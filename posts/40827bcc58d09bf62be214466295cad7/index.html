<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言练习题之 数组中出现次数超过一半的数 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/40827bcc58d09bf62be214466295cad7/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C语言练习题之 数组中出现次数超过一半的数">
  <meta property="og:description" content="题目描述 给一个长度为 n 的数组，数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。
例如输入一个长度为9的数组[1,2,3,2,2,2,5,4,2]。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。
数据范围：n≤50000，数组中元素的值0≤val≤10000
要求：空间复杂度：O(1)，时间复杂度O(n)
输入描述： 保证数组输入非空，且保证有解
示例1 输入：[1,2,3,2,2,2,5,4,2]
返回值：2
示例2 输入：[3,3,3,3,2,2,2]
返回值：3
示例3
输入：[1]
返回值：1
分析如下： 题目意思比较明确，就是要找出数组中的一个数字，这个数字在数组中出现次数超过数组长度的一半。
而题目提供的数组长度是≤50000，数组中元素的取值是 0 - 10000。
基于这些信息，很容易从循环的角度出发，对数组每个数字进行循环统计。
代码如下：
//循环法查找 int find(int arr[], int sz) { if (sz == 0)	//如果数组内没有元素，则返回-1。 return -1; int i = 0; int j = 0; for (i = 0; i &lt; sz; i&#43;&#43;)	//遍历数组，每个数都查一遍 { int count = 0; for (j = 0; j &lt; sz; j&#43;&#43;)	//数组中每个数与数组中其余数遍历一遍 { if (arr[j] == arr[i] &amp;&amp; i!">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-09-07T15:45:37+08:00">
    <meta property="article:modified_time" content="2024-09-07T15:45:37+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言练习题之 数组中出现次数超过一半的数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<h3>题目描述</h3> 
<p>给一个长度为 n 的数组，数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p> 
<p>例如输入一个长度为9的数组[1,2,3,2,2,2,5,4,2]。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。</p> 
<p></p> 
<p>数据范围：n≤50000，数组中元素的值0≤val≤10000</p> 
<p>要求：空间复杂度：O(1)，时间复杂度O(n)</p> 
<h4>输入描述：</h4> 
<p>保证数组输入非空，且保证有解</p> 
<h6>示例1</h6> 
<p>输入：[1,2,3,2,2,2,5,4,2]</p> 
<p>返回值：2</p> 
<h6>示例2</h6> 
<p>输入：[3,3,3,3,2,2,2]</p> 
<p>返回值：3</p> 
<p>示例3</p> 
<p>输入：[1]</p> 
<p>返回值：1</p> 
<p></p> 
<h5>分析如下：</h5> 
<p>        题目意思比较明确，就是要找出数组中的一个数字，这个数字在数组中出现次数超过数组长度的一半。</p> 
<p>        而题目提供的数组长度是≤50000，数组中元素的取值是 0 - 10000。</p> 
<p>        基于这些信息，很容易从循环的角度出发，对数组每个数字进行循环统计。</p> 
<p>代码如下：</p> 
<pre><code class="language-cpp">//循环法查找
int find(int arr[], int sz)
{
	if (sz == 0)		//如果数组内没有元素，则返回-1。
		return -1;
	int i = 0;
	int j = 0;
	for (i = 0; i &lt; sz; i++)	//遍历数组，每个数都查一遍
	{
		int count = 0;
		for (j = 0; j &lt; sz; j++)	//数组中每个数与数组中其余数遍历一遍
		{
			if (arr[j] == arr[i] &amp;&amp; i!= j)	//遍历过程中，与第i个数值相同，则计数+1，
			{
				count++;
			}
			if (count &gt; sz / 2)	//当计数大于数组一半时，返回该数值。
				return arr[i];
		}
	}
}</code></pre> 
<p>        可以看到，循环法做起来很简单。但题目要求空间复杂度：O(1)，时间复杂度O(n)。空间复杂度：O(1)，即占用的内存空间不以数据量的变化而变化，无论多少数据，函数占用的内存是固定的；时间复杂度O(n)，即花费的时间与数组元素成正比。</p> 
<p>        上述解法中，空间复杂度满足，时间复杂度不满足，所以需要改进。之前我们介绍过用空间换时间的思路，即将所有可能的情况都列举出来，这里可以用一样的思路。</p> 
<p>        根据题意，所求的返回值一定是 0-10000 这10001个数中的一个，所以如果提供一个容量为10001的数组，就可以把所求值的所有情况包含进去。然后遍历一遍即可。</p> 
<p>代码如下：</p> 
<pre><code class="language-cpp">
int find(int arr[], int sz)
{
	if (sz == 0)		//如果数组内没有元素，则返回-1。
		return -1;
	int i = 0;
	int j = 0;
	int count[10001] = { 0 };	
	//题目中数组arr的取值范围是0-10000，则满足条件的数一定在这10001个数中
	//建立一个数组，包含10001个元素，对应arr数组中可能出现的10001种数值
	for (i = 0; i &lt; sz; i++)	//遍历数组，对每种元素进行统计
		count[arr[i]]++;	//对arr数组中每种数值计数
	//如果arr数组中1出现了10次，则count[1]就是10；
	//5出现1000次，则count[5]就是1000；
	//假设n出现次数超出arr数组元素数一半，则n就是要找的值，即count[n] &gt; sz/2

	for (i = 0; i &lt; 10001; i++)	//遍历count数组
	{
		if (count[i] &gt; sz / 2)	//找出满足条件的n
			return i;			//返回该值
	}
}</code></pre> 
<p>        这个思路可以算是穷举法。遍历过程中，arr数组中出现哪个数值，就对计数数组的对应位元素+1，统计出arr数组中每个数出现的个数，然后对技术数组遍历一遍，就能找到出现次数超过一半的数字了。</p> 
<p>        这里空间复杂度是固定值，满足条件，时间复杂度是n+10001，也满足条件。但是占用空间过大，时间也较长，不符合实际，所以我们需要再优化。</p> 
<p>        根据题意，所求的值 a 在数组中出现的次数一定是大于一半的。也就是说，如果对数组中的元素进行遍历，与 a 相同的数量减去与 a 不同的数量，结果一定大于0。</p> 
<p>        那么我们假设一个 a ，从第一个数开始计算，与 a 相同则计数+1，不同则计数-1。若 a 是所求值，则最终结果大于0，返回 a；若 a 不是所求值，则将可能值赋给 a，继续计数，找到统计结果大于0的，就是所求值。</p> 
<p>代码如下：</p> 
<pre><code class="language-cpp">//优化解法
//前述解法占用内存空间太大，满足题目要求，但不符合实际。对其进行优化
//根据题意可以想到，返回值出现的次数比其余所有值出现的次数总和都多
//那么对数组元素进行计数，与返回值相同则数值+1，不同则数值-1
//因为返回值占总数一半以上，所以最后统计的数值一定大于0
//基于这个思路，从第一个元素开始计数，后一个元素与其不相等，则计数-1；相等则计数+1；
//当计数小于0时，则更换为新元素
//由于返回值占总数一半以上，所以其统计值最终必然大于0
int find(int* arr, int sz)
{
	if (sz == 0)	//如果数组内没有元素，则返回-1。
		return -1;
	int i = 0;
	int	count = 0;
	int a = arr[0];	//初始参考值设为数组第一个元素
	for (i = 0; i &lt; sz; i++)	//遍历一遍，进行计数
	{
		if (arr[i] == a)	//第i个元素与参考值相同则计数+1
			count++;
		else				//第i个元素与参考值不相同时分项处理
		{
			if (count &gt; 0)	//当之前计数大于0，则计数-1
				count--;
			else			//当之前计数为0，则将arr[i]赋值给参考值a，并计数为1
			{
				a = arr[i];
				count = 1;
			}
		}
	}
	return a;	//返回参考值
}
//可以看到，上述解法中，每个数值会统计一次，假设所求值是n
//参考值为n时，比较值为n， + 1，比较值为其他数， - 1；最后大于0
//参考值不为n时，比较值为n， - 1，比较值为其他数， + 1或 - 1；最后小于0，变为n，大于0
//占用内存少，且时间复杂度为O(n)，满足题目要求</code></pre> 
<p>        可以看到，如果参考值是所求值 a，比较结束，最后结果大于0。如果参考值不是所求值 a，会被赋新值，因为所求值出现的总数最高，则遍历之后，最后 a一定会被赋值为所求值，比较结束后，结果也一定大于0。而大于0作为判断条件，就可以筛选出正确结果。</p> 
<p>        这种解法的空间复杂度是固定值，且比较小，时间复杂度为n，满足题意。</p> 
<p>        此方法细想容易绕晕，只要抓住核心，所求值 a 的数量占总数一半以上，就比较好理解了。以此核心为基础，在其为参考值时进行加法运算，其他数为参考值时进行减法运算，即可求得结果。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/71936fbf73b9a09610b468821dc568ff/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Python 千题 —— 算法篇】无重复字符最长子段</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f1d2e4785a38f00d4948f93a3f0ee29b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【第0007页 · 数组】数组中重复的数据（如何实现数组的原地修改）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>