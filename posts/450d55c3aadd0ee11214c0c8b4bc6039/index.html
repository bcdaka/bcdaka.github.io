<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>基于AOP的数据字典实现：实现前端下拉框的可配置更新 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/450d55c3aadd0ee11214c0c8b4bc6039/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="基于AOP的数据字典实现：实现前端下拉框的可配置更新">
  <meta property="og:description" content="作者：后端小肥肠
创作不易，未经允许严禁转载。
目录
1. 前言
2. 数据字典
2.1. 数据字典简介
2.2. 数据字典如何管理各模块的下拉框
3. 数据字典核心内容解读
3.1. 表结构
3.2. 核心代码 3.2.1. 根据实体类名称获取下属数据字典
3.2.2. 数据字典AOP切面
3.2.2.1. 场景模拟
3.2.2.2. 数据字典交互流程
3.2.2.3. AOP代码
4. 数据字典使用
4.1. 新增Student类对应数据字典值
4.2. 新增学生数据
4.3. 根据id查询学生数据详细信息
5. 结语
6. 参考链接
1. 前言 在现代软件开发中，数据字典作为管理系统常量和配置项的重要工具，其灵活性和可维护性对系统的健壮性起着至关重要的作用。然而，传统的数据字典与业务模块的整合方式往往存在着严重的耦合问题。通常情况下，为了在业务模块中使用数据字典的标签（label），我们不得不在VO类中添加字段，并通过查询数据字典来获取对应的标签值，这种做法不仅增加了代码的复杂性，还使得业务模块与数据字典的耦合度过高，不利于系统的模块化和扩展。
本文将探讨如何利用面向切面编程（AOP）的思想，通过注解的方式实现数据字典与其他业务模块的无侵入性整合。我们将重点关注如何通过AOP技术，使数据字典的值（value）在业务模块中自动转换为其对应的标签（label），从而实现业务逻辑与数据字典的松耦合，为系统的可维护性和拓展性提供新的解决方案。
2. 数据字典 2.1. 数据字典简介 数据字典是软件系统中用于管理常量、配置项或者枚举值的集合。它通常包括标签（label）和值（value）两部分，标签用于展示给用户或者其他系统模块，而值则是实际的业务逻辑中使用的数据标识。我举个例子吧，比如前端下拉框的渲染：
我们来看一下前端代码：
&lt;template&gt; &lt;el-select v-model=&#34;value&#34; placeholder=&#34;请选择&#34;&gt; &lt;el-option v-for=&#34;item in options&#34; :key=&#34;item.value&#34; :label=&#34;item.label&#34; :value=&#34;item.value&#34;&gt; &lt;/el-option&gt; &lt;/el-select&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { options: [{ value: &#39;选项1&#39;, label: &#39;黄金糕&#39; }, { value: &#39;选项2&#39;, label: &#39;双皮奶&#39; }, { value: &#39;选项3&#39;, label: &#39;蚵仔煎&#39; }, { value: &#39;选项4&#39;, label: &#39;龙须面&#39; }, { value: &#39;选项5&#39;, label: &#39;北京烤鸭&#39; }], value: &#39;&#39; } } } &lt;/script&gt; 从前端代码可看出 下拉框的渲染主要依靠value和label，常规的做法有枚举，或者后端建表后从表中获取，这两种方法都有许多弊端，枚举的话需要开发人员写死在代码中，再来看建表，如果每个下拉框都建表，那就会浪费大量后端资源，采用数据字典，统一管理各个功能模块的下拉框是较优的选择。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-07T16:58:45+08:00">
    <meta property="article:modified_time" content="2024-07-07T16:58:45+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">基于AOP的数据字典实现：实现前端下拉框的可配置更新</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><span style="color:#4da8ee;"><strong>作者：后端小肥肠</strong></span></p> 
 <p><span style="color:#0d0016;">创作不易，未经允许严禁转载。</span></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%20%E5%89%8D%E8%A8%80-toc" style="margin-left:40px;"><a href="#1.%20%E5%89%8D%E8%A8%80" rel="nofollow">1. 前言</a></p> 
<p id="2.%20%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8-toc" style="margin-left:40px;"><a href="#2.%20%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8" rel="nofollow">2. 数据字典</a></p> 
<p id="2.1.%20%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8%E7%AE%80%E4%BB%8B-toc" style="margin-left:80px;"><a href="#2.1.%20%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8%E7%AE%80%E4%BB%8B" rel="nofollow">2.1. 数据字典简介</a></p> 
<p id="2.2.%20%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E5%90%84%E6%A8%A1%E5%9D%97%E7%9A%84%E4%B8%8B%E6%8B%89%E6%A1%86-toc" style="margin-left:80px;"><a href="#2.2.%20%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E5%90%84%E6%A8%A1%E5%9D%97%E7%9A%84%E4%B8%8B%E6%8B%89%E6%A1%86" rel="nofollow">2.2. 数据字典如何管理各模块的下拉框</a></p> 
<p id="3.%20%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9%E8%A7%A3%E8%AF%BB-toc" style="margin-left:40px;"><a href="#3.%20%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9%E8%A7%A3%E8%AF%BB" rel="nofollow">3. 数据字典核心内容解读</a></p> 
<p id="3.1.%20%E8%A1%A8%E7%BB%93%E6%9E%84-toc" style="margin-left:80px;"><a href="#3.1.%20%E8%A1%A8%E7%BB%93%E6%9E%84" rel="nofollow">3.1. 表结构</a></p> 
<p id="3.2.%20%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%C2%A0-toc" style="margin-left:80px;"><a href="#3.2.%20%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%C2%A0" rel="nofollow">3.2. 核心代码 </a></p> 
<p id="3.2.1.%20%E6%A0%B9%E6%8D%AE%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%90%8D%E7%A7%B0%E8%8E%B7%E5%8F%96%E4%B8%8B%E5%B1%9E%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8-toc" style="margin-left:120px;"><a href="#3.2.1.%20%E6%A0%B9%E6%8D%AE%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%90%8D%E7%A7%B0%E8%8E%B7%E5%8F%96%E4%B8%8B%E5%B1%9E%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8" rel="nofollow">3.2.1. 根据实体类名称获取下属数据字典</a></p> 
<p id="3.2.2.%20%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8AOP%E5%88%87%E9%9D%A2-toc" style="margin-left:120px;"><a href="#3.2.2.%20%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8AOP%E5%88%87%E9%9D%A2" rel="nofollow">3.2.2. 数据字典AOP切面</a></p> 
<p id="3.2.2.1.%20%E5%9C%BA%E6%99%AF%E6%A8%A1%E6%8B%9F-toc" style="margin-left:160px;"><a href="#3.2.2.1.%20%E5%9C%BA%E6%99%AF%E6%A8%A1%E6%8B%9F" rel="nofollow">3.2.2.1. 场景模拟</a></p> 
<p id="3.2.2.2.%20%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B-toc" style="margin-left:160px;"><a href="#3.2.2.2.%20%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B" rel="nofollow">3.2.2.2. 数据字典交互流程</a></p> 
<p id="3.2.2.3.%20AOP%E4%BB%A3%E7%A0%81-toc" style="margin-left:160px;"><a href="#3.2.2.3.%20AOP%E4%BB%A3%E7%A0%81" rel="nofollow">3.2.2.3. AOP代码</a></p> 
<p id="4.%20%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#4.%20%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8%E4%BD%BF%E7%94%A8" rel="nofollow">4. 数据字典使用</a></p> 
<p id="4.1.%20%E6%96%B0%E5%A2%9EStudent%E7%B1%BB%E5%AF%B9%E5%BA%94%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8%E5%80%BC-toc" style="margin-left:80px;"><a href="#4.1.%20%E6%96%B0%E5%A2%9EStudent%E7%B1%BB%E5%AF%B9%E5%BA%94%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8%E5%80%BC" rel="nofollow">4.1. 新增Student类对应数据字典值</a></p> 
<p id="4.2.%20%E6%96%B0%E5%A2%9E%E5%AD%A6%E7%94%9F%E6%95%B0%E6%8D%AE-toc" style="margin-left:80px;"><a href="#4.2.%20%E6%96%B0%E5%A2%9E%E5%AD%A6%E7%94%9F%E6%95%B0%E6%8D%AE" rel="nofollow">4.2. 新增学生数据</a></p> 
<p id="4.3.%20%E6%A0%B9%E6%8D%AEid%E6%9F%A5%E8%AF%A2%E5%AD%A6%E7%94%9F%E6%95%B0%E6%8D%AE%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF-toc" style="margin-left:80px;"><a href="#4.3.%20%E6%A0%B9%E6%8D%AEid%E6%9F%A5%E8%AF%A2%E5%AD%A6%E7%94%9F%E6%95%B0%E6%8D%AE%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF" rel="nofollow">4.3. 根据id查询学生数据详细信息</a></p> 
<p id="5.%20%E7%BB%93%E8%AF%AD-toc" style="margin-left:40px;"><a href="#5.%20%E7%BB%93%E8%AF%AD" rel="nofollow">5. 结语</a></p> 
<p id="6.%20%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5-toc" style="margin-left:40px;"><a href="#6.%20%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5" rel="nofollow">6. 参考链接</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="1.%20%E5%89%8D%E8%A8%80">1. 前言</h3> 
<p>在现代软件开发中，数据字典作为管理系统常量和配置项的重要工具，其灵活性和可维护性对系统的健壮性起着至关重要的作用。然而，传统的数据字典与业务模块的整合方式往往存在着严重的耦合问题。通常情况下，为了在业务模块中使用数据字典的标签（label），我们不得不在VO类中添加字段，并通过查询数据字典来获取对应的标签值，这种做法不仅增加了代码的复杂性，还使得业务模块与数据字典的耦合度过高，不利于系统的模块化和扩展。</p> 
<p>本文将探讨如何利用面向切面编程（AOP）的思想，通过注解的方式实现数据字典与其他业务模块的无侵入性整合。我们将重点关注如何通过AOP技术，使数据字典的值（value）在业务模块中自动转换为其对应的标签（label），从而实现业务逻辑与数据字典的松耦合，为系统的可维护性和拓展性提供新的解决方案。</p> 
<h3 id="2.%20%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8">2. 数据字典</h3> 
<h4 id="2.1.%20%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8%E7%AE%80%E4%BB%8B">2.1. 数据字典简介</h4> 
<p>数据字典是软件系统中用于管理常量、配置项或者枚举值的集合。它通常包括标签（label）和值（value）两部分，标签用于展示给用户或者其他系统模块，而值则是实际的业务逻辑中使用的数据标识。我举个例子吧，比如前端下拉框的渲染：</p> 
<p><img alt="" height="402" src="https://images2.imgbox.com/69/fc/hEHYEUoU_o.png" width="682"></p> 
<p>我们来看一下前端代码：</p> 
<pre><code class="language-javascript">&lt;template&gt;
  &lt;el-select v-model="value" placeholder="请选择"&gt;
    &lt;el-option
      v-for="item in options"
      :key="item.value"
      :label="item.label"
      :value="item.value"&gt;
    &lt;/el-option&gt;
  &lt;/el-select&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        options: [{
          value: '选项1',
          label: '黄金糕'
        }, {
          value: '选项2',
          label: '双皮奶'
        }, {
          value: '选项3',
          label: '蚵仔煎'
        }, {
          value: '选项4',
          label: '龙须面'
        }, {
          value: '选项5',
          label: '北京烤鸭'
        }],
        value: ''
      }
    }
  }
&lt;/script&gt;</code></pre> 
<p>从前端代码可看出 下拉框的渲染主要依靠<strong>value</strong>和<strong>label</strong>，常规的做法有枚举，或者后端建表后从表中获取，这两种方法都有许多弊端，枚举的话需要开发人员写死在代码中，再来看建表，如果每个下拉框都建表，那就会浪费大量后端资源，采用数据字典，统一管理各个功能模块的下拉框是较优的选择。</p> 
<h4 id="2.2.%20%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E5%90%84%E6%A8%A1%E5%9D%97%E7%9A%84%E4%B8%8B%E6%8B%89%E6%A1%86">2.2. 数据字典如何管理各模块的下拉框</h4> 
<p>数据字典中是如何把各模块的下拉框管理起来的，在数据字典中一共管理三块内容，分别是实体类（表），属性字段，属性字段值（数据字典value和label）；以前端的视角来看就是表单，下拉框，下拉框的值（数据字典label和value）。</p> 
<p><img alt="" height="481" src="https://images2.imgbox.com/7a/19/sjR5eIm8_o.png" width="803"></p> 
<h3 id="3.%20%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9%E8%A7%A3%E8%AF%BB" style="background-color:transparent;">3. 数据字典核心内容解读</h3> 
<h4 id="3.1.%20%E8%A1%A8%E7%BB%93%E6%9E%84">3.1. 表结构</h4> 
<p>数据字典一共涵盖两张表，分别为dictionary_type和dictionary_value，下面将分别对这两张表进行解释。</p> 
<p><img alt="" height="680" src="https://images2.imgbox.com/9f/99/MomtDZlQ_o.png" width="1200"></p> 
<p></p> 
<p><span style="color:#956fe7;"><strong>dict</strong></span><span style="color:#956fe7;"><strong>ionary_type</strong></span></p> 
<pre><code class="language-sql">CREATE TABLE "public"."dictionary_type" (
  "id" varchar(32) COLLATE "pg_catalog"."default" NOT NULL,
  "type_name" varchar(50) COLLATE "pg_catalog"."default",
  "type_description" varchar(100) COLLATE "pg_catalog"."default",
  "parent_id" varchar(32) COLLATE "pg_catalog"."default",
  "create_time" timestamp(6),
  "update_time" timestamp(6),
  "version" int4 DEFAULT 1,
  "type_label" varchar(50) COLLATE "pg_catalog"."default",
  "is_deleted" int2 DEFAULT 0,
  CONSTRAINT "dictionary_type_pkey" PRIMARY KEY ("id")
)
;

ALTER TABLE "public"."dictionary_type" 
  OWNER TO "postgres";

COMMENT ON COLUMN "public"."dictionary_type"."id" IS '主键ID';

COMMENT ON COLUMN "public"."dictionary_type"."type_name" IS '字典类型名称';

COMMENT ON COLUMN "public"."dictionary_type"."type_description" IS '字典类型描述';

COMMENT ON COLUMN "public"."dictionary_type"."parent_id" IS '父节点id';

COMMENT ON COLUMN "public"."dictionary_type"."create_time" IS '创建时间';

COMMENT ON COLUMN "public"."dictionary_type"."update_time" IS '更新时间';

COMMENT ON COLUMN "public"."dictionary_type"."version" IS '乐观锁';

COMMENT ON COLUMN "public"."dictionary_type"."type_label" IS '字典类型标签';

COMMENT ON TABLE "public"."dictionary_type" IS '字典类型表';</code></pre> 
<p><span style="color:#0d0016;"> <strong>dictionary_type</strong>表管理实体类和属性字段，当parent_id为null时则该数据为实体类，否则为归属某实体类下的属性字段。</span></p> 
<p><span style="color:#956fe7;"><strong>dictionary_value</strong></span></p> 
<pre><code class="language-sql">CREATE TABLE "public"."dictionary_value" (
  "id" varchar(32) COLLATE "pg_catalog"."default" NOT NULL,
  "value_name" varchar(50) COLLATE "pg_catalog"."default",
  "type_id" varchar(32) COLLATE "pg_catalog"."default",
  "create_time" timestamp(6),
  "update_time" timestamp(6),
  "version" int4 DEFAULT 1,
  "value_label" varchar(50) COLLATE "pg_catalog"."default",
  "value_sort" int4,
  "is_deleted" int2,
  CONSTRAINT "dictionary_value_pkey" PRIMARY KEY ("id")
)
;

ALTER TABLE "public"."dictionary_value" 
  OWNER TO "postgres";

COMMENT ON COLUMN "public"."dictionary_value"."id" IS '主键ID';

COMMENT ON COLUMN "public"."dictionary_value"."value_name" IS '字典值名称';

COMMENT ON COLUMN "public"."dictionary_value"."type_id" IS '字典类型id';

COMMENT ON COLUMN "public"."dictionary_value"."create_time" IS '创建时间';

COMMENT ON COLUMN "public"."dictionary_value"."update_time" IS '更新时间';

COMMENT ON COLUMN "public"."dictionary_value"."version" IS '乐观锁';

COMMENT ON COLUMN "public"."dictionary_value"."value_label" IS '字典值标签';

COMMENT ON COLUMN "public"."dictionary_value"."value_sort" IS '字典值排序';

COMMENT ON TABLE "public"."dictionary_value" IS '字典值表';</code></pre> 
<p><span style="color:#956fe7;"><strong>dictionary_value</strong> </span><span style="color:#0d0016;">中管理某实体类下属性字段多对应的数据字典（label和value）。</span><span style="color:#956fe7;"><strong>dictionary_value</strong> </span>和<span style="color:#956fe7;"><strong>dictionary_type</strong></span><span style="color:#0d0016;">为多对一的关系（一个属性字段下对应多个数据字典值）。</span></p> 
<h4 id="3.2.%20%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%C2%A0" style="background-color:transparent;">3.2. 核心代码 </h4> 
<h5 id="3.2.1.%20%E6%A0%B9%E6%8D%AE%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%90%8D%E7%A7%B0%E8%8E%B7%E5%8F%96%E4%B8%8B%E5%B1%9E%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8" style="background-color:transparent;">3.2.1. 根据实体类名称获取下属数据字典</h5> 
<p><span style="color:#956fe7;"><strong>controller层</strong></span></p> 
<pre><code class="language-java">    /**
     * 获取模块数据字典
     * @param typeName
     * @return
     */
    @ApiOperation("获取某个模块下的数据字典")
    @GetMapping("/parameter/{typeName}")
    Map&lt;String, Object&gt; getCompleteParameter(@PathVariable("typeName") String typeName){
        return iDictionaryValueService.getParameters(typeName);
    }</code></pre> 
<p>在上述代码中typeName为实体类名称。 </p> 
<p><span style="color:#956fe7;"><strong>service层</strong></span></p> 
<pre><code class="language-java">    public Map&lt;String, Object&gt; getParameters(String typeName) {
        List&lt;Map&lt;String, Object&gt;&gt; dictParameters=baseMapper.getDictParameters(typeName);
        Set&lt;Object&gt; typeSet= new HashSet&lt;&gt;();
        Map&lt;String,Object&gt;resParam=new HashMap&lt;&gt;();
        for (Map&lt;String, Object&gt; dictParameter : dictParameters) {
            typeSet.add(dictParameter.get("type_name").toString());
        }
        for (Object o : typeSet) {
            List&lt;ParameterVO&gt; parameterVoList = new ArrayList&lt;&gt;();
            for (Map&lt;String, Object&gt; dictParameter : dictParameters) {
                if(dictParameter.get("type_name").toString().equals(o.toString())){
                    ParameterVO parameterVO=new ParameterVO(dictParameter.get("value_name").toString(),dictParameter.get("value_label").toString());
                    parameterVoList.add(parameterVO);
                }
            }
            resParam.put(o.toString(),parameterVoList);
        }
        return resParam;
    }</code></pre> 
<p><span style="color:#956fe7;"><strong>mapper层</strong></span></p> 
<pre><code class="language-java">@Select("select a.value_name,a.value_label,a.type_name from  dictionary_type d JOIN  (select v.value_name,v.value_label,t.type_name,t.parent_id from dictionary_value v,dictionary_type t where v.type_id=t.id and  v.is_deleted = 0 and t.is_deleted = 0)a on a.parent_id=d.id where d.type_name =#{typeName} AND d.is_deleted = 0")
    List&lt;Map&lt;String, Object&gt;&gt; getDictParameters(@Param("typeName") String typeName);</code></pre> 
<h5 id="3.2.2.%20%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8AOP%E5%88%87%E9%9D%A2" style="background-color:transparent;">3.2.2. 数据字典AOP切面</h5> 
<h6 id="3.2.2.1.%20%E5%9C%BA%E6%99%AF%E6%A8%A1%E6%8B%9F" style="background-color:transparent;">3.2.2.1. 场景模拟</h6> 
<p>先预设一个场景，假设有一张学生表需要整合数据字典，表结构如下：</p> 
<pre><code class="language-sql">CREATE TABLE "public"."student" (
  "id" varchar(32) COLLATE "pg_catalog"."default" NOT NULL,
  "name" varchar(50) COLLATE "pg_catalog"."default",
  "blood_type" varchar(10) COLLATE "pg_catalog"."default",
  "constellation_type" varchar(10) COLLATE "pg_catalog"."default",
  "create_time" timestamp(6),
  "update_time" timestamp(6),
  "version" int4 DEFAULT 1,
  "is_deleted" int2 DEFAULT 0,
  CONSTRAINT "student_pkey" PRIMARY KEY ("id")
)
;

ALTER TABLE "public"."student" 
  OWNER TO "postgres";

COMMENT ON COLUMN "public"."student"."blood_type" IS '血型';

COMMENT ON COLUMN "public"."student"."constellation_type" IS '星座类型';</code></pre> 
<p>在上表中星座和血型为需要和数据字典集成的字段。 </p> 
<h6 id="3.2.2.2.%20%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B" style="background-color:transparent;">3.2.2.2. 数据字典交互流程</h6> 
<p>AOP切面主要使用在分页查询和查询详情时。与数据字典有交集的实体类（Student）在分页或查询详情时技术流程图如下：</p> 
<p><img alt="" height="321" src="https://images2.imgbox.com/db/ae/bCp83qAm_o.png" width="1200"></p> 
<p>在上图中可看出与数据字典有交集的模块要进行分页或查询详情时，需要远程调用数据字典模块的相关接口，通过数据表中的value查询数据字典对应的label，最后封装为vo类返回给前端，如果把这个逻辑以硬编码的形式内嵌到查询详情代码中的话，有个比较致命的缺点就是代码的耦合性太高了，不利于模块的迁移复用。</p> 
<p><img alt="" height="166" src="https://images2.imgbox.com/0f/47/1d4GxkHx_o.png" width="947"></p> 
<p> 上述代码为查看详情的部分代码，在封装VO类时进行了硬编码，可以看出，在耦合性极高的同时，代码的可读性也较差，故引入AOP切面，将远程调用label和将label值更新至VO类写入AOP切面。 </p> 
<h6 id="3.2.2.3.%20AOP%E4%BB%A3%E7%A0%81" style="background-color:transparent;">3.2.2.3. AOP代码</h6> 
<p>数据字典AOP注解，它的作用是用于标记类的字段，指示字段的字典类型，并且在序列化过程中使用自定义的序列化器进行处理。</p> 
<pre><code class="language-java">@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@JacksonAnnotationsInside
@JsonSerialize(using = DictSerializer.class)
public @interface Dict {
    /** 字典类型 */
    String type();
}
</code></pre> 
<p>通过 <code>@JsonSerialize(using = DictSerializer.class)</code>，我们告诉 Jackson 在对带有 <code>@Dict</code> 注解的字段进行序列化时，使用 <code>DictSerializer</code> 类来处理序列化过程。</p> 
<p>数据字典序列化类： </p> 
<pre><code class="language-java">@Component
public class DictSerializer extends StdSerializer&lt;Object&gt; implements ContextualSerializer {
    private IDictionaryValueService dictionaryValueService;
    private String type;

    @Autowired
    public DictSerializer(IDictionaryValueService dictionaryValueService) {
        super(Object.class);
        this.dictionaryValueService = dictionaryValueService;
    }

    public DictSerializer(String type, IDictionaryValueService dictionaryValueService) {
        super(Object.class);
        this.type = type;
        this.dictionaryValueService = dictionaryValueService;
    }

    @Override
    public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {
        if (Objects.isNull(value)) {
            gen.writeObject(value);
            return;
        }

        String label = null;
        if (dictionaryValueService != null &amp;&amp; type != null) {
            try {
                String response = dictionaryValueService.getLabelByValue(value.toString());
                label = response; // 设置为空时返回 "null"
            } catch (RuntimeException e) {
                label = null;
            }
        }
        gen.writeObject(value);
        gen.writeFieldName(gen.getOutputContext().getCurrentName() + "Label");
        gen.writeObject(label);
    }

    @Override
    public JsonSerializer&lt;?&gt; createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException {
        if (property != null) {
            Dict dict = property.getAnnotation(Dict.class);
            if (dict != null) {
                return new DictSerializer(dict.type(), dictionaryValueService);
            }
        }
        return this;
    }


}</code></pre> 
<p><code>DictSerializer</code> 是一个用于处理带有 <code>@Dict</code> 注解字段的自定义 Jackson 序列化器。它利用注入的 <code>IDictionaryValueService</code> 接口，根据字段值获取对应的标签，并将原始值与标签作为新字段输出，实现了动态字典值的序列化处理。</p> 
<p><span style="color:#956fe7;"><strong>我写的示例代码把AOP相关代码写到了数据字典模块，但是实际项目中应当放到common模块，方便所有和数据字典有交集的业务模块调用。</strong></span></p> 
<h3 id="4.%20%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8%E4%BD%BF%E7%94%A8" style="background-color:transparent;">4. 数据字典使用</h3> 
<p>基于第3章预设的场景，我们这章直接实操来看一下如何使用数据字典（ps，我将Student类相关代码写到了数据字典中，实际应该是在别的模块，这里为了方便我就写到了一个模块）。</p> 
<h4 id="4.1.%20%E6%96%B0%E5%A2%9EStudent%E7%B1%BB%E5%AF%B9%E5%BA%94%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8%E5%80%BC" style="background-color:transparent;">4.1. 新增Student类对应数据字典值</h4> 
<p>新增dictionary_type表数据：</p> 
<p><img alt="" height="181" src="https://images2.imgbox.com/19/44/75vDgx4Y_o.png" width="1200"></p> 
<p>新增dictionary_value 表数据：</p> 
<p><img alt="" height="275" src="https://images2.imgbox.com/a1/f1/di14UMpv_o.png" width="1200"></p> 
<p>根据实体类名获取该实体类对应的数据字典，返回至前端进行下拉框动态渲染：</p> 
<p><img alt="" height="890" src="https://images2.imgbox.com/bb/08/ZkhBWju2_o.png" width="1200"></p> 
<h4 id="4.2.%20%E6%96%B0%E5%A2%9E%E5%AD%A6%E7%94%9F%E6%95%B0%E6%8D%AE">4.2. 新增学生数据</h4> 
<p>这里新增和平时操作无异：</p> 
<pre><code class="language-java">    @PostMapping("")
    public boolean saveStudent(@RequestBody Student student){
      return  studentService.save(student);
    }</code></pre> 
<p>在传数据字典值时只需要传入value值即可：</p> 
<p><img alt="" height="890" src="https://images2.imgbox.com/63/05/siuYuEwL_o.png" width="1200"> </p> 
<h4 id="4.3.%20%E6%A0%B9%E6%8D%AEid%E6%9F%A5%E8%AF%A2%E5%AD%A6%E7%94%9F%E6%95%B0%E6%8D%AE%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF" style="background-color:transparent;">4.3. 根据id查询学生数据详细信息</h4> 
<p><span style="color:#956fe7;"><strong>编写VO类：</strong></span></p> 
<pre><code class="language-java">@Data
public class StudentVO {
    private String id;

    private String name;

    @Dict(type = "bloodType")
    private String bloodType;
    
    @Dict(type = "constellationType")
    private String constellationType;

    @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    @JsonFormat(pattern="yyyy-MM-dd HH:mm:ss",timezone="GMT+8")
    private Date createTime;
}
</code></pre> 
<p><span style="color:#956fe7;"><strong>查看详情方法：</strong></span></p> 
<pre><code class="language-java">   public StudentVO getStudentInfoById(String id) {
        Student student = baseMapper.selectById(id);
        StudentVO studentVO= BeanCopyUtils.copyBean(student,StudentVO.class);
        return studentVO;
    }</code></pre> 
<p><span style="color:#956fe7;"><strong>运行结果：</strong></span></p> 
<p><img alt="" height="890" src="https://images2.imgbox.com/51/7c/zPGxIN2E_o.png" width="1200"></p> 
<h3 id="5.%20%E7%BB%93%E8%AF%AD" style="background-color:transparent;">5. 结语</h3> 
<p>本文探讨了如何通过面向切面编程（AOP）实现数据字典与业务模块的无侵入整合。通过自定义注解和序列化器，我们有效地降低了系统中业务模块与数据字典的耦合度，提升了系统的灵活性和可维护性。希望本文能为读者在实际项目中应用这些技术提供启发，进一步提升软件开发的效率和质量。若本文对你有帮助，别忘记三连哦~</p> 
<p><img alt="" height="383" src="https://images2.imgbox.com/bc/a2/mXuImdQm_o.jpg" width="900"></p> 
<h3 id="6.%20%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">6. 参考链接</h3> 
<p><a href="https://juejin.cn/post/7104530636794232862" rel="nofollow" title="基于Springboot，一个注解搞定数据字典问题 - 掘金 (juejin.cn)">基于Springboot，一个注解搞定数据字典问题 - 掘金 (juejin.cn)</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5d0cc1830dbc6ba5774fd030c4db1368/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Linux详解】进程等待 | 非阻塞轮询</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b4273f1fe8fe215c138278ca3ea459c6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">时间处理的未来：Java 8全新日期与时间API完全解析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>