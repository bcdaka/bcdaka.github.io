<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>前端对接fastGPT流式数据&#43;打字机效果 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/41c06674513080b4b05979debb3954cb/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="前端对接fastGPT流式数据&#43;打字机效果">
  <meta property="og:description" content="首先在对接api时 参数要设置stream: true,
const data = { chatId: &#39;abc&#39;, stream: true,//这里true返回流式数据 detail: false, variables: { uid: &#39;sfdsdf&#39;, name: &#39;zhaoyunyao,&#39; }, messages: [{ content: text, role: &#39;user&#39; }] }; 不要用axios发请求 不然处理不了流式数据 我这里使用fetch
const response = await fetch(`${url}`, { method: &#39;post&#39;, headers: headers, body: JSON.stringify(data) }); const reader = response.body.getReader(); //创建了一个读取器对象，用于从响应主体中读取数据。response.body 是一个 ReadableStream 对象，通过调用 getReader() 方法可以获取一个读取器对象，以便逐步读取响应的内容。 // 循环读取响应流 while (true) { const { done, value } = await reader.read(); if (done) break; // 将ArrayBuffer转为文本 const chunk = new TextDecoder(&#39;utf-8&#39;).">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-11T15:44:33+08:00">
    <meta property="article:modified_time" content="2024-04-11T15:44:33+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">前端对接fastGPT流式数据&#43;打字机效果</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>首先在对接api时 参数要设置stream: true,</p> 
<pre><code class="language-javascript">      const data = {
        chatId: 'abc',
        stream: true,//这里true返回流式数据
        detail: false,
        variables: {
          uid: 'sfdsdf',
          name: 'zhaoyunyao,'
        },
        messages: [{ content: text, role: 'user' }]
      };</code></pre> 
<blockquote> 
 <p>不要用axios发请求 不然处理不了流式数据 我这里使用fetch</p> 
</blockquote> 
<pre><code class="language-javascript">        const response = await fetch(`${url}`, {
          method: 'post',
          headers: headers,
          body: JSON.stringify(data)
        });
        const reader = response.body.getReader();
        //创建了一个读取器对象，用于从响应主体中读取数据。response.body 是一个 ReadableStream 对象，通过调用 getReader() 方法可以获取一个读取器对象，以便逐步读取响应的内容。
        // 循环读取响应流
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          // 将ArrayBuffer转为文本
          const chunk = new TextDecoder('utf-8').decode(value);
          // 处理文本为json格式
          const jsonArr = chunk.trim().replace(/\n/g, '').split('data: ').splice(1)
          for (let index = 0; index &lt; jsonArr.length; index++) {
            const json = jsonArr[index];
            try {
              if (JSON.parse(json).choices) {
                const text = JSON.parse(json).choices[0].delta.content ?? ''
                content += text.replace(/^\n/g, '')
              } else {
                content = "内部出了问题o(╥﹏╥)o"
              }
            } catch {
              // 处理转json不报错
            }
          }
          obj.content = content //这里的content就是最终输出的文本
        }</code></pre> 
<p>然后我们再加一个打字机的光标 用html+css实现</p> 
<pre><code class="language-html">              &lt;div class="chat-item-details"&gt;
                {<!-- -->{ item.content }}
                /** 这里的span就是光标 **/
                &lt;span class="cursor-blink" v-show="item.awaitReply"&gt;  &lt;/span&gt;
              &lt;/div&gt;</code></pre> 
<p>再写上对应的css </p> 
<pre><code class="language-css">              .cursor-blink {
                display: inline-block;
                height: 16px;
                margin-bottom: -3px;
                width: 2px;
                animation: blink 1s infinite steps(1, start);
              }

              /*这里设置动画blink*/
              @keyframes blink {

                0%,
                100% {
                  background-color: #000;
                  color: #aaa;
                }

                50% {
                  background-color: #bbb;
                  /* not #aaa because it's seem there is Google Chrome bug */
                  color: #000;
                }
              }</code></pre> 
<p>最后呈现的效果</p> 
<p><img alt="" height="781" src="https://images2.imgbox.com/03/a1/0hwAzR14_o.gif" width="1200"></p> 
<p>上图呈现的差不多是打字机的效果了 不过呢 但在传输过程中每次停顿后会跳出一串内容然后又停顿一会,阅读体验有些不流畅, 就像玩游戏时帧数低卡顿的感觉, 我们用一个队列让它逐字地展示出来,并且根据传输速度控制输出的速度</p> 
<blockquote> 
 <ol><li>需要一个打字机队列</li><li>队列提供入队和消费功能</li><li>需要一个动态时间来控制文字输出</li></ol> 
</blockquote> 
<p> </p> 
<pre><code class="language-javascript">    // 打字机队列
    // 添加队列
    addQueue(str,obj) {
      obj.queue.push(...str.split(''))
    },
    // 消费队列
    consume(obj) {
      if (obj.queue.length &gt; 0) {
        let str = obj.queue.shift()
        str &amp;&amp; this.onConsume(str,obj)
      } else if (obj.isDone) {
        obj.consuming = false
        clearTimeout(obj.timmer)
        obj.awaitReply = false
        this.scrollBottom()
      }
    },
    // 消费间隔
    time(obj) {
      let time = 1000 / obj.queue.length
      return time &gt; 100 ? 100 : time
    },
    // 消费下一个
    next(obj) {
      this.consume(obj)
      obj.timmer = setTimeout(() =&gt; {
        if (obj.consuming) {
          this.next(obj)
        }
      }, this.time(obj))
    },
    start(obj) {
      obj.consuming = true
      obj.isDone=false
      this.next(obj)
    },
    done(obj) {
      obj.isDone=true
    },
    onConsume(str,obj) {
      obj.content += str
    },</code></pre> 
<p> 加了过后的效果<img alt="" height="781" src="https://images2.imgbox.com/67/8a/6d8P7NuC_o.gif" width="1200"></p> 
<p>最后附上完整代码</p> 
<pre><code class="language-javascript">export default {
  data() {
    return {
      key: "xxx",
      AppId: "xx",
      text: "",
      readonly: false,
      messages: [
        { content: "您好，我是小环！请问需要什么帮助呢？", role: 'assistant', awaitReply: false },
      ],
      userImg: this.$store.getters.avatar,
      username: this.$store.getters.nickname,
      awaitReply: false,
      timmer: null,
      obj: null,
      queue: [],
      consuming: false,
      isDone: false
    }
  },
  mounted() {
    const messageTextarea = document.getElementById('messageTextarea');
    messageTextarea.addEventListener('keydown', (event) =&gt; {
      // 如果按下的是回车键（Enter）
      if (event.key === 'Enter' &amp;&amp; !event.ctrlKey) {
        event.preventDefault(); // 阻止默认的换行行为
        // 在这里可以添加发送消息的逻辑
        this.send();
      } else if (event.key === 'Enter' &amp;&amp; event.ctrlKey) {
        const cursorPosition = messageTextarea.selectionStart; // 获取光标位置
        const textBeforeCursor = messageTextarea.value.substring(0, cursorPosition); // 获取光标前的文本
        const textAfterCursor = messageTextarea.value.substring(cursorPosition); // 获取光标后的文本
        messageTextarea.value = textBeforeCursor + '\n' + textAfterCursor; // 在光标位置插入换行符
        messageTextarea.selectionStart = cursorPosition + 1; // 设置光标位置为插入换行符后的位置
        messageTextarea.selectionEnd = cursorPosition + 1;
      }
    });
  },
  methods: {
    // 打字机队列
    // 添加队列
    addQueue(str, obj) {
      obj.queue.push(...str.split(''))
    },
    // 消费队列
    consume(obj) {
      if (obj.queue.length &gt; 0) {
        let str = obj.queue.shift()
        str &amp;&amp; this.onConsume(str, obj)
      } else if (obj.isDone) {
        obj.consuming = false
        clearTimeout(obj.timmer)
        obj.awaitReply = false
        this.scrollBottom()
      }
    },
    // 消费间隔
    time(obj) {
      let time = 500 / obj.queue.length
      return time &gt; 50 ? 50 : time
    },
    // 消费下一个
    next(obj) {
      this.consume(obj)
      obj.timmer = setTimeout(() =&gt; {
        if (obj.consuming) {
          this.next(obj)
        }
      }, this.time(obj))
    },
    start(obj) {
      obj.consuming = true
      obj.isDone = false
      this.next(obj)
    },
    done(obj) {
      obj.isDone = true
    },
    onConsume(str, obj) {
      obj.content += str
    },
    async send() {
      if (this.text === "" || /^\s+$/.test(this.text)) {
        this.$message.warning('请输入内容')
        return
      }
      const text = this.text
      this.text = ""
      const url = 'https://api.fastgpt.in/api/v1/chat/completions';
      this.messages.push({ role: 'user', content: text });
      let obj = { content: "", role: 'assistant', awaitReply: true, queue: [], consuming: false, isDone: false, timmer: null }
      this.messages.push(obj);
      this.scrollBottom()
      const data = {
        // 这里可以设置请求参数
        chatId: 'abc',
        stream: true,
        detail: false,
        variables: {
          uid: 'sfdsdf',
          name: 'zhaoyunyao,'
        },
        messages: [{ content: text, role: 'user' }]
      };
      const headers = {
        // 这里可以设置请求头
        Authorization: `Bearer ${this.key}`,
        "Content-Type": "application/json"
      };
      try {
        const response = await fetch(`${url}`, {
          method: 'post',
          headers: headers,
          body: JSON.stringify(data)
        });
        const reader = response.body.getReader();
        //let content = ""
        // 开始打字机队列
        this.start(obj)
        // 循环读取响应流
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          // 将ArrayBuffer转为文本
          const chunk = new TextDecoder('utf-8').decode(value);
          // 处理文本为json格式
          const jsonArr = chunk.trim().replace(/\n/g, '').split('data: ').splice(1)
          for (let index = 0; index &lt; jsonArr.length; index++) {
            const json = jsonArr[index];
            try {
              if (JSON.parse(json).choices) {
                const text = JSON.parse(json).choices[0].delta.content ?? ''
                this.addQueue(text.replace(/^\n/g, ''), obj)
              } else {
                this.addQueue('内部出了问题o(╥﹏╥)o', obj)
              }
            } catch {
              // 处理转json不报错
            }
          }
          this.scrollBottom()
        }
      } catch (error) {
        console.error('请求错误:', error);
      }
      this.done(obj)
    },
    // 滚到最底部
    scrollBottom() {
      setTimeout(() =&gt; {
        const mainChat = this.$refs.mainChat
        mainChat.scrollTop = mainChat.scrollHeight
      }, 0)
    },
  }
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/42a3f9e1f9416376b13e166b66af3668/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">9个不错的前端开源项目</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7026cc5c35fe737a7bb9509dedd8332c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">查看Tomcat和JDK版本信息（32位还是64位）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>