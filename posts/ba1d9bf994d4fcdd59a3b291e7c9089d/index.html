<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构——双向链表及其总结 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/ba1d9bf994d4fcdd59a3b291e7c9089d/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构——双向链表及其总结">
  <meta property="og:description" content="1.概述 链表根据是否带头、是否双向、是否循环可以分为八种，双向链表是典型的带头双向循环链表。
双向链表的结构可以表示为下：
struct ListNode { int data; struct ListNode* next; struct ListNode* prev; } 2.双向链表的实现过程及其解析 双向链表的实现依旧包含List.h，List.c，test.c
2.1 链表初始化 双向链表为空的情况：只有一个哨兵位。
先定义一个结构如下：
typedef int LTDatatype; typedef struct ListNode { LTDatatype data; struct ListNode* next; struct ListNode* prev; }LTNode; 链表初始化时我们应该先创建一个哨兵位，则实现代码如下：
LTNode* LTBuyNode(LTDatatype x) { LTNode* newnode = (LTNode*)malloc(sizeof(LTNode)); if (newnode == NULL) { perror(&#34;malloc fail!&#34;); exit(1); } newnode-&gt;data = x; newnode-&gt;next = newnode; newnode-&gt;prev = newnode; return newnode; } //初始化 void LTInit(LTNode** pphead) { //创建一个哨兵位 *pphead = LTBuyNode(-1); } 2.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-23T10:46:32+08:00">
    <meta property="article:modified_time" content="2024-07-23T10:46:32+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构——双向链表及其总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="background-color:transparent;"><span style="color:#ff9900;">1.概述</span></h2> 
<p>链表根据是否带头、是否双向、是否循环可以分为八种，双向链表是典型的带头双向循环链表。</p> 
<p>双向链表的结构可以表示为下：</p> 
<pre><code class="language-cpp">struct ListNode
{
    int data;
    struct ListNode* next;
    struct ListNode* prev;
}</code></pre> 
<h2 style="background-color:transparent;"><span style="color:#ff9900;">2.双向链表的实现过程及其解析</span></h2> 
<p>双向链表的实现依旧包含List.h，List.c，test.c</p> 
<h3 style="background-color:transparent;"><span style="color:#1c7331;">2.1 链表初始化</span></h3> 
<p>双向链表为空的情况：只有一个哨兵位。</p> 
<p>先定义一个结构如下：</p> 
<pre><code class="language-cpp">typedef int LTDatatype;
typedef struct ListNode {
	LTDatatype data;
	struct ListNode* next;
	struct ListNode* prev;
}LTNode;</code></pre> 
<p>链表初始化时我们应该先创建一个哨兵位，则实现代码如下：</p> 
<pre><code class="language-cpp">LTNode* LTBuyNode(LTDatatype x)
{
	LTNode* newnode = (LTNode*)malloc(sizeof(LTNode));
	if (newnode == NULL)
	{
		perror("malloc fail!");
		exit(1);
	}
	newnode-&gt;data = x;
	newnode-&gt;next = newnode;
	newnode-&gt;prev = newnode;

	return newnode;
}
//初始化
void LTInit(LTNode** pphead)
{
	//创建一个哨兵位
	*pphead = LTBuyNode(-1);
}</code></pre> 
<h3 style="background-color:transparent;"><span style="color:#1c7331;">2.2插入数据</span></h3> 
<h4>2.2.1 尾插</h4> 
<p> 因为在双向链表中有哨兵位，所以在这种情况下不用二级指针，用一级指针就可以实现。</p> 
<p>用一级还是二级，要看pphead指向的结点会不会改变，如果发生改变，传二级，如果不发生改变，要传一级。</p> 
<p>尾插时发生改变的是头结点和最后一个结点。</p> 
<p>第一个结点：第一个有效的结点。</p> 
<p>哨兵位：头结点。</p> 
<p>代码实现如下：</p> 
<pre><code class="language-cpp">//插入数据
//尾插
void LTPushBack(LTNode* phead, LTDatatype x)
{
    assert(phead);
	LTNode* newnode = LTBuyNode(x);
	//从后往前
	newnode-&gt;next = phead;
	newnode-&gt;prev = phead-&gt;prev;

	phead-&gt;prev-&gt;next = newnode;
	phead-&gt;prev = newnode;
}</code></pre> 
<h4 style="background-color:transparent;">2.2.2 头插</h4> 
<p>打印链表的代码：</p> 
<pre><code class="language-cpp">//打印链表
void LTPrint(LTNode* phead)
{
	LTNode* pcur = phead-&gt;next;
	while (pcur != phead)
	{
		printf("%d-&gt;", pcur-&gt;data);
		pcur = pcur-&gt;next;
	}
	printf("\n");
}</code></pre> 
<p>头插的代码实现：</p> 
<pre><code class="language-cpp">//头插
void LTPushFront(LTNode* phead, LTDatatype x)
{
	assert(phead);
	//相当于插入哨兵位之后
	LTNode* newnode = LTBuyNode(x);

	newnode-&gt;next = phead-&gt;next;
	newnode-&gt;prev = phead;

	phead-&gt;next-&gt;prev = newnode;
	phead-&gt;next = newnode;
}</code></pre> 
<h3 style="background-color:transparent;"><span style="color:#1c7331;"> 2.3 判断链表是否为空</span></h3> 
<pre><code class="language-cpp">//判断链表是否为空
bool LTEmpty(LTNode* phead)
{
	assert(phead);
	return phead-&gt;next == phead;
}</code></pre> 
<h3 style="background-color:transparent;"><span style="color:#1c7331;">2.4 删除数据</span></h3> 
<h4 style="background-color:transparent;">2.4.1 尾删</h4> 
<pre><code class="language-cpp">//删除数据
//尾删
void LTPopBack(LTNode* phead)
{
	assert(phead);
	assert(!LTEmpty(phead));

	LTNode* del = phead-&gt;prev;
	LTNode* prev = del-&gt;prev;

	prev-&gt;next = phead;
	phead-&gt;prev = prev;

	free(del);
	del = NULL;
}</code></pre> 
<h4> 2.4.2 头删</h4> 
<pre><code class="language-cpp">//头删
void LTPopFront(LTNode* phead)
{
	assert(phead);
	assert(!LTEmpty(phead));

	LTNode* del = phead-&gt;next;
	del-&gt;next-&gt;prev = phead;
	phead-&gt;next = del-&gt;next;

	free(del);
	del = NULL;
}
</code></pre> 
<h3 style="background-color:transparent;"><span style="color:#1c7331;">2.5 查找 </span></h3> 
<pre><code class="language-cpp">//查找
LTNode* LTFind(LTNode* phead, LTDatatype x)
{
	assert(phead);
	LTNode* pcur = phead-&gt;next;
	while (pcur != phead)
	{
		if (pcur-&gt;data == x)
		{
			return pcur;
		}
		pcur = pcur-&gt;next;
	}
	return NULL;
}</code></pre> 
<h3 style="background-color:transparent;"> <span style="color:#1c7331;">2.6 在指定位置之后插入数据</span></h3> 
<pre><code class="language-cpp">//在指定位置之后插入数据
void LTInsert(LTNode* pos, LTDatatype x)
{
	assert(pos);
	LTNode* newnode = LTBuyNode(x);

	newnode-&gt;next = pos-&gt;next;
	newnode-&gt;prev = pos;

	pos-&gt;next-&gt;prev = newnode;
	pos-&gt;next = newnode;
}</code></pre> 
<h3 style="background-color:transparent;"><span style="color:#1c7331;"> 2.7 删除指定位置数据</span></h3> 
<pre><code class="language-cpp">//删除指定位置结点
void LTErase(LTNode* pos)
{
	assert(pos);
	pos-&gt;prev-&gt;next = pos-&gt;next;
	pos-&gt;next-&gt;prev = pos-&gt;prev;

	free(pos);
	pos = NULL;
}</code></pre> 
<h3 style="background-color:transparent;"><span style="color:#1c7331;"> 2.8 销毁链表</span></h3> 
<pre><code class="language-cpp">//销毁链表
void LTDestroy(LTNode** pphead)
{
	assert(pphead &amp;&amp; *pphead);
	LTNode* pcur = (*pphead)-&gt;next;
	while (pcur != pphead)
	{
		LTNode* Next = pcur-&gt;next;
		free(pcur);
		pcur = Next;
	}
	pcur = NULL;
	free(*pphead);
	*pphead = NULL;
}</code></pre> 
<h3 style="background-color:transparent;"><span style="color:#1c7331;">2.9 代码改善 </span></h3> 
<p>在我们写代码时我们总是要考虑传二级指针，还是一级指针，那么有没有什么方法可以进行改进呢？</p> 
<h4>2.9.1 改进销毁链表的代码 </h4> 
<pre><code class="language-cpp">void LTDestroy1(LTNode* phead)
{
	assert(phead);
	LTNode* pcur = phead-&gt;next;
	while (pcur != phead)
	{
		LTNode* Next = pcur-&gt;next;
		free(pcur);
		pcur = Next;
	}
	free(phead);
	phead = NULL;
	pcur = NULL;
}</code></pre> 
<p> 传一级时，需要手动将plist置为NULL。</p> 
<h4>2.9.2  改进初始化的链表</h4> 
<pre><code class="language-cpp">LTNode* LTInit1()
{
	LTNode* phead = LTBuyNode(-1);
	return phead;
}</code></pre> 
<p>在调用时应该用：</p> 
<pre><code class="language-cpp">//调用时为
LTNode* plist = LTInit1();</code></pre> 
<p> </p> 
<h2 style="background-color:transparent;"><span style="color:#ff9900;"> 3.总结</span></h2> 
<p><img alt="" height="575" src="https://images2.imgbox.com/59/86/XgG9qRUG_o.png" width="1200"></p> 
<p><strong>（该图片来自比特就业课的课件） </strong></p> 
<p>在图中我们可以分别出顺序表和链表之间的关系，我们要重点关注其应用场景。</p> 
<p></p> 
<p>今天就到这里，我们下一个知识点见(*￣︶￣)!</p> 
<p></p> 
<h3></h3> 
<p></p> 
<h2></h2> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7d1a7f2281440d14f55751c888f0e5fe/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">京东百万级调度系统(Buffalo)架构解密</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e4acd0330dba439da81814df77f672fd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spark 大规模机器学习（一）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>