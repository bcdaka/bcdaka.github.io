<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>前端接入chatgpt,实现流式文字的显示 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/ae8842dbd2510d2be87ef148c55156c9/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="前端接入chatgpt,实现流式文字的显示">
  <meta property="og:description" content="前端接入chatgpt,实现流式文字的显示 业务需求： 项目需要接入chatgpt提供的api，后端返回流式的字符，前端接收并实时显示。
相关技术原理： 1. JS中的Stream流: 在JavaScript中，使用Stream流通常指的是处理数据流的一种方式，特别是在Node.js环境下。Stream可以是可读的、可写的、或者既可读又可写的。它们允许数据被处理成块，而不是一次性处理整个数据集，这对于处理大量数据或者来自网络请求的数据非常有用。
但曾经这些对于 JavaScript 是不可用的。以前，如果我们想要处理某种资源（如视频、文本文件等），我们必须下载完整的文件，等待它反序列化成适当的格式，然后在完整地接收到所有的内容后再进行处理。
随着流在 JavaScript 中的使用，一切发生了改变——只要原始数据在客户端可用，你就可以使用 JavaScript 按位处理它，而不再需要缓冲区、字符串或 blob。
2. Stream API 以下是封装的用来调用的Stream API的核心代码，为了方便调用封装成了Hook组件。有以下组成部分：
useStream Hook: 接受一个URL和一个参数对象。这个对象可以包含几个回调函数（onFirst, onNext, onError, onDone）和一个fetchParams对象，用于自定义fetch请求。startStream 函数: 被useStream内部调用，用于实际发起fetch请求，并使用ReadableStream的reader来逐块读取数据。它处理流数据的读取，并根据提供的回调函数处理数据块、错误和流结束。 import React, { useCallback, useState, useRef, useEffect } from &#39;react&#39;; import &#39;abortcontroller-polyfill&#39;; import { getLoginToken } from &#39;../../utils/localStorage.js&#39;; import {getRoleFromLocation} from &#39;../commonUtils.js&#39;; /** * React hook for the [Streams API](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API). * Use this hook to stream data from a URL. * @param {string} url * @param {object} [params] * @param {function(Response)} [params.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-02T12:07:39+08:00">
    <meta property="article:modified_time" content="2024-07-02T12:07:39+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">前端接入chatgpt,实现流式文字的显示</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="chatgpt_0"></a>前端接入chatgpt,实现流式文字的显示</h2> 
<h3><a id="_2"></a>业务需求：</h3> 
<p>项目需要接入chatgpt提供的api，后端返回流式的字符，前端接收并实时显示。</p> 
<h3><a id="_6"></a>相关技术原理：</h3> 
<h4><a id="1_JSStream_8"></a>1. JS中的Stream流:</h4> 
<p>在JavaScript中，使用Stream流通常指的是处理数据流的一种方式，特别是在Node.js环境下。Stream可以是可读的、可写的、或者既可读又可写的。它们允许数据被处理成块，而不是一次性处理整个数据集，这对于处理大量数据或者来自网络请求的数据非常有用。</p> 
<p>但曾经这些对于 JavaScript 是不可用的。以前，如果我们想要处理某种资源（如视频、文本文件等），我们必须下载完整的文件，等待它反序列化成适当的格式，然后在完整地接收到所有的内容后再进行处理。</p> 
<p>随着流在 JavaScript 中的使用，一切发生了改变——只要原始数据在客户端可用，你就可以使用 JavaScript 按位处理它，而不再需要缓冲区、字符串或 blob。</p> 
<p><img src="https://images2.imgbox.com/b3/92/zj8bqssh_o.png" alt="img"></p> 
<h4><a id="2_Stream_API_18"></a>2. Stream API</h4> 
<p>以下是封装的用来调用的Stream API的核心代码，为了方便调用封装成了Hook组件。有以下组成部分：</p> 
<ol><li><strong>useStream Hook</strong>: 接受一个URL和一个参数对象。这个对象可以包含几个回调函数（onFirst, onNext, onError, onDone）和一个fetchParams对象，用于自定义fetch请求。</li><li><strong>startStream 函数</strong>: 被useStream内部调用，用于实际发起fetch请求，并使用ReadableStream的reader来逐块读取数据。它处理流数据的读取，并根据提供的回调函数处理数据块、错误和流结束。</li></ol> 
<pre><code class="prism language-jsx">import React, { useCallback, useState, useRef, useEffect } from 'react';
import 'abortcontroller-polyfill';
import { getLoginToken } from '../../utils/localStorage.js';
import {getRoleFromLocation} from '../commonUtils.js';

/**
 * React hook for the [Streams API](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API).
 * Use this hook to stream data from a URL.
 * @param {string} url
 * @param {object} [params]
 * @param {function(Response)} [params.onNext]
 * @param {function(Error)} [params.onError]
 * @param {function()} [params.onDone]
 * @param {RequestInit} [params.fetchParams]
 *
 * @returns {StreamHook}
 */

function useStream(url, params) {
  if (typeof params !== 'object' || params === null) {
    params = {};
  }

  const streamRef = useRef();
  const onFirst = useRef(params.onFirst);
  const onNext = useRef(params.onNext);
  const onError = useRef(params.onError);
  const onDone = useRef(params.onDone);
  const close = useCallback(() =&gt; {
    if (streamRef.current) {
      streamRef.current.abort();
    }
  }, []);
  useEffect(() =&gt; {
    if (streamRef.current) {
      streamRef.current.abort();
    }

    streamRef.current = new AbortController();
    if (params.fetchParams) {
      startStream(url, {
        onFirst: onFirst,
        onNext: onNext,
        onError: onError,
        onDone: onDone,
        fetchParams: {
          ...params.fetchParams,
          signal: streamRef.current.signal
        }
      });
    }
  }, [url, params.fetchParams]);

  useEffect(() =&gt; {
    onFirst.current = params.onFirst;
  }, [params.onFirst]);
  useEffect(() =&gt; {
    onNext.current = params.onNext;
  }, [params.onNext]);
  useEffect(() =&gt; {
    onError.current = params.onError;
  }, [params.onError]);
  useEffect(() =&gt; {
    onDone.current = params.onDone;
  }, [params.onDone]);
  return {
    close
  };
}
/**
 * Use this function to start streaming data from an URL
 * @param {string} url
 * @param {object} params
 * @param {React.MutableRefObject&lt;function(Response)&gt;} params.onNext
 * @param {React.MutableRefObject&lt;function(Error)&gt;} params.onError
 * @param {React.MutableRefObject&lt;function()&gt;} params.onDone
 * @param {RequestInit} params.fetchParams
 */

async function startStream(url, {
  onFirst,
  onNext,
  onError,
  onDone,
  fetchParams
}) {
  const errCb = err =&gt; {
    if (typeof onError.current === 'function') {
      onError.current(err);
    }
  };

  try {
    // 获取role
    const locationType = getRoleFromLocation();
    // add header
    const reqHeaders = { Authorization: getLoginToken(locationType), 'Content-Type': "application/json"}
    const res = await fetch(url, { method: 'GET', ...fetchParams, headers: reqHeaders });
    const reader = res.body.getReader();
    const headers = res.headers;
    if (typeof onFirst.current === 'function') {
      onFirst.current(headers);
    }

    if (fetchParams.signal instanceof AbortSignal) {
      fetchParams.signal.addEventListener('abort', evt =&gt; reader.cancel(evt), {
        once: true,
        passive: true
      });
    } // eslint-disable-next-line no-constant-condition

    while (true) {
      try {
        const {
          done,
          value
        } = await reader.read();
        if (done) {
          if (typeof onDone.current === 'function') {
            onDone.current();
          }
          return;
        }
        if (typeof onNext.current === 'function') {
          const data = new TextDecoder('utf-8').decode(value);
          onNext.current(data);
        }
      } catch (e) {
        errCb(e);
        return;
      }
    }
  } catch (e) {
    errCb(e);
  }
}

export default useStream;
</code></pre> 
<h4><a id="3_ReactdangerouslySetInnerHTML_168"></a>3. React中的dangerouslySetInnerHTML</h4> 
<p>dangerouslySetInnerHTML是React中的一个属性，允许你直接在组件内部插入HTML代码字符串。由于直接使用HTML字符串可能会导致跨站脚本（XSS）攻击，因此React将其命名为dangerouslySetInnerHTML，以此提醒开发者注意使用时的潜在风险。</p> 
<p>使用dangerouslySetInnerHTML时，需要传递一个对象，该对象有一个__html键，对应的值就是你想要插入的HTML字符串。</p> 
<p>例如：</p> 
<pre><code class="prism language-jsx">&lt;div dangerouslySetInnerHTML={<!-- -->{ __html: "&lt;span&gt;这是HTML内容&lt;/span&gt;" }}&gt;&lt;/div&gt;
</code></pre> 
<p>在上述代码中，</p> 
<div>
  标签内将显示 
 这是HTML内容，而不是将其作为字符串显示出来。 
</div> 
<p></p> 
<p>使用dangerouslySetInnerHTML时应该非常小心，确保传入的HTML内容是安全的，避免XSS攻击。在可能的情况下，尽量使用React的组件和属性来动态生成内容，而不是直接使用dangerouslySetInnerHTML。</p> 
<h3><a id="_184"></a>业务实现</h3> 
<p>当理清上述的技术点后，剩下的业务逻辑实现就不算困难了。但是本人项目里面夹杂了太多了的业务性质的代码，所以这里只展示主要逻辑了。因为流式传来的是一个个字符，所以前期需要收集并拼接传来的字符，等待如[DONE]这类明确状态的字符传来后，再通过setState更新DOM.</p> 
<ol><li><strong>导入依赖</strong>：引入了React库的useCallback、useState、useRef钩子，antd-mobile库的Avatar组件，样式文件，一个图片资源，以及自定义的useStream钩子。</li><li><strong>组件定义</strong>：ChatGptStream是一个函数式组件，接收props作为参数。</li><li><strong>状态和引用</strong>：</li></ol> 
<ul><li>使用useState钩子定义了chatgptAnswer状态，用于存储聊天回答的内容。</li><li>使用useRef钩子创建了answerDataRef引用，用于累积接收到的流数据。</li></ul> 
<ol><li><strong>处理流数据</strong>：</li></ol> 
<ul><li>getChatGptStream函数处理从流中接收到的每一条消息。如果消息包含特定的结束标记（如[DONE]、[FAILED]、[OVER]），则调用handleCommend函数处理并结束处理流程。如果消息包含<br>，则将其替换为换行符，并累积到answerDataRef中。</li><li>更新chatgptAnswer状态以显示累积的聊天内容，并调用scrollMessageListToEnd函数滚动到消息列表的底部。</li></ul> 
<ol><li><strong>使用自定义钩子</strong>：通过useStream钩子与后端建立流连接，传入requestUrl、onFirst、getChatGptStream函数和chatgptParams参数。</li><li><strong>渲染UI</strong>：组件返回的JSX中，如果chatgptAnswer.title_zh有内容，则显示聊天记录。使用Avatar组件显示机器人头像，dangerouslySetInnerHTML属性将聊天内容作为HTML插入到页面中，以保留格式（如换行）。</li><li><strong>样式和布局</strong>：通过内联样式和className引用外部.less文件中定义的样式，设置聊天记录的布局和外观。</li></ol> 
<pre><code class="prism language-jsx">import React, { useCallback, useState, useRef } from 'react';
import { Avatar } from 'antd-mobile';

import './index.less';
import siuvoRobot from '@/assets/images/avatar_robot.png';
import useStream from '@/utils/hooks/useStreamV2';

const ChatGptStream = (props) =&gt; {
  const {
    chatgptParamsObj,
    scrollMessageListToEnd,
  } = props;
  const [chatgptAnswer, setChatgptAnswer] = useState({
    title_zh: '',
  });
  const answerDataRef = useRef('');
// 由外部传来的请求地址和入参
  const { requestUrl, chatgptParams } = chatgptParamsObj;

  const handleCommend = data =&gt; {
    // 处理data逻辑
  }

  const getChatGptStream = async res =&gt; {
    let data = res;
    // 根据后端返回字符，做相应的处理
    if (data.includes('[DONE]') || data.includes('[FAILED]') || data.includes('[OVER]')) {
      handleCommend(data);
      return;
    }
    // 换行
    if (data.includes('&lt;br/&gt;')) {
      data = data.replace(/&lt;br\/&gt;/g, '\r\n');
    }
    answerDataRef.current += data;
    // 显示聊天内容
    setChatgptAnswer({ title_zh: answerDataRef.current, });
    scrollMessageListToEnd();
  };

  const onFirst = useCallback(async res =&gt; {
    // 处理首次返回的数据
  }, []);

  useStream(requestUrl, { onFirst, onNext: getChatGptStream, fetchParams: chatgptParams });

  return (
    &lt;&gt;
      {
        chatgptAnswer?.title_zh &amp;&amp; (
          &lt;div className="chatting-records-content"
            style={<!-- -->{
              padding: '0 0.5rem',
              marginTop: '-1rem',
            }}
          &gt;
            &lt;div className="dialogue-block flex-start"&gt;
              &lt;div className="head"&gt;
                &lt;Avatar src={siuvoRobot} style={<!-- -->{ '--size': '32px' }} /&gt;
              &lt;/div&gt;
              &lt;div className="dialogue left-message-text" style={<!-- -->{ background: 'lavender' }}&gt;
                &lt;div dangerouslySetInnerHTML={<!-- -->{ __html: chatgptAnswer?.title_zh }}&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        )
      }
    &lt;/&gt;
  )
}

export default ChatGptStream;
</code></pre> 
<p>这里展示ChatGptStream在外部的引用：</p> 
<pre><code class="prism language-jsx">...
  // 如果消息超出了屏幕，自动滚动到最底部
  const scrollMessageListToEnd = useCallback(() =&gt; {
    // ...根据实际样式，获取元素
    // 元素当前的滚动位置 = 这是元素内容的总高度 - 元素可见部分的高度
    messagesShowContent.scrollTop = messagesShowContent.scrollHeight - messagesShowContent.clientHeight;
    // ...
  }, [])

  // chatgptParamsObj对象值发生更变，触发更新
  setChatgptParamsObj({
    ...chatgptParamsObj,
    chatgptParams: {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
    },
    requestUrl: `${BASE_URL}ai/suggest/v2?sessionId=${sessionIdRef.current}`
  });

...
return (
  ...
    {
      chatgptParamsObj.chatgptParams &amp;&amp;
      &lt;ChatGptStream
        chatgptParamsObj={chatgptParamsObj}
        scrollMessageListToEnd={scrollMessageListToEnd}
      /&gt;
    }
...
)
</code></pre> 
<p>以上，便是实现业务需求的总体逻辑了。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/71a561aaf58329393be8e3c8ade50b36/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">有手就行，轻松本地部署 Llama、Qwen 大模型，无需 GPU</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/28342263c7efa5f4766411d359b99593/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">更加优雅的下载文件 --- http header Content-Disposition 学习</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>