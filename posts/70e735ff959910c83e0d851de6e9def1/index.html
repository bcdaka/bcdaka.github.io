<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;进阶07】哈希表and哈希桶 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/70e735ff959910c83e0d851de6e9def1/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;进阶07】哈希表and哈希桶">
  <meta property="og:description" content="一、哈希概念 顺序结构以及平衡树中
元素关键码与存储位置没有对应关系
因此查找一个元素
必须经过关键码的多次比较
顺序查找时间复杂度为O(N)
平衡树中为树的高度，即O( l o g 2 N log_2 N log2​N)
搜索效率 = 搜索过程中元素的比较次数
理想的搜索方法：不经任何比较
一次直接从表中获取想要的元素
构造一种存储结构
通过某种函数(hashFunc)使元素的存储位置
与它的关键码之间建立一一映射的关系
就能在查找时通过该函数直接找到该元素
向该结构中：
插入元素：
根据待插入元素的关键码
以此函数计算出该元素的存储位置并按此位置
进行存放
搜索元素：
对元素的关键码进行同样的计算
把求得的函数值当做元素的存储位置
在结构中按此位置取元素比较
若关键码相等，则搜索成功
该方式即为：
哈希(散列)方法
哈希方法中使用的转换函数称为：
哈希(散列)函数
构造出来的结构称为：
哈希表(Hash Table)(或者称散列表)
例如：
数据集合{1，7，6，4，5，9};
哈希函数设置为：
hash(key) = key % capacity; capacity：
存储元素底层空间总的大小
二、哈希冲突 不同关键字通过相同的哈希函数
计算出相同的哈希地址
该种现象称为哈希冲突或哈希碰撞
把具有不同关键码
而具有相同哈希地址的数据元素称为“同义词”
11、21、31…数据经过哈希函数计算都为1
都插入在下标为1的地方便会冲突
三、哈希函数 引起哈希冲突的一个原因可能是：
哈希函数设计不够合理
哈希函数设计原则：
哈希函数的定义域必须包括
需要存储的全部关键码
而如果散列表允许有m个地址时
其值域必须在0到m-1之间哈希函数计算出来的地址能均匀分布在
整个空间中哈希函数应该比较简单 常用哈希函数：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-01-22T20:55:16+08:00">
    <meta property="article:modified_time" content="2024-01-22T20:55:16+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;进阶07】哈希表and哈希桶</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/da/d4/5QwTYdQI_o.jpg" alt="在这里插入图片描述"></p> 
<h2><a id="_1"></a>一、哈希概念</h2> 
<blockquote> 
 <p>顺序结构以及平衡树中<br> 元素关键码与存储位置没有对应关系<br> 因此查找一个元素<br> 必须经过关键码的多次比较<br> 顺序查找时间复杂度为O(N)<br> 平衡树中为树的高度，即O(<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          l 
         
        
          o 
         
         
         
           g 
          
         
           2 
          
         
        
          N 
         
        
       
         log_2 N 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span></span></span></span></span>)</p> 
</blockquote> 
<p>搜索效率 = 搜索过程中元素的比较次数<br> 理想的搜索方法：不经任何比较<br> 一次直接从表中获取想要的元素</p> 
<blockquote> 
 <p>构造一种存储结构<br> 通过某种函数(hashFunc)使元素的存储位置<br> 与它的关键码之间建立一一映射的关系<br> 就能在查找时通过该函数直接找到该元素</p> 
</blockquote> 
<p><mark>向该结构中：</mark><br> <code>插入元素：</code><br> 根据待插入元素的关键码<br> 以此函数计算出该元素的存储位置并按此位置<br> 进行存放<br> <code>搜索元素：</code><br> 对元素的关键码进行同样的计算<br> 把求得的函数值当做元素的存储位置<br> 在结构中按此位置取元素比较<br> 若关键码相等，则搜索成功</p> 
<p><mark>该方式即为：</mark><br> <code>哈希(散列)方法</code><br> <mark>哈希方法中使用的转换函数称为：</mark><br> <code>哈希(散列)函数</code><br> <mark>构造出来的结构称为：</mark><br> <code>哈希表(Hash Table)(或者称散列表)</code></p> 
<p><mark>例如：</mark><br> 数据集合{1，7，6，4，5，9};<br> <mark>哈希函数设置为：</mark><br> <code>hash(key) = key % capacity; </code><br> <mark>capacity：</mark><br> <code>存储元素底层空间总的大小</code></p> 
<p><img src="https://images2.imgbox.com/f1/b1/5xyr8TrY_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_44"></a>二、哈希冲突</h2> 
<blockquote> 
 <p>不同关键字通过相同的哈希函数<br> 计算出相同的哈希地址<br> 该种现象称为哈希冲突或哈希碰撞</p> 
</blockquote> 
<p>把具有不同关键码<br> 而具有相同哈希地址的数据元素称为“同义词”</p> 
<blockquote> 
 <p>11、21、31…数据经过哈希函数计算都为1<br> 都插入在下标为1的地方便会冲突</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/ed/2c/pWIrPFfr_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_56"></a>三、哈希函数</h2> 
<p>引起哈希冲突的一个原因可能是：<br> 哈希函数设计不够合理</p> 
<p><mark>哈希函数设计原则：</mark></p> 
<ul><li>哈希函数的定义域必须包括<br> 需要存储的全部关键码<br> 而如果散列表允许有m个地址时<br> 其值域必须在0到m-1之间</li><li>哈希函数计算出来的地址能均匀分布在<br> 整个空间中</li><li>哈希函数应该比较简单</li></ul> 
<p><mark>常用哈希函数：</mark></p> 
<ol><li> <p><code>直接定址法</code><br> 取关键字的某个线性函数为散列地址：<br> Hash（Key）= A*Key + B<br> <code>优点：</code>简单、均匀<br> <code>缺点：</code>需要事先知道关键字的分布情况<br> <code>使用场景：</code>适合查找比较小且连续的情况<br> <code>面试题：</code>字符串中第一个只出现一次字符</p> </li><li> <p><code>除留余数法</code><br> 设散列表中允许的地址数为m<br> 取一个不大于m<br> 但最接近或等于m的质数p作为除数<br> 按照哈希函数：<br> Hash(key) = key% p(p&lt;=m)<br> 将关键码转换成哈希地址</p> </li></ol> 
<h2><a id="_85"></a>四、哈希冲突解决</h2> 
<p>解决哈希冲突两种常见方法：<br> 闭散列和开散列</p> 
<h4><a id="41__88"></a>4.1 闭散列</h4> 
<p>闭散列：也叫开放定址法<br> 当发生哈希冲突时<br> 如果哈希表未被装满<br> 说明哈希表中必然还有空位置<br> 那么可以把key存放到<br> 冲突位置的“下一个” 空位置中去</p> 
<p>那如何寻找下一个空位置呢？</p> 
<ol><li>线性探测<br> <code>从发生冲突的位置开始</code><br> <code>依次向后探测</code><br> <code>直到寻找到下一个空位置为止</code></li></ol> 
<p><img src="https://images2.imgbox.com/7c/d5/DqQUvsOw_o.png" alt="在这里插入图片描述"><br> 线性探测优点：实现简单</p> 
<p>线性探测缺点：一旦发生哈希冲突<br> 所有的冲突连在一起，容易产生数据“堆积”<br> 即：不同关键码占据了可利用的空位置<br> 使得寻找某关键码的位置需要许多次比较<br> 导致搜索效率降低</p> 
<ol start="2"><li>二次探测</li></ol> 
<blockquote> 
 <p>线性探测的缺陷是<br> 产生冲突的数据堆积在一块<br> 这与其找下一个空位置有关系<br> 因为找空位置的方式就是挨着往后逐个去找</p> 
</blockquote> 
<p>因此二次探测为了避免该问题<br> 找下一个空位置的方法为：<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          H 
         
        
          i 
         
        
       
      
        H_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0813em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0813em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> = (<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          H 
         
        
          0 
         
        
       
      
        H_0 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0813em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0813em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> + <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          i 
         
        
          2 
         
        
       
      
        i^2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8141em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> )% m<br> 或者：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          H 
         
        
          i 
         
        
       
      
        H_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0813em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0813em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> = (<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          H 
         
        
          0 
         
        
       
      
        H_0 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0813em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0813em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> - <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          i 
         
        
          2 
         
        
       
      
        i^2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8141em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> )% m<br> 其中：i = 1,2,3…， <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          H 
         
        
          0 
         
        
       
      
        H_0 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0813em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0813em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>是通过<br> 散列函数Hash(x)对元素的关键码 key<br> 进行计算得到的位置，m是表的大小</p> 
<blockquote> 
 <p>研究表明：当表的长度为质数且表装载因子<br> a不超过0.5时，新的表项一定能够插入<br> 而且任何一个位置都不会被探查两次<br> 因此只要表中有一半的空位置<br> 就不会存在表满的问题<br> 在搜索时可以不考虑表装满的情况<br> 但在插入时必须确保表的装载因子a不超过<br> 0.5，如果超出必须考虑增容<br> 因此：比散列最大的缺陷就是空间利用率<br> 比较低，这也是哈希的缺陷</p> 
</blockquote> 
<h4><a id="42__135"></a>4.2 开散列</h4> 
<p>开散列法又叫链地址法(开链法)<br> 首先对关键码集合用散列函数计算散列地址<br> 具有相同地址的关键码归于同一子集合<br> 每一个子集合称为一个桶<br> 各个桶中的元素通过一个单链表链<br> 接起来，各链表的头结点存储在哈希表中</p> 
<p><mark>如图：</mark><br> 将哈希地址相同的元素链接在同一个桶下面<br> <img src="https://images2.imgbox.com/a6/19/S5bdYi9V_o.png" alt="在这里插入图片描述"><br> 在实际应用中<br> 开散列比闭散列更实用</p> 
<ol><li>哈希桶负载因子更大<br> 空间利用率高</li><li>极端情况也有解决方案</li></ol> 
<p>哈希桶极端情况：<br> 所有元素在同一个桶<br> 为了避免这种情况<br> 当桶超过一定高度<br> 将该桶转换为红黑树结构</p> 
<h2><a id="_157"></a>五、哈希桶的模拟实现</h2> 
<h4><a id="51__158"></a>5.1 基本框架</h4> 
<pre><code class="prism language-cpp"><span class="token keyword">namespace</span> HashBucket <span class="token comment">// 哈希桶</span>
<span class="token punctuation">{<!-- --></span>	
	<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">V</span><span class="token operator">&gt;</span>
	<span class="token keyword">struct</span> <span class="token class-name">HashNode</span>
	<span class="token punctuation">{<!-- --></span>
		pair<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span> _kv<span class="token punctuation">;</span>
		HashNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span><span class="token operator">*</span> _next<span class="token punctuation">;</span> <span class="token comment">// 单链表的方式链接</span>
		
		<span class="token function">HashNode</span><span class="token punctuation">(</span><span class="token keyword">const</span> pair<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span><span class="token operator">&amp;</span> kv<span class="token punctuation">)</span>
			<span class="token operator">:</span> <span class="token function">_next</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
			<span class="token punctuation">,</span> <span class="token function">_kv</span><span class="token punctuation">(</span>kv<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>

	<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">V</span><span class="token operator">&gt;</span>
	<span class="token keyword">class</span> <span class="token class-name">HashTable</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">typedef</span> HashNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span> Node<span class="token punctuation">;</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">private</span><span class="token operator">:</span>
		vector<span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token operator">&gt;</span> _tables<span class="token punctuation">;</span>
		size_t _n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 存储的有效数据个数 </span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="52__185"></a>5.2 插入元素</h4> 
<p>哈希桶的增容<br> 若哈希表的大小为0<br> 将哈希表的初始值设置为10</p> 
<p>若哈希表的负载因子等于1<br> 创建一个新表，大小是原表的两倍<br> 用新表的哈希函数计算旧表的每个<br> 元素在新表的映射位置<br> 将旧表的每个元素头插进新表</p> 
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token function">Insert</span><span class="token punctuation">(</span><span class="token keyword">const</span> pair<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span><span class="token operator">&amp;</span> kv<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 去重, 插入之前先查找有没有相同的元素</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">Find</span><span class="token punctuation">(</span>kv<span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

	<span class="token comment">// 负载因子 == 1时扩容</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>_n <span class="token operator">==</span> _tables<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 哈希表大小为0，将哈希表初始值设为10</span>
		size_t newsize <span class="token operator">=</span> _tables<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">10</span> <span class="token operator">:</span> _tables<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
		vector<span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token operator">&gt;</span> <span class="token function">newtables</span><span class="token punctuation">(</span>newsize<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> cur <span class="token operator">:</span> _tables<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span> <span class="token comment">// current不为空, 把挂着的数据一个一个移到新表</span>
			<span class="token punctuation">{<!-- --></span>
				Node<span class="token operator">*</span> next <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
				size_t hashi <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first <span class="token operator">%</span> newtables<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token comment">// 头插到新表</span>
				cur<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> newtables<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span><span class="token punctuation">;</span>
				newtables<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span> <span class="token operator">=</span> cur<span class="token punctuation">;</span>

				cur <span class="token operator">=</span> next<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		_tables<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>newtables<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	size_t hashi <span class="token operator">=</span> kv<span class="token punctuation">.</span>first <span class="token operator">%</span> _tables<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 头插</span>
	Node<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>kv<span class="token punctuation">)</span><span class="token punctuation">;</span>
	newnode<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> _tables<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span><span class="token punctuation">;</span>
	_tables<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span> <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
	<span class="token operator">++</span>_n<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

Node<span class="token operator">*</span> <span class="token function">Find</span><span class="token punctuation">(</span><span class="token keyword">const</span> K<span class="token operator">&amp;</span> key<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>_tables<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>

	size_t hashi <span class="token operator">=</span> key <span class="token operator">%</span> _tables<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Node<span class="token operator">*</span> cur <span class="token operator">=</span> _tables<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first <span class="token operator">==</span> key<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> cur<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">bool</span> <span class="token function">Erase</span><span class="token punctuation">(</span><span class="token keyword">const</span> K<span class="token operator">&amp;</span> key<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	size_t hashi <span class="token operator">=</span> key <span class="token operator">%</span> _tables<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Node<span class="token operator">*</span> prev <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
	Node<span class="token operator">*</span> cur <span class="token operator">=</span> _tables<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first <span class="token operator">==</span> key<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>prev <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				_tables<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span> <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span>
			<span class="token punctuation">{<!-- --></span>
				prev<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">delete</span> cur<span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>
			prev <span class="token operator">=</span> cur<span class="token punctuation">;</span>
			cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>✨✨✨✨✨✨✨✨<br> 本篇博客完，感谢阅读🌹<br> 如有错误之处可评论指出<br> 博主会耐心听取每条意见<br> ✨✨✨✨✨✨✨✨</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/daad647bdd58035dcc86cefe0bdd4314/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">四.Winform使用Webview2加载本地HTML页面并互相通信</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8aea69586e654aa6f732c1ea5106ff43/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">RabbitMQ控制界面详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>