<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;高阶】：特殊类设计和四种类型转换 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/dffe689f7771bb6798406094e58dab3d/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;高阶】：特殊类设计和四种类型转换">
  <meta property="og:description" content="✨ 人生如梦，朝露夕花，宛若泡影 🌏
📃个人主页：island1314
🔥个人专栏：C&#43;&#43;学习
⛺️ 欢迎关注：👍点赞 👂🏽留言 😍收藏 💞 💞 💞
特殊类设计和四种类型转换：
1. 特殊类设计
1.1 无法被拷贝的类
1.1.1 C&#43;&#43;98的做法：
1.1.2 C&#43;&#43;11的做法：
1.2 只能在堆上创建对象的类
1.3 只能在栈上创建对象的类
🍉1.3.1 实现一：
🥝1.3.2 实现二：
1.4 无法被继承的类
1.4.1 C&#43;&#43;98的做法：
1.4.2 C&#43;&#43;11的做法：
1.5 只能创建一个对象(单例模式)
🍍1.5.1 设计模式：
🍎1.5.2 单例模式：
🌈饿汉模式
🌈懒汉模式
2. 类型转换
2.1 C语言中的类型转换
2.2 C&#43;&#43;中的类型转换
🌱2.2.1 static_cast
☘️ 2.2.2 reinterpret_cast
🍀2.2.3 const_cast
🌿2.2.4 dynamic_cast
2.3 为什么C&#43;&#43;需要四种类型转换
2.4 RTTI
2.5 扩展
2.5.1 内置类型和自定义类型之间
2.5.2 自定义类型与自定义类型之间
2.6 建议">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-11T17:55:55+08:00">
    <meta property="article:modified_time" content="2024-08-11T17:55:55+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;高阶】：特殊类设计和四种类型转换</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="728" src="https://images2.imgbox.com/1b/9b/OT6ndY0Q_o.jpg" width="1200"></p> 
<p>✨                                      <span style="color:#9c8ec1;"><strong>    人生如梦，朝露夕花，宛若泡影</strong>  </span>   🌏</p> 
<p>📃<a href="https://so.csdn.net/so/search?q=%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5&amp;spm=1001.2101.3001.7020" title="个人主页">个人主页</a>：<a href="https://blog.csdn.net/island1314?spm=1011.2266.3001.5343" title="island1314">island1314</a></p> 
<p>🔥个人专栏：<a href="https://blog.csdn.net/island1314/category_12622912.html" title="C++学习">C++学习</a></p> 
<p><strong>⛺️</strong> 欢迎关注：👍点赞 👂🏽留言 😍收藏  💞 💞 💞</p> 
<p style="text-align:center;">                <img alt="" src="https://images2.imgbox.com/64/ee/gE7iSU9b_o.gif"></p> 
<hr> 
<p id="main-toc"><strong>特殊类设计和四种类型转换：</strong></p> 
<p id="1.%20%E7%89%B9%E6%AE%8A%E7%B1%BB%E8%AE%BE%E8%AE%A1-toc" style="margin-left:40px;"><a href="#1.%20%E7%89%B9%E6%AE%8A%E7%B1%BB%E8%AE%BE%E8%AE%A1" rel="nofollow">1. 特殊类设计</a></p> 
<p id="1.1%20%E6%97%A0%E6%B3%95%E8%A2%AB%E6%8B%B7%E8%B4%9D%E7%9A%84%E7%B1%BB-toc" style="margin-left:80px;"><a href="#1.1%20%E6%97%A0%E6%B3%95%E8%A2%AB%E6%8B%B7%E8%B4%9D%E7%9A%84%E7%B1%BB" rel="nofollow">1.1 无法被拷贝的类</a></p> 
<p id="1.1.1%20C%2B%2B98%E7%9A%84%E5%81%9A%E6%B3%95%EF%BC%9A-toc" style="margin-left:120px;"><a href="#1.1.1%20C%2B%2B98%E7%9A%84%E5%81%9A%E6%B3%95%EF%BC%9A" rel="nofollow">1.1.1 C++98的做法：</a></p> 
<p id="1.1.2%20C%2B%2B11%E7%9A%84%E5%81%9A%E6%B3%95%EF%BC%9A-toc" style="margin-left:120px;"><a href="#1.1.2%20C%2B%2B11%E7%9A%84%E5%81%9A%E6%B3%95%EF%BC%9A" rel="nofollow">1.1.2 C++11的做法：</a></p> 
<p id="1.2%C2%A0%E5%8F%AA%E8%83%BD%E5%9C%A8%E5%A0%86%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB-toc" style="margin-left:80px;"><a href="#1.2%C2%A0%E5%8F%AA%E8%83%BD%E5%9C%A8%E5%A0%86%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB" rel="nofollow">1.2 只能在堆上创建对象的类</a></p> 
<p id="1.3%20%E5%8F%AA%E8%83%BD%E5%9C%A8%E6%A0%88%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB-toc" style="margin-left:80px;"><a href="#1.3%20%E5%8F%AA%E8%83%BD%E5%9C%A8%E6%A0%88%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB" rel="nofollow">1.3 只能在栈上创建对象的类</a></p> 
<p id="%F0%9F%8D%891.3.1%C2%A0%E5%AE%9E%E7%8E%B0%E4%B8%80%EF%BC%9A-toc" style="margin-left:120px;"><a href="#%F0%9F%8D%891.3.1%C2%A0%E5%AE%9E%E7%8E%B0%E4%B8%80%EF%BC%9A" rel="nofollow">🍉1.3.1 实现一：</a></p> 
<p id="%F0%9F%A5%9D1.3.2%C2%A0%E5%AE%9E%E7%8E%B0%E4%BA%8C%EF%BC%9A-toc" style="margin-left:120px;"><a href="#%F0%9F%A5%9D1.3.2%C2%A0%E5%AE%9E%E7%8E%B0%E4%BA%8C%EF%BC%9A" rel="nofollow">🥝1.3.2 实现二：</a></p> 
<p id="1.4%20%E6%97%A0%E6%B3%95%E8%A2%AB%E7%BB%A7%E6%89%BF%E7%9A%84%E7%B1%BB-toc" style="margin-left:80px;"><a href="#1.4%20%E6%97%A0%E6%B3%95%E8%A2%AB%E7%BB%A7%E6%89%BF%E7%9A%84%E7%B1%BB" rel="nofollow">1.4 无法被继承的类</a></p> 
<p id="1.4.1%20C%2B%2B98%E7%9A%84%E5%81%9A%E6%B3%95%EF%BC%9A-toc" style="margin-left:120px;"><a href="#1.4.1%20C%2B%2B98%E7%9A%84%E5%81%9A%E6%B3%95%EF%BC%9A" rel="nofollow">1.4.1 C++98的做法：</a></p> 
<p id="1.4.2%20C%2B%2B11%E7%9A%84%E5%81%9A%E6%B3%95%EF%BC%9A-toc" style="margin-left:120px;"><a href="#1.4.2%20C%2B%2B11%E7%9A%84%E5%81%9A%E6%B3%95%EF%BC%9A" rel="nofollow">1.4.2 C++11的做法：</a></p> 
<p id="1.5%C2%A0%E5%8F%AA%E8%83%BD%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1(%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F)-toc" style="margin-left:80px;"><a href="#1.5%C2%A0%E5%8F%AA%E8%83%BD%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%28%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%29" rel="nofollow">1.5 只能创建一个对象(单例模式)</a></p> 
<p id="%F0%9F%8D%8D1.5.1%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A-toc" style="margin-left:120px;"><a href="#%F0%9F%8D%8D1.5.1%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A" rel="nofollow">🍍1.5.1 设计模式：</a></p> 
<p id="%F0%9F%8D%8E1.5.2%20%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%9A-toc" style="margin-left:120px;"><a href="#%F0%9F%8D%8E1.5.2%20%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%9A" rel="nofollow">🍎1.5.2 单例模式：</a></p> 
<p id="%F0%9F%8C%882.2%C2%A0decltype-toc" style="margin-left:160px;"><a href="#%F0%9F%8C%882.2%C2%A0decltype" rel="nofollow">🌈饿汉模式</a></p> 
<p id="%F0%9F%8C%882.2%C2%A0decltype-toc" style="margin-left:160px;"><a href="#%F0%9F%8C%882.2%C2%A0decltype" rel="nofollow">🌈懒汉模式</a></p> 
<p id="2.%20%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-toc" style="margin-left:40px;"><a href="#2.%20%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2" rel="nofollow">2. 类型转换</a></p> 
<p id="2.1%20C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-toc" style="margin-left:80px;"><a href="#2.1%20C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2" rel="nofollow">2.1 C语言中的类型转换</a></p> 
<p id="2.2%C2%A0C%2B%2B%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-toc" style="margin-left:80px;"><a href="#2.2%C2%A0C%2B%2B%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2" rel="nofollow">2.2 C++中的类型转换</a></p> 
<p id="%F0%9F%8C%B12.2.1%20static_cast-toc" style="margin-left:120px;"><a href="#%F0%9F%8C%B12.2.1%20static_cast" rel="nofollow">🌱2.2.1 static_cast</a></p> 
<p id="%E2%98%98%EF%B8%8F%C2%A02.2.2%20reinterpret_cast-toc" style="margin-left:120px;"><a href="#%E2%98%98%EF%B8%8F%C2%A02.2.2%20reinterpret_cast" rel="nofollow">☘️ 2.2.2 reinterpret_cast</a></p> 
<p id="%F0%9F%8D%802.2.3%20const_cast-toc" style="margin-left:120px;"><a href="#%F0%9F%8D%802.2.3%20const_cast" rel="nofollow">🍀2.2.3 const_cast</a></p> 
<p id="%F0%9F%8C%BF2.2.4%C2%A0%C2%A0dynamic_cast-toc" style="margin-left:120px;"><a href="#%F0%9F%8C%BF2.2.4%C2%A0%C2%A0dynamic_cast" rel="nofollow">🌿2.2.4  dynamic_cast</a></p> 
<p id="2.3%20%E4%B8%BA%E4%BB%80%E4%B9%88C%2B%2B%E9%9C%80%E8%A6%81%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-toc" style="margin-left:80px;"><a href="#2.3%20%E4%B8%BA%E4%BB%80%E4%B9%88C%2B%2B%E9%9C%80%E8%A6%81%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2" rel="nofollow">2.3 为什么C++需要四种类型转换</a></p> 
<p id="2.4%20RTTI-toc" style="margin-left:80px;"><a href="#2.4%20RTTI" rel="nofollow">2.4 RTTI</a></p> 
<p id="2.5%C2%A0%E6%89%A9%E5%B1%95-toc" style="margin-left:80px;"><a href="#2.5%C2%A0%E6%89%A9%E5%B1%95" rel="nofollow">2.5 扩展</a></p> 
<p id="%C2%A02.5.1%C2%A0%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4-toc" style="margin-left:120px;"><a href="#%C2%A02.5.1%C2%A0%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4" rel="nofollow"> 2.5.1 内置类型和自定义类型之间</a></p> 
<p id="2.5.2%C2%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4-toc" style="margin-left:120px;"><a href="#2.5.2%C2%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4" rel="nofollow">2.5.2 自定义类型与自定义类型之间</a></p> 
<p id="2.6%C2%A0%E5%BB%BA%E8%AE%AE-toc" style="margin-left:80px;"><a href="#2.6%C2%A0%E5%BB%BA%E8%AE%AE" rel="nofollow">2.6 建议</a></p> 
<p id="%F0%9F%93%96%E5%90%8E%E8%A8%80-toc" style="margin-left:40px;"><a href="#%F0%9F%93%96%E5%90%8E%E8%A8%80" rel="nofollow">📖后言</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="1.%20%E7%89%B9%E6%AE%8A%E7%B1%BB%E8%AE%BE%E8%AE%A1" style="background-color:transparent;">1. 特殊类设计</h3> 
<h4 id="1.1%20%E6%97%A0%E6%B3%95%E8%A2%AB%E6%8B%B7%E8%B4%9D%E7%9A%84%E7%B1%BB" style="background-color:transparent;">1.1 无法被拷贝的类</h4> 
<blockquote> 
 <p> 🚀🚀拷贝只会放生在两个场景中：拷贝构造函数以及赋值运算符重载，因此想要让一个类禁止拷贝，只需让该类不能调用拷贝构造函数以及赋值运算符重载即可。</p> 
</blockquote> 
<h5 id="1.1.1%20C%2B%2B98%E7%9A%84%E5%81%9A%E6%B3%95%EF%BC%9A" style="background-color:transparent;"><span style="color:#0d0016;">1.1.1</span><span style="color:#a2e043;"><strong> C++98的做法：</strong></span></h5> 
<blockquote> 
 <ul><li>将拷贝构造函数与赋值运算符重载<strong>只声明不定义</strong>。（防自己）</li><li>并且将其<strong>访问权限设置为私有</strong>即可。（防外面）</li></ul> 
</blockquote> 
<pre><code class="language-cpp">class CopyBan
{
  // ...
  CopyBan(const CopyBan&amp;)=delete;
  CopyBan&amp; operator=(const CopyBan&amp;)=delete;
  //...
};</code></pre> 
<p><strong>原因：</strong></p> 
<ol><li>设置成私有：如果只声明没有设置成private，用户自己如果在类外定义了，就可以不能禁止拷贝了</li><li>只声明不定义：不定义是因为该函数根本不会调用，定义了其实也没有什么意义，不写反而还简单，而且如果定义了就不会防止成员函数内部拷贝了。</li></ol> 
<hr> 
<h5 id="1.1.2%20C%2B%2B11%E7%9A%84%E5%81%9A%E6%B3%95%EF%BC%9A" style="background-color:transparent;"><span style="color:#0d0016;">1.1.2</span><span style="color:#a2e043;"> C++11的做法：</span></h5> 
<p>   💢C++11扩展delete的用法，delete除了释放new申请的资源外，<strong>如果在默认成员函数后跟=delete，表示让编译器删除掉该默认成员函数。</strong></p> 
<pre><code class="language-cpp">class CopyBan
{
  // ...
  CopyBan(const CopyBan&amp;)=delete;
  CopyBan&amp; operator=(const CopyBan&amp;)=delete;
  //...
};</code></pre> 
<h4 id="1.2%C2%A0%E5%8F%AA%E8%83%BD%E5%9C%A8%E5%A0%86%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB" style="background-color:transparent;">1.2 只能在<span style="color:#956fe7;"><strong>堆</strong></span>上创建对象的类</h4> 
<p><strong><span style="color:#956fe7;">实现方式如下：</span></strong></p> 
<blockquote> 
 <p><strong><span style="color:#b95514;">思路1：</span></strong></p> 
 <p><strong>1. 将类的构造函数私有，拷贝构造声明成私有（可以直接delete掉）。防止别人调用拷贝在栈上生成对象。</strong></p> 
 <p>      <strong>注意：</strong>拷贝构造可以直接delete掉，但是构造函数不行！！因为我们还需要利用构造函数在堆上创建对象。</p> 
 <p></p> 
 <p><strong>2. 提供一个静态的成员函数，在该静态成员函数中完成堆对象的创建。</strong></p> 
 <p><strong>     </strong><strong>注意：</strong>这里涉及到的是先有鸡还是先有蛋的问题，因为如果不去创建这个对象就没有办法去调用他的构造函数，但是没有调用构造函数就没有办法创建对象。所以这里必须通过静态成员函数的返回值去构造堆对象。</p> 
</blockquote> 
<pre><code class="language-cpp">class HeapOnly
{
public:
    //HeapOnly* CreatrObj()
	static HeapOnly* CreateObject()//需要用静态的
	{
		return new HeapOnly;
	}
private:
	HeapOnly() {};
	HeapOnly(const HeapOnly&amp;) = delete;
};


int main()
{
	//HeapOnly H; //这个不行
	HeapOnly* p = HeapOnly::CreateObject();
	return 0;
}</code></pre> 
<p><img alt="" height="243" src="https://images2.imgbox.com/db/05/mhg6dKDB_o.png" width="1200"></p> 
<blockquote> 
 <p><strong><span style="color:#b95514;">思路2：</span></strong></p> 
 <p><strong>1、相比较于上一种思路把构造函数私有、拷贝构造delete，也可以选择将析构函数给设成私有。</strong></p> 
 <p><strong>  </strong><strong>    </strong>析构函数设置成私有同样会导致对象无法在栈上进行创建。因为自定义类型在栈帧中销毁的时候会去自动调用他的析构函数，但是因为调不到所以会报错。</p> 
 <p></p> 
 <p><strong>2、封装一个destory的成员函数，这样我们可以手动释放堆空间的资源。</strong></p> 
 <p>      在堆上创建对象是用指针去接受，所以并不影响，但是内存需要我们去手动释放，因此我们需要封装destory的成员函数去调用delete，这样delete可以对应调用到析构函数。 这里有两个方案：一种是设置能静态成员函数（类域调用），一种是设置成普通成员函数（对象自己调用）。</p> 
</blockquote> 
<pre><code class="language-cpp">class HeapOnly
{
public:
	//方案1 
	static void Destroy(HeapOnly* hp)
	{
		delete hp;
	}
	//方案2
	void Destroy()
	{
		delete this;
	}
private:
	~HeapOnly() {};
};


int main()
{
	//HeapOnly H; 调不到析构函数，无法创建
	//静态成员函数释放
	HeapOnly* hp1 = new HeapOnly;
	HeapOnly::Destroy(hp1);
   
    //HeapOnly hp(*hp1);

	//普通成员函数释放
	HeapOnly* hp2 = new HeapOnly;
	hp2-&gt;Destroy(); //手动释放

	return 0;
}</code></pre> 
<h4 id="1.3%20%E5%8F%AA%E8%83%BD%E5%9C%A8%E6%A0%88%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB" style="background-color:transparent;">1.3 只能在<span style="color:#956fe7;">栈</span>上创建对象的类</h4> 
<p>💢<strong>new和delete</strong>是全局的运算符重载函数，因此我们只要将这两个给禁用掉，就不会在堆上创建对象。</p> 
<h5 id="%F0%9F%8D%891.3.1%C2%A0%E5%AE%9E%E7%8E%B0%E4%B8%80%EF%BC%9A" style="background-color:transparent;"><strong>🍉1.3.1<span style="color:#a2e043;"> </span></strong><span style="color:#4da8ee;">实现一</span><span style="color:#a2e043;">：</span></h5> 
<pre><code class="language-cpp">class StackOnly
{
public:
	static StackOnly CreateObj()
	{
		return StackOnly();
	}

	// 封死拷贝构造
	//StackOnly(const StackOnly&amp; s) = delete; 
	
	// 禁掉operator new
	void* operator new(size_t size) = delete;
	void operator delete(void* p) = delete;

private:
	StackOnly()
		:_a(0)
	{}
private:
	int _a;
};

int main()
{
	// 1.由于构造私有化，无法直接构造
	//static StackOnly s1;
	//StackOnly s2;
	//StackOnly* s3 = new StackOnly;

	// 2.在栈上创建对象，如果封死拷贝构造，
    //由于封死了拷贝构造，Creatrobj也无法调用，因此下面我们都不封拷贝构造
	StackOnly s4 = StackOnly::CreateObj();

	// 3. 禁掉operator new可以把下面用new 调用拷贝构造申请对象给禁掉
	StackOnly* s5 = new StackOnly(s4); //拷贝构造

	// 4.由于拷贝构造没封，即使封死了operator new，也可以调用
	static StackOnly s6(s4); // 静态区


	return 0;
}</code></pre> 
<h5 id="%F0%9F%A5%9D1.3.2%C2%A0%E5%AE%9E%E7%8E%B0%E4%BA%8C%EF%BC%9A" style="background-color:transparent;"><strong>🥝1.3.2<span style="color:#4da8ee;"> 实现二：</span></strong></h5> 
<p> 🚀由于仍然是没有严格的封死，因此我们还是得封拷贝构造， 但是导致上面之前得都走不通<br>  但是因为我们这里实现了拷贝构造，那么这里就不会默认生成移动构造了，因此我们得写出移动构造</p> 
<pre><code class="language-cpp">class StackOnly
{
public:
	static StackOnly CreateObj()
	{
		return StackOnly();
	}

	// 封死拷贝构造
	StackOnly(const StackOnly&amp; s) = delete; 
	
	// 提供移动构造
	StackOnly(StackOnly&amp;&amp; s) 
	{}

private:
	StackOnly()
		:_a(0)
	{}
private:
	int _a;
};

int main()
{
	// 1.由于构造私有化，无法直接构造
	//static StackOnly s1;
	//StackOnly s2;
	//StackOnly* s3 = new StackOnly;

	// 2.拷贝构造封死，然后再调用移动构造，就可以彻底封死了
	StackOnly s4 = StackOnly::CreateObj();
	//StackOnly* s5 = new StackOnly(s4); 
	//static StackOnly s6(s4); 

	// 3.漏洞
	static StackOnly s7(move(s4));  //移动构造
	StackOnly* s8 = new StackOnly(move(s4));

	return 0;
}</code></pre> 
<p></p> 
<h4 id="1.4%20%E6%97%A0%E6%B3%95%E8%A2%AB%E7%BB%A7%E6%89%BF%E7%9A%84%E7%B1%BB" style="background-color:transparent;">1.4 无法被继承的类</h4> 
<h5 id="1.4.1%20C%2B%2B98%E7%9A%84%E5%81%9A%E6%B3%95%EF%BC%9A" style="background-color:transparent;"><span style="color:#0d0016;"><strong>1.4.1 </strong></span><span style="color:#a2e043;"><strong>C++98的做法：</strong></span></h5> 
<p>💢<strong>构造函数私有化，这样子类调用不到父类的构造函数，无法实现继承</strong></p> 
<pre><code class="language-cpp">// C++98中构造函数私有化，派生类中调不到基类的构造函数。则无法继承
class NonInherit
{
public:
    static NonInherit GetInstance()
    {
        return NonInherit();
    }
private:
    NonInherit()
    {}
};</code></pre> 
<h5 id="1.4.2%20C%2B%2B11%E7%9A%84%E5%81%9A%E6%B3%95%EF%BC%9A" style="background-color:transparent;"><span style="color:#0d0016;">1.4.2 </span><span style="color:#a2e043;">C++11的做法：</span></h5> 
<p>💢<strong>直接用final关键字，可以使得该类无法被继承</strong></p> 
<pre><code class="language-cpp">class A  final
{
  // ....
};</code></pre> 
<h4 id="1.5%C2%A0%E5%8F%AA%E8%83%BD%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1(%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F)">1.5 只能创建一个对象(单例模式)</h4> 
<h5 id="%F0%9F%8D%8D1.5.1%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A" style="background-color:transparent;"><strong>🍍1.5.1 设计模式：</strong></h5> 
<blockquote> 
 <p> 🎈设计模式（Design Pattern）是一套<strong>被反复使用、多数人知晓的、经过分类的、代码设计经验的总结</strong>。为什么会产生设计模式这样的东西呢？就像人类历史发展会产生兵法。最开始部落之间打仗时都是人拼人的对砍。后来春秋战国时期，七国之间经常打仗，就发现打仗也  是有套路的，后来孙子就总结出了《孙子兵法》。孙子兵法也是类似。<br>  🎈使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。</p> 
</blockquote> 
<h5 id="%F0%9F%8D%8E1.5.2%20%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%9A" style="background-color:transparent;">🍎1.5.2 单例模式：</h5> 
<blockquote> 
 <p><strong> ☘️☘️一个类只能创建一个对象，即单例模式，该模式可以保证系统中该类只有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。</strong>比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息，这种方式简化了在复杂环境下的配置管理。</p> 
</blockquote> 
<p>单例模式有两种实现模式：</p> 
<h6 id="%F0%9F%8C%882.2%C2%A0decltype">🌈饿汉模式</h6> 
<p><span style="color:#ad720d;"><strong>就是说不管你将来用不用，程序启动时就创建一个唯一的实例对象。</strong></span></p> 
<pre><code class="language-cpp">//main函数之前创建出来的就是饿汉
// 单例：全局只有唯一实例对象
///*——-------—————— 饿汉模式 ————————————*/ 
// 优点：简单
// 缺点：
//	1、多个饿汉模式的单例，某个对象初始化内容较多(读文件)，会导致程序启动慢
//	2、A和B两个饿汉，对象初始化存在依赖关系，要求A先初始化，B再初始化，饿汉无法保证

class InfoMgr
{
public:
	static InfoMgr&amp; GetInstance()
	{
		return _ins;
	}

	void Print()
	{
		cout &lt;&lt; _ip &lt;&lt; endl;
		cout &lt;&lt; _port &lt;&lt; endl;
		cout &lt;&lt; _buffSize &lt;&lt; endl;
	}
private:
	InfoMgr(const InfoMgr&amp;) = delete;
	InfoMgr&amp; operator=(const InfoMgr&amp;) = delete;

	InfoMgr()
	{
		cout &lt;&lt; "InfoMgr()" &lt;&lt; endl;
	}
private:
	string _ip = "127.0.0.1";
	int _port = 80;
	size_t _buffSize = 1024 * 1024;
	//...

	static InfoMgr _ins;
};
InfoMgr InfoMgr::_ins; // 在程序入口之前就完成单例对象的初始化

int main()
{
	cout &lt;&lt; endl;
	InfoMgr::GetInstance().Print();
	//InfoMgr copy(InfoMgr::GetInstance());
	cout &lt;&lt; endl;
	InfoMgr::GetInstance().Print();

	cout &lt;&lt; endl;
	cout &lt;&lt; &amp;InfoMgr::GetInstance() &lt;&lt; endl;
	cout &lt;&lt; &amp;InfoMgr::GetInstance() &lt;&lt; endl;

	return 0;
}</code></pre> 
<p><img alt="" height="494" src="https://images2.imgbox.com/c9/54/9fZJ7YtV_o.png" width="1165"></p> 
<p><span style="color:#fe2c24;">注：</span>如果这个单例对象在<strong>多线程高并发环境</strong>下频繁使用，性能要求较高，那么显然使用<strong>饿汉模式</strong>来<strong>避免资源竞争，提高响应速度更好</strong>。</p> 
<h6 style="background-color:transparent;">🌈懒汉模式</h6> 
<blockquote> 
 <p><strong> ☘️☘️</strong>如果<strong>单例对象构造十分耗时或者占用很多资源</strong>，比如加载插件啊， 初始化网络连接啊，读取文件啊等等，而有可能该对象程序运行时不会用到，那么也要在程序一开始就进行初始化，就会导致程序启动时非常的缓慢。 所以这种情况使用懒汉模式<strong>（延迟加载）</strong>更好。</p> 
</blockquote> 
<p><strong><span style="color:#4da8ee;">写法一：</span></strong></p> 
<pre><code class="language-cpp">class InfoMgr
{
public:
	// 第一次调用时再去创建单例对象
	// 线程安全的风险（暂时没学）
	static InfoMgr&amp; GetInstance()
	{
		if (_pins == nullptr) //第一次调用刚好是空
		{
			_pins = new InfoMgr;
		}
		return *_pins;
	}

	void Print()
	{
		cout &lt;&lt; _ip &lt;&lt; endl;
		cout &lt;&lt; _port &lt;&lt; endl;
		cout &lt;&lt; _buffSize &lt;&lt; endl;
	}

	static void DelInstance() //主动释放单例
	{
		delete _pins;
		_pins = nullptr;
	}

private:
	InfoMgr(const InfoMgr&amp;) = delete;
	InfoMgr&amp; operator=(const InfoMgr&amp;) = delete;

	InfoMgr()
	{
		cout &lt;&lt; "InfoMgr()" &lt;&lt; endl;
	}
private:
	string _ip = "127.0.0.1";
	int _port = 80;
	size_t _buffSize = 1024 * 1024;
	//...

	static InfoMgr* _pins;
};

InfoMgr* InfoMgr::_pins = nullptr; //设计为指针</code></pre> 
<p><strong><span style="color:#4da8ee;">写法二：</span></strong></p> 
<p><strong><span style="color:#4da8ee;">懒汉模式更简单的写法，C++11之后更加推荐</span></strong></p> 
<pre><code class="language-cpp">//懒汉模式更简单的写法，C++11之后更加推荐
class InfoMgr
{
public:
	// 第一次调用时再去创建单例对象
	// 线程安全的风险（暂时没学）
	static InfoMgr&amp; GetInstance()
	{
		//C++11之后才是这样
		static InfoMgr ins; //创建一个局部的静态，因为局部的静态是在创建的时候初始化
		return ins;
	}

	void Print()
	{
		cout &lt;&lt; _ip &lt;&lt; endl;
		cout &lt;&lt; _port &lt;&lt; endl;
		cout &lt;&lt; _buffSize &lt;&lt; endl;
	}

private:
	InfoMgr(const InfoMgr&amp;) = delete;
	InfoMgr&amp; operator=(const InfoMgr&amp;) = delete;

	InfoMgr()
	{
		cout &lt;&lt; "InfoMgr()" &lt;&lt; endl;
	}
private:
	string _ip = "127.0.0.1";
	int _port = 80;
	size_t _buffSize = 1024 * 1024;
	//...

	static InfoMgr* _pins;
};

InfoMgr* InfoMgr::_pins = nullptr; //设计为指针</code></pre> 
<p><strong>调用及结果示意：</strong></p> 
<pre><code class="language-cpp">int main()
{
	cout &lt;&lt; endl;
	InfoMgr::GetInstance().Print();

	cout &lt;&lt; endl;
	InfoMgr::GetInstance().Print();

	cout &lt;&lt; endl;
	//查看多次调用时对象地址
	cout &lt;&lt; &amp;InfoMgr::GetInstance() &lt;&lt; endl;
	cout &lt;&lt; &amp;InfoMgr::GetInstance() &lt;&lt; endl;

	return 0;
}</code></pre> 
<p><img alt="" height="483" src="https://images2.imgbox.com/30/c0/lb7VrDXj_o.png" width="1182"></p> 
<blockquote> 
 <p>从饿汉与懒汉模式得打印结果我们可以发现，饿汉模式是先进行的全局然后再进行main函数，而懒汉模式是先进入main函数中才开始。</p> 
</blockquote> 
<h3></h3> 
<h3 id="2.%20%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">2. 类型转换</h3> 
<h4 id="2.1%20C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2" style="background-color:transparent;"><a name="t8"></a>2.1 C语言中的类型转换</h4> 
<blockquote> 
 <p>🚀🚀在C语言中，如果<strong>赋值运算符左右两侧类型不同，或者形参与实参类型不匹配，或者返回值类型与接收返回值类型不一致时，就需要发生类型转化</strong>，C语言中总共有两种形式的类型转换：<strong>隐式类型转换和显式类型转换。</strong></p> 
</blockquote> 
<ol><li> 隐式类型转化：编译器在编译阶段自动进行，能转就转，不能转就编译失败</li><li> 显式类型转化：需要用户自己处理</li></ol> 
<pre><code class="language-cpp">/* ———————————— a. 内置类型——————————————————*/
 //1、隐式类型转换    整形之间/整形和浮点数之间
 //2、显示类型的转换  指针和整形、指针之间

int main()
{
	int i = 1;
	// 隐式类型转换
	double d = i;
	printf("%d, %.2f\n", i, d);

	int* p = &amp;i;
	// 显示的强制类型转换
	int address = (int)p;
	printf("%p, %d\n", p, address);

	return 0;
}</code></pre> 
<p style="background-color:transparent;">缺陷：<strong>转换的可视性比较差，所有的转换形式都是以一种相同形式书写，难以跟踪错误的转换</strong></p> 
<p></p> 
<h4 id="2.2%C2%A0C%2B%2B%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">2.2 C++中的类型转换</h4> 
<p>标准C++为了<strong>加强类型转换的可视性</strong>，引入了四种命名的强制类型转换操作符</p> 
<h5 id="%F0%9F%8C%B12.2.1%20static_cast" style="background-color:transparent;"><span style="color:#0d0016;">🌱2.2.1</span><span style="color:#956fe7;"> static_cast</span></h5> 
<p><strong>       static_cast用于非多态类型的转换（静态转换），编译器隐式执行的任何类型转换都可用（相近类型用static_cast-&gt;意义相似的类型）</strong></p> 
<pre><code class="language-cpp">int main()
{
	double d = 12.34;
	int a = static_cast&lt;int&gt;(d);
	cout &lt;&lt; a &lt;&lt; endl;
	return 0;
}</code></pre> 
<h5 id="%E2%98%98%EF%B8%8F%C2%A02.2.2%20reinterpret_cast"><span style="color:#956fe7;">☘️ </span><span style="color:#0d0016;">2.2.2</span><span style="color:#956fe7;"> reinterpret_cast</span></h5> 
<p>       <strong> reinterpret_cast操作符通常为操作数的位模式提供较低层次的重新解释，用于将一种类型转换为另一种不同的类型（一定的关联，但是意义不相似的的类型用reinterpret_cast</strong> <strong>）</strong></p> 
<pre><code class="language-cpp">int main()
{
	double d = 12.34;
	int a = static_cast&lt;int&gt;(d);
	cout &lt;&lt; a &lt;&lt; endl;
	// 这里使用static_cast会报错，应该使用reinterpret_cast
	//int *p = static_cast&lt;int*&gt;(a);
	int* p = reinterpret_cast&lt;int*&gt;(a);
	return 0;
}</code></pre> 
<h5 id="%F0%9F%8D%802.2.3%20const_cast">🍀2.2.3 const_cast</h5> 
<p><strong>       const_cast最常用的用途就是删除变量的const属性，方便做赋值操作（const_cast的类型必须是对象的指针或者引用）</strong></p> 
<pre><code class="language-cpp">int main()
{

	// 对应强制类型转换中有风险的去掉const属性
	//常变量
	const int b = 2;

	//int* p2 = (int*)&amp;b; //上下两种方式效果等同
	int* p2 = const_cast&lt;int*&gt;(&amp;b);
	*p2 = 3;

	const int c = b; //在这里很明显可以看到 b 的具体值

	// b 其实在内存中已经修改为3，比如在监视窗口下就是3，但是去读的时候已经变成常量2了
	cout &lt;&lt; b &lt;&lt; " " &lt;&lt;  * p2 &lt;&lt; " " &lt;&lt; c &lt;&lt; endl;

	return 0;
}
</code></pre> 
<p><img alt="" height="282" src="https://images2.imgbox.com/12/38/1Xe5tq0j_o.png" width="1184"></p> 
<p><strong>思考：为什么*p被修改了，a却没有被修改？？</strong></p> 
<p>       因为常量被存到寄存器中了，所以其实改变的是内存中的a，但是不是寄存器中的a。这其实是一种优化，如果我们想要去掉这种优化，用<strong>volatile关键字（告诉编译器不要优化，直接从内存中读取）</strong></p> 
<p><strong><span style="color:#956fe7;">volatile关键字</span></strong></p> 
<p>     这里我们可以使用volatile 来打印我们希望的结果 3 </p> 
<blockquote> 
 <p>当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据， 即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存</p> 
</blockquote> 
<pre><code class="language-cpp">int main()
{
	 // 我们可以使用volatile 来打印我们希望的结果 3 
	volatile const int b = 2; 

	//int* p2 = (int*)&amp;b; //上下两种方式效果等同
	int* p2 = const_cast&lt;int*&gt;(&amp;b);
	*p2 = 3;

	const int c = b; //在这里很明显可以看到 b 的具体值

	cout &lt;&lt; b &lt;&lt; " " &lt;&lt;  * p2 &lt;&lt; " " &lt;&lt; c &lt;&lt; endl;

	return 0;
}</code></pre> 
<p><img alt="" height="326" src="https://images2.imgbox.com/9c/ea/wejH7X6F_o.png" width="1200"></p> 
<h5 id="%F0%9F%8C%BF2.2.4%C2%A0%C2%A0dynamic_cast" style="background-color:transparent;">🌿2.2.4  dynamic_cast</h5> 
<blockquote> 
 <p>dynamic_cast用于将一个父类对象的指针/引用转换为子类对象的指针或引用(动态转换)<br><strong>向上转型：</strong>子类对象指针/引用-&gt;父类指针/引用(不需要转换，赋值兼容规则)<br><strong>向下转型：</strong>父类对象指针/引用-&gt;子类指针/引用(用dynamic_cast转型是安全的)<br> 注意：</p> 
 <ol><li> dynamic_cast只能用于父类含有虚函数的类</li><li>dynamic_cast会先检查是否能转换成功，能成功则转换，不能则返回nullptr。</li></ol> 
</blockquote> 
<p>举个例子🌰：</p> 
<p>假如存在下面这样一个类和main函数：</p> 
<pre><code class="language-cpp">class A
{
public:
	virtual void f() {}

	int _a = 1;
};
class B : public A
{
public:
	int _b = 2;
};

void fun(* pa){}

int main()
{
	A a;
	B b;
	fun(&amp;a);
	fun(&amp;b);
	return 0;
}</code></pre> 
<p><span style="color:#956fe7;">假如fun函数实现如下：</span></p> 
<pre><code class="language-cpp">void fun(A* pa)
{
	// 指向父类转换时有风险的，后续访问存在越界访问的风险
	// 指向子类转换时安全
	B* pb1 = (B*)pa;
	cout &lt;&lt; "pb1: " &lt;&lt; pb1 &lt;&lt; endl;
	cout &lt;&lt; "pb1-&gt;_a: " &lt;&lt; pb1-&gt;_a &lt;&lt; endl;
	cout &lt;&lt; "pb1-&gt;_b: " &lt;&lt; pb1-&gt;_b &lt;&lt; endl;

	pb1-&gt;_a++;
	pb1-&gt;_b++;
	cout &lt;&lt; "pb1-&gt;_a: " &lt;&lt; pb1-&gt;_a &lt;&lt; endl;
	cout &lt;&lt; "pb1-&gt;_b: " &lt;&lt; pb1-&gt;_b &lt;&lt; endl
}</code></pre> 
<p><img alt="" height="347" src="https://images2.imgbox.com/aa/02/tmZAtvpi_o.png" width="1145"></p> 
<p><span style="color:#fe2c24;">因此我们就需要用到 dynamic_cast 来解决子类转换为 父类的问题</span></p> 
<pre><code class="language-cpp">void fun(A* pa)
{
	// dynamic_cast会先检查是否能转换成功(指向子类对象)，能成功则转换，
	// (指向父类对象)不能则返回NULL

	B* pb1 = dynamic_cast&lt;B*&gt;(pa);
	if (pb1) //先判断是否为空
	{
		cout &lt;&lt; "pb1:" &lt;&lt; pb1 &lt;&lt; endl;
		cout &lt;&lt; "pb1-&gt;_a: " &lt;&lt; pb1-&gt;_a &lt;&lt; endl;
		cout &lt;&lt; "pb1-&gt;_b: " &lt;&lt; pb1-&gt;_b &lt;&lt; endl;
		pb1-&gt;_a++;
		pb1-&gt;_b++;
		cout &lt;&lt; "pb1-&gt;_a: " &lt;&lt; pb1-&gt;_a &lt;&lt; endl;
		cout &lt;&lt; "pb1-&gt;_b: " &lt;&lt; pb1-&gt;_b &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; "转换失败" &lt;&lt; endl;
	}

	B* pb2 = static_cast&lt;B*&gt;(pa);
	B* pb3 = dynamic_cast&lt;B*&gt;(pa);
	cout &lt;&lt; "pb2: " &lt;&lt; pb2 &lt;&lt; endl;
	cout &lt;&lt; "pb3: " &lt;&lt; pb3 &lt;&lt; endl;

}</code></pre> 
<p><img alt="" height="339" src="https://images2.imgbox.com/63/6e/5iP2dq1z_o.png" width="996"></p> 
<p><strong><span style="color:#956fe7;">课外知识点：</span></strong></p> 
<p><strong><span style="color:#b95514;">1、为什么父类和子类明明是两种类型，但是向上转型不需要转换呢？？</span></strong></p> 
<p>    因为子类会直接充当子类中父类那一部分的别名，不存在类型转换</p> 
<p><span style="color:#b95514;"><strong>2、为什么向下转型是不安全的？？</strong></span></p> 
<p>      因为子类的指针或引用如果是父类对象，那么会存在一部分的越界！！！</p> 
<p><strong><span style="color:#b95514;">3、为什么 dynamic_cast只能用于父类含有虚函数的类</span></strong></p> 
<p>        dynamic_cast转换是在运行时进行转换，因为只有对于这种类层次结构，才应该将派生类的地址赋给基类指针。运行时转换就需要知道类对象的信息（继承关系等）。C++对象模型中，对象实例最前面的就是虚函数表指针，通过这个指针可以获取到该类对象的所有虚函数，包括父类的。因为派生类会继承基类的虚函数表，所以通过这个虚函数表，我们就可以知道该类对象的父类，在转换的时候就可以用来判断对象有无继承关系。</p> 
<p>　　所以虚函数对于正确的基类指针转换为子类指针是非常重要的。</p> 
<p><strong><span style="color:#b95514;">4、dynamic_cast的使用原理</span></strong></p> 
<p>       父类指针或引用如果本来指向的是子类的对象，那么类型转化是安全的，如果原本指向的是父类的对象，那么转化是不安全的（有越界，但是编译器检查不出来)，所以dynamic_cast可以帮助我们去判断这种情况，如果不符合安全转化的条件，就会返回nullptr。</p> 
<h4 id="2.3%20%E4%B8%BA%E4%BB%80%E4%B9%88C%2B%2B%E9%9C%80%E8%A6%81%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2" style="background-color:transparent;">2.3 为什么C++需要四种类型转换</h4> 
<blockquote> 
 <p>C风格的转换格式很简单，但是有不少缺点的：</p> 
 <ol><li>隐式类型转化有些情况下可能会出问题：比如数据精度丢失</li><li>显式类型转换将所有情况混合在一起，代码不够清晰</li><li>为了提供更安全、更明确的类型转换，使得代码意图更为清晰</li></ol> 
</blockquote> 
<p>       因此C++提出了自己的类型转化风格，注意因为C++要兼容C语言，所以C++中还可以使用C语言的转化风格。因此C++的转化风格并非强制性的，只不过是程序员之间的一种规范。</p> 
<p></p> 
<h4 id="2.4%20RTTI" style="background-color:transparent;">2.4 RTTI</h4> 
<blockquote> 
 <p>RTTI：Run-time Type identification的简称，即：运行时类型识别。RTTI只适用于包含虚函数的类。<br> C++通过以下方式来支持RTTI：</p> 
 <ol><li>typeid运算符（返回指出对象类型的值）</li><li>dynamic_cast运算符（根据虚基表判断有无继承关系，并判断是否可以转化）</li><li>decltype（推断表达式返回值的类型）</li></ol> 
</blockquote> 
<p></p> 
<h4 id="2.5%C2%A0%E6%89%A9%E5%B1%95" style="background-color:transparent;">2.5 扩展</h4> 
<h5 id="%C2%A02.5.1%C2%A0%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4" style="background-color:transparent;"> 2.5.1 内置类型和自定义类型之间</h5> 
<p>由于自定义类型无法像内置类型那样转换，因此我们要实现实现一个 operator int() 的函数来进行转换，详情请看下面代码及注解<span style="color:#fe2c24;">（注：explicit 可禁止隐式类型转换）</span></p> 
<pre><code class="language-cpp">/* ———————————— b. 内置类型和自定义类型之间——————————————————*/
//1、自定义类型 = 内置类型  -&gt; 构造函数支持 （单参数和多参数的隐式类型转换时通过构造函数来支持的）
// 2、内置类型 = 自定义类型 （自定义类型，转化为内置类型）

class A {
public:
	//explicit A(int a) //禁止隐式类型转换
	A(int a)
		:_a1(a)
		, _a2(a)
	{}
	A(int a1,int a2)
		:_a1(a1)
		, _a2(a2)
	{}

	//int operator()() 中()被仿函数占用了，不能用
	// operator 类型实现，无返回类型
  // 自定义类型转换为内置类型
	//explicit operator int()
	operator int()
	{
		return _a1 + _a2;
	}

private:
	int _a1 = 1;
	int _a2 = 1;
};

int main()
{
	//单参数的隐式类型转换
	//在其对应的构造函数那加了explicit关键字，就不支持隐式类型转换
	//A aa1 = 1; //单参数类型转换为自定义类型，靠构造函数转的
	A aa1 = A(1);//但是还是支持转换

	//多参数的隐式类型转换
	A aa2 = { 2,2 };
	const A&amp; aa3 = { 2,2 };

	//int z = aa1.operator int();//本质是这个
	int x = aa1; //隐式类型转换
	int y = (int)aa2; //显式类型转换
	cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; endl;

	//智能指针的条件逻辑判断

	std::shared_ptr&lt;int&gt; foo;
	std::shared_ptr&lt;int&gt; bar(new int(34));

	//if (foo.operator bool())
	if (foo)
		std::cout &lt;&lt; "foo points to " &lt;&lt; *foo &lt;&lt; '\n';
	else 
		std::cout &lt;&lt; "foo is null\n";

	if (bar)
		std::cout &lt;&lt; "bar points to " &lt;&lt; *bar &lt;&lt; '\n';
	else
		std::cout &lt;&lt; "bar is null\n";

	return 0;
}
</code></pre> 
<h5 id="2.5.2%C2%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4" style="background-color:transparent;">2.5.2 自定义类型与自定义类型之间</h5> 
<pre><code class="language-cpp">/* ———————————— c. 自定义类型和自定义类型之间——————————————————*/
// c、自定义类型和自定义类型之间 -- 需要书写对应的构造函数支持

class A {
public:
	A(int a)
		:_a1(a)
		, _a2(a)
	{}
	A(int a1, int a2)
		:_a1(a1)
		, _a2(a2)
	{}

	int get()const
	{
		return _a1 + _a2;
	}

private:
	int _a1 = 1;
	int _a2 = 1;
};


class B
{
public:
	B(int b)
		:_b1(b)
	{}

	B(const A&amp;aa)
		:_b1(aa.get())
	{}

private:
	int _b1 = 1;
};

#include "List.h"
int main()
{
	A aa1(1);
	B bb1(1);

	//aa1 = bb1;
	bb1 = aa1;
	B&amp; ref1 = bb1;

	//B&amp; ref2 = aa1;
	const B&amp; ref2 = aa1;

	qian::list&lt;int&gt; l1 = { 1,2,3,4 };
	//权限的缩小？ 权限的缩小和放大，仅限于const的指针和引用
	// 不是权限缩小，这里是类型转换
	qian::list&lt;int&gt;::const_iterator cit = l1.begin();
	while (cit != l1.end())
	{
		cout &lt;&lt; *cit &lt;&lt; " ";
		++cit;
	}
	cout &lt;&lt; endl;


	return 0;
}</code></pre> 
<p><strong>注：</strong></p> 
<blockquote> 
 <p>🔥<strong>我们是在该文章 </strong><a href="https://blog.csdn.net/island1314/article/details/140149523?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22140149523%22%2C%22source%22%3A%22island1314%22%7D" title="C++/STL】list容器的深度剖析及底层实现-CSDN博客">C++/STL】list容器的深度剖析及底层实现-CSDN博客</a> 的完整代码作为List.h文件下，加了这一段话到其头文件中</p> 
</blockquote> 
<pre><code class="language-cpp">//支持const迭代器与普通迭代器的转换
ListIterator(const ListIterator&lt;T, T&amp;, T*&gt;&amp; it)
    :_node(it._node)
{}</code></pre> 
<h4 id="2.6%C2%A0%E5%BB%BA%E8%AE%AE" style="background-color:transparent;">2.6 建议</h4> 
<p>  🔥 强制类型转换关闭或挂起了正常的类型检查，每次使用强制类型转换前，程序员应该仔细考虑是否还有其他不同的方法达到同一目的，如果非强制类型转换不可，则应限制强制转换值的作用域，以减少发生错误的机会。强烈建议：避免使用强制类型转换</p> 
<p></p> 
<h3 id="%F0%9F%93%96%E5%90%8E%E8%A8%80" style="background-color:transparent;">📖后言</h3> 
<blockquote> 
 <span style="color:#4f4f4f;">以上就是特殊类设计及类型转换的全部类型啦</span> 
 <p>💞 💞 💞<strong>那么本篇到此就结束，希望我的这篇博客可以给你提供有益的参考和启示，感谢大家支持！！！祝大家天天开心</strong></p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/36/e9/Q6BnoOt8_o.gif"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/32cfb2ea70b1df2be606d25a17e8f1ad/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【MySQL基础】非常全面！一文掌握MySQL常用语法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/75613d206e55c9923b8efb2a942482cf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Datawhale X 魔搭 AI夏令营第四期 魔搭-AIGC方向 task01笔记</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>