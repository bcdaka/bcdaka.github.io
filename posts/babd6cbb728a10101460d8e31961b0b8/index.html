<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;第四十一弹---C&#43;&#43;11新特性深度解析：让你的代码更现代、更高效(上) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/babd6cbb728a10101460d8e31961b0b8/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C&#43;&#43;第四十一弹---C&#43;&#43;11新特性深度解析：让你的代码更现代、更高效(上)">
  <meta property="og:description" content="✨个人主页： 熬夜学编程的小林
💗系列专栏： 【C语言详解】 【数据结构详解】【C&#43;&#43;详解】
目录
1. C&#43;&#43;11简介
2. 统一的列表初始化
2.1 ｛｝初始化
2.2 std::initializer_list
3. 声明
3.1 auto
3.2 decltype
3.3 nullptr
3.4 STL中一些变化
1. C&#43;&#43;11简介 阶段内容C with
classes类及派生类、公有和私有成员、类的构造和析构、友元、内联函数、赋值运算符
重载等C&#43;&#43;1.0添加虚函数概念，函数和运算符重载，引用、常量等C&#43;&#43;2.0更加完善支持面向对象，新增保护成员、多重继承、对象的初始化、抽象类、静
态成员以及const成员函数C&#43;&#43;3.0进一步完善，引入模板，解决多重继承产生的二义性问题和相应构造和析构的处
理C&#43;&#43;98C&#43;&#43;标准第一个版本，绝大多数编译器都支持，得到了国际标准化组织(ISO)和美
国标准化协会认可，以模板方式重写C&#43;&#43;标准库，引入了STL(标准模板库)C&#43;&#43;03C&#43;&#43;标准第二个版本，语言特性无大改变，主要：修订错误、减少多异性C&#43;&#43;05C&#43;&#43;标准委员会发布了一份计数报告(Technical Report，TR1)，正式更名
C&#43;&#43;0x，即：计划在本世纪第一个10年的某个时间发布C&#43;&#43;11增加了许多特性，使得C&#43;&#43;更像一种新语言，比如：正则表达式、基于范围for循
环、auto关键字、新容器、列表初始化、标准线程库等C&#43;&#43;14对C&#43;&#43;11的扩展，主要是修复C&#43;&#43;11中漏洞以及改进，比如：泛型的lambda表
达式，auto的返回值类型推导，二进制字面常量等C&#43;&#43;17在C&#43;&#43;11上做了一些小幅改进，增加了19个新特性，比如：static_assert()的文
本信息可选，Fold表达式用于可变的模板，if和switch语句中的初始化器等C&#43;&#43;20自C&#43;&#43;11以来最大的发行版，引入了许多新的特性，比如：模块(Modules)、协
程(Coroutines)、范围(Ranges)、概念(Constraints)等重大特性，还有对已有
特性的更新：比如Lambda支持模板、范围for支持初始化等C&#43;&#43;23制定ing 在2003年C&#43;&#43;标准委员会曾经提交了一份技术勘误表(简称TC1)，使得C&#43;&#43;03这个名字已经取代了C&#43;&#43;98称为C&#43;&#43;11之前的最新C&#43;&#43;标准名称。不过由于C&#43;&#43;03(TC1)主要是对C&#43;&#43;98标准中的漏洞进行修复，语言的核心部分则没有改动，因此人们习惯性的把两个标准合并称为C&#43;&#43;98/03标准。从C&#43;&#43;0x到C&#43;&#43;11，C&#43;&#43;标准10年磨一剑，第二个真正意义上的标准珊珊来迟。相比于C&#43;&#43;98/03，C&#43;&#43;11则带来了数量可观的变化，其中包含了约140个新特性，以及对C&#43;&#43;03标准中
约600个缺陷的修正，这使得C&#43;&#43;11更像是从C&#43;&#43;98/03中孕育出的一种新语言。相比较而言，
C&#43;&#43;11能更好地用于系统开发和库开发、语法更加泛华和简单化、更加稳定和安全，不仅功能更
强大，而且能提升程序员的开发效率，公司实际项目开发中也用得比较多，所以我们要作为一个
重点去学习。C&#43;&#43;11增加的语法特性非常篇幅非常多，我们这里没办法一 一讲解，所以本节课程
主要讲解实际中比较实用的语法。
C&#43;&#43;11官网https://en.cppreference.com/w/cpp/11小故事：
1998年是C&#43;&#43;标准委员会成立的第一年，本来计划以后每5年视实际需要更新一次标准，C&#43;&#43;国际标准委员会在研究C&#43;&#43; 03的下一个版本的时候，一开始计划是2007年发布，所以最初这个标准叫C&#43;&#43; 07。但是到06年的时候，官方觉得2007年肯定完不成C&#43;&#43; 07，而且官方觉得2008年可能也完不成。最后干脆叫C&#43;&#43; 0x。x的意思是不知道到底能在07还是08还是09年完成。结果2010年的时候也没完成，最后在2011年终于完成了C&#43;&#43;标准。所以最终定名为C&#43;&#43;11。
2. 统一的列表初始化 2.1 ｛｝初始化 在C&#43;&#43;98中，标准允许使用花括号{}对数组或者结构体元素进行统一的列表初始值设定。比如：
// 1、{}初始化 struct Point { int _x; int _y; }; int main() { // C语言中支持数组使用{}花括号初始化 int array1[] = { 1,2,3,4,5 }; int array2[5] = { 0 }; int array3[5]{ 0 };// 可以不加= // C语言中结构体支持使用{}初始化 Point p = { 1,2 }; return 0; } 测试结果 C&#43;&#43;11扩大了用大括号括起的列表(初始化列表)的使用范围，使其可用于所有的内置类型和用户自">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-26T12:14:55+08:00">
    <meta property="article:modified_time" content="2024-08-26T12:14:55+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;第四十一弹---C&#43;&#43;11新特性深度解析：让你的代码更现代、更高效(上)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"> ✨<span style="color:#956fe7;">个人主页：</span><a href="https://blog.csdn.net/2201_75584283?spm=1011.2415.3001.5343" title=" 熬夜学编程的小林"> 熬夜学编程的小林</a></p> 
<p style="text-align:center;">💗<span style="color:#fe2c24;">系列专栏： </span><a href="https://blog.csdn.net/2201_75584283/category_12556736.html" title="【C语言详解】">【C语言详解】</a> <a href="https://blog.csdn.net/2201_75584283/category_12556751.html" title="【数据结构详解】">【数据结构详解】</a><a href="https://blog.csdn.net/2201_75584283/category_12577595.html?spm=1001.2014.3001.5482" title="【C++详解】">【C++详解】</a></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="1.%20C%2B%2B11%E7%AE%80%E4%BB%8B-toc" style="margin-left:0px;"><a href="#1.%20C%2B%2B11%E7%AE%80%E4%BB%8B" rel="nofollow">1. C++11简介</a></p> 
<p id="2.%20%E7%BB%9F%E4%B8%80%E7%9A%84%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:0px;"><a href="#2.%20%E7%BB%9F%E4%B8%80%E7%9A%84%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">2. 统一的列表初始化</a></p> 
<p id="2.1%20%EF%BD%9B%EF%BD%9D%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:40px;"><a href="#2.1%20%EF%BD%9B%EF%BD%9D%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">2.1 ｛｝初始化</a></p> 
<p id="2.2%20std%3A%3Ainitializer_list-toc" style="margin-left:40px;"><a href="#2.2%20std%3A%3Ainitializer_list" rel="nofollow">2.2 std::initializer_list</a></p> 
<p id="3.%20%E5%A3%B0%E6%98%8E-toc" style="margin-left:0px;"><a href="#3.%20%E5%A3%B0%E6%98%8E" rel="nofollow">3. 声明</a></p> 
<p id="3.1%20auto-toc" style="margin-left:40px;"><a href="#3.1%20auto" rel="nofollow">3.1 auto</a></p> 
<p id="3.2%20decltype-toc" style="margin-left:40px;"><a href="#3.2%20decltype" rel="nofollow">3.2 decltype</a></p> 
<p id="3.3%20nullptr-toc" style="margin-left:40px;"><a href="#3.3%20nullptr" rel="nofollow">3.3 nullptr</a></p> 
<p id="3.4%20STL%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%8F%98%E5%8C%96-toc" style="margin-left:40px;"><a href="#3.4%20STL%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%8F%98%E5%8C%96" rel="nofollow">3.4 STL中一些变化</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1.%20C%2B%2B11%E7%AE%80%E4%BB%8B">1. C++11简介</h2> 
<table align="center"><thead><tr><th style="text-align:center;">阶段</th><th style="text-align:center;">内容</th></tr></thead><tbody><tr><td style="text-align:center;">C with<br> classes</td><td style="text-align:center;">类及派生类、公有和私有成员、类的构造和析构、友元、内联函数、赋值运算符<br> 重载等</td></tr><tr><td style="text-align:center;">C++1.0</td><td style="text-align:center;">添加虚函数概念，函数和运算符重载，引用、常量等</td></tr><tr><td style="text-align:center;">C++2.0</td><td style="text-align:center;">更加完善支持面向对象，新增保护成员、多重继承、对象的初始化、抽象类、静<br> 态成员以及const成员函数</td></tr><tr><td style="text-align:center;">C++3.0</td><td style="text-align:center;">进一步完善，引入模板，解决多重继承产生的二义性问题和相应构造和析构的处<br> 理</td></tr><tr><td style="text-align:center;">C++98</td><td style="text-align:center;">C++标准第一个版本，绝大多数编译器都支持，得到了国际标准化组织(ISO)和美<br> 国标准化协会认可，以模板方式重写C++标准库，引入了STL(标准模板库)</td></tr><tr><td style="text-align:center;">C++03</td><td style="text-align:center;">C++标准第二个版本，语言特性无大改变，主要：修订错误、减少多异性</td></tr><tr><td style="text-align:center;">C++05</td><td style="text-align:center;">C++标准委员会发布了一份计数报告(Technical Report，TR1)，正式更名<br> C++0x，即：计划在本世纪第一个10年的某个时间发布</td></tr><tr><td style="text-align:center;">C++11</td><td style="text-align:center;">增加了许多特性，使得C++更像一种新语言，比如：正则表达式、基于范围for循<br> 环、auto关键字、新容器、列表初始化、标准线程库等</td></tr><tr><td style="text-align:center;">C++14</td><td style="text-align:center;">对C++11的扩展，主要是修复C++11中漏洞以及改进，比如：泛型的lambda表<br> 达式，auto的返回值类型推导，二进制字面常量等</td></tr><tr><td style="text-align:center;">C++17</td><td style="text-align:center;">在C++11上做了一些小幅改进，增加了19个新特性，比如：static_assert()的文<br> 本信息可选，Fold表达式用于可变的模板，if和switch语句中的初始化器等</td></tr><tr><td style="text-align:center;">C++20</td><td style="text-align:center;">自C++11以来最大的发行版，引入了许多新的特性，比如：模块(Modules)、协<br> 程(Coroutines)、范围(Ranges)、概念(Constraints)等重大特性，还有对已有<br> 特性的更新：比如Lambda支持模板、范围for支持初始化等</td></tr><tr><td style="text-align:center;">C++23</td><td style="text-align:center;">制定ing</td></tr></tbody></table> 
<p><br><br> 在2003年C++标准委员会曾经提交了一份技术勘误表(简称TC1)，使得C++03这个名字已经取代了C++98称为C++11之前的最新C++标准名称。不过由于C++03(TC1)主要是对C++98标准中的漏洞进行修复，语言的核心部分则没有改动，因此人们习惯性的把两个标准合并称为C++98/03标准。从C++0x到C++11，C++标准10年磨一剑，第二个真正意义上的标准珊珊来迟。相比于C++98/03，<strong><span style="color:#0d0016;">C++11则带来了数量可观的变化，其中包含了约140个新特性，以及对C++03标准中<br> 约600个缺陷的修正</span></strong>，这使得C++11更像是从C++98/03中孕育出的一种新语言。相比较而言，<br> C++11能更好地用于系统开发和库开发、语法更加泛华和简单化、更加稳定和安全，不仅功能更<br> 强大，而且能提升程序员的开发效率，公司实际项目开发中也用得比较多，所以我们要作为一个<br> 重点去学习。C++11增加的语法特性非常篇幅非常多，我们这里没办法一 一讲解，所以本节课程<br> 主要讲解实际中比较实用的语法。</p> 
<p></p> 
<p><a class="link-info has-card" href="https://en.cppreference.com/w/cpp/11" rel="nofollow" title="C++11官网"><span class="link-card-box"><span class="link-title">C++11官网</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/54/89/N4AaUpFc_o.png" alt="icon-default.png?t=N7T8">https://en.cppreference.com/w/cpp/11</span></span></a>小故事：</p> 
<blockquote> 
 <p>1998年是C++标准委员会成立的第一年，本来计划以后每5年视实际需要更新一次标准，C++国际标准委员会在研究C++ 03的下一个版本的时候，一开始计划是2007年发布，所以最初这个标准叫C++ 07。但是到06年的时候，官方觉得2007年肯定完不成C++ 07，而且官方觉得2008年可能也完不成。最后干脆叫C++ 0x。x的意思是不知道到底能在07还是08还是09年完成。结果2010年的时候也没完成，最后在2011年终于完成了C++标准。所以最终定名为C++11。</p> 
</blockquote> 
<p></p> 
<h2 id="2.%20%E7%BB%9F%E4%B8%80%E7%9A%84%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96">2. 统一的列表初始化</h2> 
<h3 id="2.1%20%EF%BD%9B%EF%BD%9D%E5%88%9D%E5%A7%8B%E5%8C%96"><br> 2.1 ｛｝初始化</h3> 
<p>在C++98中，标准允许使用花括号{}对数组或者结构体元素进行统一的列表初始值设定。比如：</p> 
<pre><code>// 1、{}初始化
struct Point
{
	int _x;
	int _y;
};
int main()
{
	// C语言中支持数组使用{}花括号初始化
	int array1[] = { 1,2,3,4,5 };
	int array2[5] = { 0 };
	int array3[5]{ 0 };// 可以不加=

	// C语言中结构体支持使用{}初始化
	Point p = { 1,2 };

	return 0;
}</code></pre> 
<p><span style="background-color:#f9eda6;">测试结果 </span></p> 
<p><img alt="" height="333" src="https://images2.imgbox.com/37/3d/rJgTXkrI_o.png" width="1200"></p> 
<p>C++11扩大了用大括号括起的列表(初始化列表)的使用范围，使其可用于<span style="background-color:#e6b223;">所有的内置类型和用户自</span><br><span style="background-color:#e6b223;">定义的类型</span>，<span style="color:#0d0016;"><strong>使用初始化列表时，可添加等号(=)，也可不添加。</strong></span></p> 
<p><span style="color:#0d0016;"><span style="background-color:#f9eda6;">代码演示</span></span></p> 
<pre><code>struct Point
{
	int _x;
	int _y;
};
int main()
{
	int x1 = 1;
	int x2{ 2 };
	int array1[]{ 1, 2, 3, 4, 5 };
	int array2[5]{ 0 };
	Point p{ 1, 2 };
	// C++11中列表初始化也可以适用于new表达式中
	int* pa = new int[4] { 0 };
	return 0;
}</code></pre> 
<p><span style="background-color:#f9eda6;">测试结果 </span></p> 
<p><img alt="" height="317" src="https://images2.imgbox.com/ef/f1/ZQGB0lkJ_o.png" width="1118"></p> 
<p>创建对象时也可以使用列表初始化方式调用构造函数初始化。</p> 
<p><span style="background-color:#f9eda6;">代码演示</span></p> 
<pre><code>class Date
{
public:
	Date(int year, int month, int day)
		:_year(year)
		, _month(month)
		, _day(day)
	{
		cout &lt;&lt; "Date(int year, int month, int day)" &lt;&lt; endl;
	}
private:
	int _year;
	int _month;
	int _day;
};
int main()
{
	Date d1(2022, 1, 1); // C++11之前，旧的方式
	// C++11支持的列表初始化，这里会调用构造函数初始化
	Date d2{ 2022, 1, 2 };
	Date d3 = { 2022, 1, 3 };
	return 0;
}</code></pre> 
<p><span style="background-color:#f9eda6;">测试结果 </span></p> 
<p><img alt="" height="246" src="https://images2.imgbox.com/9b/3c/pjLetTK7_o.png" width="1090"></p> 
<h3 id="2.2%20std%3A%3Ainitializer_list">2.2 std::initializer_list</h3> 
<p><br> std::initializer_list的介绍文档：</p> 
<p><a class="link-info has-card" href="https://cplusplus.com/reference/initializer_list/initializer_list/" rel="nofollow" title="initializer_list文档"><span class="link-card-box"><span class="link-title">initializer_list文档</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/45/59/Z1OLzjfi_o.png" alt="icon-default.png?t=N7T8">https://cplusplus.com/reference/initializer_list/initializer_list/</span></span></a></p> 
<p>std::initializer_list是什么类型：</p> 
<p><span style="background-color:#f9eda6;">代码演示</span></p> 
<pre><code>int main()
{
    auto il = { 1,2,3 };
    initializer_list&lt;int&gt; il2 = { 4,5,6 };
    cout &lt;&lt; typeid(il).name() &lt;&lt; endl;
    return 0;
}</code></pre> 
<p><span style="background-color:#f9eda6;">测试结果 </span></p> 
<p><img alt="" height="280" src="https://images2.imgbox.com/2a/31/NHYbMpoR_o.png" width="856"></p> 
<p>std::initializer_list使用场景：<br> std::initializer_list一般是作为<span style="color:#ed7976;"><span style="background-color:#fbd4d0;">构造函数</span></span>的参数，C++11对STL中的不少容器就增加std::initializer_list作为参数的构造函数，这样初始化容器对象就更方便了。也可以作为<span style="color:#ed7976;"><span style="background-color:#fbd4d0;">operator=</span></span>的参数，这样就可以用大括号赋值。</p> 
<p><span style="background-color:#f9eda6;">代码演示</span></p> 
<pre><code>int main()
{
	vector&lt;int&gt; v1(10,1);
	// 构造
	vector&lt;int&gt; v2({ 1,2,3,4,5 });
	// initializer_list
	vector&lt;int&gt; v3 = { 1,3,5,7,9 };
	vector&lt;int&gt; v4{ 2,4,6,8,10 };

	pair&lt;string, string&gt; kv1("insert","插入");
	pair&lt;string, string&gt; kv2("left", "左边");

	map&lt;string, string&gt; dict1 = { kv1,kv2 };

	// 1、pair多参数隐式类型转换
	// 2、initializer_list构造
	map&lt;string, string&gt; dict = { {"right","右边"},{"string","字符串"} };
	return 0;
}</code></pre> 
<p><span style="background-color:#f9eda6;">测试结果 </span></p> 
<p><img alt="" height="693" src="https://images2.imgbox.com/6e/d8/Mb6jjCYb_o.png" width="1200"></p> 
<h2 id="3.%20%E5%A3%B0%E6%98%8E">3. 声明</h2> 
<p><br> c++11提供了多种简化声明的方式，尤其是在使用模板时。</p> 
<h3 id="3.1%20auto">3.1 auto</h3> 
<p><br> 在<strong><span style="color:#0d0016;">C++98</span></strong>中<strong><span style="color:#0d0016;">auto是一个存储类型的说明符</span></strong>，<strong><span style="color:#0d0016;">表明变量是局部自动存储类型</span></strong>，但是局部域中定义局部的变量默认就是自动存储类型，所以auto就没什么价值了。<strong><span style="color:#956fe7;">C++11</span></strong>中废弃auto原来的用法，将其<strong><span style="color:#956fe7;">用于实现自动类型推断</span></strong>。这样要求必须进行显示初始化，让编译器将定义对象的类型设置为初始化值的类型。</p> 
<p><span style="background-color:#f9eda6;">代码演示</span></p> 
<pre><code>int main()
{
	int i = 10;
	auto p = &amp;i;
	// 函数指针，将函数地址传给pf
	auto pf = strcpy;
	cout &lt;&lt; typeid(p).name() &lt;&lt; endl;
	cout &lt;&lt; typeid(pf).name() &lt;&lt; endl;
	map&lt;string, string&gt; dict = { {"sort", "排序"}, {"insert", "插入"} };
	// map&lt;string, string&gt;::iterator it = dict.begin();
	// 原本类型如上，很长，使用auto可以自动推导类型，且很短
	auto it = dict.begin();
	return 0;
}</code></pre> 
<p><span style="background-color:#f9eda6;">测试结果 </span></p> 
<p><img alt="" height="529" src="https://images2.imgbox.com/89/fa/K9vE3Imr_o.png" width="1200"><span style="color:#fe2c24;">注意：auto有一个缺陷，当使用auto为函数的返回类型时，代码可读性不强，因为函数内部可能嵌套了很多函数。</span></p> 
<pre><code>auto func1()
{
	list&lt;int&gt; lt;
	auto ret = lt.begin();
	// ret为链表迭代器的第一个位置，不能够快速确定返回类型是什么
	return ret;
}</code></pre> 
<blockquote> 
 <p> 如上代码，只使用了一个函数就很难确定func1函数的返回类型是什么。</p> 
</blockquote> 
<h3 id="3.2%20decltype">3.2 decltype</h3> 
<p><br> 关键字<strong><span style="color:#fe2c24;">decltype</span><span style="color:#0d0016;">将变量的类型声明为表达式指定的类型</span></strong>。</p> 
<p><span style="background-color:#f9eda6;">代码演示</span></p> 
<pre><code>template&lt;class T&gt;
class B
{
public:
	T* New(int n)
	{
		return new T[n];
	}
};
auto func1()
{
	list&lt;int&gt; lt;
	auto ret = lt.begin();
	// ret为链表迭代器的第一个位置，不能够快速确定返回类型是什么
	return ret;
}
int main()
{
	list&lt;int&gt;::iterator it;
	// typeid推出是一个单纯的字符串
	cout &lt;&lt; typeid(it).name() &lt;&lt; endl;
	 不能用来定义对象
	//typeid(it).name() it1;
	// 可以用来定义对象
	decltype(it) it2;
	cout &lt;&lt; typeid(it2).name() &lt;&lt; endl;
	auto it3 = it2;
	cout &lt;&lt; typeid(it3).name() &lt;&lt; endl;
    // 不知道func1函数返回什么类型，但是可以通过返回的类型实例化对象
	auto ret = func1();
	B&lt;decltype(ret)&gt; bb1;
	map&lt;string, string&gt; dict = { {"string","字符串"},{"left","左边"} };
	auto it4 = dict.begin();
	B&lt;decltype(it4)&gt; bb2;
	// 与上面代码实例化类型一样，但是长度更长
	B&lt;std::map&lt;std::string, std::string&gt;::iterator&gt; bb3;
	return 0;
}</code></pre> 
<p><span style="background-color:#f9eda6;">测试结果 </span></p> 
<p><img alt="" height="681" src="https://images2.imgbox.com/4c/c4/Jbm0gzg4_o.png" width="1200"></p> 
<h3 id="3.3%20nullptr">3.3 nullptr</h3> 
<p><br> 由于C++中<strong><span style="color:#0d0016;">NULL被定义成字面量0</span></strong>，这样就可能回带来一些问题，因为0既能指针常量，又能表示<br> 整形常量。所以出于清晰和安全的角度考虑，<strong><span style="color:#956fe7;">C++11</span></strong>中新增了<strong><span style="color:#956fe7;">nullptr</span></strong>，用于<strong><span style="color:#956fe7;">表示空指针</span></strong>。</p> 
<pre><code>#ifndef NULL
    #ifdef __cplusplus
        #define NULL 0
    #else
        #define NULL ((void *)0)
    #endif
#endif</code></pre> 
<h3 id="3.4%20STL%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%8F%98%E5%8C%96">3.4 STL中一些变化</h3> 
<p><br><strong><span style="color:#0d0016;">新容器</span></strong></p> 
<p><br> 用橘色圈起来是C++11中的一些几个新容器，但是实际最有用的是unordered_map和<br> unordered_set。这两个我们前面已经进行了非常详细的讲解，其他的uu了解一下即可。</p> 
<p><img alt="" height="624" src="https://images2.imgbox.com/d2/8a/5y7dnzHu_o.png" width="873"></p> 
<p><strong><span style="color:#0d0016;">容器中的一些新方法</span></strong></p> 
<p><br> 如果我们再细细去看会发现基本每个容器中都增加了一些C++11的方法，但是其实很多都是用得<br> 比较少的。<br> 比如<strong><span style="color:#0d0016;">提供了cbegin和cend方法返回const迭代器</span></strong>等等，但是实际意义不大，因为begin和end也是<br> 可以返回const迭代器的，这些都是属于锦上添花的操作。<br> 实际上C++11更新后，容器中增加的新方法最后用的<strong><span style="color:#0d0016;">插入接口函数的右值引用版本</span></strong>：</p> 
<p><span style="color:#fe2c24;">但是这些接口到底意义在哪？网上都说他们能提高效率，他们是如何提高效率的？</span><br> 请看下面的右值引用和移动语义章节的讲解。另外emplace还涉及模板的可变参数，也需要再继<br> 续深入学习后面章节的知识。 </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c1ff959ac9e301e529b7b3f8e0e3e324/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">一个php快速项目搭建框架源码，带一键CURD等功能</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/020cea5c4138af4681f0366ba35d8504/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">《机器学习》 决策树 ID3算法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>