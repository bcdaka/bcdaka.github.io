<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】初识数据结构 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/28980d8b318f7ba54dd70c96063a5694/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】初识数据结构">
  <meta property="og:description" content="目录
1.前言
2.时间和空间复杂度
2.1算法效率
2.2时间复杂度
2.2.1概念
2.2.2大O渐进表示法
2.2.3推导大O阶方法
2.2.4常见时间复杂度计算举例
2.3空间复杂度
2.3.1概念
2.3.2常见空间复杂度计算举例
3.包装类
3.1基本数据类型和对应的包装类
3.2装箱和拆箱
4.泛型
4.1概念
4.2引出泛型
4.3语法
5.泛型类的使用
5.1语法
5.2类型推导
6.泛型的上界
6.1概念
6.2语法
7.泛型方法
8.总结
1.前言 本篇将主要介绍数据结构的基本知识：时间和空间复杂度、算法效率、大O渐进表示法、包装类、泛型相关知识。
2.时间和空间复杂度 2.1算法效率 算法效率分析分为两种：第一种是 时间效率 ，第二种是 空间效率 。 时间效率被称为时间复杂度。 空间效率被称作空间复杂度。 时间复杂度主要衡量的是一个算法的运行速度，而空间复杂度主要衡量一个算法所需要的额外空间。 2.2时间复杂度 2.2.1概念 一个算法所花费的时间与其中语句的执行次数成正比例，算法中的基本操作的执行次数，为算法的时间复杂度。 2.2.2大O渐进表示法 举个例子：请计算一下func1基本操作执行了多少次？
void func1(int N) { int count = 0; for (int i = 0; i &lt; N; i&#43;&#43;) { for (int j = 0; j &lt; N; j&#43;&#43;) { count&#43;&#43;; } } for (int k = 0; k &lt; 2 * N; k&#43;&#43;) { count&#43;&#43;; } int M = 10; while ((M--) &gt; 0) { count&#43;&#43;; } System.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-19T16:03:43+08:00">
    <meta property="article:modified_time" content="2024-07-19T16:03:43+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】初识数据结构</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="1.%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#1.%E5%89%8D%E8%A8%80" rel="nofollow">1.前言</a></p> 
<p id="2.%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc" style="margin-left:0px;"><a href="#2.%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" rel="nofollow">2.时间和空间复杂度</a></p> 
<p id="2.1%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87-toc" style="margin-left:40px;"><a href="#2.1%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87" rel="nofollow">2.1算法效率</a></p> 
<p id="2.2%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc" style="margin-left:40px;"><a href="#2.2%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" rel="nofollow">2.2时间复杂度</a></p> 
<p id="2.2.1%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#2.2.1%E6%A6%82%E5%BF%B5" rel="nofollow">2.2.1概念</a></p> 
<p id="2.2.2%E5%A4%A7O%E6%B8%90%E8%BF%9B%E8%A1%A8%E7%A4%BA%E6%B3%95-toc" style="margin-left:80px;"><a href="#2.2.2%E5%A4%A7O%E6%B8%90%E8%BF%9B%E8%A1%A8%E7%A4%BA%E6%B3%95" rel="nofollow">2.2.2大O渐进表示法</a></p> 
<p id="2.2.3%E6%8E%A8%E5%AF%BC%E5%A4%A7O%E9%98%B6%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#2.2.3%E6%8E%A8%E5%AF%BC%E5%A4%A7O%E9%98%B6%E6%96%B9%E6%B3%95" rel="nofollow">2.2.3推导大O阶方法</a></p> 
<p id="2.2.4%E5%B8%B8%E8%A7%81%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97%E4%B8%BE%E4%BE%8B-toc" style="margin-left:80px;"><a href="#2.2.4%E5%B8%B8%E8%A7%81%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97%E4%B8%BE%E4%BE%8B" rel="nofollow">2.2.4常见时间复杂度计算举例</a></p> 
<p id="%C2%A02.3%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc" style="margin-left:40px;"><a href="#%C2%A02.3%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" rel="nofollow"> 2.3空间复杂度</a></p> 
<p id="2.3.1%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#2.3.1%E6%A6%82%E5%BF%B5" rel="nofollow">2.3.1概念</a></p> 
<p id="2.3.2%E5%B8%B8%E8%A7%81%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97%E4%B8%BE%E4%BE%8B-toc" style="margin-left:80px;"><a href="#2.3.2%E5%B8%B8%E8%A7%81%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97%E4%B8%BE%E4%BE%8B" rel="nofollow">2.3.2常见空间复杂度计算举例</a></p> 
<p id="3.%E5%8C%85%E8%A3%85%E7%B1%BB-toc" style="margin-left:0px;"><a href="#3.%E5%8C%85%E8%A3%85%E7%B1%BB" rel="nofollow">3.包装类</a></p> 
<p id="3.1%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB-toc" style="margin-left:40px;"><a href="#3.1%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB" rel="nofollow">3.1基本数据类型和对应的包装类</a></p> 
<p id="3.2%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1-toc" style="margin-left:40px;"><a href="#3.2%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1" rel="nofollow">3.2装箱和拆箱</a></p> 
<p id="4.%E6%B3%9B%E5%9E%8B-toc" style="margin-left:0px;"><a href="#4.%E6%B3%9B%E5%9E%8B" rel="nofollow">4.泛型</a></p> 
<p id="4.1%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#4.1%E6%A6%82%E5%BF%B5" rel="nofollow">4.1概念</a></p> 
<p id="4.2%E5%BC%95%E5%87%BA%E6%B3%9B%E5%9E%8B-toc" style="margin-left:40px;"><a href="#4.2%E5%BC%95%E5%87%BA%E6%B3%9B%E5%9E%8B" rel="nofollow">4.2引出泛型</a></p> 
<p id="4.3%E8%AF%AD%E6%B3%95-toc" style="margin-left:40px;"><a href="#4.3%E8%AF%AD%E6%B3%95" rel="nofollow">4.3语法</a></p> 
<p id="5.%E6%B3%9B%E5%9E%8B%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:0px;"><a href="#5.%E6%B3%9B%E5%9E%8B%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">5.泛型类的使用</a></p> 
<p id="5.1%E8%AF%AD%E6%B3%95-toc" style="margin-left:40px;"><a href="#5.1%E8%AF%AD%E6%B3%95" rel="nofollow">5.1语法</a></p> 
<p id="5.2%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC-toc" style="margin-left:40px;"><a href="#5.2%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC" rel="nofollow">5.2类型推导</a></p> 
<p id="%C2%A06.%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%B8%8A%E7%95%8C-toc" style="margin-left:0px;"><a href="#%C2%A06.%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%B8%8A%E7%95%8C" rel="nofollow"> 6.泛型的上界</a></p> 
<p id="6.1%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#6.1%E6%A6%82%E5%BF%B5" rel="nofollow">6.1概念</a></p> 
<p id="6.2%E8%AF%AD%E6%B3%95-toc" style="margin-left:40px;"><a href="#6.2%E8%AF%AD%E6%B3%95" rel="nofollow">6.2语法</a></p> 
<p id="7.%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95-toc" style="margin-left:0px;"><a href="#7.%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95" rel="nofollow">7.泛型方法</a></p> 
<p id="8.%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#8.%E6%80%BB%E7%BB%93" rel="nofollow">8.总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1.%E5%89%8D%E8%A8%80">1.前言</h2> 
<p>本篇将主要介绍数据结构的基本知识：时间和空间复杂度、算法效率、大O渐进表示法、包装类、泛型相关知识。</p> 
<h2 id="2.%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">2.时间和空间复杂度</h2> 
<h3 id="2.1%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87">2.1算法效率</h3> 
<blockquote> 
 <div> 
  <span style="color:#333333;">算法效率分析分为两种：第一种是</span> 
  <span style="color:#fe2c24;"><strong>时间效率</strong></span> 
  <span style="color:#333333;">，第二种是</span> 
  <span style="color:#fe2c24;"><strong>空间效率</strong></span> 
  <span style="color:#333333;">。</span> 
 </div> 
 <div> 
  <strong><span style="color:#fe2c24;">时间效率被称为时间复杂度。</span></strong> 
 </div> 
 <div> 
  <strong><span style="color:#fe2c24;">空间效率被称作空间复杂度。</span></strong> 
  <span style="color:#333333;"> </span> 
 </div> 
 <div> 
  <span style="color:#333333;">时间复杂度主要衡量的是一个算法的运行速度，而空间复杂度主要衡量一个算法所需要的额外空间。</span> 
 </div> 
</blockquote> 
<h3 id="2.2%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">2.2时间复杂度</h3> 
<h4 id="2.2.1%E6%A6%82%E5%BF%B5" style="background-color:transparent;">2.2.1概念</h4> 
<blockquote> 
 <div> 
  <span style="color:#333333;">一个算法所花费的时间与其中语句的执行次数成正比例，<strong>算法中的基本操作的执行次数，为算法的时间复杂度。</strong></span> 
 </div> 
</blockquote> 
<h4 id="2.2.2%E5%A4%A7O%E6%B8%90%E8%BF%9B%E8%A1%A8%E7%A4%BA%E6%B3%95">2.2.2大O渐进表示法</h4> 
<p>举个例子：<span style="color:#fe2c24;"><strong>请计算一下func1基本操作执行了多少次？</strong></span></p> 
<pre><code class="language-java">void func1(int N) {
        int count = 0;
        for (int i = 0; i &lt; N; i++) {
            for (int j = 0; j &lt; N; j++) {
                count++;
            }
        }
        for (int k = 0; k &lt; 2 * N; k++) {
            count++;
        }
        int M = 10;
        while ((M--) &gt; 0) {
            count++;
        }
        System.out.println(count);
    }</code></pre> 
<p><span style="color:#333333;">Func1 </span><span style="color:#333333;">执行的基本操作次数 ： </span></p> 
<p class="img-center"><img alt="" height="87" src="https://images2.imgbox.com/33/e1/yBMO4xdt_o.png" width="433"></p> 
<ul><li>N = 10 F(N) = 130</li><li>N = 100 F(N) = 10210</li><li>N = 1000 F(N) = 1002010</li></ul> 
<div> 
 <span style="color:#333333;">实际中我们计算时间复杂度时，我们其实并不一定要计算精确的执行次数，而只需要</span> 
 <span style="color:#333333;"><strong>大概执行次数，那么这里我们</strong></span> 
 <span style="color:#333333;"><strong>使用大</strong></span> 
 <span style="color:#333333;"><strong>O</strong></span> 
 <span style="color:#333333;"><strong>的渐进表示法</strong>（大O</span> 
 <span style="color:#333333;">符号（</span> 
 <span style="color:#333333;">Big O notation)</span> 
 <span style="color:#333333;">：是用于描述函数渐进行为的数学符号）</span> 
</div> 
<h4 id="2.2.3%E6%8E%A8%E5%AF%BC%E5%A4%A7O%E9%98%B6%E6%96%B9%E6%B3%95"><span style="color:#333333;">2.2.3<strong>推导大</strong></span><span style="color:#333333;"><strong>O</strong></span><span style="color:#333333;"><strong>阶方法</strong></span></h4> 
<div> 
 <span style="color:#333333;">1</span> 
 <span style="color:#333333;">、用常数</span> 
 <span style="color:#333333;">1</span> 
 <span style="color:#333333;">取代运行时间中的所有加法常数。 </span> 
</div> 
<div> 
 <span style="color:#333333;">2</span> 
 <span style="color:#333333;">、在修改后的运行次数函数中，只保留最高阶项。 </span> 
</div> 
<div> 
 <span style="color:#333333;">3</span> 
 <span style="color:#333333;">、如果最高阶项存在且不是</span> 
 <span style="color:#333333;">1</span> 
 <span style="color:#333333;">，则去除与这个项目相乘的常数。得到的结果就是大</span> 
 <span style="color:#333333;">O</span> 
 <span style="color:#333333;">阶。</span> 
</div> 
<p> <span style="color:#333333;">使用大</span><span style="color:#333333;">O</span><span style="color:#333333;">的渐进表示法以后，</span><span style="color:#333333;">Func1</span><span style="color:#333333;">的时间复杂度为：</span></p> 
<p class="img-center"><img alt="" height="66" src="https://images2.imgbox.com/ed/dd/2DEtfqXh_o.png" width="200"></p> 
<p>N = 10 F(N) = 100<br> N = 100 F(N) = 10000<br> N = 1000 F(N) = 1000000<br> 通过上面我们会发现大O阶的渐进表示法去掉了那些对结果影响不大的项，简洁明了的表示出了执行的次数。</p> 
<p>另外，有些算法的时间复杂度存在最好、平均和最坏情况：</p> 
<p>最坏情况：任意输入规模的最大运行次数(上界)<br> 平均情况：任意输入规模的期望运行次数<br> 最好情况：任意输入规模的最小运行次数(下界)</p> 
<div> 
 <span style="color:#fe2c24;"><strong>例如：在一个长度为N数组中搜索一个数据x </strong></span> 
</div> 
<div> 
 <span style="color:#333333;">最好情况：</span> 
 <span style="color:#333333;">1</span> 
 <span style="color:#333333;">次找到 </span> 
</div> 
<div> 
 <span style="color:#333333;">最坏情况：</span> 
 <span style="color:#333333;">N</span> 
 <span style="color:#333333;">次找到 </span> 
</div> 
<div> 
 <span style="color:#333333;">平均情况：</span> 
 <span style="color:#333333;">N/2</span> 
 <span style="color:#333333;">次找到 </span> 
</div> 
<div> 
 <span style="color:#333333;"><strong>在实际中一般情况关注的是算法的最坏运行情况，所以数组中搜索数据时间复杂度为</strong></span> 
 <span style="color:#333333;"><strong>O(N).</strong></span> 
</div> 
<h4 id="2.2.4%E5%B8%B8%E8%A7%81%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97%E4%B8%BE%E4%BE%8B">2.2.4<span style="color:#333333;"><strong>常见时间复杂度计算举例</strong></span></h4> 
<p><strong><span style="color:#0d0016;">例1：计算func2的时间复杂度？</span></strong></p> 
<pre><code class="language-java">    void func2(int N) {
        int count = 0;
        for (int k = 0; k &lt; 2 * N; k++) {
            count++;
        }
        int M = 10;
        while ((M--) &gt; 0) {
            count++;
        }
        System.out.println(count);
    }</code></pre> 
<p><span style="color:#333333;">例</span><span style="color:#333333;">1</span><span style="color:#333333;">基本操作执行了</span><span style="color:#333333;">2N+10</span><span style="color:#333333;">次，通过推导大</span><span style="color:#333333;">O</span><span style="color:#333333;">阶方法知道，它的</span>时间复杂度为 <strong>O(N)。</strong></p> 
<p><strong>例2：计算func3的时间复杂度？ </strong></p> 
<pre><code class="language-java">    void func3(int N, int M) {
        int count = 0;
        for (int k = 0; k &lt; M; k++) {
            count++;
        }
        for (int k = 0; k &lt; N; k++) {
            count++;
        }
        System.out.println(count);
    }</code></pre> 
<div> 
 <span style="color:#333333;">例</span> 
 <span style="color:#333333;">2</span> 
 <span style="color:#333333;">基本操作执行了</span> 
 <span style="color:#333333;">M+N</span> 
 <span style="color:#333333;">次，有两个未知数</span> 
 <span style="color:#333333;">M</span> 
 <span style="color:#333333;">和</span> 
 <span style="color:#333333;">N</span> 
 <span style="color:#333333;">，时间复杂度为</span> 
 <span style="color:#333333;"> <strong>O(N+M)</strong>。</span> 
</div> 
<div></div> 
<div> 
 <strong><span style="color:#333333;">例3：</span><span style="color:#0d0016;">计算func4的时间复杂度？ </span></strong> 
</div> 
<div> 
 <pre><code class="language-java">void func4(int N) {
        int count = 0;
        for (int k = 0; k &lt; 100; k++) {
            count++;
        }
        System.out.println(count);
    }</code></pre> 
 <div> 
  <span style="color:#333333;">例</span> 
  <span style="color:#333333;">3</span> 
  <span style="color:#333333;">基本操作执行了</span> 
  <span style="color:#333333;">100</span> 
  <span style="color:#333333;">次，通过推导大</span> 
  <span style="color:#333333;">O</span> 
  <span style="color:#333333;">阶方法，时间复杂度为</span> 
  <span style="color:#333333;"> <strong>O(1)。</strong></span> 
 </div> 
 <div></div> 
</div> 
<div> 
 <strong><span style="color:#333333;">例4：</span><span style="color:#0d0016;">计算bubbleSort的时间复杂度？</span></strong> 
 <span style="color:#aa5500;"> </span> 
</div> 
<div> 
 <pre><code class="language-java">void bubbleSort(int[] array) {
        for (int end = array.length; end &gt; 0; end--) {
            boolean sorted = true;
            for (int i = 1; i &lt; end; i++) {
                if (array[i - 1] &gt; array[i]) {
                    Swap(array, i - 1, i);
                    sorted = false;
                }
            }
            if (sorted == true) {
                break;
            }
        }
    }</code></pre> 
 <div> 
  <span style="color:#333333;">例</span> 
  <span style="color:#333333;">4</span> 
  <span style="color:#333333;">基本操作执行最好</span> 
  <span style="color:#333333;">N</span> 
  <span style="color:#333333;">次，最坏执行了</span> 
  <span style="color:#333333;">(N*(N-1))/2</span> 
  <span style="color:#333333;">次，通过推导大</span> 
  <span style="color:#333333;">O</span> 
  <span style="color:#333333;">阶方法</span> 
  <span style="color:#333333;">+</span> 
  <span style="color:#333333;">时间复杂度一般看最坏，时间复杂度为 <strong>O(N^2)。</strong></span> 
 </div> 
 <div></div> 
</div> 
<div> 
 <strong><span style="color:#333333;">例5：</span><span style="color:#0d0016;">计算binarySearch的时间复杂度?</span></strong> 
</div> 
<div> 
 <pre><code class="language-java">int binarySearch(int[] array, int value) {
        int begin = 0;
        int end = array.length - 1;
        while (begin &lt;= end) {
            int mid = begin + ((end - begin) / 2);
            if (array[mid] &lt; value)
                begin = mid + 1;
            else if (array[mid] &gt; value)
                end = mid - 1;
            else
                return mid;
        }
        return -1;
    }</code></pre> 
 <p>例5基本操作<strong>最好执行1次，最坏log₂N次</strong>，因为二分查找每次都会排除掉一半的不适合值，则每一次值都为上一次的1/2，所以当存在N个数据时，有总个数N/(2^(砍一半的次数)y) = 1(最后剩下的一个数) ==&gt; y = log₂N,则时间复杂度为<strong>O(log₂N)。</strong></p> 
</div> 
<div> 
 <strong>例6：</strong> 
 <span style="color:#0d0016;">计算阶乘递归factorial的时间复杂度？</span> 
</div> 
<div> 
 <pre><code class="language-java">long factorial(int N) {
        return N &lt; 2 ? N : factorial(N-1) * N;
    }</code></pre> 
 <p>例6通过计算分析发现基本操作递归了N次，且递归的时间复杂度=递归次数*每次递归后的执行次数，则时间复杂度为<strong>O(N)</strong>。</p> 
</div> 
<div> 
 <strong>例7：</strong> 
 <span style="color:#0d0016;">计算斐波那契递归fibonacci的时间复杂度？</span> 
 <pre><code class="language-java">int fibonacci(int N) {
        return N &lt; 2 ? N : fibonacci(N-1)+fibonacci(N-2);
    }</code></pre> 
</div> 
<div> 
 <span style="color:#333333;">例</span> 
 <span style="color:#333333;">7</span> 
 <span style="color:#333333;">通过计算分析发现基本操作递归了2^n次，时间复杂度为<strong>O( 2^N)</strong>。</span> 
</div> 
<h3 id="%C2%A02.3%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"> 2.3空间复杂度</h3> 
<h4 id="2.3.1%E6%A6%82%E5%BF%B5" style="background-color:transparent;">2.3.1概念</h4> 
<blockquote> 
 <div> 
  <span style="color:#333333;">空间复杂度是对一个算法在运行过程中</span> 
  <span style="color:#333333;"><strong>临时占用存储空间大小的量度</strong>。</span> 
  <div> 
   <span style="color:#333333;">空间复杂度算的是变量的个数。空间复杂度计算规则基本跟时间复杂度类似，也使用<strong>大</strong></span> 
   <span style="color:#333333;"><strong>O</strong></span> 
   <span style="color:#333333;"><strong>渐进表示法</strong></span> 
   <span style="color:#333333;">。</span> 
  </div> 
 </div> 
</blockquote> 
<h4 id="2.3.2%E5%B8%B8%E8%A7%81%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97%E4%B8%BE%E4%BE%8B">2.3.2常见空间复杂度计算举例</h4> 
<p><span style="color:#0d0016;"><strong>例1：计算bubbleSort的空间复杂度？</strong></span></p> 
<pre><code class="language-java">void bubbleSort(int[] array) {
        for (int end = array.length; end &gt; 0; end--) {
            boolean sorted = true;
            for (int i = 1; i &lt; end; i++) {
                if (array[i - 1] &gt; array[i]) {
                    Swap(array, i - 1, i);
                    sorted = false;
                }
            }
            if (sorted == true) {
                break;
            }
        }
    }</code></pre> 
<p><span style="color:#333333;">例</span><span style="color:#333333;">1</span><span style="color:#333333;">使用了常数个额外空间，所以空间复杂度为</span><strong>O(1)</strong>。</p> 
<p><span style="color:#0d0016;"><strong>例2：计算fibonacci的空间复杂度？</strong></span></p> 
<pre><code class="language-java">int[] fibonacci(int n) {
        long[] fibArray = new long[n + 1];
        fibArray[0] = 0;
        fibArray[1] = 1;
        for (int i = 2; i &lt;= n; i++) {
            fibArray[i] = fibArray[i - 1] + fibArray[i - 2];
        }
        return fibArray;
    }</code></pre> 
<div> 
 <span style="color:#333333;">例</span> 
 <span style="color:#333333;">2</span> 
 <span style="color:#333333;">动态开辟了</span> 
 <span style="color:#333333;">N</span> 
 <span style="color:#333333;">个空间，空间复杂度为<strong>O(N)</strong>。</span> 
</div> 
<div> 
 <span style="color:#0d0016;"><strong>例3：计算阶乘递归Factorial的空间复杂度？</strong></span> 
 <pre><code class="language-java">long factorial(int N) {
        return N &lt; 2 ? N : factorial(N - 1) * N;
    }</code></pre> 
 <div> 
  <span style="color:#333333;">例</span> 
  <span style="color:#333333;">3</span> 
  <span style="color:#333333;">递归调用了</span> 
  <span style="color:#333333;">N</span> 
  <span style="color:#333333;">次，开辟了</span> 
  <span style="color:#333333;">N</span> 
  <span style="color:#333333;">个栈帧，每个栈帧使用了常数个空间。空间复杂度为</span> 
  <span style="color:#333333;"><strong>O(N)</strong>。</span> 
 </div> 
 <h2 id="3.%E5%8C%85%E8%A3%85%E7%B1%BB" style="background-color:transparent;">3.包装类</h2> 
 <div> 
  <span style="color:#333333;">在</span> 
  <span style="color:#333333;">Java</span> 
  <span style="color:#333333;">中，由于基本类型不是继承自</span> 
  <span style="color:#333333;">Object</span> 
  <span style="color:#333333;">，为了在泛型代码中可以支持基本类型，</span> 
  <span style="color:#fe2c24;"><strong>Java给每个基本类型都对应了一个包装类型。 </strong></span> 
 </div> 
 <h3 id="3.1%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB"><span style="color:#0d0016;">3.1基本数据类型和对应的包装类</span></h3> 
 <p><img alt="" height="431" src="https://images2.imgbox.com/0d/bd/73Kvj5Vt_o.png" width="1194"></p> 
 <div> 
  <strong><span style="color:#fe2c24;">注：</span><span style="color:#333333;"><span style="background-color:#38d8f0;">除了 Integer </span></span><span style="color:#333333;"><span style="background-color:#38d8f0;">和</span></span><span style="color:#333333;"><span style="background-color:#38d8f0;"> Character</span></span><span style="color:#333333;"><span style="background-color:#38d8f0;">， 其余基本类型的包装类都是首字母大写。 </span></span></strong> 
 </div> 
 <h3 id="3.2%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1" style="background-color:transparent;">3.2<span style="color:#333333;"><strong>装箱和拆箱</strong></span></h3> 
 <pre><code class="language-java">    int i = 10;
    // 装箱操作，新建一个 Integer 类型对象，将 i 的值放入对象的某个属性中
    Integer ii = Integer.valueOf(i);
    Integer ij = new Integer(i);
    // 拆箱操作，将 Integer 对象中的值取出，放到一个基本数据类型中
    int j = ii.intValue();</code></pre> 
 <h2 id="4.%E6%B3%9B%E5%9E%8B">4.泛型</h2> 
 <h3 id="4.1%E6%A6%82%E5%BF%B5">4.1概念</h3> 
 <blockquote> 
  <div> 
   <span style="color:#333333;">泛型是</span> 
   <span style="color:#333333;"><strong>适用于许多许多类型</strong></span> 
   <span style="color:#333333;">。从代码上讲，就是对类型实现了参数化。</span> 
  </div> 
 </blockquote> 
</div> 
<h3 id="4.2%E5%BC%95%E5%87%BA%E6%B3%9B%E5%9E%8B">4.2引出泛型</h3> 
<div> 
 <span style="color:#333333;">实现一个类，类中包含一个数组成员，使得数组中可以存放任何类型的数据，也可以根据</span> 
 <span style="color:#0d0016;"><strong>成员方法</strong></span> 
 <span style="color:#333333;">返回数组中某个下标的值。</span> 
 <pre><code class="language-java">class MyArray {
    public Object[] array = new Object[10];
    public Object getPos(int pos) {
        return this.array[pos];
    }
    public void setVal(int pos,Object val) {
        this.array[pos] = val;
    }    
 }
 public class TestDemo {
    public static void main(String[] args) {
        MyArray myArray = new MyArray();
        myArray.setVal(0,10);
        myArray.setVal(1,"hello");//字符串也可以存放
        String ret = myArray.getPos(1);//编译报错
        //强行转化
        String ret =(String)myArray.getPos(1);
        System.out.println(ret);
    }
 }
</code></pre> 
 <p>通过运行上面的代码我们可以发现以下的问题：</p> 
 <blockquote> 
  <div> 
   <span style="color:#333333;">1. </span> 
   <span style="color:#333333;">任何类型数据都可以存放。</span> 
  </div> 
  <div> 
   <span style="color:#333333;">2. 1</span> 
   <span style="color:#333333;">号下标本身就是字符串，但是确编译报错。必须进行强制类型转换。</span> 
  </div> 
 </blockquote> 
 <div> 
  <span style="color:#333333;">因此在更多情况下，我们希望它只能够持有一种数据类型。而不是同时持有这么多类型。</span> 
  <strong><span style="color:#fe2c24;">所以泛型的主要目的：就是指定当前的容器，要持有什么类型的对象。让编译</span></strong> 
  <strong><span style="color:#fe2c24;">器去做检查。此时，就需要把类型，作为参数传递。需要什么类型，就传入什么类型。 </span></strong> 
 </div> 
 <h3 id="4.3%E8%AF%AD%E6%B3%95">4.3语法</h3> 
 <pre><code class="language-java">class MyArray&lt;T&gt; {//添加&lt; &gt;表示这个类是泛型
    public T[] array = (T[])new Object[10];//这句代码是错误的，这样写只是为了不让编译器报错
    public T getPos(int pos) {
        return this.array[pos];
    }
    public void setVal(int pos,T val) {
        this.array[pos] = val;
    }
 }
 public class TestDemo {
    public static void main(String[] args) {
        MyArray&lt;Integer&gt; myArray = new MyArray&lt;&gt;();
        //传入&lt;Integer&gt;后，每次存储数据时会检查存入的数据是不是我传入的类型，获取数据的时候也不需要强制转化。
        myArray.setVal(0,10);
        myArray.setVal(1,12);
        int ret = myArray.getPos(1);
        System.out.println(ret);
        myArray.setVal(2,"bit");
    }
 }
</code></pre> 
 <div> 
  <span style="color:#333333;">对上面代码进行解释：</span> 
 </div> 
 <div> 
  <span style="color:#333333;">1. </span> 
  <span style="color:#333333;">类名后的 </span> 
  <span style="color:#333333;">&lt;T&gt; </span> 
  <span style="color:#333333;">代表占位符，表示当前类是一个泛型类。</span> 
 </div> 
 <blockquote> 
  <div> 
   <span style="color:#333333;"><strong>了解： </strong></span> 
   <span style="color:#333333;">【规范】类型形参一般使用一个大写字母表示，常用的名称有： </span> 
  </div> 
  <div> 
   <p></p> 
   <ul><li><span style="color:#777777;">E </span><span style="color:#777777;">表示</span><span style="color:#777777;"> Element </span></li><li><span style="color:#777777;">K </span><span style="color:#777777;">表示</span><span style="color:#777777;"> Key </span></li><li><span style="color:#777777;">V </span><span style="color:#777777;">表示</span><span style="color:#777777;"> Value </span></li><li><span style="color:#777777;">N </span><span style="color:#777777;">表示</span><span style="color:#777777;"> Number </span></li><li><span style="color:#777777;">T </span><span style="color:#777777;">表示</span><span style="color:#777777;"> Type </span></li><li><span style="color:#777777;">S, U, V </span><span style="color:#777777;">等等</span><span style="color:#777777;"> - </span><span style="color:#777777;">第二、第三、第四个类型 </span></li></ul> 
  </div> 
 </blockquote> 
</div> 
<p><span style="color:#333333;">2. </span><span style="color:#333333;">注释</span><span style="color:#333333;">1</span><span style="color:#333333;">处，不能</span><span style="color:#333333;">new</span><span style="color:#333333;">泛型类型的数组</span></p> 
<blockquote> 
 <p><span style="color:#333333;"> 意味着：</span><span style="color:#000000;">T</span><span style="color:#777777;">[] </span><span style="color:#000000;">ts </span><span style="color:#981a1a;">= </span><span style="color:#770088;">new </span><span style="color:#000000;">T</span><span style="color:#777777;">[</span><span style="color:#116644;">5</span><span style="color:#777777;">];</span><span style="color:#fe2c24;">//是不对的</span><span style="color:#0d0016;"> </span></p> 
</blockquote> 
<div> 
 <span style="color:#333333;">3. </span> 
 <span style="color:#333333;">注释</span> 
 <span style="color:#333333;">2</span> 
 <span style="color:#333333;">处，类型后加入 </span> 
 <span style="color:#333333;">&lt;Integer&gt; </span> 
 <span style="color:#333333;">指定当前类型 </span> 
</div> 
<div> 
 <span style="color:#333333;">4. </span> 
 <span style="color:#333333;">注释</span> 
 <span style="color:#333333;">3</span> 
 <span style="color:#333333;">处，不需要进行强制类型转换 </span> 
</div> 
<div> 
 <span style="color:#333333;">5. </span> 
 <span style="color:#333333;">注释</span> 
 <span style="color:#333333;">4</span> 
 <span style="color:#333333;">处，代码编译报错，此时因为在注释</span> 
 <span style="color:#333333;">2</span> 
 <span style="color:#333333;">处指定类当前的类型，此时在注释</span> 
 <span style="color:#333333;">4</span> 
 <span style="color:#333333;">处，编译器会在存放元素的时候帮助我们进行类型检查。 </span> 
</div> 
<h2 id="5.%E6%B3%9B%E5%9E%8B%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span style="color:#333333;">5.泛型类的使用</span></h2> 
<h3 id="5.1%E8%AF%AD%E6%B3%95">5.1语法</h3> 
<blockquote> 
 <div> 
  <p>泛型类&lt;类型实参&gt; 变量名; // 定义一个泛型类引用<br> new 泛型类&lt;类型实参&gt;(构造方法实参); // 实例化一个泛型类对象</p> 
 </div> 
</blockquote> 
<p>举个例子：</p> 
<pre><code class="language-java">MyArray&lt;Integer&gt; list = new MyArray&lt;Integer&gt;();</code></pre> 
<div> 
 <span style="color:#fe2c24;"><strong>注意：泛型只能接受类，所有的基本数据类型必须使用包装类！</strong></span> 
</div> 
<h3 id="5.2%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC">5.2类型推导</h3> 
<div> 
 <span style="color:#333333;">类型推导即当编译器可以根据上下文推导出类型实参时，可以省略类型实参的填写。</span> 
</div> 
<blockquote> 
 <div>
   MyArray&lt;Integer&gt; list = new MyArray&lt;&gt;(); // 可以推导出实例化需要的类型实参为 Integer 
 </div> 
</blockquote> 
<h2 id="%C2%A06.%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%B8%8A%E7%95%8C"> 6.<span style="color:#333333;"><strong>泛型的上界 </strong></span></h2> 
<h3 id="6.1%E6%A6%82%E5%BF%B5">6.1概念</h3> 
<div> 
 <span style="color:#333333;"><strong>泛型的上界：</strong>在定义泛型类时，有时需要对传入的类型变量做一定的约束，可以通过类型边界来约束。 </span> 
</div> 
<h3 id="6.2%E8%AF%AD%E6%B3%95"><span style="color:#333333;">6.2语法</span></h3> 
<blockquote> 
 <div> 
  <div> 
   <p>class 泛型类名称&lt;类型形参 extends 类型边界&gt; {<!-- --><br> ...<br> }</p> 
  </div> 
 </div> 
</blockquote> 
<p>举个例子：</p> 
<pre><code class="language-java">public class MyArray&lt;E extends Number&gt; {
...
}

MyArray&lt;Integer&gt; l1; // 正常，因为 Integer 是 Number 的子类型
MyArray&lt;String&gt; l2; // 编译错误，因为 String 不是 Number 的子类型</code></pre> 
<p><span style="color:#0d0016;"><strong>tips：</strong></span><span style="color:#333333;"><strong> </strong></span><strong><span style="color:#333333;"><span style="background-color:#38d8f0;">没有指定类型边界</span></span><span style="color:#333333;"><span style="background-color:#38d8f0;"> E</span></span><span style="color:#333333;"><span style="background-color:#38d8f0;">，可以视为</span></span><span style="color:#333333;"><span style="background-color:#38d8f0;"> E extends Object</span></span></strong></p> 
<h2 id="7.%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95">7.泛型方法</h2> 
<blockquote> 
 <p>泛型方法定义语法：</p> 
 <p><span style="color:#0d0016;"><strong>方法限定符 &lt;类型形参列表&gt; 返回值类型 方法名称(形参列表) { ... }</strong></span></p> 
</blockquote> 
<p>下面举个例子给大家看看：</p> 
<pre><code class="language-java">public class Util {
    //静态的泛型方法 需要在static后用&lt;&gt;声明泛型类型参数
    public static &lt;E&gt; void swap(E[] array, int i, int j) {
        E t = array[i];
        array[i] = array[j];
        array[j] = t;
    }
}</code></pre> 
<h2 id="8.%E6%80%BB%E7%BB%93">8.总结</h2> 
<p>以上内容让大家能够初步认识数据结构的一些基本知识，后面还将继续与大家分享数据结构中的顺序表、链表、栈、队列、二叉树等内容，小欣建议大家在学数据结构的时候多画图、多动手与思考，才能更好地学习数据结构！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e36a317abd5d975a132569b255b7c730/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">前端出发能走多远——写在前面</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/359e1c71bf63785f44fb165200f8394d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">开放开源开先河（三）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>