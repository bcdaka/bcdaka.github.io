<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2023年第十四届蓝桥杯JavaB组省赛真题及全部解析（上） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/874796bb17deab04c4fe00b5e03c7fc5/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="2023年第十四届蓝桥杯JavaB组省赛真题及全部解析（上）">
  <meta property="og:description" content="目录
前言：
一、试题 A：阶乘求和（填空）
二、试题 B：幸运数字（填空）
三、试题 C：数组分割
四、试题 D：矩阵总面积
五、试题 E：蜗牛
六、试题 F：合并区域
前言： 这一篇是我蓝桥系列的第一篇，当然现在第十五届蓝桥杯已经打完了，作者也有参加，运气比较好，拿了个国二，虽然没有达到自己的预期，但也是完成学校的任务，作者是福建省的（弱省），省一我觉得还是挺简单的，随便 ac 两题，打打暴力就省一了，排名还很靠前。蓝桥杯的含金量肯定是不如 ICPC（ACM）和 CCPC （中国的ACM），这个我是深有体会，因为我有参加 CCPC 福建省邀请赛（福州大学），暴零了（一题都没有做出来），直接去旅游了😭😭😭。只能说那种级别的比赛真不是一般人能打的。接下来我会分享我备赛蓝桥杯过程刷的真题和解析，方便和我一样第一次参加蓝桥杯的小白备赛。由于题目比较多，后面几题的题解比较长，只能分成两篇来发，如果有需要的话可以点开下部分，讲解了第 7 到第 10 题。
题目来自：蓝桥杯官网
一、试题 A：阶乘求和（填空） • 题目分析：
在这里先提醒大家一下，填空题做不出来很正常，我当时填空题第一题也没做出来（就是有点影响心态）。看到这个题，202320232023 这个数的阶乘是不能开 BigInteger 的（这个数非常大），会爆掉的，且这么大的数，在比赛时间内都不一定能跑完。所以我们只能找规律，比赛的时候找不出来的话，可以先把 1 到 50 的结果打印出来。说不定就能找到规律，直接使用计算器算（可以使用计算器）。下面就是就是第 i 阶乘的后 9 位，要取模不然 long 存不下，比赛发现这个规律就可以填了（要珍惜时间）。
• 解题思路：
我们可以观察到当阶乘的底数大于等于 5 时，阶乘结果的末尾将开始出现 0。这是因为阶乘结果中含有至少两个因子 2 和 5，而 2 和 5 相乘正好为 10（结尾就会出现 0 ）。
在一个正整数阶乘的时候，因子 2 的个数一定不小于因子 5 的个数，因此我们只需要考虑因子 5 的个数即可。当因子 5 的个数大于等于 9 时，这个阶乘的后面 9 位就都为 0 了，因此这个阶乘后面就不用再考虑了。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-28T13:01:25+08:00">
    <meta property="article:modified_time" content="2024-06-28T13:01:25+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2023年第十四届蓝桥杯JavaB组省赛真题及全部解析（上）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E5%89%8D%E8%A8%80%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80%EF%BC%9A" rel="nofollow">前言：</a></p> 
<p id="%E4%B8%80%E3%80%81%E8%AF%95%E9%A2%98%20A%EF%BC%9A%E9%98%B6%E4%B9%98%E6%B1%82%E5%92%8C%EF%BC%88%E5%A1%AB%E7%A9%BA%EF%BC%89-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E8%AF%95%E9%A2%98%20A%EF%BC%9A%E9%98%B6%E4%B9%98%E6%B1%82%E5%92%8C%EF%BC%88%E5%A1%AB%E7%A9%BA%EF%BC%89" rel="nofollow">一、试题 A：阶乘求和（填空）</a></p> 
<p id="%E4%BA%8C%E3%80%81%E8%AF%95%E9%A2%98%20B%EF%BC%9A%E5%B9%B8%E8%BF%90%E6%95%B0%E5%AD%97%EF%BC%88%E5%A1%AB%E7%A9%BA%EF%BC%89-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E8%AF%95%E9%A2%98%20B%EF%BC%9A%E5%B9%B8%E8%BF%90%E6%95%B0%E5%AD%97%EF%BC%88%E5%A1%AB%E7%A9%BA%EF%BC%89" rel="nofollow">二、试题 B：幸运数字（填空）</a></p> 
<p id="%E4%B8%89%E3%80%81%E8%AF%95%E9%A2%98%20C%EF%BC%9A%E6%95%B0%E7%BB%84%E5%88%86%E5%89%B2-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E8%AF%95%E9%A2%98%20C%EF%BC%9A%E6%95%B0%E7%BB%84%E5%88%86%E5%89%B2" rel="nofollow">三、试题 C：数组分割</a></p> 
<p id="%E5%9B%9B%E3%80%81%E8%AF%95%E9%A2%98%20D%EF%BC%9A%E7%9F%A9%E9%98%B5%E6%80%BB%E9%9D%A2%E7%A7%AF-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E8%AF%95%E9%A2%98%20D%EF%BC%9A%E7%9F%A9%E9%98%B5%E6%80%BB%E9%9D%A2%E7%A7%AF" rel="nofollow">四、试题 D：矩阵总面积</a></p> 
<p id="%E4%BA%94%E3%80%81%E8%AF%95%E9%A2%98%20E%EF%BC%9A%E8%9C%97%E7%89%9B-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E8%AF%95%E9%A2%98%20E%EF%BC%9A%E8%9C%97%E7%89%9B" rel="nofollow">五、试题 E：蜗牛</a></p> 
<p id="%E5%85%AD%E3%80%81%E8%AF%95%E9%A2%98%20F%EF%BC%9A%E5%90%88%E5%B9%B6%E5%8C%BA%E5%9F%9F-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81%E8%AF%95%E9%A2%98%20F%EF%BC%9A%E5%90%88%E5%B9%B6%E5%8C%BA%E5%9F%9F" rel="nofollow">六、试题 F：合并区域</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E5%89%8D%E8%A8%80%EF%BC%9A">前言：</h2> 
<p>这一篇是我蓝桥系列的第一篇，当然现在第十五届蓝桥杯已经打完了，作者也有参加，运气比较好，拿了个国二，虽然没有达到自己的预期，但也是完成学校的任务，作者是福建省的（弱省），省一我觉得还是挺简单的，随便 ac 两题，打打暴力就省一了，排名还很靠前。蓝桥杯的含金量肯定是不如 ICPC（ACM）和 CCPC （中国的ACM），这个我是深有体会，因为我有参加 CCPC 福建省邀请赛（福州大学），暴零了（一题都没有做出来），直接去旅游了😭😭😭。只能说那种级别的比赛真不是一般人能打的。接下来我会分享我备赛蓝桥杯过程刷的真题和解析，方便和我一样第一次参加蓝桥杯的小白备赛。由于题目比较多，后面几题的题解比较长，只能分成两篇来发，如果有需要的话可以点开下部分，讲解了第 7 到第 10 题。</p> 
<p>题目来自：<a class="link-info" href="https://www.lanqiao.cn/paper/3872/result/" rel="nofollow" title="蓝桥杯官网">蓝桥杯官网</a></p> 
<h2 id="%E4%B8%80%E3%80%81%E8%AF%95%E9%A2%98%20A%EF%BC%9A%E9%98%B6%E4%B9%98%E6%B1%82%E5%92%8C%EF%BC%88%E5%A1%AB%E7%A9%BA%EF%BC%89">一、试题 A：阶乘求和（填空）</h2> 
<p><img alt="" height="1050" src="https://images2.imgbox.com/bd/af/Fl7GNYMb_o.png" width="1200"></p> 
<p><strong>• 题目分析：</strong></p> 
<p>在这里先提醒大家一下，<span style="color:#fe2c24;">填空题做不出来很正常</span>，我当时填空题第一题也没做出来（就是有点影响心态）。看到这个题，202320232023 这个数的阶乘是不能开 BigInteger 的（这个数非常大），会爆掉的，且这么大的数，<span style="color:#fe2c24;">在比赛时间内都不一定能跑完</span>。所以我们只能找规律，比赛的时候找不出来的话，可以先把 1 到 50 的结果打印出来。说不定就能找到规律，直接使用计算器算（可以使用计算器）。下面就是就是第 i 阶乘的后 9 位，要取模不然 long 存不下，比赛发现这个规律就可以填了（要珍惜时间）。</p> 
<p><img alt="" height="773" src="https://images2.imgbox.com/14/26/dJLD4mSF_o.png" width="1200"></p> 
<p><strong>• 解题思路：</strong></p> 
<p>我们可以观察到当阶乘的底数大于等于 5 时，阶乘结果的末尾将开始出现 0。这是因为阶乘结果中含有至少两个因子 2 和 5，而 2 和 5 相乘正好为 10（结尾就会出现 0 ）。</p> 
<p>在一个正整数阶乘的时候，<span style="color:#ff9900;">因子 2 的个数一定不小于因子 5 的个数</span>，因此我们只需要考虑因子 5 的个数即可。当因子 5 的个数大于等于 9 时，这个阶乘的后面 9 位就都为 0 了，因此这个阶乘后面就不用再考虑了。</p> 
<p>我们可以看到在正整数中因子为 5 出现在 5，10，15，20，25（可以算两个），30，35，40，45.....而我们只要前面 9 个即可，也就是 40 之前。当阶乘数大于等于 40 时，结尾 9 位数都是0.</p> 
<p><span style="color:#fe2c24;">因此本题其实只要计算前 40 个阶乘之和。从 40！开始以后都不会影响到最终的结果。</span></p> 
<p><span style="color:#fe2c24;">注意：在运算的过程中要取模防止溢出（MOD取 1e9 即可，正好是后面 9 位）。</span></p> 
<p><strong>• 代码编写：</strong></p> 
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        int MOD = (int) 1e9;
        long sum = 0;//保存和
        long mul = 1;
        for (int i = 1; i &lt; 40; i++) {//阶乘的求法
            mul = (mul * i) % MOD;
            sum = (sum + mul) % MOD;
        }
        System.out.println(sum);
    }
}</code></pre> 
<p><strong>• 运行结果： </strong></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/97/76/X1aNY1JC_o.png" width="1200"></p> 
<p></p> 
<h2 id="%E4%BA%8C%E3%80%81%E8%AF%95%E9%A2%98%20B%EF%BC%9A%E5%B9%B8%E8%BF%90%E6%95%B0%E5%AD%97%EF%BC%88%E5%A1%AB%E7%A9%BA%EF%BC%89">二、试题 B：幸运数字（填空）</h2> 
<p><img alt="" height="771" src="https://images2.imgbox.com/53/5b/OOSFw7iB_o.png" width="1200"></p> 
<p><strong>• 题目分析：</strong></p> 
<p>不要被题目吓到了，读过题目就会发现这是一道签到题，2023 也不会很大。</p> 
<p><strong>• 解题思路：</strong></p> 
<p>按照题目的意思模拟即可。</p> 
<p><strong>• 代码编写：</strong></p> 
<p>binary是求出 n 在 base 进制下的各位数和。</p> 
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        int count = 0;
        for(long i = 1;;i++){
            if(i % binary(i,2) == 0 &amp;&amp; i % binary(i,8) ==0 &amp;&amp; i % binary(i,10) == 0
            &amp;&amp; i % binary(i,16) == 0){//根据题意模拟
                count++;
            }
            if(count == 2023){
                System.out.println(i);
                return;
            }
        }
    }
    public static int binary(long n,int base){//求出 n 在 base 进制下的各位数和
        int sum = 0;
        while(n &gt; 0){
            sum += n % base;
            n /= base;
        }
        return sum;
    }
}</code></pre> 
<p><strong>• 运行结果： </strong> </p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/bd/03/kksiSykD_o.png" width="1200"></p> 
<p></p> 
<h2 id="%E4%B8%89%E3%80%81%E8%AF%95%E9%A2%98%20C%EF%BC%9A%E6%95%B0%E7%BB%84%E5%88%86%E5%89%B2">三、试题 C：数组分割</h2> 
<p><img alt="" height="917" src="https://images2.imgbox.com/b8/82/DzexSm5K_o.png" width="1200"></p> 
<p>由于题目加上输入各式和输出格式比较长，需要的友友自行去官方那里看就行。</p> 
<p><strong>• 题目分析：</strong></p> 
<p>题目简单可以理解为：将一个数组分为两个偶数数组（0 也是偶数）<span style="color:#fe2c24;">。根据数学性质，两个偶数相加的和一定也为偶数，因此如果给出的数组总和不是偶数的话直接打印 0 即可</span>。直接讨论两组数组的所有情况非常麻烦。考虑到总和已经为偶数，因此我们只需找出其中 1 个数组的总和为偶数（另一个数组一定也是偶数）的所有情况，就是我们的最终答案。最终这个问题就转化成了类似 01 背包问题，从 1 到 n 的数中选，总和为偶数的有多少种情况。</p> 
<p><strong>• 解题思路：</strong></p> 
<p>这是一道动态规划题，我们要先定义出状态表示。</p> 
<p><strong>1. 状态表示：</strong></p> 
<p>f[i]：表示在前 i 个数中选，总和为偶数的所有情况个数。</p> 
<p>g[i]：表示在前 i 个数中选，总和为奇数的所有情况个数。</p> 
<p><strong>2. 状态转移方程：</strong></p> 
<p>我们以最后一个位置的元素 a[i] 来研究。</p> 
<p><span style="color:#fe2c24;">（1）当 a[i] 为偶数时：</span></p> 
<p>f[i]：可以从前 i - 1 个数的所有，和为偶数的方案中（选或者选 a[i]）转移过来。</p> 
<p>g[i]：可以从前 i - 1 个数的所有，和为奇数的方案中（选或者不选 a[i]）转移过来。</p> 
<p>故在 a[i] 为偶数的状态转移方程为：</p> 
<blockquote> 
 <p><strong>f[i] = 2 * f[i - 1];</strong></p> 
 <p><strong>g[i] = 2 * g[i - 1];</strong></p> 
</blockquote> 
<p><span style="color:#fe2c24;">（2）当 a[i] 为奇数时：</span></p> 
<p>f[i]：可以分别从前 i - 1 个数的所有，和为偶数的方案中（不选 a[i]）、前 i - 1 个数的所有，和为奇数的方案中（选 a[i]）转移过来。</p> 
<p>g[i]：可以分别从前 i - 1 个数的所有，和为偶数的方案中（选 a[i]）、前 i - 1 个数的所有，和为奇数的方案中（不选 a[i]）转移过来。</p> 
<blockquote> 
 <p><strong>f[i] = f[i - 1] + g[i - 1];</strong></p> 
 <p><strong>g[i] = f[i - 1] + g[i - 1];</strong></p> 
</blockquote> 
<p><strong>3. 初始化</strong></p> 
<p>因为数组为空时也算一个偶数方案。所以设 f[0] = 1即可。</p> 
<p><strong>• 代码编写：</strong></p> 
<pre><code class="language-java">import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int MOD = (int) 1e9 + 7;
        //dp
        int T = in.nextInt();
        while (T &gt; 0) {
            int n = in.nextInt();
            int[] nums = new int[n + 1];
            long sum = 0;
            for (int i = 1; i &lt;= n; i++) {
                nums[i] = in.nextInt();
                sum += nums[i];
            }
            if (sum % 2 == 1) {//特判
                System.out.println(0);
            }else {
                //1.创建 dp 表
                int[] f = new int[n + 1];
                int[] g = new int[n + 1];
                f[0] = 1;
                //2.初始化
                //3.填表
                for (int i = 1; i &lt;= n; i++) {
                    if (nums[i] % 2 == 0) {
                        //偶数情况
                        f[i] = (2 * f[i - 1]) % MOD;
                        g[i] = (2 * g[i - 1]) % MOD;
                    } else {
                        //奇数情况
                        f[i] = (f[i - 1] + g[i - 1]) % MOD;
                        g[i] = (f[i - 1] + g[i - 1]) % MOD;//sb了g + g，抄错了
                    }
                }
                //4.返回值
                System.out.println(f[n]);
            }
            T--;
        }
    }
}
</code></pre> 
<p><strong>• 时间复杂度：</strong></p> 
<p>O（T * N）。 T 为测试数据的组数，n 为每组数据个数。能过。</p> 
<p><strong>• 运行结果： </strong> </p> 
<p><img alt="" height="1168" src="https://images2.imgbox.com/8e/94/za3dvbLY_o.png" width="1200"></p> 
<p></p> 
<h2 id="%E5%9B%9B%E3%80%81%E8%AF%95%E9%A2%98%20D%EF%BC%9A%E7%9F%A9%E9%98%B5%E6%80%BB%E9%9D%A2%E7%A7%AF">四、试题 D：矩阵总面积</h2> 
<p><img alt="" height="864" src="https://images2.imgbox.com/91/1f/u0VxvsbP_o.png" width="1200"></p> 
<p><strong>• 题目分析：</strong></p> 
<p>本题是考计算几何的知识，本题的难点在于如何计算出矩阵重合地方的面积，这一块考的较少，如果知道重合地方的面积怎么算的话，这题就是送分的，如果不知道的话，就模拟打打暴力整点分。</p> 
<p><strong>• 解题思路：</strong></p> 
<p>先算出全部面积（y2 - y1）* (x2 - x1)，另一个同理。</p> 
<p><span style="color:#fe2c24;">计算重叠部分的面积：</span></p> 
<blockquote> 
 <p><strong>x轴上的重叠长度：k = max(0,min(x2,x4) - max(x1,x3));</strong></p> 
 <p><strong>y轴上的重叠长度：k = max(0,min(y2,y4) - max(y1,y3));</strong></p> 
</blockquote> 
<p> 之所以和 0 取较大的数，是为了避免两个矩形没有重叠的地方，计算出来的结果会是负数，为了避免这种情况，我们使用 max 函数，当两个矩形没有重叠时，重叠长度为 0 。（这个公式我是看别人的，怎么来的我也不知道）</p> 
<p><strong>暴力：</strong></p> 
<p>可以创建一个二维数组，把两个矩形填上，最后遍历矩形，有多少个格子被填充，面积就是多少。</p> 
<p>时间复杂度O（n ^ 2）。超时，但是能骗到不少分数。代码不难我就不实现了。</p> 
<p><strong>• 代码编写：</strong></p> 
<pre><code class="language-java">import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        //读入数据
        long x1 = in.nextLong(),y1 = in.nextLong(),x2 = in.nextLong(),y2 = in.nextLong();
        long x3 = in.nextLong(),y3 = in.nextLong(),x4 = in.nextLong(),y4 = in.nextLong();
        long sum = ((y4 - y3) * (x4 - x3)) + ((y2 - y1) * (x2 - x1));//全部面积
        long sub = Math.max(0,((Math.min(y4,y2) - Math.max(y1,y3)) * (Math.min(x4,x2) - Math.max(x1,x3))));//重复面积
        sum -= sub;
        System.out.println(sum);
    }
}</code></pre> 
<p><strong>• 时间复杂度：</strong></p> 
<p>O（1），肯定能过。</p> 
<p><strong>• 运行结果： </strong> </p> 
<p><img alt="" height="1050" src="https://images2.imgbox.com/e8/1a/INNLRyoZ_o.png" width="1200"></p> 
<p></p> 
<h2 id="%E4%BA%94%E3%80%81%E8%AF%95%E9%A2%98%20E%EF%BC%9A%E8%9C%97%E7%89%9B">五、试题 E：蜗牛</h2> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/18/50/atBce6qG_o.png" width="1200"></p> 
<p></p> 
<p><strong>• 题目分析：</strong></p> 
<p>根据题意求最少时间，且有走地面和爬杆坐传送门两种方式，发现存在某种递推关系，故我们可以尝试使用动态规划解决。</p> 
<p><strong>• 解题思路：</strong></p> 
<p><strong>1. 状态表示：</strong></p> 
<p>f[i]：表示到达第 i 根竹竿的底部的最小时间。</p> 
<p>g[i]：表示到达第 i 根竹竿的传送门（a [i] ,不是 b [i - 1]）的最小时间。</p> 
<p><strong>2. 状态转移方程：</strong></p> 
<p><strong>h[i][2] 使用 h[i][0] 来表示 a[i]，使用 h[i][1] 来表示 b[i + 1]。</strong></p> 
<p>我们以最后一个位置来分析：</p> 
<p>（1）对于 f[i] 有两种情况：</p> 
<p>• 可以从前一根杆的底部走到当前杆的底部：<strong>f[i] = f[i - 1] + a[i] - a[i - 1];</strong></p> 
<p>• 可以从前一根杆的传送门传送到当前杆，再爬下来：<strong>g[i] = g[i - 1] + h[i - 1][1] / 1.3;</strong></p> 
<p><span style="color:#fe2c24;">注意：因为这里 f[i - 1] 已经表示到达第i - 1根杆的最小时间，所以就不用考虑存在从 i - 1根杆的传送门爬到底部，再走到当前杆底部的这种情况（因为肯定没有 </span>f[i] = f[i - 1] + a[i] - a[i - 1] 快<span style="color:#fe2c24;">）。</span></p> 
<p>（2）对于 g[i] 也有两种情况：</p> 
<p>• 可以从前一根杆的底部爬到当前杆的底部，再爬到传送门：<strong>g[i] = f[i - 1] + a[i] - a[i - 1] + h[i][0] / 1.3;</strong></p> 
<p>• 可以从前一根杆的传送门传送到当前杆，再爬到当前杆的 a[i]（传送过来是在 b[i - 1]）。注意：这里要分情况讨论，因为不确定是向上爬还是向下爬。<strong>g[i] = g[i - 1] + (h[i - 1][1] &gt;= h[i][0]) ? )h[i - 1][1] - h[i][0]) / 1.3 : (h[i][0] - h[i - 1][1]) / 0.7;</strong></p> 
<p><strong>3. 初始化</strong></p> 
<p><strong>f[1] = a[1];</strong></p> 
<p><strong>g[1] = a[1] + h[1][0] / 0.7;</strong></p> 
<p><strong>• 代码编写：</strong></p> 
<pre><code class="language-java">import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int[] arr = new int[n + 1];//存放杆的位置
        for(int i = 1;i &lt;= n;i++){
            arr[i] = in.nextInt();
        }
        int[][] h = new int[n + 1][2];
        for(int i = 1;i &lt; n;i++){
            h[i][0] = in.nextInt();
            h[i][1] = in.nextInt();
        }
        //1.创建 dp 表
        double[] f = new double[n + 1];
        double[] g = new double[n + 1];
        //2.初始化
        f[1] = arr[1];
        g[1] = arr[1] + (h[1][0]) / 0.7;

        //3.填表
        for(int i = 2;i &lt;= n;i++){
            f[i] = Math.min(f[i - 1] + arr[i] - arr[i - 1],g[i - 1] + (h[i - 1][1]) / 1.3);
            double tmp = 0;
            if(h[i - 1][1] &gt;= h[i][0]){
                tmp = g[i - 1] + (h[i - 1][1] - h[i][0]) / 1.3;
            }else{
                tmp = g[i - 1] + (h[i][0] - h[i - 1][1]) / 0.7;
            }
            g[i] = Math.min(f[i] + h[i][0] / 0.7,tmp);//向上爬是 0.7
        }
        //4.返回值
        System.out.printf("%.2f",f[n]);
    }
}</code></pre> 
<p><strong>• 时间复杂度：</strong></p> 
<p><strong>O（n），能过</strong></p> 
<p><strong>• 运行结果： </strong> </p> 
<p><img alt="" height="907" src="https://images2.imgbox.com/cc/7d/8iDYV9F0_o.png" width="1200"></p> 
<p></p> 
<h2 id="%E5%85%AD%E3%80%81%E8%AF%95%E9%A2%98%20F%EF%BC%9A%E5%90%88%E5%B9%B6%E5%8C%BA%E5%9F%9F">六、试题 F：合并区域</h2> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/cf/4b/165KlLuv_o.png" width="1200"></p> 
<p> <strong>• 题目分析：</strong></p> 
<p>题目其实不是很好读懂，题意是：随便方向都可以拼接，至少有一个接触点即可，且正方形可以翻转。考虑到要翻转，加上各个方向拼接，至少有 16 种情况以上，显然这是一道大模拟题。比赛的时候看到这种题，就暴力写点分，宁愿不写也不要全写（大佬当我没说），全部 AC 要花非常多的时间，且不一定能写对。<span style="color:#fe2c24;">看到大模拟就跑。</span></p> 
<p><strong>• 解题思路：</strong></p> 
<p>暴力大模拟，把所有翻转情况都枚举出来（填在同一个地图中），再用 bfs 找到最大连通块。我们直接把 B 填在 A 中 来枚举所有情况（图中只有上下，左右没有画出），所以 A 至少要建立 3 * n的大小。在对每个 AB 分别 BFS 找出最大值，就是我们的答案。代码如果看不懂的话，画个 2 * 2的正方形，照着代码模拟一下。（翻转其中一个正方形就能枚举出所有情况）。</p> 
<p><img alt="" height="947" src="https://images2.imgbox.com/58/cc/WF19UON6_o.png" width="1165"></p> 
<p><span style="color:#fe2c24;">下面代码注释中的偏移位置是枚举如下图情况（左右同理）。</span></p> 
<p><img alt="" height="862" src="https://images2.imgbox.com/6f/3c/zSkrc3A3_o.png" width="1200"></p> 
<p><strong>• 代码编写：</strong></p> 
<p>rotateMatrix 函数用来翻转矩阵（这个可以记下来）。 </p> 
<pre><code class="language-java">import java.util.*;

public class Main {
    static int N = 180;//用来创建矩阵
    static int a[][] = new int[N][N];//a 用来保存最后拼接的结果
    static int b[][] = new int[55][55];// 另一个矩形
    static int n;

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        n = in.nextInt();
        //读入第一个矩阵
        for (int i = 1 + n; i &lt;= n * 2; i++) {
            for (int j = 1 + n; j &lt;= n * 2; j++) {
                a[i][j] = in.nextInt();
            }
        }
        //读入第二个矩形
        for (int i = 1; i &lt;= n; i++) {
            for (int j = 1; j &lt;= n; j++) {
                b[i][j] = in.nextInt();
            }
        }
        int ans = 0;
        int[][] g = new int[N][N];
        for (int x = 0; x &lt; 4; x++) {//枚举翻转的四个方向
            for (int k = 2; k &lt;= 2 * n; k++) {//偏移位置
                for (int i = 0; i &lt; N; i++) {
                    for (int j = 0; j &lt; N; j++) {
                        g[i][j] = a[i][j];//将 a 拷贝给 g
                    }
                }
                for (int i = 1; i &lt;= n; i++) {
                    for (int j = k; j &lt;= n + k; j++) {//上下
                        g[i][j] = b[i][j - k + 1];
                        g[i + 2 * n][j] = b[i][j - k + 1];
                    }
                }
                int top = 1, bottom = 2 * n, left, right;//bfs 的边界
                if (k &lt;= n) {
                    left = k;
                    right = 2 * n;
                } else {
                    left = n + 1;
                    right = k + n - 1;//画图
                }
                ans = Math.max(ans, bfs(g, left, right, top, bottom));//bfs 找最大联通块
                ans = Math.max(ans, bfs(g, left, right, top + n, bottom + n));
            }
            //和上面的一样不过就是填左右
            for (int k = 2; k &lt;= 2 * n; k++) {
                for (int i = 0; i &lt; N; i++) {
                    g[i] = Arrays.copyOf(a[i], N);
                }
                for (int i = k; i &lt;= n + k; i++) {
                    for (int j = 1; j &lt;= n; j++) {//填写左右
                        g[i][j] = b[i - k + 1][j];
                        g[i][j + 2 * n] = b[i - k + 1][j];
                    }
                }
                int top, bottom, left = 1, right = 2 * n;
                if (k &lt;= n) {
                    top = k;
                    bottom = 2 * n;
                } else {
                    top = n + 1;
                    bottom = n + k - 1;
                }
                ans = Math.max(ans, bfs(g, left, right, top, bottom));
                ans = Math.max(ans, bfs(g, left + n, right + n, top, bottom));
            }
            rotateMatrix();//翻转矩阵
            for (int i = 1; i &lt;= n; i++) {
                for (int j = 1; j &lt;= n; j++) {
                    b[i][j] = rotate[i][j];//翻转 b 即可
                }
            }
        }
        System.out.println(ans);
    }

    static int[][] rotate = new int[N][N];

    static void rotateMatrix() {//翻转矩阵
        for (int i = 1; i &lt;= n; i++) {
            for (int j = 1; j &lt;= n; j++) {
                rotate[j][n - i + 1] = b[i][j];
            }
        }
    }


    //简单的 bfs 求最大联通块
    static int[] dx = {0,0,1,-1};
    static int[] dy = {1,-1,0,0};
    static int bfs (int[][] map,int left,int right,int top,int bottom){
        int ret = 0;//存储最终结果
        boolean[][] vis = new boolean[N][N];
        Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;();
        int path = 0;
        for(int i = top;i &lt;= bottom;i++){
            for(int j = left;j &lt;= right;j++){
                if(map[i][j] == 1 &amp;&amp; !vis[i][j]){
                    path = 0;
                    q.add(new int[]{i,j});
                    while(!q.isEmpty()){
                        int[] tmp = q.poll();
                        int sr = tmp[0],sc = tmp[1];
                        path++;
                        vis[sr][sc] = true;
                        for(int k = 0;k &lt; 4;k++){
                            int x = sr + dx[k];
                            int y = sc + dy[k];
                            if(x &gt;= top &amp;&amp; x &lt;= bottom &amp;&amp; y &gt;= left &amp;&amp; y &lt;= right &amp;&amp; !vis[x][y] &amp;&amp;
                            map[x][y] == 1){
                                q.add(new int[]{x,y});
                                vis[x][y] = true;
                            }
                        }
                    }
                    ret = Math.max(ret,path);
                }
            }
        }
        return ret;
    }
}
</code></pre> 
<p><strong>• 运行结果： </strong> </p> 
<p><img alt="" height="944" src="https://images2.imgbox.com/19/fb/Swk2XMxV_o.png" width="1200"></p> 
<p><strong>结语：</strong></p> 
<p><strong>其实写博客不仅仅是为了教大家，同时这也有利于我巩固知识点，和做一个学习的总结，由于作者水平有限，对文章有任何问题还请指出，非常感谢。如果大家有所收获的话还请不要吝啬你们的点赞收藏和关注，这可以激励我写出更加优秀的文章。</strong></p> 
<p><img alt="" height="400" src="https://images2.imgbox.com/ae/10/VqiJwScN_o.png" width="1080"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/563e904d5bc88a3f513044c3687b07b9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">力扣每日一题 6/28 动态规划/数组</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bdc81620b980140eecb0e7905e79f23e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android出海实战：Android14适配</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>