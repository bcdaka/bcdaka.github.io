<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>重头开始嵌入式第十九天（Linux系统编程 文件IO） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/5295c0e0e4e14071a7edea143b5bfc0f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="重头开始嵌入式第十九天（Linux系统编程 文件IO）">
  <meta property="og:description" content="缓冲区 1.行缓冲
行缓冲，1k， terminal，主要用于人机交互stdout
缓存区满或者遇到\n刷新 1024
行缓存多是关于终端的一些操作
1.遇到\n刷新
2.缓存区满刷新
3.程序结束刷新
4.fflush刷新 fflush(stdout);
2.全缓冲
全缓冲，4k，主要用于文件的读写
缓存区满刷新缓存区 4096
对普通文件进行标准IO操作，建立
的缓存一般为全缓存
刷新条件:
1.缓存区满刷新
2.程序结束刷新
3.fflush来刷新 fflush(fp);
3.无缓冲
无缓冲，0k 主要用于出错处理信息的输出 stderr 不对数据缓存直接刷新
printf();==&gt;&gt;stdout fprintf(strerr,&#34;fopen error %s&#34;,filename);
界面交互 出错处理
使用gdb查看，FILE结构体，或使用写入数据测试缓冲区。
缓冲区的大小是可以设置
在 C 语言中，可以通过以下方式手动控制缓冲：
1. 使用 fflush 函数： fflush 函数用于强制刷新输出缓冲区，将缓冲区中的内容立即输出。例如： fflush(stdout); 这将刷新标准输出缓冲区。
2. 设置缓冲模式：可以使用 setvbuf 函数来设置缓冲区的类型和大小。函数原型为： int setvbuf(FILE *stream, char *buffer, int mode, size_t size); 其中：
- stream 是要设置缓冲的文件流指针。
- buffer 是用户提供的缓冲区（如果为 NULL ，则由系统分配）。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-14T09:04:24+08:00">
    <meta property="article:modified_time" content="2024-08-14T09:04:24+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">重头开始嵌入式第十九天（Linux系统编程 文件IO）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>缓冲区</h2> 
<p> </p> 
<p>1.行缓冲</p> 
<p>行缓冲，1k， terminal，主要用于人机交互stdout<br> 缓存区满或者遇到\n刷新 1024<br> 行缓存多是关于终端的一些操作<br> 1.遇到\n刷新<br> 2.缓存区满刷新<br> 3.程序结束刷新<br> 4.fflush刷新  fflush(stdout);</p> 
<p>2.全缓冲</p> 
<p><br> 全缓冲，4k，主要用于文件的读写<br> 缓存区满刷新缓存区 4096<br> 对普通文件进行标准IO操作，建立<br> 的缓存一般为全缓存<br> 刷新条件:<br> 1.缓存区满刷新<br> 2.程序结束刷新<br> 3.fflush来刷新  fflush(fp);</p> 
<p>3.无缓冲</p> 
<p><br> 无缓冲，0k  主要用于出错处理信息的输出 stderr <br> 不对数据缓存直接刷新<br> printf();==&gt;&gt;stdout <br> fprintf(strerr,"fopen error %s",filename);<br> 界面交互 出错处理<br> 使用gdb查看，FILE结构体，或使用写入数据测试缓冲区。<br> 缓冲区的大小是可以设置</p> 
<p>在 C 语言中，可以通过以下方式手动控制缓冲：</p> 
<p> </p> 
<p>1. 使用  fflush  函数： fflush  函数用于强制刷新输出缓冲区，将缓冲区中的内容立即输出。例如： fflush(stdout);  这将刷新标准输出缓冲区。</p> 
<p>2. 设置缓冲模式：可以使用  setvbuf  函数来设置缓冲区的类型和大小。函数原型为： int setvbuf(FILE *stream, char *buffer, int mode, size_t size);  其中：</p> 
<p> </p> 
<p>-  stream  是要设置缓冲的文件流指针。</p> 
<p>-  buffer  是用户提供的缓冲区（如果为  NULL ，则由系统分配）。</p> 
<p>-  mode  可以是  _IONBF （无缓冲）、 _IOLBF （行缓冲）、 _IOFBF （全缓冲）。</p> 
<p>-  size  是缓冲区的大小（仅在全缓冲和行缓冲时有效）。</p> 
<p> </p> 
<p>例如，要将  stdout  设置为无缓冲，可以这样写：</p> 
<pre><code class="language-cs">setvbuf(stdout, NULL, _IONBF, 0);</code></pre> 
<p> </p> 
<h2>fseek</h2> 
<p> </p> 
<p>“fseek”是 C 语言标准库中的一个文件操作函数，用于在文件中移动文件指针的位置。<br>  <br> 其函数原型为： int fseek(FILE *stream, long offset, int whence); <br>  <br> 参数解释：<br>  <br> -  stream ：指向文件流的指针。<br> -  offset ：要移动的字节数，可以是正数（向前移动）、负数（向后移动）或 0（保持当前位置）。<br> -  whence ：指定起始位置，有以下几种取值：<br> -  SEEK_SET ：文件开头。<br> -  SEEK_CUR ：当前位置。<br> -  SEEK_END ：文件末尾。<br>  <br> 函数返回值：成功返回 0 ，失败返回非零值。<br>  <br> 例如，如果要将文件指针移动到文件开头向前 10 个字节的位置，可以这样写：</p> 
<pre><code class="language-cs">FILE *fp;
if ((fp = fopen("example.txt", "r"))!= NULL) {
    if (fseek(fp, -10, SEEK_SET) == 0) {
        // 移动成功后的操作
    } else {
        // 移动失败的处理
    }
    fclose(fp);
}</code></pre> 
<p><br>  </p> 
<h2><br>  rewind</h2> 
<h2> </h2> 
<p>“rewind”也是 C 语言标准库中用于文件操作的函数。<br>  <br> 其作用是将文件指针重新定位到文件的开头。<br>  <br> 函数原型为： void rewind(FILE *stream); <br>  <br> 使用“rewind”函数会清除文件流的错误和 EOF 标记，并将文件指针重置到文件的起始位置。<br>  <br> 例如：</p> 
<pre><code class="language-cs">FILE *fp;
if ((fp = fopen("example.txt", "r"))!= NULL) {
    // 进行一些文件操作
    rewind(fp);  // 将文件指针重置到开头
    // 后续基于开头位置的操作
    fclose(fp);
}</code></pre> 
<p><br> 它相比于“fseek(fp, 0, SEEK_SET)”这种方式更加简洁直观，但功能是相同的，都是将文件指针移到文件开头。<br>  </p> 
<p> </p> 
<h2>ftell</h2> 
<p> </p> 
<p>“ftell”是 C 语言标准库中的一个函数，用于获取文件指针在文件中的当前位置。<br>  <br> 函数原型为： long ftell(FILE *stream); <br>  <br> 它返回一个长整型值，表示文件指针相对于文件开头的偏移量（以字节为单位）。如果返回值为 -1L，表示获取位置信息时出现错误。<br>  <br> 例如：</p> 
<pre><code class="language-cs">FILE *fp;
if ((fp = fopen("example.txt", "r"))!= NULL) {
    long position = ftell(fp);  // 获取当前位置
    // 进行一些操作
    fclose(fp);
}</code></pre> 
<h2><br>  <br> 文件io</h2> 
<p><br> 操作系统为了方便用户使用系统功能而对外提供的一组系统函数。称之为 系统调用  其中有个  文件IO，一般都是对设备文件操作,当然也可以对普通文件进行操作。<br> 是一个基于Linux内核的没有缓存的IO机制</p> 
<h4>特性：</h4> 
<p><br> .1 没有缓存区<br> .2 操作对象不在是流，而是文件描述符  FILE*    int 0-1023<br> .3文件描述符<br> 很小的非负的整数 int   0-1023<br> 内核每打开一个文件就会获得一个文件 描述符<br><br>   每个程序在启动的时候操作系统默认为其打开<br>   三个描述符与流对象匹配：<br>   0 ==&gt;STDIN_FILENO === stdin<br>   1 ==&gt;STDOUT_FILENO == stdout<br>   2 ==&gt;STDERR_FILENO == stderr</p> 
<p>在 Linux 中，标准 I/O 和文件 I/O 主要有以下区别：</p> 
<p><br>  <br> 1. 缓冲机制：标准 I/O 提供了缓冲机制，例如全缓冲、行缓冲和无缓冲。这意味着数据在满足一定条件（如缓冲区填满、遇到换行符等）时才会实际进行读写操作。而文件 I/O 通常是无缓冲或由用户自行控制缓冲。<br> 2. 可移植性：标准 I/O 具有更好的可移植性，因为它的接口在不同的操作系统上通常是相似的。而文件 I/O 的某些细节在不同的系统中可能会有所不同。<br> 3. 函数接口：标准 I/O 使用如  fprintf 、 fscanf  等函数，而文件 I/O 使用如  open 、 read 、 write 、 close  等函数。<br> 4. 处理对象：标准 I/O 主要处理与标准输入、输出和标准错误相关的流。文件 I/O 可以处理各种文件，包括普通文件、设备文件等。<br> 5. 效率：在某些情况下，文件 I/O 可能比标准 I/O 更高效，特别是在需要频繁进行小量数据读写时，因为标准 I/O 的缓冲机制可能会引入一些额外的开销。<br>  <br>  </p> 
<h4>相关函数</h4> 
<p> </p> 
<h4>open</h4> 
<p> </p> 
<p>在 Linux 中， open  函数用于打开或创建文件。<br>  <br>  open  函数的原型通常如下：</p> 
<pre><code class="language-cs">#include &lt;fcntl.h&gt;

int open(const char *pathname, int flags, mode_t mode);</code></pre> 
<p>-  pathname ：要打开文件的路径名。<br> -  flags ：指定打开文件的方式，常用的标志包括：<br> -  O_RDONLY ：以只读方式打开。<br> -  O_WRONLY ：以只写方式打开。<br> -  O_RDWR ：以读写方式打开。<br> -  O_CREAT ：如果文件不存在则创建它。<br> -  O_TRUNC ：如果文件存在且以可写方式打开，则清空文件内容。<br> - 这些标志可以通过逻辑或（ | ）组合使用。<br> -  mode ：仅在创建新文件时使用，指定文件的权限。<br>  <br>  open  函数成功时返回一个文件描述符（一个非负整数），失败时返回  -1  ，并设置  errno  来指示错误原因。<br>  <br> 例如，以读写方式打开一个已存在的文件：</p> 
<pre><code class="language-cs">int fd = open("example.txt", O_RDWR);
if (fd == -1) {
    perror("Error opening file");
    return -1;
}</code></pre> 
<p>又如，创建一个新文件并设置权限为所有者可读可写可执行，组和其他用户可读可执行：</p> 
<pre><code class="language-cs">int fd = open("new_file.txt", O_CREAT | O_WRONLY, S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);
if (fd == -1) {
    perror("Error creating file");
    return -1;
}</code></pre> 
<p>又比如：</p> 
<pre><code class="language-cs">#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
int main(int argc, char *argv[])
{
    int fd = open("1.txt",O_WRONLY| O_CREAT|O_TRUNC,0666);    
    if(-1 == fd)
    {
        fprintf(stderr,"open error\n");
        return 1;
    }
    printf("fd is %d\n",fd);
    return 0;
}
</code></pre> 
<h4>close</h4> 
<p> </p> 
<p>在 Linux 中， close  函数用于关闭一个已打开的文件描述符。</p> 
<p> close  函数的原型如下：</p> 
<pre><code class="language-cs">#include &lt;unistd.h&gt;

int close(int fd);</code></pre> 
<p>其中， fd  是要关闭的文件描述符。</p> 
<p>当成功关闭文件时， close  函数返回 0；如果关闭失败，则返回 -1，并设置  errno  来指示错误原因。</p> 
<p>及时关闭不再使用的文件描述符是良好的编程习惯，它可以释放相关的系统资源，并确保数据的正确写入和同步。</p> 
<h4>write</h4> 
<p> </p> 
<p>在 Linux 中， write  函数用于向一个已打开的文件描述符写入数据。<br>   write  函数的原型如下：</p> 
<pre><code class="language-cs">#include &lt;unistd.h&gt;

ssize_t write(int fd, const void *buf, size_t count);</code></pre> 
<p><br> 参数说明：<br>  <br> -  fd ：文件描述符，指定要写入数据的文件。<br> -  buf ：指向要写入数据的缓冲区。<br> -  count ：要写入的字节数。<br>  <br>  write  函数返回实际写入的字节数，如果发生错误则返回 -1，并设置  errno  来指示错误原因。<br>  <br> 例如：</p> 
<pre><code class="language-cs">char data[] = "Hello, World!";
ssize_t bytesWritten = write(fd, data, sizeof(data));
if (bytesWritten == -1) {
    perror("Error writing to file");
    return -1;
}
 
</code></pre> 
<p>又比如：</p> 
<pre><code class="language-cs">#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
int main(int argc, char *argv[])
{
    int fd = open("1.txt",O_WRONLY| O_CREAT|O_TRUNC,0666);    
    if(-1 == fd)
    {
        fprintf(stderr,"open error\n");
        return 1;
    }
    printf("fd is %d\n",fd);
    char buf[512]="hello";
    int ret = write(fd,buf,strlen(buf));
    if(-1 == ret)
    {
        fprintf(stderr,"write error\n");
        return 1;
    }

    close(fd);
    return 0;
}</code></pre> 
<h4><br> lssek</h4> 
<p> </p> 
<p>“lseek”是在 Unix/Linux 系统编程中用于移动文件指针位置的函数。<br>  <br> 它的函数原型通常为： off_t lseek(int fd, off_t offset, int whence) <br>  <br> 参数含义如下：<br>  <br> -  fd ：文件描述符，标识要操作的文件。<br> -  offset ：偏移量，表示要移动的字节数。<br> -  whence ：指定移动的基准位置，常见的值有：<br> -  SEEK_SET ：从文件开头开始偏移。<br> -  SEEK_CUR ：从当前位置开始偏移。<br> -  SEEK_END ：从文件末尾开始偏移。<br>  <br> 通过“lseek”函数，可以灵活地在文件中定位读取或写入的位置，从而实现对文件的随机访问。</p> 
<p>“lseek”函数的返回值为新的文件偏移量，如果返回值为 -1 则表示发生错误。可以通过“errno”变量来获取具体的错误信息。</p> 
<h4>read</h4> 
<p>在 C 语言中， read 函数通常用于从文件或设备中读取数据。<br>  <br>  read 函数的原型通常是：<br>  <br> #include &lt;unistd.h&gt;</p> 
<p>ssize_t read(int fd, void *buf, size_t count);<br>  <br>  <br> 参数说明：<br>  <br> -  fd ：文件描述符，标识要读取的文件或设备。<br> -  buf ：指向用于存储读取数据的缓冲区。<br> -  count ：要读取的最大字节数。<br>  <br> 返回值：<br>  <br> - 成功读取的字节数，如果到达文件末尾则返回 0 ，出错时返回 -1 。<br>  <br> 以下是一个简单的示例，展示如何使用  read  函数从文件中读取数据：<br>  <br><br> #include &lt;stdio.h&gt;<br> #include &lt;stdlib.h&gt;<br> #include &lt;unistd.h&gt;<br> #include &lt;fcntl.h&gt;</p> 
<p>int main() {<!-- --><br>     int fd = open("test.txt", O_RDONLY);<br>     if (fd == -1) {<!-- --><br>         perror("Error opening file");<br>         return 1;<br>     }</p> 
<p>    char buf[1024];<br>     ssize_t bytesRead = read(fd, buf, sizeof(buf));<br>     if (bytesRead == -1) {<!-- --><br>         perror("Error reading file");<br>         return 1;<br>     }</p> 
<p>    printf("Read %ld bytes: %s\n", bytesRead, buf);</p> 
<p>    close(fd);<br>     return 0;<br> }<br>  <br>  <br> 在上述示例中，首先打开一个文件，然后使用  read  函数读取数据，并将读取到的数据打印出来。<br>  </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f3461631b00fb9731ce9c64c0537b2eb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">API-Runtime</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a49d416c105e4b200d0b5280c0ba6d78/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">线程池的创建以及工作原理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>