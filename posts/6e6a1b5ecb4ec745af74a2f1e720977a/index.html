<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>剖析【C&#43;&#43;】——类和对象(下篇)——超详解——小白篇 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/6e6a1b5ecb4ec745af74a2f1e720977a/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="剖析【C&#43;&#43;】——类和对象(下篇)——超详解——小白篇">
  <meta property="og:description" content="目录
1.再谈构造函数
1.1 构造函数体赋值
1.2 初始化列表
1.3 explicit 关键字
2. Static成员
2.1 概念
2.2 特性
3. 友元
3.1 友元函数
3.2 友元类
3.3总结：
4. 内部类
1.概念
2.特性
示例代码：
代码分析
3.总结
5.再次理解类和对象
1. 抽象现实生活中的实体
2. 用类描述实体
3. 实例化对象
4. 总结类和对象的关系
1.再谈构造函数 1.1 构造函数体赋值 构造函数是用来初始化对象的特殊函数。当我们创建一个对象时，编译器会自动调用构造函数来给对象的成员变量赋值。
简单理解：当你买一个新手机，打开包装，这就像调用了构造函数。手机里的默认应用程序就像成员变量的初始值。这些默认应用虽然是预装的，但我们可以再安装新的应用，这相当于构造函数体内的赋值操作。
示例代码：
class MyClass { public: int x; int y; MyClass(int a, int b) : x(a), y(b) {} // 初始化列表 }; 在上面的代码中，当我们创建一个 MyClass 对象时，比如 MyClass obj(10);，构造函数 MyClass(int value) 会被调用，x 会被赋值为 10。但是这个过程叫赋值，不叫初始化，因为我们可以在构造函数内多次赋值。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-31T17:47:25+08:00">
    <meta property="article:modified_time" content="2024-05-31T17:47:25+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">剖析【C&#43;&#43;】——类和对象(下篇)——超详解——小白篇</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f5/ad/XU04MwO8_o.gif"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E5%86%8D%E8%B0%88%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#1.%E5%86%8D%E8%B0%88%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" rel="nofollow">1.再谈构造函数</a></p> 
<p id="1.1%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BD%93%E8%B5%8B%E5%80%BC-toc" style="margin-left:40px;"><a href="#1.1%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BD%93%E8%B5%8B%E5%80%BC" rel="nofollow">1.1 构造函数体赋值</a></p> 
<p id="1.2%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8-toc" style="margin-left:40px;"><a href="#1.2%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8" rel="nofollow">1.2 初始化列表</a></p> 
<p id="1.3%20explicit%20%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:40px;"><a href="#1.3%20explicit%20%E5%85%B3%E9%94%AE%E5%AD%97" rel="nofollow">1.3 explicit 关键字</a></p> 
<p id="2.%20Static%E6%88%90%E5%91%98-toc" style="margin-left:0px;"><a href="#2.%20Static%E6%88%90%E5%91%98" rel="nofollow">2. Static成员</a></p> 
<p id="2.1%20%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#2.1%20%E6%A6%82%E5%BF%B5" rel="nofollow">2.1 概念</a></p> 
<p id="2.2%20%E7%89%B9%E6%80%A7-toc" style="margin-left:40px;"><a href="#2.2%20%E7%89%B9%E6%80%A7" rel="nofollow">2.2 特性</a></p> 
<p id="3.%20%E5%8F%8B%E5%85%83-toc" style="margin-left:0px;"><a href="#3.%20%E5%8F%8B%E5%85%83" rel="nofollow">3. 友元</a></p> 
<p id="3.1%20%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#3.1%20%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0" rel="nofollow">3.1 友元函数</a></p> 
<p id="3.2%20%E5%8F%8B%E5%85%83%E7%B1%BB-toc" style="margin-left:40px;"><a href="#3.2%20%E5%8F%8B%E5%85%83%E7%B1%BB" rel="nofollow">3.2 友元类</a></p> 
<p id="3.3%E6%80%BB%E7%BB%93%EF%BC%9A-toc" style="margin-left:40px;"><a href="#3.3%E6%80%BB%E7%BB%93%EF%BC%9A" rel="nofollow">3.3总结：</a></p> 
<p id="4.%20%E5%86%85%E9%83%A8%E7%B1%BB-toc" style="margin-left:0px;"><a href="#4.%20%E5%86%85%E9%83%A8%E7%B1%BB" rel="nofollow">4. 内部类</a></p> 
<p id="1.%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#1.%E6%A6%82%E5%BF%B5" rel="nofollow">1.概念</a></p> 
<p id="2.%E7%89%B9%E6%80%A7-toc" style="margin-left:40px;"><a href="#2.%E7%89%B9%E6%80%A7" rel="nofollow">2.特性</a></p> 
<p id="%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">示例代码：</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90" rel="nofollow">代码分析</a></p> 
<p id="3.%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#3.%E6%80%BB%E7%BB%93" rel="nofollow">3.总结</a></p> 
<p id="5.%E5%86%8D%E6%AC%A1%E7%90%86%E8%A7%A3%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-toc" style="margin-left:0px;"><a href="#5.%E5%86%8D%E6%AC%A1%E7%90%86%E8%A7%A3%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1" rel="nofollow">5.再次理解类和对象</a></p> 
<p id="1.%20%E6%8A%BD%E8%B1%A1%E7%8E%B0%E5%AE%9E%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E5%AE%9E%E4%BD%93-toc" style="margin-left:40px;"><a href="#1.%20%E6%8A%BD%E8%B1%A1%E7%8E%B0%E5%AE%9E%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E5%AE%9E%E4%BD%93" rel="nofollow">1. 抽象现实生活中的实体</a></p> 
<p id="2.%20%E7%94%A8%E7%B1%BB%E6%8F%8F%E8%BF%B0%E5%AE%9E%E4%BD%93-toc" style="margin-left:40px;"><a href="#2.%20%E7%94%A8%E7%B1%BB%E6%8F%8F%E8%BF%B0%E5%AE%9E%E4%BD%93" rel="nofollow">2. 用类描述实体</a></p> 
<p id="3.%20%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1-toc" style="margin-left:40px;"><a href="#3.%20%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1" rel="nofollow">3. 实例化对象</a></p> 
<p id="4.%20%E6%80%BB%E7%BB%93%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB-toc" style="margin-left:40px;"><a href="#4.%20%E6%80%BB%E7%BB%93%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB" rel="nofollow">4. 总结类和对象的关系</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2><span style="color:#4da8ee;">1.再谈构造函数</span></h2> 
<h3 id="1.1%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BD%93%E8%B5%8B%E5%80%BC"><span style="color:#38d8f0;">1.1 构造函数体赋值</span></h3> 
<p>构造函数是用来初始化对象的特殊函数。当我们创建一个对象时，编译器会自动调用构造函数来给对象的成员变量赋值。</p> 
<p><strong>简单理解</strong>：当你买一个新手机，打开包装，这就像调用了构造函数。手机里的默认应用程序就像成员变量的初始值。这些默认应用虽然是预装的，但我们可以再安装新的应用，这相当于构造函数体内的赋值操作。</p> 
<p><strong>示例代码：</strong></p> 
<pre><code>class MyClass {
public:
    int x;
    int y;
    MyClass(int a, int b) : x(a), y(b) {}  // 初始化列表
};
</code></pre> 
<p>在上面的代码中，当我们创建一个 <code>MyClass</code> 对象时，比如 <code>MyClass obj(10);</code>，构造函数 <code>MyClass(int value)</code> 会被调用，<code>x</code> 会被赋值为 <code>10</code>。但是这个过程叫赋值，不叫初始化，因为我们可以在构造函数内多次赋值。</p> 
<p><strong><span style="background-color:#ffd900;">总结</span></strong><span style="background-color:#ffd900;">：构造函数体内的赋值可以多次进行，而初始化只能进行一次。</span></p> 
<h3 id="1.2%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span style="color:#38d8f0;">1.2 初始化列表</span></h3> 
<p><strong>初始化列表</strong> 是另一种在创建对象时给成员变量赋初值的方法。这种方法更高效，因为它在对象创建时就直接赋值，而不是先创建对象然后再赋值。</p> 
<p><strong>简单理解</strong>：假设你买了一辆新车，初始化列表就像你在购车前已经决定好车的颜色、型号等，而不是买车后再去喷漆改装。</p> 
<p><strong>示例代码：</strong></p> 
<pre><code>class MyClass {
public:
    int x;
    int y;
    MyClass(int a, int b) : x(a), y(b) {}  // 初始化列表
};
</code></pre> 
<p>在上面的代码中，<code>: x(a), y(b)</code> 就是初始化列表，它在构造函数体执行之前完成成员变量的初始化。</p> 
<blockquote> 
 <p><strong>注意事项</strong>：</p> 
 <ol><li>每个成员变量在初始化列表中只能出现一次。</li><li>以下成员必须在初始化列表中初始化： 
   <ul><li>引用类型成员变量</li><li><code>const</code> 成员变量</li><li>自定义类型成员变量（如果该类没有默认构造函数）</li></ul></li></ol> 
</blockquote> 
<p><strong>示例代码：</strong></p> 
<pre><code>class MyClass {
public:
    const int x;
    int &amp;y;
    MyClass(int a, int &amp;b) : x(a), y(b) {}  // 必须在初始化列表中初始化
};
</code></pre> 
<p>在这段代码中，<code>const int x</code> 和 <code>int &amp;y</code> 必须在初始化列表中进行初始化，因为 <code>const</code> 成员变量和引用类型成员变量在对象创建时就需要确定其初始值。</p> 
<p><strong><span style="background-color:#ffd900;">总结</span></strong><span style="background-color:#ffd900;">：尽量使用初始化列表，因为它对自定义类型成员变量更高效。</span></p> 
<h3 id="1.3%20explicit%20%E5%85%B3%E9%94%AE%E5%AD%97"><span style="color:#38d8f0;">1.3 <code>explicit</code> 关键字</span></h3> 
<p>构造函数不仅可以用来创建对象，还可以用来进行类型转换。对于只有一个参数的构造函数，如果不使用 <code>explicit</code> 关键字，编译器会自动进行隐式类型转换。</p> 
<p><strong>简单理解</strong>：假设有一个银行系统，你有一个账户类。如果允许隐式转换，就像允许陌生人随意把你的银行账号转换成他们的账户，这很危险。所以我们需要 <code>explicit</code> 关键字来禁止这种转换。</p> 
<p><strong>示例代码：</strong></p> 
<pre><code>class MyClass {
public:
    int x;
    explicit MyClass(int value) : x(value) {}  // 使用 explicit 关键字
};

void func(MyClass obj) {
    // do something
}

int main() {
    MyClass obj1(10);  // 正常调用构造函数
    // MyClass obj2 = 10;  // 错误，explicit 禁止隐式转换
    // func(20);  // 错误，explicit 禁止隐式转换
    return 0;
}
</code></pre> 
<p>在上面的代码中，<code>explicit</code> 关键字禁止了构造函数的隐式转换，这样可以避免潜在的错误和提高代码的可读性。</p> 
<p><strong><span style="background-color:#ffd900;">总结</span></strong><span style="background-color:#ffd900;">：使用 </span><code><span style="background-color:#ffd900;">explicit</span></code><span style="background-color:#ffd900;"> 关键字可以防止构造函数被用于隐式转换，确保代码的安全性和可读性。</span></p> 
<h2 id="2.%20Static%E6%88%90%E5%91%98"><span style="color:#4da8ee;">2. Static成员</span></h2> 
<h3 id="2.1%20%E6%A6%82%E5%BF%B5"><span style="color:#38d8f0;">2.1 概念</span></h3> 
<p>在C++中，声明为<code>static</code>的类成员称为类的静态成员。静态成员分为静态成员变量和静态成员函数。</p> 
<ul><li><strong>静态成员变量</strong>：用<code>static</code>修饰的成员变量。</li><li><strong>静态成员函数</strong>：用<code>static</code>修饰的成员函数。</li></ul> 
<p><strong>简单理解</strong>：静态成员就像学校里的公共设施，比如学校的大门（静态成员变量）和学校的公告栏（静态成员函数），它们是所有学生（类的对象）共享的，而不是某个学生独有的。</p> 
<p><strong>初始化</strong>：静态成员变量必须在类外进行初始化。</p> 
<p><strong>面试题</strong>：实现一个类，计算程序中创建了多少个类对象。</p> 
<p><strong>示例代码</strong>：</p> 
<pre><code>#include &lt;iostream&gt;
using namespace std;

class MyClass {
public:
    static int count;  // 静态成员变量声明

    MyClass() {
        count++;  // 每创建一个对象，count加1
    }

    // 静态成员函数
    static int getCount() {
        return count;
    }
};

// 静态成员变量在类外定义并初始化
int MyClass::count = 0;

int main() {
    MyClass obj1;
    MyClass obj2;
    MyClass obj3;
    cout &lt;&lt; "Created objects: " &lt;&lt; MyClass::getCount() &lt;&lt; endl;
    return 0;
}
</code></pre> 
<p>在这段代码中，<code>MyClass</code>类的静态成员变量<code>count</code>记录了创建的对象数量，每创建一个对象，<code>count</code>就加1。静态成员函数<code>getCount</code>返回当前的对象数量。</p> 
<h3 id="2.2%20%E7%89%B9%E6%80%A7"><span style="color:#38d8f0;">2.2 特性</span></h3> 
<blockquote> 
 <ol><li><strong>静态成员为所有类对象共享</strong>：静态成员变量存放在静态区，不属于某个具体的对象。</li><li><strong>静态成员变量必须在类外定义</strong>：定义时不添加<code>static</code>关键字，类中只是声明。</li><li><strong>访问静态成员</strong>：静态成员可以通过<code>类名::静态成员</code>或<code>对象.静态成员</code>访问。</li><li><strong>静态成员函数没有<code>this</code>指针</strong>：不能访问任何非静态成员。</li><li><strong>静态成员受访问限定符限制</strong>：静态成员同样受<code>public</code>、<code>protected</code>、<code>private</code>访问限定符的限制。</li></ol> 
</blockquote> 
<p><strong>示例代码</strong>：</p> 
<pre><code>class MyClass {
public:
    static int staticVar;  // 静态成员变量声明
    int nonStaticVar;      // 非静态成员变量

    static void staticFunc() {
        // 静态成员函数不能访问非静态成员
        // cout &lt;&lt; nonStaticVar;  // 错误
        cout &lt;&lt; staticVar;  // 正确
    }

    void nonStaticFunc() {
        cout &lt;&lt; staticVar;  // 非静态成员函数可以访问静态成员
        cout &lt;&lt; nonStaticVar;  // 非静态成员函数可以访问非静态成员
    }
};

// 静态成员变量定义
int MyClass::staticVar = 0;
</code></pre> 
<p><strong>问题解答</strong>：</p> 
<p><strong>1.静态成员函数可以调用非静态成员函数吗？</strong> 不可以。静态成员函数没有<code>this</code>指针，所以不能访问类的非静态成员（包括非静态成员函数）。</p> 
<p><strong>示例代码</strong>：</p> 
<pre><code>class MyClass {
public:
    static void staticFunc() {
        // nonStaticFunc();  // 错误，静态成员函数不能调用非静态成员函数
    }

    void nonStaticFunc() {
        cout &lt;&lt; "Non-static member function called." &lt;&lt; endl;
    }
};
</code></pre> 
<p><strong>2.非静态成员函数可以调用类的静态成员函数吗？</strong> 可以。非静态成员函数可以访问类的所有成员，包括静态成员。</p> 
<p><strong>示例代码</strong>：</p> 
<pre><code>class MyClass {
public:
    static void staticFunc() {
        cout &lt;&lt; "Static member function called." &lt;&lt; endl;
    }

    void nonStaticFunc() {
        staticFunc();  // 非静态成员函数可以调用静态成员函数
    }
};
</code></pre> 
<h2 id="3.%20%E5%8F%8B%E5%85%83"><span style="color:#4da8ee;">3. 友元</span></h2> 
<p>友元提供了一种特殊的机制，可以让一个类允许另一个类或函数访问其私有或受保护的成员。虽然友元增加了便利性，但也会破坏封装性，增加代码耦合度，因此使用时需谨慎。</p> 
<h3 id="3.1%20%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span style="color:#38d8f0;">3.1 友元函数</span></h3> 
<p><strong>问题描述</strong>：在重载 <code>operator&lt;&lt;</code> 时，无法将其重载为成员函数，因为 <code>cout</code> 作为输出流对象和 <code>this</code> 指针会竞争第一个参数的位置。为了使 <code>cout</code> 成为第一个参数，我们需要将 <code>operator&lt;&lt;</code> 重载为全局函数。但全局函数不能直接访问类的私有成员，这时就需要友元函数来解决这个问题。</p> 
<blockquote> 
 <p><strong>友元函数的特点</strong>：</p> 
 <ol><li>可以访问类的私有和保护成员，但不属于类的成员函数。</li><li>不能用 <code>const</code> 修饰。</li><li>可以在类定义的任何地方声明，不受类访问限定符限制。</li><li>一个函数可以是多个类的友元函数。</li><li>友元函数的调用与普通函数的调用相同。</li></ol> 
</blockquote> 
<p><strong>示例代码</strong>：</p> 
<pre><code>#include &lt;iostream&gt;
using namespace std;

class MyClass {
private:
    int value;

public:
    MyClass(int v) : value(v) {}

    // 声明友元函数
    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const MyClass&amp; obj);
};

// 定义友元函数
ostream&amp; operator&lt;&lt;(ostream&amp; os, const MyClass&amp; obj) {
    os &lt;&lt; obj.value;
    return os;
}

int main() {
    MyClass obj(42);
    cout &lt;&lt; obj &lt;&lt; endl;  // 输出: 42
    return 0;
}
</code></pre> 
<p>在上面的代码中，<code>operator&lt;&lt;</code> 被定义为友元函数，因此它可以访问 <code>MyClass</code> 类的私有成员 <code>value</code>。</p> 
<h3 id="3.2%20%E5%8F%8B%E5%85%83%E7%B1%BB"><span style="color:#38d8f0;">3.2 友元类</span></h3> 
<p>友元类是一种类的所有成员函数都可以访问另一个类的私有和保护成员的机制。</p> 
<blockquote> 
 <p><strong>特点</strong>：</p> 
 <ol><li>友元关系是单向的，不具有交换性。例如，如果 <code>A</code> 类是 <code>B</code> 类的友元，那么 <code>B</code> 类可以访问 <code>A</code> 类的私有成员，但反过来 <code>A</code> 类不能访问 <code>B</code> 类的私有成员。</li><li>友元关系不能传递。如果 <code>B</code> 是 <code>A</code> 的友元，而 <code>C</code> 是 <code>B</code> 的友元，这并不意味着 <code>C</code> 是 <code>A</code> 的友元。</li><li>友元关系不能继承。</li></ol> 
</blockquote> 
<p><strong>示例代码</strong>：</p> 
<pre><code>#include &lt;iostream&gt;
using namespace std;

class Date;

class Time {
private:
    int hour;
    int minute;

public:
    Time(int h, int m) : hour(h), minute(m) {}

    // 声明Date类为友元类
    friend class Date;
};

class Date {
private:
    int day;
    int month;
    int year;

public:
    Date(int d, int m, int y) : day(d), month(m), year(y) {}

    void displayTime(const Time&amp; t) {
        // 访问Time类的私有成员
        cout &lt;&lt; "Time: " &lt;&lt; t.hour &lt;&lt; ":" &lt;&lt; t.minute &lt;&lt; endl;
    }
};

int main() {
    Time t(10, 30);
    Date d(1, 5, 2023);
    d.displayTime(t);  // 输出: Time: 10:30
    return 0;
}
</code></pre> 
<p>在上面的代码中，<code>Date</code> 类被声明为 <code>Time</code> 类的友元类，因此 <code>Date</code> 类的成员函数可以访问 <code>Time</code> 类的私有成员。</p> 
<h3 id="3.3%E6%80%BB%E7%BB%93%EF%BC%9A"><span style="color:#38d8f0;"><strong>3.3总结</strong>：</span></h3> 
<blockquote> 
 <ul><li>友元函数和友元类允许访问私有和保护成员，但要谨慎使用，因为这会增加代码的耦合性。</li><li>友元关系是单向的，不可传递。</li><li>使用友元可以解决一些特殊情况下的访问权限问题，如重载运算符等。</li></ul> 
</blockquote> 
<p></p> 
<h2 id="4.%20%E5%86%85%E9%83%A8%E7%B1%BB"><span style="color:#4da8ee;">4. 内部类</span></h2> 
<h3 id="1.%E6%A6%82%E5%BF%B5"><span style="color:#38d8f0;">1.概念</span></h3> 
<p><strong>内部类</strong> 是指定义在另一个类内部的类。它是一个独立的类，不属于外部类，不能通过外部类的对象访问其成员。</p> 
<p><strong>简单理解</strong>：就像一家大公司的部门（内部类）和公司（外部类），部门是独立的，但仍然是公司的一部分，外部类对内部类没有特别的访问权限。</p> 
<p><strong>注意事项</strong>：</p> 
<ul><li><span style="background-color:#ffd900;">内部类就像是外部类的友元类，内部类可以通过外部类的对象参数访问外部类的所有成员。</span></li><li><span style="background-color:#ffd900;">外部类对内部类没有友元访问权限，不能访问内部类的私有成员。</span></li></ul> 
<h3 id="2.%E7%89%B9%E6%80%A7"><span style="color:#38d8f0;">2.特性</span></h3> 
<blockquote> 
 <ol><li><strong>内部类的位置</strong>：内部类可以定义在外部类的 <code>public</code>、<code>protected</code> 或 <code>private</code> 区域。</li><li><strong>访问外部类的静态成员</strong>：内部类可以直接访问外部类的静态成员，而不需要外部类的对象或类名。</li><li><strong>大小计算</strong>：<code>sizeof(外部类)</code> 只计算外部类的大小，与内部类无关。</li></ol> 
</blockquote> 
<h4 id="%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A">示例代码：</h4> 
<pre><code>#include &lt;iostream&gt;
using namespace std;

class OuterClass {
private:
    int outerVar;
    static int outerStaticVar;

public:
    OuterClass(int val) : outerVar(val) {}

    // 定义内部类
    class InnerClass {
    public:
        void displayOuter(OuterClass&amp; outer) {
            // 访问外部类的非静态成员需要外部类的对象
            cout &lt;&lt; "Outer class non-static member: " &lt;&lt; outer.outerVar &lt;&lt; endl;
        }

        void displayOuterStatic() {
            // 直接访问外部类的静态成员
            cout &lt;&lt; "Outer class static member: " &lt;&lt; outerStaticVar &lt;&lt; endl;
        }
    };

    // 外部类中的成员函数可以创建内部类的对象
    void createInner() {
        InnerClass inner;
        inner.displayOuter(*this);
        inner.displayOuterStatic();
    }
};

// 定义并初始化外部类的静态成员
int OuterClass::outerStaticVar = 10;

int main() {
    OuterClass outer(5);
    outer.createInner();

    // 外部类对象不能直接访问内部类成员
    // outer.InnerClass inner;  // 错误

    // 创建内部类对象
    OuterClass::InnerClass inner;
    inner.displayOuter(outer);
    inner.displayOuterStatic();

    return 0;
}
</code></pre> 
<h4 id="%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90">代码分析</h4> 
<ol><li><strong>内部类的位置</strong>：<code>InnerClass</code> 定义在 <code>OuterClass</code> 的 <code>public</code> 区域内，可以访问外部类的静态和非静态成员。</li><li><strong>访问外部类的静态成员</strong>：<code>InnerClass</code> 中的 <code>displayOuterStatic</code> 函数直接访问 <code>OuterClass</code> 的静态成员 <code>outerStaticVar</code>。</li><li><strong>访问外部类的非静态成员</strong>：<code>displayOuter</code> 函数通过 <code>OuterClass</code> 的对象参数 <code>outer</code> 访问其非静态成员 <code>outerVar</code>。</li></ol> 
<h3 id="3.%E6%80%BB%E7%BB%93"><span style="color:#38d8f0;">3.总结</span></h3> 
<blockquote> 
 <ul><li><strong>内部类</strong> 是独立的类，可以定义在外部类的任何访问区域。</li><li>内部类可以直接访问外部类的静态成员，不需要外部类的对象或类名。</li><li>内部类可以通过外部类的对象参数访问外部类的非静态成员。</li><li>外部类不能访问内部类的私有成员，内部类也不会影响外部类的大小计算。</li></ul> 
</blockquote> 
<h2 id="5.%E5%86%8D%E6%AC%A1%E7%90%86%E8%A7%A3%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span style="color:#4da8ee;">5.再次理解类和对象</span></h2> 
<h3 id="1.%20%E6%8A%BD%E8%B1%A1%E7%8E%B0%E5%AE%9E%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E5%AE%9E%E4%BD%93"><span style="color:#38d8f0;">1. 抽象现实生活中的实体</span></h3> 
<p>在现实生活中，计算机无法直接认识物理世界中的实体，如洗衣机。为了让计算机理解这些实体，我们需要通过面向对象的语言（如C++）对它们进行抽象和描述。</p> 
<p><strong>简单理解</strong>：假设你想让计算机认识洗衣机。首先，你需要在头脑中抽象出洗衣机的属性和功能。比如，洗衣机有颜色、品牌、容量等属性，还有启动、停止、洗涤等功能。</p> 
<h3 id="2.%20%E7%94%A8%E7%B1%BB%E6%8F%8F%E8%BF%B0%E5%AE%9E%E4%BD%93"><span style="color:#38d8f0;">2. 用类描述实体</span></h3> 
<p>一旦你在人为思想层面对洗衣机有了清晰的认识，就需要用某种编程语言（如C++）将这种认识转化为计算机能理解的格式。我们使用“类”来描述洗衣机。</p> 
<p><strong>示例代码</strong>：</p> 
<pre><code>class WashingMachine {
public:
    // 属性
    string color;
    string brand;
    int capacity;

    // 方法
    void start() {
        cout &lt;&lt; "Washing machine started." &lt;&lt; endl;
    }

    void stop() {
        cout &lt;&lt; "Washing machine stopped." &lt;&lt; endl;
    }

    void wash() {
        cout &lt;&lt; "Washing machine is washing clothes." &lt;&lt; endl;
    }
};
</code></pre> 
<p>在上面的代码中，我们定义了一个类 <code>WashingMachine</code>，它包含了洗衣机的属性（颜色、品牌、容量）和方法（启动、停止、洗涤）。</p> 
<h3 id="3.%20%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1"><span style="color:#38d8f0;">3. 实例化对象</span></h3> 
<p>定义了类之后，计算机还不能理解洗衣机是什么。我们需要通过类来实例化具体的洗衣机对象。</p> 
<p><strong>示例代码</strong>：</p> 
<pre><code>int main() {
    // 实例化一个洗衣机对象
    WashingMachine myWasher;

    // 给属性赋值
    myWasher.color = "White";
    myWasher.brand = "LG";
    myWasher.capacity = 7;

    // 调用方法
    myWasher.start();
    myWasher.wash();
    myWasher.stop();

    return 0;
}
</code></pre> 
<p>在这段代码中，我们创建了一个 <code>WashingMachine</code> 对象 <code>myWasher</code>，并为其属性赋值，然后调用其方法来模拟洗衣机的行为。</p> 
<h3 id="4.%20%E6%80%BB%E7%BB%93%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB"><span style="color:#38d8f0;">4. 总结类和对象的关系</span></h3> 
<p><strong>类</strong> 是对某一类实体的抽象和描述。类定义了这些实体具有的属性和方法，形成了一种新的自定义类型。</p> 
<p><strong>对象</strong> 是类的实例，是具体的实体。通过实例化类，我们创建对象，然后可以使用这些对象来模拟现实中的实体。</p> 
<p><strong>现实生活中的模拟</strong>：</p> 
<ul><li><strong>抽象</strong>：你在人为思想层面对洗衣机进行认识，确定它的属性和功能。</li><li><strong>类</strong>：用C++类来描述洗衣机的属性和功能，将这种描述输入计算机中。</li><li><strong>实例化</strong>：通过类实例化具体的洗衣机对象，计算机才真正理解和模拟洗衣机的行为。</li><li><img alt="" height="1024" src="https://images2.imgbox.com/aa/51/dp1GkQkA_o.png" width="1200"></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4833b9e282b1d7d586fe808ab3f809dc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【C&#43;&#43;】string类模拟实现：探索其内部机制</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/822241db0d64180d9887e28aa79c484f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">免费，C&#43;&#43;蓝桥杯等级考试真题--第2级</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>