<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Rust】——所有的模式语法 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/ca269a5ddc5282049ac4b7fde5ad943b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【Rust】——所有的模式语法">
  <meta property="og:description" content="💻博主现有专栏：
C51单片机（STC89C516），c语言，c&#43;&#43;，离散数学，算法设计与分析，数据结构，Python，Java基础，MySQL，linux，基于HTML5的网页设计及应用，Rust（官方文档重点总结），jQuery，前端vue.js，Javaweb开发，Python机器学习等
🥏主页链接：
Y小夜-CSDN博客
目录
🎯匹配字面值
🎯匹配命名变量
🎯多个模式
🎯通过..-=匹配值的范围
🎯解构并分解值
🎃解构结构体
🎃解构枚举
🎃解构嵌套的结构体和枚举
🎃解构结构体和元组
🎯忽略模式中的值
🎃使用_使用忽略整个值
🎃使用嵌套的_忽略部分值
🎃通过在名字前以一个_开头来忽略未使用的变量
🎃用..忽略剩余值
🎯匹配守卫提供的额外条件
🎯@绑定
🎯匹配字面值 可以直接匹配字面值模式。
let x = 1; match x { 1 =&gt; println!(&#34;one&#34;), 2 =&gt; println!(&#34;two&#34;), 3 =&gt; println!(&#34;three&#34;), _ =&gt; println!(&#34;anything&#34;), } 这段代码会打印 one 因为 x 的值是 1。如果希望代码获得特定的具体值，则该语法很有用。
🎯匹配命名变量 命名变量是匹配任何值的不可反驳模式，这在之前已经使用过数次。然而当其用于 match 表达式时情况会有些复杂。因为 match 会开始一个新作用域，match 表达式中作为模式的一部分声明的变量会覆盖 match 结构之外的同名变量，与所有变量一样。
let x = Some(5); let y = 10; match x { Some(50) =&gt; println!">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-30T10:42:26+08:00">
    <meta property="article:modified_time" content="2024-06-30T10:42:26+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Rust】——所有的模式语法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><strong>💻博主现有专栏：</strong></p> 
 <p><strong>                C51单片机（STC89C516），c语言，c++，离散数学，算法设计与分析，数据结构，Python，Java基础，MySQL，linux，基于HTML5的网页设计及应用，Rust（官方文档重点总结），jQuery，前端vue.js，Javaweb开发，Python机器学习等<br> 🥏主页链接：</strong></p> 
 <p><strong>                </strong><a href="https://blog.csdn.net/shsjssnn?spm=1000.2115.3001.5343" title="Y小夜-CSDN博客">Y小夜-CSDN博客</a></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%F0%9F%8E%AF%E5%8C%B9%E9%85%8D%E5%AD%97%E9%9D%A2%E5%80%BC-toc" style="margin-left:0px;"><a href="#%F0%9F%8E%AF%E5%8C%B9%E9%85%8D%E5%AD%97%E9%9D%A2%E5%80%BC" rel="nofollow">🎯匹配字面值</a></p> 
<p id="%F0%9F%8E%AF%E5%8C%B9%E9%85%8D%E5%91%BD%E5%90%8D%E5%8F%98%E9%87%8F-toc" style="margin-left:0px;"><a href="#%F0%9F%8E%AF%E5%8C%B9%E9%85%8D%E5%91%BD%E5%90%8D%E5%8F%98%E9%87%8F" rel="nofollow">🎯匹配命名变量</a></p> 
<p id="%F0%9F%8E%AF%E5%A4%9A%E4%B8%AA%E6%A8%A1%E5%BC%8F-toc" style="margin-left:0px;"><a href="#%F0%9F%8E%AF%E5%A4%9A%E4%B8%AA%E6%A8%A1%E5%BC%8F" rel="nofollow">🎯多个模式</a></p> 
<p id="%F0%9F%8E%AF%E9%80%9A%E8%BF%87..-%3D%E5%8C%B9%E9%85%8D%E5%80%BC%E7%9A%84%E8%8C%83%E5%9B%B4-toc" style="margin-left:0px;"><a href="#%F0%9F%8E%AF%E9%80%9A%E8%BF%87..-%3D%E5%8C%B9%E9%85%8D%E5%80%BC%E7%9A%84%E8%8C%83%E5%9B%B4" rel="nofollow">🎯通过..-=匹配值的范围</a></p> 
<p id="%F0%9F%8E%AF%E8%A7%A3%E6%9E%84%E5%B9%B6%E5%88%86%E8%A7%A3%E5%80%BC-toc" style="margin-left:0px;"><a href="#%F0%9F%8E%AF%E8%A7%A3%E6%9E%84%E5%B9%B6%E5%88%86%E8%A7%A3%E5%80%BC" rel="nofollow">🎯解构并分解值</a></p> 
<p id="%F0%9F%8E%83%E8%A7%A3%E6%9E%84%E7%BB%93%E6%9E%84%E4%BD%93-toc" style="margin-left:40px;"><a href="#%F0%9F%8E%83%E8%A7%A3%E6%9E%84%E7%BB%93%E6%9E%84%E4%BD%93" rel="nofollow">🎃解构结构体</a></p> 
<p id="%F0%9F%8E%83%E8%A7%A3%E6%9E%84%E6%9E%9A%E4%B8%BE-toc" style="margin-left:40px;"><a href="#%F0%9F%8E%83%E8%A7%A3%E6%9E%84%E6%9E%9A%E4%B8%BE" rel="nofollow">🎃解构枚举</a></p> 
<p id="%F0%9F%8E%83%E8%A7%A3%E6%9E%84%E5%B5%8C%E5%A5%97%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%9E%9A%E4%B8%BE-toc" style="margin-left:0px;"><a href="#%F0%9F%8E%83%E8%A7%A3%E6%9E%84%E5%B5%8C%E5%A5%97%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%9E%9A%E4%B8%BE" rel="nofollow">🎃解构嵌套的结构体和枚举</a></p> 
<p id="%F0%9F%8E%83%E8%A7%A3%E6%9E%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%85%83%E7%BB%84-toc" style="margin-left:40px;"><a href="#%F0%9F%8E%83%E8%A7%A3%E6%9E%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%85%83%E7%BB%84" rel="nofollow">🎃解构结构体和元组</a></p> 
<p id="%F0%9F%8E%AF%E5%BF%BD%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%80%BC-toc" style="margin-left:0px;"><a href="#%F0%9F%8E%AF%E5%BF%BD%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%80%BC" rel="nofollow">🎯忽略模式中的值</a></p> 
<p id="%F0%9F%8E%83%E4%BD%BF%E7%94%A8_%E4%BD%BF%E7%94%A8%E5%BF%BD%E7%95%A5%E6%95%B4%E4%B8%AA%E5%80%BC-toc" style="margin-left:40px;"><a href="#%F0%9F%8E%83%E4%BD%BF%E7%94%A8_%E4%BD%BF%E7%94%A8%E5%BF%BD%E7%95%A5%E6%95%B4%E4%B8%AA%E5%80%BC" rel="nofollow">🎃使用_使用忽略整个值</a></p> 
<p id="%F0%9F%8E%83%E4%BD%BF%E7%94%A8%E5%B5%8C%E5%A5%97%E7%9A%84_%E5%BF%BD%E7%95%A5%E9%83%A8%E5%88%86%E5%80%BC-toc" style="margin-left:40px;"><a href="#%F0%9F%8E%83%E4%BD%BF%E7%94%A8%E5%B5%8C%E5%A5%97%E7%9A%84_%E5%BF%BD%E7%95%A5%E9%83%A8%E5%88%86%E5%80%BC" rel="nofollow">🎃使用嵌套的_忽略部分值</a></p> 
<p id="%F0%9F%8E%83%E9%80%9A%E8%BF%87%E5%9C%A8%E5%90%8D%E5%AD%97%E5%89%8D%E4%BB%A5%E4%B8%80%E4%B8%AA_%E5%BC%80%E5%A4%B4%E6%9D%A5%E5%BF%BD%E7%95%A5%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%9A%84%E5%8F%98%E9%87%8F-toc" style="margin-left:40px;"><a href="#%F0%9F%8E%83%E9%80%9A%E8%BF%87%E5%9C%A8%E5%90%8D%E5%AD%97%E5%89%8D%E4%BB%A5%E4%B8%80%E4%B8%AA_%E5%BC%80%E5%A4%B4%E6%9D%A5%E5%BF%BD%E7%95%A5%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%9A%84%E5%8F%98%E9%87%8F" rel="nofollow">🎃通过在名字前以一个_开头来忽略未使用的变量</a></p> 
<p id="%F0%9F%8E%83%E7%94%A8..%E5%BF%BD%E7%95%A5%E5%89%A9%E4%BD%99%E5%80%BC-toc" style="margin-left:40px;"><a href="#%F0%9F%8E%83%E7%94%A8..%E5%BF%BD%E7%95%A5%E5%89%A9%E4%BD%99%E5%80%BC" rel="nofollow">🎃用..忽略剩余值</a></p> 
<p id="%F0%9F%8E%AF%E5%8C%B9%E9%85%8D%E5%AE%88%E5%8D%AB%E6%8F%90%E4%BE%9B%E7%9A%84%E9%A2%9D%E5%A4%96%E6%9D%A1%E4%BB%B6-toc" style="margin-left:0px;"><a href="#%F0%9F%8E%AF%E5%8C%B9%E9%85%8D%E5%AE%88%E5%8D%AB%E6%8F%90%E4%BE%9B%E7%9A%84%E9%A2%9D%E5%A4%96%E6%9D%A1%E4%BB%B6" rel="nofollow">🎯匹配守卫提供的额外条件</a></p> 
<p id="%F0%9F%8E%AF%40%E7%BB%91%E5%AE%9A-toc" style="margin-left:0px;"><a href="#%F0%9F%8E%AF%40%E7%BB%91%E5%AE%9A" rel="nofollow">🎯@绑定</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%F0%9F%8E%AF%E5%8C%B9%E9%85%8D%E5%AD%97%E9%9D%A2%E5%80%BC">🎯匹配字面值</h2> 
<blockquote> 
 <p>可以直接匹配字面值模式。</p> 
 <pre><code class="language-rust">    let x = 1;

    match x {
        1 =&gt; println!("one"),
        2 =&gt; println!("two"),
        3 =&gt; println!("three"),
        _ =&gt; println!("anything"),
    }
</code></pre> 
 <p>这段代码会打印 <code>one</code> 因为 <code>x</code> 的值是 1。如果希望代码获得特定的具体值，则该语法很有用。</p> 
</blockquote> 
<h2 id="%F0%9F%8E%AF%E5%8C%B9%E9%85%8D%E5%91%BD%E5%90%8D%E5%8F%98%E9%87%8F">🎯匹配命名变量</h2> 
<blockquote> 
 <p>        命名变量是匹配任何值的不可反驳模式，这在之前已经使用过数次。然而当其用于 <code>match</code> 表达式时情况会有些复杂。因为 <code>match</code> 会开始一个新作用域，<code>match</code> 表达式中作为模式的一部分声明的变量会覆盖 <code>match</code> 结构之外的同名变量，与所有变量一样。</p> 
 <pre><code class="language-rust">    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!("Got 50"),
        Some(y) =&gt; println!("Matched, y = {y}"),
        _ =&gt; println!("Default case, x = {:?}", x),
    }

    println!("at the end: x = {:?}, y = {y}", x);
</code></pre> 
 <p>        让我们看看当 <code>match</code> 语句运行的时候发生了什么。第一个匹配分支的模式并不匹配 <code>x</code> 中定义的值，所以代码继续执行。</p> 
 <p>        第二个匹配分支中的模式引入了一个新变量 <code>y</code>，它会匹配任何 <code>Some</code> 中的值。因为我们在 <code>match</code> 表达式的新作用域中，这是一个新变量，而不是开头声明为值 10 的那个 <code>y</code>。这个新的 <code>y</code> 绑定会匹配任何 <code>Some</code> 中的值，在这里是 <code>x</code> 中的值。因此这个 <code>y</code> 绑定了 <code>x</code> 中 <code>Some</code> 内部的值。这个值是 5，所以这个分支的表达式将会执行并打印出 <code>Matched, y = 5</code>。</p> 
 <p>        如果 <code>x</code> 的值是 <code>None</code> 而不是 <code>Some(5)</code>，头两个分支的模式不会匹配，所以会匹配下划线。这个分支的模式中没有引入变量 <code>x</code>，所以此时表达式中的 <code>x</code> 会是外部没有被覆盖的 <code>x</code>。在这个假想的例子中，<code>match</code> 将会打印 <code>Default case, x = None</code>。</p> 
 <p>        一旦 <code>match</code> 表达式执行完毕，其作用域也就结束了，同理内部 <code>y</code> 的作用域也结束了。最后的 <code>println!</code> 会打印 <code>at the end: x = Some(5), y = 10</code>。</p> 
</blockquote> 
<h2 id="%F0%9F%8E%AF%E5%A4%9A%E4%B8%AA%E6%A8%A1%E5%BC%8F">🎯多个模式</h2> 
<blockquote> 
 <p>        在 <code>match</code> 表达式中，可以使用 <code>|</code> 语法匹配多个模式，它代表 <strong>或</strong>（<em>or</em>）运算符模式。例如，如下代码将 <code>x</code> 的值与匹配分支相比较，第一个分支有 <strong>或</strong> 选项，意味着如果 <code>x</code> 的值匹配此分支的任一个值，它就会运行：</p> 
 <pre><code class="language-rust">    let x = 1;

    match x {
        1 | 2 =&gt; println!("one or two"),
        3 =&gt; println!("three"),
        _ =&gt; println!("anything"),
    }
</code></pre> 
 <p>上面的代码会打印 <code>one or two</code>。</p> 
</blockquote> 
<h2 id="%F0%9F%8E%AF%E9%80%9A%E8%BF%87..-%3D%E5%8C%B9%E9%85%8D%E5%80%BC%E7%9A%84%E8%8C%83%E5%9B%B4">🎯通过..-=匹配值的范围</h2> 
<blockquote> 
 <p><code>  ..=</code> 语法允许你匹配一个闭区间范围内的值。在如下代码中，当模式匹配任何在给定范围内的值时，该分支会执行：</p> 
 <pre><code class="language-rust">    let x = 5;

    match x {
        1..=5 =&gt; println!("one through five"),
        _ =&gt; println!("something else"),
    }
</code></pre> 
 <p>        如果 <code>x</code> 是 1、2、3、4 或 5，第一个分支就会匹配。这个语法在匹配多个值时相比使用 <code>|</code> 运算符来表达相同的意思更为方便；如果使用 <code>|</code> 则不得不指定 <code>1 | 2 | 3 | 4 | 5</code>。相反指定范围就简短的多，特别是在希望匹配比如从 1 到 1000 的数字的时候！</p> 
 <p>        编译器会在编译时检查范围不为空，而 <code>char</code> 和数字值是 Rust 仅有的可以判断范围是否为空的类型，所以范围只允许用于数字或 <code>char</code> 值。</p> 
 <pre><code class="language-rust">    let x = 'c';

    match x {
        'a'..='j' =&gt; println!("early ASCII letter"),
        'k'..='z' =&gt; println!("late ASCII letter"),
        _ =&gt; println!("something else"),
    }
</code></pre> 
</blockquote> 
<h2 id="%F0%9F%8E%AF%E8%A7%A3%E6%9E%84%E5%B9%B6%E5%88%86%E8%A7%A3%E5%80%BC">🎯解构并分解值</h2> 
<h3 id="%F0%9F%8E%83%E8%A7%A3%E6%9E%84%E7%BB%93%E6%9E%84%E4%BD%93">🎃解构结构体</h3> 
<blockquote> 
 <p>有两个字段 <code>x</code> 和 <code>y</code> 的结构体 <code>Point</code>，可以通过带有模式的 <code>let</code> 语句将其分解：</p> 
 <pre><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}</code></pre> 
 <p>        这段代码创建了变量 <code>a</code> 和 <code>b</code> 来匹配结构体 <code>p</code> 中的 <code>x</code> 和 <code>y</code> 字段。这个例子展示了模式中的变量名不必与结构体中的字段名一致。不过通常希望变量名与字段名一致以便于理解变量来自于哪些字段。因为变量名匹配字段名是常见的，同时因为 <code>let Point { x: x, y: y } = p;</code> 包含了很多重复，所以对于匹配结构体字段的模式存在简写：只需列出结构体字段的名称，则模式创建的变量会有相同的名称。</p> 
 <pre><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}</code></pre> 
 <p>        这段代码创建了变量 <code>x</code> 和 <code>y</code>，与变量 <code>p</code> 中的 <code>x</code> 和 <code>y</code> 相匹配。其结果是变量 <code>x</code> 和 <code>y</code> 包含结构体 <code>p</code> 中的值。</p> 
 <p>        也可以使用字面值作为结构体模式的一部分进行解构，而不是为所有的字段创建变量。这允许我们测试一些字段为特定值的同时创建其他字段的变量。</p> 
 <p>        展示了一个 <code>match</code> 语句将 <code>Point</code> 值分成了三种情况：直接位于 <code>x</code> 轴上（此时 <code>y = 0</code> 为真）、位于 <code>y</code> 轴上（<code>x = 0</code>）或不在任何轴上的点。</p> 
 <pre><code class="language-rust">fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!("On the x axis at {x}"),
        Point { x: 0, y } =&gt; println!("On the y axis at {y}"),
        Point { x, y } =&gt; {
            println!("On neither axis: ({x}, {y})");
        }
    }
}</code></pre> 
 <p>        第一个分支通过指定字段 <code>y</code> 匹配字面值 <code>0</code> 来匹配任何位于 <code>x</code> 轴上的点。此模式仍然创建了变量 <code>x</code> 以便在分支的代码中使用。</p> 
 <p>        类似的，第二个分支通过指定字段 <code>x</code> 匹配字面值 <code>0</code> 来匹配任何位于 <code>y</code> 轴上的点，并为字段 <code>y</code> 创建了变量 <code>y</code>。第三个分支没有指定任何字面值，所以其会匹配任何其他的 <code>Point</code> 并为 <code>x</code> 和 <code>y</code> 两个字段创建变量。</p> 
 <p>        在这个例子中，值 <code>p</code> 因为其 <code>x</code> 包含 0 而匹配第二个分支，因此会打印出 <code>On the y axis at 7</code>。</p> 
 <p>        记住 <code>match</code> 表达式一旦找到一个匹配的模式就会停止检查其它分支，所以即使 <code>Point { x: 0, y: 0}</code> 在 <code>x</code> 轴上也在 <code>y</code> 轴上，这些代码也只会打印 <code>On the x axis at 0</code>。</p> 
</blockquote> 
<h3 id="%F0%9F%8E%83%E8%A7%A3%E6%9E%84%E6%9E%9A%E4%B8%BE">🎃解构枚举</h3> 
<blockquote> 
 <p>不过当时没有明确提到解构枚举的模式需要对应枚举所定义的储存数据的方式。</p> 
 <pre><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!("The Quit variant has no data to destructure.");
        }
        Message::Move { x, y } =&gt; {
            println!("Move in the x direction {x} and in the y direction {y}");
        }
        Message::Write(text) =&gt; {
            println!("Text message: {text}");
        }
        Message::ChangeColor(r, g, b) =&gt; {
            println!("Change the color to red {r}, green {g}, and blue {b}",)
        }
    }
}</code></pre> 
 <p>        这段代码会打印出 <code>Change the color to red 0, green 160, and blue 255</code>。尝试改变 <code>msg</code> 的值来观察其他分支代码的运行。</p> 
 <p>        对于像 <code>Message::Quit</code> 这样没有任何数据的枚举成员，不能进一步解构其值。只能匹配其字面值 <code>Message::Quit</code>，因此模式中没有任何变量。</p> 
 <p>        对于像 <code>Message::Move</code> 这样的类结构体枚举成员，可以采用类似于匹配结构体的模式。在成员名称后，使用大括号并列出字段变量以便将其分解以供此分支的代码使用。</p> 
</blockquote> 
<h2 id="%F0%9F%8E%83%E8%A7%A3%E6%9E%84%E5%B5%8C%E5%A5%97%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%9E%9A%E4%B8%BE">🎃解构嵌套的结构体和枚举</h2> 
<blockquote> 
 <p>        目前为止，所有的例子都只匹配了深度为一级的结构体或枚举，不过当然也可以匹配嵌套的项！</p> 
 <pre><code class="language-rust">enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; {
            println!("Change color to red {r}, green {g}, and blue {b}");
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; {
            println!("Change color to hue {h}, saturation {s}, value {v}")
        }
        _ =&gt; (),
    }
}</code></pre> 
 <p><code>  match</code> 表达式第一个分支的模式匹配一个包含 <code>Color::Rgb</code> 枚举成员的 <code>Message::ChangeColor</code> 枚举成员，然后模式绑定了 3 个内部的 <code>i32</code> 值。第二个分支的模式也匹配一个 <code>Message::ChangeColor</code> 枚举成员，但是其内部的枚举会匹配 <code>Color::Hsv</code> 枚举成员。我们可以在一个 <code>match</code> 表达式中指定这些复杂条件，即使会涉及到两个枚举。</p> 
</blockquote> 
<h3 id="%F0%9F%8E%83%E8%A7%A3%E6%9E%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%85%83%E7%BB%84">🎃解构结构体和元组</h3> 
<blockquote> 
 <p>        甚至可以用复杂的方式来混合、匹配和嵌套解构模式。如下是一个复杂结构体的例子，其中结构体和元组嵌套在元组中，并将所有的原始类型解构出来：</p> 
 <pre><code class="language-rust">    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
</code></pre> 
 <p>这将复杂的类型分解成部分组件以便可以单独使用我们感兴趣的值。</p> 
 <p>通过模式解构是一个方便利用部分值片段的手段，比如结构体中每个单独字段的值。</p> 
</blockquote> 
<h2 id="%F0%9F%8E%AF%E5%BF%BD%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%80%BC">🎯忽略模式中的值</h2> 
<blockquote> 
 <p>        有时忽略模式中的一些值是有用的，比如 <code>match</code> 中最后捕获全部情况的分支实际上没有做任何事，但是它确实对所有剩余情况负责。有一些简单的方法可以忽略模式中全部或部分值：使用 <code>_</code> 模式（我们已经见过了），在另一个模式中使用 <code>_</code> 模式，使用一个以下划线开始的名称，或者使用 <code>..</code> 忽略所剩部分的值。让我们来分别探索如何以及为什么要这么做。</p> 
</blockquote> 
<h3 id="%F0%9F%8E%83%E4%BD%BF%E7%94%A8_%E4%BD%BF%E7%94%A8%E5%BF%BD%E7%95%A5%E6%95%B4%E4%B8%AA%E5%80%BC">🎃使用_使用忽略整个值</h3> 
<blockquote> 
 <p>        我们已经使用过下划线作为匹配但不绑定任何值的通配符模式了。虽然这作为 <code>match</code> 表达式最后的分支特别有用，也可以将其用于任意模式，包括函数参数中</p> 
 <pre><code class="language-rust">fn foo(_: i32, y: i32) {
    println!("This code only uses the y parameter: {}", y);
}

fn main() {
    foo(3, 4);
}</code></pre> 
 <p>        这段代码会完全忽略作为第一个参数传递的值 <code>3</code>，并会打印出 <code>This code only uses the y parameter: 4</code>。</p> 
 <p>        大部分情况当你不再需要特定函数参数时，最好修改签名不再包含无用的参数。在一些情况下忽略函数参数会变得特别有用，比如实现 trait 时，当你需要特定类型签名但是函数实现并不需要某个参数时。这样可以避免一个存在未使用的函数参数的编译警告，就跟使用命名参数一样。</p> 
</blockquote> 
<h3 id="%F0%9F%8E%83%E4%BD%BF%E7%94%A8%E5%B5%8C%E5%A5%97%E7%9A%84_%E5%BF%BD%E7%95%A5%E9%83%A8%E5%88%86%E5%80%BC">🎃使用嵌套的_忽略部分值</h3> 
<blockquote> 
 <p>        也可以在一个模式内部使用<code>_</code> 忽略部分值，例如，当只需要测试部分值但在期望运行的代码中没有用到其他部分时。示例 18-18 展示了负责管理设置值的代码。业务需求是用户不允许覆盖现有的自定义设置，但是可以取消设置，也可以在当前未设置时为其提供设置。</p> 
 <pre><code class="language-rust">    let mut setting_value = Some(5);
    let new_setting_value = Some(10);

    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) =&gt; {
            println!("Can't overwrite an existing customized value");
        }
        _ =&gt; {
            setting_value = new_setting_value;
        }
    }

    println!("setting is {:?}", setting_value);
</code></pre> 
 <p>        这段代码会打印出 <code>Can't overwrite an existing customized value</code> 接着是 <code>setting is Some(5)</code>。在第一个匹配分支，我们不需要匹配或使用任一个 <code>Some</code> 成员中的值；重要的部分是需要测试 <code>setting_value</code> 和 <code>new_setting_value</code> 都为 <code>Some</code> 成员的情况。在这种情况，我们打印出为何不改变 <code>setting_value</code>，并且不会改变它。</p> 
 <p>        对于所有其他情况（<code>setting_value</code> 或 <code>new_setting_value</code> 任一为 <code>None</code>），这由第二个分支的 <code>_</code> 模式体现，这时确实希望允许 <code>new_setting_value</code> 变为 <code>setting_value</code>。</p> 
 <pre><code class="language-rust">    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) =&gt; {
            println!("Some numbers: {first}, {third}, {fifth}")
        }
    }
</code></pre> 
 <p>这会打印出 <code>Some numbers: 2, 8, 32</code>，值 4 和 16 会被忽略。</p> 
</blockquote> 
<h3 id="%F0%9F%8E%83%E9%80%9A%E8%BF%87%E5%9C%A8%E5%90%8D%E5%AD%97%E5%89%8D%E4%BB%A5%E4%B8%80%E4%B8%AA_%E5%BC%80%E5%A4%B4%E6%9D%A5%E5%BF%BD%E7%95%A5%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%9A%84%E5%8F%98%E9%87%8F">🎃通过在名字前以一个_开头来忽略未使用的变量</h3> 
<blockquote> 
 <p>        如果你创建了一个变量却不在任何地方使用它，Rust 通常会给你一个警告，因为未使用的变量可能会是个 bug。但是有时创建一个还未使用的变量是有用的，比如你正在设计原型或刚刚开始一个项目。这时你希望告诉 Rust 不要警告未使用的变量，为此可以用下划线作为变量名的开头。示例 18-20 中创建了两个未使用变量，不过当编译代码时只会得到其中一个的警告：</p> 
 <pre><code class="language-rust">fn main() {
    let _x = 5;
    let y = 10;
}</code></pre> 
 <p>这里得到了警告说未使用变量 <code>y</code>，不过没有警告说使用 <code>_x</code>。</p> 
 <p>        注意，只使用 <code>_</code> 和使用以下划线开头的名称有些微妙的不同：比如 <code>_x</code> 仍会将值绑定到变量，而 <code>_</code> 则完全不会绑定。为了展示这个区别的意义：</p> 
 <pre><code class="language-rust">    let s = Some(String::from("Hello!"));

    if let Some(_s) = s {
        println!("found a string");
    }

    println!("{:?}", s);
</code></pre> 
 <p>        我们会得到一个错误，因为 <code>s</code> 的值仍然会移动进 <code>_s</code>，并阻止我们再次使用 <code>s</code>。然而只使用下划线本身，并不会绑定值。</p> 
 <pre><code class="language-rust">    let s = Some(String::from("Hello!"));

    if let Some(_) = s {
        println!("found a string");
    }

    println!("{:?}", s);
</code></pre> 
 <p>上面的代码能很好的运行；因为没有把 <code>s</code> 绑定到任何变量；它没有被移动。</p> 
</blockquote> 
<h3 id="%F0%9F%8E%83%E7%94%A8..%E5%BF%BD%E7%95%A5%E5%89%A9%E4%BD%99%E5%80%BC">🎃用..忽略剩余值</h3> 
<blockquote> 
 <p>        对于有多个部分的值，可以使用 <code>..</code> 语法来只使用特定部分并忽略其它值，同时避免不得不每一个忽略值列出下划线。<code>..</code> 模式会忽略模式中剩余的任何没有显式匹配的值部分。</p> 
 <pre><code class="language-rust">    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } =&gt; println!("x is {}", x),
    }
</code></pre> 
 <p>        这里列出了 <code>x</code> 值，接着仅仅包含了 <code>..</code> 模式。这比不得不列出 <code>y: _</code> 和 <code>z: _</code> 要来得简单，特别是在处理有很多字段的结构体，但只涉及一到两个字段时的情形。</p> 
 <pre><code class="language-rust">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!("Some numbers: {first}, {last}");
        }
    }
}</code></pre> 
 <p>        这里用 <code>first</code> 和 <code>last</code> 来匹配第一个和最后一个值。<code>..</code> 将匹配并忽略中间的所有值。</p> 
 <p>        然而使用 <code>..</code> 必须是无歧义的。如果期望匹配和忽略的值是不明确的，Rust 会报错。、</p> 
 <pre><code class="language-rust">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!("Some numbers: {}", second)
        },
    }
}</code></pre> 
 <p>如果编译上面的例子，会得到下面的错误：</p> 
 <pre><code class="language-rust">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error: `..` can only be used once per tuple pattern
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here

error: could not compile `patterns` due to previous error
</code></pre> 
 <p>        Rust 不可能决定在元组中匹配 <code>second</code> 值之前应该忽略多少个值，以及在之后忽略多少个值。这段代码可能表明我们意在忽略 <code>2</code>，绑定 <code>second</code> 为 <code>4</code>，接着忽略 <code>8</code>、<code>16</code> 和 <code>32</code>；抑或是意在忽略 <code>2</code> 和 <code>4</code>，绑定 <code>second</code> 为 <code>8</code>，接着忽略 <code>16</code> 和 <code>32</code>，以此类推。变量名 <code>second</code> 对于 Rust 来说并没有任何特殊意义，所以会得到编译错误，因为在这两个地方使用 <code>..</code> 是有歧义的。</p> 
</blockquote> 
<h2 id="%F0%9F%8E%AF%E5%8C%B9%E9%85%8D%E5%AE%88%E5%8D%AB%E6%8F%90%E4%BE%9B%E7%9A%84%E9%A2%9D%E5%A4%96%E6%9D%A1%E4%BB%B6">🎯匹配守卫提供的额外条件</h2> 
<blockquote> 
 <p><strong>        匹配守卫</strong>（<em>match guard</em>）是一个指定于 <code>match</code> 分支模式之后的额外 <code>if</code> 条件，它也必须被满足才能选择此分支。匹配守卫用于表达比单独的模式所能允许的更为复杂的情况。</p> 
 <p>        这个条件可以使用模式中创建的变量。示例 18-26 展示了一个 <code>match</code>，其中第一个分支有模式 <code>Some(x)</code> 还有匹配守卫 <code>if x % 2 == 0</code> (当 <code>x</code> 是偶数的时候为真)：</p> 
 <pre><code class="language-rust">    let num = Some(4);

    match num {
        Some(x) if x % 2 == 0 =&gt; println!("The number {} is even", x),
        Some(x) =&gt; println!("The number {} is odd", x),
        None =&gt; (),
    }
</code></pre> 
 <p>        上例会打印出 <code>The number 4 is even</code>。当 <code>num</code> 与模式中第一个分支比较时，因为 <code>Some(4)</code> 匹配 <code>Some(x)</code> 所以可以匹配。接着匹配守卫检查 <code>x</code> 除以 <code>2</code> 的余数是否等于 <code>0</code>，因为它等于 <code>0</code>，所以第一个分支被选择。</p> 
 <p>        相反如果 <code>num</code> 为 <code>Some(5)</code>，因为 <code>5</code> 除以 <code>2</code> 的余数是 <code>1</code> 不等于 <code>0</code> 所以第一个分支的匹配守卫为假。接着 Rust 会前往第二个分支，这次匹配因为它没有匹配守卫所以会匹配任何 <code>Some</code> 成员。</p> 
 <p>        无法在模式中表达类似 <code>if x % 2 == 0</code> 的条件，所以通过匹配守卫提供了表达类似逻辑的能力。这种替代表达方式的缺点是，编译器不会尝试为包含匹配守卫的模式检查穷尽性。</p> 
</blockquote> 
<h2 id="%F0%9F%8E%AF%40%E7%BB%91%E5%AE%9A">🎯@绑定</h2> 
<blockquote> 
 <p><em>        at</em> 运算符（<code>@</code>）允许我们在创建一个存放值的变量的同时测试其值是否匹配模式。示例 18-29 展示了一个例子，这里我们希望测试 <code>Message::Hello</code> 的 <code>id</code> 字段是否位于 <code>3..=7</code> 范围内，同时也希望能将其值绑定到 <code>id_variable</code> 变量中以便此分支相关联的代码可以使用它。可以将 <code>id_variable</code> 命名为 <code>id</code>，与字段同名，不过出于示例的目的这里选择了不同的名称。</p> 
 <pre><code class="language-rust">    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } =&gt; println!("Found an id in range: {}", id_variable),
        Message::Hello { id: 10..=12 } =&gt; {
            println!("Found an id in another range")
        }
        Message::Hello { id } =&gt; println!("Found some other id: {}", id),
    }
</code></pre> 
 <p>        上例会打印出 <code>Found an id in range: 5</code>。通过在 <code>3..=7</code> 之前指定 <code>id_variable @</code>，我们捕获了任何匹配此范围的值并同时测试其值匹配这个范围模式。</p> 
 <p>        第二个分支只在模式中指定了一个范围，分支相关代码没有一个包含 <code>id</code> 字段实际值的变量。<code>id</code> 字段的值可以是 10、11 或 12，不过这个模式的代码并不知情也不能使用 <code>id</code> 字段中的值，因为没有将 <code>id</code> 值保存进一个变量。</p> 
 <p>        最后一个分支指定了一个没有范围的变量，此时确实拥有可以用于分支代码的变量 <code>id</code>，因为这里使用了结构体字段简写语法。不过此分支中没有像头两个分支那样对 <code>id</code> 字段的值进行测试：任何值都会匹配此分支。</p> 
</blockquote> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3a3037b546154ff2afa8861f963ddd5c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python 学习之标准库（二）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/92a14ce0784323d37f7deddccd3e77c1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">玩转springboot之springboot定制嵌入式的servlet</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>