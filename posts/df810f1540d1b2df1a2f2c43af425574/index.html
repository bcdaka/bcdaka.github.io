<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;第二十二弹---vector深度剖析及模拟实现(下) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/df810f1540d1b2df1a2f2c43af425574/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C&#43;&#43;第二十二弹---vector深度剖析及模拟实现(下)">
  <meta property="og:description" content="✨个人主页： 熬夜学编程的小林
💗系列专栏： 【C语言详解】 【数据结构详解】【C&#43;&#43;详解】
目录
1、容量操作
2、内容修改操作
3、打印函数
4、迭代器失效
4.1、什么是迭代器失效
4.2、哪些操作会引起迭代器失效
总结
1、容量操作 size()、capacity()
获取容器的有效数据个数(连续内存空间的指针相减计算的就是间隔的元素个数)和分配给当前空间的大小，以元素个数表示。
size_t size() const { return _finish - _start; } size_t capacity() const { return _endofstorage - _start; } reserve(size_t n)
扩容。如果n大于当前容量则扩容，小于等于当前容量则不处理。
void reserve(size_t n)//将容量个数扩大到n { if (n &gt; capacity())//大于容量才扩容 { size_t old_size = size(); T* tmp = new T[n]; memcpy(tmp, _start, sizeof(T) * size()); delete[] _start;//加[] _start = tmp; //_finish = _start &#43; size();//_start的地址改变了 size()结果变化 _finish = _start &#43; old_size; _endofstorage = _start &#43; n; } } 这里我们开空间完成的是一个深拷贝的过程，用 memcpy 将旧数组中的数据拷贝到新数组，但是memcpy 在这里基于字节的拷贝，即浅拷贝，那么，如果我们vector实例化为string类，这里string类进行浅拷贝会涉及到二次释放等问题。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-31T09:46:48+08:00">
    <meta property="article:modified_time" content="2024-05-31T09:46:48+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;第二十二弹---vector深度剖析及模拟实现(下)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" src="https://images2.imgbox.com/c3/39/Gh6uWWiN_o.jpg"></p> 
<p style="text-align:center;"> ✨<span style="color:#956fe7;">个人主页：</span><a href="https://blog.csdn.net/2201_75584283?spm=1011.2415.3001.5343" title=" 熬夜学编程的小林"> 熬夜学编程的小林</a></p> 
<p style="text-align:center;">💗<span style="color:#fe2c24;">系列专栏：</span> <a href="https://blog.csdn.net/2201_75584283/category_12556736.html" title="【C语言详解】">【C语言详解】</a> <a href="https://blog.csdn.net/2201_75584283/category_12556751.html" title="【数据结构详解】">【数据结构详解】</a><a href="https://blog.csdn.net/2201_75584283/category_12577595.html?spm=1001.2014.3001.5482" title="【C++详解】">【C++详解】</a></p> 
<h2></h2> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%C2%A01%E3%80%81%E5%AE%B9%E9%87%8F%E6%93%8D%E4%BD%9C-toc" style="margin-left:0px;"><a href="#%C2%A01%E3%80%81%E5%AE%B9%E9%87%8F%E6%93%8D%E4%BD%9C" rel="nofollow">1、容量操作</a></p> 
<p id="2%E3%80%81%E5%86%85%E5%AE%B9%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C-toc" style="margin-left:0px;"><a href="#2%E3%80%81%E5%86%85%E5%AE%B9%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C" rel="nofollow">2、内容修改操作</a></p> 
<p id="3%E3%80%81%E6%89%93%E5%8D%B0%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#3%E3%80%81%E6%89%93%E5%8D%B0%E5%87%BD%E6%95%B0" rel="nofollow">3、打印函数</a></p> 
<p id="4%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88-toc" style="margin-left:0px;"><a href="#4%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88" rel="nofollow">4、迭代器失效</a></p> 
<p id="4.1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88-toc" style="margin-left:40px;"><a href="#4.1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88" rel="nofollow">4.1、什么是迭代器失效</a></p> 
<p id="4.2%E3%80%81%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%BC%9A%E5%BC%95%E8%B5%B7%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88-toc" style="margin-left:40px;"><a href="#4.2%E3%80%81%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%BC%9A%E5%BC%95%E8%B5%B7%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88" rel="nofollow">4.2、哪些操作会引起迭代器失效</a></p> 
<p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%C2%A01%E3%80%81%E5%AE%B9%E9%87%8F%E6%93%8D%E4%BD%9C">1、容量操作</h2> 
<p><span style="background-color:#38d8f0;">size()、capacity()</span></p> 
<blockquote> 
 <p><span style="color:#0d0016;">获取容器的</span><strong><span style="color:#0d0016;"><span style="background-color:#fbd4d0;">有效数据个数(连续内存空间的指针相减计算的就是间隔的元素个数)</span></span></strong><span style="color:#0d0016;">和</span><strong><span style="color:#0d0016;"><span style="background-color:#fbd4d0;">分配给当前空间的大小</span>，<span style="background-color:#f9eda6;">以元素个数表示。</span></span></strong></p> 
</blockquote> 
<pre><code>size_t size() const
{
	return _finish - _start;
}
size_t capacity() const
{
	return _endofstorage - _start;
}</code></pre> 
<p><span style="background-color:#38d8f0;"> reserve(size_t n)</span></p> 
<blockquote> 
 <p><strong><span style="color:#0d0016;"><span style="background-color:#fbd4d0;">扩容</span>。如果<span style="background-color:#f9eda6;">n大于当前容量则扩容，小于等于当前容量则不处理。</span></span></strong></p> 
</blockquote> 
<pre><code>void reserve(size_t n)//将容量个数扩大到n
{
	if (n &gt; capacity())//大于容量才扩容
	{
		size_t old_size = size();
		T* tmp = new T[n];
		memcpy(tmp, _start, sizeof(T) * size());
		delete[] _start;//加[]
		_start = tmp;
		//_finish = _start + size();//_start的地址改变了 size()结果变化
		_finish = _start + old_size;
		_endofstorage = _start + n;
	}
}</code></pre> 
<blockquote> 
 <p><strong>这里我们开空间完成的是一个深拷贝的过程</strong>，<strong>用 memcpy 将旧数组中的数据拷贝到新数组，但是memcpy 在这里基于字节的拷贝</strong>，即<strong><span style="color:#fe2c24;">浅拷贝</span></strong>，那么，如果我们<span style="color:#efedf6;"><span style="background-color:#9c8ec1;">vector实例化为string类，这里string类进行浅拷贝会涉及到二次释放等问题。</span></span></p> 
</blockquote> 
<p><img alt="" height="507" src="https://images2.imgbox.com/fe/bf/1gOkBTJc_o.png" width="1200"></p> 
<p></p> 
<p><strong><span style="color:#0d0016;">解决办法：</span></strong></p> 
<blockquote> 
 <p><strong>通过一个循环，<span style="background-color:#fbd4d0;">使用赋值操作符(自定义类型会调用赋值操作符重载)逐个拷贝旧数组中的元素到新数组。</span></strong></p> 
</blockquote> 
<pre><code>void reserve(size_t n)//将容量个数扩大到n
{
	if (n &gt; capacity())//大于容量才扩容
	{
		size_t old_size = size();
		T* tmp = new T[n];
		for (size_t i = 0; i &lt; old_size; i++)
		{
			tmp[i] = _start[i];//调用赋值操作符重载，深拷贝
		}
		delete[] _start;//加[]
		_start = tmp;
		//_finish = _start + size();//_start的地址改变了 size()结果变化
		_finish = _start + old_size;
		_endofstorage = _start + n;
	}
}</code></pre> 
<p><img alt="" height="603" src="https://images2.imgbox.com/30/e6/klRm5uHg_o.png" width="1200"></p> 
<p><strong><span style="color:#0d0016;"> 注意：</span></strong></p> 
<p><strong><span style="color:#fe2c24;">需要提前计算原空间的大小，防止后面计算的大小是错误的，因为扩容的时候_start指针会修改指向，而_finish还指向原空间。</span></strong></p> 
<p></p> 
<p><span style="background-color:#38d8f0;">resize(size_t n)</span></p> 
<blockquote> 
 <p><strong><span style="color:#0d0016;"><span style="background-color:#fbd4d0;">调整容器的大小，使其包含n个元素。</span></span></strong></p> 
 <p>如果<span style="background-color:#dad5e9;">n小于当前容器大小</span>，则内容将<span style="background-color:#c7e6ea;">减少到其前n个元素，删除超出的元素（并销毁它们）</span>。</p> 
 <p>如果<span style="background-color:#dad5e9;">n大于当前容器大小</span>，则通过<span style="background-color:#e7fafa;">在末尾插入所需数量的元素来扩展内容，以达到n的大小。</span>如果<span style="background-color:#dad5e9;">指定了val</span>，则<span style="background-color:#e7fafa;">将新元素初始化为val，否则初始化为缺省值。</span></p> 
 <p>如果<span style="background-color:#dad5e9;">n也大于当前容器容量</span>，则自动<span style="background-color:#e7fafa;">重新分配所分配的存储空间。</span></p> 
</blockquote> 
<p></p> 
<pre><code>void resize(size_t n,const T&amp; val=T())//将容量修改为n个，并初始化为val
{
	if (n &gt; capacity())
	{
		//扩容
		reserve(n);
		while (_finish &lt; _start + n)
		{
			*_finish = val;
			++_finish;
		}
	}
	else
	{
		//删除
		_finish = _start + n;//更改_finish位置即可，一般不缩容
	}
}</code></pre> 
<p><span style="color:#0d0016;"><strong>注意：</strong></span></p> 
<p><strong><span style="color:#fe2c24;">当 n 小于当前容量时，只需修改 _finish 指向即可</span></strong><span style="color:#0d0016;">，一般情况不缩容，如需缩容，可以调用<span style="background-color:#ff9900;">shrink_to_fit()</span>缩容函数。</span></p> 
<p></p> 
<h2 id="2%E3%80%81%E5%86%85%E5%AE%B9%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C">2、内容修改操作</h2> 
<p><span style="background-color:#38d8f0;">push_back()</span></p> 
<blockquote> 
 <p><strong><span style="color:#0d0016;"><span style="background-color:#fbd4d0;">尾插数据</span>。即</span><span style="color:#fe2c24;">在_finish位置插入数据</span><span style="color:#0d0016;">，在插入数据之前需要判断空间是否已满。</span></strong></p> 
</blockquote> 
<pre><code>void push_back(const T&amp; val)
{
	if (_finish == _endofstorage)//扩容
	{
		reserve(capacity() == 0 ? 4 : 2 * capacity());
	}
	*_finish = val;
	++_finish;
}</code></pre> 
<p><span style="background-color:#38d8f0;"> pop_back()</span></p> 
<blockquote> 
 <p><strong><span style="color:#0d0016;"><span style="background-color:#fbd4d0;">尾删数据</span>(</span><span style="color:#fe2c24;">有数据才能删</span><span style="color:#0d0016;">)。删除最后一个数据，修改_finish指向即可。</span></strong></p> 
</blockquote> 
<pre><code>void pop_back()
{
	assert(!empty());
	--_finish;
}</code></pre> 
<p><span style="background-color:#38d8f0;">empty()</span></p> 
<blockquote> 
 <p><strong><span style="color:#0d0016;"><span style="background-color:#fbd4d0;">判断容器是否为空</span>(</span><span style="color:#fe2c24;">判断_start与_finish指向是否一致</span><span style="color:#0d0016;">)，为空返回true，否则返回false。 </span></strong></p> 
</blockquote> 
<pre><code>bool empty()
{
	return _start == _finish;
}</code></pre> 
<p><span style="background-color:#38d8f0;">insert() </span></p> 
<blockquote> 
 <p><strong><span style="color:#0d0016;"><span style="background-color:#fbd4d0;">在pos位置插入数据。</span></span></strong></p> 
 <p>1.使用<span style="background-color:#dad5e9;">断言保证在[_start,_finish]区间插入数据</span></p> 
 <p>2<span style="background-color:#dad5e9;">.判断是否需要</span><span style="background-color:#dad5e9;">扩容</span>，扩容则可能出现<strong><span style="color:#fe2c24;">迭代器失效情况</span></strong>，则需要<strong><span style="color:#fe2c24;">提前计算pos 位置与 _start之间的距离。</span></strong></p> 
 <p>3.<span style="background-color:#dad5e9;">将[pos,_finish)之间的数据都向后挪动一步</span>，再pos位置插入数据。</p> 
 <p>4.最后<span style="background-color:#dad5e9;">返回新的pos位置。</span></p> 
</blockquote> 
<pre><code>iterator insert(iterator pos, const T&amp; val)//在pos位置插入val
{
	assert(pos &gt;= _start);
	assert(pos &lt;= _finish);
	//扩容
	if (_finish == _endofstorage)
	{
		size_t len = pos - _start;//标记pos与原数组起点的长度
		reserve(capacity() == 0 ? 4 : 2 * capacity());
		pos = _start + len;//扩容_start的指向修改，pos也需修改
	}
	//移动数据
	iterator it = _finish - 1;
	while (it &gt;= pos)
	{
		*(it + 1) = *it;
		--it;
	}
	//填充数据
	*pos = val;
	++_finish;

    return pos;//返回新的pos位置
}
</code></pre> 
<p><span style="background-color:#38d8f0;"> erase()</span></p> 
<blockquote> 
 <p><strong><span style="color:#0d0016;"><span style="background-color:#fbd4d0;">删除pos位置的数据。</span></span></strong></p> 
 <p>1.使用<span style="background-color:#dad5e9;">断言保证在[_start,_finish)区间删除数据，</span><span style="color:#fe2c24;">此处跟插入不同，不能删除_finsih位置数据</span></p> 
 <p>2.<span style="background-color:#dad5e9;">将[pos + 1,_finish)之间的数据都向前挪动一步。</span></p> 
</blockquote> 
<pre><code>iterator erase(iterator pos)//删除pos位置数
{
	assert(pos &gt;= _start);
	assert(pos &lt; _finish);
	//iterator it = pos;
	iterator it = pos + 1;
	while (it &lt; _finish)
	{
		//*it = *(it + 1);//it = pos; 越界
		*(it - 1) = *it;
		it++;
	}
	--_finish;
	return pos;
}</code></pre> 
<p><strong><span style="color:#fe2c24;">erase 返回值是一个迭代器，指向原来pos位置的下一个位置，即删除操作之后的pos位置。</span></strong></p> 
<p></p> 
<p><span style="background-color:#38d8f0;">push_back()  pop_back()</span></p> 
<blockquote> 
 <p><strong><span style="color:#0d0016;">尾插和尾删函数，使用insert()和erase()函数调用。</span></strong></p> 
</blockquote> 
<pre><code>void push_back(const T&amp; val)
{
	insert(end(), val);//在end()位置插入数据
}

void pop_back()
{
	erase(end() - 1);//删除end()前面位置数据
}
</code></pre> 
<h2 id="3%E3%80%81%E6%89%93%E5%8D%B0%E5%87%BD%E6%95%B0">3、打印函数</h2> 
<p><span style="background-color:#38d8f0;">print_vector()</span></p> 
<blockquote> 
 <p><strong><span style="color:#0d0016;">打印vector容器的数据(</span><span style="color:#fe2c24;">任意类型</span><span style="color:#0d0016;">)。</span></strong></p> 
</blockquote> 
<pre><code>template&lt;class T&gt;//函数模板
void print_vector(const vector&lt;T&gt;&amp; v)
{
	//前面加typename则没有问题，表示iterator是一个类型
	//typename vector&lt;T&gt;::iterator it = v.begin();
	auto it = v.begin();//此处使用auto则可以避免此问题
	while (it != v.end())
	{
		cout &lt;&lt; *it &lt;&lt; " ";
		it++;//指向下一个位置
	}
	cout &lt;&lt; endl;
}</code></pre> 
<p><strong><span style="color:#0d0016;"> 注意：</span></strong></p> 
<p><strong><span style="color:#fe2c24;">显示访问迭代器时，需要在前面加关键字typename保证iterator是一个类型，或者直接使用auto。</span></strong></p> 
<p></p> 
<h2 id="4%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88">4、迭代器失效</h2> 
<h3 id="4.1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88">4.1、什么是迭代器失效</h3> 
<p></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>迭代器的作用</strong>：</span>主要作用就是让算法能够不用关心底层数据结构，其<strong><span style="background-color:#fbd4d0;">底层实际就是一个指针</span></strong>，或者是对指针进行了封装。</p> 
 <p></p> 
 <p><strong><span style="color:#fe2c24;">迭代器失效</span>，实际就是<span style="background-color:#fbd4d0;">迭代器底层对应指针所指向的空间被销毁了</span>，而<span style="background-color:#fbd4d0;">使用一块已经被释放的空间，造成的后果是程序崩溃</span>(即如果继续使用已经失效的迭代器，程序可能会崩溃)。我们可以从以下三步进行分析：</strong></p> 
 <ul><li>[1]<span style="color:#fe2c24;"><strong>迭代器的本质</strong></span>就是<strong>指针</strong>，<strong>迭代器失效就是指针失效</strong>。</li><li>[2]<span style="color:#fe2c24;"><strong>指针失效</strong></span>：<strong>指针指向的空间是非法的</strong>。</li><li>[3]<span style="color:#fe2c24;"><strong>指针指向非法空间</strong></span>：指向了<strong>被释放的空间 </strong>或者 <strong>越界访问 。</strong></li></ul> 
</blockquote> 
<h3 id="4.2%E3%80%81%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%BC%9A%E5%BC%95%E8%B5%B7%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88"><strong>4.2、哪些操作会引起迭代器失效</strong></h3> 
<blockquote> 
 <ol><li><strong>所有可能会引起<span style="color:#fe2c24;">扩容的操作</span>都可能会<span style="background-color:#fbd4d0;">导致迭代器失效。如：resize、reserve、insert、assign、push_back</span>等  --------------  <span style="background-color:#fbd4d0;">野指针引起的迭代器失效</span></strong></li><li><strong><span style="color:#fe2c24;">指定位置的插入和删除</span>都会都可能会<span style="background-color:#fbd4d0;">导致迭代器失效。如: insert 、erase -----------------   迭代器指向的位置意义发生改变</span></strong></li></ol> 
</blockquote> 
<p><strong><span style="color:#0d0016;">注意：</span></strong></p> 
<p><strong><span style="color:#fe2c24;">上述可能会引起迭代器失效的问题，代码中基本已经解决，如果uu们发现解决的有问题可以私信博主喔！！！</span></strong></p> 
<p></p> 
<h2 id="%E6%80%BB%E7%BB%93">总结</h2> 
<p><br> 本篇博客就结束啦，谢谢大家的观看，如果公主少年们有好的建议可以留言喔，谢谢大家啦！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c2b013a60b1f3ced0da9b7f729f4bdbb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">儿童节变身小小音乐家，用ModelArts制作一张AIGC音乐专辑</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fd046b721834cded3575169daf46b989/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Sealos CLI快速部署部署K8s集群</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>