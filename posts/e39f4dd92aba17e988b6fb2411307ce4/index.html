<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【算法/训练】：动态规划（线性DP） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/e39f4dd92aba17e988b6fb2411307ce4/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【算法/训练】：动态规划（线性DP）">
  <meta property="og:description" content="一、路径类 1. 字母收集 思路：
1、预处理
对输入的字符矩阵我们按照要求将其转换为数字分数，由于只能往下和往右走，因此走到（i，j）的位置要就是从（i - 1， j）往下走，或者是从(i，j - 1)的位置往右走，由于我们要使得路程遍历积分最多，则应该从积分多的位置过来，
2、状态表示 dp[i][j] 表示：从[0, 0]出发，到底[i, j]位置，一共有多少分
3、状态转移方程
故（i，j）位置的积分应该为dp[ i ][ j ] = max(dp[ i - 1 ][ j ], dp[ i ][ j - 1 ]) &#43; dp[ i ][ j ];
4、初始化
但是上面仅对于（i &gt;= 1 &amp;&amp; j &gt;= 1）成立，对于第一行和第一列我们应该特殊处理，利用前缀和的知识可以求得，走到第一列的第i个位置最多能拿的积分以及走到第一行的第j个位置最多能拿的积分，然后我们就可以按照dp[ i ][ j ] = max(dp[ i - 1 ][ j ], dp[ i ][ j - 1 ]) &#43; dp[ i ][ j ]的方法遍历每个节点即可">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-12T10:28:32+08:00">
    <meta property="article:modified_time" content="2024-08-12T10:28:32+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【算法/训练】：动态规划（线性DP）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一、路径类</h3> 
<h3>1. <a href="https://www.nowcoder.com/practice/9740ce2df0a04399a5ade1927d34c1e1?tpld=230&amp;tqld=230&amp;tqld=38954&amp;ru=/exam/oj" rel="nofollow" title="字母收集">字母收集</a></h3> 
<p><img alt="" height="1033" src="https://images2.imgbox.com/18/85/QwtXpsvw_o.png" width="1163"></p> 
<blockquote> 
 <p><span style="color:#ad720d;"><strong>思路：</strong></span></p> 
 <p>1、预处理</p> 
 <p>     对输入的字符矩阵我们按照要求将其<strong>转换为数字分数</strong>，<strong>由于只能往下和往右走，因此走到（i，j）的位置要就是从（i - 1， j）往下走，或者是从(i，j  - 1)的位置往右走</strong>，由于我们要<strong>使得路程遍历积分最多，则应该从积分多的位置过来，</strong></p> 
 <p>2、状态表示 <strong>dp[i][j]</strong> 表示：<strong>从[0, 0]出发，到底[i, j]位置，一共有多少分</strong></p> 
 <p><strong>3、状态转移方程</strong></p> 
 <p>    故（i，j）位置的积分应该为dp<strong>[ i ][ j ] = max(dp[ i - 1 ][ j ], dp[ i ][ j - 1 ]) + dp[ i ][ j ];</strong></p> 
 <p><strong>4、初始化</strong></p> 
 <p><strong>    但是上面仅对于（i &gt;= 1 &amp;&amp; j &gt;= 1）成立，</strong>对于第一行和第一列我们应该特殊处理，利用<strong>前缀和的知识</strong>可以求得，<strong>走到第一列的第i个位置最多能拿的积分以及走到第一行的第j个位置最多能拿的积分</strong>，然后我们就可以按照dp<strong>[ i ][ j ] = max(dp[ i - 1 ][ j ], dp[ i ][ j - 1 ]) + dp[ i ][ j ]的方法遍历每个节点即可</strong></p> 
</blockquote> 
<p><strong><span style="color:#a2e043;">AC代码</span></strong>如下：</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

const int N = 1005;
int dp[N][N];

int main() {
	int n, m;
	cin &gt;&gt; n &gt;&gt; m;
	char ch;
	for (int i = 0; i &lt; n; i++){
		for (int j = 0; j &lt; m; j++){
			cin &gt;&gt; ch;
			if (ch == 'l') dp[i][j] = 4;
			else if (ch == 'o') dp[i][j] = 3;
			else if (ch == 'v') dp[i][j] = 2;
			else if (ch == 'e') dp[i][j] = 1;
			else a[i][j] = 0;
		}
	}

for (int i = 1; i &lt; n; i++) dp[i][0] = dp[i - 1][0] + dp[i][0]; 
for (int j = 1; j &lt; m; j++) dp[0][j] = dp[0][j - 1] + dp[0][j]; 

	for (int i = 1; i &lt; n; i++){
		for (int j = 1; j &lt; m; j++){
			dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + dp[i][j];
		}
	}

	cout &lt;&lt; dp[n - 1][m - 1] &lt;&lt; endl;
	return 0;
}
</code></pre> 
<h3></h3> 
<h3>2、<a href="https://www.nowcoder.com/practice/cc1a9bc523a24716a117b438a1dc5706?tpld=230&amp;tqld=20428&amp;&amp;ru=/exam/oj" rel="nofollow" title="[NOIP2002 普及组] 过河卒">[NOIP2002 普及组] 过河卒</a></h3> 
<p><img alt="" height="1140" src="https://images2.imgbox.com/04/5f/R5SMlFaB_o.png" width="1172"></p> 
<p>图解：</p> 
<p><img alt="" height="994" src="https://images2.imgbox.com/21/a1/mt6v5AwQ_o.png" width="1200"></p> 
<blockquote> 
 <p><strong><span style="color:#ad720d;">思路：</span></strong><br><strong>1、状态表示</strong><br> dp[i][j] 表示：从[0, 0]出发，到底[i, j]位置，一共有多少种方法<br><strong>2、状态转移方程</strong></p> 
 <p>    dp[ i ][ j ] = dp[ i - 1 ][ j ] + dp[i][j - 1] (i &gt; 0 &amp;&amp; j &gt; 0)</p> 
 <p>当走到马可以走的地方，dp[ i ][ j ] = 0;<br><strong>3、初始化</strong></p> 
 <p>先创建一个 dp[ n + 2 ][ m + 2 ]，然后让dp[ 0 ][ 1 ] = 1 或者 dp[ 1 ][ 0 ] = 1。注意这样初始化的时候，x需要+1,y也需要+1.<strong>和dp表位置一一对应</strong></p> 
</blockquote> 
<p><strong><span style="color:#a2e043;">AC代码</span>如下：</strong></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

//int dp[1005][1005];
int main()
{
    int n, m, x, y;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;
    
    vector&lt;vector&lt;long long&gt;&gt; dp(n + 2, vector&lt;long long&gt;(m + 2));
    dp[0][1] = 1;
    x += 1, y += 1;和dp表位置一一对应

    for (int i = 1; i &lt;= n + 1; i++)
    {
        for (int j = 1; j &lt;= m + 1; j++) { //马所在位置
            if (i != x &amp;&amp; j != y &amp;&amp; abs(i - x) + abs(j - y) == 3 || (i == x &amp;&amp; j == y))
            {
                dp[i][j] == 0;
            }
            else dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }
    cout &lt;&lt; dp[n + 1][m + 1] &lt;&lt; endl;

    return 0;
}</code></pre> 
<h3>3、<a href="https://www.nowcoder.com/practice/2237b401eb9347d282310fc1c3adb134?tpld=265&amp;tqld=39388&amp;ru=/exam/oj" rel="nofollow" title="礼物的最大价值">礼物的最大价值</a></h3> 
<p><img alt="" height="774" src="https://images2.imgbox.com/a9/4c/p83jadkA_o.png" width="1200"></p> 
<blockquote> 
 <p><strong><span style="color:#ad720d;">思路：</span></strong><br><strong>1、状态表示</strong><br> dp[i][j] 表示：到[i, j]位置时礼物的最大价值<br><strong>2、状态转移方程</strong></p> 
 <p>    dp[ i ][ j ] = max(dp[ i - 1 ][ j ] + w[ i ][ j ]，dp[ i ][ j - 1] + w[ i ][ j ] ）  <br><strong>3、初始化</strong></p> 
 <p>我们应该初始化第一行第一列的值，但是我们可以选择多加第一行第一列，把其初始化为0</p> 
</blockquote> 
<pre><code class="language-cpp">int maxValue(vector&lt;vector&lt;int&gt; &gt;&amp; grid) {
	int n = grid.size(), m = grid[0].size();
	vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1));
	for (int i = 1; i &lt;= n; i++) {
		for (int j = 1; j &lt;= m; j++) {
			dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1];
		}
	}
	return dp[n][m];
}
</code></pre> 
<p></p> 
<h3>二、子序列和连续序列类</h3> 
<h4>1. <a href="https://ac.nowcoder.com/acm/problem/26226" rel="nofollow" title="mari和shiny">mari和shiny</a></h4> 
<p><img alt="" height="802" src="https://images2.imgbox.com/69/6d/TKKaj5K2_o.png" width="885"></p> 
<blockquote> 
 <h5>🌈<span style="color:#0d0016;">线性 dp</span></h5> 
 <p>在维护 i 位置之前，⼀共有多少个 "s" "sh" ，然后更新 "shy" 的个数。</p> 
 <p><strong>（1）状态表示</strong></p> 
 <ul><li> <p>s[i]：字符串 str 中 [0, i] 区间内有多少个 "s"。</p> </li><li> <p>h[i]：字符串 str 中 [0, i] 区间内有多少个 "sh"。</p> </li><li> <p>y[i]：字符串 str 中 [0, i] 区间内有多少个 "shy。</p> </li></ul> 
 <hr> 
 <p><strong>（2）状态转移方程</strong></p> 
 <p><img alt="" height="68" src="https://images2.imgbox.com/4a/f3/cstASNxI_o.png" width="313"></p> 
 <p><img alt="" height="430" src="https://images2.imgbox.com/54/7d/jk2Ab6mn_o.png" width="300"></p> 
 <hr> 
 <p><strong>（3）空间优化</strong></p> 
 <p><strong>用三个变量来表示即可</strong></p> 
 <p>s：（字符串 str 中 [0, n-1] 区间内有多少个 "s"）</p> 
 <p>h：（字符串 str 中 [0, n-1] 区间内有多少个 "sh"）</p> 
 <p>y：（字符串 str 中 [0, n-1] 区间内有多少个 "shy"）</p> 
 <p>最后的遍历结束后，y即我们需要的结果</p> 
</blockquote> 
<p><strong><span style="color:#a2e043;">AC代码</span></strong>如下：</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
typedef long long ll;
int main()
{
	int n;
	string str;
	cin &gt;&gt; n &gt;&gt; str;
	ll s = 0, h = 0, y = 0;
	for (int i = 0; i &lt; n; i++) {
		if (str[i] == 's') s++;
		else if (str[i] == 'h') h += s;
		else if (str[i] == 'y') y += h;
	}
	cout &lt;&lt; y &lt;&lt; endl;
	return 0;
}</code></pre> 
<blockquote> 
 <h5>🌈二维 dp </h5> 
 <p>这道题目如果不是<a href="https://so.csdn.net/so/search?q=%E5%AD%90%E5%BA%8F%E5%88%97&amp;spm=1001.2101.3001.7020" title="子序列">子序列</a>，而是<strong>要求连续序列的，那就可以考虑用 KMP。</strong></p> 
 <p><strong><span style="color:#1c7331;">（1）dp[i][j] 含义</span></strong></p> 
 <ul><li>string t="shy"</li></ul> 
 <p>dp[i][j]：以 i-1 为结尾的 str 子序列中出现以 j-1 为结尾的 t 的个数为 dp[i][j]。</p> 
 <hr> 
 <p><strong><span style="color:#1c7331;">（2）递推关系</span></strong></p> 
 <ul><li>str[i - 1] 与 t[j - 1]相等</li><li>str[i - 1] 与 t[j - 1] 不相等</li></ul> 
 <p>当 str[i - 1] 与 t[j - 1]相等时，dp[i][j] 可以有两部分组成：</p> 
 <ol><li>一部分是用 str[i - 1] 来匹配，那么个数为 dp[i - 1][j - 1]。即不需要考虑当前 str 子串和 t 子串的最后一位字母，所以只需要 dp[i-1][j-1]。</li><li>一部分是不用 str[i - 1] 来匹配，个数为 dp[i - 1][j]。</li></ol> 
 <p><span style="color:#fe2c24;">为什么还要考虑不用 str[i - 1] 来匹配</span>，都相同了指定要匹配？<br> 🧩<strong>例如</strong>： str：shyy 和 t：shy ，str[3] 和 t[2] 是相同的，但是字符串 str 也可以不用 str[3] 来匹配，即用 str[0]str[1]str[2] 组成的 "shy"。当然也可以用 str[3] 来匹配，即：str[0]str[1]str[3] 组成的 "shy"。</p> 
 <p>所以，当 str[i - 1] 与 t[j - 1] 相等时，dp[ i ][ j ] = dp[ i - 1 ][ j - 1 ] + dp[ i - 1 ][ j ];</p> 
 <p>当 str[i - 1] 与 t[j - 1] 不相等时，dp[i][j] 只有一部分组成，不用 str[i - 1] 来匹配（就是模拟在 str 中删除这个元素），即：dp[i - 1][j]，所以<strong>递推公式为：dp[ i ][ j ] = dp[ i - 1 ][ j ];</strong></p> 
 <p></p> 
 <p>为什么只考虑 “不用 str[i - 1] 来匹配” 这种情况， 不考虑 “不用 t[j - 1] 来匹配” 的情况呢？<br> 🧩这里要明确，我们求的是<strong> str 中有多少个 t，而不是求 t 中有多少个 str</strong>，所以<strong>只考虑 str 中删除元素的情况，即不用 str[i - 1] 来匹配 的情况。</strong></p> 
 <hr> 
 <p><span style="color:#1c7331;"><strong>（3）状态转移方程</strong></span></p> 
 <ul><li> <p><strong>dp[i][j]显然要从dp[i-1][?]递推而来。</strong>立即思考dp[i-1][j], dp[i-1][j-1]分别与dp[i][j]的关系。因为少一个字符，自然而然从当前字符着手。考察si的第i个字符(表为s[i])和tj的第j个字符(表为t[j])的关系。</p> </li><li> <p></p> <p>若s[i] ≠ t[j]：那么s_i中的所有t_j子序列，必不包含s[i]，即s_i-1和s_i中tj的数量是一样的，得到该情形的转移方程： <strong>dp[ i ][ j ] = dp[ i -1 ][ j ]</strong></p> </li><li> <p></p> <p>若s[i] = t[j]：假设s_i中的所有t_j子序列中，包含s[i]的有a个，不包含的有b个。s_i中包含s[i]的子序列个数相当于s_i-1中t_j-1的个数，不包含s[i]的子序列个数与上一种情况一样，于是得到该情形的转移方程：</p> <p>a = dp[ i -1 ][ j -1 ] b = dp[ i-1 ][ j ] dp[ i ][ j ] = a + b = dp[i-1][j-1] + dp[i-1][j]</p> </li></ul> 
 <hr> 
 <p><span style="color:#1c7331;"><strong>（4）遍历顺序</strong></span></p> 
 <p>从上到下，从左到右。</p> 
</blockquote> 
<p><strong><span style="color:#a2e043;">AC代码</span></strong>如下：</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
 
using namespace std;
 
int main()
{
    int n;
    cin &gt;&gt; n;
    string str;
    cin &gt;&gt; str;
    string t="shy";
    int m=t.size();
 
    vector&lt;vector&lt;long long&gt;&gt; dp(n+1, vector&lt;long long&gt;(m+1));
    for(int i=0; i&lt;=n; i++) dp[i][0]=1;
 
    for(int i=1; i&lt;=n; i++)
    {
        for(int j=1; j&lt;=m; j++)
        {
            if(str[i-1]==t[j-1])
                dp[i][j]=dp[i-1][j-1]+dp[i-1][j];
            else
                dp[i][j]=dp[i-1][j];
        }
    }
 
    cout &lt;&lt; dp[n][m] &lt;&lt; endl;
 
    return 0;
}</code></pre> 
<h3>2. <a href="https://leetcode.cn/problems/distinct-subsequences/solutions/661122/bu-tong-de-zi-xu-lie-by-leetcode-solutio-urw3/" rel="nofollow" title="不同的子序列">不同的子序列</a></h3> 
<p><img alt="" height="747" src="https://images2.imgbox.com/24/51/2iQfIlA5_o.png" width="945"></p> 
<blockquote> 
 <p>该题于上题不一样的是，上面给定了t的具体字符串，而这里没有给定，但是我们也需要用二维dp的方法来写。</p> 
 <p><strong><span style="color:#1c7331;">（1）dp[i][j] 含义</span></strong></p> 
 <p>s[ i ]的子序列中在t[ j ]出现的次数</p> 
 <p>s[ i ]表示s从下标 i 到末尾的子字符串。</p> 
 <p>t[ j ]表示t从下标 j 到末尾的子字符串。</p> 
 <hr> 
 <p><strong><span style="color:#1c7331;">（2）递推关系</span></strong></p> 
 <ol><li>分别令两个维度为0，推测边界。</li><li>dp[0][j]表示s_0中t_j的个数。s_0是空字符串，只有当j=0时，才有dp[0][j] = 1，表示s子空串中有一个t子空串，否则dp[0][j] = 0，因为一个空串不可能包含一个非空串。</li><li> <p>dp[i][0]表示s_i中t0的个数。t_0是空字符串，显然任何串（包括空串）都含有一个空子串。因此dp[i][0] = 1。</p> </li><li> <p></p> <p>注意到，dp[i][0] = 1实际上已经包含了dp[0][j] = 1的情形。</p> </li></ol> 
 <hr> 
 <p><span style="color:#1c7331;"><strong>（3）初始化</strong></span></p> 
 <ul><li>dp[i][0] 表示：以 i-1 为结尾的 str 可以随便删除元素，出现空字符串的个数。所以，dp[i][0] 一定都是 1，因为也就是把以 i-1 为结尾的 str，删除所有元素，出现空字符串的个数就是 1。</li><li>dp[0][j] 表示：空字符串 str 可以随便删除元素，出现以 j-1 为结尾的字符串 t 的个数。所以，dp[0][j] 一定都是 0，因为 str 如论如何也变成不了 t。</li><li>dp[0][0] 表示：空字符串 str 可以删除 0 个元素，变成空字符串 t。所以，dp[0][0] = 1。</li></ul> 
 <hr> 
 <p><span style="color:#1c7331;"><strong>（4）遍历顺序</strong></span></p> 
 <p>从上到下，从左到右。</p> 
</blockquote> 
<p><strong><span style="color:#a2e043;">AC代码</span>如下： </strong></p> 
<pre><code class="language-cpp">​
int numDistinct(string s, string t) {
	int n = s.size(), m = t.size();
	if (n &lt; m) return 0;
	vector&lt;vector&lt;unsigned int&gt;&gt; dp(n + 1, vector&lt;unsigned int&gt;(m + 1)); //注意是unsigned int
	for (int i = 0; i &lt;= n; i++) dp[i][0] = 1;
	for (int i = 1; i &lt;= n; i++) {
		for (int j = 1; j &lt;= m; j++) {
			dp[i][j] = dp[i - 1][j] +(s[i - 1] == t[j - 1] ? dp[i - 1][j - 1] : 0);
		}
	}
	return dp[n][m];
}

​</code></pre> 
<h3>3. <a href="https://leetcode.cn/problems/maximum-subarray/" rel="nofollow" title="连续子数组最大和">连续子数组最大和</a></h3> 
<h3><img alt="" height="859" src="https://images2.imgbox.com/29/b5/Nww465oo_o.png" width="1002"></h3> 
<blockquote> 
 <p><strong><span style="color:#ad720d;">思路：</span></strong><br><strong>1、状态表示</strong><br> dp[ i ]表示：以 i 位置为结尾的所有子数组中的最大和</p> 
 <p></p> 
 <p><span style="color:#956fe7;"><strong>方法一：</strong></span><br><strong>2、状态转移方程</strong></p> 
 <p>对于nums[i]有两种情况:一种是和前一个位置的子序列连着dp[i]=dp[i-1]+nums[i]<br> 第二种是以自己独立门户，从自己开始dp[i]=nums[i]</p> 
 <p>取其中最大值,可得状态转移方程为 <span style="color:#1a439c;"><strong>dp[ i ] =  max(dp[i - 1] + nums[i], nums[i]) ;</strong></span></p> 
 <p><strong>3、初始化</strong></p> 
 <p>dp[0]=nums[0]</p> 
 <p></p> 
 <p><span style="color:#956fe7;"><strong>方法二：</strong></span></p> 
 <p><strong>2、状态转移方程</strong></p> 
 <p> dp[ i ] = max(dp[ i - 1 ] ， 0） + nums[ i - 1 ] .<br><strong>3、初始化</strong></p> 
 <p>dp[ 0 ] = 0，然后从下标1开始计算，最后返回 dp 表的最大值即可</p> 
</blockquote> 
<p><strong><span style="color:#a2e043;">AC代码</span>如下：</strong></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

int main() {
	int n;
	cin &gt;&gt; n;
	vector&lt;int&gt; dp(n + 1);
	int w, ret = -101;
	for (int i = 1; i &lt;= n; i++) {
		cin &gt;&gt; w;
		dp[i] = max(dp[i - 1], 0) + w;
		ret = max(ret, dp[i]);
	}
	cout &lt;&lt; ret &lt;&lt; endl;
	return 0;
}</code></pre> 
<h3>4、<a class="link-info" href="https://www.nowcoder.com/practice/c7fc893654b44324b6763dea095ceaaf?tpld=265&amp;tqld=39388&amp;ru=%2Fexam%2Foj&amp;tpId=0&amp;difficulty=&amp;judgeStatus=&amp;tags=&amp;title=%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87&amp;sourceUrl=&amp;gioEnter=menu" rel="nofollow" title="最长回文子序列">最长回文子序列</a></h3> 
<p><img alt="" height="764" src="https://images2.imgbox.com/cf/43/sL4IxfFJ_o.png" width="903"></p> 
<blockquote> 
 <p><strong><span style="color:#ad720d;">思路：</span></strong><br><strong>1、状态表示</strong></p> 
 <p>dp[ i ][ j ] 表示：字符串[ i，j] 区间内最长回文子序列的长度<br><strong>2、状态转移方程</strong></p> 
 <p></p> 
 <ol><li>i &gt; j 时，dp[ i ][ j ] = 0;</li><li>i = j 时，dp[ i ][ j ] = 1;</li><li>i &lt; j，分以下两种情况</li></ol> 
 <ul><li>s[ i ] = s[ j ]时候，dp[ i + 1][ j - 1]  +2;</li><li>s[ i ] != s[ j ]时候，max(dp[i - 1][ j ]，dp[ i ][ j - 1] )</li></ul> 
 <p><strong>3、初始化</strong></p> 
 <p>dp[ 0 ] = 0，然后从下标1开始计算，最后返回 dp 表的最大值即可</p> 
</blockquote> 
<p> <strong><span style="color:#a2e043;">AC代码</span>如下：</strong></p> 
<pre><code class="language-cpp">int longestPalindromeSubSeq(string s) {
	// write code here
	int n = s.size();
	vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n));
	//i为起始索引，j为结束索引
	for (int i = n - 1; i &gt;= 0; i--) {
		dp[i][i] = 1;
		for (int j = i + 1; j &lt; n; j++) {
			//相同，则加2
			if (s[i] == s[j])
				dp[i][j] = dp[i + 1][j - 1] + 2;
			//不同，则从dp[i+1][j] dp[i][j-1]中寻找最大值。
			else
				dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
		}
	}
	return dp[0][n - 1];
}</code></pre> 
<p></p> 
<h3>三、偷盗问题</h3> 
<h4>1. <a href="https://leetcode.cn/problems/house-robber/description/" rel="nofollow" title="打家劫舍">打家劫舍</a></h4> 
<h4><img alt="" height="809" src="https://images2.imgbox.com/8a/a8/lcNdzagi_o.png" width="1154"></h4> 
<p></p> 
<blockquote> 
 <p><span style="color:#b95514;"><strong>思路：</strong></span></p> 
 <p>首先考虑最简单的情况。如果只有一间房屋，则偷窃该房屋，可以偷窃到最高总金额。如果只有两间房屋，则由于两间房屋相邻，不能同时偷窃，只能偷窃其中的一间房屋，因此选择其中金额较高的房屋进行偷窃，可以偷窃到最高总金额。如果房屋数量大于两间，应该如何计算能够偷窃到的最高总金额呢？</p> 
 <p></p> 
 <p><span style="color:#0d0016;">方法一：二维</span></p> 
 <p><strong>1、状态表示</strong></p> 
 <p>设 dp[i][0] 为不偷第 i 个房间的情况下，前 i 个数偷盗总金额的最大值；dp[i][1]为取第 i 个数的情况下，前 i 个数不偷盗总金额的最大值。</p> 
 <p><strong>2、状态转移方程</strong></p> 
 <p>不偷当前房间，那么前一个房间取不取都行：</p> 
 <p><span style="color:#956fe7;"><strong>dp[i][0]=max(dp[i−1][1],dp[i−1][0])</strong></span></p> 
 <p>若取当前房间，那么前一个房间一定不能取：</p> 
 <p><strong><span style="color:#956fe7;">dp[i][1]=dp[i−1][0]+ nums[i - 1]</span></strong></p> 
 <p>最后需要输出 max(dp[n][0],dp[n][1])</p> 
 <p></p> 
 <p>方法二：一维</p> 
 <p>对于 k（ k &gt; 2）的房屋数量，有两个选项：</p> 
 <ul><li>偷窃第k间房屋，那么就不能偷窃第 k−1 间房屋，偷窃总金额为前 k−2 间房屋的最高总金额与第 k 间房屋的金额之和。</li><li> <p><span style="color:#0d0016;">不偷窃第 k 间房屋，偷窃总金额为前 k−1 间房屋的最高总金额。</span></p> <p><span style="color:#0d0016;">在两个选项中选择偷窃总金额较大的选项，该选项对应的偷窃总金额即为前 k 间房屋能偷窃到的最高总金额。</span></p> </li></ul> 
 <p><strong>1、状态表示</strong><br> dp[ i ]：表示前i间房屋能偷盗的最多钱数。<br><strong>2、状态转移方程</strong></p> 
 <p>    dp[ i ] = max(dp[ i - 2 ] + nums[ i ] , dp[i - 1] )</p> 
 <p>提示里说了nums.length&gt;=1;</p> 
 <p>对于nums.length==1，需特殊处理，return nums[0];</p> 
</blockquote> 
<p><span style="color:#a2e043;"><strong>AC代码</strong></span>如下：</p> 
<pre><code class="language-cpp">int rob(vector&lt;int&gt;&amp; nums) {
	int n = nums.size();

	// 方法一：二维表示
	/*vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(n + 1));
	for (int i = 1; i &lt;= n; i++)
	{
		dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]);
		dp[i][1] = dp[i - 1][0] + nums[i - 1];
	}
	return max(dp[n][0], dp[n][1]);*/

	//方法二：一维表示
	/*if (n == 1) return nums[0];
	vector&lt;int&gt; dp(n + 1);
	dp[0] = nums[0];
	dp[1] = max(nums[0], nums[1]);
	for (int i = 2; i &lt; n; ++i) {
		dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
	}
	return dp[n - 1];*/

	//方法三：再优化
	int f1 = 0, f0 = 0;
	for (int i = 0; i &lt; n; i++) {
		int tmp = max(f1, f0 + nums[i]);
		f0 = f1;
		f1 = tmp;
	}
	return f1;
}
</code></pre> 
<h4>2. <a href="https://leetcode.cn/problems/house-robber-ii/description/" rel="nofollow" title="打家劫舍 II">打家劫舍 II</a></h4> 
<p><img alt="" height="948" src="https://images2.imgbox.com/72/10/P4XfrEkZ_o.png" width="1156"></p> 
<blockquote> 
 <p>思路：</p> 
 <p>    这道题中的房屋是首尾相连的，第一间房屋和最后一间房屋相邻，因此第一间房屋和最后一间房屋不能在同一晚上偷窃。和上题相似，这道题也可以使用动态规划解决。</p> 
 <p>考虑是否偷 nums[0]：</p> 
 <ul><li>如果偷 nums[0]，那么 nums[1] 和 nums[n−1] 不能偷，问题变成从 nums[2] 到 nums[n−2] 的非环形版本。</li><li>如果不偷 nums[0]，那么问题变成从 nums[1] 到 nums[n−1] 的非环形版本。</li><li>分别取<strong> [start,end)=[2,n−2) 和 [start,end)=[1,n−1) 进行计算，取两个 dp[end] 中的最大值，即可得到最终结果</strong></li></ul> 
 <p>假设偷窃房屋的下标范围是 [start,end]，用 dp[i] 表示在下标范围 [start,i] 内可以偷窃到的最高总金额：</p> 
 <p><strong>1、状态表示</strong><br><span style="color:#fe2c24;">   dp[ i ]：表示前i间房屋能偷盗的最多钱数。</span><br><strong>2、状态转移方程</strong></p> 
 <p>    <span style="color:#fe2c24;">dp[i]=max(dp[i−2]+nums[i],dp[i−1])</span></p> 
 <p>注意：这题我们用 tmp, f1, f0 来分别表示dp[i]，dp[i - 1]，dp[i -2]。 </p> 
</blockquote> 
<p><strong><span style="color:#a2e043;">AC代码</span></strong>如下：</p> 
<pre><code class="language-cpp">int robRange(vector&lt;int&gt;&amp; nums, int start, int end) { // [start, end) 左闭右开
    int f1 = 0 , f0 = 0;
    for (int i = start; i &lt; end; i++) {
        int tmp = max(f1, f0 + nums[i]);
        f0 = f1;
        f1 = tmp;
    }
    return f1;
}

int rob(vector&lt;int&gt;&amp; nums) {
    int n = nums.size();
    return max(nums[0] + robRange(nums, 2, n - 1), robRange(nums, 1, n));
}
</code></pre> 
<h4>3. <a href="https://leetcode.cn/problems/house-robber-iii/solutions/361038/da-jia-jie-she-iii-by-leetcode-solution/" rel="nofollow" title="打家劫舍 III">打家劫舍 III</a></h4> 
<p><img alt="" height="883" src="https://images2.imgbox.com/95/74/Ma40kECi_o.png" width="1157"></p> 
<blockquote> 
 <p>思路：</p> 
 <p>对于当前节点，就两个选择，<strong>抢</strong>或者<strong>放弃</strong>。<strong>然后我们用 f(o) 表示抢 o 节点的情况下，o 节点的子树上被选择的节点的最大权值和；g(o) 表示不抢 o 节点的情况下，o 节点的子树上被选择的节点的最大权值和；l 和 r 代表 o 的左右孩子。</strong></p> 
 <p>🧩1、<strong>当 o 被选中时，o 的左右孩子都不能被选中</strong>，故 o 被选中情况下子树上被选中点的最大权值和为 l 和 r 不被选中的最大权值和相加，即<span style="color:#fe2c24;"> f(o)=g(l)+g(r)</span>。<br> 🧩2、<strong>当 o 不被选中时，o 的左右孩子可以被选中</strong>，也可以不被选中。对于 o 的某个具体的孩子 x，它对 o 的贡献是 x 被选中和不被选中情况下权值和的较大值。故 <span style="color:#fe2c24;">g(o)=max{f(l),g(l)}+max{f(r),g(r)}</span>。<br> 🧩至此，我们可以用哈希表来存 f 和 g 的函数值，用深度优先搜索的办法后序遍历这棵二叉树，我们就可以得到每一个节点的 f 和 g。根节点的 f 和 g 的最大值就是我们要找的答案。</p> 
</blockquote> 
<p><strong><span style="color:#a2e043;">AC代码</span></strong>如下：</p> 
<pre><code class="language-cpp">unordered_map&lt;TreeNode*, int&gt;f, g;
void dfs(TreeNode* node)
{
	if (node == nullptr) return;
	dfs(node-&gt;left), dfs(node-&gt;right);
	f[node] = node-&gt;val + g[node-&gt;left] + g[node-&gt;right]; //如果抢该节点
	g[node] = max(f[node-&gt;left], g[node-&gt;left]) + max(f[node-&gt;right], g[node-&gt;right]);
}


int rob(TreeNode* root) {
	dfs(root);
	return max(f[root], g[root]);
}
</code></pre> 
<p></p> 
<h4>4. <a href="https://leetcode.cn/problems/house-robber-iv/description/" rel="nofollow" title="打家劫舍 IV">打家劫舍 IV</a></h4> 
<h3><img alt="" height="907" src="https://images2.imgbox.com/fe/be/5cq9dse8_o.png" width="1132"></h3> 
<blockquote> 
 <p>思路：</p> 
 <p>     通过观察可以发现，当偷盗能力越大时，小偷最多能偷的房屋数就越多；如果偷盗能力越小时，小偷最多能偷的房屋数就越少。</p> 
 <p>     由题意我们可知，这是求最小的最大值，因此我们可以想到用二分的方法来找到合适的 capacity。对于每个通过二分列举出来的 capacity，因为碍于偷盗能力，小偷只能偷价值不超过 capacity 的房子，而且不能连续偷。因此，我们可以通过动态规划的方法算出：当小偷的偷盗能力为 capacity 时，小偷可以最多可以偷多少间房（设为 y），如果 y &gt;= k，那么就代表 capacity 偏大，要把 capacity 调小一点；如果 y &lt; k，那么就代表 capacity 偏小，把 capacity 调大一点。且由于要求的是最小的最大值，因此属于二分里面的区间左端点问题。</p> 
 <p>处。</p> 
 <p>     通过二分枚举 capacity，对每个 capacity 进行动态规划，求出在该 capacity 的情况下最多偷到的房屋数，然后再根据这个房屋数调整 capacity 的查找区间。</p> 
</blockquote> 
<p><strong><span style="color:#a2e043;">AC代码</span></strong>如下：</p> 
<pre><code class="language-cpp">int minCapability(vector&lt;int&gt;&amp; nums, int k) {
    vector&lt;int&gt; capacity = nums;
    sort(capacity.begin(), capacity.end());

    int l = 0, r = capacity.size() - 1;
    while (l &lt; r)
    {
        int m = (r - l &gt;&gt; 1) + l; //注意：+， -的优先级高于&gt;&gt;
        if (check(nums, capacity[m]) &gt;= k)r = m;
        else l = m + 1;
    }
    return capacity[l];
}

int check(vector&lt;int&gt;&amp; nums, int capacity)
{
    int n = nums.size();
    vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(2));

    for (int i = 1; i &lt;= n; i++)
    {
        if (nums[i - 1] &lt;= capacity) dp[i][1] = dp[i - 1][0] + 1;
        dp[i][0] = max(dp[i - 1][1], dp[i - 1][0]);
    }
    return max(dp[n][1], dp[n][0]);
}
</code></pre> 
<p>  </p> 
<p></p> 
<h2>四、背包问题</h2> 
<h3>1. <a href="https://www.acwing.com/problem/content/2/" rel="nofollow" title="01背包问题">01背包问题</a></h3> 
<h3><img alt="" height="1022" src="https://images2.imgbox.com/18/d1/PAFenpeZ_o.png" width="1021"></h3> 
<blockquote> 
 <p><strong>1、状态表示</strong></p> 
 <p>dp[ i ][ j ]表示：从前 i 个物品中挑选，总体积不超过j，此时最大的重量</p> 
 <p><strong>2、状态转移方程</strong></p> 
 <p>dp[ i ][ j ] = max (<strong>dp[i - ][ j ]</strong>  (不选i)， <strong>dp[i - 1][ j - v[ i ]] + w[ i ] </strong> (选i) ) </p> 
 <p><strong>3、初始化问题</strong> dp[ 0 ][ j ]  = 0 ;</p> 
 <p><strong>4、 返回dp[n][V]</strong>.</p> 
 <p><strong>5、空间优化</strong></p> 
 <p>dp[ j ] = max ( dp [ j ], dp[ j - v[ i ] + w [ i ] ]  </p> 
</blockquote> 
<p><strong><span style="color:#a2e043;">AC代码</span></strong>如下：</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

const int N = 1005;
int dp[N], v[N], w[N];

int main() {
    int n, V;
    cin &gt;&gt; n &gt;&gt; V;
    for (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i]; //体积权重
    for (int i = 1; i &lt;= n; i++)  { //体积
        for (int j = V; j &gt;= v[i]; j--) { //逆序，表示该物品最多使用一次
            dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
        }
    }
    cout &lt;&lt; dp[V] &lt;&lt; endl;
    return 0;
}</code></pre> 
<h3>2. <a class="link-info" href="https://www.acwing.com/problem/content/3/" rel="nofollow" title="完全背包问题">完全背包问题</a></h3> 
<p><img alt="" height="986" src="https://images2.imgbox.com/9b/60/H7AIQsta_o.png" width="994"></p> 
<blockquote> 
 <p><strong><span style="color:#b95514;">思路：</span></strong></p> 
 <p>和上题不同的是，01背包中n件物品只能使用一次，而这里可以无限次使用</p> 
 <p>那么我们可以把这题<strong>把多次使用的某件物品看作多次插入</strong>，那么这道题的解题步骤就和上面类似了，<strong>状态转移方程也基本和上面类似，我们这里同样也进行了空间优化。</strong></p> 
 <p><strong>上一篇代码中，我们用的是逆序是为了保证更新当前状态时，用到的状态是上一轮的状态，保证每个物品只有一次或零次;<br> 在这里，因为每个物品可以取任意多次，所以不再强求用上一轮的状态，即本轮放过的物品，在后面还可以再放;</strong></p> 
</blockquote> 
<p><strong><span style="color:#a2e043;">AC代码</span></strong>如下：</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

const int N = 1010;
int dp[N],v[N], w[N];

int main(){
    int n, V;
    cin &gt;&gt; n &gt;&gt; V;
    for (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];

    for (int i = 1; i &lt;= n; i++){
        for (int j = v[i]; j &lt;= V; j++){
            dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
        }
    }
    cout &lt;&lt; dp[V] &lt;&lt; endl;
    return 0;
}
</code></pre> 
<h3>3. <a href="https://ac.nowcoder.com/acm/problem/16693" rel="nofollow" title="[NOIP2001]装箱问题">[NOIP2001]装箱问题</a></h3> 
<p><img alt="" height="1151" src="https://images2.imgbox.com/aa/4f/oZlMFnE1_o.png" width="1107"></p> 
<blockquote> 
 <p><strong><span style="color:#b95514;">思路：</span></strong></p> 
 <p><span style="color:#b95514;"><strong>该题也是个典型的01背包问题</strong></span></p> 
 <p><strong>1、状态表示</strong><br> dp[i][j] 表示：从前 i 个物品中挑选，总体积不超过 j，此时的最大体积<br><strong>2、状态转移方程</strong></p> 
 <p>    dp[ i ][ j ] = max(dp[ i - 1 ][ j ] ，dp[ i ][ j - V[ i ]] + V[ i ]) （j &gt;= arr[ i ]）<br><strong>3、初始化</strong></p> 
 <p>返回 V - dp[ n ][ V ]</p> 
</blockquote> 
<p><strong><span style="color:#a2e043;">AC代码</span></strong>如下：</p> 
<pre><code class="language-cpp">const int N = 35, M = 2e4 + 10;
int v[N], dp[N][M];

void solve3(){
	int V, n;
	cin &gt;&gt; V &gt;&gt; n;
	for (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i];
	for (int i = 1; i &lt;= n; i++) 
	{
		for (int j = 0; j &lt; V; j++)
		{
			dp[i][j] = dp[i - 1][j];
			if (j &gt;= v[i])
				dp[i][j] = max(dp[i][j], dp[i - 1][j - v[i]] + v[i]);
		}
	}

	cout &lt;&lt; V - dp[n][V] &lt;&lt; endl;
}</code></pre> 
<h3>4. <a href="https://www.nowcoder.com/practice/65ade309fa4d4067a9add749721bfdc0?tpId=230&amp;tqId=2383964&amp;ru=%2Fpractice%2F1718131e719746e9a56fb29c40cc8f95&amp;qru=%2Fta%2Fdynamic-programming%2Fquestion-ranking&amp;sourceUrl=" rel="nofollow" title="分割等和子集">分割等和子集</a></h3> 
<p><img alt="" height="397" src="https://images2.imgbox.com/28/ee/8ea0qkfI_o.png" width="1191"></p> 
<blockquote> 
 <p><strong><span style="color:#b95514;">思路：</span></strong></p> 
 <p><span style="color:#b95514;"><strong>该题也是个典型的01背包问题</strong></span></p> 
 <p><strong>1、状态表示</strong><br> dp[i][j] 表示：从前 i 个数字中挑选，总和恰好为 j，看是否能够凑成，因此我们这的dp数组为<strong>bool类型</strong><br><strong>2、状态转移方程</strong></p> 
 <p><span style="color:#956fe7;"><strong>第一种：最后一个数不选，先从前i - 1个数中挑，因为最后一个不选，对总和不造成影响，</strong></span></p> 
 <p><span style="color:#956fe7;"><strong>如果我们从前 i - 1种情况能凑成j，那么在从前 i种情况肯定能凑成j</strong></span></p> 
 <p><span style="color:#956fe7;"><strong>第二种：选了第i个数字，那从前i - 1个数中挑，对总和会造成影响，因此我们应该在前i - 1个数中凑总和为 j - arr[ i ]即可</strong></span></p> 
 <p>    <strong>dp[ i ][ j ] = dp[ i - 1 ][ j ] || dp[ i ][ j - arr[ i ]] （j &gt;= arr[ i ]）</strong><br><strong>3、初始化</strong></p> 
 <p>在之前的dp表基础上多加一行多加一列，方便我们初始化，初始dp[0][0] = true.</p> 
 <p><strong>4、返回值</strong></p> 
 <p>返回dp[ n ][ sum / 2] 即可</p> 
 <p><strong>注：如果总和为奇数，永远都选不出来一半，直接返回false即可。</strong></p> 
</blockquote> 
<p><strong><span style="color:#a2e043;">AC代码</span></strong>如下：</p> 
<p></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

const int N = 505, M = 505 * 110 / 2;
bool dp[N][M];
int arr[N];

int main()
{
	int n;
	cin &gt;&gt; n;
	int sum = 0;
	// 1.计算总和
	for (int i = 1; i &lt;= n; i++) {
		cin &gt;&gt; arr[i];
		sum += arr[i];
	}

	// 2.判断总和是否为奇数，为奇数直接截止
	if (sum % 2 == 1) {
		cout &lt;&lt; "false" &lt;&lt; endl;
		return 0;
	}

	// 3.动态规划
	sum /= 2;
	dp[0][0] = true; //初始化
	for (int i = 1; i &lt;= n; i++)
	{
		for (int j = 0; j &lt;= sum; j++) {
			dp[i][j] = dp[i - 1][j]; //当i = 0，j = 0的初始化
			if(j &gt;= arr[i])
				dp[i][j] = dp[i - 1][j] || dp[i][j - arr[i]];
		}
	}
	if (dp[n][sum]) cout &lt;&lt; "true" &lt;&lt; endl;
	else cout &lt;&lt; "false" &lt;&lt; endl;

	return 0;
}


</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5f1a326fb754e40d53bf4ba190e6f48a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">《花100块做个摸鱼小网站! 》第二篇—后端应用搭建和完成第一个爬虫</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/90408fc2d31b256eb8c50eceeab27352/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">灵办AI助手Chrome插件全面评测：PC Web端的智能办公利器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>