<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android --- 异步操作 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/81dd8ac4d44642f18a58c1ebda337681/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Android --- 异步操作">
  <meta property="og:description" content="同步和异步的差异 同步：在发生某件事后什么也不做，直到该事件完成后，再继续进行
异步：在某件事发生后，可以在等待他完成的时候去处理其他事件，等到该事件发生完成后，再回过头来处理它。
异步操作的核心思想就是将耗时操作放到子线程中执行，避免阻塞主线程，从而保持界面的流畅性。
异步实现方法 Thread &#43; Looper &#43; handler Android 提供了 Handler 机制来进行线程之间的通信，我们可以使用 Android 最基础的异步方式：Thread &#43; Looper &#43; handler 来进行异步任务
Handler mHandler = newHandler(){ @Override publicvoid handleMessage(Message msg){ if(msg.what == 1){ textView.setText(&#34;Task Done!!&#34;); } } }; mRunnable = new Runnable() { @Override publicvoid run() { SystemClock.sleep(1000); // 耗时处理 mHandler.sendEmptyMessage(1); } }; private void startTask(){ new Thread(mRunnable).start(); } 优点： 操作简单，无学习成本。 缺点： 代码规范性较差，不易维护。每次操作都会开启一个匿名线程，系统开销较大。 AsyncTask AsyncTask是较为轻量级的异步类，封装了 FutureTask 的线程池、ArrayDeque 和 Handler 进行调度。AsyncTask 主要用于后台与界面持续交互。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-17T17:52:07+08:00">
    <meta property="article:modified_time" content="2024-06-17T17:52:07+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android --- 异步操作</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>同步和异步的差异</h2> 
<p>同步：在发生某件事后什么也不做，直到该事件完成后，再继续进行</p> 
<p>异步：在某件事发生后，可以在等待他完成的时候去处理其他事件，等到该事件发生完成后，再回过头来处理它。</p> 
<p><span style="color:#fe2c24;"><strong>异步操作的核心思想就是将耗时操作放到子线程中执行，避免阻塞主线程，从而保持界面的流畅性。</strong></span></p> 
<h2><strong>异步实现方法</strong></h2> 
<h3 style="background-color:transparent;">Thread + Looper + handler</h3> 
<p>Android 提供了 Handler 机制来进行线程之间的通信，我们可以使用 Android 最基础的异步方式：Thread + Looper + handler 来进行异步任务</p> 
<pre><code class="hljs">Handler mHandler = newHandler(){
    @Override
    publicvoid handleMessage(Message msg){
        if(msg.what == 1){
            textView.setText("Task Done!!");
        }
    }
};
mRunnable = new Runnable() {
    @Override
    publicvoid run() {
        SystemClock.sleep(1000);    // 耗时处理
        mHandler.sendEmptyMessage(1);  
    }
};
private void startTask(){
    new Thread(mRunnable).start();
}
</code></pre> 
<h4>优点：</h4> 
<ul><li>操作简单，无学习成本。</li></ul> 
<h4><a id="_51"></a>缺点：</h4> 
<ul><li>代码规范性较差，不易维护。</li><li>每次操作都会开启一个匿名线程，系统开销较大。</li></ul> 
<h3 style="background-color:transparent;">AsyncTask</h3> 
<p>AsyncTask是较为轻量级的异步类，封装了 <span style="color:#fe2c24;">FutureTask 的线程池、ArrayDeque 和 Handler </span>进行调度。AsyncTask 主要用于<span style="color:#fe2c24;">后台与界面持续交互</span>。</p> 
<p>当我们定义一个类来继承 AsyncTask 这个类的时候，我们需要为其指定3个泛型参数：</p> 
<blockquote> 
 <p>AsyncTask　&lt;Params, Progress, Result&gt;</p> 
 <ul><li>Params: 这个泛型指定的是我们传递给异步任务执行时的参数的类型。</li><li>Progress: 这个泛型指定的是我们的异步任务在执行的时候将执行的进度返回给UI线程的参数的类型。</li><li>Result: 这个泛型指定的异步任务执行完后返回给UI线程的结果的类型。</li><li>我们在定义一个类继承 AsyncTask 类的时候，必须要指定好这三个泛型的类型，如果都不指定的话，则都将其写成 void。</li></ul> 
</blockquote> 
<h4 style="background-color:transparent;">使用 AsyncTask 的注意事项</h4> 
<ul><li>AsyncTask 的实例必须在 UI Thread 中创建。</li><li>只能在 UI 线程中调用 AsyncTask 的 execute 方法。</li><li>AsyncTask 被重写的四个方法是系统自动调用的,不应手动调用。</li><li>每个 AsyncTask 只能被执行一次，多次执行会引发异常。</li><li>AsyncTask 的四个方法，只有 doInBackground 方法是运行在其他线程中,其他三个方法都运行在 UI 线程中，也就说其他三个方法都可以进行 UI 的更新操作。</li><li>AsyncTask 默认是串行执行，如果需要并行执行，使用接口 executeOnExecutor 方法。 </li></ul> 
<h4>优点：</h4> 
<ul><li> <p>结构清晰，使用简单，适合后台任务的交互。</p> </li><li> <p>异步线程的优先级已经被默认设置成了：THREAD_PRIORITY_BACKGROUND，不会与 UI 线程抢占资源。</p> </li></ul> 
<h4>缺点：</h4> 
<ul><li> <p>结构略复杂，代码较多。</p> </li><li> <p>每个 AsyncTask 只能被执行一次，多次调用会发生异常。</p> </li><li> <p>AsyncTask 在整个 Android 系统中维护一个线程池，有可能被其他进程的任务抢占而降低效率。</p> </li></ul> 
<h3>线程池</h3> 
<p>利用 Executors 的静态方法<span style="background-color:#ffd900;"> newCachedThreadPool()</span>、<span style="color:#ffd900;">newFixedThreadPool()</span>、<span style="color:#ffd900;">newSingleThreadExecutor() </span>及重载形式实例化 ExecutorService 接口即得到线程池对象。</p> 
<ul><li><span style="color:#fe2c24;">动态线程池 newCachedThreadPool()</span>：根据需求创建新线程的，需求多时，创建的就多，需求少时，JVM 自己会慢慢的释放掉多余的线程。</li><li><span style="color:#fe2c24;">固定数量的线程池 newFixedThreadPool()</span>：内部有个任务阻塞队列，假设线程池里有2个线程，提交了4个任务，那么后两个任务就放在任务阻塞队列了，即使前2个任务 sleep 或者堵塞了，也不会执行后两个任务，除非前2个任务有执行完的。</li><li><span style="color:#fe2c24;">单线程 newSingleThreadExecutor()</span>：单线程的线程池，这个线程池可以在线程死后（或发生异常时）重新启动一个线程来替代原来的线程继续执行下去。</li></ul> 
<h4>例子</h4> 
<p> 下面代码中，新建了一个固定数量为4的线程池</p> 
<pre><code>@Database(entities = {AccountDataItem.class, AccountData.class},version = 6,exportSchema = false)
public abstract class AppRoomDataBase extends RoomDatabase {
    private static volatile AppRoomDataBase INSTANCE;
    public abstract AccountDao accountDao();
    public abstract AccountListDao accountListDao();

    public static final ExecutorService databaseWriteExecutor = Executors.newFixedThreadPool(4);
    // 单例模式
    public static AppRoomDataBase getDataBase(Context context){
        if (INSTANCE == null) {
            synchronized (AppRoomDataBase.class) {
                if (INSTANCE == null) {
                    INSTANCE = Room.databaseBuilder(
                                   context.getApplicationContext(),
                                    AppRoomDataBase.class,
                                    "记账数据库"
                            )
                            .fallbackToDestructiveMigration()
                            .build();
                }
            }
        }
        return INSTANCE;
    }
}</code></pre> 
<pre><code> public void deleteAllAccountItem() {
        appRoomDataBase.databaseWriteExecutor.execute(() -&gt; accountDao.deleteAll());
    }</code></pre> 
<h4>优点：</h4> 
<ul><li>线程的创建和销毁由线程池来维护，实现了线程的复用，从而减少了线程创建和销毁的开销。</li><li>适合执行大量异步任务，提高性能。</li><li>灵活性高，可以自由控制线程数量。</li><li>扩展性好，可以根据实际需要进行扩展。</li></ul> 
<h4>缺点：</h4> 
<ul><li>代码略显复杂。</li><li>线程池本身对系统资源有一定消耗。</li><li>当线程数过多时，线程之间的切换成本会有很大开销，从而使性能严重下降。</li><li>每个线程都会耗费至少 1040KB 内存，线程池的线程数量需要控制在一定范围内。</li><li>线程的优先级具有继承性，如果在 UI 线程中创建线程池，线程的默认优先级会和 UI 线程相同，从而对 UI 线程使用资源进行抢占。</li></ul> 
<h3>LiveData</h3>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0ed2cb634bfe798d4a66a007be3265c7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于C#、Visual Studio 2017以及.NET Framework 4.5的Log4Net使用教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9cffce4077fd7a6dea0125282e135248/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">普通人如何入门AI人工智能?最短学习路线分享</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>