<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>八数码问题——A*算法的应用（A-Star） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/49583b59bb3351385a12a0f26c88eef3/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="八数码问题——A*算法的应用（A-Star）">
  <meta property="og:description" content="文章目录 1 问题描述2 启发式搜索3 A*算法3.1 参考网址3.2 是什么3.3 为什么A*算法适用于八数码问题3.4 A* 算法的基本框架 4 A* 算法如何解决八数码问题4.1 八数码状态的存储4.2 启发式函数4.3 构造目标状态元素位置的字典4.4 在二维列表中查找目标元素4.5 A* 算法主体4.6 路径构造函数4.7 函数调用4.8 全部代码4.9 运行结果 5 拓展：八数码问题有无解的讨论5.1 逆序5.2 逆序奇偶性与可解性5.3 逆序不变性 1 问题描述 八数码问题是经典的启发式搜索问题，其目标是将一个3x3的九宫格中的数字1-8以及一个空格，按照规定的移动规则，通过移动操作，最终达到特定的顺序状态，通常是按照数字顺序排列，如下：
1 2 3
4 5 6
7 8 _
八数码问题的变种包括：
15 数码问题：与八数码类似，但是在4x4的九宫格中利用数字1-15及一个空格进行移动n 数码问题：可以扩展到更大规模，例如n×n的九宫格，其中包含数字1至n×n-1以及一个空格，玩家需要重新排列数字以达到特定的状态 2 启发式搜索 传统搜索算法通常不考虑启发信息，仅仅依赖于逐步尝试可能的方案，逐渐扩展搜索空间，直到找到解决方案或最优解，比如BFS、DFS等等。在大规模问题或者复杂问题中，这些传统搜索算法可能会因为搜索空间过大而导致效率低下启发式搜索是一种问题求解的方法，它结合了传统的搜索方法和一定的启发信息（heuristic information）来指导搜索方向。启发函数可以评估当前状态与目标状态的相似度，从而指导搜索方向。通过启发式函数的帮助，搜索可以更加偏向于朝着可能更接近最优解的方向前进，而不是盲目地扩展所有可能的搜索路径。 3 A*算法 3.1 参考网址 一个讲A*算法讲得很好的网站：
a-star
3.2 是什么 A*算法是一种启发式搜索算法，常用于寻找图中的最短路径或最优解。它结合了广度优先搜索和启发信息，在搜索过程中能够有效地减少搜索空间，从而提高搜索效率。
A* 算法的核心思想是综合考虑两个方面的信息：从起始节点到当前节点的实际代价（通常是已经走过的路径的代价），以及从当前节点到目标节点的估计代价（启发式函数）。这两方面的信息通过综合起来选择估计代价最小的节点进行搜索，朝着目标节点前进。
A*算法同时考虑了从起始节点到当前节点的实际代价，以及从当前节点到目标节点的估计代价（上图）
3.3 为什么A*算法适用于八数码问题 A* 算法适用于图搜索问题，本质上，八数码问题的每一种状态都可以看成是图中的一个节点，所以可以使用A* 算法求解在这里，从起始节点到当前节点的实际代价为从起始状态到当前状态的步骤数，而从当前节点到目标节点的估计代价我们使用当前状态到目标状态的曼哈顿距离来估计 在二维坐标系中，两点 (x1, y1) 和 (x2, y2) 之间的曼哈顿距离可以用以下公式表示： Manhattandistance = ∣x2−x1∣&#43;∣y2−y1∣">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-03T19:53:43+08:00">
    <meta property="article:modified_time" content="2024-04-03T19:53:43+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">八数码问题——A*算法的应用（A-Star）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1__1" rel="nofollow">1 问题描述</a></li><li><a href="#2__10" rel="nofollow">2 启发式搜索</a></li><li><a href="#3_A_14" rel="nofollow">3 A*算法</a></li><li><ul><li><a href="#31__15" rel="nofollow">3.1 参考网址</a></li><li><a href="#32__18" rel="nofollow">3.2 是什么</a></li><li><a href="#33_A_24" rel="nofollow">3.3 为什么A*算法适用于八数码问题</a></li><li><a href="#34_A__32" rel="nofollow">3.4 A* 算法的基本框架</a></li></ul> 
  </li><li><a href="#4_A__120" rel="nofollow">4 A* 算法如何解决八数码问题</a></li><li><ul><li><a href="#41__122" rel="nofollow">4.1 八数码状态的存储</a></li><li><a href="#42__140" rel="nofollow">4.2 启发式函数</a></li><li><a href="#43__166" rel="nofollow">4.3 构造目标状态元素位置的字典</a></li><li><a href="#44__188" rel="nofollow">4.4 在二维列表中查找目标元素</a></li><li><a href="#45_A__205" rel="nofollow">4.5 A* 算法主体</a></li><li><a href="#46__288" rel="nofollow">4.6 路径构造函数</a></li><li><a href="#47__335" rel="nofollow">4.7 函数调用</a></li><li><a href="#48__342" rel="nofollow">4.8 全部代码</a></li><li><a href="#49__513" rel="nofollow">4.9 运行结果</a></li></ul> 
  </li><li><a href="#5__530" rel="nofollow">5 拓展：八数码问题有无解的讨论</a></li><li><ul><li><a href="#51__531" rel="nofollow">5.1 逆序</a></li><li><a href="#52__536" rel="nofollow">5.2 逆序奇偶性与可解性</a></li><li><a href="#53__540" rel="nofollow">5.3 逆序不变性</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="1__1"></a>1 问题描述</h2> 
<ul><li> <p>八数码问题是经典的启发式搜索问题，其目标是将一个3x3的九宫格中的数字1-8以及一个空格，按照规定的移动规则，通过移动操作，最终达到特定的顺序状态，通常是按照数字顺序排列，如下：<br> 1 2 3<br> 4 5 6<br> 7 8 _</p> </li><li> <p>八数码问题的变种包括：</p> 
  <ul><li>15 数码问题：与八数码类似，但是在4x4的九宫格中利用数字1-15及一个空格进行移动</li><li>n 数码问题：可以扩展到更大规模，例如n×n的九宫格，其中包含数字1至n×n-1以及一个空格，玩家需要重新排列数字以达到特定的状态</li></ul> </li></ul> 
<h2><a id="2__10"></a>2 启发式搜索</h2> 
<ul><li>传统搜索算法通常不考虑启发信息，仅仅依赖于逐步尝试可能的方案，逐渐扩展搜索空间，直到找到解决方案或最优解，比如BFS、DFS等等。在大规模问题或者复杂问题中，这些传统搜索算法可能会因为搜索空间过大而导致效率低下</li><li>启发式搜索是一种问题求解的方法，它结合了传统的搜索方法和一定的启发信息（heuristic information）来指导搜索方向。启发函数可以评估当前状态与目标状态的相似度，从而指导搜索方向。通过启发式函数的帮助，搜索可以更加偏向于朝着可能更接近最优解的方向前进，而不是盲目地扩展所有可能的搜索路径。</li></ul> 
<h2><a id="3_A_14"></a>3 A*算法</h2> 
<h3><a id="31__15"></a>3.1 参考网址</h3> 
<p>一个讲A*算法讲得很好的网站：<br> <a href="https://www.redblobgames.com/pathfinding/a-star/introduction.html" rel="nofollow">a-star</a></p> 
<h3><a id="32__18"></a>3.2 是什么</h3> 
<ul><li> <p>A*算法是一种启发式搜索算法，常用于寻找图中的最短路径或最优解。它结合了广度优先搜索和启发信息，在搜索过程中能够有效地减少搜索空间，从而提高搜索效率。</p> </li><li> <p>A* 算法的核心思想是综合考虑两个方面的信息：从起始节点到当前节点的实际代价（通常是已经走过的路径的代价），以及从当前节点到目标节点的估计代价（启发式函数）。这两方面的信息通过综合起来选择估计代价最小的节点进行搜索，朝着目标节点前进。<br> <img src="https://images2.imgbox.com/8e/44/4H3EBx9q_o.png" alt="在这里插入图片描述"><br> A*算法同时考虑了从起始节点到当前节点的实际代价，以及从当前节点到目标节点的估计代价（上图）</p> </li></ul> 
<h3><a id="33_A_24"></a>3.3 为什么A*算法适用于八数码问题</h3> 
<ul><li>A* 算法适用于图搜索问题，本质上，八数码问题的每一种状态都可以看成是图中的一个节点，所以可以使用A* 算法求解</li><li>在这里，从<strong>起始节点到当前节点的实际代价</strong>为从<strong>起始状态到当前状态的步骤数</strong>，而从<strong>当前节点到目标节点的估计代价</strong>我们使用<strong>当前状态到目标状态的曼哈顿距离</strong>来估计</li></ul> 
<blockquote> 
 <ul><li> <p>在二维坐标系中，两点 (x1, y1) 和 (x2, y2) 之间的曼哈顿距离可以用以下公式表示： Manhattandistance = ∣x2−x1∣+∣y2−y1∣</p> </li><li> <p>这里我们计算八数码中<strong>每一个元素到其最终位置的曼哈顿距离的和</strong>作为<strong>当前状态到目标状态的曼哈顿距离</strong></p> </li></ul> 
</blockquote> 
<h3><a id="34_A__32"></a>3.4 A* 算法的基本框架</h3> 
<ul><li>主体</li></ul> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">search_with_priority_queue</span><span class="token punctuation">(</span>graph<span class="token punctuation">,</span> start<span class="token punctuation">,</span> goal<span class="token punctuation">,</span> heuristic<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
    使用优先队列进行搜索的函数

    参数:
    graph: 表示图的数据结构
    start: 起始节点
    goal: 目标节点
    heuristic: 启发式函数

    返回值:
    came_from: 包含每个节点的前驱节点信息的字典
    cost_so_far: 到达每个节点的当前最小成本路径的字典
    """</span>

    <span class="token comment"># 创建一个优先队列,用于存储待探索的节点</span>
    frontier <span class="token operator">=</span> PriorityQueue<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment"># 将起始节点 start 加入到优先队列中,并将其优先级设为 0</span>
    frontier<span class="token punctuation">.</span>put<span class="token punctuation">(</span>start<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token comment"># 创建一个字典,用于记录每个节点的前驱节点</span>
    came_from <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
    <span class="token comment"># 创建一个字典,用于记录到达每个节点的当前最小成本路径</span>
    cost_so_far <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
    <span class="token comment"># 初始化起始节点的前驱为 None,并将到达起始节点的成本设为 0</span>
    came_from<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span>
    cost_so_far<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>

    <span class="token comment"># 进入一个 while 循环,直到 frontier 中不再有待探索的节点</span>
    <span class="token keyword">while</span> <span class="token keyword">not</span> frontier<span class="token punctuation">.</span>empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 从优先队列中取出优先级最高的节点作为当前节点</span>
        current <span class="token operator">=</span> frontier<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token comment"># 判断当前节点是否为目标节点,如果是,则退出循环</span>
        <span class="token keyword">if</span> current <span class="token operator">==</span> goal<span class="token punctuation">:</span>
            <span class="token keyword">break</span>

        <span class="token comment"># 遍历当前节点的相邻节点 next</span>
        <span class="token keyword">for</span> <span class="token builtin">next</span> <span class="token keyword">in</span> graph<span class="token punctuation">.</span>neighbors<span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># 计算从起始节点到 next 节点的成本</span>
            new_cost <span class="token operator">=</span> cost_so_far<span class="token punctuation">[</span>current<span class="token punctuation">]</span> <span class="token operator">+</span> graph<span class="token punctuation">.</span>cost<span class="token punctuation">(</span>current<span class="token punctuation">,</span> <span class="token builtin">next</span><span class="token punctuation">)</span>
            <span class="token comment"># 如果 next 节点尚未在 cost_so_far 中记录或者新成本小于之前记录的成本</span>
            <span class="token keyword">if</span> <span class="token builtin">next</span> <span class="token keyword">not</span> <span class="token keyword">in</span> cost_so_far <span class="token keyword">or</span> new_cost <span class="token operator">&lt;</span> cost_so_far<span class="token punctuation">[</span><span class="token builtin">next</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                <span class="token comment"># 更新 cost_so_far 中 next 节点的成本</span>
                cost_so_far<span class="token punctuation">[</span><span class="token builtin">next</span><span class="token punctuation">]</span> <span class="token operator">=</span> new_cost
                <span class="token comment"># 计算从起始节点到 next 节点的启发式估计成本,并将其作为优先级</span>
                priority <span class="token operator">=</span> new_cost <span class="token operator">+</span> heuristic<span class="token punctuation">(</span>goal<span class="token punctuation">,</span> <span class="token builtin">next</span><span class="token punctuation">)</span>
                <span class="token comment"># 将 next 节点加入到优先队列中,并设置其优先级</span>
                frontier<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token builtin">next</span><span class="token punctuation">,</span> priority<span class="token punctuation">)</span>
                <span class="token comment"># 更新 came_from 中 next 节点的前驱节点为当前节点 current</span>
                came_from<span class="token punctuation">[</span><span class="token builtin">next</span><span class="token punctuation">]</span> <span class="token operator">=</span> current

    <span class="token keyword">return</span> came_from<span class="token punctuation">,</span> cost_so_far
</code></pre> 
<ul><li>根据前驱字典 came_from 构造出找到的路径</li></ul> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">generate_path</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> goal<span class="token punctuation">,</span> came_from<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
    生成路径的函数

    参数:
    start: 起点位置
    goal: 终点位置
    came_from: 包含每个位置的前驱位置信息的字典

    返回值:
    path: 从起点到终点的路径列表
    """</span>
    current <span class="token operator">=</span> goal  <span class="token comment"># 将当前位置设置为终点</span>
    path <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment"># 初始化路径为空列表</span>

    <span class="token keyword">if</span> goal <span class="token keyword">not</span> <span class="token keyword">in</span> came_from<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"无解"</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment"># 如果终点没有前驱位置，直接返回空路径</span>

    <span class="token keyword">while</span> current <span class="token operator">!=</span> start<span class="token punctuation">:</span>  <span class="token comment"># 当前位置不是起点时执行循环</span>
        path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>current<span class="token punctuation">)</span>  <span class="token comment"># 将当前位置添加到路径中</span>
        current <span class="token operator">=</span> came_from<span class="token punctuation">[</span>current<span class="token punctuation">]</span>  <span class="token comment"># 更新当前位置为其前驱位置</span>

    path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>start<span class="token punctuation">)</span>  <span class="token comment"># 将起点添加到路径中（可选）</span>
    path<span class="token punctuation">.</span>reverse<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 反转路径，将起点放在第一个位置（可选）</span>
    <span class="token keyword">return</span> path
</code></pre> 
<h2><a id="4_A__120"></a>4 A* 算法如何解决八数码问题</h2> 
<p>使用python进行编程。</p> 
<h3><a id="41__122"></a>4.1 八数码状态的存储</h3> 
<p>在 python 中，我们使用二维列表进行八数码初始状态和目标状态的存储</p> 
<pre><code class="prism language-python"><span class="token comment"># 初始状态</span>
initial_state <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span>
<span class="token punctuation">]</span>

<span class="token comment"># 目标状态</span>
goal_state <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">]</span>
</code></pre> 
<h3><a id="42__140"></a>4.2 启发式函数</h3> 
<p>从<strong>当前节点到目标节点的估计代价</strong>我们使用<strong>当前状态到目标状态的曼哈顿距离</strong>来估计，这里我们计算八数码中<strong>每一个元素到其最终位置的曼哈顿距离的和</strong>作为<strong>当前状态到目标状态的曼哈顿距离</strong></p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">manhattan_distance</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> goal_map<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
    计算曼哈顿距离

    参数:
    state (list): 表示当前状态的二维列表。
    goal_map (dict): 将数值映射到其在目标二维列表中索引的字典。

    返回:
    int: 当前状态与目标状态之间的曼哈顿距离。
    """</span>
    distance <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>state<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            value <span class="token operator">=</span> state<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>
            <span class="token keyword">if</span> value <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>
                goal_pos <span class="token operator">=</span> goal_map<span class="token punctuation">[</span>value<span class="token punctuation">]</span>
                distance <span class="token operator">+=</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>i <span class="token operator">-</span> goal_pos<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>j <span class="token operator">-</span> goal_pos<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> distance
</code></pre> 
<h3><a id="43__166"></a>4.3 构造目标状态元素位置的字典</h3> 
<ul><li>在启发式函数中，传入的参数是当前状态的二维列表，以及目标状态元素位置的字典</li><li>因为当前状态每次传入的参数都不一定，所以使用二维列表；而目标状态是固定的，所以使用一个字典进行元素位置的记录，提高启发式函数中曼哈顿函数的计算效率</li></ul> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">index_mapping_2d</span><span class="token punctuation">(</span>lst<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
    创建一个将数值映射到其在二维列表中索引的映射关系。

    参数:
    lst (list): 一个二维数值列表。

    返回:
    dict: 一个字典，其中键是二维列表中的数值，值是它们在列表中的索引的元组。
    """</span>
    index_map <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>lst<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>lst<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            val <span class="token operator">=</span> lst<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>
            index_map<span class="token punctuation">[</span>val<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span>
    <span class="token keyword">return</span> index_map
</code></pre> 
<h3><a id="44__188"></a>4.4 在二维列表中查找目标元素</h3> 
<p>在寻找路径的过程中，我们通过空位（此处用0代表）的移动来进行边界的扩展，所以在每次移动之前都要找到元素0的位置，于是我们需要一个在二维列表中查找目标元素的函数</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">find_element_in_2d_list</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
    在二维列表中查找目标元素
    :param arr: 二维列表，待查找的目标元素所在的列表
    :param target: 目标元素，要在二维列表中查找的元素
    :return: 如果目标元素存在于二维列表中，则返回其索引 (i, j)；如果目标元素不存在，则返回 None
    """</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">:</span>
                <span class="token keyword">return</span> i<span class="token punctuation">,</span> j
    <span class="token keyword">return</span> <span class="token boolean">None</span>
</code></pre> 
<h3><a id="45_A__205"></a>4.5 A* 算法主体</h3> 
<p>有几个注意点：</p> 
<ul><li>优先队列的使用：<br> 使用优先队列（小顶堆）存储下一个要检查的状态，以优先级（此处为成本）排序，数字小（成本低）的先进行检查</li></ul> 
<pre><code class="prism language-python"><span class="token keyword">import</span> heapq  <span class="token comment"># 优先队列（堆）</span>

frontier <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment"># 待探索节点（边界），以空的优先队列实现，成本低的先探索</span>
heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>frontier<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> initial_state<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p>这两句代码的意思是：使用列表作为小顶堆的存储，并使用heapq方法进行小顶堆的构建，<code>(0, initial_state)</code> 中，0为成本（此处因为是初始状态所以成本最低，为0），小顶堆以此排序；而 initial_state 就是初始状态的二维列表</p> 
<ul><li>哈希表键的处理：<br> 可变对象不可哈希，所以不能作为哈希表的键使用，需要转换为元组才能作为键</li></ul> 
<pre><code class="prism language-python">came_from <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 记录每个节点的前驱节点</span>
initial_state_tuple <span class="token operator">=</span> <span class="token builtin">tuple</span><span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">tuple</span><span class="token punctuation">,</span> initial_state<span class="token punctuation">)</span><span class="token punctuation">)</span>
came_from<span class="token punctuation">[</span>initial_state_tuple<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span>  <span class="token comment"># 起始状态的前驱状态设置为0</span>
</code></pre> 
<p>而且注意，此处的 <code>initial_state</code> 是二维列表，需要使用两层 tuple 将每一行也转为 tuple，不能整个转换</p> 
<ul><li>列表的深拷贝<br> 对当前状态 current 相邻状态的探索中，一般情况下最多有上下左右四个方向可以探索，此时在循环中以 current 为开始计算 next 状态，注意要对 current 进行深拷贝，否则对 next 的操作会修改到 current 的值，导致结果出错</li></ul> 
<pre><code class="prism language-python"><span class="token keyword">import</span> copy

<span class="token keyword">for</span> direc <span class="token keyword">in</span> zero_move_direcs<span class="token punctuation">:</span>
	<span class="token builtin">next</span> <span class="token operator">=</span> copy<span class="token punctuation">.</span>deepcopy<span class="token punctuation">(</span>current<span class="token punctuation">)</span>
    <span class="token comment"># 将0移动到下一个状态的位置</span>
    <span class="token builtin">next</span><span class="token punctuation">[</span>new_x_zero<span class="token punctuation">]</span><span class="token punctuation">[</span>new_y_zero<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token builtin">next</span><span class="token punctuation">[</span>x_zero<span class="token punctuation">]</span><span class="token punctuation">[</span>y_zero<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">next</span><span class="token punctuation">[</span>x_zero<span class="token punctuation">]</span><span class="token punctuation">[</span>y_zero<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token builtin">next</span><span class="token punctuation">[</span>new_x_zero<span class="token punctuation">]</span><span class="token punctuation">[</span>new_y_zero<span class="token punctuation">]</span>
</code></pre> 
<ul><li>算法主体</li></ul> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">AStar</span><span class="token punctuation">(</span>initial_state<span class="token punctuation">,</span> goal_state<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
        使用A*算法搜索路径
        :param initial_state: 初始状态
        :param goal_state: 目标状态
        :return: 每个节点的前驱节点字典
    """</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"__开始进行AStar搜索__"</span><span class="token punctuation">)</span>
    goal_map <span class="token operator">=</span> index_mapping_2d<span class="token punctuation">(</span>goal_state<span class="token punctuation">)</span>
    frontier <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment"># 待探索节点（边界），以空的优先队列实现，成本低的先探索</span>
    heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>frontier<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> initial_state<span class="token punctuation">)</span><span class="token punctuation">)</span>
    came_from <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 记录每个节点的前驱节点</span>
    min_cost <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 记录目前位置探索过的节点的最小成本</span>
    initial_state_tuple <span class="token operator">=</span> <span class="token builtin">tuple</span><span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">tuple</span><span class="token punctuation">,</span> initial_state<span class="token punctuation">)</span><span class="token punctuation">)</span>
    came_from<span class="token punctuation">[</span>initial_state_tuple<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span>  <span class="token comment"># 起始状态的前驱状态设置为0</span>
    min_cost<span class="token punctuation">[</span>initial_state_tuple<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># 到达起始状态的成本设置为0</span>
    zero_move_direcs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># 0的移动方向</span>
    <span class="token keyword">while</span> frontier<span class="token punctuation">:</span>  <span class="token comment"># 进行探索，直到 frontier 中没有待探索的状态</span>
        _<span class="token punctuation">,</span> current <span class="token operator">=</span> heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>frontier<span class="token punctuation">)</span>  <span class="token comment"># 探索优先级最高的状态</span>
        <span class="token keyword">if</span> current <span class="token operator">==</span> goal_state<span class="token punctuation">:</span>
            <span class="token keyword">break</span>
        <span class="token comment"># 遍历当前状态的相邻状态</span>
        current_state_tuple <span class="token operator">=</span> <span class="token builtin">tuple</span><span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">tuple</span><span class="token punctuation">,</span> current<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 当前状态转为tuple以便哈希</span>
        x_zero<span class="token punctuation">,</span> y_zero <span class="token operator">=</span> find_element_in_2d_list<span class="token punctuation">(</span>current<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment"># 找到0所在位置</span>
        <span class="token keyword">for</span> direc <span class="token keyword">in</span> zero_move_direcs<span class="token punctuation">:</span>
            <span class="token comment"># 计算下一个状态0所在的位置</span>
            new_x_zero <span class="token operator">=</span> x_zero <span class="token operator">+</span> direc<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
            new_y_zero <span class="token operator">=</span> y_zero <span class="token operator">+</span> direc<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
            <span class="token comment"># 检查该状态0的位置是否合法</span>
            <span class="token keyword">if</span> new_x_zero <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token keyword">or</span> new_y_zero <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token keyword">or</span> new_x_zero <span class="token operator">&gt;=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>initial_state<span class="token punctuation">)</span> <span class="token keyword">or</span> new_y_zero <span class="token operator">&gt;=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>
                    initial_state<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">continue</span>
            <span class="token comment"># 计算从起始状态到next状态的成本，这里由于0不管往哪个方向移动成本都一致，所以next状态成本直接+1即可</span>
            new_cost <span class="token operator">=</span> min_cost<span class="token punctuation">[</span>current_state_tuple<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>
            <span class="token builtin">next</span> <span class="token operator">=</span> copy<span class="token punctuation">.</span>deepcopy<span class="token punctuation">(</span>current<span class="token punctuation">)</span>
            <span class="token comment"># 将0移动到下一个状态的位置</span>
            <span class="token builtin">next</span><span class="token punctuation">[</span>new_x_zero<span class="token punctuation">]</span><span class="token punctuation">[</span>new_y_zero<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token builtin">next</span><span class="token punctuation">[</span>x_zero<span class="token punctuation">]</span><span class="token punctuation">[</span>y_zero<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">next</span><span class="token punctuation">[</span>x_zero<span class="token punctuation">]</span><span class="token punctuation">[</span>y_zero<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token builtin">next</span><span class="token punctuation">[</span>new_x_zero<span class="token punctuation">]</span><span class="token punctuation">[</span>new_y_zero<span class="token punctuation">]</span>
            next_state_tuple <span class="token operator">=</span> <span class="token builtin">tuple</span><span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">tuple</span><span class="token punctuation">,</span> <span class="token builtin">next</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> next_state_tuple <span class="token keyword">not</span> <span class="token keyword">in</span> min_cost <span class="token keyword">or</span> new_cost <span class="token operator">&lt;</span> min_cost<span class="token punctuation">[</span>next_state_tuple<span class="token punctuation">]</span><span class="token punctuation">:</span>
                <span class="token comment"># 更新next状态的成本</span>
                min_cost<span class="token punctuation">[</span>next_state_tuple<span class="token punctuation">]</span> <span class="token operator">=</span> new_cost
                <span class="token comment"># 使用曼哈顿距离计算next的启发式估计成本（initial到next的准确成本 + next到goal的估计成本）</span>
                priority_cost <span class="token operator">=</span> new_cost <span class="token operator">+</span> manhattan_distance<span class="token punctuation">(</span><span class="token builtin">next</span><span class="token punctuation">,</span> goal_map<span class="token punctuation">)</span>
                <span class="token comment"># 将next状态以计算出的启发式估计成本加入优先队列中</span>
                heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>frontier<span class="token punctuation">,</span> <span class="token punctuation">(</span>priority_cost<span class="token punctuation">,</span> <span class="token builtin">next</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                came_from<span class="token punctuation">[</span>next_state_tuple<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">tuple</span><span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">tuple</span><span class="token punctuation">,</span> current<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> came_from
</code></pre> 
<h3><a id="46__288"></a>4.6 路径构造函数</h3> 
<ul><li>在A* 搜索完成后，使用返回的 came_from 字典构建从初始状态的目标状态的函数</li><li>由于八数码问题可能有无解的情况，所以需要判断目标状态是否在 came_from 中，也就是判断是否找到了解</li><li>由于 came_from 记录的键值对是 “当前节点：前驱节点” ，所以需要从目标状态开始遍历，直到初始状态，最后输出的时候进行反转</li></ul> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">build_path</span><span class="token punctuation">(</span>initial_state<span class="token punctuation">,</span> goal_state<span class="token punctuation">,</span> came_from<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
    构建路径并输出，以找到从初始状态到目标状态的路径。

    参数：
    initial_state: 二维列表，代表初始状态
    goal_state: 二维列表，代表目标状态
    came_from: 字典，记录每个状态是从哪个状态转移而来

    返回值：
    无返回值，直接打印输出路径信息
    """</span>
    <span class="token comment"># 将二维列表转换为元组</span>
    initial_state_tuple <span class="token operator">=</span> <span class="token builtin">tuple</span><span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">tuple</span><span class="token punctuation">,</span> initial_state<span class="token punctuation">)</span><span class="token punctuation">)</span>
    goal_state_tuple <span class="token operator">=</span> <span class="token builtin">tuple</span><span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">tuple</span><span class="token punctuation">,</span> goal_state<span class="token punctuation">)</span><span class="token punctuation">)</span>
    current_tuple <span class="token operator">=</span> goal_state_tuple
    path <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    have_solution <span class="token operator">=</span> <span class="token boolean">True</span>

    <span class="token comment"># 回溯找到路径</span>
    <span class="token keyword">while</span> current_tuple <span class="token operator">!=</span> initial_state_tuple<span class="token punctuation">:</span>
        <span class="token keyword">if</span> goal_state_tuple <span class="token keyword">not</span> <span class="token keyword">in</span> came_from<span class="token punctuation">:</span>
            have_solution <span class="token operator">=</span> <span class="token boolean">False</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"无解"</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>current_tuple<span class="token punctuation">)</span>
            current_tuple <span class="token operator">=</span> came_from<span class="token punctuation">[</span>current_tuple<span class="token punctuation">]</span>

    <span class="token comment"># 如果有解，则输出路径</span>
    <span class="token keyword">if</span> have_solution<span class="token punctuation">:</span>
        path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>initial_state_tuple<span class="token punctuation">)</span>
        path<span class="token punctuation">.</span>reverse<span class="token punctuation">(</span><span class="token punctuation">)</span>
        step <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">for</span> state <span class="token keyword">in</span> path<span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"步骤"</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>step<span class="token punctuation">)</span><span class="token punctuation">)</span>
            step <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">for</span> row <span class="token keyword">in</span> state<span class="token punctuation">:</span>
                <span class="token keyword">print</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<h3><a id="47__335"></a>4.7 函数调用</h3> 
<pre><code class="prism language-python"><span class="token comment"># 使用A*算法求解路径</span>
came_from <span class="token operator">=</span> AStar<span class="token punctuation">(</span>initial_state<span class="token punctuation">,</span> goal_state<span class="token punctuation">)</span>
<span class="token comment"># 进行路径构建</span>
build_path<span class="token punctuation">(</span>initial_state<span class="token punctuation">,</span> goal_state<span class="token punctuation">,</span> came_from<span class="token punctuation">)</span>
</code></pre> 
<h3><a id="48__342"></a>4.8 全部代码</h3> 
<pre><code class="prism language-python"><span class="token keyword">import</span> heapq  <span class="token comment"># 优先队列（堆）</span>
<span class="token keyword">import</span> copy


<span class="token keyword">def</span> <span class="token function">manhattan_distance</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> goal_map<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
    计算曼哈顿距离

    参数:
    state (list): 表示当前状态的二维列表。
    goal_map (dict): 将数值映射到其在目标二维列表中索引的字典。

    返回:
    int: 当前状态与目标状态之间的曼哈顿距离。
    """</span>
    distance <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>state<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            value <span class="token operator">=</span> state<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>
            <span class="token keyword">if</span> value <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>
                goal_pos <span class="token operator">=</span> goal_map<span class="token punctuation">[</span>value<span class="token punctuation">]</span>
                distance <span class="token operator">+=</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>i <span class="token operator">-</span> goal_pos<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>j <span class="token operator">-</span> goal_pos<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> distance


<span class="token keyword">def</span> <span class="token function">index_mapping_2d</span><span class="token punctuation">(</span>lst<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
    创建一个将数值映射到其在二维列表中索引的映射关系。

    参数:
    lst (list): 一个二维数值列表。

    返回:
    dict: 一个字典，其中键是二维列表中的数值，值是它们在列表中的索引的元组。
    """</span>
    index_map <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>lst<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>lst<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            val <span class="token operator">=</span> lst<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>
            index_map<span class="token punctuation">[</span>val<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span>
    <span class="token keyword">return</span> index_map


<span class="token keyword">def</span> <span class="token function">find_element_in_2d_list</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
    在二维列表中查找目标元素
    :param arr: 二维列表，待查找的目标元素所在的列表
    :param target: 目标元素，要在二维列表中查找的元素
    :return: 如果目标元素存在于二维列表中，则返回其索引 (i, j)；如果目标元素不存在，则返回 None
    """</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">:</span>
                <span class="token keyword">return</span> i<span class="token punctuation">,</span> j
    <span class="token keyword">return</span> <span class="token boolean">None</span>


<span class="token keyword">def</span> <span class="token function">AStar</span><span class="token punctuation">(</span>initial_state<span class="token punctuation">,</span> goal_state<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
        使用A*算法搜索路径
        :param initial_state: 初始状态
        :param goal_state: 目标状态
        :return: 每个节点的前驱节点字典
    """</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"__开始进行AStar搜索__"</span><span class="token punctuation">)</span>
    goal_map <span class="token operator">=</span> index_mapping_2d<span class="token punctuation">(</span>goal_state<span class="token punctuation">)</span>
    frontier <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment"># 待探索节点（边界），以空的优先队列实现，成本低的先探索</span>
    heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>frontier<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> initial_state<span class="token punctuation">)</span><span class="token punctuation">)</span>
    came_from <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 记录每个节点的前驱节点</span>
    min_cost <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 记录目前位置探索过的节点的最小成本</span>
    initial_state_tuple <span class="token operator">=</span> <span class="token builtin">tuple</span><span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">tuple</span><span class="token punctuation">,</span> initial_state<span class="token punctuation">)</span><span class="token punctuation">)</span>
    came_from<span class="token punctuation">[</span>initial_state_tuple<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span>  <span class="token comment"># 起始状态的前驱状态设置为0</span>
    min_cost<span class="token punctuation">[</span>initial_state_tuple<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># 到达起始状态的成本设置为0</span>
    zero_move_direcs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># 0的移动方向</span>
    <span class="token keyword">while</span> frontier<span class="token punctuation">:</span>  <span class="token comment"># 进行探索，直到 frontier 中没有待探索的状态</span>
        _<span class="token punctuation">,</span> current <span class="token operator">=</span> heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>frontier<span class="token punctuation">)</span>  <span class="token comment"># 探索优先级最高的状态</span>
        <span class="token keyword">if</span> current <span class="token operator">==</span> goal_state<span class="token punctuation">:</span>
            <span class="token keyword">break</span>
        <span class="token comment"># 遍历当前状态的相邻状态</span>
        current_state_tuple <span class="token operator">=</span> <span class="token builtin">tuple</span><span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">tuple</span><span class="token punctuation">,</span> current<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 当前状态转为tuple以便哈希</span>
        x_zero<span class="token punctuation">,</span> y_zero <span class="token operator">=</span> find_element_in_2d_list<span class="token punctuation">(</span>current<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment"># 找到0所在位置</span>
        <span class="token keyword">for</span> direc <span class="token keyword">in</span> zero_move_direcs<span class="token punctuation">:</span>
            <span class="token comment"># 计算下一个状态0所在的位置</span>
            new_x_zero <span class="token operator">=</span> x_zero <span class="token operator">+</span> direc<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
            new_y_zero <span class="token operator">=</span> y_zero <span class="token operator">+</span> direc<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
            <span class="token comment"># 检查该状态0的位置是否合法</span>
            <span class="token keyword">if</span> new_x_zero <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token keyword">or</span> new_y_zero <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token keyword">or</span> new_x_zero <span class="token operator">&gt;=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>initial_state<span class="token punctuation">)</span> <span class="token keyword">or</span> new_y_zero <span class="token operator">&gt;=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>
                    initial_state<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">continue</span>
            <span class="token comment"># 计算从起始状态到next状态的成本，这里由于0不管往哪个方向移动成本都一致，所以next状态成本直接+1即可</span>
            new_cost <span class="token operator">=</span> min_cost<span class="token punctuation">[</span>current_state_tuple<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>
            <span class="token builtin">next</span> <span class="token operator">=</span> copy<span class="token punctuation">.</span>deepcopy<span class="token punctuation">(</span>current<span class="token punctuation">)</span>
            <span class="token comment"># 将0移动到下一个状态的位置</span>
            <span class="token builtin">next</span><span class="token punctuation">[</span>new_x_zero<span class="token punctuation">]</span><span class="token punctuation">[</span>new_y_zero<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token builtin">next</span><span class="token punctuation">[</span>x_zero<span class="token punctuation">]</span><span class="token punctuation">[</span>y_zero<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">next</span><span class="token punctuation">[</span>x_zero<span class="token punctuation">]</span><span class="token punctuation">[</span>y_zero<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token builtin">next</span><span class="token punctuation">[</span>new_x_zero<span class="token punctuation">]</span><span class="token punctuation">[</span>new_y_zero<span class="token punctuation">]</span>
            next_state_tuple <span class="token operator">=</span> <span class="token builtin">tuple</span><span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">tuple</span><span class="token punctuation">,</span> <span class="token builtin">next</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> next_state_tuple <span class="token keyword">not</span> <span class="token keyword">in</span> min_cost <span class="token keyword">or</span> new_cost <span class="token operator">&lt;</span> min_cost<span class="token punctuation">[</span>next_state_tuple<span class="token punctuation">]</span><span class="token punctuation">:</span>
                <span class="token comment"># 更新next状态的成本</span>
                min_cost<span class="token punctuation">[</span>next_state_tuple<span class="token punctuation">]</span> <span class="token operator">=</span> new_cost
                <span class="token comment"># 使用曼哈顿距离计算next的启发式估计成本（initial到next的准确成本 + next到goal的估计成本）</span>
                priority_cost <span class="token operator">=</span> new_cost <span class="token operator">+</span> manhattan_distance<span class="token punctuation">(</span><span class="token builtin">next</span><span class="token punctuation">,</span> goal_map<span class="token punctuation">)</span>
                <span class="token comment"># 将next状态以计算出的启发式估计成本加入优先队列中</span>
                heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>frontier<span class="token punctuation">,</span> <span class="token punctuation">(</span>priority_cost<span class="token punctuation">,</span> <span class="token builtin">next</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                came_from<span class="token punctuation">[</span>next_state_tuple<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">tuple</span><span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">tuple</span><span class="token punctuation">,</span> current<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> came_from


<span class="token keyword">def</span> <span class="token function">build_path</span><span class="token punctuation">(</span>initial_state<span class="token punctuation">,</span> goal_state<span class="token punctuation">,</span> came_from<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
    构建路径并输出，以找到从初始状态到目标状态的路径。

    参数：
    initial_state: 二维列表，代表初始状态
    goal_state: 二维列表，代表目标状态
    came_from: 字典，记录每个状态是从哪个状态转移而来

    返回值：
    无返回值，直接打印输出路径信息
    """</span>
    <span class="token comment"># 将二维列表转换为元组</span>
    initial_state_tuple <span class="token operator">=</span> <span class="token builtin">tuple</span><span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">tuple</span><span class="token punctuation">,</span> initial_state<span class="token punctuation">)</span><span class="token punctuation">)</span>
    goal_state_tuple <span class="token operator">=</span> <span class="token builtin">tuple</span><span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">tuple</span><span class="token punctuation">,</span> goal_state<span class="token punctuation">)</span><span class="token punctuation">)</span>
    current_tuple <span class="token operator">=</span> goal_state_tuple
    path <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    have_solution <span class="token operator">=</span> <span class="token boolean">True</span>

    <span class="token comment"># 回溯找到路径</span>
    <span class="token keyword">while</span> current_tuple <span class="token operator">!=</span> initial_state_tuple<span class="token punctuation">:</span>
        <span class="token keyword">if</span> goal_state_tuple <span class="token keyword">not</span> <span class="token keyword">in</span> came_from<span class="token punctuation">:</span>
            have_solution <span class="token operator">=</span> <span class="token boolean">False</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"无解"</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>current_tuple<span class="token punctuation">)</span>
            current_tuple <span class="token operator">=</span> came_from<span class="token punctuation">[</span>current_tuple<span class="token punctuation">]</span>

    <span class="token comment"># 如果有解，则输出路径</span>
    <span class="token keyword">if</span> have_solution<span class="token punctuation">:</span>
        path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>initial_state_tuple<span class="token punctuation">)</span>
        path<span class="token punctuation">.</span>reverse<span class="token punctuation">(</span><span class="token punctuation">)</span>
        step <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">for</span> state <span class="token keyword">in</span> path<span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"步骤"</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>step<span class="token punctuation">)</span><span class="token punctuation">)</span>
            step <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">for</span> row <span class="token keyword">in</span> state<span class="token punctuation">:</span>
                <span class="token keyword">print</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>


<span class="token comment"># 初始状态</span>
initial_state <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span>
<span class="token punctuation">]</span>

<span class="token comment"># 目标状态</span>
goal_state <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">]</span>

<span class="token comment"># 使用A*算法求解路径</span>
came_from <span class="token operator">=</span> AStar<span class="token punctuation">(</span>initial_state<span class="token punctuation">,</span> goal_state<span class="token punctuation">)</span>
<span class="token comment"># 进行路径构建</span>
build_path<span class="token punctuation">(</span>initial_state<span class="token punctuation">,</span> goal_state<span class="token punctuation">,</span> came_from<span class="token punctuation">)</span>
</code></pre> 
<h3><a id="49__513"></a>4.9 运行结果</h3> 
<ul><li>当有解时，是下面的形式，无解则直接显示 “无解”</li></ul> 
<pre><code class="prism language-python">__开始进行AStar搜索__
步骤<span class="token number">0</span>
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span>

步骤<span class="token number">1</span>
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
进程已结束，退出代码为 <span class="token number">0</span>
</code></pre> 
<h2><a id="5__530"></a>5 拓展：八数码问题有无解的讨论</h2> 
<h3><a id="51__531"></a>5.1 逆序</h3> 
<ul><li>将八数码问题的状态表示成一维形式，即从左到右依次排列 9 个数字。</li><li>除 0 之外的每个数字前面比它大的数字的个数，称为该数字的逆序数。</li><li>一个状态的逆序，是指所有数字的逆序数之和。</li></ul> 
<h3><a id="52__536"></a>5.2 逆序奇偶性与可解性</h3> 
<ul><li>若两个状态的逆序奇偶性相同，则这两个状态可相互到达。</li><li>若两个状态的逆序奇偶性不同，则这两个状态不可相互到达。</li></ul> 
<h3><a id="53__540"></a>5.3 逆序不变性</h3> 
<ul><li>左右移动空格不会改变逆序。</li><li>上下移动空格相当于将一个数字向前（或向后）移动两格，跳过两个数字。</li><li>若跳过的两个数字都比它大（或小），则逆序可能增加或减少 2。</li><li>若跳过的两个数字一个较大一个较小，则逆序不变。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2f09285930f62a125d2c5af09f19544b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">深度学习之详解常见梯度算法(概念、公式、原理、算法实现过程)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7f447ba412040d61fbbb757f2e8b136f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java Web实验八：按照JSP Model2思想实现注册功能</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>