<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43; 引用（&amp;）的超详细解析（小白必看系列） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/7443ff6fadae5bcc452d5611d5573244/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C&#43;&#43; 引用（&）的超详细解析（小白必看系列）">
  <meta property="og:description" content="目录
一、前言
二、引用的概念介绍
三、引用的五大特性 💦 引用在定义时必须初始化
💦 一个变量可以有多个引用
💦 一个引用可以继续有引用
💦 引用一旦引用一个实体，再不能引用其他实体
💦 可以对任何类型做引用【变量、指针…】
四、引用的两种使用场景
1、做参数
a.案例一：交换两数
b.案例二：单链表的头结点修改【SLNode*&amp; p】
2、做返回值【⭐⭐⭐】
① 引入：栈区与静态区的对比 ② 优化：传引用返回【权力反转】
③ 理解：引用返回的危害 - 造成未定义的行为【薛定谔的猫🐱】
④ 结语：正确认识【传值返回】与【传引用返回】
五、传值、传引用效率对比
1、函数传参对比
2、返回值的对比
六、常引用
1、权限放大【×】
2、权限保持【✔】
3、权限缩小【✔】
4、拓展
4.1如何给常量取别名 4.2临时变量具有常性（重点） 5、 对权限控制的用处
七、引用与指针的区别总结
八、总结与提炼 九、共勉
一、前言 本次博客来讲解以下C&#43;&#43; 的 引用 是如何运用的。那么问题来了，为什么要用到引用？用C语言中的指针不是挺好的吗 ？
其实，在C语言中的指针会引发很多的难题，比如【两数交换】的时候因为函数内部的概念不会引发外部的变化，使得我们需要传入两个需要交换数的地址，在函数内部进行解引用才可才可以交换二者的值
另一块就是在数据结构中的【单链表】，面对二级指针的恐惧😱是否还伴随在你的身边，因为考虑到要修改单链表的头结点，所以光是传入指针然后用指针来接受还不够，面对普通变量要使用一指针来进行修改，那对于一级指针就需要用到二级指针来进行修改，此时我们就要传入一级指针的地址，才可以在函数内部真正得修改这个单链表的结构
所以，为了解决上述简化上述问题，C&#43;&#43;中引入了一大特性 —— 【引用】，在学习了引用之后，就不要担心是否要传入变量的地址还是指针的地址啦，然后我们一起来学习吧！
二、引用的概念介绍 引用不是新定义一个变量，而是给已存在变量取了一个别名，编译器不会为引用变量开辟内存空间，它和它引用的变量共用同一块内存空间
比如：李逵，在家称为&#34;铁牛&#34;，江湖上人称&#34;黑旋风&#34;。【水浒108将各个有称号】 ❓那要怎么去“引用”呢?❓
此时需要使用到我们在C语言中学习到的一个操作符叫做[&amp;]，它是【按位与】，也是【取地址】，但是在C&#43;&#43;中呢，它叫做【引用】
❓ 它的语法是怎样的呢?❓
类型&amp; 引用变量名(对象名) = 引用实体；
int a = 10; int&amp; b = a; // b 是 a 的别名 通过运行我们可以看到变量a和变量b的地址是一样的，这是为什么呢？就是因为b是a的引用，那b就相当于a，所以它们共用一块地址那既然他们公用一块地址的话，内容也是一样的。此时若是我去修改b的值，a是否和跟着改变呢？ 可以看到，若是去修改b的话，a也会跟着一起变化 三、引用的五大特性 💦 引用在定义时必须初始化">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-02-02T23:40:07+08:00">
    <meta property="article:modified_time" content="2024-02-02T23:40:07+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43; 引用（&amp;）的超详细解析（小白必看系列）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80" rel="nofollow">一、前言</a></p> 
<p id="%C2%A0%E4%BA%8C%E3%80%81%E5%BC%95%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%BA%8C%E3%80%81%E5%BC%95%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D" rel="nofollow"> 二、引用的概念介绍</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%BC%95%E7%94%A8%E7%9A%84%E4%BA%94%E5%A4%A7%E7%89%B9%E6%80%A7%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%BC%95%E7%94%A8%E7%9A%84%E4%BA%94%E5%A4%A7%E7%89%B9%E6%80%A7%C2%A0" rel="nofollow">三、引用的五大特性 </a></p> 
<p id="%C2%A0%F0%9F%92%A6%C2%A0%20%E5%BC%95%E7%94%A8%E5%9C%A8%E5%AE%9A%E4%B9%89%E6%97%B6%E5%BF%85%E9%A1%BB%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:40px;"><a href="#%C2%A0%F0%9F%92%A6%C2%A0%20%E5%BC%95%E7%94%A8%E5%9C%A8%E5%AE%9A%E4%B9%89%E6%97%B6%E5%BF%85%E9%A1%BB%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow"> 💦  引用在定义时必须初始化</a></p> 
<p id="%C2%A0%F0%9F%92%A6%C2%A0%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E4%B8%AA%E5%BC%95%E7%94%A8-toc" style="margin-left:40px;"><a href="#%C2%A0%F0%9F%92%A6%C2%A0%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E4%B8%AA%E5%BC%95%E7%94%A8" rel="nofollow"> 💦 一个变量可以有多个引用</a></p> 
<p id="%C2%A0%C2%A0%F0%9F%92%A6%C2%A0%E4%B8%80%E4%B8%AA%E5%BC%95%E7%94%A8%E5%8F%AF%E4%BB%A5%E7%BB%A7%E7%BB%AD%E6%9C%89%E5%BC%95%E7%94%A8-toc" style="margin-left:40px;"><a href="#%C2%A0%C2%A0%F0%9F%92%A6%C2%A0%E4%B8%80%E4%B8%AA%E5%BC%95%E7%94%A8%E5%8F%AF%E4%BB%A5%E7%BB%A7%E7%BB%AD%E6%9C%89%E5%BC%95%E7%94%A8" rel="nofollow">  💦 一个引用可以继续有引用</a></p> 
<p id="%F0%9F%92%A6%C2%A0%E5%BC%95%E7%94%A8%E4%B8%80%E6%97%A6%E5%BC%95%E7%94%A8%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BD%93%EF%BC%8C%E5%86%8D%E4%B8%8D%E8%83%BD%E5%BC%95%E7%94%A8%E5%85%B6%E4%BB%96%E5%AE%9E%E4%BD%93-toc" style="margin-left:40px;"><a href="#%F0%9F%92%A6%C2%A0%E5%BC%95%E7%94%A8%E4%B8%80%E6%97%A6%E5%BC%95%E7%94%A8%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BD%93%EF%BC%8C%E5%86%8D%E4%B8%8D%E8%83%BD%E5%BC%95%E7%94%A8%E5%85%B6%E4%BB%96%E5%AE%9E%E4%BD%93" rel="nofollow">💦 引用一旦引用一个实体，再不能引用其他实体</a></p> 
<p id="%C2%A0%F0%9F%92%A6%C2%A0%E5%8F%AF%E4%BB%A5%E5%AF%B9%E4%BB%BB%E4%BD%95%E7%B1%BB%E5%9E%8B%E5%81%9A%E5%BC%95%E7%94%A8%E3%80%90%E5%8F%98%E9%87%8F%E3%80%81%E6%8C%87%E9%92%88%E2%80%A6%E3%80%91-toc" style="margin-left:40px;"><a href="#%C2%A0%F0%9F%92%A6%C2%A0%E5%8F%AF%E4%BB%A5%E5%AF%B9%E4%BB%BB%E4%BD%95%E7%B1%BB%E5%9E%8B%E5%81%9A%E5%BC%95%E7%94%A8%E3%80%90%E5%8F%98%E9%87%8F%E3%80%81%E6%8C%87%E9%92%88%E2%80%A6%E3%80%91" rel="nofollow"> 💦 可以对任何类型做引用【变量、指针…】</a></p> 
<p id="%C2%A0%E5%9B%9B%E3%80%81%E5%BC%95%E7%94%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:0px;"><a href="#%C2%A0%E5%9B%9B%E3%80%81%E5%BC%95%E7%94%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow"> 四、引用的两种使用场景</a></p> 
<p id="%C2%A01%E3%80%81%E5%81%9A%E5%8F%82%E6%95%B0-toc" style="margin-left:40px;"><a href="#%C2%A01%E3%80%81%E5%81%9A%E5%8F%82%E6%95%B0" rel="nofollow"> 1、做参数</a></p> 
<p id="%C2%A0a.%E6%A1%88%E4%BE%8B%E4%B8%80%EF%BC%9A%E4%BA%A4%E6%8D%A2%E4%B8%A4%E6%95%B0-toc" style="margin-left:80px;"><a href="#%C2%A0a.%E6%A1%88%E4%BE%8B%E4%B8%80%EF%BC%9A%E4%BA%A4%E6%8D%A2%E4%B8%A4%E6%95%B0" rel="nofollow"> a.案例一：交换两数</a></p> 
<p id="%C2%A0b.%E6%A1%88%E4%BE%8B%E4%BA%8C%EF%BC%9A%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%B4%E7%BB%93%E7%82%B9%E4%BF%AE%E6%94%B9%E3%80%90SLNode*%26%20p%E3%80%91-toc" style="margin-left:80px;"><a href="#%C2%A0b.%E6%A1%88%E4%BE%8B%E4%BA%8C%EF%BC%9A%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%B4%E7%BB%93%E7%82%B9%E4%BF%AE%E6%94%B9%E3%80%90SLNode*%26%20p%E3%80%91" rel="nofollow"> b.案例二：单链表的头结点修改【SLNode*&amp; p】</a></p> 
<p id="2%E3%80%81%E5%81%9A%E8%BF%94%E5%9B%9E%E5%80%BC%E3%80%90%E2%AD%90%E2%AD%90%E2%AD%90%E3%80%91-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%81%9A%E8%BF%94%E5%9B%9E%E5%80%BC%E3%80%90%E2%AD%90%E2%AD%90%E2%AD%90%E3%80%91" rel="nofollow">2、做返回值【⭐⭐⭐】</a></p> 
<p id="%E2%91%A0%20%E5%BC%95%E5%85%A5%EF%BC%9A%E6%A0%88%E5%8C%BA%E4%B8%8E%E9%9D%99%E6%80%81%E5%8C%BA%E7%9A%84%E5%AF%B9%E6%AF%94%C2%A0-toc" style="margin-left:80px;"><a href="#%E2%91%A0%20%E5%BC%95%E5%85%A5%EF%BC%9A%E6%A0%88%E5%8C%BA%E4%B8%8E%E9%9D%99%E6%80%81%E5%8C%BA%E7%9A%84%E5%AF%B9%E6%AF%94%C2%A0" rel="nofollow">① 引入：栈区与静态区的对比 </a></p> 
<p id="%C2%A0%E2%91%A1%20%E4%BC%98%E5%8C%96%EF%BC%9A%E4%BC%A0%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E%E3%80%90%E6%9D%83%E5%8A%9B%E5%8F%8D%E8%BD%AC%E3%80%91-toc" style="margin-left:80px;"><a href="#%C2%A0%E2%91%A1%20%E4%BC%98%E5%8C%96%EF%BC%9A%E4%BC%A0%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E%E3%80%90%E6%9D%83%E5%8A%9B%E5%8F%8D%E8%BD%AC%E3%80%91" rel="nofollow"> ② 优化：传引用返回【权力反转】</a></p> 
<p id="%C2%A0%E2%91%A2%20%E7%90%86%E8%A7%A3%EF%BC%9A%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E%E7%9A%84%E5%8D%B1%E5%AE%B3%20-%20%E9%80%A0%E6%88%90%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA%E3%80%90%E8%96%9B%E5%AE%9A%E8%B0%94%E7%9A%84%E7%8C%AB%F0%9F%90%B1%E3%80%91-toc" style="margin-left:80px;"><a href="#%C2%A0%E2%91%A2%20%E7%90%86%E8%A7%A3%EF%BC%9A%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E%E7%9A%84%E5%8D%B1%E5%AE%B3%20-%20%E9%80%A0%E6%88%90%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA%E3%80%90%E8%96%9B%E5%AE%9A%E8%B0%94%E7%9A%84%E7%8C%AB%F0%9F%90%B1%E3%80%91" rel="nofollow"> ③ 理解：引用返回的危害 - 造成未定义的行为【薛定谔的猫🐱】</a></p> 
<p id="%E2%91%A3%20%E7%BB%93%E8%AF%AD%EF%BC%9A%E6%AD%A3%E7%A1%AE%E8%AE%A4%E8%AF%86%E3%80%90%E4%BC%A0%E5%80%BC%E8%BF%94%E5%9B%9E%E3%80%91%E4%B8%8E%E3%80%90%E4%BC%A0%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E%E3%80%91-toc" style="margin-left:80px;"><a href="#%E2%91%A3%20%E7%BB%93%E8%AF%AD%EF%BC%9A%E6%AD%A3%E7%A1%AE%E8%AE%A4%E8%AF%86%E3%80%90%E4%BC%A0%E5%80%BC%E8%BF%94%E5%9B%9E%E3%80%91%E4%B8%8E%E3%80%90%E4%BC%A0%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E%E3%80%91" rel="nofollow">④ 结语：正确认识【传值返回】与【传引用返回】</a></p> 
<p id="%C2%A0%E4%BA%94%E3%80%81%E4%BC%A0%E5%80%BC%E3%80%81%E4%BC%A0%E5%BC%95%E7%94%A8%E6%95%88%E7%8E%87%E5%AF%B9%E6%AF%94-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%BA%94%E3%80%81%E4%BC%A0%E5%80%BC%E3%80%81%E4%BC%A0%E5%BC%95%E7%94%A8%E6%95%88%E7%8E%87%E5%AF%B9%E6%AF%94" rel="nofollow"> 五、传值、传引用效率对比</a></p> 
<p id="%C2%A01%E3%80%81%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E5%AF%B9%E6%AF%94-toc" style="margin-left:40px;"><a href="#%C2%A01%E3%80%81%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E5%AF%B9%E6%AF%94" rel="nofollow"> 1、函数传参对比</a></p> 
<p id="2%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%AF%B9%E6%AF%94-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%AF%B9%E6%AF%94" rel="nofollow">2、返回值的对比</a></p> 
<p id="%C2%A0%E5%85%AD%E3%80%81%E5%B8%B8%E5%BC%95%E7%94%A8-toc" style="margin-left:0px;"><a href="#%C2%A0%E5%85%AD%E3%80%81%E5%B8%B8%E5%BC%95%E7%94%A8" rel="nofollow"> 六、常引用</a></p> 
<p id="%C2%A01%E3%80%81%E6%9D%83%E9%99%90%E6%94%BE%E5%A4%A7%E3%80%90%C3%97%E3%80%91-toc" style="margin-left:40px;"><a href="#%C2%A01%E3%80%81%E6%9D%83%E9%99%90%E6%94%BE%E5%A4%A7%E3%80%90%C3%97%E3%80%91" rel="nofollow"> 1、权限放大【×】</a></p> 
<p id="%C2%A02%E3%80%81%E6%9D%83%E9%99%90%E4%BF%9D%E6%8C%81%E3%80%90%E2%9C%94%E3%80%91-toc" style="margin-left:40px;"><a href="#%C2%A02%E3%80%81%E6%9D%83%E9%99%90%E4%BF%9D%E6%8C%81%E3%80%90%E2%9C%94%E3%80%91" rel="nofollow"> 2、权限保持【✔】</a></p> 
<p id="%C2%A03%E3%80%81%E6%9D%83%E9%99%90%E7%BC%A9%E5%B0%8F%E3%80%90%E2%9C%94%E3%80%91-toc" style="margin-left:40px;"><a href="#%C2%A03%E3%80%81%E6%9D%83%E9%99%90%E7%BC%A9%E5%B0%8F%E3%80%90%E2%9C%94%E3%80%91" rel="nofollow"> 3、权限缩小【✔】</a></p> 
<p id="%C2%A04%E3%80%81%E6%8B%93%E5%B1%95-toc" style="margin-left:40px;"><a href="#%C2%A04%E3%80%81%E6%8B%93%E5%B1%95" rel="nofollow"> 4、拓展</a></p> 
<p id="4.1%E5%A6%82%E4%BD%95%E7%BB%99%E5%B8%B8%E9%87%8F%E5%8F%96%E5%88%AB%E5%90%8D%C2%A0-toc" style="margin-left:80px;"><a href="#4.1%E5%A6%82%E4%BD%95%E7%BB%99%E5%B8%B8%E9%87%8F%E5%8F%96%E5%88%AB%E5%90%8D%C2%A0" rel="nofollow">4.1如何给常量取别名 </a></p> 
<p id="4.2%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E5%85%B7%E6%9C%89%E5%B8%B8%E6%80%A7%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89%C2%A0-toc" style="margin-left:80px;"><a href="#4.2%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E5%85%B7%E6%9C%89%E5%B8%B8%E6%80%A7%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89%C2%A0" rel="nofollow">4.2临时变量具有常性（重点） </a></p> 
<p id="5%E3%80%81%C2%A0%E5%AF%B9%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E7%9A%84%E7%94%A8%E5%A4%84-toc" style="margin-left:40px;"><a href="#5%E3%80%81%C2%A0%E5%AF%B9%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E7%9A%84%E7%94%A8%E5%A4%84" rel="nofollow">5、 对权限控制的用处</a></p> 
<p id="%C2%A0%E4%B8%83%E3%80%81%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%B8%83%E3%80%81%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93" rel="nofollow"> 七、引用与指针的区别总结</a></p> 
<p id="%E5%85%AB%E3%80%81%E6%80%BB%E7%BB%93%E4%B8%8E%E6%8F%90%E7%82%BC%C2%A0-toc" style="margin-left:0px;"><a href="#%E5%85%AB%E3%80%81%E6%80%BB%E7%BB%93%E4%B8%8E%E6%8F%90%E7%82%BC%C2%A0" rel="nofollow">八、总结与提炼 </a></p> 
<p id="%C2%A0%E4%B9%9D%E3%80%81%E5%85%B1%E5%8B%89-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%B9%9D%E3%80%81%E5%85%B1%E5%8B%89" rel="nofollow"> 九、共勉</a></p> 
<hr> 
<h2 id="%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80"><span style="color:#0d0016;"><strong>一、前言</strong></span></h2> 
<blockquote> 
 <p>        本次博客来讲解以下C++ 的 <span style="color:#ed7976;"><strong>引用</strong></span> 是如何运用的。那么问题来了，为什么要用到引用？用C语言中的指针不是挺好的吗 ？</p> 
 <p>        其实，在C语言中的指针会引发很多的难题，比如【两数交换】的时候因为函数内部的概念不会引发外部的变化，使得我们<strong>需要传入两个需要交换数的地址</strong>，在函数内部进行解引用才可才可以交换二者的值</p> 
 <p>        另一块就是在数据结构中的【单链表】，面对二级指针的恐惧😱是否还伴随在你的身边，因为考虑到要修改单链表的头结点，所以光是传入指针然后用指针来接受还不够，<strong>面对普通变量要使用一指针来进行修改，那对于一级指针就需要用到二级指针来进行修改</strong>，此时我们就要传入一级指针的地址，才可以在函数内部真正得修改这个单链表的结构<br>         所以，为了解决上述简化上述问题，C++中引入了一大特性 —— 【<strong><span style="color:#ed7976;">引用</span></strong>】，在学习了<span style="color:#956fe7;">引用之后，就不要担心是否要传入变量的地址还是指针的地址啦</span>，然后我们一起来学习吧！</p> 
 <p class="img-center"><img alt="" height="358" src="https://images2.imgbox.com/34/3b/chzxjpxg_o.png" width="388"></p> 
</blockquote> 
<h2 id="%C2%A0%E4%BA%8C%E3%80%81%E5%BC%95%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D"><span style="color:#0d0016;"><strong> 二、引用的概念介绍</strong></span></h2> 
<blockquote> 
 <p><span style="color:#ed7976;"><strong>引用不是新定义一个变量，而是给已存在变量取了一个别名</strong></span>，<a href="https://so.csdn.net/so/search?q=%E7%BC%96%E8%AF%91%E5%99%A8&amp;spm=1001.2101.3001.7020" title="编译器">编译器</a><span style="color:#956fe7;"><strong>不会为引用变量开辟内存空间，它和它引用的变量共用同一块内存空间</strong></span></p> 
</blockquote> 
<p>比如：李逵，在家称为"<strong>铁牛</strong>"，江湖上人称"<strong>黑旋风</strong>"。【水浒108将各个有称号】 </p> 
<p class="img-center"><img alt="" height="332" src="https://images2.imgbox.com/7a/f2/CMNOi2uU_o.png" width="554"></p> 
<p><span style="color:#0d0016;"><strong> ❓那要怎么去“引用”呢?❓</strong></span></p> 
<blockquote> 
 <p> 此时需要使用到我们在C语言中学习到的一个<a href="https://blog.csdn.net/Fire_Cloud_1/article/details/128823996" title="操作符">操作符</a>叫做<span style="color:#ed7976;"><strong><code>[&amp;]</code></strong></span>，它是【按位与】，也是【取地址】，<span style="color:#ed7976;"><strong>但是在C++中呢，它叫做【引用】</strong></span></p> 
</blockquote> 
<p><strong><span style="color:#0d0016;">❓ 它的语法是怎样的呢?❓</span></strong></p> 
<blockquote> 
 <p><span style="color:#ed7976;"><strong> 类型&amp; 引用变量名(对象名) = 引用实体；</strong></span></p> 
</blockquote> 
<pre><code>int a = 10;
int&amp; b = a;  // b 是 a 的别名
</code></pre> 
<p class="img-center"><img alt="" height="172" src="https://images2.imgbox.com/ad/00/3cqh8pek_o.png" width="688"></p> 
<ul><li>通过运行我们可以看到变量a和变量b的地址是一样的，这是为什么呢？<span style="color:#ed7976;"><strong>就是因为b是a的引用，那b就相当于a，所以它们共用一块地址</strong></span></li><li>那既然他们公用一块地址的话，内容也是一样的。此时若是我去修改b的值，a是否和跟着改变呢？</li></ul> 
<p class="img-center"><img alt="" height="240" src="https://images2.imgbox.com/4f/d2/h4AmSSWo_o.png" width="954"></p> 
<ul><li>可以看到，若是去修改b的话，a也会跟着一起变化</li></ul> 
<h2 id="%E4%B8%89%E3%80%81%E5%BC%95%E7%94%A8%E7%9A%84%E4%BA%94%E5%A4%A7%E7%89%B9%E6%80%A7%C2%A0"><span style="color:#0d0016;"><strong>三、引用的五大特性 </strong></span></h2> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>💦  引用在定义时必须初始化<br> 💦  一个变量可以有多个引用</strong></span></p> 
 <p><span style="color:#0d0016;"><strong>💦 一个引用可以继续有引用</strong></span></p> 
 <p><span style="color:#0d0016;"><strong>💦 引用一旦引用一个实体，再不能引用其他实体</strong></span></p> 
 <p><span style="color:#0d0016;"><strong>💦 可以对任何类型做引用【变量、指针…】</strong></span></p> 
</blockquote> 
<h3 id="%C2%A0%F0%9F%92%A6%C2%A0%20%E5%BC%95%E7%94%A8%E5%9C%A8%E5%AE%9A%E4%B9%89%E6%97%B6%E5%BF%85%E9%A1%BB%E5%88%9D%E5%A7%8B%E5%8C%96"><span style="color:#0d0016;"> <strong>💦  引用在定义时必须初始化</strong></span></h3> 
<blockquote> 
 <ul><li>首先来看第一个，若是定义了一个引用类型的变量<strong><code>int&amp;</code></strong>，那么就必须要去对其进行一个初始化，指定一个其引用的对象，否则就会报错</li></ul> 
</blockquote> 
<pre><code>int a = 10;
int&amp; b = a;
int&amp; c;
</code></pre> 
<p><img alt="" height="310" src="https://images2.imgbox.com/13/47/WxmrQNBG_o.png" width="955"></p> 
<h3 id="%C2%A0%F0%9F%92%A6%C2%A0%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E4%B8%AA%E5%BC%95%E7%94%A8"><span style="color:#0d0016;"><strong> 💦 一个变量可以有多个引用</strong></span></h3> 
<blockquote> 
 <ul><li>对于第二个特定，通俗一点来说就是b引用了a，那么b等价于a；此时c也可以引用a，那么c也等价于a，此时<strong><code>a == b == c</code></strong></li><li>你可以无限对a进行引用，直到把操作系统的内存申请光为止（应该没那么狠吧）</li></ul> 
</blockquote> 
<pre><code>int a = 10;
int&amp; b = a;
int&amp; c = a;
</code></pre> 
<p><img alt="" height="267" src="https://images2.imgbox.com/e2/3c/WicnxpSa_o.png" width="952"></p> 
<h3 id="%C2%A0%C2%A0%F0%9F%92%A6%C2%A0%E4%B8%80%E4%B8%AA%E5%BC%95%E7%94%A8%E5%8F%AF%E4%BB%A5%E7%BB%A7%E7%BB%AD%E6%9C%89%E5%BC%95%E7%94%A8"><span style="color:#0d0016;"><strong>  💦 一个引用可以继续有引用</strong></span></h3> 
<blockquote> 
 <ul><li>对于第三个特性而言，其实就是一个传递性。当一个变量引用了另一个变量之后，其他变量还可以再对其进行一个引用。通过运行就可以看出它们<strong>也都是属于同一块空间</strong></li></ul> 
</blockquote> 
<pre><code>int a = 10;
int&amp; b = a;
int&amp; c = b;
</code></pre> 
<p class="img-center"><img alt="" height="253" src="https://images2.imgbox.com/04/a9/vyStIA3t_o.png" width="962"></p> 
<h3 id="%F0%9F%92%A6%C2%A0%E5%BC%95%E7%94%A8%E4%B8%80%E6%97%A6%E5%BC%95%E7%94%A8%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BD%93%EF%BC%8C%E5%86%8D%E4%B8%8D%E8%83%BD%E5%BC%95%E7%94%A8%E5%85%B6%E4%BB%96%E5%AE%9E%E4%BD%93"><strong><span style="color:#0d0016;">💦 引用一旦引用一个实体，再不能引用其他实体</span></strong></h3> 
<blockquote> 
 <ul><li>这个特性很重要【⭐】，要牢记。因为上面有说到对于引用而言在定义时必须初始化，那么在定义结束完后它就已经引用了一个值，无法在对其去进行修改了，这是非法的！</li></ul> 
</blockquote> 
<pre><code>int a = 10;
int c = 20;

int&amp; b = a;
int&amp; b = c;
</code></pre> 
<p><img alt="" height="432" src="https://images2.imgbox.com/21/6e/EoiGanw3_o.png" width="955"></p> 
<ul><li>这里我要做一个辨析，因为对于引用来说它和指针非常得类似，也有着千丝万缕般的关系，后面我也会对【指针】和【引用】做一个对比分析</li><li>看下图就可以知道，对于指针而言一旦指向了一块地址后是可以继续修改其指向的【<strong>这点也是指针和引用最大的不同</strong>】</li></ul> 
<h3 id="%C2%A0%F0%9F%92%A6%C2%A0%E5%8F%AF%E4%BB%A5%E5%AF%B9%E4%BB%BB%E4%BD%95%E7%B1%BB%E5%9E%8B%E5%81%9A%E5%BC%95%E7%94%A8%E3%80%90%E5%8F%98%E9%87%8F%E3%80%81%E6%8C%87%E9%92%88%E2%80%A6%E3%80%91"> <strong><span style="color:#0d0016;">💦 可以对任何类型做引用【变量、指针…】</span></strong></h3> 
<blockquote> 
 <ul><li>最后一点特性作为拓展。上面我们介绍了对于变量而言可以有引用，当然除了整型之外其他类型也是可以的</li><li>看到下面c1是<code>double</code>类型，c2引用c1，所以c2也是<code>double</code>类型的。其他类型可以自己试试看</li></ul> 
</blockquote> 
<pre><code>double c1 = 3.14;
double&amp; c2 = c1;
</code></pre> 
<p>然后我们重点来说说有关指针这一块的引用【⭐】</p> 
<pre><code>int a = 10;
int* p = &amp;a;

int*&amp; q = p;
</code></pre> 
<ul><li>通过代码可以看出，指针p指向了a所在的这块地址，接着我用q引用了p，那么指针q就相当于是指针p，q也指向了a所在的这块地址。<span style="color:#ed7976;"><strong>来分解一下<code>int*</code>代表q是一个指针类型，<code>&amp;</code>则表示指针q将会去引用另一个指针</strong></span></li></ul> 
<p class="img-center"><img alt="" height="260" src="https://images2.imgbox.com/a9/0b/OD3OKOI1_o.png" width="959"></p> 
<blockquote> 
 <p> 以上就是有关C++中的引用所要介绍的特性，还望读者牢记😁</p> 
</blockquote> 
<h2 id="%C2%A0%E5%9B%9B%E3%80%81%E5%BC%95%E7%94%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span style="color:#0d0016;"><strong> 四、引用的两种使用场景</strong></span></h2> 
<h3 id="%C2%A01%E3%80%81%E5%81%9A%E5%8F%82%E6%95%B0"><span style="color:#0d0016;"><strong> 1、做参数</strong></span></h3> 
<h4 id="%C2%A0a.%E6%A1%88%E4%BE%8B%E4%B8%80%EF%BC%9A%E4%BA%A4%E6%8D%A2%E4%B8%A4%E6%95%B0"><span style="color:#0d0016;"><strong> a.案例一：交换两数</strong></span></h4> 
<p>        还记得我们在C语言中学习过的<span style="color:#0d0016;"><strong>【交换两数】</strong></span>吗？需要传入两个变量的地址，从而可以在函数内部通过指针的解引用来访问到所指向变量的那块地址从而对里面的内部进行一个修改<br>         相信这也是我们在初次学习指针时接触的一个东西，也是最经典的一块内容，那除了使用<span style="color:#0d0016;"><strong>【指针】</strong></span>的这种形式，你还有没有其他的方法呢？没错，就是使用我们刚学的引用</p> 
<pre><code>void swap1(int* px, int* py)
{
	int t = *px;
	*px = *py;
	*py = t;
}
swap1(&amp;a, &amp;b);
</code></pre> 
<ul><li>我们来看看下面这种引用的方式，相信在学习了引用的基本语法和特性之后你一定很快看懂下面的代码。因为<strong>x引用了a，y引用了b</strong>，所以它们是等价的，在函数内部使用临时变量对二者进行交换就可以带动外界的变化 </li></ul> 
<pre><code>void swap2(int&amp; x, int&amp; y)
{
	int t = x;
	x = y;
	y = t;
}
swap2(a, b);</code></pre> 
<p> 通过运行结果来看确实也可以起到交换两数的功能</p> 
<p class="img-center"><img alt="" height="322" src="https://images2.imgbox.com/06/20/w2awqzXn_o.png" width="957"></p> 
<h4 id="%C2%A0b.%E6%A1%88%E4%BE%8B%E4%BA%8C%EF%BC%9A%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%B4%E7%BB%93%E7%82%B9%E4%BF%AE%E6%94%B9%E3%80%90SLNode*%26%20p%E3%80%91"><span style="color:#0d0016;"><strong> b.案例二：单链表的头结点修改【SLNode*&amp; p】</strong></span></h4> 
<p>         在讲解引用的特性时，我说到了引用的类型不仅仅限于普通变量，还可以是指针。但上面说的是普通指针，接下去我们来说说结构体指针，也涉及到了引用类型在做参数时的场景</p> 
<p>        看到如下一段代码，我定义了一个链表结点的结构体，还记得我们在<a class="link-info" href="https://blog.csdn.net/weixin_45031801/article/details/128961704" title="链表章节">链表章节</a>学习过的头插，因为涉及到会修改链表的头结点，因此函数内部的修改不会导致外部一起修改，继而我们需要传入这个链表的地址，然后使用二级指针来进行接收，相信这一块一定令很多小伙伴非常头疼🤦‍</p> 
<pre><code>typedef struct SingleNode {
	struct SingleNode * next;
	int val;
}SLNode;

void PushFront(SLNode** SList, int x)
{
	SLNode* newNode = BuyNode(x);
	newNode-&gt;next = *SList;
	*SList = newNode;
}

int main(void)
{
	SLNode* slist;
	PushFront(&amp;slist, 1);
	return 0;
}
</code></pre> 
<ul><li> 但现在学习了引用之后，我们就不需要去关心传入什么指针的地址了，只需要将这个链表传入即可，在函数形参部分对其做一个引用，<strong>那么内部的修改也就一同带动了外部的修改</strong></li><li>看了上面讲到的【普通指针】的引用，相信你对下面这种写法一定不陌生，内部的形参SList也就相当于是外部函数外部传入的实参slist。<span style="color:#ed7976;"><strong>这就是很多学校《数据结构》的教科书中统一的写法，说是使用了纯C实现，但却利用了C++中的【引用】，如果没有学习过C++的小伙伴一定是非常难受😖</strong></span><br>  </li></ul> 
<ul><li>此时<code>PushFront()</code>内部我们也可以去做一个修改，直接使用形参<code>SList</code>即可，<strong>无需考虑到要对二级指针进行解引用变为一级指针</strong></li></ul> 
<pre><code>void PushFront(SLNode*&amp; SList, int x)
{
	SLNode* newNode = BuyNode(x);
	newNode-&gt;next = SList;
	SList = newNode;
}
</code></pre> 
<p class="img-center"><img alt="" height="296" src="https://images2.imgbox.com/af/92/MtAafUuJ_o.png" width="952"></p> 
<h3 id="2%E3%80%81%E5%81%9A%E8%BF%94%E5%9B%9E%E5%80%BC%E3%80%90%E2%AD%90%E2%AD%90%E2%AD%90%E3%80%91"><span style="color:#0d0016;"><strong>2、做返回值【⭐⭐⭐】</strong></span></h3> 
<blockquote> 
 <p>首先看一下，下面的两个Count函数，你觉得它们哪里不太一样呢🤨</p> 
</blockquote> 
<h4 id="%E2%91%A0%20%E5%BC%95%E5%85%A5%EF%BC%9A%E6%A0%88%E5%8C%BA%E4%B8%8E%E9%9D%99%E6%80%81%E5%8C%BA%E7%9A%84%E5%AF%B9%E6%AF%94%C2%A0">① 引入：栈区与静态区的对比 </h4> 
<pre><code>int Count()
{
	int n = 0;
	n++;
	// ...
	return n;
}
</code></pre> 
<pre><code>int Count()
{
	static int n = 0;
	n++;
	// ...
	return n;
}
</code></pre> 
<ul><li>没错，就是这个<span style="color:#ed7976;"><strong>static</strong></span>的区别。通过画出函数调用的堆栈图我们可以看出对于两个不同的<strong>Count()函数而言其内部临时变量所存放的位置是不同的。</strong>我们知道，对于函数中的普通变量而言，是存放在当前所开辟函数的栈帧中的，即存放在内存中的<strong>栈区</strong>；但是对于函数中的静态变量而言，是不存放在当前函数栈帧中的，而是存放在内存中的<strong>静态区</strong>，包括平常可能会使用到的<strong>全局变量</strong>也是存放在其中</li><li>对于【栈区】和【静态区】而言，如果你有了解的过的话应该可以清楚地知道存在其内部的变量的生命周期是不同的：</li><li>存放在【栈区】中的临时变量当函数调用结束后整个函数栈帧就会被销毁，那么存放在这个栈帧中的临时变量也随之消亡，不复存在</li><li>存放在【静态区】中的变量它们的生命周期是从创建开始到整个程序结束为止，所以不会随着当前所在的函数栈帧销毁而消亡💀<br>  </li></ul> 
<p class="img-center"><img alt="" height="634" src="https://images2.imgbox.com/71/68/nbIRcNdj_o.png" width="927"></p> 
<p></p> 
<ul><li>上面通过画出两个Count()函数的堆栈图了解到了函数中临时变量和静态变量所在空间是不同的，那当执行完这个函数之后其所在栈帧一定会销毁，此时又会发生怎样的故事呢？我们继续看下去</li></ul> 
<hr> 
<p> 首先你必须要清楚的一些点：</p> 
<ul><li><strong><span style="color:#956fe7;">当我们定义变量 / 创建函数 / 申请堆内存的空间时，系统会把这块空间的使用权给到你💪，那么这块空间你在使用的时候是被保护的🛡，被人无法轻易来访问、入侵你的这块空间。</span></strong>但是当你将这个空间销毁之后，它并不是不存在了、被粉碎了，只是你把对于这块空间的使用权还给操作系统了，不过这块空间还是存在的，<span style="color:#ed7976;"><strong>因此你可以通过某种手段访问到这块空间🗡</strong></span>，由于操作系统又收回了这块空间的使用权，继而它便可以对其进行再度分配给其他的进程，那它就可能又属于别人了</li><li>所以你通过某种手段去访问这个空间的时候其实属于一种<span style="color:#ed7976;"><strong>非法访问⚠</strong></span>，可是呢这种非法访问又不一定会报错，就像之前我们说到过的数组越界、访问野指针都不一定会存在报错。为什么？因为编译器对于程序的检查是一种【抽查行为】，不一定能百分百查到，所以你在通过某些手段又再次访问到这块空间后所做的一些事都是存在一种【随机性】的</li></ul> 
<hr> 
<ul style="margin-left:0;"><li><span style="color:#ff0000;"><strong>上面所说的这些还望读者一定要牢记！！！</strong></span>因为这对于下文的理解以及后续的学习<strong>都是非常有帮助的</strong></li><li>好，接下去我们回归正题，继续来说一说有关函数栈帧销毁之后这个返回值是如何给到这个外界的值做接收的。相信你在本小节一开始讲到的这些内容之后再来看下图一定是非常得清晰</li></ul> 
<p class="img-center"><img alt="" height="383" src="https://images2.imgbox.com/6c/df/jYqv7Cbu_o.png" width="915"></p> 
<ul><li> 对于普通的存放在函数栈帧中的变量需要通过【临时变量】来暂存一下然后再返回，那现在我们来看看存放在静态区中的变量在函数栈帧销毁之后是如何返回给到外界的值做接收的呢？那有同学想：既然它都不存在于这个函数的栈帧中，那么也就不需要临时变量了吧，直接返回这个n不就好了</li><li><span style="color:#ed7976;"><strong>可是呢事实却不是这样，编译器可不会去管你这个变量是在【栈区】还是【静态区】的，它依旧还是傻傻🤨地在返回的时候将这个n先存放到临时变量中，然后回到调用的main函数中时再把临时变量中的内容拷贝到这个接收值</strong></span></li></ul> 
<p class="img-center"><img alt="" height="363" src="https://images2.imgbox.com/e4/be/Wbk69LUW_o.png" width="957"></p> 
<blockquote> 
 <p>【总结一下】：</p> 
 <ul><li><span style="color:#ed7976;"><strong> 当需要将函数中的临时变量返回时，无论这个变量是在</strong></span><span style="color:#956fe7;"><strong>栈区、堆区或者静态区开辟空间，</strong></span><span style="color:#ed7976;"><strong>都会通过一个<code>临时变量</code>去充当返回值【小一点的话可能是寄存器eax，大一点可能是在上一层栈帧开好的】然后再返回给外界的值做接受</strong></span></li></ul> 
</blockquote> 
<h4 id="%C2%A0%E2%91%A1%20%E4%BC%98%E5%8C%96%EF%BC%9A%E4%BC%A0%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E%E3%80%90%E6%9D%83%E5%8A%9B%E5%8F%8D%E8%BD%AC%E3%80%91"><span style="color:#0d0016;"> ② 优化：传引用返回【权力反转】</span></h4> 
<blockquote> 
 <p> 通过上面的示例你应该会觉得对于【栈区】而言使用临时变量返回还是合情合理的，可以【静态区】为什么也要通过临时变量来返回呢，这不是多此一举吗？</p> 
</blockquote> 
<ul><li>那有什么办法可以免去这种拷贝的过程，直接将得出的结果返回回去呢？那就是引用返回</li></ul> 
<pre><code>int&amp; Count()
{
	static int n = 0;
	n++;
	// ...
	return n;
}
</code></pre> 
<ul style="margin-left:0;"><li>对于引用返回来说就不会产生这个临时变量了，返回的只是n的别名，那你也可以说相当于就是把n返回回去了，编译器呢把这个权利给到了你，对于函数栈帧销毁依旧存在的内容，<span style="color:#0000ff;">如果我们不想让其拷贝到临时变量中进行返回，是可以通过引用来进行返回的，<strong>这样就可以减少拷贝</strong>，对程序做了一小部分的优化</span></li><li> <p class="img-center"><img alt="" height="276" src="https://images2.imgbox.com/c2/a8/4yo8RPbU_o.png" width="746"></p> <p class="img-center"><img alt="" height="271" src="https://images2.imgbox.com/63/e7/JKVtdoXh_o.png" width="833"></p> </li></ul> 
<blockquote> 
 <ul><li><span style="color:#ed7976;"><strong>因为我</strong></span><span style="color:#ed7976;"><strong>们可以做一个小结：</strong></span><span style="color:#956fe7;"><strong>对于像静态变量、全局变量等这些出了作用域不会销毁的对象，</strong></span><span style="color:#ed7976;"><strong>就可以使用【传引用返回】</strong></span></li><li> <p><span style="color:#ed7976;"><strong>这里ret和n的地址一样，也就意味着ret其实就是n的别名。综上，传值返回和传引用的返回的区别如下：</strong></span></p> </li><li><span style="color:#ed7976;"><strong>传值返回：会有一个拷贝</strong></span></li><li><span style="color:#ed7976;"><strong>传引用返回：没有这个拷贝了，返回的直接就是返回变量的别名 </strong></span></li></ul> 
</blockquote> 
<h4 id="%C2%A0%E2%91%A2%20%E7%90%86%E8%A7%A3%EF%BC%9A%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E%E7%9A%84%E5%8D%B1%E5%AE%B3%20-%20%E9%80%A0%E6%88%90%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA%E3%80%90%E8%96%9B%E5%AE%9A%E8%B0%94%E7%9A%84%E7%8C%AB%F0%9F%90%B1%E3%80%91"><span style="color:#0d0016;"><strong> ③ 理解：引用返回的危害 - 造成未定义的行为【薛定谔的猫🐱】</strong></span></h4> 
<blockquote> 
 <p>在上面，我介绍到了一种对函数返回进行优化的方法 ——&gt; 传引用返回，于是有的同学就觉得它很高大上，因此所以函数都使用了传引用返回，你认为可以吗？ </p> 
</blockquote> 
<ul><li>来看看下面这段代码，你认为它的输出结果是什么呢？是1吗❓ 还是随机值❓ 亦或者是其他值</li></ul> 
<pre><code>int&amp; Count()
{
	int n = 0;
	n++;
	cout &lt;&lt; "&amp;n: " &lt;&lt; &amp;n &lt;&lt; endl;
	return n;
}
int main()
{
	int&amp; ret = Count();
	cout &lt;&lt; ret &lt;&lt; endl;
	cout &lt;&lt; "&amp;ret: " &lt;&lt; &amp;ret &lt;&lt; endl;
	cout &lt;&lt; ret &lt;&lt; endl;
	return 0;
}</code></pre> 
<p><img alt="" height="270" src="https://images2.imgbox.com/7b/b6/fZkmzfug_o.png" width="820"></p> 
<ul><li>我传引用返回后，ret就是n的别名，但是有没有想过，出了函数出了这个作用域我n不是都销毁了吗，怎么还会有别名呢？</li><li>空间的销毁不是说空间就不在了。空间的归还就好比你退房，虽然你退房了，但是这个房间还是在的，只是说使用权不是你的了。但是假说你在不小心的情况下留了一把钥匙，你依旧是可以进入这个房间，不过你这个行为是非法的。这个例子也就足矣说明了上述的代码是有问题的。是一个间接的非法访问。<br>  </li></ul> 
<p> 正确的写法</p> 
<pre><code>int&amp; Count()
{
	static int n = 0;
	n++;
	cout &lt;&lt; "&amp;n: " &lt;&lt; &amp;n &lt;&lt; endl;
	return n;
}
int main()
{
	int&amp; ret = Count();
	cout &lt;&lt; ret &lt;&lt; endl;
	cout &lt;&lt; "&amp;ret: " &lt;&lt; &amp;ret &lt;&lt; endl;
	cout &lt;&lt; ret &lt;&lt; endl;
	return 0;
}</code></pre> 
<p class="img-center"><img alt="" height="271" src="https://images2.imgbox.com/c6/2c/YGaoKkZI_o.png" width="833"></p> 
<blockquote> 
 <p>总结： 引用返回 主要<span style="color:#956fe7;"><strong>对于像静态变量、全局变量等这些出了作用域不会销毁的对象，</strong></span><span style="color:#ed7976;"><strong>就可以使用【传引用返回】</strong></span></p> 
</blockquote> 
<p> 在举一个例子：</p> 
<pre><code>// 注意： static 只能初始化以此
int&amp; Add(int a, int b)
{
    int c = 0;
	c = a + b;
	return c;
}
int main()
{
	int&amp; ret = Add(1, 2);
	Add(3, 4);  // static 只能初始化以此  所以值不会变
	printf("Hello\n");
	cout &lt;&lt; "Add(1, 2) is :" &lt;&lt; ret &lt;&lt; endl;  // 随机值
	return 0;
}</code></pre> 
<p class="img-center"><img alt="" height="166" src="https://images2.imgbox.com/a2/8d/ZGcCIif6_o.png" width="705"></p> 
<p>此时因为 c 出栈之后就会被销毁掉，所以输出的就是一个随机值。</p> 
<p>进行改进  加入 static </p> 
<pre><code>// 注意： static 只能初始化以此
int&amp; Add(int a, int b)
{
    static int c = 0;
	c = a + b;
	return c;
}
int main()
{
	int&amp; ret = Add(1, 2);
	cout &lt;&lt; "Add(1, 2) is :" &lt;&lt; ret &lt;&lt; endl;  // 3
	Add(3, 4);  // static 只能初始化以此  所以值不会变
	printf("Hello\n");
	cout &lt;&lt; "Add(1, 2) is :" &lt;&lt; ret &lt;&lt; endl;  // 7
	return 0;
}</code></pre> 
<p class="img-center"><img alt="" height="197" src="https://images2.imgbox.com/e7/c0/3vMBKdg1_o.png" width="822"></p> 
<h4 id="%E2%91%A3%20%E7%BB%93%E8%AF%AD%EF%BC%9A%E6%AD%A3%E7%A1%AE%E8%AE%A4%E8%AF%86%E3%80%90%E4%BC%A0%E5%80%BC%E8%BF%94%E5%9B%9E%E3%80%91%E4%B8%8E%E3%80%90%E4%BC%A0%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E%E3%80%91"><span style="color:#0d0016;"><strong>④ 结语：正确认识【传值返回】与【传引用返回】</strong></span></h4> 
<blockquote> 
 <p>好了，看到这里，相信你对引用做返回值的使用场景应该有了很深刻的理解，来做个总结 </p> 
</blockquote> 
<p>         如果你觉得很难理解，那说明你是个正常人，C++引用这一块尤其是做函数返回值的时候是最难理解的，但是通过画图去理解分析就会好很多了，通过画出这个函数的栈帧图就可以很清晰地看明白所有的一切</p> 
<p class="img-center"><img alt="" height="422" src="https://images2.imgbox.com/56/ca/e2kEugqv_o.png" width="961"></p> 
<blockquote> 
 <p><span style="color:#fe2c24;">最后的话再带读者来回顾一下【传值返回】和【传引用返回】</span></p> 
 <ul><li><span style="color:#fe2c24;"> <strong>传值返回</strong>：如果已经还给系统了，随着当前作用域的结束而一起销毁的</span></li><li><span style="color:#fe2c24;"> <strong>传引用返回</strong>：只要是出了当前作用域不会销毁，并且函数栈帧销毁不影响其生命周期【全局变量、静态变量、上一层栈帧、malloc的】</span></li></ul> 
</blockquote> 
<h2 id="%C2%A0%E4%BA%94%E3%80%81%E4%BC%A0%E5%80%BC%E3%80%81%E4%BC%A0%E5%BC%95%E7%94%A8%E6%95%88%E7%8E%87%E5%AF%B9%E6%AF%94"><span style="color:#0d0016;"><strong> 五、传值、传引用效率对比</strong></span></h2> 
<blockquote> 
 <p>在上一模块，我介绍了有关引用的两种使用场景，相信你在学习了之后也是一头雾水，学它有什么用呢？和普通的传值有何区别？本模块就来对【传值】和【传引用】这两种方式来做一个对比 </p> 
</blockquote> 
<h3 id="%C2%A01%E3%80%81%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E5%AF%B9%E6%AF%94"><span style="color:#0d0016;"><strong> 1、函数传参对比</strong></span></h3> 
<ul><li>首先我们来看看以值和引用分别作为<strong>函数参数</strong>有什么不同</li></ul> 
<pre><code>#include &lt;time.h&gt;
struct A { 
	int a[10000];
};

void TestFunc1(A a){}

void TestFunc2(A&amp; a){}

void TestRefAndValue()
{
	A a;
	// 以值作为函数参数
	size_t begin1 = clock();
	for (size_t i = 0; i &lt; 10000; ++i)
	{
		TestFunc1(a);
	}
	size_t end1 = clock();

	// 以引用作为函数参数
	size_t begin2 = clock();
	for (size_t i = 0; i &lt; 10000; ++i)
	{
		TestFunc2(a);
	}
	size_t end2 = clock();

	// 分别计算两个函数运行结束后的时间
	cout &lt;&lt; "TestFunc1(A)-time:" &lt;&lt; end1 - begin1 &lt;&lt; endl &lt;&lt; endl;
	cout &lt;&lt; "TestFunc2(A&amp;)-time:" &lt;&lt; end2 - begin2 &lt;&lt; endl;
}
</code></pre> 
<ul><li> 通过运行可以观察到，其实二者也差得不太多，传值做参是19ms，引用做参则是0ms，虽然二者存在差距，但是差距并不大。传引用作参替代了我们在C语言中学习的二级指针，无需考虑传入一级指针的地址，然后再函数内部在做解引用</li><li>直接使用引用传参省去了这些步骤，那你可以想想差不多是可以省下来一些时间</li></ul> 
<p class="img-center"><img alt="" height="188" src="https://images2.imgbox.com/8e/20/UeOjbHv2_o.png" width="929"></p> 
<h3 id="2%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%AF%B9%E6%AF%94"><span style="color:#0d0016;"><strong>2、返回值的对比</strong></span></h3> 
<p>         不过呢，这个时间其实还看不出引用的强大之处，我们通过另一个场景，来看看<strong>值返回与引用返回</strong>二者的差距是否会大一些</p> 
<pre><code>// 值返回
A TestFunc1() 
{
	return a; 
}

// 引用返回
A&amp; TestFunc2()
{ 
	return a;
}
</code></pre> 
<ul><li>通过运行可以发现，在引用做返回值这一块可是比普通返回值要来的高效很多，足足有快了100倍这样</li><li>为什么它可以这么高效？因为在程序执行的过程中拷贝这一个步骤其实很耗时间的，首先你要讲想返回的值给到一个临时变量，然后再通过这个临时变量传递给到外面的变量做接收。可是对于引用来说，是直接返回了自己本身的一个别名，那也就是你拥有了我这块地址，不需要再去花费大量的辗转拷贝工作了。通过这样的对比再去回想我们上面一步步讲下来的这些内容，你就可以很清楚的认识到引用的强大之处了</li></ul> 
<p class="img-center"><img alt="" height="253" src="https://images2.imgbox.com/9a/31/NENeLhdz_o.png" width="925"></p> 
<h2 id="%C2%A0%E5%85%AD%E3%80%81%E5%B8%B8%E5%BC%95%E7%94%A8"><span style="color:#0d0016;"><strong> 六、常引用</strong></span></h2> 
<blockquote> 
 <p>        看到这里之后你对C++中的【引用】应该是有一个很清晰的概念了，也知道了它的强大之处。接下去我来普及一个东西叫做【常引用】，也是引用里面很重要的一块知识点 </p> 
</blockquote> 
<h3 id="%C2%A01%E3%80%81%E6%9D%83%E9%99%90%E6%94%BE%E5%A4%A7%E3%80%90%C3%97%E3%80%91"><span style="color:#0d0016;"><strong> 1、权限放大【×】</strong></span></h3> 
<p>权限放大 —— 用普通的变量替代只读变量</p> 
<p>首先来看下下面这段代码，你认为什么地方有问题？</p> 
<ul><li> 变量b对a进行了引用，这一点肯定不会有问题；不过问题就出在这个变量对c的引用，有同学说：“为什么呢？不都是引用吗？”</li><li>那你就要注意到这个const了，首先对于【const】关键字修饰的变量具有常性，是不可以被随意修改的，但此时变量d引用了c，那么c和d就从属于同一块地址了，不过变量d不具有常性，因此它是可以被修改的。那么这个时候就会产生歧义了，也就出现了问题</li><li> 这种引用形式叫做【权限放大】，本来我这个c是不具有再度修改权限的，但是你引用了我，那就可以修改了，这也就破坏了原先的规则👈</li></ul> 
<pre><code>int a = 1;
int&amp; b = a;

const int c = 2;
int&amp; d = c;
</code></pre> 
<p class="img-center"><img alt="" height="324" src="https://images2.imgbox.com/64/e5/a8ihaf2Z_o.png" width="962"></p> 
<h3 id="%C2%A02%E3%80%81%E6%9D%83%E9%99%90%E4%BF%9D%E6%8C%81%E3%80%90%E2%9C%94%E3%80%91"><span style="color:#0d0016;"><strong> 2、权限保持【✔】</strong></span></h3> 
<ul><li>那我们修改一下，不要让权限放大了，给变量d也加上一个常属性，让他俩一样，看看是否可行</li></ul> 
<pre><code>const int c = 2;
const int&amp; d = c;
</code></pre> 
<ul style="margin-left:0;"><li>可以看到，此时就不会出现问题了，因为我们进行了一个<span style="color:#0000ff;"><strong>【权限保持】</strong></span>，不会因为权限的放大而导致规则被破坏</li></ul> 
<p class="img-center"><img alt="" height="216" src="https://images2.imgbox.com/22/b2/gmNDc3gI_o.png" width="936"></p> 
<h3 id="%C2%A03%E3%80%81%E6%9D%83%E9%99%90%E7%BC%A9%E5%B0%8F%E3%80%90%E2%9C%94%E3%80%91"><span style="color:#0d0016;"><strong> 3、权限缩小【✔】</strong></span></h3> 
<p>权限缩小 —— 用只读的变量替代普通变量 </p> 
<ul><li>那既然权限保持不会出现问题，若是我现在将权限缩小会不会出现问题呢？</li></ul> 
<pre><code>int c = 2;
const int&amp; d = c;
</code></pre> 
<ul><li>可以看到，也是不会出现问题。<strong>你呢允许我修改，但是我加上了常属性不去修改，那也是说得通的</strong></li></ul> 
<p class="img-center"><img alt="" height="286" src="https://images2.imgbox.com/b0/c1/eJDLcECT_o.png" width="950"></p> 
<h3 id="%C2%A04%E3%80%81%E6%8B%93%E5%B1%95"> <span style="color:#0d0016;"><strong>4、拓展</strong></span></h3> 
<h4 id="4.1%E5%A6%82%E4%BD%95%E7%BB%99%E5%B8%B8%E9%87%8F%E5%8F%96%E5%88%AB%E5%90%8D%C2%A0"><span style="color:#0d0016;"><strong>4.1如何给常量取别名 </strong></span></h4> 
<blockquote> 
 <p>可以给常量取别名吗？</p> 
 <pre><code class="hljs">int&amp; c = 20; // err</code></pre> 
 <p>其实是<span style="color:#956fe7;"><strong>不可以直接进行取别名的</strong></span>，<span style="color:#fe2c24;"><strong>但是我们加上const就可以了</strong></span>：</p> 
 <pre><code class="hljs">const int&amp; c = 20; // right</code></pre> 
</blockquote> 
<h4 id="4.2%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E5%85%B7%E6%9C%89%E5%B8%B8%E6%80%A7%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89%C2%A0"><span style="color:#0d0016;"><strong>4.2临时变量具有常性（重点） </strong></span></h4> 
<blockquote> 
 <p>看如下代码：</p> 
 <pre><code class="hljs">double d = 2.2;
int&amp; e = d;</code></pre> 
 <p><span style="color:#956fe7;"><strong>此刻的 </strong></span><span style="color:#ed7976;"><strong>e</strong></span><span style="color:#956fe7;"><strong> 是否为 </strong></span><span style="color:#ed7976;"><strong>d</strong></span><span style="color:#956fe7;"><strong> 的别名？</strong></span></p> 
 <p class="img-center"><img alt="" height="368" src="https://images2.imgbox.com/92/64/6mpWr5iX_o.png" width="818"></p> 
 <p>很明显不可以，编译器发生错误。<span style="color:#ed7976;"><strong>但是我加上const，发现它竟然就不会出错了：</strong></span></p> 
 <p>怎么解释上述代码呢？这就需要我们先回顾下<span style="color:#ed7976;"><strong>C语言的类型转换</strong></span></p> 
 <p>C++本身是在C语言的基础上走的，<strong><span style="color:#956fe7;">C语言在相似类型是允许<a href="https://so.csdn.net/so/search?q=%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2&amp;spm=1001.2101.3001.7020" title="隐式类型转换">隐式类型转换</a>的</span></strong>。大给小会截断，小给大会提升。看如下代码：</p> 
 <pre><code class="hljs">double d = 2.2;
int f = d;</code></pre> 
 <p>编译器运行后：<br><img alt="" height="93" src="https://images2.imgbox.com/7d/69/rjjuORfb_o.png" width="878"><br> 这里的会丢失数据其实就是<span style="color:#956fe7;"><strong>会丢失精度</strong></span></p> 
 <ul><li>注意：</li></ul> 
 <p><span style="color:#956fe7;"><strong>这里在把d的值赋给f时并不是直接赋值的</strong></span>，会把d的整数部分取出来，<span style="color:#ed7976;"><strong>赋值给一个临时变量</strong></span>，该临时变量大小4个字节，随后再把这个临时变量给给f</p> 
 <p class="img-center"><img alt="" height="137" src="https://images2.imgbox.com/39/37/DkmQRY3M_o.png" width="527"></p> 
 <p><span style="color:#ed7976;"><strong>临时变量具有常性，就像被const修饰了一样，不能被修改</strong></span></p>   
 <ul><li>谈到这，你就应该能够理解上文的这段代码为什么要加上const才能编译通过：</li></ul> 
 <pre><code class="hljs">double d = 2.2;
const int&amp; e = d;</code></pre> 
 <br> 答案很简单， 
 <span style="color:#956fe7;"><strong>这里e引用的是临时变量，临时变量具有常性，不能直接引用，</strong></span> 
 <span style="color:#ed7976;"><strong>否则就是放大了权限，加上const才能保证其权限不变</strong></span> 
 <br>   
 <ul><li><span style="color:#0d0016;"><strong><span style="background-color:#fbd4d0;">可能又会有人提问了，那为什么这段代码在赋值的时候不加上const呢？</span></strong></span></li></ul> 
 <pre><code class="hljs">double d = 2.2;
int f = d;</code></pre> 其实很简单，上述加const是在我引用的基础上加的，如若不加const，那么就是放大权限，让e变为可读可写的同时临时变量也如此，而此段代码中，对f的改变并不会影响到我临时变量，更不会影响到d， 
 <span style="color:#956fe7;"><strong>主要就是普通的变量不存在权限放大或缩小。</strong></span> 
 <br>   
 <ul><li><span style="color:#0d0016;"><strong><span style="background-color:#fbd4d0;">此时又有人提问了，那么此时的e还是对d的引用吗？</span></strong></span></li></ul> 
 <pre><code class="hljs">double d = 2.2;
const int&amp; e = d;</code></pre> 这当然不是， 
 <span style="color:#ed7976;"><strong>此时的e是对临时变量的引用，是临时变量的别名</strong></span>。可以通过编译来验证： 
 <p class="img-center"><img alt="" height="234" src="https://images2.imgbox.com/c2/5b/6yi2LVTl_o.png" width="1200"></p> 
 <br>   
</blockquote> 
<h3 id="5%E3%80%81%C2%A0%E5%AF%B9%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E7%9A%84%E7%94%A8%E5%A4%84"><span style="color:#0d0016;"><strong>5、 对权限控制的用处</strong></span></h3> 
<blockquote> 
 <p>这里简单提下，例如这个传参的问题。</p> 
 <p>如若<span style="color:#956fe7;"><strong>函数写出普通的引用，那么很多参数可能会传不过来：</strong></span></p> 
 <p class="img-center"><img alt="" height="362" src="https://images2.imgbox.com/c5/d9/zOWVLS4L_o.png" width="748"></p> 
 <p>仔细看这段代码，只有a能正常传过去，后面的均传不过去，<span style="color:#956fe7;">因为后面传的参数均涉及权限放大，固然编译器会出错</span></p> 
 <p><span style="color:#0d0016;"><strong><span style="background-color:#fbd4d0;">但是当我们在函数的形参那加上const呢？</span></strong></span></p> 
 <p class="img-center"><img alt="" height="362" src="https://images2.imgbox.com/b8/8e/L3ckF9x4_o.png" width="811"></p> 
 <p><span style="color:#fe2c24;"><strong>加了const后编译器就不会报错了</strong></span></p> 
</blockquote> 
<h2 id="%C2%A0%E4%B8%83%E3%80%81%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93"><span style="color:#0d0016;"><strong> 七、引用与指针的区别总结</strong></span></h2> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>引用和指针的不同点：</strong></span></p> 
 <ul><li>引用概念上定义一个变量的别名，指针存储一个变量地址</li><li>引用在定义时必须初始化，指针没有要求</li><li>引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型实体</li><li>没有NULL引用，但有NULL指针</li><li>在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32位平台下占4个字节)</li><li>引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小</li><li>有多级指针，但是没有多级引用</li><li>访问实体方式不同，指针需要显式解引用，引用编译器自己处理</li><li>引用比指针使用起来相对更安全</li></ul> 
</blockquote> 
<p>接下来就上述指针与引用不同点做详细解析：</p> 
<ul><li>引用在定义时必须初始化，指针没有要求</li></ul> 
<pre><code>int&amp; r; //err 引用没有初始化
int* p; //right 指针可以不初始化</code></pre> 
<ul><li>在sizeof中含义不同：引用结果为引用类型的大小，但直至始终时地址空间所占字节个数（32位平台下占4个字节）</li></ul> 
<pre><code>	double d = 2.2;
	double&amp; r = d;
	cout &lt;&lt; sizeof(r) &lt;&lt; endl; //8</code></pre> 
<ul><li>在语法概念上引用就是一个别名，没有独立空间，和其引用实体共用同一块空间。</li></ul> 
<p class="img-center"><img alt="" height="154" src="https://images2.imgbox.com/d5/e6/uHjx85tA_o.png" width="820"></p> 
<p> 在底层实现上实际是有空间的，因为引用是按照指针方式来实现的。</p> 
<pre><code>int main()
{
	int a = 10;
	//语法角度而言：ra是a的别名，没有额外开空间
	//底层的角度：它们是一样的方式实现的
	int&amp; ra = a;
	ra = 20;
	//语法角度而言：pa存储a的空间地址，pa开了4/8字节的空间
	//底层的角度：它们是一样的方式实现的
	int* pa = &amp;a;
	*pa = 20;
	return 0;
}</code></pre> 
<p> 我们来看下引用和指针的汇编代码对比：</p> 
<p class="img-center"><img alt="" height="464" src="https://images2.imgbox.com/8c/3b/JDNMBkri_o.png" width="756"></p> 
<p> 通过反汇编我们可以看出：引用是按照指针方式来实现的。</p> 
<h2 id="%E5%85%AB%E3%80%81%E6%80%BB%E7%BB%93%E4%B8%8E%E6%8F%90%E7%82%BC%C2%A0"><span style="color:#0d0016;"><strong>八、总结与提炼 </strong></span></h2> 
<blockquote> 
 <p> 最后，来总结一下本文所学习的内容📖</p> 
</blockquote> 
<ul><li>首先我们了解了什么是引用，知晓了原来引用就是【取别名】，主体与被引用体使用的都是同一块空间</li><li>接下去学习了有关引用的五大特性，知道了</li><li>在定义时必须初始化</li><li>一个变量可以有多个引用</li><li>一个引用可以继续有引用</li><li>用一旦引用一个实体，再不能引用其他实体</li><li>可以对任何类型做引用</li><li>有了基本的概念和理解之后，我们就开始真正地使用引用，关注到它被使用的两种场景，分别是：① 做参数；② 做返回值；这一模块讲解地非常细致，里面不仅包含引用相关的很多难点，而且还有一些内存空间相关的知识，特别是对于【引用做返回值】这一块读者一定要细细品味🍵</li><li>了解了引用的两种使用场景后，便通过传值、传引用去分别比较了在这两种场景下二者的差距，很明显引用还是更胜一筹，比较拷贝是需要耗费的时间</li><li>接下去拓展了一点，说了引用的另一块知识点 ——【常引用】，我们日常在使用引用的时候，一定要注意千万不可将权限放大，只可做到权限保持或者是权限缩小</li><li>最后的最后，又去对比了指针和引用二者区别所在，知道了原来在底层的实现中【引用】和【指针】其实差不太多，都是需要开辟空间的。但二者还是存在很多的区别，都得读者列出来了，这些都是在笔试面试当中常考的内容，还望谨记！<br>  </li></ul> 
<h2 id="%C2%A0%E4%B9%9D%E3%80%81%E5%85%B1%E5%8B%89"><span style="color:#0d0016;"><strong> 九、共勉</strong></span></h2> 
<p>         <strong>以下就是我对<span style="color:#ed7976;">C++ 引用（&amp;）</span></strong><strong><span style="color:#ed7976;">的理解</span>，如果有不懂和发现问题的小伙伴，请在评论区说出来哦，同时我还会继续更新对<span style="color:#ed7976;">C++ 类和对象的理解</span><span style="color:#956fe7;">，请持续关注我哦！！！</span></strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d1/a2/VptvnTCM_o.png"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7472d480f6a9acc8fd4024e961f3bba1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python tqdm进度条详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dbe838bbaf32facfa3252659f7144685/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Android】获取屏幕方向的几种方式和最优解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>