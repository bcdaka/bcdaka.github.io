<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据库】关系模式规范化（设计范式） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/ce9c54356f3b3336c518fd7d8f6a6f5d/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据库】关系模式规范化（设计范式）">
  <meta property="og:description" content="文章目录 关系规范化第一范式 1NF第二范式 2NF函数依赖完全函数依赖传递依赖 第三范式 3NFBC范式 BCFN第四范式 4NF第五范式 5NF 关系规范化 关系数据库中的关系满足一定要求的，满足不同程度要求的为不同的范式。满足最低要求的叫第一范式，简称1NF；在第一范式的基础上满足进一步要求的称为第二范式，简称2NF，其余范式以此类推。
首先要明白”范式（NF）”是什么意思。按照教材中的定义，范式是“符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度”。
数据库范式也分为1NF，2NF，3NF，BCNF，4NF，5NF。
一般在我们设计关系型数据库的时候，最多考虑到BCNF就够。符合高一级范式的设计，必定符合低一级范式，例如符合2NF的关系模式，必定符合1NF。
关系模式”和“关系”的区别，类似于面向对象程序设计中”类“与”对象“的区别。”关系“是”关系模式“的一个实例，你可以把”关系”理解为一张带数据的表，而“关系模式”是这张数据表的表结构。
第一范式 1NF 定义： 属于第一范式关系的所有属性都不可再分，即数据项不可分。
理解： 第一范式强调数据表的原子性，是其他范式的基础。如下图所示数据库就不符合第一范式：
实际上，1NF是所有关系型数据库的最基本要求，你在关系型数据库管理系统（RDBMS），例如SQL Server，Oracle，MySQL中创建数据表的时候，如果数据表的设计不符合这个最基本的要求，那么操作一定是不能成功的。也就是说，只要在RDBMS中已经存在的数据表，一定是符合1NF的。如果我们要在RDBMS中表现表中的数据，就得设计为下表的形式：
但日常生活中仅用第一范式来规范表格是远远不够的，依然会存在数据冗余过大、删除异常、插入异常、修改异常的问题，此时就需要引入规范化概念，将其转化为更标准化的表格，减少数据依赖。
规范化：
每一名学生的学号、姓名、系名、系主任这些数据重复多次。每个系与对应的系主任的数据也重复多次——数据冗余过大
假如学校新建了一个系，但是暂时还没有招收任何学生（比如3月份就新建了，但要等到8月份才招生），那么是无法将系名与系主任的数据单独地添加到数据表中去的 （注１）——插入异常
注１：根据三种关系完整性约束中实体完整性的要求，关系中的码（注２）所包含的任意一个属性都不能为空，所有属性的组合也不能重复。为了满足此要求，图中的表，只能将学号与课名的组合作为码，否则就无法唯一地区分每一条记录。
注２：码：关系中的某个属性或者某几个属性的组合，用于区分每个元组（可以把“元组”理解为一张表中的每条记录，也就是每一行）。
假如将某个系中所有学生相关的记录都删除，那么所有系与系主任的数据也就随之消失了（一个系所有学生都没有了，并不表示这个系就没有了）。——删除异常
假如李小明转系到法律系，那么为了保证数据库中数据的一致性，需要修改三条记录中系与系主任的数据。——修改异常。
正因为仅符合1NF的数据库设计存在着这样那样的问题，我们需要提高设计标准，去掉导致上述四种问题的因素，使其符合更高一级的范式（2NF），这就是所谓的“规范化”。
规范化： 一个低一级的关系模式通过模式分解可以转化为若干个高一级范式的关系模式的集合，这个过程叫做规范化。
第二范式 2NF 定义： 若某关系R属于第一范式，且每一个非主属性完全函数依赖于任何一个候选码，则关系R属于第二范式。
此处我们需要理解非主属性、候选码和完全函数依赖的概念。
候选码：
若关系中的某一属性组的值能唯一地标识一个元组，而其子集不能，则称该属性组为候选码。若一个关系中有多个候选码，则选定其中一个为主码。
以下所有内容中，主码或候选码都简称为码。
例如下图所示的学生表中，学号和姓名都可以唯一标识一个元组，故该表的候选码为学号和姓名，主码我们可以随便选定其中一个，则选学号为主码。
学号姓名年龄性别101刘晨19女102王琪21男103张宇20男104李琛19女105欧阳慧20女 主属性：
所有候选码的属性称为主属性。不包含在任何候选码中的属性称为非主属性或非码属性。
在上面的学生表中，学号和姓名就是该关系的主属性，年龄和性别就是非主属性。
函数依赖 设R(U)是属性集U上的关系模式，X、Y是U的子集。若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则称Y函数依赖于X或X函数确定Y。
完全函数依赖 设R(U)是属性集U上的关系模式，X、Y是U的子集。如果Y函数依赖于X，且对于X的任何一个真子集X’，都有Y不函数依赖于X’，则称Y对X完全函数依赖。记作：如果Y函数依赖于X，但Y不完全函数依赖于X，则称Y对X部分函数依赖。
传递依赖 理解： 第二范式是指每个表必须有一个（有且仅有一个）数据项作为关键字或主键（primary key），其他数据项与关键字或者主键一一对应，即其他数据项完全依赖于关键字或主键。由此可知单主属性的关系均属于第二范式。
判断一个关系是否属于第二范式： 找出数据表中的所有码；找出所有主属性和非主属性；判断所有的非主属性对码的部分函数依赖。 图表示了表中所有的函数依赖关系：
码只有一个，就是**（学号、课名）。
主属性有两个：学号 与 课名
非主属性有四个：姓名、系名、系主任、分数
对于（学号，课名） → 姓名**，有 学号 → 姓名，存在非主属性 姓名 对码**（学号，课名）的部分函数依赖。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-05T16:42:48+08:00">
    <meta property="article:modified_time" content="2024-03-05T16:42:48+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据库】关系模式规范化（设计范式）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><ul><li><a href="#_1" rel="nofollow">关系规范化</a></li><li><ul><li><a href="#_1NF_13" rel="nofollow">第一范式 1NF</a></li><li><a href="#_2NF_46" rel="nofollow">第二范式 2NF</a></li><li><ul><li><a href="#_74" rel="nofollow">函数依赖</a></li><li><a href="#_78" rel="nofollow">完全函数依赖</a></li><li><a href="#_83" rel="nofollow">传递依赖</a></li></ul> 
     </li><li><a href="#_3NF_141" rel="nofollow">第三范式 3NF</a></li><li><a href="#BC_BCFN_186" rel="nofollow">BC范式 BCFN</a></li><li><a href="#_4NF_237" rel="nofollow">第四范式 4NF</a></li><li><a href="#_5NF_243" rel="nofollow">第五范式 5NF</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h4><a id="_1"></a>关系规范化</h4> 
<p>关系数据库中的关系满足一定要求的，满足不同程度要求的为不同的范式。满足最低要求的叫第一范式，简称1NF；在第一范式的基础上满足进一步要求的称为第二范式，简称2NF，其余范式以此类推。</p> 
<p>首先要明白”范式（NF）”是什么意思。按照教材中的定义，范式是“符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度”。</p> 
<p>数据库范式也分为1NF，2NF，3NF，BCNF，4NF，5NF。</p> 
<p>一般在我们设计关系型数据库的时候，<strong>最多考虑到BCNF就够</strong>。符合高一级范式的设计，必定符合低一级范式，例如符合2NF的关系模式，必定符合1NF。</p> 
<p><em>关系模式”和“关系”的区别，类似于面向对象程序设计中”类“与”对象“的区别。”关系“是”关系模式“的一个实例，你可以把”关系”理解为一张带数据的表，而“关系模式”是这张数据表的表结构。</em></p> 
<h5><a id="_1NF_13"></a>第一范式 1NF</h5> 
<p><strong>定义：</strong> 属于第一范式关系的所有属性都不可再分，即数据项不可分。</p> 
<p><strong>理解：</strong> 第一范式强调数据表的原子性，是其他范式的基础。如下图所示数据库就不符合第一范式：<br> <img src="https://images2.imgbox.com/88/4a/g8bnv35G_o.png" alt="img"></p> 
<p>实际上，<strong>1NF是所有关系型数据库的最基本要求</strong>，你在关系型数据库管理系统（RDBMS），例如SQL Server，Oracle，MySQL中创建数据表的时候，如果数据表的设计不符合这个最基本的要求，那么操作一定是不能成功的。也就是说，只要在RDBMS中已经存在的数据表，一定是符合1NF的。如果我们要在RDBMS中表现表中的数据，就得设计为下表的形式：</p> 
<p><img src="https://images2.imgbox.com/3c/ac/PgOnho9H_o.png" alt="img"></p> 
<p>但日常生活中仅用第一范式来规范表格是远远不够的，依然会存在数据冗余过大、删除异常、插入异常、修改异常的问题，此时就需要引入规范化概念，将其转化为更标准化的表格，减少数据依赖。</p> 
<p><strong>规范化：</strong></p> 
<p><img src="https://images2.imgbox.com/ce/a8/AQnIDyJi_o.png" alt="img"></p> 
<ol><li> <p>每一名学生的学号、姓名、系名、系主任这些数据重复多次。每个系与对应的系主任的数据也重复多次——<strong>数据冗余过大</strong></p> </li><li> <p>假如学校新建了一个系，但是暂时还没有招收任何学生（比如3月份就新建了，但要等到8月份才招生），那么是无法将系名与系主任的数据单独地添加到数据表中去的 （注１）——<strong>插入异常</strong></p> <p>注１：根据三种关系完整性约束中实体完整性的要求，关系中的码（注２）所包含的任意一个属性都不能为空，所有属性的组合也不能重复。为了满足此要求，图中的表，只能将学号与课名的组合作为码，否则就无法唯一地区分每一条记录。</p> <p>注２：<strong>码：关系中的某个属性或者某几个属性的组合，用于区分每个元组</strong>（可以把“元组”理解为一张表中的每条记录，也就是每一行）<strong>。</strong></p> </li><li> <p>假如将某个系中所有学生相关的记录都删除，那么所有系与系主任的数据也就随之消失了（一个系所有学生都没有了，并不表示这个系就没有了）。——<strong>删除异常</strong></p> </li><li> <p>假如李小明转系到法律系，那么为了保证数据库中数据的一致性，需要修改三条记录中系与系主任的数据。——<strong>修改异常</strong>。</p> </li></ol> 
<p>正因为仅符合1NF的数据库设计存在着这样那样的问题，我们需要提高设计标准，去掉导致上述四种问题的因素，使其符合更高一级的范式（2NF），这就是所谓的“规范化”。</p> 
<p><strong>规范化：</strong> 一个低一级的关系模式通过模式分解可以转化为若干个高一级范式的关系模式的集合，这个过程叫做规范化。</p> 
<h5><a id="_2NF_46"></a>第二范式 2NF</h5> 
<p><strong>定义：</strong> 若某关系R属于第一范式，且每一个非主属性完全函数依赖于任何一个候选码，则关系R属于第二范式。</p> 
<p>此处我们需要理解非主属性、候选码和完全函数依赖的概念。</p> 
<p><strong>候选码：</strong></p> 
<p>若关系中的某一属性组的值能唯一地标识一个元组，而其子集不能，则称该属性组为候选码。若一个关系中有多个候选码，则选定其中一个为主码。</p> 
<p><strong>以下所有内容中，主码或候选码都简称为码。</strong></p> 
<p>例如下图所示的学生表中，学号和姓名都可以唯一标识一个元组，故该表的候选码为学号和姓名，主码我们可以随便选定其中一个，则选学号为主码。</p> 
<table><thead><tr><th align="left">学号</th><th align="left">姓名</th><th align="left">年龄</th><th align="left">性别</th></tr></thead><tbody><tr><td align="left">101</td><td align="left">刘晨</td><td align="left">19</td><td align="left">女</td></tr><tr><td align="left">102</td><td align="left">王琪</td><td align="left">21</td><td align="left">男</td></tr><tr><td align="left">103</td><td align="left">张宇</td><td align="left">20</td><td align="left">男</td></tr><tr><td align="left">104</td><td align="left">李琛</td><td align="left">19</td><td align="left">女</td></tr><tr><td align="left">105</td><td align="left">欧阳慧</td><td align="left">20</td><td align="left">女</td></tr></tbody></table> 
<p><strong>主属性：</strong></p> 
<p>所有候选码的属性称为主属性。不包含在任何候选码中的属性称为非主属性或非码属性。</p> 
<p>在上面的学生表中，学号和姓名就是该关系的主属性，年龄和性别就是非主属性。</p> 
<h6><a id="_74"></a>函数依赖</h6> 
<p>设R(U)是属性集U上的关系模式，X、Y是U的子集。若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则称Y函数依赖于X或X函数确定Y。</p> 
<h6><a id="_78"></a>完全函数依赖</h6> 
<p>设R(U)是属性集U上的关系模式，X、Y是U的子集。如果Y函数依赖于X，且对于X的任何一个真子集X’，都有Y不函数依赖于X’，则称Y对X完全函数依赖。记作：如果Y函数依赖于X，但Y不完全函数依赖于X，则称Y对X<strong>部分函数依赖</strong>。<br> <img src="https://images2.imgbox.com/01/67/caqPFDFv_o.png" alt="记号"></p> 
<h6><a id="_83"></a>传递依赖</h6> 
<p><img src="https://images2.imgbox.com/0a/10/ZWHFpBzh_o.png" alt="传递依赖"></p> 
<p><strong>理解：</strong> 第二范式是指每个表必须有一个（有且仅有一个）数据项作为关键字或主键（primary key），其他数据项与关键字或者主键一一对应，即其他数据项完全依赖于关键字或主键。由此可知单主属性的关系均属于第二范式。</p> 
<ul><li><strong>判断一个关系是否属于第二范式：</strong></li></ul> 
<ol><li>找出数据表中的所有码；</li><li>找出所有主属性和非主属性；</li><li>判断所有的非主属性对码的部分函数依赖。</li></ol> 
<p><strong>图</strong>表示了表中所有的函数依赖关系：</p> 
<p><img src="https://images2.imgbox.com/2c/70/i6XCPNJx_o.png" alt="img"></p> 
<p>码只有一个，就是**（学号、课名）<strong>。<br> 主属性有两个：<strong>学号</strong> 与 <strong>课名</strong><br> 非主属性有四个：<strong>姓名</strong>、<strong>系名</strong>、<strong>系主任</strong>、<strong>分数</strong><br> 对于</strong>（学号，课名） → 姓名**，有 <strong>学号 → 姓名</strong>，存在非主属性 <strong>姓名</strong> 对码**（学号，课名）<strong>的部分函数依赖。<br> 对于</strong>（学号，课名） → 系名**，有 <strong>学号 → 系名</strong>，存在非主属性 系<strong>名</strong> 对码**（学号，课名）<strong>的部分函数依赖。<br> 对于</strong>（学号，课名） → 系主任**，有 <strong>学号 → 系主任</strong>，存在非主属性 对码**（学号，课名）**的部分函数依赖。</p> 
<p>所以存在非主属性对于码的部分函数依赖，最高只符合1NF的要求，不符合2NF的要求。</p> 
<ul><li><strong>改进：</strong></li></ul> 
<p>为了符合2NF的要求，我们必须消除这些部分函数依赖，只有一个办法，就是将大数据表拆分成两个或者更多个更小的数据表，在拆分的过程中，要达到更高一级范式的要求，这个过程叫做”模式分解“。模式分解的方法不是唯一的，以下是其中一种方法：<br> 选课（学号，课名，分数）<br> 学生（学号，姓名，系名，系主任）</p> 
<p>我们先来判断以下，<strong>选课</strong>表与<strong>学生</strong>表，是否符合了2NF的要求？</p> 
<p>对于<strong>选课</strong>表，其码是**（学号，课名）<strong>，主属性是</strong>学号<strong>和</strong>课名**，非主属性是<strong>分数</strong>，<strong>学号</strong>确定，并不能唯一确定<strong>分数</strong>，<strong>课名</strong>确定，也不能唯一确定<strong>分数</strong>，所以不存在非主属性<strong>分数</strong>对于码 **（学号，课名）**的部分函数依赖，所以此表符合2NF的要求。</p> 
<p>对于<strong>学生</strong>表，其码是<strong>学号，<strong>主属性是</strong>学号</strong>，非主属性是<strong>姓名、系名</strong>和<strong>系主任</strong>，因为码只有一个属性，所以不可能存在非主属性对于码 的部分函数依赖，所以此表符合2NF的要求。</p> 
<p><strong>图</strong>表示了模式分解以后的新的函数依赖关系</p> 
<p><img src="https://images2.imgbox.com/91/a5/5h1bIGHh_o.png" alt="img"></p> 
<p>下表表示了模式分解以后新的数据</p> 
<p><img src="https://images2.imgbox.com/68/4f/RPbSmadh_o.png" alt="img"></p> 
<p>现在我们来看一下，进行同样的操作，是否还存在着之前的那些问题？</p> 
<ol><li>李小明转系到法律系<br> 只需要修改一次李小明对应的系的值即可。——有改进</li><li>数据冗余是否减少了？<br> 学生的姓名、系名与系主任，不再像之前一样重复那么多次了。——有改进</li><li>删除某个系中所有的学生记录<br> 该系的信息仍然全部丢失。——无改进</li><li>插入一个尚无学生的新系的信息。<br> 因为学生表的码是学号，不能为空，所以此操作不被允许。——无改进</li></ol> 
<p>所以说，仅仅符合2NF的要求，很多情况下还是不够的，而出现问题的原因，在于仍然存在非主属性<strong>系主任</strong>对于码<strong>学号</strong>的传递函数依赖。为了能进一步解决这些问题，我们还需要将符合2NF要求的数据表改进为符合3NF的要求。</p> 
<h5><a id="_3NF_141"></a>第三范式 3NF</h5> 
<p><strong>定义：</strong> 非主属性既不传递依赖于码，也不部分依赖于码。</p> 
<p><strong>理解：</strong> 第三范式要求在满足第二范式的基础上，任何非主属性不依赖于其他非主属性，即在第二范式的基础上，消除了传递依赖。</p> 
<p>接下来我们看看上表中的设计，是否符合3NF的要求。</p> 
<p>对于<strong>选课</strong>表，主码为（学号，课名），主属性为<strong>学号</strong>和<strong>课名，<strong>非主属性只有一个，为分数，不可能存在传递函数依赖，所以</strong>选课</strong>表的设计，符合3NF的要求。</p> 
<p>对于<strong>学生</strong>表，主码为<strong>学号</strong>，主属性为<strong>学号</strong>，非主属性为<strong>姓名</strong>、<strong>系名</strong>和<strong>系主任</strong>。因为 学号 → 系名，同时 系名 → 系主任，所以存在非主属性<strong>系主任</strong>对于码<strong>学号</strong>的传递函数依赖，所以<strong>学生</strong>表的设计，不符合3NF的要求。。</p> 
<ul><li><strong>改进</strong></li></ul> 
<p>为了让数据表设计达到3NF，我们必须进一步进行模式分解为以下形式：<br> 选课（学号，课名，分数）<br> 学生（学号，姓名，系名）<br> 系（系名，系主任）</p> 
<p>对于<strong>选课</strong>表，符合3NF的要求，之前已经分析过了。</p> 
<p>对于<strong>学生</strong>表，码为<strong>学号</strong>，主属性为<strong>学号</strong>，非主属性为<strong>系名</strong>，不可能存在非主属性对于码的传递函数依赖，所以符合3NF的要求。</p> 
<p>对于<strong>系</strong>表，码为<strong>系名</strong>，主属性为<strong>系名</strong>，非主属性为<strong>系主任</strong>，不可能存在非主属性对于码的传递函数依赖（至少要有三个属性才可能存在传递函数依赖关系），所以符合3NF的要求。。</p> 
<p>新的函数依赖关系如图</p> 
<p><img src="https://images2.imgbox.com/75/b8/AYgSL8hz_o.png" alt="img"></p> 
<p>新的数据表如下表</p> 
<p><img src="https://images2.imgbox.com/6c/c8/whmJET8L_o.png" alt="img"></p> 
<p>现在我们来看一下，进行同样的操作，是否还存在着之前的那些问题？</p> 
<ol><li>删除某个系中所有的学生记录<br> 该系的信息不会丢失。——有改进</li><li>插入一个尚无学生的新系的信息。<br> 因为系表与学生表目前是独立的两张表，所以不影响。——有改进</li><li>数据冗余更加少了。——有改进</li></ol> 
<ul><li><strong>结论</strong></li></ul> 
<p>由此可见，符合3NF要求的数据库设计，<strong>基本</strong>上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。当然，在实际中，往往为了性能上或者应对扩展的需要，经常 做到2NF或者1NF，但是作为数据库设计人员，至少应该知道，3NF的要求是怎样的。</p> 
<h5><a id="BC_BCFN_186"></a>BC范式 BCFN</h5> 
<p><strong>定义：</strong> 关系模式R&lt;U,F&gt;中，若每一个决定因素都包含码，则R&lt;U,F&gt;属于BCFN。</p> 
<p><strong>理解：</strong> 根据定义我们可以得到结论，一个满足BC范式的关系模式有：</p> 
<ol><li>所有非主属性对每一个码都是完全函数依赖；</li><li>所有主属性对每一个不包含它的码也是完全函数依赖；</li><li>没有任何属性完全函数依赖于非码的任何一组属性。</li></ol> 
<p>要了解 BCNF 范式，那么先看这样一个问题：</p> 
<ol><li>某公司有若干个仓库；</li><li>每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作；</li><li>一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。每种物品在每个仓库中都有对应的数量。</li></ol> 
<p>那么关系模式 仓库（仓库名，管理员，物品名，数量） 属于哪一级范式？</p> 
<p>答：已知函数依赖集：仓库名 → 管理员，管理员 → 仓库名，（仓库名，物品名）→ 数量<br> 码：（管理员，物品名），（仓库名，物品名）<br> 主属性：仓库名、管理员、物品名<br> 非主属性：数量<br> ∵ 不存在非主属性对码的部分函数依赖和传递函数依赖。∴ 此关系模式属于3NF。</p> 
<p>基于此关系模式的关系（具体的数据）可能如图所示：</p> 
<p><img src="https://images2.imgbox.com/ec/7b/DNNfOLhZ_o.png" alt="img"></p> 
<p>好，既然此关系模式已经属于了 3NF，那么这个关系模式是否存在问题呢？我们来看以下几种操作：</p> 
<ol><li>先新增加一个仓库，但尚未存放任何物品，是否可以为该仓库指派管理员？——不可以，因为物品名也是主属性，根据实体完整性的要求，主属性不能为空。</li><li>某仓库被清空后，需要删除所有与这个仓库相关的物品存放记录，会带来什么问题？——仓库本身与管理员的信息也被随之删除了。</li><li>如果某仓库更换了管理员，会带来什么问题？——这个仓库有几条物品存放记录，就要修改多少次管理员信息。</li></ol> 
<p>从这里我们可以得出结论，在某些特殊情况下，即使关系模式符合 3NF 的要求，仍然存在着插入异常，修改异常与删除异常的问题，仍然不是 ”好“ 的设计。</p> 
<ul><li><strong>改进</strong></li></ul> 
<p>造成此问题的原因：存在着<strong>主属性</strong>对于码的部分函数依赖与传递函数依赖。（在此例中就是存在主属性【仓库名】对于码【（管理员，物品名）】的部分函数依赖。</p> 
<p>解决办法就是要在 3NF 的基础上消除<strong>主属性</strong>对于码的部分与传递函数依赖。</p> 
<p>仓库（仓库名，管理员）<br> 库存（仓库名，物品名，数量）</p> 
<p>这样，之前的插入异常，修改异常与删除异常的问题就被解决了。</p> 
<p>以上就是关于 BCNF 的解释。</p> 
<h5><a id="_4NF_237"></a>第四范式 4NF</h5> 
<p><strong>定义：</strong> 限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。</p> 
<p><strong>理解：</strong> 显然一个关系模式是4NF，则必为BCNF。也就是说，当一个表中的非主属性互相独立时（3NF），这些非主属性不应该有多值，若有多值就违反了4NF。</p> 
<h5><a id="_5NF_243"></a>第五范式 5NF</h5> 
<p>第五范式有以下要求：</p> 
<ol><li>必须满足第四范式；</li><li>表必须可以分解为较小的表，除非那些表在逻辑上拥有与原始表相同的主键。</li></ol> 
<p>第五范式是在第四范式的基础上做的进一步规范化。第四范式处理的是相互独立的多值情况，而第五范式则处理相互依赖的多值情况。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e2b7dff893003a1e26998e96dcab6f2b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python萌新爬虫学习笔记【建议收藏】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2947e493c6afe7bfda6976f5bd32736b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">小程序Taro框架 自定义底部Tabbar，处理自定义Tab栏切换卡顿、闪烁</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>