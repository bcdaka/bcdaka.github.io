<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;】C&#43;&#43;11的新特性 --- 右值引用与移动语义 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/62992984b540b6521f0288df4ce3a3a7/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;】C&#43;&#43;11的新特性 --- 右值引用与移动语义">
  <meta property="og:description" content="假如生活欺骗了你 不要悲伤，不要心急！ 忧郁的日子里须要镇静 相信吧 快乐的日子将会来临 -- 普希金 《假如生活欺骗了你》 C&#43;&#43;11的新特性 1 左值与右值2 左值引用和右值引用3 引用的意义4 移动语义4.1 移动构造与移动赋值4.2 区分现代写法与移动语义4.3 实践中落实移动语义 5 万能引用和完美转发Thanks♪(･ω･)ﾉ谢谢阅读！！！下一篇文章见！！！ 1 左值与右值 C&#43;&#43;中，一个表达式不是右值就是左值。C语言中：左值可以位于赋值对象的左边，右值则不能。在C&#43;&#43;中就没有这么简单了。在C&#43;&#43;中的左右值可以通过是否可以取地址来区分：
左值表示一个占据内存中可识别位置的一个对象，有可能是一个表达式。更进一步地，可以对左值取地址右值即不能进行取地址的值或表达式。包括常量，加减乘除等表达式，临时对象。 PS:左值和右值在内存中都是有地址的，只有左值可以取地址！
左值包括变量名，解引用的指针的等。下面是比较经典的左值，他们都可以进行取地址操作！
注意左值引用和右值引用都是左值
int a = 1; int* p = &amp;a; int** pp = &amp;p; const int b = 2; 右值一般是常量，表达式，临时变量 ,对于一个常量肯定是无法取地址的！
&amp;10; &amp;(1 &#43; 1); &amp;string(&#34;111&#34;); 当一个对象被作为右值进行使用时，用的是对象的值（内容）；用做左值时，实际使用的是对象的身份（在内存中的位置）
2 左值引用和右值引用 左值引用就是对左值进行取别名：
int a = 1; int&amp; ra = a; int* p = &amp;a;	int*&amp; rp = p 右值引用就是对右值进行取别名：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-18T23:33:16+08:00">
    <meta property="article:modified_time" content="2024-07-18T23:33:16+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;】C&#43;&#43;11的新特性 --- 右值引用与移动语义</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/f7/d6/1VzxPPmI_o.png" alt="在这里插入图片描述"></p> 
<div align="center"> 
 <font color="#F48620" size="5">假如生活欺骗了你 </font> 
 <div align="center"> 
  <font color="#F48620" size="5">不要悲伤，不要心急！ </font> 
  <div align="center"> 
   <font color="#F48620" size="5">忧郁的日子里须要镇静 </font> 
   <div align="center"> 
    <font color="#F48620" size="5">相信吧 </font> 
    <div align="center"> 
     <font color="#F48620" size="5">快乐的日子将会来临 </font> 
     <div align="center"> 
      <font color="#F48620" size="5">-- 普希金 《假如生活欺骗了你》 </font> 
     </div> 
    </div> 
   </div> 
  </div> 
 </div> 
</div> 
<hr> 
<p></p> 
<div class="toc"> 
 <h4>C++11的新特性 </h4> 
 <ul><li><a href="#1__11" rel="nofollow">1 左值与右值</a></li><li><a href="#2__35" rel="nofollow">2 左值引用和右值引用</a></li><li><a href="#3__55" rel="nofollow">3 引用的意义</a></li><li><a href="#4__96" rel="nofollow">4 移动语义</a></li><li><ul><li><a href="#41__97" rel="nofollow">4.1 移动构造与移动赋值</a></li><li><a href="#42__220" rel="nofollow">4.2 区分现代写法与移动语义</a></li><li><a href="#43__241" rel="nofollow">4.3 实践中落实移动语义</a></li></ul> 
  </li><li><a href="#5__378" rel="nofollow">5 万能引用和完美转发</a></li><li><a href="#Thanks_453" rel="nofollow">Thanks♪(･ω･)ﾉ谢谢阅读！！！</a></li><li><a href="#_454" rel="nofollow">下一篇文章见！！！</a></li></ul> 
</div> 
<p></p> 
<h2><a id="1__11"></a>1 左值与右值</h2> 
<p>C++中，一个表达式不是右值就是左值。C语言中：左值可以位于赋值对象的左边，右值则不能。在C++中就没有这么简单了。在C++中的左右值可以通过是否可以取地址来区分：</p> 
<ol><li>左值表示一个占据内存中可识别位置的一个对象，有可能是一个表达式。<strong>更进一步地，可以对左值取地址</strong></li><li>右值即不能进行取地址的值或表达式。包括常量，加减乘除等表达式，临时对象。</li></ol> 
<p>PS:左值和右值在内存中都是有地址的，只有左值可以取地址！</p> 
<p>左值包括变量名，解引用的指针的等。下面是比较经典的左值，他们都可以进行取地址操作！<br> <font color="red"><strong>注意左值引用和右值引用都是左值</strong></font></p> 
<pre><code class="prism language-cpp">	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">*</span> pp <span class="token operator">=</span> <span class="token operator">&amp;</span>p<span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre> 
<p>右值一般是常量，表达式，临时变量 ,对于一个常量肯定是无法取地址的！</p> 
<pre><code class="prism language-cpp"><span class="token operator">&amp;</span><span class="token number">10</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"111"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>当一个对象被作为右值进行使用时，用的是对象的值（内容）；用做左值时，实际使用的是对象的身份（在内存中的位置）</p> 
<h2><a id="2__35"></a>2 左值引用和右值引用</h2> 
<p>左值引用就是对左值进行取别名：</p> 
<pre><code class="prism language-cpp">	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    		<span class="token keyword">int</span><span class="token operator">&amp;</span> ra <span class="token operator">=</span> a<span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>		<span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">&amp;</span> rp <span class="token operator">=</span> p
</code></pre> 
<p>右值引用就是对右值进行取别名：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> rra <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
string<span class="token operator">&amp;&amp;</span> rrb <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"111"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
string<span class="token operator">&amp;&amp;</span> rrb <span class="token operator">=</span> <span class="token function">to_string</span><span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>左值引用不可以给右值取别名，<font color="red"><strong>但是const左值引用可以</strong></font></p> 
<pre><code class="prism language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> ra <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> string<span class="token operator">&amp;</span> rb <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"111"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>右值引用不可以对左值取别名，<font color="red"><strong>但是可以给move后的左值取别名</strong>.move也是C++11新加入的特性，我们后面讲。</font></p> 
<h2><a id="3__55"></a>3 引用的意义</h2> 
<p>在之前，我们使用引用的目的是什么？是为了减少拷贝，提高性能。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//传引用参数</span>
string<span class="token operator">&amp;</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//传引用返回</span>
</code></pre> 
<p>但是，引用返回也会出现一些问题，比如一个函数返回临时变量的引用，这时就会出错。临时变量的生命周期只在<code>func2</code>函数，<code>func2</code>函数返回一个临时变量的引用,在函数执行结束，临时变量就会进行销毁！右值引用也无法解决生命周期的问题！</p> 
<p>那右值引用的意义在哪里呢？？？<br> 我们来看一个情景：(bit::string是自己写的string类，方便看效果)</p> 
<pre><code class="prism language-cpp">bit<span class="token double-colon punctuation">::</span>string ret1 <span class="token operator">=</span> bit<span class="token double-colon punctuation">::</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token number">1234</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>这个会进行几次深拷贝？<br> <img src="https://images2.imgbox.com/1b/2e/wfgCXuH9_o.png" alt="在这里插入图片描述"><br> 按理来说，应该会会进行两次拷贝构造，首先拷贝构造临时变量，然后ret1在拷贝构造。但是编译器进行了一个优化，实际上只进行了一次拷贝构造。</p> 
<p>当我们把这个表达式分开写，就不会进行优化了,没有办法合二为一</p> 
<pre><code class="prism language-cpp">bit<span class="token double-colon punctuation">::</span>string ret1<span class="token punctuation">;</span>
ret1 <span class="token operator">=</span> <span class="token function">to_string</span><span class="token punctuation">(</span><span class="token number">1234</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>这两种情况的拷贝的代价都挺大，有没有一种简单的解决办法来避免进行深拷贝？<br> 这里可不能使用左值引用，<strong>因为临时变量在该行函数结束就销毁</strong>，在主函数里会直接挂掉！使用右值引用会直接报语法错误，因为在<code>to_string</code>中返回值是一个左值，左值是不能被右值引用的！<br> <strong>如果将该左值进行<code>move()</code>他就可以被右值引用。</strong></p> 
<pre><code class="prism language-cpp">bit<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;&amp;</span> <span class="token function">to_string</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	bit<span class="token double-colon punctuation">::</span>string str<span class="token punctuation">;</span>
	<span class="token comment">//...</span>
	<span class="token comment">//处理</span>
	<span class="token comment">//...</span>
	<span class="token keyword">return</span> <span class="token function">move</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这样运行依旧会挂掉，因为右值引用也是别名，**无法解决生命周期的问题！**这里左值引用和右值引用是没有区别的！<br> 栈桢图是这样的：<br> <img src="https://images2.imgbox.com/e3/e2/wuMiML3R_o.png" alt="在这里插入图片描述"><br> 编译器优化后会只进行一次拷贝构造<code>ret1</code>，但还是进行了深拷贝！</p> 
<p>所以这个深拷贝的问题无法通过左值引用或者右值引用来解决！所以就有了移动语义！</p> 
<h2><a id="4__96"></a>4 移动语义</h2> 
<h3><a id="41__97"></a>4.1 移动构造与移动赋值</h3> 
<p>C++11中就加入了一个针对右值引用的拷贝构造 — 移动构造！</p> 
<p>PS:<code>左值引用</code>是拷贝构造 ，<code>右值引用</code>是移动构造！— 构成函数重载</p> 
<pre><code class="prism language-cpp"><span class="token comment">//拷贝构造 --- const 左值可以接收左值和右值</span>
<span class="token function">string</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token operator">:</span>
	<span class="token function">_str</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span>_capacity <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
	<span class="token punctuation">,</span><span class="token function">_size</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">,</span><span class="token function">_capacity</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"string(const string&amp; s = "</span><span class="token string">")  --- 深拷贝"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token function">strcpy</span><span class="token punctuation">(</span>_str<span class="token punctuation">,</span> s<span class="token punctuation">.</span>_str<span class="token punctuation">)</span><span class="token punctuation">;</span>
	_size <span class="token operator">=</span> s<span class="token punctuation">.</span>_size<span class="token punctuation">;</span>
	_capacity <span class="token operator">=</span> s<span class="token punctuation">.</span>_capacity<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//移动构造</span>
<span class="token function">string</span><span class="token punctuation">(</span>string<span class="token operator">&amp;&amp;</span> s<span class="token punctuation">)</span>
	<span class="token operator">:</span><span class="token function">_str</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"string(string&amp;&amp; s) --- 移动构造"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token function">swap</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面我们已经知道了右值引用的的一般类型：匿名对象 ，传值返回的临时对象</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> rra <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
string<span class="token operator">&amp;&amp;</span> rrb <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"111"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//匿名对象</span>
string<span class="token operator">&amp;&amp;</span> rrb <span class="token operator">=</span> <span class="token function">to_string</span><span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//传值返回的临时对象</span>
</code></pre> 
<p>这里进行一下跟细致的区分：纯右值和将亡值</p> 
<ol><li>纯右值：内置类型的右值引用是纯右值 ：<code>int&amp;&amp; a == 10 ；int&amp;&amp; b = (1 + 1);</code></li><li>将亡值：自定义类型的右值引用，生命周期只有一行。</li></ol> 
<p>分析一下左值的拷贝构造，因为传入的是一个左值，其有自己的内存中的位置，不能修改！必须进行深度的拷贝。但是如果是一个右值，是一个临时变量的右值引用（将亡值），其生命周期就一行，就可以对其进行修改！</p> 
<pre><code class="prism language-cpp"><span class="token function">string</span><span class="token punctuation">(</span>string<span class="token operator">&amp;&amp;</span> s<span class="token punctuation">)</span>
	<span class="token operator">:</span><span class="token function">_str</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">swap</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//直接将亡值的替换就可以</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>直接进行替换不就可以了？反正也是将亡的，不用他就直接销毁了，怪可惜的！<br> <img src="https://images2.imgbox.com/7d/2d/J2VcKVDQ_o.png" alt="在这里插入图片描述"></p> 
<p>**移动构造就是用来解决这个问题的！**通过<code>to_string</code>返回的对左值的<code>move</code>的右值引用,就会调用到移动构造，就避免了深拷贝！（PS:不显式加上<code>move</code>也会调用到移动构造，编译器的优化很强，会强行识别成右值进而进行移动构造！）<br> <img src="https://images2.imgbox.com/35/70/TAemr86H_o.png" alt="在这里插入图片描述"></p> 
<p>移动构造的代价是很低的，因为是使用的同一块地址，没有开辟新的空间！注意移动构造只能对右值进行处理！必须是将亡值才有可以进行移动构造！<br> 再来看个例子</p> 
<pre><code class="prism language-cpp">
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	string <span class="token function">s1</span><span class="token punctuation">(</span><span class="token string">"1111111111111111111"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	string s2 <span class="token operator">=</span> s1<span class="token punctuation">;</span>
	string s3 <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>s2是拷贝构造，开辟了新空间。s3进行移动构造，导致S1和空的s3进行了交换，s1变成了空！</p> 
<p>对于分开书写的两行代码，编译器也无法进行优化，会进行两次深拷贝！而有了移动构造和移动赋值，都是对一块资源的移动，成本很低！ <font color="red"><strong>移动构造彻底解决传值返回的性能问题!!!</strong><br> <img src="https://images2.imgbox.com/54/2a/GL9m4VPQ_o.png" alt="在这里插入图片描述"><br> 这里有点像拷贝的现代写法，但是拷贝的现代写法的本质还是开辟空间！</font></p> 
<p>我们来看一个实际使用中的代吗：杨辉三角</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">generate</span><span class="token punctuation">(</span><span class="token keyword">int</span> numRows<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">vv</span><span class="token punctuation">(</span>numRows<span class="token punctuation">)</span> <span class="token punctuation">;</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> numRows <span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>

            vv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                vv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                vv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> vv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
                vv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span>  vv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span>j <span class="token operator">&lt;</span> i <span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    vv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> vv<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> vv<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> vv<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> ret<span class="token punctuation">;</span>
	ret <span class="token operator">=</span> Solution<span class="token punctuation">.</span><span class="token function">generate</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre> 
<p>这段代码是很坑的，我们来分析一下：</p> 
<ol><li>首先杨辉三角中的核心是二维数组：<code>vector&lt;vector&lt;int&gt;&gt;</code>，这就注定其深拷贝的时间复杂度是O(n^2)。</li><li>然后返回值是传值返回？这在调用的时候很明显会创建临时变量，就会进行深拷贝！</li></ol> 
<p>这就导致使用的之后传入一个较大数<code>1000</code>,会进行两次深拷贝,每次深拷贝的代价都很大！</p> 
<p>所以实践中不能写这样的代码，可以改成：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token keyword">void</span> <span class="token function">generate</span><span class="token punctuation">(</span><span class="token keyword">int</span> numRows <span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span><span class="token operator">&amp;</span> vv<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>这样可以避免临时变量的深拷贝。在C++11之前都是这样保证效率，现在当然最好还是使用<code>右值引用+移动赋值</code>来解决。直接进行资源的转移，避免不必要的深拷贝！编译器会自动将返回值识别成右值，进而进行移动辅助！</p> 
<h3><a id="42__220"></a>4.2 区分现代写法与移动语义</h3> 
<p>我们先来看赋值重载的现代写法：</p> 
<pre><code class="prism language-cpp">		string<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">//现代写法	</span>
			string <span class="token function">tmp</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">swap</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
</code></pre> 
<p>现代写法并没有减小成本，本质还是进行了深拷贝，传入的还是左值。没有性能的提升。<br> 再来看移动赋值</p> 
<pre><code class="prism language-cpp">		string<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>string<span class="token operator">&amp;&amp;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">swap</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
</code></pre> 
<p>因为传入的是这里只进行了一次资源的交换，没有进行深拷贝，对性能有很大的提升！</p> 
<h3><a id="43__241"></a>4.3 实践中落实移动语义</h3> 
<p>前面我们说过：<strong>左值引用和右值引用都是左值</strong>。我们可以来验证一下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token comment">//函数重载</span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func(string&amp; s)  --- 左值引用"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>string<span class="token operator">&amp;&amp;</span> s<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func(string&amp; s)  --- 右值引用"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	string <span class="token function">s</span><span class="token punctuation">(</span><span class="token string">"111"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	string<span class="token operator">&amp;</span> s1 <span class="token operator">=</span> s<span class="token punctuation">;</span>
	string<span class="token operator">&amp;&amp;</span> s2 <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"111"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">func</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">func</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>我们运行看看：<br> <img src="https://images2.imgbox.com/a6/8f/EHeMONHM_o.png" alt="在这里插入图片描述"><br> 左值引用和右值引用都匹配到了左值引用的函数，证明了左值引用和右值引用都是左值。<strong>只有这样才能逻辑自洽！</strong><br> 回看移动赋值,在里面<code>to_string</code>的返回值成为<code>string&amp;&amp; s</code>，里面进行了一步<code>swap(s)</code>。我们又知道右值本身是不能被改变的，如果右值引用作为了一个右值的别名是右值的话，那么还是不能进改变，那如何进行资源的转移呢？<br> <img src="https://images2.imgbox.com/d1/d5/QwhvPfsC_o.png" alt="在这里插入图片描述"><br> 只有右值引用本身是左值，才能实现移动构造和移动赋值中的资源转移！！！<br> 这实现了逻辑的自洽：右值引用的属性如果是右值，那么移动构造和移动赋值要进行转移资源的语法就是矛盾的，右值是不能进行改变的（可以理解为右值自带<code>const</code>属性），右值是有空间存储的，只是语法不允许取地址，但是是可以想办法取到的!<br> 强转和再次引用（先转换为左值）都可以取到</p> 
<pre><code class="prism language-cpp">	string<span class="token operator">&amp;&amp;</span> s2 <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"111"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	string<span class="token operator">&amp;</span> s3 <span class="token operator">=</span> s2<span class="token punctuation">;</span>
	
	string<span class="token operator">&amp;</span> s4 <span class="token operator">=</span> <span class="token punctuation">(</span>string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"111"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>理解上述内容，接下来我们就来看<code>List</code>中如何使用移动语义<br> 我们来看<code>push_back()</code><br> C++11中增添了右值引用版本的<br> <img src="https://images2.imgbox.com/42/5d/0tkMtoqB_o.png" alt="在这里插入图片描述"><br> 我们来底层中来细细品味：<br> <img src="https://images2.imgbox.com/cb/78/5b7OSwVq_o.png" alt="在这里插入图片描述"><br> 我们进行插入string是进行了一次构造和深拷贝，这是list内部<code>push_back()</code>中创建新节点中会创建一个string，然后进行拷贝。里面s1是左值，所以进行的是深拷贝！！！我们换一种方式<br> <img src="https://images2.imgbox.com/62/37/2vDM36gj_o.png" alt="在这里插入图片描述"><br> 这样在节点创建中创建string进行了一次构造，然后就是移动构造了，因为这里是匿名对象，是一个将亡值，编译器自动匹配了移动构造！<font color="red"><strong>所以我们在平时写代码中使用匿名对象会使效率更高!!!</strong></font></p> 
<p>然后我们来自己实现一下：<br> <img src="https://images2.imgbox.com/b7/b6/opHbjuR1_o.png" alt="在这里插入图片描述"><br> 首先我们看到我们初始化一个list会进行一次构造和深拷贝，这是因为头结点的缘故。而STL库中的是使用内存池（没有初始化），所以不会打印出来。<br> 我们赶紧来看<code>push_back</code>，如果只有一个左值引用的版本，无论左值还是右值都只能调用这个。我们加一个右值版本：</p> 
<pre><code class="prism language-cpp">		<span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x <span class="token operator">=</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//找尾</span>
			<span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> x<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//找尾</span>
			<span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
</code></pre> 
<p>我们试试<br> <img src="https://images2.imgbox.com/dc/1e/4q9NVQZc_o.png" alt="在这里插入图片描述"><br> 哎嘿！？怎么插入右值和插入左值都是深拷贝啊？其实我们看一下<code>push_back</code>中调用的<code>insert</code>就明白了。<code>push_back</code>支持右值了，可是<code>insert</code>还没有右值的版本啊！我们还要补充<code>insert</code>的右值版本</p> 
<pre><code class="prism language-cpp">		<span class="token comment">//右值版本</span>
		<span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>iterator pos <span class="token operator">=</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> T<span class="token operator">&amp;&amp;</span> x <span class="token operator">=</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			Node<span class="token operator">*</span> prev <span class="token operator">=</span> pos<span class="token punctuation">.</span>_node<span class="token operator">-&gt;</span>_prev<span class="token punctuation">;</span>
			Node<span class="token operator">*</span> next <span class="token operator">=</span> pos<span class="token punctuation">.</span>_node<span class="token punctuation">;</span>

			Node<span class="token operator">*</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>

			node<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>
			node<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> next<span class="token punctuation">;</span>
			prev<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> node<span class="token punctuation">;</span>
			next<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> node<span class="token punctuation">;</span>

			_size<span class="token operator">++</span><span class="token punctuation">;</span>

		<span class="token punctuation">}</span>
</code></pre> 
<p>再来看看：<br> <img src="https://images2.imgbox.com/d2/32/FWh2ONCk_o.png" alt="在这里插入图片描述"><br> 哎？还是这样？为什么呢？我们在分析分析<code>insert</code>内部，其中的<code>Node* node = new Node(x);</code>这一步会调用<code>node</code>的构造函数，而<code>node</code>还没有支持右值引用的移动构造啊！所以我们还要为节点增添一个移动构造</p> 
<pre><code class="prism language-cpp">		<span class="token function">ListNode</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> x <span class="token punctuation">)</span> <span class="token operator">:</span>
			<span class="token function">_next</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
			<span class="token function">_prev</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
			<span class="token function">_data</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre> 
<p>这样移动构造内部会调用<code>_data</code>的构造，而这里<code>_data</code>是<code>string</code>我们已经写好了移动构造，那这次应该就可以了吧？<br> <img src="https://images2.imgbox.com/bc/ca/8mZucc3k_o.png" alt="在这里插入图片描述"><br> 答案是 NO!!!<br> 还记得上面说过：<font color="red">左值引用和右值引用都是左值!</font></p> 
<p>第一层的<code>push_back()</code>是可以调用到右值引用的版本，第二次的<code>insert()</code>的第二个参数无论是左值引用还是右值引用，都只会调用左值版本？这要怎么解决呢？我们可以进行<code>move</code>！</p> 
<pre><code class="prism language-cpp">		<span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> x<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">move</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>iterator pos <span class="token operator">=</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> T<span class="token operator">&amp;&amp;</span> x <span class="token operator">=</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			Node<span class="token operator">*</span> prev <span class="token operator">=</span> pos<span class="token punctuation">.</span>_node<span class="token operator">-&gt;</span>_prev<span class="token punctuation">;</span>
			Node<span class="token operator">*</span> next <span class="token operator">=</span> pos<span class="token punctuation">.</span>_node<span class="token punctuation">;</span>

			Node<span class="token operator">*</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token function">move</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

			node<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>
			node<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> next<span class="token punctuation">;</span>
			prev<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> node<span class="token punctuation">;</span>
			next<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> node<span class="token punctuation">;</span>
			_size<span class="token operator">++</span><span class="token punctuation">;</span>

		<span class="token punctuation">}</span>
		<span class="token comment">//....</span>
		<span class="token function">ListNode</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> x <span class="token punctuation">)</span> <span class="token operator">:</span>
			<span class="token function">_next</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
			<span class="token function">_prev</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
			<span class="token function">_data</span><span class="token punctuation">(</span><span class="token function">move</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre> 
<p>这样经过每一层的<code>move</code>保证了每次传递的都是右值：<br> <img src="https://images2.imgbox.com/65/f4/YyinF4Np_o.png" alt="在这里插入图片描述"><br> 我们就得到了想要的结果！！！</p> 
<p><font color="red" size="4">PS:对于内置类型或者Data来中，左值和右值是没有区别的，他们不会涉及到深拷贝的问题！使用涉及深拷贝的自定义类型才会涉及移动构造和移动赋值！</font></p> 
<h2><a id="5__378"></a>5 万能引用和完美转发</h2> 
<p>这里在介绍一个新语法：完美转发。它也可以上述做到<code>move</code>的效果，甚至更好！我们最好是使用完美转发！</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">PerfectForward</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">Fun</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">PerfectForward</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右值</span>

	<span class="token keyword">int</span> a<span class="token punctuation">;</span>
	<span class="token function">PerfectForward</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 左值</span>
	<span class="token function">PerfectForward</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右值</span>

	<span class="token keyword">const</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
	<span class="token function">PerfectForward</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// const 左值</span>
	<span class="token function">PerfectForward</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// const 右值</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>上面的<code>PerfectForward(T&amp;&amp; t)</code>被叫做万能引用（引用折叠），虽然看上去是一个右值引用，但是他可以随机应变：传左值就是左值引用，穿右值就是右值引用。我们验证一下<br> <img src="https://images2.imgbox.com/d8/81/BQ0AmMfh_o.png" alt="在这里插入图片描述"><br> 可以看到，不是对应匹配的。因为还是那个原因：左值引用和右值引用都是左值！！！而引用折叠虽然会帮助我们实例化出：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">PerfectForward</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> t<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">Fun</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">PerfectForward</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> t<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">Fun</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">)</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">PerfectForward</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> t<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">Fun</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">PerfectForward</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> t<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">Fun</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">)</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>但是由于右值引用是左值，所以根本调用不到右值版本！！！<br> 所以这里如果使用<code>move</code>，行不行呢？我们试试：<br> <img src="https://images2.imgbox.com/45/71/ufACYEkQ_o.png" alt="在这里插入图片描述"></p> 
<p><code>move</code>也无法解决这个问题，因为加上<code>move</code>之后，所以实例化的函数也都带有了<code>func(move(t))</code>,所有的都变成了右值，而我们想要的是该左值就是左值，该右值就是右值，所以就有了完美转发 — <code>std::forward&lt;T&gt;(t)</code></p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">PerfectForward</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">func</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>完美解决：<br> <img src="https://images2.imgbox.com/77/55/PpjclDQg_o.png" alt="在这里插入图片描述"><br> 完美转发就做到了：<font color="red" size="4">**完美转发在传参的过程中保留对象原生类型属性!**完美转发是在函数模版里面帮助辅助传参的！</font></p> 
<ul><li>实参传左值，就推导成左值引用</li><li>实参传右值，就推导成右值引用</li></ul> 
<p>完美转发本质上类似进行了一次强转！可以简单的这样理解：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">PerfectForward</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面的<code>list</code>也可以将<code>move</code>该成完美转发了！</p> 
<h2><a id="Thanks_453"></a>Thanks♪(･ω･)ﾉ谢谢阅读！！！</h2> 
<h2><a id="_454"></a>下一篇文章见！！！</h2>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1ff65ac0db6034fe1f3f676338b12bf5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【微服务】第37节：微服务的注册中心Eureka</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/574ed867c555890561059e376ae70f65/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">最新开源的解析效果非常好的PDF解析工具MinerU （pdf2md pdf2json）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>