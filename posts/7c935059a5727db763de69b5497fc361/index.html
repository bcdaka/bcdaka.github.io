<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构之八大排序（上） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/7c935059a5727db763de69b5497fc361/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构之八大排序（上）">
  <meta property="og:description" content="找往期文章包括但不限于本期文章中不懂的知识点：
个人主页：我要学编程(ಥ_ಥ)-CSDN博客
所属专栏：数据结构（Java版） 目录
排序的相关介绍
直接插入排序 希尔排序（缩小增量排序）
选择排序
堆排序
冒泡排序 排序的相关介绍 排序的概念：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。
稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。
内部排序：数据元素全部放在内存中的排序。
外部排序：数据元素太多不能同时放在内存中，根据排序的要求在内外存之间移动数据的排序。
两个5的相对位置发生了变化，就是不稳定的排序。
注意：稳定的排序，也可以变成是不稳定的排序；而不稳定的排序无法变成稳定的排序。
排序运用：我们日常生活中，在网上买东西时，根据价钱来筛选，这就用到了排序。
常见的排序算法有八种，根据对数据的处理方式分类：
下面我们就来详细学习：
直接插入排序 思路：把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列 。实际中我们玩扑克牌时，就用了插入排序的思想。 思路：
代码实现：
public static void insertSort(int[] array) { for (int i = 1; i &lt; array.length; i&#43;&#43;) { int j = i-1; int tmp = array[i]; while (j &gt;= 0) { if (array[j] &gt; tmp) { // 大于，就让其往后走 array[j&#43;1] = array[j]; j--; } else { // 有序就直接判断后面的 break; } } // 让tmp中的值回到数组中 array[j&#43;1] = tmp; } } 时间复杂度：O(N^2)：最坏情况就是数据全部是逆序的。例如：我们是要排成从小到大的顺序，数据给的是 5 4 3 2 1。然而，当数据本身就是有序的情况下，也就只会进行判断，因此这时的时间复杂度就是O(N)。这里就可以得出一个结论：数据越有序，效率越高。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-31T09:24:44+08:00">
    <meta property="article:modified_time" content="2024-07-31T09:24:44+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构之八大排序（上）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>找往期文章包括但不限于本期文章中不懂的知识点：</p> 
<blockquote> 
 <p><strong>个人主页：</strong><a href="https://blog.csdn.net/2301_80854132?type=blog" title="我要学编程(ಥ_ಥ)-CSDN博客">我要学编程(ಥ_ಥ)-CSDN博客</a></p> 
 <p><strong>所属专栏：<strong><strong><strong><strong><strong><strong><strong><a href="https://blog.csdn.net/2301_80854132/category_12650676.html" title="数据结构（Java版）">数据结构（Java版）</a></strong></strong></strong></strong></strong></strong></strong></strong> </p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E6%8E%92%E5%BA%8F%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><a href="#%E6%8E%92%E5%BA%8F%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D" rel="nofollow">排序的相关介绍</a></p> 
<p id="%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%C2%A0-toc" style="margin-left:0px;"><a href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%C2%A0" rel="nofollow">直接插入排序 </a></p> 
<p id="%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88%E7%BC%A9%E5%B0%8F%E5%A2%9E%E9%87%8F%E6%8E%92%E5%BA%8F%EF%BC%89-toc" style="margin-left:0px;"><a href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88%E7%BC%A9%E5%B0%8F%E5%A2%9E%E9%87%8F%E6%8E%92%E5%BA%8F%EF%BC%89" rel="nofollow">希尔排序（缩小增量排序）</a></p> 
<p id="%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-toc" style="margin-left:0px;"><a href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" rel="nofollow">选择排序</a></p> 
<p id="%E5%A0%86%E6%8E%92%E5%BA%8F-toc" style="margin-left:0px;"><a href="#%E5%A0%86%E6%8E%92%E5%BA%8F" rel="nofollow">堆排序</a></p> 
<p id="%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%C2%A0-toc" style="margin-left:0px;"><a href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%C2%A0" rel="nofollow">冒泡排序 </a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E6%8E%92%E5%BA%8F%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D"><span style="color:#fe2c24;">排序的相关介绍</span></h2> 
<p>排序的概念：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。</p> 
<p>稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。</p> 
<p>内部排序：数据元素全部放在内存中的排序。</p> 
<p>外部排序：数据元素太多不能同时放在内存中，根据排序的要求在内外存之间移动数据的排序。</p> 
<p><img alt="" height="775" src="https://images2.imgbox.com/97/11/13KyCTlp_o.png" width="1200"></p> 
<p>两个5的相对位置发生了变化，就是不稳定的排序。</p> 
<p>注意：稳定的排序，也可以变成是不稳定的排序；而不稳定的排序无法变成稳定的排序。</p> 
<p>排序运用：我们日常生活中，在网上买东西时，根据价钱来筛选，这就用到了排序。</p> 
<p>常见的排序算法有八种，根据对数据的处理方式分类：</p> 
<p><img alt="" height="773" src="https://images2.imgbox.com/07/b0/4vymodDJ_o.png" width="1200"></p> 
<p>下面我们就来详细学习：</p> 
<h2 id="%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%C2%A0"><span style="color:#fe2c24;">直接插入排序 </span></h2> 
<p>思路：把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列 。实际中我们玩扑克牌时，就用了插入排序的思想。 </p> 
<p><img alt="" height="590" src="https://images2.imgbox.com/f1/1f/4rBzI4bb_o.png" width="1089"></p> 
<p>思路：</p> 
<p><img alt="" height="721" src="https://images2.imgbox.com/43/e2/qLNVneHy_o.png" width="1200"></p> 
<p><img alt="" height="1083" src="https://images2.imgbox.com/9e/1d/FZbKnZtB_o.png" width="1200"></p> 
<p>代码实现：</p> 
<pre><code class="language-java">    public static void insertSort(int[] array) {
        for (int i = 1; i &lt; array.length; i++) {
            int j = i-1;
            int tmp = array[i];
            while (j &gt;= 0) {
                if (array[j] &gt; tmp) {
                    // 大于，就让其往后走
                    array[j+1] = array[j];
                    j--;
                } else {
                    // 有序就直接判断后面的
                    break;
                }
            }
            // 让tmp中的值回到数组中
            array[j+1] = tmp;
        }
    }</code></pre> 
<p>时间复杂度：O(N^2)：最坏情况就是数据全部是逆序的。例如：我们是要排成从小到大的顺序，数据给的是 5 4 3 2 1。然而，当数据本身就是有序的情况下，也就只会进行判断，因此这时的时间复杂度就是O(N)。这里就可以得出一个结论：数据越有序，效率越高。</p> 
<p>空间复杂度：O(1) ：只申请了常数个空间</p> 
<p>稳定性： 稳定的排序。本身是一个稳定的排序，可以实现为不稳定的。</p> 
<h2 id="%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88%E7%BC%A9%E5%B0%8F%E5%A2%9E%E9%87%8F%E6%8E%92%E5%BA%8F%EF%BC%89"><span style="color:#fe2c24;">希尔排序（缩小增量排序）</span></h2> 
<p>希尔排序法又称缩小增量法。希尔排序法的基本思想是：先选定一个整数，把待排序文件中所有记录分成多个组， 所有距离为的记录分在同一组内，并对每一组内的记录进行排序。然后，取重复上述分组和排序的工作。当到达分组 =1时，所有记录在统一组内排好序。如下图所示：</p> 
<p><img alt="" height="1016" src="https://images2.imgbox.com/bd/52/0iC85EZI_o.png" width="1200"></p> 
<p>这个gap的求值有很多种最常见的就是：总数据 / 2 和 总数据 / 3 + 1。</p> 
<p>代码实现：</p> 
<pre><code class="language-java">    public static void shellSort(int[] array) {
        // 先分组
        int gap = array.length;
        while (gap &gt; 1) {
            gap /= 2;
            // 根据分组来排序
            shell(array, gap);
        }
    }

    // 分组排序
    private static void shell(int[] array, int gap) {
        // i 是组内要排序的第二个数据
        for (int i = gap; i &lt; array.length; i++) {
            // j 是组内要排序的第一个数据
            int j = i-gap;
            int tmp = array[i];
            while (j &gt;= 0) {
                if (array[j] &gt; tmp) {
                    array[j+gap] = array[j];
                    j -= gap;
                } else {
                    break;
                }
            }
            array[j+gap] = tmp;
        }
    }</code></pre> 
<p>注意：</p> 
<p>1、希尔排序是对直接插入排序的优化。</p> 
<p>2、i 在加时，虽然 i += gap ，最终的排序结果是对的（因为gap 最终还是会等于1，就相当于直接进行直接插入排序了），但是并不符合逻辑要求。</p> 
<p>3、当gap &gt; 1时都是预排序，目的是让数组更接近于有序。当gap == 1时，数组已经接近有序的了，这样就会很快。这样整体而言，可以达到优化的效果。</p> 
<p>4、希尔排序的时间复杂度不好计算，因为gap的取值方法很多，导致很难去计算。</p> 
<p>时间复杂度：O(n^1.3 - n^1.5)：很多著名的书籍上面的估算结果。</p> 
<p>空间复杂度：O(1)：申请了常数个空间。</p> 
<p>稳定性：不稳定。</p> 
<h2 id="%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span style="color:#fe2c24;">选择排序</span></h2> 
<p>基本思想：每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完 。</p> 
<p><img alt="" height="436" src="https://images2.imgbox.com/ab/0c/DGHnxMY1_o.png" width="1200"></p> 
<p>代码实现：</p> 
<pre><code class="language-java">    public static void selectSort(int[] array) {
        for (int i = 0; i &lt; array.length; i++) {
            int minIndex = i;
            for (int j = i+1; j &lt; array.length; j++) {
                // 更新最小值下标
                if (array[j] &lt; array[minIndex]) {
                    minIndex = j;
                }
            }
            // 交换
            if (minIndex != i) {
                swap(array, i, minIndex);
            }
        }
    }

    private static void swap(int[] array, int i, int j) {
        int tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
    }</code></pre> 
<p>注意： </p> 
<p>1. 直接选择排序思考非常好理解，但是效率不是很好。实际中很少使用。</p> 
<p>2. 时间复杂度：O(N^2)：无论是最好情况还是最坏情况，时间复杂度都是一样的。也就是说和数据的顺序无关。</p> 
<p>3. 空间复杂度：O(1)：申请了常数个空间。</p> 
<p>4. 稳定性：不稳定。 </p> 
<p><img alt="" height="1148" src="https://images2.imgbox.com/8c/b9/e5QEtPnx_o.png" width="1200"></p> 
<p>情况二属于第一个元素是重复的元素且不是最小的。 </p> 
<p>优化：既然是找最小值，那么我们直接既找最小值又找最大值，然后两头交换即可，这样效率就提升了不少。</p> 
<p>代码实现：</p> 
<pre><code class="language-java">    public static void selectSort(int[] array) {
        int left = 0;
        int right = array.length-1;
        while (left &lt; right) {
            int minIndex = left;
            int maxIndex = left;
            for (int i = left+1; i &lt;= right; i++) {
                if (array[minIndex] &gt; array[i]) {
                    minIndex = i;
                }
                if (array[maxIndex] &lt; array[i]) {
                    maxIndex = i;
                }
            }
            // 开始交换
            swap(array, minIndex, left);
            // 如果left位置是最大值，那么第一次交换时，就会把最大值换走，换成最小值
            // 那么我们在第二次交换时，只会把最小值交换走，无法拿到最大值
            if (maxIndex == left) {
                maxIndex = minIndex;
            }
            swap(array, maxIndex, right);
            left++;
            right--;
        }
    }</code></pre> 
<h2 id="%E5%A0%86%E6%8E%92%E5%BA%8F"><span style="color:#fe2c24;">堆排序</span></h2> 
<p>堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。它是通过堆来进行选择数据。需要注意的是：从小到大排序得建大根堆；从大到小排序得建小根堆。想要了解更多的知识，可以去看这篇博客：<a href="https://blog.csdn.net/2301_80854132/article/details/140721685?spm=1001.2014.3001.5502" title="数据结构之探索“堆”的奥秘-CSDN博客">数据结构之探索“堆”的奥秘-CSDN博客</a></p> 
<p>思路：首先，就是要建一个大根堆，然后根据删除的思路来交换数据，再进行向下调整来重新使其变成大根堆。一直重复该步骤，直至遍历完成数组。</p> 
<p>代码实现：</p> 
<pre><code class="language-java">    public static void heapSort(int[] array) {
        // 从小到大排序建大根堆
        createHeap(array);
        // 开始排序
        heap_sort(array);
    }

    private static void createHeap(int[] array) {
        // 向下调整建堆（时间复杂度比较小：O(N)）

        // 从最后一棵子树的位置开始向下调整建堆
        for (int parent = (array.length-1-1)/2 ; parent &gt;= 0; parent--) {
            siftDown(array, parent, array.length);
        }
    }

    private static void siftDown(int[] array, int parent, int end) {
        int child = parent*2+1;
        // 大根堆
        while (child &lt; end) {
            // 先找到左右孩子的最大值
            if (child+1 &lt; end &amp;&amp; array[child] &lt; array[child+1]) {
                child++;
            }
            // 判断孩子节点的值和父亲节点的值满不满足大根堆的要求
            if (array[child] &gt; array[parent]) {
                swap(array, parent, child);
                parent = child;
                child = parent*2+1;
            } else {
                break;
            }
        }
    }

    private static void heap_sort(int[] array) {
        // 模拟删除的思想
        int end = array.length-1;
        int start = 0;
        while (end &gt; 0) {
            swap(array, end, start);
            siftDown(array, start, end);
            end--;
        }
    }</code></pre> 
<p>如果这个代码有疑惑的话，可以去看上面的链接博客，那里有画图更加的清晰明了。</p> 
<p>注意：</p> 
<p>1. 堆排序使用堆来选数，效率就高了很多。</p> 
<p>2. 时间复杂度：O(N*logN)：向下建堆的时间复杂度为O(N) + 排序的时间复杂度为O(N*logN).</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/0f/b4/qzVt4Hvk_o.png" width="1200"></p> 
<p>3. 空间复杂度：O(1)：只申请了常数个空间。</p> 
<p>4. 稳定性：不稳定。 </p> 
<p><img alt="" height="662" src="https://images2.imgbox.com/0a/92/M1otlrli_o.png" width="1200"></p> 
<h2 id="%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%C2%A0"><span style="color:#fe2c24;">冒泡排序 </span></h2> 
<p>冒泡排序是属于交换排序的一种。</p> 
<p>交换排序，基本思想：所谓交换，就是根据序列中两个记录键值的比较结果来对换这两个记录在序列中的位置，交换排序的特点是：将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动（从小到大排序）。 </p> 
<p>其实这里已经告诉我们思路了，而且冒泡排序我们在C语言阶段，JavaSE阶段就进行了学习，因此下面就直接给出代码了。</p> 
<p>代码实现：</p> 
<pre><code class="language-java">    public static void bubbleSort(int[] array) {
        // 冒泡排序的特点和堆排序一样，是后面的数据先有序
        for (int i = 0; i &lt; array.length-1; i++) { // 趟数
            boolean flag = true; // 假设数据已经有序了
            for (int j = 0; j &lt; array.length-1-i; j++) { // 每一趟比较的内容
                if (array[j] &gt; array[j+1]) {
                    swap(array, j, j+1);
                    flag = false; // 交换了，就说明数据还不是有序的
                }
            }
            // 如果没有交换，就说明有序，则不在交换
            if (flag) {
                break;
            }
        }
    }</code></pre> 
<p>注意：</p> 
<p>1. 冒泡排序是一种非常容易理解的排序。</p> 
<p>2. 时间复杂度：O(N^2)：在时间复杂度那篇博客中有详细介绍，有兴趣的小伙伴可以看一看。</p> 
<p><img alt="" height="776" src="https://images2.imgbox.com/95/04/0AJJGaPq_o.png" width="1200"></p> 
<p>3. 空间复杂度：O(1)：只申请了常数个空间。</p> 
<p>4. 稳定性：稳定。和直接插入排序一样，既可以实现为不稳定的，也可以实现为稳定的，因此冒泡排序是一个稳定的排序。</p> 
<p>好啦！本期 数据结构之八大排序（上）的学习之旅就到此结束啦！我们下一期再一起学习吧！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5bbb0ae1e600d72377b57b7684083dcb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">《从零开始做个摸鱼小网站! · 序》灵感来源</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/95e618736bbfd1de0cc3a60ed2fbff6d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Vue中输入框仅支持数字输入</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>