<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>（超详细）数据结构——“队列”的深度解析 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/ada618c82c11640ab42b3b3a9fe4b490/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="（超详细）数据结构——“队列”的深度解析">
  <meta property="og:description" content="目录
前言：
1.队列的概念 2.队列的实现 3.代码实现队列 3.1 队列的初始化 3.2 插入 3.3 删除 3.4 队列的队头，队尾和大小
3.5 判空 3.6 销毁 3.7 测试 前言： 队列与栈都是线性表，它们的结构也非常类似，都是一头进一头出，那么它们有什么区别吗？答案是有的，虽然它们同为线性表，但是栈的出栈入栈方式为后进先出，而队列的出栈入栈方式为先进先出，具体我们在正文讲解。
1.队列的概念 队列：只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，队列具有先进先出 FIFO(First In First Out) 入队列：进行插入操作的一端称为 队尾 出队列：进行删除操作的一端称为 队头。 2.队列的实现 队列与栈的结构类似，所以它和栈一样，使用链表和顺序表都可以实现队列，但是由于队列遵循先进先出的顺序，如果使用顺序表进行头删实现出队列的话，整个队列的数据需要频繁向前移动，代码效率相对较低，而使用链表的头删实现出队列的话，只需要将头节点删除即可，所以综上所述，我们将使用链表来实现队列。
3.代码实现队列 为了方便管理，我们还是将队列分为三个文件实现，分别是Queue.h （queue中译是队列的意思），Queue.c和test.c，由于我们选择使用链表实现队列，所以我们要先使用结构体实现一个单链表的节点，这个节点包含数据和下一个节点的地址，存储数据变量的类型由我们将来要存储的数据决定，所以我们使用typedef队对数据类型进行改名，在这里我们将int作为测试类型，所以我们要对int重命名：
typedef int QDataType; typedef struct QueueNode { QDataType val; struct QueueNode* next; }QNode; 基于队列先进先出的原则，我们需要得到队列的头和尾，必要时还需要知道队列的大小，所以我们额外创建一个结构体来存储队列的首地址，尾地址和队列的大小：
typedef struct Queue { QNode* Qtail; QNode* Qhead; int size; }Queue; 3.1 队列的初始化 我们现在有两个结构体，我们该如何初始化呢？是对两个结构体都初始化，还是对其中某一个初始化呢。答案是对存储有队列首地址和尾地址的结构体初始化，因为代表链表节点的QNode结构体的初始化是在我们在堆上开辟新的空间时初始化，所以我们这个时候的初始化是对Queue初始化：
void QInit(Queue* pq) { assert(pq); pq-&gt;Qhead = pq-&gt;Qtail = NULL; pq-&gt;size = 0; }//初始化 3.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-02T01:20:15+08:00">
    <meta property="article:modified_time" content="2024-07-02T01:20:15+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">（超详细）数据结构——“队列”的深度解析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h6 id="%C2%A0"> </h6> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%C2%A0-toc" style="margin-left:200px;"><a href="#%C2%A0" rel="nofollow"> </a></p> 
<p id="%E5%89%8D%E8%A8%80%EF%BC%9A-toc" style="margin-left:200px;"><a href="#%E5%89%8D%E8%A8%80%EF%BC%9A" rel="nofollow">前言：</a></p> 
<p id="1.%E9%98%9F%E5%88%97%E7%9A%84%E6%A6%82%E5%BF%B5%C2%A0%20%C2%A0-toc" style="margin-left:0px;"><a href="#1.%E9%98%9F%E5%88%97%E7%9A%84%E6%A6%82%E5%BF%B5%C2%A0%20%C2%A0" rel="nofollow">1.队列的概念   </a></p> 
<p id="2.%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%C2%A0-toc" style="margin-left:0px;"><a href="#2.%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%C2%A0" rel="nofollow">2.队列的实现 </a></p> 
<p id="3.%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%C2%A0-toc" style="margin-left:0px;"><a href="#3.%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%C2%A0" rel="nofollow">3.代码实现队列 </a></p> 
<p id="3.1%20%E9%98%9F%E5%88%97%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%C2%A0-toc" style="margin-left:40px;"><a href="#3.1%20%E9%98%9F%E5%88%97%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%C2%A0" rel="nofollow">3.1 队列的初始化 </a></p> 
<p id="3.2%20%E6%8F%92%E5%85%A5%C2%A0-toc" style="margin-left:40px;"><a href="#3.2%20%E6%8F%92%E5%85%A5%C2%A0" rel="nofollow">3.2 插入 </a></p> 
<p id="3.3%20%E5%88%A0%E9%99%A4%C2%A0-toc" style="margin-left:40px;"><a href="#3.3%20%E5%88%A0%E9%99%A4%C2%A0" rel="nofollow">3.3 删除 </a></p> 
<p id="3.4%20%E9%98%9F%E5%88%97%E7%9A%84%E9%98%9F%E5%A4%B4%EF%BC%8C%E9%98%9F%E5%B0%BE%E5%92%8C%E5%A4%A7%E5%B0%8F-toc" style="margin-left:40px;"><a href="#3.4%20%E9%98%9F%E5%88%97%E7%9A%84%E9%98%9F%E5%A4%B4%EF%BC%8C%E9%98%9F%E5%B0%BE%E5%92%8C%E5%A4%A7%E5%B0%8F" rel="nofollow">3.4 队列的队头，队尾和大小</a></p> 
<p id="3.5%20%E5%88%A4%E7%A9%BA%C2%A0-toc" style="margin-left:40px;"><a href="#3.5%20%E5%88%A4%E7%A9%BA%C2%A0" rel="nofollow">3.5 判空 </a></p> 
<p id="3.6%20%E9%94%80%E6%AF%81%C2%A0-toc" style="margin-left:40px;"><a href="#3.6%20%E9%94%80%E6%AF%81%C2%A0" rel="nofollow">3.6 销毁 </a></p> 
<p id="3.7%20%E6%B5%8B%E8%AF%95%C2%A0-toc" style="margin-left:40px;"><a href="#3.7%20%E6%B5%8B%E8%AF%95%C2%A0" rel="nofollow">3.7 测试 </a></p> 
<p id="%C2%A0-toc" style="margin-left:40px;"><a href="#%C2%A0" rel="nofollow"> </a></p> 
<hr id="hr-toc"> 
<p></p> 
<h6 id="%E5%89%8D%E8%A8%80%EF%BC%9A">前言：</h6> 
<p>    队列与栈都是线性表，它们的结构也非常类似，都是一头进一头出，那么它们有什么区别吗？答案是有的，虽然它们同为线性表，但是栈的出栈入栈方式为后进先出，而队列的出栈入栈方式为先进先出，具体我们在正文讲解。</p> 
<h2 id="1.%E9%98%9F%E5%88%97%E7%9A%84%E6%A6%82%E5%BF%B5%C2%A0%20%C2%A0">1.队列的概念   </h2> 
<div> 
 <span style="color:#777777;">队列：只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，队列具有先进先出 FIFO(First In First Out) 入队列：进行插入操作的一端称为</span> 
 <span style="color:#777777;"><strong>队尾</strong></span> 
 <span style="color:#777777;">出队列：进行删除操作的一端称为</span> 
 <span style="color:#777777;"><strong>队头。</strong></span> 
</div> 
<div> 
 <img alt="" height="472" src="https://images2.imgbox.com/5c/d6/kzbG0dT5_o.png" width="1194"> 
</div> 
<p></p> 
<h2 id="2.%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%C2%A0">2.队列的实现 </h2> 
<p>    队列与栈的结构类似，所以它和栈一样，使用链表和顺序表都可以实现队列，但是由于队列遵循先进先出的顺序，如果使用顺序表进行头删实现出队列的话，整个队列的数据需要频繁向前移动，代码效率相对较低，而使用链表的头删实现出队列的话，只需要将头节点删除即可，所以综上所述，我们将使用链表来实现队列。</p> 
<p><img alt="" height="446" src="https://images2.imgbox.com/4b/bd/7X3YYymO_o.png" width="1200"></p> 
<h2 id="3.%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%C2%A0">3.代码实现队列 </h2> 
<p>    为了方便管理，我们还是将队列分为三个文件实现，分别是Queue.h （queue中译是队列的意思），Queue.c和test.c，由于我们选择使用链表实现队列，所以我们要先使用结构体实现一个单链表的节点，这个节点包含数据和下一个节点的地址，存储数据变量的类型由我们将来要存储的数据决定，所以我们使用typedef队对数据类型进行改名，在这里我们将int作为测试类型，所以我们要对int重命名：</p> 
<pre><code class="hljs">typedef int QDataType;
typedef struct QueueNode
{
	QDataType val;
	struct QueueNode* next;


}QNode;</code></pre> 
<p>   基于队列先进先出的原则，我们需要得到队列的头和尾，必要时还需要知道队列的大小，所以我们额外创建一个结构体来存储队列的首地址，尾地址和队列的大小：</p> 
<pre><code class="hljs">typedef struct Queue
{
	QNode* Qtail;
	QNode* Qhead;
	int size;

}Queue;</code></pre> 
<h3 id="3.1%20%E9%98%9F%E5%88%97%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%C2%A0">3.1 队列的初始化 </h3> 
<p>   我们现在有两个结构体，我们该如何初始化呢？是对两个结构体都初始化，还是对其中某一个初始化呢。答案是对存储有队列首地址和尾地址的结构体初始化，因为代表链表节点的QNode结构体的初始化是在我们在堆上开辟新的空间时初始化，所以我们这个时候的初始化是对Queue初始化：</p> 
<pre><code class="hljs">void QInit(Queue* pq)
{
	assert(pq);
	pq-&gt;Qhead = pq-&gt;Qtail = NULL;
	pq-&gt;size = 0;

}//初始化
</code></pre> 
<h3 id="3.2%20%E6%8F%92%E5%85%A5%C2%A0">3.2 插入 </h3> 
<p>    我们这里的队列使用的是单链表，所以插入要使用尾插，删除使用头插，单链表的这两个操作完美的符合队列的先进先出的特性。在插入数据前，我们要先开辟一个新节点，如果这个节点有效，我们就对它初始化，让它的next指针指向空，将x赋给val。将新节点初始化完了之后，我们就要考虑插入的问题了，如果队列里没有任何成员，我们要插入的新节点就要同时赋给头指针和尾指针，如果队列里有成员，我们插入的新节点就只需要给尾指针的next指针，执行完插入操作后让size加1：</p> 
<pre><code class="hljs">void QueuePush(Queue* pq, QDataType x)
{
	assert(pq);
	QNode* newnode = (QNode*)malloc(sizeof(QNode));
	if (newnode == NULL)
	{
		perror("malloc fail");
		return;
	}
	newnode-&gt;next = NULL;
	newnode-&gt;val = x;

	if (pq-&gt;Qhead == NULL)
	{
		pq-&gt;Qhead = pq-&gt;Qtail = newnode;
	}
	else
	{
		pq-&gt;Qtail-&gt;next = newnode;
		pq-&gt;Qtail = newnode;
	}
	pq-&gt;size++;
}//插入</code></pre> 
<h3 id="3.3%20%E5%88%A0%E9%99%A4%C2%A0">3.3 删除 </h3> 
<p>    删除操作我们在前面讲过要使用头删，我们需要考虑队列是否为空，如果队列为空，则让程序无法执行删除操作，我们选择使用断言来限制队列为空使用删除的情况，与插入相同，我们需要考虑两种情况，如果队列中只有只有一个成员，那么这个成员同时被头指针和尾指针指着，如果我们要删除这个节点，那么我们要将头指针和尾指针同时置空，这样做是为了防止出现空指针的现象。第二种则是正常情况，我们用一个指针存储头指针的下一个节点的地址，将头指针指向的那块空间释放后（删除节点），再让头指针指向我们之前存储的地址，这样删除操作就算完成了：</p> 
<pre><code class="hljs">void QueuePop(Queue* pq)
{
	assert(pq);
	assert(pq-&gt;Qhead);

	if (pq-&gt;Qhead-&gt;next == NULL)
	{
		free(pq-&gt;Qhead);
		pq-&gt;Qhead = pq-&gt;Qtail = NULL;
	}
	else
	{
		QNode* next = pq-&gt;Qhead-&gt;next;
		free(pq-&gt;Qhead);
		pq-&gt;Qhead = next;
	}
	pq-&gt;size--;
}//删除</code></pre> 
<h3 id="3.4%20%E9%98%9F%E5%88%97%E7%9A%84%E9%98%9F%E5%A4%B4%EF%BC%8C%E9%98%9F%E5%B0%BE%E5%92%8C%E5%A4%A7%E5%B0%8F">3.4 队列的队头，队尾和大小</h3> 
<p>  队列的队头和队尾只需要将头指针和尾指针指向成员的值返回就可以了，而队列的大小也比较简单，只需要返回size就可以了：</p> 
<p>队头：</p> 
<pre><code class="hljs">DataType QueueFront(Queue* pq)
{
	assert(pq);
	return pq-&gt;Qhead-&gt;val;
}</code></pre> 
<p>队尾：</p> 
<pre><code class="hljs">QDataType QueueBack(Queue* pq)
{
	assert(pq);
	return pq-&gt;Qtail-&gt;val;
}</code></pre> 
<p>队列大小：</p> 
<pre><code class="hljs">int Queuesize(Queue* pq)
{
	assert(pq);
	assert(pq-&gt;size &gt;= 0);
	return pq-&gt;size;
}//大小</code></pre> 
<h3 id="3.5%20%E5%88%A4%E7%A9%BA%C2%A0">3.5 判空 </h3> 
<p>  我们有时会频繁对队列进行删除插入操作，这时我们可以使用这个方法来决定是否删除，如果队列为空，则不进行删除操作：</p> 
<pre><code class="hljs">bool QEmpty(Queue* pq)
{
	assert(pq);
	assert(pq-&gt;size &gt;= 0);
	return pq-&gt;size == 0;
}//判空
</code></pre> 
<h3 id="3.6%20%E9%94%80%E6%AF%81%C2%A0">3.6 销毁 </h3> 
<p>  我们链表的节点都是从堆上开辟的，所以要手动将这些空间释放：</p> 
<pre><code class="hljs">void QDestroy(Queue* pq)
{
	assert(pq);
	Queue* cur = pq-&gt;Qhead;

	while (cur)
	{
		QNode* next = cur-&gt;Qhead-&gt;next;
		free(cur-&gt;Qhead);
		cur-&gt;Qhead = next;
	}
	pq-&gt;Qhead = pq-&gt;Qtail = NULL;
	pq-&gt;size = 0;
}</code></pre> 
<h3 id="3.7%20%E6%B5%8B%E8%AF%95%C2%A0">3.7 测试 </h3> 
<p>  到这里队列所有的方法都已经实现了，实现完之后不要忘记测试一下代码的有效性，我们来测试一下我们实现的方法：</p> 
<p><img alt="" height="530" src="https://images2.imgbox.com/89/d8/hTLdr0De_o.png" width="1200"></p> 
<p>我们插入了四个数字，然后使用判空，队头和删除方法来打印队列，可以看到都是没有问题的，讲到这里，队列就到此结束了，代码放在下面，感兴趣的小伙伴可以试试哦。</p> 
<p>Queue.h :</p> 
<pre><code class="hljs">#pragma once
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdbool.h&gt;

typedef int QDataType;
typedef struct QueueNode
{
	QDataType val;
	struct QueueNode* next;


}QNode;

typedef struct Queue
{
	QNode* Qtail;
	QNode* Qhead;
	int size;

}Queue;

void QInit(Queue* pq);//初始化

void QueuePush(Queue* pq, QDataType x);//插入

void QueuePop(Queue* pq);//删除

int Queuesize(Queue* pq);//大小

//头尾数据
QDataType QueueFront(Queue* pq);
QDataType QueueBack(Queue* pq);
//判空
bool QEmpty(Queue* pq);

void QDestroy(Queue* pq);//销毁


</code></pre> 
<p>Queue.c :</p> 
<pre><code class="hljs">#define _CRT_SECURE_NO_WARNINGS 1
#include"Queue.h"

void QInit(Queue* pq)
{
	assert(pq);
	pq-&gt;Qhead = pq-&gt;Qtail = NULL;
	pq-&gt;size = 0;

}//初始化

void QueuePush(Queue* pq, QDataType x)
{
	assert(pq);
	QNode* newnode = (QNode*)malloc(sizeof(QNode));
	if (newnode == NULL)
	{
		perror("malloc fail");
		return;
	}
	newnode-&gt;next = NULL;
	newnode-&gt;val = x;

	if (pq-&gt;Qhead == NULL)
	{
		pq-&gt;Qhead = pq-&gt;Qtail = newnode;
	}
	else
	{
		pq-&gt;Qtail-&gt;next = newnode;
		pq-&gt;Qtail = newnode;
	}
	pq-&gt;size++;
}//插入

void QueuePop(Queue* pq)
{
	assert(pq);
	assert(pq-&gt;Qhead);

	if (pq-&gt;Qhead-&gt;next == NULL)
	{
		free(pq-&gt;Qhead);
		pq-&gt;Qhead = pq-&gt;Qtail = NULL;
	}
	else
	{
		QNode* next = pq-&gt;Qhead-&gt;next;
		free(pq-&gt;Qhead);
		pq-&gt;Qhead = next;
	}
	pq-&gt;size--;
}//删除

int Queuesize(Queue* pq)
{
	assert(pq);
	assert(pq-&gt;size &gt;= 0);
	return pq-&gt;size;
}//大小

//头、尾数据
QDataType QueueFront(Queue* pq)
{
	assert(pq);
	return pq-&gt;Qhead-&gt;val;
}
QDataType QueueBack(Queue* pq)
{
	assert(pq);
	return pq-&gt;Qtail-&gt;val;
}

bool QEmpty(Queue* pq)
{
	assert(pq);
	assert(pq-&gt;size &gt;= 0);
	return pq-&gt;size == 0;
}//判空

void QDestroy(Queue* pq)
{
	assert(pq);
	Queue* cur = pq-&gt;Qhead;

	while (cur)
	{
		QNode* next = cur-&gt;Qhead-&gt;next;
		free(cur-&gt;Qhead);
		cur-&gt;Qhead = next;
	}
	pq-&gt;Qhead = pq-&gt;Qtail = NULL;
	pq-&gt;size = 0;
}</code></pre> 
<p>test.c :</p> 
<pre><code class="hljs">#define _CRT_SECURE_NO_WARNINGS 1
#include"Queue.h"
void test()
{
	Queue q;
	QInit(&amp;q);
	QueuePush(&amp;q, 1);
	QueuePush(&amp;q, 2);
	QueuePush(&amp;q, 3);
	QueuePush(&amp;q, 4);


	while (!QEmpty(&amp;q))
	{
		printf("%d ", QueueFront(&amp;q));
		QueuePop(&amp;q);
	}
	printf("\n");

	QDestroy(&amp;q);

}
int main()
{
	test();
	return 0;
}</code></pre> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p></p> 
<h3> </h3> 
<p> </p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5d924bd757ac75a7bf4c5ba3dba13f28/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【AI 大模型】提示工程 ③ ( 提示词用法 | 提示词 Prompt 构成 | 提示词位置对权重的影响 | 提示词 Prompt 调优 | OpenAI 的 API 类型 | 提示词重要参数说明 )</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1a482b8e492d6fdead17029d3ff491cd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">摸鱼大数据——Spark基础——Spark On Yarn环境配置和部署</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>