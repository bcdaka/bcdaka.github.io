<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【网络原理】使用Java基于TCP搭建简单客户端与服务器通信 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/592cf208c525495ba4a31c743369c9e5/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【网络原理】使用Java基于TCP搭建简单客户端与服务器通信">
  <meta property="og:description" content="目录 🎄API介绍🌸ServerSocket API🌸Socket API 🍀TCP中的长短连接🌳建立TCP回显客户端与服务器🌸TCP搭建服务器🌸TCP搭建客户端 ⭕总结 TCP服务器与客户端的搭建需要借助以下API 🎄API介绍 🌸ServerSocket API ServerSocket 是创建TCP服务端Socket的API。
ServerSocket 构造方法：
方法签名方法说明ServerSocket(int port)创建一个服务端流套接字Socket，并绑定到指定端口 ServerSocket 方法：
方法签名方法说明Socket accept()开始监听指定端口（创建时绑定的端口），有客户端连接后，返回一个服务端Socket对象，并基于该Socket建立与客户端的连接，否则阻塞等待void close()关闭此套接字 🌸Socket API Socket 是客户端Socket，或服务端中接收到客户端建立连接（accept方法）的请求后，返回的服务端Socket。
不管是客户端还是服务端Socket，都是双方建立连接以后，保存的对端信息，及用来与对方收发数据的。
Socket 构造方法：
方法签名方法说明Socket(String host, intport)创建一个客户端流套接字Socket，并与对应IP的主机上，对应端口的进程建立连接 Socket 方法：
方法签名方法说明InetAddress getInetAddress()返回套接字所连接的地址InputStream getInputStream()返回此套接字的输入流OutputStream getOutputStream()返回此套接字的输出流 🍀TCP中的长短连接 博主在前面的博文里面说到，TCP是面向连接的通信方式，TCP发送数据时，需要先建立连接，而这个连接又分为长短连接：
短连接：每次接收到数据并返回响应后，都关闭连接，即是短连接。也就是说，短连接只能一次收发数据。
长连接：不关闭连接，一直保持连接状态，双方不停的收发数据，即是长连接。也就是说，长连接可以多次收发数据
对比以上长短连接，两者区别如下：
建立连接、关闭连接的耗时：短连接每次请求、响应都需要建立连接，关闭连接；而长连接只需要第一次建立连接，之后的请求、响应都可以直接传输。相对来说建立连接，关闭连接也是要耗时的，长连接效率更高。
主动发送请求不同：短连接一般是客户端主动向服务端发送请求；而长连接可以是客户端主动发送请求，也可以是服务端主动发。
两者的使用场景有不同：短连接适用于客户端请求频率不高的场景，如浏览网页等。长连接适用于客户端与服务端通信频繁的场景，如聊天室，实时游戏等
拓展：
基于BIO（同步阻塞IO）的长连接会一直占用系统资源。对于并发要求很高的服务端系统来说，这样的消耗是不能承受的。
由于每个连接都需要不停的阻塞等待接收数据，所以每个连接都会在一个线程中运行。一次阻塞等待对应着一次请求、响应，不停处理也就是长连接的特性：一直不关闭连接，不停的处理请求
实际应用时，服务端一般是基于NIO（即同步非阻塞IO）来实现长连接，性能可以极大的提升。
🌳建立TCP回显客户端与服务器 🌸TCP搭建服务器 我们分为以下几步来实现：
创建TcpEchoServer类来表示我们的服务器，并创建ServerSocket对象，初始值为null在TcpEchoServer的构造方法里进行ServerSocket对象的实例化用一个start()方法表示启动程序在该方法内我们首先要使用accept()进行连接，并用Socket对象进行接收我们再用一个processConnection(Socket clientSocket)方法处理我们的连接 由于我们的TCP传输是以流的形式传播的，所以我们这里用到了读写数据流的方法来进行书写，不会这一部分的小伙伴，可以去看看博主所写【Java EE】文件内容的读写⸺数据流进行查看学习
接下来我们书写这个processConnection(Socket clientSocket)方法
读取请求，构造输入流的Scanner，并判断后面如果没有数据就关闭连接然后我们将读取的数据交给我们的 response()构造响应响应后的数据写入该套接字的输出流中，最后flush()，进行刷新，确保写入 为了释放资源，我们每一次交互完毕都需要对我们的套接字进行关闭，这里我们使用fially来进行处理
代码如下：
import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-10T10:41:54+08:00">
    <meta property="article:modified_time" content="2024-03-10T10:41:54+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【网络原理】使用Java基于TCP搭建简单客户端与服务器通信</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#API_2" rel="nofollow">🎄API介绍</a></li><li><ul><li><a href="#ServerSocket_API_3" rel="nofollow">🌸ServerSocket API</a></li><li><a href="#Socket_API_17" rel="nofollow">🌸Socket API</a></li></ul> 
  </li><li><a href="#TCP_34" rel="nofollow">🍀TCP中的长短连接</a></li><li><a href="#TCP_59" rel="nofollow">🌳建立TCP回显客户端与服务器</a></li><li><ul><li><a href="#TCP_61" rel="nofollow">🌸TCP搭建服务器</a></li><li><a href="#TCP_164" rel="nofollow">🌸TCP搭建客户端</a></li></ul> 
  </li><li><a href="#_237" rel="nofollow">⭕总结</a></li></ul> 
</div> 
<br> TCP服务器与客户端的搭建需要借助以下API 
<p></p> 
<h2><a id="API_2"></a>🎄API介绍</h2> 
<h3><a id="ServerSocket_API_3"></a>🌸ServerSocket API</h3> 
<p>ServerSocket 是创建TCP服务端Socket的API。</p> 
<p><mark>ServerSocket 构造方法</mark>：</p> 
<table><thead><tr><th>方法签名</th><th>方法说明</th></tr></thead><tbody><tr><td>ServerSocket(int port)</td><td>创建一个服务端流套接字Socket，并绑定到指定端口</td></tr></tbody></table> 
<p><mark>ServerSocket 方法：</mark></p> 
<table><thead><tr><th>方法签名</th><th>方法说明</th></tr></thead><tbody><tr><td>Socket accept()</td><td>开始监听指定端口（创建时绑定的端口），有客户端连接后，返回一个服务端Socket对象，并基于该Socket建立与客户端的连接，否则阻塞等待</td></tr><tr><td>void close()</td><td>关闭此套接字</td></tr></tbody></table> 
<h3><a id="Socket_API_17"></a>🌸Socket API</h3> 
<p>Socket 是客户端Socket，或服务端中接收到客户端建立连接（accept方法）的请求后，返回的服务端Socket。</p> 
<p>不管是客户端还是服务端Socket，都是双方建立连接以后，保存的对端信息，及用来与对方收发数据的。</p> 
<p><mark>Socket 构造方法：</mark></p> 
<table><thead><tr><th>方法签名</th><th>方法说明</th></tr></thead><tbody><tr><td>Socket(String host, intport)</td><td>创建一个客户端流套接字Socket，并与对应IP的主机上，对应端口的进程建立连接</td></tr></tbody></table> 
<p><mark>Socket 方法：</mark></p> 
<table><thead><tr><th>方法签名</th><th>方法说明</th></tr></thead><tbody><tr><td>InetAddress getInetAddress()</td><td>返回套接字所连接的地址</td></tr><tr><td>InputStream getInputStream()</td><td>返回此套接字的输入流</td></tr><tr><td>OutputStream getOutputStream()</td><td>返回此套接字的输出流</td></tr></tbody></table> 
<h2><a id="TCP_34"></a>🍀TCP中的长短连接</h2> 
<p>博主在前面的博文里面说到，TCP是面向连接的通信方式，TCP发送数据时，需要先建立连接，而这个连接又分为长短连接：</p> 
<ul><li> <p>短连接：每次接收到数据并返回响应后，都关闭连接，即是短连接。也就是说，短连接只能一次收发数据。</p> </li><li> <p>长连接：不关闭连接，一直保持连接状态，双方不停的收发数据，即是长连接。也就是说，长连接可以多次收发数据</p> </li></ul> 
<p>对比以上长短连接，两者区别如下：</p> 
<ul><li> <p>建立连接、关闭连接的耗时：短连接每次请求、响应都需要建立连接，关闭连接；而长连接只需要第一次建立连接，之后的请求、响应都可以直接传输。相对来说建立连接，关闭连接也是要耗时的，长连接效率更高。</p> </li><li> <p>主动发送请求不同：短连接一般是客户端主动向服务端发送请求；而长连接可以是客户端主动发送请求，也可以是服务端主动发。</p> </li><li> <p>两者的使用场景有不同：短连接适用于客户端请求频率不高的场景，如浏览网页等。长连接适用于客户端与服务端通信频繁的场景，如聊天室，实时游戏等</p> </li></ul> 
<p><mark>拓展：</mark></p> 
<ul><li> <p>基于BIO（同步阻塞IO）的长连接会一直占用系统资源。对于并发要求很高的服务端系统来说，这样的消耗是不能承受的。</p> </li><li> <p>由于每个连接都需要不停的阻塞等待接收数据，所以每个连接都会在一个线程中运行。一次阻塞等待对应着一次请求、响应，不停处理也就是长连接的特性：一直不关闭连接，不停的处理请求</p> </li><li> <p>实际应用时，服务端一般是基于NIO（即同步非阻塞IO）来实现长连接，性能可以极大的提升。</p> </li></ul> 
<h2><a id="TCP_59"></a>🌳建立TCP回显客户端与服务器</h2> 
<h3><a id="TCP_61"></a>🌸TCP搭建服务器</h3> 
<p>我们分为以下几步来实现：</p> 
<ol><li>创建TcpEchoServer类来表示我们的服务器，并创建ServerSocket对象，初始值为null</li><li>在TcpEchoServer的构造方法里进行ServerSocket对象的实例化</li><li>用一个start()方法表示启动程序</li><li>在该方法内我们首先要使用accept()进行连接，并用Socket对象进行接收</li><li>我们再用一个processConnection(Socket clientSocket)方法处理我们的连接</li></ol> 
<p>由于我们的TCP传输是以流的形式传播的，所以我们这里用到了读写数据流的方法来进行书写，不会这一部分的小伙伴，可以去看看博主所写<a href="https://blog.csdn.net/m0_65941010/article/details/136499560?spm=1001.2014.3001.5501">【Java EE】文件内容的读写⸺数据流</a>进行查看学习</p> 
<p>接下来我们书写这个processConnection(Socket clientSocket)方法</p> 
<ol><li>读取请求，构造输入流的Scanner，并判断后面如果没有数据就关闭连接</li><li>然后我们将读取的数据交给我们的 response()构造响应</li><li>响应后的数据写入该套接字的输出流中，最后flush()，进行刷新，确保写入</li></ol> 
<p>为了释放资源，我们每一次交互完毕都需要对我们的套接字进行关闭，这里我们使用fially来进行处理</p> 
<p>代码如下：</p> 
<pre><code class="prism language-bash"><span class="token function">import</span> java.io.IOException<span class="token punctuation">;</span>
<span class="token function">import</span> java.io.InputStream<span class="token punctuation">;</span>
<span class="token function">import</span> java.io.OutputStream<span class="token punctuation">;</span>
<span class="token function">import</span> java.io.PrintWriter<span class="token punctuation">;</span>
<span class="token function">import</span> java.net.ServerSocket<span class="token punctuation">;</span>
<span class="token function">import</span> java.net.Socket<span class="token punctuation">;</span>
<span class="token function">import</span> java.util.Scanner<span class="token punctuation">;</span>

public class TcpEchoServer <span class="token punctuation">{<!-- --></span>
    private ServerSocket serverSocket <span class="token operator">=</span> null<span class="token punctuation">;</span>

    public TcpEchoServer<span class="token punctuation">(</span>int port<span class="token punctuation">)</span> throws IOException <span class="token punctuation">{<!-- --></span>
        serverSocket <span class="token operator">=</span> new ServerSocket<span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    public void start<span class="token punctuation">(</span><span class="token punctuation">)</span> throws IOException <span class="token punctuation">{<!-- --></span>
        System.out.println<span class="token punctuation">(</span><span class="token string">"启动服务器"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Socket socket <span class="token operator">=</span> serverSocket.accept<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        processConnection<span class="token punctuation">(</span>socket<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    // 使用这个方法来处理一个连接.
    // 这一个连接对应到一个客户端. 但是这里可能会涉及到多次交互.
    private void processConnection<span class="token punctuation">(</span>Socket clientSocket<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        System.out.printf<span class="token punctuation">(</span><span class="token string">"[%s:%d] 客户端上线!<span class="token entity" title="\n">\n</span>"</span>, clientSocket.getInetAddress<span class="token punctuation">(</span><span class="token punctuation">)</span>.toString<span class="token punctuation">(</span><span class="token punctuation">)</span>, clientSocket.getPort<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
        // 基于上述 socket 对象和客户端进行通信
        try <span class="token punctuation">(</span>InputStream inputStream <span class="token operator">=</span> clientSocket.getInputStream<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             OutputStream outputStream <span class="token operator">=</span> clientSocket.getOutputStream<span class="token punctuation">(</span><span class="token punctuation">))</span> <span class="token punctuation">{<!-- --></span>
            // 由于要处理多个请求和响应, 也是使用循环来进行.
            <span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                // <span class="token number">1</span>. 读取请求
                Scanner scanner <span class="token operator">=</span> new Scanner<span class="token punctuation">(</span>inputStream<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>scanner.hasNext<span class="token punctuation">(</span><span class="token punctuation">))</span> <span class="token punctuation">{<!-- --></span>
                    // 没有下个数据, 说明读完了. <span class="token punctuation">(</span>客户端关闭了连接<span class="token punctuation">)</span>
                    System.out.printf<span class="token punctuation">(</span><span class="token string">"[%s:%d] 客户端下线! <span class="token entity" title="\n">\n</span>"</span>, clientSocket.getInetAddress<span class="token punctuation">(</span><span class="token punctuation">)</span>.toString<span class="token punctuation">(</span><span class="token punctuation">)</span>, clientSocket.getPort<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
                    <span class="token builtin class-name">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                // 注意<span class="token operator">!</span><span class="token operator">!</span> 此处使用 next 是一直读取到换行符/空格/其他空白符结束, 但是最终返回结果里不包含上述 空白符 <span class="token builtin class-name">.</span>
                String request <span class="token operator">=</span> scanner.next<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                // <span class="token number">2</span>. 根据请求构造响应
                String response <span class="token operator">=</span> process<span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>
                // <span class="token number">3</span>. 返回响应结果.
                //    OutputStream 没有 <span class="token function">write</span> String 这样的功能. 可以把 String 里的字节数组拿出来, 进行写入<span class="token punctuation">;</span>
                //    也可以用字符流来转换一下.
                PrintWriter printWriter <span class="token operator">=</span> new PrintWriter<span class="token punctuation">(</span>outputStream<span class="token punctuation">)</span><span class="token punctuation">;</span>
                // 此处使用 println 来写入. 让结果中带有一个 <span class="token punctuation">\</span>n 换行. 方便对端来接收解析.
                printWriter.println<span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>
                // flush 用来刷新缓冲区, 保证当前写入的数据, 确实是发送出去了.
                printWriter.flush<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                System.out.printf<span class="token punctuation">(</span><span class="token string">"[%s:%d] req: %s; resp: %s <span class="token entity" title="\n">\n</span>"</span>, clientSocket.getInetAddress<span class="token punctuation">(</span><span class="token punctuation">)</span>.toString<span class="token punctuation">(</span><span class="token punctuation">)</span>, clientSocket.getPort<span class="token punctuation">(</span><span class="token punctuation">)</span>,
                        request, response<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> catch <span class="token punctuation">(</span>IOException e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            e.printStackTrace<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> finally <span class="token punctuation">{<!-- --></span>
            // 更合适的做法, 是把 close 放到 finally 里面, 保证一定能够执行到<span class="token operator">!</span><span class="token operator">!</span>
            try <span class="token punctuation">{<!-- --></span>
            	clientSocket.close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                clientSocket.close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> catch <span class="token punctuation">(</span>IOException e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                e.printStackTrace<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    public String process<span class="token punctuation">(</span>String request<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token builtin class-name">return</span> request<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    public static void main<span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> throws IOException <span class="token punctuation">{<!-- --></span>
        TcpEchoServer server <span class="token operator">=</span> new TcpEchoServer<span class="token punctuation">(</span><span class="token number">9090</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        server.start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<h3><a id="TCP_164"></a>🌸TCP搭建客户端</h3> 
<p>搭建客户端我们也可以分为以下几步：</p> 
<ol><li>创建TcpEchoClient类表示我们的客户端，创建Soket对象用于与客户端通信·</li><li>再TcpEchoClient构造方法里进行实例化Socket的对象</li><li>创建start()方法用于我们的操作</li><li>读取键盘所要输入的数据</li><li>将所读的数据通过输出流进行写入</li><li>读取响应的输入流，进行打印</li><li>main函数中进行启动</li></ol> 
<pre><code class="prism language-bash"><span class="token function">import</span> java.io.IOException<span class="token punctuation">;</span>
<span class="token function">import</span> java.io.InputStream<span class="token punctuation">;</span>
<span class="token function">import</span> java.io.OutputStream<span class="token punctuation">;</span>
<span class="token function">import</span> java.io.PrintWriter<span class="token punctuation">;</span>
<span class="token function">import</span> java.net.Socket<span class="token punctuation">;</span>
<span class="token function">import</span> java.util.Scanner<span class="token punctuation">;</span>

public class TcpEchoClient <span class="token punctuation">{<!-- --></span>
    private Socket socket <span class="token operator">=</span> null<span class="token punctuation">;</span>

    public TcpEchoClient<span class="token punctuation">(</span>String serverIp, int serverPort<span class="token punctuation">)</span> throws IOException <span class="token punctuation">{<!-- --></span>
        // Socket 构造方法, 能够识别 点分十进制格式的 IP 地址. 比 DatagramPacket 更方便.
        // new 这个对象的同时, 就会进行 TCP 连接操作.
        socket <span class="token operator">=</span> new Socket<span class="token punctuation">(</span>serverIp, serverPort<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    public void <span class="token function-name function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        System.out.println<span class="token punctuation">(</span><span class="token string">"客户端启动!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Scanner scanner <span class="token operator">=</span> new Scanner<span class="token punctuation">(</span>System.in<span class="token punctuation">)</span><span class="token punctuation">;</span>
        try <span class="token punctuation">(</span>InputStream inputStream <span class="token operator">=</span> socket.getInputStream<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             OutputStream outputStream <span class="token operator">=</span> socket.getOutputStream<span class="token punctuation">(</span><span class="token punctuation">))</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                // <span class="token number">1</span>. 先从键盘上读取用户输入的内容
                System.out.print<span class="token punctuation">(</span><span class="token string">"&gt; "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                String request <span class="token operator">=</span> scanner.next<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>request.equals<span class="token punctuation">(</span><span class="token string">"exit"</span><span class="token punctuation">))</span> <span class="token punctuation">{<!-- --></span>
                    System.out.println<span class="token punctuation">(</span><span class="token string">"goodbye"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token builtin class-name">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                // <span class="token number">2</span>. 把读到的内容构造成请求, 发送给服务器.
                PrintWriter printWriter <span class="token operator">=</span> new PrintWriter<span class="token punctuation">(</span>outputStream<span class="token punctuation">)</span><span class="token punctuation">;</span>
                printWriter.println<span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>
                // 此处加上 flush 保证数据确实发送出去了.
                printWriter.flush<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                // <span class="token number">3</span>. 读取服务器的响应
                Scanner respScanner <span class="token operator">=</span> new Scanner<span class="token punctuation">(</span>inputStream<span class="token punctuation">)</span><span class="token punctuation">;</span>
                String response <span class="token operator">=</span> respScanner.next<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                // <span class="token number">4</span>. 把响应内容显示到界面上
                System.out.println<span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> catch <span class="token punctuation">(</span>IOException e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            e.printStackTrace<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    public static void main<span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> throws IOException <span class="token punctuation">{<!-- --></span>
        TcpEchoClient client <span class="token operator">=</span> new TcpEchoClient<span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span>, <span class="token number">9090</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        client.start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<p><img src="https://images2.imgbox.com/55/da/eZgueXzt_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a2/3c/6D8BoVCN_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/1b/6f/oQYuqIgO_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/ea/14/172pZQx7_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_237"></a>⭕总结</h2> 
<p>关于《【网络原理】使用Java基于TCP实现简单客户端与服务器通信》就讲解到这儿，感谢大家的支持，欢迎各位留言交流以及批评指正，如果文章对您有帮助或者觉得作者写的还不错可以点一下关注，点赞，收藏支持一下！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/577159e078dafd6c5161c2d5d9b1e941/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">TimescaleDB 开源时序数据库</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6cd6e032caec46f8de594dc30d6b374a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android Studio下载安装及完全卸载</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>