<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【SpringBoot】Bean 是什么？ - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/319b29360715ef8098ad4a8009ae4916/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【SpringBoot】Bean 是什么？">
  <meta property="og:description" content="感兴趣的话，可以看我另外一篇关于 Bean 的文章：【Java基础】Spring 中 Bean 的理解与使用
一、Bean 定义 Bean 作为 Spring 框架面试中不可或缺的概念，其本质上是指代任何被 Spring 加载生成出来的对象。（本质上区别于 Java Bean，Java Bean 是对于 Java 类的一种规范定义。）Spring Bean 代表着 Spring 中最小的执行单位，其加载、作用域、生命周期的管理都由 Spring 操作。可见 Spring Bean 在整个 Spring 框架中的重要地位。
二、设计目的 在了解 Spring 是如何管理 Bean 组件之前，咋们有必要了解为什么 Spring 需要设计出来这么一套机制。假设当前咋们是某个大家族里的公子转世，天天过着衣来伸手饭来张口的生活。在你的家里有一位无微不至的大管家，无论你需要什么，只要跟管家说一下，他就能给你找来。
有一天，你突然饿了，于是你对着管家吩咐道：“本少爷想吃帝王蟹。”。管家听到命令后，吭哧吭哧的给你搞来了。至于管家到底是抓来的、还是买来的，作为少爷的你自然是不关注的。
与此相类似的，如果把程序员想象成少爷，那么 SpringBoot 就是我们忠诚的管家先生。当我们需要用容器内的对象时，只需要“告诉” Spring，Spring 就能自动帮我们加载，我们则无需考虑这个 Bean 到底是如何加载的、什么时候回收等细节逻辑。我们只需要使用即可。由此一来，降低了使用门槛，也减少了对于细节的一些管理。
三、名词介绍 定义：Bean 是在 Spring 容器中被实例化、管理和维护的对象。一个 Bean 可以是任何普通的 Java 对象，例如 POJO、Service、Respository、Controller 等等。将一个类声明为 Bean 的方式可以是在类级别上使用 ‘@Component’ 注解或其派生注解（‘@Service’、‘@Repository’、‘@Controller’等），也可以是通过配置文件进行显式的声明。实例化：Spring 容器负责实例化 Bean。当应用程序启动时，Spring 容器会根据配置信息或注解扫描的结果，找到并实例化所有被标记为 Bean 的类，并将它们加入容器中。实例化的过程由 Spring 的 IoC 容器负责。管理：一旦 Bean 被实例化，Spring 容器将负责管理 Bean 的生命周期和依赖关系。它会根据配置文件或注解的信息，自动解决 Bean 之间的依赖关系，确保在需要的时候正确的注入依赖。Spring 容器还会负责销毁不再需要的 Bean。依赖注入：依赖注入是 Spring 框架的一个重要特性，它允许通过自动或显式配置的方式将 Bean 的依赖项注入到其它 Bean 中。依赖注入可以通过构造函数注入、Setter 方法注入或字段注入的方式实现，其中最常见的是使用 ‘@Autowired’注解进行注入。作用域：Spring 框架提供了多种作用域（scope）来管理 Bean 的生命周期。常见的作用域包括单例（Singleton）、原型（Prototype）、会话（Session）、请求（Request）等。默认情况下，Bean 是单例的，即每个容器中只存在一个实例。但可以根据需要配置其它作用域。 @Component // 默认为单例 public class MyBean { // 代码.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-01-17T19:32:57+08:00">
    <meta property="article:modified_time" content="2024-01-17T19:32:57+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【SpringBoot】Bean 是什么？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2></h2> 
<p><span style="color:#fe2c24;"><strong>感兴趣的话，可以看我另外一篇关于 Bean 的文章</strong></span>：<a class="link-info" href="https://blog.csdn.net/yuxiangdeming/article/details/122876550?spm=1001.2014.3001.5501" title="【Java基础】Spring 中 Bean 的理解与使用">【Java基础】Spring 中 Bean 的理解与使用</a></p> 
<h2>一、Bean 定义</h2> 
<p>Bean 作为 Spring 框架面试中不可或缺的概念，其本质上是指代<strong>任何被 Spring 加载生成出来的对象。</strong>（本质上区别于 Java Bean，Java Bean 是对于 Java 类的一种规范定义。）Spring Bean 代表着 Spring 中最小的执行单位，其加载、作用域、生命周期的管理都由 Spring 操作。可见 Spring Bean 在整个 Spring 框架中的重要地位。</p> 
<h2>二、设计目的</h2> 
<p>在了解 Spring 是如何管理 Bean 组件之前，咋们有必要了解为什么 Spring 需要设计出来这么一套机制。假设当前咋们是某个大家族里的公子转世，天天过着衣来伸手饭来张口的生活。在你的家里有一位无微不至的大管家，无论你需要什么，只要跟管家说一下，他就能给你找来。</p> 
<p>有一天，你突然饿了，于是你对着管家吩咐道：“本少爷想吃帝王蟹。”。管家听到命令后，吭哧吭哧的给你搞来了。至于管家到底是抓来的、还是买来的，作为少爷的你自然是不关注的。</p> 
<p><img alt="" height="421" src="https://images2.imgbox.com/20/9e/HAg3nX63_o.png" width="1009"></p> 
<p>与此相类似的，如果把程序员想象成少爷，那么 SpringBoot 就是我们忠诚的管家先生。当我们需要用容器内的对象时，只需要“告诉” Spring，Spring 就能自动帮我们加载，我们则无需考虑这个 Bean 到底是如何加载的、什么时候回收等细节逻辑。我们只需要使用即可。由此一来，<strong>降低了使用门槛，也减少了对于细节的一些管理。</strong></p> 
<h2><strong>三、名词介绍</strong></h2> 
<ol><li><span style="color:#fe2c24;">定义</span>：<span style="color:#1a439c;">Bean 是在 Spring 容器中被实例化、管理和维护的对象</span>。<span style="color:#1a439c;">一个 Bean 可以是任何普通的 Java 对象</span>，例如 POJO、Service、Respository、Controller 等等。将一个类声明为 Bean 的方式可以是在类级别上使用 ‘@Component’ 注解或其派生注解（‘@Service’、‘@Repository’、‘@Controller’等），也可以是通过配置文件进行显式的声明。</li><li><span style="color:#fe2c24;">实例化</span>：Spring 容器负责实例化 Bean。当应用程序启动时，Spring 容器会根据配置信息或注解扫描的结果，找到并实例化所有被标记为 Bean 的类，并将它们加入容器中。实例化的过程由 Spring 的 IoC 容器负责。</li><li><span style="color:#fe2c24;">管理</span>：<strong><span style="color:#1a439c;">一旦 Bean 被实例化，Spring 容器将负责管理 Bean 的生命周期和依赖关系</span></strong>。它会根据配置文件或注解的信息，自动解决 Bean 之间的依赖关系，确保在需要的时候正确的注入依赖。Spring 容器还会负责销毁不再需要的 Bean。</li><li><span style="color:#fe2c24;">依赖注入</span>：<span style="color:#1a439c;">依赖注入是 Spring 框架的一个重要特性，它允许通过自动或显式配置的方式将 Bean 的依赖项注入到其它 Bean 中</span>。<span style="color:#fe2c24;">依赖注入可以通过构造函数注入、Setter 方法注入或字段注入的方式实现，其中最常见的是使用 ‘@Autowired’注解进行注入</span>。</li><li><span style="color:#fe2c24;">作用域</span>：<span style="color:#fe2c24;">Spring 框架</span>提供了多种作用域（scope）来管理 Bean 的生命周期。<span style="color:#1a439c;">常见的作用域包括单例（Singleton）、原型（Prototype）、会话（Session）、请求（Request）等。默认情况下，Bean 是单例的，即每个容器中只存在一个实例。但可以根据需要配置其它作用域</span>。 <pre><code class="language-java">@Component // 默认为单例
public class MyBean {
    // 代码...
}

-------------------------------------

@Component
@Scope("prototype")
public class MyPrototypeBean {
    // 代码...
}</code></pre> </li><li><span style="color:#fe2c24;">自动装配</span>：<span style="color:#1a439c;">Spring Boot 支持自动装配（Auto - wiring），它能够根据类型或名称自动解析和注入依赖关系。通过在需要注入的字段、构造函数或 Setter 方法上使用 ‘@Autowired’ 注解，Spring 容器会自动查找并注入对应的 Bean</span>。 <pre><code class="language-java">@Component
public class MyService {
    @Autowired
    private MyBean myBean;
    
    // 使用myBean的代码...
}</code></pre> <p>总的来说，<span style="color:#1a439c;">Bean 是 Spring 框架中被实例化、管理和维护的对象。通过在类上使用 ‘@Component’ 注解或其派生注解，将一个类声明为 Bean，并将其交给 Spring 容器处理。Spring 容器负责实例化、管理和维护 Bean 的生命周期和依赖关系。通过依赖注入和自动装配，应用程序可以方便的使用和管理 Bean</span>。</p> </li></ol> 
<h2> 四、装配及注入</h2> 
<p>在了解了 Spring 设计 Bean 的目的以后，我们就可以来了解下在 Spring 中，我们是如何告诉 Spring，我们需要一个 Bean 的了。以下面的 MyBean 类为例子，我们来一步步介绍 Spring 是如何管理、加载 bean 的。</p> 
<pre><code class="language-java">@Data
@AllArgsConstructor
@NoArgsConstructor
public class MyBean {
    Integer filedA;

    Integer fieldB;
}</code></pre> 
<p>开门见山的说，Spring 对于 Bean 的装配有三种方式：<strong>xml 装配、Java 显式配置和自动装配</strong>。</p> 
<h4>xml 装配</h4> 
<p>xml装配就不介绍了，因为是比较老的装配方式了</p> 
<h4>Java 装配</h4> 
<p>经常在第三方项目中，如果我们想要注入一个容器，那么往往需要通过注解 <strong>@Configuration + @Bean </strong>的方式进行实现。如下所示：</p> 
<pre><code class="language-java">@Configuration
public class MyBeanConfiguration {

    @Bean(name = "myBean")
    public MyBean initMyBean() {
        return new MyBean();
    }

}

-------------------------------------------------

@SpringBootApplication
@ComponentScan(basePackages = {"com.example.demo.*", "com.alibaba"}) // 需指明路径。
public class emptyDemoApplication {

    public static void main(String[] args) {
        ConfigurableApplicationContext context = SpringApplication.run(emptyDemoApplication.class, args);

        Object myBean = context.getBean("myBean");
        System.out.println(myBean); // MyBean(filedA=null, fieldB=null)
    }

}
</code></pre> 
<p>需要注意的点是，<strong>Spring 默认是不会开启第三方的 bean 扫描的</strong>（这个取决于下面一种的自动装配机制。），如果需要对第三方的包进行扫描，那么需要采用 @ComponentScan 注解进行显式的指明。</p> 
<h4>自动装配</h4> 
<p>自动装配机制是 SpringBoot 的一大亮点之一，<span style="color:#fe2c24;">其主要依赖于 @SpringBootApplication 下的 @EnableAutoConfiguration 注解</span>（<span style="color:#1a439c;">该注解在 @SpringBootApplication 注解里面，看源码可以看到</span>）实现。简单来说，就是在该注解指定的目录下，通过使用 @Component 及其衍生注解如 @Service、@Repository 等，Spring 就会默认将对应对象注册到容器中。具体例子如下：</p> 
<pre><code class="language-java">@Data
@AllArgsConstructor
@NoArgsConstructor
@Component
public class MyBean {

    Integer filedA;

    Integer fieldB;

}

-------------------------------------------------

@SpringBootApplication
@ComponentScan(basePackages = {"com.example.demo.*", "com.alibaba"}) // 需指明路径。
public class emptyDemoApplication {

    public static void main(String[] args) {
        ConfigurableApplicationContext context = SpringApplication.run(emptyDemoApplication.class, args);

        Object myBean = context.getBean("myBean");
        System.out.println(myBean); // MyBean(filedA=null, fieldB=null)
    }

}
</code></pre> 
<p> 自动装配的方案，<strong>遵循了“约定大于配置”的设计理念</strong>，通过约定俗成来极大减少了程序员开发的成本。在通常情况下，Spring 只会默认扫描当前类路径下的组件，不会扫描其它第三方包组件。可以通过上文的 @ComponentScan 来扩充扫描的范围。</p> 
<h2>五、生命周期</h2> 
<h4>作用域</h4> 
<p>在了解了 Bean 的设计目的及其装配注入的方式后，咋们有必要对 Bean 的整个生命周期做一个了解。但是在了解具体的生命周期之前，我们需要了解一个概念，即容器的作用域。作用域大致有以下五种：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>作用域</td><td>含义</td></tr><tr><td>singleton（默认）</td><td>将单个 bean 定义限定为每个 Spring IoC 容器的单个对象实例。</td></tr><tr><td>prototype</td><td>将单个 bean 定义限定为任意数量的对象实例</td></tr><tr><td>request</td><td>每次用户请求时，只生成一个 Bean 对象</td></tr><tr><td>session</td><td>每次 Http 会话建立到终止时，只能够生成一个对应的 Bean 实例</td></tr><tr><td>application</td><td>每次应用启动到终止，只维持一个对应的 Bean 实例对象</td></tr><tr><td> 
    <ol><li>websocket</li></ol></td><td>每次 webSocket 从建立链接到断开链接，只存在一个对应的 Bean 实例对象</td></tr></tbody></table> 
<p>从含义的解释上来看，作用域主要是解决 Bean 的作用范围的。以 singleton 和 prototype 来说，singleton 在创建之后，springboot 会保证整个上下文环境中都只存在一个该类型的 bean。而如果是 prototype 情况，那么每次 springboot 发生加载的时候，都会新创建一个 bean 进行注入。</p> 
<p>相似的，request、session则是在每次用户请求、每次会话建立都新创建 bean 进行注入。通过指定作用域，我们就可以判断出当前这个 Bean 对象的大致生命周期和作用范围。</p> 
<h4>Bean 生命周期</h4> 
<p>从主观上来考虑，一个 Bean 在容器中管理，大概需要以下这么几步：</p> 
<ol><li>调用构造方法，创建对应的 Bean 类。此时 Bean 类中的属性都是空的。</li><li>将 Bean 所依赖的一些数据，如待注入的容器等，填充到 Bean 对象中。</li><li>调用 bean 内的一些方法，如启动数据库链接等。同时将 Bean 填充到容器中存储起来，以方便应用程序获取使用。</li><li>如果当前不再使用该 Bean 对象，则调用销毁方法，将当前 Bean 销毁。</li></ol> 
<p>而这上述几步，其实也就对应着 Bean 生命周期：</p> 
<ul><li><strong>实例化 Instantiation（</strong>指创建对象的过程，也就是说，当 Spring 容器启动时，它会扫描所有的配置文件，读取 Bean 定义，然后根据定义创建 Bean 对象的实例。这个过程中，Spring 容器会使用反射机制来调用 Bean 的构造函数来实例化对象。<strong>）</strong></li><li><strong>属性赋值 Populate</strong></li><li><strong>初始化 Initialization</strong>（指 Bean 对象被创建后，Spring 容器会根据配置文件中的定义来对其进行一系列的属性设置、依赖注入等操作，使其可以正常运行。这个过程中，Spring 容器会调用 Bean 的一些特定方法，如 set 方法、init-method 方法等来完成对象的初始化。）</li><li><strong>销毁 Destruction</strong></li></ul> 
<p>实例化和初始化的区别：实例化是创建对象的过程，而初始化是为对象设置属性、注入依赖以及调用特定方法来使其准备好执行操作的过程。在 Spring 框架中，实例化和初始化都是由容器来管理的，可以通过配置文件或者注解来指定 Bean 的创建和初始化过程。</p> 
<p>同时，为了方便拓展，Spring 也在特定的生命周期前后提供了接口以供拓展实现，最重要的两个实现接口就是如下两个：</p> 
<ul><li><strong>InstantiationAwareBeanPostProcessor</strong></li><li><strong>BeanPostProcessor</strong></li></ul> 
<p>InstantiationAwareBeanPostProcessor 主要在 Bean 实例化、属性赋值的时候提供了拓展接口；</p> 
<p>而 BeanPostProcessor 则主要在 Bean 初始化前后提供拓展接口。我们熟知的 @PostConstruct 注解，就是通过实现了 BeanPostProcessor 接口，来实现的后处理机制。</p> 
<p>总体来说，Spring 中 bean 的基本生命流程主要如下所示：</p> 
<p><img alt="" height="1086" src="https://images2.imgbox.com/93/2f/7oILq00S_o.png" width="1059"></p> 
<p></p> 
<h2>六、参考文档</h2> 
<ul><li><a class="link-info" href="https://zhuanlan.zhihu.com/p/627070582" rel="nofollow" title="如何理解Spring中的Bean">如何理解Spring中的Bean</a></li><li><a class="link-info" href="https://blog.csdn.net/wenhuakulv2008/article/details/132577330" title="【SpringBoot】详细介绍SpringBoot中的bean">【SpringBoot】详细介绍SpringBoot中的bean</a></li></ul> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/de0e3559791e6082aeb2431438ff0d40/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">AIGC内容分享(五十一)：音韵如诗如斯：AIGC音乐创新工具之Suno</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5d22217caa6ffde0d598f0b5c51431a9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Web 服务器的搭建</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>