<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Oracle数据库 v$archived_log - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/c06760384ac261b6214a05a08dd56bd3/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Oracle数据库 v$archived_log">
  <meta property="og:description" content="v$archived_log详解 V$ARCHIVED_LOG视图描述了系统中已经归档的日志文件的相关信息。归档日志是ARCHIVELOG模式的一种，用来记录DML以及DDL对数据库中对象所做的更改，保护数据库以及实施重做数据库恢复。
V$ARCHIVED_LOG视图的主要用途是查看已经归档的日志的信息，确定要恢复的日志。可以直接执行：
#查询当前被归档日志的相关信息 SELECT ARCHIVED, DELETED, SEQUENCE#, RESETLOGS_CHANGE#, FLAGS, ARCHIVE_DATE, ARCHIVE_SCN, SESSION_INFO FROM V$ARCHIVED_LOG; V$ARCHIVED_LOG displays archived log information from the control file, including archive log names.
An archive log record is inserted after the online redo log is successfully archived or cleared (name column is NULL if the log was cleared). If the log is archived twice, there will be two archived log records with the same THREAD#, SEQUENCE#, and FIRST_CHANGE#, but with a different name.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-20T08:30:00+08:00">
    <meta property="article:modified_time" content="2024-07-20T08:30:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Oracle数据库 v$archived_log</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="varchived_log_0"></a>v$archived_log详解</h2> 
<p>V$ARCHIVED_LOG视图描述了系统中已经归档的日志文件的相关信息。归档日志是ARCHIVELOG模式的一种，用来记录DML以及DDL对数据库中对象所做的更改，保护数据库以及实施重做数据库恢复。</p> 
<p>V$ARCHIVED_LOG视图的主要用途是查看已经归档的日志的信息，确定要恢复的日志。可以直接执行：</p> 
<pre><code class="prism language-sql"><span class="token comment">#查询当前被归档日志的相关信息</span>
<span class="token keyword">SELECT</span> ARCHIVED<span class="token punctuation">,</span> DELETED<span class="token punctuation">,</span> SEQUENCE<span class="token comment">#, RESETLOGS_CHANGE#,</span>
FLAGS<span class="token punctuation">,</span> ARCHIVE_DATE<span class="token punctuation">,</span> ARCHIVE_SCN<span class="token punctuation">,</span> SESSION_INFO
<span class="token keyword">FROM</span> V$ARCHIVED_LOG<span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p><code>V$ARCHIVED_LOG</code> displays archived log information from the control file, including archive log names.</p> 
 <p>An archive log record is inserted after the online redo log is successfully archived or cleared (name column is <code>NULL</code> if the log was cleared). If the log is archived twice, there will be two archived log records with the same <code>THREAD#</code>, <code>SEQUENCE#</code>, and <code>FIRST_CHANGE#</code>, but with a different name. An archive log record is also inserted when an archive log is restored from a backup set or a copy and whenever a copy of a log is made with the RMAN <code>COPY</code> command.</p> 
</blockquote> 
<table><thead><tr><th align="left">Column</th><th align="left">Datatype</th><th align="left">Description</th><th>解释</th></tr></thead><tbody><tr><td align="left"><code>RECID</code></td><td align="left"><code>NUMBER</code></td><td align="left">Archived log record ID</td><td>归档日志记录的唯一标识号</td></tr><tr><td align="left"><code>STAMP</code></td><td align="left"><code>NUMBER</code></td><td align="left">Archived log record stamp</td><td>时间戳，与<code>RECID</code>一起构成归档日志记录的全局唯一标识</td></tr><tr><td align="left"><code>NAME</code></td><td align="left"><code>VARCHAR2(513)</code></td><td align="left">Archived log file name. If set to <code>NULL</code>, either the log file was cleared before it was archived or an RMAN backup command with the “delete input” option was executed to back up archivelog all (<code>RMAN&gt; backup archivelog all delete input;</code>).</td><td>归档日志文件名</td></tr><tr><td align="left"><code>DEST_ID</code></td><td align="left"><code>NUMBER</code></td><td align="left">Original destination from which the archive log was generated. The value is <code>0</code> if the destination identifier is not available.</td><td>归档生成的目标</td></tr><tr><td align="left"><code>THREAD#</code></td><td align="left"><code>NUMBER</code></td><td align="left">Redo thread number</td><td>数据库线程的编号。Oracle数据库可以由多个线程组成，每个线程负责处理特定的事务。</td></tr><tr><td align="left"><code>SEQUENCE#</code></td><td align="left"><code>NUMBER</code></td><td align="left">Redo log sequence number</td><td>归档日志的序列号。表示日志的生成顺序。</td></tr><tr><td align="left"><code>RESETLOGS_CHANGE#</code></td><td align="left"><code>NUMBER</code></td><td align="left">Resetlogs change number of the database when the log was written</td><td>重置日志序列号，用于标识新的一组日志</td></tr><tr><td align="left"><code>RESETLOGS_TIME</code></td><td align="left"><code>DATE</code></td><td align="left">Resetlogs time of the database when the log was written</td><td>日志重置的时间戳编号</td></tr><tr><td align="left"><code>RESETLOGS_ID</code></td><td align="left"><code>NUMBER</code></td><td align="left">Resetlogs identifier associated with the archived redo log</td><td>重置日志的时间戳</td></tr><tr><td align="left"><code>FIRST_CHANGE#</code></td><td align="left"><code>NUMBER</code></td><td align="left">First change number in the archived log</td><td>归档日志中第一个重做记录的重做号（Redo Log Sequence Number）</td></tr><tr><td align="left"><code>FIRST_TIME</code></td><td align="left"><code>DATE</code></td><td align="left">Timestamp of the first change</td><td>归档日志的创建时间</td></tr><tr><td align="left"><code>NEXT_CHANGE#</code></td><td align="left"><code>NUMBER</code></td><td align="left">First change in the next log</td><td>归档日志中最后一个重做记录的重做号</td></tr><tr><td align="left"><code>NEXT_TIME</code></td><td align="left"><code>DATE</code></td><td align="left">Timestamp of the next change</td><td>下一个归档日志的预计创建时间</td></tr><tr><td align="left"><code>BLOCKS</code></td><td align="left"><code>NUMBER</code></td><td align="left">Size of the archived log (in blocks)</td><td>归档日志的块数</td></tr><tr><td align="left"><code>BLOCK_SIZE</code></td><td align="left"><code>NUMBER</code></td><td align="left">Redo log block size. This is the logical block size of the archived log, which is the same as the logical block size of the online log from which the archived log was copied. The online log logical block size is a platform-specific value that is not adjustable by the user.</td><td>归档日志块的大小</td></tr><tr><td align="left"><code>CREATOR</code></td><td align="left"><code>VARCHAR2(7)</code></td><td align="left">Creator of the archivelog:<br><code>ARCH</code> – Archiver process<br><code>FGRD</code> – Foreground process<br><code>RMAN</code> – Recovery Manager<br><code>SRMN</code> – RMAN at standby<br><code>LGWR</code> – Logwriter process</td><td>触发归档的原因</td></tr><tr><td align="left"><code>REGISTRAR</code></td><td align="left"><code>VARCHAR2(7)</code></td><td align="left">Registrar of the entry:<br><code>RFS</code> – Remote File Server process<br><code>ARCH</code> – Archiver process<br><code>FGRD</code> – Foreground process<br><code>RMAN</code> – Recovery manager<br><code>SRMN</code> – RMAN at standby<br><code>LGWR</code> – Logwriter process</td><td>条目注册</td></tr><tr><td align="left"><code>STANDBY_DEST</code></td><td align="left"><code>VARCHAR2(3)</code></td><td align="left">Indicates whether the entry is an archivelog destination (<code>YES</code>) or not (<code>NO</code>)</td><td>显示条目是否是归档日志目标</td></tr><tr><td align="left"><code>ARCHIVED</code></td><td align="left"><code>VARCHAR2(3)</code></td><td align="left">Indicates whether the online redo log was archived (<code>YES</code>) or whether RMAN only inspected the log and created a record for future application of redo logs during recovery (<code>NO</code>).</td><td>显示是否归档(YES)或是否是RMAN恢复创建的记录(NO)</td></tr><tr><td align="left"><code>APPLIED</code></td><td align="left"><code>VARCHAR2(9)</code></td><td align="left">Indicates whether an archived redo log file has been applied to the corresponding physical standby database. The value is always <code>NO</code> for local destinations.This column is meaningful on a physical standby database for rows where <code>REGISTRAR</code> = <code>RFS</code>:If <code>REGISTRAR</code> = <code>RFS</code> and <code>APPLIED</code> = <code>NO</code>, then the log file has been received but has not yet been applied.If <code>REGISTRAR</code> = <code>RFS</code> and <code>APPLIED</code> = <code>IN-MEMORY</code>, then the log file has been applied in memory, but the data files have not yet been updated.If <code>REGISTRAR</code> = <code>RFS</code> and <code>APPLIED</code> = <code>YES</code>, then the log file has been applied and the data files have been updated.This column can be used to identify log files that can be backed up and deleted. When used for this purpose, the value <code>IN-MEMORY</code> should be treated as if it were <code>NO</code>.</td><td>显示归档日志已被应用到了physical standby中,对本地节点值为NO在物理standby中的意义：<br>REGISTRAR=RFS &amp;&amp; APPLIED=NO,表示logfile已被接受并注册但没有应用<br>REGISTRAR=RFS &amp;&amp; APPLIED=IN-MEMORY,表示在内存中已应用logfile,还没有更新到datafiles中<br>REGISTRAR=RFS &amp;&amp; APPLIED=YES,表示已应用logfile并更新到datafiles</td></tr><tr><td align="left"><code>DELETED</code></td><td align="left"><code>VARCHAR2(3)</code></td><td align="left">Indicates whether an RMAN <code>DELETE</code> command has physically deleted the archived log file from disk, as well as logically removing it from the control file of the target database and from the recovery catalog (<code>YES</code>) or not (<code>NO</code>)</td><td>显示是否使用了RMAN DELETE命令物理删除了归档日志,是否在逻辑上从controlfile恢复目录移除(YES/NO)</td></tr><tr><td align="left"><code>STATUS</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">Status of the archived log:<br><code>A</code> – Available<br><code>D</code> – Deleted<br><code>U</code> – Unavailable<br><code>X</code> – Expired</td><td>归档日志状态</td></tr><tr><td align="left"><code>COMPLETION_TIME</code></td><td align="left"><code>DATE</code></td><td align="left">Time when the archiving completed</td><td>归档完成时间</td></tr><tr><td align="left"><code>DICTIONARY_BEGIN</code></td><td align="left"><code>VARCHAR2(3)</code></td><td align="left">Indicates whether the log contains the start of a LogMiner dictionary (<code>YES</code>) or not (<code>NO</code>)</td><td>显示是否是LogMiner数据字典包含日志的开始(YES/NO)</td></tr><tr><td align="left"><code>DICTIONARY_END</code></td><td align="left"><code>VARCHAR2(3)</code></td><td align="left">Indicates whether the log contains the end of a LogMiner dictionary (<code>YES</code>) or not (<code>NO</code>)</td><td>显示是否是LogMiner数据字典包含日志的结束(YES/NO)</td></tr><tr><td align="left"><code>END_OF_REDO</code></td><td align="left"><code>VARCHAR2(3)</code></td><td align="left">Indicates whether the archived redo log contains the end of all redo information from the primary database (<code>YES</code>) or not (<code>NO</code>)</td><td>显示primary端归档日志是否包含redo结束信息</td></tr><tr><td align="left"><code>BACKUP_COUNT</code></td><td align="left"><code>NUMBER</code></td><td align="left">Indicates the number of times this file has been backed up. Values range from 0-15. If the file has been backed up more than 15 times, the value remains 15.</td><td>显示文件被备份的次数(0-15),如果次数超出15,则保留显示为15</td></tr><tr><td align="left"><code>ARCHIVAL_THREAD#</code></td><td align="left"><code>NUMBER</code></td><td align="left">Redo thread number of the instance that performed the archival operation. This column differs from the <code>THREAD#</code> column only when a closed thread is archived by another instance.</td><td>执行归档操作的实例线程号,当关闭的线程被其他实例归档时值与THREAD#不同</td></tr><tr><td align="left"><code>ACTIVATION#</code></td><td align="left"><code>NUMBER</code></td><td align="left">Number assigned to the database instantiation</td><td>被实例分配的次数</td></tr><tr><td align="left"><code>IS_RECOVERY_DEST_FILE</code></td><td align="left"><code>VARCHAR2(3)</code></td><td align="left">Indicates whether the file was created in the fast recovery area (<code>YES</code>) or not (<code>NO</code>)</td><td>显示文件是否被创建到fast recovery ares(YES/NO)</td></tr><tr><td align="left"><code>COMPRESSED</code></td><td align="left"><code>VARCHAR2(3)</code></td><td align="left">Reserved for internal use</td><td>保留作内部使用</td></tr><tr><td align="left"><code>FAL</code></td><td align="left"><code>VARCHAR2(3)</code></td><td align="left">Indicates whether the archive log was generated as the result of a FAL request (<code>YES</code>) or not (<code>NO</code>)</td><td>显示归档日志是否为FAL请求产生的(YES/NO)</td></tr><tr><td align="left"><code>END_OF_REDO_TYPE</code></td><td align="left"><code>VARCHAR2(10)</code></td><td align="left">Possible values are as follows:<br><code>SWITCHOVER</code> – Shows archived redo log files that are produced at the end of a switchover<br><code>TERMINAL</code> – Shows archived redo log files produced after a failover<br><code>RESETLOGS</code> – Shows online redo log files archived on the primary database after an <code>ALTER DATABASE OPEN RESETLOGS</code> statement is issued<br><code>ACTIVATION</code> – Shows any log files archived on a physical standby database after an <code>ALTER DATABASE ACTIVATE STANDBY</code> <code>DATABASE</code> statement is issued<br><code>empty string</code> – Any empty string implies that the log is just a normal archival and was not archived due to any of the other events</td><td>SWITCHOVER ：Switchover产生的EOR<br>TERMINAL : Failover产生的EOR<br>RESETLOGS : 主库执行ALTER DATABASE OPEN RESETLOGS语句后产生的归档<br>ACTIVATION ：物理standby执行ALTER DATABASE ACTIVATE STANDBY DATABASE语句后产生的归档<br>空值 ：正常的归档</td></tr><tr><td align="left"><code>BACKED_BY_VSS</code></td><td align="left"><code>VARCHAR2(3)</code></td><td align="left">Whether or not the file has been backed up by Volume Shadow Copy Service (VSS). This column is reserved for internal use.</td><td>显示文件是否以Volume Shadow Copy Service(VSS)备份,保留作内部使用</td></tr><tr><td align="left"><code>CON_ID</code></td><td align="left"><code>NUMBER</code></td><td align="left">The ID of the container to which the data pertains. Possible values include:<code>0</code>: This value is used for rows containing data that pertain to the entire CDB. This value is also used for rows in non-CDBs.<code>1</code>: This value is used for rows containing data that pertain to only the rootn: Where n is the applicable container ID for the rows containing data</td><td>容器ID，对于多租户数据库，用于标识租户的容器</td></tr></tbody></table>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/54b80a168d23285b6522486057fc7fd3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">概率论中的卷积公式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4915465bba0322f0496683d610ca35d7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">​数据结构之初始二叉树（3）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>