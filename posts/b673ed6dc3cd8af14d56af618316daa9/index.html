<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构-树的遍历和基本操作(Java实现) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b673ed6dc3cd8af14d56af618316daa9/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构-树的遍历和基本操作(Java实现)">
  <meta property="og:description" content="一. 二叉树的遍历 二叉树的遍历分为以下三种: 前序遍历: 访问顺序为 根节点----&gt;左子树----&gt;右子树
中序遍历: 访问顺序为 左子树----&gt;根节点----&gt;右子树
后序遍历: 访问顺序为 左子树----&gt;右子树----&gt;根节点
接下来针对这3种遍历方式进行详细介绍:
(1) 前序遍历 上图前序遍历顺序为 1 2 3 4 5 6
(2) 中序遍历 上图中序遍历顺序为3 2 1 5 4 6 (3) 后序遍历 上图后序遍历顺序为 3 2 5 6 4 1
(4) 层序遍历原理 除了前序遍历,中序遍历,后序遍历外,还可以对二叉树进行层序遍历. 设二叉树的根节点所在层数为1, 层序遍历就是从所在二叉树的根节点出发,首先访问第一层的树的根节点,然后从左到右访问第2层上的结点,接着是第三层的结点,以此类推,自上而下,自左至右逐层访问树的结点的过程就是层序遍历. 上图的层序遍历为 1 2 4 3 5 6
二. 二叉树的基本操作 2.1 二叉树的创建 二叉树的存储结构分为: 顺序存储结构和类似于链表的链式存储。二叉树的链式存储是通过一个一个的结点引用起来的，常见的表示方式有二叉和三叉表示方式。在这里我们主要是使用二叉表示法来创建二叉树。
static class TreeNode { //定义好三个属性 public char val; public TreeNode left; //左节点 public TreeNode right; //右节点 public TreeNode(char val) { //提供一个结点的构造方法 new一个新结点的时候是不知道左右子树的,所以不用构造 this.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-07T10:53:19+08:00">
    <meta property="article:modified_time" content="2024-03-07T10:53:19+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构-树的遍历和基本操作(Java实现)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一. 二叉树的遍历</h2> 
<p>二叉树的遍历分为以下三种: </p> 
<p><strong>前序遍历: 访问顺序为  根节点----&gt;左子树----&gt;右子树</strong></p> 
<p><strong>中序遍历: 访问顺序为  左子树----&gt;根节点----&gt;右子树</strong></p> 
<p><strong>后序遍历: 访问顺序为  左子树----&gt;右子树----&gt;根节点</strong></p> 
<p><strong>接下来针对这3种遍历方式进行详细介绍:</strong></p> 
<h3>        (1) 前序遍历</h3> 
<p><img alt="" height="420" src="https://images2.imgbox.com/36/c1/X3CPejd7_o.png" width="699"><strong>上图前序遍历顺序为 1 2 3 4 5 6</strong></p> 
<h3><strong>        (2) 中序遍历</strong></h3> 
<h3><img alt="" height="303" src="https://images2.imgbox.com/88/6b/DgSENH8H_o.png" width="520"></h3> 
<p><strong>上图中序遍历顺序为3 2 1 5 4 6</strong> </p> 
<h3>        (3) 后序遍历</h3> 
<p><img alt="" height="347" src="https://images2.imgbox.com/94/22/gXSOAiMx_o.png" width="582"></p> 
<p><strong>上图后序遍历顺序为 3 2 5 6 4 1</strong></p> 
<h3><strong>        (4) 层序遍历原理</strong></h3> 
<p>        除了前序遍历,中序遍历,后序遍历外,还可以对二叉树进行层序遍历. <strong>设二叉树的根节点所在层数为1, 层序遍历就是从所在二叉树的根节点出发,首先访问第一层的树的根节点,然后从左到右访问第2层上的结点,接着是第三层的结点,以此类推,自上而下,自左至右逐层访问树的结点的过程就是层序遍历. </strong></p> 
<p><img alt="" height="303" src="https://images2.imgbox.com/5d/9d/hnm56vmM_o.png" width="579"></p> 
<p><strong>上图的层序遍历为 1 2 4 3 5 6</strong></p> 
<h2> 二. 二叉树的基本操作</h2> 
<h3>2.1 二叉树的创建</h3> 
<p><strong>二叉树的存储结构</strong>分为: <strong>顺序存储结构和类似于链表的链式存储。二叉树的链式存储是通过一个一个的结点引用起来的，常见的表示方式有二叉和三叉表示方式。</strong>在这里我们主要是使用二叉表示法来创建二叉树。</p> 
<pre><code class="language-java">    static class TreeNode {  //定义好三个属性
        public char val;
        public TreeNode left;  //左节点
        public TreeNode right;  //右节点

        public TreeNode(char val) {  //提供一个结点的构造方法  new一个新结点的时候是不知道左右子树的,所以不用构造
            this.val = val;
        }
    }</code></pre> 
<h3>2.2 二叉树的创建代码实现</h3> 
<p>以下图二叉树为例创建</p> 
<p><img alt="" height="412" src="https://images2.imgbox.com/58/3f/FPyeaU0n_o.png" width="573"></p> 
<pre><code class="language-java">    //以穷举的方式创建一棵二叉树出来
    public TreeNode creatTree() {  //要返回树的根节点,所以返回类型是 TreeNode
        TreeNode A = new TreeNode('A');  //创建一个结点赋值
        TreeNode B = new TreeNode('B');  //创建一个结点赋值
        TreeNode C = new TreeNode('C');  //创建一个结点赋值
        TreeNode D = new TreeNode('D');  //创建一个结点赋值
        TreeNode E = new TreeNode('E');  //创建一个结点赋值
        TreeNode F = new TreeNode('F');  //创建一个结点赋值
        TreeNode G = new TreeNode('G');  //创建一个结点赋值
        TreeNode H = new TreeNode('H');  //创建一个结点赋值

        A.left = B;
        A.right = C;

        B.left = D;
        B.right = E;
        C.left = F;
        C.right = G;

        E.right = H;

        return A;  //返回根节点

    }</code></pre> 
<h3>2.3 二叉树的基本操作（Java实现）</h3> 
<h4>2.3.1 前序遍历代码实现（递归方式）</h4> 
<p> 由于二叉树是递归定义的，所以二叉树的遍历一般也是采用递归的形式，当然二叉树也可以用非递归方式遍历。这里文章用递归方式介绍。前序遍历即采用先访问根节点，再访问左子树，最后访问右子树的顺序。前序遍历也是按照类似的方式递归遍历，具体操作如下：<br><strong>① 如果当前节点值为空，返回；<br> ②如果当前节点值不为空，打印当前节点值；递归遍历左子树；递归遍历右子树。</strong></p> 
<pre><code class="language-java">    // 前序遍历
    void preOrder(TreeNode root) {
        if (root == null) {
            return;  //空树是不需要遍历的
        }
        System.out.print(root.val + " ");
        preOrder(root.left);  //递归
        preOrder(root.right);

    }
</code></pre> 
<h4> 2.3.2 中序遍历代码实现</h4> 
<p><strong>①如果当前节点值为空，返回；<br> ②递归遍历左子树；打印当前节点的值；递归遍历右子树。</strong></p> 
<pre><code class="language-java">    // 中序遍历
    void inOrder(TreeNode root) {
        if (root == null) {
            return;
        }
        inOrder(root.left);
        System.out.print(root.val + " ");
        inOrder(root.right);

    }</code></pre> 
<h4>2.3.3 后序遍历代码实现</h4> 
<p><strong>①如果当前节点值为空，返回；<br> ②递归遍历左子树；递归遍历右子树；打印当前节点的值。</strong></p> 
<pre><code class="language-java">    // 后序遍历
    void postOrder(TreeNode root) {
        if (root == null) {
            if (root == null) {
                return;
            }
            postOrder(root.left);
            postOrder(root.right);
            System.out.print(root.val + " ");
        }

    }</code></pre> 
<h4>2.3.4 获取树中结点的个数</h4> 
<pre><code class="language-java">    public static int nodeSize;  //默认为0
    public int size(TreeNode root){
        if(root == null){
            return 0;
        }
        nodeSize++;
        size(root.left);  //遍历左子树
        size(root.right);  //遍历右子树
        return nodeSize;
    }</code></pre> 
<p>子问题思路： </p> 
<pre><code class="language-java">    public int size2(TreeNode root){
        if(root == null){
            return 0;
        }
        //左子树的个数加上右子树的结点个数加上根结点
        int tmp = size2(root.left)+size2(root.right)+1;  
        return tmp;
    }</code></pre> 
<h4>2.3.5 获取叶子结点的个数</h4> 
<pre><code class="language-java">    //获取叶子结点个数
    public static int leafSize;
    public void getLeafNodeCount(TreeNode root){
        if(root == null){
            return;
        }
        if(root.left == null &amp;&amp; root.right == null){  
            //如果没有左右子树就说明是叶子节点
            leafSize++;
        }
        getLeafNodeCount(root.left);  //递归遍历左子树
        getLeafNodeCount(root.right);  //递归遍历右子树
    }</code></pre> 
<p> 子问题思路： <strong>root这棵树有多少个叶子结点 = 左子树的叶子结点 + 右子树的叶子结点</strong></p> 
<pre><code class="language-java">    public int getLeafNodeCount2(TreeNode root){
        if(root == null){
            return 0;
        }
        if(root.left == null &amp;&amp; root.right == null){
            return 1;
        }
        return getLeafNodeCount2(root.left)+getLeafNodeCount2(root.right);
    }</code></pre> 
<h4>2.3.6 获取第K层结点的个数</h4> 
<pre><code class="language-java">    public int getKLevelNodeCount(TreeNode root,int k){
        if(root == null){
            return 0;
        }
        if(k == 1){
            return 1;
        }else{
            return getKLevelNodeCount(root.left,k-1)+getKLevelNodeCount(root.right,k-1);
        }
    }</code></pre> 
<h4>2.3.7 获取树的高度</h4> 
<h4></h4> 
<pre><code class="language-java">    //获取树的高度
    //整棵树的高度 = 左子树的高度和右子树的高度的最大值 + 1
    public int getHeight(TreeNode root){
        if(root == null){
            return 0;
        }
        int hl = getHeight(root.left);  //获取左子树的高度
        int hr = getHeight(root.right);  //获取右子树的高度
        int max = hl&gt;hr?hl:hr;
        return max+1;
    }</code></pre> 
<h4>2.3.8 检测value的值是否存在</h4> 
<pre><code class="language-java">    //寻找树指定的元素
    public TreeNode find(TreeNode root,int val){
        if(root ==null){
            return null;
        }
        if(root.val == val){  //先判断根节点是不是我们要找的数据
            return root;
        }
        TreeNode leftVal = find(root.left,val);  //左子树去找
        if(leftVal != null){  //返回值不等于空说明找到了
            return leftVal;
        }
        TreeNode rightVal = find(root.right,val);  //右子树去找
        if(rightVal != null){  //返回值不等于空说明找到了
            return rightVal;
        }
        //左右都走完没找到返回空
        return null;
    }</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/32915128b951ebbc396b5c6af2d6d9e3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">信号特征之希尔伯特变换（Python、C&#43;&#43;、MATLAB实现）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cd0f70e67b4df88a1a713de726260031/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">毕业设计 基于大数据情感分析的网络舆情分析系统(源码&#43;论文)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>