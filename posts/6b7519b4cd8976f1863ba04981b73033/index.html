<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构——链式二叉树 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/6b7519b4cd8976f1863ba04981b73033/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构——链式二叉树">
  <meta property="og:description" content="前言：哈喽小伙伴们，上篇文章我们讲述了一个特殊的二叉树——使用数组实现的堆的基本知识之后呢，从这篇文章开始，我们就正式进入普通二叉树的介绍啦，二叉树真正的难点——递归，即将来临，小伙伴们注意不要掉队哦。
目录
一.链式二叉树
二.遍历二叉树
三.二叉树的实现
1.二叉树的定义
2.创建二叉树节点
四.二叉树的操作
1.先序遍历
2.中序遍历
3.后序遍历
4.节点个数
递归分析
5.叶节点数
6.树的高度
7.第k层节点数
8.查找指定值节点
9.销毁二叉树
四.完整代码展示
1.BinaryTree.h
2.BinaryTree.c
3.test.c
五.总结
一.链式二叉树 在前边的文章中，我们已经了解到，二叉树可以有顺序存储和链式存储两种方式，在堆的文章中，我们讲解了顺序存储的完全二叉树，那么现在，我们一起来认识一下链式存储的普通二叉树。
我们知道，二叉树的规则是，每个节点至多有两个子节点，而两个子节点及其后续的子节点组成的整体，又可以分别称为左右子树，如右图所示，1为根节点，2和3则一起构成左子树，4、5、6则构成右子树。 而这两个子树，同样可以看做是由一个根节点和左右子树构成的新树。
所以，任何一个二叉树都可以被拆解为三部分：
根节点左子树右子树 由此看来，二叉树和递归离不开关系，后续二叉树的各种基本操作，也都是通过递归来实现的。
二.遍历二叉树 二叉树的遍历有三种方式：
1.前（先）序遍历：先遍历树的根节点，再遍历它的左子树，最后是右子树。
2.中序遍历：先遍历树的左子树，再遍历它的根节点，最后是右子树。
3.后序遍历：先遍历树的左子树，再遍历它的右子树，最后是根节点。
我们以这棵树为例：
前序遍历即为：1 2 3 4 5 6。
但是这样写其实并不合理，因为我们是用链表来写二叉树的结构的，所以对于节点2来说，它并不是没有右子树，而是右子树是空树。
同样的，3、5、6同样可以作为一颗树，不过它们的左右子树都是空树罢了。
所以合理的遍历方式应该把空树也带上，我们这里用N表示，于是：
前序遍历：1 2 3 N N N 4 5 N N 6 N N，如果用图形来表示，如下：
每一个方框都可以看做是一个新的树，从左到右依次为：根，左，右。如此，我们便也能写出中序遍历和后序遍历：
中序遍历：N 3 N 2 N 1 N 5 N 4 N 6 N，图形如下：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-12-06T20:53:37+08:00">
    <meta property="article:modified_time" content="2023-12-06T20:53:37+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构——链式二叉树</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>前言：哈喽小伙伴们，上篇文章我们讲述了一个特殊的二叉树——使用数组实现的堆的基本知识之后呢，从这篇文章开始，我们就<strong>正式进入普通二叉树的介绍啦，二叉树真正的难点——递归，即将来临，小伙伴们注意不要掉队哦</strong>。</p> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80.%E9%93%BE%E5%BC%8F%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:0px;"><a href="#%E4%B8%80.%E9%93%BE%E5%BC%8F%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">一.链式二叉树</a></p> 
<p id="%E4%BA%8C.%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">二.遍历二叉树</a></p> 
<p id="%E4%B8%89.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%E4%B8%89.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">三.二叉树的实现</a></p> 
<p id="1.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#1.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">1.二叉树的定义</a></p> 
<p id="2.%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9-toc" style="margin-left:40px;"><a href="#2.%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9" rel="nofollow">2.创建二叉树节点</a></p> 
<p id="%E5%9B%9B.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C-toc" style="margin-left:0px;"><a href="#%E5%9B%9B.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C" rel="nofollow">四.二叉树的操作</a></p> 
<p id="1.%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86-toc" style="margin-left:40px;"><a href="#1.%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86" rel="nofollow">1.先序遍历</a></p> 
<p id="2.%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-toc" style="margin-left:40px;"><a href="#2.%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86" rel="nofollow">2.中序遍历</a></p> 
<p id="3.%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-toc" style="margin-left:40px;"><a href="#3.%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86" rel="nofollow">3.后序遍历</a></p> 
<p id="4.%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0-toc" style="margin-left:40px;"><a href="#4.%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0" rel="nofollow">4.节点个数</a></p> 
<p id="%E9%80%92%E5%BD%92%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><a href="#%E9%80%92%E5%BD%92%E5%88%86%E6%9E%90" rel="nofollow">递归分析</a></p> 
<p id="5.%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0-toc" style="margin-left:40px;"><a href="#5.%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0" rel="nofollow">5.叶节点数</a></p> 
<p id="6.%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6-toc" style="margin-left:40px;"><a href="#6.%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6" rel="nofollow">6.树的高度</a></p> 
<p id="7.%E7%AC%ACk%E5%B1%82%E8%8A%82%E7%82%B9%E6%95%B0-toc" style="margin-left:40px;"><a href="#7.%E7%AC%ACk%E5%B1%82%E8%8A%82%E7%82%B9%E6%95%B0" rel="nofollow">7.第k层节点数</a></p> 
<p id="8.%E6%9F%A5%E6%89%BE%E6%8C%87%E5%AE%9A%E5%80%BC%E8%8A%82%E7%82%B9-toc" style="margin-left:40px;"><a href="#8.%E6%9F%A5%E6%89%BE%E6%8C%87%E5%AE%9A%E5%80%BC%E8%8A%82%E7%82%B9" rel="nofollow">8.查找指定值节点</a></p> 
<p id="9.%E9%94%80%E6%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:40px;"><a href="#9.%E9%94%80%E6%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">9.销毁二叉树</a></p> 
<p id="%E5%9B%9B.%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA-toc" style="margin-left:0px;"><a href="#%E5%9B%9B.%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA" rel="nofollow">四.完整代码展示</a></p> 
<p id="1.BinaryTree.h-toc" style="margin-left:40px;"><a href="#1.BinaryTree.h" rel="nofollow">1.BinaryTree.h</a></p> 
<p id="2.BinaryTree.c-toc" style="margin-left:40px;"><a href="#2.BinaryTree.c" rel="nofollow">2.BinaryTree.c</a></p> 
<p id="3.test.c-toc" style="margin-left:40px;"><a href="#3.test.c" rel="nofollow">3.test.c</a></p> 
<p id="%E4%BA%94.%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E4%BA%94.%E6%80%BB%E7%BB%93" rel="nofollow">五.总结</a></p> 
<hr> 
<h2 id="%E4%BA%94.%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;">一.链式二叉树</h2> 
<p></p> 
<p>在前边的文章中，我们已经了解到，二叉树可以有顺序存储和链式存储两种方式，在堆的文章中，我们讲解了顺序存储的完全二叉树，那么现在，我们一起来认识一下<span style="color:#fe2c24;"><strong>链式存储的普通二叉树</strong></span>。</p> 
<p><img alt="" height="283" src="https://images2.imgbox.com/62/ed/SXf6MGGZ_o.png" width="588"></p> 
<p>我们知道，二叉树的规则是，<span style="color:#fe2c24;"><strong>每个节点至多有两个子节点</strong></span>，而<strong><span style="background-color:#ffd900;">两个子节点及其后续的子节点组成的整体，又可以分别称为左右子树</span></strong>，如右图所示，<strong><span style="background-color:#ffd900;">1为根节点，2和3则一起构成左子树，4、5、6则构成右子树</span></strong>。 <span style="color:#fe2c24;"><strong>而这两个子树，同样可以看做是由一个根节点和左右子树构成的新树</strong></span>。</p> 
<p>所以，任何一个二叉树都可以被拆解为三部分：</p> 
<ol><li><strong>根节点</strong></li><li><strong>左子树</strong></li><li><strong>右子树</strong></li></ol> 
<p>由此看来，<strong>二叉树和<span style="color:#fe2c24;">递归</span>离不开关系，后续二叉树的各种基本操作，也都是通过递归来实现的</strong>。</p> 
<hr> 
<h2 id="%E4%BA%8C.%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91">二.遍历二叉树</h2> 
<p> 二叉树的遍历有三种方式：</p> 
<blockquote> 
 <p><strong>1.前（先）序遍历：先遍历树的根节点，再遍历它的左子树，最后是右子树。</strong></p> 
 <p><strong>2.中序遍历：先遍历树的左子树，再遍历它的根节点，最后是右子树。</strong></p> 
 <p><strong>3.后序遍历：先遍历树的左子树，再遍历它的右子树，最后是根节点。</strong></p> 
</blockquote> 
<p><img alt="" height="299" src="https://images2.imgbox.com/f8/b0/0rYpJMpO_o.png" width="318"></p> 
<p>我们以这棵树为例：</p> 
<p>前序遍历即为：<strong>1 2 3 4 5 6</strong>。</p> 
<p>但是这样写其实并不合理，因为我们是用<span style="color:#fe2c24;"><strong>链表</strong></span>来写二叉树的结构的，所以<span style="color:#fe2c24;"><strong>对于节点2来说，它并不是没有右子树，而是右子树是空树</strong></span>。</p> 
<p>同样的，<strong><span style="background-color:#ffd900;">3、5、6同样可以作为一颗树，不过它们的左右子树都是空树罢了</span></strong>。</p> 
<p>所以合理的遍历方式应该把空树也带上，我们这里用N表示，于是：</p> 
<p>前序遍历：<strong>1    2    3    N    N    N    4    5    N    N    6    N    N</strong>，如果用图形来表示，如下：</p> 
<p><img alt="" height="139" src="https://images2.imgbox.com/69/d3/AaIiUitz_o.png" width="623"></p> 
<p>每一个方框都可以看做是一个新的树，从左到右依次为：<span style="color:#fe2c24;"><strong>根，左，右</strong></span>。如此，我们便也能写出中序遍历和后序遍历：</p> 
<p>中序遍历：<strong>N    3    N    2    N    1    N    5    N    4    N    6    N</strong>，图形如下：</p> 
<p><img alt="" height="204" src="https://images2.imgbox.com/e9/ff/l44V61NM_o.png" width="886"></p> 
<p>后序遍历：<strong>N    N    3    N    2    N    N    5    N    N    6    4    1</strong>，图形如下：</p> 
<p><img alt="" height="168" src="https://images2.imgbox.com/26/e2/ZgFDY4Yj_o.png" width="886"></p> 
<p>了解了二叉树的基本架构之后，我们就开始来实现二叉树的各个功能啦。</p> 
<hr> 
<h2 id="%E4%B8%89.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0">三.二叉树的实现</h2> 
<h3 id="1.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89">1.二叉树的定义</h3> 
<pre><code class="language-cpp">typedef int BTDataType;

typedef struct TreeNode
{
	BTDataType data;
	struct TreeNode* left;
	struct TreeNode* right;
}TreeNode;</code></pre> 
<p>二叉树的定义并不难写，需要<span style="color:#fe2c24;"><strong>数据变量，以及指向左子树和右子树的两个指针</strong></span>。</p> 
<hr> 
<h3 id="2.%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9">2.创建二叉树节点</h3> 
<pre><code class="language-cpp">//创建树节点
TreeNode* CreateTreeNode(TreeNode* root,BTDataType x)
{
	TreeNode* tmp = (TreeNode*)malloc(sizeof(TreeNode));
	if (tmp == NULL)
	{
		perror("CreateTree-&gt;malloc");
		exit(-1);
	}
	root = tmp;
	root-&gt;data = x;
	root-&gt;left = NULL;
	root-&gt;right = NULL;
	return root;
}</code></pre> 
<p>二叉树节点的创建也不难，起初我们需要<span style="color:#fe2c24;"><strong>将两个指针都指向NULL</strong></span>。</p> 
<p>为了方便下文对<span style="color:#fe2c24;"><strong>二叉树的操作</strong></span>进行讲解，我们手动创建一颗如下的二叉树：</p> 
<p><img alt="" height="299" src="https://images2.imgbox.com/3f/ce/h09J2nIb_o.png" width="318"></p> 
<pre><code class="language-cpp">	TreeNode root;
	TreeNode* node1 = CreateTreeNode(&amp;root, 1);
	TreeNode* node2 = CreateTreeNode(&amp;root, 2);
	TreeNode* node3 = CreateTreeNode(&amp;root, 3);
	TreeNode* node4 = CreateTreeNode(&amp;root, 4);
	TreeNode* node5 = CreateTreeNode(&amp;root, 5);
	TreeNode* node6 = CreateTreeNode(&amp;root, 6);
	node1-&gt;left = node2;
	node1-&gt;right = node4;
	node2-&gt;left = node3;
	node4-&gt;left = node5;
	node4-&gt;right = node6;</code></pre> 
<hr> 
<h2 id="%E5%9B%9B.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C">四.二叉树的操作</h2> 
<p>二叉树的操作，基本上都和递归紧密相连。</p> 
<h3 id="1.%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86">1.先序遍历</h3> 
<p>先序遍历，也就是按照：<span style="color:#fe2c24;"><strong>根，左子树，右子树</strong></span>的顺序遍历，下面我直接给出代码：</p> 
<pre><code class="language-cpp">//先序遍历
void PrevOrder(TreeNode* root)
{
	if (root == NULL)
	{
		printf("N ");
		return;
	}
	printf("%d ", root-&gt;data);//根
	PrevOrder(root-&gt;left);//左子树
	PrevOrder(root-&gt;right);//右子树
}</code></pre> 
<p>没错，代码就是这么简单。</p> 
<p>想要按照我们上边所讲解的遍历方法进行二叉树的遍历，<span style="color:#fe2c24;"><strong>递归是最好的选择</strong></span>。</p> 
<p>我们来分析以下：</p> 
<p>首先，<strong>如果我们遇到叶节点，那么他就没有<span style="color:#fe2c24;">左右子树</span>，这时候我们再去递归调用它的左右子树时，就打印一个<span style="color:#fe2c24;">N</span>，证明我们遇到了<span style="color:#fe2c24;">空节点</span></strong>。</p> 
<p>随后，我们按照<span style="color:#fe2c24;"><strong>根，左，右</strong></span>的顺序，<strong><span style="background-color:#ffd900;">先打印根节点的数据，再先后去递归打印它的左右子树的节点数据</span></strong>。</p> 
<p>递归确实是一个难以理解的重点知识，但是<span style="color:#fe2c24;"><strong>博主却有一个小妙招</strong></span>，可以分享给大家：</p> 
<p>我们继续来看上边的代码，如果我去掉递归调用，那么我剩下的代码是：</p> 
<pre><code class="language-cpp">void PrevOrder(TreeNode* root)
{
	if (root == NULL)
	{
		printf("N ");
		return;
	}
	printf("%d ", root-&gt;data);//根
}</code></pre> 
<p>这样就<span style="color:#fe2c24;"><strong>可以看做是一个打印节点数据的代码</strong></span>。</p> 
<p>那么我在<strong><span style="background-color:#ffd900;">打印完根节点的数据之后，想打印它左子树的根节点数据，就把它左子树的地址传给这个函数</span></strong>，也就是：</p> 
<blockquote> 
 <p><strong>    PrevOrder(root-&gt;left);//左子树</strong></p> 
</blockquote> 
<p><strong>打印完左子树，再去打印右子树</strong>，于是就把右子树的地址传过去：</p> 
<blockquote> 
 <p><strong>    PrevOrder(root-&gt;right);//右子树</strong></p> 
</blockquote> 
<p> 要记住的是，每当我们用递归调用时，都是<span style="color:#fe2c24;"><strong>一层一层的套用该函数</strong></span>，<strong><span style="background-color:#ffd900;">直到遇到某个限制条件，到达最后一层时，才会终止当前的函数，并返回上一层函数，直到返回至第一层为止</span></strong>。</p> 
<p>来看结果：</p> 
<p><img alt="" height="102" src="https://images2.imgbox.com/70/86/NUYczNDG_o.png" width="394"></p> 
<p>而中序，后序遍历，就和上边是大差不差，只需要改变递归调用函数的顺序。</p> 
<hr> 
<h3 id="2.%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">2.中序遍历</h3> 
<p>中序遍历的顺序为：<span style="color:#fe2c24;"><strong>左子树，根，右子树</strong></span>，所以：</p> 
<pre><code class="language-cpp">//中序遍历
void InOrder(TreeNode* root)
{
	if (root == NULL)
	{
		printf("N ");
		return;
	}
	InOrder(root-&gt;left);//左子树
	printf("%d ", root-&gt;data);//根
	InOrder(root-&gt;right);//右子树
}</code></pre> 
<p><strong>先递归调用左子树，再打印根节点数据，再递归调用右子树</strong>。</p> 
<p>结果如下：</p> 
<p><img alt="" height="94" src="https://images2.imgbox.com/3d/f8/ZeHtk7um_o.png" width="331"></p> 
<hr> 
<h3 id="3.%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86">3.后序遍历</h3> 
<p>后序遍历的顺序为：<strong>左子树，右子树，根</strong>，所以：</p> 
<pre><code class="language-cpp">//后序遍历
void PostOrder(TreeNode* root)
{
	if (root == NULL)
	{
		printf("N ");
		return;
	}
	PostOrder(root-&gt;left);//左子树
	PostOrder(root-&gt;right);//右子树
	printf("%d ", root-&gt;data);//根
}</code></pre> 
<p><strong>在左右子树全部都递归调用之后，再打印根节点数据</strong>。</p> 
<p>结果如下：</p> 
<p><img alt="" height="99" src="https://images2.imgbox.com/c9/e9/8MH1f8AD_o.png" width="348"></p> 
<hr> 
<h3 id="4.%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0" style="background-color:transparent;">4.节点个数</h3> 
<p>二叉树的节点个数该怎么统计呢？？？</p> 
<p>有小伙伴会说，这简单啊，<strong>用个计数器，遍历的时候顺便计数不就好啦</strong>。</p> 
<p>这确实是一种方法，但是却不够简便，我们不妨来思考思考有没有更简单一点的方法：</p> 
<p>二叉树的节点个数，是不是就等于<span style="color:#fe2c24;"><strong>它的根节点，加上它的左子树，右子树的节点个数</strong></span>？</p> 
<p>那我就能得出下边的代码：</p> 
<pre><code class="language-cpp">//节点个数
int TreeSize(TreeNode* root)
{
	if (root == NULL)
	{
		return 0;
	}
	return TreeSize(root-&gt;left) + TreeSize(root-&gt;right) + 1;
}</code></pre> 
<p>结果如下：</p> 
<p> <img alt="" height="111" src="https://images2.imgbox.com/4c/da/m3PXpoIs_o.png" width="381"></p> 
<p>简不简单就问你？有没有问题？</p> 
<p><strong><span style="background-color:#ffd900;">如果根节点为空，就说明是空树，节点个数为0，返回0</span></strong>；</p> 
<p><strong><span style="background-color:#ffd900;">如果不是空树，那我就返回左子树的节点个数+右子树的节点个数 + 根节点（也就是1）</span></strong>。</p> 
<p>怎么样？有没有被递归给圈粉？<span style="color:#fe2c24;"><strong>递归是如此的奇妙</strong></span>。 </p> 
<hr> 
<h3 id="%E9%80%92%E5%BD%92%E5%88%86%E6%9E%90">递归分析</h3> 
<p>递归问题的基本思想就是<span style="color:#fe2c24;"><strong>把大型的，复杂的问题拆解成多个子问题，简单的问题</strong></span>。</p> 
<p>以上述代码为例，我们要求出一个二叉树的节点个数，而<span style="color:#fe2c24;"><strong>这棵二叉树又可以拆解为一个一个的子二叉树</strong></span>，<strong><span style="background-color:#ffd900;">我们将每个子树的节点个数统计出来，在整合起来，就得出了总的节点个数</span></strong>。 </p> 
<p>当我们面对递归问题时，要做的就是找到递归的<span style="color:#fe2c24;"><strong>两个要点</strong></span>：</p> 
<blockquote> 
 <ol><li><strong>终止条件</strong></li><li><strong>递归部分</strong></li></ol> 
</blockquote> 
<p>拿上述代码为例，终止条件就是：</p> 
<blockquote> 
 <p><strong>    if (root == NULL)<br>     {<!-- --><br>         return 0;<br>     }</strong></p> 
</blockquote> 
<p>而递归部分就是：</p> 
<blockquote> 
 <p><strong>    return TreeSize(root-&gt;left) + TreeSize(root-&gt;right) + 1;</strong></p> 
</blockquote> 
<hr> 
<h3 id="5.%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0" style="background-color:transparent;">5.叶节点数</h3> 
<p>叶节点也就是左右子树都为空的节点，那么叶节点个数该怎么求呢？</p> 
<p>很显然，与上边的想法类似，也就是<span style="color:#fe2c24;"><strong>左子树的叶节点个数+右子树的叶节点个数</strong></span>。</p> 
<p>如此一来，我们便能写出代码：</p> 
<pre><code class="language-cpp">//叶节点个数
int TreeLeafSize(TreeNode* root)
{
	if (root == NULL)
	{
		return 0;
	}
	if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)
	{
		return 1;
	}
	return TreeLeafSize(root-&gt;left) + TreeLeafSize(root-&gt;right);
}</code></pre> 
<p><strong>当为空树时，自然没有叶节点，返回0</strong>；</p> 
<p><strong>当根节点存在，且它的左右子树都为空时，说明它是叶节点，返回1</strong>；</p> 
<p>上述两种都不满足，则<span style="color:#fe2c24;"><strong>返回左右子树叶节点之和，实现递归</strong></span>。</p> 
<p>结果如下：</p> 
<p><img alt="" height="96" src="https://images2.imgbox.com/38/16/6Kqbuh6W_o.png" width="356"></p> 
<hr> 
<h3 id="6.%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6" style="background-color:transparent;">6.树的高度</h3> 
<p>二叉树的高度，也可以叫做<strong>深度、层数</strong>。</p> 
<p>2那么该如何求出二叉树的高度呢？？？</p> 
<p>我们仍然利用上边的思想，<span style="color:#fe2c24;"><strong>把根和左右子树独立开</strong></span>，不难得出，求树的高度就可以变成<span style="color:#fe2c24;"><strong>求左右两棵子树的高度较大的那一个再 + 1</strong></span>。</p> 
<pre><code class="language-cpp">//树高度
int TreeHight(TreeNode* root)
{
	if (root == NULL)
	{
		return 0;
	}
	int lefthight = TreeHight(root-&gt;left);
	int righthight = TreeHight(root-&gt;right);
	return lefthight &gt; righthight ? lefthight + 1 : righthight + 1;
}</code></pre> 
<p>首先仍然是要<strong>判断是否为空树</strong>。</p> 
<p>然后我们要<strong>把左右子树的高度定义出来</strong>。</p> 
<p>最后我们使用<span style="color:#fe2c24;"><strong>三目运算符</strong></span>来实现比较左右子树的高度并进行返回。</p> 
<p>结果如下：</p> 
<p><img alt="" height="96" src="https://images2.imgbox.com/d1/39/Aa6waCrm_o.png" width="327"></p> 
<hr> 
<h3 id="7.%E7%AC%ACk%E5%B1%82%E8%8A%82%E7%82%B9%E6%95%B0" style="background-color:transparent;">7.第k层节点数</h3> 
<p>二叉树还有一种操作，那就是<strong>求其某一层的节点数</strong>，这该怎么求呢？？？</p> 
<p>有一种写法是，<strong>分别求二叉树的前k层和前k-1层，再相减，但是这显然会非常麻烦</strong>。</p> 
<p>所以，我们仍然可以采用把我们上边的<strong>递归思想</strong>：</p> 
<p>求二叉树的第k层，可以等价为是<span style="color:#fe2c24;"><strong>求其左右子树的第k-1层节点数之和</strong></span>。</p> 
<pre><code class="language-cpp">//第k层的节点个数
int LeveKSize(TreeNode* root,int k)
{
	assert(k &gt; 0);
	if (root == NULL)
	{
		return 0;
	}
	if (k == 1)
	{
		return 1;
	}
	return LeveKSize(root-&gt;left, k - 1) + LeveKSize(root-&gt;right, k - 1);
}</code></pre> 
<p><strong><span style="background-color:#ffd900;">当k = 1时，即第一层，只有一个根节点，返回1</span></strong>，反之就返回其<span style="color:#fe2c24;"><strong>左右子树的第k-1层节点数之和</strong></span>。</p> 
<p>来看结果：</p> 
<p>首先是第三层，有3个节点；</p> 
<p><img alt="" height="138" src="https://images2.imgbox.com/02/96/wW1sjtTN_o.png" width="544"></p> 
<p> 然后是第四层，没有节点：</p> 
<p><img alt="" height="144" src="https://images2.imgbox.com/b0/45/GznwLax4_o.png" width="543"></p> 
<hr> 
<h3 id="8.%E6%9F%A5%E6%89%BE%E6%8C%87%E5%AE%9A%E5%80%BC%E8%8A%82%E7%82%B9">8.查找指定值节点</h3> 
<p>对于二叉树，同样有<strong><span style="background-color:#ffd900;">查找给定的值的节点的操作，并返回它的地址</span></strong>，这又该如何实现呢？？？</p> 
<p>很明显，<span style="color:#fe2c24;"><strong>如果这个值不是根节点，就要让左右子树去分别查找</strong></span>：</p> 
<pre><code class="language-cpp">// 二叉树查找值为x的节点
TreeNode* BinaryTreeFind(TreeNode* root, BTDataType x)
{
	if (root == NULL)
		return NULL;

	if (root-&gt;data == x)
		return root;

	TreeNode* ret = BinaryTreeFind(root-&gt;left, x);
	if (ret)
		return ret;

	return BinaryTreeFind(root-&gt;right, x);
}</code></pre> 
<p>首先<span style="color:#fe2c24;"><strong>判断空树</strong></span>。</p> 
<p>然后<strong>判断根节点的值是否为要查找的数据</strong>，<strong><span style="background-color:#ffd900;">是就直接返回根节点地址，反之就开始查找左右子树</span></strong>。</p> 
<p>我们<strong>先查找左子树</strong>，这里要注意一点，<span style="color:#fe2c24;"><strong>要临时定义一个指针变量来判断左子树中是否能找到节点</strong></span>。</p> 
<p><strong><span style="background-color:#ffd900;">如果存在，就会返回其地址，不存在，ret就为空，这样我们就接着去查找右子树</span></strong>。</p> 
<hr> 
<h3></h3> 
<h3 id="9.%E9%94%80%E6%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91">9.销毁二叉树</h3> 
<p>二叉树该如何销毁呢？？？</p> 
<p>是<strong>从根节点开始一个一个遍历销毁吗</strong>？？？但是这样<strong><span style="background-color:#ffd900;">每销毁一个根节点，我们都要先去记录它的两个左右子树的地址，未免有点太麻烦了些</span></strong>。</p> 
<p>既然不能从上到下，那我们就<span style="color:#fe2c24;"><strong>从下到上</strong></span>呗，不要忘了，还有<span style="color:#fe2c24;"><strong>后序遍历</strong></span>呢。</p> 
<pre><code class="language-cpp">//销毁树
void TreeDestroy(TreeNode* root)
{
	if (root == NULL)
		return;
	TreeDestroy(root-&gt;left);
	TreeDestroy(root-&gt;right);
	free(root);
}</code></pre> 
<hr> 
<h2 id="%E5%9B%9B.%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA" style="background-color:transparent;">四.完整代码展示</h2> 
<h3 id="1.BinaryTree.h">1.BinaryTree.h</h3> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;assert.h&gt;

typedef int BTDataType;

typedef struct TreeNode
{
	BTDataType data;
	struct TreeNode* left;
	struct TreeNode* right;
}TreeNode;


//创建树
TreeNode* CreateTreeNode(TreeNode* root,BTDataType x);
//销毁树
void TreeDestroy(TreeNode* root);
//先序遍历
void PrevOrder(TreeNode* root);
//中序遍历
void InOrder(TreeNode* root);
//后序遍历
void PostOrder(TreeNode* root);
// 层序遍历
void LevelOrder(TreeNode* root);
//节点个数
int TreeSize(TreeNode* root);
//叶节点个数
int TreeLeafSize(TreeNode* root);
//树高度
int TreeHight(TreeNode* root);
//第k层的节点个数
int LeveKSize(TreeNode* root,int k);
// 二叉树查找值为x的节点
TreeNode* BinaryTreeFind(TreeNode* root, BTDataType x);</code></pre> 
<hr> 
<h3 id="2.BinaryTree.c">2.BinaryTree.c</h3> 
<pre><code class="language-cpp">#include "BinaryTree.h"

//创建树节点
TreeNode* CreateTreeNode(TreeNode* root,BTDataType x)
{
	TreeNode* tmp = (TreeNode*)malloc(sizeof(TreeNode));
	if (tmp == NULL)
	{
		perror("CreateTree-&gt;malloc");
		exit(-1);
	}
	root = tmp;
	root-&gt;data = x;	
	root-&gt;left = NULL;
	root-&gt;right = NULL;
	return root;
}
//销毁树
void TreeDestroy(TreeNode* root)
{
	if (root == NULL)
		return;
	TreeDestroy(root-&gt;left);
	TreeDestroy(root-&gt;right);
	free(root);
}
//先序遍历
void PrevOrder(TreeNode* root)
{
	if (root == NULL)
	{
		printf("N ");
		return;
	}
	printf("%d ", root-&gt;data);//根
	PrevOrder(root-&gt;left);//左子树
	PrevOrder(root-&gt;right);//右子树
}
//中序遍历
void InOrder(TreeNode* root)
{
	if (root == NULL)
	{
		printf("N ");
		return;
	}
	InOrder(root-&gt;left);//左子树
	printf("%d ", root-&gt;data);//根
	InOrder(root-&gt;right);//右子树
}
//后序遍历
void PostOrder(TreeNode* root)
{
	if (root == NULL)
	{
		printf("N ");
		return;
	}
	PostOrder(root-&gt;left);//左子树
	PostOrder(root-&gt;right);//右子树
	printf("%d ", root-&gt;data);//根
}
//节点个数
int TreeSize(TreeNode* root)
{
	if (root == NULL)
	{
		return 0;
	}
	return TreeSize(root-&gt;left) + TreeSize(root-&gt;right) + 1;
}
//叶节点个数
int TreeLeafSize(TreeNode* root)
{
	if (root == NULL)
	{
		return 0;
	}
	if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)
	{
		return 1;
	}
	return TreeLeafSize(root-&gt;left) + TreeLeafSize(root-&gt;right);
}
//树高度
int TreeHight(TreeNode* root)
{
	if (root == NULL)
	{
		return 0;
	}
	int lefthight = TreeHight(root-&gt;left);
	int righthight = TreeHight(root-&gt;right);
	return lefthight &gt; righthight ? lefthight + 1 : righthight + 1;
}
//第k层的节点个数
int LeveKSize(TreeNode* root,int k)
{
	assert(k &gt; 0);
	if (root == NULL)
	{
		return 0;
	}
	if (k == 1)
	{
		return 1;
	}
	return LeveKSize(root-&gt;left, k - 1) + LeveKSize(root-&gt;right, k - 1);
}
// 二叉树查找值为x的节点
TreeNode* BinaryTreeFind(TreeNode* root, BTDataType x)
{
	if (root == NULL)
		return NULL;

	if (root-&gt;data == x)
		return root;

	TreeNode* ret = BinaryTreeFind(root-&gt;left, x);
	if (ret)
		return ret;

	return BinaryTreeFind(root-&gt;right, x);
}</code></pre> 
<hr> 
<h3 id="3.test.c">3.test.c</h3> 
<pre><code class="language-cpp">#include "BinaryTree.h"

int main()
{
    TreeNode root;
    TreeNode* node1 = CreateTreeNode(&amp;root, 1);
    TreeNode* node2 = CreateTreeNode(&amp;root, 2);
    TreeNode* node3 = CreateTreeNode(&amp;root, 3);
    TreeNode* node4 = CreateTreeNode(&amp;root, 4);
    TreeNode* node5 = CreateTreeNode(&amp;root, 5);
    TreeNode* node6 = CreateTreeNode(&amp;root, 6);
    node1-&gt;left = node2;
    node1-&gt;right = node4;
    node2-&gt;left = node3;
    node4-&gt;left = node5;
    node4-&gt;right = node6;
    //PrevOrder(node1);
    //printf("\n");
    //InOrder(node1);
    //printf("\n");
    //PostOrder(node1);
    //printf("\n");
    //int Treesize = TreeSize(node1);
    //printf("Treesize = %d\n", Treesize);
    //int TreeLeafsize = TreeLeafSize(node1);
    //printf("TreeLeafsize = %d\n", TreeLeafsize);
    //int Treehight = TreeHight(node1);
    //printf("Treehight = %d\n", Treehight);
    int LeveKsize = LeveKSize(node1, 4);
    printf("LeveKsize = %d\n", LeveKsize);
    TreeDestroy(node1);
    node1 = NULL;
    return 0;
}</code></pre> 
<hr> 
<h2 id="%E4%BA%94.%E6%80%BB%E7%BB%93">五.总结</h2> 
<p>二叉树的基本知识和操作到这里就结束啦，二叉树与递归关系颇深。</p> 
<p>虽然博主对于递归讲解的也不是那么清晰透彻，但是递归的知识真的是要靠自己一步一步的去理解，去深入。</p> 
<p>希望小伙伴们都可以努力去拿下递归，这是每一个优秀程序员都必须要克服的！！！</p> 
<p>最后还是求一求<span style="color:#956fe7;"><strong>一键三连</strong></span>！！！</p> 
<p>我们下期再见啦！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/aa64bba19968cbcb82bd51956c85b652/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">旅行商问题（枚举，回溯，动态规划，贪心，分支界限）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/852e489f321fa95fd3e5ce2d965c5763/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">学生成绩管理系统（Java）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>