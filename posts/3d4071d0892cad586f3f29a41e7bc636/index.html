<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【SpringBoot】单元测试实战演示及心得分享 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/3d4071d0892cad586f3f29a41e7bc636/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【SpringBoot】单元测试实战演示及心得分享">
  <meta property="og:description" content="目录
1.指定测试标准
2.设计测试用例
3.测试集示例
4.跑测试集
1.指定测试标准 单元测试会用到mock和junit的内容，作者前文有详解，可移步：
Spring Boot单元测试-CSDN博客
mockito的详细使用-CSDN博客
1.1.测哪一层？
以当前后端标准的MVC分层来说，后端代码分为controller、service、dao三层。首先我们要先确定这三层里面去测试哪一层？单元测试的核心目的是什么：
覆盖业务代码
按标准的来说的话controller层是系统对外暴露的API，这一层级只负责做一些请求和参数的处理；service层用来编写具体的业务逻辑；dao层负责与数据库进行交互。所以我们应该测service层。
1.2.如何判断测试是否通过？
测试的输出结果和我们期望的输出结果是一致的，测试就通过了。怎么判断喃？
用Assert断言
Assert不要到处去用，在测试用例的最后用它来判断一下输出结果是不是期望值即可。
1.3.mock掉哪些内容？
mock我们主要拿来干两件事儿：
mock掉对数据库的操作，避免引起数据的改动，也就是说要mock掉dao层的方法
mock掉没办法达到的地方，比如有些地方不影响代码逻辑，但是在测试的时候不好造出来，这些不可达的地方可以mock掉。
mock我们要mock两种情况：
mock返回值
mock行为
mock返回值，比如：
Train train = new Train(); String id = UUID.randomUUID() &#43; &#34;&#34;; train.setKeyId(id); when(trainDao.getDetail(any(Train.class))).thenReturn(train); mock行为有些时候是主动的，我们想去定义实体的具体行为，有时候是被动的，比如要mock的dao方法没有返回值该，我们就只能通过去mock行为来使得它不去操作数据库，反正核心就是不让它去操作数据库。
比如以下方法：
void trainDetailDao.updateList(XXX) 用doAnswer去mock它的响应：
@Test public void modifyTrainDetails(){ TrainDetailList trainDetails = new TrainDetailList(); TrainDetail trainDetail = new TrainDetail(); trainDetail.setKeyId(UUID.randomUUID()&#43;&#34;&#34;); trainDetails.add(trainDetail); doAnswer(invocation -&gt; { List&lt;TrainDetail&gt; trainDetailList = (List&lt;TrainDetail&gt;) invocation.getArguments()[0]; Assert.assertEquals(trainDetails.getItems(), trainDetailList); return trainDetails; }).">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-22T08:16:27+08:00">
    <meta property="article:modified_time" content="2024-05-22T08:16:27+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【SpringBoot】单元测试实战演示及心得分享</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="90" src="https://images2.imgbox.com/52/01/vjjJis00_o.png" width="546"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E6%8C%87%E5%AE%9A%E6%B5%8B%E8%AF%95%E6%A0%87%E5%87%86-toc" style="margin-left:0px;"><a href="#1.%E6%8C%87%E5%AE%9A%E6%B5%8B%E8%AF%95%E6%A0%87%E5%87%86" rel="nofollow">1.指定测试标准</a></p> 
<p id="2.%E8%AE%BE%E8%AE%A1%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B-toc" style="margin-left:0px;"><a href="#2.%E8%AE%BE%E8%AE%A1%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B" rel="nofollow">2.设计测试用例</a></p> 
<p id="3.%E6%B5%8B%E8%AF%95%E9%9B%86%E7%A4%BA%E4%BE%8B-toc" style="margin-left:0px;"><a href="#3.%E6%B5%8B%E8%AF%95%E9%9B%86%E7%A4%BA%E4%BE%8B" rel="nofollow">3.测试集示例</a></p> 
<p id="4.%E8%B7%91%E6%B5%8B%E8%AF%95%E9%9B%86-toc" style="margin-left:0px;"><a href="#4.%E8%B7%91%E6%B5%8B%E8%AF%95%E9%9B%86" rel="nofollow">4.跑测试集</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1.%E6%8C%87%E5%AE%9A%E6%B5%8B%E8%AF%95%E6%A0%87%E5%87%86">1.指定测试标准</h2> 
<p>单元测试会用到mock和junit的内容，作者前文有详解，可移步：</p> 
<p><a href="https://blog.csdn.net/Joker_ZJN/article/details/134542387?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171630763616800222829801%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=171630763616800222829801&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-134542387-null-null.nonecase&amp;utm_term=%E5%8D%95%E5%85%83&amp;spm=1018.2226.3001.4450" title="Spring Boot单元测试-CSDN博客">Spring Boot单元测试-CSDN博客</a></p> 
<p><a href="https://bugman.blog.csdn.net/article/details/128315637" rel="nofollow" title="mockito的详细使用-CSDN博客">mockito的详细使用-CSDN博客</a></p> 
<p><strong>1.1.测哪一层？</strong></p> 
<p>以当前后端标准的MVC分层来说，后端代码分为controller、service、dao三层。首先我们要先确定这三层里面去测试哪一层？单元测试的核心目的是什么：</p> 
<p>覆盖业务代码</p> 
<p>按标准的来说的话controller层是系统对外暴露的API，这一层级只负责做一些请求和参数的处理；service层用来编写具体的业务逻辑；dao层负责与数据库进行交互。所以我们应该测service层。</p> 
<p><strong>1.2.如何判断测试是否通过？</strong></p> 
<p>测试的输出结果和我们期望的输出结果是一致的，测试就通过了。怎么判断喃？</p> 
<p>用Assert断言</p> 
<p>Assert不要到处去用，在测试用例的最后用它来判断一下输出结果是不是期望值即可。</p> 
<p><strong>1.3.mock掉哪些内容？</strong></p> 
<p>mock我们主要拿来干两件事儿：</p> 
<ul><li> <p>mock掉对数据库的操作，避免引起数据的改动，也就是说要mock掉dao层的方法</p> </li><li> <p>mock掉没办法达到的地方，比如有些地方不影响代码逻辑，但是在测试的时候不好造出来，这些不可达的地方可以mock掉。</p> </li></ul> 
<p>mock我们要mock两种情况：</p> 
<ul><li> <p>mock返回值</p> </li><li> <p>mock行为</p> </li></ul> 
<p>mock返回值，比如：</p> 
<pre><code class="language-java">Train train = new Train();
String id = UUID.randomUUID() + "";
train.setKeyId(id);
when(trainDao.getDetail(any(Train.class))).thenReturn(train);</code></pre> 
<p>mock行为有些时候是主动的，我们想去定义实体的具体行为，有时候是被动的，比如要mock的dao方法没有返回值该，我们就只能通过去mock行为来使得它不去操作数据库，反正核心就是不让它去操作数据库。</p> 
<p>比如以下方法：</p> 
<pre><code class="language-java">void trainDetailDao.updateList(XXX)</code></pre> 
<p>用doAnswer去mock它的响应：</p> 
<pre><code class="language-java">@Test
public void modifyTrainDetails(){
    TrainDetailList trainDetails = new TrainDetailList();
    TrainDetail trainDetail = new TrainDetail();
    trainDetail.setKeyId(UUID.randomUUID()+"");
    trainDetails.add(trainDetail);
    doAnswer(invocation -&gt; {
        List&lt;TrainDetail&gt; trainDetailList = (List&lt;TrainDetail&gt;) invocation.getArguments()[0];
        Assert.assertEquals(trainDetails.getItems(), trainDetailList);
        return trainDetails;
    }).when(trainDetailDao).updateList(any());
    trainDetailBaseSvr.modifyTrainDetails("",trainDetails);
}</code></pre> 
<h2 id="2.%E8%AE%BE%E8%AE%A1%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B">2.设计测试用例</h2> 
<p>一个接口只需要一个测试用例吗？有时候是不够的。</p> 
<p>衡量对一个接口的单元测试是不是到位了，核心指标是看它的分支覆盖率。代码种的一个方法里面有些时候会存在一些选择分支（带判断性质的语句），我们设计测试用例的时候要考虑覆盖掉所有分支。</p> 
<p>最好的办法就是画个流程图，设计测试用例的时候要覆盖掉所有流程分支，以下以用户买猪肉为一个例子：</p> 
<p>灰色的节点就是要mock掉的</p> 
<p class="img-center"><img alt="图片" height="465" src="https://images2.imgbox.com/32/a5/rUS6Lu3j_o.png" width="1080"></p> 
<p>细化成流程图，流程图的所有出口就是要覆盖的分支，有几个出口，就应该有几个用例，有几个测试方法：</p> 
<p><img alt="" height="631" src="https://images2.imgbox.com/db/e7/ghf01RoQ_o.png" width="1080"></p> 
<h2 id="3.%E6%B5%8B%E8%AF%95%E9%9B%86%E7%A4%BA%E4%BE%8B">3.测试集示例</h2> 
<p>以下是作者在工作中编写的一个测试集用例，演示了一个简单的对增删改查方法的覆盖。里面演示了如何覆盖有返回值的方法和没有返回值的方法。</p> 
<p>这里有几个技巧分享一下：</p> 
<p>首先是要mock掉dao层的话，我们就要把service里面依赖的dao换成mock出来的dao，这里需要用反射的方式强行访问到service里面的dao，然后把它替换掉。其次mock掉dao层之后直接new service就行，完全不需要用到自动注入，也就是不需要用到IOC，也就不需要用到@RunWith(XXX.class) @SpringBootTest(classes = XXX.class)之类的注解来启动SpringBoot了。这样跑测试用例的时候，省去了启动时间，会快很多。</p> 
<pre><code class="language-java">public class ExaminationBaseSvrTest extends PropertyControllerBase {
    IExaminationBaseSvr examinationBaseSvr;

    ExaminationTargetService examinationTargetService;

    private ExaminationDao examinationDao;

    private IDataDicItemBaseMgeSvr dataDicItemBaseMgeSvr;

    private DataDictionaryItemDao dataDictionaryItemDao;

    @Before
    public void setUp() throws Exception{
        examinationBaseSvr = new ExaminationBaseSvr();
        Field field = ExaminationBaseSvr.class.getDeclaredField("examinationDao");
        Field dataDicItemBaseMgeSvrField = ExaminationBaseSvr.class.getDeclaredField("dataDicItemBaseMgeSvr");
        Field dataDictionaryItemDaoField = DataDicItemBaseMgeSvr.class.getDeclaredField("dataDictionaryItemDao");
        field.setAccessible(true);
        dataDicItemBaseMgeSvrField.setAccessible(true);
        dataDictionaryItemDaoField.setAccessible(true);
        examinationDao = mock(ExaminationDao.class);
        dataDictionaryItemDao=mock(DataDictionaryItemDao.class);
        dataDicItemBaseMgeSvr=mock(DataDicItemBaseMgeSvr.class);
        field.set(examinationBaseSvr, examinationDao);
        dataDicItemBaseMgeSvrField.set(examinationBaseSvr,dataDicItemBaseMgeSvr);
        dataDictionaryItemDaoField.set(dataDicItemBaseMgeSvr,dataDictionaryItemDao);
    }

    @Test
    public void addExamination(){
        when(examinationDao.insert(any())).thenReturn(1);
        Examination examination = new Examination();
        examination.setKeyId(UUID.randomUUID()+"");
        Assert.assertEquals(examinationBaseSvr.addExamination("",examination),examination);
    }

    @Test
    public void addExcaminations(){
        ExaminationList examinations = new ExaminationList();
        Examination examination = new Examination();
        examination.setKeyId(UUID.randomUUID()+"");
        examinations.add(examination);
        doAnswer(invocation -&gt; {
            List&lt;Examination&gt; examinationList = (List&lt;Examination&gt;)invocation.getArguments()[0];
            Assert.assertEquals(examinationList,examinations.getItems());
            return 1;
        }).when(examinationDao).insertList(any());
        examinationBaseSvr.addExaminations("",examinations);
    }

    @Test
    public void modifyExamination(){
        when(examinationDao.update(any())).thenReturn(1);
        Examination examination = new Examination();
        examination.setKeyId(UUID.randomUUID()+"");
        Assert.assertEquals(examinationBaseSvr.modifyExamination("",examination),examination);
    }

    @Test
    public void modifyExaminations(){
        ExaminationList examinations = new ExaminationList();
        Examination examination = new Examination();
        examination.setKeyId(UUID.randomUUID()+"");
        examinations.add(examination);
        doAnswer(invocation -&gt; {
            List&lt;Examination&gt; examinationList = (List&lt;Examination&gt;)invocation.getArguments()[0];
            Assert.assertEquals(examinationList,examinations.getItems());
            return 1;
        }).when(examinationDao).updateList(examinations.getItems());
        examinationBaseSvr.modifyExaminations("",examinations);
    }

    @Test
    public void deleteExamination(){
        Examination examination = new Examination();
        examination.setKeyId(UUID.randomUUID()+"");
        when(examinationDao.update(any())).thenReturn(1);
        when(examinationDao.getDetail(any())).thenReturn(examination);
        Assert.assertEquals(examinationBaseSvr.deleteExamination("",examination.getKeyId(),false),1);
    }

    @Test
    public void deleteExaminations(){
        ExaminationList examinations = new ExaminationList();
        Examination examination = new Examination();
        examination.setKeyId(UUID.randomUUID()+"");
        examinations.add(examination);
        doAnswer(invocation -&gt; {
            List&lt;Examination&gt; examinationList = (List&lt;Examination&gt;)invocation.getArguments()[0];
            Assert.assertEquals(examinationList,examinations.getItems());
            return 1;
        }).when(examinationDao).updateList(any());
        examinationBaseSvr.deleteExamination("",examinations,false);
    }
}</code></pre> 
<h2 id="4.%E8%B7%91%E6%B5%8B%E8%AF%95%E9%9B%86">4.跑测试集</h2> 
<p>测试类写完之后，类名旁边有一个run的图标，点击即可跑整个测试集。其中有普通的run以及带覆盖率报告的run：</p> 
<p><img alt="" height="124" src="https://images2.imgbox.com/a4/c4/cN8H9py5_o.png" width="292"></p> 
<p>选择带覆盖率的run之后会显示覆盖率：</p> 
<p><img alt="" height="206" src="https://images2.imgbox.com/a9/95/l0zMWzb9_o.png" width="440"></p> 
<p>相看类里面具体是哪些代码段被覆盖了，可以在跑完测试集后进入具体的被测试类，代码行旁边会有颜色条，绿色表示被cover的内容：</p> 
<p><img alt="" height="206" src="https://images2.imgbox.com/5f/2d/rUVnEGej_o.png" width="440"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8c45238716773eeda91b5ec015b54602/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">“AIGC行业投资时机分析：评估当前市场发展阶段与未来需求趋势“</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/eab3633f6d25e1c4fa0613b7f2e1795a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java网络编程：Socket与NIO的高级应用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>