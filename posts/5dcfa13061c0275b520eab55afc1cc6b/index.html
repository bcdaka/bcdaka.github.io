<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构奇妙旅程之二叉平衡树进阶---AVL树 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/5dcfa13061c0275b520eab55afc1cc6b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构奇妙旅程之二叉平衡树进阶---AVL树">
  <meta property="og:description" content="꒰˃͈꒵˂͈꒱ write in front ꒰˃͈꒵˂͈꒱
ʕ̯•͡˔•̯᷅ʔ大家好，我是xiaoxie.希望你看完之后,有不足之处请多多谅解，让我们一起共同进步૮₍❀ᴗ͈ . ᴗ͈ აxiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客
本文由xiaoxieʕ̯•͡˔•̯᷅ʔ 原创 CSDN 如需转载还请通知˶⍤⃝˶
个人主页：xiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客
系列专栏：xiaoxie的JAVA系列专栏——CSDN博客●&#39;ᴗ&#39;σσணღ*
我的目标:&#34;团团等我💪( ◡̀_◡́ ҂)&#34; ( ⸝⸝⸝›ᴥ‹⸝⸝⸝ )欢迎各位→点赞👍 &#43; 收藏⭐️ &#43; 留言📝​&#43;关注（互三必回）!
一.AVL树的概念 二叉搜索树虽可以缩短查找的效率，但如果数据有序或接近有序二叉搜索树将退化为单支树，查找元素相当于在顺 序表中搜索元素，效率低下。因此，两位俄罗斯的数学家G.M.Adelson-Velskii和E.M.Landis在1962年 发明了一种 解决上述问题的方法：当向二叉搜索树中插入新结点后，如果能保证每个结点的左右子树高度之差的绝对值不超过 1(需要对树中的结点进行调整)，即可降低树的高度，从而减少平均搜索长度。 一棵AVL树或者是空树，或者是具有以下性质的二叉搜索树：
1.它的左右子树都是AVL树 2.左右子树高度之差(简称平衡因子)的绝对值不超过1(-1/0/1) 这里我们规定节点的左孩子的平衡因子为--,右孩子为&#43;&#43;;
如果一棵二叉搜索树是高度平衡的，它就是AVL树。如果它有n个结点，其高度可保持在 ，搜索时间复杂 度O(logN)。
二.AVL树节点的定义 public class AVLTree { public static class TreeNode { public int val; public TreeNode left; public TreeNode right; public int bf;// 当前节点的平衡因子=右子树高度-左子树的高度 public TreeNode parent; public TreeNode(int val) { this.val = val; } } public TreeNode root; 当前节点的平衡因子=右子树高度-左子树的高度。但是，不是每棵树，都必须有平衡因子，这只是其中的一种实现方式,并且这只是一种表示方式。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-12T15:56:57+08:00">
    <meta property="article:modified_time" content="2024-03-12T15:56:57+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构奇妙旅程之二叉平衡树进阶---AVL树</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>꒰˃͈꒵˂͈꒱ write in front ꒰˃͈꒵˂͈꒱<br> ʕ̯•͡˔•̯᷅ʔ大家好，我是xiaoxie.希望你看完之后,有不足之处请多多谅解，让我们一起共同进步૮₍❀ᴗ͈ . ᴗ͈ ა<a href="https://blog.csdn.net/xiaoxie8023?spm=1000.2115.3001.5343" title="xiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客">xiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客</a><br> 本文由xiaoxieʕ̯•͡˔•̯᷅ʔ 原创 CSDN 如需转载还请通知˶⍤⃝˶<br><a href="https://so.csdn.net/so/search?q=%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5&amp;spm=1001.2101.3001.7020" title="个人主页">个人主页</a>：<a href="https://blog.csdn.net/xiaoxie8023/article/details/134417887?spm=1001.2014.3001.5501" title="xiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客">xiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客</a><br> 系列专栏：<a href="https://blog.csdn.net/xiaoxie8023/category_12482318.html?spm=1001.2014.3001.5482" title="xiaoxie的JAVA系列专栏——CSDN博客●'ᴗ'σσணღ*">xiaoxie的JAVA系列专栏——CSDN博客●'ᴗ'σσணღ*</a><br><span style="color:#fe2c24;"><strong>我的目标:"团团等我💪( ◡̀_◡́ ҂)" </strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>( ⸝⸝⸝›ᴥ‹⸝⸝⸝ )欢迎各位→点赞👍 + 收藏⭐️ + 留言📝​+关注（互三必回）!</strong></span></p> 
</blockquote> 
<h2><img alt="" height="1080" src="https://images2.imgbox.com/bf/88/Y3IJKyM4_o.png" width="1080"> 一.AVL树的概念</h2> 
<p><a class="link-info" href="https://blog.csdn.net/xiaoxie8023/article/details/136489029?spm=1001.2014.3001.5501" title="二叉搜索树">二叉搜索树</a>虽可以缩短查找的效率，但如果数据有序或接近有序二叉搜索树将退化为单支树，查找元素相当于在顺 序表中搜索元素，效率低下。因此，两位俄罗斯的数学家G.M.Adelson-Velskii和E.M.Landis在1962年 发明了一种 解决上述问题的方法：当向二叉搜索树中插入新结点后，如果能保证每个结点的左右子树高度之差的绝对值不超过 1(需要对树中的结点进行调整)，即可降低树的高度，从而减少平均搜索长度。 一棵AVL树或者是空树，或者是具有以下性质的二叉搜索树：</p> 
<h3>1.它的左右子树都是AVL树</h3> 
<h3>2.左右子树高度之差(简称平衡因子)的绝对值不超过1(-1/0/1)</h3> 
<p>这里我们规定节点的左孩子的平衡因子为--,右孩子为++;</p> 
<p><img alt="" height="1096" src="https://images2.imgbox.com/75/2d/YZKChPGz_o.png" width="1200"></p> 
<p>如果一棵二叉搜索树是高度平衡的，它就是AVL树。如果它有n个结点，其高度可保持在 ，搜索时间复杂 度O(logN)。</p> 
<h2>二.AVL树节点的定义</h2> 
<pre><code class="language-java">public class AVLTree {
 public static class TreeNode {
     public int val; 
     public TreeNode left;
     public TreeNode right;
     public int bf;// 当前节点的平衡因子=右子树高度-左子树的高度
     public TreeNode parent;
     public TreeNode(int val) {
         this.val = val;
     }
 }
 public TreeNode root;
</code></pre> 
<p>当前节点的平衡因子=右子树高度-左子树的高度。但是，不是每棵树，都必须有平衡因子，这只是其中的一种实现方式,并且这只是一种表示方式。</p> 
<h2>三.AVL树节点的插入</h2> 
<p>AVL树就是在二叉搜索树的基础上引入了平衡因子，因此AVL树也可以看成是二叉搜索树。那么AVL树的插入过程可 以分为两步：</p> 
<h3>1.按照二叉搜索树的方式插入新节点</h3> 
<pre><code class="language-java"> TreeNode node = new TreeNode(val);
     if(root == null) {
         root = node;
         root.parent = null;
     }
     TreeNode parent = null;
     TreeNode cur = root;
     while (cur != null) {
         if(node.val &lt; cur.val) {
             parent = cur;
             cur = cur.left;
         } else if (node.val &gt; cur.val) {
             parent = cur;
             cur = cur.right;
         }else {
             System.out.println("节点值 " + val + " 已经存在于树中，不进行插入操作");
             return false;
         }
     }
     //cur == null
      //找到node是parent的左孩子还是右孩子
      if(node.val &lt; parent.val) {
          parent.left = node;
      }else {
          parent.right = node;
      }
      node.parent = parent;
      cur = node;</code></pre> 
<h3> 2.调整节点的平衡因子</h3> 
<p>新节点插入后，AVL树的平衡性可能会遭到破坏，此时就需要更新平衡因子，并检测是否破坏了AVL树 的平衡性.</p> 
<p>此时cur节点插入,parent节点的平衡因子就需要调整, 有以下两种情况</p> 
<p>1.Cur插入到Parent的左侧，只需给Parent的平衡因子-1即可</p> 
<p>2. 如果Cur插入到Parent的右侧，只需给Parent的平衡因子+1即可</p> 
<p>此时：Parent的平衡因子可能有三种情况：0，正负1， 正负2</p> 
<p>1.如果parent的平衡因子为0,那么就说明在插入前parent的平衡因子为正负1,插入后被调整成0，此时满足 AVL树的性质，插入成功</p> 
<p>2.如果Parent的平衡因子为正负1，说明插入前Parent的平衡因子一定为0，插入后被更新成正负1，此 时以Parent为根的子树的高度增加，需要继续向上更新</p> 
<p>3.如果Parent的平衡因子为正负2，则Parent的平衡因子违反平衡树的性质，需要对其进行旋转处理</p> 
<pre><code class="language-java">  while (parent != null) {
          //计算节点的平衡因子
          //如果是左孩子就--
          //右孩子就++;
          if(cur == parent.left) {
              parent.bf--;
          }else {
              parent.bf++;
          }
          //根据不同的平衡因子有不同的情况
          //1.如果平衡因子为0
          if(parent.bf == 0) {
              break;
          } else if (parent.bf == 1 || parent.bf == -1) {
              cur = parent;
              parent = cur.parent;
          }else {
              if(parent.bf == 2) { //就代表右树高,需要调整右树的高度,就是左单旋,或者右左双旋
                  if(cur.bf == 1) {
                      rotateLeft(parent);
                  }else {
                      rotateRL(parent);//cur.bf = -1
                  }
              }else {//parent.bf == -2//就代表左树高,需要调整左树的高度,就是左单旋,或者左右双旋
                  if(cur.bf == 1) {
                      rotateLR(parent);
                  }else {//cur.bf == -1
                      rotateRight(parent);
                  }
              }
          }</code></pre> 
<h2> 四.AVL树的旋转(重点)</h2> 
<p>如果在一棵原本是平衡的AVL树中插入一个新节点，可能造成不平衡，此时必须调整树的结构，使之平衡化。根据 节点插入位置的不同，AVL树的旋转分为四种：</p> 
<h3>1.新节点插入较高左子树的左侧---右单旋</h3> 
<p><img alt="" height="886" src="https://images2.imgbox.com/ac/aa/NNjJuA7z_o.png" width="1200"></p> 
<p></p> 
<p>上图在插入前，AVL树是平衡的，新节点插入到20的左子树(注意：此处不是左孩子)中，20左子树增加 了一层，导致以60为根的二叉树不平衡，要让60平衡，只能将60左子树的高度减少一层，右子树增加一层， 即将左子树往上提，这样60转下来，因为60比30大，只能将其放在30的右子树，而如果30有右子树，右子树根的值 一定大于30，小于60，只能将其放在60的左子树，旋转完成后，更新节点的平衡因子即可。在旋转过程中，有以下 几种情况需要考虑： 1. 30节点的右孩子可能存在，也可能不存在 2. 60可能是根节点，也可能是子树 如果是根节点，旋转完成后，要更新根节点 如果是子树，可能是某个节点的左子树，也可能是右子树 </p> 
<pre><code class="language-java"> /**
   * 右单旋左树高的话需要调整左树的高度
   * @author xiaoxie
   * @date 2024/3/6 15:01
   * @param parent
   */
  private void rotateRight(TreeNode parent) {
      TreeNode subL = parent.left;
      TreeNode subLR = subL.right;
      subL.right = parent;
      parent.left = subLR;
      if(subLR != null) {
          subLR.parent = parent;
      }
      TreeNode Pparent = parent.parent;
      parent.parent = subL;
      if(parent == root) {
          root = subL;
          root.parent = null;
      }else {
           if(Pparent.left == parent) {
              Pparent.left = subL;
          }else {
              Pparent.right = subL;
          }
          subL.parent = Pparent;
      }
      parent.bf = 0;
      subL.bf = 0;
  }</code></pre> 
<h3>2. 新节点插入较高右子树的右侧---左单旋 </h3> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/b1/1f/FFdz8K7Y_o.png" width="1200"></p> 
<p> </p> 
<p>上图在插入前，AVL树是平衡的,新的节点80,插入到70的右子树,70右子树增加 了一层，导致以30为根的二叉树不平衡,要让30平衡，只能将30右子树的高度减少一层，左子树增加一层， 即将右子树往上提，这样30转下来，因为30比60小，只能将其放在60的左子树，而如果60有左子树，左子树根的值 一定大于30，小于60，只能将其放在30的右子树，旋转完成后，更新节点的平衡因子即可。在旋转过程中，有以下 几种情况需要考虑： 1. 60节点的右孩子可能存在，也可能不存在 2. 30可能是根节点，也可能是子树 如果是根节点，旋转完成后，要更新根节点 如果是子树，可能是某个节点的左子树，也可能是右子树 </p> 
<pre><code class="language-java">/** 左单旋
   * 左旋,右树高的情况,需要调整右树的高度
   * @author xiaoxie
   * @date 2024/3/6 14:14
   * @param parent
   */
  private void rotateLeft(TreeNode parent) {
      TreeNode subR = parent.right;
      TreeNode subRL = subR.left;
      subR.left = parent;
      parent.right = subRL;
      if(subRL != null) {
          subRL.parent = parent;
      }
      //先记录parent节点的父亲节点
      TreeNode Pparent = parent.parent;
      parent.parent = subR;
      if(parent == root) {
          root = subR;
          subR.parent = null;
      }else {
          if(Pparent.left == parent) {
              Pparent.left = subR;
          }else {
              Pparent.right = subR;
          }
          subR.parent = Pparent;
      }
      parent.bf = 0;
      subR.bf = 0;
  }</code></pre> 
<h3>3.新节点插入较高左子树的右侧：先左单旋再右单旋【左右双旋】</h3> 
<p>当一个节点的左子树比右子树高度高2个以上时，且这个节点的左子节点的右子树高于左子树时，需要进行左右双旋</p> 
<h4>1.情况一 subLR的平衡因子为1</h4> 
<p><img alt="" height="922" src="https://images2.imgbox.com/74/e2/Epgv2Sgx_o.png" width="1200"></p> 
<p><img alt="" height="932" src="https://images2.imgbox.com/5b/25/Gn6p7wV4_o.png" width="1200"> </p> 
<p>在上图插入前,AVL树是平衡的,但在插入节点50后,插入到40的右子树上时,40的左子树的高度就增加一层了,以60为根的子树就不平衡了,这个时候我们就需要增加60的右子树的高度,降低左子树的高度,我们就需要用到右单旋,但60节点的左子节点的右子树高于左子树时,我们仅仅通过简单的右单旋并不能使这棵树变成高度平衡的二叉搜索树,我们就需要先进行左单旋,使这个节点的左节点的左子树和右子树的平衡后再进行右单旋,可以从上图看出,在进行左单旋后这颗树的情况和情况1一样,只是在最后需要我们调整 subL,parent,subLR的平衡因子即可</p> 
<h4>2.情况二subLR的平衡因子为-1</h4> 
<p><img alt="" height="976" src="https://images2.imgbox.com/9d/86/XgOFD2RX_o.png" width="1200"></p> 
<p><img alt="" height="782" src="https://images2.imgbox.com/e0/10/AVi2Eq02_o.png" width="1200"> </p> 
<p>情况二和情况一的旋转过程大致一样,只不对 subL,parent,subLR的平衡因子的调整不同</p> 
<pre><code class="language-java">/**
   * 左右双旋
   * @author xiaoxie
   * @date 2024/3/6 16:04
   * @param parent
   */
  private void rotateLR(TreeNode parent) {
      TreeNode subL = parent.left;
      TreeNode subLR = subL.right;
      int bf = subLR.bf;
      rotateLeft(parent.left);//左旋
      rotateRight(parent);//右旋
      if(bf == 1) {
          subLR.bf = 0;
          subL.bf = -1;
          parent.bf = 0;
      }else if(bf == -1) {
          subLR.bf = 0;
          subL.bf = 0;
          parent.bf = 1;
      }
  }</code></pre> 
<h3>4.新节点插入较高右子树的左侧---右左：先右单旋再左单旋【右左双旋】</h3> 
<p>当一个节点的右子树比左子树高度高2个以上时，且这个节点的右子节点的左子树高于右子树时，需要进行右左双旋</p> 
<h4>1.情况一 subRL的平衡因子为1</h4> 
<p><img alt="" height="1000" src="https://images2.imgbox.com/85/74/C0AgEODa_o.png" width="1200"></p> 
<p><img alt="" height="984" src="https://images2.imgbox.com/a4/75/t8nwIeUS_o.png" width="1200"> </p> 
<p>在上图插入前,AVL树是平衡的,但在插入节点75后,插入到70的右子树上时,70的右子树的高度就增加一层了,以60为根的子树就不平衡了,这个时候我们就需要增加60的左子树的高度,降低右子树的高度,我们就需要用到左单旋,但60节点的右子节点的左子树高于右子树时,我们仅仅通过简单的左单旋并不能使这棵树变成高度平衡的二叉搜索树,我们就需要先进行右单旋,使这个节点的右节点的右子树和左子树的平衡后再进行左旋,可以从上图看出,在进行右单旋后这颗树的情况和情况2一样,只是在最后需要我们调整 subR,parent,subRL的平衡因子即可 </p> 
<h4>2.情况二subRL的平衡因子为-1</h4> 
<p><img alt="" height="986" src="https://images2.imgbox.com/55/88/iAfRmDvI_o.png" width="1200"></p> 
<p><img alt="" height="826" src="https://images2.imgbox.com/4d/22/EmAGlEJ5_o.png" width="1200"> </p> 
<p>况二和情况一的旋转过程大致一样,只不对 subR,parent,subRL的平衡因子的调整不同</p> 
<pre><code class="language-java">/**
   * 右左双旋
   * @author xiaoxie
   * @date 2024/3/6 16:19
   * @param parent
   */
  private void rotateRL(TreeNode parent) {
      TreeNode subR = parent.right;
      TreeNode subRL = subR.left;
      int bf = subRL.bf;
      rotateRight(parent.right);
      rotateLeft(parent);
      if(bf == -1) {
          parent.bf = 0;
          subR.bf = 1;
          subRL.bf = 0;
      }else if(bf == 1) {
          parent.bf = -1;
          subRL.bf = 0;
          subR.bf = 0;
      }
  }</code></pre> 
<h3> 5.旋转的总结</h3> 
<p>新节点插入后，假设以Parent为根的子树不平衡，即Parent的平衡因子为2或者-2，分以下情况考虑</p> 
<p>1. Parent的平衡因子为2，说明Parent的右子树高，设Parent的右子树的根为SubR 当SubR的平衡因子为1时，执行左单旋 当SubR的平衡因子为-1时，执行右左双旋</p> 
<p>2. Parent的平衡因子为-2，说明Parent的左子树高，设Parent的左子树的根为SubL 当SubL的平衡因子为-1是，执行右单旋 当SubL的平衡因子为1时，执行左右双旋</p> 
<p><span style="color:#fe2c24;"><strong>即：Parent与其较高子树节点的平衡因子时同号时单旋转，异号时双旋转。</strong></span></p> 
<p>旋转完成后，原Parent为根的子树个高度降低，已经平衡，不需要再向上更新</p> 
<h2>五.总的代码实现及总结</h2> 
<h3>1.Java代码实现</h3> 
<pre><code class="language-java">public class AVLTree {
 public static class TreeNode {
     public int val;
     public TreeNode left;
     public TreeNode right;
     public int bf;
     public TreeNode parent;
     public TreeNode(int val) {
         this.val = val;
     }
 }
 public TreeNode root;
 /**
  * 插入节点,并调整平衡因子
  * 使用旋转的方法调整平衡因子
  * @author xiaoxie
  * @date 2024/3/6 13:13
  * @param val
  * @return boolean
  */
  public boolean insertNode(int val) {
      TreeNode node = new TreeNode(val);
     if(root == null) {
         root = node;
         root.parent = null;
     }
     TreeNode parent = null;
     TreeNode cur = root;
     while (cur != null) {
         if(node.val &lt; cur.val) {
             parent = cur;
             cur = cur.left;
         } else if (node.val &gt; cur.val) {
             parent = cur;
             cur = cur.right;
         }else {
             System.out.println("节点值 " + val + " 已经存在于树中，不进行插入操作");
             return false;
         }
     }
     //cur == null
      //找到node是parent的左孩子还是右孩子
      if(node.val &lt; parent.val) {
          parent.left = node;
      }else {
          parent.right = node;
      }
      node.parent = parent;
      cur = node;
      while (parent != null) {
          //计算节点的平衡因子
          //如果是左孩子就--
          //右孩子就++;
          if(cur == parent.left) {
              parent.bf--;
          }else {
              parent.bf++;
          }
          //根据不同的平衡因子有不同的情况
          //1.如果平衡因子为0
          if(parent.bf == 0) {
              break;
          } else if (parent.bf == 1 || parent.bf == -1) {
              cur = parent;
              parent = cur.parent;
          }else {
              if(parent.bf == 2) { //就代表右树高,需要调整右树的高度,就是左单旋,或者右左双旋
                  if(cur.bf == 1) {
                      rotateLeft(parent);
                  }else {
                      rotateRL(parent);//cur.bf = -1
                  }
              }else {//parent.bf == -2
                  if(cur.bf == 1) {
                      rotateLR(parent);
                  }else {//cur.bf == -1
                      rotateRight(parent);
                  }
              }
          }
      }
      return true;
  }
  /** 左单旋
   * 左旋,右树高的情况,需要调整右树的高度
   * @author xiaoxie
   * @date 2024/3/6 14:14
   * @param parent
   */
  private void rotateLeft(TreeNode parent) {
      TreeNode subR = parent.right;
      TreeNode subRL = subR.left;
      subR.left = parent;
      parent.right = subRL;
      if(subRL != null) {
          subRL.parent = parent;
      }
      //先记录parent节点的父亲节点
      TreeNode Pparent = parent.parent;
      parent.parent = subR;
      if(parent == root) {
          root = subR;
          subR.parent = null;
      }else {
          if(Pparent.left == parent) {
              Pparent.left = subR;
          }else {
              Pparent.right = subR;
          }
          subR.parent = Pparent;
      }
      parent.bf = 0;
      subR.bf = 0;
  }
  /**
   * 右单旋左树高的话需要调整左树的高度
   * @author xiaoxie
   * @date 2024/3/6 15:01
   * @param parent
   */
  private void rotateRight(TreeNode parent) {
      TreeNode subL = parent.left;
      TreeNode subLR = subL.right;
      subL.right = parent;
      parent.left = subLR;
      if(subLR != null) {
          subLR.parent = parent;
      }
      TreeNode Pparent = parent.parent;
      parent.parent = subL;
      if(parent == root) {
          root = subL;
          root.parent = null;
      }else {
           if(Pparent.left == parent) {
              Pparent.left = subL;
          }else {
              Pparent.right = subL;
          }
          subL.parent = Pparent;
      }
      parent.bf = 0;
      subL.bf = 0;
  }
  /**
   * 左右双旋
   * @author xiaoxie
   * @date 2024/3/6 16:04
   * @param parent
   */
  private void rotateLR(TreeNode parent) {
      TreeNode subL = parent.left;
      TreeNode subLR = subL.right;
      int bf = subLR.bf;
      rotateLeft(parent.left);
      rotateRight(parent);
      if(bf == 1) {
          subLR.bf = 0;
          subL.bf = -1;
          parent.bf = 0;
      }else if(bf == -1) {
          subL.bf = 0;
          parent.bf = 1;
          subLR.bf = 0;
      }
  }
  /**
   * 右左双旋
   * @author xiaoxie
   * @date 2024/3/6 16:19
   * @param parent
   */
  private void rotateRL(TreeNode parent) {
      TreeNode subR = parent.right;
      TreeNode subRL = subR.left;
      int bf = subRL.bf;
      rotateRight(parent.right);
      rotateLeft(parent);
      if(bf == -1) {
          parent.bf = 0;
          subR.bf = 1;
          subRL.bf = 0;
      }else if(bf == 1) {
          parent.bf = -1;
          subRL.bf = 0;
          subR.bf = 0;
      }
  }
    private int height(TreeNode root) {
        if(root == null) return 0;
        int leftH = height(root.left);
        int rightH = height(root.right);

        return leftH &gt; rightH ? leftH+1 : rightH+1;
    }
    /**
     * 验证是否正确AVLTree
     * @author xiaoxie
     * @date 2024/3/6 16:49
     * @param root
     * @return boolean
     */
    public boolean isBalanced(TreeNode root) {
        if(root == null) return true;
        int leftH = height(root.left);
        int rightH = height(root.right);

        if(rightH-leftH != root.bf) {
            System.out.println("这个节点："+root.val+" 平衡因子异常");
            return false;
        }

        return Math.abs(leftH-rightH) &lt;= 1
                &amp;&amp; isBalanced(root.left)
                &amp;&amp; isBalanced(root.right);
    }
}</code></pre> 
<h3>2.AVL树总结</h3> 
<p>AVL树是一棵绝对平衡的二叉搜索树，其要求每个节点的左右子树高度差的绝对值都不超过1，这样可以保证查询时高效的时间复杂度，即 logN。但是如果要对AVL树做一些结构修改的操作，性能非常低下，比如：插入时要 维护其绝对平衡，旋转的次数比较多，更差的是在删除时，有可能一直要让旋转持续到根的位置。<strong>因此：如果需要一种查询高效且有序的数据结构，而且数据的个数为静态的(即不会改变)，可以考虑AVL树，但一个结构经常修改就不太适合。 </strong></p> 
<p><strong>以上就是博主关于AVL树的全部总结了,希望能够对你有所帮助!</strong></p> 
<p></p> 
<p><strong> </strong></p> 
<p></p> 
<h2> </h2> 
<p></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f913d17147e7318edda6fa4b38ddc09b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">c# WebService创建与调用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/782b1a79788f9bc3648acdd18079ad52/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">VUE3 播放RTSP实时、回放(NVR录像机)视频流（使用WebRTC）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>