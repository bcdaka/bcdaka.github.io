<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>桥接模式与适配器模式 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/a03631ef33a64b8e6b5ed65d332af3f8/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="桥接模式与适配器模式">
  <meta property="og:description" content="一、共性和区别 桥接设计模式和适配器设计模式的共同点和明显，它们都是使两种不同的类配合工。
二者的区别在于，适配器模式是将已有的两个不同接口接口组合到一起，使得适配器同时拥有两个不同接口的功能，其目的是使两个不兼容的接口协调工作；桥接模式目的是抽象和实现分离，实现的改变不影响抽象，抽象的变化不影响实现，可以有效的应对具体业务的变化，以及业务实现的横向扩展。
二、桥接模式 1、函数类声明 #ifndef BRIDGE_H #define BRIDGE_H #include &lt;iostream&gt; using namespace std; ///定义抽象业务类 class AbstractObj{ public: virtual void abstractOpt()=0; }; /// 定义具体业务实现类A class ObjImplA: public AbstractObj{ public: ObjImplA(); ~ObjImplA(); void abstractOpt() override; }; /// 定义具体的业务实现了B class ObjImplB: public AbstractObj{ public: ObjImplB(); ~ObjImplB(); void abstractOpt() override; }; /// 定义桥器 class IBridge{ public: virtual void bridgeOpt()=0; }; /// 桥接器具体实现 class BridgeImpl: public IBridge{ /// 桥接器持有对抽象业务类的引用，不考虑具体实现，这样不管具体的业务怎么处理，都不会影响到接口，随着业务的扩张，业务横向增加，对于用户是无感的，用户只需要通过桥接器动态调用即可 private: AbstractObj* abstractObj; public: BridgeImpl(AbstractObj* abstractObj); ~BridgeImpl(); void bridgeOpt() override; }; #endif 2、函数定义 #include &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-03T14:09:57+08:00">
    <meta property="article:modified_time" content="2024-07-03T14:09:57+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">桥接模式与适配器模式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一、共性和区别       </h3> 
<p>      桥接设计模式和适配器设计模式的共同点和明显，它们都是使两种不同的类配合工。</p> 
<p>       二者的区别在于，适配器模式是将已有的两个不同接口接口组合到一起，使得适配器同时拥有两个不同接口的功能，<strong>其目的是使两个不兼容的接口协调工作</strong>；桥接模式目的是<strong>抽象和实现分离</strong>，实现的改变不影响抽象，抽象的变化不影响实现，可以有效的应对具体业务的变化，以及业务实现的横向扩展。</p> 
<h3>二、桥接模式</h3> 
<h4>1、函数类声明</h4> 
<pre><code class="language-cpp">#ifndef BRIDGE_H
#define BRIDGE_H
#include &lt;iostream&gt;
using namespace std;

///定义抽象业务类
class  AbstractObj{
public:
    virtual  void  abstractOpt()=0;
};

/// 定义具体业务实现类A
class  ObjImplA: public AbstractObj{
public:
     ObjImplA();
    ~ObjImplA();
    void   abstractOpt()  override;
};

/// 定义具体的业务实现了B
class  ObjImplB: public AbstractObj{
public:
    ObjImplB();
    ~ObjImplB();
    void abstractOpt()  override;
};

/// 定义桥器
class IBridge{
public:
    virtual void   bridgeOpt()=0;
};

/// 桥接器具体实现
class  BridgeImpl: public IBridge{
/// 桥接器持有对抽象业务类的引用，不考虑具体实现，这样不管具体的业务怎么处理，都不会影响到接口，随着业务的扩张，业务横向增加，对于用户是无感的，用户只需要通过桥接器动态调用即可    
private:
    AbstractObj*  abstractObj;
public:
    BridgeImpl(AbstractObj*  abstractObj);
    ~BridgeImpl();
    void bridgeOpt() override;
};

#endif 
</code></pre> 
<h4>2、函数定义</h4> 
<pre><code class="language-cpp">#include "./bridge.h"

ObjImplA::ObjImplA(){

}
ObjImplA::~ObjImplA(){

}
void ObjImplA::abstractOpt(){
   std::cout &lt;&lt; "ObjImplA call  abstractOpt  function" &lt;&lt; std::endl;
}

ObjImplB::ObjImplB(){

}
ObjImplB::~ObjImplB(){

}
void  ObjImplB::abstractOpt(){
     std::cout &lt;&lt; "ObjImplB call  abstractOpt  function" &lt;&lt; std::endl;
}

BridgeImpl::BridgeImpl(AbstractObj*  abstractObj){
    this-&gt;abstractObj = abstractObj ;
}

void BridgeImpl::bridgeOpt(){
    abstractObj-&gt;abstractOpt();
}
</code></pre> 
<p>3、测试</p> 
<pre><code class="language-cpp"> /// 处理B类业务
IBridge*  bridge = new BridgeImpl(new ObjImplB());
bridge-&gt;bridgeOpt();
/// 处理A类业务
bridge = new BridgeImpl(new ObjImplA());
bridge-&gt;bridgeOpt();</code></pre> 
<h3>三、适配器模式 </h3> 
<h4> 1、函数声明</h4> 
<pre><code class="language-cpp">#ifndef ADAPTER_H
#define ADAPTER_H
#include  &lt;iostream&gt;
#include &lt;string.h&gt;
using namespace std;

/// 场景设定，笔记本上只有HDMI接口，而手中只有一根VGA的线，要想把这个VGA得线连到笔记本，就需要一个HDMI的转接头，这就典型的适配器模式

///  定义适配者vga VAG线
class Vga{
protected:
    string vgaTran();
};

/// 定义适配接口  hdmi接口
class  IHdmi{
public:
    virtual void hdmiIO()=0;
};

/// 定义适配器 hdmi 转接头
class HdmiAdapter : public Vga,public IHdmi {
public:
    void hdmiIO()  override;
};

#endif
</code></pre> 
<pre><code class="language-cpp">#include "adapter.h"

string Vga::vgaTran(){
  ///  使用vga线传输信号
  return "vga data line  tran signal";
}

void  HdmiAdapter::hdmiIO(){
  string singal = this-&gt;vgaTran();
  /// 使用hdmi接口输出vga传输的信号
  cout&lt;&lt; "hdmi  output : " &lt;&lt; singal &lt;&lt; endl;
}
</code></pre> 
<h4>2、业务调用</h4> 
<pre><code class="language-cpp">  HdmiAdapter*  adapter = new  HdmiAdapter();
  adapter-&gt;hdmiIO();</code></pre> 
<h3>四、CMakeLists.txt</h3> 
<pre><code class="language-bash">cmake_minimum_required(VERSION 3.5)

project(dpcode LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

add_executable(dpcode main.cpp
    bridge.h
    bridge.cpp
    adapter.h
    adapter.cpp)

include(GNUInstallDirs)
install(TARGETS dpcode
    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
)
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7c82b2110f5f094e070ce13a790ec816/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用androidx.appcompat:appcompat:1.7.0无法运行的问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e8f3347907d69e580accaffa485198be/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">华为路由器静态路由配置（eNSP模拟实验）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>