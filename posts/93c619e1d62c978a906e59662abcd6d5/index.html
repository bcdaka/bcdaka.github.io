<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Codeforces Round 962 (Div. 3) 题解 A-F - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/93c619e1d62c978a906e59662abcd6d5/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Codeforces Round 962 (Div. 3) 题解 A-F">
  <meta property="og:description" content="A. Legs Problem - A - Codeforces
1.1翻译 农夫约翰的农场又迎来了美好的一天。
农夫约翰来到农场后，数了数 n条腿。众所周知，农场里只住着鸡和牛，一只鸡有 2 条腿，而一头牛有 4 条腿。
假设约翰农场主数清了所有动物的腿，那么他的农场里最少有多少动物？
1.2思路 求最少有几只动物，n先除4再除2就行。
1.3代码 void solve() { cin &gt;&gt; n; int k = n / 4; n -= k * 4; int p = n / 2; cout &lt;&lt; p &#43; k &lt;&lt; &#34;\n&#34;; } B. Scale ​​​​​​Problem - B - Codeforces
2.1翻译 就是说，给你一个n*n的01网格，网格中每个01块都是相同的长宽，让你缩小k倍，例如：
8 2
00001111
00001111 00001111 --&gt; 0011
00001111 --&gt; 0011 11110000 --&gt; 1100">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-30T10:44:46+08:00">
    <meta property="article:modified_time" content="2024-07-30T10:44:46+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Codeforces Round 962 (Div. 3) 题解 A-F</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="text-align:justify;">A. Legs</h2> 
<p style="text-align:justify;"><a href="https://codeforces.com/contest/1996/problem/A" rel="nofollow" title="Problem - A - Codeforces">Problem - A - Codeforces</a></p> 
<h6 style="text-align:justify;">1.1翻译</h6> 
<p style="text-align:justify;">农夫约翰的农场又迎来了美好的一天。</p> 
<p>农夫约翰来到农场后，数了数 n条腿。众所周知，农场里只住着鸡和牛，一只鸡有 2 条腿，而一头牛有 4 条腿。</p> 
<p>假设约翰农场主数清了所有动物的腿，那么他的农场里最少有多少动物？</p> 
<p></p> 
<h6><br> 1.2思路</h6> 
<p>求最少有几只动物，n先除4再除2就行。</p> 
<h6>1.3代码</h6> 
<pre><code class="language-cpp">void solve() {
    cin &gt;&gt; n;
    int k = n / 4;
    n -= k * 4;
    int p = n / 2;
    cout &lt;&lt; p + k &lt;&lt; "\n";
}</code></pre> 
<h2></h2> 
<h2>B. Scale</h2> 
<p><br><a href="https://codeforces.com/contest/1996/problem/B" rel="nofollow" title="​​​​​​Problem - B - Codeforces">​​​​​​Problem - B - Codeforces</a><br>  </p> 
<h6>2.1翻译 </h6> 
<p><br> 就是说，给你一个n*n的01网格，网格中每个01块都是相同的长宽，让你缩小k倍，例如：<br> 8 2<br> 00001111<br> 00001111 <br> 00001111      --&gt;      0011<br> 00001111      --&gt;      0011               <br> 11110000      --&gt;      1100<br> 11110000      --&gt;      1100<br> 11110000</p> 
<p></p> 
<h6>2.2思路</h6> 
<p><br> 我们只需要从（1，1）位置开始i和j加k输出就可以，自己模拟几下就找到规律</p> 
<p></p> 
<h6>2.3代码</h6> 
<pre><code class="language-cpp">char mpp[N][N];
void solve() {
    int n, k;
    cin &gt;&gt; n &gt;&gt; k;
    for (int i = 1; i &lt;= n; i++) {
        for (int j = 1; j &lt;= n; j++) {
            cin &gt;&gt; mpp[i][j];
        }
    }

    for (int i = 1; i &lt;= n; i += k) {
        for (int j = 1; j &lt;= n; j += k) {
            cout &lt;&lt; mpp[i][j];
        }
        cout &lt;&lt; "\n";
    }
}</code></pre> 
<p></p> 
<h2>C. Sort</h2> 
<p><br>   <a href="https://codeforces.com/contest/1996/problem/C" rel="nofollow" title="Problem - C - Codeforces">Problem - C - Codeforces</a><br>  </p> 
<h6>3.1翻译</h6> 
<p><br> 就是说，给你两个长度为n的字符串，询问q次。<br> 每次给出l，r的区间让你判断区间字符串是否匹配，不匹配就得去修改a的字符，需要修改几次才能让两个区间相同</p> 
<h6><br> 3.2思路</h6> 
<p><br> 首先需要判断l和r大小，确定循环；<br> 统计一下区间字符串中字符不同的数量，输出即可。<br> 一开始用map来做，后来超时了，就做了优化。</p> 
<p></p> 
<h6>3.3代码</h6> 
<pre><code class="language-cpp">const int N = 2e5 + 10;
int a_count[26][N], b_count[26][N];

void Count(const string&amp; a, const string&amp; b, int n) {
    for (int i = 0; i &lt; 26; ++i) {
        a_count[i][0] = b_count[i][0] = 0;
    }
    for (int i = 0; i &lt; n; ++i) {
        for (int j = 0; j &lt; 26; ++j) {
            a_count[j][i + 1] = a_count[j][i] + (a[i] == 'a' + j);
            b_count[j][i + 1] = b_count[j][i] + (b[i] == 'a' + j);
        }
    }
}

int get(int l, int r, int n) {
    int cnt = 0;
    for (int i = 0; i &lt; 26; ++i) {
        int ap = a_count[i][r] - a_count[i][l - 1];
        int bp = b_count[i][r] - b_count[i][l - 1];
        cnt += max(0, bp - ap);
    }
    return cnt;
}

void solve() {
    int n, k;
    cin &gt;&gt; n &gt;&gt; k;
    string a, b;
    cin &gt;&gt; a &gt;&gt; b;
    Count(a, b, n);
    while (k--) {
        int l, r;
        cin &gt;&gt; l &gt;&gt; r;
        if (l &gt; r) cout &lt;&lt; get(1, r, n) + get(l, n, n) &lt;&lt; "\n";
        else cout &lt;&lt; get(l, r, n) &lt;&lt; "\n";
    }
}</code></pre> 
<h6><br> 3.4超时版</h6> 
<pre><code class="language-cpp">const int N = 2e5 + 10;
map&lt;char, int&gt;p;
void solve() {
    int n, k;
    cin &gt;&gt; n &gt;&gt; k;
    string a, b;
    cin &gt;&gt; a &gt;&gt; b;
    while (k--) {
        int l, r;
        cin &gt;&gt; l &gt;&gt; r;
        p.clear();
        if (l &lt;= r) {
            for (int i = l - 1; i &lt;= r - 1; i++)
                p[b[i]]++, p[a[i]]--;
        }
        else {
            for (int i = l - 1; i &lt;= n - 1; i++)
                p[b[i]]++, p[a[i]]--;
            for (int i = 0; i &lt;= l - 1; i++)
                p[b[i]]++, p[a[i]]--;
        }
        int cnt = 0;
        for (char i = 'a'; i &lt;= 'z'; i++)
            if (p[i] &gt; 0) cnt += p[i];
        cout &lt;&lt; cnt &lt;&lt; "\n";
    }
}</code></pre> 
<p></p> 
<h2>D. Fun</h2> 
<p><br><a href="https://codeforces.com/contest/1996/problem/D" rel="nofollow" title="Problem - D - Codeforces">Problem - D - Codeforces</a></p> 
<h6><br> 4.1翻译</h6> 
<p><br> 给定两个整数 n 和 x ，求 ab+ac+bc≤n 和 a+b+c≤x 的个正整数的三元组( a,b,c)的个数。<br> 注意顺序问题(例如 ( 1,1,2 ) 和 ( 1,2,1 ) 被视为不同)， a ， b ， c 必须严格大于 0 。</p> 
<h6><br> 4.2思路 </h6> 
<p><br> 由第一个式子可知，a*b&lt;=n，所以b有大约有 nlogn个选择，可以循环ab求解<br> 由两个式子可推导出c ≤（n−ab）/（a+b）和  c ≤ x−a−b,我们只需要选择范围最小的那一个即可。</p> 
<p></p> 
<h6>4.3代码</h6> 
<pre><code class="language-cpp">#define ll long long

void solve() {
    int n, k;
    cin &gt;&gt; n &gt;&gt; k;
    ll c = 0;
    for (int i = 1; i &lt;= n; i++)
        for (int j = 1; i * j &lt;= n; j++) {
            ll t1 = i * j, t2 = i + j;
            if ((n - t1) / t2 &gt; 0 &amp;&amp; k - t2 &gt; 0) c += min((n - t1) / t2, k - t2);
        }
    cout &lt;&lt; c &lt;&lt; "\n";
}</code></pre> 
<h2>E. Decode</h2> 
<p><a href="https://codeforces.com/contest/1996/problem/E" rel="nofollow" title="Problem - E - Codeforces">Problem - E - Codeforces</a></p> 
<p></p> 
<h6>5.1翻译</h6> 
<p></p> 
<p>给你一个长度为 𝑛 的二进制字符串 𝑠 。对于每一对整数 (𝑙,𝑟) . (1≤𝑙≤𝑟≤𝑛) 中，数出(𝑥,𝑦) (𝑙≤𝑥≤𝑦≤𝑟) 这样的整数对的个数。 (𝑙≤𝑥≤𝑦≤𝑟) 中的 00 等于子串 𝑠𝑥𝑠𝑥+1...𝑠𝑦 中的 1 。</p> 
<p>输出所有可能的 (l,r)(𝑙,𝑟) modulo 109+7109+7 的计数之和。</p> 
<p></p> 
<h6>5.2代码</h6> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;unordered_map&gt;
using namespace std;
typedef unsigned long long ull;
#define ios ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)
#define mm(a, b) memset(a, b, sizeof(a))
#define mp make_pair
#define ll long long
typedef pair&lt;int, int&gt; pii;
const int inf = 0x3f3f3f3f, mod = 1e9 + 7;
const int N = 2e6 + 10;

ll n, sum, p[N], f[N], k;
string s;
void solve() {
    cin &gt;&gt; s;
    n = s.length();
    for (ll i = 0; i &lt;= 2 * n; i++) f[i] = 0;
    for (ll i = 1; i &lt;= n; i++) {
        ll pp = p[i - 1];
        if (s[i - 1] == '1') p[i] = pp + 1;
        else  p[i] = pp - 1;
    }
    sum = 0;
    for (ll i = 0; i &lt;= n; i++) {
        ll id = p[i] + n;
        sum = (sum + f[id] * (n - i + 1)) % mod;
        f[id] = (f[id] + (i + 1)) % mod;
    }
    cout &lt;&lt; sum &lt;&lt; '\n';
}

int main() {
    ios;
    ll t;
    cin &gt;&gt; t;
    while (t--) solve();
    return 0;
}
</code></pre> 
<h2>F. Bomb（参考jiangly的思路）</h2> 
<h6 style="background-color:transparent;">6.1代码</h6> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;unordered_map&gt;
#include&lt;set&gt;
using namespace std;
typedef unsigned long long ull;
#define ios ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)
#define mm(a, b) memset(a, b, sizeof(a))
#define mp make_pair
#define ll long long
typedef pair&lt;int, int&gt; pii;
const int inf = 0x3f3f3f3f, mod = 1e9 + 7;
const int N = 2e6 + 10;

typedef pair&lt;ll, ll&gt; Pair;

Pair get(int v, vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b, int n) {
    ll sum = 0;
    ll cnt = 0;
    for (int i = 0; i &lt; n; ++i) {
        if (a[i] &gt;= v) {
            ll t = (a[i] - v) / b[i] + 1;
            cnt += t;
            sum += a[i] * t - t * (t - 1) / 2 * b[i];
        }
    }
    return Pair(cnt, sum);
}

void solve() {
    int n, k;
    cin &gt;&gt; n &gt;&gt; k;
    vector&lt;int&gt; a(n), b(n);

    for (int i = 0; i &lt; n; ++i) cin &gt;&gt; a[i];  
    for (int i = 0; i &lt; n; ++i) cin &gt;&gt; b[i];

    int l = 0, r = inf;
    while (l &lt; r) {
        int x = (l + r) / 2;

        if (get(x, a, b, n).first &lt;= k)  r = x;
        else l = x + 1;
    }

    Pair res = get(l, a, b, n);
    if (l &gt; 0)  res.second += (k - res.first) * (l - 1);

    cout &lt;&lt; res.second &lt;&lt; "\n";
}


int main() {
    ios;
    ll t;
    cin &gt;&gt; t;
    while (t--) solve();
    return 0;
}
</code></pre> 
<p><a href="https://www.cnblogs.com/kkk117/p/18326698" rel="nofollow" title="Codeforces Round 962 (Div. 3) 题解 - 尔一 - 博客园 (cnblogs.com)">Codeforces Round 962 (Div. 3) 题解 - 尔一 - 博客园 (cnblogs.com)</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/49ec739ec90b6fee8bc766437ed3ce24/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">六小龄童评价《黑神话悟空》 黑神话悟空是什么游戏 苹果电脑能玩黑神话悟空吗</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f304c00763cf264dc92a7f8c35bdab5b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">设计模式 之 —— 抽象工厂模式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>