<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>文件系统中元数据的隐患——缓存 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/85d4018116d0e659e9b25808b9877f87/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="文件系统中元数据的隐患——缓存">
  <meta property="og:description" content=" 热点文件（尤其是大文件）在查询或下载过程中，涉及大量的元信息访问。如果元信息较大且访问 QPS 较大时，就会导致实例网卡打满、CPU爆表，造成缓存失效（缓存击穿）；流量直接打到 DB 上，造成大量读请求超时、连接打满、机器挂掉（服务雪崩）。直接对服务可用性造成打击，一般都是重大事故。
造成这种结果的本质原因是缓存设计和使用不合理。直接原因是缓存对象指向的文件是热门资源。一般文件系统很少关心文件或者文件对象指向的内容，所以在这类热点发生时往往很被动。需要告警阈值提醒，人工及时介入处理和止损（封禁、扩容）。
理想的方式是对文件粒度的读访问限流，但是很少这么做，就像普通用户 Windows 系统装防火墙一样...代价大价值很难凸显。比较常用的方法是对缓存下手，业务侵入小，普适性高。
前提是需要梳理业务逻辑，对目标对象的缓存本身进行分析，哪些情况QPS 达到多少就会有隐患。然后再分析一下可用的方案，一般有三种处理方式：
本地缓存
在合适的业务节点实例上，申请一定大小的空间用于本地缓存。将需要被缓存的一定大小以上的元数据作为缓存对象。需要自行实现淘汰算法，支持过期时间，支持内容校验。由于流量的负载均衡和随机性，需要埋点查看缓存命中率，估计效果。
这种方式可以解决集中热点问题，但是无法根治。命中率随着流量随机性的降低而升高，这取决于流量分发层策略和设计。
缓存数据压缩
一般压缩率可观，但是遇到超大文件仍然无法根本解决问题。
大 key 拆解
这种需要对缓存数据中的作用和业务需求有全面的分析，分类讨论。抽象出基本信息，多 key信息存储。直接影响是原来获取一次，现在需要获取多次，极端情况下，有长尾请求的 bad case，可以根据具体情况优化逻辑，全局考虑下一般可接受。由于大 key 拆分，需要先改校验规则，再上线新逻辑。
综上，正对业务使用的大 key缓存需求，本质要求设计者和编程者懂业务，对缓存目标有一定的认知，了解缓存的利弊，使用时根据情况取舍粒度，全面思考和逻辑闭环。 ">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-25T19:03:52+08:00">
    <meta property="article:modified_time" content="2024-07-25T19:03:52+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">文件系统中元数据的隐患——缓存</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>        热点文件（尤其是大文件）在查询或下载过程中，涉及大量的元信息访问。如果元信息较大且访问 QPS 较大时，就会导致实例网卡打满、CPU爆表，造成缓存失效（缓存击穿）；流量直接打到 DB 上，造成大量读请求超时、连接打满、机器挂掉（服务雪崩）。直接对服务可用性造成打击，一般都是重大事故。</p> 
<p>        造成这种结果的本质原因是缓存设计和使用不合理。直接原因是缓存对象指向的文件是热门资源。一般文件系统很少关心文件或者文件对象指向的内容，所以在这类热点发生时往往很被动。需要告警阈值提醒，人工及时介入处理和止损（封禁、扩容）。</p> 
<p>        理想的方式是对文件粒度的读访问限流，但是很少这么做，就像普通用户 Windows 系统装防火墙一样...代价大价值很难凸显。比较常用的方法是对缓存下手，业务侵入小，普适性高。</p> 
<p>        前提是需要梳理业务逻辑，对目标对象的缓存本身进行分析，哪些情况QPS 达到多少就会有隐患。然后再分析一下可用的方案，一般有三种处理方式：</p> 
<p><strong>本地缓存</strong></p> 
<p><strong>       </strong> 在合适的业务节点实例上，申请一定大小的空间用于本地缓存。将需要被缓存的一定大小以上的元数据作为缓存对象。需要自行实现淘汰算法，支持过期时间，支持内容校验。由于流量的负载均衡和随机性，需要埋点查看缓存命中率，估计效果。</p> 
<p>        这种方式可以解决集中热点问题，但是无法根治。命中率随着流量随机性的降低而升高，这取决于流量分发层策略和设计。</p> 
<p><strong>缓存数据压缩</strong></p> 
<p>        一般压缩率可观，但是遇到超大文件仍然无法根本解决问题。</p> 
<p><strong>大 key 拆解</strong></p> 
<p>        这种需要对缓存数据中的作用和业务需求有全面的分析，分类讨论。抽象出基本信息，多 key信息存储。直接影响是原来获取一次，现在需要获取多次，极端情况下，有长尾请求的 bad case，可以根据具体情况优化逻辑，全局考虑下一般可接受。由于大 key 拆分，需要先改校验规则，再上线新逻辑。</p> 
<p>        综上，正对业务使用的大 key缓存需求，本质要求设计者和编程者懂业务，对缓存目标有一定的认知，了解缓存的利弊，使用时根据情况取舍粒度，全面思考和逻辑闭环。      </p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a0401e0128ae34f1b54de484feebecd3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">特斯拉财报看点：FSD拳打华为，Robotaxi 脚踢百度</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/30d711ff66915ce023a0bae83fd942e8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">手撕数据结构---------顺序表和链表</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>