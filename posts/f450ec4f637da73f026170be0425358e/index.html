<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【北京迅为】《i.MX8MM嵌入式Linux开发指南》-第三篇 嵌入式Linux驱动开发篇-第三十九章 Linux MISC驱动 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/f450ec4f637da73f026170be0425358e/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【北京迅为】《i.MX8MM嵌入式Linux开发指南》-第三篇 嵌入式Linux驱动开发篇-第三十九章 Linux MISC驱动">
  <meta property="og:description" content="i.MX8MM处理器采用了先进的14LPCFinFET工艺，提供更快的速度和更高的电源效率;四核Cortex-A53，单核Cortex-M4，多达五个内核 ，主频高达1.8GHz，2G DDR4内存、8G EMMC存储。千兆工业级以太网、MIPI-DSI、USB HOST、WIFI/BT、4G模块、CAN、RS485等接口一应俱全。H264、VP8视频硬编码，H.264、H.265、VP8、VP9视频硬解码，并提供相关历程,支持8路PDM接口、5路SAI接口、2路Speaker。系统支持Android9.0(支持获取root限)Linux4.14.78&#43;Qt5.10.1、Yocto、Ubuntu20、Debian9系统。适用于智能充电桩，物联网，工业控制，医疗，智能交通等，可用于任何通用工业和物联网应用、
【公众号】迅为电子
【粉丝群】258811263（加群获取驱动文档&#43;例程）
第三部分 Linux驱动基础 第三十九章 Linux MISC驱动 本章导读
Linux MISC驱动是最简单的字符设备驱动，学习MISC驱动将会为学习字符设备驱动奠定基础。
39.1 章节讲解了misc设备驱动的基本概念及函数使用方法
39.2 章节讲解了编写最简单的杂项设备驱动，并将其编译为驱动模块，在iTOP-3399开发板上运行测试。
本章内容对应视频讲解链接（在线观看）：
杂项设备驱动讲解 → 杂项设备驱动讲解_哔哩哔哩_bilibili
编写一个杂项设备驱动 → https://www.bilibili.com/video/BV1Vy4y1B7ta?p=10
程序源码在网盘资料“iTOP-i.MX8MM开发板\02-i.MX8MM开发板网盘资料汇总(不含光盘内容)\嵌入式Linux开发指南(iTOP-i.MX8MM)手册配套资料\2.驱动程序例程\02-杂项设备驱动实验”路径下。
39.1 misc设备驱动简介 本章节我们讲解杂项设备驱动，那么杂项设备驱动是属于我们linux三大设备驱动的哪一项呢？由于linux驱动倾向于分层设计，所以每个具体的设备都可以找到它归属的类型，从而可以套到它相应的架构里面去，我们只需要实现它最底层的那部分。但是也有部分字符设备，确实不知道它属于哪种类型，我们一般推荐大家采用miscdevice的框架结构。misc 的意思是混合的杂项的，所以 misc 设备驱动也叫做杂项设备驱动，当我们板子上的某个设备没有办法分类时，就可以用 misc 设备驱动。它的注册跟使用比较的简单，所以比较适用于功能简单的设备。正因为简单，所以它通常嵌套在 platform 总线驱动中，配合总线驱动达到更复杂，多功能的效果。杂项设备是字符设备的一种，杂项设备可以自动生成设备节点。
在学习misc设备驱动之前，先来了解几个基础概念。
概念1设备节点
我们可以启动我们的开发板，进入到dev目录下，dev目录下全部都是生成的设备节点，如下图所示：
我们的系统里面有很多杂项设备。我们可以输入以下命令来查看，如下图所示：
cat /proc/misc
概念2 杂项设备的优点
杂项设备除了比字符设备代码简单，还有别的区别吗？所有的 misc 设备驱动的主设备号都为 10，不同的设备使用不同的从设备号。主设设备号相同就可以节省内核的资源，在内核中大概可以找到200多处使用miscdevice框架结构的驱动。
概念3主设备号和次设备号的概念
设备号包含主设备号和次设备号，设备号是计算机识别设备的一种方式，主设备号相同的就被视为同一类设备，主设备号在Linux系统里面是唯一的，次设备号不一定唯一。主设备号可以比做成电话号码的区号。比如北京的区号是010，次设备号可以比作成电话号码。
主设备号可以通过以下命令来查看，前面的数字就是主设备号，如下图所示：
cat /proc/devices
misc 设备用 miscdevice 结构体表示，miscdevice结构体的定义在内核源码具体定义/home/topeet/linux/linux-imx/include/linux/miscdevice.h中，内容如下：
struct miscdevice { int minor; //次设备号 const char *name; //设备节点的名字 const struct file_operations *fops; //文件操作集 struct list_head list; struct device *parent; struct device *this_device; const struct attribute_group **groups; const char *nodename; umode_t mode; }; 当我们创建一个 misc 设备的 miscdevice 结构体时，需要我们指定 minor、name 和 fops 这三个成员变量。minor 表示次设备号，需要用户设置，在 Linux 内核中有一些预定义的 misc 设备的次设备号，定义在/home/topeet/linux/linux-imx/include/linux/miscdevice.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-22T13:48:47+08:00">
    <meta property="article:modified_time" content="2024-07-22T13:48:47+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【北京迅为】《i.MX8MM嵌入式Linux开发指南》-第三篇 嵌入式Linux驱动开发篇-第三十九章 Linux MISC驱动</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:justify;">i.MX8MM处理器采用了先进的14LPCFinFET工艺，提供更快的速度和更高的电源效率;四核Cortex-A53，单核Cortex-M4，多达五个内核 ，主频高达1.8GHz，2G DDR4内存、8G EMMC存储。千兆工业级以太网、MIPI-DSI、USB HOST、WIFI/BT、4G模块、CAN、RS485等接口一应俱全。H264、VP8视频硬编码，H.264、H.265、VP8、VP9视频硬解码，并提供相关历程,支持8路PDM接口、5路SAI接口、2路Speaker。系统支持Android9.0(支持获取root限)Linux4.14.78+Qt5.10.1、Yocto、Ubuntu20、Debian9系统。适用于智能充电桩，物联网，工业控制，医疗，智能交通等，可用于任何通用工业和物联网应用、</p> 
<p></p> 
<p>【公众号】迅为电子</p> 
<p>【粉丝群】258811263（加群获取驱动文档+例程）</p> 
<hr> 
<h2 style="text-align:center;"><strong><a name="_Toc21933"></a><strong><strong><a name="_Toc11729"></a><a name="_Toc27658"></a><a name="_Toc3578"></a><a name="_Toc32630"></a><a name="_Toc8478"></a><a name="_Toc3664"><span style="color:#494949;">第三部分 Linux驱动基础</span></a></strong></strong></strong></h2> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<h2 style="text-align:center;"><strong><a name="_Toc30425"></a><strong><strong><a name="_Toc9997"></a><a name="_Toc15134"></a><a name="_Toc27250"></a><a name="_Toc3558"></a><a name="_Toc17394"></a><a name="_Toc28499"><span style="color:#494949;">第</span></a></strong></strong><strong><strong><span style="color:#494949;">三</span>十九</strong></strong><strong><strong>章 </strong></strong><strong><strong>Linux MISC驱动</strong></strong></strong></h2> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#c00000;">本章导读</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">Linux MISC驱动是最简单的字符设备驱动，学习MISC驱动将会为学习字符设备驱动奠定基础。</p> 
<p style="margin-left:.0001pt;text-align:justify;">39.1 章节讲解了misc设备驱动的基本概念及函数使用方法</p> 
<p style="margin-left:.0001pt;text-align:justify;">39.2 章节讲解了编写最简单的杂项设备驱动，并将其编译为驱动模块，在iTOP-3399开发板上运行测试。</p> 
<p style="margin-left:.0001pt;text-align:justify;">本章内容对应视频讲解链接（在线观看）：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#1d41d5;">杂项设备驱动讲解</span> <span style="color:#1d41d5;">→</span> <a href="https://www.bilibili.com/video/BV1Vy4y1B7ta?p=9" rel="nofollow" title="杂项设备驱动讲解_哔哩哔哩_bilibili">杂项设备驱动讲解_哔哩哔哩_bilibili</a></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#1d41d5;">编写一个杂项设备驱动</span> <span style="color:#1d41d5;">→</span> <a href="https://www.bilibili.com/video/BV1Vy4y1B7ta?p=10&amp;share_source=copy_web" rel="nofollow" title="https://www.bilibili.com/video/BV1Vy4y1B7ta?p=10">https://www.bilibili.com/video/BV1Vy4y1B7ta?p=10</a></p> 
<p style="margin-left:.0001pt;text-align:justify;">程序源码在网盘资料“<span style="color:#ff0000;">iTOP-i.MX8MM开发板\02-i.MX8MM开发板网盘资料汇总(不含光盘内容)\嵌入式Linux开发指南(iTOP-i.MX8MM)手册配套资料\2.驱动程序例程\02-杂项设备驱动实验</span>”路径下。</p> 
<h3 style="text-align:justify;"><strong><a name="_Toc18457"></a><strong><strong><a name="_Toc8611"></a><a name="_Toc26874"></a><a name="_Toc13741"></a><a name="_Toc3861"></a><a name="_Toc13716"></a><a name="_Toc28550">39</a></strong></strong><strong><strong>.1 </strong></strong><strong><strong>misc设备驱动简介</strong></strong></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">本</span><span style="color:#000000;">章节我们</span><span style="color:#000000;">讲解</span><span style="color:#000000;">杂项设备驱动，那么杂项设备驱动是属于我们linux三大设备驱动的哪一项呢？由于linux驱动倾向于分层设计，所以每个具体的设备都可以找到它归属的类型，从而可以套到它相应的架构里面去，我们只需要实现它最底层的那部分。但是也有部分字符设备，确实不知道它属于</span><span style="color:#000000;">哪种</span><span style="color:#000000;">类型，我们一般推荐大家采用miscdevice的框架结构。misc 的意思是混合的杂项的，所以 misc 设备驱动也叫做杂项设备驱动，当我们板子上的某个设备没有办法分类时，就可以用 misc 设备驱动。它的注册跟使用比较的简单，所以比较适用于功能简单的设备。正因为简单，所以它通常嵌套在 platform 总线驱动中，配合总线驱动达到更复杂，多功能的效果。杂项设备是字符设备的一种，杂项设备可以自动生成设备节点。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">在学习misc设备驱动之前，先来了解几个基础概念。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#0070c0;">概念1</span><span style="color:#0070c0;">设备节点</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">我们可以启动我们的开发板，进入到dev目录下，dev目录下全部都是生成的设备节点，如下图所示：</span></p> 
<p style="margin-left:.0001pt;text-align:center;"><span style="color:#000000;"><img alt="" src="https://images2.imgbox.com/fa/90/QdDpm4zK_o.png"></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">我们的系统里面有很多杂项设备。我们可以输入</span><span style="color:#000000;">以下命令</span><span style="color:#000000;">来查看，如下图所示</span><span style="color:#000000;">：</span></p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">cat /proc/misc</span></p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/fc/e9/KFi6K4iB_o.png"> </p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#0070c0;">概念2 杂项设备的优点</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">杂项设备除了比字符设备代码简单，还有别的区别吗？所有的 misc 设备驱动的主设备号都为 10，不同的设备使用不同的从设备号。主设设备号相同就可以节省内核的资源</span><span style="color:#000000;">，</span><span style="color:#000000;">在内核中大概可以找到200多处使用miscdevice框架结构的驱动。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#0070c0;">概念3主设备号和次设备号的概念</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">设备号包含主设备号和次设备号，设备号是计算机识别设备的一种方式，主设备号相同的就被视为同一类设备，主设备号在Linux系统里面是唯一的，次设备号不一定唯一。主设备号可以比做成电话号码的区号。比如北京的区号是010，次设备号可以比作成电话号码。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">主设备号可以通过</span><span style="color:#000000;">以下</span><span style="color:#000000;">命令来查看，前面的数字就是主设备号，如下图所示：</span></p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#dddddd;"><span style="color:#000000;">cat /proc/devices</span></span></p> 
</blockquote> 
<p style="text-align:justify;"> </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e1/94/qmcrKJCY_o.png"></p> 
<p style="text-align:justify;"><span style="color:#000000;">misc 设备用 miscdevice 结构体表示，miscdevice结构体的定义在内核源码具体定义/home/topeet/linux/linux-imx/include/linux/miscdevice.h中</span><span style="color:#000000;">，</span><span style="color:#000000;">内容如下：</span></p> 
<pre><code class="language-cpp">struct miscdevice  {
    int minor; //次设备号
    const char *name; //设备节点的名字
    const struct file_operations *fops; //文件操作集
    struct list_head list;
    struct device *parent;
    struct device *this_device;
    const struct attribute_group **groups;
    const char *nodename;
    umode_t mode;
};</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">当我们创建一个 misc 设备的 miscdevice 结构体时，需要我们指定 minor、name 和 fops 这三个成员变量。minor 表示</span><span style="color:#000000;">次</span><span style="color:#000000;">设备号，需要用户设置，在 Linux 内核中有一些预定义的 misc 设备的</span><span style="color:#000000;">次</span><span style="color:#000000;">设备号，定义在/home/topeet/linux/linux-imx/include/linux/miscdevice.h文件中，如下所示：</span></p> 
<pre><code class="language-cpp">#define PSMOUSE_MINOR 1
#define MS_BUSMOUSE_MINOR 2 /* unused */
#define ATIXL_BUSMOUSE_MINOR 3 /* unused */
 /*#define AMIGAMOUSE_MINOR 4 FIXME OBSOLETE */
#define ATARIMOUSE_MINOR 5 /* unused */
#define SUN_MOUSE_MINOR 6 /* unused */
......
#define MISC_DYNAMIC_MINOR 255</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">我们设置子设备号时要注意不要重复使用其他设备的子设备号。可以从这些预定义的子设备号中选择</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">一个，也可以自定义。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">name 就是这个 misc 设备的名字，当设备注册成功后，会在/dev 目录下自动生成一个名为 name 的设备文件。fops 就是这个 misc 设备的操作集合。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">当创建好miscdevice 结构体后，使用 misc_register 函数向系统中注册一个misc设备，函数原型如下：</span></p> 
<table border="1" cellspacing="0" style="margin-left:6.75pt;"><tbody><tr><td style="background-color:#8db3e2;width:63.6pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">函数</span></p> </td><td style="background-color:#f5f6f8;width:400pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">int misc_register(struct miscdevice * misc)</span></p> </td></tr><tr><td style="background-color:#8db3e2;width:63.6pt;"> <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">参数 misc</span></p> </td><td style="background-color:#f5f6f8;width:400pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">之前创建好的 miscdevice 结构体</span></p> </td></tr><tr><td style="background-color:#8db3e2;width:63.6pt;"> <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">返回值</span></p> </td><td style="background-color:#f5f6f8;width:400pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">成功返回 0，失败返回负数。</span></p> </td></tr></tbody></table> 
<p> </p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">我们设置子设备号时要注意不要重复使用其他设备的子设备号。可以从这些预定义的子设备号中选择</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">一个，也可以自定义。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">name 就是这个 misc 设备的名字，当设备注册成功后，会在/dev 目录下自动生成一个名为 name 的设备文件。fops 就是这个 misc 设备的操作集合。</span></p> 
<table border="1" cellspacing="0" style="margin-left:18.25pt;"><tbody><tr><td style="background-color:#8db3e2;width:63.05pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">函数</span></p> </td><td style="background-color:#f5f6f8;width:401.7pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">int misc_deregister(struct miscdevice *misc)</span></p> </td></tr><tr><td style="background-color:#8db3e2;width:63.05pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">参数</span><span style="color:#000000;">misc</span></p> </td><td style="background-color:#f5f6f8;width:401.7pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">要注销的 miscdevice 结构体。</span></p> </td></tr><tr><td style="background-color:#8db3e2;width:63.05pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">返回值</span></p> </td><td style="background-color:#f5f6f8;width:401.7pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">无</span></p> </td></tr></tbody></table> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">在miscdevice结构体的第四行，它指向了一个file_operation的结构体。file_operations文件操作集在定义在include/linux/fs.h下面，如下图所示。</span></p> 
<p style="margin-left:.0001pt;text-align:center;"><span style="color:#000000;"><img alt="" src="https://images2.imgbox.com/08/ca/8fmAPUnX_o.png"></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">file_operations中的成员函数实际是由drivers/char/misc.c中misc驱动核心层的misc_fops成员函数间接调用的。file_operations结构体里面的结构体成员都对应一个调用。简单介绍一下其中比较常用的函数：</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">llseek()函数用来修改一个文件的当前的读写位置，并将新位置返回。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">read()函数用来从设备中读取数据，成功时返回读取到的字节数，出错返回一个负值。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">write()函数用来向设备发送数据，成功时返回该函数写入的字节数。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">poll()函数用于查询设备是否可以进行非阻塞读写。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">unlock_ioctl()函数提供设备相关控制命令的实现。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">mmap()函数将设备内存映射到进程的虚拟地址空间中。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">open()函数用于打开设备文件。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">release()函数用于关闭设备文件。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#fabf8f;"><span style="color:#000000;">注册杂项设备有一个通用的思路和方法，这里给大家总结为三个步骤：</span></span></p> 
<ul><li style="text-align:justify;"><span style="color:#000000;">填充miscdevice这个结构体</span></li><li style="text-align:justify;"><span style="color:#000000;">填充file_operations这个结构体</span></li><li style="text-align:justify;"><span style="color:#000000;">注册杂项设备并生生成设备节点。</span></li></ul> 
<p> </p> 
<h3 style="text-align:justify;"><strong><strong><strong>39</strong></strong><strong><strong>.</strong></strong><strong><strong>2 编写实验程序</strong></strong></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify;">通过39.1章节的学习，我们已经把杂项设备的基本概念搞懂了，在本实验中，使用 misc 设备驱动的方式来编写最简单的杂项设备的驱动。</p> 
<h4 style="text-align:justify;"><strong><strong><strong>39.2.1 编写驱动例程</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">首先我们回想一下注册杂项设备的三大流程，我们在Windows上面新建misc.c文件，并用sourceinsight打开。我们可以将上次编写的helloworld.c里面的代码拷贝到misc.c文件，并修改为如下图所示：</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/01/19/Y4g4n0uR_o.png"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>添加头文件</strong></strong></p> 
<blockquote> 
 <p>/*注册杂项设备头文件*/</p> 
 <p>#include &lt;linux/miscdevice.h&gt;</p> 
 <p>/*注册设备节点的文件结构体*/</p> 
 <p>#include &lt;linux/fs.h&gt;</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>填充miscdevice结构体</strong></strong></p> 
<blockquote> 
 <p style="margin-left:0;text-align:justify;"><span style="color:#000000;"><span style="color:#000000;">struct miscdevice  misc_dev = {<!-- --></span></span></p> 
 <p style="margin-left:0;text-align:justify;"><span style="color:#000000;"><span style="color:#000000;">.minor = MISC_DYNAMIC_MINOR,</span></span></p> 
 <p style="margin-left:0;text-align:justify;"><span style="color:#000000;"><span style="color:#000000;">.name = "hello_misc",</span></span></p> 
 <p style="margin-left:0;text-align:justify;"><span style="color:#000000;"><span style="color:#000000;">.fops = &amp;misc_fops,</span></span></p> 
 <p style="margin-left:0;text-align:justify;"><span style="color:#000000;"><span style="color:#000000;">};</span></span></p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">上述代码第2行的minor为</span><span style="color:#000000;">MISC_DYNAMIC_MINOR</span><span style="color:#000000;">，miscdevice核心层会自动找一个空闲的次设备号，否则用minor指定的次设备号。上述代码第3行name是设备的名称，我们自定义为"hello_misc"</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>填充</strong></strong><strong><strong>file_operations</strong></strong><strong><strong>结构体</strong></strong></p> 
<blockquote> 
 <p> <span style="color:#000000;"><span style="color:#000000;">struct file_operations misc_fops={<!-- --></span></span></p> 
 <p style="margin-left:0;text-align:justify;"><span style="color:#000000;"><span style="color:#000000;">.owner = THIS_MODULE</span></span></p> 
 <p style="margin-left:0;text-align:justify;"><span style="color:#000000;"><span style="color:#000000;">};</span></span></p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">THIS_MODULE宏是什么意思呢？它在include/linux/module.h里的定义是</span></p> 
<blockquote> 
 <p style="margin-left:0;text-align:justify;"><span style="color:#000000;"><span style="color:#000000;">#define THIS_MODULE (&amp;__this_module)</span></span></p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">它是一个struct module变量，代表当前模块，可以通过THIS_MODULE宏来引用模块的struct module结构，比如使用THIS_MODULE-&gt;state可以获得当前模块的状态。这个owner指针指向的就是你的模块。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>注册杂项设备并生成设备节点</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">在misc_init</span><span style="color:#000000;">()</span><span style="color:#000000;">函数中填充misc_register()函数注册杂项设备，并判断杂项设备是否注册成功。</span></p> 
<pre><code class="language-cpp">static int misc_init(void){
    int ret;
    ret = misc_register(&amp;misc_dev);             //注册杂项设备
    if(ret&lt;0)                                   //判断杂项设备是否注册成功
    {
        printk("misc registe is error \n");     //打印杂项设备注册失败
    }
    printk("misc registe is succeed \n");       //打印杂项设备注册成功
    return 0;
}
在misc_exit（）函数中填充misc_deregister()函数注销杂项设备。
 static void misc_exit(void){
    misc_deregister(&amp;misc_dev);                 //注销杂项设备
    printk("misc gooodbye! \n");                //打印杂项设备注销成功
}</code></pre> 
<p> 完整的代码如下图所示：</p> 
<pre><code class="language-cpp">/*
 * @Descripttion: 最简单的杂项设备驱动
 * @version: 1.0
 * @Author: topeet
 */
#include &lt;linux/init.h&gt;              //初始化头文件
#include &lt;linux/module.h&gt;            //最基本的文件，支持动态添加和卸载模块。
#include &lt;linux/miscdevice.h&gt;        /*注册杂项设备头文件*/
#include &lt;linux/fs.h&gt;                /*注册设备节点的文件结构体*/
struct file_operations misc_fops = { //文件操作集
    .owner = THIS_MODULE};
struct miscdevice misc_dev = {
    //杂项设备结构体
    .minor = MISC_DYNAMIC_MINOR, //动态申请的次设备号
    .name = "hello_misc",        //杂项设备名字是hello_misc
    .fops = &amp;misc_fops,          //文件操作集

};
static int misc_init(void)
{ //在初始化函数中注册杂项设备
    int ret;
    ret = misc_register(&amp;misc_dev);
    if (ret &lt; 0)
    {
        printk("misc registe is error \n");
    }
    printk("misc registe is succeed \n");
    return 0;
}
static void misc_exit(void)
{ //在卸载函数中注销杂项设备
    misc_deregister(&amp;misc_dev);
    printk(" misc gooodbye! \n");
}
module_init(misc_init);
module_exit(misc_exit);
MODULE_LICENSE("GPL");</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">现在最简单的杂项设备的驱动就写完了，那么接下来我们可以把这个驱动编译一下，然后放到我们的开发板上面运行。我们编译驱动，可以将它编译进内核里面，也可以将它编译成模块。</p> 
<h4 style="text-align:justify;"><strong><a name="_Toc30300"></a><strong><strong><a name="_Toc13066"></a><a name="_Toc4637"></a><a name="_Toc32685"></a><a name="_Toc13522"></a><a name="_Toc23012"></a><a name="_Toc29263">39.2.2 编译驱动程序</a></strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">这里我们以iTOP-i.MX8MM开发板为例，将杂项设备驱动编译成模块，请参考本手册<a href="#_%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B9%9D%E7%AB%A0%20%E7%BC%96%E8%AF%91%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97" rel="nofollow"><u><span style="color:#0000ff;"><u>第三十</u></span></u><u><span style="color:#0000ff;"><u>七</u></span></u><u><span style="color:#0000ff;"><u>章 </u></span></u></a><u><span style="color:#0000ff;"><u>Linux内核模块</u></span></u>。我们将misc.c文件拷贝到Ubuntu的/home/topeet/imx8m/02目录下。将上次编译helloworld的Makefile文件和build.sh脚本拷贝到misc.c同级目录下，修改Makefile为：</p> 
<pre><code class="language-cpp">obj-m += misc.o
KDIR:=/home/topeet/linux/linux-imx
PWD?=$(shell pwd)
all:
	make -C $(KDIR) M=$(PWD) modules
clean:
	make -C $(KDIR) M=$(PWD) clean</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">文件如下图所示：</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/eb/9c/JP2MFNaU_o.png"></p> 
<p style="margin-left:.0001pt;text-align:justify;">驱动编译成功生成了ko文件，如下图所示：</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/06/cc/nCHV2V5R_o.png"></p> 
<h4 style="text-align:justify;"><strong><strong><strong>39.2.3 运行测试</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">启动iTOP-iMX8MM开发板，我们通过nfs挂载共享文件目录，我们进入到共享目录，加载驱动模块如图所示：</p> 
<blockquote> 
 <p>insmod misc.ko</p> 
</blockquote> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/a2/d9/udK7iOR9_o.png"></p> 
<p style="margin-left:.0001pt;text-align:justify;">驱动加载成功后，输入以下命令，查看注册的设备节点是否存在，如下图所示，设备节点存在。</p> 
<blockquote> 
 <p>ls /dev/h*</p> 
</blockquote> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/95/83/6b6HQT7g_o.png"></p> 
<p style="margin-left:.0001pt;text-align:justify;">我们输入以下命令拆卸驱动模块,如下图所示：</p> 
<blockquote> 
 <p>rmmod misc</p> 
</blockquote> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/38/8a/vLFUYF7b_o.png"></p> 
<p>那么，现在最简单的杂项设备已经完成了。 </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ae119b72e7cdf59b95d85d105af5e0bd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[css3] 如何设置边框颜色渐变</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/989a5bc12f629c38ea1f190eed25a12a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43;：从C到C&#43;&#43;的飞跃之旅（C&#43;&#43;基础知识）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>