<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>一篇文章讲透数据结构之树and二叉树 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/6f12df46f16a96fd9b6e47403849a2b5/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="一篇文章讲透数据结构之树and二叉树">
  <meta property="og:description" content="一.树 1.1树的定义 树是一种非线性的数据结构，它是有n个有限结点组成的一个具有层次关系的集合。把它叫做树是因为它看起来像一棵倒挂的树，也就是说它是根在上，叶在下的。
在树中有一个特殊的结点，称为根结点，根结点没有前驱结点
除根结点外，其余的结点被分成了M个互不相交的集合T1、T2、......、Tm，其中每一个集合Ti又是一棵结构与树类似的子树。每棵子树的根结点有且只有一个前驱结点，但可以有0个或多个后继结点。因此：树是递归定义的。
注意：树的结点之间是不可以有交集的，有交集的话就不是树了，至于是什么我们后期再说。
如下图：以A为根节点的就不是树，以D为结点的才是树。
1.2树的基本概念 结点的度：一个结点含有的子树的个数称为该结点的度叶子结点：度为0的结点称为叶子结点分支结点：度不为0的结点双亲结点/父结点：若一个结点包含子节点，则这个结点称为其子结点的父节点孩子结点/子节点：一个结点含有的子树的根结点称为该结点的子节点兄弟结点：具有相同父节点的结点互称为兄弟结点树的度：一棵树中，度最大的结点的度称为树的度结点的层次：定义根为第一层，根的子节点为第二层，依次类推即可树的高度或深度：树中结点的最大层次堂兄弟结点：双亲在同一层的结点互为堂兄弟结点结点的祖先：从根到该结点所经分支上的所有结点。子孙：以某结点为根的子树的任一结点都称为该结点的子孙。森林：由m棵互不相交的树组成的集合称为森林。 1.3树的表示方法 我们在这里学习三种树的表示方法，分别为双亲表示法、树的孩子表示法、左孩子右兄弟表示法。
我们将用这三种方法来表示这一棵树：
1.3.1父节点表示法（双亲表示法） 树的父节点表示法，是利用顺序表来完成的，怎么做呢？
首先，我们创建顺序表结构体来存储结点的内容以及父节点的下标。我们将这个结构体称为结点结构体。
然后，我们创建树的结构体，其中一个是结点结构体数组，一个是数组内元素个数。
由此，我们可以写出如下代码：
//双亲表示法 //顺序表的方式存储 //顺序表存储结点的数据和双亲结点的下标 typedef int DataType; typedef struct Node { DataType data;//数据域 int parent;//双亲结点下标 }Node; //树--&gt;结点组成的数组 typedef struct Tree { Node NodeArr[10];//保存结点的数组，也可以动态申请 int size;//结点个数 }; 在这里需要我们大家注意的是：由于根节点没有前驱结点，我们将其的父节点特别记为-1. 下面我们来表示一下这棵树。
1.3.2树的孩子表示法 树的孩子表示法是通过顺序表和链表结合的形式表示的
它的原理是：
先定义一个单链表结构体表示一个父节点的所有孩子结点的下标，一个孩子指向另外一个孩子然后用一个顺序表结构体存储当前结点的数值以及这个结点的第一个孩子结点的下标最后定义一个树结构体 那么，我们就可以写出如下代码：
typedef int DataType; //链表 struct ListNode { int child;//当前孩子结点下标 struct Listnode* next;//下一个孩子 }; //顺序表 struct Node { DataType data;//结点的数据 ListNode* FirstChild;//第一个孩子 }; struct Tree { Node NodeArr[10]; int size; }; 现在我们画图来理解一下这个方法">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-04T07:55:05+08:00">
    <meta property="article:modified_time" content="2024-06-04T07:55:05+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">一篇文章讲透数据结构之树and二叉树</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一.树</h2> 
<h3>1.1树的定义</h3> 
<p>树是一种<strong>非线性</strong>的数据结构，它是有n个有限结点组成的一个具有层次关系的集合。<strong>把它叫做树是因为它看起来像一棵倒挂的树</strong>，也就是说它是<strong>根在上，叶在下</strong>的。</p> 
<p><img alt="" height="505" src="https://images2.imgbox.com/04/3e/KogQgDmR_o.png" width="750"></p> 
<p>在树中有一个特殊的结点，称为<strong>根结点</strong>，<strong>根结点</strong>没有前驱结点</p> 
<p>除根结点外，其余的结点被分成了M个互不相交的集合T1、T2、......、Tm，其中每一个集合Ti又是一棵结构与树类似的子树。每棵子树的根结点有且只有一个前驱结点，但可以有0个或多个后继结点。因此：<strong>树是递归定义的。</strong></p> 
<p>注意：<strong>树的结点之间是不可以有交集的</strong>，有交集的话就不是树了，至于是什么我们后期再说。</p> 
<p>如下图：<strong>以A为根节点的就不是树，以D为结点的才是树。</strong></p> 
<p><img alt="" height="495" src="https://images2.imgbox.com/73/85/FYDy5EsB_o.png" width="770">  </p> 
<h3>1.2树的基本概念</h3> 
<p><img alt="" height="511" src="https://images2.imgbox.com/3a/e9/pGK8hcF7_o.png" width="997"></p> 
<ol><li><span style="color:#fe2c24;"><strong>结点的度</strong>：一个结点含有的子树的个数称为该结点的度</span></li><li><span style="color:#fe2c24;"><strong>叶子结点</strong>：度为0的结点称为叶子结点</span></li><li><strong>分支结点</strong>：度不为0的结点</li><li><span style="color:#fe2c24;"><strong>双亲结点/父结点</strong>：若一个结点包含子节点，则这个结点称为其子结点的父节点</span></li><li><span style="color:#fe2c24;"><strong>孩子结点/子节点</strong>：一个结点含有的子树的根结点称为该结点的子节点</span></li><li><strong>兄弟结点</strong>：具有相同父节点的结点互称为兄弟结点</li><li><strong>树的度</strong>：一棵树中，度最大的结点的度称为树的度</li><li><strong>结点的层次</strong>：定义根为第一层，根的子节点为第二层，依次类推即可</li><li><span style="color:#fe2c24;"><strong>树的高度或深度</strong>：树中结点的最大层次</span></li><li><strong>堂兄弟结点</strong>：双亲在同一层的结点互为堂兄弟结点</li><li><span style="color:#fe2c24;"><strong>结点的祖先</strong>：从根到该结点所经分支上的所有结点。</span></li><li><span style="color:#fe2c24;"><strong>子孙</strong>：以某结点为根的子树的任一结点都称为该结点的子孙。</span></li><li><strong>森林</strong>：由m棵互不相交的树组成的集合称为森林。</li></ol> 
<h3>1.3树的表示方法</h3> 
<p>我们在这里学习三种树的表示方法，分别为<strong>双亲表示法、树的孩子表示法、左孩子右兄弟表示法</strong>。</p> 
<p>我们将用这三种方法来表示这一棵树：</p> 
<p><img alt="" height="642" src="https://images2.imgbox.com/f1/70/mvI0OTl3_o.png" width="840"></p> 
<h4>1.3.1父节点表示法（双亲表示法）</h4> 
<p>树的父节点表示法，是利用顺序表来完成的，怎么做呢？</p> 
<p>首先，我们创建顺序表结构体来存储结点的内容以及父节点的下标。我们将这个结构体称为结点结构体。</p> 
<p>然后，我们创建树的结构体，其中一个是结点结构体数组，一个是数组内元素个数。</p> 
<p>由此，我们可以写出如下代码：</p> 
<pre><code class="language-cpp">//双亲表示法
//顺序表的方式存储
//顺序表存储结点的数据和双亲结点的下标
typedef int DataType;
typedef struct Node
{
	DataType data;//数据域
	int parent;//双亲结点下标
}Node;
//树--&gt;结点组成的数组
typedef struct Tree
{
	Node NodeArr[10];//保存结点的数组，也可以动态申请
	int size;//结点个数
};</code></pre> 
<p>在这里需要我们大家注意的是：由于根节点没有前驱结点，我们将其的父节点特别记为-1. </p> 
<p>下面我们来表示一下这棵树。</p> 
<p><img alt="" height="624" src="https://images2.imgbox.com/da/5c/6OSHcFQB_o.png" width="982"></p> 
<h4>1.3.2树的孩子表示法</h4> 
<p>树的孩子表示法是通过<strong>顺序表和链表结合</strong>的形式表示的</p> 
<p>它的原理是：</p> 
<ul><li>先定义一个单链表结构体表示一个父节点的所有孩子结点的下标，一个孩子指向另外一个孩子</li><li>然后用一个顺序表结构体存储当前结点的数值以及这个结点的第一个孩子结点的下标</li><li>最后定义一个树结构体</li></ul> 
<p>那么，我们就可以写出如下代码：</p> 
<pre><code class="language-cpp">typedef int DataType;
//链表
struct ListNode
{
	int child;//当前孩子结点下标
	struct Listnode* next;//下一个孩子
};
//顺序表
struct Node
{
	DataType data;//结点的数据
	ListNode* FirstChild;//第一个孩子
};
struct Tree
{
	Node NodeArr[10];
	int size;
};</code></pre> 
<p>现在我们画图来理解一下这个方法</p> 
<ul><li>绿色的是全部的链表结构体（每个单链表之间没有关系）</li><li>绿色的每一块是一个单链表</li><li>紫色中的每一块是一个顺序表</li><li>由于图的篇幅有限，将一个树分开画了，紫色的其实是一个整体</li><li>紫色每一块的右下角是元素的个数</li></ul> 
<p> <img alt="" height="726" src="https://images2.imgbox.com/89/5f/0GNBNxJY_o.png" width="1200"></p> 
<p>这个方法的缺点就是：我们要在顺序表中插入或者删除数据需要移动大量的数据。 </p> 
<h4>1.3.3左孩子右兄弟表示法</h4> 
<p>这个是最常用的表示树的的方法，即定义两个指针，让<strong>左指针指向最左边的子节点，右指针指向兄弟节点。</strong></p> 
<p>如果没有节点，则都指向空。</p> 
<pre><code class="language-cpp">typedef int DataType;
struct Node
{
	struct Node* leftChild;//孩子结点
	struct Node* rightBrother;//指向下一个兄弟结点
	DataType Data;//数据域
};</code></pre> 
<p>我们下面具体画一下图： </p> 
<p><img alt="" height="366" src="https://images2.imgbox.com/66/25/gfLAfzee_o.png" width="921"></p> 
<h3>1.4树的实际应用</h3> 
<p>在linux环境下目录结构就是有一颗树构成。</p> 
<p>而在Windows环境下，目录许多内容并不交叉，所以是由森林构成。</p> 
<p><img alt="" height="628" src="https://images2.imgbox.com/d7/52/ASe1cT8J_o.png" width="1119"></p> 
<h2>二.二叉树</h2> 
<h3>2.1二叉树的定义</h3> 
<p>一棵二叉树是结点的一个有限集合，该集合：</p> 
<p>1.或者为空</p> 
<p>2.由一个根节点加上两棵别称（别名/外号）为：左子树、右子树的二叉树组成</p> 
<p><img alt="" height="501" src="https://images2.imgbox.com/ca/32/EQ9vNSRw_o.png" width="952"></p> 
<p>从上图可以看出</p> 
<ul><li>二叉树不存在度大于2的结点</li><li>二叉树的子树有左右之分，次序不能颠倒， 因此二叉树是有序树</li></ul> 
<p>我们可以将一棵二叉树拆分开来，我们会发现任何一棵二叉树都是由以下几种情况复合而来的：</p> 
<p><img alt="" height="293" src="https://images2.imgbox.com/39/61/oUmDp0mL_o.png" width="904"></p> 
<p>下面给大家看一张现实生活中存在的二叉树： </p> 
<p><img alt="" height="381" src="https://images2.imgbox.com/ee/e2/sr60OCHN_o.png" width="441"></p> 
<h3>2.2特殊的二叉树</h3> 
<ul><li>满二叉树：</li></ul> 
<p>一个二叉树，如果每一层的节点数都达到了最大值，那么这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是2^k-1，则它就是满二叉树。</p> 
<ul><li>完全二叉树：</li></ul> 
<p>完全二叉树是一种效率很高的数据结构。</p> 
<p>完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1到n的结点都可以一一对应时，则可称之为完全二叉树。也就是说：满二叉树是一种特殊的完全二叉树。（<strong>文字表述蛮抽象的，其实就是倒数第二层满，最后一层的叶子结点要从左往右放</strong>）</p> 
<p><img alt="" height="271" src="https://images2.imgbox.com/8c/80/aCIBgZqU_o.png" width="923"></p> 
<h3>2.3二叉树的相关性质</h3> 
<p>1. 若规定根结点的层数为1，则一棵非空二叉树的第i层上最多有2^(i-1)个结点.<br> 2. 若规定根结点的层数为1，则深度为h的二叉树的最大结点数是2^h-1.<br> 3. 对任何一棵二叉树, 如果度为0其叶结点个数为 , 度为2的分支结点个数为 ,则有 n0＝n2＋1</p> 
<p>4.若规定根结点的层数为1，具有n个结点的<strong>满二叉树的深度</strong>，h=log(n+1)</p> 
<p>5.对于具有n个结点的完全二叉树，如果按照从上至下从左至右的数组顺序对所有结点从0开始编号，则对<br> 于序号为i的结点有：</p> 
<blockquote> 
 <p>1. 若i&gt;0，i位置结点的双亲序号：(i-1)/2；i=0，i为根结点编号，无双亲结点<br> 2. 若2i+1&lt;n，左孩子序号：2i+1，2i+1&gt;=n否则无左孩子<br> 3. 若2i+2&lt;n，右孩子序号：2i+2，2i+2&gt;=n否则无右孩子</p> 
</blockquote> 
<p>结论3的推导过程：<br><img alt="" height="698" src="https://images2.imgbox.com/5b/b7/26am2bth_o.png" width="1200"></p> 
<p> 其余结论的推导过程可参考：<a class="link-info" href="https://blog.csdn.net/duanku111/article/details/139182151?spm=1001.2014.3001.5502" title="堆的实现 ">堆的实现 </a></p> 
<h3>2.4二叉树的存储</h3> 
<p>二叉树一般使用两种结构存储，一种顺序结构，一种链式结构。</p> 
<h4>2.4.1顺序结构</h4> 
<p>顺序结构存储就是使用数组来存储，一般使用数组只适合表示完全二叉树。</p> 
<p>因为<strong>不是完全二叉树会有空间的浪费。</strong></p> 
<p>而现实中使用中只有堆才会使用数组来存储，关于堆的实现可以参考上面的链接。</p> 
<p>二叉树顺序存储在物理上是一个数组，在逻辑上是一颗二叉树。</p> 
<p></p> 
<p>如下图，左边是完全二叉树，不会有空间浪费；</p> 
<p>右边是不完全二叉树，有空间浪费。</p> 
<p><img alt="" height="617" src="https://images2.imgbox.com/d2/d7/U1gfxNSf_o.png" width="1200"></p> 
<h4>2.4.2链式存储 </h4> 
<p>二叉树的链式存储结构是指，用链表来表示一棵二叉树，即用链来指示元素的逻辑关系。 通常的方法是链表中<strong>每个结点由三个域组成，数据域和左右指针域，左右指针分别用来给出该结点左孩子和右孩子所在的链结点的存储地址</strong> 。</p> 
<p>如下图所示：</p> 
<p>最左边是存储结构，中间是二叉树实例，右边是逻辑结构图。</p> 
<p><img alt="" height="661" src="https://images2.imgbox.com/3b/3f/qFhYAOtf_o.png" width="1200"></p> 
<p>在这里我们采用链式结构来存储二叉树：</p> 
<h3>2.5二叉树的遍历</h3> 
<p>二叉树的遍历方式有四种：前序遍历、中序遍历、后序遍历、层序遍历</p> 
<p>二叉树的前、中、后序遍历都可以通过递归和用栈模拟递归实现，这里我们学习这两种方法.</p> 
<p>大家可以先研究代码，理解困难的话可以根据视频学习：</p> 
<p>视频1：</p> 
<div class="csdn-video-box"> 
 <iframe id="Gz0VWhit-1717247233511" frameborder="0" src="https://player.bilibili.com/player.html?aid=1655284539" allowfullscreen="true" data-mediaembed="bilibili"></iframe> 
 <p>二叉树的前中后序遍历的递归实现</p> 
</div> 
<p>视频2：</p> 
<div class="csdn-video-box"> 
 <iframe id="bThCsVMV-1717247146291" frameborder="0" src="https://player.bilibili.com/player.html?aid=1355408705" allowfullscreen="true" data-mediaembed="bilibili"></iframe> 
 <p>二叉树前中后序遍历的非递归实现以及层序遍历</p> 
</div> 
<p></p> 
<h4>2.5.1前序遍历</h4> 
<p><strong>前序遍历</strong>：先遍历根节点，再依次遍历左子树，右子树。而遍历左子树，又要先遍历根节点，再依次遍历左子树，右子树…...直到遍历完整棵树。</p> 
<p><img alt="" height="671" src="https://images2.imgbox.com/25/24/Anm2FWS2_o.png" width="1078"></p> 
<p><strong>递归实现 </strong></p> 
<pre><code class="language-cpp">void PreOrder1(BTree* root)
{
	assert(root);
	if (!root)
	{
		return;
	}
	printf("%d ", root-&gt;data);
	PreOrder(root-&gt;left);
	PreOrder(root-&gt;right);
}</code></pre> 
<p><strong> 非递归实现</strong></p> 
<pre><code class="language-cpp">typedef BTree* STDataType;
void PreOrder2(BTree* root)
{
	//开辟一个栈
	Stack s;
	StackInit(&amp;s);
	BTree* p = root;
	while (p || !IsEmpty(&amp;s))
	{
		if (p != NULL)
		{
			printf("%d ", p-&gt;data);
			StackPush(&amp;s, p);
			p = p-&gt;left;
		}
		else
		{
             p = StackTop(&amp;s);		    
             StackPop(&amp;s);
			p = p-&gt;right;
		}
	}
}</code></pre> 
<h4>2.5.2中序遍历</h4> 
<p>先遍历左子树，再依次遍历根节点，右子树。而遍历左子树，又要先遍历左子树，再依次遍历根节点，右子树…直至遍历完整棵树。</p> 
<p><strong>递归实现</strong></p> 
<pre><code class="language-cpp">void Inorder1(BTree*root)
{
    if (root == NULL)
    {
        return;
    }
    PreOrder(root-&gt;left);//左子树
    printf("%d ", root-&gt;data);//根节点
    PreOrder(root-&gt;right);//右子树
}
</code></pre> 
<p><strong>非递归实现 </strong></p> 
<pre><code class="language-cpp">  typedef BTree* STDataType;
  void Inorder2(BTree* root)
  {
	  Stack s;
	  InitStack(&amp;s);
	  BTree* p = root;
	  while (p || !IsEmpty(&amp;s))  
	  {
		  if (p != NULL)//入栈
		  {
			  StackPush(&amp;s, p);
			  p = p-&gt;left;
		  }
		  else
		  {
			  p = StackTop(&amp;s);
			  StackPop(&amp;s);	  
			  printf("%d ", p-&gt;data);
			  p = p-&gt;right;
		  }
	  }
  }
</code></pre> 
<h4>2.5.3后序遍历</h4> 
<p><strong>后序遍历</strong>：先遍历左子树，再依次遍历右子树，根节点。而遍历左子树，又要先遍历左子树，再依次遍历右子树，根节点…直至遍历完整棵树。</p> 
<p><strong>递归实现</strong></p> 
<pre><code class="language-cpp">void Postorder1(BTree*root)
{
    if (root == NULL)
    {
        return;
    }
    PreOrder(root-&gt;left);//左子树
    PreOrder(root-&gt;right);//右子树
    printf("%d ", root-&gt;data);//根节点
}
</code></pre> 
<p><strong> 非递归实现</strong></p> 
<pre><code class="language-cpp">void Postorder2(BTree* root)
{
	Stack s;
	InitStack(&amp;s);
	BTree* p = root;// p为遍历指针
	BTree* v = root;// v标记已访问节点
	while (p || !IsEmpty(&amp;s))  // 栈不为空或p不为空时循环
	{
		while(p != NULL)//入栈
		{
			StackPush(&amp;s, p);
			p = p-&gt;left;
		}
		p = StackTop(&amp;s);
		if (p-&gt;right &amp;&amp; p-&gt;right != v)//存在右子树，且没有被访问
		{
			p = p-&gt;right;//访问
		}
		else//没有右子树或者右子树已被访问
		{
			printf("%d ", p-&gt;data);
			v = p;//记录当前访问的节点
			p = NULL;//防止重复访问左子树
			StackPop(&amp;s);// 栈顶元素出栈
		}
	}
}
</code></pre> 
<h4>2.5.4层序遍历</h4> 
<p>层序遍历，就是一层一层的遍历。</p> 
<p>这里我们借助队列来实现。</p> 
<pre><code class="language-cpp">void leverOrder(BTree* root, Queue* pq)
{
	if (root == NULL)//为空直接返回
	{
		return;
	}
	QueuePush(pq, root);//插入第一个节点
	while (!QueueEmpty(pq))//队列不为空
	{
		BTree* p = QueueFront(pq);
		printf("%d ", p-&gt;data);
		QueuePop(pq);
		if (p-&gt;left != NULL)//带入左孩子
		{
			QueuePush(pq, p-&gt;left);
		}
		if (p-&gt;right != NULL)//带入右孩子
		{
			QueuePush(pq, p-&gt;right);
		}
	}
}</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6187384159e26e62e5b11cd87da54788/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">AI大模型探索之路-实战篇15： Agent智能数据分析平台之整合封装Tools和Memory功能代码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5cc937937dbe349a48be476a8b3ae234/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">OpenCV图像裁剪：使用&amp;运算符在OpenCV图像裁剪时进行边界检查</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>