<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>“双指针”算法上篇 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/247435006db832d4df4db6ee13519b29/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="“双指针”算法上篇">
  <meta property="og:description" content="『 你 的 名 字 』高帧4K动漫素材，无水印，需要自取！
题目： 一· 移动零 1.题目链接：移动零 2. 分析 解法一：暴力求解
就是新开一个数组，大小与原数组大小一致，只要不是数字0就进行写入，若是数字0，统计出现的
次数，最后把所有非0元素写入之后，在写入0元素。
对于一些没有思路的，老铁，刚刚看到此题，或许都会这样
但是，题目要求空间复杂度必须是O（N），所以这个想法就 “pass ” 掉了。
解法二：双指针算法
3. 原理 双指针：注意这里可不是真正意义上的指针：int*,char* ,float* …… 而是指向元素的下标
cur 指针：指向当前要扫描的元素
dest指针：指向已经被扫描过的元素
初始位置：dest = 0； cur = 0 （表示从左向右依次进行判断是否为数字0）
cur 指向元素为0，则&#43;&#43;cur
cur 指向元素非0，交换 cur，dest对应位置的元素，同时&#43;&#43;cur，&#43;&#43;dest
这里建议，咱还是先根据自己的理解，来编写程序，看看自己上手能力咋样哈~~~
4.OJ代码 class Solution { public: void moveZeroes(vector&lt;int&gt;&amp; nums) { int dest = 0,cur = 0; int n = nums.size(); for(;cur &lt; n;&#43;&#43;cur) { if(nums[cur] ) { swap(nums[dest&#43;&#43;],nums[cur]); } } } }; 二· 复写零 1.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-18T09:21:53+08:00">
    <meta property="article:modified_time" content="2024-08-18T09:21:53+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">“双指针”算法上篇</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="csdn-video-box" data-report-view='{"spm":"3001.10261","extra":{"id":"Hf85iQM7-1723936276735"}}'> 
 <iframe id="Hf85iQM7-1723936276735" frameborder="0" src="https://player.bilibili.com/player.html?aid=506464524" allowfullscreen="true" data-mediaembed="bilibili"></iframe> 
 <p>『 你 的 名 字 』高帧4K动漫素材，无水印，需要自取！</p> 
</div> 
<hr> 
<h5 style="background-color:transparent;">题目：</h5> 
<h5>一· 移动零</h5> 
<h6>1.题目链接：<a class="link-info" href="https://leetcode.cn/problems/move-zeroes/description/" rel="nofollow" title="移动零">移动零</a></h6> 
<p><img alt="" height="422" src="https://images2.imgbox.com/ba/51/3K5XprG7_o.png" width="531"></p> 
<h6>2. 分析</h6> 
<p><strong>解法一：暴力求解</strong></p> 
<p>就是<span style="background-color:#ffd900;">新开一个数组</span>，大小与原数组大小一致，只要不是数字0就进行写入，若是数字0，统计出现的</p> 
<p>次数，最后把所有非0元素写入之后，在写入0元素。</p> 
<p>对于一些没有思路的，老铁，刚刚看到此题，或许都会这样<img alt="" height="47" src="https://images2.imgbox.com/8e/e4/LbjHu0Xx_o.gif" width="47"></p> 
<p>但是，题目要<span style="background-color:#956fe7;">求空间复杂度必须是O（N）</span>，所以这个想法就 “pass ” 掉了。</p> 
<p><strong> 解法二：双指针算法</strong></p> 
<h6>3. 原理</h6> 
<p>双指针：注意这里可不是真正意义上的指针：int*,char* ,float* …… 而是指向元素的下标</p> 
<p><span style="background-color:#be191c;">cur 指针</span>：指向当前要扫描的元素</p> 
<p><span style="background-color:#be191c;">dest指针</span>：指向已经被扫描过的元素</p> 
<p>初始位置：dest  = 0； cur = 0 （表示从左向右依次进行判断是否为数字0）</p> 
<p><span style="background-color:#ed7976;"> cur 指向元素为0，则++cur</span></p> 
<p><span style="background-color:#ed7976;">cur 指向元素非0，交换 cur，dest对应位置的元素，同时++cur，++dest</span></p> 
<p> <img alt="" height="1200" src="https://images2.imgbox.com/48/1d/3i2MHQGa_o.png" width="683"></p> 
<p> 这里建议，咱还是先根据自己的理解，来编写程序，看看自己上手能力咋样哈~~~</p> 
<p class="img-center"><img alt="" height="77" src="https://images2.imgbox.com/ab/a0/w5lHeybU_o.png" width="133"></p> 
<p> </p> 
<h6>4.OJ代码</h6> 
<pre><code class="language-cpp">class Solution {
public:
    void moveZeroes(vector&lt;int&gt;&amp; nums)
     {
        int dest = 0,cur = 0;
        int n = nums.size();
        for(;cur &lt; n;++cur)
        {
            if(nums[cur] )
            {
                swap(nums[dest++],nums[cur]);
            }
           
        }

    }
};</code></pre> 
<h5>二· 复写零</h5> 
<h6 style="background-color:transparent;">1.题目链接：<a class="link-info" href="https://leetcode.cn/problems/duplicate-zeros/" rel="nofollow" title="复写零">复写零</a></h6> 
<p><img alt="" height="464" src="https://images2.imgbox.com/42/d4/BPRTDU8W_o.png" width="481"></p> 
<h6>2. 分析</h6> 
<p><span style="background-color:#fe2c24;">解法一：暴力求解</span></p> 
<p>还是老样子：新开一个数组，对于非0元素进行“复写”一遍，0元素，“复写” 两遍，可以解决问题，</p> 
<p>但是不符合要求：必须原地修改数组（也就是说时间 复杂度 O（N））</p> 
<p><span style="background-color:#faa572;">解法二：双指针</span></p> 
<p>先<span style="color:#be191c;"><strong>模拟“异地”元素的移动</strong></span>：开一个与原始数组大小一样 的空间，对于非0元素进行“复写”一遍，0元</p> 
<p>素，“复写” 两遍，我们可以找到新数组的最后一个元素，</p> 
<p><span style="background-color:#fbd4d0;">假设我们知道“复写”之后的数组的最后一个元素</span>，这个问题就简化了许多。此时就是对元素进行“复</p> 
<p>写”的问题了：从前往后还是从后往前进行写入？？？</p> 
<p class="img-center"><img alt="" height="101" src="https://images2.imgbox.com/1b/9d/wQNEJ2I2_o.gif" width="101"></p> 
<p><span style="background-color:#a2e043;">误区一：从前往后遍历</span></p> 
<p>定义2个指针：cur = 0，dest = 0；</p> 
<p>当cur 指向非0元素，arr[dest ]  = arr [ cur ] ,++dest,++cur</p> 
<p>当cur 指向0元素:arr[dest ]  = arr [ cur ] ,++dest,  arr[dest ]  = arr [ cur ] ,++dest,++cur</p> 
<p> 这样势必会<strong><span style="background-color:#ff9900;">造成数据覆盖，</span></strong></p> 
<p>所以说应该从后往前进行写入。</p> 
<p>问题又来了：如何找到数组写入之后的最后一个元素呢？还是借助双指针</p> 
<h6>3. 原理</h6> 
<p><span style="background-color:#a2e043;">1）先模拟找到需写入数组的最后一个元素</span></p> 
<p><strong><span style="background-color:#ed7976;">图解：</span></strong></p> 
<p><img alt="" height="567" src="https://images2.imgbox.com/a9/2a/zlAXxAzQ_o.png" width="973"></p> 
<p>双指针： dest = -1，cur = 0，cur 对应元素0，dest += 2,++cur </p> 
<p><strong><span style="background-color:#d4e9d5;">注意：避免dest 越界，所以一个判读dest 是否 越界 dest &gt;= n-1 </span></strong></p> 
<p>cur 对应非0元素：++dest，++cur</p> 
<p> 结束之后：cur 位置对应的一定是写入数组的最后一个元素的位置</p> 
<p style="text-align:center;"><img alt="" height="93" src="https://images2.imgbox.com/3d/ac/nWzkdi06_o.gif" width="93"></p> 
<p><strong>注意：结束之后dest 可能不是数组的有效位置</strong></p> 
<p>当cur 对应位置是元素0，会导致dest 越界，此时应该在dest 原有位置 前移动 2步，同时把最后一</p> 
<p>个位置写入0即可</p> 
<p><span style="background-color:#e6b223;">对于这个问题：可能会说直接让  dest = n-1 ，不就完了吗，反正最后dest  也是从数组的最后一个</span></p> 
<p><span style="background-color:#e6b223;">位置开始“复写”</span></p> 
<p>但是：可能恰好，cur 对应位置是元素0，写入数组的时候，就还只有一个位置，如果只是简单的</p> 
<p>让dest = n- 1 ，对于这个临界情况就搞不了</p> 
<p><strong><span style="background-color:#38d8f0;">临界情况判断：</span></strong></p> 
<pre><code class="language-cpp"> if (arr[cur] == 0 &amp;&amp; dest &gt; n-1)//注意这里后面的dest 的判断必须加上；也有可能复写的最后一个元素是0同时dest向后移动，刚刚到了n-1对应位置
    {
        arr[n - 1] = 0;
        dest -= 2;//注意永远指向下一个要填写的位置
        --cur;
    }</code></pre> 
<h6>4.OJ代码</h6> 
<pre><code class="language-cpp">class Solution {
public:
  void duplicateZeros(vector&lt;int&gt;&amp; arr)
{
    // 1:需要找到新数组最后一个元素，以方便复写从哪里开始

    int cur = 0, dest = -1;
    int n = arr.size();
    while (cur &lt;= n - 1)
    {
        if (arr[cur] != 0)
        {
            ++dest;
        }
        else
        {
            dest += 2;
        }
        if (dest &gt;= n - 1)
        {
            //对dest 需要判断是否越界
            break;
        }
        ++cur;
    }
    //cur 一定是复写元素的最后一个，同时dest 永远指向的是要复写下一个元素位置
    // // 2:临界判断：可能结束的时候恰好cur遍历到原始数组元素为0
    //导致dest 越界
    //注意不能简单的让dest = n-1 ，这样就可能存在数据覆盖
    if (arr[cur] == 0 &amp;&amp; dest &gt; n-1)//注意这里后面的dest 的判断必须加上；也有可能复写的最后一个元素是0同时dest向后移动，刚刚到了n-1对应位置
    {
        arr[n - 1] = 0;
        dest -= 2;//注意永远指向下一个要填写的位置
        --cur;
    }
   
    // 3: 双指针：从后往前进行复写
   
    while (cur &gt;= 0)
    {
        if (arr[cur])
        {
            arr[dest--] = arr[cur--];
        }
        else
        {
            arr[dest--] = arr[cur];
            arr[dest--] = arr[cur--];
        }
    }

}
};</code></pre> 
<h5 style="background-color:transparent;">三· 快乐数</h5> 
<h6>1.题目链接：<a class="link-info" href="https://leetcode.cn/problems/happy-number/description/" rel="nofollow" title="快乐数">快乐数</a></h6> 
<p><img alt="" height="595" src="https://images2.imgbox.com/68/4c/5cETpcHJ_o.png" width="550"></p> 
<h6 style="background-color:transparent;">2. 分析</h6> 
<p>对于数字n  ，就是拿到每一位的数字，并把每一位数字的平方进行相加求得平方之和，一直重复这</p> 
<p>个过程，当变为1，就是快乐数，否则就不是快乐数。</p> 
<p class="img-center"><img alt="" height="1200" src="https://images2.imgbox.com/df/ee/2mVvmJNS_o.jpg" width="1200"></p> 
<p> 通过画图我们知道，对于一个数字是快乐数也好，不是快乐数也好，<strong><span style="background-color:#e6b223;">最终都会进入一个环，此时</span></strong></p> 
<p><strong><span style="background-color:#e6b223;">问题就变成了判断是否为数字1 了。</span></strong></p> 
<p>不知道到这里，是否想起链表里面的一个OJ题目：判断链表是否有环？</p> 
<p>对于这个题目感到陌生的友友们，可以看看之前我写的这个<span style="color:#be191c;"><strong>题解</strong></span>：<a class="link-info" href="https://blog.csdn.net/X_do_myself/article/details/136005048?spm=1001.2014.3001.5502" title="判断链表是否有环">判断链表是否有环</a></p> 
<p> 所以对于这个问题的思路：<strong><span style="background-color:#b95514;">快慢指针</span></strong></p> 
<h6>3. 原理</h6> 
<p>定义2个指针：</p> 
<p><span style="background-color:#ed7976;">slow 指针初始位置指向 n 所得的数字平方之和</span></p> 
<p><span style="background-color:#d4e9d5;">fast 指针 初始位置指向 ：slow 指针初始位置指向 n 所得的数字平方之和的平方之和</span></p> 
<p><span style="background-color:#38d8f0;">最终2指针一定相遇，所以就只需要判断其中一个指针是否为1即可</span></p> 
<h6 style="background-color:transparent;">4.OJ代码</h6> 
<pre><code class="language-cpp">class Solution {
    //求当前数字每一位的平方和
    int num_sum(int n)
    {
        int sum = 0;
        while(n)
        {
            int x = n%10;
            sum += (x*x);
            n /= 10;
        }
        return sum;
    }
public:
    bool isHappy(int n)
     {
        //题型：判断链表是否有环
        //快慢指针(也不一定就是指针)
        int slow = n;
        int fast = num_sum(n);
        while(fast != slow)
        {
            //fast 走2步
            //slow 走1步
            slow = num_sum(slow);
            fast = (num_sum(num_sum(fast)));
        }
        return fast == 1;

    }
};</code></pre> 
<h4 style="background-color:transparent;">总结：</h4> 
<p><span style="background-color:#956fe7;">对于快慢指针这一思想的应用关键在于：初始位置下标的确定；如何迭代；还是需要注意一些临界</span></p> 
<p><span style="background-color:#956fe7;">情况判断以及特例</span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4e7fb72304a9cbcfa41e9d84d7d14bc1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">c_cpp_properties.json、launch.json、 tasks.json</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c54cfae4083b723a11137324dab91efc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">利用亚马逊云科技Bedrock和LangChain开发AI驱动数据分析平台</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>