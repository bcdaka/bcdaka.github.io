<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>RM惯性测量单元IMU - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/5946df0ff6ab5028318943686554ad4e/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="RM惯性测量单元IMU">
  <meta property="og:description" content="在Robomaster比赛中，一般各大参赛队会在机器人的云台上搭载IMU，用以反馈云台的yaw轴和pitch轴的角度和角速度。
需要注意的是，尽管依靠云台电机6020的编码器同样可以实现以上数据的获取，但是由于云台控制对于灵敏度和精度的要求比较高，而云台电机编码器反馈的数据分辨率较低，并且速度数据波动较大，用它来做控制并不能够达到很好的效果，所以目前的主流方案依然是通过IMU的数据来做云台的闭环控制。
IMU的选型方案非常多，从几十到几千乃至上万不等。一般IMU内部会包含陀螺仪和加速度计，陀螺仪用来反馈角速度和计算位姿，加速度计用于反馈线速度，陀螺仪和加速度各自提供三个轴向的速度数据，所以一般这种IMU被称为六轴IMU。基于不同原理去制作的陀螺仪和加速度计，能够达到的精度范围也有一定的区别。
但是对于IMU来说，总会有一个难以克服的问题，即累积误差。由于IMU通过是通过对内部的陀螺仪获取的角速度数据对时间进行积分获取角度数据的，无论一个陀螺仪的精度有多高，总是会在每个时刻产生一些误差，随着积分效应，误差逐渐累积，最后就会产生累积误差。
为了解决累积误差问题，一般厂家会在IMU内部再集成一个三轴磁力计，从而构成一个所谓的九轴IMU。磁力计的作用是对IMU计算出的位姿定期进行较准，从而解决累积误差。但是磁力计不适合在电磁环境复杂的场合下使用，如果附近有能够产生强磁场的设备，会对磁力计的数据产生非常大的影响。
可以在下图中看到，比较常用的微机械陀螺仪（MEMS）其累积误差水平大概在每小时10°到100°。但是由于实际上每局比赛时间并没有那么长，所以其实累积误差造成的影响并不是特别严重，没有必要为了过高的精度要求而去购买特别贵的陀螺仪。
关于IMU的选型，不同的队伍有着不同的方案，而且一般来说都经过了若干次的迭代。
IMU选型上的坑很多，其中最严重的问题就是由于各种原因引发的复位/离线问题。在这种情况下，失去反馈的云台会立刻失控，从而发生“疯头”。
以下针对IMU总结一些需要注意的要点
确保供电稳定，如果供电电压有较大的波动可能会引发IMU掉线确保物理防护，在赛场上的冲撞/弹丸打击可能会造成IMU的移位/掉线确保陀螺仪量程，如果撞击产生了超出陀螺仪量程的大角速度，可能会引发云台偏移的问题确保线路连接，保证通信线路电连接良好，尤其是当硬件方案涉及到比较长的走线时IMU会受到温度影响，如果要在冬天时把机器人带到室外，记得采取一定的保温措施（比如加热电阻） 以下是一些防范IMU离线引发严重问题的方案
准备电机闭环方案，检测到IMU离线后可以自动/手动切换成电机编码器反馈在云台上装载多个IMU，检测到一个离线后将反馈源切换成另一个采用官方开发板/自研开发板上集成的IMU，相比独立的IMU模块来说风险更小 最后推荐一个讲IMU的知乎专栏，有兴趣的同学可以看一看。https://zhuanlan.zhihu.com/p/41299359
开发板板载IMU 官方提供的开发板自带IMU，用户手册中的介绍如下
如果要使用开发板板载IMU，则必须将开发板固定在云台上可以同时随着yaw轴与pitch轴运动的位置。板载IMU的需要自己完成姿态解算，姿态解算是通过SPI读取MPU6500的寄存器数据后，将三轴加速度计和三轴陀螺仪的数据进行数据融合，解算出当前的位姿，其中为了能够使用矩阵进行快速的运算，需要将欧拉角转换成四元数。
姿态解算的推导涉及到比较复杂的数学过程，这里就不加以太多的介绍了，有兴趣的可以自己去看下面的博客。
姿态解算
姿态解算-CSDN博客
mpu6050姿态解算与卡尔曼滤波（1）数学_mpu6050姿态解算与卡尔曼滤波(1)数学-CSDN博客
滤波
姿态估计（1）——互补滤波（Complementary filter ）-CSDN博客 四元数
彻底搞懂四元数-CSDN博客 牛顿迭代快速求根
牛顿迭代法快速寻找平方根 | Matrix67: The Aha Moments 官方车代码里面同样有解算的代码，并且有多种算法。下面这段代码是一个禁用了磁力计数据的算法，也是我自己以前移植到自己的工程里进行过测试的，由于当时我发现磁力计读取到的数据干扰很大，于是选择了禁用了磁力计数据的算法，只使用加速度计和陀螺仪进行数据融合。其中invSqrt是运用牛顿迭代法快速求平方根，是用于归一化处理的，官方给的注释在我看来已经已到位了，因此在这里不去加更多的注脚。
void mahony_ahrs_updateIMU(struct ahrs_sensor *sensor, struct attitude *atti) { float recipNorm; float halfvx, halfvy, halfvz; float halfex, halfey, halfez; float qa, qb, qc; gx = sensor-&gt;wx; gy = sensor-&gt;wy; gz = sensor-&gt;wz; ax = sensor-&gt;ax; ay = sensor-&gt;ay; az = sensor-&gt;az; mx = sensor-&gt;mx; my = sensor-&gt;my; mz = sensor-&gt;mz; // Compute feedback only if accelerometer measurement valid (avoids NaN in accelerometer normalisation) if (!">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-21T10:26:39+08:00">
    <meta property="article:modified_time" content="2024-08-21T10:26:39+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">RM惯性测量单元IMU</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在Robomaster比赛中，一般各大参赛队会在机器人的云台上搭载IMU，用以反馈云台的yaw轴和pitch轴的角度和角速度。</p> 
<p>需要注意的是，尽管依靠云台电机6020的编码器同样可以实现以上数据的获取，但是由于云台控制对于灵敏度和精度的要求比较高，而云台电机编码器反馈的数据分辨率较低，并且速度数据波动较大，用它来做控制并不能够达到很好的效果，所以目前的主流方案依然是通过IMU的数据来做云台的闭环控制。</p> 
<p>IMU的选型方案非常多，从几十到几千乃至上万不等。一般IMU内部会包含陀螺仪和加速度计，陀螺仪用来反馈角速度和计算位姿，加速度计用于反馈线速度，陀螺仪和加速度各自提供三个轴向的速度数据，所以一般这种IMU被称为六轴IMU。基于不同原理去制作的陀螺仪和加速度计，能够达到的精度范围也有一定的区别。</p> 
<p></p> 
<p class="img-center"><a href="https://img2018.cnblogs.com/blog/1815493/201911/1815493-20191101171556381-1603096328.png" rel="nofollow"><img alt="" height="395" src="https://images2.imgbox.com/43/34/WUAY60jX_o.png" width="398"></a></p> 
<p>但是对于IMU来说，总会有一个难以克服的问题，即累积误差。由于IMU通过是通过对内部的陀螺仪获取的角速度数据对时间进行积分获取角度数据的，无论一个陀螺仪的精度有多高，总是会在每个时刻产生一些误差，随着积分效应，误差逐渐累积，最后就会产生累积误差。</p> 
<p>为了解决累积误差问题，一般厂家会在IMU内部再集成一个三轴磁力计，从而构成一个所谓的九轴IMU。磁力计的作用是对IMU计算出的位姿定期进行较准，从而解决累积误差。但是磁力计不适合在电磁环境复杂的场合下使用，如果附近有能够产生强磁场的设备，会对磁力计的数据产生非常大的影响。</p> 
<p>可以在下图中看到，比较常用的微机械陀螺仪（MEMS）其累积误差水平大概在每小时10°到100°。但是由于实际上每局比赛时间并没有那么长，所以其实累积误差造成的影响并不是特别严重，没有必要为了过高的精度要求而去购买特别贵的陀螺仪。</p> 
<p></p> 
<p></p> 
<p class="img-center"><img alt="" height="350" src="https://images2.imgbox.com/4f/92/UyZFx5JD_o.png" width="506"></p> 
<p>关于IMU的选型，不同的队伍有着不同的方案，而且一般来说都经过了若干次的迭代。</p> 
<p>IMU选型上的坑很多，其中最严重的问题就是由于各种原因引发的复位/离线问题。在这种情况下，失去反馈的云台会立刻失控，从而发生“疯头”。</p> 
<p></p> 
<p>以下针对IMU总结一些需要注意的要点</p> 
<ul><li>确保供电稳定，如果供电电压有较大的波动可能会引发IMU掉线</li><li>确保物理防护，在赛场上的冲撞/弹丸打击可能会造成IMU的移位/掉线</li><li>确保陀螺仪量程，如果撞击产生了超出陀螺仪量程的大角速度，可能会引发云台偏移的问题</li><li>确保线路连接，保证通信线路电连接良好，尤其是当硬件方案涉及到比较长的走线时</li><li>IMU会受到温度影响，如果要在冬天时把机器人带到室外，记得采取一定的保温措施（比如加热电阻）</li></ul> 
<p></p> 
<p>以下是一些防范IMU离线引发严重问题的方案</p> 
<ul><li>准备电机闭环方案，检测到IMU离线后可以自动/手动切换成电机编码器反馈</li><li>在云台上装载多个IMU，检测到一个离线后将反馈源切换成另一个</li><li>采用官方开发板/自研开发板上集成的IMU，相比独立的IMU模块来说风险更小</li></ul> 
<p>最后推荐一个讲IMU的知乎专栏，有兴趣的同学可以看一看。<a href="https://zhuanlan.zhihu.com/p/41299359" rel="nofollow" title="https://zhuanlan.zhihu.com/p/41299359">https://zhuanlan.zhihu.com/p/41299359</a></p> 
<p></p> 
<h4 id="开发板板载imu">开发板板载IMU</h4> 
<p>官方提供的开发板自带IMU，用户手册中的介绍如下</p> 
<p><img alt="" height="287" src="https://images2.imgbox.com/99/32/rRUS5Wbu_o.png" width="1024"></p> 
<p>如果要使用开发板板载IMU，则必须将开发板固定在云台上可以同时随着yaw轴与pitch轴运动的位置。板载IMU的需要自己完成姿态解算，姿态解算是通过SPI读取MPU6500的寄存器数据后，将三轴加速度计和三轴陀螺仪的数据进行数据融合，解算出当前的位姿，其中为了能够使用矩阵进行快速的运算，需要将欧拉角转换成四元数。</p> 
<p></p> 
<p></p> 
<p class="img-center"><img alt="" height="626" src="https://images2.imgbox.com/d1/ea/yutyoUkp_o.png" width="700"></p> 
<p>姿态解算的推导涉及到比较复杂的数学过程，这里就不加以太多的介绍了，有兴趣的可以自己去看下面的博客。</p> 
<p>姿态解算</p> 
<ul><li> <p><a href="https://blog.csdn.net/u010076999/article/details/50922568" title="姿态解算-CSDN博客">姿态解算-CSDN博客</a></p> </li><li> <p><a href="https://blog.csdn.net/qiguizhe/article/details/59133514" title="mpu6050姿态解算与卡尔曼滤波（1）数学_mpu6050姿态解算与卡尔曼滤波(1)数学-CSDN博客">mpu6050姿态解算与卡尔曼滤波（1）数学_mpu6050姿态解算与卡尔曼滤波(1)数学-CSDN博客</a></p> </li></ul> 
<p>滤波</p> 
<ul><li><a href="https://blog.csdn.net/u012814946/article/details/52850400" title="姿态估计（1）——互补滤波（Complementary filter ）-CSDN博客">姿态估计（1）——互补滤波（Complementary filter ）-CSDN博客</a></li></ul> 
<p>四元数</p> 
<ul><li><a href="https://blog.csdn.net/shenshen211/article/details/78492055" title="彻底搞懂四元数-CSDN博客">彻底搞懂四元数-CSDN博客</a></li></ul> 
<p>牛顿迭代快速求根</p> 
<ul><li><a href="http://www.matrix67.com/blog/archives/361" rel="nofollow" title="牛顿迭代法快速寻找平方根 | Matrix67: The Aha Moments">牛顿迭代法快速寻找平方根 | Matrix67: The Aha Moments</a></li></ul> 
<p></p> 
<p>官方车代码里面同样有解算的代码，并且有多种算法。下面这段代码是一个禁用了磁力计数据的算法，也是我自己以前移植到自己的工程里进行过测试的，由于当时我发现磁力计读取到的数据干扰很大，于是选择了禁用了磁力计数据的算法，只使用加速度计和陀螺仪进行数据融合。其中invSqrt是运用牛顿迭代法快速求平方根，是用于归一化处理的，官方给的注释在我看来已经已到位了，因此在这里不去加更多的注脚。</p> 
<pre><code class="language-cpp">void mahony_ahrs_updateIMU(struct ahrs_sensor *sensor, struct attitude *atti)
{
  float recipNorm;
  float halfvx, halfvy, halfvz;
  float halfex, halfey, halfez;
  float qa, qb, qc;

  gx = sensor-&gt;wx;
  gy = sensor-&gt;wy;
  gz = sensor-&gt;wz;
  ax = sensor-&gt;ax;
  ay = sensor-&gt;ay;
  az = sensor-&gt;az;
  mx = sensor-&gt;mx;
  my = sensor-&gt;my;
  mz = sensor-&gt;mz;
  // Compute feedback only if accelerometer measurement valid (avoids NaN in accelerometer normalisation)
  if (!((ax == 0.0f) &amp;&amp; (ay == 0.0f) &amp;&amp; (az == 0.0f)))
  {

    // Normalise accelerometer measurement
    recipNorm = invSqrt(ax * ax + ay * ay + az * az);
    ax *= recipNorm;
    ay *= recipNorm;
    az *= recipNorm;

    // Estimated direction of gravity and vector perpendicular to magnetic flux
    halfvx = q1 * q3 - q0 * q2;
    halfvy = q0 * q1 + q2 * q3;
    halfvz = q0 * q0 - 0.5f + q3 * q3;

    // Error is sum of cross product between estimated and measured direction of gravity
    halfex = (ay * halfvz - az * halfvy);
    halfey = (az * halfvx - ax * halfvz);
    halfez = (ax * halfvy - ay * halfvx);

    // Compute and apply integral feedback if enabled
    if (twoKi &gt; 0.0f)
    {
      integralFBx += twoKi * halfex * (1.0f / sampleFreq); // integral error scaled by Ki
      integralFBy += twoKi * halfey * (1.0f / sampleFreq);
      integralFBz += twoKi * halfez * (1.0f / sampleFreq);
      gx += integralFBx; // apply integral feedback
      gy += integralFBy;
      gz += integralFBz;
    }
    else
    {
      integralFBx = 0.0f; // prevent integral windup
      integralFBy = 0.0f;
      integralFBz = 0.0f;
    }

    // Apply proportional feedback
    gx += twoKp * halfex;
    gy += twoKp * halfey;
    gz += twoKp * halfez;
  }

  // Integrate rate of change of quaternion
  gx *= (0.5f * (1.0f / sampleFreq)); // pre-multiply common factors
  gy *= (0.5f * (1.0f / sampleFreq));
  gz *= (0.5f * (1.0f / sampleFreq));
  qa = q0;
  qb = q1;
  qc = q2;
  q0 += (-qb * gx - qc * gy - q3 * gz);
  q1 += (qa * gx + qc * gz - q3 * gy);
  q2 += (qa * gy - qb * gz + q3 * gx);
  q3 += (qa * gz + qb * gy - qc * gx);

  // Normalise quaternion
  recipNorm = invSqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);
  q0 *= recipNorm;
  q1 *= recipNorm;
  q2 *= recipNorm;
  q3 *= recipNorm;
  atti-&gt;roll = atan2(2 * q2 * q3 + 2 * q0 * q1, -2 * q1 * q1 - 2 * q2 * q2 + 1) * 57.3; // roll     -pi----pi
  atti-&gt;pitch = asin(-2 * q1 * q3 + 2 * q0 * q2) * 57.3;                                // pitch    -pi/2----pi/2
  atti-&gt;yaw = atan2(2 * q1 * q2 + 2 * q0 * q3, -2 * q2 * q2 - 2 * q3 * q3 + 1) * 57.3;  // yaw      -pi----pi
}

</code></pre> 
<p>代码解释如下：</p> 
<p>1、函数<code>mahony_ahrs_updateIMU接收两个结构体作为参数</code>接收两个结构体作为参数：<code>sensor</code>包含IMU传感器的数据，<code>atti</code>用于存储计算后的姿态角。</p> 
<p>2、变量<code>gx</code>、<code>gy</code>、<code>gz</code>是陀螺仪测量的角速度，<code>ax</code>、<code>ay</code>、<code>az</code>是加速度计测量的加速度，<code>mx</code>、<code>my</code>、<code>mz</code>是磁力计测量的磁场强度。变量<code>twoKp</code>和<code>twoKi</code>是算法的控制参数，分别代表比例和积分增益的两倍。变量<code>sampleFreq</code>是传感器数据采样频率。</p> 
<p></p> 
<p></p> 
<h4>加速度计数据验证和归一化</h4> 
<p><img alt="" height="192" src="https://images2.imgbox.com/51/d3/VSd4V0pX_o.png" width="795"></p> 
<p>函数首先检查加速度计的数据是否有效，避免除以零。</p> 
<p><code>recipNorm</code>是加速度计数据的归一化因子，用于确保加速度向量的长度为1。将归一化因子应用于加速度向量的每个分量，使其成为一个单位向量。</p> 
<p></p> 
<h4><strong>计算姿态误差（计算估计的重力方向向量，这是通过当前姿态四元数 <code>q0</code>, <code>q1</code>, <code>q2</code>, <code>q3</code> 来实现的。）</strong></h4> 
<p><img alt="" height="92" src="https://images2.imgbox.com/a0/28/qRp3XiOX_o.png" width="728"></p> 
<p><img alt="" height="94" src="https://images2.imgbox.com/26/1c/WXPD0vK7_o.png" width="773"></p> 
<p><code>halfvx</code>、<code>halfvy</code>、<code>halfvz</code>是估计的重力方向向量。<code>halfex</code>、<code>halfey</code>、<code>halfez</code>是估计的重力方向向量与实际测量的加速度向量的叉乘结果，代表姿态估计的误差。</p> 
<p></p> 
<p></p> 
<h4>积分和比例反馈</h4> 
<p><img alt="" height="408" src="https://images2.imgbox.com/07/f1/NCiwCSLT_o.png" width="769"></p> 
<ul><li>如果积分增益 <code>twoKi</code> 大于0，将误差的积分反馈加入角速度。</li><li>如果积分增益为0，则重置积分反馈，防止积分饱和。</li></ul> 
<p></p> 
<p><img alt="" height="90" src="https://images2.imgbox.com/00/3c/kjoo3oSc_o.png" width="713"></p> 
<ul><li>应用比例反馈，将姿态误差乘以比例增益 <code>twoKp</code> 并加到角速度上。</li></ul> 
<p></p> 
<p></p> 
<h4>四元数积分和归一化</h4> 
<p><img alt="" height="91" src="https://images2.imgbox.com/8e/22/szJAfLHw_o.png" width="633"></p> 
<ul><li>将角速度乘以一个因子，准备进行四元数的积分更新。</li></ul> 
<p><img alt="" height="119" src="https://images2.imgbox.com/c5/fb/Pt49nhSJ_o.png" width="666"></p> 
<ul><li>根据角速度更新四元分的每个分量。</li></ul> 
<p><img alt="" height="136" src="https://images2.imgbox.com/c0/0f/hQtKyRQb_o.png" width="765"></p> 
<ul><li>四元数归一化，确保其长度为1，表示有效的旋转。</li></ul> 
<p></p> 
<p></p> 
<h4>计算姿态角</h4> 
<p><img alt="" height="137" src="https://images2.imgbox.com/a5/15/wB2FjRjy_o.png" width="792"></p> 
<ul><li>使用四元数计算俯仰角（pitch）、横滚角（roll）和偏航角（yaw），并将结果从弧度转换为度。</li></ul> 
<p></p> 
<h4>结尾</h4> 
<p>函数没有返回值，计算结果直接存储在 <code>atti</code> 结构体中。</p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3e264c81e2696179e6f88474e2473ebc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">图文详解ThreadLocal：原理、结构与内存泄漏解析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bd1d8bdd20f92fad6223e44172b91699/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">将Web应用部署到Tomcat根目录的三种方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>