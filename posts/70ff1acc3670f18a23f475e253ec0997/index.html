<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>日期类代码实现-C&#43;&#43; - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/70ff1acc3670f18a23f475e253ec0997/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="日期类代码实现-C&#43;&#43;">
  <meta property="og:description" content="一、目标 通过前面对类和对象的介绍我们可以自己通过C&#43;&#43;代码初步实现一个简单的日期类。
实现的主要操作有：
1.日期类的构造函数
2.日期类的拷贝构造函数（在头文件中实现）
3.日期类的比较运算符重载
4.日期类的计算运算符重载
5.流插入运算符重载。
二、总体思路 首先，我这里采用的是分文件编程的方式来实现的日期类。
分别为：
1.头文件：Date.h 该文件的主要目的是对上述目标所要实现的所有操作进行函数的声明。同时，还要包含在
源文件Date.cpp 中定义时所需要用到的头文件函数。
2.源文件：Date.cpp 该文件的目的主要是用于对 头文件Date.h 所声明的所有函数进行定义，从而完成各个函数所要实现的操作。
3.源文件：Test.cpp 该文件的目的主要是用于检测 源文件Date.cpp 中定义的函数是否能正常够使用并且达到所要实现的操作。
三、代码实现及具体思路 1.头文件：Date.h 通过上面思路的介绍，我们可以知道，我们的目的是创建一个日期类，然后在日期类中自我声明：日期类的构造函数、日期类的比较运算符重载、日期类的计算运算符重载以及流插入运算符重载。并实现拷贝构造函数。
（注意：通过我们前面对类和对象的介绍可知，因为在实现日期类过程中，我们没有动态申请空间，所以我们只需使用编译器默认生成的析构函数就可以，因此，我们不需要自己再定义一个析构函数）
代码如下：
#pragma once #include &lt;iostream&gt; #include &lt;assert.h&gt; using namespace std; class Date { public: Date(int year = 1, int month = 1, int day = 1); void Print()const { cout &lt;&lt; _year &lt;&lt; &#39;-&#39; &lt;&lt; _month &lt;&lt; &#39;-&#39; &lt;&lt; _day &lt;&lt; endl; } Date(const Date&amp; d) { _year = d.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-16T15:51:36+08:00">
    <meta property="article:modified_time" content="2024-08-16T15:51:36+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">日期类代码实现-C&#43;&#43;</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、目标</h2> 
<p>        通过前面对类和对象的介绍我们可以自己通过C++代码初步实现一个简单的日期类。</p> 
<p>实现的主要操作有：</p> 
<p><span style="color:#fe2c24;"><strong>1.日期类的构造函数</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>2.日期类的拷贝构造函数（在头文件中实现）</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>3.日期类的比较运算符重载</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>4.日期类的计算运算符重载</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>5.流插入运算符重载。</strong></span></p> 
<h2>二、总体思路</h2> 
<p>        首先，我这里采用的是分文件编程的方式来实现的日期类。</p> 
<p>分别为：</p> 
<h3>1.头文件：Date.h</h3> 
<p>        该文件的主要目的是对上述目标所要实现的所有操作进行函数的声明。同时，还要包含在</p> 
<p><strong><span style="color:#511b78;">源文件Date.cpp </span></strong>中定义时所需要用到的头文件函数。</p> 
<h3 style="background-color:transparent;">2.源文件：Date.cpp</h3> 
<p>        该文件的目的主要是用于对 <span style="color:#511b78;"><strong>头文件Date.h </strong></span>所声明的所有函数进行定义，从而完成各个函数所要实现的操作。</p> 
<h3>3.源文件：Test.cpp</h3> 
<p>        该文件的目的主要是用于检测 <span style="color:#511b78;"><strong>源文件Date.cpp </strong></span>中定义的函数是否能正常够使用并且达到所要实现的操作。</p> 
<h2>三、代码实现及具体思路</h2> 
<h3>1.头文件：Date.h</h3> 
<p>        通过上面思路的介绍，我们可以知道，我们的目的是创建一个日期类，然后在日期类中自我声明：<span style="color:#511b78;">日期类的构造函数、日期类的比较运算符重载、日期类的计算运算符重载以及流插入运算符重载。并实现拷贝构造函数。</span></p> 
<p><span style="color:#0d0016;">（<strong>注意</strong>：通过我们前面对类和对象的介绍可知，因为在实现日期类过程中，我们没有<strong>动态申请空间</strong>，所以我们只需使用<strong>编译器默认生成的析构函数</strong>就可以，因此，我们不需要自己再定义一个析构函数）</span></p> 
<p>代码如下：</p> 
<pre><code class="language-cpp">#pragma once

#include &lt;iostream&gt;
#include &lt;assert.h&gt;

using namespace std;
class Date
{

public:
	Date(int year = 1, int month = 1, int day = 1);
	void Print()const
	{
		cout &lt;&lt; _year &lt;&lt; '-' &lt;&lt; _month &lt;&lt; '-' &lt;&lt; _day &lt;&lt; endl;
	}
	Date(const Date&amp; d)
	{
		_year = d._year;
		_month = d._month;
		_day = d._day;
	}
	//日期类的比较运算符的重载
	bool operator&lt;(const Date&amp; x) const;
	bool operator==(const Date&amp; x) const;
	bool operator&lt;=(const Date&amp; x) const;
	bool operator&gt;(const Date&amp; x) const;
	bool operator&gt;=(const Date&amp; x) const;
	bool operator!=(const Date&amp; x) const;

	//日期类的计算运算符的重载
	int Get_MonthDay(int year,int month);		//获取该月份的天数

	Date&amp; operator+=(int day);
	Date operator+(int day)const;

	Date&amp; operator-=(int day);
	Date operator-(int day)const;

	Date&amp; operator++();		//前置++
	Date operator++(int);		//后置++

	Date&amp; operator--();			//前置--
	Date operator--(int);		//后置--

	int operator-(const Date&amp; x) const;

	// 流插入不能写成成员函数?
	// 因为Date对象默认占用第一个参数，就是做了左操作数
	// 写出来就一定是下面这样子，不符合使用习惯
	//d1 &lt;&lt; cout; // d1.operator&lt;&lt;(cout); 
	//void operator&lt;&lt;(ostream&amp; out);
	
	// 友元函数声明
	friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const Date&amp; d);
	friend istream&amp; operator&gt;&gt;(istream&amp; in, Date&amp; d);
private:
	int _year;
	int _month;
	int _day;
};

ostream&amp; operator&lt;&lt;(ostream&amp; out, const Date&amp; x);
istream&amp; operator&gt;&gt;(istream&amp; in, Date&amp; x);</code></pre> 
<p></p> 
<h3>2.源文件：Date.cpp</h3> 
<p>        对于实现下面函数，我们需要首先定义一个获取当前月份天数的函数</p> 
<p>代码实现：</p> 
<pre><code class="language-cpp">//因为平年闰年的2月天数不一样所以我们需定义一个获取月份的函数来解决这一问题
int Date::Get_MonthDay(int year, int month)		//获取该月份的天数
{
	static int daysArr[13] = { 0,31,28,31,30,31,30,31,31,30,31,30,31 };
	if (month == 2 &amp;&amp; (year % 4 == 0 &amp;&amp; year % 100 != 0) || (year % 400 == 0))
	{
		return 29;
	}
	else
	{
		return daysArr[month];
	}
}
</code></pre> 
<h4><span style="color:#0d0016;"><strong>1.日期类的构造函数</strong></span></h4> 
<p><span style="color:#0d0016;"> 思路：</span></p> 
<p><span style="color:#0d0016;">        我们在通过日期类构造函数初始化所定义的日期时，我们需要判断我们所定义的日期是否合法，若不合法，则需要返回并提示</span></p> 
<p><span style="color:#0d0016;">代码实现：</span></p> 
<pre><code class="language-cpp">Date::Date(int year, int month, int day)
{
    //判断所初始化的日期是否合法
	if (month &gt; 0 &amp;&amp; month &lt; 13
		&amp;&amp;day&gt;=1&amp;&amp;day&lt;= Get_MonthDay(year, month))
	{
		_year = year;
		_month = month;
		_day = day;
	}
	else
	{
		cout &lt;&lt; "非法日期" &lt;&lt; endl;
		assert(false);
	}
}</code></pre> 
<h4><span style="color:#0d0016;"><strong>2.日期类的比较运算符重载</strong></span></h4> 
<p><span style="color:#0d0016;">思路：</span></p> 
<p>        对于比较类的运算符重载来说，因为比较运算符具有互斥性，所以我们只需定义出<strong><span style="color:#fe2c24;"> &lt; </span></strong>运算符重载和<span style="color:#fe2c24;"><strong> == </strong></span>运算符重载，然后其他运算符复用上面所定定义的两个运算符即可。并且在比较的同时，我们不会改变参数的值，所以我们可以在函数尾部加const用于修饰内部的this指针，这样的话，const修饰的类型我们也可以通过比较运算符来比较。</p> 
<p><span style="color:#0d0016;">代码实现：</span></p> 
<pre><code class="language-cpp">bool Date::operator&lt;(const Date&amp; x) const
{
	if (_year &lt; x._year)
	{
		return true;
	}
	else if (_year == x._year &amp;&amp; _month &lt; x._month)
	{
		return true;
	}
	else if (_year == x._year &amp;&amp; _month == x._month &amp;&amp; _day &lt; x._day)
	{
		return true;
	}
	else
	{
		return false;
	}
}

bool Date::operator==(const Date&amp; x) const
{
	if (_year == x._year &amp;&amp; _month == x._month &amp;&amp; _day == x._day)
	{
		return true;
	}
	else
	{
		return false;
	}
}

bool Date::operator&lt;=(const Date&amp; x) const
{
	//复用上面定义的重载运算符:&lt; , ==
	return *this &lt; x || *this == x;
}

bool Date::operator&gt;(const Date&amp; x) const
{
	//复用上面定义的重载运算符:&lt;=
	return !(*this &lt;= x);
}

bool Date::operator&gt;=(const Date&amp; x) const
{
	//复用上面定义的重载运算符:&gt; , ==
	return *this &gt; x || *this == x;
}

bool Date::operator!=(const Date&amp; x) const
{
	//复用上面定义的重载运算符:==
	return !(*this == x);
}
</code></pre> 
<h4><span style="color:#0d0016;"><strong>3.日期类的计算运算符重载</strong></span></h4> 
<p>思路：</p> 
<p>        对于日期类的计算运算符重载的定义，我们可以先定义 <span style="color:#fe2c24;"><strong>+=</strong></span> 运算符重载和 <span style="color:#fe2c24;"><strong>-=</strong></span> 运算符重载，然后其他运算符重载的定义我们可以复用这两个运算符重载，从而实现各个运算符所要实现的目的。</p> 
<p>代码实现：</p> 
<pre><code class="language-cpp">Date&amp; Date::operator+=(int day)
{
	if (day &lt; 0)
	{
		return *this -= (-day);
	}
	_day = _day + day;
	while (_day &gt; Get_MonthDay(_year, _month))
	{
		_day = _day-Get_MonthDay(_year, _month);
		++_month;
		if (_month == 13)
		{
			_month = 1;
			++_year;
		}
	}
	return *this;
}

Date Date::operator+(int day)const
{
	if (day &lt; 0)
	{
		return *this - (-day);
	}
	//复用上面定义的重载运算符:+=
	Date tem(*this);
	tem+= day;
	return tem;
}

Date&amp; Date::operator-=(int day)
{
	if (day &lt; 0)
	{
		return *this += (-day);
	}
	_day = _day - day;
	while (_day &lt; 1)
	{
		--_month;
		if (_month &lt;1 )
		{
			_month = 12;
			--_year;
		}
		_day = _day + Get_MonthDay(_year, _month);
	}
	return *this;
}

Date Date::operator-(int day)const
{
	if (day &lt; 0)
	{
		return *this + (-day);
	}
	//复用上面定义的重载运算符:-=
	Date tem(*this);
	tem -= day;
	return tem;
}

Date&amp; Date::operator++()
{
	//复用上面定义的重载运算符:+=
	*this += 1;
	return *this;
}

Date Date::operator++(int)
{
	//复用上面定义的重载运算符:+
	Date tem = *this;
	*this += 1;
	return tem;
}

Date&amp; Date::operator--()
{
	//复用上面定义的重载运算符:+=
	*this -= 1;
	return *this;
}

Date Date::operator--(int)
{
	//复用上面定义的重载运算符:+
	Date tem = *this;
	*this -= 1;
	return tem;
}

</code></pre> 
<p>        实现两个日期之间相减求天数时，我们可以先判断哪个日期大，从而确定出所求的天数是正数还是负数，即用flage的正负来实现。接着我们定义一个n来统计天数，然后我们通过while循环，++最小的日期，并且++天数直到最小日期和最大日期相等的时候结束，这时候我们返回n*flage的值即是所求天数。</p> 
<pre><code class="language-cpp">int Date::operator-(const Date&amp; x) const
{
	Date max = *this;
	Date min = x;
	int flage = 1;
	if (*this &lt; x)
	{
		max = x;
		min = *this;
		flage = -1;
	}
	int n = 0;
	while (min != max)
	{
		++min;
		++n;
	}
	return n * flage;
}
</code></pre> 
<h4><span style="color:#0d0016;"><strong>4.流插入运算符重载。</strong></span></h4> 
<p>思路：</p> 
<p>        对于日期类使用<strong>系统中的流插入（只能插入内置类型）</strong>时并不能实现所期望的操作，因为日期类是<strong>自定义类型</strong>，所以我们就需要自己定义一个流插入来实现这个操作</p> 
<pre><code class="language-cpp">	// 流插入不能写成成员函数?
	// 因为Date对象默认占用第一个参数，就是做了左操作数
	// 写出来就一定是下面这样子，不符合使用习惯
	//d1 &lt;&lt; cout; // d1.operator&lt;&lt;(cout); 
	//void operator&lt;&lt;(ostream&amp; out);</code></pre> 
<p>因此，这里我们通过友元函数，在全局中定义流插入的运算符重载</p> 
<p>代码实现：</p> 
<pre><code class="language-cpp">ostream&amp; operator&lt;&lt;(ostream&amp; out, const Date&amp; x)
{
	out &lt;&lt; x._year &lt;&lt; "年" &lt;&lt; x._month &lt;&lt; "月" &lt;&lt; x._day &lt;&lt; "日" &lt;&lt; endl;

	return out;
}

istream&amp; operator&gt;&gt;(istream&amp; in, Date&amp; x)
{
	int year, month, day;
	in &gt;&gt; year &gt;&gt; month &gt;&gt; day;

	if (month &gt; 0 &amp;&amp; month &lt; 13
		&amp;&amp; day &gt; 0 &amp;&amp; day &lt;= x.Get_MonthDay(year, month))
	{
		x._year = year;
		x._month = month;
		x._day = day;
	}
	else
	{
		cout &lt;&lt; "非法日期" &lt;&lt; endl;
		assert(false);
	}

	return in;
}</code></pre> 
<h3>3.源文件：Test.cpp</h3> 
<h4>Test1：</h4> 
<p>用于检测日期类的比较运算符的重载</p> 
<pre><code class="language-cpp">void Test1()		//用于检测日期类的比较运算符的重载
{
	Date s1(2005, 2, 16);
	Date s2(2024, 8, 12);
	cout &lt;&lt; "bool operator&lt;(const Date&amp; x) const:" &lt;&lt; (s1 &lt; s2) &lt;&lt; endl;
	cout &lt;&lt; "bool operator==(const Date&amp; x) const:" &lt;&lt; (s1 == s2) &lt;&lt; endl;
	cout &lt;&lt; "bool operator&lt;=(const Date&amp; x) const:" &lt;&lt; (s1 &lt;= s2) &lt;&lt; endl;
	cout &lt;&lt; "bool operator&gt;(const Date&amp; x) const:" &lt;&lt; (s1 &gt; s2) &lt;&lt; endl;
	cout &lt;&lt; "bool operator&gt;=(const Date&amp; x) const:" &lt;&lt; (s1 &gt;= s2) &lt;&lt; endl;
	cout &lt;&lt; "bool operator!=(const Date&amp; x) const:" &lt;&lt; (s1 != s2) &lt;&lt; endl;
}</code></pre> 
<h4><img alt="" height="572" src="https://images2.imgbox.com/9a/c5/CygnSKuZ_o.png" width="787"></h4> 
<h4>Test2：</h4> 
<p>用于检测日期类的计算运算符的重载:+= , +</p> 
<pre><code class="language-cpp">void Test2()		//用于检测日期类的计算运算符的重载:+= , +
{
	Date s1(2005, 2, 16);
	s1.Print();
	s1 += 10000;
	s1.Print();

	Date s2(2005, 2, 16);
	s2.Print();
	Date s3=s2+10000;
	s3.Print();
}</code></pre> 
<h4 style="background-color:transparent;"><img alt="" height="597" src="https://images2.imgbox.com/7a/29/a9jPqG3a_o.png" width="1172"></h4> 
<h4 style="background-color:transparent;">Test3：</h4> 
<p>用于检测日期类的计算运算符的重载:-= , -</p> 
<pre><code class="language-cpp">void Test3()		//用于检测日期类的计算运算符的重载:-= , -
{
	Date s1(2005, 2, 16);
	s1.Print();
	s1 -= 1000;
	s1.Print();

	Date s2(2005, 2, 16);
	s2.Print();
	Date s3 = s2 - 1000;
	s3.Print();
}</code></pre> 
<h4><img alt="" height="604" src="https://images2.imgbox.com/50/04/9uYHTQCV_o.png" width="1054"></h4> 
<h4>Test4：</h4> 
<p>用于检测日期类的计算运算符的重载:--</p> 
<pre><code class="language-cpp">void Test4()		//用于检测日期类的计算运算符的重载:--
{
	Date s2(2005, 2, 16);
	Date s3(2005, 2, 16);
	Date s4;
	s4=s2--;
	s4.Print();

	s4 = --s3;
	s4.Print();
}
</code></pre> 
<h4><img alt="" height="529" src="https://images2.imgbox.com/d7/fa/ZZljsRPs_o.png" width="1038"></h4> 
<h4>Test5：</h4> 
<p>用于检测日期类的计算运算符的重载:++</p> 
<pre><code class="language-cpp">void Test5()		//用于检测日期类的计算运算符的重载:++
{
	Date s2(2005, 2, 16);
	Date s3(2005, 2, 16);
	Date s4;
	s4 = s2++;
	s4.Print();

	s4 = ++s3;
	s4.Print();
}</code></pre> 
<h4><img alt="" height="601" src="https://images2.imgbox.com/73/d0/1ANbRfoT_o.png" width="1148"></h4> 
<h4>Test6：</h4> 
<p>用于检测日期类之间的计算运算符的重载:-</p> 
<pre><code class="language-cpp">void Test6()		//用于检测日期类之间的计算运算符的重载:-
{
	Date s1(2005, 2, 16);
	Date s2(2024, 8, 13);
	cout &lt;&lt; "int operator-(const Date&amp; x) const:" &lt;&lt; (s1 - s2) &lt;&lt; endl;
}</code></pre> 
<h4><img alt="" height="548" src="https://images2.imgbox.com/dc/0a/rQqsNEvY_o.png" width="1092"></h4> 
<h4>Test7：</h4> 
<p>用于检测日期类之间的计算运算符的重载:&lt;&lt; , &gt;&gt;</p> 
<pre><code class="language-cpp">void Test7()		//用于检测日期类之间的计算运算符的重载:&lt;&lt; , &gt;&gt;
{
	Date s1;
	cin &gt;&gt; s1;
	cout &lt;&lt; s1 &lt;&lt; endl;
	cout &lt;&lt; s1 + 100 &lt;&lt; endl;
}</code></pre> 
<p><img alt="" height="498" src="https://images2.imgbox.com/c9/57/3XPVJUkP_o.png" width="1104"></p> 
<p></p> 
<h2>四、结语：</h2> 
<p><strong>        <span style="color:#511b78;"> 上述内容，即是我个人对C++日期类的个人见解及代码实现。若有大佬发现哪里有问题可以私信或评论指教一下。非常感谢各位uu们的点赞，关注，收藏，还望各位多多关照，让我们一起进步吧！</span></strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ebc022e20c5c6a7eb4bebd36a85147a9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python爬虫——爬取某网站的视频</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/941291b26e7879be5fcbc9d79830fca9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">HarmonyOS NEXT星河版零基础入门（3）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>