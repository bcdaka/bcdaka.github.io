<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Unity&#43;讯飞星火大模型&#43;Web api，实现二次元小姐姐AI聊天互动 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/df29b86246f101e6fed30edc2d167739/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Unity&#43;讯飞星火大模型&#43;Web api，实现二次元小姐姐AI聊天互动">
  <meta property="og:description" content="1.简述 最近讯飞的星火大模型更新了2.0版本，增强了AI的语言生成能力。毕竟是国产大语言模型，我也尝试使用了一下星火大模型的应用广场，体验还是很不错的。应用广场提供了很多AI助手工具，也支持用户创建自己的AI助手，能力不局限于自然语言生成，也有一些图片生成工具、视频生成工具之类的，总的来说，还是很有意思的。
同时，星火大模型也提供有api服务，可以很方便的集成到自己的应用里。申请api应用的门槛也比较低，简单填写一些信息，就可以申请试用。试用审核大概半个多小时就结束了，官方提供的免费token数量还是比较可观。针对星火大模型V1.5版本以及V2.0版本，各提供了200万的token试用，非常的良心。我的AI二次元小姐姐项目里，使用chatgpt以及一些开源模型的方式，相对来说还是有一定使用门槛，而接入星火大模型门槛就很低了。
本文就简单介绍一下unity端集成星火大模型API的代码实现，让星火大模型驱动我们的AI二次元小姐姐，与大家聊天吧。
2.开通星火大模型服务 本节内容将简单介绍一下如何在讯飞星火大模型官网，申请试用星火大模型，并创建星火大模型的应用。
星火大模型官方地址：讯飞星火认知大模型-AI大语言模型-星火大模型-科大讯飞 (xfyun.cn)
在申请星火大模型服务之前，需要先注册讯飞的账户，使用手机号码验证就可以了，这里不多赘述。在星火大模型官方站点主页，找到【API测试】按钮，可以点击进入API试用申请的页面。
点击【API测试申请】，即可进入API测试申请界面，如图所示：
在API申请界面中，填写必填的信息。这里需要注意一下，申请API测试，需要创建一个讯飞的应用，我们可以填写一个自己实现申请号的应用ID，也可以在申请页面点击创建一个新的应用，创建应用成功之后，我们就能够获得应用的密钥，这个在后面的接口对接会使用的到。
申请提交之后，耐心等待官方审核即可。时间不会太久，我大概是半小时左右，就完成审批，拿到api的试用服务了。
3.对接API服务 星火大模型应用申请完成之后，我们就可以拿到应用的密钥。进入到讯飞开放平台的控制台界面，选择到新创建的星火大模型服务，我们就可以看到服务剩余的token数，以及应用的密钥信息了。这个页面可以切换查看V1.5和V2.0两个版本的token使用情况。
3.1 API对接流程 星火大模型的接口对接，考虑到跨平台的兼容性，这里选择采用web方式对接，根据官方文档的说明，我们首先需要调用鉴权接口，获取到接口授权，然后在使用websocket协议与服务端握手，websocket握手成功后，需要在60秒内发送请求。接口采用的是流式输出模式，需要对根据返回的数据判断，并拼接成完整的回复信息，大致流程如下如所示：
接下来，将描述一下具体的代码实现。
3.2 接口鉴权 根据官方文档的说明，开发者需要自行先在控制台创建应用，利用应用中提供的appid，APIKey， APISecret进行鉴权，生成最终请求的鉴权url，鉴权参数如下：
参数类型必须说明示例hoststring是请求的主机aichat.xf-yun.com(使用时需替换为实际使用的接口地址）datestring是当前时间戳，采用RFC1123格式，时间偏差需控制在300s内Fri, 05 May 2023 10:43:39 GMTauthorizationstring是base64编码的签名信息参考下方生成方式 以下是在unity端实现鉴权url的处理代码：
/// &lt;summary&gt; /// 获取鉴权url /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; private string GetAuthUrl() { string date = DateTime.UtcNow.ToString(&#34;r&#34;); Uri uri = new Uri(url); StringBuilder builder = new StringBuilder(&#34;host: &#34;).Append(uri.Host).Append(&#34;\n&#34;).// Append(&#34;date: &#34;).Append(date).Append(&#34;\n&#34;).// Append(&#34;GET &#34;).Append(uri.LocalPath).Append(&#34; HTTP/1.1&#34;); string sha = HMACsha256(m_XunfeiSettings.m_APISecret, builder.ToString()); string authorization = string.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-08-30T20:20:58+08:00">
    <meta property="article:modified_time" content="2023-08-30T20:20:58+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Unity&#43;讯飞星火大模型&#43;Web api，实现二次元小姐姐AI聊天互动</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="749" src="https://images2.imgbox.com/58/0b/TfrkTjq3_o.png" width="1200"></p> 
<h3 style="background-color:transparent;">1.简述</h3> 
<p>        最近讯飞的星火大模型更新了2.0版本，增强了AI的语言生成能力。毕竟是国产大语言模型，我也尝试使用了一下星火大模型的应用广场，体验还是很不错的。应用广场提供了很多AI助手工具，也支持用户创建自己的AI助手，能力不局限于自然语言生成，也有一些图片生成工具、视频生成工具之类的，总的来说，还是很有意思的。</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/fc/5f/E9OzDpGg_o.png" width="1200"></p> 
<p>        同时，星火大模型也提供有api服务，可以很方便的集成到自己的应用里。申请api应用的门槛也比较低，简单填写一些信息，就可以申请试用。试用审核大概半个多小时就结束了，官方提供的免费token数量还是比较可观。针对星火大模型V1.5版本以及V2.0版本，各提供了200万的token试用，非常的良心。我的AI二次元小姐姐项目里，使用chatgpt以及一些开源模型的方式，相对来说还是有一定使用门槛，而接入星火大模型门槛就很低了。</p> 
<p>        本文就简单介绍一下unity端集成星火大模型API的代码实现，让星火大模型驱动我们的AI二次元小姐姐，与大家聊天吧。</p> 
<h3>2.开通星火大模型服务</h3> 
<p>        本节内容将简单介绍一下如何在讯飞星火大模型官网，申请试用星火大模型，并创建星火大模型的应用。</p> 
<p><strong>星火大模型官方地址</strong>：<a href="https://xinghuo.xfyun.cn/?ch=bdtg_xh_kw672&amp;bd_vid=9698672378283635273" rel="nofollow" title="讯飞星火认知大模型-AI大语言模型-星火大模型-科大讯飞 (xfyun.cn)">讯飞星火认知大模型-AI大语言模型-星火大模型-科大讯飞 (xfyun.cn)</a></p> 
<p>        在申请星火大模型服务之前，需要先注册讯飞的账户，使用手机号码验证就可以了，这里不多赘述。在星火大模型官方站点主页，找到【API测试】按钮，可以点击进入API试用申请的页面。</p> 
<p><img alt="" height="654" src="https://images2.imgbox.com/07/48/z4gB3c3K_o.png" width="1200"></p> 
<p><img alt="" height="560" src="https://images2.imgbox.com/7e/d0/L4FbhoFV_o.png" width="1030"></p> 
<p>        点击【API测试申请】，即可进入API测试申请界面，如图所示：</p> 
<p><img alt="" height="1094" src="https://images2.imgbox.com/73/90/bnpdhlDq_o.png" width="1200"></p> 
<p>        在API申请界面中，填写必填的信息。这里需要注意一下，申请API测试，需要创建一个讯飞的应用，我们可以填写一个自己实现申请号的应用ID，也可以在申请页面点击创建一个新的应用，创建应用成功之后，我们就能够获得应用的密钥，这个在后面的接口对接会使用的到。</p> 
<p>        申请提交之后，耐心等待官方审核即可。时间不会太久，我大概是半小时左右，就完成审批，拿到api的试用服务了。</p> 
<h3 style="background-color:transparent;">3.对接API服务</h3> 
<p>        星火大模型应用申请完成之后，我们就可以拿到应用的密钥。进入到讯飞开放平台的控制台界面，选择到新创建的星火大模型服务，我们就可以看到服务剩余的token数，以及应用的密钥信息了。这个页面可以切换查看V1.5和V2.0两个版本的token使用情况。</p> 
<p><img alt="" height="915" src="https://images2.imgbox.com/e8/ad/uXHkD2jD_o.png" width="1200"></p> 
<h4>3.1 API对接流程</h4> 
<p>        星火大模型的接口对接，考虑到跨平台的兼容性，这里选择采用web方式对接，根据官方文档的说明，我们首先需要调用鉴权接口，获取到接口授权，然后在使用websocket协议与服务端握手，websocket握手成功后，需要在60秒内发送请求。接口采用的是流式输出模式，需要对根据返回的数据判断，并拼接成完整的回复信息，大致流程如下如所示：</p> 
<p><img alt="" height="409" src="https://images2.imgbox.com/0b/0c/rHH1g4dM_o.png" width="876"></p> 
<p>        接下来，将描述一下具体的代码实现。</p> 
<h4 style="background-color:transparent;">3.2 接口鉴权</h4> 
<p>        根据官方文档的说明，开发者需要自行先在控制台创建应用，利用应用中提供的appid，APIKey， APISecret进行鉴权，生成最终请求的鉴权url，鉴权参数如下：</p> 
<table><thead><tr><th>参数</th><th>类型</th><th style="width:92px;">必须</th><th style="width:199px;">说明</th><th>示例</th></tr></thead><tbody><tr><td>host</td><td>string</td><td style="width:92px;">是</td><td style="width:199px;">请求的主机</td><td>aichat.xf-yun.com(使用时需替换为实际使用的接口地址）</td></tr><tr><td>date</td><td>string</td><td style="width:92px;">是</td><td style="width:199px;">当前时间戳，采用RFC1123格式，时间偏差需控制在300s内</td><td>Fri, 05 May 2023 10:43:39 GMT</td></tr><tr><td>authorization</td><td>string</td><td style="width:92px;">是</td><td style="width:199px;">base64编码的签名信息</td><td>参考下方生成方式</td></tr></tbody></table> 
<p>        以下是在unity端实现鉴权url的处理代码：</p> 
<pre><code class="language-cs">/// &lt;summary&gt;
    /// 获取鉴权url
    /// &lt;/summary&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    private string GetAuthUrl()
    {
        string date = DateTime.UtcNow.ToString("r");

        Uri uri = new Uri(url);
        StringBuilder builder = new StringBuilder("host: ").Append(uri.Host).Append("\n").//
                                Append("date: ").Append(date).Append("\n").//
                                Append("GET ").Append(uri.LocalPath).Append(" HTTP/1.1");

        string sha = HMACsha256(m_XunfeiSettings.m_APISecret, builder.ToString());
        string authorization = string.Format("api_key=\"{0}\", algorithm=\"{1}\", headers=\"{2}\", signature=\"{3}\"", m_XunfeiSettings.m_APIKey, "hmac-sha256", "host date request-line", sha);

        string NewUrl = "https://" + uri.Host + uri.LocalPath;

        string path1 = "authorization" + "=" + Convert.ToBase64String(System.Text.Encoding.UTF8.GetBytes(authorization));
        date = date.Replace(" ", "%20").Replace(":", "%3A").Replace(",", "%2C");
        string path2 = "date" + "=" + date;
        string path3 = "host" + "=" + uri.Host;

        NewUrl = NewUrl + "?" + path1 + "&amp;" + path2 + "&amp;" + path3;
        return NewUrl;
    }

    public string HMACsha256(string apiSecretIsKey, string buider)
    {
        byte[] bytes = System.Text.Encoding.UTF8.GetBytes(apiSecretIsKey);
        System.Security.Cryptography.HMACSHA256 hMACSHA256 = new System.Security.Cryptography.HMACSHA256(bytes);
        byte[] date = System.Text.Encoding.UTF8.GetBytes(buider);
        date = hMACSHA256.ComputeHash(date);
        hMACSHA256.Clear();

        return Convert.ToBase64String(date);

    }</code></pre> 
<h4 style="background-color:transparent;">3.3 接口请求</h4> 
<h5 style="background-color:transparent;">       3.3.1 接口费用与服务地址</h5> 
<p>        根据官方文档说明，星火大模型的1.5版本以及2.0版本的计费模型以及资源地址是不同的，当然我们免费申请的服务是不需要额外付费的，但超过额度了的话，就需要付费了，token的价格如下所示：</p> 
<table><thead><tr><th>服务引擎</th><th>单价</th></tr></thead><tbody><tr><td>讯飞星火认知大模型V1.5</td><td>0.18元/万tokens</td></tr><tr><td>讯飞星火认知大模型V2.0</td><td>0.36元/万tokens</td></tr></tbody></table> 
<p>        两个版本的api地址分别是：</p> 
<p>        ①星火大模型1.5版本请求地址，对应的domain参数为general</p> 
<pre><code>ws(s)://spark-api.xf-yun.com/v1.1/chat
</code></pre> 
<p>        ②星火大模型1.5版本请求地址，对应的domain参数为generalv2：</p> 
<pre><code>ws(s)://spark-api.xf-yun.com/v2.1/chat</code></pre> 
<h5>3.3.2 发送报文结构        </h5> 
<p>        星火大模型的API服务对接部分，按照文档说明，使用websocket协议握手成功之后，就可以根据报文格式发送信息了。请求参数参数部分的接口说明如下：</p> 
<p><strong>header部分</strong></p> 
<table><thead><tr><th>参数名称</th><th>类型</th><th>必传</th><th>参数要求</th><th>参数说明</th></tr></thead><tbody><tr><td>app_id</td><td>string</td><td>是</td><td></td><td>应用appid，从开放平台控制台创建的应用中获取</td></tr><tr><td>uid</td><td>string</td><td>否</td><td>最大长度32</td><td>每个用户的id，用于区分不同用户</td></tr></tbody></table> 
<p><strong>parameter.chat部分</strong></p> 
<table><thead><tr><th>参数名称</th><th>类型</th><th>必传</th><th>参数要求</th><th>参数说明</th></tr></thead><tbody><tr><td>domain</td><td>string</td><td>是</td><td>取值为[general,generalv2]</td><td>指定访问的领域,general指向V1.5版本 generalv2指向V2版本。注意：不同的取值对应的url也不一样！</td></tr><tr><td>temperature</td><td>float</td><td>否</td><td>取值为[0,1],默认为0.5</td><td>核采样阈值。用于决定结果随机性，取值越高随机性越强即相同的问题得到的不同答案的可能性越高</td></tr><tr><td>max_tokens</td><td>int</td><td>否</td><td>取值为[1,4096]，默认为2048</td><td>模型回答的tokens的最大长度</td></tr><tr><td>top_k</td><td>int</td><td>否</td><td>取值为[1，6],默认为4</td><td>从k个候选中随机选择⼀个（⾮等概率）</td></tr><tr><td>chat_id</td><td>string</td><td>否</td><td>需要保障用户下的唯一性</td><td>用于关联用户会话</td></tr></tbody></table> 
<p><strong>payload.message.text部分</strong></p> 
<p><em>注：text下所有content累计内容 tokens需要控制在8192内</em></p> 
<table><thead><tr><th>参数名称</th><th>类型</th><th>必传</th><th>参数要求</th><th>参数说明</th></tr></thead><tbody><tr><td>role</td><td>string</td><td>是</td><td>取值为[user,assistant]</td><td>user表示是用户的问题，assistant表示AI的回复</td></tr><tr><td>content</td><td>string</td><td>是</td><td>所有content的累计tokens需控制8192以内</td><td>用户和AI的对话内容</td></tr></tbody></table> 
<p id="_1-4-接口响应">报文示例：</p> 
<pre><code class="language-cs">{
        "header": {
            "app_id": "12345",
            "uid": "12345"
        },
        "parameter": {
            "chat": {
                "domain": "general",
                "temperature": 0.5,
                "max_tokens": 1024, 
            }
        },
        "payload": {
            "message": {
                # 如果想获取结合上下文的回答，需要开发者每次将历史问答信息一起传给服务端，如下示例
                # 注意：text里面的所有content内容加一起的tokens需要控制在8192以内，开发者如有较长对话需求，需要适当裁剪历史信息
                "text": [
                    {"role": "user", "content": "你是谁"} # 用户的历史问题
                    {"role": "assistant", "content": "....."}  # AI的历史回答结果
                    # ....... 省略的历史对话
                    {"role": "user", "content": "你会做什么"}  # 最新的一条问题，如无需上下文，可只传最新一条问题
                ]
        }
    }
}</code></pre> 
<h5>        3.3.3 响应报文结构</h5> 
<p>        接口服务将采用流式输出方式，返回回复信息，我们需要解析返回的报文信息，拼接成完整的回复信息。接口响应的报文结构如下所示：</p> 
<p><strong>header部分</strong></p> 
<table><thead><tr><th>字段名</th><th>类型</th><th>字段说明</th></tr></thead><tbody><tr><td>code</td><td>int</td><td>错误码，0表示正常，非0表示出错；详细释义可在接口说明文档最后的错误码说明了解</td></tr><tr><td>message</td><td>string</td><td>会话是否成功的描述信息</td></tr><tr><td>sid</td><td>string</td><td>会话的唯一id，用于讯飞技术人员查询服务端会话日志使用,出现调用错误时建议留存该字段</td></tr><tr><td>status</td><td>int</td><td>会话状态，取值为[0,1,2]；0代表首次结果；1代表中间结果；2代表最后一个结果</td></tr></tbody></table> 
<p><strong>payload.choices部分</strong></p> 
<table><thead><tr><th>字段名</th><th>类型</th><th>字段说明</th></tr></thead><tbody><tr><td>status</td><td>int</td><td>文本响应状态，取值为[0,1,2]; 0代表首个文本结果；1代表中间文本结果；2代表最后一个文本结果</td></tr><tr><td>seq</td><td>int</td><td>返回的数据序号，取值为[0,9999999]</td></tr><tr><td>content</td><td>string</td><td>AI的回答内容</td></tr><tr><td>role</td><td>string</td><td>角色标识，固定为assistant，标识角色为AI</td></tr><tr><td>index</td><td>int</td><td>结果序号，取值为[0,10]; 当前为保留字段，开发者可忽略</td></tr></tbody></table> 
<p><strong>payload.usage部分(在最后一次结果返回)</strong></p> 
<table><thead><tr><th>字段名</th><th>类型</th><th>字段说明</th></tr></thead><tbody><tr><td>question_tokens</td><td>int</td><td>保留字段，可忽略</td></tr><tr><td>prompt_tokens</td><td>int</td><td>包含历史问题的总tokens大小</td></tr><tr><td>completion_tokens</td><td>int</td><td>回答的tokens大小</td></tr><tr><td>total_tokens</td><td>int</td><td>prompt_tokens和completion_tokens的和，也是本次交互计费的tokens大小</td></tr></tbody></table> 
<p style="background-color:transparent;">        接口响应报文结构示例：</p> 
<pre><code class="language-cs"># 接口为流式返回，此示例为最后一次返回结果，开发者需要将接口多次返回的结果进行拼接展示
{
    "header":{
        "code":0,
        "message":"Success",
        "sid":"cht000cb087@dx18793cd421fb894542",
        "status":2
    },
    "payload":{
        "choices":{
            "status":2,
            "seq":0,
            "text":[
                {
                    "content":"我可以帮助你的吗？",
                    "role":"assistant",
                    "index":0
                }
            ]
        },
        "usage":{
            "text":{
                "question_tokens":4,
                "prompt_tokens":5,
                "completion_tokens":9,
                "total_tokens":14
            }
        }
    }
}</code></pre> 
<p style="background-color:transparent;"></p> 
<h5 id="_2-调用示例" style="background-color:transparent;">3.3.4 接口对接代码示例</h5> 
<p>        使用websocket协议与服务端握手成功后，按照报文格式要求发送信息，等待接口响应，并解析响应数据拼接成完整的回复信息。代码示例如下所示：</p> 
<pre><code class="language-cs">    #region websocket连接
    /// &lt;summary&gt;
    /// websocket
    /// &lt;/summary&gt;
    private ClientWebSocket m_WebSocket;
    private CancellationToken m_CancellationToken;
    /// &lt;summary&gt;
    /// 连接服务器，获取回复
    /// &lt;/summary&gt;
    private async void ConnectHost(string text,Action&lt;string&gt; _callback)
    {
        try
        {
            stopwatch.Restart();

            m_WebSocket = new ClientWebSocket();
            m_CancellationToken = new CancellationToken();
            string authUrl = GetAuthUrl();
            string url = authUrl.Replace("http://", "ws://").Replace("https://", "wss://");

            //Uri uri = new Uri(GetUrl());
            Uri uri = new Uri(url);
            await m_WebSocket.ConnectAsync(uri, m_CancellationToken);

            //发送json
            string _jsonData = text;
            await m_WebSocket.SendAsync(new ArraySegment&lt;byte&gt;(Encoding.UTF8.GetBytes(_jsonData)), WebSocketMessageType.Binary, true, m_CancellationToken); //发送数据
            StringBuilder sb = new StringBuilder();
            //用于拼接返回的答复
            string _callBackMessage = "";

            //播放队列.Clear();
            while (m_WebSocket.State == WebSocketState.Open)
            {
                var result = new byte[4096];
                await m_WebSocket.ReceiveAsync(new ArraySegment&lt;byte&gt;(result), m_CancellationToken);//接受数据
                List&lt;byte&gt; list = new List&lt;byte&gt;(result); while (list[list.Count - 1] == 0x00) list.RemoveAt(list.Count - 1);//去除空字节  
                var str = Encoding.UTF8.GetString(list.ToArray());
                sb.Append(str);
                if (str.EndsWith("}"))
                {
                    //获取返回的数据
                    ResponseData _responseData = JsonUtility.FromJson&lt;ResponseData&gt;(sb.ToString());
                    sb.Clear();

                    if (_responseData.header.code != 0)
                    {
                        //返回错误
                        //PrintErrorLog(_responseData.code);
                        Debug.Log("错误码：" + _responseData.header.code);
                        m_WebSocket.Abort();
                        break;
                    }
                    //没有回复数据
                    if (_responseData.payload.choices.text.Count == 0)
                    {
                        Debug.LogError("没有获取到回复的信息！");
                        m_WebSocket.Abort();
                        break;
                    }
                    //拼接回复的数据
                    _callBackMessage += _responseData.payload.choices.text[0].content;

                    if (_responseData.payload.choices.status == 2)
                    {
                        stopwatch.Stop();
                        Debug.Log("ChatSpark耗时：" + stopwatch.Elapsed.TotalSeconds);

                        //添加记录
                        m_DataList.Add(new SendData("assistant", _callBackMessage));

                        //回调
                        _callback(_callBackMessage);
                        m_WebSocket.Abort();
                        break;
                    }
                }
            }

        }
        catch (Exception ex)
        {
            Debug.LogError("报错信息: " + ex.Message);
            m_WebSocket.Dispose();
        }
    }

    #endregion
</code></pre> 
<h4 style="background-color:transparent;">4.结束语</h4> 
<p>        这次的文章简单介绍了讯飞星火大模型的web api的对接流程，并针对接口对接的流程进行了介绍，包括接口的鉴权、websocket握手以及发送报文、响应报文的结构说明，并提供了针对全流程在unity端的实现代码示例。通过上述的代码实现，我们就可以在unity引擎中，使用星火大模型的api来驱动AI二次元小姐姐的对话交互。</p> 
<p>        上述代码只包含了核心的代码实现，完整的代码工程可以从我的开源项目下载使用，项目包含了针对多种GPT应用的集成工具，以及语音服务的集成，对我这个项目感兴趣的朋友，可以上我的B站号查看，我也做有详细的教程，相关源码可以在的哔哩哔哩主站找到相关视频，在视频介绍以及评论区获取。</p> 
<div class="csdn-video-box"> 
 <iframe id="tMZowkqV-1693397804341" frameborder="0" src="https://player.bilibili.com/player.html?aid=447513834" allowfullscreen="true" data-mediaembed="bilibili"></iframe> 
 <p>国产星火大模型驱动AI小姐姐聊天，unity开源工具包，手把手打造自己的二次元老婆~</p> 
</div> 
<p></p> 
<hr> 
<p>上述项目地址传送门：</p> 
<p><strong>AI二次元老婆开源项目(unity-AI-Chat-Toolkit):</strong></p> 
<p>Github地址：https://github.com/zhangliwei7758/unity-AI-Chat-Toolkit</p> 
<p>Gitee地址：https://gitee.com/DammonSpace/unity-ai-chat-toolkit</p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/53eb065eb1cc138e9c4c5809c05353a9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring-SpringBoot-SpringMVC-MyBatis常见面试题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/133977dff1bfa35fcdd1ed8152987610/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java数字转中文大写工具类（拿去即用）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>