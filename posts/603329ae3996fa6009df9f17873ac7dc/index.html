<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>动态规划-背包问题详解 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/603329ae3996fa6009df9f17873ac7dc/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="动态规划-背包问题详解">
  <meta property="og:description" content="文章目录 一、动态规划问题说明1.题目问题2.Dp解题思路 二、01背包问题1.问题描述输入格式输出格式数据范围输入样例输出样例 2.朴素算法代码 3.优化算法代码 三、完全背包问题1.问题描述输入格式输出格式数据范围输入样例输出样例 2.朴素算法代码 3.优化算法代码 四、多重背包问题1.问题描述输入格式输出格式数据范围输入样例输出样例 2.朴素算法代码 3.优化算法代码 五、分组背包问题1.问题描述输入格式输出格式数据范围输入样例输出样例 2.优化算法代码 六、总结 一、动态规划问题说明 1.题目问题 首先给出背包的容量，接着：
01背包问题：给出每个物品的体积和质量，每个物品最多只能使用一次完全背包问题：给出每个物品的体积和质量，每个物品可以无限次使用多重背包问题：给出每个物品的体积、质量和数量，每个物品使用量必须在每个物品给定的数量之类分组背包问题：给出每个物品的体积、质量和它们的分组，每个组中最多只能取一件物品 在背包的限制之内，做出抉择，选择物品填充背包，使得最终背包的质量最大。
2.Dp解题思路 Dp由于变化较多，没有固定模板，可以从两个方面入手分析，即：状态表示和状态计算，我们把状态设为f[i][j]
状态表示f[i][j]:它表示在前i种物品种选取，使得容量不超过j，满足该情况的所有情况集合，在集合中选取最优解，该最优解的质量即为f[i][j]的值状态计算：即如何计算f[i][j]，每种情况有所不同，且可以优化，优化方式也有所不同，在下面实例分析中进行详细讲解 二、01背包问题 1.问题描述 有 N 件物品和一个容量是 V的背包。每件物品只能使用一次。
第 i件物品的体积是 vi，价值是 wi。
求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。
输入格式 第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。
接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。
输出格式 输出一个整数，表示最大价值。
数据范围 0&lt;N,V≤1000
0&lt;vi,wi≤1000
输入样例 4 5 1 2 2 4 3 4 4 5 输出样例 8 2.朴素算法 我们可以把f[i][j]的状态计算下分，分为对两种情况的取最大值：不包括第i种物品和包括第i种物品不包括第i种物品：f[i-1][j]包括第i种物品：f[i-1][j-v[i]]&#43;w[i]，即已经含有了第i种物品 代码 #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; const int N = 1010; //物品的最大数量 int n,m; //n是物品数量，m是背包的容量 int v[N], w[N]; //v[i]是第i件物品的体积，w[i]是第i件物品的质量 int f[N][N]; //状态表示,全局变量初始化为0 int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1;i &lt;= n;i &#43;&#43; ) cin &gt;&gt; v[i] &gt;&gt; w[i]; for(int i = 1;i &lt;= n;i &#43;&#43; ) for(int j = 0;j &lt;= m;j &#43;&#43; ) { f[i][j] = f[i - 1][j]; //只有在给定的j容量大于第i个物品的体积时，才可以放第i个物品，不然程序会错误 if(j &gt;= v[i]) f[i][j] = max(f[i][j],f[i - 1][j - v[i]] &#43; w[i]); } cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0; } 3.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-01-21T20:34:37+08:00">
    <meta property="article:modified_time" content="2024-01-21T20:34:37+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">动态规划-背包问题详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">一、动态规划问题说明</a></li><li><ul><li><a href="#1_2" rel="nofollow">1.题目问题</a></li><li><a href="#2Dp_10" rel="nofollow">2.Dp解题思路</a></li></ul> 
  </li><li><a href="#01_15" rel="nofollow">二、01背包问题</a></li><li><ul><li><a href="#1_16" rel="nofollow">1.问题描述</a></li><li><ul><li><ul><li><a href="#_24" rel="nofollow">输入格式</a></li><li><a href="#_30" rel="nofollow">输出格式</a></li><li><a href="#_34" rel="nofollow">数据范围</a></li><li><a href="#_39" rel="nofollow">输入样例</a></li><li><a href="#_49" rel="nofollow">输出样例</a></li></ul> 
   </li></ul> 
   </li><li><a href="#2_54" rel="nofollow">2.朴素算法</a></li><li><ul><li><ul><li><a href="#_59" rel="nofollow">代码</a></li></ul> 
   </li></ul> 
   </li><li><a href="#3_90" rel="nofollow">3.优化算法</a></li><li><ul><li><ul><li><a href="#_96" rel="nofollow">代码</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#_123" rel="nofollow">三、完全背包问题</a></li><li><ul><li><a href="#1_124" rel="nofollow">1.问题描述</a></li><li><ul><li><ul><li><a href="#_132" rel="nofollow">输入格式</a></li><li><a href="#_138" rel="nofollow">输出格式</a></li><li><a href="#_142" rel="nofollow">数据范围</a></li><li><a href="#_147" rel="nofollow">输入样例</a></li><li><a href="#_157" rel="nofollow">输出样例</a></li></ul> 
   </li></ul> 
   </li><li><a href="#2_162" rel="nofollow">2.朴素算法</a></li><li><ul><li><ul><li><a href="#_164" rel="nofollow">代码</a></li></ul> 
   </li></ul> 
   </li><li><a href="#3_193" rel="nofollow">3.优化算法</a></li><li><ul><li><ul><li><a href="#_198" rel="nofollow">代码</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#_225" rel="nofollow">四、多重背包问题</a></li><li><ul><li><a href="#1_226" rel="nofollow">1.问题描述</a></li><li><ul><li><ul><li><a href="#_234" rel="nofollow">输入格式</a></li><li><a href="#_240" rel="nofollow">输出格式</a></li><li><a href="#_244" rel="nofollow">数据范围</a></li><li><a href="#_250" rel="nofollow">输入样例</a></li><li><a href="#_260" rel="nofollow">输出样例</a></li></ul> 
   </li></ul> 
   </li><li><a href="#2_265" rel="nofollow">2.朴素算法</a></li><li><ul><li><ul><li><a href="#_268" rel="nofollow">代码</a></li></ul> 
   </li></ul> 
   </li><li><a href="#3_297" rel="nofollow">3.优化算法</a></li><li><ul><li><ul><li><a href="#_303" rel="nofollow">代码</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#_354" rel="nofollow">五、分组背包问题</a></li><li><ul><li><a href="#1_355" rel="nofollow">1.问题描述</a></li><li><ul><li><ul><li><a href="#_365" rel="nofollow">输入格式</a></li><li><a href="#_374" rel="nofollow">输出格式</a></li><li><a href="#_378" rel="nofollow">数据范围</a></li><li><a href="#_384" rel="nofollow">输入样例</a></li><li><a href="#_397" rel="nofollow">输出样例</a></li></ul> 
   </li></ul> 
   </li><li><a href="#2_402" rel="nofollow">2.优化算法</a></li><li><ul><li><ul><li><a href="#_405" rel="nofollow">代码</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#_438" rel="nofollow">六、总结</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>一、动态规划问题说明</h2> 
<h3><a id="1_2"></a>1.题目问题</h3> 
<p>首先给出背包的容量，接着：</p> 
<ul><li>01背包问题：给出每个物品的体积和质量，每个物品最多只能使用一次</li><li>完全背包问题：给出每个物品的体积和质量，每个物品可以无限次使用</li><li>多重背包问题：给出每个物品的体积、质量和数量，每个物品使用量必须在每个物品给定的数量之类</li><li>分组背包问题：给出每个物品的体积、质量和它们的分组，每个组中最多只能取一件物品</li></ul> 
<p>在背包的限制之内，做出抉择，选择物品填充背包，使得最终背包的质量最大。</p> 
<h3><a id="2Dp_10"></a>2.Dp解题思路</h3> 
<p>Dp由于变化较多，没有固定模板，可以从两个方面入手分析，即：状态表示和状态计算，我们把状态设为f[i][j]</p> 
<ul><li>状态表示f[i][j]:它表示在前i种物品种选取，使得容量不超过j，满足该情况的所有情况集合，在集合中选取最优解，该最优解的质量即为f[i][j]的值</li><li>状态计算：即如何计算f[i][j]，每种情况有所不同，且可以优化，优化方式也有所不同，在下面实例分析中进行详细讲解</li></ul> 
<h2><a id="01_15"></a>二、01背包问题</h2> 
<h3><a id="1_16"></a>1.问题描述</h3> 
<p>有 N 件物品和一个容量是 V的背包。每件物品只能使用一次。</p> 
<p>第 i件物品的体积是 vi，价值是 wi。</p> 
<p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br> 输出最大价值。</p> 
<h5><a id="_24"></a>输入格式</h5> 
<p>第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。</p> 
<p>接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。</p> 
<h5><a id="_30"></a>输出格式</h5> 
<p>输出一个整数，表示最大价值。</p> 
<h5><a id="_34"></a>数据范围</h5> 
<p>0&lt;N,V≤1000<br> 0&lt;vi,wi≤1000</p> 
<h5><a id="_39"></a>输入样例</h5> 
<pre><code>4 5
1 2
2 4
3 4
4 5
</code></pre> 
<h5><a id="_49"></a>输出样例</h5> 
<pre><code>8
</code></pre> 
<h3><a id="2_54"></a>2.朴素算法</h3> 
<ul><li>我们可以把f[i][j]的状态计算下分，分为对两种情况的取最大值：不包括第i种物品和包括第i种物品</li><li>不包括第i种物品：f[i-1][j]</li><li>包括第i种物品：f[i-1][j-v[i]]+w[i]，即已经含有了第i种物品</li></ul> 
<h5><a id="_59"></a>代码</h5> 
<pre><code class="prism language-C++">#include&lt;iostream&gt;
#include&lt;algorithm&gt;

using namespace std;

const int N = 1010; //物品的最大数量 

int n,m; //n是物品数量，m是背包的容量
int v[N], w[N]; //v[i]是第i件物品的体积，w[i]是第i件物品的质量
int f[N][N]; //状态表示,全局变量初始化为0 

int main()
{
	cin &gt;&gt; n &gt;&gt; m;
	for(int i = 1;i &lt;= n;i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i];
	
	for(int i = 1;i &lt;= n;i ++ )
	    for(int j = 0;j &lt;= m;j ++ )
	    {
	    	f[i][j] = f[i - 1][j];
	    	//只有在给定的j容量大于第i个物品的体积时，才可以放第i个物品，不然程序会错误 
	    	if(j &gt;= v[i]) f[i][j] = max(f[i][j],f[i - 1][j - v[i]] + w[i]);
		}
		
	cout &lt;&lt; f[n][m] &lt;&lt; endl;
	
	return 0;
}
</code></pre> 
<h3><a id="3_90"></a>3.优化算法</h3> 
<ul><li>我们可以把二维f[i][j]化为一维f[j]</li><li>状态计算则变为：f[j]=max(f[j],f[j-v[i]]+w[i])</li><li>出现问题：如果第二个循环依旧从前往后，则计算f[j]=max(f[j],f[j-v[i]]+w[i])时，已经在第i层中遍历过f[j-v[i]]+w[i]，即此时的f[j-v[i]]+w[i]用二维表示为f[i-1][j-v[i]]+w[i]，而非f[i][j-v[i]]+w[i]，所以第二个循环要从后往前遍历</li><li>第二个循环可以再简化：j的最小值遍历到v[i]，由于所有f[0~n][j]都存在f[j]中，所以不用遍历小于等于v[i]的部分</li></ul> 
<h5><a id="_96"></a>代码</h5> 
<pre><code class="prism language-C++">#include&lt;iostream&gt;
#include&lt;algorithm&gt;

using namespace std;

const int N = 1010; //物品的最大数量 

int n,m; //n是物品数量，m是背包的容量
int v[N], w[N]; //v[i]是第i件物品的体积，w[i]是第i件物品的质量
int f[N]; //状态表示,全局变量初始化为0 

int main()
{
	cin &gt;&gt; n &gt;&gt; m;
	for(int i = 1;i &lt;= n;i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i];
	
	for(int i = 1;i &lt;= n;i ++ )
	    for(int j = m;j &gt;= v[i];j -- )
	    	f[j] = max(f[j],f[j - v[i]] + w[i]);
		
	cout &lt;&lt; f[m] &lt;&lt; endl;
	
	return 0;
}
</code></pre> 
<h2><a id="_123"></a>三、完全背包问题</h2> 
<h3><a id="1_124"></a>1.问题描述</h3> 
<p>有 N种物品和一个容量是 V的背包，每种物品都有无限件可用。</p> 
<p>第 i 种物品的体积是 vi，价值是 wi。</p> 
<p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br> 输出最大价值。</p> 
<h5><a id="_132"></a>输入格式</h5> 
<p>第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。</p> 
<p>接下来有 N行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 种物品的体积和价值。</p> 
<h5><a id="_138"></a>输出格式</h5> 
<p>输出一个整数，表示最大价值。</p> 
<h5><a id="_142"></a>数据范围</h5> 
<p>0&lt;N,V≤1000<br> 0&lt;vi,wi≤1000</p> 
<h5><a id="_147"></a>输入样例</h5> 
<pre><code>4 5
1 2
2 4
3 4
4 5
</code></pre> 
<h5><a id="_157"></a>输出样例</h5> 
<pre><code>10
</code></pre> 
<h3><a id="2_162"></a>2.朴素算法</h3> 
<ul><li>状态计算：我们把f[i][j]分为多种情况取最大值，不取第i个物品，取1个第i个物品，取两个，取三个…，但是满足前提条件是所取的第i物品总质量不大于给定的容量</li></ul> 
<h5><a id="_164"></a>代码</h5> 
<pre><code class="prism language-C++">#include&lt;iostream&gt;
#include&lt;algorithm&gt;

using namespace std;

const int N = 1010; //物品的最大数量 

int n,m; //n是物品数量，m是背包的容量
int v[N], w[N]; //v[i]是第i件物品的体积，w[i]是第i件物品的质量
int f[N][N]; //状态表示,全局变量初始化为0 

int main()
{
	cin &gt;&gt; n &gt;&gt; m;
	for(int i = 1;i &lt;= n;i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i];
	
	for(int i = 1;i &lt;= n;i ++ )
	    for(int j = 0;j &lt;= m;j ++ )
	    	for(int k = 0;k * v[i] &lt;= j;k ++ )
	    	f[i][j] = max(f[i][j],f[i-1][j - k * v[i]] + k * w[i]);
	    	//由于k从0开始，所以已经包含了f[i-1][j]，不需要单独列出 
		
	cout &lt;&lt; f[n][m] &lt;&lt; endl;
	
	return 0;
}
</code></pre> 
<h3><a id="3_193"></a>3.优化算法</h3> 
<ul><li>f[i][j]=max(f[i-1][j],f[i-1][j-v]+w,f[i-1][j-2v]+2w,f[i-1][j-3v]+3w,…)</li><li>f[i][j-v]=max(f[i-1][j-v],f[i-1][j-2v]+w,f[i-1][j-3v]+2w,…)</li><li>综上：f[i][j]=max(f[i-1][j],f[i][j-v]+w)</li><li>继续优化为一维，不过不用倒置，因为都在第i层</li></ul> 
<h5><a id="_198"></a>代码</h5> 
<pre><code class="prism language-C++">#include&lt;iostream&gt;
#include&lt;algorithm&gt;

using namespace std;

const int N = 1010; //物品的最大数量 

int n,m; //n是物品数量，m是背包的容量
int v[N], w[N]; //v[i]是第i件物品的体积，w[i]是第i件物品的质量
int f[N]; //状态表示,全局变量初始化为0 

int main()
{
	cin &gt;&gt; n &gt;&gt; m;
	for(int i = 1;i &lt;= n;i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i];
	
	for(int i = 1;i &lt;= n;i ++ )
	    for(int j = v[i];j &lt;= m;j ++ )
	    	f[j] = max(f[j],f[j - v[i]] + w[i]);
		
	cout &lt;&lt; f[m] &lt;&lt; endl;
	
	return 0;
}
</code></pre> 
<h2><a id="_225"></a>四、多重背包问题</h2> 
<h3><a id="1_226"></a>1.问题描述</h3> 
<p>有 N 种物品和一个容量是 V的背包。</p> 
<p>第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。</p> 
<p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br> 输出最大价值。</p> 
<h5><a id="_234"></a>输入格式</h5> 
<p>第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。</p> 
<p>接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。</p> 
<h5><a id="_240"></a>输出格式</h5> 
<p>输出一个整数，表示最大价值。</p> 
<h5><a id="_244"></a>数据范围</h5> 
<p>0&lt;N≤1000<br> 0&lt;V≤2000<br> 0&lt;vi,wi,si≤2000</p> 
<h5><a id="_250"></a>输入样例</h5> 
<pre><code>4 5
1 2 3
2 4 1
3 4 3
4 5 2
</code></pre> 
<h5><a id="_260"></a>输出样例</h5> 
<pre><code>10
</code></pre> 
<h3><a id="2_265"></a>2.朴素算法</h3> 
<ul><li>在完全背包问题的朴素算法基础上进行</li><li>增加一个判断条件：第三个循环多一个k&lt;=s[i]</li></ul> 
<h5><a id="_268"></a>代码</h5> 
<pre><code class="prism language-C++">#include&lt;iostream&gt;
#include&lt;algorithm&gt;

using namespace std;

const int N = 1010; //物品的最大数量 

int n,m; //n是物品数量，m是背包的容量
int v[N], w[N],s[N]; //v[i]是第i件物品的体积，w[i]是第i件物品的质量，s[i]是第i件物品有多少件
int f[N][N]; //状态表示,全局变量初始化为0 

int main()
{
	cin &gt;&gt; n &gt;&gt; m;
	for(int i = 1;i &lt;= n;i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];
	
	for(int i = 1;i &lt;= n;i ++ )
	    for(int j = 0;j &lt;= m;j ++ )
	    	for(int k = 0;k * v[i] &lt;= j &amp;&amp; k &lt;= s[i];k ++ )
	    	f[i][j] = max(f[i][j],f[i-1][j - k * v[i]] + k * w[i]);
	    	//由于k从0开始，所以已经包含了f[i-1][j]，不需要单独列出 
		
	cout &lt;&lt; f[n][m] &lt;&lt; endl;
	
	return 0;
}
</code></pre> 
<h3><a id="3_297"></a>3.优化算法</h3> 
<ul><li>利用二进制思想，进行拆包简化</li><li>2<sup>0</sup>，2<sup>1</sup>，2<sup>2</sup>，2<sup>3</sup>…2<sup>k</sup>：可以表示出从0到2<sup>k</sup>-1其中的所有数</li><li>2<sup>0</sup>，2<sup>1</sup>，2<sup>2</sup>，2<sup>3</sup>…2<sup>k</sup>，C：可以表示出从0到2<sup>k</sup>+C-1其中的所有数</li><li>接着做一遍01背包问题</li><li>注意：该题相当于把每个物品拆包为logw个物品，所以开N空间时，开为N*logw<sub>max</sub></li></ul> 
<h5><a id="_303"></a>代码</h5> 
<pre><code class="prism language-C++">#include&lt;iostream&gt;
#include&lt;algorithm&gt;

using namespace std;

const int N = 2500; //物品的最大数量,N+logw 

int n,m; //n是物品数量，m是背包的容量
int v[N], w[N]; //v[i]是第i件物品的体积，w[i]是第i件物品的质量
int f[N]; //状态表示,全局变量初始化为0 

int main()
{
	cin &gt;&gt; n &gt;&gt; m;
	
	int cnt=0;
	
	for(int i = 1;i &lt;= n;i ++ )
	{
		int a,b,s;
		cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;
		int k = 1;
		while(k &lt;= s)
		{
			cnt ++ ;
			v[cnt] = a * k;
			w[cnt] = b * k;
			s -= k;
			k *= 2;
		}
		if(s&gt;0) //防止s刚好用完
		{
			cnt ++;
			v[cnt] = a * s;
			w[cnt] = b * s;
		}
	}
	
	n = cnt; //此时物品相当于有cnt个 
		
	for(int i = 1;i &lt;= n;i ++ )
	    for(int j = m;j &gt;= v[i];j -- )
	    	f[j] = max(f[j],f[j - v[i]] + w[i]);
		
	cout &lt;&lt; f[m] &lt;&lt; endl;
	
	return 0;
}
</code></pre> 
<h2><a id="_354"></a>五、分组背包问题</h2> 
<h3><a id="1_355"></a>1.问题描述</h3> 
<p>有 N 组物品和一个容量是 V 的背包。</p> 
<p>每组物品有若干个，同一组内的物品最多只能选一个。<br> 每件物品的体积是 vij，价值是 wij，其中 i 是组号，j 是组内编号。</p> 
<p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p> 
<p>输出最大价值。</p> 
<h5><a id="_365"></a>输入格式</h5> 
<p>第一行有两个整数 N，V，用空格隔开，分别表示物品组数和背包容量。</p> 
<p>接下来有 N 组数据：</p> 
<ul><li>每组数据第一行有一个整数 Si，表示第 i 个物品组的物品数量；</li><li>每组数据接下来有 Si 行，每行有两个整数 vij,wij，用空格隔开，分别表示第 i 个物品组的第 j 个物品的体积和价值；</li></ul> 
<h5><a id="_374"></a>输出格式</h5> 
<p>输出一个整数，表示最大价值。</p> 
<h5><a id="_378"></a>数据范围</h5> 
<p>0&lt;N,V≤100<br> 0&lt;Si≤100<br> 0&lt;vij,wij≤100</p> 
<h5><a id="_384"></a>输入样例</h5> 
<pre><code>3 5
2
1 2
2 4
1
3 4
1
4 5
</code></pre> 
<h5><a id="_397"></a>输出样例</h5> 
<pre><code>8
</code></pre> 
<h3><a id="2_402"></a>2.优化算法</h3> 
<ul><li>相当于在01背包问题上多了一个分组</li><li>分组用一个循环实现，增加第三个循环，遍历每种选择一组中任何一种的情况，取最优解</li></ul> 
<h5><a id="_405"></a>代码</h5> 
<pre><code class="prism language-C++">#include&lt;iostream&gt;
#include&lt;algorithm&gt;

using namespace std;

const int N = 110; //物品的最大数量 

int n,m; //n是物品数量，m是背包的容量
int v[N][N], w[N][N],s[N]; //v[i][j]是第i组第j件物品的体积，w[i][j]是第i组第j件物品的质量,s[i]是第i组有多少个物品 
int f[N]; //状态表示,全局变量初始化为0 

int main()
{
	cin &gt;&gt; n &gt;&gt; m;
	for(int i = 1;i &lt;= n;i ++ )
	{
		cin &gt;&gt; s[i]; //s[i]是第i组有多少个物品 
		for(int j = 0;j &lt; s[i];j ++ )
			cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];
	}
	
	for(int i = 1;i &lt;= n;i ++ )
	    for(int j = m;j &gt;= 0;j -- )
	    	for(int k = 0;k &lt; s[i] &amp;&amp; v[i][k] &lt;= j;k ++ )
	    		f[j] = max(f[j],f[j - v[i][k]] + w[i][k]);
		
	cout &lt;&lt; f[m] &lt;&lt; endl;
	
	return 0;
}
</code></pre> 
<h2><a id="_438"></a>六、总结</h2> 
<p>从上例我们可以看到，01背包问题、多重背包问题、分组背包问题其实十分相似，多重背包优化是进行二进制操作拆包后的01背包优化，分组背包优化是多了一个循环的01背包优化，第二个循环都需要倒置。而完全背包问题相较于01背包问题优化，唯一的区别在于第二个循环是否倒置。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/54d427cd89f11a5b27622966da0c6892/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python MD5加密的三种方法（可加盐）/base64加解密 /RSA加解密</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/df28a7ee92582700ebc90394a0e91947/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">HiveSQL常用函数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>