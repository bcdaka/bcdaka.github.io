<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深入理解SQL中的INNER JOIN操作 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/30282c3ba95b9ff1ad9de3c45482e5f6/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="深入理解SQL中的INNER JOIN操作">
  <meta property="og:description" content="本文介绍了INNER JOIN的定义、使用场景、计算方法及与其他JOIN的比较。INNER JOIN是关系数据库中常用的操作，用于返回两个表中匹配的行，只有在连接条件满足时才返回数据。本文详细解释了INNER JOIN的语法及其在一对多、多对多关系中的应用，通过示例展示其结果集行数的计算方法。此外，文中还比较了INNER JOIN与LEFT JOIN、RIGHT JOIN、FULL JOIN和CROSS JOIN的异同，帮助读者理解不同类型的JOIN在实际查询中的应用场景。通过本文，读者能够掌握INNER JOIN的核心概念和技术细节，提高SQL查询和数据处理的效率。
一、InnerJoin 的定义和概念 在关系数据库中，JOIN操作用于在两个或多个表之间基于某些条件进行连接。INNER JOIN是最常见的JOIN类型之一，它仅返回两个表中匹配的行。了解INNER JOIN的定义和概念对于正确使用和优化SQL查询至关重要。
什么是INNER JOIN？ INNER JOIN用于返回两个表中基于指定条件匹配的行。换句话说，只有当连接条件满足时，才会返回行。如果没有匹配的行，则不会在结果集中包含这些行。
INNER JOIN的语法 标准SQL语法中，INNER JOIN的基本形式如下：
SELECT column_name(s) FROM table1 INNER JOIN table2 ON table1.column_name = table2.column_name; 在这个语法中，table1和table2是要连接的两个表，column_name(s)是要选择的列，ON子句指定了连接条件。
INNER JOIN的使用场景 INNER JOIN广泛应用于各种场景，包括：
数据分析：从多个相关表中检索数据进行分析。数据聚合：结合多个表的数据进行汇总和统计。报告生成：生成基于多表数据的报告。数据验证：验证多个表之间的关系和数据一致性。 通过理解INNER JOIN的定义和概念，可以更有效地应用它来解决实际问题。
二、InnerJoin 关联结果的计算方法 在实际应用中，INNER JOIN的结果集行数取决于连接表之间的关系类型和匹配条件。为了准确计算INNER JOIN的返回行数，我们需要深入了解以下几种情况：
一对多关系和多对多关系 在关系数据库中，一对多关系和多对多关系是两种常见的表关系类型。INNER JOIN在这两种关系中的行为有所不同，但可以通过理解它们的本质来统一计算方法。
一对多关系 在一对多关系中，一个表中的每一行可以与另一个表中的多行相关联。INNER JOIN在一对多关系中的行为主要取决于子表中的匹配行数。
假设：
表 A 具有 m 行。表 B 具有 n 行。表 A 中的每一行可能在表 B 中匹配零行、一行或多行。 如果表 A 中的每一行在表 B 中平均匹配 k 行（k 可以是 0），那么INNER JOIN返回的总行数为 m * k。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-26T13:11:14+08:00">
    <meta property="article:modified_time" content="2024-07-26T13:11:14+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深入理解SQL中的INNER JOIN操作</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>本文介绍了INNER JOIN的定义、使用场景、计算方法及与其他JOIN的比较。INNER JOIN是关系数据库中常用的操作，用于返回两个表中匹配的行，只有在连接条件满足时才返回数据。本文详细解释了INNER JOIN的语法及其在一对多、多对多关系中的应用，通过示例展示其结果集行数的计算方法。此外，文中还比较了INNER JOIN与LEFT JOIN、RIGHT JOIN、FULL JOIN和CROSS JOIN的异同，帮助读者理解不同类型的JOIN在实际查询中的应用场景。通过本文，读者能够掌握INNER JOIN的核心概念和技术细节，提高SQL查询和数据处理的效率。</p> 
<p><img src="https://images2.imgbox.com/ed/33/air45bI7_o.gif" alt="在这里插入图片描述"></p> 
<hr> 
<h3><a id="InnerJoin__6"></a>一、InnerJoin 的定义和概念</h3> 
<p>在关系数据库中，JOIN操作用于在两个或多个表之间基于某些条件进行连接。INNER JOIN是最常见的JOIN类型之一，它仅返回两个表中匹配的行。了解INNER JOIN的定义和概念对于正确使用和优化SQL查询至关重要。</p> 
<h4><a id="INNER_JOIN_10"></a>什么是INNER JOIN？</h4> 
<p>INNER JOIN用于返回两个表中基于指定条件匹配的行。换句话说，只有当连接条件满足时，才会返回行。如果没有匹配的行，则不会在结果集中包含这些行。</p> 
<h4><a id="INNER_JOIN_14"></a>INNER JOIN的语法</h4> 
<p>标准SQL语法中，INNER JOIN的基本形式如下：</p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token keyword">FROM</span> table1
<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> table2
<span class="token keyword">ON</span> table1<span class="token punctuation">.</span>column_name <span class="token operator">=</span> table2<span class="token punctuation">.</span>column_name<span class="token punctuation">;</span>
</code></pre> 
<p>在这个语法中，<code>table1</code>和<code>table2</code>是要连接的两个表，<code>column_name(s)</code>是要选择的列，<code>ON</code>子句指定了连接条件。</p> 
<h4><a id="INNER_JOIN_27"></a>INNER JOIN的使用场景</h4> 
<p>INNER JOIN广泛应用于各种场景，包括：</p> 
<ol><li><strong>数据分析</strong>：从多个相关表中检索数据进行分析。</li><li><strong>数据聚合</strong>：结合多个表的数据进行汇总和统计。</li><li><strong>报告生成</strong>：生成基于多表数据的报告。</li><li><strong>数据验证</strong>：验证多个表之间的关系和数据一致性。</li></ol> 
<p>通过理解INNER JOIN的定义和概念，可以更有效地应用它来解决实际问题。</p> 
<hr> 
<h3><a id="InnerJoin__39"></a>二、InnerJoin 关联结果的计算方法</h3> 
<p>在实际应用中，INNER JOIN的结果集行数取决于连接表之间的关系类型和匹配条件。为了准确计算INNER JOIN的返回行数，我们需要深入了解以下几种情况：</p> 
<h4><a id="_43"></a>一对多关系和多对多关系</h4> 
<p>在关系数据库中，一对多关系和多对多关系是两种常见的表关系类型。INNER JOIN在这两种关系中的行为有所不同，但可以通过理解它们的本质来统一计算方法。</p> 
<h5><a id="_47"></a>一对多关系</h5> 
<p>在一对多关系中，一个表中的每一行可以与另一个表中的多行相关联。INNER JOIN在一对多关系中的行为主要取决于子表中的匹配行数。</p> 
<p>假设：</p> 
<ul><li>表 A 具有 m 行。</li><li>表 B 具有 n 行。</li><li>表 A 中的每一行可能在表 B 中匹配零行、一行或多行。</li></ul> 
<p>如果表 A 中的每一行在表 B 中平均匹配 k 行（k 可以是 0），那么INNER JOIN返回的总行数为 <code>m * k</code>。</p> 
<h5><a id="_58"></a>多对多关系</h5> 
<p>在多对多关系中，一个表中的每一行可以与另一个表中的多行相关联，反之亦然。这种关系通常通过一个中间表（交叉表）来实现，该表包含两个表的外键。</p> 
<p>假设：</p> 
<ul><li>表 A 具有 m 行。</li><li>表 B 具有 n 行。</li><li>中间表 C 具有 p 行，表示表 A 和表 B 之间的关系数量。</li></ul> 
<p>在这种情况下，INNER JOIN的结果集行数通常等于中间表 C 的行数，即 p 行。</p> 
<h4><a id="Inner_Join__69"></a>Inner Join 关联结果的计算方法</h4> 
<p>为了更好地理解INNER JOIN的计算方法，下面我们将通过具体示例进行详细讲解。</p> 
<h5><a id="_73"></a>示例：一对多关系</h5> 
<p>假设我们有两个表：Customers 和 Orders，其中 Customers 表记录了客户信息，Orders 表记录了客户的订单信息。这是一个典型的一对多关系，每个客户可以有多个订单。</p> 
<ul><li> <p>Customers 表：</p> <pre><code>CustomerID | CustomerName
-----------+-------------
1          | Alice
2          | Bob
3          | Charlie
</code></pre> </li><li> <p>Orders 表：</p> <pre><code>OrderID | CustomerID | OrderAmount
--------+------------+------------
1       | 1          | 100
2       | 1          | 150
3       | 2          | 200
4       | 2          | 250
5       | 3          | 300
</code></pre> </li></ul> 
<p>在这种场景中，执行INNER JOIN查询：</p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> Customers<span class="token punctuation">.</span>CustomerID<span class="token punctuation">,</span> Customers<span class="token punctuation">.</span>CustomerName<span class="token punctuation">,</span> Orders<span class="token punctuation">.</span>OrderID<span class="token punctuation">,</span> Orders<span class="token punctuation">.</span>OrderAmount
<span class="token keyword">FROM</span> Customers
<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> Orders <span class="token keyword">ON</span> Customers<span class="token punctuation">.</span>CustomerID <span class="token operator">=</span> Orders<span class="token punctuation">.</span>CustomerID<span class="token punctuation">;</span>
</code></pre> 
<p>返回的结果为：</p> 
<pre><code>CustomerID | CustomerName | OrderID | OrderAmount
-----------+--------------+---------+------------
1          | Alice        | 1       | 100
1          | Alice        | 2       | 150
2          | Bob          | 3       | 200
2          | Bob          | 4       | 250
3          | Charlie      | 5       | 300
</code></pre> 
<hr> 
<h5><a id="_118"></a>示例：多对多关系</h5> 
<p>假设我们有三个表：Students, Courses 和 Enrollments，其中 Students 表记录学生信息，Courses 表记录课程信息，Enrollments 表记录学生与课程的注册关系。</p> 
<ul><li> <p>Students 表：</p> <pre><code>StudentID | StudentName
----------+------------
1         | Alice
2         | Bob
3         | Charlie
</code></pre> </li><li> <p>Courses 表：</p> <pre><code>CourseID | CourseName
---------+-----------
1        | Math
2        | Science
3        | History
4        | Art
</code></pre> </li><li> <p>Enrollments 表：</p> <pre><code>EnrollmentID | StudentID | CourseID
-------------+-----------+---------
1            | 1         | 1
2            | 1         | 2
3            | 2         | 2
4            | 2         | 3
5            | 3         | 3
6            | 3         | 4
</code></pre> </li></ul> 
<p>在这种场景中，执行多对多关系的INNER JOIN查询：</p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> Students<span class="token punctuation">.</span>StudentID<span class="token punctuation">,</span> Students<span class="token punctuation">.</span>StudentName<span class="token punctuation">,</span> Courses<span class="token punctuation">.</span>CourseID<span class="token punctuation">,</span> Courses<span class="token punctuation">.</span>CourseName
<span class="token keyword">FROM</span> Students
<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> Enrollments <span class="token keyword">ON</span> Students<span class="token punctuation">.</span>StudentID <span class="token operator">=</span> Enrollments<span class="token punctuation">.</span>StudentID
<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> Courses <span class="token keyword">ON</span> Enrollments<span class="token punctuation">.</span>CourseID <span class="token operator">=</span> Courses<span class="token punctuation">.</span>CourseID<span class="token punctuation">;</span>
</code></pre> 
<p>返回的结果为：</p> 
<pre><code>StudentID | StudentName | CourseID | CourseName
----------+-------------+----------+-----------
1         | Alice       | 1        | Math
1         | Alice       | 2        | Science
2         | Bob         | 2        | Science
2         | Bob         | 3        | History
3         | Charlie     | 3        | History
3         | Charlie     | 4        | Art
</code></pre> 
<h4><a id="InnerJoin_175"></a>InnerJoin关联结果的总结</h4> 
<p>通过上述示例，我们可以总结出INNER JOIN在不同关系类型中的行为规律：</p> 
<ul><li><strong>一对多关系</strong>：INNER JOIN返回的行数主要取决于“多”方的行数，即子表的行数和匹配关系。最终的结果集行数等于父表中每一行在子表中的平均匹配数与父表行数的乘积。</li><li><strong>多对多关系</strong>：INNER JOIN返回的行数通常等于中间表的行数。中间表记录了两表之间的所有关系，因此结果集行数等于中间表的记录数。</li></ul> 
<hr> 
<h3><a id="InnerJoinJoin_183"></a>三、InnerJoin与其他Join关联查询结果的异同</h3> 
<p>在关系数据库中，除了INNER JOIN，还有其他类型的JOIN，例如LEFT JOIN、RIGHT JOIN和FULL JOIN。了解它们之间的差异对于选择合适的JOIN类型至关重要。</p> 
<h4><a id="LEFT_JOINLEFT_OUTER_JOIN_187"></a>LEFT JOIN（或LEFT OUTER JOIN）</h4> 
<p>LEFT JOIN返回左表中的所有行，即使右表中没有匹配的行。对于没有匹配的行，右表的列将包含NULL值。</p> 
<p><strong>示例</strong></p> 
<p>假设我们有两个表：Customers 和 Orders。</p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> Customers<span class="token punctuation">.</span>CustomerID<span class="token punctuation">,</span> Customers<span class="token punctuation">.</span>CustomerName<span class="token punctuation">,</span> Orders<span class="token punctuation">.</span>OrderID<span class="token punctuation">,</span> Orders<span class="token punctuation">.</span>OrderAmount
<span class="token keyword">FROM</span> Customers
<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> Orders <span class="token keyword">ON</span> Customers<span class="token punctuation">.</span>CustomerID <span class="token operator">=</span> Orders<span class="token punctuation">.</span>CustomerID<span class="token punctuation">;</span>
</code></pre> 
<p>返回的结果可能包含没有订单的客户：</p> 
<pre><code>CustomerID | CustomerName | OrderID | OrderAmount
-----------+--------------+---------+------------
1          | Alice        | 1       | 100
1          | Alice        | 2       | 150
2          | Bob          | 3       | 200
2          | Bob          | 4       | 250
3          | Charlie      | 5       | 300
4          | David        | NULL    | NULL
</code></pre> 
<hr> 
<h4><a id="RIGHT_JOINRIGHT_OUTER_JOIN_216"></a>RIGHT JOIN（或RIGHT OUTER JOIN）</h4> 
<p>RIGHT JOIN返回右表中的所有行，即使左表中没有匹配的行。对于没有匹配的行，左表的列将包含NULL值。</p> 
<p><strong>示例</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> Customers<span class="token punctuation">.</span>CustomerID<span class="token punctuation">,</span> Customers<span class="token punctuation">.</span>CustomerName<span class="token punctuation">,</span> Orders<span class="token punctuation">.</span>OrderID<span class="token punctuation">,</span> Orders<span class="token punctuation">.</span>OrderAmount
<span class="token keyword">FROM</span> Customers
<span class="token keyword">RIGHT</span> <span class="token keyword">JOIN</span> Orders <span class="token keyword">ON</span> Customers<span class="token punctuation">.</span>CustomerID <span class="token operator">=</span> Orders<span class="token punctuation">.</span>CustomerID<span class="token punctuation">;</span>
</code></pre> 
<p>返回的结果可能包含没有匹配客户的订单：</p> 
<pre><code>CustomerID | CustomerName | OrderID | OrderAmount
-----------+--------------+---------+------------
1          | Alice        | 1       | 100
1          | Alice        | 2       | 150
2          | Bob          | 3       | 200
2          | Bob          | 4       | 250
3          | Charlie      | 5       |

 300
NULL       | NULL         | 6       | 350
</code></pre> 
<hr> 
<h4><a id="FULL_JOINFULL_OUTER_JOIN_246"></a>FULL JOIN（或FULL OUTER JOIN）</h4> 
<p>FULL JOIN返回两个表中的所有行。如果没有匹配的行，则相应表的列将包含NULL值。</p> 
<p><strong>示例</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> Customers<span class="token punctuation">.</span>CustomerID<span class="token punctuation">,</span> Customers<span class="token punctuation">.</span>CustomerName<span class="token punctuation">,</span> Orders<span class="token punctuation">.</span>OrderID<span class="token punctuation">,</span> Orders<span class="token punctuation">.</span>OrderAmount
<span class="token keyword">FROM</span> Customers
<span class="token keyword">FULL</span> <span class="token keyword">JOIN</span> Orders <span class="token keyword">ON</span> Customers<span class="token punctuation">.</span>CustomerID <span class="token operator">=</span> Orders<span class="token punctuation">.</span>CustomerID<span class="token punctuation">;</span>
</code></pre> 
<p>返回的结果可能包含所有客户和订单，包括没有匹配的行：</p> 
<pre><code>CustomerID | CustomerName | OrderID | OrderAmount
-----------+--------------+---------+------------
1          | Alice        | 1       | 100
1          | Alice        | 2       | 150
2          | Bob          | 3       | 200
2          | Bob          | 4       | 250
3          | Charlie      | 5       | 300
4          | David        | NULL    | NULL
NULL       | NULL         | 6       | 350
</code></pre> 
<hr> 
<h4><a id="CROSS_JOIN_274"></a>CROSS JOIN</h4> 
<p>CROSS JOIN返回两个表的笛卡尔积，即每个表中的每一行都与另一个表中的每一行进行组合。</p> 
<p><strong>示例</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> Customers<span class="token punctuation">.</span>CustomerID<span class="token punctuation">,</span> Customers<span class="token punctuation">.</span>CustomerName<span class="token punctuation">,</span> Orders<span class="token punctuation">.</span>OrderID<span class="token punctuation">,</span> Orders<span class="token punctuation">.</span>OrderAmount
<span class="token keyword">FROM</span> Customers
<span class="token keyword">CROSS</span> <span class="token keyword">JOIN</span> Orders<span class="token punctuation">;</span>
</code></pre> 
<p>返回的结果为：</p> 
<pre><code>CustomerID | CustomerName | OrderID | OrderAmount
-----------+--------------+---------+------------
1          | Alice        | 1       | 100
1          | Alice        | 2       | 150
1          | Alice        | 3       | 200
1          | Alice        | 4       | 250
1          | Alice        | 5       | 300
2          | Bob          | 1       | 100
2          | Bob          | 2       | 150
2          | Bob          | 3       | 200
2          | Bob          | 4       | 250
2          | Bob          | 5       | 300
3          | Charlie      | 1       | 100
3          | Charlie      | 2       | 150
3          | Charlie      | 3       | 200
3          | Charlie      | 4       | 250
3          | Charlie      | 5       | 300
</code></pre> 
<hr> 
<h3><a id="InnerJoin__310"></a>四、InnerJoin 总结</h3> 
<p>INNER JOIN是SQL查询中最常用的JOIN类型之一，它仅返回两个表中匹配的行。在理解INNER JOIN时，需要重点关注以下几点：</p> 
<ol><li><strong>定义和概念</strong>：INNER JOIN用于返回两个表中基于指定条件匹配的行。</li><li><strong>计算方法</strong>：在一对多和多对多关系中，INNER JOIN的结果集行数取决于匹配条件和表之间的关系类型。</li><li><strong>与其他JOIN的比较</strong>：INNER JOIN与LEFT JOIN、RIGHT JOIN、FULL JOIN和CROSS JOIN在行为和返回结果上存在显著差异，选择合适的JOIN类型对于正确查询至关重要。</li></ol> 
<p>通过理解这些概念和技术细节，您可以更高效地使用INNER JOIN进行数据查询和分析，解决复杂的数据处理需求。在实际应用中，建议通过动手练习和阅读相关文档来进一步巩固所学知识，并在项目中灵活应用。</p> 
<p><img src="https://images2.imgbox.com/b9/bb/SfbSwEty_o.gif" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/33c5d76015b70d94b1d69f54534bcc40/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">lua 游戏架构 之 游戏 AI （八）ai_tbl 行为和优先级</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b0b675228b46707d34ee1ccf32f0f1b3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Lua 类管理器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>