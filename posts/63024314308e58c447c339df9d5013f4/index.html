<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>移情别恋c&#43;&#43; ദ്ദി˶ｰ̀֊ｰ́ ) ——2.类和对象（中（2）） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/63024314308e58c447c339df9d5013f4/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="移情别恋c&#43;&#43; ദ്ദി˶ｰ̀֊ｰ́ ) ——2.类和对象（中（2））">
  <meta property="og:description" content="5. 赋值运算符重载 5.1 运算符重载 • 重载运算符函数的参数个数和该运算符作⽤的运算对象数量⼀样多。⼀元运算符有⼀个参数，⼆元 运算符有两个参数，⼆元运算符的左侧运算对象传给第⼀个参数，右侧运算对象传给第⼆个参数。
• 如果⼀个重载运算符函数是成员函数，则它的第⼀个运算对象默认传给隐式的this指针，因此运算 符重载作为成员函数时，参数⽐运算对象少⼀个。
• 运算符重载以后，其优先级和结合性与对应的内置类型运算符保持⼀致。
• 不能通过连接语法中没有的符号来创建新的操作符：⽐如operator@。
.* :: sizeof ?: . 注意以上5个运算符不能重载。(选择题⾥⾯常考，⼤家要记⼀ 下)
• 重载操作符⾄少有⼀个类类型参数，不能通过运算符重载改变内置类型对象的含义，如： int operator&#43;(int x, int y)
• ⼀个类需要重载哪些运算符，是看哪些运算符重载后有意义，⽐如Date类重载operator-就有意 义，但是重载operator&#43;就没有意义。
• 重载&#43;&#43;运算符时，有前置&#43;&#43;和后置&#43;&#43;，运算符重载函数名都是operator&#43;&#43;，⽆法很好的区分。 C&#43;&#43;规定，
后置&#43;&#43;重载时，增加⼀个int形参，跟前置&#43;&#43;构成函数重载，⽅便区分。
#include&lt;iostream&gt; using namespace std; class Date { public: Date(int year = 1, int month = 1, int day = 1) { _year = year; _month = month; _day = day; } void Print() { cout &lt;&lt; _year &lt;&lt; &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-05T10:18:29+08:00">
    <meta property="article:modified_time" content="2024-08-05T10:18:29+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">移情别恋c&#43;&#43; ദ്ദി˶ｰ̀֊ｰ́ ) ——2.类和对象（中（2））</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><strong>5. 赋值运算符重载</strong></h2> 
<h3>5.1 运算符重载</h3> 
<blockquote> 
 <p>• 重载运算符函数的参数个数和该运算符作⽤的运算对象数量⼀样多。⼀元运算符有⼀个参数，⼆元 运算符有两个参数，⼆元运算符的左侧运算对象传给第⼀个参数，右侧运算对象传给第⼆个参数。</p> 
 <p></p> 
 <p>• 如果⼀个重载运算符函数是成员函数，则它的第⼀个运算对象默认传给隐式的this指针，因此运算 符重载作为成员函数时，参数⽐运算对象少⼀个。</p> 
 <p></p> 
 <p>• 运算符重载以后，其优先级和结合性与对应的内置类型运算符保持⼀致。</p> 
 <p></p> 
 <p>• 不能通过连接语法中没有的符号来创建新的操作符：⽐如operator@。</p> 
 <p><strong><span style="color:#fe2c24;">.*  ::  sizeof  ?:  . </span></strong>注意以上5个运算符不能重载。(选择题⾥⾯常考，⼤家要记⼀ 下)</p> 
 <p></p> 
 <p>• 重载操作符⾄少有⼀个类类型参数，不能通过运算符重载改变内置类型对象的含义，如： int operator+(int x, int y)</p> 
 <p></p> 
 <p>• ⼀个类需要重载哪些运算符，是看哪些运算符重载后有意义，⽐如Date类重载operator-就有意 义，但是重载operator+就没有意义。</p> 
 <p></p> 
 <p>• 重载++运算符时，有前置++和后置++，运算符重载函数名都是operator++，⽆法很好的区分。 C++规定，</p> 
 <p>后置++重载时，增加⼀个int形参，跟前置++构成函数重载，⽅便区分。</p> 
</blockquote> 
<pre><code class="hljs">#include&lt;iostream&gt;
using namespace std;

class Date
{
   public:
   Date(int year = 1, int month = 1, int day = 1)
   {
     _year = year;
     _month = month;
     _day = day;
    }

  void Print()
  {
     cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl;
   }

   bool operator==(const Date&amp; d)
  {
     return _year == d._year
           &amp;&amp; _month == d._month
           &amp;&amp; _day == d._day;
   }

   Date&amp; operator++()
   {
     cout &lt;&lt; "前置++" &lt;&lt; endl;
     *this += 1;
    return *this;
   }

   Date operator++(int)
   {
    date tmp(*this);
	* this += 1;
    return tmp;
   }

private:
int _year;
int _month;
int _day;
};

int main()
{
  Date d1(2024, 7, 5);
  Date d2(2024, 7, 6);
  // 运算符重载函数可以显⽰调⽤
  d1.operator==(d2);
// 编译器会转换成 d1.operator==(d2);
d1 == d2;
// 编译器会转换成 d1.operator++();
++d1;
// 编译器会转换成 d1.operator++(0);
d1++;
return 0;
}
</code></pre> 
<h3> 5.2 赋值运算符重载</h3> 
<p>赋值运算符重载是⼀个默认成员函数，⽤于完成<span style="color:#fe2c24;"><strong>两个已经存在的对象</strong></span>直接的拷⻉赋值，这⾥要注意跟 拷⻉构造区分，拷⻉构造⽤于⼀个对象拷⻉初始化给另⼀个要创建的对象。</p> 
<p>赋值运算符重载的特点：</p> 
<blockquote> 
 <p>1. 赋值运算符重载是⼀个运算符重载，规定必须重载为成员函数。赋值运算重载的参数建议写成 const 当前类类型引⽤，否则会传值传参会有拷⻉</p> 
 <p></p> 
 <p>2. 有返回值，且建议写成当前类类型引⽤，引⽤返回可以提⾼效率，有返回值⽬的是为了⽀持连续赋 值场景。</p> 
 <p></p> 
 <p>3. 没有显式实现时，编译器会⾃动⽣成⼀个默认赋值运算符重载，默认赋值运算符重载⾏为跟默认拷 ⻉构造函数类似，<strong><span style="color:#fe2c24;">对内置类型成员变量会完成值拷⻉/浅拷⻉(⼀个字节⼀个字节的拷⻉)，对⾃定义 类型成员变量会调⽤他的赋值重载函数。</span></strong> （和其他成员函数一样）</p> 
</blockquote> 
<pre><code class="hljs">class Date
{
 public:

 Date(int year = 1, int month = 1, int day = 1)
 {
  _year = year;
  _month = month;
  _day = day;
 }

 Date(const Date&amp; d)
 {
   cout &lt;&lt; " Date(const Date&amp; d)" &lt;&lt; endl;
   _year = d._year;
   _month = d._month;
   _day = d._day;
 }

// 传引⽤返回减少拷⻉
// d1 = d2;

 Date&amp; operator=(const Date&amp; d)
 {
// 不要检查⾃⼰给⾃⼰赋值的情况
  if (this != &amp;d)
  {
   _year = d._year;
   _month = d._month;
   _day = d._day;
  }
  // d1 = d2表达式的返回对象应该为d1，也就是*this
   return *this;
 }

void Print()
{
cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl;
}

 private:
 int _year;
 int _month;
 int _day;
};

int main()
{
Date d1(2024, 7, 5);
Date d2(d1);
Date d3(2024, 7, 6);
d1 = d3;
// 需要注意这⾥是拷⻉构造，不是赋值重载
// 请牢牢记住赋值重载完成两个已经存在的对象直接的拷⻉赋值
// ⽽拷⻉构造⽤于⼀个对象拷⻉初始化给另⼀个要创建的对象
Date d4 = d1;
return 0;
}</code></pre> 
<h3>5.3 日期类的实现 </h3> 
<h4>date.h:</h4> 
<pre><code class="hljs">#include&lt;iostream&gt;

using namespace std;

class date
{
  public:
	  date(int year = 1, int month = 1, int day = 1);//全缺省的初始化,定义处需要给出数据
	  void print();
	  int getmonthday(int year, int month);
	  date&amp; operator=(const date&amp; d);                 //赋值运算符重载
	  bool operator&lt;(const date&amp; d);
	  bool operator==(const date&amp; d);
	  //
	  bool operator&gt;(const date&amp; d);
	  bool operator!=(const date&amp; d);
	  bool operator&lt;=(const date&amp; d);
	  bool operator&gt;=(const date&amp; d);
	  
	  date&amp; operator+=(int day);
	  date operator+(int day);
	  date&amp; operator-=(int day);
	  date operator-(int day);
	  /
	  date&amp; operator++();        //前置++
	  date operator++(int);      //后置++
	  date&amp; operator--();        //前置--
	  date operator--(int);      //后置--

	  int operator-(const date&amp; d);
	  int deal(int year, int month, int day);

 private:
	int _year;
	int _month;
	int _day;
};</code></pre> 
<p></p> 
<h4>date.cpp :</h4> 
<pre><code class="hljs">#include"date.h"

date::date(int year, int month, int day) //声明处可以不给
{
	_year = year;
	_month = month;
	_day = day;

	if (month &lt; 1 || month&gt;12 || year &lt; 1 || day&lt;1 || day&gt;getmonthday(year, month))
		cout &lt;&lt; "非法日期" &lt;&lt; endl;

}                                   //1.构造函数

void date::print()
{
	cout &lt;&lt; _year &lt;&lt; "年" &lt;&lt; _month &lt;&lt; "月" &lt;&lt; _day &lt;&lt; "日" &lt;&lt; endl;
}

int date::getmonthday(int year, int month)
{
	int arrday[13] = { 0,31,28,31,30,31,30,31,31,30,31,30,31 };
	if (month==2&amp;&amp;(year % 400 == 0 || (year % 4 == 0 &amp;&amp; year % 100 != 0)))
		return 29;
	else
		return arrday[month];
}

date&amp; date::operator=(const date&amp; d)       
{
	 this-&gt;_year = d._year;
	 this-&gt;_month = d._month;
	 this-&gt;_day = d._day;

	 return *this;              

}//赋值运算符重载             //如果return的元素出了作用域还在，那么可以用引用返回&amp;，否则不可用


bool date:: operator&lt;(const date&amp; d)
{
	if (_year &lt; d._year)
		return true;
	else if (_year == d._year &amp;&amp; _month &lt; d._month)
		return true;
	else if (_year == d._year &amp;&amp; _month == d._month &amp;&amp; _day &lt; d._day)
		return true;
	else
		return false;
}

bool date:: operator==(const date&amp; d)
{
	if (_year == d._year &amp;&amp; _month == d._month &amp;&amp; _day == d._day)
		return true;
	else
		return false;

}

bool date:: operator&gt;(const date&amp; d)
{
	return !(*this &lt; d || *this == d);
}

bool date:: operator!=(const date&amp; d)
{
	return !(*this == d);
}

bool date:: operator&lt;=(const date&amp; d)
{
	return !(*this &gt; d);
}

bool date:: operator&gt;=(const date&amp; d)
{
	return !(*this &lt; d);     //this为 Date* const 类型
}


date&amp; date:: operator+=(int day)
{
	_day = _day + day;
	while (_day &gt; getmonthday(_year, _month))
	{
		_day = _day - getmonthday(_year, _month);
		_month++;

		if (_month == 13)
		{
			_year++;
			_month = 1;
		}
	}

	return *this;    
}

date date:: operator+(int day)
{
	date tmp(*this);                           //d1的值不能改变，用拷贝构造

	tmp += day;

	return tmp;
}




date&amp; date:: operator-=(int day)
{
	_day = _day - day+1;
	while (_day &lt;=0 )
	{
		_day = _day + getmonthday(_year, _month);
		_month--;

		if (_month == 0)
		{
			_year--;
			_month = 12;
		}
	}

	return *this;

}

date date:: operator-(int day)
{
	date tmp(*this);                           //d1的值不能改变，用拷贝构造

	tmp -= day;

	return tmp;                             //出作用域销毁，不能用&amp;
}



date&amp; date:: operator++()
{

	*this += 1;
	return *this;
}


date date::operator++(int)
{
	date tmp(*this);
		* this += 1;
		return tmp;
}


date&amp; date:: operator--()
{

	*this -= 1;
	return *this;
}


date date::operator--(int)
{
	date tmp(*this);
	*this -= 1;
	return tmp;
}



int date::deal(int year, int month, int day)
{

	int sum = day - 1;
	month--;
	for (; month &gt;= 1; month--)
	{
		sum = sum + getmonthday(year, month);
	}

	return sum;
}



int date:: operator-(const date&amp; d)
{
	int year = 0;
	int sum = 0;
	for (year = _year-1; year &gt;= d._year; year--)
	{
		if (year % 400 == 0 || (year % 4 == 0 &amp;&amp; year % 100 != 0))
			sum = sum + 366;
		else
			sum = sum + 365;
	}

	sum = sum + deal(_year, _month, _day) - deal(d._year, d._month, d._day);
	return sum;
}</code></pre> 
<h4> test.cpp:</h4> 
<p> </p> 
<pre><code class="hljs">#include"date.h"

int main()
{
	date d1(2023, 6, 22);

	date d2(d1);    //拷贝构造，对于只有内置类型（即不需要开动态空间的）系统自动生成(浅拷贝即值拷贝），像栈之类的需要自己去写拷贝构造(深拷贝，防止二次析构）
	
	date d3(2003, 10, 1);

	cout &lt;&lt; d1 - d3 &lt;&lt; "天" &lt;&lt; endl;

}</code></pre> 
<h2>6. 取地址运算符重载 </h2> 
<h3>6.1 const成员函数</h3> 
<blockquote> 
 <p>• 将const修饰的成员函数称之为const成员函数，<strong><span style="color:#fe2c24;">const修饰成员函数放到成员函数参数列表的后</span></strong> <span style="color:#fe2c24;"><strong>⾯</strong></span>。</p> 
 <p>• const实际修饰该成员函数隐含的this指针，表明在该成员函数中不能对类的任何成员进⾏修改。 const 修饰Date类的Print成员函数，Print隐含的this指针由 <span style="color:#38d8f0;"><strong>Date* const this</strong></span> 变为<span style="color:#956fe7;"><strong> const</strong></span> <strong><span style="color:#956fe7;">Date* const this</span></strong></p> 
</blockquote> 
<pre><code class="hljs">#include&lt;iostream&gt;
using namespace std;
class Date
{
public:
Date(int year = 1, int month = 1, int day = 1)
{
_year = year;
_month = month;
_day = day;
}
// void Print(const Date* const this) const
void Print() const
{
cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl;
}
private:
int _year;
int _month;
int _day;
};
int main()
{
// 这⾥⾮const对象也可以调⽤const成员函数是⼀种权限的缩⼩
Date d1(2024, 7, 5);
d1.Print();
const Date d2(2024, 8, 5);
d2.Print();
return 0;
}</code></pre> 
<p> </p> 
<p> </p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4ae945e32fe37424419f5b90bb3b06ce/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【数据结构】LinkedList与链表</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1fc22976e0ef47c3b9a38bc1d45b8193/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Visual Studio Code】源代码管理 传入/传出 更改配置开关</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>