<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>贪心算法(c&#43;&#43;) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/c121630de33feee121e3d79b9a6357f1/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="贪心算法(c&#43;&#43;)">
  <meta property="og:description" content="一、贪心算法介绍 基本原理：每一步都选择局部最优解，而尽量不考虑对后续的影响，最终达到全局最优解。
局限性：贪心算法不能保证获得全局最优解，但在某些问题上具有高效性。
特征：贪心选择性质、最优子结构性质(根据我的观察，很多贪心的题目会出现“不同的操作产生的贡献相同”的特征，在此特征下我们每次选择代价最小的。)
贪心类型多且杂，需要积累联系。
二、贪心算法实现步骤 1、确定问题的最优子结构（贪心往往跟排序、优先队列等一起出现）。
2、构建贪心选择的策略，可能通过“分类讨论”、“最小代价”、“最大价值”等方式来思考贪心策略。简单验证贪心的正确性，采用句式一般是：这样做一定不会使得结果变差、不存在比当前方案更好的方案等等。
3、通过贪心选择逐步求解问题，直到得到最终解。
三、例题 1、蓝桥OJ3412 最小化战斗力差距 https://www.lanqiao.cn/problems/3412/learning/?page=1&amp;first_category_id=1&amp;problem_id=3412
思路：
简单排序模型。
要将战斗力分为两部分，假设有一个a数组，一个b数组。将战斗力排序后进行划分，左边的在a数组中，右边的在b数组中，a数组的最后一个和b数组第一个元素的差距即战斗力差距，其他元素都可以忽略，故枚举即可。找间隙最小。
#include&lt;bits/stdc&#43;&#43;.h&gt; using namespace std; const int N = 1e5 &#43; 9; int a[N]; int main() { int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i&#43;&#43;) cin &gt;&gt; a[i]; sort(a&#43;1,a&#43;1&#43;n); int ans = a[2] - a[1]; for (int i = 1; i &lt; n; i&#43;&#43;) ans = min(ans,a[i&#43;1]-a[i]);//有i&#43;1故&lt;n cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;; } 体会：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-11-28T23:29:14+08:00">
    <meta property="article:modified_time" content="2023-11-28T23:29:14+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">贪心算法(c&#43;&#43;)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一、贪心算法介绍</h3> 
<p><strong><span style="color:#ff9900;">基本原理</span></strong><span style="color:#0d0016;">：每一步都选择局部最优解，而尽量不考虑对后续的影响，最终达到全局最优解。</span></p> 
<p><strong><span style="color:#ff9900;">局限性</span></strong><span style="color:#0d0016;">：贪心算法不能保证获得全局最优解，但在某些问题上具有高效性。</span></p> 
<p><span style="color:#ff9900;"><strong>特征</strong></span><span style="color:#0d0016;">：贪心选择性质、最优子结构性质(根据我的观察，很多贪心的题目会出现“</span><span style="color:#ff9900;">不同的操作产生的贡献相同</span><span style="color:#0d0016;">”的特征，在此特征下我们</span><span style="color:#ff9900;">每次选择代价最小的</span><span style="color:#0d0016;">。)</span></p> 
<p><span style="color:#0d0016;">贪心类型多且杂，需要积累联系。</span></p> 
<h3><span style="color:#0d0016;">二、贪心算法实现步骤</span></h3> 
<p>1、确定问题的最优子结构（贪心往往跟排序、优先队列等一起出现）。</p> 
<p>2、构建贪心选择的策略，可能通过“分类讨论”、“最小代价”、“最大价值”等方式来思考贪心策略。简单验证贪心的正确性，采用句式一般是：这样做一定不会使得结果变差、不存在比当前方案更好的方案等等。</p> 
<p>3、通过贪心选择逐步求解问题，直到得到最终解。</p> 
<h3>三、例题</h3> 
<h4>1、蓝桥OJ3412 最小化战斗力差距</h4> 
<p><a class="link-info" href="https://www.lanqiao.cn/problems/3412/learning/?page=1&amp;first_category_id=1&amp;problem_id=3412" rel="nofollow" title="https://www.lanqiao.cn/problems/3412/learning/?page=1&amp;first_category_id=1&amp;problem_id=3412">https://www.lanqiao.cn/problems/3412/learning/?page=1&amp;first_category_id=1&amp;problem_id=3412</a></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/82/36/Z1jtHr1R_o.png"></p> 
<blockquote> 
 <p>思路：</p> 
 <p>简单排序模型。</p> 
 <p>要将战斗力分为两部分，假设有一个a数组，一个b数组。将战斗力排序后进行划分，左边的在a数组中，右边的在b数组中，a数组的最后一个和b数组第一个元素的差距即战斗力差距，其他元素都可以忽略，故枚举即可。<span style="color:#4da8ee;">找间隙最小。</span></p> 
</blockquote> 
<pre><code class="hljs">#include&lt;bits/stdc++.h&gt;
using namespace std;

const int N = 1e5 + 9;

int a[N];

int main()
{
	int n; cin &gt;&gt; n;
	for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];
	sort(a+1,a+1+n);
	int ans = a[2] - a[1];
	for (int i = 1; i &lt; n; i++) ans = min(ans,a[i+1]-a[i]);//有i+1故&lt;n 
	cout &lt;&lt; ans &lt;&lt; '\n';
} </code></pre> 
<p>体会：</p> 
<p>当遇到元素混乱的问题时，可以试着把元素排序，当然是在不影响题目的情况下。 </p> 
<hr> 
<h4>2、蓝桥OJ545 谈判</h4> 
<p><a class="link-info" href="https://www.lanqiao.cn/problems/545/learning/?page=1&amp;first_category_id=1&amp;problem_id=545" rel="nofollow" title="https://www.lanqiao.cn/problems/545/learning/?page=1&amp;first_category_id=1&amp;problem_id=545">https://www.lanqiao.cn/problems/545/learning/?page=1&amp;first_category_id=1&amp;problem_id=545</a></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2b/d4/nTEwk3dZ_o.png"></p> 
<blockquote> 
 <p>思路：</p> 
 <p>这是一个总操作数一定情况下的“最小代价”问题。</p> 
 <p>我们要实现花费最少的金币，贪心地想，假如我们每次把人数最少的两个部落加起来，是不是就可以实现花费的金币最少呢，即<span style="color:#4da8ee;">每次选择代价最小的两个部落合并</span>。</p> 
 <p>我们可以采用优先队列，按greater排序，就可以使top变成最小的值(小根堆)，取上面两个最小的值相加并pop出队列，再push两个最小的值相加的值进入队列，最后累加出结果即为最小花费。</p> 
</blockquote> 
<pre><code class="hljs">#include&lt;bits/stdc++.h&gt;
using namespace std;

using ll = long long;
priority_queue&lt;ll,vector&lt;ll&gt;,greater&lt;ll&gt;&gt; pq;

int main()
{
	int n;cin &gt;&gt; n;
	ll m;
	for (int i = 1; i &lt;= n; i++)
	{
		cin &gt;&gt; m;
		pq.push(m);
	}
	ll ans = 0;
	while(pq.size() &gt; 1)
	{
		ll x = pq.top(); pq.pop();
		ll y = pq.top(); pq.pop();
		
		ans += x + y;
		
		pq.push(x+y);
	}
	cout &lt;&lt; ans &lt;&lt;'\n';
	return 0;
} </code></pre> 
<h4></h4> 
<hr> 
<h4>3、蓝桥OJ532 纪念品分组</h4> 
<p><a class="link-info" href="https://www.lanqiao.cn/problems/532/learning/?page=1&amp;first_category_id=1&amp;problem_id=532" rel="nofollow" title="https://www.lanqiao.cn/problems/532/learning/?page=1&amp;first_category_id=1&amp;problem_id=532">https://www.lanqiao.cn/problems/532/learning/?page=1&amp;first_category_id=1&amp;problem_id=532</a></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/38/bf/7gP1N5LT_o.png"></p> 
<blockquote> 
 <p>思路：</p> 
 <p>这是一个最少数目的贪心模型。</p> 
 <p>题目要求每组纪念品价格之和不能超过给定的整数，且每组最多只能两件纪念品。并分组数目最少。我的贪心策略就是，<span style="color:#4da8ee;">最贵带最便宜的</span>成为一组。若装不下就单独成为一组。</p> 
 <p>采用二分的思想，将l=1，r=n，左(小)右(大)同时遍历数组，若找到一组就l++,r--,且组数+1，若没找到则说明溢出了，r--，单独成为一组组数也要+1，最后判断l=r，代表遍历完成break结束。</p> 
</blockquote> 
<pre><code class="hljs">#include&lt;bits/stdc++.h&gt;
using namespace std;

const int N = 1e5 + 9;
int a[N];

int main()
{
	int w, n; cin &gt;&gt; w &gt;&gt; n;
	for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];
	sort(a+1,a+1+n);
	int l = 1, r = n, ans = 0;
	while(l &lt;= r)
	{
		ans++;
		if (l == r) break;
		if (a[l] + a[r] &lt;= w)
		{
			r--;
			l++;
		} 
		else r--;
	}
	cout &lt;&lt; ans &lt;&lt; '\n';
	return 0;
} </code></pre> 
<p> </p> 
<hr> 
<h4>4、蓝桥OJ2928 分糖果</h4> 
<p><a class="link-info" href="https://www.lanqiao.cn/problems/2928/learning/?page=1&amp;first_category_id=1&amp;problem_id=2928" rel="nofollow" title="https://www.lanqiao.cn/problems/2928/learning/?page=1&amp;first_category_id=1&amp;problem_id=2928">https://www.lanqiao.cn/problems/2928/learning/?page=1&amp;first_category_id=1&amp;problem_id=2928</a></p> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/93/0a/GlCHPxcs_o.png"></p> 
<blockquote> 
 <p>这是一个找规律的贪心模型。</p> 
 <p>题目要求我们使所有糖果组成的字符串中字典序最大的字符串尽可能小。需要我们分三种情况：</p> 
 <p>（1）当字符串全部相等时(假设为aaaaaaa)，要把这7个a分给3个同学，那么分为(aa)(aa)(aaa)即是最优，所以此情况，我们只需要使每个人分到的字符串的最大长度尽可能小。</p> 
 <p>（2）当s[x] == s[1]，说明第x个是最小的字符串，带着后面所有的字符一起输出。</p> 
 <p>（3）当s[x] != s[1]，后面的字符可以直接丢到s[1]后面，分给第一个同学。那么x个同学肯定就是字典序最大的了。(假设w=5,x=2,s="abbcd")，我们将后面的bcd丢给第一个同学，abcd的字典序&lt;b的字典序。</p> 
</blockquote> 
<pre><code class="hljs">#include&lt;bits/stdc++.h&gt;
using namespace std;

const int N = 1e6 + 9;
char s[N];

int main()
{
	int n, x; cin &gt;&gt; n &gt;&gt; x;
	cin &gt;&gt; s + 1;
	sort(s+1,s+1+n);
	
	if (s[1] == s[n])//字符串全相等
	{
		for (int i = 1; i &lt;= n / x + (n % x ? 1 : 0); ++i) cout &lt;&lt; s[i];
	} 
	else if (s[1] == s[x])
	{
		for (int i = x; i &lt;= n; ++i) cout &lt;&lt; s[i];
	}
	else	cout &lt;&lt; s[x];
	return 0;
}</code></pre> 
<p>贪心题目的类型多而杂，需要自己不断积累。欢迎大家指正。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2ac2dbda0474a735f2fec9abbe8670ad/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">前端常用算法（一）：防抖&#43;节流</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/adaceab83c34647bb2dd06b0ca9760e6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Python】torch.exp（）和 torch.sigmoid（）函数详解和示例</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>