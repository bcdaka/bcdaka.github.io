<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言（字符、字符串函数）1 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/30a23df2dfd548801f543a8cfa327eca/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C语言（字符、字符串函数）1">
  <meta property="og:description" content="Hi~！这里是奋斗的小羊，很荣幸各位能阅读我的文章，诚请评论指点，关注&#43;收藏，欢迎欢迎~~ 💥个人主页：小羊在奋斗
💥所属专栏：C语言 本系列文章为个人学习笔记，在这里撰写成文一为巩固知识，二为同样是初学者的学友展示一些我的学习过程及心得。文笔、排版拙劣，望见谅。 1、字符分类函数
2、字符转换函数
3、strlen 的使用和模拟实现
4、strcpy 的使用和模拟实现
5、strcat 的使用和模拟实现
1、字符分类函数 C语言中有一些专门作字符分类的函数，使用这些函数需要包含头文件 ctype.h 。
isalnum
检查一个字符是否是字母或数字
(函数) isalpha
检查一个字符是否是字母
(函数) islower
检查一个字符是否是小写字母
(函数) isupper
检查一个字符是否是大写字母
(函数) isdigit
检查字符是否为数字
(函数) isxdigit
检查一个字符是否是十六进制的字符
(函数) iscntrl
检查一个字符是否是控制字符
(函数) isgraph
检查一个字符是否是图形字符
(函数) isspace
检查一个字符是否是空白字符
(函数) isblank
(C99)
检查一个字符是否是空格字符
(函数) isprint
检查一个字符是否是可打印字符
(函数) ispunct
检查一个字符是否是标点字符 更多详细内容请点击跳转阅读 —&gt; C 标准库头文件 - cppreference.com 这些函数的使用方法、返回值等基本是一致的，这里就以 islower 函数为例，写一个将字符串中非大写的字母转化为大写字母的示例。
2、字符转换函数 C语言中有两个实现大小写转换的函数，tolower（将大写字母转小写） 和 toupper（将小写字母转大写）。
那既然有了这两个函数，上面将字符串中的小写字母转换为大写字母的代码就可以优化一下了。
3、strlen 的使用和模拟实现 3.1 strlen 的返回值 strlen 函数我们已经非常的熟悉，之前也介绍了两种模拟 strlen 函数的方法，这里再关于 strlen 的使用做一些补充，同时再介绍另一种 strlen 的模拟实现方法。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-03T17:04:09+08:00">
    <meta property="article:modified_time" content="2024-06-03T17:04:09+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言（字符、字符串函数）1</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>                      <span style="color:#4da8ee;"> Hi~！这里是奋斗的小羊，很荣幸各位能阅读我的文章，诚请评论指点，关注+收藏，欢迎欢迎~~     </span></p> 
 <p>                        💥<span style="color:#be191c;">个人主页</span>：<a href="https://blog.csdn.net/2301_78843337?type=blog" title="小羊在奋斗">小羊在奋斗</a></p> 
 <p>                        💥<span style="color:#be191c;">所属专栏</span>：<a href="https://blog.csdn.net/2301_78843337/category_12630603.html" title="C语言">C语言</a>   </p> 
</blockquote> 
<blockquote> 
 <p>       <span style="color:#be191c;"> 本系列文章为个人学习笔记，在这里撰写成文一为巩固知识，二为同样是初学者的学友展示一些我的学习过程及心得。文笔、排版拙劣，望见谅。 </span></p> 
</blockquote> 
<p><span style="color:#4da8ee;">                                1、字符分类函数</span></p> 
<p><span style="color:#4da8ee;">                                2、字符转换函数</span></p> 
<p><span style="color:#4da8ee;">                                3、strlen 的使用和模拟实现</span></p> 
<p><span style="color:#4da8ee;">                                4、strcpy 的使用和模拟实现</span></p> 
<p><span style="color:#4da8ee;">                                5、strcat 的使用和模拟实现</span></p> 
<h3>1、字符分类函数</h3> 
<p>        C语言中有一些专门作字符分类的函数，使用这些函数需要包含头文件<strong> ctype.h</strong> 。</p> 
<table><tbody><tr><td> <p><a href="https://zh.cppreference.com/w/c/string/byte/isalnum" rel="nofollow" title="isalnum">isalnum</a></p> </td><td>检查一个字符是否是字母或数字<br> (函数)</td></tr><tr><td> <p><a href="https://zh.cppreference.com/w/c/string/byte/isalpha" rel="nofollow" title="isalpha">isalpha</a></p> </td><td>检查一个字符是否是字母<br> (函数)</td></tr><tr><td> <p><a href="https://zh.cppreference.com/w/c/string/byte/islower" rel="nofollow" title="islower">islower</a></p> </td><td>检查一个字符是否是小写字母<br> (函数)</td></tr><tr><td> <p><a href="https://zh.cppreference.com/w/c/string/byte/isupper" rel="nofollow" title="isupper">isupper</a></p> </td><td>检查一个字符是否是大写字母<br> (函数)</td></tr><tr><td> <p><a href="https://zh.cppreference.com/w/c/string/byte/isdigit" rel="nofollow" title="isdigit">isdigit</a></p> </td><td>检查字符是否为数字<br> (函数)</td></tr><tr><td> <p><a href="https://zh.cppreference.com/w/c/string/byte/isxdigit" rel="nofollow" title="isxdigit">isxdigit</a></p> </td><td>检查一个字符是否是十六进制的字符<br> (函数)</td></tr><tr><td> <p><a href="https://zh.cppreference.com/w/c/string/byte/iscntrl" rel="nofollow" title="iscntrl">iscntrl</a></p> </td><td>检查一个字符是否是控制字符<br> (函数)</td></tr><tr><td> <p><a href="https://zh.cppreference.com/w/c/string/byte/isgraph" rel="nofollow" title="isgraph">isgraph</a></p> </td><td>检查一个字符是否是图形字符<br> (函数)</td></tr><tr><td> <p><a href="https://zh.cppreference.com/w/c/string/byte/isspace" rel="nofollow" title="isspace">isspace</a></p> </td><td>检查一个字符是否是空白字符<br> (函数)</td></tr><tr><td> <p><a href="https://zh.cppreference.com/w/c/string/byte/isblank" rel="nofollow" title="isblank">isblank</a></p> <p>(C99)</p> </td><td>检查一个字符是否是空格字符<br> (函数)</td></tr><tr><td> <p><a href="https://zh.cppreference.com/w/c/string/byte/isprint" rel="nofollow" title="isprint">isprint</a></p> </td><td>检查一个字符是否是可打印字符<br> (函数)</td></tr><tr><td> <p><a href="https://zh.cppreference.com/w/c/string/byte/ispunct" rel="nofollow" title="ispunct">ispunct</a></p> </td><td>检查一个字符是否是标点字符</td></tr></tbody></table> 
<p style="text-align:center;">        更多详细内容<strong>请点击跳转阅读</strong> —&gt;<strong> <a href="https://zh.cppreference.com/w/c/header" rel="nofollow" title="C 标准库头文件 - cppreference.com">C 标准库头文件 - cppreference.com</a> </strong></p> 
<p style="text-align:center;"><br><img alt="" height="252" src="https://images2.imgbox.com/fc/38/KHNGx6jB_o.png" width="608"></p> 
<p>        这些函数的使用方法、返回值等基本是一致的，这里就以 islower 函数为例，写一个将字符串中非大写的字母转化为大写字母的示例。</p> 
<p style="text-align:center;"> <img alt="" height="333" src="https://images2.imgbox.com/89/08/vTQ6TpHo_o.png" width="532"></p> 
<h3> 2、字符转换函数</h3> 
<p>        C语言中有两个实现大小写转换的函数，<strong>tolower</strong>（<strong>将大写字母转小写</strong>） 和 <strong>toupper</strong>（<strong>将小写字母转大写</strong>）。</p> 
<p style="text-align:center;"><img alt="" height="292" src="https://images2.imgbox.com/06/30/EY2QqNwb_o.png" width="602"></p> 
<p>        那既然有了这两个函数，上面将字符串中的小写字母转换为大写字母的代码就可以优化一下了。</p> 
<p style="text-align:center;"> <img alt="" height="334" src="https://images2.imgbox.com/7b/47/p7NLIBh2_o.png" width="527"></p> 
<h3>3、strlen 的使用和模拟实现</h3> 
<h4>        3.1 strlen 的返回值</h4> 
<p>        strlen 函数我们已经非常的熟悉，之前也介绍了两种模拟 strlen 函数的方法，这里再关于 strlen 的使用做一些补充，同时再介绍另一种 strlen 的模拟实现方法。</p> 
<p style="text-align:center;">        <img alt="" height="225" src="https://images2.imgbox.com/b7/bb/ZLYY4gDK_o.png" width="633"></p> 
<p>        以前我们在使用 strlen 函数的时候，可能没有细心地关注过 strlen 的返回值类型，有时候我们使用 int 类型来接收它的返回值好像也没出现什么问题，但其实这是一个很值得我们去注意的一个问题。来看下面的示例：</p> 
<p style="text-align:center;"><img alt="" height="281" src="https://images2.imgbox.com/4b/be/QR2OpNFH_o.png" width="452"></p> 
<p>        按道理来说-3小于0应该打印的是“&lt;=”，但结果却并不是。其中的原因就在于 strlen 的返回值类型是 size_t 类型，两个 size_t 类型的值相减还是 size_t 类型，而我们知道整型是以补码的形式存储的，所以 size_t 类型会把-3的补码当做一个很大的正整数，这个数当然是大于0的，所以结果是打印出了 “&gt;”。而如果我们想让它输出我们想要的结果，只需要强制类型转换就行。</p> 
<p style="text-align:center;"><img alt="" height="291" src="https://images2.imgbox.com/e8/90/Rfl0SA7Q_o.png" width="457"></p> 
<h4>        3.2 strlen 的模拟实现 </h4> 
<p>         之前的文章中我们用了指针遍历数组和指针-指针两种方法来模拟实现 strlen 函数，这里我们再使用另一种方法来模拟实现——递归。</p> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;

size_t my_strlen(char* str)
{
	assert(str != NULL);
	if (*str != '\0')
	{
		return 1 + my_strlen(++str);
	}
	else
	{
		return 0;
	}
}

int main()
{
	char str[] = "Are you ok?";
	size_t len = my_strlen(str);
	printf("%zd\n", len);
	return 0;
}</code></pre> 
<p style="text-align:center;"><img alt="" height="447" src="https://images2.imgbox.com/60/51/WztAiUb1_o.png" width="437"></p> 
<p>        我们之前说过，递归就是一个把大事化小的过程，适合于解决一些简单重复的操作，就像上面重复读取一个字符并判断的过程。这个方法很简单，一眼就能明白其中的原理，我就不过多阐述了。<strong>值得一说的是，这个方法并<span style="color:#0d0016;">没</span>有创建新变量，这是区别于前两种方法的地方</strong>。 </p> 
<h3>4、strcpy 的使用和模拟实现</h3> 
<h4>        4.1 strcpy 的用法 </h4> 
<p>        strcpy 是一个字符串拷贝函数，它的作用是<strong>把第二个参数所指的字符串拷贝给第一个参数所指的字符串数组中，</strong>注意不要搞反了。</p> 
<p>        更多详细介绍请点击查阅 —&gt;<strong> <a href="https://zh.cppreference.com/w/c/string/byte/strcpy" rel="nofollow" title="strcpy, strcpy_s - cppreference.com">strcpy, strcpy_s - cppreference.com</a></strong></p> 
<p style="text-align:center;">         <img alt="" height="254" src="https://images2.imgbox.com/c6/7e/NWgTSlbk_o.png" width="557"></p> 
<p>        使用 strcpy 也需要包含头文件 &lt;string.h&gt;，是比较简单的，但是有几个需要<span style="color:#fe2c24;"><strong>特别注意</strong></span>的点。 </p> 
<p>（1）源字符串必须以 ‘\0’ 结束；</p> 
<p>        就像 strlen 函数一样，strcpy 函数也需要知道它应该在哪里停止拷贝。 </p> 
<p>（2）会将源字符串中的 ‘\0’ 拷贝到目标空间；</p> 
<p>         在上面的代码中我们使用 strlen 函数证明了这点。</p> 
<p>（3）目标空间必须足够大，以确保能放得下字符串；</p> 
<p>        以上面的代码为例，如果我们定义的字符数组 str2 太小，程序就会出错。</p> 
<p style="text-align:center;"><img alt="" height="310" src="https://images2.imgbox.com/0d/79/m8pRRPc1_o.png" width="513">  </p> 
<p>（4）目标空间必须可修改。</p> 
<p>         这里举个反例来证明这一点。</p> 
<p style="text-align:center;"><img alt="" height="349" src="https://images2.imgbox.com/14/43/aOGeiRVv_o.png" width="430"></p> 
<p>        将常量字符串 “abc” 存到字符指针变量 ps 中，之前说过常量字符串是不能被修改的，所以程序就出错了。 </p> 
<h4>        4.2 strcpy 的模拟实现 </h4> 
<p>        就像 strlen 函数一样，我们同样也可以模拟实现一个 strcpy 函数，完成字符串拷贝的功能。 </p> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;

void my_strcpy(char* dest, const char* sour)
{
	assert(dest != NULL);
    assert(sour != NULL);
	while (*sour != '\0')
	{
		*dest = *sour;
		sour++;
		dest++;
	}
	*dest = *sour;//\0
}

int main()
{
	char str1[] = "what can I say? man.";
	char str2[50] = { 0 };
	my_strcpy(str2, str1);
	printf("%s\n", str2);
	printf("%zd\n", strlen(str2));
	return 0;
}
</code></pre> 
<p style="text-align:center;"><img alt="" height="324" src="https://images2.imgbox.com/78/8e/7xHC1Wm8_o.png" width="493"></p> 
<p>        逻辑也是特别简单的，只不过我们要特别注意字符 ‘\0’ 也需要拷贝过去。</p> 
<h4>        4.3 strcpy 的返回值 </h4> 
<p style="text-align:center;"><img alt="" height="199" src="https://images2.imgbox.com/6a/94/lH9sWR1K_o.png" width="623"></p> 
<p>        关于 strcpy 函数我们可能会忽略了它的返回值，因为我们会觉得这个函数并不需要什么返回值，但其实它是有返回值的，既然有返回值，那它的返回值就有用，所以严格来说我们上面模拟实现的 strcpy 函数返回值应该为 char * 而不是 void 。<strong>strcpy 函数返回的是目标字符串的首地址，这使得 strcpy 可以链式操作。</strong></p> 
<p><strong>        </strong>所以上面的代码可以更新为：</p> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;

char* my_strcpy(char* dest, const char* sour)
{
	assert(dest != NULL);
	assert(sour != NULL);
	char* pd = dest;
	while (*sour != '\0')
	{
		*dest = *sour;
		sour++;
		dest++;
	}
	*dest = *sour;//\0
	return pd;
}

int main()
{
	char str1[] = "what can I say? man.";
	char str2[50] = { 0 };
	char* ps = my_strcpy(str2, str1);
	printf("%s\n", ps);
	printf("%s\n", my_strcpy(str2, str1));
	printf("%zd\n", strlen(str2));
	return 0;
}</code></pre> 
<p style="text-align:center;"><img alt="" height="478" src="https://images2.imgbox.com/30/ed/bwT02KIa_o.png" width="381"></p> 
<p style="text-align:center;"><img alt="" height="379" src="https://images2.imgbox.com/ee/a1/p4Bc6jLH_o.png" width="419"></p> 
<h4>        4.4 strcpy 模拟实现的优化 </h4> 
<p>        虽然我们已经完成了 strcpy 函数的模拟实现，但上面的代码还可以优化。因为字符‘\0’的特殊，上面的代码中我们是将普通字符和‘\0’字符分开处理的，那是否可以有个办法将这两步合在一起呢？</p> 
<p>        来体会下面这条代码：</p> 
<p style="text-align:center;"><img alt="" height="343" src="https://images2.imgbox.com/7a/e7/UZpOp0T4_o.png" width="521"></p> 
<p>        我们用一条代码就实现了拷贝字符串，包括拷贝字符‘\0’。其中的原理也是非常简单，当字符‘\0’拷贝到目的空间后，括号中表达式的值为0，就自动跳出了循环。需要说明的是两个指针变量都是先解引用，然后再自增的。</p> 
<h3>5、strcat 的使用和模拟实现</h3> 
<h4>         5.1 strcat 的用法</h4> 
<p>        strcat 函数的作用是将源字符串拼接到目标字符串的后面。跟 strcpy 函数类似，strcat 是将第二个参数所指的字符串拼接到第一个参数所指的字符串后面。</p> 
<p>        更多详细的介绍请点击阅读 —&gt;<strong> <a href="https://zh.cppreference.com/w/c/string/byte/strcat" rel="nofollow" title="strcat, strcat_s - cppreference.com">strcat, strcat_s - cppreference.com</a></strong></p> 
<p style="text-align:center;"><img alt="" height="256" src="https://images2.imgbox.com/1f/3c/tNUDwPpL_o.png" width="497"></p> 
<p>        同样的，strcat 函数也有几个需要注意的点： </p> 
<p>        （1）源字符串必须以‘\0’结束；</p> 
<p>        （2）目标字符串中也得有‘\0’，否则没法知道拼接在哪里；</p> 
<p>        （3）目标空间必须足够大；</p> 
<p>        （4）目标空间必须可修改。</p> 
<h4>        5.2 strcat 的返回值</h4> 
<p style="text-align:center;"><img alt="" height="265" src="https://images2.imgbox.com/b9/c4/WQiOBlVO_o.png" width="616"></p> 
<p>        类比 strcpy，strcat 也是有返回值的，并且返回值也是目标字符串的首地址。</p> 
<p style="text-align:center;"><img alt="" height="253" src="https://images2.imgbox.com/08/c4/0PY2d7T2_o.png" width="483"></p> 
<h4>        5.3 strcat 的模拟实现</h4> 
<p>        我们依然可以自己写一个函数来模拟实现 strcat 的功能，方法很简单，类似于模拟实现 strcpy 的方法，我们只需要想办法将源字符串拼接到目标字符串末尾就行，相信对于现在有点基础的我们来说这并不是什么难事。</p> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;

char* my_strcat(char* dest, const char* sour)
{
	assert(dest != NULL);
	assert(sour != NULL);
	char* pd = dest;
	while (*dest++);
	dest--;//覆盖掉目标字符串中的\0
	while (*dest++ = *sour++);
	return pd;
}

int main()
{
	char str1[20] = "hello ";
	char str2[] = "world";
	char *ps = my_strcat(str1, str2);
	printf("%s\n", ps);
	return 0;
}</code></pre> 
<p style="text-align:center;"><img alt="" height="324" src="https://images2.imgbox.com/f3/90/108Seqk7_o.png" width="401"></p> 
<p>        上面我们是将一个字符串与另一个字符串拼接在一起，那能不能将一个字符串拼接到自己的末尾呢？</p> 
<p style="text-align:center;"><img alt="" height="321" src="https://images2.imgbox.com/7a/60/BMzg2vio_o.png" width="456"></p> 
<p style="text-align:center;"><img alt="" height="287" src="https://images2.imgbox.com/31/7d/jfjufbFB_o.png" width="459"></p> 
<p>        可以看到，用我们自己写的函数不能实现字符串自己拼接到自己后面，这是因为拼接的过程是在目标字符串末尾的 ‘\0’ 处开始拼接的，也就是说目标字符串的第一个字符会覆盖掉它自己末尾的 ‘\0’，那函数的第二个参数指针就永远也找不到 ‘\0’ 以结束拼接，就会陷入死循环。</p> 
<p>        但是 strcat 函数可以，不过 <strong>strcat 函数并不能保证这件事情</strong>，也就是说上面能成功是偶然的。 </p> 
<p>           <span style="color:#4da8ee;">如果觉得我的文章还不错，请点赞、收藏 + 关注支持一下，我会持续更新更好的文章</span>。 </p> 
<p>                                      <span style="color:#be191c;">  点击跳转下一节</span> —&gt;<strong> <a class="link-info" href="https://blog.csdn.net/2301_78843337/article/details/139317801?spm=1001.2014.3001.5501" title="C语言（字符、字符串函数）2">C语言（字符、字符串函数）2</a> </strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3b8d2b510936b624e80ca9f8fe5f8803/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Switch 刷安卓11 (LineageOS 18.1) 大气层双系统图文教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/66396cc2393c1f7a0a52025d47cb9ff3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Redis】 Java操作客户端命令——集合操作与有序集合操作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>