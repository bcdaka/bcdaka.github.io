<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【MQTT】MQTT协议与指令下发；MQTT与Kafka比较 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/dbc906f0a3e9051debc1da971edfe1ba/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【MQTT】MQTT协议与指令下发；MQTT与Kafka比较">
  <meta property="og:description" content="本文内容： 一、MQTT协议1. 发布/订阅模型：2. 连接和会话：3. QoS级别（Quality of Service Levels）：4. 保留消息：5. Last Will and Testament（遗嘱消息）：6. 适用场景和优势：7. 消息格式：8. 安全性：9. 开源实现和协议版本： 二、指令下发指令下发流程 三、使用MQTT实现指令下发具体步骤代码案例 四、MQTT 数据和数据库数据五、MQTT和Kafka比较MQTT和Kafka主要区别MQTT和Kafka适合的场景 相关文章：
（一）MQTT协议与指令下发；MQTT与Kafka比较
（二）用MQTT在Spring Boot项目中实现异步消息通信
一、MQTT协议 详细讲讲MQTT协议
当涉及到物联网和设备通信时，MQTT（Message Queuing Telemetry Transport）是一种轻量级、开放、灵活的协议。MQTT最初是为低带宽、不稳定网络环境下的传感器和设备之间的通信而设计的，但现在已经广泛应用于各种应用领域。
以下是关于MQTT协议的详细解释：
1. 发布/订阅模型： 发布者（Publisher）： 负责将消息发布到特定的主题。订阅者（Subscriber）： 订阅特定主题，以接收相关消息。主题（Topic）： 是消息的分类标签，用于描述消息的内容。发布者发布消息到特定主题，而订阅者则订阅特定主题。 2. 连接和会话： MQTT使用基于TCP的连接，但也可以在WebSocket上运行。客户端和服务器之间建立长连接，可以维护一个持久的会话状态。客户端可以选择保持与服务器的连接状态，以接收实时消息。 3. QoS级别（Quality of Service Levels）： QoS 0： 最多一次传递，消息可能会丢失，不保证传递。QoS 1： 至少一次传递，消息被确认，但可能会重复。QoS 2： 正好一次传递，确保消息只传递一次，但是通信开销较大。 4. 保留消息： 发布者可以设置消息为保留消息，这意味着新的订阅者在订阅相关主题时会收到最新的保留消息。 5. Last Will and Testament（遗嘱消息）： 客户端可以设置遗嘱消息，以便在连接意外断开时通知其他订阅者。 6. 适用场景和优势： 适用于低带宽、高延迟、不稳定网络环境下的物联网设备通信。轻量级协议，减少通信开销。支持发布/订阅模型，允许灵活的通信架构。易于实现，有许多开源实现和库可用。 7. 消息格式： MQTT消息由固定头、可变头和消息体组成。固定头包含消息类型、标志位等信息。可变头包含不同类型消息的特定信息。消息体包含实际的消息内容。 8. 安全性： MQTT本身并没有提供加密功能，但可以在其上使用TLS/SSL进行加密。用户名和密码可以用于身份验证。 9.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-01-12T09:02:34+08:00">
    <meta property="article:modified_time" content="2024-01-12T09:02:34+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【MQTT】MQTT协议与指令下发；MQTT与Kafka比较</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>本文内容：</h4> 
 <ul><li><a href="#MQTT_8" rel="nofollow">一、MQTT协议</a></li><li><ul><li><ul><li><a href="#1__16" rel="nofollow">1. 发布/订阅模型：</a></li><li><a href="#2__22" rel="nofollow">2. 连接和会话：</a></li><li><a href="#3_QoSQuality_of_Service_Levels_28" rel="nofollow">3. QoS级别（Quality of Service Levels）：</a></li><li><a href="#4__34" rel="nofollow">4. 保留消息：</a></li><li><a href="#5_Last_Will_and_Testament_38" rel="nofollow">5. Last Will and Testament（遗嘱消息）：</a></li><li><a href="#6__42" rel="nofollow">6. 适用场景和优势：</a></li><li><a href="#7__49" rel="nofollow">7. 消息格式：</a></li><li><a href="#8__56" rel="nofollow">8. 安全性：</a></li><li><a href="#9__61" rel="nofollow">9. 开源实现和协议版本：</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_72" rel="nofollow">二、指令下发</a></li><li><ul><li><a href="#_103" rel="nofollow">指令下发流程</a></li></ul> 
  </li><li><a href="#MQTT_138" rel="nofollow">三、使用MQTT实现指令下发</a></li><li><ul><li><a href="#_139" rel="nofollow">具体步骤</a></li><li><a href="#_157" rel="nofollow">代码案例</a></li></ul> 
  </li><li><a href="#MQTT__203" rel="nofollow">四、MQTT 数据和数据库数据</a></li><li><a href="#MQTTKafka_220" rel="nofollow">五、MQTT和Kafka比较</a></li><li><ul><li><a href="#MQTTKafka_221" rel="nofollow">MQTT和Kafka主要区别</a></li><li><a href="#MQTTKafka_262" rel="nofollow">MQTT和Kafka适合的场景</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<blockquote> 
 <p>相关文章：<br> <a href="https://blog.csdn.net/qq_47450919/article/details/135494203?spm=1001.2014.3001.5502">（一）MQTT协议与指令下发；MQTT与Kafka比较</a><br> <a href="https://blog.csdn.net/qq_47450919/article/details/135497352">（二）用MQTT在Spring Boot项目中实现异步消息通信</a></p> 
</blockquote> 
<hr> 
<h2><a id="MQTT_8"></a>一、MQTT协议</h2> 
<ul><li> <p>详细讲讲MQTT协议</p> <p>当涉及到<strong>物联网</strong>和<strong>设备通信</strong>时，MQTT（Message Queuing Telemetry Transport）是一种轻量级、开放、灵活的协议。MQTT最初是为低带宽、不稳定网络环境下的传感器和设备之间的通信而设计的，但现在已经广泛应用于各种应用领域。</p> <p>以下是关于MQTT协议的详细解释：</p> <h4><a id="1__16"></a>1. 发布/订阅模型：</h4> 
  <ul><li><strong>发布者（Publisher）：</strong> 负责将消息发布到特定的主题。</li><li><strong>订阅者（Subscriber）：</strong> 订阅特定主题，以接收相关消息。</li><li><strong>主题（Topic）：</strong> 是消息的分类标签，用于描述消息的内容。发布者发布消息到特定主题，而订阅者则订阅特定主题。</li></ul> <h4><a id="2__22"></a>2. 连接和会话：</h4> 
  <ul><li>MQTT使用基于TCP的连接，但也可以在WebSocket上运行。</li><li>客户端和服务器之间建立长连接，可以维护一个持久的会话状态。</li><li>客户端可以选择保持与服务器的连接状态，以接收实时消息。</li></ul> <h4><a id="3_QoSQuality_of_Service_Levels_28"></a>3. QoS级别（Quality of Service Levels）：</h4> 
  <ul><li><strong>QoS 0：</strong> 最多一次传递，消息可能会丢失，不保证传递。</li><li><strong>QoS 1：</strong> 至少一次传递，消息被确认，但可能会重复。</li><li><strong>QoS 2：</strong> 正好一次传递，确保消息只传递一次，但是通信开销较大。</li></ul> <h4><a id="4__34"></a>4. 保留消息：</h4> 
  <ul><li>发布者可以设置消息为保留消息，这意味着新的订阅者在订阅相关主题时会收到最新的保留消息。</li></ul> <h4><a id="5_Last_Will_and_Testament_38"></a>5. Last Will and Testament（遗嘱消息）：</h4> 
  <ul><li>客户端可以设置遗嘱消息，以便在连接意外断开时通知其他订阅者。</li></ul> <h4><a id="6__42"></a>6. 适用场景和优势：</h4> 
  <ul><li>适用于低带宽、高延迟、不稳定网络环境下的物联网设备通信。</li><li>轻量级协议，减少通信开销。</li><li>支持发布/订阅模型，允许灵活的通信架构。</li><li>易于实现，有许多开源实现和库可用。</li></ul> <h4><a id="7__49"></a>7. 消息格式：</h4> 
  <ul><li>MQTT消息由固定头、可变头和消息体组成。</li><li>固定头包含消息类型、标志位等信息。</li><li>可变头包含不同类型消息的特定信息。</li><li>消息体包含实际的消息内容。</li></ul> <h4><a id="8__56"></a>8. 安全性：</h4> 
  <ul><li>MQTT本身并没有提供加密功能，但可以在其上使用TLS/SSL进行加密。</li><li>用户名和密码可以用于身份验证。</li></ul> <h4><a id="9__61"></a>9. 开源实现和协议版本：</h4> 
  <ul><li>Eclipse Mosquitto、HiveMQ、EMQ等是一些常见的MQTT服务器实现。</li><li>MQTT 3.1和MQTT 5.0是两个主要的协议版本，其中MQTT 5.0提供了更多的功能和改进。</li><li></ul> <p>MQTT协议的灵活性和轻量级特性使其成为连接各种设备和应用程序的理想选择，尤其在物联网领域中。学习MQTT协议可以帮助设计和实施可靠的设备通信系统。</p> </li></ul> 
<h2><a id="_72"></a>二、指令下发</h2> 
<p>指令下发通常指的是通过某种通信协议向远程设备发送命令或控制信息。这个过程通常是在分布式系统或物联网（IoT）中的设备管理中使用的。</p> 
<p>指令下发是将控制指令从上级控制系统下发发送给下级执行系统以实现控制功能。</p> 
<p>具体来说:</p> 
<ul><li> <p>指令下发的目的是向下级系统发布控制命令,如开关机、参数设置等。</p> </li><li> <p>上级系统负责生成控制指令,下级系统负责接收并执行指令。</p> </li><li> <p>指令通常以数字或字符形式表示,通过网络通信等方式从上至下传输。</p> </li><li> <p>指令下发是一个控制链路的关键环节,实现上下级系统之间的命令传输与执行。</p> </li></ul> 
<p>一些常见的指令下发场景:</p> 
<ul><li> <p>SCADA系统向过程控制器下发控制参数配置指令。</p> </li><li> <p>MES系统向生产设备下发产品切换指令。</p> </li><li> <p>车联网平台向交通指挥系统下发车辆调度指令。</p> </li><li> <p>大数据中心向边缘计算集群下发任务下发指令。</p> </li><li> <p>APP下发控制指令驱动智能家电执行动作。</p> </li></ul> 
<p>所以总体来说,指令下发是上下级控制系统之间实现控制功能的基础,通过它来传达和执行各种操作指令。</p> 
<h3><a id="_103"></a>指令下发流程</h3> 
<p>下面是一个一般的指令下发流程：</p> 
<ol><li><strong>指令生成</strong>： 
  <ul><li>在系统的控制中心或者上层应用中，某个用户或者自动化程序生成一个需要发送给设备的指令。这个指令可能是控制设备执行某个动作、改变状态、或者请求设备发送特定信息等。</li></ul> </li><li><strong>指令封装</strong>： 
  <ul><li>生成的指令需要按照设备能理解的通信协议进行封装。这可能包括将指令转换为特定的数据格式、添加必要的协议头部信息等。</li></ul> </li><li><strong>指令传输</strong>： 
  <ul><li>封装后的指令通过通信协议传输到目标设备。这可以通过不同的通信方式实现，例如MQTT、HTTP、CoAP等。在物联网中，MQTT是一个常用的协议，因为它轻量、灵活，适合在资源受限的设备上使用。</li></ul> </li><li><strong>设备接收</strong>： 
  <ul><li>目标设备通过相应的通信协议接收到指令。设备需要能够理解协议并正确解析接收到的指令。</li></ul> </li><li><strong>指令解析</strong>： 
  <ul><li>设备解析接收到的指令，理解其中的控制或操作内容。</li></ul> </li><li><strong>执行指令</strong>： 
  <ul><li>设备执行指令对应的操作。这可能包括改变设备状态、执行某种动作、或者返回请求的信息。</li></ul> </li><li><strong>响应生成</strong>： 
  <ul><li>设备生成执行结果的响应，这个响应也需要按照相应的协议进行封装。</li></ul> </li><li><strong>响应传输</strong>： 
  <ul><li>设备将响应传输回控制中心或者上层应用。</li></ul> </li><li><strong>响应解析</strong>： 
  <ul><li>控制中心或者应用解析接收到的响应，获取设备执行指令的结果。</li></ul> </li><li><strong>处理结果</strong>： 
  <ul><li>控制中心或者应用处理设备执行指令的结果，可能会触发进一步的操作或者通知相关的系统。</li></ul> </li></ol> 
<p>在这个流程中，MQTT作为通信协议的一部分起到了很关键的作用。它提供了发布/订阅的模式，允许设备和系统之间实现松耦合的通信。在结合MQTT时，需要定义好指令的主题（Topic），确保设备和控制中心都订阅了正确的主题，以便指令的传递。</p> 
<p>例如，在一个基于MQTT的系统中，可以按照以下步骤进行指令下发：</p> 
<ol><li>控制中心发布一个包含指令的消息到MQTT Broker，指定了设备的主题。</li><li>目标设备订阅了相应的主题，在接收到消息后解析并执行指令。</li><li>设备执行指令后，可以发布一个包含执行结果的消息到MQTT Broker，指定了相应的主题。</li><li>控制中心订阅了执行结果的主题，在接收到设备的响应消息后进行处理。</li></ol> 
<p>这样的设计使得设备和控制中心可以异步地进行通信，实现了灵活而可靠的远程控制。</p> 
<h2><a id="MQTT_138"></a>三、使用MQTT实现指令下发</h2> 
<h3><a id="_139"></a>具体步骤</h3> 
<p>在使用MQTT进行指令下发时，通常需要考虑以下几个步骤：</p> 
<ol><li><strong>定义MQTT主题（Topic）</strong>： 
  <ul><li>在MQTT中，主题是消息发布和订阅的关键。为了实现指令下发，需要定义好主题，以便设备能够订阅这些主题，而控制中心或应用则可以发布消息到这些主题。</li></ul> </li><li><strong>设备订阅主题</strong>： 
  <ul><li>设备需要在启动时订阅用于接收指令的MQTT主题。这样，设备就能够监听来自控制中心或应用的指令消息。</li></ul> </li><li><strong>控制中心发布指令消息</strong>： 
  <ul><li>控制中心或应用通过MQTT发布包含指令的消息到相应的主题。这个消息应该包含指令的内容，可能是一个JSON格式的数据，以便设备能够解析。</li></ul> </li><li><strong>设备接收指令消息</strong>： 
  <ul><li>设备通过MQTT接收到发布的指令消息。这通常在设备的MQTT消息处理回调中完成。</li></ul> </li><li><strong>解析指令</strong>： 
  <ul><li>设备解析接收到的指令消息，理解其中的控制或操作内容。</li></ul> </li><li><strong>执行指令</strong>： 
  <ul><li>设备执行指令对应的操作。这可能包括改变设备状态、执行某种动作、或者返回请求的信息。</li></ul> </li></ol> 
<h3><a id="_157"></a>代码案例</h3> 
<p>以下是一个简单的Java示例代码，演示了如何使用MQTT 客户端库进行 MQTT 指令下发：</p> 
<pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>eclipse<span class="token punctuation">.</span>paho<span class="token punctuation">.</span>client<span class="token punctuation">.</span>mqttv3<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>eclipse<span class="token punctuation">.</span>paho<span class="token punctuation">.</span>client<span class="token punctuation">.</span>mqttv3<span class="token punctuation">.</span>persist<span class="token punctuation">.</span></span><span class="token class-name">MemoryPersistence</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MqttCommandSender</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">String</span> broker <span class="token operator">=</span> <span class="token string">"tcp://mqtt.eclipse.org:1883"</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> clientId <span class="token operator">=</span> <span class="token string">"CommandSender"</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> topic <span class="token operator">=</span> <span class="token string">"device/command"</span><span class="token punctuation">;</span> <span class="token comment">// 定义指令主题</span>

        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">MqttClient</span> client <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MqttClient</span><span class="token punctuation">(</span>broker<span class="token punctuation">,</span> clientId<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">MemoryPersistence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">MqttConnectOptions</span> connOpts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MqttConnectOptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            connOpts<span class="token punctuation">.</span><span class="token function">setCleanSession</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Connecting to broker: "</span> <span class="token operator">+</span> broker<span class="token punctuation">)</span><span class="token punctuation">;</span>
            client<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>connOpts<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Connected"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// 定义指令内容，可以是JSON格式的数据</span>
            <span class="token class-name">String</span> command <span class="token operator">=</span> <span class="token string">"{\\"</span>action\\"<span class="token operator">:</span>\\"start\\"<span class="token punctuation">,</span> \\"parameter\\"<span class="token operator">:</span>\\"value\\"<span class="token punctuation">}</span>"<span class="token punctuation">;</span>

            <span class="token comment">// 发布指令到指定主题</span>
            client<span class="token punctuation">.</span><span class="token function">publish</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">MqttMessage</span><span class="token punctuation">(</span>command<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Command sent"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            client<span class="token punctuation">.</span><span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Disconnected"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">MqttException</span> me<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            me<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>上述代码演示了一个简单的指令发送器，它连接到 MQTT 代理，发布了一个包含指令的消息到指定主题。在实际应用中，需要根据需求定义更多的细节，例如处理设备响应、错误处理等。</p> 
<p>在设备端需要实现一个 MQTT 客户端用于订阅指令主题，接收并处理来自控制中心的指令。这可能需要使用 Eclipse Paho 的 <code>MqttCallback</code> 接口。</p> 
<h2><a id="MQTT__203"></a>四、MQTT 数据和数据库数据</h2> 
<p>MQTT（Message Queuing Telemetry Transport）是一种轻量级的消息传输协议，通常用于在设备之间传递实时数据。与传统数据库相比，MQTT 具有一些特定的特征和应用场景。</p> 
<p>以下是 MQTT 数据和数据库数据之间的一些差异：</p> 
<ol><li><strong>实时性和即时性：</strong> MQTT 通常用于实时性要求较高的场景，例如物联网设备之间的实时通信。消息可以非常快速地通过 MQTT 传递，而数据库操作可能会有一些延迟。</li><li><strong>消息格式：</strong> MQTT 传递的是消息，这些消息可以采用各种格式，如 JSON、二进制数据等。数据库通常存储结构化数据，可能是表格形式的数据。</li><li><strong>存储方式：</strong> MQTT 主要用于消息传递，通常不用于数据的长期存储。数据可以被传递到订阅者，但不一定会在中间存储。相比之下，数据库是一种持久化的存储方式，用于长期保存数据。</li><li><strong>数据结构：</strong> MQTT 的数据通常是一对多的关系，一个发布者可以将消息发送给多个订阅者。数据库中的数据通常是一对一或一对多的关系，具有固定的结构。</li></ol> 
<p><strong>在一般的物联网系统中，通常会将 MQTT 数据和数据库数据结合使用：</strong></p> 
<ul><li><strong>MQTT 数据流向数据库：</strong> 设备产生的实时数据通过 MQTT 发送到一个消息代理，然后可以选择将这些数据存储到数据库中，以便后续分析、查询和长期存储。</li><li><strong>数据库数据供给 MQTT：</strong> 某些应用可能需要将数据库中的数据推送到设备，可以通过定期查询数据库，然后使用 MQTT 发送数据到相关的设备。</li></ul> 
<p>综上所述，MQTT 主要用于实时通信和消息传递，而数据库主要用于数据的长期存储和结构化查询。在实际应用中，它们通常是相辅相成的，一起构建完整的物联网系统。</p> 
<h2><a id="MQTTKafka_220"></a>五、MQTT和Kafka比较</h2> 
<h3><a id="MQTTKafka_221"></a>MQTT和Kafka主要区别</h3> 
<p>MQTT和Kafka是两种主流的消息中间件二者的主要区别如下:</p> 
<ol><li> <p>架构设计</p> 
  <ul><li> <p>MQTT是一个单发布/订阅消息模型,Kafka采用发布/订阅和消息队列模型。</p> </li><li> <p>MQTT面向点对点通讯,Kafka面向发布/订阅,可以进行广播通讯。</p> </li></ul> </li><li> <p>消息传输模式</p> 
  <ul><li>MQTT消息以推方式发送,Kafka消息支持推和拉加载务。</li></ul> </li><li> <p>消息Durability</p> 
  <ul><li>MQTT消息不支持持久化,Kafka支持消息持久化存储。</li></ul> </li><li> <p>性能</p> 
  <ul><li>Kafka性能更高,吞吐量更大,可以处理巨大流量。MQTT吞吐量和并发能力相对较低。</li></ul> </li><li> <p>存储能力</p> 
  <ul><li>Kafka可以对消息进行存储管理和备份,而MQTT不支持消息存储。</li></ul> </li><li> <p>可靠性</p> 
  <ul><li>Kafka支持分布式部署高可用,MQTT单点故障风险较高。</li></ul> </li><li> <p>应用场景</p> 
  <ul><li> <p>MQTT更适用于物联网场景的低延迟和低带宽连接。</p> </li><li> <p>Kafka适用于大数据量、高吞吐的场景,例如实时日志、点击流等。</p> </li></ul> </li></ol> 
<p><strong>总体来说:</strong></p> 
<ul><li>MQTT适用于IoT边缘接入场景,Kafka更强大进行大数据实时处理。</li><li>MQTT单点,Kafka支持分布式。</li><li>Kafka消息持久化,可追溯;MQTT不支持存储。</li></ul> 
<h3><a id="MQTTKafka_262"></a>MQTT和Kafka适合的场景</h3> 
<ul><li> <p>IoT场景下,MQTT更适用于设备到云端的低延时数据上报,像温湿度传感器这类。Kafka更适用于需求较高的场景,如视频云。</p> </li><li> <p>使用Kafka来处理和分析实时数据更好,它支持持久化和横向扩展能力强。MQTT不适合大规模数据处理。</p> </li><li> <p>日志分析Kafka和Elasticsearch都很好,Kafka用于高吞吐预处理,Elasticsearch用于搜索和分析。</p> </li><li> <p>物流追踪这样低延迟的场景MQTT足够,不需要Kafka的高性能。</p> </li><li> <p>服务间通讯可以使用Kafka,但性能考虑最好还是用专用MQ。</p> </li><li> <p>推送使用MQTT订阅更高效可靠。</p> </li><li> <p>Crowdfunding实时更新可以用Kafka做事件传播与处理。</p> </li><li> <p>视频直播可以用Kafka转发流数据,用MQTT实现弹幕交互。</p> </li></ul> 
<p><strong>总体来说,MQTT更适用于物联网即时报告,Kafka更适用于大数据实时计算。两个都很强大,选择要根据实际场景需求进行权衡。具体实施也可以结合两者各自优点,如Kafka处理大数据,MQTT边缘物联网连接</strong>。</p> 
<hr> 
<blockquote> 
 <p>相关文章：<br> <a href="https://blog.csdn.net/qq_47450919/article/details/135494203?spm=1001.2014.3001.5502">（一）MQTT协议与指令下发；MQTT与Kafka比较</a><br> <a href="https://blog.csdn.net/qq_47450919/article/details/135497352">（二）用MQTT在Spring Boot项目中实现异步消息通信</a></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dfd00f8d2ae10607f5c92764a42d28ad/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python 基础 详细,python 基础入门</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/884f487f571e9632e36494a0be9fa8ea/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">训练Stable Diffusion(SD) Lora模型巨详细教程 赛博丹炉/青龙脚本/秋叶云端使用教程 主用赛博丹炉（道玄）巨小白巨啰嗦，全是干货和踩过的坑</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>