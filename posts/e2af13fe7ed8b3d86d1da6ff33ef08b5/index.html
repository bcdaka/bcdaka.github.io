<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>算法沉淀——滑动窗口（leetcode真题剖析） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/e2af13fe7ed8b3d86d1da6ff33ef08b5/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="算法沉淀——滑动窗口（leetcode真题剖析）">
  <meta property="og:description" content="算法沉淀——滑动窗口 01.长度最小的子数组02.无重复字符的最长子串03.最大连续1的个数 III04.将 x 减到 0 的最小操作数05.水果成篮06.找到字符串中所有字母异位词07.串联所有单词的子串08.最小覆盖子串 滑动窗口算法是一种用于解决数组或列表中子数组或子序列问题的有效技巧。它通过维护一个可变大小的窗口（通常是一个连续的子数组或子序列），在数据流中滑动该窗口来进行问题求解。这种方法在一维数组和二维数组中都有应用，并且在字符串处理中也很常见。 滑动窗口算法的基本思想是使用两个指针，通常是左指针（left）和右指针（right）来定义窗口，通过移动这两个指针，调整窗口的大小和位置，从而在不重复计算的情况下找到问题的解。
以下是滑动窗口算法的一般步骤：
初始化窗口： 定义左指针和右指针，并将窗口初始化为满足问题条件的初始状态。移动窗口： 不断移动右指针，扩展窗口大小，直到不再满足问题条件为止。调整窗口： 一旦窗口不再满足问题条件，开始移动左指针，缩小窗口大小，直到满足问题条件为止。记录解： 在窗口移动的过程中，记录满足问题条件的解。 滑动窗口算法适用于一些问题，例如：
子数组和子序列的最大/最小值： 在数组中找到满足条件的子数组或子序列的最大或最小值。子数组和子序列的和或平均值： 在数组中找到满足条件的子数组或子序列的和或平均值。字符串处理问题： 如找到最小覆盖子串、找到没有重复字符的最长子串等。 下面我们通过几个真题来学习这个算法
01.长度最小的子数组 题目链接：https://leetcode.cn/problems/minimum-size-subarray-sum/
给定一个含有 n 个正整数的数组和一个正整数 target 。
找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl&#43;1, ..., numsr-1, numsr] ，并返回其长度**。**如果不存在符合条件的子数组，返回 0 。
示例 1：
输入：target = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。 示例 2：
输入：target = 4, nums = [1,4,4] 输出：1 示例 3：
输入：target = 11, nums = [1,1,1,1,1,1,1,1] 输出：0 思路">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-01-28T22:11:35+08:00">
    <meta property="article:modified_time" content="2024-01-28T22:11:35+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">算法沉淀——滑动窗口（leetcode真题剖析）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/42/73/q6V7RmZ5_o.jpg" alt="在这里插入图片描述"></p> 
<p></p> 
<div class="toc"> 
 <h4>算法沉淀——滑动窗口</h4> 
 <ul><li><a href="#01_22" rel="nofollow">01.长度最小的子数组</a></li><li><a href="#02_83" rel="nofollow">02.无重复字符的最长子串</a></li><li><a href="#031_III_144" rel="nofollow">03.最大连续1的个数 III</a></li><li><a href="#04_x__0__197" rel="nofollow">04.将 x 减到 0 的最小操作数</a></li><li><a href="#05_265" rel="nofollow">05.水果成篮</a></li><li><a href="#06_352" rel="nofollow">06.找到字符串中所有字母异位词</a></li><li><a href="#07_412" rel="nofollow">07.串联所有单词的子串</a></li><li><a href="#08_502" rel="nofollow">08.最小覆盖子串</a></li></ul> 
</div> 
<br> 滑动窗口算法是一种用于解决数组或列表中子数组或子序列问题的有效技巧。它通过维护一个可变大小的窗口（通常是一个连续的子数组或子序列），在数据流中滑动该窗口来进行问题求解。这种方法在一维数组和二维数组中都有应用，并且在字符串处理中也很常见。 
<p></p> 
<p>滑动窗口算法的基本思想是使用两个指针，通常是左指针（left）和右指针（right）来定义窗口，通过移动这两个指针，调整窗口的大小和位置，从而在不重复计算的情况下找到问题的解。</p> 
<p>以下是滑动窗口算法的一般步骤：</p> 
<ol><li><strong>初始化窗口：</strong> 定义左指针和右指针，并将窗口初始化为满足问题条件的初始状态。</li><li><strong>移动窗口：</strong> 不断移动右指针，扩展窗口大小，直到不再满足问题条件为止。</li><li><strong>调整窗口：</strong> 一旦窗口不再满足问题条件，开始移动左指针，缩小窗口大小，直到满足问题条件为止。</li><li><strong>记录解：</strong> 在窗口移动的过程中，记录满足问题条件的解。</li></ol> 
<p>滑动窗口算法适用于一些问题，例如：</p> 
<ul><li><strong>子数组和子序列的最大/最小值：</strong> 在数组中找到满足条件的子数组或子序列的最大或最小值。</li><li><strong>子数组和子序列的和或平均值：</strong> 在数组中找到满足条件的子数组或子序列的和或平均值。</li><li><strong>字符串处理问题：</strong> 如找到最小覆盖子串、找到没有重复字符的最长子串等。</li></ul> 
<p>下面我们通过几个真题来学习这个算法</p> 
<h2><a id="01_22"></a>01.长度最小的子数组</h2> 
<p>题目链接：https://leetcode.cn/problems/minimum-size-subarray-sum/</p> 
<p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p> 
<p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度**。**如果不存在符合条件的子数组，返回 <code>0</code> 。</p> 
<p><strong>示例 1：</strong></p> 
<pre><code>输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
</code></pre> 
<p><strong>示例 2：</strong></p> 
<pre><code>输入：target = 4, nums = [1,4,4]
输出：1
</code></pre> 
<p><strong>示例 3：</strong></p> 
<pre><code>输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
</code></pre> 
<p><strong>思路</strong></p> 
<p>在最开始没接触这种算法题时，我们要先建立滑动窗口的概念，首先像这种题目要求是连续的情况下，我们就要想到这种算法思想，然后滑动窗口主要分为四个步骤，进窗口、判断、出窗口、更新结果；其中更新结果要根据不同的情况放在不同的位置，比如上面这道题</p> 
<p>这里使用滑动窗口算法，用于找到数组中和大于等于目标值 <code>target</code> 的最短子数组的长度。</p> 
<ol><li><strong>初始化：</strong> 使用两个指针 <code>left</code> 和 <code>right</code>，都初始指向数组的起始位置。同时定义变量 <code>sum</code> 用来记录当前窗口中元素的和，以及变量 <code>len</code> 用来记录当前找到的最短子数组的长度。</li><li><strong>窗口扩展：</strong> 在一个循环中，不断将右指针 <code>right</code> 向右移动，累加元素的值到 <code>sum</code> 中。如果 <code>sum</code> 大于等于目标值 <code>target</code>，说明当前窗口的和满足条件。</li><li><strong>窗口收缩：</strong> 进入内层循环，将左指针 <code>left</code> 向右移动，缩小窗口大小，同时更新 <code>len</code> 为当前窗口的长度。然后从 <code>sum</code> 中减去左侧移出窗口的元素的值。</li><li><strong>循环继续：</strong> 继续上述步骤，直到右指针 <code>right</code> 移动到数组的末尾。在整个过程中，不断更新 <code>len</code> 为找到的最短子数组的长度。</li><li><strong>返回结果：</strong> 最终返回 <code>len</code>，如果没有找到满足条件的子数组，返回 0。</li></ol> 
<p><strong>代码</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">minSubArrayLen</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> n<span class="token operator">=</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token operator">=</span>INT_MAX<span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>right<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>right<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>right<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            sum<span class="token operator">+=</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>sum<span class="token operator">&gt;=</span>target<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                len<span class="token operator">=</span><span class="token function">min</span><span class="token punctuation">(</span>len<span class="token punctuation">,</span>right<span class="token operator">-</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                sum<span class="token operator">-=</span>nums<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> len<span class="token operator">==</span>INT_MAX<span class="token operator">?</span><span class="token number">0</span><span class="token operator">:</span>len<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="02_83"></a>02.无重复字符的最长子串</h2> 
<p>题目链接：https://leetcode.cn/problems/longest-substring-without-repeating-characters/</p> 
<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p> 
<p><strong>示例 1:</strong></p> 
<pre><code>输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
</code></pre> 
<p><strong>示例 2:</strong></p> 
<pre><code>输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
</code></pre> 
<p><strong>示例 3:</strong></p> 
<pre><code>输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
</code></pre> 
<p><strong>思路</strong></p> 
<p>这里使用暴力枚举的方法是可以通过的，但是不推荐，这里我们使用滑动窗口来进行遍历，再借用一个哈希数组来记录字符出现的频次，每个字符最多出现一次，如果出现两次，那么左边一直向右滑动，直到变为1，再进行滑动时，我们更新最大长度，在使用哈希存储时，因为这里是字符，我们可以使用数组模拟哈希结构，这样可以提高效率。</p> 
<ol><li><strong>初始化：</strong> 使用两个指针 <code>left</code> 和 <code>right</code> 分别指向字符串的起始位置，并初始化一个长度为 128 的哈希表 <code>hash</code> 用于记录字符出现的次数。同时，初始化变量 <code>len</code> 用于记录当前的最长无重复字符子串的长度。</li><li><strong>窗口扩展：</strong> 在一个循环中，不断将右指针 <code>right</code> 向右移动，同时在哈希表中记录字符的出现次数。如果发现当前字符的出现次数大于 1，说明出现了重复字符。</li><li><strong>窗口收缩：</strong> 进入内层循环，将左指针 <code>left</code> 向右移动，缩小窗口大小。在这个过程中，不断减少哈希表中左指针对应字符的出现次数，直到当前窗口中没有重复字符为止。</li><li><strong>更新最长长度：</strong> 在每一步中，都更新 <code>len</code> 为当前窗口的长度 <code>right - left + 1</code> 与已经记录的最大长度的较大者。</li><li><strong>循环继续：</strong> 继续上述步骤，直到右指针 <code>right</code> 移动到字符串的末尾。</li><li><strong>返回结果：</strong> 最终返回 <code>len</code>，即最长无重复字符子串的长度。</li></ol> 
<p><strong>代码</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> hash<span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> n<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>len<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>left<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>right<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>right<span class="token operator">&lt;</span>n<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            hash<span class="token punctuation">[</span>s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>hash<span class="token punctuation">[</span>s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token number">1</span><span class="token punctuation">)</span> hash<span class="token punctuation">[</span>s<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>
            len <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>len<span class="token punctuation">,</span>right<span class="token operator">-</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            right<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> len<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="031_III_144"></a>03.最大连续1的个数 III</h2> 
<p>题目链接：https://leetcode.cn/problems/max-consecutive-ones-iii/</p> 
<p>给定一个二进制数组 <code>nums</code> 和一个整数 <code>k</code>，如果可以翻转最多 <code>k</code> 个 <code>0</code> ，则返回 <em>数组中连续 <code>1</code> 的最大个数</em> 。</p> 
<p><strong>示例 1：</strong></p> 
<pre><code>输入：nums = [1,1,1,0,0,0,1,1,1,1,0], K = 2
输出：6
解释：[1,1,1,0,0,1,1,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 6。
</code></pre> 
<p><strong>示例 2：</strong></p> 
<pre><code>输入：nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3
输出：10
解释：[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 10。
</code></pre> 
<p><strong>思路</strong></p> 
<p>这里我们首先不要被题目误导，题目让我们翻转0，我们也不用真的翻转，我们可以利用滑动窗口的思想，在窗口内最大容纳k个0，超过就出窗口，直到又是k个0，再继续入窗口，每次更新最大长度即可。</p> 
<ol><li><strong>初始化：</strong> 使用两个指针 <code>left</code> 和 <code>right</code> 分别指向数组的起始位置，并初始化变量 <code>zero</code> 用于记录当前窗口中 0 的个数。同时，初始化变量 <code>len</code> 用于记录当前的最大长度。</li><li><strong>窗口扩展：</strong> 在一个循环中，不断将右指针 <code>right</code> 向右移动。如果当前元素为 0，将 <code>zero</code> 增加 1。</li><li><strong>窗口收缩：</strong> 进入内层循环，如果窗口中的 0 的个数大于 <code>k</code>，说明需要缩小窗口，将左指针 <code>left</code> 向右移动，减少窗口中 0 的个数。在这个过程中，如果左指针指向的元素是 0，则将 <code>zero</code> 减少 1。</li><li><strong>更新最大长度：</strong> 在每一步中，都更新 <code>len</code> 为当前窗口的长度 <code>right - left + 1</code> 与已经记录的最大长度的较大者。</li><li><strong>循环继续：</strong> 继续上述步骤，直到右指针 <code>right</code> 移动到数组的末尾。</li><li><strong>返回结果：</strong> 最终返回 <code>len</code>，即包含最多 <code>k</code> 个 0 的连续子数组的最大长度。</li></ol> 
<p><strong>代码</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">longestOnes</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> n<span class="token operator">=</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>zero<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>right<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>right<span class="token operator">&lt;</span>n<span class="token punctuation">;</span><span class="token operator">++</span>right<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> zero<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>zero<span class="token operator">&gt;</span>k<span class="token punctuation">)</span> 
                <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> zero<span class="token operator">--</span><span class="token punctuation">;</span>
            len<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>len<span class="token punctuation">,</span>right<span class="token operator">-</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> len<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="04_x__0__197"></a>04.将 x 减到 0 的最小操作数</h2> 
<p>题目链接：https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/</p> 
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>x</code> 。每一次操作时，你应当移除数组 <code>nums</code> 最左边或最右边的元素，然后从 <code>x</code> 中减去该元素的值。请注意，需要 <strong>修改</strong> 数组以供接下来的操作使用。</p> 
<p>如果可以将 <code>x</code> <strong>恰好</strong> 减到 <code>0</code> ，返回 <strong>最小操作数</strong> ；否则，返回 <code>-1</code> 。</p> 
<p><strong>示例 1：</strong></p> 
<pre><code>输入：nums = [1,1,4,2,3], x = 5
输出：2
解释：最佳解决方案是移除后两个元素，将 x 减到 0 。
</code></pre> 
<p><strong>示例 2：</strong></p> 
<pre><code>输入：nums = [5,6,7,8,9], x = 4
输出：-1
</code></pre> 
<p><strong>示例 3：</strong></p> 
<pre><code>输入：nums = [3,2,20,1,1,3], x = 10
输出：5
解释：最佳解决方案是移除后三个元素和前两个元素（总共 5 次操作），将 x 减到 0 。
</code></pre> 
<p><strong>思路</strong></p> 
<p>首先我们看到这道题，可能并不容易想到用滑动窗口来解，可能有很多人开始会想到双指针，但是，那样要处理的细节太多，不容易通过，其实这里我们可以将问题转化，从左右两边减去最少的操作数来达到要求，我们可以转换成将数组总和减去X，在中间找到最长的子数组之和等于这个数，再将原数组长度与子数组长度相减便可以求出最小操作数，这样是不是就更简单了呢？</p> 
<ol><li><strong>计算总和：</strong> 遍历数组，计算数组中所有元素的和，并保存在变量 <code>sum</code> 中。</li><li><strong>计算目标差值：</strong> 计算目标差值 <code>t</code>，即 <code>t = sum - x</code>。</li><li><strong>滑动窗口求解：</strong> 使用滑动窗口的思想，在一个循环中，不断将右指针 <code>right</code> 向右移动，累加元素的值到 <code>tmp</code> 中。同时，在内层循环中，如果 <code>tmp</code> 大于目标差值 <code>t</code>，将左指针 <code>left</code> 向右移动，减少窗口的和。在每一步中，检查当前窗口的和是否等于目标差值 <code>t</code>。</li><li><strong>更新最大窗口长度：</strong> 在每一步中，如果当前窗口的和等于目标差值 <code>t</code>，则更新 <code>ret</code> 为当前窗口的长度 <code>right - left + 1</code> 和已经记录的最大长度的较大者。</li><li><strong>计算结果：</strong> 最终返回操作数，即数组长度减去最大窗口长度。如果 <code>ret</code> 仍然为初始值 -1，则说明无法找到符合条件的子数组，返回 -1。</li></ol> 
<p><strong>代码</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">minOperations</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> n<span class="token operator">=</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>ret<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> sum<span class="token operator">+=</span>num<span class="token punctuation">;</span>
        <span class="token keyword">int</span> t<span class="token operator">=</span>sum<span class="token operator">-</span>x<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>right<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>tmp<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>right<span class="token operator">&lt;</span>n<span class="token punctuation">;</span><span class="token operator">++</span>right<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            tmp<span class="token operator">+=</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>tmp<span class="token operator">&gt;</span>t<span class="token punctuation">)</span> tmp<span class="token operator">-=</span>nums<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>tmp<span class="token operator">==</span>t<span class="token punctuation">)</span> ret<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span>right<span class="token operator">-</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">return</span> n<span class="token operator">-</span>ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="05_265"></a>05.水果成篮</h2> 
<p>题目链接：https://leetcode.cn/problems/fruit-into-baskets/</p> 
<p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 <code>fruits</code> 表示，其中 <code>fruits[i]</code> 是第 <code>i</code> 棵树上的水果 <strong>种类</strong> 。</p> 
<p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p> 
<ul><li>你只有 <strong>两个</strong> 篮子，并且每个篮子只能装 <strong>单一类型</strong> 的水果。每个篮子能够装的水果总量没有限制。</li><li>你可以选择任意一棵树开始采摘，你必须从 <strong>每棵</strong> 树（包括开始采摘的树）上 <strong>恰好摘一个水果</strong> 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。</li><li>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</li></ul> 
<p>给你一个整数数组 <code>fruits</code> ，返回你可以收集的水果的 <strong>最大</strong> 数目。</p> 
<p><strong>示例 1：</strong></p> 
<pre><code>输入：fruits = [1,2,1]
输出：3
解释：可以采摘全部 3 棵树。
</code></pre> 
<p><strong>示例 2：</strong></p> 
<pre><code>输入：fruits = [0,1,2,2]
输出：3
解释：可以采摘 [1,2,2] 这三棵树。
如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。
</code></pre> 
<p><strong>示例 3：</strong></p> 
<pre><code>输入：fruits = [1,2,3,2,2]
输出：4
解释：可以采摘 [2,3,2,2] 这四棵树。
如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。
</code></pre> 
<p><strong>示例 4：</strong></p> 
<pre><code>输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]
输出：5
解释：可以采摘 [1,2,1,1,2] 这五棵树。
</code></pre> 
<p><strong>思路</strong></p> 
<p>首先我们这里同样可以采取滑动窗口的方式进出窗口，同时更新最大长度即可，这里需要借助哈希容器来记录水果的种类，当然，我们也可以直接用数组来模拟哈希，这样可以提高效率，这里题目告诉我们最大长度是<code>10^5</code>，因此我们可以建立一个100001大小的数组来模拟哈希。</p> 
<ol><li><strong>初始化：</strong> 使用两个指针 <code>left</code> 和 <code>right</code> 分别指向数组的起始位置，并初始化一个数组 <code>hash</code> 用于记录水果的出现次数。同时，初始化变量 <code>ret</code> 用于记录最大长度，以及变量 <code>kind</code> 用于记录当前窗口中不同水果的种类数。</li><li><strong>滑动窗口求解：</strong> 在一个循环中，不断将右指针 <code>right</code> 向右移动。如果当前水果是一种新的水果（即 <code>hash[fruits[right]] == 0</code>），则将 <code>kind</code> 增加 1。在哈希表中记录当前水果的出现次数。</li><li><strong>窗口收缩：</strong> 如果当前窗口中不同水果的种类数 <code>kind</code> 大于 2，说明窗口中包含了超过两种不同水果。进入内层循环，将左指针 <code>left</code> 向右移动，减小窗口的大小。在这个过程中，不断减少哈希表中左指针指向的水果的出现次数，并更新 <code>kind</code>。</li><li><strong>更新最大长度：</strong> 在每一步中，都更新 <code>ret</code> 为当前窗口的长度 <code>right - left + 1</code> 与已经记录的最大长度的较大者。</li><li><strong>循环继续：</strong> 继续上述步骤，直到右指针 <code>right</code> 移动到数组的末尾。</li><li><strong>返回结果：</strong> 最终返回 <code>ret</code>，即包含最多两种不同水果的连续子数组的最大长度。</li></ol> 
<p><strong>代码</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">totalFruit</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> fruits<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> hash<span class="token punctuation">[</span><span class="token number">100001</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span> ret<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>kind<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>n<span class="token operator">=</span>fruits<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>right<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>right<span class="token operator">&lt;</span>n<span class="token punctuation">;</span><span class="token operator">++</span>right<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>hash<span class="token punctuation">[</span>fruits<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> kind<span class="token operator">++</span><span class="token punctuation">;</span>
            hash<span class="token punctuation">[</span>fruits<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>

            <span class="token keyword">if</span><span class="token punctuation">(</span>kind<span class="token operator">&gt;</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                hash<span class="token punctuation">[</span>fruits<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>hash<span class="token punctuation">[</span>fruits<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> kind<span class="token operator">--</span><span class="token punctuation">;</span>
                left<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            ret<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span>right<span class="token operator">-</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="06_352"></a>06.找到字符串中所有字母异位词</h2> 
<p>题目链接：https://leetcode.cn/problems/find-all-anagrams-in-a-string/</p> 
<p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p> 
<p><strong>异位词</strong> 指由相同字母重排列形成的字符串（包括相同的字符串）。</p> 
<p><strong>示例 1:</strong></p> 
<pre><code>输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
</code></pre> 
<p><strong>示例 2:</strong></p> 
<pre><code>输入: s = "abab", p = "ab"
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。
</code></pre> 
<p><strong>思路</strong></p> 
<p>这里我们可以借助两个哈希表，先存储p字符串的各字母个数，再使用另一个哈希表，进行长度为p字符串长度的固定滑动窗口对s字符串进行遍历，合法字符进窗口计数++，合法字符出窗口计数–，只有计数与p字符串长度相等时，存储窗口左下标，最后返回存储数组</p> 
<p><strong>代码</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">findAnagrams</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> string p<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ret<span class="token punctuation">;</span>
        <span class="token keyword">int</span> hash1<span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> hash2<span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> c<span class="token operator">:</span>p<span class="token punctuation">)</span> hash1<span class="token punctuation">[</span>c<span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span> n<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>m<span class="token operator">=</span>p<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>right<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>right<span class="token operator">&lt;</span>n<span class="token punctuation">;</span><span class="token operator">++</span>right<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">char</span> c1<span class="token operator">=</span>s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">++</span>hash2<span class="token punctuation">[</span>c1<span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token operator">&lt;=</span>hash1<span class="token punctuation">[</span>c1<span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> count<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&gt;</span>m<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">char</span> c2<span class="token operator">=</span>s<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>hash2<span class="token punctuation">[</span>c2<span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token operator">&lt;=</span>hash1<span class="token punctuation">[</span>c2<span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> count<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">==</span>m<span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="07_412"></a>07.串联所有单词的子串</h2> 
<p>题目链接：https://leetcode.cn/problems/substring-with-concatenation-of-all-words/</p> 
<p>给定一个字符串 <code>s</code> 和一个字符串数组 <code>words</code><strong>。</strong> <code>words</code> 中所有字符串 <strong>长度相同</strong>。</p> 
<p><code>s</code> 中的 <strong>串联子串</strong> 是指一个包含 <code>words</code> 中所有字符串以任意顺序排列连接起来的子串。</p> 
<ul><li>例如，如果 <code>words = ["ab","cd","ef"]</code>， 那么 <code>"abcdef"</code>， <code>"abefcd"</code>，<code>"cdabef"</code>， <code>"cdefab"</code>，<code>"efabcd"</code>， 和 <code>"efcdab"</code> 都是串联子串。 <code>"acdbef"</code> 不是串联子串，因为他不是任何 <code>words</code> 排列的连接。</li></ul> 
<p>返回所有串联子串在 <code>s</code> 中的开始索引。你可以以 <strong>任意顺序</strong> 返回答案。</p> 
<p><strong>示例 1：</strong></p> 
<pre><code>输入：s = "barfoothefoobarman", words = ["foo","bar"]
输出：[0,9]
解释：因为 words.length == 2 同时 words[i].length == 3，连接的子字符串的长度必须为 6。
子串 "barfoo" 开始位置是 0。它是 words 中以 ["bar","foo"] 顺序排列的连接。
子串 "foobar" 开始位置是 9。它是 words 中以 ["foo","bar"] 顺序排列的连接。
输出顺序无关紧要。返回 [9,0] 也是可以的。
</code></pre> 
<p><strong>示例 2：</strong></p> 
<pre><code>输入：s = "wordgoodgoodgoodbestword", words = ["word","good","best","word"]
输出：[]
解释：因为 words.length == 4 并且 words[i].length == 4，所以串联子串的长度必须为 16。
s 中没有子串长度为 16 并且等于 words 的任何顺序排列的连接。
所以我们返回一个空数组。
</code></pre> 
<p><strong>示例 3：</strong></p> 
<pre><code>输入：s = "barfoofoobarthefoobarman", words = ["bar","foo","the"]
输出：[6,9,12]
解释：因为 words.length == 3 并且 words[i].length == 3，所以串联子串的长度必须为 9。
子串 "foobarthe" 开始位置是 6。它是 words 中以 ["foo","bar","the"] 顺序排列的连接。
子串 "barthefoo" 开始位置是 9。它是 words 中以 ["bar","the","foo"] 顺序排列的连接。
子串 "thefoobar" 开始位置是 12。它是 words 中以 ["the","foo","bar"] 顺序排列的连接。
</code></pre> 
<p><strong>思路</strong></p> 
<p>其实这里问题和上面的问题相同，只不过将字符变成了字符串，根据题目条件每个组合字符串都是相等长度，所以我们的计数条件也可以比较明确，就是一个字串的长度与所有子串之积，而且我们要保证不能有遗漏的情况，所以我们要从不同的起始点开始遍历单个字串长度次，还需要注意的一点就是这里是字符串，所以我们不能使用数组来模拟哈希，这里就需使用容器，其它的和上面的算法并无二异，都是使用滑动窗口的方式。</p> 
<ol><li><strong>初始化：</strong> 使用一个哈希表 <code>hash1</code> 记录单词列表 <code>words</code> 中每个单词的出现次数。</li><li><strong>遍历起始位置：</strong> 对于每个可能的起始位置 <code>i</code>，其中 <code>i</code> 的范围是 <code>[0, len - 1]</code>，其中 <code>len</code> 是单词长度。这是为了确保能够覆盖到所有可能的子串。</li><li><strong>滑动窗口求解：</strong> 在一个循环中，不断将右指针 <code>right</code> 向右移动，每次移动一个单词的长度 <code>len</code>。在每一步中，截取字符串 <code>str1</code>，表示当前窗口的单词。然后，更新哈希表 <code>hash2</code>，表示当前窗口内各单词的出现次数。</li><li><strong>检查匹配：</strong> 在每一步中，检查截取的字符串 <code>str1</code> 是否在哈希表 <code>hash1</code> 中出现，并且当前窗口内该单词的出现次数不超过 <code>hash1</code> 中的次数。如果是，则将 <code>count</code> 增加 1。这里和下面的count–，先检查是一个提升效率的方式，不写也不影响代码运行，主要原因是如果<code>hash1</code>中没有这个键，它就会直接插入，这对性能的消耗可能很大。</li><li><strong>窗口收缩：</strong> 如果当前窗口的长度超过了需要的总长度 <code>len * m</code>，则需要收缩窗口。将左指针 <code>left</code> 向右移动，每次移动一个单词的长度 <code>len</code>。在每一步中，截取字符串 <code>str2</code>，表示当前窗口收缩的单词。然后，检查截取的字符串 <code>str2</code> 是否在哈希表 <code>hash1</code> 中出现，并且当前窗口内该单词的出现次数不超过 <code>hash1</code> 中的次数。如果是，则将 <code>count</code> 减少 1。</li><li><strong>更新结果：</strong> 在每一步中，如果 <code>count</code> 等于单词列表 <code>words</code> 的长度 <code>m</code>，说明当前窗口中包含了所有的单词，将左指针的位置加入结果数组 <code>ret</code>。</li><li><strong>循环继续：</strong> 继续上述步骤，直到右指针 <code>right</code> 移动到字符串 <code>s</code> 的末尾。</li><li><strong>返回结果：</strong> 最终返回结果数组 <code>ret</code>。</li></ol> 
<p><strong>代码</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">findSubstring</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token operator">&amp;</span> words<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ret<span class="token punctuation">;</span>
        unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">&gt;</span> hash1<span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> str<span class="token operator">:</span>words<span class="token punctuation">)</span> hash1<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span> n<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>m<span class="token operator">=</span>words<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>len<span class="token operator">=</span>words<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">&gt;</span> hash2<span class="token punctuation">;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token operator">=</span>i<span class="token punctuation">,</span>right<span class="token operator">=</span>i<span class="token punctuation">,</span>count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>right<span class="token operator">+</span>len<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>right<span class="token operator">+=</span>len<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                string str1<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>right<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
                hash2<span class="token punctuation">[</span>str1<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>hash1<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>hash2<span class="token punctuation">[</span>str1<span class="token punctuation">]</span><span class="token operator">&lt;=</span>hash1<span class="token punctuation">[</span>str1<span class="token punctuation">]</span><span class="token punctuation">)</span> count<span class="token operator">++</span><span class="token punctuation">;</span>

                <span class="token keyword">if</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&gt;</span>len<span class="token operator">*</span>m<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    string str2<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span><span class="token punctuation">(</span>hash1<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>hash2<span class="token punctuation">[</span>str2<span class="token punctuation">]</span><span class="token operator">&lt;=</span>hash1<span class="token punctuation">[</span>str2<span class="token punctuation">]</span><span class="token punctuation">)</span> count<span class="token operator">--</span><span class="token punctuation">;</span>
                    hash2<span class="token punctuation">[</span>str2<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>
                    left<span class="token operator">+=</span>len<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

                <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">==</span>m<span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="08_502"></a>08.最小覆盖子串</h2> 
<p>题目链接：https://leetcode.cn/problems/minimum-window-substring/</p> 
<p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>""</code> 。</p> 
<p><strong>注意：</strong></p> 
<ul><li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li><li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li></ul> 
<p><strong>示例 1：</strong></p> 
<pre><code>输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。
</code></pre> 
<p><strong>示例 2：</strong></p> 
<pre><code>输入：s = "a", t = "a"
输出："a"
解释：整个字符串 s 是最小覆盖子串。
</code></pre> 
<p><strong>示例 3:</strong></p> 
<pre><code>输入: s = "a", t = "aa"
输出: ""
解释: t 中两个字符 'a' 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。
</code></pre> 
<p><strong>思路</strong></p> 
<p>这里和前面两题类似，还是使用滑动窗口加哈希的方式来解决，只不过这里可以有重复字符，因此我们在计数时只要有一个，就不再计数，出窗口也一样，当计数和记录的种类相同时，我们更新起始位置和最小长度，最后返回字串即可。</p> 
<ol><li><strong>初始化：</strong> 使用两个数组 <code>hash1</code> 和 <code>hash2</code> 分别记录字符串 <code>t</code> 中字符的出现次数和当前窗口中字符的出现次数。同时，使用变量 <code>kind</code> 记录不同字符的种类数。</li><li><strong>统计字符串 <code>t</code> 中字符次数：</strong> 遍历字符串 <code>t</code>，更新数组 <code>hash1</code> 中对应字符的出现次数，并更新 <code>kind</code>。</li><li><strong>滑动窗口求解：</strong> 在一个循环中，不断将右指针 <code>right</code> 向右移动。在每一步中，截取字符串 <code>c1</code> 表示当前窗口的右端字符。然后，更新数组 <code>hash2</code> 中右指针指向字符的出现次数，并根据当前窗口中字符的出现次数与字符串 <code>t</code> 中相应字符的出现次数比较，更新 <code>count</code>。</li><li><strong>检查匹配：</strong> 在每一步中，如果 <code>count</code> 等于 <code>kind</code>，说明当前窗口中包含了字符串 <code>t</code> 中的所有字符。进入内层循环，更新最小窗口的长度和起始位置。将左指针 <code>left</code> 向右移动，减小窗口的大小。在这个过程中，不断减少数组 <code>hash2</code> 中左指针指向字符的出现次数，并根据当前窗口中字符的出现次数与字符串 <code>t</code> 中相应字符的出现次数比较，更新 <code>count</code>。</li><li><strong>更新结果：</strong> 在每一步中，如果找到更小的窗口，则更新 <code>minl</code> 和 <code>begin</code>。</li><li><strong>循环继续：</strong> 继续上述步骤，直到右指针 <code>right</code> 移动到字符串 <code>s</code> 的末尾。</li><li><strong>返回结果：</strong> 最终返回最小窗口子串，如果没有找到则返回空字符串。</li></ol> 
<p><strong>代码</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    string <span class="token function">minWindow</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> string t<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> hash1<span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> hash2<span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> kind<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> ch<span class="token operator">:</span>t<span class="token punctuation">)</span> 
            <span class="token keyword">if</span><span class="token punctuation">(</span>hash1<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token operator">++</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> kind<span class="token operator">++</span><span class="token punctuation">;</span>
        
        <span class="token keyword">int</span> begin<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>minl<span class="token operator">=</span>INT_MAX<span class="token punctuation">,</span>n<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>right<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>right<span class="token operator">&lt;</span>n<span class="token punctuation">;</span><span class="token operator">++</span>right<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">char</span> c1<span class="token operator">=</span>s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">++</span>hash2<span class="token punctuation">[</span>c1<span class="token punctuation">]</span><span class="token operator">==</span>hash1<span class="token punctuation">[</span>c1<span class="token punctuation">]</span><span class="token punctuation">)</span> count<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>count<span class="token operator">==</span>kind<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>minl<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    minl<span class="token operator">=</span>right<span class="token operator">-</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
                    begin<span class="token operator">=</span>left<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">char</span> c2<span class="token operator">=</span>s<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>hash2<span class="token punctuation">[</span>c2<span class="token punctuation">]</span><span class="token operator">--</span><span class="token operator">==</span>hash1<span class="token punctuation">[</span>c2<span class="token punctuation">]</span><span class="token punctuation">)</span> count<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span>begin<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span>minl<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8dbe783551b2af69856821fa4194624e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">win11设置mysql开机自启</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9daa09a338affa15ac18e05169eda4a0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Mac下查看、配置和使用环境变量</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>