<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>DFS：解决二叉树问题 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/df03b31d26d6b20aa449274b63acb56c/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="DFS：解决二叉树问题">
  <meta property="og:description" content="文章目录 了解DFS1.计算布尔二叉树的值思路代码展示 2.求根节点到叶节点数字之和思路代码展示 3.二叉树剪枝思路代码展示 4.验证二叉搜索树思路分析代码展示 5.二叉搜索树中第k小元素思路：代码展示 6.二叉树的所有路径思路分析代码展示 总结 了解DFS 所谓DFS就是就是深度优先搜索，首先我们回到我们以前学习过的二叉树，对于二叉树我们讲过深度优先遍历，也就前序，后序，中序，这三种遍历方式，对于深度优先搜索，深度优先遍历是一个过程，在这个过程中我们加上搜索。
在一颗二叉树上，对于遍历来说，我们会一条路走到黑，直到走到空的节点为止，才会返回上一个节点，走另一个分支，但是对于DFS（深度优先搜索）来说，我们的目的是、搜索当中的值，而不是一味地遍历。
接下来我们通过几道题来深入理解这个算法
1.计算布尔二叉树的值 首先我们来理解题意，题意很简单就是在一颗二叉树中只有0，1，2，3这几个值，他们分别代表的是false true || &amp;&amp;，我们来看看实际的一颗树：
右边这颗二叉树就可以投影成左边这颗树的样子。
接下来我们来分析一下这个道题应该怎么做：
思路 首先这道题说了这颗树是完整的二叉树，意思就是所有节点要么一个节点都没有，要么就是有两个节点。我们再来看这颗树的特征：非叶子节点肯定是2或者3，叶子节点肯定是1或者0，所以这里划分就出来了，我们对叶子节点和非叶子节点做不同的处理，如果是叶子节点就直接返回当前节点的值，如果不是叶子节点就判断一下该节点的值，如果是2就对左子树和右子树进行||操作，反之则进行&amp;&amp;操作即可。
函数头
函数头：bool dfs(root)
函数体
遇到叶子节点返回叶子节点的值，遇到非叶子节点，对左子树和右子树进行递归操作。
递归出口
就是返回叶子节点的值
代码展示 class Solution { public: bool evaluateTree(TreeNode* root) { //只用判断一边就可以 if(root-&gt;right==nullptr) { //叶子节点直接返回值 return root-&gt;val; } //得到左子树的结果 bool left=evaluateTree(root-&gt;left); //得到右子树的结果 bool right=evaluateTree(root-&gt;right); //判断一下当前节点的值是2还是3，进行&amp;&amp;操作还是||操作 return root-&gt;val==2?left||right:left&amp;&amp;right; } }; 2.求根节点到叶节点数字之和 题目解释：
首先我们先给出一棵树
对于这棵树并不是说所有节点的和就是把所有节点的值加起来，而是，我们先看第一个路径，4--9--5对于这个路径来说，这个路径下对应的和就是495，第二个路对应的是491，第三个路径对应的是40.
从下面图应该可以看出：
思路 对于这道题，我们先来走一遍，当我们进入根节点4的时候，我们先递归左子树，我们肯定必须要知道前面的和是多少，因为我们要计算下一个节点的和，所以必须知道前面节点的和是多少，所以这里我们传递的参数就多了一个presum（前驱和）
函数头
函数头：int dfs(root,presum)
因为这道题要求返回所有路径的和，所以有一个返回值就是int
函数体
这里我们来想一下函数体是什么？
我们把presum传进行，当进入根节点的时候肯定不能带值，因为根节点的前驱和是0，所以这里我们传参的话，传presum进去先是0，进了函数之后我们先更新一下这个 presum，presum=presum*10&#43;root-&gt;val,更新了presum之后，判断一下这个节点是否是叶子节点，如果是叶子节点直接返回presum，因为如果是叶子节点的话就说明这个路径的和已经求完了，只需要求下一个路径的和就可以了，这里我们用一个ret来存放一下左子树和右子树的和，如果左子树不为空，则返回将左子树的和加在ret上，如果右子树不为空，则再将右子树的和加在ret上，最后返回ret。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-23T14:36:00+08:00">
    <meta property="article:modified_time" content="2024-05-23T14:36:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">DFS：解决二叉树问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#DFS_3" rel="nofollow">了解DFS</a></li><li><a href="#1_8" rel="nofollow">1.计算布尔二叉树的值</a></li><li><ul><li><a href="#_16" rel="nofollow">思路</a></li><li><a href="#_25" rel="nofollow">代码展示</a></li></ul> 
  </li><li><a href="#2_46" rel="nofollow">2.求根节点到叶节点数字之和</a></li><li><ul><li><a href="#_55" rel="nofollow">思路</a></li><li><a href="#_66" rel="nofollow">代码展示</a></li></ul> 
  </li><li><a href="#3_100" rel="nofollow">3.二叉树剪枝</a></li><li><ul><li><a href="#_107" rel="nofollow">思路</a></li><li><a href="#_117" rel="nofollow">代码展示</a></li></ul> 
  </li><li><a href="#4_146" rel="nofollow">4.验证二叉搜索树</a></li><li><ul><li><a href="#_150" rel="nofollow">思路分析</a></li><li><a href="#_160" rel="nofollow">代码展示</a></li></ul> 
  </li><li><a href="#5k_195" rel="nofollow">5.二叉搜索树中第k小元素</a></li><li><ul><li><a href="#_200" rel="nofollow">思路：</a></li><li><a href="#_207" rel="nofollow">代码展示</a></li></ul> 
  </li><li><a href="#6_235" rel="nofollow">6.二叉树的所有路径</a></li><li><ul><li><a href="#_241" rel="nofollow">思路分析</a></li><li><a href="#_254" rel="nofollow">代码展示</a></li></ul> 
  </li><li><a href="#_288" rel="nofollow">总结</a></li></ul> 
</div> 
<p></p> 
<h2><a id="DFS_3"></a>了解DFS</h2> 
<p>所谓DFS就是就是深度优先搜索，首先我们回到我们以前学习过的二叉树，对于二叉树我们讲过深度优先遍历，也就前序，后序，中序，这三种遍历方式，对于深度优先搜索，深度优先遍历是一个过程，在这个过程中我们加上搜索。<br> 在一颗二叉树上，对于遍历来说，我们会一条路走到黑，直到走到空的节点为止，才会返回上一个节点，走另一个分支，但是对于DFS（深度优先搜索）来说，我们的目的是、搜索当中的值，而不是一味地遍历。<br> 接下来我们通过几道题来深入理解这个算法</p> 
<h2><a id="1_8"></a>1.计算布尔二叉树的值</h2> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/09/a1/ZpAJmhrD_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>首先我们来理解题意，题意很简单就是在一颗二叉树中只有<code>0，1，2，3</code>这几个值，他们分别代表的是<code>false true || &amp;&amp;</code>，我们来看看实际的一颗树：<br> <img src="https://images2.imgbox.com/f3/1e/45uDeHfm_o.png" alt="在这里插入图片描述"><br> 右边这颗二叉树就可以投影成左边这颗树的样子。</p> 
<p>接下来我们来分析一下这个道题应该怎么做：</p> 
<h3><a id="_16"></a>思路</h3> 
<p>首先这道题说了这颗树是完整的二叉树，意思就是所有节点要么一个节点都没有，要么就是有两个节点。我们再来看这颗树的特征：非叶子节点肯定是2或者3，叶子节点肯定是1或者0，所以这里划分就出来了，我们对叶子节点和非叶子节点做不同的处理，如果是叶子节点就直接返回当前节点的值，如果不是叶子节点就判断一下该节点的值，如果是2就对左子树和右子树进行||操作，反之则进行&amp;&amp;操作即可。</p> 
<p><strong>函数头</strong><br> 函数头：<code>bool dfs(root)</code><br> <strong>函数体</strong><br> 遇到叶子节点返回叶子节点的值，遇到非叶子节点，对左子树和右子树进行递归操作。<br> <strong>递归出口</strong><br> 就是返回叶子节点的值</p> 
<h3><a id="_25"></a>代码展示</h3> 
<pre><code class="prism language-c">class Solution <span class="token punctuation">{<!-- --></span>
public<span class="token operator">:</span>
    bool <span class="token function">evaluateTree</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    	<span class="token comment">//只用判断一边就可以</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token operator">==</span>nullptr<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
        	<span class="token comment">//叶子节点直接返回值</span>
            <span class="token keyword">return</span> root<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//得到左子树的结果</span>
        bool left<span class="token operator">=</span><span class="token function">evaluateTree</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//得到右子树的结果</span>
        bool right<span class="token operator">=</span><span class="token function">evaluateTree</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//判断一下当前节点的值是2还是3，进行&amp;&amp;操作还是||操作</span>
        <span class="token keyword">return</span> root<span class="token operator">-&gt;</span>val<span class="token operator">==</span><span class="token number">2</span><span class="token operator">?</span>left<span class="token operator">||</span>right<span class="token operator">:</span>left<span class="token operator">&amp;&amp;</span>right<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="2_46"></a>2.求根节点到叶节点数字之和</h2> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/e4/8c/PA91FTlL_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>题目解释：<br> 首先我们先给出一棵树<br> <img src="https://images2.imgbox.com/5d/21/Ar67KcZw_o.png" alt="在这里插入图片描述"><br> 对于这棵树并不是说所有节点的和就是把所有节点的值加起来，而是，我们先看第一个路径，<code>4--9--5</code>对于这个路径来说，这个路径下对应的和就是495，第二个路对应的是491，第三个路径对应的是40.<br> 从下面图应该可以看出：<br> <img src="https://images2.imgbox.com/8e/a2/vKtzY9P4_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_55"></a>思路</h3> 
<p>对于这道题，我们先来走一遍，当我们进入根节点4的时候，我们先递归左子树，我们肯定必须要知道前面的和是多少，因为我们要计算下一个节点的和，所以必须知道前面节点的和是多少，所以这里我们传递的参数就多了一个presum（前驱和）</p> 
<p><strong>函数头</strong><br> 函数头：<code>int dfs(root,presum)</code><br> 因为这道题要求返回所有路径的和，所以有一个返回值就是int</p> 
<p><strong>函数体</strong><br> 这里我们来想一下函数体是什么？<br> 我们把presum传进行，当进入根节点的时候肯定不能带值，因为根节点的前驱和是0，所以这里我们传参的话，传presum进去先是0，进了函数之后我们先更新一下这个 presum，<code>presum=presum*10+root-&gt;val</code>,更新了presum之后，判断一下这个节点是否是叶子节点，如果是叶子节点直接返回presum，因为如果是叶子节点的话就说明这个路径的和已经求完了，只需要求下一个路径的和就可以了，这里我们用一个ret来存放一下左子树和右子树的和，如果左子树不为空，则返回将左子树的和加在ret上，如果右子树不为空，则再将右子树的和加在ret上，最后返回ret。</p> 
<h3><a id="_66"></a>代码展示</h3> 
<pre><code class="prism language-c">class Solution <span class="token punctuation">{<!-- --></span>
public<span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span>root<span class="token punctuation">,</span><span class="token keyword">int</span> presum<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//先将前驱和加上个</span>
        presum<span class="token operator">=</span>presum<span class="token operator">*</span><span class="token number">10</span><span class="token operator">+</span>root<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span>
        <span class="token comment">//如果是末尾节点的话，直接返回前驱和</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token operator">==</span>nullptr<span class="token operator">&amp;&amp;</span>root<span class="token operator">-&gt;</span>right<span class="token operator">==</span>nullptr<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> presum<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">int</span> ret<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment">//如果左节点不为空的话直接ret叠加上左节点的dfs</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token operator">!=</span>nullptr<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            ret<span class="token operator">+=</span><span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span>presum<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//如果右节点不为空的话只额吉ret叠加右节点的dfs</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token operator">!=</span>nullptr<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            ret<span class="token operator">+=</span><span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span>presum<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//返回两边树的总和</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> <span class="token function">sumNumbers</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

        <span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//刚传递进去的时候前驱和是0</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="3_100"></a>3.二叉树剪枝</h2> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/88/50/Aoyg1pY3_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>首先我们来看看下面一颗二叉树，注意这颗二叉树上只有1或者0.<br> <img src="https://images2.imgbox.com/9f/91/sD3JhL7O_o.png" alt="在这里插入图片描述"><br> 根据题目的意思，就是将只含有0的子树删除，对于上面这颗二叉树来说，只含有0的子树，首先我们看左子树，左子树全是零，直接删除，再看右子树，右子树的第一个节点是1，不满足，不能删除，右子树的左子树的节点，只有0，直接删除，右子树右子树只有1，不能删除，所以删除之后的二叉树就变成了下面的样子：<br> <img src="https://images2.imgbox.com/0f/b0/3x0mxrPY_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_107"></a>思路</h3> 
<p>对于这道题，我们要删除节点的话，肯定要知道左子树和右子树的信息，才能删除这个节点，由于这个特殊的性质，我们首先想到的则是后序遍历，因为只有后序遍历，才能将左子树和右子树的信息传递给节点，确定了该如何遍历之后，我们来讨论应该如何删除节点，首先我们肯定不能从非叶子节点开始删，因为我们根本不知道他的左子树和右子树的信息，所以应该从叶子节点开始删，所以这里删除的标志就是判断叶子节点的值是否为0，如果为0，则返回nullptr，证明将这个节点删除了，nullptr就是将删除的信息带给非叶子节点，如果叶子节点不是0，则返回当前节点，如果返回的是非空节点这个信息的话，就表示它的子树不是0，</p> 
<p><strong>函数头</strong><br> 函数头：<code>dfs(root)</code><br> <strong>函数体</strong><br> 就是上面所讲的<br> <strong>递归出口</strong><br> 当遇到空节点的时候，直接返回空节点。</p> 
<h3><a id="_117"></a>代码展示</h3> 
<pre><code class="prism language-c">class Solution <span class="token punctuation">{<!-- --></span>
public<span class="token operator">:</span>
    TreeNode<span class="token operator">*</span> <span class="token function">pruneTree</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//空节点直接返回</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span>nullptr<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> nullptr<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//递归左子树</span>
        root<span class="token operator">-&gt;</span>left<span class="token operator">=</span><span class="token function">pruneTree</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//递归右子树</span>
        root<span class="token operator">-&gt;</span>right<span class="token operator">=</span><span class="token function">pruneTree</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//判断叶子节点的值</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token operator">==</span>nullptr<span class="token operator">&amp;&amp;</span>root<span class="token operator">-&gt;</span>right<span class="token operator">==</span>nullptr<span class="token operator">&amp;&amp;</span>root<span class="token operator">-&gt;</span>val<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//delete root防止内存泄露</span>
            <span class="token keyword">return</span> nullptr<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//如果是1，则不删除</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> root<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="4_146"></a>4.验证二叉搜索树</h2> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/1d/58/rXQbkpdr_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>题目很简单，就是验证一棵树是否是二叉搜索树，如果是，则直接返回true，如果不是则返回false</p> 
<h3><a id="_150"></a>思路分析</h3> 
<p>首先我们要知道一个二叉搜索树的一个很重要的性质，就是它的中序遍历是一个有序序列，这是一个这道题重要的突破口，我们只需要记录它中序遍历的前驱的节点，然后与当前节点进行比较即可，如果比当前节点大则当前情况来看的话是二叉搜索树，如果不满足的话，直接返回false，根本不需要进行判断了。注意，当返回结果的时候，我们要求左子树和右子树都满足还有根节点都满足二叉搜索树，才是二叉搜索树，否则不是二叉搜索树</p> 
<p><strong>函数头</strong><br> 函数头：<code>dfs(root)</code><br> <strong>函数体</strong><br> 在定义函数体的时候，我们最好将prev(前驱）定义为全局变量，因为全局变量，随着地递归不会改变，我们只能手动改变<br> <strong>递归出口</strong><br> 当递归到空节点的时候，直接返回true，因为空节点就是二叉搜索树</p> 
<h3><a id="_160"></a>代码展示</h3> 
<pre><code class="prism language-c">class Solution <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">long</span> prev<span class="token operator">=</span>LONG_MIN<span class="token punctuation">;</span>
public<span class="token operator">:</span>
    bool <span class="token function">isValidBST</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span>nullptr<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> true<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        bool left<span class="token operator">=</span><span class="token function">isValidBST</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//左子树都不满足，则不用递归右子树了</span>
        <span class="token comment">//剪枝</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">==</span>false<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> false<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//用cur表示当前节点是否满足</span>
        bool cur<span class="token operator">=</span>false<span class="token punctuation">;</span>
        <span class="token comment">//如果满足则进入将cur置为true</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>val<span class="token operator">&gt;</span>prev<span class="token punctuation">)</span>
            cur<span class="token operator">=</span>true<span class="token punctuation">;</span>
            <span class="token comment">//不满足直接返回false</span>
        <span class="token keyword">else</span>
            <span class="token keyword">return</span> false<span class="token punctuation">;</span>
            <span class="token comment">//更新prevv</span>
        prev<span class="token operator">=</span>root<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span>
        <span class="token comment">//递归右子树</span>
        bool right<span class="token operator">=</span><span class="token function">isValidBST</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//返回左子树和右子树和当前节点是否满足是否是二叉搜索树</span>
        <span class="token keyword">return</span> left<span class="token operator">&amp;&amp;</span>right<span class="token operator">&amp;&amp;</span>cur<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="5k_195"></a>5.二叉搜索树中第k小元素</h2> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/7e/5b/5Nx33ZW6_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>对于这道题还是和上一道题类似。</p> 
<h3><a id="_200"></a>思路：</h3> 
<p><img src="https://images2.imgbox.com/06/fa/DA9sn8UA_o.png" alt="在这里插入图片描述"><br> 对于上面这个二叉搜索树，我们要求这个二叉搜索树的第k小的节点是不是应该用中序遍历，因为中序遍历是有序的，当我们中序遍历到叶子节点的时候，我们就可以开始数了，所以这里我们需要一个count来计数，计算这个是第几小，count我们最好选择全局变量，因为全局变量不会随着递归而改变，当我们中序遍历到叶子节点的时候，我们的count就应该–操作，每次–之后，我么都应该判断一下这个count是否已经==0了，如果等于0，我们用一个全局变量ret来接收一下这个值。<br> <img src="https://images2.imgbox.com/ff/7f/JXFFGEar_o.png" alt="在这里插入图片描述"></p> 
<p>到3的时候直接用全局变量接收这个值。</p> 
<h3><a id="_207"></a>代码展示</h3> 
<pre><code class="prism language-c">class Solution <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> count<span class="token punctuation">;</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
public<span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">kthSmallest</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        count<span class="token operator">=</span>k<span class="token punctuation">;</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span>root<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//count==0是剪枝</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span>nullptr<span class="token operator">||</span>count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        count<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            ret<span class="token operator">=</span>root<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>上面代码的递归出口的count==0，可不写，因为我们也可以继续递归，count为0只有一次，所以如果count等于0，我们可以直接不用递归了，直接返回。</p> 
<h2><a id="6_235"></a>6.二叉树的所有路径</h2> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/99/98/DzlHiTlN_o.png" alt="这里是引用"></p> 
</blockquote> 
<p>这道题需要返回的是，一个路径的数组，类型是string类的</p> 
<h3><a id="_241"></a>思路分析</h3> 
<p>这道题要返回string类的数组的话，为了不被递归影响到数组的值，所以我们最好还是创建一个全局变量数组，string的来记录这个每个路径，还需要一个局部变量，还需要一个string变量来记录当前路径。</p> 
<p><strong>函数头</strong><br> 函数头：<code>dfs(root,path)</code><br> 传递一个局部变量的路径<br> <strong>函数体</strong><br> 注意函数体部分，我们分析一下，我们要求出所有路径，我们先看看下面的输入和输出样例。<br> <img src="https://images2.imgbox.com/94/1d/kVyxnGxw_o.png" alt="在这里插入图片描述"><br> 对于这个输出样例，我们可以看到这个string不仅需要路径的值还需要一个-&gt;将其串联起来，所以这里我们就分为了两种情况，一种是非叶子节点，一种是叶子节点，对于非叶子节点，我们不仅需要向string变量中加入当前值的字符，还需要向里加入两个符号“-&gt;”，但是对于叶子节点来说，我们只需要向里添加当前节点对应值的字符就可以了，注意：添加完之后，我们将string类的变量丢进string类的数组中，注意：这里我们不创建全局变量string的原因是因为当我们返回到上一节点的时候，因为全局变量不会改变，所以我们需要手动删除当前路径下的不需要的所有节点，才能进入下一个分支，就拿上面的图为例子，当我们要进入右子树的时候，我们必须将左子树中的2和3删完之后，只留下1才能进入右子树分支，但是对于局部变量，则不一样，注意：这里我们创建局部变量的时候，传参也要传拷贝构造，而不是引用，传引用的话和创建全局变量没有任何区别，传递拷贝构造的话，每次返回上一个分支都是一个新的string，不会存在什么删除不需要的情况。</p> 
<h3><a id="_254"></a>代码展示</h3> 
<pre><code class="prism language-c">class Solution <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//全局若string数组，用来存储字符串</span>
    vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span>  ret<span class="token punctuation">;</span>
public<span class="token operator">:</span>
    vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">binaryTreePaths</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//创建path记录路径</span>
        string path<span class="token punctuation">;</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//返回字符数组</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span>root<span class="token punctuation">,</span>string path<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//叶子节点的处理方式</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token operator">==</span>nullptr<span class="token operator">&amp;&amp;</span>root<span class="token operator">-&gt;</span>right<span class="token operator">==</span>nullptr<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            path<span class="token operator">+=</span><span class="token function">to_string</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
            ret<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//非叶子节点的处理方式</span>
        path<span class="token operator">+=</span><span class="token function">to_string</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"-&gt;"</span><span class="token punctuation">;</span>
        <span class="token comment">//左子树不为空才递归，为空直接剪枝</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//右子树也一样</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="_288"></a>总结</h2> 
<p><strong>通过本文的探讨，我们了解了深度优先搜索（DFS）在解决二叉树问题中的强大功能和广泛应用。DFS 通过其递归和迭代两种实现方式，为我们提供了处理二叉树的不同策略，使得问题的求解变得更加灵活。无论是前序遍历、中序遍历还是后序遍历，DFS 都能够有效地遍历二叉树的每一个节点，从而帮助我们解决各种实际问题，如路径求和、树的对称性检查以及节点间距离计算等。</strong></p> 
<p><strong>希望通过本文的介绍，大家对 DFS 在二叉树问题中的应用有了更深入的理解，并能够在实际编程中灵活运用这些技巧来解决复杂的树结构问题。感谢阅读，期待在你们的代码中见到这些算法的身影！如果有任何疑问或进一步的讨论，欢迎在评论区留言，我们一起交流学习。</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2c1b96bccaa5535c48dec2e8e2ae4ffb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spark Sql</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bc3ce75c75116e50e3f205ff7d131cb8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">漫画|基于SprinBoot&#43;vue的漫画网站(源码&#43;数据库&#43;文档)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>