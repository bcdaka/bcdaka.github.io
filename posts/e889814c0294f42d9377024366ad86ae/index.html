<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java 集合框架：Java 中的 Set 集合（HashSet &amp; LinkedHashSet &amp; TreeSet）特点与实现解析 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/e889814c0294f42d9377024366ad86ae/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java 集合框架：Java 中的 Set 集合（HashSet & LinkedHashSet & TreeSet）特点与实现解析">
  <meta property="og:description" content="大家好，我是栗筝i，这篇文章是我的 “栗筝i 的 Java 技术栈” 专栏的第 017 篇文章，在 “栗筝i 的 Java 技术栈” 这个专栏中我会持续为大家更新 Java 技术相关全套技术栈内容。专栏的主要目标是已经有一定 Java 开发经验，并希望进一步完善自己对整个 Java 技术体系来充实自己的技术栈的同学。与此同时，本专栏的所有文章，也都会准备充足的代码示例和完善的知识点梳理，因此也十分适合零基础的小白和要准备工作面试的同学学习。当然，我也会在必要的时候进行相关技术深度的技术解读，相信即使是拥有多年 Java 开发经验的从业者和大佬们也会有所收获并找到乐趣。
–
相较于 List 集合与 Map 集合，Set 集合可以讨论的点其实很少，这主要的原因是因为无论是哪一种 Set 集合的实现类其实都是基于 Map 集合的，而如果深究其原理，其实就是去深究 Map 的实现，而我不打算对 Map 的解读放在 Set 的章节…
当然除了主要实现之外，Set 也是有很多值得我们关注的特点的，比如他的无序性，对并发流、序列化以及非序列化的实现，以及主要实现类 HashSet、TreeSet、LinkedHashSet 三者的区别，只是由于可能真正值得关注的点不是很多，所以我在本系列中将整个 Set 压缩为了一篇文章。
文章目录 1、Set 集合介绍1.1、Set 接口概述1.2、实现类 HashSet1.3、实现类 TreeSet1.4、实现类 LinkedHashSet1.5、三种 Set 集合对比 2、HashSet 底层实现2.1、HashSet 构造函数实现2.2、HashSet 主要方法实现 3、TreeSet 底层实现3.1、TreeSet 构造方法实现3.2、TreeSet 特色方法实现 1、Set 集合介绍 1.1、Set 接口概述 Set 是 java.util 包下集合框架中一个接口，它是 Collection 接口的一个子接口，表示不允许包含重复元素的集合。Set 集合的特点是集合内的元素无序，且每个元素都是唯一的。这意味着即使试图添加两个相等的对象（依据 .">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-09T06:00:00+08:00">
    <meta property="article:modified_time" content="2024-07-09T06:00:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java 集合框架：Java 中的 Set 集合（HashSet &amp; LinkedHashSet &amp; TreeSet）特点与实现解析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>大家好，我是栗筝i，这篇文章是我的 “栗筝i 的 Java 技术栈” 专栏的第 017 篇文章，在 “栗筝i 的 Java 技术栈” 这个专栏中我会持续为大家更新 Java 技术相关全套技术栈内容。专栏的主要目标是已经有一定 Java 开发经验，并希望进一步完善自己对整个 Java 技术体系来充实自己的技术栈的同学。与此同时，本专栏的所有文章，也都会准备充足的代码示例和完善的知识点梳理，因此也十分适合零基础的小白和要准备工作面试的同学学习。当然，我也会在必要的时候进行相关技术深度的技术解读，相信即使是拥有多年 Java 开发经验的从业者和大佬们也会有所收获并找到乐趣。</p> 
 <p>–</p> 
 <p>相较于 List 集合与 Map 集合，Set 集合可以讨论的点其实很少，这主要的原因是因为无论是哪一种 Set 集合的实现类其实都是基于 Map 集合的，而如果深究其原理，其实就是去深究 Map 的实现，而我不打算对 Map 的解读放在 Set 的章节…</p> 
 <p>当然除了主要实现之外，Set 也是有很多值得我们关注的特点的，比如他的无序性，对并发流、序列化以及非序列化的实现，以及主要实现类 HashSet、TreeSet、LinkedHashSet 三者的区别，只是由于可能真正值得关注的点不是很多，所以我在本系列中将整个 Set 压缩为了一篇文章。</p> 
</blockquote> 
<hr> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><ul><li><a href="#1Set__15" rel="nofollow">1、Set 集合介绍</a></li><li><ul><li><a href="#11Set__17" rel="nofollow">1.1、Set 接口概述</a></li><li><a href="#12_HashSet_29" rel="nofollow">1.2、实现类 HashSet</a></li><li><a href="#13_TreeSet_40" rel="nofollow">1.3、实现类 TreeSet</a></li><li><a href="#14__LinkedHashSet_54" rel="nofollow">1.4、实现类 LinkedHashSet</a></li><li><a href="#15_Set__64" rel="nofollow">1.5、三种 Set 集合对比</a></li></ul> 
    </li><li><a href="#2HashSet___82" rel="nofollow">2、HashSet 底层实现</a></li><li><ul><li><a href="#21HashSet__86" rel="nofollow">2.1、HashSet 构造函数实现</a></li><li><a href="#22HashSet__171" rel="nofollow">2.2、HashSet 主要方法实现</a></li></ul> 
    </li><li><a href="#3TreeSet__365" rel="nofollow">3、TreeSet 底层实现</a></li><li><ul><li><a href="#31TreeSet__369" rel="nofollow">3.1、TreeSet 构造方法实现</a></li><li><a href="#32TreeSet__455" rel="nofollow">3.2、TreeSet 特色方法实现</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h4><a id="1Set__15"></a>1、Set 集合介绍</h4> 
<h5><a id="11Set__17"></a>1.1、Set 接口概述</h5> 
<p><code>Set</code> 是 <code>java.util</code> 包下集合框架中一个接口，它是 <code>Collection</code> 接口的一个子接口，表示不允许包含重复元素的集合。Set 集合的特点是集合内的元素无序，且每个元素都是唯一的。这意味着即使试图添加两个相等的对象（依据 <code>.equals()</code> 方法判断相等），Set 集合只会保存一个对象。</p> 
<p><img src="https://images2.imgbox.com/d6/ac/1sZHKEzH_o.png" alt="image-20240709010221991"></p> 
<p>Set集合的特点：</p> 
<ul><li>无序性：Set 集合中的元素不按任何特定顺序排列，无法通过索引访问元素，即集合内部的元素顺序可能随时间和操作发生变化；</li><li>唯一性：Set 集合不允许包含重复的元素。判断元素是否重复的标准是基于元素的 <code>.equals()</code> 方法。如果两个对象在 <code>.equals()</code> 方法下判断为相等，则 Set 集合中只会存储其中一个；</li><li>最大容量：理论上，Set 集合可以无限增长，直到受到可用内存限制为止。</li></ul> 
<h5><a id="12_HashSet_29"></a>1.2、实现类 HashSet</h5> 
<p><code>HashSet</code> 是 Java 集合框架中一个实现 <code>Set</code> 接口的类，它使用哈希表（内部一般采用 <code>HashMap</code>）作为底层数据结构，主要用于存储不重复的元素集合。</p> 
<p><code>HashSet</code> 集合有以下特点：</p> 
<ul><li>唯一性；</li><li>无序性；</li><li>高效性：由于基于哈希表实现，<code>HashSet</code> 插入、删除和查找元素的平均时间复杂度为 <code>O(1)</code>，前提是哈希函数能够良好地分散冲突。</li><li>允许存储 <code>null</code> 值：<code>HashSet</code> 允许存储一个 <code>null</code> 元素，但仅能存储一个，因为 <code>null</code> 的哈希码固定为 <code>0</code>。</li></ul> 
<h5><a id="13_TreeSet_40"></a>1.3、实现类 TreeSet</h5> 
<p><code>TreeSet</code> 同样是 Java 集合框架中实现 <code>Set</code> 接口的一个重要类，它基于红黑树（Red-Black Tree）数据结构，提供了一个有序的、不包含重复元素的集合。</p> 
<p><img src="https://images2.imgbox.com/5b/d5/O94VhOSa_o.png" alt="image-20240709010502515"></p> 
<p>相比于 <code>HashSet</code>，<code>TreeSet</code> 性能稍逊，但在需要排序功能时非常有用。</p> 
<p><code>TreeSet</code>集合有以下特点：</p> 
<ul><li>唯一性</li><li>有序性：<code>TreeSet</code>中的元素是有序的，排序规则既可以是元素本身的自然排序（元素类实现了 <code>Comparable</code> 接口），也可以是由客户端提供的 <code>Comparator</code> 来决定。</li><li>自平衡：由于基于红黑树实现，<code>TreeSet </code>在插入、删除和查找操作后都能保持树的平衡，从而确保这些操作的时间复杂度接近 <code>O(log n)</code>。</li></ul> 
<h5><a id="14__LinkedHashSet_54"></a>1.4、实现类 LinkedHashSet</h5> 
<p><code>LinkedHashSet</code> 继承自 <code>HashSet</code> 并实现了 <code>Set</code> 接口。<code>LinkedHashSet</code> 集合是一种哈希表和链表的组合，它具有以下特点：</p> 
<ol><li>无序性：与 <code>HashSet</code> 类似，<code>LinkedHashSet</code> 也不允许集合中有重复的元素。</li><li>有序性：与 <code>HashSet</code> 不同的是，<code>LinkedHashSet</code> 维护了一个双向链表，使得迭代它时可以按照插入顺序访问集合中的元素。</li><li>性能：<code>LinkedHashSet</code> 在大多数情况下提供与 <code>HashSet</code> 相同的时间和空间复杂度，即添加、删除和查找元素的时间复杂度为 O(1)。</li></ol> 
<p>当你需要一个不允许重复元素的集合，并且希望迭代时能够按照元素的插入顺序进行时，可以使用 <code>LinkedHashSet</code>。<code>LinkedHashSet</code> 可以作为 <code>HashMap</code> 的键集合，因为它提供了快速的查找和迭代性能。</p> 
<h5><a id="15_Set__64"></a>1.5、三种 Set 集合对比</h5> 
<table><thead><tr><th align="center">特点</th><th align="center">HashSet</th><th align="center">TreeSet</th><th align="center">LinkedHashSet</th></tr></thead><tbody><tr><td align="center">底层数据结构</td><td align="center"><code>HashMap</code></td><td align="center">红黑树</td><td align="center"><code>LinkedHashMap</code></td></tr><tr><td align="center">元素顺序</td><td align="center">无特定顺序</td><td align="center">按自然顺序或自定义顺序</td><td align="center">按插入顺序</td></tr><tr><td align="center">时间复杂度</td><td align="center"><code>O(1)</code></td><td align="center"><code>O(log n)</code></td><td align="center"><code>O(1)</code></td></tr><tr><td align="center">额外功能</td><td align="center">无</td><td align="center">支持范围查询和排序操作</td><td align="center">保证插入顺序</td></tr><tr><td align="center">适用场景</td><td align="center">需要快速访问和操作的集合</td><td align="center">需要排序的有序集合</td><td align="center">需要保持插入顺序且快速访问和操作的集合</td></tr></tbody></table> 
<p>总的来说，这三种集合各有优劣，选择时需根据具体需求考虑，如性能要求、是否需要排序或保持顺序等。</p> 
<ul><li>HashSet：在需要高效地进行添加、删除、查找操作且不关心元素顺序时最为适用。</li><li>TreeSet：适用于需要对元素进行排序和范围查询的场景，尽管性能稍逊，但提供了额外的有序操作方法。</li><li>LinkedHashSet：当既需要快速操作元素，又需要保持插入顺序时，是最佳选择。</li></ul> 
<hr> 
<h4><a id="2HashSet___82"></a>2、HashSet 底层实现</h4> 
<p><code>HashSet&lt;E&gt;</code> 继承自 <code>AbstractSet&lt;E&gt;</code>，实现了 <code>Set&lt;E&gt;</code>, <code>Cloneable</code> 和 <code>java.io.Serializable</code> 接口。<code>Cloneable</code> 使其支持克隆，<code>Serializable</code> 使其支持序列化。</p> 
<h5><a id="21HashSet__86"></a>2.1、HashSet 构造函数实现</h5> 
<p><code>HashSet</code> 类在 Java 集合框架中提供了多个构造函数，用于创建不同的 <code>HashSet</code> 实例。</p> 
<pre><code class="prism language-java"><span class="token keyword">package</span> <span class="token namespace">java<span class="token punctuation">.</span>util</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword">implements</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">5024744406713321676L</span><span class="token punctuation">;</span>

    <span class="token comment">// 底层使用 HashMap 实现</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">;</span>

    <span class="token comment">// 用于与 HashMap 中的 key 关联的虚拟值</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> <span class="token constant">PRESENT</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 构造一个新的空集合，底层 HashMap 的默认初始容量为 16，负载因子为 0.75
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 构造一个包含指定集合中元素的新集合。底层 HashMap 的负载因子为 0.75，
     * 初始容量足以包含指定集合中的元素。
     *
     * @param c 要放入此集合的元素的集合
     * @throws NullPointerException 如果指定的集合为 null
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">.75f</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">addAll</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 构造一个新的空集合，底层 HashMap 实例具有指定的初始容量和负载因子。
     *
     * @param      initialCapacity   哈希映射的初始容量
     * @param      loadFactor        哈希映射的负载因子
     * @throws     IllegalArgumentException 如果初始容量小于 0，或负载因子非正
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 构造一个新的空集合，底层 HashMap 实例具有指定的初始容量和默认负载因子 0.75。
     *
     * @param      initialCapacity   哈希表的初始容量
     * @throws     IllegalArgumentException 如果初始容量小于 0
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 构造一个新的空的 LinkedHashSet。仅由 LinkedHashSet 使用的包私有构造函数。
     * 底层 HashMap 实例是具有指定初始容量和负载因子的 LinkedHashMap。
     *
     * @param      initialCapacity   哈希映射的初始容量
     * @param      loadFactor        哈希映射的负载因子
     * @param      dummy             忽略（用于区分其他 int, float 构造函数）
     * @throws     IllegalArgumentException 如果初始容量小于 0，或负载因子非正
     */</span>
    <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">,</span> <span class="token keyword">boolean</span> dummy<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  
    <span class="token comment">// 省略其他方法和实现细节</span>
  	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  
<span class="token punctuation">}</span>
</code></pre> 
<p>从这部分代码我们可以看出：</p> 
<ul><li><code>HashSet</code> 主要通过 <code>HashMap</code> 实现其所有功能，所有元素作为 <code>HashMap</code> 的键存储，而 <code>PRESENT</code> 常量对象作为所有键的值。</li><li>多个构造函数提供了不同的初始化方式，满足不同场景下的使用需求。</li><li>包私有构造函数 <code>HashSet(int initialCapacity, float loadFactor, boolean dummy)</code> 专为 <code>LinkedHashSet</code> 设计，用于支持按插入顺序访问元素。</li></ul> 
<h5><a id="22HashSet__171"></a>2.2、HashSet 主要方法实现</h5> 
<p>从 HashSet 具体的方法实现，我们可以进一步看出 <code>HashSet</code> 通过 <code>HashMap</code> 实现其所有主要功能，通过 <code>HashMap</code> 的键值特性，确保集合中的元素不重复。由于底层采用哈希表存储，<code>HashSet</code> 提供了快速的元素添加、删除和查找操作。</p> 
<p>此外 HashSet 也主要实现了部分流方法，用于实现序列化、反序列化和并行流操作：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword">extends</span> <span class="token class-name">AbstractSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword">implements</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">5024744406713321676L</span><span class="token punctuation">;</span>

    <span class="token comment">// 底层使用 HashMap 实现</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">;</span>

    <span class="token comment">// 用于与 HashMap 中的 key 关联的虚拟值</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> <span class="token constant">PRESENT</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    <span class="token comment">// 省略其他方法和实现细节</span>
  	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    <span class="token comment">// 返回该集合的迭代器</span>
    <span class="token keyword">public</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 返回集合中的元素数量（基数）。
     *
     * @return 集合中的元素数量（基数）
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 如果此集合不包含任何元素，则返回 true。
     *
     * @return 如果此集合不包含任何元素，则返回 true
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 如果此集合包含指定的元素，则返回 true。
     * 更正式地讲，当且仅当此集合包含一个元素 e 满足 (o==null ? e==null : o.equals(e)) 时，返回 true。
     *
     * @param o 测试在此集合中的存在的元素
     * @return 如果此集合包含指定的元素，则返回 true
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 如果指定元素尚未存在于集合中，则将其添加到集合中。
     * 更正式地讲，如果此集合不包含元素 e2 满足 (e==null ? e2==null : e.equals(e2))，则将指定元素 e 添加到此集合中。
     * 如果此集合已经包含该元素，则此调用不更改集合并返回 false。
     *
     * @param e 要添加到集合中的元素
     * @return 如果集合中尚不包含指定元素，则返回 true
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token constant">PRESENT</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 如果集合中存在指定的元素，则将其从集合中移除。
     * 更正式地讲，如果此集合包含一个元素 e 满足 (o==null ? e==null : o.equals(e))，则将其移除。
     * 如果此集合包含该元素，则返回 true（即此调用改变了集合）。
     *
     * @param o 要从集合中移除的元素
     * @return 如果集合中包含指定的元素，则返回 true
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">PRESENT</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 从此集合中移除所有元素。此调用返回后集合将为空。
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        map<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 返回此 HashSet 实例的浅表副本：元素本身不被克隆。
     *
     * @return 此集合的浅表副本
     */</span>
    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> newSet <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            newSet<span class="token punctuation">.</span>map <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> map<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> newSet<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InternalError</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 将此 HashSet 实例的状态保存到一个流中（即，序列化它）。
     *
     * @serialData 发出支持 HashMap 实例的容量（int）及其负载因子（float），
     *             然后是集合的大小（它包含的元素数量）（int），
     *             以及所有的元素（每个是 Object），顺序不定。
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">writeObject</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>ObjectOutputStream</span> s<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>IOException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 写出所有默认的序列化内容</span>
        s<span class="token punctuation">.</span><span class="token function">defaultWriteObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 写出 HashMap 的容量和负载因子</span>
        s<span class="token punctuation">.</span><span class="token function">writeInt</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        s<span class="token punctuation">.</span><span class="token function">writeFloat</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">loadFactor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 写出大小</span>
        s<span class="token punctuation">.</span><span class="token function">writeInt</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 写出所有元素，顺序不定</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">E</span> e <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            s<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 从流中重构 HashSet 实例（即，反序列化它）。
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">readObject</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>ObjectInputStream</span> s<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>IOException</span><span class="token punctuation">,</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 读取并忽略流字段（当前为零）</span>
        s<span class="token punctuation">.</span><span class="token function">readFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 读取容量并验证非负</span>
        <span class="token keyword">int</span> capacity <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">readInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>capacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InvalidObjectException</span><span class="token punctuation">(</span><span class="token string">"非法容量: "</span> <span class="token operator">+</span> capacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 读取负载因子并验证正值且非 NaN</span>
        <span class="token keyword">float</span> loadFactor <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">readFloat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>loadFactor <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token class-name">Float</span><span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InvalidObjectException</span><span class="token punctuation">(</span><span class="token string">"非法负载因子: "</span> <span class="token operator">+</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 将负载因子限制在 0.25 到 4.0 范围内</span>
        loadFactor <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0.25f</span><span class="token punctuation">,</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">4.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 读取大小并验证非负</span>
        <span class="token keyword">int</span> size <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">readInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InvalidObjectException</span><span class="token punctuation">(</span><span class="token string">"非法大小: "</span> <span class="token operator">+</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 根据大小和负载因子设置容量，确保 HashMap 至少填充 25%，并限制最大容量</span>
        capacity <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>size <span class="token operator">*</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">/</span> loadFactor<span class="token punctuation">,</span> <span class="token number">4.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token class-name">HashMap</span><span class="token punctuation">.</span><span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 构造支持的 HashMap 将在添加第一个元素时懒惰地创建一个数组，</span>
        <span class="token comment">// 因此在构造前进行检查。调用 HashMap.tableSizeFor 计算实际分配大小。</span>
        <span class="token comment">// 检查 Map.Entry[].class，因为它是最接近实际创建的公共类型。</span>

        <span class="token class-name">SharedSecrets</span><span class="token punctuation">.</span><span class="token function">getJavaOISAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                     <span class="token punctuation">.</span><span class="token function">checkArray</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">HashMap</span><span class="token punctuation">.</span><span class="token function">tableSizeFor</span><span class="token punctuation">(</span>capacity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 创建支持的 HashMap</span>
        map <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">LinkedHashSet</span> <span class="token operator">?</span>
               <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>capacity<span class="token punctuation">,</span> loadFactor<span class="token punctuation">)</span> <span class="token operator">:</span>
               <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>capacity<span class="token punctuation">,</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 以适当的顺序读取所有元素</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>
                <span class="token class-name">E</span> e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> s<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token constant">PRESENT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 创建一个晚绑定且快速失败的 Spliterator 对象，遍历此集合中的元素。
     *
     * Spliterator 报告 SIZED 和 DISTINCT 特性。
     * 重写实现应记录额外特性值的报告。
     *
     * @return 一个遍历此集合中元素的 Spliterator
     * @since 1.8
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">Spliterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">spliterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">HashMap<span class="token punctuation">.</span>KeySpliterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>map<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h4><a id="3TreeSet__365"></a>3、TreeSet 底层实现</h4> 
<p><code>TreeSet</code> 类实现了 <code>NavigableSet</code> 接口，提供了一组按顺序存储的集合元素。它使用一个 <code>NavigableMap</code> 来存储元素，默认情况下是 <code>TreeMap</code>。</p> 
<h5><a id="31TreeSet__369"></a>3.1、TreeSet 构造方法实现</h5> 
<p><code>TreeSet</code> 提供了多个构造函数，以支持不同的初始化方式：</p> 
<ul><li>无参构造函数：创建一个空的 <code>TreeSet</code>，按自然顺序排序；</li><li>带比较器参数的构造函数：按指定的比较器排序；</li><li>带集合参数的构造函数：使用指定集合的元素构造 <code>TreeSet</code>，按自然顺序排序；</li><li>带排序集参数的构造函数：使用指定排序集的元素和顺序构造 <code>TreeSet</code>。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword">implements</span> <span class="token class-name">NavigableSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">/**
     * 底层使用的 NavigableMap 实例。
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">NavigableMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> m<span class="token punctuation">;</span>

    <span class="token comment">// 作为在底层 Map 中与元素关联的虚拟值</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> <span class="token constant">PRESENT</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 构造一个由指定的 NavigableMap 支持的集合。
     */</span>
    <span class="token class-name">TreeSet</span><span class="token punctuation">(</span><span class="token class-name">NavigableMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> m<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>m <span class="token operator">=</span> m<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 构造一个新的空的树集，按照元素的自然顺序排序。
     * 插入集合的所有元素必须实现 {@link Comparable} 接口。
     * 此外，所有元素必须是相互可比较的：{@code e1.compareTo(e2)} 
     * 不能对集合中的任何元素 {@code e1} 和 {@code e2} 抛出 
     * {@code ClassCastException} 异常。如果用户尝试添加违反此约束的元素
     * （例如，用户尝试将字符串元素添加到整数元素的集合中），
     * {@code add} 调用将抛出 {@code ClassCastException} 异常。
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">TreeSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 构造一个新的空的树集，按照指定的比较器排序。
     * 插入集合的所有元素必须是由指定的比较器相互可比较的：
     * {@code comparator.compare(e1, e2)} 不能对集合中的任何元素 
     * {@code e1} 和 {@code e2} 抛出 {@code ClassCastException} 异常。
     * 如果用户尝试添加违反此约束的元素，
     * {@code add} 调用将抛出 {@code ClassCastException} 异常。
     *
     * @param comparator 用于排序此集合的比较器。
     *        如果 {@code null}，将使用元素的自然顺序。
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">TreeSet</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> comparator<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>comparator<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 构造一个包含指定集合中的元素的新树集，
     * 按照元素的自然顺序排序。插入集合的所有元素必须实现 
     * {@link Comparable} 接口。此外，所有元素必须是相互可比较的：
     * {@code e1.compareTo(e2)} 不能对集合中的任何元素 {@code e1} 和 
     * {@code e2} 抛出 {@code ClassCastException} 异常。
     *
     * @param c 其元素将构成新集合的集合
     * @throws ClassCastException 如果 {@code c} 中的元素不是 
     *         {@link Comparable}，或不是相互可比较的
     * @throws NullPointerException 如果指定的集合为 null
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">TreeSet</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">addAll</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 构造一个包含指定排序集的相同元素并使用相同顺序的新树集。
     *
     * @param s 其元素将构成新集合的排序集
     * @throws NullPointerException 如果指定的排序集为 null
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">TreeSet</span><span class="token punctuation">(</span><span class="token class-name">SortedSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">comparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">addAll</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="32TreeSet__455"></a>3.2、TreeSet 特色方法实现</h5> 
<p><code>TreeSet</code> 提供了灵活的集合操作和导航功能的操作，使其成为功能强大的有序集合。这些特点使 <code>TreeSet</code> 在需要有序和高效查找的场景中尤为有用</p> 
<pre><code class="prism language-java"><span class="token comment">/**
 * 返回此集合中的第一个（最低）元素。
 *
 * @throws NoSuchElementException 如果此集合为空
 */</span>
<span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">firstKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 返回此集合中的最后一个（最高）元素。
 *
 * @throws NoSuchElementException 如果此集合为空
 */</span>
<span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">last</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">lastKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 返回一个新的集合，包含从 fromElement（包含或不包含，根据 fromInclusive）到 toElement（包含或不包含，根据 toInclusive）范围内的元素。
 *
 * @param fromElement 起始元素
 * @param fromInclusive 是否包含起始元素
 * @param toElement 结束元素
 * @param toInclusive 是否包含结束元素
 * @return 包含指定范围内元素的新集合
 */</span>
<span class="token keyword">public</span> <span class="token class-name">NavigableSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">subSet</span><span class="token punctuation">(</span><span class="token class-name">E</span> fromElement<span class="token punctuation">,</span> <span class="token keyword">boolean</span> fromInclusive<span class="token punctuation">,</span>
                              <span class="token class-name">E</span> toElement<span class="token punctuation">,</span> <span class="token keyword">boolean</span> toInclusive<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TreeSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">subMap</span><span class="token punctuation">(</span>fromElement<span class="token punctuation">,</span> fromInclusive<span class="token punctuation">,</span> toElement<span class="token punctuation">,</span> toInclusive<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 返回一个新的集合，包含从集合开头到指定元素（包含或不包含，根据 inclusive）的所有元素。
 *
 * @param toElement 结束元素
 * @param inclusive 是否包含结束元素
 * @return 包含从开头到指定元素的新集合
 */</span>
<span class="token keyword">public</span> <span class="token class-name">NavigableSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">headSet</span><span class="token punctuation">(</span><span class="token class-name">E</span> toElement<span class="token punctuation">,</span> <span class="token keyword">boolean</span> inclusive<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TreeSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">headMap</span><span class="token punctuation">(</span>toElement<span class="token punctuation">,</span> inclusive<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 返回一个新的集合，包含从指定元素（包含或不包含，根据 inclusive）到集合末尾的所有元素。
 *
 * @param fromElement 起始元素
 * @param inclusive 是否包含起始元素
 * @throws ClassCastException 如果指定元素的类型不允许
 * @throws NullPointerException 如果 fromElement 为 null 且集合使用自然顺序，或其比较器不允许 null 元素
 * @throws IllegalArgumentException 如果起始元素不合法
 * @since 1.6
 * @return 包含从指定元素到末尾的新集合
 */</span>
<span class="token keyword">public</span> <span class="token class-name">NavigableSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">tailSet</span><span class="token punctuation">(</span><span class="token class-name">E</span> fromElement<span class="token punctuation">,</span> <span class="token keyword">boolean</span> inclusive<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TreeSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">tailMap</span><span class="token punctuation">(</span>fromElement<span class="token punctuation">,</span> inclusive<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 返回一个新的集合，包含从 fromElement（包含）到 toElement（不包含）范围内的元素。
 *
 * @param fromElement 起始元素
 * @param toElement 结束元素
 * @return 包含指定范围内元素的新集合
 */</span>
<span class="token keyword">public</span> <span class="token class-name">SortedSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">subSet</span><span class="token punctuation">(</span><span class="token class-name">E</span> fromElement<span class="token punctuation">,</span> <span class="token class-name">E</span> toElement<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token function">subSet</span><span class="token punctuation">(</span>fromElement<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> toElement<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 返回一个新的集合，包含从集合开头到指定元素（不包含）的所有元素。
 *
 * @param toElement 结束元素
 * @throws ClassCastException 如果指定元素的类型不允许
 * @throws NullPointerException 如果 toElement 为 null 且集合使用自然顺序，或其比较器不允许 null 元素
 * @throws IllegalArgumentException 如果结束元素不合法
 * @return 包含从开头到指定元素的新集合
 */</span>
<span class="token keyword">public</span> <span class="token class-name">SortedSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">headSet</span><span class="token punctuation">(</span><span class="token class-name">E</span> toElement<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token function">headSet</span><span class="token punctuation">(</span>toElement<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 返回一个新的集合，包含从指定元素（包含）到集合末尾的所有元素。
 *
 * @param fromElement 起始元素
 * @throws ClassCastException 如果指定元素的类型不允许
 * @throws NullPointerException 如果 fromElement 为 null 且集合使用自然顺序，或其比较器不允许 null 元素
 * @throws IllegalArgumentException 如果起始元素不合法
 * @return 包含从指定元素到末尾的新集合
 */</span>
<span class="token keyword">public</span> <span class="token class-name">SortedSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">tailSet</span><span class="token punctuation">(</span><span class="token class-name">E</span> fromElement<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token function">tailSet</span><span class="token punctuation">(</span>fromElement<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 返回此集合中元素的逆序迭代器。
 *
 * @return 逆序迭代器
 */</span>
<span class="token keyword">public</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">descendingIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">descendingKeySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 返回一个新的集合，包含此集合中元素的逆序视图。
 *
 * @since 1.6
 * @return 逆序视图的新集合
 */</span>
<span class="token keyword">public</span> <span class="token class-name">NavigableSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">descendingSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TreeSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">descendingMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fceba71971702bc990f350043150d5f2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【前端从入门到精通：第九课：CSS3新增属性及伸缩盒布局】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f4285522fb4d4cc3b72dae1e386380ae/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MongoDB 全文检索</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>