<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java---SpringBoot详解二 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/2c5040d3c180f8389790f8c74dffefbe/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java---SpringBoot详解二">
  <meta property="og:description" content="勤奋勤劳铸梦成，
晨曦微露起长征。
汗水浇灌花似锦，
寒窗苦读岁月明。
千锤百炼心如铁，
万里征途志不倾。
持之以恒终有日，
功成名就笑谈中。
目录
一，统一响应结果
二，三层架构
三，分层解耦
四，IOC
五，DI
接上文Java---SpringBoot详解一-CSDN博客
一，统一响应结果 之前我们返回的结果都是各自返回各自的，这样客户端解析的时候就非常麻烦，不便于封装，下面是我们想要的结果：
客户端只需要根据Result这一种格式解析就可以。
下面我们创建一个Result类：
package com.yuanzhen.yzjavatest.bean; public class Result { private Integer code;//1成功，0失败 private String msg;//提示信息 private Object data;//数据date public Result() { } public Result(Integer code, String msg, Object data) { this.code = code; this.msg = msg; this.data = data; } public void setCode(Integer code) { this.code = code; } public void setMsg(String msg) { this.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-11T17:36:53+08:00">
    <meta property="article:modified_time" content="2024-07-11T17:36:53+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java---SpringBoot详解二</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><strong>勤奋勤劳铸梦成，<br> 晨曦微露起长征。<br> 汗水浇灌花似锦，<br> 寒窗苦读岁月明。<br> 千锤百炼心如铁，<br> 万里征途志不倾。<br> 持之以恒终有日，<br> 功成名就笑谈中。</strong></p> 
</blockquote> 
<blockquote> 
 <p id="main-toc"><strong>目录</strong></p> 
 <p id="%E4%B8%80%EF%BC%8C%E7%BB%9F%E4%B8%80%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%9C-toc" style="margin-left:0px;"><a href="#%E4%B8%80%EF%BC%8C%E7%BB%9F%E4%B8%80%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%9C" rel="nofollow">一，统一响应结果</a></p> 
 <p id="%E4%BA%8C%EF%BC%8C%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%EF%BC%8C%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84" rel="nofollow">二，三层架构</a></p> 
 <p id="%C2%A0%E4%B8%89%EF%BC%8C%E5%88%86%E5%B1%82%E8%A7%A3%E8%80%A6-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%B8%89%EF%BC%8C%E5%88%86%E5%B1%82%E8%A7%A3%E8%80%A6" rel="nofollow"> 三，分层解耦</a></p> 
 <p id="%E5%9B%9B%EF%BC%8CIOC-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%EF%BC%8CIOC" rel="nofollow">四，IOC</a></p> 
 <p id="%C2%A0%E4%BA%94%EF%BC%8CDI-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%BA%94%EF%BC%8CDI" rel="nofollow"> 五，DI</a></p> 
</blockquote> 
<hr id="hr-toc"> 
<p></p> 
<p>接上文<a href="https://blog.csdn.net/y2653904/article/details/140308476?spm=1001.2014.3001.5501" title="Java---SpringBoot详解一-CSDN博客">Java---SpringBoot详解一-CSDN博客</a></p> 
<h2 id="%E4%B8%80%EF%BC%8C%E7%BB%9F%E4%B8%80%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%9C">一，统一响应结果</h2> 
<p>之前我们返回的结果都是各自返回各自的，这样客户端解析的时候就非常麻烦，不便于封装，下面是我们想要的结果：</p> 
<p><img alt="" height="724" src="https://images2.imgbox.com/cb/d3/9w0iDrbS_o.png" width="1200"></p> 
<p>客户端只需要根据Result这一种格式解析就可以。</p> 
<p>下面我们创建一个Result类：</p> 
<pre><code class="language-java">package com.yuanzhen.yzjavatest.bean;

public class Result {

    private Integer code;//1成功，0失败
    private String msg;//提示信息
    private Object data;//数据date

    public Result() {
    }

    public Result(Integer code, String msg, Object data) {
        this.code = code;
        this.msg = msg;
        this.data = data;
    }

    public void setCode(Integer code) {
        this.code = code;
    }

    public void setMsg(String msg) {
        this.msg = msg;
    }

    public void setData(Object data) {
        this.data = data;
    }

    public Integer getCode() {
        return code;
    }

    public String getMsg() {
        return msg;
    }

    public Object getData() {
        return data;
    }

    public static Result success(Object data) {
        return new Result(1, "success", data);
    }

    public static Result success() {
        return new Result(1, "success", null);
    }

    public static Result error(String msg) {
        return new Result(0, msg, null);
    }

    @Override
    public String toString() {
        return "Result{" +
                "code=" + code +
                ", msg='" + msg + '\'' +
                ", data=" + data +
                '}';
    }
}
</code></pre> 
<p>对我们之前写的controller代码进行改造：</p> 
<pre><code class="language-java">@RestController
public class RequestController {

    @RequestMapping("/yzTestBean")
    public Result yzTestBean(User user){
        System.out.println("user:"+user);
        return  Result.success(user);
    }

    @RequestMapping("/yzTestList")
    public Result yzTestList(@RequestParam List&lt;String&gt; name){
        System.out.println("name:"+name);
        return  Result.success(name);
    }

    @RequestMapping("/yzTestDate")
    public Result yzTestDate(@DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss") LocalDateTime time){
        System.out.println("time:"+time);
        return  Result.success(time);
    }

    @RequestMapping("/yzTestJson")
    public Result yzTestJson(@RequestBody User user){
        System.out.println("user:"+user);
        return  Result.success(user);
    }

    @RequestMapping("/yzTestPath/{name}")
    public Result yzTestPath(@PathVariable String name){
        System.out.println("name:"+name);
        return  Result.success(name);
    }
}
</code></pre> 
<p>然后使用postman进行访问，看看效果：</p> 
<p><img alt="" height="712" src="https://images2.imgbox.com/dc/0f/I4hCr8bn_o.png" width="1200"></p> 
<p><img alt="" height="702" src="https://images2.imgbox.com/1d/b5/EBF7BSoj_o.png" width="1200"> </p> 
<p><img alt="" height="751" src="https://images2.imgbox.com/2a/cf/lLIliY3K_o.png" width="1200"> </p> 
<p> 至此，我们就把请求响应结果进行了统一。</p> 
<h2 id="%E4%BA%8C%EF%BC%8C%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84">二，三层架构</h2> 
<p>先看下下面这段代码：</p> 
<p><img alt="" height="824" src="https://images2.imgbox.com/14/a5/NZVDkOr8_o.png" width="1200"></p> 
<p> 所有逻辑都在controller里面，这就导致controller这个类非常庞大，逻辑复杂，代码混乱。</p> 
<p>因此，我们需要设计三层架构来解耦程序，是程序符合单一职责原则。</p> 
<p><img alt="" height="651" src="https://images2.imgbox.com/c3/6f/vizcN5Ei_o.png" width="1200"></p> 
<p> 下面写个例子来体验一下三层架构的好处：</p> 
<p>客户端发送姓名，服务端根据姓名查找具体用户信息，并将用户地址修改。</p> 
<p>首先创建DAO层：</p> 
<pre><code class="language-java">public interface IYZDao {
    /*
    * 根据用户姓名查找用户信息
    * **/
    User findUserByName(String name);
}</code></pre> 
<pre><code class="language-java">import com.yuanzhen.yzjavatest.dao.IYZDao;

public class YZDao implements IYZDao {
    @Override
    public User findUserByName(String name) {
        User user = new User();
        user.setName(name);
        user.setAge(20);
        Address address = new Address();
        address.setProvince("北京");
        address.setCity("北京");
        user.setAddress(address);
        return user ;
    }
}</code></pre> 
<p>然后创建Service层：</p> 
<pre><code class="language-java">public interface IYZService {
    /**
     * 处理用户信息
     * */
    User dealUser(String name);
}</code></pre> 
<pre><code class="language-java">public class YZService implements IYZService {

    private YZDao yzDao =new YZDao();

    @Override
    public User dealUser(String name) {
        User user = yzDao.findUserByName(name);
        Address address = new Address();
        address.setCity("淄博");
        address.setProvince("山东");
        user.setAddress(address);
        return user;
    }
}</code></pre> 
<p>最后改造controller层：</p> 
<pre><code class="language-java">@RestController
public class RequestController {


    private IYZService yzService = new YZService();

    @RequestMapping("/yzTestPath/{name}")
    public Result yzTestPath(@PathVariable String name){
        User user = yzService.dealUser(name);
        return  Result.success(user);
    }
}
</code></pre> 
<p>postman运行结果：</p> 
<p><img alt="" height="729" src="https://images2.imgbox.com/c3/1b/z0GAZr2E_o.png" width="1169"></p> 
<p>这样就实现了三层架构。</p> 
<h2 id="%C2%A0%E4%B8%89%EF%BC%8C%E5%88%86%E5%B1%82%E8%A7%A3%E8%80%A6"> 三，分层解耦</h2> 
<p>刚才我们的代码存在一个问题，就是层与层之间存在耦合关系：</p> 
<p><img alt="" height="645" src="https://images2.imgbox.com/9d/50/tJnDezln_o.png" width="805"></p> 
<p> 为了解耦，我们就不能通过直接创建对象的形式来实现，只能通过一个中间容器，将对象放到容器里面，需要的时候去容器里面取，这样就用到了控制反转和依赖注入：</p> 
<p><img alt="" height="59" src="https://images2.imgbox.com/b4/91/fP40uSQ3_o.png" width="705"></p> 
<p> 下面我们将上面的demo修改为分层解耦的：</p> 
<p>首先修改Dao层代码：</p> 
<pre><code class="language-java">@Component //将当前容器交给IOC容器管理 成为IOC容器中的bean
public class YZDao implements IYZDao {
    @Override
    public User findUserByName(String name) {
        User user = new User();
        user.setName(name);
        user.setAge(20);
        Address address = new Address();
        address.setProvince("北京");
        address.setCity("北京");
        user.setAddress(address);
        return user ;
    }
}</code></pre> 
<p>然后修改service层代码：</p> 
<pre><code class="language-java">@Component //将当前容器交给IOC容器管理 成为IOC容器中的bean
public class YZService implements IYZService {

    @Autowired  //运行时，IOC容器会提供该类型的bean对象，并赋值给该变量  这就是依赖注入
    private YZDao yzDao;

    @Override
    public User dealUser(String name) {
        User user = yzDao.findUserByName(name);
        Address address = new Address();
        address.setCity("淄博");
        address.setProvince("山东");
        user.setAddress(address);
        return user;
    }
}</code></pre> 
<p>最后修改controller层代码：</p> 
<pre><code class="language-java">@RestController
public class RequestController {

    @Autowired  //运行时，IOC容器会提供该类型的bean对象，并赋值给该变量  这就是依赖注入
    private IYZService yzService;

    @RequestMapping("/yzTestPath/{name}")
    public Result yzTestPath(@PathVariable String name){
        User user = yzService.dealUser(name);
        return  Result.success(user);
    }
}</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="758" src="https://images2.imgbox.com/24/3b/cK05G35y_o.png" width="1200"></p> 
<p>此时如果我们要实现一个新的service类：</p> 
<pre><code class="language-java">@Component
public class YZService2 implements IYZService {
   
    @Autowired  //运行时，IOC容器会提供该类型的bean对象，并赋值给该变量  这就是依赖注入
    private YZDao yzDao;

    @Override
    public User dealUser(String name) {
        User user = yzDao.findUserByName(name);
        Address address = new Address();
        address.setCity("淄博111");
        address.setProvince("山东111");
        user.setAddress(address);
        return user;
    }
}</code></pre> 
<p>然后将原来的YZService从容器中拿出来：</p> 
<pre><code class="language-java">//@Component //将当前容器交给IOC容器管理 成为IOC容器中的bean
public class YZService implements IYZService {

   // @Autowired  //运行时，IOC容器会提供该类型的bean对象，并赋值给该变量  这就是依赖注入
    private YZDao yzDao;

    @Override
    public User dealUser(String name) {
        User user = yzDao.findUserByName(name);
        Address address = new Address();
        address.setCity("淄博");
        address.setProvince("山东");
        user.setAddress(address);
        return user;
    }
}</code></pre> 
<p>只需要加两行注释就可以了。</p> 
<p>运行结果：</p> 
<p><img alt="" height="716" src="https://images2.imgbox.com/38/5c/g9wwW94e_o.png" width="1200"></p> 
<p>这样就实现了分层解耦。 </p> 
<h2 id="%E5%9B%9B%EF%BC%8CIOC">四，IOC</h2> 
<p>上面我们使用了Component注解，其实还有三个注解是项目中用的最多的：</p> 
<p><img alt="" height="155" src="https://images2.imgbox.com/93/21/CRv5Z2iB_o.png" width="698"></p> 
<p><img alt="" height="191" src="https://images2.imgbox.com/90/90/86Xe1jY3_o.png" width="1200"> <img alt="" height="168" src="https://images2.imgbox.com/31/bb/KGLDpfuL_o.png" width="1200"></p> 
<h2 id="%C2%A0%E4%BA%94%EF%BC%8CDI"> 五，DI</h2> 
<p><img alt="" height="669" src="https://images2.imgbox.com/67/5f/FxK76c7P_o.png" width="1200"></p> 
<p>使用Primary </p> 
<p>上面我们切换YZService2的时候，把YZService的注解注释掉了，其实还可以使用@Primary注解来处理：</p> 
<p>将YZService的注解放开：</p> 
<pre><code class="language-java">@Component //将当前容器交给IOC容器管理 成为IOC容器中的bean
public class YZService implements IYZService {

    @Autowired  //运行时，IOC容器会提供该类型的bean对象，并赋值给该变量  这就是依赖注入
    private YZDao yzDao;

    @Override
    public User dealUser(String name) {
        User user = yzDao.findUserByName(name);
        Address address = new Address();
        address.setCity("淄博");
        address.setProvince("山东");
        user.setAddress(address);
        return user;
    }
}</code></pre> 
<p>在YZService2上面添加Primary注解：</p> 
<pre><code class="language-java">@Primary
@Component
public class YZService2 implements IYZService {

    @Autowired  //运行时，IOC容器会提供该类型的bean对象，并赋值给该变量  这就是依赖注入
    private YZDao yzDao;

    @Override
    public User dealUser(String name) {
        User user = yzDao.findUserByName(name);
        Address address = new Address();
        address.setCity("淄博111");
        address.setProvince("山东111");
        user.setAddress(address);
        return user;
    }
}</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="724" src="https://images2.imgbox.com/89/16/ZZ30HVZy_o.png" width="1200"></p> 
<p> 使用Qualifier</p> 
<pre><code class="language-java">@RestController
public class RequestController {

    @Qualifier("YZService2")
    @Autowired  //运行时，IOC容器会提供该类型的bean对象，并赋值给该变量  这就是依赖注入
    private IYZService yzService;

    @RequestMapping("/yzTestPath/{name}")
    public Result yzTestPath(@PathVariable String name){
        User user = yzService.dealUser(name);
        return  Result.success(user);
    }
}</code></pre> 
<p>使用Resource：</p> 
<pre><code class="language-java">@RestController
public class RequestController {

   @Resource(name ="YZService2")
    private IYZService yzService;

    @RequestMapping("/yzTestPath/{name}")
    public Result yzTestPath(@PathVariable String name){
        User user = yzService.dealUser(name);
        return  Result.success(user);
    }
}</code></pre> 
<p><img alt="" height="712" src="https://images2.imgbox.com/2d/83/NOEpnHPP_o.png" width="1200"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/43bd299c8d898a02472a9f5249928311/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">快递查询｜阿里云实现调用API接口</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5ccd5667736cc3ee0bb4fb6caa88de06/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java Stream API详解：高效处理集合数据的利器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>