<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring AOP切面执行顺序深度解析：@Before, @After, @Around的协同作战 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/abbc3158a1c1974ef3160166f52283da/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Spring AOP切面执行顺序深度解析：@Before, @After, @Around的协同作战">
  <meta property="og:description" content="引言 在现代的软件开发中，代码的可维护性、可扩展性和可读性是至关重要的。为了解决这些问题，Aspect-Oriented Programming（AOP，面向切面编程）应运而生，它允许开发者在不改变原有代码的情况下，增加横切关注点，如日志记录、事务管理和权限校验等。在Spring框架中，AOP是一项核心功能，被广泛应用于各种业务场景，从而使代码更加模块化和可维护。
AOP通过切面（Aspect）来实现横切关注点的模块化。切面是一组包含多个通知（Advice）和切点（Pointcut）的类，其中通知定义了在特定切点上执行的逻辑，而切点定义了何处应用该逻辑。
Spring框架提供了一系列的注解来简化AOP的实现，包括@Before、@After、@Around等。这些注解使得开发者可以更容易地定义切面的行为，并控制它们在目标方法执行过程中的调用时机。
在本文中，我们将深入探讨这些注解在切面中的作用，以及它们如何协同工作以优化代码逻辑。特别是，我们将关注这些注解在执行顺序方面的细节，探索它们如何协同作战，以及如何在实际开发中合理运用这些知识。
通过本文的学习，读者将能够更加深入地理解Spring AOP的工作机制，掌握不同注解的使用技巧，并能够在实际项目中有效地应用这些知识，从而提高代码的质量和效率。现在，让我们开始这次关于Spring AOP切面执行顺序的深度解析之旅吧！
AOP基础知识回顾 什么是AOP？ Aspect-Oriented Programming（AOP）是一种编程范式，它旨在解决传统面向对象编程（OOP）中难以处理的问题，特别是那些横跨多个模块或层的横切关注点。这些关注点，如日志记录、事务管理和安全检查，通常散布在应用程序的多个部分中，导致代码重复和难以维护。
AOP的核心思想是通过将这些横切关注点从业务逻辑中分离出来，封装成单独的模块，这些模块被称为“切面”（Aspect）。通过这种方式，我们可以将横切关注点的实现从核心业务逻辑中解耦，使得代码更加模块化、清晰和易于维护。
AOP在Spring中的作用 在Spring框架中，AOP是一个重要的组成部分，广泛应用于各种功能，包括但不限于：
事务管理：通过AOP，Spring能够自动管理数据库事务，确保数据的一致性和完整性。
权限校验：AOP可以用于实现权限检查，确保用户只能访问他们被授权的资源。
日志记录：AOP可以捕获方法的执行，记录日志信息，提供审计和调试信息。
性能监控：通过AOP，我们可以监控方法的执行时间、调用次数等，对系统的性能进行实时监控和优化。
这些功能都能够大大提高开发效率，减少重复代码，同时也增强了系统的可维护性和可扩展性。
AOP的关键术语 在理解AOP的基础知识时，以下几个术语是非常重要的：
切点（Pointcut）：切点定义了何处应用切面的逻辑。它是一个表达式，描述了哪些方法或者类需要被切面拦截。
连接点（Joinpoint）：连接点是程序执行过程中切面可以插入的点。通常，连接点是一个方法的执行。
通知（Advice）：通知是切面在连接点上执行的动作。在Spring AOP中，通知有多种类型，包括@Before、@After、@Around等。
切面（Aspect）：切面是切点和通知的结合，它定义了在何处应用通知的逻辑。一个切面可以包含多个切点和通知。
通过理解这些关键术语，我们可以更好地理解AOP的工作原理，以及如何在Spring框架中有效地应用它们来解决实际的编程问题。
Spring切面注解详解 Spring AOP 提供了一套强大的注解，以便开发者可以轻松地定义切面的行为。以下是对这些注解的详细解释和示例。
@Before注解 使用 @Before 注解的方法将在目标方法执行之前执行。这个通知可以用于设置前置条件、参数验证或者执行前的日志记录。
示例：
@Before(&#34;execution(* com.example.service.UserService.addUser(..))&#34;) public void beforeAddUser() { System.out.println(&#34;Before adding a user...&#34;); } @After注解 @After 注解的方法将在目标方法执行完毕后执行，无论目标方法是否成功完成。通常，这里可以进行资源清理或者后续处理。
示例：
@After(&#34;execution(* com.example.service.UserService.addUser(..))&#34;) public void afterAddUser() { System.out.println(&#34;After adding a user...&#34;); } @AfterReturning注解 @AfterReturning 注解的方法将在目标方法正常返回后执行。这是一个理想的地方来处理返回值，例如日志记录或者转换数据格式。
示例：
@AfterReturning(pointcut = &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-25T06:00:00+08:00">
    <meta property="article:modified_time" content="2024-04-25T06:00:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring AOP切面执行顺序深度解析：@Before, @After, @Around的协同作战</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4><a id="_1"></a>引言</h4> 
<p>在现代的软件开发中，代码的可维护性、可扩展性和可读性是至关重要的。为了解决这些问题，Aspect-Oriented Programming（AOP，面向切面编程）应运而生，它允许开发者在不改变原有代码的情况下，增加横切关注点，如日志记录、事务管理和权限校验等。在Spring框架中，AOP是一项核心功能，被广泛应用于各种业务场景，从而使代码更加模块化和可维护。</p> 
<p>AOP通过切面（Aspect）来实现横切关注点的模块化。切面是一组包含多个通知（Advice）和切点（Pointcut）的类，其中通知定义了在特定切点上执行的逻辑，而切点定义了何处应用该逻辑。</p> 
<p>Spring框架提供了一系列的注解来简化AOP的实现，包括@Before、@After、@Around等。这些注解使得开发者可以更容易地定义切面的行为，并控制它们在目标方法执行过程中的调用时机。</p> 
<p>在本文中，我们将深入探讨这些注解在切面中的作用，以及它们如何协同工作以优化代码逻辑。特别是，我们将关注这些注解在执行顺序方面的细节，探索它们如何协同作战，以及如何在实际开发中合理运用这些知识。</p> 
<p>通过本文的学习，读者将能够更加深入地理解Spring AOP的工作机制，掌握不同注解的使用技巧，并能够在实际项目中有效地应用这些知识，从而提高代码的质量和效率。现在，让我们开始这次关于Spring AOP切面执行顺序的深度解析之旅吧！</p> 
<h4><a id="AOP_13"></a>AOP基础知识回顾</h4> 
<h5><a id="AOP_15"></a>什么是AOP？</h5> 
<p>Aspect-Oriented Programming（AOP）是一种编程范式，它旨在解决传统面向对象编程（OOP）中难以处理的问题，特别是那些横跨多个模块或层的横切关注点。这些关注点，如日志记录、事务管理和安全检查，通常散布在应用程序的多个部分中，导致代码重复和难以维护。</p> 
<p>AOP的核心思想是通过将这些横切关注点从业务逻辑中分离出来，封装成单独的模块，这些模块被称为“切面”（Aspect）。通过这种方式，我们可以将横切关注点的实现从核心业务逻辑中解耦，使得代码更加模块化、清晰和易于维护。</p> 
<h5><a id="AOPSpring_21"></a>AOP在Spring中的作用</h5> 
<p>在Spring框架中，AOP是一个重要的组成部分，广泛应用于各种功能，包括但不限于：</p> 
<ul><li> <p><strong>事务管理</strong>：通过AOP，Spring能够自动管理数据库事务，确保数据的一致性和完整性。</p> </li><li> <p><strong>权限校验</strong>：AOP可以用于实现权限检查，确保用户只能访问他们被授权的资源。</p> </li><li> <p><strong>日志记录</strong>：AOP可以捕获方法的执行，记录日志信息，提供审计和调试信息。</p> </li><li> <p><strong>性能监控</strong>：通过AOP，我们可以监控方法的执行时间、调用次数等，对系统的性能进行实时监控和优化。</p> </li></ul> 
<p>这些功能都能够大大提高开发效率，减少重复代码，同时也增强了系统的可维护性和可扩展性。</p> 
<h5><a id="AOP_35"></a>AOP的关键术语</h5> 
<p>在理解AOP的基础知识时，以下几个术语是非常重要的：</p> 
<ul><li> <p><strong>切点（Pointcut）</strong>：切点定义了何处应用切面的逻辑。它是一个表达式，描述了哪些方法或者类需要被切面拦截。</p> </li><li> <p><strong>连接点（Joinpoint）</strong>：连接点是程序执行过程中切面可以插入的点。通常，连接点是一个方法的执行。</p> </li><li> <p><strong>通知（Advice）</strong>：通知是切面在连接点上执行的动作。在Spring AOP中，通知有多种类型，包括@Before、@After、@Around等。</p> </li><li> <p><strong>切面（Aspect）</strong>：切面是切点和通知的结合，它定义了在何处应用通知的逻辑。一个切面可以包含多个切点和通知。</p> </li></ul> 
<p>通过理解这些关键术语，我们可以更好地理解AOP的工作原理，以及如何在Spring框架中有效地应用它们来解决实际的编程问题。</p> 
<h4><a id="Spring_49"></a>Spring切面注解详解</h4> 
<p>Spring AOP 提供了一套强大的注解，以便开发者可以轻松地定义切面的行为。以下是对这些注解的详细解释和示例。</p> 
<h5><a id="Before_53"></a>@Before注解</h5> 
<p>使用 <code>@Before</code> 注解的方法将在目标方法执行之前执行。这个通知可以用于设置前置条件、参数验证或者执行前的日志记录。</p> 
<p><strong>示例：</strong></p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"execution(* com.example.service.UserService.addUser(..))"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">beforeAddUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Before adding a user..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="After_66"></a>@After注解</h5> 
<p><code>@After</code> 注解的方法将在目标方法执行完毕后执行，无论目标方法是否成功完成。通常，这里可以进行资源清理或者后续处理。</p> 
<p><strong>示例：</strong></p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@After</span><span class="token punctuation">(</span><span class="token string">"execution(* com.example.service.UserService.addUser(..))"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterAddUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"After adding a user..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="AfterReturning_79"></a>@AfterReturning注解</h5> 
<p><code>@AfterReturning</code> 注解的方法将在目标方法正常返回后执行。这是一个理想的地方来处理返回值，例如日志记录或者转换数据格式。</p> 
<p><strong>示例：</strong></p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@AfterReturning</span><span class="token punctuation">(</span>pointcut <span class="token operator">=</span> <span class="token string">"execution(* com.example.service.UserService.getUser(..))"</span><span class="token punctuation">,</span> returning <span class="token operator">=</span> <span class="token string">"user"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterReturningGetUser</span><span class="token punctuation">(</span><span class="token class-name">User</span> user<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"After returning from getUser method: "</span> <span class="token operator">+</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="AfterThrowing_92"></a>@AfterThrowing注解</h5> 
<p><code>@AfterThrowing</code> 注解的方法将在目标方法抛出异常后执行。这是一个处理异常和进行清理工作的好地方。</p> 
<p><strong>示例：</strong></p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@AfterThrowing</span><span class="token punctuation">(</span>pointcut <span class="token operator">=</span> <span class="token string">"execution(* com.example.service.UserService.*(..))"</span><span class="token punctuation">,</span> throwing <span class="token operator">=</span> <span class="token string">"exception"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterThrowing</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> exception<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Exception thrown: "</span> <span class="token operator">+</span> exception<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="Around_105"></a>@Around注解</h5> 
<p><code>@Around</code> 注解的方法将包围目标方法的执行，它可以在目标方法执行前后执行自定义逻辑。这是最灵活的通知类型。</p> 
<p><strong>示例：</strong></p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">"execution(* com.example.service.UserService.*(..))"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">around</span><span class="token punctuation">(</span><span class="token class-name">ProceedingJoinPoint</span> joinPoint<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Before method execution..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token class-name">Object</span> result <span class="token operator">=</span> joinPoint<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 执行目标方法</span>
    
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"After method execution..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这些注解为开发者提供了丰富的功能来定义切面的行为，它们可以组合使用以实现复杂的逻辑。</p> 
<h4><a id="_126"></a>切面执行顺序探究</h4> 
<p>为了充分理解Spring AOP中不同注解的执行顺序，我们需要深入研究它们在不同场景下的调用顺序。这对于开发者来说是非常重要的，因为它关系到切面的正确性和预期的行为。</p> 
<h5><a id="_130"></a>执行流程图</h5> 
<p>以下是一个简单的流程图，展示了不同注解在目标方法执行过程中的调用时机：</p> 
<pre><code>开始 --&gt; @Before --&gt; 目标方法 --&gt; @AfterReturning / @AfterThrowing --&gt; @After --&gt; 结束
</code></pre> 
<p>这个流程图简洁地展示了<code>@Before</code>注解在目标方法执行前调用，<code>@AfterReturning</code>或<code>@AfterThrowing</code>在目标方法执行后调用（取决于方法是否正常返回或抛出异常），最后<code>@After</code>总是在目标方法执行完毕后调用。</p> 
<h5><a id="BeforeAfterAround_140"></a>@Before、@After、@Around的执行顺序</h5> 
<p>在单个切面中，当同时使用<code>@Before</code>、<code>@After</code>和<code>@Around</code>注解时，它们的执行顺序如下：</p> 
<ol><li><code>@Before</code>：在目标方法执行前调用。</li><li><code>@Around</code>（前半部分）：包围目标方法的执行，首先执行<code>@Around</code>注解的前半部分。</li><li>目标方法：正常执行目标方法。</li><li><code>@Around</code>（后半部分）：包围目标方法的执行，接着执行<code>@Around</code>注解的后半部分。</li><li><code>@AfterReturning</code>或<code>@AfterThrowing</code>：根据目标方法的执行结果，<code>@AfterReturning</code>在正常返回时调用，<code>@AfterThrowing</code>在抛出异常时调用。</li><li><code>@After</code>：无论目标方法是否抛出异常，<code>@After</code>都会在目标方法执行完毕后调用。</li></ol> 
<h5><a id="_151"></a>同一切面不同注解的执行顺序</h5> 
<p>在同一个切面中，注解的执行顺序是固定的，从<code>@Before</code>开始，然后是<code>@Around</code>的前半部分，接着是目标方法，再是<code>@Around</code>的后半部分，最后是<code>@AfterReturning</code>或<code>@AfterThrowing</code>，最终是<code>@After</code>。</p> 
<h5><a id="_155"></a>不同切面间的执行顺序</h5> 
<p>当存在多个切面时，它们的执行顺序取决于它们在切面链中的顺序。在Spring AOP中，切面是按照它们在XML配置或<code>@Aspect</code>注解中的顺序应用的。默认情况下，Spring会按照切面声明的顺序执行切面。</p> 
<h4><a id="_159"></a>实际应用中的执行顺序示例</h4> 
<h5><a id="_161"></a>代码示例</h5> 
<p>考虑一个简单的用户服务类，我们想在添加用户时进行权限校验、记录日志和执行事务管理：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">{<!-- --></span>
    
    <span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"execution(* com.example.service.UserService.addUser(..))"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">checkPermission</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Checking permission..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">"execution(* com.example.service.UserService.addUser(..))"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">logBeforeAndAfter</span><span class="token punctuation">(</span><span class="token class-name">ProceedingJoinPoint</span> joinPoint<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Before adding user..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        joinPoint<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 调用目标方法</span>
        
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"After adding user..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token annotation punctuation">@AfterReturning</span><span class="token punctuation">(</span><span class="token string">"execution(* com.example.service.UserService.addUser(..))"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">commitTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Committing transaction..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token annotation punctuation">@AfterThrowing</span><span class="token punctuation">(</span><span class="token string">"execution(* com.example.service.UserService.addUser(..))"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rollbackTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Rolling back transaction..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="_195"></a>执行顺序分析</h5> 
<p>假设<code>addUser</code>方法正常执行，那么执行顺序如下：</p> 
<ol><li>Checking permission…</li><li>Before adding user…</li><li>After adding user…</li><li>Committing transaction…</li></ol> 
<p>如果<code>addUser</code>方法抛出异常：</p> 
<ol><li>Checking permission…</li><li>Before adding user…</li><li>Rolling back transaction…</li></ol> 
<p>这个示例清晰地展示了不同注解在目标方法执行过程中的执行顺序。</p> 
<p>这样的深度解析有助于我们更好地理解和掌握Spring AOP的工作机制，为我们在实际开发中合理应用AOP提供了有力的支持。</p> 
<h4><a id="_214"></a>可能遇到的问题及解决方案</h4> 
<p>在使用Spring AOP进行编程时，我们可能会遇到一些与切面执行顺序相关的问题。这些问题可能会导致功能不正常或性能下降。下面我们来详细探讨这些问题以及相应的解决方案。</p> 
<h5><a id="_218"></a>执行顺序的混乱问题</h5> 
<p>当不同切面或同一切面内部的注解顺序混乱时，可能会导致预期之外的行为。例如，如果<code>@After</code>在<code>@Around</code>之前执行，可能会影响事务的提交或日志记录。</p> 
<p><strong>解决方案</strong>：</p> 
<ul><li> <p><strong>明确注解的顺序</strong>：在同一个切面内，确保注解的顺序是明确的。一般来说，<code>@Before</code>应该在最前面，<code>@After</code>和<code>@Around</code>应该有明确的执行顺序。</p> </li><li> <p><strong>使用<code>@Order</code>注解</strong>：Spring提供了<code>@Order</code>注解来指定切面的执行顺序。值越小，优先级越高。</p> </li></ul> 
<h5><a id="_228"></a>切面依赖问题</h5> 
<p>有时一个切面的执行可能依赖于另一个切面。例如，一个切面可能需要在另一个切面执行完毕后才能执行。</p> 
<p><strong>解决方案</strong>：</p> 
<ul><li> <p><strong>使用<code>JoinPoint</code>参数</strong>：在<code>@Around</code>注解中，我们可以通过<code>ProceedingJoinPoint</code>参数来控制切面的执行顺序。</p> </li><li> <p><strong><code>@Order</code>注解</strong>：使用<code>@Order</code>注解可以明确指定切面的执行顺序，从而解决依赖问题。</p> </li></ul> 
<h5><a id="_238"></a>性能问题</h5> 
<p>不合理的切面设计可能会影响系统性能，尤其是当切面逻辑复杂或频繁调用时。</p> 
<p><strong>解决方案</strong>：</p> 
<ul><li> <p><strong>精简切点表达式</strong>：使用精确的切点表达式可以减少不必要的方法匹配，提高性能。</p> </li><li> <p><strong>避免过度使用<code>@Around</code></strong>：<code>@Around</code>比其他注解更消耗性能，应尽量避免过度使用。</p> </li></ul> 
<h5><a id="_248"></a>解决方案与最佳实践</h5> 
<ul><li> <p><strong>模块化切面逻辑</strong>：将不同的横切关注点分别实现在不同的切面中，可以提高代码的可读性和维护性。</p> </li><li> <p><strong>单元测试</strong>：编写单元测试可以帮助我们验证切面的行为是否符合预期，确保不会出现执行顺序的混乱或性能问题。</p> </li></ul> 
<h4><a id="Before_After_Around_254"></a>@Before, @After, @Around的协同工作</h4> 
<p>在Spring AOP中，<code>@Before</code>, <code>@After</code>, 和 <code>@Around</code> 这三种注解是最常用的切面执行注解。它们各自有其独特的功能和特点，但当它们组合在一起时，能够协同工作以实现更为复杂和灵活的业务逻辑。</p> 
<h5><a id="_258"></a>如何协调不同注解以优化逻辑</h5> 
<ol><li> <p><strong>@Before与@Around的结合</strong></p> <p>使用<code>@Before</code>可以在目标方法执行前进行预处理，例如权限检查或参数验证。而<code>@Around</code>则可以在目标方法前后进行包围，这样可以在<code>@Before</code>执行后，再进行一些额外的操作，如计时或日志记录。</p> <pre><code class="prism language-java"><span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"execution(* com.example.service.*.*(..))"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">beforeAdvice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 执行一些前置操作</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">"execution(* com.example.service.*.*(..))"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">aroundAdvice</span><span class="token punctuation">(</span><span class="token class-name">ProceedingJoinPoint</span> joinPoint<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 在目标方法执行前进行操作</span>
    <span class="token class-name">Object</span> result <span class="token operator">=</span> joinPoint<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 在目标方法执行后进行操作</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li><li> <p><strong>@After与@Around的结合</strong></p> <p>使用<code>@After</code>可以在目标方法执行完毕后进行后处理，例如资源释放或日志记录。结合<code>@Around</code>，我们可以在<code>@After</code>之前执行一些其他操作，然后在<code>@After</code>执行后进行资源的释放。</p> <pre><code class="prism language-java"><span class="token annotation punctuation">@After</span><span class="token punctuation">(</span><span class="token string">"execution(* com.example.service.*.*(..))"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterAdvice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 执行一些后置操作</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">"execution(* com.example.service.*.*(..))"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">aroundAdvice</span><span class="token punctuation">(</span><span class="token class-name">ProceedingJoinPoint</span> joinPoint<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 在目标方法执行前进行操作</span>
    <span class="token class-name">Object</span> result <span class="token operator">=</span> joinPoint<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 在目标方法执行后进行资源释放等操作</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li><li> <p><strong>@Before、@After、@Around的连续执行</strong></p> <p>有时，我们可能需要在<code>@Before</code>、<code>@Around</code>、和<code>@After</code>之间进行某种流程控制或数据共享。可以通过方法参数或者使用<code>ThreadLocal</code>来实现数据在各个通知间的传递。</p> </li></ol> 
<h5><a id="_302"></a>实际场景中的应用示例</h5> 
<p>假设我们有一个需求，需要对用户的操作进行日志记录，同时进行权限校验。</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"execution(* com.example.service.UserService.*(..))"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">checkPermission</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 检查用户权限</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">"execution(* com.example.service.UserService.*(..))"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">logAndExecute</span><span class="token punctuation">(</span><span class="token class-name">ProceedingJoinPoint</span> joinPoint<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 记录日志：方法开始</span>
    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Method {} starts."</span><span class="token punctuation">,</span> joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 执行目标方法</span>
    <span class="token class-name">Object</span> result <span class="token operator">=</span> joinPoint<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 记录日志：方法结束</span>
    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Method {} ends with result {}."</span><span class="token punctuation">,</span> joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@After</span><span class="token punctuation">(</span><span class="token string">"execution(* com.example.service.UserService.*(..))"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">releaseResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 释放资源，如数据库连接等</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这个示例中，<code>@Before</code>注解用于权限检查，<code>@Around</code>注解用于日志记录和方法执行，而<code>@After</code>注解用于资源释放。通过这三个注解的协同工作，我们可以清晰、高效地实现业务逻辑。</p> 
<h4><a id="_334"></a>结论</h4> 
<p>本文深入探讨了Spring AOP中<code>@Before</code>, <code>@After</code>, 和 <code>@Around</code> 这三种注解的协同作战及其在切面执行顺序中的作用。在现代软件开发中，切面编程已经成为解决众多横切关注点问题的有效手段，尤其在Spring框架中，其得到了广泛的应用。</p> 
<p>首先，我们从AOP的基础知识开始，介绍了AOP的定义、在Spring中的应用，以及相关的关键术语。这为后续的注解解析和执行顺序探究提供了坚实的理论基础。</p> 
<p>然后，我们深入探讨了<code>@Before</code>, <code>@After</code>, 和 <code>@Around</code> 这三种注解的具体特点和使用方法。通过具体的代码示例和执行顺序分析，我们展示了这三种注解在单个切面以及多个切面中的执行顺序和协同工作方式。</p> 
<p>在实际应用中，正确理解和合理使用这三种注解对于实现清晰、高效的业务逻辑至关重要。我们也分享了一些在实际开发中如何优化逻辑、解决可能遇到的问题以及遵循最佳实践的建议。</p> 
<p>总体来说，对切面执行顺序的深入理解和规划不仅可以提高代码的可维护性和可读性，还可以确保系统的健壮性和性能。在日益复杂的软件开发环境中，掌握这些核心概念和技术，将有助于开发者更加高效地构建出质量更高、功能更强大的应用程序。</p> 
<p>因此，对于任何希望在Spring AOP中更上一层楼的开发者来说，深入理解和掌握<code>@Before</code>, <code>@After</code>, 和 <code>@Around</code> 这三种注解的协同作战是非常必要的。这不仅可以让我们更好地利用AOP的强大功能，还可以提高我们在实际开发中的解决问题的能力和效率。</p> 
<h4><a id="_348"></a>参考资料</h4> 
<p>为了确保本文的内容准确、权威，以及为读者提供更深入的学习资源，我们列出了以下参考资料。这些资料不仅包括了官方文档和专业书籍，还有一些高质量的博客和教程，它们为我们的研究和分析提供了有力的支持和灵感。</p> 
<ol><li> <p><strong>Spring官方文档</strong></p> 
  <ul><li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop" rel="nofollow">Spring AOP官方文档</a><br> 这是Spring框架官方发布的AOP文档，涵盖了AOP的基础概念、注解、执行顺序等核心内容，是学习Spring AOP的首选资源。</li></ul> </li><li> <p><strong>《Spring实战》（Fourth Edition）</strong></p> 
  <ul><li>作者：Craig Walls<br> 这本书是Spring框架的经典之作，详细介绍了Spring的各个方面，包括AOP的应用和实践。书中有丰富的实例和案例，可以帮助读者更好地理解和应用Spring AOP。</li></ul> </li><li> <p><strong>Spring in Action 博客</strong></p> 
  <ul><li><a href="https://spring.io/blog" rel="nofollow">Spring in Action 博客</a><br> Spring官方博客不仅包含了最新的框架更新和功能介绍，还有许多深入的技术文章和教程，对于想要深入了解Spring的读者来说是一个非常宝贵的资源。</li></ul> </li><li> <p><strong>Baeldung</strong></p> 
  <ul><li><a href="https://www.baeldung.com/" rel="nofollow">Baeldung</a><br> Baeldung是一个知名的Java和Spring教程网站，提供了大量的Spring AOP教程和实用技巧，内容详实，适合不同层次的读者。</li></ul> </li><li> <p><strong>InfoQ Spring AOP相关文章</strong></p> 
  <ul><li><a href="https://www.infoq.com/spring-aop/" rel="nofollow">InfoQ Spring AOP文章列表</a><br> InfoQ是一个技术领域的在线新闻和文章发布平台，其中有许多关于Spring AOP的深入文章和访谈，能够提供更广泛的视角和理解。</li></ul> </li><li> <p><strong>GitHub Spring AOP示例项目</strong></p> 
  <ul><li><a href="https://github.com/spring-projects/spring-framework/tree/main/src/samples">Spring AOP示例代码</a><br> Spring框架在GitHub上维护了一系列示例项目，其中包括了Spring AOP的示例代码，可以直接查看和运行，对于实际操作有很大的帮助。</li></ul> </li></ol> 
<p>通过参考上述资料，读者不仅可以更全面地了解Spring AOP的各个方面，还可以深入到实际应用和最佳实践，从而更好地掌握和应用本文介绍的内容。这些资源将为您的学习和实践提供有力的支持，帮助您在Spring AOP的探索之路上走得更远、更稳、更高。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/615d86e4b7558d14da00c6a66182941d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【前端】什么是面包屑？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/65a59ef530cd061bd4e87efad6f3d7e3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Flutter】webview_flutter使用详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>