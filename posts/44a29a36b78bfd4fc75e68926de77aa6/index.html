<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;】C/C&#43;&#43;内存管理 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/44a29a36b78bfd4fc75e68926de77aa6/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;】C/C&#43;&#43;内存管理">
  <meta property="og:description" content="个人主页~
内存管理 一、C/C&#43;&#43;内存分布二、C语言中动态内存管理方式三、C&#43;&#43;内存管理方式1、new和delete操作内置类型2、new和delete操作自定义类型 四、operator new 和operator delete 函数五、new 和 delete 实现的原理1、内置类型2、自定义类型（1）new（2）delete（3）new[ ]（4）delete[ ] 六、定位new（placement new）表达式七、malloc和new、free和delete的区别八、内存泄漏1、内存泄漏的危害2、内存泄漏的种类3、避免内存泄漏的方法 九、抛异常及捕获异常 一、C/C&#43;&#43;内存分布 C/C&#43;&#43;中程序内存区域划分为栈、内存映射段、堆、数据段、代码段
栈：存放非静态局部变量、函数参数、返回值等等，是向下增长的
内存映射段：用于装载一个共享的动态内存库，做映射
堆：用于程序运行时动态内存分配，是向上增长的
数据段：存储全局变量和静态数据，也叫静态区
代码段：存储可执行的代码以及只读常量，也叫常量区
#include &lt;stdlib.h&gt; int a = 1; static int b = 1; void Test() { static int c = 1; int d = 1; int num1[10] = { 1, 2, 3, 4 }; char char2[] = &#34;abcd&#34;; const char* pchar3 = &#34;abcd&#34;; int* p1 = (int*)malloc(sizeof(int) * 4); int* p2 = (int*)calloc(4, sizeof(int)); int* p3 = (int*)realloc(p2, sizeof(int) * 4); free(p1); free(p3); } 栈中数据：d、num1、*num1、char2、*char2、pchar3、p1、p2、p3">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-16T18:10:23+08:00">
    <meta property="article:modified_time" content="2024-07-16T18:10:23+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;】C/C&#43;&#43;内存管理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/78/c4/Bt2rLumi_o.jpg" alt="在这里插入图片描述"><br> <a href="https://blog.csdn.net/s_little_monster?spm=1000.2115.3001.5343">个人主页~</a></p> 
<hr> 
<p></p> 
<div class="toc"> 
 <h4>内存管理</h4> 
 <ul><li><a href="#CC_6" rel="nofollow">一、C/C++内存分布</a></li><li><a href="#C_51" rel="nofollow">二、C语言中动态内存管理方式</a></li><li><a href="#C_56" rel="nofollow">三、C++内存管理方式</a></li><li><ul><li><a href="#1newdelete_60" rel="nofollow">1、new和delete操作内置类型</a></li><li><a href="#2newdelete_88" rel="nofollow">2、new和delete操作自定义类型</a></li></ul> 
  </li><li><a href="#operator_new_operator_delete__131" rel="nofollow">四、operator new 和operator delete 函数</a></li><li><a href="#new__delete__140" rel="nofollow">五、new 和 delete 实现的原理</a></li><li><ul><li><a href="#1_141" rel="nofollow">1、内置类型</a></li><li><a href="#2_144" rel="nofollow">2、自定义类型</a></li><li><ul><li><a href="#1new_145" rel="nofollow">（1）new</a></li><li><a href="#2delete_147" rel="nofollow">（2）delete</a></li><li><a href="#3new__150" rel="nofollow">（3）new[ ]</a></li><li><a href="#4delete__153" rel="nofollow">（4）delete[ ]</a></li></ul> 
  </li></ul> 
  </li><li><a href="#newplacement_new_156" rel="nofollow">六、定位new（placement new）表达式</a></li><li><a href="#mallocnewfreedelete_199" rel="nofollow">七、malloc和new、free和delete的区别</a></li><li><a href="#_216" rel="nofollow">八、内存泄漏</a></li><li><ul><li><a href="#1_217" rel="nofollow">1、内存泄漏的危害</a></li><li><a href="#2_222" rel="nofollow">2、内存泄漏的种类</a></li><li><a href="#3_225" rel="nofollow">3、避免内存泄漏的方法</a></li></ul> 
  </li><li><a href="#_236" rel="nofollow">九、抛异常及捕获异常</a></li></ul> 
</div> 
<p></p> 
<h2><a id="CC_6"></a>一、C/C++内存分布</h2> 
<p>C/C++中程序内存区域划分为栈、内存映射段、堆、数据段、代码段</p> 
<p>栈：存放非静态局部变量、函数参数、返回值等等，是向下增长的</p> 
<p>内存映射段：用于装载一个共享的动态内存库，做映射</p> 
<p>堆：用于程序运行时动态内存分配，是向上增长的</p> 
<p>数据段：存储全局变量和静态数据，也叫静态区</p> 
<p>代码段：存储可执行的代码以及只读常量，也叫常量区</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">static</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

	<span class="token keyword">int</span> num1<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

	<span class="token keyword">char</span> char2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"abcd"</span><span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> pchar3 <span class="token operator">=</span> <span class="token string">"abcd"</span><span class="token punctuation">;</span>

	<span class="token keyword">int</span><span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">calloc</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">*</span> p3 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">realloc</span><span class="token punctuation">(</span>p2<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">free</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>p3<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>栈中数据：d、num1、*num1、char2、*char2、pchar3、p1、p2、p3</p> 
<p>堆中数据：*p1、*p2、*p3</p> 
<p>数据段中数据：a、b、c</p> 
<p>代码段中数据：*pchar3</p> 
<h2><a id="C_51"></a>二、C语言中动态内存管理方式</h2> 
<p>C语言中动态内存管理的方式有malloc、calloc、realloc、free<br> 这里我们在以前的博文<a href="https://blog.csdn.net/s_little_monster/article/details/136978325?spm=1001.2014.3001.5501">动态内存管理</a>中有详细的介绍，这里我们可以移步来阅读一下，不做过多赘述</p> 
<h2><a id="C_56"></a>三、C++内存管理方式</h2> 
<p><strong>两个关键字：new和delete</strong></p> 
<h3><a id="1newdelete_60"></a>1、new和delete操作内置类型</h3> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 动态申请一个int类型的空间</span>
	<span class="token keyword">int</span><span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>
	<span class="token comment">// 动态申请一个int类型的空间并初始化为0</span>
	<span class="token keyword">int</span><span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 动态申请10个int类型的空间</span>
	<span class="token keyword">int</span><span class="token operator">*</span> p3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token comment">//动态申请10个int类型的空间并部分初始化</span>
	<span class="token keyword">int</span><span class="token operator">*</span> p4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">delete</span> p1<span class="token punctuation">;</span>
	<span class="token keyword">delete</span> p2<span class="token punctuation">;</span>
	<span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p3<span class="token punctuation">;</span>	
	<span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p4<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/ec/22/kUJfrzW9_o.png" alt="在这里插入图片描述"><br> new的对内置类型使用就是new后面加一个内置类型，返回一个该类型的指针，方括号是数组元素个数，圆括号是一个元素时初始化，花括号与数组的赋值相同，是数组元素初始化</p> 
<p>delete是与new配套使用的，要与new的类型一一对应，否则出现的问题是不可预料的，不同的编译器有不同的问题</p> 
<p><strong>申请和释放单个元素的空间用new和delete，申请和释放多个元素的空间用new[]和delete[]</strong></p> 
<p>new与delete，new[]与delete[]需要配套使用的原因是：new[]在开辟时会在最前边开辟一个int类型的空间用来存储[ ]的内容，也就是元素个数，而delete[]可以读取到前面这个空间，以此来达到调用元素个数次析构函数的结果，但是delete默认就是一个，只会调用第一个析构函数，虽然二者最后都会释放内存，但不匹配的使用会导致一些不可预料的事情发生，可能是内存泄漏甚至是内存损坏</p> 
<h3><a id="2newdelete_88"></a>2、new和delete操作自定义类型</h3> 
<p>new和delete比malloc等C语言的内存管理方式更强的地方之一就在于new和delete可以分别调用自定义类型的构造和析构函数，而malloc它们不行</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token operator">:</span> <span class="token function">_a</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A():"</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~A():"</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _a<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//自定义类型</span>
	A<span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token punctuation">(</span>A<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	A<span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">delete</span> p2<span class="token punctuation">;</span>
	<span class="token comment">//内置类型</span>
	<span class="token keyword">int</span><span class="token operator">*</span> p3 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">*</span> p4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>p3<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">delete</span> p4<span class="token punctuation">;</span>
	<span class="token comment">//多个自定义类型</span>
	A<span class="token operator">*</span> p5 <span class="token operator">=</span> <span class="token punctuation">(</span>A<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	A<span class="token operator">*</span> p6 <span class="token operator">=</span> <span class="token keyword">new</span> A<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>p5<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p6<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/fe/3e/MWqMbZkx_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/42/3f/oiV7m7GA_o.png" alt="在这里插入图片描述"><br> 图中我们可以很明显的看到，malloc是不调用构造函数的，free也是不调用析构函数的，而new和delete就可以</p> 
<h2><a id="operator_new_operator_delete__131"></a>四、operator new 和operator delete 函数</h2> 
<p>new和delete是用户进行动态内存申请和释放的操作符，operator new 和 operator delete 是系统提供的全局函数，是new和delete的底层函数，也就是说，new和delete是通过operator new 和operator delete 实现的申请和释放空间，下面我们来了解一下operator new 和operator delete的机制</p> 
<p>operator new：通过malloc来申请空间，当malloc申请空间成功后直接返回，当malloc申请失败后尝试执行用户设置的空间不足的应对措施，继续申请，否则就抛异常</p> 
<p>operator delete ：最终通过free来释放空间</p> 
<p>所以它们归根结底还是从C语言的根中生长的，最终还要回到malloc 和 free 中，只不过我们经过包装，使得它有更多的作用</p> 
<h2><a id="new__delete__140"></a>五、new 和 delete 实现的原理</h2> 
<h3><a id="1_141"></a>1、内置类型</h3> 
<p>如果申请的是内置类型的空间，new与malloc、free与delete基本相似，不同点在于new在申请空间失败时会抛异常，而malloc会返回NULL</p> 
<h3><a id="2_144"></a>2、自定义类型</h3> 
<h4><a id="1new_145"></a>（1）new</h4> 
<p>首先调用operator new函数申请空间，然后在申请的空间上执行构造函数</p> 
<h4><a id="2delete_147"></a>（2）delete</h4> 
<p>首先在空间上执行析构函数，清理对象中的资源，然后调用operator delete函数释放对象的空间</p> 
<h4><a id="3new__150"></a>（3）new[ ]</h4> 
<p>首先调用operator new[ ]函数申请空间，实际上是调用多个operator new函数申请空间，然后在申请的空间上执行多个构造函数</p> 
<h4><a id="4delete__153"></a>（4）delete[ ]</h4> 
<p>首先在空间上执行多次析构函数，清理多个对象中的资源，然后调用operator delete[ ]函数释放对象的空间，也就是调用多个operator delete</p> 
<h2><a id="newplacement_new_156"></a>六、定位new（placement new）表达式</h2> 
<p>定位new的表达式是在已分配的原始内存空间中调用构造函数初始化一个对象</p> 
<p>格式：<strong>new(指针) type</strong> 或者 <strong>new(指针) type(类型的初始化列表)</strong></p> 
<p>场景：配合内存池使用，因为内存池分配出的内存没有初始化，如果是自定义类型的对象，就需要使用new的定义表达式进行显示调用构造函数进行初始化<br> （内存池是在真正使用内存之前，预先分配一定数量的、大小相等或相近的内存块留作备用。当有新的内存需求时，就从内存池中分配一块内存块，若内存块不够则继续申请新的内存块）</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token operator">:</span> <span class="token function">_a</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A():"</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~A():"</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _a<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// p1现在指向的是与A对象相同大小的一段空间，不是一个对象，因为构造函数没有执行</span>
	A<span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token punctuation">(</span>A<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 如果A类的构造函数有参数时，此处需要传参</span>
	<span class="token keyword">new</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span>A<span class="token punctuation">;</span> 
	p1<span class="token operator">-&gt;</span><span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	A<span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token punctuation">(</span>A<span class="token operator">*</span><span class="token punctuation">)</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//初始化列表初始化</span>
	<span class="token keyword">new</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	p2<span class="token operator">-&gt;</span><span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/a8/43/4yZPIstJ_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="mallocnewfreedelete_199"></a>七、malloc和new、free和delete的区别</h2> 
<p>共同点：都从堆上申请空间，需要用户手动释放</p> 
<p>不同点：<br> （1）malloc和free是函数，new和delete是操作符</p> 
<p>（2）malloc申请空间不会初始化，new申请空间会初始化</p> 
<p>（3）malloc申请空间需要手动计算空间大小并传递，new只要在后边跟上空间的类型就可以自动计算空间大小，如果new多个对象只要在后边[ ]中加入指定对象个数就可以了</p> 
<p>（4）malloc的返回值为void*，在使用时需要强制类型转换，new的返回值就为后边所跟类型type的指针形式type*，不需要强制类型转换</p> 
<p>（5）malloc申请空间失败时返回NULL，所以使用时必须判空，new申请失败需要捕获异常</p> 
<p>（6）申请自定义类型的时候，malloc和free只会申请和释放空间，而new在申请空间后会调用构造函数完成对象的初始化，delete在释放空间后会调用析构函数完成空间中资源的清理</p> 
<h2><a id="_216"></a>八、内存泄漏</h2> 
<h3><a id="1_217"></a>1、内存泄漏的危害</h3> 
<p>内存泄漏我们在之前也提到过，它是指因为疏忽或错误造成程序未能释放已经不再使用的内存的情况，指应用程序分配某段内存后因为设计错误失去了对某段内存的控制，导致我们不能再使用这一块内存，而不是内存在物理上的消失</p> 
<p>长期运行的程序，比如说某某公司的服务器，如果出现内存泄漏影响会很大，会导致响应越来越慢，最终导致无可控制内存可用，程序卡死</p> 
<h3><a id="2_222"></a>2、内存泄漏的种类</h3> 
<p>（1）堆内存泄漏：就是malloc、calloc、realloc或者new从堆中申请的一块内存用完后必须调用free或new释放掉，不释放就会造成堆内存泄漏<br> （2）系统资源泄露：就是程序使用系统分配的资源没有使用对应的函数释放掉，导致系统资源的浪费</p> 
<h3><a id="3_225"></a>3、避免内存泄漏的方法</h3> 
<p>（1）工程前期良好的设计规范，养成良好的代码习惯，申请了内存用完就要释放</p> 
<p>（2）采用RAII思想或者智能指针来管理资源<br> （RAII ,也称为“资源获取就是初始化”，是C++语言的一种管理资源、避免泄漏的惯用法。C++标准保证任何情况下，已构造的对象最终会销毁，即它的析构函数最终会被调用。简单的说，RAII 的做法是使用一个对象，在其构造时获取资源，在对象生命期控制对资源的访问使之始终保持有效，最后在对象析构的时候释放资源）<br> （智能指针是存储指向动态分配（堆）对象指针的类。除了能够在适当的时间自动删除指向的对象外，他们的工作机制很像C++的内置指针。智能指针在面对异常的时候格外有用，因为他们能够确保正确的销毁动态分配的对象。他们也可以用于跟踪被多用户共享的动态分配对象）</p> 
<p>（3）在工作时有些公司内部的库中有检测功能</p> 
<p>（4）内存泄漏工具检测</p> 
<h2><a id="_236"></a>九、抛异常及捕获异常</h2> 
<p>需要一套关键字：try 和 catch，try用于包围可能抛出异常的代码，catch用于捕获并处理try中抛出的异常</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdexcept&gt;</span> <span class="token comment">// 包含std::runtime_error  </span></span>
<span class="token comment">//这个runtime_error是一个运行时错误，可以直接被捕获到</span>
<span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">try</span> 
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">throw</span> std<span class="token double-colon punctuation">::</span><span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"发生了运行时错误！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//new就有throw的功能，将错误抛出</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>runtime_error<span class="token operator">&amp;</span> e<span class="token punctuation">)</span> 
    <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"捕获到异常: "</span> <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token comment">//这里cerr是标准错误输出流，专门用来输出错误信息，当然用cout也一样可以</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"程序继续执行"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/20/4e/6F4FjmTk_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p>今日分享结束~</p> 
<p><img src="https://images2.imgbox.com/2c/51/Rr8AjDmz_o.jpg" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/15d01e77b4b8ba42b37d4188b988a134/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据类型与结构设计：Rust 语言的深度探索</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2e24b8fc4350ce892e92e05a739836e2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">RabbitMQ 和 RocketMQ 的区别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>