<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>分治精炼宝库-----快速排序运用(⌯꒪꒫꒪)੭ - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/e8b5ffc891b34ede354bd3e9ae94d9be/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="分治精炼宝库-----快速排序运用(⌯꒪꒫꒪)੭">
  <meta property="og:description" content="目录
一.基本概念:
一.颜色分类：
二.排序数组：
三.数组中的第k个最大元素：
解法一：快速选择算法
解法二：简单粗暴优先级队列
四.库存管理Ⅲ：
解法一：快速选择
解法二：简单粗暴排序
解法三：简单粗暴优先级队列
一.基本概念: 🐻在计算机科学中，分治法是一种很重要的算法。字面上的解释就是“分而治之”，就是把一个复杂的问题分成两个或则更多个相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法（快速排序，归并排序），傅立叶变换(快速傅立叶变换)……
任何一个可以用计算机求解的问题所需的计算时间都与其规模有关。问题的规模越小，越容易直接求解，解题所需的计算时间也越少。例如，对于n个元素的排序问题，当n=1时，不需任何计算。n=2时，只要作一次比较即可排好序。n=3时只要作3次比较即可，…。而当n较大时，问题就不那么容易处理了。要想直接解决一个规模较大的问题，有时是相当困难的。🧐分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。
当我们对分治算法有了以上的一定了解后，来练习几道题目加深理解~~
注（本文承接上文：分治精炼宝库----归并排序应用( ´◔︎ ‸◔︎`)_用分治法归并排序-CSDN博客）
一.颜色分类： 说明：这里我们用到的快速排序会使用数组分三块的思想（下文会详细说明），从数组中随机取一个元素key,将数组划分为三个区域，区域① &lt; key ，区域 ② = key ,区域③ &gt; key
题目链接：75. 颜色分类 - 力扣（LeetCode）
算法思路：
使用左指针left和右指针right来划分数组，初始时left为-1，right为数组长度n。遍历数组nums，使用变量i作为当前遍历的索引。如果nums[i]等于0，则将nums[i]与left&#43;1位置的值交换，并将left和i都加1。如果nums[i]等于1，则继续遍历下一个值。如果nums[i]等于2，则将nums[i]与right-1位置的值交换，并将right和i都减1。重复步骤4-6，直到遍历完成整个数组。 核心步骤：
代码详解：
class Solution { public void sortColors(int[] nums) { //将数组划分为三个区域[0,1,2] int n = nums.length; for(int i = 0,left = -1,right = n;i &lt; right;){ if(nums[i] == 0){ swap(nums,&#43;&#43;left,i&#43;&#43;); }else if(nums[i] == 1){ i&#43;&#43;; }else{ swap(nums,--right,i); } } } public void swap(int[] nums,int i,int j){ int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; } } 运行结果：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-30T22:22:04+08:00">
    <meta property="article:modified_time" content="2024-06-30T22:22:04+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">分治精炼宝库-----快速排序运用(⌯꒪꒫꒪)੭</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80.%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%3A-toc" style="margin-left:0px;"><a href="#%E4%B8%80.%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%3A" rel="nofollow">一.基本概念:</a></p> 
<p id="%E4%B8%80.%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%B8%80.%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB%EF%BC%9A" rel="nofollow">一.颜色分类：</a></p> 
<p id="%E4%BA%8C.%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%EF%BC%9A" rel="nofollow">二.排序数组：</a></p> 
<p id="%E4%B8%89.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%B8%89.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0%EF%BC%9A" rel="nofollow">三.数组中的第k个最大元素：</a></p> 
<p id="%E8%A7%A3%E6%B3%95%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95-toc" style="margin-left:40px;"><a href="#%E8%A7%A3%E6%B3%95%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95" rel="nofollow">解法一：快速选择算法</a></p> 
<p id="%E8%A7%A3%E6%B3%95%E4%BA%8C%EF%BC%9A%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97-toc" style="margin-left:40px;"><a href="#%E8%A7%A3%E6%B3%95%E4%BA%8C%EF%BC%9A%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97" rel="nofollow">解法二：简单粗暴优先级队列</a></p> 
<p id="%C2%A0%E5%9B%9B.%E5%BA%93%E5%AD%98%E7%AE%A1%E7%90%86%E2%85%A2%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%C2%A0%E5%9B%9B.%E5%BA%93%E5%AD%98%E7%AE%A1%E7%90%86%E2%85%A2%EF%BC%9A" rel="nofollow"> 四.库存管理Ⅲ：</a></p> 
<p id="%E8%A7%A3%E6%B3%95%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9-toc" style="margin-left:40px;"><a href="#%E8%A7%A3%E6%B3%95%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9" rel="nofollow">解法一：快速选择</a></p> 
<p id="%E8%A7%A3%E6%B3%95%E4%BA%8C%EF%BC%9A%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#%E8%A7%A3%E6%B3%95%E4%BA%8C%EF%BC%9A%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%E6%8E%92%E5%BA%8F" rel="nofollow">解法二：简单粗暴排序</a></p> 
<p id="%E8%A7%A3%E6%B3%95%E4%B8%89%EF%BC%9A%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E8%A7%A3%E6%B3%95%E4%B8%89%EF%BC%9A%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%EF%BC%9A" rel="nofollow">解法三：简单粗暴优先级队列</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80.%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%3A">一.基本概念:</h2> 
<p>🐻在计算机科学中，分治法是一种很重要的算法。<strong><span style="background-color:#ffd900;">字面上的解释就是“分而治之”，就是把一个复杂的问题分成两个或则更多个相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并</span></strong>。这个技巧是很多高效算法的基础，如排序算法（快速排序，归并排序），傅立叶变换(快速傅立叶变换)……</p> 
<p>　任何一个可以用计算机求解的问题所需的计算时间都与其规模有关。问题的规模越小，越容易直接求解，解题所需的计算时间也越少。例如，对于n个元素的排序问题，当n=1时，不需任何计算。n=2时，只要作一次比较即可排好序。n=3时只要作3次比较即可，…。而当n较大时，问题就不那么容易处理了。要想直接解决一个规模较大的问题，有时是相当困难的。🧐<strong><span style="background-color:#ffd900;">分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。</span></strong></p> 
<p>当我们对分治算法有了以上的一定了解后，来练习几道题目加深理解~~</p> 
<p>注（本文承接上文：<a href="https://blog.csdn.net/2302_79862386/article/details/139897805?spm=1001.2014.3001.5502" title="分治精炼宝库----归并排序应用( ´◔︎ ‸◔︎`)_用分治法归并排序-CSDN博客 ">分治精炼宝库----归并排序应用( ´◔︎ ‸◔︎`)_用分治法归并排序-CSDN博客</a>）</p> 
<h2 id="%E4%B8%80.%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB%EF%BC%9A">一.颜色分类：</h2> 
<p>说明：这里我们用到的快速排序会使用数组分三块的思想（下文会详细说明），从数组中随机取一个元素key,将数组划分为三个区域，区域① &lt; key ，区域 ② = key ,区域③ &gt; key</p> 
<p><img alt="" height="229" src="https://images2.imgbox.com/c2/b6/61dgf84p_o.png" width="555"></p> 
<p>题目链接：<a href="https://leetcode.cn/problems/sort-colors/description/" rel="nofollow" title="75. 颜色分类 - 力扣（LeetCode）">75. 颜色分类 - 力扣（LeetCode）</a></p> 
<p><img alt="" height="396" src="https://images2.imgbox.com/cf/0e/tXuKaUzt_o.png" width="399"></p> 
<blockquote> 
 <p><strong><span style="background-color:#ffd900;">算法思路：</span></strong></p> 
 <ol><li>使用左指针left和右指针right来划分数组，初始时left为-1，right为数组长度n。</li><li>遍历数组nums，使用变量i作为当前遍历的索引。</li><li>如果nums[i]等于0，则将nums[i]与left+1位置的值交换，并将left和i都加1。</li><li>如果nums[i]等于1，则继续遍历下一个值。</li><li>如果nums[i]等于2，则将nums[i]与right-1位置的值交换，并将right和i都减1。</li><li>重复步骤4-6，直到遍历完成整个数组。</li></ol> 
 <p><strong><span style="background-color:#ffd900;">核心步骤：</span></strong></p> 
 <p><img alt="" height="377" src="https://images2.imgbox.com/ca/ad/qf7V5ch6_o.png" width="588"></p> 
</blockquote> 
<p><strong>代码详解：</strong></p> 
<pre><code class="language-java">class Solution {
    public void sortColors(int[] nums) {
        //将数组划分为三个区域[0,1,2]
        int n = nums.length;
        for(int i = 0,left = -1,right = n;i &lt; right;){
            if(nums[i] == 0){
                swap(nums,++left,i++);
            }else if(nums[i] == 1){
                i++;
            }else{
                swap(nums,--right,i);
            }
        }
    }

    public void swap(int[] nums,int i,int j){
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
}</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="167" src="https://images2.imgbox.com/a7/00/ijO8OdpG_o.png" width="595"></p> 
<h2 id="%E4%BA%8C.%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%EF%BC%9A">二.排序数组：</h2> 
<p>题目链接：<a href="https://leetcode.cn/problems/sort-an-array/description/" rel="nofollow" title="912. 排序数组 - 力扣（LeetCode）">912. 排序数组 - 力扣（LeetCode）</a></p> 
<p><img alt="" height="454" src="https://images2.imgbox.com/05/df/dKvTjDki_o.png" width="386"></p> 
<p>这里我们使用快速排序来解决，首先，我们来一起看一下快速排序的核心框架：</p> 
<pre><code class="language-java">void sort(int[] nums, int lo, int hi) {
    if (lo &gt;= hi) {
        return;
    }
    // 对 nums[lo..hi] 进行切分
    // 使得 nums[lo..p-1] &lt;= nums[p] &lt; nums[p+1..hi]
    int p = partition(nums, lo, hi);
    // 去左右子数组进行切分
    sort(nums, lo, p - 1);
    sort(nums, p + 1, hi);
}</code></pre> 
<p><strong><span style="background-color:#ffd900;">快速排序的核心即是先将一个元素排好序，再将剩下的元素排好序</span></strong></p> 
<p> 快速排序的核心无疑是 <code>partition</code> 函数， <code>partition</code> 函数的作用是在 <code>nums[lo..hi]</code> 中寻找一个切分点 <code>p</code>，通过交换元素使得 <code>nums[lo..p-1]</code> 都小于等于 <code>nums[p]</code>，且 <code>nums[p+1..hi]</code> 都大于 <code>nums[p].</code></p> 
<p><strong><code>一个元素左边它小，右边都比它大，什么意思？不就是把它放到正确的排好序的位置上了吗？</code></strong></p> 
<p>所以 <code>partition</code> 函数干的事情，其实就是把 <code>nums[p]</code> 这个元素排好序了。</p> 
<p>一个元素被排好序了，然后呢？你再把剩下的元素排好序不就行了嘛，排序图解：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b1/5f/PUKg3c2D_o.gif"></p> 
<p>其实我们不难发现，拍好序的数组就是一颗二叉搜索树！快速排序的过程其实也就是构造一棵二叉搜索树的过程<img alt="" height="308" src="https://images2.imgbox.com/60/d8/FbzRtf2o_o.png" width="620"></p> 
<p> 但谈到二叉搜索树的构造，那就不得不说二叉搜索树不平衡的极端情况，极端情况下二叉搜索树会退化成一个链表，导致操作效率大幅降低。这也和快速排序是一样的道理，特别是数组元素都相同的情况下，时间复杂度会大幅上升。</p> 
<p><img alt="" height="244" src="https://images2.imgbox.com/e0/c4/vnTsKiag_o.png" width="538"></p> 
<p>为了避免这种情况，我们要引入随机性：</p> 
<p><img alt="" height="151" src="https://images2.imgbox.com/ee/78/5sLIVcSS_o.png" width="628"></p> 
<p>用代码表示就是（取left ~ right 区间的随机数，加上偏移量left）：</p> 
<pre><code class="language-java">int key = nums[new Random().nextInt(r - l + 1) + l];</code></pre> 
<blockquote> 
 <p>快排思路： </p> 
 <p>从数组中随机取一个元素key,将数组划分为三个区域，区域① &lt; key ，区域 ② = key ,</p> 
 <p>区域③ &gt; key，然后排序①区间和②区间即可</p> 
</blockquote> 
<p><strong>代码详解：</strong></p> 
<pre><code class="language-java">class Solution {
     public int[] sortArray(int[] nums) {
        quickSort(nums,0,nums.length - 1);
        return nums;
    }

    public void quickSort(int[] nums,int l,int r){
        if(l &gt;= r) return ;

        //设置一个随机数，然后将数组分为三块
        int key = nums[new Random().nextInt(r - l + 1) + l];
        int left = l - 1,cur = l,right = r + 1;
        while(cur &lt; right){
            if(nums[cur] &lt; key){
                swap(nums,++left,cur++);
            }else if(nums[cur] == key){
                cur++;
            }else{
                swap(nums,--right,cur);
            }
        }
        //在接着往后面找,此时数组区域[l,left] [left + 1,right - 1] [right,r]
        quickSort(nums,l,left);
        quickSort(nums,right,r);
    }

    public void swap(int[] nums,int i,int j){
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
}</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="145" src="https://images2.imgbox.com/9b/cd/gHL0cL2C_o.png" width="500"></p> 
<h2 id="%E4%B8%89.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0%EF%BC%9A">三.数组中的第k个最大元素：</h2> 
<p>题目链接：<a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/" rel="nofollow" title="215. 数组中的第K个最大元素 - 力扣（LeetCode）">215. 数组中的第K个最大元素 - 力扣（LeetCode）</a></p> 
<p><img alt="" height="539" src="https://images2.imgbox.com/db/96/ZMT1hdSB_o.png" width="521"></p> 
<h3 id="%E8%A7%A3%E6%B3%95%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95" style="background-color:transparent;">解法一：快速选择算法</h3> 
<blockquote> 
 <p>思路：</p> 
 <p>在快排中，当我们把数组「分成三块」之后： [l, left] [left + 1, right - 1] [right, r] ，我们可以通过计算每⼀个区间内元素的「个数」，进⽽推断出我们要找的元素是 在「哪⼀个区间」⾥⾯。那么我们可以直接去「相应的区间」去寻找最终结果就好了：</p> 
 <p><img alt="" height="288" src="https://images2.imgbox.com/70/4d/2i7XQccP_o.png" width="520"></p> 
</blockquote> 
<p> 代码详解：</p> 
<pre><code class="language-java">class Solution {
    public int findKthLargest(int[] nums, int k) {
        //快速选择算法，返回第k大的元素
        int res = quickSort(nums,0,nums.length - 1,k);
        return res;
    }

    public int quickSort(int[] nums,int l,int r,int k){
        //当只有一个元素或则区间不存在时，直接返回
        if(l &gt;= r) return nums[l];
        //数组分三块 [l,left][left + 1,right - 1][right,r]
        int key = nums[new Random().nextInt(r - l + 1) + l];
        int left = l - 1,cur = l,right = r + 1;
        while(cur &lt; right){
            if(nums[cur] &lt; key){
                swap(nums,++left,cur++);
            }else if(nums[cur] == key){
                cur++;
            }else{
                swap(nums,--right,cur);
            }
        }
        //分别对a b c 三个区间做判断，合适的区间
        int b = right - left - 1,c = r - right + 1;
        if(c &gt;= k) return quickSort(nums,right,r,k);
        else if(b + c &gt;= k) return key;
        //如果都不是，就去[l,left]区间找k - b - c大的元素
        else return quickSort(nums,l,left,k - b - c);
    }

    public void swap(int[] nums,int i,int j){
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
}</code></pre> 
<p>运行结果： </p> 
<p><img alt="" height="173" src="https://images2.imgbox.com/49/72/VzrEN8CD_o.png" width="631"></p> 
<h3 id="%E8%A7%A3%E6%B3%95%E4%BA%8C%EF%BC%9A%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97">解法二：简单粗暴优先级队列</h3> 
<p>代码详解：</p> 
<pre><code class="language-java">class Solution {
     public int findKthLargest(int[] nums, int k) {
        PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;((o1,o2)-&gt;{
            return o2.compareTo(o1);
        });
        for(int i = 0;i &lt; nums.length;i++){
            heap.offer(nums[i]);
        }
        int res = 0;
        for(int i = 0;i &lt; k;i++){
            res = heap.poll();
        }
        return res;
    }
}</code></pre> 
<p> 运行结果：</p> 
<p><img alt="" height="425" src="https://images2.imgbox.com/9e/f3/lkg9rh2e_o.png" width="1200"></p> 
<p></p> 
<h2 id="%C2%A0%E5%9B%9B.%E5%BA%93%E5%AD%98%E7%AE%A1%E7%90%86%E2%85%A2%EF%BC%9A"> 四.库存管理Ⅲ：</h2> 
<p>题目链接：<a href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/description/" rel="nofollow" title="LCR 159. 库存管理 III - 力扣（LeetCode）">LCR 159. 库存管理 III - 力扣（LeetCode）</a></p> 
<p><img alt="" height="464" src="https://images2.imgbox.com/ea/f9/6hLcDLAC_o.png" width="509"></p> 
<h3 id="%E8%A7%A3%E6%B3%95%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9">解法一：快速选择</h3> 
<blockquote> 
 <p> 思路：</p> 
 <p>在快排中，当我们把数组「分成三块」之后： [l, left] [left + 1, right - 1] [right, r] ，我们可以通过计算每⼀个区间内元素的「个数」，进⽽推断出最⼩的k个数在哪 些区间⾥⾯，那么我们可以直接去「相应的区间」继续划分数组即可：</p> 
 <p><img alt="" height="435" src="https://images2.imgbox.com/86/79/oKeCFH7s_o.png" width="508"></p> 
</blockquote> 
<p> 代码详解:</p> 
<pre><code class="language-java">class Solution {
    public int[] inventoryManagement(int[] stock, int k) {
        quickSort(stock,0,stock.length - 1,k);

        int[] res = new int[k];
        for(int i = 0;i &lt; k;i++){
            res[i] = stock[i];
        }
        return res;
    }

    public void quickSort(int[] nums,int l,int r,int k){
        if(l &gt;= r) return ;

        //随机取数
        int key = nums[new Random().nextInt(r - l + 1) + l];
        int left = l - 1,cur = l,right = r + 1;
        while(cur &lt; right){
            if(nums[cur] &lt; key){
                swap(nums,++left,cur++);
            }else if(nums[cur] == key){
                cur++;
            }else{
                swap(nums,--right,cur);
            }
        }
        //寻找区间最小k个值[l,left] [left + 1,right - 1][right,r]
        int a = left - l + 1,b = right - left - 1;
        if(a &gt; k) quickSort(nums,l,left,k);
        else if(a + b &gt;= k) return ;
        else quickSort(nums,right,r,k - a - b);
    }
    public void swap(int[] nums,int i,int j){
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
}</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="478" src="https://images2.imgbox.com/d2/a4/Pu1TmE5r_o.png" width="1200"></p> 
<h3 id="%E8%A7%A3%E6%B3%95%E4%BA%8C%EF%BC%9A%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%E6%8E%92%E5%BA%8F">解法二：简单粗暴排序</h3> 
<p>代码详解：</p> 
<pre><code class="language-java">class Solution {
    public int[] inventoryManagement(int[] stock, int cnt) {
        Arrays.sort(stock);
        int[] res = new int[cnt];
        for(int i = 0;i &lt; cnt;i++){
            res[i] = stock[i];
        }
        return res;
    }
}</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="132" src="https://images2.imgbox.com/f0/1f/SZgrsDGM_o.png" width="577"></p> 
<h3 id="%E8%A7%A3%E6%B3%95%E4%B8%89%EF%BC%9A%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%EF%BC%9A">解法三：简单粗暴优先级队列</h3> 
<p>代码详解：</p> 
<pre><code class="language-java">class Solution {
    public int[] inventoryManagement(int[] stock, int cnt) {
        PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;();
        for(int i = 0; i &lt; stock.length; i++){
            heap.offer(stock[i]);
        }
        int[] res = new int[cnt];
        for(int i = 0;i &lt; cnt;i++){
            res[i] = heap.poll();
        }
        return res;
    }
}</code></pre> 
<blockquote> 
 <p>参考资料：</p> 
 <p> <a href="https://www.cnblogs.com/xsyfl/p/6921687.html" rel="nofollow" title="五大常用算法之一：分治算法 - Will_Don - 博客园 (cnblogs.com)">五大常用算法之一：分治算法 - Will_Don - 博客园 (cnblogs.com)</a></p> 
 <p>《labuladong算法笔记》</p> 
 <p>封面来自：《hello 算法》</p> 
</blockquote> 
<p><strong>结语：</strong> <strong>写博客不仅仅是为了分享学习经历，同时这也有利于我巩固知识点，总结该知识点，由于作者水平有限，对文章有任何问题的还请指出，接受大家的批评，让我改进。同时也希望读者们不吝啬你们的点赞+收藏+关注，你们的鼓励是我创作的最大动力！</strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/3f/70/VvrpS30H_o.gif"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bb625b9c60ce28d4df47081a81d61c80/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">AI陪伴产品的情感设计：从孤独感到恋爱感评分：9/10</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c665e05b99501dd8ab240314bfdeb5c7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C&#43;&#43;深度探索】继承机制详解（一）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>