<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【MySQL】连接查询（JOIN 关键字）—— 图文详解：内连接(INNER JOIN)、外连接（OUTER JOIN）、左连接（LEFT JOIN）、左外连接、右连接、右外连接、全连接、全外连接 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/346329ae4fd5003874967263e1d20a8c/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【MySQL】连接查询（JOIN 关键字）—— 图文详解：内连接(INNER JOIN)、外连接（OUTER JOIN）、左连接（LEFT JOIN）、左外连接、右连接、右外连接、全连接、全外连接">
  <meta property="og:description" content="文章目录 连接查询驱动表连接查询分类 内连接（INNER JOIN）内连接 —— 等值连接内连接 —— 自然连接（NATURAL JOIN）内连接 —— 交叉连接 / 笛卡尔积（CROSS JOIN） 外连接（OUTER JOIN）外连接 —— 左连接（LEFT JOIN） / 左外连接（LEFT OUTER JOIN）拓展：左连接不包含内连接 外连接 —— 右连接（RIGHT JOIN） / 右外连接（RIGHT OUTER JOIN）拓展：右连接不包含内连接 外连接 —— 全连接 / 全外连接【注意】：FULL OUTER JOIN 关键字异常讨论拓展：全连接不包括内连接 我是一名立志把细节都说清楚的博主，欢迎【关注】🎉 ~
原创不易， 如果有帮助 ，记得【点赞】【收藏】 哦~ ❥(^_-)~
如有错误、疑惑，欢迎【评论】指正探讨，我会尽可能第一时间回复的，谢谢支持
连接查询 MySQL使用 JOIN 关键字连接多个表查询数据，主要使用的是嵌套循环连接算法（nested-loop join）。这种算法机制简单的理解可以类比为for循环遍历一样。
从驱动表中选取数据作为循环的基础数据，然后以这些数据作为 查询条件 到下一个表中进行循环遍历查询。循环往复。
这种算法的缺点是： 连接的表越多，循环嵌套的层数就越多，算法复杂度呈指数级增长。
对应的处理方法是： 我们在设计查询时，尽可能减少连接表的个数。
驱动表 驱动表： 在使用多表嵌套连接时，首先，会全表扫描该一个表作为查询条件，这个表叫做驱动表。然后用驱动表返回的结果集逐行去匹配的表，叫做被驱动表。
关于驱动表的详细说明及性能优化，本文不过多提及，感兴趣的可以看这篇文章：
【MySQL】驱动表、被驱动表详解。—— 性能优化。
连接查询分类 内连接（INNER JOIN） 等值连接（最常用）自然连接交叉连接 外连接（INNER JOIN） 左连接（LEFT JOIN） / 左外连接（LEFT OUTER JOIN）右连接（RIGHT JOIN） / 有外连接（RIGHT OUTER JOIN） 全连接 内连接（INNER JOIN） 内连接查询的是两张表的交集，即两张表都有的数据。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-08T09:34:05+08:00">
    <meta property="article:modified_time" content="2024-05-08T09:34:05+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【MySQL】连接查询（JOIN 关键字）—— 图文详解：内连接(INNER JOIN)、外连接（OUTER JOIN）、左连接（LEFT JOIN）、左外连接、右连接、右外连接、全连接、全外连接</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_9" rel="nofollow">连接查询</a></li><li><ul><li><a href="#_18" rel="nofollow">驱动表</a></li><li><a href="#_24" rel="nofollow">连接查询分类</a></li></ul> 
  </li><li><a href="#INNER_JOIN_36" rel="nofollow">内连接（INNER JOIN）</a></li><li><ul><li><a href="#___46" rel="nofollow">内连接 —— 等值连接</a></li><li><a href="#__NATURAL_JOIN_70" rel="nofollow">内连接 —— 自然连接（NATURAL JOIN）</a></li><li><a href="#____CROSS_JOIN_125" rel="nofollow">内连接 —— 交叉连接 / 笛卡尔积（CROSS JOIN）</a></li></ul> 
  </li><li><a href="#OUTER_JOIN_145" rel="nofollow">外连接（OUTER JOIN）</a></li><li><ul><li><a href="#__LEFT_JOIN__LEFT_OUTER_JOIN_159" rel="nofollow">外连接 —— 左连接（LEFT JOIN） / 左外连接（LEFT OUTER JOIN）</a></li><li><ul><li><a href="#_230" rel="nofollow">拓展：左连接不包含内连接</a></li></ul> 
   </li><li><a href="#__RIGHT_JOIN__RIGHT_OUTER_JOIN_244" rel="nofollow">外连接 —— 右连接（RIGHT JOIN） / 右外连接（RIGHT OUTER JOIN）</a></li><li><ul><li><a href="#_261" rel="nofollow">拓展：右连接不包含内连接</a></li></ul> 
   </li><li><a href="#_____278" rel="nofollow">外连接 —— 全连接 / 全外连接</a></li><li><ul><li><a href="#FULL_OUTER_JOIN__290" rel="nofollow">【注意】：FULL OUTER JOIN 关键字异常讨论</a></li><li><a href="#_306" rel="nofollow">拓展：全连接不包括内连接</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<p><strong><mark>我是一名立志把细节都说清楚的博主，欢迎【关注】🎉 ~</mark></strong></p> 
<p><strong><mark>原创不易， 如果有帮助 ，记得【点赞】【收藏】 哦~ ❥(^_-)~</mark></strong></p> 
<p><strong><mark>如有错误、疑惑，欢迎【评论】指正探讨，我会尽可能第一时间回复的，谢谢支持</mark></strong></p> 
<hr> 
<h2><a id="_9"></a>连接查询</h2> 
<p>MySQL使用 <code>JOIN</code> 关键字连接多个表查询数据，主要使用的是嵌套循环连接算法（nested-loop join）。这种算法机制简单的理解可以类比为for循环遍历一样。</p> 
<p>从驱动表中选取数据作为循环的基础数据，然后以这些数据作为 <strong>查询条件</strong> 到下一个表中进行循环遍历查询。循环往复。</p> 
<p><strong>这种算法的缺点是：</strong> 连接的表越多，循环嵌套的层数就越多，算法复杂度呈指数级增长。</p> 
<p><strong>对应的处理方法是：</strong> 我们在设计查询时，尽可能减少连接表的个数。</p> 
<h3><a id="_18"></a>驱动表</h3> 
<blockquote> 
 <p><strong>驱动表：</strong> 在使用多表嵌套连接时，首先，会全表扫描该一个表作为查询条件，这个表叫做驱动表。然后用驱动表返回的结果集逐行去匹配的表，叫做被驱动表。</p> 
</blockquote> 
<p>关于驱动表的详细说明及性能优化，本文不过多提及，感兴趣的可以看这篇文章：<br> <a href="https://blog.csdn.net/m0_50513629/article/details/138302970https://blog.csdn.net/m0_50513629/article/details/138302970">【MySQL】驱动表、被驱动表详解。—— 性能优化。</a></p> 
<h3><a id="_24"></a>连接查询分类</h3> 
<ul><li>内连接（INNER JOIN） 
  <ul><li>等值连接（最常用）</li><li>自然连接</li><li>交叉连接</li></ul> </li><li>外连接（INNER JOIN） 
  <ul><li>左连接（LEFT JOIN） / 左外连接（LEFT OUTER JOIN）</li><li>右连接（RIGHT JOIN） / 有外连接（RIGHT OUTER JOIN）</li></ul> </li><li>全连接</li></ul> 
<hr> 
<h2><a id="INNER_JOIN_36"></a>内连接（INNER JOIN）</h2> 
<p>内连接查询的是两张表的交集，即两张表都有的数据。</p> 
<p>内连接的驱动表：通常是数据量较少的表作为驱动表。</p> 
<p><img src="https://images2.imgbox.com/42/30/9uRWH5ZG_o.png" alt="内连接概念图"></p> 
<hr> 
<h3><a id="___46"></a>内连接 —— 等值连接</h3> 
<p>SQL 代码形式如下：</p> 
<pre><code class="prism language-sql"><span class="token comment"># FROM 两表 WHERE 连接。</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> A表 <span class="token punctuation">,</span> B表 <span class="token keyword">WHERE</span> A表<span class="token punctuation">.</span>id <span class="token operator">=</span> B表<span class="token punctuation">.</span>id<span class="token punctuation">;</span>

<span class="token comment"># JOIN ON 连接。</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> A表  <span class="token keyword">JOIN</span> B表 <span class="token keyword">ON</span> A表<span class="token punctuation">.</span>id <span class="token operator">=</span> B表<span class="token punctuation">.</span>id<span class="token punctuation">;</span>

<span class="token comment"># INNER JOIN ON 连接。</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> A表 <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> B表 <span class="token keyword">ON</span> A表<span class="token punctuation">.</span>id <span class="token operator">=</span> B表<span class="token punctuation">.</span>id<span class="token punctuation">;</span>

<span class="token comment"># 多JOIN ON 连接。</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> A表 
<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> B表 
	<span class="token keyword">ON</span> A表<span class="token punctuation">.</span>id <span class="token operator">=</span> B表<span class="token punctuation">.</span>id
<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> C表 
	<span class="token keyword">ON</span> B表<span class="token punctuation">.</span>id <span class="token operator">=</span> C表<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
</code></pre> 
<hr> 
<h3><a id="__NATURAL_JOIN_70"></a>内连接 —— 自然连接（NATURAL JOIN）</h3> 
<p>自然连接会在两个表中寻找那些名称相同的列，并且以这些列的值作为联接的条件。不需要我们指定连接条件。</p> 
<p><strong>案例说明</strong></p> 
<p>假设有两个表，一个是员工表 employees 和一个是部门表 departments。</p> 
<p><code>employees</code> 表:</p> 
<pre><code>+--------+------+-------------+--------+
| emp_id | name |  department | salary |
+--------+------+-------------+--------+
|      1 | John |       Sales |  50000 |
|      2 | Mary | Engineering |  60000 |
|      3 |  Bob |       Sales |  40000 |
+--------+------+-------------+--------+
</code></pre> 
<p><code>departments</code> 表:</p> 
<pre><code>+---------+-------------+
| dept_id |  department |
+---------+-------------+
|       1 |       Sales |
|       2 | Engineering |
|       3 |  Accounting |
+---------+-------------+
</code></pre> 
<p>如果我们想要找到所有员工及其部门的信息，我们可以使用自然连接来联接这两个表：</p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> employees
<span class="token keyword">NATURAL</span> <span class="token keyword">JOIN</span> departments<span class="token punctuation">;</span>
</code></pre> 
<p>这将返回两个表中同名的列 department 的值相等的那些行，因此结果集将是：</p> 
<pre><code>+--------+------+-------------+--------+---------+-------------+
| emp_id | name |  department | salary | dept_id |  department |
+--------+------+-------------+--------+---------+-------------+
|      1 | John |       Sales |  50000 |       1 |       Sales |
|      2 | Mary | Engineering |  60000 |       2 | Engineering |
+--------+------+-------------+--------+---------+-------------+
</code></pre> 
<p>注意，在这个例子中，emp_id 和 dept_id 是自然连接过程中被删除的重复列。</p> 
<p><strong>自然连接特点：</strong></p> 
<ul><li>如果两个表中有同名的非空列，并且列中的值相等，那么这一行会出现在结果集中。</li><li>如果两个表中有同名的列，但是列中的值不相等，那么这一行不会出现在结果集中。</li><li>如果两个表中有同名的列，但是至少有一个列是空的，那么这一行也不会出现在结果集中。</li><li>自然连接会删除重复的列，只保留一个同名的列。</li></ul> 
<p>因为自然连接的特点，我们无法指定连接列，这种写法给给我们带来了不确定性。如果以后数据模型变更导致原来可以自然连接的列，不能再自然连接了，导致数据查询异常。所以通常情况下，<strong>不推荐使用自然连接</strong>。</p> 
<hr> 
<h3><a id="____CROSS_JOIN_125"></a>内连接 —— 交叉连接 / 笛卡尔积（CROSS JOIN）</h3> 
<p>由没有联结条件的表关系返回的结果叫交叉连接，也叫笛卡儿积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。</p> 
<pre><code class="prism language-sql"><span class="token comment"># 笛卡尔积示例一：</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> A表 <span class="token keyword">JOIN</span> B表<span class="token punctuation">;</span>

<span class="token comment"># 笛卡尔积示例二：</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> A表<span class="token punctuation">,</span> B表<span class="token punctuation">;</span>
</code></pre> 
<hr> 
<p><strong><mark>我是一名立志把细节都说清楚的博主，欢迎【关注】🎉 ~</mark></strong></p> 
<p><strong><mark>原创不易， 如果有帮助 ，记得【点赞】【收藏】 哦~ ❥(^_-)~</mark></strong></p> 
<p><strong><mark>如有错误、疑惑 ，欢迎【评论】指正探讨，我会尽可能第一时间回复的，谢谢支持</mark></strong></p> 
<hr> 
<h2><a id="OUTER_JOIN_145"></a>外连接（OUTER JOIN）</h2> 
<p>外连接可以保留连接表所有的记录，包括这条记录没有匹配的记录也可以保留（以NULL形式出现）。</p> 
<p>保留表可以根据保留左表、右表、全表从而分为：</p> 
<ul><li>左连接/左外连接。</li><li>右连接/右外连接。</li><li>全连接/全外连接。</li></ul> 
<p>左表、右表的判断标准，是以包含 <code>JOIN</code> 的关键字作为基准（如：<code>LEFT JOIN</code> 、 <code>LEFT OUTER JOIN</code>、<code>RIGHT JOIN</code>、<code>RIGHT OUT JOIN</code>）：</p> 
<ul><li>关键字的左边称为左表。</li><li>关键字的右边称为右表。</li></ul> 
<hr> 
<h3><a id="__LEFT_JOIN__LEFT_OUTER_JOIN_159"></a>外连接 —— 左连接（LEFT JOIN） / 左外连接（LEFT OUTER JOIN）</h3> 
<p><img src="https://images2.imgbox.com/f8/db/QLEW9JT6_o.png" alt="左连接 / 左外连接"></p> 
<p>左连接会返回左表中的所有记录。如果右表中没有匹配的记录，则右表字段使用 <code>NULL</code> 填充。</p> 
<pre><code class="prism language-sql"><span class="token comment"># LEFT JOIN ON 连接。</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> A表  
<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> B表 
<span class="token keyword">ON</span> A表<span class="token punctuation">.</span>id <span class="token operator">=</span> B表<span class="token punctuation">.</span>id<span class="token punctuation">;</span>

<span class="token comment"># RIGHT JOIN ON 连接。</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> A表  
<span class="token keyword">RIGHT</span> <span class="token keyword">JOIN</span> B表 
<span class="token keyword">ON</span> A表<span class="token punctuation">.</span>id <span class="token operator">=</span> B表<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
</code></pre> 
<p><code>Employees</code> 表：</p> 
<pre><code>+----+----------+
| id | name     |
+----+----------+
| 1  | Alice    |
| 7  | Bob      |
| 11 | Meir     |
| 90 | Winston  |
| 3  | Jonathan |
+----+----------+
</code></pre> 
<p><code>EmployeeUNI</code> 表:</p> 
<pre><code>+----+-----------+
| id | unique_id |
+----+-----------+
| 3  | 1         |
| 11 | 2         |
| 90 | 3         |
+----+-----------+
</code></pre> 
<p>左连接SQL样例：</p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> 
    unique_id<span class="token punctuation">,</span> name
<span class="token keyword">FROM</span>
    Employees
<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span>
    EmployeeUNI
<span class="token keyword">ON</span>
    Employees<span class="token punctuation">.</span>id <span class="token operator">=</span> EmployeeUNI<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
</code></pre> 
<p>结果：</p> 
<pre><code>+-----------+----------+
| unique_id | name     |
+-----------+----------+
| null      | Alice    |
| null      | Bob      |
| 2         | Meir     |
| 3         | Winston  |
| 1         | Jonathan |
+-----------+----------+
</code></pre> 
<hr> 
<h4><a id="_230"></a>拓展：左连接不包含内连接</h4> 
<p><img src="https://images2.imgbox.com/f1/c2/xyJPvMjl_o.png" alt="左连接不包含内连接"></p> 
<p>模版样式：</p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> A表  
<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> B表 
<span class="token keyword">ON</span> A表<span class="token punctuation">.</span>id <span class="token operator">=</span> B表<span class="token punctuation">.</span>id
<span class="token keyword">WHERE</span> B表<span class="token punctuation">.</span>id <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span>
</code></pre> 
<hr> 
<h3><a id="__RIGHT_JOIN__RIGHT_OUTER_JOIN_244"></a>外连接 —— 右连接（RIGHT JOIN） / 右外连接（RIGHT OUTER JOIN）</h3> 
<p><img src="https://images2.imgbox.com/60/40/mnYVKJzK_o.png" alt="右连接（RIGHT JOIN） / 右外连接（RIGHT OUTER JOIN）"><br> 与左连接同理。<br> 右连接会返回右表中的所有记录。如果左表中没有匹配的记录，则左表字段使用 <code>NULL</code> 填充</p> 
<p>通常情况下，右连接会被习惯性的改写成左连接。效果是一样的，左连接的可读性更好点。</p> 
<p>模版样式：</p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> A表  
<span class="token keyword">RIGHT</span> <span class="token keyword">JOIN</span> B表 
<span class="token keyword">ON</span> A表<span class="token punctuation">.</span>id <span class="token operator">=</span> B表<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
</code></pre> 
<hr> 
<h4><a id="_261"></a>拓展：右连接不包含内连接</h4> 
<p><img src="https://images2.imgbox.com/37/ab/Dfe20Rsb_o.png" alt="右连接不包含内连接"></p> 
<p>模版样式：</p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> A表  
<span class="token keyword">RIGHT</span> <span class="token keyword">JOIN</span> B表 
<span class="token keyword">ON</span> A表<span class="token punctuation">.</span>id <span class="token operator">=</span> B表<span class="token punctuation">.</span>id
<span class="token keyword">WHERE</span> A表<span class="token punctuation">.</span>id <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span>
</code></pre> 
<hr> 
<h3><a id="_____278"></a>外连接 —— 全连接 / 全外连接</h3> 
<p><img src="https://images2.imgbox.com/c3/52/k2Et0YKz_o.png" alt="全连接 / 全外连接"></p> 
<p>全连接（也称全外连接）一般没有什么意义，MySQL并不直接支持全外连接，但可以通过左右外连接的并集（UNION 关键字）来模拟实现。</p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> A表 <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> B表 <span class="token keyword">ON</span> A表<span class="token punctuation">.</span>id <span class="token operator">=</span> B表<span class="token punctuation">.</span>id
<span class="token keyword">UNION</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> A表 <span class="token keyword">RIGHT</span> <span class="token keyword">JOIN</span> B表 <span class="token keyword">ON</span> A表<span class="token punctuation">.</span>id <span class="token operator">=</span> B表<span class="token punctuation">.</span>id
</code></pre> 
<hr> 
<h4><a id="FULL_OUTER_JOIN__290"></a>【注意】：FULL OUTER JOIN 关键字异常讨论</h4> 
<p>网上部分教程出现的 <code>FULL OUTER JOIN</code> 关键词，但是MySQL并不直接支持全外连接，所以可能很多版本 <strong><mark>无法直接使用</mark></strong> <code>FULL OUTER JOIN</code> 关键词，至少我测试的版本是这样。所以在使用前建议测试一下。</p> 
<pre><code class="prism language-sql"><span class="token comment"># 错误SQL演示</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span>  A表
		<span class="token keyword">FULL</span> <span class="token keyword">OUTER</span> <span class="token keyword">JOIN</span> B表
<span class="token keyword">ON</span> A表<span class="token punctuation">.</span>id <span class="token operator">=</span> B表<span class="token punctuation">.</span>id
</code></pre> 
<p>为此我做了测试，我这里使用的 <code>MySQL 8.0.32</code> 版本，并不识别 <code>FULL OUTER JOIN</code> 关键词。并且执行搜索提示错误。</p> 
<p><img src="https://images2.imgbox.com/7a/ef/J8O9ne6e_o.png" alt="错误演示"></p> 
<hr> 
<h4><a id="_306"></a>拓展：全连接不包括内连接</h4> 
<p><img src="https://images2.imgbox.com/46/26/GGU9O33b_o.png" alt="全连接不包括内连接"></p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> A表 <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> B表 <span class="token keyword">ON</span> A表<span class="token punctuation">.</span>id <span class="token operator">=</span> B表<span class="token punctuation">.</span>id
<span class="token keyword">UNION</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> A表 <span class="token keyword">RIGHT</span> <span class="token keyword">JOIN</span> B表 <span class="token keyword">ON</span> A表<span class="token punctuation">.</span>id <span class="token operator">=</span> B表<span class="token punctuation">.</span>id
<span class="token keyword">WHERE</span> A表<span class="token punctuation">.</span>id <span class="token operator">IS</span> NULLOR B表<span class="token punctuation">.</span>id <span class="token operator">IS</span> <span class="token boolean">NULL</span>
</code></pre> 
<hr> 
<p><strong><mark>我是一名立志把细节都说清楚的博主，欢迎【关注】🎉 ~</mark></strong></p> 
<p><strong><mark>原创不易， 如果有帮助 ，记得【点赞】【收藏】 哦~ ❥(^_-)~</mark></strong></p> 
<p><strong><mark>如有错误、疑惑 ，欢迎【评论】指正探讨，我会尽可能第一时间回复的，谢谢支持</mark></strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8935c0900f98fef9233f8b8fcf58a583/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">FastAPI vs Flask: 选择最适合您的 Python Web 框架</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/09c01d22ae11ab600a26e3c6e81e5b78/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">DDD架构理论详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>