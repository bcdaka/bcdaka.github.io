<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数理知识】最小二乘法，从线性回归出发，数值举例并用最小二乘法求解回归模型 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b1f7b03e98099933be94332a3613ae93/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数理知识】最小二乘法，从线性回归出发，数值举例并用最小二乘法求解回归模型">
  <meta property="og:description" content="观前提醒：本章介绍了如何通过DI-engine使用DQN算法训练强化学习模型
一、什么是DQN算法
DQN算法，全称为Deep Q-Network算法，是一种结合了Q学习（一种价值基础的强化学习算法）和深度学习的算法。该算法是由DeepMind团队在2013年提出的，并在2015年通过在多款Atari 2600视频游戏上取得超越人类专家的表现而闻名。DQN算法是深度强化学习领域的一个里程碑，因为它展示了深度学习模型可以直接从原始输入（如像素）中学习控制策略。DQN 算法可以用来解决连续状态下离散动作的问题。
以图 中所示的所示的车杆（CartPole）环境为例，它的状态值就是连续的，动作值是离散的。
Q学习（Q-Learning）
在深入DQN之前，我们需要了解Q学习。Q学习是一种无模型（model-free）的强化学习算法，它学习在给定状态下采取各种行动的预期效用，即Q值（Q-value）。Q值函数Q(s, a)代表在状态s下采取行动a，并遵循最优策略所期望获得的累积回报。
Q学习的核心是Q表（Q-table），它存储了每个状态-动作对的Q值。然而，当状态空间或动作空间很大或连续时，Q表方法不再适用，因为它难以表示或更新这么大的表。这时候就需要DQN这类方法。
DQN的核心
DQN算法通过以下几个关键的技术改进来扩展Q学习的应用范围：
1.深度神经网络：
DQN使用深度神经网络来逼近Q值函数，而不是使用传统的Q表。这个网络称为Q网络，它的输入是状态，输出是每个可能动作的Q值。这使得算法可以应用于具有高维状态空间的问题，如直接从像素输入学习。
Q网络示意图：
1.经验回放（Experience Replay）：
DQN存储代理的经验（状态，动作，奖励，新状态）在一个数据集中，称为回放缓冲区（replay buffer）。在训练过程中，会在此数据集中随机抽取一批经验来更新网络。这有助于打破样本间的时间相关性，提高了学习稳定性。
2.固定Q目标（Fixed Q-Targets）：
在传统的Q学习中，Q表在每一步更新时都会用到，这会导致目标Q值和预测Q值在相同的过程中不断变化，从而可能导致学习过程不稳定。DQN引入了固定Q目标的概念，即在更新网络时，用于计算目标值的Q网络参数保持不变。具体来说，DQN会维护两个神经网络：一个在线网络（用于选择动作和学习）和一个目标网络（用于生成Q目标值）。目标网络的参数定期（或缓慢）地从在线网络复制过来。
DQN的更新规则
DQN的学习目标是最小化预测Q值和目标Q值之间的差异。目标Q值是通过使用贝尔曼方程（Bellman equation）计算得出的，即奖励加上下一个状态中最大Q值的折现值。更新规则可以通过以下损失函数来表达：
DQN的训练过程包括以下步骤：
1.初始化：
初始化在线网络和目标网络的参数。
在线网络和目标网络：在DQN（Deep Q-Network）算法中，”在线网络”和”目标网络”是两个并行使用的神经网络，它们有着相同的网络结构但是参数可能不同。这两个网络的引入旨在解决学习过程中可能出现的不稳定和发散问题。
在线网络，有时也被称为主网络（main network），是用来实际做决策和学习的网络。换句话说，它是与环境交互时用来评估当前状态并选择动作的网络。在每一步学习中，它也负责接收训练样本并通过梯度下降法更新自己的参数。在DQN中，在线网络输出给定状态下每个可能动作的预测Q值，然后根据这些Q值来选择动作（比如使用ε-贪婪策略）。在学习阶段，它还会根据从经验回放中抽取的样本来优化其参数，以减少预测Q值和目标Q值之间的误差。
目标网络是DQN算法中的关键创新之一。它的参数是在线网络参数的一个较为稳定的副本。目标网络不直接参与到决策或者收集经验的过程中，其主要作用是在计算目标Q值时提供一个稳定的目标。在DQN中，每隔一定的时间步，目标网络的参数会被更新为在线网络的参数，这样可以减少学习过程中的震荡和发散问题。在更新在线网络的参数时，使用目标网络的输出来计算目标Q值。具体而言，目标Q值是当前收到的奖励加上对下一个状态的最大Q值的折现。这里的最大Q值是由目标网络给出的，而不是在线网络。这种方法可以防止自我强化的反馈循环，因为目标网络的参数在优化过程中是固定的。在不断变化的数据（如强化学习中的状态和奖励）上训练一个网络时，如果使用即时更新的数据来计算目标值，会导致训练目标和网络参数之间的紧密耦合，这种耦合会使得学习过程变得非常不稳定。目标网络的使用就是为了解耦这两个元素，使得学习目标在短时间内保持稳定，从而有助于网络的稳定收敛。通过这种机制，目标网络在更新间隔期间保持不变，为在线网络提供一组稳定的目标来进行学习。这种做法类似于监督学习中的固定训练集，使得优化过程更加稳定和可靠。
1.数据收集：
通过与环境交互，按照ε-贪婪策略采取行动，并将经验（状态，动作，奖励，下一个状态）存储到回放缓冲区中。
ε-贪婪策略和回放缓冲区
ε-贪婪策略是一种在强化学习中用于控制探索和利用之间平衡的方法。在这种策略中：
_利用（Exploitation）_：代理选择它当前认为最优的动作，即根据Q值函数选择当前状态下Q值最高的动作。
_探索（Exploration）_：代理随机选择一个动作，与Q值无关，为了探索环境中尚未充分评估的状态或动作。
ε-贪婪策略通过一个参数ε（epsilon）来控制探索和利用的比例。ε通常设置为一个接近0但大于0的小数。在每个决策点：
以概率ε进行探索，即随机选择一个动作。
以概率1-ε进行利用，即选择Q值最高的动作。
随着学习的进行，ε的值通常会逐渐减小（例如，通过ε衰减），这意味着代理在学习初期会进行更多的探索，在学习后期则更倾向于利用其已学到的知识。
回放缓冲区（有时也称为经验回放），是用来存储代理与环境交互的经验的数据结构。
在DQN中，代理的每次动作、所观察到的下一个状态、获得的奖励以及是否达到终止状态等信息，都会作为一个元组（tuple）保存到回放缓冲区中。
存储这些经验的目的是：
打破样本间的时间相关性：强化学习中连续的状态转换和动作是高度相关的，这可能导致训练过程中的稳定性问题。通过从回放缓冲区中随机抽样，可以模
拟出一个更加独立同分布（i.i.d.）的数据集，从而提高学习算法的稳定性。
更高效地利用过去的经验：由于环境交互可能代价昂贵或时间消耗较大，通过重复使用历史数据来更新网络，可以更高效地利用这些数据，而不是使用一次
就丢弃。
点击DI-engine强化学习入门（二）如何训练和导出模型 - 古月居可查看全文">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-31T09:00:00+08:00">
    <meta property="article:modified_time" content="2024-05-31T09:00:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数理知识】最小二乘法，从线性回归出发，数值举例并用最小二乘法求解回归模型</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>观前提醒：本章介绍了如何通过DI-engine使用DQN算法训练强化学习模型</p> 
<p><strong>一、什么是DQN算法</strong><br> DQN算法，全称为Deep Q-Network算法，是一种结合了Q学习（一种价值基础的强化学习算法）和深度学习的算法。该算法是由DeepMind团队在2013年提出的，并在2015年通过在多款Atari 2600视频游戏上取得超越人类专家的表现而闻名。DQN算法是深度强化学习领域的一个里程碑，因为它展示了深度学习模型可以直接从原始输入（如像素）中学习控制策略。DQN 算法可以用来解决连续状态下离散动作的问题。<br> 以图 中所示的所示的车杆（CartPole）环境为例，它的状态值就是连续的，动作值是离散的。</p> 
<p class="img-center"><img alt="" height="213" src="https://images2.imgbox.com/7a/4d/xm2P7jYE_o.gif" width="320"></p> 
<p><strong>Q学习（Q-Learning）</strong><br> 在深入DQN之前，我们需要了解Q学习。Q学习是一种无模型（model-free）的强化学习算法，它学习在给定状态下采取各种行动的预期效用，即Q值（Q-value）。Q值函数Q(s, a)代表在状态s下采取行动a，并遵循最优策略所期望获得的累积回报。</p> 
<p>Q学习的核心是Q表（Q-table），它存储了每个状态-动作对的Q值。然而，当状态空间或动作空间很大或连续时，Q表方法不再适用，因为它难以表示或更新这么大的表。这时候就需要DQN这类方法。</p> 
<p><strong>DQN的核心</strong><br> DQN算法通过以下几个关键的技术改进来扩展Q学习的应用范围：</p> 
<p><strong>1.深度神经网络：</strong><br> DQN使用深度神经网络来逼近Q值函数，而不是使用传统的Q表。这个网络称为Q网络，它的输入是状态，输出是每个可能动作的Q值。这使得算法可以应用于具有高维状态空间的问题，如直接从像素输入学习。<br><strong>Q网络示意图：</strong></p> 
<p><img alt="" height="895" src="https://images2.imgbox.com/e8/31/9vJhCsrq_o.png" width="1149"></p> 
<p><strong>1.经验回放（Experience Replay）：</strong><br> DQN存储代理的经验（状态，动作，奖励，新状态）在一个数据集中，称为回放缓冲区（replay buffer）。在训练过程中，会在此数据集中随机抽取一批经验来更新网络。这有助于打破样本间的时间相关性，提高了学习稳定性。</p> 
<p><strong>2.固定Q目标（Fixed Q-Targets）：</strong><br> 在传统的Q学习中，Q表在每一步更新时都会用到，这会导致目标Q值和预测Q值在相同的过程中不断变化，从而可能导致学习过程不稳定。DQN引入了固定Q目标的概念，即在更新网络时，用于计算目标值的Q网络参数保持不变。具体来说，DQN会维护两个神经网络：一个在线网络（用于选择动作和学习）和一个目标网络（用于生成Q目标值）。目标网络的参数定期（或缓慢）地从在线网络复制过来。</p> 
<p><strong>DQN的更新规则</strong><br> DQN的学习目标是最小化预测Q值和目标Q值之间的差异。目标Q值是通过使用贝尔曼方程（Bellman equation）计算得出的，即奖励加上下一个状态中最大Q值的折现值。更新规则可以通过以下损失函数来表达：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/fc/54/gYlmaCj5_o.png"></p> 
<p><strong> DQN的训练过程包括以下步骤：</strong><br><strong>1.初始化：</strong><br> 初始化在线网络和目标网络的参数。<br><strong>在线网络和目标网络：</strong>在DQN（Deep Q-Network）算法中，”在线网络”和”目标网络”是两个并行使用的神经网络，它们有着相同的网络结构但是参数可能不同。这两个网络的引入旨在解决学习过程中可能出现的不稳定和发散问题。<br> 在线网络，有时也被称为主网络（main network），是用来实际做决策和学习的网络。换句话说，它是与环境交互时用来评估当前状态并选择动作的网络。在每一步学习中，它也负责接收训练样本并通过梯度下降法更新自己的参数。在DQN中，在线网络输出给定状态下每个可能动作的预测Q值，然后根据这些Q值来选择动作（比如使用ε-贪婪策略）。在学习阶段，它还会根据从经验回放中抽取的样本来优化其参数，以减少预测Q值和目标Q值之间的误差。<br> 目标网络是DQN算法中的关键创新之一。它的参数是在线网络参数的一个较为稳定的副本。目标网络不直接参与到决策或者收集经验的过程中，其主要作用是在计算目标Q值时提供一个稳定的目标。在DQN中，每隔一定的时间步，目标网络的参数会被更新为在线网络的参数，这样可以减少学习过程中的震荡和发散问题。在更新在线网络的参数时，使用目标网络的输出来计算目标Q值。具体而言，目标Q值是当前收到的奖励加上对下一个状态的最大Q值的折现。这里的最大Q值是由目标网络给出的，而不是在线网络。这种方法可以防止自我强化的反馈循环，因为目标网络的参数在优化过程中是固定的。在不断变化的数据（如强化学习中的状态和奖励）上训练一个网络时，如果使用即时更新的数据来计算目标值，会导致训练目标和网络参数之间的紧密耦合，这种耦合会使得学习过程变得非常不稳定。目标网络的使用就是为了解耦这两个元素，使得学习目标在短时间内保持稳定，从而有助于网络的稳定收敛。通过这种机制，目标网络在更新间隔期间保持不变，为在线网络提供一组稳定的目标来进行学习。这种做法类似于监督学习中的固定训练集，使得优化过程更加稳定和可靠。</p> 
<p><strong>1.数据收集：</strong><br> 通过与环境交互，按照ε-贪婪策略采取行动，并将经验（状态，动作，奖励，下一个状态）存储到回放缓冲区中。<br><strong>ε-贪婪策略和回放缓冲区</strong><br> ε-贪婪策略是一种在强化学习中用于控制探索和利用之间平衡的方法。在这种策略中：<br> _利用（Exploitation）_：代理选择它当前认为最优的动作，即根据Q值函数选择当前状态下Q值最高的动作。<br> _探索（Exploration）_：代理随机选择一个动作，与Q值无关，为了探索环境中尚未充分评估的状态或动作。<br> ε-贪婪策略通过一个参数ε（epsilon）来控制探索和利用的比例。ε通常设置为一个接近0但大于0的小数。在每个决策点：<br> 以概率ε进行探索，即随机选择一个动作。<br> 以概率1-ε进行利用，即选择Q值最高的动作。<br> 随着学习的进行，ε的值通常会逐渐减小（例如，通过ε衰减），这意味着代理在学习初期会进行更多的探索，在学习后期则更倾向于利用其已学到的知识。<br> 回放缓冲区（有时也称为经验回放），是用来存储代理与环境交互的经验的数据结构。<br> 在DQN中，代理的每次动作、所观察到的下一个状态、获得的奖励以及是否达到终止状态等信息，都会作为一个元组（tuple）保存到回放缓冲区中。<br> 存储这些经验的目的是：<br> 打破样本间的时间相关性：强化学习中连续的状态转换和动作是高度相关的，这可能导致训练过程中的稳定性问题。通过从回放缓冲区中随机抽样，可以模<br> 拟出一个更加独立同分布（i.i.d.）的数据集，从而提高学习算法的稳定性。<br> 更高效地利用过去的经验：由于环境交互可能代价昂贵或时间消耗较大，通过重复使用历史数据来更新网络，可以更高效地利用这些数据，而不是使用一次<br> 就丢弃。</p> 
<p>点击<a href="https://www.guyuehome.com/45653" rel="nofollow" title="DI-engine强化学习入门（二）如何训练和导出模型 - 古月居">DI-engine强化学习入门（二）如何训练和导出模型 - 古月居</a>可查看全文</p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4661389589009bd2a19833f9699f1aa4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">全面理解渗透测试</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/33935e4eccb40d0f4361bbe760eae1f3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">国产智能算力规模已超过27EFLOPS</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>