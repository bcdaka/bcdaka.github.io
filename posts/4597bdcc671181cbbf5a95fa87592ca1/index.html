<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;深度探索】全面解析多态性机制(二) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/4597bdcc671181cbbf5a95fa87592ca1/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;深度探索】全面解析多态性机制(二)">
  <meta property="og:description" content="🔥 个人主页：大耳朵土土垚 🔥 所属专栏：C&#43;&#43;从入门至进阶 这里将会不定期更新有关C/C&#43;&#43;的内容，欢迎大家点赞，收藏，评论🥳🥳🎉🎉🎉 前言 我们知道C&#43;&#43;多态实现有两个条件——一是基类的指针或引用调用虚函数，另一个是基类中有虚函数并且在派生类中实现虚函数重写；这两个条件缺一不可，这与多态实现的底层原理有关，今天我们就来学习一下多态实现的原理🥳🥳
目录 前言1.虚函数表2.派生类中的虚表情况一：只有基类有虚函数，派生类没有情况二：基类和派生类中都有虚函数，并且虚函数没有被重写情况三：基类中定义虚函数，并且派生类中对该虚函数进行了重写综合这三种情况 3.多态原理动态绑定与静态绑定 4.多继承中的虚函数表5.结语 1.虚函数表 虚函数表（Virtual Function Table，VTable）是C&#43;&#43;中实现动态多态性的一种机制。每个包含虚函数的类都有一个对应的虚函数表，用于存储该类的虚函数地址。
虚函数表是一个包含函数指针的数组，每个函数指针指向相应虚函数的实现。
也就是说在类中定义了虚函数，那么该类就会包含一个虚函数表来存放虚函数的函数指针，注意这里是指类中会存储虚函数表的指针来达到效果，因为如果虚函数很多，直接存储虚函数表可能会占用很多空间。
例如：
class Base { public: virtual void Func1() { cout &lt;&lt; &#34;Func1()&#34; &lt;&lt; endl; } private: int _b = 1; }; int main() { cout &lt;&lt; sizeof(Base) &lt;&lt; endl; return 0; } 当我们计算Base类的大小时，发现只有一个int类型的成员变量_b，所以应该是4个字节，但是我们可以看一下结果：
这里显示的是8字节，这是因为Base类中创建了虚函数，而每个包含虚函数的类都有一个对应的虚函数表，虚函数的地址要被放到虚函数表中，所以需要多余的空间来存储虚函数表的指针，这个指针我们叫做虚函数表指针。
如下图所示：
Base对象b中除了_b成员，还多一个__vfptr指针放在对象的前面(注意有些平台可能会放到对象的最后面，这个跟平台有关)，这个指针我们叫做虚函数表指针(v代表virtual，f代表function)。
注意是虚函数表的指针，而不是直接存储虚函数表。
因为上述例子是在32位操作系统下执行的，所以指针的大小是4字节，Base类大小是8字节；如果是64位那么指针的大小是8字节，Base类的大小就应该参考结构体内存对齐规则，应该是16字节。
2.派生类中的虚表 如果基类中没有虚函数，派生类中有虚函数，那么它的虚函数表和上面的一致。
例如：
class Base { private: int _b = 1; }; class Derive :public Base { public: virtual void Func2() { cout &lt;&lt; &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-13T21:47:28+08:00">
    <meta property="article:modified_time" content="2024-07-13T21:47:28+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;深度探索】全面解析多态性机制(二)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/49/ba/fK9TWzh9_o.jpg" alt="在这里插入图片描述"></p> 
<center> 
 <strong><font color="orange">🔥 个人主页：<a href="https://blog.csdn.net/Renswc?type=blog">大耳朵土土垚</a></font></strong> 
</center> 
<center> 
 <strong><font color="orange">🔥 所属专栏：<a href="https://blog.csdn.net/renswc/category_12630230.html">C++从入门至进阶</a></font></strong> 
</center> 
<center> 
 <strong> 这里将会不定期更新有关C/C++的内容，欢迎大家点赞，收藏，评论🥳🥳🎉🎉🎉 </strong> 
</center> 
<p><img src="https://images2.imgbox.com/c8/15/RsOEMo5A_o.gif" alt="在这里插入图片描述"></p> 
<h2><a id="_10"></a>前言</h2> 
<p>我们知道C++多态实现有两个条件——一是基类的指针或引用调用虚函数，另一个是基类中有虚函数并且在派生类中实现虚函数重写；这两个条件缺一不可，这与多态实现的底层原理有关，今天我们就来学习一下多态实现的原理🥳🥳<br> </p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_10" rel="nofollow">前言</a></li><li><a href="#1_14" rel="nofollow">1.虚函数表</a></li><li><a href="#2_55" rel="nofollow">2.派生类中的虚表</a></li><li><ul><li><a href="#_92" rel="nofollow">情况一：只有基类有虚函数，派生类没有</a></li><li><a href="#_127" rel="nofollow">情况二：基类和派生类中都有虚函数，并且虚函数没有被重写</a></li><li><a href="#_213" rel="nofollow">情况三：基类中定义虚函数，并且派生类中对该虚函数进行了重写</a></li><li><a href="#_257" rel="nofollow">综合这三种情况</a></li></ul> 
  </li><li><a href="#3_341" rel="nofollow">3.多态原理</a></li><li><ul><li><a href="#_395" rel="nofollow">动态绑定与静态绑定</a></li></ul> 
  </li><li><a href="#4_405" rel="nofollow">4.多继承中的虚函数表</a></li><li><a href="#5_469" rel="nofollow">5.结语</a></li></ul> 
</div> 
<p></p> 
<h2><a id="1_14"></a>1.虚函数表</h2> 
<p><strong>虚函数表</strong>（Virtual Function Table，VTable）是C++中实现动态多态性的一种机制。每个包含虚函数的类都有一个对应的虚函数表，用于存储该类的虚函数地址。</p> 
<p><strong>虚函数表</strong>是一个包含函数指针的<strong>数组</strong>，每个函数指针指向相应<strong>虚函数</strong>的实现。</p> 
<blockquote> 
 <p>也就是说在类中定义了虚函数，那么该类就会包含一个虚函数表来存放虚函数的函数指针，注意这里是指类中会存储虚函数表的指针来达到效果，因为如果虚函数很多，直接存储虚函数表可能会占用很多空间。</p> 
</blockquote> 
<p>例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Func1()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Base<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>当我们计算Base类的大小时，发现只有一个int类型的成员变量_b，所以应该是4个字节，但是我们可以看一下结果：</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/2a/77/A2TIvRLy_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>这里显示的是8字节，这是因为Base类中创建了虚函数，而每个包含虚函数的类都有一个对应的虚函数表，虚函数的地址要被放到虚函数表中，所以需要多余的空间来存储虚函数表的<strong>指针</strong>，这个指针我们叫做虚函数表指针。</p> 
</blockquote> 
<p>如下图所示：</p> 
<p><img src="https://images2.imgbox.com/98/0b/1rF0Wtca_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>Base对象b中除了_b成员，还多一个__vfptr指针放在对象的前面(注意有些平台可能会放到对象的最后面，这个跟平台有关)，这个指针我们叫做虚函数表指针(v代表virtual，f代表function)。</p> 
</blockquote> 
<p>注意是虚函数表的指针，而不是直接存储虚函数表。</p> 
<blockquote> 
 <p>因为上述例子是在32位操作系统下执行的，所以指针的大小是4字节，Base类大小是8字节；如果是64位那么指针的大小是8字节，Base类的大小就应该参考结构体内存对齐规则，应该是16字节。</p> 
</blockquote> 
<h2><a id="2_55"></a>2.派生类中的虚表</h2> 
<p>如果基类中没有虚函数，派生类中有虚函数，那么它的虚函数表和上面的一致。<br> 例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derive</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Func2()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _d <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Derive d<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>上述代码基类中没有虚函数也就不存在虚函数表，但派生类Derive类中存在虚函数，所以会存放一个虚函数表指针__vfptr，来指向虚函数表，而虚函数表中又会存放Derive类中虚函数的指针。</p> 
</blockquote> 
<p>如下图所示：</p> 
<p><img src="https://images2.imgbox.com/6d/c6/DfmpQkJq_o.png" alt="在这里插入图片描述"></p> 
<p>但是如果基类中有虚函数表，那么派生类该如何继承呢？</p> 
<h3><a id="_92"></a>情况一：只有基类有虚函数，派生类没有</h3> 
<p>例如：</p> 
<pre><code class="prism language-cpp"><span class="token comment">//情况一：只有基类有虚函数</span>
<span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Func1()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derive</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _d <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Derive d<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>d对象由两部分构成，一部分是父类继承下来的成员，另一部分是自己的成员，如下图所示：</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/bf/ca/D0KE6ukV_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>我们看到d对象继承了基类的成员变量_b和虚函数表的指针，虚函数表里面存放的是基类中虚函数<code>Func1()</code>的地址。</p> 
</blockquote> 
<h3><a id="_127"></a>情况二：基类和派生类中都有虚函数，并且虚函数没有被重写</h3> 
<p>例如：</p> 
<pre><code class="prism language-cpp"><span class="token comment">//情况二：基类和派生类中都有虚函数，并且虚函数没有被重写</span>
<span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Func1()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derive</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Func2()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _d <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Derive d<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>首先基类中有虚函数，所以派生类中包含基类的那部分成员肯定会包含基函数表的指针，但是派生类的虚函数应该怎么存放呢？结果如下图所示：</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/7e/8b/JkcmJ8zs_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>我们发现派生类并没有生成自己的虚函数表，所以它的虚函数应该存放在从基类继承下来的虚函数表中，上图中看到虚函数数组内只存放一个虚函数<code>Func1()</code>，没有派生类自己的虚函数<code>Fun2()</code>，这里是编译器的监视窗口故意隐藏了<code>Fun2()</code>函数，也可以认为是他的一个小bug，那么我们可以思考从打印虚函数地址的思路入手，查看<code>Fun1()</code>和<code>Fun2()</code>的地址是否是存放在一起。</p> 
</blockquote> 
<p>虚函数的地址存放在虚函数表中，而对象中前四个字节存放的是虚函数表的指针，所以我们可以使用强制类型转换取出对象的前四个字节，但是<code>int</code>类型与<code>Base</code>和<code>Derive</code>类型不兼容，不能相互转换，但是指针之间可以相互转换，所以我们考虑先取<code>Base</code>和<code>Derive</code>类对象的地址然后强制转换成<code>int*</code>类型，然后再解引用就得到了虚函数表的地址🥳🥳<br> 代码如下：</p> 
<pre><code class="prism language-cpp"><span class="token comment">//情况二：基类和派生类中都有虚函数，并且虚函数没有被重写</span>
<span class="token comment">//基类和派生类代码如上</span>

<span class="token comment">//先定义一个函数指针类型</span>
<span class="token keyword">typedef</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span>VFPTR<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//打印函数指针数组中存放的函数地址</span>
<span class="token keyword">void</span> <span class="token function">PrintVTable</span><span class="token punctuation">(</span>VFPTR vTable<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 依次取虚表中的虚函数指针打印并调用。调用就可以看出存的是哪个函数</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">" 虚表地址&gt;"</span> <span class="token operator">&lt;&lt;</span> vTable <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> vTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" 第%d个虚函数地址 :0X%x-&gt;"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> vTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		VFPTR f <span class="token operator">=</span> vTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用该函数</span>
	<span class="token punctuation">}</span>
	cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Base b<span class="token punctuation">;</span>
	Derive d<span class="token punctuation">;</span>
	<span class="token comment">//打印b对象中虚函数的地址</span>
	VFPTR<span class="token operator">*</span> vTableb <span class="token operator">=</span> <span class="token punctuation">(</span>VFPTR<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">PrintVTable</span><span class="token punctuation">(</span>vTableb<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">//打印d对象中虚函数的地址</span>
	VFPTR<span class="token operator">*</span> vTabled <span class="token operator">=</span> <span class="token punctuation">(</span>VFPTR<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">PrintVTable</span><span class="token punctuation">(</span>vTabled<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>结果如下：</p> 
<p><img src="https://images2.imgbox.com/57/cb/4sk4TTpg_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>我们发现基类对象和派生类对象的虚函数表是不同的，并且派生类对象虚函数表中存放了两个虚函数的地址，其中一个与基类的虚函数地址相同也就是<code>Func1()</code>的地址，另一个则是派生类自己定义的虚函数<code>Func2()</code>的地址。</p> 
</blockquote> 
<p>综上所述，如果派生类和基类都定义了自己的虚函数，并且基类的虚函数没有在派生类中重写的话，那么派生类中虚函数的地址会存放在派生类继承的基类那部分的虚函数表中的末尾，并且基类定义的对象和派生类定义的对象的虚函数表的地址是不同的。</p> 
<p><strong>同一类定义的不同对象使用的基函数表是同一个</strong>。<br> 如下图所示：</p> 
<p><img src="https://images2.imgbox.com/12/b9/U7A3wvG7_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_213"></a>情况三：基类中定义虚函数，并且派生类中对该虚函数进行了重写</h3> 
<p>例如：</p> 
<pre><code class="prism language-cpp"><span class="token comment">//情况三：基类中定义虚函数，并且派生类中对该虚函数进行了重写</span>
<span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base::Func1()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derive</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//重写虚函数Fun1()</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Derive::Func1()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _d <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Base b<span class="token punctuation">;</span>
	Derive d<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>按照之前的结论，派生类中的虚函数的地址是存放在继承的基类的虚函数表中的，那么对于重写的虚函数是写在基类虚函数表的末尾，还是将基类被重写的虚函数地址覆盖呢？</p> 
</blockquote> 
<p>结果如下图：</p> 
<p><img src="https://images2.imgbox.com/f4/a2/EiOBm0JZ_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>可以看到派生类的重写的虚函数的地址覆盖了继承的基类的虚函数的地址，我们还可以使用上文中打印虚函数地址的方式更加直观的看清楚：</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/3a/45/gd8nes6d_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>上述例子中基类b对象和派生类d对象虚表是不一样的，这里我们发现<code>Func1</code>完成了重写，所以d的虚表中存的是重写的<code>Derive::Func1</code>，所以虚函数的重写也叫作覆盖，覆盖就是指虚表中虚函数的覆盖。重写是语法的叫法，覆盖是原理层的叫法。</p> 
</blockquote> 
<h3><a id="_257"></a>综合这三种情况</h3> 
<ol><li>如果基类没有虚函数，子类有虚函数，那么子类会自己生成一个虚函数表来存放自己的虚函数；</li><li>如果基类有虚函数，子类也有自己的虚函数，那么子类中虚函数的地址会存放在子类继承的基类那部分的虚函数表中的末尾；</li></ol> 
<blockquote> 
 <p>注意虽然说是继承基类的虚函数表，但是基类对象和子类对象的虚函数表是不同的表，它们各自有各自的表。只是因为子类会继承基类的虚函数，所以基类的虚函数指针也会存在该子类的虚函数表中，相当于将基类的虚函数表直接继承下来，再将子类自己的虚函数指针存放进去，子类也就不用自己再生成一个虚函数表。</p> 
</blockquote> 
<ol start="3"><li>如果基类有虚函数，并且子类对该虚函数进行了重写，那么子类虚函数表中基类被重写的虚函数地址就会被子类重写的虚函数地址覆盖，而不再和第二点一样写在虚函数表的尾部。</li></ol> 
<p>例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base::Func1()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base::Func2()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">void</span> <span class="token function">Func3</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base::Func3()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derive</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//重写</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Derive::Func1()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _d <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Base b<span class="token punctuation">;</span>
	Derive d<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/f8/cc/hY36A1mu_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>基类b对象和派生类d对象虚表是不一样的，这里我们发现<code>Func1</code>完成了重写，所以d的虚表中存的是重写的<code>Derive::Func1</code>，另外<code>Func2</code>继承下来后是虚函数，所以放进了虚表，<code>Func3</code>也继承下来了，但是不是虚函数，所以不会放进虚表。</p> 
</blockquote> 
<p>虚函数表本质是一个存虚函数指针的指针数组，一般情况这个数组最后面放了一个<code>nullptr</code>。</p> 
<p>总结一下派生类的虚表生成：<br> a.先将基类中的虚表内容拷贝一份到派生类虚表中<br> b.如果派生类重写了基类中某个虚函数，用派生类自己的虚函数覆盖虚表中基类的虚函数<br> c.派生类自己新增加的虚函数按其在派生类中的声明次序增加到派生类虚表的最后。</p> 
<p>✨✨这里还有一个很容易混淆的问题：虚函数存在哪的？虚表存在哪的？</p> 
<blockquote> 
 <p>虚函数存在虚表，虚表存在对象中。注意上面的回答的错的。但是很多童鞋都是这样深以为然的。注意虚表存的是虚函数指针，不是虚函数，虚函数和普通函数一样的，都是存在代码段的，只是他的指针又存到了虚表中。另外对象中存的不是虚表，存的是虚表指针。那么虚表存在哪的呢？实际我们去验证一下会发现vs下是存在代码段的。</p> 
</blockquote> 
<p>代码如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">static</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token string">"aaaaa"</span><span class="token punctuation">;</span>
	Base b<span class="token punctuation">;</span>
	Derive d<span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"栈：%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"静态区：%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"堆：%p\n"</span><span class="token punctuation">,</span> p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"常量区：%p\n"</span><span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Base虚表地址：%p\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Derive虚表地址：%p\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>通过比较不同区域的地址来判断虚表地址在哪，发现虚表离常量区最近，如下图所示：</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/ee/a5/LFPrS7L2_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="3_341"></a>3.多态原理</h2> 
<p>了解了虚函数表我们就可以深入学习多态的原理。</p> 
<p>例如：</p> 
<pre><code class="prism language-cpp"><span class="token comment">//多态原理</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">BuyTicket</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"买票-全价"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">BuyTicket</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"买票-半价"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span>Person<span class="token operator">&amp;</span> p<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	p<span class="token punctuation">.</span><span class="token function">BuyTicket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Person Black<span class="token punctuation">;</span>
	<span class="token function">Func</span><span class="token punctuation">(</span>Black<span class="token punctuation">)</span><span class="token punctuation">;</span>

	Student tutu<span class="token punctuation">;</span>
	<span class="token function">Func</span><span class="token punctuation">(</span>tutu<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>对于买票这个行为，不同的对象会有不同的结果，普通人买票是全价，学生则可能是半价，如下图所示：</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/af/fa/ktcHCdVL_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>那么我们可以通过调试来看看它有不同结果的原因：</p> 
</blockquote> 
<p>当使用Person类对象调用函数Func时：</p> 
<p><img src="https://images2.imgbox.com/91/99/CWmhq6dY_o.png" alt="在这里插入图片描述"></p> 
<p>当使用Student类对象调用函数Func时：</p> 
<p><img src="https://images2.imgbox.com/bf/9d/jid2tSiL_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>我们看到，p是指向Black对象时，p-&gt;BuyTicket在Black的虚表中找到虚函数是Person::BuyTicket。p是指向tutu对象时，p-&gt;BuyTicket在tutu的虚表中找到虚函数Student::BuyTicket。</p> 
</blockquote> 
<blockquote> 
 <p>我们发现不同的对象调用Func函数时，使用的虚函数表是不同的，Person类对象和Student类对象都使用各自的虚函数表，所以调用不同的虚函数，如下图所示：</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/c7/d9/YPCMjTEx_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>这样就实现出了不同对象去完成同一行为时，展现出不同的形态。</p> 
</blockquote> 
<p>反过来思考我们要达到多态，有两个条件，一个是虚函数覆盖，一个是基类对象的指针或引用调用虚函数。具体原因，我们先要了解一下动态绑定。</p> 
<h3><a id="_395"></a>动态绑定与静态绑定</h3> 
<ul><li><strong>静态绑定</strong>又称为前期绑定(早绑定)，在程序编译期间确定了程序的行为，也称为静态多态，比如：函数重载</li><li><strong>动态绑定</strong>又称后期绑定(晚绑定)，是在程序运行期间，根据具体拿到的类型确定程序的具体行为，调用具体的函数，也称为动态多态。</li></ul> 
<p>那么当我们直接使用对象调用成员函数时走的是静态绑定，是指编译期间就确定的程序行为；当我们使用基类指针或引用调用虚函数时走的是动态绑定，需要通过虚函数表来确定不同对象调用不同的函数，根据具体拿到的类型确定程序的具体行为。</p> 
<blockquote> 
 <p>所以对于多态实现的两个条件，首先我们需要通过基类对象的指针或引用调用虚函数才能走动态绑定，其次派生类的虚函数还需要重写，这样不同类的对象使用的虚函数才是不一样的，才会显现不同的状态，实现多态。</p> 
</blockquote> 
<p>如果只是完成了虚函数的覆盖而没有通过基类对象的指针或引用调用，或者只有第二个条件都无法完成多态的实现。</p> 
<blockquote> 
 <p>多态实现的两个条件缺一不可。</p> 
</blockquote> 
<h2><a id="4_405"></a>4.多继承中的虚函数表</h2> 
<p>在多继承中，派生类会继承多个基类，每个基类都有自己的虚表。因此，派生类会有多个虚表，每个虚表对应于一个基类。</p> 
<blockquote> 
 <p>这是为了保证派生类能够正确调用和重写每个基类的虚函数。当派生类实例化时，会为每个基类分配一个虚表指针，这些虚表指针会存储在派生类对象的内存中。</p> 
</blockquote> 
<p>例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base1</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base1::func1"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base1::func2"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> b1<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Base2</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base2::func1"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base2::func2"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> b2<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derive</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base1</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">Base2</span></span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Derive::func1"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment">//重写Fun1()</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Derive::func3"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> d1<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//打印虚表地址以及虚函数地址</span>
<span class="token keyword">typedef</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span>VFPTR<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">PrintVTable</span><span class="token punctuation">(</span>VFPTR vTable<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">" 虚表地址&gt;"</span> <span class="token operator">&lt;&lt;</span> vTable <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> vTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" 第%d个虚函数地址 :0X%x,-&gt;"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> vTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		VFPTR f <span class="token operator">=</span> vTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Derive d<span class="token punctuation">;</span>
	<span class="token comment">//第一个虚表地址</span>
	VFPTR<span class="token operator">*</span> vTableb1 <span class="token operator">=</span> <span class="token punctuation">(</span>VFPTR<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">PrintVTable</span><span class="token punctuation">(</span>vTableb1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//找到第二个虚表的地址</span>
	VFPTR<span class="token operator">*</span> vTableb2 <span class="token operator">=</span> <span class="token punctuation">(</span>VFPTR<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>d <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Base1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">PrintVTable</span><span class="token punctuation">(</span>vTableb2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>结果如下：</p> 
<p><img src="https://images2.imgbox.com/2f/d7/VwaQxqpt_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>上图可以看出多继承派生类的未重写的虚函数<code>func3()</code>放在第一个继承基类部分的虚函数表中，图示如下：</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/c0/a4/roOnyXdm_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="5_469"></a>5.结语</h2> 
<p>虚函数表的存在是为了实现动态绑定也就是实现多态，当派生类对基类的虚函数进行重写时，通过基类对象指针和引用调用虚函数时，就会通过虚函数表来确定不同对象调用不同的函数，根据具体拿到的类型确定程序的具体行为，所以多态实现的两个条件缺一不可。以上就是今天所有的内容啦~ 完结撒花🥳🎉🎉</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d432a780c63e853f70a6f3287e505879/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">视频播放器的问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2717c9b1bc85aa6e15acc8ac998870cf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【模块化与包管理】：解锁【Python】编程的高效之道</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>