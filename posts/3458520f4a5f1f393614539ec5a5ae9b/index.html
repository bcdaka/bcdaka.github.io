<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Java】Comparator 的用法 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/3458520f4a5f1f393614539ec5a5ae9b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【Java】Comparator 的用法">
  <meta property="og:description" content="一、 Comparator 类 Comparator 类常作为 sorted() 方法的参数传递给 sorted 方法，用来解决给集合排序，自定义排序规则的问题 。
那从这个角度看，这个类肯定很常用了，一般都不喜欢自己写排序方法，而且自己写的肯定还有性能优化问题，我们直接用 jdk 帮我们封装好的，就即简洁，又易于阅读 。
二、使用 1. 对 Array 数组类型进行排序 下面是 Arrays 类暴露给我们的排序方法 —— sorted
Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator); Comparator 接口暴露给我们以下方法给我们实现：
int compare(T o1, T o2); （1）情况一 ： 直接 new Comparator 对象，然后实现其 compare 方法进行排序 这种情况可以在 compare 内部定义好排序规则，看起来非常直观，通过在 compare 中写好逻辑代码，可以实现多种排序规则 。
这种方式只能用于包装类型的数组，如果数组是基本数据类型，必须转成包装类才能使用实现 compare 方法进行定义排序
public static void test(){ // 对包装类型的数组进行排序 Integer[] a = {1, 2, 3, 0}; // 直接对 a 排序 Arrays.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-20T10:11:32+08:00">
    <meta property="article:modified_time" content="2024-03-20T10:11:32+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Java】Comparator 的用法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>一、 Comparator 类</h4> 
<p>Comparator 类常作为 sorted() 方法的参数传递给 sorted 方法，用来解决给集合排序，自定义排序规则的问题 。</p> 
<p>那从这个角度看，这个类肯定很常用了，一般都不喜欢自己写排序方法，而且自己写的肯定还有性能优化问题，我们直接用 jdk 帮我们封装好的，就即简洁，又易于阅读 。</p> 
<h4>二、使用</h4> 
<h5>1. 对 Array 数组类型进行排序</h5> 
<p>下面是 Arrays 类暴露给我们的排序方法 —— sorted</p> 
<pre><code class="language-java">Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator);</code></pre> 
<p>Comparator 接口暴露给我们以下方法给我们实现：</p> 
<pre><code class="language-java">int compare(T o1, T o2);</code></pre> 
<h6>（1）情况一 ： 直接 new Comparator 对象，然后实现其 compare 方法进行排序</h6> 
<p>这种情况可以在 compare 内部定义好排序规则，看起来非常直观，通过在 compare 中写好逻辑代码，可以实现多种排序规则 。</p> 
<p>这种方式只能用于包装类型的数组，如果数组是基本数据类型，必须转成包装类才能使用实现 compare 方法进行定义排序</p> 
<pre><code class="language-java">public static void test(){
    // 对包装类型的数组进行排序
    Integer[] a = {1, 2, 3, 0};
    // 直接对 a 排序
    Arrays.sort(a, new Comparator&lt;Integer&gt;() {
        @Override
        public int compare(Integer o1, Integer o2) {
            return o2 - o1;
        }
    });
    // 不对 a 排序，而是将 a 排序的结果给 a2
    Integer[] a2 = Arrays.stream(a).sorted(new Comparator&lt;Integer&gt;() {
        @Override
        public int compare(Integer o1, Integer o2) {
            return o2 - o1;
        }
    }).toArray(new IntFunction&lt;Integer[]&gt;() {
        @Override
        public Integer[] apply(int value) {
            return new Integer[value];
        }
    });

    // 对基本数据类型的数组进行排序 —— 不允许自定义排序规则
    int[] b = {1, 3, 2, 4};
    Arrays.sort(b);
    int[] b1 = Arrays.stream(b).sorted().toArray();
}</code></pre> 
<h6>（2）情况二： 使用 Comparator 提供的静态方法，链式的添加排序规则</h6> 
<p>这种方式也可以随意定制排序规则，而且相对来说，代码的可读性更高，如下实例：</p> 
<pre><code class="language-java">Integer[] a1 = Arrays.stream(a).sorted(Comparator.comparing(new Function&lt;Integer, Integer&gt;() {
    @Override
    public Integer apply(Integer integer) {
        return integer;
    }
}).reversed()).toArray(new IntFunction&lt;Integer[]&gt;() {
    @Override
    public Integer[] apply(int value) {
        return new Integer[value];
    }
});</code></pre> 
<h5>2. 对 Collection 集合类型进行排序</h5> 
<pre><code class="language-java">public void test2(){
    List&lt;Student&gt; list = new ArrayList&lt;&gt;();
    // 对 list 按照 先年龄 后 成绩的方式排序
    Collections.sort(list, Comparator.comparing(Student :: getAge).thenComparing(Student :: getScore));
    // 将 list 按照先成绩 再年龄 的方式排序，并将结果赋值给 list2
    List&lt;Student&gt; list2 = list.stream().sorted(Comparator.comparing(Student :: getScore).thenComparing(Student :: getAge)).collect(Collectors.toList());
}


class Student{
    int name;
    int age;
    int score;

    public int getName() {
        return name;
    }

    public void setName(int name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public int getScore() {
        return score;
    }

    public void setScore(int score) {
        this.score = score;
    }
}
</code></pre> 
<h5>3. compare方法的排序方式</h5> 
<p>在默认的compare方法中有两个参数o1和o2，这里以int类型为例</p> 
<pre><code class="language-java">List&lt;Integer&gt; ids = new ArrayList&lt;&gt;();
ids.add(1);
ids.add(2);
ids.add(33);
ids.add(4);
Collections.sort(ids, new Comparator&lt;Integer&gt;() {
    @Override
    public int compare(Integer o1, Integer o2) {
        return o1-o2;
    }
});</code></pre> 
<blockquote> 
 <p>TIPS：首先要知道 Collections.sort()方法进行排序的时候，sort里面默认是升序排序。这里一定要记住了。</p> 
</blockquote> 
<p>Java中默认是升序排序的，就是如果你重写了compare方法的逻辑，它不管你compare方法内部是怎么比较的，返回正整数则认为o1&gt;o2，返回0则认为o1=o2，返回负整数则认为o2&gt;o1，所以他会比较List集合中所有的元素，得到确定大小的结果进行升序排序。</p> 
<p>打个比方，还是这个代码块</p> 
<pre><code class="language-java">@Override
public int compare(Integer o1, Integer o2) {
    return o1-o2;
}</code></pre> 
<p>假如现在开始比较，o1的值为1，o2的值为2，那么return的就是1-2=-1，返回-1，那么在比较器中认为1&lt;2的，这个是正常思维的，但是假如把里面的返回逻辑改掉了，改成o2-o1，那么同样的o1=1，o2=2的情况下，返回的就是2-1=1，那么比较器就会认为1&gt;2，比较器就会把2排序的更前面一点（因为它认为2是小于1的），这样就变成了降序排序。</p> 
<h4> 三、总结</h4> 
<ul><li>直接创建 Comparator 类实例， 然后重写 compare 方法定义排序规则</li><li>使用 Comparator 静态方法进行排序，直接用类名调用进行排序，给方法传入相应的排序指标</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/642d8962f9a34ab56bc07ad8443eaaa7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">从 NCBI SRA 数据库下载文件——获取想要的数据</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/52bb92a418d70f184257f702213fac7d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">前端MQTT详细使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>