<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;入门到精通】C&#43;&#43; thread线程库 [ C&#43;&#43;入门 ] - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/a768ba39f83239e4f1a65f93cf7a3f31/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;入门到精通】C&#43;&#43; thread线程库 [ C&#43;&#43;入门 ]">
  <meta property="og:description" content="阅读导航 引言一、thread类的简单介绍二、thread类的用法1. 创建线程2. 使用 Lambda 表达式3. 传递参数给线程4. 线程的 join 和 detach5. 检查线程是否可 join6. 线程的 ID7. 线程的移动语义8. 线程的析构🚨 注意事项 三、线程函数参数温馨提示 引言 C&#43;&#43; thread线程库是C&#43;&#43;11标准引入的一个强大工具，它提供了一种便捷的方式来创建和管理线程，使得并行编程变得更加容易和高效。这个库支持线程的创建、同步、互斥以及线程局部存储等功能。通过使用std::thread类，开发者可以轻松地创建新的线程来执行任务，并使用join()方法来等待线程完成。此外，线程库还包括了std::mutex和std::lock_guard等同步原语，以帮助管理线程间的资源访问，防止数据竞争和死锁。线程局部存储std::thread::id和thread_local关键字则允许线程拥有自己的局部数据，这在多线程环境中非常有用。总的来说，C&#43;&#43; thread线程库为C&#43;&#43;开发者提供了一个功能全面、易于使用的多线程编程解决方案。让我们一起开始这段关于thread线程库的学习之旅吧。
一、thread类的简单介绍 std::thread 类是C&#43;&#43;11标准库中的一个核心组件，用于创建和管理独立的线程。它允许开发者通过传递一个函数或可调用对象来初始化线程，执行并行任务。线程对象的生命周期控制着线程的执行，而通过join()和detach()方法，可以控制线程的同步和分离。此外，std::thread还提供了线程ID和状态检查功能，帮助开发者进行线程管理和异常处理，确保程序的稳定性和效率。
🚨注意：要使用线程库中的线程，必须包含&lt;thread&gt;头文件。线程类官方介绍文档
下面这个表格包含了 std::thread 类的构造函数、赋值运算符、比较运算符以及一些用于线程管理的成员函数。这些函数提供了创建、管理、比较和销毁线程的能力.
函数名功能描述id get_id()返回线程的唯一标识符。bool joinable()检查线程是否可 join，即是否还在运行。void join()等待线程结束执行。void detach()将线程与 std::thread 对象分离，使其在后台独立运行。void swap(std::thread&amp; other)与另一个 std::thread 对象交换线程。thread::native_handle_type native_handle()返回线程的原生句柄，用于操作系统特定的线程操作。bool operator==(const thread&amp; other) const比较两个线程是否相同。bool operator!=(const thread&amp; other) const比较两个线程是否不同。thread() noexcept默认构造函数，创建一个未关联线程的 std::thread 对象。thread(nullptr_t) noexcept构造一个未关联线程的 std::thread 对象。explicit thread(Callable&amp;&amp; func, Args&amp;&amp;… args)构造函数，创建一个线程并启动它来执行给定的可调用对象和参数。thread(thread&amp;&amp; other) noexcept移动构造函数，获取另一个 std::thread 对象的所有权。thread&amp; operator=(thread&amp;&amp; other) noexcept移动赋值运算符，获取另一个 std::thread 对象的所有权。~thread()析构函数，如果线程可 join，则会调用 join()，否则调用 detach()。 二、thread类的用法 std::thread 类是 C&#43;&#43; 标准库中用于线程创建和管理的类。以下是 std::thread 类的一些关键用法和示例：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-03T16:38:17+08:00">
    <meta property="article:modified_time" content="2024-06-03T16:38:17+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;入门到精通】C&#43;&#43; thread线程库 [ C&#43;&#43;入门 ]</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/96/b9/moRnr8DA_o.jpg" alt="在这里插入图片描述"><br> </p> 
<div class="toc"> 
 <h4>阅读导航</h4> 
 <ul><li><a href="#_2" rel="nofollow">引言</a></li><li><a href="#thread_4" rel="nofollow">一、thread类的简单介绍</a></li><li><a href="#thread_26" rel="nofollow">二、thread类的用法</a></li><li><ul><li><a href="#1__29" rel="nofollow">1. 创建线程</a></li><li><a href="#2__Lambda__48" rel="nofollow">2. 使用 Lambda 表达式</a></li><li><a href="#3__65" rel="nofollow">3. 传递参数给线程</a></li><li><a href="#4__join__detach_81" rel="nofollow">4. 线程的 join 和 detach</a></li><li><a href="#5__join_97" rel="nofollow">5. 检查线程是否可 join</a></li><li><a href="#6__ID_113" rel="nofollow">6. 线程的 ID</a></li><li><a href="#7__128" rel="nofollow">7. 线程的移动语义</a></li><li><a href="#8__143" rel="nofollow">8. 线程的析构</a></li><li><a href="#__156" rel="nofollow">🚨 注意事项</a></li></ul> 
  </li><li><a href="#_163" rel="nofollow">三、线程函数参数</a></li><li><a href="#_194" rel="nofollow">温馨提示</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_2"></a>引言</h2> 
<p>C++ thread线程库是C++11标准引入的一个强大工具，它提供了一种便捷的方式来创建和管理线程，使得并行编程变得更加容易和高效。这个库支持线程的创建、同步、互斥以及线程局部存储等功能。通过使用<code>std::thread</code>类，开发者可以轻松地创建新的线程来执行任务，并使用<code>join()</code>方法来等待线程完成。此外，线程库还包括了<code>std::mutex</code>和<code>std::lock_guard</code>等同步原语，以帮助管理线程间的资源访问，防止数据竞争和死锁。线程局部存储<code>std::thread::id</code>和<code>thread_local</code>关键字则允许线程拥有自己的局部数据，这在多线程环境中非常有用。总的来说，C++ thread线程库为C++开发者提供了一个功能全面、易于使用的多线程编程解决方案。让我们一起开始这段关于<code>thread</code>线程库的学习之旅吧。</p> 
<h2><a id="thread_4"></a>一、thread类的简单介绍</h2> 
<p><code>std::thread</code> 类是C++11标准库中的一个核心组件，用于创建和管理独立的线程。它允许开发者通过传递一个函数或可调用对象来初始化线程，执行并行任务。线程对象的生命周期控制着线程的执行，而通过<code>join()</code>和<code>detach()</code>方法，可以控制线程的同步和分离。此外，<code>std::thread</code>还提供了线程ID和状态检查功能，帮助开发者进行线程管理和异常处理，确保程序的稳定性和效率。<br> 🚨<strong>注意</strong>：要使用线程库中的线程，<strong>必须包含&lt;thread&gt;头文件</strong>。<a href="https://cplusplus.com/reference/thread/thread/" rel="nofollow">线程类官方介绍文档</a></p> 
<p>下面这个表格包含了 <code>std::thread</code> 类的构造函数、赋值运算符、比较运算符以及一些用于线程管理的成员函数。这些函数提供了创建、管理、比较和销毁线程的能力.</p> 
<table><thead><tr><th>函数名</th><th>功能描述</th></tr></thead><tbody><tr><td>id get_id()</td><td>返回线程的唯一标识符。</td></tr><tr><td>bool joinable()</td><td>检查线程是否可 join，即是否还在运行。</td></tr><tr><td>void join()</td><td>等待线程结束执行。</td></tr><tr><td>void detach()</td><td>将线程与 <code>std::thread</code> 对象分离，使其在后台独立运行。</td></tr><tr><td>void swap(std::thread&amp; other)</td><td>与另一个 <code>std::thread</code> 对象交换线程。</td></tr><tr><td>thread::native_handle_type native_handle()</td><td>返回线程的原生句柄，用于操作系统特定的线程操作。</td></tr><tr><td>bool operator==(const thread&amp; other) const</td><td>比较两个线程是否相同。</td></tr><tr><td>bool operator!=(const thread&amp; other) const</td><td>比较两个线程是否不同。</td></tr><tr><td>thread() noexcept</td><td>默认构造函数，创建一个未关联线程的 <code>std::thread</code> 对象。</td></tr><tr><td>thread(nullptr_t) noexcept</td><td>构造一个未关联线程的 <code>std::thread</code> 对象。</td></tr><tr><td>explicit thread(Callable&amp;&amp; func, Args&amp;&amp;… args)</td><td>构造函数，创建一个线程并启动它来执行给定的可调用对象和参数。</td></tr><tr><td>thread(thread&amp;&amp; other) noexcept</td><td>移动构造函数，获取另一个 <code>std::thread</code> 对象的所有权。</td></tr><tr><td>thread&amp; operator=(thread&amp;&amp; other) noexcept</td><td>移动赋值运算符，获取另一个 <code>std::thread</code> 对象的所有权。</td></tr><tr><td>~thread()</td><td>析构函数，如果线程可 join，则会调用 <code>join()</code>，否则调用 <code>detach()</code>。</td></tr></tbody></table> 
<h2><a id="thread_26"></a>二、thread类的用法</h2> 
<p><code>std::thread</code> 类是 C++ 标准库中用于线程创建和管理的类。以下是 <code>std::thread</code> 类的一些关键用法和示例：</p> 
<h3><a id="1__29"></a>1. 创建线程</h3> 
<p>要创建一个线程，你需要实例化 <code>std::thread</code> 对象并传递一个函数或可调用对象（如 lambda 表达式或函数对象）作为参数。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">threadFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello from thread!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span>threadFunction<span class="token punctuation">)</span><span class="token punctuation">;</span>
    t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等待线程结束</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="2__Lambda__48"></a>2. 使用 Lambda 表达式</h3> 
<p>Lambda 表达式提供了一种简洁的方式来定义匿名函数对象，非常适合用于线程。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello from lambda thread!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="3__65"></a>3. 传递参数给线程</h3> 
<p>你可以将参数传递给线程函数。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">threadFunctionWithArgs</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"x: "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">", y: "</span> <span class="token operator">&lt;&lt;</span> y <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span>threadFunctionWithArgs<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="4__join__detach_81"></a>4. 线程的 join 和 detach</h3> 
<ul><li><code>join()</code>: 调用此方法会阻塞，直到线程结束执行。</li><li><code>detach()</code>: 调用此方法会使线程在后台继续运行，而不受 <code>std::thread</code> 对象的生命周期限制。</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 线程执行的代码</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 线程现在在后台运行，不会等待它结束</span>
    <span class="token comment">// 主线程继续执行，而 t 线程在后台运行</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="5__join_97"></a>5. 检查线程是否可 join</h3> 
<p>在调用 <code>join()</code> 或 <code>detach()</code> 之前，可以使用 <code>joinable()</code> 检查线程是否还在运行。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 线程执行的代码</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 线程还在运行，等待结束</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="6__ID_113"></a>6. 线程的 ID</h3> 
<p>每个线程都有一个唯一的 ID，可以使用 <code>get_id()</code> 获取。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Thread ID: "</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t<span class="token punctuation">.</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取线程 ID</span>
    t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="7__128"></a>7. 线程的移动语义</h3> 
<p><code>std::thread</code> 对象可以被移动，但不能被复制。这意味着你可以通过移动语义来转移线程的所有权。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Thread 1 running"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread t2 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// t1 的所有权转移给 t2</span>
    t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等待线程结束</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="8__143"></a>8. 线程的析构</h3> 
<p>当 <code>std::thread</code> 对象被销毁时，如果线程是可 join 的，那么 <code>join()</code> 会被自动调用。如果线程已经被分离，则不会有任何操作。</p> 
<pre><code class="prism language-cpp"><span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 线程执行的代码</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// t 在这里离开作用域，自动调用 join()</span>
<span class="token punctuation">}</span> <span class="token comment">// t 的析构函数被调用</span>
</code></pre> 
<h3><a id="__156"></a>🚨 注意事项</h3> 
<ul><li>确保在 <code>std::thread</code> 对象生命周期结束前，线程已经被正确处理（join 或 detach）。</li><li>避免在线程函数中调用 <code>std::exit()</code> 或者抛出未捕获的异常，因为这可能会导致程序的不稳定。</li><li>使用互斥锁和条件变量来同步线程，避免数据竞争和死锁。</li></ul> 
<p><code>std::thread</code> <strong>提供了强大的工具来实现多线程编程，但也需要谨慎使用以确保程序的正确性和稳定性</strong>。</p> 
<h2><a id="_163"></a>三、线程函数参数</h2> 
<p><strong>线程函数的参数是以值拷贝的方式拷贝到线程栈空间中的</strong>，因此：即使线程参数为引用类型，在线程中修改后也不能修改外部实参，因为<strong>其实际引用的是线程栈中的拷贝，而不是外部实参</strong>。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">ThreadFunc1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    x <span class="token operator">+=</span> <span class="token number">10</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">ThreadFunc2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token operator">*</span>x <span class="token operator">+=</span> <span class="token number">10</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	 <span class="token comment">// 在线程函数中对a修改，不会影响外部实参，因为：线程函数参数虽然是引用方式，但其实际引用的是线程栈中的拷贝    </span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>ThreadFunc1<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    
    <span class="token comment">// 如果想要通过形参改变外部实参时，必须借助std::ref()函数</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>ThreadFunc1<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">ref</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等待线程执行完成</span>
    
    <span class="token comment">// 地址的拷贝</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t3</span><span class="token punctuation">(</span>ThreadFunc2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    t3<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等待线程执行完成   </span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_194"></a>温馨提示</h2> 
<p>感谢您对博主文章的关注与支持！另外，我计划在未来的更新中持续探讨与本文相关的内容，会为您带来更多关于C++以及编程技术问题的深入解析、应用案例和趣味玩法等。请继续关注博主的更新，不要错过任何精彩内容！</p> 
<p>再次感谢您的支持和关注。期待与您建立更紧密的互动，共同探索C++、算法和编程的奥秘。祝您生活愉快，排便顺畅！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7c2216d4dd46c6139d1962e57fa19309/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">unipush 2.0流程及踩坑记录（后端调用接口，前端推送）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/30dffd4192ba92812ff680e1d589c632/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">湖师计信学科小组之DFS走迷宫问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>