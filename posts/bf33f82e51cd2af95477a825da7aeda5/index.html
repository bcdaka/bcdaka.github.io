<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言：深入理解指针(3) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/bf33f82e51cd2af95477a825da7aeda5/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C语言：深入理解指针(3)">
  <meta property="og:description" content="创作不易，友友们给个三连吧！！ 通过深入理解指针（1）和深入理解指针（2），我们对指针有了一个初步的了解，学会了一级指针、二级指针、指针数组……而深入理解指针（3），主要是为了学习不同数据类型的指针变量。
一、字符指针变量 字符串指针变量的指针类型为char*，下面我们通过这段代码来解析字符指针变量。
int main() { printf(&#34;指针接收字符\n&#34;); char ch = &#39;w&#39;; char* pc = &amp;ch; printf(&#34;\t*pc=%c\n&#34;, *pc); printf(&#34;----------------\n&#34;); printf(&#34;指针接收字符串\n&#34;); const char* pstr = &#34;abcdef&#34;;//const 加了一层保护，使其变成常量字符串，被修改编译器会报错 printf(&#34;\t*pstr=%c\n&#34;, *pstr);//其实是把字符串的首字符地址放到pstr,字符串出现在表达式中时，他的值就是第一个字符的地址 printf(&#34;\tpstr=%s\n&#34;, pstr); //%s占位符的特点就是只要告诉他字符串的首地址, 就可以读取整个字符串 printf(&#34;\tpstr[3]=%c\n&#34;, pstr[3]);//[]是特殊的解引用操作符，等价于*（pstr&#43;3），相当于得到第1个元素偏移3得到第四个元素 printf(&#34;\tabcdef[3] = % c\n&#34;, &#34;abcdef&#34;[3]);//可以把字符串想象成一个字符数组，可以通过下标去访问他 return 0; } 指针接收字符
*pc=w
----------------
指针接收字符串
*pstr=a
pstr=abcdef
pstr[3]=d
abcdef[3] = d 字符指针变量，顾名思义就是指向字符的指针变量，所以利用指针接收字符的地址（第31行代码），最后解引用该指针变量得到的是对应的字符，非常容易理解。 但字符指针变量还有一种方式，就是接收字符串的地址。
通过第35行代码，我们用字符指针变量pstr接收了字符串“abcdef”，那这是把整个字符串放到pstr指针变量里面了吗？
其实并不是的，我们通过第36行代码的运行结果，发现将指针变量pstr解引用后得到的是‘a’，这说明字符指针变量pstr接收字符串的本质是将字符串的首字符地址存放到pstr中，所以如果字符串出现在表达式中，他的值就是第一个字符的地址。
既然pstr存放的是字符串首字符的地址，那么我们打印出来的是一个地址，但我们在看向第37行代码，当我们用%s的占位符时，却可以直接将整个字符串打印出来，这说明了%s占位符的特点就是只要告诉他字符串首字符的地址，他就可以直接读取整个字符串。
那为什么，我们知道了字符串的首元素地址，就可以通过%s打印出字符串全体呢？这是因为其实我们可以把字符串理解成一个字符数组，他具有数组的特点，可以通过首元素地址找到后面的全部元素，并且也可以像数组一样通过下标去访问每个元素，比如我们想访问字符串下标为3的元素（d），那么通过第39行代码我们可以发现“abcdef”[3]是可行的，
既然可以通过下标去访问字符串，那么既然pstr是接收字符串的指针变量，那么我们同样可以通过首元素地址的指针偏移来找到下标为3的元素，第38行代码中的pstr[3]（等价“*（pstr&#43;3）”）也是可行的。
下面是一道和字符串相关的面试题。
int main() { char str1[] = &#34;hello bit.&#34;; char str2[] = &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-02-09T01:41:04+08:00">
    <meta property="article:modified_time" content="2024-02-09T01:41:04+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言：深入理解指针(3)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"><img alt="" height="311" src="https://images2.imgbox.com/04/ae/VDGLnhTd_o.gif" width="607"></p> 
<p>                                        <strong>      创作不易，友友们给个三连吧！！ </strong></p> 
<p>    通过深入理解指针（1）和深入理解指针（2），我们对指针有了一个初步的了解，学会了一级指针、二级指针、指针数组……而深入理解指针（3），主要是为了学习不同数据类型的指针变量。</p> 
<h2>一、字符指针变量</h2> 
<p>     字符串指针变量的指针类型为char*，下面我们通过这段代码来解析字符指针变量。</p> 
<pre><code class="language-cpp">int main()
{
	printf("指针接收字符\n");
	char ch = 'w';
	char* pc = &amp;ch;
	printf("\t*pc=%c\n", *pc);
	printf("----------------\n");
	printf("指针接收字符串\n");
	const char* pstr = "abcdef";//const 加了一层保护，使其变成常量字符串，被修改编译器会报错
	printf("\t*pstr=%c\n", *pstr);//其实是把字符串的首字符地址放到pstr,字符串出现在表达式中时，他的值就是第一个字符的地址
	printf("\tpstr=%s\n", pstr); //%s占位符的特点就是只要告诉他字符串的首地址, 就可以读取整个字符串
	printf("\tpstr[3]=%c\n", pstr[3]);//[]是特殊的解引用操作符，等价于*（pstr+3），相当于得到第1个元素偏移3得到第四个元素
	printf("\tabcdef[3] = % c\n", "abcdef"[3]);//可以把字符串想象成一个字符数组，可以通过下标去访问他
	return 0;
}</code></pre> 
<blockquote> 
 <p>指针接收字符<br>         *pc=w<br> ----------------<br> 指针接收字符串<br>         *pstr=a<br>         pstr=abcdef<br>         pstr[3]=d<br>         abcdef[3] = d </p> 
</blockquote> 
<p>       字符指针变量，顾名思义就是指向字符的指针变量，所以利用指针接收字符的地址（第31行代码），最后解引用该指针变量得到的是对应的字符，非常容易理解。 但字符指针变量还有一种方式，就是接收字符串的地址。</p> 
<p>       通过第35行代码，我们用字符指针变量pstr接收了字符串“abcdef”，那这是把整个字符串放到pstr指针变量里面了吗？</p> 
<p>      其实并不是的，我们通过第36行代码的运行结果，发现将指针变量pstr解引用后得到的是‘a’，这说明字<span style="color:#fe2c24;"><strong>符指针变量pstr接收字符串的本质是将字符串的首字符地址存放到pstr中，所以如果字符串出现在表达式中，他的值就是第一个字符的地址。</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>      </strong></span><span style="color:#0d0016;">既然pstr存放的是字符串首字符的地址，那么我们打印出来的是一个地址，但</span><span style="color:#0d0016;">我们在看向第37行代码，当我们用%s的占位符时，却可以直接将整个字符串打印出来，这说明了</span><span style="color:#fe2c24;"><strong>%s占位符的特点就是只要告诉他字符串首字符的地址，他就可以直接读取整个字符串。</strong></span></p> 
<p><strong><span style="color:#fe2c24;"> </span></strong><strong><span style="color:#fe2c24;">  </span><span style="color:#fe2c24;"> </span></strong><strong> </strong><span style="color:#0d0016;">那为什么，我们知道了字符串的首元素地址，就可以通过%s打印出字符串全体呢？这是因为</span><span style="color:#fe2c24;"><strong>其实我们可以把字符串理解成一个字符数组，他具有数组的特点，可以通过首元素地址找到后面的全部元素，并且也可以像数组一样通过下标去访问每个元素</strong></span><span style="color:#0d0016;">，比如我们想访问字符串下标为3的元素（d），那么通过第39行代码我们可以发现“abcdef”[3]是可行的，</span></p> 
<p><span style="color:#0d0016;">      既然可以通过下标去访问字符串，那么既然pstr是接收字符串的指针变量，那么我们</span><span style="color:#fe2c24;"><strong>同样可以通过首元素地址的指针偏移来找到下标为3的元素</strong></span><span style="color:#0d0016;">，第38行代码中的pstr[3]（等价“*（pstr+3）”）也是可行的。</span></p> 
<p><span style="color:#0d0016;">下面是一道和字符串相关的面试题。</span></p> 
<pre><code class="language-cpp">int main()
{
	char str1[] = "hello bit.";
	char str2[] = "hello bit.";
	const char* str3 = "hello bit.";
	const char* str4 = "hello bit.";
	if (str1 == str2)
		printf("str1 and str2 are same\n");
	else
		printf("str1 and str2 are not same\n");

	if (str3 == str4)
		printf("str3 and str4 are same\n");
	else
		printf("str3 and str4 are not same\n");

	return 0;
}</code></pre> 
<blockquote> 
 <p> str1 and str2 are not same<br> str3 and str4 are same</p> 
</blockquote> 
<p><strong>为什么str1和str2的地址不同，而str3和str4的地址相同呢？？</strong></p> 
<p>       将常量字符串赋值给数组（str1和str2），本质上是将这个常量字符串复制一份到数组中，这两个数组其实并不在一个空间，所以str1=str2，并且复制出来的常量字符串是可以修改的。</p> 
<p>       而如果通过字符指针变量指向常量字符串（str3和str4），对于常量字符串来说，是只能读不能改的，从内存利用率来说，内容相同的字符串只会保存一份，所以str3=str4.</p> 
<h2 style="background-color:transparent;">二、数组指针变量</h2> 
<p>我们学过指针数组，它是一个存放指针的数组。</p> 
<p>那什么是数组指针变量呢？我们通过已经学过的指针变量来类比一下。</p> 
<p><img alt="" height="215" src="https://images2.imgbox.com/9b/16/eILp4RDv_o.png" width="765"><span style="color:#fe2c24;"><strong>所以数组指针变量是一个存放的是数组的地址，并且能够指向数组的指针变量。</strong></span></p> 
<pre><code class="language-cpp">int* p1[10];
int(*p2)[10];
</code></pre> 
<p>以上哪个是数组指针变量呢？</p> 
<p>     对于int*p1[10]来说，首先p1会先和[ ]结合，然后int和*结合，所以p1有10个元素，并且每个元素是int*类型，所以p1是一个存放指针的数组，<strong>p1是指针数组。</strong>（[ ]的优先级高于*）</p> 
<p>     对于int（*p2）[10]来说，p2先和*结合了，所以*p2是一个指针，int和[10]代表p2指向的是一个数组，并且有10个元素，并且每个元素的类型是int，所以<strong>p2是数组指针。</strong>(因为[ ]的优先级高于*，所以必须加上（ ）来保证p和*先结合)</p> 
<p>     那数组指针如何初始化呢？既然指针变量是用来存放数组地址的，而&amp;arr是取整个数组的地址，所以写法就是<span style="color:#fe2c24;"><strong>int（*p2）[10]=&amp;arr。</strong></span></p> 
<h2 style="background-color:transparent;"><span style="color:#0d0016;">三、二维数组传参的本质</span></h2> 
<p>数组指针有什么用呢?其实数组指针有自己的应用场景，在此之前要先了解二维数组传参的本质</p> 
<p><span style="color:#0d0016;">以往我们对有一个二维数组需要传递给函数时，我们是这样写的</span></p> 
<pre><code class="language-cpp">void test(int a[][5], int r, int c)
{
	int i = 0;
	int j = 0;
	for (i = 0; i &lt; r; i++)
	{
		for (j = 0; j &lt; c; j++)
		{
			printf("%d ", p[i][j]);
		}
		printf("\n");
	}
}
int main()
{
	int arr[3][5] = { {1,2,3,4,5}, {2,3,4,5,6},{3,4,5,6,7} };
	test(arr, 3, 5);
	return 0;
}</code></pre> 
<blockquote> 
 <p>1 2 3 4 5<br> 2 3 4 5 6<br> 3 4 5 6 7 </p> 
</blockquote> 
<p>形参和实参都是二维数组的形式，但其实还有其他写法。</p> 
<p>      对于二维数组来说，可以看做是每个元素是一维数组的数组，也就是二维数组的每个元素是一个一维数组。<span style="color:#fe2c24;"><strong>那么二维数组的首元素就是第一行，是个一维数组。</strong></span></p> 
<p>     根据一维数组的数组名名就是首元素地址、一维数组传参本质是传递首元素地址这个规则，我们可以推出<strong><span style="color:#fe2c24;">二维数组的数组名就是就是第一行（一维数组）的地址，二维数组传参本质是传递第一行这个一维数组的地址。</span></strong></p> 
<p>     根据上面的代码，我们知道该<span style="color:#fe2c24;"><strong>二维数组第一行的一维数组的数据类型是int[5]，所以第一行的地址类型就是数组指针类型int(*)[5],所以我们可以将形参类型写成指针形式。</strong></span>   </p> 
<p>    接下来对上面的代码进行改写，将形参写成数组指针类型。</p> 
<pre><code class="language-cpp">void test(int(*p)[5], int r, int c)
{
	int i = 0;
	int j = 0;
	for (i = 0; i &lt; r; i++)
	{
		for (j = 0; j &lt; c; j++)
		{
			printf("%d ",p[i][j]);
		}
		printf("\n");
	}
}
int main()
{
	int arr[3][5] = { {1,2,3,4,5}, {2,3,4,5,6},{3,4,5,6,7} };
	test(arr, 3, 5);
	return 0;
}</code></pre> 
<blockquote> 
 <p>1 2 3 4 5<br> 2 3 4 5 6<br> 3 4 5 6 7 </p> 
</blockquote> 
<p>怎么去理解*(*(p+i)+j))呢？我们要进行拆解！（假设访问二维数组中的一个元素）</p> 
<p>首先是p+i，二维数组的首元素地址是第一行的一维数组，所以p存放的是第一行的地址，所以+i会跳过i行，i=0时，此时跳过0行，拿到的是第一行的地址，i=1时，跳过1行，拿到的是第二行的地址，i=2时，跳过2行，拿到的是第三行的地址。</p> 
<p>然后是*（p+i），假设i已经确定，此时就是通过解引用拿到了一行的数据。</p> 
<p>然后是*（p+i）+j，此时*（p+i）已经拿到一行的数据了，通过j来访问这一行的其他元素地址，当j=0时，就是首元素地址，j=1时，就跳过一个元素，拿到第二个元素的地址，以此类推，找到了该行所有元素的地址。</p> 
<p>然后是*(*(p+i)+j))，假设j已经确定，此时*（p+i）+j就是一个元素的地址，再对他进行解引用，找到该元素。</p> 
<p><span style="color:#fe2c24;"><strong>底层逻辑还是通过指针的偏移量去访问每个元素。所以p[i][j]的写法也是可行的。</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>所以根据二维数组传参的本质-----传递首行这个一维数组的地址，我们找到了数组指针变量的应用场景。</strong></span></p> 
<h2 style="background-color:transparent;">四、函数指针变量</h2> 
<h3>4.1 函数指针变量</h3> 
<p>通过类比，函数指针就是指向函数的指针，那么<span style="color:#fe2c24;"><strong>函数指针变量就是用来存放函数的地址。</strong></span></p> 
<p>对应数组arr来说，arr是数组首元素地址，而&amp;arr代表是整个数组的地址，而<span style="color:#fe2c24;"><strong>对于函数来说，函数名是函数的地址，&amp;函数名也是函数的地址。</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>既然函数指针变量是用来存放函数的地址的，所以未来也可以通过函数的地址去调用函数。</strong></span></p> 
<p>函数指针怎么创建？</p> 
<pre><code class="language-cpp">int(*p)(int, int) = Add;
int(*p)(int x, int y) = &amp;Add;</code></pre> 
<p>（ ）将*和p结合起来，说明这是一个指针，（int，int）说明这个指针指向一个函数，并且形参类型是int和int，开头的int说明该函数的返回类型是int。</p> 
<p>add和&amp;add是一样的，因为对于函数来说，函数名是地址，&amp;函数名也是地址</p> 
<p>同理*p和p也是一样的，函数指针变量是可以不需要解引用。</p> 
<p>形参的形参名可写可不写</p> 
<p><img alt="" height="246" src="https://images2.imgbox.com/06/d3/X4QCKL9j_o.png" width="625"></p> 
<h3>4.2 函数指针变量的使用</h3> 
<pre><code class="language-cpp">int Add(int x, int y)
{
	return x + y;
}
int main()
{
	int(*pf3)(int, int) = Add;

	printf("%d\n", (*pf3)(2, 3));
	printf("%d\n", pf3(3, 5));
	return 0;
}</code></pre> 
<blockquote> 
 <p>5</p> 
 <p>8</p> 
</blockquote> 
<p>注意：因为Add和&amp;Add都是函数的地址，所以对于pf3来说，即使不解引用也是可以调用函数的，但如果解引用了，一定要记得用括号（ ）将*和pf3放在一起！！</p> 
<h3>4.3 函数指针变量的拓展</h3> 
<pre><code class="language-cpp">fun1(char* p, int (*)(char*));

(*(void (*)())0)();

void (*signal(int, void(*)(int)))(int);
</code></pre> 
<p>分析这3个代码</p> 
<p>1.fun1的的第1个形参的类型是字符指针，第2个形参int（*）（char*），（*）代表这个形参是个指针，int和（char*）表名这是一个函数指针，形参类型为字符指针，返回值为整型。<span style="color:#fe2c24;"><strong>函数指针作为其他函数的形参时，其自身的函数名和形参名可以省略，仅保留数据类型即可。</strong></span></p> 
<p>2.多个括号要逐步拆解，void（*）（ ）说明这是一个void类型的函数指针，没有形参，类型放在（）,就是强制类型转换，所以（void（*）（ ）0）的意思时将0这个整数值强制转换成一个void（*）（ ）类型的函数指针，再进行解引用，得到的是函数指针的地址，结尾的（ ）就是调用0地址处的函数。所以<strong>上述代码实际上是一个函数调用，将0转化成一个void（*）（ ）类型的函数地址，再去调用0地址处的函数。</strong></p> 
<p>3.首先，*没有和signal在一起，signal（int，void（*）（int））说明<strong>signal是一个函数名，该函数的形参有两个类型，一个是int，一个是void（*）（int）类型的函数指针</strong>，剩下的部分就是该函数的返回类型，所以<strong>signal的返回类型是void（*）（int）类型的函数指针</strong>。<strong>上述代码其实是一个函数声明。</strong></p> 
<p><span style="color:#fe2c24;"><strong>通过上述的扩展，我们复习到了</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>1.认识函数指针类型</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>2.强制类型转换</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>3.通过函数指针调用函数的方式</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>4.函数的定义、声明、调用</strong></span></p> 
<h3>4.4 typedef关键字</h3> 
<p>typedef是用来类型重命名的，可以将复杂的类型简单化</p> 
<pre><code class="language-cpp">typedef unsigned int uint;
//将unsigned int 重命名为uint

typedef int* ptr_t;//整形指针
//int*重命名为ptr_t

typedef int(*parr_t)[5];//数组指针
//int(*5)重命名为parr_t

typedef void(*pfun_t)(int);//函数指针
//void(*)(int)重名名为pfun_t


void (*signal(int, void(*)(int)))(int);//进行改写
pfun_t signal(int, pfun_t);
</code></pre> 
<p>    <span style="color:#fe2c24;"><strong> 关于typedef，常规写法是  typedef 类型 重命名  ，但是对于数组指针类型和函数指针类型稍有区别，重命名部分要写在*的后面。</strong></span></p> 
<h2 style="background-color:transparent;"><span style="color:#0d0016;">五、函数指针数组</span></h2> 
<p><span style="color:#0d0016;">      数组是一个存放相同类型数据的存储空间，所以</span><span style="color:#fe2c24;"><strong>函数指针数组存放的是具有相同返回类型和形参的函数指针。</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>     </strong></span><span style="color:#0d0016;">函数指针数组怎么创建呢？</span></p> 
<pre><code class="language-cpp">int (*parr1[3])();
int* parr2[3]();</code></pre> 
<p>   如上图代码，其实是parr1，首先parr1先和[ ]结合，说明parr1是个数组，且有3个元素，存放的是int（*）（）类型的函数指针。</p> 
<p>   函数指针数组的应用场景，我们可以通过转移表来理解。</p> 
<h2 style="background-color:transparent;">六、转移表的应用</h2> 
<p><strong>函数指针数组，用数组取每个元素的方式去调用函数</strong>，就叫转移表。</p> 
<p>当我们想要对两个数进行加减乘除运算操作时，以下是计算机的一般实现。</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
int add(int a, int b)
{
 return a + b;
}
int sub(int a, int b)
{
 return a - b;
}
int mul(int a, int b)
{
 return a * b;
}
int div(int a, int b)
{
 return a / b;
}
int main()
{
 int x, y;
 int input = 1;
 int ret = 0;
 do
 {
 printf("*************************\n");
 printf(" 1:add 2:sub \n");
 printf(" 3:mul 4:div \n");
 printf(" 0:exit \n");
 printf("*************************\n");
 printf("请选择：");
 scanf("%d", &amp;input);
 switch (input)
 {
 case 1:
 printf("输⼊操作数：");
 scanf("%d %d", &amp;x, &amp;y);
 ret = add(x, y);
 printf("ret = %d\n", ret);
 break;
 case 2:
 printf("输⼊操作数：");
 scanf("%d %d", &amp;x, &amp;y);
 ret = sub(x, y);
 printf("ret = %d\n", ret);
 break;
 case 3:
 printf("输⼊操作数：");
 scanf("%d %d", &amp;x, &amp;y);
 ret = mul(x, y);
 printf("ret = %d\n", ret);
 break;
 case 4:
 printf("输⼊操作数：");
 scanf("%d %d", &amp;x, &amp;y);
 ret = div(x, y);
 printf("ret = %d\n", ret);
 break;
 case 0:
 printf("退出程序\n");
 break;
 default:
 printf("选择错误\n");
 break;
 }
 } while (input);
 return 0;
}</code></pre> 
<p>   <strong>   假设我们想要对这两个数进行更多的运算，那么由于增加了更多的选择，switch语句的相关代码会变得非常冗长，且重复性很高，所以此时用函数指针数组，可以很好地解决这个问题。</strong>下面我们通过函数指针数组来实现。</p> 
<pre><code class="language-cs">int add(int a, int b)
{
	return a + b;
}
int sub(int a, int b)
{
	return a - b;
}
int mul(int a, int b)
{
	return a * b;
}
int div(int a, int b)
{
	return a / b;
}
int main()
{
	int x, y;
	int input = 1;
	int ret = 0;
	int(*p[5])(int x, int y) = { 0, add, sub, mul, div }; //转移表
	do
	{
		printf("*************************\n");
		printf(" 1:add 2:sub \n");
		printf(" 3:mul 4:div \n");
		printf(" 0:exit \n");
		printf("*************************\n");
		printf("请选择：");
		scanf("%d", &amp;input);
		if ((input &lt;= 4 &amp;&amp; input &gt;= 1))
		{
			printf("输入操作数：");
			scanf("%d %d", &amp;x, &amp;y);
			ret = (*p[input])(x, y);
			printf("ret = %d\n", ret);
		}
		else if (input == 0)
			printf("退出计算器\n");
		else
			printf("输入有误\n");
		} while (input);
		return 0;
}
		</code></pre> 
<p><span style="color:#0d0016;">   </span><img alt="" height="639" src="https://images2.imgbox.com/ed/4e/n6Vc2vb6_o.png" width="1200"></p> 
<p><span style="color:#0d0016;">      我们发现原本通过switch语句的选择代码，直接变成了函数指针数组的下标访问，代码简洁清晰。</span></p> 
<p><span style="color:#0d0016;"><strong>      为什么可以使用函数指针数组？</strong></span><span style="color:#fe2c24;"><strong>因为add、sub、mul、div这四个函数的形参以及返回类型是意义的，所以他们的函数指针类型也是一致的，根据数组只能存放相同数据类型的特点，所以这几个函数可以被放在一个函数指针数组里，当放进函数指针数组时，我们就可以通过下标去访问并调用对应的函数！</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>    这里要注意，数组的地址是连续的，但是这个数组存放的函数地址是不连续的。</strong></span></p> 
<p style="text-align:center;"><span style="color:#0d0016;">    <img alt="" src="https://images2.imgbox.com/31/34/eRT1zDzV_o.jpg"></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cfa60cb93069c863b767cc1e56657ec2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言：深入理解指针(2)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/96bff700c0ba46d90e8e74baa6e87b4f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python SimpleHTTPServer - Python HTTP 服务器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>