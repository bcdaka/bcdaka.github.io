<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>单链表——单链表的定义及基本操作（头插法尾插法建表、查找、插入、删除等） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/ca5941f529f224e01d6bf37a2dbf3855/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="单链表——单链表的定义及基本操作（头插法尾插法建表、查找、插入、删除等）">
  <meta property="og:description" content="前言 上一篇我们已经完成了顺序表的实现和基本操作&lt;元素的增加、删除和查找&gt;
(链接直达：线性表元素的基本操作（C语言）【数据结构】-CSDN博客)
我们知道顺序表支持随机访问，可以通过下标来直接访问，同时也可以进行排序等优点；但是仍存在局限性，对顺序表的中部进行增加或删除元素的时间复杂度高，均为O(n)；同时要求大片连续空间进行存储，改变容量也不是很方便。
因为我们引入新的线性表——链表。
单链表 一、单链表的基本概念 单链表（Singly Linked List）是一种常用的数据结构，它由若干个结点组成，每个结点包含两部分：数据域和指针域。数据域用于存储数据，而指针域则用于指向下一个节点的地址。单链表中每个结点只有一个指针域，指向下一个结点，最后一个结点的指针域指向 NULL，表示链表的结尾。
从这里我们可以很清楚的看见每个结点分为数据域和指针域。
//在结构体中定义数据域和指针域 typedef struct LNode { int data; //每个节点存放一个数据元素 struct LNode *next; //指针指向下一个节点 }LNode, *LinkList; 相比于顺序表，单链表的存储不要求大片连续存储空间，因此改变容量十分方便。
对比下图便可直观感受到单链表易更改性。
二、单链表的实现 1.单链表的创建 单链表的创建分为头插法和尾插法。
(1)头插法： 输入的数据次序生成的链表结点次序相反，例如：按{1,2,3}顺序进行头插之后，最终排序却变成了{3,2,1}，换言之就是逆序插入。
以下便是代码图解，e为需要插入到单链表L中的结点
头插法代码实现：
//利用头插法创建链表 LNode *Init_LinkList_head(LinkList L) { //创建头结点 LinkList head = (LinkList) malloc(sizeof(LinkList)); //保证头结点没有存储脏数据 head-&gt;next = NULL; //创建输入数据的常量 int val = -1; //定义-1表示输入结束标志 int len = 0; //观察单链表的长度 while (true) { printf(&#34;请输入链表中的元素：&#34;); scanf(&#34;%d&#34;, &amp;val); if (val == -1) { break; } //创建新的结点 LinkList s = (LinkList) malloc(sizeof(LinkList)); s-&gt;data = val; //将输入的数据赋值到新结点的数据域中 s-&gt;next = head-&gt;next; head-&gt;next = s; //将新结点连接到头指针中 len&#43;&#43;; } printf(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-30T14:12:18+08:00">
    <meta property="article:modified_time" content="2024-03-30T14:12:18+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">单链表——单链表的定义及基本操作（头插法尾插法建表、查找、插入、删除等）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>前言</h2> 
<p>上一篇我们已经完成了顺序表的实现和基本操作&lt;元素的增加、删除和查找&gt;</p> 
<p>(链接直达：<a href="https://blog.csdn.net/Wanghh520max/article/details/137128308" title="线性表元素的基本操作（C语言）【数据结构】-CSDN博客">线性表元素的基本操作（C语言）【数据结构】-CSDN博客</a>)</p> 
<p>我们知道顺序表支持随机访问，可以通过下标来直接访问，同时也可以进行排序等优点；但是仍存在局限性，对顺序表的中部进行增加或删除元素的时间复杂度高，均为O(n)；同时要求大片连续空间进行存储，改变容量也不是很方便。</p> 
<p>因为我们引入新的线性表——链表。</p> 
<h2>单链表</h2> 
<h3>一、单链表的基本概念</h3> 
<p><strong>单链表</strong>（Singly Linked List）是一种常用的数据结构，它由若干个结点组成，每个结点包含两部分：<strong>数据域</strong>和<strong>指针域</strong>。数据域用于存储数据，而指针域则用于指向下一个节点的地址。单链表中每个结点只有一个指针域，指向下一个结点，最后一个结点的指针域指向 NULL，表示链表的结尾。</p> 
<blockquote> 
 <p>从这里我们可以很清楚的看见每个结点分为<strong>数据域</strong>和<strong>指针域</strong>。</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/58/cf/QBTvFRqy_o.png"></p> 
<pre><code class="language-cpp">//在结构体中定义数据域和指针域
typedef struct LNode {
    int data;                //每个节点存放一个数据元素
    struct LNode *next;      //指针指向下一个节点
}LNode, *LinkList;</code></pre> 
<blockquote> 
 <p>相比于顺序表，单链表的存储不要求大片连续存储空间，因此改变容量十分方便。</p> 
 <p>对比下图便可直观感受到单链表易更改性。</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/93/4d/fhYRdSic_o.png"></p> 
<h3>二、单链表的实现</h3> 
<h4>1.单链表的创建</h4> 
<p>单链表的创建分为头插法和尾插法。</p> 
<h5>(1)头插法：</h5> 
<p>输入的数据次序生成的链表结点次序相反，例如：按{1,2,3}顺序进行头插之后，最终排序却变成了{3,2,1}，换言之就是逆序插入。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c3/b6/yJsEmUtY_o.png"></p> 
<blockquote> 
 <p>以下便是代码图解，e为需要插入到单链表L中的结点</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2c/88/9VWfuY6b_o.png"></p> 
<blockquote> 
 <p>头插法代码实现：</p> 
</blockquote> 
<pre><code class="language-cpp">//利用头插法创建链表
LNode *Init_LinkList_head(LinkList L) {
    //创建头结点
    LinkList head = (LinkList) malloc(sizeof(LinkList));
    //保证头结点没有存储脏数据
    head-&gt;next = NULL;
    //创建输入数据的常量
    int val = -1;       //定义-1表示输入结束标志
    int len = 0;        //观察单链表的长度
    while (true) {
        printf("请输入链表中的元素：");
        scanf("%d", &amp;val);

        if (val == -1) {
            break;
        }
        //创建新的结点
        LinkList s = (LinkList) malloc(sizeof(LinkList));

        s-&gt;data = val;    //将输入的数据赋值到新结点的数据域中

        s-&gt;next = head-&gt;next;    
        head-&gt;next = s;        //将新结点连接到头指针中

        len++;
    }
    printf("链表的长度为：%d\n", len);
    return head;            //返回单链表
}

int main() {
    LinkList L = Init_LinkList_head(L);
    PrintLinkList(L);
    return 0;
}</code></pre> 
<blockquote> 
 <p>例：向空链表中插入{10，20，30，40，50，60}构成新的单链表。</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/7f/33/gUucf8D8_o.png"></p> 
<h5>(2)尾插法：</h5> 
<p>输入的数据次序生成的链表结点次序<strong>相同</strong>，例如：按{1,2,3}顺序进行头插之后，最终排序还是{1,2,3}，换言之就是<strong>顺序插入</strong>。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/cf/2a/DntdVjTi_o.png"></p> 
<blockquote> 
 <p>以下便是代码图解，e为需要插入到单链表L中的结点</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ad/fd/iCAK7B3N_o.png"></p> 
<blockquote> 
 <p>尾插法的代码实现：</p> 
 <p>在此方法中我们添加了一个尾结点，设置尾结点的目的是为了提高插入操作的效率。如果没有尾结点，每次进行尾插入操作时，都需要遍历整个链表找到最后一个结点，然后再进行插入操作。这样的时间复杂度是O(n)，其中n是链表的长度。</p> 
 <p>而如果设置了尾结点，每次进行尾插入操作时，只需要直接将新结点插入到尾结点之后，并更新尾结点的指针即可，不需要遍历整个链表。这样的时间复杂度是O(1)，效率更高。</p> 
</blockquote> 
<pre><code class="language-cpp">//利用尾插法创建链表
LinkList Init_LinkList_tail(LinkList L) {
    //创建头结点
    LinkList head = (LinkList) malloc(sizeof(LinkList));  
    //头结点的指针域置空，说明当前链表是空的
    head-&gt;next = NULL;
    int val = -1;
    int len = 0;

    //创建尾节点
    LinkList ptr = (LinkList) malloc(sizeof(LinkList));
    ptr = head;         //开始时指向头节结点，中间没有数据

    //循环的向链表中添加元素，直至找到结束标志后退出输入环节
    while (true) {
        printf("请输入链表中的元素：");
        scanf("%d", &amp;val);

        if (val == -1) {    //输入结束标志
            break;
        }

        LinkList s = (LinkList) malloc(sizeof(LinkList)); //申请新的结点
        s-&gt;data = val;
        s-&gt;next = NULL;

        ptr-&gt;next = s;    // 将新的结点链接到尾结点中
        
        ptr = s;          //更新尾结点，添加完新的结点后将新的结点设为尾结点
        len++;
    }
    printf("链表的长度为：%d\n", len);
    return head;
}

int main() {
    LinkList L = Init_LinkList_tail(L);
    PrintLinkList(L);
    return 0;
}</code></pre> 
<blockquote> 
 <p>例：向空链表中插入{10，20，30，40，50，60}构成新的单链表。</p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/60/0d/3KKFaT0U_o.png"></p> 
<p><strong>一般地，头插法的重要应用便是链表的逆置，尾插法可能多用于自己的学习研究，接下来单链表的基本操作我们均以尾插法来创建链表并加以阐述。</strong></p> 
<h4>2.单链表的查找</h4> 
<p>单链表的查找分为按值查找和按位查找。</p> 
<p>我们这里默认讨论带头结点的单链表。</p> 
<h5>(1)按位查找</h5> 
<p>单链表不具备“随机访问“的特性，只能依次扫描每个结点并对比数据域中是否为目标值。</p> 
<p>基本思路：从单链表中的第一个结点出发，顺时针next域逐个往下搜索，直到找到第i个结点为止，否则返回最后一个结点指针域NULL。</p> 
<p>平均时间复杂度：O(n)</p> 
<blockquote> 
 <p>创建一个指针P，并从头结点开始遍历单链表，直至找到目标元素。</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/8b/da/YTALp24n_o.png"></p> 
<p><strong>代码实现：</strong></p> 
<pre><code class="language-cpp">//按位查找元素
void Search_LinkList_site(LinkList L) {
    //创建新的结点
    LinkList p = (LinkList) malloc(sizeof(LinkList));
    
    //结点p从头结点的下一个结点开始遍历，即第一个存储数据的结点开始遍历
    p = L-&gt;next;
    int j = 1;
    printf("请输入想要查找元素的位置：");
    int i;
    scanf("%d", &amp;i);

    while (p != NULL &amp;&amp; j &lt; i) {    // p若为空则说明链表已遍历结束
        j++;
        p = p-&gt;next;                //依次指向下一个结点
    }

    int elem = p-&gt;data;             //获取目标位置的元素
    printf("链表中第%d元素是%d\n", i, elem);
}
</code></pre> 
<blockquote> 
 <p>例：查找链表{10,20,30,40,50,60}中第3位元素。</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/14/bb/0AHBjOTf_o.png"></p> 
<p></p> 
<h5>(2)按值查找</h5> 
<p>基本思路：从单链表中的第一个结点出发，顺时针next域逐个往下搜索，直到找到第i个结点的数据域与目标值相等为止，否则返回最后一个结点指针域NULL。</p> 
<p>平均时间复杂度：O(n)</p> 
<p>创建一个指针p，从单链表的第一个结点开始遍历，每次比较结点的数据域和目标值。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/dd/74/n3zljkz5_o.png"></p> 
<p><strong>代码实现：</strong></p> 
<pre><code class="language-cpp">//按值查找元素
void Search_LinkList_value(LinkList L) {
    LinkList p = (LinkList) malloc(sizeof(LinkList));
    p = L-&gt;next;

    int cnt = 1;
    int e;
    printf("请输入需要查找的元素：");
    scanf("%d", &amp;e);

    while (p != NULL &amp;&amp; p-&gt;data != e) { //比较每个结点的数据域是否为目标值
        cnt++;
        p = p-&gt;next;
    }
    printf("元素%d是链表中第%d位元素。\n", e, cnt);
}</code></pre> 
<blockquote> 
 <p>例：查找链表{10,20,30,40,50,60}中{60}元素所在位置。</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ec/e3/YqK55afx_o.png"></p> 
<p><strong>单链表的查找主要思想是遍历整个链表，从而找到目标数值或目标位置。</strong></p> 
<h4>3.单链表的元素插入</h4> 
<p>单链表的插入分为<strong>按位序插入</strong>和<strong>按指定结点插入</strong>两大类。</p> 
<h5>(1)<strong>按位序插入</strong></h5> 
<p>在单链表L中的第i个位置上插入指定元素e。要在第i个位置上插入指定元素，那就应该要找到第i-1个结点，并将新结点插入其后。</p> 
<blockquote> 
 <p>过程分析：</p> 
 <p>1.要找到第i-1个结点；(若i=2,就需要找到i=1的第一个结点)<br> 2.然后需要用malloc函数申请一个新的结点s;<br> 3.将数据元素e存入到这个结点;<br> 4.假设第i-1的结点为*p;<br> 5.新结点s的指针域指向p的后继结点；<br> 6.令p的指针域指向新插入结点s; (5与6的顺序不能颠倒)<br> 7.按位序插入成功；</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/55/91/ZpZEtJF9_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/8a/da/cxv2zqo1_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/92/2f/ixFQVvd4_o.png"></p> 
<p><strong>代码实现：</strong></p> 
<pre><code class="language-cpp">//按位序插入
void Insert_LinkList_appoint(LinkList L) {
    LinkList p = (LinkList) malloc(sizeof(LinkList));
    p = L;

    int j = 0;

    int site;
    printf("请输入需要插入的位置：");
    scanf("%d",&amp;site);

    //通过循环找到指定元素的前驱
    while (p != NULL &amp;&amp; j &lt; site - 1) {
        j++;
        p = p-&gt;next;
    }

    //判断接下来插入位置是否合法
    if (p == NULL) {        
        //site值不合法，超出链表长度，说明第site-1个结点不存在
        printf("插入的位置不合法！\n");
    } else {
        printf("请输入需要插入的元素：");
        //创建需要插入的节点
        LinkList s = (LinkList) malloc(sizeof(LinkList));
        scanf("%d", &amp;(s-&gt;data));

        s-&gt;next = p-&gt;next;
        p-&gt;next = s;
    }
}</code></pre> 
<blockquote> 
 <p>例：向链表{10,20,40,50,60}中的第3号位置插入元素{30}。</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/23/7f/RHwAt8dX_o.png"></p> 
<blockquote> 
 <p>健壮性测试：输入的site值不合法，例在链表{10,20,30}的第8号位置插入元素。</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/6b/25/Zc7aZBf3_o.png"></p> 
<h5>(2)按指定结点的插入操作</h5> 
<h6>a.在指定结点之后插入（后插）</h6> 
<p>后插操作：给定一个<strong>指定结点</strong>，在此结点之<strong>后</strong>插入一个数据元素e。单链表的结点结构使得单链表的链接指针只能往后寻找，所以如果给定一个指定结点p,那么<strong>p结点之后的结点都是可知的，p结点之前的结点都是未知的</strong>。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f0/18/Q5dHtUpB_o.png"></p> 
<p><strong>代码实现：</strong></p> 
<pre><code class="language-cpp">//后插操作，在p结点之后插入元素e.
bool InsertNextNode(LinkList p,int e){
    if(p==NULL)     //结点p不合法
        return false;
    LinkList s = (LinkList) malloc(sizeof(LinkList));//申请新结点
    
    s-&gt;data=e;                              //在新结点中存入数据元素e
    s-&gt;next =p-&gt;next;                       //结点p的下一个结点由新结点s来链接；
    p-&gt;next=s;      
    return true;                            //插入成功！
}</code></pre> 
<p>实现之后的效果：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/91/5f/mNwQwCMa_o.png"></p> 
<blockquote> 
 <p>后插操作主要找到指定结点之后便可以直接执行插入操作，因此时间复杂度是O(1)。</p> 
</blockquote> 
<h6>b.在指定结点之前插入（前插）</h6> 
<p>在指定某一结点的前面插入一个新的结点。由于单链表只能从头向尾遍历，那么我们怎么找到指定结点的前驱结点呢？（后面的双链表可以直接指向p-prior）</p> 
<blockquote> 
 <p>此时我们可以传入一个头指针，利用头指针循环查找结点p；找到p的前驱结点q，再对结点q进行后插；从而完成结点q的前插操作。<br><strong>时间复杂度：O(n)</strong></p> 
</blockquote> 
<p><img alt="" height="448" src="https://images2.imgbox.com/a4/35/nVPJxpPn_o.png" width="1200"></p> 
<p><strong>代码实现：</strong></p> 
<pre><code class="language-cpp">//前插操作，在p结点之前插入元素e.
bool InsertPriorNode(LinkList p,int e){
    if(p==NULL)     //结点p不合法
        return false;
    LinkList s = (LinkList) malloc(sizeof(LinkList));//申请新结点
    
    s-&gt;next=p-&gt;next;    
    p-&gt;next=s;                   //将新结点连接到p之后
    s-&gt;data=p-&gt;data;             //将p中元素复制到s中
    p-&gt;data=e;                   //将p中元素被覆盖为e     
    return true;                 //插入成功！
}</code></pre> 
<h4>4.单链表的元素删除</h4> 
<p>单链表的删除分为<strong>按位序删除</strong>和<strong>指定结点的删除</strong>。</p> 
<h5>(1)按位序删除</h5> 
<p>找到第i-1个结点，将其指针指向第i+1个结点，并释放第i个结点</p> 
<blockquote> 
 <p>检查删除位置的合法性；<br> 查找表中的第i-1个结点——被删结点的前驱结点<br> 修改指针域和返回被删数据域的元素<br> 删除成功!<br> 最坏、最好时间复杂度：O(n)<br> 最好时间复杂度：O(1)——被删结点是第一个结点。</p> 
</blockquote> 
<p><img alt="" height="429" src="https://images2.imgbox.com/32/35/Wc075uK9_o.png" width="1200"></p> 
<p><strong>代码实现：</strong></p> 
<pre><code class="language-cpp">//按位序删除
void ListDelete(LinkList L) {
    //判断L是否存在元素
    if (L == NULL) {
        printf("链表为空，无法删除结点\n");
        return;
    }
    LinkList p = (LNode *) malloc(sizeof(LinkList));
    p = L;       //指针P指向当前结点
    int j = 0;
    int site;
    printf("请输入需要删除结点的位置：");
    scanf("%d",&amp;site);

    while (p != NULL &amp;&amp; j &lt; site - 1) {    //通过循环遍历到site - 1的结点处
        p = p-&gt;next;
        j++;
    }

    // 如果位置超出链表长度
    if (p == NULL || p-&gt;next == NULL) {
        printf("位置超出链表长度，无法删除结点\n");
        return;
    }

    LinkList q = (LNode *) malloc(sizeof(LinkList));
    q = p-&gt;next-&gt;next;         //令q指向被删除的结点
    int e = p-&gt;next-&gt;data;     //获取被删除结点的数据
    free(p-&gt;next);            //释放结点的存储空间
    p-&gt;next = q;
    printf("成功删除元素%d\n", e);
}</code></pre> 
<blockquote> 
 <p>例：将链表{10，20，30，40，50}中的第4个结点进行删除。</p> 
</blockquote> 
<p><img alt="" height="496" src="https://images2.imgbox.com/cc/ca/Ez35Zrm2_o.png" width="1200"></p> 
<blockquote> 
 <p>健壮性测试：若输入的位置超过链表的长度则会删除失败！</p> 
</blockquote> 
<p><img alt="" height="324" src="https://images2.imgbox.com/25/39/tvn1w7OR_o.png" width="1200"></p> 
<h5>(2)指定结点删除</h5> 
<p>删除单链表中指定结点的基本原理如下：</p> 
<ol><li>遍历链表，找到要删除的结点以及其前驱结点。</li><li>将前驱结点的<code>next</code>指针指向要删除结点的下一个结点，跳过要删除的结点。</li><li>释放要删除的结点的内存空间，防止内存泄漏。</li></ol> 
<p><img alt="" height="429" src="https://images2.imgbox.com/b1/65/ygXHivQy_o.png" width="1200"></p> 
<p><strong>代码实现：</strong></p> 
<pre><code class="language-cpp">//指定结点删除操作
void ListDelete_point(LinkList L) {
    //初始化两个指针p和s，分别指向链表的头结点和空指针。
    LinkList p = (LNode *) malloc(sizeof(LinkList));
    LinkList s = (LNode *) malloc(sizeof(LinkList));
    p = L;
    s = NULL;
    
    //定义目标结点的值
    int key;
    printf("请输入需要目标结点的值：");
    scanf("%d",&amp;key);

    //头结点便是目标位置的情况，直接将头指针指向下一个结点
    if(p != NULL &amp;&amp; p-&gt;data == key){
        L = p-&gt;next;
        free(p);
        return;
    }

    //遍历链表直到找到要删除的结点
    while (p != NULL &amp;&amp; p-&gt;data != key){
        s = p;
        p = p-&gt;next;
    }

    if(p == NULL){
        printf("没有找到目标结点的值，删除失败！\n");
        return;
    }

    s-&gt;next = p-&gt;next;    //跳过要删除的结点
    free(p);              //释放要删除的结点的内存空间
    printf("删除成功！\n删除后的链表为：");
}</code></pre> 
<blockquote> 
 <p>例：将链表{10，20，30，40，50}中的数据域为40的结点进行删除。</p> 
</blockquote> 
<p><img alt="" height="525" src="https://images2.imgbox.com/9e/a0/rpHO4pUM_o.png" width="1200"></p> 
<blockquote> 
 <p>如果整个链表中都没有找到目标值则会返回查找失败！</p> 
</blockquote> 
<p><img alt="" height="403" src="https://images2.imgbox.com/d9/44/3srOAGkc_o.png" width="1200"></p> 
<p><strong>注意区分这两种删除的区别：</strong></p> 
<ul><li>指定结点删除是根据结点的数值来确定要删除的结点，即删除具有特定数值的结点。</li><li>按照位序删除是根据结点在链表中的位置（位序）来确定要删除的结点，即删除链表中的第n个结点。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9eb713f3f9b3985e30af0113b07e9704/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">大学生web网页设计期末作业实例代码 (全网最全,建议收藏) HTML&#43;CSS&#43;JS（网页源码）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/90204bfc904a70da3eb03265ac9b21f4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AI绘画利器：Stable-Diffusion-ComfyUI保姆级教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>