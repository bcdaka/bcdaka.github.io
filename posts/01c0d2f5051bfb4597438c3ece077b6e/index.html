<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【深度学习模型】扩散模型(Diffusion Model)基本原理及代码讲解 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/01c0d2f5051bfb4597438c3ece077b6e/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【深度学习模型】扩散模型(Diffusion Model)基本原理及代码讲解">
  <meta property="og:description" content="前言 生成式建模的扩散思想实际上已经在2015年（Sohl-Dickstein等人）提出，然而，直到2019年斯坦福大学（Song等人）、2020年Google Brain（Ho等人）才改进了这个方法，从此引发了生成式模型的新潮流。目前，包括OpenAI的GLIDE和DALL-E 2，海德堡大学的Latent Diffusion和Google Brain的ImageGen，都基于diffusion模型，并可以得到高质量的生成效果。本文以下讲解主要基于DDPM，并适当地增加一些目前有效的改进内容。
基本原理 扩散模型包括两个步骤：
固定的（或预设的）前向扩散过程q：该过程会逐渐将高斯噪声添加到图像中，直到最终得到纯噪声。
可训练的反向去噪扩散过程：训练一个神经网络，从纯噪音开始逐渐去噪，直到得到一个真实图像。
前向与后向的步数由下标 t定义，并且有预先定义好的总步数 T（DDPM原文中为1000）。
t=0 时为从数据集中采样得到的一张真实图片， t=T 时近似为一张纯粹的噪声。
2.1 直观理解 为了看懂扩散模型查了很多资料，但是要么就是大量的数学公式，一行行公式推完了还是不知道它想干啥。要么就是高视角，上来就和能量模型，VAE放一块儿对比说共同点和不同点，看完还是云里雾里。然而事实上下面几句话就能把扩散模型说明白了 扩散模型的目的是什么？ 学习从纯噪声生成图片的方法 扩散模型是怎么做的？ 训练一个U-Net，接受一系列加了噪声的图片，学习预测所加的噪声 前向过程在干啥？ 逐步向真实图片添加噪声最终得到一个纯噪声 对于训练集中的每张图片，都能生成一系列的噪声程度不同的加噪图片 在训练时，这些 【不同程度的噪声图片 &#43; 生成它们所用的噪声】 是实际的训练样本 反向过程在干啥？ 训练好模型后，采样、生成图片 2.2 数学形式 2.2.1 前向过程 是真实数据分布（也就是真实的大量图片），从这个分布中采样即可得到一张真实图片 。我们定义前向扩散过程为 ，即每一个step向图片添加噪声的过程，并定义好一系列，则有：
其中，N为正态分布，均值和方差分别为，因此通过采样标准正态分布，有：
2.2.2 反向过程 那么问题的核心就是如何得到的逆过程 ，这个过程无法直接求出来，所以我们使用神经网络去拟合这一分布。我们使用一个具有参数的神经网络去计算 。假设反向的条件概率分布也是高斯分布，且高斯分布实际上只有两个参数：均值和方差，那么神经网络需要计算的实际上是
在DDPM中，方差被固定，网络只学习均值。而之后的改进模型中，方差也可由网络学习得到。
2.2.3 总结过程 总之，我们定义这么一个过程：给一张图片逐步加噪声直到变成纯粹的噪声，然后对噪声进行去噪得到真实的图片。所谓的扩散模型就是让神经网络学习这个去除噪声的方法。 所谓的加噪声，就是基于稍微干净的图片计算一个（多维）高斯分布（每个像素点都有一个高斯分布，且均值就是这个像素点的值，方差是预先定义的 ），然后从这个多维分布中抽样一个数据出来，这个数据就是加噪之后的结果。显然，如果方差非常非常小，那么每个抽样得到的像素点就和原本的像素点的值非常接近，也就是加了一个非常非常小的噪声。如果方差比较大，那么抽样结果就会和原本的结果差距较大。 去噪声也是同理，我们基于稍微噪声的图片 计算一个条件分布，我们希望从这个分布中抽样得到的是相比于 更加接近真实图片的稍微干净的图片。我们假设这样的条件分布是存在的，并且也是个高斯分布，那么我们只需要知道均值和方差就可以了。问题是这个均值和方差是无法直接计算的，所以用神经网络去学习近似这样一个高斯分布。 2.3 网络训练流程 我们最终要训练的实际上是一个噪声预测器。神经网络输出的噪声是，而真实的噪声取自于正态分布。则损失函数为：
预测网络方面，DDPM采用了 U-Net。
从而，网络的训练流程为：
我们接受一个随机的样本；
我们随机从 1 到 T 采样一个 t；">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-03-23T14:58:49+08:00">
    <meta property="article:modified_time" content="2023-03-23T14:58:49+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【深度学习模型】扩散模型(Diffusion Model)基本原理及代码讲解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><h2>前言</h2></li></ol> 
 <p style="">生成式建模的扩散思想实际上已经在2015年（Sohl-Dickstein等人）提出，然而，直到2019年斯坦福大学（Song等人）、2020年Google Brain（Ho等人）才改进了这个方法，从此引发了生成式模型的新潮流。目前，包括OpenAI的GLIDE和DALL-E 2，海德堡大学的Latent Diffusion和Google Brain的ImageGen，都基于diffusion模型，并可以得到高质量的生成效果。本文以下讲解主要基于<a class="kdocs-link" style="color:#0A6CFF;" href="https://arxiv.org/abs/2006.11239" rel="nofollow noopener noreferrer" target="_blank">DDPM</a>，并适当地增加一些目前有效的改进内容。</p> 
 <p style=""></p> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><h2>基本原理</h2></li></ol> 
 <p style="text-align:null;">扩散模型包括两个步骤：</p> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>固定的（或预设的）前向扩散过程<span class="kdocs-bold" style="font-weight:bold;">q</span>：该过程会逐渐将高斯噪声添加到图像中，直到最终得到纯噪声。</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>可<span class="kdocs-bold" style="font-weight:bold;">训练</span>的反向去噪扩散过程<img class="kdocs-latex-img" src="https://images2.imgbox.com/8e/3c/NCbi8qz5_o.png">：训练一个神经网络，从纯噪音开始逐渐去噪，直到得到一个真实图像。</p></li></ol> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:614px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:22.312702%;height:0;"> 
    <img src="https://images2.imgbox.com/17/e9/MHmOmulM_o.png" style="margin-left:;display:block;width:614px;margin-top:-22.312702%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:null;">前向与后向的步数由下标 t定义，并且有预先定义好的总步数 T（DDPM原文中为1000）。</p> 
 <p style="text-align:null;">t=0 时为从数据集中采样得到的一张真实图片， t=T 时近似为一张纯粹的噪声。</p> 
 <p style="text-align:null;"></p> 
 <h3 style="text-align:null;">2.1 直观理解</h3> 
 <blockquote class="kdocs-blockquote" style="text-align:null;">
   为了看懂扩散模型查了很多资料，但是要么就是大量的数学公式，一行行公式推完了还是不知道它想干啥。要么就是高视角，上来就和能量模型，VAE放一块儿对比说共同点和不同点，看完还是云里雾里。然而事实上下面几句话就能把扩散模型说明白了 
  <br> 
  <span class="kdocs-bold" style="font-weight:bold;">扩散模型的目的是什么？</span> 
  <br>学习从纯噪声生成图片的方法 
  <br> 
  <span class="kdocs-bold" style="font-weight:bold;">扩散模型是怎么做的？</span> 
  <br>训练一个U-Net，接受一系列加了噪声的图片，学习预测所加的噪声 
  <br> 
  <span class="kdocs-bold" style="font-weight:bold;">前向过程在干啥？</span> 
  <br>逐步向真实图片添加噪声最终得到一个纯噪声 
  <br>对于训练集中的每张图片，都能生成一系列的噪声程度不同的加噪图片 
  <br>在训练时，这些 【不同程度的噪声图片 + 生成它们所用的噪声】 是实际的训练样本 
  <br> 
  <span class="kdocs-bold" style="font-weight:bold;">反向过程在干啥？</span> 
  <br>训练好模型后，采样、生成图片 
 </blockquote> 
 <p style=""></p> 
 <h3 style="">2.2 <span class="kdocs-bold" style="font-weight:bold;">数学形式</span></h3> 
 <h4 style="">2.2.1 前向过程</h4> 
 <p style=""> <img class="kdocs-latex-img" src="https://images2.imgbox.com/51/a3/jDX6wRvP_o.png">是真实数据分布（也就是真实的大量图片），从这个分布中采样即可得到一张真实图片 <img class="kdocs-latex-img" src="https://images2.imgbox.com/af/ea/v3S7LVN9_o.png">。我们定义前向扩散过程为 <img class="kdocs-latex-img" src="https://images2.imgbox.com/cb/74/s6lx4pdd_o.png">，即每一个step向图片添加噪声的过程，并定义好一系列<img class="kdocs-latex-img" src="https://images2.imgbox.com/d9/2a/ck3IAvsF_o.png">，则有：</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:268px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:12.313433%;height:0;"> 
    <img src="https://images2.imgbox.com/1f/08/2FC1OwkY_o.png" style="margin-left:;display:block;width:268px;margin-top:-12.313433%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">其中，N为正态分布，均值和方差分别为<img class="kdocs-latex-img" src="https://images2.imgbox.com/0d/d5/YjqUwARz_o.png">，因此通过采样标准正态分布<img class="kdocs-latex-img" src="https://images2.imgbox.com/15/f0/LgTBMFRr_o.png">，有：</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:201px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:10.945273%;height:0;"> 
    <img src="https://images2.imgbox.com/d3/77/Hx6gCkSd_o.png" style="margin-left:;display:block;width:201px;margin-top:-10.945273%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:740px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:51.62162%;height:0;"> 
    <img src="https://images2.imgbox.com/9d/2b/i6E2D1Cy_o.png" style="margin-left:;display:block;width:740px;margin-top:-51.62162%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:740px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:37.297295%;height:0;"> 
    <img src="https://images2.imgbox.com/fe/10/cofNVl7c_o.png" style="margin-left:;display:block;width:740px;margin-top:-37.297295%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:740px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:36.756756%;height:0;"> 
    <img src="https://images2.imgbox.com/33/b4/TSmMmU2G_o.png" style="margin-left:;display:block;width:740px;margin-top:-36.756756%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <h4 style="">2.2.2 反向过程</h4> 
 <p style="text-align:null;">那么问题的核心就是如何得到<img class="kdocs-latex-img" src="https://images2.imgbox.com/0c/e8/rQE9INob_o.png">的逆过程<img class="kdocs-latex-img" src="https://images2.imgbox.com/33/db/gIStLSL5_o.png"> ，这个过程无法直接求出来，所以我们使用神经网络去拟合这一分布。我们使用一个具有参数的神经网络去计算 <img class="kdocs-latex-img" src="https://images2.imgbox.com/d4/dc/Pz3ADOxF_o.png">。假设反向的条件概率分布也是高斯分布，且高斯分布实际上只有两个参数：均值和方差，那么神经网络需要计算的实际上是</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:293px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:8.87372%;height:0;"> 
    <img src="https://images2.imgbox.com/e5/6a/xn7TSgSY_o.png" style="margin-left:;display:block;width:293px;margin-top:-8.87372%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:null;">在DDPM中，方差被固定，网络只学习均值。而之后的改进模型中，方差也可由网络学习得到。</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1253px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:9.337589%;height:0;"> 
    <img src="https://images2.imgbox.com/bf/73/AyFOUsay_o.png" style="margin-left:;display:block;width:1253px;margin-top:-9.337589%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <h4 style="">2.2.3 总结过程</h4> 
 <blockquote class="kdocs-blockquote" style="">
   总之，我们定义这么一个过程：给一张图片逐步加噪声直到变成纯粹的噪声，然后对噪声进行去噪得到真实的图片。所谓的扩散模型就是让神经网络学习这个去除噪声的方法。 
  <br>所谓的加噪声，就是基于稍微干净的图片计算一个（多维）高斯分布（每个像素点都有一个高斯分布，且均值就是这个像素点的值，方差是预先定义的 
  <img class="kdocs-latex-img" src="https://images2.imgbox.com/0b/13/hR8MZexa_o.png">），然后从这个多维分布中抽样一个数据出来，这个数据就是加噪之后的结果。显然，如果方差非常非常小，那么每个抽样得到的像素点就和原本的像素点的值非常接近，也就是加了一个非常非常小的噪声。如果方差比较大，那么抽样结果就会和原本的结果差距较大。 
  <br>去噪声也是同理，我们基于稍微噪声的图片 
  <img class="kdocs-latex-img" src="https://images2.imgbox.com/89/b6/nGD6huUQ_o.png"> 计算一个条件分布，我们希望从这个分布中抽样得到的是相比于 
  <img class="kdocs-latex-img" src="https://images2.imgbox.com/e1/9c/ACYr7kNZ_o.png"> 更加接近真实图片的稍微干净的图片。我们假设这样的条件分布是存在的，并且也是个高斯分布，那么我们只需要知道均值和方差就可以了。问题是这个均值和方差是无法直接计算的，所以用神经网络去学习近似这样一个高斯分布。 
 </blockquote> 
 <p style=""></p> 
 <h3 style="">2.3 网络训练流程</h3> 
 <p style="text-align:null;">我们最终要训练的实际上是一个噪声预测器。神经网络输出的噪声是<img class="kdocs-latex-img" src="https://images2.imgbox.com/1b/b2/zNETMchm_o.png">，而真实的噪声取自于正态分布<img class="kdocs-latex-img" src="https://images2.imgbox.com/59/74/QGDCCRF7_o.png">。则损失函数为：</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:442px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:8.823529%;height:0;"> 
    <img src="https://images2.imgbox.com/c6/51/5Foeeohb_o.png" style="margin-left:;display:block;width:442px;margin-top:-8.823529%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">预测网络方面，DDPM采用了 U-Net。</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:675px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:64.296295%;height:0;"> 
    <img src="https://images2.imgbox.com/5d/97/ixnLhomE_o.jpg" style="margin-left:;display:block;width:675px;margin-top:-64.296295%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">从而，网络的训练流程为：</p> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;text-align:left;"><p>我们接受一个随机的样本<img class="kdocs-latex-img" src="https://images2.imgbox.com/d0/84/St7eAA6t_o.png">；</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;text-align:left;"><p>我们随机从 1 到 T 采样一个 t；</p></li></ol> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;text-align:left;"><p>我们从高斯分布采样一些噪声并且施加在输入上；</p></li></ol> 
 <ol start="4"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;text-align:left;"><p>网络从被影响过后的噪声图片学习其被施加了的噪声。</p></li></ol> 
 <p style=""></p> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><h2>代码</h2></li></ol> 
 <h3 style="">3.1 <span class="kdocs-bold" style="font-weight:bold;">Network helpers</span></h3> 
 <p style="">先是一些辅助函数和类。</p> 
 <pre class="kdocs-python"><code class="language-python">def exists(x):
    return x is not None

# 有val时返回val，val为None时返回d
def default(val, d):
    if exists(val):
        return val
    return d() if isfunction(d) else d

# 残差模块，将输入加到输出上
class Residual(nn.Module):
    def __init__(self, fn):
        super().__init__()
        self.fn = fn

    def forward(self, x, *args, **kwargs):
        return self.fn(x, *args, **kwargs) + x

# 上采样（反卷积）
def Upsample(dim):
    return nn.ConvTranspose2d(dim, dim, 4, 2, 1)

# 下采样
def Downsample(dim):
    return nn.Conv2d(dim, dim, 4, 2, 1)</code></pre> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">3.2 Positional embeddings</span></h3> 
 <p style="text-align:null;">类似于Transformer的positional embedding，为了让网络知道当前处理的是一系列去噪过程中的哪一个step，我们需要将步数 t 也编码并传入网络之中。DDPM采用正弦位置编码（Sinusoidal Positional Embeddings）。这一方法的输入是shape为 (batch_size, 1) 的 tensor，也就是batch中每一个sample所处的t ，并将这个tensor转换为shape为 (batch_size, dim) 的 tensor。这个tensor会被加到每一个残差模块中。</p> 
 <pre class="kdocs-python"><code class="language-python">class SinusoidalPositionEmbeddings(nn.Module):
    def __init__(self, dim):
        super().__init__()
        self.dim = dim

    def forward(self, time):
        device = time.device
        half_dim = self.dim // 2
        embeddings = math.log(10000) / (half_dim - 1)
        embeddings = torch.exp(torch.arange(half_dim, device=device) * -embeddings)
        embeddings = time[:, None] * embeddings[None, :]
        embeddings = torch.cat((embeddings.sin(), embeddings.cos()), dim=-1)
        return embeddings</code></pre> 
 <h3 style="">3.3 <span class="kdocs-bold" style="font-weight:bold;">ResNet/ConvNeXT block</span></h3> 
 <p style="">U-Net的Block实现，可以用ResNet或ConvNeXT。</p> 
 <pre class="kdocs-python"><code class="language-python">class Block(nn.Module):
    def __init__(self, dim, dim_out, groups = 8):
        super().__init__()
        self.proj = nn.Conv2d(dim, dim_out, 3, padding = 1)
        self.norm = nn.GroupNorm(groups, dim_out)
        self.act = nn.SiLU()

    def forward(self, x, scale_shift = None):
        x = self.proj(x)
        x = self.norm(x)

        if exists(scale_shift):
            scale, shift = scale_shift
            x = x * (scale + 1) + shift

        x = self.act(x)
        return x

class ResnetBlock(nn.Module):
    """Deep Residual Learning for Image Recognition"""
    
    def __init__(self, dim, dim_out, *, time_emb_dim=None, groups=8):
        super().__init__()
        self.mlp = (
            nn.Sequential(nn.SiLU(), nn.Linear(time_emb_dim, dim_out))
            if exists(time_emb_dim)
            else None
        )

        self.block1 = Block(dim, dim_out, groups=groups)
        self.block2 = Block(dim_out, dim_out, groups=groups)
        self.res_conv = nn.Conv2d(dim, dim_out, 1) if dim != dim_out else nn.Identity()

    def forward(self, x, time_emb=None):
        h = self.block1(x)

        if exists(self.mlp) and exists(time_emb):
            time_emb = self.mlp(time_emb)
            h = rearrange(time_emb, "b c -&gt; b c 1 1") + h

        h = self.block2(h)
        return h + self.res_conv(x)
    
class ConvNextBlock(nn.Module):
    """A ConvNet for the 2020s"""

    def __init__(self, dim, dim_out, *, time_emb_dim=None, mult=2, norm=True):
        super().__init__()
        self.mlp = (
            nn.Sequential(nn.GELU(), nn.Linear(time_emb_dim, dim))
            if exists(time_emb_dim)
            else None
        )

        self.ds_conv = nn.Conv2d(dim, dim, 7, padding=3, groups=dim)

        Get an email address at self.net. It's ad-free, reliable email that's based on your own name | self.net = nn.Sequential(
            nn.GroupNorm(1, dim) if norm else nn.Identity(),
            nn.Conv2d(dim, dim_out * mult, 3, padding=1),
            nn.GELU(),
            nn.GroupNorm(1, dim_out * mult),
            nn.Conv2d(dim_out * mult, dim_out, 3, padding=1),
        )
        self.res_conv = nn.Conv2d(dim, dim_out, 1) if dim != dim_out else nn.Identity()

    def forward(self, x, time_emb=None):
        h = self.ds_conv(x)

        if exists(self.mlp) and exists(time_emb):
            condition = self.mlp(time_emb)
            h = h + rearrange(condition, "b c -&gt; b c 1 1")

        h = Get an email address at self.net. It's ad-free, reliable email that's based on your own name | self.net(h)
        return h + self.res_conv(x)</code></pre> 
 <h3 style="">3.4 <span class="kdocs-bold" style="font-weight:bold;">Attention module</span></h3> 
 <p style="">包含两种attention模块，一个是常规的 multi-head self-attention，一个是 linear attention variant。</p> 
 <pre class="kdocs-python"><code class="language-python">class Attention(nn.Module):
    def __init__(self, dim, heads=4, dim_head=32):
        super().__init__()
        self.scale = dim_head**-0.5
        self.heads = heads
        hidden_dim = dim_head * heads
        self.to_qkv = nn.Conv2d(dim, hidden_dim * 3, 1, bias=False)
        self.to_out = nn.Conv2d(hidden_dim, dim, 1)

    def forward(self, x):
        b, c, h, w = x.shape
        qkv = self.to_qkv(x).chunk(3, dim=1)
        q, k, v = map(
            lambda t: rearrange(t, "b (h c) x y -&gt; b h c (x y)", h=self.heads), qkv
        )
        q = q * self.scale

        sim = einsum("b h d i, b h d j -&gt; b h i j", q, k)
        sim = sim - sim.amax(dim=-1, keepdim=True).detach()
        attn = sim.softmax(dim=-1)

        out = einsum("b h i j, b h d j -&gt; b h i d", attn, v)
        out = rearrange(out, "b h (x y) d -&gt; b (h d) x y", x=h, y=w)
        return self.to_out(out)

class LinearAttention(nn.Module):
    def __init__(self, dim, heads=4, dim_head=32):
        super().__init__()
        self.scale = dim_head**-0.5
        self.heads = heads
        hidden_dim = dim_head * heads
        self.to_qkv = nn.Conv2d(dim, hidden_dim * 3, 1, bias=False)

        self.to_out = nn.Sequential(nn.Conv2d(hidden_dim, dim, 1), 
                                    nn.GroupNorm(1, dim))

    def forward(self, x):
        b, c, h, w = x.shape
        qkv = self.to_qkv(x).chunk(3, dim=1)
        q, k, v = map(
            lambda t: rearrange(t, "b (h c) x y -&gt; b h c (x y)", h=self.heads), qkv
        )

        q = q.softmax(dim=-2)
        k = k.softmax(dim=-1)

        q = q * self.scale
        context = torch.einsum("b h d n, b h e n -&gt; b h d e", k, v)

        out = torch.einsum("b h d e, b h d n -&gt; b h e n", context, q)
        out = rearrange(out, "b h c (x y) -&gt; b (h c) x y", h=self.heads, x=h, y=w)
        return self.to_out(out)</code></pre> 
 <h3 style="">3.5 <span class="kdocs-bold" style="font-weight:bold;">Group normalization</span></h3> 
 <p style="">DDPM的作者对U-Net的卷积/注意力层使用GN正则化。下面，我们定义了一个PreNorm类，它将被用于在注意力层之前应用groupnorm。值得注意的是，归一化在Transformer中是在注意力之前还是之后应用，目前仍存在着争议。</p> 
 <pre class="kdocs-python"><code class="language-python">class PreNorm(nn.Module):
    def __init__(self, dim, fn):
        super().__init__()
        self.fn = fn
        self.norm = nn.GroupNorm(1, dim)

    def forward(self, x):
        x = self.norm(x)
        return self.fn(x)</code></pre> 
 <h3 style="">3.6 <span class="kdocs-bold" style="font-weight:bold;">Conditional U-Net</span></h3> 
 <p style="text-align:null;">现在，我们已经定义了所有的组件，接下来就是定义完整的网络了。</p> 
 <p style="text-align:null;">输入：噪声图片的batch+这些图片各自的t。</p> 
 <p style="text-align:null;">输出：预测每个图片上所添加的噪声。</p> 
 <blockquote class="kdocs-blockquote" style="">
   Input：a batch of noisy images of shape ( batch_size, num_channels, h, w ) and a batch of steps of shape ( batch_size, 1 ) 
  <br>output: a tensor of shape ( batch_size, num_channels, h, w ) 
 </blockquote> 
 <p style="text-align:null;">具体的网络结构：</p> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>首先，输入通过一个卷积层，同时计算step t 所对应的embedding</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>通过一系列的下采样stage，每个stage都包含：2个ResNet/ConvNeXT blocks + groupnorm + attention + residual connection + downsample operation</p></li></ol> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>在网络中间，应用一个带attention的ResNet或者ConvNeXT</p></li></ol> 
 <ol start="4"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>通过一系列的上采样stage，每个stage都包含：2个ResNet/ConvNeXT blocks + groupnorm + attention + residual connection + upsample operation</p></li></ol> 
 <ol start="5"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>最终，通过一个ResNet/ConvNeXT blocl和一个卷积层。</p></li></ol> 
 <pre class="kdocs-python"><code class="language-python">class Unet(nn.Module):
    def __init__(
        self,
        dim,
        init_dim=None,
        out_dim=None,
        dim_mults=(1, 2, 4, 8),
        channels=3,
        with_time_emb=True,
        resnet_block_groups=8,
        use_convnext=True,
        convnext_mult=2,
    ):
        super().__init__()

        # determine dimensions
        self.channels = channels

        init_dim = default(init_dim, dim // 3 * 2)
        self.init_conv = nn.Conv2d(channels, init_dim, 7, padding=3)

        dims = [init_dim, *map(lambda m: dim * m, dim_mults)]
        in_out = list(zip(dims[:-1], dims[1:]))
        
        if use_convnext:
            block_klass = partial(ConvNextBlock, mult=convnext_mult)
        else:
            block_klass = partial(ResnetBlock, groups=resnet_block_groups)

        # time embeddings
        if with_time_emb:
            time_dim = dim * 4
            self.time_mlp = nn.Sequential(
                SinusoidalPositionEmbeddings(dim),
                nn.Linear(dim, time_dim),
                nn.GELU(),
                nn.Linear(time_dim, time_dim),
            )
        else:
            time_dim = None
            self.time_mlp = None

        # layers
        self.downs = nn.ModuleList([])
        self.ups = nn.ModuleList([])
        num_resolutions = len(in_out)

        for ind, (dim_in, dim_out) in enumerate(in_out):
            is_last = ind &gt;= (num_resolutions - 1)

            self.downs.append(
                nn.ModuleList(
                    [
                        block_klass(dim_in, dim_out, time_emb_dim=time_dim),
                        block_klass(dim_out, dim_out, time_emb_dim=time_dim),
                        Residual(PreNorm(dim_out, LinearAttention(dim_out))),
                        Downsample(dim_out) if not is_last else nn.Identity(),
                    ]
                )
            )

        mid_dim = dims[-1]
        self.mid_block1 = block_klass(mid_dim, mid_dim, time_emb_dim=time_dim)
        self.mid_attn = Residual(PreNorm(mid_dim, Attention(mid_dim)))
        self.mid_block2 = block_klass(mid_dim, mid_dim, time_emb_dim=time_dim)

        for ind, (dim_in, dim_out) in enumerate(reversed(in_out[1:])):
            is_last = ind &gt;= (num_resolutions - 1)

            self.ups.append(
                nn.ModuleList(
                    [
                        block_klass(dim_out * 2, dim_in, time_emb_dim=time_dim),
                        block_klass(dim_in, dim_in, time_emb_dim=time_dim),
                        Residual(PreNorm(dim_in, LinearAttention(dim_in))),
                        Upsample(dim_in) if not is_last else nn.Identity(),
                    ]
                )
            )

        out_dim = default(out_dim, channels)
        self.final_conv = nn.Sequential(
            block_klass(dim, dim), nn.Conv2d(dim, out_dim, 1)
        )

    def forward(self, x, time):
        x = self.init_conv(x)
        t = self.time_mlp(time) if exists(self.time_mlp) else None
        h = []

        # downsample
        for block1, block2, attn, downsample in self.downs:
            x = block1(x, t)
            x = block2(x, t)
            x = attn(x)
            h.append(x)
            x = downsample(x)

        # bottleneck
        x = self.mid_block1(x, t)
        x = self.mid_attn(x)
        x = self.mid_block2(x, t)

        # upsample
        for block1, block2, attn, upsample in self.ups:
            x = torch.cat((x, h.pop()), dim=1)
            x = block1(x, t)
            x = block2(x, t)
            x = attn(x)
            x = upsample(x)

        return self.final_conv(x)</code></pre> 
 <h3 style="">3.7 <span class="kdocs-bold" style="font-weight:bold;">定义前向扩散过程</span></h3> 
 <p style="text-align:null;">DDPM中使用linear schedule定义 <img class="kdocs-latex-img" src="https://images2.imgbox.com/c8/2b/5VP0dF2v_o.png"> 。<a class="kdocs-link" style="color:#0A6CFF;" href="https://link.zhihu.com/?target=https%3A//arxiv.org/abs/2102.09672" rel="nofollow noopener noreferrer" target="_blank">后续的研究</a>指出使用cosine schedule可能会有更好的效果。</p> 
 <p style="text-align:null;">接下来是一些简单的对于 schedule 的定义，从当中选一个使用即可。</p> 
 <pre class="kdocs-python"><code class="language-python">def cosine_beta_schedule(timesteps, s=0.008):
    """
    cosine schedule as proposed in https://arxiv.org/abs/2102.09672
    """
    steps = timesteps + 1
    x = torch.linspace(0, timesteps, steps)
    alphas_cumprod = torch.cos(((x / timesteps) + s) / (1 + s) * torch.pi * 0.5) ** 2
    alphas_cumprod = alphas_cumprod / alphas_cumprod[0]
    betas = 1 - (alphas_cumprod[1:] / alphas_cumprod[:-1])
    return torch.clip(betas, 0.0001, 0.9999)

def linear_beta_schedule(timesteps):
    beta_start = 0.0001
    beta_end = 0.02
    return torch.linspace(beta_start, beta_end, timesteps)

def quadratic_beta_schedule(timesteps):
    beta_start = 0.0001
    beta_end = 0.02
    return torch.linspace(beta_start**0.5, beta_end**0.5, timesteps) ** 2

def sigmoid_beta_schedule(timesteps):
    beta_start = 0.0001
    beta_end = 0.02
    betas = torch.linspace(-6, 6, timesteps)
    return torch.sigmoid(betas) * (beta_end - beta_start) + beta_start
</code></pre> 
 <p style="text-align:null;">我们按照DDPM中用第二种的linear，将 T 设置为200，并将每个 t 下的各种参数提前计算好。</p> 
 <pre class="kdocs-python"><code class="language-python">timesteps = 200

# define beta schedule
betas = linear_beta_schedule(timesteps=timesteps)

# define alphas 
alphas = 1. - betas
alphas_cumprod = torch.cumprod(alphas, axis=0)
alphas_cumprod_prev = F.pad(alphas_cumprod[:-1], (1, 0), value=1.0)
sqrt_recip_alphas = torch.sqrt(1.0 / alphas)

# calculations for diffusion q(x_t | x_{t-1}) and others
sqrt_alphas_cumprod = torch.sqrt(alphas_cumprod)
sqrt_one_minus_alphas_cumprod = torch.sqrt(1. - alphas_cumprod)

# calculations for posterior q(x_{t-1} | x_t, x_0)
posterior_variance = betas * (1. - alphas_cumprod_prev) / (1. - alphas_cumprod)

def extract(a, t, x_shape):
    batch_size = t.shape[0]
    out = a.gather(-1, t.cpu())
    return out.reshape(batch_size, *((1,) * (len(x_shape) - 1))).to(t.device)</code></pre> 
 <p style="">我们用一个实例来说明前向加噪过程。</p> 
 <pre class="kdocs-python"><code class="language-python">from PIL import Image
import requests

url = 'http://images.cocodataset.org/val2017/000000039769.jpg'
image = Image.open(requests.get(url, stream=True).raw)
image</code></pre> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:423px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:74.9409%;height:0;"> 
    <img src="https://images2.imgbox.com/e2/69/fv5KalIF_o.jpg" style="margin-left:;display:block;width:423px;margin-top:-74.9409%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <pre class="kdocs-python"><code class="language-python">from torchvision.transforms import Compose, ToTensor, Lambda, ToPILImage, CenterCrop, Resize

image_size = 128
transform = Compose([
    Resize(image_size),
    CenterCrop(image_size),
    ToTensor(), # turn into Numpy array of shape HWC, divide by 255
    Lambda(lambda t: (t * 2) - 1),
])

x_start = transform(image).unsqueeze(0)
x_start.shape  # 输出的结果是 torch.Size([1, 3, 128, 128])

import numpy as np

reverse_transform = Compose([
     Lambda(lambda t: (t + 1) / 2),
     Lambda(lambda t: t.permute(1, 2, 0)), # CHW to HWC
     Lambda(lambda t: t * 255.),
     Lambda(lambda t: t.numpy().astype(np.uint8)),
     ToPILImage(),
])</code></pre> 
 <p style="">准备齐全，接下来就可以定义正向扩散过程了。</p> 
 <pre class="kdocs-python"><code class="language-python"># forward diffusion (using the nice property)
def q_sample(x_start, t, noise=None):
    if noise is None:
        noise = torch.randn_like(x_start)

    sqrt_alphas_cumprod_t = extract(sqrt_alphas_cumprod, t, x_start.shape)
    sqrt_one_minus_alphas_cumprod_t = extract(
        sqrt_one_minus_alphas_cumprod, t, x_start.shape
    )

    return sqrt_alphas_cumprod_t * x_start + sqrt_one_minus_alphas_cumprod_t * noise

def get_noisy_image(x_start, t):
  # add noise
  x_noisy = q_sample(x_start, t=t)

  # turn back into PIL image
  noisy_image = reverse_transform(x_noisy.squeeze())

  return noisy_image</code></pre> 
 <p style="">可视化一下多个不同t的生成结果。</p> 
 <pre class="kdocs-python"><code class="language-python">import matplotlib.pyplot as plt

# use seed for reproducability
torch.manual_seed(0)

# source: https://pytorch.org/vision/stable/auto_examples/plot_transforms.html#sphx-glr-auto-examples-plot-transforms-py
def plot(imgs, with_orig=False, row_title=None, **imshow_kwargs):
    if not isinstance(imgs[0], list):
        # Make a 2d grid even if there's just 1 row
        imgs = [imgs]

    num_rows = len(imgs)
    num_cols = len(imgs[0]) + with_orig
    fig, axs = plt.subplots(figsize=(200,200), nrows=num_rows, ncols=num_cols, squeeze=False)
    for row_idx, row in enumerate(imgs):
        row = [image] + row if with_orig else row
        for col_idx, img in enumerate(row):
            ax = axs[row_idx, col_idx]
            ax.imshow(np.asarray(img), **imshow_kwargs)
            ax.set(xticklabels=[], yticklabels=[], xticks=[], yticks=[])

    if with_orig:
        axs[0, 0].set(title='Original image')
        axs[0, 0].title.set_size(8)
    if row_title is not None:
        for row_idx in range(num_rows):
            axs[row_idx, 0].set(ylabel=row_title[row_idx])

    plt.tight_layout()

plot([get_noisy_image(x_start, torch.tensor([t])) for t in [0, 50, 100, 150, 199]])</code></pre> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:740px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:20.0%;height:0;"> 
    <img src="https://images2.imgbox.com/fc/0a/LZk1xozD_o.png" style="margin-left:;display:block;width:740px;margin-top:-20.0%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <h3 style="">3.8 定义损失函数</h3> 
 <pre class="kdocs-python"><code class="language-python">def p_losses(denoise_model, x_start, t, noise=None, loss_type="l1"):
    # 先采样噪声
    if noise is None:
        noise = torch.randn_like(x_start)
    
    # 用采样得到的噪声去加噪图片
    x_noisy = q_sample(x_start=x_start, t=t, noise=noise)
    predicted_noise = denoise_model(x_noisy, t)
    
    # 根据加噪了的图片去预测采样的噪声
    if loss_type == 'l1':
        loss = F.l1_loss(noise, predicted_noise)
    elif loss_type == 'l2':
        loss = F.mse_loss(noise, predicted_noise)
    elif loss_type == "huber":
        loss = F.smooth_l1_loss(noise, predicted_noise)
    else:
        raise NotImplementedError()

    return loss</code></pre> 
 <h3 style="">3.9 <span class="kdocs-bold" style="font-weight:bold;">定义数据集 PyTorch Dataset 和 DataLoader</span></h3> 
 <p style="">我们使用mnist数据集构造了一个 DataLoader，每个batch由128张 normalize 过的 image 组成。</p> 
 <pre class="kdocs-python"><code class="language-python">from datasets import load_dataset

# load dataset from the hub
dataset = load_dataset("fashion_mnist")
image_size = 28
channels = 1
batch_size = 128


from torchvision import transforms
from torch.utils.data import DataLoader

transform = Compose([
            transforms.RandomHorizontalFlip(),
            transforms.ToTensor(),
            transforms.Lambda(lambda t: (t * 2) - 1)
])

def transforms(examples):
   examples["pixel_values"] = [transform(image.convert("L")) for image in examples["image"]]
   del examples["image"]

   return examples

transformed_dataset = dataset.with_transform(transforms).remove_columns("label")
dataloader = DataLoader(transformed_dataset["train"], batch_size=batch_size, shuffle=True)
batch = next(iter(dataloader))
print(batch.keys())    # dict_keys(['pixel_values'])</code></pre> 
 <h3 style="">3.10 采样</h3> 
 <p style="text-align:null;">采样过程发生在反向去噪时。对于一张纯噪声，扩散模型一步步地去除噪声最终得到真实图片，采样事实上就是定义的<span class="kdocs-bold" style="font-weight:bold;">去除噪声</span>这一行为。 观察采样算法中第四行， t−1 步的图片是由 t 步的图片减去一个噪声得到的，只不过这个噪声是由网络拟合出来，并且 rescale 过的而已。 这里要注意第四行式子的最后一项，采样时每一步也都会加上一个从正态分布采样的纯噪声。理想情况下，最终我们会得到一张看起来像是从真实数据分布中采样得到的图片。</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:382px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:48.95288%;height:0;"> 
    <img src="https://images2.imgbox.com/0c/bb/mBFlllmC_o.png" style="margin-left:;display:block;width:382px;margin-top:-48.95288%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <pre class="kdocs-python"><code class="language-python">@torch.no_grad()
def p_sample(model, x, t, t_index):
    betas_t = extract(betas, t, x.shape)
    sqrt_one_minus_alphas_cumprod_t = extract(
        sqrt_one_minus_alphas_cumprod, t, x.shape
    )
    sqrt_recip_alphas_t = extract(sqrt_recip_alphas, t, x.shape)
    
    # Equation 11 in the paper
    # Use our model (noise predictor) to predict the mean
    model_mean = sqrt_recip_alphas_t * (
        x - betas_t * model(x, t) / sqrt_one_minus_alphas_cumprod_t
    )

    if t_index == 0:
        return model_mean
    else:
        posterior_variance_t = extract(posterior_variance, t, x.shape)
        noise = torch.randn_like(x)
        # Algorithm 2 line 4:
        return model_mean + torch.sqrt(posterior_variance_t) * noise 

# Algorithm 2 (including returning all images)
@torch.no_grad()
def p_sample_loop(model, shape):
    device = next(model.parameters()).device

    b = shape[0]
    # start from pure noise (for each example in the batch)
    img = torch.randn(shape, device=device)
    imgs = []

    for i in tqdm(reversed(range(0, timesteps)), desc='sampling loop time step', total=timesteps):
        img = p_sample(model, img, torch.full((b,), i, device=device, dtype=torch.long), i)
        imgs.append(img.cpu().numpy())
    return imgs

@torch.no_grad()
def sample(model, image_size, batch_size=16, channels=3):
    return p_sample_loop(model, shape=(batch_size, channels, image_size, image_size))</code></pre> 
 <h3 style="">3.11 训练</h3> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:376px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:49.734043%;height:0;"> 
    <img src="https://images2.imgbox.com/68/94/fqrDIHzJ_o.png" style="margin-left:;display:block;width:376px;margin-top:-49.734043%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">先定义一些辅助生成图片的函数。</p> 
 <pre class="kdocs-python"><code class="language-python">from pathlib import Path

def num_to_groups(num, divisor):
    groups = num // divisor
    remainder = num % divisor
    arr = [divisor] * groups
    if remainder &gt; 0:
        arr.append(remainder)
    return arr

results_folder = Path("./results")
results_folder.mkdir(exist_ok = True)
save_and_sample_every = 1000</code></pre> 
 <p style="text-align:null;">接下来实例化模型。</p> 
 <pre class="kdocs-python"><code class="language-python">from torch.optim import Adam

device = "cuda" if torch.cuda.is_available() else "cpu"

model = Unet(
    dim=image_size,
    channels=channels,
    dim_mults=(1, 2, 4,)
)
model.to(device)

optimizer = Adam(model.parameters(), lr=1e-3)</code></pre> 
 <p style="text-align:null;">开始训练！</p> 
 <pre class="kdocs-python"><code class="language-python">from torchvision.utils import save_image

epochs = 6

for epoch in range(epochs):
    for step, batch in enumerate(dataloader):
      optimizer.zero_grad()

      batch_size = batch["pixel_values"].shape[0]
      batch = batch["pixel_values"].to(device)

      # Algorithm 1 line 3: sample t uniformally for every example in the batch
      t = torch.randint(0, timesteps, (batch_size,), device=device).long()

      loss = p_losses(model, batch, t, loss_type="huber")

      if step % 100 == 0:
        print("Loss:", loss.item())

      loss.backward()
      optimizer.step()

      # save generated images
      if step != 0 and step % save_and_sample_every == 0:
        milestone = step // save_and_sample_every
        batches = num_to_groups(4, batch_size)
        all_images_list = list(map(lambda n: sample(model, batch_size=n, channels=channels), batches))
        all_images = torch.cat(all_images_list, dim=0)
        all_images = (all_images + 1) * 0.5
        save_image(all_images, str(results_folder / f'sample-{milestone}.png'), nrow = 6)</code></pre> 
 <p style="text-align:null;">Inference：</p> 
 <pre class="kdocs-python"><code class="language-python"># sample 64 images
samples = sample(model, image_size=image_size, batch_size=64, channels=channels)

# show a random one
random_index = 5
plt.imshow(samples[-1][random_index].reshape(image_size, image_size, channels), cmap="gray")</code></pre> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:251px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:98.80478%;height:0;"> 
    <img src="https://images2.imgbox.com/2c/44/0QYZhQCt_o.png" style="margin-left:;display:block;width:251px;margin-top:-98.80478%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <pre class="kdocs-python"><code class="language-python">import matplotlib.animation as animation

random_index = 53

fig = plt.figure()
ims = []
for i in range(timesteps):
    im = plt.imshow(samples[i][random_index].reshape(image_size, image_size, channels), cmap="gray", animated=True)
    ims.append([im])

animate = animation.ArtistAnimation(fig, ims, interval=50, blit=True, repeat_delay=1000)
animate.save('diffusion.gif')
plt.show()</code></pre> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:432px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:66.666664%;height:0;"> 
    <img src="https://images2.imgbox.com/6d/fa/1uvyy3j6_o.gif" style="margin-left:;display:block;width:432px;margin-top:-66.666664%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <h2 style="">4. 参考文献</h2> 
 <p style=""><a class="kdocs-link" style="color:#0A6CFF;" href="https://zhuanlan.zhihu.com/p/572161541" rel="nofollow noopener noreferrer" target="_blank">原理+代码：Diffusion Model 直观理解</a></p> 
 <p style=""><a class="kdocs-link" style="color:#0A6CFF;" href="https://huggingface.co/blog/annotated-diffusion" rel="nofollow noopener noreferrer" target="_blank">The Annotated Diffusion Model</a></p> 
 <p style=""><a class="kdocs-link" style="color:#0A6CFF;" href="https://blog.csdn.net/m0_63642362/article/details/127586200" target="_blank" rel="noopener noreferrer">【diffusion】扩散模型详解！理论＋代码</a></p> 
 <p style=""></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/30f15c821355ff9ae4bae09ceb44ffbf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【排序算法】归并排序与快速排序</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ae420adfbf4120629421f9c8c5de6b28/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">React 入门（超详细）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>