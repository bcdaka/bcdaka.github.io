<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>iOS——通知协议代理 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/fbaf8d7501553c0bdc54b3109ead24dd/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="iOS——通知协议代理">
  <meta property="og:description" content="通知 概要 观察者和被观察者都无需知晓对方，只需要通过标记在NSNotificationCenter中找到监听该通知所对应的类，从而调用该类的方法。并且在NSNotificationCenter中，观察者可以只订阅某一特定的通知，并对其做出相应操作，而不用对某一个类发的所有通知都进行更新操作。NSNotificationCenter对观察者的调用不是随机的，而是遵循注册顺序一一执行的，并且在该线程内是同步的 自定义实现通知方法： 通知的原理 通知机制的核心是一个与线程关联的单例对象叫通知中心（NSNotificationCenter）。通知中心发送通知给观察者是同步的，也可以用通知队列（NSNotificationQueue）异步发送通知。
数据结构 通知是一个单例。
static NSNotificationCenter *default_center = nil; &#43; (NSNotificationCenter*) defaultCenter { return default_center; } 通知中心NSNotificationCenter的单例类中存放着两个表，一个存储所有注册通知信息的表的结构体，一个保存单个注册信息的节点结构体。
typedef struct NCTbl { Observation *wildcard; // 添加观察者时既没有传入 NotificationName ，又没有传入object，就会加在这个链表上，它里边的观察者可以接收所有的系统通知 GSIMapTable nameless; // 添加观察者时没有传入 NotificationName 的表 GSIMapTable named; // 添加观察者时传入了 NotificationName 的表 } NCTable typedef struct Obs { id observer; // 观察者对象 SEL selector; // 方法信息 struct Obs *next; // 指向下一个节点 int retained; /* Retain count for structure. */ struct NCTbl *link; /* Pointer back to chunk table */ } Observation; 解释一下NCTbl中三个表的作用：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-09-05T21:10:43+08:00">
    <meta property="article:modified_time" content="2024-09-05T21:10:43+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">iOS——通知协议代理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>通知</h2> 
<h3><a id="_1"></a>概要</h3> 
<ul><li>观察者和被观察者都无需知晓对方，只需要通过标记在<code>NSNotificationCenter</code>中找到监听该通知所对应的类，从而调用该类的方法。</li><li>并且在<code>NSNotificationCenter</code>中，观察者可以只订阅某一特定的通知，并对其做出相应操作，而不用对某一个类发的所有通知都进行更新操作。</li><li><code>NSNotificationCenter</code>对观察者的调用不是随机的，而是遵循注册顺序一一执行的，并且在该线程内是同步的</li></ul> 
<h3><a id="_6"></a>自定义实现通知方法：</h3> 
<h3><a id="_8"></a>通知的原理</h3> 
<p>通知机制的核心是一个与线程关联的单例对象叫通知中心（<code>NSNotificationCenter</code>）。通知中心发送通知给观察者是同步的，也可以用通知队列（<code>NSNotificationQueue</code>）异步发送通知。</p> 
<h4><a id="_10"></a>数据结构</h4> 
<p>通知是一个单例。</p> 
<pre><code class="prism language-objectivec"><span class="token keyword">static</span> NSNotificationCenter <span class="token operator">*</span>default_center <span class="token operator">=</span> nil<span class="token punctuation">;</span>

<span class="token operator">+</span> <span class="token punctuation">(</span>NSNotificationCenter<span class="token operator">*</span><span class="token punctuation">)</span> defaultCenter
<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> default_center<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>通知中心<code>NSNotificationCenter</code>的单例类中存放着两个表，一个存储所有注册通知信息的表的结构体，一个保存单个注册信息的节点结构体。</p> 
<pre><code class="prism language-objectivec"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> NCTbl <span class="token punctuation">{<!-- --></span>
  Observation       <span class="token operator">*</span>wildcard<span class="token punctuation">;</span>  <span class="token comment">// 添加观察者时既没有传入 NotificationName ，又没有传入object，就会加在这个链表上，它里边的观察者可以接收所有的系统通知</span>
  GSIMapTable       nameless<span class="token punctuation">;</span>   <span class="token comment">// 添加观察者时没有传入 NotificationName 的表</span>
  GSIMapTable       named<span class="token punctuation">;</span>      <span class="token comment">// 添加观察者时传入了 NotificationName 的表</span>
<span class="token punctuation">}</span> NCTable
</code></pre> 
<pre><code class="prism language-objectivec"><span class="token keyword">typedef</span> <span class="token keyword">struct</span>  Obs <span class="token punctuation">{<!-- --></span>
  id        observer<span class="token punctuation">;</span>   <span class="token comment">// 观察者对象</span>
  SEL       selector<span class="token punctuation">;</span>   <span class="token comment">// 方法信息</span>
  <span class="token keyword">struct</span> Obs    <span class="token operator">*</span>next<span class="token punctuation">;</span>      <span class="token comment">// 指向下一个节点</span>
  <span class="token keyword">int</span>       retained<span class="token punctuation">;</span>   <span class="token comment">/* Retain count for structure.  */</span>
  <span class="token keyword">struct</span> NCTbl  <span class="token operator">*</span>link<span class="token punctuation">;</span>      <span class="token comment">/* Pointer back to chunk table  */</span>
<span class="token punctuation">}</span> Observation<span class="token punctuation">;</span>
</code></pre> 
<p>解释一下NCTbl中三个表的作用：</p> 
<ul><li>name表：<br> 作用：<br> 管理通知名称和对应的观察者。</li></ul> 
<p>结构：<br> Key：通知名称（NotificationName），用于区分不同类型的通知。<br> Value：一个链表，保存所有注册了该通知名称的观察者。每个观察者可能会绑定一个特定的对象（object）。</p> 
<p>对象 (object) 的作用：<br> 当注册观察者时，可以指定一个对象（object），只监听该对象发出的通知。<br> 如果 object 参数为 nil，系统会自动生成一个特殊的 nil 键，这个键对应的链表中保存了所有没有指定 object 的观察者。这样，nil 键可以用来管理所有未绑定特定对象的观察者。</p> 
<p><img src="https://images2.imgbox.com/a8/00/VRQPXS4n_o.png" alt="在这里插入图片描述"></p> 
<ul><li>nameless 表<br> 作用：管理没有指定通知名称的观察者。</li></ul> 
<p>结构：<br> Key：object，观察者对象。<br> Value：链表，保存所有注册了该对象的观察者。</p> 
<p>nameless 表没有通知名称的约束，仅通过 object 来管理观察者。它的作用是处理那些未指定通知名称的情况，即所有未绑定特定通知名称的观察者。</p> 
<p>￼<img src="https://images2.imgbox.com/7a/f8/nRRn0O6L_o.png" alt="在这里插入图片描述"></p> 
<ul><li>wildcard 表<br> 作用：管理能够接收所有通知的观察者。</li></ul> 
<p>结构：<br> Value：链表，保存所有可以接收任何通知的观察者。</p> 
<p>wildcard 表既没有通知名称 (NotificationName)，也没有对象 (object)。它的链表存储了所有可以接收任意通知的观察者。这种设置通常用于管理那些对所有通知感兴趣的观察者。<br> ￼ ￼<img src="https://images2.imgbox.com/d5/8d/UeU1pybX_o.png" alt="在这里插入图片描述"></p> 
<p><strong>为什么 wildcard 需要使用链表？</strong><br> 动态插入和删除：<br> 链表允许在运行时动态插入和删除节点，这对于通知系统来说非常重要，因为观察者可能在不同的时间点注册和注销。</p> 
<p>管理多个观察者：<br> 一个 wildcard 链表可以存储多个观察者，这些观察者对所有类型的通知感兴趣。因此，链表是一种有效的数据结构来管理这些观察者。</p> 
<p>高效的遍历：<br> 链表支持顺序遍历操作，这对于触发通知时遍历所有注册的观察者非常有用。</p> 
<h4><a id="_88"></a>实现原理</h4> 
<p>使用方法addObserver:selector:name:object添加观察者流程总结：</p> 
<ol><li>首先会根据传入的参数实例化一个 Observation，Observation 对象保存了观察者对象，接收到通知观察者所执行的方法，以及下一个 Observation 对象的地址。</li><li>根据是否传入 NotificationName 选择操作 Named Table 还是 Nameless Table。</li><li>若传入了 NotificationName，则会以 NotificationName 为 key 去查找对应的 Value，若找到 value，则取出对应的 value；若未找到对应的 value，则新建一个 table，然后将这个 table 以 NotificationName 为 key 添加到 Named Table 中。</li><li>若在保存 Observation 的 table 中，以 object（接收通知的对象） 为 key 取对应的链表。若找到了则直接在链接末尾插入之前实例化好的 Observation；若未找到则以之前实例化好的 Observation 对象作为头节点插入进去。</li><li>若既没有 NotificationName 也没有 object，那么就加在 wildcard 链表中</li></ol> 
<p>使用方法postNotification发送通知流程总结：</p> 
<ol><li>首先会创建一个数组 observerArray 用来保存需要通知的 observer。</li><li>遍历 wildcard 链表（为了使接收所有通知的观察者也接收到消息），将 observer 添加到 observerArray 数组中。</li><li>若存在 object（接收通知的对象），在 nameless table 中找到以 object 为 key 的链表，然后遍历找到的链表，将 observer 添加到 observerArray 数组中。</li><li>若存在 NotificationName，在 named table 中以 NotificationName 为 key 找到对应的 table，然后再在找到的 table 中以 object 为 key 找到对应的链表，遍历链表，将 observer 添加到 observerArray 数组中。如果 object 不 为nil，则以 nil 为 key 找到对应的链表，遍历链表，将 observer 添加到 observerArray 数组中。</li><li>至此所有关于当前通知的 observer（wildcard + nameless + named）都已经加入到了数组 observerArray 中。遍历 observerArray 数组，取出其中 的observer 节点（包含了观察者对象和 selector）其中调用观察者的方法，调用形式如下:</li></ol> 
<pre><code class="prism language-objc"><span class="token punctuation">[</span>o<span class="token operator">-&gt;</span>observer performSelector<span class="token punctuation">:</span> o<span class="token operator">-&gt;</span>selector withObject<span class="token punctuation">:</span> notification<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre> 
<p>移除通知的流程总结：</p> 
<ol><li>若 NotificationName 和 object 都为 nil，则清空 wildcard 链表。</li><li>若 NotificationName 为 nil，遍历 named table，若 object 为 nil，则清空 named table，若 object 不为 nil，则以 object 为 key 找到对应的链表，然后清空链表。在 nameless table 中以 object 为 key 找到对应的 observer 链表，然后清空，若 object 也为 nil，则清空 nameless table。</li><li>若 NotificationName 不为nil，在 named table 中以 NotificationName 为 key 找到对应的 table，若 object 为 nil，则清空找到的 table，若 object 不为 nil，则以 object 为 key 在找到的 table 中取出对应的链表，然后清空链表。</li></ol> 
<p><strong>通知的发送时同步的，还是异步的？发送消息与接收消息的线程是同一个线程么？</strong><br> 通知中心发送通知给观察者是同步的，也可以用通知队列（<code>NSNotificationQueue</code>）异步发送通知。</p> 
<h3><a id="NSNotificationQueue_119"></a>NSNotificationQueue(通知队列)</h3> 
<p><code>NSNotificationQueue</code>是<code>notification Center</code>的缓冲池。如果我们使用普通的<code>postNotification</code>这种方法来发送通知，那么这个通知就会直接发送到<code>notification Center</code>，<code>notification Center</code>则会直接将其发送给注册了该通知的观察者。但是如果我们使用<code>NSNotificationQueue</code>就不一样了，通知不是直接发送给<code>notification Center</code>，而是先发送给<code>NSNotificationQueue</code>，然后由<code>NSNotificationQueue</code>决定在当前<code>runloop</code>结束或者空闲的时候转发给<code>notification Center</code>，再由<code>notification</code>转发给注册的观察者。通过<code>NSNotificationQueue</code>，可以合并重复的通知，以便只发送一个通知。</p> 
<p><code>NSNotificationQueue</code>遵循<strong>FIFO</strong>的顺序，当一个通知移动到<code>NSNotificationQueue</code>的最前面，它就被发送给<code>notification Center</code>，然后<code>notification Center</code>再将通知转发给注册了该通知的监听者。<br> 每一个线程都有一个默认的<code>NSNotificationQueue</code>，这个<code>NSNotificationQueue</code>和通知中心联系在一起。当然我们也可以自己创建<code>NSNotificationQueue</code>，可以为一个线程创建多个<code>NSNotificationQueue</code>。</p> 
<h2><a id="_127"></a>单例模式</h2> 
<p>系统为我们提供的单例类有：</p> 
<pre><code>UIApplication(应用程序实例类)
NSNotificationCenter(消息中心类)
NSFileManager(文件管理类)
NSUserDefaults(应用程序设置)
NSURLCache(请求缓存类)
NSHTTPCookieStorage(应用程序cookies池)
</code></pre> 
<p>单例的GCD写法：</p> 
<pre><code class="prism language-objectivec"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">import</span> <span class="token string">"AModel.h"</span></span>

<span class="token keyword">static</span> id _instance <span class="token operator">=</span> nil<span class="token punctuation">;</span>
<span class="token keyword">@implementation</span> AModel

<span class="token operator">+</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span>sharInstance <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token keyword">self</span> alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//将我们原先写在自定义初始化方法中的内容写到allocWithZone中</span>
<span class="token operator">+</span> <span class="token punctuation">(</span>instancetype<span class="token punctuation">)</span>allocWithZone<span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token keyword">struct</span> _NSZone <span class="token operator">*</span><span class="token punctuation">)</span>zone <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">static</span> dispatch_once_t onceToken<span class="token punctuation">;</span>
    <span class="token function">dispatch_once</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>onceToken<span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{<!-- --></span>
        _instance <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">super</span> allocWithZone<span class="token punctuation">:</span>zone<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> _instance<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//重写 copyWithZone:方法,避免实例对象的 copy 操作导致创建新的对象</span>
<span class="token operator">-</span><span class="token punctuation">(</span>instancetype<span class="token punctuation">)</span>copyWithZone<span class="token punctuation">:</span><span class="token punctuation">(</span>NSZone <span class="token operator">*</span><span class="token punctuation">)</span>zone
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">//由于是对象方法，说明可能存在_instance对象，直接返回即可</span>
    <span class="token keyword">return</span> _instance<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">@end</span>
</code></pre> 
<h2><a id="_169"></a>代理模式</h2> 
<p>协议是多个类（或者说对象）之间协商的一个公共接口，提供一系列方法的声明给类们使用；而代理是协议的一个典型应用机制。<br> 代理模式的核心思想是通过代理接口分离使用者和服务提供者，降低了模块之间的耦合度。在实际中灵活使用代理模式可以让我们写出更优质的模块结构的代码。</p> 
<p>代理就是自己不想做的事情，让代理做。（类似老板和秘书）<br> <img src="https://images2.imgbox.com/7b/69/e7TgDtJk_o.png" alt="在这里插入图片描述"></p> 
<p>代理设计模式的场合:</p> 
<ol><li>当对象A发生了一些行为,想告知对象B(让对象B成为对象A的代理对象)</li><li>对象B想监听对象A的一些行为(让对象B成为对象A的代理对象)</li><li>当对象A无法处理某些行为的时候,想让对象B帮忙处理(让对象B成为对象A的代理对象)</li></ol> 
<p>协议的编写规范:</p> 
<ol><li>一般情况下, 当前协议属于谁, 我们就将协议定义到谁的头文件中</li><li>协议的名称一般以它属于的那个类的类名开头, 后面跟上protocol或者delegate</li><li>协议中的方法名称一般以协议���名称protocol之前的作为开头</li><li>一般情况下协议中的方法会将触发该协议的对象传递出去</li><li>一般情况下一个类中的代理属于的名称叫做 delegate</li><li>当某一个类要成为另外一个类的代理的时候, 一般情况下在.h中用@protocol 协议名称;告诉当前类 这是一个协议.在.m中用#import真正的导入一个协议的声明</li></ol> 
<p>注意：</p> 
<ol><li>协议不能声明成员变量,不能写实现</li><li>只要父类遵守了某个协议,那么子类也遵守</li><li>协议可以遵守协议,一个协议遵守了另一个协议,就可以拥有另一份协议中的方法声明</li></ol> 
<p>协议中有2个关键字可以控制方法是否要实现(默认是@required，在大多数情况下，用途在于程序员之间的交流)</p> 
<ul><li>@required：这个方法必须要实现（若不实现，编译器会发出警告）</li><li>@optional：这个方法不一定要实现</li></ul> 
<h3><a id="_198"></a>代理的原理</h3> 
<p>在iOS中代理的本质就是代理对象内存的传递和操作，我们在委托类设置代理对象后，实际上只是用一个id类型的指针将代理对象进行了一个弱引用。委托方让代理方执行操作，实际上是在委托类中向这个id类型指针指向的对象发送消息，而这个id类型指针指向的对象，就是代理对象。￼<br> <img src="https://images2.imgbox.com/e2/6d/n5Wushc1_o.png" alt="请添加图片描述"></p> 
<p>这里，将代理对象进行弱引用的作用是为了避免循环引用</p> 
<h3><a id="_204"></a>代理的循环引用</h3> 
<p>比如以下代码：B强引用A，而A的delegate属性指向B，这里的delegate是用strong修饰的，所以A也会强引用B，这是一个比较典型的循环引用样例。所以要将代理delegate改为弱引用weak。</p> 
<pre><code class="prism language-objc"><span class="token keyword">@protocol</span> ClssADelegate
－ <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>eat<span class="token punctuation">;</span>
<span class="token keyword">@end</span>

<span class="token keyword">@interface</span> ClassA <span class="token punctuation">:</span> UIViewController
<span class="token keyword">@property</span> <span class="token punctuation">(</span>nonatomic<span class="token punctuation">,</span> strong<span class="token punctuation">)</span> id  delegate<span class="token punctuation">;</span>
<span class="token keyword">@end</span>

<span class="token comment">//ClassB:</span>
<span class="token keyword">@interface</span> <span class="token function">ClassB</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">@property</span> <span class="token punctuation">(</span>nonatomic<span class="token punctuation">,</span> strong<span class="token punctuation">)</span> ClassA <span class="token operator">*</span>classA<span class="token punctuation">;</span>
<span class="token keyword">@end</span>

<span class="token keyword">@implementation</span> ClassB
－ <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>viewDidLoad <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">[</span><span class="token keyword">super</span> viewDidLoad<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">self</span><span class="token punctuation">.</span>classA <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>ClassA alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">self</span><span class="token punctuation">.</span>classA<span class="token punctuation">.</span>delegate <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>￼<br> <img src="https://images2.imgbox.com/97/6c/1sZZUSwT_o.png" alt="请添加图片描述"></p> 
<p>￼</p> 
<p><img src="https://images2.imgbox.com/16/a1/gCDtesoR_o.png" alt="请添加图片描述"></p> 
<p>设计模式总结<br> KVO/通知 -------&gt; 观察者模式</p> 
<blockquote> 
 <p>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。<br> 优势：解耦合<br> 接口隔离原则、开放-封闭原则</p> 
</blockquote> 
<p>KVC --------&gt; KVC模式<br> 单例模式</p> 
<blockquote> 
 <p>利用应用程序只有一个该类的实例对象这一特殊性来实现资源共享。<br> 优势：使用简单，延时求值，易于跨模块<br> 劣势：这块内存知道程序退出时才能释放<br> 单一职责原则<br> 举例：[UIApplication sharedApplication]。</p> 
</blockquote> 
<p>代理模式</p> 
<blockquote> 
 <p>委托方将不想完成的任务交给代理方处理，并且需要委托方通知代理方才能处理。<br> 优势： 解耦合<br> 开放-封闭原则<br> 举例：tableview的数据源和代理</p> 
</blockquote> 
<p>策略模式</p> 
<blockquote> 
 <p>策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。<br> 优势：使算法的变化独立于使用算法的用户<br> 接口隔离原则、多用组合，少用继承、针对接口编程，而非实现<br> 举例：账号密码输入格式的判断、NSArray的sortedArrayUsingSelector等等</p> 
</blockquote> 
<p>MVC模式</p> 
<blockquote> 
 <p>将程序书写分为三层，分别为模型、视图、控制器，每层都有各自的职责完成各自的工作。<br> 优势： MVC模式使系统，层次清晰，职责分明，易于维护<br> 对扩展开放-对修改封闭</p> 
</blockquote> 
<p>MVVM模式</p> 
<blockquote> 
 <p>用于解决MVC模式下C层代码冗杂的情况（过多的网络请求以及业务逻辑处理）而出现的MVVM模式，其相比于MVC多了一层ViweModel（业务处理和数据转化）层，专门用于处理数据。<br> 当功能简单时，MVVM反而会增加很多代码，所以对于简单的功能，MVC更加的方便。</p> 
</blockquote> 
<p>MVP模式</p> 
<blockquote> 
 <p>MVP是MVC模式派生出来的，常用于创建用户界面，在MVP中所有页面显示逻辑都会被推送到presenter（中间人）中，它主要实现程序逻辑控制、数据的检索，并格式化数据以便在视图中显示，把Model和View完全的进行分离，MVP模式的V是View + ViewController。</p> 
</blockquote> 
<p>三种工厂模式</p> 
<blockquote> 
 <p>通过给定参数来返回对应的实例，完全对用户隐藏其实现的原理。<br> 优势：易于替换，面向抽象编程<br> 依赖倒置原则</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/167dfe1fa3627f46e365eb7c6e749e9e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2024年高教社杯数学建模国赛C题超详细解题思路分析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3ba3e75f3196d4e6dc78848453a42b3c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【2024高教社杯全国大学生数学建模竞赛】B题 生产过程中的决策问题——解题思路 代码 论文</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>