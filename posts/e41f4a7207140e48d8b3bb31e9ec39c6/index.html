<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>FastAPI 库（Python 的 Web 框架）基本使用指南（一） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/e41f4a7207140e48d8b3bb31e9ec39c6/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="FastAPI 库（Python 的 Web 框架）基本使用指南（一）">
  <meta property="og:description" content="FastAPI 概述 参考文档：
中文文档轻松上手Python的Web神器：FastAPI教程 介绍 FastAPI 是一个基于 Python 的现代 Web 框架，它具有快速构建高性能 API 的特点。
FastAPI 关键特性:
快速：可与 NodeJS 和 Go 并肩的极高性能（归功于 Starlette 和 Pydantic）。最快的 Python web 框架之一。高效编码：提高功能开发速度约 200％ 至 300％。更少 bug：减少约 40％ 的人为（开发者）导致错误。智能：极佳的编辑器支持。处处皆可自动补全，减少调试时间。简单：设计的易于使用和学习，阅读文档的时间更短。简短：使代码重复最小化。通过不同的参数声明实现丰富功能。bug 更少。健壮：生产可用级别的代码。还有自动生成的交互式文档。标准化：基于（并完全兼容）API 的相关开放标准：OpenAPI (以前被称为 Swagger) 和 JSON Schema。 常见 Python Web 框架的介绍与区别 性能：
Django：是一个全功能的框架，它提供了许多内置的功能和扩展。虽然它在性能方面相对较低，但它非常适合构建大型应用程序。
Flask：是一个轻量级的框架，它更加注重简洁和灵活性。相比于 Django，Flask 具有更好的性能表现，但它的功能相对较少。
FastAPI：是一个高性能的框架，它基于异步请求处理和类型注解。FastAPI 比 Django 和 Flask 在性能上更为出色，并且它使用 Python 的 asyncio 库来实现高效的并发请求处理。
开发难度：
Django：是一个全功能的框架，它提供了许多现成的功能和组件，使得开发更加快速和简单。但是，对于初学者来说，Django的学习曲线可能相对较陡。Flask：是一个简洁而灵活的框架，它更多地侧重于自定义和配置。相对于 Django，Flask 的学习曲线较为平缓，适合小型和简单的项目。FastAPI：使用了类型注解和自动生成文档的功能，使代码更易读和维护。它提供了基于标准的API模式和强大的验证工具，减少了开发过程中的错误。 推广程度：
Django：是最受欢迎和广泛使用的 Python Web 框架之一。它拥有庞大的社区支持和丰富的文档资源，可以轻松找到相关的教程、插件和解决方案。
Flask：是一个比较受欢迎的框架，拥有庞大的社区和丰富的扩展库。虽然它的用户群体相对较小，但在小型项目和快速原型开发中非常流行。
FastAPI：是一个相对较新的框架，但它正在迅速获得开发者的关注。它的高性能和现代特性吸引了许多开发者，并且社区正在逐渐扩大。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-11-06T11:10:47+08:00">
    <meta property="article:modified_time" content="2023-11-06T11:10:47+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">FastAPI 库（Python 的 Web 框架）基本使用指南（一）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="FastAPI__0"></a>FastAPI 概述</h2> 
<p>参考文档：</p> 
<ul><li><a href="https://fastapi.tiangolo.com/zh/" rel="nofollow">中文文档</a></li><li><a href="https://zhuanlan.zhihu.com/p/624779536?utm_id=0" rel="nofollow">轻松上手Python的Web神器：FastAPI教程</a></li></ul> 
<h3><a id="_7"></a>介绍</h3> 
<p>FastAPI 是一个基于 Python 的现代 Web 框架，它具有快速构建高性能 API 的特点。</p> 
<p>FastAPI 关键特性:</p> 
<ul><li>快速：可与 NodeJS 和 Go 并肩的极高性能（归功于 Starlette 和 Pydantic）。最快的 Python web 框架之一。</li><li>高效编码：提高功能开发速度约 200％ 至 300％。</li><li>更少 bug：减少约 40％ 的人为（开发者）导致错误。</li><li>智能：极佳的编辑器支持。处处皆可自动补全，减少调试时间。</li><li>简单：设计的易于使用和学习，阅读文档的时间更短。</li><li>简短：使代码重复最小化。通过不同的参数声明实现丰富功能。bug 更少。</li><li>健壮：生产可用级别的代码。还有自动生成的交互式文档。</li><li>标准化：基于（并完全兼容）API 的相关开放标准：OpenAPI (以前被称为 Swagger) 和 JSON Schema。</li></ul> 
<br> 
<h3><a id="_Python_Web__24"></a>常见 Python Web 框架的介绍与区别</h3> 
<p><strong>性能：</strong></p> 
<ul><li> <p><strong>Django</strong>：是一个全功能的框架，它提供了许多内置的功能和扩展。虽然它在性能方面相对较低，但它非常适合构建大型应用程序。</p> </li><li> <p><strong>Flask</strong>：是一个轻量级的框架，它更加注重简洁和灵活性。相比于 Django，Flask 具有更好的性能表现，但它的功能相对较少。</p> </li><li> <p><strong>FastAPI</strong>：是一个高性能的框架，它基于异步请求处理和类型注解。FastAPI 比 Django 和 Flask 在性能上更为出色，并且它使用 Python 的 asyncio 库来实现高效的并发请求处理。</p> </li></ul> 
<p><strong>开发难度：</strong></p> 
<ul><li><strong>Django</strong>：是一个全功能的框架，它提供了许多现成的功能和组件，使得开发更加快速和简单。但是，对于初学者来说，Django的学习曲线可能相对较陡。</li><li><strong>Flask</strong>：是一个简洁而灵活的框架，它更多地侧重于自定义和配置。相对于 Django，Flask 的学习曲线较为平缓，适合小型和简单的项目。</li><li><strong>FastAPI</strong>：使用了类型注解和自动生成文档的功能，使代码更易读和维护。它提供了基于标准的API模式和强大的验证工具，减少了开发过程中的错误。</li></ul> 
<p><strong>推广程度：</strong></p> 
<ul><li> <p><strong>Django</strong>：是最受欢迎和广泛使用的 Python Web 框架之一。它拥有庞大的社区支持和丰富的文档资源，可以轻松找到相关的教程、插件和解决方案。</p> </li><li> <p><strong>Flask</strong>：是一个比较受欢迎的框架，拥有庞大的社区和丰富的扩展库。虽然它的用户群体相对较小，但在小型项目和快速原型开发中非常流行。</p> </li><li> <p><strong>FastAPI</strong>：是一个相对较新的框架，但它正在迅速获得开发者的关注。它的高性能和现代特性吸引了许多开发者，并且社区正在逐渐扩大。</p> <p>FastAPI 是一个用于构建 API 的现代、快速（高性能）的 web 框架，使用 Python 3.6+ 并基于标准的 Python 类型提示。</p> </li></ul> 
<br> 
<h3><a id="_53"></a>入门示例</h3> 
<ul><li> <p><strong>安装 FastAPI 和 uvicorn</strong></p> <p>FastAPI 使用 uvicorn 作为默认的 Web 服务。因此，需要在安装 FastAPI 和 uvicorn</p> <p>uvicorn 是一个轻量级的 ASGI（异步服务器网关接口）服务器</p> <pre><code>pip install fastapi
pip install uvicorn
</code></pre> </li><li> <p>示例代码</p> <pre><code class="prism language-python"><span class="token keyword">from</span> fastapi <span class="token keyword">import</span> FastAPI
<span class="token keyword">import</span> uvicorn

<span class="token comment"># 创建一个FastAPI应用程序实例</span>
app <span class="token operator">=</span> FastAPI<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment"># 定义路由（使用装饰器将函数绑定到特定的路径和HTTP方法）</span>
<span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>get</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span>
<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">root</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span><span class="token string">"message"</span><span class="token punctuation">:</span> <span class="token string">"Hello World"</span><span class="token punctuation">}</span>

<span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>get</span><span class="token punctuation">(</span><span class="token string">"/items/{item_id}"</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">read_item</span><span class="token punctuation">(</span>item_id<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> q<span class="token punctuation">:</span> <span class="token builtin">str</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span><span class="token string">"item_id"</span><span class="token punctuation">:</span> item_id<span class="token punctuation">,</span> <span class="token string">"q"</span><span class="token punctuation">:</span> q<span class="token punctuation">}</span>

<span class="token comment"># 启动程序时使用 uvicorn 允许 FastAPI 应用程序</span>
uvicorn<span class="token punctuation">.</span>run<span class="token punctuation">(</span>app<span class="token punctuation">)</span>
<span class="token comment"># 默认ip为127.0.0.1，默认端口为8000</span>
</code></pre> </li></ul> 
<br> 
<h3><a id="_web__90"></a>启动 web 服务</h3> 
<ul><li> <p><strong>方式1：uvicorn 内嵌式</strong></p> <p>在代码中使用 <code>uvicorn.run(app)</code> 启用 uvicorn 服务器运行 python 服务，然后使用 python 启动 py 模块</p> <pre><code class="prism language-python"><span class="token keyword">import</span> uvicorn

app <span class="token operator">=</span> FastAPI<span class="token punctuation">(</span><span class="token punctuation">)</span>
uvicorn<span class="token punctuation">.</span>run<span class="token punctuation">(</span>app<span class="token punctuation">)</span>
</code></pre> </li><li> <p><strong>方式2：uvicorn 外启式</strong></p> <p>在命令行输入命令：</p> <pre><code>uvicorn main:app --host 0.0.0.0 --port 80 --reload
</code></pre> 
  <ul><li>main：启动服务的py文件名</li><li>app：服务对象名</li><li>–-host：ip地址</li><li>–-port：端口</li><li>–-reload：代码修改后自动重启服务。仅在开发时使用，上线后不要带这个参数，会降低性能</li></ul> </li></ul> 
<br> 
<h3><a id="uvicornrun__119"></a>uvicorn.run 支持的参数</h3> 
<ul><li><strong>app</strong> ：指定应用 app。‘脚本名:FastAPI 实例对象’ 或 FastAPI 实例对象</li><li><strong>host</strong> ：字符串，允许被访问的形式：locahost、127.0.0.1、当前 IP、0.0.0.0。默认为127.0.0.1</li><li><strong>port</strong> ：数字，应用的端口，默认为 8000</li><li><strong>uds</strong> ：字符串，socket 服务绑定到 UNIX 的域名</li><li><strong>fd</strong> ：数字，从此文件描述符绑定到socket</li><li><strong>loop</strong> ：事件循环模式。选项列表为 [auto|asyncio|uvloop]，默认为 auto</li><li><strong>http</strong> ：HTTP协议实现。选项列表为 [auto|h11|httptools]，默认为auto</li><li><strong>ws</strong> ：WebSocket协议实现。选项列表为 [auto|none|websockets|wsproto]，默认为auto</li><li><strong>ws-max-size</strong> ：数字，WebSocket 最大消息大小（字节），默认值为 16777216</li><li><strong>lifespan</strong> ：生命周期实施。选项列表为 [auto|on|off]，默认为auto</li><li><strong>env-file</strong> ：PATH，环境配置文件</li><li><strong>log-config</strong> ：PATH，日志配置文件。支持的格式：<code>.ini</code>、<code>.json</code>、<code>.yaml</code>，默认为 fastapi 默认的 log 配置</li><li><strong>log-level</strong> ：日志级别。选项列表为 [critical|error|warning|info|debug|trace]，默认 info</li><li><strong>access-log</strong> ：boolean，access log 日志的开关，默认为 True</li><li><strong>use-colors</strong> ：boolean，彩色日志的开关（前提需指定log-config），默认为 None</li><li><strong>interface</strong> ：选择 ASGI3、ASGI2 或 WSGI 作为应用程序接口。选项列表为 [auto|asgi3|asgi2|wsgi]，默认为 auto</li><li><strong>debug</strong> ：是否使用 debug 模式，默认False,</li><li><strong>reload</strong> ：boolean，当代码发生更时，是否自动重启，默认 False,</li><li><strong>reload_dirs</strong> ：字符串，设置重新加载目录，当没有传这个参数的实时，将取当前工作目录</li><li><strong>reload-delay</strong> ：float，每隔多久检测代码是否有变动，默认 0.25 秒</li><li><strong>workers</strong> ：数字，工作进程数。默认为 <code>WEB_CONCURRENCY</code> 环境变量（如果可用） 或 1。对于 --reload 无效。</li><li><strong>proxy-headers</strong> ：boolean，启用/禁用 X-Forwarded-Proto、X-Forwarded-For、X-Forwarded-Port 以填充远程地址信息，默认为 True</li><li><strong>forwarded-allow-ips</strong> ：字符串，用逗号分隔的IP列表以信任代理标头。默认为 <code>FORWARDED_ALLOW_IPS</code> 环境变量（如果可用），或 None，为 None 时，代码里面则取 127.0.0.1</li><li><strong>root-path</strong> ：字符串，为安装在给定 URL 路径下的应用程序设置 ASGI “根路径”。</li><li><strong>limit-concurrency</strong> ：数字，在发出 HTTP503 响应之前，允许的最大并发连接数或任务数。默认为 None</li><li><strong>limit-max-requests</strong> ：数字，达到多少请求数则终止进程，默认为 None</li><li><strong>backlog</strong> ：数字，等待处理的最大连接数，默认为 2048</li><li><strong>timeout-keep-alive</strong> ：数字，如果在此超时时间内未收到新数据，则关闭保持活动状态的连接，默认为 5</li><li><strong>ssl-keyfile</strong> ：字符串，SSL密钥文件，默认为 None</li><li><strong>ssl-certfile</strong> ：字符串，SSL证书文件，默认为 None</li><li><strong>ssl-keyfile-password</strong> ：字符串，SSL密钥文件密码，默认为 None</li><li><strong>ssl-version</strong> ：数字，要使用的 SSL版本（详见 stdlib SS L模块），默认为 2</li><li><strong>ssl-cert-reqs</strong> ：数字，是否需要客户端证书（详见 stdlib SSL 模块），默认为 0</li><li><strong>ssl-ca-certs</strong> ：字符串，CA 证书文件</li><li><strong>ssl-ciphers</strong> ：字符串，要使用的 CA 证书文件密码（详见 stdlib SSL 模块），默认为 TLSv1</li><li><strong>header</strong> ：字典，自定义响应头信息，键值对的形式，默认为 None</li></ul> 
<br> 
<h2><a id="_API_160"></a>常用 API</h2> 
<h3><a id="appFastAPI__FastAPI__162"></a>app=FastAPI() ：创建 FastAPI 应用程序实例</h3> 
<ul><li> <p><code>app = FastAPI()</code> 是在 FastAPI 中创建应用程序实例的常见做法。这行代码创建了一个 FastAPI 应用程序对象，可以在这个对象上定义路由、中间件、异常处理等。</p> </li><li> <p>应用程序实例 <code>app</code> 具有许多属性和方法，用于配置和管理应用程序的各个方面，如路由、中间件、异常处理、依赖注入等。通过创建 <code>app</code> 实例，可以在其中定义和组织应用程序的逻辑。</p> </li><li> <p>代码示例</p> <pre><code class="prism language-python"><span class="token keyword">from</span> fastapi <span class="token keyword">import</span> FastAPI

app <span class="token operator">=</span> FastAPI<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> </li><li> <p><strong>支持参数（均为可选传）：</strong></p> 
  <ul><li> <p><strong>debug</strong> ：调试模式，True/False。此属性继承自 starlette，在 starlette 中使用的是 property 装饰器</p> </li><li> <p><strong>routes</strong> ：路由列表，默认值为 None</p> <p>此属性继承自 starlette，类型为 startlette 的 BaseRoute 列表，BaseRoute 与 starlette 的基础类型 Scope 有关</p> </li><li> <p><strong>title</strong> ：API文档的标题，默认值 FastAPI</p> </li><li> <p><strong>description</strong> ：API文档的描述，默认为空</p> </li><li> <p><strong>version</strong> ：API 接口的版本号</p> </li><li> <p><strong>openapi_url</strong> ：OpenAPI 文件路径，默认为 <code>/opanapi.json</code></p> </li><li> <p><strong>openapi_prefix</strong> ：OpenAPI 文件路径前缀，默认为空</p> </li><li> <p><strong>default_response_class</strong> ：默认响应类型，默认为 JSONResponse</p> <p>此参数继承自 startlette 的 Response，有 HTMLResponse、PlainTextResponse、UJSONResponse、RedirectResponse、StreamingResponse、FileResponse 和 JSONResponse 七种，使用时需加载 starlette.responses 模块</p> </li><li> <p><strong>docs_url</strong> ：交互式文档路径，默认为 <code>/docs</code></p> </li><li> <p><strong>redoc_url</strong> ：可选式文档路径，默认为 <code>/redoc</code></p> </li><li> <p><strong>swagger_ui_oauth2_redirect_url</strong> ：OAuth 重定向路径，默认为 <code>/docs/oauth2-redirect</code></p> </li><li> <p><strong>swagger_ui_init_oauth</strong> ：OAuth 重定向字典，默认为 None</p> </li><li> <p><strong>middleware</strong> ：中间件，默认为空</p> </li><li> <p><strong>exception_handlers</strong> ：异常处理方法，默认为 None</p> </li><li> <p><strong>on_startup</strong> ：app 启动时调用的方法列表</p> </li><li> <p><strong>on_shutdown</strong> ：app 关闭时调用的方法列表</p> </li><li> <p><strong>extra</strong> : 额外可选参数</p> </li></ul> </li></ul> 
<br> 
<h3><a id="FastAPI__API_218"></a>FastAPI() 实例常用 API</h3> 
<h4><a id="getpost__HTTP__220"></a>get()、post() 等：定义 HTTP 请求的路由</h4> 
<p>在 FastAPI 中，<code>app.get()</code> 、<code>app.post()</code>等方法用于定义 HTTP 请求的路由。这些方法接受多个参数，用于指定路由的路径、请求处理函数、依赖项等。</p> 
<p>以下是主要参数：</p> 
<ul><li><strong><code>path</code>（必填）</strong>：用于指定路由的路径。这是一个字符串，表示 URL 路径，可以包含路径参数和查询参数。</li><li><strong><code>response_model</code></strong>：用于指定响应模型。响应模型是响应数据的数据结构，通常使用 Pydantic 模型来定义。</li><li><strong><code>summary</code></strong>：一个简短的字符串，用于描述路由的目的或功能。</li><li><strong><code>description</code></strong>：用于提供更详细的路由说明。</li><li><strong><code>tags</code></strong>：一个字符串列表，用于标记路由，以便在文档中分类和组织路由。</li><li><strong><code>dependencies</code></strong>：一个列表，指定在路由处理函数中需要注入的依赖项。</li><li><strong><code>response_description</code></strong>：用于指定响应的描述信息。</li><li><strong><code>deprecated</code></strong>：一个布尔值，表示路由是否已被弃用。</li><li><strong><code>status_code</code></strong>：用于指定响应的 HTTP 状态码。</li><li><strong><code>response_model_include</code></strong> 和 <strong><code>response_model_exclude</code></strong>：用于指定在响应模型中包含或排除的字段。</li><li><strong><code>response_model_by_alias</code></strong>：一个布尔值，表示是否使用 Pydantic 模型中的别名来序列化响应。</li><li><strong><code>response_model_exclude_unset</code></strong>：一个布尔值，表示在响应中排除未设置的字段。</li><li><strong><code>response_model_exclude_defaults</code></strong>：一个布尔值，表示在响应中排除具有默认值的字段。</li><li><strong><code>response_model_exclude_none</code></strong>：一个布尔值，表示在响应中排除值为 None 的字段。</li><li><strong><code>operation_id</code></strong>：用于指定操作的唯一标识符。</li><li><strong><code>deprecated</code></strong>：一个布尔值，表示路由是否已被弃用。</li><li><strong><code>callbacks</code></strong>：一个字典，用于指定回调函数。</li></ul> 
<p>这些参数可以根据需求来灵活配置。一般来说，<code>path</code> 参数是必需的，而其他参数则根据需要来选择性地使用。</p> 
<br> 
<h4><a id="add_middleware_248"></a>add_middleware()：添加中间件</h4> 
<ul><li> <p><strong>add_middleware()</strong> 函数：是 FastAPI 中用于添加中间件的方法。</p> <p>中间件是一种可以在请求和响应处理过程中进行预处理和后处理的功能。可以使用中间件来实现各种需求，如添加全局头部、请求日志记录、异常处理等。</p> <p>通过 <code>app.add_middleware</code> 方法将自定义中间件添加到应用程序。当请求到达时，FastAPI 会依次执行添加的中间件，然后再调用路由处理函数。在响应返回时，会按照相反的顺序执行中间件的后处理逻辑。</p> <p>通过添加中间件，可以在请求和响应处理过程中实现一些通用的功能，而不需要在每个路由中重复编写相同的代码。这有助于保持代码的整洁和可维护性。</p> </li><li> <p>常用参数：</p> 
  <ul><li> <p><strong>middleware_class</strong>（必需）：一个中间件类，希望添加到应用程序的中间件。</p> <p>中间件类应继承自 fastapi.middleware.base.BaseHTTPMiddleware 或类似的基类。</p> </li><li> <p>**options：这是中间件的配置选项，可以根据中间件的要求传递不同的参数。具体的选项取决于使用的中间件类。通常，可以传递任何与中间件相关的自定义参数，以便在中间件类中使用。</p> </li></ul> </li></ul> 
<p><strong>CORSMiddleware 中间件</strong></p> 
<ul><li> <p>FastAPI 内置的中间件，用于处理跨源资源共享（CORS）问题。</p> <p>CORS 是一种浏览器安全机制，用于控制跨域请求。在前端和后端分离的应用中，当前端代码（在浏览器中运行）从一个域向另一个域发出请求时，浏览器会执行跨域检查，确保只有受信任的域可以访问资源。</p> <p>CORSMiddleware 可以帮助开发者配置 FastAPI 应用程序以正确处理跨域请求。</p> <p>配置完中间件后，FastAPI 会自动处理跨域请求，并在响应中添加适当的头部信息以满足 CORS 安全要求。</p> <p>请注意，CORS 配置涉及到应用程序的安全性。在生产环境中，应根据实际需求来配置 <code>allow_origins</code> 和其他参数。</p> </li><li> <p><strong>常用参数（用于配置跨域策略）：</strong></p> 
  <ul><li> <p><strong>allow_origins</strong>：允许访问资源的域名列表。</p> <p>可以使用 <code>["*"]</code> 表示允许所有域名，但这通常不是推荐的做法。</p> </li><li> <p><strong>allow_credentials</strong>：是否允许发送凭据（如 cookie、HTTP 认证头部）的请求。</p> <p>如果为 <code>True</code>，则需要确保在客户端和服务器端都进行相应的配置，且 <code>allow_origins</code> 必须为具体的源，不可以是 <code>["*"]</code></p> </li><li> <p><strong>allow_methods</strong>：允许的 HTTP 方法列表如 <code>["GET", "POST"]</code>。默认是 <code>["GET"]</code></p> <p>可以使用 <code>["*"]</code> 表示允许所有方法</p> </li><li> <p><strong>allow_headers</strong>：允许的 HTTP 头部列表，如 <code>["Content-Type", "Authorization"]</code>。默认是 <code>[]</code></p> <p>可以使用 <code>["*"]</code> 表示允许所有头部</p> <p>注：Accept、Accept-Language、Content-Language 以及 Content-Type 总是被允许的</p> </li></ul> </li><li> <p><strong>代码示例：</strong></p> <pre><code class="prism language-python"><span class="token keyword">from</span> fastapi <span class="token keyword">import</span> FastAPI
<span class="token keyword">from</span> fastapi<span class="token punctuation">.</span>middleware<span class="token punctuation">.</span>cors <span class="token keyword">import</span> CORSMiddleware

app <span class="token operator">=</span> FastAPI<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 添加 CORS 中间件</span>
app<span class="token punctuation">.</span>add_middleware<span class="token punctuation">(</span>
    CORSMiddleware<span class="token punctuation">,</span>
    allow_origins<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"http://localhost"</span><span class="token punctuation">,</span> <span class="token string">"https://example.com"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    allow_credentials<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>
    allow_methods<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"*"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    allow_headers<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"*"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span>
</code></pre> </li></ul> 
<br> 
<p><strong>自定义中间件：</strong></p> 
<ul><li> <p><strong>方式1：自定义中间件类，添加自定义中间件时通过 dispatch 参数传递自定义中间件类的对象</strong></p> <pre><code class="prism language-python"><span class="token keyword">from</span> fastapi <span class="token keyword">import</span> FastAPI<span class="token punctuation">,</span> Request
<span class="token keyword">from</span> fastapi<span class="token punctuation">.</span>middleware<span class="token punctuation">.</span>cors <span class="token keyword">import</span> BaseHTTPMiddleware

<span class="token comment"># 自定义中间件</span>
<span class="token keyword">class</span> <span class="token class-name">MyMiddleware</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> some_attribute<span class="token punctuation">:</span> <span class="token builtin">str</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># some_attribute非必需，此处用于演示传参到自定义的中间件</span>
        self<span class="token punctuation">.</span>some_attribute <span class="token operator">=</span> some_attribute

    <span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> request<span class="token punctuation">:</span> Request<span class="token punctuation">,</span> call_next<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># do something with the request object</span>
        <span class="token comment"># process the request and get the response    </span>
        response <span class="token operator">=</span> <span class="token keyword">await</span> call_next<span class="token punctuation">(</span>request<span class="token punctuation">)</span>
        <span class="token comment"># do something with the response object</span>
        <span class="token keyword">return</span> response

app <span class="token operator">=</span> FastAPI<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment"># 添加自定义中间件</span>
app<span class="token punctuation">.</span>add_middleware<span class="token punctuation">(</span>BaseHTTPMiddleware<span class="token punctuation">,</span> dispatch<span class="token operator">=</span>MyMiddleware<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> </li><li> <p><strong>方式2：自定义中间件类继承 BaseHTTPMiddleware 类</strong></p> <pre><code class="prism language-python"><span class="token comment"># 自定义中间件</span>
<span class="token keyword">class</span> <span class="token class-name">MyMiddleware</span><span class="token punctuation">(</span>BaseHTTPMiddleware<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> app<span class="token punctuation">,</span> some_attribute<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>app<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>some_attribute <span class="token operator">=</span> some_attribute

    <span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">dispatch</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> request<span class="token punctuation">:</span> Request<span class="token punctuation">,</span> call_next<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># do something with the request object, for example</span>
        content_type <span class="token operator">=</span> request<span class="token punctuation">.</span>headers<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>content_type<span class="token punctuation">)</span>
        
        <span class="token comment"># process the request and get the response    </span>
        response <span class="token operator">=</span> <span class="token keyword">await</span> call_next<span class="token punctuation">(</span>request<span class="token punctuation">)</span>
        
        <span class="token keyword">return</span> response

app <span class="token operator">=</span> FastAPI<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment"># 添加自定义中间件</span>
app<span class="token punctuation">.</span>add_middleware<span class="token punctuation">(</span>MyMiddleware<span class="token punctuation">)</span>
</code></pre> </li><li> <p><strong>方式3：@app.middleware 装饰器</strong></p> <p>在 FastAPI 中，可以使用 <code>@app.middleware</code> 装饰器来添加应用程序范围的中间件。</p> <p>即使用 <code>@app.middleware</code> 装饰器添加的中间件适用于整个 FastAPI 应用程序，通常用于执行全局操作，例如身份验证、日志记录、异常处理等。这使得您可以在整个应用程序中共享相同的中间件逻辑，而不需要为每个路由重复添加相同的中间件。</p> <p>此装饰器可以接受以下两个<strong>参数</strong>：</p> 
  <ul><li> <p><strong>middleware_type</strong>（必需）：字符串参数，用于指定中间件的类型。</p> <p>在 FastAPI 中，中间件可以分为以下两种类型：</p> 
    <ul><li> <p>“http”：HTTP 中间件</p> <p>这种中间件将在每个 HTTP 请求处理期间执行，适用于处理 HTTP 请求和响应的操作。</p> </li><li> <p>“websocket”：WebSocket 中间件</p> <p>这种中间件将在 WebSocket 连接的处理期间执行，适用于处理 WebSocket 请求和响应的操作。</p> </li></ul> </li><li> <p><strong>priority</strong>（可选）：整数参数，用于指定中间件的优先级。</p> <p>如果应用程序中有多个中间件，可以使用此参数来控制它们的执行顺序。</p> <p>较小的数字表示较高的优先级，中间件将按照优先级升序执行。</p> <p>如果不指定 priority 参数，中间件的默认优先级为 50。</p> </li></ul> <pre><code class="prism language-python">app <span class="token operator">=</span> FastAPI<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 自定义中间件处理函数</span>
<span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>middleware</span><span class="token punctuation">(</span><span class="token string">"http"</span><span class="token punctuation">)</span>
<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">log_requests</span><span class="token punctuation">(</span>request<span class="token punctuation">:</span> Request<span class="token punctuation">,</span> call_next<span class="token punctuation">)</span><span class="token punctuation">:</span>
    logger<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Incoming request: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>request<span class="token punctuation">.</span>method<span class="token punctuation">}</span></span><span class="token string"> </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>request<span class="token punctuation">.</span>url<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
    response <span class="token operator">=</span> <span class="token keyword">await</span> call_next<span class="token punctuation">(</span>request<span class="token punctuation">)</span>
    logger<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Outgoing response: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>response<span class="token punctuation">.</span>status_code<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> response
</code></pre> </li></ul> 
<br> 
<h4><a id="websocket_WebSocket__412"></a>websocket()：创建 WebSocket 路由</h4> 
<ul><li> <p><strong>websocket()</strong> 函数：创建 WebSocket 路由，从而实现与客户端之间的<strong>实时双向通信</strong>。</p> <p>WebSocket 是一种在单个长连接上进行全双工通信的协议，适用于需要实时更新数据的应用场景，例如聊天应用、实时数据展示等。</p> <p>在客户端，可以使用浏览器内置的 WebSocket API 或其他 WebSocket 客户端库来与 FastAPI WebSocket 路由进行通信。</p> </li><li> <p>代码示例：</p> <pre><code class="prism language-python"><span class="token keyword">from</span> fastapi <span class="token keyword">import</span> FastAPI<span class="token punctuation">,</span> WebSocket

app <span class="token operator">=</span> FastAPI<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># WebSocket 路由</span>
<span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>websocket</span><span class="token punctuation">(</span><span class="token string">"/ws"</span><span class="token punctuation">)</span>
<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">websocket_endpoint</span><span class="token punctuation">(</span>websocket<span class="token punctuation">:</span> WebSocket<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">await</span> websocket<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
        data <span class="token operator">=</span> <span class="token keyword">await</span> websocket<span class="token punctuation">.</span>receive_text<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">await</span> websocket<span class="token punctuation">.</span>send_text<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"You said: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>data<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
</code></pre> 
  <ul><li>使用 <code>app.websocket()</code> 方法创建了一个 <code>/ws</code> 的 WebSocket 路由。在 WebSocket 连接建立后，使用 <code>await websocket.accept()</code> 方法接受连接。</li><li>然后，在一个无限循环中使用 <code>await websocket.receive_text()</code> 方法接收客户端发送的文本消息，并使用 <code>await websocket.send_text()</code> 方法将消息返回给客户端。</li></ul> </li></ul> 
<br> 
<h4><a id="mount_441"></a>mount()：安装子应用程序（静态文件）</h4> 
<ul><li> <p><strong>mount()</strong> 函数：用于将另一个 ASGI 应用程序安装为 FastAPI 应用程序的子应用程序。</p> <p>使用 <code>mount</code> 安装子应用程序可以方便的将多个应用程序组合在一起，实现更复杂的应用程序逻辑结构。例如，将多个 API 应用程序组装成一个网关应用程序，将多个应用程序组装成一个单页面应用程序等等。</p> <p>支持参数：</p> 
  <ul><li><strong>path</strong> ：类型为字符串，必传参数，指定 url 访问的路径</li><li><strong>app</strong> ：类型为 ASGIApp，必传参数，挂载的是静态文件对象 
    <ul><li><strong>directory</strong> ：指定挂载的是静态文件目录</li></ul> </li><li><strong>name</strong> ：指定 fastapi 内部使用的名称。默认为 None</li></ul> </li><li> <p><strong>访问静态文件方式</strong>：直接在浏览器输入 <code>ip:端口/路径/文件全名.后缀</code> 即可</p> </li><li> <p>代码示例（配置静态文件路径）：</p> <pre><code class="prism language-python"><span class="token keyword">import</span> uvicorn
<span class="token keyword">from</span> fastapi <span class="token keyword">import</span> FastAPI
<span class="token keyword">from</span> fastapi<span class="token punctuation">.</span>staticfiles <span class="token keyword">import</span> StaticFiles

app <span class="token operator">=</span> FastAPI<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment"># 配置静态文件路径</span>
app<span class="token punctuation">.</span>mount<span class="token punctuation">(</span><span class="token string">"/static"</span><span class="token punctuation">,</span> StaticFiles<span class="token punctuation">(</span>directory<span class="token operator">=</span><span class="token string">"static"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">"static"</span><span class="token punctuation">)</span>
uvicorn<span class="token punctuation">.</span>run<span class="token punctuation">(</span>app<span class="token operator">=</span><span class="token string">"main:app"</span><span class="token punctuation">,</span> host<span class="token operator">=</span><span class="token string">"0.0.0.0"</span><span class="token punctuation">,</span> port<span class="token operator">=</span><span class="token number">8000</span><span class="token punctuation">,</span> <span class="token builtin">reload</span><span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
</code></pre> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/29cb2ecafa4009835748b6db4dc29631/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">AI大模型在短视频处理和剪辑中的应用，文末送书</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e0363397239065bcb92744e05d098e52/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java 数据结构篇-实现单链表核心API</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>