<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Zookeeper和Nacos的区别 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/28a5dc5dd43d314183ed96a130d2733b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Zookeeper和Nacos的区别">
  <meta property="og:description" content="1. ZooKeeper 是什么？ ZooKeeper 是一个开源的分布式协调服务。它是一个为分布式应用提供一致性服务的软件，分布式应用程序可以基于 Zookeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。
2. ZooKeeper 提供了什么 文件系统
通知机制
3. Zookeeper 怎么保证主从节点的状态同步？ Zookeeper 的核心是原子广播机制，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 Zab 协议。Zab 协议有两种模式，它们分别是恢复模式和广播模式。
恢复模式
当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。
广播模式
一旦 leader 已经和多数的 follower 进行了状态同步后，它就可以开始广播消息了，即进入广播状态。这时候当一个 server 加入 ZooKeeper 服务中，它会在恢复模式下启动，发现 leader，并和 leader 进行状态同步。待到同步结束，它也参与消息广播。ZooKeeper 服务一直维持在 Broadcast 状态，直到 leader 崩溃了或者 leader 失去了大部分的 followers 支持。
4. Zookeeper Watcher 机制 – 数据变更通知 工作机制：
（1）客户端注册 watcher
（2）服务端处理 watcher
（3）客户端回调 watcher
（1）一次性">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-02T10:55:11+08:00">
    <meta property="article:modified_time" content="2024-03-02T10:55:11+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Zookeeper和Nacos的区别</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4 style="background-color:transparent;"><strong>1. ZooKeeper 是什么？</strong></h4> 
<p>ZooKeeper 是一个开源的分布式协调服务。它是一个为分布式应用提供一致性服务的软件，分布式应用程序可以基于 Zookeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。</p> 
<h4><strong>2. ZooKeeper 提供了什么</strong></h4> 
<p>文件系统</p> 
<p>通知机制</p> 
<h4 style="background-color:transparent;"><strong>3. Zookeeper 怎么保证主从节点的状态同步？</strong></h4> 
<p>Zookeeper 的核心是原子广播机制，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 Zab 协议。Zab 协议有两种模式，它们分别是恢复模式和广播模式。</p> 
<p><strong>恢复模式</strong><br> 当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</p> 
<p><strong>广播模式</strong><br> 一旦 leader 已经和多数的 follower 进行了状态同步后，它就可以开始广播消息了，即进入广播状态。这时候当一个 server 加入 ZooKeeper 服务中，它会在恢复模式下启动，发现 leader，并和 leader 进行状态同步。待到同步结束，它也参与消息广播。ZooKeeper 服务一直维持在 Broadcast 状态，直到 leader 崩溃了或者 leader 失去了大部分的 followers 支持。</p> 
<h4><strong>4. Zookeeper Watcher 机制 – 数据变更通知</strong></h4> 
<p>工作机制：</p> 
<p>（1）客户端注册 watcher</p> 
<p>（2）服务端处理 watcher</p> 
<p>（3）客户端回调 watcher</p> 
<p>（1）一次性</p> 
<p>无论是服务端还是客户端，一旦一个 Watcher 被 触 发 ，Zookeeper 都会将其从相应的存储中移除。这样的设计有效的减轻了服务端的压力，不然对于更新非常频繁的节点，服务端会不断的向客户端发送事件通知，无论对于网络还是服务端的压力都非常大。</p> 
<p>（2）客户端串行执行</p> 
<p>客户端 Watcher 回调的过程是一个串行同步的过程。</p> 
<p>（3）轻量</p> 
<p>3.1、Watcher 通知非常简单，只会告诉客户端发生了事件，而不会说明事件的具体内容。</p> 
<p>3.1、Watcher 通知非常简单，只会告诉客户端发生了事件，而不会说明事件的具体内容。</p> 
<p>3.2、客户端向服务端注册 Watcher 的时候，并不会把客户端真实的 Watcher 对象实体传递到服务端，仅仅是在客户端请求中使用 boolean 类型属性进行了标记。</p> 
<p>（4）watcher event 异步发送 <strong>watcher 的通知事件从 server 发送到 client 是异步的</strong>，这就存在一个问题，不同的客户端和服务器之间通过 socket 进行通信，由于网络延迟或其他因素导致客户端在不通的时刻监听到事件，由于 Zookeeper 本身提供了 ordering guarantee，即客户端监听事件后，才会感知它所监视 znode发生了变化。所以我们使用 Zookeeper 不能期望能够监控到节点每次的变化。<strong>Zookeeper 只能保证最终的一致性</strong>，而无法保证强一致性。</p> 
<p>（5）注册 watcher getData、exists、getChildren</p> 
<p>（6）触发 watcher create、delete、setData</p> 
<p>（7）当一个客户端连接到一个新的服务器上时，watch 将会被以任意会话事件触发。当与一个服务器失去连接的时候，是无法接收到 watch 的。而当 client 重新连接时，如果需要的话，所有先前注册过的 watch，都会被重新注册。通常这是完全透明的。只有在一个特殊情况下，watch 可能会丢失：对于一个未创建的 znode的 exist watch，如果在客户端断开连接期间被创建了，并且随后在客户端连接上之前又删除了，这种情况下，这个 watch 事件可能会被丢失。</p> 
<p>Zookeeper 允许客户端向服务端的某个 Znode 注册一个 Watcher 监听，当服务端的一些指定事件触发了这个 Watcher，服务端会向指定客户端发送一个事件通知来实现分布式的通知功能，然后客户端根据 Watcher 通知状态和事件类型做出业务上的改变。</p> 
<h4><strong>5. Zookeeper 文件系统</strong></h4> 
<p>Zokeeper 提供一个多层级的节点命名空间（节点称为 znode）。与文件系统不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。</p> 
<p>Zookeeper 为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这种特性使得 Zookeeper 不能用于存放大量的数据，每个节点的存放数据上限为1M。</p> 
<p>Zookeeper和Nacos的区别<br> 在分布式系统中，注册中心充当着重要角色，是服务发现、客户端负载均衡中不可缺少的一员。注册中心除了能够实现基本的功能外，他的稳定性、可用性和健壮性对整个分布式系统的流畅运行影响重大。zookeeper和nacos可能是最常使用的方式。</p> 
<p>Zookeeper<br> Zookeeper 是 Apache Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高。<br> Zookeeper的功能主要是它的树形节点来实现的。当有数据变化的时候或者节点过期的时候，会通过<strong>事件触发通知</strong>对应的客户端数据变化了，然后客户端再请求zookeeper获取最新数据，采用push-pull来做数据更新。服务注册和消费信息直接存储在zk树形节点上，集群下采用过半机制保证服务节点间一致性。<br> **Zookeeper主要是用来协调服务的，不用来存储业务数据。**ZNode的数据大小最大是1M<br> **<strong>消息广播</strong>:**集群中zk在数据更新的时候，通过leader节点将将消息广播给其他follower节点，<strong>采用简单的两阶段提交模式，先request-&gt;ack-&gt;commit</strong>，当超过一半的follower节点响应可以提交就更新代码。<br> 崩溃恢复： 当leader不可用时，或者超半数follower投票得出leader不可用，那么会重新选举，这段期间zk服务是不可用的。通过最新的 xid来选举出新的leader，选举出来后需要将新的leader中的数据更新给超过半数的follower节点才能对外提供服务。<br><strong>zookeeper是个CP系统，强一致性。(集群leader挂了会重新选举，此时暂停对外服务)</strong>。Zookeeper是通过<strong>TCP的心跳</strong>判断服务是否可用。</p> 
<h4><strong>6. 客户端注册 Watcher 实现</strong></h4> 
<p>（1）调用 getData()/getChildren()/exist()三个 API，传入 Watcher 对象</p> 
<p>（2）标记请求 request，封装 Watcher 到 WatchRegistration</p> 
<p>（3）封装成 Packet 对象，发服务端发送 request</p> 
<p>（4）收到服务端响应后，将 Watcher 注册到 ZKWatcherManager 中进行管理</p> 
<p>（5）请求返回，完成注册。</p> 
<h4><strong>7. 服务端处理 Watcher 实现</strong></h4> 
<p>（1）服务端接收 Watcher 并存储</p> 
<p>接收到客户端请求，处理请求判断是否需要注册 Watcher，<strong>需要的话将数据节点的节点路径和 ServerCnxn（ServerCnxn 代表一个客户端和服务端的连接，实现了 Watcher 的 process 接口，此时可以看成一个 Watcher 对象</strong>）存储在WatcherManager 的 WatchTable 和 watch2Paths 中去。</p> 
<p>（2）Watcher 触发</p> 
<p>以服务端接收到 setData() 事务请求触发 NodeDataChanged 事件为例：</p> 
<p>2.1 封装 WatchedEvent</p> 
<p><strong>将通知状态（SyncConnected）、事件类型（NodeDataChanged）以及节点路径封</strong>装成一个 WatchedEvent 对象</p> 
<p>2.2 查询 Watcher</p> 
<p>从 WatchTable 中根据节点路径查找 Watcher</p> 
<p>2.3 没找到；说明没有客户端在该数据节点上注册过 Watcher</p> 
<p>2.4 找到；提取并从 WatchTable 和 Watch2Paths 中删除对应 Watcher（<strong>从这里可以看出 Watcher 在服务端是一次性的，触发一次就失效了</strong>）</p> 
<p>（3）调用 process 方法来触发 Watcher</p> 
<p>这里 process 主要就是通过 ServerCnxn <strong>对应的 TCP 连接发送 Watcher 事件通知</strong>。</p> 
<h4><strong>8. 客户端回调 Watcher</strong></h4> 
<p>客户端 SendThread 线程接收事件通知，交由 EventThread 线程回调 Watcher。</p> 
<p>客户端的 Watcher 机制同样是一次性的，一旦被触发后，该 Watcher 就失效了。</p> 
<h4><strong>9. 服务器角色</strong></h4> 
<p>Leader</p> 
<p>（1）事务请求的唯一调度和处理者，保证集群事务处理的顺序性</p> 
<p>（2）集群内部各服务的调度者</p> 
<p>Follower</p> 
<p>（1）处理客户端的非事务请求，转发事务请求给 Leader 服务器</p> 
<p>（2）参与事务请求 Proposal 的投票</p> 
<p>（3）参与 Leader 选举投票</p> 
<h4><strong>10. Zookeeper 下 Server 工作状态</strong></h4> 
<p>服务器具有四种状态，分别是 <strong>LOOKING、FOLLOWING、LEADING、OBSERVING</strong>。</p> 
<p>（1）LOOKING：寻 找 Leader 状态。当服务器处于该状态时，它会认为当前集群中没有 Leader，因此需要进入 Leader 选举状态。</p> 
<p>（2）FOLLOWING：跟随者状态。表明当前服务器角色是 Follower。</p> 
<p>（3）LEADING：领导者状态。表明当前服务器角色是 Leader。</p> 
<p>（4）OBSERVING：观察者状态。表明当前服务器角色是 Observer。</p> 
<h4><strong>11. 数据同步</strong></h4> 
<p>整个集群完成 Leader 选举之后，Learner（<strong>Follower 和 Observer 的统称</strong>）回向Leader 服务器进行注册。当 Learner 服务器想向Leader 服务器完成注册后，进入数据同步环节。</p> 
<p>数据同步流程：（均以消息传递的方式进行）</p> 
<p>Learner 向 Learder 注册</p> 
<p>数据同步</p> 
<p>同步确认</p> 
<p>Zookeeper 的数据同步通常分为四类：</p> 
<p>（1）直接差异化同步（DIFF 同步）</p> 
<p>（2）先回滚再差异化同步（TRUNC+DIFF 同步）</p> 
<p>（3）仅回滚同步（TRUNC 同步）</p> 
<p>（4）全量同步（SNAP 同步）</p> 
<p>在进行数据同步前，Leader 服务器会完成数据同步初始化</p> 
<p>peerLastZxid：</p> 
<p>·从 learner 服务器注册时发送的<strong> ACKEPOCH 消息中提取 lastZxid</strong>（该Learner 服务器最后处理的 ZXID）</p> 
<p>minCommittedLog：</p> 
<p>· Leader 服务器 Proposal 缓存队列 committedLog 中最小 ZXIDmaxCommittedLog：</p> 
<p>· Leader 服务器 Proposal 缓存队列 committedLog 中最大 ZXID直接差异化同步（DIFF 同步）</p> 
<p>· 场景：peerLastZxid 介于 minCommittedLog 和 maxCommittedLog之间先回滚再差异化同步（TRUNC+DIFF 同步）</p> 
<p>· 场景：当新的 Leader 服务器发现某个 Learner 服务器包含了一条自己没有的事务记录，<strong>那么就需要让该 Learner 服务器进行事务回滚–回滚到 Leader服务器上存在的，同时也是最接近于 peerLastZxid 的 ZXID仅回滚同步（TRUNC 同步）</strong></p> 
<p>· 场景：peerLastZxid 大于 maxCommittedLog</p> 
<p>全量同步（SNAP 同步）</p> 
<p>· 场景一：peerLastZxid 小于 minCommittedLog</p> 
<p>· 场景二：Leader 服务器上没有 Proposal 缓存队列且 peerLastZxid 不等于 lastProcessZxid</p> 
<h4><strong>12. zookeeper 是如何保证事务的顺序一致性的？</strong></h4> 
<p>zookeeper 采用了全局递增的事务 Id 来标识，<strong>所有的 proposal（提议）都在被提出的时候加上了 zxid，zxid 实际上是一个 64 位的数字，高 32 位是 epoch（ 时期; 纪元; 世; 新时代）用来标识 leader 周期，如果有新的 leader 产生出来，epoch会自增，低 32 位用来递增计数。当新产生 proposal 的时候，会依据数据库的两阶段过程，首先会向其他的 server 发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执</strong></p> 
<h4><strong>13. zk 节点宕机如何处理？</strong></h4> 
<p>Zookeeper 本身也是集群，推荐配置不少于 3 个服务器。Zookeeper 自身也要保证当一个节点宕机时，其他节点会继续提供服务。</p> 
<p>如果是一个 Follower 宕机，还有 2 台服务器提供访问，因为 Zookeeper 上的数据是有多个副本的，数据并不会丢失；</p> 
<p>如果是一个 Leader 宕机，Zookeeper 会选举出新的 Leader。</p> 
<p>ZK 集群的机制是只要超过半数的节点正常，集群就能正常提供服务。只有在 ZK节点挂得太多，只剩一半或不到一半节点能工作，集群才失效。</p> 
<p>所以</p> 
<p>3 个节点的 cluster 可以挂掉 1 个节点(leader 可以得到 2 票&gt;1.5)</p> 
<p>2 个节点的 cluster 就不能挂掉任何 1 个节点了(leader 可以得到 1 票&lt;=1)</p> 
<h4>14. ZAB 和 Paxos 算法的联系与区别？</h4> 
<p><strong>相同点：</strong></p> 
<p>（1）两者都存在一个类似于 Leader 进程的角色，由其负责协调多个 Follower 进程的运行</p> 
<p>（2）Leader 进程都会等待超过半数的 Follower 做出正确的反馈后，才会将一个提案进行提交</p> 
<p>（3）ZAB 协议中，每个 Proposal 中都包含一个 epoch 值来代表当前的 Leader周期，Paxos 中名字为 Ballot</p> 
<h4><strong> 15 不同点：</strong></h4> 
<p>ZAB 用来构建高可用的分布式数据主备系统（Zookeeper），Paxos 是用来构建分布式一致性状态机系统。</p> 
<p>Nacos<br> Nacos 是 Alibaba 公司推出的开源工具，用于实现分布式系统的服务发现与配置管理。Nacos 是 Dubbo 生态系统中重要的注册中心实现。<br> Nacos的配置中心和注册中心实现的是两套代码。Nacos依赖Mysql数据库做数据存储，当有数据更新的时候，直接更新数据库的数据，然后将数据更新的信息异步广播给Nacos集群中所有服务节点数据变更，在由Nacos服务节点更新本地缓存，然后将通知客户端节点数据变化。<br> Nacos支持两种方式的注册中心，持久化和非持久化存储服务信息。<br> 非持久直接存储在nacos服务节点的内存中，并且服务节点间采用去中心化的思想，服务节点采用hash分片存储注册信息。<br> 持久化使用Raft协议选举master节点，同样采用过半机制将数据存储在leader节点上。<br> Nacos保证了P，官方推荐使用A，即AP，保证其高可用。<br> AP模式下服务以临时实例注册，CP模式下服务以永久实例注册，Nacos集成了配置中心的功能。<br> Nacos同时实现CP以及AP两种数据的一致性策略，其实在一个组件中，同时实现两种数据一致性策略，这样在做服务注册中心选型时，就不必操心AP选什么组件，CP选什么组件，直接采用nacos就好了，同时满足你AP以及CP的数据一致性需求，即直接在一个组件中，享受Zookeeper以及Eureka组件的服务，避免了需要同时维护两种不同的组件的运维代价，只需要根据自己的实例需求，选择不同的注册模式即可。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e04ff762fbf4e93b0fb83970f65db3a6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Tomcat 的安装(详细教程)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ec03ba6a6a45312e1630ba5c20c0cc40/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python——Windows使用Nuitka2.0打包（保姆级教程）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>