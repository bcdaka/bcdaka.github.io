<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;中链表的底层迭代器实现 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/a7b67ec8e13b10ababfc7eca69777183/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C&#43;&#43;中链表的底层迭代器实现">
  <meta property="og:description" content="大家都知道在C&#43;&#43;的学习中迭代器是必不可少的，今天我们学习的是C&#43;&#43;中的链表的底层迭代器的实现，首先我们应该先知道链表的底层迭代器和顺序表的底层迭代器在实现上有什么区别，为什么顺序表的底层迭代器更加容易实现，而链表的底层迭代器不容易实现，接下来小编再来告诉大家如何来实现链表的底层迭代器，学完今天这篇我相信大家对C&#43;&#43;中的迭代器一定会有一个更加深刻的认识！大家先看今天学习的内容：
一、顺序表和链表的底层迭代器的区别
为了知道它们两个的区别，先得告诉大家顺序表的底层迭代器是如何实现的，首先大家先得明白顺序表私有成员都有什么，好方便大家来理解它们的底层迭代器是如何实现的，请看下图顺序表的私有成员变量：
private: iterator _start; iterator _finish; iterator _end_of_storage; 如图就是顺序表的私有成员变量 第一个 _start 是记录顺序表的起始位置的指针类型是 T*
_finish记录的是顺序表内末尾元素的下一个位置的指针类型是T*,_end_of_storage记录的是顺序表的目前的所有容量的下一个位置类型也是T*。
在明白了顺序表的私有成员变量的意义，并且顺序表的储存是连续的空间有点类似于数组的数据储存，所以大家也应该明白了顺序表的底层迭代器是如何实现的了吧，如果不懂请看下图操作及注释，如下图：
但是由于链表的物理结构不是连续的，所以想顺序表一样的底层迭代器实现方法是行不通的，这也是为什么在底层实现链表的迭代器中，不能通过给迭代器&#43;&#43;来做到迭代器指向下一个元素的地址，因为链表的数据在空间中分布式随意的。那该如何去设计链表的底层迭代器呢，请大家继续往下看。
二、链表的底层迭代器该如何实现
首先先请大家看一下链表中的数据是如何分布的，如下图：
如图，可见链表中的数据是随意分布的，但是我们仍然可以用前一个节点找到下一个节点，但为什么这样子不行，不算迭代器呢，因为在C&#43;&#43;中迭代器的定义就是通过 &#43;&#43; 来找到下一个元素，接通过 * 号来拿到他这个位置的数据，这才是迭代器的规定，如下段代码的遍历效果：
如上链表的分布图，虽然我们可以拿到下一个节点的位置和这个节点的数据，但我们不是通过 &#43;&#43; 和 * 来实现的，所以通过这样的方式做出的迭代器是不对的。那我们该如何实现呢，小编新学了一个方法，就是把迭代器底层封装成一个类，让它内部进项运算符重载来达到 &#43;&#43; 实现像迭代器一样遍历的过程，* 实现像迭代器一样拿出数据的过程，那么该如何实现呢，请大家继续往下看。
三、链表底层迭代器的实现
上面说到把迭代器封装成一个类，然后用运算符重载来达到 &#43;&#43; 和 * 的过程，把它彻底改变为一个正规的迭代器，现在大家就和我一起实现这个迭代器的类：
1、首先大家要明白链表(带头双向循环链表)的结构，如下代码：
template&lt;class T&gt; // 这里用结构体是因为ListNode中的每个成员都应该可以访问 没有私有成员 // 也可以使用友元来解决这个问题 struct ListNode { T _data; ListNode* _next; ListNode* _prev; ListNode(const T&amp; data = T()) :_next(nullptr) ,_prev(nullptr) , _data(data) {} }; template&lt;class T&gt; class list { public: typedef ListNode&lt;T&gt; Node; private: Node* _head; }; 如上图代码，在这里我们已经知道下一步需要把链表独特的遍历方式(用前一个指针找到后一个指针)用运算符重载的改为 &#43;&#43; 和 * 来实现遍历和拿到数据，保证它和迭代器的实现和用法一模一样。那该如何实现这个类呢。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-14T23:27:18+08:00">
    <meta property="article:modified_time" content="2024-07-14T23:27:18+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;中链表的底层迭代器实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>大家都知道在C++的学习中迭代器是必不可少的，今天我们学习的是C++中的链表的底层迭代器的实现，首先我们应该先知道链表的底层迭代器和顺序表的底层迭代器在实现上有什么区别，为什么顺序表的底层迭代器更加容易实现，而链表的底层迭代器不容易实现，接下来小编再来告诉大家如何来实现链表的底层迭代器，学完今天这篇我相信大家对C++中的迭代器一定会有一个更加深刻的认识！大家先看今天学习的内容：<img alt="" height="248" src="https://images2.imgbox.com/85/80/gTVcdjTc_o.png" width="450"></p> 
<p><strong>一、顺序表和链表的底层迭代器的区别</strong></p> 
<p>为了知道它们两个的区别，先得告诉大家顺序表的底层迭代器是如何实现的，首先大家先得明白顺序表私有成员都有什么，好方便大家来理解它们的底层迭代器是如何实现的，请看下图顺序表的私有成员变量：<img alt="" height="204" src="https://images2.imgbox.com/e4/15/O1C2Gr8n_o.png" width="494"></p> 
<pre><code class="hljs">	private:
		iterator _start;
		iterator _finish;
		iterator _end_of_storage;</code></pre> 
<p>如图就是顺序表的私有成员变量 第一个 <strong>_start </strong>是记录<strong>顺序表的起始位置的指针</strong>类型是 T*</p> 
<p><strong>_finish</strong>记录的是<strong>顺序表内末尾元素的下一个位置</strong>的指针类型是T*,<strong>_end_of_storage</strong>记录的是顺序表的目前的所有<strong>容量的下一个位置</strong>类型也是T*。</p> 
<p>在明白了顺序表的私有成员变量的意义，并且顺序表的储存是连续的空间有点类似于数组的数据储存，所以大家也应该明白了顺序表的底层迭代器是如何实现的了吧，如果不懂请看下图操作及注释，如下图：<img alt="" height="324" src="https://images2.imgbox.com/4c/c1/WOGITwOn_o.png" width="617"></p> 
<p>但是由于<strong>链表的物理结构不是连续</strong>的，所以想顺序表一样的底层迭代器实现方法是行不通的，这也是为什么在底层实现链表的迭代器中，不能通过<strong>给迭代器++</strong>来做到<strong>迭代器指向下一个元素</strong>的地址，因为链表的数据在空间中分布式随意的。那该如何去设计链表的底层迭代器呢，请大家继续往下看。</p> 
<p><strong>二、链表的底层迭代器该如何实现</strong></p> 
<p>首先先请大家看一下链表中的数据是如何分布的，如下图：<img alt="" height="251" src="https://images2.imgbox.com/cd/ef/G6fIwM5A_o.png" width="667"></p> 
<p>如图，可见链表中的数据是<strong>随意分布</strong>的，但是我们仍然可以用<strong>前一个节点找到下一个节点</strong>，但为什么这样子不行，不算迭代器呢，<strong>因为在C++中迭代器的定义就是通过 <span style="color:#fe2c24;">++</span> 来找到下一个元素，接通过 <span style="color:#fe2c24;">* </span>号来拿到他这个位置的数据</strong>，这才是迭代器的规定，如下段代码的遍历效果：</p> 
<p><img alt="" height="325" src="https://images2.imgbox.com/bc/2a/ZG7eO1Yg_o.png" width="445"></p> 
<p>如上链表的分布图，虽然我们可以拿到下一个节点的位置和这个节点的数据，但我们不是通过 <strong>++ 和 *</strong> 来实现的，所以通过这样的方式做出的迭代器是不对的。那我们该如何实现呢，小编新学了一个方法，就是把<span style="color:#fe2c24;"><strong>迭代器底层封装成一个类</strong></span>，让它<span style="color:#fe2c24;"><strong>内部进项运算符重载</strong></span>来达到 <span style="color:#fe2c24;"><strong>++ 实现像迭代器一样遍历的过程</strong></span>，<span style="color:#fe2c24;"><strong>* 实现像迭代器一样拿出数据</strong></span>的过程，那么该如何实现呢，请大家继续往下看。</p> 
<p><strong>三、链表底层迭代器的实现</strong></p> 
<p>上面说到把迭代器封装成一个类，然后用运算符重载来达到 <strong>++</strong> 和 <strong>*</strong> 的过程，把它彻底改变为一个正规的迭代器，现在大家就和我一起实现这个迭代器的类：</p> 
<p><strong>1、首先大家要明白链表(带头双向循环链表)的结构，如下代码：</strong></p> 
<pre><code class="hljs">template&lt;class T&gt;
// 这里用结构体是因为ListNode中的每个成员都应该可以访问 没有私有成员
// 也可以使用友元来解决这个问题
struct ListNode
{
	T _data;
	ListNode* _next;
	ListNode* _prev;

	ListNode(const T&amp; data = T())
		:_next(nullptr)
		,_prev(nullptr)
		, _data(data)
	{}
};</code></pre> 
<pre><code class="hljs">	template&lt;class T&gt;
	class list
	{
	public:
		typedef ListNode&lt;T&gt; Node;
	private:
		Node* _head;
	};</code></pre> 
<p>如上图代码，在这里我们已经知道下一步需要把<strong>链表独特的遍历</strong>方式(<strong>用前一个指针找到后一个指针</strong>)用<strong>运算符重载的</strong>改为 <strong>++ </strong> 和<strong> </strong><strong>*  </strong>来实现遍历和拿到数据，保证它和迭代器的实现和用法一模一样。那该如何实现这个类呢。</p> 
<p><strong>2、实现迭代器的类</strong></p> 
<p>我们需要定义一个迭代器的类，因为有普通迭代器和不可修改的迭代器，它们两个的函数大多数相同，为了减少代码量，我们加入两个模板参数来帮我们减轻代码量</p> 
<pre><code class="hljs">	// 这里加入 Ref 和 Ptr 是为了区分普通迭代器和const迭代器的区别
	// 本来要写两份迭代器，一份可修改，一份不可修改 现在直接交给编译器去做
	template&lt;class T , class Ref, class Ptr&gt;
	struct ListIterator
	{
		typedef ListNode&lt;T&gt; Node;
		typedef ListIterator&lt;T, Ref, Ptr&gt; Self;

		// 链表的迭代器应该是 Node* 类型的指针
		Node* _node;

		ListIterator(Node* node)
			:_node(node)
		{}
		// 前置++
		Self&amp; operator++()
		{
			_node = _node-&gt;_next;
			return *this;
		}
		//前置--
		Self&amp; operator--()
		{
			_node = _node-&gt;_prev;
			return *this;
		}
		Self operator++(int)
		{
			Self tem(*this);
			_node = _node-&gt;_next;
			return tem;
		}
		Self operator--(int)
		{
			Self tem(*this);
			_node = _node-&gt;_prev;
			return tem;
		}
		Ptr operator-&gt;()
		{
			return &amp;(_node-&gt;_data);
		}
		Ref operator*()
		{
			return _node-&gt;_data;
		}
		bool operator!=(const Self&amp; it)
		{
			return _node != it._node;
		}

		bool operator==(const Self&amp; it)
		{
			return _node == it._node;
		}
	};</code></pre> 
<p>以上就是今天的所有内容，希望大家会喜欢！！！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8a957c8a951867e31680f8e5c1ca7188/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据结构之通过“ 队列 ”实现的“ 栈 ”功能。</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d76c18a3bca9af1d3f54e685c8f11f8f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">记录些Spring&#43;题集（1）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>