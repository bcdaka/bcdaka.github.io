<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>《数据结构》：中缀表达式转后缀表达式 &#43; 后缀表达式的计算 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/610b511f420a3f098cdc92a347930a2a/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="《数据结构》：中缀表达式转后缀表达式 &#43; 后缀表达式的计算">
  <meta property="og:description" content="补充了一个判断输入中缀表达式合法性的代码： 《数据结构》：中缀表达式合法性判断_Amentos的博客-CSDN博客
目录
一、基本概念
二、中缀表达式转后缀表达式
例 中缀表达式 2*(3&#43;5)&#43;7/1-4 转换为后缀表达式
三、后缀表达式的计算
例 后缀表达式 2 3 5 &#43; * 7 1 / &#43; 4 - 的计算
四、算法实现
五、算法改进
一、基本概念 1、中缀表达式：
操作符以中缀形式位于运算数中间（如：3&#43;2），是我们日常通用的算术和逻辑公式表示方法。
2、后缀表达式：
又称逆波兰式（Reverse Polish Notation - RPN），操作符以后缀形式位于两个运算数后（如：3&#43;2的后缀表达形式就是3 2 &#43;）。
3、前缀表达式：
又称波兰式（Polish Notation），操作符以前缀形式位于两个运算数前（如：3&#43;2的前缀表达形式就是&#43; 3 2）。
中缀表达式往往需要使用括号将操作符和对应的操作数括起来，用于指示运算的次序
e.g：5*(2&#43;1) 虽然 * 的优先级高于 &#43; ，但括号的存在表示应优先执行括号内的 &#43; 运算。
中缀表达式适合于人类的思维结构和运算习惯，但并不适用于计算机
尤其是包含括号的中缀表达式，对计算机而言是非常复杂的结构。
适用于计算机的后缀表达式
与中缀表达式不同，后缀表达式不需要使用括号来标识操作符的优先级。
后缀表达式的计算按 操作符 从左到右出现的顺序依次执行(不考虑运算符之间的优先级)，对于计算机而言是比较简单的结构。
二、中缀表达式转后缀表达式 从左至右依次遍历中缀表达式各个字符（需要准备一个字符栈存储操作符和括号）
1、字符为 运算数 ：
直接送入后缀表达式（注：需要先分析出完整的运算数）。
2、字符为 左括号 ：
直接入栈（注：左括号入栈后优先级降至最低）。
3、字符为 右括号 ：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-05-23T21:00:58+08:00">
    <meta property="article:modified_time" content="2023-05-23T21:00:58+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">《数据结构》：中缀表达式转后缀表达式 &#43; 后缀表达式的计算</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<ul><li>补充了一个判断输入中缀表达式<strong>合法性</strong>的代码：</li></ul> 
<p><a href="https://blog.csdn.net/Amentos/article/details/129171785" title="《数据结构》：中缀表达式合法性判断_Amentos的博客-CSDN博客">《数据结构》：中缀表达式合法性判断_Amentos的博客-CSDN博客</a></p> 
<p> </p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">一、基本概念</a></p> 
<p id="%E4%BA%8C%E3%80%81%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F" rel="nofollow">二、中缀表达式转后缀表达式</a></p> 
<p id="%C2%A0%20%C2%A0%E4%BE%8B%C2%A0%C2%A0%C2%A0%C2%A0%20%C2%A0%C2%A0%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%C2%A0%202*(3%2B5)%2B7%2F1-4%C2%A0%20%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%E4%BE%8B%C2%A0%C2%A0%C2%A0%C2%A0%20%C2%A0%C2%A0%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%C2%A0%202*%283%2B5%29%2B7%2F1-4%C2%A0%20%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F" rel="nofollow">   例       中缀表达式  2*(3+5)+7/1-4  转换为后缀表达式</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97" rel="nofollow">三、后缀表达式的计算</a></p> 
<p id="%C2%A0%20%C2%A0%E4%BE%8B%C2%A0%C2%A0%C2%A0%C2%A0%20%C2%A0%20%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%C2%A0%202%203%205%20%2B%20*%207%201%20%2F%20%2B%204%20-%C2%A0%C2%A0%E7%9A%84%E8%AE%A1%E7%AE%97-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%E4%BE%8B%C2%A0%C2%A0%C2%A0%C2%A0%20%C2%A0%20%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%C2%A0%202%203%205%20%2B%20*%207%201%20%2F%20%2B%204%20-%C2%A0%C2%A0%E7%9A%84%E8%AE%A1%E7%AE%97" rel="nofollow">   例       后缀表达式  2 3 5 + * 7 1 / + 4 -  的计算</a></p> 
<p id="%E5%9B%9B%E3%80%81%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0" rel="nofollow">四、算法实现</a></p> 
<p id="%E4%BA%94%E3%80%81%E7%AE%97%E6%B3%95%E6%94%B9%E8%BF%9B-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E7%AE%97%E6%B3%95%E6%94%B9%E8%BF%9B" rel="nofollow">五、算法改进</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><strong>一、基本概念</strong></h2> 
<p><span style="color:#ed7976;"><strong>1、中缀表达式：</strong></span></p> 
<p>        操作符以中缀形式位于运算数中间（如：3+2），是我们日常通用的算术和逻辑公式表示方法。</p> 
<p><span style="color:#ed7976;"><strong>2、后缀表达式：</strong></span></p> 
<p>        又称<strong>逆波兰式</strong>（<em>Reverse Polish Notation - RPN</em>），操作符以后缀形式位于两个运算数后（如：3+2的后缀表达形式就是3 2 +）。</p> 
<p><span style="color:#ed7976;"><strong>3、前缀表达式：</strong></span></p> 
<p>        又称<strong>波兰式</strong>（<em>Polish Notation</em>），操作符以前缀形式位于两个运算数前（如：3+2的前缀表达形式就是+ 3 2）。</p> 
<p></p> 
<p></p> 
<p><strong>中缀表达式往往需要使用括号将操作符和对应的操作数括起来，用于指示运算的次序</strong></p> 
<p>e.g：5*(2+1) 虽然<span style="background-color:#fef2f0;"> <strong><span style="color:#ed7976;">*</span></strong> </span>的优先级高于<span style="background-color:#fef2f0;"> <span style="color:#ed7976;">+</span><strong><span style="color:#ed7976;"> </span></strong></span> ，但括号的存在表示应优先执行括号内的<span style="color:#ed7976;"><span style="background-color:#fef2f0;"> + </span></span>运算。</p> 
<p><strong>中缀表达式适合于人类的思维结构和运算习惯，但并不适用于计算机</strong></p> 
<p>尤其是包含括号的中缀表达式，对计算机而言是非常复杂的结构。</p> 
<p><strong>适用于计算机的<span style="color:#ed7976;">后缀表达式</span></strong></p> 
<p>与中缀表达式不同，后缀表达式<span style="color:#ed7976;">不需要使用括号</span>来标识操作符的优先级。</p> 
<p>后缀表达式的计算按<span style="background-color:#fef2f0;"> </span><strong><span style="color:#ed7976;"><span style="background-color:#fef2f0;">操作符 </span></span></strong>从左到右出现的顺序<strong><span style="color:#ed7976;">依次执行</span></strong>(不考虑运算符之间的优先级)，对于计算机而言是比较简单的结构。</p> 
<p></p> 
<p></p> 
<h2 id="%E4%BA%8C%E3%80%81%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F">二、中缀表达式转后缀表达式</h2> 
<p><strong>从左至右依次遍历中缀表达式各个字符（需要准备一个字符栈存储操作符和括号）</strong></p> 
<p>1、字符为<span style="background-color:#fef2f0;"> </span><span style="color:#ed7976;"><span style="background-color:#fef2f0;"><strong>运算数</strong> </span></span>：</p> 
<p>直接送入后缀表达式（<span style="color:#ed7976;">注：</span><span style="color:#494949;">需要先分析出完整的运算数</span>）。</p> 
<p>2、字符为<span style="color:#ed7976;"><strong><span style="background-color:#fef2f0;"> 左括号 </span></strong></span>：</p> 
<p>直接入栈（<span style="color:#ed7976;">注：</span><span style="color:#494949;">左括号入栈后优先级降至最低</span>）。</p> 
<p>3、字符为<span style="color:#fef2f0;"><strong><span style="background-color:#fef2f0;"> </span></strong></span><span style="color:#ed7976;"><strong><span style="background-color:#fef2f0;">右括号</span></strong></span><span style="color:#fef2f0;"><strong><span style="background-color:#fef2f0;"> </span></strong></span>：</p> 
<p>直接出栈，并将出栈字符依次送入后缀表达式，直到栈顶字符为左括号（左括号也要出栈，但不送入后缀表达式）。</p> 
<p><strong>总结：只要满足<span style="color:#ed7976;"> 栈顶为左括号 </span>即可进行最后一次出栈。</strong></p> 
<p>4、字符为<span style="color:#ed7976;"><strong><span style="background-color:#fef2f0;"> 操作符 </span></strong></span>：</p> 
<p>若栈空，直接入栈。</p> 
<p>若栈非空，判断栈顶操作符，若栈顶操作符优先级<span style="color:#ed7976;"><strong>低于</strong></span>该操作符，该操作符入栈；否则一直出栈，并将出栈字符依次送入后缀表达式，直到栈空或栈顶操作符优先级低于该操作符，该操作符再入栈。</p> 
<p><strong>总结：只要满足 <span style="color:#ed7976;">栈空</span><span style="color:#494949;"> 或者 </span><span style="color:#ed7976;">优先级高于栈顶操作符</span> 即可停止出栈，并将该操作符入栈。</strong></p> 
<p>5、重复以上步骤直至遍历完成中缀表达式，接着判断字符栈是否为空，非空则直接出栈，并将出栈字符依次送入后缀表达式。</p> 
<p><span style="color:#ed7976;">注：</span>中缀表达式遍历完成，栈中可能还有字符未输出，故需要判断栈空。</p> 
<p></p> 
<p></p> 
<h3 id="%C2%A0%20%C2%A0%E4%BE%8B%C2%A0%C2%A0%C2%A0%C2%A0%20%C2%A0%C2%A0%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%C2%A0%202*(3%2B5)%2B7%2F1-4%C2%A0%20%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><strong><span style="color:#e6b223;"><span style="background-color:#e7fafa;">   </span></span><span style="color:#ff9900;"><span style="background-color:#e7fafa;">例</span></span><span style="color:#e6b223;"><span style="background-color:#e7fafa;">   </span></span>    中缀表达式<span style="color:#ed7976;"><span style="background-color:#e7fafa;">  </span></span><span style="color:#ff9900;"><span style="background-color:#e7fafa;">2*(3+5)+7/1-4</span></span><span style="color:#ed7976;"><span style="background-color:#e7fafa;">  </span></span>转换为后缀表达式</strong></h3> 
<p><strong>从左至右依次遍历中缀表达式各个字符：</strong></p> 
<p>第一个字符为<strong>运算数</strong>，直接输出：</p> 
<p><img alt="" height="357" src="https://images2.imgbox.com/58/f0/mjuiOEkQ_o.png" width="811"></p> 
<hr> 
<p>第二个字符为<strong>操作符</strong>，满足 <span style="color:#ed7976;"><strong>栈空</strong></span>/优先级高于<span style="color:#494949;">栈顶操作符</span><strong><span style="color:#ed7976;"> </span></strong>条件，该操作符入栈：</p> 
<p><img alt="" height="356" src="https://images2.imgbox.com/fe/44/2gado6Wn_o.png" width="810"></p> 
<hr> 
<p>第三个字符为<strong>左括号</strong>，直接入栈（<span style="color:#494949;">入栈后优先级降至最低</span>）：</p> 
<p><img alt="" height="356" src="https://images2.imgbox.com/09/47/V1PYadEk_o.png" width="811"></p> 
<hr> 
<p>第四个字符为<strong>运算数</strong>，直接输出：</p> 
<p><img alt="" height="356" src="https://images2.imgbox.com/59/b0/7SNXaiF4_o.png" width="810"></p> 
<hr> 
<p>第五个字符为<strong>操作符</strong>，满足 <span style="color:#494949;">栈空</span>/<strong><span style="color:#ed7976;">优先级高于栈顶操作符 </span></strong>条件，该操作符入栈：</p> 
<p><img alt="" height="356" src="https://images2.imgbox.com/d8/28/Ug16zkwe_o.png" width="812"></p> 
<hr> 
<p>第六个字符为<strong>运算数</strong>，直接输出：</p> 
<p><img alt="" height="357" src="https://images2.imgbox.com/5d/37/eWxVKqus_o.png" width="810"></p> 
<hr> 
<p>第七个字符为<strong>右括号</strong>，直接出栈并输出，直到栈顶为左括号时进行最后一次出栈(不输出)：</p> 
<p><img alt="" height="389" src="https://images2.imgbox.com/c5/de/vqACEA0b_o.png" width="899"></p> 
<hr> 
<p><img alt="" height="346" src="https://images2.imgbox.com/7f/8a/hCb5Rci4_o.png" width="787"></p> 
<hr> 
<p>第八个字符为<strong>操作符</strong>，不满足 <span style="color:#494949;">栈空/优先级高于栈顶操作符 </span>条件，出栈直至满足条件</p> 
<p><img alt="" height="356" src="https://images2.imgbox.com/32/87/RxPPCJ8M_o.png" width="812"></p> 
<hr> 
<p><img alt="" height="344" src="https://images2.imgbox.com/e7/a6/4UFGhWFY_o.png" width="789"></p> 
<hr> 
<p>第九个字符为<strong>运算数</strong>，直接输出：</p> 
<p><img alt="" height="354" src="https://images2.imgbox.com/0a/2b/A1e5cF7e_o.png" width="812"></p> 
<hr> 
<p>第十个字符为<strong>操作符</strong>，满足 <span style="color:#494949;">栈空</span>/<strong><span style="color:#ed7976;">优先级高于栈顶操作符 </span></strong>条件，该操作符入栈：</p> 
<p><img alt="" height="355" src="https://images2.imgbox.com/b0/bd/g7j9gDfu_o.png" width="810"></p> 
<hr> 
<p>第十一个字符为<strong>运算数</strong>，直接输出：</p> 
<p><img alt="" height="356" src="https://images2.imgbox.com/8f/c0/eQtHm0cb_o.png" width="810"></p> 
<hr> 
<p>第十二个字符为<strong>操作符</strong>，不满足 <span style="color:#494949;">栈空/优先级高于栈顶操作符 </span>条件，出栈直至满足条件：</p> 
<p><img alt="" height="354" src="https://images2.imgbox.com/68/d2/BocJrsyT_o.png" width="811"></p> 
<hr> 
<p><img alt="" height="346" src="https://images2.imgbox.com/2b/d2/U4Hy85ZS_o.png" width="790"></p> 
<hr> 
<p><img alt="" height="346" src="https://images2.imgbox.com/4f/1a/O8HTWh4r_o.png" width="788"></p> 
<hr> 
<p>第十三个字符为<strong>运算数</strong>，直接输出：</p> 
<p><img alt="" height="458" src="https://images2.imgbox.com/fe/b3/cYXkiEHg_o.png" width="1050"></p> 
<hr> 
<p>中缀表达式<strong>遍历完成</strong>，<strong>判断字符栈中是否还有操作符</strong>，如有则出栈并输出：</p> 
<p><img alt="" height="355" src="https://images2.imgbox.com/86/c7/xLuEEs1D_o.png" width="810"></p> 
<hr> 
<p><strong>转换完成：</strong></p> 
<p><img alt="" height="355" src="https://images2.imgbox.com/86/0e/MsNmtRwK_o.png" width="810"></p> 
<p></p> 
<p></p> 
<h2 id="%E4%B8%89%E3%80%81%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97"><strong>三、后缀表达式的计算</strong></h2> 
<p><strong>从左至右依次遍历后缀表达式各个字符（需要准备一个运算数栈存储运算数和操作结果）</strong></p> 
<p>1、字符为<span style="color:#ed7976;"><strong><span style="background-color:#fef2f0;"> 运算数 </span></strong></span>：</p> 
<p>直接入栈（<span style="color:#ed7976;">注：</span>需要先分析出完整的运算数并将其转换为对应的数据类型）</p> 
<p>2、字符为<span style="color:#ed7976;"><strong><span style="background-color:#fef2f0;"> 操作符 </span></strong></span>：</p> 
<p>连续出栈两次，使用出栈的两个数据进行相应计算，并将计算结果入栈</p> 
<p>e.g：第一个出栈的运算数为<span style="color:#ed7976;"><span style="background-color:#fef2f0;"> a </span></span>，第二个出栈的运算数为<span style="color:#ed7976;"><span style="background-color:#fef2f0;"> b </span></span>，此时的操作符为<span style="color:#ed7976;"><span style="background-color:#fef2f0;"> - </span></span>，则计算<span style="background-color:#fef2f0;"> </span><span style="color:#ed7976;"><strong><span style="background-color:#fef2f0;">b-a </span></strong></span> （<span style="color:#ed7976;">注：</span>a和b顺序不能反），并将结果入栈。</p> 
<p>3、重复以上步骤直至遍历完成后缀表达式，最后栈中的数据就是中缀表达式的计算结果。</p> 
<p></p> 
<p></p> 
<h3 id="%C2%A0%20%C2%A0%E4%BE%8B%C2%A0%C2%A0%C2%A0%C2%A0%20%C2%A0%20%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%C2%A0%202%203%205%20%2B%20*%207%201%20%2F%20%2B%204%20-%C2%A0%C2%A0%E7%9A%84%E8%AE%A1%E7%AE%97"><span style="color:#e6b223;"><span style="background-color:#e7fafa;">   </span></span><strong><span style="color:#ff9900;"><span style="background-color:#e7fafa;">例</span></span></strong><span style="color:#e6b223;"><span style="background-color:#e7fafa;">   </span></span>    后缀表达式<span style="color:#ed7976;"><span style="background-color:#e7fafa;">  </span></span><span style="color:#ff9900;"><span style="background-color:#e7fafa;"><strong>2 3 5 + * 7 1 / + 4 -</strong> </span></span><span style="color:#ed7976;"><span style="background-color:#e7fafa;"> </span></span>的计算</h3> 
<p><strong>从左至右依次遍历后缀表达式各个字符：</strong></p> 
<p>第一个字符为<strong>运算数</strong>，直接入栈：</p> 
<p><img alt="" height="354" src="https://images2.imgbox.com/6b/c1/vo8Td7WW_o.png" width="810"></p> 
<hr> 
<p>第二个字符为<strong>运算数</strong>，直接入栈：</p> 
<p><img alt="" height="358" src="https://images2.imgbox.com/5e/ec/LVU4pEak_o.png" width="810"></p> 
<hr> 
<p>第三个字符为<strong>运算数</strong>，直接入栈：</p> 
<p><img alt="" height="355" src="https://images2.imgbox.com/4d/0c/Z1oETZBW_o.png" width="807"></p> 
<hr> 
<p>第四个字符为<strong>操作符</strong>，直接出栈两次：</p> 
<p><img alt="" height="354" src="https://images2.imgbox.com/e2/34/rEB7bCP2_o.png" width="810"></p> 
<p></p> 
<hr> 
<p>继续出栈：</p> 
<p><img alt="" height="355" src="https://images2.imgbox.com/2e/2f/ZGRWPELG_o.png" width="808"></p> 
<hr> 
<p><strong>执行：<span style="background-color:#fef2f0;"> </span><span style="color:#ed7976;"><span style="background-color:#fef2f0;">第二次出栈运算数 </span></span>  <span style="color:#4da8ee;"><span style="background-color:#eaf4fc;"> 操作符 </span></span>  <span style="color:#ed7976;"><span style="background-color:#fef2f0;"> 第一次出栈运算数 </span></span></strong></p> 
<p><span style="color:#494949;">即：<strong>3 + 5</strong></span></p> 
<p><span style="color:#494949;">结果：<strong>8</strong></span></p> 
<p><strong><span style="color:#494949;">将计算结果入栈：</span></strong></p> 
<p><img alt="" height="357" src="https://images2.imgbox.com/62/ad/eyclqRHY_o.png" width="813"></p> 
<p></p> 
<hr> 
<p>第五个字符为<strong>操作符</strong>，直接出栈两次：<img alt="" height="356" src="https://images2.imgbox.com/21/8c/KQ2Bq8HN_o.png" width="810"></p> 
<hr> 
<p><strong>执行：<span style="background-color:#fef2f0;"> </span><span style="color:#ed7976;"><span style="background-color:#fef2f0;">第二次出栈运算数 </span></span>  <span style="color:#4da8ee;"><span style="background-color:#eaf4fc;"> 操作符 </span></span>  <span style="color:#ed7976;"><span style="background-color:#fef2f0;"> 第一次出栈运算数 </span></span></strong></p> 
<p><span style="color:#494949;">即：<strong>2 * 8</strong></span></p> 
<p><span style="color:#494949;">结果：<strong>16</strong></span></p> 
<p><strong><span style="color:#494949;">将计算结果入栈：</span></strong></p> 
<p><img alt="" height="356" src="https://images2.imgbox.com/c8/eb/Izefy7PZ_o.png" width="812"></p> 
<hr> 
<p>第六个字符为<strong>运算数</strong>，直接入栈：</p> 
<p><img alt="" height="356" src="https://images2.imgbox.com/08/33/Sfn51fo9_o.png" width="811"></p> 
<hr> 
<p>第七个字符为<strong>运算数</strong>，直接入栈：</p> 
<p><img alt="" height="356" src="https://images2.imgbox.com/49/b9/U40HYVJD_o.png" width="808"></p> 
<hr> 
<p>第八个字符为<strong>操作符</strong>，直接出栈两次：</p> 
<p><img alt="" height="341" src="https://images2.imgbox.com/c0/4a/CG78u1c5_o.png" width="787"></p> 
<hr> 
<p><strong>执行：<span style="background-color:#fef2f0;"> </span><span style="color:#ed7976;"><span style="background-color:#fef2f0;">第二次出栈运算数 </span></span>  <span style="color:#4da8ee;"><span style="background-color:#eaf4fc;"> 操作符 </span></span>  <span style="color:#ed7976;"><span style="background-color:#fef2f0;"> 第一次出栈运算数 </span></span></strong></p> 
<p><span style="color:#494949;">即：<strong>7 / 1</strong></span></p> 
<p><span style="color:#494949;">结果：<strong>7</strong></span></p> 
<p><strong><span style="color:#494949;">将计算结果入栈：</span></strong></p> 
<p><img alt="" height="355" src="https://images2.imgbox.com/f3/00/PkKIEigc_o.png" width="809"></p> 
<hr> 
<p>第九个字符为<strong>操作符</strong>，直接出栈两次：</p> 
<p><img alt="" height="357" src="https://images2.imgbox.com/4b/a6/7nobGzqO_o.png" width="810"></p> 
<hr> 
<p><strong>执行：<span style="background-color:#fef2f0;"> </span><span style="color:#ed7976;"><span style="background-color:#fef2f0;">第二次出栈运算数 </span></span>  <span style="color:#4da8ee;"><span style="background-color:#eaf4fc;"> 操作符 </span></span>  <span style="color:#ed7976;"><span style="background-color:#fef2f0;"> 第一次出栈运算数 </span></span></strong></p> 
<p><span style="color:#494949;">即：<strong>16 + 7</strong></span></p> 
<p><span style="color:#494949;">结果：<strong>23</strong></span></p> 
<p> <strong><span style="color:#494949;">将计算结果入栈：</span></strong></p> 
<p><img alt="" height="356" src="https://images2.imgbox.com/31/20/UuI5LvbS_o.png" width="809"></p> 
<hr> 
<p>第十个字符为<strong>运算数</strong>，直接入栈：</p> 
<p><img alt="" height="354" src="https://images2.imgbox.com/d5/9a/LjxTDje3_o.png" width="809"></p> 
<p></p> 
<hr> 
<p>第十一个字符为<strong>操作符</strong>，直接出栈两次：</p> 
<p><img alt="" height="356" src="https://images2.imgbox.com/04/bf/9J63Sca6_o.png" width="811"></p> 
<hr> 
<p><strong>执行：<span style="background-color:#fef2f0;"> </span><span style="color:#ed7976;"><span style="background-color:#fef2f0;">第二次出栈运算数 </span></span>  <span style="color:#4da8ee;"><span style="background-color:#eaf4fc;"> 操作符 </span></span>  <span style="color:#ed7976;"><span style="background-color:#fef2f0;"> 第一次出栈运算数 </span></span></strong></p> 
<p><span style="color:#494949;">即：<strong>23 - 4</strong></span></p> 
<p><span style="color:#494949;">结果：<strong>19</strong></span></p> 
<p><strong><span style="color:#494949;">将计算结果入栈：</span></strong></p> 
<p><img alt="" height="357" src="https://images2.imgbox.com/68/ec/NYiSbVno_o.png" width="810"></p> 
<hr> 
<p>后缀表达式<strong>遍历完成</strong>，栈中数据即为最终计算结果：</p> 
<p><img alt="" height="356" src="https://images2.imgbox.com/b0/6d/0nTNO8u2_o.png" width="811"></p> 
<p></p> 
<p></p> 
<h2 id="%E5%9B%9B%E3%80%81%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0">四、算法实现</h2> 
<p><span style="color:#956fe7;"><strong>程序代码：</strong></span></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;malloc.h&gt;
#include&lt;string.h&gt;
#include&lt;ctype.h&gt;

#define ERROR 0
#define OK 1
#define STACK_INT_SIZE 10  /*存储空间初始分配量*/
#define STACKINCREMENT 5  /*存储空间分配增量*/
#define M 50

typedef char ElemType; /*定义字符数据类型*/
typedef double ElemType2;  /*定义运算数数据类型*/

/*字符栈*/
typedef struct{
    ElemType *base;
    ElemType *top;
    int stacksize; 
}SqStack;

/*运算数栈*/
typedef struct{
    ElemType2 *base;
    ElemType2 *top;
    int stacksize;
}NStack;

int InitStack(SqStack *S);   /*构造空栈*/
int push(SqStack *S,ElemType e); /*入栈*/
int Pop(SqStack *S,ElemType *e);  /*出栈*/
int StackEmpty(SqStack *s);  /*栈空判断*/
void in2post(ElemType *str,ElemType *p);  /*中缀表达式转后缀表达式*/
double cal_post(char *str);  /*计算后缀表达式*/

/*字符栈初始化*/
int InitStack(SqStack *S){
    S-&gt;base=(ElemType *)malloc(STACK_INT_SIZE * sizeof(ElemType));
    if(!S-&gt;base)
        return ERROR;  //分配失败
    S-&gt;top = S-&gt;base;
    S-&gt;stacksize = STACK_INT_SIZE;
    return OK;
}/*InitStack*/

/*运算数栈初始化*/
int InitStack_N(NStack *S){
    S-&gt;base=(ElemType2 *)malloc(STACK_INT_SIZE * sizeof(ElemType2));
    if(!S-&gt;base)
        return ERROR;
    S-&gt;top = S-&gt;base;
    S-&gt;stacksize = STACK_INT_SIZE;
    return OK;
}

/*字符栈入栈*/
int Push(SqStack *S,ElemType e){
    //判断栈满
    if(S-&gt;top - S-&gt;base &gt;= S-&gt;stacksize){
        S-&gt;base = (ElemType *)realloc(S-&gt;base,(S-&gt;stacksize + STACKINCREMENT)*sizeof(ElemType));
        if(NULL == S-&gt;base)  //分配失败
            return ERROR;
        S-&gt;top = S-&gt;base + S-&gt;stacksize;
        S-&gt;stacksize = S-&gt;stacksize+STACKINCREMENT;
    }
    *S-&gt;top = e;
    S-&gt;top++;
    return OK;
}

/*运算数栈入栈*/
int Push_N(NStack *S,ElemType2 e){
    if(S-&gt;top - S-&gt;base &gt;= S-&gt;stacksize){
        S-&gt;base = (ElemType2 *)realloc(S-&gt;base,(S-&gt;stacksize + STACKINCREMENT)*sizeof(ElemType2));
        if(NULL == S-&gt;base)
            return ERROR;
        S-&gt;top = S-&gt;base + S-&gt;stacksize;
        S-&gt;stacksize = S-&gt;stacksize+STACKINCREMENT;
    }
    *S-&gt;top = e;
    S-&gt;top++;
    return OK;
}

/*字符栈出栈*/
int Pop(SqStack *S,ElemType *e){
    //判断栈空
    if(S-&gt;top == S-&gt;base)
        return ERROR;
    S-&gt;top--;
    *e=*S-&gt;top;
    return OK;
}/*Pop*/

/*运算数栈出栈*/
int Pop_N(NStack *S,ElemType2 *e){
    if(S-&gt;top == S-&gt;base)
        return ERROR;
    S-&gt;top--;
    *e=*S-&gt;top;
    return OK;
}

/*判断栈空*/
int StackEmpty(SqStack *s){
    if(s-&gt;top == s-&gt;base)
        return OK;
    return ERROR;
}/*StackEmpty*/

//str为待转换的中缀表达式字符串,p为转换后的后缀表达式字符串
void in2post(ElemType *str,ElemType *p){   /*infix to postfix*/
    SqStack s;   
    InitStack(&amp;s);   //初始化一个空字符栈
    ElemType e;
    int i;
    int j=0;
    for(i=0 ; i&lt;strlen(str) ; i++)  //遍历中缀表达式
    {
        //遇到数字和小数点直接输出
        //使用循环完整接收一个运算数
        while(isdigit(str[i]) || '.'==str[i])
        {
            p[j++]=str[i++];
            if(!isdigit(str[i]) &amp;&amp; '.'!=str[i])
                p[j++]=' ';   //一个数字完整输出后使用空格与其它运算符或数字分隔开
        }

        //遇到左括号直接入栈
        if('('==str[i])
            Push(&amp;s,str[i]);

        //遇到右括号直接出栈，直到栈顶为左括号
        if(')'==str[i])
        {
            while('(' != *(s.top-1))
            {
                Pop(&amp;s,&amp;e);
                p[j++]=e;
                p[j++]=' ';
            }
            Pop(&amp;s,&amp;e);  //左括号出栈但不输出
        }

        //遇到+或—
        //1.栈空/栈顶为左括号:直接入栈
        //2.否则一直出栈,直到栈空/栈顶为左括号,再入栈
        if('+'==str[i] || '-'==str[i])
        {
            while(!StackEmpty(&amp;s) &amp;&amp; '('!=*(s.top-1))
            {
                Pop(&amp;s,&amp;e);
                p[j++]=e;
                p[j++]=' ';
            }
            Push(&amp;s,str[i]);
        }

        //遇到*或/
        //1.栈空/栈顶为左括号/栈顶操作符为+ or -:直接入栈
        //2.否则一直出栈,直到满足1,再入栈
        if('*'==str[i] || '/'==str[i] || '%'==str[i])
        {
            while(!StackEmpty(&amp;s) &amp;&amp; '('!=*(s.top-1) &amp;&amp; '+'!=*(s.top-1) &amp;&amp; '-'!=*(s.top-1))
            {
                Pop(&amp;s,&amp;e);
                p[j++]=e;
                p[j++]=' ';
            }
            Push(&amp;s,str[i]);
        }
    }
    //中缀表达式遍历完成,还需检查栈中是否有未输出字符
    //判断栈空,非空则直接出栈并输出(左括号不用输出)
    while(!StackEmpty(&amp;s)){
        Pop(&amp;s,&amp;e);
        if('('!=e)
        {
            p[j++]=e;
            p[j++]=' ';
        }
    }
    p[--j]='\0';
}/*infix2postfix*/

//str为待计算的后缀表达式,返回值为计算结果
double cal_post(char *str){   /*计算后缀表达式*/
    int i;
    ElemType2 e,a,b;
    char d[M];
    NStack n;
    InitStack_N(&amp;n);   //初始化一个运算数栈保存运算数
    for(i=0;i&lt;strlen(str);i++)
    {
        int j=0;
        while(isdigit(str[i]) || '.'==str[i])
        {
            d[j++]=str[i++];
            d[j]='\0';
            if(!isdigit(str[i]) &amp;&amp; '.'!=str[i])
            {
                e=atof(d);   //使用atof()将字符串形式的运算数转换为double型数据
                Push_N(&amp;n,e);   //运算数入栈
            }
        }
        switch(str[i])
        {
            case '+':
                Pop_N(&amp;n,&amp;b);
                Pop_N(&amp;n,&amp;a);
                Push_N(&amp;n,a+b);
                break;
            case '-':
                Pop_N(&amp;n,&amp;b);
                Pop_N(&amp;n,&amp;a);
                Push_N(&amp;n,a-b);
                break;
            case '*':
                Pop_N(&amp;n,&amp;b);
                Pop_N(&amp;n,&amp;a);
                Push_N(&amp;n,a*b);
                break;
            case '/':
                Pop_N(&amp;n,&amp;b);
                Pop_N(&amp;n,&amp;a);
                Push_N(&amp;n,a/b);
                break;
        }
    }
    Pop_N(&amp;n,&amp;e);
    return e;
}/*calculate_postfix*/

int main()
{
    char str[M];
    char post[M];
    int i;
    printf("\n输入一串中缀表达式：\n");
    gets(str);
    printf("\n对应的后缀表达式：\n");
    in2post(str,post);
    printf("%s",post);
    printf("\n\n计算后缀表达式：\n");
    printf("%f",cal_post(post));
    return 0;
}</code></pre> 
<p><strong>运行结果：</strong></p> 
<p><img alt="" height="230" src="https://images2.imgbox.com/cb/5f/FZqVgEv3_o.png" width="528"></p> 
<p><img alt="" height="121" src="https://images2.imgbox.com/c0/43/Wlb9mfRJ_o.png" width="490"></p> 
<p></p> 
<h2 id="%E4%BA%94%E3%80%81%E7%AE%97%E6%B3%95%E6%94%B9%E8%BF%9B"><strong>五、算法改进</strong></h2> 
<p>上面的代码正确运算的前提是：</p> 
<p>① 输入的中缀表达式<strong>合法</strong></p> 
<p>② 运算数<strong>非负数</strong></p> 
<p></p> 
<p><span style="color:#ff9900;"><strong><span style="background-color:#fff5e6;"> 例如 </span></strong></span>：输入<span style="background-color:#f3f3f4;"> 3*(</span><span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">-6</span></span><span style="background-color:#f3f3f4;">+5) </span>，得到以下结果，后缀表达式和运算结果明显不正确。</p> 
<p><img alt="" height="180" src="https://images2.imgbox.com/1e/64/bnH3Qipd_o.png" width="385"></p> 
<p>这里的 <span style="color:#fe2c24;">-6</span> 应该才是一个完整的运算数，但是在后缀表达式中<span style="color:#fe2c24;"> '-'</span> 号和数字 <span style="color:#fe2c24;">'6'</span> 被拆分开来了，得到的结果也不正确。因为代码中对于 '-' 号一律是作为操作符处理，所以面对像 -6 这样的负数时不能分析出完整正确的运算数。</p> 
<ul><li>如果要进行修改，在进行运算数分析的时候就要考虑<strong>负数</strong>的情况。当出现 '-' 号的时候，要判断它是作为<strong>负数</strong>标志，属于运算数的一部分，还是作为一个运算符。</li></ul> 
<p>所以需要对运算数分析的代码添加负数的处理，修改后的代码如下：</p> 
<p><span style="color:#956fe7;"><strong>in2post</strong></span> 函数代码修改：</p> 
<pre><code class="language-cpp">void in2post(ElemType *str,ElemType *p){   /*infix to postfix*/
    //初始化一个空栈
    SqStack s;
    InitStack(&amp;s);
    ElemType e;

    int i;
    int j=0;
    for(i=0 ; i&lt;strlen(str) ; i++)  //遍历中缀表达式
    {
        if('-' == str[i])    //负数情况判断
        {
            //表达式首位是'-',则一定是作为负数符号
            if(0 == i)
                p[j++]=str[i++];
            //'-'前面是'(',则一定是作为负数符号
            else if('(' == str[i-1])
                p[j++]=str[i++];
        }


        //遇到数字和小数点直接输出
        while(isdigit(str[i]) || '.'==str[i])
        {
            p[j++]=str[i++];
            if(!isdigit(str[i]) &amp;&amp; '.'!=str[i])
                p[j++]=' ';   //一个数字完整输出后使用空格与其它运算符或数字分隔开
        }

        //遇到左括号直接入栈
        if('('==str[i])
            Push(&amp;s,str[i]);

        //遇到右括号直接出栈，直到左括号出栈(左括号不输出)
        if(')'==str[i])
        {
            while('(' != *(s.top-1))
            {
                Pop(&amp;s,&amp;e);
                p[j++]=e;
                p[j++]=' ';
            }
            Pop(&amp;s,&amp;e);  //左括号出栈但不输出
        }

        //遇到+或—
        //1.栈空/栈顶为左括号:直接入栈
        //2.否则一直出栈,直到栈空/栈顶为左括号,再入栈
        if('+'==str[i] || '-'==str[i])
        {
            while(!StackEmpty(&amp;s) &amp;&amp; '('!=*(s.top-1))  //栈非空 且 栈顶非左括号
            {
                Pop(&amp;s,&amp;e);
                p[j++]=e;
                p[j++]=' ';
            }
            Push(&amp;s,str[i]);
        }

        //遇到*或/
        //1.栈空/栈顶为左括号/栈顶操作符为+ or -:直接入栈
        //2.否则一直出栈,直到满足1,再入栈
        if('*'==str[i] || '/'==str[i] || '%'==str[i])
        {
            while(!StackEmpty(&amp;s) &amp;&amp; '('!=*(s.top-1) &amp;&amp; '+'!=*(s.top-1) &amp;&amp; '-'!=*(s.top-1))
            {
                Pop(&amp;s,&amp;e);
                p[j++]=e;
                p[j++]=' ';
            }
            Push(&amp;s,str[i]);
        }
    }
    //中缀表达式遍历完成,还需检查栈中是否有未输出字符
    //判断栈空,非空则直接出栈并输出(左括号不用输出)
    while(!StackEmpty(&amp;s)){
        Pop(&amp;s,&amp;e);
        if('('!=e)
        {
            p[j++]=e;
            p[j++]=' ';
        }
    }
    p[--j]='\0';
}</code></pre> 
<p></p> 
<p><span style="color:#956fe7;"><strong>cal_post</strong></span> 函数代码修改：</p> 
<pre><code class="language-cpp">double cal_post(char *str){
    ElemType2 e,a,b;
    char d[M];
    //初始化一个运算数栈保存运算数
    NStack n;
    InitStack_N(&amp;n);
    int i=0;
    int j=0;
    while(str[i])  //遍历后缀表达式
    {
        switch(str[i])
        {
            case '-':
                if( isdigit(str[i+1]) )  //判断'-'是作为负数符号or运算符
                {
                    d[j++]=str[i++];  //将负号加入运算数字符串
                    d[j]='\0';
                    break;  //注:这里的break只是跳出switch循环
                }
                else
                {
                    Pop_N(&amp;n,&amp;b);
                    Pop_N(&amp;n,&amp;a);
                    Push_N(&amp;n,a-b);
                    i++;
                    break;
                }
            case '+':
                Pop_N(&amp;n,&amp;b);
                Pop_N(&amp;n,&amp;a);
                Push_N(&amp;n,a+b);
                i++;
                break;
            case '*':
                Pop_N(&amp;n,&amp;b);
                Pop_N(&amp;n,&amp;a);
                Push_N(&amp;n,a*b);
                i++;
                break;
            case '/':
                Pop_N(&amp;n,&amp;b);
                Pop_N(&amp;n,&amp;a);
                Push_N(&amp;n,a/b);
                i++;
                break;
            case ' ':i++;
        }

        //遇到运算数直接入栈(先转换double类型)
        //d保存后缀表达式中的字符串形式的运算数
        //使用atof将字符串转换为double类型
        while(isdigit(str[i]) || '.'==str[i])
        {
            d[j++]=str[i++];
            d[j]='\0';
            if( ' ' == str[i] )
            {
                e = atof(d);  //此时分析出的就是完整的运算数
                Push_N(&amp;n,e);
                i++;
                j = 0;
            }
        }
    }
    Pop_N(&amp;n,&amp;e);
    return e;
}</code></pre> 
<p></p> 
<ul><li><strong>运行结果：</strong></li></ul> 
<p> <img alt="" height="177" src="https://images2.imgbox.com/d7/94/dQM8w3a6_o.png" width="438"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d41b5102294be36a608ea221b8966384/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">✨概率论期末速成(三套卷)——试卷①✨</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/072affa25b99b67dc1340f3ff94e10c1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">『赠书活动 ｜ 第六期』《“Java四大名著“，你集齐了吗？》</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>