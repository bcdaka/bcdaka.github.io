<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>力扣刷题之3098.求出所有子序列的能量和 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/4c429d748b73f528bc5b99bafd9b2237/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="力扣刷题之3098.求出所有子序列的能量和">
  <meta property="og:description" content="题干描述 给你一个长度为 n 的整数数组 nums 和一个 正 整数 k 。
一个 子序列
的 能量 定义为子序列中 任意 两个元素的差值绝对值的 最小值 。
请你返回 nums 中长度 等于 k 的 所有 子序列的 能量和 。
由于答案可能会很大，将答案对 109 &#43; 7 取余 后返回。
示例 1：
输入：nums = [1,2,3,4], k = 3
输出：4
解释：
nums 中总共有 4 个长度为 3 的子序列：[1,2,3] ，[1,3,4] ，[1,2,4] 和 [2,3,4] 。能量和为 |2 - 3| &#43; |3 - 4| &#43; |2 - 1| &#43; |3 - 4| = 4 。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-27T23:47:25+08:00">
    <meta property="article:modified_time" content="2024-07-27T23:47:25+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">力扣刷题之3098.求出所有子序列的能量和</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>题干描述</h2> 
<p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 和一个 <strong>正</strong> 整数 <code>k</code> 。</p> 
<p>一个 </p> 
<p>子序列</p> 
<p> 的 <strong>能量</strong> 定义为子序列中 <strong>任意</strong> 两个元素的差值绝对值的 <strong>最小值</strong> 。</p> 
<p>请你返回 <code>nums</code> 中长度 <strong>等于</strong> <code>k</code> 的 <strong>所有</strong> 子序列的 <strong>能量和</strong> 。</p> 
<p>由于答案可能会很大，将答案对 <code>109 + 7</code> <strong>取余</strong> 后返回。</p> 
<p></p> 
<p><strong>示例 1：</strong></p> 
<p><strong>输入：</strong>nums = [1,2,3,4], k = 3</p> 
<p><strong>输出：</strong>4</p> 
<p><strong>解释：</strong></p> 
<p><code>nums</code> 中总共有 4 个长度为 3 的子序列：<code>[1,2,3]</code> ，<code>[1,3,4]</code> ，<code>[1,2,4]</code> 和 <code>[2,3,4]</code> 。能量和为 <code>|2 - 3| + |3 - 4| + |2 - 1| + |3 - 4| = 4</code> 。</p> 
<p><strong>示例 2：</strong></p> 
<p><strong>输入：</strong>nums = [2,2], k = 2</p> 
<p><strong>输出：</strong>0</p> 
<p><strong>解释：</strong></p> 
<p><code>nums</code> 中唯一一个长度为 2 的子序列是 <code>[2,2]</code> 。能量和为 <code>|2 - 2| = 0</code> 。</p> 
<p><strong>示例 3：</strong></p> 
<p><strong>输入：</strong>nums = [4,3,-1], k = 2</p> 
<p><strong>输出：</strong>10</p> 
<p><strong>解释：</strong></p> 
<p><code>nums</code> 总共有 3 个长度为 2 的子序列：<code>[4,3]</code> ，<code>[4,-1]</code> 和 <code>[3,-1]</code> 。能量和为 <code>|4 - 3| + |4 - (-1)| + |3 - (-1)| = 10</code> 。</p> 
<h2>题干解析</h2> 
<p>         首先我们先要理解题干的相关需求：我们需要计算所有长度为K的子序列的能量和，并返回结果对109+7 取余。</p> 
<h4>解题思路</h4> 
<h5>1.理解题目要求</h5> 
<ul><li>给定一个长度为n的整数数组nums和一个正整数k。</li><li>目标是找到所有长度为k的子序列，并计算每个子序列的能量。</li><li>子序列的能量定义是为子序列中任意来个元素的长治绝对值的最小值。</li><li>最后返回所有子序列的能量和。</li></ul> 
<h5>2.动态规划和哈希表的结合</h5> 
<ul><li>为了有效地解决问题，我们采用动态规划和哈希表结合的方法。这种方法的关键点是：</li><li>动态规划 用于记录不同长度子序列的能量。</li><li>哈希表 用于存储子序列的能量技术，确保快速查找和更新。</li></ul> 
<h5>3.初始化数据结构</h5> 
<ul><li>动态分配一个三维数组d来存储哈希表。</li><li>每个d[i][j]表示以nums[i]结尾的长度为j的子序列及其能量信息。</li></ul> 
<h5>4.对数组进行排序</h5> 
<ul><li>使用快速排序对nums进行排序，以便于后续计算两个元素的差值。</li></ul> 
<h5>5.主要是动态规划过程</h5> 
<ul><li>遍历数组nums中的每个元素nums[i]。</li><li>初始化d[i][1]，即长度为1的子序列，其能量为INF（即无穷大），计数为1。</li></ul> 
<pre><code class="language-cpp">hashAddItem(&amp;d[i][1], INF, 1);
</code></pre> 
<ul><li> 对于每个nums[i]，遍历之前的所有元素nums[j]。</li></ul> 
<pre><code class="language-cpp">for (int j = 0; j &lt; i; j++) {
    int diff = abs(nums[i] - nums[j]);
</code></pre> 
<ul><li>对于每个可能的长度p（从2到k），计算从nums[i]结尾的长度为p的子序列的能量。</li></ul> 
<pre><code class="language-cpp">for (int p = 2; p &lt;= k; p++) {
    for (HashItem *pEntry = d[j][p - 1]; pEntry; pEntry = pEntry-&gt;hh.next) {
        int v = pEntry-&gt;key, cnt = pEntry-&gt;val;
        int key = (diff &lt; v) ? diff : v; // 计算最小能量
        hashSetItem(&amp;d[i][p], key, (hashGetItem(&amp;d[i][p], key, 0) + cnt) % MOD);
    }
}
</code></pre> 
<ul><li>更新d[i][p]中以nums[i]结尾的长度为p的子序列的能量和技术。</li></ul> 
<h5>6.计算总能量和</h5> 
<ul><li>遍历所有长度为k的子序列，计算它们的能量和。</li></ul> 
<pre><code class="language-cpp">for (HashItem *pEntry = d[i][k]; pEntry; pEntry = pEntry-&gt;hh.next) {
    int v = pEntry-&gt;key, cnt = pEntry-&gt;val;
    res = (res + 1ll * v * cnt % MOD) % MOD;
}
</code></pre> 
<ul><li>使用% MOD确保结果在范围内。</li></ul> 
<h5>7.释放内存</h5> 
<ul><li>释放动态分配的内存，防止内存泄漏</li></ul> 
<pre><code class="language-cpp">for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt;= k; j++) {
        hashFree(&amp;d[i][j]);
    }
    free(d[i]);
}
free(d);
</code></pre> 
<h4>总结</h4> 
<h4>1.初始化数据结构</h4> 
<ul><li>动态分配一个三维数组d来存储哈希表。</li><li>初始化每个哈希表NULL。</li></ul> 
<h4>2.对数组排序</h4> 
<ul><li>使用快速排序对nums进行排序。</li></ul> 
<h4>3.动态规划填表</h4> 
<p>对于每个元素nums[i]:</p> 
<ul><li>初始化d[i][j]</li><li>对于每个j &lt; i，计算nums[i]和nums[j]之间的差值diff。</li><li>对于每个p（从2到k）更新长度为p的子序列的能量和计数。</li></ul> 
<h4>4.计算总能量和</h4> 
<ul><li>遍历所有长度为k子序列，计算它们的能量和。</li><li>使用% MOD确保结果在范围内。</li></ul> 
<h5>5.释放所有动态分配的内存，防止内存泄漏。</h5> 
<h4>完整代码如下</h4> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include "uthash.h"

// 定义哈希表项结构
typedef struct {
    int key;
    int val;
    UT_hash_handle hh;
} HashItem;

// 查找哈希表中的项
HashItem *hashFindItem(HashItem **obj, int key) {
    HashItem *pEntry = NULL;
    HASH_FIND_INT(*obj, &amp;key, pEntry);
    return pEntry;
}

// 向哈希表中添加项
bool hashAddItem(HashItem **obj, int key, int val) {
    if (hashFindItem(obj, key)) {
        return false;
    }
    HashItem *pEntry = (HashItem *)malloc(sizeof(HashItem));
    pEntry-&gt;key = key;
    pEntry-&gt;val = val;
    HASH_ADD_INT(*obj, key, pEntry);
    return true;
}

// 设置哈希表中的项
bool hashSetItem(HashItem **obj, int key, int val) {
    HashItem *pEntry = hashFindItem(obj, key);
    if (!pEntry) {
        hashAddItem(obj, key, val);
    } else {
        pEntry-&gt;val = val;
    }
    return true;
}

// 获取哈希表中的项
int hashGetItem(HashItem **obj, int key, int defaultVal) {
    HashItem *pEntry = hashFindItem(obj, key);
    if (!pEntry) {
        return defaultVal;
    }
    return pEntry-&gt;val;
}

// 释放哈希表
void hashFree(HashItem **obj) {
    HashItem *curr = NULL, *tmp = NULL;
    HASH_ITER(hh, *obj, curr, tmp) {
        HASH_DEL(*obj, curr);
        free(curr);
    }
}

// 定义一些常量
const int MOD = 1e9 + 7;
const int INF = 0x3f3f3f3f;

// 比较函数，用于qsort排序
static int cmp(const void *a, const void *b) {
    return *(int *)a - *(int *)b;
}

// 计算幂和的函数
int sumOfPowers(int* nums, int numsSize, int k) {
    int n = numsSize;
    int res = 0;

    // 动态分配内存
    HashItem ****d = (HashItem ****)malloc(n * sizeof(HashItem ***));  // 修改1
    for (int i = 0; i &lt; n; i++) {
        d[i] = (HashItem ***)malloc((k + 1) * sizeof(HashItem **));    // 修改2
        for (int j = 0; j &lt;= k; j++) {
            d[i][j] = NULL;
        }
    }

    // 对数组进行排序
    qsort(nums, numsSize, sizeof(int), cmp);

    // 主要的动态规划过程
    for (int i = 0; i &lt; n; i++) {
        hashAddItem(&amp;d[i][1], INF, 1); // 修改3
        for (int j = 0; j &lt; i; j++) {
            int diff = abs(nums[i] - nums[j]);
            for (int p = 2; p &lt;= k; p++) {
                for (HashItem *pEntry = d[j][p - 1]; pEntry; pEntry = pEntry-&gt;hh.next) { // 修改4
                    int v = pEntry-&gt;key, cnt = pEntry-&gt;val;
                    int key = (diff &lt; v) ? diff : v; // 替换fmin函数
                    hashSetItem(&amp;d[i][p], key, (hashGetItem(&amp;d[i][p], key, 0) + cnt) % MOD); // 修改5
                }
            }
        }
        for (HashItem *pEntry = d[i][k]; pEntry; pEntry = pEntry-&gt;hh.next) {
            int v = pEntry-&gt;key, cnt = pEntry-&gt;val;
            res = (res + 1ll * v * cnt % MOD) % MOD;
        }
    }

    // 释放动态分配的内存
    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt;= k; j++) {
            hashFree(&amp;d[i][j]);
        }
        free(d[i]);  // 修改6
    }
    free(d);  // 修改7

    return res;
}

int main() {
    int nums[] = {1, 2, 3, 4};
    int numsSize = sizeof(nums) / sizeof(nums[0]);
    int k = 3;
    int result = sumOfPowers(nums, numsSize, k);
    printf("结果: %d\n", result); // 输出结果: 4

    int nums2[] = {2, 2};
    int numsSize2 = sizeof(nums2) / sizeof(nums2[0]);
    k = 2;
    result = sumOfPowers(nums2, numsSize2, k);
    printf("结果: %d\n", result); // 输出结果: 0

    int nums3[] = {4, 3, -1};
    int numsSize3 = sizeof(nums3) / sizeof(nums3[0]);
    k = 2;
    result = sumOfPowers(nums3, numsSize3, k);
    printf("结果: %d\n", result); // 输出结果: 10

    return 0;
}
</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/48ed1cda8f7ee0ab6e31171bae5e5949/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">最全ElasticSearch启动失败问题（附解决方案）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/13ad5f745bb21c633443629a1cd56a8e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SD-WAN 的真相以及它如何支持企业数字化转型</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>