<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SpringBoot 集成 WebSocket - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/2ea3b0526fe48a5dc3b44fb0dab462c4/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="SpringBoot 集成 WebSocket">
  <meta property="og:description" content="前言 最近在做一个 WebSocket 通信服务的软件，所以必须跟着学一学。
1、WebSocket 概述 一般情况下，我们的服务器和服务器之间可以发送请求，但是服务器是不能向浏览器去发送请求的。因为设计之初并没有想到以后会出现服务端频繁向客户端发送请求的情况。
全双工的通信协议（WebSocket 最大的特点是浏览器也可以往服务器发请求，服务器也可以向浏览器发请求）。
1.1、浏览器和服务器使用WebSocket通信流程 1. 浏览器发起http请求，请求建立 WebSocket 连接 这里的协议升级就是说，我想通过这个 http 连接去升级为 WebSocket 连接
2. 服务器响应统一协议更改 3. 相互发送数据 升级了协议之后浏览器就可以和服务器相互通信了： 1.2、总结 WebSocket 协议是建立在 tcp 协议基础上的，所以不同语言也都支持 tcp 协议是全双工协议，http 协议基于它是单向的WebSocket 没有同源限制，所以前后端端口不一致也不影响信息的发送 2、Java 实现 WebSocket 的两种方式 2.1、基于注解实现WebSocket服务器端 服务终端类：
@ServerEndpoint：监听连接（需要传递一个地址参数）@OnOpen：连接成功@OnClose：连接关闭@OnMessage：收到消息 配置类
把 Spring 中的 ServerEndpointExporter 对象注入进来 2.2.1、编写服务终端类 // 监听哪些客户端来连接了WebSocket服务端 // 监听websocket地址 /myWs @ServerEndpoint(&#34;/myWs&#34;) @Component @Slf4j public class WebServerEndpoint { // 因为可能有多个客户端所以这里需要保证线程安全 static Map&lt;String,Session&gt; sessionMap = new ConcurrentHashMap&lt;&gt;(); // 建立连接时执行的操作 @OnOpen public void onOpen(Session session){ // 每个websocket连接对于服务端来说都是一个Session sessionMap.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-21T11:04:39+08:00">
    <meta property="article:modified_time" content="2024-04-21T11:04:39+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SpringBoot 集成 WebSocket</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>前言</h2> 
<p>        最近在做一个 WebSocket 通信服务的软件，所以必须跟着学一学。</p> 
<h2>1、WebSocket 概述</h2> 
<p>        一般情况下，我们的服务器和服务器之间可以发送请求，但是服务器是不能向浏览器去发送请求的。因为设计之初并没有想到以后会出现服务端频繁向客户端发送请求的情况。</p> 
<p>        全双工的通信协议（WebSocket 最大的特点是浏览器也可以往服务器发请求，<strong>服务器也可以向浏览器发请求</strong>）。</p> 
<h3>1.1、浏览器和服务器使用WebSocket通信流程</h3> 
<h4>1. 浏览器发起http请求，请求建立 WebSocket 连接</h4> 
<p><img alt="" height="381" src="https://images2.imgbox.com/08/2e/tLbaznkx_o.png" width="1200"></p> 
<p>这里的协议升级就是说，我想通过这个 http 连接去升级为 WebSocket 连接</p> 
<h4>2. 服务器响应统一协议更改</h4> 
<p><img alt="" height="231" src="https://images2.imgbox.com/c4/12/06NXrlbC_o.png" width="1200"></p> 
<h4>3. 相互发送数据</h4> 
<p>升级了协议之后浏览器就可以和服务器相互通信了： </p> 
<p><img alt="" height="228" src="https://images2.imgbox.com/3c/b4/RDzlJGtn_o.png" width="745"></p> 
<h3>1.2、总结</h3> 
<ul><li>WebSocket 协议是建立在 tcp 协议基础上的，所以不同语言也都支持 </li><li>tcp 协议是全双工协议，http 协议基于它是单向的</li><li>WebSocket 没有同源限制，所以前后端端口不一致也不影响信息的发送</li></ul> 
<h2>2、Java 实现 WebSocket 的两种方式</h2> 
<h3>2.1、基于注解实现WebSocket服务器端</h3> 
<p><strong>服务终端类</strong>：</p> 
<ul><li>@ServerEndpoint：监听连接（需要传递一个地址参数）</li><li>@OnOpen：连接成功</li><li>@OnClose：连接关闭</li><li>@OnMessage：收到消息</li></ul> 
<p><strong>配置类</strong></p> 
<ul><li>把 Spring 中的 ServerEndpointExporter 对象注入进来</li></ul> 
<h4>2.2.1、编写服务终端类 </h4> 
<pre><code class="language-java">// 监听哪些客户端来连接了WebSocket服务端
// 监听websocket地址 /myWs
@ServerEndpoint("/myWs")
@Component
@Slf4j
public class WebServerEndpoint {

    // 因为可能有多个客户端所以这里需要保证线程安全
    static Map&lt;String,Session&gt; sessionMap = new ConcurrentHashMap&lt;&gt;();

    // 建立连接时执行的操作
    @OnOpen
    public void onOpen(Session session){   // 每个websocket连接对于服务端来说都是一个Session
        sessionMap.put(session.getId(),session);
        log.info("websocket is open");
    }

    /**
     * 收到客户端消息时执行的操作
     * @param text 接受到客户端的消息
     * @return 返回给客户端的消息
     */
    @OnMessage
    public String onMessage(String text){
        log.info("收到一条新消息: " + text);
        return "收到 !";
    }

    // 连接关闭时执行的操作
    @OnClose
    public void onClose(Session session){
        sessionMap.remove(session.getId());
        log.info("websocket is close");
    }

    @Scheduled(fixedRate = 2000) // 每隔2s执行一次
    public static void sendMessage() throws IOException {
        for(String key: sessionMap.keySet()){ // 给所有客户端发送消息
            sessionMap.get(key).getBasicRemote().sendText("beat");
        }
    };
}
</code></pre> 
<p><span style="color:#fe2c24;"><strong>注意</strong></span>：这里监听的地址不可以是 "ws" 不然会报错，可能这是关键字吧，毕竟我们的协议就叫 ws 。</p> 
<h4>2.2.2、编写配置类</h4> 
<pre><code class="language-java">// 需要注入Bean的话必须声明为配置类
@Configuration
public class WebSocketConfig {
    @Bean
    public ServerEndpointExporter serverEndpointExporter(){
        return new ServerEndpointExporter();
    }
}</code></pre> 
<h3>2.2、HTML + JS 实现客户端</h3> 
<p> 在 resources 目录下创建 static/ws-client.html</p> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;WebSocket Client&lt;/title&gt;
&lt;/head&gt;
&lt;script&gt;
    // 客户端和服务器连接的地址(我们服务端监听的地址)
    let ws = new WebSocket("ws://localhost:8080/myWs1")
    ws.onopen=function (){ // 连接打开的时候向服务器发送一条消息
        ws.send("hey man")
    }
    ws.onmessage=function (message) {
        console.log(message.data)
    }
&lt;/script&gt;
&lt;body&gt;
&lt;h1&gt;WebSocket&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<p><strong>测试</strong>：启动 SpringBoot 并访问  localhost:8080/ws-client.html</p> 
<p><img alt="" height="272" src="https://images2.imgbox.com/22/15/yK9O6fJS_o.png" width="1186"></p> 
<p>执行结果： </p> 
<p><img alt="" height="217" src="https://images2.imgbox.com/64/3e/25XVqFQM_o.png" width="1200"></p> 
<h3>2.3、基于 Spring 框架实现 WebSocket 服务器端</h3> 
<p><strong>Spring 提供的类和框架</strong></p> 
<ul><li>HttpSessionHandshakeInterceptor（抽象类）：握手拦截器，在握手前后添加操作</li><li>AbstractWebSocketHandler（抽象类）：WebSocket 处理程序，监听连接前、中、后</li><li>WebSocketConfigurer（接口）：配置程序，比如配置监听哪个端口，配置自定义的握手拦截器，配置我们自定义的处理程序</li></ul> 
<h4>2.3.1、编写握手拦截器类</h4> 
<pre><code class="language-java">/**
 * WebSocket 自定义握手拦截器
 */
@Component
@Slf4j
public class MyInterceptor extends HttpSessionHandshakeInterceptor {
    @Override
    public boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes) throws Exception {
        log.info("握手前");
        log.info("远程地址 =&gt; " + request.getRemoteAddress());
        // 保留父类的操作
        return super.beforeHandshake(request, response, wsHandler, attributes);
    }

    @Override
    public void afterHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Exception ex) {
        log.info("完成握手");
        // 完成握手后它就会把 HTTP 协议升级为 WebSocket 协议
        super.afterHandshake(request, response, wsHandler, ex);
    }
}
</code></pre> 
<h4>2.3.2、编写 WebSocket 处理程序</h4> 
<pre><code class="language-java">/**
 * WebSocket 自定义处理程序
 */
@Slf4j
@Component
public class MyWsHandler extends AbstractWebSocketHandler {
    // WebSocketSession 对象可以封装一下吧用户的信息封装进去
    private static Map&lt;String, SessionBean&gt; sessionMap = new ConcurrentHashMap&lt;&gt;();
    // 线程安全的int值
    private static AtomicInteger clientIdMaker = new AtomicInteger(0);

    // 连接建立
    @Override
    public void afterConnectionEstablished(WebSocketSession session) throws Exception {
        super.afterConnectionEstablished(session);
        // 放在父方法调用之后
        SessionBean sessionBean = new SessionBean(session, clientIdMaker.getAndIncrement());
        sessionMap.put(session.getId(),sessionBean);
        log.info(sessionMap.get(session.getId()) + " connected");
    }

    // 收到消息
    @Override
    protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
        super.handleTextMessage(session, message);
        log.info(sessionMap.get(session.getId()).getClientId() + " : " + message.getPayload());
    }

    // 传输异常
    @Override
    public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception {
        super.handleTransportError(session, exception);
        // 如果异常就关闭 session
        if (session.isOpen())
            session.close();
        sessionMap.remove(session.getId());
    }

    // 连接关闭
    @Override
    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {
        super.afterConnectionClosed(session, status);
        log.info(sessionMap.get(session.getId()) + " closed");
        sessionMap.remove(session.getId());
    }

    @Scheduled(fixedRate = 2000) // 每隔2s执行一次
    public static void sendMessage() throws IOException {
        for(String key: sessionMap.keySet()){ // 给所有客户端发送消息
            sessionMap.get(key).getWebSocketSession().sendMessage(new TextMessage("beat"));
        }
    }
}</code></pre> 
<h4>2.3.3、编写配置类</h4> 
<pre><code class="language-java">@Configuration
@EnableWebSocket    // 启用 spring 提供的 websocket 功能
public class MyWsConfig implements WebSocketConfigurer {

    @Resource
    MyWsHandler myWsHandler; // 引入我们在MyWsHandler上声明的Bean(@Component)
    @Resource
    MyInterceptor myInterceptor;
    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        // 监听的地址
        registry.addHandler(myWsHandler,"/myWs1")
                .addInterceptors(myInterceptor)
                .setAllowedOrigins("*"); // 允许的源
    }
}</code></pre> 
<p>修改 html 中的 websocket 地址为 /myWs1 </p> 
<p> <strong>测试</strong>：访问 localhost:8080/ws-client.html</p> 
<h2><img alt="" height="486" src="https://images2.imgbox.com/b7/77/19vvsrJv_o.png" width="1200">3、总结</h2> 
<p><img alt="" height="295" src="https://images2.imgbox.com/0c/26/afHpUEeI_o.png" width="750"></p> 
<p>服务器会和每个客户端维护一个连接 ：</p> 
<p><img alt="" height="110" src="https://images2.imgbox.com/16/e0/M4suP156_o.png" width="350"><img alt="" height="102" src="https://images2.imgbox.com/0a/02/5OLJrVLz_o.png" width="350"></p> 
<h2>3、WebSocket 实现多人聊天室</h2> 
<h3>3.1、需求</h3> 
<ul><li>进入聊天室</li><li>群聊功能，任何人说话，所有人都能接受到消息</li><li>退出群聊</li></ul> 
<h3>3.2、实现</h3> 
<h4>3.2.1、编写前端界面和通信逻辑 </h4> 
<p>        这里我们通过 js 实现了当用户点击发送按钮的时候，把文本框的内容通过 websocket 发送给指定的地址，我们的后台 websocket 程序收到后会全部群发给所有当前连接的客户端：</p> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;WebSocket Client&lt;/title&gt;
&lt;/head&gt;
&lt;script&gt;
    // 客户端和服务器连接的地址(我们服务端监听的地址)
    let ws = new WebSocket("ws://localhost:8080/myWs1")
    ws.onopen=function (){ // 连接打开的时候向服务器发送一条消息
        // ws.send("hey man")
    }
    ws.onmessage=function (message) {
        // console.log(message.data)
        document.getElementById("talkMsg").innerHTML = message.data
    }
    function sendMsg(){
        // 发送文本框的信息
        ws.send(document.getElementById("message").value)
        // 发送完清空输入框
        document.getElementById("message").value=""
    }
&lt;/script&gt;
&lt;body&gt;
&lt;h1&gt;WebSocket 多人聊天室&lt;/h1&gt;
&lt;p style="border: 1px solid black;width: 600px;height: 500px" id="talkMsg"&gt;&lt;/p&gt;
&lt;input id="message" /&gt;
&lt;button id="sendBtn" onclick="sendMsg()"&gt;发 送&lt;/button&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<h4> 3.2.2、WebSocket 后台处理程序</h4> 
<p>         这里我们编写了一个 sendMessage 的方法来给所有已连接的客户端进行消息的群发，而我们上面的前端代码中设置当 websocket 收到消息后，会把文本域（&lt;p&gt;标签）中的内容替换掉（innerHTML），因为我们的消息是不断累加到 StringBuffer 当中的，而文本域内容的替换开销并不会造成视觉上的卡顿：</p> 
<pre><code class="language-java">/**
 * WebSocket 自定义处理程序
 */
@Slf4j
@Component
public class MyWsHandler extends AbstractWebSocketHandler {
    // WebSocketSession 对象可以封装一下吧用户的信息封装进去
    private static Map&lt;String, SessionBean&gt; sessionMap = new ConcurrentHashMap&lt;&gt;();
    // 线程安全的int值
    private static AtomicInteger clientIdMaker = new AtomicInteger(0);
    //
    private static StringBuffer sb = new StringBuffer();

    // 连接建立
    @Override
    public void afterConnectionEstablished(WebSocketSession session) throws Exception {
        super.afterConnectionEstablished(session);
        // 放在父方法调用之后
        SessionBean sessionBean = new SessionBean(session, clientIdMaker.getAndIncrement());
        sessionMap.put(session.getId(),sessionBean);
        log.info(sessionMap.get(session.getId()) + " connected");
        sb.append(sessionBean.getClientId()).append(" 进入了群聊&lt;br/&gt;");
        sendMessage(sessionMap);
    }

    // 收到消息
    @Override
    protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
        super.handleTextMessage(session, message);
        log.info(sessionMap.get(session.getId()).getClientId() + " : " + message.getPayload());
        sb.append(sessionMap.get(session.getId()).getClientId()).append(" : ").append(message.getPayload()).append("&lt;br/&gt;");
        sendMessage(sessionMap);
    }

    // 传输异常
    @Override
    public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception {
        super.handleTransportError(session, exception);
        // 如果异常就关闭 session
        if (session.isOpen())
            session.close();
        sessionMap.remove(session.getId());
    }

    // 连接关闭
    @Override
    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {
        super.afterConnectionClosed(session, status);
        Integer clientId = sessionMap.get(session.getId()).getClientId();
        log.info(sessionMap.get(session.getId()) + " closed");
        sessionMap.remove(session.getId());
        sb.append(clientId).append("退出了群聊&lt;br/&gt;");
        sendMessage(sessionMap);
    }

    public void sendMessage(Map&lt;String,SessionBean&gt; sessionMap){
        for(String sessionId: sessionMap.keySet()){
            try {
                sessionMap.get(sessionId).getWebSocketSession().sendMessage(new TextMessage(sb.toString()));
            } catch (IOException e) {
                e.printStackTrace();
                log.error(e.getMessage());
            }
        }
    }
}</code></pre> 
<h4>3.2.3、测试</h4> 
<p>启动项目，并访问 <a href="http://localhost:8080/ws-client.html" rel="nofollow" title="http://localhost:8080/ws-client.html">http://localhost:8080/ws-client.html</a></p> 
<p><img alt="" height="522" src="https://images2.imgbox.com/6c/e6/5MkVJV88_o.png" width="500"></p> 
<p>        可以看到，当我们启动多个客户端（开启多个网页），就会显示多人加入群聊，当任意客户端发送消息后，所有客户端都可以看到，当有客户端退出后，同样所有人都可以看到。</p> 
<h2>4、WebSocket 使用场景</h2> 
<p>        总的来讲，websocket 主要的特点就是全双工通信吗，它最大的优势就是实时性特别好，因为传统的单工通信我们客户端需要不断的向服务器发送请求，要追求实时性就必须不断频繁发送请求，效率肯定是低下的。而基于 WebSocket 协议的全双工通信的话就不需要了，因为服务端下你在可以主动给客户端发送消息了，就不需要客户端不断的去发送请求了。</p> 
<p>        比如股价分析，股票什么时候发生变动我们谁也说不清楚，但是难道让客户端每几百毫秒去访问一次服务器吗？那必不可能，最好的办法就是每当股价发生变动，让服务器主动给客户端发送消息，客户端收到消息以后再做更新。这样通信效率一下子刷就上来了。</p> 
<h3>4.1、网页在线客服</h3> 
<p><img alt="" height="508" src="https://images2.imgbox.com/c0/a0/cWJUMyvD_o.png" width="650"></p> 
<h3>4.2、chatGpt</h3> 
<p><img alt="" height="327" src="https://images2.imgbox.com/a7/2c/GzzfIHl7_o.png" width="650"></p> 
<h3>4.3、弹幕</h3> 
<p><img alt="" height="365" src="https://images2.imgbox.com/a8/c2/zDug69L2_o.png" width="650"></p> 
<h3>4.4、实时股价分析</h3> 
<p><img alt="" height="438" src="https://images2.imgbox.com/19/18/gpCxNhkl_o.png" width="650"></p> 
<h3>4.5、4399小游戏</h3> 
<p><img alt="" height="338" src="https://images2.imgbox.com/57/e3/iWZaOLvI_o.png" width="650"></p> 
<h3>4.6、实时统计</h3> 
<p><img alt="" height="273" src="https://images2.imgbox.com/90/9f/FFOYZy6z_o.png" width="650"></p> 
<h2> 总结</h2> 
<h3>1、为什么需要 WebSocket?</h3> 
<p>        HTTP 请求只能从浏览器（客户端）发送服务器，不能从服务器发往浏览器（客户端），这就导致一些需要从服务器发往浏览器（客户端）的场景满足不了。</p> 
<h3>2、WebSocket 是什么？</h3> 
<p>        WebSocket 是 HTML5 支持的，它是基于现有的 HTTP 请求进行了协议升级的一个全双工通信协议。一般用于实时性要求比较高的场景。</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/924936930254a36a45db9cd3ac9c074e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">手把手教你Windows下搭建Filebeat&#43;Logstash&#43;ElasticSearch&#43;Kibana系统</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/848aa49cdfcc6400db2fb21b44de7245/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Python数分实战】预测肥胖风险数据</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>