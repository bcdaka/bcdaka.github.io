<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【一步一步了解Java系列】：认识String类 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/524f166d839841fd5dc439135bef25da/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【一步一步了解Java系列】：认识String类">
  <meta property="og:description" content="看到这句话的时候证明：此刻你我都在努力
加油陌生人
个人主页：Gu Gu Study
专栏：一步一步了解Java
喜欢的一句话： 常常会回顾努力的自己，所以要为自己的努力留下足迹
喜欢的话可以点个赞谢谢了。
作者：小闭
String在Java中是一个类，平常我们存储字符串时也是储存在这个类型中的，但是Java创建Strring类肯定不仅仅让我们储存字符串而已，他也为我们提供了许多成员方法。接下来就让我们来学习一下。
String的构造 字符串的构造有挺多的，现在我就列出比较常用的三种构造方式：
以下是三种构造方式：
使用常量串进行构造使用new关键字进行构造使用字符串进行构造 public class Test { public static void main(String[] args) { //使用常量串进行构造 String s1=&#34;hehe&#34;; //使用new关键字进行构造 String s2=new String(&#34;hehe&#34;); //使用字符串进行构造 char[] arr={&#39;h&#39;,&#39;e&#39;,&#39;h&#39;,&#39;e&#39;}; String s3=new String(arr); } } 注意：String是一个引用类型， 内部并不存储字符串本身，在String类的实现源码中，String类实例变量如下： 在现在的jdk中是一个byte类型的数组进行储存的。
String 的比较 在Java中String中，==的比较对于不同类型的数据比较方式是不同的，对于基本类型是比较其中的值是否相等，对于引用类型是进行比较引用的地址是否相等。当然如果用常量字符串进行构造那么其地址是一样的，也就是两个用常量字符串构造的字符串成员变量他们是相等的。
public static void main(String[] args) { int a = 10; int b = 20; int c = 10; // 对于基本类型变量，==比较两个变量中存储的值是否相同 System.out.println(a == b); // false System.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-17T08:42:42+08:00">
    <meta property="article:modified_time" content="2024-06-17T08:42:42+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【一步一步了解Java系列】：认识String类</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>看到这句话的时候证明：此刻你我都在努力</strong><br> <strong>加油陌生人</strong><br> <img src="https://images2.imgbox.com/d0/f4/qGhJVb4n_o.png" alt="微信图片编辑_20240229212205.png"><br> <br><strong>个人主页：</strong><a href="https://blog.csdn.net/2302_81249757?type=lately"><strong>Gu Gu Study</strong></a><strong><br><strong>专栏：</strong><a href="https://blog.csdn.net/2302_81249757/category_12656486.html?spm=1001.2014.3001.5482"><strong>一步一步了解Java</strong></a><br><br> 喜欢的一句话： 常常会回顾努力的自己，所以要为自己的努力留下足迹</strong><br> <br><strong>喜欢的话可以点个赞谢谢了。</strong><br> <strong>作者：小闭</strong></p> 
<hr> 
<p><strong>String在Java中是一个类，平常我们存储字符串时也是储存在这个类型中的，但是Java创建Strring类肯定不仅仅让我们储存字符串而已，他也为我们提供了许多成员方法。接下来就让我们来学习一下。</strong></p> 
<h2><a id="String_13"></a>String的构造</h2> 
<p>字符串的构造有挺多的，现在我就列出比较常用的三种构造方式：<br> 以下是三种构造方式：</p> 
<ol><li><strong>使用常量串进行构造</strong></li><li><strong>使用new关键字进行构造</strong></li><li><strong>使用字符串进行构造</strong></li></ol> 
<pre><code>public class Test {
    public static void main(String[] args) {
        //使用常量串进行构造
        String s1="hehe";

        //使用new关键字进行构造
        String s2=new String("hehe");

       //使用字符串进行构造
        char[] arr={'h','e','h','e'};
        String s3=new String(arr);

    }



}
</code></pre> 
<p>注意：String是一个引用类型， 内部并不存储字符串本身，在String类的实现源码中，String类实例变量如下： 在现在的jdk中是一个byte类型的数组进行储存的。<img src="https://images2.imgbox.com/9a/fe/FHoPZFLP_o.png" alt="image.png"></p> 
<hr> 
<h3><a id="String__43"></a>String 的比较</h3> 
<p>在Java中String中，==的比较对于不同类型的数据比较方式是不同的，对于基本类型是比较其中的值是否相等，对于引用类型是进行比较引用的地址是否相等。当然如果用常量字符串进行构造那么其地址是一样的，也就是两个用常量字符串构造的字符串成员变量他们是相等的。</p> 
<pre><code>public static void main(String[] args) {
        int a = 10;
        int b = 20;
        int c = 10;
// 对于基本类型变量，==比较两个变量中存储的值是否相同
        System.out.println(a == b); // false
        System.out.println(a == c); // true
// 对于引用类型变量，==比较两个引用变量引用的是否为同一个对象
        String s1 = new String("hello");
        String s2 = new String("hello");
        String s3 = new String("world");
        String s4 = s1;
        String s5 = "hehe";    //字符串构造的方法构造字符串
        String s6 = "hehe";
        System.out.println(s1 == s2); // false
        System.out.println(s2 == s3); // false
        System.out.println(s1 == s4); // true
        System.out.println(s5 == s6); // true
        
    }
</code></pre> 
<p>那么使用什么比较方法可以比较里面的内容呢？这时我们就要引入一个方法了equals，这是字符串自带的一个比较方法。那接下来我们就看看如何使用吧。</p> 
<pre><code>public class Test {

    String s1=new String("hehe");
    String s2=new String("haha");
    String s3=new String("hehe");
    String s4=s1;

    public static void main(String[] args) {
        Test t=new Test();
        System.out.println(t.s1.equals(t.s2));

        System.out.println(t.s1.equals(t.s4));

        System.out.println(t.s1.equals(t.s3));

        System.out.println(t.s1==t.s3);


    }



}
</code></pre> 
<p><img src="https://images2.imgbox.com/5c/c6/H80PhzXK_o.png" alt="image.png"><br> equals是比较字符串里面的内容的，而不是比较地址所以有了以上的结果。</p> 
<hr> 
<h4><a id="_98"></a>字符串的查找</h4> 
<p>大家在了解了一定的字符串知识后可能也想到了一个问题。那就是字符串能不能查找某个字符所在的位置呢？答案肯定是可以的。这时我们就又需要到String类自带的方法了。</p> 
<blockquote> 
 <p><strong>Java 中的 String 类提供了多种查找方法，这些方法可以用于在字符串中查找子字符串、字符或者模式。以下是一些常用的查找方法：</strong></p> 
 <ol><li><strong>indexOf(int ch) - 返回指定字符 ch 在字符串中首次出现的索引。</strong></li><li><strong>indexOf(int ch, int fromIndex) - 从 fromIndex 位置开始搜索，返回指定字符 ch 在字符串中首次出现的索引。</strong></li><li><strong>indexOf(String str) - 返回子字符串 str 在字符串中首次出现的索引。</strong></li><li><strong>indexOf(String str, int fromIndex) - 从 fromIndex 位置开始搜索，返回子字符串 str 在字符串中首次出现的索引。</strong></li><li><strong>lastIndexOf(int ch) - 返回指定字符 ch 在字符串中最后一次出现的索引。</strong></li><li><strong>lastIndexOf(int ch, int fromIndex) - 从 fromIndex 位置开始反向搜索，返回指定字符 ch 在字符串中最后一次出现的索引。</strong></li><li><strong>lastIndexOf(String str) - 返回子字符串 str 在字符串中最后一次出现的索引。</strong></li><li><strong>lastIndexOf(String str, int fromIndex) - 从 fromIndex 位置开始反向搜索，返回子字符串 str 在字符串中最后一次出现的索引。</strong></li><li><strong>contains(CharSequence s) - 判断字符串是否包含序列 s。</strong></li><li><strong>startsWith(String prefix) - 判断字符串是否以指定前缀 prefix 开始。</strong></li><li><strong>startsWith(String prefix, int toffset) - 从指定索引 toffset 开始，判断字符串是否以指定前缀 prefix 开始。</strong></li><li><strong>endsWith(String suffix) - 判断字符串是否以指定后缀 suffix 结束。</strong></li></ol> 
</blockquote> 
<p><strong>这些方法在处理字符串时非常有用，可以根据需要选择适当的方法来进行字符串的查找操作。</strong></p> 
<p><strong>因为函数太多就不一一示例了，就简单给大家简单使用几个函数。</strong></p> 
<pre><code>public class Test1 {
    String s1="holle world";
    String s2="this is a person";

    public static void main(String[] args) {
        Test1 t=new Test1();
        System.out.println(t.s1.indexOf("w", 2));
        System.out.println(t.s1.indexOf("w", 7));
        System.out.println(t.s1.lastIndexOf("w",2));
        System.out.println(t.s1.lastIndexOf("w"));
        System.out.println(t.s1.contains("holle "));


    }
}
</code></pre> 
<p><img src="https://images2.imgbox.com/4a/96/zjxbjRbe_o.png" alt="image.png"><br> 如上就是代码的运行结果。</p> 
<p>那如果我们想要取出字符串中下标为n的字符，那么这时我们就需要到另一个字符串方法了。那就是<br> char charAt( int n);</p> 
<pre><code>public class Test1 {
    String s1="holle world";
    String s2="this is a person";

    public static void main(String[] args) {
        Test1 t=new Test1();
        System.out.println(t.s1.charAt(6));
    }
</code></pre> 
<p><img src="https://images2.imgbox.com/7e/be/jgl5dXrW_o.png" alt="image.png"></p> 
<hr> 
<h5><a id="_153"></a><strong>字符串的转化</strong></h5> 
<p>String类也包含了方法转化为其它类型，当然其它类型也是可以转化成字符串。接下来我们看一下。<br> 在Java中，String类提供了一个静态方法valueOf()，它可以将各种类型转换为String类型。这个方法非常通用，适用于原始数据类型、对象、数组等。以下是一些使用String.valueOf()方法的例子：</p> 
<ul><li><strong>原始数据类型</strong>：可以直接将原始类型（如int, double等）转换为String。</li></ul> 
<pre><code>int num = 10;
String numStr = String.valueOf(num);

double d = 3.14;
String dStr = String.valueOf(d);
</code></pre> 
<hr> 
<ul><li><strong>对象</strong>：如果对象是null，String.valueOf(null)将返回"null"字符串。对于非null对象，valueOf()将调用对象的toString()方法来获取其字符串表示。</li></ul> 
<pre><code>Object obj = new Object();
String objStr = String.valueOf(obj); // 调用obj的toString()方法

String nullStr = String.valueOf(null); // 返回"null"
</code></pre> 
<hr> 
<ul><li><strong>数组</strong>：String.valueOf()可以用于将数组转换为字符串，但不会像Arrays.toString()那样提供友好的数组格式。它只是简单地调用数组的toString()方法。</li></ul> 
<pre><code>int[] array = {1, 2, 3};
String arrayStr = String.valueOf(array); // 返回"[I@15aeb7ab"（示例）
</code></pre> 
<hr> 
<ul><li><strong>集合</strong>：对于集合类型，String.valueOf()会调用集合的toString()方法。</li></ul> 
<pre><code>List&lt;String&gt; list = Arrays.asList("Hello", "World");
String listStr = String.valueOf(list); // 返回"[Hello, World]"
</code></pre> 
<hr> 
<ul><li><strong>枚举</strong>：枚举类型也可以使用String.valueOf()转换为字符串。</li></ul> 
<pre><code>enum Color { RED, GREEN, BLUE }
String colorStr = String.valueOf(Color.RED); // 返回"RED"
</code></pre> 
<hr> 
<ul><li><strong>字符串字面量</strong>：对于字符串字面量，String.valueOf()将直接返回该字符串。</li></ul> 
<pre><code>String literal = "Hello, World!";
String str = String.valueOf(literal); // 返回"Hello, World!"
</code></pre> 
<p>String.valueOf()方法是一个方便的工具，可以用于将几乎所有类型转换为字符串，但它不会对数组或集合进行特殊格式化，只会调用它们的toString()方法。如果需要更友好的格式化输出，可能需要使用其他方法，如Arrays.toString()或自定义的格式化逻辑。</p> 
<hr> 
<pre><code>public class Test {
    String s1 = "hello world";

    public static void main(String[] args) {
        Test t = new Test();

// 数字转字符串
        String s1 = String.valueOf(1234);
        String s2 = String.valueOf(12.34);
        String s3 = String.valueOf(true);
        String s4 = String.valueOf(new Student("Hanmeimei", 18));
        System.out.println(s1);
        System.out.println(s2);

        System.out.println(s3);
        System.out.println(s4);
        System.out.println();

       
// 字符串转数字
// 注意：Integer、Double等是Java中的包装类型
        int data1 = Integer.parseInt("1234");
        double data2 = Double.parseDouble("12.34");
        System.out.println(data1);
        System.out.println(data2);
    }
}
</code></pre> 
<p><img src="https://images2.imgbox.com/23/39/4VKDnLM8_o.png" alt="image.png"></p> 
<hr> 
<h6><a id="String_245"></a>String类中的替换和截取方法</h6> 
<p>在Java中，String 类提供了多种方法来替换字符串中的字符或子串，以及截取字符串的一部分。以下是一些常用的字符串操作方法：<br> <strong>替换方法：</strong></p> 
<ol><li><strong>replace(char oldChar, char newChar)</strong>： 替换字符串中的所有指定字符。</li></ol> 
<pre><code>String str = "hello world";
String replaced = str.replace('o', 'e'); // "hellE werd"
</code></pre> 
<ol start="2"><li><strong>replace(CharSequence target, CharSequence replacement)</strong>： 替换字符串中所有匹配的子串。</li></ol> 
<pre><code>String str = "hello world";
String replaced = str.replace("world", "Java"); // "hello Java"
</code></pre> 
<ol start="3"><li><strong>replaceAll(String regex, String replacement)</strong>： 使用正则表达式来替换字符串中的匹配项。</li></ol> 
<pre><code>String str = "hello world";
String replaced = str.replaceAll("\\w+", "X"); // "X X"
</code></pre> 
<ol start="4"><li><strong>replaceFirst(String regex, String replacement)</strong>： 使用正则表达式替换字符串中的第一个匹配项。</li></ol> 
<pre><code>String str = "hello world";
String replaced = str.replaceFirst("\\w+", "X"); // "X world"
</code></pre> 
<p><strong>截取方法：</strong></p> 
<ol><li><strong>substring(int beginIndex)</strong>： 从指定位置开始截取到字符串末尾。</li></ol> 
<pre><code>String str = "hello world";
String sub = str.substring(6); // "world"
</code></pre> 
<ol start="2"><li><strong>substring(int beginIndex, int endIndex)</strong>： 截取字符串的一部分，从beginIndex开始到endIndex - 1结束。</li></ol> 
<pre><code>String str = "hello world";
String sub = str.substring(0, 5); // "hello"
</code></pre> 
<ol start="3"><li><strong>charAt(int index)</strong>： 获取字符串中指定位置的字符。</li></ol> 
<pre><code>String str = "hello world";
char ch = str.charAt(0); // 'h'
</code></pre> 
<ol start="4"><li><strong>split(String regex)</strong>： 使用正则表达式来分割字符串，返回一个字符串数组。</li></ol> 
<pre><code>String str = "hello,world";
String[] parts = str.split(","); // ["hello", "world"]
</code></pre> 
<ol start="5"><li><strong>substringBefore(String delimiter)</strong> 和 <strong>substringAfter(String delimiter)</strong>： 根据指定的分隔符截取字符串。</li></ol> 
<pre><code>String str = "hello-world";
String before = str.substringBefore("-"); // "hello"
String after = str.substringAfter("-"); // "world"
</code></pre> 
<ol start="6"><li><strong>substringTrimmed()</strong>： 截取字符串，同时去除首尾的空白字符。</li></ol> 
<pre><code>String str = "  hello world  ";
String trimmed = str.substringTrimmed(); // "hello world"
</code></pre> 
<p>请注意，String 类在Java中是不可变的，这意味着所有这些操作都会返回一个新的字符串实例，而不会修改原始字符串。</p> 
<hr> 
<p><strong>spilt方法详解</strong><br> 相信大家用过split方法用空格（“ ”）后有时会出现有空字符的元素，那么这是为什么呢？，这就需要我们好好了解一下，split这个方法了。在传给它的参数是“ ”时会怎么分割的呢？</p> 
<ol><li><strong>基本分割</strong>： 如果字符串中包含空格，split() 会按照空格分割字符串。</li></ol> 
<pre><code>String str = "hello world";
String[] parts = str.split(" "); // 使用单个空格作为分隔符
// parts 将是 ["hello", "world"]
</code></pre> 
<ol start="2"><li><strong>忽略连续空格</strong>： split() 方法默认情况下不会忽略连续的空格。如果字符串中有连续的空格，它们将导致数组中出现空字符串。</li></ol> 
<pre><code>String str = "hello   world";
String[] parts = str.split(" "); // 将返回 ["hello", "", "", "world"]
</code></pre> 
<ol start="3"><li><strong>字符串首尾空格</strong>： split() 方法不会自动去除字符串首尾的空格。如果需要去除这些空格，你需要在分割前使用 trim() 方法。</li></ol> 
<pre><code>String str = " hello world ";
String[] parts = str.trim().split(" "); // 先去除首尾空格，然后分割
// parts 将是 ["hello", "world"]
</code></pre> 
<ol start="4"><li><strong>分割后去除空白</strong>： 如果你想要去除分割后数组元素的首尾空白，可以在分割后对每个元素使用 trim() 方法。</li></ol> 
<pre><code>String str = " hello world ";
String[] parts = str.split(" ");
for (int i = 0; i &lt; parts.length; i++) {
    parts[i] = parts[i].trim(); // 去除每个元素的首尾空白
}
// parts 将是 ["hello", "world"]
</code></pre> 
<ol start="5"><li><strong>使用正则表达式分割</strong>： 如果你想要更灵活地处理空格，比如同时忽略多个连续空格和首尾空格，你可以使用正则表达式 \s+ 来代替单个空格。</li></ol> 
<pre><code>String str = " hello world ";
String[] parts = str.trim().split("\\s+"); // 使用正则表达式来分割
// parts 将是 ["hello", "world"]
</code></pre> 
<ol start="6"><li><strong>空字符串</strong>： 如果原始字符串是空字符串或者只包含空格，split(" ") 将返回一个包含单个空字符串的数组。</li></ol> 
<pre><code>String str = " ";
String[] parts = str.split(" "); // 将返回 [""]
</code></pre> 
<ol start="7"><li><strong>null 值</strong>： 如果输入的字符串是 null，使用 split(" ") 将抛出 NullPointerException。</li></ol> 
<p>split() 方法返回的数组大小取决于字符串中空格的数量，包括连续的空格。如果需要忽略连续空格或首尾空格，你可能需要使用 trim() 和正则表达式 \s+ 的组合。</p> 
<hr> 
<p>StringBuffer和StringBuilder<br> StringBuffer 是Java中一个线程安全的可变字符串类。它是 AbstractStringBuilder 类的一个具体实现，并且扩展了 CharSequence 接口。由于其线程安全性，StringBuffer 在多线程环境中经常被使用，以避免多个线程同时修改字符串时发生的问题。<br> 以下是 StringBuffer 的一些主要特点和用法：</p> 
<ol><li><strong>线程安全</strong>： StringBuffer 类中的所有方法都是同步的，这意味着它可以在多线程环境中安全使用，而不需要额外的同步措施。</li><li><strong>可变字符串</strong>： 与 String 类不同，StringBuffer 允许修改字符串内容，如插入、删除或替换字符。</li><li><strong>容量自动增长</strong>： StringBuffer 内部维护了一个容量足够大的字符数组来存储字符串。如果字符串增长超出了当前容量，StringBuffer 会自动增长其内部数组。</li><li><strong>常用方法</strong>： 
  <ul><li>append(Object obj)：将对象的字符串表示追加到 StringBuffer 的末尾。</li><li>insert(int offset, Object obj)：在指定位置插入对象的字符串表示。</li><li>delete(int start, int end)：删除从 start 到 end - 1 之间的字符。</li><li>reverse()：反转 StringBuffer 中的字符顺序。</li><li>substring(int start) 和 substring(int start, int end)：返回 StringBuffer 的子字符串。</li><li>capacity()：返回当前分配给 StringBuffer 的容量。</li><li>ensureCapacity(int minimumCapacity)：确保 StringBuffer 的容量至少为指定的最小容量。</li><li>toString()：返回 StringBuffer 的当前字符串表示。</li></ul> </li><li><strong>性能考虑</strong>： 由于同步带来的开销，StringBuffer 的性能可能不如 StringBuilder（非线程安全的可变字符串类）。因此，如果你不需要线程安全，可以考虑使用 StringBuilder。</li><li><strong>示例代码</strong>：</li></ol> 
<pre><code>StringBuffer sb = new StringBuffer("Hello");
sb.append(" World"); // "Hello World"
sb.insert(5, " there"); // "Hello there World"
sb.delete(5, 11); // "Hello World"
sb.reverse(); // "dlroW olleH"
System.out.println(sb.toString()); // 输出 "dlroW olleH"
</code></pre> 
<p>请注意，StringBuffer 是Java 1.0 引入的，随着Java的发展，一些新的API和特性可能已经出现，但 StringBuffer 仍然是处理多线程字符串操作的可靠选择。</p> 
<hr> 
<p>StringBuilder 是Java中一个可变的字符串类，与 StringBuffer 类似，但它不是线程安全的。这意味着 StringBuilder 适合在单线程环境中使用，因为它的性能比 StringBuffer 更高，因为它没有同步的开销。<br> 以下是 StringBuilder 的一些主要特点和用法：</p> 
<ol><li><strong>非线程安全</strong>： StringBuilder 不包含同步机制，因此在单线程环境中使用时，性能优于 StringBuffer。</li><li><strong>可变字符串</strong>： StringBuilder 允许对字符串进行修改，包括插入、删除、替换和追加操作。</li><li><strong>容量自动增长</strong>： 与 StringBuffer 类似，StringBuilder 内部维护了一个字符数组，如果字符串增长超出当前容量，它会自动增长。</li><li><strong>常用方法</strong>： 
  <ul><li>append(Object obj)：将对象的字符串表示追加到 StringBuilder 的末尾。</li><li>insert(int index, Object obj)：在指定位置插入对象的字符串表示。</li><li>delete(int start, int end)：删除从 start 到 end - 1 之间的字符。</li><li>reverse()：反转 StringBuilder 中的字符顺序。</li><li>substring(int start) 和 substring(int start, int end)：返回 StringBuilder 的子字符串。</li><li>capacity()：返回当前分配给 StringBuilder 的容量。</li><li>ensureCapacity(int minimumCapacity)：确保 StringBuilder 的容量至少为指定的最小容量。</li><li>toString()：返回 StringBuilder 的当前字符串表示。</li></ul> </li><li><strong>性能考虑</strong>： 由于 StringBuilder 不是线程安全的，所以在多线程环境中使用时，需要额外的同步措施，或者考虑使用 StringBuffer。</li><li><strong>示例代码</strong>：</li></ol> 
<pre><code>StringBuilder sb = new StringBuilder("Hello");
sb.append(" World"); // "Hello World"
sb.insert(5, " there"); // "Hello there World"
sb.delete(5, 11); // "Hello World"
sb.reverse(); // "dlroW olleH"
System.out.println(sb.toString()); // 输出 "dlroW olleH"
</code></pre> 
<ol start="7"><li><strong>API 变更</strong>： StringBuilder 是Java 5引入的，它提供了与 StringBuffer 类似的API，但是没有同步机制。如果你的代码不需要线程安全，推荐使用 StringBuilder 来提高性能。</li></ol> 
<p>总<strong>结：在多线程环境时为确保安全使用StringBuffer方法，在单线程环境时使用StringBuilder。</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/21a537a90a030ef2ecc6555c1c24df55/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">在人工智能背景下，程序员要有什么职业素养，怎么改进</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4aed1d4c36cacdd3c0991113db3a4017/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【初阶数据结构】深入解析单链表:探索底层逻辑（无头单向非循环链表）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>