<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>排序算法详解 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/7e3a84d941262bf4197a4a0150821019/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="排序算法详解">
  <meta property="og:description" content="​
💎所属专栏：数据结构与算法学习 💎 欢迎大家互三：2的n次方_
🍁1. 插入排序 🍁1.1 直接插入排序 插入排序是一种简单直观的排序算法，它的原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
以从小到大排序为例
1.从第一个元素开始，可以看作是有序的元素
2.取出下一个元素，与前面已经排好序的元素比较，如果前面的元素大于此元素，就把前面的元素往后移，继续往前找，找到小于或等于的位置进行插入，直到找到最前面
​
public class InsertSort { public static void main(String[] args) { int[] arr = {5, 1, 2, 4, 3}; insertSort(arr); System.out.println(Arrays.toString(arr)); } public static void insertSort(int[] arr) { for (int i = 1; i &lt; arr.length; i&#43;&#43;) { int tmp = arr[i]; int j = i - 1; //比tmp大的元素往后移 for (; j &gt;= 0 &amp;&amp; arr[j] &gt; tmp; j--) { arr[j &#43; 1] = arr[j]; } arr[j &#43; 1] = tmp; } } } 🍁1.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-25T23:10:45+08:00">
    <meta property="article:modified_time" content="2024-07-25T23:10:45+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">排序算法详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div> 
 <blockquote> 
  <p><img alt="" height="417" src="https://images2.imgbox.com/ae/54/wSyjRXRV_o.gif" width="755">​</p> 
 </blockquote> 
</div> 
<p></p> 
<p style="text-align:center;"> 💎<strong>所属专栏：<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><a href="https://blog.csdn.net/2202_76097976?spm=1010.2135.3001.5343" title="数据结构与算法学习">数据结构与算法学习</a></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong> </strong></p> 
<p style="text-align:center;">💎 <strong>欢迎大家互三：<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><a href="https://blog.csdn.net/2202_76097976?spm=1010.2135.3001.5343" title="2的n次方_">2的n次方_</a></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p> 
<p class="img-center"><img alt="在这里插入图片描述" src="https://images2.imgbox.com/2b/67/pbidOiMw_o.gif"></p> 
<p> </p> 
<h2 style="background-color:transparent;">🍁<span style="color:#fe2c24;">1. 插入排序</span></h2> 
<h3>🍁<span style="color:#fe2c24;">1.1 直接插入排序</span></h3> 
<p>插入排序是一种简单直观的排序算法，它的原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p> 
<blockquote> 
 <p>以从小到大排序为例</p> 
 <p><strong><span style="color:#38d8f0;">1.从第一个元素开始，可以看作是有序的元素</span></strong></p> 
 <p><strong><span style="color:#38d8f0;">2.取出下一个元素，与前面已经排好序的元素比较，如果前面的元素大于此元素，就把前面的元素往后移，继续往前找，找到小于或等于的位置进行插入，直到找到最前面</span></strong></p> 
</blockquote> 
<div> 
 <p><img alt="" height="600" src="https://images2.imgbox.com/f7/51/Ilv8g8bH_o.gif" width="600">​</p> 
</div> 
<div> 
 <pre><code class="language-java">public class InsertSort {
    public static void main(String[] args) {
        int[] arr = {5, 1, 2, 4, 3};
        insertSort(arr);
        System.out.println(Arrays.toString(arr));
    }

    public static void insertSort(int[] arr) {
        for (int i = 1; i &lt; arr.length; i++) {
            int tmp = arr[i];
            int j = i - 1;
            //比tmp大的元素往后移
            for (; j &gt;= 0 &amp;&amp; arr[j] &gt; tmp; j--) {
                arr[j + 1] = arr[j];
            }
            arr[j + 1] = tmp;
        }
    }
}</code></pre> 
</div> 
<p></p> 
<p></p> 
<h3><span style="color:#fe2c24;">🍁1.2 希尔排序</span></h3> 
<p>希尔排序的基本思想是：</p> 
<p>先选定一个整数，把待排序的数据分为多个组，对每一个组内进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序。</p> 
<div> 
 <p><img alt="" height="600" src="https://images2.imgbox.com/56/b9/yre1DdvS_o.gif" width="1063">​</p> 
</div> 
<blockquote> 
 <p>假设有一个数组<code>arr = [9, 8, 3, 7, 5, 6, 4, 1]</code>，我们采用最简单的增量序列（每次减半）来进行希尔排序：</p> 
 <p><span style="color:#38d8f0;"><strong>1. 初始增量<code>d = 4</code>，将数组分为4组，每组进行插入排序：<code>[9, 7], [8, 5], [3, 6], [4, 1]</code></strong></span></p> 
 <p><span style="color:#38d8f0;"><strong>2. 增量<code>d = 2</code>，将数组分为2组，每组进行插入排序：<code>[7, 5, 6, 1], [9, 8, 3, 4]</code></strong></span></p> 
 <p><span style="color:#38d8f0;"><strong>3. 增量<code>d = 1</code>，整个数组作为一组进行插入排序，得到最终结果：<code>[1, 3, 4, 5, 6, 7, 8, 9]</code></strong></span></p> 
</blockquote> 
<div> 
 <pre><code class="language-java">    public static void shellSort(int[] arr) {
        int gap = arr.length;
        //增量每次减半
        while (gap &gt; 1) {
            gap /= 2;
            shell(arr, gap);
        }
    }

    private static void shell(int[] arr, int gap) {
        for (int i = gap; i &lt; arr.length; i++) {
            int tmp = arr[i];
            int j = i - gap;
            //比tmp大的元素往后移
            for (; j &gt;= 0 &amp;&amp; arr[j] &gt; tmp; j -= gap) {
                arr[j + gap] = arr[j];
            }
            arr[j + gap] = tmp;
        }
    }</code></pre> 
</div> 
<h2>🍁<span style="color:#fe2c24;">2. 选择排序</span></h2> 
<h3>🍁<span style="color:#fe2c24;">2.1 直接选择排序</span></h3> 
<p>直接选择排序的思想：</p> 
<p>每次从待排序的数据中选择一个最小（最大）的元素放在序列起始位置，直到整个序列元素排序完毕</p> 
<div> 
 <p><img alt="" height="418" src="https://images2.imgbox.com/81/af/tcCcIZxj_o.gif" width="817">​</p> 
</div> 
<div> 
 <pre><code class="language-java">    public static void selectSort(int[] arr) {
        for (int i = 0; i &lt; arr.length; i++) {
            int minIndex = i;
            for (int j = i + 1; j &lt; arr.length; j++) {
                if (arr[j] &lt; arr[minIndex]) {
                    minIndex = j;
                }
            }
            swap(arr, i, minIndex);
        }
    }</code></pre> 
</div> 
<h3>🍁<span style="color:#fe2c24;">2.2 堆排序</span></h3> 
<p>堆排序在上一节中已经有过介绍，这里再简单回顾下，还是<strong><span style="color:#38d8f0;">以从小到大排序为例，这时我们创建一个大根堆，堆顶元素也就是最大的，把最顶元素和堆尾元素进行交换，接着向下调整，再把堆顶元素和堆尾元素进行交换，也就是排在了上一个最大元素的前面，重复此过程，就实现了从小到大排序。</span></strong></p> 
<p> <a class="link-info" href="https://blog.csdn.net/2202_76097976/article/details/140558218" title="上一篇回顾">上一篇回顾</a></p> 
<div> 
 <pre><code class="language-java">    public static void heapSort(int[] arr) {
        createHeap(arr);
        int end = arr.length - 1;
        while (end &gt; 0) {
            //堆顶和end元素互换
            swap(arr, 0, end);
            //向下调整
            siftDown(arr, 0, end);
            end--;
        }
    }

    public static void createHeap(int[] arr) {
        for (int parent = (arr.length - 1 - 1) / 2; parent &gt;= 0; parent--) {
            siftDown(arr, parent, arr.length);
        }
    }

    private static void siftDown(int[] arr, int parent, int length) {
        int child = 2 * parent + 1;
        while (child &lt; length) {
            if (child + 1 &lt; length &amp;&amp; arr[child] &lt; arr[child + 1]) {
                child += 1;
            }
            if (arr[child] &gt; arr[parent]) {
                swap(arr, child, parent);
                child = 2 * child + 1;
            } else {
                break;
            }
        }
    }
</code></pre> 
</div> 
<p></p> 
<h2>🍁<span style="color:#fe2c24;">3. 交换排序</span></h2> 
<h3>🍁<span style="color:#fe2c24;">3.1 冒泡排序</span></h3> 
<p>冒泡排序是一种简单的排序算法，它重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。</p> 
<blockquote> 
 <p><strong><span style="color:#38d8f0;">比较每一对相邻的元素：如果第一个比第二个大（升序排序），就交换它们两个，这步做完后，最后的元素会是最大的数。</span></strong></p> 
 <p><strong><span style="color:#38d8f0;">持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</span></strong></p> 
</blockquote> 
<div> 
 <p><img alt="" height="418" src="https://images2.imgbox.com/7f/36/QsKpdi9O_o.gif" width="747">​</p> 
</div> 
<div> 
 <pre><code class="language-java">    public static void bubbleSort(int[] arr) {
        for (int i = 0; i &lt; arr.length - 1; i++) {
            boolean flag = false;
            for (int j = 0; j &lt; arr.length - 1 - i; j++) {
                if (arr[j] &gt; arr[j + 1]) {
                    swap(arr, j, j + 1);
                    flag = true;
                }
            }
            //如果这一趟没有交换任何一对元素，表示已经排好序了
            if(!flag){
                break;
            }
        }
    }</code></pre> 
</div> 
<p> 这里做了一个优化，<span style="background-color:#ffd900;">如果给出的数据只有一对数据不符合顺序，那么交换这对数据之后就不用再重复后续的程序了，所以直接结束循环即可，</span>在一些情况下，通过这种优化，冒泡排序的时间复杂度可以达到O(n)</p> 
<h3>🍁<span style="color:#fe2c24;">3.2 快速排序</span></h3> 
<p><strong><span style="color:#38d8f0;">首先把0索引的位置当作基准数，定义两个指针，先将右指针从数组末尾开始往前找，遇到比基准数小的停下来，左指针从1索引开始往后找，遇到比基准数大的停下来，交换左右指针的数，重复此过程，直到左右指针相遇，此时和基准数交换，就可以把基准数排到正确的位置，此时左边都是比基准数小的，右边都是比基准数大的，再依次递归基准数左边部分和右边部分，就实现了排序</span></strong></p> 
<p><span style="background-color:#ffd900;">注意：一定要先从右边开始找比基准数小的，先从左边开始就无法达到效果</span></p> 
<p></p> 
<div> 
 <p><img alt="" height="444" src="https://images2.imgbox.com/36/1b/rzCOgsml_o.gif" width="898">​</p> 
</div> 
<div> 
 <pre><code class="language-java">    public static void quickSort(int[] arr, int start, int end) {
        if (start &gt;= end) {
            return;
        }
        int mid = part(arr, start, end);
        quickSort(arr, start, mid - 1);
        quickSort(arr, mid + 1, end);
    }

    public static int part(int[] arr, int i, int j) {
        int tmp = arr[i];
        int tmpStart = i;
        while (i &lt; j) {
            while (i &lt; j &amp;&amp; arr[j] &gt;= tmp) {
                j--;
            }
            while (i &lt; j &amp;&amp; arr[i] &lt;= tmp) {
                i++;
            }
            swap(arr, i, j);
        }
        swap(arr, tmpStart, i);
        return i;
    }</code></pre> 
</div> 
<p> 关于基准数归位的过程还有一种优化的方法，由于上面使用了大量的交换，也会浪费一些时间</p> 
<div> 
 <pre><code class="language-java">    public static int part1(int[] arr, int i, int j) {
        int tmp = arr[i];
        while (i &lt; j) {
            while (i &lt; j &amp;&amp; arr[j] &gt;= tmp) {
                j--;
            }
            arr[i] = arr[j];
            while (i &lt; j &amp;&amp; arr[i] &lt;= tmp) {
                i++;
            }
            arr[j] = arr[i];
        }
        arr[i] = tmp;
        return i;
    }</code></pre> 
</div> 
<p>也就是先把基准数拿出来，这时就留出来一个空位，接着从右边找比基准数小的，填上空位，再从左边找比基准数大的，再填上右边的空位，以此类推</p> 
<p>还有一个优化的点是，<strong><span style="color:#fe2c24;">输入数组已经是有序（升序或降序）的，或者每次划分（partition）操作都选择到最小（或最大）的元素作为基准（pivot），导致每次划分只将一个元素移到它最终的位置上，而其他所有元素都留在原数组的另一侧。这种情况下，每次划分后的递归调用处理的子数组大小几乎相同，递归的深度接近n，导致总的比较和交换次数接近n^2。</span></strong></p> 
<p> 下面通过三数取中法来更换基准数进行优化</p> 
<div> 
 <pre><code class="language-java">    private static int getMid(int[] arr, int left, int right) {
        int mid = (left + right) / 2;
        if (arr[left] &gt; arr[right]) {
            if (arr[mid] &gt; arr[left]) {
                return left;
            } else if (arr[mid] &lt; arr[right]) {
                return right;
            } else {
                return mid;
            }
        } else {
            if (arr[mid] &gt; arr[right]) {
                return right;
            } else if (arr[mid] &lt; arr[left]) {
                return left;
            } else {
                return mid;
            }
        }
    }</code></pre> 
</div> 
<p> 获取中位数之后进行交换：</p> 
<p><img alt="" height="385" src="https://images2.imgbox.com/c5/9e/fPAxGXJR_o.png" width="771">​</p> 
<p> 另一个可以优化的是，由于快速排序的递归是一棵二叉树，每一层都是指数级的增长，所以最后两层会有很多递归需要走，但此时元素也趋于有序，就可以调用插入排序</p> 
<div> 
 <pre><code class="language-java">        if(end - start + 1 &lt;= 3){
            insertSort(arr,start,end);
            return;
        }</code></pre> 
</div> 
<p><strong>非递归实现</strong></p> 
<p>递归需要一直在栈上开辟空间，容易造成栈溢出，这里我们直接通过栈来进行非递归的实现</p> 
<div> 
 <pre><code class="language-java">    public static void yquickSort(int[] arr,int start,int end){
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        int pivot = part1(arr,start,end);
        if(pivot &gt; start + 1){
            stack.push(start);
            stack.push(pivot - 1);
        }
        if(pivot &lt; end - 1){
            stack.push(pivot + 1);
            stack.push(end);
        }
        while(!stack.isEmpty()){
            end = stack.pop();
            start = stack.pop();
            pivot = part1(arr,start,end);
            if(pivot &gt; start + 1){
                stack.push(start);
                stack.push(pivot - 1);
            }
            if(pivot &lt; end - 1){
                stack.push(pivot + 1);
                stack.push(end);
            }
        }
    }</code></pre> 
</div> 
<h2> 🍁<span style="color:#fe2c24;">4. 归并排序</span></h2> 
<p>归并排序主要利用了分治法，先使每个子序列有序，再使子序列段间有序，组后合并分解的子序列</p> 
<p></p> 
<div> 
 <p><img alt="" height="316" src="https://images2.imgbox.com/41/93/zbXH7BeS_o.png" width="552">​</p> 
</div> 
<p> 首先把要排序的数组依次分解，直到两两一组，之后开始合并，合并的过程也就是把两个有序数组再合并为一个有序数组的过程，每次取出两个数组的较小者存入合并的数组中，最终合并为一整个数组</p> 
<div> 
 <pre><code class="language-java">    public static void mergeSort(int[] arr, int left, int right) {
        if (left &gt;= right) return;
        int mid = (left + right) / 2;
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        merge(arr, left, mid, right);
    }
    
    //也就是合并两个有序数组
    public static void merge(int[] arr, int left, int mid, int right) {
        
        int[] tmp = new int[right - left + 1];
        int k = 0;
        int s1 = left;
        int s2 = mid + 1;
        //将分解后的两个数组每次取出最小值放在tmp数组中
        while (s1 &lt;= mid &amp;&amp; s2 &lt;= right) {
            if (arr[s1] &gt;= arr[s2]) {
                tmp[k++] = arr[s2++];
            } else {
                tmp[k++] = arr[s1++];
            }
        }
        while (s1 &lt;= mid) {
            tmp[k++] = arr[s1++];
        }
        while (s2 &lt;= right) {
            tmp[k++] = arr[s2++];
        }
        for (int i = 0; i &lt; k; i++) {
            arr[left + i] = tmp[i];
        }
    }</code></pre> 
</div> 
<p><strong> 非递归实现归并排序</strong></p> 
<p> 非递归实现也就是通过循环来模拟递归，依次合并数组，gap取</p> 
<div> 
 <pre><code class="language-java">    public static void mergeSortNor(int[] arr) {
        int gap = 1;
        while (gap &lt; arr.length) {
            for (int i = 0; i &lt; arr.length; i += gap * 2) {
                int left = i;
                int mid = i + gap - 1;
                if (mid &gt;= arr.length) {
                    mid = arr.length - 1;
                }
                int right = mid + gap;
                if (right &gt;= arr.length) {
                    right = arr.length - 1;
                }
                merge(arr, left, mid, right);
            }
            gap *= 2;
        }
    }</code></pre> 
</div> 
<h2 style="background-color:transparent;"><span style="color:#fe2c24;">🍁5. 计数排序</span></h2> 
<p>计数排序是一种基于非比较的排序算法，计数排序的主要特点是通过统计每个元素出现的次数，来确定每个元素在排序后数组中的位置，从而实现排序。</p> 
<div> 
 <p><img alt="" height="310" src="https://images2.imgbox.com/1b/45/rFr5IJAF_o.png" width="779">​</p> 
</div> 
<p> 计算出以上数据出现的次数之后，再根据次数进行遍历，就可以达到排序的效果</p> 
<div> 
 <pre><code class="language-java">    public static void countSort(int[] arr) {
        int maxVal = arr[0];
        int minVal = arr[0];
        //找到最大值和最小值
        for (int i = 0; i &lt; arr.length; i++) {
            if (arr[i] &gt; maxVal) {
                maxVal = arr[i];
            }
            if (arr[i] &lt; minVal) {
                minVal = arr[i];
            }
        }
        int[] tmp = new int[maxVal - minVal + 1];
        //开始计数
        for (int i = 0; i &lt; arr.length; i++) {
            tmp[arr[i] - minVal]++;
        }
        int index = 0;
        //将数据赋值给数组
        for (int i = 0; i &lt; tmp.length; i++) {
            while (tmp[i]-- != 0) {
                arr[index] = i + minVal;
                index++;
            }
        }
    }</code></pre> 
</div> 
<p class="img-center"><img alt="在这里插入图片描述" src="https://images2.imgbox.com/65/fc/u562a91n_o.gif"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/aa5ab8f3b74eed36a60bd6de76270dbe/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">决策树与随机森林：比较与应用场景分析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/04982abd284f415086e6081cdac08061/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2024华为数通HCIP-datacom最新题库（H12-831变题更新⑦）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>