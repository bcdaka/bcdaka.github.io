<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;】—— 类与对象（二） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/3b20e4c252f9439041b2d5c645eaa94b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;】—— 类与对象（二）">
  <meta property="og:description" content="【C&#43;&#43;】—— 类与对象（二） 1、类的默认成员函数2、构造函数2.1、初见构造2.2、深入构造2.3、初始化列表2.3.1、什么是初始化列表2.3.2、初始化列表和函数体关系2.3.3、必须使用初始化列表的情况2.3.3.1、 c o n s t const const 成员变量2.3.3.2、引用成员变量2.3.3.3、没有默认构造的类 2.3.4、变量声明时给缺省值（默认值）2.3.5、初始化列表初始化顺序2.3.6、总结2.3.6.1、构造函数特点总结2.3.6.1、初始化列表知识点总结2.3.6.2、初始化列表行为脉络 3、析构函数3.1、初见析构3.2、深入析构 1、类的默认成员函数 类的默认成员函数就是用户没有显式实现，编译器会自动生成的成员函数被称为默认成员函数。一个类，我们不写的情况下编译器会默认生成 6 个默认成员函数。
需要注意的是这 6 个最重要的默认成员函数是前 4 个，最后两个取地址重载不重要，我们稍微了解一下即可。
其次就是 C&#43;&#43;11 以后还会增加两个默认成员函数，移动构造和移动赋值，这个我们以后再讲解。
默认成员函数是学习 C&#43;&#43; 的基础，很重要，但也比较复杂，我们学习默认成员函数时要从以下两个方面取学习：
我们不写时，编译器默认生成的函数行为是什么，是否满足我们的需求编译器默认生成的 函数不满足我们的需求，我们需要自己实现，那么如何自己实现。 2、构造函数 2.1、初见构造 构造函数虽然名字叫构造，但它并不是用来开空间创建对象的。对象的空间在函数创建栈帧时就一次性开辟好了（不仅是对象，所有变量都是如此）。
构造函数的功能是对象实例化时初始化对象。构造函数的本质是要替代我们以前 S t a c k Stack Stack 和 D a t e Date Date 类中写的 I n i t Init Init 函数的功能，构造函数一系列的特点完美的替代了 Init
构造函数的特点：
函数名与类名相同无返回值（返回值啥都不需要给，也不需要写void）对象实例化时系统会自动调用对应的构造函数构造函数可以重载 我们来看日期类的构造函数
注：实际运行代码时全缺省的构造函数不能与无参的或带参的构造函数同时存在，并且全缺省的构造函数的功能已经包括了无参构造和带参构造，我们只需保留全缺省构造函数即可，这里只是为了演示。
可以看到，上述构造函数可以重载；函数名与类名相同；无返回值
构造函数的调用也与一般的函数调用不同，我们一起来看看：
int main() { Date d1; Date d2(2025, 1, 1); d1.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-03T10:50:47+08:00">
    <meta property="article:modified_time" content="2024-08-03T10:50:47+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;】—— 类与对象（二）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>【C++】—— 类与对象（二）</h4> 
 <ul><li><a href="#1_1" rel="nofollow">1、类的默认成员函数</a></li><li><a href="#2_16" rel="nofollow">2、构造函数</a></li><li><ul><li><a href="#21_17" rel="nofollow">2.1、初见构造</a></li><li><a href="#22_66" rel="nofollow">2.2、深入构造</a></li><li><a href="#23_195" rel="nofollow">2.3、初始化列表</a></li><li><ul><li><a href="#231_196" rel="nofollow">2.3.1、什么是初始化列表</a></li><li><a href="#232_211" rel="nofollow">2.3.2、初始化列表和函数体关系</a></li><li><a href="#233_261" rel="nofollow">2.3.3、必须使用初始化列表的情况</a></li><li><ul><li><a href="#2331const__266" rel="nofollow">2.3.3.1、<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
           
            
             
             
               c 
              
             
               o 
              
             
               n 
              
             
               s 
              
             
               t 
              
             
            
              const 
             
            
          </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6151em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span></span> 成员变量</a></li><li><a href="#2332_293" rel="nofollow">2.3.3.2、引用成员变量</a></li><li><a href="#2333_350" rel="nofollow">2.3.3.3、没有默认构造的类</a></li></ul> 
    </li><li><a href="#234_392" rel="nofollow">2.3.4、变量声明时给缺省值（默认值）</a></li><li><a href="#235_466" rel="nofollow">2.3.5、初始化列表初始化顺序</a></li><li><a href="#236_511" rel="nofollow">2.3.6、总结</a></li><li><ul><li><a href="#2361_513" rel="nofollow">2.3.6.1、构造函数特点总结</a></li><li><a href="#2361_529" rel="nofollow">2.3.6.1、初始化列表知识点总结</a></li><li><a href="#2362_539" rel="nofollow">2.3.6.2、初始化列表行为脉络</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#3_553" rel="nofollow">3、析构函数</a></li><li><ul><li><a href="#31_555" rel="nofollow">3.1、初见析构</a></li><li><a href="#32_586" rel="nofollow">3.2、深入析构</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="1_1"></a>1、类的默认成员函数</h2> 
<p>  类的默认成员函数就是<code>用户没有显式实现，编译器会自动生成</code>的成员函数被称为<mark>默认成员函数</mark>。一个类，我们不写的情况下编译器会默认生成 <strong>6</strong> 个默认成员函数。<br>   需要注意的是这 <strong>6</strong> 个最重要的默认成员函数是前 <strong>4</strong> 个，最后两个取地址重载不重要，我们稍微了解一下即可。<br>   其次就是 C++11 以后还会增加两个默认成员函数，<strong>移动构造</strong>和<strong>移动赋值</strong>，这个我们以后再讲解。<br>   <br>   默认成员函数是学习 C++ 的基础，很重要，但也比较复杂，我们学习默认成员函数时要从以下两个方面取学习：</p> 
<blockquote> 
 <ul><li>我们不写时，编译器默认生成的函数行为是什么，是否满足我们的需求</li><li>编译器默认生成的 函数不满足我们的需求，我们需要自己实现，那么如何自己实现。</li></ul> 
</blockquote> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/b5/7f/zS41qTJx_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>  </p> 
<h2><a id="2_16"></a>2、构造函数</h2> 
<h3><a id="21_17"></a>2.1、初见构造</h3> 
<p>  构造函数虽然名字叫构造，但它并不是用来开空间创建对象的。<code>对象的空间在函数创建栈帧时就一次性开辟好了</code>（不仅是对象，所有变量都是如此）。<br>   构造函数的功能是<mark>对象实例化时初始化对象</mark>。构造函数的本质是要替代我们以前 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         S 
        
       
         t 
        
       
         a 
        
       
         c 
        
       
         k 
        
       
      
        Stack 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">St</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span></span></span></span></span> 和 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         D 
        
       
         a 
        
       
         t 
        
       
         e 
        
       
      
        Date 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span></span></span></span></span> 类中写的 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         I 
        
       
         n 
        
       
         i 
        
       
         t 
        
       
      
        Init 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0785em;">I</span><span class="mord mathnormal">ni</span><span class="mord mathnormal">t</span></span></span></span></span> 函数的功能，构造函数一系列的特点<code>完美的替代了 Init</code><br>   <br> <strong>构造函数的特点：</strong></p> 
<blockquote> 
 <ol><li><mark>函数名与类名相同</mark></li><li><mark>无返回值</mark>（返回值啥都不需要给，也不需要写void）</li><li><mark>对象实例化时系统会自动调用对应的构造函数</mark></li><li><mark>构造函数可以重载</mark></li></ol> 
</blockquote> 
<p>  <br> 我们来看日期类的构造函数</p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/d8/6d/WJdgANgW_o.png" alt="在这里插入图片描述"><br>   <font color="red">注</font>：实际运行代码时全缺省的构造函数不能与无参的或带参的构造函数同时存在，并且全缺省的构造函数的功能已经包括了无参构造和带参构造，我们只需保留全缺省构造函数即可，这里只是为了演示。</p> 
</blockquote> 
<p>  可以看到，上述构造函数<code>可以重载</code>；<code>函数名与类名相同</code>；<code>无返回值</code></p> 
<p>  构造函数的调用也与一般的函数调用不同，我们一起来看看：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Date d1<span class="token punctuation">;</span> 
	Date <span class="token function">d2</span><span class="token punctuation">(</span><span class="token number">2025</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
	
	d1<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	d2<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>运行结果：</strong></p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/52/9e/O7vmfUev_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>  可以看到，我们并没有显式去调用构造函数，而两个对象 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         d 
        
       
         1 
        
       
      
        d1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">d</span><span class="mord">1</span></span></span></span></span> 和 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         d 
        
       
         2 
        
       
      
        d2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">d</span><span class="mord">2</span></span></span></span></span> 的初始化已经完成了，可见：<mark>对象定义(实例化)时系统会 <font color="red">自动调用</font> 对应的构造函数</mark><br>   <br> 在对象实例化时：</p> 
<blockquote> 
 <ul><li>若调用的构造函数 <strong>需要传参</strong>，则在<mark>对象名后面传递参数</mark>，如： <code>Date d2(2025, 1, 1);</code></li><li>若需要调用的构造函数 <strong>无需传参</strong>，应写成<code>Date d1;</code> 的形式（以 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           D 
          
         
           a 
          
         
           t 
          
         
           e 
          
         
        
          Date 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span></span></span></span></span> 类为例），不能写成<code>Date d1();</code>，因为这样与函数声明无法区分。</li></ul> 
</blockquote> 
<p>  </p> 
<h3><a id="22_66"></a>2.2、深入构造</h3> 
<p><strong>构造函数的进阶特点：</strong></p> 
<blockquote> 
 <ol start="5"><li>如果类中<strong>没有显式定义构造函数</strong>，则 C++ 编译器会<mark>自动生成</mark>一个<strong>无参</strong>的默认构造函数，一旦用户显式定义编译器将不再生成<br>   </li><li><font color="red">无参构造函数</font>、 <font color="red">全缺省构造函数</font>、 <font color="red">我们不写构造时编译器默认生成的构造函数</font>，都叫做 <font color="red"><strong>默认构造函数</strong></font> 
   <ul><li>这三个函数<code>有且只有一个存在</code>，不能同时存在 。因为他们都可以不传参数，会造成调用歧义</li><li>有很多小伙伴以为默认构造函数是编译器默认生成的那个构造函数，但实际上无参构造函数、全缺省构造函数也是默认构造函数</li><li>总结下来就是==<font color="red">不传实参</font> 就可以调用的构造就叫 <font color="red">默认构造</font>==<br>   </li></ul> </li><li>我们不写，编译器默认生成的构造，对<code>内置类型</code>成员变量的初始化<code>没有要求</code>，也就是说是否初始化内置类型成员时<mark>不确定</mark>的，看编译器。<br>   </li><li>对于<code>自定义类型</code>成员变量，要求<mark>调用这个成员变量的 <font color="red">默认构造函数</font> 来初始化</mark>，如果这个成员变量<code>没有默认构造函数</code>，程序会<mark>报错</mark>。这时，我们要初始化这个变量，需要用<font color="red">初始化列表</font>才能解决，这点我们等下再学习</li></ol> 
</blockquote> 
<p>  <br>   我们来看看我们不写构造函数时，编译器<code>自动生成的默认构造</code>对<strong>内置类型</strong>和<strong>自定义类型</strong>的成员变量的处理</p> 
<p>我们来看下面一段代码：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		_a <span class="token operator">=</span> a<span class="token punctuation">;</span>
		_b <span class="token operator">=</span> b<span class="token punctuation">;</span>
		_c <span class="token operator">=</span> c<span class="token punctuation">;</span>

		<span class="token comment">//打印，看该默认构造是否被调用</span>
		cout <span class="token operator">&lt;&lt;</span> _a <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> _b <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> _c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _a<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _b<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _c<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Date</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> _year <span class="token operator">&lt;&lt;</span> <span class="token string">"/"</span> <span class="token operator">&lt;&lt;</span> _month <span class="token operator">&lt;&lt;</span> <span class="token string">"/"</span> <span class="token operator">&lt;&lt;</span> _day <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _year<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _month<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _day<span class="token punctuation">;</span>
	A _a<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Date d1<span class="token punctuation">;</span>
	d1<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  <br> <strong>运行结果：</strong></p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/98/a3/fZaMszBs_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>  在 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         D 
        
       
         a 
        
       
         t 
        
       
         e 
        
       
      
        Date 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span></span></span></span></span> 类中，有 4 个成员变量：_<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         y 
        
       
         e 
        
       
         a 
        
       
         r 
        
       
      
        year 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">ye</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span></span></span></span></span>；_<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         m 
        
       
         o 
        
       
         n 
        
       
         t 
        
       
         h 
        
       
      
        month 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span></span></span></span></span>；_<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         d 
        
       
         a 
        
       
         y 
        
       
      
        day 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span></span></span></span></span>；_<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         a 
        
       
      
        a 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span></span>，前三个是<strong>内置类型</strong>，最后一个<strong>自定义类型</strong>。<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         D 
        
       
         a 
        
       
         t 
        
       
         e 
        
       
      
        Date 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span></span></span></span></span> 类中并没有写构造函数。</p> 
<blockquote> 
 <ul><li>系统自动生成默认构造函数并<mark>没有对<font color="red">内置类型</font>成员变量初始化</mark>（有些编译器会初始化成 0，看具体编译器）</li><li>但是对于<mark>自定义类型</mark> A 类，系统<code>调用了A类中的默认构造函数</code>，完成了对 _a 自定义类型成员变量的初始化</li></ul> 
</blockquote> 
<p>  而如果 <mark><font color="red">自定义类型</font>没有默认构造函数</mark>，系统就会<code>报错</code><br> <strong>如：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		_a <span class="token operator">=</span> a<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _a<span class="token punctuation">;</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Date</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> _year <span class="token operator">&lt;&lt;</span> <span class="token string">"/"</span> <span class="token operator">&lt;&lt;</span> _month <span class="token operator">&lt;&lt;</span> <span class="token string">"/"</span> <span class="token operator">&lt;&lt;</span> _day <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _year<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _month<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _day<span class="token punctuation">;</span>
	A _a<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Date d1<span class="token punctuation">;</span>
	d1<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/70/94/JHCdWRhR_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>  上述代码，A类中写了<code>需要传递实参的构造函数</code>，它不属于无参和全实参构造；同时，因为写了构造函数，编译器也不会自动生成，因此A类中是<mark>没有默认构造函数</mark>的。<br>   </p> 
<p>回到文章开头的那两个问题：</p> 
<blockquote> 
 <ul><li>我们不写时，编译器默认生成的函数行为是什么，是否满足我们的需求</li><li>编译器默认生成的 函数不满足我们的需求，我们需要自己实现，那么如何自己实现。</li></ul> 
</blockquote> 
<p>  总结：</p> 
<blockquote> 
 <ul><li>对<mark>内置类型</mark>，编译器自动生成的默认构造大多数情况时<code>不满足</code>我们的使用需求的。</li><li>对<mark>自定义类型</mark>，编译器自动生成的默认构造会<code>自动调用该自定义类型的默认构造</code>，从而完成对自定义类型的初始化。当然如果该自定义类型<code>没有默认构造</code>，编译器会<code>报错</code></li></ul> 
</blockquote> 
<p>  <mark><strong><font color="red">构造函数应写尽写！</font></strong></mark><br>   </p> 
<h3><a id="23_195"></a>2.3、初始化列表</h3> 
<h4><a id="231_196"></a>2.3.1、什么是初始化列表</h4> 
<p>  前面我们写的构造函数，虽然在调用之后，对象中有了初始值，但是它并不能称为是对对象中成员变量的初始化；构造函数体中的语句我们只能将其称为<mark>赋初值</mark>，而<code>不能称作是初始化</code>。因为初始化<strong>只能初始化一次</strong>，而构造函数体内可以<strong>多次赋值</strong>。</p> 
<p>  构造函数初始化的方式是 <mark><font color="red">初始化列表</font></mark>，初始化列表的使用方式是：以一个<code>冒号开始</code>，接着是一个<code>以逗号分隔</code>的数据或成员列表，每个成员变量后面跟一个放在<code>括号中</code>的<code>初始值或表达式</code>。</p> 
<p>  既然是<mark>定义初始化</mark>，那就只能<font color="red">初始化一次</font>，因此<code>每个成员变量在初始化列表中只能出现一次</code></p> 
<p>  <mark>尽量使用初始化列表初始化</mark>，因为初始化列表是<mark>定义的地方</mark>，所以即使是不在初始化列表初始化的成员<code>也会走一遍初始化列表</code>。对于没有显示在初始化列表初始化的<code>内置类型</code>成员是否初始化<code>取决于编译器</code>；对于没有显示在初始化列表初始化的<code>自定义类型</code>成员<code>编译器会调用这个成员类型的默认构造函数</code>，如果没有默认构造会编译错误。</p> 
<p>  单看文字，相信大家对什么定义初始化；什么赋值；初始化列表的使用方式一脸懵逼。没关系，我们直接上代码</p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/28/ff/7GZQIvEK_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>  </p> 
<h4><a id="232_211"></a>2.3.2、初始化列表和函数体关系</h4> 
<p>  既然初始化列表是 <mark><font color="red">变量的初始化</font></mark>，那之前学习的写在函数体中的代码是什么呢？是 <mark><font color="red">赋值</font></mark>，相当于给成员变量的赋值。</p> 
<p>  初始化列表和函数体可以<mark>混合使用</mark><br> <strong>如：</strong></p> 
<pre><code class="prism language-cpp"><span class="token function">Date</span><span class="token punctuation">(</span><span class="token keyword">int</span> year <span class="token operator">=</span> <span class="token number">2000</span><span class="token punctuation">,</span> <span class="token keyword">int</span> month <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">int</span> day <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token operator">:</span><span class="token function">_year</span><span class="token punctuation">(</span>year <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span>
	<span class="token punctuation">,</span><span class="token function">_month</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	_day <span class="token operator">=</span> day<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>运行结果：</strong></p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/14/1c/hlPhJOmQ_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p><font color="red">注</font>：成员变量后面的括号可以是<code>初始值</code>或<code>表达式</code>，不一定要形参<br>   <br>   编译器会<code>先</code>执行<code>初始化列表</code>，<code>再</code>执行<code>函数体</code>中代码（先初始化才能赋值对吧）</p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/d9/f7/FVdxkFVv_o.gif" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>  虽然动图中，在初始化列表代码并没有执行 _<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         d 
        
       
         a 
        
       
         y 
        
       
      
        day 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span></span></span></span></span>，但实际上 <mark>_<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          d 
         
        
          a 
         
        
          y 
         
        
       
         day 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span></span></span></span></span> 是被<strong>隐式执行</strong>了</mark>，只是并没有被初始化，为随机值。初始化列表是定义的地方，_<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         d 
        
       
         a 
        
       
         y 
        
       
      
        day 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span></span></span></span></span> 不再初始化列表定义又在哪定义呢。<br>   <br>   函数体可以做到初始化列表做不到的功能，有时需要他们<mark>配合使用</mark><br> <strong>如：</strong></p> 
<pre><code class="prism language-cpp">	<span class="token function">Date</span><span class="token punctuation">(</span><span class="token keyword">int</span> year <span class="token operator">=</span> <span class="token number">2000</span><span class="token punctuation">,</span> <span class="token keyword">int</span> month <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">int</span> day <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_year</span><span class="token punctuation">(</span>year<span class="token punctuation">)</span>
		<span class="token punctuation">,</span><span class="token function">_month</span><span class="token punctuation">(</span>month<span class="token punctuation">)</span>
		<span class="token punctuation">,</span><span class="token function">_day</span><span class="token punctuation">(</span>day<span class="token punctuation">)</span>
		<span class="token punctuation">,</span><span class="token function">_ptr</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">nullptr</span> <span class="token operator">==</span> _ptr<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"malloc fail"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">memset</span><span class="token punctuation">(</span>_ptr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p>  </p> 
<h4><a id="233_261"></a>2.3.3、必须使用初始化列表的情况</h4> 
<p>  <mark><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          c 
         
        
          o 
         
        
          n 
         
        
          s 
         
        
          t 
         
        
       
         const 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6151em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span></span> 成员变量</mark>；<mark>引用成员变量</mark>；<mark>没有默认构造的类类型变量</mark>，<code>必须放在初始化列表位置进行初始化</code>，否则会编译报错</p> 
<p>  为什么呢？我们一起来看看</p> 
<h5><a id="2331const__266"></a>2.3.3.1、<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         c 
        
       
         o 
        
       
         n 
        
       
         s 
        
       
         t 
        
       
      
        const 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6151em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span></span> 成员变量</h5> 
<p>  我们先来看下面这代码是否可行</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>
	a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  是不行的，因为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         c 
        
       
         o 
        
       
         n 
        
       
         s 
        
       
         t 
        
       
      
        const 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6151em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span></span> 修饰的变量<code>必须进行初始化</code>，且初始化后<code>值不能再改变</code></p> 
<p>  因此 <mark><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          c 
         
        
          o 
         
        
          n 
         
        
          s 
         
        
          t 
         
        
       
         const 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6151em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span></span> 修饰的变量需在初始化列表中定义初始化</mark></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_a</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> _a<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>  </p> 
<h5><a id="2332_293"></a>2.3.3.2、引用成员变量</h5> 
<p>  引用成员变量的原因与 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         c 
        
       
         o 
        
       
         n 
        
       
         s 
        
       
         t 
        
       
      
        const 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6151em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span></span> 的类似<br>   <mark>引用在定义时必须初始化</mark></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> xx<span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_x</span><span class="token punctuation">(</span>xx<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span><span class="token operator">&amp;</span> _x<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>我们可以看到一个有意思的情况：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> rx<span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_rx</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

	<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token operator">++</span>_rx<span class="token punctuation">;</span>
		<span class="token operator">++</span>_rx<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span><span class="token operator">&amp;</span> _rx<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	A <span class="token function">a</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	a<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>运行结果：</strong></p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/91/04/lYjdY0BL_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>  可以看到，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
      
        n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span> 是变了<br>   为什么呢？</p> 
<blockquote> 
 <ul><li>把 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           n 
          
         
        
          n 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span> 传给rx，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           r 
          
         
           x 
          
         
        
          rx 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord mathnormal">x</span></span></span></span></span> 是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           n 
          
         
        
          n 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span> 的别名，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           r 
          
         
           x 
          
         
        
          rx 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord mathnormal">x</span></span></span></span></span> 就是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           n 
          
         
        
          n 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>，而 _<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           r 
          
         
           x 
          
         
        
          rx 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord mathnormal">x</span></span></span></span></span> 又是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           r 
          
         
           x 
          
         
        
          rx 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord mathnormal">x</span></span></span></span></span> 的别 名，这样 <mark>_<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            r 
           
          
            x 
           
          
         
           rx 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord mathnormal">x</span></span></span></span></span> 就是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            n 
           
          
         
           n 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span> 的别名，_<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            r 
           
          
            x 
           
          
         
           rx 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord mathnormal">x</span></span></span></span></span> 就是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            n 
           
          
         
           n 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span></mark>。在类中对_<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           r 
          
         
           x 
          
         
        
          rx 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord mathnormal">x</span></span></span></span></span> 的改变，类外的 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           n 
          
         
        
          n 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span> 自然也就跟着改变啦</li></ul> 
</blockquote> 
<p>  当你想在对象中发生了某个行为，外面的变量 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
      
        n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span> 就跟着变，就能这样使用</p> 
<p>  </p> 
<h5><a id="2333_350"></a>2.3.3.3、没有默认构造的类</h5> 
<p>  我们知道，对于自定义类型，我们不写，编译器会<code>自动调其默认构造函数</code>，如果其没有默认构造函数，则<code>报错</code>。</p> 
<p>那对于没有默认构造函数的类型又该怎么办呢？</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Time</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span> <span class="token operator">:</span>
	<span class="token function">Time</span><span class="token punctuation">(</span><span class="token keyword">int</span> hour<span class="token punctuation">)</span>
		<span class="token operator">:</span> <span class="token function">_hour</span><span class="token punctuation">(</span>hour<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Time()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _hour<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Date</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _year<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _month<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _day<span class="token punctuation">;</span>
	Time _t<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>这时候就需要<mark>在初始化列表中自己传参数</mark>了</p> 
<pre><code class="prism language-cpp">	<span class="token function">Date</span><span class="token punctuation">(</span><span class="token keyword">int</span> year <span class="token operator">=</span> <span class="token number">2000</span><span class="token punctuation">,</span> <span class="token keyword">int</span> month <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">int</span> day <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_year</span><span class="token punctuation">(</span>year<span class="token punctuation">)</span>
		<span class="token punctuation">,</span><span class="token function">_month</span><span class="token punctuation">(</span>month<span class="token punctuation">)</span>
		<span class="token punctuation">,</span><span class="token function">_day</span><span class="token punctuation">(</span>day<span class="token punctuation">)</span>
		<span class="token punctuation">,</span><span class="token function">_t</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre> 
<p>当然，如果是<code>全缺省默认构造也可以这么给值</code>。</p> 
<p>  </p> 
<h4><a id="234_392"></a>2.3.4、变量声明时给缺省值（默认值）</h4> 
<p>  C++11 支持在 <mark><font color="red">声明的位置</font></mark> 给 <mark>缺省值(默认值)</mark>，这个缺省值主要是给 <mark><strong>没有显式在初始化列表初始化的成员用的</strong></mark></p> 
<p><strong>如：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Date</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">Date</span><span class="token punctuation">(</span><span class="token keyword">int</span> year <span class="token operator">=</span> <span class="token number">2000</span><span class="token punctuation">,</span> <span class="token keyword">int</span> month <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">int</span> day <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_year</span><span class="token punctuation">(</span>year<span class="token punctuation">)</span>
		<span class="token punctuation">,</span><span class="token function">_month</span><span class="token punctuation">(</span>month<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token comment">//C++11</span>
	<span class="token comment">//声明, 给缺省值</span>
	<span class="token keyword">int</span> _year <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> _month <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> _day <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Date <span class="token function">d</span><span class="token punctuation">(</span><span class="token number">2024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>运行结果：</strong></p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/97/e2/IX8iUGYz_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>  为什么是这个结果呢？先别急</p> 
<p>  我们 先来思考这样写 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         p 
        
       
         r 
        
       
         i 
        
       
         v 
        
       
         a 
        
       
         t 
        
       
         e 
        
       
      
        private 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right: 0.0359em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span></span></span></span></span> 的内容是定义吗？<br>   它<mark>还是<font color="red">声明</font></mark>，不是定义。<br>   定义的特点是木已成舟，<code>已经把空间开出来</code>了；而声明是<code>告知</code>你有这个东西<code>存在</code></p> 
<blockquote> 
 <ul><li>如果成员在初始化列表中<code>没有显式示初始化</code>，则用<mark>声明时给的缺省值</mark>对其进行初始化；如果在初始化列表中<code>显式初始化</code>，这用成员变量后边<code>()</code>中的<code>表达式</code>对其进行<code>初始化</code></li></ul> 
</blockquote> 
<p>  <br>   现在，我们再看为什么是这个结果：</p> 
<blockquote> 
 <ul><li>首先是 <mark>_<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            y 
           
          
            e 
           
          
            a 
           
          
            r 
           
          
         
           year 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">ye</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span></span></span></span></span></mark>：这里直接传实参 2024，这个没有问题</li><li>后是 <mark>_<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            m 
           
          
            o 
           
          
            n 
           
          
            t 
           
          
            h 
           
          
         
           month 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span></span></span></span></span></mark>：_<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           m 
          
         
           o 
          
         
           n 
          
         
           t 
          
         
           h 
          
         
        
          month 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span></span></span></span></span> 在初始化列表中<code>显示初始化</code>，所以<code>没有声明时给的缺省值什么事</code>。因为没传参数，这里 _<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           m 
          
         
           o 
          
         
           n 
          
         
           t 
          
         
           h 
          
         
        
          month 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span></span></span></span></span> 的值是形参中的缺省值 <code>1</code></li><li>最后来看 <mark>_<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            d 
           
          
            a 
           
          
            y 
           
          
         
           day 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span></span></span></span></span></mark>： 
   <ul><li>_<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             d 
            
           
             a 
            
           
             y 
            
           
          
            day 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span></span></span></span></span> 并<code>没有在初始化列表中显示初始化</code>，因此<code>用声明时给的缺省值初始化</code>。</li><li>这里别看函数形参 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             d 
            
           
             a 
            
           
             y 
            
           
          
            day 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span></span></span></span></span> 有个缺省值 1 就以为初始化为 1，函数中并没有使用 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             d 
            
           
             a 
            
           
             y 
            
           
          
            day 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span></span></span></span></span> 这个形参。我多设置几个形参怎么了嘛，而且 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             d 
            
           
             a 
            
           
             y 
            
           
          
            day 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span></span></span></span></span> 只是形参名，与成员变量 _<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             d 
            
           
             a 
            
           
             y 
            
           
          
            day 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span></span></span></span></span> 并没有关系，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             d 
            
           
             a 
            
           
             y 
            
           
          
            day 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span></span></span></span></span> 也可以叫其他名。</li><li>即使形参 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             d 
            
           
             a 
            
           
             y 
            
           
          
            day 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span></span></span></span></span> 给上实参，初始化的值依然是声明时的缺省值，因为初始化列表中没有显式示初始化</li></ul> </li></ul> 
</blockquote> 
<p>  缺省值不仅仅可以是一个数值，它还可以是<code>表达式</code></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Date</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">Date</span><span class="token punctuation">(</span><span class="token keyword">int</span> year <span class="token operator">=</span> <span class="token number">2000</span><span class="token punctuation">,</span> <span class="token keyword">int</span> month <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">int</span> day <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_year</span><span class="token punctuation">(</span>year<span class="token punctuation">)</span>
		<span class="token punctuation">,</span><span class="token function">_month</span><span class="token punctuation">(</span>month<span class="token punctuation">)</span>
		<span class="token punctuation">,</span><span class="token function">_day</span><span class="token punctuation">(</span>day<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _year <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> _month <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> _day <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

	<span class="token keyword">int</span><span class="token operator">*</span> _ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Time _t <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//Time是一个类，前文有提到，这里不再赘述</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>  相当于只要初始化列表成员变量后面<code>()</code>中允许的，声明时给的缺省值也允许、</p> 
<p>  </p> 
<h4><a id="235_466"></a>2.3.5、初始化列表初始化顺序</h4> 
<p>  我们先看下面代码的运行结果是什么</p> 
<blockquote> 
 <p>A.输出 1 1      B.输出 2 2   C.编译报错<br> D.输出 1 随机值   E.输出 1 2    F.输出 2 1</p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span> <span class="token operator">:</span>
	<span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span>
		<span class="token operator">:</span> <span class="token function">_a1</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_a2</span><span class="token punctuation">(</span>_a1<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> _a1 <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> _a2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _a2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> _a1 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	A <span class="token function">aa</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	aa<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>答案：<font color="red"><strong>D</strong></font></p> 
<p>为什么呢？<br> 我们先来看个小知识点</p> 
<blockquote> 
 <ul><li>初始化列表中<mark>按照成员变量在类中<font color="red">声明顺序</font>进行初始化</mark>，跟成员在初始化列表出现的先后顺序无关。因此建议声明顺序和初始化顺序保持一致</li></ul> 
</blockquote> 
<p>  上述代码中：<mark>先初始化的是 <font color="red">_<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           a 
          
         
           2 
          
         
        
          a2 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord mathnormal">a</span><span class="mord">2</span></span></span></span></span></font></mark>，_<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         a 
        
       
         2 
        
       
      
        a2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord mathnormal">a</span><span class="mord">2</span></span></span></span></span> 用 _<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         a 
        
       
         1 
        
       
      
        a1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord mathnormal">a</span><span class="mord">1</span></span></span></span></span> 来定义初始化，那此时的 _<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         a 
        
       
         1 
        
       
      
        a1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord mathnormal">a</span><span class="mord">1</span></span></span></span></span> 是什么情况呢？<br>   这里，<code>在建立函数栈帧时，整个对象的空间就已经开好了</code>，用 _<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         a 
        
       
         1 
        
       
      
        a1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord mathnormal">a</span><span class="mord">1</span></span></span></span></span> 去初始化<mark>并不会出现什么语法错误</mark><br>   因为此时的 _<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         a 
        
       
         1 
        
       
      
        a1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord mathnormal">a</span><span class="mord">1</span></span></span></span></span> 还是随机值，所以 _<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         a 
        
       
         2 
        
       
      
        a2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord mathnormal">a</span><span class="mord">2</span></span></span></span></span> <code>初始化后还是随机值</code><br>   再之后是 _<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         a 
        
       
         1 
        
       
      
        a1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord mathnormal">a</span><span class="mord">1</span></span></span></span></span> 的初始化，初始化为 1 ，这点相信大家没什么问题。</p> 
<p>  为什么初始化列表的初始化顺序是按声明的顺序走呢？<br>   因为声明中的顺序其实是<mark>内存中成员变量存放的顺序</mark>，编译器这么做也是合理的<br>   </p> 
<h4><a id="236_511"></a>2.3.6、总结</h4> 
<h5><a id="2361_513"></a>2.3.6.1、构造函数特点总结</h5> 
<blockquote> 
 <ul><li><mark>函数名与类名相同</mark></li><li><mark>无返回值</mark>（返回值啥都不需要给，也不需要写void）</li><li>对象实例化时系统会<mark>自动调用</mark>对应的构造函数</li><li>构造函数<mark>可以重载</mark></li><li>如果类中没有显式定义构造函数，则 C++ 编译器会<mark>自动生成</mark>一个<code>无参的默认构造函数</code>，一旦用户显式定义编译器将不再生成<br>   </li><li><code>无参构造函数</code>、<code>全缺省构造函数</code>、<code>我们不写编译器默认生成的构造函数</code>，都叫做<mark>默认构造函数</mark>。但是这三个函数<mark>有且只有一个存在</mark>，不能同时存在。无参构造函数和全缺省构造函数虽然构成函数重载，但是调用时会存在歧义。要注意很多小伙伴会认为默认构造函数是编译器默认生成的那个叫默认构造，实际上无参构造函数、全缺省构造函数也是默认构造，总结一下就是<mark>不传实参就可以调用的构造就叫默认构造</mark><br>   </li><li>我们不写，编译器默认生成的构造，对<code>内置类型</code>成员变量的初始化<mark>没有要求</mark>，也就是说是否初始化是不确定的，看编译器。对于<code>自定义类型</code>成员变量，要求<mark>调用这个成员变量的默认构造函数初始化</mark>。如果这个成员变量没有默认构造函数，那么就会<code>报错</code>，我们要初始化这个成员变量，需要用<mark>初始化列表</mark>才能<mark>解决</mark></li></ul> 
 <p>  <br> 说明：C++ 把类型分成<code>内置类型</code>(基本类型)和<code>⾃定义类型</code>。内置类型就是语⾔提供的原⽣数据型，如：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          i 
         
        
          n 
         
        
          t 
         
        
       
         int 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6595em;"></span><span class="mord mathnormal">in</span><span class="mord mathnormal">t</span></span></span></span></span> / <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          c 
         
        
          h 
         
        
          a 
         
        
          r 
         
        
       
         char 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">ha</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span></span></span></span></span> /<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          d 
         
        
          o 
         
        
          u 
         
        
          b 
         
        
          l 
         
        
          e 
         
        
       
         double 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">e</span></span></span></span></span> /指针等，⾃定义类型就是我们使⽤ <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          c 
         
        
          l 
         
        
          a 
         
        
          s 
         
        
          s 
         
        
       
         class 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal">ss</span></span></span></span></span> / <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          s 
         
        
          t 
         
        
          r 
         
        
          u 
         
        
          c 
         
        
          t 
         
        
       
         struct 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6151em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span></span></span></span></span> 等关键字⾃⼰定义的类型。</p> 
</blockquote> 
<p>  </p> 
<h5><a id="2361_529"></a>2.3.6.1、初始化列表知识点总结</h5> 
<blockquote> 
 <p>初始化列表的使用方式是以一个<mark>冒号开始</mark>，接着是一个以<mark>逗号分隔</mark>的数据成员列表，每个“成员变量”后面<mark>跟着一个放在括号中的初始值或表达式</mark></p> 
 <ul><li>每个成员变量在初始化列表中<mark>只能出现一次</mark>，语法理解上初始化列表可以认为是每个成员变量 <mark><font color="red">定义初始化</font></mark> 的地方</li><li>引<code>用成员变量</code>、<code>const成员变量</code>，<code>没有默认构造的类类型变量</code>，<mark>必须</mark>放在<mark>初始化列表</mark>位置进行初始化，否则会编译报错</li><li>C++11 支持在成员变量<mark>声明的位置给缺省值</mark>，这个缺省值主要是<mark>给没有显式在初始化列表初始化的成员使用的</mark></li><li><mark>尽量使用初始化列表初始化</mark>，因为那些你不在初始化列表初始化的成员<mark>也会走初始化列表</mark>，如果这个成员在声明位置<code>给了缺省值</code>（默认值），初始化列表会用这个<code>缺省值初始化</code>。如果你<code>没有给缺省值</code>，对于没有显式在初始化列表初始化列表初始化的内置类型成员是否初始化取决于编译器，C++没有规定。对于没有显式在初始化列表初始化的自定义类型成员会调用这个成员类型的默认构造函数，如果没有默认构造会编译错误</li><li>初始化列表中按照成员变量在<mark>类中<font color="red">声明顺序进行初始化</font></mark>，跟成员在初始化列表出现的先后顺序无关。建议声明顺序和初始化列表顺序保存一致</li></ul> 
</blockquote> 
<p>  </p> 
<h5><a id="2362_539"></a>2.3.6.2、初始化列表行为脉络</h5> 
<blockquote> 
 <ul><li>每个构造函数<code>都有</code>初始化列表</li><li>每一个成员<code>都要走</code>初始化列表 
   <ul><li><code>在</code>初始化列表初始化的成员（显式写）</li><li><code>没有在</code>初始化化列表初始化的成员（不显式写） 
     <ul><li>声明的地方<code>有缺省值</code></li><li><code>没有缺省值</code> 
       <ul><li><code>内置类型</code>不确定是否初始化，看编译器，大概率是随机值</li><li><code>自定义类型</code>，调用默认构造，没有默认构造就编译报错</li></ul> </li></ul> </li><li>引用、const、没有默认构造的自定义类型，<code>必须</code>在初始化列表初始化</li></ul> </li></ul> 
</blockquote> 
<p>  </p> 
<h2><a id="3_553"></a>3、析构函数</h2> 
<h3><a id="31_555"></a>3.1、初见析构</h3> 
<p>  析构函数与构造函数功能<code>相反</code>。就像构造函数不是完成对象的创建；析构函数也不是完成对对象本身的销毁。局部对象的空间是<code>建立函数栈帧时开好的</code>；<code>销毁是在函数结束时，栈帧销毁，它就释放了</code>，不需要我们管。<br>   C++ 规定对象在销毁时会<mark>自动调用析构函数</mark>，完成对象中资源的清理释放工作。析构函数的功能类比我们之前实现栈 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         S 
        
       
         t 
        
       
         a 
        
       
         c 
        
       
         k 
        
       
      
        Stack 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">St</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span></span></span></span></span>、或实现队列 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         Q 
        
       
         u 
        
       
         e 
        
       
         u 
        
       
         e 
        
       
      
        Queue 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">Q</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span></span></span> 中的 <mark><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          D 
         
        
          e 
         
        
          s 
         
        
          t 
         
        
          r 
         
        
          o 
         
        
          y 
         
        
       
         Destroy 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">Des</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right: 0.0359em;">roy</span></span></span></span></span> 功能</mark>。<br>   <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         D 
        
       
         a 
        
       
         t 
        
       
         e 
        
       
      
        Date 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span></span></span></span></span> 类没有 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         D 
        
       
         e 
        
       
         s 
        
       
         t 
        
       
         r 
        
       
         o 
        
       
         y 
        
       
      
        Destroy 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">Des</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right: 0.0359em;">roy</span></span></span></span></span>，其实就是<code>没有资源需要释放</code>，所以严格来说 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         D 
        
       
         a 
        
       
         t 
        
       
         e 
        
       
      
        Date 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span></span></span></span></span> 是不需要析构函数的。</p> 
<p>  <br> 析构函数的特点：</p> 
<blockquote> 
 <ul><li>析构函数名是在<mark>类名前加上字符 <font color="red">~</font></mark>。</li><li><mark>无参数无返回值</mark>。（这里构造类似，也不需要加void）</li><li>一个类只能有<mark>一个</mark>析构函数。若未显式定义，系统会自动生成默认的析构函数。</li><li>对象生命周期结束时，系统会<mark>自动调用析构函数</mark></li><li>一个局部域的多个对象，C++ 规定<mark>后定义的先析构</mark></li></ul> 
</blockquote> 
<p>  析构函数的命名也很好理解：析构函数和构造函数是相反的功能。而 “<font color="red">~</font>” 操作符表示取反<br>   因为析构函数无参数无返回值，所以析构函数<mark>不构成函数重载</mark>，只能有一个析构函数<br>   析构函数有点类似于栈：<mark>后定义的先析构</mark><br>   <br> 因为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         D 
        
       
         a 
        
       
         t 
        
       
         e 
        
       
      
        Date 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span></span></span></span></span> 类中并没有资源需要清理，我们用栈类进行举例：</p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/8f/08/tlXeTjHe_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>  <br> 我们调试看一下;</p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/1c/b5/fvqrSNo5_o.gif" alt="在这里插入图片描述"></p> 
</blockquote> 
<p><font color="red">注</font>：该栈对象的销毁是发生在 <mark><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          m 
         
        
          a 
         
        
          i 
         
        
          n 
         
        
       
         main 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6595em;"></span><span class="mord mathnormal">main</span></span></span></span></span>函数 结束时</mark>，销毁对象之前调用了析构函数<br>   </p> 
<h3><a id="32_586"></a>3.2、深入析构</h3> 
<p>  与构造函数类似，析构函数也有进阶特点：</p> 
<blockquote> 
 <ul><li>跟构造函数类似，我们不写编译器自动生成的析构函数对<code>内置类型</code>成员<mark>不做任何在处理</mark>，<code>自定义类型</code>成员<mark>调用它的析构函数</mark><br>   </li><li>我们显示写析构函数，对于自定义类型成员也会调用它的析构，也就是说<code>自定义类型</code>成员<mark>无论什么情况都会自动调用其自身析构函数</mark><br>   </li><li>如果类中没有申请资源时，析构函数可以不写，直接使用编译器生成的默认析构函数，如 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           D 
          
         
           a 
          
         
           t 
          
         
           e 
          
         
        
          Date 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span></span></span></span></span> 类；如果默认生成的析构就可以用，也就不需要显示写析构，如 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           M 
          
         
           y 
          
         
           Q 
          
         
           u 
          
         
           e 
          
         
           u 
          
         
           e 
          
         
        
          MyQueue 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">M</span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="mord mathnormal">Q</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span></span></span>（用两个栈模拟实现队列）、但是<mark>有资源申请时，一定要自己写析构</mark>，否则会造成资源泄露，如 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           S 
          
         
           t 
          
         
           a 
          
         
           c 
          
         
           k 
          
         
        
          Stack 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">St</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span></span></span></span></span> 类。</li></ul> 
</blockquote> 
<p>  <br> 下面实现 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         M 
        
       
         y 
        
       
         Q 
        
       
         u 
        
       
         e 
        
       
         u 
        
       
         e 
        
       
      
        MyQueue 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">M</span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="mord mathnormal">Q</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span></span></span> 类（用两个栈模拟实现队列）就不用我们写析构，因为编译器自动会调用两个 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         S 
        
       
         t 
        
       
         a 
        
       
         c 
        
       
         k 
        
       
      
        Stack 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">St</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span></span></span></span></span> 类的析构函数</p> 
<pre><code class="prism language-cpp"><span class="token comment">// 两个Stack实现队列</span>
<span class="token keyword">class</span> <span class="token class-name">MyQueue</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span> <span class="token operator">:</span>
	<span class="token comment">//编译器默认⽣成MyQueue的析构函数调⽤了Stack的析构，释放的Stack内部的资源</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	Stack pushst<span class="token punctuation">;</span>
	Stack popst<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Stack st<span class="token punctuation">;</span>
	MyQueue mq<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/67/35/CSzToU1n_o.gif" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>  可以看到，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         M 
        
       
         y 
        
       
         Q 
        
       
         u 
        
       
         e 
        
       
         u 
        
       
         e 
        
       
      
        MyQueue 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">M</span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="mord mathnormal">Q</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span></span></span> 类<mark>自动调用</mark>了两次 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         S 
        
       
         t 
        
       
         a 
        
       
         c 
        
       
         k 
        
       
      
        Stack 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">St</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span></span></span></span></span> 类的析构<br>   并且，因为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         s 
        
       
         t 
        
       
      
        st 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6151em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span></span> 对象是先定义；<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         m 
        
       
         q 
        
       
      
        mq 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right: 0.0359em;">q</span></span></span></span></span> 对象是后定义，析构时，<mark>先析构 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          m 
         
        
          q 
         
        
       
         mq 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right: 0.0359em;">q</span></span></span></span></span>，再析构 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          s 
         
        
          t 
         
        
       
         st 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6151em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span></span></mark><br>   <br>   现在，我比较作，自己在 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         M 
        
       
         y 
        
       
         Q 
        
       
         u 
        
       
         e 
        
       
         u 
        
       
         e 
        
       
      
        MyQueue 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">M</span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="mord mathnormal">Q</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span></span></span> 上写了一个析构函数，但啥都不干，会发生什么呢？</p> 
<pre><code class="prism language-cpp"><span class="token comment">// 两个Stack实现队列</span>
<span class="token keyword">class</span> <span class="token class-name">MyQueue</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span> <span class="token operator">:</span>
	<span class="token operator">~</span><span class="token function">MyQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~MyQueue()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	Stack pushst<span class="token punctuation">;</span>
	Stack popst<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Stack st<span class="token punctuation">;</span>
	MyQueue mq<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/16/5a/zpJO1ubp_o.gif" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>  可以看到，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         M 
        
       
         y 
        
       
         Q 
        
       
         u 
        
       
         e 
        
       
         u 
        
       
         e 
        
       
      
        MyQueue 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">M</span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="mord mathnormal">Q</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span></span></span> 中的资源还是<mark>正常释放</mark>的<br>   这是因为即使我们显示写析构函数，对<code>自定义类型</code>，编译器执行完当前自己的析构函数后<mark>还会调用自定义类型的析构函数</mark>。<br>   <br>   那要是连 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         S 
        
       
         t 
        
       
         a 
        
       
         c 
        
       
         k 
        
       
      
        Stack 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">St</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span></span></span></span></span> 类中的析构函数也不写呢？那就内存泄漏了。自己作，真救不了。<br>   <br>   以前写C语言时，可能申请了空间总是忘记释放，现在有了析构函数就不再有这样的烦恼啦。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f37315bdab37ebb2cd74adc9f5572e2a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SpringBoot使用Redisson操作Redis及使用场景实战</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/eecc6714b8faf8296d8d1db532948a11/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">贪心算法part03</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>