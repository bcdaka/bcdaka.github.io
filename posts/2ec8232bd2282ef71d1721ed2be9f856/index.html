<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>迪杰斯特拉(Dijkstra)算法（C/C&#43;&#43;) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/2ec8232bd2282ef71d1721ed2be9f856/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="迪杰斯特拉(Dijkstra)算法（C/C&#43;&#43;)">
  <meta property="og:description" content="迪杰斯特拉（Dijkstra）算法是一种用于在加权图中找到单个源点到所有其他顶点的最短路径的算法。它是由荷兰计算机科学家艾兹格·迪科斯彻（Edsger Dijkstra）在1956年提出的。Dijkstra算法适用于处理带有非负权重的图。迪杰斯特拉算法主要特点是从起始点开始，采用贪心算法，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止。适用的是单源路径最短路问题，对于多源则采用弗洛伊德（Floyd）算法。
基本思想： 1. 创建一个集合S，用于存储已经找到最短路径的顶点。
2. 将所有顶点的最短路径估计值初始化为无穷大（或一个非常大的数），除了源点其值为0。
3. 不断从未加入S的顶点中选择一个具有最小估计值的顶点u，加入到S中。
4. 更新u的所有邻接顶点v的最短路径估计值。如果通过u到达v的路径比当前已知的路径更短，则更新v的估计值。
5. 重复步骤3和4，直到所有顶点都被加入到S中。
Dijkstra算法的时间复杂度为O(n^2)
下面介绍Dijkstra算法最重要的思想，如果A-&gt;B的代价为10，A-&gt;C的代价为1，C-&gt;B的代价为2，那么我们可以采用绕路的方式，把C点当作中转点，路线为ACB，这样代价为3小于A直接到B的代价10。
图解算法： 下面放一张Dijkstra算法的动态实现图，方便大家理解一下Dijkstra算法的主要思想。没有看懂没有关系，下面我会一步一步的详解。图片来自全栈程序员站长。
下面我们将以此图为例子进行一步一步讲解。
初始： 我们初始设有6个点，起点为a，终点为b，每个点到另一个点的距离如图所示，如果不能到达则为inf，Dis数组为起点到任意一点的最短距离，vis为标记数组，每次寻找最短距离。起点到起点不需要任何代价，所以为0，标记为true。
第一步： 从起点到能够到达的点更新最小距离，与6号点相邻能到达的有1、3、5号点，距离分别为9、2、9，在Dis数组里面都比inf要小，所以更新其值。我们寻找其中最小的距离为2（3号结点），那么我们就更新vis数组标记为true。
第二步： 由3号点可以到达2、4号点，我们发现起点到2号点的距离为2&#43;10=12&lt;inf，所以更新Dis数组，起点到4号点为2&#43;11=13&lt;inf，所以更新Dis数组。此时Dis数组中的最短距离为9，对应5号点。把5号点标记为true。
第三步： 由5号点可以到达4号点，那么由5号点作为中转点，起点到达4号点的距离为9&#43;6=15&gt;13，所以不更新Dis数组，此时Dis数组中最小的为12（2号点），把2号点vis标记为true。
第四步： 由2号点可以到达4号点，2号点作为中转点，起点到达4号点的距离为2&#43;10&#43;15=27&lt;13，所以Dis数组不更新。此时Dis数组中最小值为13（4号结点），标记vis数组。
第五步： 此时没有被标记的点且Dis数组中最小的值为1号点，那么标记1号点，1号点可以到达2、3号点，把1号点作为中转点，起点到达2号点的距离为14&#43;7=21&lt;12，不更新，起点到达2号点的距离为14&#43;9=23&lt;2不更新，此时vis数组都标记完成，算法结束，起点到每个点的最小距离为Dis数组。
视频讲解可以看一下这意味B站up主的，博主觉得他讲的非常好，通俗易懂，--&gt;点击直达&lt;-- C&#43;&#43;实现示例： #include&lt;iostream&gt; using namespace std; int n,e,s;//n个顶点，e条边，s是起点 const int inf=0x7fffff; int dis[101];//dis[i]起点到i的最短距离 int cheak[101];//标记是否找到 int graph[101][101];//记录路径i-&gt;j有路径 int main(){ for(int i=1;i&lt;=100;i&#43;&#43;){//初始无穷大 dis[i]=inf; } cin&gt;&gt;n&gt;&gt;e; for(int i=1;i&lt;=e;i&#43;&#43;){//邻接矩阵存储 int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; graph[a][b]=c; } cin&gt;&gt;s; dis[s]=0;//起点到起点不需要带价 for(int i=1;i&lt;=n;i&#43;&#43;){ int minn=inf,minx; for(int j=1;j&lt;=n;j&#43;&#43;){ if(dis[j]&lt;minn&amp;&amp;cheak[j]==0){//寻找此点到其他点的最小距离 minn=dis[j]; minx=j; } } cheak[minx]=1;//标记到达的最小点 for(int j=1;j&lt;=n;j&#43;&#43;){//更新以最小距离点最为中转点的最小距离 if(graph[minx][j]&gt;0){ if(minn&#43;graph[minx][j]&lt;dis[j]){ dis[j]=minn&#43;graph[minx][j]; } } } } for(int i=1;i&lt;=n;i&#43;&#43;){//打印最短距离 cout&lt;&lt;dis[i]&lt;&lt;&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-19T12:50:40+08:00">
    <meta property="article:modified_time" content="2024-08-19T12:50:40+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">迪杰斯特拉(Dijkstra)算法（C/C&#43;&#43;)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>迪杰斯特拉（Dijkstra）算法</strong>是一种用于在加权图中找到<strong>单个源点</strong>到所有其他顶点的<strong>最短路径</strong>的算法。它是由荷兰计算机科学家艾兹格·迪科斯彻（Edsger Dijkstra）在1956年提出的。Dijkstra算法适用于处理带有<strong>非负权重</strong>的图。迪杰斯特拉算法主要特点是从起始点开始，采用<strong>贪心算法</strong>，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止。适用的是单源路径最短路问题，对于多源则采用弗洛伊德（Floyd）算法。</p> 
<p style="text-align:center;"><img alt="" height="98" src="https://images2.imgbox.com/df/13/KCxoQ943_o.gif" width="780"></p> 
<h4>基本思想：</h4> 
<p>1. 创建一个集合S，用于存储已经找到最短路径的顶点。<br> 2. 将所有顶点的最短路径估计值初始化为无穷大（或一个非常大的数），除了源点其值为0。<br> 3. 不断从未加入S的顶点中选择一个具有最小估计值的顶点u，加入到S中。<br> 4. 更新u的所有邻接顶点v的最短路径估计值。如果通过u到达v的路径比当前已知的路径更短，则更新v的估计值。<br> 5. 重复步骤3和4，直到所有顶点都被加入到S中。</p> 
<p>Dijkstra算法的<strong>时间复杂度</strong>为O(n^2)</p> 
<p>下面介绍Dijkstra算法最重要的思想，如果A-&gt;B的代价为10，A-&gt;C的代价为1，C-&gt;B的代价为2，那么我们可以采用绕路的方式，把C点当作中转点，路线为ACB，这样代价为3小于A直接到B的代价10。</p> 
<p class="img-center"><img alt="" height="260" src="https://images2.imgbox.com/96/46/GY5FYUZ5_o.png" width="551"></p> 
<hr> 
<h4>图解算法：</h4> 
<p>下面放一张Dijkstra算法的动态实现图，方便大家理解一下Dijkstra算法的主要思想。没有看懂没有关系，下面我会一步一步的详解。图片来自全栈程序员站长。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/fc/08/JAZp1ZUU_o.gif"></p> 
<p>下面我们将以此图为例子进行一步一步讲解。</p> 
<h5>初始：</h5> 
<p>我们初始设有6个点，起点为a，终点为b，每个点到另一个点的距离如图所示，如果不能到达则为inf，Dis数组为起点到任意一点的最短距离，vis为标记数组，每次寻找最短距离。起点到起点不需要任何代价，所以为0，标记为true。</p> 
<p class="img-center"><img alt="" height="483" src="https://images2.imgbox.com/41/24/TEpI3TcP_o.png" width="909"></p> 
<h5>第一步： </h5> 
<p>从起点到能够到达的点更新最小距离，与6号点相邻能到达的有1、3、5号点，距离分别为9、2、9，在Dis数组里面都比inf要小，所以更新其值。我们寻找其中最小的距离为2（3号结点），那么我们就更新vis数组标记为true。</p> 
<p class="img-center"><img alt="" height="472" src="https://images2.imgbox.com/0c/07/obWsPBU7_o.png" width="908"></p> 
<h5>第二步：</h5> 
<p>由3号点可以到达2、4号点，我们发现起点到2号点的距离为2+10=12&lt;inf，所以更新Dis数组，起点到4号点为2+11=13&lt;inf，所以更新Dis数组。此时Dis数组中的最短距离为9，对应5号点。把5号点标记为true。</p> 
<p class="img-center"><img alt="" height="480" src="https://images2.imgbox.com/aa/2c/MnOu3d5M_o.png" width="907"></p> 
<h5>第三步：</h5> 
<p>由5号点可以到达4号点，那么由5号点作为中转点，起点到达4号点的距离为9+6=15&gt;13，所以不更新Dis数组，此时Dis数组中最小的为12（2号点），把2号点vis标记为true。</p> 
<p><img alt="" height="476" src="https://images2.imgbox.com/c0/22/Q86JfCVE_o.png" width="906"></p> 
<h5>第四步： </h5> 
<p>由2号点可以到达4号点，2号点作为中转点，起点到达4号点的距离为2+10+15=27&lt;13，所以Dis数组不更新。此时Dis数组中最小值为13（4号结点），标记vis数组。</p> 
<p class="img-center"><img alt="" height="480" src="https://images2.imgbox.com/32/21/4OUYRm7P_o.png" width="902"></p> 
<h5> 第五步：</h5> 
<p>此时没有被标记的点且Dis数组中最小的值为1号点，那么标记1号点，1号点可以到达2、3号点，把1号点作为中转点，起点到达2号点的距离为14+7=21&lt;12，不更新，起点到达2号点的距离为14+9=23&lt;2不更新，此时vis数组都标记完成，算法结束，起点到每个点的最小距离为Dis数组。</p> 
<p><img alt="" height="478" src="https://images2.imgbox.com/cf/cb/0fqU4rUR_o.png" width="905"></p> 
<p>视频讲解可以看一下这意味B站up主的，博主觉得他讲的非常好，通俗易懂，--&gt;<a class="link-info" href="https://www.bilibili.com/video/BV1MU4y1D729/?spm_id_from=333.999.0.0&amp;vd_source=fb68acc8676366210b38465a4a61ff28" rel="nofollow" title="点击直达">点击直达</a>&lt;-- </p> 
<hr> 
<h4>C++实现示例：</h4> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int n,e,s;//n个顶点，e条边，s是起点
const int inf=0x7fffff;
int dis[101];//dis[i]起点到i的最短距离
int cheak[101];//标记是否找到
int graph[101][101];//记录路径i-&gt;j有路径

int main(){
	for(int i=1;i&lt;=100;i++){//初始无穷大
		dis[i]=inf;
	}
	cin&gt;&gt;n&gt;&gt;e;
	for(int i=1;i&lt;=e;i++){//邻接矩阵存储
		int a,b,c;
		cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
		graph[a][b]=c;
	}
	cin&gt;&gt;s;
	dis[s]=0;//起点到起点不需要带价
	for(int i=1;i&lt;=n;i++){
		int minn=inf,minx;
		for(int j=1;j&lt;=n;j++){
			if(dis[j]&lt;minn&amp;&amp;cheak[j]==0){//寻找此点到其他点的最小距离
				minn=dis[j];
				minx=j;
			}
		}
		cheak[minx]=1;//标记到达的最小点
		for(int j=1;j&lt;=n;j++){//更新以最小距离点最为中转点的最小距离
			if(graph[minx][j]&gt;0){
				if(minn+graph[minx][j]&lt;dis[j]){
					dis[j]=minn+graph[minx][j];
				}
			}
		}
	}
	for(int i=1;i&lt;=n;i++){//打印最短距离
		cout&lt;&lt;dis[i]&lt;&lt;" ";
	}
	return 0;
}</code></pre> 
<hr> 
<h4> 算法例题：</h4> 
<p>Dijkstra算法直接考一般是不会直接考的，都是跟一些其他算法，或者新定义的概念结合起来考，由于Dijkstra算法原理很简单，考察Dijkstra算法更加偏向于其他算法的结合。下面我选取一个例题讲解。</p> 
<h5><a class="link-info" href="https://www.acwing.com/problem/content/4278/" rel="nofollow" title="AcWing 4275. Dijkstra序列">AcWing 4275. Dijkstra序列</a></h5> 
<p>Dijkstra 算法是非常著名的贪心算法之一。</p> 
<p>它用于解决单源最短路径问题，即指定一个特定源顶点，求该顶点到给定图的所有其他顶点的最短路径。</p> 
<p>它由计算机科学家 Edsger W. Dijkstra 于 19561956 年构思并在三年后出版。</p> 
<p>在该算法中，我们需要不断维护一个包含最短路径树中顶点的集合。</p> 
<p>在每一步中，我们找到一个尚未在集合内且与源顶点距离最小的顶点，并将其收于集合中。</p> 
<p>因此，通过 Dijkstra 算法，我们可以逐步生成一个有序的顶点序列，我们称之为 Dijkstra 序列。</p> 
<p>对于一个给定的图，可能有多个 Dijkstra 序列。</p> 
<p>例如，{5,1,3,4,2} 和 {5,3,1,2,4} 都是给定图的 Dijkstra 序列。</p> 
<p>注意，序列中的第一个顶点即为指定的特定源顶点。</p> 
<p>你的任务是检查给定的序列是否是 Dijkstra 序列。</p> 
<h6>输入格式</h6> 
<p>第一行包含两个整数 N 和 M，表示图中点和边的数量。</p> 
<p>点的编号 1∼N。</p> 
<p>接下来 M 行，每行包含三个整数 a,b,c，表示点 a 和点 b 之间存在一条<strong>无向</strong>边，长度为 c。</p> 
<p>再一行包含整数 K，表示需要判断的序列个数。</p> 
<p>接下来 K 行，每行包含一个 1∼N 的排列，表示一个给定序列。</p> 
<h6>输出格式</h6> 
<p>共 K 行，第 i 行输出第 K 个序列的判断，如果序列是 Dijkstra 序列则输出 <code>Yes</code>，否则输出 <code>No</code>。</p> 
<h6>数据范围</h6> 
<p>1≤N≤1000,<br> 1≤M≤10^5,<br> 1≤a,b≤N,<br> 1≤c≤100,<br> 1≤K≤100,<br> 保证给定无向图是连通图，<br> 保证无重边和自环（官网没提，但是经实测，官网数据符合此条件）。</p> 
<h6>输入样例：</h6> 
<pre><code>5 7
1 2 2
1 5 1
2 3 1
2 4 1
2 5 2
3 5 1
3 4 1
4
5 1 3 4 2
5 3 1 2 4
2 3 4 5 1
3 2 1 5 4
</code></pre> 
<h6>输出样例：</h6> 
<pre><code>Yes
Yes
Yes
No</code></pre> 
<h5>解题思路：</h5> 
<p>此题主要是考察了Dijkstra的逆向解决思路。题意是给定一个序列，让判断是否是Dijkstra序列，当然这个题的新概念Dijkstra序列也是很好理解的，上面我们图解算法，每一步都能标记一个点，这就是本题所说的Dijkstra序列，我们的解题思路就是验证即可，唯一不同的就是每一步选取一个最短距离的点，与给定的序列顺序比较是否为一致。判断一致需要看其他点是否被标记过，并且还有没有比此点距离还小的点。如果给定的序列中有任意一个点不满足，那么它就算不是Dijkstra序列，如果都满足，就是Dijkstra序列。</p> 
<h5>AC代码：</h5> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int inf=105;
int n,m;
int a[1005];
int g[1005][1005];
bool cheak[1005];
int dis[1005];
bool dij(int x){
	dis[x]=0;//起点到起点初始
	cheak[x]=1;
	for(int i=1;i&lt;=n;i++){//给定序列的n个点进行验证
		int t=a[i];
		cheak[t]=1;//标记此点
		for(int j=1;j&lt;=n;j++){//查看此点是否为最短距离的点
			if(!cheak[j]&amp;&amp;dis[j]&lt;dis[t]){//还有距离更短的点，则不满足
				return false;
			}
		}
		for(int j=1;j&lt;=n;j++){//由此点作为中转点，绕路更新最短距离
			if(dis[t]+g[t][j]&lt;dis[j]&amp;&amp;g[t][j]&gt;0){
				dis[j]=dis[t]+g[t][j];
			}
		}
	}
	return true;
}
int main(){
	cin&gt;&gt;n&gt;&gt;m;
	memset(g,inf,sizeof(g));//初始无穷大，不能到达就是无穷大
	for(int i=1;i&lt;=m;i++){
		int x,y,z;
		cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;
		g[x][y]=g[y][x]=z;//无向边
	}
	cin&gt;&gt;m;
	while(m--){
		memset(cheak,0,sizeof(cheak));//初始化0
		memset(dis,inf,sizeof(dis));
		for(int i=1;i&lt;=n;i++){
			cin&gt;&gt;a[i];
		}
		cout&lt;&lt;(dij(a[1])?"Yes":"No")&lt;&lt;endl;
	}
	return 0;
}</code></pre> 
<p>题目不再过多举例，比较难的都是Dijkstra与其他算法的集合，博主将会单独出一篇讲解。下篇更新弗洛伊德（Floyd）算法。执笔至此，感触彼多，全文将至，落笔为终，感谢大家的支持。 </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/31266de849ecff0dc36e4c80bd9088d5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C &#43;&#43;初阶：C&#43;&#43;入门级知识点</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b84e5dc2d92c7149cb334c1e7182888a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【轻松拿捏】Java中ArrayList 和 LinkedList 的区别是什么？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>