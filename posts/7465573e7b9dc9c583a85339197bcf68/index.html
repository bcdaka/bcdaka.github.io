<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】这里有一份KMP算法优化的详细攻略，不要错过哦！！！ - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/7465573e7b9dc9c583a85339197bcf68/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】这里有一份KMP算法优化的详细攻略，不要错过哦！！！">
  <meta property="og:description" content="KMP算法优化 导读一、C语言实现next数组1.1 next数组的底层逻辑1.2 串的数据类型的选择1.3 函数三要素1.3.1 查漏补缺——数组传参1.3.2 小结 1.4 函数主体1.4.1 通过模拟实现1.4.1.1 算法思路1.4.1.2 代码实现1.4.1.3 算法测试 1.4.2 算法的缺陷1.4.3 算法优化1.4.3.1 算法思路1.4.3.2 代码实现1.4.3.3 算法测试 二、`KMP`算法的进一步优化2.1 `KMP`算法存在的缺陷2.2 `nextval`数组 三、KMP算法测试四、模式匹配算法的对比五、算法的C语言函数接口总结 导读 大家好，很高兴又和大家见面啦！！！
在上一篇内容中我们详细介绍了KMP算法的基础知识点，相信大家在阅读完后应该对前缀、后缀、PM值、next数组这些基本概念有了一个初步的了解。但是在上一篇内容中我们对KMP算法的介绍还不够完整，遗留下来了两个问题：
next数组的代码实现KMP算法的缺陷优化 在今天的内容中，我们将会围绕这两个问题，进一步的对KMP算法进行深入探讨。相信大家都很期待今天的内容了，下面我们就进入正题吧！！！
一、C语言实现next数组 在求解next数组之前，我们先思考一个问题——对于不同的模式串，当首字符失配时，会不会有不同的处理方式？
这个问题的答案显然是不会。对于任意长度为 n ( n &gt; = 1 ) n(n&gt;=1) n(n&gt;=1) 模式串，不管模式串怎么改变，只要首元素失配，那我们在下一次进行匹配时肯定是将模式串向右移动1位，因此，首元素失配时对应的next[j]肯定是 j − 1 j-1 j−1。
！！！注意这里的j指的是元素在字符串中对应的数组下标。
也就是说当采用的存储方式是数组下标 = 位序 - 1时，那首元素的next[j]中j = 0，对应的值就为-1；
当采用的存储方式是数组下标 = 位序时，那首元素的next[j]中j = 1，对应的值就为0.
同样的对于任意长度为 n ( n &gt; = 2 ) n(n&gt;=2) n(n&gt;=2) 的模式串，不管模式串怎么改变，当第二个字符失配时，在下一次匹配时肯定是将首元素与主串中当前失配元素进行匹配，因此第二个元素失配时对应的next[j]同样也是是 j − 1 j-1 j−1。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-16T01:59:10+08:00">
    <meta property="article:modified_time" content="2024-05-16T01:59:10+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】这里有一份KMP算法优化的详细攻略，不要错过哦！！！</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>KMP算法优化</h4> 
 <ul><li><a href="#_3" rel="nofollow">导读</a></li><li><a href="#Cnext_12" rel="nofollow">一、C语言实现next数组</a></li><li><ul><li><a href="#11_next_40" rel="nofollow">1.1 next数组的底层逻辑</a></li><li><a href="#12__47" rel="nofollow">1.2 串的数据类型的选择</a></li><li><a href="#13__58" rel="nofollow">1.3 函数三要素</a></li><li><ul><li><a href="#131__72" rel="nofollow">1.3.1 查漏补缺——数组传参</a></li><li><a href="#132__86" rel="nofollow">1.3.2 小结</a></li></ul> 
   </li><li><a href="#14__110" rel="nofollow">1.4 函数主体</a></li><li><ul><li><a href="#141__112" rel="nofollow">1.4.1 通过模拟实现</a></li><li><ul><li><a href="#1411__115" rel="nofollow">1.4.1.1 算法思路</a></li><li><a href="#1412__152" rel="nofollow">1.4.1.2 代码实现</a></li><li><a href="#1413__183" rel="nofollow">1.4.1.3 算法测试</a></li></ul> 
    </li><li><a href="#142__193" rel="nofollow">1.4.2 算法的缺陷</a></li><li><a href="#143__222" rel="nofollow">1.4.3 算法优化</a></li><li><ul><li><a href="#1431__223" rel="nofollow">1.4.3.1 算法思路</a></li><li><a href="#1432__269" rel="nofollow">1.4.3.2 代码实现</a></li><li><a href="#1433__379" rel="nofollow">1.4.3.3 算法测试</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#KMP_386" rel="nofollow">二、`KMP`算法的进一步优化</a></li><li><ul><li><a href="#21_KMP_391" rel="nofollow">2.1 `KMP`算法存在的缺陷</a></li><li><a href="#22_nextval_406" rel="nofollow">2.2 `nextval`数组</a></li></ul> 
  </li><li><a href="#KMP_470" rel="nofollow">三、KMP算法测试</a></li><li><a href="#_476" rel="nofollow">四、模式匹配算法的对比</a></li><li><a href="#C_484" rel="nofollow">五、算法的C语言函数接口</a></li><li><a href="#_561" rel="nofollow">总结</a></li></ul> 
</div> 
<p></p> 
<p><img src="https://images2.imgbox.com/0f/bc/xMJM976N_o.gif" alt="封面"></p> 
<h2><a id="_3"></a>导读</h2> 
<p>大家好，很高兴又和大家见面啦！！！</p> 
<p>在上一篇内容中我们详细介绍了KMP算法的基础知识点，相信大家在阅读完后应该对前缀、后缀、PM值、next数组这些基本概念有了一个初步的了解。但是在上一篇内容中我们对KMP算法的介绍还不够完整，遗留下来了两个问题：</p> 
<ol><li>next数组的代码实现</li><li>KMP算法的缺陷优化</li></ol> 
<p>在今天的内容中，我们将会围绕这两个问题，进一步的对KMP算法进行深入探讨。相信大家都很期待今天的内容了，下面我们就进入正题吧！！！</p> 
<h2><a id="Cnext_12"></a>一、C语言实现next数组</h2> 
<p>在求解next数组之前，我们先思考一个问题——对于不同的模式串，当首字符失配时，会不会有不同的处理方式？</p> 
<p>这个问题的答案显然是不会。对于任意长度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
         ( 
        
       
         n 
        
       
         &gt; 
        
       
         = 
        
       
         1 
        
       
         ) 
        
       
      
        n(n&gt;=1) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">&gt;=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 模式串，不管模式串怎么改变，只要首元素失配，那我们在下一次进行匹配时肯定是将模式串向右移动1位，因此，首元素失配时对应的<code>next[j]</code>肯定是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         j 
        
       
         − 
        
       
         1 
        
       
      
        j-1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span>。</p> 
<blockquote> 
 <p><strong>！！！注意这里的j指的是元素在字符串中对应的数组下标。<br> 也就是说当采用的存储方式是<code>数组下标 = 位序 - 1</code>时，那首元素的<code>next[j]</code>中<code>j = 0</code>，对应的值就为<code>-1</code>；<br> 当采用的存储方式是<code>数组下标 = 位序</code>时，那首元素的<code>next[j]</code>中<code>j = 1</code>，对应的值就为<code>0</code>.</strong></p> 
</blockquote> 
<p>同样的对于任意长度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
         ( 
        
       
         n 
        
       
         &gt; 
        
       
         = 
        
       
         2 
        
       
         ) 
        
       
      
        n(n&gt;=2) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">&gt;=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> 的模式串，不管模式串怎么改变，当第二个字符失配时，在下一次匹配时肯定是将首元素与主串中当前失配元素进行匹配，因此第二个元素失配时对应的<code>next[j]</code>同样也是是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         j 
        
       
         − 
        
       
         1 
        
       
      
        j-1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span>。</p> 
<p>因此对于任意串长为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
         ( 
        
       
         n 
        
       
         &gt; 
        
       
         = 
        
       
         2 
        
       
         ) 
        
       
      
        n(n&gt;=2) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">&gt;=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> 的模式串，我们都能得到next数组中的前两个元素：</p> 
<ul><li>元素下标从0开始：</li></ul> 
<table><thead><tr><th>模式串</th><th>x</th><th>x</th><th>x</th><th>……</th><th>x</th><th>……</th><th>x</th></tr></thead><tbody><tr><td>元素下标 j</td><td>0</td><td>1</td><td>2</td><td>……</td><td>j</td><td>……</td><td>n - 1</td></tr><tr><td>next[j]</td><td>-1</td><td>0</td><td>?</td><td>……</td><td>?</td><td>……</td><td>?</td></tr></tbody></table> 
<ul><li>元素下标从1开始：</li></ul> 
<table><thead><tr><th>模式串</th><th>x</th><th>x</th><th>x</th><th>……</th><th>x</th><th>……</th><th>x</th></tr></thead><tbody><tr><td>元素下标 j</td><td>1</td><td>2</td><td>3</td><td>……</td><td>j</td><td>……</td><td>n</td></tr><tr><td>next[j]</td><td>0</td><td>1</td><td>?</td><td>……</td><td>?</td><td>……</td><td>?</td></tr></tbody></table> 
<p>所以，当我们在进行手算next数组时，可以根据下标j的起点直接确定前两个元素的<code>next[j]</code>。</p> 
<h3><a id="11_next_40"></a>1.1 next数组的底层逻辑</h3> 
<p>在上一篇内容中，我们介绍了两种计算next数组的方法，不知道大家还有没有印象，现在我们一起来回忆一下：</p> 
<ol><li>通过PM值计算next数组——当第 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          j 
         
        
       
         j 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span></span></span></span></span> 个字符发生失配时，我们只需要计算第 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          j 
         
        
          − 
         
        
          1 
         
        
       
         j-1 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span> 个字符的PM值就可以获取第 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          j 
         
        
       
         j 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span></span></span></span></span> 个字符的<code>next[j]</code>，因为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          n 
         
        
          e 
         
        
          x 
         
        
          t 
         
        
          [ 
         
        
          j 
         
        
          ] 
         
        
          = 
         
        
          = 
         
        
          P 
         
         
         
           M 
          
          
          
            j 
           
          
            − 
           
          
            1 
           
          
         
        
       
         next[j]==PM_{j-1} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">==</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.9694em; vertical-align: -0.2861em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.109em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.109em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span></span></span></span></span>；</li><li>通过移位模拟计算next数组——当第 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          j 
         
        
       
         j 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span></span></span></span></span> 个字符发生失配时，我们可以通过手动移位来模拟匹配过程，从而找到<code>next[j]</code>；</li></ol> 
<p>实际上不管是PM值也好还是移位模拟也好，我们都是在手动的进行由前面 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         j 
        
       
         − 
        
       
         1 
        
       
      
        j-1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span> 个字符组成的子串的前后缀匹配过程。也就是说<strong>求解next数组实际上就是求解失配字符的前一个字符的PM值</strong>，因此，我们想要通过代码来计算next数组，同样也是需要借助代码来实现子串前后缀的匹配。</p> 
<h3><a id="12__47"></a>1.2 串的数据类型的选择</h3> 
<p>为了减轻大家的阅读负担，并且能够将今天的内容与前面的内容联系起来，因此，在今天的内容介绍中，我们依旧采用的是定长顺序存储的数据类型：</p> 
<pre><code class="prism language-c"><span class="token comment">//定长顺序存储</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXSIZE</span> <span class="token expression"><span class="token number">255</span></span><span class="token comment">//最大串长</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">StackString</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span> ch<span class="token punctuation">[</span>MAXSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//存储字符的字符数组</span>
	<span class="token keyword">int</span> length<span class="token punctuation">;</span><span class="token comment">//当前串长</span>
<span class="token punctuation">}</span>SString<span class="token punctuation">;</span><span class="token comment">//重命名后的数据类型名</span>
</code></pre> 
<h3><a id="13__58"></a>1.3 函数三要素</h3> 
<p>next数组的求解我们同样是将其封装成一个函数，既然是函数，那就少不了函数的三要素：</p> 
<ul><li>函数名：对于一个函数而言，一个好的函数名可以展示出函数的具体功能，而我们要实现的是一个能够获取next数组的函数，因此我们不妨将函数名定为<code>get_next</code>；</li><li>函数参数：在获取next数组时，我们肯定是需要对模式串T进行操作的，因此，函数参数肯定有模式串T这个参数，模式串的参数类型我们还是以上一篇的模式串的类型为例进行介绍，因此这里我们选择采用<code>char*</code>的类型；</li><li>函数返回类型：函数返回类型的选择与函数的功能是有直接关系的： 
  <ul><li>如果我们是想通过函数来创建一个next数组，那我们就可以返回一个由<code>malloc/calloc</code>创建的<code>int*</code>的值，因此函数返回类型就是<code>int*</code>；</li><li>如果我们想要通过函数来获取next数组中的内容，那我们只需要将<code>int</code>类型的数组作为函数参数传入函数，这时函数就不需要任何返回类型，因此函数的返回类型为<code>void</code>；</li></ul> </li></ul> 
<p>通过第一种函数返回类型实现的函数大家应该都更容易理解，但是第二种返回类型的函数，可能会有朋友有疑问，我们在传入<code>int</code>型的数组时需不需要取地址？</p> 
<p>这个问题的答案是不需要的。会有这个疑问是很正常的，这就说明我们在数组传参这个知识点上还存在知识漏洞，不过很幸运的是我们现在发现了这个漏洞，下面就需要将其填补起来。</p> 
<hr> 
<h4><a id="131__72"></a>1.3.1 查漏补缺——数组传参</h4> 
<p><strong>数组名表示的是数组首元素的地址，同样也是数组空间的起始地址</strong>。</p> 
<p>我们在进行数组名传参时实际上传入的是数组首元素地址，这时形参接收的内容也是数组的首元素地址，因此形参的参数类型可以是<code>int*</code>的类型也可以是<code>int []</code>类型；</p> 
<p>当我们在函数中对形参进行操作时，实际上就是通过形参找到数组的首元素地址对数组的首元素进行操作，而数组中的元素在存储时是地址由低到高进行连续存储的，所以我们可以通过数组的首元素地址找到数组中的其它元素，因此我们只是想修改数组中的元素的话是不需要进行取地址传参，如下所示：<br> <img src="https://images2.imgbox.com/bd/a7/2uyuLElx_o.png" alt="数组传参"><br> 可以看到直接通过数组名进行传参，此时实参和形参的参数地址是同一个地址。</p> 
<p>我们在进行取地址数组名传参时，实际上传入的是数组空间的起始地址，如下所示：</p> 
<p><img src="https://images2.imgbox.com/03/97/2BkNAuT9_o.png" alt="数组传参2"><br> 可以看到通过取地址数组名传参，此时的实参和形参的参数地址是同一个地址。</p> 
<h4><a id="132__86"></a>1.3.2 小结</h4> 
<p>现在我们就简单复习了一下一维数组传参的基础知识点，下面我们做个小结：</p> 
<ul><li>数组名表示的是数组的首元素地址，也是数组空间的起始地址；</li><li>一维数组在传参时，不管是直接通过数组名传参还是通过取地址数组名传参，形参都可以使用一级指针或者是一维数组进行接收，并且都能够正常对数组中的元素进行修改；</li><li>直接通过数组名进行传参，传入是实际上是数组首元素的地址；</li><li>通过取地址数组名进行传参，传入的实际上是数组空间的起始地址；</li></ul> 
<hr> 
<p>复习完了数组传参的内容，那么我们回到我们的正题——函数返回类型的选择。</p> 
<p>正如前面所说，在实现next数组的函数中，函数的返回类型我们可以选择两种类型——<code>int*</code>和<code>void</code>。这两个类型的区别就是next数组的存在区域不同。</p> 
<ul><li>int*型的函数创建的next数组是在堆区上，内存空间需要手动进行释放；</li><li>void型的函数修改的next数组是在栈区上，内存空间在程序结束时自动回收；</li></ul> 
<p>因此我们可以根据自己的需求进行选择，这里我们还是简单一点，以void型的函数为例进行next数组的C语言实现。</p> 
<pre><code class="prism language-c"><span class="token comment">//C语言实现next数组</span>
<span class="token keyword">void</span> <span class="token function">get_next</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> T<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> next<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//函数实现</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="14__110"></a>1.4 函数主体</h3> 
<p>按照next数组的底层逻辑，我们想要求解next数组中的<code>next[j]</code>，实际上就是对前一个字符的PM值进行求解，而求解PM值就是求解字符串的前后缀相等的最长前后缀长度，因此，我们可以采用模拟的方式来求解next数组。</p> 
<h4><a id="141__112"></a>1.4.1 通过模拟实现</h4> 
<p><strong>模拟指的就是通过代码模拟出前后缀比较从而进行PM值求解的方法</strong>。</p> 
<h5><a id="1411__115"></a>1.4.1.1 算法思路</h5> 
<p>整个算法的实现肯定需要有以下流程：</p> 
<ol><li>获取模式串中的字符</li><li>获取模式串中当前字符的前一个字符的前缀与后缀</li><li>比较前缀和后缀，根据比较的结果进行相应的操作： 
  <ul><li>前缀后缀相等：获取当前的前后缀长度，之后继续获取下一个前后缀</li><li>前缀后缀不相等：继续获取下一个前后缀</li></ul> </li></ol> 
<p>在整个流程中，我们会遇到的问题有以下几点：</p> 
<ol><li>首字符没有前后缀应该如何处理</li><li>第二个字符应该如何处理</li><li>前后缀长度如何获取</li></ol> 
<p>第一个问题和第二个问题实际上都是与首字符相关的问题，而对于首字符的问题，这个我们只能单独进行处理。在前面也提到过对于任意长度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
         ( 
        
       
         n 
        
       
         &gt; 
        
       
         = 
        
       
         2 
        
       
         ) 
        
       
      
        n(n&gt;=2) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">&gt;=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> 的模式串而言，首字符和第二个字符的<code>next[j]</code>肯定是<code>j - 1</code>。因此我们可以直接根据首字符和第二个字符的下标来进行<code>next[j]</code>的求解；</p> 
<p>第三个问题的处理方式我们主要介绍两种：</p> 
<ol><li>通过前缀子串的尾指针获取前缀长度： 
  <ul><li>下标从0开始的模式串，前缀串长 = 前缀子串的尾指针 + 1</li><li>下标从1开始的模式串，前缀串长 = 前缀子串的尾指针</li></ul> </li><li>通过后缀子串的头指针获取后缀长度： 
  <ul><li>借助求串长操作将后缀子串的头指针传入函数进行求解；</li><li>还可以通过下标之差获取后缀子串长度：后缀子串长度 = 当前字符的下标 - 后缀子串头指针指向的下标</li></ul> </li></ol> 
<p>为了方便大家理解整个过程，下面我们看一下该算法的演示：</p> 
<p><img src="https://images2.imgbox.com/d0/2c/zCct170x_o.gif" alt="通过模拟实现"></p> 
<p>从演示中我们不难推测，算法的实现依赖与两层循环，外层循环是来获取模式串的各个元素，内存循环则是用来获取各个元素的<code>next[j]</code>；</p> 
<p>为了保证前缀子串和后缀子串在每个字符中都能从单个字符开始增加，因此前缀字符数组和后缀字符数组肯定是定义在第一层循环内，第二层循环外；</p> 
<p>在进行前后缀比较时，我们可以通过调用串比较操作来实现。从演示中可以看到，对于前缀子串而言，子串的起始点就是首元素地址，而后缀子串的起始点是后缀子串的头指针，因此传入的参数分别是前缀子串的数组名和后缀子串的串头指针；</p> 
<p>在获取后缀子串的元素时，如果我们从后缀数组的首元素开始，那必然会出现数据移动的操作，为了规避这个步骤，我们可以如演示中一样从后往前向后缀数组中插入元素；</p> 
<h5><a id="1412__152"></a>1.4.1.2 代码实现</h5> 
<p>理清了整体的实现思路，我们就可以顺着思路进行代码实现了，如下所示：</p> 
<pre><code class="prism language-c"><span class="token comment">//C语言实现next数组</span>
<span class="token keyword">void</span> <span class="token function">get_next</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> T<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> next<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//函数实现——模拟</span>
	<span class="token comment">//处理首字符</span>
	next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//字符下标从0开始</span>
	<span class="token comment">//处理其他字符</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> T<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">char</span> prefix<span class="token punctuation">[</span>MAXSIZE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//前缀子串</span>
		<span class="token keyword">char</span> suffix<span class="token punctuation">[</span>MAXSIZE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//后缀子串</span>
		<span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//前缀指针</span>
		<span class="token keyword">int</span> l <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//后缀指针</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//处理第二个字符</span>
			next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			prefix<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> T<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//获取前缀字符</span>
			suffix<span class="token punctuation">[</span>l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> T<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//获取后缀字符</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">Compare</span><span class="token punctuation">(</span>prefix<span class="token punctuation">,</span> suffix <span class="token operator">+</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//比较前后缀</span>
				next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//前后缀相等，则记录前缀尾字符下标</span>
			p<span class="token operator">++</span><span class="token punctuation">,</span> l<span class="token operator">--</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>有朋友可能好奇，为什么第二个字符的处理是放在循环内。我的考虑是可能遇到的模式串长度为1，因此将第二个字符的处理放入循环内会更保险一点。</p> 
<p>还有朋友可能会问为什么在获取后缀字符时字符的位置放入的是<code>l - 1</code>，这是因为前后缀子串的长度是要小于对应子串的长度的，所以我通过将存入的位置往前移动来进行表示，当然也可以直接放入下标为l的位置，这个不影响算法的实现。</p> 
<h5><a id="1413__183"></a>1.4.1.3 算法测试</h5> 
<p>接下来我们分别测试下面几个模式串：</p> 
<ol><li><code>"abcabc"</code>——手算next数组为<code>{-1, 0, 0, 0, 1, 2}</code>；</li><li><code>"ababaaababaa"</code>——手算next数组为<code>{-1, 0, 0, 1, 2, 3, 1, 1, 2, 3, 4, 5}</code>；</li><li><code>"aabaac"</code>——手算next数组为<code>{-1, 0, 1, 0, 1, 2}</code>；</li></ol> 
<p><img src="https://images2.imgbox.com/6f/24/slDWXocT_o.png" alt="算法测试"><br> 可以看到，现在是能够正确获取模式串的next数组的。</p> 
<h4><a id="142__193"></a>1.4.2 算法的缺陷</h4> 
<p>在刚才实现的next数组求解的算法中，我们可以看到，对于串长为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
         ( 
        
       
         n 
        
       
         &gt; 
        
       
         = 
        
       
         1 
        
       
         ) 
        
       
      
        n(n&gt;=1) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">&gt;=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 的模式串来说，求解其next数组的时间复杂度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
        
        
          N 
         
        
          2 
         
        
       
         ) 
        
       
      
        O(N^2) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> 很显然这个时间复杂度会在一定程度上会增加<code>KMP</code>算法的时间开销，因此我们要对该算法进行优化。</p> 
<p>在整个算法的实现中主要存在以下几个问题：</p> 
<ol><li>当我们在求PM值的时候是通过大量的获取前缀和后缀子串来进行求解，因此每一次获取前后缀都会消耗大量的时间；</li><li>在获取前后缀并进行匹配的过程中存在大量的无用匹配：</li></ol> 
<p><img src="https://images2.imgbox.com/15/46/jmDEdYjs_o.jpg" alt="算法的缺陷"><br> 以上图为例，此时我们在求<code>j = 3</code>的<code>next[3]</code>之前，我们已经通过 <code>j = 2</code> 证明了<code>K[0] != K[1]</code>，之后我们又证明了<code>K[0] != K[2]</code>，也就是说此时从<code>K[0]～K[3]</code>元素之间的关系我们已经很明确它们互不相等了，因此上图所示的这一步就已经没有必要再来证明了。</p> 
<p><img src="https://images2.imgbox.com/48/06/c1xZ4gpZ_o.jpg" alt="算法的缺陷2"><br> 在这一步中，此时我们可以很容易证明<code>K[0] == K[3]</code>，在这之前我们已经证明了K[0]/K[1]/K[2]它们三个元素互不相等，因此由K[0]K[1]K[2]这三个元素组成的字符串肯定与K[1]K[2]K[3]组成的字符串不相等，因此后续获取前后缀的步骤也是没必要的；</p> 
<p><img src="https://images2.imgbox.com/5e/97/O7Vvr2Ll_o.jpg" alt="算法的缺陷3"><br> 在这一步中，我们已经证明了<code>K[0] == K[3]</code>，因此由这两个元素开头的字符串我们只需要证明后续的元素是否相等，即我们要证明的是<code>K[1] == K[4]?</code>，因此在这之前证明<code>K[0] == K[4]？</code>这个步骤也是没必要的；</p> 
<p>从上述分析中我们可以很直观的感受到，在整个求解的过程中，我们并不需要将每一个前缀都与后缀进行比较，相反，我们仅仅只需要比较单个元素，为什么会是这样的结论呢？如下图所示：</p> 
<p><img src="https://images2.imgbox.com/d9/d4/q5AcyF0z_o.jpg" alt="前后缀的关系"></p> 
<p>从图中我们可以很直观的看到，当第j个字符失配时，我们要求其next[j]的话，那对应的前缀则是由字符<code>K[0]～K[j-3]</code>这些字符组成的最长前缀；对应的后缀是由<code>K[1]～K[j-2]</code>这些字符组成的最长后缀；</p> 
<p>在比较前后缀是否相等时，我们是从前后缀的首元素依次往后比较的。</p> 
<ul><li>当<code>K[0] != K[1]</code>时，后面的内容我们就不需要继续比较了，这时可以直接将后缀往左移动或者前缀向右移动进而比较<code>K[0]</code>与<code>K[2]</code>的关系；</li><li>当<code>K[0] == K[i]</code>时，接下来我们才会继续比较<code>K[1]</code>与<code>K[i+1]</code>之间的关系</li></ul> 
<p>由此可以看到求解next[j]时，我们完全可以将寻找最长相等的前后缀长度转换成判断前后缀中的各个元素是否相等。</p> 
<h4><a id="143__222"></a>1.4.3 算法优化</h4> 
<h5><a id="1431__223"></a>1.4.3.1 算法思路</h5> 
<p>在明确了优化的方向后，下面我们就可以来理清整个算法的思路了。</p> 
<p>同样的在优化的算法中，对于首元素我们依旧是进行单独处理，这里就不再展开赘述。我们现在要重点关注的是从第二个字符开始的算法优化。</p> 
<p>在前面的分析中，我们不难发现，我们在进行字符比较时，是从<code>K[0]</code>和<code>K[1]</code>开始进行比较的，如果相等，则继续比较下一个元素；反之，则比较<code>K[0]</code>和<code>K[2]</code>。</p> 
<p>因此在整个求解过程中，我们可以通过判断前缀的串尾元素K[p]与后缀的串尾元素K[l]是否相等将其分为两种情况：</p> 
<ul><li>若<code>K[p] == K[l]</code>，则我们需要将指针向后移动，即<code>p++, l++</code>；</li><li>若<code>K[p] != K[l]</code>，则我们需要将指针p回溯，指针l不变，进而比较回溯后的<code>K[p]</code>与此时的<code>K[l]</code>之间的关系；</li></ul> 
<p>现在问题来了，在字符匹配失败时，我们应该将指针p回溯到哪里去呢？下面我们来简单的推导一下，以字符串<code>"ababaaababaa"</code>为例：</p> 
<p><img src="https://images2.imgbox.com/4b/ff/bVGuZKIX_o.gif" alt="用例推导"></p> 
<p>从演示中我们不难发现，当第j个元素发生失配时，前一个字符的<code>next[j-1]</code>就是我们下次需要进行匹配的对象，也就是说在<code>next[j-1]</code>之前的元素匹配肯定都是无效的。</p> 
<p>可能有朋友对这个过程不太理解，为了帮助大家理解这个过程，下面请跟随我的思路来思考几个问题：</p> 
<ol><li>next数组中存储的内容是用来做什么的？</li></ol> 
<p>这个问题相信大家都不陌生了，next数组中的<code>next[j]</code>的含义是：在子串的第 <code>j</code> 个字符与主串发生失配时，下一次进行匹配时需要跳转到子串的<code>next[j]</code>的位置重新与主串当前位置进行比较。</p> 
<ol start="2"><li>前后缀比较的本质是什么？</li></ol> 
<p>这个问题大家现在仔细回顾一下我们介绍next数组的整个过程就不难发现，其实前后缀的比较过程也是在进行模式匹配，如果将后缀作为主串的话，那前缀进行匹配的内容就是子串，只不过这里的主串长度是会发生变化的。</p> 
<p>这时有朋友可能就会提出疑问了，对于这个匹配过程我们已经理解了，进行手算的话是完全没问题的，但是如何通过计算机来反映这一过程呢？</p> 
<p>下面我们就需要探讨一下当第 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         k 
        
       
      
        k 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span></span></span></span></span> 个字符匹配成功时，第 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         k 
        
       
         + 
        
       
         1 
        
       
      
        k+1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7778em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span> 个字符的<code>next[k+1]</code>与<code>next[k]</code>的关系。</p> 
<p>在前后缀匹配的过程中第k个字符匹配成功时对应的<code>next[k]</code>就是从第1个字符到第 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         k 
        
       
         − 
        
       
         1 
        
       
      
        k-1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7778em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span> 个字符组成的子串的前后缀匹配的最长相等长度，此时我们假设<code>next[k] = x</code><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ( 
        
       
         0 
        
       
         &lt; 
        
       
         = 
        
       
         x 
        
       
         &lt; 
        
       
         = 
        
       
         k 
        
       
         ) 
        
       
      
        (0&lt;=x&lt;=k) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.5782em; vertical-align: -0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mclose">)</span></span></span></span></span>。</p> 
<p>当第 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         k 
        
       
         + 
        
       
         1 
        
       
      
        k+1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7778em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span> 个字符失配时，那也就是说前面第 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         k 
        
       
      
        k 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span></span></span></span></span> 个字符是匹配成功的，而第 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         k 
        
       
      
        k 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span></span></span></span></span> 个字符失配时，根据我们的假设，第 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         k 
        
       
         − 
        
       
         1 
        
       
      
        k-1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7778em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span> 个字符总共有 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         x 
        
       
      
        x 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span> 个字符匹配成功，现在第 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         k 
        
       
      
        k 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span></span></span></span></span> 个字符也匹配成功，因此我们不难得出，此时匹配成功的字符总共有 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         x 
        
       
         + 
        
       
         1 
        
       
      
        x+1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span> 个。</p> 
<p>因此当第 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         k 
        
       
         + 
        
       
         1 
        
       
      
        k+1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7778em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span> 个字符失配时，对应的<code>next[k+1] = x + 1</code>。</p> 
<p>有了上面的结论，现在我们再来分析从第二个字符开始的<code>next[j]</code>如何进行计算。</p> 
<p>当我们在对长度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
         ( 
        
       
         n 
        
       
         &gt; 
        
       
         = 
        
       
         1 
        
       
         ) 
        
       
      
        n(n&gt;=1) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">&gt;=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 的模式串进行next数组求解时，假设其元素下标从0开始，所有字符的<code>next[j]</code>的求解如下所示：</p> 
<ul><li>首字符的<code>next[0] = 0 - 1 = -1</code>；</li><li>当下一个字符匹配成功时，对应的<code>next[j] = next[j-1] + 1</code>，然后继续匹配下一个元素；</li><li>当下一个字符匹配失败时，我们则需要将下标为<code>next[j - 1]</code>的元素与元素 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          j 
         
        
       
         j 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span></span></span></span></span> 进行匹配；</li><li>当<code>next[j-1] = -1</code>时，说明此时前缀字符串中没有元素与元素j能够成功匹配，因此需要将前缀串尾元素与下一个元素 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          j 
         
        
          + 
         
        
          1 
         
        
       
         j+1 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span> 进行匹配，第 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          j 
         
        
       
         j 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span></span></span></span></span> 个元素对应的<code>next[j] = 0</code>；</li></ul> 
<h5><a id="1432__269"></a>1.4.3.2 代码实现</h5> 
<p>有了具体的思路，接下来就是进行代码的编写了，如下所示：</p> 
<pre><code class="prism language-c"><span class="token comment">//C语言实现next数组</span>
<span class="token keyword">void</span> <span class="token function">get_next</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> T<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> next<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//函数实现——算法优化</span>
	<span class="token comment">//处理首字符</span>
	next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//字符下标从0开始</span>
	<span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//前缀指针和后缀指针</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> T<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//当匹配成功时</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">==</span> T<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> next<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
			p<span class="token operator">++</span><span class="token punctuation">,</span> l<span class="token operator">++</span><span class="token punctuation">,</span> i<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//当匹配失败时</span>
		<span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			p <span class="token operator">=</span> next<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//前缀指针回溯到next[i-1]的位置</span>
			<span class="token comment">//处理无匹配字符的情况</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
				p<span class="token operator">++</span><span class="token punctuation">,</span> l<span class="token operator">++</span><span class="token punctuation">,</span> i<span class="token operator">++</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>现在我们已经根据上述思路成功编写了代码，但是这个代码看上去还是不够精简，下面我们需要思考一下如何简化该代码。</p> 
<blockquote> 
 <ol><li>合并相同代码</li></ol> 
</blockquote> 
<p>从代码中我们可以看到，整个算法在<code>p == -1</code>和前后缀字符匹配成功时都有进行指针的后移，唯一不同的是<code>next[i]</code>的处理，因此如果要合并这两句代码的话我们则需要探讨一下<code>next[i - 1] + 1</code>与0的关系。</p> 
<p>在代码中我们能够比较容易的得到当<code>next[i - 1] = -1</code>时，这两个值是相等的；而当<code>next[i-1] = -1</code>时，即第<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         i 
        
       
      
        i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></span>个字符的前一个字符的next数组的值为-1，此时只有一种情况，<code>next[i-1]</code>对应的元素为模式串的首元素。当出现这种情况时就表示前缀子串中没有和该元素匹配的情况，因此这两个if语句是可以进行合并的。</p> 
<blockquote> 
 <ol start="2"><li>去掉无用代码</li></ol> 
</blockquote> 
<p>在整个算法中，我们不难发现，后缀指针<code>l</code>与指向模式串<code>i</code>的指针它们的操作是相同的，只会向后进行遍历，因此我们可以舍弃其中一个指针，为了方便理解，我们选择舍弃模式串指针，保留指向后缀子串的指针，这样整个匹配过程就简化为前缀子串与后缀子串进行模式匹配。在这种情况下，当匹配成功时，需要先移动前后缀指针，才能获取正确的next数组的值。</p> 
<p>根据简化思路简化后的代码如下所示：</p> 
<pre><code class="prism language-c"><span class="token comment">//C语言实现next数组</span>
<span class="token keyword">void</span> <span class="token function">get_next</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> T<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> next<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//函数实现——算法优化——代码简化</span>
	<span class="token comment">//处理首字符</span>
	next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//字符下标从0开始</span>
	<span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//前缀指针</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> T<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//当匹配成功时</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> T<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">==</span> T<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			p<span class="token operator">++</span><span class="token punctuation">,</span> j<span class="token operator">++</span><span class="token punctuation">;</span>
			next<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> next<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//当匹配失败时</span>
		<span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			p <span class="token operator">=</span> next<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//前缀指针回溯到next[j-1]的位置</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>那现在是不是就完成了next数组的求解算法了呢？其实仔细思考一下我们会发现这个代码存在一个问题，如下所示：</p> 
<p><img src="https://images2.imgbox.com/88/c8/hLdv1m4z_o.jpg" alt="算法存在问题"></p> 
<p>在这个用例中可以看到，当<code>j == 5, p == 3</code>时，元素发生了失配，下面我们继续按照代码执行：</p> 
<p><img src="https://images2.imgbox.com/0d/fd/L0RFjfS3_o.jpg" alt="算法存在问题2"></p> 
<p>可以看到，此时如果按照代码的步骤进行执行，那我们求出来的<code>next[j+1] = 3</code>。当K[6]发生失配时，此时通过回溯后进行匹配的前缀子串为<code>"abab"</code>，与之匹配的后缀子串为<code>"baaa"</code>，很显然该子串的首元素就已经不匹配了，并不可能出现将K[3]与K[6]进行匹配的情况。为什么会出现这种错误呢？</p> 
<p>产生这个错误的原因其实有两个：1. 回溯对象有误，2. 赋值对象有误。如下图所示：</p> 
<p><img src="https://images2.imgbox.com/7e/6e/jKHWdbKf_o.jpg" alt="求解元素"></p> 
<p>可以看到，此时p指向的元素是K[3]，并不是K[4]，而且失配的元素是K[3]与K[5]发生的失配，因此我们要回溯的对象应该是K[1]，而且下一次匹配是通过K[1]与K[5]进行匹配。</p> 
<p>在<code>KMP</code>算法中我们是通过找到子串失配元素的<code>next[j]</code>所指向的下一个元素进行匹配，而在模式串中，前缀才是子串，因此这里的<code>next[j-1]</code>实际上指的是指针<code>p</code>。<br> <img src="https://images2.imgbox.com/72/37/ob2S0CS6_o.jpg" alt="next[j-1]=p"></p> 
<p>所以算法的正确思路应该是：</p> 
<ul><li>首字符的<code>next[0] = 0 -1 = -1</code>；</li><li>通过前缀指针<code>p</code>指向前缀子串中的串尾元素，通过后缀指针<code>j</code>指向后缀子串中的串尾元素；</li><li>通过指针<code>p</code>和指针<code>j</code>匹配获取的数据为模式串中第<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          j 
         
        
          + 
         
        
          1 
         
        
       
         j+1 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span>个元素所对应的next数组下标；</li><li>当指针p指向的元素与指针j指向的元素匹配成功时，先移动指针，再获取next数组下标，即<code>next[j] = p + 1</code>；</li><li>当指针p指向的元素与指针j指向的元素匹配失败时，则将指针p回溯到<code>next[p]</code>的位置进行匹配，即<code>p = next[p]</code>；</li><li>当<code>p = -1</code>时，说明此时匹配的是获取的第二个元素的next数组下标，此时只需要将指针往后移动使指针p指向模式串首元素，指针j指向模式歘第二个元素，再将首元素的下标赋值给next[j]即可，即<code>next[j] = p + 1</code>；</li></ul> 
<p>现在我们就可以根据改进后的思路进行代码编写了，如下所示：</p> 
<pre><code class="prism language-c"><span class="token comment">//C语言实现next数组</span>
<span class="token keyword">void</span> <span class="token function">get_next</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> T<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> next<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//函数实现——算法优化</span>
	<span class="token comment">//处理首字符</span>
	next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//字符下标从0开始</span>
	<span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//前缀指针</span>
	<span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//指向模式串的指针</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//当匹配成功时</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> T<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">==</span> T<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
			next<span class="token punctuation">[</span><span class="token operator">++</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">++</span>p<span class="token punctuation">;</span><span class="token comment">//先移动指针，再获取next下标</span>
		<span class="token comment">//当匹配失败时</span>
		<span class="token keyword">else</span>
			p <span class="token operator">=</span> next<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//前缀指针回溯到next[p]的位置</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="1433__379"></a>1.4.3.3 算法测试</h5> 
<p>现在我们已经成功的实现了求解next数组的最佳算法，下面我们还是来测试一下算法的正确性：</p> 
<p><img src="https://images2.imgbox.com/ed/6f/QszH09Mv_o.png" alt="算法测试"><br> 可以看到，此时实现的算法也是没有任何问题的。从时间复杂度上分析，我们可以看到优化后的算法的时间复杂度可以近似的视作<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         N 
        
       
         + 
        
       
         M 
        
       
         ) 
        
       
      
        O(N + M) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">M</span><span class="mclose">)</span></span></span></span></span>相比于之前的<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
        
        
          N 
         
        
          2 
         
        
       
         ) 
        
       
      
        O(N^2) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>有了大幅度的提升。</p> 
<h2><a id="KMP_386"></a>二、<code>KMP</code>算法的进一步优化</h2> 
<p>介绍完了next数组C语言实现，不知道朋友们有没有一种熟悉的感觉，算法从<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
        
        
          N 
         
        
          2 
         
        
       
         ) 
        
       
      
        O(N^2) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>进行优化提升至<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         N 
        
       
         + 
        
       
         M 
        
       
         ) 
        
       
      
        O(N + M) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">M</span><span class="mclose">)</span></span></span></span></span>整个算法的提升思路与模式匹配算法的提升思路如出一辙。</p> 
<p>在我看来其实next数组作为<code>KMP</code>算法的核心，它的求解算法也是通过<code>KMP</code>算法才得以实现，因此对<code>KMP</code>算法的优化世界上就是对next数组的进一步优化。</p> 
<h3><a id="21_KMP_391"></a>2.1 <code>KMP</code>算法存在的缺陷</h3> 
<p>目前我们求解的next数组在实际使用中还是会存在进行无意义匹配的问题，如下所示：</p> 
<p><img src="https://images2.imgbox.com/18/df/yqwSmC7M_o.jpg" alt="KMP算法存在的缺陷"></p> 
<p>在这个例子中，根据<code>KMP</code>算法的求解过程，当元素失配时，下一次匹配的对象为<code>next[j]</code>。</p> 
<p>从图中我们可以看到当<code>T[j] == T[next[j]]</code>时，下一次匹配的结果肯定也是不匹配，因此我们需要找到<code>next[next[j]]</code>。在这个例子中我们会发现，此时<code>next[next[j]]</code>是能够与<code>K[i]</code>成功匹配的，再如下一个例子：</p> 
<p><img src="https://images2.imgbox.com/b8/d5/UllnaeI5_o.jpg" alt="KMP算法存在的缺陷2"></p> 
<p>在这个例子中，因为模式串中的元素都是相等的因此，当最后一个元素失配时那就代表前面所有的元素都肯定是失配的，因此我们根据next数组进行匹配的话则会进行5次毫无意义的匹配。</p> 
<p>这两个例子都是在说明目前我们求解的next数组并不是<code>KMP</code>算法中最佳的next数组，为了优化KMP算法，接下来我们就需要从next数组上进行优化。</p> 
<h3><a id="22_nextval_406"></a>2.2 <code>nextval</code>数组</h3> 
<p>当前的next数组中存在的缺陷是当第<code>j</code>个字符失配时，其对应的<code>next[j]</code>指向的元素如果与<code>j</code>相等，那么下一次匹配就相当于使用元素<code>j</code>再与当前元素进行了一次匹配，结果可想而知肯定会失配。因此我们就需要找到与元素<code>j</code>不相等的<code>next[j]</code>。</p> 
<p>为了找到这个与元素<code>j</code>不相等的<code>next[j]</code>，我们不妨对模式串的next数组进一步求解得到一个新的next数组——<code>nextval</code>数组。现在如何求解<code>nextval</code>数组则变成了我们现在需要关心的问题。</p> 
<p>我们先介绍手算的方式，在进行手算<code>nextval</code>数组时，我们只需要通过判断第j个元素与其next[j]所对应的元素是否相等，相等则继续递归找到下一个<code>next[next[j]]</code>，直到找到不相等的元素为止，因此模式串<code>"abcabc"</code>的next数组以及<code>nextval</code>数组如下表所示：</p> 
<table><thead><tr><th>模式串T</th><th>a</th><th>b</th><th>c</th><th>a</th><th>b</th><th>c</th><th>\0</th></tr></thead><tbody><tr><td>下标j</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>^</td></tr><tr><td>next[j]</td><td>-1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td><td>^</td></tr><tr><td>nextval[j]</td><td>-1</td><td>0</td><td>0</td><td>-1</td><td>0</td><td>0</td><td>^</td></tr></tbody></table> 
<p>下面我们可以尝试着将该思路用代码表示：</p> 
<pre><code class="prism language-c"><span class="token comment">//nextval数组</span>
<span class="token keyword">void</span> <span class="token function">nextval</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> T<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">*</span> next<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> T<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//从头开始遍历next数组</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> T<span class="token punctuation">[</span>next<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//当前元素与对应的next[i]相等时</span>
			next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> next<span class="token punctuation">[</span>next<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//对该元素进行一次递归</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>接下来我们来简单测试一下该算法的正确性：</p> 
<p><img src="https://images2.imgbox.com/2c/e9/HjhGybJy_o.png" alt="算法测试"><br> 可以看到此时我们是能够很好的实现<code>nextval</code>数组求解的。</p> 
<p>现在有朋友可能会说，我这写个<code>KMP</code>算法还需要额外写两个函数，感觉好麻烦，我们能不能在求解next数组时直接求解<code>nextval</code>数组呢？</p> 
<p>这个想法我觉得非常棒，下面我们就需要分析一下目前我们求解next数组的算法，看看应该如何改进。</p> 
<p>在前面实现的<code>get_next</code>算法中，我们在整个求解过程只进行了字符匹配的判断，而<code>nextval</code>数组是在字符匹配成功的基础上对字符<code>j</code>与<code>next[j]</code>进行进一步匹配。</p> 
<p>在get_next算法中，元素j所对应的<code>next[j] = p</code>，因此我们不妨直接在匹配成功时直接对字符j与字符p进行匹配，从而直接求得<code>nextval</code>数组，如下所示：</p> 
<pre><code class="prism language-c"><span class="token comment">//C语言实现nextval数组</span>
<span class="token keyword">void</span> <span class="token function">get_nextval</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> T<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> nextval<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//函数实现——算法优化</span>
	<span class="token comment">//处理首字符</span>
	nextval<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//字符下标从0开始</span>
	<span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//前缀指针</span>
	<span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//指向模式串的指针</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//当匹配成功时</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> T<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">==</span> T<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			j<span class="token operator">++</span><span class="token punctuation">,</span> p<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//移动指针</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">==</span> T<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//当需要求解的元素j与指针p指向的元素相匹配时</span>
				nextval<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nextval<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//将元素p的nextval赋值给元素j</span>
			<span class="token keyword">else</span>
				nextval<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span><span class="token comment">//当元素p与next[p]不相等时，直接获取next[j]</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//当匹配失败时</span>
		<span class="token keyword">else</span>
			p <span class="token operator">=</span> nextval<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//前缀指针回溯到next[p]的位置</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>下面我们同样还是以刚才的例子进行测试，结果如下所示：<br> <img src="https://images2.imgbox.com/21/67/Cnr3aLoO_o.png" alt="算法测试2"><br> 可以看到，此时同样也能求得正确的<code>nextval</code>数组。</p> 
<h2><a id="KMP_470"></a>三、KMP算法测试</h2> 
<p>现在我们就完成完整的<code>KMP</code>算法，接下来我们就来测试一下完善后的<code>KMP</code>算法是否能够正常运行，如下所示：</p> 
<p><img src="https://images2.imgbox.com/46/cb/8lYynwwE_o.png" alt="算法测试"><br> 从测试结果中可以看到，现在不管是<code>nextval</code>数组还是串定位都是能够正常运行。</p> 
<h2><a id="_476"></a>四、模式匹配算法的对比</h2> 
<p>下面我们简单的分析一下<code>KMP</code>算法和朴素模式算法。</p> 
<p>在朴素模式匹配算法中，算法的实现是通过指向主串的指针与指向模式串的指针的不断回溯，从而完全主串中所有的子串与模式串的匹配，因此朴素模式匹配算法也可以称为双指针算法。当我们从时间复杂度上来分析该算法时，就主串而言算法的最坏时间复杂度可以达到<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
        
        
          N 
         
        
          2 
         
        
       
         ) 
        
       
      
        O(N^2) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>；</p> 
<p>在<code>KMP</code>算法中，算法的实现是通过<code>nextval</code>数组完成指向模式串的指针的有效回溯，从而快速完成主串与模式串的匹配。就主串而言<code>KMP</code>算法的最坏时间复杂度只有<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         N 
        
       
         ) 
        
       
      
        O(N) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="mclose">)</span></span></span></span></span>；</p> 
<p>两种算法从时间复杂度上来看<code>KMP</code>算法是明显优于朴素模式匹配算法的，但是在我们遇到的实际问题中，朴素模式匹配算法的时间复杂度在一定程度上也是能够达到<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         N 
        
       
         ) 
        
       
      
        O(N) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="mclose">)</span></span></span></span></span>级别，因此朴素模式匹配算法至今任被采用。</p> 
<h2><a id="C_484"></a>五、算法的C语言函数接口</h2> 
<p>下面给大家附上<code>KMP</code>算法和<code>nextval</code>数组以及头文件和测试文件的相关代码：</p> 
<pre><code class="prism language-c"><span class="token comment">//头文件</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token comment">//定长顺序存储</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXSIZE</span> <span class="token expression"><span class="token number">255</span></span><span class="token comment">//最大串长</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">StackString</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span> ch<span class="token punctuation">[</span>MAXSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//存储字符的字符数组</span>
	<span class="token keyword">int</span> length<span class="token punctuation">;</span><span class="token comment">//当前串长</span>
<span class="token punctuation">}</span>SString<span class="token punctuation">;</span><span class="token comment">//重命名后的数据类型名</span>

<span class="token comment">//nextval数组</span>
<span class="token keyword">void</span> <span class="token function">get_nextval</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> T<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> nextval<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//函数实现——算法优化</span>
	<span class="token comment">//处理首字符</span>
	nextval<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//字符下标从0开始</span>
	<span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//前缀指针</span>
	<span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//指向模式串的指针</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//当匹配成功时</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> T<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">==</span> T<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			j<span class="token operator">++</span><span class="token punctuation">,</span> p<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//移动指针</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">==</span> T<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//当需要求解的元素j与指针p指向的元素相匹配时</span>
				nextval<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nextval<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//将元素p的nextval赋值给元素j</span>
			<span class="token keyword">else</span>
				nextval<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span><span class="token comment">//当元素p与next[p]不相等时，直接获取next[j]</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//当匹配失败时</span>
		<span class="token keyword">else</span>
			p <span class="token operator">=</span> nextval<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//前缀指针回溯到next[p]的位置</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//串定位</span>
<span class="token keyword">int</span> <span class="token function">Index_kmp</span><span class="token punctuation">(</span>SString T<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> S<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>S<span class="token punctuation">)</span> 
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> nextval<span class="token punctuation">[</span>MAXSIZE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token function">get_nextval</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> nextval<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取nextval数组</span>
	<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>T<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> S<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> T<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> S<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//匹配成功</span>
			i<span class="token operator">++</span><span class="token punctuation">,</span> j<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//继续匹配下一个元素</span>
		<span class="token keyword">else</span><span class="token comment">//匹配失败</span>
			j <span class="token operator">=</span> nextval<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//模式串回溯到nextval[j]</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token operator">!</span>S<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">?</span> i <span class="token operator">-</span> j <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//KMP算法测试</span>
<span class="token keyword">void</span> <span class="token function">test4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	SString T <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> T<span class="token punctuation">.</span>ch<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		T<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token function">Strlen</span><span class="token punctuation">(</span>T<span class="token punctuation">.</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取主串串长</span>
		<span class="token keyword">char</span> S<span class="token punctuation">[</span>MAXSIZE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//模式串</span>
		<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> S<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取模式串</span>
		<span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token function">Index_kmp</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> S<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"模式串%s在主串%s的位序为%d\n"</span><span class="token punctuation">,</span> S<span class="token punctuation">,</span> T<span class="token punctuation">.</span>ch<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"模式串%s在主串%s的下标为%d\n"</span><span class="token punctuation">,</span> S<span class="token punctuation">,</span> T<span class="token punctuation">.</span>ch<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>index<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"定位操作传参有误，参数为空指针\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">else</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"模式串%s不在主串%s中\n"</span><span class="token punctuation">,</span> S<span class="token punctuation">,</span> T<span class="token punctuation">.</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">test4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_561"></a>总结</h2> 
<p>在今天的内容中我们详细介绍了next数组的C语言实现的过程。</p> 
<p>在这个过程中我们分析了next数组的底层逻辑；</p> 
<p>在进行算法实现时，我们首先通过模拟的方式实现了next数组求解的算法，之后通过对算法的详细剖析，我们完成了对算法从<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
        
        
          N 
         
        
          2 
         
        
       
         ) 
        
       
      
        O(N^2) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>到<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         N 
        
       
         ) 
        
       
      
        O(N) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="mclose">)</span></span></span></span></span>的一个优化；</p> 
<p>接下来我们通过对<code>KMP</code>算法存在的缺陷的分析，了解到了next数组还能进一步优化得到nextval数组，并且我们很好的完成了nextval数组的求解；</p> 
<p>最后我们将朴素模式匹配算法和KMP算法进行了时间复杂度上的对比，我们发现KMP算法是原优于朴素模式匹配算法的，但是在实际问题中，朴素模式匹配算法也是能够达到与KMP算法同级别的时间复杂度，因此至今任被采用。</p> 
<p>今天的内容到这里就全部结束了，如果大家喜欢博主的作品，大家可以点赞、评论加收藏支持一下博主，当然也可以转发给身边需要的朋友。最后感谢大家的支持，咱们下一篇再见！！！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/68244e74eb0467a10a192a6f8e6c03ea/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">iRemovalPro完美解4G信号,支持A12&#43;,支持6S~14ProMax，支持iOS17.4&#43;</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fb659799af68f18440aaa3a44f9fc4dc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AI绘画保姆级教程 | 比Remini更好的黏土风格</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>