<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Kafka 和 RabbitMQ用哪个？一篇文章告诉你他们的区别 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/688cef79a44271996af4404bd0b85756/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Kafka 和 RabbitMQ用哪个？一篇文章告诉你他们的区别">
  <meta property="og:description" content="经常有人问我 有个 xx 需求，我应该用 Kafka 还是 RabbitMQ ？
这个问题很常见，而且很多人对二者的选择也把握不好。
所以我决定写篇文章来详细说一下：Kafka 和 RabbitMQ 的区别，适用于什么场景？
同时，这个问题在面试中也经常问到。
下面我会通过 6 个场景，来对比分析一下 Kafka 和 RabbitMQ 的优劣。
一、消息的顺序 有这样一个需求：当订单状态变化的时候，把订单状态变化的消息发送给所有关心订单变化的系统。
订单会有创建成功、待付款、已支付、已发货的状态，状态之间是单向流动的。
​
好，现在我们把订单状态变化消息要发送给所有关心订单状态的系统上去，实现方式就是用消息队列。
​
在这种业务下，我们最想要的是什么？
消息的顺序：对于同一笔订单来说，状态的变化都是有严格的先后顺序的。
吞吐量：像订单的业务，我们自然希望订单越多越好。订单越多，吞吐量就越大。
在这种情况下，我们先看看 RabbitMQ 是怎么做的。
首先，对于发消息，并广播给多个消费者这种情况，RabbitMQ 会为每个消费者建立一个对应的队列。也就是说，如果有 10 个消费者，RabbitMQ 会建立 10 个对应的队列。然后，当一条消息被发出后，RabbitMQ 会把这条消息复制 10 份放到这 10 个队列里。
​
当 RabbitMQ 把消息放入到对应的队列后，我们紧接着面临的问题就是，我们应该在系统内部启动多少线程去从消息队列中获取消息。
如果只是单线程去获取消息，那自然没有什么好说的。但是多线程情况，可能就会有问题了……
RabbitMQ 有这么个特性，它在官方文档就声明了自己是不保证多线程消费同一个队列的消息，一定保证顺序的。而不保证的原因，是因为多线程时，当一个线程消费消息报错的时候，RabbitMQ 会把消费失败的消息再入队，此时就可能出现乱序的情况。
​
T0 时刻，队列中有四条消息 A1、B1、B2、A2。其中 A1、A2 表示订单 A 的两个状态：待付款、已付款。B1、B2 也同理，是订单 B 的待付款、已付款。
到了 T1 时刻，消息 A1 被线程 1 收到，消息 B1 被线程 2 收到。此时，一切都还正常。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-14T10:41:21+08:00">
    <meta property="article:modified_time" content="2024-05-14T10:41:21+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Kafka 和 RabbitMQ用哪个？一篇文章告诉你他们的区别</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4><a id="_0"></a>经常有人问我</h4> 
<blockquote> 
 <p>有个 xx 需求，我应该用 Kafka 还是 RabbitMQ ？<br> 这个问题很常见，而且很多人对二者的选择也把握不好。</p> 
</blockquote> 
<p>所以我决定写篇文章来详细说一下：Kafka 和 RabbitMQ 的区别，适用于什么场景？</p> 
<p>同时，这个问题在面试中也经常问到。</p> 
<p>下面我会通过 6 个场景，来对比分析一下 Kafka 和 RabbitMQ 的优劣。</p> 
<h3><a id="_10"></a>一、消息的顺序</h3> 
<p>有这样一个需求：当订单状态变化的时候，把订单状态变化的消息发送给所有关心订单变化的系统。</p> 
<p>订单会有创建成功、待付款、已支付、已发货的状态，状态之间是单向流动的。</p> 
<p><img src="https://images2.imgbox.com/a4/d0/XBcuARBP_o.png" alt=""></p> 
<p>​</p> 
<p>好，现在我们把订单状态变化消息要发送给所有关心订单状态的系统上去，实现方式就是用消息队列。</p> 
<p><img src="https://images2.imgbox.com/9c/fb/hp8jaXid_o.png" alt=""></p> 
<p>​</p> 
<p>在这种业务下，我们最想要的是什么？</p> 
<ol><li> <p>消息的顺序：对于同一笔订单来说，状态的变化都是有严格的先后顺序的。</p> </li><li> <p>吞吐量：像订单的业务，我们自然希望订单越多越好。订单越多，吞吐量就越大。</p> </li></ol> 
<p>在这种情况下，我们先看看 RabbitMQ 是怎么做的。</p> 
<p>首先，对于发消息，并广播给多个消费者这种情况，RabbitMQ 会为每个消费者建立一个对应的队列。也就是说，如果有 10 个消费者，RabbitMQ 会建立 10 个对应的队列。然后，当一条消息被发出后，RabbitMQ 会把这条消息复制 10 份放到这 10 个队列里。</p> 
<p><img src="https://images2.imgbox.com/b5/77/6Bvp8jdn_o.png" alt=""></p> 
<p>​</p> 
<p>当 RabbitMQ 把消息放入到对应的队列后，我们紧接着面临的问题就是，我们应该在系统内部启动多少线程去从消息队列中获取消息。</p> 
<p>如果只是单线程去获取消息，那自然没有什么好说的。但是多线程情况，可能就会有问题了……</p> 
<p>RabbitMQ 有这么个特性，它在官方文档就声明了自己是不保证多线程消费同一个队列的消息，一定保证顺序的。而不保证的原因，是因为多线程时，当一个线程消费消息报错的时候，RabbitMQ 会把消费失败的消息再入队，此时就可能出现乱序的情况。</p> 
<p><img src="https://images2.imgbox.com/26/50/cOyyEAye_o.png" alt=""></p> 
<p>​</p> 
<p>T0 时刻，队列中有四条消息 A1、B1、B2、A2。其中 A1、A2 表示订单 A 的两个状态：待付款、已付款。B1、B2 也同理，是订单 B 的待付款、已付款。</p> 
<p>到了 T1 时刻，消息 A1 被线程 1 收到，消息 B1 被线程 2 收到。此时，一切都还正常。</p> 
<p>到了 T3 时刻，B1 消费出错了，同时呢，由于线程 1 处理速度快，又从消息队列中获取到了 B2。此时，问题开始出现。</p> 
<p>到了 T4 时刻，由于 RabbitMQ 线程消费出错，可以把消息重新入队的特性，此时 B1 会被重新放到队列头部。所以，如果不凑巧，线程 1 获取到了 B1，就出现了乱序情况，B2 状态明明是 B1 的后续状态，却被提前处理了。</p> 
<p>所以，可以看到了，这个场景用 RabbitMQ，出现了三个问题：</p> 
<ol><li>为了实现发布订阅功能，从而使用的消息复制，会降低性能并耗费更多资源</li><li>多个消费者无法严格保证消息顺序</li><li>大量的订单集中在一个队列，吞吐量受到了限制</li></ol> 
<p>那么 Kafka 怎么样呢？Kafka 正好在这三个问题上，表现的要比 RabbitMQ 要好得多。</p> 
<p>首先，Kafka 的发布订阅并不会复制消息，因为 Kafka 的发布订阅就是消费者直接去获取被 Kafka 保存在日志文件中的消息就好。无论是多少消费者，他们只需要主动去找到消息在文件中的位置即可。</p> 
<p>其次，Kafka 不会出现消费者出错后，把消息重新入队的现象。</p> 
<p>最后，Kafka 可以对订单进行分区，把不同订单分到多个分区中保存，这样，吞吐量能更好。</p> 
<p>所以，对于这个需求 Kafka 更合适。</p> 
<h3><a id="_74"></a>二、消息的匹配</h3> 
<p>我曾经做过一套营销系统。这套系统中有个非常显著的特点，就是非常复杂非常灵活地匹配规则。</p> 
<p>比如，要根据推广内容去匹配不同的方式做宣传。又比如，要根据不同的活动去匹配不同的渠道去做分发。</p> 
<p>总之，数不清的匹配规则是这套系统中非常重要的一个特点。</p> 
<p><img src="https://images2.imgbox.com/d9/df/e2qYPtaV_o.png" alt=""></p> 
<p>​</p> 
<p>首先，先看看 RabbitMQ 的，你会发现 RabbitMQ 是允许在消息中添加 routing_key 或者自定义消息头，然后通过一些特殊的 Exchange，很简单的就实现了消息匹配分发。开发几乎不用成本。</p> 
<p>而 Kafka 呢？如果你要实现消息匹配，开发成本高多了。</p> 
<p>首先，通过简单的配置去自动匹配和分发到合适的消费者端这件事是不可能的。</p> 
<p>其次，消费者端必须先把所有消息不管需要不需要，都取出来。然后，再根据业务需求，自己去实现各种精准和模糊匹配。可能因为过度的复杂性，还要引入规则引擎。</p> 
<p>这个场景下 RabbitMQ 扳回一分。</p> 
<h3><a id="_96"></a>三、消息的超时</h3> 
<p>在电商业务里，有个需求：下单之后，如果用户在 15 分钟内未支付，则自动取消订单。</p> 
<p>你可能奇怪，这种怎么也会用到消息队列的？</p> 
<p>我来先简单解释一下，在单一服务的系统，可以起个定时任务就搞定了。</p> 
<p>但是，在 SOA 或者微服务架构下，这样做就不行了。因为很多个服务都关心是否支付这件事，如果每种服务，都自己实现一套定时任务的逻辑，既重复，又难以维护。</p> 
<p>在这种情况下，我们往往会做一层抽象：把要执行的任务封装成消息。当时间到了，直接扔到消息队列里，消息的订阅者们获取到消息后，直接执行即可。</p> 
<p>希望把消息延迟一定时间再处理的，被称为延迟队列。</p> 
<p>对于订单取消的这种业务，我们就会在创建订单的时候，同时扔一个包含了执行任务信息的消息到延迟队列，指定15分钟后，让订阅这个队列的各个消费者，可以收到这个消息。随后，各个消费者所在的系统就可以去执行相关的扫描订单的任务了。</p> 
<p><img src="https://images2.imgbox.com/d7/3e/4KNua7Wa_o.png" alt=""></p> 
<p>​</p> 
<h4><a id="RabbitMQ__Kafka__116"></a>RabbitMQ 和 Kafka 消息队列如何选？</h4> 
<p>先看下 RabbitMQ 的。</p> 
<p>RabbitMQ 的消息自带手表，消息中有个 TTL 字段，可以设置消息在 RabbitMQ 中的存放的时间，超时了会被移送到一个叫死信队列的地方。</p> 
<p>所以，延迟队列 RabbitMQ 最简单的实现方式就是设置 TTL，然后一个消费者去监听死信队列。当消息超时了，监听死信队列的消费者就收到消息了。</p> 
<p>不过，这样做有个大问题：假设，我们先往队列放入一条过期时间是 10 秒的 A 消息，再放入一条过期时间是 5 秒的 B 消息。 那么问题来了，B 消息会先于 A 消息进入死信队列吗？</p> 
<p>答案是否定的。B 消息会优先遵守队列的先进先出规则，在 A 消息过期后，和其一起进入死信队列被消费者消费。</p> 
<p>在 RabbitMQ 的 3.5.8 版本以后，官方推荐的 rabbitmq delayed message exchange 插件可以解决这个问题。</p> 
<ul><li>用了这个插件，我们在发送消息的时候，把消息发往一个特殊的 Exchange。</li><li>同时，在消息头里指定要延迟的时间。</li><li>收到消息的 Exchange 并不会立即把消息放到队列里，而是在消息延迟时间到达后，才会把消息放入。</li></ul> 
<p><img src="https://images2.imgbox.com/6a/ef/33tJSOO7_o.png" alt=""></p> 
<p>​</p> 
<p>再看下 Kafka 的：</p> 
<p><img src="https://images2.imgbox.com/c6/71/BkG9npHj_o.png" alt=""></p> 
<p>​</p> 
<p>Kafka 要实现延迟队列就很麻烦了。</p> 
<ul><li>你先需要把消息先放入一个临时的 topic。</li><li>然后得自己开发一个做中转的消费者。让这个中间的消费者先去把消息从这个临时的 topic 取出来。</li><li>取出来，这消息还不能马上处理啊，因为没到时间呢。也没法保存在自己的内存里，怕崩溃了，消息没了。所以，就得把没有到时间的消息存入到数据库里。</li><li>存入数据库中的消息需要在时间到了之后再放入到 Kafka 里，以便真正的消费者去执行真正的业务逻辑。</li><li>……</li></ul> 
<p>想想就已经头大了，这都快搞成调度平台了。再高级点，还要用时间轮算法才能更好更准确。</p> 
<p>这次，RabbitMQ 上那一条条戴手表的消息，才是最好的选择。</p> 
<h3><a id="_156"></a>四、消息的保持</h3> 
<p>在微服务里，事件溯源模式是经常用到的。如果想用消息队列实现，一般是把事件当成消息，依次发送到消息队列中。</p> 
<p>事件溯源有个最经典的场景，就是事件的重放。简单来讲就是把系统中某段时间发生的事件依次取出来再处理。而且，根据业务场景不同，这些事件重放很可能不是一次，更可能是重复 N 次。</p> 
<p>假设，我们现在需要一批在线事件重放，去排查一些问题。</p> 
<p>RabbitMQ 此时就真的不行了，因为消息被人取出来就被删除了。想再次被重复消费？对不起。</p> 
<p>而 Kafka 呢，消息会被持久化一个专门的日志文件里。不会因为被消费了就被删除。</p> 
<p>所以，对消息不离不弃的 Kafka 相对用过就抛的 RabbitMQ，请选择 Kafka。</p> 
<h3><a id="_170"></a>五、消息的错误处理</h3> 
<p>很多时候，在做记录数据相关业务的时候，Kafka 一般是不二选择。不过，有时候在记录数据吞吐量不大时，我自己倒是更喜欢用 RabbitMQ。</p> 
<p>原因就是 Kafka 有一个我很不喜欢的设计原则：</p> 
<p>当单个分区中的消息一旦出现消费失败，就只能停止而不是跳过这条失败的消息继续消费后面的消息。即不允许消息空洞。</p> 
<p>只要消息出现失败，不管是 Kafka 自身消息格式的损坏，还是消费者处理出现异常，是不允许跳过消费失败的消息继续往后消费的。</p> 
<p>所以，在<strong>数据统计不要求十分精确</strong>的场景下选了 Kafka，一旦出现了消息消费问题，就会发生项目不可用的情况。这真是徒增烦恼。</p> 
<p>而 RabbitMQ 呢，它由于会在消息出问题或者消费错误的时候，可以重新入队或者移动消息到死信队列，继续消费后面的，会省心很多。</p> 
<p>坏消息就像群众中的坏蛋那样，Kafka 处理这种坏蛋太过残暴，非得把坏蛋揪出来不行。相对来说，RabbitMQ 就温柔多了，群众是群众，坏蛋是坏蛋，分开处理嘛。</p> 
<h3><a id="_186"></a>六、消息的吞吐量</h3> 
<p>Kafka 是每秒几十万条消息吞吐，而 RabbitMQ 的吞吐量是每秒几万条消息。</p> 
<p>其实，在一家公司内部，有必须用到 Kafka 那么大吞吐量的项目真的很少。大部分项目，像 RabbitMQ 那样每秒几万的消息吞吐，已经非常够了。</p> 
<p>在一些没那么大吞吐量的项目中引入 Kafka，我觉得就不如引入 RabbitMQ。</p> 
<p>为什么呢？</p> 
<p>因为 Kafka 为了更好的吞吐量，很大程度上增加了自己的复杂度。而这些复杂度对项目来说，就是麻烦，主要体现在两个方面：</p> 
<p>1、配置复杂、维护复杂</p> 
<p>Kafka 的参数配置相对 RabbitMQ 是很复杂的。比如：磁盘管理相关参数，集群管理相关参数，ZooKeeper 交互相关参数，Topic 级别相关参数等，都需要一些思考和调优。</p> 
<p>另外，Kafka 本身集群和参与管理集群的 ZooKeeper，这就带来了更多的维护成本。Kafka 要用好，你要考虑 JVM，消息持久化，集群本身交互，以及 ZooKeeper 本身和它与 Kafka 之间的可靠和效率。</p> 
<p>2、用好，用对存在门槛</p> 
<p>Kafka 的 Producer 和 Consumer 本身要用好用对也存在很高的门槛。</p> 
<p>比如，Producer 消息可靠性保障、幂等性、事务消息等，都需要对 KafkaProducer 有深入的了解。</p> 
<p>而 Consumer 更不用说了，光是一个日志偏移管理就让一大堆人掉了不少头发。</p> 
<p>相对来说，RabbitMQ 就简单得多。你可能都不用配置什么，直接启动起来就能很稳定可靠地使用了。就算配置，也是寥寥几个参数设置即可。</p> 
<p>所以，大家在项目中引入消息队列的时候，真的要好好考虑下，不要因为大家都鼓吹 Kafka 好，就无脑引入。</p> 
<h3><a id="_216"></a>总结</h3> 
<p>可以看到，如果我们要做消息队列选型，有两件事是必须要做好的：</p> 
<ol><li> <p>列出业务最重要的几个特点</p> </li><li> <p>深入到消息队列的细节中去比较</p> </li></ol> 
<p>等我们对这些中间件的特点非常熟悉之后，甚至可以把业务分解成不同的子业务，再根据不同的子业务的特征，引入不同的消息队列，即消息队列混用。这样，我们就可能会最大化我们的获益，最小化我们的成本。</p> 
<p>说了这么多，其实还有很多 Kafka 和 RabbitMQ 的比较没有说，比如二者集群的区别，占用资源多少的比较等。以后有机会可以再提提。</p> 
<p>总之，期待大家看完这篇文章后，能对 Kafka 和 RabbitMQ 的区别有了更细节性的了解。</p> 
<p>最后，分享一个网上的比较全的对比图：</p> 
<p><img src="https://images2.imgbox.com/6f/3f/GDluGJlp_o.png" alt=""></p> 
<p>​</p> 
<p><img src="https://images2.imgbox.com/30/63/SePp758s_o.png" alt=""></p> 
<p>​</p> 
<p><img src="https://images2.imgbox.com/87/fc/YLNYOsDa_o.png" alt=""></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ec6cffdaca2913b58b5e1e202bd8621f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java mapper批量更新、插入、查询</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c616c013250d7c3760720db14b74e79f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">爆肝！超详细的胎教级Midjourney使用教程，看这一篇就够！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>