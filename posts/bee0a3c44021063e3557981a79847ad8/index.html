<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;】构造函数、析构函数、拷贝构造与运算符重载 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/bee0a3c44021063e3557981a79847ad8/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;】构造函数、析构函数、拷贝构造与运算符重载">
  <meta property="og:description" content="文章目录 1.类的六个默认构造函数2.构造函数2.1特性2.1.1 函数名与类名相同2.1.2. 无返回值（不能写void）2.1.3. 对象实例化时编译器自动调用对应的构造函数2.1.4 构造函数可以重载2.1.5编译器生成默认的构造函数2.1.6编译器生成的默认构造有何用？2.1.7三种默认构造函数 3.析构函数3.1特性3.1.1析构函数名是在类名前加上字符 ~3.1.2无参数无返回值类型（不能写void）3.1.3一个类只能有一个析构函数。3.1.4对象生命周期结束时，编译系统自动调用析构函数3.1.5编译器生成的默认析构函数 4.拷贝构造4.1特征4.1.1拷贝构造函数是构造函数的一个重载形式4.1.2拷贝构造函数的参数4.1.3编译器生成默认的拷贝构造函数(浅拷贝)4.1.4拷贝构造函数典型调用场景： 5.赋值运算符重载5.1运算符重载5.2赋值运算符重载5.2.1赋值运算符重载格式5.2.2返回值类型5.2.3检测是否自己给自己赋值5.2.4注意返回值5.2.5重载成类的成员函数5.2.6默认赋值运算符重载 5.3前置&#43;&#43;与后置&#43;&#43;重载5.4运算符重载拓展 6.const成员函数7.取地址及const取地址操作符重载 1.类的六个默认构造函数 如果一个类中什么成员都没有，简称为空类。
class test { }; 空类中真的什么都没有吗？并不是，任何类在什么都不写时，编译器会自动生成以下6个默认成员函数。
默认成员函数：用户没有显式实现，编译器自动生成的成员函数称为默认成员函数。
2.构造函数 class Data { public: void Init(int year = 1, int month = 1, int day = 1) { this-&gt;_year = year; this-&gt;_month = month; this-&gt;_day = day; } void Print() { cout &lt;&lt; _year &lt;&lt; &#34;-&#34; &lt;&lt; _month &lt;&lt; &#34;-&#34; &lt;&lt; _day &lt;&lt; endl; } private: int _year; int _month; int _day; }; int main() { Data d1; d1.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-28T13:35:49+08:00">
    <meta property="article:modified_time" content="2024-05-28T13:35:49+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;】构造函数、析构函数、拷贝构造与运算符重载</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1_3" rel="nofollow">1.类的六个默认构造函数</a></li><li><a href="#2_20" rel="nofollow">2.构造函数</a></li><li><ul><li><a href="#21_60" rel="nofollow">2.1特性</a></li><li><ul><li><a href="#211__64" rel="nofollow">2.1.1 函数名与类名相同</a></li><li><a href="#212_void_65" rel="nofollow">2.1.2. 无返回值（不能写void）</a></li><li><a href="#213__69" rel="nofollow">2.1.3. 对象实例化时编译器自动调用对应的构造函数</a></li><li><a href="#214__73" rel="nofollow">2.1.4 构造函数可以重载</a></li><li><a href="#215_79" rel="nofollow">2.1.5编译器生成默认的构造函数</a></li><li><a href="#216_89" rel="nofollow">2.1.6编译器生成的默认构造有何用？</a></li><li><a href="#217_111" rel="nofollow">2.1.7三种默认构造函数</a></li></ul> 
  </li></ul> 
  </li><li><a href="#3_127" rel="nofollow">3.析构函数</a></li><li><ul><li><a href="#31_130" rel="nofollow">3.1特性</a></li><li><ul><li><a href="#311__131" rel="nofollow">3.1.1析构函数名是在类名前加上字符 ~</a></li><li><a href="#312void_132" rel="nofollow">3.1.2无参数无返回值类型（不能写void）</a></li><li><a href="#313_134" rel="nofollow">3.1.3一个类只能有一个析构函数。</a></li><li><a href="#314_136" rel="nofollow">3.1.4对象生命周期结束时，编译系统自动调用析构函数</a></li><li><a href="#315_193" rel="nofollow">3.1.5编译器生成的默认析构函数</a></li></ul> 
  </li></ul> 
  </li><li><a href="#4_206" rel="nofollow">4.拷贝构造</a></li><li><ul><li><a href="#41_212" rel="nofollow">4.1特征</a></li><li><ul><li><a href="#411_214" rel="nofollow">4.1.1拷贝构造函数是构造函数的一个重载形式</a></li><li><a href="#412_254" rel="nofollow">4.1.2拷贝构造函数的参数</a></li><li><a href="#413_269" rel="nofollow">4.1.3编译器生成默认的拷贝构造函数(浅拷贝)</a></li><li><a href="#414_276" rel="nofollow">4.1.4拷贝构造函数典型调用场景：</a></li></ul> 
  </li></ul> 
  </li><li><a href="#5_323" rel="nofollow">5.赋值运算符重载</a></li><li><ul><li><a href="#51_385" rel="nofollow">5.1运算符重载</a></li><li><a href="#52_465" rel="nofollow">5.2赋值运算符重载</a></li><li><ul><li><a href="#521_467" rel="nofollow">5.2.1赋值运算符重载格式</a></li><li><a href="#522_469" rel="nofollow">5.2.2返回值类型</a></li><li><a href="#523_529" rel="nofollow">5.2.3检测是否自己给自己赋值</a></li><li><a href="#524_532" rel="nofollow">5.2.4注意返回值</a></li><li><a href="#525_535" rel="nofollow">5.2.5重载成类的成员函数</a></li><li><a href="#526_539" rel="nofollow">5.2.6默认赋值运算符重载</a></li></ul> 
   </li><li><a href="#53_544" rel="nofollow">5.3前置++与后置++重载</a></li><li><a href="#54_551" rel="nofollow">5.4运算符重载拓展</a></li></ul> 
  </li><li><a href="#6const_601" rel="nofollow">6.const成员函数</a></li><li><a href="#7const_608" rel="nofollow">7.取地址及const取地址操作符重载</a></li></ul> 
</div> 
<p></p> 
<p><img src="https://images2.imgbox.com/c6/31/8bB14D7f_o.gif" alt="在这里插入图片描述"></p> 
<h2><a id="1_3"></a>1.类的六个默认构造函数</h2> 
<p>如果一个类中什么成员都没有，简称为空类。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">test</span>
<span class="token punctuation">{<!-- --></span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>空类中真的什么都没有吗？并不是，任何类在什么都不写时，编译器会自动生成以下6个默认成员函数。</p> 
<p><mark>默认成员函数</mark>：<strong>用户没有显式实现</strong>，<strong>编译器自动生成</strong>的成员函数称为默认成员函数。<br> <img src="https://images2.imgbox.com/e8/c1/EWGjUHYg_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="2_20"></a>2.构造函数</h2> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Data</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">Init</span><span class="token punctuation">(</span><span class="token keyword">int</span> year <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">int</span> month <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">int</span> day <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">this</span><span class="token operator">-&gt;</span>_year <span class="token operator">=</span> year<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token operator">-&gt;</span>_month <span class="token operator">=</span> month<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token operator">-&gt;</span>_day <span class="token operator">=</span> day<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> _year <span class="token operator">&lt;&lt;</span> <span class="token string">"-"</span> <span class="token operator">&lt;&lt;</span> _month <span class="token operator">&lt;&lt;</span> <span class="token string">"-"</span> <span class="token operator">&lt;&lt;</span> _day <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _year<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _month<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _day<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Data d1<span class="token punctuation">;</span>
	d1<span class="token punctuation">.</span><span class="token function">Init</span><span class="token punctuation">(</span><span class="token number">2024</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	d1<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	Data d2<span class="token punctuation">;</span>
	d2<span class="token punctuation">.</span><span class="token function">Init</span><span class="token punctuation">(</span><span class="token number">2024</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	d2<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>对于上方的Date类，可以通过 Init 公有方法给对象设置日期，但如果每次创建对象时都调用该方法设置信息，未免有点麻烦，那能否在对象创建时，就将信息设置进去呢？</p> 
<p><mark>构造函数</mark>是一个特殊的成员函数，<strong>名字与类名相同</strong>，创建类类型对象时由<code>编译器自动调用</code>，以保证每个数据成员都有 一个合适的初始值，并且在对象整个生命周期内<strong>只调用一次。</strong></p> 
<h3><a id="21_60"></a>2.1特性</h3> 
<p>构造函数是特殊的成员函数，需要注意的是，构造函数虽然名称叫构造，但是<mark>构造函数的主要任务并<strong>不是开空间创建对象</strong>，而是初始化对象</mark>。</p> 
<p>特性：</p> 
<h4><a id="211__64"></a>2.1.1 函数名与类名相同</h4> 
<h4><a id="212_void_65"></a>2.1.2. 无返回值（不能写void）</h4> 
<p><img src="https://images2.imgbox.com/14/e6/6z1NgZuV_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="213__69"></a>2.1.3. 对象实例化时编译器自动调用对应的构造函数</h4> 
<p><img src="https://images2.imgbox.com/90/d6/4gbF3Hfu_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="214__73"></a>2.1.4 构造函数可以重载</h4> 
<p><img src="https://images2.imgbox.com/50/5c/UzVnyqwe_o.png" alt="在这里插入图片描述"></p> 
<p><mark>特别注意：在调用无参构造时，后面不能跟括号。</mark><br> <img src="https://images2.imgbox.com/4a/58/nbz7wFtC_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="215_79"></a>2.1.5编译器生成默认的构造函数</h4> 
<p>如果类中<mark>没有显式定义构造函数</mark>，则C++<mark>编译器会自动生成一个无参的默认构造函数</mark>，<code>一旦用户显式定义编译器将不再生成</code>。</p> 
<p>未显示定义，编译器自动生成，可以通过编译</p> 
<p><img src="https://images2.imgbox.com/f2/cc/QGVni90N_o.png" alt="在这里插入图片描述"></p> 
<p>若显示定义了构造函数，编译器不再生成；即没有默认构造函数，编译报错。</p> 
<p><img src="https://images2.imgbox.com/1c/80/eiKvvBEA_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="216_89"></a>2.1.6编译器生成的默认构造有何用？</h4> 
<p>不实现构造函数的情况下，编译器会生成默认的构造函数。但是看起来默认构造函数又没什么用？<br> 下面代码中，d对象调用了编译器生成的默认构造函数，但是d对象_year/_month/_day，依旧是随机值。也就说在这里编译器生成的默认构造函数并没有什么用？？<br> <img src="https://images2.imgbox.com/e1/59/UAOQ3wBF_o.png" alt="在这里插入图片描述"></p> 
<p>存在即合理，它还是有一定的用处的。<br> C++把类型分成内置类型(基本类型)和自定义类型。</p> 
<ul><li>内置类型就是语言提供的数据类型，如：int/char/float/任何类型的指针…，</li><li>自定义类型就是我们使用class/struct/union等自己定义的类型，</li></ul> 
<p><mark>对于内置类型来说，C++标准并没有规定要不要处理（可处理，可不处理，取决于编译器）</mark></p> 
<p><mark>对于自定义类型来说，会调用该类型的默认构造函数</mark></p> 
<p>看看下面的程序，就会发现编译器生成默认的构造函数会对自定类型成员 _t 调用的它的默认成员函数。<br> <img src="https://images2.imgbox.com/e9/6f/V1zWf7iu_o.png" alt="在这里插入图片描述"></p> 
<p>注意：：C++11 中针对内置类型成员不初始化的缺陷，又打了补丁，即：内置类型成员变量<mark>在类中声明时可以给默认值</mark>（类中不是定义，类的实例化才是定义，<code>易错</code>）<br> <img src="https://images2.imgbox.com/84/d3/L3vzUWIp_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="217_111"></a>2.1.7三种默认构造函数</h4> 
<p><strong>无参的构造函数</strong>和<strong>全缺省的构造函数</strong>都称为默认构造函数，并且<mark>默认构造函数只能有一个。</mark></p> 
<p>三种默认构造函数：</p> 
<ul><li>无参构造函数</li><li>全缺省构造函数</li><li>我们没写编译器默认生成的构造函数</li></ul> 
<p>注意：无参构造与全缺省的构造只能存在一个，否则会存在调用歧义<br> <img src="https://images2.imgbox.com/82/f9/1hyK7yIf_o.png" alt="在这里插入图片描述"></p> 
<p>总结：</p> 
<ul><li><mark>无需传参就可以调用的构造函数就是默认构造函数</mark>。</li><li>一般情况下，构造函数都需要我们显示的去实现。</li><li>只有少数情况下可让编译器自动生成构造函数，例如成员全是自定义类型</li></ul> 
<h2><a id="3_127"></a>3.析构函数</h2> 
<p>析构函数：与构造函数功能相反，析构函数不是完成对象本身的销毁工作，局部对象销毁工作是由编译器完成的。而<mark>对象在销毁时会自动调用析构函数，完成对象中资源的清理工作。</mark></p> 
<h3><a id="31_130"></a>3.1特性</h3> 
<h4><a id="311__131"></a>3.1.1析构函数名是在类名前加上字符 ~</h4> 
<h4><a id="312void_132"></a>3.1.2无参数无返回值类型（不能写void）</h4> 
<p><img src="https://images2.imgbox.com/cc/87/OeM5RR5W_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="313_134"></a>3.1.3一个类只能有一个析构函数。</h4> 
<p>一个类只能有一个析构函数若未显式定义，系统会自动生成默认的析构函数。注意：<mark>析构函数不能重载。</mark></p> 
<h4><a id="314_136"></a>3.1.4对象生命周期结束时，编译系统自动调用析构函数</h4> 
<p>可以借助调试看一眼，我们并没有调用析构函数，但是在代码179行按F11会自动进入析构函数。</p> 
<p><img src="https://images2.imgbox.com/91/2f/ko27L7Qb_o.gif" alt="在这里插入图片描述"></p> 
<p>上面的代码我们好像没有看出来析构函数有什么用，那就看下面的代码：<br> 下方代码我们简单的实现了一个栈，此时编译器自动调用栈所实现的析构函数，会将我们所申请的资源清理掉。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">int</span> DataType<span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Stack</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token comment">//构造</span>
	<span class="token function">Stack</span><span class="token punctuation">(</span>size_t capacity <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">this</span><span class="token operator">-&gt;</span>_array <span class="token operator">=</span> <span class="token punctuation">(</span>DataType<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>DataType<span class="token punctuation">)</span> <span class="token operator">*</span> capacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> _array<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"malloc申请空间失败!!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">this</span><span class="token operator">-&gt;</span>_capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token operator">-&gt;</span>_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">void</span> <span class="token function">Push</span><span class="token punctuation">(</span>DataType data<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">// CheckCapacity();</span>
		_array<span class="token punctuation">[</span>_size<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">;</span>
		_size<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//析构</span>
	<span class="token operator">~</span><span class="token function">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
 		<span class="token keyword">if</span> <span class="token punctuation">(</span>_array<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">free</span><span class="token punctuation">(</span>_array<span class="token punctuation">)</span><span class="token punctuation">;</span>
			_array <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
			_capacity <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
			_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	DataType<span class="token operator">*</span> _array<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _capacity<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _size<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Stack s<span class="token punctuation">;</span>
	s<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	s<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/85/c0/rD5E56dj_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="315_193"></a>3.1.5编译器生成的默认析构函数</h4> 
<p>关于编译器自动生成的析构函数，是否会完成一些事情呢？<br> 下面的程序我们会看到，编译器生成的默认析构函数，对自定类型成员调用它的析构函数；对内置类型成员不做处理。</p> 
<p><img src="https://images2.imgbox.com/5c/30/PbUfoB4u_o.png" alt="在这里插入图片描述"></p> 
<p>总结：</p> 
<ol><li>有资源需要清理的，就需要写析构函数，<mark>否则会造成内存泄漏问题</mark>。如：栈、链表…</li><li>有两种情况不需要写析构，编译器默认生成的就可以<br> a.全是内置类型的成员，没有资源需要清理的。如Date类…<br> b.内置类型成员无需清理，其它都是自定义类型的成员。如两个栈实现一个队列</li></ol> 
<h2><a id="4_206"></a>4.拷贝构造</h2> 
<p>在创建对象时，可否创建一个与已存在对象一模一样的新对象呢？</p> 
<p><strong>拷贝构造函数</strong>：只有单个形参，该<mark>形参是对本类类型对象的引用(一般常用const修饰)</mark>，在<code>用已存在的类类型对象创建新对象</code>时<mark>由编译器自动调用</mark>。</p> 
<h3><a id="41_212"></a>4.1特征</h3> 
<p>拷贝构造函数也是特殊的成员函数，其特征如下：</p> 
<h4><a id="411_214"></a>4.1.1拷贝构造函数是构造函数的一个重载形式</h4> 
<p><mark>没有返回值</mark></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Date</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token comment">//构造函数</span>
	<span class="token function">Date</span><span class="token punctuation">(</span><span class="token keyword">int</span> year<span class="token punctuation">,</span> <span class="token keyword">int</span> month<span class="token punctuation">,</span> <span class="token keyword">int</span> day<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">this</span><span class="token operator">-&gt;</span>_year <span class="token operator">=</span> year<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token operator">-&gt;</span>_month <span class="token operator">=</span> month<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token operator">-&gt;</span>_day <span class="token operator">=</span> day<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//拷贝构造</span>
	<span class="token function">Date</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date<span class="token operator">&amp;</span> d<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">this</span><span class="token operator">-&gt;</span>_year <span class="token operator">=</span> d<span class="token punctuation">.</span>_year<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token operator">-&gt;</span>_month <span class="token operator">=</span> d<span class="token punctuation">.</span>_month<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token operator">-&gt;</span>_day <span class="token operator">=</span> d<span class="token punctuation">.</span>_day<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _year<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _month<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _day<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Date <span class="token function">d1</span><span class="token punctuation">(</span><span class="token number">2024</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//拷贝构造</span>
	<span class="token comment">//以下两种方式等价</span>
	Date <span class="token function">d2</span><span class="token punctuation">(</span>d1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	Date d3 <span class="token operator">=</span> d1<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="412_254"></a>4.1.2拷贝构造函数的参数</h4> 
<p>拷贝构造函数的<mark>参数只有一个且<strong>必须是类类型对象的引用</strong></mark>，使用传值方式编译器直接报错，因为会引发无穷递归调用。<br> <img src="https://images2.imgbox.com/4e/95/KDfnz08x_o.png" alt="在这里插入图片描述"><br> 为什么会引起无穷递归呢？</p> 
<p>首先我们要知道，<mark>自定义类型传值传参要调用拷贝构造</mark>（可以看成一种规定）</p> 
<p>下面的代码调试可以发现，当我们第一次按F11进入fun函数时，它是先进入到了Date类中的拷贝构造函数，第二次按F11才会进入fun函数。<br> <img src="https://images2.imgbox.com/dd/af/vdbKR1mK_o.gif" alt="在这里插入图片描述"></p> 
<p>如果这样，不写引用的话就会引发无穷的递归。</p> 
<p>本来是只想调用拷贝构造，但是调用前要传参数，传递参数又要发生拷贝构造；那么还是要传递参数，此时就会形成没有尽头的递归，<br> <img src="https://images2.imgbox.com/ec/9e/nvAarV30_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="413_269"></a>4.1.3编译器生成默认的拷贝构造函数(浅拷贝)</h4> 
<p>若未显式定义，编译器会生成默认的拷贝构造函数。 默认的拷贝构造函数对象按内存存储按字节序完成拷贝，这种拷贝叫做浅拷贝，或者值拷贝。</p> 
<p>我们发现，对于所有成员确实都拷贝过去了，可是对于数组元素来说，它们两个数组的地址是相同的，也就是二者数组的同一块空间，这就有点不好了。<br> <img src="https://images2.imgbox.com/b7/74/NvK9csQ2_o.png" alt="在这里插入图片描述"><br> <mark>注意：</mark><br> 在编译器生成的默认拷贝构造函数中，内置类型是按照字节方式直接拷贝的；而自定义类型是调用其拷贝构造函数完成拷贝的。</p> 
<h4><a id="414_276"></a>4.1.4拷贝构造函数典型调用场景：</h4> 
<ul><li>使用已存在对象创建新对象</li><li>函数参数类型为类类型对象</li><li>函数返回值类型为类类型对象</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Date</span>
 <span class="token punctuation">{<!-- --></span>
 <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Date</span><span class="token punctuation">(</span><span class="token keyword">int</span> year<span class="token punctuation">,</span> <span class="token keyword">int</span> minute<span class="token punctuation">,</span> <span class="token keyword">int</span> day<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Date(int,int,int):"</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">Date</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date<span class="token operator">&amp;</span> d<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Date(const Date&amp; d):"</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~Date():"</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> _year<span class="token punctuation">;</span>
    <span class="token keyword">int</span> _month<span class="token punctuation">;</span>
    <span class="token keyword">int</span> _day<span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
 Date <span class="token function">Test</span><span class="token punctuation">(</span>Date d<span class="token punctuation">)</span>
 <span class="token punctuation">{<!-- --></span>
    Date <span class="token function">temp</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> temp<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{<!-- --></span>
    Date <span class="token function">d1</span><span class="token punctuation">(</span><span class="token number">2022</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Test</span><span class="token punctuation">(</span>d1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/48/cf/pdlv5ZDd_o.png" alt="在这里插入图片描述"></p> 
<p><mark>总结：</mark></p> 
<ul><li>如果没有管理资源，一般不需要写拷贝构造，默认生成的拷贝构造就可以。如Data</li><li>如果都是自定义类型的成员，内置类型成员也没有指向资源，也类似默认生成的拷贝构造就可以。如两个栈实现队列</li><li>一般情况下，不需要显示的写析构函数，就不需要显示的写拷贝构造</li><li>如果内部有指针或一些值指向资源，需要写析构释放，通常就需要显示写构造完成深拷贝。如：Stack、List等。</li></ul> 
<h2><a id="5_323"></a>5.赋值运算符重载</h2> 
<p>我们写了这么多的日期类，好像都没怎么操作过，下面写个日期的比较吧：<br> 比如我们写个函数比较两个日期哪个小，那么我们就得这样写：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token function">CompareLess</span><span class="token punctuation">(</span>Date<span class="token operator">&amp;</span> d1<span class="token punctuation">,</span> Date<span class="token operator">&amp;</span> d2<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>d1<span class="token punctuation">.</span>_year <span class="token operator">&lt;</span> d2<span class="token punctuation">.</span>_year<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>d1<span class="token punctuation">.</span>_year <span class="token operator">==</span> d2<span class="token punctuation">.</span>_year<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>d1<span class="token punctuation">.</span>_month <span class="token operator">&lt;</span> d2<span class="token punctuation">.</span>_month<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>d1<span class="token punctuation">.</span>_month <span class="token operator">==</span> d2<span class="token punctuation">.</span>_month<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> d1<span class="token punctuation">.</span>_day <span class="token operator">&lt;</span> d2<span class="token punctuation">.</span>_day<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如果比较两个日期哪个大呢？是不是又得写一份类似的代码，而且调用的时候可读性又不好，如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token function">CompareLarger</span><span class="token punctuation">(</span>Date<span class="token operator">&amp;</span> d1<span class="token punctuation">,</span> Date<span class="token operator">&amp;</span> d2<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>d1<span class="token punctuation">.</span>_year <span class="token operator">&gt;</span> d2<span class="token punctuation">.</span>_year<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>d1<span class="token punctuation">.</span>_year <span class="token operator">==</span> d2<span class="token punctuation">.</span>_year<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>d1<span class="token punctuation">.</span>_month <span class="token operator">&gt;</span> d2<span class="token punctuation">.</span>_month<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>d1<span class="token punctuation">.</span>_month <span class="token operator">==</span> d2<span class="token punctuation">.</span>_month<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> d1<span class="token punctuation">.</span>_day <span class="token operator">&gt;</span> d2<span class="token punctuation">.</span>_day<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Date <span class="token function">d1</span><span class="token punctuation">(</span><span class="token number">2024</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Date <span class="token function">d2</span><span class="token punctuation">(</span><span class="token number">2024</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Date <span class="token function">d3</span><span class="token punctuation">(</span><span class="token number">2025</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token function">CompareLess</span><span class="token punctuation">(</span>d1<span class="token punctuation">,</span> d2<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token function">CompareLess</span><span class="token punctuation">(</span>d2<span class="token punctuation">,</span> d3<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>那能不能像内置类型那样直接用&gt; &lt; 这样比呢？那样多得劲。但是很遗憾，C++不支持这样写</p> 
<p><img src="https://images2.imgbox.com/8c/6f/OgVvHQvK_o.png" alt="在这里插入图片描述"></p> 
<p>但是祖师爷发明了运算符重载来支持这样写。</p> 
<h3><a id="51_385"></a>5.1运算符重载</h3> 
<p>C++为了增强代码的可读性引入了运算符重载，<mark>运算符重载是具有特殊函数名的函数</mark>，也具有其返回值类型，函数名字以及参数列表，其返回值类型和参数列表与普通的函数类似。</p> 
<p><strong>函数名字为：关键字operator 后面接需要重载的运算符符号</strong>。<br> 函数原型：<strong>返回值类型</strong> <mark>operator</mark><code>操作符</code>(参数列表)</p> 
<pre><code class="prism language-cpp"><span class="token comment">//全局的两个函数</span>
<span class="token comment">//bool CompareLess(Date&amp; d1, Date&amp; d2)</span>
<span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">&lt;</span><span class="token punctuation">(</span>Date<span class="token operator">&amp;</span> d1<span class="token punctuation">,</span> Date<span class="token operator">&amp;</span> d2<span class="token punctuation">)</span><span class="token comment">//操作符重载</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>d1<span class="token punctuation">.</span>_year <span class="token operator">&lt;</span> d2<span class="token punctuation">.</span>_year<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>d1<span class="token punctuation">.</span>_year <span class="token operator">==</span> d2<span class="token punctuation">.</span>_year<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>d1<span class="token punctuation">.</span>_month <span class="token operator">&lt;</span> d2<span class="token punctuation">.</span>_month<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>d1<span class="token punctuation">.</span>_month <span class="token operator">==</span> d2<span class="token punctuation">.</span>_month<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> d1<span class="token punctuation">.</span>_day <span class="token operator">&lt;</span> d2<span class="token punctuation">.</span>_day<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//bool CompareLarger(Date&amp; d1, Date&amp; d2)</span>
<span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>Date<span class="token operator">&amp;</span> d1<span class="token punctuation">,</span> Date<span class="token operator">&amp;</span> d2<span class="token punctuation">)</span><span class="token comment">//操作符重载</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>d1<span class="token punctuation">.</span>_year <span class="token operator">&gt;</span> d2<span class="token punctuation">.</span>_year<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>d1<span class="token punctuation">.</span>_year <span class="token operator">==</span> d2<span class="token punctuation">.</span>_year<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>d1<span class="token punctuation">.</span>_month <span class="token operator">&gt;</span> d2<span class="token punctuation">.</span>_month<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>d1<span class="token punctuation">.</span>_month <span class="token operator">==</span> d2<span class="token punctuation">.</span>_month<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> d1<span class="token punctuation">.</span>_day <span class="token operator">&gt;</span> d2<span class="token punctuation">.</span>_day<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Date <span class="token function">d1</span><span class="token punctuation">(</span><span class="token number">2024</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Date <span class="token function">d2</span><span class="token punctuation">(</span><span class="token number">2024</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Date <span class="token function">d3</span><span class="token punctuation">(</span><span class="token number">2025</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//显示调用</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">operator</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>d1<span class="token punctuation">,</span> d2<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	<span class="token comment">//隐式调用</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>d1 <span class="token operator">&lt;</span> d2<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>d2 <span class="token operator">&gt;</span> d3<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>注意：</p> 
<ul><li>不能通过连接其他符号来创建新的操作符：比如operator@</li></ul> 
<p><img src="https://images2.imgbox.com/a3/21/5Zqa0Bu0_o.png" alt="在这里插入图片描述"></p> 
<ul><li>重载操作符 <mark>必须有一个类类型参数（即不可以重新定义内置类型已经存在的操作符的行为）</mark></li></ul> 
<p><img src="https://images2.imgbox.com/05/73/5XY9ICJb_o.png" alt="在这里插入图片描述"></p> 
<ul><li>.* (点星)、 :: (域限定符) 、sizeof 、?:（三目运算符） . (成员点)。注意<mark>以上5个运算符不能重载</mark>。这个经常在<code>笔试选择题中出现。</code></li><li><mark>作为类成员函数重载时，其形参看起来比操作数数目少1，因为成员函数的第一个参数为隐藏的this</mark><br> 我们一般将运算符重载放在类中，而不是类外。因为成员变量通常是私有的，在类外是访问不到的，所以通常将函数重载作为类的成员函数。（上面代码可以访问是因为将它放为public了）</li></ul> 
<p><img src="https://images2.imgbox.com/77/73/lgJ6K9gK_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="52_465"></a>5.2赋值运算符重载</h3> 
<h4><a id="521_467"></a>5.2.1赋值运算符重载格式</h4> 
<p>参数类型：<mark>const T&amp;</mark>，传递引用可以提高传参效率</p> 
<h4><a id="522_469"></a>5.2.2返回值类型</h4> 
<p>返回值类型：T&amp;，返回引用可以提高返回的效率，有返回值目的是为了支持连续赋值</p> 
<p>假设有下面的代码，我想让d1变成d4，那会发生什么呢？<br> <img src="https://images2.imgbox.com/74/f1/f69EaMZT_o.png" alt="在这里插入图片描述"><br> 此时调用的不是拷贝构造，而是一个<mark>赋值拷贝（将一个已经存在的对象，拷贝赋值给另一个已经存在的对象）</mark></p> 
<p>那赋值应该怎么写呢？下面这样写就可以吗？<br> <img src="https://images2.imgbox.com/78/c5/RzdWGZOP_o.png" alt="在这里插入图片描述"></p> 
<p>但是很多人都不是这样写的，别人是这样写的，有一个返回值：</p> 
<p><img src="https://images2.imgbox.com/74/c1/btSmW6fj_o.png" alt="在这里插入图片描述"></p> 
<p>这样写是因为可能存在连续的赋值</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Date <span class="token function">d1</span><span class="token punctuation">(</span><span class="token number">2024</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//拷贝构造</span>
	Date d2 <span class="token operator">=</span> d1<span class="token punctuation">;</span>
	Date <span class="token function">d3</span><span class="token punctuation">(</span>d1<span class="token punctuation">)</span><span class="token punctuation">;</span>

	Date <span class="token function">d4</span><span class="token punctuation">(</span><span class="token number">2024</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	d1 <span class="token operator">=</span> d4<span class="token punctuation">;</span><span class="token comment">//此时是什么？赋值拷贝</span>

	d1 <span class="token operator">=</span> d2 <span class="token operator">=</span> d4<span class="token punctuation">;</span> <span class="token comment">//连续赋值</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>很多人也都建议使用引用返回：</p> 
<p><img src="https://images2.imgbox.com/97/07/U9oCAaMr_o.png" alt="在这里插入图片描述"></p> 
<p>那传值返回与传引用返回有什么区别呢？效率上的区别<br> 看下面的func函数：<br> <img src="https://images2.imgbox.com/47/e0/nG2TiqNH_o.png" alt="在这里插入图片描述"><br> 那有没有什么方式让它不发生拷贝构造呢？传引用返回<br> 下面代码没有发生拷贝构造<br> <img src="https://images2.imgbox.com/3e/13/6QT0oHDo_o.png" alt="在这里插入图片描述"></p> 
<p><strong>但此时会有问题，确实减少了拷贝，但是引用实际上就是给d取了一个别名，二者都指向d，但是d都析构了，此时返回了临时变量的地址，类似于C中的野指针了。</strong></p> 
<p>二者地址打印出来是一样的。<br> <img src="https://images2.imgbox.com/81/da/KgQJJx2P_o.png" alt="在这里插入图片描述"></p> 
<p>总结一下：<br> 若返回对象是一个局部对象或临时对象，出来当前函数的作用域就析构销毁了，就不能使用引用返回，用引用返回是存在风险的，引用对象在那个函数的栈帧中已经销毁了。</p> 
<p>即：</p> 
<ul><li>出了作用域，返回对象还没有析构，那就可以传引用放回，减少拷贝<br> a、返回对象声明周期到了，会析构，传值返回<br> b、返回对象声明周期没到，不会析构，传引用返回</li></ul> 
<p>对于最开始写的日期的赋值重载，this在operator的栈帧上，但是*this在main函数的栈帧中，返回对象没有析构，因此可以使用引用返回。</p> 
<h4><a id="523_529"></a>5.2.3检测是否自己给自己赋值</h4> 
<p>为了防止有人自己给自己赋值，赋值前可以判断一下，提高效率，避免不必要的操作。<br> <img src="https://images2.imgbox.com/e0/2d/ORTvarge_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="524_532"></a>5.2.4注意返回值</h4> 
<p>返回*this ：要复合连续赋值的含义</p> 
<h4><a id="525_535"></a>5.2.5重载成类的成员函数</h4> 
<p>赋值运算符只能重载成类的成员函数不能重载成全局函数<br> <img src="https://images2.imgbox.com/18/51/rffW3D8p_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="526_539"></a>5.2.6默认赋值运算符重载</h4> 
<p>跟拷贝构造类似，用户没有显式实现时，<mark>编译器会生成一个默认赋值运算符重载，以值的方式逐字节拷贝。</mark><br> 注意：</p> 
<ul><li>内置类型成员变量是直接赋值的，而自定义类型成员变量需要调用对应类的赋值运算符重载完成赋值</li><li>如果类中未涉及到资源管理，赋值运算符是否实现都可以；<strong>一旦涉及到资源管理则必须要实现。</strong></li></ul> 
<h3><a id="53_544"></a>5.3前置++与后置++重载</h3> 
<p>我们知道，前置++与后置++重载以后，二者是一样的，没有办法区分。我们的祖师爷就给<mark>后置++强行增加了一个int类型的形参</mark>，<strong>该形参不需要写参数名，调用函数参数不需要传（编译器自动传）或者 传递任何数都可</strong>，这个参数仅仅为了跟前置区分，不会使用。<br> <img src="https://images2.imgbox.com/6f/a7/an7GNlq7_o.png" alt="在这里插入图片描述"><br> 一般会这样写：</p> 
<p><img src="https://images2.imgbox.com/72/9e/a9XQS14W_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="54_551"></a>5.4运算符重载拓展</h3> 
<p>我们之前要想打印类中的成员变量，都是写了一个Print函数</p> 
<p><img src="https://images2.imgbox.com/61/a6/gehUFxIr_o.png" alt="在这里插入图片描述"></p> 
<p>那我们能不能使用C++标准库中的cout与cin输出呢？</p> 
<p><img src="https://images2.imgbox.com/31/de/JJkSiZ06_o.png" alt="在这里插入图片描述"><br> 很显然，正常情况下是不可以的。<br> 对于内置类型我们可以直接使用是因为C++标准库中已经写好了，流插入与流提取也是函数重载。<br> <img src="https://images2.imgbox.com/6a/8d/ncx9peR2_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-cpp">	<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> i<span class="token punctuation">;</span>
	<span class="token comment">//上面的代码本质上转换为下面的</span>
	cout<span class="token punctuation">.</span><span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>cout与cin可以自动识别类型，本质上是因为这些流插入重载构成函数重载。</p> 
<p>那自定义类型要想写，那我们就得自己写函数重载，怎么写呢？如下：<br> <img src="https://images2.imgbox.com/05/cd/eoNf9iZw_o.png" alt="在这里插入图片描述"><br> 此时我们发现依然无法调用，为什么呢？</p> 
<p>如果我们自己调用，那就应该按下面的方式写。<br> 你是我d1的成员函数嘛</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">Test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Date <span class="token function">d1</span><span class="token punctuation">(</span><span class="token number">2024</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Date <span class="token function">d2</span><span class="token punctuation">(</span><span class="token number">1982</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//cout &lt;&lt; d1;</span>
	<span class="token comment">//cout &lt;&lt; d2;</span>
	<span class="token comment">//自己写调用</span>
	d1<span class="token punctuation">.</span><span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>cout<span class="token punctuation">)</span><span class="token punctuation">;</span>
	d2<span class="token punctuation">.</span><span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>cout<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>所以我们应该按下面的方式写：<br> <img src="https://images2.imgbox.com/ac/28/RaWWrRBN_o.png" alt="在这里插入图片描述"></p> 
<p>这样写又非常的奇怪，那我们能不能让它的顺序颠倒一下呢？<br> <img src="https://images2.imgbox.com/fc/87/uxft5z2d_o.png" alt="在这里插入图片描述"></p> 
<p>所以，operator&lt;&lt;想重载为成员函数可以，但是用起来不符合正常逻辑，不建议这样做，<mark>建议重载为全局函数。</mark><br> <img src="https://images2.imgbox.com/50/19/L0xwQVKq_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="6const_601"></a>6.const成员函数</h2> 
<p>有时候我们需要把对象设置为只读的，但是这时候就会存在一些问题。<br> <img src="https://images2.imgbox.com/8a/0f/IBmdm57G_o.png" alt="在这里插入图片描述"></p> 
<p>因此，我们的祖师爷就规定在函数的后面加const，看起来很怪，但确实也没有什么好的办法了</p> 
<p><img src="https://images2.imgbox.com/5b/7a/8Oh0VZVb_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="7const_608"></a>7.取地址及const取地址操作符重载</h2> 
<p>这两个默认成员函数一般不用重新定义 ，编译器默认会生成。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Date</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	Date<span class="token operator">*</span> <span class="token keyword">operator</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">const</span> Date<span class="token operator">*</span> <span class="token keyword">operator</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _year<span class="token punctuation">;</span> <span class="token comment">// 年</span>
	<span class="token keyword">int</span> _month<span class="token punctuation">;</span> <span class="token comment">// 月</span>
	<span class="token keyword">int</span> _day<span class="token punctuation">;</span> <span class="token comment">// 日</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>这两个运算符一般不需要重载，使用编译器生成的默认取地址的重载即可，只有特殊情况，才需要重载，比如想让别人获取到指定的内容！<br> <img src="https://images2.imgbox.com/c2/7b/TkXoy0tC_o.jpg" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a9f40189acf2999a2bd760555eacc5e8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用python绘制一个五颜六色的爱心</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e32e031584e541c6e559722da383c64a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">星辰AI-史上最强AI系统（既能写文章，还能画图，写歌曲，画思维导图的AI系统）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>