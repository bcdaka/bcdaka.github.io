<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>保姆级教学QT实战项目：基于QT的音乐播放器(一) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/5409738a7ea59b54cf50e3124af0e98d/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="保姆级教学QT实战项目：基于QT的音乐播放器(一)">
  <meta property="og:description" content="UI界面我就不细说了，可以自行参照设计，实现的功能有：
1.搜索网络歌曲，但是这个网络歌曲是自己模拟的服务器，与各大音乐软件服务器或者API什么的无关
2.歌词同步
3.随机播放，上一首，下一首，暂停播放。主要就是这些按钮控件。
最右边的按键就是歌曲列表与歌词页面的切换按钮
最左边的为随机播放功能开启和关闭
一、演示：
文件夹按钮为：有config文件配置，但是我这里没有进行显示，理由就是同上面显示的一样的操作，为了赶进度就没实现了，但是道理是一样的。
学完本项目可以了解一下QT中的：http请求，json分析，数据库操作，多线程操作，以及文件操作，专辑图像处理本程序并未实现，大家可以自行补充QT中的图像处理相关知识。
所以接下来我们先实现搜索网络歌曲部分。
以下是实现http功能的源代码
二、http请求部分(MusicHttp) MusicHttp.h #include &lt;QObject&gt; #include &lt;QNetworkAccessManager&gt;//处理网络请求和接收响应的一个核心类 #include &lt;QUrl&gt;//url地址 #include &lt;QNetworkReply&gt;//接收返回数据 #include &lt;QNetworkRequest&gt;//发送请求 #include &lt;QFile&gt;//文件操作，读取数据需要保存在文件 #include &lt;QDebug&gt; class MusicHttp : public QObject { Q_OBJECT public: //枚举请求状态 enum MusicHttpState{ MusicFailHttp, MusicSuccessHttp, }; explicit MusicHttp(const QString &amp;filename,QObject *parent = nullptr); bool GetHttpState(); void setFilename(const QString &amp;value); void onGet(const QString&amp; httpurl); void onreadyRead(); QByteArray onreadData(); void onhandFinished(); void onhandError(QNetworkReply::NetworkError code); signals: void readyRead(); void error(); public slots: private: QString filename;//文件名 QNetworkAccessManager* networkManager;//请求对象 enum MusicHttpState httpstate;//判断请求成功还是失败 }; #endif // MUSICHTTP_H MusicHttp.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-01T21:34:38+08:00">
    <meta property="article:modified_time" content="2024-04-01T21:34:38+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">保姆级教学QT实战项目：基于QT的音乐播放器(一)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><br> UI界面我就不细说了，可以自行参照设计，实现的功能有：</p> 
<p>1.搜索网络歌曲，但是这个网络歌曲是自己模拟的服务器，与各大音乐软件服务器或者API什么的无关</p> 
<p>2.歌词同步<br> 3.随机播放，上一首，下一首，暂停播放。主要就是这些按钮控件。<br>  </p> 
<p>最右边的按键就是歌曲列表与歌词页面的切换按钮</p> 
<p>最左边的为随机播放功能开启和关闭</p> 
<p><br><img alt="" height="773" src="https://images2.imgbox.com/30/b1/zFXWDHh0_o.png" width="896"><br><img alt="" height="710" src="https://images2.imgbox.com/d3/f2/hchrPsBF_o.png" width="353"></p> 
<h2>一、演示：<br><img alt="" height="805" src="https://images2.imgbox.com/48/ff/L3WCCjDL_o.png" width="918"><br><img alt="" height="805" src="https://images2.imgbox.com/6d/8e/1tPrvD3O_o.png" width="918"></h2> 
<p>文件夹按钮为：有config文件配置，但是我这里没有进行显示，理由就是同上面显示的一样的操作，为了赶进度就没实现了，但是道理是一样的。<br><img alt="" height="270" src="https://images2.imgbox.com/0b/7d/3A03GsJ0_o.png" width="551"></p> 
<p>学完本项目可以了解一下QT中的：http请求，json分析，数据库操作，多线程操作，以及文件操作，专辑图像处理本程序并未实现，大家可以自行补充QT中的图像处理相关知识。<br><br><br><br> 所以接下来我们先实现搜索网络歌曲部分。<br> 以下是实现http功能的源代码<br>  </p> 
<h2>二、http请求部分(MusicHttp)</h2> 
<p>MusicHttp.h </p> 
<pre><code class="language-cpp">#include &lt;QObject&gt;
#include &lt;QNetworkAccessManager&gt;//处理网络请求和接收响应的一个核心类
#include &lt;QUrl&gt;//url地址
#include &lt;QNetworkReply&gt;//接收返回数据
#include &lt;QNetworkRequest&gt;//发送请求
#include &lt;QFile&gt;//文件操作，读取数据需要保存在文件
#include &lt;QDebug&gt;

class MusicHttp : public QObject
{
    Q_OBJECT
public:
    //枚举请求状态
    enum MusicHttpState{
        MusicFailHttp,
        MusicSuccessHttp,
    };
    explicit MusicHttp(const QString &amp;filename,QObject *parent = nullptr);

    bool GetHttpState();
    void setFilename(const QString &amp;value);
    void onGet(const QString&amp; httpurl); 
    void onreadyRead();
    QByteArray onreadData();
    void onhandFinished();
    void onhandError(QNetworkReply::NetworkError code);

signals:
    void readyRead();
    void error();

public slots:

private:
    QString filename;//文件名
    QNetworkAccessManager* networkManager;//请求对象
    enum MusicHttpState httpstate;//判断请求成功还是失败
};

#endif // MUSICHTTP_H</code></pre> 
<p>MusicHttp.cpp </p> 
<pre><code class="language-cpp">/*
第一，我们要创建一个网络管理对象，用于发送和接收http请求
同时我们还需要一个文件，用于存放请求接受的数据，因为搜索一首歌可以有多个返回结果，所以每次都需要重新写入文件，我用的是
    if(QFile::exists(filename))
        QFile::remove(filename);
第二，我自己枚举了请求状态，成功或失败都应该进行处理，成功可以返回搜索结果，失败可以弹出对话框，比如说因为网络问题请求失败
第三，只要连接成功并且接收到数据，QNetworkReply会发出readyRead信号，但是如果文件太大，那会分几次发送，所以我连接了onreadyRead函数，对接受到的数据进行写入，只有当数据接收完，该类发送finished的时候我自定义一个readyRead信号，接受到自定义的信号然后对文件进行读取，所以有两个readyRead信号，不要搞混淆了。一个是自定义，一个是QNetworkReply的。不过该类在连接失败的时候也会发送finished信号，所以发送了一个自定义的错误信号，可以对该信号进行捕获做出对应的处理操作。
第四，可能onGet(const QString&amp; httpurl)，可能对这个存在不理解，为什么是这个参数，而且没有调用，但是我们是要根据按下搜索的回车键进行搜索，与其他类配合使用，所以先记下这个参数，往后其他类实现会提及。
第五，实际上我们得到的是json数据，但是这个json数据是我自己参照写的，需要对这个json进行分析，后面有类会对其进行分析，如果要得到真正的json文件需要用到爬虫，本人不会，所以只好自己仿制了。
第六，用到的QT中的类还比较简单，有需要的伙伴可以自行查看帮助手册
*/





#include "musichttp.h"

MusicHttp::MusicHttp(const QString &amp;filename,QObject *parent) : 
    QObject(parent),filename(filename)
{
    networkManager = new QNetworkAccessManager(this);
    //将请求状态初始化为成功
    httpstate=MusicHttpState:: MusicSuccessHttp;
}

//发送请求部分
void MusicHttp::onGet(const QString&amp; httpurl)
{
    if(QFile::exists(filename)){
        QFile::remove(filename);
    }
    //连接服务器的返回状态初始化为成功
    httpstate=MusicHttpState:: MusicSuccessHttp;
    
    //创建url对象,也就是设置url地址
    QUrl url(httpurl);
    //创建一个请求对象，用于发送请求
    QNetworkRequest request(url);
    //发送请求，返回一个reply对象
    //该返回对象接受到数据会发送readyRea信号
    QNetworkReply *reply = networkManager-&gt;get(request);
    connect(reply,&amp;QNetworkReply::readyRead,this,&amp;MusicHttp::onreadyRead);
    //数据发送完毕或者是请求失败，发出finished信号,处理该信号
    connect(reply,&amp;QNetworkReply::finished,this,&amp;MusicHttp::onhandFinished);

    //请求失败处理部分
    //对请求失败进行输出，输出失败原因
    connect(reply,SIGNAL(error(QNetworkReply::NetworkError)),\
          this,SLOT(onhandError(QNetworkReply::NetworkError)));

}

//处理请求完成
void MusicHttp::onhandFinished()
{
    QNetworkReply *reply =(QNetworkReply *)this-&gt;sender();
    //如果不是请求失败，则发出readyRead信号，表示可以读取数据
    if(reply-&gt;error() == QNetworkReply::NoError){
        emit readyRead();
    }
    reply-&gt;deleteLater();
}

//处理请求失败
void MusicHttp::onhandError(QNetworkReply::NetworkError code)
{
    qDebug()&lt;&lt;"error code:"&lt;&lt;code;
    httpstate=MusicHttpState:: MusicFailHttp;
    emit error();
}

//处理接受到的数据
void MusicHttp::onreadyRead()
{
    //连接该槽函数的对象是局部变量，所以要先获取是谁发送的信号
    QNetworkReply *reply =(QNetworkReply *)this-&gt;sender();
    //读取数据写入缓冲区
    QByteArray data =reply-&gt;readAll();
    //准备一个文件，将缓冲区数据以追加的方式写入文件
    QFile file(filename);
    bool ok = file.open(QFile::WriteOnly|QFile::Append);
    if(!ok){
        qDebug()&lt;&lt;"fail open "&lt;&lt;filename&lt;&lt;"to write \n Error:"&lt;&lt;file.errorString();
        return;
    }
    file.write(data);
    file.close();
    return;
}

//对保存的数据进行读取
QByteArray MusicHttp::onreadData()
{
    QFile file(filename);
    bool ok = file.open(QFile::ReadOnly);
    if(!ok){
        qDebug()&lt;&lt;"fail open "&lt;&lt;filename&lt;&lt;"to Read \n Error:"&lt;&lt;file.errorString();
        return QByteArray();
    }
    QByteArray data = file.readAll();
    file.close();
    return data;
}

//构造函数
void MusicHttp::setFilename(const QString &amp;value)
{
    filename = value;
}

//用户查询成功还是失败
bool MusicHttp::GetHttpState()
{
    return httpstate==MusicHttpState::MusicSuccessHttp ? true : false;
}</code></pre> 
<p>实现网络请求部分，接下来就是搜索功能实现部分了</p> 
<p></p> 
<h2><br> 三、搜索功能部分(MusicSearch)</h2> 
<p>准备一个json文件，以下是我自己仿的，仅供学习使用。filename：你瞒我瞒.json<br><img alt="" height="459" src="https://images2.imgbox.com/de/d7/s5kQYnhI_o.png" width="552"><br> MusicSearch.h</p> 
<pre><code class="language-cpp">#ifndef MUSICSEARCH_H
#define MUSICSEARCH_H

#include &lt;QObject&gt;
#include &lt;QJsonObject&gt;
#include &lt;QJsonArray&gt;
#include &lt;QJsonParseError&gt;
#include &lt;QJsonDocument&gt;
#include "musichttp.h"
#include "musicinformation.h"


class MusicSearch : public QObject
{
    Q_OBJECT
public:
    explicit MusicSearch(QObject *parent = nullptr);
signals:
    showMusicInfo(const QVector&lt;MusicInformation* &gt; musicInfoList);
public slots:
    //搜索对应的歌曲名方法方法，
    void search(const QString&amp; music);
    //读取歌曲文件
    void onreadyRead();
    //解析json数据
    void parseMusicJsonData(const QByteArray jsondata);
    //清空容器
    void clearMusicList();
private:
    MusicHttp* musicHttp;
    //创建容器，里面的类型为MusicInformation*，下一部分提及
    QVector&lt;MusicInformation* &gt; musicInfoList;
};

#endif // MUSICSEARCH_H
</code></pre> 
<p>MusicSearch.cpp </p> 
<pre><code class="language-cpp">/*
第一，创建MusicHttp对象，可以使用里面的接口方法，当自定义的readyRead信号发出的时候，就可以对其进行读取分析，在MusicHttp部分说了，得到的是json数据。
第二，//实现搜索歌曲 void MusicSearch::search(const QString &amp;music) 该函数主要是在搜索栏按下的时候调用，根据歌曲在服务器寻找对应的歌曲json文件，而我模拟的web服务器主要地址就是
http://localhost/QQ音乐下载/，也就是从这里开始找。
第三，这里我封装了一个MusicInfomation的类，主要是用于存储歌曲信息，这里还没有讲，如果不用也是一样的，自定义QString musicMp3Url,QString musicLrcUrl,...。添加这个类主要是可以创建一个对象，发生信号的时候把容器发送过去，再一个个在ui界面进行显示就比较方便
第四，注意json文件的错误信号，解析失败的时候要对其进行处理。
第五，当解析完所有的JSON数据，并且插入容器的时候，就可以发送信号，将容器发送过去，主界面进行捕获，就可以显示在ui界面上
*/






#include "musicsearch.h"

MusicSearch::MusicSearch(QObject *parent) : QObject(parent)
{
    musicHttp = new MusicHttp("music.json",this);
    //连接MusicHttp的readyRead信号，对其进行读取
    connect(musicHttp,&amp;MusicHttp::readyRead,this,&amp;MusicSearch::onreadyRead);
}

//实现搜索歌曲
void MusicSearch::search(const QString &amp;music)
{
    QString httpurl = QString("http://localhost/QQ音乐下载/%1/%2.json").arg(music).arg(music);
    musicHttp-&gt;onGet(httpurl);
}

//获取从服务器返回的数据
void MusicSearch::onreadyRead()
{
    QByteArray data = musicHttp-&gt;onreadData();
    //对接收到的json文件进行解析
    parseMusicJsonData(data);
}

//解析json文件
void MusicSearch::parseMusicJsonData(const QByteArray jsondata)
{
    QJsonParseError jsonParseError;
    QJsonDocument musicDocument =QJsonDocument::fromJson(jsondata,&amp;jsonParseError);
    if(musicDocument.isEmpty()){
        qDebug()&lt;&lt;"Fail to parse data:"&lt;&lt;musicDocument&lt;&lt;"Error:"&lt;&lt;jsonParseError.errorString();
        return ;
    }
    QJsonObject musicObject = musicDocument.object();
    QJsonArray musicArray = musicObject["list"].toArray();

    for(int i=0;i&lt;musicArray.size();i++){
        MusicInformation* music = new MusicInformation;
        QJsonObject object = musicArray[i].toObject();
        QString musicName = object["musicName"].toString();
        QString albumName = object["albumName"].toString();
        QString duration =QString::number(object["duration"].toInt());
        QString musicPath = object["path"].toString();
        QString musicMp3 = object["mp3"].toString();
        QString musicLrc = object["lyric"].toString();

        music-&gt;musicName = musicName;
        music-&gt;albumName = albumName;
        music-&gt;duration = duration.toInt();
        music-&gt;musicLrcName = musicLrc;
        music-&gt;musicMp3Url = QString(music-&gt;bodyUrl+musicPath+"/"+musicMp3);
        music-&gt;musicLrcUrl = QString(music-&gt;bodyUrl+musicPath+"/"+musicLrc);
        music-&gt;musicAlbumUrl=QString(music-&gt;bodyUrl+musicPath+"/"+albumName+".jpg");
        //将得到的歌曲信息插入歌曲容器
        musicInfoList.append(music);
 
    }
    //发送信号，可以显示歌曲
    emit showMusicInfo(musicInfoList);
}

//清空歌曲列表容器
void MusicSearch::clearMusicList()
{
    qDeleteAll(musicInfoList.begin(), musicInfoList.end());
    musicInfoList.clear();
}


</code></pre> 
<h2>四、歌曲信息类，MusicInfomation </h2> 
<pre><code class="language-cpp">/*
    这里没什么说的，就是一些成员变量，同时有QT自己生成的构造函数，可以根据自己需要添加成员变量，另外这里不仅有网络歌曲，后面还需要播放本地歌曲，所以就合在了一块儿.主要就是我服务器的基本路径，每个人都不同，这只是我从该路径开始而已
*/


#ifndef MUSICINFORMATION_H
#define MUSICINFORMATION_H

#include &lt;QObject&gt;
#include &lt;QDebug&gt;
#include &lt;QString&gt;

class MusicInformation : public QObject
{
    Q_OBJECT
public:
    explicit MusicInformation(QObject *parent = nullptr);

    //主地址,服务器基本路径
    QString bodyUrl="http://localhost/QQ音乐下载/";
    //歌曲文件夹地址
    QString musicUrl;
    //mp3地址
    QString musicMp3Url;
    //歌词地址
    QString musicLrcUrl;
    //专辑图片地址
    QString musicAlbumUrl;
    //歌曲名
    QString musicName;
    //专辑名
    QString albumName;
    //歌曲时长
    qint16 duration;
    //歌词名
    QString musicLrcName;
    //本地mp3地址
    QString musicLocalMp3Path;
    //本地歌词地址
    QString musicLocalLrcPath;
    //本地专辑地址
    QString musicLocalAlmPath;

    QString getMusicUrl() const;
    void setMusicUrl(const QString &amp;value);
    
    QString getMusicMp3Url() const;
    void setMusicMp3Url(const QString &amp;value);
    
    QString getMusicLrcUrl() const;
    void setMusicLrcUrl(const QString &amp;value);
    
    QString getMusicAlbumUrl() const;
    void setMusicAlbumUrl(const QString &amp;value);
    
    QString getMusicName() const;
    void setMusicName(const QString &amp;value);
    
    QString getAlbumName() const;
    void setAlbumName(const QString &amp;value);
    
    qint16 getDuration() const;
    void setDuration(const qint16 &amp;value);
    
    QString getMusicLrcName() const;
    void setMusicLrcName(const QString &amp;value);
    
    QString getMusicLocalMp3Path() const;
    void setMusicLocalMp3Path(const QString &amp;value);
    
    QString getMusicLocalLrcPath() const;
    void setMusicLocalLrcPath(const QString &amp;value);
    
    QString getMusicLocalAlmPath() const;
    void setMusicLocalAlmPath(const QString &amp;value);
    
signals:
    
public slots:
    
private:
    
    
};

#endif // MUSICINFORMATION_H
</code></pre> 
<p></p> 
<h2><br>  </h2>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f4b5ca91e86249a8adef82d0253379bd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">iMAC 苹果系统 macOS加入AD域</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b7160916480c400bb4f46e06a5f93855/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">什么是人工智能物联网（AIoT）？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>