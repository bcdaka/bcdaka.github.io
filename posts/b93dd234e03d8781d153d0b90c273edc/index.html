<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>浔川AI五子棋（改进（完整）版1.3）——浔川python社 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b93dd234e03d8781d153d0b90c273edc/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="浔川AI五子棋（改进（完整）版1.3）——浔川python社">
  <meta property="og:description" content="简介： 浔川AI五子棋是一种使用人工智能技术来进行五子棋对弈的游戏。它采用了先进的算法和模型，在对弈过程中能够实时分析棋局并进行决策，使得游戏更具挑战性和趣味性。
浔川AI五子棋的核心技术是人工智能算法。它使用深度学习模型对大量的五子棋对局进行训练，从而学习到了不同棋局下的最优解策略。通过不断的优化和迭代，浔川AI五子棋的对弈水平逐渐提高。
浔川AI五子棋还具有一些其他的特性。它可以提供不同难度的对手选择，从初级到高级，以满足不同水平玩家的需求。此外，游戏还提供了多种游戏模式和主题，使得玩家能够体验到不同的游戏风格和乐趣。
总的来说，浔川AI五子棋是一款结合了人工智能技术的棋类游戏，通过对局分析和决策，提供了更具挑战性和趣味性的游戏体验。
本代码由浔川python社、浔川AI社联合创作。
下次更新： 2024/07/06 更新：v1.3 → v1.4
浔川AI五子棋 v1.0链接：浔川AI五子棋——浔川AI社_ai五子棋人工智能对弈-CSDN博客
正式代码： -*- coding: utf-8 -*- import tkinter as tk import tkinter.messagebox import pickle import random # 窗口 window = tk.Tk() window.title(&#39;欢迎进入python&#39;) window.geometry(&#39;450x200&#39;) # 画布放置图片 # canvas=tk.Canvas(window,height=300,width=500) # imagefile=tk.PhotoImage(file=&#39;qm.png&#39;) # image=canvas.create_image(0,0,anchor=&#39;nw&#39;,image=imagefile) # canvas.pack(side=&#39;top&#39;) # 标签 用户名密码 Verification_Code = random.randint(1000, 9999)#设置一个随机的四位数 Verification_Code = str(Verification_Code)#把类型转换为str型 print(type(Verification_Code)) tk.Label(window, text=&#39;用户名:&#39;).place(x=100, y=30) tk.Label(window, text=&#39;密码:&#39;).place(x=100, y=70) tk.Label(window, text=&#39;验证码&#39;).place(x=100, y=110) tk.Label(window, text=Verification_Code).place(x=320, y=110) # 用户名输入框 var_usr_name = tk.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-25T20:26:15+08:00">
    <meta property="article:modified_time" content="2024-06-25T20:26:15+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">浔川AI五子棋（改进（完整）版1.3）——浔川python社</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>简介：</h2> 
<p>浔川AI五子棋是一种使用人工智能技术来进行五子棋对弈的游戏。它采用了先进的算法和模型，在对弈过程中能够实时分析棋局并进行决策，使得游戏更具挑战性和趣味性。</p> 
<p>浔川AI五子棋的核心技术是人工智能算法。它使用深度学习模型对大量的五子棋对局进行训练，从而学习到了不同棋局下的最优解策略。通过不断的优化和迭代，浔川AI五子棋的对弈水平逐渐提高。</p> 
<p>浔川AI五子棋还具有一些其他的特性。它可以提供不同难度的对手选择，从初级到高级，以满足不同水平玩家的需求。此外，游戏还提供了多种游戏模式和主题，使得玩家能够体验到不同的游戏风格和乐趣。</p> 
<p>总的来说，浔川AI五子棋是一款结合了人工智能技术的棋类游戏，通过对局分析和决策，提供了更具挑战性和趣味性的游戏体验。</p> 
<hr> 
<blockquote> 
 <p>本代码由浔川python社、浔川AI社联合创作。</p> 
</blockquote> 
<hr> 
<blockquote> 
 <p> 下次更新： <strong>2024/07/06 更新：v1.3 → v1.4</strong></p> 
</blockquote> 
<hr> 
<blockquote> 
 <p>浔川AI五子棋 v1.0链接：<a href="https://blog.csdn.net/2401_83104529/article/details/139547103" title="浔川AI五子棋——浔川AI社_ai五子棋人工智能对弈-CSDN博客">浔川AI五子棋——浔川AI社_ai五子棋人工智能对弈-CSDN博客</a></p> 
</blockquote> 
<hr> 
<h2>正式代码：</h2> 
<pre><code class="language-python"> -*- coding: utf-8 -*-
import tkinter as tk
import tkinter.messagebox
import pickle
import random

# 窗口
window = tk.Tk()
window.title('欢迎进入python')
window.geometry('450x200')
# 画布放置图片
# canvas=tk.Canvas(window,height=300,width=500)
# imagefile=tk.PhotoImage(file='qm.png')
# image=canvas.create_image(0,0,anchor='nw',image=imagefile)
# canvas.pack(side='top')
# 标签 用户名密码
Verification_Code = random.randint(1000, 9999)#设置一个随机的四位数
Verification_Code = str(Verification_Code)#把类型转换为str型
print(type(Verification_Code))
tk.Label(window, text='用户名:').place(x=100, y=30)
tk.Label(window, text='密码:').place(x=100, y=70)
tk.Label(window, text='验证码').place(x=100, y=110)
tk.Label(window, text=Verification_Code).place(x=320, y=110)
# 用户名输入框
var_usr_name = tk.StringVar()
entry_usr_name = tk.Entry(window, textvariable=var_usr_name)
entry_usr_name.place(x=160, y=30)
# 密码输入框
var_usr_pwd = tk.StringVar()
entry_usr_pwd = tk.Entry(window, textvariable=var_usr_pwd, show='*')
entry_usr_pwd.place(x=160, y=70)
#验证码输入框
var_usr_yzm = tk.StringVar()
entry_usr_yzm = tk.Entry(window, textvariable=var_usr_yzm)
entry_usr_yzm.place(x=160, y=110)


# 登录函数
def usr_log_in():
    # 输入框获取用户名密码
    usr_name = var_usr_name.get()
    usr_pwd = var_usr_pwd.get()
    usr_yzm = var_usr_yzm.get()
    #测试类型
    print(type(usr_yzm),type(Verification_Code))
    # 从本地字典获取用户信息,如果没有则新建本地数据库
    try:
        with open('usr_info.pickle', 'rb') as usr_file:
            usrs_info = pickle.load(usr_file)
    except FileNotFoundError:
        with open('usr_info.pickle', 'wb') as usr_file:
            usrs_info = {'admin': 'admin'}
            pickle.dump(usrs_info, usr_file)
    # 判断验证码是否正确用户名和密码是否匹配
    if usr_yzm == Verification_Code:
        if usr_name in usrs_info:
            if usr_pwd == usrs_info[usr_name]:
                tk.messagebox.showinfo(title='welcome',
                                       message='欢迎您:' + usr_name)
            else:
                tk.messagebox.showerror(message='密码错误')
        # 用户名密码不能为空
        elif usr_name == '' or usr_pwd == '':
            tk.messagebox.showerror(message='用户名或密码为空')
        # 不在数据库中弹出是否注册的框
        else:
            is_signup = tk.messagebox.askyesno('欢迎', '您还没有注册,是否现在注册')
            if is_signup:
                usr_sign_up()
    elif usr_yzm == '':
        tk.messagebox.showerror(message='验证码不能为空')
    else:
        tk.messagebox.showerror(message='验证码有误!')


# 注册函数
def usr_sign_up():
    # 确认注册时的相应函数
    def signtowcg():
        # 获取输入框内的内容
        nn = new_name.get()
        np = new_pwd.get()
        npf = new_pwd_confirm.get()

        # 本地加载已有用户信息,如果没有则已有用户信息为空
        try:
            with open('usr_info.pickle', 'rb') as usr_file:
                exist_usr_info = pickle.load(usr_file)
        except FileNotFoundError:
            exist_usr_info = {}

            # 检查用户名存在、密码为空、密码前后不一致
        if nn in exist_usr_info:
            tk.messagebox.showerror('错误', '用户名已存在')
        elif np == '' or nn == '':
            tk.messagebox.showerror('错误', '用户名或密码为空')
        elif np != npf:
            tk.messagebox.showerror('错误', '密码前后不一致')
        # 注册信息没有问题则将用户名密码写入数据库
        else:
            exist_usr_info[nn] = np
            with open('usr_info.pickle', 'wb') as usr_file:
                pickle.dump(exist_usr_info, usr_file)
            tk.messagebox.showinfo('欢迎', '注册成功')
            # 注册成功关闭注册框
            window_sign_up.destroy()

    # 新建注册界面
    window_sign_up = tk.Toplevel(window)
    window_sign_up.geometry('350x200')
    window_sign_up.title('注册')
    # 用户名变量及标签、输入框
    new_name = tk.StringVar()
    tk.Label(window_sign_up, text='用户名:').place(x=10, y=10)
    tk.Entry(window_sign_up, textvariable=new_name).place(x=150, y=10)
    # 密码变量及标签、输入框
    new_pwd = tk.StringVar()
    tk.Label(window_sign_up, text='请输入密码:').place(x=10, y=50)
    tk.Entry(window_sign_up, textvariable=new_pwd, show='*').place(x=150, y=50)
    # 重复密码变量及标签、输入框
    new_pwd_confirm = tk.StringVar()
    tk.Label(window_sign_up, text='请再次输入密码:').place(x=10, y=90)
    tk.Entry(window_sign_up, textvariable=new_pwd_confirm, show='*').place(x=150, y=90)
    # 确认注册按钮及位置
    bt_confirm_sign_up = tk.Button(window_sign_up, text='确认注册',
                                   command=signtowcg)
    bt_confirm_sign_up.place(x=150, y=130)


# 退出的函数
def usr_sign_quit():
    window.destroy()


# 登录 注册按钮
bt_login = tk.Button(window, text='登录', command=usr_log_in)
bt_login.place(x=140, y=150)
bt_logup = tk.Button(window, text='注册', command=usr_sign_up)
bt_logup.place(x=210, y=150)
bt_logquit = tk.Button(window, text='退出', command=usr_sign_quit)
bt_logquit.place(x=280, y=150)
# 主循环
window.mainloop()
#下载、安装
import tkinter as tk
import time

# 创建主窗口
window = tk.Tk()
window.title('进度条')
window.geometry('630x150')

# 设置下载进度条
tk.Label(window, text='下载进度:', ).place(x=50, y=60)
canvas = tk.Canvas(window, width=465, height=22, bg="white")
canvas.place(x=110, y=60)


# 显示下载进度
def progress():
    # 填充进度条
    fill_line = canvas.create_rectangle(1.5, 1.5, 0, 23, width=0, fill="green")
    x = 500  # 未知变量,可更改
    n = 465 / x  # 465是矩形填充满的次数
    for i in range(x):
        n = n + 465 / x
        canvas.coords(fill_line, (0, 0, n, 60))
        window.update()
        time.sleep(0.02)  # 控制进度条流动的速度

    # 清空进度条
    fill_line = canvas.create_rectangle(1.5, 1.5, 0, 23, width=0, fill="white")
    x = 500  # 未知变量,可更改
    n = 465 / x  # 465是矩形填充满的次数

    for t in range(x):
        n = n + 465 / x
        # 以矩形的长度作为变量值更新
        canvas.coords(fill_line, (0, 0, n, 60))
        window.update()
        time.sleep(0)  # 时间为0,即飞速清空进度条


btn_download = tk.Button(window, text='开始下载', command=progress)
btn_download.place(x=400, y=105)

window.mainloop()

import tkinter as tk
import time

# 创建主窗口
window = tk.Tk()
window.title('进度条')
window.geometry('630x150')

# 设置下载进度条
tk.Label(window, text='安装进度:', ).place(x=50, y=60)
canvas = tk.Canvas(window, width=465, height=22, bg="white")
canvas.place(x=110, y=60)


# 显示下载进度
def progress():
    # 填充进度条
    fill_line = canvas.create_rectangle(1.5, 1.5, 0, 23, width=0, fill="green")
    x = 500  # 未知变量,可更改
    n = 465 / x  # 465是矩形填充满的次数
    for i in range(x):
        n = n + 465 / x
        canvas.coords(fill_line, (0, 0, n, 60))
        window.update()
        time.sleep(0.02)  # 控制进度条流动的速度

    # 清空进度条
    fill_line = canvas.create_rectangle(1.5, 1.5, 0, 23, width=0, fill="white")
    x = 500  # 未知变量,可更改
    n = 465 / x  # 465是矩形填充满的次数

    for t in range(x):
        n = n + 465 / x
        # 以矩形的长度作为变量值更新
        canvas.coords(fill_line, (0, 0, n, 60))
        window.update()
        time.sleep(0)  # 时间为0,即飞速清空进度条


btn_download = tk.Button(window, text='开始安装', command=progress)
btn_download.place(x=400, y=105)

window.mainloop()

#五子棋
from tkinter import *
import tkinter.messagebox  # 弹窗库
import numpy as np
 
root = Tk()                                 #创建窗口
root.title("浔川五子棋")                  #窗口名字
w1 = Canvas(root, width=600,height=600,background='chocolate')
w1.pack()
 
for i in range(0, 15):
    w1.create_line(i * 40 + 20, 20, i * 40 + 20, 580)
    w1.create_line(20, i * 40 + 20, 580, i * 40 + 20)
w1.create_oval(135, 135, 145, 145,fill='black')
w1.create_oval(135, 455, 145, 465,fill='black')
w1.create_oval(465, 135, 455, 145,fill='black')
w1.create_oval(455, 455, 465, 465,fill='black')
w1.create_oval(295, 295, 305, 305,fill='black')
 
num=0
A=np.full((15,15),0)
B=np.full((15,15),'')
def callback(event):
    global num ,A
    for j in range (0,15):
        for i in range (0,15):
            if (event.x - 20 - 40 * i) ** 2 + (event.y - 20 - 40 * j) ** 2 &lt;= 2 * 20 ** 2:
                break
        if (event.x - 20 - 40 * i) ** 2 + (event.y - 20 - 40 * j) ** 2 &lt;= 2*20 ** 2:
            break
    if num % 2 == 0 and A[i][j] != 1:
        w1.create_oval(40*i+5, 40*j+5, 40*i+35, 40*j+35,fill='black')
        A[i][j] = 1
        B[i][j] = 'b'
        num += 1
    if num % 2 != 0 and A[i][j] != 1 :
        w1.create_oval(40*i+5, 40*j+5, 40*i+35, 40*j+35,fill='white')
        A[i][j] = 1.
        B[i][j] = 'w'
        num += 1
 
    f = [[-1, 0], [-1, 1], [0, 1], [1, 1]]
    for z in range(0, 4):
        a, b = f[z][0], f[z][1]
        count1, count2 = 0, 0
        x, y = i, j
        while B[x][y] == B[i][j]:
            count1 += 1
            if x + a &gt;= 0 and y + b &gt;= 0 and x + a &lt; 15 and y + b &lt; 15 and B[x + a][y + b] == B[i][j]:
                [x, y] = np.array([x, y]) + np.array([a, b])
            else:
                x, y = i, j
                break
        while B[x][y] == B[i][j]:
            count2 += 1
            if x - a &lt; 15 and y - b &lt; 15 and x - a &gt;= 0 and y - b &gt;= 0 and B[x - a][y - b] == B[i][j]:
                [x, y] = np.array([x, y]) - np.array([a, b])
            else:
                break
        if count1 + count2 == 6:
            if B[i][j] == 'b':
                tkinter.messagebox.showinfo('提示', '黑棋获胜')
            else:
                tkinter.messagebox.showinfo('提示', '白棋获胜')
 
w1.bind("&lt;Button -1&gt;",callback)
w1.pack()
def quit():
    root.quit()
 
u=Button(root,text="退出",width=10,height=1,command=quit,font=('楷体',15))
u.pack()
 
mainloop()</code></pre> 
<hr> 
<h2>即将上线 公告！ </h2> 
<blockquote> 
 <h2>浔川AI翻译v3.0 即将上线！</h2> 
 <h2>公告链接：<br><a href="https://blog.csdn.net/2401_83104529/article/details/139873879?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171931801916800182122137%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=171931801916800182122137&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-10-139873879-null-null.142%5Ev100%5Epc_search_result_base6&amp;utm_term=%E6%B5%94%E5%B7%9Dai%E7%BF%BB%E8%AF%91%E6%9C%BA&amp;spm=1018.2226.3001.4187" title="“浔川AI翻译机v3.0”即将上线！-CSDN博客"><br> “浔川AI翻译机v3.0”即将上线！-CSDN博客</a></h2> 
</blockquote> 
<blockquote> 
 <h2>浔川画板v5.1 即将上线！</h2> 
 <h3>公告链接：<a href="https://blog.csdn.net/2401_83104529/article/details/139878368?spm=1001.2014.3001.5501" title="‘浔川画板v5.1’即将上线！——浔川python社-CSDN博客">‘浔川画板v5.1’即将上线！——浔川python社-CSDN博客</a></h3> 
</blockquote> 
<blockquote> 
 <h2>浔川AI五子棋v1.4 即将线！</h2> 
 <h3>公告链接：<a href="https://blog.csdn.net/2401_83104529/article/details/139547103" title="浔川AI五子棋——浔川AI社_ai五子棋人工智能对弈-CSDN博客">浔川AI五子棋——浔川AI社_ai五子棋人工智能对弈-CSDN博客</a></h3> 
</blockquote> 
<hr> 
<blockquote> 
 <p>本代码由浔川python社、浔川AI社联合创作。</p> 
</blockquote> 
<hr> 
<blockquote> 
 <p>版权所有，未经许可不得复制。 </p> 
</blockquote> 
<h2>版权所有，未经许可不得复制。 </h2> 
<h2>本内容版权独有，未经授权不得以任何形式复制、转载、摘编和使用，违者必究。</h2>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/06b868cebc7548abcd1db7b9ea24516d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">一文2000字记录基于jmeter&#43;perfmon的稳定性测试</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4e8dfc30e4f6bcdcf7884abef9001a79/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于SpringBoot和PostGIS的某国基地可视化实战</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>