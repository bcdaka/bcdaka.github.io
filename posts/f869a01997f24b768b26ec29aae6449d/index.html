<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>算法沉淀——动态规划之01背包问题（leetcode真题剖析） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/f869a01997f24b768b26ec29aae6449d/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="算法沉淀——动态规划之01背包问题（leetcode真题剖析）">
  <meta property="og:description" content="算法沉淀——动态规划之01背包问题 01.【模板】01背包02.分割等和子集03.目标和04.最后一块石头的重量 II 01背包问题是一类经典的动态规划问题，通常描述为：有一个固定容量的背包，以及一组物品，每件物品都有重量和价值，目标是找到在背包容量范围内，使得背包中的物品总价值最大的组合。 具体来说，问题的输入包括：
一个固定容量的背包（通常表示为一个整数W）。一组物品，每个物品有两个属性：重量（通常表示为一个整数weight）和价值（通常表示为一个整数value）。求解的目标是找到一种放置物品的方式，使得放入背包的物品的总重量不超过背包容量，并且总价值最大。 这个问题的特点是，对于每件物品，你只能选择将其放入背包一次（0-1，因此称为“01背包”），或者不放入背包。不能将物品切割成更小的部分放入背包，要么整个物品放入背包，要么不放入。
动态规划解法：
定义状态： 通常使用二维数组dp[i][j]表示在前i个物品中，背包容量为j时的最大总价值。
状态转移方程： 考虑第i个物品，可以选择放入背包或者不放入。如果选择放入，那么总价值为dp[i-1][j-weight[i]] &#43; value[i]，即前i-1个物品的总价值加上当前物品的价值。如果选择不放入，那么总价值为dp[i-1][j]，即前i-1个物品的总价值。因此，状态转移方程为：
dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] &#43; value[i]) 其中，dp[i-1][j]表示不放入第i个物品，dp[i-1][j-weight[i]] &#43; value[i]表示放入第i个物品。
初始条件： 当i=0时，表示前0个物品，总价值为0；当j=0时，表示背包容量为0，总价值也为0。
遍历顺序： 外层循环遍历物品，内层循环遍历背包容量。
返回结果： 最终结果存储在dp[N][W]中，其中N为物品数量，W为背包容量。
例子：
假设有如下物品：
Copy code解释物品1：重量=2，价值=3 物品2：重量=3，价值=4 物品3：重量=4，价值=5 物品4：重量=5，价值=6 背包容量为W=8，我们要求解在这个条件下的最大总价值。
按照上述动态规划解法，构建状态转移表如下：
luaCopy code解释 重量/价值 0 1 2 3 4 5 6 7 8 ---------------------------------------------- 物品0 0 0 0 0 0 0 0 0 0 物品1 0 0 3 3 3 3 3 3 3 物品2 0 0 3 4 4 7 7 7 10 物品3 0 0 3 4 4 7 8 8 11 物品4 0 0 3 4 4 7 8 9 11 因此，最终结果为dp[4][8] = 11，表示在背包容量为8的情况下，最大总价值为11。这意味着最优解是选择物品2和物品4放入背包。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-04T22:44:38+08:00">
    <meta property="article:modified_time" content="2024-03-04T22:44:38+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">算法沉淀——动态规划之01背包问题（leetcode真题剖析）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/cb/c1/S6JTaaAc_o.jpg" alt="在这里插入图片描述"></p> 
<p></p> 
<div class="toc"> 
 <h4>算法沉淀——动态规划之01背包问题</h4> 
 <ul><li><a href="#0101_58" rel="nofollow">01.【模板】01背包</a></li><li><a href="#02_236" rel="nofollow">02.分割等和子集</a></li><li><a href="#03_324" rel="nofollow">03.目标和</a></li><li><a href="#04_II_402" rel="nofollow">04.最后一块石头的重量 II</a></li></ul> 
</div> 
<br> 01背包问题是一类经典的动态规划问题，通常描述为：有一个固定容量的背包，以及一组物品，每件物品都有重量和价值，目标是找到在背包容量范围内，使得背包中的物品总价值最大的组合。 
<p></p> 
<p>具体来说，问题的输入包括：</p> 
<ol><li>一个固定容量的背包（通常表示为一个整数<code>W</code>）。</li><li>一组物品，每个物品有两个属性：重量（通常表示为一个整数<code>weight</code>）和价值（通常表示为一个整数<code>value</code>）。</li><li>求解的目标是找到一种放置物品的方式，使得放入背包的物品的总重量不超过背包容量，并且总价值最大。</li></ol> 
<p>这个问题的特点是，对于每件物品，你只能选择将其放入背包一次（0-1，因此称为“01背包”），或者不放入背包。不能将物品切割成更小的部分放入背包，要么整个物品放入背包，要么不放入。</p> 
<p><strong>动态规划解法</strong>：</p> 
<ol><li> <p><strong>定义状态：</strong> 通常使用二维数组<code>dp[i][j]</code>表示在前<code>i</code>个物品中，背包容量为<code>j</code>时的最大总价值。</p> </li><li> <p><strong>状态转移方程：</strong> 考虑第<code>i</code>个物品，可以选择放入背包或者不放入。如果选择放入，那么总价值为<code>dp[i-1][j-weight[i]] + value[i]</code>，即前<code>i-1</code>个物品的总价值加上当前物品的价值。如果选择不放入，那么总价值为<code>dp[i-1][j]</code>，即前<code>i-1</code>个物品的总价值。因此，状态转移方程为：</p> <pre><code class="prism language-cpp">dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>weight<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> value<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre> <p>其中，<code>dp[i-1][j]</code>表示不放入第<code>i</code>个物品，<code>dp[i-1][j-weight[i]] + value[i]</code>表示放入第<code>i</code>个物品。</p> </li><li> <p><strong>初始条件：</strong> 当<code>i=0</code>时，表示前0个物品，总价值为0；当<code>j=0</code>时，表示背包容量为0，总价值也为0。</p> </li><li> <p><strong>遍历顺序：</strong> 外层循环遍历物品，内层循环遍历背包容量。</p> </li><li> <p><strong>返回结果：</strong> 最终结果存储在<code>dp[N][W]</code>中，其中<code>N</code>为物品数量，<code>W</code>为背包容量。</p> </li></ol> 
<p><strong>例子</strong>：</p> 
<p>假设有如下物品：</p> 
<pre><code>Copy code解释物品1：重量=2，价值=3
物品2：重量=3，价值=4
物品3：重量=4，价值=5
物品4：重量=5，价值=6
</code></pre> 
<p>背包容量为<code>W=8</code>，我们要求解在这个条件下的最大总价值。</p> 
<p>按照上述动态规划解法，构建状态转移表如下：</p> 
<pre><code>luaCopy code解释  重量/价值   0   1   2   3   4   5   6   7   8
  ----------------------------------------------
  物品0        0   0   0   0   0   0   0   0   0
  物品1        0   0   3   3   3   3   3   3   3
  物品2        0   0   3   4   4   7   7   7  10
  物品3        0   0   3   4   4   7   8   8  11
  物品4        0   0   3   4   4   7   8   9  11
</code></pre> 
<p>因此，最终结果为<code>dp[4][8] = 11</code>，表示在背包容量为8的情况下，最大总价值为11。这意味着最优解是选择物品2和物品4放入背包。</p> 
<h2><a id="0101_58"></a>01.【模板】01背包</h2> 
<p>题目链接：https://www.nowcoder.com/practice/fd55637d3f24484e96dad9e992d3f62e?tpId=230&amp;tqId=2032484&amp;ru=/exam/oj&amp;qru=/ta/dynamic-programming/question-ranking&amp;sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D196</p> 
<p>你有一个背包，最多能容纳的体积是V。</p> 
<p>现在有n个物品，第i个物品的体积为vi,价值为wi。</p> 
<p>（1）求这个背包至多能装多大价值的物品？</p> 
<p>（2）若背包<strong>恰好装满</strong>，求至多能装多大价值的物品？</p> 
<p><strong>输入描述</strong>：</p> 
<p>第一行两个整数n和V，表示物品个数和背包体积。</p> 
<p>接下来n行，每行两个数vi和wi，表示第i个物品的体积和价值。</p> 
<p>1≤n,V;vi,wi≤1000</p> 
<p><strong>输出描述</strong>：</p> 
<p>输出有两行，第一行输出第一问的答案，第二行输出第二问的答案，如果无解请输出0。</p> 
<p><strong>示例1</strong></p> 
<p><strong>输入</strong>：</p> 
<pre><code>3 5
2 10
4 5
1 4
</code></pre> 
<p><strong>输出</strong>：</p> 
<pre><code>14
9
</code></pre> 
<p>复制</p> 
<p>说明：</p> 
<pre><code>装第一个和第三个物品时总价值最大，但是装第二个和第三个物品可以使得背包恰好装满且总价值最大。 
</code></pre> 
<p><strong>示例2</strong></p> 
<p><strong>输入</strong>：</p> 
<pre><code>3 8
12 6
11 8
6 8
</code></pre> 
<p><strong>输出</strong>：</p> 
<pre><code>8
0
</code></pre> 
<p><strong>说明</strong>：</p> 
<pre><code>装第三个物品时总价值最大但是不满，装满背包无解。 要求O(nV)的时间复杂度，O(V)空间复杂度
</code></pre> 
<p><strong>思路</strong></p> 
<p><strong>第一问：</strong></p> 
<ol><li><strong>状态表示：</strong> 
  <ul><li><code>dp[i][j]</code> 表示从前 <code>i</code> 个物品中挑选，总体积不超过 <code>j</code> 的情况下，所有的选法中能挑选出的最大价值。</li></ul> </li><li><strong>状态转移方程：</strong> 
  <ul><li>对于每个物品，我们有两种选择： 
    <ul><li>不选第 <code>i</code> 个物品：此时 <code>dp[i][j] = dp[i - 1][j]</code>。</li><li>选择第 <code>i</code> 个物品：此时需要确保总体积不超过 <code>j - v[i]</code>，而且该状态是合法的，即 <code>j &gt;= v[i]</code> 和 <code>dp[i - 1][j - v[i]]</code> 存在。状态转移方程为 <code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i])</code>。</li></ul> </li></ul> </li><li><strong>初始化：</strong> 
  <ul><li>多加一行，第一行初始化为 <code>0</code>，因为不选任何物品总体积为 <code>0</code>时，价值为 <code>0</code>。</li></ul> </li><li><strong>填表顺序：</strong> 
  <ul><li>从上往下，每一行从左往右填表。</li></ul> </li><li><strong>返回值：</strong> 
  <ul><li>返回 <code>dp[n][V]</code>，即最后一行最后一列的值。</li></ul> </li></ol> 
<p><strong>第二问：</strong></p> 
<ol><li><strong>状态表示：</strong> 
  <ul><li><code>dp[i][j]</code> 表示从前 <code>i</code> 个物品中挑选，总体积正好等于 <code>j</code> 的情况下，所有的选法中能挑选出的最大价值。</li></ul> </li><li><strong>状态转移方程：</strong> 
  <ul><li><code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i])</code>。</li><li>在使用 <code>dp[i - 1][j - v[i]]</code> 时，需要判断 <code>j &gt;= v[i]</code> 和 <code>dp[i - 1][j - v[i]]</code> 是否为 <code>-1</code>。</li></ul> </li><li><strong>初始化：</strong> 
  <ul><li>多加一行，第一格初始化为 <code>0</code>，表示正好凑齐体积为 <code>0</code>的背包。</li><li>第一行后面的格子初始化为 <code>-1</code>，因为没有物品，无法满足体积大于 <code>0</code>的情况。</li></ul> </li><li><strong>填表顺序：</strong> 
  <ul><li>从上往下，每一行从左往右填表。</li></ul> </li><li><strong>返回值：</strong> 
  <ul><li>由于最后可能凑不成体积为 <code>V</code> 的情况，需要特判。</li></ul> </li></ol> 
<p><strong>代码</strong></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token keyword">int</span> N<span class="token operator">=</span><span class="token number">1002</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span>V<span class="token punctuation">,</span>v<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>w<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> dp<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    cin<span class="token operator">&gt;&gt;</span>n<span class="token operator">&gt;&gt;</span>V<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> cin<span class="token operator">&gt;&gt;</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&gt;&gt;</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>V<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">&gt;=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    cout<span class="token operator">&lt;&lt;</span>dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>

    <span class="token function">memset</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span> dp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>V<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>V<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">&gt;=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">?</span><span class="token number">0</span><span class="token operator">:</span>dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>优化步骤：</strong></p> 
<ol><li><strong>滚动数组的应用：</strong> 
  <ul><li>在01背包问题中，通过滚动数组可以删去所有的横坐标，因为状态 <code>dp[i][j]</code> 只依赖于上一行的状态 <code>dp[i-1][j]</code> 和 <code>dp[i-1][j-v[i]]</code>，因此只需保留一行状态。</li></ul> </li><li><strong>遍历顺序修改：</strong> 
  <ul><li>修改了 <code>j</code> 的遍历顺序，原本的遍历是从 <code>0</code> 到 <code>V</code>，现在改为从 <code>V</code> 到 <code>0</code>。这样做的原因是，如果从 <code>0</code> 到 <code>V</code> 遍历，会使用当前行的 <code>dp[i-1][j-v[i]]</code> 的值，而我们已经在上一步的滚动数组中删除了这一行，所以需要改变遍历顺序，从 <code>V</code> 到 <code>0</code>。</li></ul> </li></ol> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token keyword">int</span> N<span class="token operator">=</span><span class="token number">1002</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span>V<span class="token punctuation">,</span>v<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>w<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> dp<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    cin<span class="token operator">&gt;&gt;</span>n<span class="token operator">&gt;&gt;</span>V<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> cin<span class="token operator">&gt;&gt;</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&gt;&gt;</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>V<span class="token punctuation">;</span>j<span class="token operator">&gt;=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>
            dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    cout<span class="token operator">&lt;&lt;</span>dp<span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>

    <span class="token function">memset</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span> dp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>V<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>V<span class="token punctuation">;</span>j<span class="token operator">&gt;=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">?</span><span class="token number">0</span><span class="token operator">:</span>dp<span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="02_236"></a>02.分割等和子集</h2> 
<p>题目链接：https://leetcode.cn/problems/partition-equal-subset-sum/</p> 
<p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p> 
<p><strong>示例 1：</strong></p> 
<pre><code>输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
</code></pre> 
<p><strong>示例 2：</strong></p> 
<pre><code>输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
</code></pre> 
<p><strong>提示：</strong></p> 
<ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul> 
<p><strong>思路</strong></p> 
<ol><li><strong>状态表达：</strong> 
  <ul><li><code>dp[i][j]</code> 表示在前 <code>i</code> 个元素中选择，所有的选法中，能否凑成总和为 <code>j</code> 这个数。</li></ul> </li><li><strong>状态转移方程：</strong> 
  <ul><li>根据最后一个位置的元素，分两种情况讨论： 
    <ul><li>不选择 <code>nums[i]</code>：此时是否能够凑成总和为 <code>j</code> 取决于前 <code>i-1</code> 个元素的情况，即 <code>dp[i][j] = dp[i-1][j]</code>。</li><li>选择 <code>nums[i]</code>：如果 <code>nums[i]</code> 小于等于 <code>j</code>，则需要看前 <code>i-1</code> 个元素中是否能凑成总和为 <code>j - nums[i]</code>，即 <code>dp[i][j] = dp[i][j] || dp[i-1][j - nums[i]]</code>。</li></ul> </li></ul> </li><li><strong>初始化：</strong> 
  <ul><li>第一行表示不选择任何元素，要凑成目标和 <code>j</code>，只有当目标和为 <code>0</code> 时才能做到，因此第一行仅需初始化第一个元素 <code>dp[0][0] = true</code>。</li></ul> </li><li><strong>填表顺序：</strong> 
  <ul><li>根据状态转移方程，从上往下填写每一行，每一行的顺序是无所谓的。</li></ul> </li><li><strong>返回值：</strong> 
  <ul><li>根据状态表达，返回 <code>dp[n][aim]</code> 的值，其中 <code>n</code> 表示数组的大小， <code>aim</code> 表示要凑的目标和。</li></ul> </li><li><strong>空间优化：</strong> 
  <ul><li>对于 01 背包类型的问题，可以进行空间上的优化，即删除第一维，并修改第二层循环的遍历顺序。</li></ul> </li></ol> 
<p><strong>代码</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">bool</span> <span class="token function">canPartition</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> n<span class="token operator">=</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token operator">:</span>nums<span class="token punctuation">)</span> sum<span class="token operator">+=</span>x<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>sum<span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span> aim<span class="token operator">=</span>sum<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>aim<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>aim<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">&gt;=</span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">||</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>aim<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>空间优化</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">bool</span> <span class="token function">canPartition</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> n<span class="token operator">=</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token operator">:</span>nums<span class="token punctuation">)</span> sum<span class="token operator">+=</span>x<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>sum<span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span> aim<span class="token operator">=</span>sum<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>aim<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>aim<span class="token punctuation">;</span>j<span class="token operator">&gt;=</span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>
                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">||</span>dp<span class="token punctuation">[</span>j<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>aim<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="03_324"></a>03.目标和</h2> 
<p>题目链接：https://leetcode.cn/problems/target-sum/</p> 
<p>给你一个非负整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p> 
<p>向数组中的每个整数前添加 <code>'+'</code> 或 <code>'-'</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p> 
<ul><li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>'+'</code> ，在 <code>1</code> 之前添加 <code>'-'</code> ，然后串联起来得到表达式 <code>"+2-1"</code> 。</li></ul> 
<p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p> 
<p><strong>示例 1：</strong></p> 
<pre><code>输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
</code></pre> 
<p><strong>示例 2：</strong></p> 
<pre><code>输入：nums = [1], target = 1
输出：1
</code></pre> 
<p><strong>提示：</strong></p> 
<ul><li><code>1 &lt;= nums.length &lt;= 20</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li><li><code>0 &lt;= sum(nums[i]) &lt;= 1000</code></li><li><code>-1000 &lt;= target &lt;= 1000</code></li></ul> 
<p><strong>思路</strong></p> 
<ol><li><strong>状态表示：</strong> 
  <ul><li><code>dp[i][j]</code> 表示在前 <code>i</code> 个数中选，总和正好等于 <code>j</code>，一共有多少种选法。</li></ul> </li><li><strong>状态转移方程：</strong> 
  <ul><li>根据最后一个位置的元素，结合题目的要求，有两种策略： 
    <ul><li>不选 <code>nums[i]</code>：此时凑成总和 <code>j</code> 的总方案数，要看在前 <code>i-1</code> 个元素中选，凑成总和为 <code>j</code> 的方案数，即 <code>dp[i][j] = dp[i-1][j]</code>。</li><li>选择 <code>nums[i]</code>：如果 <code>nums[i]</code> 小于等于 <code>j</code>，则需要看前 <code>i-1</code> 个元素中是否能凑成总和为 <code>j - nums[i]</code>，即 <code>dp[i][j] += dp[i-1][j - nums[i]]</code>。</li></ul> </li></ul> </li><li><strong>初始化：</strong> 
  <ul><li>需要用到上一行的数据，因此初始化第一行，表示不选择任何元素凑成目标和 <code>j</code>。只有当目标和为 <code>0</code> 时才能做到，因此第一行仅需初始化第一个元素 <code>dp[0][0] = 1</code>。</li></ul> </li><li><strong>填表顺序：</strong> 
  <ul><li>根据状态转移方程，从上往下填写每一行，每一行的顺序是无所谓的。</li></ul> </li><li><strong>返回值：</strong> 
  <ul><li>根据状态表示，返回 <code>dp[n][aim]</code> 的值，其中 <code>n</code> 表示数组的大小， <code>aim</code> 表示要凑的目标和。</li></ul> </li></ol> 
<p><strong>代码</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">findTargetSumWays</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x<span class="token operator">:</span>nums<span class="token punctuation">)</span> sum<span class="token operator">+=</span>x<span class="token punctuation">;</span>
        <span class="token keyword">int</span> aim<span class="token operator">=</span><span class="token punctuation">(</span>sum<span class="token operator">+</span>target<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>aim<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">||</span><span class="token punctuation">(</span>sum<span class="token operator">+</span>target<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> n<span class="token operator">=</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>aim<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> aim<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">&gt;=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>aim<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="04_II_402"></a>04.最后一块石头的重量 II</h2> 
<p>题目链接：https://leetcode.cn/problems/last-stone-weight-ii/</p> 
<p>有一堆石头，用整数数组 <code>stones</code> 表示。其中 <code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p> 
<p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p> 
<ul><li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li><li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li></ul> 
<p>最后，<strong>最多只会剩下一块</strong> 石头。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 <code>0</code>。</p> 
<p><strong>示例 1：</strong></p> 
<pre><code>输入：stones = [2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。
</code></pre> 
<p><strong>示例 2：</strong></p> 
<pre><code>输入：stones = [31,26,33,21,40]
输出：5
</code></pre> 
<p><strong>提示：</strong></p> 
<ul><li><code>1 &lt;= stones.length &lt;= 30</code></li><li><code>1 &lt;= stones[i] &lt;= 100</code></li></ul> 
<p><strong>思路</strong></p> 
<ol><li><strong>状态表示：</strong> 
  <ul><li><code>dp[i][j]</code> 表示在前 <code>i</code> 个元素中选择，总和不超过 <code>j</code> 的情况下，这些元素的最大和。</li></ul> </li><li><strong>状态转移方程：</strong> 
  <ul><li>根据最后一个位置的元素，结合题目的要求，有两种策略： 
    <ul><li>不选 <code>stones[i]</code>：此时是否能够凑成总和为 <code>j</code>，要看在前 <code>i-1</code> 个元素中选，能否凑成总和为 <code>j</code>。根据状态表示，此时 <code>dp[i][j] = dp[i-1][j]</code>。</li><li>选择 <code>stones[i]</code>：这种情况下是有前提条件的，此时的 <code>stones[i]</code> 应该是小于等于 <code>j</code>。因为如果这个元素都比要凑成的总和大，选择它就没有意义。那么是否能够凑成总和为 <code>j</code>，要看在前 <code>i-1</code> 个元素中选，能否凑成总和为 <code>j - stones[i]</code>。根据状态表示，此时 <code>dp[i][j] = dp[i-1][j-stones[i]] + stones[i]</code>。</li></ul> </li></ul> </li><li><strong>初始化：</strong> 
  <ul><li>由于需要用到上一行的数据，可以先将第一行初始化。</li><li>第一行表示「没有石头」，因此想凑成目标和 <code>j</code> 的最大和都是 <code>0</code>。</li></ul> </li><li><strong>填表顺序：</strong> 
  <ul><li>根据状态转移方程，从上往下填写每一行，每一行的顺序是无所谓的。</li></ul> </li><li><strong>返回值：</strong> 
  <ul><li>根据状态表示，找到最接近 <code>sum / 2</code> 的最大和 <code>dp[n][sum / 2]</code>。</li><li>返回 <code>sum - 2 * dp[n][sum / 2]</code>，因为我们要的是两堆石头的差。</li></ul> </li></ol> 
<p><strong>代码</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">lastStoneWeightII</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> stones<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token operator">:</span>stones<span class="token punctuation">)</span> sum<span class="token operator">+=</span>x<span class="token punctuation">;</span>
        <span class="token keyword">int</span> n<span class="token operator">=</span>stones<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>m<span class="token operator">=</span>sum<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">&gt;=</span>stones<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> 
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>stones<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>stones<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token keyword">return</span> sum<span class="token operator">-</span><span class="token number">2</span><span class="token operator">*</span>dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/13dd64f6c05603f908e7b3349f81fe0e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">微信开发者工具下载及小程序项目的创建与调试（完整图文教程）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9c6a1572196720429cb571678affd2e3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">算法沉淀——动态规划之完全背包问题（leetcode真题剖析）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>