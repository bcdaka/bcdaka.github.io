<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>é¸¿è’™è½»å†…æ ¸Aæ ¸æºç åˆ†æç³»åˆ—ä¸ƒ è¿›ç¨‹ç®¡ç† (3) - ç¼–ç¨‹å¤§å’–</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/cbd98e9139122b9f354c9af80a1fbf28/">
  <meta property="og:site_name" content="ç¼–ç¨‹å¤§å’–">
  <meta property="og:title" content="é¸¿è’™è½»å†…æ ¸Aæ ¸æºç åˆ†æç³»åˆ—ä¸ƒ è¿›ç¨‹ç®¡ç† (3)">
  <meta property="og:description" content="æœ¬æ–‡è®°å½•ä¸‹è¿›ç¨‹ç›¸å…³çš„åˆå§‹åŒ–å‡½æ•°ï¼Œå¦‚OsSystemProcessCreateã€OsProcessInitã€OsProcessCreateInitã€OsUserInitProcessã€OsDeInitPCBã€OsUserInitProcessStartç­‰ã€‚
1ã€LiteOS-Aå†…æ ¸è¿›ç¨‹åˆ›å»ºåˆå§‹åŒ–é€šç”¨å‡½æ•° å…ˆçœ‹çœ‹ä¸€äº›å†…éƒ¨å‡½æ•°ï¼Œä¸ç®¡æ˜¯åˆå§‹åŒ–ç”¨æˆ·æ€è¿›ç¨‹è¿˜æ˜¯å†…æ ¸æ€è¿›ç¨‹ï¼Œéƒ½ä¼šä½¿ç”¨è¿™äº›å‡½æ•°ï¼ŒåŒ…å«è¿›ç¨‹æ§åˆ¶å—åˆå§‹åŒ–å‡½æ•°OsInitPCBã€è¿›ç¨‹æ§åˆ¶å—åˆå§‹åŒ–æ¢å¤å‡½æ•°OsDeInitPCB
1.1 è¿›ç¨‹æ§åˆ¶å—åˆå§‹åŒ–å‡½æ•°OsInitPCB è¿›ç¨‹æ§åˆ¶å—åˆå§‹åŒ–å‡½æ•°OsInitPCBéœ€è¦3ä¸ªå‚æ•°ï¼Œç¬¬ä¸€ä¸ªå‚æ•°processCBæ˜¯è¿›ç¨‹å—æŒ‡é’ˆï¼Œç¬¬äºŒä¸ªå‚æ•°ä¸ºè¿›ç¨‹æ¨¡å¼modeï¼Œåˆ†ä¸ºå†…æ ¸æ€è¿›ç¨‹OS_KERNEL_MODEå’Œç”¨æˆ·æ€è¿›ç¨‹OS_USER_MODEã€‚ç¬¬ä¸‰ä¸ªå‚æ•°ç”¨äºè®¾ç½®è¿›ç¨‹åç§°ã€‚è¿”å›å€¼ä¸ºåˆå§‹åŒ–æˆåŠŸLOS_OKè¿˜æ˜¯å¤±è´¥LOS_ENOMEMã€‚çœ‹ä¸‹ä»£ç ï¼Œâ‘´å¤„è®¾ç½®è¿›ç¨‹æ§åˆ¶å—çš„ä¿¡æ¯ï¼Œç”¨æˆ·æ€è¿›ç¨‹è¿˜æ˜¯å†…æ ¸æ€è¿›ç¨‹ï¼Œè¿›ç¨‹çŠ¶æ€è®¾ç½®ä¸ºåˆå§‹åŒ–çŠ¶æ€ï¼Œçº¿ç¨‹ç»„ç¼–å·è®¾ç½®ä¸ºæ— æ•ˆå€¼ï¼Œè®¾ç½®ä¸ºé»˜è®¤æ©ç ï¼Œå®šæ—¶å™¨ç¼–å·è®¾ç½®ä¸ºæ— æ•ˆå€¼ã€‚â‘µå¤„åˆå§‹åŒ–è¿›ç¨‹çš„åŒå‘é“¾è¡¨ã€‚å¦‚æœç³»ç»Ÿé…ç½®æ”¯æŒè™šæ‹Ÿå†…å­˜ï¼Œåˆ™æ‰§è¡Œâ‘¶åˆ¤æ–­åˆå§‹åŒ–çš„è¿›ç¨‹æ˜¯å¦ä¸ºç”¨æˆ·æ€è¿›ç¨‹ï¼Œå¦‚æœæ˜¯ç”¨æˆ·æ€è¿›ç¨‹ï¼Œåˆ™åˆ›å»ºè™šæ‹Ÿåœ°å€ç©ºé—´ï¼Œå¦‚æœåˆ›å»ºå¤±è´¥ï¼Œåˆ™æŠŠè¿›ç¨‹çŠ¶æ€è®¾ç½®ä¸ºæœªä½¿ç”¨çŠ¶æ€ï¼Œç„¶åè¿”å›é”™è¯¯ç ã€‚â‘·å¤„è¡¨ç¤ºå¦‚æœæ˜¯å†…æ ¸æ€è¿›ç¨‹ï¼Œåˆ™æŒ‡å®šè¿›ç¨‹çš„å†…æ ¸è¿›ç¨‹è™šæ‹Ÿåœ°å€ç©ºé—´ã€‚æœ‰å…³è™šæ‹Ÿåœ°å€ç©ºé—´çš„ä¿¡æ¯ï¼Œè¯·å‚è€ƒä¹‹å‰çš„ç³»åˆ—æ–‡ç« ã€‚
å¦‚æœæ‰§è¡ŒCPUPç‰¹æ€§ï¼Œåˆ™æ‰§è¡Œâ‘¸å¤„ä»£ç ï¼Œåˆ™ä¸ºCPUPç»“æ„ä½“ç”³è¯·å†…å­˜ç©ºé—´ã€‚â‘¹å¤„ï¼Œå¦‚æœå¼€å¯äº†LOSCFG_SECURITY_VIDï¼Œåˆ™Våˆå§‹åŒ–IDæ˜ å°„é“¾è¡¨ã€‚â‘ºå¤„ï¼Œå¦‚æœå¼€å¯äº†å®‰å…¨èƒ½åŠ›LOSCFG_SECURITY_CAPABILITYï¼Œåˆ™è¿›è¡Œç›¸åº”çš„åˆå§‹åŒ–ã€‚â‘»å¤„ä¸ºè¿›ç¨‹è®¾ç½®ä¸€ä¸ªåç§°ã€‚
STATIC UINT32 OsInitPCB(LosProcessCB *processCB, UINT32 mode, const CHAR *name) { â‘´ processCB-&gt;processMode = mode; processCB-&gt;processStatus = OS_PROCESS_STATUS_INIT; processCB-&gt;parentProcessID = OS_INVALID_VALUE; processCB-&gt;threadGroupID = OS_INVALID_VALUE; processCB-&gt;umask = OS_PROCESS_DEFAULT_UMASK; processCB-&gt;timerID = (timer_t)(UINTPTR)MAX_INVALID_TIMER_VID; â‘µ LOS_ListInit(&amp;processCB-&gt;threadSiblingList); LOS_ListInit(&amp;processCB-&gt;childrenList); LOS_ListInit(&amp;processCB-&gt;exitChildList); LOS_ListInit(&amp;(processCB-&gt;waitList)); #ifdef LOSCFG_KERNEL_VM â‘¶ if (OsProcessIsUserMode(processCB)) { processCB-&gt;vmSpace = OsCreateUserVmSpace(); if (processCB-&gt;vmSpace == NULL) { processCB-&gt;processStatus = OS_PROCESS_FLAG_UNUSED; return LOS_ENOMEM; } } else { â‘· processCB-&gt;vmSpace = LOS_GetKVmSpace(); } #endif #ifdef LOSCFG_KERNEL_CPUP â‘¸ processCB-&gt;processCpup = (OsCpupBase *)LOS_MemAlloc(m_aucSysMem1, sizeof(OsCpupBase)); if (processCB-&gt;processCpup == NULL) { return LOS_ENOMEM; } (VOID)memset_s(processCB-&gt;processCpup, sizeof(OsCpupBase), 0, sizeof(OsCpupBase)); #endif #ifdef LOSCFG_SECURITY_VID â‘¹ status_t status = VidMapListInit(processCB); if (status !">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-13T21:04:02+08:00">
    <meta property="article:modified_time" content="2024-06-13T21:04:02+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="ç¼–ç¨‹å¤§å’–" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">ç¼–ç¨‹å¤§å’–</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">é¸¿è’™è½»å†…æ ¸Aæ ¸æºç åˆ†æç³»åˆ—ä¸ƒ è¿›ç¨‹ç®¡ç† (3)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>æœ¬æ–‡è®°å½•ä¸‹è¿›ç¨‹ç›¸å…³çš„åˆå§‹åŒ–å‡½æ•°ï¼Œå¦‚OsSystemProcessCreateã€OsProcessInitã€OsProcessCreateInitã€OsUserInitProcessã€OsDeInitPCBã€OsUserInitProcessStartç­‰ã€‚</p> 
<h2><a id="1LiteOSA_2"></a>1ã€LiteOS-Aå†…æ ¸è¿›ç¨‹åˆ›å»ºåˆå§‹åŒ–é€šç”¨å‡½æ•°</h2> 
<p>å…ˆçœ‹çœ‹ä¸€äº›å†…éƒ¨å‡½æ•°ï¼Œä¸ç®¡æ˜¯åˆå§‹åŒ–ç”¨æˆ·æ€è¿›ç¨‹è¿˜æ˜¯å†…æ ¸æ€è¿›ç¨‹ï¼Œéƒ½ä¼šä½¿ç”¨è¿™äº›å‡½æ•°ï¼ŒåŒ…å«è¿›ç¨‹æ§åˆ¶å—åˆå§‹åŒ–å‡½æ•°OsInitPCBã€è¿›ç¨‹æ§åˆ¶å—åˆå§‹åŒ–æ¢å¤å‡½æ•°OsDeInitPCB</p> 
<h3><a id="11_OsInitPCB_6"></a>1.1 è¿›ç¨‹æ§åˆ¶å—åˆå§‹åŒ–å‡½æ•°OsInitPCB</h3> 
<p>è¿›ç¨‹æ§åˆ¶å—åˆå§‹åŒ–å‡½æ•°OsInitPCBéœ€è¦3ä¸ªå‚æ•°ï¼Œç¬¬ä¸€ä¸ªå‚æ•°processCBæ˜¯è¿›ç¨‹å—æŒ‡é’ˆï¼Œç¬¬äºŒä¸ªå‚æ•°ä¸ºè¿›ç¨‹æ¨¡å¼modeï¼Œåˆ†ä¸ºå†…æ ¸æ€è¿›ç¨‹OS_KERNEL_MODEå’Œç”¨æˆ·æ€è¿›ç¨‹OS_USER_MODEã€‚ç¬¬ä¸‰ä¸ªå‚æ•°ç”¨äºè®¾ç½®è¿›ç¨‹åç§°ã€‚è¿”å›å€¼ä¸ºåˆå§‹åŒ–æˆåŠŸLOS_OKè¿˜æ˜¯å¤±è´¥LOS_ENOMEMã€‚çœ‹ä¸‹ä»£ç ï¼Œâ‘´å¤„è®¾ç½®è¿›ç¨‹æ§åˆ¶å—çš„ä¿¡æ¯ï¼Œç”¨æˆ·æ€è¿›ç¨‹è¿˜æ˜¯å†…æ ¸æ€è¿›ç¨‹ï¼Œè¿›ç¨‹çŠ¶æ€è®¾ç½®ä¸ºåˆå§‹åŒ–çŠ¶æ€ï¼Œçº¿ç¨‹ç»„ç¼–å·è®¾ç½®ä¸ºæ— æ•ˆå€¼ï¼Œè®¾ç½®ä¸ºé»˜è®¤æ©ç ï¼Œå®šæ—¶å™¨ç¼–å·è®¾ç½®ä¸ºæ— æ•ˆå€¼ã€‚â‘µå¤„åˆå§‹åŒ–è¿›ç¨‹çš„åŒå‘é“¾è¡¨ã€‚å¦‚æœç³»ç»Ÿé…ç½®æ”¯æŒè™šæ‹Ÿå†…å­˜ï¼Œåˆ™æ‰§è¡Œâ‘¶åˆ¤æ–­åˆå§‹åŒ–çš„è¿›ç¨‹æ˜¯å¦ä¸ºç”¨æˆ·æ€è¿›ç¨‹ï¼Œå¦‚æœæ˜¯ç”¨æˆ·æ€è¿›ç¨‹ï¼Œåˆ™åˆ›å»ºè™šæ‹Ÿåœ°å€ç©ºé—´ï¼Œå¦‚æœåˆ›å»ºå¤±è´¥ï¼Œåˆ™æŠŠè¿›ç¨‹çŠ¶æ€è®¾ç½®ä¸ºæœªä½¿ç”¨çŠ¶æ€ï¼Œç„¶åè¿”å›é”™è¯¯ç ã€‚â‘·å¤„è¡¨ç¤ºå¦‚æœæ˜¯å†…æ ¸æ€è¿›ç¨‹ï¼Œåˆ™æŒ‡å®šè¿›ç¨‹çš„å†…æ ¸è¿›ç¨‹è™šæ‹Ÿåœ°å€ç©ºé—´ã€‚æœ‰å…³è™šæ‹Ÿåœ°å€ç©ºé—´çš„ä¿¡æ¯ï¼Œè¯·å‚è€ƒä¹‹å‰çš„ç³»åˆ—æ–‡ç« ã€‚</p> 
<p>å¦‚æœæ‰§è¡ŒCPUPç‰¹æ€§ï¼Œåˆ™æ‰§è¡Œâ‘¸å¤„ä»£ç ï¼Œåˆ™ä¸ºCPUPç»“æ„ä½“ç”³è¯·å†…å­˜ç©ºé—´ã€‚â‘¹å¤„ï¼Œå¦‚æœå¼€å¯äº†LOSCFG_SECURITY_VIDï¼Œåˆ™Våˆå§‹åŒ–IDæ˜ å°„é“¾è¡¨ã€‚â‘ºå¤„ï¼Œå¦‚æœå¼€å¯äº†å®‰å…¨èƒ½åŠ›LOSCFG_SECURITY_CAPABILITYï¼Œåˆ™è¿›è¡Œç›¸åº”çš„åˆå§‹åŒ–ã€‚â‘»å¤„ä¸ºè¿›ç¨‹è®¾ç½®ä¸€ä¸ªåç§°ã€‚</p> 
<pre><code>    STATIC UINT32 OsInitPCB(LosProcessCB *processCB, UINT32 mode, const CHAR *name)
    {
â‘´      processCB-&gt;processMode = mode;
        processCB-&gt;processStatus = OS_PROCESS_STATUS_INIT;
        processCB-&gt;parentProcessID = OS_INVALID_VALUE;
        processCB-&gt;threadGroupID = OS_INVALID_VALUE;
        processCB-&gt;umask = OS_PROCESS_DEFAULT_UMASK;
        processCB-&gt;timerID = (timer_t)(UINTPTR)MAX_INVALID_TIMER_VID;

â‘µ      LOS_ListInit(&amp;processCB-&gt;threadSiblingList);
        LOS_ListInit(&amp;processCB-&gt;childrenList);
        LOS_ListInit(&amp;processCB-&gt;exitChildList);
        LOS_ListInit(&amp;(processCB-&gt;waitList));

    #ifdef LOSCFG_KERNEL_VM
â‘¶      if (OsProcessIsUserMode(processCB)) {
            processCB-&gt;vmSpace = OsCreateUserVmSpace();
            if (processCB-&gt;vmSpace == NULL) {
                processCB-&gt;processStatus = OS_PROCESS_FLAG_UNUSED;
                return LOS_ENOMEM;
            }
        } else {
â‘·          processCB-&gt;vmSpace = LOS_GetKVmSpace();
        }
    #endif

    #ifdef LOSCFG_KERNEL_CPUP
â‘¸      processCB-&gt;processCpup = (OsCpupBase *)LOS_MemAlloc(m_aucSysMem1, sizeof(OsCpupBase));
        if (processCB-&gt;processCpup == NULL) {
            return LOS_ENOMEM;
        }
        (VOID)memset_s(processCB-&gt;processCpup, sizeof(OsCpupBase), 0, sizeof(OsCpupBase));
    #endif

    #ifdef LOSCFG_SECURITY_VID
â‘¹      status_t status = VidMapListInit(processCB);
        if (status != LOS_OK) {
            return LOS_ENOMEM;
        }
    #endif

â‘º  #ifdef LOSCFG_SECURITY_CAPABILITY
        OsInitCapability(processCB);
    #endif

â‘»      if (OsSetProcessName(processCB, name) != LOS_OK) {
            return LOS_ENOMEM;
        }

        return LOS_OK;
    }

</code></pre> 
<h3><a id="12_OsDeInitPCB_67"></a>1.2 è¿›ç¨‹æ§åˆ¶å—åˆå§‹åŒ–æ¢å¤å‡½æ•°OsDeInitPCB</h3> 
<p>åœ¨åˆ›å»ºè¿›ç¨‹æ—¶ï¼Œä¼šæ‰§è¡Œè¯¥å‡½æ•°ï¼Œæ¢å¤è¿›ç¨‹æ§åˆ¶å—ä¿¡æ¯åˆ°åˆå§‹åŒ–ä¹‹å‰çš„çŠ¶æ€ã€‚â‘´å¤„é‡Šæ”¾è¿›ç¨‹çš„èµ„æºï¼ŒåŒ…å«åœ°å€ç©ºé—´ã€æ–‡ä»¶ã€å®‰å…¨èƒ½åŠ›ã€å®šæ—¶å™¨ç­‰å ç”¨çš„å†…å­˜ã€‚å¦‚æœå­˜åœ¨çˆ¶è¿›ç¨‹ï¼Œåˆ™æ‰§è¡Œâ‘µä»çˆ¶è¿›ç¨‹çš„å…„å¼Ÿåˆ—è¡¨ä¸Šåˆ é™¤ã€‚å¦‚æœè¿›ç¨‹å±äºè¿›ç¨‹ç»„ï¼Œåˆ™ä»è¿›ç¨‹ç»„ä¸­é€€å‡ºã€‚ç„¶åæ‰§è¡Œâ‘·è®¾ç½®è¿›ç¨‹çŠ¶æ€ä¸ºé€€å‡ºæ€ï¼ŒæŠŠè¿›ç¨‹æ”¾å…¥å¾…å›æ”¶é“¾è¡¨ä¸­ã€‚</p> 
<pre><code>    STATIC VOID OsDeInitPCB(LosProcessCB *processCB)
    {
        UINT32 intSave;
        ProcessGroup *group = NULL;

        if (processCB == NULL) {
            return;
        }

â‘´      OsProcessResourcesToFree(processCB);

        SCHEDULER_LOCK(intSave);
        if (processCB-&gt;parentProcessID != OS_INVALID_VALUE) {
â‘µ          LOS_ListDelete(&amp;processCB-&gt;siblingList);
            processCB-&gt;parentProcessID = OS_INVALID_VALUE;
        }

â‘¶      if (processCB-&gt;group != NULL) {
            OsExitProcessGroup(processCB, &amp;group);
        }

â‘·      processCB-&gt;processStatus &amp;= ~OS_PROCESS_STATUS_INIT;
        processCB-&gt;processStatus |= OS_PROCESS_FLAG_EXIT;
        LOS_ListHeadInsert(&amp;g_processRecycleList, &amp;processCB-&gt;pendList);
        SCHEDULER_UNLOCK(intSave);

        (VOID)LOS_MemFree(m_aucSysMem1, group);
        OsWriteResourceEvent(OS_RESOURCE_EVENT_FREE);
        return;
    }

</code></pre> 
<h2><a id="2_LiteOSAOsSystemProcessCreate_105"></a>2ã€ LiteOS-Aå†…æ ¸ç³»ç»Ÿè¿›ç¨‹åˆ›å»ºå‡½æ•°OsSystemProcessCreate</h2> 
<p>ç³»ç»Ÿè¿›ç¨‹åˆ›å»ºå‡½æ•°OsSystemProcessCreateåœ¨æ–‡ä»¶kernel\common\los_config.cä¸­è¢«è°ƒç”¨ï¼Œåœ¨ç³»ç»Ÿå¯åŠ¨é˜¶æ®µåˆ›å»ºç³»ç»Ÿè¿›ç¨‹ã€‚è¯¥å‡½æ•°åˆè°ƒç”¨OsProcessInitï¼Œæˆ‘ä»¬é¦–å…ˆçœ‹ä¸‹å‡½æ•°OsProcessInitã€‚</p> 
<h3><a id="21_OsProcessInit_109"></a>2.1 è¿›ç¨‹åˆå§‹åŒ–å‡½æ•°OsProcessInit</h3> 
<p>è¿›ç¨‹åˆå§‹åŒ–å‡½æ•°OsProcessInitä¸ºè¿›ç¨‹æ§åˆ¶å—ç”³è¯·å†…å­˜ï¼Œåˆå§‹åŒ–è¿›ç¨‹ç›¸å…³çš„è¿›ç¨‹é“¾è¡¨ã€‚æˆ‘ä»¬çœ‹ä¸‹ä»£ç ï¼Œâ‘´å¤„è·å–é…ç½®çš„è¿›ç¨‹æœ€å¤§æ•°å€¼ï¼Œç„¶åè®¡ç®—éœ€è¦çš„å†…å­˜å¤§å°ã€‚â‘µå¤„ç”³è¯·å†…å­˜ï¼Œåˆå§‹åŒ–ç”³è¯·çš„å†…å­˜å—ã€‚â‘¶å¤„åˆå§‹åŒ–ç©ºé—²è¿›ç¨‹åŒå‘é“¾è¡¨å’Œå¾…å›æ”¶è¿›ç¨‹åŒå‘é“¾è¡¨ã€‚<br> â‘·å¤„åˆå§‹åŒ–æ¯ä¸€ä¸ªè¿›ç¨‹ï¼Œç¤¾åŒºè¿›ç¨‹ç¼–å·ã€è¿›ç¨‹çŠ¶æ€ï¼Œç„¶åæŠŠæ¯ä¸€ä¸ªè¿›ç¨‹æ”¾åˆ°ç©ºé—²è¿›ç¨‹é“¾è¡¨é‡Œã€‚â‘¸å¤„è®¾ç½®Idleè¿›ç¨‹ç¼–å·ä¸º0ï¼Œç”¨æˆ·æ ¹è¿›ç¨‹ç¼–å·ä¸º1ï¼Œç³»ç»Ÿæ ¹è¿›ç¨‹ç¼–å·ä¸º2ï¼Œç„¶åæ‰§è¡ŒLOS_ListDeleteæŠŠè¿™3ä¸ªè¿›ç¨‹ä»é˜»å¡é“¾è¡¨ä¸Šåˆ é™¤ã€‚</p> 
<pre><code>    STATIC UINT32 OsProcessInit(VOID)
    {
        UINT32 index;
        UINT32 size;

â‘´      g_processMaxNum = LOSCFG_BASE_CORE_PROCESS_LIMIT;
        size = g_processMaxNum * sizeof(LosProcessCB);

â‘µ      g_processCBArray = (LosProcessCB *)LOS_MemAlloc(m_aucSysMem1, size);
        if (g_processCBArray == NULL) {
            return LOS_NOK;
        }
        (VOID)memset_s(g_processCBArray, size, 0, size);

â‘¶      LOS_ListInit(&amp;g_freeProcess);
        LOS_ListInit(&amp;g_processRecycleList);

â‘·      for (index = 0; index &lt; g_processMaxNum; index++) {
            g_processCBArray[index].processID = index;
            g_processCBArray[index].processStatus = OS_PROCESS_FLAG_UNUSED;
            LOS_ListTailInsert(&amp;g_freeProcess, &amp;g_processCBArray[index].pendList);
        }

â‘¸      g_kernelIdleProcess = 0; /* 0: The idle process ID of the kernel-mode process is fixed at 0 */
        LOS_ListDelete(&amp;OS_PCB_FROM_PID(g_kernelIdleProcess)-&gt;pendList);

        g_userInitProcess = 1; /* 1: The root process ID of the user-mode process is fixed at 1 */
        LOS_ListDelete(&amp;OS_PCB_FROM_PID(g_userInitProcess)-&gt;pendList);

        g_kernelInitProcess = 2; /* 2: The root process ID of the kernel-mode process is fixed at 2 */
        LOS_ListDelete(&amp;OS_PCB_FROM_PID(g_kernelInitProcess)-&gt;pendList);

        return LOS_OK;
    }
</code></pre> 
<h3><a id="22_OsProcessCreateInit_151"></a>2.2 è¿›ç¨‹åˆ›å»ºåˆå§‹åŒ–å‡½æ•°OsProcessCreateInit</h3> 
<p>è¯¥å‡½æ•°ç”¨äºåˆ›å»ºè¿›ç¨‹æ—¶çš„ä¸€äº›åˆå§‹åŒ–æ“ä½œï¼Œä¸»è¦æ˜¯æ–‡ä»¶ç³»ç»Ÿã€å®‰å…¨èƒ½åŠ›ã€è¿›ç¨‹ç»„ç­‰ç­‰ã€‚éœ€è¦3ä¸ªå‚æ•°ï¼Œåˆ†åˆ«æ˜¯è¿›ç¨‹æ§åˆ¶å—æŒ‡é’ˆï¼Œæ ‡è®°ç”¨æˆ·æ€è¿˜æ˜¯å†…æ ¸æ€è¿›ç¨‹çš„flagsï¼Œè¿›ç¨‹åç§°nameã€‚é¦–å…ˆæ‰§è¡Œâ‘´è°ƒç”¨OsInitPCB()å¯¹è¿›ç¨‹æ§åˆ¶å—è¿›è¡Œåˆå§‹åŒ–ï¼Œç„¶åï¼Œå¦‚æœé…ç½®æ”¯æŒäº†è™šæ‹Ÿæ–‡ä»¶ç³»ç»ŸVFSï¼Œåˆ™æ‰§è¡Œâ‘µä¸ºè¿›ç¨‹åˆ†åˆ«æ–‡ä»¶ã€‚â‘¶å¤„æ ¹æ®è¿›ç¨‹å·åˆ›å»ºè¿›ç¨‹ç»„ã€‚å¦‚æœæ”¯æŒå®‰å…¨èƒ½åŠ›ï¼Œåˆ™æ‰§è¡Œâ‘·åˆ›å»ºç”¨æˆ·ã€‚å¦‚æœåˆå§‹åŒ–å¤±è´¥ï¼Œä¼šæ‰§è¡Œâ‘¸æ¢å¤è¿›ç¨‹æ§åˆ¶å—åˆ°åˆå§‹åŒ–ä¹‹å‰çš„çŠ¶æ€ã€‚</p> 
<pre><code>    STATIC UINT32 OsProcessCreateInit(LosProcessCB *processCB, UINT32 flags, const CHAR *name)
    {
        ProcessGroup *group = NULL;
â‘´      UINT32 ret = OsInitPCB(processCB, flags, name);
        if (ret != LOS_OK) {
            goto EXIT;
        }

    #ifdef LOSCFG_FS_VFS
â‘µ      processCB-&gt;files = alloc_files();
        if (processCB-&gt;files == NULL) {
            ret = LOS_ENOMEM;
            goto EXIT;
        }
    #endif

â‘¶      group = OsCreateProcessGroup(processCB-&gt;processID);
        if (group == NULL) {
            ret = LOS_ENOMEM;
            goto EXIT;
        }

    #ifdef LOSCFG_SECURITY_CAPABILITY
â‘·      processCB-&gt;user = OsCreateUser(0, 0, 1);
        if (processCB-&gt;user == NULL) {
            ret = LOS_ENOMEM;
            goto EXIT;
        }
    #endif

        return LOS_OK;

    EXIT:
â‘¸      OsDeInitPCB(processCB);
        return ret;
    }

</code></pre> 
<h3><a id="23_OsSystemProcessCreate_195"></a>2.3 ç³»ç»Ÿè¿›ç¨‹åˆ›å»ºå‡½æ•°OsSystemProcessCreate</h3> 
<p>æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬çœ‹çœ‹ç³»ç»Ÿè¿›ç¨‹åˆ›å»ºå‡½æ•°OsSystemProcessCreateçš„æºä»£ç ã€‚â‘´å¤„å¼€å§‹å…ˆåè°ƒç”¨OsProcessInitã€OsProcessCreateInitåˆå§‹åŒ–å†…æ ¸æ€æ ¹è¿›ç¨‹ï¼Œâ‘µå¤„è¿›ç¨‹çš„çŠ¶æ€ä¸å†æ˜¯åˆå§‹åŒ–çŠ¶æ€ã€‚â‘¶å¤„ä»å†…æ ¸è¿›ç¨‹è·å–å…¨å±€è¿›ç¨‹ç»„æŒ‡é’ˆg_processGroupï¼Œç„¶ååˆå§‹åŒ–è¿›ç¨‹ç»„çš„åŒå‘é“¾è¡¨ã€‚è¿™æ ·çœ‹æ¥ï¼Œæ‰€æœ‰çš„è¿›ç¨‹ç»„éƒ½ä¼šæŒ‚è½½åˆ°å†…æ ¸è¿›ç¨‹çš„è¿›ç¨‹ç»„èŠ‚ç‚¹ä¸Šã€‚â‘·å¤„åˆå§‹åŒ–å†…æ ¸ç©ºé—²è¿›ç¨‹ï¼Œå†…æ ¸ç©ºé—²è¿›ç¨‹çš„çˆ¶è¿›ç¨‹ä¹Ÿæ˜¯å†…æ ¸æ€æ ¹è¿›ç¨‹ï¼Œæ’å…¥åˆ°è¿›ç¨‹ç»„é“¾è¡¨ï¼Œè®¾ç½®ç©ºé—²è¿›ç¨‹çš„çŠ¶æ€ä¸å†æ˜¯åˆå§‹åŒ–çŠ¶æ€ã€‚æ‰§è¡Œâ‘¸åˆ›å»ºç©ºé—²ä»»åŠ¡ï¼Œç„¶åè®¾ç½®ç©ºé—²è¿›ç¨‹çš„çº¿ç¨‹ç»„ç¼–å·ä¸ºç©ºé—²çº¿ç¨‹ç¼–å·ã€‚</p> 
<pre><code>    LITE_OS_SEC_TEXT_INIT UINT32 OsSystemProcessCreate(VOID)
    {
â‘´      UINT32 ret = OsProcessInit();
        if (ret != LOS_OK) {
            return ret;
        }

        LosProcessCB *kerInitProcess = OS_PCB_FROM_PID(g_kernelInitProcess);
        ret = OsProcessCreateInit(kerInitProcess, OS_KERNEL_MODE, "KProcess");
        if (ret != LOS_OK) {
            return ret;
        }

â‘µ      kerInitProcess-&gt;processStatus &amp;= ~OS_PROCESS_STATUS_INIT;
â‘¶      g_processGroup = kerInitProcess-&gt;group;
        LOS_ListInit(&amp;g_processGroup-&gt;groupList);

â‘·      LosProcessCB *idleProcess = OS_PCB_FROM_PID(g_kernelIdleProcess);
        ret = OsInitPCB(idleProcess, OS_KERNEL_MODE, "KIdle");
        if (ret != LOS_OK) {
            return ret;
        }
        idleProcess-&gt;parentProcessID = kerInitProcess-&gt;processID;
        LOS_ListTailInsert(&amp;kerInitProcess-&gt;childrenList, &amp;idleProcess-&gt;siblingList);
        idleProcess-&gt;group = kerInitProcess-&gt;group;
        LOS_ListTailInsert(&amp;kerInitProcess-&gt;group-&gt;processList, &amp;idleProcess-&gt;subordinateGroupList);
    #ifdef LOSCFG_SECURITY_CAPABILITY
        idleProcess-&gt;user = kerInitProcess-&gt;user;
    #endif
    #ifdef LOSCFG_FS_VFS
        idleProcess-&gt;files = kerInitProcess-&gt;files;
    #endif
        idleProcess-&gt;processStatus &amp;= ~OS_PROCESS_STATUS_INIT;

â‘¸      ret = OsIdleTaskCreate();
        if (ret != LOS_OK) {
            return ret;
        }
        idleProcess-&gt;threadGroupID = OsGetIdleTaskId();

        return LOS_OK;
    }

</code></pre> 
<h2><a id="3_LiteOSAOsUserInitProcess_245"></a>3. LiteOS-Aå†…æ ¸ç”¨æˆ·è¿›ç¨‹åˆ›å»ºå‡½æ•°OsUserInitProcess</h2> 
<p>ç³»ç»Ÿå¯åŠ¨é˜¶æ®µï¼ŒOsUserInitProcesså¯åŠ¨initè¿›ç¨‹ã€‚è¯¥å‡½æ•°åœ¨deviceå¼€å‘æ¿ç›®å½•ä¸‹ç³»ç»Ÿåˆå§‹åŒ–æ–‡ä»¶ä¸­è°ƒç”¨ï¼Œå¦‚system_init.cç­‰ç­‰ã€‚è¯¥å‡½æ•°éœ€è¦å¼€å¯LOSCFG_KERNEL_DYNLOADå®ï¼Œå¦åˆ™å‡½æ•°ä½“å†…å®¹ä¸ºç©ºã€‚åœ¨é˜…è¯»å‡½æ•°OsUserInitProcessçš„æºç å‰ï¼Œå…ˆçœ‹çœ‹è¯¥å‡½æ•°è°ƒç”¨çš„å…¶ä»–å‡½æ•°ï¼Œå¦‚OsLoadUserInitã€OsUserInitStackAllocã€OsUserInitProcessStartç­‰ç­‰ã€‚</p> 
<h3><a id="31_OsLoadUserInit_249"></a>3.1 åŠ è½½ç”¨æˆ·åˆå§‹åŒ–æ•°æ®å‡½æ•°OsLoadUserInit</h3> 
<p>è¯¥å‡½æ•°ç”¨äºåŠ è½½ç”¨æˆ·æ•°æ®ã€‚â‘´å¤„ä»é“¾æ¥è„šæœ¬è·å–textã€bssçš„å¼€å¯å’Œç»“æŸåœ°å€ï¼Œç„¶åè®¡ç®—bssæ®µã€åˆå§‹åŒ–æ®µçš„å¤§å°ã€‚â‘µå¤„è¿›è¡Œä¸€äº›å¿…è¦çš„æ ¡éªŒï¼Œæ˜¯å¦é’ˆå¯¹å†…å­˜é¡µå¯¹é½ï¼Œå†…å­˜æ®µé•¿åº¦æ˜¯å¦åˆç†ç­‰ã€‚ç„¶åæ‰§è¡Œâ‘¶ï¼Œç”³è¯·ç‰©ç†å†…å­˜é¡µï¼Œç„¶åæŠŠç”¨æˆ·åˆå§‹åŒ–æ•°æ®å¤åˆ¶åˆ°ç”³è¯·çš„å†…å­˜é¡µã€‚â‘·å¤„è¿›è¡Œè™šå®æ˜ å°„ã€‚å¦‚æœbssæ®µé•¿åº¦ä¸ä¸º0ï¼Œæ‰§è¡Œâ‘¸æŠŠbssæ®µçš„å†…å­˜åŒºåŸŸæ¸…é›¶ã€‚</p> 
<pre><code>STATIC UINT32 OsLoadUserInit(LosProcessCB *processCB)
{
    /*              userInitTextStart               -----
     * | user text |
     *
     * | user data |                                initSize
     *              userInitBssStart  ---
     * | user bss  |                  initBssSize
     *              userInitEnd       ---           -----
     */
    errno_t errRet;
    INT32 ret;
â‘´  CHAR *userInitTextStart = (CHAR *)&amp;__user_init_entry;
    CHAR *userInitBssStart = (CHAR *)&amp;__user_init_bss;
    CHAR *userInitEnd = (CHAR *)&amp;__user_init_end;
    UINT32 initBssSize = userInitEnd - userInitBssStart;
    UINT32 initSize = userInitEnd - userInitTextStart;
    VOID *userBss = NULL;
    VOID *userText = NULL;

â‘µ  if ((LOS_Align((UINTPTR)userInitTextStart, PAGE_SIZE) != (UINTPTR)userInitTextStart) ||
        (LOS_Align((UINTPTR)userInitEnd, PAGE_SIZE) != (UINTPTR)userInitEnd)) {
        return LOS_EINVAL;
    }

    if ((initSize == 0) || (initSize &lt;= initBssSize)) {
        return LOS_EINVAL;
    }

â‘¶  userText = LOS_PhysPagesAllocContiguous(initSize &gt;&gt; PAGE_SHIFT);
    if (userText == NULL) {
        return LOS_NOK;
    }

    errRet = memcpy_s(userText, initSize, (VOID *)&amp;__user_init_load_addr, initSize - initBssSize);
    if (errRet != EOK) {
        PRINT_ERR("Load user init text, data and bss failed! err : %d\n", errRet);
        goto ERROR;
    }
â‘·  ret = LOS_VaddrToPaddrMmap(processCB-&gt;vmSpace, (VADDR_T)(UINTPTR)userInitTextStart, LOS_PaddrQuery(userText),
                               initSize, VM_MAP_REGION_FLAG_PERM_READ | VM_MAP_REGION_FLAG_PERM_WRITE |
                               VM_MAP_REGION_FLAG_FIXED | VM_MAP_REGION_FLAG_PERM_EXECUTE |
                               VM_MAP_REGION_FLAG_PERM_USER);
    if (ret &lt; 0) {
        PRINT_ERR("Mmap user init text, data and bss failed! err : %d\n", ret);
        goto ERROR;
    }

    /* The User init boot segment may not actually exist */
â‘¸  if (initBssSize != 0) {
        userBss = (VOID *)((UINTPTR)userText + userInitBssStart - userInitTextStart);
        errRet = memset_s(userBss, initBssSize, 0, initBssSize);
        if (errRet != EOK) {
            PRINT_ERR("memset user init bss failed! err : %d\n", errRet);
            goto ERROR;
        }
    }

    return LOS_OK;

ERROR:
    (VOID)LOS_PhysPagesFreeContiguous(userText, initSize &gt;&gt; PAGE_SHIFT);
    return LOS_NOK;
}

</code></pre> 
<h3><a id="32_OsUserInitStackAlloc_321"></a>3.2 ç”¨æˆ·åˆå§‹åŒ–æ ˆå‡½æ•°OsUserInitStackAlloc</h3> 
<p>è¯¥å‡½æ•°éœ€è¦2ä¸ªå‚æ•°ï¼Œç¬¬ä¸€ä¸ªå‚æ•°ä¸ºè¿›ç¨‹æ§åˆ¶å—ï¼Œç¬¬äºŒä¸ªå‚æ•°ä¸ºè¾“å‡ºå‚æ•°ï¼Œç”¨äºè·å–ç”¨æˆ·ä»»åŠ¡æ ˆçš„å¤§å°ã€‚â‘´å¤„ç”¨æˆ·ä»»åŠ¡æ ˆå¤§å°å¯¹é¡µè¿›è¡Œå¯¹é½ï¼Œç„¶åç”³è¯·å†…å­˜åŒºåŸŸï¼Œç„¶åæ‰§è¡Œâ‘µè®¾ç½®å†…å­˜åŒºåŸŸç±»å‹ï¼Œå¹¶ç¤¾åŒºå†…å­˜åŒºåŸŸæ ‡ç­¾ä¸ºæ ˆã€‚ç„¶åè®¾ç½®è¾“å‡ºå‚æ•°ä¸ºä»»åŠ¡æ ˆå¤§å°ï¼Œå¹¶è¿”å›ç”¨æˆ·æ ˆç©ºé—´çš„å¼€å§‹åœ°å€ã€‚</p> 
<pre><code>STATIC VOID *OsUserInitStackAlloc(LosProcessCB *processCB, UINT32 *size)
{
    LosVmMapRegion *region = NULL;
â‘´  UINT32 stackSize = ALIGN(OS_USER_TASK_STACK_SIZE, PAGE_SIZE);

    region = LOS_RegionAlloc(processCB-&gt;vmSpace, 0, stackSize,
                             VM_MAP_REGION_FLAG_PERM_USER | VM_MAP_REGION_FLAG_PERM_READ |
                             VM_MAP_REGION_FLAG_PERM_WRITE, 0);
    if (region == NULL) {
        return NULL;
    }

â‘µ  LOS_SetRegionTypeAnon(region);
    region-&gt;regionFlags |= VM_MAP_REGION_FLAG_STACK;

    *size = stackSize;

    return (VOID *)(UINTPTR)region-&gt;range.base;
}

</code></pre> 
<h3><a id="33_OsUserInitProcessStart_348"></a>3.3 ç”¨æˆ·è¿›ç¨‹åˆå§‹åŒ–å¼€å¯å‡½æ•°OsUserInitProcessStart</h3> 
<p>ç”¨æˆ·è¿›ç¨‹åˆå§‹åŒ–å¼€å¯å‡½æ•°OsUserInitProcessStartç”¨äºåˆ›å»ºçº¿ç¨‹ï¼Œè®¾ç½®è°ƒåº¦ç­–ç•¥ç­‰ã€‚â‘´å¤„ä¸ºç”¨æˆ·æ€è¿›ç¨‹åˆ›å»ºä¸ªçº¿ç¨‹ï¼Œç„¶åä¸ºè¿›ç¨‹è®¾ç½®ä¼˜å…ˆçº§ã€‚â‘µå¤„è®¾ç½®è¿›ç¨‹çŠ¶æ€ä¸ºéåˆå§‹åŒ–çŠ¶æ€ï¼Œç„¶åæ‰§è¡Œâ‘¶ä¸ºä»»åŠ¡è®¾ç½®è°ƒåº¦ç­–ç•¥å’Œä¼˜å…ˆçº§ã€‚</p> 
<pre><code>STATIC UINT32 OsUserInitProcessStart(LosProcessCB *processCB, TSK_INIT_PARAM_S *param)
{
    UINT32 intSave;
    INT32 ret;

â‘´  UINT32 taskID = OsCreateUserTask(processCB-&gt;processID, param);
    if (taskID == OS_INVALID_VALUE) {
        return LOS_NOK;
    }

    ret = LOS_SetProcessPriority(processCB-&gt;processID, OS_PROCESS_USERINIT_PRIORITY);
    if (ret != LOS_OK) {
        PRINT_ERR("User init process set priority failed! ERROR:%d \n", ret);
        goto EXIT;
    }

    SCHEDULER_LOCK(intSave);
â‘µ  processCB-&gt;processStatus &amp;= ~OS_PROCESS_STATUS_INIT;
    SCHEDULER_UNLOCK(intSave);

â‘¶  ret = LOS_SetTaskScheduler(taskID, LOS_SCHED_RR, OS_TASK_PRIORITY_LOWEST);
    if (ret != LOS_OK) {
        PRINT_ERR("User init process set scheduler failed! ERROR:%d \n", ret);
        goto EXIT;
    }

    return LOS_OK;

EXIT:
    (VOID)LOS_TaskDelete(taskID);
    return ret;
}

</code></pre> 
<h3><a id="34_OsUserInitProcess_388"></a>3.4 ç”¨æˆ·æ€è¿›ç¨‹åˆå§‹åŒ–å‡½æ•°OsUserInitProcess</h3> 
<p>ç”¨æˆ·æ€è¿›ç¨‹åˆå§‹åŒ–å‡½æ•°OsUserInitProcesså®Œæˆç”¨æˆ·æ€è¿›ç¨‹çš„åˆå§‹åŒ–ã€‚â‘´å¤„è·å–ç”¨æˆ·æ€æ ¹è¿›ç¨‹ï¼Œç„¶åè°ƒç”¨å‡½æ•°åˆ›å»ºç”¨æˆ·æ€æ ¹è¿›ç¨‹ï¼Œå¹¶è°ƒç”¨å‡½æ•°OsLoadUserInitåŠ è½½ç”¨æˆ·åˆå§‹åŒ–æ•°æ®ã€‚â‘µå¤„åˆå§‹åŒ–ç”¨æˆ·æ ˆï¼Œç„¶åè®¾ç½®çº¿ç¨‹çš„åˆå§‹åŒ–å‚æ•°ï¼Œâ‘¶å¤„å®Œæˆç”¨æˆ·æ€è¿›ç¨‹çš„åˆ›å»ºã€‚</p> 
<pre><code>LITE_OS_SEC_TEXT_INIT UINT32 OsUserInitProcess(VOID)
{
    UINT32 ret;
    UINT32 size;
    TSK_INIT_PARAM_S param = { 0 };
    VOID *stack = NULL;

â‘´  LosProcessCB *processCB = OS_PCB_FROM_PID(g_userInitProcess);
    ret = OsProcessCreateInit(processCB, OS_USER_MODE, "Init");
    if (ret != LOS_OK) {
        return ret;
    }

    ret = OsLoadUserInit(processCB);
    if (ret != LOS_OK) {
        goto ERROR;
    }

â‘µ  stack = OsUserInitStackAlloc(processCB, &amp;size);
    if (stack == NULL) {
        PRINT_ERR("Alloc user init process user stack failed!\n");
        goto ERROR;
    }

    param.pfnTaskEntry = (TSK_ENTRY_FUNC)(CHAR *)&amp;__user_init_entry;
    param.userParam.userSP = (UINTPTR)stack + size;
    param.userParam.userMapBase = (UINTPTR)stack;
    param.userParam.userMapSize = size;
    param.uwResved = OS_TASK_FLAG_PTHREAD_JOIN;
â‘¶  ret = OsUserInitProcessStart(processCB, &amp;param);
    if (ret != LOS_OK) {
        (VOID)OsUnMMap(processCB-&gt;vmSpace, param.userParam.userMapBase, param.userParam.userMapSize);
        goto ERROR;
    }

    return LOS_OK;

ERROR:
    OsDeInitPCB(processCB);
    return ret;
}

</code></pre> 
<h2><a id="_437"></a>å°ç»“</h2> 
<p>æœ¬æ–‡ä»‹ç»äº†è¿›ç¨‹ç®¡ç†çš„å†…æ ¸è¿›ç¨‹ã€ç”¨æˆ·æ€è¿›ç¨‹çš„åˆå§‹åŒ–ç›¸å…³å‡½æ•°ã€‚</p> 
<p><font color="#EE66AA"><strong>å¦‚æœå¤§å®¶æƒ³æ›´åŠ æ·±å…¥çš„å­¦ä¹  OpenHarmony å¼€å‘çš„å†…å®¹ï¼Œä¸å¦¨å¯ä»¥å‚è€ƒä»¥ä¸‹ç›¸å…³å­¦ä¹ æ–‡æ¡£è¿›è¡Œå­¦ä¹ ï¼ŒåŠ©ä½ å¿«é€Ÿæå‡è‡ªå·±ï¼š</strong></font></p> 
<h4><a id="font_colorEE66AAOpenHarmony_httpsqr18cnCgxrRyhttpsdocsqqcomdocDSGZNY053a3hza0xo_443"></a><font color="#EE66AA">OpenHarmony å¼€å‘ç¯å¢ƒæ­å»ºï¼š<a href="https://docs.qq.com/doc/DSGZNY053a3hza0xo" rel="nofollow"><code>https://qr18.cn/CgxrRy</code></a></font></h4> 
<p><img src="https://images2.imgbox.com/54/4a/wZYjBToH_o.png" alt=""></p> 
<h4><a id="font_colorEE66AAOpenHarmonyhttpsqr18cnCgxrRyhttpsdocsqqcomdocDSGZNY053a3hza0xo_446"></a><font color="#EE66AA">ã€ŠOpenHarmonyæºç è§£æã€‹ï¼š<a href="https://docs.qq.com/doc/DSGZNY053a3hza0xo" rel="nofollow"><code>https://qr18.cn/CgxrRy</code></a></font></h4> 
<ul><li>æ­å»ºå¼€å‘ç¯å¢ƒ</li><li>Windows å¼€å‘ç¯å¢ƒçš„æ­å»º</li><li>Ubuntu å¼€å‘ç¯å¢ƒæ­å»º</li><li>Linux ä¸ Windows ä¹‹é—´çš„æ–‡ä»¶å…±äº«</li><li>â€¦â€¦<br> <img src="https://images2.imgbox.com/41/84/9AaSLwEz_o.png" alt=""></li></ul> 
<h4><a id="font_colorEE66AAhttpsqr18cnCgxrRyhttpsdocsqqcomdocDSGZNY053a3hza0xo_454"></a><font color="#EE66AA">ç³»ç»Ÿæ¶æ„åˆ†æï¼š<a href="https://docs.qq.com/doc/DSGZNY053a3hza0xo" rel="nofollow"><code>https://qr18.cn/CgxrRy</code></a></font></h4> 
<ul><li>æ„å»ºå­ç³»ç»Ÿ</li><li>å¯åŠ¨æµç¨‹</li><li>å­ç³»ç»Ÿ</li><li>åˆ†å¸ƒå¼ä»»åŠ¡è°ƒåº¦å­ç³»ç»Ÿ</li><li>åˆ†å¸ƒå¼é€šä¿¡å­ç³»ç»Ÿ</li><li>é©±åŠ¨å­ç³»ç»Ÿ</li><li>â€¦â€¦</li></ul> 
<p><img src="https://images2.imgbox.com/56/73/yh1RkDa2_o.png" alt=""></p> 
<h4><a id="font_colorEE66AAOpenHarmony_httpsqr18cnCgxrRyhttpsdocsqqcomdocDSGZNY053a3hza0xo_466"></a><font color="#EE66AA">OpenHarmony è®¾å¤‡å¼€å‘å­¦ä¹ æ‰‹å†Œï¼š<a href="https://docs.qq.com/doc/DSGZNY053a3hza0xo" rel="nofollow"><code>https://qr18.cn/CgxrRy</code></a></font></h4> 
<p><img src="https://images2.imgbox.com/72/0e/gCBQ3Xgh_o.png" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p> 
<h4><a id="font_colorEE66AAOpenHarmonyhttpsqr18cnCgxrRyhttpsdocsqqcomdocDSGZNY053a3hza0xo_470"></a><font color="#EE66AA">OpenHarmonyé¢è¯•é¢˜ï¼ˆå†…å«å‚è€ƒç­”æ¡ˆï¼‰ï¼š<a href="https://docs.qq.com/doc/DSGZNY053a3hza0xo" rel="nofollow"><code>https://qr18.cn/CgxrRy</code></a></font></h4> 
<p><img src="https://images2.imgbox.com/26/ac/Q3DmgoRZ_o.png" alt=""></p> 
<h3><a id="_474"></a>å†™åœ¨æœ€å</h3> 
<ul><li>å¦‚æœä½ è§‰å¾—è¿™ç¯‡å†…å®¹å¯¹ä½ è¿˜è›®æœ‰å¸®åŠ©ï¼Œæˆ‘æƒ³é‚€è¯·ä½ å¸®æˆ‘ä¸‰ä¸ªå°å¿™ï¼š</li><li>ç‚¹èµï¼Œè½¬å‘ï¼Œæœ‰ä½ ä»¬çš„ ã€ç‚¹èµå’Œè¯„è®ºã€ï¼Œæ‰æ˜¯æˆ‘åˆ›é€ çš„åŠ¨åŠ›ã€‚</li><li>å…³æ³¨å°ç¼–ï¼ŒåŒæ—¶å¯ä»¥æœŸå¾…åç»­æ–‡ç« ingğŸš€ï¼Œä¸å®šæœŸåˆ†äº«åŸåˆ›çŸ¥è¯†ã€‚</li><li>æƒ³è¦è·å–æ›´å¤šå®Œæ•´é¸¿è’™æœ€æ–°å­¦ä¹ èµ„æºï¼Œè¯·ç§»æ­¥å‰å¾€å°ç¼–ï¼š<a href="https://qr21.cn/FV7h05" rel="nofollow"><code>https://qr21.cn/FV7h05</code></a></li></ul> 
<p><img src="https://images2.imgbox.com/90/aa/eQ7YdSaQ_o.png" alt=""></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e3efef1b574a92ea358a4a42c53123ea/" rel="prev">
			<span class="pager__subtitle">Â«&thinsp;Previous</span>
			<p class="pager__title">MPLSå·¥ä½œè¿‡ç¨‹</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/81e4c178724059ba3d9f502548ed2bf2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;Â»</span>
			<p class="pager__title">01 Pytorch åŸºç¡€</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 ç¼–ç¨‹å¤§å’–.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>