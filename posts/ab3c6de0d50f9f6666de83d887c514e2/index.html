<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JavaScript中GET和POST对比 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/ab3c6de0d50f9f6666de83d887c514e2/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="JavaScript中GET和POST对比">
  <meta property="og:description" content="在前后端交互的过程中，使用频率最高的莫过于 GET 和 POST 这两个方法，并且这也是面试中被问到频率很高的知识点。
GET和POST方法只是 HTTP 协议为了不同分工而规定的两种请求方式。
一、什么是HTTP？ HTTP 是基于 TCP/IP 的关于数据如何在万维网中如何通信的协议。
HTTP 的工作方式是客户端与服务器之间的请求-应答协议。
二、GET和POST的对比 在客户机和服务器之间进行请求-响应时，两种最常被用到的方法是：GET 和 POST。
GET - 从指定的资源请求数据。POST - 向指定的资源提交要被处理的数据。 GET 提交参数一般显示在 URL 上，POST 通过表单提交不会显示在 URL 上，POST 更具隐蔽性
1、相同点 HTTP 的底层是 TCP/IP。所以 GET 和 POST 的底层也是 TCP/IP，也就是说，GET 和 POST 都是 TCP 链接。所以说，它们的本质是相同的。
GET 和 POST 之所以产生，要通过HTTP的规则和浏览器/服务器的限制进行区分，使它们在应用过程中体现出不同。 请求过程是：
客户端 IP 发出请求。发出的请求数据包会通过 TCP ，经网络传输给远程服务端 IP。服务端 IP 收到请求包之后，解析并处理请求包最后服务端会通过 TCP 将处理结果返回给客户端。用户便可以查看到想要的响应数据。 2、区别 （1）安全性不同 GET的所有参数全部包装在URL中，明文显示，且服务器的访问日志会记录，非常不安全POST的URL中只有资源路径，不包含参数，参数封装在二进制的数据体中，服务器也不会记录参数，相对安全。所有涉及用户隐私的数据都要用POST传输 （2）参数长度限制不同 GET 和 POST 传递参数的长度不同：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-12T00:49:13+08:00">
    <meta property="article:modified_time" content="2024-04-12T00:49:13+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JavaScript中GET和POST对比</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在前后端交互的过程中，使用频率最高的莫过于 GET 和 POST 这两个方法，并且这也是面试中被问到频率很高的知识点。</p> 
<p>GET和POST方法只是 HTTP 协议为了不同分工而规定的两种请求方式。</p> 
<h3>一、什么是HTTP？</h3> 
<blockquote> 
 <p>HTTP 是基于 TCP/IP 的关于数据如何在万维网中如何通信的协议。</p> 
 <p>HTTP 的工作方式是客户端与服务器之间的请求-应答协议。</p> 
</blockquote> 
<h3> 二、GET和POST的对比</h3> 
<blockquote> 
 <p>在客户机和服务器之间进行请求-响应时，两种最常被用到的方法是：GET 和 POST。</p> 
 <ul><li><strong>GET</strong> - 从指定的资源请求数据。</li><li><strong>POST</strong> - 向指定的资源提交要被处理的数据。</li></ul> 
 <p>GET 提交参数一般显示在 URL 上，POST 通过表单提交不会显示在 URL 上，POST 更具隐蔽性</p> 
</blockquote> 
<h4>1、相同点</h4> 
<p>HTTP 的底层是 TCP/IP。所以 GET 和 POST 的底层也是 TCP/IP，也就是说，<strong>GET 和 POST 都是 TCP 链接</strong>。所以说，它们的本质是相同的。</p> 
<p>GET 和 POST 之所以产生，要通过HTTP的规则和浏览器/服务器的限制进行区分，使它们在应用过程中体现出不同。 </p> 
<p>请求过程是：</p> 
<blockquote> 
 <ul><li>客户端 IP 发出请求。</li><li>发出的请求数据包会通过 TCP ，经网络传输给远程服务端 IP。</li><li>服务端 IP 收到请求包之后，解析并处理请求包最后服务端会通过 TCP 将处理结果返回给客户端。</li><li>用户便可以查看到想要的响应数据。</li></ul> 
</blockquote> 
<h4> 2、区别</h4> 
<h5>（1）安全性不同</h5> 
<blockquote> 
 <ul><li>GET的所有参数全部包装在URL中，明文显示，且服务器的访问日志会记录，非常不安全</li><li>POST的URL中只有资源路径，不包含参数，参数封装在二进制的数据体中，服务器也不会记录参数，相对安全。所有涉及用户隐私的数据都要用POST传输</li></ul> 
</blockquote> 
<h5>（2）参数长度限制不同</h5> 
<blockquote> 
 <p>GET 和 POST 传递参数的长度不同：</p> 
 <ul><li>GET传送的数据量较小，不能大于2KB。</li><li>POST传送的数据量较大，一般被默认为不受限制。</li></ul> 
</blockquote> 
<p><strong>HTTP 协议没有 Body 和 URL 的长度限制，对 URL 限制的大多是浏览器和服务器的原因。</strong></p> 
<p>服务器是因为处理长 URL 要消耗比较多的资源，为了性能和安全（防止恶意构造长 URL 来攻击）考虑，会给 URL 长度加限制。</p> 
<h5>（3）参数数据类型不同</h5> 
<blockquote> 
 <p>GET 只接受 ASCII 字符，而 POST 没有限制。</p> 
</blockquote> 
<h5>（4） 编码方式不同</h5> 
<blockquote> 
 <p>GET 请求只能进行 URL 编码（application/x-www-form-urlencoded）</p> 
 <p>POST 支持多种编码方式（application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。）</p> 
</blockquote> 
<h5>（5）GET和POST的请求过程</h5> 
<blockquote> 
 <p><strong>POST 请求的过程：</strong></p> 
 <ol><li>浏览器请求 TCP 连接（第一次握手）</li><li>服务器答应进行 TCP 连接（第二次握手）</li><li>浏览器确认，并发送 POST 请求头（第三次握手，这个报文比较小，所以 HTTP 会在此时进行第一次数据发送）</li><li>服务器返回100 Continue响应</li><li>浏览器发送数据</li><li>服务器返回 200 OK响应</li></ol> 
 <p><strong>GET 请求的过程：</strong></p> 
 <ol><li>浏览器请求 TCP 连接（第一次握手）</li><li>服务器答应进行 TCP 连接（第二次握手）</li><li>浏览器确认，并发送 GET 请求头和数据（第三次握手，这个报文比较小，所以 HTTP 会在此时进行第一次数据发送）</li><li>服务器返回 200 OK响应</li></ol> 
</blockquote> 
<h3> 三、XMLHttpRequest的基本使用(发起GET和POST请求）</h3> 
<p><strong>XMLHttpRequest</strong>（XHR）对象用于与服务器交互。通过 <strong>XMLHttpRequest </strong>可以在不刷新页面的情况下请求特定 URL，获取数据。这允许网页在不影响用户操作的情况下，更新页面的局部内容。</p> 
<p><strong>XMLHttpRequest(XHR)</strong>是一个API对象，其中的方法可以用来在浏览器和服务器端传输数据。这个对象是浏览器的js环境提供的。从XHR获取数据的目的是为了持续修改一个加载过的页面，XHR是Ajax设计的底层概念。XHR使用的协议不同于HTTP，不仅可以使用XML格式的数据，也支持JSON，HTML或者纯文本。</p> 
<h5>1、XMLHttpRequest的方法</h5> 
<p>（1）<em>open</em>方法</p> 
<blockquote> 
 <p><strong>XMLHttpRequest</strong>对象的HTTP和HTTPS请求必须通过opent方法初始化。这个方法必须在实际发送请求之前调用，以用来验证请求方法，URL以及用户信息。这个方法不能确保URL存在或者用户信息必须正确。初始化请求可以接受5个参数。</p> 
 <p><strong>第一个参数是一个字符串值标识HTTP的请求方法。</strong></p> 
 <p><strong>第二个参数也是一个字符串值，标示请求的URL。</strong></p> 
 <p><strong>第三个参数是一个布尔值类型，标示请求是否是异步的，在W3C草案中并不是一个必须参数。如果没有提供，符合W3C规范的用户代理应该默认为true。</strong></p> 
 <p><strong>第四个和第五个参数分别是用户名和密码。这些参数是服务端为了验证请求使用的。</strong></p> 
</blockquote> 
<p><img alt="" height="68" src="https://images2.imgbox.com/82/85/Tck8mcEr_o.png" width="683"></p> 
<p>（2）<em>sendRequestHeader</em>方法</p> 
<blockquote> 
 <p>在成功初始化请求之后，XMLHttpRequest对象的<em>setRequestHeader</em>方法可以用来设置请求头。</p> 
 <p><img alt="" height="80" src="https://images2.imgbox.com/d2/b5/h4f8mXWF_o.png" width="842"></p> 
 <p>第一个参数是header的字符串名称，第二个参数是字符串值。如果请求需要多个header，这个方法就要被调用多次。这个方法附加的请求头，在下次<em>open</em>方法调用时会被清空。</p> 
</blockquote> 
<p>（3）<em>send</em>方法</p> 
<blockquote> 
 <p>XMLHttpRequest对象的send方法用来发送请求，这个方法接收一个参数，这个参数就是要发送的内容。</p> 
 <p>如果不需要发送内容，这个参数可以省略。</p> 
 <p>如果参数是DOM对象，用户代理应该确保文档已经被转成XML格式，通过文档对象的inputEncoding属性编码。如果请求头的Content-Type还没有通过<em>setRequestHeader</em>方法设置，用户代理应该自动的增加一个值"application/xml;charset=charset"，其中的charset应该是用来编码文档的编码格式。</p> 
</blockquote> 
<p>（4）<em>onreadystatechange</em>事件监听器</p> 
<blockquote> 
 <p>如果XMLHttpRequest对象的send方法第三个参数是<em>true</em>,也就是发送了异步请求，onreadystatechange事件监听器将自动在XMLHttpRequest对象的readyState属性改变时被触发。</p> 
 <p>状态改变过程如下：</p> 
 <ul><li>当open方法被成功调用，readyState属性被置为1(OPEND)</li><li>当send方法被调用，成功接收到HTTP响应头，readyState属性被置为2(HEADERS_RECEIVED)</li><li>一旦HTTP响应内容开始加载，readyState属性被置为3(LOADING)</li><li>一旦HTTP响应内容结束加载，readyState属性被置为4(DONE)</li></ul> 
 <p>当监听器被定义之后，每次状态改变时都会触发。为了检测状态1和状态2，监听器必须在open方法调用前调用。open方法必须在send方法调用前调用。</p> 
</blockquote> 
<h5>2、使用xhr发起get请求</h5> 
<pre><code class="language-javascript">// 创建异步请求对象
let xhr = new XMLHttpRequest();
// 绑定监听onreadystatechange事件  当请求状态发生改变时 执行
xhr.onreadystatechange = function(){
/**
  * xhr.readyState 请求状态
  * 0 请求未初始化
  * 1 服务器连接已建立
  * 2 请求已接收
  * 3 请求处理中
  * 4 请求已完成，且响应已就绪
  * xhr.status 响应状态码
  * 200 请求成功
  * 404 请求失败
  * xhr.responseText 响应体
*/
// 监听xhr对象的请求状态 与服务器的响应状态         
if(xhr.readyState === 4 &amp;&amp; xhr.status === 200){
        console.log(JSON.parse(xhr.responseText))
   }
}
// 配置  请求方式 请求url地址  是否异步
xhr.open('get', 'http://localhost:8080/dish/list?categoryId=1397844263642378242',true);
// 发送请求  如果是post 传参
xhr.send();
</code></pre> 
<p><strong> 执行结果：</strong></p> 
<p><img alt="" height="355" src="https://images2.imgbox.com/8c/f6/bFfFiy94_o.png" width="875"></p> 
<h5><strong>3、使用xhr发送post请求</strong></h5> 
<pre><code class="language-javascript">//  POST 后台 表单格式的参数
// 创建异步请求对象
let xhr = new XMLHttpRequest();
// 绑定事件 当请求状态发生改变时 执行
xhr.onreadystatechange = function(){
if(xhr.readyState === 4 &amp;&amp; xhr.status === 200){
          console.log(xhr.responseText)
   }
}
// 配置  请求方式 请求url地址  是否异步
xhr.open('POST', 'http://localhost:8080/dish/page',true);
// 表单格式参数
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
// 发送请求  如果是post 传参
xhr.send('page=1&amp;pageSize=10');</code></pre> 
<p> 执行结果：</p> 
<p><img alt="" height="671" src="https://images2.imgbox.com/0d/cb/ruYczIPk_o.png" width="1200"></p> 
<h5><strong>4、post方式发送json</strong></h5> 
<pre><code class="language-javascript">// 创建异步请求对象
let xhr = new XMLHttpRequest();
//绑定事件 当请求状态发生改变时 执行
xhr.onreadystatechange = function () {
if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) {
        console.log(xhr.responseText)
    }
}
//配置    请求方式   请求的URL  是否异步 true
xhr.open('POST', 'http://localhost:8080/employee/login',true);
// 后台接受JSON 格式的参数
xhr.setRequestHeader("Content-type","application/json")
//发送请求  如果是post  传参
xhr.send(JSON.stringify({"username":"root","password":123456}));</code></pre> 
<p><strong>执行结果：</strong></p> 
<p><img alt="" height="186" src="https://images2.imgbox.com/51/d1/IvG2FBLo_o.png" width="1200"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b6e04edb80dbe2f7e7a996b8adc9af39/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java生成exe可执行文件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/de43d0cbcc9c8c8c0bc0362ce43a2673/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android 14 抓包、安装系统证书</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>