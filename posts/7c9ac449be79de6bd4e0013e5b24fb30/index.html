<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【知识点随笔分享 | 第九篇】常见的限流算法 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/7c9ac449be79de6bd4e0013e5b24fb30/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【知识点随笔分享 | 第九篇】常见的限流算法">
  <meta property="og:description" content="目录
前言：
1.固定窗口限流： 缺点： 2.滑动窗口限流：
优点：
滴桶限流：
缺点：
令牌桶限流： 优点：
总结:
前言： 当今互联网时代，随着网络流量的快速增长和系统负载的不断加重，限流算法作为一种重要的网络管理工具变得愈发重要。限流算法通过控制系统的输入和输出流量，有效地保护系统不受过载的影响，确保系统能够稳定可靠地运行。本文将介绍几种常见的限流算法及其应用场景，旨在帮助读者更好地理解限流算法的原理和实际应用，从而为网络性能优化提供有力支持。限流算法的研究和应用对于保障网络安全、提升系统稳定性具有重要意义，在当前信息化社会具有广泛的应用前景。 1.固定窗口限流： 固定窗口限流 就是在单位时间（时间窗口）内，只能接收指定数量的请求。
在固定窗口限流算法中，时间被划分为固定大小的窗口，并且每个窗口内允许通过的请求数是固定的。算法步骤： 统计当前窗口内的请求数；如果请求数超过了限制值，则拒绝该请求；重置新的窗口开始计数。 用汉堡店举例：固定窗口限流就是 在固定的时间内只能接待指定数量的顾客。比如一个小时只能接待10个顾客。
固定窗口限流的思路比较简单，代码实现为：
import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicInteger; public class FixedWindowRateLimiter { private final int limit; // 限制的请求数 private final long windowSizeInMillis; // 窗口大小（毫秒） private final AtomicInteger counter; private long windowStartTime; public FixedWindowRateLimiter(int limit, long windowSizeInMillis) { this.limit = limit; this.windowSizeInMillis = windowSizeInMillis; this.counter = new AtomicInteger(0); this.windowStartTime = System.currentTimeMillis(); } public boolean allowRequest() { long currentTime = System.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-12-25T22:29:42+08:00">
    <meta property="article:modified_time" content="2023-12-25T22:29:42+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【知识点随笔分享 | 第九篇】常见的限流算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80%EF%BC%9A" rel="nofollow">前言：</a></p> 
<p id="1.%E5%9B%BA%E5%AE%9A%E7%AA%97%E5%8F%A3%E9%99%90%E6%B5%81%EF%BC%9A%C2%A0-toc" style="margin-left:0px;"><a href="#1.%E5%9B%BA%E5%AE%9A%E7%AA%97%E5%8F%A3%E9%99%90%E6%B5%81%EF%BC%9A%C2%A0" rel="nofollow">1.固定窗口限流： </a></p> 
<p id="%E7%BC%BA%E7%82%B9%EF%BC%9A%C2%A0-toc" style="margin-left:40px;"><a href="#%E7%BC%BA%E7%82%B9%EF%BC%9A%C2%A0" rel="nofollow">缺点： </a></p> 
<p id="2.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%99%90%E6%B5%81%EF%BC%9A-toc" style="margin-left:0px;"><a href="#2.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%99%90%E6%B5%81%EF%BC%9A" rel="nofollow">2.滑动窗口限流：</a></p> 
<p id="%C2%A0%E4%BC%98%E7%82%B9%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%C2%A0%E4%BC%98%E7%82%B9%EF%BC%9A" rel="nofollow"> 优点：</a></p> 
<p id="%E6%BB%B4%E6%A1%B6%E9%99%90%E6%B5%81%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E6%BB%B4%E6%A1%B6%E9%99%90%E6%B5%81%EF%BC%9A" rel="nofollow">滴桶限流：</a></p> 
<p id="%E7%BC%BA%E7%82%B9%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E7%BC%BA%E7%82%B9%EF%BC%9A" rel="nofollow">缺点：</a></p> 
<p id="%E4%BB%A4%E7%89%8C%E6%A1%B6%E9%99%90%E6%B5%81%EF%BC%9A%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%BB%A4%E7%89%8C%E6%A1%B6%E9%99%90%E6%B5%81%EF%BC%9A%C2%A0" rel="nofollow">令牌桶限流： </a></p> 
<p id="%E4%BC%98%E7%82%B9%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E4%BC%98%E7%82%B9%EF%BC%9A" rel="nofollow">优点：</a></p> 
<p id="%E6%80%BB%E7%BB%93%3A-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93%3A" rel="nofollow">总结:</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p> </p> 
<h2 id="%E5%89%8D%E8%A8%80%EF%BC%9A">前言：</h2> 
<p>        当今互联网时代，随着网络流量的快速增长和系统负载的不断加重，限流算法作为一种重要的网络管理工具变得愈发重要。限流算法通过控制系统的输入和输出流量，有效地保护系统不受过载的影响，确保系统能够稳定可靠地运行。<strong><span style="color:#fe2c24;">本文将介绍几种常见的限流算法及其应用场景，旨在帮助读者更好地理解限流算法的原理和实际应用</span></strong>，从而为网络性能优化提供有力支持。限流算法的研究和应用对于保障网络安全、提升系统稳定性具有重要意义，在当前信息化社会具有广泛的应用前景。 </p> 
<p><img alt="" height="699" src="https://images2.imgbox.com/7a/99/bzbIGjLT_o.png" width="1200"></p> 
<h2 id="1.%E5%9B%BA%E5%AE%9A%E7%AA%97%E5%8F%A3%E9%99%90%E6%B5%81%EF%BC%9A%C2%A0">1.固定窗口限流： </h2> 
<p>       <span style="color:#be191c;"><span style="background-color:#fbd4d0;"> 固定窗口限流</span></span>  就是在单位时间（时间窗口）内，只能接收指定数量的请求。</p> 
<ul><li>在固定窗口限流算法中，时间被划分为固定大小的窗口，并且每个窗口内允许通过的请求数是固定的。</li><li>算法步骤： 
  <ul><li>统计当前窗口内的请求数；</li><li>如果请求数超过了限制值，则拒绝该请求；</li><li>重置新的窗口开始计数。</li></ul></li></ul> 
<blockquote> 
 <p>用汉堡店举例：固定窗口限流就是  在固定的时间内只能接待指定数量的顾客。比如一个小时只能接待10个顾客。</p> 
</blockquote> 
<p>固定窗口限流的思路比较简单，代码实现为：</p> 
<pre><code class="language-java">import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

public class FixedWindowRateLimiter {
    private final int limit;  // 限制的请求数
    private final long windowSizeInMillis;  // 窗口大小（毫秒）
    private final AtomicInteger counter;
    private long windowStartTime;

    public FixedWindowRateLimiter(int limit, long windowSizeInMillis) {
        this.limit = limit;
        this.windowSizeInMillis = windowSizeInMillis;
        this.counter = new AtomicInteger(0);
        this.windowStartTime = System.currentTimeMillis();
    }

    public boolean allowRequest() {
        long currentTime = System.currentTimeMillis();
        long elapsedTime = currentTime - windowStartTime;

        if (elapsedTime &gt; windowSizeInMillis) {
            // 进入新的窗口，重置计数器和窗口开始时间
            counter.set(0);
            windowStartTime = currentTime;
        }

        // 检查请求数是否超过限制
        if (counter.incrementAndGet() &gt; limit) {
            return false;  // 超过限制，拒绝请求
        }

        return true;  // 没有超过限制，允许请求通过
    }
}
</code></pre> 
<h3 id="%E7%BC%BA%E7%82%B9%EF%BC%9A%C2%A0">缺点： </h3> 
<p>      <strong><span style="color:#fe2c24;">  固定窗口限流可能会引发流量突刺</span></strong>，也就是可能会发生以下情况：</p> 
<p><img alt="" height="336" src="https://images2.imgbox.com/04/47/Qk7N22rv_o.png" width="1200"></p> 
<p>我们用红色来标识 在该时间窗口区域发生了请求，也就是说固定窗口限流在窗口的边界处可能会发生流量突刺，在短时间内发生多次请求</p> 
<h2 id="2.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%99%90%E6%B5%81%EF%BC%9A">2.滑动窗口限流：</h2> 
<p>          <span style="color:#be191c;"><span style="background-color:#fbd4d0;"> 滑动窗口限流</span></span>  就是在单位时间（时间窗口）内，只能接收指定数量的请求。但单位时间是滑动的。</p> 
<ul><li>在滑动窗口限流算法中，时间被划分为固定大小的窗口，每个窗口内允许通过的请求数是固定的，同时可以滑动窗口来适应请求的变化。</li><li>算法步骤： 
  <ul><li>统计当前窗口内的请求数；</li><li>如果请求数超过了限制值，则拒绝该请求；</li><li>滑动窗口，将旧的窗口移除。</li></ul></li></ul> 
<p>我们用图片来标识滑动窗口限流和固定窗口限流的区别：</p> 
<p>这是固定窗口限流，他的时间窗口是由时间窗口大小决定的。 </p> 
<p><img alt="" height="320" src="https://images2.imgbox.com/46/ba/6PdaFq7N_o.png" width="1200"> 这是滑动窗口限流，他的时间窗口是不断滑动的。</p> 
<p><img alt="" height="573" src="https://images2.imgbox.com/57/61/icJe5Ujc_o.png" width="1200"></p> 
<p>也就是说：滑动窗口限流不会一次性消除旧窗口的请求次数，而是不断的通过滑动的方式抹除。</p> 
<blockquote> 
 <p> 用汉堡店举例：滑动窗口限流就是  单位时间内限制接客数，相比较于固定窗口而言，假设我们在5.59接待了五位客人，如果时间窗口长度为小时，滑动单位为1分钟，那么六点的时候，并不会刷新窗口接待客人人数，而是继续保留5.59的接待人数。因为此时二者仍位于一个窗口内。  </p> 
</blockquote> 
<p>滑动窗口限流的代码思路为:</p> 
<pre><code class="language-java">import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class SlidingWindowRateLimiter {
    private final int limit;  // 限制的请求数
    private final long windowSizeInMillis;  // 窗口大小（毫秒）
    private final int[] counter;
    private final Lock lock;
    private long windowStartTime;

    public SlidingWindowRateLimiter(int limit, long windowSizeInMillis) {
        this.limit = limit;
        this.windowSizeInMillis = windowSizeInMillis;
        this.counter = new int[(int) (windowSizeInMillis / 1000)];
        this.lock = new ReentrantLock();
        this.windowStartTime = System.currentTimeMillis();
    }

    public boolean allowRequest() {
        long currentTime = System.currentTimeMillis();
        long elapsedTime = currentTime - windowStartTime;

        lock.lock();
        try {
            // 滑动窗口，将旧的窗口移除
            if (elapsedTime &gt; windowSizeInMillis) {
                int numToRemove = (int) ((elapsedTime - windowSizeInMillis) / 1000);
                for (int i = 0; i &lt; numToRemove; i++) {
                    counter[i] = 0;
                }
                windowStartTime = currentTime - (elapsedTime % windowSizeInMillis);
            }

            // 统计请求数
            int currentWindowIndex = (int) (elapsedTime / 1000);
            counter[currentWindowIndex]++;

            // 检查请求数是否超过限制
            int totalRequests = 0;
            for (int i = 0; i &lt; counter.length; i++) {
                totalRequests += counter[i];
            }
            if (totalRequests &gt; limit) {
                return false;  // 超过限制，拒绝请求
            }
        } finally {
            lock.unlock();
        }

        return true;  // 没有超过限制，允许请求通过
    }
}
</code></pre> 
<h3 id="%C2%A0%E4%BC%98%E7%82%B9%EF%BC%9A"> 优点：</h3> 
<p>                <strong><span style="color:#fe2c24;">滑动窗口可以缓解流量突刺</span></strong>：例如固定窗口（窗口大小为1小时，每个窗口最多处理10个请求）可以在1.59进行了十次请求，2.01进行了十次请求。但是在滑动窗口中，如果我们将滑动参数设置为1min，窗口大小设置为1小时，那么1.59时，滑动窗口的范围是1.59-2.59。此时如果设置最大请求数量为10，那么1.59执行的十次请求就已经填满了请求数量上限。2.01的就无法进行请求。通过这种思路避免了窗口边界流量突刺这种情况。</p> 
<h2 id="%E6%BB%B4%E6%A1%B6%E9%99%90%E6%B5%81%EF%BC%9A">滴桶限流：</h2> 
<p><span style="color:#be191c;"><span style="background-color:#fbd4d0;">滴桶限流</span></span> 就是  接收指定数量的请求，按照指定的速率处理。</p> 
<ul><li>在滴桶限流算法中，系统以恒定的速率漏水，并以固定速率接收请求。</li><li>算法步骤： 
  <ul><li>当有请求到达时，先检查桶中是否有水滴；</li><li>如果有水滴可用，则允许请求通过并漏水；</li><li>如果没有水滴可用，则拒绝该请求。</li></ul></li></ul> 
<p> <img alt="" height="847" src="https://images2.imgbox.com/1a/f0/sCqDWrHY_o.png" width="977"></p> 
<blockquote> 
 <p>用汉堡店举例：滴桶限流就是每个小时接待6个客户，然后每十分钟处理一个客户的请求 </p> 
</blockquote> 
<p> java代码实现:</p> 
<pre><code class="language-java">import java.util.concurrent.TimeUnit;

public class LeakyBucketRateLimiter {
    private final int capacity;  // 桶的容量
    private final double rate;   // 水滴漏出速率（水滴/秒）
    private double water;        // 当前桶中的水滴数量
    private long lastLeakTime;   // 上次漏水的时间戳

    public LeakyBucketRateLimiter(int capacity, double rate) {
        this.capacity = capacity;
        this.rate = rate;
        this.water = 0;
        this.lastLeakTime = System.nanoTime();
    }

    public synchronized boolean allowRequest() {
        leak();

        if (water &gt;= 1) {
            water -= 1;
            return true;  // 水滴足够，允许请求通过
        } else {
            return false;  // 水滴不足，拒绝请求
        }
    }

    private void leak() {
        long now = System.nanoTime();
        double elapsedTime = (now - lastLeakTime) / 1e9;
        double waterToLeak = elapsedTime * rate;

        if (waterToLeak &gt; 0) {
            water = Math.max(0, water - waterToLeak);
            lastLeakTime = now;
        }
    }
}
</code></pre> 
<h3 id="%E7%BC%BA%E7%82%B9%EF%BC%9A">缺点：</h3> 
<p>       <strong><span style="color:#fe2c24;"> 滴桶限流的并发性比较差</span></strong>，我们在代码中就可以看到，他需要对水滴（请求）逐个进行处理</p> 
<h2 id="%E4%BB%A4%E7%89%8C%E6%A1%B6%E9%99%90%E6%B5%81%EF%BC%9A%C2%A0">令牌桶限流： </h2> 
<p>        令牌桶限流就是创建一个桶，生成指定数量的令牌，只有拿到令牌的请求才可以进行处理。</p> 
<ul><li>在令牌桶限流算法中，系统以恒定的速率生成令牌并放入令牌桶中，每个请求需要获取一个令牌才能通过。</li><li>算法步骤： 
  <ul><li>每隔一段时间生成一定数量的令牌放入桶中；</li><li>当有请求到达时，从桶中获取一个令牌，如果没有令牌可用，则拒绝该请求。</li></ul></li></ul> 
<pre><code class="language-java">import java.util.concurrent.TimeUnit;

public class TokenBucketRateLimiter {
    private final int capacity;  // 令牌桶容量
    private final double rate;   // 令牌生成速率（令牌/秒）
    private double tokens;       // 当前桶中的令牌数
    private long lastRefillTime; // 上次填充令牌的时间戳

    public TokenBucketRateLimiter(int capacity, double rate) {
        this.capacity = capacity;
        this.rate = rate;
        this.tokens = capacity;
        this.lastRefillTime = System.nanoTime();
    }

    public synchronized boolean allowRequest() {
        refill();

        if (tokens &gt;= 1) {
            tokens -= 1;
            return true;  // 令牌足够，允许请求通过
        } else {
            return false;  // 令牌不足，拒绝请求
        }
    }

    private void refill() {
        long now = System.nanoTime();
        double elapsedTime = (now - lastRefillTime) / 1e9;
        double tokensToAdd = elapsedTime * rate;

        if (tokensToAdd &gt; 0) {
            tokens = Math.min(capacity, tokens + tokensToAdd);
            lastRefillTime = now;
        }
    }
}
</code></pre> 
<blockquote> 
 <p>用汉堡店举例：令牌桶限流就是 汉堡店 有一个 餐卷桶，并且会按时补充餐卷桶的餐卷数，只有拿到了餐卷才可以购买汉堡</p> 
</blockquote> 
<h3 id="%E4%BC%98%E7%82%B9%EF%BC%9A">优点：</h3> 
<p>        令牌桶限流的并发性能比较高，我们可以批量对拿到令牌的请求进行处理。</p> 
<h2 id="%E6%80%BB%E7%BB%93%3A">总结:</h2> 
<p>        在实际的开发中，其实我们并不用手动去实现这些限流算法，很多第三方库都已经为我们实现了限流算法，我们只需要直接使用就好了。而在实际开发中，常用的限流算法是 滴桶限流和令牌桶限流。因此我们要掌握好这两个限流算法。</p> 
<p>如果我的内容对你有帮助，请<span style="color:#fe2c24;"><strong>点赞，评论，收藏</strong></span>。创作不易，大家的支持就是我坚持下去的动力！</p> 
<p><img alt="" src="https://images2.imgbox.com/f1/3d/CnaUChhQ_o.png"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6d1e37bb57bb356084a5b397f289e61b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java调用DLL保姆级教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a0d95daa694ed35a019c57eeb524546d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">在Python中使用pyecharts图形画可视化大屏</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>