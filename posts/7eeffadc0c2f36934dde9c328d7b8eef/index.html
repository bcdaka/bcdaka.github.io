<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;航海王：追寻罗杰的编程之路】关联式容器的底层结构——红黑树 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/7eeffadc0c2f36934dde9c328d7b8eef/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;航海王：追寻罗杰的编程之路】关联式容器的底层结构——红黑树">
  <meta property="og:description" content="目录
1 -&gt; 红黑树
1.1 -&gt; 红黑树的概念
1.2 -&gt; 红黑树的性质
1.3 -&gt; 红黑树节点的定义
1.4 -&gt; 红黑树的结构
1.5 -&gt; 红黑树的插入操作
1.6 -&gt; 红黑树的验证
1.8 -&gt; 红黑树与AVL树的比较
2 -&gt; 红黑树模拟实现STL中的map与set
2.1 -&gt; 红黑树的迭代器
2.2 -&gt; 改造红黑树
2.3 -&gt; map的模拟实现
2.4 -&gt; set的模拟实现
1 -&gt; 红黑树 1.1 -&gt; 红黑树的概念 红黑树，是一种二叉搜索树，但在每个节点上增加了一个存储位表示节点的颜色，可以是Red或Black。通过对任何一条从根到叶子的路径上各个节点着色方式的限制，红黑树确保没有一条路径会比其他路径长出两倍，因而是接近平衡的。
1.2 -&gt; 红黑树的性质 每个节点不是红色就是黑色。根节点是黑色的。如果一个节点是红色的，则它的两个孩子节点是黑色的。对于每个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点。每个叶子节点都是黑色的(此处的叶子节点指空节点)。 1.3 -&gt; 红黑树节点的定义 #define _CRT_SECURE_NO_WARNINGS 1 #include &lt;iostream&gt; using namespace std; // 节点的颜色 enum Color { RED, BLACK }; // 红黑树节点的定义 template&lt;class ValueType&gt; struct RBTreeNode { RBTreeNode(const ValueType&amp; data = ValueType()，Color color = RED) : _pLeft(nullptr), _pRight(nullptr), _pParent(nullptr) , _data(data), _color(color) {} RBTreeNode&lt;ValueType&gt;* _pLeft; // 节点的左孩子 RBTreeNode&lt;ValueType&gt;* _pRight; // 节点的右孩子 RBTreeNode&lt;ValueType&gt;* _pParent; // 节点的双亲(红黑树需要旋转，为了实现简单给出该字段) ValueType _data; // 节点的值域 Color _color; // 节点的颜色 }; 1.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-10T15:57:27+08:00">
    <meta property="article:modified_time" content="2024-07-10T15:57:27+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;航海王：追寻罗杰的编程之路】关联式容器的底层结构——红黑树</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><span style="color:#79c6cd;"><strong>目录</strong></span></p> 
<p id="1%20-%3E%20%E7%BA%A2%E9%BB%91%E6%A0%91-toc" style="margin-left:0px;"><strong><a href="#1%20-%3E%20%E7%BA%A2%E9%BB%91%E6%A0%91" rel="nofollow"><span style="color:#79c6cd;">1 -&gt; 红黑树</span></a></strong></p> 
<p id="1.1%20-%3E%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><strong><a href="#1.1%20-%3E%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow"><span style="color:#79c6cd;">1.1 -&gt; 红黑树的概念</span></a></strong></p> 
<p id="1.2%20-%3E%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8-toc" style="margin-left:40px;"><strong><a href="#1.2%20-%3E%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8" rel="nofollow"><span style="color:#79c6cd;">1.2 -&gt; 红黑树的性质</span></a></strong></p> 
<p id="1.3%20-%3E%20%E7%BA%A2%E9%BB%91%E6%A0%91%E8%8A%82%E7%82%B9%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><strong><a href="#1.3%20-%3E%20%E7%BA%A2%E9%BB%91%E6%A0%91%E8%8A%82%E7%82%B9%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow"><span style="color:#79c6cd;">1.3 -&gt; 红黑树节点的定义</span></a></strong></p> 
<p id="1.4%20-%3E%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><strong><a href="#1.4%20-%3E%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84" rel="nofollow"><span style="color:#79c6cd;">1.4 -&gt; 红黑树的结构</span></a></strong></p> 
<p id="1.5%20-%3E%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><strong><a href="#1.5%20-%3E%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C" rel="nofollow"><span style="color:#79c6cd;">1.5 -&gt; 红黑树的插入操作</span></a></strong></p> 
<p id="1.6%20-%3E%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E9%AA%8C%E8%AF%81-toc" style="margin-left:40px;"><strong><a href="#1.6%20-%3E%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E9%AA%8C%E8%AF%81" rel="nofollow"><span style="color:#79c6cd;">1.6 -&gt; 红黑树的验证</span></a></strong></p> 
<p id="1.8%20-%3E%20%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8EAVL%E6%A0%91%E7%9A%84%E6%AF%94%E8%BE%83-toc" style="margin-left:40px;"><strong><a href="#1.8%20-%3E%20%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8EAVL%E6%A0%91%E7%9A%84%E6%AF%94%E8%BE%83" rel="nofollow"><span style="color:#79c6cd;">1.8 -&gt; 红黑树与AVL树的比较</span></a></strong></p> 
<p id="2%20-%3E%20%E7%BA%A2%E9%BB%91%E6%A0%91%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0STL%E4%B8%AD%E7%9A%84map%E4%B8%8Eset-toc" style="margin-left:0px;"><strong><a href="#2%20-%3E%20%E7%BA%A2%E9%BB%91%E6%A0%91%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0STL%E4%B8%AD%E7%9A%84map%E4%B8%8Eset" rel="nofollow"><span style="color:#79c6cd;">2 -&gt; 红黑树模拟实现STL中的map与set</span></a></strong></p> 
<p id="2.1%20-%3E%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8-toc" style="margin-left:40px;"><strong><a href="#2.1%20-%3E%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8" rel="nofollow"><span style="color:#79c6cd;">2.1 -&gt; 红黑树的迭代器</span></a></strong></p> 
<p id="2.2%20-%3E%20%E6%94%B9%E9%80%A0%E7%BA%A2%E9%BB%91%E6%A0%91-toc" style="margin-left:40px;"><strong><a href="#2.2%20-%3E%20%E6%94%B9%E9%80%A0%E7%BA%A2%E9%BB%91%E6%A0%91" rel="nofollow"><span style="color:#79c6cd;">2.2 -&gt; 改造红黑树</span></a></strong></p> 
<p id="2.3%20-%3E%20map%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><strong><a href="#2.3%20-%3E%20map%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" rel="nofollow"><span style="color:#79c6cd;">2.3 -&gt; map的模拟实现</span></a></strong></p> 
<p id="2.4%20-%3E%20set%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><strong><a href="#2.4%20-%3E%20set%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" rel="nofollow"><span style="color:#79c6cd;">2.4 -&gt; set的模拟实现</span></a></strong></p> 
<hr id="hr-toc"> 
<p class="img-center"><img alt="" height="579" src="https://images2.imgbox.com/1a/3d/CA8ld21o_o.png" width="552"></p> 
<h2 id="1%20-%3E%20%E7%BA%A2%E9%BB%91%E6%A0%91">1 -&gt; 红黑树</h2> 
<h3 id="1.1%20-%3E%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5">1.1 -&gt; 红黑树的概念</h3> 
<p><span style="color:#6eaad7;"><strong>红黑树</strong>，是一种<strong>二叉搜索树</strong>，但<strong>在每个节点上增加了一个存储位表示节点的颜色，可以是Red或Black</strong>。通过对<strong>任何一条从根到叶子的路径上各个节点着色方式的限制，红黑树确保没有一条路径会比其他路径长出两倍</strong>，因而是<strong>接近平衡</strong>的。</span></p> 
<p class="img-center"><img alt="" height="504" src="https://images2.imgbox.com/02/40/MzeD7XDb_o.png" width="982"></p> 
<h3 id="1.2%20-%3E%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8">1.2 -&gt; 红黑树的性质</h3> 
<ol><li><strong><span style="color:#6eaad7;">每个节点不是红色就是黑色。</span></strong></li><li><strong><span style="color:#6eaad7;">根节点是黑色的。</span></strong></li><li><strong><span style="color:#6eaad7;">如果一个节点是红色的，则它的两个孩子节点是黑色的。</span></strong></li><li><strong><span style="color:#6eaad7;">对于每个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点。</span></strong></li><li><strong><span style="color:#6eaad7;">每个叶子节点都是黑色的(此处的叶子节点指空节点)。</span></strong></li></ol> 
<h3 id="1.3%20-%3E%20%E7%BA%A2%E9%BB%91%E6%A0%91%E8%8A%82%E7%82%B9%E7%9A%84%E5%AE%9A%E4%B9%89">1.3 -&gt; 红黑树节点的定义</h3> 
<pre><code class="hljs">#define _CRT_SECURE_NO_WARNINGS 1

#include &lt;iostream&gt;
using namespace std;

// 节点的颜色
enum Color 
{ 
	RED, BLACK 
};

// 红黑树节点的定义
template&lt;class ValueType&gt;
struct RBTreeNode
{
	RBTreeNode(const ValueType&amp; data = ValueType()，Color color = RED)
		: _pLeft(nullptr), _pRight(nullptr), _pParent(nullptr)
		, _data(data), _color(color)
	{}
	RBTreeNode&lt;ValueType&gt;* _pLeft;   // 节点的左孩子
	RBTreeNode&lt;ValueType&gt;* _pRight;  // 节点的右孩子
	RBTreeNode&lt;ValueType&gt;* _pParent; // 节点的双亲(红黑树需要旋转，为了实现简单给出该字段)

	ValueType _data; // 节点的值域
	Color _color;    // 节点的颜色
};</code></pre> 
<h3 id="1.4%20-%3E%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84">1.4 -&gt; 红黑树的结构</h3> 
<p><span style="color:#6eaad7;">为了后续实现关联式容器更加简单，红黑树的实现中增加一个头节点，因为根节点必须是黑色的，为了与根节点区分开，将头节点给成黑色，并且让头节点的pParent域指向红黑树的根节点，pLeft域指向红黑树中最小的节点，_pRight域指向红黑树中最大的节点。</span></p> 
<p class="img-center"><img alt="" height="711" src="https://images2.imgbox.com/ec/6d/mz7epOI4_o.png" width="1200"></p> 
<h3 id="1.5%20-%3E%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C">1.5 -&gt; 红黑树的插入操作</h3> 
<p><span style="color:#6eaad7;">红黑树是在二叉搜索树的基础上加上其平衡限制条件，因此红黑树的插入可以分为两步：</span></p> 
<p><span style="color:#6eaad7;"><strong>1. 按照二叉搜索树的树规则插入新节点。</strong></span></p> 
<pre><code class="hljs">template&lt;class ValueType&gt;
struct RBTree
{
	bool Insert(const ValueType&amp; data)
	{
		PNode&amp; pRoot = GetRoot();
		if (nullptr == pRoot)
		{
			pRoot = new Node(data, BLACK);

			// 根的双亲为头节点
			pRoot-&gt;_pParent = _pHead;
			_pHead-&gt;_pParent = pRoot;
		}
		else
		{
			// 1. 按照二叉搜索的树方式插入新节点
			// 2. 检测新节点插入后，红黑树的性质是否造到破坏，
			//    若满足直接退出，否则对红黑树进行旋转着色处理
		}
		// 根节点的颜色可能被修改，将其改回黑色
		pRoot-&gt;_color = BLACK;
		_pHead-&gt;_pLeft = LeftMost();
		_pHead-&gt;_pRight = RightMost();

		return true;
	}
private:
	PNode&amp; GetRoot()
	{
		return _pHead-&gt;_pParent;
	}

	// 获取红黑树中最小节点，即最左侧节点
	PNode LeftMost();

	// 获取红黑树中最大节点，即最右侧节点
	PNode RightMost();

private:
	PNode _pHead;
}</code></pre> 
<p><span style="color:#6eaad7;"><strong>2. 检测新节点插入后，红黑树的性质是否遭到破坏。</strong></span></p> 
<p><span style="color:#6eaad7;">因为<strong>新节点的默认颜色为红色</strong>，因此：如果其<strong>双亲节点的颜色是黑色，没有违反红黑树的任何性质</strong>，则不需要调整；但<strong>当新插入节点的双亲节点颜色为红色时，就违反了性质三，即不能有连在一起的红色节点</strong>，此时需要对红黑树分情况来讨论： </span></p> 
<ul><li><span style="color:#6eaad7;"><strong>情况一：cur为红，p为红，g为黑，u存在且为红。</strong></span></li></ul> 
<p><span style="color:#ed7976;">注意：此处看到的树可能是一棵完整的树，也可能是一棵子树。</span></p> 
<p class="img-center"><img alt="" height="402" src="https://images2.imgbox.com/12/17/ArV5S7CU_o.png" width="1011"></p> 
<p><span style="color:#6eaad7;">如果g是根节点，调整完成后，需要将g改为黑色。</span></p> 
<p><span style="color:#6eaad7;">如果g是子树，g一定有双亲，且g的双亲如果是红色，就需要继续向上调整。 </span></p> 
<p class="img-center"><img alt="" height="429" src="https://images2.imgbox.com/9e/2d/ospWaVsE_o.png" width="1200"></p> 
<p><span style="color:#6eaad7;">cur和p均为红，违反了性质三。</span></p> 
<p><span style="color:#6eaad7;"><strong>解决方法：将p、u改为黑，g改为红，然后把g当成cur，继续向上调整。 </strong></span></p> 
<ul><li><span style="color:#6eaad7;"><strong>情况二：cur为红，p为红，g为黑，u不存在/u存在且为黑。</strong></span></li></ul> 
<p class="img-center"><img alt="" height="496" src="https://images2.imgbox.com/5d/14/FVXebsOW_o.png" width="1200"></p> 
<p><strong><span style="color:#6eaad7;"> 说明：</span></strong></p> 
<ol><li><span style="color:#6eaad7;">如果u节点不存在，则cur一定是新插入节点，因为如果cur不是新插入节点，则cur和p一定有一个节点的颜色是黑色，就不满足性质4：每条路径黑色节点个数相同。</span></li><li><span style="color:#6eaad7;">如果u节点存在，则其一定是黑色的，那么cur节点原来的颜色一定是黑色的，现在看到其是红色的原因是因为cur的子树在调整的过程中将cur节点的颜色由黑色改成了红色。</span></li></ol> 
<p><span style="color:#6eaad7;"><strong>p为g的左孩子，cur为p的左孩子，则进行右单旋转。</strong></span></p> 
<p><span style="color:#6eaad7;"><strong>p为g的右孩子，cur为p的右孩子，则进行左单旋转。</strong></span></p> 
<p><span style="color:#6eaad7;"><strong>p、g变色——p变黑，g变红。</strong></span></p> 
<ul><li><span style="color:#6eaad7;"><strong>情况三：cur为红，p为红，g为黑，u不存在/u存在且为黑。</strong></span></li></ul> 
<p class="img-center"><img alt="" height="346" src="https://images2.imgbox.com/6e/59/UPlAk0ey_o.png" width="1138"></p> 
<p> </p> 
<p><span style="color:#6eaad7;"><strong>p为g的左孩子，cur为p的右孩子，则针对p进行左单旋转。</strong></span></p> 
<p><span style="color:#6eaad7;"><strong>p为g的右孩子，cur为p的左孩子，则针对p进行右单旋转。</strong></span></p> 
<p><span style="color:#6eaad7;"><strong>则转换成情况二。</strong></span></p> 
<p><span style="color:#6eaad7;">针对每种情况进行相应的处理即可。</span></p> 
<pre><code class="hljs">bool Insert(const ValueType&amp; data)
{
	// ...
	// 新节点插入后，如果其双亲节点的颜色为空色，则违反性质3：不能有连在一起的红色结点
		while (pParent &amp;&amp; RED == pParent-&gt;_color)
		{
			// 注意：grandFather一定存在
			// 因为pParent存在，且不是黑色节点，则pParent一定不是根，则其一定有双亲
			PNode grandFather = pParent-&gt;_pParent;
			// 先讨论左侧情况
			if (pParent == grandFather-&gt;_pLeft)
			{
				PNode unclue = grandFather-&gt;_pRight;
				// 情况三：叔叔节点存在，且为红
				if (unclue &amp;&amp; RED == unclue-&gt;_color)
				{
					pParent-&gt;_color = BLACK;
					unclue-&gt;_color = BLACK;
					grandFather-&gt;_color = RED;
					pCur = grandFather;
					pParent = pCur-&gt;_pParent;
				}
				else
				{
					// 情况五：叔叔节点不存在，或者叔叔节点存在且为黑
					if (pCur == pParent-&gt;_pRight)
					{
						_RotateLeft(pParent);
						swap(pParent, pCur);
					}
					// 情况五最后转化成情况四
					grandFather-&gt;_color = RED;
					pParent-&gt;_color = BLACK;
					_RotateRight(grandFather);
				}
			}
			else
			{
				// …
			}
		}
	// ...
}</code></pre> 
<h3 id="1.6%20-%3E%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E9%AA%8C%E8%AF%81">1.6 -&gt; 红黑树的验证</h3> 
<p><span style="color:#6eaad7;">红黑树的检测分为两步：</span></p> 
<ol><li><strong><span style="color:#6eaad7;">检测其是否满足二叉搜索树(中序遍历是否为有序序列)。</span></strong></li><li><strong><span style="color:#6eaad7;">检测其是否满足红黑树的性质。</span></strong></li></ol> 
<pre><code class="hljs">bool IsValidRBTree()
	{
		PNode pRoot = GetRoot();

		// 空树也是红黑树
		if (nullptr == pRoot)
			return true;

		// 检测根节点是否满足情况
		if (BLACK != pRoot-&gt;_color)
		{
			cout &lt;&lt; "违反红黑树性质二：根节点必须为黑色" &lt;&lt; endl;

			return false;
		}

		// 获取任意一条路径中黑色节点的个数
		size_t blackCount = 0;
		PNode pCur = pRoot;
		while (pCur)
		{
			if (BLACK == pCur-&gt;_color)
				blackCount++;

			pCur = pCur-&gt;_pLeft;
		}

		// 检测是否满足红黑树的性质，k用来记录路径中黑色节点的个数
		size_t k = 0;

		return _IsValidRBTree(pRoot, k, blackCount);
	}

	bool _IsValidRBTree(PNode pRoot, size_t k, const size_t blackCount)
	{
		//走到null之后，判断k和black是否相等
		if (nullptr == pRoot)
		{
			if (k != blackCount)
			{
				cout &lt;&lt; "违反性质四：每条路径中黑色节点的个数必须相同" &lt;&lt; endl;
				return false;
			}

			return true;
		}

		// 统计黑色节点的个数
		if (BLACK == pRoot-&gt;_color)
			k++;

		// 检测当前节点与其双亲是否都为红色
		PNode pParent = pRoot-&gt;_pParent;
		if (pParent &amp;&amp; RED == pParent-&gt;_color &amp;&amp; RED == pRoot-&gt;_color)
		{
			cout &lt;&lt; "违反性质三：没有连在一起的红色节点" &lt;&lt; endl;

			return false;
		}

		return _IsValidRBTree(pRoot-&gt;_pLeft, k, blackCount) &amp;&amp;
			_IsValidRBTree(pRoot-&gt;_pRight, k, blackCount);
	}</code></pre> 
<h3 id="1.8%20-%3E%20%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8EAVL%E6%A0%91%E7%9A%84%E6%AF%94%E8%BE%83">1.8 -&gt; 红黑树与AVL树的比较</h3> 
<p><span style="color:#6eaad7;"><strong>红黑树和AVL树都是高效的平衡二叉树，增删改查的时间复杂度都是O(n)，红黑树不追求绝对平衡，其只需保证最长路径不超过最短路径的2倍，相对而言，降低了插入和旋转的次数，所以在经常进行增删的结构中性能比AVL树更优，而且红黑树实现比较简单，所以在实际运用中红黑树更多。</strong></span></p> 
<h2 id="2%20-%3E%20%E7%BA%A2%E9%BB%91%E6%A0%91%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0STL%E4%B8%AD%E7%9A%84map%E4%B8%8Eset">2 -&gt; 红黑树模拟实现STL中的map与set</h2> 
<h3 id="2.1%20-%3E%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8">2.1 -&gt; 红黑树的迭代器</h3> 
<p><span style="color:#6eaad7;">迭代器的好处是可以方便遍历，是数据结构的底层实现与用户透明。如果想要给红黑树增加迭代器，需要考虑以下问题：</span></p> 
<ul><li><span style="color:#6eaad7;"><strong>begin()和end()</strong></span></li></ul> 
<p><span style="color:#6eaad7;">STL明确规定，begin()与end()代表的是一段前闭后开的区间，而对红黑树进行中序遍历后，可以得到一个有序的序列，因此：<strong>begin()可以放在红黑树中最小节点(即最左侧节点)的位置，end()放在最大节点(最右侧节点)的下一个位置</strong>，关键是最大节点的下一个位置在哪里呢？能否给成nullptr呢？</span></p> 
<p><span style="color:#6eaad7;">答案是行不通的，<strong>因为对end()位置的迭代器进行--操作，必须要能找到最后一个元素</strong>，此处就不行，因此<strong>最好的方式是将end()放在头节点的位置</strong>：</span></p> 
<p class="img-center"><img alt="" height="793" src="https://images2.imgbox.com/68/8f/tg90dOyB_o.png" width="1200"></p> 
<ul><li><span style="color:#6eaad7;"><strong>operator++()与operator--() </strong></span></li></ul> 
<pre><code class="hljs">// 找迭代器的下一个节点，下一个节点肯定比其大
	void Increasement()
	{
		//分两种情况讨论:_pNode的右子树存在和不存在
		// 右子树存在
		if (_pNode-&gt;_pRight)
		{
			// 右子树中最小的节点，即右子树中最左侧节点
			_pNode = _pNode-&gt;_pRight;
			while (_pNode-&gt;_pLeft)
				_pNode = _pNode-&gt;_pLeft;
		}
		else
		{
			// 右子树不存在，向上查找，直到_pNode != pParent-&gt;right
			PNode pParent = _pNode-&gt;_pParent;
			while (pParent-&gt;_pRight == _pNode)
			{
				_pNode = pParent;
				pParent = _pNode-&gt;_pParent;
			}
			// 特殊情况：根节点没有右子树
			if (_pNode-&gt;_pRight != pParent)
				_pNode = pParent;
		}
	}

	// 获取迭代器指向节点的前一个节点
	void Decreasement()
	{
		//分三种情况讨论：_pNode 在head的位置，_pNode 左子树存在，_pNode 左子树不
		存在
			// 1. _pNode 在head的位置，--应该将_pNode放在红黑树中最大节点的位置
			if (_pNode-&gt;_pParent-&gt;_pParent == _pNode &amp;&amp; _pNode-&gt;_color == RED)
				_pNode = _pNode-&gt;_pRight;
			else if (_pNode-&gt;_pLeft)
			{
				// 2. _pNode的左子树存在,在左子树中找最大的节点，即左子树中最右侧节点
				_pNode = _pNode-&gt;_pLeft;
				while (_pNode-&gt;_pRight)
					_pNode = _pNode-&gt;_pRight;
			}
			else
			{
				// _pNode的左子树不存在，只能向上找
				PNode pParent = _pNode-&gt;_pParent;
				while (_pNode == pParent-&gt;_pLeft)
				{
					_pNode = pParent;
					pParent = _pNode-&gt;_pParent;
				}
				_pNode = pParent;
			}
	}</code></pre> 
<h3 id="2.2%20-%3E%20%E6%94%B9%E9%80%A0%E7%BA%A2%E9%BB%91%E6%A0%91">2.2 -&gt; 改造红黑树</h3> 
<pre><code class="hljs">#pragma once

// set -&gt;key
// map -&gt;key/value

enum Colour
{
	RED,
	BLACK
};

template&lt;class T&gt;
struct RBTreeNode
{
	RBTreeNode&lt;T&gt;* _left;
	RBTreeNode&lt;T&gt;* _right;
	RBTreeNode&lt;T&gt;* _parent;

	T _data;

	Colour _col;

	RBTreeNode(const T&amp; data)
		:_left(nullptr)
		, _right(nullptr)
		, _parent(nullptr)
		, _data(data)
		, _col(RED)
	{}
};

template&lt;class T&gt;
struct __TreeIterator
{
	typedef RBTreeNode&lt;T&gt; Node;
	typedef __TreeIterator&lt;T&gt; Self;
	Node* _node;

	__TreeIterator(Node* node)
		:_node(node)
	{}

	T&amp; operator*()
	{
		return _node-&gt;_data;
	}

	T* operator-&gt;()
	{
		return &amp;_node-&gt;_data;
	}

	Self&amp; operator--();

	Self&amp; operator++()
	{
		if (_node-&gt;_right)
		{
			// 下一个就是右子树的最左节点
			Node* cur = _node-&gt;_right;
			while (cur-&gt;_left)
			{
				cur = cur-&gt;_left;
			}

			_node = cur;
		}
		else
		{
			// 左子树 根 右子树
			// 右为空，找孩子是父亲左的那个祖先
			Node* cur = _node;
			Node* parent = cur-&gt;_parent;
			while (parent &amp;&amp; cur == parent-&gt;_right)
			{
				cur = parent;
				parent = parent-&gt;_parent;
			}

			_node = parent;
		}

		return *this;
	}

	bool operator!=(const Self&amp; s)
	{
		return _node != s._node;
	}

	bool operator==(const Self&amp; s)
	{
		return _node == s._node;
	}
};

// set-&gt;RBTree&lt;K, K, SetKeyOfT&gt; _t;
// map-&gt;RBTree&lt;K, pair&lt;K, T&gt;, MapKeyOfT&gt; _t;
template&lt;class K, class T, class KeyOfT&gt;
class RBTree
{
	typedef RBTreeNode&lt;T&gt; Node;
public:
	typedef __TreeIterator&lt;T&gt; iterator;

	iterator begin()
	{
		Node* cur = _root;
		while (cur &amp;&amp; cur-&gt;_left)
		{
			cur = cur-&gt;_left;
		}

		return iterator(cur);
	}

	iterator end()
	{
		return iterator(nullptr);
	}

	pair&lt;iterator, bool&gt; Insert(const T&amp; data)
	{
		if (_root == nullptr)
		{
			_root = new Node(data);
			_root-&gt;_col = BLACK;
			return make_pair(iterator(_root), true);
		}

		Node* parent = nullptr;
		Node* cur = _root;
		KeyOfT kot;

		while (cur)
		{
			if (kot(cur-&gt;_data) &lt; kot(data))
			{
				parent = cur;
				cur = cur-&gt;_right;
			}
			else if (kot(cur-&gt;_data) &gt; kot(data))
			{
				parent = cur;
				cur = cur-&gt;_left;
			}
			else
			{
				return make_pair(iterator(cur), false);
			}
		}

		// 新增节点给红色
		cur = new Node(data);
		Node* newnode = cur;
		cur-&gt;_col = RED;
		if (kot(parent-&gt;_data) &lt; kot(data))
		{
			parent-&gt;_right = cur;
			cur-&gt;_parent = parent;
		}
		else
		{
			parent-&gt;_left = cur;
			cur-&gt;_parent = parent;
		}

		while (parent &amp;&amp; parent-&gt;_col == RED)
		{
			Node* grandfather = parent-&gt;_parent;
			if (parent == grandfather-&gt;_left)
			{
				//     g
				//   p   u
				// c
				Node* uncle = grandfather-&gt;_right;
				if (uncle &amp;&amp; uncle-&gt;_col == RED)
				{
					// 变色
					parent-&gt;_col = uncle-&gt;_col = BLACK;
					grandfather-&gt;_col = RED;

					// 继续往上更新处理
					cur = grandfather;
					parent = cur-&gt;_parent;
				}
				else
				{
					if (cur == parent-&gt;_left)
					{
						// 单旋
						//     g
						//   p
						// c
						RotateR(grandfather);
						parent-&gt;_col = BLACK;
						grandfather-&gt;_col = RED;
					}
					else
					{
						// 双旋
						//     g
						//   p
						//     c
						RotateL(parent);
						RotateR(grandfather);
						cur-&gt;_col = BLACK;
						grandfather-&gt;_col = RED;
					}

					break;
				}
			}
			else  // parent == grandfather-&gt;_right
			{
				//     g
				//   u   p 
				//          c
				//
				Node* uncle = grandfather-&gt;_left;
				if (uncle &amp;&amp; uncle-&gt;_col == RED)
				{
					// 变色
					parent-&gt;_col = uncle-&gt;_col = BLACK;
					grandfather-&gt;_col = RED;

					// 继续往上处理
					cur = grandfather;
					parent = cur-&gt;_parent;
				}
				else
				{
					if (cur == parent-&gt;_right)
					{
						RotateL(grandfather);
						parent-&gt;_col = BLACK;
						grandfather-&gt;_col = RED;
					}
					else
					{
						//     g
						//   u   p 
						//     c
						//
						RotateR(parent);
						RotateL(grandfather);
						cur-&gt;_col = BLACK;
						grandfather-&gt;_col = RED;
					}

					break;
				}
			}
		}

		_root-&gt;_col = BLACK;

		return make_pair(iterator(newnode), true);
	}

	void RotateL(Node* parent)
	{
		Node* subR = parent-&gt;_right;
		Node* subRL = subR-&gt;_left;

		parent-&gt;_right = subRL;
		subR-&gt;_left = parent;

		Node* parentParent = parent-&gt;_parent;

		parent-&gt;_parent = subR;
		if (subRL)
			subRL-&gt;_parent = parent;

		if (_root == parent)
		{
			_root = subR;
			subR-&gt;_parent = nullptr;
		}
		else
		{
			if (parentParent-&gt;_left == parent)
			{
				parentParent-&gt;_left = subR;
			}
			else
			{
				parentParent-&gt;_right = subR;
			}

			subR-&gt;_parent = parentParent;
		}
	}

	void RotateR(Node* parent)
	{
		Node* subL = parent-&gt;_left;
		Node* subLR = subL-&gt;_right;

		parent-&gt;_left = subLR;
		if (subLR)
			subLR-&gt;_parent = parent;

		Node* parentParent = parent-&gt;_parent;

		subL-&gt;_right = parent;
		parent-&gt;_parent = subL;

		if (_root == parent)
		{
			_root = subL;
			subL-&gt;_parent = nullptr;
		}
		else
		{
			if (parentParent-&gt;_left == parent)
			{
				parentParent-&gt;_left = subL;
			}
			else
			{
				parentParent-&gt;_right = subL;
			}

			subL-&gt;_parent = parentParent;
		}
	}

	void InOrder()
	{
		_InOrder(_root);
		cout &lt;&lt; endl;
	}

	void _InOrder(Node* root)
	{
		if (root == nullptr)
			return;

		_InOrder(root-&gt;_left);
		cout &lt;&lt; root-&gt;_kv.first &lt;&lt; " ";
		_InOrder(root-&gt;_right);
	}

	// 根节点-&gt;当前节点这条路径的黑色节点的数量
	bool Check(Node* root, int blacknum, const int refVal)
	{
		if (root == nullptr)
		{
			//cout &lt;&lt; balcknum &lt;&lt; endl;
			if (blacknum != refVal)
			{
				cout &lt;&lt; "存在黑色节点数量不相等的路径" &lt;&lt; endl;
				return false;
			}

			return true;
		}

		if (root-&gt;_col == RED &amp;&amp; root-&gt;_parent-&gt;_col == RED)
		{
			cout &lt;&lt; "有连续的红色节点" &lt;&lt; endl;

			return false;
		}

		if (root-&gt;_col == BLACK)
		{
			++blacknum;
		}

		return Check(root-&gt;_left, blacknum, refVal)
			&amp;&amp; Check(root-&gt;_right, blacknum, refVal);
	}

	bool IsBalance()
	{
		if (_root == nullptr)
			return true;

		if (_root-&gt;_col == RED)
			return false;

		//参考值
		int refVal = 0;
		Node* cur = _root;
		while (cur)
		{
			if (cur-&gt;_col == BLACK)
			{
				++refVal;
			}

			cur = cur-&gt;_left;
		}

		int blacknum = 0;
		return Check(_root, blacknum, refVal);
	}

	int Height()
	{
		return _Height(_root);
	}

	int _Height(Node* root)
	{
		if (root == nullptr)
			return 0;

		int leftHeight = _Height(root-&gt;_left);
		int rightHeight = _Height(root-&gt;_right);

		return leftHeight &gt; rightHeight ? leftHeight + 1 : rightHeight + 1;
	}

	size_t Size()
	{
		return _Size(_root);
	}

	size_t _Size(Node* root)
	{
		if (root == NULL)
			return 0;

		return _Size(root-&gt;_left)
			+ _Size(root-&gt;_right) + 1;
	}

	Node* Find(const K&amp; key)
	{
		Node* cur = _root;
		while (cur)
		{
			if (cur-&gt;_kv.first &lt; key)
			{
				cur = cur-&gt;_right;
			}
			else if (cur-&gt;_kv.first &gt; key)
			{
				cur = cur-&gt;_left;
			}
			else
			{
				return cur;
			}
		}

		return NULL;
	}

private:
	Node* _root = nullptr;
};
</code></pre> 
<h3 id="2.3%20-%3E%20map%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">2.3 -&gt; map的模拟实现</h3> 
<p><span style="color:#6eaad7;">map的底层结构就是红黑树，因此在map中直接封装一棵红黑树，然后将其接口包装下即可。</span></p> 
<pre><code class="hljs">#pragma once
#include"RBTree.h"

namespace fyd
{
	template&lt;class K, class V&gt;
	class map
	{
	public:
		struct MapKeyOfT
		{
			const K&amp; operator()(const pair&lt;K, V&gt;&amp; kv)
			{
				return kv.first;
			}
		};

		// 对类模板取内嵌类型，加typename告诉编译器这里是类型
		typedef typename RBTree&lt;K, pair&lt;K, V&gt;, MapKeyOfT&gt;::iterator iterator;

		iterator begin()
		{
			return _t.begin();
		}

		iterator end()
		{
			return _t.end();
		}

		V&amp; operator[](const K&amp; key)
		{
			pair&lt;iterator, bool&gt; ret = insert(make_pair(key, V()));
			return ret.first-&gt;second;
		}

		pair&lt;iterator, bool&gt; insert(const pair&lt;K, V&gt;&amp; kv)
		{
			return _t.Insert(kv);
		}
		
	private:
		RBTree&lt;K, pair&lt;K, V&gt;, MapKeyOfT&gt; _t;
	};
}
</code></pre> 
<h3 id="2.4%20-%3E%20set%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">2.4 -&gt; set的模拟实现</h3> 
<p><span style="color:#6eaad7;">set的底层为红黑树，因此只需在set内部封装一棵红黑树，即可将该容器实现出来。</span></p> 
<pre><code class="hljs">#pragma once
#include"RBTree.h"

namespace fyd
{
	template&lt;class K&gt;
	class set
	{
	public:
		struct SetKeyOfT
		{
			const K&amp; operator()(const K&amp; key)
			{
				return key;
			}
		};

		typedef typename RBTree&lt;K, K, SetKeyOfT&gt;::iterator iterator;

		iterator begin()
		{
			return _t.begin();
		}

		iterator end()
		{
			return _t.end();
		}

		pair&lt;iterator, bool&gt; insert(const K&amp; key)
		{
			return _t.Insert(key);
		}

	private:
		RBTree&lt;K, K, SetKeyOfT&gt; _t;
	};
}
</code></pre> 
<hr> 
<p></p> 
<p></p> 
<p style="text-align:center;"><span style="color:#9c8ec1;"><strong>感谢各位大佬支持！！！</strong></span></p> 
<p style="text-align:center;"><span style="color:#9c8ec1;"><strong>互三啦！！！</strong></span></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a66b9bffb211a91160ca021604d44ae8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">react启用mobx @decorators装饰器语法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/91a35f45974f04fde6dc122eb9e13283/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Profibus_DP转ModbusTCP网关模块连马保与上位机通讯</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>