<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;航海王：追寻罗杰的编程之路】哈希的应用——位图 | 布隆过滤器 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/8b863c70a6457d892dabda83ef76418a/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;航海王：追寻罗杰的编程之路】哈希的应用——位图 | 布隆过滤器">
  <meta property="og:description" content="目录
1 -&gt; 位图
1.1 -&gt; 位图的概念
1.2 -&gt; 位图的应用
2 -&gt; 布隆过滤器
2.1 -&gt; 布隆过滤器的提出 2.2 -&gt; 布隆过滤器的概念
2.3 -&gt; 布隆过滤器的插入
2.4 -&gt; 布隆过滤器的查找
2.5 -&gt; 布隆过滤器的删除
2.6 -&gt; 布隆过滤器的优点
2.7 -&gt; 布隆过滤器的缺陷
1 -&gt; 位图 1.1 -&gt; 位图的概念 位图的概念：所谓位图，就是用每一位来存放某种状态，适用于海量数据，数据无重复的场景。通常是用来判断某个数据是否存在的。
下面是一道面试题：
给40亿个不重复的无符号整数，没排过序。给一个无符号整数，如何快速判断一个数是否在这40亿个数中。
遍历，时间复杂度O(N)。排序(O(NlogN))，利用二分查找：logN。位图解决：数据是否在给定的整形数据中，结果是在或者不在，刚好是两种状态，那么可以使用一个二进制比特位来代表数据是否存在的信息，如果二进制比特位为1，代表存在，为0代表不存在。比如： #define _CRT_SECURE_NO_WARNINGS 1 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; class bitset { public: bitset(size_t bitCount) : _bit((bitCount &gt;&gt; 5) &#43; 1), _bitCount(bitCount) {} // 将which比特位置1 void set(size_t which) { if (which &gt; _bitCount) return; size_t index = (which &gt;&gt; 5); size_t pos = which % 32; _bit[index] |= (1 &lt;&lt; pos); } // 将which比特位置0 void reset(size_t which) { if (which &gt; _bitCount) return; size_t index = (which &gt;&gt; 5); size_t pos = which % 32; _bit[index] &amp;= ~(1 &lt;&lt; pos); } // 检测位图中which是否为1 bool test(size_t which) { if (which &gt; _bitCount) return false; size_t index = (which &gt;&gt; 5); size_t pos = which % 32; return _bit[index] &amp; (1 &lt;&lt; pos); } // 获取位图中比特位的总个数 size_t size()const { return _bitCount; } // 位图中比特为1的个数 size_t Count()const { int bitCnttable[256] = { 0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8 }; size_t size = _bit.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-14T20:19:13+08:00">
    <meta property="article:modified_time" content="2024-07-14T20:19:13+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;航海王：追寻罗杰的编程之路】哈希的应用——位图 | 布隆过滤器</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><span style="color:#1c7331;"><strong>目录</strong></span></p> 
<p id="1%20-%3E%20%E4%BD%8D%E5%9B%BE-toc" style="margin-left:0px;"><strong><a href="#1%20-%3E%20%E4%BD%8D%E5%9B%BE" rel="nofollow"><span style="color:#1c7331;">1 -&gt; 位图</span></a></strong></p> 
<p id="1.1%20-%3E%20%E4%BD%8D%E5%9B%BE%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><strong><a href="#1.1%20-%3E%20%E4%BD%8D%E5%9B%BE%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow"><span style="color:#1c7331;">1.1 -&gt; 位图的概念</span></a></strong></p> 
<p id="1.2%20-%3E%20%E4%BD%8D%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8-toc" style="margin-left:40px;"><strong><a href="#1.2%20-%3E%20%E4%BD%8D%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8" rel="nofollow"><span style="color:#1c7331;">1.2 -&gt; 位图的应用</span></a></strong></p> 
<p id="2%20-%3E%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8-toc" style="margin-left:0px;"><strong><a href="#2%20-%3E%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8" rel="nofollow"><span style="color:#1c7331;">2 -&gt; 布隆过滤器</span></a></strong></p> 
<p id="2.1%20-%3E%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E6%8F%90%E5%87%BA%C2%A0-toc" style="margin-left:40px;"><strong><a href="#2.1%20-%3E%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E6%8F%90%E5%87%BA%C2%A0" rel="nofollow"><span style="color:#1c7331;">2.1 -&gt; 布隆过滤器的提出 </span></a></strong></p> 
<p id="2.2%20-%3E%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><strong><a href="#2.2%20-%3E%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow"><span style="color:#1c7331;">2.2 -&gt; 布隆过滤器的概念</span></a></strong></p> 
<p id="2.3%20-%3E%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E6%8F%92%E5%85%A5-toc" style="margin-left:40px;"><strong><a href="#2.3%20-%3E%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E6%8F%92%E5%85%A5" rel="nofollow"><span style="color:#1c7331;">2.3 -&gt; 布隆过滤器的插入</span></a></strong></p> 
<p id="2.4%20-%3E%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E6%9F%A5%E6%89%BE-toc" style="margin-left:40px;"><strong><a href="#2.4%20-%3E%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E6%9F%A5%E6%89%BE" rel="nofollow"><span style="color:#1c7331;">2.4 -&gt; 布隆过滤器的查找</span></a></strong></p> 
<p id="2.5%20-%3E%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%88%A0%E9%99%A4-toc" style="margin-left:40px;"><strong><a href="#2.5%20-%3E%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%88%A0%E9%99%A4" rel="nofollow"><span style="color:#1c7331;">2.5 -&gt; 布隆过滤器的删除</span></a></strong></p> 
<p id="2.6%20-%3E%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E4%BC%98%E7%82%B9-toc" style="margin-left:40px;"><strong><a href="#2.6%20-%3E%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E4%BC%98%E7%82%B9" rel="nofollow"><span style="color:#1c7331;">2.6 -&gt; 布隆过滤器的优点</span></a></strong></p> 
<p id="2.7%20-%3E%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E7%BC%BA%E9%99%B7-toc" style="margin-left:40px;"><strong><a href="#2.7%20-%3E%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E7%BC%BA%E9%99%B7" rel="nofollow"><span style="color:#1c7331;">2.7 -&gt; 布隆过滤器的缺陷</span></a></strong></p> 
<hr id="hr-toc"> 
<p class="img-center"><img alt="" height="552" src="https://images2.imgbox.com/32/c4/uyFQzTQp_o.png" width="558"></p> 
<h2 id="1%20-%3E%20%E4%BD%8D%E5%9B%BE">1 -&gt; 位图</h2> 
<h3 id="1.1%20-%3E%20%E4%BD%8D%E5%9B%BE%E7%9A%84%E6%A6%82%E5%BF%B5">1.1 -&gt; 位图的概念</h3> 
<p><span style="color:#6eaad7;"><strong>位图的概念：所谓位图，就是用每一位来存放某种状态，适用于海量数据，数据无重复的场景。通常是用来判断某个数据是否存在的。</strong></span></p> 
<p><span style="color:#ed7976;"><strong>下面是一道面试题：</strong></span></p> 
<p><strong><span style="color:#6eaad7;">给40亿个不重复的无符号整数，没排过序。给一个无符号整数，如何快速判断一个数是否在这40亿个数中。</span></strong></p> 
<ol><li><span style="color:#6eaad7;">遍历，时间复杂度O(N)。</span></li><li><span style="color:#6eaad7;">排序(O(NlogN))，利用二分查找：logN。</span></li><li><span style="color:#6eaad7;">位图解决：数据是否在给定的整形数据中，结果是在或者不在，刚好是两种状态，那么可以使用一个二进制比特位来代表数据是否存在的信息，如果二进制比特位为1，代表存在，为0代表不存在。比如：</span></li></ol> 
<p class="img-center"><img alt="" height="435" src="https://images2.imgbox.com/12/24/DoyYu2nh_o.png" width="1167"></p> 
<pre><code class="hljs">#define _CRT_SECURE_NO_WARNINGS 1

#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

class bitset
{
public:
	bitset(size_t bitCount)
		: _bit((bitCount &gt;&gt; 5) + 1), _bitCount(bitCount)
	{}

	// 将which比特位置1
	void set(size_t which)
	{
		if (which &gt; _bitCount)
			return;

		size_t index = (which &gt;&gt; 5);
		size_t pos = which % 32;
		_bit[index] |= (1 &lt;&lt; pos);
	}

	// 将which比特位置0
	void reset(size_t which)
	{
		if (which &gt; _bitCount)
			return;

		size_t index = (which &gt;&gt; 5);
		size_t pos = which % 32;
		_bit[index] &amp;= ~(1 &lt;&lt; pos);
	}

	// 检测位图中which是否为1
	bool test(size_t which)
	{
		if (which &gt; _bitCount)
			return false;

		size_t index = (which &gt;&gt; 5);
		size_t pos = which % 32;

		return _bit[index] &amp; (1 &lt;&lt; pos);
	}
	// 获取位图中比特位的总个数
	size_t size()const 
	{ 
		return _bitCount; 
	}

	// 位图中比特为1的个数
	size_t Count()const
	{
		int bitCnttable[256] = {
   0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2,
   3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3,
   3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3,
   4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4,
   3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5,
   6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4,
   4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5,
   6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5,
   3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3,
   4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6,
   6, 7, 6, 7, 7, 8 };

		size_t size = _bit.size();
		size_t count = 0;
		for (size_t i = 0; i &lt; size; ++i)
		{
			int value = _bit[i];
			int j = 0;
			while (j &lt; sizeof(_bit[0]))
			{
				unsigned char c = value;
				count += bitCnttable[c];
				++j;
				value &gt;&gt;= 8;
			}
		}
		return count;
	}

private:
	vector&lt;int&gt; _bit;
	size_t _bitCount;
};</code></pre> 
<h3 id="1.2%20-%3E%20%E4%BD%8D%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8">1.2 -&gt; 位图的应用</h3> 
<ol><li><span style="color:#6eaad7;">快速查找某个数据是否在一个集合中。</span></li><li><span style="color:#6eaad7;">排序 + 去重。</span></li><li><span style="color:#6eaad7;">求两个集合的交集、并集等。</span></li><li><span style="color:#6eaad7;">操作系统中磁盘块标记。</span></li></ol> 
<h2 id="2%20-%3E%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8">2 -&gt; 布隆过滤器</h2> 
<h3 id="2.1%20-%3E%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E6%8F%90%E5%87%BA%C2%A0">2.1 -&gt; 布隆过滤器的提出 </h3> 
<p><span style="color:#6eaad7;">我们在使用新闻客户端看新闻时，它会不停地给我们推荐新的内容，它每次推荐时要去重，去掉那些已经看过的内容。那么问题来了，新闻客户端推荐系统是如何实现推送去重的呢？用服务器记录了用户看过的所有历史记录，当推荐系统推荐新闻时会从每个用户的历史记录里进行筛选，过滤掉那些已经存在的记录。如何快速查找呢？</span></p> 
<ol><li><span style="color:#6eaad7;">用哈希表存储用户记录，缺点：浪费空间。</span></li><li><span style="color:#6eaad7;">用位图存储用户记录，缺点：位图一般只能处理整形，如果内容编号是字符串，就无法处理了。</span></li><li><span style="color:#6eaad7;">将哈希与位图结合，即布隆过滤器。</span></li></ol> 
<h3 id="2.2%20-%3E%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E6%A6%82%E5%BF%B5">2.2 -&gt; 布隆过滤器的概念</h3> 
<p><span style="color:#6eaad7;"><strong>布隆过滤器</strong>是由布隆(Burton Howard Bloom)在1970年提出的一种紧凑型的、比较巧妙的<strong>概率型数据结构</strong>，特点是<strong>高效地插入和查询，可以用来告诉你“某样东西一定不存在或者可能存在”</strong>，它是用多个哈希函数，将一个数据映射到位图结构中。此种方法<strong>不仅可以提升查询效率，也可以节省大量的内存空间。</strong></span></p> 
<p class="img-center"><img alt="" height="373" src="https://images2.imgbox.com/4a/6a/PxLchk8l_o.png" width="1200"></p> 
<h3 id="2.3%20-%3E%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E6%8F%92%E5%85%A5">2.3 -&gt; 布隆过滤器的插入</h3> 
<p class="img-center"><img alt="" height="240" src="https://images2.imgbox.com/70/e5/NNaFq0L6_o.png" width="1162"></p> 
<p><span style="color:#6eaad7;"><strong>向布隆过滤器中插入：“baidu”。</strong></span></p> 
<p class="img-center"><img alt="" height="387" src="https://images2.imgbox.com/b6/4e/xIgfB9C4_o.png" width="853"></p> 
<p class="img-center"><img alt="" height="441" src="https://images2.imgbox.com/1e/9f/CLL9530E_o.png" width="840"></p> 
<pre><code class="hljs">#define _CRT_SECURE_NO_WARNINGS 1

#include &lt;iostream&gt;
using namespace std;

struct BKDRHash
{
	size_t operator()(const string&amp; s)
	{
		// BKDR
		size_t value = 0;
		for (auto ch : s)
		{
			value *= 31;
			value += ch;
		}

		return value;
	}
};

struct APHash
{
	size_t operator()(const string&amp; s)
	{
		size_t hash = 0;
		for (long i = 0; i &lt; s.size(); i++)
		{
			if ((i &amp; 1) == 0)
			{
				hash ^= ((hash &lt;&lt; 7) ^ s[i] ^ (hash &gt;&gt; 3));
			}
			else
			{
				hash ^= (~((hash &lt;&lt; 11) ^ s[i] ^ (hash &gt;&gt; 5)));
			}
		}

		return hash;
	}
};

struct DJBHash
{
	size_t operator()(const string&amp; s)
	{
		size_t hash = 5381;
		for (auto ch : s)
		{
			hash += (hash &lt;&lt; 5) + ch;
		}

		return hash;
	}
};

template&lt;size_t N,
	size_t X = 5,
	class K = string,
	class HashFunc1 = BKDRHash,
	class HashFunc2 = APHash,
	class HashFunc3 = DJBHash&gt;
	class BloomFilter
{

public:
	void Set(const K&amp; key)
	{
		size_t len = X * N;
		size_t index1 = HashFunc1()(key) % len;
		size_t index2 = HashFunc2()(key) % len;
		size_t index3 = HashFunc3()(key) % len;

		/* cout &lt;&lt; index1 &lt;&lt; endl;
		cout &lt;&lt; index2 &lt;&lt; endl;
		cout &lt;&lt; index3 &lt;&lt; endl&lt;&lt;endl;*/

		_bs.set(index1);
		_bs.set(index2);
		_bs.set(index3);
	}

	bool Test(const K&amp; key)
	{
		size_t len = X * N;
		size_t index1 = HashFunc1()(key) % len;
		if (_bs.test(index1) == false)
			return false;

		size_t index2 = HashFunc2()(key) % len;
		if (_bs.test(index2) == false)
			return false;

		size_t index3 = HashFunc3()(key) % len;
		if (_bs.test(index3) == false)
			return false;

		return true; // 存在误判的
	}

	// 不支持删除，删除可能会影响其他值。
	void Reset(const K&amp; key);

private:
	bitset&lt;X* N&gt; _bs;
};</code></pre> 
<h3 id="2.4%20-%3E%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E6%9F%A5%E6%89%BE">2.4 -&gt; 布隆过滤器的查找</h3> 
<p><span style="color:#6eaad7;">布隆过滤器的思想是将一个元素用多个哈希函数映射到一个位图中，因此被映射到的位置的比特位一定是1。所以可以按照以下方式进行查找：<strong>分别计算每个哈希值对应的比特位置存储的是否为0，只要有一个为0，代表该元素一定不在哈希表中，否则可能在哈希表中。</strong></span></p> 
<p><span style="color:#ed7976;"><strong>注意：布隆过滤器如果说某个元素不存在时，该元素一定不存在，如果该元素存在时，该元素可能存在，因为有些哈希函数存在一定的误判。</strong></span></p> 
<p><span style="color:#6eaad7;">比如：在布隆过滤器中查找“alibaba”时，假设3个哈希函数计算的哈希值为：1、3、7，刚好和其他元素的比特位重叠，此时布隆过滤器告诉该元素存在，但实际该元素是不存在的。</span></p> 
<h3 id="2.5%20-%3E%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%88%A0%E9%99%A4">2.5 -&gt; 布隆过滤器的删除</h3> 
<p><span style="color:#6eaad7;"><strong>布隆过滤器不能直接支持删除工作，因为在删除一个元素时，可能会影响其他元素。</strong></span></p> 
<p><span style="color:#6eaad7;">比如：删除上图中的“tencent”元素，如果直接将该元素所对应的二进制比特位置0，“baidu”元素也被删除了。因为这两个元素在多个哈希函数计算出的比特位上刚好有重叠。</span></p> 
<p><span style="color:#6eaad7;">一种支持删除的方法：将布隆过滤器中的每个比特位扩展成一个小的计数器，插入元素时给k个计数器(k个哈希函数计算出的哈希地址)加一，删除元素时，给k个计数器减一，通过多占用几倍存储空间的代价来增加删除操作。</span></p> 
<p><span style="color:#6eaad7;">缺陷：</span></p> 
<ol><li><span style="color:#6eaad7;">无法确认元素是否真正在布隆过滤器中。</span></li><li><span style="color:#6eaad7;">存在计数回绕。</span></li></ol> 
<h3 id="2.6%20-%3E%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E4%BC%98%E7%82%B9">2.6 -&gt; 布隆过滤器的优点</h3> 
<ol><li><span style="color:#6eaad7;">增加和查询元素的时间复杂度为O(k)，(k为哈希函数的个数，一般比较小)，与数据量大小无关。</span></li><li><span style="color:#6eaad7;">哈希函数相互之间没有关系，方便硬件并行运算。</span></li><li><span style="color:#6eaad7;">布隆过滤器不需要存储元素本身，在某些对保密要求比较严格的场合有很大的优势。</span></li><li><span style="color:#6eaad7;">在能够承受一定的误判时，布隆过滤器比其他数据结构有很大的空间优势。</span></li><li><span style="color:#6eaad7;">数据量很大时，布隆过滤器可以表示全集，其他数据结构不能。</span></li><li><span style="color:#6eaad7;">使用同一组散列函数的布隆过滤器可以进行交、并、差运算。</span></li></ol> 
<h3 id="2.7%20-%3E%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E7%BC%BA%E9%99%B7">2.7 -&gt; 布隆过滤器的缺陷</h3> 
<ol><li><span style="color:#6eaad7;">有误判率，即存在假阳性(False Position)，即不能准确判断元素是否在集合中(补救方法：再建立一个白名单，存储可能误判的数据)。</span></li><li><span style="color:#6eaad7;">不能获取元素本身。</span></li><li><span style="color:#6eaad7;">一般情况下不能从布隆过滤器中删除元素。</span></li><li><span style="color:#6eaad7;">如果采用计数方式删除，可能会存在计数回绕问题。</span></li></ol> 
<hr> 
<p></p> 
<p></p> 
<p style="text-align:center;"><span style="color:#1c7892;"><strong>感谢各位大佬支持！！！</strong></span></p> 
<p style="text-align:center;"><span style="color:#1c7892;"><strong>互三啦！！！</strong></span></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e3112bd7b1520ff58455b85501aafa7c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Docker Compose部署Kafka集群并在宿主机Windows连接开发</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/34a3fa4e16be33f026237a1b47ba4728/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Datawhale AI 夏令营 学习笔记——机器学习竞赛——Task2</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>