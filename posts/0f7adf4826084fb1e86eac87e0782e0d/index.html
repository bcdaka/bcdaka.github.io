<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>RabbitMQ-消费者确认机制 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/0f7adf4826084fb1e86eac87e0782e0d/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="RabbitMQ-消费者确认机制">
  <meta property="og:description" content=" 1、确认模式 none：不做任何处理，消息投递到消费者了之后，立即返回ACK，并且从MQ将消息删除，非常不安全，不建议使用。manual：手动模式，需要在业务中调用api，ack或者reject。auto：自动模式，SpringAMQP利用AOP对我们的消息处理做了环绕增强，当业务正常执行时返回ACK，执行异常时，根据异常的情况返回不同的结果： 如果是业务异常，会自动返回nack，nack会再次投递MQ消息。如果是消息处理或校验异常，自动返回reject，拒绝之后不再投递MQ，删除MQ中的消息。一般是以错误的消息，就会这么错里 2、yml文件配置 spring: rabbitmq: listener: simple: acknowledge-mode: auto #开启自动模式 3、重试机制 消息失败之后会重新入队，然后再次异常，再次入队，无限循环，这会导致mq消息处理飙升，带来不必要的压力。为了缓解这种压力，利用Spring的retry机制，在消费者出现异常的情况下，利用本地重试，重试次数用完之后，再进行消息的投递或者消息的拒绝。
yml文件配置：
spring: rabbitmq: listener: simple: retry: # 是否启用 enabled: true # 初始时间间隔 initial-interval: 1000ms # 下次失败的等待时长的倍数 multiplier: 1 # 最大尝试次数 max-attempts: 3 # 无状态 stateless: true 开启重试之后，当重试次数耗尽的时候，如果消息依然失败，则需要调用MessageRecoverer接口来处理，这个接口有三种实现：
RejectAndDontRequeueRecoverer：重试耗尽，直接reject，丢弃消息。默认方式。ImmediateRequeueMessageRecoverer：重试耗尽后，返回nack，消息重新入队。RepublishMessageRecoverer：重试耗尽后，将失败消息投递到指定的交换机。然后交给人工处理。 ">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-01-20T17:57:14+08:00">
    <meta property="article:modified_time" content="2024-01-20T17:57:14+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">RabbitMQ-消费者确认机制</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>1、确认模式</h3> 
<blockquote> 
 <ul><li>none：不做任何处理，消息投递到消费者了之后，立即返回ACK，并且从MQ将消息删除，非常不安全，不建议使用。</li><li>manual：手动模式，需要在业务中调用api，ack或者reject。</li><li>auto：自动模式，SpringAMQP利用AOP对我们的消息处理做了环绕增强，当业务正常执行时返回ACK，执行异常时，根据异常的情况返回不同的结果： 
   <ul><li>如果是业务异常，会自动返回nack，nack会再次投递MQ消息。</li><li>如果是消息处理或校验异常，自动返回reject，拒绝之后不再投递MQ，删除MQ中的消息。一般是以错误的消息，就会这么错里</li></ul></li></ul> 
</blockquote> 
<h3>2、yml文件配置 </h3> 
<pre><code class="language-XML">spring:
  rabbitmq:
    listener:
      simple:
        acknowledge-mode: auto #开启自动模式</code></pre> 
<h3>3、重试机制</h3> 
<p>消息失败之后会重新入队，然后再次异常，再次入队，无限循环，这会导致mq消息处理飙升，带来不必要的压力。为了缓解这种压力，利用Spring的retry机制，在消费者出现异常的情况下，利用本地重试，重试次数用完之后，再进行消息的投递或者消息的拒绝。</p> 
<p>yml文件配置：</p> 
<pre><code class="language-XML">spring:
  rabbitmq:
    listener:
      simple:
        retry:
          # 是否启用
          enabled: true
          # 初始时间间隔
          initial-interval: 1000ms
          # 下次失败的等待时长的倍数
          multiplier: 1
          # 最大尝试次数
          max-attempts: 3
          # 无状态
          stateless: true</code></pre> 
<p>开启重试之后，当重试次数耗尽的时候，如果消息依然失败，则需要调用MessageRecoverer接口来处理，这个接口有三种实现：</p> 
<blockquote> 
 <ul><li>RejectAndDontRequeueRecoverer：重试耗尽，直接reject，丢弃消息。默认方式。</li><li>ImmediateRequeueMessageRecoverer：重试耗尽后，返回nack，消息重新入队。</li><li>RepublishMessageRecoverer：重试耗尽后，将失败消息投递到指定的交换机。然后交给人工处理。</li></ul> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/197e115856fb6a4d5938901f2483e94b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">关于Twitch上的AI虚拟主播 neuro-sama</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c7c883ae88ec374a442b3752521f6dc1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">前端VUE后端JAVA，SM2加解密，一篇解决你的问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>