<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构奇妙旅程之七大排序 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/31afa6b6cf60bb491d1b28f4377b0199/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构奇妙旅程之七大排序">
  <meta property="og:description" content="꒰˃͈꒵˂͈꒱ write in front ꒰˃͈꒵˂͈꒱
ʕ̯•͡˔•̯᷅ʔ大家好，我是xiaoxie.希望你看完之后,有不足之处请多多谅解，让我们一起共同进步૮₍❀ᴗ͈ . ᴗ͈ აxiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客
本文由xiaoxieʕ̯•͡˔•̯᷅ʔ 原创 CSDN 如需转载还请通知˶⍤⃝˶
个人主页：xiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客
系列专栏：xiaoxie的JAVA系列专栏——CSDN博客●&#39;ᴗ&#39;σσணღ*
我的目标:&#34;团团等我💪( ◡̀_◡́ ҂)&#34; ( ⸝⸝⸝›ᴥ‹⸝⸝⸝ )欢迎各位→点赞👍 &#43; 收藏⭐️ &#43; 留言📝​&#43;关注（互三必回）!
一.排序的概念 排序的概念 排序 ：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。 稳定性 ：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持 不变，即在原序列中， r[i]=r[j] ，且 r[i] 在 r[j] 之前，而在排序后的序列中， r[i] 仍在 r[j] 之前，则称这种排序算法是稳 定的；否则称为不稳定的。 内部排序 ：数据元素全部放在内存中的排序。 外部排序 ：数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。 二.插入排序 1.直接插入排序 直接插入排序是一种简单的插入排序法，其基本思想是： 把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到 一个新的有序序列 。实际中我们玩扑克牌时，就用了插入排序的思想。 1.过程 假设我们有一个数组array{15，87，63，5，98，23，1，82，10} ；我们如果使用直接插入排序的过程如下：
原始： 15 87 63 5 98 23 1 82 10
第一趟： 15 87 63 5 98 23 1 82 10">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-01-30T10:10:09+08:00">
    <meta property="article:modified_time" content="2024-01-30T10:10:09+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构奇妙旅程之七大排序</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>꒰˃͈꒵˂͈꒱ write in front ꒰˃͈꒵˂͈꒱<br> ʕ̯•͡˔•̯᷅ʔ大家好，我是xiaoxie.希望你看完之后,有不足之处请多多谅解，让我们一起共同进步૮₍❀ᴗ͈ . ᴗ͈ ა<a href="https://blog.csdn.net/xiaoxie8023?spm=1000.2115.3001.5343" title="xiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客">xiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客</a><br> 本文由xiaoxieʕ̯•͡˔•̯᷅ʔ 原创 CSDN 如需转载还请通知˶⍤⃝˶<br><a href="https://so.csdn.net/so/search?q=%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5&amp;spm=1001.2101.3001.7020" title="个人主页">个人主页</a>：<a href="https://blog.csdn.net/xiaoxie8023/article/details/134417887?spm=1001.2014.3001.5501" title="xiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客">xiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客</a><br> 系列专栏：<a href="https://blog.csdn.net/xiaoxie8023/category_12482318.html?spm=1001.2014.3001.5482" title="xiaoxie的JAVA系列专栏——CSDN博客●'ᴗ'σσணღ*">xiaoxie的JAVA系列专栏——CSDN博客●'ᴗ'σσணღ*</a><br><span style="color:#fe2c24;"><strong>我的目标:"团团等我💪( ◡̀_◡́ ҂)" </strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>( ⸝⸝⸝›ᴥ‹⸝⸝⸝ )欢迎各位→点赞👍 + 收藏⭐️ + 留言📝​+关注（互三必回）!</strong></span></p> 
</blockquote> 
<p><img alt="" height="1080" src="https://images2.imgbox.com/b6/e6/NT6LsRwd_o.png" width="1080"> </p> 
<h2>一.排序的概念</h2> 
<div> 
 <span style="color:#333333;"><strong> </strong></span> 
 <span style="color:#333333;"><strong>排序的概念 </strong></span> 
</div> 
<div> 
 <span style="color:#333333;"><strong>排序</strong></span> 
 <span style="color:#333333;">：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。 </span> 
</div> 
<div> 
 <span style="color:#333333;"><strong>稳定性</strong></span> 
 <span style="color:#333333;">：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持 </span> 
</div> 
<div> 
 <span style="color:#333333;">不变，即在原序列中，</span> 
 <span style="color:#333333;">r[i]=r[j]</span> 
 <span style="color:#333333;">，且</span> 
 <span style="color:#333333;">r[i]</span> 
 <span style="color:#333333;">在</span> 
 <span style="color:#333333;">r[j]</span> 
 <span style="color:#333333;">之前，而在排序后的序列中，</span> 
 <span style="color:#333333;">r[i]</span> 
 <span style="color:#333333;">仍在</span> 
 <span style="color:#333333;">r[j]</span> 
 <span style="color:#333333;">之前，则称这种排序算法是稳 定的；否则称为不稳定的。 </span> 
</div> 
<div> 
 <span style="color:#333333;"><strong>内部排序</strong></span> 
 <span style="color:#333333;">：数据元素全部放在内存中的排序。 </span> 
</div> 
<div> 
 <span style="color:#333333;"><strong>外部排序</strong></span> 
 <span style="color:#333333;">：数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。 </span> 
</div> 
<h2>二.插入排序</h2> 
<h3>1.直接插入排序</h3> 
<div> 
 <span style="color:#333333;">直接插入排序是一种简单的插入排序法，其基本思想是： </span> 
</div> 
<div> 
 <span style="color:#333333;"><strong>把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到 </strong></span> 
 <span style="color:#333333;"><strong>一个新的有序序列 </strong></span> 
 <span style="color:#333333;">。实际中我们玩扑克牌时，就用了插入排序的思想。</span> 
</div> 
<div> 
 <img alt="" height="562" src="https://images2.imgbox.com/63/7d/QyaSKTo2_o.png" width="1200"> 
</div> 
<h4 style="background-color:transparent;">1.过程</h4> 
<p>假设我们有一个数组array{15，87，63，5，98，23，1，82，10} ；我们如果使用直接插入排序的过程如下：</p> 
<p>原始：    15  87  63 5 98 23 1 82 10</p> 
<p>第一趟： <span style="color:#fe2c24;">15</span>  87  63 5 98 23 1 82 10</p> 
<p>第二趟： <span style="color:#fe2c24;">15</span> <span style="color:#fe2c24;"> 87</span>  63 5 98 23 1 82 10</p> 
<p>第三趟：<span style="color:#fe2c24;">15</span> <span style="color:#fe2c24;">  63 </span> <span style="color:#fe2c24;">87</span>  5 98 23 1 82 10</p> 
<p>......</p> 
<p>第n(9)趟:  <span style="color:#fe2c24;">1 5 10 15 23 63 82 87 98</span></p> 
<h4>2.代码 </h4> 
<p>我们可以把他写为Java代码如下：</p> 
<pre><code class="language-java">public class Sort {
    public static void insertSort(int[] array) {
        insert(array,0, array.length-1);
    }
    private static void insert(int[] array,int start,int end) {
        for (int i = start+1; i &lt;= end; i++) {
            int tmp = array[i];
            int j = i-1;
            for (;j &gt;= start; j--) {
                if(array[j] &gt; tmp) {
                    array[j+1] = array[j];
                }else {
                    break;
                }
            }
            array[j+1] = tmp;
        }
    }
}</code></pre> 
<p>C++版本如下</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Sort {
public:
    static void insertSort(int array[], int size) {
        insert(array, 0, size-1);
    }

private:
    static void insert(int array[], int start, int end) {
        for (int i = start+1; i &lt;= end; i++) {
            int tmp = array[i];
            int j = i-1;
            for (; j &gt;= start; j--) {
                if (array[j] &gt; tmp) {
                    array[j+1] = array[j];
                } else {
                    break;
                }
            }
            array[j+1] = tmp;
        }
    }
};</code></pre> 
<h4 style="background-color:transparent;">3.时间复杂度</h4> 
<p><strong>最好情况下：</strong></p> 
<p>直接插入排序在最好情况下也就是在数据都有序的情况下为<span style="color:#fe2c24;">O（n)</span>。</p> 
<p><strong>最坏情况下：</strong></p> 
<p>直接插入排序的最坏情况也就是在数据为逆序的情况下为<span style="color:#fe2c24;">O（n^2)</span>。</p> 
<h4>4.空间复杂度</h4> 
<p>因为直接插入排序是在本数组中实现的没有借用辅助空间所以为<span style="color:#fe2c24;">O（1）</span>。</p> 
<h4>5.稳定性</h4> 
<p>该算法为<span style="color:#fe2c24;">稳定</span>的</p> 
<p>值得注意的是<strong><span style="color:#fe2c24;">元素集合越接近有序，直接插入排序算法的时间效率越高。</span></strong></p> 
<h3>2. 希尔排序<span style="color:#333333;"><strong>( </strong></span><span style="color:#333333;"><strong>缩小增量排序</strong></span><span style="color:#333333;"><strong> )</strong></span></h3> 
<div> 
 <span style="color:#333333;">希尔排序法又称缩小增量法。希尔排序法的基本思想是：</span> 
 <strong>将待排序的数组按照一定的增量分组，对每个分组进行直接插入排序，然后逐步缩小增量，重复进行分组和直接插入排序的操作，直到增量缩小为1，最后进行最后一次直接插入排序。</strong> 
</div> 
<div></div> 
<h4><strong>1.过程</strong></h4> 
<div> 
 <img alt="" height="1038" src="https://images2.imgbox.com/e1/ee/zBsQ6Ecr_o.png" width="1200"> 
</div> 
<div></div> 
<h4>2.代码</h4> 
<p>java</p> 
<pre><code class="language-java">public class Sort {
  
    public static void shellSort(int[] array) {
        int gap = array.length;
        while (gap &gt; 1) {
            gap /= 2;
            Shell(array,gap);
        }
    }
    private static void Shell(int[] array,int gap) {
        for (int i = gap; i &lt; array.length; i++) {
            int tmp = array[i];
            int j = i-gap;
            for (; j &gt;= 0; j-=gap) {
                if(array[j] &gt; tmp) {
                 array[j+gap] = array[j];
                }else {
                    break;
                }
            }
            array[j+gap] = tmp;
        }
    }
}
</code></pre> 
<p>C++</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void shellSort(int array[], int size) {
    int gap = size;
    while (gap &gt; 1) {
        gap /= 2;
        Shell(array, size, gap);
    }
}

void Shell(int array[], int size, int gap) {
    for (int i = gap; i &lt; size; i++) {
        int tmp = array[i];
        int j = i - gap;
        for (; j &gt;= 0; j -= gap) {
            if (array[j] &gt; tmp) {
                array[j + gap] = array[j];
            } else {
                break;
            }
        }
        array[j + gap] = tmp;
    }
}</code></pre> 
<h4> 3.时间复杂度</h4> 
<div> 
 <span style="color:#333333;">希尔排序的时间复杂度不好计算，因为</span> 
 <span style="color:#333333;">gap</span> 
 <span style="color:#333333;">的取值方法很多，导致很难去计算，因此在不同的书中给出的希尔排序的时间复杂度都不固定</span> 
</div> 
<div> 
 <span style="color:#333333;"><strong>《数据结构</strong></span> 
 <span style="color:#333333;"><strong>(C</strong></span> 
 <span style="color:#333333;"><strong>语言版</strong></span> 
 <span style="color:#333333;"><strong>)</strong></span> 
 <span style="color:#333333;"><strong>》</strong></span> 
 <span style="color:#333333;"><strong>--- </strong></span> 
 <span style="color:#333333;"><strong>严蔚敏 </strong></span> 
</div> 
<div> 
 <img alt="" height="464" src="https://images2.imgbox.com/f1/f6/kYugvBdI_o.png" width="1200"> 
</div> 
<div></div> 
<p><span style="color:#333333;"><strong>《数据结构</strong></span><span style="color:#333333;"><strong>-</strong></span><span style="color:#333333;"><strong>用面向对象方法与</strong></span><span style="color:#333333;"><strong>C++</strong></span><span style="color:#333333;"><strong>描述》</strong></span><span style="color:#333333;"><strong>--- </strong></span><span style="color:#333333;"><strong>殷人昆</strong></span></p> 
<p><img alt="" height="612" src="https://images2.imgbox.com/11/26/x4NIgZiq_o.png" width="1200"> </p> 
<h4> 4.空间复杂度</h4> 
<p>因为希尔排序是直接插入排序的优化所以是在本数组中实现的没有借用辅助空间所以为<span style="color:#fe2c24;"><strong>O（1）</strong></span>。</p> 
<h4>5.稳定性</h4> 
<p><span style="color:#fe2c24;">不稳定 </span></p> 
<h4><span style="color:#0d0016;">6.希尔排序的特性</span></h4> 
<div> 
 <span style="color:#333333;">1. </span> 
 <span style="color:#333333;">希尔排序是对直接插入排序的优化。 </span> 
</div> 
<div> 
 <span style="color:#333333;">2. </span> 
 <span style="color:#333333;">当</span> 
 <span style="color:#333333;">gap &gt; 1</span> 
 <span style="color:#333333;">时都是预排序，目的是让数组更接近于有序。当</span> 
 <span style="color:#333333;">gap == 1</span> 
 <span style="color:#333333;">时，数组已经接近有序的了，这样就会很快。这样整体而言，可以达到优化的效果。</span> 
</div> 
<h2><span style="color:#333333;">三.选择排序</span></h2> 
<h3 style="background-color:transparent;"><span style="color:#333333;">3.直接选择排序</span></h3> 
<div> 
 <span style="color:#333333;">每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完 。</span> 
</div> 
<h4><span style="color:#333333;">1.过程</span></h4> 
<div> 
 <div> 
  <strong><span style="color:#333333;">1.在元素集合</span><span style="color:#333333;">array[i]--array[n-1]</span><span style="color:#333333;">中选择关键码最大</span><span style="color:#333333;">(</span><span style="color:#333333;">小</span><span style="color:#333333;">)</span><span style="color:#333333;">的数据元素 </span></strong> 
 </div> 
 <div> 
  <strong><span style="color:#333333;">2.若它不是这组元素中的最后一个</span><span style="color:#333333;">(</span><span style="color:#333333;">第一个</span><span style="color:#333333;">)</span><span style="color:#333333;">元素，则将它与这组元素中的最后一个（第一个）元素交换 </span></strong> 
 </div> 
 <div> 
  <strong><span style="color:#333333;">3.在剩余的</span><span style="color:#333333;">array[i]--array[n-2]</span><span style="color:#333333;">（</span><span style="color:#333333;">array[i+1]--array[n-1]</span><span style="color:#333333;">）集合中，重复上述步骤，直到集合剩余</span><span style="color:#333333;">1</span><span style="color:#333333;">个元素</span></strong> 
 </div> 
</div> 
<div></div> 
<div> 
 <img alt="" height="1022" src="https://images2.imgbox.com/ca/7a/81A55hbn_o.png" width="1200"> 
</div> 
<h4>2.代码</h4> 
<p>Java</p> 
<pre><code class="language-java">public class Sort {
    public static void selectSort(int[] array) {
        select(array,0, array.length-1);
    }
    private static void select(int[] array,int start,int end) {
        for (int i = 0; i &lt;= end ; i++) {
            int minIndex = i;
            for (int j = i+1; j &lt;= end ; j++) {
                if(array[j] &lt; array[minIndex]) {
                    minIndex = j;
                }
            }
            swap(array,i,minIndex);
        }
    }
    private static void swap(int[]array,int i,int j) {
        int tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
    }
}</code></pre> 
<div>
  C++ 
</div> 
<div> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
void selectSort(int array[], int size) {
    select(array, 0, size - 1);
}

void select(int array[], int start, int end) {
    for (int i = 0; i &lt;= end; i++) {
        int minIndex = i;
        for (int j = i + 1; j &lt;= end; j++) {
            if (array[j] &lt; array[minIndex]) {
                minIndex = j;
            }
        }
        swap(array, i, minIndex);
    }
}

void swap(int array[], int i, int j) {
    int tmp = array[i];
    array[i] = array[j];
    array[j] = tmp;
}
</code></pre> 
 <h4 style="background-color:transparent;">3.时间复杂度</h4> 
 <p>最好情况和最坏情况都为：<span style="color:#fe2c24;"><strong>O（n^2）</strong></span> 所以不是很推荐使用</p> 
 <h4>4.空间复杂度</h4> 
 <p>因为直接选择排序是在本数组中实现的没有借用辅助空间所以为<strong><span style="color:#fe2c24;">O（1）</span></strong>。</p> 
 <h4 style="background-color:transparent;">5.稳定性</h4> 
 <p><span style="color:#fe2c24;"><strong>不稳定</strong></span></p> 
 <div> 
  <span style="color:#333333;">直接选择排序思考非常好理解，但是效率不是很好。实际中很少使用</span> 
 </div> 
 <h3><span style="color:#333333;">4.堆排序（需要重点掌握）</span></h3> 
 <div> 
  <span style="color:#333333;">堆排序</span> 
  <span style="color:#333333;">(Heapsort)</span> 
  <span style="color:#333333;">是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。它是通过堆来进行选择数据。</span> 
  <span style="color:#fe2c24;"><strong>需要注意的是排升序要建大堆，排降序建小堆</strong></span> 
  <span style="color:#333333;"><strong>。</strong></span> 
 </div> 
 <h4>1.过程</h4> 
 <p><img alt="" height="918" src="https://images2.imgbox.com/67/af/GwDCiYwQ_o.png" width="1200"></p> 
</div> 
<h4>2.代码</h4> 
<p>Java</p> 
<pre><code class="language-java">private static void swap(int[]array,int i,int j) {
        int tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
    }
    public static  void heapSort(int[] array) {
        crateHeap(array);//首先创建大根堆
        int end = array.length-1;
        while (end &gt;= 0) {
           swap(array,0,end);
           siftDown(array,0,end);
           end--;
        }
    }
    // 创建大根堆
    private static void crateHeap(int[] array) {
        for (int parent = (array.length-1-1)/2; parent &gt;= 0; parent--) {
            siftDown(array,parent,array.length);
        }
    }
    // 向下调整
    private static void siftDown(int[] array,int parent,int len) {
        int child = 2*parent+1;
        while (child &lt; len) {
            if(child+1 &lt; len &amp;&amp; array[child] &lt; array[child+1]) {
                child++;
            }
            if(array[child] &gt; array[parent]) {
                swap(array,child,parent);
                parent = child;
                child = 2*parent+1;
            }else {
                break;
            }
        }
    }</code></pre> 
<p>C++</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void swap(int array[], int i, int j) {
    int tmp = array[i];
    array[i] = array[j];
    array[j] = tmp;
}

void heapSort(int array[], int length) {
    createHeap(array, length); // 首先创建大根堆
    int end = length - 1;
    while (end &gt;= 0) {
        swap(array, 0, end);
        siftDown(array, 0, end);
        end--;
    }
}

// 创建大根堆
void createHeap(int array[], int length) {
    for (int parent = (length - 2) / 2; parent &gt;= 0; parent--) {
        siftDown(array, parent, length);
    }
}

// 向下调整
void siftDown(int array[], int parent, int len) {
    int child = 2 * parent + 1;
    while (child &lt; len) {
        if (child + 1 &lt; len &amp;&amp; array[child] &lt; array[child + 1]) {
            child++;
        }
        if (array[child] &gt; array[parent]) {
            swap(array, child, parent);
            parent = child;
            child = 2 * parent + 1;
        } else {
            break;
        }
    }
}
</code></pre> 
<h4> 3.时间复杂度</h4> 
<p> 因为堆是一颗完全二叉树所以他的时间复杂度为：<strong><span style="color:#fe2c24;">O（n*logN)</span></strong><span style="color:#0d0016;">。</span></p> 
<h4 style="background-color:transparent;"><span style="color:#0d0016;">4.空间复杂度</span></h4> 
<p><span style="color:#0d0016;">没有借助辅助空间所以空间复杂度为：</span><strong><span style="color:#fe2c24;">O(1)</span></strong><span style="color:#0d0016;">。</span></p> 
<h4><span style="color:#0d0016;">5.稳定性</span></h4> 
<p><span style="color:#fe2c24;"><strong>不稳定</strong></span></p> 
<h2>四.交换排序</h2> 
<div> 
 <span style="color:#333333;">基本思想：所谓交换，就是根据序列中两个记录键值的比较结果来对换这两个记录在序列中的位置，交换排序的特点是：</span> 
 <span style="color:#fe2c24;"><strong>将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动</strong></span> 
</div> 
<h3>5.冒泡排序</h3> 
<h4 style="background-color:transparent;">1.过程</h4> 
<p><img alt="" height="756" src="https://images2.imgbox.com/5f/d0/UMKP3bv5_o.png" width="1200"></p> 
<h4>2.代码</h4> 
<p>Java</p> 
<pre><code class="language-java"> private static void swap(int[]array,int i,int j) {
        int tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
    }
    public static void bubbleSort(int[] array) {
        //10个元素遍历9趟
        for (int i = 0; i &lt; array.length-1; i++) {
            boolean flag = false;
            for (int j = 0; j &lt; array.length-1-i; j++) {
                if(array[j] &gt; array[j+1]) {
                    swap(array,j,j+1);
                    flag = true;
                }
            }
            //没有交换就证明有序
            if(flag == false) {
                return;
            }
        }
    }</code></pre> 
<p>C++</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void swap(int array[], int i, int j) {
    int tmp = array[i];
    array[i] = array[j];
    array[j] = tmp;
}

void bubbleSort(int array[], int length) {
    // 对于10个元素，遍历9趟
    for (int i = 0; i &lt; length - 1; i++) {
        bool flag = false;
        for (int j = 0; j &lt; length - 1 - i; j++) {
            if (array[j] &gt; array[j + 1]) {
                swap(array, j, j + 1);
                flag = true;
            }
        }
        // 若没有交换发生，则证明数组已有序
        if (!flag) {
            return;
        }
    }
}</code></pre> 
<h4 style="background-color:transparent;">3.时间复杂度</h4> 
<p><strong>最好情况下：</strong></p> 
<p>冒泡排序在最好情况下也就是在数据都有序的情况下为<span style="color:#fe2c24;">O（n)</span>。</p> 
<p><strong>最坏情况下：</strong></p> 
<p>冒泡排序的最坏情况也就是在数据为逆序的情况下为<span style="color:#fe2c24;">O（n^2)</span>。</p> 
<h4 style="background-color:transparent;">4.空间复杂度</h4> 
<p><span style="color:#0d0016;">没有借助辅助空间所以空间复杂度为：</span><strong><span style="color:#fe2c24;">O(1)</span></strong><span style="color:#0d0016;">。</span></p> 
<h4 style="background-color:transparent;"><span style="color:#0d0016;">5.稳定性</span></h4> 
<p><span style="color:#fe2c24;"><strong>稳定</strong></span></p> 
<h3>6.快速排序（重点掌握）</h3> 
<div> 
 <span style="color:#333333;">快速排序是</span> 
 <span style="color:#333333;">Hoare</span> 
 <span style="color:#333333;">于</span> 
 <span style="color:#333333;">1962</span> 
 <span style="color:#333333;">年提出的一种二叉树结构的交换排序方法，其基本思想为：</span> 
 <span style="color:#333333;"><strong>任取待排序元素序列中的某元 </strong></span> 
 <span style="color:#333333;"><strong>素作为基准值，按照该排序码将待排序集合分割成两子序列，左子序列中所有元素均小于基准值，右子序列中所有</strong></span> 
 <span style="color:#333333;"><strong>元素均大于基准值，然后最左右子序列重复该过程，直到所有元素都排列在相应位置上为止</strong></span> 
 <span style="color:#333333;">。 </span> 
</div> 
<div> 
 <span style="color:#333333;">因为根据划分基准值的方法不同其过程也不一样，一般有Hoare法，挖坑法（常用）来划分基准值</span> 
</div> 
<h4><span style="color:#333333;">1.1Hoare法过程</span></h4> 
<p><img alt="" height="934" src="https://images2.imgbox.com/33/3a/GlWz686c_o.png" width="1200"></p> 
<div>
  需要注意的是快速排序需要进行优化，防止出现像{1，2，3，4，5，6，7，8，9}这样的情况如果出现这种情况，二叉树会变成一颗斜树，降低排序速率这时候我们需要使用1 
 <span style="color:#fe2c24;"><strong>.三数取中法选基准值</strong></span> 
</div> 
<div>
  如果 
 <span style="color:#333333;">. </span> 
 <span style="color:#fe2c24;"><strong>递归到小的子区间时，可以考虑使用插入排序 </strong></span>（这里就不优化了感兴趣的可以自己下去实现） 
</div> 
<h4>1.2Hoare法代码</h4> 
<pre><code class="language-java">  private static void swap(int[]array,int i,int j) {
        int tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
    }
    public static void quickSort(int[] array) {
        quick(array,0, array.length-1);
    }

    private static void quick(int[] array,int left,int right) {
        if(right-left &lt;= 1) {
            return;
        }
        //三数取中法
        int index = middleNum(array,left,right);
        swap(array,left,index);
        int pivot = partitionHoare(array,left,right);
        quick(array,left,pivot-1);//递归左边
        quick(array,pivot+1,right);//递归右边
    }
    //三数取中
    private static int middleNum(int[] array,int start,int end) {
        int mid = start+((end-start)&gt;&gt;1);
        if(array[start] &lt;  array[end]) {
            if(array[mid] &gt; array[end]) {
                return end;
            } else if (array[mid] &lt; array[start]) {
                return start;
            }else {
                return mid;
            }
        }else {
            if(array[mid] &lt; array[end]) {
                return end;
            } else if (array[mid] &gt; array[start]) {
                return start;
            }else {
                return mid;
            }
        }
    }
    //获取基准值的位置使用Hoare法
    private static int partitionHoare(int[] array,int left ,int right) {
        int tmp = array[left];//基准值
        int i = left;//记录下来基准值开始的下标
        while (left &lt; right) {
            while (left &lt; right &amp;&amp; array[right] &gt;= tmp) {
                right--;
            }
            while (left &lt; right &amp;&amp; array[left] &lt;= tmp) {
                left++;
            }
            swap(array,left,right);
        }
        swap(array,left,i);
        return left;
    }</code></pre> 
<p>C++版本</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void swap(int array[], int i, int j) {
    int tmp = array[i];
    array[i] = array[j];
    array[j] = tmp;
}

void quickSort(int array[], int length) {
    quick(array, 0, length - 1);
}

void quick(int array[], int left, int right) {
    if (right - left &lt;= 1) {
        return;
    }
    // 三数取中法
    int index = middleNum(array, left, right);
    swap(array, left, index);
    int pivot = partitionHoare(array, left, right);
    quick(array, left, pivot - 1); // 递归左边
    quick(array, pivot + 1, right); // 递归右边
}

// 三数取中
int middleNum(int array[], int start, int end) {
    int mid = start + ((end - start) &gt;&gt; 1);
    if (array[start] &lt; array[end]) {
        if (array[mid] &gt; array[end]) {
            return end;
        } else if (array[mid] &lt; array[start]) {
            return start;
        } else {
            return mid;
        }
    } else {
        if (array[mid] &lt; array[end]) {
            return end;
        } else if (array[mid] &gt; array[start]) {
            return start;
        } else {
            return mid;
        }
    }
}

// 获取基准值的位置使用Hoare法
int partitionHoare(int array[], int left, int right) {
    int tmp = array[left]; // 基准值
    int i = left; // 记录下来基准值开始的下标
    while (left &lt; right) {
        while (left &lt; right &amp;&amp; array[right] &gt;= tmp) {
            right--;
        }
        while (left &lt; right &amp;&amp; array[left] &lt;= tmp) {
            left++;
        }
        swap(array, left, right);
    }
    swap(array, left, i);
    return left;
}</code></pre> 
<h4>2.1挖坑法过程（重点掌握）考试选择题过程一般使用挖坑法</h4> 
<p><img alt="" height="868" src="https://images2.imgbox.com/18/39/VsG2lgCV_o.png" width="1200"></p> 
<h4>2.2 挖坑法代码（重点掌握）</h4> 
<p>Java</p> 
<pre><code class="language-java"> private static void swap(int[]array,int i,int j) {
        int tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
    }
    public static void quickSort(int[] array) {
        quick(array,0, array.length-1);
    }

    private static void quick(int[] array,int left,int right) {
        if(right-left &lt;= 1) {
            return;
        }
        //三数取中法
        int index = middleNum(array,left,right);
        swap(array,left,index);
        int pivot = partition(array,left,right);
        quick(array,left,pivot-1);//递归左边
        quick(array,pivot+1,right);//递归右边
    }
    //三数取中
    private static int middleNum(int[] array,int start,int end) {
        int mid = start+((end-start)&gt;&gt;1);
        if(array[start] &lt;  array[end]) {
            if(array[mid] &gt; array[end]) {
                return end;
            } else if (array[mid] &lt; array[start]) {
                return start;
            }else {
                return mid;
            }
        }else {
            if(array[mid] &lt; array[end]) {
                return end;
            } else if (array[mid] &gt; array[start]) {
                return start;
            }else {
                return mid;
            }
        }
    }
    //获取基准值的位置使用挖坑法
    private static int partition(int[] array,int left ,int right) {
        int tmp = array[left];//记录基准值
        while (left &lt; right) {
            while (left &lt; right &amp;&amp; array[right] &gt;=  tmp) {
                right--;
            }
            array[left] = array[right];
            while (left &lt; right &amp;&amp; array[left] &lt;= tmp) {
                left++;
            }
            array[right] = array[left];
        }
        array[left] = tmp;// 将基准值放入正确位置
        return left;
    }</code></pre> 
<p>C++</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void swap(int array[], int i, int j) {
    int tmp = array[i];
    array[i] = array[j];
    array[j] = tmp;
}

void quickSort(int array[], int length) {
    quick(array, 0, length - 1);
}

void quick(int array[], int left, int right) {
    if (right - left &lt;= 1) {
        return;
    }
    // 三数取中法
    int index = middleNum(array, left, right);
    swap(array, left, index);
    int pivot = partition(array, left, right);
    quick(array, left, pivot - 1); // 递归左边
    quick(array, pivot + 1, right); // 递归右边
}

// 三数取中
int middleNum(int array[], int start, int end) {
    int mid = start + ((end - start) &gt;&gt; 1);
    if (array[start] &lt; array[end]) {
        if (array[mid] &gt; array[end]) {
            return end;
        } else if (array[mid] &lt; array[start]) {
            return start;
        } else {
            return mid;
        }
    } else {
        if (array[mid] &lt; array[end]) {
            return end;
        } else if (array[mid] &gt; array[start]) {
            return start;
        } else {
            return mid;
        }
    }
}

// 获取基准值的位置使用挖坑法
int partition(int array[], int left, int right) {
    int pivot = array[left]; // 基准值
    while (left &lt; right) {
        while (left &lt; right &amp;&amp; array[right] &gt;= pivot) {
            right--;
        }
        array[left] = array[right];

        while (left &lt; right &amp;&amp; array[left] &lt;= pivot) {
            left++;
        }
        array[right] = array[left];
    }
    array[left] = pivot; // 将基准值放入正确位置
    return left;
}

</code></pre> 
<h4>3.时间复杂度</h4> 
<p>最好情况下数据为无序的时候为<span style="color:#fe2c24;"><strong>O(n*logN)</strong></span>。</p> 
<p>最坏情况下数据为有序或者是逆序的时候为<span style="color:#fe2c24;"><strong>O（n^2）</strong></span>。 </p> 
<h4 style="background-color:transparent;">4.空间复杂度</h4> 
<p>在递归调用过程中，需要使用O(log n)的栈空间来存储递归调用的上下文信息<span style="color:#0d0016;">所以空间复杂度为：</span><strong><span style="color:#fe2c24;">O(logN)</span></strong><span style="color:#0d0016;">。</span></p> 
<h4 style="background-color:transparent;">5.稳定性</h4> 
<p><span style="color:#fe2c24;"><strong>不稳定</strong></span></p> 
<h3>7.归并排序（重点掌握）</h3> 
<div> 
 <span style="color:#333333;">归并排序（</span> 
 <span style="color:#333333;">MERGE-SORT</span> 
 <span style="color:#333333;">）是建立在归并操作上的一种有效的排序算法</span> 
 <span style="color:#333333;">,</span> 
 <span style="color:#333333;">该算法是采用分治法（</span> 
 <span style="color:#333333;">Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使 子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</span> 
</div> 
<h4>1.过程</h4> 
<p><img alt="" height="880" src="https://images2.imgbox.com/d1/4c/02hpFEeC_o.png" width="1200"></p> 
<h4>2.代码</h4> 
<p>Java</p> 
<pre><code class="language-java">public static void mergeSort(int[] array) {
        mergeFunc(array,0,array.length-1);
    }
    private static void mergeFunc(int[] array,int left,int right) {
        if(left &gt;= right) {
            return;
        }
        int mid = left + ((right-left) &gt;&gt; 1);
        //开始分解
        mergeFunc(array,left,mid);
        mergeFunc(array, mid+1, right);
        //开始合并
        merge(array,left,right,mid);
    }
    private static void merge(int[] array,int left,int right,int mid) {
        int s1 = left;
        int e1 = mid;
        int s2 = mid+1;
        int e2 = right;
        int[] tmp = new int[right-left+1];//创建一个临时数组来储存数据
        int k = 0;//临时数组下标
        while (s1 &lt;= e1 &amp;&amp; s2 &lt;= e2) {
            if(array[s1] &lt;= array[s2]) {
                tmp[k++] = array[s1++];
            }else {
                tmp[k++] = array[s2++];
            }
        }
        //看那个数组还有数据就拷贝过去
        while (s1 &lt;= e1) {
            tmp[k++] = array[s1++];
        }
        while (s2 &lt;= e2) {
            tmp[k++] = array[s2++];
        }
        //3.拷贝到源数组
        for (int i = 0; i &lt; k; i++) {
            array[i+left] = tmp[i];
        }
    }</code></pre> 
<p>C++</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void mergeSort(int array[], int length) {
    mergeFunc(array, 0, length - 1);
}

void mergeFunc(int array[], int left, int right) {
    if (left &gt;= right) {
        return;
    }
    int mid = left + ((right - left) &gt;&gt; 1);
    // 开始分解
    mergeFunc(array, left, mid);
    mergeFunc(array, mid + 1, right);
    // 开始合并
    merge(array, left, right, mid);
}

void merge(int array[], int left, int right, int mid) {
    int s1 = left;
    int e1 = mid;
    int s2 = mid + 1;
    int e2 = right;
    int tmp[right - left + 1]; // 创建一个临时数组来储存数据
    int k = 0; // 临时数组下标

    while (s1 &lt;= e1 &amp;&amp; s2 &lt;= e2) {
        if (array[s1] &lt;= array[s2]) {
            tmp[k++] = array[s1++];
        } else {
            tmp[k++] = array[s2++];
        }
    }

    // 看那个数组还有数据就拷贝过去
    while (s1 &lt;= e1) {
        tmp[k++] = array[s1++];
    }
    while (s2 &lt;= e2) {
        tmp[k++] = array[s2++];
    }

    // 3.拷贝到源数组
    for (int i = 0; i &lt; k; i++) {
        array[i + left] = tmp[i];
    }
}</code></pre> 
<h4> 3.时间复杂度</h4> 
<p>时间复杂度为<span style="color:#fe2c24;"><strong>O(n*logN)</strong></span>。</p> 
<h4>4.空间复杂度</h4> 
<p>因为需要借助临时数组所以空间复杂度为<span style="color:#fe2c24;"><strong>O（n）</strong></span>。</p> 
<h4>5.稳定性</h4> 
<p><span style="color:#fe2c24;"><strong>稳定</strong></span></p> 
<h2>五.各个排序算法的时间复杂度和空间复杂度以及稳定性总结</h2> 
<p><img alt="" height="752" src="https://images2.imgbox.com/bc/38/Swap9ak2_o.png" width="1200"></p> 
<p>以上就是关于基于比较排序的所以的内容了，如果有帮助到你，创作不易希望可以给博主一个关注，感谢你的阅读，希望能够对你有所帮助 </p> 
<p></p> 
<p> </p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6defee44c42344e7c6628db9e25a273f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python地理空间数据库之geopandas使用详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8b2817baf0984ab4ffd23fbe06e1bfbf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">图灵之旅--ArrayList&amp;顺序表&amp;LinkedList&amp;链表&amp;&amp;栈&amp;&amp;Stack&amp;&amp;队列&amp;&amp;Queue</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>