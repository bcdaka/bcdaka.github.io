<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】穿梭在二叉树的时间隧道：顺序存储的实现 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/00b8ca3afe42d36eb8a9c383cbc1f96a/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】穿梭在二叉树的时间隧道：顺序存储的实现">
  <meta property="og:description" content="专栏引入 哈喽大家好，我是野生的编程萌新，首先感谢大家的观看。数据结构的学习者大多有这样的想法：数据结构很重要，一定要学好，但数据结构比较抽象，有些算法理解起来很困难，学的很累。我想让大家知道的是：数据结构非常有趣，很多算法是智慧的结晶，我希望大家在学习数据结构的过程是一种愉悦的心情感受。因此我开创了《数据结构》专栏，在这里我将把数据结构内容以有趣易懂的方式展现给大家。
1.二叉树的顺序存储结构 之前我们谈过了树的存储结构，并且谈到了顺序存储结构对树这种一对多的关系结构实现起来还是比较困难的。但二叉树是一种特殊的树，由于二叉树的特殊性，使得它可以使用顺序存储结构来实现，二叉树的顺序存储结构就是使用一维数组存储二叉树中的节点，并且节点的存储位置，也就是数组的下标要能体现出来节点之间的逻辑关系，比如：双亲和孩子的关系、左孩子右兄弟的关系等。先来看看完全二叉树的顺序存储，就用下面这棵二叉树为例：
将这棵二叉树存入数组中，相应的下标对应其同样的位置，很多数据结构相关书籍上下标都是将0空置，从1开始存储，其实下标0的位置是否存放数据对堆的实现的难度没有影响，为了节省空间我对下标为0的位置进行了存储，如下图：
这下我们可以看出来完全二叉树的优越性了吧，由于它严格的定义，所以用顺序结构也可以表现出二叉树的结构来，当然对于一般的二叉树，尽管层序编号不能反映出来逻辑关系，但是可以将其按完全二叉树来编号，只不过，把不存在的节点设置为&#34;NULL&#34;而已，就像下面的图中，虚线部分表示不存在：
我们再考虑一种极端的情况：一颗深度为h的右斜树。它只有h个节点，却要分配个存储单元空间，这显然是对存储空间的浪费，如下图所示：
所以，二叉树的顺序存储结构一般只适用于完全二叉树。上一篇中我们提到了堆是一个特殊的完全二叉树，所以这篇我们就以堆为例子来实现二叉树的顺序存储。
2.堆 2.1堆的概念 堆是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子节点的值，称为大顶堆；或者每个结点的值都小于等于其左右孩子结点的值，称为小顶堆。如下图所示：
从堆的定义可以知道：根节点一定是堆中所有结点的最大（小）值 。在上一篇堆二叉树的性质介绍时，有一个性质还没和大家介绍，因为这个性质就仿佛是为堆量身定制的，所以我计划在介绍堆时再介绍它：
如果一棵有n个节点的完全二叉树（其深度为）的节点按层序编号（从第一层到第层，每层从左到右），对任一节点i（1≤i≤n）有：
如果i=1，则节点i是二叉树的根，无双亲；如果i&gt;1,则双亲是节点。如果2i&gt;n，则节点i没有左孩子（节点i为叶子节点），否则其左孩子是节点2i。如果2i&#43;1&gt;n，则节点i没有右孩子；否则其右孩子是节点2i&#43;1。 在这个性质第二、三条，也就是说明下标i与2i和2i&#43;1的双亲子女的关系：双亲结点=（子节点-1）/2。
2.2堆的实现 我们先来定义一下堆的结构：
typedef int HPDataType; typedef struct Heap { HPDataType* a; int size; int capacity; }HP; 2.2.1堆的创建和销毁 堆的创建我们使用顺序存储来实现，所以它的创建和销毁的实现代码和顺序表的实现的相同。首先是堆的创建函数：
void HeapInit(HP* php) { assert(php); php-&gt;a = NULL; php-&gt;size = 0; php-&gt;capacity = 0; } 接着是堆的销毁函数：
void HeapDestroy(HP* php) { assert(php); free(php-&gt;a); php-&gt;a = NULL; php-&gt;size = php-&gt;capacity = 0; } 2.2.2堆的向上调整 一说到调整我们肯定会对两个数据进行交换，我们先来写一个交换函数：
void Swap(HPDataType* p1, HPDataType* p2) { HPDataType tmp = *p1; *p1 = *p2; *p2 = tmp; } 堆的向上调整是将一个元素插入到小堆时，调整堆的结构，使其满足小堆的性质过程。实现堆的向上调整的要先将元素插入到数组的最后一个位置（这一步我们在堆的插入操作中实现）。这时候我们就要比较插入元素和其双亲结点的大小关系，然后做出调整。这里我们可以用循环实现，用循环来实现比用递归实现的好处有：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-05T09:30:10+08:00">
    <meta property="article:modified_time" content="2024-06-05T09:30:10+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】穿梭在二叉树的时间隧道：顺序存储的实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>专栏引入</h2> 
<blockquote> 
 <p>哈喽大家好，我是野生的编程萌新，首先感谢大家的观看。数据结构的学习者大多有这样的想法：数据结构很重要，一定要学好，但数据结构比较抽象，有些算法理解起来很困难，学的很累。我想让大家知道的是：数据结构非常有趣，很多算法是智慧的结晶，我希望大家在学习数据结构的过程是一种愉悦的心情感受。因此我开创了《数据结构》专栏，在这里我将把数据结构内容以有趣易懂的方式展现给大家。</p> 
</blockquote> 
<h2>1.二叉树的顺序存储结构 </h2> 
<p>之前我们谈过了树的存储结构，并且谈到了顺序存储结构对树这种一对多的关系结构实现起来还是比较困难的。但二叉树是一种特殊的树，由于二叉树的特殊性，使得它可以使用顺序存储结构来实现，二叉树的顺序存储结构就是使用一维数组存储二叉树中的节点，并且节点的存储位置，也就是数组的下标要能体现出来节点之间的逻辑关系，比如：双亲和孩子的关系、左孩子右兄弟的关系等。先来看看完全二叉树的顺序存储，就用下面这棵二叉树为例：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/6f/0d/ouJNCjdD_o.png"></p> 
<p>将这棵二叉树存入数组中，相应的下标对应其同样的位置，很多数据结构相关书籍上下标都是将0空置，从1开始存储，其实下标0的位置是否存放数据对堆的实现的难度没有影响，为了节省空间我对下标为0的位置进行了存储，如下图：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/50/eb/e8vVSupt_o.png"></p> 
<p>这下我们可以看出来完全二叉树的优越性了吧，由于它严格的定义，所以用顺序结构也可以表现出二叉树的结构来，当然对于一般的二叉树，尽管层序编号不能反映出来逻辑关系，但是可以将其按完全二叉树来编号，只不过，把不存在的节点设置为"NULL"而已，就像下面的图中，虚线部分表示不存在：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d7/77/IMK2VhSw_o.png"></p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/95/07/OYZWeoxg_o.png"></p> 
<p>我们再考虑一种极端的情况：一颗深度为h的右斜树。它只有h个节点，却要分配<img alt="2^{h}-1" class="mathcode" src="https://images2.imgbox.com/ca/c5/YFpcuzVn_o.png">个存储单元空间，这显然是对存储空间的浪费，如下图所示：</p> 
<p><img alt="" src="https://images2.imgbox.com/59/10/cTtQCmk4_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/02/15/SB7cy9X8_o.png"></p> 
<p> 所以，二叉树的顺序存储结构一般只适用于完全二叉树。上一篇中我们提到了堆是一个特殊的完全二叉树，所以这篇我们就以堆为例子来实现二叉树的顺序存储。</p> 
<h2>2.堆</h2> 
<h3>2.1堆的概念</h3> 
<p><strong>堆是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子节点的值，称为大顶堆；或者每个结点的值都小于等于其左右孩子结点的值，称为小顶堆。</strong>如下图所示：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/86/aa/H3LLrb7Q_o.png"></p> 
<p>从堆的定义可以知道：根节点一定是堆中所有结点的最大（小）值 。在上一篇堆二叉树的性质介绍时，有一个性质还没和大家介绍，因为这个性质就仿佛是为堆量身定制的，所以我计划在介绍堆时再介绍它：</p> 
<p><strong>如果一棵有n个节点的完全二叉树（其深度为<img alt="\left \lfloor \log_{2}n \right \rfloor+1" class="mathcode" src="https://images2.imgbox.com/91/af/fKY3xgaX_o.png">）的节点按层序编号（从第一层到第<img alt="\left \lfloor \log_{2}n \right \rfloor+1" class="mathcode" src="https://images2.imgbox.com/b9/65/zx2qCC1D_o.png">层，每层从左到右），对任一节点i（1≤i≤n）有：</strong></p> 
<ul><li><strong>如果i=1，则节点i是二叉树的根，无双亲；如果i&gt;1,则双亲是节点<img alt="\left \lfloor i/2 \right \rfloor" class="mathcode" src="https://images2.imgbox.com/ed/8f/PtuzbJ1g_o.png">。</strong></li><li><strong>如果2i&gt;n，则节点i没有左孩子（节点i为叶子节点），否则其左孩子是节点2i。</strong></li><li><strong>如果2i+1&gt;n，则节点i没有右孩子；否则其右孩子是节点2i+1。</strong></li></ul> 
<p>在这个性质第二、三条，也就是说明下标i与2i和2i+1的双亲子女的关系：双亲结点=（子节点-1）/2。</p> 
<h3>2.2堆的实现</h3> 
<p>我们先来定义一下堆的结构：</p> 
<pre><code>typedef int HPDataType;
typedef struct Heap
{
	HPDataType* a;
	int size;
	int capacity;
}HP;</code></pre> 
<h4>2.2.1堆的创建和销毁</h4> 
<p>堆的创建我们使用顺序存储来实现，所以它的创建和销毁的实现代码和顺序表的实现的相同。首先是堆的创建函数：</p> 
<pre><code>void HeapInit(HP* php)
{
	assert(php);
    php-&gt;a = NULL;
	php-&gt;size = 0;
	php-&gt;capacity = 0;
}</code></pre> 
<p>接着是堆的销毁函数：</p> 
<pre><code>void HeapDestroy(HP* php)
{
	assert(php);
	free(php-&gt;a);
	php-&gt;a = NULL;
	php-&gt;size = php-&gt;capacity = 0;
}</code></pre> 
<h4>2.2.2堆的向上调整</h4> 
<p>一说到调整我们肯定会对两个数据进行交换，我们先来写一个交换函数：</p> 
<pre><code>void Swap(HPDataType* p1, HPDataType* p2)
{
	HPDataType tmp = *p1;
	*p1 = *p2;
	*p2 = tmp;
}</code></pre> 
<p>堆的向上调整是将一个元素插入到小堆时，调整堆的结构，使其满足小堆的性质过程。实现堆的向上调整的要先将元素插入到数组的最后一个位置（这一步我们在堆的插入操作中实现）。这时候我们就要比较插入元素和其双亲结点的大小关系，然后做出调整。这里我们可以用循环实现，用循环来实现比用递归实现的好处有：</p> 
<ol><li>空间开销：循环实现通常比递归实现需要更少的内存空间。递归函数会在每次调用时创建一个新的函数栈帧，而循环则只使用一个循环体内的局部变量。</li><li>性能：循环实现通常比递归实现具有更高的执行效率。递归函数在每次调用时都需要进行函数调用、参数传递和返回值处理等操作，而循环通过使用迭代变量和循环条件判断来控制流程，避免了递归带来的额外开销。</li></ol> 
<p>首先我们先将这个函数里面的判断条件先写好：</p> 
<pre><code>void AdjustUp(HPDataType* a, int child)
{
	int parent = (child - 1) / 2;
	while ()
	{
		if (a[child] &lt; a[parent])
		{
			Swap(&amp;a[child], &amp;a[parent]);
			child = parent;
			parent = (child - 1) / 2;
		}
		else
		{
			break;
		}
	}
}</code></pre> 
<p>既然我们要用循环来实现，那么使用while()语句的循环条件是什么呢？最坏的情况就是将新插入的节点经过调整变成根节点，那条件是parent≥0吗？parent是不会小于0的，当parent=0时，插入的数据还要接着向上调整交换，此时child变为0，parent=(0-1)/2，我们计算出来的parent时-0.5，但是要取整，所以parent还是0，此时循环还是没结束，会再次进入循环，此时child==parent，经过判断语句会侥幸跳出循环，这样是不严谨的。我们将循环条件设为child大于0就可以完美解决这个问题。此时，这个向上调整的操作完整代码为：</p> 
<pre><code>void AdjustUp(HPDataType* a, int child)
{
	int parent = (child - 1) / 2;
	while (child &gt; 0)
	{
		if (a[child] &lt; a[parent])
		{
			Swap(&amp;a[child], &amp;a[parent]);
			child = parent;
			parent = (child - 1) / 2;
		}
		else
		{
			break;
		}
	}
}</code></pre> 
<h4>2.3堆的插入 </h4> 
<p> 堆的插入操作和顺序表的插入操作相似，其具体步骤为：</p> 
<ol><li>首先，函数开始时先进行一些边界判断，确保堆的指针有效。</li><li>如果堆的当前元素数量等于堆的容量，即堆已满，需要进行动态扩容。这里使用realloc函数对堆的数组进行扩容，新的容量为原来容量的两倍。</li><li>将待插入的元素x放到堆数组的最后一个位置，并将堆的元素数量递增。</li><li>调用AdjustUp函数对刚插入的元素进行向上调整，保持堆的性质。</li></ol> 
<p>我们来实现一下这个操作：</p> 
<pre><code>void HeapPush(HP* php, HPDataType x)
{
	assert(php);
	if (php-&gt;size == php-&gt;capacity)
	{
		int newCapacity = php-&gt;capacity == 0 ? 4 : php-&gt;capacity * 2;
		HPDataType* tmp = (HPDataType*)realloc(php-&gt;a, newCapacity * sizeof(HPDataType));
		if (tmp == NULL)
		{
			perror("realloc fail");
			exit(-1);
		}
		php-&gt;a = tmp;
		php-&gt;capacity = newCapacity;
	}
	php-&gt;a[php-&gt;size] = x;
	php-&gt;size++;
	AdjustUp(php-&gt;a, php-&gt;size - 1);
}</code></pre> 
<h4 style="background-color:transparent;">2.4堆的向下调整</h4> 
<p>堆的向上调整是为了让堆在删除数据时能够保持堆的性质，而堆的向下调整操作是在删除根节点后，为了维护堆的性质而进行的操作。该操作的目的是将新的根节点下沉到合适的位置，使得根节点的值不大于它的左右子节点的值。堆的向下调整具体步骤为：</p> 
<ol><li>初始化子节点的索引child，设为父节点的左孩子节点的索引，即parent*2+1。</li><li>进入一个循环，判断当前节点是否有左孩子节点，如果有则执行循环体。</li><li>在循环体内，先假设左孩子节点的值最小，将child设为左孩子节点的索引。</li><li>检查右孩子节点是否存在，即child+1&lt;size，如果存在且右孩子节点的值小于左孩子节点的值，则将child更新为右孩子节点的索引。</li><li>检查当前节点的值是否大于最小的子节点的值，如果是，则交换当前节点和最小子节点的值，将当前节点的索引设为子节点的索引child，并更新子节点的索引为新的左孩子节点的索引child=parent*2+1。</li><li>如果当前节点的值不大于最小子节点的值，即a[child]&gt;=a[parent]，则跳出循环。</li><li>重复之前的步骤，直到当前节点没有左孩子节点为止。</li></ol> 
<p>我们来具体实现一下这个操作：</p> 
<pre><code>void AdjustDown(int* a, int size, int parent)
{
	int child = parent * 2 + 1;

	while (child &lt; size)
	{
		// 假设左孩子小，如果解设错了，更新一下

		if (child+1 &lt; size &amp;&amp; a[child + 1] &lt; a[child])
		{
			++child;
		}

		if (a[child] &lt; a[parent])
		{
			Swap(&amp;a[child], &amp;a[parent]);
			parent = child;
			child = parent * 2 + 1;
		}
		else
		{
			break;
		}
	}
}</code></pre> 
<h4> 2.5堆的删除</h4> 
<p>堆的删除具体操作步骤为：</p> 
<ol><li>调用Swap函数来交换小堆根节点（php-&gt;a[0]）和最后一个节点（php-&gt;a[php-&gt;size - 1]）的值。这样就将要删除的根节点移到了最后一个位置。</li><li>将小堆的大小减1，即php-&gt;size--，表示删除了一个节点。</li><li>最后，调用AdjustDown函数来对小堆进行向下调整，以维护小堆的性质。这样就完成了小堆的删除操作。</li></ol> 
<p>我们来实现一下这个操作：</p> 
<pre><code>void HeapPop(HP* php)
{
	assert(php);
	assert(php-&gt;size &gt; 0);

	Swap(&amp;php-&gt;a[0], &amp;php-&gt;a[php-&gt;size - 1]);
	php-&gt;size--;

	AdjustDown(php-&gt;a, php-&gt;size, 0);
}</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d4d31e49ff792ce76446dd636a22e477/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">GaussDB如何创建修改数据库和数据表</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/09e2365d7173f13870914299d9dfa60c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JSQLParser用于解析SQL语句并创建抽象语法树(AST)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>