<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;学习】哈希表的底层实现及其在unordered_set与unordered_map中的封装 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/bacfa7bfe6fc816c21ba769ad4ce9ef4/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;学习】哈希表的底层实现及其在unordered_set与unordered_map中的封装">
  <meta property="og:description" content="文章目录 1. unordered系列关联式容器1.1 unordered_map1.2 unordered_set1.3.底层结构 2.哈希2.1哈希概念2.2哈希冲突2.3 哈希函数2.4 哈希冲突解决2.4.1闭散列2.4.1开散列2.5开散列与闭散列比较 3.哈希的模拟实现1. 模板参数列表2. 迭代器的实现3. 增加通过key获取value操作4. 哈希实现总代码： 4.用实现的哈希封装unordered_map与unordered_set前的模板参数的梳理及相关联系的梳理5.unordered_map的封装实现6.unordered_set的封装实现 🎉个人名片： 🐼作者简介：一名乐于分享在学习道路上收获的大二在校生
🙈个人主页🎉：GOTXX
🐼个人WeChat：ILXOXVJE
🐼本文由GOTXX原创，首发CSDN🎉🎉🎉
🐵系列专栏：零基础学习C语言----- 数据结构的学习之路----C&#43;&#43;的学习之路
🐓每日一句：如果没有特别幸运，那就请特别努力！🎉🎉🎉
————————————————
文章简介：
本篇博文主要会涉及到STL关联式容器，unordered系列关联式容器，unordered_set和unordered_map的底层数据结构，哈希表的底层及迭代器实现，以及在其上对unordered_set****和unordered_map的封装。
1. unordered系列关联式容器 在C&#43;&#43;98中，STL提供了底层为红黑树结构的一系列关联式容器，在查询时效率可达到 l o g 2 N log_2 N log2​N，即最差情况下需要比较红黑树的高度次，当树中的节点非常多时，查询效率也不理想。最好的查询是，进行很少的比较次数就能够将元素找到，因此在C&#43;&#43;11中，STL又提供了4个unordered系列的关联式容器，分别为：unordered_map与unordered_set和unordered_multimap与unordered_multiset 这四个容器，他们与红黑树结构的关联式容器使用方式基本类似，只是其底层结构不同。
unordered_map和unordered_set与map与set类似，map与set是有序的，但是unordered系列都不是有序的，但是也不允许出现重复值。unordered_multimap和unordered_multiset与unordered_map和unordered_set类似，unordered_map和unordered_set不允许重复值出现，但是multi系列是允许重复值出现的。只要是前缀带了unordered的就是无序，后缀带了multi的就是允许键值重复。他们在使用方面上与set与map非常类似，这里不作详解。 1.1 unordered_map unordered_map的文档介绍链接: link
文档说明：
unordered_map是存储&lt;key, value&gt;键值对的关联式容器，其允许通过keys快速的索引到与其对应的value。在unordered_map中，键值通常用于惟一地标识元素，而映射值是一个对象，其内容与此键关联。键和映射值的类型可能不同。在内部,unordered_map没有对&lt;kye, value&gt;按照任何特定的顺序排序, 为了能在常数范围内找到key所对应的value，unordered_map将相同哈希值的键值对放在相同的桶中。unordered_map容器通过key访问单个元素要比map快，但它通常在遍历元素子集的范围迭代方面效率较低。unordered_maps实现了直接访问操作符(operator[ ])，它允许使用key作为参数直接访问value。它的迭代器至少是前向迭代器。 1.2 unordered_set unordered_mset的文档介绍链接: link
1.3.底层结构 STL关联式容器中：
set和map的底层数据结构为红黑树，因为map和set要求是自动排序的，红黑树能够实现这一功能，并且各个操作的时间复杂度都较低，而unordered_set和unordered_map的底层数据结构为哈希表，查找时间复杂度为常数级。
2.哈希 2.1哈希概念 顺序结构以及平衡树中，元素 关键码 与其 存储位置 之间没有对应的关系，因此在查找一个元素时，必须要经过关键码的多次比较。顺序查找时间复杂度为O(N)，平衡树中为树的高度，即O( l o g 2 N log_2 N log2​N)，搜索的效率取决于搜索过程中元素的比较次数。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-04T13:32:42+08:00">
    <meta property="article:modified_time" content="2024-04-04T13:32:42+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;学习】哈希表的底层实现及其在unordered_set与unordered_map中的封装</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1_unordered_18" rel="nofollow">1. unordered系列关联式容器</a></li><li><ul><li><ul><li><a href="#11_unordered_map_29" rel="nofollow">1.1 unordered_map</a></li><li><a href="#12_unordered_set_42" rel="nofollow">1.2 unordered_set</a></li><li><a href="#13_48" rel="nofollow">1.3.底层结构</a></li></ul> 
  </li></ul> 
  </li><li><a href="#2_56" rel="nofollow">2.哈希</a></li><li><ul><li><ul><li><a href="#21_57" rel="nofollow">2.1哈希概念</a></li><li><a href="#22_79" rel="nofollow">2.2哈希冲突</a></li><li><a href="#23__85" rel="nofollow">2.3 哈希函数</a></li><li><a href="#24__114" rel="nofollow">2.4 哈希冲突解决</a></li><li><ul><li><a href="#241_117" rel="nofollow">2.4.1闭散列</a></li><li><a href="#241_153" rel="nofollow">2.4.1开散列</a></li><li><a href="#25_287" rel="nofollow">2.5开散列与闭散列比较</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#3_291" rel="nofollow">3.哈希的模拟实现</a></li><li><ul><li><ul><li><a href="#1__293" rel="nofollow">1. 模板参数列表</a></li><li><a href="#2__303" rel="nofollow">2. 迭代器的实现</a></li><li><a href="#3_keyvalue_383" rel="nofollow">3. 增加通过key获取value操作</a></li><li><a href="#4__406" rel="nofollow">4. 哈希实现总代码：</a></li></ul> 
  </li></ul> 
  </li><li><a href="#4unordered_mapunordered_set_691" rel="nofollow">4.用实现的哈希封装unordered_map与unordered_set前的模板参数的梳理及相关联系的梳理</a></li><li><a href="#5unordered_map_701" rel="nofollow">5.unordered_map的封装实现</a></li><li><a href="#6unordered_set_746" rel="nofollow">6.unordered_set的封装实现</a></li></ul> 
</div> 
<br> 
<font color="red"><mark>🎉个人名片：</mark></font> 
<p></p> 
<blockquote> 
 <p><font color="blue">🐼作者简介：一名乐于分享在学习道路上收获的大二在校生<br> <font color="blue">🙈个人主页🎉：GOTXX<br> <font color="black">🐼个人WeChat：ILXOXVJE<br> <font color="green">🐼本文由GOTXX原创，首发CSDN🎉🎉🎉<br> <font color="orange">🐵系列专栏：零基础学习C语言----- 数据结构的学习之路----C++的学习之路<br> <font color="red">🐓每日一句：如果没有特别幸运，那就请特别努力！🎉🎉🎉<br> ————————————————</font></font></font></font></font></font></p> 
</blockquote> 
<p><em><strong>文章简介</strong></em>：</p> 
<blockquote> 
 <p>本篇博文主要会涉及到<strong>STL关联式容器</strong>，<strong>unordered</strong>系列关联式容器，<strong>unordered_set和unordered_map</strong>的底层数据结构，<strong>哈希表</strong>的底层及<strong>迭代器</strong>实现，以及在其上对<strong>unordered_set****和unordered_map</strong>的封装。</p> 
</blockquote> 
<h2><a id="1_unordered_18"></a>1. unordered系列关联式容器</h2> 
<p>在C++98中，STL提供了底层为红黑树结构的一系列关联式容器，在查询时效率可达到<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         l 
        
       
         o 
        
        
        
          g 
         
        
          2 
         
        
       
         N 
        
       
      
        log_2 N 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span></span></span></span></span>，即最差情况下需要比较红黑树的高度次，当树中的节点非常多时，查询效率也不理想。最好的查询是，进行很少的比较次数就能够将元素找到，因此在C++11中，STL又提供了4个<strong>unordered</strong>系列的关联式容器，分别为：<em><strong>unordered_map与unordered_set和unordered_multimap与unordered_multiset</strong></em> 这四个容器，他们与红黑树结构的关联式容器使用方式基本类似，只是其底层结构不同。</p> 
<ol><li>unordered_map和unordered_set与map与set类似，map与set是有序的，但是unordered系列都不是有序的，但是也不允许出现重复值。</li><li>unordered_multimap和unordered_multiset与unordered_map和unordered_set类似，unordered_map和unordered_set不允许重复值出现，但是multi系列是允许重复值出现的。</li><li>只要是前缀带了unordered的就是无序，后缀带了multi的就是允许键值重复。</li><li>他们在使用方面上与set与map非常类似，这里不作详解。</li></ol> 
<h4><a id="11_unordered_map_29"></a>1.1 unordered_map</h4> 
<p>unordered_map的文档介绍链接: <a href="https://legacy.cplusplus.com/reference/unordered_map/unordered_map/?kw=unordered_map" rel="nofollow">link</a></p> 
<p><em>文档说明：</em></p> 
<ol><li>unordered_map是存储&lt;key, value&gt;键值对的关联式容器，其允许通过keys快速的索引到与其对应的value。</li><li>在unordered_map中，键值通常用于惟一地标识元素，而映射值是一个对象，其内容与此键关联。键和映射值的类型可能不同。</li><li>在内部,unordered_map没有对&lt;kye, value&gt;按照任何特定的顺序排序, 为了能在常数范围内找到key所对应的value，unordered_map将相同哈希值的键值对放在相同的桶中。</li><li>unordered_map容器通过key访问单个元素要比map快，但它通常在遍历元素子集的范围迭代方面效率较低。</li><li>unordered_maps实现了直接访问操作符(operator[ ])，它允许使用key作为参数直接访问value。</li><li>它的迭代器至少是前向迭代器。</li></ol> 
<h4><a id="12_unordered_set_42"></a>1.2 unordered_set</h4> 
<p>unordered_mset的文档介绍链接: <a href="https://legacy.cplusplus.com/reference/unordered_set/unordered_set/?kw=unordered_set" rel="nofollow">link</a></p> 
<h4><a id="13_48"></a>1.3.底层结构</h4> 
<p>STL关联式容器中：<br> set和map的底层数据结构为红黑树，因为map和set要求是自动排序的，红黑树能够实现这一功能，并且各个操作的时间复杂度都较低，而unordered_set和unordered_map的底层数据结构为哈希表，查找时间复杂度为常数级。</p> 
<h2><a id="2_56"></a>2.哈希</h2> 
<h4><a id="21_57"></a>2.1哈希概念</h4> 
<p>顺序结构以及平衡树中，元素 <em>关键码</em> 与其 <em>存储位置</em> 之间没有对应的关系，因此在查找一个元素时，必须要经过关键码的多次比较。顺序查找时间复杂度为O(N)，平衡树中为树的高度，即O(<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         l 
        
       
         o 
        
        
        
          g 
         
        
          2 
         
        
       
         N 
        
       
      
        log_2 N 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span></span></span></span></span>)，搜索的效率取决于搜索过程中元素的比较次数。</p> 
<p>理想的搜索方法：可以不经过任何比较，一次直接从表中得到要搜索的元素。<br> 如果构造一种存储结构，通过某种函数(hashFunc)使元素的 <em>存储位置</em> 与它的 <em>关键码</em> 之间能够建立一一 <em>映射</em> 的关系，那么在查找时通过该函数可以很快找到该元素。</p> 
<p>当向该结构中：<br> <em><strong>插入元素</strong></em><br> 根据待插入元素的关键码，以此函数计算出该元素的存储位置并按此位置进行存放。<br> <em><strong>搜索元素</strong></em><br> 对元素的关键码进行同样的计算，把求得的函数值当做元素的存储位置，在结构中按此位置取元素比较，若关键码相等，则搜索成功。</p> 
<p>该方式即为哈希(散列)方法，哈希方法中使用的转换函数称为哈希(散列)函数，构造出来的结构称为哈希表(Hash Table)(或者称散列表)。</p> 
<p>例如有一个数组arr[ ]={ 4 , 9 , 17 , 28 , 16 , 22 , 13 , 10 };<br> 哈希函数设置为：hash(key) = key % capacity（ capacity为存储元素底层空间总的大小）。<br> <img src="https://images2.imgbox.com/58/79/SHzLCKAD_o.png" alt="在这里插入图片描述"><br> 用该方法进行搜索不必进行多次关键码的比较，因此搜索的速度比较快，<br> 但是如果我们再插入一个数7，就会和存放17的位置冲突，这个就引发了<em><strong>哈希冲突</strong></em>；</p> 
<h4><a id="22_79"></a>2.2哈希冲突</h4> 
<p>对于两个数据元素的关键字<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          k 
         
        
          i 
         
        
       
      
        k_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0315em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>和 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          k 
         
        
          j 
         
        
       
      
        k_j 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.9805em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0315em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span></span></span></span></span>(i != j)，有<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          k 
         
        
          i 
         
        
       
      
        k_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0315em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> != <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          k 
         
        
          j 
         
        
       
      
        k_j 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.9805em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0315em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span></span></span></span></span>，但有：Hash(<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          k 
         
        
          i 
         
        
       
      
        k_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0315em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>) ==<br> Hash(<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          k 
         
        
          j 
         
        
       
      
        k_j 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.9805em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0315em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span></span></span></span></span>)，即：不同关键字通过相同哈希哈数计算出相同的哈希地址，该种现象称为哈希冲突或哈希碰撞。<br> 把具有不同关键码而具有相同哈希地址的数据元素称为“同义词”。</p> 
<h4><a id="23__85"></a>2.3 哈希函数</h4> 
<p>引起哈希冲突的一个原因可能是：哈希函数设计不够合理。<br> 哈希函数设计原则：</p> 
<ol><li>哈希函数的定义域必须包括需要存储的全部关键码，而如果散列表允许有m个地址时，其值域必须在0到m-1之间。</li><li>哈希函数计算出来的地址能均匀分布在整个空间中</li><li>哈希函数应该比较简单</li></ol> 
<p><strong>常见哈希函数</strong><br> 这里只讲解常用的几种方法</p> 
<ol><li>直接定址法<br> 取关键字的某个线性函数为散列地址：Hash（Key）= A*Key + B<br> 优点：简单、均匀<br> 缺点：需要事先知道关键字的分布情况<br> 使用场景：适合查找比较小且连续的情况<br> 面试题：字符串中第一个只出现一次字符</li></ol> 
<blockquote> 
 <p>例如：数组arr[ ]={ 1 , 4 , 6 , 2 , 8 }; 假设线性函数我们取：Hash(key) = 2*key+1。<br> <em>那么</em>：Hash(6)=2 *1+1=13; 就把 6 存放到哈希表中对应映射位置为 13 的位置中，这样如果我们想要快速找元素6时，就可以直接利用该函数找到地址。</p> 
</blockquote> 
<ol start="2"><li>除留余数法<br> 设散列表中允许的地址数为m，取一个不大于m，但最接近或者等于m的质数p作为除数，按照哈希函数：Hash(key) = key% p(p&lt;=m),将关键码转换成哈希地址</li></ol> 
<blockquote> 
 <p>例如有一个数组arr[ ]={ 4 , 9 , 17 , 28 , 16 , 22 , 13 , 10 };<br> 哈希函数设置为：hash(key) = key % capacity; capacity为存储元素底层空间总的大小。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/4f/08/5YwyeCBJ_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="24__114"></a>2.4 哈希冲突解决</h4> 
<p>解决哈希冲突两种常见的方法是： <em>闭散列</em> 和 <em>开散列</em></p> 
<h5><a id="241_117"></a>2.4.1闭散列</h5> 
<p><em>闭散列</em>：也叫开放定址法，当发生哈希冲突时，如果哈希表未被装满，说明在哈希表中必然还有空位置，那么可以把key存放到冲突位置中的“下一个” 空位置中去。那如何寻找下一个空位置<br> 呢？</p> 
<ol><li><em>线性探测</em><br> 现在需要插入元素44（如下图），先通过哈希函数计算哈希地址，hashAddr为4，因此44理论上应该插在该位置，但是该位置已经放了值为4的元素，即发生哈希冲突。<br> 线性探测：从发生冲突的位置开始，依次向后探测，直到寻找到下一个空位置为止。</li></ol> 
<p><em>插入</em><br> 通过哈希函数获取待插入元素在哈希表中的位置<br> 如果该位置中没有元素则直接插入新元素，如果该位置中有元素发生哈希冲突，使用线性探测找到下一个空位置，插入新元素。<br> <img src="https://images2.imgbox.com/f4/39/t2A9LkUD_o.png" alt="在这里插入图片描述"><br> <em>删除</em><br> 采用闭散列处理哈希冲突时，不能随便物理删除哈希表中已有的元素，若直接删除元素会影响其他元素的搜索。比如删除元素4，如果直接删除掉，44查找起来可能会受影<br> 响。因此线性探测采用标记的伪删除法来删除一个元素。（例如使用枚举，列出三种状态（存在，不存在，已删除））</p> 
<pre><code class="prism language-cpp"><span class="token comment">// 哈希表每个空间给个标记</span>
<span class="token comment">// EMPTY此位置空， EXIST此位置已经有元素， DELETE元素已经删除</span>
<span class="token keyword">enum</span> <span class="token class-name">State</span><span class="token punctuation">{<!-- --></span>EMPTY<span class="token punctuation">,</span> EXIST<span class="token punctuation">,</span> DELETE<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><em>线性探测优点</em>：实现非常简单（就不实现了，重点实现后面的开散列）<br> <em>线性探测缺点</em>：一旦发生哈希冲突，所有的冲突连在一起，容易产生数据“堆积”，即：不同关键码占据了可利用的空位置，使得寻找某关键码的位置需要许多次比较，导致搜索效率降低。<br> 如何缓解呢？</p> 
<ol start="2"><li><em>二次探测</em><br> 二次探测就是与线性探测寻找下一个位置的方法不同而已。<br> 线性探测的缺陷是产生冲突的数据堆积在一块，这与其找下一个空位置有关系，因为找空位置的方式就是挨着往后逐个去找，因此二次探测为了避免该问题<br> *<strong>找下一个空位置的方法为</strong>:<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           H 
          
         
           i 
          
         
        
       
         H_i 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0813em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0813em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> = (<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           H 
          
         
           0 
          
         
        
       
         H_0 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0813em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0813em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> + <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           i 
          
         
           2 
          
         
        
       
         i^2 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8141em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> )% m, 或者：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           H 
          
         
           i 
          
         
        
       
         H_i 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0813em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0813em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> = (<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           H 
          
         
           0 
          
         
        
       
         H_0 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0813em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0813em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> - <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           i 
          
         
           2 
          
         
        
       
         i^2 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8141em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> )% m。其中：i = 1,2,3…， <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           H 
          
         
           0 
          
         
        
       
         H_0 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0813em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0813em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>是通过散列函数Hash(x)对元素的关键码 key 进行计算得到的位置，m是表的大小。</li></ol> 
<p>研究表明：<strong>当表的长度为质数且表装载因子a（存放的数据个数/最多能存放的数据个数）不超过0.5时，新的表项一定能够插入，而且任何一个位置都不会被探查两次。因此只要表中有一半的空位置，就不会存在表满的问题。在搜索时可以不考虑表装满的情况，但在插入时必须确保表的装载因子a不超过0.5</strong>，如果超出必须考虑增容。</p> 
<p>因此：<em><strong>闭散列</strong></em> 最大的 <em><strong>缺陷</strong></em> 就是 <em>空间利用率比较低</em>，这也是<em>哈希的缺陷</em>。</p> 
<h5><a id="241_153"></a>2.4.1开散列</h5> 
<ol><li><em>开散列概念</em><br> 开散列法又叫链地址法(开链法)，首先对关键码集合用散列函数计算散列地址，具有相同地址的关键码归于同一子集合，每一个子集合称为一个桶，各个桶中的元素通过一个单链表链接起来，各链表的头结点存储在哈希表中。<br> <img src="https://images2.imgbox.com/42/1d/bxt5QkWs_o.png" alt="在这里插入图片描述"></li></ol> 
<p>从上图可以看出，开散列中每个<strong>桶中</strong>放的都是发生<strong>哈希冲突的元素</strong>。</p> 
<ol start="2"><li><em>开散列实现</em></li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">K</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">Hashfunc</span>       <span class="token comment">//整型数据不用转换</span>
<span class="token punctuation">{<!-- --></span> 
	size_t <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> K<span class="token operator">&amp;</span> key<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token punctuation">(</span>size_t<span class="token punctuation">)</span>key<span class="token punctuation">;</span>    <span class="token comment">//直接返回</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span>                     <span class="token comment">//特化</span>
<span class="token keyword">struct</span> <span class="token class-name">Hashfunc</span><span class="token operator">&lt;</span>string<span class="token operator">&gt;</span>         <span class="token comment">//如果为字符串类型，需要将其转化为整形</span>
<span class="token punctuation">{<!-- --></span>
	size_t <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		size_t hashi <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> s<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			hashi <span class="token operator">+=</span> e<span class="token punctuation">;</span>
			hashi <span class="token operator">*=</span> <span class="token number">131</span><span class="token punctuation">;</span>       <span class="token comment">//这里13 131 1313.....都可以</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> hashi<span class="token punctuation">;</span>          <span class="token comment">//转换为整型返回</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">V</span><span class="token operator">&gt;</span>     <span class="token comment">//储存数据的节点</span>
<span class="token keyword">struct</span> <span class="token class-name">HashNode</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">HashNode</span><span class="token punctuation">(</span><span class="token keyword">const</span> pair<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span><span class="token operator">&amp;</span> kv<span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_next</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_kv</span><span class="token punctuation">(</span>kv<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

	HashNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span><span class="token operator">*</span> _next<span class="token punctuation">;</span>    <span class="token comment">//指向写一个节点的指针</span>
	pair<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span> _kv<span class="token punctuation">;</span>           <span class="token comment">//数据</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">K</span><span class="token punctuation">,</span><span class="token keyword">class</span> <span class="token class-name">V</span><span class="token punctuation">,</span><span class="token keyword">class</span> <span class="token class-name">HFunc</span> <span class="token operator">=</span> Hashfunc<span class="token operator">&lt;</span>K<span class="token operator">&gt;&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">HashTable</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">typedef</span> HashNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span> Node<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">HashTable</span><span class="token punctuation">(</span>size_t size <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		_table<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		_n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">插入函数的实现(这里只有插入函数，扩容与检查函数文章后面会有)</span>
	<span class="token keyword">bool</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">const</span> pair<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">&gt;</span><span class="token operator">&amp;</span> kv<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//1.查重，如果已经存在，不用插入了</span>
		
		<span class="token comment">//2.检查是否需要扩容</span>
		
		<span class="token comment">//3.插入代码</span>
		Hashfunc<span class="token operator">&lt;</span>K<span class="token operator">&gt;</span> HFunc<span class="token punctuation">;</span>         <span class="token comment">//转换能取模的整型</span>
		size_t hashi <span class="token operator">=</span> <span class="token function">HFunc</span><span class="token punctuation">(</span>kv<span class="token punctuation">.</span>first<span class="token punctuation">)</span> <span class="token operator">%</span> _table<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>_table<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span><span class="token punctuation">)</span>   <span class="token comment">//如果不为bullptr，则说明改位置已经有数据了，直接头插</span>
		<span class="token punctuation">{<!-- --></span>                            <span class="token comment">//因为单链表的头插效率高</span>
			<span class="token comment">//头插</span>
			Node<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>kv<span class="token punctuation">)</span><span class="token punctuation">;</span>
			newnode<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> _table<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span><span class="token punctuation">;</span>
			_table<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span> <span class="token operator">=</span> newnode<span class="token punctuation">;</span>

			<span class="token operator">++</span>_n<span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span>       <span class="token comment">//如果为nullptr，则说明该位置还没有数据，直接插入</span>
		<span class="token punctuation">{<!-- --></span>
			Node<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>kv<span class="token punctuation">)</span><span class="token punctuation">;</span>
			_table<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span> <span class="token operator">=</span> newnode<span class="token punctuation">;</span>

			<span class="token operator">++</span>_n<span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
      <span class="token comment">删除函数的实现</span>
	<span class="token keyword">bool</span> <span class="token function">Erase</span><span class="token punctuation">(</span><span class="token keyword">const</span> K<span class="token operator">&amp;</span> key<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		Hashfunc<span class="token operator">&lt;</span>K<span class="token operator">&gt;</span> HFunc<span class="token punctuation">;</span>          <span class="token comment">//转换能取模的整型</span>
		size_t hashi <span class="token operator">=</span> <span class="token function">HFunc</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> _table<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//找到该元素对应到哈希表中的位置</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>_table<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token comment">//如果不为空，则说明有元素</span>
		<span class="token punctuation">{<!-- --></span>
			Node<span class="token operator">*</span> cur <span class="token operator">=</span> _table<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span><span class="token punctuation">;</span>
			Node<span class="token operator">*</span> parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>     <span class="token comment">//保存上一个节点，因为如果不是第一个节点需要链接</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>                 <span class="token comment">//寻找要删除的元素的节点</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first <span class="token operator">==</span> key<span class="token punctuation">)</span>      <span class="token comment">//找到了</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> _table<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>   <span class="token comment">//如果是第一个节点，特殊处理</span>
						<span class="token keyword">delete</span> cur<span class="token punctuation">;</span>
						_table<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
						_n<span class="token operator">--</span><span class="token punctuation">;</span>
						<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
					<span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>                       <span class="token comment">//不是第一个节点</span>
						<span class="token keyword">if</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span>
							parent<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>   <span class="token comment">//链接</span>
						<span class="token keyword">delete</span> cur<span class="token punctuation">;</span>
						_n<span class="token operator">--</span><span class="token punctuation">;</span>
						<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
				<span class="token punctuation">}</span>
				parent <span class="token operator">=</span> cur<span class="token punctuation">;</span>
				cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	vector<span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token operator">&gt;</span> _table<span class="token punctuation">;</span>      <span class="token comment">///表</span>
	size_t _n<span class="token punctuation">;</span>         <span class="token comment">//记录储存的有效数据个数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<ol start="3"><li> <p><em>开散列增容</em><br> 桶的个数是一定的，随着元素的不断插入，每个桶中元素的个数不断增多，极端情况下，可能会导致一个桶中链表节点非常多，会影响的哈希表的性能，因此在一定条件下需要对哈希表进行增容，那该条件怎么确认呢？开散列最好的情况是：每个哈希桶中刚好挂一个节点，再继续插入元素时，每一次都会发生哈希冲突，因此，在元素个数刚好等于桶的个数时，可以给哈希表增容。</p> </li><li> <p><em>数据类型为非整型时的定址方法</em><br> 因为%取模的操作数只能是整型，那么当我们存储的数据类型为string或则Date(日期类)时，应该怎样去计算位置呢？<br> 这时，如果存储的数据不是整型的时候，就需要先转换为整型再定址；</p> </li></ol> 
<h5><a id="25_287"></a>2.5开散列与闭散列比较</h5> 
<p>应用链地址法处理溢出，需要增设链接指针，似乎增加了存储开销。事实上：<br> 由于开地址法必须保持大量的空闲空间以确保搜索效率，如二次探查法要求装载因子a &lt;= 0.7，而表项所占空间又比指针大的多，所以使用链地址法反而比开地址法节省存储空间。</p> 
<h2><a id="3_291"></a>3.哈希的模拟实现</h2> 
<h4><a id="1__293"></a>1. 模板参数列表</h4> 
<pre><code class="prism language-cpp"><span class="token comment">// K:关键码类型</span>
<span class="token comment">// T: 不同容器T的类型不同，如果是unordered_map，T代表一个键值对，如果是unordered_set,T为 K</span>
<span class="token comment">// KeyOfValue: 因为T的类型不同，通过value取key的方式就不同，详见见unordered_map/set的实现</span>
<span class="token comment">// HFunc : 哈希函数仿函数对象类型，哈希函数使用除留余数法，需要将Key转换为整形数字才能取模</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">KeyofT</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">HFunc</span> <span class="token operator">=</span> Hashfunc<span class="token operator">&lt;</span>K<span class="token operator">&gt;</span> <span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">HashTable</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="2__303"></a>2. 迭代器的实现</h4> 
<p><em>解析：</em></p> 
<ol><li> <p>因为我们实现的hashTable是开散列的，底层是一个数组，数组里面存储的一个一个的节点，节点下面有可能挂着一个哈希桶；迭代器的实现必须要实现 <strong>++，*，!=</strong> 操作，<strong>++</strong> 指向下一个节点的，这里如果迭代器里面我们只选择封装一个节点的指针的话，那么如果当这个节点是一个哈希桶里面的最后一个节点时，则没有办法找到下一个节点，所以需要加一个哈希表的地址，当然也可以是哈希表中存放节点指针的vector；<br> 其中下一个节点的<strong>寻找方法</strong>：</p> 
  <ol><li>判断当前节点的下一个节点是否为空，如果不为空，则让其指向下一个节点即可，如果当前节点的下一个节点为空，则需要步骤二。</li><li>计算出当前节点所在哈希表中的下标（哈希地址），向后寻找数组中不为空的位置，让其指向该位置。</li></ol> </li><li> <p>因为我们需要访问HashTable里面的私有成员（vector&lt;Node*&gt; ），所以需要将迭代器设置成HashTable的友元类。</p> </li></ol> 
<p><em>代码实现：</em></p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">KeyofT</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">HFunc</span><span class="token operator">&gt;</span>        <span class="token comment">//前置声明，因为迭代器需要一HashTable的一个指针，需要使用到HashTable，编译器默认向上找，如果不加前置声明，则会找不到报错                            </span>
<span class="token keyword">class</span> <span class="token class-name">HashTable</span><span class="token punctuation">;</span>                                                    

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">KeyofT</span><span class="token punctuation">,</span><span class="token keyword">class</span> <span class="token class-name">HFunc</span> <span class="token operator">=</span> Hashfunc<span class="token operator">&lt;</span>K<span class="token operator">&gt;&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">Iterator</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">typedef</span> HashTable<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> T<span class="token punctuation">,</span> KeyofT<span class="token punctuation">,</span> HFunc<span class="token operator">&gt;</span> HashTable<span class="token punctuation">;</span>
	<span class="token keyword">typedef</span> Iterator<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> T<span class="token punctuation">,</span> KeyofT<span class="token punctuation">,</span>HFunc<span class="token operator">&gt;</span> Self<span class="token punctuation">;</span>
	<span class="token keyword">typedef</span> HashNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> Node<span class="token punctuation">;</span>       <span class="token comment">//存放数据的节点</span>

	Node<span class="token operator">*</span> _node<span class="token punctuation">;</span>          <span class="token comment">//节点指针</span>
	HashTable<span class="token operator">*</span> _ht<span class="token punctuation">;</span>        <span class="token comment">//哈希表</span>

	<span class="token function">Iterator</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> node<span class="token punctuation">,</span> HashTable<span class="token operator">*</span> ht<span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_node</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span>
		<span class="token punctuation">,</span><span class="token function">_ht</span><span class="token punctuation">(</span>ht<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

	T<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> _node<span class="token operator">-&gt;</span>_date<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	T<span class="token operator">*</span> <span class="token keyword">operator</span><span class="token operator">-&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token operator">&amp;</span>_node<span class="token operator">-&gt;</span>_date<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	Self<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		KeyofT kot<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>_node<span class="token operator">-&gt;</span>_next<span class="token punctuation">)</span>   <span class="token comment">//如果该节点的下一个节点存在</span>
		<span class="token punctuation">{<!-- --></span>
			_node <span class="token operator">=</span> _node<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//找下一个桶</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>
			Hashfunc<span class="token operator">&lt;</span>K<span class="token operator">&gt;</span> Hfunc<span class="token punctuation">;</span>
			size_t hashi <span class="token operator">=</span> <span class="token function">Hfunc</span><span class="token punctuation">(</span><span class="token function">kot</span><span class="token punctuation">(</span>_node<span class="token operator">-&gt;</span>_date<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> _ht<span class="token operator">-&gt;</span>_table<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			hashi<span class="token operator">++</span><span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>hashi <span class="token operator">&lt;</span> _ht<span class="token operator">-&gt;</span>_table<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>_ht<span class="token operator">-&gt;</span>_table<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span><span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					_node <span class="token operator">=</span> _ht<span class="token operator">-&gt;</span>_table<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span><span class="token punctuation">;</span>
					<span class="token keyword">break</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				hashi<span class="token operator">++</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>hashi <span class="token operator">==</span> _ht<span class="token operator">-&gt;</span>_table<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				_node <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">!=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Self<span class="token operator">&amp;</span> s<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> _node <span class="token operator">!=</span> s<span class="token punctuation">.</span>_node<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>	
	<span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> Self<span class="token operator">&amp;</span> s<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> _node <span class="token operator">==</span> s<span class="token punctuation">.</span>_node<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="3_keyvalue_383"></a>3. 增加通过key获取value操作</h4> 
<pre><code class="prism language-cpp"><span class="token comment">//map</span>
<span class="token keyword">struct</span> <span class="token class-name">mapKeyofT</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">const</span> K<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> pair<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span><span class="token operator">&amp;</span> kv<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> kv<span class="token punctuation">.</span>first<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<pre><code class="prism language-cpp"><span class="token comment">///set</span>
<span class="token keyword">struct</span> <span class="token class-name">setKeyofT</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">const</span> K<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> K<span class="token operator">&amp;</span> key<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> key<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="4__406"></a>4. 哈希实现总代码：</h4> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;vector&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>


<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">HashNode</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">HashNode</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> date<span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_next</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_date</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

	HashNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> _next<span class="token punctuation">;</span>
	T _date<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">K</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">Hashfunc</span>       <span class="token comment">//整型数据不用转换</span>
<span class="token punctuation">{<!-- --></span> 
	size_t <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> K<span class="token operator">&amp;</span> key<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token punctuation">(</span>size_t<span class="token punctuation">)</span>key<span class="token punctuation">;</span>    <span class="token comment">//直接返回</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span>                     <span class="token comment">//特化</span>
<span class="token keyword">struct</span> <span class="token class-name">Hashfunc</span><span class="token operator">&lt;</span>string<span class="token operator">&gt;</span>         <span class="token comment">//如果为字符串类型，需要将其转化为整形</span>
<span class="token punctuation">{<!-- --></span>
	size_t <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		size_t hashi <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> s<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			hashi <span class="token operator">+=</span> e<span class="token punctuation">;</span>
			hashi <span class="token operator">*=</span> <span class="token number">131</span><span class="token punctuation">;</span>       <span class="token comment">//这里13 131 1313.....都可以</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> hashi<span class="token punctuation">;</span>          <span class="token comment">//转换为整型返回</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">///迭代器的实现</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">KeyofT</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">HFunc</span><span class="token operator">&gt;</span>        <span class="token comment">//前置声明</span>
<span class="token keyword">class</span> <span class="token class-name">HashTable</span><span class="token punctuation">;</span>                                                    

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">KeyofT</span><span class="token punctuation">,</span><span class="token keyword">class</span> <span class="token class-name">HFunc</span> <span class="token operator">=</span> Hashfunc<span class="token operator">&lt;</span>K<span class="token operator">&gt;&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">Iterator</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">typedef</span> HashTable<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> T<span class="token punctuation">,</span> KeyofT<span class="token punctuation">,</span> HFunc<span class="token operator">&gt;</span> HashTable<span class="token punctuation">;</span>
	<span class="token keyword">typedef</span> Iterator<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> T<span class="token punctuation">,</span> KeyofT<span class="token punctuation">,</span>HFunc<span class="token operator">&gt;</span> Self<span class="token punctuation">;</span>
	<span class="token keyword">typedef</span> HashNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> Node<span class="token punctuation">;</span>

	Node<span class="token operator">*</span> _node<span class="token punctuation">;</span>
	HashTable<span class="token operator">*</span> _ht<span class="token punctuation">;</span>

	<span class="token function">Iterator</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> node<span class="token punctuation">,</span> HashTable<span class="token operator">*</span> ht<span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_node</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span>
		<span class="token punctuation">,</span><span class="token function">_ht</span><span class="token punctuation">(</span>ht<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

	T<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> _node<span class="token operator">-&gt;</span>_date<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	T<span class="token operator">*</span> <span class="token keyword">operator</span><span class="token operator">-&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token operator">&amp;</span>_node<span class="token operator">-&gt;</span>_date<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	Self<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		KeyofT kot<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>_node<span class="token operator">-&gt;</span>_next<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			_node <span class="token operator">=</span> _node<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//找下一个桶</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>
			Hashfunc<span class="token operator">&lt;</span>K<span class="token operator">&gt;</span> Hfunc<span class="token punctuation">;</span>
			size_t hashi <span class="token operator">=</span> <span class="token function">Hfunc</span><span class="token punctuation">(</span><span class="token function">kot</span><span class="token punctuation">(</span>_node<span class="token operator">-&gt;</span>_date<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> _ht<span class="token operator">-&gt;</span>_table<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			hashi<span class="token operator">++</span><span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>hashi <span class="token operator">&lt;</span> _ht<span class="token operator">-&gt;</span>_table<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>_ht<span class="token operator">-&gt;</span>_table<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span><span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					_node <span class="token operator">=</span> _ht<span class="token operator">-&gt;</span>_table<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span><span class="token punctuation">;</span>
					<span class="token keyword">break</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				hashi<span class="token operator">++</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>hashi <span class="token operator">==</span> _ht<span class="token operator">-&gt;</span>_table<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				_node <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">!=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Self<span class="token operator">&amp;</span> s<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> _node <span class="token operator">!=</span> s<span class="token punctuation">.</span>_node<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>	
	<span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> Self<span class="token operator">&amp;</span> s<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> _node <span class="token operator">==</span> s<span class="token punctuation">.</span>_node<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
 
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">KeyofT</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">HFunc</span> <span class="token operator">=</span> Hashfunc<span class="token operator">&lt;</span>K<span class="token operator">&gt;&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">HashTable</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">typedef</span> HashNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> Node<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">KeyofT</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">HFunc</span><span class="token operator">&gt;</span>
	<span class="token keyword">friend</span> <span class="token keyword">struct</span> <span class="token class-name">Iterator</span><span class="token punctuation">;</span>
	<span class="token keyword">typedef</span> Iterator<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> T<span class="token punctuation">,</span> KeyofT<span class="token punctuation">,</span> HFunc<span class="token operator">&gt;</span> iterator<span class="token punctuation">;</span>

	iterator <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span>_table<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>_table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">return</span> <span class="token function">iterator</span><span class="token punctuation">(</span>_table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	iterator <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token function">HashTable</span><span class="token punctuation">(</span>size_t size <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		_table<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		_n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token operator">~</span><span class="token function">HashTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> _table<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>_table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				Node<span class="token operator">*</span> cur <span class="token operator">=</span> _table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
				Node<span class="token operator">*</span> next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
				<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					next <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
					<span class="token keyword">delete</span> cur<span class="token punctuation">;</span>
					cur <span class="token operator">=</span> next<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				_table<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	pair<span class="token operator">&lt;</span>iterator<span class="token punctuation">,</span><span class="token keyword">bool</span><span class="token operator">&gt;</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> date<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		KeyofT kot<span class="token punctuation">;</span>
		<span class="token comment">//查重，如果已经存在，不用插入了</span>
		Node<span class="token operator">*</span> ret <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token function">kot</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>ret<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token function">iterator</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//扩容   </span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>_n <span class="token operator">==</span> _table<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			vector<span class="token operator">&lt;</span>Node<span class="token operator">*</span> <span class="token operator">&gt;</span> <span class="token function">newtable</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> _table<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//创建一个新的newtable</span>
			Hashfunc<span class="token operator">&lt;</span>K<span class="token operator">&gt;</span> HFunc<span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> _table<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>              <span class="token comment">//遍历原hashtable，将节点移到新的hastable里</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>_table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                                  <span class="token comment">//如果不为空，则移动节点到新表的对应位置上</span>
				<span class="token punctuation">{<!-- --></span>
					Node<span class="token operator">*</span> cur <span class="token operator">=</span> _table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
					<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
					<span class="token punctuation">{<!-- --></span>
						<span class="token comment">//头插到新表对应位置</span>
						size_t hashi <span class="token operator">=</span> <span class="token function">HFunc</span><span class="token punctuation">(</span><span class="token function">kot</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_date<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> newtable<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

						Node<span class="token operator">*</span> next <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
						cur<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> newtable<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span><span class="token punctuation">;</span>
						newtable<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span> <span class="token operator">=</span> cur<span class="token punctuation">;</span>

						cur <span class="token operator">=</span> next<span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
					_table<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>       <span class="token comment">//移动完后，将原表中映射位置置空</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>               
			_table<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>newtable<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">//调用vector的的swap函数完成交换</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//插入代码</span>
		Hashfunc<span class="token operator">&lt;</span>K<span class="token operator">&gt;</span> HFunc<span class="token punctuation">;</span>
		size_t hashi <span class="token operator">=</span> <span class="token function">HFunc</span><span class="token punctuation">(</span><span class="token function">kot</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> _table<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>_table<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//头插</span>
			Node<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>
			newnode<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> _table<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span><span class="token punctuation">;</span>
			_table<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span> <span class="token operator">=</span> newnode<span class="token punctuation">;</span>

			<span class="token operator">++</span>_n<span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token function">iterator</span><span class="token punctuation">(</span>newnode<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>
			Node<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>
			_table<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span> <span class="token operator">=</span> newnode<span class="token punctuation">;</span>

			<span class="token operator">++</span>_n<span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token function">iterator</span><span class="token punctuation">(</span>newnode<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//查找</span>
	Node<span class="token operator">*</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">const</span> K<span class="token operator">&amp;</span> key<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		KeyofT kot<span class="token punctuation">;</span>
		Hashfunc<span class="token operator">&lt;</span>K<span class="token operator">&gt;</span> HFunc<span class="token punctuation">;</span>
		size_t hashi <span class="token operator">=</span> <span class="token function">HFunc</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> _table<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		Node<span class="token operator">*</span> cur <span class="token operator">=</span> _table<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">kot</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_date<span class="token punctuation">)</span> <span class="token operator">==</span> key<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">return</span> cur<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">bool</span> <span class="token function">Erase</span><span class="token punctuation">(</span><span class="token keyword">const</span> K<span class="token operator">&amp;</span> key<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		Hashfunc<span class="token operator">&lt;</span>K<span class="token operator">&gt;</span> HFunc<span class="token punctuation">;</span>
		size_t hashi <span class="token operator">=</span> <span class="token function">HFunc</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> _table<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>_table<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			Node<span class="token operator">*</span> cur <span class="token operator">=</span> _table<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span><span class="token punctuation">;</span>
			Node<span class="token operator">*</span> parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				KeyofT kot<span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">kot</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_date<span class="token punctuation">)</span> <span class="token operator">==</span> key<span class="token punctuation">)</span>      <span class="token comment">//找到了</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> _table<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span><span class="token punctuation">)</span>   <span class="token comment">//是第一个节点</span>
					<span class="token punctuation">{<!-- --></span>
						<span class="token keyword">delete</span> cur<span class="token punctuation">;</span>
						_table<span class="token punctuation">[</span>hashi<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
						_n<span class="token operator">--</span><span class="token punctuation">;</span>

						<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
					<span class="token keyword">else</span>                       <span class="token comment">//不是第一个节点</span>
					<span class="token punctuation">{<!-- --></span>
						<span class="token keyword">if</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span>
							parent<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
						<span class="token keyword">delete</span> cur<span class="token punctuation">;</span>
						_n<span class="token operator">--</span><span class="token punctuation">;</span>

						<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
				<span class="token punctuation">}</span>
				parent <span class="token operator">=</span> cur<span class="token punctuation">;</span>
				cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	vector<span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token operator">&gt;</span> _table<span class="token punctuation">;</span>           <span class="token comment">//表</span>
	size_t _n<span class="token punctuation">;</span>                     <span class="token comment">//记录储存的有效数据个数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="4unordered_mapunordered_set_691"></a>4.用实现的哈希封装unordered_map与unordered_set前的模板参数的梳理及相关联系的梳理</h2> 
<p><em>我们是想要用同一个哈希表封装出不同的容器（unordered_map与unordered_set），所以就需要对相关操作参数及操作做出改变。</em></p> 
<ol><li>unordered_map与unordered_set存储的数据类型不同，unordered_map存储的是pair&lt;K,V&gt; ，K为key的类型，V为value的类型而unordered_set，存储的是K，所以就需要对节点所存储的数据类型做出改变，如图：<br> <img src="https://images2.imgbox.com/39/96/BwSfnvIk_o.png" alt="在这里插入图片描述"></li><li>因为unordered_map中的key为pair中的第一个数据，而unordered_set中存储的数据就是key，所以当在需要取出数据里面的key进行操作时，unordered_map与unordered_set取出的方法有差异，所以需要各自提供一个仿函数来实现：如图：<br> <img src="https://images2.imgbox.com/dc/de/MRjwbrie_o.png" alt="在这里插入图片描述"></li></ol> 
<h2><a id="5unordered_map_701"></a>5.unordered_map的封装实现</h2> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"HashTable.h"</span></span>
<span class="token keyword">namespace</span> map
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">V</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">HFunc</span> <span class="token operator">=</span> Hashfunc<span class="token operator">&lt;</span>K<span class="token operator">&gt;&gt;</span>
	<span class="token keyword">class</span> <span class="token class-name">unorderedmap</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">struct</span> <span class="token class-name">mapKeyofT</span>              <span class="token comment">//取数据中的key，即pair&lt;K,V&gt;中的k</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">const</span> K<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> pair<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span><span class="token operator">&amp;</span> kv<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">return</span> kv<span class="token punctuation">.</span>first<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">HashTable</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> pair<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span><span class="token punctuation">,</span> mapKeyofT<span class="token punctuation">,</span> HFunc<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator iterator<span class="token punctuation">;</span>

		pair<span class="token operator">&lt;</span>iterator<span class="token punctuation">,</span><span class="token keyword">bool</span><span class="token operator">&gt;</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">const</span> pair<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span><span class="token operator">&amp;</span> kv<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _ht<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>kv<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		iterator <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _ht<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		iterator <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _ht<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		V<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> K<span class="token operator">&amp;</span> key<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			pair<span class="token operator">&lt;</span>iterator<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">&gt;</span> ret <span class="token operator">=</span> _ht<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token keyword">return</span> <span class="token punctuation">(</span>ret<span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token operator">-&gt;</span>second<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token keyword">private</span><span class="token operator">:</span>
		HashTable<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> pair<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span><span class="token punctuation">,</span> mapKeyofT<span class="token punctuation">,</span> HFunc<span class="token operator">&gt;</span> _ht<span class="token punctuation">;</span>    <span class="token comment">//需要用自己的mapKeyofT去实例化一个HashTable</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="6unordered_set_746"></a>6.unordered_set的封装实现</h2> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"HashTable.h"</span></span>
<span class="token keyword">namespace</span> set
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">HFunc</span> <span class="token operator">=</span> Hashfunc<span class="token operator">&lt;</span>K<span class="token operator">&gt;&gt;</span>
	<span class="token keyword">class</span> <span class="token class-name">unorderedset</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">struct</span> <span class="token class-name">setKeyofT</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">const</span> K<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> K<span class="token operator">&amp;</span> key<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">return</span> key<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">HashTable</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> K<span class="token punctuation">,</span> setKeyofT<span class="token punctuation">,</span> HFunc<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator iterator<span class="token punctuation">;</span>

		pair<span class="token operator">&lt;</span>iterator<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">&gt;</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">const</span> K<span class="token operator">&amp;</span> key<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _ht<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		iterator <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _ht<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		iterator <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _ht<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

	<span class="token keyword">private</span><span class="token operator">:</span>
		HashTable<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> K<span class="token punctuation">,</span> setKeyofT<span class="token punctuation">,</span> HFunc<span class="token operator">&gt;</span> _ht<span class="token punctuation">;</span>   <span class="token comment">//需要用自己的setKeyofT去实例化一个HashTable</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>本章完~</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/337cd48104cc982df3141ac410f5d24f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【MySQL】跟着示例学 SQL</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8f51f0681055c4870a131fbc9304baa9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">最火前端 Web 组态软件 (可视化)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>