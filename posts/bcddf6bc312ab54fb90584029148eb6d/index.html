<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Re：从零开始的C&#43;&#43;世界——（一）入门基础 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/bcddf6bc312ab54fb90584029148eb6d/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Re：从零开始的C&#43;&#43;世界——（一）入门基础">
  <meta property="og:description" content="文章目录 C&#43;&#43;发展历史1.命名空间1.1 namespace的价值1.2 namespace的定义1.3 命名空间使⽤ 2.C&#43;&#43;输⼊&amp;输出3.缺省参数3.1 缺省参数的概念3.2 缺省参数的分类 4.函数重载5.引⽤5.1引⽤的概念和定义5.2 引⽤的特性5.3 const引⽤5.4 使用场景5.5 指针和引⽤的关系 6.内联函数6.1内联函数概念6.2 内敛函数的特性 7.指针空值nullptr7.1 C&#43;&#43;98中的指针空值7.2 C&#43;&#43;11中的指针空值 8 **总结** C&#43;&#43;发展历史 C&#43;&#43;的起源可以追溯到1979年，当时Bjarne Stroustrup(本贾尼·斯特劳斯特卢普，这个翻译的名字不同的地⽅可能有差异)在⻉尔实验室从事计算机科学和软件⼯程的研究⼯作。⾯对项⽬中复杂的软件开发任务，特别是模拟和操作系统的开发⼯作，他感受到了现有语⾔（如C语⾔）在表达能⼒、可维护性和可扩展性⽅⾯的不⾜。
1983年，Bjarne Stroustrup在C语⾔的基础上添加了⾯向对象编程的特性，设计出了C&#43;&#43;语⾔的雏形，此时的C&#43;&#43;已经有了类、封装、继承等核⼼概念，为后来的⾯向对象编程奠定了基础。这⼀年该语⾔被正式命名为C&#43;&#43;。
语言的发展是一个初步递进、由浅入深的过程。
目前，C&#43;&#43;还在不断向后发展中。
1.命名空间 1.1 namespace的价值 在C/C&#43;&#43;中，变量、函数和后⾯要学到的类都是⼤量存在的，这些变量、函数和类的名称将都存在于全局作⽤域中，可能会导致很多冲突。使⽤命名空间的⽬的是对标识符的名称进⾏本地化，以避免命名冲突或名字污染，namespace关键字的出现就是针对这种问题的。
c语⾔项⽬类似下⾯程序这样的命名冲突是普遍存在的问题，C&#43;&#43;引⼊namespace就是为了更好的解决这样的问题。
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int rand = 10; int main() { // 编译报错：error C2365: “rand”: 重定义；以前的定义是“函数” printf(&#34;%d\n&#34;, rand); return 0; } 1.2 namespace的定义 • 定义命名空间，需要使⽤到namespace关键字，后⾯跟命名空间的名字，然后接⼀对{}即可，{}中即为命名空间的成员。命名空间中可以定义变量/函数/类型等。
// 普通的命名空间 namespace N1 // N1为命名空间的名称 { // 命名空间中的内容，既可以定义变量，也可以定义函数 int a; int Add(int x, int y) { return x &#43; y; } } • namespace只能定义在全局，当然他还可以嵌套定义。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-14T08:28:35+08:00">
    <meta property="article:modified_time" content="2024-07-14T08:28:35+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Re：从零开始的C&#43;&#43;世界——（一）入门基础</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#C_1" rel="nofollow">C++发展历史</a></li><li><a href="#1_17" rel="nofollow">1.命名空间</a></li><li><ul><li><a href="#11_namespace_19" rel="nofollow">1.1 namespace的价值</a></li><li><a href="#12_namespace_37" rel="nofollow">1.2 namespace的定义</a></li><li><a href="#13__102" rel="nofollow">1.3 命名空间使⽤</a></li></ul> 
  </li><li><a href="#2C_208" rel="nofollow">2.C++输⼊&amp;输出</a></li><li><a href="#3_266" rel="nofollow">3.缺省参数</a></li><li><ul><li><a href="#31__269" rel="nofollow">3.1 缺省参数的概念</a></li><li><a href="#32__291" rel="nofollow">3.2 缺省参数的分类</a></li></ul> 
  </li><li><a href="#4_403" rel="nofollow">4.函数重载</a></li><li><a href="#5_448" rel="nofollow">5.引⽤</a></li><li><ul><li><a href="#51_449" rel="nofollow">5.1引⽤的概念和定义</a></li><li><a href="#52__479" rel="nofollow">5.2 引⽤的特性</a></li><li><a href="#53_const_536" rel="nofollow">5.3 const引⽤</a></li><li><a href="#54__610" rel="nofollow">5.4 使用场景</a></li><li><a href="#55__706" rel="nofollow">5.5 指针和引⽤的关系</a></li></ul> 
  </li><li><a href="#6_721" rel="nofollow">6.内联函数</a></li><li><ul><li><a href="#61_722" rel="nofollow">6.1内联函数概念</a></li><li><a href="#62__770" rel="nofollow">6.2 内敛函数的特性</a></li></ul> 
  </li><li><a href="#7nullptr_802" rel="nofollow">7.指针空值nullptr</a></li><li><ul><li><a href="#71_C98_805" rel="nofollow">7.1 C++98中的指针空值</a></li><li><a href="#72_C11_867" rel="nofollow">7.2 C++11中的指针空值</a></li></ul> 
  </li><li><a href="#8__879" rel="nofollow">8 **总结**</a></li></ul> 
</div> 
<p></p> 
<h2><a id="C_1"></a>C++发展历史</h2> 
<p>C++的起源可以追溯到1979年，当时Bjarne Stroustrup(本贾尼·斯特劳斯特卢普，这个翻译的名字不同的地⽅可能有差异)在⻉尔实验室从事计算机科学和软件⼯程的研究⼯作。⾯对项⽬中复杂的软件开发任务，特别是模拟和操作系统的开发⼯作，他感受到了现有语⾔（如C语⾔）在表达能⼒、可维护性和可扩展性⽅⾯的不⾜。</p> 
<p>1983年，Bjarne Stroustrup在C语⾔的基础上添加了⾯向对象编程的特性，设计出了C++语⾔的雏形，此时的C++已经有了类、封装、继承等核⼼概念，为后来的⾯向对象编程奠定了基础。这⼀年该语⾔被正式命名为C++。</p> 
<p><img src="https://images2.imgbox.com/f8/5c/982sPVds_o.png" alt="在这里插入图片描述"></p> 
<p>语言的发展是一个初步递进、由浅入深的过程。<br> <img src="https://images2.imgbox.com/36/d3/jUJkBoCW_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/0b/7d/Qtwe36XV_o.png" alt="在这里插入图片描述"><br> 目前，C++还在不断向后发展中。</p> 
<h2><a id="1_17"></a>1.命名空间</h2> 
<h3><a id="11_namespace_19"></a>1.1 namespace的价值</h3> 
<p>在C/C++中，变量、函数和后⾯要学到的类都是⼤量存在的，这些变量、函数和类的名称将都存在于全局作⽤域中，可能会导致很多冲突。使⽤命名空间的⽬的是对标识符的名称进⾏本地化，以避免命名冲突或名字污染，namespace关键字的出现就是针对这种问题的。</p> 
<p>c语⾔项⽬类似下⾯程序这样的命名冲突是普遍存在的问题，C++引⼊namespace就是为了更好的解决这样的问题。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token keyword">int</span> rand <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 编译报错：error C2365: “rand”: 重定义；以前的定义是“函数”</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> rand<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="12_namespace_37"></a>1.2 namespace的定义</h3> 
<p>• 定义命名空间，需要使⽤到namespace关键字，后⾯跟命名空间的名字，然后接⼀对{}即可，{}中即为命名空间的成员。命名空间中可以定义变量/函数/类型等。</p> 
<pre><code class="prism language-c"> <span class="token comment">// 普通的命名空间</span>
namespace N1 <span class="token comment">// N1为命名空间的名称</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//  命名空间中的内容，既可以定义变量，也可以定义函数</span>
	<span class="token keyword">int</span> a<span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> 
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>• namespace只能定义在全局，当然他还可以嵌套定义。</p> 
<pre><code class="prism language-c"><span class="token comment">// 命名空间可以嵌套</span>
namespace N1 <span class="token comment">// 定义一个名为N1的命名空间</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a<span class="token punctuation">;</span>
	<span class="token keyword">int</span> b<span class="token punctuation">;</span>
	namespace N2 <span class="token comment">// 嵌套定义另一个名为N2的命名空间</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> c<span class="token punctuation">;</span>
		<span class="token keyword">int</span> d<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>•项⽬⼯程中多⽂件中定义的同名namespace会认为是⼀个namespace，不会冲突。</p> 
<pre><code class="prism language-c"><span class="token comment">// 定义一个N1</span>
namespace N1
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a<span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 再定义一个N1</span>
namespace N1
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> <span class="token function">Mul</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> left <span class="token operator">*</span> right<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>其它特征：</p> 
<blockquote> 
 <p>• namespace本质是定义出⼀个域，这个域跟全局域各⾃独⽴，不同的域可以定义同名变量，所以下<br> ⾯的rand不在冲突了。<br> • C++中域有函数局部域，全局域，命名空间域，类域；域影响的是编译时语法查找⼀个变量/函数/<br> 类型出处(声明或定义)的逻辑，所有有了域隔离，名字冲突就解决了。局部域和全局域除了会影响<br> 编译查找逻辑，还会影响变量的⽣命周期，命名空间域和类域不影响变量⽣命周期。<br> • C++标准库都放在⼀个叫std(standard)的命名空间中。</p> 
</blockquote> 
<h3><a id="13__102"></a>1.3 命名空间使⽤</h3> 
<p>编译查找⼀个变量的声明/定义时，<strong>默认只会在局部或者全局查找，不会到命名空间⾥⾯去查找</strong>。所以下⾯程序会编译报错。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
namespace bit
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 编译报错：error C2065: “a”: 未声明的标识符</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>所以我们要使⽤命名空间中定义的变量/函数，有三种⽅式：</p> 
<p>（1）<strong>加命名空间名称及作用域限定符，项⽬中推荐这种⽅式。</strong></p> 
<pre><code>符号 :: 在 C++中叫做作用域限定符。
</code></pre> 
<p>我们通过 <strong>命名空间名称 <strong>::</strong> 命名空间成员</strong> 便可以访问到命名空间中相应的成员。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token comment">// 加命名空间名称及作用域限定符</span>
namespace N
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a<span class="token punctuation">;</span>
	<span class="token keyword">float</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	N<span class="token operator">::</span>a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 将命名空间中的成员a赋值为10</span>
	N<span class="token operator">::</span>b <span class="token operator">=</span> <span class="token number">5.55</span><span class="token punctuation">;</span> <span class="token comment">// 将成员b赋值为5.55</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> N<span class="token operator">::</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印a</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.2f\n"</span><span class="token punctuation">,</span> N<span class="token operator">::</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印b</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>(2)<strong>使用 using 将命名空间中成员引入</strong></p> 
<p>我们还可以通过 <strong>using 命名空间名称::命名空间成员</strong> 的方式将命名空间中指定的成员引入。</p> 
<p>这样语句之后的代码中就可以直接使用引入的成员变量了。项⽬中经常访问的不存在冲突的成员推荐这种⽅式。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token comment">// 使用using将命名空间中的成员引入</span>
namespace N
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a<span class="token punctuation">;</span>
	<span class="token keyword">float</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

using N<span class="token operator">::</span>a<span class="token punctuation">;</span> <span class="token comment">// 将命名空间中的成员a引入</span>
using N<span class="token operator">::</span>b<span class="token punctuation">;</span> <span class="token comment">// 再将b引入</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 将命名空间中的成员a赋值为10</span>
	b <span class="token operator">=</span> <span class="token number">5.55</span><span class="token punctuation">;</span> <span class="token comment">// 将b赋值为5.55</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印成员a</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.2f\n"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印成员b</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>(3) <strong>使用 using namespace 命名空间名称引入</strong></p> 
<p>最后一种方式就是通 <strong>using namespace 命名空间名称</strong> 将命名空间中的全部成员引入。</p> 
<p>这样语句之后的代码中就可以直接使用该命名空间内的全部成员了,项⽬不推荐，冲突⻛险很⼤，⽇常⼩练习程序为了⽅便推荐使⽤。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token comment">// 使用 using namespace 命名空间名称引入</span>
namespace N
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a<span class="token punctuation">;</span>
	<span class="token keyword">float</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

using namespace N<span class="token punctuation">;</span> <span class="token comment">// 将命名空间N的所有成员引入</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 将命名空间中的成员a赋值为10</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印命名空间中的成员a</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<h2><a id="2C_208"></a>2.C++输⼊&amp;输出</h2> 
<p>在学习任何语言的时候，我们首先会向 世界问好!也就是会在屏幕上打印 <strong>hello world！</strong><br> 那么用 <strong>C++</strong> 如何打印呢?很简单。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
using namespace std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello world!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>运行结果：</p> 
<p><img src="https://images2.imgbox.com/7a/ce/VEmRXeYR_o.png" alt="在这里插入图片描述"></p> 
<p>代码解释：</p> 
<p>• 是 Input Output Stream 的缩写，是标准的输⼊、输出流库，定义了标准的输⼊、输<br> 出对象。</p> 
<p>• cout/cin/endl等都属于C++标准库，C++标准库都放在⼀个叫std(standard)的命名空间中，所以要通过命名空间的使⽤⽅式去⽤他们。</p> 
<p>• ⼀般⽇常练习中我们可以using namespace std，实际项⽬开发中不建议using namespace std。</p> 
<p>• std::cin 是 istream 类的对象，它主要⾯向窄字符（narrow characters (of type char)）的标准输<br> ⼊流。</p> 
<p>• std::cout 是 ostream 类的对象，它主要⾯向窄字符的标准输出流。</p> 
<p>• std::endl 是⼀个函数，流插⼊输出时，相当于插⼊⼀个<strong>换⾏</strong>字符加刷新缓冲区。</p> 
<p>• &lt;&lt;是流插⼊运算符，&gt;&gt;是流提取运算符。（C语⾔还⽤这两个运算符做位运算左移/右移）</p> 
<p>• 使⽤C++输⼊输出更⽅便，不需要像printf/scanf输⼊输出时那样，需要⼿动指定格式，C++的输⼊输出可以<strong>⾃动识别变量类型</strong>，其实最重要的是C++的流能更好的⽀持<strong>⾃定义类型对象的输⼊输出。</strong></p> 
<p>• 这⾥我们没有包含&lt;stdio.h&gt;，也可以使⽤printf和scanf，在包含间接包含了。vs系列<br> 编译器是这样的，其他编译器可能会报错。</p> 
<p><strong>注意</strong>：在io需求⽐较⾼的地⽅，如部分⼤量输⼊的竞赛题中，加上以下3⾏代码，可以提⾼C++ IO效率：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 在io需求⽐较⾼的地⽅，如部分⼤量输⼊的竞赛题中，加上以下3⾏代码</span>
	<span class="token comment">// 可以提⾼C++IO效率</span>
	ios_base<span class="token operator">::</span><span class="token function">sync_with_stdio</span><span class="token punctuation">(</span>false<span class="token punctuation">)</span><span class="token punctuation">;</span>
	cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span>nullptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span>nullptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="3_266"></a>3.缺省参数</h2> 
<p>在C语言中，函数没有指定参数列表，默认可以接收任意多个参数，但在 C++ 中，因为严格的参数类型检测，没有参数列表的函数，默认为 void，不接收任何参数。</p> 
<h3><a id="31__269"></a>3.1 缺省参数的概念</h3> 
<p>缺省参数是声明或定义函数时为函数的参数指定⼀个缺省值。在调⽤该函数时，如果没有指定实参则采⽤该形参的缺省值，否则使⽤指定的实参，缺省参数分为全缺省和半缺省参数。（有些地⽅把缺省参数也叫默认参数）。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h&gt;</span></span>
using namespace std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span> 

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 没有传参时，使⽤参数的默认值</span>
	<span class="token function">Func</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 传参时，使⽤指定的实参</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>运行结果：<br> <img src="https://images2.imgbox.com/c1/16/7PTp0hIk_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="32__291"></a>3.2 缺省参数的分类</h3> 
<p>缺省参数分为两类：一类是全缺省参数，另一类是半缺省参数。</p> 
<p><strong>（1）全缺省参数</strong></p> 
<p>•全缺省参数所有参数都有默认值，如果没有手动传参，那么编译器会使用默认参数列表中的参数。<br> •但是这里值得注意的是，如果传参的时候只传了部分参数，那么该值会被 <strong>从左至右</strong> 匹配.</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
using namespace std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p><img src="https://images2.imgbox.com/d0/35/A7GrUpdP_o.png" alt="在这里插入图片描述"></p> 
<p><strong>(2)半缺省参数</strong></p> 
<p>半缺省参数，即函数的参数不全是缺省参数。</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">Test1</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token punctuation">,</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">Test2</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>其中 <strong>Test1</strong> 函数至少传一个参数，<strong>Test 2</strong>函数至少传两个参数，函数才可以正常运行。</p> 
<p><strong>注意事项</strong></p> 
<p><strong>(1)半缺省参数必须</strong>从右往左<strong>依次来缺省，不能间隔着给。</strong></p> 
<pre><code class="prism language-c"><span class="token comment">// 错误示例</span>
<span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 正确示例</span>
<span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p><strong>（2）函数声明和定义分离时，缺省参数不能在函数声明和定义中同时出现，规定必须函数声明给缺省值。</strong></p> 
<pre><code class="prism language-c">错误示例：
<span class="token comment">// Test.h（函数声明）</span>
<span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Test.c（函数定义）</span>
<span class="token keyword">void</span> <span class="token function">TestFunc</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//-------------------------------------------</span>

正确示例：
<span class="token comment">// Test.h（函数声明）</span>
<span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Test.c（函数定义）</span>
<span class="token keyword">void</span> <span class="token function">TestFunc</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p><strong>（3）缺省值必须是常量或全局变量</strong></p> 
<pre><code class="prism language-c"><span class="token comment">// 正确示例</span>

<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span> <span class="token comment">//全局变量</span>
<span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token keyword">int</span> c <span class="token operator">=</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<h2><a id="4_403"></a>4.函数重载</h2> 
<p>C++⽀持在同⼀作⽤域中出现同名函数，但是要求这些同名函数的形参不同，<strong>可以是参数个数不同或者类型不同或者参数顺序不同</strong>。这样C++函数调⽤就表现出了多态⾏为，使⽤更灵活。C语⾔是不⽀持同⼀作⽤域中出现同名函数的。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
using namespace std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">double</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">double</span> a<span class="token punctuation">,</span> <span class="token keyword">double</span> b<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">double</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">double</span> b<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token number">5.5</span><span class="token punctuation">,</span> <span class="token number">5.5</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5.5</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>运行结果：<br> <img src="https://images2.imgbox.com/ff/04/vdfzzDfH_o.png" alt="在这里插入图片描述"></p> 
<p><strong>注意: 返回值不同不能作为重载条件，因为调⽤时也⽆法区分</strong></p> 
<pre><code class="prism language-c"> 
<span class="token comment">//void fxx()</span>
<span class="token comment">//{<!-- --></span>
<span class="token comment">// return 0;</span>
<span class="token comment">//}</span>
<span class="token comment">//</span>
<span class="token comment">//int fxx()</span>
<span class="token comment">//{<!-- --></span>
<span class="token comment">// return 0;</span>
<span class="token comment">//}</span>
</code></pre> 
<h2><a id="5_448"></a>5.引⽤</h2> 
<h3><a id="51_449"></a>5.1引⽤的概念和定义</h3> 
<p>引⽤不是新定义⼀个变量，⽽是给已存在变量取了⼀个别名，编译器不会为引⽤变量开辟内存空间，它和它引⽤的变量共⽤同⼀块内存空间。<br> ⽐如：⽔壶传中李逵，宋江叫"铁⽜"，江湖上⼈称"⿊旋⻛"；林冲，外号豹⼦头；</p> 
<p>使用的基本形式为：<strong>类型&amp; 引⽤别名 = 引⽤对象;</strong></p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
using namespace std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token comment">// 引⽤：b和c是a的别名</span>
	<span class="token keyword">int</span><span class="token operator">&amp;</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">&amp;</span> c <span class="token operator">=</span> a<span class="token punctuation">;</span>
	<span class="token comment">// 也可以给别名b取别名，d相当于还是a的别名</span>
	<span class="token keyword">int</span><span class="token operator">&amp;</span> d <span class="token operator">=</span> b<span class="token punctuation">;</span>
	<span class="token operator">++</span>d<span class="token punctuation">;</span>
	<span class="token comment">// 这⾥取地址我们看到是⼀样的</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>d <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/b7/1b/FzBGJG89_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="52__479"></a>5.2 引⽤的特性</h3> 
<p><strong>（1）引⽤在定义时必须初始化</strong></p> 
<p>错误用法：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> b<span class="token punctuation">;</span> <span class="token comment">// 定义b时，没有进行初始化</span>
b <span class="token operator">=</span> a<span class="token punctuation">;</span>

</code></pre> 
<p>正确用法：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// 定义时必须初始化</span>

</code></pre> 
<p><strong>（2）⼀个变量可以有多个引⽤</strong></p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> c <span class="token operator">=</span> a<span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> d <span class="token operator">=</span> a<span class="token punctuation">;</span>

</code></pre> 
<p>此时，b、c、d都是变量a的引用。</p> 
<p><strong>（3）引⽤⼀旦引⽤⼀个实体，再不能引⽤其他实体</strong></p> 
<p>创建一个 <strong>变量 a</strong>，再创建一个 <strong>变量 b</strong>，那么<strong>b</strong>是<strong>a</strong>的引用。</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>

</code></pre> 
<p>那么我再创建一个<strong>变量 c</strong>，想让 <strong>b</strong>成为<strong>c</strong>的引用。</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>

<span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
b <span class="token operator">=</span> c<span class="token punctuation">;</span>

</code></pre> 
<p>注意:此时，<strong>b已经是a的引用了，b不能再引用其他实体</strong>，它是意思是，将b引用的实体赋值为c，也就是将变量 a的内容改成了 20。</p> 
<p>运行结果：<br> <img src="https://images2.imgbox.com/54/a5/W2HaLsQp_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="53_const_536"></a>5.3 const引⽤</h3> 
<p>引用类型必须和引用实体是同种类型的。</p> 
<p>但是仅仅是同种类型，还不能保证能够引用成功，我们若用一个普通引用类型去引用一个被 const 所修饰的类型，那么引用将不会成功。</p> 
<p>我们对于引用取别名的原则是:<strong>对原引用变量，权限只能缩小，不能放大。</strong></p> 
<p><strong>（1）权限变大</strong><br> 下面代码中，<strong>a</strong> 变量用 <strong>const</strong> 修饰，说明变量不能被修改，是只读的，那么我们定义别名的时候，也必须拿const 修饰:</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">//变量a是只读的</span>

	<span class="token comment">//这里的b属于权限的放大，编译会报错</span>
	<span class="token keyword">int</span><span class="token operator">&amp;</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">//b是a的别名，但b是可读可写的</span>

	<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> c <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">//c是a的别名，和a一样，c是只读的</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>可以看到，编译会报错：<br> <img src="https://images2.imgbox.com/ca/c7/Ic3Ctl4V_o.png" alt="在这里插入图片描述"></p> 
<p><strong>（2）权限变小</strong><br> 下面代码中，<strong>a</strong> 变量的内容是 <strong>可读可写</strong> 的，也就是说此时权限是最大的，那么我们可以控制b的权限，让它变成只读:</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">//可读可写</span>

	<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">//只读权限</span>

	<span class="token comment">//打印b（读权限）</span>
	cout <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	<span class="token comment">//这里如果再对b进行修改，会报错</span>
	b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>可以看到，编译会报错：<br> <img src="https://images2.imgbox.com/be/63/Fa41QJKT_o.png" alt="在这里插入图片描述"><br> <strong>（3）临时变量</strong></p> 
<p>需要注意的是类似 <strong>int&amp; rb = a*3; double d = 12.34; int&amp; rd = d;</strong> 这样⼀些场景下a*3的和结果保存在⼀个临时对象中， int&amp; rd = d 也是类似，在类型转换中会产⽣临时对象存储中间值，也就是，rb和rd引⽤的都是临时对象，⽽C++规定临时对象具有常性，所以这⾥就触发了权限放⼤，必须要⽤常引⽤才可以。</p> 
<p>所谓临时对象就是编译器需要⼀个空间暂存表达式的求值结果时临时创建的⼀个未命名的对象，<br> C++中把这个未命名对象叫做临时对象。</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">2.2</span><span class="token punctuation">;</span>
	
	<span class="token keyword">int</span><span class="token operator">&amp;</span> a <span class="token operator">=</span> d<span class="token punctuation">;</span> <span class="token comment">//编译不通过，会报错</span>
	
	<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> b <span class="token operator">=</span> d<span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>可以看到，编译会报错：<br> <img src="https://images2.imgbox.com/26/a5/FGix4WaN_o.png" alt="在这里插入图片描述"><br> <strong>总结:</strong><br> ·const 引用的好处是保护实参，避免被误改，且它可以传普通对象也可以传 const 对象。<br> 函数传参如果想减少拷贝使用引用传参，如果函数中不改变这个参数最好使用 const 引用传参.。</p> 
<h3><a id="54__610"></a>5.4 使用场景</h3> 
<p>引⽤在实践中主要是于引⽤传参和引⽤做返回值中<strong>减少拷⻉提⾼效率和改变引⽤对象时同时改变被引⽤对象。</strong></p> 
<p><strong>（1）做参数</strong></p> 
<p>在 C 语言中，我们学习过 交换函数，当时深入剖析了 <strong>传值</strong> 和 <strong>传址</strong>。</p> 
<p>现在我们学习了<strong>引用</strong>，可以不用 <strong>传址</strong> 了。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
using namespace std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">Swap1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> p2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token operator">*</span>p1<span class="token punctuation">;</span>
	<span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">*</span>p2<span class="token punctuation">;</span>
	<span class="token operator">*</span>p2 <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">Swap2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> rx<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> ry<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> temp <span class="token operator">=</span> rx<span class="token punctuation">;</span>
	rx <span class="token operator">=</span> ry<span class="token punctuation">;</span>
	ry <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>

	<span class="token function">Swap1</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// C传参</span>
	<span class="token function">Swap2</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// C++传参</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>因为这里 rx 和 ry 是传入实参的引用，我们将x和y的值交换，就相当于将传入的两个实参交换了。</p> 
<p><strong>(2)做返回值</strong></p> 
<p>思考一下为什么需要使用 <strong>引用</strong> 来做返回值呢?</p> 
<p>下面这段代码中，我在 Cout 函数里面定义了一个静态变量，那么出了作用域以后，n不会被销毁,如果我们使用传值返回的话，会产生一个临时变量，意味着会有一个临时拷贝，那么程序的效率也就降低了。</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">Cout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	n<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">Cout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> ret <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	ret <span class="token operator">=</span> <span class="token function">Cout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> ret <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>所以我们可以给 Cout 函数的返回值加上一个引用，那么当我们返回n时，主函数里面使用 ret 来接收，那么这个ret 就是n的别名，也就是说，传引用返回以后，就没有生成一个临时拷贝了，函数返回的直接就是返回变量的别名。</p> 
<p>代码如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">Cout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	n<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">Cout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> ret <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	ret <span class="token operator">=</span> <span class="token function">Cout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> ret <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>但是要特别注意，我们返回的数据不能是函数内部创建的普通局部变量，因为在函数内部定义的普通的局部变量会随着函数调用的结束而被销毁。</p> 
<p>我们返回的数据必须是被 <strong>static 修饰</strong>，或者是 <strong>动态开辟</strong> 的，再或者是 <strong>全局变量</strong> 等一些不会随着函数调用的结束而被销毁的数据。</p> 
<p><strong>总结:</strong></p> 
<p>如果函数返回时，出了函数作用域，返回对象还未还给系统，则可以使用引用返回；</p> 
<p>如果已经还给系统了，则必须使用传值返回。</p> 
<h3><a id="55__706"></a>5.5 指针和引⽤的关系</h3> 
<p>C++中指针和引⽤就像两个性格迥异的亲兄弟，指针是哥哥，引⽤是弟弟，在实践中他们相辅相成，功能有重叠性，但是各有⾃⼰的特点，互相不可替代。</p> 
<p>• 语法概念上引⽤是⼀个变量的取别名不开空间，指针是存储⼀个变量地址，要开空间。</p> 
<p>• 引⽤在定义时必须初始化，指针建议初始化，但是语法上不是必须的。</p> 
<p>• 引⽤在初始化时引⽤⼀个对象后，就不能再引⽤其他对象；⽽指针可以在不断地改变指向对象。</p> 
<p>• 引⽤可以直接访问指向对象，指针需要解引⽤才是访问指向对象。</p> 
<p>• sizeof中含义不同，引⽤结果为引⽤类型的⼤⼩，但指针始终是地址空间所占字节个数(32位平台下占4个字节，64位下是8byte)</p> 
<p>• 指针很容易出现空指针和野指针的问题，引⽤很少出现，引⽤使⽤起来相对更安全⼀些。</p> 
<h2><a id="6_721"></a>6.内联函数</h2> 
<h3><a id="61_722"></a>6.1内联函数概念</h3> 
<p>⽤inline修饰的函数叫做内联函数，编译时C++编译器会在调⽤的地⽅展开内联函数，这样调⽤内联函数就不需要建⽴栈帧了，就可以提⾼效率。</p> 
<p>代码示例：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
using namespace std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	ret <span class="token operator">=</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>这就是一个简单的 <strong>加法</strong> 函数，我们可以转到 <strong>反汇编</strong>，然后能看到调用栈帧的过程(call 指令用于调用其他函数)</p> 
<p><img src="https://images2.imgbox.com/33/21/vTXTpNTh_o.png" alt="在这里插入图片描述"></p> 
<p>如果在上述函数前增加 inline 关键字将其改成内联函数，在编译期间编译器会用函数体替换函数的调用。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
using namespace std<span class="token punctuation">;</span>

<span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	ret <span class="token operator">=</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p><img src="https://images2.imgbox.com/78/20/zVh4NVj7_o.png" alt="在这里插入图片描述"><br> 从汇编代码中可以看出，内联函数调用时并没有调用函数这个过程的汇编指令。</p> 
<h3><a id="62__770"></a>6.2 内敛函数的特性</h3> 
<p>(1)<strong>inline</strong> 是一种以空间换时间的做法，省去调用函数额开销。所以 <strong>代码很长</strong> 或者 <strong>有循环</strong> 或者 <strong>有递归</strong> 的函数不适宜使用作为内联函数。</p> 
<p>(2)<strong>inline</strong> 对于编译器而言只是一个建议，编译器会自动优化，如果定义为 inline 的函数体内 <strong>有循环</strong> 或者<strong>有递归</strong> 等等，编译器优化时会忽略掉内联。</p> 
<p>(3)inline 不建议声明和定义分离，分离会导致链接错误。因为 <strong>inline</strong> 被展开，就没有函数地址了，链接就会找不到。</p> 
<pre><code class="prism language-c"><span class="token comment">// F.h</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
using namespace std<span class="token punctuation">;</span>
<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// F.cpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"F.h"</span></span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
 cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Test.cpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"F.h"</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
 <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>可以看到，编译时会报错：</p> 
<p><img src="https://images2.imgbox.com/44/9b/S4qbdXaL_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="7nullptr_802"></a>7.指针空值nullptr</h2> 
<p>这也是C++11中的特性</p> 
<h3><a id="71_C98_805"></a>7.1 C++98中的指针空值</h3> 
<p>在良好的 C/C++ 编程习惯中，声明一个变量时最好给该变量一个合适的初始值，否则可能会出现不可预料错误，比如未初始化的指针。</p> 
<p>如果一个指针没有合法的指向，我们基本都是按照如下方式对其进行初始化。</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">TestPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span>
 	<span class="token keyword">int</span><span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
 	<span class="token keyword">int</span><span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>NULL实际是⼀个宏，在传统的C头⽂件(stddef.h)中，可以看到如下代码：</p> 
<pre><code class="prism language-c"><span class="token comment">/* Define NULL pointer value */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression"><span class="token constant">NULL</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__cplusplus</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span>    <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span>  <span class="token comment">/* __cplusplus */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span>    <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span>  <span class="token comment">/* __cplusplus */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span>  <span class="token comment">/* NULL */</span></span>

</code></pre> 
<p>可以看到，NULL可能被定义为字⾯常量0，或者C中被定义为⽆类型指针(void*)的常量。不论采取何种定义，在使⽤空值的指针时，都不可避免的会遇到⼀些⿇烦。</p> 
<p>比如：本想通过f(NULL)调⽤指针版本的f(int*)函数，但是由于NULL被定义成0，调⽤了f(int x)，因此与程序的初衷相悖。f((void*)NULL);调⽤会报错。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
using namespace std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f(int)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f(int*)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//调用f(int)</span>
	<span class="token function">f</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//也是调用f(int)</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>程序本意是想通过 f(NULL)调用指针版本的 f(int*)函数，但是由于 NULL 被定义成0，所以 f(NULL)最终调用的是 f(int)函数。</p> 
<p><strong>注意:</strong></p> 
<p>•·在 C++98 中，字面常量0既可以是一个整形数字，也可以是无类型的指针(void*)常量。</p> 
<p>•但是编译器默认情况下将其看成是一个整形常量，如果要将其按照指针方式来使用，必须对其进行强转(void *)0 。</p> 
<h3><a id="72_C11_867"></a>7.2 C++11中的指针空值</h3> 
<p>对于 <strong>C++98</strong> 存在的问题，<strong>C++11</strong> 引入了关键字 <strong>nullptr</strong>。</p> 
<p>但是，还得注意:</p> 
<p>(1)在使用 <strong>nullptr</strong> 表示指针空值时，不需要包含头文件，因为 <strong>nullptr</strong> 是 <strong>C++11</strong> 作为新关键字引入的。</p> 
<p>(2)在C++11中，**sizeof(nullptr)**与 *<em>sizeof((void</em>)0)**所占的字节数相同。</p> 
<p>(3)为了提高代码的健壮性，在后续表示指针空值时建议最好使用 <strong>nullptr</strong>。</p> 
<h2><a id="8__879"></a>8 <strong>总结</strong></h2> 
<p>这是 C++ 入门的第一篇，学习 C++ 语言就像学一门活跃使用中的外语，你不要期望能够掌握所有的单词和语法规则一那对于世界上 99.999999% 的人来说是不可能的。但语言是服务于人的，语法规则也是服务于人的，是为了让人们能够更好地沟通和表达。</p> 
<p>虽然C++的每一个新标准都是让语言从定义和规则的角度变得更复杂，但从用法上来说，新标准允许人们能够更简单地表达自己的计算意图。跟学外语一样，我们需要的是多看多写，掌握合适的“语感”，而不是记住所有的规则。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fa00a6b69242ea357c2a73f640c2dc0f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python酷库之旅-第三方库Pandas(022)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/47cf51ab1658c6da75a3a50788325932/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Rust】——不安全Rust</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>