<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【JavaEE精炼宝库】多线程（7）定时器 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/efd4d32bec9cef4e042c7007c3cd3003/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【JavaEE精炼宝库】多线程（7）定时器">
  <meta property="og:description" content="目录
一、定时器的概念
二、标准库中的定时器
三、自己实现一个定时器
3.1 MyTimerTask 实现：
3.2 MyTimer 实现：
一、定时器的概念 定时器也是软件开发中的⼀个重要组件。类似于一个 &#34;闹钟&#34;。达到一个设定的时间之后，就执行某个指定好的代码（可以用来完成线程池里面的非核心线程的超时回收）。
定时器是一种实际开发中非常常用的组件。 比如网络通信中，如果对方 500ms 内没有返回数据，则断开连接尝试重连。比如⼀个 Map，希望里面的某个 key 在 3s 之后过期(自动删除)。类似于这样的场景就需要用到定时器。
二、标准库中的定时器 标准库中提供了⼀个 Timer 类。Timer 类的核心方法为 schedule。
schedule 包含两个参数。第⼀个参数指定即将要执行的任务代码，第二个参数指定多长时间之后 执行（单位为毫秒）。如下：
其中第一个参数 TimerTask 是一个抽象类，本质上还是实现了 Runnable 接口，所以我们就可以把它当作 Runnable 来使用即可。 • 使用演示：
public class Main { public static void main(String[] args) { Timer timer = new Timer(); timer.schedule(new TimerTask() { @Override public void run() { System.out.println(&#34;hello 3000&#34;); } },3000); timer.schedule(new TimerTask() { @Override public void run() { System.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-20T12:47:26+08:00">
    <meta property="article:modified_time" content="2024-06-20T12:47:26+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【JavaEE精炼宝库】多线程（7）定时器</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">一、定时器的概念</a></p> 
<p id="%E4%BA%8C%E3%80%81%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84%E5%AE%9A%E6%97%B6%E5%99%A8-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84%E5%AE%9A%E6%97%B6%E5%99%A8" rel="nofollow">二、标准库中的定时器</a></p> 
<p id="%C2%A0%E4%B8%89%E3%80%81%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6%E5%99%A8-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%B8%89%E3%80%81%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6%E5%99%A8" rel="nofollow">三、自己实现一个定时器</a></p> 
<p id="3.1%20MyTimerTask%20%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc" style="margin-left:40px;"><a href="#3.1%20MyTimerTask%20%E5%AE%9E%E7%8E%B0%EF%BC%9A" rel="nofollow">3.1 MyTimerTask 实现：</a></p> 
<p id="3.2%20MyTimer%20%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc" style="margin-left:40px;"><a href="#3.2%20MyTimer%20%E5%AE%9E%E7%8E%B0%EF%BC%9A" rel="nofollow">3.2 MyTimer 实现：</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E6%A6%82%E5%BF%B5">一、定时器的概念</h2> 
<p>定时器也是软件开发中的⼀个重要组件。类似于一个 "闹钟"。达到一个设定的时间之后，就执行某个指定好的代码（可以用来完成线程池里面的非核心线程的超时回收）。</p> 
<p><img alt="" height="566" src="https://images2.imgbox.com/e8/e1/9bF9tmEb_o.png" width="985"></p> 
<p>定时器是一种实际开发中非常常用的组件。 比如网络通信中，如果对方 500ms 内没有返回数据，则断开连接尝试重连。比如⼀个 Map，希望里面的某个 key 在 3s 之后过期(自动删除)。类似于这样的场景就需要用到定时器。</p> 
<h2 id="%E4%BA%8C%E3%80%81%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84%E5%AE%9A%E6%97%B6%E5%99%A8">二、标准库中的定时器</h2> 
<p><strong>标准库中提供了⼀个 Timer 类。Timer 类的核心方法为 schedule。</strong></p> 
<p><img alt="" height="743" src="https://images2.imgbox.com/22/17/zRWwdyXj_o.png" width="1200"></p> 
<p>schedule 包含两个参数。第⼀个参数指定即将要执行的任务代码，第二个参数指定多长时间之后 执行（单位为毫秒）。如下：</p> 
<p><img alt="" height="224" src="https://images2.imgbox.com/5f/8e/kDLpNIRE_o.png" width="1200"></p> 
<p><span style="color:#fe2c24;">其中第一个参数 TimerTask 是一个抽象类，本质上还是实现了 Runnable 接口，所以我们就可以把它当作 Runnable 来使用即可。</span><img alt="" height="119" src="https://images2.imgbox.com/2e/36/heg8h24S_o.png" width="910"> </p> 
<p>• 使用演示：</p> 
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        Timer timer = new Timer();
        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                System.out.println("hello 3000");
            }
        },3000);
        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                System.out.println("hello 2000");
            }
        },2000);
        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                System.out.println("hello 1000");
            }
        },1000);
    }
}</code></pre> 
<p>案例效果演示：</p> 
<p>会间隔对应的时间打印。</p> 
<p><img alt="" height="645" src="https://images2.imgbox.com/20/94/GOB8D7XB_o.png" width="1200"></p> 
<h2 id="%C2%A0%E4%B8%89%E3%80%81%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6%E5%99%A8">三、自己实现一个定时器</h2> 
<p>我们在写代码之前要想好我们的需求是什么，也就是我们要实现什么，<span style="color:#fe2c24;">我们定时器的需求：1. 是能够延时执行任务 / 指定时间执行任务。2. 能够管理多个任务。</span></p> 
<h3 id="3.1%20MyTimerTask%20%E5%AE%9E%E7%8E%B0%EF%BC%9A">3.1 MyTimerTask 实现：</h3> 
<p>首先我们先实现任务，可以实现 Runnable 接口，或者采用把 Runnable 作为类参数，来进行实现。这里我们采用把 Runnable 作为类参数来进行实现。为了起到延时的效果，我们还需要一个 time 参数来保存绝对的时间。</p> 
<p><span style="color:#fe2c24;">为什么需要绝对时间呢？</span></p> 
<p>答：这个其实很好理解，我们举一个栗子来解释：假如现在是早上 9 点，领导让你 1 小时之后去找他，也就是说我们应该在早上 10 点左右去找他，但是如果我们只是记录 1 个小时，那么随着时间的推移，我们不能够知道这个 1 小时之后，是哪个时间点的。当然我们可以采用倒计时的方法来实现，但是这样我们还要不停的维护，这个倒计时，倒不如直接记录绝对时间来的简单。</p> 
<p><span style="color:#fe2c24;">这里我们还需要实现 Comparable 接口，为什么还需要实现这个接口呢？</span></p> 
<p>答：在 Timer 类中，任务不仅仅只有一个，且绝对时间大小与进入队列的顺序没有绝对关系，那么我们如何在队列中快速找到绝对时间最小的任务呢（如果绝对时间最小的任务都不满足执行时间，那么后面的任务绝对也不满足）？显然需要使用到<strong>优先级队列（小根堆）来存储任务</strong>，但是我们自定义的类不能比较，所以我们需要实现 Comparable 接口来重写 CompareTo 方法。</p> 
<p>具体代码如下：</p> 
<pre><code class="language-java">class MyTimerTask implements Comparable&lt;MyTimerTask&gt; {
    private long time;//绝对时间
    private Runnable runnable;//加上 private 体现封装性

    public MyTimerTask(Runnable runnable, long time) {
        this.runnable = runnable;
        this.time = time + System.currentTimeMillis();//绝对时间
    }

    public void run() {//方便后续调用
        runnable.run();
    }
    public long getTime(){
        return time;
    }

    //重写比较器,从小到大排序
    @Override
    public int compareTo(MyTimerTask o) {
        return this.time &gt;= o.time ? 1 : -1;
    }
}
</code></pre> 
<h3 id="3.2%20MyTimer%20%E5%AE%9E%E7%8E%B0%EF%BC%9A">3.2 MyTimer 实现：</h3> 
<p>这个就是我们要实现的定时器，通过上面在 MyTimerTask 的分析可知，我们这里需要优先级队列来辅助管理任务。同时还需要一个线程来不停的执行队列中的任务，并且还要提供一个 schedule 方法。所以总共要实现的东西有：</p> 
<p>• 线程</p> 
<p>• 优先级队列（小根堆）</p> 
<p>• schedule 方法</p> 
<p>• 保证线程安全（通过使用锁的方式要实现）</p> 
<p><span style="color:#fe2c24;">注意：这里我们不使用 Java 自带的优先级阻塞队列，原因是：优先级阻塞队列本身内部就有一个锁，我们为了保证线程安全，外面还要加一层锁，如果使用阻塞队列，那就是两个锁嵌套的情况，一不小心就会出现死锁的情况，所以倒不如我们同一处理，只使用一个锁即可。在自己实现阻塞队列的时候不能使用 continue 来循环等待（“忙等”），这样很消耗 CPU 资源，也不能使用 sleep 来进行阻塞，因为 sleep 不能释放锁（抱着锁睡），线程睡了就真的睡了，综上我们选择采用 wait 的方式来进行阻塞。</span></p> 
<p>还有一些小细节在代码中都有标注释，这里就不再赘述了。 </p> 
<p><strong>具体代码如下：</strong></p> 
<p><strong>• 大体框架：</strong></p> 
<p>线程一直不停的扫描队首元素，看看是否能执行这个任务。</p> 
<pre><code class="language-java">class MyTimer {
    private Object locker = new Object();
    //不用阻塞优先级队列，因为有两个锁，一不小心就死锁了
    private PriorityQueue&lt;MyTimerTask&gt; heap = new PriorityQueue&lt;MyTimerTask&gt;();//因为有实现 comparable 所以 不用再传入比较器
    public MyTimer(){
        Thread thread = new Thread(() -&gt; {
            try{
                while (true) {
                    synchronized (locker) {
                        if (heap.isEmpty()) {
                            locker.wait();
                        }
                        MyTimerTask tmp = heap.peek();
                        long curTime = System.currentTimeMillis();
                        if (curTime &gt;= tmp.getTime()) {
                            //执行
                            tmp.run();
                            heap.poll();
                        } else {
                            //时间还未到
                            locker.wait(tmp.getTime() - curTime);
                        }
                    }
                }
            }catch(InterruptedException e){//把异常统一处理
                throw new RuntimeException(e);
            }
        });
        thread.start();//线程启动
    }
}
</code></pre> 
<p><strong>• schedule 方法：</strong></p> 
<p> Timer 类提供的核心方法为 schedule，用于注册一个任务，并指定这个任务多长时间后执行。这里加上锁有两个原因：1. 保证线程安全。2. 唤醒执行队列元素线程（如果在 wait 中的话）。</p> 
<pre><code class="language-java">public void schedule(Runnable runnable,long delay){
        synchronized(locker){
            MyTimerTask task = new MyTimerTask(runnable,delay);
            heap.add(task);
            locker.notify();//这里必须要唤醒一下，因为添加新的任务后，绝对时间最小的不一定就是栈顶元素，要把新加入的元素一起考虑一下。
        }
    }</code></pre> 
<p>• 验证正确性：</p> 
<p>还是上面在演示标准库 Timer 那里的案例。</p> 
<pre><code class="language-java">public class demo1 {

    public static void main(String[] args) {
        MyTimer timer = new MyTimer();
        timer.schedule(new Runnable() {
            @Override
            public void run() {
                System.out.println("hello 3000");
            }
        },3000);
        timer.schedule(new Runnable() {
            @Override
            public void run() {
                System.out.println("hello 2000");
            }
        },2000);
        timer.schedule(new Runnable() {
            @Override
            public void run() {
                System.out.println("hello 1000");
            }
        },1000);
    }
}</code></pre> 
<p>案例演示效果如下：</p> 
<p>可以看到符合我们预期的效果🎉🎉🎉</p> 
<p><img alt="" height="612" src="https://images2.imgbox.com/4b/52/gp8NaQWh_o.png" width="1200"></p> 
<p>我们现在实现的是单线程的定时器，也可以实现多线程的定时器，只需要加个 List 来管理多个线程即可。</p> 
<p><span style="color:#fe2c24;">这里可能有的友友就有疑问：这样保证不了准时执行，在一个时间段，如果任务非常多的情况下。</span></p> 
<p>其实无论如何都无法保证时间准的，只要你短时间内插入海量的任务，超过了 CPU 能够负担的极限都会不准，我们最多能做的就是把误差控制到一定的范围（加硬件）。</p> 
<p><strong>结语：</strong></p> 
<p><strong>其实写博客不仅仅是为了教大家，同时这也有利于我巩固知识点，和做一个学习的总结，由于作者水平有限，对文章有任何问题还请指出，非常感谢。如果大家有所收获的话还请不要吝啬你们的点赞收藏和关注，这可以激励我写出更加优秀的文章。</strong></p> 
<p><img alt="" height="400" src="https://images2.imgbox.com/1e/24/WbBS3dFp_o.png" width="1080"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5306a388060f29d6b8a436b4bba126fe/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据库系统概论——数据库恢复技术</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/08b812a676fb3519935bd06ac5d0e002/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spacedrive：一个开源的跨平台文件管理器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>