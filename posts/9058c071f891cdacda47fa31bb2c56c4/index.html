<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【java】HashMap底层实现原理 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/9058c071f891cdacda47fa31bb2c56c4/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【java】HashMap底层实现原理">
  <meta property="og:description" content="目录 一.哈希表(散列)1.什么是哈希表2.什么是哈希冲突(面试题)3.解决哈希冲突的方法(面试题)(1) 开放地址法① 线性探查②二次探查③随机探查 (2) 再哈希法(3) 链地址法(4)建立公共溢出区 二.HashMap1.HashMap的hash()算法(面试)(1)为什么不是`h = key.hashCode()`直接返回，而要 `h = key.hashCode() ^ (h &gt;&gt;&gt; 16)`来计算哈希值呢？(2)为什么HashMap的初始容量和扩容都是2的次幂(3)如果指定了不是2的次幂的容量会发生什么？ 2.HashMap为什么线程不安全(面试题)(1) 多线程下扩容造成的死循环和数据丢失(jdk1.7)(2)数据覆盖(jdk1.8) 3.HashMap解决线程不安全(面试题)(1) 使用HashTable解决线程不安全问题(弃用)(2)HashMap和HashTable的区别(3)Collections.synchronizedMap(不常用)(4)ConcurrentHashMap(常用) 4.为什么使用synchronized替换ReentrantLock锁呢？4.HashMap底层 数组 &#43; 链表 / 红黑树(面试题)(1)HashMap为什么引入链表(2)HashMap为什么引入红黑树(3)为什么不一开始就使用红黑树(4)说说你对红黑树的理解(5) 红黑树为什么要变色、左旋和右旋操作 5.HashMap链表和红黑树转换(面试题)(1) 为什么链表长度大于8，并且表的长度大于64的时候，链表会转换成红黑树？(2) 为什么转成红黑树是8呢？而重新转为链表阈值是6呢？(3) 为什么负载因子是0.75？ 6.HashMap扩容(面试题)(1)什么时候会发生扩容？(2)为什么不是满了扩容？(3)扩容过程 一.哈希表(散列) 1.什么是哈希表 根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。
给定表M，存在函数H(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash)表，函数H(key)为哈希(Hash)函数。
2.什么是哈希冲突(面试题) 根据一定的规则放进存放哈希值的数组中，然后下标为1的数组已经有值了，后面根据规则，判定某个数也需要放到下标为1的数组中，这样就导致了只有一个位置两个人都要坐，就引起了冲突。(不同的key值产生的H(key)是一样的)。
3.解决哈希冲突的方法(面试题) (1) 开放地址法 插入一个元素的时候，先通过哈希函数进行判断，若是发生哈希冲突，就以当前地址为基准，根据再寻址的方法（探查序列），去寻找下一个地址，若发生冲突再去寻找，直至找到一个为空的地址为止。所以这种方法又称为再散列法。
Hi=(H(key)&#43;di)%m //开放地址法计算下标公式 Hi：下标(储存的地址) H(key)：哈希函数(计算哈希值) di：增量 %：取模 m：哈希表的长度 探查方法如下
① 线性探查 di=1,2,3,…m-1；冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。
②二次探查 di=1^2, -1^2, 2^2, -2^2 …k^2, -k^2,(k&lt;=m/2)； 冲突发生时，在表的左右进行跳跃式探测，比较灵活。
③随机探查 di=伪随机数序列；冲突发生时，建立一个伪随机数发生器（如i=(i&#43;p) % m），p是质数(在m范围取得质数)，生成一个伪随机序列，并给定一个随机数做起点，每次加上伪随机数&#43;&#43;就行。
为了更好的理解，我们举一个例子
设哈希表长为14，哈希函数为H(key)=key%11。表中现有数据15、38、61和84，其余位置为空，如果用二次探测再散列处理冲突，则49的位置是？使用线性探测法位置是？ 解：因为H(key)=key%11 所以15的位置 = 15 % 11=4; 38的位置 = 38 % 11=5; 61的位置 = 61 % 11=6; 84的位置 = 84 % 11=7;(证明哈希表4,5,6,7已经有元素) 因为计算下标的公式为：Hi=(H(key)&#43;di)mod%m 使用二次探测法 H(1) = (49%11 &#43; 1^1) = 6;冲突 H(-1) = (49%11 &#43; (-1^2)) = 4;冲突 注意 -1^2 = -1; (-1)^2 = 1; H(2) = (49%11 &#43; 2^2) = 9;不冲突 二次探测法49的位置就是哈希表的9。 使用线性探测 H(1) = (49%11 &#43; 1) = 6;冲突 H(2) = (49%11 &#43; 2) = 7;冲突 H(3) = (49%11 &#43; 3) = 8;不冲突 线性探测法49的位置就是哈希表的8。 (2) 再哈希法 再哈希法又叫双哈希法，有多个不同的Hash函数，当发生冲突时，使用第二个，第三个，….">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-03-17T10:08:19+08:00">
    <meta property="article:modified_time" content="2023-03-17T10:08:19+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【java】HashMap底层实现原理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">一.哈希表(散列)</a></li><li><ul><li><a href="#1_2" rel="nofollow">1.什么是哈希表</a></li><li><a href="#2_7" rel="nofollow">2.什么是哈希冲突(面试题)</a></li><li><a href="#3_10" rel="nofollow">3.解决哈希冲突的方法(面试题)</a></li><li><ul><li><a href="#1__11" rel="nofollow">(1) 开放地址法</a></li><li><ul><li><a href="#__25" rel="nofollow">① 线性探查</a></li><li><a href="#_27" rel="nofollow">②二次探查</a></li><li><a href="#_29" rel="nofollow">③随机探查</a></li></ul> 
    </li><li><a href="#2__54" rel="nofollow">(2) 再哈希法</a></li><li><a href="#3__58" rel="nofollow">(3) 链地址法</a></li><li><a href="#4_66" rel="nofollow">(4)建立公共溢出区</a></li></ul> 
  </li></ul> 
  </li><li><a href="#HashMap_69" rel="nofollow">二.HashMap</a></li><li><ul><li><a href="#1HashMaphash_70" rel="nofollow">1.HashMap的hash()算法(面试)</a></li><li><ul><li><a href="#1h__keyhashCode_h__keyhashCode__h__16_71" rel="nofollow">(1)为什么不是`h = key.hashCode()`直接返回，而要 `h = key.hashCode() ^ (h &gt;&gt;&gt; 16)`来计算哈希值呢？</a></li><li><a href="#2HashMap2_130" rel="nofollow">(2)为什么HashMap的初始容量和扩容都是2的次幂</a></li><li><a href="#32_170" rel="nofollow">(3)如果指定了不是2的次幂的容量会发生什么？</a></li></ul> 
   </li><li><a href="#2HashMap_245" rel="nofollow">2.HashMap为什么线程不安全(面试题)</a></li><li><ul><li><a href="#1_jdk17_246" rel="nofollow">(1) 多线程下扩容造成的死循环和数据丢失(jdk1.7)</a></li><li><a href="#2jdk18_335" rel="nofollow">(2)数据覆盖(jdk1.8)</a></li></ul> 
   </li><li><a href="#3HashMap_351" rel="nofollow">3.HashMap解决线程不安全(面试题)</a></li><li><ul><li><a href="#1_HashTable_352" rel="nofollow">(1) 使用HashTable解决线程不安全问题(弃用)</a></li><li><a href="#2HashMapHashTable_356" rel="nofollow">(2)HashMap和HashTable的区别</a></li><li><a href="#3CollectionssynchronizedMap_378" rel="nofollow">(3)Collections.synchronizedMap(不常用)</a></li><li><a href="#4ConcurrentHashMap_389" rel="nofollow">(4)ConcurrentHashMap(常用)</a></li></ul> 
   </li><li><a href="#4synchronizedReentrantLock_403" rel="nofollow">4.为什么使用synchronized替换ReentrantLock锁呢？</a></li><li><a href="#4HashMap______419" rel="nofollow">4.HashMap底层 数组 + 链表 / 红黑树(面试题)</a></li><li><ul><li><a href="#1HashMap_421" rel="nofollow">(1)HashMap为什么引入链表</a></li><li><a href="#2HashMap_424" rel="nofollow">(2)HashMap为什么引入红黑树</a></li><li><a href="#3_426" rel="nofollow">(3)为什么不一开始就使用红黑树</a></li><li><a href="#4_429" rel="nofollow">(4)说说你对红黑树的理解</a></li><li><a href="#5__443" rel="nofollow">(5) 红黑树为什么要变色、左旋和右旋操作</a></li></ul> 
   </li><li><a href="#5HashMap_448" rel="nofollow">5.HashMap链表和红黑树转换(面试题)</a></li><li><ul><li><a href="#1_864_452" rel="nofollow">(1) 为什么链表长度大于8，并且表的长度大于64的时候，链表会转换成红黑树？</a></li><li><a href="#2_86_500" rel="nofollow">(2) 为什么转成红黑树是8呢？而重新转为链表阈值是6呢？</a></li><li><a href="#3_075_505" rel="nofollow">(3) 为什么负载因子是0.75？</a></li></ul> 
   </li><li><a href="#6HashMap_521" rel="nofollow">6.HashMap扩容(面试题)</a></li><li><ul><li><a href="#1_522" rel="nofollow">(1)什么时候会发生扩容？</a></li><li><a href="#2_527" rel="nofollow">(2)为什么不是满了扩容？</a></li><li><a href="#3_531" rel="nofollow">(3)扩容过程</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>一.哈希表(散列)</h2> 
<h3><a id="1_2"></a>1.什么是哈希表</h3> 
<blockquote> 
 <p>根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p> 
</blockquote> 
<blockquote> 
 <p>给定表M，存在函数H(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash)表，函数H(key)为哈希(Hash)函数。</p> 
</blockquote> 
<h3><a id="2_7"></a>2.什么是哈希冲突(面试题)</h3> 
<blockquote> 
 <p>根据一定的规则放进存放哈希值的数组中，然后下标为1的数组已经有值了，后面根据规则，判定某个数也需要放到下标为1的数组中，这样就导致了只有一个位置两个人都要坐，就引起了冲突。(不同的key值产生的H(key)是一样的)。</p> 
</blockquote> 
<h3><a id="3_10"></a>3.解决哈希冲突的方法(面试题)</h3> 
<h4><a id="1__11"></a>(1) 开放地址法</h4> 
<blockquote> 
 <p>插入一个元素的时候，先通过哈希函数进行判断，若是发生哈希冲突，就以当前地址为基准，根据再寻址的方法（探查序列），去寻找下一个地址，若发生冲突再去寻找，直至找到一个为空的地址为止。所以这种方法又称为再散列法。</p> 
</blockquote> 
<pre><code class="prism language-xml">Hi=(H(key)+di)%m  //开放地址法计算下标公式
Hi：下标(储存的地址)
H(key)：哈希函数(计算哈希值)
di：增量
%：取模
m：哈希表的长度
</code></pre> 
<p>探查方法如下</p> 
<h5><a id="__25"></a>① 线性探查</h5> 
<blockquote> 
 <p>di=1,2,3,…m-1；冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。</p> 
</blockquote> 
<h5><a id="_27"></a>②二次探查</h5> 
<blockquote> 
 <p>di=1^2, -1^2, 2^2, -2^2 …k^2, -k^2,(k&lt;=m/2)； 冲突发生时，在表的左右进行跳跃式探测，比较灵活。</p> 
</blockquote> 
<h5><a id="_29"></a>③随机探查</h5> 
<blockquote> 
 <p>di=伪随机数序列；冲突发生时，建立一个伪随机数发生器（如i=(i+p) % m），p是质数(在m范围取得质数)，生成一个伪随机序列，并给定一个随机数做起点，每次加上伪随机数++就行。</p> 
</blockquote> 
<p>为了更好的理解，我们举一个例子</p> 
<pre><code class="prism language-xml">设哈希表长为14，哈希函数为H(key)=key%11。表中现有数据15、38、61和84，其余位置为空，如果用二次探测再散列处理冲突，则49的位置是？使用线性探测法位置是？

解：因为H(key)=key%11
所以15的位置 = 15 % 11=4; 38的位置 = 38 % 11=5; 61的位置 = 61 % 11=6; 84的位置 = 84 % 11=7;(证明哈希表4,5,6,7已经有元素)

因为计算下标的公式为：Hi=(H(key)+di)mod%m
使用二次探测法
H(1) = (49%11 + 1^1) = 6;冲突      
H(-1) = (49%11 + (-1^2)) = 4;冲突   注意 -1^2 = -1; (-1)^2 = 1;
H(2) = (49%11 + 2^2) = 9;不冲突
二次探测法49的位置就是哈希表的9。

使用线性探测
H(1) = (49%11 + 1) = 6;冲突
H(2) = (49%11 + 2) = 7;冲突
H(3) = (49%11 + 3) = 8;不冲突
线性探测法49的位置就是哈希表的8。
</code></pre> 
<h4><a id="2__54"></a>(2) 再哈希法</h4> 
<blockquote> 
 <p>再哈希法又叫双哈希法，有多个不同的Hash函数，当发生冲突时，使用第二个，第三个，….，等哈希函数计算地址，直到无冲突。虽然不易发生聚集，但是增加了计算时间。</p> 
</blockquote> 
<h4><a id="3__58"></a>(3) 链地址法</h4> 
<blockquote> 
 <p>每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来。<br> 比如 66和88这两个元素哈希值都是1，这就发生了哈希冲突，采用链地址法，可以把 66和88放在同一个链表中。如下图</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/dc/fa/tLrPsUTM_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="4_66"></a>(4)建立公共溢出区</h4> 
<blockquote> 
 <p>将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</p> 
</blockquote> 
<h2><a id="HashMap_69"></a>二.HashMap</h2> 
<h3><a id="1HashMaphash_70"></a>1.HashMap的hash()算法(面试)</h3> 
<h4><a id="1h__keyhashCode_h__keyhashCode__h__16_71"></a>(1)为什么不是<code>h = key.hashCode()</code>直接返回，而要 <code>h = key.hashCode() ^ (h &gt;&gt;&gt; 16)</code>来计算哈希值呢？</h4> 
<p><strong>回答：减少哈希冲突</strong></p> 
<pre><code class="prism language-java">	<span class="token comment">//源码：计算哈希值的方法 H(key)</span>
	<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> h<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>   
    <span class="token comment">//^ (异或运算) 相同的二进制数位上，数字相同，结果为0，不同为1。  举例如下：</span>
    <span class="token number">0</span> <span class="token operator">^</span> <span class="token number">0</span> <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token number">0</span> <span class="token operator">^</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token number">1</span> <span class="token operator">^</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token number">1</span> <span class="token operator">^</span> <span class="token number">0</span> <span class="token operator">=</span> <span class="token number">1</span>
	<span class="token comment">// &amp;(与运算)  相同的二进制数位上，都是1的时候，结果为1，否则为零。 举例如下：</span>
	<span class="token number">0</span> <span class="token operator">&amp;</span> <span class="token number">0</span> <span class="token operator">=</span> <span class="token number">0</span>
	<span class="token number">0</span> <span class="token operator">&amp;</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">0</span>
	<span class="token number">1</span> <span class="token operator">&amp;</span> <span class="token number">0</span> <span class="token operator">=</span> <span class="token number">0</span>
	<span class="token number">1</span> <span class="token operator">&amp;</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">1</span>
</code></pre> 
<p><code>h = key.hashCode() ^ (h &gt;&gt;&gt; 16)</code>意思是先获得<code>key</code>的<code>哈希值h</code>，然后 h 和 h右移十六位 做<code>异或</code>运算，运算结果再和 <code>数组长度 - 1</code> 进行 <code>与</code> 运算，计算出储存下标的位置。具体原理如下：</p> 
<pre><code class="prism language-java">综下所述 储存下标 <span class="token operator">=</span> 哈希值 <span class="token operator">&amp;</span> 数组长度 <span class="token operator">-</span> <span class="token number">1</span>

<span class="token comment">//jdk1.7中计算数组下标的HashMap源码</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">indexFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//计算储存元素的数组下标</span>
        <span class="token keyword">return</span> h <span class="token operator">&amp;</span> <span class="token punctuation">(</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//jdk1.8中去掉了indexFor()函数，改为如下</span>
i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash <span class="token comment">//i就是元素存储的数组下标 </span>
</code></pre> 
<p>某个key的哈希值为 ：<strong>1111 1111 1110 1111 0101 0101 0111 0101</strong>，数组初始长度也是16，如果没有 <code>^ h &gt;&gt;&gt; 16</code>，计算下标如下</p> 
<pre><code class="prism language-java">          <span class="token number">1111</span> <span class="token number">1111</span> <span class="token number">1110</span> <span class="token number">1111</span> <span class="token number">0101</span> <span class="token number">0101</span> <span class="token number">0111</span> <span class="token number">0101</span>  <span class="token comment">//h = hashcode()</span>
	   <span class="token operator">&amp;</span>  <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">1111</span>  <span class="token comment">//数组长度 - 1 = 15 (15的二进制就是 1111)</span>
	   <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
	      <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0101</span>  <span class="token comment">//key的储存下标为5</span>

       由上面可知，只相当于取了后面几位进行运算，所以哈希冲突的可能大大增加。
</code></pre> 
<p>以上条件不变，加上 <code>异或h &gt;&gt;&gt; 16</code>，之后在进行下标计算</p> 
<pre><code class="prism language-java">          <span class="token number">1111</span> <span class="token number">1111</span> <span class="token number">1110</span> <span class="token number">1111</span> <span class="token number">0101</span> <span class="token number">0101</span> <span class="token number">0111</span> <span class="token number">0101</span>  <span class="token comment">//h = hashcode()</span>
       <span class="token operator">^</span>  <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">1111</span> <span class="token number">1111</span> <span class="token number">1110</span> <span class="token number">1111</span>  <span class="token comment">//h &gt;&gt;&gt; 16</span>
       <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
          <span class="token number">1111</span> <span class="token number">1111</span> <span class="token number">1110</span> <span class="token number">1111</span> <span class="token number">1010</span> <span class="token number">1010</span> <span class="token number">1001</span> <span class="token number">1010</span>  <span class="token comment">//h = key.hashCode() ^ (h &gt;&gt;&gt; 16) </span>
      <span class="token operator">&amp;</span>   <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">1111</span>  <span class="token comment">//数组长度 - 1 = 15 (15的二进制就是 1111)</span>
       <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
          <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">1010</span>  <span class="token comment">//key的存储下标为10</span>
          
        重要：由上可知，因为哈希值得高<span class="token number">16</span>位和低<span class="token number">16</span>位进行异或运算，混合之后的哈希值，低位也可能掺杂了高位的一部分特性<span class="token punctuation">(</span>就是变化性增加了<span class="token punctuation">)</span>，这样就减少了哈希冲突。
</code></pre> 
<h4><a id="2HashMap2_130"></a>(2)为什么HashMap的初始容量和扩容都是2的次幂</h4> 
<p><strong>回答：也是为了减少哈希冲突。</strong></p> 
<blockquote> 
 <p>原理：<br> 因为判断储存位置的下标为 ： <code>i = (n - 1) &amp; hash</code>，n就是数组的长度。<br> 2的次幂 - 1，其二进制都是1，比如 2^4 -1= 15(1111)，2^5-1 = 31(11111)。<br> 因为 <code>n-1</code> 和 <code>hash</code> 进行<code>与</code>运算，只有 1 &amp; 1 ，才为1。<br> 因为 <code>n-1</code>永远是2的次幂-1，<code>(n - 1) &amp; hash</code>的结果就是 hash的低位的值。</p> 
</blockquote> 
<pre><code class="prism language-java">          <span class="token number">1111</span> <span class="token number">1111</span> <span class="token number">1110</span> <span class="token number">1111</span> <span class="token number">0101</span> <span class="token number">0101</span> <span class="token number">0111</span> <span class="token number">0101</span>  <span class="token comment">//hash值</span>
	   <span class="token operator">&amp;</span>  <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">1111</span>  <span class="token comment">//数组长度 - 1 = 15 (15的二进制就是 1111)</span>
	   <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
	      <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0101</span>  <span class="token comment">//高位全部清零，只保留末四位(就相当于保留了hash的低位)</span>
	      
</code></pre> 
<p>如果容量不是2次幂会怎么样呢？如下图表</p> 
<ul><li>2次幂的时候，数组长度为16，n-1 = 16 -1 = 15(1111)</li></ul> 
<table><thead><tr><th>hash</th><th>(n-1) &amp; hash</th><th>储存下标</th></tr></thead><tbody><tr><td>0</td><td>1111 &amp; 0000</td><td>0</td></tr><tr><td>1</td><td>1111 &amp; 0001</td><td>1</td></tr><tr><td>2</td><td>1111 &amp; 0010</td><td>2</td></tr><tr><td>3</td><td>1111 &amp; 0011</td><td>3</td></tr><tr><td>4</td><td>1111 &amp; 0100</td><td>4</td></tr><tr><td>5</td><td>1111 &amp; 0101</td><td>5</td></tr></tbody></table> 
<ul><li>非2次幂的时候，数组长度为10，n-1 = 10 -1 = 9(1001)</li></ul> 
<table><thead><tr><th>hash</th><th>(n-1) &amp; hash</th><th>储存下标</th></tr></thead><tbody><tr><td>0</td><td>1001 &amp; 0000</td><td>0</td></tr><tr><td>1</td><td>1001 &amp; 0001</td><td>1</td></tr><tr><td>2</td><td>1001 &amp; 0010</td><td>0</td></tr><tr><td>3</td><td>1001 &amp; 0011</td><td>1</td></tr><tr><td>4</td><td>1001 &amp; 0100</td><td>0</td></tr><tr><td>5</td><td>1001 &amp; 0101</td><td>1</td></tr></tbody></table> 
<p><strong>重要</strong>：由上看出，n为2的次幂，哈希冲突会更少，保证元素的均匀插入。</p> 
<h4><a id="32_170"></a>(3)如果指定了不是2的次幂的容量会发生什么？</h4> 
<p><strong>回答：会获得一个大于指定的初始值的最接近2的次幂的值作为初始容量。</strong><br> 比如：输入 9 获得 16，输入 5 获得 8。</p> 
<p>原理如下：</p> 
<pre><code class="prism language-java">    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span> <span class="token comment">//负载因子</span>

	<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span><span class="token comment">//初始容量最大为 2的30次方</span>

	<span class="token comment">/**
     * @param initialCapacity 初始容量
     */</span>
	<span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//此处通过把第二个参数负载因子使用默认值0.75f，然后调用有两个参数的构造方法</span>
        <span class="token keyword">this</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用函数一</span>
    <span class="token punctuation">}</span>


	<span class="token comment">/**
	 * 函数一
     * @param initialCapacity 初始容量
     * @param loadFactor  负载因子
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>   <span class="token comment">//如果初始容量小于0，抛出异常</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal initial capacity: "</span> <span class="token operator">+</span> initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&gt;</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span>  <span class="token comment">//如果初始容量超过最大容量（1&lt;&lt;30）</span>
            initialCapacity <span class="token operator">=</span> MAXIMUM_CAPACITY<span class="token punctuation">;</span>  <span class="token comment">//则使用最大容量作为初始容量</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>loadFactor <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token class-name">Float</span><span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">//如果负载因子小于等于0或者不是数字，则抛出异常</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal load factor: "</span> <span class="token operator">+</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>                <span class="token comment">//把负载因子赋值给成员变量loadFactor</span>
 
        <span class="token comment">//调用tableSizeFor方法计算出不小于initialCapacity的最小的2的幂的结果，并赋给成员变量threshold</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//调用函数二</span>
    <span class="token punctuation">}</span>

	<span class="token comment">/**
	 * 函数二
     * @param cap 初始容量
     */</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//这里我们假设我们初始容量是 10</span>
        <span class="token comment">//容量减1，为了防止初始化容量已经是2的幂的情况，在最后有n+1的操作。  n = 10 - 1 = 9</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> cap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>      

		<span class="token comment">//n = (n | n &gt;&gt;&gt; 1) 带入得   n = (1001 | 0100) = 1101 </span>
        n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>        
		<span class="token comment">//n = (n | n &gt;&gt;&gt; 2) 带入得   n = (1101 | 0011) = 1111 </span>
        n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">;</span>       
		<span class="token comment">//n = (n | n &gt;&gt;&gt; 4) 带入得   n = (1111 | 0000) = 1111 </span>
        n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">4</span><span class="token punctuation">;</span> 
		<span class="token comment">//n = (n | n &gt;&gt;&gt; 8) 带入得   n = (1111 | 0000) = 1111 </span>
        n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">8</span><span class="token punctuation">;</span>       
        <span class="token comment">//n = (n | n &gt;&gt;&gt; 16) 带入得  n = (1111 | 0000) = 1111 = 15</span>
        n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">;</span>        
        <span class="token comment">/**
        如果入参cap为小于或等于0的数，那么经过cap-1之后n为负数，n经过无符号右移和或操作后仍未负数,
        所以如果n&lt;0,则返回1;如果n大于或等于最大容量，则返回最大容量;否则返回n+1。
        
        n = 15 + 1 = 16，咱们传进来是初始容量10，会自动转为16容量。
        **/</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token operator">?</span> MAXIMUM_CAPACITY <span class="token operator">:</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token comment">//return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;相当于下面这段代码</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        	<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
        	<span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        		<span class="token keyword">return</span> MAXIMUM_CAPACITY<span class="token punctuation">;</span> 
        	<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
        		<span class="token keyword">return</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        	<span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h3><a id="2HashMap_245"></a>2.HashMap为什么线程不安全(面试题)</h3> 
<h4><a id="1_jdk17_246"></a>(1) 多线程下扩容造成的死循环和数据丢失(jdk1.7)</h4> 
<blockquote> 
 <p>在jdk1.7中，链表采用的是<code>头插法</code>(每次插入节点都是从头插入)。<br> <img src="https://images2.imgbox.com/73/f4/SuFKzFvX_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p><strong>①</strong> 假设这里有两个线程同时执行了put()操作(扩容)，并进入了transfer()方法。线程A先进行操作<br> <img src="https://images2.imgbox.com/88/1e/ZLMYrHV0_o.png" alt="在这里插入图片描述"></p> 
<p><strong>②</strong> 线程A在执行到 <code>newTable[i] = e</code>后被挂起，因为 <code>newTable[i] = null</code>,又因为 <code>e.next = newTable[i]</code>，所以<code>e.next = null</code></p> 
<pre><code class="prism language-java"><span class="token function">transfer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法部分源码：

<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">!=</span>e<span class="token punctuation">)</span>

<span class="token punctuation">{<!-- --></span>
      <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next <span class="token operator">=</span>e<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">//next = 3.next = 7</span>

      e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//3.next = null</span>
      
      newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token comment">//线程A执行到这里被挂起了</span>
	
	   e <span class="token operator">=</span> next<span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/20/7f/rbbc2QVw_o.png" alt="在这里插入图片描述"></p> 
<p><strong>③</strong> 开始执行线程B，并完成了扩容。这时候 7.next = 3；3.next = null；</p> 
<p><img src="https://images2.imgbox.com/5c/bd/4fqcA8q2_o.png" alt="在这里插入图片描述"></p> 
<p><strong>④</strong> 继续执行线程A，执行 <code>newTable[i] = e</code>，因为当时 e = 3，所以将3放到对应位置，此时执行 <code>e = next</code>，因为 <code>next = 7</code>(第②步)，所以 <code>e = 7</code></p> 
<pre><code class="prism language-java"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">!=</span>e<span class="token punctuation">)</span>

<span class="token punctuation">{<!-- --></span>
      <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next <span class="token operator">=</span>e<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">//next = 3.next = 7</span>

      e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//3.next = null</span>
      
      newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token comment">//继续从这里执行  newTable[i] = 3</span>
	
	   e <span class="token operator">=</span> next<span class="token punctuation">;</span> <span class="token comment">//e = 7</span>

<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/57/ce/Di0Ky9WL_o.png" alt="在这里插入图片描述"><br> <strong>⑤</strong> 上轮循环之后<code>e=7</code>，从主内存中读取<code>e.next</code>时发现主内存中<code>7.next=3</code>，此时<code>next=3</code>，并将7采用头插法的方式放入新数组中，并继续执行完此轮循环。</p> 
<pre><code class="prism language-java"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">!=</span>e<span class="token punctuation">)</span>

<span class="token punctuation">{<!-- --></span>
      <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next <span class="token operator">=</span>e<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">//next = 7.next = 3</span>

      e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//7.next = 3</span>
      
      newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token comment">//newTable[i] = 7</span>
	
	   e <span class="token operator">=</span> next<span class="token punctuation">;</span> <span class="token comment">//e = 3</span>

<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/f2/ca/9oIgCeNk_o.png" alt="在这里插入图片描述"></p> 
<p><strong>⑥</strong>上轮循环<code>7.next=3</code>，而e=3，执行下一次循环可以发现，因为<code>3.next=null</code>，所以循环之后 e = null，所以循环会退出。</p> 
<pre><code class="prism language-java"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">!=</span>e<span class="token punctuation">)</span>

<span class="token punctuation">{<!-- --></span>
      <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next <span class="token operator">=</span>e<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">// next = 3.next = null</span>

      e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//3.next = 7 (此处3指向7,同时之前7也指向了3,所以会形成闭环)</span>
      
      newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>       <span class="token comment">//newTable[i] = 3</span>
      
	  e <span class="token operator">=</span> next<span class="token punctuation">;</span>              <span class="token comment">//e = null(退出循环条件)</span>

<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/ed/8a/Y3hRJwGv_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2jdk18_335"></a>(2)数据覆盖(jdk1.8)</h4> 
<blockquote> 
 <p>jdk1.8中已经不再采用头插法，改为尾插法，即直接插入链表尾部，因此不会出现死循环和数据丢失，但是在多线程环境下仍然会有数据覆盖的问题。</p> 
</blockquote> 
<p>当你调用put()方法时，putVal()方法里面有两处代码会产生数据覆盖。<br> <img src="https://images2.imgbox.com/85/a1/3wDK5tUO_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>① 假设两个线程都进行put操作，线程A和线程B通过哈希函数算出的储存下标是一致的，当线程A判断完之后，然后挂起，然后线程B判断完进入，把元素放到储存位置，然后线程A继续执行，把元素放到储存位置，因为线程A和线程B存储位置一样，所以线程A会覆盖线程B的元素。<br> <img src="https://images2.imgbox.com/77/4c/1FK6auO1_o.png" alt="请添加图片描述"></p> 
</blockquote> 
<blockquote> 
 <p>② 同样在putVal()方法里。两个线程，假设HashMap的size为15，线程A从主内存获得15，准备进行++的操作的时候，被挂起，然后线程B拿到size并执行++操作，并写回主内存，这时size是16，然后线程A继续执行(这时A线程内存size还是15)++操作，然后写回主内存，即线程A和线程B都进行了put操作，然后size值增加了1，所以数据被覆盖了。<br> <img src="https://images2.imgbox.com/49/c5/acPmyWrk_o.png" alt="请添加图片描述"></p> 
</blockquote> 
<h3><a id="3HashMap_351"></a>3.HashMap解决线程不安全(面试题)</h3> 
<h4><a id="1_HashTable_352"></a>(1) 使用HashTable解决线程不安全问题(弃用)</h4> 
<blockquote> 
 <p>因为HashTable解决线程不安全就是在其方法加上同步关键字(synchronized)，会导致效率很低下。</p> 
</blockquote> 
<h4><a id="2HashMapHashTable_356"></a>(2)HashMap和HashTable的区别</h4> 
<p><strong>①线程是否安全</strong><br> HashMap线程不安全。<br> HashTable线程安全，但是效率较低。</p> 
<p><strong>②是否null</strong><br> HashMap中key只能有一个null，value可以多个为null。<br> HashTable不允许键或值为null。</p> 
<p><strong>③容量</strong><br> HashMap底层数组长度必须为2的幂（16，32，128…），默认为16。<br> HashTable底层数组长度可以为任意值，导致hash算法散射不均匀，容易造成hash冲突，默认为11。</p> 
<p><strong>④底层区别</strong><br> HashMap是底层由数组+链表形成，在JDK1.8之后链表长度大于8时转化为红黑树。<br> HashTable一直都是数组+链表。</p> 
<p><strong>⑤继承关系</strong><br> HashTable继承自Dictionary类。<br> HashMap继承自AbstractMap类。</p> 
<h4><a id="3CollectionssynchronizedMap_378"></a>(3)Collections.synchronizedMap(不常用)</h4> 
<pre><code class="prism language-java"><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">synchronizedMap</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p>可以看到SynchronizedMap 是一个实现了Map接口的代理类，该类中对Map接口中的方法使用synchronized同步关键字来保证对Map的操作是线程安全的。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/a2/ad/ZLh9YN9i_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="4ConcurrentHashMap_389"></a>(4)ConcurrentHashMap(常用)</h4> 
<blockquote> 
 <p>① jdk1.7使用分段锁，底层采用数组+链表的存储结构，包括两个核心静态内部类 Segment(锁角色) 和 HashEntry(存放键值对)。</p> 
</blockquote> 
<blockquote> 
 <p>分段锁：Segment(继承ReentrantLock来加锁)数组中，一个Segment对象就是一把锁,对应n个HashEntry数组,不同HashEntry数组的读写互不干扰。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/45/fc/RHLOYH4D_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>② JDK 1.8抛弃了原有的 Segment 分段锁，来保证采用Node + CAS + Synchronized来保证并发安全性。取消Segment类，直接用数组存储键值对。<br> <img src="https://images2.imgbox.com/8c/54/QJ5aFY36_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote></blockquote> 
<p><a href="https://blog.csdn.net/baidu_41632451/article/details/124754457">CAS理解</a></p> 
<h3><a id="4synchronizedReentrantLock_403"></a>4.为什么使用synchronized替换ReentrantLock锁呢？</h3> 
<p>① 减少内存开销。假设使用可重入锁来获得同步支持，那么每个节点都需要通过继承AQS(队列同步器)来获得同步支持。但并不是每个节点都需要获得同步支持的，只有链表的头节点（红黑树的根节点）需要同步，这无疑带来了巨大内存浪费。<br> ② 获得JVM的支持。可重入锁毕竟是API这个级别的，后续的性能优化空间很小。 synchronized则是JVM直接支持的，JVM能够在运行时作出相应的优化措施：锁粗化、锁消除、锁自旋等等。这就使得synchronized能够随着JDK版本的升级而不改动代码的前提下获得性能上的提升。<br> ③在 JDK1.6 中，对 synchronized 锁的实现引入了大量的优化，并且 synchronized 有多种锁状态，会从无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁一步步转换。</p> 
<p><strong>AQS</strong>：是一个队列同步器，同步队列是一个双向链表，有一个状态标志位state，如果state为1的时候，表示有线程占用，其他线程会进入同步队列等待，如果有的线程需要等待一个条件，会进入等待队列，当满足这个条件的时候才进入同步队列，ReentrantLock就是基于AQS实现的</p> 
<blockquote> 
 <p>锁升级方式：就是先使用偏向锁优先同一线程然后再次获取锁，如果失败，就升级为CAS(compare and swap 原子操作) 轻量级锁，如果失败就会短暂自旋(不停的判断比较，看能否将值交换)，防止线程被系统挂起。最后如果以上都失败就升级为重量级锁。</p> 
</blockquote> 
<ul><li>偏向锁：减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁产生的性能消耗。轻量级锁每次申请、释放锁都至少需要一次CAS，但偏向锁只有初始化时需要一次CAS。</li><li>轻量级锁：当有两个线程，竞争的时候就会升级为轻量级锁。轻量级锁的目标是，减少无实际竞争情况下，使用重量级锁产生的性能消耗，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。</li><li>重量级锁：大多数情况下，在同一时间点，常常有多个线程竞争同一把锁，悲观锁的方式，竞争失败的线程会不停的在阻塞及被唤醒态之间切换，代价比较大。</li></ul> 
<h3><a id="4HashMap______419"></a>4.HashMap底层 数组 + 链表 / 红黑树(面试题)</h3> 
<p><strong>红黑树</strong>：平衡二叉查找树</p> 
<h4><a id="1HashMap_421"></a>(1)HashMap为什么引入链表</h4> 
<blockquote> 
 <p>因为HashMap在put()操作时，会进行哈希值得计算，算出储存下标要放在数组那个位置时，当多个元素要放在同一位置时就会出现哈希冲突，然后引进链表，把相同位置的元素放进同一个链表(链地址法)。</p> 
</blockquote> 
<h4><a id="2HashMap_424"></a>(2)HashMap为什么引入红黑树</h4> 
<blockquote> 
 <p>因为当链表长度大于8时，链表遍历查询速度比较慢，所以引入红黑树。</p> 
</blockquote> 
<h4><a id="3_426"></a>(3)为什么不一开始就使用红黑树</h4> 
<blockquote> 
 <p>因为树相对链表维护成本更大，红黑树在插入新数据之后，可能会通过左旋、右旋、变色来保持平衡，造成维护成本过高，故链路较短时，不适合用红黑树。</p> 
</blockquote> 
<h4><a id="4_429"></a>(4)说说你对红黑树的理解</h4> 
<blockquote> 
 <p>红黑树是一种平衡二叉查找树，是一种数据结构。除了具备二叉查找树特性以外，还具备以下特性</p> 
</blockquote> 
<ul><li>1.根节点是黑色</li><li>2.节点是黑色或红色</li><li>3.每个叶子节点是黑色</li><li>4.红色节点的子节点都是黑色</li><li>5.从任意节点到其叶子节点的所有路径都包含相同数目的黑色节点</li></ul> 
<p>说出以上就很好了</p> 
<p>补充：以上性质强制了红黑树的关键性质<strong>从根到叶子的最长的可能路径不多于最短的可能路径的两倍长</strong>。保证了红黑树的高效。</p> 
<h4><a id="5__443"></a>(5) 红黑树为什么要变色、左旋和右旋操作</h4> 
<blockquote> 
 <p>当我们在对红黑树进行插入和删除等操作时，对树做了修改，那么可能会违背红黑树的性质。<br> 过程：先变色如果变色还不满足红黑树的性质，那就进行左旋或者右旋，然后继续变色，以此循环直至符合红黑树的性质。</p> 
</blockquote> 
<h3><a id="5HashMap_448"></a>5.HashMap链表和红黑树转换(面试题)</h3> 
<ul><li>链表长度大于8，并且表的长度大于64   数组 + 红黑树</li><li>链表长度大于8，并且表的长度不大于64  数组 + 链表 会扩容</li><li>当数的节点小于6             数组 + 链表</li></ul> 
<h4><a id="1_864_452"></a>(1) 为什么链表长度大于8，并且表的长度大于64的时候，链表会转换成红黑树？</h4> 
<blockquote> 
 <p>因为链表长度符合泊松分布，长度越长哈希冲突概率就越小，当链表长度为8时，概率仅为 0.00000006，这时是一个千万分之一的概率，然后我们map也不会存储那么多的数据，所以链表长度不超过8没有必要转换成红黑树。如果出现这种大量数据的话，转为红黑树可以增加查询和插入效率。长度大于64，只是注释写了 最低要在 4*8，我也没弄懂，请大佬指导。 <br> 原理如下：</p> 
</blockquote> 
<pre><code class="prism language-java"> 
<span class="token class-name">In</span> usages <span class="token keyword">with</span> <span class="token namespace">well</span><span class="token operator">-</span>distributed user hashCodes<span class="token punctuation">,</span> tree bins 
are rarely <span class="token class-name"><span class="token namespace">used<span class="token punctuation">.</span></span>  Ideally</span><span class="token punctuation">,</span> under random hashCodes<span class="token punctuation">,</span> the 
frequency of nodes in bins follows a <span class="token class-name">Poisson</span> distribution 
<span class="token punctuation">(</span>http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>en<span class="token punctuation">.</span>wikipedia<span class="token punctuation">.</span>org<span class="token operator">/</span>wiki<span class="token operator">/</span><span class="token class-name">Poisson_distribution</span><span class="token punctuation">)</span> <span class="token keyword">with</span> <span class="token namespace">a</span> 
parameter of about <span class="token number">0.5</span> on average <span class="token keyword">for</span> the <span class="token keyword">default</span> resizing 
threshold of <span class="token number">0.75</span><span class="token punctuation">,</span> although <span class="token keyword">with</span> <span class="token namespace">a</span> large variance because 
of resizing <span class="token class-name"><span class="token namespace">granularity<span class="token punctuation">.</span></span> Ignoring</span> variance<span class="token punctuation">,</span> the expected 
occurrences of list size k are <span class="token punctuation">(</span><span class="token function">exp</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token operator">/</span> 
<span class="token function">factorial</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token class-name">The</span> first values are<span class="token operator">:</span>
 <span class="token number">0</span><span class="token operator">:</span>    <span class="token number">0.60653066</span>
 <span class="token number">1</span><span class="token operator">:</span>    <span class="token number">0.30326533</span>
 <span class="token number">2</span><span class="token operator">:</span>    <span class="token number">0.07581633</span>
 <span class="token number">3</span><span class="token operator">:</span>    <span class="token number">0.01263606</span>
 <span class="token number">4</span><span class="token operator">:</span>    <span class="token number">0.00157952</span>
 <span class="token number">5</span><span class="token operator">:</span>    <span class="token number">0.00015795</span>
 <span class="token number">6</span><span class="token operator">:</span>    <span class="token number">0.00001316</span>
 <span class="token number">7</span><span class="token operator">:</span>    <span class="token number">0.00000094</span>
 <span class="token number">8</span><span class="token operator">:</span>    <span class="token number">0.00000006</span>
 more<span class="token operator">:</span> less than <span class="token number">1</span> in ten million  <span class="token comment">//翻译：更多：少于千万分之一</span>


负载因子是<span class="token number">0.75</span>和长度为<span class="token number">8</span>转为红黑树的原理：由上面我们可以看出 当负载因子为<span class="token number">0.75</span>时，哈希冲突出现的频率遵循参数为<span class="token number">0.5</span>的泊松分布。
常数<span class="token number">0.5</span>是作为参数代入泊松分布来计算的，而加载因子<span class="token number">0.75</span>是作为一个条件。

泊松分布是一种离散概率分布，泊松分布的概率质量函数：

x<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>。
λ：单位时间内随机事件的平均发生率。因为我们从上面知道平均发生率是<span class="token number">0.5</span>
e<span class="token operator">^</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0.60653065971264</span>  <span class="token comment">//e的负0.5次方</span>
阶乘：指从<span class="token number">1</span>乘以<span class="token number">2</span>乘以<span class="token number">3</span>乘以<span class="token number">4</span>一直乘到所要求的数。比如 <span class="token number">3</span>！ <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">3</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/b5/72/vWjPr1uF_o.png" alt="在这里插入图片描述"></p> 
<ul><li>P(0) = (0.5<sup>0</sup> * e<sup>-0.5</sup>) / 0! ≈ 0.60653066</li><li>P(1) = (0.5<sup>1</sup> * e<sup>-0.5</sup>) / 1! ≈ 0.30326533</li><li>P(2) = (0.5<sup>2</sup> * e<sup>-0.5</sup>) / 2! ≈ 0.07581633</li><li>后面就不给大家计算了，有兴趣可以自己算一下。</li></ul> 
<h4><a id="2_86_500"></a>(2) 为什么转成红黑树是8呢？而重新转为链表阈值是6呢？</h4> 
<blockquote> 
 <p>如果转为链表也是8，那如果在8这个位置发生哈希冲突，那红黑树和链表就会频繁切换，就会浪费资源。</p> 
</blockquote> 
<h4><a id="3_075_505"></a>(3) 为什么负载因子是0.75？</h4> 
<blockquote> 
 <p>根据上面的泊松分布来看，表长度达到8个元素的时候，概率为0.00000006，几乎是一个不可能事件，减少了哈希冲突。</p> 
</blockquote> 
<blockquote> 
 <p>加载因子 = 填入表中的元素个数 / 散列表的长度</p> 
</blockquote> 
<p>加载因子越大，填满的元素越多，空间利用率越高，但发生冲突的机会变大了；</p> 
<p>加载因子越小，填满的元素越少，冲突发生的机会减小，但空间浪费了更多了，而且还会提高扩容rehash操作的次数。</p> 
<p>“冲突的机会”与“空间利用率”之间，寻找一种平衡与折中。</p> 
<h3><a id="6HashMap_521"></a>6.HashMap扩容(面试题)</h3> 
<h4><a id="1_522"></a>(1)什么时候会发生扩容？</h4> 
<blockquote> 
 <p>元素个数 &gt; 数组长度 * 负载因子 例如 16 * 0.75 = 12,当元素超过12个时就会扩容。<br> 链表长度大于8并且表长小于64，也会扩容</p> 
</blockquote> 
<h4><a id="2_527"></a>(2)为什么不是满了扩容？</h4> 
<blockquote> 
 <p>因为越元素越接近数组长度，哈希冲突概率就越大，所以不是满了扩容。</p> 
</blockquote> 
<h4><a id="3_531"></a>(3)扩容过程</h4> 
<ul><li> <p>jdk1.7<br> 创建一个新的table，并调用transfer()方法把旧数组中的数据迁移到新数组中，使用的是头插法，也就是说，新table中链表的顺序和旧列表中是相反的，在HashMap线程不安全的情况下，这种头插法可能会导致死链和数据丢失现象。</p> </li><li> <p>jdk1.8<br> ①在resize()方法中，定义了oldCap参数，记录了原table的长度，定义了newCap参数，记录新table长度，newCap是oldCap长度的2倍，然后循环原table，把原table中的每个链表中的每个元素放入新table。<br> ②计算索引做了优化：hash（原始hash） &amp; oldCap（原始容量） == 0 的元素留在原来位置 ，否则新位置 = 旧位置 + oldCap（原始容量）。</p> </li></ul> 
<p><strong>注意</strong></p> 
<ul><li> <p>扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。</p> </li><li> <p>HashMap的容量达到2的30次方，就不会在进行扩容了。</p> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/964b3c464fb7f019e3d1db180283b2fc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">微信开发者工具下载安装教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/115043f666fcc1dc4952d06a855744fc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">分享Python7个爬虫小案例（附源码）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>