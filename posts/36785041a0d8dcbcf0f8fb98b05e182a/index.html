<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;】多线程(thread)使用详解 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/36785041a0d8dcbcf0f8fb98b05e182a/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;】多线程(thread)使用详解">
  <meta property="og:description" content="目录 一、前言1. 多线程的含义2. 进程与线程的区别 二、创建线程1. thread2. join() 和 detach()3. this_thread 三、std::mutex1. lock() 与 unlock()2. lock_guard3. unique_lock 四、condition_variable五、std::atomic如果这篇文章对你有所帮助，渴望获得你的一个点赞！ 一、前言 1. 多线程的含义 多线程（multithreading），是指在软件或者硬件上实现多个线程并发执行的技术。具有多核CPU的支持的计算机能够真正在同一时间执行多个程序片段，进而提升程序的处理性能。在一个程序中，这些独立运行的程序片段被称为“线程”（Thread），利用其编程的概念就叫作“多线程处理”。
2. 进程与线程的区别 进程是指一个程序的运行实例，而线程是指进程中独立的执行流程。一个进程可以有多个线程，多个线程之间可以并发执行。
一个程序有且只有一个进程，但可以拥有至少一个的线程。不同进程拥有不同的地址空间，互不相关，而不同线程共同拥有相同进程的地址空间。 二、创建线程 1. thread C&#43;&#43;支持多线程编程，主要使用的是线程库&lt;thread&gt;。
示例1： 创建线程使用std::thread类
#include &lt;iostream&gt; #include &lt;thread&gt; //必须包含&lt;thread&gt;头文件 void threadFunctionA() { std::cout &lt;&lt; &#34;Run New thread: 1&#34; &lt;&lt; std::endl; } void threadFunctionB(int n) { std::cout &lt;&lt; &#34;Run New thread: &#34;&lt;&lt; n &lt;&lt; std::endl; } int main() { std::cout &lt;&lt; &#34;Run Main Thread&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-06-29T11:51:21+08:00">
    <meta property="article:modified_time" content="2023-06-29T11:51:21+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;】多线程(thread)使用详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">一、前言</a></li><li><ul><li><a href="#1__3" rel="nofollow">1. 多线程的含义</a></li><li><a href="#2__7" rel="nofollow">2. 进程与线程的区别</a></li></ul> 
  </li><li><a href="#_16" rel="nofollow">二、创建线程</a></li><li><ul><li><a href="#1_thread_18" rel="nofollow">1. thread</a></li><li><a href="#2_join__detach_125" rel="nofollow">2. join() 和 detach()</a></li><li><a href="#3_this_thread_175" rel="nofollow">3. this_thread</a></li></ul> 
  </li><li><a href="#stdmutex_243" rel="nofollow">三、std::mutex</a></li><li><ul><li><a href="#1_lock__unlock_251" rel="nofollow">1. lock() 与 unlock()</a></li><li><a href="#2_lock_guard_310" rel="nofollow">2. lock_guard</a></li><li><a href="#3_unique_lock_357" rel="nofollow">3. unique_lock</a></li></ul> 
  </li><li><a href="#condition_variable_411" rel="nofollow">四、condition_variable</a></li><li><a href="#stdatomic_483" rel="nofollow">五、std::atomic</a></li><li><ul><li><a href="#_534" rel="nofollow">如果这篇文章对你有所帮助，渴望获得你的一个点赞！</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>一、前言</h2> 
<h3><a id="1__3"></a>1. 多线程的含义</h3> 
<p>多线程（multithreading），是指在软件或者硬件上实现多个线程并发执行的技术。具有多核CPU的支持的计算机能够真正在同一时间执行多个程序片段，进而提升程序的处理性能。在一个程序中，这些独立运行的程序片段被称为“<strong>线程</strong>”（Thread），利用其编程的概念就叫作“多线程处理”。</p> 
<h3><a id="2__7"></a>2. 进程与线程的区别</h3> 
<p>进程是指一个程序的<strong>运行实例</strong>，而线程是指进程中<strong>独立的执行流程</strong>。一个进程可以有多个线程，多个线程之间可以并发执行。</p> 
<ul><li>一个程序有且只有一个进程，但可以拥有至少一个的线程。</li><li>不同进程拥有不同的地址空间，互不相关，而不同线程共同拥有相同进程的地址空间。</li></ul> 
<hr> 
<h2><a id="_16"></a>二、创建线程</h2> 
<h3><a id="1_thread_18"></a>1. thread</h3> 
<p>C++支持多线程编程，主要使用的是线程库<code>&lt;thread&gt;</code>。</p> 
<p><strong>示例1：</strong> 创建线程使用<code>std::thread</code>类</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span>    <span class="token comment">//必须包含&lt;thread&gt;头文件</span></span>

<span class="token keyword">void</span> <span class="token function">threadFunctionA</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Run New thread: 1"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">threadFunctionB</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Run New thread: "</span><span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Run Main Thread"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

	std<span class="token double-colon punctuation">::</span>thread <span class="token function">newThread1</span><span class="token punctuation">(</span>threadFunctionA<span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>thread <span class="token function">newThread2</span><span class="token punctuation">(</span>threadFunctionB<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	newThread1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	newThread2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-c++">//result
Run Main Thread
Run New thread: 1
Run New thread: 2
</code></pre> 
<p>上述示例中，我们创建了两个线程<strong>newThread1</strong>和<strong>newThread2</strong>，使用函数<code>threadFunctionA()</code>和<code>threadFunctionB()</code>作为线程的执行函数，并使用<code>join()</code>函数等待线程执行完成。</p> 
<p><strong>示例2：</strong> 执行函数有引用参数</p> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;thread&gt;    //必须包含&lt;thread&gt;头文件

void threadFunc(int &amp;arg1, int arg2)
{
	arg1 = arg2;
	std::cout &lt;&lt; "arg1 = " &lt;&lt; arg1 &lt;&lt; std::endl;
}

int main()
{
    std::cout &lt;&lt; "Run Main Thread!" &lt;&lt; std::endl;
	int a = 1;
	int b = 5;
	std::thread newTh(threadFunc, a, b);  //此处会报错
	newTh.join();
	return 0;
}
</code></pre> 
<p><strong>注意：</strong> 若编译上述代码，编译器会报如下错误：</p> 
<pre><code>错误	C2672	“std::invoke”: 未找到匹配的重载函数
错误	C2893	未能使函数模板“unknown-type std::invoke(_Callable &amp;&amp;,_Types &amp;&amp;...) noexcept(&lt;expr&gt;)”专用化
</code></pre> 
<p>这是因为<strong>thread</strong>在传递参数时，是以<strong>右值传递</strong>的，如果要传递一个左值可以使用<code>std::ref</code>和<code>std::cref</code></p> 
<ul><li><code>std::ref</code> 可以包装按引用传递的值为右值。</li><li><code>std::cref</code> 可以包装按<code>const</code>引用传递的值为右值。</li></ul> 
<p>因此，示例2代码可修改为：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span>    <span class="token comment">//必须包含&lt;thread&gt;头文件</span></span>

<span class="token keyword">void</span> <span class="token function">threadFunc</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>arg1<span class="token punctuation">,</span> <span class="token keyword">int</span> arg2<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	arg1 <span class="token operator">=</span> arg2<span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"New Thread arg1 = "</span> <span class="token operator">&lt;&lt;</span> arg1 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Run Main Thread!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>thread <span class="token function">newTh</span><span class="token punctuation">(</span>threadFunc<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">ref</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//使用ref</span>
	newTh<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-c++">//result
Run Main Thread!
arg1 = 5
</code></pre> 
<hr> 
<h3><a id="2_join__detach_125"></a>2. join() 和 detach()</h3> 
<p>在C++中，创建了一个线程时，它通常被称为一个<strong>可联接</strong><code>(joinable)</code>的线程，可以通过调用<code>join()</code>函数或<code>detach()</code>函数来管理线程的执行。</p> 
<table><thead><tr><th></th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>join()</td><td><strong>等待</strong>一个线程完成，如果该线程还未执行完毕，则当前线程（一般是主线程）将被阻塞，直到该线程执行完成，主线程才会继续执行。</td></tr><tr><td>2</td><td>detach()</td><td>将当前线程与创建的线程<strong>分离</strong>，使它们分别运行，当分离的线程执行完毕后，系统会自动回收其资源。如果一个线程被分离了，就不能再使用<code>join()</code>函数了，因为线程已经无法被联接了。</td></tr><tr><td>3</td><td>joinable()</td><td>判断线程是否可以执行<code>join()</code>函数，返回<strong>true/false</strong></td></tr></tbody></table> 
<p><strong>示例3：</strong></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;windows.h&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Run New thread!\n"</span><span class="token punctuation">;</span>
	<span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   		<span class="token comment">//需要头文件&lt;windows.h&gt;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  		<span class="token comment">// 等待线程t执行完毕</span>

		<span class="token comment">// t.detach();  // 分离线程t与主线程</span>
	<span class="token punctuation">}</span>

	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Run Main thread!\n"</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上述的示例中，创建了一个可联接的线程<code>t</code>，使用<code>t.join()</code>主线程将被阻塞，直到<code>t</code>线程执行完毕。如果使用<code>t.detach()</code>将<code>t</code>线程分离，那么它们将同时执行，主线程将不会阻塞。</p> 
<p><strong>注意：</strong></p> 
<ul><li>线程是在<strong>thread</strong>对象被定义的时候开始执行的，而不是在调用<code>join()</code>函数时才执行的，调用<code>join()</code>函数只是阻塞等待线程结束并回收资源。</li><li>分离的线程（执行过<code>detach()</code>的线程）会在调用它的线程结束或自己结束时自动释放资源。</li><li>线程会在函数运行完毕后<strong>自动释放</strong>，不推荐利用其他方法强制结束线程，可能会因资源未释放而导致内存泄漏。</li><li>若没有执行<code>join()</code>或<code>detach()</code>的线程在程序结束时会引发异常。</li></ul> 
<hr> 
<h3><a id="3_this_thread_175"></a>3. this_thread</h3> 
<p>在C++中，<code>this_thread</code>类提供了一些关于<strong>当前线程的功能函数</strong>。具体如下：</p> 
<table><thead><tr><th></th><th>使用</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>std::this_thread::sleep_for()</td><td>当前线程休眠指定的时间</td></tr><tr><td>2</td><td>std::this_thread::sleep_until()</td><td>当前线程休眠直到指定时间点</td></tr><tr><td>3</td><td>std::this_thread::yield()</td><td>当前线程让出CPU，允许其他线程运行</td></tr><tr><td>4</td><td>std::this_thread::get_id()</td><td>获取当前线程的ID</td></tr></tbody></table> 
<p>此外，<code>this_thread</code>还包含重载运算符<code>==</code>和<code>!=</code>，用于比较两个线程是否相等。</p> 
<p><strong>示例4：</strong></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;chrono&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">my_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Thread "</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" start！"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Thread "</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" running: "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
		std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 让出当前线程的时间片</span>
		std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">milliseconds</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 线程休眠200毫秒</span>
	<span class="token punctuation">}</span>

	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Thread "</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" end！"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Main thread id: "</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>my_thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>my_thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-c++">//result 程序输出的结果可能如下：
Main thread id: 43108
Thread 39272 start！
Thread 33480 start！
Thread 33480 running: 1
Thread 39272 running: 1
Thread 33480 running: 2
Thread 39272 running: 2
Thread 33480 running: 3
Thread 39272 running: 3
Thread 33480 running: 4
Thread 39272 running: 4
Thread 39272 running: 5
Thread 33480 running: 5
Thread 39272 ends
Thread 33480 ends
</code></pre> 
<hr> 
<h2><a id="stdmutex_243"></a>三、std::mutex</h2> 
<p>在多线程编程中，需要注意以下问题：</p> 
<ul><li>线程之间的共享数据访问需要进行同步，以防止数据竞争和其他问题。可以使用<strong>互斥量</strong>、<strong>条件变量</strong>等机制进行同步。</li><li>可能会发生<strong>死锁</strong>问题，即多个线程互相等待对方释放锁，导致程序无法继续执行。</li><li>可能会发生<strong>竞态条件</strong>问题，即多个线程执行的顺序导致结果的不确定性。</li></ul> 
<h3><a id="1_lock__unlock_251"></a>1. lock() 与 unlock()</h3> 
<p><code>std::mutex</code>是 C++11 中最基本的<strong>互斥量</strong>，一个线程将mutex锁住时，其它的线程就不能操作mutex，直到这个线程将mutex解锁。</p> 
<table><thead><tr><th></th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>lock()</td><td><strong>将mutex上锁</strong>。如果mutex已经被其它线程上锁，那么会阻塞，直到解锁；如果mutex已经被同一个线程锁住，那么会产生<strong>死锁</strong>。</td></tr><tr><td>2</td><td>unlock()</td><td><strong>将mutex解锁</strong>，释放其所有权。如果有线程因为调用<code>lock()</code>不能上锁而被阻塞，则调用此函数会将mutex的主动权随机交给其中一个线程；如果mutex不是被此线程上锁，那么会引发未定义的异常。</td></tr><tr><td>3</td><td>try_lock()</td><td><strong>尝试将mutex上锁</strong>。如果mutex未被上锁，则将其上锁并返回<strong>true</strong>；如果mutex已被锁则返回<strong>false</strong>。</td></tr></tbody></table> 
<p><strong>示例：</strong> 使用互斥量</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span>

std<span class="token double-colon punctuation">::</span>mutex mtx<span class="token punctuation">;</span>
<span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">thread_function</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		mtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		n<span class="token operator">++</span><span class="token punctuation">;</span>
		mtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>thread myThread<span class="token punctuation">[</span><span class="token number">500</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>thread <span class="token operator">&amp;</span>a <span class="token operator">:</span> myThread<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		a <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span>thread_function<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">ref</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		a<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"num = "</span> <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Main thread exits!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-c++">//result
num = 50000
Main thread exits!
</code></pre> 
<p><strong>注意：</strong> 在使用互斥量时，需要注意以下问题：</p> 
<ul><li>加锁和解锁的顺序必须相同。</li><li>不能在未获得锁的情况下对共享数据进行操作。</li><li>由于使用了 <code>std::mutex</code> 来控制对共享资源的访问，因此<strong>可能会对程序的性能造成影响</strong>，如果需要优化程序性能，可以考虑使用无锁编程等技术。</li></ul> 
<hr> 
<h3><a id="2_lock_guard_310"></a>2. lock_guard</h3> 
<p><code>std::lock_guard</code>是C++标准库中的一个模板类，用于实现资源的自动加锁和解锁。它是基于<strong>RAII</strong>（资源获取即初始化）的设计理念，能够确保在作用域结束时自动释放锁资源，避免了手动管理锁的复杂性和可能出现的错误。</p> 
<p><code>std::lock_guard</code>的主要特点如下：</p> 
<ul><li><strong>自动加锁：</strong> 在创建<code>std::lock_guard</code>对象时，会立即对指定的互斥量进行加锁操作。这样可以确保在进入作用域后，互斥量已经被锁定，避免了并发访问资源的竞争条件。</li><li><strong>自动解锁：</strong><code>std::lock_guard</code>对象在作用域结束时，会自动释放互斥量。无论作用域是通过正常的流程结束、异常抛出还是使用<code>return</code>语句提前返回，<code>std::lock_guard</code>都能保证互斥量被正确解锁，避免了资源泄漏和死锁的风险。</li><li><strong>适用于局部锁定：</strong> 由于<code>std::lock_guard</code>是通过栈上的对象实现的，因此适用于在局部范围内锁定互斥量。当超出<code>std::lock_guard</code>对象的作用域时，互斥量会自动解锁，释放控制权。</li></ul> 
<p><strong>使用<code>std::lock_guard</code>的一般步骤如下：</strong></p> 
<ol><li>创建一个<code>std::lock_guard</code>对象，传入要加锁的互斥量作为参数。</li><li>执行需要加锁保护的代码块。</li><li><code>std::lock_guard</code>对象的作用域结束时，自动调用析构函数解锁互斥量。</li></ol> 
<p><strong>示例：</strong></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span>

std<span class="token double-colon punctuation">::</span>mutex mtx<span class="token punctuation">;</span>  <span class="token comment">// 互斥量</span>

<span class="token keyword">void</span> <span class="token function">thread_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 加锁互斥量</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Thread running"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token comment">// 执行需要加锁保护的代码</span>
<span class="token punctuation">}</span>  <span class="token comment">// lock_guard对象的析构函数自动解锁互斥量</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>thread_function<span class="token punctuation">)</span><span class="token punctuation">;</span>
    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Main thread exits!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上述示例中，<code>std::lock_guard</code>对象<code>lock</code>会在<code>thread_function</code>中加锁互斥量，保护了输出语句的执行。当<code>thread_function</code>结束时，<code>lock_guard</code>对象的析构函数会自动解锁互斥量。这样可以确保互斥量在合适的时候被锁定和解锁，避免了多线程间的竞争问题。</p> 
<p>总而言之，<code>std::lock_guard</code>提供了一种简单而安全的方式来管理互斥量的锁定和解锁，使多线程编程更加方便和可靠。</p> 
<hr> 
<h3><a id="3_unique_lock_357"></a>3. unique_lock</h3> 
<p><code>std::unique_lock</code>是C++标准库中的一个模板类，用于实现更加灵活的互斥量的加锁和解锁操作。它提供了比<code>std::lock_guard</code>更多的功能和灵活性。</p> 
<p><strong><code>std::unique_lock</code>的主要特点如下：</strong></p> 
<ul><li> <p><strong>自动加锁和解锁：</strong> 与<code>std::lock_guard</code>类似，<code>std::unique_lock</code>在创建对象时立即对指定的互斥量进行加锁操作，确保互斥量被锁定。在对象的生命周期结束时，会自动解锁互斥量。这种自动加锁和解锁的机制避免了手动管理锁的复杂性和可能出现的错误。</p> </li><li> <p><strong>支持灵活的加锁和解锁：</strong> 相对于<code>std::lock_guard</code>的自动加锁和解锁，<code>std::unique_lock</code>提供了更灵活的方式。它可以在需要的时候手动加锁和解锁互斥量，允许在不同的代码块中对互斥量进行多次加锁和解锁操作。</p> </li><li> <p><strong>支持延迟加锁和条件变量：</strong><code>std::unique_lock</code>还支持延迟加锁的功能，可以在不立即加锁的情况下创建对象，稍后根据需要进行加锁操作。此外，它还可以与条件变量（<code>std::condition_variable</code>）一起使用，实现更复杂的线程同步和等待机制。</p> </li></ul> 
<p><strong>使用<code>std::unique_lock</code>的一般步骤如下：</strong></p> 
<ol><li>创建一个<code>std::unique_lock</code>对象，传入要加锁的互斥量作为参数。</li><li>执行需要加锁保护的代码块。</li><li>可选地手动调用<code>lock</code>函数对互斥量进行加锁，或者在需要时调用<code>unlock</code>函数手动解锁互斥量。</li></ol> 
<p><strong>示例：</strong></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span>

std<span class="token double-colon punctuation">::</span>mutex mtx<span class="token punctuation">;</span>  <span class="token comment">// 互斥量</span>

<span class="token keyword">void</span> <span class="token function">thread_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 加锁互斥量</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Thread running"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token comment">// 执行需要加锁保护的代码</span>
    lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 手动解锁互斥量</span>
    <span class="token comment">// 执行不需要加锁保护的代码</span>
    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 再次加锁互斥量</span>
    <span class="token comment">// 执行需要加锁保护的代码</span>
<span class="token punctuation">}</span>  
<span class="token comment">// unique_lock对象的析构函数自动解锁互斥量</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>thread_function<span class="token punctuation">)</span><span class="token punctuation">;</span>
    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Main thread exits!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上述示例中，<code>std::unique_lock</code>对象<code>lock</code>会在创建时自动加锁互斥量，析构时自动解锁互斥量。我们可以通过调用<code>lock</code>和<code>unlock</code>函数手动控制加锁和解锁的时机，以实现更灵活的操作。</p> 
<p>总而言之，<code>std::unique_lock</code>提供了更灵活和功能丰富的互斥量的加锁和解锁机制，使多线程编程更加便捷和安全。它在处理复杂的同步需求、延迟加锁以及与条件变量的结合等方面非常有用。</p> 
<hr> 
<h2><a id="condition_variable_411"></a>四、condition_variable</h2> 
<p><code>std::condition_variable</code>是C++标准库中的一个类，用于在多线程编程中实现线程间的条件变量和线程同步。它提供了<strong>等待</strong>和<strong>通知</strong>的机制，使得线程可以等待某个条件成立时被唤醒，或者在满足某个条件时通知其他等待的线程。其提供了以下几个函数用于等待和通知线程：</p> 
<table><thead><tr><th></th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>wait</td><td>使当前线程进入等待状态，直到被其他线程通过<code>notify_one()</code>或<code>notify_all()</code>函数唤醒。该函数需要一个互斥锁作为参数，调用时会自动释放互斥锁，并在被唤醒后重新获取互斥锁。</td></tr><tr><td>2</td><td>wait_for</td><td><code>wait_for()</code>: 使当前线程进入等待状态，最多等待一定的时间，直到被其他线程通过<code>notify_one()</code>或<code>notify_all()</code>函数唤醒，或者等待超时。该函数需要一个互斥锁和一个时间段作为参数，返回时有两种情况：等待超时返回<code>std::cv_status::timeout</code>，被唤醒返回<code>std::cv_status::no_timeout</code>。</td></tr><tr><td>3</td><td>wait_until</td><td><code>wait_until()</code>: 使当前线程进入等待状态，直到被其他线程通过<code>notify_one()</code>或<code>notify_all()</code>函数唤醒，或者等待时间达到指定的绝对时间点。该函数需要一个互斥锁和一个绝对时间点作为参数，返回时有两种情况：时间到达返回<code>std::cv_status::timeout</code>，被唤醒返回<code>std::cv_status::no_timeout</code>。</td></tr><tr><td>4</td><td>notify_one</td><td><code>notify_one()</code>: 唤醒一个等待中的线程，如果有多个线程在等待，则选择其中一个线程唤醒。</td></tr><tr><td>5</td><td>notify_all</td><td><code>notify_all()</code>: 唤醒所有等待中的线程，使它们从等待状态返回。</td></tr></tbody></table> 
<p><strong><code>std::condition_variable</code>的主要特点如下：</strong></p> 
<ul><li> <p><strong>等待和通知机制：</strong><code>std::condition_variable</code>允许线程进入等待状态，直到某个条件满足时才被唤醒。线程可以调用<code>wait</code>函数进入等待状态，并指定一个互斥量作为参数，以确保线程在等待期间互斥量被锁定。当其他线程满足条件并调用<code>notify_one</code>或<code>notify_all</code>函数时，等待的线程将被唤醒并继续执行。</p> </li><li> <p><strong>与互斥量配合使用：</strong><code>std::condition_variable</code>需要与互斥量（<code>std::mutex</code>或<code>std::unique_lock&lt;std::mutex&gt;</code>）配合使用，以确保线程之间的互斥性。在等待之前，线程必须先锁定互斥量，以避免竞争条件。当条件满足时，通知其他等待的线程之前，必须再次锁定互斥量。</p> </li><li> <p><strong>支持超时等待：</strong><code>std::condition_variable</code>提供了带有超时参数的等待函数<code>wait_for</code>和<code>wait_until</code>，允许线程在等待一段时间后自动被唤醒。这对于处理超时情况或限时等待非常有用。</p> </li></ul> 
<p><strong>使用<code>std::condition_variable</code>的一般步骤如下：</strong></p> 
<ol><li>创建一个<code>std::condition_variable</code>对象。</li><li>创建一个互斥量对象（<code>std::mutex</code>或<code>std::unique_lock&lt;std::mutex&gt;</code>）。</li><li>在等待线程中，使用<code>std::unique_lock</code>锁定互斥量，并调用<code>wait</code>函数进入等待状态。</li><li>在唤醒线程中，使用<code>std::unique_lock</code>锁定互斥量，并调用<code>notify_one</code>或<code>notify_all</code>函数通知等待的线程。</li><li>等待线程被唤醒后，继续执行相应的操作。</li></ol> 
<p><strong>示例：</strong></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;condition_variable&gt;</span></span>

std<span class="token double-colon punctuation">::</span>mutex mtx<span class="token punctuation">;</span>  <span class="token comment">// 互斥量</span>
std<span class="token double-colon punctuation">::</span>condition_variable cv<span class="token punctuation">;</span>  <span class="token comment">// 条件变量</span>
<span class="token keyword">bool</span> isReady <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment">// 条件</span>

<span class="token keyword">void</span> <span class="token function">thread_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>isReady<span class="token punctuation">)</span> 
    <span class="token punctuation">{<!-- --></span>
        cv<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 等待条件满足</span>
    <span class="token punctuation">}</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Thread is notified"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span>thread_function<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 模拟一段耗时操作</span>
    std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span>
        isReady <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment">// 设置条件为true</span>
    <span class="token punctuation">}</span>
    cv<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 通知等待的线程</span>

    t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上述示例中，创建了一个线程，该线程在等待状态下通过<code>cv.wait(lock)</code>等待条件满足。主线程经过一段时间后将条件设置为<code>true</code>，然后通过<code>cv.notify_one()</code>通知等待的线程。等待的线程被唤醒后输出一条消息。</p> 
<hr> 
<h2><a id="stdatomic_483"></a>五、std::atomic</h2> 
<p><code>std::mutex</code>可以很好地解决多线程资源争抢的问题，但它每次循环都要加锁、解锁，这样固然会浪费很多的时间。</p> 
<p>在 C++ 中，<code>std::atomic</code> 是用来提供原子操作的类，<strong>atomic</strong>，本意为<strong>原子</strong>，原子操作是最小的且不可并行化的操作。这就意味着即使是多线程，也要像同步进行一样同步操作原子对象，从而省去了互斥量上锁、解锁的时间消耗。</p> 
<p>使用 <code>std::atomic</code> 可以保证数据在操作期间不被其他线程修改，这样就避免了数据竞争，使得程序在多线程并发访问时仍然能够正确执行。</p> 
<p><strong>示例：</strong></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;atomic&gt;</span>   <span class="token comment">//必须包含</span></span>

std<span class="token double-colon punctuation">::</span>atomic_int num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">thread_function</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>atomic_int <span class="token operator">&amp;</span>n<span class="token punctuation">)</span>  <span class="token comment">//修改类型</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		n<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>thread myThread<span class="token punctuation">[</span><span class="token number">500</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>thread <span class="token operator">&amp;</span>a <span class="token operator">:</span> myThread<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		a <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span>thread_function<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">ref</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		a<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"num = "</span> <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Main thread exits!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-c++">//result
num = 50000
Main thread exits!
</code></pre> 
<p><strong>说明：</strong><code>std::atomic_int</code>是<code>std::atomic&lt;int&gt;</code>的别名。</p> 
<hr> 
<h3><a id="_534"></a>如果这篇文章对你有所帮助，渴望获得你的一个点赞！</h3> 
<p><img src="https://images2.imgbox.com/81/b9/4CDdNcwd_o.jpg" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/20d6bf062b7ea1d87da371b6a52ba7c7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">图书信息管理系统（python，sqlite）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/847a3144eb6e10f060c1957407a61794/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Google Colab免费GPU大揭晓：超详细使用攻略</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>