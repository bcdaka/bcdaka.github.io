<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构与算法】最小生成树之普里姆(Prim)算法和克鲁斯卡尔(Kruskal)算法 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/516bdd2e0490e2daeb997c8cc68e3816/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构与算法】最小生成树之普里姆(Prim)算法和克鲁斯卡尔(Kruskal)算法">
  <meta property="og:description" content="🌱博客主页：大寄一场.
🌱系列专栏：数据结构与算法
😘博客制作不易欢迎各位👍点赞&#43;⭐收藏&#43;➕关注
目录
前言
一、最小生成树的概念
二、最小生成树的求解方法
三、练习题
四、最小生成树在实际应用中的例子
前言 最近非科班的同学学到了最小生成树并询问我，于是想趁热打火，来总结顺便复习一下~
最小生成树(Minimum Spanning Tree,简称MST)是一个无向连通图中包含所有顶点的最短边集。在许多实际问题中，找到一个最小生成树对于理解和解决这些问题至关重要。本文将介绍最小生成树的概念、求解方法以及其在实际应用中的一些例子。
一、最小生成树的概念 假设我们有一个无向连通图G=(V,E),其中V是顶点集合，E是边集合。我们需要找到一个最小生成树，使得每个顶点都至少与一条边相连。这个最小生成树就是MST。
二、最小生成树的求解方法 1.Prim算法 Prim算法是一种贪心算法，用于在具有有向边的加权图中寻找最小生成树。算法的基本思想是从任意一个顶点开始，沿着权重最小的边进行扩展，直到找到整个MST
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #define INF INT_MAX // 邻接矩阵表示的无向图 typedef struct { int V; // 顶点数 int E; // 边数 int G[100][100]; // 邻接矩阵 } Graph; // 获取边的权重 int getWeight(Graph G, int u, int v) { return G[u][v]; } // Kruskal算法求最小生成树 Graph primMST(Graph G) { int V = G.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-07-07T12:42:18+08:00">
    <meta property="article:modified_time" content="2023-07-07T12:42:18+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构与算法】最小生成树之普里姆(Prim)算法和克鲁斯卡尔(Kruskal)算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" src="https://images2.imgbox.com/61/57/Y9n7rzmk_o.gif"> </p> 
<blockquote> 
 <p>🌱博客主页：<a href="https://blog.csdn.net/weixin_61885496?type=blog" title="大寄一场">大寄一场</a>.</p> 
 <p>🌱系列专栏：<a href="https://blog.csdn.net/weixin_61885496/category_12186339.html" title="数据结构与算法">数据结构与算法</a></p> 
 <p>😘博客制作不易欢迎各位👍点赞+⭐收藏+➕关注<br><img alt="75486fdc2eee4efba3dfc46f574e64ef.gif#pic_center" src="https://images2.imgbox.com/3a/fe/jMXoc0U5_o.gif"></p> 
 <p></p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/6c/a1/1wXObdp2_o.gif"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p id="%E4%B8%80%E3%80%81%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">一、最小生成树的概念</a></p> 
<p id="%E4%BA%8C%E3%80%81%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E6%B1%82%E8%A7%A3%E6%96%B9%E6%B3%95-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E6%B1%82%E8%A7%A3%E6%96%B9%E6%B3%95" rel="nofollow">二、最小生成树的求解方法</a></p> 
<p id="%E4%B8%89%E3%80%81%E7%BB%83%E4%B9%A0%E9%A2%98-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E7%BB%83%E4%B9%A0%E9%A2%98" rel="nofollow">三、练习题</a></p> 
<p id="%E5%9B%9B%E3%80%81%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%9C%A8%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84%E4%BE%8B%E5%AD%90-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%9C%A8%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84%E4%BE%8B%E5%AD%90" rel="nofollow">四、最小生成树在实际应用中的例子</a></p> 
<hr> 
<h3>前言</h3> 
<p>最近非科班的同学学到了最小生成树并询问我，于是想趁热打火，来总结顺便复习一下~</p> 
<p>最小生成树(Minimum Spanning Tree,简称MST)是一个无向连通图中包含所有顶点的最短边集。在许多实际问题中，找到一个最小生成树对于理解和解决这些问题至关重要。本文将介绍最小生成树的概念、求解方法以及其在实际应用中的一些例子。</p> 
<h2 id="%E4%B8%80%E3%80%81%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5">一、最小生成树的概念</h2> 
<p>假设我们有一个无向连通图G=(V,E),其中V是顶点集合，E是边集合。我们需要找到一个最小生成树，使得每个顶点都至少与一条边相连。这个最小生成树就是MST。</p> 
<p><img alt="" height="553" src="https://images2.imgbox.com/49/03/ekPObfzK_o.png" width="1083"> </p> 
<p> </p> 
<h2 id="%E4%BA%8C%E3%80%81%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E6%B1%82%E8%A7%A3%E6%96%B9%E6%B3%95">二、最小生成树的求解方法</h2> 
<p>1.Prim算法 Prim算法是一种贪心算法，用于在具有有向边的加权图中寻找最小生成树。算法的基本思想是<span style="color:#ed7976;"><strong><span style="background-color:#fef2f0;">从任意一个顶点开始，沿着权重最小的边进行扩展</span></strong></span>，直到找到整个MST</p> 
<pre><code class="language-cpp">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define INF INT_MAX

// 邻接矩阵表示的无向图
typedef struct {
    int V; // 顶点数
    int E; // 边数
    int G[100][100]; // 邻接矩阵
} Graph;

// 获取边的权重
int getWeight(Graph G, int u, int v) {
    return G[u][v];
}

// Kruskal算法求最小生成树
Graph primMST(Graph G) {
    int V = G.V; // 顶点数
    int E = G.E; // 边数
    int parent[V]; // 父节点数组
    int dist[V]; // 从源点到每个顶点的距离数组
    int i, u, v;
    int minCost = 0; // 总代价
    int edgeCount = 0; // 已选边的数量
    Graph mstEdges; // MST边集合
    memset(parent, -1, sizeof(parent)); // 初始化父节点为-1
    memset(dist, INF, sizeof(dist)); // 初始化距离为正无穷大
    priorityQueueNode pq; // 优先队列头结点
    pq.data = (void*)&amp;dist[0];
    pq.index = 0;
    memset(mstEdges.G, 0, sizeof(mstEdges.G)); // 将邻接矩阵清零
    mstEdges.V = V;
    mstEdges.E = 0;
    do { // 不断扩展最小生成树，直到不存在增广路为止
        u = pq.index; // 取出距离源点最近的顶点u
        if (u == -1) break; // 如果已经没有顶点可选了，跳出循环
        pq.index = parent[u]; // 将当前顶点更新为其父节点
        edgeCount++; // 已选边的数量加1
        for (i = 0; i &lt; G.V; i++) { // 遍历所有顶点
            v = i; // 从当前顶点开始选择下一个顶点v
            if (dist[v] &gt; dist[u] + G.G[u][v]) { // 如果从u到v的距离比从u到源点的距离更短，则更新距离和优先级队列头结点
                dist[v] = dist[u] + G.G[u][v];
                pq.data = (void*)&amp;dist[0];
                pq.index = i;
            } else if (i != u &amp;&amp; v != u) { // 如果当前顶点u不是目标顶点，且从u到v的距离比从u到源点的距离更短，则将边的权重加入到最小生成树中，并更新优先级队列头结点的位置
                mstEdges.G[edgeCount] = getWeight(G, u, v);
                pq.data = (void*)&amp;mstEdges.G[0];
                pq.index = edgeCount++;
            } else if (i == u &amp;&amp; v != u) { // 如果当前顶点u是目标顶点，但从u到v的距离比从u到源点的距离更短，则将边的权重加入到最小生成树中，并将当前顶点更新为其父节点的值为已选边的数量减一(因为此时已经找到了一条增广路径)
                mstEdges.G[edgeCount] = getWeight(G, u, v);
                parent[v] = edgeCount--; // 将当前顶点的父节点设为已选边的数量减一(因为此时已经找到了一条增广路径)
            } else if (i != u &amp;&amp; v == u) continue; // 如果当前顶点u是目标顶点且从u到v的距离等于从u到源点的距离，则不需要进行任何操作，直接跳过本次循环继续下一次循环迭代
        }
        minCost += mstEdges.G[mstEdges.E-1]; // 将总代价加上已选边的权重之和作为新的总代价
        mstEdges.E++; // 将已选边的计数加一，表示又选了一条边加入到最小生成树中
    } while (edgeCount &lt; V); // 当已选边的数量小于顶点数时，继续扩展最小生成树直到不存在增广路为止</code></pre> 
<p>2.Kruskal算法 Kruskal算法也是一种贪心算法，用于在具有有向边的加权图中寻找最小生成树。算法的基本思想是<span style="color:#ed7976;"><strong><span style="background-color:#fef2f0;">每次选择权重最小的边来将两个顶点连接起来</span></strong></span>，直到找到整个MST。</p> 
<pre><code class="language-cpp">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define INF INT_MAX

// 邻接矩阵表示的无向图
typedef struct {
    int V; // 顶点数
    int E; // 边数
    int G[100][100]; // 邻接矩阵
} Graph;

// 获取边的权重
int getWeight(Graph G, int u, int v) {
    return G[u][v];
}

// Kruskal算法求最小生成树
Graph primMST(Graph G) {
    int V = G.V; // 顶点数
    int E = G.E; // 边数
    int parent[V]; // 父节点数组
    int dist[V]; // 从源点到每个顶点的距离数组
    int i, u, v;
    int minCost = 0; // 总代价
    int edgeCount = 0; // 已选边的数量
    Graph mstEdges; // MST边集合
    memset(parent, -1, sizeof(parent)); // 初始化父节点为-1
    memset(dist, INF, sizeof(dist)); // 初始化距离为正无穷大
    priorityQueueNode pq; // 优先队列头结点
    pq.data = (void*)&amp;dist[0];
    pq.index = 0;
    memset(mstEdges.G, 0, sizeof(mstEdges.G)); // 将邻接矩阵清零
    mstEdges.V = V;
    mstEdges.E = 0;
    do { // 不断扩展最小生成树，直到不存在增广路为止
        u = pq.index; // 取出距离源点最近的顶点u
        if (u == -1) break; // 如果已经没有顶点可选了，跳出循环
        pq.index = parent[u]; // 将当前顶点更新为其父节点
        edgeCount++; // 已选边的数量加1
        for (i = 0; i &lt; G.V; i++) { // 遍历所有顶点
            v = i; // 从当前顶点开始选择下一个顶点v
            if (dist[v] &gt; dist[u] + G.G[u][v]) { // 如果从u到v的距离比从u到源点的距离更短，则更新距离和优先级队列头结点
                dist[v] = dist[u] + G.G[u][v];
                pq.data = (void*)&amp;dist[0];
                pq.index = i;
            } else if (i != u &amp;&amp; v != u) { // 如果当前顶点u不是目标顶点，且从u到v的距离比从u到源点的距离更短，则将边的权重加入到最小生成树中，并更新优先级队列头结点的位置
                mstEdges.G[edgeCount] = getWeight(G, u, v);
                pq.data = (void*)&amp;mstEdges.G[0];
                pq.index = edgeCount++;
            } else if (i == u &amp;&amp; v != u) { // 如果当前顶点u是目标顶点，但从u到v的距离比从u到源点的距离更短，则将边的权重加入到最小生成树中，并将当前顶点更新为其父节点的值为已选边的数量减一(因为此时已经找到了一条增广路径)
                mstEdges.G[edgeCount] = getWeight(G, u, v);
                parent[v] = edgeCount--; // 将当前顶点的父节点设为已选边的数量减一(因为此时已经找到了一条增广路径)
            } else if (i != u &amp;&amp; v == u) continue; // 如果当前顶点u是目标顶点且从u到v的距离等于从u到源点的距离，则不需要进行任何操作，直接跳过本次循环继续下一次循环迭代
        }
        minCost += mstEdges.G[mstEdges.E-1]; // 将总代价加上已选边的权重之和作为新的总代价
        mstEdges.E++; // 将已选边的计数加一，表示又选了一条边加入到最小生成树中
    } while (edgeCount &lt; V); // 当已选边的数量小于顶点数时，继续扩展最小生成树直到不存在增广路为止</code></pre> 
<p></p> 
<h2 id="%E4%B8%89%E3%80%81%E7%BB%83%E4%B9%A0%E9%A2%98">三、练习题</h2> 
<p>对如图所示的带权连通图按照克鲁斯卡尔和普里姆算法得到其最小生成树，请写出生成过程中依次得到的各条边，并计算该最小生成树的权值。</p> 
<p></p> 
<p><img alt="" height="289" src="https://images2.imgbox.com/c4/13/FJRVMERx_o.png" width="437"></p> 
<p></p> 
<p> 普里姆算法<span style="color:#ed7976;"><strong><span style="background-color:#fef2f0;">从任意一个顶点开始，沿着权重最小的边进行扩展</span></strong></span></p> 
<p><img alt="" height="240" src="https://images2.imgbox.com/8c/76/xIMq6wMK_o.png" width="324"></p> 
<p>克鲁斯卡尔<span style="color:#ed7976;"> <strong><span style="background-color:#fef2f0;">每次选择权重最小的边来将两个顶点连接起来</span></strong></span></p> 
<p><img alt="" height="280" src="https://images2.imgbox.com/1a/eb/Y7GXgla9_o.png" width="349"></p> 
<p></p> 
<h2 id="%E5%9B%9B%E3%80%81%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%9C%A8%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84%E4%BE%8B%E5%AD%90">四、最小生成树在实际应用中的例子</h2> 
<p><span style="color:#0d0016;">最小生成树在很多实际应用中有很广泛的应用，例如路由算法、社交网络分析、电路设计等。下面分别介绍这些领域中的应用案例。</span></p> 
<ol><li> <p><span style="color:#0d0016;">路由算法<br> 最小生成树在路由算法中有很重要的应用。例如，在单源最短路径问题中，我们可以使用Prim算法或Kruskal算法来找到最小生成树。同时，最小生成树也可以用于计算网络中每个节点的最短路径。这对于网络优化和资源分配非常重要。</span></p> </li><li> <p><span style="color:#0d0016;">社交网络分析<br> 最小生成树在社交网络分析中也有很广泛的应用。例如，我们可以使用最小生成树来确定社交网络中的社区结构。通过将每个节点与它的邻居节点连接起来，并删除具有较小的连通性(即具有较少的邻居节点)的边，我们可以得到一个最小生成树。然后，我们可以通过检查哪些节点之间的边被保留来确定这些节点属于同一个社区。</span></p> </li><li><span style="color:#0d0016;">电路设计<br> 最小生成树在电路设计中有很重要的应用。例如，在电路布线中，我们可以使用最小生成树来最小化电路的总长度和电阻。通过将电路中的节点与它们的相邻节点连接起来，并删除具有较小的阻抗(即具有较少的电阻或电容)的边，我们可以得到一个最小生成树。然后，我们可以选择将电阻和电容分配给这个最小生成树上的节点，以最小化总长度和阻抗。</span></li></ol> 
<p><span style="color:#0d0016;">总之，最小生成树在许多领域中都有着广泛的应用。它不仅可以帮助我们解决各种计算问题，还可以帮助我们理解和分析现实世界中的复杂系统。</span></p> 
<hr> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b0/f7/eFWxPSHP_o.gif"></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/42d67a0f1892fc157939adf091e10869/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【自学笔记】在SQL Server中创建用户角色及授权(使用SQL语句)更新2023.07.06</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/63c2b3846f55615e29d7c1d791dd1840/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">前端篇（第二节）-使用npm安装pnpm</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>