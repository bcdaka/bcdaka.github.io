<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【栈和队列】算法题 ---- 力扣 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/3339addbdf5c53dd17761bb1ba565e78/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【栈和队列】算法题 ---- 力扣">
  <meta property="og:description" content="通过前面栈和队列的学习，现在来看这些算法题目
一、有效的括号 本题让判断括号是否有效
第一眼看可能没一点思路，但仔细分析一下；
我们学习过栈数据结构，知道栈先进后出的原则，那我们就可以使用啊；把题目的左括号存储起来，让右括号跟左括号一一比较。
思路：
遍历字符串，遇到左括号就括号入栈，遇到右括号就与栈顶数据进行对比，如果配对就继续；如果不配对，就返回false
画图分析：
现在有这样的括号字符串
遍历字符串，第一个是 { 左括号，就入栈
ps接着遍历， [ 依然是左括号，入栈
ps接着遍历， ( 还是左括号，入栈
ps接着遍历， ) 是右括号，与栈顶数据进行比较，括号匹配，出栈
ps接着遍历， ] 是右括号，与栈顶数据比较，括号匹配，出栈
ps接着遍历， } 是右括号，与栈顶数据进行比较，括号匹配，出栈
ps遍历完字符串，再判断栈是否为空？如果为空，就代表所以括号都匹配了；如果栈不为空，括号就不匹配。
此外，再遍历过程中，有依次括号不匹配就要直接返回false
力扣题代码如下：
typedef char SType; typedef struct Stack { SType* arr; int size; // 栈顶 int num; // 空间大小 } Stack; // 初始化 void STInit(Stack* ps) { assert(ps); ps-&gt;arr = NULL; ps-&gt;size = ps-&gt;num = 0; } // 判断栈是否为空 bool STEmpty(Stack* ps) { assert(ps); return ps-&gt;size == 0; } // 入栈 void STPush(Stack* ps, SType x) { assert(ps); // 判断空间大小是否足够 if (ps-&gt;num &lt;= ps-&gt;size) { int newnum = (ps-&gt;num == 0) ?">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-23T23:27:41+08:00">
    <meta property="article:modified_time" content="2024-07-23T23:27:41+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【栈和队列】算法题 ---- 力扣</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>        通过前面栈和队列的学习，现在来看这些算法题目</p> 
<h2>一、<a class="link-info" href="https://leetcode.cn/problems/valid-parentheses/description/" rel="nofollow" title="有效的括号">有效的括号</a></h2> 
<p><img alt="" height="400" src="https://images2.imgbox.com/df/bc/bTPq7t3E_o.png" width="928"></p> 
<p>        本题让判断括号是否有效</p> 
<p><img alt="" height="453" src="https://images2.imgbox.com/f2/58/llfnycr7_o.png" width="375"></p> 
<p>第一眼看可能没一点思路，但仔细分析一下；</p> 
<p>        我们学习过栈数据结构，知道栈先进后出的原则，那我们就可以使用啊；把题目的左括号存储起来，让右括号跟左括号一一比较。</p> 
<p><span style="color:#4da8ee;"><strong><span style="background-color:#fefcd8;">思路：</span></strong></span></p> 
<p><span style="color:#4da8ee;"><strong>        </strong></span><span style="color:#0d0016;"><strong><span style="background-color:#a2e043;">遍历字符串，遇到左括号就括号入栈，遇到右括号就与栈顶数据进行对比，如果配对就继续；如果不配对，就返回false</span></strong></span></p> 
<p><span style="color:#4da8ee;"><strong><span style="background-color:#fefcd8;">画图分析：</span></strong></span></p> 
<p><img alt="" height="118" src="https://images2.imgbox.com/a6/9b/JBNmiDB0_o.png" width="392">  现在有这样的括号字符串</p> 
<p>        遍历字符串，第一个是  {  左括号，就入栈</p> 
<p><img alt="" height="300" src="https://images2.imgbox.com/4e/45/4EHNKq8F_o.png" width="270"></p> 
<p>        ps接着遍历， [  依然是左括号，入栈</p> 
<p><img alt="" height="300" src="https://images2.imgbox.com/11/0b/jBokYp1Q_o.png" width="309"></p> 
<p>        ps接着遍历，  (  还是左括号，入栈</p> 
<p><img alt="" height="300" src="https://images2.imgbox.com/d4/a8/efxVi3ZD_o.png" width="280"></p> 
<p>        ps接着遍历，  )  是右括号，与栈顶数据进行比较，括号匹配，出栈</p> 
<p><img alt="" height="346" src="https://images2.imgbox.com/6b/e2/jEQufsMa_o.png" width="538"></p> 
<p>        ps接着遍历，  ]  是右括号，与栈顶数据比较，括号匹配，出栈</p> 
<p><img alt="" height="365" src="https://images2.imgbox.com/57/28/Y7uVicy0_o.png" width="577"></p> 
<p>        ps接着遍历，  }  是右括号，与栈顶数据进行比较，括号匹配，出栈</p> 
<p><img alt="" height="341" src="https://images2.imgbox.com/be/86/AMg0SUGV_o.png" width="528"></p> 
<p>        ps遍历完字符串，再判断栈是否为空？如果为空，就代表所以括号都匹配了；如果栈不为空，括号就不匹配。</p> 
<p>       <span style="color:#ff9900;"><strong> 此外，再遍历过程中，有依次括号不匹配就要直接返回false</strong></span></p> 
<p><span style="color:#a2e043;"><strong><span style="background-color:#fefcd8;">力扣题代码如下：</span></strong></span></p> 
<pre><code class="language-cpp">typedef char SType;
typedef struct Stack {
    SType* arr;
    int size; // 栈顶
    int num;  // 空间大小
} Stack;

// 初始化
void STInit(Stack* ps) {
    assert(ps);
    ps-&gt;arr = NULL;
    ps-&gt;size = ps-&gt;num = 0;
}
// 判断栈是否为空
bool STEmpty(Stack* ps) {
    assert(ps);
    return ps-&gt;size == 0;
}
// 入栈
void STPush(Stack* ps, SType x) {
    assert(ps);
    // 判断空间大小是否足够
    if (ps-&gt;num &lt;= ps-&gt;size) {
        int newnum = (ps-&gt;num == 0) ? 4 : 2 * ps-&gt;num;
        SType* tmp = (SType*)realloc(ps-&gt;arr, newnum * sizeof(Stack));
        if (tmp == NULL) {
            perror("realloc filed");
            exit(1);
        }
        ps-&gt;arr = tmp;
        ps-&gt;num = newnum;
    }
    ps-&gt;arr[ps-&gt;size++] = x;
}
// 出栈
void STPop(Stack* ps) {
    assert(ps);           // 不能传NULL
    assert(!STEmpty(ps)); // 栈不能为空
    ps-&gt;size--;
}
// 取栈顶数据
SType STtop(Stack* ps) {
    assert(ps);           // 不能传NULL
    assert(!STEmpty(ps)); // 栈不能为空
    return ps-&gt;arr[ps-&gt;size - 1];
}
// 获取栈中数据个数
int STSize(Stack* ps) {
    assert(ps);
    return ps-&gt;size;
}
// 栈的销毁
void STDesTroy(Stack* ps) {
    assert(ps);
    if (ps-&gt;arr)
        free(ps-&gt;arr);
    ps-&gt;arr = NULL;
    ps-&gt;size = ps-&gt;num = 0;
}

bool isValid(char* s) {
    Stack arr;
    // 初始化
    STInit(&amp;arr);
    char* ps = s;
    while (*ps != '\0') {
        if (*ps == '(' || *ps == '[' || *ps == '{') {
            // 入栈
            STPush(&amp;arr, *ps);
        } else {
            // 取栈顶数据
            if (STEmpty(&amp;arr)) {
                return false;
            }
            char ch = STtop(&amp;arr);
            if ((ch == '(' &amp;&amp; *ps == ')') || (ch == '[' &amp;&amp; *ps == ']') ||
                (ch == '{' &amp;&amp; *ps == '}')) {
                STPop(&amp;arr);
            } else {
                return false;
            }
        }
        ps++;
    }
    if (STEmpty(&amp;arr)) // 栈为空
    {
        return true;
    }
    return false;
}</code></pre> 
<p></p> 
<h2>二、<a class="link-info" href="https://leetcode.cn/problems/implement-stack-using-queues/description/" rel="nofollow" title="用队列实现栈">用队列实现栈</a></h2> 
<p><img alt="" height="450" src="https://images2.imgbox.com/df/ff/PWw00Gbj_o.png" width="1050"></p> 
<p>        使用队列来实现栈，我们直到，队列是先进先出，而栈是先进后出。这里我们需要用两个队列来实现栈的相关操作</p> 
<p><span style="color:#4da8ee;"><strong>思路：</strong></span></p> 
<p>        保证两个队列中有一个为空，再两个队列之间来回导入导出数据。</p> 
<blockquote> 
 <p><span style="color:#4da8ee;"><strong>        </strong></span><span style="color:#38d8f0;"><strong>入栈：往不为空的队列里面插入数据</strong></span></p> 
 <p><span style="color:#38d8f0;"><strong>        出栈：找到不为空的队列，将size-1个数据导入到另一个队列，最后剩余的一个数据，就是要出栈的数据</strong></span></p> 
 <p><span style="color:#38d8f0;"><strong>        取栈顶元素：找到不为空的队列，取队尾元素即可</strong></span></p> 
</blockquote> 
<p><img alt="" height="600" src="https://images2.imgbox.com/14/52/7cYTwy9t_o.png" width="908"></p> 
<p>假设依次插入了1，2，3三个数据，现在要出栈</p> 
<p><img alt="" height="363" src="https://images2.imgbox.com/d8/6f/M1zRNqVZ_o.png" width="862"></p> 
<p>        将q1中数据size-1（2个）导入到q2中。</p> 
<p><img alt="" height="365" src="https://images2.imgbox.com/6e/b4/M4j4ME87_o.png" width="928"></p> 
<p>        现在q1当中剩余的数据就是要出栈的数据（即栈顶）。这样就满足了栈先进先出的特点。</p> 
<p><span style="color:#a2e043;"><strong><span style="background-color:#fefcd8;">力扣题代码如下：</span></strong></span></p> 
<pre><code class="language-cpp">typedef int QType;
typedef struct QueueNode // 队列节结构
{
    QType data;
    struct QueueNode* next;
} QueueNode;
typedef struct Queue // 队列结构
{
    int size;         // 队列中的数据个数
    QueueNode* phead; // 队头
    QueueNode* ptial; // 队尾
} Queue;

// 初始化
void QueueInit(Queue* pq) {
    assert(pq);
    pq-&gt;phead = pq-&gt;ptial = NULL;
    pq-&gt;size = 0;
}
// 判断队列是否为空
bool QueueEmpty(Queue* pq) {
    assert(pq);
    return pq-&gt;size == 0;
}
// 入队列--从队尾插入数据
void QueuePush(Queue* pq, QType x) {
    assert(pq);
    QueueNode* newnode = (QueueNode*)malloc(sizeof(QueueNode));
    newnode-&gt;data = x;
    newnode-&gt;next = NULL;
    if (QueueEmpty(pq)) // 队列为空
    {
        pq-&gt;phead = pq-&gt;ptial = newnode;
    } else { // 队列不为空
        pq-&gt;ptial-&gt;next = newnode;
        pq-&gt;ptial = newnode;
    }
    pq-&gt;size++;
}
// 出队列--从对头删除数据
void QueuePop(Queue* pq) {
    assert(pq);              // 不能传NULL
    //assert(!QueueEmpty(pq)); // 队列不能为空
    QueueNode* del = pq-&gt;phead;
    pq-&gt;phead = pq-&gt;phead-&gt;next;
    if (pq-&gt;size == 1) // 队列只有一个节点
    {
        pq-&gt;ptial = NULL;
    }
    pq-&gt;size--;
    free(del);
    del = NULL;
}
// 取队头数据
QType QueueFront(Queue* pq) {
    assert(pq);              // 不能传NULL
    //assert(!QueueEmpty(pq)); // 队列不能为空
    return pq-&gt;phead-&gt;data;
}
// 取队尾数据
QType QueueBack(Queue* pq) {
    assert(pq);              // 不能传NULL
    //assert(!QueueEmpty(pq)); // 队列不能为空
    return pq-&gt;ptial-&gt;data;
}
// 获取队列数据个数
int QueueSize(Queue* pq) {
    assert(pq); // 不能传NULL
    return pq-&gt;size;
}
// 销毁队列
void QueueDesTroy(Queue* pq) {
    assert(pq);              // 不能传NULL
    //assert(!QueueEmpty(pq)); // 队列不能为空
    QueueNode* pcur = pq-&gt;phead;
    while (pcur) {
        QueueNode* del = pcur;
        pcur = pcur-&gt;next;
        free(del);
        del = NULL;
    }
    pq-&gt;phead = pq-&gt;ptial = NULL;
    pq-&gt;size = 0;
}

typedef struct {
    Queue q1;
    Queue q2;
} MyStack;

MyStack* myStackCreate() {
    MyStack* Qst = (MyStack*)malloc(sizeof(MyStack));
    QueueInit(&amp;Qst-&gt;q1);
    QueueInit(&amp;Qst-&gt;q2);
    return Qst;
}

void myStackPush(MyStack* obj, int x) {
    // 往不为空的队列中插入数据
    if (QueueEmpty(&amp;obj-&gt;q1)) {
        QueuePush(&amp;obj-&gt;q2, x);
    } else {
        QueuePush(&amp;obj-&gt;q1, x);
    }
}

int myStackPop(MyStack* obj) {
    // 先找到不为空的队列
    Queue* empq = &amp;obj-&gt;q1;
    Queue* noneq = &amp;obj-&gt;q2;
    if (!(QueueEmpty(&amp;obj-&gt;q1))) // 如果q1不为空
    {
        empq = &amp;obj-&gt;q2;
        noneq = &amp;obj-&gt;q1;
    }
    //empq --  空队列
    //noneq --  非空队列
    while(QueueSize(noneq) &gt; 1) {
        // 将noneq队列的数据导入到empq中去
        QueuePush(empq, QueueFront(noneq));
        QueuePop(noneq);
    }
    int ret = QueueFront(noneq);
    QueuePop(noneq);
    return ret;
}

int myStackTop(MyStack* obj) {
    if(QueueEmpty(&amp;obj-&gt;q1))
    {
        return QueueBack(&amp;obj-&gt;q2);
    }else{
        return QueueBack(&amp;obj-&gt;q1);
    }
}

bool myStackEmpty(MyStack* obj) {
    return QueueEmpty(&amp;obj-&gt;q1) &amp;&amp; QueueEmpty(&amp;obj-&gt;q2);
}

void myStackFree(MyStack* obj) {
    free(obj);
    obj = NULL;
}</code></pre> 
<h2>三、<a class="link-info" href="https://leetcode.cn/problems/implement-queue-using-stacks/description/" rel="nofollow" title="用栈实现队列">用栈实现队列</a></h2> 
<p><img alt="" height="566" src="https://images2.imgbox.com/02/e9/lSa0jXBj_o.png" width="1078"></p> 
<p>        上一个题让我们用队列来实现栈，这个用两个栈来实现队列。</p> 
<p>定义两个栈</p> 
<p><img alt="" height="314" src="https://images2.imgbox.com/31/ba/JLKmlwgN_o.png" width="709"></p> 
<p><span style="color:#4da8ee;"><strong><span style="background-color:#fefcd8;">思路：</span></strong></span></p> 
<p>        往PushST中插入数据，再将数据导入到PopST中，出栈即可；</p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>        <span style="background-color:#38d8f0;">入队列：往PushST中插入数据</span></strong></span></p> 
 <p><span style="color:#0d0016;"><strong>        <span style="background-color:#38d8f0;">出队列：判断栈PopST是否为空？如果PopST栈为空，就将栈PushST中数据导入到栈PopST中去，再让栈PopST出栈操作；如果不为空，直接让栈PopST出栈操作即可。</span></strong></span></p> 
 <p><span style="color:#0d0016;"><strong>        <span style="background-color:#38d8f0;">取队头数据：和出队列操作一样，只是不需要出栈操作，只取数据</span></strong></span></p> 
</blockquote> 
<p><strong><span style="color:#4da8ee;"><span style="background-color:#fefcd8;">分析：</span></span></strong></p> 
<p><span style="color:#4da8ee;"><strong>        假设依次插入了1，2，3三个数据，现在出栈一次，再插入一个数据4，最后取队头数据，依次出栈。</strong></span></p> 
<p><img alt="" height="441" src="https://images2.imgbox.com/63/17/82GzKJc6_o.png" width="1200"></p> 
<p>        出栈一次，PopST为空，就将PushST中数据导入到PopST中去。</p> 
<p>依次导入</p> 
<p><img alt="" height="300" src="https://images2.imgbox.com/ee/44/GlUUKpfD_o.png" width="794"></p> 
<p><img alt="" height="300" src="https://images2.imgbox.com/0c/25/RMbgebVS_o.png" width="797"></p> 
<p><img alt="" height="300" src="https://images2.imgbox.com/7f/95/J2jxjH1x_o.png" width="766"></p> 
<p>        出栈；</p> 
<p><img alt="" height="562" src="https://images2.imgbox.com/7b/19/P0M771mk_o.png" width="1153"></p> 
<p>再插入数据4</p> 
<p><img alt="" height="300" src="https://images2.imgbox.com/6e/5e/MMzc9on8_o.png" width="709"></p> 
<p>取队头数据：</p> 
<p><img alt="" height="300" src="https://images2.imgbox.com/ee/0d/tOOQjVLA_o.png" width="800"></p> 
<p>最后依次出队列</p> 
<p><img alt="" height="511" src="https://images2.imgbox.com/d9/a4/3V3cmuU6_o.png" width="1133"></p> 
<p><img alt="" height="518" src="https://images2.imgbox.com/08/7b/Fk9wWDAr_o.png" width="1143"></p> 
<p>现在，PopST栈为空，就要先将PushST中数据先导入到PopST中。</p> 
<p><img alt="" height="476" src="https://images2.imgbox.com/08/bf/NpHRUClQ_o.png" width="1095"></p> 
<p>再出队列</p> 
<p><img alt="" height="537" src="https://images2.imgbox.com/b7/f7/C0J8KuuK_o.png" width="1132"></p> 
<p><span style="color:#4da8ee;"><strong><span style="background-color:#fefcd8;">力扣题代码如下：</span></strong></span></p> 
<pre><code class="language-cpp">typedef int SType;
typedef struct Stack
{
	SType* arr;
	int size;  //栈顶
	int num;   //空间大小
}Stack;
//初始化
void STInit(Stack* ps)
{
	assert(ps);
	ps-&gt;arr = NULL;
	ps-&gt;size = ps-&gt;num = 0;
}
//判断栈是否为空
bool STEmpty(Stack* ps)
{
	assert(ps);
	return ps-&gt;size == 0;
}
//入栈
void STPush(Stack* ps, SType x)
{
	assert(ps);
	//判断空间大小是否足够
	if (ps-&gt;num &lt;= ps-&gt;size)
	{
		int newnum = (ps-&gt;num == 0) ? 4 : ps-&gt;num * 2;
		SType* tmp = (SType*)realloc(ps-&gt;arr, newnum * sizeof(Stack));
		if (tmp == NULL)
		{
			perror("realloc filed");
			exit(1);
		}
		ps-&gt;arr = tmp;
		ps-&gt;num = newnum;
	}
	ps-&gt;arr[ps-&gt;size++] = x;
}
//出栈
void STPop(Stack* ps)
{
	assert(ps); //不能传NULL
	assert(!STEmpty(ps));  //栈不能为空
	ps-&gt;size--;
}
//取栈顶数据
SType STtop(Stack* ps)
{
	return ps-&gt;arr[ps-&gt;size - 1];
}
//获取栈中数据个数
int STSize(Stack* ps)
{
	assert(ps);
	return ps-&gt;size;
}
//栈的销毁
void STDesTroy(Stack* ps)
{
	assert(ps);
	if (ps-&gt;arr)
		free(ps-&gt;arr);
	ps-&gt;arr = NULL;
	ps-&gt;size = ps-&gt;num = 0;
}


typedef struct {
    Stack s1;
    Stack s2;
} MyQueue;

//初始化
MyQueue* myQueueCreate() {
    MyQueue* Queue=(MyQueue*)malloc(sizeof(MyQueue));
    STInit(&amp;Queue-&gt;s1);
    STInit(&amp;Queue-&gt;s2);
    return Queue;
}
//插入数据
void myQueuePush(MyQueue* obj, int x) {
    assert(obj);
    STPush(&amp;obj-&gt;s1, x);
}

int myQueuePop(MyQueue* obj) {
    assert(obj);
    if(STEmpty(&amp;obj-&gt;s2))
    {
        //把s1中数据导入到s2
        while(!STEmpty(&amp;obj-&gt;s1))
        {
            STPush(&amp;obj-&gt;s2,STtop(&amp;obj-&gt;s1));
            STPop(&amp;obj-&gt;s1);
        }
    }
    int ret=STtop(&amp;obj-&gt;s2);
    STPop(&amp;obj-&gt;s2);
    return ret;
}

int myQueuePeek(MyQueue* obj) {
    if(STEmpty(&amp;obj-&gt;s2))
    {
        //把s1中数据导入到s2
        while(!STEmpty(&amp;obj-&gt;s1))
        {
            STPush(&amp;obj-&gt;s2,STtop(&amp;obj-&gt;s1));
            STPop(&amp;obj-&gt;s1);
        }
    }
    return STtop(&amp;obj-&gt;s2);
}

bool myQueueEmpty(MyQueue* obj) {
    return (STEmpty(&amp;obj-&gt;s1)) &amp;&amp; (STEmpty(&amp;obj-&gt;s2));
}

void myQueueFree(MyQueue* obj) {
    if(obj)
        free(obj);
    obj=NULL;
}</code></pre> 
<h2 style="background-color:transparent;">四、<a class="link-info" href="https://leetcode.cn/problems/design-circular-queue/description/" rel="nofollow" title="设计循环队列">设计循环队列</a></h2> 
<p><img alt="" height="627" src="https://images2.imgbox.com/85/ef/IgduaqIF_o.png" width="1057"></p> 
<p>        设计循环队列，这里使用数组来设计</p> 
<p>这里会设计到的一些问题：</p> 
<p><strong><span style="color:#ff9900;">        插入数据，如何判断空间是否满了？</span></strong><strong><span style="color:#ff9900;">       </span></strong></p> 
<p>这里多申请一个空间，便于判断空间是否满了</p> 
<p><img alt="" height="183" src="https://images2.imgbox.com/ca/d0/f2BN4p57_o.png" width="862"></p> 
<p><strong><span style="color:#ff9900;">        删除数据，如何去删？</span></strong></p> 
<p>这里，删除front指向的数据，就是队头数据</p> 
<p>详细代码如下：</p> 
<pre><code class="language-cpp">
typedef struct {
    int* arr;
    int front;
    int rear;
    int num;
} MyCircularQueue;

MyCircularQueue* myCircularQueueCreate(int k) {
    MyCircularQueue* pq = (MyCircularQueue*)malloc(sizeof(MyCircularQueue));
    pq-&gt;arr = malloc((k + 1) * sizeof(int));
    pq-&gt;front = pq-&gt;rear = 0;
    pq-&gt;num = k;
    return pq;
}

bool myCircularQueueIsEmpty(MyCircularQueue* obj) {

    return (obj-&gt;rear == obj-&gt;front);
}

bool myCircularQueueIsFull(MyCircularQueue* obj) {
    return (obj-&gt;rear + 1) % (obj-&gt;num + 1) == obj-&gt;front;
}

bool myCircularQueueEnQueue(MyCircularQueue* obj, int value) {

    if (myCircularQueueIsFull(obj)) // 队列满了
    {
        return false;
    }
    // 插入数据
    obj-&gt;arr[obj-&gt;rear++] = value;
    obj-&gt;rear %= (obj-&gt;num + 1);
    return true;
}

bool myCircularQueueDeQueue(MyCircularQueue* obj) {
    if (myCircularQueueIsEmpty(obj)) {
        return false;
    }
    obj-&gt;front++;
    obj-&gt;front %= (obj-&gt;num + 1);
    return true;
}

int myCircularQueueFront(MyCircularQueue* obj) {
    if (myCircularQueueIsEmpty(obj))
        return -1;
    return obj-&gt;arr[obj-&gt;front];
}

int myCircularQueueRear(MyCircularQueue* obj) {
    if (myCircularQueueIsEmpty(obj))
        return -1;
    int ret=obj-&gt;rear-1;
    if(obj-&gt;rear==0)
    {
        ret=obj-&gt;num;
    }
    return obj-&gt;arr[ret];
}

void myCircularQueueFree(MyCircularQueue* obj) {
    free(obj-&gt;arr);
    free(obj);
    obj = NULL;
}
</code></pre> 
<p><span style="color:#ffd900;"><strong><span style="background-color:#eaf4fc;">感谢各位大佬支持并指出问题，</span></strong></span></p> 
<p><strong>                       <span style="color:#4da8ee;"><span style="background-color:#fefcd8;"> 如果本篇内容对你有帮助，可以一键三连支持以下，感谢支持！！！</span></span></strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/8c/72/CBy6cz7w_o.jpg"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7b673be4c6968cef04e1c4ca381eb298/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SpringBoot整合Flink CDC，实时追踪mysql数据变动</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c066c85205ba51e373cd976844a0e172/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【数据结构】二叉树——顺序结构——堆及其实现</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>