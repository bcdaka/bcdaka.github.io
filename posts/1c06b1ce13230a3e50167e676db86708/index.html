<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c＋＋STL容器中vector的使用，模拟实现及迭代器使用注意事项和迭代器失效问题 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/1c06b1ce13230a3e50167e676db86708/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="c＋＋STL容器中vector的使用，模拟实现及迭代器使用注意事项和迭代器失效问题">
  <meta property="og:description" content="目录
前言：
1.vector的介绍及使用
1.2 vector的使用
1.2 1 vector的定义
1.2 2 vector iterator（迭代器）的使用 1.2.3 vector 空间增长问题 1.2.4 vector 增删查改 1.2.5vector 迭代器失效问题。
2.vector模拟实现 2.1 std::vector的核心框架接口的模拟实现bit::vector
2.2 使用memcpy拷贝问题
前言： 在前面的章节我们已经接触过了关于STL的知识，也就是string类，我们详细介绍了string类的特性及使用，而严格来说string类并没有被归为STL中，因为string类的出现早于STL，string类的接口也比STL中的单个类多，使得string类较其他类显得冗余，这一期我们就要开始讲STL中的内容。
1.vector的介绍及使用 1. vector是表示可变大小数组的序列容器。
2. 就像数组一样，vector也采用的连续存储空间来存储元素。也就是意味着可以采用下标对vector的元素进行访问，和数组一样高效。但是又不像数组，它的大小是可以动态改变的，而且它的大小会被容器自动处理。
3. 本质讲，vector使用动态分配数组来存储它的元素。当新元素插入时候，这个数组需要被重新分配大小为了增加存储空间。其做法是，分配一个新的数组，然后将全部元素移到这个数组。就时间而言，这是一个相对代价高的任务，因为每当一个新的元素加入到容器的时候，vector并不会每次都重新分配大小。
4. vector分配空间策略：vector会分配一些额外的空间以适应可能的增长，因为存储空间比实际需要的存储空间更大。不同的库采用不同的策略权衡空间的使用和重新分配。但是无论如何，重新分配都应该是对数增长的间隔大小，以至于在末尾插入一个元素的时候是在常数时间的复杂度完成的。
5. 因此，vector占用了更多的存储空间，为了获得管理存储空间的能力，并且以一种有效的方式动态增长。
6. 与其它动态序列容器相比（deque, list and forward_list）， vector在访问元素的时候更加高效，在末尾添加和删除元素相对高效。对于其它不在末尾的删除和插入操作，效率更低。比起list和forward_list统一的迭代器和引用更好。
1.2 vector的使用 vector的使用与string类相似，要实现一些基本的操作，如增，删，查，改这些操作，c＋＋在库中都已经实现好了接口，我们只需要调用这些接口就可以实现对应的操作。c＋＋如今的地位在很大程度上是因为引入了STL这块的内容。
1.2 1 vector的定义 1.2 2 vector iterator（迭代器）的使用 1.2.3 vector 空间增长问题 （1）capacity的代码在vs和g&#43;&#43;下分别运行会发现，vs下capacity是按1.5倍增长的，g&#43;&#43;是按2倍增长的。这个问题经常会考察，不要固化的认为，vector增容都是2倍，具体增长多少是根据具体的需求定义的。vs是PJ版本STL，g&#43;&#43;是SGI版本STL。 （2）reserve只负责开辟空间，如果确定知道需要用多少空间，reserve可以缓解vector增容的代价缺陷问题。
（3）resize在开空间的同时还会进行初始化，影响size。
// 测试vector的默认扩容机制 void TestVectorExpand() { size_t sz; vector&lt;int&gt; v; sz = v.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-05T18:08:22+08:00">
    <meta property="article:modified_time" content="2024-08-05T18:08:22+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c＋＋STL容器中vector的使用，模拟实现及迭代器使用注意事项和迭代器失效问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:200px;"></p> 
<p id="%E5%89%8D%E8%A8%80%EF%BC%9A-toc" style="margin-left:200px;"><a href="#%E5%89%8D%E8%A8%80%EF%BC%9A" rel="nofollow">前言：</a></p> 
<p id="1.vector%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8-toc" style="margin-left:0px;"><a href="#1.vector%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8" rel="nofollow">1.vector的介绍及使用</a></p> 
<p id="1.2%20vector%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#1.2%20vector%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">1.2 vector的使用</a></p> 
<p id="%C2%A0%201.2%201%20vector%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:80px;"><a href="#%C2%A0%201.2%201%20vector%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">  1.2 1 vector的定义</a></p> 
<p id="1.2%202%20vector%20iterator%EF%BC%88%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%89%E7%9A%84%E4%BD%BF%E7%94%A8%C2%A0-toc" style="margin-left:80px;"><a href="#1.2%202%20vector%20iterator%EF%BC%88%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%89%E7%9A%84%E4%BD%BF%E7%94%A8%C2%A0" rel="nofollow">1.2 2 vector iterator（迭代器）的使用 </a></p> 
<p id="1.2.3%20vector%20%E7%A9%BA%E9%97%B4%E5%A2%9E%E9%95%BF%E9%97%AE%E9%A2%98%C2%A0-toc" style="margin-left:80px;"><a href="#1.2.3%20vector%20%E7%A9%BA%E9%97%B4%E5%A2%9E%E9%95%BF%E9%97%AE%E9%A2%98%C2%A0" rel="nofollow">1.2.3 vector 空间增长问题 </a></p> 
<p id="1.2.4%20vector%20%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9%C2%A0-toc" style="margin-left:80px;"><a href="#1.2.4%20vector%20%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9%C2%A0" rel="nofollow">1.2.4 vector 增删查改 </a></p> 
<p id="1.2.5vector%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%E3%80%82-toc" style="margin-left:80px;"><a href="#1.2.5vector%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%E3%80%82" rel="nofollow">1.2.5vector 迭代器失效问题。</a></p> 
<p id="2.vector%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%C2%A0-toc" style="margin-left:0px;"><a href="#2.vector%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%C2%A0" rel="nofollow">2.vector模拟实现 </a></p> 
<p id="2.1%20std%3A%3Avector%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0bit%3A%3Avector-toc" style="margin-left:40px;"><a href="#2.1%20std%3A%3Avector%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0bit%3A%3Avector" rel="nofollow">2.1 std::vector的核心框架接口的模拟实现bit::vector</a></p> 
<p id="%C2%A02.2%20%E4%BD%BF%E7%94%A8memcpy%E6%8B%B7%E8%B4%9D%E9%97%AE%E9%A2%98-toc" style="margin-left:40px;"><a href="#%C2%A02.2%20%E4%BD%BF%E7%94%A8memcpy%E6%8B%B7%E8%B4%9D%E9%97%AE%E9%A2%98" rel="nofollow"> 2.2 使用memcpy拷贝问题</a></p> 
<p id="%C2%A0-toc" style="margin-left:0px;"><a href="#%C2%A0" rel="nofollow"> </a></p> 
<hr id="hr-toc"> 
<p></p> 
<h6 id="%E5%89%8D%E8%A8%80%EF%BC%9A">前言：</h6> 
<p>    在前面的章节我们已经接触过了关于STL的知识，也就是string类，我们详细介绍了string类的特性及使用，而严格来说string类并没有被归为STL中，因为string类的出现早于STL，string类的接口也比STL中的单个类多，使得string类较其他类显得冗余，这一期我们就要开始讲STL中的内容。</p> 
<h2 id="1.vector%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8">1.vector的介绍及使用</h2> 
<p>1. vector是表示可变大小数组的序列容器。<br> 2. 就像数组一样，vector也采用的连续存储空间来存储元素。也就是意味着可以采用下标对vector的元素进行访问，和数组一样高效。但是又不像数组，它的大小是可以动态改变的，而且它的大小会被容器自动处理。<br> 3. 本质讲，vector使用动态分配数组来存储它的元素。当新元素插入时候，这个数组需要被重新分配大小为了增加存储空间。其做法是，分配一个新的数组，然后将全部元素移到这个数组。就时间而言，这是一个相对代价高的任务，因为每当一个新的元素加入到容器的时候，vector并不会每次都重新分配大小。<br> 4. vector分配空间策略：vector会分配一些额外的空间以适应可能的增长，因为存储空间比实际需要的存储空间更大。不同的库采用不同的策略权衡空间的使用和重新分配。但是无论如何，重新分配都应该是对数增长的间隔大小，以至于在末尾插入一个元素的时候是在常数时间的复杂度完成的。<br> 5. 因此，vector占用了更多的存储空间，为了获得管理存储空间的能力，并且以一种有效的方式动态增长。<br> 6. 与其它动态序列容器相比（deque, list and forward_list）， vector在访问元素的时候更加高效，在末尾添加和删除元素相对高效。对于其它不在末尾的删除和插入操作，效率更低。比起list和forward_list统一的迭代器和引用更好。</p> 
<h3 id="1.2%20vector%E7%9A%84%E4%BD%BF%E7%94%A8">1.2 vector的使用</h3> 
<blockquote> 
 <p>    <strong>vector的使用与string类相似，要实现一些基本的操作，如增，删，查，改这些操作，c＋＋在库中都已经实现好了接口，我们只需要调用这些接口就可以实现对应的操作。c＋＋如今的地位在很大程度上是因为引入了STL这块的内容。</strong></p> 
</blockquote> 
<h4 id="%C2%A0%201.2%201%20vector%E7%9A%84%E5%AE%9A%E4%B9%89">  1.2 1 vector的定义</h4> 
<p><img alt="" height="302" src="https://images2.imgbox.com/9c/53/eyh6WXt1_o.png" width="1004"></p> 
<h4 id="1.2%202%20vector%20iterator%EF%BC%88%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%89%E7%9A%84%E4%BD%BF%E7%94%A8%C2%A0">1.2 2 vector iterator（迭代器）的使用 </h4> 
<p><img alt="" height="247" src="https://images2.imgbox.com/65/07/Y4NcfW9F_o.png" width="973"></p> 
<p><img alt="" height="658" src="https://images2.imgbox.com/22/61/jowFWp7y_o.png" width="1033"></p> 
<h4 id="1.2.3%20vector%20%E7%A9%BA%E9%97%B4%E5%A2%9E%E9%95%BF%E9%97%AE%E9%A2%98%C2%A0">1.2.3 vector 空间增长问题 </h4> 
<p><img alt="" height="399" src="https://images2.imgbox.com/cb/09/vMEZCgWB_o.png" width="904"></p> 
<p>（1）capacity的代码在vs和g++下分别运行会发现，<strong>vs下capacity是按1.5倍增长的，g++是按2倍增长的。</strong>这个问题经常会考察，不要固化的认为，vector增容都是2倍，具体增长多少是根据具体的需求定义的。vs是PJ版本STL，g++是SGI版本STL。 </p> 
<p>（2）reserve只负责开辟空间，如果确定知道需要用多少空间，reserve可以缓解vector增容的代价缺陷问题。</p> 
<p>（3）resize在开空间的同时还会进行初始化，影响size。</p> 
<pre><code>// 测试vector的默认扩容机制
void TestVectorExpand()
{
size_t sz;
vector&lt;int&gt; v;
sz = v.capacity();
cout &lt;&lt; "making v grow:\n";
for (int i = 0; i &lt; 100; ++i)
{
v.push_back(i);
if (sz != v.capacity())
{
sz = v.capacity();
cout &lt;&lt; "capacity changed: " &lt;&lt; sz &lt;&lt; '\n';
}
}
}
vs：运行结果：vs下使用的STL基本是按照1.5倍方式扩容
making foo grow:
capacity changed: 1
capacity changed: 2
capacity changed: 3
capacity changed: 4
capacity changed: 6
capacity changed: 9
capacity changed: 13
capacity changed: 19
capacity changed: 28
capacity changed: 42
capacity changed: 63
capacity changed: 94
capacity changed: 141
g++运行结果：linux下使用的STL基本是按照2倍方式扩容
making foo grow:
capacity changed: 1
capacity changed: 2
capacity changed: 4
capacity changed: 8
capacity changed: 16
capacity changed: 32
capacity changed: 64
capacity changed: 128</code></pre> 
<h4 id="1.2.4%20vector%20%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9%C2%A0">1.2.4 vector 增删查改 </h4> 
<p><img alt="" height="455" src="https://images2.imgbox.com/cd/6d/AWBNREkj_o.png" width="989"></p> 
<p>    如果我们实现增删查改，只需要调用相应的接口就可以了 ，其中标重点的是我们在日常的开发使用vector中常用的接口，需要我们重点掌握。</p> 
<h4 id="1.2.5vector%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%E3%80%82">1.2.5vector 迭代器失效问题。</h4> 
<blockquote> 
 <p><strong>迭代器的主要作用就是让算法能够不用关心底层数据结构，其底层实际就是一个指针，或者是对指针进行了封装，</strong>比如：<strong>vector的迭代器就是原生态指针T* 。因此迭代器失效，实际就是迭代器底层对应指针所指向的空间被销毁了</strong>，而使用一块已经被释放的空间<strong>，造成的后果是程序崩溃(即如果继续使用已经失效的迭代器，程序可能会崩溃)</strong>。</p> 
 <p></p> 
</blockquote> 
<p><strong>  对于vector可能会导致其迭代器失效的操作有</strong>：</p> 
<p>1. <strong>会引起其底层空间改变的操作，都有可能是迭代器失效</strong>，比如一些常用的接口：resize、reserve、insert、assign、push_back等等。</p> 
<pre><code>#include &lt;iostream&gt;
using namespace std;
#include &lt;vector&gt;
int main()
{
vector&lt;int&gt; v{1,2,3,4,5,6};
auto it = v.begin();
// 将有效元素个数增加到100个，多出的位置使用8填充，操作期间底层会扩容
// v.resize(100, 8);
// reserve的作用就是改变扩容大小但不改变有效元素个数，操作期间可能会引起底层容量改变
// v.reserve(100);
// 插入元素期间，可能会引起扩容，而导致原空间被释放
// v.insert(v.begin(), 0);
// v.push_back(8);
// 给vector重新赋值，可能会引起底层容量改变
v.assign(100, 8);
/*
出错原因：以上操作，都有可能会导致vector扩容，也就是说vector底层原理旧空间被释放掉，
而在打印时，it还使用的是释放之间的旧空间，在对it迭代器操作时，实际操作的是一块已经被释放的
空间，而引起代码运行时崩溃。
解决方式：在以上操作完成之后，如果想要继续通过迭代器操作vector中的元素，只需给it重新
赋值即可。
*/
while(it != v.end())
{
cout&lt;&lt; *it &lt;&lt; " " ;
++it;
}
cout&lt;&lt;endl;
return 0;
}</code></pre> 
<p>2.<strong> 指定位置元素的删除操作--erase</strong> </p> 
<pre><code>#include &lt;iostream&gt;
using namespace std;
#include &lt;vector&gt;
int main()
{
int a[] = { 1, 2, 3, 4 };
vector&lt;int&gt; v(a, a + sizeof(a) / sizeof(int));
// 使用find查找3所在位置的iterator
vector&lt;int&gt;::iterator pos = find(v.begin(), v.end(), 3);
// 删除pos位置的数据，导致pos迭代器失效。
v.erase(pos);
cout &lt;&lt; *pos &lt;&lt; endl; // 此处会导致非法访问
return 0;
}</code></pre> 
<blockquote> 
 <p>erase删除pos位置元素后，pos位置之后的元素会往前搬移，没有导致底层空间的改变，理论上讲迭代器不应该会失效，但是：如果pos刚好是最后一个元素，删完之后pos刚好是end的位置，而end位置是没有元素的，那么pos就失效了。因此删除vector中任意位置上元素时，vs就认为该位置迭代器失效了。  </p> 
</blockquote> 
<p>我们来看一个删除vector所有偶数的例子：</p> 
<pre><code>#include &lt;iostream&gt;
using namespace std;
#include &lt;vector&gt;
int main()
{
	vector&lt;int&gt; v{ 1, 2, 3, 4 };
	auto it = v.begin();
	while (it != v.end())
	{
		if (*it % 2 == 0)
			v.erase(it);
		++it;
	}
	return 0;
}</code></pre> 
<p>我们来运行一下这段代码：</p> 
<p><img alt="" height="723" src="https://images2.imgbox.com/3e/1d/XFxUEUNs_o.png" width="1200"></p> 
<p></p> 
<p>可以看到程序直接崩溃了，这就是经典的迭代器失效的例子，这是为什么呢？我们画图来看：</p> 
<p><img alt="" height="451" src="https://images2.imgbox.com/00/85/hiZxXcuN_o.png" width="827"></p> 
<p>    这是我们的vector刚开始的样子，  第一次进入循环先判断it指向的数1对2取模是否为0，结果不为零，所以it往后走来到了2的位置：</p> 
<p><img alt="" height="407" src="https://images2.imgbox.com/35/2d/WdsHgDu4_o.png" width="813"></p> 
<p>   在程序发现2模2为0后2就被删除了，3和4都往前移动一个位置，紧接着it也往前移动了一个位置：</p> 
<p><img alt="" height="473" src="https://images2.imgbox.com/15/28/PjLQIaTX_o.png" width="728"></p> 
<p> </p> 
<p>此时end还不等于end，程序判断4模2为0后，又将4删除了，然后end往前一个位置，it又往后走一个位置：</p> 
<p><img alt="" height="480" src="https://images2.imgbox.com/75/a3/rp9wj14r_o.png" width="742"></p> 
<blockquote> 
 <p>可以看到，此时it指向了end后面的位置，而我们循环结束的条件是it等于end就结束，而it在end后面，他就会一直往后走，循环也无法停下来，<strong>不仅造成非法访问，也会使程序死循环，这也就是程序奔溃的原因</strong>。这个例子也再次告诉我们，<strong>如果我们使用erase删除了数据，那么就不要再使用pos了</strong>。 </p> 
</blockquote> 
<p>3. 与vector类似，string在插入+扩容操作+erase之后，迭代器也会失效：</p> 
<pre><code>#include &lt;string&gt;
void TestString()
迭代器失效解决办法：在使用前，对迭代器重新赋值即可。
1.2.5 vector 在OJ中的使用。
1. 只出现一次的数字i
2. 杨辉三角OJ
{
string s("hello");
auto it = s.begin();
// 放开之后代码会崩溃，因为resize到20会string会进行扩容
// 扩容之后，it指向之前旧空间已经被释放了，该迭代器就失效了
// 后序打印时，再访问it指向的空间程序就会崩溃
//s.resize(20, '!');
while (it != s.end())
{
cout &lt;&lt; *it;
++it;
}
cout &lt;&lt; endl;
it = s.begin();
while (it != s.end())
{
it = s.erase(it);
// 按照下面方式写，运行时程序会崩溃，因为erase(it)之后
// it位置的迭代器就失效了
// s.erase(it);
++it;
}
}</code></pre> 
<h2 id="2.vector%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%C2%A0">2.vector模拟实现 </h2> 
<p> 由于使用命名空间时，将函数的定义和声明分到不同的文件中会引起连结错误，所以我们分两个文件来实现vector，一个用来实现功能，一个用来测试。</p> 
<h3 id="2.1%20std%3A%3Avector%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0bit%3A%3Avector">2.1 std::vector的核心框架接口的模拟实现bit::vector</h3> 
<p>vector.h :</p> 
<pre><code>#pragma once
#include&lt;assert.h&gt;
#include&lt;iostream&gt;
using namespace std;

namespace Myvector
{
	template&lt;class T&gt;
	class vector
	{
	public:
		typedef T* iterator;
		vector()
		{}
		vector(vector&lt;T&gt;&amp; v)
		{
			reserve(v.size());
			for (auto&amp; ch : v)
			{
				push_back(ch);
			}
		}


		~vector()
		{
			delete[] _start;
			_start = _finish = _end_of_storage = nullptr;
		}
		void swap(vector&lt;T&gt;&amp; v1)
		{
			std::swap(_start, v1._start);
			std::swap(_finish, v1._finish);
			std::swap(_end_of_storage, v1._end_of_storage);
		}

		vector&lt;T&gt;&amp; operator=(vector&lt;T&gt; v)
		{
			swap(v);
			return *this;
		}

		size_t size()
		{
			return _finish - _start;
		}

		size_t capacity()
		{
			return _end_of_storage - _start;
		}
		void reserve(size_t n)
		{
			if (n &gt; capacity())
			{
				size_t old_size = size();
				T* tmp = new T[n];
				memcpy(tmp, _start, size() * sizeof(T));
				delete _start;
				_start = tmp;
				_finish = _start + old_size;
				_end_of_storage = _start + n;
			}
		}

		void push_back(const T&amp; x)
		{
			if (_finish == _end_of_storage)
			{
				reserve(capacity() == 0 ? 4 : capacity() * 2);
			}
			*_finish = x;
			_finish++;
		}

		T&amp; operator[](const T&amp; x)
		{
			return _start[x];
		}

		iterator begin()
		{
			return _start;
		}

		iterator end()
		{
			return _finish;
		}

		void pop_back()
		{
			--_finish;
		}
		void resize(size_t n, T val = T())
		{
			if (n &lt; size())
			{
				_finish = _start + n;
			}
			else
			{
				reserve(n);
				while (_finish &lt; _start + n)
				{
					*_finish = val;
					_finish++;
				}
			}
		}

		void erase(iterator pos)
		{
			assert(pos &gt;= _start);
			assert(pos &lt;= _finish);

			iterator it = pos + 1;

			while (it != end())
			{
				*(it - 1) = *it;
				++it;
			}
			--_finish;

		}

		void insert(iterator pos, const T&amp; x)
		{
			assert(pos &gt;= _start);
			assert(pos &lt;= _finish);
			if (_finish == _end_of_storage)
			{
				size_t len = pos - _start;
				reserve(capacity() == 0 ? 4 : capacity() * 2);
				pos = _start + len;
			}

			iterator end = _finish - 1;
			while (end &gt;= pos)
			{
				*(end + 1) = *end;
				end--;

			}
			*pos = x;
			++_finish;
		}

	private:
		iterator _start = nullptr;
		iterator _finish = nullptr;
		iterator _end_of_storage = nullptr;
	};
}
</code></pre> 
<p>test.cpp :</p> 
<pre><code>#include"vector.h"
namespace Myvector
{
	void test()
	{
		vector&lt;int&gt; v;
		v.push_back(1);
		v.push_back(2);
		v.push_back(3);
		v.push_back(4);

		v.insert(v.begin() + 2, 40);

		for (size_t i = 0; i &lt; v.size(); i++)
		{
			cout &lt;&lt; v[i] &lt;&lt; " ";

		}
		cout &lt;&lt; endl;

		vector&lt;int&gt;::iterator it = v.begin();

		while (it != v.end())
		{

			cout &lt;&lt; *it &lt;&lt; " ";
			++it;
		}
		cout &lt;&lt; endl;

		for (auto ch : v)
		{
			cout &lt;&lt; ch &lt;&lt; " ";
		}
		cout &lt;&lt; endl;
		v.erase(v.begin() + 2);
		v.resize(10, 1);
		for (auto ch : v)
		{
			cout &lt;&lt; ch &lt;&lt; " ";
		}
		cout &lt;&lt; endl;
	}

	void test02()
	{
		vector&lt;int&gt; v;
		v.push_back(1);
		v.push_back(2);
		v.push_back(3);
		v.push_back(4);
		v.push_back(5);
		for (auto ch : v)
		{
			cout &lt;&lt; ch &lt;&lt; " ";
		}
		cout &lt;&lt; endl;
		vector&lt;int&gt; v1;
		v1 = v;
		for (auto ch : v1)
		{
			cout &lt;&lt; ch &lt;&lt; " ";
		}
		cout &lt;&lt; endl;


	}
}


int main()
{
	//Myvector::test();
	Myvector::test02();
	return 0;
}
</code></pre> 
<h3 id="%C2%A02.2%20%E4%BD%BF%E7%94%A8memcpy%E6%8B%B7%E8%B4%9D%E9%97%AE%E9%A2%98"> 2.2 使用memcpy拷贝问题</h3> 
<p>假设模拟实现的vector中的reserve接口中，使用memcpy进行的拷贝，以下代码会发生什么问题？</p> 
<pre><code>int main()
{
bite::vector&lt;bite::string&gt; v;
v.push_back("1111");
v.push_back("2222");
v.push_back("3333");
return 0;
}</code></pre> 
<p><strong> 问题分析</strong>：</p> 
<p>1. memcpy是内存的二进制格式拷贝，将一段内存空间中内容原封不动的拷贝到另外一段内存空间中<br> 2. 如果拷贝的是自定义类型的元素，memcpy既高效又不会出错，但如果拷贝的是自定义类型元素，并且自定义类型元素中涉及到资源管理时，就会出错，<strong>因为memcpy的拷贝实际是浅拷贝</strong>。</p> 
<p><img alt="" height="324" src="https://images2.imgbox.com/db/3c/CJ8F6acq_o.png" width="699"></p> 
<p><img alt="" height="528" src="https://images2.imgbox.com/3a/d4/Zlx51HK2_o.png" width="768"></p> 
<p><img alt="" height="542" src="https://images2.imgbox.com/84/c9/ADXq5AKq_o.png" width="862"></p> 
<p><img alt="" height="574" src="https://images2.imgbox.com/5e/62/0P8GVyu9_o.png" width="887"></p> 
<blockquote> 
 <p><strong>结论：如果对象中涉及到资源管理时，千万不能使用memcpy进行对象之间的拷贝，因为memcpy是浅拷贝，否则可能会引起内存泄漏甚至程序崩溃</strong>。 </p> 
</blockquote> 
<p>本章完。 </p> 
<p></p> 
<h2 id="%C2%A0"></h2> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cde4525b1d9cd6237c8c6563df4bdddb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Flink 实时数仓（七）【DWS 层搭建（一）流量域汇总表创建】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e691c52c75f123bbb34cd6e150209646/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">有哪些ai写作在线生成器？这篇文章让你了解几种软件的大概情况</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>