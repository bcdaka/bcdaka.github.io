<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>探索C嘎嘎的奇妙世界:第三关---缺省参数与函数重载 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/d4d9ff5e59877160c0b6742308bc794e/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="探索C嘎嘎的奇妙世界:第三关---缺省参数与函数重载">
  <meta property="og:description" content="在c语言中,我们常常在对有参函数进行传参,这样的繁琐过程,C&#43;&#43;祖师爷对此进行了相关改进,多说无益,上干货:
1 缺省参数: 缺省参数是指在声明或定义函数时为函数的形参指定一个默认值（默认参数）。在调用该函数时，如果没有指定实参，则采用该形参的缺省值；否则使用指定的实参。缺省参数主要分为两种类型:全缺省参数和半缺省参数
1.1 全缺省参数: 全缺省参数是指函数的所有参数都具有默认值。以下是一个全缺省参数的示例代码：
// 全缺省 void F2(int a = 10, int b = 20, int c = 30) { cout &lt;&lt; &#34;a = &#34; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &#34;b = &#34; &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; &#34;c = &#34; &lt;&lt; c &lt;&lt; endl &lt;&lt; endl; } int main() { F2(1, 2, 3); F2(1, 2); F2(1); F2(); return 0; } 在上述代码中,我们会发现,有所不同的是在形参的位置上,我们给予了赋值,这样写又什么作用呢?唉~这样写当我们在调用的时候,少给参数的时候,编译器也不会报错,会自动给上默认值.同时也可以多种方式调用函数了.比如在上述代码中:F2(1,2,3)这样的调用时,上面形参的默认值就不会起作用了,而当我们F2(1,2)这样传参的时候,也不会报错,这是编译器会把a和b的值变为,1和2,而c的值就使用我们给的默认参数进行赋值30.同理可以去理解后两个调用,也可以一个都不传哦,这样形参用的全是我们所给的默认值.
1.2 半缺省参数: 半缺省参数是指从右往左连续地为函数的部分参数提供默认值。以下是一个半缺省参数的示例代码：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-12T17:44:18+08:00">
    <meta property="article:modified_time" content="2024-06-12T17:44:18+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">探索C嘎嘎的奇妙世界:第三关---缺省参数与函数重载</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>        在c语言中,我们常常在对有参函数进行传参,这样的繁琐过程,C++祖师爷对此进行了相关改进,多说无益,上干货:</p> 
<h2>1 缺省参数:</h2> 
<p>        <strong><span style="color:#fe2c24;">缺省参数</span></strong>是指<strong><span style="color:#ff9900;">在声明或定义函数时为函数的形参指定一个默认值（默认参数）。在调用该函数时，如果没有指定实参，则采用该形参的缺省值；否则使用指定的实参。</span></strong><span style="color:#0d0016;">缺省参数主要分为两种类型:<strong>全缺省参数</strong>和<strong>半缺省参数</strong></span></p> 
<h3 style="background-color:transparent;"><span style="color:#0d0016;">1.1 全缺省参数:</span><span style="color:#0d0016;">       </span></h3> 
<p>        全缺省参数是指函数的所有参数都具有默认值。以下是一个全缺省参数的示例代码：</p> 
<pre><code class="language-cpp">// 全缺省
void F2(int a = 10, int b = 20, int c = 30)
{
	cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; endl;
	cout &lt;&lt; "c = " &lt;&lt; c &lt;&lt; endl &lt;&lt; endl;
}

int main()
{
	F2(1, 2, 3);
	F2(1, 2);
	F2(1);
	F2();
    return 0;
}</code></pre> 
<p>        在上述代码中,我们会发现,有所不同的是在形参的位置上,我们给予了赋值,这样写又什么作用呢?唉~这样写当我们在调用的时候,少给参数的时候,编译器也不会报错,会自动给上默认值.同时也可以多种方式调用函数了.比如在上述代码中:F2(1,2,3)这样的调用时,上面形参的默认值就不会起作用了,而当我们F2(1,2)这样传参的时候,也不会报错,这是编译器会把a和b的值变为,1和2,而c的值就使用我们给的默认参数进行赋值30.同理可以去理解后两个调用,也可以一个都不传哦,这样形参用的全是我们所给的默认值.</p> 
<h3 style="background-color:transparent;">1.2 半缺省参数:</h3> 
<p>        半缺省参数是指从右往左连续地为函数的部分参数提供默认值。以下是一个半缺省参数的示例代码：</p> 
<pre><code class="language-cpp">// 半缺省，从右往左缺省
void F3(int a, int b = 20 , int c = 30)
{
	cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; endl;
	cout &lt;&lt; "c = " &lt;&lt; c &lt;&lt; endl &lt;&lt; endl;
}

int main()
{
    F3(1);
	F3(1, 2);
	F3(1, 2, 3);
}</code></pre> 
<p>        在上述代码中,我们只是缺省了b和c,同样可以进行赋值,但是这时我们就不能一个参数也不传了,因为这时我们如果一个都不传的话,这时a是没有默认值的,编译器就会报错,半缺省参数必须从右往左依次提供默认值，不能间隔着给。为什么呢?请看下面的代码:</p> 
<pre><code class="language-cpp">void F3(int a=10, int b = 20 , int c)
{
	cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; endl;
	cout &lt;&lt; "c = " &lt;&lt; c &lt;&lt; endl &lt;&lt; endl;
}

int main()
{
    F3(1,2);
    return 0;
}</code></pre> 
<p>        这时我们这样给默认值的时候,用F3(1,2)进行传参时,2可以赋值给c,但是这个1会赋值给谁呢?是a还是b呢?这是编译器就会存在歧义,就会报错喽,所以,我们平时在写半缺省参数的时候,应该极为注意.细心使用~</p> 
<h3 style="background-color:transparent;">1.3 缺省参数的注意事项:</h3> 
<p><span style="color:#fe2c24;">注意:</span></p> 
<p><span style="color:#fe2c24;">使用缺省参数可以提高代码的灵活性和可读性，减少函数调用时的参数传递数量。但需要注意以下几点：</span></p> 
<div> 
 <span style="color:#777777;">1. </span> 
 <span style="color:#777777;">半缺省参数必须</span> 
 <span style="color:#777777;"><strong>从右往左依次</strong></span> 
 <span style="color:#777777;">来给出，不能间隔着给 </span> 
</div> 
<div> 
 <span style="color:#777777;">2. </span> 
 <span style="color:#777777;">缺省参数不能在函数声明和定义中同时出现,如果要给,只能在声明的时候给缺省值</span> 
</div> 
<div> 
 <div> 
  <span style="color:#777777;">3. </span> 
  <span style="color:#777777;">缺省值必须是常量或者全局变量 </span> 
 </div> 
 <div> 
  <span style="color:#777777;">4. C</span> 
  <span style="color:#777777;">语言不支持（编译器不支持）</span> 
 </div> 
 <div> 
  <span style="color:#777777;">5.</span> 
  <span style="color:#aa5500;">如果声明与定义位置同时出现，恰巧两个位置提供的值不同，那编译器就无法确定到底该</span> 
  <div> 
   <span style="color:#aa5500;">用那个缺省值。</span> 
  </div> 
  <div>
    6.缺省参数在后续的使用中尤为重要,尤其是数据结构中. 
  </div> 
  <div></div> 
  <h2 style="background-color:transparent;"><span style="color:#0d0016;">2 函数重载:</span></h2> 
  <p><span style="color:#0d0016;">        在C语言中,不支持重名函数存在,这就让一些程序很麻烦,比如要写一个整形数据的交换和浮点数的交换就不行,那么C++祖师爷就改进了这一点---</span><span style="color:#fe2c24;"><strong>函数重载</strong></span></p> 
  <p><span style="color:#0d0016;">        </span><strong><span style="color:#ff9900;">在同一作用域内，可以有多个具有相同函数名但参数列表不同（参数的类型、个数或顺序不同）的函数</span></strong><span style="color:#0d0016;">。这些函数就被称为</span><strong><span style="color:#fe2c24;">重载函数</span></strong><span style="color:#0d0016;">。</span></p> 
  <p><span style="color:#0d0016;">        那么具体什么是重载函数呢?请看代码:</span></p> 
  <pre><code class="language-cpp">namespace bit1
{
	void Swap(int* pa, int* pb)
	{
		cout &lt;&lt; "void Swap(int* pa, int* pb)" &lt;&lt; endl;
	}
}

namespace bit2
{
	void Swap(int* px, int* py)
	{
		cout &lt;&lt; "void Swap(int* pa, int* pb)" &lt;&lt; endl;
	}
}</code></pre> 
  <p>        这样的两个函数构不构成重载呢?</p> 
  <p>        显然它们在不同的命名空间中,不符合重载函数中的<strong><span style="color:#ff9900;">属于同一作用域</span></strong>这一条件,所以上述两个函数不构成函数重载.让我们来看一下另一个示例:</p> 
  <p>        </p> 
  <pre><code class="language-cpp">namespace bit1
{
	void Swap(int* pa, int* pb)
	{
		cout &lt;&lt; "void Swap(int* pa, int* pb)" &lt;&lt; endl;
	}
}

namespace bit2
{
	void Swap(int* px, int* py)
	{
		cout &lt;&lt; "void Swap(int* pa, int* pb)" &lt;&lt; endl;
	}
}

using namespace bit1;
using namespace bit2;</code></pre> 
  <p>        如果把它们两个的命名空间展开,是否构成函数重载呢?</p> 
  <p>        显然也是不构成重载的,因为"using namespace"只是把他们展开供全局可以使用这两个命名空间中的成员,并不意味着它们合并同一个作用域,所以还是不符合重载函数中的<strong><span style="color:#ff9900;">属于同一作用域</span></strong>这一条件,不构成函数重载,那么怎么才能构成呢?请看正确示例:</p> 
  <h3 style="background-color:transparent;">2.1 类型一:参数类型不同:</h3> 
  <pre><code class="language-cpp">void Swap(int* pa, int* pb)
{
	cout &lt;&lt; "void Swap(int* pa, int* pb)" &lt;&lt; endl;
}

void Swap(double* pa, double* pb)
{
	cout &lt;&lt; "void Swap(double* pa, double* pb)" &lt;&lt; endl;
}</code></pre> 
  <p>        上述代码就满足了重载函数的条件:<span style="color:#aa5500;">参数类型不同.</span><span style="color:#0d0016;">可以看到上述代码中,形参的类型不同,一个是int,一个是double,当然还可以写其他类型等等等...这样就可以使函数的功能变得更加丰富!</span></p> 
  <h3 style="background-color:transparent;">2.2 类型二:参数个数不同:</h3> 
  <pre><code class="language-cpp">void f()
{
	cout &lt;&lt; "f()" &lt;&lt; endl;
}

void f(int a)
{
	cout &lt;&lt; "f(int a)" &lt;&lt; endl;
}</code></pre> 
  <p>        在上述代码中:显而易见这两个函数的参数个数不同,第一个函数无参,第二个函数有一个整形参数a,可以构成重载函数.</p> 
  <h3 style="background-color:transparent;">2.3 类型三:参数顺序不同:</h3> 
  <pre><code class="language-cpp">void f(int a, char b)
{
     cout &lt;&lt; "f(int a,char b)" &lt;&lt; endl;
}

void f(char b, int a)
{
     cout &lt;&lt; "f(char b, int a)" &lt;&lt; endl;
}</code></pre> 
  <p>        大眼一看,好像是一样的,仔细的小伙伴就会发现,上述两个函数的参数的顺序好像不一样,第一个函数是(int a,char b),第二个函数参数是(char b,int a)这样也是可以构成函数重载的哦~</p> 
  <h3 style="background-color:transparent;">2.4 函数重载的注意事项:</h3> 
  <p>1. 参数类型必须不同：重载的函数之间参数的类型要有明显区别，不能仅通过可隐式转换的类型差异来重载。<br> 2. 参数个数不同：这是常见的重载方式之一。<br> 3. 参数顺序不同：也可以作为重载的依据，但要注意使用时的清晰性。<br> 4. 不能仅靠返回值不同来重载：因为调用时通常不关心返回值来确定调用哪个重载函数。<br> 5. 作用域要明确：确保重载的函数都在同一个合理的作用域内，避免混淆。<br> 6. 避免过度重载：过多的重载可能导致代码复杂难以理解和维护。<br> 7. 注意歧义：确保参数的组合不会导致调用时产生歧义，编译器能明确地选择正确的重载函数。<br> 8. 考虑可读性：重载函数的命名和功能设计要符合逻辑，便于其他开发者理解和使用。</p> 
  <h2 style="background-color:transparent;">3 C++支持函数重载的原理---名字修饰原则:(选看)</h2> 
  <div> 
   <span style="color:#777777;"><strong>为什么C++</strong></span> 
   <span style="color:#777777;"><strong>支持函数重载，而</strong></span> 
   <span style="color:#777777;"><strong>C</strong></span> 
   <span style="color:#777777;"><strong>语言不支持函数重载呢？</strong></span> 
  </div> 
  <div></div> 
  <div> 
   <span style="color:#777777;"><strong>这是因为</strong>在</span> 
   <span style="color:#777777;">C/C++</span> 
   <span style="color:#777777;">中，一个程序要运行起来，需要经历以下几个阶段：</span> 
   <span style="color:#777777;"><strong>预处理、编译、汇编、链接</strong></span> 
  </div> 
  <div> 
   <img alt="" height="441" src="https://images2.imgbox.com/a5/87/jtPzDHoo_o.png" width="696"> 
  </div> 
  <div> 
   <img alt="" height="486" src="https://images2.imgbox.com/b5/bc/kKSFJIEz_o.png" width="874"> 
  </div> 
  <div> 
   <div> 
    <span style="color:#777777;">1. </span> 
    <span style="color:#777777;">实际项目通常是由多个头文件和多个源文件构成，而通过</span> 
    <span style="color:#777777;">C</span> 
    <span style="color:#777777;">语言阶段学习的编译链接，我们 </span> 
   </div> 
   <div> 
    <span style="color:#777777;">可以知道，【当前</span> 
    <span style="color:#777777;">a.cpp</span> 
    <span style="color:#777777;">中调用了</span> 
    <span style="color:#777777;">b.cpp</span> 
    <span style="color:#777777;">中定义的</span> 
    <span style="color:#777777;">Add</span> 
    <span style="color:#777777;">函数时】，编译后链接前，</span> 
    <span style="color:#777777;">a.o</span> 
    <span style="color:#777777;">的目标 </span> 
   </div> 
   <div> 
    <span style="color:#777777;">文件中没有</span> 
    <span style="color:#777777;">Add</span> 
    <span style="color:#777777;">的函数地址，因为</span> 
    <span style="color:#777777;">Add</span> 
    <span style="color:#777777;">是在</span> 
    <span style="color:#777777;">b.cpp</span> 
    <span style="color:#777777;">中定义的，所以</span> 
    <span style="color:#777777;">Add</span> 
    <span style="color:#777777;">的地址在</span> 
    <span style="color:#777777;">b.o</span> 
    <span style="color:#777777;">中。那么 </span> 
   </div> 
   <div> 
    <span style="color:#777777;">怎么办呢？ </span> 
   </div> 
   <div> 
    <span style="color:#777777;">2. </span> 
    <span style="color:#777777;">所以链接阶段就是专门处理这种问题，</span> 
    <span style="color:#777777;"><strong>链接器看到</strong></span> 
    <span style="color:#777777;"><strong>a.o</strong></span> 
    <span style="color:#777777;"><strong>调用</strong></span> 
    <span style="color:#777777;"><strong>Add</strong></span> 
    <span style="color:#777777;"><strong>，但是没有</strong></span> 
    <span style="color:#777777;"><strong>Add</strong></span> 
    <span style="color:#777777;"><strong>的地址，就 </strong></span> 
   </div> 
   <div> 
    <span style="color:#777777;"><strong>会到</strong></span> 
    <span style="color:#777777;"><strong>b.o</strong></span> 
    <span style="color:#777777;"><strong>的符号表中找</strong></span> 
    <span style="color:#777777;"><strong>Add</strong></span> 
    <span style="color:#777777;"><strong>的地址，然后链接到一起</strong></span> 
    <span style="color:#777777;">。</span> 
    <span style="color:#777777;">(</span> 
    <span style="color:#777777;">老师要带同学们回顾一下</span> 
    <span style="color:#777777;">) </span> 
   </div> 
   <div> 
    <span style="color:#777777;">3. </span> 
    <span style="color:#777777;">那么链接时，面对</span> 
    <span style="color:#777777;">Add</span> 
    <span style="color:#777777;">函数，链接接器会使用哪个名字去找呢？这里每个编译器都有自己的 </span> 
   </div> 
   <div> 
    <span style="color:#777777;">函数名修饰规则。 </span> 
   </div> 
   <div> 
    <span style="color:#777777;">4. </span> 
    <span style="color:#777777;">由于</span> 
    <span style="color:#777777;">Windows</span> 
    <span style="color:#777777;">下</span> 
    <span style="color:#777777;">vs</span> 
    <span style="color:#777777;">的修饰规则过于复杂，而</span> 
    <span style="color:#777777;">Linux</span> 
    <span style="color:#777777;">下</span> 
    <span style="color:#777777;">g++</span> 
    <span style="color:#777777;">的修饰规则简单易懂，下面我们使 </span> 
   </div> 
   <div> 
    <span style="color:#777777;">用了</span> 
    <span style="color:#777777;">g++</span> 
    <span style="color:#777777;">演示了这个修饰后的名字。 </span> 
   </div> 
   <div> 
    <span style="color:#777777;">5. </span> 
    <span style="color:#777777;"><strong>通过下面我们可以看出</strong></span> 
    <span style="color:#777777;"><strong>gcc</strong></span> 
    <span style="color:#777777;"><strong>的函数修饰后名字不变。而</strong></span> 
    <span style="color:#777777;"><strong>g++</strong></span> 
    <span style="color:#777777;"><strong>的函数修饰后变成【</strong></span> 
    <span style="color:#777777;"><strong>_Z+</strong></span> 
    <span style="color:#777777;"><strong>函数长度 </strong></span> 
   </div> 
   <div> 
    <span style="color:#777777;"><strong>+</strong></span> 
    <span style="color:#777777;"><strong>函数名</strong></span> 
    <span style="color:#777777;"><strong>+</strong></span> 
    <span style="color:#777777;"><strong>类型首字母】。</strong></span> 
   </div> 
  </div> 
  <div></div> 
  <div> 
   <img alt="" height="435" src="https://images2.imgbox.com/3f/2c/1aipXww0_o.png" width="864"> 
  </div> 
  <div> 
   <div> 
    <span style="color:#777777;">结论：</span> 
    <span style="color:#777777;"><strong>在</strong></span> 
    <span style="color:#777777;"><strong>linux</strong></span> 
    <span style="color:#777777;"><strong>下，采用</strong></span> 
    <span style="color:#777777;"><strong>gcc</strong></span> 
    <span style="color:#777777;"><strong>编译完成后，函数名字的修饰没有发生改变。</strong></span> 
    <span style="color:#777777;"><strong>采用</strong></span> 
    <span style="color:#777777;"><strong>C++</strong></span> 
    <span style="color:#777777;"><strong>编译器编译后结果.</strong></span> 
   </div> 
   <div> 
    <img alt="" height="426" src="https://images2.imgbox.com/4c/2e/fXxGsItn_o.png" width="894"> 
   </div> 
   <div> 
    <div> 
     <span style="color:#777777;">结论：</span> 
     <span style="color:#777777;"><strong>在</strong></span> 
     <span style="color:#777777;"><strong>linux</strong></span> 
     <span style="color:#777777;"><strong>下，采用</strong></span> 
     <span style="color:#777777;"><strong>g++</strong></span> 
     <span style="color:#777777;"><strong>编译完成后，函数名字的修饰发生改变，编译器将函数参</strong></span> 
     <span style="color:#777777;"><strong>数类型信息添加到修改后的名字中。</strong></span> 
    </div> 
    <div></div> 
    <div> 
     <span style="color:#777777;"><strong>Windows</strong></span> 
     <span style="color:#777777;"><strong>下名字修饰规则:</strong></span> 
    </div> 
    <div> 
     <img alt="" height="492" src="https://images2.imgbox.com/4c/31/utEqXJHK_o.png" width="864"> 
    </div> 
    <div> 
     <div> 
      <span style="color:#777777;">对比</span> 
      <span style="color:#777777;">Linux</span> 
      <span style="color:#777777;">会发现，</span> 
      <span style="color:#777777;"><strong>windows</strong></span> 
      <span style="color:#777777;"><strong>下</strong></span> 
      <span style="color:#777777;"><strong>vs</strong></span> 
      <span style="color:#777777;"><strong>编译器对函数名字修饰规则相对复杂难懂</strong></span> 
      <span style="color:#777777;">，但道理都 </span> 
     </div> 
     <div> 
      <span style="color:#777777;">是类似的，我们就不做细致的研究了。</span> 
     </div> 
     <div> 
      <div> 
       <span style="color:#777777;">6. </span> 
       <span style="color:#777777;"><strong>通过这里就理解了</strong></span> 
       <span style="color:#777777;"><strong>C</strong></span> 
       <span style="color:#777777;"><strong>语言没办法支持重载，因为同名函数没办法区分。而</strong></span> 
       <span style="color:#777777;"><strong>C++</strong></span> 
       <span style="color:#777777;"><strong>是通过函数修 </strong></span> 
      </div> 
      <div> 
       <span style="color:#777777;"><strong>饰规则来区分，只要参数不同，修饰出来的名字就不一样，就支持了重载</strong></span> 
       <span style="color:#777777;">。 </span> 
      </div> 
      <div> 
       <span style="color:#777777;">7. </span> 
       <span style="color:#777777;">如果两个函数函数名和参数是一样的，返回值不同是不构成重载的，因为调用时编译器没办 </span> 
      </div> 
      <div> 
       <span style="color:#777777;">法区分。</span> 
      </div> 
      <div></div> 
      <div> 
       <span style="color:#0d0016;">     <strong>   到此有关缺省参数和函数重载的只是就讲解到这啦~希望这篇博客能给您带来一些启发和思考!那我们下次再一起探险喽,欢迎在评论区进行讨论~~~</strong></span> 
      </div> 
     </div> 
    </div> 
   </div> 
  </div> 
 </div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2c868f54e0ac37166106b48ef38c1a9f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【MySQL】数据库介绍|数据库分类|MySQL的基本结构|MySQL初步认识|SQL分类</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/98579a1ffd0a145765ee92e7b289211a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">undetected_chromedriver驱动浏览器结束报错OSError: [WinError 6] 句柄无效</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>