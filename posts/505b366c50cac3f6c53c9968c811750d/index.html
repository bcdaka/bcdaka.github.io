<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java---包装类与泛型 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/505b366c50cac3f6c53c9968c811750d/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java---包装类与泛型">
  <meta property="og:description" content="1.包装类 1.1 包装类 在Java中，由于基本数据类型不是继承Object类，为了在泛型代码中可以支持基本数据类型，Java给每个基本数据类型各自提供了·一个包装类。
如下图
除了char和int基本数据类型的包装类型有点特别，其他的都是首字母大写 1.2 装箱与拆箱 1. 装箱 装箱就是将基本数据类型的数据转化成包装类，装箱分为自动装箱和显示拆箱。
public static void main(String[] args) { int a=10; Integer b=Integer.valueOf(a);//显示拆箱 Integer c=a;//自动拆箱 } 其实自动拆箱和显示拆箱的底层原理是一样的，都是调用了Integer.valueOf()方法。
2. 拆箱 拆箱就是将包装类的数据类型转换转换成基本数据类型，拆箱也分为自动拆箱和显示拆箱。
public static void main1(String[] args) { Integer a=10; int b=a.intValue();//显示拆箱 int c=a;//自动拆箱 } 2.面试题 了解装箱与拆箱，我们来看一道面试题
public static void main(String[] args) { Integer a=100; Integer b=100; System.out.println(a == b);//打印true Integer c=200; Integer d=200; System.out.println(c == d);//打印false } 为什么会打印不同的结果呢？
我们来看Integer.ValueOf()方法的原码
我们发现，在进行装包操作的时候，会根据装包的数据的大小来返回不同类型的数据。
当要装包的数据的范围在 [-127~128] 之间时，valueOf 方法就会返回数组中的一个数据（整数）。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-08T19:33:55+08:00">
    <meta property="article:modified_time" content="2024-07-08T19:33:55+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java---包装类与泛型</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p class="img-center"><img alt="" height="675" src="https://images2.imgbox.com/35/82/oIfEoFQj_o.jpg" width="1200"></p> 
<h2>1.包装类</h2> 
<h3>1.1 包装类</h3> 
<p>在Java中，由于基本数据类型不是继承Object类，为了在泛型代码中可以支持基本数据类型，Java给每个基本数据类型各自提供了·一个包装类。</p> 
<p>如下图</p> 
<p class="img-center"><img alt="" height="700" src="https://images2.imgbox.com/fa/62/P5CYhFAt_o.png" width="1200"></p> 
<p>除了char和int基本数据类型的包装类型有点特别，其他的都是首字母大写 </p> 
<h3>1.2 装箱与拆箱</h3> 
<h4>1. 装箱</h4> 
<p>装箱就是将基本数据类型的数据转化成包装类，装箱分为自动装箱和显示拆箱。</p> 
<pre><code class="language-java">public static void main(String[] args) {
        int a=10;
        Integer b=Integer.valueOf(a);//显示拆箱
        Integer c=a;//自动拆箱
    }</code></pre> 
<p>其实自动拆箱和显示拆箱的底层原理是一样的，都是调用了Integer.valueOf()方法。</p> 
<h4>2. 拆箱</h4> 
<p>拆箱就是将包装类的数据类型转换转换成基本数据类型，拆箱也分为自动拆箱和显示拆箱。</p> 
<pre><code class="language-java">public static void main1(String[] args) {
        Integer a=10;
        int b=a.intValue();//显示拆箱
        int c=a;//自动拆箱
    }</code></pre> 
<h3> 2.面试题</h3> 
<p>了解装箱与拆箱，我们来看一道面试题</p> 
<pre><code class="language-java">public static void main(String[] args) {
        Integer a=100;
        Integer b=100;
        System.out.println(a == b);//打印true
        Integer c=200;
        Integer d=200;
        System.out.println(c == d);//打印false

    }</code></pre> 
<p>为什么会打印不同的结果呢？</p> 
<p>我们来看Integer.ValueOf()方法的原码</p> 
<p><img alt="" height="373" src="https://images2.imgbox.com/0a/84/3yzCgDz3_o.png" width="898"></p> 
<p>我们发现，在进行装包操作的时候，会根据装包的数据的大小来返回不同类型的数据。</p> 
<p>当要装包的数据的范围在 [-127~128] 之间时，valueOf 方法就会返回数组中的一个数据（整数）。</p> 
<p>如下图</p> 
<p class="img-center"><img alt="" height="306" src="https://images2.imgbox.com/1b/2f/pjh4HK6h_o.png" width="1029"></p> 
<p><span style="color:#fe2c24;"><strong>当数据不在上面的范围时，就会返回一个新的实例化的对象。 </strong></span></p> 
<p> <strong>所以，由于100在【128~127】这个范围内，所以两者的比较是两个整数之间的比较。</strong></p> 
<p><strong> 由于200超出了以上范围，所以c和d的比较实际上是两个对象之间的比较，有==来比较两个对象，返回值当然是false。</strong></p> 
<h2>2. 泛型</h2> 
<h3>2.1 泛型的概念</h3> 
<p>一般类和方法，只能使用具体的数据类型，要么是基本数据类型或者是引用数据类型。当我们要编写设计多种数据类型的程序时，一旦我们将数据类型固定，那么对于后续的编程的限制会很大。所以在Java中提出了泛型的概念，所谓<span style="color:#fe2c24;"><strong>泛型，就是将数据类型参数化。</strong></span></p> 
<h3>2.2 引出泛型</h3> 
<p>我们先来看一道题：实现一个类，该类中有一个可以存储任何数据类型的数组，并且可以通过方法来设置数组中的值和获取数组中对应的内容。</p> 
<p>代码如下图</p> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/9a/30/QHRZsfXF_o.png" width="520"></p> 
<p>在类中，我们创建了一个Object类型的数组，这样就可以存储任何数据类型了。但是，后面我们发现，我们可以通过方法来直接设置数组中的内容，但是我们通过方法来获取数据类型的时候，却发现会报错，这是因为发生了向下转型，我们需要进行强制类型转换才能正确获得数组中的任何数据。这样想想就很奇怪了，我明明可以存储任何数据类型，但却不能直接1获取数组中的数据。为了解决这个问题，我们就可以使用泛型。</p> 
<p>如以下代码</p> 
<pre><code class="language-java">class DataBase&lt;E&gt;{
    Object[] array=new Object[10];
    public void setArray(int pos,E obj){
        array[pos]=obj;
    }
    public E getArray(int pos){
        return (E)array[pos];
    }
}
public class Test {
    public static void main(String[] args) {
        DataBase&lt;Integer&gt; dataBase=new DataBase&lt;&gt;();
        dataBase.setArray(0,10);
        Integer a=dataBase.getArray(0);
        DataBase&lt;String&gt; dataBase1=new DataBase&lt;String&gt;();
        dataBase1.setArray(1,"man");
        String str=dataBase1.getArray(1);
    }
}</code></pre> 
<p class="img-center"><img alt="" height="450" src="https://images2.imgbox.com/9d/42/phGyFqZr_o.png" width="479"></p> 
<p><strong>&lt; E &gt;就是泛型的用法</strong> ，可以发现，当我们使用泛型之后，我们就可以直接来获取数据了，不用进行强制转换了。</p> 
<p>简单来说，使用泛型，就行我们在创建类的时候，通过泛型，我们可以将数据类型转换为参数来进行类的创建。如上图，我们在实例化database对象的时候，我们将Integer的数据类型作为参数传过去，所以此时，对于字母E就代表Integer数据类型，实例化database1的时候，我们将String数据类型作为参数传过去，此时，对于database1来说，字母E就代表String类型。</p> 
<p>注意事项：&lt;E&gt;可以理解为一个标识符，代表该类为泛型类。</p> 
<h3>2.3 泛型的语法</h3> 
<pre><code class="language-java">class 类名&lt;T&gt;{

}</code></pre> 
<p>类名后的&lt;T&gt;是一个标识符，表示当前类为泛型类。 其中&lt; &gt;里面也可以是其他字母，常见的有T和E。</p> 
<h2>3.泛型类的使用</h2> 
<h3>3.1 语法格式</h3> 
<pre><code class="language-java">泛型类名&lt;类型实参&gt; 变量名=new 泛型类名&lt;类型实参&gt;();</code></pre> 
<p>举例</p> 
<p> </p> 
<pre><code class="language-java">class MyFunc&lt;T&gt;{

}
public class Test {
    public static void main(String[] args) {
        MyFunc&lt;Integer&gt; myFunc=new MyFunc&lt;Integer&gt;();
        MyFunc&lt;String&gt; myFunc1=new MyFunc&lt;&gt;();
    }
    
}
</code></pre> 
<p>在创建泛型类对象时，后面的new&lt; &gt;里面的包装类可以不写，编译器会根据前面的包装类来推导后面的包装类类型。</p> 
<p>注意事项：<strong>泛型只能接受类，所有的基本数据类型必须使用包装类。</strong></p> 
<h2> 4. 裸类型（了解）</h2> 
<p>裸类型是一种不带参数的泛型类型，它是为了兼容以前老版本JDK没有泛型的版本。例如MyArrayList就是一个裸类型。</p> 
<h3>5. 擦除机制</h3> 
<p>泛型是如何进行编译的呢？</p> 
<p>泛型是<span style="color:#fe2c24;"><strong>编译时期的机制</strong></span>，代码在<strong>运行的时候没有泛型的概念。</strong></p> 
<p>这就涉及到擦处机制：在编译完成后，所有的传给泛型类的数据类型，最终都会被擦除为Object类。所以，编译之后的字节码无泛型，只有Object类。</p> 
<h2>6. 泛型的上界</h2> 
<p>在定义泛型类时，有时需要对传入的类型变量进行限制，这时候可以通过类型边界来限制。</p> 
<h3>6.1 语法</h3> 
<pre><code class="language-java">class 泛型类名称&lt;类型形参 extends 类型边界&gt; {
    ...
}</code></pre> 
<p>举例</p> 
<p class="img-center"><img alt="" height="341" src="https://images2.imgbox.com/6d/ec/jg5DLp4J_o.png" width="652"></p> 
<p> 这时定义的泛型类时传入的类型参数的上界为Number，传如的类型参数必须是Number的子类，由于String类不是Number的子类，所以会报错。</p> 
<p>注意事项：没有泛型边界的，默认边界为Object。</p> 
<h3>6.2 复杂例子</h3> 
<p>题目要求：创建一个类，里面有一个方法来获取数组中的最大值。</p> 
<p>我们会很直接的写下以下代码</p> 
<p class="img-center"><img alt="" height="450" src="https://images2.imgbox.com/f0/9e/gMG5NxAx_o.png" width="492"></p> 
<p>当我们写出上图的代码之后，我们发现会报错。这是因为泛型类的E代表很多数据类型，我们不能用平常的数学思维去比较。这时候我们可以对传入的类型参数实现comparable接口来解决问题。</p> 
<pre><code class="language-java">class Alg&lt;E extends Comparable&lt;E&gt;&gt;{
    public E FindMax(E[] array){
        E max=array[0];
        for(int i=1;i&lt;array.length;i++){
            if(array[i].compareTo(max)&gt;0){
                max=array[i];
            }
        }
        return max;
    }
}
public class Test {
    public static void main(String[] args) {
        Integer[] array={1,2,3,4,5};
        Alg alg=new Alg();
        int ret=alg.FindMax(array);
    }
}</code></pre> 
<p>这时，由于我们在定义泛型类的时候使用了Comparable接口，所以，此时，<span style="color:#fe2c24;"><strong>传入的类型参数必须实现Comparable接口</strong></span>，否则会报错。</p> 
<h2> 7. 泛型方法</h2> 
<h3>7.1 语法格式</h3> 
<pre><code class="language-java">方法修饰限定符 &lt;类型参数&gt; 返回值类型 方法名(){

}</code></pre> 
<p>举例</p> 
<pre><code class="language-java">public static&lt;E extends Comparable&lt;E&gt;&gt; E FindMax(E[] array)</code></pre> 
<p> 以上题目，获取最大值的另一种代码形式</p> 
<pre><code class="language-java">class Alg{
    public static&lt;E extends Comparable&lt;E&gt;&gt; E FindMax(E[] array){
        E max=array[0];
        for(int i=1;i&lt;array.length;i++){
            if(array[i].compareTo(max)&gt;0){
                max=array[i];
            }
        }
        return max;
    }
}
public class Test {
    public static void main(String[] args) {
        Integer[] array={1,2,3,4,5};
        Alg alg=new Alg();
        Integer ret=Alg.FindMax(array);//使用类型推导
        Integer ret2=Alg.&lt;Integer&gt;FindMax(array);//不使用类型推导
    }
}</code></pre> 
<p>感谢观看。</p> 
<p> </p> 
<p class="img-center"><img alt="" height="600" src="https://images2.imgbox.com/6a/74/MCUPzOyw_o.jpg" width="600"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5f553f3d6bbcb35e35e33d38987f7dff/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Java】搜索引擎设计：信息搜索怎么避免大海捞针？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ce267ec35d5385942cc20e343354cc36/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">深入分析 Android BroadcastReceiver (六)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>