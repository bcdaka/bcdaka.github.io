<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构第一关---- 复杂度 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/5133cc08c481c4f2cbccf7c2b0a32bc5/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构第一关---- 复杂度">
  <meta property="og:description" content="初阶数据结构第一关---- 复杂度 什么是数据结构？ 我们之前已经学习过数组相关的概念，这里举个例子：
int a=10; //我们需要定义1000个整型变量数组 int arr[1000]; //如果我们要进行更改的话，可以这样做 int arr[i]=100; 同理，数据结构就是对数据进行管理。
概念：数据结构(Data Structure)是计算机存储、组织数据的⽅式，指相互之间存在⼀种或多种特定关系的数 据元素的集合。没有⼀种单⼀的数据结构对所有⽤途都有⽤，所以我们要学各式各样的数据结构， 如：线性表、树、图、哈希等
算法的概念：算法(Algorithm):就是定义良好的计算过程，他取⼀个或⼀组的值为输⼊，并产⽣出⼀个或⼀组值作为 输出。简单来说算法就是⼀系列的计算步骤，⽤来将输⼊数据转化成输出结果。
数据结构好比是一个收纳整齐的容器，算法好比是取得想要东西的统筹方法，所以说数据结构和算法不分家
引入一个例子：如何衡量算法好坏 轮换数组 给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。
示例 1:
输入: nums = [1,2,3,4,5,6,7], k = 3 输出: [5,6,7,1,2,3,4] 解释: 向右轮转 1 步: [7,1,2,3,4,5,6] 向右轮转 2 步: [6,7,1,2,3,4,5] 向右轮转 3 步: [5,6,7,1,2,3,4] 示例 2:
输入：nums = [-1,-100,3,99], k = 2 输出：[3,99,-1,-100] 解释: 向右轮转 1 步: [99,-1,-100,3] 向右轮转 2 步: [3,99,-1,-100] 思路：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-12T22:05:18+08:00">
    <meta property="article:modified_time" content="2024-07-12T22:05:18+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构第一关---- 复杂度</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="__0"></a>初阶数据结构第一关---- 复杂度</h2> 
<h3><a id="_4"></a>什么是数据结构？</h3> 
<p>我们之前已经学习过数组相关的概念，这里举个例子：</p> 
<pre><code class="prism language-C">int a=10;
//我们需要定义1000个整型变量数组
int arr[1000];
//如果我们要进行更改的话，可以这样做
int arr[i]=100;
</code></pre> 
<p>同理，数据结构就是对数据进行管理。</p> 
<p><strong>概念</strong>：数据结构(Data Structure)是计算机存储、组织数据的⽅式，指相互之间存在⼀种或多种特定关系的数 据元素的集合。没有⼀种单⼀的数据结构对所有⽤途都有⽤，所以我们要学各式各样的数据结构， 如：线性表、树、图、哈希等</p> 
<p><strong>算法的概念</strong>：算法(Algorithm):就是定义良好的计算过程，他取⼀个或⼀组的值为输⼊，并产⽣出⼀个或⼀组值作为 输出。简单来说算法就是⼀系列的计算步骤，⽤来将输⼊数据转化成输出结果。</p> 
<p>数据结构好比是一个收纳整齐的容器，算法好比是取得想要东西的统筹方法，所以说<mark>数据结构和算法不分家</mark></p> 
<h3><a id="_24"></a>引入一个例子：如何衡量算法好坏</h3> 
<h4><a id="_26"></a>轮换数组</h4> 
<p>给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p> 
<p><strong>示例 1:</strong></p> 
<pre><code>输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]
</code></pre> 
<p><strong>示例 2:</strong></p> 
<pre><code>输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释: 
向右轮转 1 步: [99,-1,-100,3]
向右轮转 2 步: [3,99,-1,-100]
</code></pre> 
<p>思路：</p> 
<p>循环K次将数组所有元素向后移动⼀位</p> 
<p>分析的过程：<br> <img src="https://images2.imgbox.com/b4/e2/MXpY4jKu_o.png" alt="在这里插入图片描述"></p> 
<p>在OJ平台上提交的情况如下：<br> <img src="https://images2.imgbox.com/c0/ab/ggk38dFX_o.png" alt="在这里插入图片描述"></p> 
<p>这就引出了如何衡量算法的好坏呢？</p> 
<p>从复杂度的角度来看，复杂度从空间和时间两个维度来看。</p> 
<h3><a id="_69"></a>复杂度</h3> 
<p>算法在编写成可执⾏程序后，运⾏时需要耗费时间资源和空间(内存)资源 。因此<strong>衡量⼀个算法的好 坏，⼀般 是从时间和空间两个维度来衡量的</strong>，即时间复杂度和空间复杂度。<strong>时间复杂度主要衡量⼀个算法的运⾏快慢，⽽空间复杂度主要衡量⼀个算法运⾏所需要的额外空间</strong>。 在计算 机发展的早期，计算机的存储容量很⼩。所以对空间复杂度很是在乎。但是经过计算机⾏业的迅速发 展，计 算机的存储容量已经达到了很⾼的程度。所以我们如今已经不需要再特别关注⼀个算法的空间复杂 度。</p> 
<p>（题外话：根据摩尔定律，计算机每过16-24年性能翻一番）</p> 
<h3><a id="_75"></a>时间复杂度</h3> 
<p>定义：在计算机科学中，<strong>算法的时间复杂度是⼀个函数式T(N)</strong>，它定量描述了该算法的运⾏时间。时 间复杂度是衡量程序的时间效率，那么为什么不去计算程序的运⾏时间呢？</p> 
<ol><li> <p>因为程序运⾏时间和编译环境和运⾏机器的配置都有关系，⽐如同⼀个算法程序，⽤⼀个⽼编译 器进⾏编译和新编译器编译，在同样机器下运⾏时间不同。</p> </li><li> <p>同⼀个算法程序，⽤⼀个⽼低配置机器和新⾼配置机器，运⾏时间也不同。</p> </li><li> <p>并且时间只能程序写好后测试，不能写程序前通过理论思想计算评估。</p> </li></ol> 
<p>以下是测试时间的代码：</p> 
<pre><code class="prism language-C">#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
int main()
{
	//计算程序运行时间
	int begin = clock();
	int count = 0;
	for (int i = 0; i &lt; 10000; i++)
	{
		count++;
	}
	int end =clock() ;
	printf("time:%d\n", end - begin);
	return 0;
}
</code></pre> 
<p>计算公式：</p> 
<p><img src="https://images2.imgbox.com/73/c9/jGkojR2Q_o.png" alt="在这里插入图片描述"></p> 
<p>我们可以不用考虑每条语句运行时间，只看运行次数</p> 
<p>因为程序时间效率和运行次数成正比</p> 
<p><img src="https://images2.imgbox.com/ef/dd/QOQkz3nu_o.png" alt="在这里插入图片描述"></p> 
<p>那么算法的时间复杂度是⼀个函数式T(N)到底是什么呢？这个T(N)函数式计算了程序的执⾏次数。通 过c语⾔编译链接章节学习，我们知道算法程序被编译后⽣成⼆进制指令，程序运⾏，就是cpu执⾏这 些编译好的指令。那么我们通过程序代码或者理论思想计算出程序的执⾏次数的函数式T(N)，假设每 句指令执⾏时间基本⼀样(实际中有差别，但是微乎其微)，那么执⾏次数和运⾏时间就是等⽐正相关， 这样也脱离了具体的编译运⾏环境。执⾏次数就可以代表程序时间效率的优劣。⽐如解决⼀个问题的 算法a程序T(N) = N，算法b程序T(N) = N^2，那么算法a的效率⼀定优于算法b.</p> 
<p>下面来看一道例题：</p> 
<pre><code class="prism language-C">// 请计算⼀下Func1中++count语句总共执⾏了多少
次？
void Func1(int N)
{
int count = 0;
for (int i = 0; i &lt; N ; ++ i)
{
for (int j = 0; j &lt; N ; ++ j)
{
++count;
}
}
for (int k = 0; k &lt; 2 * N ; ++ k)
{
++count;
}
int M = 10;
while (M--)
{
++count;
}
}
</code></pre> 
<p><img src="https://images2.imgbox.com/de/a1/GIitoJMZ_o.png" alt="在这里插入图片描述"></p> 
<p>一些疑问：</p> 
<p>为什么声明变量的时候不进行考虑呢？</p> 
<p>因为声明的时候，执行次数为1，实在是太小了，可以忽略不计，上面写的可以测试运行时间的代码里面，10000次可能运行时间都为0，所以声明的时候可以忽略不记</p> 
<hr> 
<p>实际中我们计算时间复杂度时，计算的也不是程序的精确的执⾏次数，精确执⾏次数计算起来还是很 ⿇烦的(不同的⼀句程序代码，编译出的指令条数都是不⼀样的)，计算出精确的执⾏次数意义也不⼤， 因为我么计算时间复杂度只是想⽐较算法程序的增⻓量级，也就是当N不断变⼤时T(N)的差别，上⾯我 们已经看到了当N不断变⼤时常数和低阶项对结果的影响很⼩，所以我们只需要计算程序能代表增⻓量 级的⼤概执⾏次数，复杂度的表⽰通常使⽤⼤O的渐进表⽰法。</p> 
<h3><a id="O_162"></a>⼤O的渐进表⽰法</h3> 
<p>⼤O符号（Big O notation）：是⽤于描述函数渐进⾏为的数学符号</p> 
<p>💡 推导⼤O阶规则</p> 
<ol><li> <p>时间复杂度函数式T(N)中，只保留最⾼阶项，去掉那些低阶项，因为当N不断变⼤时， 低阶项对结果影响越来越⼩，当N⽆穷⼤时，就可以忽略不计了。</p> </li><li> <p>如果最⾼阶项存在且不是1，则去除这个项⽬的常数系数，因为当N不断变⼤，这个系数 对结果影响越来越⼩，当N⽆穷⼤时，就可以忽略不计了。</p> </li><li> <p>T(N)中如果没有N相关的项⽬，只有常数项，⽤常数1取代所有加法常数。</p> </li></ol> 
<p>通过以上⽅法，可以得到 Func1 的时间复杂度为： O(N<sup>2</sup>)</p> 
<p><mark>注意点</mark>：</p> 
<p>这里的规则时间复杂度和空间复杂度都能用</p> 
<h3><a id="_179"></a>时间复杂度计算⽰例</h3> 
<h4><a id="1_181"></a>示例1</h4> 
<pre><code class="prism language-C">// 计算Func2的时间复杂度？
void Func2(int N)
{
int count = 0;
for (int k = 0; k &lt; 2 * N ; ++ k)
{
++count;
}
int M = 10;
while (M--)
{
++count;
}
printf("%d\n", count);
}
</code></pre> 
<p><img src="https://images2.imgbox.com/9b/10/R2In0KyH_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2_206"></a>示例2</h4> 
<pre><code class="prism language-C">// 计算Func3的时间复杂度？
void Func3(int N, int M)
{
int count = 0;
for (int k = 0; k &lt; M; ++ k)
{
++count;
}
for (int k = 0; k &lt; N ; ++
k)
{
++count;
}
printf("%d\n", count);
}

</code></pre> 
<p><img src="https://images2.imgbox.com/10/e6/sAMkMdYb_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="3_230"></a>示例3</h4> 
<pre><code class="prism language-C">// 计算Func4的时间复杂度？
void Func4(int N)
{
int count = 0;
for (int k = 0; k &lt; 100; ++ k)
{
++count;
}
printf("%d\n", count);
}
</code></pre> 
<p><img src="https://images2.imgbox.com/6e/ee/C1YHUvii_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="4_248"></a>示例4</h4> 
<pre><code class="prism language-C">// 计算strchr的时间复杂度？
const char * strchr ( const char
* str, int character)
{
const char* p_begin = s;
while (*p_begin != character)
{
if (*p_begin == '\0')
return NULL;
p_begin++;
}
return p_begin;
}
</code></pre> 
<p><strong>T（N)取决于要查找的位置</strong></p> 
<p><img src="https://images2.imgbox.com/2c/28/oT5nmyGM_o.png" alt="在这里插入图片描述"></p> 
<p>💡 总结 通过上⾯我们会发现，有些算法的时间复杂度存在最好、平均和最坏情况。</p> 
<p>最坏情况：任意输⼊规模的最⼤运⾏次数(上界)</p> 
<p>平均情况：任意输⼊规模的期望运⾏次数</p> 
<p>最好情况：任意输⼊规模的最⼩运⾏次数(下界)</p> 
<p>⼤O的渐进表⽰法在实际中⼀般情况关注的是算法的上界，也就是最坏运⾏情况</p> 
<h4><a id="5_283"></a>示例5</h4> 
<pre><code class="prism language-C">// 计算BubbleSort的时间复杂度？
void BubbleSort(int* a, int n)
{
assert(a);
for (size_t end = n; end &gt; 0; --end)
{
int exchange = 0;
for (size_t i = 1; i &lt; end; ++i)
{
if (a[i-1] &gt; a[i])
{
Swap(&amp;a[i-1], &amp;a[i]);
exchange = 1;
}
}
if (exchange == 0)
break;
}
}
</code></pre> 
<p>外层循环控制的是我们一次循环要交换多少次，这里的时间复杂度是内层循环交换次数的累加</p> 
<p><img src="https://images2.imgbox.com/eb/90/E0ngXIIH_o.png" alt="在这里插入图片描述"></p> 
<p>因此：<strong>BubbleSort的时间复杂度取最 差情况为： O(N<sup>2</sup> )</strong></p> 
<p>有个地方要注意区分：</p> 
<p>前面的里面有道题也是双层for循环</p> 
<p><img src="https://images2.imgbox.com/17/51/4mWgjhF0_o.png" alt="在这里插入图片描述"></p> 
<p>实际上本质也是外层控制次数，不过这里外层是m,不是具体的常数，不可以忽略掉，所以时间复杂度是M*N</p> 
<h4><a id="6_323"></a>示例6</h4> 
<pre><code class="prism language-C">void func5(int n)
{
int cnt = 1;
while (cnt &lt; n)
{
cnt *= 2;
}
}
</code></pre> 
<p><img src="https://images2.imgbox.com/39/81/kL2ZnT1l_o.png" alt="在这里插入图片描述"></p> 
<p>书籍中 log2 n 、 log n 、 lg n 的表⽰ 当n接近⽆穷⼤时，底数的⼤⼩对结果影响不⼤。因此，⼀般情况下不管底数是多少都可以省略不 写，即可以表⽰为 log n 不同书籍的表⽰⽅式不同，以上写法差别不⼤，我们建议使⽤ log n,也是因为对数的底数打不出来</p> 
<h4><a id="7_341"></a>示例7</h4> 
<pre><code class="prism language-C">// 计算阶乘递归Fac的时间复杂度？
long long Fac(size_t N)
{
if(0 == N)
return 1;
return Fac(N-1)*N;
}
</code></pre> 
<p><img src="https://images2.imgbox.com/41/d8/f3xcWDqN_o.png" alt="在这里插入图片描述"></p> 
<p>这里不可以理解为单次递归的时间复杂度都是O(1),也要具体情况具体分析，如果说里面嵌套for循环之类的，就可能不是O(1)</p> 
<p>这里仅仅是举例一些常见的例子，因为是初阶数据结构，就不展开来讲太多。</p> 
<h3><a id="_359"></a>空间复杂度</h3> 
<p>空间复杂度也是⼀个数学表达式，是对⼀个算法在运⾏过程中因为算法的需要<strong>额外临时开辟的空间</strong>。</p> 
<p>空间复杂度不是程序占⽤了多少bytes的空间，因为常规情况每个对象⼤⼩差异不会很⼤，所以空间复 杂度算的是变量的个数。</p> 
<p>空间复杂度计算规则基本跟实践复杂度类似，也使⽤<strong>⼤O渐进表⽰法</strong>。</p> 
<p>注意：<strong>函数运⾏时所需要的栈空间(存储参数、局部变量、⼀些寄存器信息等)在编译期间已经确定好 了，因 此空间复杂度主要通过函数在运⾏时候显式申请的额外空间来确定</strong></p> 
<h3><a id="_369"></a>空间复杂度计算示例</h3> 
<h4><a id="1_371"></a>示例1</h4> 
<pre><code class="prism language-C">// 计算BubbleSort的空间复杂度？
void BubbleSort(int* a, int n)
{
assert(a);
for (size_t end = n; end &gt; 0; --end)
{
int exchange = 0;
for (size_t i = 1; i &lt; end; ++i)
{
if (a[i-1] &gt; a[i])
{
Swap(&amp;a[i-1], &amp;a[i]);
exchange = 1;
}
}
if (exchange == 0)
break;
}
}

</code></pre> 
<p><img src="https://images2.imgbox.com/bd/98/Cjd24tPl_o.png" alt="在这里插入图片描述"></p> 
<p>函数栈帧在编译期间已经确定好了， 只需要关注函数在运⾏时额外申请的 空间。 BubbleSort额外申请的空间有 exchange等有限个局部变量，使⽤了 常数个额外空间 因此空间复杂度为 O(1)</p> 
<h4><a id="2_401"></a>示例2</h4> 
<pre><code class="prism language-C">// 计算阶乘递归Fac的空间复杂度？
long long Fac(size_t N)
{
if(N == 0)
return 1;
return Fac(N-1)*N;
}
</code></pre> 
<p><img src="https://images2.imgbox.com/cb/e6/Hz2KSVes_o.png" alt="在这里插入图片描述"></p> 
<p>Fac递归调⽤了N次，额外开辟了N个函数栈帧， 每个栈帧使⽤了常数个空间 因此空间复杂度为： O(N)</p> 
<p><strong>注意点</strong>：<br> 涉及到动态内存管理也会涉及到空间复杂度的计算，例子如下：</p> 
<pre><code class="prism language-C">int func()
{
    int arr[n]=(int*)malloc(sizeof(int)*n);
}
</code></pre> 
<p>这段代码的空间复杂度为O(n)</p> 
<h3><a id="_430"></a>常见复杂度对比</h3> 
<p><img src="https://images2.imgbox.com/a3/0b/b5RCu2zC_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/cd/a0/48rSL9Yc_o.png" alt="在这里插入图片描述"></p> 
<p>上图仅需要做个简单的了解即可</p> 
<h3><a id="_440"></a>相关的小练习</h3> 
<h4><a id="O_442"></a>大O表示法</h4> 
<p>1.下列有关大O表示法的说法错误的是</p> 
<p>A.大O表示法只是对程序执行时间的一个估算</p> 
<p>B.大O表示法只保留最高阶项</p> 
<p>C.大O表示法会保留一个系数来更准确的表示复杂度</p> 
<p>D.大O表示法一般表示的是算法最差的运行时间</p> 
<p>答案：C</p> 
<p>解析：大O是一个渐进表示法，不会去表示精确的次数，cpu的运算速度很快，估计精确的没有意义。</p> 
<h4><a id="_458"></a>时间复杂度</h4> 
<p>2.分析以下程序的时间复杂度</p> 
<pre><code class="prism language-C">for(int i=0;i&lt;n;i++)
  for(int j=0;j&lt;n;j++)
    a[i][j]=i*j;
</code></pre> 
<p>A.O(n)</p> 
<p>B.O(n^2)</p> 
<p>C.O(nlogn)</p> 
<p>D.O(logn)</p> 
<p>答案：B</p> 
<p>解析：</p> 
<p>程序有两次循环，每个循环都有n次操作，所以时间复杂度为n^2</p> 
<p>3.分析以下函数的时间复杂度</p> 
<pre><code class="prism language-C">void fun(int n) {
  int i=l;
  while(i&lt;=n)
    i=i*2;
}
</code></pre> 
<p>A.O(n)</p> 
<p>B.O(n^2)</p> 
<p>C.O(nlogn)</p> 
<p>D.O(logn)</p> 
<p>5.下面算法的时间复杂度是（ ）</p> 
<pre><code class="prism language-C"> int f ( unsigned int n ) {
    if (n == 0 || n==1) 
      return 1;
    else 
      return n * f(n-1);
  }
</code></pre> 
<p>A.O(n)</p> 
<p>B.O(n^2)</p> 
<p>C.O(nlogn)</p> 
<p>D.O(logn)</p> 
<p>答案：A</p> 
<p>解析：</p> 
<p>此函数会被递归调用n - 1次，每次操作都是一次，所以时间复杂度为n</p> 
<h4><a id="_525"></a>空间复杂度</h4> 
<p>2.分析以下函数的空间复杂度（ ）</p> 
<pre><code class="prism language-C">int** fun(int n) {
    int ** s = (int **)malloc(n * sizeof(int *));
    while(n--)
      s[n] = (int *)malloc(n * sizeof(int));
    return s;
  }
</code></pre> 
<p>A.O(n)</p> 
<p>B.O(n^2)</p> 
<p>C.O( 1 )</p> 
<p>D.O(nlogn)</p> 
<p>答案：B</p> 
<p>解析：</p> 
<p>此处开辟的是一个二维数组，数组有n行，每行分别有1,2,3,…n列，所以是n(n + 1)/2个元素空间，空间复杂度为n^2</p> 
<h3><a id="_552"></a>复杂度算法题</h3> 
<h4><a id="_554"></a>旋转数组</h4> 
<p>给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p> 
<p><strong>示例 1:</strong></p> 
<pre><code>输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]
</code></pre> 
<p><strong>示例 2:</strong></p> 
<pre><code>输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释: 
向右轮转 1 步: [99,-1,-100,3]
向右轮转 2 步: [3,99,-1,-100]
</code></pre> 
<p>思路1</p> 
<p>时间复杂度 O(n<sup>2</sup> )</p> 
<p>循环K次将数组所有元素向后移动⼀位（代码不通过）</p> 
<pre><code class="prism language-C">void rotate(int* nums, int numsSize, int k) {
while(k--)
{
int end = nums[numsSize-1];
for(int i = numsSize - 1;i &gt; 0 ;i--)
{
nums[i] = nums[i-1];
}
nums[0] = end;
}
}
</code></pre> 
<p>思路2：</p> 
<p>空间复杂度 O(n)</p> 
<p>申请新数组空间，先将后k个数据放到新数组中，再将剩下的数据挪到新数组中</p> 
<pre><code class="prism language-C">void rotate(int* nums, int numsSize, int k)
{
int newArr[numsSize];
for (int i = 0; i &lt; numsSize; ++i)
{
newArr[(i + k) % numsSize] = nums[i];
}
for (int i = 0; i &lt; numsSize; ++i)
{
nums[i] = newArr[i];
}
}
</code></pre> 
<p><mark>以空间换时间的方式</mark></p> 
<p><img src="https://images2.imgbox.com/ea/30/ewypCuVc_o.png" alt="在这里插入图片描述"></p> 
<p>先申请新的数组，大小为numsSize,[]下标的处理是关键，这是反转数组的关键</p> 
<p><img src="https://images2.imgbox.com/ab/4a/25zJH9Vg_o.png" alt="在这里插入图片描述"></p> 
<p>代码如下：</p> 
<pre><code class="prism language-C">void rotate(int* nums, int numsSize, int k)
{
int newArr[numsSize];
for (int i = 0; i &lt; numsSize; ++i)
{
newArr[(i + k) % numsSize] = nums[i];
}
for (int i = 0; i &lt; numsSize; ++i)
{
nums[i] = newArr[i];
}
}

</code></pre> 
<p>思路3：空间复杂度 O(1)（<mark>非常妙的思路</mark>）</p> 
<p><img src="https://images2.imgbox.com/55/93/OhbkT2Zp_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-C">void reverse(int* nums,int begin,int end)//逆置数组元素
{
while(begin&lt;end)//先判断再执行，=可以不加
{
    //交换数组元素
int tmp = nums[begin];
nums[begin] = nums[end];
nums[end] = tmp;
    //元素移动
begin++;
end--;
}
}
void rotate(int* nums, int numsSize, int k)
{
    //保证k的值不会超过numsSize
k = k%numsSize;
    //前n-k个数据逆置
reverse(nums,0,numsSize-k-1);
    //后k个数据逆置
reverse(nums,numsSize-k,numsSize-1);
    //整体数据逆置
reverse(nums,0,numsSize-1);
}

</code></pre> 
<p><img src="https://images2.imgbox.com/98/dc/MHpEp5J7_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/ab/37/HTyBqFwG_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_696"></a>思维导图</h3> 
<p><img src="https://images2.imgbox.com/9f/b0/A3qYej4U_o.png" alt="在这里插入图片描述"></p> 
<pre><code>

</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dc84557a8fb58ef1ba69468a4254edcc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Bugku---web---速度要快</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ad30903fba05c08653d9928b40900f2a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">M3U8工作原理以及key解密视频流详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>