<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>高级数据结构 ＜二叉搜索树＞ - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/36e34eac84ecdff76061928a0431696b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="高级数据结构 ＜二叉搜索树＞">
  <meta property="og:description" content="本文已收录至《数据结构(C/C&#43;&#43;语言)》专栏！
作者：ARMCSKGT 目录 前言正文二叉搜索树的概念二叉搜索树的基本功能实现二叉搜索树的基本框架插入节点删除节点查找函数中序遍历函数析构函数和销毁函数(后序遍历销毁)拷贝构造和赋值重载(前序遍历创建)其他函数 二叉搜索树的应用场景key模型key-value模型 关于二叉搜索树 最后 前言 前面我们学习了二叉树，但仅仅只是简单的二叉树并没有很大的用处，而本节的二叉搜索树是对二叉树的升级，其查找效率相对于简单二叉树来说有一定提升，二叉搜索树是学习AVL树和红黑树的基础，所以我们必须先了解二叉搜索树。
正文 二叉搜索树的概念 二叉搜索树（Binary search tree）也称二叉排序树或二叉查找树，是在普通二叉树基础上的升级版本，普通二叉树的利用价值不大，而二叉搜索树要求 左节点比根小，右节点比根大，二叉搜索树将数据按二分性质插入在树中，所以将数据存入 二叉搜索树 中进行查找时，理想情况下只需要花费 logN 的时间（二分思想），此时使用中序遍历可以得到一列有序序列，因此 二叉搜索树 的查找效率极高，具有一定的实际价值。
二叉搜索树名字的由来就是因为搜索（查找）速度很快！
二叉搜索树基本特点
一棵二叉树，可以为空；如果不为空则：
如果左子树存在，则左子树根节点一定比根节点值要小如果右子树存在，则右子树根节点一定比根节点值要大左子树中的所有节点比根节点小，右子树中的所有节点比根节点大所有的节点值都不相同，不会出现重复值的节点所有子树都遵循这些性质 在这种性质下，使用中序遍历可以得到升序序列，如果将性质反转，即左比根大右比根小，则中序遍历可得到降序序列。
如上图的中树，中序遍历序列为：1 3 4 6 7 8 10 13 14
二叉搜索树的基本功能实现 二叉搜索树的基本框架 二叉搜索树的节点同样需要单独使用模板封装，且因为会用到比较函数，所以需要一个模板参数充当比较函数。
//节点类 template&lt;class T&gt; struct TreeNode { T _key; TreeNode&lt;T&gt;* _left; TreeNode&lt;T&gt;* _right; TreeNode() :_key(T()) , _left(nullptr) , _right(nullptr) {} TreeNode(const T&amp; key) :_key(key) , _left(nullptr) , _right(nullptr) {} }; //默认比较函数 template&lt;class T&gt; struct Compare { bool operator()(const T&amp; left, const T&amp; right) { return left &gt; right; } }; //二叉搜索树 template&lt;class T, class Com = Compare&lt;T&gt;&gt; class BSTree { //对节点类型 和 树类型 的重命名 方便使用 using NodeType = TreeNode&lt;T&gt;; //相对于 typedef TreeNode&lt;T&gt; NodeType; using TreeType = BSTree&lt;T, Com&gt;; public: BSTree() :_root(nullptr) , _size(0) {} private: NodeType* _root; //根节点 size_t _size; //节点数量 Com _com; //比较函数 }; 插入节点 对于插入函数，我们的目标是要找到合适的插入位置！">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-12-23T10:18:05+08:00">
    <meta property="article:modified_time" content="2023-12-23T10:18:05+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">高级数据结构 ＜二叉搜索树＞</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p><img src="https://images2.imgbox.com/c9/3d/0pUF93JR_o.jpg" alt="二叉搜索树"><br> <br> <em></em></p> 
 <center> 
  <strong>本文已收录至《<a href="https://blog.csdn.net/m0_73446322/category_12100295.html">数据结构(C/C++语言)</a>》专栏！<br> 作者：<a href="https://blog.csdn.net/m0_73446322?spm=1011.2421.3001.5343">ARMCSKGT</a></strong> 
 </center> 
 <br> 
 <img src="https://images2.imgbox.com/63/1e/8xY9Sg1Q_o.gif" alt="CSDN"> 
 <p></p> 
</blockquote> 
<hr> 
<p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_8" rel="nofollow">前言</a></li><li><a href="#_12" rel="nofollow">正文</a></li><li><ul><li><a href="#_13" rel="nofollow">二叉搜索树的概念</a></li><li><a href="#_34" rel="nofollow">二叉搜索树的基本功能实现</a></li><li><ul><li><a href="#_36" rel="nofollow">二叉搜索树的基本框架</a></li><li><a href="#_88" rel="nofollow">插入节点</a></li><li><a href="#_169" rel="nofollow">删除节点</a></li><li><a href="#_354" rel="nofollow">查找函数</a></li><li><a href="#_405" rel="nofollow">中序遍历函数</a></li><li><a href="#_429" rel="nofollow">析构函数和销毁函数(后序遍历销毁)</a></li><li><a href="#_452" rel="nofollow">拷贝构造和赋值重载(前序遍历创建)</a></li><li><a href="#_490" rel="nofollow">其他函数</a></li></ul> 
   </li><li><a href="#_525" rel="nofollow">二叉搜索树的应用场景</a></li><li><ul><li><a href="#key_531" rel="nofollow">key模型</a></li><li><a href="#keyvalue_568" rel="nofollow">key-value模型</a></li></ul> 
   </li><li><a href="#_854" rel="nofollow">关于二叉搜索树</a></li></ul> 
  </li><li><a href="#_869" rel="nofollow">最后</a></li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_8"></a>前言</h2> 
<p>前面我们学习了二叉树，但仅仅只是简单的二叉树并没有很大的用处，而本节的二叉搜索树是对二叉树的升级，其查找效率相对于简单二叉树来说有一定提升，二叉搜索树是学习AVL树和红黑树的基础，所以我们必须先了解二叉搜索树。<br> <img src="https://images2.imgbox.com/d5/2b/pvmeSX0X_o.png" alt=""></p> 
<hr> 
<h2><a id="_12"></a>正文</h2> 
<blockquote> 
 <h3><a id="_13"></a>二叉搜索树的概念</h3> 
 <hr> 
 <p>二叉搜索树（Binary search tree）也称二叉排序树或二叉查找树，是在普通二叉树基础上的升级版本，普通二叉树的利用价值不大，而二叉搜索树要求 <mark>左节点比根小，右节点比根大</mark>，二叉搜索树将数据按二分性质插入在树中，所以将数据存入 二叉搜索树 中进行查找时，理想情况下只需要花费 logN 的时间（二分思想），此时使用中序遍历可以得到一列有序序列，因此 二叉搜索树 的查找效率极高，具有一定的实际价值。<br> <br> 二叉搜索树名字的由来就是因为搜索（查找）速度很快！<br> <br></p> 
 <blockquote> 
  <p><strong>二叉搜索树基本特点</strong><br> 一棵二叉树，可以为空；如果不为空则：</p> 
  <ul><li>如果左子树存在，则左子树根节点一定比根节点值要小</li><li>如果右子树存在，则右子树根节点一定比根节点值要大</li><li>左子树中的所有节点比根节点小，右子树中的所有节点比根节点大</li><li>所有的节点值都不相同，不会出现重复值的节点</li><li>所有子树都遵循这些性质</li></ul> 
 </blockquote> 
 <p><img src="https://images2.imgbox.com/9a/fa/Kpj4RrZH_o.png" alt=""></p> 
 <p>在这种性质下，使用中序遍历可以得到升序序列，如果将性质反转，即左比根大右比根小，则中序遍历可得到降序序列。<br> <br> 如上图的中树，中序遍历序列为：<code>1 3 4 6 7 8 10 13 14</code></p> 
</blockquote> 
<hr> 
<blockquote> 
 <h3><a id="_34"></a>二叉搜索树的基本功能实现</h3> 
 <hr> 
 <h4><a id="_36"></a>二叉搜索树的基本框架</h4> 
 <p>二叉搜索树的节点同样需要单独使用模板封装，且因为会用到比较函数，所以需要一个模板参数充当比较函数。</p> 
 <pre><code class="prism language-cpp"><span class="token comment">//节点类</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">TreeNode</span>
<span class="token punctuation">{<!-- --></span>
	T _key<span class="token punctuation">;</span>
	TreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> _left<span class="token punctuation">;</span>
	TreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> _right<span class="token punctuation">;</span>

	<span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_key</span><span class="token punctuation">(</span><span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_left</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_right</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

	<span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> key<span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_key</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_left</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_right</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//默认比较函数</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">Compare</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> left<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> left <span class="token operator">&gt;</span> right<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token comment">//二叉搜索树</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Com</span> <span class="token operator">=</span> Compare<span class="token operator">&lt;</span>T<span class="token operator">&gt;&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">BSTree</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//对节点类型 和 树类型 的重命名 方便使用</span>
	<span class="token keyword">using</span> NodeType <span class="token operator">=</span> TreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">//相对于 typedef TreeNode&lt;T&gt; NodeType;</span>
	<span class="token keyword">using</span> TreeType <span class="token operator">=</span> BSTree<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Com<span class="token operator">&gt;</span><span class="token punctuation">;</span> 
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">BSTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_root</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_size</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	NodeType<span class="token operator">*</span> _root<span class="token punctuation">;</span> <span class="token comment">//根节点</span>
	size_t _size<span class="token punctuation">;</span>    <span class="token comment">//节点数量</span>
	Com _com<span class="token punctuation">;</span>        <span class="token comment">//比较函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
 <hr> 
 <h4><a id="_88"></a>插入节点</h4> 
 <p>对于插入函数，我们的目标是要找到合适的插入位置！<br> </p> 
 <blockquote> 
  <p><strong>步骤</strong></p> 
  <ul><li>检查root根节点，如果根节点为空则直接赋值为根节点。</li><li>通过 key（插入值）参数查找最佳插入位置，如果遇到相等的，则返回false表示插入失败。</li><li>在查找时记录迭代变量cur的前驱节点parent，当迭代变量为nullptr时，记录的前驱节点就是合适插入节点，插入在该前驱节点后即可。</li><li>在链接插入时，比较插入值key与parent节点值的的大小，从而得知插入到左子树还是右子树，最终插入成功返回true。</li></ul> 
 </blockquote> 
 <p>代码实现(迭代版)：</p> 
 <pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token function">Insert</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> key<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>_root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		NodeType<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">NodeType</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
		_root <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
		_size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	NodeType<span class="token operator">*</span> parent <span class="token operator">=</span> _root<span class="token punctuation">;</span>
	NodeType<span class="token operator">*</span> cur <span class="token operator">=</span> _root<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		parent <span class="token operator">=</span> cur<span class="token punctuation">;</span>
		<span class="token comment">//节点值小于key</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_com</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> cur<span class="token operator">-&gt;</span>_key<span class="token punctuation">)</span><span class="token punctuation">)</span> cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>
		<span class="token comment">//节点值大于key</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_com</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_key<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>
		<span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	NodeType<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">NodeType</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//比较节点值key与parent节点值的大小，插入在正确的位置</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_com</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> parent<span class="token operator">-&gt;</span>_key<span class="token punctuation">)</span><span class="token punctuation">)</span> parent<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
	<span class="token keyword">else</span> parent<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> newnode<span class="token punctuation">;</span>

	<span class="token operator">++</span>_size<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
 <p><mark>注意：parent指针不能赋值为nullptr，当只有一个根节点时，插入会发生空指针访问！</mark><br> <img src="https://images2.imgbox.com/d1/26/eZiQ4UR5_o.png" alt="insert"><br> 当然，迭代可以实现插入，递归也可以，思想相同，但是实现上有一定差异。<br> <br><br> <strong>关于递归版插入函数</strong><br> 因为有递归的存在，所以需要两个参数：<mark>一个用于查找的key和递归参数root节点地址</mark>。但是这个函数并不对外暴露，我们对外暴露的是一个key参数的函数，调用内部递归函数。<br> 这里巧妙的是，我们传递的参数是对节点的引用，那么我们在当前递归函数中的修改，可以影响上一层的节点(父节点)。<br> 假设当前节点为root，那么当我们递归root-&gt;left时，此时root参数变为root-&gt;left，我们修改root就是对上一层root-&gt;left修改，这样，当我们检查到root-&gt;left为nullptr时，创建新节点并构建链接关系然后返回即可完成插入新节点。<br> 同样的，如果插入成功返回true，插入失败返回false。<br> <br><br> <br></p> 
 <p>代码实现(递归版)：</p> 
 <pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token function">RecuInsert</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> key<span class="token punctuation">)</span> <span class="token comment">//递归插入-外部调用接口</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token function">_RecuInsert</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> _root<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">bool</span> <span class="token function">_RecuInsert</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> key<span class="token punctuation">,</span> NodeType<span class="token operator">*</span><span class="token operator">&amp;</span> root<span class="token punctuation">)</span> <span class="token comment">//递归插入-实际调用函数</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//发现空节点直接链接 对节点的引用会自动完成对节点的链接</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		NodeType<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">NodeType</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
		root <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//递归继续查找最佳插入位置</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_com</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> root<span class="token operator">-&gt;</span>_key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">_RecuInsert</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> root<span class="token operator">-&gt;</span>_right<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_com</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_key<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">_RecuInsert</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> root<span class="token operator">-&gt;</span>_left<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
</code></pre> 
 <p>可以发现，递归加持节点引用帮我们省去了很多麻烦，代码也很简洁，但迭代和递归各有优劣，我们都做介绍！</p> 
 <hr> 
 <h4><a id="_169"></a>删除节点</h4> 
 <p>对于删除函数，与插入类似，需要先查找值为key的节点，然后<mark>分情况删除</mark>。</p> 
 <blockquote> 
  <p><strong>步骤</strong></p> 
  <ul><li>通过key值从根节点开始遍历，寻找等值节点，cur逐个遍历节点，parent记录cur的前驱节点</li><li>如果根节点为nullptr或cur遍历为nullptr，则没有可删除的节点，返回false</li><li>如果找到节点，则开始分情况删除，删除后返回true</li></ul> 
 </blockquote> 
   
 <blockquote> 
  <p>这里的难点是删除时，如何保证树的序列和链接关系，分为三种情况：</p> 
  <ul><li>被删节点左右子树为空 (直接删除)</li><li>被删节点左子树或右子树为空 (托孤，将自己的子节点拜托给父节点管理)</li><li>被删节点左右子树都不为空 (找一个替代节点来管理)</li></ul> 
 </blockquote> 
 <p>实现代码(迭代版)：</p> 
 <pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token function">Erase</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> key<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>_root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

	<span class="token comment">//删除节点</span>
	NodeType<span class="token operator">*</span> parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
	NodeType<span class="token operator">*</span> cur <span class="token operator">=</span> _root<span class="token punctuation">;</span>
	<span class="token comment">//找节点</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//节点值小于key</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_com</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> cur<span class="token operator">-&gt;</span>_key<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			parent <span class="token operator">=</span> cur<span class="token punctuation">;</span>
			cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//节点值大于key</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_com</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_key<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			parent <span class="token operator">=</span> cur<span class="token punctuation">;</span>
			cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token comment">//找到了 开始删除</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_right <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token comment">//删除的节点只有左子树</span>
			<span class="token punctuation">{<!-- --></span>
				NodeType<span class="token operator">*</span> DelNode <span class="token operator">=</span> cur<span class="token punctuation">;</span>
				<span class="token comment">//改变链接关系</span>
				<span class="token comment">//如果要删除的是根节点</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> _root<span class="token punctuation">)</span> _root <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>
				<span class="token keyword">else</span> <span class="token comment">//非根节点</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-&gt;</span>_left <span class="token operator">==</span> cur<span class="token punctuation">)</span> parent<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>
					<span class="token keyword">else</span> parent<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">delete</span> DelNode<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_left <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token comment">//删除的节点只有右子树</span>
			<span class="token punctuation">{<!-- --></span>
				NodeType<span class="token operator">*</span> DelNode <span class="token operator">=</span> cur<span class="token punctuation">;</span>
				<span class="token comment">//改变链接关系</span>
				<span class="token comment">//如果要删除的是根节点</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> _root<span class="token punctuation">)</span> _root <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>
				<span class="token keyword">else</span> <span class="token comment">//非根节点</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-&gt;</span>_left <span class="token operator">==</span> cur<span class="token punctuation">)</span> parent<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>
					<span class="token keyword">else</span> parent<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">delete</span> DelNode<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span> <span class="token comment">//子节点都在</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token comment">//找替代 左子树的最大节点(最右节点) 右子树的最小节点(最左节点)</span>

				<span class="token comment">//去左子树中找最大节点</span>
				<span class="token comment">//NodeType* maxParent = cur;</span>
				<span class="token comment">//NodeType* maxLeft = cur-&gt;_left;</span>
				<span class="token comment">//while (maxLeft-&gt;_right)</span>
				<span class="token comment">//{<!-- --></span>
				<span class="token comment">//	maxParent = maxLeft;</span>
				<span class="token comment">//	maxLeft = maxLeft-&gt;_right;</span>
				<span class="token comment">//}</span>
				<span class="token comment">//cur-&gt;_key = maxLeft-&gt;_key;</span>
				<span class="token comment">接管替代节点的右孩子</span>
				<span class="token comment">//if (maxParent-&gt;_left == maxLeft) maxParent-&gt;_left = maxLeft-&gt;_left;</span>
				<span class="token comment">//else maxParent-&gt;_right = maxLeft-&gt;_left;</span>
				<span class="token comment">//delete maxLeft;</span>

				<span class="token comment">//去右子树中找最小节点</span>
				NodeType<span class="token operator">*</span> minParent <span class="token operator">=</span> cur<span class="token punctuation">;</span>
				NodeType<span class="token operator">*</span> minRight <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>
				<span class="token keyword">while</span> <span class="token punctuation">(</span>minRight<span class="token operator">-&gt;</span>_left<span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					minParent <span class="token operator">=</span> minRight<span class="token punctuation">;</span>
					minRight <span class="token operator">=</span> minRight<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				cur<span class="token operator">-&gt;</span>_key <span class="token operator">=</span> minRight<span class="token operator">-&gt;</span>_key<span class="token punctuation">;</span>
				<span class="token comment">//接管替代节点的右孩子</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>minParent<span class="token operator">-&gt;</span>_left <span class="token operator">==</span> minRight<span class="token punctuation">)</span> minParent<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> minRight<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>
				<span class="token keyword">else</span> minParent<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> minRight<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>
				<span class="token keyword">delete</span> minRight<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token operator">--</span>_size<span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">//找不到节点</span>
<span class="token punctuation">}</span>
</code></pre> 
 <p>将代码结合下图理解，就能知道这些情况到底在干什么了。<br> <br><br> <strong>被删节点只有左子树或右子树时：</strong><br> 我们只需要让被删节点的父节点托管子节点即可，即让爷爷节点接管孙子节点。<br> <img src="https://images2.imgbox.com/55/0b/UrC0Mfag_o.png" alt="">&gt;<mark>注意：如果被删节点是根节点，还需要特殊处理，修改根节点_root的值。</mark><br> <br></p> 
 <p><strong>被删节点左右子树都存在：</strong><br> 此时我们需要找一个替代节点来接管左右子树，接管节点必须保证接管后树的整体形态和性质不变。<br> <mark>于是我们可以选择左子树中的最大节点(maxLeft) 或 右子树中的最小节点(minRight)</mark>，两个节点中的其中一个，将该节点值覆盖被删节点的值转而删除该节点即可，该替代节点一定是叶子节点，可以转换为直接删除。<br> 因为 <mark>左子树的最大节点 小于和最接近 当前根节点 ，右子树中的最小节点大于和最接近</mark>。<br> 所以我们在删除节点前，需要寻找合适的替代节点来接管左右孩子，维护树的形态，在寻找合适节点时，需要 <mark>记录替代节点的前驱节点，在被删除后及时更新替代节点父节点的链接关系</mark>。<br> <img src="https://images2.imgbox.com/e0/ee/TNQuM8wv_o.png" alt=""><br> 这里我们并不是实际删除了11节点，而是采用<mark>伪删除法</mark>，替换节点值，转而删除替代节点。<br> 这里使用伪删除法，将问题转化为删除叶子节点，省去了很多麻烦！<br> <br><br> <strong>关于递归版删除函数</strong><br> 同样的，递归函数需要在内部单独实现，外部对递归函数重新封装。<br> 我们在插入函数中使用对节点地址的引用解决了很多问题，同样的，在删除函数中，我们也使用了对节点的引用，这样可以做到 在不同的栈帧中，删除同一个节点，而非临时变量，同时递归删除还用到了一种思想：转换问题的量级。<br> <br> 因为是对节点的引用，所以当我们遍历到被删节点时，先记录被删除节点的地址，因为是对节点的引用，则在节点数大于1的情况下，当前函数中的root节点地址必然是对某根节点的左子树节点或右子树节点的引用，我们对其做出修改会直接影响链接关系，如果被删节点只有左子树或右子树，直接将其左子树或右子树赋值给当前函数中root即可，然后删除记录的节点，如果被删节点左右子树都存在，则同样需要找左子树最大节点或右子树最小节点作为替代节点，因为节点值交换了，所以被删节点转换成了替代节点，所以继续调用递归删除替代节点即可。<br> <br> 实现代码(递归版)：</p> 
 <pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token function">RecuErase</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> key<span class="token punctuation">)</span> <span class="token comment">//递归删除-外部接口</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token function">_RecuErase</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> _root<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">bool</span> <span class="token function">_RecuErase</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> key<span class="token punctuation">,</span> NodeType<span class="token operator">*</span><span class="token operator">&amp;</span> root<span class="token punctuation">)</span> <span class="token comment">//递归删除-实际调用函数</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token comment">//节点值比key小，递归去右子树中寻找 否则去左子树中寻找</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_com</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> root<span class="token operator">-&gt;</span>_key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">_RecuErase</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> root<span class="token operator">-&gt;</span>_right<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_com</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_key<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">_RecuErase</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> root<span class="token operator">-&gt;</span>_left<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span> <span class="token comment">//找到了</span>
	<span class="token punctuation">{<!-- --></span>
		NodeType<span class="token operator">*</span> delNode <span class="token operator">=</span> root<span class="token punctuation">;</span> <span class="token comment">//记录要删除的节点</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_left <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> root <span class="token operator">=</span> root<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_right <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> root <span class="token operator">=</span> root<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>
		<span class="token keyword">else</span> <span class="token comment">//两个子节点都存在</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//找一个替代</span>
			<span class="token comment">//找左边的最大节点</span>
			NodeType<span class="token operator">*</span> cur <span class="token operator">=</span> root<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_right<span class="token punctuation">)</span> cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>

			<span class="token comment">//找右边的最小节点</span>
			<span class="token comment">//NodeType* cur = root-&gt;_right;</span>
			<span class="token comment">//while (cur-&gt;_left) cur = cur-&gt;_left;</span>

			<span class="token comment">//将要删除的值与替代节点交换</span>
			T tmp <span class="token operator">=</span> root<span class="token operator">-&gt;</span>_key<span class="token punctuation">;</span>
			root<span class="token operator">-&gt;</span>_key <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_key<span class="token punctuation">;</span>
			cur<span class="token operator">-&gt;</span>_key <span class="token operator">=</span> tmp<span class="token punctuation">;</span>

			<span class="token keyword">return</span> <span class="token function">_RecuErase</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> root<span class="token operator">-&gt;</span>_left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//转而删除子节点</span>
			<span class="token comment">//return _RecuErase(key, root-&gt;_right); //转而删除子节点</span>

		<span class="token punctuation">}</span>
		<span class="token keyword">delete</span> delNode<span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
 <br> 
 <blockquote> 
  <p><strong>关于删除需要注意的：</strong></p> 
  <ul><li>涉及更改链接关系的操作，都需要保存父节点的信息</li><li>左右子树都为空时，表示删除根节点root，此时 parent 为空，不必更改父节点链接关系，更新根节点root的信息后，删除目标节点即可，这种情况需要特殊处理。</li><li>左右子树都不为空时，parent 要初始化为 cur，避免后面的野指针或空指针的问题。<br> </li></ul> 
 </blockquote> 
 <p>删除函数细节比较多，需要结合代码多多理解！<br> 关于搜索二叉树的删除函数，还有一道题，大家可以尝试：<strong><a href="https://leetcode.cn/problems/delete-node-in-a-bst/" rel="nofollow">删除二叉搜索树中的节点</a></strong></p> 
 <hr> 
 <h4><a id="_354"></a>查找函数</h4> 
 <p>查找函数相对比较简单，一个变量cur向下遍历即可。</p> 
 <blockquote> 
  <p><strong>步骤</strong></p> 
  <ul><li>当cur节点值小于key时cur走向右子树，大于则走向左子树</li><li>当cur遍历到值为key的节点时返回true</li><li>当根节点root或cur遍历到nullptr时，表示树中不存在该节点，返回false<br> </li></ul> 
 </blockquote> 
 <p>实现代码(迭代版)：</p> 
 <pre><code class="prism language-cpp">		<span class="token keyword">bool</span> <span class="token function">Find</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> key<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>_root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

			NodeType<span class="token operator">*</span> cur <span class="token operator">=</span> _root<span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_com</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> cur<span class="token operator">-&gt;</span>_key<span class="token punctuation">)</span><span class="token punctuation">)</span> cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>
				<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_com</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_key<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>
				<span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
</code></pre> 
 <p><img src="https://images2.imgbox.com/07/16/Q9BcfdWc_o.png" alt=""></p> 
 <p><strong>关于递归版查找函数</strong><br> 递归版查找函数也需要实现一个内部的递归函数，然后使用外部调用接口封装。<br> 同样的，查找节点也有递归版本，其实现比较简单，当root小于key时递归遍历其右子树，大于则遍历其左子树，等于时返回true，root为nullptr时，返回false。</p> 
 <p>实现代码(递归版)：</p> 
 <pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token function">RecuFind</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> key<span class="token punctuation">)</span> <span class="token comment">//删除函数-外部接口</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token function">_RecuFind</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> _root<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">bool</span> <span class="token function">_RecuFind</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> key<span class="token punctuation">,</span> NodeType<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token comment">//删除函数-实际调用函数</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_com</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> root<span class="token operator">-&gt;</span>_key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">_RecuFind</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> root<span class="token operator">-&gt;</span>_right<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_com</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_key<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">_RecuFind</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> root<span class="token operator">-&gt;</span>_left<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
 <hr> 
 <h4><a id="_405"></a>中序遍历函数</h4> 
 <p>中序遍历函数会变遍历边打印，最终打印出的节点序列成有序。<br> 这个函数比较简单，我们在第一次接触二叉树时就已经接触到了，但是因为我们需要递归，所有需要在内部实现一个递归函数，使用外部接口调用即可。</p> 
 <pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">MidBfd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//中序遍历-外部接口</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">_MidBfd</span><span class="token punctuation">(</span>_root<span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">_MidBfd</span><span class="token punctuation">(</span>NodeType<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token comment">//中序遍历-实际调用函数</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>

	<span class="token function">_MidBfd</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_left<span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> root<span class="token operator">-&gt;</span>_key <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
	<span class="token function">_MidBfd</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
 <p><img src="https://images2.imgbox.com/69/fb/1rVzLKXB_o.png" alt=""><br> 乱序插入后，中序遍历打印有序。</p> 
 <hr> 
 <h4><a id="_429"></a>析构函数和销毁函数(后序遍历销毁)</h4> 
 <p>销毁一棵二叉树，我们需要先销毁子树再销毁根节点，那么后序遍历再合适不过了。<br> 因为销毁函数需要后序遍历，递归销毁，所以我们需要单独封装一个带节点指针参数的递归函数来销毁树。<br> 当析构函数在析构时调用销毁函数后置空根节点指针即可！</p> 
 <pre><code class="prism language-cpp"><span class="token operator">~</span><span class="token function">BSTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//析构函数</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">Destroy</span><span class="token punctuation">(</span>_root<span class="token punctuation">)</span><span class="token punctuation">;</span>
	_root <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">Destroy</span><span class="token punctuation">(</span>NodeType<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token comment">//后序销毁</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>

	<span class="token function">Destroy</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_left<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">Destroy</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_right<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">delete</span> root<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
 <hr> 
 <h4><a id="_452"></a>拷贝构造和赋值重载(前序遍历创建)</h4> 
 <p>编译器默认的拷贝构造默认是浅拷贝，当浅拷贝根节点指针后销毁时便会出现异常。<br> <br> <strong>递归拷贝函数：</strong> 所以我们必须实现一个可以拷贝一棵树且返回根节点地址的函数，这个函数我们采用前序遍历，前序遍历一棵树，每遍历一个节点就创建一个节点然后递归创建其左子树和右子树，最后返回根节点地址。<br> <br> <strong>拷贝构造函数</strong>：我们只需要调用拷贝函数拷贝另一棵树然后将根节点地址赋值给本对象的_root即可(实现了拷贝构造函数就必须实现一个默认构造函数)。<br> <br> <strong>赋值重载函数</strong>：我们重新赋值一棵树时需要先销毁当前对象的树，再调用拷贝函数拷贝这棵树，不过这样做显得很繁琐。我们可以将<code>赋值重载函数参数改为传值传参</code>，这样传值传参会调用拷贝构造拷贝一棵临时的树，然后我们调用swap将我们需要赋值树的节点地址交换，就完成了，当函数执行完成，临时变量会调用析构函数销毁树，因为我们把原来的树交换给了临时变量对象，所以临时变量会帮我们销毁而不需要我们自己销毁，这样就节省了我们的操作步骤。<br> <br></p> 
 <p>实现代码：</p> 
 <pre><code class="prism language-cpp"><span class="token function">BSTree</span><span class="token punctuation">(</span><span class="token keyword">const</span> TreeType<span class="token operator">&amp;</span> bst<span class="token punctuation">)</span> <span class="token comment">//拷贝构造</span>
	<span class="token operator">:</span><span class="token function">_root</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
	<span class="token punctuation">,</span> <span class="token function">_size</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	_root <span class="token operator">=</span> <span class="token function">Copy</span><span class="token punctuation">(</span>bst<span class="token punctuation">.</span>_root<span class="token punctuation">)</span><span class="token punctuation">;</span>
	_size <span class="token operator">=</span> bst<span class="token punctuation">.</span>_size<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

TreeType<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>TreeType bst<span class="token punctuation">)</span> <span class="token comment">//赋值重载</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">swap</span><span class="token punctuation">(</span>bst<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//我们自己实现的交换函数</span>
	<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

NodeType<span class="token operator">*</span> <span class="token function">Copy</span><span class="token punctuation">(</span><span class="token keyword">const</span> NodeType<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token comment">//前序拷贝一棵树</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>

	NodeType<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">NodeType</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_key<span class="token punctuation">)</span><span class="token punctuation">;</span>

	newnode<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> <span class="token function">Copy</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_left<span class="token punctuation">)</span><span class="token punctuation">;</span>
	newnode<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> <span class="token function">Copy</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_right<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> newnode<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
 <hr> 
 <h4><a id="_490"></a>其他函数</h4> 
 <p>剩下的函数是比较简单的基础函数：</p> 
 <ul><li>获取节点数量</li><li>交换函数</li><li>清空节点</li></ul> 
 <br> 
 <pre><code class="prism language-cpp">size_t <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> _size<span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>TreeType<span class="token operator">&amp;</span> bst<span class="token punctuation">)</span> <span class="token comment">//交换函数</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//也可以调用库中的swap</span>
	NodeType<span class="token operator">*</span> root <span class="token operator">=</span> bst<span class="token punctuation">.</span>_root<span class="token punctuation">;</span>
	bst<span class="token punctuation">.</span>_root <span class="token operator">=</span> _root<span class="token punctuation">;</span>
	_root <span class="token operator">=</span> root<span class="token punctuation">;</span>

	Com com <span class="token operator">=</span> bst<span class="token punctuation">.</span>_com<span class="token punctuation">;</span>
	bst<span class="token punctuation">.</span>_com <span class="token operator">=</span> _com<span class="token punctuation">;</span>
	_com <span class="token operator">=</span> com<span class="token punctuation">;</span>

	size_t sz <span class="token operator">=</span> bst<span class="token punctuation">.</span>_size<span class="token punctuation">;</span>
	bst<span class="token punctuation">.</span>_size <span class="token operator">=</span> _size<span class="token punctuation">;</span>
	_size <span class="token operator">=</span> sz<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//清空节点</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">Destroy</span><span class="token punctuation">(</span>_root<span class="token punctuation">)</span><span class="token punctuation">;</span>
	_root <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
</blockquote> 
<hr> 
<blockquote> 
 <h3><a id="_525"></a>二叉搜索树的应用场景</h3> 
 <hr> 
 <p>二叉搜索树凭借着极快的查找速度，有着一定的实战价值，常用的查找模型是 <code>key查找模型</code>和 <code>key / value 查找模型</code> 及 存储模型。</p> 
 <hr> 
 <h4><a id="key_531"></a>key模型</h4> 
 <p>key模型其实就是我们上面实现的树，节点中只有一个值，<strong>一般适用于在集合中查找某个参数在不在</strong>！<br> <br> 应用场景：</p> 
 <ul><li>门禁系统</li><li>单词拼写检查</li><li>. . . . . .<br> <br></li></ul> 
 <pre><code class="prism language-cpp"><span class="token comment">//简易字典</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	BSTree<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> bst<span class="token punctuation">;</span>
	bst<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span><span class="token string">"中国"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	bst<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span><span class="token string">"CSDN"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	bst<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span><span class="token string">"BIT"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	bst<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span><span class="token string">"C++"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	bst<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span><span class="token string">"668"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		string tmp<span class="token punctuation">;</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"请输入&gt;&gt;&gt; "</span><span class="token punctuation">;</span>
		cin <span class="token operator">&gt;&gt;</span> tmp<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>bst<span class="token punctuation">.</span><span class="token function">Find</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"在词典中"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token keyword">else</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"不在词典中"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
'<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre> 
 <p><img src="https://images2.imgbox.com/78/bb/JJSZsCqA_o.png" alt=""><br> 单值key的意义本身就是判断在不在，判断在不在也需要查找，二叉搜索树比较合适。</p> 
 <hr> 
 <h4><a id="keyvalue_568"></a>key-value模型</h4> 
 <p>key-value模型需要存储两个值，其中用来对比(插入删除的依据)的是key，同时存储value (仅存储，value没用任何其他意义) 建立key-value的映射关系，这是一种典型的哈希思想。<br> <br><br> 应用场景：</p> 
 <ul><li>电话号码查询快递信息</li><li>词典互译</li><li>. . . . . .<br> <br></li></ul> 
 <p>我们将key模型的代码微微改动就可以实现key-value模型的二叉搜索树。<br> 这里我们简单实现一下。</p> 
 <pre><code class="prism language-cpp"><span class="token comment">//二叉搜索树KV</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">KT</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">VT</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Com</span> <span class="token operator">=</span> Compare<span class="token operator">&lt;</span>KT<span class="token operator">&gt;&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">KVBSTree</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">using</span> NodeType <span class="token operator">=</span> TreeNode<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span>KT<span class="token punctuation">,</span> VT<span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span>
	<span class="token keyword">using</span> TreeType <span class="token operator">=</span> KVBSTree<span class="token operator">&lt;</span>KT<span class="token punctuation">,</span> VT<span class="token punctuation">,</span> Com<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">KVBSTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_root</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_size</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

	<span class="token function">KVBSTree</span><span class="token punctuation">(</span><span class="token keyword">const</span> TreeType<span class="token operator">&amp;</span> bst<span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_root</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_size</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		_root <span class="token operator">=</span> <span class="token function">Copy</span><span class="token punctuation">(</span>bst<span class="token punctuation">.</span>_root<span class="token punctuation">)</span><span class="token punctuation">;</span>
		_size <span class="token operator">=</span> bst<span class="token punctuation">.</span>_size<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	TreeType<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>TreeType bst<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">swap</span><span class="token punctuation">(</span>bst<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//我们自己实现的交换函数</span>
		<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">bool</span> <span class="token function">Insert</span><span class="token punctuation">(</span><span class="token keyword">const</span> KT<span class="token operator">&amp;</span> key<span class="token punctuation">,</span> <span class="token keyword">const</span> VT<span class="token operator">&amp;</span> value<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>_root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			NodeType<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">NodeType</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span> key<span class="token punctuation">,</span>value <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			_root <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
			_size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		NodeType<span class="token operator">*</span> parent <span class="token operator">=</span> _root<span class="token punctuation">;</span>
		NodeType<span class="token operator">*</span> cur <span class="token operator">=</span> _root<span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			parent <span class="token operator">=</span> cur<span class="token punctuation">;</span>
			<span class="token comment">//节点值小于key</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_com</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> cur<span class="token operator">-&gt;</span>_key<span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span> cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>
			<span class="token comment">//节点值大于key</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_com</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_key<span class="token punctuation">.</span>first<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>
			<span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		NodeType<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">NodeType</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span> key<span class="token punctuation">,</span>value <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_com</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> parent<span class="token operator">-&gt;</span>_key<span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span> parent<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
		<span class="token keyword">else</span> parent<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> newnode<span class="token punctuation">;</span>

		<span class="token operator">++</span>_size<span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">bool</span> <span class="token function">Erase</span><span class="token punctuation">(</span><span class="token keyword">const</span> KT<span class="token operator">&amp;</span> key<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>_root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

		<span class="token comment">//删除节点</span>
		NodeType<span class="token operator">*</span> parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
		NodeType<span class="token operator">*</span> cur <span class="token operator">=</span> _root<span class="token punctuation">;</span>
		<span class="token comment">//找节点</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//节点值小于key</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_com</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> cur<span class="token operator">-&gt;</span>_key<span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				parent <span class="token operator">=</span> cur<span class="token punctuation">;</span>
				cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token comment">//节点值大于key</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_com</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_key<span class="token punctuation">.</span>first<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				parent <span class="token operator">=</span> cur<span class="token punctuation">;</span>
				cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span> <span class="token comment">//找到了 开始删除</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_right <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token comment">//删除的节点只有左子树</span>
				<span class="token punctuation">{<!-- --></span>
					NodeType<span class="token operator">*</span> DelNode <span class="token operator">=</span> cur<span class="token punctuation">;</span>
					<span class="token comment">//改变链接关系</span>
					<span class="token comment">//如果要删除的是根节点</span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> _root<span class="token punctuation">)</span> _root <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>
					<span class="token keyword">else</span> <span class="token comment">//非根节点</span>
					<span class="token punctuation">{<!-- --></span>
						<span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-&gt;</span>_left <span class="token operator">==</span> cur<span class="token punctuation">)</span> parent<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>
						<span class="token keyword">else</span> parent<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
					<span class="token keyword">delete</span> DelNode<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_left <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token comment">//删除的节点只有右子树</span>
				<span class="token punctuation">{<!-- --></span>
					NodeType<span class="token operator">*</span> DelNode <span class="token operator">=</span> cur<span class="token punctuation">;</span>
					<span class="token comment">//改变链接关系</span>
					<span class="token comment">//如果要删除的是根节点</span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> _root<span class="token punctuation">)</span> _root <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>
					<span class="token keyword">else</span> <span class="token comment">//非根节点</span>
					<span class="token punctuation">{<!-- --></span>
						<span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-&gt;</span>_left <span class="token operator">==</span> cur<span class="token punctuation">)</span> parent<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>
						<span class="token keyword">else</span> parent<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
					<span class="token keyword">delete</span> DelNode<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">else</span> <span class="token comment">//子节点都在</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token comment">//找替代 左子树的最大节点(最右节点) 右子树的最小节点(最左节点)</span>
					<span class="token comment">//去左子树中找最大节点</span>
					<span class="token comment">//NodeType* maxParent = cur;</span>
					<span class="token comment">//NodeType* maxLeft = cur-&gt;_left;</span>
					<span class="token comment">//while (maxLeft-&gt;_right)</span>
					<span class="token comment">//{<!-- --></span>
					<span class="token comment">//	maxParent = maxLeft;</span>
					<span class="token comment">//	maxLeft = maxLeft-&gt;_right;</span>
					<span class="token comment">//}</span>
					<span class="token comment">//cur-&gt;_key = maxLeft-&gt;_key;</span>
					<span class="token comment">接管替代节点的右孩子</span>
					<span class="token comment">//if (maxParent-&gt;_left == maxLeft) maxParent-&gt;_left = maxLeft-&gt;_left;</span>
					<span class="token comment">//else maxParent-&gt;_right = maxLeft-&gt;_left;</span>
					<span class="token comment">//delete maxLeft;</span>

					<span class="token comment">//去右子树中找最小节点</span>
					NodeType<span class="token operator">*</span> minParent <span class="token operator">=</span> cur<span class="token punctuation">;</span>
					NodeType<span class="token operator">*</span> minRight <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>
					<span class="token keyword">while</span> <span class="token punctuation">(</span>minRight<span class="token operator">-&gt;</span>_left<span class="token punctuation">)</span>
					<span class="token punctuation">{<!-- --></span>
						minParent <span class="token operator">=</span> minRight<span class="token punctuation">;</span>
						minRight <span class="token operator">=</span> minRight<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
					cur<span class="token operator">-&gt;</span>_key <span class="token operator">=</span> minRight<span class="token operator">-&gt;</span>_key<span class="token punctuation">;</span>
					<span class="token comment">//接管替代节点的右孩子</span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span>minParent<span class="token operator">-&gt;</span>_left <span class="token operator">==</span> minRight<span class="token punctuation">)</span> minParent<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> minRight<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>
					<span class="token keyword">else</span> minParent<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> minRight<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>
					<span class="token keyword">delete</span> minRight<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token operator">--</span>_size<span class="token punctuation">;</span>
				<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">//找不到节点</span>
	<span class="token punctuation">}</span>

	pair<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span>KT<span class="token punctuation">,</span> VT<span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">&gt;</span> <span class="token function">Find</span><span class="token punctuation">(</span><span class="token keyword">const</span> KT<span class="token operator">&amp;</span> key<span class="token punctuation">)</span> <span class="token comment">//key-value模型 通过key找value</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//这里使用pair再套一层pair，用于返回查询的结果是否有效</span>
		<span class="token comment">//false表示查询返回值无效</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>_root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

		NodeType<span class="token operator">*</span> cur <span class="token operator">=</span> _root<span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_com</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> cur<span class="token operator">-&gt;</span>_key<span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span> cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_com</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_key<span class="token punctuation">.</span>first<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>
			<span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span> cur<span class="token operator">-&gt;</span>_key<span class="token punctuation">,</span><span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	size_t <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> _size<span class="token punctuation">;</span> <span class="token punctuation">}</span>

	<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>TreeType<span class="token operator">&amp;</span> bst<span class="token punctuation">)</span> <span class="token comment">//交换函数</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//也可以调用库中的swap</span>
		NodeType<span class="token operator">*</span> root <span class="token operator">=</span> bst<span class="token punctuation">.</span>_root<span class="token punctuation">;</span>
		bst<span class="token punctuation">.</span>_root <span class="token operator">=</span> _root<span class="token punctuation">;</span>
		_root <span class="token operator">=</span> root<span class="token punctuation">;</span>

		Com com <span class="token operator">=</span> bst<span class="token punctuation">.</span>_com<span class="token punctuation">;</span>
		bst<span class="token punctuation">.</span>_com <span class="token operator">=</span> _com<span class="token punctuation">;</span>
		_com <span class="token operator">=</span> com<span class="token punctuation">;</span>

		size_t sz <span class="token operator">=</span> bst<span class="token punctuation">.</span>_size<span class="token punctuation">;</span>
		bst<span class="token punctuation">.</span>_size <span class="token operator">=</span> _size<span class="token punctuation">;</span>
		_size <span class="token operator">=</span> sz<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//清空节点</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">Destroy</span><span class="token punctuation">(</span>_root<span class="token punctuation">)</span><span class="token punctuation">;</span>
		_root <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//中序遍历打印</span>
	<span class="token keyword">void</span> <span class="token function">MidBfd</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">_MidBfd</span><span class="token punctuation">(</span>_root<span class="token punctuation">)</span><span class="token punctuation">;</span>
		cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token operator">~</span><span class="token function">KVBSTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">Destroy</span><span class="token punctuation">(</span>_root<span class="token punctuation">)</span><span class="token punctuation">;</span>
		_root <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token comment">//前序拷贝一棵树</span>
	NodeType<span class="token operator">*</span> <span class="token function">Copy</span><span class="token punctuation">(</span><span class="token keyword">const</span> NodeType<span class="token operator">*</span> root<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>

		NodeType<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">NodeType</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_key<span class="token punctuation">)</span><span class="token punctuation">;</span>

		newnode<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> <span class="token function">Copy</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_left<span class="token punctuation">)</span><span class="token punctuation">;</span>
		newnode<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> <span class="token function">Copy</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_right<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> newnode<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//中序</span>
	<span class="token keyword">void</span> <span class="token function">_MidBfd</span><span class="token punctuation">(</span>NodeType<span class="token operator">*</span> root<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>

		<span class="token function">_MidBfd</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_left<span class="token punctuation">)</span><span class="token punctuation">;</span>
		cout <span class="token operator">&lt;&lt;</span> root<span class="token operator">-&gt;</span>_key<span class="token punctuation">.</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">" : "</span> <span class="token operator">&lt;&lt;</span> root<span class="token operator">-&gt;</span>_key<span class="token punctuation">.</span>second <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token function">_MidBfd</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_right<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//后序销毁</span>
	<span class="token keyword">void</span> <span class="token function">Destroy</span><span class="token punctuation">(</span>NodeType<span class="token operator">*</span> root<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>

		<span class="token function">Destroy</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_left<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">Destroy</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_right<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">delete</span> root<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	NodeType<span class="token operator">*</span> _root<span class="token punctuation">;</span> <span class="token comment">//根节点</span>
	size_t _size<span class="token punctuation">;</span>       <span class="token comment">//节点数量</span>
	Com _com<span class="token punctuation">;</span>        <span class="token comment">//比较函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
 <br> 
 <blockquote> 
  <p><strong>关于pair：</strong><br> pair是C++自带的一个用于存储key-value的对象。<br> <img src="https://images2.imgbox.com/66/24/Pj3Df3oh_o.png" alt=""><br> 还有一个函数make_pair，传递两个参数(key / value)，快速构建pair对象。</p> 
 </blockquote> 
 <br> 
 <p><strong>简易词典：</strong></p> 
 <pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span> 
	KVBSTree<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> string<span class="token operator">&gt;</span> bst<span class="token punctuation">;</span>
	bst<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span><span class="token string">"china"</span><span class="token punctuation">,</span> <span class="token string">"中国"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	bst<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span><span class="token string">"fruit"</span><span class="token punctuation">,</span> <span class="token string">"水果"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	bst<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span><span class="token string">"god"</span><span class="token punctuation">,</span> <span class="token string">"神"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	bst<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span><span class="token string">"great"</span><span class="token punctuation">,</span> <span class="token string">"伟大"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	bst<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span><span class="token string">"blue"</span><span class="token punctuation">,</span> <span class="token string">"蓝色"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		string str<span class="token punctuation">;</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"请输入&gt;&gt;&gt; "</span><span class="token punctuation">;</span>
		cin <span class="token operator">&gt;&gt;</span> str<span class="token punctuation">;</span>
		<span class="token keyword">auto</span> ret <span class="token operator">=</span> bst<span class="token punctuation">.</span><span class="token function">Find</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>ret<span class="token punctuation">.</span>second<span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> ret<span class="token punctuation">.</span>first<span class="token punctuation">.</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">" : "</span> <span class="token operator">&lt;&lt;</span> ret<span class="token punctuation">.</span>first<span class="token punctuation">.</span>second <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token keyword">else</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"词典中没有该词!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre> 
 <p><img src="https://images2.imgbox.com/0b/3e/jB1q2LBr_o.png" alt=""></p> 
</blockquote> 
<hr> 
<blockquote> 
 <h3><a id="_854"></a>关于二叉搜索树</h3> 
 <hr> 
 <p>本章介绍了最基本的二叉搜索树，因为其左右性质，其查找速度很快。<br> <br> 关于二叉搜索树的时间复杂度：最快 O(logn)，最慢 O(n)<br> <br> 我们仔细分析可以发现，当二叉搜索树插入有序序列时，会变成链表！<br> <img src="https://images2.imgbox.com/d4/37/CnwSGuXr_o.png" alt=""><br> 当二叉搜索树的高度等于节点数，则查找速度就是O(n)<br> 为了解决这个问题，大佬们发明了 <code>AVL树</code> 和 <code>红黑树</code> 等，降低二叉搜索树的高度，以加速查找。<br> <img src="https://images2.imgbox.com/de/f7/KOQBrnXf_o.png" alt=""><br> AVL树 和 红黑树 的时间复杂度近似为：O(logn)<br> 后面我们将详细介绍！</p> 
</blockquote> 
<hr> 
<h2><a id="_869"></a>最后</h2> 
<p><strong>本节我们介绍了二叉搜索树，讲解了二叉搜索树的相关概念，为后面AVL树和红黑树的学习做铺垫，本节我们只是实现了最基本的代码，在AVL树和红黑树中，我们将实现更多功能，来完善我们的二叉搜索树。</strong></p> 
<p><strong>本次 &lt;二叉搜索树&gt; 就先介绍到这里啦，希望能够尽可能帮助到大家。</strong></p> 
<p><strong>如果文章中有瑕疵，还请各位大佬细心点评和留言，我将立即修补错误，谢谢！</strong></p> 
<p><strong>本节涉及代码：<a href="https://gitee.com/armcskgt/c-and---c-code-warehouse/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E5%92%8C%E5%AE%9E%E7%8E%B0/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84STL/BinarySearchTree%E5%8F%8AAVL%E5%8F%8ARB/%E9%AB%98%E9%98%B6%E6%A0%91%E5%8D%9A%E5%AE%A2/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.hpp" rel="nofollow">二叉搜索树博客代码</a></strong></p> 
<p><img src="https://images2.imgbox.com/ed/88/QqgFkfTD_o.png" alt=""></p> 
<blockquote> 
 <p><em></em></p> 
 <center> 
  <strong>🌟其他文章阅读推荐🌟<br> <a href="https://blog.csdn.net/m0_73446322/article/details/128394450">数据结构初级＜二叉树＞</a><br> <a href="https://blog.csdn.net/m0_73446322/article/details/131281127">C++ &lt;继承&gt;</a><br> <a href="https://blog.csdn.net/m0_73446322/article/details/131235312">C++ &lt;STL容器适配器&gt;</a><br> <a href="https://blog.csdn.net/m0_73446322/article/details/134514227">Linux进程间通信</a><br> <a href="https://blog.csdn.net/m0_73446322/article/details/131114060">Linux软硬链接和动静态库</a><br> 🌹欢迎读者多多浏览多多支持!🌹</strong> 
 </center> 
 <p></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9ed1c69fbfbf71b9ca01d81033e7be43/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Oracle中decode函数详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1e426fd0589bc66f1da6327e4e7c1cc5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue前端上传图片到阿里云OSS，超详细上传图片与视频教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>