<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java 并发集合：CopyOnWrite 写时复制集合介绍 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/0970b35ee47605f2bc6834ce81414677/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java 并发集合：CopyOnWrite 写时复制集合介绍">
  <meta property="og:description" content="大家好，我是栗筝i，这篇文章是我的 “栗筝i 的 Java 技术栈” 专栏的第 016 篇文章，在 “栗筝i 的 Java 技术栈” 这个专栏中我会持续为大家更新 Java 技术相关全套技术栈内容。专栏的主要目标是已经有一定 Java 开发经验，并希望进一步完善自己对整个 Java 技术体系来充实自己的技术栈的同学。与此同时，本专栏的所有文章，也都会准备充足的代码示例和完善的知识点梳理，因此也十分适合零基础的小白和要准备工作面试的同学学习。当然，我也会在必要的时候进行相关技术深度的技术解读，相信即使是拥有多年 Java 开发经验的从业者和大佬们也会有所收获并找到乐趣。
–
Java 集合框架（Java Collections Framework）为开发者提供了一套强大且灵活的数据结构和算法工具，使得数据管理和操作变得更加高效和简洁。在多线程环境中，如何在保证线程安全的同时，保持集合操作的高效性，成为了一个至关重要的课题。为此，Java 提供了一系列并发集合类，其中 CopyOnWrite 系列集合因其独特的“写时复制”机制，成为了解决并发读写问题的一种有效方案。
CopyOnWrite 集合类主要包括 CopyOnWriteArrayList 和 CopyOnWriteArraySet。它们通过在每次修改集合时创建一个新副本，从而保证了读操作的无锁化，这种设计极大地提高了读操作的性能，同时也简化了开发者的使用难度。然而，写时复制的特性也带来了一定的内存开销和写操作的性能代价。因此，了解其工作原理和适用场景，对于我们在实际开发中选择合适的集合类至关重要。
在本文中，我们将深入探讨 CopyOnWrite 集合的实现原理、优缺点以及适用场景，帮助读者全面理解和正确使用这些集合类。无论是编写高性能的多线程应用程序，还是解决复杂的并发数据访问问题，掌握 CopyOnWrite 集合的使用技巧，都将为您的开发工作带来极大的助益。
文章目录 1、写时复制的介绍2、写时复制的实现2.1、CopyOnWriteArrayList 数据结构2.2、CopyOnWriteArrayList 读操作2.2、CopyOnWriteArrayList 写时复制2.2.1、add() 函数2.2.2、remove() 函数2.2.3、set() 函数 2.3、CopyOnWriteArraySet 的实现 3、写实复制的特性3.1、读多写少3.2、弱一致性3.3、连续存储3.3.1、数组容器3.3.3、非数组容器 1、写时复制的介绍 写时复制（Copy-on-Write，简称COW）是一种计算机程序设计领域的优化策略。
其核心思想是：如果有多个调用者同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这一过程对其他的调用者都是透明的。
当对容器进行写操作（这里的写可以理解为 “增、删、改”）时，为了避免读写操作同时进行而导致的线程安全问题
我们将原始容器中的数据复制一份放入新创建的容器，然后对新创建的容器进行写操作；而读操作继续在原始容器上进行，这样读写操作之间便不会存在数据访问冲突，也就不存在线程安全问题
当写操作执行完成之后，新创建的容器替代原始容器，原始容器便废弃。 写时复制的主要优点是，如果调用者没有修改该资源，就不会有副本被创建，因此多个调用者只是进行读取操作时可以共享同一份资源。这种策略不仅优化了内存使用，还保护了数据，因为在写操作之前，原始数据不会被覆盖或修改，从而避免了数据丢失的风险。
在 Java 中，CopyOnWriteArrayList 和 CopyOnWriteArraySet 就是使用了这种策略的两个类。这两个类都位于java.util.concurrent 包下，是线程安全的集合类。当需要修改集合中的元素时，它们不会直接在原集合上进行修改，而是复制一份新的集合，然后在新的集合上进行修改。修改完成后，再将指向原集合的引用指向新的集合。这种设计使得读操作可以在不加锁的情况下进行，从而提高了并发性能。
总的来说，写时复制是一种适用于读多写少场景的优化策略，它通过复制数据的方式实现了读写分离，提高了并发性能。但是，它也存在一些潜在的性能问题，如内存占用增加、写操作性能下降以及频繁的垃圾回收。因此，在使用时需要根据具体场景进行权衡和选择。
2、写时复制的实现 2.1、CopyOnWriteArrayList 数据结构 CopyOnWriteArrayList 是 Java 中的一种线程安全的 List 实现，它通过每次写操作时复制底层数组来保证线程安全。CopyOnWriteArrayList 跟 ArrayList 一样，也实现了 List 接口：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-02T14:03:23+08:00">
    <meta property="article:modified_time" content="2024-07-02T14:03:23+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java 并发集合：CopyOnWrite 写时复制集合介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>大家好，我是栗筝i，这篇文章是我的 “栗筝i 的 Java 技术栈” 专栏的第 016 篇文章，在 “栗筝i 的 Java 技术栈” 这个专栏中我会持续为大家更新 Java 技术相关全套技术栈内容。专栏的主要目标是已经有一定 Java 开发经验，并希望进一步完善自己对整个 Java 技术体系来充实自己的技术栈的同学。与此同时，本专栏的所有文章，也都会准备充足的代码示例和完善的知识点梳理，因此也十分适合零基础的小白和要准备工作面试的同学学习。当然，我也会在必要的时候进行相关技术深度的技术解读，相信即使是拥有多年 Java 开发经验的从业者和大佬们也会有所收获并找到乐趣。</p> 
 <p>–</p> 
 <p>Java 集合框架（Java Collections Framework）为开发者提供了一套强大且灵活的数据结构和算法工具，使得数据管理和操作变得更加高效和简洁。在多线程环境中，如何在保证线程安全的同时，保持集合操作的高效性，成为了一个至关重要的课题。为此，Java 提供了一系列并发集合类，其中 <code>CopyOnWrite</code> 系列集合因其独特的“写时复制”机制，成为了解决并发读写问题的一种有效方案。</p> 
 <p><code>CopyOnWrite</code> 集合类主要包括 <code>CopyOnWriteArrayList</code> 和 <code>CopyOnWriteArraySet</code>。它们通过在每次修改集合时创建一个新副本，从而保证了读操作的无锁化，这种设计极大地提高了读操作的性能，同时也简化了开发者的使用难度。然而，写时复制的特性也带来了一定的内存开销和写操作的性能代价。因此，了解其工作原理和适用场景，对于我们在实际开发中选择合适的集合类至关重要。</p> 
 <p>在本文中，我们将深入探讨 <code>CopyOnWrite</code> 集合的实现原理、优缺点以及适用场景，帮助读者全面理解和正确使用这些集合类。无论是编写高性能的多线程应用程序，还是解决复杂的并发数据访问问题，掌握 <code>CopyOnWrite</code> 集合的使用技巧，都将为您的开发工作带来极大的助益。</p> 
</blockquote> 
<hr> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><ul><li><a href="#1_18" rel="nofollow">1、写时复制的介绍</a></li><li><a href="#2_39" rel="nofollow">2、写时复制的实现</a></li><li><ul><li><a href="#21CopyOnWriteArrayList__41" rel="nofollow">2.1、CopyOnWriteArrayList 数据结构</a></li><li><a href="#22CopyOnWriteArrayList__66" rel="nofollow">2.2、CopyOnWriteArrayList 读操作</a></li><li><a href="#22CopyOnWriteArrayList__78" rel="nofollow">2.2、CopyOnWriteArrayList 写时复制</a></li><li><ul><li><a href="#221add__82" rel="nofollow">2.2.1、add() 函数</a></li><li><a href="#222remove__113" rel="nofollow">2.2.2、remove() 函数</a></li><li><a href="#223set__153" rel="nofollow">2.2.3、set() 函数</a></li></ul> 
     </li><li><a href="#23CopyOnWriteArraySet__187" rel="nofollow">2.3、CopyOnWriteArraySet 的实现</a></li></ul> 
    </li><li><a href="#3_225" rel="nofollow">3、写实复制的特性</a></li><li><ul><li><a href="#31_227" rel="nofollow">3.1、读多写少</a></li><li><a href="#32_261" rel="nofollow">3.2、弱一致性</a></li><li><a href="#33_354" rel="nofollow">3.3、连续存储</a></li><li><ul><li><a href="#331_358" rel="nofollow">3.3.1、数组容器</a></li><li><a href="#333_372" rel="nofollow">3.3.3、非数组容器</a></li></ul> 
    </li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h4><a id="1_18"></a>1、写时复制的介绍</h4> 
<p>写时复制（Copy-on-Write，简称COW）是一种计算机程序设计领域的优化策略。</p> 
<p>其核心思想是：如果有多个调用者同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这一过程对其他的调用者都是透明的。</p> 
<ul><li>当对容器进行写操作（这里的写可以理解为 “增、删、改”）时，为了避免读写操作同时进行而导致的线程安全问题<br> 我们将原始容器中的数据复制一份放入新创建的容器，然后对新创建的容器进行写操作；</li><li>而读操作继续在原始容器上进行，这样读写操作之间便不会存在数据访问冲突，也就不存在线程安全问题<br> 当写操作执行完成之后，新创建的容器替代原始容器，原始容器便废弃。</li></ul> 
<p>写时复制的主要优点是，如果调用者没有修改该资源，就不会有副本被创建，因此多个调用者只是进行读取操作时可以共享同一份资源。这种策略不仅优化了内存使用，还保护了数据，因为在写操作之前，原始数据不会被覆盖或修改，从而避免了数据丢失的风险。</p> 
<p><img src="https://images2.imgbox.com/d1/07/7KbvK3US_o.png" alt="image-20240618144643159"></p> 
<p>在 Java 中，<code>CopyOnWriteArrayList</code> 和 <code>CopyOnWriteArraySet</code> 就是使用了这种策略的两个类。这两个类都位于<code>java.util.concurrent</code> 包下，是线程安全的集合类。当需要修改集合中的元素时，它们不会直接在原集合上进行修改，而是复制一份新的集合，然后在新的集合上进行修改。修改完成后，再将指向原集合的引用指向新的集合。这种设计使得读操作可以在不加锁的情况下进行，从而提高了并发性能。</p> 
<p>总的来说，写时复制是一种适用于读多写少场景的优化策略，它通过复制数据的方式实现了读写分离，提高了并发性能。但是，它也存在一些潜在的性能问题，如内存占用增加、写操作性能下降以及频繁的垃圾回收。因此，在使用时需要根据具体场景进行权衡和选择。</p> 
<hr> 
<h4><a id="2_39"></a>2、写时复制的实现</h4> 
<h5><a id="21CopyOnWriteArrayList__41"></a>2.1、CopyOnWriteArrayList 数据结构</h5> 
<p><code>CopyOnWriteArrayList</code> 是 Java 中的一种线程安全的 List 实现，它通过每次写操作时复制底层数组来保证线程安全。<code>CopyOnWriteArrayList</code> 跟 <code>ArrayList</code> 一样，也实现了 <code>List</code> 接口：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">RandomAccess</span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">// ReentrantLock用于保证在多线程环境下的线程安全</span>
    <span class="token keyword">final</span> <span class="token keyword">transient</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 持有实际元素的数组，通过volatile修饰保证在多线程环境下的可见性</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">;</span>

    <span class="token comment">// 默认构造函数，初始化一个空数组</span>
    <span class="token keyword">public</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 省略其他方法和实现细节...</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>可以看到，<code>CopyOnWriteArrayList</code> 底层的数据结构是一个数组（<code>Object[] array</code>）。这个数组通过 <code>volatile</code> 修饰，保证在多线程环境下的可见性。当数组内容发生变化时，其他线程能够立即看到最新的数组内容。</p> 
<h5><a id="22CopyOnWriteArrayList__66"></a>2.2、CopyOnWriteArrayList 读操作</h5> 
<p>读操作不需要加锁，因为写操作总是会生成新的数组副本，并且数组引用是 <code>volatile</code> 的，所以读操作总能读取到最新的数组内容。这使得读操作非常高效，适用于读多写少的场景。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span>array<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>get()</code> 函数实现了 <code>CopyOnWriteArrayList</code> 的读操作，代码逻辑非常简单，直接按照下标访问 <code>array</code> 数组从代码中我们可以发现，读操作没有加锁，因此即便在多线程环境下，效率也非常高</p> 
<h5><a id="22CopyOnWriteArrayList__78"></a>2.2、CopyOnWriteArrayList 写时复制</h5> 
<p>当对 <code>CopyOnWriteArrayList</code> 进行写操作（如 <code>add</code>, <code>set</code>, <code>remove</code>）时，都会创建底层数组的新副本。在新的副本上进行修改操作，修改完成后再将引用指向新的数组。这种写时复制的机制保证了在进行写操作时不会影响到正在进行读操作的线程。</p> 
<h6><a id="221add__82"></a>2.2.1、add() 函数</h6> 
<p><code>add()</code> 函数的代码实现如下所示，<code>add()</code> 函数包含写时复制逻辑，因此相对于 <code>get()</code> 函数，要复杂一些</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 获取锁，确保在多线程环境下只有一个线程能进行写操作</span>
    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 获取当前数组的长度</span>
        <span class="token keyword">int</span> len <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token comment">// 使用 Arrays.copyOf() 方法创建一个新数组，并将现有数组的元素复制到新数组中</span>
        <span class="token comment">// Arrays.copyOf() 方法底层依赖 native 方法 System.arraycopy() 来实现复制操作，速度较快</span>
        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 将新元素添加到新数组的最后一个位置</span>
        newElements<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
        <span class="token comment">// 将底层数组引用指向新数组</span>
        array <span class="token operator">=</span> newElements<span class="token punctuation">;</span>
        <span class="token comment">// 返回 true 表示添加成功</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 释放锁</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>当往容器中添加数据时，并非直接将数据添加到原始数组中，而是创建一个长度比原始数组大一的数组 <code>newElements</code>，将原始数组中的数据拷贝到 <code>newElements</code>。然后将数据添加到 <code>newElements</code> 的末尾，最后修改 <code>array</code> 引用指向 <code>newElements</code>。</p> 
<p>除此之外，我们可以看到，为了保证写操作的线程安全性，避免两个线程同时执行写时复制，写操作通过加锁（<code>lock.lock();</code>）来串行执行也就是说：读读、读写都可以并行执行，唯独写写不可以并行执行.</p> 
<h6><a id="222remove__113"></a>2.2.2、remove() 函数</h6> 
<p><code>remove()</code> 函数的代码实现如下所示：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 获取锁，确保在多线程环境下只有一个线程能进行写操作</span>
    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 获取当前数组的长度</span>
        <span class="token keyword">int</span> len <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token comment">// 获取指定索引处的元素，该元素将在稍后被移除</span>
        <span class="token class-name">E</span> oldValue <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 计算从指定索引到数组末尾之间的元素个数</span>
        <span class="token keyword">int</span> numMoved <span class="token operator">=</span> len <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 如果要移除的元素是数组的最后一个元素，直接创建一个长度为 len - 1 的新数组</span>
            array <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 如果要移除的元素在数组的中间位置</span>
            <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token comment">// 将原数组中从索引 0 到 index-1 的元素复制到新数组中</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> newElements<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// array[0, index - 1]</span>
            <span class="token comment">// 将原数组中从索引 index+1 到末尾的元素复制到新数组中，从 index 位置开始</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> newElements<span class="token punctuation">,</span> index<span class="token punctuation">,</span> numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span> 
            <span class="token comment">// 更新底层数组引用为新数组</span>
            array <span class="token operator">=</span> newElements<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 返回被移除的元素</span>
        <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 释放锁</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>remove()</code> 函数的处理逻辑跟 <code>add()</code> 函数类似：先通过加锁保证写时复制操作的线程安全性，然后申请一个大小比原始数组大小小一的新数组 <code>newElements</code>。除了待删除数据之外，我们将原始数组中的其他数据统统拷贝到 <code>newElements</code>，拷贝完成之后，我们将 <code>array</code> 引用指向 <code>newElements</code>。</p> 
<h6><a id="223set__153"></a>2.2.3、set() 函数</h6> 
<p><code>set()</code> 函数的代码实现如下所示</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 获取锁，确保在多线程环境下只有一个线程能进行写操作</span>
    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 获取指定索引处的旧值</span>
        <span class="token class-name">E</span> oldValue <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 如果旧值与新值不同，才进行更新操作</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldValue <span class="token operator">!=</span> element<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 获取当前数组的长度</span>
            <span class="token keyword">int</span> len <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
            <span class="token comment">// 使用 Arrays.copyOf() 方法创建一个新数组，并将现有数组的元素复制到新数组中</span>
            <span class="token comment">// Arrays.copyOf() 方法底层依赖 native 方法 System.arraycopy() 来实现复制操作，速度较快</span>
            <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 将新元素放置到指定索引处</span>
            newElements<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>
            <span class="token comment">// 更新底层数组引用为新数组</span>
            array <span class="token operator">=</span> newElements<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 返回旧值</span>
        <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 释放锁</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在 <code>set()</code> 函数中，跟 <code>add()</code> 函数、<code>remove()</code> 函数的类似，通过加锁确保线程安全，在旧值与新值不同时复制底层数组并替换指定索引处的元素，最后更新数组引用并释放锁。</p> 
<h5><a id="23CopyOnWriteArraySet__187"></a>2.3、CopyOnWriteArraySet 的实现</h5> 
<p><code>CopyOnWriteArraySet</code> 使用 <code>CopyOnWriteArrayList</code> 作为底层数据结构，通过写时复制的方式保证线程安全。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CopyOnWriteArraySet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">// 底层数据结构使用 CopyOnWriteArrayList 来存储元素</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> al<span class="token punctuation">;</span>

    <span class="token comment">// 默认构造函数，初始化底层的 CopyOnWriteArrayList</span>
    <span class="token keyword">public</span> <span class="token class-name">CopyOnWriteArraySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        al <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 添加元素到集合中，如果元素不存在则添加并返回 true，否则返回 false</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> al<span class="token punctuation">.</span><span class="token function">addIfAbsent</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 从集合中移除指定元素，如果移除成功则返回 true，否则返回 false</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> al<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 判断集合中是否包含指定元素，如果包含则返回 true，否则返回 false</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> al<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  
  	<span class="token comment">// 省略其他方法和实现细节...</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>添加元素时，只有在元素不存在时才会添加；移除和检查元素的方法直接委托给底层的 <code>CopyOnWriteArrayList</code> 实现。整个实现确保了高并发环境下的安全性和一致性。</p> 
<hr> 
<h4><a id="3_225"></a>3、写实复制的特性</h4> 
<h5><a id="31_227"></a>3.1、读多写少</h5> 
<p>从上述 <code>CopyOnWriteArrayList</code> 的源码和性能测试结果可以得出以下结论：</p> 
<ol><li> <p>写操作需要加锁：所有的写操作（如 <code>add</code>、<code>set</code>、<code>remove</code> 等）都需要获取锁，确保线程安全性，因此这些操作只能串行执行；</p> </li><li> <p>写时复制：每次写操作都需要创建数组副本并进行数据拷贝，这涉及大量的数据搬移，导致写操作的执行效率非常低；</p> </li><li> <p>读多写少的场景：由于写操作的高开销，<code>CopyOnWriteArrayList</code> 适用于读多写少的应用场景。在这种场景下，读操作可以并发执行，且无需加锁。</p> </li></ol> 
<p>以下是一个性能测试的示例代码，用于比较 <code>CopyOnWriteArrayList</code> 和 <code>ArrayList</code> 在执行大量写操作时的耗时：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> cowList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> startTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            cowList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"CopyOnWriteArrayList耗时: "</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 毫秒"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        startTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ArrayList耗时: "</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 毫秒"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里我执行的结果是：<code>CopyOnWriteArrayList</code> 执行 100000 次写操作耗时约 2098 毫秒。<code>ArrayList</code> 执行同样数量的写操作仅耗时约 2 毫秒。<code>CopyOnWriteArrayList</code> 的耗时是 <code>ArrayList</code> 的 1000 多倍，说明在写操作频繁的场景下，<code>CopyOnWriteArrayList</code> 的性能表现非常差。</p> 
<h5><a id="32_261"></a>3.2、弱一致性</h5> 
<p><code>CopyOnWriteArrayList</code> 由于写时复制的特性，写操作的结果并不会立即对读操作可见。写操作在新数组上执行，而读操作在原始数组上执行，这就导致在 <code>array</code> 引用指向新数组之前，读操作只能读取到旧的数据。这种现象被称为弱一致性。</p> 
<p>在示例代码中，存在两个线程：一个线程调用 <code>add()</code> 函数添加数据，另一个线程调用 <code>sum()</code> 函数遍历容器求和。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> scores <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">,</span> <span class="token keyword">int</span> score<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        scores<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>idx<span class="token punctuation">,</span> score<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将数据插入到 idx 下标位置</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> scores<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            ret <span class="token operator">+=</span> scores<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>重复统计问题的产生：假设一个线程在执行 <code>add(int idx, int score)</code> 方法向 <code>scores</code> 列表中添加数据的同时，另一个线程在执行 <code>sum()</code> 方法遍历 <code>scores</code> 列表求和。这种情况下，可能会发生以下情况：</p> 
<ol><li> <p>线程 A 执行 <code>add()</code> 方法：线程 A 调用 <code>scores.add(idx, score)</code> 方法，底层会创建一个新的数组并将原数组的内容复制到新数组，然后将新元素添加到新数组中；</p> </li><li> <p>线程 B 执行 <code>sum()</code> 方法：在 <code>scores</code> 列表的 <code>array</code> 引用更新之前，线程 B 开始遍历原数组；</p> </li></ol> 
<p><img src="https://images2.imgbox.com/18/1b/rR7XQL5z_o.png" alt="image"></p> 
<ol start="3"><li>写时复制导致的数据不一致：由于写时复制的特性，线程 A 操作的是新数组，而线程 B 读取的是旧数组。此时，如果线程 A 更新了 <code>array</code> 引用，指向了新数组，而线程 B 仍然在遍历旧数组，可能会产生数据不一致的问题。</li></ol> 
<p>假设 <code>scores</code> 列表中有 <code>n</code> 个元素，线程 A 在第 <code>i</code> 个位置添加新元素，而线程 B 正在遍历第 <code>i</code> 个元素。如果 <code>array</code> 引用在此时更新，指向了新数组，线程 B 会继续遍历旧数组并重复统计第 <code>i</code> 个元素。这就导致了 <code>sum()</code> 方法可能会多统计一次该元素的值，产生错误的求和结果。</p> 
<p>迭代器实现与弱一致性问题的解决：<code>CopyOnWriteArrayList</code> 提供了一个专门的迭代器，用于遍历容器。这个迭代器在创建时，将原始数组赋值给 <code>snapshot</code> 引用，之后的遍历操作都是在 <code>snapshot</code> 上进行的。这样，即使 <code>array</code> 引用指向新的数组，也不会影响到 <code>snapshot</code> 引用继续指向原始数组，从而解决了弱一致性带来的问题。</p> 
<p>以下是 <code>CopyOnWriteArrayList</code> 中迭代器的实现代码：</p> 
<pre><code class="prism language-java"><span class="token comment">// 位于 CopyOnWriteArrayList.java 中</span>
<span class="token keyword">public</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">COWIterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">COWIterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">ListIterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> snapshot<span class="token punctuation">;</span> <span class="token comment">// 指向原始数组</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> cursor<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">COWIterator</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elements<span class="token punctuation">,</span> <span class="token keyword">int</span> initialCursor<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        cursor <span class="token operator">=</span> initialCursor<span class="token punctuation">;</span>
        snapshot <span class="token operator">=</span> elements<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> cursor <span class="token operator">&lt;</span> snapshot<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> snapshot<span class="token punctuation">[</span>cursor<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// ... 省略其他方法 ...</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>使用迭代器来重构 <code>sum()</code> 方法，使其在遍历过程中避免重复统计的问题。重构后的代码如下：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> itr <span class="token operator">=</span> scores<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>itr<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        ret <span class="token operator">+=</span> itr<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>重构后的优点：</p> 
<ol><li> <p>避免数据不一致：由于迭代器在创建时将原始数组赋值给 <code>snapshot</code>，遍历操作都是在 <code>snapshot</code> 上进行，即使 <code>array</code> 引用指向新的数组，遍历过程中的数据也不会改变，从而避免了重复统计的问题；</p> </li><li> <p>线程安全：迭代器提供了一种线程安全的遍历方式，确保在高并发环境下能够正确读取数据；</p> </li><li> <p>简洁代码：使用迭代器使得遍历代码更加简洁和易读，同时保证了代码的正确性和性能。</p> </li></ol> 
<h5><a id="33_354"></a>3.3、连续存储</h5> 
<p>在本篇开头，我们提到了 JUC 提供了 <code>CopyOnWriteArrayList</code>、<code>CopyOnWriteArraySet</code> 却没有提供 <code>CopyOnWriteLinkedList</code>、<code>CopyOnWriteHashMap</code> 等其他类型的写时复制容器，这是出于什么样的考虑呢？</p> 
<h6><a id="331_358"></a>3.3.1、数组容器</h6> 
<p>在写时复制的处理逻辑中，每次执行写操作时，哪怕只添加、修改、删除一个数据，都需要大动干戈，把原始数据重新拷贝一份。如果原始数据比较大，那么对于链表、哈希表来说，因为数据在内存中不是连续存储的，因此拷贝的耗时将非常大，写操作的性能将无法满足一个工业级通用类对性能的要求。</p> 
<p>而 <code>CopyOnWriteArrayList</code> 和 <code>CopyOnWriteArraySet</code> 底层都是基于数组来实现的，数组在内存中是连续存储的<br> JUC 使用 JVM 提供的 <code>native</code> 方法，如下所示，通过 C++ 代码中的指针实现了内存块的快速拷贝，因此写操作的性能在可接受范围之内。</p> 
<p>而在平时的业务开发中，对于一些读多写少的业务场景，在确保性能满足业务要求的前提下，我们仍然可以使用写时复制技术来提高读操作性能。</p> 
<pre><code class="prism language-java"><span class="token comment">// 位于 System.java 中</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">arraycopy</span><span class="token punctuation">(</span><span class="token class-name">Object</span> src<span class="token punctuation">,</span> <span class="token keyword">int</span> srcPos<span class="token punctuation">,</span> <span class="token class-name">Object</span> dest<span class="token punctuation">,</span> <span class="token keyword">int</span> destPos<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h6><a id="333_372"></a>3.3.3、非数组容器</h6> 
<p>JUC 没有提供非数组类型的写时复制容器，是出于对于一个工业级通用类的性能的考量对于非数组类型的容器，我们需要自己去开发相应的写时复制逻辑，</p> 
<p>假设系统配置存储在文件中，在系统启动时，配置文件被解析加载到内存中的 <code>HashMap</code> 容器中，之后 <code>HashMap</code> 容器中的配置会频繁地被用到系统支持配置热更新，在不重启系统的情况下，我们希望能较实时地更新内存中的配置，让其跟文件中的配置保持一致</p> 
<p>为了实现热更新这个功能，我们在系统中创建一个单独的线程，定时从配置文件中加载解析配置，更新到内存中的 <code>HashMap</code> 容器中</p> 
<p>对于这样一个读多写少的应用场景，我们就可以使用写时复制技术，如下代码所示在更新内存中的配置时，使用写时复制技术，避免写操作和读操作互相影响。相对于 <code>ConcurrentHashMap</code> 来说，读操作完全不需要加锁，甚至连 CAS 操作都不需要，因此读操作的性能更高。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Configuration</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    <span class="token comment">// 热更新, 这里不需要加锁(只有一个线程调用此函数), 也不需要拷贝(全量更新配置)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reload</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> newMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// ... 从配置文件加载配置, 并解析放入 newMap</span>
        map <span class="token operator">=</span> newMap<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bc68400bbabe9f1802166df8879fa854/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">怎么分区，新买的电脑只有一个C盘</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6eb2c2ac5bb807409f7fde97e4046baa/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">机器学习 C&#43;&#43; 的opencv实现SVM图像二分类的测试 (三)【附源码】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>