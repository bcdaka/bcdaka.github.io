<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Liunx】基础开发工具的使用介绍-- yum / vim / gcc / gdb / make - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/475d798b87c72096a64f5cbaf198e5f4/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【Liunx】基础开发工具的使用介绍-- yum / vim / gcc / gdb / make">
  <meta property="og:description" content="前言
本章将介绍Linux环境基础开发工具的安装及使用，在Linux下安装软件，编写代码，调试代码等操作。
目录 1. yum 工具的使用1.1 什么是软件包：1.2 如何下载软件：1.3 配置国内yum源： 2. vim编辑器2.1 vim的安装2.2 vim的三种模式 3. gcc / g&#43;&#43; 编译器3. 1 编译的处理阶段3. 2 使用gcc生成静态库及静态库的使用方法：3. 3 gcc的编译选项： 4. gdb 编译器4.1 背景介绍4.2 gdb的操作指令 5. make / Makefile5.1 makefile的介绍5.2 如何判断是否重新生成：5.3 多文件的makefile 6. Linux第一个程序 —— 进度条6.1 回车和换行的概念：6.2 缓存区的概念： 1. yum 工具的使用 在Linux中安装软件：
源代码安装，rpm包安装yum安装 其中源代码安装和rpm安装并不简单，当依赖别的库时，还需要下载其他的库，Windows是直接打包好了的。
yum安装的好处：不用编译源码，不用解决软件的依赖关系。
1.1 什么是软件包： 在Linux下安装软件, 一个通常的办法是下载到程序的源代码, 并进行编译, 得到可执行程序.但是这样太麻烦了, 于是有些人把一些常用的软件提前编译好, 做成软件包(可以理解成windows上的安装程序)放在一个服务器上, 通过包管理器可以很方便的获取到这个编译好的软件包, 直接进行安装.软件包和软件包管理器, 就好比 “App” 和 “应用商店” 这样的关系 1.2 如何下载软件： yum list：
显示所有已经安装和可以安装的程序包。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-16T21:05:16+08:00">
    <meta property="article:modified_time" content="2024-06-16T21:05:16+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Liunx】基础开发工具的使用介绍-- yum / vim / gcc / gdb / make</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>前言</strong><br> 本章将介绍Linux环境基础开发工具的安装及使用，在Linux下安装软件，编写代码，调试代码等操作。</p> 
<p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><ul><li><a href="#1_yum__5" rel="nofollow">1. yum 工具的使用</a></li><li><ul><li><a href="#11__16" rel="nofollow">1.1 什么是软件包：</a></li><li><a href="#12___22" rel="nofollow">1.2 如何下载软件：</a></li><li><a href="#13___yum_45" rel="nofollow">1.3 配置国内yum源：</a></li></ul> 
   </li><li><a href="#2_vim_54" rel="nofollow">2. vim编辑器</a></li><li><ul><li><a href="#21__vim_67" rel="nofollow">2.1 vim的安装</a></li><li><a href="#22___vim_73" rel="nofollow">2.2 vim的三种模式</a></li></ul> 
   </li><li><a href="#3_gcc__g__125" rel="nofollow">3. gcc / g++ 编译器</a></li><li><ul><li><a href="#3_1__127" rel="nofollow">3. 1 编译的处理阶段</a></li><li><a href="#3_2__gcc_140" rel="nofollow">3. 2 使用gcc生成静态库及静态库的使用方法：</a></li><li><a href="#3_3__gcc_170" rel="nofollow">3. 3 gcc的编译选项：</a></li></ul> 
   </li><li><a href="#4_gdb__202" rel="nofollow">4. gdb 编译器</a></li><li><ul><li><a href="#41___203" rel="nofollow">4.1 背景介绍</a></li><li><a href="#42___gdb_211" rel="nofollow">4.2 gdb的操作指令</a></li></ul> 
   </li><li><a href="#5_make__Makefile_242" rel="nofollow">5. make / Makefile</a></li><li><ul><li><a href="#51_makefile_259" rel="nofollow">5.1 makefile的介绍</a></li><li><a href="#52__284" rel="nofollow">5.2 如何判断是否重新生成：</a></li><li><a href="#53_makefile_297" rel="nofollow">5.3 多文件的makefile</a></li></ul> 
   </li><li><a href="#6_Linux___327" rel="nofollow">6. Linux第一个程序 —— 进度条</a></li><li><ul><li><a href="#61__328" rel="nofollow">6.1 回车和换行的概念：</a></li><li><a href="#62__337" rel="nofollow">6.2 缓存区的概念：</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="1_yum__5"></a>1. yum 工具的使用</h3> 
<p><strong>在Linux中安装软件：</strong></p> 
<ul><li>源代码安装，</li><li>rpm包安装</li><li>yum安装</li></ul> 
<p>其中源代码安装和rpm安装并不简单，当依赖别的库时，还需要下载其他的库，Windows是直接打包好了的。</p> 
<p><font color="Blue"><strong>yum安装的好处：不用编译源码，不用解决软件的依赖关系。</strong></font></p> 
<h4><a id="11__16"></a>1.1 什么是软件包：</h4> 
<ul><li>在Linux下安装软件, <strong>一个通常的办法是下载到程序的源代码, 并进行编译, 得到可执行程序.</strong></li><li>但是这样太麻烦了, 于是有些人把一些常用的软件提前编译好, 做成软件包(可以理解成windows上的安装程序)放在一个服务器上, 通过包管理器可以很方便的获取到这个编译好的软件包, 直接进行安装.</li><li>软件包和软件包管理器, 就好比 “App” 和 “应用商店” 这样的关系</li></ul> 
<p><img src="https://images2.imgbox.com/1b/9a/4a1oi2H6_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="12___22"></a>1.2 如何下载软件：</h4> 
<ul><li class="task-list-item"> <p><input type="checkbox" class="task-list-item-checkbox" checked disabled> yum list：<br> 显示所有已经安装和可以安装的程序包。<br> <strong>这些列表里面的包的来源就是/etc/yum.repo.d</strong></p> </li><li> <p>我们推荐先下载一下两个软件：<br> lrzsz：</p> </li></ul> 
<blockquote> 
 <p>软件功能：支持Windows的文件传到Linux_上，直接拖拽到X-Shell。</p> 
</blockquote> 
<pre><code class="prism language-cpp">yum list <span class="token operator">|</span> grep lrzsz
yum install <span class="token operator">-</span>y lrzsz<span class="token punctuation">.</span>x86_64
</code></pre> 
<p><font color="Red"> 注意：我们下载软件要用root身份，或者通过sudo来提升权限。</font></p> 
<ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked disabled> yum remove ：</li></ul> 
<pre><code class="prism language-cpp">sudo yum remove lrzsz
</code></pre> 
<h4><a id="13___yum_45"></a>1.3 配置国内yum源：</h4> 
<p>如何知道去哪台服务器上下载软件呢？</p> 
<ul><li>因为手机应用市场内置了下载的链接。</li><li>Linux则是去 /etc/yum.repos.d去找对应链接。<br> 有的时候在下载的时候会发现，下载的速度非常慢，这是因为有的yum源不是在国内，而是在国外的。这时候就需要我们配制国内的yum源了。</li></ul> 
<p><font color="Blue"> 注意：做任何配置，绝对不要先删除，一定是先备份（就是将之前的目录改个名字）。</font></p> 
<h3><a id="2_vim_54"></a>2. vim编辑器</h3> 
<ul><li>vim是什么?</li></ul> 
<blockquote> 
 <p>是一个编辑器<br> 类似于Windows下的记事本 只有写代码的功能，并不能像vs 2019那样的集成开发环境<br> 只能用来写代码，功能强大**（多模式的编辑器）**。</p> 
</blockquote> 
<ul><li>我们为什么要学习vim？</li></ul> 
<blockquote> 
 <p>有时候，需要我们在生产环境下，需要你快速的定位问题，甚至需要你快速的修改代码！<br> vim更适合处理大型项目或者文件。</p> 
</blockquote> 
<h4><a id="21__vim_67"></a>2.1 vim的安装</h4> 
<p>一般Liunx都是自带vim，有的则不是自带的，如果没有自带，需要安装一下。</p> 
<pre><code class="prism language-cpp">yum install <span class="token operator">-</span>y vim
</code></pre> 
<h4><a id="22___vim_73"></a>2.2 vim的三种模式</h4> 
<p>vim有很多种模式，我们现在学习三种模式：<font color="Red"> <strong>底行模式，命令模式，插入模式。</strong></font><br> <img src="https://images2.imgbox.com/53/76/xLLvCPgp_o.png" alt="在这里插入图片描述"><br> <strong>使用 vim test.c后，默认进入的是“正常模式”</strong></p> 
<ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked disabled> <font color="Red"><strong>在命令模式下的一些文本批量化操作</strong></font></li></ul> 
<blockquote> 
 <p><strong>yy</strong>: 复制当前行，nyy复制n行<br> <strong>p</strong>: 粘贴再当前行的后面，np粘贴n次剪贴板的内容<br> <strong>dd</strong>: 剪切（删除）当前行，ndd操作n行<br> <strong>u</strong>:撤销<br> <strong>ctrl + r</strong>: 重做<br> <strong>shift + g</strong>: 光标快速定位到文本末尾<br> <strong>gg</strong>: 光标快速移动到文本头<br> <strong>n + shift + g</strong>: 光标定位到文本的第n行<br> <strong>shift + 4:</strong> 光标定位到该行末尾<br> <strong>shift + 6:</strong> 光标定位到该行开头<br> <strong>w,b</strong>: 以单词为单位进行移动光标<br> <strong>h,j,k,l</strong>: 左、下、上、右<br> <strong>shift + `</strong>: 大小写快速切换<br> <strong>r</strong>: 替换光标所在处的字符，支持nr<br> <strong>shift + r</strong>: 批量化替换<br> <strong>x</strong>: 删除光标所在处的字符，nx删除n个</p> 
</blockquote> 
<p><font color="Red"> <strong>其他模式切换至命令模式，直接无脑Esc。</strong><br> <img src="https://images2.imgbox.com/46/52/Pm4IydXG_o.png" alt="在这里插入图片描述"></font></p> 
<ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked disabled> <font color="Red"><strong>在底行模式的一些操作如下：</strong></font></li></ul> 
<blockquote> 
 <p><strong>:w</strong> 只保存<br> <strong>:q</strong> 不保存退出<br> <strong>:wq</strong> 保存并退出<br> <strong>:reg</strong> 打开vim的寄存器面板<br> <strong>:syntax on</strong> 开启语法高亮<br> <strong>:set nu</strong> 显示行号<br> <strong>:set nonu</strong> 取消行号显示<br> <strong>:set tabstop=4</strong> 设置tab的缩进，默认为8<br> <strong>:set softtabstop=4</strong> softtabstop是“逢8空格进1制表符”,前提是你tabstop=8<br> <strong>:set shiftwidth=4</strong>设置程序自动缩进所使用的空格长度<br> <strong>:set autoindent</strong> 自动对齐上一行（这个选项会导致复制的时候代码排版混乱，可以考虑关闭，或者开启粘贴模式）<br> <strong>:set paste</strong> 开启粘贴模式<br> <strong>:set mouse=a</strong> 设置鼠标模式，默认是a<br> <strong>/+</strong> 要搜索的内容 指定搜索</p> 
</blockquote> 
<p>VIM配置文件的位置：</p> 
<ul><li>Vim的配置主要是在.vimrc的文件里面</li><li>在目录 /etc/ 下面，有个名为vimrc的文件，这是系统中公共的vim配置文件，对所有用户都有效。</li><li>而在每个用户的主目录下，都可以自己建立私有的配置文件，命名为：“.vimrc”。例如，/root目录下，通常已经存在一个.vimrc文件,如果不存在，则创建之。切换用户成为自己执行 su ，进入自己的主工作目录,执行 cd ~<br> 打开自己目录下的.vimrc文件，执行 vim .vimrc</li></ul> 
<h3><a id="3_gcc__g__125"></a>3. gcc / g++ 编译器</h3> 
<h4><a id="3_1__127"></a>3. 1 编译的处理阶段</h4> 
<ol><li><strong>预处理（进行宏替换)</strong> --&gt; 2. <strong>编译（生成汇编)</strong> —&gt; 3. <strong>汇编（生成机器可识别代码）</strong>—&gt; 4. <strong>连接（生成可执行文件或库文件)</strong></li></ol> 
<p><font color="Red"> <strong>Gcc是如何完成的。</strong></font><br> 格式： gcc <font color="Blue"> <strong>[选项]</strong> </font> 要编译的文件 <font color="Green"> <strong>[选项]</strong> </font> [目标文件】</p> 
<p><strong>动静态库：查看一个程序的链接关系，可以使用ldd或file</strong><br> <img src="https://images2.imgbox.com/08/46/fxCexc7p_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/b8/5e/RBYBVH01_o.png" alt="在这里插入图片描述"><br> 系统默认的搜索路径“/usr/lib”下进行查找，也就是链接到libc.so,6 库函数中去。。<br> <font color="Red"> <strong>动态链接：必须使用动态库(.so)。</strong><br> 静态链接：必须使用静态库(.a）</font></p> 
<h4><a id="3_2__gcc_140"></a>3. 2 使用gcc生成静态库及静态库的使用方法：</h4> 
<ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked disabled> 静态库的制作方法：<br> 代码示例：</li></ul> 
<pre><code class="prism language-cpp">  ar <span class="token operator">-</span>rc libhello<span class="token punctuation">.</span>a mymath<span class="token punctuation">.</span>o myprint<span class="token punctuation">.</span>o
  
</code></pre> 
<p>%ar 是gnu归档工具，rc表示（replace and create）<br> <strong>静态库的命名：以lib开头+名字+.a结束。</strong><br> <img src="https://images2.imgbox.com/8a/8d/rTbVgJLi_o.png" alt="在这里插入图片描述"></p> 
<ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked disabled> 动态库的制作</li></ul> 
<p><strong>动态库生成：</strong></p> 
<pre><code class="prism language-cpp">gcc <span class="token operator">-</span>fPIC <span class="token operator">-</span>c mymath<span class="token punctuation">.</span>c <span class="token operator">-</span>o mymath_d<span class="token punctuation">.</span>o
</code></pre> 
<p><strong>打包动态库：</strong></p> 
<pre><code class="prism language-cpp">gcc <span class="token operator">-</span>shared myprint<span class="token punctuation">.</span>o mymath<span class="token punctuation">.</span>o <span class="token operator">-</span>o libhello<span class="token punctuation">.</span>so
</code></pre> 
<ul><li>-shared：表示生成共享库格式</li><li>-fPIC：产生位置无关代码（position independent code）<br> <img src="https://images2.imgbox.com/05/06/2C0nFtgh_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="3_3__gcc_170"></a>3. 3 gcc的编译选项：</h4> 
<p>我们使用gcc编译程序时，常常会用到“-I（大写i）, ” -L（大写l）" ,<br> " -i(小写i)"等参数，下面做个记录<img src="https://images2.imgbox.com/bb/8a/UBfpqs6k_o.png" alt="在这里插入图片描述"></p> 
<ul><li>-L选项后带的是库的路径。</li><li>-I选择后带的是头文件的搜索路径。</li><li>-l选项带的是库的名字，库名要去掉前面的lib和后缀.a。</li></ul> 
<p><strong>补充：</strong></p> 
<ul><li>g++是用来编译C++程序的，用法和gcc一样</li><li>因为C++是兼容C语言的，所以g++也能用来编译C语言</li><li>如果部分C语言用法gcc不支持的话，那就在gcc编译的最后加上一句-std=c99</li><li>例如在循环里定义变量是c99才支持的<br> <img src="https://images2.imgbox.com/db/5d/PQUJYSDu_o.png" alt="在这里插入图片描述"></li></ul> 
<p><strong>Gcc选项：</strong></p> 
<ul><li>-E 只激活预处理,这个不生成文件,你需要把它重定向到一个输出文件里面</li><li>-S 编译到汇编语言不进行汇编和链接</li><li>-c 编译到目标代码</li><li>-o 文件输出到 文件</li><li>-static 此选项对生成的文件采用静态链接</li><li>-g 生成调试信息。GNU 调试器可利用该信息。</li><li>-shared 此选项将尽量使用动态库，所以生成文件比较小，但是需要系统由动态库.</li><li>-O0<br> -O1<br> -O2<br> -O3 编译器的优化选项的4个级别，-O0表示没有优化,-O1为缺省值，-O3优化级别最高</li><li>-w 不生成任何警告信息。</li><li>-Wall 生成所有警告信息</li></ul> 
<h3><a id="4_gdb__202"></a>4. gdb 编译器</h3> 
<h4><a id="41___203"></a>4.1 背景介绍</h4> 
<p>用gdb调试的时候非常麻烦比vs麻烦得多，但是在一些特定的场景下就是需要用gdb调试。</p> 
<ul><li>程序的发布方式有两种，debug模式和release模式</li><li>Linux gcc/g++出来的二进制程序，默认是release模式.</li><li>要使用gdb调试，必须在源代码生成二进制程序的时候**, 加上 -g 选项.**</li></ul> 
<h4><a id="42___gdb_211"></a>4.2 gdb的操作指令</h4> 
<p>如何进入gdb？</p> 
<blockquote> 
 <p>使用gdb +可执行程序名字<br> quit: 代表退出gdb<br> gdb会记录上一次的命令代码</p> 
</blockquote> 
<p>gdb的操作：</p> 
<ul><li>b 行号: 打断点</li><li>info b: 查看断点</li><li>d 断点编号: 取消断点</li><li>l 行号: 显示代码</li><li>l main：显示包含main的那一行</li><li>r: run，开始运行程序,跳到第一个断点</li><li>s: step，逐语句，对应vs的F11（进入函数）</li><li>n: next，逐过程，对应vs的F10</li><li>c:continue，跳转道下一个断点</li><li>p: 查看变量</li><li><font color="Red"> display 变量名</font>：跟踪查看一个变量，每次停下来都显示它的值</li><li><strong>undisplay:</strong> 取消对先前设置的那些变量的跟踪</li><li>until 行号:跳转到指定行</li><li>finish: 执行完一个函数后停下</li><li>bt: 查看函数调用堆栈</li></ul> 
<p><strong>gdb知道、会用就可以了。。</strong></p> 
<h3><a id="5_make__Makefile_242"></a>5. make / Makefile</h3> 
<p>经过上述的学习之后，我们知道<font color="Red">Linux</font>下要是生成一个可执行(exe)文件是很麻烦的，当多个源文件一起编译的时候，一个一个生成目标文件最后再链接，很麻烦</p> 
<p><strong>项目结构：</strong><br> 1.多文件.h /.c /.cpp 先编译哪一个程序？<br> 2.链接需要哪些库？<br> 3.库和头文件等在哪里找？</p> 
<p>我们在vs中生成可执行文件只需要一键点击，清理解决方案也是一键点击，非常方便。</p> 
<p><font color="Red"><strong>但在Linux系统上，就需要自己去构建项目的工程结构？</strong></font></p> 
<ul><li>make ：是一个指令</li><li>Makefile:是一个文件</li></ul> 
<p>make 和Makefile类似于：Vs当中生成解决方案</p> 
<h4><a id="51_makefile_259"></a>5.1 makefile的介绍</h4> 
<p>我们在makefile文件中通过，<font color="Red">依赖关系和依赖方法</font>，达到我们最终的目的，生成可执行文件。</p> 
<ul><li>依赖关系：表明我要将那些文件生成</li><li>依赖方法：表明我如何生成该文件</li></ul> 
<p><font color="blue">makefile表明的是依赖关系和依赖方法。</font></p> 
<p>对应的Makefile如下：<br> <img src="https://images2.imgbox.com/45/b3/PQlajtbI_o.png" alt="在这里插入图片描述"><br> <strong>注意：</strong></p> 
<ul><li>make指令默认只会形成第一个目标文件，执行该依赖关系的依赖方法。</li><li>要运行第二个依赖方法，则需要make clean</li><li>.PHONY: 是makefile语法格式中的一个关键字</li><li>clean被.PHONY修饰，表明：总是被执行！</li></ul> 
<p><strong>什么叫总是被执行：</strong></p> 
<blockquote> 
 <ul><li>无论目标文件是否新旧，照样直接执行依赖关系！</li><li>像普通的文件，make之后，就不会重复生成可执行程序，这就叫总不被执行。</li></ul> 
</blockquote> 
<h4><a id="52__284"></a>5.2 如何判断是否重新生成：</h4> 
<p><strong>那么问题来了，makefile是如何识别我的exe/bin是新的还是旧的呢？</strong></p> 
<blockquote> 
 <p>答案就是：根据对比源文件和可执行程序的最近修改时间，评估要不要重新生成</p> 
</blockquote> 
<p><font color="Red"> 一般而言，Linux下的文件会有三种时间：</font><br> <img src="https://images2.imgbox.com/74/75/ovwGe8Ha_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>Access</strong>： 访问时间对于文件来说，当我们使用cat、more、less等命令读取文件内容时。</li><li><strong>Modity</strong>： 对文件内容修改时，Modify、Change时间会更新。</li><li><strong>Chang</strong>： 对文件属性修改时，例如chmod、chown、chcgrp等操作后，Change 时间会更新</li></ul> 
<h4><a id="53_makefile_297"></a>5.3 多文件的makefile</h4> 
<p><font color="blue"> <strong>1.依赖多个.c文件生成一个可执行程序</strong></font></p> 
<pre><code class="prism language-cpp">mytest：main<span class="token punctuation">.</span>o test<span class="token punctuation">.</span>o
  gcc <span class="token operator">-</span>o mytest main<span class="token punctuation">.</span>o test<span class="token punctuation">.</span>o
main<span class="token punctuation">.</span>o<span class="token operator">:</span>main<span class="token punctuation">.</span>c
  gcc <span class="token operator">-</span>c main<span class="token punctuation">.</span>c <span class="token operator">-</span>o main<span class="token punctuation">.</span>o
test<span class="token punctuation">.</span>o <span class="token operator">:</span>test<span class="token punctuation">.</span>c
  gcc <span class="token operator">-</span>c test<span class="token punctuation">.</span>c <span class="token operator">-</span>o test<span class="token punctuation">.</span>o
 
 <span class="token punctuation">.</span>PHONY<span class="token operator">:</span>clean
 clean<span class="token operator">:</span>
    rm <span class="token operator">-</span>r <span class="token operator">*</span><span class="token punctuation">.</span>o mytest
</code></pre> 
<p><font color="blue"> <strong>2.生成多个可执行程序</strong>（exe）</font></p> 
<pre><code class="prism language-cpp"> <span class="token punctuation">.</span>PHONY<span class="token operator">:</span>all
all<span class="token operator">:</span> exec mycmd

mycmd：mycmd<span class="token punctuation">.</span>c
   gcc <span class="token operator">-</span>o $@ $<span class="token operator">^</span>
exec：exec<span class="token punctuation">.</span>c
   gcc <span class="token operator">-</span>o $@ $<span class="token operator">^</span>

 <span class="token punctuation">.</span>PHONY<span class="token operator">:</span>clean
 clean<span class="token operator">:</span>
    rm <span class="token operator">-</span>r <span class="token operator">*</span><span class="token punctuation">.</span>o exec mycmd
</code></pre> 
<h3><a id="6_Linux___327"></a>6. Linux第一个程序 —— 进度条</h3> 
<h4><a id="61__328"></a>6.1 回车和换行的概念：</h4> 
<p>平时接触的的换行一般指的是回车 + 换行，就是另起一行。但是实际上回车和换行还是有区别的：<br> <strong>回车是回车，换行是换行~</strong></p> 
<ul><li><strong>回车</strong>： 光标回到该行的最前面</li><li><strong>换行</strong>： 光标去到下一行，但是列不变</li></ul> 
<p>在我们之前学习的C语言中，<strong>\n就是回车 + 换行，而 \r 是回车。</strong></p> 
<h4><a id="62__337"></a>6.2 缓存区的概念：</h4> 
<ul><li>当我们printf一个字符串的时候，系统是先把这个字符串写入缓冲区，再把缓冲区的内容输出到屏幕上。</li><li>在linux环境中，\n会自动刷新缓冲区（只要缓冲区被刷新了就会在屏幕上显示出来）。</li><li>如果缓冲区没有刷新我们可以手动刷新，就需要用到**fflush() **函数来刷新一下。<br> <img src="https://images2.imgbox.com/47/9f/ET1RyXjP_o.png" alt="在这里插入图片描述"></li></ul> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CNT</span> <span class="token expression"><span class="token number">101</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">STYLE</span> <span class="token char">'#'</span></span>

<span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">char</span> arr<span class="token punctuation">[</span>CNT<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">memset</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token char">'\0'</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> str <span class="token operator">=</span> <span class="token string">"/-|\\"</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> STYLE<span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\033[46;34m[%-100s]\033[0m [%d%%] %c\r"</span><span class="token punctuation">,</span> arr<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> str<span class="token punctuation">[</span>i <span class="token operator">%</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">usleep</span><span class="token punctuation">(</span><span class="token number">40000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>尾声</strong><br> 看到这里，相信大家对这个C++有了解了。<br> 如果你感觉这篇博客对你有帮助，不要忘了一键三连哦</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/af8e7ce090d74916de0ea727530d92d8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【flink实战】flink-connector-mysql-cdc导致mysql连接器报类型转换错误</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bca2cb0745742ede589b384d83afc635/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">电子科技大学信软学院数据库 操作系统 计算机网络复习笔记汇总</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>