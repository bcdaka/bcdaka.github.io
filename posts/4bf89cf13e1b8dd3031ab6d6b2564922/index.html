<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Go 1.23新特性前瞻 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/4bf89cf13e1b8dd3031ab6d6b2564922/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Go 1.23新特性前瞻">
  <meta property="og:description" content="2024年5月22日，Go 1.23版本[1]功能特性正式冻结，后续将只改bug，不增加新feature。
对Go团队来说，这意味着开始了Go 1.23rc1的冲刺，对我们普通Gopher而言，这意味着是时候对Go 1.23新增的功能做一些前瞻了！
在Go没有发布Go 1.23rc1之前，我们至少可以通过以下两种渠道体验Go 1.23的最新特性：
通过go install安装tip版本；
使用Go playground[2]在线体验。
注：关于Go tip的安装方法以及Go playground在线体验的详细说明，这里就不赘述了，《Go语言第一课》[3]专栏的“03｜配好环境：选择一种最适合你的Go安装方法[4]”有系统全面的讲解，欢迎订阅阅读。
按照Go Release cycle[5]，Go 1.23将于2024年8月发布！因此目前为时尚早，下面列出的有些变化最终不一定能进入到Go 1.23的最终版本中，有小概率被revert的可能或者推迟到下一个版本(Go 1.24)，所以切记一切变更点要以最终Go 1.23版本发布时为准。
1. 语言变化 Go 1.23语言变化较少，除了range over func试验特性转正，再有就是几个悬而未决的spec变更。
1.1 range over func试验特性转正(61405[6]) Go 1.22版本[7]引入了range over func[8]试验特性，通过GOEXPERIMENT=rangefunc，可以实现函数迭代器。这一特性在Go 1.23版本正式转正，下面代码可以直接使用Go 1.23编译运行：
// go1.23-foresight/lang/range-over-function-iterator/main.go package main import &#34;fmt&#34; func Backward[E any](s []E &#34;E any&#34;) func(func(int, E) bool) { return func(yield func(int, E) bool) { for i := len(s) - 1; i &gt;= 0; i-- { if !">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-30T08:01:55+08:00">
    <meta property="article:modified_time" content="2024-05-30T08:01:55+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Go 1.23新特性前瞻</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p>2024年5月22日，Go 1.23版本<sup>[1]</sup>功能特性正式冻结，后续将只改bug，不增加新feature。</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/91/84/1OpUVxil_o.png" alt="437f174e7c9e362a6f6a5869bd5dbc6a.png"></p> 
 <p>对Go团队来说，这意味着开始了Go 1.23rc1的冲刺，对我们普通Gopher而言，这意味着<strong>是时候对Go 1.23新增的功能做一些前瞻了</strong>！</p> 
 <p>在Go没有发布Go 1.23rc1之前，我们至少可以通过以下两种渠道体验Go 1.23的最新特性：</p> 
 <ul><li><p>通过go install安装tip版本；</p></li><li><p>使用Go playground<sup>[2]</sup>在线体验。</p></li></ul> 
 <blockquote> 
  <p>注：关于Go tip的安装方法以及Go playground在线体验的详细说明，这里就不赘述了，《Go语言第一课》<sup>[3]</sup>专栏的“03｜配好环境：选择一种最适合你的Go安装方法<sup>[4]</sup>”有系统全面的讲解，欢迎订阅阅读。</p> 
 </blockquote> 
 <p>按照Go Release cycle<sup>[5]</sup>，Go 1.23将于2024年8月发布！因此目前为时尚早，下面列出的有些变化最终不一定能进入到Go 1.23的最终版本中，有小概率被revert的可能或者推迟到下一个版本(Go 1.24)，所以切记一切变更点要以最终Go 1.23版本发布时为准。</p> 
 <h3>1. 语言变化</h3> 
 <p>Go 1.23语言变化较少，除了range over func试验特性转正，再有就是几个悬而未决的spec变更。</p> 
 <h4>1.1 range over func试验特性转正(61405<sup>[6]</sup>)</h4> 
 <p>Go 1.22版本<sup>[7]</sup>引入了range over func<sup>[8]</sup>试验特性，通过GOEXPERIMENT=rangefunc，可以实现函数迭代器。这一特性在Go 1.23版本正式转正，下面代码可以直接使用Go 1.23编译运行：</p> 
 <pre class="has"><code class="language-go">// go1.23-foresight/lang/range-over-function-iterator/main.go

package main

import "fmt"

func Backward[E any](s []E "E any") func(func(int, E) bool) {
 return func(yield func(int, E) bool) {
  for i := len(s) - 1; i &gt;= 0; i-- {
   if !yield(i, s[i]) {
    return
   }
  }
  return
 }
}

func main() {
 sl := []string{"hello", "world", "golang"}
 for i, s := range Backward(sl) {
  fmt.Printf("%d : %s\n", i, s)
 }
}</code></pre> 
 <p>使用Go 1.23运行上述示例：</p> 
 <pre class="has"><code class="language-go">$go run main.go                     
2 : golang
1 : world
0 : hello</code></pre> 
 <p>range over func可以提供一种统一、高效的迭代方式, 为泛型后的自定义容器类提供统一的迭代接口，同时也可以替代部分现有API返回切片的做法, 改为通过迭代器的形式改进性能（通过编译器的优化），甚至还可以为函数式编程风格提供标准迭代机制。</p> 
 <p>rang over func机制的实现是通过编译器在源码层面的转换，其转换形式大致如下：</p> 
 <pre class="has"><code class="language-go">// 单循环变量
for x := range f1 {
 ...
}</code></pre> 
 <p>将被转换为：</p> 
 <pre class="has"><code class="language-go">f1(func(x T) bool {
 ...
})</code></pre> 
 <p>而另外一种常见的双循环变量形式的for range：</p> 
 <pre class="has"><code class="language-go">for expr1, expr2 = range f2 {
 ...
}</code></pre> 
 <p>将被转换为：</p> 
 <pre class="has"><code class="language-go">f2(func(#p1 T1, #p2 T2) bool {
 expr1, expr2 = #p1, #p2
 ...
})</code></pre> 
 <p>前提是：f1和f2分别要满足标准库中iter包中的下面函数原型形式：</p> 
 <pre class="has"><code class="language-go">// $GOROOT/src/iter/iter.go
type Seq[V any] func(yield func(V) bool) bool
type Seq2[K, V any] func(yield func(K, V) bool) bool</code></pre> 
 <p>此外，for range循环体中如果有break，将被转换为f1/f2中的return false，而如果有continue，则会被转换为return true。当然这只是大致的形式，实际的转换远比这个要复杂很多，要考虑的情况也是十分复杂。更为具体、复杂的转换可以参考Go编译器的实现源码rewrite.go<sup>[9]</sup></p> 
 <p>函数迭代器虽然转正，但肯定尚未成熟，后续还会有诸多问题(比如一些corner case)需要解决，比如Russ Cox新开的issue 65236<sup>[10]</sup>就在讨论是否允许忽略迭代变量；issue 65237<sup>[11]</sup>将跟踪spec中与range over func相关内容的变更。</p> 
 <h4>1.2 spec：几个悬而未决的issue</h4> 
 <ul><li><p>明确依赖常量的包级变量初始化时的次序(issue 66575)<sup>[12]</sup></p></li></ul> 
 <p>这个issue来自我提出的《Go 1.22引入的包级变量初始化次序问题<sup>[13]</sup>》，Go 1.23已经修正了该问题，并保持与Go 1.22之前的版本一致，但go spec<sup>[14]</sup>中尚未就此给出明确的说明。</p> 
 <ul><li><p>澄清"严格可比较"(strictly comparable)和"类型约束"(type constraints)等术语 (issue 59104)</p></li><li><p>[修改关于"类型参数是接口"的说明，避免引起混淆(issue 57310)](https://github.com/golang/go/issues/57310 "修改关于"类型参数是接口"的说明，避免引起混淆(issue 57310)")</p></li><li><p>禁止匿名接口类型的循环定义(issue 56103)<sup>[15]</sup></p></li></ul> 
 <p>一些issue已经“跳票”多次，不能确定以上issue都能最终在Go 1.23得以解决！</p> 
 <h3>2. 编译器与运行时</h3> 
 <h4>2.1 优化了PGO(Profile Guided Optimization)<sup>[16]</sup>带来的处理开销 (issue 58102<sup>[17]</sup>)</h4> 
 <p>Go社区发现启用PGO后，每个cmd/compile调用都会解析完整的PGO pprof配置文件，构建完整的权重图，然后确定与该包相关的内容。这类工作项有很多，并且随着Profile文件的大小和构建包的数量的扩展，构建开销也会增大。尤其是对于那些特别大的项目，PGO Profile很大，这可能会导致构建时间增加100%以上。</p> 
 <p>Go 1.23对这个问题进行了优化，PGO开销被降到了个位数百分比。</p> 
 <h4>2.2 限制将来对linkname的使用(67401<sup>[18]</sup>)</h4> 
 <p>在Go语言中，//go:linkname指令可以用来链接到标准库或其他包中的未导出符号。比如我们想访问runtime包中的一个未导出函数，例如runtime.nanotime。这个函数返回当前时间的纳秒数。我们可以通过//go:linkname指令链接到这个符号。下面我用一个示例来演示一下这点：</p> 
 <pre class="has"><code class="language-go">// go1.23-foresight/compiler/golinkname/main.go
package main
  
import (
    "fmt"
    _ "unsafe" // 必须导入 unsafe 包以使用 //go:linkname
)

// 声明符号链接
//
//go:linkname nanotime runtime.nanotime
func nanotime() int64

func main() {
    // 调用未导出的 runtime.nanotime 函数
    fmt.Println("Current time in nanoseconds:", nanotime()) 
}</code></pre> 
 <p>运行该示例：</p> 
 <pre class="has"><code class="language-go">$go run main.go
Current time in nanoseconds: 374424337532051</code></pre> 
 <p>这种做法一般不推荐，因为它可能导致程序不稳定，并且未来版本的Go可能会改变内部实现（比如nanotime被改名或被删除），破坏你的代码。</p> 
 <p>Go团队已经意识到这一点，并发现现存开源代码中有很多代码都通过//go:linkname依赖Go项目的internal下的包或Go标准库的未导出符号。这显然不是Go团队想看到的事儿，于是Russ Cox发起issue 67401，旨在考虑限制对//go:linkname的使用。</p> 
 <p>该issue虽然在Go 1.23 milestone中，但最终是否能落在Go 1.23中还不确定，毕竟这样的调整会导致一些现存代码无法正常编译运行。</p> 
 <h4>2.3 其他一些优化</h4> 
 <ul><li><p>优化内存分配器的行为，减少了大内存(带有指针)分配时的长暂停 (issue 31222<sup>[19]</sup>)</p></li><li><p>修复Windows下time.Sleep的精度问题(issue 44343<sup>[20]</sup>)</p></li><li><p>增加了设置崩溃输出的API runtime/debug.SetCrashOutput(issue 42888<sup>[21]</sup>)</p></li><li><p>对内联器继续进行大修：重构优化 (issue 61502<sup>[22]</sup>)，这是一个长期任务，估计后续版本还会继续。</p></li></ul> 
 <h3>3. 工具链</h3> 
 <h4>3.1 新增go telemetry子命令，改进go工具链的遥测能力 (issue 67111<sup>[23]</sup>)</h4> 
 <p>Russ Cox去年初就在个人博客上发布了四篇有关Go Telemetry的文章<sup>[24]</sup>，在2023 GopherCon大会上，Russ Cox也谈到了Go Telemetry对基于数据驱动进行Go演进决策的重要性<sup>[25]</sup>。Russ Cox亲自创建的["all: add opt-in transparent telemetry to Go toolchain"](https://github.com/golang/go/issues/58894 ""all: add opt-in transparent telemetry to Go toolchain"")提案也被Go项目接受。</p> 
 <p>Go工具链中的telemetry是数据驱动的重要一环，最初golang.org/x/telemetry实验项目<sup>[26]</sup>被建立。在Go 1.23中，go工具链新增了go telemetry子命令，该子命令就是基于golang.org/x/telemetry实验项目，这也是Go团队实现某一个特性的一贯套路。</p> 
 <p>go telemetry子命令用法大致如下(以最终版本的doc为准)：</p> 
 <pre class="has"><code class="language-go">go telemetry - 打印telemetry mode: on, off or local；
go telemetry on - 设置mode为on；即开启telemetry且上传遥测数据。
go telemetry local - 设置mode为local；即telemetry数据仅存储在本地，但不上传。
go telemetry off - 设置mode为off。即关闭telemetry
go clean -telemetry - 清理本地的遥测数据目录。</code></pre> 
 <h4>3.2 其他一些改变</h4> 
 <ul><li><p>go build(-json)支持以json形式输出构建结果(issue 62067<sup>[27]</sup>)，让构建结果更结构化</p></li><li><p>移除了对GOROOT_FINAL的支持 (issue 62047<sup>[28]</sup>)，估计很多人不知道或完全没用过GOROOT_FINAL，我也是如此。</p></li></ul> 
 <h3>4. 标准库</h3> 
 <h4>4.1 Timer/Ticker变化</h4> 
 <p>timer/ticker的stop/reset问题一直困扰Go团队，Go 1.23的两个重要fix期望能从根本上解决这个问题：</p> 
 <ul><li><p>Timer/Ticker的GC不再需要Stop(issue 61542<sup>[29]</sup>)</p></li></ul> 
 <p>程序不再引用的Timer和Ticker将立即有资格进行垃圾回收，即使它们的Stop方法尚未被调用。Go的早期版本直到触发后才会收集未停止的Timer，并且从未收集未停止的Ticker。</p> 
 <ul><li><p>Timer/Ticker的Stop/Reset后不再接收旧值(issue 37196<sup>[30]</sup>)</p></li></ul> 
 <p>与Timer或Ticker关联的计时器channel现在改为无缓冲的了，即容量为0 。此更改的主要效果是Go现在保证任何对Reset或Stop方法的调用，调用之前不会发送或接收任何陈旧值。 Go的早期版本使用带有缓冲区的channel，因此很难正确使用Reset和Stop。此更改的一个明显效果是计时器channel的len和cap现在返回0而不是1，这可能会影响轮询长度以确定是否在计时器channel上接收的程序。通过GODEBUG设置asynctimerchan=1可恢复异步通道行为。</p> 
 <h4>4.2 新增unique包(issue 62483<sup>[31]</sup>)</h4> 
 <p>unique包的灵感来自于第三方包go4.org/intern<sup>[32]</sup>，也是为了弥补Go语言缺乏对[interning](https://en.wikipedia.org/wiki/Interning_(computer_science "interning"))内置支持的空缺。</p> 
 <p>根据wikipedia的描述，interning是按需重复使用具有同等值对象的技术，减少创建新对象的动作。这种创建模式经常用于不同编程语言中的数和字符串，可以避免不必要的对象重复分配的开销。</p> 
 <p>Go unique包即是Go的interning机制的实现，unique包提供了一种高效的值去重和快速比较的机制，可以用于优化某些特定场景下的程序性能。</p> 
 <p>unique包提供给开发人员的API接口非常简单：Make用来创建Handle实例，Handle的方法Value用于获取值的拷贝。下面是一个使用unique包的典型示例：</p> 
 <pre class="has"><code class="language-go">// go1.23-foresight/lib/unique/main.go
package main

import (
 "fmt"
 "unique"
)

func main() {
 // 创建唯一Handle
 s1 := unique.Make("hello")
 s2 := unique.Make("world")
 s3 := unique.Make("hello")

 // s1和s3是相等的，因为它们是同一个字符串值
 fmt.Println(s1 == s3) // true
 fmt.Println(s1 == s2) // false

 // 从Handle获取原始值
 fmt.Println(s1.Value()) // hello
 fmt.Println(s2.Value()) // world
}</code></pre> 
 <p>代码和输出结果都不难理解，这类就不赘述了。</p> 
 <h4>4.3 函数迭代器相关</h4> 
 <p>前面说过，函数迭代器转正了。标准库中有一些包立即就提供了一些便利的、可以与函数迭代器一起使用的函数，以slices、maps两个后加入Go标准库的泛型容器包为主。</p> 
 <p>其中slices包增加了：All、Values、Backward、Collect、AppendSeq、Sortted、SortedFunc、SortedStableFunc和Chunk。maps包增加了All、Keys、Values、Insert和Collect。</p> 
 <p>我们以slices包的All和Backward来构建一个示例，直观感受一下：</p> 
 <pre class="has"><code class="language-go">// go1.23-foresight/lib/slices/main.go

package main

import (
 "fmt"
 "slices"
)

func main() {
 sl := []string{"hello", "world", "golang"}

 for i, s := range slices.All(sl) {
  fmt.Printf("%d : %s\n", i, s)
 }

 for i, s := range slices.Backward(sl) {
  fmt.Printf("%d : %s\n", i, s)
 }
}</code></pre> 
 <p>运行该示例：</p> 
 <pre class="has"><code class="language-go">$go run main.go
0 : hello
1 : world
2 : golang
2 : golang
1 : world
0 : hello</code></pre> 
 <p>和以往一样，Go标准库是变化最多的一块儿，但篇幅有限，这里不便枚举，大家可以自行查看Go 1.23里程碑，选择自己关注的标准库变化，并深入研究。</p> 
 <h3>5. 小结</h3> 
 <p>本文主要预览了Go 1.23版本即将带来的新特性和变化。</p> 
 <p>首先在语言层面，range over func试验特性正式转正，提供统一高效的迭代方式；同时也会修复之前一些悬而未决的规范问题。</p> 
 <p>其次，在编译器和运行时方面，Go 1.23将优化PGO带来的开销，限制对linkname的使用，优化内存分配器和内联器等。工具链方面，新增telemetry子命令改进遥测能力。</p> 
 <p>标准库也有不少变化，比如Timer/Ticker的相关修复，新增unique包实现interning机制，以及为函数迭代器新增一些辅助函数。</p> 
 <p>Go 1.23的Release Notes的编写方式也做了调整，详细内容可参考我的公号文章<a href="" rel="nofollow">《Go 1.23 Release Notes编写方式改进！》</a>。</p> 
 <p>总的来说，Go 1.23包含了语法、编译器、运行时、工具链和标准库等多方面的改进，其中最主要集中在编译器性能优化、PGO特性增强、新编译器功能实现以及标准库增强等方面。</p> 
 <p>不过由于Go 1.23尚未发布，文中部分变化还可能被修改或推迟到下个版本。最终还是以正式发布版为准。文末也列出了一些相关资源链接，方便读者深入了解。</p> 
 <p>截至发文时，Go 1.23 milestone已经完成59%(https://github.com/golang/go/milestone/212)，还有188个open的issue待解决。究竟Go 1.23最终会做出哪些改变，让我们拭目以待！</p> 
 <p>最后，感谢Go团队以及所有Go 1.23贡献者做出的伟大工作！</p> 
 <p>文本涉及的源码可以在这里<sup>[33]</sup>下载。</p> 
 <h3>6. 参考资料</h3> 
 <ul><li><p>Go 1.23版本里程碑<sup>[34]</sup> - https://github.com/golang/go/milestone/212</p></li><li><p>Next Release Notes Draft<sup>[35]</sup> - https://tip.golang.org/doc/next</p></li><li><p>Go Release Dashboard<sup>[36]</sup> - https://dev.golang.org/release</p></li></ul> 
 <hr> 
 <p>Gopher部落知识星球<sup>[37]</sup>在2024年将继续致力于打造一个高品质的Go语言学习和交流平台。我们将继续提供优质的Go技术文章首发和阅读体验。同时，我们也会加强代码质量和最佳实践的分享，包括如何编写简洁、可读、可测试的Go代码。此外，我们还会加强星友之间的交流和互动。欢迎大家踊跃提问，分享心得，讨论技术。我会在第一时间进行解答和交流。我衷心希望Gopher部落可以成为大家学习、进步、交流的港湾。让我相聚在Gopher部落，享受coding的快乐! 欢迎大家踊跃加入！</p> 
 <p><img src="https://images2.imgbox.com/bd/23/QMglZAfE_o.jpg" alt="cd4ef3e1e253941316bc8484cc308415.jpeg"><img src="https://images2.imgbox.com/56/2f/wZQTVKvm_o.png" alt="1945e3aca35b452a27e787d670cc7e94.png"></p> 
 <p><img src="https://images2.imgbox.com/b4/20/1HAiYhn0_o.png" alt="d5252584f30d7080beefe895f2522fca.png"><img src="https://images2.imgbox.com/72/2f/SKxthaT8_o.jpg" alt="441df58e53ff0cb07c9283cedb9905cb.jpeg"></p> 
 <p>著名云主机服务厂商DigitalOcean发布最新的主机计划，入门级Droplet配置升级为：1 core CPU、1G内存、25G高速SSD，价格5$/月。有使用DigitalOcean需求的朋友，可以打开这个链接地址<sup>[38]</sup>：https://m.do.co/c/bff6eed92687 开启你的DO主机之路。</p> 
 <p>Gopher Daily(Gopher每日新闻) - https://gopherdaily.tonybai.com</p> 
 <p>我的联系方式：</p> 
 <ul><li><p>微博(暂不可用)：https://weibo.com/bigwhite20xx</p></li><li><p>微博2：https://weibo.com/u/6484441286</p></li><li><p>博客：tonybai.com</p></li><li><p>github: https://github.com/bigwhite</p></li><li><p>Gopher Daily归档 - https://github.com/bigwhite/gopherdaily</p></li></ul> 
 <img src="https://images2.imgbox.com/f5/4d/Q0eP8ns0_o.jpg" alt="cbc05298d6420749856643829982caa4.jpeg"> 
 <p>商务合作方式：撰稿、出书、培训、在线课程、合伙创业、咨询、广告合作。</p> 
 <h4>参考资料</h4> 
 <p>[1] </p> 
 <p>Go 1.23版本: <em>https://github.com/golang/go/milestone/212</em></p> 
 [2]  
 <p>Go playground: <em>https://go.dev/play/</em></p> 
 [3]  
 <p>《Go语言第一课》: <em>http://gk.link/a/10AVZ</em></p> 
 [4]  
 <p>03｜配好环境：选择一种最适合你的Go安装方法: <em>https://time.geekbang.org/column/article/427489</em></p> 
 [5]  
 <p>Go Release cycle: <em>https://go.dev/wiki/Go-Release-Cycle</em></p> 
 [6]  
 <p>61405: <em>https://github.com/golang/go/issues/61405</em></p> 
 [7]  
 <p>Go 1.22版本: <em>https://tonybai.com/2024/02/18/some-changes-in-go-1-22/</em></p> 
 [8]  
 <p>range over func: <em>https://go.dev/wiki/RangefuncExperiment</em></p> 
 [9]  
 <p>Go编译器的实现源码rewrite.go: <em>https://github.com/golang/go/blob/master/src/cmd/compile/internal/rangefunc/rewrite.go</em></p> 
 [10]  
 <p>issue 65236: <em>https://github.com/golang/go/issues/65236</em></p> 
 [11]  
 <p>issue 65237: <em>https://github.com/golang/go/issues/65237</em></p> 
 [12]  
 <p>明确依赖常量的包级变量初始化时的次序(issue 66575): <em>https://github.com/golang/go/issues/66575</em></p> 
 [13]  
 <p>Go 1.22引入的包级变量初始化次序问题: <em>https://tonybai.com/2024/03/29/the-issue-in-pkg-level-var-init-order-in-go-1-22/</em></p> 
 [14]  
 <p>go spec: <em>https://go.dev/ref/spec</em></p> 
 [15]  
 <p>禁止匿名接口类型的循环定义(issue 56103): <em>https://github.com/golang/go/issues/56103</em></p> 
 [16]  
 <p>PGO(Profile Guided Optimization): <em>https://go.dev/doc/pgo</em></p> 
 [17]  
 <p>issue 58102: <em>https://github.com/golang/go/issues/58102</em></p> 
 [18]  
 <p>67401: <em>https://github.com/golang/go/issues/67401</em></p> 
 [19]  
 <p>issue 31222: <em>https://github.com/golang/go/issues/31222</em></p> 
 [20]  
 <p>issue 44343: <em>https://github.com/golang/go/issues/44343</em></p> 
 [21]  
 <p>issue 42888: <em>https://github.com/golang/go/issues/42888</em></p> 
 [22]  
 <p>issue 61502: <em>https://github.com/golang/go/issues/61502</em></p> 
 [23]  
 <p>issue 67111: <em>https://github.com/golang/go/issues/67111</em></p> 
 [24]  
 <p>四篇有关Go Telemetry的文章: <em>https://research.swtch.com/telemetry</em></p> 
 [25]  
 <p>Go Telemetry对基于数据驱动进行Go演进决策的重要性: <em>https://tonybai.com/2023/12/10/go-changes/</em></p> 
 [26]  
 <p>golang.org/x/telemetry实验项目: <em>https://github.com/golang/telemetry</em></p> 
 [27]  
 <p>issue 62067: <em>https://github.com/golang/go/issues/62067</em></p> 
 [28]  
 <p>issue 62047: <em>https://github.com/golang/go/issues/62067</em></p> 
 [29]  
 <p>issue 61542: <em>https://github.com/golang/go/issues/61542</em></p> 
 [30]  
 <p>issue 37196: <em>https://github.com/golang/go/issues/37196</em></p> 
 [31]  
 <p>issue 62483: <em>https://github.com/golang/go/issues/62483</em></p> 
 [32]  
 <p>go4.org/intern: <em>https://github.com/go4org/intern</em></p> 
 [33]  
 <p>这里: <em>https://github.com/bigwhite/experiments/tree/master/go1.23-foresight</em></p> 
 [34]  
 <p>Go 1.23版本里程碑: <em>https://github.com/golang/go/milestone/212</em></p> 
 [35]  
 <p>Next Release Notes Draft: <em>https://tip.golang.org/doc/next</em></p> 
 [36]  
 <p>Go Release Dashboard: <em>https://dev.golang.org/release</em></p> 
 [37]  
 <p>Gopher部落知识星球: <em>https://public.zsxq.com/groups/51284458844544</em></p> 
 [38]  
 <p>链接地址: <em>https://m.do.co/c/bff6eed92687</em></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4e632a092c19035743f651053f200fc2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【C&#43;&#43;初阶】C&#43;&#43;模板编程入门：探索泛型编程的奥秘</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3418920ddc816d37b32c49d39fd7d12b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Web程序设计-实验05 DOM与BOM编程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>