<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>和日期相关的代码和bug——一道力扣题中的小发现 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/57631f1c76b94c412dcc3d1ffe16d10b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="和日期相关的代码和bug——一道力扣题中的小发现">
  <meta property="og:description" content="目录
Day of the Week
题目大意
常规方法
Python代码
Golang代码
C&#43;&#43;代码
基姆拉尔森公式
Python代码
Golang代码
C&#43;&#43;代码
使用库函数
Python代码
Golang代码
C&#43;&#43;代码
Day of the Week Given a date, return the corresponding day of the week for that date.
The input is given as three integers representing the day , month and year respectively.
Return the answer as one of the following values {&#34;Sunday&#34;, &#34;Monday&#34;, &#34;Tuesday&#34;, &#34;Wednesday&#34;, &#34;Thursday&#34;, &#34;Friday&#34;, &#34;Saturday&#34;} .
Example 1:">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-02-23T06:30:00+08:00">
    <meta property="article:modified_time" content="2023-02-23T06:30:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">和日期相关的代码和bug——一道力扣题中的小发现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="500" src="https://images2.imgbox.com/40/c7/hXIhaWmw_o.png" width="800"></h2> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="Day%20of%20the%20Week-toc" style="margin-left:0px;"><a href="#Day%20of%20the%20Week" rel="nofollow">Day of the Week</a></p> 
<p id="%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F-toc" style="margin-left:40px;"><a href="#%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F" rel="nofollow">题目大意</a></p> 
<p id="%E5%B8%B8%E8%A7%84%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#%E5%B8%B8%E8%A7%84%E6%96%B9%E6%B3%95" rel="nofollow">常规方法</a></p> 
<p id="Python%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#Python%E4%BB%A3%E7%A0%81" rel="nofollow">Python代码</a></p> 
<p id="Golang%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#Golang%E4%BB%A3%E7%A0%81" rel="nofollow">Golang代码</a></p> 
<p id="%C2%A0C%2B%2B%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%C2%A0C%2B%2B%E4%BB%A3%E7%A0%81" rel="nofollow"> C++代码</a></p> 
<p id="%E5%9F%BA%E5%A7%86%E6%8B%89%E5%B0%94%E6%A3%AE%E5%85%AC%E5%BC%8F-toc" style="margin-left:40px;"><a href="#%E5%9F%BA%E5%A7%86%E6%8B%89%E5%B0%94%E6%A3%AE%E5%85%AC%E5%BC%8F" rel="nofollow">基姆拉尔森公式</a></p> 
<p id="Python%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#Python%E4%BB%A3%E7%A0%81" rel="nofollow">Python代码</a></p> 
<p id="Golang%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#Golang%E4%BB%A3%E7%A0%81" rel="nofollow">Golang代码</a></p> 
<p id="C%2B%2B%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#C%2B%2B%E4%BB%A3%E7%A0%81" rel="nofollow">C++代码</a></p> 
<p id="%E4%BD%BF%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E4%BD%BF%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0" rel="nofollow">使用库函数</a></p> 
<p id="Python%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#Python%E4%BB%A3%E7%A0%81" rel="nofollow">Python代码</a></p> 
<p id="Golang%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#Golang%E4%BB%A3%E7%A0%81" rel="nofollow">Golang代码</a></p> 
<p id="C%2B%2B%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#C%2B%2B%E4%BB%A3%E7%A0%81" rel="nofollow">C++代码</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="Day%20of%20the%20Week">Day of the Week</h2> 
<p>Given a date, return the corresponding day of the week for that date.<br> The input is given as three integers representing the day , month and year respectively.<br> Return the answer as one of the following values {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"} .</p> 
<p>Example 1:<br> Input: day = 31, month = 8, year = 2019<br> Output: "Saturday"<br> Example 2:<br> Input: day = 18, month = 7, year = 1999<br> Output: "Sunday"<br> Example 3:<br> Input: day = 15, month = 8, year = 1993<br> Output: "Sunday"</p> 
<h3 id="%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F">题目大意</h3> 
<p>给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。<br> 输入为三个整数： day、 month 和 year，分别表示日、月、年。<br> 您返回的结果必须是这几个值中的一个 {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday",<br> "Friday", "Saturday"}。<br> 提示：<br> 给出的日期一定是在 1971 到 2100 年之间的有效日期。<br> 解题思路：<br> 给出一个日期，要求算出这一天是星期几。</p> 
<h3 id="%E5%B8%B8%E8%A7%84%E6%96%B9%E6%B3%95">常规方法</h3> 
<p>从1971.1.1起，先累计整年year、整月month-1的天数，再加上最后一个月month的天数day，然后总天数减1后与7求余。最后得到的余数在星期字串数组中位置索引，显然前提要知道1971.1.1这个基准日期是星期几，再作一个索引位移就是答案。</p> 
<p>另外常规方法还需要判断year是否闰年，规则：y%4==0 and y%100!=0 or y%400==0，据说是1582</p> 
<p></p> 
<h4 id="Python%E4%BB%A3%E7%A0%81">Python代码</h4> 
<p>python代码非常简单，不需另外导入库只用内置函数就能搞定。</p> 
<pre><code class="language-python">class Solution(object):
    def DayOfWeek(self, year, month, day):
        days = 0
        isLeapYear = lambda y:y%4==0 and y%100!=0 or y%400==0
        monthday = [31,28,31,30,31,30,31,31,30,31,30,31]
        week = ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"]
        monthday[1] = 29 if isLeapYear(year) else 28
        for i in range(1971,year):
            days += 366 if isLeapYear(i) else 365
        days += sum(monthday[:month-1], day-1)
        return week[(days+5)%7]

if __name__ == "__main__":
    s = Solution()
    print(s.DayOfWeek(2019,8,31))
    print(s.DayOfWeek(1999,7,18))
    print(s.DayOfWeek(1993,8,15))
	
    print(s.DayOfWeek(1971,6,12))
    print(s.DayOfWeek(2023,2,22))
    print(s.DayOfWeek(2040,6,13))</code></pre> 
<p><strong>输出：</strong></p> 
<blockquote> 
 <p>Saturday<br> Sunday<br> Sunday<br> Saturday<br> Wednesday<br> Wednesday</p> 
</blockquote> 
<h4 id="Golang%E4%BB%A3%E7%A0%81">Golang代码</h4> 
<p>基本原理相同，另外自定义一个数组求和公式即可。</p> 
<pre><code class="language-Go">package main

import "fmt"

func DayOfWeek(year int, month int, day int) string {
	days := 0
	isLeapYear := func(y int) bool {
		return y%4 == 0 &amp;&amp; y%100 != 0 || y%400 == 0
	}
	Sum := func(nums []int, initNum int) int {
		var sumNum int = 0
		for _, num := range nums {
			sumNum += num
		}
		return sumNum + initNum
	}
	monthday := []int{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
	week := []string{"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}
	if isLeapYear(year) {
		monthday[1] = 29
	} else {
		monthday[1] = 28
	}
	for i := 1971; i &lt; year; i++ {
		if isLeapYear(i) {
			days += 366
		} else {
			days += 365
		}
	}
	days += Sum(monthday[:month-1], day-1)
	return week[(days+5)%7]
}

func main() {

	fmt.Println(DayOfWeek(2019, 8, 31))
	fmt.Println(DayOfWeek(1999, 7, 18))
	fmt.Println(DayOfWeek(1993, 8, 15))

	fmt.Println(DayOfWeek(1971, 6, 12))
	fmt.Println(DayOfWeek(2023, 2, 22))
	fmt.Println(DayOfWeek(2040, 6, 13))

}</code></pre> 
<p><strong>输出：</strong></p> 
<blockquote> 
 <p>Saturday</p> 
 <p>Sunday</p> 
 <p>Sunday</p> 
 <p>Saturday</p> 
 <p>Wednesday</p> 
 <p>Wednesday</p> 
 <p>成功: 进程退出代码 0.</p> 
</blockquote> 
<h4 id="%C2%A0C%2B%2B%E4%BB%A3%E7%A0%81"> C++代码</h4> 
<p>引入C++11的容器vector，可以省掉最后一个非整年的各月份日数循环累加，只要用&lt;numeric&gt;库中的函数accumulate，方便累加非整年的各月份日数，并且把day作为基准数一并累加掉。</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;numeric&gt;
using namespace std;

class Solution
{
public:
    string DayOfWeek(int year, int month, int day)
    {
		int days = 0;
		auto isLeapYear = [](int y) { return y%4==0 &amp;&amp; y%100!=0 || y%400==0; };
        vector&lt;int&gt; monthday = {31,28,31,30,31,30,31,31,30,31,30,31};
        vector&lt;string&gt; week = {"Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"};
		monthday[1] = isLeapYear(year) ? 29 : 28;
		for (int i=1971;i&lt;year;i++)
			days += isLeapYear(i) ? 366 : 365;
		days += accumulate(monthday.begin(), monthday.begin()+month-1, day-1);
        return week[(days+5)%7];
    }
};

int main()
{
	Solution s;
	
	cout &lt;&lt; s.DayOfWeek(2019,8,31) &lt;&lt; endl;
	cout &lt;&lt; s.DayOfWeek(1999,7,18) &lt;&lt; endl;
	cout &lt;&lt; s.DayOfWeek(1993,8,15) &lt;&lt; endl;
	
	cout &lt;&lt; s.DayOfWeek(1971,6,12) &lt;&lt; endl;
	cout &lt;&lt; s.DayOfWeek(2023,2,22) &lt;&lt; endl;
	cout &lt;&lt; s.DayOfWeek(2040,6,13) &lt;&lt; endl;
	
	return 0;
}</code></pre> 
<p>Dev C++ 6.3 编译通过：</p> 
<blockquote> 
 <p>Saturday<br> Sunday<br> Sunday<br> Saturday<br> Wednesday<br> Wednesday</p> 
 <p>--------------------------------<br> Process exited after 0.02175 seconds with return value 0<br> 请按任意键继续. . .</p> 
</blockquote> 
<p> </p> 
<h3 id="%E5%9F%BA%E5%A7%86%E6%8B%89%E5%B0%94%E6%A3%AE%E5%85%AC%E5%BC%8F">基姆拉尔森公式</h3> 
<p>万能的日期计算公式，不用知道基准日是哪一天，也不需要判断year是否为闰年。</p> 
<p><strong>公式：</strong>weekday = (day+2month+3(month+1)/5+year+year/4-year/100+year/400+1)%7</p> 
<p><strong>注意：1月和2月需看做上一年的13月与14月</strong>，即 month&lt;3时， year-=1; month+=12</p> 
<h4>Python代码</h4> 
<pre><code class="language-python">class Solution(object):
    def DayOfWeek(self, year, month, day):
        week = ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"]
        if month&lt;3: year, month = year-1, month+12
        weekday = (day+2*month+3*(month+1)//5+year+year//4-year//100+year//400+1)%7
        return dict(zip(range(7),week)).get(weekday)

if __name__ == "__main__":
    s = Solution()
    print(s.DayOfWeek(2019,8,31))
    print(s.DayOfWeek(1999,7,18))
    print(s.DayOfWeek(1993,8,15))
	
    print(s.DayOfWeek(1971,6,12))
    print(s.DayOfWeek(2023,2,22))
    print(s.DayOfWeek(2040,6,13))</code></pre> 
<h4>Golang代码</h4> 
<pre><code class="language-Go">package main

import "fmt"

func DayOfWeek(year int, month int, day int) string {
	week := []string{"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}
	if month &lt; 3 {
		year -= 1
		month += 12
	}
	weekday := (day + 2*month + 3*(month+1)/5 + year + year/4 - year/100 + year/400 + 1) % 7
	return week[weekday]
}

func main() {

	fmt.Println(DayOfWeek(2019, 8, 31))
	fmt.Println(DayOfWeek(1999, 7, 18))
	fmt.Println(DayOfWeek(1993, 8, 15))

	fmt.Println(DayOfWeek(1971, 6, 12))
	fmt.Println(DayOfWeek(2023, 2, 22))
	fmt.Println(DayOfWeek(2040, 6, 13))

}</code></pre> 
<h4 id="C%2B%2B%E4%BB%A3%E7%A0%81">C++代码</h4> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;

class Solution
{
public:
    string DayOfWeek(int year, int month, int day)
    {
        const char *week[7] = {"Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"};
		if (month &lt; 3) {
		        year -= 1;
		        month += 12;
		    } 
    	int weekday = (day+2*month+3*(month+1)/5+year+year/4-year/100+year/400+1)%7;
	    return week[weekday];
    }
};

int main()
{
	Solution s;
	
	cout &lt;&lt; s.DayOfWeek(2019,8,31) &lt;&lt; endl;
	cout &lt;&lt; s.DayOfWeek(1999,7,18) &lt;&lt; endl;
	cout &lt;&lt; s.DayOfWeek(1993,8,15) &lt;&lt; endl;
	
	cout &lt;&lt; s.DayOfWeek(1971,6,12) &lt;&lt; endl;
	cout &lt;&lt; s.DayOfWeek(2023,2,22) &lt;&lt; endl;
	cout &lt;&lt; s.DayOfWeek(2040,6,13) &lt;&lt; endl;
	
	return 0;
}</code></pre> 
<p> </p> 
<h3 id="%E4%BD%BF%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0">使用库函数</h3> 
<h4>Python代码</h4> 
<p><strong>datetime库</strong></p> 
<pre><code class="language-python">import datetime

class Solution(object):
    def DayOfWeek(self, year, month, day):
        week = ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"]
        weekday = datetime.date(year,month,day).isoweekday()
        return week[weekday%7]

if __name__ == "__main__":
    s = Solution()
    print(s.DayOfWeek(2019,8,31))
    print(s.DayOfWeek(1999,7,18))
    print(s.DayOfWeek(1993,8,15))
	
    print(s.DayOfWeek(1971,6,12))
    print(s.DayOfWeek(2023,2,22))
    print(s.DayOfWeek(2040,6,13))</code></pre> 
<p><strong>calendar库 </strong></p> 
<pre><code class="language-python">import calendar

class Solution(object):
    def DayOfWeek(self, year, month, day):
        week = ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"]
        weekday = calendar.weekday(year,month,day)+1
        return week[weekday%7]

if __name__ == "__main__":
    s = Solution()
    print(s.DayOfWeek(2019,8,31))
    print(s.DayOfWeek(1999,7,18))
    print(s.DayOfWeek(1993,8,15))
	
    print(s.DayOfWeek(1971,6,12))
    print(s.DayOfWeek(2023,2,22))
    print(s.DayOfWeek(2040,6,13))</code></pre> 
<p></p> 
<h4>Golang代码</h4> 
<p><strong>time库</strong>，超级省事，连星期数组都不用了。</p> 
<pre><code class="language-Go">package main

import (
	"fmt"
	"time"
)

func DayOfWeek(year int, month int, day int) string {
	return time.Date(year, time.Month(month), day, 0, 0, 0, 0, time.Local).Weekday().String()
}

func main() {

	fmt.Println(DayOfWeek(2019, 8, 31))
	fmt.Println(DayOfWeek(1999, 7, 18))
	fmt.Println(DayOfWeek(1993, 8, 15))

	fmt.Println(DayOfWeek(1971, 6, 12))
	fmt.Println(DayOfWeek(2023, 2, 22))
	fmt.Println(DayOfWeek(2040, 6, 13))

}</code></pre> 
<h4>C++代码</h4> 
<p><strong>ctime库</strong></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;ctime&gt;
using namespace std;

class Solution
{
public:
    string DayOfWeek(int year, int month, int day)
    {
        const char *week[7] = {"Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"};
	    struct tm t = {0};
	    t.tm_year = year - 1900;
	    t.tm_mon = month - 1;
	    t.tm_mday = day;
	    mktime(&amp;t);
	    return week[t.tm_wday%7];
    }
};

int main()
{
	Solution s;
	
	cout &lt;&lt; s.DayOfWeek(2019,8,31) &lt;&lt; endl;
	cout &lt;&lt; s.DayOfWeek(1999,7,18) &lt;&lt; endl;
	cout &lt;&lt; s.DayOfWeek(1993,8,15) &lt;&lt; endl;
	
	cout &lt;&lt; s.DayOfWeek(1971,6,12) &lt;&lt; endl;
	cout &lt;&lt; s.DayOfWeek(2023,2,22) &lt;&lt; endl;
	cout &lt;&lt; s.DayOfWeek(2040,6,13) &lt;&lt; endl;

	return 0;
}</code></pre> 
<p><strong>输出：</strong></p> 
<blockquote> 
 <p>Saturday<br> Sunday<br> Sunday<br> Saturday<br> Wednesday<br><span style="color:#fe2c24;">Sunday</span></p> 
 <p>--------------------------------<br> Process exited after 0.02402 seconds with return value 0<br> 请按任意键继续. . .</p> 
</blockquote> 
<p><span style="color:#fe2c24;"><strong>发现没？ 2040.6.13返回的星期是错的！</strong></span></p> 
<p>网上查了资料，原来ctime库的CTime对象是有指定范围的：</p> 
<blockquote> 
 <p>static CTime WINAPI GetCurrentTime( );<br> 获取系统当前日期和时间。</p> 
 <p>返回表示当前日期和时间的CTime对象。<br> int GetYear( ) const；<br> 获取CTime对象表示时间的年份。</p> 
 <p>范围从1970年1月1日到2038年1月18日。</p> 
</blockquote> 
<p><strong>时间范围测试：</strong></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;ctime&gt;
using namespace std;

class Solution
{
public:
    string DayOfWeek(int year, int month, int day)
    {
        const char *week[7] = {"Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"};
	    struct tm t = {0};
	    t.tm_year = year - 1900;
	    t.tm_mon = month - 1;
	    t.tm_mday = day;
	    mktime(&amp;t);
	    return week[t.tm_wday%7];
    }
};

int main()
{
	Solution s;
	for (int i=16;i&lt;25;i++)
		cout &lt;&lt; i &lt;&lt; ":" &lt;&lt; s.DayOfWeek(2038,1,i) &lt;&lt; endl;

	return 0;
}</code></pre> 
<p><strong>测试结果：</strong></p> 
<blockquote> 
 <p>16:Saturday<br> 17:Sunday<br> 18:Monday<br> 19:Tuesday<br> 20:Sunday<br> 21:Sunday<br> 22:Sunday<br> 23:Sunday<br> 24:Sunday</p> 
 <p>--------------------------------<br> Process exited after 0.05159 seconds with return value 0<br> 请按任意键继续. . .</p> 
</blockquote> 
<p>2038.1.19日的星期也对，之后的全部返回Sunday。</p> 
<hr> 
<p>修改这个问题，技术上一点问题都没有。 目前C++都发展到C++20了，而我用的是C++11，暂不知道之后版本的库文件有没有对此问题作过更新。那么，问题来了：</p> 
<p><strong>之前用C语言写的的软件，用ctime或者time.h获取时间的软件在2038年1月19日之后都会发生错误。<span style="color:#fe2c24;">还好，还有整整15年时间来改正这个“时间Bug”。</span></strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/70d5938ae03705a00b306513b4dfa7bd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CSS字体样式（font）[详细]</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5179f68ccbd6c7107c73dad038b61944/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">BMS电池管理系统中的各种算法介绍</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>