<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>小游戏贪吃蛇的实现之C语言版 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/c1fd4bb4ecfbc63b3b726fcd1e220fb7/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="小游戏贪吃蛇的实现之C语言版">
  <meta property="og:description" content="找往期文章包括但不限于本期文章中不懂的知识点：
个人主页：我要学编程(ಥ_ಥ)-CSDN博客
所属专栏：C语言
游戏演示：
贪吃蛇游戏演示
目录
游戏前期准备：
设置控制台相关的信息 GetStdHandle
GetConsoleCursorInfo SetConsoleCursorInfo
SetConsoleCursorPosition
GetAsyncKeyState
贪吃蛇游戏设计与分析 本地化
地图，食物和蛇身的设计 GameStart（）—— 游戏的初始化
打印欢迎界面 绘制贪吃蛇地图 初始化贪吃蛇
初始化食物
GameRun（）——游戏的运行
打印右侧的帮助信息
贪吃蛇的相关运行信息 GameOver（）——游戏的结束（善后工作） 贪吃蛇源码 使用C语言在Windows环境的控制台中模拟实现经典小游戏贪吃蛇。
游戏前期准备： 本次实现贪吃蛇会使用到的一些Win32 API知识，接下来我们就学习一下。
背景介绍：
Windows 这个多作业系统除了协调应用程序的执行、分配内存、管理资源之外， 它同时也是一个很大的服务中心，调用这个服务中心的各种服务（每一种服务就是一个函数），可以帮应用程序达到开启视窗、描绘图形、使用周边设备等目的，由于这些函数服务的对象是应用程序(Application)， 所以便称之为 Application Programming Interface，简称 API 函数。WIN32 API也就是Microsoft Windows 32位平台的应用程序编程接口。
设置控制台相关的信息 平常我们运行起来的黑框程序其实就是控制台程序（如下图所示）。
我们可以使用cmd命令来设置控制台窗口的长宽。例如：设置控制台窗口的大小，30行，100列。 //格式： 列 行 mode con cols=100 lines=30 注意：
1. 列和行在赋值时，不能带有空格。例如：cols = 100，这就是不行的，没有影响到控制台的大小。
2. 使用这个命令之前，需要把这个控制台改为让Windows决定或者Windows 控制台主机
演示：
改变VS编译器的控制台
3. 使用system函数所需要包含的头文件既可以是stdlib.h，也可以是Windows.h(不分大小写的，因此可以使用&#34;windows.h&#34;、&#34;WINDOWS.H&#34;或者&#34;Windows.h&#34;等形式来引用该头文件。不过，一般约定使用&#34;Windows.h&#34;的形式来引用该头文件，以保持代码的一致性和可读性。) 下面就来使用这个来改变控制台的大小。
从上面的结果来看：行列对应不一致。没错，一行的宽度是一列的宽度的二倍。
也可以通过命令设置控制台窗口的名字： //格式： title 要修改的名字 注意：在更改之后要观察到的话，就不能让程序运行结束，也就是说只能在程序运行期间才能够观察的到。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-23T12:32:16+08:00">
    <meta property="article:modified_time" content="2024-04-23T12:32:16+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">小游戏贪吃蛇的实现之C语言版</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>找往期文章包括但不限于本期文章中不懂的知识点：</p> 
<blockquote> 
 <p>个人主页：<a href="https://blog.csdn.net/2301_80854132?type=blog" title="我要学编程(ಥ_ಥ)-CSDN博客">我要学编程(ಥ_ಥ)-CSDN博客</a></p> 
 <p>所属专栏：<a class="link-info" href="https://blog.csdn.net/2301_80854132/category_12525962.html" title="C语言">C语言</a></p> 
</blockquote> 
<p>游戏演示：</p> 
<div class="csdn-video-box"> 
 <iframe id="FspxCY2r-1713845968811" frameborder="0" src="https://live.csdn.net/v/embed/381028" allowfullscreen="true" data-mediaembed="csdn"></iframe> 
 <p>贪吃蛇游戏演示</p> 
</div> 
<p></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E6%B8%B8%E6%88%8F%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E6%B8%B8%E6%88%8F%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87%EF%BC%9A" rel="nofollow">游戏前期准备：</a></p> 
<p id="%E8%AE%BE%E7%BD%AE%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%9B%B8%E5%85%B3%E7%9A%84%E4%BF%A1%E6%81%AF%C2%A0-toc" style="margin-left:40px;"><a href="#%E8%AE%BE%E7%BD%AE%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%9B%B8%E5%85%B3%E7%9A%84%E4%BF%A1%E6%81%AF%C2%A0" rel="nofollow">设置控制台相关的信息 </a></p> 
<p id="GetStdHandle-toc" style="margin-left:40px;"><a href="#GetStdHandle" rel="nofollow">GetStdHandle</a></p> 
<p id="GetConsoleCursorInfo%C2%A0-toc" style="margin-left:40px;"><a href="#GetConsoleCursorInfo%C2%A0" rel="nofollow">GetConsoleCursorInfo </a></p> 
<p id="SetConsoleCursorInfo-toc" style="margin-left:40px;"><a href="#SetConsoleCursorInfo" rel="nofollow">SetConsoleCursorInfo</a></p> 
<p id="SetConsoleCursorPosition-toc" style="margin-left:40px;"><a href="#SetConsoleCursorPosition" rel="nofollow">SetConsoleCursorPosition</a></p> 
<p id="GetAsyncKeyState-toc" style="margin-left:40px;"><a href="#GetAsyncKeyState" rel="nofollow">GetAsyncKeyState</a></p> 
<p id="%E8%B4%AA%E5%90%83%E8%9B%87%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%C2%A0-toc" style="margin-left:0px;"><a href="#%E8%B4%AA%E5%90%83%E8%9B%87%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%C2%A0" rel="nofollow">贪吃蛇游戏设计与分析 </a></p> 
<p id="%3Clocale.h%3E%E6%9C%AC%E5%9C%B0%E5%8C%96-toc" style="margin-left:40px;"><a href="#%3Clocale.h%3E%E6%9C%AC%E5%9C%B0%E5%8C%96" rel="nofollow">本地化</a></p> 
<p id="%E5%9C%B0%E5%9B%BE%EF%BC%8C%E9%A3%9F%E7%89%A9%E5%92%8C%E8%9B%87%E8%BA%AB%E7%9A%84%E8%AE%BE%E8%AE%A1%C2%A0-toc" style="margin-left:40px;"><a href="#%E5%9C%B0%E5%9B%BE%EF%BC%8C%E9%A3%9F%E7%89%A9%E5%92%8C%E8%9B%87%E8%BA%AB%E7%9A%84%E8%AE%BE%E8%AE%A1%C2%A0" rel="nofollow">地图，食物和蛇身的设计 </a></p> 
<p id="GameStart%EF%BC%88%EF%BC%89%E2%80%94%E2%80%94%20%E6%B8%B8%E6%88%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:40px;"><a href="#GameStart%EF%BC%88%EF%BC%89%E2%80%94%E2%80%94%20%E6%B8%B8%E6%88%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">GameStart（）—— 游戏的初始化</a></p> 
<p id="%E6%89%93%E5%8D%B0%E6%AC%A2%E8%BF%8E%E7%95%8C%E9%9D%A2%C2%A0-toc" style="margin-left:80px;"><a href="#%E6%89%93%E5%8D%B0%E6%AC%A2%E8%BF%8E%E7%95%8C%E9%9D%A2%C2%A0" rel="nofollow">打印欢迎界面 </a></p> 
<p id="%E7%BB%98%E5%88%B6%E8%B4%AA%E5%90%83%E8%9B%87%E5%9C%B0%E5%9B%BE%C2%A0-toc" style="margin-left:80px;"><a href="#%E7%BB%98%E5%88%B6%E8%B4%AA%E5%90%83%E8%9B%87%E5%9C%B0%E5%9B%BE%C2%A0" rel="nofollow">绘制贪吃蛇地图 </a></p> 
<p id="%E5%88%9D%E5%A7%8B%E5%8C%96%E8%B4%AA%E5%90%83%E8%9B%87-toc" style="margin-left:80px;"><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E8%B4%AA%E5%90%83%E8%9B%87" rel="nofollow">初始化贪吃蛇</a></p> 
<p id="%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A3%9F%E7%89%A9-toc" style="margin-left:80px;"><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A3%9F%E7%89%A9" rel="nofollow">初始化食物</a></p> 
<p id="GameRun%EF%BC%88%EF%BC%89%E2%80%94%E2%80%94%E6%B8%B8%E6%88%8F%E7%9A%84%E8%BF%90%E8%A1%8C-toc" style="margin-left:40px;"><a href="#GameRun%EF%BC%88%EF%BC%89%E2%80%94%E2%80%94%E6%B8%B8%E6%88%8F%E7%9A%84%E8%BF%90%E8%A1%8C" rel="nofollow">GameRun（）——游戏的运行</a></p> 
<p id="%E6%89%93%E5%8D%B0%E5%8F%B3%E4%BE%A7%E7%9A%84%E5%B8%AE%E5%8A%A9%E4%BF%A1%E6%81%AF-toc" style="margin-left:80px;"><a href="#%E6%89%93%E5%8D%B0%E5%8F%B3%E4%BE%A7%E7%9A%84%E5%B8%AE%E5%8A%A9%E4%BF%A1%E6%81%AF" rel="nofollow">打印右侧的帮助信息</a></p> 
<p id="%E8%B4%AA%E5%90%83%E8%9B%87%E7%9A%84%E7%9B%B8%E5%85%B3%E8%BF%90%E8%A1%8C%E4%BF%A1%E6%81%AF%C2%A0-toc" style="margin-left:80px;"><a href="#%E8%B4%AA%E5%90%83%E8%9B%87%E7%9A%84%E7%9B%B8%E5%85%B3%E8%BF%90%E8%A1%8C%E4%BF%A1%E6%81%AF%C2%A0" rel="nofollow">贪吃蛇的相关运行信息 </a></p> 
<p id="GameOver%EF%BC%88%EF%BC%89%E2%80%94%E2%80%94%E6%B8%B8%E6%88%8F%E7%9A%84%E7%BB%93%E6%9D%9F%EF%BC%88%E5%96%84%E5%90%8E%E5%B7%A5%E4%BD%9C%EF%BC%89%C2%A0-toc" style="margin-left:40px;"><a href="#GameOver%EF%BC%88%EF%BC%89%E2%80%94%E2%80%94%E6%B8%B8%E6%88%8F%E7%9A%84%E7%BB%93%E6%9D%9F%EF%BC%88%E5%96%84%E5%90%8E%E5%B7%A5%E4%BD%9C%EF%BC%89%C2%A0" rel="nofollow">GameOver（）——游戏的结束（善后工作） </a></p> 
<p id="%E8%B4%AA%E5%90%83%E8%9B%87%E6%BA%90%E7%A0%81%C2%A0-toc" style="margin-left:0px;"><a href="#%E8%B4%AA%E5%90%83%E8%9B%87%E6%BA%90%E7%A0%81%C2%A0" rel="nofollow">贪吃蛇源码 </a></p> 
<hr id="hr-toc"> 
<p>使用C语言在Windows环境的控制台中模拟实现经典小游戏贪吃蛇。</p> 
<h2 id="%E6%B8%B8%E6%88%8F%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87%EF%BC%9A"><span style="color:#fe2c24;">游戏前期准备：</span></h2> 
<p> 本次实现贪吃蛇会使用到的一些Win32 API知识，接下来我们就学习一下。</p> 
<blockquote> 
 <p><strong>背景介绍</strong>：</p> 
 <p>Windows 这个多作业系统除了协调应用程序的执行、分配内存、管理资源之外， 它同时也是一个很大的服务中心，调用这个服务中心的各种服务（每一种服务就是一个函数），可以帮应用程序达到开启视窗、描绘图形、使用周边设备等目的，由于这些函数服务的对象是应用程序(Application)， 所以便称之为 Application Programming Interface，简称 API 函数。WIN32 API也就是Microsoft Windows 32位平台的应用程序编程接口。</p> 
</blockquote> 
<h3 id="%E8%AE%BE%E7%BD%AE%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%9B%B8%E5%85%B3%E7%9A%84%E4%BF%A1%E6%81%AF%C2%A0"><span style="color:#38d8f0;">设置控制台相关的信息 </span></h3> 
<p>平常我们运行起来的黑框程序其实就是控制台程序（如下图所示）。</p> 
<p><img alt="" height="1050" src="https://images2.imgbox.com/61/f0/fTKxdU4D_o.png" width="1200"></p> 
<p>我们可以使用cmd命令来设置<strong>控制台窗口的长宽</strong>。例如：设置控制台窗口的大小，30行，100列。 </p> 
<pre><code class="language-cs">//格式：  列        行
mode con cols=100 lines=30</code></pre> 
<p>注意：</p> 
<p>1. 列和行在赋值时，不能带有空格。例如：cols = 100，这就是不行的，没有影响到控制台的大小。</p> 
<p>2. 使用这个命令之前，需要把这个控制台改为<span style="color:#ff9900;">让Windows决定</span><span style="color:#0d0016;">或者</span><span style="color:#ff9900;">Windows 控制台主机</span></p> 
<p>演示：</p> 
<div class="csdn-video-box"> 
 <iframe id="mORBGuD9-1713713566022" frameborder="0" src="https://live.csdn.net/v/embed/380153" allowfullscreen="true" data-mediaembed="csdn"></iframe> 
 <p>改变VS编译器的控制台</p> 
</div> 
<p>3. 使用system函数所需要包含的头文件既可以是stdlib.h，也可以是Windows.h(不分大小写的，因此可以使用"windows.h"、"WINDOWS.H"或者"Windows.h"等形式来引用该头文件。不过，一般约定使用"Windows.h"的形式来引用该头文件，以保持代码的一致性和可读性。) </p> 
<p>下面就来使用这个来改变控制台的大小。</p> 
<p><img alt="" height="426" src="https://images2.imgbox.com/1f/41/5Qu2WOYn_o.png" width="1200"></p> 
<p>从上面的结果来看：行列对应不一致。没错，<span style="color:#ff9900;">一行的宽度是一列的宽度的二倍</span>。</p> 
<p>也可以通过命令<strong>设置控制台窗口的名字</strong>： </p> 
<pre><code class="language-cs">//格式：
title 要修改的名字
</code></pre> 
<p>注意：在更改之后要观察到的话，就不能让程序运行结束，也就是说只能在程序运行期间才能够观察的到。<img alt="" height="477" src="https://images2.imgbox.com/ec/70/cOJpEaTW_o.png" width="1074"></p> 
<p> <strong>控制台屏幕上的坐标COORD</strong></p> 
<p>COORD 是Windows API中定义的一个结构体，表示一个字符在控制台屏幕缓冲区上的坐标，坐标系 (0，0) 的原点位于缓冲区的顶部左侧单元格。 </p> 
<p><img alt="" height="1050" src="https://images2.imgbox.com/8c/12/HFFLtsC8_o.png" width="1200"></p> 
<p>COORD类型的声明：</p> 
<pre><code class="language-cs">typedef struct _COORD {
    SHORT X;//短整型
    SHORT Y;
} COORD, *PCOORD;
</code></pre> 
<p>给坐标赋值：</p> 
<pre><code class="language-cs">COORD pos = { 10, 15 };</code></pre> 
<h3 id="GetStdHandle"><span style="color:#38d8f0;">GetStdHandle</span></h3> 
<p>GetStdHandle是一个Windows API函数。它用于从一个特定的标准设备（标准输入、标准输出或标准错误）中取得一个句柄（用来标识不同设备的数值），使用这个句柄可以操作设备。</p> 
<p><strong>标准输入是指键盘，标准输出和标准错误是指屏幕。</strong></p> 
<p>这个句柄就类似一个遥控器，可以通过句柄来操作标准设备。而我们想要操作标准设备也得通过GetStdHandle这个函数来获得句柄。再通过句柄来操作。</p> 
<pre><code class="language-cs">HANDLE GetStdHandle(DWORD nStdHandle);</code></pre> 
<p><img alt="" height="1126" src="https://images2.imgbox.com/ba/50/SgvLNttT_o.png" width="1200"></p> 
<p>例如：</p> 
<pre><code class="language-cs">HANDLE hOutput = NULL;
//获取标准输出的句柄(⽤来标识不同设备的数值)
hOutput = GetStdHandle(STD_OUTPUT_HANDLE);</code></pre> 
<h3 id="GetConsoleCursorInfo%C2%A0"><span style="color:#38d8f0;"><strong>GetConsoleCursorInfo </strong></span></h3> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/12/b6/Ca4yY0K2_o.png" width="1200"></p> 
<p>检索有关指定控制台屏幕缓冲区的光标大小和可见性的信息。 </p> 
<pre><code class="language-cs">BOOL WINAPI GetConsoleCursorInfo(
 HANDLE hConsoleOutput,
 PCONSOLE_CURSOR_INFO lpConsoleCursorInfo
);
PCONSOLE_CURSOR_INFO 是指向 CONSOLE_CURSOR_INFO 结构的指针，该结构接收有关主机游标</code></pre> 
<p><strong>CONSOLE_CURSOR_INFO 这个结构体，包含有关控制台光标的信息。</strong></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/71/4e/BqVox1vd_o.png" width="1200"></p> 
<pre><code class="language-cs">typedef struct _CONSOLE_CURSOR_INFO {
    DWORD dwSize;//光标的宽度占比
    BOOL bVisible;//光标的可见性
} CONSOLE_CURSOR_INFO, *PCONSOLE_CURSOR_INFO;</code></pre> 
<p>举例：</p> 
<pre><code class="language-cs">HANDLE hOutput = NULL;
//获取标准输出的句柄(用来标识不同设备的数值)
hOutput = GetStdHandle(STD_OUTPUT_HANDLE);
CONSOLE_CURSOR_INFO CursorInfo = {0};
//获取控制台光标信息
GetConsoleCursorInfo(hOutput, &amp;CursorInfo);</code></pre> 
<h3 id="SetConsoleCursorInfo"><span style="color:#38d8f0;">SetConsoleCursorInfo</span></h3> 
<p>设置指定控制台屏幕缓冲区的光标的大小和可见性。</p> 
<pre><code class="language-cs">BOOL WINAPI SetConsoleCursorInfo(
    HANDLE hConsoleOutput,
    const CONSOLE_CURSOR_INFO *lpConsoleCursorInfo
);</code></pre> 
<p>举例：</p> 
<pre><code class="language-cs">//获取标准输出的句柄
HANDLE hOutput = GetStdHandle(STD_OUTPUT_HANDLE);
//定义一个存放光标信息的结构体
CONSOLE_CURSOR_INFO CursorInfo = {0};
//获取控制台光标信息存放到这个结构体中
GetConsoleCursorInfo(hOutput, &amp;CursorInfo);
//隐藏控制台光标
CursorInfo.bVisible = false; 
//把控制台光标大小调到最大
CursorInfo.dwSize = 100;
//设置控制台光标状态（按照上面的设置调）
SetConsoleCursorInfo(hOutput, &amp;CursorInfo);</code></pre> 
<h3 id="SetConsoleCursorPosition"><span style="color:#38d8f0;">SetConsoleCursorPosition</span></h3> 
<p>设置控制台屏幕缓冲区中的光标位置，我们将想要设置的坐标信息放在COORD类型的变量中，调 用SetConsoleCursorPosition函数将光标位置设置到指定的位置。 </p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/70/04/LLTyjEeM_o.png" width="1200"></p> 
<pre><code class="language-cs">BOOL WINAPI SetConsoleCursorPosition(
    HANDLE hConsoleOutput,
    COORD pos
);</code></pre> 
<p>举例：</p> 
<pre><code class="language-cs">//改变光标的位置
COORD pos = { 10, 5};
HANDLE hOutput = NULL;
//获取标准输出的句柄
hOutput = GetStdHandle(STD_OUTPUT_HANDLE);
//设置标准输出上光标的位置为pos
SetConsoleCursorPosition(hOutput, pos);</code></pre> 
<p>注意：这个pos的位置设置有可能不一定会成功。 </p> 
<h3 id="GetAsyncKeyState"><span style="color:#38d8f0;">GetAsyncKeyState</span></h3> 
<p>获取按键情况，GetAsyncKeyState的函数原型如下：</p> 
<pre><code class="language-cs">SHORT GetAsyncKeyState(int vKey);</code></pre> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/85/78/r7MyI3AS_o.png" width="1200"></p> 
<p>将键盘上每个键的虚拟键值传递给函数，函数通过返回值来分辨按键的状态。GetAsyncKeyState 的返回值是short类型，在上一次调用 GetAsyncKeyState 函数后，如果返回的16位的short数据中，最高位是1，说明按键的状态是按下，如果最高是0，说明按键的状态是抬起；如果最低位被置为1则说明，该按键被按过，否则为0。 如果我们要判断一个键是否被按过，可以检测GetAsyncKeyState返回值的最低位是否为1 。下面是虚拟键代码<a href="https://learn.microsoft.com/zh-cn/windows/win32/inputdev/virtual-key-codes" rel="nofollow" title="虚拟键码 (Winuser.h) - Win32 apps | Microsoft Learn">虚拟键码 (Winuser.h) - Win32 apps | Microsoft Learn</a><a class="link-info" href="https://learn.microsoft.com/zh-cn/windows/win32/inputdev/virtual-key-codes" rel="nofollow" title="虚拟键码">虚拟键码</a></p> 
<p>举例：检测数字键是否被摁过。（字母键上面的数字键）</p> 
<pre><code class="language-cs">//判断一个键是否被摁过
//如果被摁过结果就是1，否则就是0
#define KEY_PRESS(vk) ((GetAsyncKeyState(vk)&amp;0x1)?1:0)
int main()
{
	while (1)
	{
		if (KEY_PRESS(0x30))
		{
			printf("%d\n", 0);
		}
		else if (KEY_PRESS(0x31))
		{
			printf("%d\n", 1);
		}
		else if (KEY_PRESS(0x32))
		{
			printf("%d\n", 2);
		}
		else if (KEY_PRESS(0x33))
		{
			printf("%d\n", 3);
		}
		else if (KEY_PRESS(0x34))
		{
			printf("%d\n", 4);
		}
		else if (KEY_PRESS(0x35))
		{
			printf("%d\n", 5);
		}
		else if (KEY_PRESS(0x36))
		{
			printf("%d\n", 6);
		}
		else if (KEY_PRESS(0x37))
		{
			printf("%d\n", 7);
		}
		else if (KEY_PRESS(0x38))
		{
			printf("%d\n", 8);
		}
		else if (KEY_PRESS(0x39))
		{
			printf("%d\n", 9);
		}
	}
}</code></pre> 
<h2 id="%E8%B4%AA%E5%90%83%E8%9B%87%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%C2%A0"><span style="color:#fe2c24;">贪吃蛇游戏设计与分析 </span></h2> 
<blockquote> 
 <p>实现基本的功能：</p> 
 <p>• 贪吃蛇地图绘制</p> 
 <p>• 蛇吃食物的功能 （上、下、左、右方向键控制蛇的动作）</p> 
 <p>• 蛇撞墙死亡</p> 
 <p>• 蛇撞自身死亡</p> 
 <p>• 计算得分</p> 
 <p>• 蛇身加速、减速</p> 
 <p>• 暂停游戏</p> 
</blockquote> 
<p>在游戏地图上，我们打印墙体使用宽字符：□，打印蛇使用宽字符●，打印食物使用宽字符★</p> 
<p>普通的字符是占一个字节的，这类宽字符是占用2个字节。 </p> 
<p>加入了宽字符的类型 wchar_t 和宽字符的输入和输出函数，加入了&lt;locale.h&gt;头文件，其中提供了允许程序员针对特定地区（通常是国家或者说某种特定语言的地理区域）调整程序行为的函数。</p> 
<h3 id="%3Clocale.h%3E%E6%9C%AC%E5%9C%B0%E5%8C%96"><span style="color:#38d8f0;">&lt;locale.h&gt;本地化</span></h3> 
<p>setlocale函数原型：</p> 
<pre><code class="language-cs">char* setlocale (int category, const char* locale);</code></pre> 
<p>类项</p> 
<blockquote> 
 <p>通过修改地区，程序可以改变它的行为来适应世界的不同区域。但地区的改变可能会影响库的许多部分，其中一部分可能是我们不希望修改的。所以C语言支持针对不同的类项进行修改，下面的一个宏， 指定一个类项：</p> 
 <p>• LC_COLLATE：影响字符串比较函数 strcoll() 和 strxfrm() 。</p> 
 <p>• LC_CTYPE：影响字符处理函数的行为。</p> 
 <p>• LC_MONETARY：影响货币格式。</p> 
 <p>• LC_NUMERIC：影响 printf() 的数字格式。</p> 
 <p>• LC_TIME：影响时间格式 strftime() 和 wcsftime() 。</p> 
 <p>• LC_ALL - 针对所有类项修改，将以上所有类别设置为给定的语言环境。 </p> 
</blockquote> 
<p>setlocale 函数用于修改当前地区，可以针对一个类项修改，也可以针对所有类项。 setlocale 的第一个参数可以是前面说明的类项中的一个，那么每次只会影响一个类项，如果第一个参数是LC_ALL，就会影响所有的类项。 C标准给第二个参数仅定义了2种可能取值："C"（正常模式）和" "（本地模式）。 在任意程序执行开始，都会隐藏式执行调用：</p> 
<pre><code class="language-cs">setlocale(LC_ALL, "C");</code></pre> 
<p>当地区设置为"C"时，库函数按正常方式执行，小数点是一个点。 当程序运行起来后想改变地区，就只能显示调用setlocale函数。用" "作为第2个参数，调用setlocale 函数就可以切换到本地模式，这种模式下程序会适应本地环境。比如：切换到我们的本地模式后就支持宽字符（汉字）的输出等。 </p> 
<pre><code class="language-cs">setlocale(LC_ALL, "");//切换到本地环境（注意这里双引号里不能有空格）</code></pre> 
<p>那如果想在屏幕上打印宽字符，怎么打印呢？ 宽字符的字面量必须加上前缀“L”，否则 C 语言会把字面量当作窄字符类型处理。前缀“L”在单引号前面，表示宽字符，对应 wprintf() 的占位符为 %lc ；在双引号前面，表示宽字符串，对应 wprintf() 的占位符为 %ls 。</p> 
<p>举例：</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
#include &lt;locale.h&gt;
int main()
{
    //切换到本地环境
    setlocale(LC_ALL, "");
    wprintf(L"%s\n", L"我要学编程");

    wchar_t wc1 = L'我';
    wchar_t wc2 = L'要';
    wchar_t wc3 = L'学';
    wchar_t wc4 = L'编';
    wchar_t wc5 = L'程';
    wprintf(L"%lc", wc1);
    wprintf(L"%lc", wc2);
    wprintf(L"%lc", wc3);
    wprintf(L"%lc", wc4);
    wprintf(L"%lc", wc5);
    return 0;
}
</code></pre> 
<h3 id="%E5%9C%B0%E5%9B%BE%EF%BC%8C%E9%A3%9F%E7%89%A9%E5%92%8C%E8%9B%87%E8%BA%AB%E7%9A%84%E8%AE%BE%E8%AE%A1%C2%A0"><span style="color:#38d8f0;">地图，食物和蛇身的设计</span> </h3> 
<p>我们假设实现一个棋盘27行，58列的棋盘，再围绕地图画出墙。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/6a/df/w0bRuqYR_o.jpg"></p> 
<p>由于1行的宽度是一列宽度的二倍，就可以按照上面的样式绘制地图。这些都用宽字符来打印。</p> 
<p>初始化状态：假设蛇的长度是5，蛇身的每个节点是●，在固定的一个坐标处，比如(24, 5)处开始出现蛇，连续5个节点。 注意：<strong>蛇的每个节点的x坐标必须是2个倍数</strong>，否则可能会出现蛇的一个节点有一半出现在墙体中， 另外一半在墙外的现象。 关于食物，就是在墙体内随机生成一个坐标（x坐标必须是2的倍数），坐标不能和蛇的身体重合，然后打印★。<strong>食物的x坐标也要是2的倍数。</strong></p> 
<p>在游戏运行的过程中，蛇每次吃一个食物，蛇的身体就会变长一节，如果我们使用链表存储蛇的信 息，那么蛇的每一节其实就是链表的一个节点。每个节点只要记录好蛇身节点在地图上的坐标就行， 所以蛇节点结构如下： </p> 
<pre><code class="language-cs">//蛇身的节点类型
typedef struct SnakeNode
{
	//坐标
	int x;
	int y;
	//指向下一个节点的指针
	struct SnakeNode* next;
}SnakeNode, * pSnakeNode;</code></pre> 
<p>还得创建一些变量：指向蛇头的指针，初始时蛇的速度，蛇的方向，食物，食物分数，总分，贪吃蛇的状态。但是这些都比较麻烦，我们就创建一个贪吃蛇的结构体来管理这些变量。</p> 
<pre><code class="language-cs">//贪吃蛇
typedef struct Snake
{
	pSnakeNode _pSnake;//指向蛇头的指针
	pSnakeNode _pFood;//指向食物的指针
	DIRECTION _dir;//蛇的方向
	GAME_STATE _state;//游戏的运行状态
	int _FoodWeight;//一个食物的分数
	int _score;//总分数
	int _SleepTime;//休眠时间，时间越短，速度越快，时间越长，速度越慢
}Snake, * pSnake;
</code></pre> 
<p>蛇的方向有四种：上，下，左，右。我们就可以枚举出来。</p> 
<pre><code class="language-cs">//蛇的方向
typedef enum DIRECTION
{
	UP = 1,//上
	DOWN,//下
	LEFT,//左
	RIGHT//右
}DIRECTION;</code></pre> 
<p>游戏的运行状态：正常运行，正常退出，撞墙死亡，撞到自己死亡。</p> 
<pre><code class="language-cs">//游戏的状态
typedef enum GAME_STATE
{
	OK,//正常运行
	KILL_BY_WALL,//撞墙
	KILL_BY_SELF,//撞到自己
	END_NORMAL//正常退出
}GAME_STATE;</code></pre> 
<p>接下来就是正式的游戏设计。</p> 
<p>首先分装三个大的函数。</p> 
<h3 id="GameStart%EF%BC%88%EF%BC%89%E2%80%94%E2%80%94%20%E6%B8%B8%E6%88%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span style="color:#38d8f0;">GameStart（）—— 游戏的初始化</span></h3> 
<p>初始化的内容：1，打印欢迎界面  2，绘制贪吃蛇地图  3，初始化贪吃蛇和食物 。</p> 
<h4 id="%E6%89%93%E5%8D%B0%E6%AC%A2%E8%BF%8E%E7%95%8C%E9%9D%A2%C2%A0"><span style="color:#956fe7;">打印欢迎界面</span> </h4> 
<p><img alt="" height="1050" src="https://images2.imgbox.com/a4/2c/MYLz8nY2_o.png" width="1200"></p> 
<p>首先得分装一个函数用来定位坐标。</p> 
<pre><code class="language-cs">//定位光标
void SetPos(short x, short y)
{
	HANDLE houtput = GetStdHandle(STD_OUTPUT_HANDLE);//获取标准输出的句柄
	COORD pos = { x, y };
	SetConsoleCursorPosition(houtput, pos);//设置光标的位置
}</code></pre> 
<p>system("pause")是一个用于暂停控制台的函数。它会在控制台输出一个提示信息，等待用户按下任意键后才会继续执行程序。</p> 
<pre><code class="language-cs">system("pause");</code></pre> 
<p><img alt="" height="1050" src="https://images2.imgbox.com/dc/bc/OLzWLXlM_o.png" width="1200"></p> 
<p>由上面的界面切换到下面这个界面，就需要用到一个清理控制台界面的函数。 </p> 
<pre><code class="language-cs">system("cls");//用于清理当前控制台的界面所有信息</code></pre> 
<p>打印欢迎界面：</p> 
<pre><code class="language-cs">//打印欢迎界面
void WelcomToGame()
{
	//首先得定位光标
	SetPos(39, 10);
	printf("欢迎来到贪吃蛇小游戏\n");
	SetPos(40, 15);
	system("pause");//暂停
	system("cls");//清理屏幕

	SetPos(28, 10);
	printf("用↑.↓.←.→ 来控制蛇的移动！摁F3加速！摁F4减速！\n");
	SetPos(38, 11);
	printf("游戏即将开始，请做好准备！\n");
	SetPos(40, 15);
	system("pause");
	system("cls");
}</code></pre> 
<h4 id="%E7%BB%98%E5%88%B6%E8%B4%AA%E5%90%83%E8%9B%87%E5%9C%B0%E5%9B%BE%C2%A0"><span style="color:#956fe7;">绘制贪吃蛇地图</span> </h4> 
<p><img alt="" height="1050" src="https://images2.imgbox.com/b1/1b/fNYwe9od_o.png" width="1200"></p> 
<p>上面这个就是我们要绘制的地图。值得一提的是：这个方块是宽字符，而使用wprintf来打印宽字符就得先将C语言环境转化到本地环境。至于后面的打印，就是通过定位来循环打印。</p> 
<p>先打印上下两行，再打印左右两列。</p> 
<p>上一行的坐标是（2*i，0），i 的范围是0~28。  下一行的坐标是（2*i，25），i 的范围是0~28。 </p> 
<p>左一列的坐标是（0，i），i 的范围是1~25。      右一列的坐标是（56，i），i 的范围是1~25。</p> 
<p>注意：</p> 
<p>1. 一行的打印就相当于是打印了一列中的一个，因此用总列数-2就是我们要打印的列坐标。</p> 
<p>2. 列在打印时，需要先定位好坐标。因为打印的顺序是默认从左到右的；而我们是要实现从上到下的打印。</p> 
<pre><code class="language-cs">#define WALL L'□'


//绘制地图
void CreatMap()
{
	//打印上体墙
	for (int i = 0; i &lt;= 28; i++)
	{
		wprintf(L"%lc", WALL);
	}
	SetPos(0, 26);//定位到下体墙的位置
	//打印下体墙
	for (int i = 0; i &lt;= 28; i++)
	{
		wprintf(L"%lc", WALL);
	}
	//打印左体墙
	for (int i = 1; i &lt;= 25; i++)
	{
		SetPos(0, i);
		wprintf(L"%lc", WALL);//用换行不行，因此加不加换行无所谓
	}
	//打印右体墙
	for (int i = 1; i &lt;= 25; i++)
	{
		SetPos(56, i);
		wprintf(L"%lc", WALL);//用换行不行，因此加不加换行无所谓
	}
}</code></pre> 
<h4 id="%E5%88%9D%E5%A7%8B%E5%8C%96%E8%B4%AA%E5%90%83%E8%9B%87"><span style="color:#956fe7;">初始化贪吃蛇</span></h4> 
<p>既然要初始化蛇，首先就得有蛇，而蛇是用节点串起来的。因此我们只要创建5个节点，并且传入我们想要的坐标（我们想要蛇出现在哪个位置，这个位置最好是固定的，这里也是采用固定的位置。），最后把这些节点串起来就行了。</p> 
<pre><code class="language-cs">//创建一条蛇
pSnakeNode pcur = NULL;
pSnakeNode prev = NULL;
for (int i = 0; i &lt; 5; i++)
{
	pSnakeNode tmp = (pSnakeNode)malloc(sizeof(SnakeNode));
	if (tmp == NULL)
	{
		perror("InitSnake():malloc:");
		return;
	}
	pcur = tmp;
	pcur-&gt;x = POS_X + 2 * i;
	pcur-&gt;y = POS_Y;
	pcur-&gt;next = NULL;
	if (ps-&gt;_pSnake == NULL)
	{
		//直接插入即可
		ps-&gt;_pSnake = pcur;
	}
	else
	{
		//尾插
		if (prev != NULL)
			prev-&gt;next = pcur;
	}
	prev = pcur;
}</code></pre> 
<p>打印蛇（打印整个链表）</p> 
<pre><code class="language-cs">#define BODY L'●'
#define HEAD L'◆'


//开始在控制台上打印蛇
int count = 0;
while (pcur)
{
	SetPos(pcur-&gt;x, pcur-&gt;y);//定位
	if (count == 0)
	{
		count++;
		wprintf(L"%lc", HEAD);//打印蛇头
	}
	else
	{
		wprintf(L"%lc", BODY);//打印蛇身
	}
	pcur = pcur-&gt;next;
}</code></pre> 
<p>设置贪吃蛇的属性。</p> 
<pre><code class="language-cs">//设置贪吃蛇的属性
ps-&gt;_dir = LEFT;//初始时蛇的方向向左
ps-&gt;_FoodWeight = 50;//一个食物50分
ps-&gt;_score = 0;//总分为0
ps-&gt;_SleepTime = 200;//单位是毫秒
ps-&gt;_state = OK;//正常运行</code></pre> 
<p> 因为这里的蛇头是在最左边，所以这个蛇的初始方向不能是向右走，除此之外都可以。</p> 
<h4 id="%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A3%9F%E7%89%A9"><span style="color:#956fe7;">初始化食物</span></h4> 
<p>初始化食物其实就是创建一个食物并且打印出来。</p> 
<p>这个食物为了能够被蛇给吃掉，x坐标也必须是2的倍数，并且这个食物应该是要随机生成的，还要在这个墙体中。 </p> 
<pre><code class="language-cs">	int x = 0;
	int y = 0;
	//随机创建食物(食物的x坐标必须是2的倍数，因此要判断)
again:
	do
	{
        //为了食物出现在墙内
		x = rand() % 53 + 2;
		y = rand() % 25 + 1;

	} while (x % 2);
	//食物的坐标不能和蛇身冲突
	pSnakeNode pcur = ps-&gt;_pSnake;
	//开始寻找看看是否与蛇身冲突
	while (pcur)
	{
		if (pcur-&gt;x == x &amp;&amp; pcur-&gt;y == y)
		{
			goto again;//如果冲突了，就要回炉重造
		}
		pcur = pcur-&gt;next;
	}
	//开始创建食物的节点
	pSnakeNode tmp = (pSnakeNode)malloc(sizeof(SnakeNode));
	if (tmp == NULL)
	{
		perror("CreatFood():malloc:");
		return;
	}
	tmp-&gt;x = x;
	tmp-&gt;y = y;
	tmp-&gt;next = NULL;
	ps-&gt;_pFood = tmp;</code></pre> 
<p>打印食物</p> 
<pre><code class="language-cs">//打印食物
SetPos(x, y);
wprintf(L"%lc", FOOD);</code></pre> 
<h3 id="GameRun%EF%BC%88%EF%BC%89%E2%80%94%E2%80%94%E6%B8%B8%E6%88%8F%E7%9A%84%E8%BF%90%E8%A1%8C"><span style="color:#38d8f0;">GameRun（）——游戏的运行</span></h3> 
<p>1，打印帮助手册  2，贪吃蛇的相关运行信息  3，判断贪吃蛇是否死亡</p> 
<p><img alt="" height="1050" src="https://images2.imgbox.com/a1/0e/C7Mu8bwC_o.png" width="1200"></p> 
<p>上图就是游戏运行时的界面。</p> 
<h4 id="%E6%89%93%E5%8D%B0%E5%8F%B3%E4%BE%A7%E7%9A%84%E5%B8%AE%E5%8A%A9%E4%BF%A1%E6%81%AF"><span style="color:#956fe7;">打印右侧的帮助信息</span></h4> 
<pre><code class="language-cs">//打印帮助信息
void PrintHelpInfo()
{
	SetPos(68, 10);
	printf("小提示：");
	SetPos(68, 13);
	printf("不能穿墙，不能咬到自己！");
	SetPos(68, 14);
	printf("用↑.↓.←.→ 来控制蛇的移动！");
	SetPos(68, 15);
	printf("摁F3加速！摁F4减速！");
	SetPos(68, 16);
	printf("加速将增加单个食物的分数！");
	SetPos(68, 17);
	printf("减速将减少单个食物的分数！");
	SetPos(68, 18);
	printf("摁Esc退出游戏！摁空格暂停游戏！");
}</code></pre> 
<h4 id="%E8%B4%AA%E5%90%83%E8%9B%87%E7%9A%84%E7%9B%B8%E5%85%B3%E8%BF%90%E8%A1%8C%E4%BF%A1%E6%81%AF%C2%A0"><span style="color:#38d8f0;">贪吃蛇的相关运行信息</span> </h4> 
<p>贪吃蛇要运行起来，就得需要我们摁键来实现贪吃蛇的走动。所以接下来就是判断哪个键是否摁过来判断蛇的走向。而只要是蛇的状态不等于OK时，此时就不需要再走了。</p> 
<pre><code class="language-cs">#define KEY_PRESS(VK) ((GetAsyncKeyState(VK) &amp; 0x1) ? 1 : 0)


//接下来就是通过按键来判断贪吃蛇的运行状态
do
{
	//打印分数显示
	SetPos(68, 7);
	printf("当前总分数：%08d", ps-&gt;_score);
	SetPos(68, 8);
	printf("当前食物分数：%02d", ps-&gt;_FoodWeight);
	//判断摁了什么键，根据键来判断要执行的命令
	if (KEY_PRESS(VK_UP) &amp;&amp; ps-&gt;_dir != DOWN)
	{
		ps-&gt;_dir = UP;//摁了↑，并且蛇不是往下走，就改变方向
	}
	else if (KEY_PRESS(VK_DOWN) &amp;&amp; ps-&gt;_dir != UP)
	{
		ps-&gt;_dir = DOWN;
	}
	else if (KEY_PRESS(VK_LEFT) &amp;&amp; ps-&gt;_dir != RIGHT)
	{
		ps-&gt;_dir = LEFT;
	}
	else if (KEY_PRESS(VK_RIGHT) &amp;&amp; ps-&gt;_dir != LEFT)
	{
		ps-&gt;_dir = RIGHT;
	}
	else if (KEY_PRESS(VK_SPACE))
	{
		Pause();//暂停
	}
	else if (KEY_PRESS(VK_ESCAPE))
	{
		//退出游戏
		ps-&gt;_state = END_NORMAL;
	}
	else if (KEY_PRESS(VK_F3))
	{
		//加速（减少休眠时间）
		if (ps-&gt;_SleepTime &gt; 80)//设置为4档速度
		{
			ps-&gt;_SleepTime -= 30;
			ps-&gt;_FoodWeight += 10;
		}
	}
	else if (KEY_PRESS(VK_F4))
	{
		//减速
		if (ps-&gt;_FoodWeight &gt; 10)//设置为4档速度
		{
			ps-&gt;_SleepTime += 20;
			ps-&gt;_FoodWeight -= 10;
		}
	}
	//蛇开始走
	//走一步，就休息一下
	SnakeMove(ps);//蛇走一步的过程
	Sleep(ps-&gt;_SleepTime);
	//检测是否撞墙
	KillByWall(ps);
	//检测是否撞到自己
	KillBySelf(ps);
    //通过总分数来判断游戏是否结束
    if (ps-&gt;_score &gt; 30000)
    {
	    SetPos(20, 13);
	    printf("恭喜你！成功通关！");
    }
} while (ps-&gt;_state == OK);//只有蛇的状态正常才走</code></pre> 
<p>暂停的实现就只需要系统一直处于休眠状态。 </p> 
<pre><code class="language-cs">void Pause()
{
	while (1)
	{
		//休眠200毫秒
		Sleep(200);
		//这个只能放到休眠的后面
		if (KEY_PRESS(VK_SPACE))
		{
			break;
		}
	}
}</code></pre> 
<p>当进入这个暂停函数就需要休眠，即使再次摁了空格键，也得先休眠一下。</p> 
<p>蛇在走的时候，就是根据我们摁的键位来判断蛇头应该出现在哪个地方。再通过链接蛇头的下一个位置和蛇身以及释放蛇身的尾节点。还有一个小细节：如果蛇头下一个位置是食物的话，就要吃掉食物，并且再创建一个食物，而如果不是食物的话，就只需要按照上面的步骤走就行了。因此就得先判断是否为食物。</p> 
<pre><code class="language-cs">//蛇走一步的过程
void SnakeMove(pSnake ps)
{
	//创建一个节点来存放蛇要走的下一个节点
	pSnakeNode next = (pSnakeNode)malloc(sizeof(SnakeNode));
	if (next == NULL)
	{
		perror("SnakeMove():malloc:");
		return;
	}
	//根据方向来判断蛇是怎么走的
	switch (ps-&gt;_dir)
	{
	case UP:
		next-&gt;x = ps-&gt;_pSnake-&gt;x;
		next-&gt;y = ps-&gt;_pSnake-&gt;y - 1;
		break;
	case DOWN:
		next-&gt;x = ps-&gt;_pSnake-&gt;x;
		next-&gt;y = ps-&gt;_pSnake-&gt;y + 1;
		break;
	case LEFT:
		next-&gt;x = ps-&gt;_pSnake-&gt;x - 2;
		next-&gt;y = ps-&gt;_pSnake-&gt;y;
		break;
	case RIGHT:
		next-&gt;x = ps-&gt;_pSnake-&gt;x + 2;
		next-&gt;y = ps-&gt;_pSnake-&gt;y;
		break;
	}
	//判断蛇走的下一个节点是不是食物
	if (NextIsFood(next, ps))
	{
        //是食物就吃掉食物
		EatFood(next, ps);
	}
	else
	{
        //不是就不吃
		NoFood(next, ps);
	}
}</code></pre> 
<p>下一个位置是食物</p> 
<pre><code class="language-cs">//下一个位置是食物，就可以吃掉
void EatFood(pSnakeNode next, pSnake ps)
{
	//把这个节点(就是食物节点)头插到蛇身就行
	ps-&gt;_pFood-&gt;next = ps-&gt;_pSnake;
	ps-&gt;_pSnake = ps-&gt;_pFood;
	//释放掉这个节点(因为创建了两个节点：一个食物节点，一个蛇头的下一个节点)
	free(next);
	next = NULL;
	//打印蛇身
	pSnakeNode pcur = ps-&gt;_pSnake;
	int count = 0;
	while (pcur)
	{
		SetPos(pcur-&gt;x, pcur-&gt;y);//定位
		if (count == 0)
		{
			count++;
			wprintf(L"%lc", HEAD);//打印蛇头
		}
		else
		{
			wprintf(L"%lc", BODY);//打印蛇身
		}
		pcur = pcur-&gt;next;
	}
    //分数的增加
	ps-&gt;_score += ps-&gt;_FoodWeight;
	//重新创建食物
	CreatFood(ps);
}</code></pre> 
<p>下一个位置不是食物</p> 
<pre><code class="language-cs">//下一个位置不是食物
void NoFood(pSnakeNode next, pSnake ps)
{
	//把下一个位置的节点头插到蛇身
	next-&gt;next = ps-&gt;_pSnake;
	ps-&gt;_pSnake = next;
	//把蛇身最后一个节点的空间释放掉，顺便打印蛇身
	pSnakeNode pcur = ps-&gt;_pSnake;
	int count = 0;
	while (pcur-&gt;next-&gt;next != NULL)
	{
		//遍历时，可以直接打印
		SetPos(pcur-&gt;x, pcur-&gt;y);
		if (count == 0)
		{
			count++;
			wprintf(L"%lc", HEAD);
		}
		else
		{
			wprintf(L"%lc", BODY);
		}
		pcur = pcur-&gt;next;
	}
	//把最后一个节点的位置打印成空格
	SetPos(pcur-&gt;next-&gt;x, pcur-&gt;next-&gt;y);
	printf("  ");
	free(pcur-&gt;next);
	pcur-&gt;next = NULL;
}</code></pre> 
<p>如果不把蛇身的尾节点的位置打印成空格，那么上一次的痕迹就不会被消除。 会导致蛇身一直变长。  走一步，再休息两百毫秒，可以让我们有时间来判断贪吃蛇下一步需怎么走，如果不休息就会直接撞墙。</p> 
<p>检测是否撞墙只需要检测蛇头是否撞墙，因为蛇身的每一个节点是重复执行蛇头的操作。蛇头不撞墙那么蛇身就没有机会撞墙，如果蛇头撞墙，那么就说明这个蛇撞墙了。</p> 
<pre><code class="language-cs">//检测是否撞墙
void KillByWall(pSnake ps)
{
	//只要判断蛇头是否碰到墙就可以了
	if (ps-&gt;_pSnake-&gt;x == 0 || ps-&gt;_pSnake-&gt;x == 56
		|| ps-&gt;_pSnake-&gt;y == 0 || ps-&gt;_pSnake-&gt;y == 26)
	{
		ps-&gt;_state = KILL_BY_WALL;//改变蛇的状态即可 
	}
}
</code></pre> 
<p>检测蛇是否撞到自身就只需要检测蛇头和蛇身的某一个节点是否重合就行了。</p> 
<pre><code class="language-cs">//检测是否撞到自己
void KillBySelf(pSnake ps)
{
	//只要判断蛇头是否碰到自己的蛇身
	pSnakeNode pcur = ps-&gt;_pSnake-&gt;next;
	while (pcur)
	{
		if (pcur-&gt;x == ps-&gt;_pSnake-&gt;x &amp;&amp; pcur-&gt;y == ps-&gt;_pSnake-&gt;y)
		{
			ps-&gt;_state = KILL_BY_SELF;//改变蛇的状态即可
			break;
		}
		pcur = pcur-&gt;next;
	}
}</code></pre> 
<h3 id="GameOver%EF%BC%88%EF%BC%89%E2%80%94%E2%80%94%E6%B8%B8%E6%88%8F%E7%9A%84%E7%BB%93%E6%9D%9F%EF%BC%88%E5%96%84%E5%90%8E%E5%B7%A5%E4%BD%9C%EF%BC%89%C2%A0"><span style="color:#38d8f0;">GameOver（）——游戏的结束（善后工作）</span> </h3> 
<p>善后也就是把蛇身的节点释放掉，并告诉玩家游戏结束的原因。</p> 
<pre><code class="language-cs">//结束游戏（善后工作）
void GameOver(pSnake ps)
{
	SetPos(20, 13);
	switch (ps-&gt;_state)
	{
	case KILL_BY_WALL:
		printf("很遗憾！撞墙死亡！");
		break;
	case KILL_BY_SELF:
		printf("很遗憾！撞到自己死亡！");
		break;
	case END_NORMAL:
		printf("玩家主动结束游戏！");
		break;
	}
	//释放蛇身链表
	pSnakeNode prev = ps-&gt;_pSnake;
	pSnakeNode pcur = ps-&gt;_pSnake;
	while (pcur)
	{
		prev = pcur-&gt;next;
		free(pcur);
		pcur = prev;
	}
}</code></pre> 
<h2 id="%E8%B4%AA%E5%90%83%E8%9B%87%E6%BA%90%E7%A0%81%C2%A0" style="background-color:transparent;"><span style="color:#fe2c24;">贪吃蛇源码</span> </h2> 
<p> Snake.h</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;Windows.h&gt;
#include &lt;locale.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;time.h&gt;

#define POS_X 24
#define POS_Y 5

#define WALL L'□'
#define BODY L'●'
#define FOOD L'★'
#define HEAD L'◆'

#define KEY_PRESS(VK) ((GetAsyncKeyState(VK) &amp; 0x1) ? 1 : 0)

//游戏的状态
typedef enum GAME_STATE
{
	OK,//正常运行
	KILL_BY_WALL,//撞墙
	KILL_BY_SELF,//撞到自己
	END_NORMAL//正常退出
}GAME_STATE;

//蛇的方向
typedef enum DIRECTION
{
	UP = 1,//上
	DOWN,//下
	LEFT,//左
	RIGHT//右
}DIRECTION;

//蛇身的节点类型
typedef struct SnakeNode
{
	//坐标
	int x;
	int y;
	//指向下一个节点的指针
	struct SnakeNode* next;
}SnakeNode, * pSnakeNode;


//贪吃蛇
typedef struct Snake
{
	pSnakeNode _pSnake;//指向蛇头的指针
	pSnakeNode _pFood;//指向食物的指针
	DIRECTION _dir;//蛇的方向
	GAME_STATE _state;//游戏的运行状态
	int _FoodWeight;//一个食物的分数
	int _score;//总分数
	int _SleepTime;//休眠时间，时间越短，速度越快，时间越长，速度越慢
}Snake, * pSnake;


//定位光标
void SetPos(short x, short y);

//初始化游戏
void GameStart(pSnake ps);

//打印欢迎界面
void WelcomToGame();

//绘制地图
void CreatMap();

//初始化蛇
void InitSnake(pSnake ps);

//创建食物
void CreatFood(pSnake ps);

//游戏运行
void GameRun(pSnake ps);

//蛇走一步的过程
void SnakeMove(pSnake ps);

//判断蛇要走的下一个节点是否为食物
int NextIsFood(pSnakeNode next, pSnake ps);

//下一个位置是食物，就可以吃掉
void EatFood(pSnakeNode next, pSnake ps);

//下一个位置不是食物
void NoFood(pSnakeNode next, pSnake ps);

//检测是否撞墙
void KillByWall(pSnake ps);

//检测是否撞到自己
void KillBySelf(pSnake ps); 

//结束游戏（善后工作）
void GameOver(pSnake ps);</code></pre> 
<p>Snake.c</p> 
<pre><code class="language-cs">#include "Snake.h"


//定位光标
void SetPos(short x, short y)
{
	HANDLE houtput = GetStdHandle(STD_OUTPUT_HANDLE);//获取标准输出的句柄
	COORD pos = { x, y };
	SetConsoleCursorPosition(houtput, pos);//设置光标的位置
}


//打印欢迎界面
void WelcomToGame()
{
	//首先得定位光标
	SetPos(39, 10);
	printf("欢迎来到贪吃蛇小游戏\n");
	SetPos(40, 15);
	system("pause");//暂停
	system("cls");//清理屏幕

	SetPos(28, 10);
	printf("用↑.↓.←.→ 来控制蛇的移动！摁F3加速！摁F4减速！\n");
	SetPos(38, 11);
	printf("游戏即将开始，请做好准备！\n");
	SetPos(40, 15);
	system("pause");
	system("cls");
}


//绘制地图
void CreatMap()
{
	//打印上体墙
	for (int i = 0; i &lt;= 28; i++)
	{
		wprintf(L"%lc", WALL);
	}
	SetPos(0, 26);//定位到下体墙的位置
	//打印下体墙
	for (int i = 0; i &lt;= 28; i++)
	{
		wprintf(L"%lc", WALL);
	}
	//打印左体墙
	for (int i = 1; i &lt;= 25; i++)
	{
		SetPos(0, i);
		wprintf(L"%lc", WALL);
	}
	//打印右体墙
	for (int i = 1; i &lt;= 25; i++)
	{
		SetPos(56, i);
		wprintf(L"%lc", WALL);
	}
}


//初始化蛇
void InitSnake(pSnake ps)
{
	//创建一条蛇
	pSnakeNode pcur = NULL;
	pSnakeNode prev = NULL;
	for (int i = 0; i &lt; 5; i++)
	{
		pSnakeNode tmp = (pSnakeNode)malloc(sizeof(SnakeNode));
		if (tmp == NULL)
		{
			perror("InitSnake():malloc:");
			return;
		}
		pcur = tmp;
		pcur-&gt;x = POS_X + 2 * i;
		pcur-&gt;y = POS_Y;
		pcur-&gt;next = NULL;
		if (ps-&gt;_pSnake == NULL)
		{
			//直接插入即可
			ps-&gt;_pSnake = pcur;
		}
		else
		{
			//尾插
			if (prev != NULL)
				prev-&gt;next = pcur;
		}
		prev = pcur;
	}
	pcur = ps-&gt;_pSnake;
	//开始在控制台上打印蛇
	int count = 0;
	while (pcur)
	{
		SetPos(pcur-&gt;x, pcur-&gt;y);//定位
		if (count == 0)
		{
			count++;
			wprintf(L"%lc", HEAD);//打印蛇头
		}
		else
		{
			wprintf(L"%lc", BODY);//打印蛇身
		}
		pcur = pcur-&gt;next;
	}
	//设置贪吃蛇的属性
	ps-&gt;_dir = LEFT;//初始时蛇的方向向左
	ps-&gt;_FoodWeight = 50;//一个食物50分
	ps-&gt;_score = 0;//总分为0
	ps-&gt;_SleepTime = 200;//单位是毫秒
	ps-&gt;_state = OK;//正常运行
}


//创建食物
void CreatFood(pSnake ps)
{
	int x = 0;
	int y = 0;
	//随机创建食物(食物的x坐标必须是2的倍数，因此要判断)
again:
	do
	{
		x = rand() % 53 + 2;
		y = rand() % 25 + 1;
	} while (x % 2);
	//食物的坐标不能和蛇身冲突
	pSnakeNode pcur = ps-&gt;_pSnake;
	//开始寻找看看是否与蛇身冲突
	while (pcur)
	{
		if (pcur-&gt;x == x &amp;&amp; pcur-&gt;y == y)
		{
			goto again;
		}
		pcur = pcur-&gt;next;
	}
	//开始创建食物的节点
	pSnakeNode tmp = (pSnakeNode)malloc(sizeof(SnakeNode));
	if (tmp == NULL)
	{
		perror("CreatFood():malloc:");
		return;
	}
	tmp-&gt;x = x;
	tmp-&gt;y = y;
	tmp-&gt;next = NULL;
	ps-&gt;_pFood = tmp;
	//打印食物
	SetPos(x, y);
	wprintf(L"%lc", FOOD);
}


//初始化游戏
void GameStart(pSnake ps)
{
	//设置窗口大小以及名字
	system("mode con cols=100 lines=30");
	system("title 贪吃蛇");
	//隐藏光标信息，为了后续打印
	HANDLE houtput = GetStdHandle(STD_OUTPUT_HANDLE);//获取标准输出的句柄
	CONSOLE_CURSOR_INFO CursorInfo;
	GetConsoleCursorInfo(houtput, &amp;CursorInfo);//获取光标信息
	CursorInfo.bVisible = false;//隐藏光标
	SetConsoleCursorInfo(houtput, &amp;CursorInfo);//设置光标状态

	//打印欢迎界面和功能介绍
	WelcomToGame();
	//绘制地图
	CreatMap();
	//初始化蛇
	InitSnake(ps);
	//创建食物
	CreatFood(ps);
}


//打印帮助信息
void PrintHelpInfo()
{
	SetPos(68, 10);
	printf("小提示：");
	SetPos(68, 13);
	printf("不能穿墙，不能咬到自己！");
	SetPos(68, 14);
	printf("用↑.↓.←.→ 来控制蛇的移动！");
	SetPos(68, 15);
	printf("摁F3加速！摁F4减速！");
	SetPos(68, 16);
	printf("加速将增加单个食物的分数！");
	SetPos(68, 17);
	printf("减速将减少单个食物的分数！");
	SetPos(68, 18);
	printf("摁Esc退出游戏！摁空格暂停游戏！");
}


void Pause()
{
	while (1)
	{
		//休眠200毫秒
		Sleep(200);
		//这个只能放到休眠的后面
		if (KEY_PRESS(VK_SPACE))
		{
			break;
		}
	}
}


//判断蛇要走的下一个节点是否为食物
int NextIsFood(pSnakeNode next, pSnake ps)
{
	return ((next-&gt;x == ps-&gt;_pFood-&gt;x) &amp;&amp; (next-&gt;y == ps-&gt;_pFood-&gt;y));
}


//下一个位置是食物，就可以吃掉
void EatFood(pSnakeNode next, pSnake ps)
{
	//把这个节点(就是食物节点)头插到蛇身就行
	ps-&gt;_pFood-&gt;next = ps-&gt;_pSnake;
	ps-&gt;_pSnake = ps-&gt;_pFood;
	//释放掉这个节点(因为有两个节点)
	free(next);
	next = NULL;
	//打印蛇身
	pSnakeNode pcur = ps-&gt;_pSnake;
	int count = 0;
	while (pcur)
	{
		SetPos(pcur-&gt;x, pcur-&gt;y);//定位
		if (count == 0)
		{
			count++;
			wprintf(L"%lc", HEAD);//打印蛇头
		}
		else
		{
			wprintf(L"%lc", BODY);//打印蛇身
		}
		pcur = pcur-&gt;next;
	}
	ps-&gt;_score += ps-&gt;_FoodWeight;
	//重新创建食物
	CreatFood(ps);
}


//下一个位置不是食物
void NoFood(pSnakeNode next, pSnake ps)
{
	//把下一个位置的节点头插到蛇身
	next-&gt;next = ps-&gt;_pSnake;
	ps-&gt;_pSnake = next;
	//把蛇身最后一个节点的空间释放掉，顺便打印蛇身
	pSnakeNode pcur = ps-&gt;_pSnake;
	int count = 0;
	while (pcur-&gt;next-&gt;next != NULL)
	{
		//遍历时，可以直接打印
		SetPos(pcur-&gt;x, pcur-&gt;y);
		if (count == 0)
		{
			count++;
			wprintf(L"%lc", HEAD);
		}
		else
		{
			wprintf(L"%lc", BODY);
		}
		pcur = pcur-&gt;next;
	}
	//把最后一个节点的位置打印成空格
	SetPos(pcur-&gt;next-&gt;x, pcur-&gt;next-&gt;y);
	printf("  ");
	free(pcur-&gt;next);
	pcur-&gt;next = NULL;
}



//蛇走一步的过程
void SnakeMove(pSnake ps)
{
	//创建一个节点来存放蛇要走的下一个节点
	pSnakeNode next = (pSnakeNode)malloc(sizeof(SnakeNode));
	if (next == NULL)
	{
		perror("SnakeMove():malloc:");
		return;
	}
	//根据方向来判断蛇是怎么走的
	switch (ps-&gt;_dir)
	{
	case UP:
		next-&gt;x = ps-&gt;_pSnake-&gt;x;
		next-&gt;y = ps-&gt;_pSnake-&gt;y - 1;
		break;
	case DOWN:
		next-&gt;x = ps-&gt;_pSnake-&gt;x;
		next-&gt;y = ps-&gt;_pSnake-&gt;y + 1;
		break;
	case LEFT:
		next-&gt;x = ps-&gt;_pSnake-&gt;x - 2;
		next-&gt;y = ps-&gt;_pSnake-&gt;y;
		break;
	case RIGHT:
		next-&gt;x = ps-&gt;_pSnake-&gt;x + 2;
		next-&gt;y = ps-&gt;_pSnake-&gt;y;
		break;
	}
	//判断蛇走的下一个节点是不是食物
	if (NextIsFood(next, ps))
	{
		EatFood(next, ps);
	}
	else
	{
		NoFood(next, ps);
	}
}


//检测是否撞墙
void KillByWall(pSnake ps)
{
	//只要判断蛇头是否碰到墙就可以了
	if (ps-&gt;_pSnake-&gt;x == 0 || ps-&gt;_pSnake-&gt;x == 56
		|| ps-&gt;_pSnake-&gt;y == 0 || ps-&gt;_pSnake-&gt;y == 26)
	{
		ps-&gt;_state = KILL_BY_WALL; 
	}
}


//检测是否撞到自己
void KillBySelf(pSnake ps)
{
	//只要判断蛇头是否碰到自己的蛇身
	pSnakeNode pcur = ps-&gt;_pSnake-&gt;next;
	while (pcur)
	{
		if (pcur-&gt;x == ps-&gt;_pSnake-&gt;x &amp;&amp; pcur-&gt;y == ps-&gt;_pSnake-&gt;y)
		{
			ps-&gt;_state = KILL_BY_SELF;
			break;
		}
		pcur = pcur-&gt;next;
	}
}


//游戏运行
void GameRun(pSnake ps)
{
	//先打印帮助信息
	PrintHelpInfo();
	//接下来就是通过按键来判断贪吃蛇的运行状态
	do
	{
		//打印分数显示
		SetPos(68, 7);
		printf("当前总分数：%05d", ps-&gt;_score);
		SetPos(68, 8);
		printf("当前食物分数：%02d", ps-&gt;_FoodWeight);
		//判断摁了什么键，根据键来判断要执行的命令
		if (KEY_PRESS(VK_UP) &amp;&amp; ps-&gt;_dir != DOWN)
		{
			ps-&gt;_dir = UP;//摁了↑，并且蛇不是往下走，就改变方向
		}
		else if (KEY_PRESS(VK_DOWN) &amp;&amp; ps-&gt;_dir != UP)
		{
			ps-&gt;_dir = DOWN;
		}
		else if (KEY_PRESS(VK_LEFT) &amp;&amp; ps-&gt;_dir != RIGHT)
		{
			ps-&gt;_dir = LEFT;
		}
		else if (KEY_PRESS(VK_RIGHT) &amp;&amp; ps-&gt;_dir != LEFT)
		{
			ps-&gt;_dir = RIGHT;
		}
		else if (KEY_PRESS(VK_SPACE))
		{
			Pause();//暂停
		}
		else if (KEY_PRESS(VK_ESCAPE))
		{
			//退出游戏
			ps-&gt;_state = END_NORMAL;
		}
		else if (KEY_PRESS(VK_F3))
		{
			//加速（减少休眠时间）
			if (ps-&gt;_SleepTime &gt; 80)//设置为4档速度
			{
				ps-&gt;_SleepTime -= 30;
				ps-&gt;_FoodWeight += 10;
			}
		}
		else if (KEY_PRESS(VK_F4))
		{
			//减速
			if (ps-&gt;_FoodWeight &gt; 10)
			{
				ps-&gt;_SleepTime += 20;
				ps-&gt;_FoodWeight -= 10;
			}
		}
		//蛇开始走
		//走一步，就休息一下
		SnakeMove(ps);//蛇走一步的过程
		Sleep(ps-&gt;_SleepTime);
		//检测是否撞墙
		KillByWall(ps);
		//检测是否撞到自己
		KillBySelf(ps);
		if (ps-&gt;_score &gt; 30000)
		{
			SetPos(20, 13);
			printf("恭喜你！成功通关！");
			break;
		}
	} while (ps-&gt;_state == OK);
}


//结束游戏（善后工作）
void GameOver(pSnake ps)
{
	SetPos(20, 13);
	switch (ps-&gt;_state)
	{
	case KILL_BY_WALL:
		printf("很遗憾！撞墙死亡！");
		break;
	case KILL_BY_SELF:
		printf("很遗憾！撞到自己死亡！");
		break;
	case END_NORMAL:
		printf("玩家主动结束游戏！");
		break;
	}
	//释放蛇身链表
	pSnakeNode prev = ps-&gt;_pSnake;
	pSnakeNode pcur = ps-&gt;_pSnake;
	while (pcur)
	{
		prev = pcur-&gt;next;
		free(pcur);
		pcur = prev;
	}
}</code></pre> 
<p>test.c</p> 
<pre><code class="language-cs">#include "Snake.h"

void test()
{
	//创建贪吃蛇
	Snake snake = { 0 };
	//初始化游戏
	//1.游戏相关界面的打印
	//2.贪吃蛇与食物的打印
	GameStart(&amp;snake);
	//游戏运行
	GameRun(&amp;snake);
	//结束游戏（善后工作）
	GameOver(&amp;snake);
}


int main()
{
	//适配本地化环境
	setlocale(LC_ALL, "");
    //生成随机种子
	srand((unsigned int)time(NULL));
	//测试贪吃蛇
	test();
    //为了格式更好看
	SetPos(0, 27);
	return 0;
}</code></pre> 
<p> 好啦！本期贪吃蛇游戏的学习之旅到此结束了！我们下一期再一起学习吧！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/65e0b010e28080537d28d858dd5ebef0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JavaScript中的map()方法详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f0be9900586a2c9605259053893ea041/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C&#43;&#43;】一篇文章带你深入了解list</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>