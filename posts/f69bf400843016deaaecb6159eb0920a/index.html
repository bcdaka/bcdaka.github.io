<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构——【堆】 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/f69bf400843016deaaecb6159eb0920a/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构——【堆】">
  <meta property="og:description" content="一、堆的相关概念 1.1、堆的概念 1、堆在逻辑上是一颗完全二叉树（类似于一颗满二叉树只缺了右下角）。
2、堆的实现利用的是数组，我们通常会利用动态数组来存放元素，这样可以快速拓容也不会很浪费空间，我们是将这颗完全二叉树用层序遍历的方式储存在数组里的。
3、堆有两种分别是大根堆和小根堆 。
1.2、堆的分类 1.2.1、大根堆 大根堆就是整个完全二叉树，任意一个根节点的值都比左右子树的值大 这就是一个大根堆，所有根节点的值永远比左右子树的大，那么就可以看出，整棵树的根节点，他的值是整个堆中最大的。同时我们也发现没有直接父子关系的节点他们的值没有完全地关系，就像第二层的33和第三层的45以及20，没有规定第三层的元素值必须小于第二层，只要满足根节点比自己左右子树节点的值大即可。
1.2.3、小根堆 小根堆表示整个完全二叉树，任意一个根节点的值都比左右子树的值小。
以上就是一个简单地小根堆它的定义与大根堆相似，只是跟节点的值小于自己的左右节点的值，同时小根堆的层与层之间没有直接关系的节点的值也没有必然的大小关系。
1.3、堆的结构 堆的逻辑结构是一颗完全二叉树
堆的物理结构是一个数组
我们可以用左右孩子节点和父节点，来表示所有的节点。
leftchild = parent * 2 &#43; 1;
rightchild = parent * 2 &#43; 2;
parent = (child - 1) / 2;(child可以是左孩子,也可以是右孩子)
如下图：是一个大根堆，父节点的值都大于子节点的值。
在数组中存储的是：
109 865743 二、堆的实现 2.1、堆的功能 我们是以顺序表的形式实现的堆，其中基本的操作和顺序表的操作是大致一样的。
下面是我们要实现的堆的一些基础功能
#pragma once #include&lt;stdio.h&gt; #include&lt;assert.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; typedef int HPDataType; typedef struct Heap { HPDataType* a; int size; int capacity; }Heap; //堆的初始化 void HeapInit(Heap* hp); // 堆的构建 void HeapCreate(Heap* hp, HPDataType* a, int n); // 堆的销毁 void HeapDestory(Heap* hp); // 堆的插入 void HeapPush(Heap* hp, HPDataType x); // 堆的删除 void HeapPop(Heap* hp); // 取堆顶的数据 HPDataType HeapTop(Heap* hp); // 堆的数据个数 int HeapSize(Heap* hp); // 堆的判空 int HeapEmpty(Heap* hp); //打印堆 void HeapPrint(Heap* hp); //交换函数 void Swap(HPDataType* p1, HPDataType* p2); 2.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-09-12T19:34:59+08:00">
    <meta property="article:modified_time" content="2023-09-12T19:34:59+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构——【堆】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、堆的相关概念</h2> 
<h3>1.1、堆的概念</h3> 
<p>1、堆在逻辑上是一颗<strong>完全二叉树</strong>（类似于一颗满<a href="https://so.csdn.net/so/search?q=%E4%BA%8C%E5%8F%89%E6%A0%91&amp;spm=1001.2101.3001.7020" title="二叉树">二叉树</a>只缺了右下角）。</p> 
<p>2、堆的实现利用的是<strong>数组</strong>，我们通常会利用<a href="https://so.csdn.net/so/search?q=%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84&amp;spm=1001.2101.3001.7020" title="动态数组">动态数组</a>来存放元素，这样可以快速拓容也不会很浪费空间，我们是将这颗完全二叉树用层序遍历的方式储存在数组里的。</p> 
<p>3、堆有两种分别是<strong>大根堆</strong>和<strong>小根堆</strong> 。</p> 
<h3>1.2、堆的分类</h3> 
<h4><strong>1.2.1、大根堆</strong></h4> 
<p>大根堆就是整个<a href="https://so.csdn.net/so/search?q=%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91&amp;spm=1001.2101.3001.7020" title="完全二叉树">完全二叉树</a>，<strong>任意一个根节点的值都比左右子树的值大</strong>    </p> 
<p>          <img alt="" height="395" src="https://images2.imgbox.com/2b/89/9DaDGb3x_o.png" width="516"></p> 
<p>这就是一个大根堆，所有根节点的值永远比左右子树的大，那么就可以看出，<span style="color:#fe2c24;"><strong>整棵树的根节点，他的值是整个堆中最大的。</strong></span>同时我们也发现没有直接父子关系的节点他们的值没有完全地关系，就像第二层的33和第三层的45以及20，没有规定第三层的元素值必须小于第二层，只要满足根节点比自己左右子树节点的值大即可。</p> 
<h4><strong>1.2.3、小根堆</strong></h4> 
<p><a href="https://so.csdn.net/so/search?q=%E5%B0%8F%E6%A0%B9%E5%A0%86&amp;spm=1001.2101.3001.7020" title="小根堆">小根堆</a>表示整个完全二叉树，<strong>任意一个根节点的值都比左右子树的值小</strong>。</p> 
<p>            <img alt="" height="329" src="https://images2.imgbox.com/b6/3f/FrSZ6jcd_o.png" width="509"></p> 
<p>以上就是一个简单地小根堆它的定义与大根堆相似，只是跟节点的值小于自己的左右节点的值，同时小根堆的<strong>层与层之间没有直接关系的节点的值也没有必然的大小关系</strong>。</p> 
<h3>1.3、堆的结构</h3> 
<blockquote> 
 <p>堆的逻辑结构是一颗完全二叉树</p> 
 <p>堆的物理结构是一个数组</p> 
 <p>我们可以用左右孩子节点和父节点，来表示所有的节点。</p> 
 <p>leftchild = parent * 2 + 1;</p> 
 <p>rightchild = parent * 2 + 2;</p> 
 <p>parent = (child - 1) / 2;(child可以是左孩子,也可以是右孩子)</p> 
</blockquote> 
<p> 如下图：是一个大根堆，父节点的值都大于子节点的值。</p> 
<p><img alt="" height="371" src="https://images2.imgbox.com/b5/4f/xRPFzt5H_o.png" width="441"></p> 
<p>在数组中存储的是：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td><strong><span style="color:#ff9900;">10</span></strong></td><td><strong><span style="color:#ff9900;">9 </span></strong></td><td><strong><span style="color:#ff9900;">8</span></strong></td><td><strong><span style="color:#ff9900;">6</span></strong></td><td><strong><span style="color:#ff9900;">5</span></strong></td><td><strong><span style="color:#ff9900;">7</span></strong></td><td><strong><span style="color:#ff9900;">4</span></strong></td><td><strong><span style="color:#ff9900;">3</span></strong></td></tr></tbody></table> 
<p></p> 
<h2>二、堆的实现</h2> 
<h3>2.1、堆的功能</h3> 
<p>我们是以顺序表的形式实现的堆，其中基本的操作和顺序表的操作是大致一样的。</p> 
<p>下面是我们要实现的堆的一些基础功能</p> 
<pre><code>
#pragma once
#include&lt;stdio.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;

typedef int HPDataType;
typedef struct Heap
{
	HPDataType* a;
	int size;
	int capacity;
}Heap;


//堆的初始化
void HeapInit(Heap* hp);
// 堆的构建
void HeapCreate(Heap* hp, HPDataType* a, int n);
// 堆的销毁
void HeapDestory(Heap* hp);
// 堆的插入
void HeapPush(Heap* hp, HPDataType x);
// 堆的删除
void HeapPop(Heap* hp);
// 取堆顶的数据
HPDataType HeapTop(Heap* hp);
// 堆的数据个数
int HeapSize(Heap* hp);
// 堆的判空
int HeapEmpty(Heap* hp);
//打印堆
void HeapPrint(Heap* hp);
//交换函数
void Swap(HPDataType* p1, HPDataType* p2);</code></pre> 
<h3>2.2、堆函数的实现</h3> 
<pre><code>#include"Heap.h"

//初始堆
void HeapInit(Heap* hp)
{
	assert(hp);
	hp-&gt;a = NULL;
	hp-&gt;size = 0;
	hp-&gt;capacity = 0;
}

// 堆的销毁
void HeapDestory(Heap* hp)
{
	assert(hp);

	free(hp-&gt;a);
	hp-&gt;a = NULL;

	hp-&gt;size = hp-&gt;capacity = 0;
}

//交换函数
void Swap(HPDataType* p1, HPDataType* p2)
{
	HPDataType temp = *p1;
	*p1 = *p2;
	*p2 = temp;
}

//向上调整（前面的是堆）
void AdjustUp(HPDataType* a, int child)
{
	int parent = (child - 1) / 2;
	while (child &gt; 0)
	{
		//小堆
		if (a[child] &lt;  a[parent])
		{
			Swap(&amp;a[child], &amp;a[parent]);
			child = parent;
			parent = (parent - 1) / 2;

		}
		else
		{
			break;
		}
	}
}

//打印堆
void HeapPrint(Heap* hp)
{
	assert(hp);
	for (size_t i = 0; i &lt; hp-&gt;size; i++)
	{
		printf("%d ",hp-&gt;a[i]);
	}
	printf("\n");
}

// 堆的插入
void HeapPush(Heap* hp, HPDataType x)
{
	assert(hp);
	if (hp-&gt;size == hp-&gt;capacity)
	{
		int newcapacity = hp-&gt;capacity == 0 ? 4 : hp-&gt;capacity * 2;
		HPDataType* tem = (HPDataType*)realloc(hp-&gt;a,sizeof(HPDataType)*newcapacity);
		if (tem == NULL)
		{
			perror("malloc fail");
			exit(-1);
		}
		hp-&gt;a = tem;
		hp-&gt;capacity = newcapacity;
	}
	hp-&gt;a[hp-&gt;size] = x;
	hp-&gt;size++;

	AdjustUp(hp-&gt;a, hp-&gt;size - 1);
}

//向下调整（大堆或者小堆）
void AdjustDown(HPDataType* a, int n, int parent)
{
	int child = parent * 2 + 1;
	while (child &lt; n)
	{
		//小堆
		if (child + 1 &lt; n &amp;&amp; a[child+1] &lt; a[child])   //找到两个孩子节点较小的值
		{
			child++;
		}
		//建小堆
		if (a[child]&lt;a[parent])
		{
			Swap(&amp;a[child], &amp;a[parent]);
			parent = child;
			child = parent * 2 + 1;
		}
		else
		{
			break;
		}
	}
}


// 堆顶元素的删除
void HeapPop(Heap* hp)
{
	assert(hp);
	assert(hp-&gt;size&gt;0);

	Swap(&amp;hp-&gt;a[0], &amp;hp-&gt;a[hp-&gt;size-1]);
	--hp-&gt;size;
	AdjustDown(hp-&gt;a, hp-&gt;size, 0); //大堆
}

// 堆的构建
void HeapCreate(Heap* hp, HPDataType* a, int n)
{
	assert(hp);
	assert(a);
	hp-&gt;a = (HPDataType*)malloc(sizeof(HPDataType) * n);
	if (hp-&gt;a == NULL)
	{
		perror("malloc fail");
		exit(-1);
	}
	hp-&gt;size = n;
	hp-&gt;capacity = n;
	memcpy(hp-&gt;a, a,sizeof(HPDataType) * n);

	//建堆
	for (int i = 1; i &lt; n; i++)
	{
		AdjustUp(hp-&gt;a, i);
	}
}

// 取堆顶的数据
HPDataType HeapTop(Heap* hp)
{
	assert(hp);
	assert(hp-&gt;size &gt; 0);
	return hp-&gt;a[0];
}

// 堆的判空
int HeapEmpty(Heap* hp)
{
	assert(hp);
	return hp-&gt;size == 0;
}

// 堆的数据个数
int HeapSize(Heap* hp)
{
	assert(hp);
	return hp-&gt;size;
}</code></pre> 
<h3>2.3、堆的插入</h3> 
<p>堆是一个完全二叉树，在插入元素时是在堆的末尾插入的，但是为了把一个元素插入后，使这个堆还是一个堆，我们需要对堆中的数据尽心再次调整。</p> 
<p><strong>向上调整</strong></p> 
<p>我们插入一个元素是，在进行向上调整，把这个数放到合适的位置。我们来看看代码实现</p> 
<pre><code class="hljs">void AdjustUp(HPDataType* a, int child)
{
	int parent = (child - 1) / 2;
	while (child &gt; 0)
	{
		//大堆
		if (a[child] &gt;  a[parent])
		{
			Swap(&amp;a[child], &amp;a[parent]);
			child = parent;
			parent = (parent - 1) / 2;

		}
		else
		{
			break;
		}
	}
}</code></pre> 
<p>下面这张图帮助大家理解</p> 
<p><img alt="" height="253" src="https://images2.imgbox.com/ce/1a/JP11U3vA_o.png" width="1200"></p> 
<p>接下来我们来实现<strong>堆的插入</strong></p> 
<p>我们还是和顺序表一样，相对其扩容情况进行讨论，当hp-&gt;size==hp-&gt;capacity时，证明没有多余空间了，我们需要增加空间，这里还是使用，realloc函数，将这个数插入进去后，对这个数进行向上调整，使之变成一个新堆。</p> 
<pre><code class="hljs">void HeapPush(Heap* hp, HPDataType x)
{
	assert(hp);
	if (hp-&gt;size == hp-&gt;capacity)
	{
		int newcapacity = hp-&gt;capacity == 0 ? 4 : hp-&gt;capacity * 2;
		HPDataType* tem = (HPDataType*)realloc(hp-&gt;a,sizeof(HPDataType)*newcapacity);
		if (tem == NULL)
		{
			perror("malloc fail");
			exit(-1);
		}
		hp-&gt;a = tem;
		hp-&gt;capacity = newcapacity;
	}
	hp-&gt;a[hp-&gt;size] = x;
	hp-&gt;size++;

	AdjustUp(hp-&gt;a, hp-&gt;size - 1);
}</code></pre> 
<h3>2.4、堆的删除</h3> 
<p><strong>向上调整</strong></p> 
<p>我们在堆中删除一个元素时删除的时堆顶元素，也就是第一个元素，我们一般会先让第一个元素和最后一个元素交换位置，然后hp-&gt;size--；为了让新的数据成为堆，我们将第一个数据<strong>向下调整</strong>，使之变成一个新堆。</p> 
<p>我们来看看向下调整的代码该如何写：</p> 
<pre><code class="hljs">void AdjustDown(HPDataType* a, int n, int parent)
{
	int child = parent * 2 + 1;
	while (child &lt; n)
	{
		//小堆
		if (child + 1 &lt; n &amp;&amp; a[child+1] &gt; a[child])   //找到两个孩子节点较大的值
		{
			child++;
		}
		//建小堆
		if (a[child]&gt;a[parent])
		{
			Swap(&amp;a[child], &amp;a[parent]);
			parent = child;
			child = parent * 2 + 1;
		}
		else
		{
			break;
		}
	}
}</code></pre> 
<p>我们来看看这张图跟好的理解向下调整：</p> 
<p><img alt="" height="249" src="https://images2.imgbox.com/9a/a4/uN2su18I_o.png" width="1200"></p> 
<p>接下来我们来实现<strong>堆的删除</strong></p> 
<p>我们先考虑一下hp-&gt;size的临界问题，用一个断言就可以避免此类问题。</p> 
<pre><code class="hljs">void HeapPop(Heap* hp)
{
	assert(hp);
	assert(hp-&gt;size&gt;0);

	Swap(&amp;hp-&gt;a[0], &amp;hp-&gt;a[hp-&gt;size-1]);
	--hp-&gt;size;
	AdjustDown(hp-&gt;a, hp-&gt;size, 0); //大堆
}</code></pre> 
<h2>三、建堆</h2> 
<p>给一个数组我们如何把这个数组建成堆呢？</p> 
<p>一般我们都有两种方法：</p> 
<h3>3.1、自顶向下（向上调整）</h3> 
<p>我们来看看代码如何实现</p> 
<pre><code class="hljs">void HeapCreate(Heap* hp, HPDataType* a, int n)
{
	assert(hp);
	assert(a);
	hp-&gt;a = (HPDataType*)malloc(sizeof(HPDataType) * n);
	if (hp-&gt;a == NULL)
	{
		perror("malloc fail");
		exit(-1);
	}
	hp-&gt;size = n;
	hp-&gt;capacity = n;
	memcpy(hp-&gt;a, a,sizeof(HPDataType) * n);

	//建堆
	for (int i = 1; i &lt; n; i++)
	{
		AdjustUp(hp-&gt;a, i);
	}
}</code></pre> 
<p>我们使用错位相减的方式来计算 自顶向下（向上调整）的时间复杂度</p> 
<p><img alt="" height="700" src="https://images2.imgbox.com/cb/22/hbX8uATn_o.png" width="770"></p> 
<p>时间复杂度：O（nlog(2)^n)</p> 
<h3>3.2、自低向上（向下调整）</h3> 
<p>我们来看看代码如何实现</p> 
<pre><code class="hljs">void HeapCreate(Heap* hp, HPDataType* a, int n)
{
	assert(hp);
	assert(a);
	hp-&gt;a = (HPDataType*)malloc(sizeof(HPDataType) * n);
	if (hp-&gt;a == NULL)
	{
		perror("malloc fail");
		exit(-1);
	}
	hp-&gt;size = n;
	hp-&gt;capacity = n;
	memcpy(hp-&gt;a, a,sizeof(HPDataType) * n);

	//建堆
    //向下调整算法
	for (int i = (n - 1 - 1) / 2; i &gt;= 0; i--)
	{
		AdjustDown(arr, n, i);
	}
}

</code></pre> 
<p>和自顶向下一样，还是错位相减来计算时间复杂度</p> 
<p><img alt="" height="691" src="https://images2.imgbox.com/2a/46/Baax15vQ_o.png" width="759"></p> 
<p>时间复杂度：O（n）</p> 
<h2>四、堆的排序</h2> 
<p>我们学习堆，有一个很有用的地方，就是可以用堆进行排序，因为我们知道，大堆堆顶元素是数组中最小的，小队堆顶是数组中元素最小的。</p> 
<p>当我们需要将一个数组进行从小到大的排序时：</p> 
<blockquote> 
 <p>1.将该数组建成一个大堆</p> 
 <p>2.第一个数和最后一个数交换，然后把交换的那个较大的数不看做堆里面</p> 
 <p>3.前n-1和数进行向下调整算法，选出大的数放到根节点，再跟倒数第二个交换......</p> 
</blockquote> 
<p> 代码如下：</p> 
<pre><code class="hljs">void HeapSort(int* a,int n)
{
	int i = 0;
	//这里用向下调整算法来建堆,因为时间复杂度只有O(N)
	for (i = (n - 1 - 1) / 2; i &gt;= 0; i--)
	{
		AdjustDown(a, n, i);
	}
	int end = n - 1;
	while (end &gt; 0)
	{
		Swap(&amp;amp;a[0], &amp;amp;a[end]);
		AdjustUp(a, end, 0);
		--end;
	}
}
</code></pre> 
<p>时间复杂度：O（Nlog(2)^N）</p> 
<h2>五、topk问题</h2> 
<p>我们在做一些编程题会遇到一类问题，就是topk问题</p> 
<p>topk问题指的有一组很大的数据，我们需要返回它最大（最小）的前K个元素。</p> 
<p>这里我们就可以用堆排序很好的解决此类问题。</p> 
<p>这里力扣平台有一个练习题，我们一起来看一看</p> 
<p><a href="https://leetcode.cn/problems/smallest-k-lcci/" rel="nofollow" title="面试题 17.14. 最小K个数 - 力扣（LeetCode）">面试题 17.14. 最小K个数 - 力扣（LeetCode）</a></p> 
<p><img alt="" height="596" src="https://images2.imgbox.com/ef/77/IvslNMJq_o.png" width="879"></p> 
<p>思路：我们先建立一个大堆，先把前K个元素建成一个大堆，然后在将剩下的数和堆顶元素进行比较，如过大于堆顶数据，我们就和堆顶元素进行交换，然后将现在的堆顶元素向下调整，前k个数就是这组数据中最小的前K个数。</p> 
<p>我们来看看该如何实现：</p> 
<pre><code class="hljs">void Swap(int* p1, int* p2)
{
	int temp = *p1;
	*p1 = *p2;
	*p2 = temp;
}
//向下调整
void AdjustDown(int* a, int n, int parent)
{
	int child = parent * 2 + 1;
	while (child &lt; n)
	{
		//大堆
		if (child + 1 &lt; n &amp;&amp; a[child+1] &gt; a[child])   //找到两个孩子节点较小的值
		{
			child++;
		}
		//建大堆
		if (a[child]&gt;a[parent])
		{
			Swap(&amp;a[child], &amp;a[parent]);
			parent = child;
			child = parent * 2 + 1;
		}
		else
		{
			break;
		}
	}
}

int* smallestK(int* arr, int arrSize, int k, int* returnSize)
{
    if(k==0)
    {
        *returnSize=0;
        return NULL;
    }
    int *ret=(int*)malloc(sizeof(int)*k);
    for(int i=0;i&lt;k;i++)
    {
        ret[i]=arr[i];
    }


    //给前k个元素建大堆
    for(int i=(k-1-1)/2;i&gt;=0;i--)
    {
        AdjustDown(ret, k, i);
    }

    for(int i=k;i&lt;arrSize;i++)
    {
        if(ret[0]&gt;arr[i])
        {
            ret[0]=arr[i];
            AdjustDown(ret,k,0);
        }
    }
    *returnSize=k;
    return ret;
}</code></pre> 
<h2>六、大量数据中的topk问题</h2> 
<p>比如我们现在有100000个数据，我们要找到最大的10个数据，我们需要改怎么实现，还是利用topk解决，我们先将前100个数据建成一个小堆</p> 
<pre><code class="hljs">//创建一个文件，并且随机生成一些数字
void CreateDataFile(const char* filename, int N)
{
	FILE* Fin = fopen(filename, "w");
	if (Fin == NULL)
	{
		perror("fopen fail");
		exit(-1);
	}
	srand(time(0));
	for (int i = 0; i &lt; N; i++)
	{
		fprintf(Fin, "%d ", rand() % 10000);
	}
}
void PrintTopK(const char* filename, int k)
{
	assert(filename);
	FILE* fout = fopen(filename, "r");
	if (fout == NULL)
	{
		perror("fopen fail");
		return;
	}
	int* minheap = (int*)malloc(sizeof(int) * k);
	if (minheap == NULL)
	{
		perror("malloc fail");
		return;
	}
	//读前k个数
	for (int i = 0; i &lt; k; i++)
	{
		//空格和换行默认是多个值之间的间隔
		fscanf(fout, "%d", &amp;amp;minheap[i]);
	}
	//建k个数的堆
	for (int j = (k - 1 - 1) / 2; j &gt;= 0; j--)
	{
		AdjustDown(minheap, j, k, cmp_down);
	}
	//读取后N-K个
	int x = 0;
	while(fscanf(fout,"%d",&amp;amp;x)!=EOF)
	{
		if (x &gt; minheap[0])
		{
			minheap[0] = x;
			AdjustDown(minheap, 0, k, cmp_down);
		}
	}
	for (int i = 0; i &lt; k; i++)
	{
		printf("%d ", minheap[i]);
	}
	printf("\n");
	free(minheap);
	fclose(fout);
}
int main()
{
	//CreateDataFile("data.txt", 1000000);
	//找前10个最大的数
	PrintTopK("data.txt", 10);
	return 0;
}
</code></pre> 
<p>这里只截取了一小部分<img alt="" height="831" src="https://images2.imgbox.com/45/0f/rqw6gZz3_o.png" width="1160"></p> 
<p>我们提前改10个较大的数，验证返回的正确错误。</p> 
<p><img alt="" height="95" src="https://images2.imgbox.com/54/7d/xyXckOgh_o.png" width="936"></p> 
<p>返回的就是我们改的10个大的数字，证明返回正确，而且效率极其的高！</p> 
<p><strong>总结：堆的知识就介绍到这里，如有疑问或者质疑，请在评论区发出来，我会尽全力帮大家解决，成长的路上少不了你们的支持，你们的三连是我进步最大的动力，还望大佬们多多支持，一起加油！共勉！</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2379075489ee64a81adcb3b24f036a6b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43; 中的原子变量（std::atomic）使用指南</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/add75df695a5b06af82bf7d68790d1d2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">前端：纯css实现图片轮播（自动&#43;手动）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>