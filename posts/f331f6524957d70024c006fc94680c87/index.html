<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>什么是请求参数、表单参数、url参数、header参数、Cookie参数？一文讲懂_前端请求参数 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/f331f6524957d70024c006fc94680c87/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="什么是请求参数、表单参数、url参数、header参数、Cookie参数？一文讲懂_前端请求参数">
  <meta property="og:description" content="请求方式后面跟的是请求的路径，一般把这个叫 URI（统一资源标识符） 补充：URL 是统一资源定位符，见名知义，因为要定位，所以要指定协议甚至是位置，比如这样：http://localhost:5000/api/hello
请求路径后面跟的是 HTTP 的版本，比如这里是 HTTP/1.1 完整的第一行如下：
POST /api/hello HTTP/1.1 第二行的 User-Agent 则用于告诉对方发起请求的客户端是啥，比如咱们用 Postman 发起的请求，Postman 就会自动把这个参数设置为它自己：
User-Agent: PostmanRuntime/7.28.4 第三行的 Accept 用于告诉对方我们希望收到什么类型的数据，这里默认是能接受所有类型的数据：
Accept: */* 第四行就非常值得留意，Postman-Token 是 Postman 自己传的参数，这个我们放到下面讲！
Postman-Token: ddd72e1a-0d63-4bad-a18e-22e38a5de3fc 第五行是请求的主机，网络上的一个服务一般用 ip 加端口作为唯一标识：
Host: 127.0.0.1:5000 第六行指定的是咱们请求发起方可以理解的压缩方式：
Accept-Encoding: gzip, deflate, br 第七行告诉对方处理完当前请求后不要关闭连接：
Connection: keep-alive 第八行告诉对方咱们请求体的内容格式，这个是本文的侧重点啦！比如我们这里指定的是一般浏览器的原生表单格式：
Content-Type: application/x-www-form-urlencoded 前端面试 用前端面试题库 MST题宝库 好了，下面大家要留意了，第九行的 Content-Length 给出的是请求体的大小。
而请求体，会放在紧跟着的一个空行之后。比如本请求的请求体内容是以 key=value 形式填充的，也就是我们表单参数的内容了：
Content-Length: 23 name=%E9%98%BF%E8%8F%8C 看到这里我们先简单小结一下，想要告诉服务器我们发送的是表单数据，一共需要两步：
将 Content-Type 设置为 application/x-www-form-urlencoded在请求体中按照 key=value 的形式填写请求参数 什么是协议？进一步了解 http 好了，接下来我们进一步讲解，大家试想一下，网络应用，其实就是端到端的交互，最常见的就是服务端和客户端交互模型：客户端发一些参数数据给服务端，通过这些参数数据告诉服务端它想得到什么或想干什么，服务端根据客户端传递的参数数据作出处理。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-27T08:00:46+08:00">
    <meta property="article:modified_time" content="2024-04-27T08:00:46+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">什么是请求参数、表单参数、url参数、header参数、Cookie参数？一文讲懂_前端请求参数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <ul><li>请求方式后面跟的是请求的路径，一般把这个叫 URI（统一资源标识符）</li></ul> 
<blockquote> 
 <p>补充：URL 是统一资源定位符，见名知义，因为要定位，所以要指定协议甚至是位置，比如这样：<code>http://localhost:5000/api/hello</code></p> 
</blockquote> 
<ul><li>请求路径后面跟的是 HTTP 的版本，比如这里是 <code>HTTP/1.1</code></li></ul> 
<p>完整的第一行如下：</p> 
<pre><code>POST /api/hello HTTP/1.1

</code></pre> 
<p>第二行的 User-Agent 则用于告诉对方发起请求的客户端是啥，比如咱们用 Postman 发起的请求，Postman 就会自动把这个参数设置为它自己：</p> 
<pre><code>User-Agent: PostmanRuntime/7.28.4

</code></pre> 
<p>第三行的 Accept 用于告诉对方我们希望收到什么类型的数据，这里默认是能接受所有类型的数据：</p> 
<pre><code>Accept: */*

</code></pre> 
<p>第四行就非常值得留意，<code>Postman-Token</code> 是 Postman 自己传的参数，这个我们放到下面讲！</p> 
<pre><code>Postman-Token: ddd72e1a-0d63-4bad-a18e-22e38a5de3fc

</code></pre> 
<p>第五行是请求的主机，网络上的一个服务一般用 ip 加端口作为唯一标识：</p> 
<pre><code>Host: 127.0.0.1:5000

</code></pre> 
<p>第六行指定的是咱们请求发起方可以理解的压缩方式：</p> 
<pre><code>Accept-Encoding: gzip, deflate, br

</code></pre> 
<p>第七行告诉对方处理完当前请求后不要关闭连接：</p> 
<pre><code>Connection: keep-alive

</code></pre> 
<p>第八行告诉对方咱们请求体的内容格式，这个是本文的侧重点啦！比如我们这里指定的是一般浏览器的原生表单格式：</p> 
<pre><code>Content-Type: application/x-www-form-urlencoded

</code></pre> 
<h4><a id="%C2%A0_%C2%A0_%C2%A0_%C2%A0MST_86"></a>前端面试    用前端面试题库   MST题宝库</h4> 
<p><img src="https://images2.imgbox.com/4f/e0/8bClNqRm_o.jpg" alt=""></p> 
<p>好了，下面大家要留意了，第九行的 Content-Length 给出的是请求体的大小。</p> 
<p>而请求体，会放在紧跟着的一个空行之后。比如本请求的请求体内容是以 <code>key=value</code> 形式填充的，也就是我们表单参数的内容了：</p> 
<pre><code>Content-Length: 23

name=%E9%98%BF%E8%8F%8C

</code></pre> 
<p>看到这里我们先简单小结一下，想要告诉服务器我们发送的是表单数据，一共需要两步：</p> 
<ol><li>将 <code>Content-Type</code> 设置为 <code>application/x-www-form-urlencoded</code></li><li>在请求体中按照 <code>key=value</code> 的形式填写请求参数</li></ol> 
<h4><a id="_http_113"></a>什么是协议？进一步了解 http</h4> 
<p>好了，接下来我们进一步讲解，大家试想一下，网络应用，其实就是端到端的交互，最常见的就是服务端和客户端交互模型：客户端发一些参数数据给服务端，通过这些参数数据告诉服务端它想得到什么或想干什么，服务端根据客户端传递的参数数据作出处理。</p> 
<p>传输层协议通过 ip 和端口号帮我们定位到了具体的服务应用，具体怎么交互是由我们程序员自己定义的。</p> 
<p>大概在 30 年前，英国计算机科学家蒂姆·伯纳斯-李定义了原始超级文本传输协议（HTTP），后续我们的 web 应用大都延续采用了他定义的这套标准，当然这套标准也在不断地进行迭代。</p> 
<p>许多文献资料会把 http 协议描述得比较晦涩，加上协议这个词听起来有点高大上，初学者入门学习的时候往往感觉不太友好。</p> 
<p>其实协议说白了就是一种格式，就好比我们写书信，约定要先顶格写个敬爱的 xxx，然后写个你好，然后换一个段落再写正文，可能最后还得加上日期署名等等。</p> 
<p>我们只要按照格式写信，老师就能一眼看出来我们在写信；只要我们按协议格式发请求数据，服务器就能一眼看出来我们想要得到什么或想干什么。</p> 
<p>当然，老师是因为老早就学过书信格式，所以他才能看懂书信格式；服务端程序也一样，我们要预先编写好 http 协议的解析逻辑，然后我们的服务器才能根据解析逻辑去获取一个 http 请求中的各种东西。</p> 
<p>当然这个解析 http 协议的逻辑不是谁都能写出来的，就算能写出来，也未必写得好，所以我们会使用厉害的人封装好的脚手架，比如 java 里的 spring 全套、Go 语言里的 Gin 等等。</p> 
<p>回到我们开头给出的示例：</p> 
<pre><code>from flask import Flask
from flask import request

app = Flask(__name__)

# 云你好服务 API 接口
@app.get("/api/hello")
def hello():
    # 看用户是否传递了参数 name
    name = request.args.get("name", "")
    # 如果传了参数就向目标对象打招呼，输出 Hello XXX，否则输出 Hello World
    return f"Hello {name}" if name else "Hello World"

# 启动云你好服务
if __name__ == '__main__':
    app.run()

</code></pre> 
<p>阿菌的示例使用了 python 里的 flask 框架，在处理逻辑中使用了 request.args 获取请求参数，而 args 封装的就是框架从 url 中获取参数的逻辑。比如我们发送请求的 url 为：</p> 
<pre><code>http://127.0.0.1:5000/api/hello?name=ajun

</code></pre> 
<p>框架会帮助我们从 url 中的 ? 后面开始截取，然后把 <code>name=ajun</code> 这些参数存放到 args 里。</p> 
<p>切换一下，假设我们是云你好服务提供者，我们希望用户通过表单参数的形式使用云你好服务，我们只要把获取 name 参数的方式改成从表单参数里获取就可以了，flask 在 request.form 里封装了表单参数（关于框架是怎么在数行 http 请求中封装参数的，大家可以看自己使用的框架的具体逻辑，估计区别不大，只是存在一些语言特性上的差异）：</p> 
<pre><code>@app.post("/api/hello")
def hello():
    # 看用户是否传递了参数 name
    name = request.form.get("name", "")
    # 如果传了参数就向目标对象打招呼，输出 Hello XXX，否则输出 Hello World
    return f"Hello {name}" if name else "Hello World"

</code></pre> 
<h4><a id="_http__190"></a>思考：我们可以在 http 协议中传递什么参数？</h4> 
<p>最后，我们解释本文的标题，其实想要明白各种参数之间的区别，我们可以换一个角度思考：</p> 
<blockquote> 
 <p>咱们可以在一份 http 报文的哪些位置传递参数？</p> 
</blockquote> 
<h4><a id="%C2%A0_%C2%A0_%C2%A0_%C2%A0MST_204"></a>前端面试    用前端面试题库   MST题宝库</h4> 
<p><img src="https://images2.imgbox.com/97/bb/EAu8ZETp_o.jpg" alt=""></p> 
<p>接下来回顾一下一个 http 请求的内容：</p> 
<pre><code>POST /api/hello HTTP/1.1
User-Agent: PostmanRuntime/7.28.4
Accept: */*
Postman-Token: fbf75035-a647-46dc-adc0-333751a9399e
Host: 127.0.0.1:5000
Accept-Encoding: gzip, deflate, br
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 23

name=%E9%98%BF%E8%8F%8C

</code></pre> 
<p>大家看，咱们的 http 报文，也就是基于传输层之上的应用层报文，大概就长上面这样。</p> 
<p>我们考虑两种情况，第一种情况，我们基于别人已经开发好的脚手架开发 http 服务器。</p> 
<p>由于框架会基于 http 协议进行解析，所以框架会帮助我们解析好请求 url，各种 Header 头（比如：Cookie 等），以及具体的响应内容都帮我们封装解析好了（比如按照 key=value 的方式去读取请求体）。</p> 
<p><strong>对象篇</strong></p> 
<p><img src="https://images2.imgbox.com/8d/ce/U0XaggTB_o.png" alt=""></p> 
<p><img src="https://images2.imgbox.com/4a/1a/RhIGdPXV_o.png" alt=""></p> 
<p><strong>模块化编程-自研模块加载器</strong></p> 
<p><img src="https://images2.imgbox.com/d0/47/cUbcB8qz_o.png" alt=""></p> 
<p><strong><a href="https://bbs.csdn.net/topics/618166371">开源分享：【大厂前端面试题解析+核心总结学习笔记+真实项目实战+最新讲解视频】</a></strong></p> 
<p><img src="https://images2.imgbox.com/c3/f3/wYgKr9Xf_o.png" alt=""></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bb52dcd9a4b07d1f8ebf4258fee1ccd7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">AI大模型探索之路-训练篇3：大语言模型全景解读</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/51b3d7c5211029932c2ef18e16f099a9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java常见的技术场景面试题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>