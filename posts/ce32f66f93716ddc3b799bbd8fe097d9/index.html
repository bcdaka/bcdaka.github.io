<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】--- 顺序表 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/ce32f66f93716ddc3b799bbd8fe097d9/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】--- 顺序表">
  <meta property="og:description" content="目录
前言： 顺序表
动态顺序表的实现
代码总览：
前言：
数据结构是由“数据”和“结构”两词组合而来。
什么是数据？
常见的数值1、2、3、4.....、教务系统⾥保存的⽤⼾信息（姓名、性别、年龄、学历等
等）、网页里肉眼可以看到的信息（文字、图片、视频等等），这些都是数据
什么是结构？
当我们想要使⽤大量使⽤同⼀类型的数据时，通过⼿动定义⼤量的独立的变量对于程序来说，可读性非常差，我们可以借助数组这样的数据结构将⼤量的数据组织在⼀起，结构也可以理解为组织数据的方式
简而言之
能够存储数据（如顺序表、链表等结构） 存储的数据能够方便查找 那么为什么需要数据结构呢？
假定数组有10个空间，已经使用了5个，向数组中插入数据步骤：
求数组的长度，求数组的有效数据个数，向下标为数据有效个数的位置插入数据（注意：这里是
否要判断数组是否满了，满了还能继续插⼊吗）.....
假设数据量非常庞大，频繁的获取数组有效数据个数会影响程序执行效率。
结论：
最基础的数据结构能够提供的操作已经不能完全满⾜复杂算法实现。
顺序表 线性表
线性表是n个具有相同特性的数据元素的有限序列。线性表是一种在实际中广泛使用的数据结构，常见的线性表：顺序表、链表、栈、队列、字符串等
线性表在了逻辑上是线性结构，也就是说是一条直线。但是在物理结构上并不一定是连续的，线性表在物理结构上存储时，通常以数组和链式结构的形式存储。
知识补充：
逻辑结构和物理结构
1.逻辑结构：
所谓逻辑结构就是数据与数据之间的关联关系，准确的说是数据元素之间的关联关系。
注：所有的数据都是由数据元素构成，数据元素是数据的基本构成单位。而数据元素由多个数据项构成。
逻辑结构有四种基本类型：集合结构、线性结构、树状结构和网络结构。也可以统一的分为线性结构和非线性结构。
2.物理结构：
数据的物理结构就是数据存储在磁盘中的方式。官方语言为：数据结构在计算机中的表示（又称映像）称为数据的物理结构，或称存储结构。它所研究的是数据结构在计算机中的实现方法，包括数据结构中元素的表示及元素间关系的表示。
而物理结构一般有四种：顺序存储，链式存储，散列，索引
顺序表
顺序表的底层结构就是数组，对数组的封装，实现了常用的增删改查等接口
顺序表可以分为静态顺序表和动态顺序表
静态顺序表
静态顺序表是使用定长的数组来存储元素
#define N 10 typedef int Type; //静态顺序表 struct SeqList { Type arr[N];//定长数组 int size;//有效数据个数 }; 使用动态顺序表缺陷：空间给小了不够用，空间给多了造成空间浪费
动态顺序表
动态顺序表的实现 静态顺序表是定长数组，而动态顺序表是可增容的，不会浪费空间也不会出现空间不够的场景，这里来实现动态顺序表存储整形数据：
首先就是顺序表的一些功能
这里将其写入SeqList.h 的头文件中
SeqList.h头文件
#pragma once #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;assert.h&gt; typedef int Type; typedef struct SeqList//动态顺序表 { Type* arr; int size; int num; }SL; //动态顺序表 // 初始化 void SLInit(SL* p); //销毁 void SLDesTroy(SL* p); //输出 void SLPrint(SL* p); //顺序表扩容 void SLExps(SL* p); //从头部插入数据 void SLAddHand(SL* p, Type x); //从头部删除数据 void SLDelHand(SL* p); //从尾部插入数据 void SLAddEnd(SL* p, Type x); //从尾部删除数据 void SLDelEnd(SL* p); //从任意位置插入数据 void SLAddeve(SL* p, Type x, int t); //从任意位置删除数据 void SLDeleve(SL* p, int t); //查找数据 int SLFind(SL* p, Type f); 要存储一些数据，顺序表具备以上功能（对于整型）">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-17T16:48:19+08:00">
    <meta property="article:modified_time" content="2024-07-17T16:48:19+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】--- 顺序表</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80%EF%BC%9A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80%EF%BC%9A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0" rel="nofollow">前言：        </a></p> 
<p id="%E9%A1%BA%E5%BA%8F%E8%A1%A8-toc" style="margin-left:0px;"><a href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8" rel="nofollow">顺序表</a></p> 
<p id="%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">动态顺序表的实现</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E6%80%BB%E8%A7%88%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%BB%A3%E7%A0%81%E6%80%BB%E8%A7%88%EF%BC%9A" rel="nofollow">代码总览：</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E5%89%8D%E8%A8%80%EF%BC%9A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0"><strong>前言：</strong><br>         </h2> 
<p style="margin-left:.0001pt;text-align:justify;">数据结构是由“数据”和“结构”两词组合而来。</p> 
<p style="margin-left:.0001pt;text-align:justify;">        什么是数据？</p> 
<p style="margin-left:.0001pt;text-align:justify;">常见的数值1、2、3、4.....、教务系统⾥保存的⽤⼾信息（姓名、性别、年龄、学历等</p> 
<p style="margin-left:.0001pt;text-align:justify;">等）、网页里肉眼可以看到的信息（文字、图片、视频等等），这些都是数据</p> 
<p style="margin-left:.0001pt;text-align:justify;">        什么是结构？</p> 
<p style="margin-left:.0001pt;text-align:justify;">当我们想要使⽤大量使⽤同⼀类型的数据时，通过⼿动定义⼤量的独立的变量对于程序来说，可读性非常差，我们可以借助数组这样的数据结构将⼤量的数据组织在⼀起，结构也可以理解为组织数据的方式</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="color:#ff9900;">简而言之</span></strong></p> 
<ol><li><span style="color:#646a73;">能够存储数据（如顺序表、链表等结构） </span></li><li><span style="color:#646a73;">存储的数据能够方便查找</span></li></ol> 
<p><span style="color:#646a73;">那么为什么需要数据结构呢？</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">假定数组有10个空间，已经使用了5个，向数组中插入数据步骤：</p> 
<p style="margin-left:.0001pt;text-align:justify;">求数组的长度，求数组的有效数据个数，向下标为数据有效个数的位置插入数据（注意：这里是</p> 
<p style="margin-left:.0001pt;text-align:justify;">否要判断数组是否满了，满了还能继续插⼊吗）.....</p> 
<p style="margin-left:.0001pt;text-align:justify;">假设数据量非常庞大，频繁的获取数组有效数据个数会影响程序执行效率。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff9900;"><strong>结论：</strong></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff9900;"><strong>        </strong></span>最基础的数据结构能够提供的操作已经不能完全满⾜复杂算法实现。</p> 
<h2 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8" style="margin-left:.0001pt;text-align:justify;">顺序表</h2> 
<p><span style="color:#ff9900;"><strong><span style="background-color:#38d8f0;">线性表</span></strong></span></p> 
<p>        线性表是n个具有相同特性的数据元素的有限序列。线性表是一种在实际中广泛使用的数据结构，常见的线性表：顺序表、链表、栈、队列、字符串等</p> 
<p>        线性表在了逻辑上是线性结构，也就是说是一条直线。但是在物理结构上并不一定是连续的，线性表在物理结构上存储时，通常以数组和链式结构的形式存储。</p> 
<p><strong><span style="color:#4da8ee;"><span style="background-color:#ffd900;">知识补充：</span></span></strong></p> 
<p><span style="color:#4da8ee;"><strong><span style="background-color:#ffd900;">逻辑结构和物理结构</span></strong></span></p> 
<p><span style="color:#0d0016;"><strong>1.逻辑结构：</strong></span></p> 
<p><span style="color:#0d0016;"><strong>所谓逻辑结构就是数据与数据之间的关联关系，准确的说是数据元素之间的关联关系。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>注：所有的数据都是由数据元素构成，数据元素是数据的基本构成单位。而数据元素由多个数据项构成。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>逻辑结构有四种基本类型：集合结构、线性结构、树状结构和网络结构。也可以统一的分为线性结构和非线性结构。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>2.物理结构：</strong></span></p> 
<p><span style="color:#0d0016;"><strong>数据的物理结构就是数据存储在磁盘中的方式。官方语言为：数据结构在计算机中的表示（又称映像）称为数据的物理结构，或称存储结构。它所研究的是数据结构在计算机中的实现方法，包括数据结构中元素的表示及元素间关系的表示。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>而物理结构一般有四种：顺序存储，链式存储，散列，索引</strong></span></p> 
<p></p> 
<p><span style="color:#ff9900;"><strong><span style="background-color:#38d8f0;">顺序表</span></strong></span></p> 
<p><span style="color:#0d0016;"><strong>顺序表的底层结构就是数组，对数组的封装，实现了常用的增删改查等接口</strong></span></p> 
<p><strong>顺序表可以分为静态顺序表和动态顺序表</strong></p> 
<p><strong>        静态顺序表</strong></p> 
<p><strong>静态顺序表是使用定长的数组来存储元素</strong></p> 
<pre><code>#define N 10
typedef int Type;
//静态顺序表
struct SeqList
{
	Type arr[N];//定长数组
	int size;//有效数据个数
};</code></pre> 
<p><img alt="" height="691" src="https://images2.imgbox.com/f5/9e/BGWev4Rc_o.png" width="1059"></p> 
<p><span style="background-color:#fff5e6;">使用动态顺序表缺陷：空间给小了不够用，空间给多了造成空间浪费</span></p> 
<p></p> 
<p><strong>        动态顺序表</strong></p> 
<p><img alt="" height="669" src="https://images2.imgbox.com/be/81/dvrSuB3V_o.png" width="844"></p> 
<p></p> 
<h2 id="%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0">动态顺序表的实现</h2> 
<p>静态顺序表是定长数组，而动态顺序表是可增容的，不会浪费空间也不会出现空间不够的场景，这里来实现动态顺序表存储<strong><span style="color:#0d0016;"><span style="background-color:#956fe7;">整形数据</span></span></strong>：</p> 
<p><span style="color:#0d0016;"><strong>首先就是顺序表的一些功能</strong></span></p> 
<p>这里将其写入SeqList.h 的头文件中</p> 
<p style="margin-left:.0001pt;text-align:justify;">SeqList.h头文件</p> 
<pre><code class="language-cpp">#pragma once
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
typedef int Type;
typedef struct SeqList//动态顺序表
{
	Type* arr;
	int size;
	int num;
}SL;
//动态顺序表
// 初始化
void SLInit(SL* p);
//销毁
void SLDesTroy(SL* p);
//输出
void SLPrint(SL* p);
//顺序表扩容
void SLExps(SL* p);
//从头部插入数据
void SLAddHand(SL* p, Type x);
//从头部删除数据
void SLDelHand(SL* p);
//从尾部插入数据
void SLAddEnd(SL* p, Type x);
//从尾部删除数据
void SLDelEnd(SL* p);
//从任意位置插入数据
void SLAddeve(SL* p, Type x, int t);
//从任意位置删除数据
void SLDeleve(SL* p, int t);
//查找数据
int SLFind(SL* p, Type f);</code></pre> 
<p>要存储一些数据，顺序表具备以上功能（对于整型）</p> 
<p><span style="color:#ff9900;"><strong><span style="background-color:#38d8f0;">顺序表初始化</span></strong></span></p> 
<p>        顺序表初始化，其实就是将动态顺序表中指针置为NULL，有效数据和空间容量置为0；</p> 
<p>代码如下：</p> 
<pre><code class="language-cpp">// 初始化
void SLInit(SL* p)
{
	p-&gt;arr = NULL;
	p-&gt;size = 0;
	p-&gt;num = 0;
}</code></pre> 
<p><img alt="" height="111" src="https://images2.imgbox.com/e3/98/s2pmeI5j_o.png" width="853"></p> 
<p>在初始化完成后s中的数据。</p> 
<p><span style="color:#ff9900;"><strong><span style="background-color:#38d8f0;">顺序表销毁</span></strong></span></p> 
<p>        在使用完顺序表后，就要销毁顺序表，因为动态顺序表内存是动态开辟的，所以需要对动态内存进行释放，并将有效数据和空间容量个数置为0；</p> 
<p>代码如下：</p> 
<pre><code class="language-cpp">//销毁
void SLDesTroy(SL* p)
{
	if (p-&gt;arr != NULL)
	{
		free(p-&gt;arr);
		p-&gt;arr = NULL;
	}
	p-&gt;size = 0;
	p-&gt;num = 0;
}</code></pre> 
<p>        顺序表销毁之后，指针置为NULL，有效数据和空间容量的为0；</p> 
<p><span style="color:#ff9900;"><strong><span style="background-color:#38d8f0;">顺序表输出</span></strong></span></p> 
<p>        现在如果顺序表中有数据，我们需要查看数据，就要用到顺序表的输出</p> 
<p>代码如下：</p> 
<pre><code class="language-cpp">//输出
void SLPrint(SL* p)
{
	for (int i = 0; i &lt; p-&gt;size; i++)
	{
		printf("%d ", p-&gt;arr[i]);
	}
	printf("\n%d %d\n", p-&gt;size, p-&gt;num);
}</code></pre> 
<p>测试看一下输出<img alt="" height="641" src="https://images2.imgbox.com/49/fc/dXClcivf_o.png" width="797"></p> 
<p>        这里将有效数字和空间容量也输出出来以便查看，<span style="color:#a2e043;"><strong>下面插入数据以后就不在进行输出了</strong></span></p> 
<p><span style="color:#ff9900;"><strong><span style="background-color:#38d8f0;">顺序表扩容</span></strong></span></p> 
<p>        我们要像顺序表中插入数据，这必然会涉及到扩容的问题</p> 
<p>代码如下：</p> 
<pre><code class="language-cpp">//顺序表扩容
void SLExps(SL* p)
{
	int num = (p-&gt;num == 0) ? 4 : 2 * p-&gt;num;
	Type* tmp = (Type*)realloc(p-&gt;arr, num * sizeof(Type));
	assert(tmp);
	p-&gt;arr = tmp;
	p-&gt;num = num;
}</code></pre> 
<p>如果首次扩容，即p-&gt;num等于0，这样习惯给它赋值成4，以后每次扩容以倍数增加（这里使用2倍，也可以使用3倍）。</p> 
<p>扩容以后再测试看一下输出结果（查看有效数据和空间容量）<span style="background-color:#38d8f0;"><img alt="" height="755" src="https://images2.imgbox.com/8b/dc/eNoYyYFF_o.png" width="601"></span></p> 
<p>这里首次扩容，空间容量为4。</p> 
<p><span style="color:#fe2c24;"><strong>        注：</strong></span><strong><span style="color:#ff9900;">扩容主要使用在插入数据判断空间大小不够时</span></strong></p> 
<p><span style="color:#ff9900;"><strong><span style="background-color:#38d8f0;">顺序表头插</span></strong></span></p> 
<p>现在需要从顺序表头部（起始位置）插入数据，这里就需要将<span style="background-color:#38d8f0;">有效数据向后移动一位</span>，再进行插入数据以防数据丢失。</p> 
<p>        当然，再插入数据之前需要判断空间是否足够</p> 
<p>代码如下：</p> 
<pre><code class="language-cpp">//从头部插入数据
void SLAddHand(SL* p, Type x)
{
	if (p-&gt;size &gt;= p-&gt;num)
	{
		SLExps(p);
	}
	for (int i = p-&gt;size; i &gt; 0; i--)
	{
		p-&gt;arr[i] = p-&gt;arr[i - 1];
	}
	p-&gt;arr[0] = x;
	p-&gt;size++;
}</code></pre> 
<p>测试以下代码是否正确<img alt="" height="142" src="https://images2.imgbox.com/50/b8/0xPme4ZR_o.png" width="628"></p> 
<p><span style="color:#ff9900;"><strong><span style="background-color:#38d8f0;">顺序表头删</span></strong></span></p> 
<p>从起始位置删除数据，就需要把有效数据向前移动一位，并且有效数据个数-1；</p> 
<p>代码如下：<br>  </p> 
<pre><code class="language-cpp">//从头部删除数据
void SLDelHand(SL* p)
{
	for (int i = 0; i &lt; p-&gt;size - 1; i++)
	{
		p-&gt;arr[i] = p-&gt;arr[i + 1];
	}
	p-&gt;size--;
}</code></pre> 
<p>测试：<img alt="" height="257" src="https://images2.imgbox.com/49/bc/5u5DRIZV_o.png" width="548"></p> 
<p><span style="color:#ff9900;"><strong><span style="background-color:#38d8f0;">顺序表尾插</span></strong></span></p> 
<p>现在从尾部插入数据，很简单直接在数据末尾插入数据，然后有效数据+1；</p> 
<p>        当然，也需要进行判断空间是否足够</p> 
<p>代码如下：</p> 
<pre><code class="language-cpp">//从尾部插入数据
void SLAddEnd(SL* p, Type x)
{
	if (p-&gt;size &gt;= p-&gt;num)
	{
		SLExps(p);
	}
	p-&gt;arr[p-&gt;size] = x;
	p-&gt;size++;
}</code></pre> 
<p>测试：<img alt="" height="412" src="https://images2.imgbox.com/02/cc/QCI0kSib_o.png" width="589"></p> 
<p><span style="color:#ff9900;"><strong><span style="background-color:#38d8f0;">顺序表尾删</span></strong></span></p> 
<p>从尾部删除数据很简单马，可以直接让有效数据个数-1；</p> 
<p>代码如下:</p> 
<pre><code class="language-cpp">//从尾部删除数据
void SLDelEnd(SL* p)
{
	p-&gt;size--;
}</code></pre> 
<p>测试：</p> 
<p><img alt="" height="537" src="https://images2.imgbox.com/6d/c0/vpS4QVqu_o.png" width="541"></p> 
<p><span style="color:#ff9900;"><strong><span style="background-color:#38d8f0;">顺序表任意位置插入</span></strong></span></p> 
<p>        从任意位置插入数据，需要将指定位置数据以后的有效数据向后移动一位，再进行插入</p> 
<p>代码：</p> 
<pre><code class="language-cpp">//从任意位置插入数据
void SLAddeve(SL* p, Type x, int t)
{
	if (p-&gt;size &gt;= p-&gt;num)
	{
		SLExps(p);
	}
	for (int i = p-&gt;size; i &gt; t; i--)
	{
		p-&gt;arr[i] = p-&gt;arr[i - 1];
	}
	p-&gt;arr[t] = x;
	p-&gt;size++;
}</code></pre> 
<p>这里就不输出有效数字个数和空间容量了</p> 
<p>测试：<img alt="" height="383" src="https://images2.imgbox.com/46/b3/tR7mtYhS_o.png" width="629"></p> 
<p><span style="color:#ff9900;"><strong><span style="background-color:#38d8f0;">顺序表任意数据删除</span></strong></span></p> 
<p>从任意位置删除数据，将该位置后的数据向前移动一位</p> 
<p>代码如下：</p> 
<pre><code class="language-cpp">//从任意位置删除数据
void SLDeleve(SL* p, int t)
{
	for (int i = t; i &lt; p-&gt;size - 1; i++)
	{
		p-&gt;arr[i] = p-&gt;arr[i + 1];
	}
	p-&gt;size--;
}</code></pre> 
<p>测试：</p> 
<p><img alt="" height="508" src="https://images2.imgbox.com/0f/1b/SFQL6Vps_o.png" width="604"></p> 
<p><span style="color:#ff9900;"><strong><span style="background-color:#38d8f0;">顺序表查找</span></strong></span></p> 
<p>现在我们需要在顺序表中查找数据</p> 
<p>这里也可以写函数返回数据的下标</p> 
<p>代码：</p> 
<pre><code class="language-cpp">//查找数据
void SLFind(SL* p, Type f)
{
	for (int i = 0; i &lt; p-&gt;size; i++)
	{
		if (p-&gt;arr[i] == f)
		{
			printf("查找的数据下标为：%d\n", i);
			return;
		}
	}
	printf("所查找的数据不存在\n");
}</code></pre> 
<p>测试：<br><img alt="" height="143" src="https://images2.imgbox.com/c4/82/x1r5TIxC_o.png" width="589"></p> 
<p></p> 
<p>到这里，顺序表的知识就完成了，学完这些，我们也要写顺序表的实践，就是通讯录——在下一篇进行实现。</p> 
<h2 id="%E4%BB%A3%E7%A0%81%E6%80%BB%E8%A7%88%EF%BC%9A">代码总览：</h2> 
<p>SeqList.h</p> 
<pre><code class="language-cpp">#pragma once
#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
typedef int Type;
typedef struct SeqList//动态顺序表
{
	Type* arr;
	int size;
	int num;
}SL;

//动态顺序表
// 初始化
void SLInit(SL* p);
//销毁
void SLDesTroy(SL* p);
//输出
void SLPrint(SL* p);
//顺序表扩容
void SLExps(SL* p);
//从头部插入数据
void SLAddHand(SL* p, Type x);
//从头部删除数据
void SLDelHand(SL* p);
//从尾部插入数据
void SLAddEnd(SL* p, Type x);
//从尾部删除数据
void SLDelEnd(SL* p);
//从任意位置插入数据
void SLAddeve(SL* p, Type x, int t);
//从任意位置删除数据
void SLDeleve(SL* p, int t);
//查找数据
void SLFind(SL* p, Type f);</code></pre> 
<p>SeqList.c</p> 
<pre><code class="language-cpp">#include"SeqList.h"

// 初始化
void SLInit(SL* p)
{
	p-&gt;arr = NULL;
	p-&gt;size = 0;
	p-&gt;num = 0;
}
//销毁
void SLDesTroy(SL* p)
{
	if (p-&gt;arr != NULL)
	{
		free(p-&gt;arr);
		p-&gt;arr = NULL;
	}
	p-&gt;size = 0;
	p-&gt;num = 0;
}
//输出
void SLPrint(SL* p)
{
	for (int i = 0; i &lt; p-&gt;size; i++)
	{
		printf("%d ", p-&gt;arr[i]);
	}
	printf("\n");
	//printf("%d %d\n", p-&gt;size, p-&gt;num);
}
//顺序表扩容
void SLExps(SL* p)
{
	int num = (p-&gt;num == 0) ? 4 : 2 * p-&gt;num;
	Type* tmp = (Type*)realloc(p-&gt;arr, num * sizeof(Type));
	assert(tmp);
	p-&gt;arr = tmp;
	p-&gt;num = num;
}
//从头部插入数据
void SLAddHand(SL* p, Type x)
{
	if (p-&gt;size &gt;= p-&gt;num)
	{
		SLExps(p);
	}
	for (int i = p-&gt;size; i &gt; 0; i--)
	{
		p-&gt;arr[i] = p-&gt;arr[i - 1];
	}
	p-&gt;arr[0] = x;
	p-&gt;size++;
}
//从头部删除数据
void SLDelHand(SL* p)
{
	for (int i = 0; i &lt; p-&gt;size - 1; i++)
	{
		p-&gt;arr[i] = p-&gt;arr[i + 1];
	}
	p-&gt;size--;
}
//从尾部插入数据
void SLAddEnd(SL* p, Type x)
{
	if (p-&gt;size &gt;= p-&gt;num)
	{
		SLExps(p);
	}
	p-&gt;arr[p-&gt;size] = x;
	p-&gt;size++;
}
//从尾部删除数据
void SLDelEnd(SL* p)
{
	p-&gt;size--;
}
//从任意位置插入数据
void SLAddeve(SL* p, Type x, int t)
{
	if (p-&gt;size &gt;= p-&gt;num)
	{
		SLExps(p);
	}
	for (int i = p-&gt;size; i &gt; t; i--)
	{
		p-&gt;arr[i] = p-&gt;arr[i - 1];
	}
	p-&gt;arr[t] = x;
	p-&gt;size++;
}
//从任意位置删除数据
void SLDeleve(SL* p, int t)
{
	for (int i = t; i &lt; p-&gt;size - 1; i++)
	{
		p-&gt;arr[i] = p-&gt;arr[i + 1];
	}
	p-&gt;size--;
}
//查找数据
void SLFind(SL* p, Type f)
{
	for (int i = 0; i &lt; p-&gt;size; i++)
	{
		if (p-&gt;arr[i] == f)
		{
			printf("查找的数据下标为：%d\n", i);
			return;
		}
	}
	printf("所查找的数据不存在\n");
}</code></pre> 
<p>测试代码（test.c）</p> 
<pre><code class="language-cpp">#include"SeqList.h"

void Test()
{
	SL s;
	//初始化
	SLInit(&amp;s);
	//SLPrint(&amp;s);//打印
	//扩容
	//SLExps(&amp;s);
	//SLPrint(&amp;s);//打印
	头插
	//SLAddHand(&amp;s, 520);
	//SLAddHand(&amp;s, 1314);
	//SLPrint(&amp;s);//打印
	头删
	//SLDelHand(&amp;s);
	//SLPrint(&amp;s);
	尾插
	//SLAddEnd(&amp;s, 1314);
	//SLAddEnd(&amp;s, 520);
	//SLPrint(&amp;s);
	尾删
	//SLDelEnd(&amp;s);
	//SLPrint(&amp;s);

	//头插
	SLAddHand(&amp;s, 1);
	SLAddHand(&amp;s, 2);
	SLAddHand(&amp;s, 3);
	SLAddHand(&amp;s, 4);
	//4 3 2 1 
	//任意位置插入
	SLAddeve(&amp;s, 9, 2);
	//4 3 9 2 1
	SLPrint(&amp;s);
	//任意位置删除
	SLDeleve(&amp;s, 2);
	SLPrint(&amp;s);
	//4 3 2 1
	SLFind(&amp;s, 9);
	SLFind(&amp;s, 2);
	//销毁
	SLDesTroy(&amp;s);
}
int main()
{
	Test();
	return 0;
}</code></pre> 
<p><span style="color:#fe2c24;"><strong><span style="background-color:#38d8f0;">制作不易，感到有帮助的可以一键三连支持一下，如果有错误的地方，也请指出！！！</span></strong></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/371946f6eeab3958c090ac166edd53a8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux--网络基础</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d99835c8517c8bf2746665c2984473dc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Apache Paimon 在蚂蚁的应用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>