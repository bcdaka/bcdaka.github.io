<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python的pytest框架(4)--参数化测试 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/860c5529bccb5edeb67452649ebd8892/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Python的pytest框架(4)--参数化测试">
  <meta property="og:description" content="在 pytest 测试框架中，参数化测试（Parametrized Testing）意味着将一个测试用例设计为能够接受不同输入数据（参数）并分别执行，以验证被测试代码在面对多种情况时的行为是否符合预期。参数化测试的核心理念是通过复用相同的测试逻辑，但使用不同的输入数据集来增加测试覆盖率，减少代码重复，并提高测试的灵活性和效率。该篇文章就如何使用pytest进行参数化配置来深入解析：
目录
一、参数化测试概念
二、使用 pytest.mark.parametrize
1、基本用法
2、多层参数化：组合数据示例
3、从外部文件加载参数数据（重要）
4、结合 fixture 进行参数化
5、动态参数生成
6、参数化与条件跳过
一、参数化测试概念 参数化测试是一种软件测试策略，它允许测试人员或开发人员使用一组预定义的输入数据集合来运行相同的测试逻辑。这意味着一个测试用例可以被设计为接受不同参数，并根据这些参数执行相应的测试操作。这种方法有助于提高测试覆盖率，确保程序在多种数据条件下的行为正确性，同时减少了编写重复测试代码的工作量。
在参数化测试中，测试脚本保持不变，但其执行时使用的数据集可以灵活变化。这些数据集可能包括边界条件、异常情况、典型用户输入、负测试用例等。通过参数化，测试团队可以系统地遍历各种预期和非预期的输入情况，确保软件在面对多种输入时都能稳定、准确地响应。
二、使用 pytest.mark.parametrize 1、基本用法 pytest的参数化主要通过 pytest.mark.parametrize 装饰器实现。这个装饰器允许你为测试函数指定一组或多组不同的输入数据和预期输出（如果有），从而生成多个独立的测试用例。
基本用法如下：
import pytest # 假设有一个待测试的函数 `add(a, b)` def add(a, b): return a &#43; b # 使用 @pytest.mark.parametrize 装饰器参数化测试函数 @pytest.mark.parametrize(&#34;a, b, expected_sum&#34;, [ (1, 2, 3), (0, 5, 5), (-1, -2, -3), # ... 更多测试数据 ]) def test_add(a, b, expected_sum): result = add(a, b) assert result == expected_sum 在这个例子中，pytest.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-19T11:03:17+08:00">
    <meta property="article:modified_time" content="2024-04-19T11:03:17+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python的pytest框架(4)--参数化测试</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在 pytest 测试框架中，参数化测试（Parametrized Testing）意味着将一个测试用例设计为能够接受不同输入数据（参数）并分别执行，以验证被测试代码在面对多种情况时的行为是否符合预期。参数化测试的核心理念是通过复用相同的测试逻辑，但使用不同的输入数据集来增加测试覆盖率，减少代码重复，并提高测试的灵活性和效率。该篇文章就如何使用pytest进行参数化配置来深入解析：</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E5%8F%82%E6%95%B0%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%8F%82%E6%95%B0%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A6%82%E5%BF%B5" rel="nofollow">一、参数化测试概念</a></p> 
<p id="%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%20pytest.mark.parametrize-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%20pytest.mark.parametrize" rel="nofollow">二、使用 pytest.mark.parametrize</a></p> 
<p id="1%E3%80%81%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95" rel="nofollow">1、基本用法</a></p> 
<p id="2%E3%80%81%E5%A4%9A%E5%B1%82%E5%8F%82%E6%95%B0%E5%8C%96%EF%BC%9A%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%A4%BA%E4%BE%8B-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%A4%9A%E5%B1%82%E5%8F%82%E6%95%B0%E5%8C%96%EF%BC%9A%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%A4%BA%E4%BE%8B" rel="nofollow">2、多层参数化：组合数据示例</a></p> 
<p id="3%E3%80%81%E4%BB%8E%E5%A4%96%E9%83%A8%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E5%8F%82%E6%95%B0%E6%95%B0%E6%8D%AE%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E4%BB%8E%E5%A4%96%E9%83%A8%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E5%8F%82%E6%95%B0%E6%95%B0%E6%8D%AE%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89" rel="nofollow">3、从外部文件加载参数数据（重要）</a></p> 
<p id="4%E3%80%81%E7%BB%93%E5%90%88%20fixture%20%E8%BF%9B%E8%A1%8C%E5%8F%82%E6%95%B0%E5%8C%96-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E7%BB%93%E5%90%88%20fixture%20%E8%BF%9B%E8%A1%8C%E5%8F%82%E6%95%B0%E5%8C%96" rel="nofollow">4、结合 fixture 进行参数化</a></p> 
<p id="5%E3%80%81%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0%E7%94%9F%E6%88%90-toc" style="margin-left:40px;"><a href="#5%E3%80%81%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0%E7%94%9F%E6%88%90" rel="nofollow">5、动态参数生成</a></p> 
<p id="6%E3%80%81%E5%8F%82%E6%95%B0%E5%8C%96%E4%B8%8E%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BF%87-toc" style="margin-left:40px;"><a href="#6%E3%80%81%E5%8F%82%E6%95%B0%E5%8C%96%E4%B8%8E%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BF%87" rel="nofollow">6、参数化与条件跳过</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E5%8F%82%E6%95%B0%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A6%82%E5%BF%B5">一、参数化测试概念</h2> 
<p>参数化测试是一种<strong>软件测试策略</strong>，它允许测试人员或开发人员使用一组<strong>预定义的输入数据集合</strong>来运行<strong>相同的测试逻辑</strong>。这意味着一个测试用例可以被设计为接受不同参数，并根据这些参数执行相应的测试操作。这种方法有助于提高测试覆盖率，确保程序在多种数据条件下的行为正确性，同时减少了编写重复测试代码的工作量。</p> 
<p>在参数化测试中，测试脚本保持不变，但其执行时使用的数据集可以灵活变化。这些数据集可能包括<strong>边界条件、异常情况、典型用户输入、负测试用例</strong>等。通过参数化，测试团队可以系统地遍历各种预期和非预期的输入情况，确保软件在面对多种输入时都能稳定、准确地响应。</p> 
<h2 id="%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%20pytest.mark.parametrize">二、使用 pytest.mark.parametrize</h2> 
<h3 id="1%E3%80%81%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">1、基本用法</h3> 
<p>pytest的参数化主要通过 pytest.mark.parametrize 装饰器实现。这个装饰器允许你为测试函数指定一组或多组不同的输入数据和预期输出（如果有），从而生成多个独立的测试用例。</p> 
<p>基本用法如下：</p> 
<pre><code class="language-python">import pytest

# 假设有一个待测试的函数 `add(a, b)`
def add(a, b):
    return a + b

# 使用 @pytest.mark.parametrize 装饰器参数化测试函数
@pytest.mark.parametrize("a, b, expected_sum", [
    (1, 2, 3),
    (0, 5, 5),
    (-1, -2, -3),
    # ... 更多测试数据
])
def test_add(a, b, expected_sum):
    result = add(a, b)
    assert result == expected_sum</code></pre> 
<p>在这个例子中，pytest.mark.parametrize 接受三个参数：</p> 
<blockquote> 
 <p><strong>参数名</strong>：一个由逗号分隔的字符串列表，表示要传递给测试函数的参数名。在这个例子中是 "a, b, expected_sum"。</p> 
 <p><strong>数据集</strong>：一个嵌套列表，其中每个内部元组对应一组测试数据。元组中的元素按照参数名的顺序与测试函数的参数对应。例如，元组 (1, 2, 3) 表示 a=1, b=2, expected_sum=3。</p> 
 <p></p> 
 <p><span style="background-color:#cccccc;">当 pytest 运行时，它会为每组数据生成一个单独的测试用例（我们写了三组数据也就是会生成三个单独的测试用例），并调用 test_add 函数，传入相应的参数值。这样，即使测试逻辑相同（即检查 add() 函数的输出是否等于预期和），由于使用了不同的输入数据，实际执行的是多个独立的测试。</span></p> 
</blockquote> 
<p>通过 ids 关键字参数，可以为生成的测试用例提供易读的名称，尤其是在测试数据难以从参数值直接推断的情况下：</p> 
<pre><code class="language-python">import pytest

#场景一：简单字符串列表
test_data = [(1, 2), (3, 4), (5, 6)]
ids = ["Case1", "Case2", "Case3"]

@pytest.mark.parametrize("a, b", test_data, ids=ids)
def test_multiply_numbers(a, b):
    assert a * b == a + b
'''
在这个例子中，ids 参数是一个包含三个字符串的列表，分别对应 test_data 中的三个元组。测试报告将显示为 "Case1", "Case2", "Case3" 而不是默认的参数值。
'''

#场景二：基于参数值生成名称
test_data = [(1, 2, 3), (4, 5, 9)]

@pytest.mark.parametrize("a, b, expected_sum", test_data, ids=lambda params: f"a={params[0]}_b={params[1]}_sum={params[2]}")
def test_addition(a, b, expected_sum):
    assert a + b == expected_sum
'''
这里的 ids 参数是一个 lambda 函数，它接收每个参数元组 params，并使用 f-string 格式化输出一个描述性的字符串，如 "a=1_b=2_sum=3"。这样，测试报告中的用例名称将明确反映每个测试用例的具体参数值。
'''

#场景三：自定义命名规则
def generate_id(data):
    username, password = data
    return f"{username}_{password[:3]}_login"

test_data = [("user1", "pass123"), ("user2", "passabc")]

@pytest.mark.parametrize("username, password", test_data, ids=generate_id)
def test_login(username, password):
    # 实现登录逻辑的断言
    pass
'''
在这个例子中，generate_id 函数接收包含用户名和密码的元组，返回一个如 "user1_pass1_登录" 或 "user2_passa_登录" 样式的字符串。这个自定义函数被直接用作 ids 参数，为每个测试用例生成具有特定格式的名称。
'''

#场景四：处理中文及其他非 ASCII 字符
test_data = [(1, "你好"), (2, "世界")]
ids = [f"Case_{i}_({text})".encode("utf-8") for i, text in enumerate(test_data, start=1)]

@pytest.mark.parametrize("num, text", test_data, ids=ids)
def test_chinese_text(num, text):
    assert isinstance(text, str)
'''在这个例子中，ids 列表中的每个字符串都被显式地 encode() 成 UTF-8 编码。如果控制台能够正确处理 UTF-8 输出，则无需解码；否则，可能需要在显示时进行 decode()。'''</code></pre> 
<h3 id="2%E3%80%81%E5%A4%9A%E5%B1%82%E5%8F%82%E6%95%B0%E5%8C%96%EF%BC%9A%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%A4%BA%E4%BE%8B">2、多层参数化：组合数据示例</h3> 
<p>有时需要对多个参数进行不同的组合，形成复杂的测试矩阵。这可以通过应用多个 pytest.mark.parametrize 装饰器来实现。它们提供的数据集会按照笛卡尔积的方式组合，生成更复杂的测试用例矩阵：</p> 
<pre><code class="language-python">def multiply(a, b):
    return a * b

# 参数化 `a` 的数据
a_values = [-2, 0, 1, 2]

# 参数化 `b` 的数据
b_values = [0, 1, 2, 3]

# 为 `a` 和 `b` 分别应用参数化，生成所有组合的测试用例
@pytest.mark.parametrize("a", a_values)
@pytest.mark.parametrize("b", b_values)
def test_multiply(a, b):
    expected_product = a * b
    assert multiply(a, b) == expected_product</code></pre> 
<p>在这个示例中，我们分别为 a 和 b 定义了参数化数据。每个参数的装饰器都会生成一系列测试用例。由于两个装饰器同时作用于 test_multiply() 函数，pytest 会按照笛卡尔积的方式组合 a 和 b 的所有可能值，生成 4 × 4 = 16 个测试用例。</p> 
<h3 id="3%E3%80%81%E4%BB%8E%E5%A4%96%E9%83%A8%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E5%8F%82%E6%95%B0%E6%95%B0%E6%8D%AE%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89">3、从外部文件加载参数数据（重要）</h3> 
<p>在实际项目中，参数数据可能会非常多，或者需要根据实际情况动态调整。此时，可以从外部文件（如 CSV、JSON）加载参数数据。使用外部文件通常会需要使用第三方库来操作读取文件数据：</p> 
<pre><code class="language-python">import csv
import pytest

# 假设有一个 `test_data.csv` 文件，内容如下：
# a,b,expected_result
# 1,2,3
# 4,5,20
# ...

def load_test_data(file_path):
    test_data = []
    with open(file_path, newline='') as csvfile:
        reader = csv.DictReader(csvfile)
        for row in reader:
            test_data.append((int(row['a']), int(row['b']), int(row['expected_result'])))
    return test_data

test_data = load_test_data('test_data.csv')

@pytest.mark.parametrize("a, b, expected_result", test_data)
def test_multiply_from_file(a, b, expected_result):
    assert multiply(a, b) == expected_result</code></pre> 
<p>这里，我们定义了一个 load_test_data() 函数，它从指定的 CSV 文件中读取参数数据，并将其转换为一个包含 (a, b, expected_result) 元组的列表。然后，将这个列表作为参数数据传递给 pytest.mark.parametrize。这样，测试数据就可以独立于测试代码进行管理和更新。</p> 
<h3 id="4%E3%80%81%E7%BB%93%E5%90%88%20fixture%20%E8%BF%9B%E8%A1%8C%E5%8F%82%E6%95%B0%E5%8C%96">4、结合 fixture 进行参数化</h3> 
<p>pytest 的 fixture 可以用来提供测试所需的共享资源或预置条件。结合参数化，可以动态生成 fixture 数据。</p> 
<pre><code class="language-python">import pytest

@pytest.fixture(params=[1, 2, 3, 4, 5])
def input_value(request):
    return request.param

def test_with_fixture(input_value):
    assert input_value &gt; 0</code></pre> 
<p>在这个例子中，我们定义了一个 fixture input_value，并使用 params 参数对其进行参数化。pytest 会为 fixture 指定的每个参数值生成一个独立的 fixture 实例，并将其注入到使用该 fixture 的测试函数中。因此，test_with_fixture() 函数会被执行五次，每次使用 input_value fixture 提供的一个不同的正整数。</p> 
<h3 id="5%E3%80%81%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0%E7%94%9F%E6%88%90">5、<strong>动态参数生成</strong></h3> 
<p>除了使用静态定义的参数数据集，还可以编写函数或使用生成器来动态生成参数值。这在处理大量数据、随机数据或基于某种规则生成的测试数据时特别有用，以下是一个简单的例子：</p> 
<pre><code class="language-python">import random
import pytest

def generate_random_integers(count=10):
    return [(random.randint(-100, 100), random.randint(-100, 100)) for _ in range(count)]

@pytest.mark.parametrize("x, y", generate_random_integers())
def test_complex_operation(x, y):
    result = complex_operation(x, y)
    assert result.is_valid()  # 假设有一个is_valid()方法来验证结果有效性</code></pre> 
<p>对于需要大量或复杂参数组合的场景，可以使用生成器函数（yield 语句）来动态生成参数。这种方式特别适用于有特定规律或算法生成的参数集：</p> 
<pre><code class="language-python">import pytest
import random

def generate_random_inputs():
    for _ in range(10):
        input = random.randint(1, 10**999)
        expected = input * 2
        yield input, expected

@pytest.mark.parametrize("input, expected", generate_random_inputs())
def test_doubling_function(input, expected):
    assert doubling_function(input) == expected</code></pre> 
<p>在这个例子中，generate_random_inputs 是一个生成器函数，它每次 yield 一对随机的 input 和对应的 expected 值。parametrize 会遍历这些生成的值，为每一对生成一个测试实例。</p> 
<h3 id="6%E3%80%81%E5%8F%82%E6%95%B0%E5%8C%96%E4%B8%8E%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BF%87">6、<strong>参数化与条件跳过</strong></h3> 
<p>可以结合 pytest.mark.skipif 或 pytest.mark.xfail 根据特定条件（如环境变量、版本依赖等）有条件地跳过某些参数组合或标记其为预期失败。</p> 
<pre><code class="language-python">import pytest

@pytest.mark.parametrize("input, expected", ...)
@pytest.mark.skipif(condition, reason="由于缺少依赖项而跳过")
def test_feature(input, expected):
    ...

@pytest.mark.parametrize("input, expected", ...)
@pytest.mark.xfail(condition, reason="由于已知问题导致的预期故障")
def test_flaky_behavior(input, expected):
    ...</code></pre> 
<p>condition是一个布尔值或可以计算出布尔值的表达式，pytest 在执行测试之前会先评估这个条件。当条件为 True 时，即使测试实际通过了，pytest 也会将其报告为预期失败（xfail）。反之，若条件为 False，则测试按照正常流程执行，无论其实际结果是通过还是失败。</p> 
<p>也可以是一个可调用对象（如函数、lambda 表达式等），pytest 会在测试执行前调用它。该可调用对象应不接受任何参数，并返回一个布尔值。返回 True 时，测试被视为预期失败；返回 False 时，测试按正常流程执行。</p> 
<p></p> 
<p><span style="color:#fe2c24;"><strong>希望以上内容能帮助大家理解使用pytest进行参数化操作！</strong></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6c0d2a84b0667f4dd5bdd3fdc96b63fe/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">可以与 FastAPI 不分伯仲的 Python 著名的 Web 框架</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d4a88225168e51e821fe29356a9e2e87/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">03 JavaScript学习：浏览器中执行 JavaScript</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>