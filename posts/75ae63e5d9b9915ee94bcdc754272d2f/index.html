<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言王国——杨氏矩阵 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/75ae63e5d9b9915ee94bcdc754272d2f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C语言王国——杨氏矩阵">
  <meta property="og:description" content="目录
1. 引言
2. 了解杨氏矩阵
3. 思路分析
4. 代码
5. 总结
1. 引言 最近在做二维数组的训练的时候发现了一个很有意思的题：
一看这不是杨氏矩阵嘛，接下来就由姜糖我带大家了解一下这个著名的矩阵。
2. 了解杨氏矩阵 通过查阅百度得知：
杨氏矩阵：
是对组合表示理论和舒伯特演算很有用的工具。它提供了一种方便的方式来描述对称和一般线性群的群表示，并研究它们的性质。有一个二维数组. 数组的每行从左到右是递增的，每列从上到下是递增的. 在这样的数组中查找一个数字是否存在。 时间复杂度小于O(N)。
平常我们在数组里查找数字时，是否我们用的都是暴力遍历查找，一个数一个数的去比对时间复杂度为O(n)，效率很低，这时候就该我们杨氏矩阵出场了。 3. 思路分析 资料中我们知道了杨氏矩阵是一个二维数组，数组的每行从左到右是递增的，每列从上到下是递增的. 在这样的数组中查找一个数字是否存在，所以我们举一个例子：
在arr[3][3] = {{1,2,3},{4,5,6},{7,8,9}}查找数字n。
数组如图：
此数组符合杨氏矩阵。
那接下来我们该怎么查找数字更快捷呢。接下来我们要找此数组里的特殊的数，我们会发现最右上角的那个数是一行之中最大的一列之中最小的所以我们拿n去跟他比较，然后我们就会发现：
红色为查找范围，黄色为除去范围。
根据图中我们发现当n&gt;3时，第一行就被排除了，查找范围只有第二、三行；
当n&lt;3时，第一列就被排除了 ，查找范围只有第二、三列。
然后在接下来的图像中继续取右上角的数字进行比较，排除行和列直达剩下查找的数，若都找不到则数字n不在数组中。
我们将n赋值进行具体分析，为了特殊性，我们就取右上角的对角左下角7吧。
当n=7，如图分析：
这样我们就能找到我们的数字n了。最后我们也发现：在一个杨氏矩阵中查找最特殊的数字7，我们总共进行了5次比较，找到了元素，这样的查找方式明显比遍历二维数组的效率高 。
4. 代码 接下来我就来分享一下我写的代码：
#include&lt;stdio.h&gt; int young(int (*arr)[3], int n) { int i,j = 0; for (i = 0; i &lt; 3; i&#43;&#43;) { for (j = 2; j &gt;= 0; j--) { if (n == arr[i][j]) { return 1; } else if(n &gt; arr[i][j]) { break; } } } return 0; } int main() { int arr[3][3] = { 1,2,3,4,5,6,7,8,9 }; printf(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-01T02:27:57+08:00">
    <meta property="article:modified_time" content="2024-06-01T02:27:57+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言王国——杨氏矩阵</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="1.%20%E5%BC%95%E8%A8%80-toc" style="margin-left:0px;"><a href="#1.%20%E5%BC%95%E8%A8%80" rel="nofollow">1. 引言</a></p> 
<p id="%C2%A02.%20%E4%BA%86%E8%A7%A3%E6%9D%A8%E6%B0%8F%E7%9F%A9%E9%98%B5-toc" style="margin-left:0px;"><a href="#%C2%A02.%20%E4%BA%86%E8%A7%A3%E6%9D%A8%E6%B0%8F%E7%9F%A9%E9%98%B5" rel="nofollow"> 2. 了解杨氏矩阵</a></p> 
<p id="3.%20%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-toc" style="margin-left:0px;"><a href="#3.%20%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90" rel="nofollow">3. 思路分析</a></p> 
<p id="4.%20%E4%BB%A3%E7%A0%81-toc" style="margin-left:0px;"><a href="#4.%20%E4%BB%A3%E7%A0%81" rel="nofollow">4. 代码</a></p> 
<p id="%C2%A05.%20%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%C2%A05.%20%E6%80%BB%E7%BB%93" rel="nofollow"> 5. 总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1.%20%E5%BC%95%E8%A8%80">1. 引言</h2> 
<p>最近在做二维数组的训练的时候发现了一个很有意思的题：</p> 
<p><img alt="" height="133" src="https://images2.imgbox.com/68/78/fiXqn4lq_o.png" width="973"></p> 
<p>一看这不是杨氏矩阵嘛，接下来就由姜糖我带大家了解一下这个著名的矩阵。</p> 
<p></p> 
<h2 id="%C2%A02.%20%E4%BA%86%E8%A7%A3%E6%9D%A8%E6%B0%8F%E7%9F%A9%E9%98%B5"> 2. 了解杨氏矩阵</h2> 
<p>通过查阅百度得知：</p> 
<blockquote> 
 <p>杨氏矩阵：</p> 
 <p>是对组合表示理论和舒伯特演算很有用的工具。它提供了一种方便的方式来描述对称和<a href="https://baike.baidu.com/item/%E4%B8%80%E8%88%AC%E7%BA%BF%E6%80%A7%E7%BE%A4/18899655?fromModule=lemma_inlink" rel="nofollow" title="一般线性群">一般线性群</a>的群表示，并研究它们的性质。<span style="color:#fe2c24;">有一个二维数组. 数组的每行从左到右是递增的，每列从上到下是递增的. 在这样的数组中查找一个数字是否存在。 时间复杂度小于O(N)。</span></p> 
</blockquote> 
<p>平常我们在数组里查找数字时，是否我们用的都是暴力遍历查找，一个数一个数的去比对时间复杂度为O(n)，效率很低，这时候就该我们杨氏矩阵出场了。 </p> 
<hr> 
<h2 id="3.%20%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90">3. 思路分析</h2> 
<p>资料中我们知道了杨氏矩阵是一个二维数组，<span style="color:#0d0016;">数组的每行从左到右是递增的，每列从上到下是递增的. 在这样的数组中查找一个数字是否存在，所以我们举一个例子：</span></p> 
<p><span style="color:#0d0016;">在arr[3][3] = {<!-- -->{1,2,3},{4,5,6},{7,8,9}}查找数字n。</span></p> 
<p><span style="color:#0d0016;">数组如图：</span></p> 
<p><img alt="" height="603" src="https://images2.imgbox.com/35/f6/epPPQPdv_o.png" width="819"></p> 
<p>此数组符合杨氏矩阵。</p> 
<p>那接下来我们该怎么查找数字更快捷呢。接下来我们要找此数组里的特殊的数，我们会发现最右上角的那个数是一行之中最大的一列之中最小的所以我们拿n去跟他比较，然后我们就会发现：</p> 
<p><img alt="" height="637" src="https://images2.imgbox.com/14/81/2xCzlQV9_o.png" width="1102"></p> 
<p><img alt="" height="603" src="https://images2.imgbox.com/fb/26/g6bDIxyS_o.png" width="1069"></p> 
<blockquote> 
 <p>红色为查找范围，黄色为除去范围。</p> 
</blockquote> 
<p>根据图中我们发现当n&gt;3时，第一行就被排除了，查找范围只有第二、三行；</p> 
<p>当n&lt;3时，第一列就被排除了 ，查找范围只有第二、三列。</p> 
<p>然后在接下来的图像中继续取右上角的数字进行比较，排除行和列直达剩下查找的数，若都找不到则数字n不在数组中。</p> 
<hr> 
<p>我们将n赋值进行具体分析，为了特殊性，我们就取右上角的对角左下角7吧。</p> 
<p>当n=7，如图分析：</p> 
<p><img alt="" height="637" src="https://images2.imgbox.com/8f/f4/f40HjWO9_o.png" width="1102"></p> 
<p> <img alt="" height="631" src="https://images2.imgbox.com/5d/5a/K3dL7pgq_o.png" width="1039"></p> 
<p> <img alt="" height="663" src="https://images2.imgbox.com/74/0f/WKMefDbH_o.png" width="966"></p> 
<p> <img alt="" height="664" src="https://images2.imgbox.com/8a/e0/8E3raKsT_o.png" width="1066"></p> 
<p><img alt="" height="298" src="https://images2.imgbox.com/69/52/wgUIXNdu_o.png" width="355"></p> 
<p>这样我们就能找到我们的数字n了。最后我们也发现：在一个杨氏矩阵中查找最特殊的数字7，我们总共进行了5次比较，找到了元素，这样的查找方式明显比遍历二维数组的效率高 。</p> 
<hr> 
<h2 id="4.%20%E4%BB%A3%E7%A0%81">4. 代码</h2> 
<p>接下来我就来分享一下我写的代码：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int young(int (*arr)[3], int n)
{
	int i,j = 0;
	for (i = 0; i &lt; 3; i++)
	{
		for (j = 2; j &gt;= 0; j--)
		{
			if (n == arr[i][j])
			{
				return 1;
			}
			else if(n &gt; arr[i][j])
			{
				break;
			}
		}
	}

	return 0;

}


int main()
{

	int arr[3][3] = { 1,2,3,4,5,6,7,8,9 };
	printf("输入你要查找的数字：");
	int n = 0;
	scanf("%d", &amp;n);
	int ret = young(arr, n);
	if (n)
	{
		printf("找到了");
	}
	else
		printf("找不到");

	return 0;
</code></pre> 
<p>但是我们发现这样子的代码只能判断是否找到数字，不能判断数字的位置，所以我给代码进行了优化：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int young(int(*arr)[3], int* px, int* py, int n)
{
	int y = *py;
	int x = *px-1;
	for (*py = 0; *py &lt; y; (*py)++)
	{
		for (*px = x; (*px) &gt;= 0; (*px)--)
		{
			if (n == arr[(*py)][(*px)])
			{
				return 1;
			}
			else if (n &gt; arr[*py][*px])
			{
				break;
			}
		}
	}

	return 0;
}


int main()
{

	int arr[3][3] = { 1,2,3,4,5,6,7,8,9 };
	printf("输入你要查找的数字：");
	int n = 0;
	scanf("%d", &amp;n);
	int i = 3;
	int j = 3;
	int ret = young(arr, &amp;i , &amp;j , n);
	if (n)
	{
		printf("找到了为arr[%d][%d]",j,i);
	}
	else
		printf("找不到");

	return 0;
}</code></pre> 
<p>像这样子我们把数组行和列用指针的形式传到函数里去，随着函数的变化去变化最后就能得到数组中我们要查找的n的位置。 </p> 
<p>最后我们发现用while循环思路会更清晰准确：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
int find_num(int arr[3][3], int* px, int* py, int k)
{
	int x = 0;
	int y = *py - 1;
	while (x &lt; *px &amp;&amp; y &gt;= 0)
	{
		//向下查找
		if (k &gt; arr[x][y])
		{
			x++;
		}
		//向左查找
		else if (k &lt; arr[x][y])
		{
			y--;
		}
		//找到了
		else
		{
			*px = x;
			*py = y;
			return 1;
		}
	}
	return 0;
}
int main()
{
	int arr[3][3] = { 1,2,3,4,5,6,7,8,9 };
	int k = 0;
	scanf("%d", &amp;k);
	int x = 3;
	int y = 3;
	int ret = find_num(arr, &amp;x, &amp;y, k);
	if (ret == 1)
	{
		printf("找到了，下标是%d %d\n", x, y);
	}
	else
	{
		printf("找不到\n");
	}

	return 0;
}</code></pre> 
<h2 id="%C2%A05.%20%E6%80%BB%E7%BB%93"> 5. 总结</h2> 
<p>如果大家有不同见解也可以私信姜糖哦，姜糖也在不停的学习进步，与大家一起步入大牛之列。期待大家三连！！</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9f3a33fb4b5d2700be7a927af7078d15/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">算法（十三）回溯算法---N皇后问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/026057840ed216f68a1a68b16c42ef5a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Golang | Leetcode Golang题解之第123题买卖股票的最佳时机III</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>