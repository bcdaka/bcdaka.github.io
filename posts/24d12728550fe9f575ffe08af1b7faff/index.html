<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>基于python的百度资讯爬虫的设计与实现 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/24d12728550fe9f575ffe08af1b7faff/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="基于python的百度资讯爬虫的设计与实现">
  <meta property="og:description" content="研究背景
随着互联网和信息技术的飞速发展，网络已经成为人们获取信息的主要来源之一。特别是搜索引擎，作为信息检索的核心工具，极大地改变了人们获取信息的方式。其中，百度作为中国最受欢迎的搜索引擎之一，其新闻搜索功能为用户提供了丰富的实时信息。本文研究背景围绕利用爬虫技术从百度新闻中提取有价值的信息展开。
1. 网络爬虫的应用与重要性
网络爬虫（Web Crawler）是通过程序自动地从互联网上获取信息的技术。它广泛应用于搜索引擎的数据抓取、内容聚合、舆情监控、市场调研等领域。通过网络爬虫，可以快速、大规模地获取结构化和非结构化的数据，为数据分析和信息挖掘提供基础支持。
2. 百度新闻作为信息源的优势
百度新闻是百度搜索引擎的重要组成部分，它汇集了海量的新闻资源，涵盖了全球各地的实时新闻动态。由于其信息量大、更新速度快、内容覆盖广，百度新闻成为研究实时信息、公共舆情和新闻热点的宝贵数据源。
3. 爬取百度新闻的技术挑战
尽管百度新闻提供了丰富的信息，但直接从网页中提取数据存在一定的技术挑战。首先，百度新闻页面结构复杂，不同类型的新闻内容在HTML中呈现的方式各不相同。其次，百度会通过设置反爬机制（如频繁请求检测、验证码等）来防止恶意爬虫，这要求爬虫程序具备一定的随机性和智能性，以模拟真实用户的访问行为。
4. 研究目的与意义
本研究的目的在于设计并实现一个有效的网络爬虫，从百度新闻中自动提取相关的新闻标题、链接、内容摘要和来源信息。这不仅为研究人员提供了一种获取大规模新闻数据的有效手段，也为进一步的数据分析和挖掘提供了基础。例如，通过分析不同时间段的新闻热点，可以了解社会关注的焦点问题；通过舆情监控，可以及时捕捉并应对公共舆论的变化。
5. 方法概述
在具体实现上，本文采用Python语言编写爬虫程序，利用urllib.request模块发起HTTP请求，模拟浏览器访问百度新闻搜索页面。通过设置合适的请求头，避免被识别为爬虫。然后使用BeautifulSoup库解析HTML内容，提取所需的新闻信息。为了避免触发百度的反爬机制，程序在每次请求之间随机等待一段时间，以模拟正常用户的访问行为。
6. 预期成果
通过本研究，希望能够实现以下成果：
设计并实现一个能够高效稳定运行的百度新闻爬虫程序。
从百度新闻中自动提取大量有价值的新闻数据。
为后续的新闻数据分析和研究提供可靠的数据来源。
综上所述，利用网络爬虫从百度新闻中提取信息，不仅是对网络爬虫技术的应用和实践，更是为大数据时代的信息获取和分析提供了一种行之有效的方法。希望本研究能够在网络爬虫技术和数据挖掘应用方面有所贡献。
数据挖掘技术基础
查询网页源代码、获取User-Agent、获得请求网址的状态码以及从网页源代码中获取RequestURL，都是进行网页分析和抓取的重要步骤。以下是详细的步骤和方法：
1. 查询网页源代码
使用浏览器的开发者工具：
打开浏览器（例如Google Chrome）。
导航到你想查看源代码的网页。
右键点击页面，然后选择“检查”（Inspect）。
在弹出的开发者工具窗口中，选择“Elements”标签。这里可以看到网页的HTML源代码。如下图所示：
使用Python爬虫：
可以使用urllib.request和BeautifulSoup库来获取网页的源代码。
request = urllib.request.Request(url&#43;str(i*10),headers=headers)
response = urllib.request.urlopen(request)
res=response.read().decode(&#39;utf-8&#39;)
print(res)
运行后结果如下图：
2. 获取User-Agent
使用浏览器的开发者工具：
打开开发者工具（同样使用“检查”选项）。
转到“Network”标签。
刷新页面。
在请求列表中选择任意一个请求。
在“Headers”选项中，可以找到该请求的User-Agent信息。如下图
也可以使用Python获取User-Agent：
import requests
response = requests.get(&#39;https://www.baidu.com/&#39;)
user_agent = response.request.headers[&#39;User-Agent&#39;]
print(user_agent)
3.获得请求网址的状态码
获取响应码，可以使用 response.getcode() 方法。代码如下：
request = urllib.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-17T23:29:09+08:00">
    <meta property="article:modified_time" content="2024-07-17T23:29:09+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">基于python的百度资讯爬虫的设计与实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:.0001pt;text-align:justify;"><strong><strong>研究背景</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">随着互联网和信息技术的飞速发展，网络已经成为人们获取信息的主要来源之一。特别是搜索引擎，作为信息检索的核心工具，极大地改变了人们获取信息的方式。其中，百度作为中国最受欢迎的搜索引擎之一，其新闻搜索功能为用户提供了丰富的实时信息。本文研究背景围绕利用爬虫技术从百度新闻中提取有价值的信息展开。</p> 
<p style="margin-left:.0001pt;text-align:justify;">1. 网络爬虫的应用与重要性</p> 
<p style="margin-left:.0001pt;text-align:justify;">网络爬虫（Web Crawler）是通过程序自动地从互联网上获取信息的技术。它广泛应用于搜索引擎的数据抓取、内容聚合、舆情监控、市场调研等领域。通过网络爬虫，可以快速、大规模地获取结构化和非结构化的数据，为数据分析和信息挖掘提供基础支持。</p> 
<p style="margin-left:.0001pt;text-align:justify;">2. 百度新闻作为信息源的优势</p> 
<p style="margin-left:.0001pt;text-align:justify;">百度新闻是百度搜索引擎的重要组成部分，它汇集了海量的新闻资源，涵盖了全球各地的实时新闻动态。由于其信息量大、更新速度快、内容覆盖广，百度新闻成为研究实时信息、公共舆情和新闻热点的宝贵数据源。</p> 
<p style="margin-left:.0001pt;text-align:justify;">3. 爬取百度新闻的技术挑战</p> 
<p style="margin-left:.0001pt;text-align:justify;">尽管百度新闻提供了丰富的信息，但直接从网页中提取数据存在一定的技术挑战。首先，百度新闻页面结构复杂，不同类型的新闻内容在HTML中呈现的方式各不相同。其次，百度会通过设置反爬机制（如频繁请求检测、验证码等）来防止恶意爬虫，这要求爬虫程序具备一定的随机性和智能性，以模拟真实用户的访问行为。</p> 
<p style="margin-left:.0001pt;text-align:justify;">4. 研究目的与意义</p> 
<p style="margin-left:.0001pt;text-align:justify;">本研究的目的在于设计并实现一个有效的网络爬虫，从百度新闻中自动提取相关的新闻标题、链接、内容摘要和来源信息。这不仅为研究人员提供了一种获取大规模新闻数据的有效手段，也为进一步的数据分析和挖掘提供了基础。例如，通过分析不同时间段的新闻热点，可以了解社会关注的焦点问题；通过舆情监控，可以及时捕捉并应对公共舆论的变化。</p> 
<p style="margin-left:.0001pt;text-align:justify;">5. 方法概述</p> 
<p style="margin-left:.0001pt;text-align:justify;">在具体实现上，本文采用Python语言编写爬虫程序，利用urllib.request模块发起HTTP请求，模拟浏览器访问百度新闻搜索页面。通过设置合适的请求头，避免被识别为爬虫。然后使用BeautifulSoup库解析HTML内容，提取所需的新闻信息。为了避免触发百度的反爬机制，程序在每次请求之间随机等待一段时间，以模拟正常用户的访问行为。</p> 
<p style="margin-left:.0001pt;text-align:justify;">6. 预期成果</p> 
<p style="margin-left:.0001pt;text-align:justify;">通过本研究，希望能够实现以下成果：</p> 
<p style="margin-left:.0001pt;text-align:justify;">设计并实现一个能够高效稳定运行的百度新闻爬虫程序。</p> 
<p style="margin-left:.0001pt;text-align:justify;">从百度新闻中自动提取大量有价值的新闻数据。</p> 
<p style="margin-left:.0001pt;text-align:justify;">为后续的新闻数据分析和研究提供可靠的数据来源。</p> 
<p style="margin-left:.0001pt;text-align:justify;">综上所述，利用网络爬虫从百度新闻中提取信息，不仅是对网络爬虫技术的应用和实践，更是为大数据时代的信息获取和分析提供了一种行之有效的方法。希望本研究能够在网络爬虫技术和数据挖掘应用方面有所贡献。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>数据挖掘技术基础</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">查询网页源代码、获取User-Agent、获得请求网址的状态码以及从网页源代码中获取RequestURL，都是进行网页分析和抓取的重要步骤。以下是详细的步骤和方法：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>1. 查询网页源代码</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">使用浏览器的开发者工具：</p> 
<p style="margin-left:.0001pt;text-align:justify;">打开浏览器（例如Google Chrome）。</p> 
<p style="margin-left:.0001pt;text-align:justify;">导航到你想查看源代码的网页。</p> 
<p style="margin-left:.0001pt;text-align:justify;">右键点击页面，然后选择“检查”（Inspect）。</p> 
<p style="margin-left:.0001pt;text-align:justify;">在弹出的开发者工具窗口中，选择“Elements”标签。这里可以看到网页的HTML源代码。如下图所示：</p> 
<p><img alt="" height="277" src="https://images2.imgbox.com/6f/f7/lUj8N8Mt_o.png" width="553"></p> 
<p style="margin-left:.0001pt;text-align:justify;">使用Python爬虫：</p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">可以使用<span style="background-color:#ffffff;"><span style="color:#000000;">urllib.request</span></span>和BeautifulSoup库来获取网页的源代码。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#000000;">request = urllib.request.Request(url+</span></span><span style="background-color:#ffffff;"><span style="color:#000080;">str</span></span><span style="background-color:#ffffff;"><span style="color:#000000;">(i*</span></span><span style="background-color:#ffffff;"><span style="color:#0000ff;">10</span></span><span style="background-color:#ffffff;"><span style="color:#000000;">),</span></span><span style="background-color:#ffffff;"><span style="color:#660099;">headers</span></span><span style="background-color:#ffffff;"><span style="color:#000000;">=headers)</span></span><br><span style="background-color:#ffffff;"><span style="color:#000000;">response = urllib.request.urlopen(request)</span></span><br><span style="background-color:#ffffff;"><span style="color:#000000;">res=response.read().decode(</span></span><strong><span style="background-color:#ffffff;"><span style="color:#008080;"><strong>'utf-8'</strong></span></span></strong><span style="background-color:#ffffff;"><span style="color:#000000;">)</span></span><br><span style="background-color:#ffffff;"><span style="color:#000080;">print</span></span><span style="background-color:#ffffff;"><span style="color:#000000;">(res)</span></span></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">运行后结果如下图：</span></p> 
<p><img alt="" height="253" src="https://images2.imgbox.com/63/93/aKl7fl85_o.png" width="517"></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong>2. 获取User-Agent</strong></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">使用浏览器的开发者工具：</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">打开开发者工具（同样使用“检查”选项）。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">转到“Network”标签。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">刷新页面。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">在请求列表中选择任意一个请求。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">在“Headers”选项中，可以找到该请求的User-Agent信息。如下图</span></p> 
<p><img alt="" height="277" src="https://images2.imgbox.com/e4/03/M0agIoGn_o.png" width="553"></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">也可以使用Python获取User-Agent：</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">import requests</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">response = requests.get('https://www.baidu.com/')</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">user_agent = response.request.headers['User-Agent']</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">print(user_agent)</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong>3.</strong></strong><strong><strong>获得请求网址的状态码</strong></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">获取响应码，可以使用 response.getcode() 方法。代码如下：</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#000000;">request = urllib.request.Request(url+</span></span><span style="background-color:#ffffff;"><span style="color:#000080;">str</span></span><span style="background-color:#ffffff;"><span style="color:#000000;">(i*</span></span><span style="background-color:#ffffff;"><span style="color:#0000ff;">10</span></span><span style="background-color:#ffffff;"><span style="color:#000000;">),</span></span><span style="background-color:#ffffff;"><span style="color:#660099;">headers</span></span><span style="background-color:#ffffff;"><span style="color:#000000;">=headers)</span></span><br><span style="background-color:#ffffff;"><span style="color:#000000;">response = urllib.request.urlopen(request)</span></span><br><span style="background-color:#ffffff;"><span style="color:#000000;">status_code = response.getcode()</span></span><br><span style="background-color:#ffffff;"><span style="color:#000080;">print</span></span><span style="background-color:#ffffff;"><span style="color:#000000;">(</span></span><strong><span style="background-color:#ffffff;"><span style="color:#008080;"><strong>f"Response code for request </strong></span></span></strong><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>{<!-- --></strong></span></span></strong><span style="background-color:#ffffff;"><span style="color:#000000;">i</span></span><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>}</strong></span></span></strong><strong><span style="background-color:#ffffff;"><span style="color:#008080;"><strong>: </strong></span></span></strong><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>{<!-- --></strong></span></span></strong><span style="background-color:#ffffff;"><span style="color:#000000;">status_code</span></span><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>}</strong></span></span></strong><strong><span style="background-color:#ffffff;"><span style="color:#008080;"><strong>"</strong></span></span></strong><span style="background-color:#ffffff;"><span style="color:#000000;">)</span></span><br><span style="background-color:#ffffff;"><span style="color:#000000;">运行结果如下图：</span></span></span></p> 
<p><img alt="" height="134" src="https://images2.imgbox.com/08/ef/A30atX1t_o.png" width="554"></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong>4. 从网页源代码中获取RequestURL</strong></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">需要从HTML源代码中提取某个特定的URL，比如从&lt;a&gt;标签或&lt;img&gt;标签中提取链接地址，可以使用BeautifulSoup。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">使用Python的BeautifulSoup库的代码：</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#000000;">soup=BeautifulSoup(res,</span></span><strong><span style="background-color:#ffffff;"><span style="color:#008080;"><strong>'lxml'</strong></span></span></strong><span style="background-color:#ffffff;"><span style="color:#000000;">)</span></span><br><span style="background-color:#ffffff;"><span style="color:#000000;">dw = soup.find_all(</span></span><strong><span style="background-color:#ffffff;"><span style="color:#008080;"><strong>'div'</strong></span></span></strong><span style="background-color:#ffffff;"><span style="color:#000000;">, </span></span><span style="background-color:#ffffff;"><span style="color:#660099;">class_</span></span><span style="background-color:#ffffff;"><span style="color:#000000;">=</span></span><strong><span style="background-color:#ffffff;"><span style="color:#008080;"><strong>'result-op c-container xpath-log new-pmd'</strong></span></span></strong><span style="background-color:#ffffff;"><span style="color:#000000;">)</span></span><br><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>for </strong></span></span></strong><span style="background-color:#ffffff;"><span style="color:#000000;">n </span></span><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>in </strong></span></span></strong><span style="background-color:#ffffff;"><span style="color:#000000;">dw:</span></span><br><span style="background-color:#ffffff;"><span style="color:#000000;">    url0=n.find(</span></span><strong><span style="background-color:#ffffff;"><span style="color:#008080;"><strong>'a'</strong></span></span></strong><span style="background-color:#ffffff;"><span style="color:#000000;">,</span></span><span style="background-color:#ffffff;"><span style="color:#660099;">class_</span></span><span style="background-color:#ffffff;"><span style="color:#000000;">=</span></span><strong><span style="background-color:#ffffff;"><span style="color:#008080;"><strong>'news-title-font_1xS-F'</strong></span></span></strong><span style="background-color:#ffffff;"><span style="color:#000000;">).get(</span></span><strong><span style="background-color:#ffffff;"><span style="color:#008080;"><strong>'href'</strong></span></span></strong><span style="background-color:#ffffff;"><span style="color:#000000;">)</span></span></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">运行后如下图：</span></p> 
<p><img alt="" height="205" src="https://images2.imgbox.com/9f/d3/3vrLSlB4_o.png" width="554"></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong>5</strong></strong><strong><strong>.</strong></strong><strong><strong>判断是Get请求还是Post请求</strong></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">要判断是GET请求还是POST请求，可以从以下几个方面入手：</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong>HTTP方法：</strong></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">GET请求：数据通过URL参数传递，使用查询字符串（query string）。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">POST请求：数据通过请求主体（body）传递，通常不会显示在URL中。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong>数据位置：</strong></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">GET请求：数据附加在URL后，以问号 ? 开始，多个参数用 &amp; 分隔。例如：http://example.com/page?param1=value1¶m2=value2</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">POST请求：数据放在请求体中，不会出现在URL里。例如：在表单提交时，数据以键值对形式发送。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong>使用场景：</strong></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">GET请求：一般用于请求数据，且不会对服务器上的资源产生副作用（例如：查询操作）。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">POST请求：一般用于提交数据，可能会对服务器上的资源产生副作用（例如：提交表单，上传文件）。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong>安全性：</strong></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">GET请求：因为数据在URL中明文显示，不适合传输敏感数据。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">POST请求：数据在请求体中，虽然更安全，但仍需使用HTTPS确保数据传输安全。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong>示例</strong></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong>GET请求的特征：</strong></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">URL包含查询字符串。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">请求头中的HTTP方法为GET。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">常用于检索数据而不改变服务器状态。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong>示例代码：</strong></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">GET /search?q=example HTTP/1.1</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">Host: <a href="http://www.example.com" rel="nofollow" title="www.example.com">www.example.com</a></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">浏览器访问http://www.example.com/search?q=example时会发出这样的请求。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong>POST请求的特征：</strong></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">数据在请求体中。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">请求头中的HTTP方法为POST。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">常用于提交数据，导致服务器状态改变。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong>示例代码：</strong></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">POST /submit-form HTTP/1.1</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">Host: www.example.com</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">Content-Type: application/x-www-form-urlencoded</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">Content-Length: 27</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">name=JohnDoe&amp;age=25</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">在HTML表单提交时，使用POST方法，表单数据被编码并放在请求体中发送到服务器。GET请求主要用于数据检索，数据通过URL传递；POST请求主要用于提交数据，数据通过请求体传递。选择使用哪种请求方式取决于具体的应用场景和数据传输的需求。请求头查询get请求或者post请求如下图</span></p> 
<p><img alt="" height="277" src="https://images2.imgbox.com/56/d3/cSd9NwMu_o.png" width="553"></p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong>数据挖掘的网页信息获取</strong></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">这个程序的目的是通过发送HTTP请求，获取百度资讯页面的内容，并解析页面中的特定数据项（如文章标题、内容、来源等）。下面详细描述如何从网页源代码中获取数据，并展示代码中每个数据项在网页源代码中的位置。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">数据项在源代码中的位置如下图：</span></p> 
<p><img alt="" height="277" src="https://images2.imgbox.com/b7/df/H3tSgvM2_o.png" width="553"></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong>1. 发送请求</strong></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">程序使用urllib.request库发送HTTP GET请求到指定URL，并获取响应。具体步骤如下：</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">构建请求对象：首先，程序构建一个包含URL和头部信息的请求对象。头部信息通常包括User-Agent和Cookie，以模拟真实的浏览器请求，防止被服务器识别为机器人并拒绝访问。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">request = urllib.request.Request(url + str(i * 10), headers=headers)</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">发送请求：通过urllib.request.urlopen函数发送请求，并接收服务器的响应。响应包括状态码和响应体内容。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">response = urllib.request.urlopen(request)</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">检查响应状态：程序获取响应的状态码，以确保请求成功。状态码200表示成功。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">status_code = response.getcode()</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">print(f"Response code for request {i}: {status_code}")</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">读取响应内容：程序将响应体读取为字符串形式，以便后续解析。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">res = response.read().decode('utf-8')</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">2. 解析响应</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">程序使用BeautifulSoup库解析响应的HTML内容，并提取所需的数据项。具体步骤如下：</span></p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">创建BeautifulSoup对象：通过将HTML字符串传递给BeautifulSoup构造函数，并指定解析器（如lxml），程序创建一个BeautifulSoup对象。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">soup = BeautifulSoup(res, 'lxml')</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">查找目标内容：使用find_all方法查找所有包含新闻结果的div标签，这些标签具有特定的类名result-op c-container xpath-log new-pmd。find_all方法返回一个包含所有匹配元素的列表。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">dw = soup.find_all('div', class_='result-op c-container xpath-log new-pmd')</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">对应的网页位置如下图：</span></p> 
<p><img alt="" height="248" src="https://images2.imgbox.com/ff/73/LzIm3QaI_o.png" width="811"></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">3. 提取数据</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">程序从HTML中提取特定的div、a、span等标签中的内容。具体步骤如下：</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">遍历新闻结果：程序遍历包含新闻结果的div列表，逐个提取每个新闻项的详细信息。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">for n in dw:</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">提取新闻链接：通过查找包含新闻标题的a标签，并获取其href属性值，提取新闻链接。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">url0 = n.find('a', class_='news-title-font_1xS-F').get('href')</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">对应的网页位置如下图：</span></p> 
<p><img alt="" height="168" src="https://images2.imgbox.com/99/fb/wOi0ma4Q_o.png" width="638"></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">提取新闻标题：通过查找包含新闻标题的a标签，并获取其aria-label属性值，提取新闻标题。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">title = n.find('a', class_='news-title-font_1xS-F').get('aria-label')</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">对应的网页位置如下图：</span></p> 
<p><img alt="" height="235" src="https://images2.imgbox.com/71/da/PwRd1MrP_o.png" width="746"></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">提取新闻内容：通过查找包含新闻内容的span标签，并获取其文本内容，提取新闻内容。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">neirong = n.find('span', class_='c-font-normal c-color-text').text</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">对应的网页位置如下图：</span></p> 
<p><img alt="" height="171" src="https://images2.imgbox.com/40/90/vbt9zJRh_o.png" width="635"></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">提取新闻来源：通过查找包含新闻来源的span标签，并获取其文本内容，提取新闻来源。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">laiyuan = n.find('span', class_='c-color-gray').text</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">对应的网页位置如下图：</span></p> 
<p><img alt="" height="203" src="https://images2.imgbox.com/72/7d/bXIGvBgF_o.png" width="702"></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">打印结果：程序将提取到的新闻链接、标题、内容和来源打印输出。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">print(url0, title, neirong, laiyuan)</span></p> 
<p><img alt="" height="364" src="https://images2.imgbox.com/b9/04/VYY0ODVv_o.png" width="633"></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong>总结</strong></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">通过上述详细步骤，程序实现了从指定网页获取数据的全过程。首先，程序通过urllib.request库发送HTTP GET请求获取网页内容。然后，使用BeautifulSoup库解析响应的HTML内容，并通过查找特定的标签和类名提取目标数据项。最后，程序将提取到的数据打印输出。通过这种方式，程序能够有效地从网页源代码中抓取所需的资讯信息。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong>数据挖掘所用到Python模块的特点及功能</strong></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong>urllib.request — 为打开url提供的可扩展类库</strong></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">urllib.request模块定义了方法和类,帮助打开url(主要是HTTP)在一个复杂的世界——基本和摘要式身份验证,重定向,cookies等等。</span></p> 
<p><img alt="" height="280" src="https://images2.imgbox.com/b9/2a/wOV8EZW8_o.png" width="549"></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">————-urllib.request模块定义了以下功能：—————–</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">urllib.request.urlopen()</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">urllib.request.urlopen(url, data=None, [timeout, ]*, cafile=None, capath=None, cadefault=False, context=None)</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">打开网址URL,这可以是一个字符串或一个 Request对象。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">数据必须是一个字节对象指定额外的数据发送到服务器或 None。如果没有这样的数据是必要的，数据也可能是一个iterable对象而且在这种情况下必须在最开始时指定内容的长度。目前HTTP是唯一一个这样请求数据的，当数据参数被提供时，HTTP请求将会执行POST请求而不是GET请求。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">数据应该是一个缓冲的在标准应用程序中以 x-www-form-urlencoded的格式。 urllib.parse.urlencode()函数接受一个映射或序列集合,并返回一个ASCII文本字符串的格式。它应该在被用作数据参数之前，被编码为字节。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">urllib.request 模块 使用 HTTP/1.1协议，并且包括请求 Connection:close在HTTP请求头。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">可选的第二个超时参数timeout，用于阻塞操作,比如连接请求(如果未指定,全球将使用默认超时设置)。这实际上只适用于HTTP、HTTPS和FTP连接。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">如果context被指定，它必须是一个 ssl.SSLContext实例描述各种SSL选项。点击HTTPSConnection查看更多细节。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">可选cafile和capath参数指定一组被HTTPS请求信任的CA证书。cafile应该指向一个文件包含CA证书的包,而capath应该指向一个散列的证书文件的目录。点击ssl.SSLContext.load_verify_locations()查看更多的信息。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">cadefault参数被忽略。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">这个函数始终返回一个对象，像context（上下文） 管理者并提供这些方法</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">geturl()——返回URL的资源检索,常常重定向之后使用</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">info()——返回页面的元信息,如标题，组成 email.message_from_string(的)实例</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">getcode()——返回响应的HTTP状态代码。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">为HTTP和HTTPS url，这个函数返回的一个 http.client.HTTPResponse对象略有不同。除了上面的三种新方法中，这个message属性包含相同的信息像reason属性——由服务器返回的原因——而不是响应头,因为它在文档中指定 HTTPResponse。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">FTP、文件和数据请求url和显式地处理 URLopener和 FancyURLopener类，这个函数返回一个 urllib.response.addinfourl对象。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">urllib.request.urlopen()会在 URLError中抛出协议错误。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">urllib.request.install_opener(opener)</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">安装一个 OpenerDirector实例作为全球默认的opener 。安装一个opener 必要的,如果你想让urlopen使用这个opener ;否则,简单地调用 OpenerDirector.open()而不是 urlopen()。这样代码不会检查一个真实的 OpenerDirector并且任何类的适当的接口都可以运作。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">urllib.request.build_opener([handler, …])</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">返回一个顺序的链的处理程序 OpenerDirector的实例。处理程序可以是BaseHandler的实例,或者 BaseHandler的子类(在这种情况下,必须调用没有参数的构造函数)。下面这些类的实例将提前处理程序,除非处理程序包含它们，或者它们子类的实例：ProxyHandler(如果检测到代理设置), UnknownHandler, HTTPHandler, HTTPDefaultErrorHandler, HTTPRedirectHandler, FTPHandler, FileHandler, HTTPErrorProcessor.</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">如果Python安装SSL支持(即如果 ssl模块可以被导入)， HTTPSHandler也将被添加。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">一个 BaseHandler子类也可以通过改变它的 handler_order属性来修改它再处理程序列表中的位置。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">urllib.request.pathname2url(path)</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">将路径名转换成路径，从本地语法形式的路径中使用一个URL的路径组成部分。这不会产生一个完整的URL。它将返回引用 quote()函数的值。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">urllib.request.url2pathname(path)</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">将路径组件转换为本地路径的语法。这个不接受一个完整的URL。这个函数使用 unquote()解码的通路。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">urllib.request.getproxies()</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">这个helper函数返回一个日程表dictionary 去代理服务器的URL映射。扫描指定的环境变量 _proxy大小写不敏感的方法,对所有的操作系统，当它不能找到它，从Mac OS X的Mac OSX系统配置和Windows系统注册表中寻找代理信息。如果两个大写和小写环境变量存在(或不一样)，小写优先。总的来说，特点及功能：</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">HTTP请求：该模块提供了发送HTTP请求（如GET和POST）的功能。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">处理响应：能够处理HTTP响应，包括获取响应状态码和读取响应内容。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">Header管理：允许设置请求头部信息（如User-Agent和Cookie），以模拟浏览器行为。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">在代码中的作用：</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">构建请求对象：通过urllib.request.Request构建包含URL和头部信息的请求对象。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">发送请求：使用urllib.request.urlopen发送请求并接收服务器响应。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">获取响应内容：读取响应体内容并进行解码，以便后续解析。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong>BeautifulSoup </strong></strong><strong><strong>模块</strong></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">简单来说，BeautifulSoup 就是 Python 的一个 HTML 或 XML 的解析库，我们可以用它来方便地从网页中提取数据，官方的解释如下：</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">BeautifulSoup 提供一些简单的、python 式的函数用来处理导航、搜索、修改分析树等功能。它是一个工具箱，通过解析文档为用户提供需要抓取的数据，因为简单，所以不需要多少代码就可以写出一个完整的应用程序。BeautifulSoup 自动将输入文档转换为 Unicode 编码，输出文档转换为 utf-8 编码。你不需要考虑编码方式，除非文档没有指定一个编码方式，这时你仅仅需要说明一下原始编码方式就可以了。BeautifulSoup 已成为和 lxml、html6lib 一样出色的 python 解释器，为用户灵活地提供不同的解析策略或强劲的速度。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">总的来说，利用它我们可以省去很多繁琐的提取工作，提高解析效率。特点及功能：</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">HTML解析：提供了强大的HTML和XML解析功能，可以处理不规则的HTML文档。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">元素查找：支持通过标签名、类名、ID等方式查找元素。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">导航树结构：通过导航文档树结构，可以方便地提取所需的数据。如下图：</span></p> 
<p><img alt="" height="240" src="https://images2.imgbox.com/bc/2e/A6fHcmmw_o.png" width="513"></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">在代码中的作用：</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">创建解析对象：通过BeautifulSoup构造函数创建解析对象。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">查找元素：使用find_all方法查找特定类名的div标签，获取新闻结果。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">提取数据：通过标签和类名提取新闻链接、标题、内容和来源。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong>Time模块</strong></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">time 模块提供各种时间相关的功能</span></p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">在 Python 中，与时间处理有关的模块包括：time，datetime 以及 calendar</span></p> 
<p><img alt="" height="297" src="https://images2.imgbox.com/90/9b/ZOhsY8lw_o.png" width="466"></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">必要说明：</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">虽然这个模块总是可用，但并非所有的功能都适用于各个平台。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">该模块中定义的大部分函数是调用 C 平台上的同名函数实现，所以各个平台上实现可能略有不同。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">一些术语和约定的解释：</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">时间戳（timestamp）的方式：通常来说，时间戳表示的是从 1970 年 1 月 1 日 00:00:00 开始按秒计算的偏移量（time.gmtime(0)）此模块中的函数无法处理 1970 纪元年以前的日期和时间或太遥远的未来（处理极限取决于 C 函数库，对于 32 位系统来说，是 2038 年）</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">UTC（Coordinated Universal Time，世界协调时）也叫格林威治天文时间，是世界标准时间。在中国为 UTC+8</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">DST（Daylight Saving Time）即夏令时的意思</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">一些实时函数的计算精度可能低于它们建议的值或参数，例如在大部分 Unix 系统，时钟一秒钟“滴答”50~100 次。总的来说，特点及功能：</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">时间管理：提供了各种与时间相关的功能，如获取当前时间、暂停执行、时间格式化等。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">在代码中的作用：</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">暂停执行：使用time.sleep在循环中暂停几秒，以避免频繁请求触发服务器的反爬虫机制。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong>Random模块</strong></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">特点及功能：</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">随机数生成：提供生成随机数的功能，可以生成随机整数、浮点数、随机选择等。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">在代码中的作用：</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">生成随机延迟时间：使用random.randint生成随机整数，以确定暂停执行的时间间隔。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong>数据挖掘程序的编写</strong></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong>完整代码如下：</strong></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>import time</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>import random</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>import urllib.request</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>from bs4 import BeautifulSoup</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong># 定义爬取的网址和请求头</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>url='https://www.baidu.com/s?rtt=1&amp;bsst=1&amp;cl=2&amp;tn=news&amp;ie=utf-8&amp;word=%E7%99%BE%E5%BA%A6%E8%B5%84%E8%AE%AF&amp;x_bfe_rqs=03E80&amp;x_bfe_tjscore=0.100000&amp;tngroupname=organic_news&amp;newVideo=12&amp;goods_entry_switch=1&amp;rsv_dl=news_b_pn&amp;pn='</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>headers={'User-Agent':'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36',</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>         'Cookie':'BIDUPSID=CA010A6B85040D048E120E50A51814A1; PSTM=1702542106; BAIDUID=CA010A6B85040D04A1D9EF39307C5A78:FG=1; BD_UPN=12314753; BDUSS=1Ec35aUWJiYjZkWTBydDRLZ21NUlB1ci01dXJ6NX5kQW9yTThRRTMzQ1RXQ2RtRVFBQUFBJCQAAAAAABAAAAEAAACwlCn7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJPL~2WTy~9lck; BDUSS_BFESS=1Ec35aUWJiYjZkWTBydDRLZ21NUlB1ci01dXJ6NX5kQW9yTThRRTMzQ1RXQ2RtRVFBQUFBJCQAAAAAABAAAAEAAACwlCn7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJPL~2WTy~9lck; BDORZ=FFFB88E999055A3F8A630C64834BD6D0; H_WISE_SIDS_BFESS=40303_40080_60140_60175; H_WISE_SIDS=40303_60175_60270_60289; H_PS_PSSID=60175_60270_60289_60296; BA_HECTOR=2ka10lag0k2l8h2kak05a0akc6c5221j4bhb11v; BAIDUID_BFESS=CA010A6B85040D04A1D9EF39307C5A78:FG=1; COOKIE_SESSION=2175793_0_4_0_12_6_1_2_4_2_0_2_2175949_0_158_0_1715848702_0_1715848544%7C9%230_0_1715848544%7C1; baikeVisitId=16491678-4d53-42a6-8473-07967a7d14b6; B64_BOT=1; BDRCVFR[C0p6oIjvx-c]=mk3SLVN4HKm; delPer=0; BD_CK_SAM=1; PSINO=1; BDRCVFR[K6RW1DeE3Dm]=mk3SLVN4HKm; sugstore=1; H_PS_645EC=ebabAVGfQoSOZqxgpnv4ZZuoXP9fJRqM5LurBezXuyAO7aiEtOJHLP67gRg4NQhBGHje%2Bg; BDSVRTM=0',</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>         }</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong># 循环发起请求，这里只执行一次</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>for i in range(0,1):</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>    # 构建请求对象，添加请求头</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>    request = urllib.request.Request(url+str(i*10),headers=headers)</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>    # 发起请求并获取响应</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>    response = urllib.request.urlopen(request)</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>    # 获取HTTP响应状态码</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>    status_code = response.getcode()</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>    # 打印响应状态码</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>    print(f"Response code for request {i}: {status_code}")</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>    # 读取响应内容并解码</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>    res=response.read().decode('utf-8')</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>    # 打印响应内容</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>    print(res)</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>    # 解析HTML内容</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>    soup=BeautifulSoup(res,'lxml')</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>    # 查找所有符合条件的div标签</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>    dw = soup.find_all('div', class_='result-op c-container xpath-log new-pmd')</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>    # 遍历找到的div标签</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>    for n in dw:</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>        # 提取新闻链接</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>        url0=n.find('a',class_='news-title-font_1xS-F').get('href')</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>        # 提取新闻标题</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>        title=n.find('a',class_='news-title-font_1xS-F').get('aria-label')</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>        # 提取新闻内容摘要</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>        neirong=n.find('span',class_='c-font-normal c-color-text').text</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>        # 提取新闻来源</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>        laiyuan=n.find('span',class_='c-color-gray').text</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>        # 打印提取的信息</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>        print(url0,title,neirong,laiyuan)</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>    # 随机等待3到5秒，以避免被封禁</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#000080;"><strong>    time.sleep(random.randint(3,5))</strong></span></span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong>代码解释</strong></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong>导入模块</strong></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">import time</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">import random</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">import urllib.request</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">from bs4 import BeautifulSoup</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">time: 用于时间相关操作，如暂停脚本执行。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">random: 用于生成随机数，避免请求过于频繁。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">urllib.request: 用于发起HTTP请求。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">BeautifulSoup: 用于解析HTML内容。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong>定义爬取的网址和请求头</strong></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">url='https://www.baidu.com/s?...'</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">headers={'User-Agent':'Mozilla/5.0...','Cookie':'BIDUPSID=...'}</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">url: 要爬取的百度新闻搜索结果页面的基本URL。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">headers: HTTP请求头信息，包括User-Agent和Cookie，以模拟真实用户请求。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong>循环发起请求</strong></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">for i in range(0,1):</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">仅执行一次请求，但可以扩展为多页请求。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong>构建请求对象并发起请求</strong></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">request = urllib.request.Request(url+str(i*10),headers=headers)</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">response = urllib.request.urlopen(request)</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">status_code = response.getcode()</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">print(f"Response code for request {i}: {status_code}")</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">构建包含URL和请求头的请求对象。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">发起请求并获取响应。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">打印HTTP响应状态码以确认请求成功。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong>读取和解析响应内容</strong></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">res=response.read().decode('utf-8')</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">print(res)</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">soup=BeautifulSoup(res,'lxml')</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">读取响应内容并解码为UTF-8字符串。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">打印响应内容（可选）。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">使用BeautifulSoup解析HTML内容。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong>查找并提取新闻信息</strong></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">dw = soup.find_all('div', class_='result-op c-container xpath-log new-pmd')</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">for n in dw:</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">    url0=n.find('a',class_='news-title-font_1xS-F').get('href')</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">   title=n.find('a',class_='news-title-font_1xS-F').get('aria-label')</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">    neirong=n.find('span',class_='c-font-normal c-color-text').text</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">    laiyuan=n.find('span',class_='c-color-gray').text</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">    print(url0,title,neirong,laiyuan)</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">查找所有包含新闻信息的div标签。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">遍历找到的div标签，并提取其中的新闻链接、标题、内容摘要和来源。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">打印提取的信息。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong>随机等待一段时间</strong></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">time.sleep(random.randint(3,5))</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">随机等待3到5秒，以避免请求过于频繁导致被封禁。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">最后程序运行得到如下结果：</span></p> 
<p><img alt="" height="268" src="https://images2.imgbox.com/1d/17/cPPQjZAP_o.png" width="553"></p> 
<p><img alt="" height="243" src="https://images2.imgbox.com/da/c6/eUSUKb7U_o.png" width="553"></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong>总结</strong></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong>总结</strong></strong></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">在当今信息爆炸的时代，如何快速有效地获取并处理大量的在线信息已成为研究与应用中的一大挑战。通过此次研究，我们设计并实现了一个基于Python语言的网络爬虫，专门用于从百度新闻搜索结果中提取相关的新闻信息。以下是对整个过程及其成果的总结。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">1. 研究目的</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">本次研究的主要目标是开发一个能够自动化获取百度新闻数据的爬虫程序。具体而言，爬虫应能抓取新闻的标题、链接、摘要和来源等信息。这将为后续的新闻数据分析提供基础，并且有助于进一步的舆情监控和热点话题挖掘。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">2. 方法与实现</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">在实现过程中，我们使用了Python语言，并借助了多个强大的库来完成任务。首先，使用urllib.request模块构建HTTP请求，模拟浏览器访问百度新闻搜索页面。通过设置合适的请求头信息，包括User-Agent和Cookie，我们避免了被百度的反爬机制直接识别和屏蔽。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">爬虫的具体实现步骤如下：</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">构建请求对象：通过循环构建请求对象，针对不同的页面发送请求。请求头包含了模拟的用户代理和必要的Cookie信息，以绕过基本的反爬虫机制。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">发起请求并获取响应：利用urllib.request.urlopen方法发送请求并获取响应。通过检查HTTP状态码来确认请求是否成功。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">解析响应内容：使用BeautifulSoup库解析返回的HTML文档。通过分析百度新闻页面的结构，定位到包含新闻信息的特定div标签。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">提取并打印信息：从定位到的div标签中提取新闻的标题、链接、摘要和来源。提取后的信息通过控制台打印出来，以便验证爬虫的有效性。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">添加随机等待时间：在每次请求之间加入随机的等待时间（3到5秒），以模拟正常用户的浏览行为，进一步降低被反爬机制封禁的风险。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">3. 成果与验证</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">通过本次研究，我们成功地实现了一个能够稳定运行的百度新闻爬虫。爬虫程序能够准确地从百度新闻搜索结果中提取出所需的新闻信息，并在控制台输出这些信息。通过多次测试，爬虫展示了良好的鲁棒性和有效性，能够处理不同页面结构的新闻内容。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">4. 意义与应用</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">本次研究的成果不仅在技术上展示了如何构建一个有效的网络爬虫，更在实际应用中提供了获取大规模新闻数据的解决方案。通过进一步的扩展和优化，这一爬虫可以应用于实时新闻监控、舆情分析、市场调研等多个领域。研究人员和数据分析师可以利用这些爬取到的数据，进行深入的文本分析和数据挖掘，洞察社会关注热点和趋势。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">5. 未来工作</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">尽管当前的爬虫程序已经实现了预期的功能，但仍有改进空间。未来的工作可以包括：</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">提升爬虫效率：通过并发处理提高爬虫的速度和效率。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">增强反反爬机制：进一步研究并实现更多的反反爬策略，以应对更加复杂的反爬虫措施。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">数据存储与管理：将提取的数据存储到数据库中，方便后续的数据分析和处理。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">通过本次研究，我们不仅实现了从百度新闻中自动提取数据的技术方案，还为后续的新闻分析和应用提供了坚实的基础。希望这一研究能为更多的学术研究和实际应用带来启发。</span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7077cffff3fd1f8469c547520b1a005f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MySQL第一次作业</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8f85b14ca5fa046af1d24706e80cddd4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">lua脚本在redis的实战案例</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>