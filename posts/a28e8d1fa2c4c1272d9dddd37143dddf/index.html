<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Python】全面掌握 Collections Deque：队列与栈的高效实现及动态内存管理指南 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/a28e8d1fa2c4c1272d9dddd37143dddf/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【Python】全面掌握 Collections Deque：队列与栈的高效实现及动态内存管理指南">
  <meta property="og:description" content="文章目录 第一章：`deque` 的定义和特性1. 什么是双端队列（deque）2. `deque` 与普通列表（list）的性能差异 第二章：构造函数1. 如何创建一个 `deque`2. 可选参数 `maxlen` 的作用和使用场景 第三章：添加和删除元素1. 使用 `append` 方法在右端添加元素2. 使用 `appendleft` 方法在左端添加元素3. 使用 `pop` 方法从右端删除元素4. 使用 `popleft` 方法从左端删除元素 第四章：访问和旋转元素1. 如何访问 `deque` 中的元素2. `deque` 的索引和切片操作3. `deque` 的 `rotate` 方法 第五章：扩展 `deque`1. 使用 `extend` 方法在右端扩展多个元素2. 使用 `extendleft` 方法在左端扩展多个元素 第六章：限制和性能考虑1. `maxlen` 属性的影响2. `deque` 的内存效率和操作效率 第七章：实际应用场景1. 实现队列和栈2. 实现滑动窗口代码实现维护 `deque` 的递减性质例子解析检查和移除逻辑 3. 广度优先搜索 (BFS) 第八章：注意事项和局限性1. `deque` 的局限性2. 何时不应使用 `deque` 本文章主要探讨 Python collections 模块中的 deque 类，详尽介绍了其定义、特性、构造方法、操作技巧、实际应用场景以及其使用时的注意事项和局限性。
第一章：deque 的定义和特性 1.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-28T18:26:25+08:00">
    <meta property="article:modified_time" content="2024-04-28T18:26:25+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Python】全面掌握 Collections Deque：队列与栈的高效实现及动态内存管理指南</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#deque__4" rel="nofollow">第一章：`deque` 的定义和特性</a></li><li><ul><li><a href="#1_deque_6" rel="nofollow">1. 什么是双端队列（deque）</a></li><li><a href="#2_deque_list_15" rel="nofollow">2. `deque` 与普通列表（list）的性能差异</a></li></ul> 
   </li><li><a href="#_24" rel="nofollow">第二章：构造函数</a></li><li><ul><li><a href="#1__deque_26" rel="nofollow">1. 如何创建一个 `deque`</a></li><li><a href="#2__maxlen__43" rel="nofollow">2. 可选参数 `maxlen` 的作用和使用场景</a></li></ul> 
   </li><li><a href="#_58" rel="nofollow">第三章：添加和删除元素</a></li><li><ul><li><a href="#1__append__62" rel="nofollow">1. 使用 `append` 方法在右端添加元素</a></li><li><a href="#2__appendleft__76" rel="nofollow">2. 使用 `appendleft` 方法在左端添加元素</a></li><li><a href="#3__pop__87" rel="nofollow">3. 使用 `pop` 方法从右端删除元素</a></li><li><a href="#4__popleft__97" rel="nofollow">4. 使用 `popleft` 方法从左端删除元素</a></li></ul> 
   </li><li><a href="#_107" rel="nofollow">第四章：访问和旋转元素</a></li><li><ul><li><a href="#1__deque__111" rel="nofollow">1. 如何访问 `deque` 中的元素</a></li><li><a href="#2_deque__128" rel="nofollow">2. `deque` 的索引和切片操作</a></li><li><a href="#3_deque__rotate__147" rel="nofollow">3. `deque` 的 `rotate` 方法</a></li></ul> 
   </li><li><a href="#_deque_169" rel="nofollow">第五章：扩展 `deque`</a></li><li><ul><li><a href="#1__extend__173" rel="nofollow">1. 使用 `extend` 方法在右端扩展多个元素</a></li><li><a href="#2__extendleft__188" rel="nofollow">2. 使用 `extendleft` 方法在左端扩展多个元素</a></li></ul> 
   </li><li><a href="#_200" rel="nofollow">第六章：限制和性能考虑</a></li><li><ul><li><a href="#1_maxlen__204" rel="nofollow">1. `maxlen` 属性的影响</a></li><li><a href="#2_deque__223" rel="nofollow">2. `deque` 的内存效率和操作效率</a></li></ul> 
   </li><li><a href="#_233" rel="nofollow">第七章：实际应用场景</a></li><li><ul><li><a href="#1__237" rel="nofollow">1. 实现队列和栈</a></li><li><a href="#2__260" rel="nofollow">2. 实现滑动窗口</a></li><li><ul><li><a href="#_264" rel="nofollow">代码实现</a></li><li><a href="#_deque__301" rel="nofollow">维护 `deque` 的递减性质</a></li><li><a href="#_313" rel="nofollow">例子解析</a></li><li><a href="#_328" rel="nofollow">检查和移除逻辑</a></li></ul> 
    </li><li><a href="#3__BFS_333" rel="nofollow">3. 广度优先搜索 (BFS)</a></li></ul> 
   </li><li><a href="#_368" rel="nofollow">第八章：注意事项和局限性</a></li><li><ul><li><a href="#1_deque__372" rel="nofollow">1. `deque` 的局限性</a></li><li><a href="#2__deque_378" rel="nofollow">2. 何时不应使用 `deque`</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<blockquote> 
 <p>本文章主要探讨 Python <code>collections</code> 模块中的 <code>deque</code> 类，详尽介绍了其定义、特性、构造方法、操作技巧、实际应用场景以及其使用时的注意事项和局限性。</p> 
</blockquote> 
<h3><a id="deque__4"></a>第一章：<code>deque</code> 的定义和特性</h3> 
<h4><a id="1_deque_6"></a>1. 什么是双端队列（deque）</h4> 
<p><code>deque</code>，全名为双端队列（Double-Ended Queue），是一个由 Python 的 <code>collections</code> 模块提供的容器类型。它支持从两端进行元素的快速添加和删除操作。<code>deque</code> 是线程安全的，可以在不使用锁的情况下从两端操作，这使得它特别适合用于多线程编程中实现数据共享的队列。</p> 
<p>在 <code>deque</code> 中，可以使用 <code>append</code> 来在队列的右端添加元素，使用 <code>appendleft</code> 在队列的左端添加元素。同样地，可以使用 <code>pop</code> 从右端删除元素，使用 <code>popleft</code> 从左端删除元素。这种灵活性使得 <code>deque</code> 不仅可以用作普通的队列，也可以作为栈使用，非常适合需要双向操作的场合。</p> 
<p><img src="https://images2.imgbox.com/3f/17/3Pi1EGZY_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2_deque_list_15"></a>2. <code>deque</code> 与普通列表（list）的性能差异</h4> 
<p><code>deque</code> 和 Python 的内置列表（list）在使用和功能上有着明显的区别，特别是在性能方面：</p> 
<ul><li><strong>从两端添加或删除元素：</strong> 对于 <code>deque</code>，无论是从前端还是后端添加或删除元素，时间复杂度都是 O(1)。这得益于 <code>deque</code> 的数据结构设计，它允许两端都能高效地进行修改操作。相比之下，列表在尾部添加或删除元素（使用 <code>append</code> 和 <code>pop</code>）的效率也很高（O(1)），但在列表的开头插入或删除元素（如使用 <code>insert(0, value)</code> 或 <code>pop(0)</code>）时，性能会显著下降，因为这涉及到移动列表中的所有其他元素，时间复杂度为 O(n)，其中 n 是列表的长度。</li><li><strong>内存效率：</strong> <code>deque</code> 在内存使用上通常比列表更加高效，因为它在两端的操作减少了内存重新分配的次数。列表在达到其容量极限时需要进行整体的内存重新分配，而 <code>deque</code> 则通过一个链表的形式分散存储，每次内存分配影响的范围较小。</li></ul> 
<p>由于这些特性，<code>deque</code> 是解决需要频繁修改两端元素的问题的理想选择，而列表则更适合那些主要进行尾部操作和顺序访问的任务。</p> 
<h3><a id="_24"></a>第二章：构造函数</h3> 
<h4><a id="1__deque_26"></a>1. 如何创建一个 <code>deque</code></h4> 
<p>要使用 <code>deque</code>，首先需要从 <code>collections</code> 模块中导入它。创建一个 <code>deque</code> 对象的基本方法非常简单，可以直接通过将一个可迭代对象传递给 <code>deque</code> 的构造函数来完成，这与创建列表类似。</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque

<span class="token comment"># 创建一个空的 deque</span>
d <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 使用列表初始化 deque</span>
d <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment"># 使用字符串初始化，每个字符作为一个元素</span>
d <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span>
</code></pre> 
<h4><a id="2__maxlen__43"></a>2. 可选参数 <code>maxlen</code> 的作用和使用场景</h4> 
<p><code>deque</code> 的构造函数还接受一个名为 <code>maxlen</code> 的可选参数。这个参数用于设置 <code>deque</code> 可以容纳的最大元素数量。当设定了 <code>maxlen</code> 并且在 <code>deque</code> 中添加元素使其达到最大容量时，每当添加一个新元素，另一端的元素会被自动移除。</p> 
<pre><code class="prism language-python"><span class="token comment"># 创建一个最大长度为 3 的 deque</span>
d <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> maxlen<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span>

<span class="token comment"># 当尝试添加更多元素时，最旧的元素将被自动移除</span>
d<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>  <span class="token comment"># deque([2, 3, 4])</span>
d<span class="token punctuation">.</span>appendleft<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># deque([1, 2, 3])</span>
</code></pre> 
<p>这个特性非常适合于需要限制容量的应用场景，如缓存机制或最近使用的项目（LRU）缓存。当只需要跟踪最新的几个项目时，使用 <code>maxlen</code> 可以自动维护 <code>deque</code> 的大小，避免手动删除老旧元素的复杂性。</p> 
<h3><a id="_58"></a>第三章：添加和删除元素</h3> 
<p><code>deque</code> 提供了多种方法来动态地添加和删除元素，使其非常适用于需要频繁修改的数据结构应用场景。以下是 <code>deque</code> 的基本操作方法的详细介绍。</p> 
<h4><a id="1__append__62"></a>1. 使用 <code>append</code> 方法在右端添加元素</h4> 
<p><code>append</code> 方法是用于在 <code>deque</code> 的右端添加新元素的基本方法。这种操作非常快速，因为它不涉及元素之间的移动，只涉及到对尾部的访问和修改。</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque

d <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
d<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>  <span class="token comment"># 在右端添加元素</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span>  <span class="token comment"># 输出: deque([1, 2, 3, 4])</span>
</code></pre> 
<p>这个方法通常用于实现栈（后进先出）或队列（先进先出）的操作。</p> 
<h4><a id="2__appendleft__76"></a>2. 使用 <code>appendleft</code> 方法在左端添加元素</h4> 
<p>与 <code>append</code> 相对应，<code>appendleft</code> 方法允许用户在 <code>deque</code> 的左端添加新元素。这同样是一个时间复杂度为 O(1) 的操作，使得 <code>deque</code> 在需要从两端动态修改数据时表现出色。</p> 
<pre><code class="prism language-python">d<span class="token punctuation">.</span>appendleft<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment"># 在左端添加元素</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span>  <span class="token comment"># 输出: deque([0, 1, 2, 3, 4])</span>
</code></pre> 
<p><code>appendleft</code> 非常适合于需要从前端推入数据的场景，例如在某些特定的数据流或缓冲区操作中。</p> 
<h4><a id="3__pop__87"></a>3. 使用 <code>pop</code> 方法从右端删除元素</h4> 
<p><code>pop</code> 方法用于从 <code>deque</code> 的右端移除并返回最后一个元素，这是实现栈结构的标准操作。由于 <code>deque</code> 的设计，这种操作同样具有很高的效率（O(1)）。</p> 
<pre><code class="prism language-python">last_item <span class="token operator">=</span> d<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 移除并返回右端元素</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>last_item<span class="token punctuation">)</span>  <span class="token comment"># 输出: 4</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span>  <span class="token comment"># 输出: deque([0, 1, 2, 3])</span>
</code></pre> 
<h4><a id="4__popleft__97"></a>4. 使用 <code>popleft</code> 方法从左端删除元素</h4> 
<p><code>popleft</code> 方法是 <code>deque</code> 中从左端移除并返回第一个元素的方法。这一操作对于实现队列结构至关重要，允许快速的从队列头部移除元素。</p> 
<pre><code class="prism language-python">first_item <span class="token operator">=</span> d<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 移除并返回左端元素</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>first_item<span class="token punctuation">)</span>  <span class="token comment"># 输出: 0</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span>  <span class="token comment"># 输出: deque([1, 2, 3])</span>
</code></pre> 
<h3><a id="_107"></a>第四章：访问和旋转元素</h3> 
<p>尽管 <code>deque</code> 主要设计用于高效地从两端添加和删除元素，它也支持通过索引访问单个元素。然而，相比列表，<code>deque</code> 在中间元素的访问效率方面有一定的限制。</p> 
<h4><a id="1__deque__111"></a>1. 如何访问 <code>deque</code> 中的元素</h4> 
<p><code>deque</code> 支持通过索引访问元素，这类似于列表的索引方式。可以直接使用索引操作符访问任意位置的元素。</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque
d <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment"># 访问第一个元素</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># 输出: 0</span>

<span class="token comment"># 访问最后一个元素</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># 输出: 4</span>
</code></pre> 
<p>尽管这种访问方式在语法上很直接，但需要注意的是，<code>deque</code> 中元素的随机访问不如列表高效，特别是在 <code>deque</code> 很大时。这是因为 <code>deque</code> 是用链表实现的，链表的随机访问性能相比于数组来说较差。</p> 
<h4><a id="2_deque__128"></a>2. <code>deque</code> 的索引和切片操作</h4> 
<p>与列表不同，<code>deque</code> 并不直接支持切片操作，即不能直接使用切片语法如 <code>d[0:3]</code> 来获取 <code>deque</code> 的一部分。如果需要执行切片操作，可以先将 <code>deque</code> 转换为列表，再进行切片，或者使用 <code>itertools.islice</code> 实现更高效的切片。</p> 
<pre><code class="prism language-python"><span class="token comment"># 将 deque 转换为列表进行切片</span>
d_list <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>d_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># 输出: [0, 1, 2]</span>

<span class="token comment"># 使用 itertools.islice 进行切片</span>
<span class="token keyword">from</span> itertools <span class="token keyword">import</span> islice
slice_result <span class="token operator">=</span> islice<span class="token punctuation">(</span>d<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">(</span>slice_result<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 输出: [0, 1, 2]</span>
</code></pre> 
<p>虽然操作有那么一些复杂，但它们提供了在需要时对 <code>deque</code> 进行灵活处理的方法。</p> 
<p><code>deque</code> 更多地被用于那些主要涉及到在两端添加或移除元素的情况，而不是频繁地随机访问中间元素。如果需要经常访问集合中间的元素，可能需要考虑是否有其他更适合的数据结构，如列表。当然，<code>deque</code> 提供了足够的功能来高效地处理数据，尤其是涉及队列和栈操作。</p> 
<h4><a id="3_deque__rotate__147"></a>3. <code>deque</code> 的 <code>rotate</code> 方法</h4> 
<p><code>deque</code> 提供了一个非常有用的方法 <code>rotate</code>，可以旋转队列中的元素。这个方法可以向右或向左旋转 <code>deque</code> 中的元素，使得部分元素从一端移到另一端，非常适合于需要循环移位操作的场景。</p> 
<p><code>rotate</code> 方法接受一个参数 <code>n</code>。如果 <code>n</code> 是正数，<code>deque</code> 将会向右旋转；如果 <code>n</code> 是负数，则向左旋转。旋转操作的效果是将 <code>deque</code> 尾部的元素移动到前面，或者将前面的元素移动到尾部。</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque

d <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment"># 向右旋转</span>
d<span class="token punctuation">.</span>rotate<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span>  <span class="token comment"># 输出: deque([5, 1, 2, 3, 4])</span>

<span class="token comment"># 向左旋转</span>
d<span class="token punctuation">.</span>rotate<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span>  <span class="token comment"># 输出: deque([1, 2, 3, 4, 5])</span>
</code></pre> 
<p>这种方法特别适合于需要周期性调整元素位置的应用，例如在某些算法中循环移位数组或处理缓冲流的数据。</p> 
<h3><a id="_deque_169"></a>第五章：扩展 <code>deque</code></h3> 
<p><code>deque</code> 提供了灵活的方法来扩展现有的双端队列，允许从两端迅速添加多个元素。这些功能特别适合于在执行批量操作时维护队列的效率和顺序。</p> 
<h4><a id="1__extend__173"></a>1. 使用 <code>extend</code> 方法在右端扩展多个元素</h4> 
<p><code>extend</code> 方法允许将一个可迭代对象中的元素添加到 <code>deque</code> 的右端。这个方法可以一次性添加多个元素，是扩展 <code>deque</code> 的一种高效方式。使用 <code>extend</code> 方法可以保持元素的添加顺序，与单独使用多次 <code>append</code> 方法相比，<code>extend</code> 在处理大量数据时更高效。</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque
d <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment"># 使用 extend 在右端添加多个元素</span>
d<span class="token punctuation">.</span>extend<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span>  <span class="token comment"># 输出: deque([1, 2, 3, 4, 5, 6])</span>
</code></pre> 
<p>这种方法在需要将多个数据源或批量数据快速合并到现有队列中时非常有用，例如在数据流处理或批量文件处理中。</p> 
<h4><a id="2__extendleft__188"></a>2. 使用 <code>extendleft</code> 方法在左端扩展多个元素</h4> 
<p>与 <code>extend</code> 类似，<code>extendleft</code> 方法允许将一个可迭代对象中的元素从左端添加到 <code>deque</code> 中。不同之处在于，<code>extendleft</code> 会逆序添加元素，因为它是从左端一次添加一个元素，所以首先添加的元素会被推到更远的位置。</p> 
<pre><code class="prism language-python"><span class="token comment"># 使用 extendleft 在左端添加多个元素</span>
d<span class="token punctuation">.</span>extendleft<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span>  <span class="token comment"># 输出: deque([-2, -1, 0, 1, 2, 3, 4, 5, 6])</span>
</code></pre> 
<p><code>extendleft</code> 方法的这种特性使得它在特定场景下非常有用，如需要反向保持元素添加的顺序时。然而，这也可能导致一些混淆，因为添加元素的顺序与 <code>extend</code> 是相反的。使用时需要特别注意这一点。</p> 
<h3><a id="_200"></a>第六章：限制和性能考虑</h3> 
<p>当使用 <code>deque</code> 时，了解其性能限制和效率特点是至关重要的。这包括对 <code>maxlen</code> 属性的影响以及内存和操作效率的考量。</p> 
<h4><a id="1_maxlen__204"></a>1. <code>maxlen</code> 属性的影响</h4> 
<p><code>maxlen</code> 属性为 <code>deque</code> 设置了一个固定的长度限制。这意味着一旦 <code>deque</code> 达到了设定的最大长度，每当新元素被添加进来，最老的元素会自动被从另一端移除。这种机制有助于保持 <code>deque</code> 的大小不会无限增长，特别是在内存有限的环境中或者处理连续的数据流时。</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque

<span class="token comment"># 创建一个最大长度为 5 的 deque</span>
d <span class="token operator">=</span> deque<span class="token punctuation">(</span>maxlen<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>
d<span class="token punctuation">.</span>extend<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span>  <span class="token comment"># 输出: deque([1, 2, 3, 4, 5], maxlen=5)</span>

<span class="token comment"># 添加新元素，自动移除最老元素</span>
d<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span>  <span class="token comment"># 输出: deque([2, 3, 4, 5, 6], maxlen=5)</span>
</code></pre> 
<p>使用 <code>maxlen</code> 可以防止内存泄漏，确保 <code>deque</code> 不会因积累过多无关数据而影响性能。然而，这也意味着数据会丢失，因此在需要保留全部历史数据的应用中，使用 <code>maxlen</code> 需要谨慎。</p> 
<h4><a id="2_deque__223"></a>2. <code>deque</code> 的内存效率和操作效率</h4> 
<p><strong>内存效率</strong>：<code>deque</code> 通过使用双向链表实现，可以实现两端的快速添加和删除操作，而不需要为整个容器重新分配内存。这与列表相比，在进行大量的插入和删除操作时可以显著减少内存的使用和提高性能。</p> 
<p><strong>操作效率</strong>：</p> 
<ul><li><strong>两端操作</strong>：<code>deque</code> 在其两端进行添加或删除操作都具有 O(1) 的时间复杂度，这使得它在实现如队列和栈等数据结构时非常高效。</li><li><strong>随机访问</strong>：尽管 <code>deque</code> 支持索引访问，但其效率低于列表，因为链表需要从头开始遍历到指定位置，时间复杂度为 O(n)。因此，如果依赖于频繁的随机访问，<code>deque</code> 可能不是最优选择。</li><li><strong>扩展操作</strong>：<code>extend</code> 和 <code>extendleft</code> 方法使得 <code>deque</code> 能够快速地从两端批量添加元素，这在处理大量数据时特别有用。</li></ul> 
<h3><a id="_233"></a>第七章：实际应用场景</h3> 
<p><code>deque</code> 由于其独特的性能特性和灵活的操作方式，在许多编程问题中都有广泛的应用。下面列举了一些典型的使用场景，展示了 <code>deque</code> 在实际中的有效应用。</p> 
<h4><a id="1__237"></a>1. 实现队列和栈</h4> 
<p>由于 <code>deque</code> 支持从两端高效地添加和删除元素，它非常适合用于实现数据结构如队列（先进先出）和栈（后进先出）。</p> 
<ul><li> <p><strong>队列</strong>： <code>deque</code> 可以用作队列，其中元素从一端添加（通常是右端），从另一端（左端）移除。这模拟了队列的操作，适合于任务调度和消息处理等场景。</p> <pre><code class="prism language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque
queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>
queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'任务1'</span><span class="token punctuation">)</span>
queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'任务2'</span><span class="token punctuation">)</span>
queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># '任务1' 被处理</span>
</code></pre> </li><li> <p><strong>栈</strong>： <code>deque</code> 也可以用作栈，其中元素从同一端添加和删除，模拟了栈的后进先出的特性。</p> <pre><code class="prism language-python">stack <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>
stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'页面1'</span><span class="token punctuation">)</span>
stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'页面2'</span><span class="token punctuation">)</span>
stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># '页面2' 被访问</span>
</code></pre> </li></ul> 
<h4><a id="2__260"></a>2. 实现滑动窗口</h4> 
<p>滑动窗口是一种常见的数据结构，用于处理连续数据流中的问题，如计算移动平均或滑动最大/最小值。<code>deque</code> 由于其两端操作的高效性，非常适合于实现滑动窗口的功能。</p> 
<h5><a id="_264"></a>代码实现</h5> 
<pre><code class="prism language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque

<span class="token keyword">def</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 结果列表</span>
    max_elements <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token comment"># 双端队列，用于存储可能是当前窗口最大值的元素索引</span>
    d <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">for</span> i<span class="token punctuation">,</span> num <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 移除所有小于当前元素的队尾元素的索引</span>
        <span class="token keyword">while</span> d <span class="token keyword">and</span> nums<span class="token punctuation">[</span>d<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> num<span class="token punctuation">:</span>
            d<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
        
        <span class="token comment"># 添加当前元素的索引到队列尾部</span>
        d<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>

        <span class="token comment"># 检查队首元素是否超出窗口范围</span>
        <span class="token keyword">if</span> d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> i <span class="token operator">-</span> k<span class="token punctuation">:</span>
            d<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
        
        <span class="token comment"># 当索引大于等于窗口大小减1时，队首元素为当前窗口的最大值</span>
        <span class="token keyword">if</span> i <span class="token operator">&gt;=</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>
            max_elements<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    
    <span class="token keyword">return</span> max_elements

<span class="token comment"># 示例</span>
nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span>
k <span class="token operator">=</span> <span class="token number">3</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>maxSlidingWindow<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 输出: [3, 3, 5, 5, 6, 7]</span>
</code></pre> 
<p><strong>时间复杂度</strong>：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
      
        O(n) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>，其中 n 是数组长度。每个元素最多被添加和移除队列一次。</p> 
<h5><a id="_deque__301"></a>维护 <code>deque</code> 的递减性质</h5> 
<p>每当一个新元素（比如当前元素为 <code>num</code>）需要加入到 <code>deque</code> 时，会执行以下操作：</p> 
<ol><li><strong>移除队尾小于当前元素的所有元素</strong>： 
  <ul><li>检查 <code>deque</code> 的队尾元素，如果队尾元素对应的数组值小于当前元素 <code>num</code>，则将这些元素从 <code>deque</code> 中移除。这是因为这些元素不可能再成为后续窗口的最大值了（当前元素更大，且更晚离开窗口）。</li><li>这个过程会一直持续，直到 <code>deque</code> 为空或者队尾元素大于等于当前元素为止。</li><li>这确保了当当前元素被加入 <code>deque</code> 后，<code>deque</code> 依然维持从左到右的递减顺序。</li></ul> </li><li><strong>添加当前元素的索引到队尾</strong>： 
  <ul><li>紧接着将当前元素的索引添加到 <code>deque</code> 的队尾。</li><li>因为之前已经移除了所有小于它的元素，所以保持了 <code>deque</code> 的递减性质。</li></ul> </li></ol> 
<h5><a id="_313"></a>例子解析</h5> 
<p>以 <code>nums = [1, 3, -1, -3, 5, 3, 6, 7]</code> 和 <code>k = 3</code> 为例，考虑每一步的 <code>deque</code> 变化来理解：</p> 
<ul><li><strong>第一步</strong>：<code>i=0</code>, <code>num=1</code> 
  <ul><li><code>deque = [0]</code>，只有一个元素，无需比较。</li></ul> </li><li><strong>第二步</strong>：<code>i=1</code>, <code>num=3</code> 
  <ul><li><code>deque = [0]</code> 中，索引0对应的值是1，小于3，所以移除。</li><li><code>deque = [1]</code>，现在 <code>deque</code> 只包含当前最大值3的索引。</li></ul> </li><li><strong>第三步</strong>：<code>i=2</code>, <code>num=-1</code> 
  <ul><li><code>deque = [1]</code> 中，索引1对应的值是3，大于-1，所以不移除。</li><li><code>deque = [1, 2]</code>，虽然-1不是最大值，但保留其索引以保持窗口大小。</li></ul> </li><li><strong>第四步</strong>：<code>i=3</code>, <code>num=-3</code> 
  <ul><li>类似地，<code>deque = [1, 2]</code>，3和-1都大于-3，所以 <code>deque</code> 更新为 <code>[1, 2, 3]</code>。</li></ul> </li></ul> 
<h5><a id="_328"></a>检查和移除逻辑</h5> 
<ul><li><strong>检查条件</strong>：<code>if d[0] == i - k</code> 这行代码检查 <code>deque</code> 的队首元素的索引是否等于 <code>i - k</code>。这里，<code>i - k</code> 是当前索引 <code>i</code> 减去窗口大小 <code>k</code>，得到的是当前窗口的前一个位置。如果 <code>deque</code> 的队首元素索引等于这个值，这意味着队首元素是窗口移动前的一个元素，现在已经不在当前窗口范围内了（已经超出了窗口的左边界）。</li><li><strong>移除操作</strong>：如果上述条件成立，使用 <code>d.popleft()</code> 从 <code>deque</code> 的左端移除该过期的元素索引。这确保了 <code>deque</code> 始终只包含当前窗口范围内的元素索引，且队首是当前窗口的最大值的索引。</li></ul> 
<h4><a id="3__BFS_333"></a>3. 广度优先搜索 (BFS)</h4> 
<p>在图或树的遍历中，广度优先搜索通常使用队列来维护当前层的节点。<code>deque</code> 由于其从两端高效地添加和删除操作，非常适合用作这类算法的数据结构基础。</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque

<span class="token keyword">def</span> <span class="token function">bfs</span><span class="token punctuation">(</span>graph<span class="token punctuation">,</span> start<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 初始化一个集合来存储已访问过的节点，防止重复访问</span>
    visited <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment"># 初始化一个双端队列，开始时只包含起始节点</span>
    queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">)</span>

    <span class="token comment"># 循环执行，直到队列为空</span>
    <span class="token keyword">while</span> queue<span class="token punctuation">:</span>
        <span class="token comment"># 从队列的左端移除一个元素，这保证了按层次顺序访问</span>
        vertex <span class="token operator">=</span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token comment"># 如果这个节点未被访问过，则进行处理</span>
        <span class="token keyword">if</span> vertex <span class="token keyword">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">:</span>
            <span class="token comment"># 将节点标记为已访问</span>
            visited<span class="token punctuation">.</span>add<span class="token punctuation">(</span>vertex<span class="token punctuation">)</span>
            <span class="token comment"># 找出所有未访问的邻居节点并加入队列，保证这些节点将在未来被访问</span>
            <span class="token comment"># graph[vertex] 访问当前节点的邻居</span>
            <span class="token comment"># - visited 确保只添加还未访问的邻居</span>
            queue<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>graph<span class="token punctuation">[</span>vertex<span class="token punctuation">]</span> <span class="token operator">-</span> visited<span class="token punctuation">)</span>

    <span class="token comment"># 返回所有从起始节点可达的节点集合</span>
    <span class="token keyword">return</span> visited

<span class="token comment"># 示例图的遍历</span>
graph <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">}</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>bfs<span class="token punctuation">(</span>graph<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 输出: {1, 2, 3, 4, 5}</span>
</code></pre> 
<h3><a id="_368"></a>第八章：注意事项和局限性</h3> 
<p>虽然 <code>deque</code> 在许多情况下表现出色，特别是在涉及到双端操作的场景中，但它并不总是最优的数据结构选择。了解 <code>deque</code> 的局限性和何时不应使用它是非常重要的。</p> 
<h4><a id="1_deque__372"></a>1. <code>deque</code> 的局限性</h4> 
<ul><li><strong>随机访问性能</strong>：尽管 <code>deque</code> 支持索引访问，但由于其底层是双向链表的实现，所以在随机访问时的性能不如数组或列表。每次访问都可能涉及从头节点或尾节点开始的遍历，尤其是访问中间元素时，性能会明显下降。</li><li><strong>不支持切片操作</strong>：<code>deque</code> 不支持直接的切片操作，这在需要执行大量基于位置的操作时可能不太方便。虽然可以通过转换为列表来间接实现，但这种转换本身就会带来额外的性能开销。</li><li><strong>内存使用</strong>：与具有紧凑内存布局的数组相比，<code>deque</code> 的每个元素都可能需要更多的内存开销，因为除了存储数据外，还需要额外的空间来维护前驱和后继的链接。</li></ul> 
<h4><a id="2__deque_378"></a>2. 何时不应使用 <code>deque</code></h4> 
<ul><li><strong>需要频繁随机访问的场景</strong>：如果依赖于频繁的、快速的随机访问操作，使用列表或动态数组可能是更好的选择。例如，在需要经常访问或修改中间位置元素的大型数据集时，列表的性能通常会优于 <code>deque</code>。</li><li><strong>大规模数据处理时的内存考量</strong>：虽然 <code>deque</code> 在添加和删除操作中非常高效，但如果要常大的数据集并且内存使用是一个关键考虑因素，更紧凑的数据结构（如数组）可能更合适。</li><li><strong>高度依赖切片操作的应用</strong>：在需要大量使用切片操作来处理数据的应用中，<code>deque</code> 的不支持直接切片可能成为一个限制。在这种情况下，列表或其他支持切片的数据结构可能更为适宜。</li></ul> 
<blockquote> 
 <p>参考：</p> 
 <ul><li><a href="https://medium.com/@rasmussen.matias/fun-with-deques-in-python-31942bcb6321" rel="nofollow">Fun with deques in Python</a></li><li><a href="https://www.interviewbit.com/blog/sliding-window-maximum/" rel="nofollow">Sliding Window Maximum</a></li><li><a href="https://learnpainless.com/understanding-python-deque-double-ended-queue/" rel="nofollow">Understanding Python deque (Double-Ended Queue)</a></li></ul> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/07cd252b5e219a95cf4b482e441df2a9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">大数据深度学习长短时记忆网络（LSTM）：从理论到PyTorch实战演示</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ed01a79cae5be026c6c5c17a527578b3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">YOLO目标检测项目--YOLOv4算法对交通标志的识别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>