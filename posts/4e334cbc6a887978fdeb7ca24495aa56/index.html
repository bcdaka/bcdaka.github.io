<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构——链式二叉树的实现与分治编程思维（c语言实现） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/4e334cbc6a887978fdeb7ca24495aa56/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构——链式二叉树的实现与分治编程思维（c语言实现）">
  <meta property="og:description" content="目录
前言：
1.前置说明
2.链式二叉树的遍历 2.1 前序，中序及后续遍历
2.2 前序遍历实现
2.3 中序遍历实现 2.4 后续遍历实现 3.结点个数以及高度等 3.1 结点个数
3.2 结点高度 3.3 叶子结点的个数 前言： 在之前的学习中，我们初步学习了二叉树的概念和实现二叉树的顺序结构，最主要的是使用二叉树的顺序结构建堆，从而实现堆排序，这一章我们要学习的是二叉树的另一个结构——二叉树的链式结构，与顺序结构不同的是，顺序结构的底层是一个数组，链式结构是使用递归将多个结点链接起来组成的二叉树，讲到这里，递归还不是很熟悉的小伙伴需要回去复习递归的知识才能更好的理解链式二叉树的实现，话不多是，我们马上开始这一期的学习吧。
1.前置说明 在学习二叉树的基本操作前，需先要创建一棵二叉树，然后才能学习其相关的基本操作。由于现在大家对二叉树结构掌握还不够深入，为了降低大家学习成本，此处手动快速创建一棵简单的二叉树，快速进入二叉树操作学习，等二叉树结构了解的差不多时，我们会过头再来研究二叉树真正的创建方式。
使用结构体来定义二叉树的结点，里面包含了它的数据和它的左子树，右子树，我们不知道将来会存什么类型的数据在结点中，所以使用typedef关键字来对它的数据类型改名，现在我们使用的是int类型，如果我们以后要使用char类型，只需要将第一行的int改成char就能实现了，如果我们不使用这个操作，将来要更改数据类型时，只能在各个函数中一个一个改，几十行几百行代码我们要改类型工作量还不是很大，如果是几万行几十万行其中的工作量有多大可想而知。
typedef int BTDateType; typedef struct BinaryTreeNode { BTDateType data; struct BinaryTreeNode* left; struct BinaryTreeNode* right; }BTNode; BTNode* creratNode() { BTNode* node1 = BuyNode(1); BTNode* node2 = BuyNode(2); BTNode* node3 = BuyNode(3); BTNode* node4 = BuyNode(4); BTNode* node5 = BuyNode(5); BTNode* node6 = BuyNode(6); node1-&gt;left = node2; node2-&gt;left = node3; node1-&gt;right = node4; node4-&gt;left = node5; node4-&gt;right = node6; return node1; } 注意：上述代码并不是创建二叉树的方式，真正创建二叉树方式后序详解重点讲解。 再看二叉树基本操作前，再回顾下二叉树的概念，二叉树是：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-24T14:29:44+08:00">
    <meta property="article:modified_time" content="2024-08-24T14:29:44+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构——链式二叉树的实现与分治编程思维（c语言实现）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:200px;"></p> 
<p id="%E5%89%8D%E8%A8%80%EF%BC%9A-toc" style="margin-left:200px;"><a href="#%E5%89%8D%E8%A8%80%EF%BC%9A" rel="nofollow">前言：</a></p> 
<p id="1.%E5%89%8D%E7%BD%AE%E8%AF%B4%E6%98%8E-toc" style="margin-left:0px;"><a href="#1.%E5%89%8D%E7%BD%AE%E8%AF%B4%E6%98%8E" rel="nofollow">1.前置说明</a></p> 
<p id="2.%E9%93%BE%E5%BC%8F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%C2%A0-toc" style="margin-left:0px;"><a href="#2.%E9%93%BE%E5%BC%8F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%C2%A0" rel="nofollow">2.链式二叉树的遍历 </a></p> 
<p id="2.1%20%E5%89%8D%E5%BA%8F%EF%BC%8C%E4%B8%AD%E5%BA%8F%E5%8F%8A%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86-toc" style="margin-left:40px;"><a href="#2.1%20%E5%89%8D%E5%BA%8F%EF%BC%8C%E4%B8%AD%E5%BA%8F%E5%8F%8A%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86" rel="nofollow">2.1 前序，中序及后续遍历</a></p> 
<p id="2.2%20%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#2.2%20%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E5%AE%9E%E7%8E%B0" rel="nofollow">2.2 前序遍历实现</a></p> 
<p id="2.3%20%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%AE%9E%E7%8E%B0%C2%A0-toc" style="margin-left:40px;"><a href="#2.3%20%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%AE%9E%E7%8E%B0%C2%A0" rel="nofollow">2.3 中序遍历实现 </a></p> 
<p id="2.4%20%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86%E5%AE%9E%E7%8E%B0%C2%A0-toc" style="margin-left:40px;"><a href="#2.4%20%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86%E5%AE%9E%E7%8E%B0%C2%A0" rel="nofollow">2.4 后续遍历实现 </a></p> 
<p id="3.%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0%E4%BB%A5%E5%8F%8A%E9%AB%98%E5%BA%A6%E7%AD%89%C2%A0-toc" style="margin-left:0px;"><a href="#3.%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0%E4%BB%A5%E5%8F%8A%E9%AB%98%E5%BA%A6%E7%AD%89%C2%A0" rel="nofollow">3.结点个数以及高度等 </a></p> 
<p id="3.1%20%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0-toc" style="margin-left:40px;"><a href="#3.1%20%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0" rel="nofollow">3.1 结点个数</a></p> 
<p id="3.2%20%E7%BB%93%E7%82%B9%E9%AB%98%E5%BA%A6%C2%A0-toc" style="margin-left:40px;"><a href="#3.2%20%E7%BB%93%E7%82%B9%E9%AB%98%E5%BA%A6%C2%A0" rel="nofollow">3.2 结点高度 </a></p> 
<p id="3.3%20%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E7%9A%84%E4%B8%AA%E6%95%B0%C2%A0-toc" style="margin-left:40px;"><a href="#3.3%20%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E7%9A%84%E4%B8%AA%E6%95%B0%C2%A0" rel="nofollow">3.3 叶子结点的个数 </a></p> 
<hr id="hr-toc"> 
<p></p> 
<h6 id="%E5%89%8D%E8%A8%80%EF%BC%9A">前言：</h6> 
<p>   在之前的学习中，我们初步学习了二叉树的概念和实现二叉树的顺序结构，最主要的是使用二叉树的顺序结构建堆，从而实现堆排序，这一章我们要学习的是二叉树的另一个结构——二叉树的链式结构，与顺序结构不同的是，顺序结构的底层是一个数组，链式结构是使用递归将多个结点链接起来组成的二叉树，讲到这里，递归还不是很熟悉的小伙伴需要回去复习递归的知识才能更好的理解链式二叉树的实现，话不多是，我们马上开始这一期的学习吧。</p> 
<h2 id="1.%E5%89%8D%E7%BD%AE%E8%AF%B4%E6%98%8E">1.前置说明</h2> 
<blockquote> 
 <p>  <strong>在学习二叉树的基本操作前，需先要创建一棵二叉树，然后才能学习其相关的基本操作。由于现在大家对二叉树结构掌握还不够深入，为了降低大家学习成本，此处手动快速创建一棵简单的二叉树，快速进入二叉树操作学习，等二叉树结构了解的差不多时，我们会过头再来研究二叉树真正的创建方式。</strong></p> 
</blockquote> 
<p>   使用结构体来定义二叉树的结点，里面包含了它的数据和它的左子树，右子树，我们不知道将来会存什么类型的数据在结点中，所以使用typedef关键字来对它的数据类型改名，现在我们使用的是int类型，如果我们以后要使用char类型，只需要将第一行的int改成char就能实现了，如果我们不使用这个操作，将来要更改数据类型时，只能在各个函数中一个一个改，几十行几百行代码我们要改类型工作量还不是很大，如果是几万行几十万行其中的工作量有多大可想而知。</p> 
<pre><code>typedef int BTDateType;
typedef struct BinaryTreeNode
{
	BTDateType data;
	struct BinaryTreeNode* left;
	struct BinaryTreeNode* right;
}BTNode;
BTNode* creratNode()
{
	BTNode* node1 = BuyNode(1);
	BTNode* node2 = BuyNode(2);
	BTNode* node3 = BuyNode(3);
	BTNode* node4 = BuyNode(4);
	BTNode* node5 = BuyNode(5);
	BTNode* node6 = BuyNode(6);

	node1-&gt;left = node2;
	node2-&gt;left = node3;
	node1-&gt;right = node4;
	node4-&gt;left = node5;
	node4-&gt;right = node6;

	return node1;
}</code></pre> 
<p><span style="color:#fe2c24;"><strong>注意：上述代码并不是创建二叉树的方式，真正创建二叉树方式后序详解重点讲解</strong>。</span> </p> 
<p><strong>再看二叉树基本操作前，再回顾下二叉树的概念，二叉树是</strong>：<br> 1. 空树<br> 2. 非空：根结点，根结点的左子树、根结点的右子树组成的。</p> 
<p><img alt="" height="414" src="https://images2.imgbox.com/ff/bf/x9KnDCHP_o.png" width="861"></p> 
<p>从概念中可以看出，二叉树定义是递归式的，因此后序基本操作中基本都是按照该概念实现的。</p> 
<h2 id="2.%E9%93%BE%E5%BC%8F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%C2%A0">2.链式二叉树的遍历 </h2> 
<h3 id="2.1%20%E5%89%8D%E5%BA%8F%EF%BC%8C%E4%B8%AD%E5%BA%8F%E5%8F%8A%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86">2.1 前序，中序及后续遍历</h3> 
<blockquote> 
 <p><strong>学习二叉树结构，最简单的方式就是遍历。所谓二叉树遍历(Traversal)是按照某种特定的规则，依次对二叉树中的结点进行相应的操作，并且每个结点只操作一次。访问结点所做的操作依赖于具体的应用问题。 遍历是二叉树上最重要的运算之一，也是二叉树上进行其它运算的基础。</strong></p> 
</blockquote> 
<p><img alt="" height="272" src="https://images2.imgbox.com/c0/bf/NhIPbj4j_o.png" width="492"></p> 
<p>按照规则，二叉树的遍历有：前序/中序/后序的递归结构遍历：<br> 1. <strong>前序遍历</strong>(Preorder Traversal 亦称先序遍历)——访问根结点的操作发生在遍历其左右子树之前。<br> 2. <strong>中序遍历</strong>(Inorder Traversal)——访问根结点的操作发生在遍历其左右子树之中（间）。<br> 3. <strong>后序遍历</strong>(Postorder Traversal)——访问根结点的操作发生在遍历其左右子树之后。 </p> 
<p>     由于被访问的结点必是某子树的根，<strong>所以N(Node）、L(Left subtree）和R(Right subtree）又可解释为根、根的左子树和根的右子树</strong>。NLR、LNR和LRN分别又称为先根遍历、中根遍历和后根遍历。</p> 
<p>     也就是说，<strong>前序遍历的访问顺序依次为：根结点，左子树，右子树</strong>。相应的，<strong>中序遍历的顺序依次为：左子树，根节点，右子树</strong>。<strong>后序遍历的顺序依次为：左子树，右子树，根节点</strong>。</p> 
<p>我们有一棵二叉树：</p> 
<p><img alt="" height="556" src="https://images2.imgbox.com/fe/32/BRYQkL9u_o.png" width="549"></p> 
<p>假设空结点为N：</p> 
<p>前序遍历：1   2   3   N   N   N   4   5   N   N   6   N   N</p> 
<p>中序遍历：N   3   N   2   N   1   N   5   N   4   N   6   N </p> 
<p>后序遍历：N   N   3   N   2   N   N   5  N   N   6    4   1</p> 
<p><strong>其中N就是我们在访问一些结点的左右子树时发现是空树时的标记</strong>。</p> 
<h3 id="2.2%20%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E5%AE%9E%E7%8E%B0">2.2 前序遍历实现</h3> 
<p>  我们在前面已经简单的实现了一棵树，现在就可以使用这棵树实现一些像遍历，计算结点个数这样的操作了。</p> 
<p>   前序遍历的代码实现也比较简单，使用递归实现前序遍历，我们要先访问根结点，再去访问左子树和右子树，就是先打印根节点的数据，然后依次调用自己传左子树和右子树实现递归，如果遇到空树，我们就打印N，然后使用return马上走出这个函数栈帧，回到上一个函数栈帧，直到回到根结点为止。</p> 
<pre><code>void FrontOrder(BTNode* root)
{
	if (root == NULL)
	{
		printf("N ");
		return;
	}

	printf("%d ", root-&gt;data);
	FrontOrder(root-&gt;left);
	FrontOrder(root-&gt;right);
}</code></pre> 
<p>图解：</p> 
<p><img alt="" height="475" src="https://images2.imgbox.com/dc/ce/qpj9Dt9N_o.png" width="892"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/78/34/YN13pqO9_o.png" width="1200"></p> 
<h3 id="2.3%20%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%AE%9E%E7%8E%B0%C2%A0">2.3 中序遍历实现 </h3> 
<p>   中序遍历的实现与前序遍历的原理大致相同，在前序遍历原有代码的基础上改变顺序就可以实现了：</p> 
<pre><code>void MiddleOrder(BTNode* root)
{
	if (root == NULL)
	{
		printf("N ");
		return;
	}

	MiddleOrder(root-&gt;left);
	printf("%d ", root-&gt;data);
	MiddleOrder(root-&gt;right);
}</code></pre> 
<h3 id="2.4%20%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86%E5%AE%9E%E7%8E%B0%C2%A0">2.4 后续遍历实现 </h3> 
<pre><code>void BackOrder(BTNode* root)
{
	if (root == NULL)
	{
		printf("N ");
		return;
	}

	BackOrder(root-&gt;left);
	BackOrder(root-&gt;right);
	printf("%d ", root-&gt;data);
}</code></pre> 
<p>前序遍历结果：1 2 3 4 5 6<br> 中序遍历结果：3 2 1 5 4 6<br> 后序遍历结果：3 2 5 6 4 1</p> 
<p>程序运行结果：</p> 
<p><img alt="" height="67" src="https://images2.imgbox.com/01/72/mEo5wU09_o.png" width="449"></p> 
<h2 id="3.%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0%E4%BB%A5%E5%8F%8A%E9%AB%98%E5%BA%A6%E7%AD%89%C2%A0">3.结点个数以及高度等 </h2> 
<h3 id="3.1%20%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0">3.1 结点个数</h3> 
<p>   计算结点个数这里很容易掉入一个坑中，计算结点个数必然要使用递归，多次调用同一个函数，但是我们的每一次调用，都会建立一个独立的栈帧，而函数结束之后，函数栈帧也随之销毁，函数栈帧里的变量也不会存在，所以就不能使用局部变量来计算，我们自然而然就想到使用静态变量来计算，因为静态变量是存在于于堆区的，函数栈帧销毁不会将静态变量回收，所以有计算节点个数的函数：</p> 
<pre><code>size_t TreeSize(BTNode* root)
{
	static size_t size;
	if (root == NULL)
	{
		return 0;
	}
	else
		size++;

	TreeSize(root-&gt;left);
	TreeSize(root-&gt;right);
	return size;
}</code></pre> 
<p>这个函数能不能算出结点个数呢，我们当前是这样一棵树：</p> 
<p><img alt="" height="491" src="https://images2.imgbox.com/f8/12/7CqWqOH0_o.png" width="627"></p> 
<p>共六个结点，来看程序运行结果：</p> 
<p><img alt="" height="96" src="https://images2.imgbox.com/36/c4/MV54cGcu_o.png" width="474"></p> 
<p>这样一看是不是很正确呢，但是如果我们调用两次：</p> 
<p><img alt="" height="112" src="https://images2.imgbox.com/ae/ed/LYyaFv6H_o.png" width="453"></p> 
<p>    二叉树的结点个数又变成12了，到这我们也发现问题所在了，由于size是静态变量，在内存中只存在一份，在第二次调用时size的值就是6，而二叉树的结点是6个，就这样size的值变成了12，所以这样的方法是行不通的。所以我们使用另一种方法——分治。什么叫分治呢，假如某个学校的校长想要统计一下在校师生人数，他就会通知各个学院的院长让他们统计人数，而各个学院的院长通知各个班的班主任，班主任通知各个班的班长，将人数统计出来加上自己就是人数，这样是不是就方便了许多呢：</p> 
<p><img alt="" height="552" src="https://images2.imgbox.com/6e/65/Y2Bijdqr_o.png" width="1151"></p> 
<p>所以我们计算二叉树结点的函数应该是这样：</p> 
<pre><code>size_t TreeNodeCount(BTNode* root)
{
	return root == NULL ? 0 : TreeNodeCount(root-&gt;left) +
		TreeNodeCount(root-&gt;right) + 1;
}</code></pre> 
<p>将自己与左右子树的结点个数加起来就是总的结点个数：</p> 
<p><img alt="" height="86" src="https://images2.imgbox.com/c2/5c/crMruWJh_o.png" width="446"></p> 
<p></p> 
<h3 id="3.2%20%E7%BB%93%E7%82%B9%E9%AB%98%E5%BA%A6%C2%A0">3.2 结点高度 </h3> 
<p>   计算结点高度也是一个带着坑的问题，这样的问题也需要使用递归实现，我们的方法是：将左右子树的高度分别算出来，然后将大的那个加一就是整棵树的高度，但是我们在计算二叉树高度时，需要将它们的结果存起来，如果不存起来，我们每次要拿到这个结果都要递归一次，如果这棵树高一点的话，其中的计算量是非常恐怖的，所以我们要使用这种将结果存起来的方法：</p> 
<pre><code>size_t TreeHeight(BTNode* root)
{
	if (root == NULL)
		return 0;
	size_t leftheigh = TreeHeight(root-&gt;left);
	size_t rightheigh = TreeHeight(root-&gt;right);

	return leftheigh &gt; rightheigh ? leftheigh + 1 : rightheigh + 1;
}</code></pre> 
<p>我们当前树的高度是3，来看看程序运行结果吧：</p> 
<p><img alt="" height="106" src="https://images2.imgbox.com/f6/5d/WKj77wYE_o.png" width="450"></p> 
<h3 id="3.3%20%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E7%9A%84%E4%B8%AA%E6%95%B0%C2%A0">3.3 叶子结点的个数 </h3> 
<p>  如何计算叶子结点的个数呢，我们发现只有叶子结点没有左右子树，所以只要一个结点的左右子树为空我们就认为它是叶子结点，发现叶子结点我们就返回1，如果当前结点不是叶子结点我们就去计算左右子树的叶子结点个数，需要注意的是，如果我们访问的是一棵空树，程序马上就会崩溃，所以要加个判断：如果是一棵空树就马上返回0结束这个栈帧，这样程序就不会崩溃了。</p> 
<pre><code>size_t TreeLelfSize(BTNode* root)
{
	//如果是空树，要马上返回零，否则走到下一行代码会崩溃
	if (root == NULL)
		return 0;

	if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)
	{
		return 1;
	}

	return TreeLelfSize(root-&gt;left) + TreeLelfSize(root-&gt;right);
}</code></pre> 
<p>这是我们当前的二叉树：</p> 
<p><img alt="" height="491" src="https://images2.imgbox.com/bf/e2/tQWobiEQ_o.png" width="627"></p> 
<p>可以看到叶子结点有3个，来看看程序运行结果吧：</p> 
<p><img alt="" height="128" src="https://images2.imgbox.com/e4/aa/20f6MfH5_o.png" width="465"></p> 
<p> 我将代码放在下面，感兴趣的话可以试试哦：</p> 
<pre><code>#define _CRT_SECURE_NO_WARNINGS 1
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
static size_t size;
typedef int BTDateType;
typedef struct BinaryTreeNode
{
	BTDateType data;
	struct BinaryTreeNode* left;
	struct BinaryTreeNode* right;
}BTNode;

BTNode* BuyNode(BTDateType x)
{
	BTNode* newnode = (BTNode*)malloc(sizeof(BTNode));
	if (newnode == NULL)
	{
		perror("malloc fail");
	}

	newnode-&gt;data = x;
	newnode-&gt;left = NULL;
	newnode-&gt;right = NULL;

	return newnode;
}

size_t TreeLelfSize(BTNode* root)
{
	//如果是空树，要马上返回零，否则走到下一行代码会崩溃
	if (root == NULL)
		return 0;

	if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)
	{
		return 1;
	}

	return TreeLelfSize(root-&gt;left) + TreeLelfSize(root-&gt;right);
}
void FrontOrder(BTNode* root)
{
	if (root == NULL)
	{
		printf("N ");
		return;
	}

	printf("%d ", root-&gt;data);
	FrontOrder(root-&gt;left);
	FrontOrder(root-&gt;right);
}

BTNode* creratNode()
{
	BTNode* node1 = BuyNode(1);
	BTNode* node2 = BuyNode(2);
	BTNode* node3 = BuyNode(3);
	BTNode* node4 = BuyNode(4);
	BTNode* node5 = BuyNode(5);
	BTNode* node6 = BuyNode(6);

	node1-&gt;left = node2;
	node2-&gt;left = node3;
	node1-&gt;right = node4;
	node4-&gt;left = node5;
	node4-&gt;right = node6;

	return node1;
}

size_t TreeSize(BTNode* root)
{	
	if (root == NULL)
	{
		return 0;
	}
	else
		size++;

	TreeSize(root-&gt;left);
	TreeSize(root-&gt;right);
	return size;
}
size_t TreeHeight(BTNode* root)
{
	if (root == NULL)
		return 0;
	size_t leftheigh = TreeHeight(root-&gt;left);
	size_t rightheigh = TreeHeight(root-&gt;right);

	return leftheigh &gt; rightheigh ? leftheigh + 1 : rightheigh + 1;
}

void MiddleOrder(BTNode* root)
{
	if (root == NULL)
	{
		printf("N ");
		return;
	}
	MiddleOrder(root-&gt;left);
	printf("%d ", root-&gt;data);
	MiddleOrder(root-&gt;right);
}
size_t TreeNodeCount(BTNode* root)
{
	return root == NULL ? 0 : TreeNodeCount(root-&gt;left) +
		TreeNodeCount(root-&gt;right) + 1;
}
void BackOrder(BTNode* root)
{
	if (root == NULL)
	{
		printf("N ");
		return;
	}
	BackOrder(root-&gt;left);
	BackOrder(root-&gt;right);
	printf("%d ", root-&gt;data);
}
int main()
{
	BTNode* root = creratNode();
	printf("前序遍历二叉树：");
	FrontOrder(root);
	printf("\n");

	printf("中序遍历二叉树：");
	MiddleOrder(root);
	printf("\n");

	printf("后序遍历二叉树：");
	BackOrder(root);
	printf("\n");

	printf("二叉树结点的数量:");
	
	printf("%zd\n", TreeNodeCount(root));

	printf("二叉树的高度为:");
	printf("%zd\n", TreeHeight(root));

	printf("二叉树的叶子节点有%zd个", TreeLelfSize(root));
	return 0;
}</code></pre> 
<p>本章完。  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/426a4ce9e48d25f5c69d17b346f422d8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">浅谈Kafka（三）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3e5d92a44a2fa1389a5d3d969e969826/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SpringBoot整合MQ</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>