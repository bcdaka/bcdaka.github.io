<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【MySQL】什么是事务？在高并发场景使用事务会出现什么问题，该如何解决 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/f38c348166199aa44cb939986ea708e5/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【MySQL】什么是事务？在高并发场景使用事务会出现什么问题，该如何解决">
  <meta property="og:description" content="事务的概念 在MySQL中，事务是一组操作的集合，这些操作要么全部执行成功，要么全部不执行。这种特性确保了数据库操作的可靠性和一致性。事务的主要概念包括以下几个方面：
原子性（Atomicity）：事务中的操作要么全部完成，要么全部不执行。这意味着在事务执行过程中，如果发生错误，所有已执行的操作会被撤销，数据库将返回到事务开始前的状态。
一致性（Consistency）：事务必须使数据库从一个一致性状态转变到另一个一致性状态。在事务执行前和执行后，数据库的完整性约束必须得到满足。
隔离性（Isolation）：多个事务同时执行时，彼此之间不会干扰。每个事务都有其独立的执行环境，防止了事务间的数据干扰。
持久性（Durability）：一旦事务提交，其结果就会永久保存到数据库中，即使发生系统崩溃也不会丢失。
在MySQL中，可以通过使用START TRANSACTION或BEGIN来开始一个事务，通过COMMIT来提交事务，通过ROLLBACK来撤销事务。事务的正确使用能够确保数据的完整性和一致性，是数据库管理的重要机制。
使用事务的原因 使用事务的原因主要体现在以下几个方面：
确保数据一致性：事务能够保证数据库在多用户环境下的一致性，确保在一个事务中所做的所有操作要么全部完成，要么全部不执行，从而防止数据处于不一致的状态。
提高数据安全性：通过原子性，事务确保了一系列操作的完整性。当事务中的某一操作失败时，所有的操作都会被撤销，这样可以避免部分操作成功而导致的数据错误或不一致。
支持并发控制：在多用户环境中，事务提供了一种机制来管理并发访问。通过隔离性，事务能够确保多个用户在同时访问和修改数据时不会发生冲突，提升了系统的稳定性和可用性。
维护数据完整性：事务在执行时可以确保所有的完整性约束（如主键、外键约束等）被满足，从而维护数据的逻辑合理性。
提高可恢复性：持久性确保了一旦事务提交，数据就会安全地保存在数据库中，即使出现系统崩溃，用户也不必担心数据丢失，提高了系统的可靠性。
总而言之，事务是保障数据库操作安全性和有效性的重要机制，通过使用事务，可以有效避免数据问题，增强数据库管理的可靠性和稳定性。
事务的使用 开启事务：start transaction; 执行多条SQL语句;
回滚或提交：rollback/commit; 下面是一个使用事务的示例，演示如何在MySQL中处理一个简单的银行转账操作。这个操作包括从一个账户扣款并将款项存入另一个账户。在这个过程中，我们使用事务来确保万一任何一个步骤失败，整个过程都可以回滚，保证数据的一致性。
示例：银行转账操作 需求：从账户A转账100元到账户B。
代码示例 -- 假设有一个账户表 CREATE TABLE accounts ( id INT PRIMARY KEY, balance DECIMAL(10, 2) NOT NULL ); -- 插入示例账户 INSERT INTO accounts (id, balance) VALUES (1, 1000.00), (2, 500.00); -- 开始事务 START TRANSACTION; -- 从账户A（id = 1）扣款100 UPDATE accounts SET balance = balance - 100 WHERE id = 1; -- 将100元存入账户B（id = 2） UPDATE accounts SET balance = balance &#43; 100 WHERE id = 2; -- 提交事务 COMMIT; -- 为了检查结果，你可以查询账户余额 SELECT * FROM accounts; 代码说明 创建账户表：首先我们创建了一个名为accounts的表，包含账户ID（id）和余额（balance）两个字段。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-13T18:46:02+08:00">
    <meta property="article:modified_time" content="2024-08-13T18:46:02+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【MySQL】什么是事务？在高并发场景使用事务会出现什么问题，该如何解决</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="background-color:transparent;">事务的概念</h2> 
<p>在MySQL中，事务是一组操作的集合，这些操作要么全部执行成功，要么全部不执行。这种特性确保了数据库操作的可靠性和一致性。事务的主要概念包括以下几个方面：</p> 
<ol><li> <p><strong>原子性（Atomicity）</strong>：事务中的操作要么全部完成，要么全部不执行。这意味着在事务执行过程中，如果发生错误，所有已执行的操作会被撤销，数据库将返回到事务开始前的状态。</p> </li><li> <p><strong>一致性（Consistency）</strong>：事务必须使数据库从一个一致性状态转变到另一个一致性状态。在事务执行前和执行后，数据库的完整性约束必须得到满足。</p> </li><li> <p><strong>隔离性（Isolation）</strong>：多个事务同时执行时，彼此之间不会干扰。每个事务都有其独立的执行环境，防止了事务间的数据干扰。</p> </li><li> <p><strong>持久性（Durability）</strong>：一旦事务提交，其结果就会永久保存到数据库中，即使发生系统崩溃也不会丢失。</p> </li></ol> 
<p>在MySQL中，可以通过使用<code>START TRANSACTION</code>或<code>BEGIN</code>来开始一个事务，通过<code>COMMIT</code>来提交事务，通过<code>ROLLBACK</code>来撤销事务。事务的正确使用能够确保数据的完整性和一致性，是数据库管理的重要机制。</p> 
<p></p> 
<h2 style="background-color:transparent;">使用事务的原因</h2> 
<p>使用事务的原因主要体现在以下几个方面：</p> 
<ol><li> <p><strong>确保数据一致性</strong>：事务能够保证数据库在多用户环境下的一致性，确保在一个事务中所做的所有操作要么全部完成，要么全部不执行，从而防止数据处于不一致的状态。</p> </li><li> <p><strong>提高数据安全性</strong>：通过原子性，事务确保了一系列操作的完整性。当事务中的某一操作失败时，所有的操作都会被撤销，这样可以避免部分操作成功而导致的数据错误或不一致。</p> </li><li> <p><strong>支持并发控制</strong>：在多用户环境中，事务提供了一种机制来管理并发访问。通过隔离性，事务能够确保多个用户在同时访问和修改数据时不会发生冲突，提升了系统的稳定性和可用性。</p> </li><li> <p><strong>维护数据完整性</strong>：事务在执行时可以确保所有的完整性约束（如主键、外键约束等）被满足，从而维护数据的逻辑合理性。</p> </li><li> <p><strong>提高可恢复性</strong>：持久性确保了一旦事务提交，数据就会安全地保存在数据库中，即使出现系统崩溃，用户也不必担心数据丢失，提高了系统的可靠性。</p> </li></ol> 
<p>总而言之，事务是保障数据库操作安全性和有效性的重要机制，通过使用事务，可以有效避免数据问题，增强数据库管理的可靠性和稳定性。</p> 
<p></p> 
<h2 style="background-color:transparent;">事务的使用</h2> 
<p></p> 
<ul><li><span style="color:#333333;">开启事务：</span><span style="color:#333333;">start transaction; </span></li></ul> 
<div> 
 <p><span style="color:#333333;">       执行多条</span><span style="color:#333333;">SQL</span><span style="color:#333333;">语句;</span></p> 
 <ul><li><span style="color:#333333;">回滚或提交：</span><span style="color:#333333;">rollback/commit; </span></li></ul> 
 <p></p> 
</div> 
<p>下面是一个使用事务的示例，演示如何在MySQL中处理一个简单的银行转账操作。这个操作包括从一个账户扣款并将款项存入另一个账户。在这个过程中，我们使用事务来确保万一任何一个步骤失败，整个过程都可以回滚，保证数据的一致性。</p> 
<h4 id="示例：银行转账操作" style="background-color:transparent;">示例：银行转账操作</h4> 
<p><strong>需求</strong>：从账户A转账100元到账户B。</p> 
<h4 id="代码示例" style="background-color:transparent;">代码示例</h4> 
<pre><code class="language-sql">-- 假设有一个账户表
CREATE TABLE accounts (
    id INT PRIMARY KEY,
    balance DECIMAL(10, 2) NOT NULL
);

-- 插入示例账户
INSERT INTO accounts (id, balance) VALUES (1, 1000.00), (2, 500.00);

-- 开始事务
START TRANSACTION;

-- 从账户A（id = 1）扣款100
UPDATE accounts SET balance = balance - 100 WHERE id = 1;

-- 将100元存入账户B（id = 2）
UPDATE accounts SET balance = balance + 100 WHERE id = 2;

-- 提交事务
COMMIT;

-- 为了检查结果，你可以查询账户余额
SELECT * FROM accounts;
</code></pre> 
<h4 id="代码说明" style="background-color:transparent;">代码说明</h4> 
<ol><li> <p><strong>创建账户表</strong>：首先我们创建了一个名为<code>accounts</code>的表，包含账户ID（<code>id</code>）和余额（<code>balance</code>）两个字段。</p> </li><li> <p><strong>插入示例账户</strong>：插入两个示例账户，账户A的余额为1000元，账户B的余额为500元。</p> </li><li> <p><strong>开始事务</strong>：通过<code>START TRANSACTION;</code>开始一个新的事务，用于保证接下来的操作的原子性。</p> </li><li> <p><strong>更新账户余额</strong>：</p> 
  <ul><li>第一个<code>UPDATE</code>语句用于从账户A中扣除100元。</li><li>第二个<code>UPDATE</code>语句用于将100元存入账户B。</li></ul></li><li> <p><strong>提交事务</strong>：通过<code>COMMIT;</code>来提交事务，如果所有操作成功执行，所有的变更会被保存到数据库中。</p> </li><li> <p><strong>查询结果</strong>：最后，使用SELECT语句检查账户的余额，以确认转账是否成功。</p> </li></ol> 
<h4 id="错误处理" style="background-color:transparent;">错误处理</h4> 
<p>在实际生产环境中，还需要考虑错误处理。如果在任一步骤发生错误，你应该执行<code>ROLLBACK;</code>来撤销之前的操作。例如：</p> 
<pre><code class="language-sql">-- 当UPDATE操作前后，我们应该有错误处理
BEGIN;

UPDATE accounts SET balance = balance - 100 WHERE id = 1;
IF ROW_COUNT() = 0 THEN
    ROLLBACK;
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Transaction failed: Account A does not have enough balance';
END IF;

UPDATE accounts SET balance = balance + 100 WHERE id = 2;

-- 提交事务
COMMIT;
</code></pre> 
<p>这种情况下，如果账户A的余额不足，事务将被回滚，确保数据一致性。通过合理使用事务，能够保障银行等业务场景中的数据安全。</p> 
<p></p> 
<h2 style="background-color:transparent;">在高并发场景使用事务会出现的问题以及解决方法</h2> 
<p>在高并发场景中，使用事务会面临一些挑战，这些挑战主要来源于多个事务并发执行时的相互影响。主要问题包括：</p> 
<h4 id="1-死锁（deadlock）" style="background-color:transparent;">1. <strong>死锁（Deadlock）</strong></h4> 
<p>多个事务在互相等待对方释放资源，导致系统无法继续执行。</p> 
<p><strong>解决方案</strong>：</p> 
<ul><li><strong>超时机制</strong>：设置事务超时，避免长时间等待。</li><li><strong>死锁检测与回滚</strong>：数据库通常会自动检测到死锁并回滚某一个事务，开发者可以优化代码逻辑以减少死锁发生的概率。</li><li><strong>合理的锁顺序</strong>：在数据库操作中，保持一致的资源访问顺序，降低死锁的风险。</li></ul> 
<h4 id="2-可用性和性能下降" style="background-color:transparent;">2. <strong>可用性和性能下降</strong></h4> 
<p>事务的隔离级别越高，可用性和性能通常越低。比如，使用<code>Serializable</code>级别会导致较长的锁定时间，影响并发性能。</p> 
<p><strong>解决方案</strong>：</p> 
<ul><li><strong>调整隔离级别</strong>：根据业务需求，选择适当的隔离级别。例如，使用<code>读已提交</code>或<code>可重复读</code>，在性能和隔离性之间找到平衡。</li><li><strong>使用乐观锁</strong>：在更新数据时，不会立即加锁，只有在提交时检查数据是否发生变化。如果发生变化，则回滚并重试。可以通过使用版本号或时间戳实现乐观锁。</li></ul> 
<h4 id="3-脏读和不可重复读" style="background-color:transparent;">3. <strong>脏读和不可重复读</strong></h4> 
<p>在高并发的情况下，可能会出现脏读（一个事务读取另一个事务未提交的数据）和不可重复读（同一事务的多次查询结果不同）。</p> 
<p><strong>解决方案</strong>：</p> 
<ul><li><strong>选择合适的隔离级别</strong>：如前所述，通过选择<code>读已提交</code>或<code>可重复读</code>来避免脏读和不可重复读问题。</li><li><strong>使用锁机制</strong>：在需要保证数据一致性的场合应用行级锁，避免其他事务读取未提交的数据。</li></ul> 
<h4 id="4-幻读（phantom-read）" style="background-color:transparent;">4. <strong>幻读（Phantom Read）</strong></h4> 
<p>在启动事务后，另一事务的插入会导致当前事务再次查询时出现不同的记录集。</p> 
<p><strong>解决方案</strong>：</p> 
<ul><li><strong>使用更高的隔离级别</strong>：如<code>Serializable</code>可以完全避免幻读，但在高并发场景中会导致性能下降。</li><li><strong>使用范围锁</strong>（如在某些数据库中支持），通过对查询的值范围加锁来避免幻读的发生。</li></ul> 
<h4 id="5-回滚带来的性能开销" style="background-color:transparent;">5. <strong>回滚带来的性能开销</strong></h4> 
<p>在高并发的情况下，频繁的事务回滚会导致性能下降。</p> 
<p><strong>解决方案</strong>：</p> 
<ul><li><strong>错误重试机制</strong>：在应用层实现智能重试机制，处理因冲突引起的回滚，同时通过后退指数等策略减少冲突。</li><li><strong>提高数据库性能</strong>：优化数据库性能、索引、查询，减少回滚的可能性。</li></ul> 
<p id="总结" style="background-color:transparent;">总结</p> 
<p>在高并发场景使用事务时，必须权衡数据一致性和系统性能。通过选择合适的事务隔离级别、利用锁机制、优化数据库操作以及设计合理的应用逻辑，可以减少并发带来的问题。同时，监控系统性能和及时调整也是确保系统稳定的重要手段。</p> 
<p></p> 
<h2 style="background-color:transparent;">MySQL自带的隔离级别调整</h2> 
<p>事务中的隔离性是指在多用户并发执行事务时，每个事务的执行不会被其他事务所干扰，确保每个事务可以在其独立的环境中执行。这一特性对于维护数据的完整性和一致性至关重要。隔离性通常通过不同的隔离级别来实现，每个级别都在并发性和数据一致性之间取得不同的平衡。</p> 
<p>MySQL支持四种主要的事务隔离级别：</p> 
<ol><li> <p><strong>读未提交（Read Uncommitted）</strong>：</p> 
  <ul><li>事务可以读取其他事务未提交的数据。</li><li>这种级别的并发性最高，但可能会导致脏读（Dirty Read）现象，即一个事务读取到另一个事务尚未提交的数据，这可能在后续操作中导致错误。</li></ul></li><li> <p><strong>读已提交（Read Committed）</strong>：</p> 
  <ul><li>事务只能读取其他已提交事务的数据。</li><li>这种级别避免了脏读，但仍然可能出现不可重复读（Non-repeatable Read），即在同一事务内的两次读取可能得到不同的结果，因为其他事务在这段时间可以提交改变。</li></ul></li><li> <p><strong>可重复读（Repeatable Read）</strong>：</p> 
  <ul><li>事务在开始时读取的数据在整个事务期间都是一致的，即使其他事务提交了改变。</li><li>这种级别避免了脏读和不可重复读，但可能发生幻读（Phantom Read），即在同一事务中，后续查询可能会看到新插入的行。</li></ul></li><li> <p><strong>串行化（Serializable）</strong>：</p> 
  <ul><li>这是最高级别的隔离，事务完全串行执行，仿佛是依次执行的。</li><li>这种级别可以完全避免脏读、不可重复读和幻读，但会导致并发性能显著降低，因为事务必须等待彼此完成。</li></ul></li></ol> 
<p id="隔离性的影响" style="background-color:transparent;">隔离性的影响</p> 
<ul><li><strong>性能</strong>：较高的隔离级别通常意味着更低的并发性能，因为事务之间的干扰被限制得更严格。</li><li><strong>一致性</strong>：在需要高度一致性保障的场景下，选择较高的隔离级别是合理的，比如金融交易系统等。而在一些可以容忍一定不一致性的场景下，选择较低的隔离级别可以提高系统性能。</li><li><strong>设计考虑</strong>：系统的设计和需求会决定使用哪种隔离级别。开发者需要根据应用场景评估性能与一致性之间的权衡。</li></ul> 
<p>总之，事务中的隔离性是支持并发操作的重要机制，通过合理选择隔离级别，可以在系统性能和数据一致性之间找到适当的平衡。</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5fa3f42eee1c2bde0e487c19ddd71d37/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">socket和websocket 有什么区别</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/24a542870af4a45e742bba9186d7e87e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">50&#43;个AI大模型在不同领域的应用案例</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>