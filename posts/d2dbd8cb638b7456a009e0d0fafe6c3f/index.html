<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>springboot整合webservice使用总结 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/d2dbd8cb638b7456a009e0d0fafe6c3f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="springboot整合webservice使用总结">
  <meta property="og:description" content="因为做的项目中用到了webservice,所以在此总结一下。
一、webservice简介 Web Service也叫XML Web Service, WebService是一种可以接收从Internet或者Intranet上的其它系统中传递过来的请求，轻量级的独立的通讯技术。是通过SOAP在Web上提供的软件服务，使用WSDL文件进行说明，并通过UDDI进行注册。WebService是一种跨编程语言和跨操作系统平台的远程调用技术。
还可以从多个角度来理解WebService，从表面看，WebService就是一个应用程序向外界暴露出一个能通过Web进行调用的API，也就是说能用编程的方法通过Web来调用这个应用程序。我们把调用这个WebService的应用程序叫做客户端，而把提供这个WebService的应用程序叫做服务端。从深层次看，WebService是建立可互操作的分布式应用程序的新平台，是一个平台，是一套标准。它定义了应用程序如何在Web上实现互操作性，你可以用任何你喜欢的语言，在任何你喜欢的平台上写Web service ，只要我们可以通过Web service标准对这些服务进行查询和访问。
二、webservice三要素： SOAP、WSDL、UDDI（UniversalDescriptionDiscovery andIntegration）三者构成了WebService的三要素。下面详细阐述这三大技术：
SOAP：
WebService通过HTTP协议发送请求和接收结果时，发送的请求内容和结果内容都采用XML格式封装，并增加了一些特定的HTTP消息头，以说明HTTP消息的内容格式，这些特定的HTTP消息头和XML内容格式就是SOAP协议。SOAP提供了标准的RPC(远程调用技术)方法来调用Web Service。
SOAP协议组成：
SOAP协议 = HTTP协议 &#43; XML数据格式
SOAP协议定义了SOAP消息的格式，SOAP协议是基于HTTP协议的，SOAP也是基于XML的，XML是SOAP的数据编码方式。
WSDL
好比我们去商店买东西，首先要知道商店里有什么东西可买，然后再来购买，商家的做法就是张贴广告海报。 WebService也一样，WebService客户端要调用一个WebService服务，首先要有知道这个服务的地址在哪，以及这个服务里有什么方法可以调用，所以，WebService务器端首先要通过一个WSDL文件来说明自己家里有啥服务可以对外调用，服务是什么（服务中有哪些方法，方法接受的参数是什么，返回值是什么），服务的网络地址用哪个url地址表示，服务通过什么方式来调用。
WSDL(Web Services Description Language)就是这样一个基于XML的语言，用于描述Web Service及其函数、参数和返回值。它是WebService客户端和服务器端都能理解的标准格式。因为是基于XML的，所以WSDL既是机器可阅读的，又是人可阅读的，这将是一个很大的好处。一些最新的开发工具既能根据你的Web service生成WSDL文档，又能导入WSDL文档，生成调用相应WebService的代理类代码。
UDDI
uddi是一个跨产业，跨平台的开放性架构，可以帮助 Web 服务提供商在互联网上发布 Web 服务的信息。UDDI 是一种目录服务，企业可以通过 UDDI 来注册和搜索 Web 服务。简单来说，UDDI 就是一个目录，只不过在这个目录中存放的是一些关于 Web 服务的信息而已。
也就是说：
soap：就是在与webservice通信时规定好的协议
wsdl：就是webservice中的食谱，你可以找到webservice中有哪些材料（方法），怎去做这道菜（入参、方法、返回值）等
uddi：wsdl是食谱的话，uddi就是菜单，可以用来注册和搜索web服务。
三、为什么要使用WebService 跨平台调用跨语言调用远程调用 四、springboot简单调用案例 1、引入依赖： &lt;!-- CXF webservice --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt; &lt;artifactId&gt;cxf-spring-boot-starter-jaxws&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; 2、创建实体类： @Data @Builder public class UserDto { private Long id; private String name; private Integer age; private String address; } 3、创建WebService接口 public interface IUserServer { UserDto getUser(Long str)； } 4、创建WebService接口的实现类 @Service @WebService public class UserServerImpl implements IUserServer { @Override public UserDto getUser(Long id) { return UserDto.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-01-07T14:31:27+08:00">
    <meta property="article:modified_time" content="2024-01-07T14:31:27+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">springboot整合webservice使用总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>        因为做的项目中用到了webservice,所以在此总结一下。</p> 
<h4>        一、webservice简介</h4> 
<p>        Web Service也叫XML Web Service, WebService是一种可以接收从Internet或者Intranet上的其它系统中传递过来的请求，轻量级的独立的通讯技术。是通过SOAP在Web上提供的软件服务，使用WSDL文件进行说明，并通过UDDI进行注册。WebService是一种跨编程语言和跨操作系统平台的远程调用技术。<br>         还可以从多个角度来理解WebService，从表面看，WebService就是一个应用程序向外界暴露出一个能通过Web进行调用的API，也就是说能用编程的方法通过Web来调用这个应用程序。我们把调用这个WebService的应用程序叫做客户端，而把提供这个WebService的应用程序叫做服务端。从深层次看，WebService是建立可互操作的分布式应用程序的新平台，是一个平台，是一套标准。它定义了应用程序如何在Web上实现互操作性，你可以用任何你喜欢的语言，在任何你喜欢的平台上写Web service ，只要我们可以通过Web service标准对这些服务进行查询和访问。</p> 
<p></p> 
<h4>        二、webservice三要素：</h4> 
<p>        SOAP、WSDL、UDDI（UniversalDescriptionDiscovery andIntegration）三者构成了WebService的三要素。下面详细阐述这三大技术：</p> 
<p><strong>SOAP：</strong></p> 
<p>WebService通过HTTP协议发送请求和接收结果时，发送的请求内容和结果内容都采用XML格式封装，并增加了一些特定的HTTP消息头，以说明HTTP消息的内容格式，这些特定的HTTP消息头和XML内容格式就是SOAP协议。SOAP提供了标准的RPC(远程调用技术)方法来调用Web Service。</p> 
<p>SOAP协议组成：</p> 
<p>SOAP协议 = HTTP协议 + XML数据格式</p> 
<p>SOAP协议定义了SOAP消息的格式，SOAP协议是基于HTTP协议的，SOAP也是基于XML的，XML是SOAP的数据编码方式。</p> 
<p></p> 
<p><strong>WSDL</strong></p> 
<p>好比我们去商店买东西，首先要知道商店里有什么东西可买，然后再来购买，商家的做法就是张贴广告海报。 WebService也一样，WebService客户端要调用一个WebService服务，首先要有知道这个服务的地址在哪，以及这个服务里有什么方法可以调用，所以，WebService务器端首先要通过一个WSDL文件来说明自己家里有啥服务可以对外调用，服务是什么（服务中有哪些方法，方法接受的参数是什么，返回值是什么），服务的网络地址用哪个url地址表示，服务通过什么方式来调用。</p> 
<p><strong>WSDL(</strong>Web Services Description Language)就是这样一个基于XML的语言，用于描述Web Service及其函数、参数和返回值。它是WebService客户端和服务器端都能理解的标准格式。因为是基于XML的，所以WSDL既是机器可阅读的，又是人可阅读的，这将是一个很大的好处。一些最新的开发工具既能根据你的Web service生成WSDL文档，又能导入WSDL文档，生成调用相应WebService的代理类代码。</p> 
<p></p> 
<p><strong>UDDI</strong></p> 
<p>uddi是一个跨产业，跨平台的开放性架构，可以帮助 Web 服务提供商在互联网上发布 Web 服务的信息。UDDI 是一种目录服务，企业可以通过 UDDI 来注册和搜索 Web 服务。简单来说，UDDI 就是一个目录，只不过在这个目录中存放的是一些关于 Web 服务的信息而已。</p> 
<p></p> 
<p>也就是说：<br>         soap：就是在与webservice通信时规定好的协议<br>         wsdl：就是webservice中的食谱，你可以找到webservice中有哪些材料（方法），怎去做这道菜（入参、方法、返回值）等<br>         uddi：wsdl是食谱的话，uddi就是菜单，可以用来注册和搜索web服务。</p> 
<p></p> 
<h4>三、为什么要使用WebService</h4> 
<ol><li>跨平台调用</li><li>跨语言调用</li><li>远程调用</li></ol> 
<p></p> 
<h4>四、springboot简单调用案例</h4> 
<h5>1、引入依赖：</h5> 
<pre><code class="language-XML">&lt;!-- CXF webservice --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;
    &lt;artifactId&gt;cxf-spring-boot-starter-jaxws&lt;/artifactId&gt;
    &lt;version&gt;3.4.5&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<h5>2、创建实体类：</h5> 
<pre><code class="language-java">@Data
@Builder
public class UserDto {
    private Long id;
    private String name;
    private Integer age;
    private String address;
}</code></pre> 
<h5>3、创建WebService接口</h5> 
<pre><code class="language-java">public interface IUserServer {
     UserDto getUser(Long str)；
}</code></pre> 
<h5>4、创建WebService接口的实现类</h5> 
<pre><code class="language-java">@Service
@WebService
public class UserServerImpl implements IUserServer {

    @Override
    public UserDto getUser(Long id) {
        return UserDto.builder()
                .id(id)
                .address("上海市浦东新区")
                .age(25)
                .name("laJi").build();
    }
}</code></pre> 
<p></p> 
<p>这里用到了注解@WebService，我这就只在实现类上使用了。这里介绍一下，先来看下它的定义：</p> 
<pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE})
public @interface WebService {
    String name() default "";

    String targetNamespace() default "";

    String serviceName() default "";

    String portName() default "";

    String wsdlLocation() default "";

    String endpointInterface() default "";
}</code></pre> 
<blockquote> 
 <p>name: 对应wsdl:portType标签，默认值为Java类或接口的名称；<br> targetNamespace: 命名空间，一般写为接口的包名倒序，默认值也是接口的包名倒序。对应wsd:definitions:targetNamespace 标签；<br> serviceName: WebService的服务名称，对应wsdl:service，默认值为WebService接口实现类的名称+“Service”，示例：UserServiceImplServicce<br> portName: 对应wsdl:port标签，默认值为:WebService接口实现类的名称+“Port”，示例：UserServiceImplPort<br> wsdlLocation: 指定用于定义WebService的WSDL文档的地址<br> endpoointInterfacce: WebService接口全路径</p> 
</blockquote> 
<h5>5、创建WebService配置类</h5> 
<pre><code class="language-java">@Configuration
@RequiredArgsConstructor
public class CxfConfig {
    private final IUserServer userServer;

    /**
     * 注入Servlet，注意beanName不能为dispatcherServlet
     * @author Fang Ruichuan
     * @date 2022/11/14 19:16
     */
    @Bean
    public ServletRegistrationBean cxfServlet() {
        return new ServletRegistrationBean(new CXFServlet(), "/webservice/*");
    }

    @Bean(name = Bus.DEFAULT_BUS_ID)
    public SpringBus springBus() {
        return new SpringBus();
    }

    @Bean
    public Endpoint endpoint() {
        EndpointImpl endpoint = new EndpointImpl(springBus(), userServer);
        endpoint.publish("/api");
        return endpoint;
    }
}</code></pre> 
<p>进行访问：http://localhost:8080/webservice<br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/56/2c/21JHqgNL_o.png"><br> 然后点击url<br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/e4/a2/aJdNafZo_o.png"></p> 
<p>客户端：</p> 
<pre><code class="language-java">public class WebserviceClient {
    public static void main(String[] args) {
        JaxWsDynamicClientFactory dcf = JaxWsDynamicClientFactory.newInstance();
        Client client = dcf.createClient("http://localhost:8080/webservice/api?wsdl");
        final ObjectMapper mapper = new ObjectMapper();
        try {
            Object[] objects = client.invoke("getUser", 99L);
            System.out.println(mapper.writeValueAsString(objects[0]));
        } catch (Exception e) {
            e.printStackTrace();;
        }
    }
}</code></pre> 
<p>显示：</p> 
<pre><code class="language-java">{"address":"上海市浦东新区","age":25,"id":99,"name":"laJi"}</code></pre> 
<p></p> 
<p></p> 
<h4>五、进阶使用：</h4> 
<p>        webservice的服务端是以远程接口为主的，在java实现的webService主要是依靠的是CXF开发框架，而这个CXF框架可以直接将接口发布成webservice，同时还要考虑到整个项目之中的安全性问题。</p> 
<h5>相关注解：</h5> 
<h6>1)@WebService</h6> 
<p>        1、serviceName： 对外发布的服务名，指定 Web Service 的服务名称：wsdl:service。缺省值为 Java 类的简单名称 + Service。（字符串）<br>         2、endpointInterface： 服务接口全路径, 指定做SEI（Service EndPoint Interface）服务端点接口，包名+实现类的接口的完整路径<br>         3、name：此属性的值包含XML Web Service的名称。在默认情况下，该值是实现XML Web Service的类的名称，wsdl:portType 的名称。缺省值为 Java 类的简单名称 + Service。（字符串）<br>         4、portName：  wsdl:portName。缺省值为 WebService.name+Port。<br>         5、targetNamespace：指定你想要的名称空间，默认是使用接口实现类的包名的反缀<br>         6、wsdlLocation：指定用于定义 Web Service 的 WSDL 文档的 Web 地址。Web 地址可以是相对路径或绝对路径。（字符串）</p> 
<p>    注意：实现类上可以不添加Webservice注解  </p> 
<p></p> 
<h6>2)@WebMethod</h6> 
<p>    注释表示作为一项 Web Service 操作的方法，将此注释应用于客户机或服务器服务端点接口（SEI）上的方法，或者应用于 JavaBeans 端点的服务器端点实现类。</p> 
<p>    要点： 仅支持在使用 @WebService 注释来注释的类上使用 @WebMethod 注释<br>         1、operationName：指定与此方法相匹配的wsdl:operation 的名称。缺省值为 Java 方法的名称。（字符串）<br>         2、action：定义此操作的行为。对于 SOAP 绑定，此值将确定 SOAPAction 头的值。缺省值为 Java 方法的名称。（字符串）<br>         3、exclude：指定是否从 Web Service 中排除某一方法。缺省值为 false。（布尔值）  </p> 
<p></p> 
<h6>3)@Oneway </h6> 
<p>        注释将一个方法表示为只有输入消息而没有输出消息的 Web Service 单向操作。<br>         将此注释应用于客户机或服务器服务端点接口（SEI）上的方法，或者应用于 JavaBeans 端点的服务器端点实现类  </p> 
<p></p> 
<h6>4)@WebParam </h6> 
<p>        注释用于定制从单个参数至 Web Service 消息部件和 XML 元素的映射。<br>         将此注释应用于客户机或服务器服务端点接口（SEI）上的方法，或者应用于 JavaBeans 端点的服务器端点实现类。<br>         1、name ：参数的名称。如果操作是远程过程调用（RPC）类型并且未指定partName 属性，那么这是用于表示参数的 wsdl:part 属性的名称。如果操作是文档类型或者参数映射至某个头，那么 -name 是用于表示该参数的 XML 元素的局部名称。如果操作是文档类型、参数类型为 BARE 并且方式为 OUT 或 INOUT，那么必须指定此属性。（字符串）   <br>         2、partName：定义用于表示此参数的 wsdl:part属性的名称。仅当操作类型为 RPC 或者操作是文档类型并且参数类型为BARE 时才使用此参数。（字符串）<br>         3、targetNamespace：指定参数的 XML 元素的 XML 名称空间。当属性映射至 XML 元素时，仅应用于文档绑定。缺省值为 Web Service 的targetNamespace。（字符串）<br>         4、mode：此值表示此方法的参数流的方向。有效值为 IN、INOUT 和 OUT。（字符串）<br>         5、header：指定参数是在消息头还是消息体中。缺省值为 false。（布尔值）</p> 
<p></p> 
<h6>5)@WebResult </h6> 
<p>        注释用于定制从返回值至 WSDL 部件或 XML 元素的映射。将此注释应用于客户机或服务器服务端点接口（SEI）上的方法，或者应用于 JavaBeans 端点的服务器端点实现类。<br>         1、name：当返回值列示在 WSDL 文件中并且在连接上的消息中找到该返回值时，指定该返回值的名称。对于 RPC 绑定，这是用于表示返回值的 wsdl:part属性的名称。对于文档绑定，-name参数是用于表示返回值的 XML 元素的局部名。对于 RPC 和 DOCUMENT/WRAPPED 绑定，缺省值为 return。对于 DOCUMENT/BARE 绑定，缺省值为方法名 + Response。（字符串）<br>         2、targetNamespace：指定返回值的 XML 名称空间。仅当操作类型为 RPC 或者操作是文档类型并且参数类型为 BARE 时才使用此参数。（字符串） <br>         3、header：指定头中是否附带结果。缺省值为false。（布尔值）<br>         4、partName：指定 RPC 或 DOCUMENT/BARE 操作的结果的部件名称。缺省值为@WebResult.name。（字符串）</p> 
<h6>6)@HandlerChain</h6> 
<p>         注释用于使 Web Service 与外部定义的处理程序链相关联。只能通过对 SEI 或实现类使用 @HandlerChain 注释来配置服务器端的处理程序。<br>         但是可以使用多种方法来配置客户端的处理程序。可以通过对生成的服务类或者 SEI 使用 @HandlerChain 注释来配置客户端的处理程序。此外，可以按程序在服务上注册您自己的 HandlerResolver 接口实现，或者按程序在绑定对象上设置处理程序链。<br>         1、file：指定处理程序链文件所在的位置。文件位置可以是采用外部格式的绝对 java.net.URL，也可以是类文件中的相对路径。（字符串）<br>         2、name：指定配置文件中处理程序链的名称。</p> 
<p></p> 
<blockquote> 
 <pre>/**
 * WebService涉及到的有这些 "四解三类 ", 即四个注解，三个类
 * @WebMethod
 * @WebService
 * @WebResult
 * @WebParam
 * SpringBus
 * Endpoint
 * EndpointImpl
 *
 * 一般我们都会写一个接口，然后再写一个实现接口的实现类，但是这不是强制性的
 * @WebService 注解表明是一个webservice服务。
 *      name：对外发布的服务名, 对应于&lt;wsdl:portType name="ServerServiceDemo"&gt;&lt;/wsdl:portType&gt;
 *      targetNamespace：命名空间,一般是接口的包名倒序, 实现类与接口类的这个配置一定要一致这种错误
 *              Exception in thread "main" org.apache.cxf.common.i18n.UncheckedException: No operation was found with the name xxxx
 *              对应于targetNamespace="http://server.webservice.example.com"
 *      endpointInterface：服务接口全路径（如果是没有接口，直接写实现类的，该属性不用配置）, 指定做SEI（Service EndPoint Interface）服务端点接口
 *      serviceName：对应于&lt;wsdl:service name="ServerServiceDemoImplService"&gt;&lt;/wsdl:service&gt;
 *      portName：对应于&lt;wsdl:port binding="tns:ServerServiceDemoImplServiceSoapBinding" name="ServerServiceDemoPort"&gt;&lt;/wsdl:port&gt;
 *
 * @WebMethod 表示暴露的服务方法, 这里有接口ServerServiceDemo存在，在接口方法已加上@WebMethod, 所以在实现类中不用再加上，否则就要加上
 *      operationName: 接口的方法名
 *      action: 没发现又什么用处
 *      exclude: 默认是false, 用于阻止将某一继承方法公开为web服务
 *
 * @WebResult 表示方法的返回值
 *      name：返回值的名称
 *      partName：
 *      targetNamespace:
 *      header: 默认是false, 是否将参数放到头信息中，用于保护参数，默认在body中
 *
 * @WebParam
 *       name：接口的参数
 *       partName：
 *       targetNamespace:
 *       header: 默认是false, 是否将参数放到头信息中，用于保护参数，默认在body中
 *       model：WebParam.Mode.IN/OUT/INOUT
 */</pre> 
</blockquote> 
<p></p> 
<h5>使用步骤：</h5> 
<h6>        1）创建接口：</h6> 
<pre><code class="language-java">@WebService(name = "UserSSSS" ,targetNamespace ="http://data.fucker.mother.com")
public interface UserService {
        
        User getUser(String userName);
}</code></pre> 
<h6>        2)创建实现类：</h6> 
<pre><code class="language-java">@Service
@WebService(name = "UserSSSS" ,
            targetNamespace ="http://data.fucker.mother.com",
            endpointInterface = "com.mother.fucker.data.service.UserService")
public class UserServerImpl implements UserService {
    
    @Override
    @WebMethod(operationName = "getUser")
    @WebResult(name = "User")
    public User getUser(@WebParam(name = "userName") String userName) {
        return new User("姓名","年龄","性别","工作");
    }
}</code></pre> 
<h6>        3）创建身份认证拦截器：（不需要可以不创建）</h6> 
<pre><code class="language-java">import lombok.extern.slf4j.Slf4j;
import org.apache.cxf.binding.soap.SoapMessage;
import org.apache.cxf.binding.soap.saaj.SAAJInInterceptor;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.phase.AbstractPhaseInterceptor;
import org.apache.cxf.phase.Phase;
import org.springframework.stereotype.Component;
import org.w3c.dom.NodeList;

import javax.xml.soap.SOAPException;
import javax.xml.soap.SOAPHeader;
import javax.xml.soap.SOAPMessage;

@Component
@Slf4j
public class WebServiceAuthInterceptor extends AbstractPhaseInterceptor&lt;SoapMessage&gt; {

    /**
     * 用户名
     */
    private static final String USER_NAME = "wangdi";
    /**
     * 密码
     */
    private static final String USER_PASSWORD = "wangdi.com";
    private static final String NAME_SPACE_URI = "http://data.fucker.mother.com";
    /**
     * 创建拦截器
     */
    private SAAJInInterceptor interceptor = new SAAJInInterceptor();

    public WebServiceAuthInterceptor() {
        super(Phase.PRE_PROTOCOL);
        //添加拦截
        super.getAfter().add(SAAJInInterceptor.class.getName());
    }

    @Override
    public void handleMessage(SoapMessage message) throws Fault {
        //获取指定消息
        SOAPMessage soapMessage = message.getContent(SOAPMessage.class);
        if (null == soapMessage) {
            this.interceptor.handleMessage(message);
            soapMessage = message.getContent(SOAPMessage.class);
        }
        //SOAP头信息
        SOAPHeader header = null;
        try {
            header = soapMessage.getSOAPHeader();
        } catch (SOAPException e) {
            e.printStackTrace();
        }
        if (null == header) {
            throw new Fault(new IllegalAccessException("没有Header信息，无法实现用户认证处理!"));
        }
        //SOAP是基于XML文件结构进行传输的，所以如果要想获取认证信息就必须进行相关的结构约定
        NodeList usernameNodeList = header.getElementsByTagNameNS(NAME_SPACE_URI, "username");
        NodeList passwordNodeList = header.getElementsByTagNameNS(NAME_SPACE_URI, "password");
        if (usernameNodeList.getLength() &lt; 1) {
            throw new Fault(new IllegalAccessException("没有用户信息，无法实现用户认证处理!"));
        }
        if (passwordNodeList.getLength() &lt; 1) {
            throw new Fault(new IllegalAccessException("没有密码信息，无法实现用户认证处理!"));
        }
        String username = usernameNodeList.item(0).getTextContent().trim();
        String password = passwordNodeList.item(0).getTextContent().trim();
        if (USER_NAME.equals(username) &amp;&amp; USER_PASSWORD.equals(password)) {
            log.info("用户访问认证成功!");
        } else {
            SOAPException soapException = new SOAPException("用户认证失败!");
            log.info("用户认证失败!");
            throw new Fault(soapException);
        }
    }
}
</code></pre> 
<h6>        4)创建配置类：</h6> 
<pre><code class="language-java">import com.mother.fucker.data.AuthInterceptor.WebServiceAuthInterceptor;
import com.mother.fucker.data.service.UserService;
import lombok.RequiredArgsConstructor;
import org.apache.cxf.Bus;
import org.apache.cxf.bus.spring.SpringBus;
import org.apache.cxf.jaxws.EndpointImpl;
import org.apache.cxf.transport.servlet.CXFServlet;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.web.servlet.ServletRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.xml.ws.Endpoint;

@Configuration
@RequiredArgsConstructor
public class CxfConfig {
    private final UserService userServer;

    @Autowired
    private WebServiceAuthInterceptor interceptor;
    /**
     * 注入Servlet，注意beanName不能为dispatcherServlet
     * @author Fang Ruichuan
     * @date 2022/11/14 19:16
     */
    @Bean
    public ServletRegistrationBean cxfServlet() {
        return new ServletRegistrationBean(new CXFServlet(), "/webservice/*");
    }

    @Bean(name = Bus.DEFAULT_BUS_ID)
    public SpringBus springBus() {
        return new SpringBus();
    }

    @Bean
    public Endpoint endpoint() {
        EndpointImpl endpoint = new EndpointImpl(springBus(), userServer);
        endpoint.publish("/api");
        endpoint.getInInterceptors().add(this.interceptor);
        return endpoint;
    }

    /*用于发布多个WebService*/
//    @Bean
//    public Endpoint messageEndPoint2() {
//        EndpointImpl endpoint = new EndpointImpl(springBus(), this.ageInfoService);
//        endpoint.publish("/userInfoService");
        endpoint.getInInterceptors().add(this.interceptor);
//        return endpoint;
//    }

}</code></pre> 
<h6>5)创建客户端拦截器：<strong>(如有需要)</strong></h6> 
<pre><code class="language-java">import org.apache.cxf.binding.soap.SoapMessage;
import org.apache.cxf.helpers.DOMUtils;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.phase.AbstractPhaseInterceptor;
import org.apache.cxf.phase.Phase;
import org.apache.cxf.headers.Header;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import javax.xml.namespace.QName;
import java.util.List;


public class ClientLoginInterceptor extends AbstractPhaseInterceptor&lt;SoapMessage&gt; {

    private String username;
    private String password;
    private static final String NAME_SPACE_URI = "http://data.fucker.mother.com";

    public ClientLoginInterceptor(String username, String password) {
        super(Phase.PREPARE_SEND);
        this.username = username;
        this.password = password;
    }

    @Override
    public void handleMessage(SoapMessage soapMessage) throws Fault {
        List&lt;Header&gt; headers = soapMessage.getHeaders();
        Document document = DOMUtils.createDocument();
        Element authority = document.createElementNS(NAME_SPACE_URI, "authority");
        Element username = document.createElementNS(NAME_SPACE_URI, "username");
        Element password = document.createElementNS(NAME_SPACE_URI, "password");
        username.setTextContent(this.username);
        password.setTextContent(this.password);
        authority.appendChild(username);
        authority.appendChild(password);
        headers.add(0, new Header(new QName("authority"), authority));
    }
}</code></pre> 
<h6>6) 新建客户端调用接口（使用动态代理）</h6> 
<pre><code class="language-java">    /**
     * 用户名
     */
    private static final String USER_NAME = "wangdi";
    /**
     * 密码
     */
    private static final String USER_PASSWORD = "wangdi.com";
    private static final String NAME_SPACE_URI = "http://server.webservice.gtp.sinotrans.com";


    public static void main(String[] args) {
        
        //打印日志
        LoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory();
        List&lt;Logger&gt; loggerList = loggerContext.getLoggerList();
        loggerList.forEach(logger -&gt; {logger.setLevel(Level.INFO);    });


        JaxWsDynamicClientFactory dcf = JaxWsDynamicClientFactory.newInstance();
        Client client = dcf.createClient("http://localhost:8001/webservice/api?wsdl");
        try {
            client.getOutInterceptors().add(new ClientLoginInterceptor(USER_NAME, USER_PASSWORD));
            Object[] objects = client.invoke("getUser","aaa");
            System.out.println(JSON.toJSONString(objects[0]));
        } catch (Exception e) {
            e.printStackTrace();;
        }

    }</code></pre> 
<p></p> 
<p> 7）当webservcie中参数是复杂类型的是：</p> 
<pre><code class="language-java">    @Override
    @WebMethod(operationName = "getUser")
    public User getUser(@WebParam(name = "userName") User userName) {
        return new User("姓名","年龄","性别","工作");
    }
</code></pre> 
<p>需要这样调用：</p> 
<pre><code class="language-java">        //打印日志
//        LoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory();
//        List&lt;Logger&gt; loggerList = loggerContext.getLoggerList();
//        loggerList.forEach(logger -&gt; {logger.setLevel(Level.INFO);    });
        
        JaxWsDynamicClientFactory dcf = JaxWsDynamicClientFactory.newInstance();
        Client client = dcf.createClient("http://localhost:1001/webservice/api?wsdl");
        try {

            //通过反射，创建OrderInfo对象，com.limp.service.OrderInfo 这个包名称必须和webservice的中的order路径一致
            Object user = Thread.currentThread().getContextClassLoader().
                    loadClass("com.mother.fucker.data.User").newInstance();

            //初始化实体对象
            Method m = user.getClass().getMethod("setName", String.class);

            m.invoke(user, "uuid213-281heq-2131");

            Object[] objects = client.invoke("getUser",user);
            System.out.println(JSON.toJSONString(objects[0]));
        } catch (Exception e) {
            e.printStackTrace();;
        }</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/63b83870a610eed106ca0bd8661984f5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【卫星定位】GPS/BDS北斗卫星单点定位SPP详解（附Matlab源码）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/92970f3d92a8a0e3eef1d1632a9b554d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">GitHub Copilot 功能介绍和使用场景</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>