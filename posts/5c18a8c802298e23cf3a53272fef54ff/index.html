<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[WebDav] WebDav基础知识 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/5c18a8c802298e23cf3a53272fef54ff/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="[WebDav] WebDav基础知识">
  <meta property="og:description" content="文章目录 什么是WebDavWebDav常用命令WebDav常用命令的测试（代码）PROPFIND 方法测试PUT 方法测试GET 方法测试PROPPATCH方法 WebDav缓存Cache-ControlEtag测试 强制重新验证不需要缓存 WebDav的锁WebDav的状态码WebDav身份验证WebDav版本控制WebDav和FTP的区别参考 什么是WebDav What is WebDAV?
Briefly: WebDAV stands for “Web-based Distributed Authoring and Versioning”. It is a set of extensions to the HTTP protocol which allows users to collaboratively edit and manage files on remote web servers.
WebDAV Resources
WebDav是基于HTTP的协议，他可以允许客户端远程编辑Web内容。
WebDAV的特性和优势
支持创建、修改、复制、移动、移除、查询、列举文件
文件锁
版本控制
支持修改文件属性
安全完善的身份验证机制
支持https加密
支持proxy
客户端缓存
方便的客户端工具：和局域网中的文件共享一样简单使用。
来源：学习WebDav
WebDav常用命令 WebDav在HTTP的基础上扩展了自己的命令，例如：
PROPFIND 用于获取文件夹列表、文件夹内的文件列表、文件夹和文件的属性；
MKCOL 用于创建空文件夹；
PUT 用于上传文件；
GET 用于下载文件；
COPY 用于复制文件；">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-02-20T12:18:57+08:00">
    <meta property="article:modified_time" content="2024-02-20T12:18:57+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[WebDav] WebDav基础知识</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#WebDav_1" rel="nofollow">什么是WebDav</a></li><li><a href="#WebDav_18" rel="nofollow">WebDav常用命令</a></li><li><a href="#WebDav_26" rel="nofollow">WebDav常用命令的测试（代码）</a></li><li><ul><li><a href="#PROPFIND__31" rel="nofollow">PROPFIND 方法测试</a></li><li><a href="#PUT__324" rel="nofollow">PUT 方法测试</a></li><li><a href="#GET__421" rel="nofollow">GET 方法测试</a></li><li><a href="#PROPPATCH_498" rel="nofollow">PROPPATCH方法</a></li></ul> 
  </li><li><a href="#WebDav_628" rel="nofollow">WebDav缓存</a></li><li><ul><li><a href="#CacheControl_634" rel="nofollow">Cache-Control</a></li><li><a href="#Etag_639" rel="nofollow">Etag</a></li><li><ul><li><a href="#_648" rel="nofollow">测试</a></li></ul> 
   </li><li><a href="#_660" rel="nofollow">强制重新验证</a></li><li><a href="#_664" rel="nofollow">不需要缓存</a></li></ul> 
  </li><li><a href="#WebDav_672" rel="nofollow">WebDav的锁</a></li><li><a href="#WebDav_681" rel="nofollow">WebDav的状态码</a></li><li><a href="#WebDav_688" rel="nofollow">WebDav身份验证</a></li><li><a href="#WebDav_690" rel="nofollow">WebDav版本控制</a></li><li><a href="#WebDavFTP_693" rel="nofollow">WebDav和FTP的区别</a></li><li><a href="#_697" rel="nofollow">参考</a></li></ul> 
</div> 
<p></p> 
<h2><a id="WebDav_1"></a>什么是WebDav</h2> 
<blockquote> 
 <p>What is WebDAV?<br> Briefly: WebDAV stands for “Web-based Distributed Authoring and Versioning”. It is a set of extensions to the HTTP protocol which allows users to collaboratively edit and manage files on remote web servers.<br> <a rel="nofollow">WebDAV Resources</a></p> 
</blockquote> 
<p>WebDav是基于HTTP的协议，他可以允许客户端远程编辑Web内容。</p> 
<blockquote> 
 <p>WebDAV的特性和优势<br> 支持创建、修改、复制、移动、移除、查询、列举文件<br> 文件锁<br> 版本控制<br> 支持修改文件属性<br> 安全完善的身份验证机制<br> 支持https加密<br> 支持proxy<br> 客户端缓存<br> 方便的客户端工具：和局域网中的文件共享一样简单使用。<br> 来源：<a href="https://blog.csdn.net/janbar/article/details/120512616">学习WebDav</a></p> 
</blockquote> 
<h2><a id="WebDav_18"></a>WebDav常用命令</h2> 
<p>WebDav在HTTP的基础上扩展了自己的命令，例如：<br> PROPFIND 用于获取文件夹列表、文件夹内的文件列表、文件夹和文件的属性；<br> MKCOL 用于创建空文件夹；<br> PUT 用于上传文件；<br> GET 用于下载文件；<br> COPY 用于复制文件；<br> MOVE 用于移动文件；</p> 
<h2><a id="WebDav_26"></a>WebDav常用命令的测试（代码）</h2> 
<p>我在坚果云网盘中，创建了几个文件夹，上传了几个文件。并按照<a rel="nofollow">如何在Zotero中设置webdav连接到坚果云？</a>进行了网盘的WebDav服务配置，生成了WebDav密码。<br> <img src="https://images2.imgbox.com/d8/70/64YvpY5a_o.png" alt="在这里插入图片描述"><br> 根据<a href="https://blog.csdn.net/janbar/article/details/120512616">学习WebDav</a> ，直接在windows cmd使用curl命令就可以一定程度测试WebDav，我这里是在VS 2022中，通过libcurl库，向坚果云发送请求。<br> 关于VS中如何导入libcurl库，可以看<a href="https://blog.csdn.net/zlllc/article/details/135104389">[libcurl] windows visual studio 导入libcurl库</a>。</p> 
<h3><a id="PROPFIND__31"></a>PROPFIND 方法测试</h3> 
<p>代码：</p> 
<pre><code>#include &lt;curl/curl.h&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;

using std::cout;
using std::endl;
using std::ios;

#define ERROR(X) (cout &lt;&lt; __FUNCDNAME__ &lt;&lt;  " " &lt;&lt; (X) &lt;&lt; " " &lt;&lt; "error" &lt;&lt; endl, -1)
#define ERROR2(X,Y) (cout &lt;&lt; __FUNCDNAME__ &lt;&lt;  " " &lt;&lt; (X) &lt;&lt; " " &lt;&lt; (Y) &lt;&lt; " " &lt;&lt; "error" &lt;&lt; endl, -1)

#if 1 // WebDav
size_t write_callback(char* ptr, size_t size, size_t nmemb, void* userdata);
int My_PROPFIND();
FILE* fp;

int main()
{
	//打开一个文件，用于输出WebDav响应
	char filename[256];
	sprintf_s(filename, 256, "%s.%s", "WebDav-Test", "xml");
	errno_t err = fopen_s(&amp;fp, filename, "wb");
	if (err)
		return ERROR2("fopen_s", err);

	//初始化curl
	curl_global_init(CURL_GLOBAL_WIN32);

	//WebDav请求函数
	My_PROPFIND();

	curl_global_cleanup();
	cout &lt;&lt; "program end." &lt;&lt; endl;
}

int My_PROPFIND()
{
	const char* host = "https://dav.jianguoyun.com";
	const char* url = "https://dav.jianguoyun.com/dav/box1";
	
	CURL* curl = curl_easy_init();
	if (curl) {
		//设置HTTP头		
		curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "PROPFIND"); //修改HTTP方法
		curl_easy_setopt(curl, CURLOPT_URL, url); //设置URL		
		curl_easy_setopt(curl, CURLOPT_HTTP_VERSION, (long)CURL_HTTP_VERSION_1_1); //指定HTTP版本
		curl_easy_setopt(curl, CURLOPT_USERNAME, "这里隐藏掉邮箱地址@qq.com"); //设置访问WebDav账号和密码
		curl_easy_setopt(curl, CURLOPT_PASSWORD, "axs5pyhc2j6n7q");
		struct curl_slist* list = NULL; //设置HTTP头部字段
		list = curl_slist_append(list, "Connection: close"); //不要长连接
		list = curl_slist_append(list, "Accept: */*");
		curl_easy_setopt(curl, CURLOPT_HTTPHEADER, list);
		

		//指定用于SSL证书验证的证书
		CURLcode err = curl_easy_setopt(curl, CURLOPT_CAINFO, "D:\\SourceCode\\cert\\_.jianguoyun.com.crt");
		if (err != CURLE_OK) {
			cout &lt;&lt; "CURLOPT_CAPATH err:" &lt;&lt; err &lt;&lt; endl;
		}
		//如果不设置，会出现：unable to get local issuer certificate的错误

		//设定HTTP响应的处理方法
		curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
		curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)fp);
		//设定控制台回显调试信息
		curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);

		//执行HTTP请求
		CURLcode ret = curl_easy_perform(curl);
		if (ret != CURLE_OK) {
			curl_easy_cleanup(curl);
			fclose(fp);
			return ERROR2("curl_easy_perform", ret);
		}
	}
	else {
		fclose(fp);
		return ERROR("curl_easy_init");
	}
	fclose(fp);
	curl_easy_cleanup(curl);
	return 0;
}

size_t write_callback(char* ptr, size_t size, size_t nmemb, void* userdata)
{
	int realsize = size * nmemb;
	fwrite(ptr, 1, realsize, fp);
	return realsize;
}
#endif
</code></pre> 
<p>控制台输出：</p> 
<pre><code>* Host dav.jianguoyun.com:443 was resolved.
* IPv6: (none)
* IPv4: 36.155.116.36, 36.155.116.35
*   Trying 36.155.116.36:443...
* Connected to dav.jianguoyun.com (36.155.116.36) port 443
* ALPN: curl offers http/1.1
*  CAfile: D:\SourceCode\cert\_.jianguoyun.com.crt
*  CApath: none
* SSL connection using TLSv1.2 / ECDHE-RSA-AES128-GCM-SHA256 / [blank] / UNDEF
* ALPN: server accepted http/1.1
* Server certificate:
*  subject: CN=*.jianguoyun.com
*  start date: Jan 23 00:00:00 2024 GMT
*  expire date: Feb 19 23:59:59 2025 GMT
*  subjectAltName: host "dav.jianguoyun.com" matched cert's "*.jianguoyun.com"
*  issuer: C=GB; ST=Greater Manchester; L=Salford; O=Sectigo Limited; CN=Sectigo RSA Domain Validation Secure Server CA
*  SSL certificate verify ok.
*   Certificate level 0: Public key type ? (2048/112 Bits/secBits), signed using sha256WithRSAEncryption
* using HTTP/1.x
* Server auth using Basic with user ‘这里隐藏掉邮箱地址@qq.com'
&gt; PROPFIND /dav/box1 HTTP/1.1
Host: dav.jianguoyun.com
Authorization: Basic MjgwMjAzNzEyN这里隐藏掉B5aGMyajZuN3F0eg==
Connection: close
Accept: */*

&lt; HTTP/1.1 207 Multi-Status
&lt; Server: nginx
&lt; Date: Mon, 19 Feb 2024 04:14:58 GMT
&lt; Content-Type: text/xml; charset=UTF-8
&lt; Content-Length: 2882
&lt; Connection: close
&lt; Pragma: no-cache
&lt; Cache-Control: no-cache
&lt;
* Closing connection
program end.
</code></pre> 
<p>可以看到，发出的请求是：</p> 
<pre><code>&gt; PROPFIND /dav/box1 HTTP/1.1
Host: dav.jianguoyun.com
Authorization: Basic MjgwMjAzNzEyN这里隐藏掉B5aGMyajZuN3F0eg==
Connection: close
Accept: */*
</code></pre> 
<p>收到的响应HTTP头是：</p> 
<pre><code>&lt; HTTP/1.1 207 Multi-Status
&lt; Server: nginx
&lt; Date: Mon, 19 Feb 2024 04:14:58 GMT
&lt; Content-Type: text/xml; charset=UTF-8
&lt; Content-Length: 2882
&lt; Connection: close
&lt; Pragma: no-cache
&lt; Cache-Control: no-cache
</code></pre> 
<p>输出到文件中的XML内容是：</p> 
<pre><code>&lt;d:multistatus&gt;
&lt;d:response&gt;
 &lt;d:href&gt;/dav/box1/&lt;/d:href&gt;
&lt;d:propstat&gt;
&lt;d:prop&gt;
 &lt;d:getcontenttype&gt;httpd/unix-directory&lt;/d:getcontenttype&gt;
 &lt;d:displayname&gt;box1&lt;/d:displayname&gt;
 &lt;d:owner&gt;这里隐藏掉邮箱地址@qq.com&lt;/d:owner&gt;
&lt;d:resourcetype&gt;
 &lt;d:collection/&gt;
 &lt;/d:resourcetype&gt;
 &lt;d:getcontentlength&gt;0&lt;/d:getcontentlength&gt;
 &lt;d:getlastmodified&gt;Mon, 19 Feb 2024 04:14:58 GMT&lt;/d:getlastmodified&gt;
&lt;d:current-user-privilege-set&gt;
&lt;d:privilege&gt;
 &lt;d:read/&gt;
 &lt;/d:privilege&gt;
&lt;d:privilege&gt;
 &lt;d:write/&gt;
 &lt;/d:privilege&gt;
&lt;d:privilege&gt;
 &lt;d:all/&gt;
 &lt;/d:privilege&gt;
&lt;d:privilege&gt;
 &lt;d:read_acl/&gt;
 &lt;/d:privilege&gt;
&lt;d:privilege&gt;
 &lt;d:write_acl/&gt;
 &lt;/d:privilege&gt;
 &lt;/d:current-user-privilege-set&gt;
 &lt;/d:prop&gt;
 &lt;d:status&gt;HTTP/1.1 200 OK&lt;/d:status&gt;
 &lt;/d:propstat&gt;
 &lt;/d:response&gt;
&lt;d:response&gt;
 &lt;d:href&gt;/dav/box1/WeatherWS.xml&lt;/d:href&gt;
&lt;d:propstat&gt;
&lt;d:prop&gt;
 &lt;d:getetag&gt;UsZ7ybf73r39UXEEPQs5qA&lt;/d:getetag&gt;
 &lt;d:getcontenttype&gt;text/xml&lt;/d:getcontenttype&gt;
 &lt;d:displayname&gt;WeatherWS.xml&lt;/d:displayname&gt;
 &lt;d:owner&gt;这里隐藏掉邮箱地址@qq.com&lt;/d:owner&gt;
 &lt;d:getcontentlength&gt;29712&lt;/d:getcontentlength&gt;
 &lt;d:getlastmodified&gt;Fri, 29 Dec 2023 09:02:10 GMT&lt;/d:getlastmodified&gt;
 &lt;d:resourcetype/&gt;
&lt;d:current-user-privilege-set&gt;
&lt;d:privilege&gt;
 &lt;d:read/&gt;
 &lt;/d:privilege&gt;
&lt;d:privilege&gt;
 &lt;d:write/&gt;
 &lt;/d:privilege&gt;
&lt;d:privilege&gt;
 &lt;d:all/&gt;
 &lt;/d:privilege&gt;
&lt;d:privilege&gt;
 &lt;d:read_acl/&gt;
 &lt;/d:privilege&gt;
&lt;d:privilege&gt;
 &lt;d:write_acl/&gt;
 &lt;/d:privilege&gt;
 &lt;/d:current-user-privilege-set&gt;
 &lt;/d:prop&gt;
 &lt;d:status&gt;HTTP/1.1 200 OK&lt;/d:status&gt;
 &lt;/d:propstat&gt;
 &lt;/d:response&gt;
&lt;d:response&gt;
 &lt;d:href&gt;/dav/box1/box1_1&lt;/d:href&gt;
&lt;d:propstat&gt;
&lt;d:prop&gt;
 &lt;d:getetag/&gt;
 &lt;d:getcontenttype&gt;httpd/unix-directory&lt;/d:getcontenttype&gt;
 &lt;d:displayname&gt;box1_1&lt;/d:displayname&gt;
 &lt;d:owner&gt;这里隐藏掉邮箱地址@qq.com&lt;/d:owner&gt;
 &lt;d:getcontentlength&gt;0&lt;/d:getcontentlength&gt;
 &lt;d:getlastmodified&gt;Tue, 13 Feb 2024 04:29:51 GMT&lt;/d:getlastmodified&gt;
&lt;d:resourcetype&gt;
 &lt;d:collection/&gt;
 &lt;/d:resourcetype&gt;
&lt;d:current-user-privilege-set&gt;
&lt;d:privilege&gt;
 &lt;d:read/&gt;
 &lt;/d:privilege&gt;
&lt;d:privilege&gt;
 &lt;d:write/&gt;
 &lt;/d:privilege&gt;
&lt;d:privilege&gt;
 &lt;d:all/&gt;
 &lt;/d:privilege&gt;
&lt;d:privilege&gt;
 &lt;d:read_acl/&gt;
 &lt;/d:privilege&gt;
&lt;d:privilege&gt;
 &lt;d:write_acl/&gt;
 &lt;/d:privilege&gt;
 &lt;/d:current-user-privilege-set&gt;
 &lt;/d:prop&gt;
 &lt;d:status&gt;HTTP/1.1 200 OK&lt;/d:status&gt;
 &lt;/d:propstat&gt;
 &lt;/d:response&gt;
&lt;d:response&gt;
 &lt;d:href&gt;/dav/box1/box1file.pdf&lt;/d:href&gt;
&lt;d:propstat&gt;
&lt;d:prop&gt;
 &lt;d:getetag&gt;rlLyz4SUXar-UNmip-F5Qw&lt;/d:getetag&gt;
 &lt;d:getcontenttype&gt;application/pdf&lt;/d:getcontenttype&gt;
 &lt;d:displayname&gt;box1file.pdf&lt;/d:displayname&gt;
 &lt;d:owner&gt;这里隐藏掉邮箱地址@qq.com&lt;/d:owner&gt;
 &lt;d:getcontentlength&gt;2422816&lt;/d:getcontentlength&gt;
 &lt;d:getlastmodified&gt;Wed, 15 Nov 2023 08:43:08 GMT&lt;/d:getlastmodified&gt;
 &lt;d:resourcetype/&gt;
&lt;d:current-user-privilege-set&gt;
&lt;d:privilege&gt;
 &lt;d:read/&gt;
 &lt;/d:privilege&gt;
&lt;d:privilege&gt;
 &lt;d:write/&gt;
 &lt;/d:privilege&gt;
&lt;d:privilege&gt;
 &lt;d:all/&gt;
 &lt;/d:privilege&gt;
&lt;d:privilege&gt;
 &lt;d:read_acl/&gt;
 &lt;/d:privilege&gt;
&lt;d:privilege&gt;
 &lt;d:write_acl/&gt;
 &lt;/d:privilege&gt;
 &lt;/d:current-user-privilege-set&gt;
 &lt;/d:prop&gt;
 &lt;d:status&gt;HTTP/1.1 200 OK&lt;/d:status&gt;
 &lt;/d:propstat&gt;
 &lt;/d:response&gt;
 &lt;/d:multistatus&gt;
</code></pre> 
<p>我对Dav中的box1文件夹发送了PROPDIND请求，在响应回来的XML内容中，列出了box1中的每个文件夹和文件（包括box1自己）。每个&lt;d:response&gt;节点都包含了一个文件夹或者文件，&lt;d:response&gt;节点，是文件夹或者文件的属性信息。</p> 
<h3><a id="PUT__324"></a>PUT 方法测试</h3> 
<p>只保留方法部分，其余代码省略。</p> 
<pre><code>int My_PUT()
{
	//这里需要指明需要在Dav上创建的文件的路径“box1”和名字“Upload_test.txt”
	const char* url = "https://dav.jianguoyun.com/dav/box1/Upload_test.txt";
	CURL* curl = curl_easy_init();
	if (curl) {		
		//设置HTTP头		
		curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "PUT"); //修改HTTP方法
		curl_easy_setopt(curl, CURLOPT_URL, url); //设置URL		
		curl_easy_setopt(curl, CURLOPT_HTTP_VERSION, (long)CURL_HTTP_VERSION_1_1); //指定HTTP版本
		curl_easy_setopt(curl, CURLOPT_USERNAME, "2xxxxxxxx4@qq.com"); //设置访问WebDav账号和密码
		curl_easy_setopt(curl, CURLOPT_PASSWORD, "axs5pyhc2j6n7q");
		struct curl_slist* list = NULL; //设置HTTP头部字段
		list = curl_slist_append(list, "Connection: close"); //不要长连接
		list = curl_slist_append(list, "Accept: */*");
		curl_easy_setopt(curl, CURLOPT_HTTPHEADER, list);

		//设置要上传的文件信息
		//打开文件
		curl_off_t fsize = 0;
		FILE* src = nullptr;
		errno_t ferr = fopen_s(&amp;src, "D:\\SourceCode\\TransFILE1.txt", "rb");
		if (ferr)
			return -1;
		//获取文件大小
		fseek(src, 0, SEEK_END);	
		fsize = ftell(src);
		fseek(src, 0, SEEK_SET);
		curl_easy_setopt(curl, CURLOPT_READFUNCTION, read_cb); //设置读取文件的回调函数
		curl_easy_setopt(curl, CURLOPT_UPLOAD, 1L); //启动Upload服务
		curl_easy_setopt(curl, CURLOPT_READDATA, src);//设置传入回调函数的文件句柄
		curl_easy_setopt(curl, CURLOPT_INFILESIZE_LARGE, (curl_off_t)fsize);//设置文件大小

		//指定用于SSL证书验证的证书
		CURLcode err = curl_easy_setopt(curl, CURLOPT_CAINFO, "D:\\SourceCode\\cert\\_.jianguoyun.com.crt");
		if (err != CURLE_OK) {
			cout &lt;&lt; "CURLOPT_CAPATH err:" &lt;&lt; err &lt;&lt; endl;
		}
		//如果不设置，会出现：unable to get local issuer certificate的错误

		//设定HTTP响应的处理方法
		curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
		curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)fp);
		//设定控制台回显调试信息
		curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);

		//执行HTTP请求
		CURLcode ret = curl_easy_perform(curl);
		if (ret != CURLE_OK) {
			curl_easy_cleanup(curl);
			fclose(fp);
			return ERROR2("curl_easy_perform", ret);
		}
	}
	else {
		fclose(fp);
		return ERROR("curl_easy_init");
	}
	fclose(fp);
	curl_easy_cleanup(curl);
	return 0;
}
static size_t read_cb(char* ptr, size_t size, size_t nmemb, void* userdata)
{
	FILE* src = (FILE*)userdata;
	/* copy as much data as possible into the 'ptr' buffer, but no more than
	   'size' * 'nmemb' bytes */
	size_t retcode = fread(ptr, size, nmemb, src);

	return retcode;
}
</code></pre> 
<p>控制台回显信息（部分）：</p> 
<pre><code>&gt; PUT /dav/box1/Upload_test.txt HTTP/1.1
Host: dav.jianguoyun.com
Authorization: Basic MjgwMjAzNzEyNEB---------------aGMyajZuN3F0eg==
Connection: close
Accept: */*
Content-Length: 1844

* We are completely uploaded and fine
&lt; HTTP/1.1 204 No Content
&lt; Server: nginx
&lt; Date: Mon, 19 Feb 2024 05:59:17 GMT
&lt; Connection: close
&lt; X-File-Version: 3
&lt; Pragma: no-cache
&lt; Cache-Control: no-cache
&lt;
* Closing connection
</code></pre> 
<p>WebDav查看：<br> <img src="https://images2.imgbox.com/d8/e8/hOOi16Eg_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="GET__421"></a>GET 方法测试</h3> 
<pre><code>int My_GET()
{
	const char* url = "https://dav.jianguoyun.com/dav/box1/Upload_test.txt";

	CURL* curl = curl_easy_init();
	if (curl) {
		//设置HTTP头		
		curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "GET"); //修改HTTP方法
		curl_easy_setopt(curl, CURLOPT_URL, url); //设置URL		
		curl_easy_setopt(curl, CURLOPT_HTTP_VERSION, (long)CURL_HTTP_VERSION_1_1); //指定HTTP版本
		curl_easy_setopt(curl, CURLOPT_USERNAME, "2--------4@qq.com"); //设置访问WebDav账号和密码
		curl_easy_setopt(curl, CURLOPT_PASSWORD, "axs5pyhc2j6n7q");
		struct curl_slist* list = NULL; //设置HTTP头部字段
		list = curl_slist_append(list, "Connection: close"); //不要长连接
		list = curl_slist_append(list, "Accept: */*");
		curl_easy_setopt(curl, CURLOPT_HTTPHEADER, list);

		//指定用于SSL证书验证的证书
		CURLcode err = curl_easy_setopt(curl, CURLOPT_CAINFO, "D:\\SourceCode\\cert\\_.jianguoyun.com.crt");
		if (err != CURLE_OK) {
			cout &lt;&lt; "CURLOPT_CAPATH err:" &lt;&lt; err &lt;&lt; endl;
		}
		//如果不设置，会出现：unable to get local issuer certificate的错误

		//设定HTTP响应的处理方法
		curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
		curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)fp);
		//设定控制台回显调试信息
		curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);

		//执行HTTP请求
		CURLcode ret = curl_easy_perform(curl);
		if (ret != CURLE_OK) {
			curl_easy_cleanup(curl);
			fclose(fp);
			return ERROR2("curl_easy_perform", ret);
		}
	}
	else {
		fclose(fp);
		return ERROR("curl_easy_init");
	}
	fclose(fp);
	curl_easy_cleanup(curl);
	return 0;
}
</code></pre> 
<p>控制台回显结果（部分）：</p> 
<pre><code>&gt; GET /dav/box1/Upload_test.txt HTTP/1.1
Host: dav.jianguoyun.com
Authorization: Basic MjgwMjAzNzEyNEBxc--------------GMyajZuN3F0eg==
Connection: close
Accept: */*

&lt; HTTP/1.1 200 OK
&lt; Server: nginx
&lt; Date: Mon, 19 Feb 2024 06:13:18 GMT
&lt; Content-Type: text/plain
&lt; Content-Length: 1844
&lt; Connection: close
&lt; Etag: 8sKBsnMc5tH71U67xjQTCQ
&lt; Pragma: public
&lt; Cache-Control: max-age=5
&lt; Content-Disposition: attachment
&lt;
* Closing connection
program end.
</code></pre> 
<p>下载的文件内容保存在以下代码绑定的文件中了：</p> 
<pre><code>		//设定HTTP响应的处理方法
		curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
		curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)fp);
</code></pre> 
<h3><a id="PROPPATCH_498"></a>PROPPATCH方法</h3> 
<p>PROPPATCH方法用于修改文件的属性。<br> WebDav方法的HTTP Body是XML格式，前面尝试的几个请求都没有添加Body。<br> PROPPATCH需要在Body中添加需要修改的属性指令。</p> 
<p>以刚才PUT的文件Upload_test.txt为目标，把它的&lt;d:displayname&gt;修改为Upload_test_1.txt。<br> 但是没有效果，坚果云给的响应中消息中，也没有显示失败信息。</p> 
<p><strong>我咨询了坚果云的客服，客服联系技术给出了回复，目前坚果云不支持PROPPATCH方法</strong><br> 因此，无法验证我的代码是否正确，但是还是记录一下代码，期待以后有机会验证。</p> 
<p>代码：</p> 
<pre><code>int My_PROPPATCH()
{
	const char* url = "https://dav.jianguoyun.com/dav/box1/Upload_test.txt";

	CURL* curl = curl_easy_init();
	if (curl) {
		//设置HTTP头		
		curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "PROPPATCH"); //修改HTTP方法
		curl_easy_setopt(curl, CURLOPT_URL, url); //设置URL		
		curl_easy_setopt(curl, CURLOPT_HTTP_VERSION, (long)CURL_HTTP_VERSION_1_1); //指定HTTP版本
		curl_easy_setopt(curl, CURLOPT_USERNAME, "2802037124@qq.com"); //设置访问WebDav账号和密码
		curl_easy_setopt(curl, CURLOPT_PASSWORD, "axs5pyhc2j6n7qtz");
		struct curl_slist* list = NULL; //设置HTTP头部字段
		//list = curl_slist_append(list, "Connection: close"); //不要长连接
		list = curl_slist_append(list, "Accept: */*");
		list = curl_slist_append(list, "Content-Type:application/xml; charset= 'utf-8'");
		curl_easy_setopt(curl, CURLOPT_HTTPHEADER, list);

		//指定用于SSL证书验证的证书
		CURLcode err = curl_easy_setopt(curl, CURLOPT_CAINFO, "D:\\SourceCode\\cert\\_.jianguoyun.com.crt");
		if (err != CURLE_OK) {
			cout &lt;&lt; "CURLOPT_CAPATH err:" &lt;&lt; err &lt;&lt; endl;
		}
		//如果不设置，会出现：unable to get local issuer certificate的错误

		//设定HTTP响应的处理方法
		curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
		curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)fp);
		//设定控制台回显调试信息
		curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);

		//使用TinyXML库，添加Http Body
		TiXmlDocument* tinyXmlDoc = new TiXmlDocument();

		TiXmlDeclaration* tinyXmlDeclare = new TiXmlDeclaration("1.0", "utf-8", "");  // xml的声明
		tinyXmlDoc-&gt;LinkEndChild(tinyXmlDeclare);

		TiXmlElement* Library = new TiXmlElement("D:propertyupdate");
		Library-&gt;SetAttribute(" xmlns:D", "DAV");
		Library-&gt;SetAttribute(" xmlns:S", "http://ns.jianguoyun.com");
		tinyXmlDoc-&gt;LinkEndChild(Library);	

		TiXmlElement* Set = new TiXmlElement("D:set");
		Library-&gt;LinkEndChild(Set);

		TiXmlElement* Prop = new TiXmlElement("D:prop");
		Set-&gt;LinkEndChild(Prop);

		TiXmlElement* Displayname2 = new TiXmlElement("S:publish");
		TiXmlText* newname = new TiXmlText("Upload_test_1.txt");	
		Displayname2-&gt;LinkEndChild(newname);	
		Prop-&gt;LinkEndChild(Displayname2);

		TiXmlPrinter printer;
		tinyXmlDoc-&gt;Accept(&amp;printer);
		printf("%s\n", printer.CStr());
		char body[1024] = { 0x00 };
		strcpy_s(body, (rsize_t)1024, printer.CStr());
		curl_off_t size = strlen(body);
		
		curl_easy_setopt(curl, CURLOPT_READFUNCTION, read_cb_patch); //设置读取文件的回调函数
		curl_easy_setopt(curl, CURLOPT_UPLOAD, 1L); //启动Upload服务
		curl_easy_setopt(curl, CURLOPT_READDATA, body);//设置传入回调函数的文件句柄
		curl_easy_setopt(curl, CURLOPT_INFILESIZE_LARGE, (curl_off_t)size);//设置文件大小

		//执行HTTP请求
		CURLcode ret = curl_easy_perform(curl);
		if (ret != CURLE_OK) {
			curl_easy_cleanup(curl);
			/*fclose(fp);*/
			return ERROR2("curl_easy_perform", ret);
		}
	}
	else {
		//fclose(fp);
		return ERROR("curl_easy_init");
	}
	//fclose(fp);
	curl_easy_cleanup(curl);
	return 0;
}
</code></pre> 
<p>控制台回显：</p> 
<pre><code>&gt; PROPPATCH /dav/box1/Upload_test.txt HTTP/1.1
Host: dav.jianguoyun.com
Authorization: Basic MjgwMjAzNzEyNEBxcS5jb206YXhzNXB5aGMyajZuN3F0eg==
Accept: */*
Content-Type:application/xml; charset= 'utf-8'
Content-Length: 243

* We are completely uploaded and fine
&lt; HTTP/1.1 207 Multi-Status
&lt; Server: nginx
&lt; Date: Mon, 19 Feb 2024 09:23:56 GMT
&lt; Content-Type: text/xml; charset=UTF-8
&lt; Content-Length: 524
&lt; Connection: keep-alive
&lt; Keep-Alive: timeout=60
&lt; Pragma: no-cache
&lt; Cache-Control: no-cache
</code></pre> 
<p>Response的正文：</p> 
<pre><code>&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;d:multistatus xmlns:d="DAV:" xmlns:s="http://ns.jianguoyun.com"&gt;
&lt;d:response&gt;
&lt;d:href&gt;/dav/box1/Upload_test.txt&lt;/d:href&gt;
&lt;d:propstat&gt;
&lt;d:prop&gt;
&lt;m:Win32LastModifiedTime xmlns:m="urn:schemas-microsoft-com:"/&gt;
&lt;m:Win32FileAttributes xmlns:m="urn:schemas-microsoft-com:"/&gt;
&lt;m:Win32CreationTime xmlns:m="urn:schemas-microsoft-com:"/&gt;
&lt;m:Win32LastAccessTime xmlns:m="urn:schemas-microsoft-com:"/&gt;
&lt;/d:prop&gt;&lt;d:status&gt;HTTP/1.1 200 OK&lt;/d:status&gt;
&lt;/d:propstat&gt;&lt;/d:response&gt;&lt;/d:multistatus&gt;
</code></pre> 
<h2><a id="WebDav_628"></a>WebDav缓存</h2> 
<p>在上面的PROPFIND等请求的响应头中，能看到以下字段：</p> 
<pre><code>&lt; Etag: 8sKBsnMc5tH71U67xjQTCQ
&lt; Cache-Control: max-age=5
</code></pre> 
<h3><a id="CacheControl_634"></a>Cache-Control</h3> 
<p>Cache-Control: max-age=5 就是控制缓存的过期时间，这里是5秒后缓存过期。</p> 
<p>Cache-Control也可以用来设置缓存类型，Cache-Control: private //私有缓存<br> Cache-Control: public //贡献缓存。</p> 
<h3><a id="Etag_639"></a>Etag</h3> 
<p>他们是用于HTTP缓存控制的字段。</p> 
<p>Etag响应头，是HTTP中资源的特定版本标识符。<br> Etag相当于资源的指纹， URL 中的资源更改了，就一定要生成新的 ETag 值。<br> Etag由服务器生成，在客户端请求资源时通过Etag响应头发给客户端。</p> 
<p>客户端下次请求同一个资源时，如果资源已经过期，客户端请求通过If-None-Match请求头，把Etag的值发给服务器，服务器可以通过If-None-Match的值，判断资源是否已经改变（这个过程叫做重新验证）。如果客户端的If-None-Match和服务器资源当前的Etag一致，服务器就不需要发送完整数据了，返回一个 304 Not Modified 状态即可。</p> 
<h4><a id="_648"></a>测试</h4> 
<p>首先我用PROPFIND获取了WebDav中，一个文件的属性，它的Etag是：</p> 
<pre><code>&lt;d:getetag&gt;uLR1Dl0O-2f8uVxiMCSTGQ&lt;/d:getetag&gt;
</code></pre> 
<p>我在GET方法的请求头中，添加了If-None_Match字段，值就是刚才获取的文件Etag。</p> 
<pre><code>list = curl_slist_append(list, "If-None-Match: uLR1Dl0O-2f8uVxiMCSTGQ");
</code></pre> 
<p>发送GET方法请求后，服务器返回304 Not Modified，即文件没有变动，无需重新获取数据。<br> <img src="https://images2.imgbox.com/27/ac/nW96usgx_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_660"></a>强制重新验证</h3> 
<p>如果服务器想要客户端在资源没有过期的时候，也要获取最新的资源。<br> 可以在 存在Etag或者Last-Modified头的同时，指定Cache-Control: no-cache或Cache-Control: max-age=0, must-revalidate</p> 
<h3><a id="_664"></a>不需要缓存</h3> 
<p>指定Cache-Control: no-cache</p> 
<p>GET、HEAD、OPTIONS 方法是幂等的，不会改变服务器资源的状态，是可以缓存的。<br> 其余的方法是不建议缓存，或者不可以缓存的。</p> 
<p>完整的缓存控制可以参考：<a rel="nofollow">【HTTP完全注解】看了还搞不懂缓存你直接来打我</a></p> 
<h2><a id="WebDav_672"></a>WebDav的锁</h2> 
<p>WebDav 规范中存在排他锁、共享锁。<br> WebDav规范中只规定了写入锁（Write），不同的服务器可能实现了不同类型的锁。<br> 在不同的服务器中，可能不支持锁，或者支持一种锁，或者支持多种锁。</p> 
<p>WebDav中的每一个锁都会生成一个锁令牌（lock token），在对被锁住的对象进行操作室，HTTP头必须提交锁令牌信息。</p> 
<p>有LOCK和UNLOCK方法来进行枷锁和解锁。</p> 
<h2><a id="WebDav_681"></a>WebDav的状态码</h2> 
<p>WebDav扩展了以下状态码：<br> 207：多状态，查看响应正文来获取详细状态。<br> 422：请求URL存在，但是请求正文的XML内容不正确<br> 423：请求的文件对象已被锁定<br> 424：依赖失败，比如PROPPATCH中的一个属性修改命令失败，其余的命令也会失败。<br> 507：服务器暂时无法提供存储空间</p> 
<h2><a id="WebDav_688"></a>WebDav身份验证</h2> 
<p>通过TLS确保Basic验证信息安全。</p> 
<h2><a id="WebDav_690"></a>WebDav版本控制</h2> 
<p>TODO.<br> 参考：<a rel="nofollow">Versioning Extensions to WebDAV</a></p> 
<h2><a id="WebDavFTP_693"></a>WebDav和FTP的区别</h2> 
<p>WebDav提供了缓存功能，FTP没有；<br> WebDav一般通过HTTPS的443端口通信，FTP需要用20和21端口通信。<br> WebDav提供了锁，FTP没有。</p> 
<h2><a id="_697"></a>参考</h2> 
<p><a rel="nofollow">WebDAV Resources</a><br> <a rel="nofollow">WebDAV 规范文档</a><br> <a href="https://gitee.com/FullStackPlayer/WebDAV-RFC4918-CN/tree/master/Translation" rel="nofollow">WebDAV 规范文档-Gitee</a><br> <a href="https://blog.csdn.net/janbar/article/details/120512616">学习WebDav</a><br> <a rel="nofollow">如何在Zotero中设置webdav连接到坚果云？</a><br> <a rel="nofollow">【HTTP完全注解】看了还搞不懂缓存你直接来打我</a><br> http 三种认证方式 Basic Session Token 简介<br> <a rel="nofollow">Versioning Extensions to WebDAV</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b4b69ade719a874968f300265ba71e16/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Java】采用 Tabula 技术对 PDF 文件内表格进行数据提取</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f99abb9eaa645c351e442fc047641259/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何使用安卓平板远程Ubuntu服务器通过VS Code远程开发</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>