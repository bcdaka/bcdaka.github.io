<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python泛型使用typing模块TypeVar和Generic实现 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/6db2499e396a29a21d57c12d6a8288b5/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Python泛型使用typing模块TypeVar和Generic实现">
  <meta property="og:description" content="在Python中，泛型是一种编程概念，它允许在编写函数、类或数据结构时使用参数化类型，以提高代码的灵活性和复用性。通过泛型，我们可以编写更通用的代码，使其能够适用于多种不同类型的数据。
Python 中的泛型是使用 typing 模块中的 TypeVar 和 Generic 进行实现的。TypeVar 用于定义泛型类型变量，而 Generic 用于定义泛型类或函数。
typing 模块中的泛型支持包括一系列的泛型类型和类型变量，例如 List、Dict、Tuple 等。开发者可以使用这些泛型类型来声明具有泛型参数的数据结构或函数签名。此外，Python 3.9 引入了更多强大的泛型支持，包括 Literal、TypedDict 等新的泛型类型。
需要注意的是，Python 中的泛型类型提示仅用于静态类型检查和文档说明，并不影响运行时的行为。Python 解释器不会强制执行类型提示，因此在运行时仍然可以传入任何类型的参数。
下面是一些关于Python泛型的详细解释：
1. 泛型类型变量（Generic Type Variables）： 在使用泛型时，我们通常会定义一个泛型类型变量，用于表示某种不确定的类型。泛型类型变量通常使用大写字母命名，比如 T、U、V 等。
T = TypeVar(&#39;T&#39;) 2. 泛型函数（Generic Functions）： 泛型函数是可以接受一个或多个泛型类型参数的函数。这些参数可以用来指定函数参数的类型、返回值的类型或函数内部使用的其他类型。
from typing import TypeVar, List T = TypeVar(&#39;T&#39;) def first_element(items: List[T]) -&gt; T: return items[0] int_list = [1, 2, 3, 4, 5] print(first_element(int_list)) # 输出: 1 str_list = [&#34;Hello&#34;, &#34;World&#34;, &#34;Python&#34;] print(first_element(str_list)) # 输出: Hello 在这个例子中，我们创建了一个整数列表 int_list 和一个字符串列表 str_list。我们使用 first_element 函数获取了这两个列表的第一个元素，分别是整数 1 和字符串 &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-01T01:07:40+08:00">
    <meta property="article:modified_time" content="2024-04-01T01:07:40+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python泛型使用typing模块TypeVar和Generic实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在Python中，泛型是一种编程概念，它允许在编写函数、类或数据结构时使用参数化类型，以提高代码的灵活性和复用性。<span style="color:#1a439c;">通过</span><span style="color:#fe2c24;">泛型</span><span style="color:#1a439c;">，我们可以编写更通用的代码</span>，使其能够适用于多种不同类型的数据。</p> 
<p><span style="color:#1a439c;">Python 中的泛型是使用 <code>typing</code> 模块中的 <code>TypeVar</code> 和 <code>Generic</code> 进行实现的。<code>TypeVar</code> 用于定义泛型类型变量，而 <code>Generic</code> 用于定义泛型类或函数。</span></p> 
<p><span style="color:#1a439c;"><code>typing</code> 模块中的泛型</span>支持包括一系列的泛型类型和类型变量，例如 <code>List</code>、<code>Dict</code>、<code>Tuple</code> 等。开发者可以使用这些泛型类型来声明具有泛型参数的数据结构或函数签名。此外，Python 3.9 引入了更多强大的泛型支持，包括 <code>Literal</code>、<code>TypedDict</code> 等新的泛型类型。</p> 
<p>需要注意的是，Python 中的泛型<strong><span style="color:#1a439c;">类型提示</span></strong>仅用于静态类型检查和文档说明，并不影响运行时的行为。Python 解释器不会强制执行类型提示，因此在运行时仍然可以传入任何类型的参数。</p> 
<p>下面是一些关于Python泛型的详细解释：</p> 
<h4>1. 泛型类型变量（Generic Type Variables）：</h4> 
<p>在使用泛型时，我们通常会定义一个泛型类型变量，用于表示某种不确定的类型。泛型类型变量通常使用大写字母命名，比如 <code>T</code>、<code>U</code>、<code>V</code> 等。</p> 
<pre><code class="language-python">T = TypeVar('T')
</code></pre> 
<h4>2. 泛型函数（Generic Functions）：</h4> 
<p>泛型函数是可以接受一个或多个泛型类型参数的函数。这些参数可以用来指定函数参数的类型、返回值的类型或函数内部使用的其他类型。</p> 
<pre><code class="language-python">from typing import TypeVar, List

T = TypeVar('T')

def first_element(items: List[T]) -&gt; T:
    return items[0]

int_list = [1, 2, 3, 4, 5]
print(first_element(int_list))  # 输出: 1

str_list = ["Hello", "World", "Python"]
print(first_element(str_list))  # 输出: Hello
</code></pre> 
<p>在这个例子中，我们创建了一个整数列表 <code>int_list</code> 和一个字符串列表 <code>str_list</code>。我们使用 <code>first_element</code> 函数获取了这两个列表的第一个元素，分别是整数 <code>1</code> 和字符串 <code>"Hello"</code>。 </p> 
<pre><code class="language-python">from typing import TypeVar, List

# 定义一个泛型类型T
T = TypeVar('T')

def reverse_list(items: List[T]) -&gt; List[T]:
    """反转列表"""
    return items[::-1]

# 使用泛型函数
int_list = [1, 2, 3, 4, 5]
str_list = ["apple", "banana", "orange"]

reversed_ints = reverse_list(int_list)
reversed_strs = reverse_list(str_list)

print(reversed_ints)  # 输出: [5, 4, 3, 2, 1]
print(reversed_strs)  # 输出: ['orange', 'banana', 'apple']
</code></pre> 
<h4>3. 泛型类（Generic Classes）：</h4> 
<p>泛型类是可以接受一个或多个泛型类型参数的类。这些参数可以用来指定类的属性类型、方法参数类型、方法返回值类型或类内部使用的其他类型。</p> 
<pre><code class="language-python">from typing import TypeVar, Generic

T = TypeVar('T')

class Box(Generic[T]):
    def __init__(self, item: T):
        self.item = item

    def get_item(self) -&gt; T:
        return self.item

int_box = Box[int](10)
print(int_box.get_item())  # 输出: 10

str_box = Box[str]("Hello")
print(str_box.get_item())  # 输出: Hello
</code></pre> 
<p>在这个例子中，我们创建了一个整数 <code>Box</code> 实例 <code>int_box</code>，存储了整数 <code>10</code>，并使用 <code>get_item</code> 方法获取了该整数。我们还创建了一个字符串 <code>Box</code> 实例 <code>str_box</code>，存储了字符串 <code>"Hello"</code>，并使用 <code>get_item</code> 方法获取了该字符串。 </p> 
<h4>4. 泛型约束（Generic Constraints）：</h4> 
<p>有时，我们希望泛型类型只能是特定的类型或其子类。在这种情况下，我们可以使用泛型约束来限制泛型类型的范围。</p> 
<pre><code class="language-python">from typing import TypeVar, List, Union

T = TypeVar('T', int, float)

def sum_values(items: List[T]) -&gt; Union[int, float]:
    return sum(items)

int_list = [1, 2, 3, 4, 5]
print(sum_values(int_list))  # 输出: 15

float_list = [1.5, 2.5, 3.5, 4.5, 5.5]
print(sum_values(float_list))  # 输出: 16.0
</code></pre> 
<p>在这个例子中，我们创建了一个整数列表 <code>int_list</code> 和一个浮点数列表 <code>float_list</code>。我们使用 <code>sum_values</code> 函数计算了这两个列表的总和，分别是整数 <code>15</code> 和浮点数 <code>16.0</code>。 <br><span style="color:#fe2c24;">代码片段中，<code>-&gt; Union[int, float]</code> 是函数 <code>sum_values</code> 的</span><strong><span style="color:#1a439c;">返回类型注解</span></strong><span style="color:#fe2c24;">。</span>它表示函数的返回值可以是整数（<code>int</code>）或浮点数（<code>float</code>）类型之一。这是通过 <code>typing</code> 模块中的 <code>Union</code> 类型帮助器实现的。<br> 需要注意的是，<span style="color:#1a439c;">Python 中的</span><span style="color:#fe2c24;">泛型<strong>类型提示</strong></span><span style="color:#1a439c;">仅用于静态类型检查和文档说明，并不影响运行时的行为</span>。Python 解释器不会强制执行类型提示，因此在运行时仍然可以传入任何类型的参数。</p> 
<p>​​​​​​​<br><span style="color:#1a439c;"><strong>类型注解</strong></span>是指在代码中为变量、函数参数和返回值等添加类型信息的过程。它们使用 Python 的 <span style="color:#1a439c;"><code>typing</code> 模块提供的类型帮助器</span>，如 <code>List</code>、<code>Union</code>、<code>TypeVar</code> 等，来描述变量或函数参数的类型。类型注解的主要目的是提高代码的可读性、可维护性，并为静态类型检查工具提供有关代码结构的信息。</p> 
<h4>5. 使用泛型时的注意事项：</h4> 
<ul><li>泛型只是一种约定和规范，Python解释器不会强制执行泛型类型。</li><li>泛型可以提高代码的可读性和可维护性，但也可能增加代码的复杂度。</li><li>在使用泛型时，应该遵循Python的命名规范，使代码易于理解和维护。</li><li>当使用第三方库中的泛型类型时，应该查阅文档以了解其使用方法和约束条件。</li></ul> 
<p>总之，泛型是一种强大的编程工具，可以帮助开发者编写更通用、更灵活的代码，但在使用时需要注意理解其原理和限制。</p> 
<p>---------</p> 
<pre><code class="language-python">from typing import TypeVar, Generic

# 定义一个泛型类型T
T = TypeVar('T')

class Storage(Generic[T]):
    def __init__(self, initial_value: T):
        self._value = initial_value

    def get_value(self) -&gt; T:
        """获取存储的值"""
        return self._value

    def set_value(self, new_value: T) -&gt; None:
        """设置新的值"""
        self._value = new_value

# 使用泛型类
int_storage = Storage(10)
print(int_storage.get_value())  # 输出: 10
int_storage.set_value(20)
print(int_storage.get_value())  # 输出: 20

str_storage = Storage("Hello")
print(str_storage.get_value())  # 输出: Hello
str_storage.set_value("World")
print(str_storage.get_value())  # 输出: World</code></pre> 
<p>这段代码演示了如何使用泛型类（Generic Class）来创建可以存储不同类型数据的存储器。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4347e188369ec6ad01f0185f5307f470/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android中FragmentContainerView的详细介绍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8c002de5def4d75e171b4ca6c7d31253/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android输入法框架，安卓开发实战</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>