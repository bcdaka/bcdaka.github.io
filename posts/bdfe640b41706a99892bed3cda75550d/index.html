<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>树和二叉树（不用看课程） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/bdfe640b41706a99892bed3cda75550d/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="树和二叉树（不用看课程）">
  <meta property="og:description" content="1. 树 1.1 树的概念与结构 树是⼀种非线性的数据结构，它是由 n（n&gt;=0） 个有限结点组成⼀个具有层次关系的集合。把它叫做树是因为它看起来像⼀棵倒挂的树，也就是说它是根朝上，而叶朝下的。
• 有⼀个特殊的结点，称为根结点，根结点没有前驱结点。
• 除根结点外，其余结点被分成 M(M&gt;0) 个互不相交的集合 T1、T2、……、Tm ，其中每⼀个集合 Ti(1 &lt;= i &lt;= m) 又是⼀棵结构与树类似的子树。每棵子树的根结点有且只有⼀个前驱，可以有 0 个或多个后继。因此，树是递归定义的。
树形结构中，子树之间不能有交集，否则就不是树形结构。
非树形结构： • 子树是不相交的（如果存在相交就是图了）（除了根节点之外，有其它的集合，这些集合就是树） • 除了根结点外，每个结点有且仅有一个父结点 • ⼀棵N个结点的树有N-1条边 1.2树相关术语 父结点/双亲结点：若⼀个结点含有子结点，则这个结点称为其子结点的父结点； 如上图：A是B的父结点。 子结点/孩子结点：⼀个结点含有的子树的根结点称为该结点的子结点； 如上图：B是A的孩子结点。 结点的度：⼀个结点有几个孩子，他的度就是多少；比如A的度为6，F的度为2，K的度为0。 树的度：⼀棵树中，最大的结点的度称为树的度； 如上图：树的度为 6。 叶子结点/终端结点：度为 0 的结点称为叶结点； 如上图： B 、 C 、 H 、 I... 等结点为叶结点。 分支结点/非终端结点：度不为 0 的结点； 如上图： D 、 E 、 F 、 G... 等结点为分支结点。 兄弟结点：具有相同父结点的结点互称为兄弟结点(亲兄弟)； 如上图： B 、 C 、D、E、F等 是兄弟结点。（H、I是表兄弟节点）。 结点的层次：从根开始定义起，根为第 1 层，根的子结点为第 2 层，以此类推。 树的高度或深度：树中结点的最大层次； 如上图：树的高度为 4。 结点的祖先：从根到该结点所经分支上的所有结点；如上图： A 是所有结点的祖先。比如P的祖先节点是（A、E、J）。 路径：⼀条从树中任意节点出发，沿父节点——子节点连接，达到任意节点的序列；比如A到Q的路径为： A-E-J-Q；H到Q的路径H-D-A-E-J-Q。 子孙：以某结点为根的子树中任⼀结点都称为该结点的子孙。如上图：所有结点都是A的子孙。 森林：由 m （ m&gt;0 ）棵互不相交的树的集合称为森林。一棵树也可以称为森林。 1.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-27T20:24:16+08:00">
    <meta property="article:modified_time" content="2024-07-27T20:24:16+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">树和二叉树（不用看课程）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="1.%20%E6%A0%91">1. 树</h2> 
<h3 id="1.1%20%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%BB%93%E6%9E%84">1.1 树的概念与结构</h3> 
<p>树是⼀种非线性的数据结构，它是由 n（n&gt;=0） 个有限结点组成⼀个具有层次关系的集合。把它叫做树是因为它看起来像⼀棵倒挂的树，也就是说它是根朝上，而叶朝下的。</p> 
<p>• 有⼀个特殊的结点，称为根结点，根结点没有前驱结点。</p> 
<p>• 除根结点外，其余结点被分成 M(M&gt;0) 个互不相交的集合 T1、T2、……、Tm ，其中每⼀个集合 Ti(1 &lt;= i &lt;= m) 又是⼀棵结构与树类似的子树。每棵子树的根结点有且只有⼀个前驱，可以有 0 个或多个后继。因此，树是递归定义的。</p> 
<p><img alt="" src="https://images2.imgbox.com/ae/13/DXMIqCun_o.png"></p> 
<p> <span style="color:#646a73;">树形结构中，子树之间不能有交集，否则就不是树形结构。</span></p> 
<p><span style="color:#1f2329;">非树形结构： </span></p> 
<p style="text-align:center;"><span style="color:#1f2329;"><img alt="" src="https://images2.imgbox.com/96/ee/k65Isqg2_o.png"></span></p> 
<div> 
 <span style="color:#1456f0;">• </span> 
 <span style="color:#1f2329;">子树是不相交的（如果存在相交就是图了）（除了根节点之外，有其它的集合，这些集合就是树）</span> 
</div> 
<div> 
 <span style="color:#1456f0;">• </span> 
 <span style="color:#1f2329;">除了根结点外，每个结点有且仅有一个父结点 </span> 
</div> 
<div> 
 <span style="color:#1456f0;">• </span> 
 <span style="color:#1f2329;">⼀棵N个结点的树有N-1条边 </span> 
</div> 
<h3 id="1.2%E6%A0%91%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD"><span style="color:#1f2329;">1.2树相关术语 </span></h3> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/35/8c/8auvroSJ_o.png"></p> 
<div> 
 <span style="color:#1f2329;"><strong>父结点/双亲结点：</strong>若⼀个结点含有子结点，则这个结点称为其子结点的父结点； 如上图：A是B的父结点。</span> 
</div> 
<div></div> 
<div> 
 <span style="color:#1f2329;"><strong>子结点/孩子结点：</strong>⼀个结点含有的子树的根结点称为该结点的子结点； 如上图：B是A的孩子结点。</span> 
</div> 
<div></div> 
<div> 
 <span style="color:#1f2329;"><strong>结点的度：</strong>⼀个结点有几个孩子，他的度就是多少；比如A的度为6，F的度为2，K的度为0。</span> 
</div> 
<div> 
 <span style="color:#1f2329;">树的度：⼀棵树中，最大的结点的度称为树的度； 如上图：树的度为 </span> 
 <span style="color:#1f2329;">6。</span> 
</div> 
<div></div> 
<div> 
 <span style="color:#1f2329;"><strong>叶子结点/终端结点：</strong>度为 </span> 
 <span style="color:#1f2329;">0 </span> 
 <span style="color:#1f2329;">的结点称为叶结点； 如上图： </span> 
 <span style="color:#1f2329;">B</span> 
 <span style="color:#1f2329;">、</span> 
 <span style="color:#1f2329;">C</span> 
 <span style="color:#1f2329;">、</span> 
 <span style="color:#1f2329;">H</span> 
 <span style="color:#1f2329;">、</span> 
 <span style="color:#1f2329;">I... </span> 
 <span style="color:#1f2329;">等结点为叶结点。</span> 
</div> 
<div></div> 
<div> 
 <span style="color:#1f2329;"><strong>分支结点/非终端结点：</strong>度不为 </span> 
 <span style="color:#1f2329;">0 </span> 
 <span style="color:#1f2329;">的结点； 如上图： </span> 
 <span style="color:#1f2329;">D</span> 
 <span style="color:#1f2329;">、</span> 
 <span style="color:#1f2329;">E</span> 
 <span style="color:#1f2329;">、</span> 
 <span style="color:#1f2329;">F</span> 
 <span style="color:#1f2329;">、</span> 
 <span style="color:#1f2329;">G... </span> 
 <span style="color:#1f2329;">等结点为分支结点。</span> 
</div> 
<div></div> 
<div> 
 <span style="color:#1f2329;"><strong>兄弟结点：</strong>具有相同父结点的结点互称为兄弟结点(亲兄弟)； 如上图： </span> 
 <span style="color:#1f2329;">B</span> 
 <span style="color:#1f2329;">、</span> 
 <span style="color:#1f2329;">C 、D、E、F等</span> 
 <span style="color:#1f2329;">是兄弟结点。（H、I是表兄弟节点）。</span> 
</div> 
<div></div> 
<div> 
 <span style="color:#1f2329;"><strong>结点的层次：</strong>从根开始定义起，根为第 </span> 
 <span style="color:#1f2329;">1 </span> 
 <span style="color:#1f2329;">层，根的子结点为第 </span> 
 <span style="color:#1f2329;">2 </span> 
 <span style="color:#1f2329;">层，以此类推。</span> 
</div> 
<div></div> 
<div> 
 <span style="color:#1f2329;"><strong>树的高度或深度：</strong>树中结点的最大层次； 如上图：树的高度为 </span> 
 <span style="color:#1f2329;">4。</span> 
</div> 
<div></div> 
<div> 
 <span style="color:#1f2329;"><strong>结点的祖先：</strong>从根到该结点所经分支上的所有结点；如上图： </span> 
 <span style="color:#1f2329;">A </span> 
 <span style="color:#1f2329;">是所有结点的祖先。比如P的祖先节点是（A、E、J）。</span> 
</div> 
<div></div> 
<div> 
 <span style="color:#1f2329;"><strong>路径：</strong>⼀条从树中任意节点出发，沿父节点——子节点连接，达到任意节点的序列；比如A到Q的路径为： A-E-J-Q；H到Q的路径H-D-A-E-J-Q。</span> 
</div> 
<div></div> 
<div> 
 <span style="color:#1f2329;"><strong>子孙：</strong>以某结点为根的子树中任⼀结点都称为该结点的子孙。如上图：所有结点都是A的子孙。</span> 
</div> 
<div></div> 
<div> 
 <span style="color:#1f2329;"><strong>森林：</strong>由 </span> 
 <span style="color:#1f2329;">m</span> 
 <span style="color:#1f2329;">（ </span> 
 <span style="color:#1f2329;">m&gt;0 </span> 
 <span style="color:#1f2329;">）棵互不相交的树的集合称为森林。一棵树也可以称为森林。</span> 
</div> 
<h3 id="1.3%C2%A0%E6%A0%91%E7%9A%84%E8%A1%A8%E7%A4%BA">1.3 <span style="color:#1f2329;">树的表示</span></h3> 
<div> 
 <strong><span style="color:#1f2329;">孩子兄弟表示法： </span></strong> 
</div> 
<div> 
 <span style="color:#1f2329;">树结构相对线性表就比较复杂了，要存储表示起来就比较麻烦了，既然保存值域，也要保存结点和结点之间的关系，实际中树有很多种表示方式如：双亲表示法，孩子表示法、孩子双亲表示法以及孩子兄弟表示法等。我们这里就简单的了解其中最常用的孩子兄弟表示法。</span> 
</div> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/9d/ec/xibcRtYh_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f8/84/4c3hU12w_o.png"></p> 
<h3 id="1.4%20%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8%E5%9C%BA%E6%99%AF"><span style="color:#1f2329;">1.4 树形结构实际运用场景 </span></h3> 
<div> 
 <span style="color:#1f2329;">文件系统是计算机存储和管理文件的⼀种方式，它利用树形结构来组织和管理文件和文件夹。在文件 系统中，树结构被广泛应用，它通过父结点和子结点之间的关系来表示不同层级的文件和文件夹之间的关联。 </span> 
</div> 
<div style="text-align:center;"> 
 <span style="color:#1f2329;"><img alt="" src="https://images2.imgbox.com/68/7a/1o7pi9w9_o.png"></span> 
</div> 
<p><img alt="" src="https://images2.imgbox.com/c1/b2/gG8PEDMC_o.png"></p> 
<h2 id="2.%20%E4%BA%8C%E5%8F%89%E6%A0%91"><span style="color:#1f2329;">2. 二叉树 </span></h2> 
<h3 id="2.1%20%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%BB%93%E6%9E%84"><span style="color:#1f2329;">2.1 概念与结构 </span></h3> 
<div> 
 <span style="color:#1f2329;">在树形结构中，我们最常用的就是⼆叉树，⼀棵⼆叉树是结点的⼀个有限集合，该集合由⼀个根结点加上两棵别称为左子树和右子树的⼆叉树组成或者为空。二叉树是树形结构的一种，也可以说是对树的结构加以限制形成二叉树。</span> 
</div> 
<div style="text-align:center;"> 
 <span style="color:#1f2329;"><img alt="" src="https://images2.imgbox.com/87/08/QHYR28LY_o.png"></span>  
</div> 
<div> 
 <span style="color:#1f2329;">从上图可以看出二叉树具备以下特点： </span> 
</div> 
<div> 
 <span style="color:#1456f0;">1. </span> 
 <span style="color:#1f2329;">⼆叉树不存在度大于 </span> 
 <span style="color:#1f2329;">2 </span> 
 <span style="color:#1f2329;">的结点。（二叉树只存在度为0、1、2的节点）</span> 
</div> 
<div> 
 <span style="color:#1456f0;">2. </span> 
 <span style="color:#1f2329;">⼆叉树的子树有左右之分，次序不能颠倒，因此二叉树是<strong>有序树</strong>。（这里的有序是指左右孩子是有区分的）</span> 
</div> 
<div> 
 <span style="color:#1f2329;">注意：对于任意的二叉树都是由以下几种情况复合而成的。</span> 
</div> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/61/6e/6KVNUaIP_o.png"></p> 
<p>第一个是空树（度为0），第二个叫只有根节点的二叉树，第三个叫做只有左子树的二叉树，第四个叫做只有右子树的二叉树，第五个叫做左右子树都存在的二叉树。</p> 
<h3 id="2.2%20%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span style="color:#1456f0;">2.2 </span><span style="color:#1f2329;">特殊的二叉树 </span></h3> 
<h4 id="2.2.1%20%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span style="color:#1456f0;">2.2.1 </span><span style="color:#1f2329;">满二叉树 </span></h4> 
<div> 
 <span style="color:#1f2329;">⼀个二叉树，除了叶子节点外，如果每⼀个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为 K </span> 
 <span style="color:#1f2329;">，且结点总数是 </span> 
 <span style="color:#1f2329;">2 </span> 
 <span style="color:#1f2329;"><em>k </em></span> 
 <span style="color:#1f2329;">− 1 </span> 
 <span style="color:#1f2329;">，则它就是满二叉树。</span> 
</div> 
<div style="text-align:center;"> 
 <span style="color:#1f2329;"><img alt="" src="https://images2.imgbox.com/b6/45/SUsOL7yF_o.png"></span> 
</div> 
<div> 
 <h4 id="2.2.2%20%E5%AE%8C%E5%85%A8%E2%BC%86%E5%8F%89%E6%A0%91"><span style="color:#1456f0;">2.2.2 </span><span style="color:#1f2329;">完全⼆叉树 </span></h4> 
 <div> 
  <span style="color:#1f2329;">完全⼆叉树是效率很高的数据结构，完全二叉树是由满二叉树引出来的。对于深度为 </span> 
  <span style="color:#1f2329;">K </span> 
  <span style="color:#1f2329;">的，有 </span> 
  <span style="color:#1f2329;">n </span> 
  <span style="color:#1f2329;">个结点的二叉树，当且仅当其每⼀个结点都与深度为K的满二叉树中编号从 1至 </span> 
  <span style="color:#1f2329;">n </span> 
  <span style="color:#1f2329;">的结点⼀⼀对应时称 之为完全二叉树。要注意的是满二叉树是⼀种特殊的完全二叉树。 </span> 
 </div> 
 <div style="text-align:center;"> 
  <img alt="" src="https://images2.imgbox.com/26/c8/dBbCWUvD_o.png"> 
 </div> 
 <div>
   假设二叉树层次为K，除了第K层外，每层结点的个数达到最大结点数，第K层结点个数不一定达到最大节点数。 
 </div> 
 <div style="text-align:center;"> 
  <img alt="" src="https://images2.imgbox.com/b8/f4/XAB2fO5P_o.png"> 
 </div> 
 <div>
   这种就不是完全二叉树（完全二叉树结点的顺序是从左到右的）。 
 </div> 
 <div>
   总结： 
 </div> 
 <div> 
  <span style="color:#fe2c24;">满二叉树一定是完全二叉树，但是完全二叉树不一定是满二叉树。</span> 
 </div> 
 <div> 
  <span style="color:#1f2329;">💡 </span> 
  <span style="color:#d83931;">⼆叉树性质 </span> 
 </div> 
 <div> 
  <span style="color:#1f2329;">根据满二叉树的特点可知： </span> 
 </div> 
 <div> 
  <span style="color:#1f2329;">1）若规定根结点的层数为 </span> 
  <span style="color:#1f2329;">1 </span> 
  <span style="color:#1f2329;">，则⼀棵非空二叉树的第i层上最多有 </span> 
  <span style="color:#1f2329;">2^i</span> 
  <span style="color:#1f2329;">−1 </span> 
  <span style="color:#1f2329;">个结点 </span> 
 </div> 
 <div> 
  <span style="color:#1f2329;">2）若规定根结点的层数为 </span> 
  <span style="color:#1f2329;">1 </span> 
  <span style="color:#1f2329;">，则深度为 </span> 
  <span style="color:#1f2329;">h </span> 
  <span style="color:#1f2329;">的二叉树的最大结点数是 </span> 
  <span style="color:#1f2329;">2^h</span> 
  <span style="color:#1f2329;"><em> </em></span> 
  <span style="color:#1f2329;">− 1 </span> 
 </div> 
 <div> 
  <div> 
   <span style="color:#1f2329;">3）若规定根结点的层数为 </span> 
   <span style="color:#1f2329;">1 </span> 
   <span style="color:#1f2329;">，具有 </span> 
   <span style="color:#1f2329;">n </span> 
   <span style="color:#1f2329;">个结点的满⼆叉树的深度 ( </span> 
   <span style="color:#1f2329;">log以2为底， n+1 </span> 
   <span style="color:#1f2329;">为对数)</span> 
  </div> 
 </div> 
 <div>
   （由2^h-1 = n演变而来） 
 </div> 
 <div> 
  <h3 id="2.3%20%E2%BC%86%E5%8F%89%E6%A0%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span style="color:#1456f0;">2.3 </span><span style="color:#1f2329;">⼆叉树存储结构 </span></h3> 
  <div> 
   <span style="color:#1f2329;">二叉树⼀般可以使用两种结构存储，⼀种顺序结构，⼀种链式结构。 </span> 
  </div> 
  <h4 id="2.3.1%20%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84"><span style="color:#1456f0;">2.3.1 </span><span style="color:#1f2329;">顺序结构 </span></h4> 
  <div> 
   <span style="color:#1f2329;">顺序结构存储就是使用数组来存储，一般使用数组只适合表示完全二叉树，因为不是完全二叉树会有 空间的浪费，完全二叉树更适合使用顺序结构存储。 </span> 
  </div> 
 </div> 
</div> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/35/1a/AL5rO93J_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2b/d3/EsBvQOSs_o.png"></p> 
<div> 
 <span style="color:#1f2329;">现实中我们通常把堆（⼀种二叉树）使用顺序结构的数组来存储，需要注意的是这里的堆和操作系统虚拟进程地址空间中的堆是两回事，⼀个是数据结构，⼀个是操作系统中管理内存的⼀块区域分段。</span> 
</div> 
<div> 
 <h4 id="2.3.2%20%E9%93%BE%E5%BC%8F%E7%BB%93%E6%9E%84"><span style="color:#1456f0;">2.3.2 </span><span style="color:#1f2329;">链式结构 </span></h4> 
 <div> 
  <span style="color:#1f2329;">二叉树的链式存储结构是指，用链表来表示⼀棵⼆叉树，即用链来指示元素的逻辑关系。 通常的方法是链表中每个结点由三个域组成，数据域和左右指针域，左右指针分别用来给出该结点左孩子和右孩子所在的链结点的存储地址 。链式结构又分为二叉链和三叉链，当前我们学习中一般都是二叉链。后面课程学到高阶数据结构如红黑树等会用到三叉链。</span> 
 </div> 
</div> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/24/44/JFwv3q9b_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/a3/36/7CSVOSLw_o.png"></p> 
<h2 id="3.%20%E5%AE%9E%E7%8E%B0%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span style="color:#1456f0;">3. </span><span style="color:#1f2329;">实现顺序结构二叉树 </span></h2> 
<div> 
 <span style="color:#1f2329;">一般堆使用顺序结构的数组来存储数据，堆是⼀种特殊的二</span> 
 <span style="color:#1f2329;">叉树，具有二叉树的特性的同时，还具备其他的特性。</span> 
</div> 
<h3 id="%C2%A03.1%20%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%BB%93%E6%9E%84"><span style="color:#1456f0;">3.1 </span><span style="color:#1f2329;">堆的概念与结构 </span></h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/73/ab/fIyvjWBD_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/cf/a9/kEzfkAjS_o.png"></p> 
<blockquote> 
 <div> 
  <span style="color:#646a73;">堆具有以下性质：</span> 
 </div> 
 <div> 
  <span style="color:#1456f0;">• </span> 
  <span style="color:#1f2329;">堆中某个结点的值总是不大于或不小于其父结点的值； </span> 
 </div> 
 <div> 
  <span style="color:#1456f0;">• </span> 
  <span style="color:#1f2329;">堆总是⼀棵完全二叉树。</span> 
 </div> 
 <div> 
  <span style="color:#1456f0;">• </span> 
  <span style="color:#1f2329;">小堆堆顶是堆最小值</span> 
 </div> 
 <div> 
  <span style="color:#1456f0;">• </span> 
  <span style="color:#0d0016;">大</span> 
  <span style="color:#1f2329;">堆堆顶是堆最大值</span> 
 </div> 
 <div> 
  <span style="color:#1456f0;">• </span> 
  <span style="color:#1f2329;">存储在数组中的元素不一定是有序的 </span> 
 </div> 
</blockquote> 
<div> 
 <span style="color:#1f2329;">💡</span> 
 <span style="color:#fe2c24;"> </span> 
 <span style="color:#be191c;">二</span> 
 <span style="color:#d83931;">叉树性质 </span> 
</div> 
<div> 
 <span style="color:#1456f0;">• </span> 
 <span style="color:#1f2329;">对于具有 </span> 
 <span style="color:#1f2329;">n </span> 
 <span style="color:#1f2329;">个结点的完全二叉树，如果按照从上至下从左至右的数组顺序对所有结点从 </span> 
</div> 
<div> 
 <span style="color:#1f2329;">0 </span> 
 <span style="color:#1f2329;">开始编号，则对于序号为 </span> 
 <span style="color:#1f2329;">i </span> 
 <span style="color:#1f2329;">的结点有： </span> 
</div> 
<div> 
 <span style="color:#1456f0;">1. </span> 
 <span style="color:#1f2329;">若 </span> 
 <span style="color:#1f2329;">i&gt;0 </span> 
 <span style="color:#1f2329;">， </span> 
 <span style="color:#1f2329;">i </span> 
 <span style="color:#1f2329;">位置结点的双亲序号： </span> 
 <span style="color:#1f2329;">(i-1)/2 </span> 
 <span style="color:#1f2329;">； </span> 
 <span style="color:#1f2329;">i=0 </span> 
 <span style="color:#1f2329;">， </span> 
 <span style="color:#1f2329;">i </span> 
 <span style="color:#1f2329;">为根结点编号，无双亲结点 </span> 
</div> 
<div> 
 <span style="color:#1456f0;">2. </span> 
 <span style="color:#1f2329;">若 </span> 
 <span style="color:#1f2329;">2i+1&lt;n </span> 
 <span style="color:#1f2329;">，左孩子序号： </span> 
 <span style="color:#1f2329;">2i+1 </span> 
 <span style="color:#1f2329;">， </span> 
 <span style="color:#1f2329;">2i+1&gt;=n </span> 
 <span style="color:#1f2329;">否则无左孩子</span> 
</div> 
<div> 
 <span style="color:#1456f0;">3. </span> 
 <span style="color:#1f2329;">若 </span> 
 <span style="color:#1f2329;">2i+2&lt;n </span> 
 <span style="color:#1f2329;">，右孩子序号： </span> 
 <span style="color:#1f2329;">2i+2 </span> 
 <span style="color:#1f2329;">， </span> 
 <span style="color:#1f2329;">2i+2&gt;=n </span> 
 <span style="color:#1f2329;">否则无右孩子</span> 
</div> 
<p>//定义堆的结构——数组    堆的底层是使用顺序结构数组来实现的<br> typedef int HPDataType;<br> typedef struct Heap<br> {<!-- --><br>     HPDataType* arr;<br>     int size;//有效的数据个数<br>     int capacity;//空间大小<br> }HP;</p> 
<p>//堆的初始化</p> 
<p>void HPInit(HP* php);</p> 
<p>堆的销毁<br> void HPDestroy(HP* php);</p> 
<p>堆数据的插入<br> void HPPush(HP* php, HPDataType x);</p> 
<p>//判断链表是否为空</p> 
<p>//判断空间是否足够</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a6/7b/ARtKjZeq_o.png"></p> 
<p>实现到堆的数据插入之后，不确定是不是真的符合大、小堆存储，这时候就要进行堆的向上调整算法。在这之间，还要用到两个变量交换的函数Add。（只需要比较父结点和左孩子结点，若父结点大于左孩子结点，就交换位置）。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a6/ad/MrOP5aEm_o.png"></p> 
<p>接下来是出堆，而出堆指的就是删除堆顶数据，当我们直接删除堆顶数据时，会导致堆乱套（后一个位置移动到前一个位置处，堆的底层是顺序表），所以不能直接删除堆顶数据。因此，我们必须采取其他的办法。</p> 
<p>方法：</p> 
<p>最后一个结点的数据和堆顶数据交换，这时让size--；而堆顶数据（交换后为最后一个结点）能直接被删除，而删除后的堆顺序不一定符合大、小堆，所以我们要用到向下调整算法。</p> 
<p>//去堆顶<br> void HPPop(HP* php);</p> 
<p>在出堆中，我们必须要保证父结点的值和左右孩子中最小的值去交换（向下调整算法）。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b9/90/E1qXNSJH_o.png"></p> 
<p>//出堆顶<br> HPDataType HPTop(HP* php);</p> 
<p>//打印元素判断代码是否正确</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/1d/53/ruQhDbet_o.png"></p> 
<h2>附源代码： </h2> 
<blockquote> 
 <p>Heap.h</p> 
 <p>#pragma once<br> #include&lt;stdio.h&gt;<br> #include&lt;stdlib.h&gt;<br> #include&lt;assert.h&gt;<br> #include&lt;stdbool.h&gt;<br> //定义堆的结构——数组    堆的底层是使用顺序结构数组来实现的<br> typedef int HPDataType;<br> typedef struct Heap<br> {<!-- --><br>     HPDataType* arr;<br>     int size;//有效的数据个数<br>     int capacity;//空间大小<br> }HP;</p> 
 <p>void HPInit(HP* php);<br> void HPDestroy(HP* php);<br> void HPPush(HP* php, HPDataType x);<br> //去堆顶<br> void HPPop(HP* php);<br> //判空<br> bool HPEmpty(HP* php);<br> //出堆顶<br> HPDataType HPTop(HP* php);</p> 
 <p>void Swap(int* x, int* y);</p> 
</blockquote> 
<blockquote> 
 <p> Heap.c</p> 
 <p>#define _CRT_SECURE_NO_WARNINGS 1<br> #include"Heap.h"<br> void HPInit(HP* php)<br> {<!-- --><br>     assert(php);<br>     php-&gt;arr = NULL;<br>     php-&gt;capacity = php-&gt;size = 0;<br> }</p> 
 <p>void HPDestroy(HP* php)<br> {<!-- --><br>     assert(php);<br>     if (php-&gt;arr)<br>     {<!-- --><br>         free(php-&gt;arr);<br>     }<br>     php-&gt;arr = NULL;<br>     php-&gt;capacity = php-&gt;size = 0;<br> }<br> void Swap(int* x, int* y)<br> {<!-- --><br>     int tmp = *x;<br>     *x = *y;<br>     *y = tmp;<br> }<br> void AdjustUp(HPDataType *arr, int child)<br> {<!-- --><br>     int parent = (child - 1) / 2;<br>     while (child &gt; 0)//不需要等于，child只要走到根节点的位置，根节点没有父节点不需要交换<br>     {<!-- --><br>         if (arr[child] &lt; arr[parent])<br>         {<!-- --><br>             Swap(&amp;arr[parent], &amp;arr[child]);<br>             child = parent;<br>             parent = (child - 1) / 2;<br>         }<br>         else<br>         {<!-- --><br>             break;<br>         }<br>     }<br> }<br> void HPPush(HP* php, HPDataType x)<br> {<!-- --><br>     assert(php);<br>     //判断空间是否足够<br>     if (php-&gt;capacity == php-&gt;size)<br>     {<!-- --><br>         //扩容<br>         int newCapacity = php-&gt;capacity == 0 ? 4 : 2 * php-&gt;capacity;<br>         HPDataType* tmp = (HPDataType*)realloc(php-&gt;arr, newCapacity * sizeof(HPDataType));<br>         if (tmp == NULL)<br>         {<!-- --><br>             perror("realloc fail!");<br>             exit(1);<br>         }<br>         php-&gt;arr = tmp;<br>         php-&gt;capacity = newCapacity;<br>     }<br>     php-&gt;arr[php-&gt;size] = x;<br>     AdjustUp(php-&gt;arr, php-&gt;size);<br>     php-&gt;size++;<br> }<br> void AdjustDown(HPDataType* arr, int parent, int n)<br> {<!-- --><br>     int child = 2 * parent + 1;<br>     while (child &lt; n)<br>     {<!-- --><br>         //找左右孩子中最小的<br>         if (child +1 &lt; n &amp;&amp; arr[child] &gt; arr[child + 1])<br>         {<!-- --><br>             child++;<br>         }<br>         if (arr[parent] &gt; arr[child])<br>         {<!-- --><br>             Swap(&amp;arr[child], &amp;arr[parent]);<br>             parent = child;<br>             child = 2 * parent + 1;<br>         }<br>         else<br>         {<!-- --><br>             break;<br>         }<br>     }<br> }</p> 
 <p>void HPPop(HP* php)<br> {<!-- --><br>     assert(php &amp;&amp; php-&gt;size);<br>     Swap(&amp;php-&gt;arr[0], &amp;php-&gt;arr[php-&gt;size - 1]);<br>     --php-&gt;size;<br>     AdjustDown(php-&gt;arr, 0, php-&gt;size);<br> }<br> //判空<br> bool HPEmpty(HP* php)<br> {<!-- --><br>     assert(php);<br>     return php-&gt;size == 0;<br> }<br> HPDataType HPTop(HP* php)<br> {<!-- --><br>     assert(php &amp;&amp; php-&gt;size);//堆顶的元素不能为空<br>     return php-&gt;arr[0];<br> }</p> 
</blockquote> 
<blockquote> 
 <p>text.c</p> 
 <p>#define _CRT_SECURE_NO_WARNINGS 1<br> #include"Heap.h"<br> void text01()<br> {<!-- --><br>     HP hp;<br>     HPInit(&amp;hp);<br>     int arr[] = { 17,20,10,13,19,15 };</p> 
 <p>    for (int i = 0; i &lt; 6; i++)<br>     {<!-- --><br>         HPPush(&amp;hp, arr[i]);<br>     }<br>     while (!HPEmpty(&amp;hp))<br>     {<!-- --><br>         printf("%d ", HPTop(&amp;hp));<br>         HPPop(&amp;hp);<br>     }<br>     HPDestroy(&amp;hp);<br> }<br> int main()<br> {<!-- --><br>     text01();<br>     return 0;<br> }<br>  </p> 
</blockquote> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<div></div> 
<p></p> 
<p style="text-align:center;"></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4144fde66d587ea4675fd64f888cd140/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python的pip包管理工具使用和cmd介绍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ff293d0fae5c056c54f6b459a65ec953/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">全网最详细的postman接口测试教程，一篇文章满足你</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>