<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【排序算法】—— 希尔排序 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/985c4621ba8647f008d58ed898f9343c/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【排序算法】—— 希尔排序">
  <meta property="og:description" content="目录
一、希尔排序原理
二、希尔排序的思路
三、希尔排序为什么快
四、如何取增量
五、源码
希尔排序是简单插入排序的一种升级版，它也是用了插入的思想，而插入排序相比冒泡排序和选择排序的效率要高的多，再将它优化为希尔排序后效率跟原来根本就不在一个级别。接下来我们就一起来学习一下希尔排序
一、希尔排序原理 希尔排序的原理是插入排序，接下来先讲一下简单插入排序
简单插入排序原理：
首先假设第一个元素就是一个小数组并且是有序的，然后把第二个元素当做新加入的元素，依次往前遍历把它放在合适的位置保持小数组有序，同理把第三个元素当做新加入的元素，依次往前遍历把它放在合适的位置保持前面的小数组有序，依次重复下去直到把大数组的最后一个元素给放置好，这有点像高等代数里的基底扩充定理，从一个小的空间覆盖到整个大的空间。
动态图：
//简单插入排序 void InsertSort(int* a, int sz) { for (int i = 0; i &lt; sz - 1; i&#43;&#43;) { int j = i, tmp = a[i &#43; 1]; while (j &gt;= 0 &amp;&amp; tmp &lt; a[j]) { a[j &#43; 1] = a[j--]; } a[j &#43; 1] = tmp; } } 如果一个数组储存数据是顺序有序的时候效率是最高的时间复杂度为O(n)。
有的时候该排序遇到一些极端的情况还是比较低效的，比如需要将一组数组进行升序排序，如果这组数据恰好是降序(即逆有序)的话就会很麻烦时间复杂度O(N^2)，它需要将新元素前面的所有数据都遍历完。为了解决类似的问题就引入了希尔排序。
二、希尔排序的思路 希尔排序的原理还是插入排序，就是在做简单插入排序之前做一下预处排序，
先把数据分组，如上图分为(1),(2),(3)三组，然后分别对这三组进行简单插入排序，这是一次预排序。
那么这三组是如何分出来的呢？主要是涉及到一个增量的问题，如上图的增量是3，在取第(1)组元素时每隔3个元素取一次，第(2)第(3)组同样，直到把每个元素都取到。
排完上面三组后继续减小增量分组进行简单插入排序，比如排完以3为增量的三组后，再把增量变为2分为二组，最后当增量为1的时候相当于对整个大组做了一个简单插入排序，排完这一趟后这个数组就有序了，希尔排序结束。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-25T11:02:31+08:00">
    <meta property="article:modified_time" content="2024-06-25T11:02:31+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【排序算法】—— 希尔排序</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86" rel="nofollow">一、希尔排序原理</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%9D%E8%B7%AF-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%9D%E8%B7%AF" rel="nofollow">二、希尔排序的思路</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB" rel="nofollow">三、希尔排序为什么快</a></p> 
<p id="%E5%9B%9B%E3%80%81%E5%A6%82%E4%BD%95%E5%8F%96%E5%A2%9E%E9%87%8F-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E5%A6%82%E4%BD%95%E5%8F%96%E5%A2%9E%E9%87%8F" rel="nofollow">四、如何取增量</a></p> 
<p id="%E4%BA%94%E3%80%81%E6%BA%90%E7%A0%81-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E6%BA%90%E7%A0%81" rel="nofollow">五、源码</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p>        希尔排序是简单插入排序的一种升级版，它也是用了<span style="color:#fe2c24;">插入的思想</span>，而插入排序相比冒泡排序和选择排序的效率要高的多，再将它优化为希尔排序后效率跟原来根本就不在一个级别。接下来我们就一起来学习一下希尔排序</p> 
<h2 id="%E4%B8%80%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86">一、希尔排序原理</h2> 
<p>        希尔排序的原理是插入排序，接下来先讲一下简单插入排序</p> 
<p>简单插入排序原理：</p> 
<p>        首先假设第一个元素就是一个<span style="color:#fe2c24;">小数组</span>并且是有序的，然后把第二个元素当做<span style="color:#fe2c24;">新加入的元素</span>，依次<u><span style="color:#ff9900;">往前遍历把它放在合适的位置保持小数组有序</span></u>，同理把第三个元素当做新加入的元素，依次往前遍历把它放在合适的位置保持前面的小数组有序，依次重复下去直到把大数组的最后一个元素给放置好，这有点像高等代数里的<u>基底扩充定理</u>，从一个小的空间覆盖到整个大的空间。</p> 
<p>动态图：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/8e/55/QONzmYa0_o.gif"></p> 
<pre><code class="language-cpp">//简单插入排序
void InsertSort(int* a, int sz)
{
	for (int i = 0; i &lt; sz - 1; i++)
	{
		int j = i, tmp = a[i + 1];
		while (j &gt;= 0 &amp;&amp; tmp &lt; a[j])
		{
			a[j + 1] = a[j--];
		}
		a[j + 1] = tmp;
	}
}</code></pre> 
<p>        如果一个数组储存数据是<u>顺序有序</u>的时候效率是最高的<u>时间复杂度为O(n)</u>。</p> 
<p>        有的时候该排序遇到一些极端的情况还是比较低效的，比如需要将一组数组进行升序排序，如果这组数据恰好是降序(即<span style="color:#fe2c24;">逆有序</span>)的话就会很麻烦时间复杂度O(N^2)，它需要<span style="color:#4da8ee;">将新元素前面的所有数据都遍历完</span>。为了解决类似的问题就引入了希尔排序。</p> 
<h2 id="%E4%BA%8C%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%9D%E8%B7%AF">二、希尔排序的思路</h2> 
<p>        希尔排序的原理还是插入排序，就是在做简单插入排序之前做一下预处排序，</p> 
<p><img alt="" height="229" src="https://images2.imgbox.com/b0/61/NUpE7mTl_o.png" width="629"></p> 
<p>        先把数据<span style="color:#fe2c24;">分组</span>，如上图分为(1),(2),(3)三组，然后分别对这三组进行简单插入排序，这是一次预排序。</p> 
<p>        那么这三组是如何分出来的呢？主要是涉及到一个<span style="color:#fe2c24;">增量</span>的问题，如上图的增量是3，在取第(1)组元素时每隔3个元素取一次，第(2)第(3)组同样，直到把每个元素都取到。</p> 
<p>       排完上面三组后继续减小增量分组进行简单插入排序，比如排完以3为增量的三组后，再把增量变为2分为二组，最后当增量为1的时候相当于对整个大组做了一个简单插入排序，排完这一趟后这个数组就有序了，希尔排序结束。</p> 
<p><img alt="" height="267" src="https://images2.imgbox.com/f5/02/xZp3w7o7_o.png" width="940"></p> 
<p><img alt="" height="213" src="https://images2.imgbox.com/06/f7/TbVlLees_o.png" width="944"></p> 
<h2 id="%E4%B8%89%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB">三、希尔排序为什么快</h2> 
<p>        简单插入排序的时间复杂度为O(N^2)，而希尔排序的时间复杂度大概为<span style="color:#fe2c24;">O(N^1.3)</span>，当然这还与如何取增量有关。 </p> 
<p>        希尔排序确实比之前的简单插入排序所排的组数要多，因为简单插入排序相当于只排了一组，那么它为什么还那么快呢？ </p> 
<p>        因为它大大的<span style="color:#ff9900;">减少了数据挪动次数</span>，在做预排序的时候它是<span style="color:#fe2c24;">以增量的跨度去挪动</span>的，这就使一个<span style="color:#fe2c24;">数据更快的接近它的准确位置</span>(也就是排序后它该在的位置)。</p> 
<h2 id="%E5%9B%9B%E3%80%81%E5%A6%82%E4%BD%95%E5%8F%96%E5%A2%9E%E9%87%8F">四、如何取增量</h2> 
<p>        希尔排序的核心就在于通过设定不同的增量序列来优化插入排序的性能。增量序列的选择对排序速度有显著影响。一般来说，增量序列的选择涉及多种策略，而最佳的增量序列并没有一个固定的标准。比较常用效果比较好的增量设定为<span style="color:#fe2c24;">size/3+1</span>。size为数组长度。</p> 
<h2 id="%E4%BA%94%E3%80%81%E6%BA%90%E7%A0%81">五、源码</h2> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
//单组排
void ShellSort1(int* a, int sz)//(一组排完再排另一组)
{
	int gap = sz;//增量
	while (gap &gt; 1)
	{
		gap = gap / 3 + 1;
		for (int i = 0; i &lt; gap; i++)
		{
			for (int j = i; j &lt; sz - gap; j += gap)
			{
				int m = j;
				int tmp = a[j + gap];
				while (m &gt;= 0 &amp;&amp; tmp &lt; a[m])
				{
					a[m + gap] = a[m];
					m -= gap;
				}
				a[m + gap] = tmp;
			}
		}
	}
}
//多组一起排
void ShellSort2(int* a, int sz)
{
	int gap = sz;//增量
	while (gap &gt; 1)
	{
		gap = gap / 3 + 1;
		for (int i = 0; i &lt; sz - gap; i++)
		{
			int j = i;
			int tmp = a[i + gap];
			while (j &gt;= 0 &amp;&amp; tmp &lt; a[j])
			{
				a[j + gap] = a[j];
				j -= gap;
			}
			a[j + gap] = tmp;
		}
	}
}
int main()
{
	int arr[] = { 8,3,4,9,2,6,5,7,1,10 };
	int size = sizeof(arr) / sizeof(int);
	ShellSort1(arr, size);
	for (int i = 0; i &lt; size; i++)
		printf("%d ", arr[i]);
	return 0;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d4c2c98263be5e932b4bc5821847b90b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">手机远程控制另一台手机的全新使用教程（安卓版）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/09d64c163cc6d0a5ae1dae4ab3b77f7e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">毕业设计 多功能 Web 应用渗透测试系统（源码&#43;论文）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>