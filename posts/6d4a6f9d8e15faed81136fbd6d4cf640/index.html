<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构|C语言版】四大排序（算法） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/6d4a6f9d8e15faed81136fbd6d4cf640/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构|C语言版】四大排序（算法）">
  <meta property="og:description" content="前言1. 插入排序1.1 直接插入排序1.2 希尔排序 2. 选择排序2.1 选择排序2.2 堆排序 3. 交换排序3.1 冒泡排序冒泡排序的步骤 3.2 快速排序快速排序的步骤 4. 归并排序归并排序的步骤：代码解释：归并排序的性能： 上期回顾: 【数据结构|C语言版】栈和队列
个人主页：C_GUIQU
归属专栏：【数据结构（C语言版）学习】
前言 各位小伙伴大家好！上次小编给大家讲解了数据结构中的树、二叉树和堆，接下来我们讲解一下排序算法中的四大排序！
1. 插入排序 1.1 直接插入排序 直接插入排序（Straight Insertion Sort）是一种简单的排序算法，其主要思想是通过构建有序序列，对于未排序的数据，在已排序序列中从后向前扫描，找到相应位置并插入。该算法通常适用于少量数据的排序，时间复杂度为 (O(n^2))。
以下是直接插入排序的详细步骤：
初始化：
将数组的第一个元素视为一个有序序列，剩余的元素视为未排序序列。 从第一个未排序元素开始：
选择下一个未排序的元素。将这个元素插入到前面已经排序的序列中的适当位置。 寻找插入位置：
从已排序的序列中，从后向前扫描，找到第一个比当前元素小的元素的位置。如果遇到比当前元素大的元素，将该元素向后移动一位。 插入：
将当前元素插入到找到的位置。 重复步骤2-4：
对剩余的未排序元素重复上述过程，直到所有元素都被排序。 以下是直接插入排序的伪代码：
InsertionSort(A): for i = 1 to length(A) - 1: key = A[i] j = i - 1 while j &gt;= 0 and A[j] &gt; key: A[j &#43; 1] = A[j] j = j - 1 A[j &#43; 1] = key 通过一个具体的例子来说明：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-30T04:00:00+08:00">
    <meta property="article:modified_time" content="2024-06-30T04:00:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构|C语言版】四大排序（算法）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4> </h4> 
 <ul><li><a href="#_11" rel="nofollow">前言</a></li><li><a href="#1__16" rel="nofollow">1. 插入排序</a></li><li><ul><li><a href="#11__17" rel="nofollow">1.1 直接插入排序</a></li><li><a href="#12__71" rel="nofollow">1.2 希尔排序</a></li></ul> 
  </li><li><a href="#2__131" rel="nofollow">2. 选择排序</a></li><li><ul><li><a href="#21__132" rel="nofollow">2.1 选择排序</a></li><li><a href="#22__204" rel="nofollow">2.2 堆排序</a></li></ul> 
  </li><li><a href="#3__305" rel="nofollow">3. 交换排序</a></li><li><ul><li><a href="#31__306" rel="nofollow">3.1 冒泡排序</a></li><li><ul><li><a href="#_311" rel="nofollow">冒泡排序的步骤</a></li></ul> 
   </li><li><a href="#32__385" rel="nofollow">3.2 快速排序</a></li><li><ul><li><a href="#_388" rel="nofollow">快速排序的步骤</a></li></ul> 
  </li></ul> 
  </li><li><a href="#4__480" rel="nofollow">4. 归并排序</a></li><li><ul><li><ul><li><a href="#_482" rel="nofollow">归并排序的步骤：</a></li><li><a href="#_563" rel="nofollow">代码解释：</a></li><li><a href="#_568" rel="nofollow">归并排序的性能：</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<p><img src="https://images2.imgbox.com/65/f4/oNnZ0G5Z_o.gif" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/27/54/RhVwBHht_o.gif" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>上期回顾: <a href="http://t.csdnimg.cn/cLdZr" rel="nofollow">【数据结构|C语言版】栈和队列</a><br> 个人主页：<a href="https://blog.csdn.net/2302_80269373?type=blog">C_GUIQU</a><br> 归属专栏：<a href="https://blog.csdn.net/2302_80269373/category_12642757.html">【数据结构（C语言版）学习】</a></strong></p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/36/cd/6tDxW6bs_o.gif" alt="在这里插入图片描述"></p> 
<h2><a id="_11"></a>前言</h2> 
<p>各位小伙伴大家好！上次小编给大家讲解了数据结构中的树、二叉树和堆，接下来我们讲解一下排序算法中的四大排序！</p> 
<p><img src="https://images2.imgbox.com/f2/cd/00dl8QMP_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="1__16"></a>1. 插入排序</h2> 
<h3><a id="11__17"></a>1.1 直接插入排序</h3> 
<p>直接插入排序（Straight Insertion Sort）是一种简单的排序算法，其主要思想是通过构建有序序列，对于未排序的数据，在已排序序列中从后向前扫描，找到相应位置并插入。该算法通常适用于少量数据的排序，时间复杂度为 (O(n^2))。</p> 
<p>以下是直接插入排序的详细步骤：</p> 
<ol><li> <p><strong>初始化</strong>：</p> 
  <ul><li>将数组的第一个元素视为一个有序序列，剩余的元素视为未排序序列。</li></ul> </li><li> <p><strong>从第一个未排序元素开始</strong>：</p> 
  <ul><li>选择下一个未排序的元素。</li><li>将这个元素插入到前面已经排序的序列中的适当位置。</li></ul> </li><li> <p><strong>寻找插入位置</strong>：</p> 
  <ul><li>从已排序的序列中，从后向前扫描，找到第一个比当前元素小的元素的位置。</li><li>如果遇到比当前元素大的元素，将该元素向后移动一位。</li></ul> </li><li> <p><strong>插入</strong>：</p> 
  <ul><li>将当前元素插入到找到的位置。</li></ul> </li><li> <p><strong>重复步骤2-4</strong>：</p> 
  <ul><li>对剩余的未排序元素重复上述过程，直到所有元素都被排序。</li></ul> </li></ol> 
<p>以下是直接插入排序的伪代码：</p> 
<pre><code>InsertionSort(A):
  for i = 1 to length(A) - 1:
    key = A[i]
    j = i - 1
    while j &gt;= 0 and A[j] &gt; key:
      A[j + 1] = A[j]
      j = j - 1
    A[j + 1] = key
</code></pre> 
<p>通过一个具体的例子来说明：</p> 
<p>假设有一个数组 A = [5, 2, 4, 6, 1, 3]</p> 
<ol><li>初始状态： [5 | 2, 4, 6, 1, 3]</li><li>插入 2： [2, 5 | 4, 6, 1, 3]</li><li>插入 4： [2, 4, 5 | 6, 1, 3]</li><li>插入 6： [2, 4, 5, 6 | 1, 3]</li><li>插入 1： [1, 2, 4, 5, 6 | 3]</li><li>插入 3： [1, 2, 3, 4, 5, 6 | ]</li></ol> 
<p>最终排序后的数组为 [1, 2, 3, 4, 5, 6]</p> 
<p>直接插入排序的特点：</p> 
<ul><li><strong>稳定性</strong>：直接插入排序是稳定的排序算法，两个相等的元素在排序后相对位置不变。</li><li><strong>时间复杂度</strong>：最坏情况下（倒序）时间复杂度为 (O(n^2))，最优情况下（已排序）时间复杂度为 (O(n))。</li><li><strong>空间复杂度</strong>：直接插入排序是原地排序算法，空间复杂度为 (O(1))。</li></ul> 
<p>直接插入排序适用于数据量较小或者部分有序的序列，当数据量较大时，性能较差。</p> 
<h3><a id="12__71"></a>1.2 希尔排序</h3> 
<p>希尔排序（Shell Sort）是插入排序的一种改进版本，它通过将整个待排序的记录序列分割成若干子序列分别进行直接插入排序，以便在整个序列基本有序时，再对全体记录进行一次直接插入排序。这种方法克服了直接插入排序的局限性，使得希尔排序的时间复杂度显著降低。</p> 
<p>以下是希尔排序的详细步骤：</p> 
<ol><li> <p><strong>选择初始增量</strong>：</p> 
  <ul><li>选择一个增量序列，一般选择增量 ( \text{gap} ) 初始值为数组长度的一半，然后逐步缩小增量，直至增量为1。</li></ul> </li><li> <p><strong>分组</strong>：</p> 
  <ul><li>按照当前增量 ( \text{gap} ) 将数组分成若干子序列。每个子序列分别进行直接插入排序。</li></ul> </li><li> <p><strong>排序子序列</strong>：</p> 
  <ul><li>对每个子序列使用直接插入排序进行排序。</li></ul> </li><li> <p><strong>减小增量</strong>：</p> 
  <ul><li>缩小增量 ( \text{gap} )，重复步骤2-4，直到增量为1时，再进行最后一次直接插入排序。</li></ul> </li></ol> 
<p>以下是希尔排序的伪代码：</p> 
<pre><code>ShellSort(A):
  n = length(A)
  gap = n // 2
  while gap &gt; 0:
    for i = gap to n - 1:
      temp = A[i]
      j = i
      while j &gt;= gap and A[j - gap] &gt; temp:
        A[j] = A[j - gap]
        j = j - gap
      A[j] = temp
    gap = gap // 2
</code></pre> 
<p>通过一个具体的例子来说明希尔排序的过程：</p> 
<p>假设有一个数组 A = [9, 8, 3, 7, 5, 6, 4, 1]</p> 
<ol><li> <p>初始状态：</p> 
  <ul><li>数组长度 n = 8</li><li>初始增量 gap = 4</li></ul> </li><li> <p>第一次分组和排序：</p> 
  <ul><li>分组： [9, 5] [8, 6] [3, 4] [7, 1]</li><li>排序后： [5, 6, 4, 1, 9, 8, 3, 7]</li></ul> </li><li> <p>缩小增量 gap = 2：</p> 
  <ul><li>分组： [5, 4, 9, 3] [6, 1, 8, 7]</li><li>排序后： [4, 1, 3, 5, 7, 6, 8, 9]</li></ul> </li><li> <p>缩小增量 gap = 1：</p> 
  <ul><li>全体直接插入排序：</li><li>最终排序后： [1, 3, 4, 5, 6, 7, 8, 9]</li></ul> </li></ol> 
<p>希尔排序的特点：</p> 
<ul><li><strong>不稳定性</strong>：希尔排序是一个不稳定的排序算法，两个相等的元素在排序后相对位置可能会改变。</li><li><strong>时间复杂度</strong>：希尔排序的时间复杂度取决于增量序列的选择，最坏情况下时间复杂度为 (O(n^2))，但一般情况远优于直接插入排序，通常可以达到 (O(n \log^2 n))。</li><li><strong>空间复杂度</strong>：希尔排序是原地排序算法，空间复杂度为 (O(1))。</li></ul> 
<p>希尔排序通过分组和多次插入排序，显著减少了数据移动的次数，适用于中等规模的数据排序。</p> 
<h2><a id="2__131"></a>2. 选择排序</h2> 
<h3><a id="21__132"></a>2.1 选择排序</h3> 
<p>选择排序（Selection Sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。</p> 
<p>以下是选择排序的详细步骤：</p> 
<ol><li> <p><strong>初始状态</strong>：</p> 
  <ul><li>将整个数组视为未排序。</li></ul> </li><li> <p><strong>选择最小元素</strong>：</p> 
  <ul><li>在未排序的序列中找到最小（或最大）的元素，记录其位置。</li></ul> </li><li> <p><strong>交换元素</strong>：</p> 
  <ul><li>将找到的最小（或最大）元素与未排序序列的第一个元素交换。</li></ul> </li><li> <p><strong>缩小范围</strong>：</p> 
  <ul><li>将范围缩小，从下一个位置开始，重复步骤2-3，直到排序结束。</li></ul> </li></ol> 
<p>以下是选择排序的伪代码：</p> 
<pre><code>SelectionSort(A):
  n = length(A)
  for i = 0 to n - 2:
    min_index = i
    for j = i + 1 to n - 1:
      if A[j] &lt; A[min_index]:
        min_index = j
    if min_index != i:
      swap A[i] and A[min_index]
</code></pre> 
<p>通过一个具体的例子来说明选择排序的过程：</p> 
<p>假设有一个数组 A = [64, 25, 12, 22, 11]</p> 
<ol><li> <p>初始状态：</p> 
  <ul><li>未排序序列：[64, 25, 12, 22, 11]</li><li>已排序序列：[]</li></ul> </li><li> <p>第一次选择和交换：</p> 
  <ul><li>找到最小元素 11，交换到第一个位置</li><li>结果：[11, 25, 12, 22, 64]</li><li>未排序序列：[25, 12, 22, 64]</li><li>已排序序列：[11]</li></ul> </li><li> <p>第二次选择和交换：</p> 
  <ul><li>找到最小元素 12，交换到第二个位置</li><li>结果：[11, 12, 25, 22, 64]</li><li>未排序序列：[25, 22, 64]</li><li>已排序序列：[11, 12]</li></ul> </li><li> <p>第三次选择和交换：</p> 
  <ul><li>找到最小元素 22，交换到第三个位置</li><li>结果：[11, 12, 22, 25, 64]</li><li>未排序序列：[25, 64]</li><li>已排序序列：[11, 12, 22]</li></ul> </li><li> <p>第四次选择和交换：</p> 
  <ul><li>找到最小元素 25，交换到第四个位置</li><li>结果：[11, 12, 22, 25, 64]</li><li>未排序序列：[64]</li><li>已排序序列：[11, 12, 22, 25]</li></ul> </li><li> <p>最终排序后：</p> 
  <ul><li>结果：[11, 12, 22, 25, 64]</li></ul> </li></ol> 
<p>选择排序的特点：</p> 
<ul><li><strong>不稳定性</strong>：选择排序是一个不稳定的排序算法，因为相等元素的相对顺序可能会改变。</li><li><strong>时间复杂度</strong>：选择排序的时间复杂度为 (O(n^2))，无论数组是否有序。</li><li><strong>空间复杂度</strong>：选择排序是原地排序算法，空间复杂度为 (O(1))。</li></ul> 
<p>选择排序适用于数据量较小的序列排序，当数据量较大时，性能较差。</p> 
<h3><a id="22__204"></a>2.2 堆排序</h3> 
<p>在C语言中实现堆排序涉及到构建最大堆以及从最大堆中提取最大元素并重新调整堆的过程。下面是堆排序的完整实现代码：</p> 
<p>堆排序的实现步骤</p> 
<ol><li> <p><strong>定义堆调整函数 <code>heapify</code></strong>：</p> 
  <ul><li>用于维护堆的性质（最大堆）。</li></ul> </li><li> <p><strong>构建最大堆</strong>：</p> 
  <ul><li>从最后一个非叶子节点开始，向前调整每个节点。</li></ul> </li><li> <p><strong>排序过程</strong>：</p> 
  <ul><li>交换堆顶元素和最后一个元素，然后调整剩余元素为最大堆。</li></ul> </li></ol> 
<p>C语言代码</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token comment">// 交换两个元素的宏</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SWAP</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">int</span> temp <span class="token operator">=</span> x<span class="token punctuation">;</span> x <span class="token operator">=</span> y<span class="token punctuation">;</span> y <span class="token operator">=</span> temp<span class="token punctuation">;</span> <span class="token punctuation">}</span></span></span>

<span class="token comment">// 堆调整函数，维护最大堆性质</span>
<span class="token keyword">void</span> <span class="token function">heapify</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> largest <span class="token operator">=</span> i<span class="token punctuation">;</span>  <span class="token comment">// 初始化largest为根节点</span>
    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 左子节点</span>
    <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// 右子节点</span>

    <span class="token comment">// 如果左子节点存在且大于根节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span>
        largest <span class="token operator">=</span> left<span class="token punctuation">;</span>

    <span class="token comment">// 如果右子节点存在且大于根节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span>
        largest <span class="token operator">=</span> right<span class="token punctuation">;</span>

    <span class="token comment">// 如果largest不是根节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>largest <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">SWAP</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 交换</span>
        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> largest<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 递归地对受影响的子树进行调整</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 主堆排序函数</span>
<span class="token keyword">void</span> <span class="token function">heapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 构建最大堆</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 一个一个地从堆中取出元素</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">SWAP</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 移动当前根到数组末尾</span>
        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 调整减少后的堆</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 打印数组</span>
<span class="token keyword">void</span> <span class="token function">printArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 主函数</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Unsorted array: \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">heapSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Sorted array: \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>代码说明</p> 
<ol><li> <p><strong>宏定义 <code>SWAP</code></strong>：</p> 
  <ul><li>用于交换两个整数的值。</li></ul> </li><li> <p><strong><code>heapify</code> 函数</strong>：</p> 
  <ul><li>用于维护最大堆的性质。参数 <code>arr</code> 是待调整的数组，<code>n</code> 是数组的长度，<code>i</code> 是当前节点的索引。</li><li>它通过比较节点与其子节点的值，将最大值移到根位置，然后递归地调整受影响的子树。</li></ul> </li><li> <p><strong><code>heapSort</code> 函数</strong>：</p> 
  <ul><li>先构建最大堆，从最后一个非叶子节点开始向前调整。</li><li>然后从堆中依次取出最大值（堆顶），将其放到数组末尾，并调整剩余的元素为新的最大堆。</li></ul> </li><li> <p><strong><code>printArray</code> 函数</strong>：</p> 
  <ul><li>用于打印数组内容。</li></ul> </li><li> <p><strong><code>main</code> 函数</strong>：</p> 
  <ul><li>定义待排序的数组并调用 <code>heapSort</code> 函数进行排序，然后打印排序后的数组。</li></ul> </li></ol> 
<p>特点</p> 
<ul><li><strong>时间复杂度</strong>：堆排序的时间复杂度为 (O(n \log n))。</li><li><strong>空间复杂度</strong>：堆排序是原地排序算法，空间复杂度为 (O(1))。</li><li><strong>不稳定性</strong>：堆排序是不稳定的排序算法。</li></ul> 
<p>堆排序适用于需要保证较好最坏情况性能的排序场景。</p> 
<h2><a id="3__305"></a>3. 交换排序</h2> 
<h3><a id="31__306"></a>3.1 冒泡排序</h3> 
<p>冒泡排序（Bubble Sort）是一种简单的排序算法，它重复地遍历要排序的列表，比较相邻的元素并交换它们的位置，如果它们的顺序错误。遍历列表的工作是重复进行的，直到不需要再交换为止，也就是说列表已经排序完成。</p> 
<p>以下是冒泡排序的详细步骤和在C语言中的实现：</p> 
<h4><a id="_311"></a>冒泡排序的步骤</h4> 
<ol><li> <p><strong>遍历数组</strong>：</p> 
  <ul><li>从数组的第一个元素开始，依次比较相邻的两个元素，如果前一个元素大于后一个元素，则交换它们的位置。</li></ul> </li><li> <p><strong>重复步骤1</strong>：</p> 
  <ul><li>对于每一对相邻元素的比较和交换，重复该过程n-1次（n是数组的长度），每次都会将最大的元素"冒泡"到数组的末尾。</li></ul> </li><li> <p><strong>优化</strong>：</p> 
  <ul><li>可以在每一轮遍历中加入一个标志变量，如果在某一轮遍历中没有发生交换，说明数组已经排序完成，可以提前退出。</li></ul> </li></ol> 
<p>C语言实现代码</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token comment">// 冒泡排序函数</span>
<span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 标志变量用于检测是否发生交换</span>
        <span class="token keyword">int</span> swapped <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 交换相邻元素</span>
                <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
                swapped <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 如果在某一轮没有发生交换，说明数组已排序完成</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>swapped <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 打印数组函数</span>
<span class="token keyword">void</span> <span class="token function">printArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 主函数</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">/</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Unsorted array: \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token function">bubbleSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Sorted array: \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>代码说明</p> 
<ol><li> <p><strong><code>bubbleSort</code> 函数</strong>：</p> 
  <ul><li>传入一个数组 <code>arr</code> 和数组的长度 <code>n</code>。</li><li>外层循环控制遍历次数，内层循环进行相邻元素的比较和交换。</li><li>使用标志变量 <code>swapped</code> 检测在每一轮中是否发生交换，如果没有发生交换，说明数组已经有序，可以提前退出。</li></ul> </li><li> <p><strong><code>printArray</code> 函数</strong>：</p> 
  <ul><li>用于打印数组内容。</li></ul> </li><li> <p><strong><code>main</code> 函数</strong>：</p> 
  <ul><li>定义一个待排序的数组，调用 <code>bubbleSort</code> 函数进行排序，然后打印排序后的数组。</li></ul> </li></ol> 
<p>特点</p> 
<ul><li><strong>稳定性</strong>：冒泡排序是稳定的排序算法，因为相等元素的相对顺序不会改变。</li><li><strong>时间复杂度</strong>：最坏情况下和平均情况下时间复杂度为 (O(n^2))，最优情况下（已经有序）时间复杂度为 (O(n))。</li><li><strong>空间复杂度</strong>：冒泡排序是原地排序算法，空间复杂度为 (O(1))。</li></ul> 
<p>冒泡排序适用于数据量较小或基本有序的数组，对于较大的数据集，效率较低。</p> 
<h3><a id="32__385"></a>3.2 快速排序</h3> 
<p>快速排序（Quick Sort）是一种高效的排序算法，基于分治法（Divide and Conquer）。它的主要思想是选择一个基准元素（pivot），通过一趟排序将待排序列分成两部分，其中一部分的所有元素都比基准元素小，另一部分的所有元素都比基准元素大，然后递归地对这两部分进行快速排序。以下是快速排序的详细步骤和在C语言中的实现：</p> 
<h4><a id="_388"></a>快速排序的步骤</h4> 
<ol><li> <p><strong>选择基准元素</strong>：</p> 
  <ul><li>可以选择数组的第一个元素、最后一个元素、中间元素或者随机选择一个元素作为基准。</li></ul> </li><li> <p><strong>分区操作</strong>：</p> 
  <ul><li>通过一趟排序将数组分成两部分，使得基准元素左边的元素都小于基准元素，右边的元素都大于基准元素。</li></ul> </li><li> <p><strong>递归排序</strong>：</p> 
  <ul><li>对基准元素左边和右边的子数组递归地进行快速排序。</li></ul> </li></ol> 
<p>C语言实现代码</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token comment">// 交换两个元素的宏</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SWAP</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">int</span> temp <span class="token operator">=</span> x<span class="token punctuation">;</span> x <span class="token operator">=</span> y<span class="token punctuation">;</span> y <span class="token operator">=</span> temp<span class="token punctuation">;</span> <span class="token punctuation">}</span></span></span>

<span class="token comment">// 分区函数</span>
<span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 选择最后一个元素作为基准</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// i是较小元素的索引</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> low<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> high<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 如果当前元素小于或等于基准</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            i<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 增加较小元素的索引</span>
            <span class="token function">SWAP</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 交换</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">SWAP</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 交换基准和i+1位置的元素</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回基准的索引</span>
<span class="token punctuation">}</span>

<span class="token comment">// 快速排序函数</span>
<span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// pi是分区索引，arr[pi]是基准元素</span>
        <span class="token keyword">int</span> pi <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 递归地排序基准元素的左右两部分</span>
        <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> pi <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> pi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 打印数组函数</span>
<span class="token keyword">void</span> <span class="token function">printArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 主函数</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">/</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Unsorted array: \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Sorted array: \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>代码说明</p> 
<ol><li> <p><strong>宏定义 <code>SWAP</code></strong>：</p> 
  <ul><li>用于交换两个整数的值。</li></ul> </li><li> <p><strong><code>partition</code> 函数</strong>：</p> 
  <ul><li>选择数组的最后一个元素作为基准元素 <code>pivot</code>。</li><li>初始化较小元素的索引 <code>i</code> 为 <code>low - 1</code>。</li><li>遍历数组，将小于或等于 <code>pivot</code> 的元素移到数组的左侧，大于 <code>pivot</code> 的元素移到右侧。</li><li>最后交换基准元素和 <code>i+1</code> 位置的元素，并返回 <code>i+1</code> 作为分区索引。</li></ul> </li><li> <p><strong><code>quickSort</code> 函数</strong>：</p> 
  <ul><li>递归地对数组的左半部分和右半部分进行快速排序。</li></ul> </li><li> <p><strong><code>printArray</code> 函数</strong>：</p> 
  <ul><li>用于打印数组内容。</li></ul> </li><li> <p><strong><code>main</code> 函数</strong>：</p> 
  <ul><li>定义一个待排序的数组，调用 <code>quickSort</code> 函数进行排序，然后打印排序后的数组。</li></ul> </li></ol> 
<p>特点</p> 
<ul><li><strong>不稳定性</strong>：快速排序是不稳定的排序算法，因为相等元素的相对顺序可能会改变。</li><li><strong>时间复杂度</strong>：平均时间复杂度为 (O(n \log n))，最坏情况下时间复杂度为 (O(n^2))（当每次选择的基准元素是最小或最大的元素）。</li><li><strong>空间复杂度</strong>：快速排序的空间复杂度为 (O(\log n))，用于递归栈。</li></ul> 
<p>快速排序适用于大多数情况下的排序任务，尤其适合大规模数据的排序，因为其平均时间复杂度较低。</p> 
<h2><a id="4__480"></a>4. 归并排序</h2> 
<p>归并排序（Merge Sort）是一种经典的排序算法，其基本思想是将两个或两个以上的有序表组合成一个新的有序表。在C语言中实现归并排序，通常采用递归的方式。下面我会详细讲解C语言中归并排序的实现步骤和代码。</p> 
<h4><a id="_482"></a>归并排序的步骤：</h4> 
<ol><li><strong>分解</strong>：将待排序的列表分解成若干个长度为1的子列表，然后两两合并，得到若干个有序的子列表。</li><li><strong>合并</strong>：将相邻的有序子列表合并成一个新的有序列表，直到最后合并成一个有序的列表。</li></ol> 
<p>C语言实现：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token comment">// 归并所需的辅助数组</span>
<span class="token keyword">int</span> <span class="token operator">*</span>temp<span class="token punctuation">;</span>
<span class="token comment">// 归并函数，将两个有序数组合并成一个有序数组</span>
<span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">;</span>
    <span class="token keyword">int</span> n1 <span class="token operator">=</span> m <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 左子数组的长度</span>
    <span class="token keyword">int</span> n2 <span class="token operator">=</span> r <span class="token operator">-</span> m<span class="token punctuation">;</span>     <span class="token comment">// 右子数组的长度</span>
    <span class="token comment">// 将数组复制到辅助数组中</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n1<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        temp<span class="token punctuation">[</span>l <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>l <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n2<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
        temp<span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> j<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 合并临时数组回到原数组中</span>
    i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 初始索引第一个子数组</span>
    j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 初始索引第二个子数组</span>
    k <span class="token operator">=</span> l<span class="token punctuation">;</span> <span class="token comment">// 初始索引合并的子数组</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n1 <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> n2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>temp<span class="token punctuation">[</span>l <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> temp<span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>l <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            j<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        k<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 复制剩余的元素到数组（如果有的话）</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n1<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>l <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        i<span class="token operator">++</span><span class="token punctuation">;</span>
        k<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> n2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        j<span class="token operator">++</span><span class="token punctuation">;</span>
        k<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 主函数，用于递归地排序数组</span>
<span class="token keyword">void</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 找到中间点</span>
        <span class="token keyword">int</span> m <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token comment">// 分别对前半部分和后半部分进行排序</span>
        <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 合并两部分</span>
        <span class="token function">merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 辅助函数，用于打印数组</span>
<span class="token keyword">void</span> <span class="token function">printArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 主函数</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> arr_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 动态分配临时数组</span>
    temp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>arr_size <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"给定的数组：\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> arr_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr_size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"排序后的数组：\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> arr_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 释放临时数组</span>
    <span class="token function">free</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_563"></a>代码解释：</h4> 
<ul><li><code>mergeSort()</code> 函数是递归函数，用于不断地将数组对半分，直到每个子数组的长度为1。</li><li><code>merge()</code> 函数负责将两个有序数组合并成一个有序数组。</li><li><code>temp</code> 是一个辅助数组，用于在合并过程中存储数据，避免直接在原数组上操作可能导致的元素丢失。</li><li><code>main()</code> 函数中初始化了待排序的数组，并调用了 <code>mergeSort()</code> 进行排序，最后打印排序后的数组。</li></ul> 
<h4><a id="_568"></a>归并排序的性能：</h4> 
<ul><li><strong>时间复杂度</strong>：(O(n \log n))，无论是最好、最坏还是平均情况，归并排序的时间复杂度都是 (O(n \log n))。</li><li><strong>空间复杂度</strong>：(O(n))，因为需要一个额外的数组来存储临时数据。</li><li><strong>稳定性</strong>：归并排序是稳定的排序算法，即相等的元素在排序后会保持其原有的顺序。<br> 归并排序在处理大数据集时表现良好，是效率高且稳定的排序算法。</li></ul> 
<p>以上就是小编对四大排序的讲解。<br> 如果觉得小编讲的还可以，还请一键三连。互三必回！<br> 持续更新中~！</p> 
<p><img src="https://images2.imgbox.com/2d/ec/VFDg70sC_o.gif" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/da/d2/EoKV5jyd_o.gif" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e4c170cb7db65222214270d490f8eb3d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【小沐学AI】Python实现语音识别（faster-whisper-webui）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b4ca26aaea3e13213e4fb808ce19eb0c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">前端 Vite 项目使用 vite-plugin-dts 打包输出.d.ts文件，分析处理踩坑：Cannot find module ‘vue‘. Did you mean to set ...</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>