<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;从小白到大牛】C&#43;&#43;智能指针的使用、原理和分类 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/6619258e951e622d12fbab68e1892e95/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;从小白到大牛】C&#43;&#43;智能指针的使用、原理和分类">
  <meta property="og:description" content="目录
1、我们为什么需要智能指针？
2、内存泄露
2.1 什么是内存泄漏，内存泄漏的危害
2.2如何避免内存泄漏
总结一下:
3.智能指针的使用及原理
3.1 RAII
3.2关于深拷贝和浅拷贝更深层次的理解：
3.3 std::auto_ptr
3.4 std::unique_ptr
3.5 std::shared_ptr
引用计数的原理：
原码：
std::shared_ptr的循环引用（特定场景下的缺陷）
很坑的赋值重载函数
智能指针的缺陷：（循环引用）
解决方案：
1、我们为什么需要智能指针？ 下面我们先分析一下下面这段程序有没有什么内存方面的问题？
解析：
这里如果是p1的new抛异常了 那么首先p1是申请空间失败的 然后程序跳转到异常处理机制，如果main函数中没有对异常捕捉，那么程序就终止了。
如果是p2的new抛异常了 那么大体和p1抛异常一样。区别在于p1这个指针申请的空间就会内存泄漏，因为p1已经申请成功了但是由于抛异常下面的delete语句不再执行！
div抛异常也一样 只不过这个时候p1和p2开辟的空间都会造成内存泄漏！
2、内存泄露 2.1 什么是内存泄漏，内存泄漏的危害 什么是内存泄漏：内存泄漏指因为疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并不是指内存在物理上的消失，而是应用程序分配某段内存后，因为设计错误，失去了对该段内存的控制，因而造成了内存的浪费。
内存泄漏的危害：长期运行的程序出现内存泄漏，影响很大，如操作系统、后台服务等等，出现内存泄漏会导致响应越来越慢，最终卡死。
void MemoryLeaks() { // 1.内存申请了忘记释放 int* p1 = (int*)malloc(sizeof(int)); int* p2 = new int; // 2.异常安全问题 int* p3 = new int[10]; Func(); // 这里Func函数抛异常导致 delete[] p3未执行，p3没被释放. delete[] p3; } 2.2如何避免内存泄漏 1. 工程前期良好的设计规范，养成良好的编码规范，申请的内存空间记着匹配的去释放。ps：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-25T21:18:23+08:00">
    <meta property="article:modified_time" content="2024-08-25T21:18:23+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;从小白到大牛】C&#43;&#43;智能指针的使用、原理和分类</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="1181" src="https://images2.imgbox.com/e0/ef/zoVAIAy0_o.jpg" width="1200"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1%E3%80%81%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%9F-toc" style="margin-left:0px;"><a href="#1%E3%80%81%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%9F" rel="nofollow">1、我们为什么需要智能指针？</a></p> 
<p id="2%E3%80%81%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2-toc" style="margin-left:0px;"><a href="#2%E3%80%81%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2" rel="nofollow">2、内存泄露</a></p> 
<p id="2.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8D%B1%E5%AE%B3-toc" style="margin-left:40px;"><a href="#2.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8D%B1%E5%AE%B3" rel="nofollow">2.1 什么是内存泄漏，内存泄漏的危害</a></p> 
<p id="2.2%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F-toc" style="margin-left:40px;"><a href="#2.2%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F" rel="nofollow">2.2如何避免内存泄漏</a></p> 
<p id="%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%3A-toc" style="margin-left:40px;"><a href="#%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%3A" rel="nofollow">总结一下:</a></p> 
<p id="3.%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86-toc" style="margin-left:0px;"><a href="#3.%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86" rel="nofollow">3.智能指针的使用及原理</a></p> 
<p id="3.1%20RAII-toc" style="margin-left:40px;"><a href="#3.1%20RAII" rel="nofollow">3.1 RAII</a></p> 
<p id="3.2%E5%85%B3%E4%BA%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%9B%B4%E6%B7%B1%E5%B1%82%E6%AC%A1%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9A-toc" style="margin-left:40px;"><a href="#3.2%E5%85%B3%E4%BA%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%9B%B4%E6%B7%B1%E5%B1%82%E6%AC%A1%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9A" rel="nofollow">3.2关于深拷贝和浅拷贝更深层次的理解：</a></p> 
<p id="3.3%20std%3A%3Aauto_ptr-toc" style="margin-left:40px;"><a href="#3.3%20std%3A%3Aauto_ptr" rel="nofollow">3.3 std::auto_ptr</a></p> 
<p id="3.4%20std%3A%3Aunique_ptr-toc" style="margin-left:40px;"><a href="#3.4%20std%3A%3Aunique_ptr" rel="nofollow">3.4 std::unique_ptr</a></p> 
<p id="3.5%20std%3A%3Ashared_ptr-toc" style="margin-left:40px;"><a href="#3.5%20std%3A%3Ashared_ptr" rel="nofollow">3.5 std::shared_ptr</a></p> 
<p id="%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9A" rel="nofollow">引用计数的原理：</a></p> 
<p id="%E5%8E%9F%E7%A0%81%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%8E%9F%E7%A0%81%EF%BC%9A" rel="nofollow">原码：</a></p> 
<p id="std%3A%3Ashared_ptr%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%EF%BC%88%E7%89%B9%E5%AE%9A%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E7%BC%BA%E9%99%B7%EF%BC%89-toc" style="margin-left:80px;"><a href="#std%3A%3Ashared_ptr%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%EF%BC%88%E7%89%B9%E5%AE%9A%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E7%BC%BA%E9%99%B7%EF%BC%89" rel="nofollow">std::shared_ptr的循环引用（特定场景下的缺陷）</a></p> 
<p id="%E5%BE%88%E5%9D%91%E7%9A%84%E8%B5%8B%E5%80%BC%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E5%BE%88%E5%9D%91%E7%9A%84%E8%B5%8B%E5%80%BC%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0" rel="nofollow">很坑的赋值重载函数</a></p> 
<p id="%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E7%BC%BA%E9%99%B7%EF%BC%9A%EF%BC%88%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E7%BC%BA%E9%99%B7%EF%BC%9A%EF%BC%88%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%EF%BC%89" rel="nofollow">智能指针的缺陷：（循环引用）</a></p> 
<p id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A-toc" style="margin-left:120px;"><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A" rel="nofollow">解决方案：</a></p> 
<p><img alt="" height="80" src="https://images2.imgbox.com/af/9f/iDJ2hoJc_o.gif" width="640"></p> 
<h2 id="1%E3%80%81%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%9F">1、我们为什么需要智能指针？</h2> 
<p>下面我们先分析一下下面这段程序有没有什么内存方面的问题？</p> 
<p class="img-center"><img alt="" height="339" src="https://images2.imgbox.com/0e/a3/AKLcEiRV_o.png" width="449"></p> 
<p>解析：</p> 
<p>这里如果是p1的new抛异常了 那么首先p1是申请空间失败的  然后程序跳转到异常处理机制，如果main函数中没有对异常捕捉，那么程序就终止了。</p> 
<p>如果是p2的new抛异常了 那么大体和p1抛异常一样。区别在于<span style="background-color:#ffd900;"><span style="color:#fe2c24;">p1</span>这个指针申请的空间就会<span style="color:#fe2c24;">内存泄漏</span></span>，因为p1已经申请成功了但是由于抛异常下面的delete语句不再执行！</p> 
<p>div抛异常也一样 只不过这个时候<span style="background-color:#ffd900;"><span style="color:#fe2c24;">p1和p2</span>开辟的空间都会<span style="color:#fe2c24;">造成内存泄漏</span></span>！</p> 
<h2 id="2%E3%80%81%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2">2、内存泄露</h2> 
<h3 id="2.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8D%B1%E5%AE%B3">2.1 什么是内存泄漏，内存泄漏的危害</h3> 
<p>什么是内存泄漏：内存泄漏指因为疏忽或错误造成<strong>程序未能释放已经不再使用的内存的情况</strong>。内存泄漏并不是指内存在物理上的消失，而是应用程序分配某段内存后，因为设计错误，失去了对该段内存的控制，因而造成了内存的浪费。</p> 
<p>内存泄漏的危害：长期运行的程序出现内存泄漏，影响很大，如操作系统、后台服务等等，出现内存泄漏会导致响应越来越慢，最终卡死。</p> 
<pre><code class="language-cpp">void MemoryLeaks()
{
   // 1.内存申请了忘记释放
  int* p1 = (int*)malloc(sizeof(int));
  int* p2 = new int;
  
  // 2.异常安全问题
  int* p3 = new int[10];
  
  Func(); // 这里Func函数抛异常导致 delete[] p3未执行，p3没被释放.
  
  delete[] p3;
}</code></pre> 
<h3 id="2.2%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">2.2如何避免内存泄漏</h3> 
<p>1. 工程前期良好的设计规范，养成良好的编码规范，申请的内存空间记着匹配的去释放。ps：<br> 这个理想状态。但是如果碰上异常时，就算注意释放了，还是可能会出问题。需要下一条智能指针来管理才有保证。</p> 
<p>2. 采用RAII思想或者智能指针来管理资源。</p> 
<p>3. 有些公司内部规范使用内部实现的私有内存管理库。这套库自带内存泄漏检测的功能选项。4. 出问题了使用内存泄漏工具检测。ps：不过很多工具都不够靠谱，或者收费昂贵。</p> 
<h3 id="%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%3A">总结一下:</h3> 
<p>内存泄漏非常常见，解决方案分为两种：1、事前预防型。如智能指针等。2、事后查错型。如泄漏检测工具。</p> 
<h2 id="3.%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86">3.智能指针的使用及原理</h2> 
<h3 id="3.1%20RAII">3.1 RAII</h3> 
<p>RAII（Resource Acquisition Is Initialization资源立即初始化）是一种<strong>利用对象生命周期来控制程序资源</strong>（如内存、文件句柄、网络连接、互斥量等等）的简单技术。</p> 
<p>在<strong>对象构造时获取资源</strong>，接着控制对资源的访问使之在对象的生命周期内始终保持有效，最后在<strong>对象析构的时候释放资源</strong>。借此，我们实际上把管理一份资源的责任托管给了一个对象。这种做法有两大好处：</p> 
<ul><li>不需要显式地释放资源。</li><li>采用这种方式，对象所需的资源在其生命期内始终保持有效。</li></ul> 
<p>所以我们把资源的获取和释放交给了一个智能指针类，让这个类帮我们完成，所以就不需要关心会报错异常导致内存泄漏的问题。并且这个类<strong>还得需要将* 、-&gt;重载下，才可让其像指针一样去使用</strong>。</p> 
<p>原码：</p> 
<pre><code class="language-cpp">template&lt;class T&gt;
class SmartPtr {
public:
SmartPtr(T* ptr = nullptr)
     : _ptr(ptr)
 {}
~SmartPtr()
 {
     if(_ptr)
         delete _ptr;
 }
T&amp; operator*() {return *_ptr;}
T* operator-&gt;() {return _ptr;}
private:
T* _ptr;
};</code></pre> 
<p>总结一下智能指针的原理：</p> 
<ol><li>RAII特性</li><li> 重载operator*和opertaor-&gt;，具有像指针一样的行为。</li></ol> 
<h3 id="3.2%E5%85%B3%E4%BA%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%9B%B4%E6%B7%B1%E5%B1%82%E6%AC%A1%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9A">3.2关于深拷贝和浅拷贝更深层次的理解：</h3> 
<p>vector/list……采用深拷贝的原因：利用资源存储管理数据，资源是自己的，拷贝时，每个对象各自一份资源，各管各的，所以深拷贝。</p> 
<p>智能指针/迭代器……采用浅拷贝的原因：本质资源不是自己的，代为持有，方便访问修改数据。他们拷贝的时候期望指向同一个资源，所以浅拷贝！</p> 
<h3 id="3.3%20std%3A%3Aauto_ptr">3.3 std::auto_ptr</h3> 
<p>C++98版本的库中就提供了auto_ptr的智能指针。下面演示的auto_ptr的使用及问题。</p> 
<pre><code class="language-cpp">	template&lt;class T&gt;
	class auto_ptr
	{
	public:
		// RAII
		auto_ptr(T* ptr)
			:_ptr(ptr)
		{}

		// ap2(ap1)
		auto_ptr(auto_ptr&lt;T&gt;&amp; ap)
		{
			_ptr = ap._ptr;
			ap._ptr = nullptr;
		}

		~auto_ptr()
		{
			cout &lt;&lt; "delete:" &lt;&lt; _ptr &lt;&lt; endl;

			delete _ptr;
		}

		// 像指针一样
		T&amp; operator*()
		{
			return *_ptr;
		}

		T* operator-&gt;()
		{
			return _ptr;
		}

	private:
		T* _ptr;
	};</code></pre> 
<p><img alt="" height="411" src="https://images2.imgbox.com/40/56/qB6qRRJM_o.png" width="976"></p> 
<p>auto_ptr<strong><span style="color:#fe2c24;"><span style="background-color:#ffd900;"> 管理权转移</span></span></strong>，被拷贝对象把资源管理权转移给拷贝对象，<span style="color:#fe2c24;">导致被拷贝对象悬空！</span></p> 
<p>注意拷贝过后不能访问被拷贝对象，否则就出现空指针了。很多公司<span style="color:#fe2c24;">禁止使用它</span>，因为他很坑！</p> 
<h3 id="3.4%20std%3A%3Aunique_ptr">3.4 std::unique_ptr</h3> 
<p>C++11中开始提供更靠谱的unique_ptr </p> 
<p>unique_ptr的实现原理：<strong><span style="color:#fe2c24;"><span style="background-color:#ffd900;">简单粗暴的防拷贝</span></span></strong>，禁止拷贝，简单粗暴，适合于不需要拷贝的场景。下面简化模拟实现了一份UniquePtr来了解它的原理</p> 
<pre><code class="language-cpp">	template&lt;class T&gt;
	class unique_ptr
	{
	public:
		// RAII
		unique_ptr(T* ptr)
			:_ptr(ptr)
		{}

		// ap2(ap1)
        //直接将拷贝函数和复制重载函数不实现，赋值为delete
		unique_ptr(const unique_ptr&lt;T&gt;&amp; ap) = delete;
		unique_ptr&lt;T&gt;&amp; operator=(const unique_ptr&lt;T&gt;&amp; ap) = delete;

		~unique_ptr()
		{
			cout &lt;&lt; "delete:" &lt;&lt; _ptr &lt;&lt; endl;

			delete _ptr;
		}

		// 像指针一样
		T&amp; operator*()
		{
			return *_ptr;
		}

		T* operator-&gt;()
		{
			return _ptr;
		}

	private:
		T* _ptr;
	};</code></pre> 
<h3 id="3.5%20std%3A%3Ashared_ptr">3.5 std::shared_ptr</h3> 
<p>C++11中开始提供更靠谱的并且支持拷贝的shared_ptr</p> 
<p>那我们如何才能支持拷贝呢？</p> 
<p>我们采取使用<span style="color:#fe2c24;"><strong><span style="background-color:#ffd900;">引用计数</span></strong></span>的方式来解决。记录有几个对象参与管理这个资源。</p> 
<p>可以直接采用count整形直接++吗？</p> 
<p><img alt="" height="137" src="https://images2.imgbox.com/37/5c/i0eJnb5r_o.png" width="325"></p> 
<p>不可以，我们这里要求每份资源分配一个计数，而这里是每指向一份资源调用的智能指针就分配一个计数，也就是我们<span style="color:#fe2c24;">要求的是公共计数，而不是每个智能指针单独的计数</span>。</p> 
<p>可以采用静态成员变量来解决这个问题吗？</p> 
<p>sharedptr 为什么用静态的引用计数不行，因为静态成员属于这个类，属于这个类的所有对象</p> 
<p></p> 
<p>不可以。因为静态成员属于这个类，属于这个类的所有对象。而我们的需求是每个资源配一个引用计数，而不是全部是一个引用计数。</p> 
<p><img alt="" height="408" src="https://images2.imgbox.com/0a/4c/p1LP7enR_o.png" width="1200"></p> 
<p>所以这里只释放了一份资源，另一份资源没有释放</p> 
<p>正确的解法是每个对象存一个指向计数的指针，而指针指向的内容<span style="color:#fe2c24;"><strong><span style="background-color:#ffd900;">只在构造的时候进行初始化构造单独这一份</span></strong></span><span style="background-color:#ffd900;">，拷贝的时候，++计数，智能指针析构的时候--计数，只有当引用计数减到0时，才真正释放这份资源</span>！</p> 
<h4 id="%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9A">引用计数的原理：</h4> 
<p>1. shared_ptr在其内部，给每个资源都维护了着一份计数，用来记录该份资源被几个对象共<br> 享。<br> 2. 在对象被销毁时(也就是析构函数调用)，就说明自己不使用该资源了，对象的引用计数减<br> 一。<br> 3. 如果引用计数是0，就说明自己是最后一个使用该资源的对象，必须释放该资源；<br> 4. 如果不是0，就说明除了自己还有其他对象在使用该份资源，不能释放该资源，否则其他对<br> 象就成野指针了。</p> 
<h4 id="%E5%8E%9F%E7%A0%81%EF%BC%9A">原码：</h4> 
<pre><code class="language-cpp">	template&lt;class T&gt;
	class shared_ptr
	{
	public:
		// RAII
		shared_ptr(T* ptr = nullptr)
			:_ptr(ptr)
			,_pcount(new int(1))
		{}

		// sp2(sp1)
		shared_ptr(const shared_ptr&lt;T&gt;&amp; sp)
		{
			_ptr = sp._ptr;
			_pcount = sp._pcount;

			// 拷贝时++计数
			++(*_pcount);
		}

		// sp1 = sp4
		// sp4 = sp4;
		// sp1 = sp2;
		shared_ptr&lt;T&gt;&amp; operator=(const shared_ptr&lt;T&gt;&amp; sp)
		{
			//if (this != &amp;sp)
			if (_ptr != sp._ptr)
			{
				release();

				_ptr = sp._ptr;
				_pcount = sp._pcount;

				// 拷贝时++计数
				++(*_pcount);
			}

			return *this;
		}

		void release()
		{
			// 说明最后一个管理对象析构了，可以释放资源了
			if (--(*_pcount) == 0)
			{
				cout &lt;&lt; "delete:" &lt;&lt; _ptr &lt;&lt; endl;
				delete _ptr;
				delete _pcount;
			}
		}

		~shared_ptr()
		{
			// 析构时，--计数，计数减到0，
			release();
		}

		int use_count()
		{
			return *_pcount;
		}

		// 像指针一样
		T&amp; operator*()
		{
			return *_ptr;
		}

		T* operator-&gt;()
		{
			return _ptr;
		}

		T* get() const
		{
			return _ptr;
		}
	private:
		T* _ptr;
		int* _pcount;
	};</code></pre> 
<h4 id="std%3A%3Ashared_ptr%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%EF%BC%88%E7%89%B9%E5%AE%9A%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E7%BC%BA%E9%99%B7%EF%BC%89">std::shared_ptr的循环引用（特定场景下的缺陷）</h4> 
<p>那我们的share_ptr智能指针就是完美的吗？其实也并不是。</p> 
<h4 id="%E5%BE%88%E5%9D%91%E7%9A%84%E8%B5%8B%E5%80%BC%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0">很坑的赋值重载函数</h4> 
<p class="img-center"><img alt="" height="423" src="https://images2.imgbox.com/89/47/DwgJC8Zw_o.png" width="337"></p> 
<p>这里的sp1 = sp4，会将sp1的指针指向sp4指向的资源，<span style="color:#fe2c24;"><span style="background-color:#ffd900;">但是原来sp1指向的资源需要--引用计数，不然会引起内存泄露</span></span>！！！</p> 
<p>赋值重载函数很坑，注意先--计数，因为赋值给别人了，</p> 
<p>自己可能赋值给自己，很坑！</p> 
<pre><code class="language-cpp">shared_ptr&lt;T&gt;&amp; operator=(const shared_ptr&lt;T&gt;&amp; sp)
		{
			//if (this != &amp;sp)防止自己给自己赋值
			if (_ptr != sp._ptr)
			{
				release();

				_ptr = sp._ptr;
				_pcount = sp._pcount;

				// 拷贝时++计数
				++(*_pcount);
			}

			return *this;
		}</code></pre> 
<h4 id="%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E7%BC%BA%E9%99%B7%EF%BC%9A%EF%BC%88%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%EF%BC%89">智能指针的缺陷：（循环引用）</h4> 
<p><img alt="" height="589" src="https://images2.imgbox.com/60/f8/UnQf3H6x_o.png" width="1200"></p> 
<p>这里为什么n2的生命周期先到？因为对象调用构造函数和调用析构函数的顺序相反，这里先构造n1，后构造n2,所以就会先析构n2，因此n2的生命周期先到！</p> 
<p><span style="color:#fe2c24;">我们只有一个语句时就不会报错，具体分析如下</span>：</p> 
<p>首先出了作用域，n2的生命周期先到，那么n2的引用计数就--，变成了1，再紧接着，n1的生命周期到了，所以n1的引用计数就-到了0，因此就要释放掉，就会将n1结点的资源释放掉，这样n2的引用计数就会变成0，所以就会将n2结点的资源也释放掉，因此释放空间没问题，不会造成泄露</p> 
<p><span style="background-color:#ffd900;">但是这两句话同时存在，就会存在<span style="color:#fe2c24;">循环引用</span>的问题</span>，具体分析如下：</p> 
<p><img alt="" height="880" src="https://images2.imgbox.com/ce/6b/R8rWWIp2_o.png" width="1200"></p> 
<p>1. node1和node2两个智能指针对象指向两个节点，引用计数变成1，我们不需要手动<br> delete。<br> 2. node1的_next指向node2，node2的_prev指向node1，引用计数变成2。<br> 3. node1和node2析构，引用计数减到1，但是_next还指向下一个节点。但是_prev还指向上<br> 一个节点。<br> 4. 也就是说node1的_next析构了，node2就释放了。<br> 5. 也就是说node2的_prev析构了，node1就释放了。<br> 6. 但是_next属于node1的成员，node1释放了，_next才会析构，而node1由node2的_prev管理，_prev属于node2成员，所以这就叫循环引用，谁也不会释放，互相牵制！</p> 
<p>也就是引用计数一直在1，不会减到0，也就不会析构了。</p> 
<h5 id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A">解决方案：</h5> 
<p>我们采用weak_ptr不会将引用计数++，不会增加计数。</p> 
<p>在引用计数的场景下，把节点中的_prev和_next改成weak_ptr就可以了<br> 原理就是，node1-&gt;_next = node2;和node2-&gt;_prev = node1;时<span style="background-color:#ffd900;">weak_ptr的_next和</span><br><span style="background-color:#ffd900;">_prev<span style="color:#fe2c24;">不会增加</span>node1和node2的<span style="color:#fe2c24;">引用计数</span></span>。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4e40a55e06910c96cbb1c0b131c1d075/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据结构【链试结构二叉树】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/eae3e4ad3a0ec167bee477371fcf659d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">每日一练【最大连续1的个数 III】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>