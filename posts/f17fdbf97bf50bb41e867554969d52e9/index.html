<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;】STL中stack和queue(适配器版)的模拟实现 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/f17fdbf97bf50bb41e867554969d52e9/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;】STL中stack和queue(适配器版)的模拟实现">
  <meta property="og:description" content="前言：在此之前我们讲到了stack和queue还有deque的常见的使用方法，并且也在数据结构的时候用C语言去实现过栈和队列，今天我们将进一步的用C&#43;&#43;去模拟实现stack和queue
💖 博主CSDN主页:卫卫卫的个人主页 💞
👉 专栏分类:高质量Ｃ&#43;&#43;学习 👈
💯代码仓库:卫卫周大胖的学习日记💫
💪关注博主和博主一起学习!一起努力！
目录标题 什么是适配器Stack的模拟实现Stack的基本结构常见函数的模拟实现入栈 - push(const T&amp; x)出栈- pop()获取栈顶元素 - const T&amp; top()栈中的元素个数 - size_t size()判断栈是否为空 整体代码: Queue的模拟实现Queue的基本结构常见函数的模拟实现入队列- push(const T&amp; x)出队列- pop()获取队头元素- const T&amp; front()获取队尾元素- const T&amp; back()获取队列元素个数 - size_t size()判断队列是否为空 - bool empty() 整体代码 在讲stack和queue的模拟实现之前我们需要提到一个概念:适配器
什么是适配器 适配器是一种设计模式，也是一种编程工具，用于将一个类的接口转换成另一个类的接口。适配器模式允许不兼容的类之间能够协同工作。
在C&#43;&#43;中，适配器是指通过改变容器的接口使其适用于不同的需求。适配器可以封装容器，以提供一种更简单、更有限的功能接口，或者可以通过改变容器的工作方式来满足特定的需求。
在STL（标准模板库）中，适配器包括以下几种：
迭代器适配器：用于改变迭代器的行为，如reverse_iterator适配器用于反向遍历一个容器。容器适配器：用于改变容器的接口，如stack适配器用于实现堆栈功能。函数适配器：用于改变函数的行为，如bind适配器用于绑定函数和参数，生成新的函数对象。 适配器模式是一种重要的设计模式，它提供了一种解决兼容性问题的方式，并且可以使代码更加灵活和可复用。在C&#43;&#43;中，STL的适配器提供了方便的工具和容器，使开发者能够更好地处理不同的需求和场景。
Stack的模拟实现 Stack的基本结构 这里很多人就会说，我们在C语言实现栈的时候就是像下面这么写的呐，就和实现vector一样的方式去实现stack不就行了嘛？如果是要用这样的方式去实现，那么博主今天就不会提到适配器这个概念了。
代码思路: 既然我们使用适配器来帮助我们来实现stack，那就是说你这个容器适配器的功能要满足我们stack所需要的入栈、出栈、获取栈顶元素、判断是否为空等等。
namespace bit { //这里我们通过模板来灵活的选择底层的容器适配器，只需要适配器满足我们所需要的操作即可 template&lt;class T, class Container = deque&lt;T&gt;&gt;//适配器 class stack { private: Container _con; }; STL中对stack和queue默认选择deque作为其底层容器，主要是因为：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-13T15:17:51+08:00">
    <meta property="article:modified_time" content="2024-06-13T15:17:51+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;】STL中stack和queue(适配器版)的模拟实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-kimbie-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>前言：在此之前我们讲到了stack和queue还有deque的常见的使用方法，并且也在数据结构的时候用C语言去实现过栈和队列，今天我们将进一步的用C++去模拟实现stack和queue</p> 
<blockquote> 
 <p>💖 博主CSDN主页:<a href="https://blog.csdn.net/m0_64826370?spm=1010.2135.3001.5343">卫卫卫的个人主页</a> 💞<br> 👉 专栏分类:<a href="http://t.csdnimg.cn/EEhmC" rel="nofollow">高质量Ｃ++学习</a> 👈<br> 💯代码仓库:<a href="https://gitee.com/wei-wei-zhou-dapang" rel="nofollow">卫卫周大胖的学习日记</a>💫<br> 💪关注博主和博主一起学习!一起努力！<br> <img src="https://images2.imgbox.com/64/4b/xFTxckuE_o.jpg" alt="在这里插入图片描述"></p> 
</blockquote> 
<hr> 
<p></p> 
<div class="toc"> 
 <h4>目录标题</h4> 
 <ul><li><a href="#_12" rel="nofollow">什么是适配器</a></li><li><a href="#Stack_25" rel="nofollow">Stack的模拟实现</a></li><li><ul><li><a href="#Stack_26" rel="nofollow">Stack的基本结构</a></li><li><a href="#_48" rel="nofollow">常见函数的模拟实现</a></li><li><ul><li><a href="#__pushconst_T_x_49" rel="nofollow">入栈 - push(const T&amp; x)</a></li><li><a href="#_pop_58" rel="nofollow">出栈- pop()</a></li><li><a href="#__const_T_top_67" rel="nofollow">获取栈顶元素 - const T&amp; top()</a></li><li><a href="#___size_t_size_76" rel="nofollow">栈中的元素个数 - size_t size()</a></li><li><a href="#_85" rel="nofollow">判断栈是否为空</a></li></ul> 
   </li><li><a href="#_95" rel="nofollow">整体代码:</a></li></ul> 
  </li><li><a href="#Queue_145" rel="nofollow">Queue的模拟实现</a></li><li><ul><li><a href="#Queue_146" rel="nofollow">Queue的基本结构</a></li><li><a href="#_161" rel="nofollow">常见函数的模拟实现</a></li><li><ul><li><a href="#_pushconst_T_x_162" rel="nofollow">入队列- push(const T&amp; x)</a></li><li><a href="#_pop_171" rel="nofollow">出队列- pop()</a></li><li><a href="#_const_T_front_181" rel="nofollow">获取队头元素- const T&amp; front()</a></li><li><a href="#_const_T_back_190" rel="nofollow">获取队尾元素- const T&amp; back()</a></li><li><a href="#__size_t_size_199" rel="nofollow">获取队列元素个数 - size_t size()</a></li><li><a href="#__bool_empty_208" rel="nofollow">判断队列是否为空 - bool empty()</a></li></ul> 
   </li><li><a href="#_217" rel="nofollow">整体代码</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<p>在讲stack和queue的模拟实现之前我们需要提到一个概念:适配器</p> 
<h2><a id="_12"></a>什么是适配器</h2> 
<p>适配器是一种设计模式，也是一种编程工具，用于将一个类的接口转换成另一个类的接口。适配器模式允许不兼容的类之间能够协同工作。</p> 
<p>在C++中，适配器是指通过改变容器的接口使其适用于不同的需求。适配器可以封装容器，以提供一种更简单、更有限的功能接口，或者可以通过改变容器的工作方式来满足特定的需求。</p> 
<p>在STL（标准模板库）中，适配器包括以下几种：</p> 
<ol><li>迭代器适配器：用于改变迭代器的行为，如reverse_iterator适配器用于反向遍历一个容器。</li><li>容器适配器：用于改变容器的接口，如stack适配器用于实现堆栈功能。</li><li>函数适配器：用于改变函数的行为，如bind适配器用于绑定函数和参数，生成新的函数对象。</li></ol> 
<p>适配器模式是一种重要的设计模式，它提供了一种解决兼容性问题的方式，并且可以使代码更加灵活和可复用。在C++中，STL的适配器提供了方便的工具和容器，使开发者能够更好地处理不同的需求和场景。<br> <img src="https://images2.imgbox.com/8e/7e/FOpNa4dr_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h2><a id="Stack_25"></a>Stack的模拟实现</h2> 
<h3><a id="Stack_26"></a>Stack的基本结构</h3> 
<p>这里很多人就会说，我们在C语言实现栈的时候就是像下面这么写的呐，就和实现vector一样的方式去实现stack不就行了嘛？如果是要用这样的方式去实现，那么博主今天就不会提到<strong>适配器</strong>这个概念了。<br> <img src="https://images2.imgbox.com/c5/a8/aalHLKSE_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p><strong>代码思路</strong>: 既然我们使用适配器来帮助我们来实现stack，那就是说你这个容器适配器的功能要满足我们stack所需要的入栈、出栈、获取栈顶元素、判断是否为空等等。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">namespace</span> bit 
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//这里我们通过模板来灵活的选择底层的容器适配器，只需要适配器满足我们所需要的操作即可</span>
	<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Container</span> <span class="token operator">=</span> deque<span class="token operator">&lt;</span>T<span class="token operator">&gt;&gt;</span><span class="token comment">//适配器</span>
	<span class="token keyword">class</span> <span class="token class-name">stack</span>
	<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">private</span><span class="token operator">:</span>
		Container _con<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p>STL中对stack和queue默认选择deque作为其底层容器，主要是因为：</p> 
 <ol><li>stack和queue不需要遍历(因此stack和queue没有迭代器)，只需要在固定的一端或者两端进行操作。</li><li>在stack中元素增长时，deque比vector的效率高(扩容时不需要搬移大量数据)；queue中的元素增长时，deque不仅效率高，而且内存使用率高。</li><li>当然了这里你也可以显示调用你想用的容器适配器例如vector和list也都是可以的。</li></ol> 
</blockquote> 
<hr> 
<h3><a id="_48"></a>常见函数的模拟实现</h3> 
<h4><a id="__pushconst_T_x_49"></a>入栈 - push(const T&amp; x)</h4> 
<p><strong>代码思路</strong>: 这里我们知道栈的基本结构就是先入栈的会后出，后进栈的先出，我们只需要在容器的尾部进行尾插，即可完成入栈，但是我们需要注意的是我们是尾插，所以再出栈的时候就直接出容器尾部的元素即可。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span><span class="token comment">//入栈</span>
<span class="token punctuation">{<!-- --></span>
	_con<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用适配器的push_back即可</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h4><a id="_pop_58"></a>出栈- pop()</h4> 
<p><strong>代码思路</strong>:刚刚我们说过栈先进后出，并且我们是通过尾插来模仿入栈的操作，所以我们的最后一个元素就是最后尾插进来的元素，要想模拟出栈的操作就是对其进行尾删即可。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//出栈</span>
<span class="token punctuation">{<!-- --></span>
	_con<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除容器尾部的元素</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h4><a id="__const_T_top_67"></a>获取栈顶元素 - const T&amp; top()</h4> 
<p><strong>代码思路</strong>: 我们是通过尾插来表示入栈，栈顶的元素就是最后一个入栈的元素，因此我们直接返回容器尾部的元素就可以模拟出获取栈顶元素的操作</p> 
<pre><code class="prism language-cpp"><span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//获取栈顶元素</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> _con<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用适配器返回尾部的元素</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h4><a id="___size_t_size_76"></a>栈中的元素个数 - size_t size()</h4> 
<p><strong>代码思路</strong>: 这个就比较简单了，我们通过适配器返回当前元素个数即可</p> 
<pre><code class="prism language-cpp">size_t <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//栈中的元素个数</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> _con<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h4><a id="_85"></a>判断栈是否为空</h4> 
<p><strong>代码思路</strong>: 同理直接调用适配器的函数即可</p> 
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//判断栈是否为空</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> _con<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h3><a id="_95"></a>整体代码:</h3> 
<pre><code class="prism language-cpp"><span class="token keyword">namespace</span> bit 
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//template&lt;class T&gt; //传统的写法</span>
	<span class="token comment">//class stack</span>
	<span class="token comment">//{<!-- --></span>
	<span class="token comment">//	private:</span>
	<span class="token comment">//	T* _a;</span>
	<span class="token comment">//	int _top;</span>
	<span class="token comment">//	int _capacity;</span>
	<span class="token comment">//};</span>
	<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Container</span> <span class="token operator">=</span> deque<span class="token operator">&lt;</span>T<span class="token operator">&gt;&gt;</span><span class="token comment">//适配器</span>
	<span class="token keyword">class</span> <span class="token class-name">stack</span>
	<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span><span class="token comment">//入栈</span>
		<span class="token punctuation">{<!-- --></span>
			_con<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//出栈</span>
		<span class="token punctuation">{<!-- --></span>
			_con<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除容器尾部的元素就是出栈</span>
		<span class="token punctuation">}</span>

		size_t <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//栈中的元素个数</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _con<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//获取栈顶元素</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _con<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回队尾的元素</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//判断栈是否为空</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _con<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

	<span class="token keyword">private</span><span class="token operator">:</span>
		Container _con<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


</code></pre> 
<hr> 
<h2><a id="Queue_145"></a>Queue的模拟实现</h2> 
<h3><a id="Queue_146"></a>Queue的基本结构</h3> 
<p><strong>代码思路</strong>:同理我们这里依然可以使用适配器帮助我们来模拟实现queue的基本结构，但是一定记住适配器里面的操作必须满足你所需要的操作</p> 
<pre><code class="prism language-cpp"><span class="token keyword">namespace</span> bit
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Container</span> <span class="token operator">=</span> deque<span class="token operator">&lt;</span>T<span class="token operator">&gt;&gt;</span><span class="token comment">//调用适配器</span>
	<span class="token keyword">class</span> <span class="token class-name">queue</span>
	<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">private</span><span class="token operator">:</span>
		Container _con<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h3><a id="_161"></a>常见函数的模拟实现</h3> 
<h4><a id="_pushconst_T_x_162"></a>入队列- push(const T&amp; x)</h4> 
<p><strong>代码思路</strong>: 这里我们依然提一下，队列是先进先出，后进的后出和栈是完全相反的，所以我们在入队列的时候尾插的时候要记住，出队列的时候就是该容器的第一个元素先出，最后一个元素就是最后进去的元素就是最后出</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span><span class="token comment">//入队列</span>
<span class="token punctuation">{<!-- --></span>
	_con<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//队列先进去的先出去，入队列就直接尾插</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h4><a id="_pop_171"></a>出队列- pop()</h4> 
<p><strong>代码思路</strong>:刚刚我们提到了因为我们是尾插来模拟的入队列，所以出队列的时候就要通过删除第一个元素来模拟出队列，但是这里需要注意的是Vector中是没有pop_front()这个函数的，所以我们的适配器只能是List和deque</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//出队列</span>
<span class="token punctuation">{<!-- --></span>
	_con<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//出队列就依次头出即可,这里就不能用vector了，vector没有pop_front</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h4><a id="_const_T_front_181"></a>获取队头元素- const T&amp; front()</h4> 
<p><strong>代码思路</strong>: 刚刚提到了容器的第一个元素就是队头元素，因此我们只需要获取第一个元素即可。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//获取队头元素</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> _con<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//通过适配器获取队头元素</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h4><a id="_const_T_back_190"></a>获取队尾元素- const T&amp; back()</h4> 
<p><strong>代码思路</strong>:因为我们是尾插，所以队尾元素就是最后一个进去的元素，所以通过适配器获得队尾元素即可。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//获取队尾元素</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> _con<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用适配器获取队尾元素</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h4><a id="__size_t_size_199"></a>获取队列元素个数 - size_t size()</h4> 
<p><strong>代码思路</strong>：这个和前面的栈同理就不过多的讲解了</p> 
<pre><code class="prism language-cpp">size_t <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> _con<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h4><a id="__bool_empty_208"></a>判断队列是否为空 - bool empty()</h4> 
<p><strong>代码思路</strong>: 这个也是一样的直接调用适配器里面的函数即可</p> 
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> _con<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//同理调用适配器判断是否为空</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h3><a id="_217"></a>整体代码</h3> 
<pre><code class="prism language-cpp"><span class="token keyword">namespace</span> bit
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Container</span> <span class="token operator">=</span> deque<span class="token operator">&lt;</span>T<span class="token operator">&gt;&gt;</span>
	<span class="token keyword">class</span> <span class="token class-name">queue</span>
	<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span><span class="token comment">//入队列</span>
		<span class="token punctuation">{<!-- --></span>
			_con<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//队列先进去的先出去，入队列就直接尾插</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//出队列</span>
		<span class="token punctuation">{<!-- --></span>
			_con<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//出队列就依次头出即可,这里就不能用vector了，vector没有pop_front</span>
		<span class="token punctuation">}</span>

		size_t <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _con<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _con<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//获取队头元素</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _con<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//获取队尾元素</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _con<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

	<span class="token keyword">private</span><span class="token operator">:</span>
		Container _con<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<p>好啦，今天的内容就到这里啦，下期内容预告<strong>STL中的优先级队列的使用与模拟实现</strong>.</p> 
<hr> 
<p>结语：今天的内容就到这里吧，谢谢各位的观看，如果有讲的不好的地方也请各位多多指出，作者每一条评论都会读的，谢谢各位。</p> 
<hr> 
<center>
  🌏🗺️ 
 <font color="purple" size="4">这里祝各位接下来的每一天好运连连</font> 💞💞 
</center>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c62130df5af2087ccc0dca4c02460806/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python酷库之旅-比翼双飞情侣库(04)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fbb222994158530ededafd977f21401a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于图像识别的中医AI舌面诊技术，全面开放API对接</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>