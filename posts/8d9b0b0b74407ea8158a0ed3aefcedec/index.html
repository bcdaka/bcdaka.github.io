<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Java】接口详解 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/8d9b0b0b74407ea8158a0ed3aefcedec/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【Java】接口详解">
  <meta property="og:description" content="接口是抽象类的更进一步. 抽象类中还可以包含非抽象方法, 和字段. 而接口中包含的方法都是抽象方法, 字段只能包含静态常量。
一个简单的接口代码示例 interface IShape { void draw(); } class Cycle implements IShape { @Override public void draw() { System.out.println(&#34;○&#34;); } } public class Data { public static void main(String[] args) { IShape shape = new Rect(); shape.draw(); } } 定义接口的注意事项：
使用 interface 定义一个接口接口中的方法一定是抽象方法, 因此可以省略 abstract接口中的方法一定是 public, 因此可以省略 publicCycle 使用 implements 继承接口. 此时表达的含义不再是 &#34;扩展&#34;, 而是 &#34;实现&#34;在调用的时候同样可以创建一个接口的引用, 对应到一个子类的实例.接口不能单独被实例化 定义一个完整的接口是这样的：
interface Ishape{
public static final int num = 10;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-03T20:31:25+08:00">
    <meta property="article:modified_time" content="2024-06-03T20:31:25+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Java】接口详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>接口是抽象类的更进一步. 抽象类中还可以包含非抽象方法, 和字段. 而接口中包含的方法都是抽象方法, 字段只能包含静态常量。</strong></p> 
<h2><strong>一个简单的接口代码示例</strong></h2> 
<pre><code class="language-java">interface IShape {
void draw();
}
class Cycle implements IShape {
@Override
public void draw() {
System.out.println("○");
}
}
public class Data {
public static void main(String[] args) {
IShape shape = new Rect();
shape.draw();
}
}</code></pre> 
<p><strong>定义接口的注意事项：</strong></p> 
<ul><li><strong>使用 interface 定义一个接口</strong></li><li><strong>接口中的方法一定是抽象方法, 因此可以省略 abstract</strong></li><li><strong>接口中的方法一定是 public, 因此可以省略 public</strong></li><li><strong>Cycle 使用 implements 继承接口. 此时表达的含义不再是 "扩展", 而是 "实现"</strong></li><li><strong>在调用的时候同样可以创建一个接口的引用, 对应到一个子类的实例.</strong></li><li><strong>接口不能单独被实例化</strong></li></ul> 
<p>定义一个完整的接口是这样的：</p> 
<blockquote> 
 <p>interface Ishape{<!-- --></p> 
 <p>        public static final int num = 10;</p> 
 <p>        public abstruct void draw();</p> 
 <p>}</p> 
</blockquote> 
<p> 但是严格来说我们在定义一个接口的时候通常会省略  public static final 和 public abstruct ，在我们定义接口的时候里面的变量和方法会自动加上。</p> 
<p>省略之后的写法：</p> 
<blockquote> 
 <p>interface Ishape{<!-- --></p> 
 <p>         int num = 10;</p> 
 <p>         void draw();</p> 
 <p>}</p> 
</blockquote> 
<h2>实现多个接口</h2> 
<p> <strong>有的时候我们需要让一个类同时继承自多个父类. 这件事情在有些编程语言通过 多继承 的方式来实现的.然而 Java 中只支持单继承, 一个类只能 extends 一个父类. 但是可以同时实现多个接口, 也能达到多继承类似的效果。</strong></p> 
<p>代码示例：</p> 
<pre><code class="language-java">interface Ifly{
    void fly();
}
interface Irunning{
    void running();
}
interface Iswimming{
    void swimming();
}
abstract class Animal{
    public String name;
    public int age;
    public Animal(String name,int age){
        this.name = name;
        this.age = age;
    }
    abstract public void eat();
}
class Dog extends Animal implements Iswimming , Irunning{

    public Dog(String name,int age){
        super(name,age);
    }

    @Override
    public void running() {
        System.out.println(this.name + "正在跑");
    }

    @Override
    public void swimming() {
        System.out.println(this.name + "正在游泳");
    }

    @Override
    public void eat() {
        System.out.println(this.name + "正在吃狗粮");
    }
}

public class Data{
    public static void test1(Animal animal){
        animal.eat();
    }
    public static void test2(Ifly ifly){
        ifly.fly();
    }
    public static void test3(Iswimming iswimming){
        iswimming.swimming();
    }
    public static void test4(Irunning irunning){
        irunning.running();
    }

    public static void main(String[] args) {
        test1(new Dog("小黄" ,20));
        test3(new Dog("小黄" ,20));
        test4(new Dog("小黄" ,20));
    }
}</code></pre> 
<p><strong>上面的代码展示了 Java 面向对象编程中最常见的用法: 一个类继承一个父类, 同时实现多种接口。</strong></p> 
<p>在这个代码中我们定义了三个接口：Ifly 、Irunning 、Iswimming 。一个抽象类：Animal 。然后定义了一个类来继承这个抽象类并且实现了两个接口。</p> 
<p>上述代码运行结果：</p> 
<p><img alt="" height="243" src="https://images2.imgbox.com/4f/40/Cp2R8NJv_o.png" width="810"></p> 
<h2>接口的常见使用案例</h2> 
<h3>Comparable接口</h3> 
<h4 style="background-color:transparent;"> 给对象数组排序</h4> 
<p>代码示例：</p> 
<pre><code class="language-java">class Student implements Comparable&lt;Student&gt;{
    private String name;
    private int score;
    public Student(String name, int score) {
        this.name = name;
        this.score = score;
    }
    @Override
    public String toString() {
        return "[" + this.name + ":" + this.score + "]";
    }

    @Override
    public int compareTo(Student o) {
        return this.score - o.score;
    }
}
public class Data{
    public static void main(String[] args) {
        Student[] student = {
                new Student("小明",87),
                new Student("小黄",94),
                new Student("小李",89)};
        Arrays.sort(student);
        System.out.println(Arrays.toString(student));
    }
}</code></pre> 
<p>在这个代码中我们定义了一个 Student 类：</p> 
<blockquote> 
 <p>class Student {<!-- --><br> private String name;<br> private int score;<br> public Student(String name, int score) {<!-- --><br> this.name = name;<br> this.score = score;<br> }<br> @Override<br> public String toString() {<!-- --><br> return "[" + this.name + ":" + this.score + "]";<br> }<br> }</p> 
</blockquote> 
<p> 然后用这个类创建了一个数组：</p> 
<blockquote> 
 <pre>Student[] student = {
        new Student("小明",87),
        new Student("小黄",94),
        new Student("小李",89)};</pre> 
</blockquote> 
<p>接着我们给 Student 类实现接口 Comparable&lt;Student&gt; ，这样我们就可以给该类实例化的成员进行比较大小。</p> 
<p>上述代码的运行结果：</p> 
<p><img alt="" height="192" src="https://images2.imgbox.com/2a/45/VVi6jblz_o.png" width="753"></p> 
<p><strong> 注意事项: </strong>对于 sort 方法来说, 需要传入的数组的每个对象都是 "可比较" 的, 需要具备 compareTo 这样的能力. 通过重写 compareTo 方法的方式, 就可以定义比较规则。</p> 
<h3 style="background-color:transparent;">Comparator接口</h3> 
<h4><strong>另外一种比较一个类的两个实例的方法：</strong></h4> 
<p>代码示例：</p> 
<pre><code class="language-java">class Person implements Comparable&lt;Person&gt;{
    public String name;
    public int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    @Override
    public int compareTo(Person o) {
        return this.age - o.age;
    }
}
class AgeComparator implements Comparator&lt;Person&gt;{

    @Override
    public int compare(Person o1, Person o2) {
        return o1.age - o2.age;
    }
}
class NameComparator implements Comparator&lt;Person&gt;{

    @Override
    public int compare(Person o1, Person o2) {
        return o1.name.compareTo(o2.name);
    }
}
public class Data{
    public static void main(String[] args) {
        Person p1 = new Person("小明",20);
        Person p2 = new Person("小黄",30);
        System.out.println(p1.compareTo(p2));
        AgeComparator agecomparator = new AgeComparator();
        System.out.println(agecomparator.compare(p1,p2));
        NameComparator namecomparator = new NameComparator();
        namecomparator.compare(p1,p2);
    }
}</code></pre> 
<p>在这个代码中我们为了进行比较，额外创建了一个类来实现 Comparator 接口并且在该类里面重写 compare 方法。</p> 
<h3 style="background-color:transparent;">Clonable 接口</h3> 
<p><strong>浅拷贝 VS 深拷贝</strong></p> 
<h4><strong>浅拷贝示例</strong></h4> 
<p>代码示例：</p> 
<pre><code class="language-java">class Person implements Cloneable{
    public int age;
    public Person(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "age=" + age +
                '}';
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
public class Data{
    public static void main(String[] args) throws CloneNotSupportedException {
        Person p1 = new Person(20);
        Person p2 = (Person)p1.clone();
        System.out.println(p1);
        System.out.println(p2);
    }
}</code></pre> 
<p>这里我们定义了一个类 Person 并且实现了接口 Cloneable 重写了方法 clone 。在测试类中我们将 p1 里面的内容拷贝到了 p2 里面。</p> 
<p>代码运行结果：</p> 
<p><img alt="" height="208" src="https://images2.imgbox.com/2c/90/TaAXzgit_o.png" width="717"></p> 
<p>接着我们再定义一个 Money 类：</p> 
<blockquote> 
 <pre>class Money{
    public double money = 19.9;
}</pre> 
</blockquote> 
<p>并且在 Person 类中使用这个类：</p> 
<blockquote> 
 <p> </p> 
 <pre>class Person implements Cloneable{
    public int age;
    public Money m = new Money();
    public Person(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "age=" + age +
                '}';
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}</pre> 
</blockquote> 
<p> 接着我们再进行拷贝，将 p1 里面的内容拷贝到 p2 里面，然后我们改变 p2 里面的内容，并且将其输出：</p> 
<p><img alt="" height="282" src="https://images2.imgbox.com/3c/fb/EbTKqQdu_o.png" width="811"></p> 
<p>很快我们就能看出一个问题：改变 p2 里面的内容，而 p1 里面的内容也跟着改变了呢？</p> 
<p>接着我们引入深拷贝的理念：</p> 
<h4>深拷贝示例</h4> 
<p>代码示例：</p> 
<pre><code class="language-java">class Money implements Cloneable{
    public double money = 19.9;

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
class Person implements Cloneable{
    public int age;
    public Money m = new Money();
    public Person(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "age=" + age +
                '}';
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        Person tmp = (Person)super.clone();
        tmp.m = (Money)this.m.clone();
        return tmp;
    }
}
public class Data{
    public static void main(String[] args) throws CloneNotSupportedException {
        Person p1 = new Person(20);
        Person p2 = (Person)p1.clone();
        System.out.println(p1.m.money);
        System.out.println(p2.m.money);
        p2.m.money = 99.9;
        System.out.println(p1.m.money);
        System.out.println(p2.m.money);
    }
}</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="302" src="https://images2.imgbox.com/00/3c/aeRJcLd8_o.png" width="727"></p> 
<p>我们发现我们刚刚提出的问题被解决了。</p> 
<p>这里我们改变了两个地方：</p> 
<p>1、 将 Money 类也实现 Clonable 接口重写 clone 方法，将其具备能被拷贝的能力。</p> 
<blockquote> 
 <pre>class Money implements Cloneable{
    public double money = 19.9;

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}</pre> 
</blockquote> 
<p>2、重写 Person 类里面的 clone 方法。</p> 
<blockquote> 
 <p> </p> 
 <pre>protected Object clone() throws CloneNotSupportedException {
    Person tmp = (Person)super.clone();
    tmp.m = (Money)this.m.clone();
    return tmp;
}</pre> 
</blockquote> 
<h2>接口间的继承</h2> 
<p><strong>接口可以继承一个接口, 达到复用的效果. 使用 extends 关键字。</strong></p> 
<pre><code class="language-java">interface IRunning {
    void run();
}
interface ISwimming {
    void swim();
}
interface IAmphibious extends IRunning, ISwimming {
    void eat();
}</code></pre> 
<p>接口间的继承相当于把多个接口合并在一起。这里我们定义接口 Iamphibious 来继承了接口 IRunning 和接口 ISwimming 。这样该接口就有了另外两个接口里面的抽象方法，并且该接口也可以定义另外的抽象方法。</p> 
<h2>总结</h2> 
<p>抽象类与接口的区别：</p> 
<p><strong>核心区别:</strong> 抽象类中可以包含普通方法和普通字段, 这样的普通方法和字段可以被子类直接使用(不必重写), 而接口中不能包含普通方法, 子类必须重写所有的抽象方法。</p> 
<p><img alt="" height="1142" src="https://images2.imgbox.com/8d/53/hyhFMFaA_o.png" width="1200"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/96914f387014d2e4b114f8ceef629a8f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">map函数友好讲解（狠狠爱住）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1aaefec32844e16ebd47b396785d44fb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">半导体光子电学期末笔记2: 光子晶体 Photonic crystals</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>