<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【JAVA】String类 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/5cc24d5ab4c7c5db387188abda96a450/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【JAVA】String类">
  <meta property="og:description" content="作者主页：paper jie_的博客
本文作者：大家好，我是paper jie，感谢你阅读本文，欢迎一建三连哦。
本文录入于《JAVASE语法系列》专栏，本专栏是针对于大学生，编程小白精心打造的。笔者用重金(时间和精力)打造，将javaSE基础知识一网打尽，希望可以帮到读者们哦。
其他专栏：《JAVA》《算法详解》《C语言》等
内容分享：本期将会对JAVA中的String类进行分享
目录
String类的引出
String类的常用方法
字符串构造
String对象的比较
比较是否引用的是同一个对象
boolean aquals（Object o）比较方法：按照字典序比较
int compareTo(String s)方法：按照字典序进行比较
字符串查找
转换
数值与字符串转换
大小写转换
字符串与数组转换
格式化
字符串替换
字符串拆分
字符串截取
去处空格
字符串的不可变性
String设计成不可变的原因
字符串的修改
StringBuilder和StringBuffer
String，StringBuilder，StringBuffer的区别
String类的引出 C语言中，我们发现里面是没有字符串类型的，要想表达字符串只能通过字符数组或者字符指针，可以用它的标准库提供的字符串函数完成操作，但是这种将数据和操作数据方法分离的方式它不符合面向对象的思想，因此java中专门提供了String类。
String类的常用方法 字符串构造 String类提供的构造方法一般有三种：
public class Test { public static void main(String[] args) { //使用常量串构造 String s1 = &#34;hello word&#34;; System.out.println(s1); //直接new一个String对象 String s2 = new String(&#34;hello word&#34;); System.out.println(s2); //使用字符数组进行构造 char[] array = {&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;0&#39;}; String s3 = new String(array); } } 这里要注意一个地方：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-09-12T08:44:06+08:00">
    <meta property="article:modified_time" content="2023-09-12T08:44:06+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【JAVA】String类</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><strong><span style="color:#956fe7;">作者主页：<a href="https://blog.csdn.net/paperjie?type=blog" title="paper jie_的博客">paper jie_的博客</a></span></strong></p> 
 <p><span style="color:#956fe7;"><strong>本文作者：大家好，我是paper jie，感谢你阅读本文，欢迎一建三连哦。</strong></span></p> 
 <p><span style="color:#956fe7;"><strong>本文录入于《JAVASE语法系列》专栏，本专栏是针对于大学生，编程小白精心打造的。笔者用重金(时间和精力)打造，将javaSE基础知识一网打尽，希望可以帮到读者们哦。</strong></span></p> 
 <p><span style="color:#956fe7;"><strong>其他专栏：《JAVA》《算法详解》《C语言》等</strong></span></p> 
 <p><span style="color:#956fe7;"><strong>内容分享：本期将会对JAVA中的String类进行分享</strong></span></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="String%E7%B1%BB%E7%9A%84%E5%BC%95%E5%87%BA-toc" style="margin-left:0px;"><a href="#String%E7%B1%BB%E7%9A%84%E5%BC%95%E5%87%BA" rel="nofollow">String类的引出</a></p> 
<p id="String%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-toc" style="margin-left:0px;"><a href="#String%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95" rel="nofollow">String类的常用方法</a></p> 
<p id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9E%84%E9%80%A0-toc" style="margin-left:40px;"><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9E%84%E9%80%A0" rel="nofollow">字符串构造</a></p> 
<p id="String%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AF%94%E8%BE%83-toc" style="margin-left:40px;"><a href="#String%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AF%94%E8%BE%83" rel="nofollow">String对象的比较</a></p> 
<p id="%E6%AF%94%E8%BE%83%E6%98%AF%E5%90%A6%E5%BC%95%E7%94%A8%E7%9A%84%E6%98%AF%E5%90%8C%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1-toc" style="margin-left:80px;"><a href="#%E6%AF%94%E8%BE%83%E6%98%AF%E5%90%A6%E5%BC%95%E7%94%A8%E7%9A%84%E6%98%AF%E5%90%8C%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1" rel="nofollow">比较是否引用的是同一个对象</a></p> 
<p id="boolean%20aquals%EF%BC%88Object%20o%EF%BC%89%E6%AF%94%E8%BE%83%E6%96%B9%E6%B3%95%EF%BC%9A%E6%8C%89%E7%85%A7%E5%AD%97%E5%85%B8%E5%BA%8F%E6%AF%94%E8%BE%83-toc" style="margin-left:80px;"><a href="#boolean%20aquals%EF%BC%88Object%20o%EF%BC%89%E6%AF%94%E8%BE%83%E6%96%B9%E6%B3%95%EF%BC%9A%E6%8C%89%E7%85%A7%E5%AD%97%E5%85%B8%E5%BA%8F%E6%AF%94%E8%BE%83" rel="nofollow">boolean aquals（Object o）比较方法：按照字典序比较</a></p> 
<p id="int%20compareTo(String%20s)%E6%96%B9%E6%B3%95%EF%BC%9A%E6%8C%89%E7%85%A7%E5%AD%97%E5%85%B8%E5%BA%8F%E8%BF%9B%E8%A1%8C%E6%AF%94%E8%BE%83-toc" style="margin-left:80px;"><a href="#int%20compareTo%28String%20s%29%E6%96%B9%E6%B3%95%EF%BC%9A%E6%8C%89%E7%85%A7%E5%AD%97%E5%85%B8%E5%BA%8F%E8%BF%9B%E8%A1%8C%E6%AF%94%E8%BE%83" rel="nofollow">int compareTo(String s)方法：按照字典序进行比较</a></p> 
<p id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE-toc" style="margin-left:40px;"><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE" rel="nofollow">字符串查找</a></p> 
<p id="%E8%BD%AC%E6%8D%A2-toc" style="margin-left:40px;"><a href="#%E8%BD%AC%E6%8D%A2" rel="nofollow">转换</a></p> 
<p id="%E6%95%B0%E5%80%BC%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2-toc" style="margin-left:80px;"><a href="#%E6%95%B0%E5%80%BC%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2" rel="nofollow">数值与字符串转换</a></p> 
<p id="%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2-toc" style="margin-left:80px;"><a href="#%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2" rel="nofollow">大小写转换</a></p> 
<p id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2-toc" style="margin-left:80px;"><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2" rel="nofollow">字符串与数组转换</a></p> 
<p id="%E6%A0%BC%E5%BC%8F%E5%8C%96-toc" style="margin-left:80px;"><a href="#%E6%A0%BC%E5%BC%8F%E5%8C%96" rel="nofollow">格式化</a></p> 
<p id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2-toc" style="margin-left:40px;"><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2" rel="nofollow">字符串替换</a></p> 
<p id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%86%E5%88%86-toc" style="margin-left:40px;"><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%86%E5%88%86" rel="nofollow">字符串拆分</a></p> 
<p id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%AA%E5%8F%96-toc" style="margin-left:40px;"><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%AA%E5%8F%96" rel="nofollow">字符串截取</a></p> 
<p id="%E5%8E%BB%E5%A4%84%E7%A9%BA%E6%A0%BC-toc" style="margin-left:40px;"><a href="#%E5%8E%BB%E5%A4%84%E7%A9%BA%E6%A0%BC" rel="nofollow">去处空格</a></p> 
<p id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7-toc" style="margin-left:0px;"><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7" rel="nofollow">字符串的不可变性</a></p> 
<p id="String%E8%AE%BE%E8%AE%A1%E6%88%90%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E5%8E%9F%E5%9B%A0-toc" style="margin-left:40px;"><a href="#String%E8%AE%BE%E8%AE%A1%E6%88%90%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E5%8E%9F%E5%9B%A0" rel="nofollow">String设计成不可变的原因</a></p> 
<p id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%BF%AE%E6%94%B9-toc" style="margin-left:0px;"><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%BF%AE%E6%94%B9" rel="nofollow">字符串的修改</a></p> 
<p id="StringBuilder%E5%92%8CStringBuffer-toc" style="margin-left:0px;"><a href="#StringBuilder%E5%92%8CStringBuffer" rel="nofollow">StringBuilder和StringBuffer</a></p> 
<p id="String%EF%BC%8CStringBuilder%EF%BC%8CStringBuffer%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:0px;"><a href="#String%EF%BC%8CStringBuilder%EF%BC%8CStringBuffer%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">String，StringBuilder，StringBuffer的区别</a></p> 
<hr id="hr-toc"> 
<h2 style="background-color:transparent;">String类的引出</h2> 
<p>C语言中，我们发现里面是没有字符串类型的，要想表达字符串只能通过字符数组或者字符指针，可以用它的标准库提供的字符串函数完成操作，但是这种将数据和操作数据方法分离的方式它不符合面向对象的思想，因此java中专门提供了String类。</p> 
<h2 id="String%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">String类的常用方法</h2> 
<h3 id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9E%84%E9%80%A0">字符串构造</h3> 
<p>String类提供的构造方法一般有三种：</p> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        //使用常量串构造
        String s1 = "hello word";
        System.out.println(s1);
        
        //直接new一个String对象
        String s2 = new String("hello word");
        System.out.println(s2);
        
        //使用字符数组进行构造
        char[] array = {'h','e','l','l','0'};
        String s3 = new String(array);
    }
}</code></pre> 
<p><img alt="" height="136" src="https://images2.imgbox.com/f4/14/kbE2sZN0_o.png" width="712"></p> 
<p><strong>这里要注意一个地方：</strong></p> 
<p><strong><span style="background-color:#ed7976;">String是一个引用类型，内部并不会存储字符串本身</span></strong>，我们可以看看string类的源码：</p> 
<p><img alt="" height="308" src="https://images2.imgbox.com/d0/85/zSSKeZSv_o.png" width="982"></p> 
<pre><code class="language-java">    public static void main(String[] args) {

// s1和s2引用的是不同对象 s1和s3引用的是同一对象
        String s1 = new String("hello");
        String s2 = new String("world");
        String s3 = s1;

        System.out.println(s1.length()); // 获取字符串长度---输出5
        System.out.println(s3.isEmpty()); // 如果字符串长度为0，返回true，否则返回false
    }</code></pre> 
<p>画图分析：</p> 
<p><img alt="" height="567" src="https://images2.imgbox.com/70/e1/vqFVFHEz_o.png" width="1200"></p> 
<h3 id="String%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AF%94%E8%BE%83">String对象的比较</h3> 
<p>字符串的比较，java中提供了4种方式</p> 
<h4 id="%E6%AF%94%E8%BE%83%E6%98%AF%E5%90%A6%E5%BC%95%E7%94%A8%E7%9A%84%E6%98%AF%E5%90%8C%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1">比较是否引用的是同一个对象</h4> 
<p>对内置类型，==比较的是变量中的值，对于引用类型==比较的是引用中的地址：</p> 
<pre><code class="language-java">    public static void main(String[] args) {
        int a = 10;
        int b = 20;
        int c = 10;
// 对于基本类型变量，==比较两个变量中存储的值是否相同
        System.out.println(a == b); // false
        System.out.println(a == c); // true
// 对于引用类型变量，==比较两个引用变量引用的是否为同一个对象
        String s1 = new String("hello");
        String s2 = new String("hello");
        String s3 = new String("world");
        String s4 = s1;
        System.out.println(s1 == s2); // false
        System.out.println(s2 == s3); // false
        System.out.println(s1 == s4); // true
    }
    </code></pre> 
<h4 id="boolean%20aquals%EF%BC%88Object%20o%EF%BC%89%E6%AF%94%E8%BE%83%E6%96%B9%E6%B3%95%EF%BC%9A%E6%8C%89%E7%85%A7%E5%AD%97%E5%85%B8%E5%BA%8F%E6%AF%94%E8%BE%83">boolean aquals（Object o）比较方法：按照字典序比较</h4> 
<p>String类重写父类Object中的equals方法，Object类中equals方法默认按==比较，String重写equals方法后，按照以下规则比较：</p> 
<p>equals方法的源码：</p> 
<pre><code class="language-java">    public boolean equals(Object anObject) {
// 1. 先检测this 和 anObject 是否为同一个对象比较，如果是返回true
        if (this == anObject) {
            return true;
        } // 2. 检测anObject是否为String类型的对象，如果是继续比较，否则返回false
        if (anObject instanceof String) {
// 将anObject向下转型为String类型对象
            String anotherString = (String) anObject;
            int n = value.length;
// 3. this和anObject两个字符串的长度是否相同，是继续比较，否则返回false
            if (n == anotherString.value.length) {
                char v1[] = value;
                char v2[] = anotherString.value;
                int i = 0;
// 4. 按照字典序，从前往后逐个字符进行比较
                while (n-- != 0) {
                    if (v1[i] != v2[i])
                        return false;
                    i++;
                }
                return true;
            }
        }
        return false;
    }</code></pre> 
<h4 id="int%20compareTo(String%20s)%E6%96%B9%E6%B3%95%EF%BC%9A%E6%8C%89%E7%85%A7%E5%AD%97%E5%85%B8%E5%BA%8F%E8%BF%9B%E8%A1%8C%E6%AF%94%E8%BE%83">int compareTo(String s)方法：按照字典序进行比较</h4> 
<p>与equals方法不同是，equals返回的是对还是错，而compareTo返回的是整数。比较方式：</p> 
<p><span style="color:#ed7976;"><strong>1 先按照字典序比较，出现不同的字符，返回这两个字符的大小差值。</strong></span></p> 
<p><span style="color:#ed7976;"><strong>2 如果一直到一个字符串比较完字符都相等的话但他们的长度不同，则返回值是这两个字符串的长度差值</strong></span></p> 
<pre><code class="language-java">public class Test {
        public static void main(String[] args) {
            String s1 = new String("abc");
            String s2 = new String("ac");
            String s3 = new String("abc");
            String s4 = new String("abcdef");
            System.out.println(s1.compareTo(s2)); // 不同输出字符差值-1
            System.out.println(s1.compareTo(s3)); // 相同输出 0
            System.out.println(s1.compareTo(s4)); // 前k个字符完全相同，输出长度差值 -3
        }
}</code></pre> 
<h3 id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE">字符串查找</h3> 
<p>字符串查找String类提供了许多查找方法：</p> 
<p><img alt="" height="666" src="https://images2.imgbox.com/20/21/kTuTRVda_o.png" width="1200"></p> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        //通过下标找字符
        String s1 = "abcdefgh";
        char ch = s1.charAt(2);
        System.out.println(ch);

        //通过字符找下标
        int index1 = s1.indexOf('c');
        System.out.println(index1);

        //跳着找
        int index2 = s1.indexOf('e', 3);
        System.out.println(index2);

        //通过子字符串找第一次出现的下标
        int index3 = s1.indexOf("def");
        System.out.println(index3);

        //跳着找子字符串返回第一次出现的下标
        int index4 = s1.indexOf("def", 2);
        System.out.println(index4);
        
        //倒着找字符
        int lastindex1 = s1.lastIndexOf('c');
        System.out.println(lastindex1);

        //跳着倒着找字符
        int lastindex2 = s1.lastIndexOf('c', 5);
        System.out.println(lastindex2);

        //倒着找字符串
        int lastindex3 = s1.lastIndexOf("ef");
        System.out.println(lastindex3);

        //倒着跳着找字符串
        int lastindex4 = s1.lastIndexOf("ef", 6);
        System.out.println(lastindex4);
    }</code></pre> 
<h3 id="%E8%BD%AC%E6%8D%A2">转换</h3> 
<h4 id="%E6%95%B0%E5%80%BC%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2">数值与字符串转换</h4> 
<p>数字转字符串：</p> 
<pre><code class="language-java">    public static void main(String[] args) {
        //数字转字符串
        String s1 = String.valueOf(1111);
        String s2 = String.valueOf(11.11);
        String s3 = String.valueOf(true);
        String s4 = String.valueOf(new person("baga", 19));
        System.out.println(s1);
        System.out.println(s2);
        System.out.println(s3);
        System.out.println(s4);
    }</code></pre> 
<p>字符串转数字：</p> 
<pre><code class="language-java">    public static void main(String[] args) {
        //字符串转数字 integer Double 是包装类型
        int data = Integer.parseInt("12345");
        double data2 = Double.parseDouble("12.43");
        System.out.println(data);
        System.out.println(data2);
    }</code></pre> 
<h4 id="%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2">大小写转换</h4> 
<pre><code class="language-java">    public static void main(String[] args) {
        //大写转小写
        String s1 = "hello word";
        String str1 = s1.toUpperCase();
        System.out.println(str1);
        //小写转大写
        String s2 = "HELLO WORD";
        String str2 = s2.toLowerCase();
        System.out.println(str2);
    }</code></pre> 
<h4 id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2">字符串与数组转换</h4> 
<pre><code class="language-java">public static void main(String[] args) {
        //字符串转数组
        String s1 = "hello word";
        char[] ch = s1.toCharArray();
        for (int i = 0; i &lt; ch.length; i++) {
            System.out.print(ch[i]+" ");
        }

        //数组转字符串
        char[] array = new char[]{'f','f','f','o','o','o'};
        String s2 = new String(array);
        System.out.println(s2);
    }</code></pre> 
<p><img alt="" height="144" src="https://images2.imgbox.com/e9/35/sCQnybEA_o.png" width="546"></p> 
<h4 id="%E6%A0%BC%E5%BC%8F%E5%8C%96">格式化</h4> 
<pre><code class="language-java">    public static void main(String[] args) {
        String s = String.format("%d %d %d ", 12, 34, 56);
        System.out.println(s);
    }</code></pre> 
<p><img alt="" height="98" src="https://images2.imgbox.com/e9/39/WglKKGxY_o.png" width="478"></p> 
<h3 id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2">字符串替换</h3> 
<p><img alt="" height="181" src="https://images2.imgbox.com/72/9f/rgE040Lh_o.png" width="1200"></p> 
<pre><code class="language-java">    public static void main(String[] args) {
        String s1 = "asdfasfasafaiughesfsfafil";
        //替换全部的子字符
        String str1 = s1.replaceAll("fa", "000");
        System.out.println(str1);
        //替换第一个个子字符
        String str2 = s1.replaceFirst("fd", "99");
        System.out.println(str2);
    }</code></pre> 
<p><img alt="" height="119" src="https://images2.imgbox.com/0f/d8/JilBRWFA_o.png" width="654"></p> 
<h3 id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%86%E5%88%86">字符串拆分</h3> 
<p><img alt="" height="174" src="https://images2.imgbox.com/9f/e2/VvkTzVYE_o.png" width="1159"></p> 
<pre><code class="language-java">    public static void main(String[] args) {
        //全部拆分
        String s1 = "hello word wo lai le";
        String[] str = s1.split(" ");
        for (int i = 0; i &lt; str.length; i++) {
            System.out.println(str[i]);
        }
        System.out.println();
        //拆分部分
        String[] str2 = s1.split(" ", 3);
        for (int i = 0; i &lt; str2.length; i++) {
            System.out.println(str2[i]);
        }
    }</code></pre> 
<p><img alt="" height="254" src="https://images2.imgbox.com/de/e3/j3HG2DHi_o.png" width="679"></p> 
<p><span style="color:#fe2c24;"><strong>使用特殊符号</strong></span><span style="color:#956fe7;"><strong>"|","*","+"</strong></span><span style="color:#fe2c24;"><strong>需要用一个斜杠表示，而两个斜杠表示一个斜杠</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>多个字符分割时，用竖线|隔开</strong></span></p> 
<p><img alt="" height="481" src="https://images2.imgbox.com/45/1b/fUToGnRv_o.png" width="614"></p> 
<h3 id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%AA%E5%8F%96">字符串截取</h3> 
<p>从一个完整的字符串中截取部分内容</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>方法</td><td>功能</td></tr><tr><td>String substring(int beginIndex)</td><td>从指定索引截取到结尾<br>  </td></tr><tr><td><br> String substring(int beginIndex, int endIndex)<br>  </td><td>截取部分内容</td></tr><tr><td></td><td></td></tr></tbody></table> 
<pre><code class="language-java">    public static void main(String[] args) {
        //从指定索引到末尾
        String s1 = "sadfdsag";
        String str1 = s1.substring(3);
        System.out.println(str1);
        //截取部分内容 遵循左闭右开规则
        String str2 = s1.substring(1, 3);
        System.out.println(str2);

    }</code></pre> 
<p><img alt="" height="117" src="https://images2.imgbox.com/21/30/IWCdo90l_o.png" width="615"></p> 
<p><span style="color:#ed7976;"><strong>1. 索引从0开始  </strong></span></p> 
<p><span style="color:#ed7976;"><strong>2. 注意前闭后开区间的写法, substring(0, 5) 表示包含 0 号下标的字符, 不包含 5 号下标 </strong></span></p> 
<h3 id="%E5%8E%BB%E5%A4%84%E7%A9%BA%E6%A0%BC">去处空格</h3> 
<p><strong>trim会去除字符串开头和结尾的空白字符（空格，换行，制表符）</strong></p> 
<pre><code class="language-java">    public static void main(String[] args) {
        String s1 ="   hello werd sad   ";
        String str = s1.trim();
        System.out.println(str);
    }</code></pre> 
<h2 id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">字符串的不可变性</h2> 
<p>String类是一种不可变的对象，它的内容是不可以改变的。字符串它为什么不能改变呢？</p> 
<p><span style="color:#ed7976;"><strong>1 String类它在设计的时候就是不可以改变的。</strong></span>字符串实现描述中已经说的很明白了：</p> 
<p><img alt="" height="130" src="https://images2.imgbox.com/ea/f6/f2kPwi5h_o.png" width="828"></p> 
<p><img alt="" height="282" src="https://images2.imgbox.com/e2/da/EWlGbfYm_o.png" width="816"></p> 
<p>通过1观察源码，我们发现：</p> 
<p><span style="color:#956fe7;"><strong>String类中的字符实际保存在内部维护的value字符数组中</strong></span></p> 
<p><span style="color:#956fe7;"><strong>String类被final修饰，不可以被继承</strong></span></p> 
<p><span style="color:#956fe7;"><strong>value被final修饰，表明value自身的值是不能被改变的，也就是不可以引用其他字符数组，但是它空间中的内容可以改变。</strong></span></p> 
<p><strong><span style="color:#ed7976;">所有涉及到修改字符串的操作，都是创建一个新对象，改变的是新对象</span></strong></p> 
<p>栗子：</p> 
<p><img alt="" height="320" src="https://images2.imgbox.com/01/3a/FhUCoXnY_o.png" width="946"></p> 
<p>注意：</p> 
<p><span style="color:#4da8ee;"><strong>这里字符串不能修改不是因为value被final修饰了，final修饰只是类是表示不能被继承，修饰引用类型表示不能引用其他对象，但是引用对象里面的内容还是可以修改的。</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>不能修改是因为value被private修饰，只能被当前类访问，在当前类的外部是访问不到的。</strong></span></p> 
<p>栗子：</p> 
<pre><code class="language-java">public static void main(String[] args) {
final int array[] = {1,2,3,4,5};
array[0] = 100;
System.out.println(Arrays.toString(array));
// array = new int[]{4,5,6}; // 编译报错：Error:(19, 9) java: 无法为最终变量array分配值
}</code></pre> 
<h3 id="String%E8%AE%BE%E8%AE%A1%E6%88%90%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E5%8E%9F%E5%9B%A0">String设计成不可变的原因</h3> 
<p><span style="color:#ed7976;"><strong>方便实现字符串对象池 ，如果String类可变，那么对象池就需要考虑拷贝的问题了</strong></span></p> 
<p><span style="color:#ed7976;"><strong>不可变对象的线程是安全的</strong></span></p> 
<p><span style="color:#ed7976;"><strong>不可变对象更方便缓存hash code，作为key的时候可以更高效的保存到HashMap中</strong></span></p> 
<h2 id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%BF%AE%E6%94%B9">字符串的修改</h2> 
<p>对于String类对象进行修改，它是不能直接修改的，会创建新的对象，效率就会变得地下，特别是在循环中使用的时候。</p> 
<pre><code class="language-java">public static void main(String[] args) {
        String s = "hello";
        s = s + "word";
        System.out.println(s);
    }</code></pre> 
<p>我们可以通过cmd观察底层实现逻辑：</p> 
<p>通过观察，发现它在这中间创建了一些临时变量，因此效率地下</p> 
<p><img alt="" height="704" src="https://images2.imgbox.com/a0/28/ufbs9y54_o.png" width="1200"></p> 
<pre><code class="language-java">public static void main2(String[] args) {
        long start = System.currentTimeMillis();
        String s = "";
        for(int i = 0; i &lt; 10000; ++i){
            s += i;
        } long end = System.currentTimeMillis();
        System.out.println(end - start);
        start = System.currentTimeMillis();
        StringBuffer sbf = new StringBuffer("");
        for(int i = 0; i &lt; 10000; ++i){
            sbf.append(i);
        } end = System.currentTimeMillis();
        System.out.println(end - start);
        start = System.currentTimeMillis();
        StringBuilder sbd = new StringBuilder();
        for(int i = 0; i &lt; 10000; ++i){
            sbd.append(i);
        } end = System.currentTimeMillis();
        System.out.println(end - start);
    }</code></pre> 
<p><img alt="" height="178" src="https://images2.imgbox.com/28/9a/uyN8wt6m_o.png" width="804"></p> 
<p>通过结果就可以发现他们相差的时间巨大，我们看看底层的执行逻辑：</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/ab/24/kvWH3DfF_o.png" width="1200"></p> 
<p><span style="color:#ed7976;"><strong>因此，我们需要尽量避免对String类的直接需要，要修改尽量使用StringBuffer和StringBuilder</strong></span></p> 
<h2 id="StringBuilder%E5%92%8CStringBuffer">StringBuilder和StringBuffer</h2> 
<p>因为String类的不可改变性，为了方便字符串的修改，java中提供了StringBuilder和Stringbuffer两个类。他们两个类的功能差不多相同。方法和String其实也差不多</p> 
<pre><code class="language-java">    public static void main(String[] args) {
        StringBuilder sb1 = new StringBuilder("hello");
        StringBuilder sb2 = sb1;
// 追加：即尾插--&gt;字符、字符串、整形数字
        sb1.append(' '); // hello
        sb1.append("world"); // hello world
        sb1.append(123); // hello world123
        System.out.println(sb1); // hello world123
        System.out.println(sb1 == sb2); // true
        System.out.println(sb1.charAt(0)); // 获取0号位上的字符 h
        System.out.println(sb1.length()); // 获取字符串的有效长度14
        System.out.println(sb1.capacity()); // 获取底层数组的总大小
        sb1.setCharAt(0, 'H'); // 设置任意位置的字符 Hello world123
        sb1.insert(0, "Hello world!!!"); // Hello world!!!Hello world123
        System.out.println(sb1);
        System.out.println(sb1.indexOf("Hello")); // 获取Hello第一次出现的位置
        System.out.println(sb1.lastIndexOf("hello")); // 获取hello最后一次出现的位置
        sb1.deleteCharAt(0); // 删除首字符
        sb1.delete(0,5); // 删除[0, 5)范围内的字符
        String str = sb1.substring(0, 5); // 截取[0, 5)区间中的字符以String的方式返回
        System.out.println(str);
        sb1.reverse(); // 字符串逆转
        str = sb1.toString(); // 将StringBuffer以String的方式返回
        System.out.println(str);
    }</code></pre> 
<p>String和StringBuffer，StringBuilder的区别就是前者不能修改，后两者可以修改。需要频繁修改字符串可以考虑使用后两者。</p> 
<p>这里需要注意几点：</p> 
<p><span style="color:#ed7976;"><strong>String类和Stringbuffer，StringBuilder不能直接转化</strong></span></p> 
<p><span style="color:#ed7976;"><strong>String转换为StringBilder，StringBuffer需要使用后者的构造方法或者append（）方法、</strong></span></p> 
<p><span style="color:#ed7976;"><strong>StringBuilder和Stringbuffer转换为String需要调用toString方法</strong></span></p> 
<h2 id="String%EF%BC%8CStringBuilder%EF%BC%8CStringBuffer%E7%9A%84%E5%8C%BA%E5%88%AB">String，StringBuilder，StringBuffer的区别</h2> 
<p><span style="color:#fe2c24;"><strong>String的内容不可以修改，而StringBuilder和StringBuffer可以修改内容</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>他们的大部分功能是相同的</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>StringBuffer是同步操作，线程是安全的；StringBuilder未同步操作，线程是不安全的</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>因为StringBuffer需要不断的关锁开锁，性能略低于StringBuilder</strong></span></p> 
<hr> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/894a7d88a1e82fc7dbe0ae01a7d0fa6f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Java 基础篇】Java HashSet 集合详解：高效存储唯一元素的利器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2379075489ee64a81adcb3b24f036a6b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43; 中的原子变量（std::atomic）使用指南</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>