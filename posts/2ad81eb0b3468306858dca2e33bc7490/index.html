<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Nginx&#43;Tomcat负载均衡、动静分离原理 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/2ad81eb0b3468306858dca2e33bc7490/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Nginx&#43;Tomcat负载均衡、动静分离原理">
  <meta property="og:description" content="目录
一.Nginx负载均衡
1.负载均衡概念
2.负载均衡原理
3.Nginx反向代理
3.1.反向代理概念
3.2.Nginx实现负载均衡的主要配置项
二.Nginx动静分离
1.什么是动静分离
2.动态页面与静态页面区别
3.动静分离原理
三.Nginx&#43;Tomcat负载均衡的实验设计
1.部署nginx负载均衡器
2.搭建tomcat服务器
2.1.Tomcat server（192.168.10.103） 配置
2.2.Tomcat server （192.168.80.102） 配置
3.Nginx进行负载均衡和动静分离设置
3.1.编写Nginx静态资源测试网页
3.2.进行负载均衡和动静分离配置
四.Nginx反向代理类型
1.七层反向代理设置
1.1.配置
2.四层反向代理设置
2.1.配置
3.Nginx的负载均衡模式（调度模式、调度算法、调度策略)
4.Nginx负载均衡会话保持
5.Nginx会话保持实现方式
5.1.ip_hash 或 一致性hash算法
5.2.sticky_cookie_insert
5.3.使用后端服务器自身通过相关机制保持session同步
一.Nginx负载均衡 1.负载均衡概念 服务端接受来自客户端的请求中，既有动态资源也有动态资源，静态资源由 Nginx 提供服务，动态
资源 Nginx 转发至后端
2.负载均衡原理 Nginx实现负载均衡是通过反向代理实现Nginx服务器作为前端，Tomcat服务器作为后端，web页
面请求由Nginx服务来进行转发。 但是不是把所有的web请求转发，而是将静态页面请求Nginx服
务器自己来处理，动态页面请求，转发给后端的Tomcat服务器来处理。据了解，Tomcat是属于轻
量级的应用服务器，可接受访问量可能会不足，所以我们需要多台Tomcat服务器。并且Tomcat并
发量处理能力弱（约Nginx的六分之一），所以需要Nginx方向代理时，进行合理的调用分配
3.Nginx反向代理 3.1.反向代理概念 将nginx接收到的请求转发给其他应用服务器处理
3.2.Nginx实现负载均衡的主要配置项 upstream 服务池名 { }
作用：配置后端服务器池，以提供响应数据 proxy_pass http:// 服务池名
作用：配置将访问请求转发给后端服务器池的服务器处理 upstream框架中，指令中涉及多个参数，各个参数含义说明如下
weight服务访问的权重，默认是1max_connsserver的最大并发连接数，仅作用于单worker进程，默认是0，表示没有限制max _fails在fail timeout时间段内，最大的失败次数，当达到最大失败时，会在failtimeout秒内这台server不允许再次被选择fail timeout单位为秒，默认10秒 proxy_pass http:// 服务池名作用：配置将访问请求转发给后端服务器池的服务器处理 二.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-11T21:59:41+08:00">
    <meta property="article:modified_time" content="2024-06-11T21:59:41+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Nginx&#43;Tomcat负载均衡、动静分离原理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80.Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-toc" style="margin-left:0px;"><a href="#%E4%B8%80.Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1" rel="nofollow">一.Nginx负载均衡</a></p> 
<p id="1.%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#1.%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%A6%82%E5%BF%B5" rel="nofollow">1.负载均衡概念</a></p> 
<p id="2.%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#2.%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8E%9F%E7%90%86" rel="nofollow">2.负载均衡原理</a></p> 
<p id="3.Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86-toc" style="margin-left:40px;"><a href="#3.Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86" rel="nofollow">3.Nginx反向代理</a></p> 
<p id="3.1.%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#3.1.%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%A6%82%E5%BF%B5" rel="nofollow">3.1.反向代理概念</a></p> 
<p id="3.2.Nginx%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E4%B8%BB%E8%A6%81%E9%85%8D%E7%BD%AE%E9%A1%B9-toc" style="margin-left:80px;"><a href="#3.2.Nginx%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E4%B8%BB%E8%A6%81%E9%85%8D%E7%BD%AE%E9%A1%B9" rel="nofollow">3.2.Nginx实现负载均衡的主要配置项</a></p> 
<p id="%E4%BA%8C.Nginx%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.Nginx%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB" rel="nofollow">二.Nginx动静分离</a></p> 
<p id="1.%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB-toc" style="margin-left:40px;"><a href="#1.%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB" rel="nofollow">1.什么是动静分离</a></p> 
<p id="2.%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E4%B8%8E%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#2.%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E4%B8%8E%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E5%8C%BA%E5%88%AB" rel="nofollow">2.动态页面与静态页面区别</a></p> 
<p id="3.%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#3.%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB%E5%8E%9F%E7%90%86" rel="nofollow">3.动静分离原理</a></p> 
<p id="%E4%B8%89.Nginx%2BTomcat%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E5%AE%9E%E9%AA%8C%E8%AE%BE%E8%AE%A1-toc" style="margin-left:0px;"><a href="#%E4%B8%89.Nginx%2BTomcat%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E5%AE%9E%E9%AA%8C%E8%AE%BE%E8%AE%A1" rel="nofollow">三.Nginx+Tomcat负载均衡的实验设计</a></p> 
<p id="1.%E9%83%A8%E7%BD%B2nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8-toc" style="margin-left:40px;"><a href="#1.%E9%83%A8%E7%BD%B2nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8" rel="nofollow">1.部署nginx负载均衡器</a></p> 
<p id="2.%E6%90%AD%E5%BB%BAtomcat%E6%9C%8D%E5%8A%A1%E5%99%A8-toc" style="margin-left:40px;"><a href="#2.%E6%90%AD%E5%BB%BAtomcat%E6%9C%8D%E5%8A%A1%E5%99%A8" rel="nofollow">2.搭建tomcat服务器</a></p> 
<p id="2.1.Tomcat%20server%EF%BC%88192.168.10.103%EF%BC%89%20%E9%85%8D%E7%BD%AE-toc" style="margin-left:80px;"><a href="#2.1.Tomcat%20server%EF%BC%88192.168.10.103%EF%BC%89%20%E9%85%8D%E7%BD%AE" rel="nofollow">2.1.Tomcat server（192.168.10.103） 配置</a></p> 
<p id="2.2.Tomcat%C2%A0server%C2%A0%20%EF%BC%88192.168.80.102%EF%BC%89%C2%A0%E9%85%8D%E7%BD%AE-toc" style="margin-left:80px;"><a href="#2.2.Tomcat%C2%A0server%C2%A0%20%EF%BC%88192.168.80.102%EF%BC%89%C2%A0%E9%85%8D%E7%BD%AE" rel="nofollow">2.2.Tomcat server  （192.168.80.102） 配置</a></p> 
<p id="3.Nginx%E8%BF%9B%E8%A1%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%92%8C%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB%E8%AE%BE%E7%BD%AE-toc" style="margin-left:40px;"><a href="#3.Nginx%E8%BF%9B%E8%A1%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%92%8C%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB%E8%AE%BE%E7%BD%AE" rel="nofollow">3.Nginx进行负载均衡和动静分离设置</a></p> 
<p id="3.1.%E7%BC%96%E5%86%99Nginx%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%B5%8B%E8%AF%95%E7%BD%91%E9%A1%B5-toc" style="margin-left:80px;"><a href="#3.1.%E7%BC%96%E5%86%99Nginx%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%B5%8B%E8%AF%95%E7%BD%91%E9%A1%B5" rel="nofollow">3.1.编写Nginx静态资源测试网页</a></p> 
<p id="3.2.%E8%BF%9B%E8%A1%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%92%8C%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB%E9%85%8D%E7%BD%AE-toc" style="margin-left:80px;"><a href="#3.2.%E8%BF%9B%E8%A1%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%92%8C%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB%E9%85%8D%E7%BD%AE" rel="nofollow">3.2.进行负载均衡和动静分离配置</a></p> 
<p id="4.Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%B1%BB%E5%9E%8B-toc" style="margin-left:0px;"><a href="#4.Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%B1%BB%E5%9E%8B" rel="nofollow">四.Nginx反向代理类型</a></p> 
<p id="1.%E4%B8%83%E5%B1%82%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE-toc" style="margin-left:40px;"><a href="#1.%E4%B8%83%E5%B1%82%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE" rel="nofollow">1.七层反向代理设置</a></p> 
<p id="1.1.%E9%85%8D%E7%BD%AE-toc" style="margin-left:80px;"><a href="#1.1.%E9%85%8D%E7%BD%AE" rel="nofollow">1.1.配置</a></p> 
<p id="2.%E5%9B%9B%E5%B1%82%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE-toc" style="margin-left:40px;"><a href="#2.%E5%9B%9B%E5%B1%82%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE" rel="nofollow">2.四层反向代理设置</a></p> 
<p id="2.1.%E9%85%8D%E7%BD%AE-toc" style="margin-left:80px;"><a href="#2.1.%E9%85%8D%E7%BD%AE" rel="nofollow">2.1.配置</a></p> 
<p id="3.Nginx%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%BC%8F%E3%80%81%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E3%80%81%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5)-toc" style="margin-left:40px;"><a href="#3.Nginx%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%BC%8F%E3%80%81%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E3%80%81%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5%29" rel="nofollow">3.Nginx的负载均衡模式（调度模式、调度算法、调度策略)</a></p> 
<p id="4.Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%BC%9A%E8%AF%9D%E4%BF%9D%E6%8C%81-toc" style="margin-left:40px;"><a href="#4.Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%BC%9A%E8%AF%9D%E4%BF%9D%E6%8C%81" rel="nofollow">4.Nginx负载均衡会话保持</a></p> 
<p id="5.%20Nginx%E4%BC%9A%E8%AF%9D%E4%BF%9D%E6%8C%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><a href="#5.%20Nginx%E4%BC%9A%E8%AF%9D%E4%BF%9D%E6%8C%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F" rel="nofollow">5.Nginx会话保持实现方式</a></p> 
<p id="5.1.ip_hash%20%E6%88%96%20%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95-toc" style="margin-left:80px;"><a href="#5.1.ip_hash%20%E6%88%96%20%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95" rel="nofollow">5.1.ip_hash 或 一致性hash算法</a></p> 
<p id="5.2.sticky_cookie_insert-toc" style="margin-left:80px;"><a href="#5.2.sticky_cookie_insert" rel="nofollow">5.2.sticky_cookie_insert</a></p> 
<p id="5.3.%E4%BD%BF%E7%94%A8%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%87%AA%E8%BA%AB%E9%80%9A%E8%BF%87%E7%9B%B8%E5%85%B3%E6%9C%BA%E5%88%B6%E4%BF%9D%E6%8C%81session%E5%90%8C%E6%AD%A5-toc" style="margin-left:80px;"><a href="#5.3.%E4%BD%BF%E7%94%A8%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%87%AA%E8%BA%AB%E9%80%9A%E8%BF%87%E7%9B%B8%E5%85%B3%E6%9C%BA%E5%88%B6%E4%BF%9D%E6%8C%81session%E5%90%8C%E6%AD%A5" rel="nofollow">5.3.使用后端服务器自身通过相关机制保持session同步</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2>一.Nginx负载均衡</h2> 
<h3 id="1.%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%A6%82%E5%BF%B5">1.负载均衡概念</h3> 
<p>服务端接受来自客户端的请求中，既有动态资源也有动态资源，静态资源由 Nginx 提供服务，动态</p> 
<p>资源 Nginx 转发至后端</p> 
<h3 id="2.%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8E%9F%E7%90%86">2.负载均衡原理</h3> 
<p>Nginx实现负载均衡是通过反向代理实现Nginx服务器作为前端，Tomcat服务器作为后端，web页</p> 
<p>面请求由Nginx服务来进行转发。 但是不是把所有的web请求转发，而是将静态页面请求Nginx服</p> 
<p>务器自己来处理，动态页面请求，转发给后端的Tomcat服务器来处理。据了解，Tomcat是属于轻</p> 
<p>量级的应用服务器，可接受访问量可能会不足，所以我们需要多台Tomcat服务器。并且Tomcat并</p> 
<p>发量处理能力弱（约Nginx的六分之一），所以需要Nginx方向代理时，进行合理的调用分配</p> 
<p><img alt="" height="609" src="https://images2.imgbox.com/d0/43/WyHYbDTf_o.png" width="676"></p> 
<h3 id="3.Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86">3.Nginx反向代理</h3> 
<h4 id="3.1.%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%A6%82%E5%BF%B5">3.1.反向代理概念</h4> 
<p>将nginx接收到的请求转发给其他应用服务器处理</p> 
<h4 id="3.2.Nginx%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E4%B8%BB%E8%A6%81%E9%85%8D%E7%BD%AE%E9%A1%B9">3.2.Nginx实现负载均衡的主要配置项</h4> 
<p>upstream 服务池名 {   }</p> 
<ul><li>作用：配置后端服务器池，以提供响应数据</li></ul> 
<p>proxy_pass http:// 服务池名</p> 
<ul><li>作用：配置将访问请求转发给后端服务器池的服务器处理</li></ul> 
<p><strong>upstream框架中，指令中涉及多个参数，各个参数含义说明如下</strong></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:660px;"><tbody><tr><td><strong>weight</strong></td><td><strong>服务访问的权重，默认是1</strong></td></tr><tr><td><strong>max_conns</strong></td><td><strong>server的最大并发连接数，仅作用于单worker进程，默认是0，表示没有限制</strong></td></tr><tr><td><strong>max _fails</strong></td><td><strong>在fail timeout时间段内，最大的失败次数，当达到最大失败时，会在failtimeout秒内这台server不允许再次被选择</strong></td></tr><tr><td><strong>fail timeout</strong></td><td><strong>单位为秒，默认10秒</strong></td></tr></tbody></table> 
<ul><li>proxy_pass http:// 服务池名</li><li>作用：配置将访问请求转发给后端服务器池的服务器处理</li></ul> 
<h2 id="%E4%BA%8C.Nginx%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB">二.Nginx动静分离</h2> 
<h3 id="1.%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB">1.什么是动静分离</h3> 
<ul><li>动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路</li><li>动静分离简单的概括是：动态文件与静态文件的分离</li><li>伪静态：网站如果想被搜索引擎搜素到，动态页面静态技术freemarker等模版引擎技术</li></ul> 
<h3 id="2.%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E4%B8%8E%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E5%8C%BA%E5%88%AB">2.动态页面与静态页面区别</h3> 
<ul><li>静态资源：当用户多次访问这个资源，资源的源代码永远不会改变的资源</li><li>动态资源：当用户多次访问这个资源，资源的源代码可能会发送改变</li></ul> 
<h3 id="3.%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB%E5%8E%9F%E7%90%86">3.动静分离原理</h3> 
<ul><li>服务端接收来自客户端的请求中，既有静态资源也有动态资源，静态资源由Nginx提供服务，动态资源由Nginx转发至后端</li></ul> 
<p><img alt="" height="795" src="https://images2.imgbox.com/f0/46/C5UPrPAX_o.png" width="1200"></p> 
<h2 id="%E4%B8%89.Nginx%2BTomcat%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E5%AE%9E%E9%AA%8C%E8%AE%BE%E8%AE%A1">三.Nginx+Tomcat负载均衡的实验设计</h2> 
<h3 id="1.%E9%83%A8%E7%BD%B2nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8" style="background-color:transparent;">1.部署nginx负载均衡器</h3> 
<p><strong>192.168.80.101</strong></p> 
<pre><code class="hljs">systemctl stop firewalld
setenforce 0
 
yum -y install pcre-devel zlib-devel openssl-devel gcc gcc-c++ make
 
useradd -M -s /sbin/nologin nginx
 
cd /opt
tar xf nginx-1.26.0.tar.gz
 
cd nginx-1.26.0/
./configure \
--prefix=/usr/local/nginx \
--user=nginx \
--group=nginx \
--with-file-aio \									#启用文件修改支持
--with-http_stub_status_module \					#启用状态统计
--with-http_gzip_static_module \					#启用 gzip静态压缩
--with-http_flv_module \							#启用 flv模块，提供对 flv 视频的伪流支持
--with-http_ssl_module								#启用 SSL模块，提供SSL加密功能
--with-stream										#启用 stream模块，提供4层调


make -j 2 &amp;&amp; make install
 
ln -s /usr/local/nginx/sbin/nginx /usr/local/sbin/
 
vim /lib/systemd/system/nginx.service
[Unit]
Description=nginx
After=network.target
[Service]
Type=forking
PIDFile=/usr/local/nginx/logs/nginx.pid
ExecStart=/usr/local/nginx/sbin/nginx
ExecrReload=/bin/kill -s HUP $MAINPID
ExecrStop=/bin/kill -s QUIT $MAINPID
PrivateTmp=true
[Install]
WantedBy=multi-user.target
 
chmod 754 /lib/systemd/system/nginx.service
systemctl start nginx.service
systemctl enable nginx.service</code></pre> 
<h3 id="2.%E6%90%AD%E5%BB%BAtomcat%E6%9C%8D%E5%8A%A1%E5%99%A8">2.搭建tomcat服务器</h3> 
<p><strong>tomcat1 和tomcat2（192.168.80.102）</strong></p> 
<p><strong>tomcat3（192.168.10.103）</strong></p> 
<pre><code class="hljs">systemctl stop firewalld
setenforce 0
 
 
#软件包的方式安装jdk环境
tar zxvf jdk-8u91-linux-x64.tar.gz -C /usr/local/
 
vim /etc/profile
export JAVA_HOME=/usr/local/jdk1.8.0_91
export JRE_HOME=${JAVA_HOME}/jre
export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib
export PATH=${JAVA_HOME}/bin:${JRE_HOME}/bin:$PATH
 
source /etc/profile
 
tar zxvf apache-tomcat-9.0.16.tar.gz
 
mv /opt/apache-tomcat-9.0.16/ /usr/local/tomcat
 
/usr/local/tomcat/bin/shutdown.sh 
/usr/local/tomcat/bin/startup.sh
 
netstat -ntap | grep 8080</code></pre> 
<h4 id="2.1.Tomcat%20server%EF%BC%88192.168.10.103%EF%BC%89%20%E9%85%8D%E7%BD%AE">2.1.<strong>Tomcat server（192.168.10.103） 配置</strong></h4> 
<pre><code class="hljs">mkdir /usr/local/tomcat/webapps/test
vim /usr/local/tomcat/webapps/test/index.jsp
&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;JSP test3 page&lt;/title&gt;   #指定为 test3 页面
&lt;/head&gt;
&lt;body&gt;
&lt;% out.println("动态页面 3,http://www.test3.com");%&gt;
&lt;/body&gt;
&lt;/html&gt;
 
 
vim /usr/local/tomcat/conf/server.xml
#由于主机名 name 配置都为 localhost，需要删除前面的 HOST 配置
&lt;Host name="localhost" appBase="webapps" unpackWARs="true" autoDeploy="true" xmlValidation="false" xmlNamespaceAware="false"&gt;
	&lt;Context docBase="/usr/local/tomcat/webapps/test" path="" reloadable="true"&gt;
	&lt;/Context&gt;
&lt;/Host&gt;
 
/usr/local/tomcat/bin/shutdown.sh 
/usr/local/tomcat/bin/startup.sh</code></pre> 
<h4 id="2.2.Tomcat%C2%A0server%C2%A0%20%EF%BC%88192.168.80.102%EF%BC%89%C2%A0%E9%85%8D%E7%BD%AE">2.2.<strong>Tomcat server  （192.168.80.102） 配置</strong></h4> 
<p><strong>tomcat1</strong></p> 
<pre><code class="hljs">mkdir /usr/local/tomcat/tomcat1/webapps/test /usr/local/tomcat/tomcat2/webapps/test
 
vim /usr/local/tomcat/tomcat1/webapps/test/index.jsp
&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;JSP test2 page&lt;/title&gt;   #指定为 test2 页面
&lt;/head&gt;
&lt;body&gt;
&lt;% out.println("动态页面 2,http://www.test2.com");%&gt;
&lt;/body&gt;
&lt;/html&gt;
 
 
vim /usr/local/tomcat/tomcat1/conf/server.xml
#删除前面的 HOST 配置
&lt;Host name="localhost" appBase="webapps" unpackWARs="true" autoDeploy="true" xmlValidation="false" xmlNamespaceAware="false"&gt;
	&lt;Context docBase="/usr/local/tomcat/tomcat1/webapps/test" path="" reloadable="true" /&gt;
&lt;/Host&gt;
 
/usr/local/tomcat/tomcat1/bin/shutdown.sh 
/usr/local/tomcat/tomcat1/bin/startup.sh</code></pre> 
<p><strong>tomcat2</strong></p> 
<pre><code class="hljs">vim /usr/local/tomcat/tomcat2/webapps/test/index.jsp
&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;JSP test1  page&lt;/title&gt;  
&lt;/head&gt;
&lt;body&gt;
&lt;% out.println("动态页面 1,http://www.test1.com");%&gt;
&lt;/body&gt;
&lt;/html&gt;
 
 
vim /usr/local/tomcat/tomcat2/conf/server.xml
#删除前面的 HOST 配置
&lt;Host name="localhost" appBase="webapps" unpackWARs="true" autoDeploy="true" xmlValidation="false" xmlNamespaceAware="false"&gt;
	&lt;Context docBase="/usr/local/tomcat/tomcat2/webapps/test" path="" reloadable="true" /&gt;
&lt;/Host&gt;
 
/usr/local/tomcat/tomcat2/bin/shutdown.sh 
/usr/local/tomcat/tomcat2/bin/startup.sh </code></pre> 
<h3 id="3.Nginx%E8%BF%9B%E8%A1%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%92%8C%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB%E8%AE%BE%E7%BD%AE">3.<strong>Nginx进行负载均衡和动静分离设置</strong></h3> 
<h4 id="3.1.%E7%BC%96%E5%86%99Nginx%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%B5%8B%E8%AF%95%E7%BD%91%E9%A1%B5"><strong>3.1.编写Nginx静态资源测试网页</strong></h4> 
<pre><code class="hljs">vim /usr/local/nginx/html/index.html
&lt;html&gt;
&lt;body&gt;
&lt;h1&gt; this is Nginx static test !&lt;/h2&gt;
&lt;img src="test.png"/&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<h4 id="3.2.%E8%BF%9B%E8%A1%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%92%8C%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB%E9%85%8D%E7%BD%AE"><strong>3.2.进行负载均衡和动静分离配置</strong></h4> 
<pre><code class="hljs">vim /usr/local/nginx/conf/nginx.conf
......
http {
......
	#gzip on;
	
	#配置负载均衡的服务器列表，weight参数表示权重，权重越高，被分配到的概率越大
	upstream tomcat_server {
		server 192.168.80.102:8080 weight=1;
		server 192.168.80.102:8081 weight=1;
		server 192.168.80.103:8080 weight=1;
	}
	
	server {
		listen 80;
		server_name www.test.com;
	
		charset utf-8;
	
		#access_log logs/host.access.log main;
		
		#配置Nginx处理动态页面请求，将 .jsp文件请求转发到Tomcat 服务器处理
		location ~ .*\.jsp$ {
			proxy_pass http://tomcat_server;
#设置后端的Web服务器可以获取远程客户端的真实IP
##设定后端的Web服务器接收到的请求访问的主机名（域名或IP、端口），默认HOST的值为proxy_pass指令设置的主机名。如果反向代理服务器不重写该请求头的话，那么后端真实服务器在处理时会认为所有的请求都来自反向代理服务器，如果后端有防攻击策略的话，那么机器就被封掉了。
			proxy_set_header HOST $host;
##把$remote_addr赋值给X-Real-IP，来获取源IP
			proxy_set_header X-Real-IP $remote_addr;
##在nginx 作为代理服务器时，设置的IP列表，会把经过的机器ip，代理机器ip都记录下来
			proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
		}
		
		#配置Nginx处理静态图片请求
		location ~ .*\.(gif|jpg|jpeg|png|bmp|swf|css)$ {
			root /usr/local/nginx/html;
			expires 10d;
		}
		
		location / {
			root html;
			index index.html index.htm;
		}
......
	}
......
}</code></pre> 
<h2 id="4.Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%B1%BB%E5%9E%8B">四.Nginx反向代理类型</h2> 
<h3 id="1.%E4%B8%83%E5%B1%82%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE">1.七层反向代理设置</h3> 
<p>基于http、https、mail等七层应用协议的代理转发（根据用户访问请求的URL路径来转发请求），</p> 
<p>通常用于 动静分离 等应用场景</p> 
<h4 id="1.1.%E9%85%8D%E7%BD%AE">1.1.配置</h4> 
<pre><code class="hljs">1）在http配置块中使用upstream定义后端服务器列表名称和节点参数
http {
    upstream 服务器池名称 {
        server IP1:PORT1 weight=1;
        server IP2:PORT2 weight=1;
        ......
    }


2）在server配置块中使用location匹配用户请求的动态页面的URL路径，使用 proxy_pass 基于协议代理转发
    server {
	    ......
	    location ~ .*\.jsp$ {
		    proxy_pass http://服务器池名称;
		    
			#用于为后端服务器获取真实的客户端地址
		    proxy_set_header HOST $host;
            proxy_set_header X_Real_IP $remote_addr;
            proxy_set_header X_Forwarded_For $proxy_add_x_forwarded_for;
		}
    ......
	}
......
}</code></pre> 
<h3 id="2.%E5%9B%9B%E5%B1%82%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE">2.四层反向代理设置</h3> 
<p>基于 IP 和 端口 实现的代理转发（根据用户请求的IP和端口来转发请求），通常用于做 网关访问</p> 
<p>入口的负载均衡器 等应用场景</p> 
<h4 id="2.1.%E9%85%8D%E7%BD%AE">2.1.配置</h4> 
<pre><code class="hljs">1）编译安装时需要添加 stream 四层代理模块  ./configure --with-stream

2）在 http 配置块同层级，一般在 http 配置块上面添加 stream 配置块，在 stream 配置块里使用upstream定义后端服务器列表名称和节点参数以及使用server配置块定义监听端口和转发配置
stream {
    upstream 服务器池名称 {
        server IP1:PORT1 weight=1;
        server IP2:PORT2 weight=1;
        ......
    }

    server {
	    listen IP:PORT;
		proxy_pass 服务器池名称;
	}
}

http {....}</code></pre> 
<p><strong>补充：</strong></p> 
<ul><li>四层反向代理 比 七层反向代理 转发性能更高于；</li><li>七层反向代理 比 四层反向代理 转发功能更多、更灵活</li></ul> 
<h3 id="3.Nginx%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%BC%8F%E3%80%81%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E3%80%81%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5)">3.Nginx的负载均衡模式（调度模式、调度算法、调度策略)</h3> 
<table border="1" cellpadding="1" cellspacing="1" style="width:660px;"><tbody><tr><td><strong>轮询（round robin、rr）</strong></td><td><strong>是nginx的默认调度模式，按照时间顺序逐一分配请求</strong></td></tr><tr><td><strong>加权轮询（weight round、wrr）</strong></td><td><strong>使用weight参数设置权重，weight值越高的节点被分配请求的概率越大</strong></td></tr><tr><td><strong>least_conn（最少链接、最小连接）</strong></td><td><strong>优先将请求分配给当前连接数最少的节点</strong></td></tr><tr><td><strong>ip_hash（源地址哈希）</strong></td><td><strong>根据客户端IP做hash缓存调度，会将请求分配给固定的一个节点</strong></td></tr><tr><td><strong>url_hash（目的地址哈希）</strong></td><td><strong>根据客户端请求访问的URL路径做hash缓存调度，会将请求分配给固定的一个节点。需要另外安装第三方模块支持</strong></td></tr><tr><td><strong>fdir</strong></td><td><strong>优先将请求分配给响应时间最少的节点，需要另外安装第三方模块支持</strong></td></tr><tr><td> <p><strong>random</strong></p> </td><td><strong>随机分配请求</strong></td></tr><tr><td><strong>hash nginx全局变量 consistent</strong></td><td> <p><strong>一致性hash算法，根据nginx全局变量的值来做hash缓存调度</strong></p> <p><strong>（比如 hash $remote_addr consistent   根据客户端IP做hash缓存调度，是IP_hash的加强版）</strong></p> </td></tr></tbody></table> 
<h3 id="4.Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%BC%9A%E8%AF%9D%E4%BF%9D%E6%8C%81">4.Nginx负载均衡会话保持</h3> 
<p><strong>作用：</strong>简单说就是优化用户体验，降低网络开销</p> 
<ul><li>如果有一个用户访问请求被分配到服务器A，并且在服务器A登录了，并且在很短的时间，这个用户又发出了一个请求，如果没有会话保持功能的话，这个用户的请求很有可能会被分配到服务器B去，这个时候在服务器B上是没有登录的，所以你要重新登录，但是用户并不知道自己的请求被分配到了哪里，用户的感觉就是登录了怎么又要登录，用户体验很不好上</li><li>会话保持都会有时间的限制(映射到固定某一台的服务器除外工如:ip_hash),各种负载均衡工具都会提供这种会话保持时间的设置，LVS，apache等。连php语言都提供了会话保持时间的设定session.gc_maxlifetime会话保持时间的设定要大于session生存时间的设定，这样可以减少需要同步session的情况，但是不能杜绝。所以同步session还是要做的</li></ul> 
<h3 id="5.%20Nginx%E4%BC%9A%E8%AF%9D%E4%BF%9D%E6%8C%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">5.Nginx会话保持实现方式</h3> 
<h4 id="5.1.ip_hash%20%E6%88%96%20%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95">5.1.ip_hash 或 一致性hash算法</h4> 
<p>基于客户端IP做hash缓存将请求发送给同一个后端节点服务器来实现会话保持，但是此方法容易导</p> 
<p>致负载失衡问题</p> 
<pre><code class="hljs">语法:

upstream backend {
ip hash:
server backendl.example.com:
server backend2.example.com,
server backend3.example.com down:
server backend4.example.com:
}
</code></pre> 
<h4 id="5.2.sticky_cookie_insert">5.2.sticky_cookie_insert</h4> 
<p>基于cookie来来判断实现会话保持</p> 
<pre><code class="hljs">语法:

upstream backend {
server backendl.example.com:
server backend2.example.com!
sticky cookie insert srv id expires=lh domain=3evip.cn path=/:
}

说明:
设置浏览器中保持cookie的时间expires.
domain:定义cookie的域
path:为cookie定义路径
</code></pre> 
<h4 id="5.3.%E4%BD%BF%E7%94%A8%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%87%AA%E8%BA%AB%E9%80%9A%E8%BF%87%E7%9B%B8%E5%85%B3%E6%9C%BA%E5%88%B6%E4%BF%9D%E6%8C%81session%E5%90%8C%E6%AD%A5">5.3.使用后端服务器自身通过相关机制保持session同步</h4> 
<p>通过缓存数据库做session同步复制，使用后端节点服务器自身配置通过相关机制保持session同步</p> 
<p>来实现会话保持</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/eac9c015a4c791eb3cd535a774a4a683/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2024050802-重学 Java 设计模式《实战模板模式》</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9b5ec9828dcdac4b0b99c252a81e30c6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Kafka专栏 09】Kafka消费者如何实现如何实现消息回溯与重放：谁说“覆水难收”？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>