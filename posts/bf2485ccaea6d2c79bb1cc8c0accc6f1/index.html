<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构栈和队列 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/bf2485ccaea6d2c79bb1cc8c0accc6f1/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构栈和队列">
  <meta property="og:description" content="个人主页：星纭-CSDN博客
系列文章专栏：数据结构
踏上取经路，比抵达灵山更重要！一起努力一起进步！
目录
一.栈 1.栈的介绍
2.初始化与销毁
3.入栈和出栈
4.栈顶元素，判空，求栈的元素个数
代码：
test.c
stack.h:
stack.c:
二.队列 1.队列的介绍
2.初始化与销毁
3.插入与删除 4.查看队头队尾元素
5.判空与队列大小
代码：
一.栈 1.栈的介绍 栈是一种线性数据结构，它只能在固定的一端进行插入和删除操作，这一端被称为栈顶，另一端则称为栈底。栈的特点是后进先出（Last In First Out，LIFO），即最后插入的元素最先被删除，而最先插入的元素最后被删除。
栈的基本操作有两个：入栈（push）和出栈（pop）。入栈操作将元素插入到栈顶，出栈操作将栈顶元素删除并返回。 入栈：栈插入数据的操作也叫入栈/压栈/进栈，入数据在栈顶。出栈：栈的删除操作也叫做出栈。出数据也在栈顶。 栈可以用来解决一些具有后效性的问题，例如表达式求值、括号匹配、函数调用等。它也可以用于实现一些常见的数据结构，例如递归函数、深度优先搜索等。 栈可以使用数组或链表来实现。使用数组实现的栈称为顺序栈，使用链表实现的栈称为链式栈。无论使用哪种实现方式，栈的空间复杂度都为O(n)，其中n为栈中元素的个数。 栈还有一些常见的扩展操作，例如获取栈顶元素（top）、判断栈是否为空（isEmpty）、获取栈中元素个数（size）等。这些操作的时间复杂度都为O(1)。
对于顺序栈来说，又分两种情况：一种是定长的静态栈结构，一般情况下，实际中用的比较少，另一种是支持动态增长的栈。
以下的栈的实现，作者基于支持动态增长的顺序栈完成。
typedef int STDatatype; typedef struct{ STDatatype* a; int top;//栈顶 int capacity;//栈的容量 }Stack; 为了方便对存储的数据类型进行更改，我们对int重命名一下，如果以后要存储char类型的数据，只需要更改一下int为char就可以轻松完成。 2.初始化与销毁 //初始化 void STInit(Stack* pst); //销毁 void STDestory(Stack* pst); 1.初始化
void STInit(Stack* pst) { pst-&gt;a = NULL; pst-&gt;capacity = pst-&gt;top = 0; }; 因为开始的时候，这个栈中并没有任何的元素，所以我们将其的a初始化为NULL,top和capacity为0.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-20T11:00:00+08:00">
    <meta property="article:modified_time" content="2024-05-20T11:00:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构栈和队列</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p class="img-center"><img alt="" height="125" src="https://images2.imgbox.com/c9/47/kxGgJwtb_o.gif" width="1000"></p> 
<p style="text-align:center;"><strong>个人主页：<strong><strong><strong><strong><strong><strong><strong><a href="https://blog.csdn.net/CNDS_lili?spm=1011.2266.3001.5343" title="星纭-CSDN博客">星纭-CSDN博客</a></strong></strong></strong></strong></strong></strong></strong></strong></p> 
<p style="text-align:center;"><strong>系列文章专栏：<strong><strong><strong><strong><strong><strong><strong><a href="http://t.csdnimg.cn/bzodE" rel="nofollow" title="数据结构">数据结构</a></strong></strong></strong></strong></strong></strong></strong></strong></p> 
<p style="text-align:center;"><strong>踏上取经路，比抵达灵山更重要！一起努力一起进步！</strong></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80.%E6%A0%88%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%B8%80.%E6%A0%88%C2%A0" rel="nofollow">一.栈 </a></p> 
<p id="1.%E6%A0%88%E7%9A%84%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#1.%E6%A0%88%E7%9A%84%E4%BB%8B%E7%BB%8D" rel="nofollow">1.栈的介绍</a></p> 
<p id="2.%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E9%94%80%E6%AF%81-toc" style="margin-left:40px;"><a href="#2.%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E9%94%80%E6%AF%81" rel="nofollow">2.初始化与销毁</a></p> 
<p id="3.%E5%85%A5%E6%A0%88%E5%92%8C%E5%87%BA%E6%A0%88-toc" style="margin-left:40px;"><a href="#3.%E5%85%A5%E6%A0%88%E5%92%8C%E5%87%BA%E6%A0%88" rel="nofollow">3.入栈和出栈</a></p> 
<p id="4.%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0%EF%BC%8C%E5%88%A4%E7%A9%BA%EF%BC%8C%E6%B1%82%E6%A0%88%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0-toc" style="margin-left:40px;"><a href="#4.%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0%EF%BC%8C%E5%88%A4%E7%A9%BA%EF%BC%8C%E6%B1%82%E6%A0%88%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0" rel="nofollow">4.栈顶元素，判空，求栈的元素个数</a></p> 
<p id="%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">代码：</a></p> 
<p id="test.c-toc" style="margin-left:80px;"><a href="#test.c" rel="nofollow">test.c</a></p> 
<p id="stack.h%3A-toc" style="margin-left:80px;"><a href="#stack.h%3A" rel="nofollow">stack.h:</a></p> 
<p id="stack.c%3A-toc" style="margin-left:80px;"><a href="#stack.c%3A" rel="nofollow">stack.c:</a></p> 
<p id="%E4%BA%8C.%E9%98%9F%E5%88%97%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.%E9%98%9F%E5%88%97%C2%A0" rel="nofollow">二.队列 </a></p> 
<p id="1.%E9%98%9F%E5%88%97%E7%9A%84%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#1.%E9%98%9F%E5%88%97%E7%9A%84%E4%BB%8B%E7%BB%8D" rel="nofollow">1.队列的介绍</a></p> 
<p id="2.%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E9%94%80%E6%AF%81-toc" style="margin-left:40px;"><a href="#2.%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E9%94%80%E6%AF%81" rel="nofollow">2.初始化与销毁</a></p> 
<p id="3.%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4%C2%A0-toc" style="margin-left:40px;"><a href="#3.%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4%C2%A0" rel="nofollow">3.插入与删除 </a></p> 
<p id="4.%E6%9F%A5%E7%9C%8B%E9%98%9F%E5%A4%B4%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0-toc" style="margin-left:40px;"><a href="#4.%E6%9F%A5%E7%9C%8B%E9%98%9F%E5%A4%B4%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0" rel="nofollow">4.查看队头队尾元素</a></p> 
<p id="%C2%A05.%E5%88%A4%E7%A9%BA%E4%B8%8E%E9%98%9F%E5%88%97%E5%A4%A7%E5%B0%8F-toc" style="margin-left:40px;"><a href="#%C2%A05.%E5%88%A4%E7%A9%BA%E4%B8%8E%E9%98%9F%E5%88%97%E5%A4%A7%E5%B0%8F" rel="nofollow"> 5.判空与队列大小</a></p> 
<p id="%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">代码：</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80.%E6%A0%88%C2%A0">一.栈 </h2> 
<h3 id="1.%E6%A0%88%E7%9A%84%E4%BB%8B%E7%BB%8D">1.栈的介绍</h3> 
<p>栈是一种线性数据结构，它只能在固定的<strong>一端</strong>进行插入和删除操作，这一端被称为<span style="color:#fe2c24;">栈顶</span><span style="color:#0d0016;">，另一端则称为</span><span style="color:#fe2c24;">栈底</span>。栈的特点是后进先出（Last In First Out，LIFO），即最后插入的元素最先被删除，而最先插入的元素最后被删除。</p> 
<p>栈的基本操作有两个：<span style="color:#fe2c24;">入栈（push）和出栈（pop）</span>。入栈操作将元素插入到栈顶，出栈操作将栈顶元素删除并返回。 </p> 
<ol><li>入栈：栈插入数据的操作也叫入栈/压栈/进栈，入数据在栈顶。</li><li>出栈：栈的删除操作也叫做出栈。出数据也在栈顶。</li></ol> 
<p>栈可以用来解决一些具有后效性的问题，例如表达式求值、括号匹配、函数调用等。它也可以用于实现一些常见的数据结构，例如递归函数、深度优先搜索等。 </p> 
<p class="img-center"><img alt="" height="342" src="https://images2.imgbox.com/7a/38/OCiA5cl1_o.png" width="700"></p> 
<p></p> 
<p>栈可以使用数组或链表来实现。使用数组实现的栈称为顺序栈，使用链表实现的栈称为链式栈。无论使用哪种实现方式，栈的空间复杂度都为O(n)，其中n为栈中元素的个数。 </p> 
<p class="img-center"><img alt="" height="235" src="https://images2.imgbox.com/94/27/qyq0qqDZ_o.png" width="1000"></p> 
<p>栈还有一些常见的扩展操作，例如<strong><span style="color:#fe2c24;">获取栈顶元素（top）</span></strong>、<span style="color:#fe2c24;"><strong>判断栈是否为空（isEmpty）</strong></span>、<span style="color:#fe2c24;"><strong>获取栈中元素个数（size）</strong></span>等。这些操作的时间复杂度都为O(1)。</p> 
<p>对于顺序栈来说，又分两种情况：一种是定长的静态栈结构，一般情况下，实际中用的比较少，另一种是支持动态增长的栈。</p> 
<p>以下的栈的实现，作者基于支持动态增长的顺序栈完成。</p> 
<pre><code class="language-cpp">typedef int STDatatype;
typedef struct{
	STDatatype* a;
	int top;//栈顶
	int capacity;//栈的容量
}Stack;</code></pre> 
<p>为了方便对存储的数据类型进行更改，我们对int重命名一下，如果以后要存储char类型的数据，只需要更改一下int为char就可以轻松完成。 </p> 
<h3 id="2.%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E9%94%80%E6%AF%81">2.初始化与销毁</h3> 
<pre><code class="language-cpp">//初始化
void STInit(Stack* pst);
//销毁
void STDestory(Stack* pst);</code></pre> 
<p> 1.初始化</p> 
<pre><code class="language-cpp">void STInit(Stack* pst) {
	pst-&gt;a = NULL;
	pst-&gt;capacity = pst-&gt;top = 0;
};</code></pre> 
<p>因为开始的时候，这个栈中并没有任何的元素，所以我们将其的a初始化为NULL,top和capacity为0.</p> 
<p>其实对于top的初始化是有两种情况的：</p> 
<p>如果top指向的是栈顶的元素:</p> 
<p class="img-center"><img alt="" height="158" src="https://images2.imgbox.com/c9/d1/zRjLB8Nh_o.png" width="700"></p> 
<p> 比如这样的TOP就是指向栈顶的元素8,此时存放了3个数据，Top的值等于2.</p> 
<p>可以是我们开始初始化为0，此时的TOP指向下标为0的位置，可是此时的位置上并没有元素，这里的top指向的是栈顶元素的下一个位置，并不是栈顶元素。</p> 
<p>所以如果要使top指向栈顶元素，初始化应该为-1，而不是0.</p> 
<p>本文采用top指向栈顶元素的下一个位置。</p> 
<p>2.销毁</p> 
<p>销毁其实和初始化很类似。</p> 
<p>因为a是我们使用malloc函数动态开辟的空间，所以我们需要free释放掉a。</p> 
<pre><code class="language-cpp">//初始化
void STInit(Stack* pst) {
	assert(pst);
	pst-&gt;a = NULL;
	pst-&gt;capacity = pst-&gt;top = 0;
};
//销毁
void STDestory(Stack* pst) {
	assert(pst);
	free(pst-&gt;a);
	pst-&gt;a = NULL;
	pst-&gt;capacity = pst-&gt;top = 0;
};</code></pre> 
<p>为了防止pst-&gt;a时造成野指针，需要对pst进行断言一下，避免pst是NULL.</p> 
<h3 id="3.%E5%85%A5%E6%A0%88%E5%92%8C%E5%87%BA%E6%A0%88">3.入栈和出栈</h3> 
<p> 1.入栈</p> 
<p>在入栈之前，我们需要对栈判断空间是否足够。因为top指向的是栈顶元素的下一个位置，所以当满了的条件是top等于capacity，而对于top指向的是栈顶元素而言，判满的条件是capacity = top + 1.</p> 
<p>可是对于这个条件来说，当容量为0的时候，这个条件也成立，所以这里需要使用三目操作符，更改容量，以免乘以2后还是0.用tmp接收开辟的空间是为了避免开辟失败，返回NULL,导致a变成了NULL,使数据丢失。realloc函数当第一个 参数的值为NULL的时候，它的功能和malloc函数一模一样。所以我们不需要单独判断a是否为NULL.</p> 
<pre><code class="language-cpp">void STPush(Stack * pst,STDatatype x){
	assert(pst);
	if (pst-&gt;top == pst-&gt;capacity) {
		int newcapacity = pst-&gt;capacity == 0 ? 4 : pst-&gt;capacity * 2;
		STDatatype* tmp = (STDatatype*)realloc(pst-&gt;a,newcapacity * sizeof(STDatatype));
		if (tmp == NULL)
		{
			perror("malloc fail");
			exit(1);
		}
		pst-&gt;a = tmp;
		pst-&gt;capacity = newcapacity;
	}
	pst-&gt;a[pst-&gt;top++] = x;
};</code></pre> 
<p> 注意：最后记得top+1,不要忘了。</p> 
<p>2.出栈</p> 
<p>对于数组而言，出栈的时候，并不需要把这个数据真的移除掉，只需要top--即可，因为这样这个元素实际上就不在这个栈中了，我们再入栈的时候，就会覆盖掉这个元素。</p> 
<pre><code class="language-cpp">void STPop(Stack* pst) {
	assert(pst);
	assert(pst-&gt;top&gt;0);
	pst-&gt;top--;
};</code></pre> 
<p>出栈要注意，栈空了就不能出栈了。否则top就变成负数了。</p> 
<h3 id="4.%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0%EF%BC%8C%E5%88%A4%E7%A9%BA%EF%BC%8C%E6%B1%82%E6%A0%88%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0">4.栈顶元素，判空，求栈的元素个数</h3> 
<pre><code class="language-cpp">//栈顶元素
STDatatype STTop(Stack* pst) {
	assert(pst);
	assert(pst-&gt;top&gt;0);
	return pst-&gt;a[pst-&gt;top - 1];
};
//判空
bool IsEmpty(Stack* pst) {
	assert(pst);
	return pst-&gt;top == 0;
}
//求元素个数
int STSize(Stack* pst) {
	assert(pst);
	return pst-&gt;top;
};</code></pre> 
<p>这三个函数非常简单：栈定元素需要保证这个栈不能为空，也就是top要大于0，否则不对。</p> 
<p>判空，当栈空的时候top就0，所以只需要判断top等不等于0即可。</p> 
<p>求元素个数：因为top指向栈顶元素的下一个位置，又因为数组下标从0开始，所以top就代表元素的个数。</p> 
<h3 id="%E4%BB%A3%E7%A0%81%EF%BC%9A">代码：</h3> 
<h4 id="test.c">test.c</h4> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 
#include"stack.h"
int main()
{
	Stack s;
	STInit(&amp;s);
	STPush(&amp;s,1);
	printf("%d-&gt;", STTop(&amp;s));
	STPush(&amp;s,2);
	printf("%d-&gt;", STTop(&amp;s));
	STPush(&amp;s,3);
	printf("%d-&gt;", STTop(&amp;s));
	STPush(&amp;s,4);
	printf("%d-&gt;", STTop(&amp;s));
	STPush(&amp;s,5);
	printf("%d-&gt;", STTop(&amp;s));
	STPush(&amp;s,6);
	printf("%d-&gt;", STTop(&amp;s));
	printf("\n栈总共有%d个元素\n",STSize(&amp;s));
	//打印整个栈的元素
	while (!IsEmpty(&amp;s)) {
		printf("%d-&gt;",STTop(&amp;s));
		STPop(&amp;s);
	}
	printf("\n栈总共有%d个元素\n", STSize(&amp;s));
	STDestory(&amp;s);
    return 0;
}</code></pre> 
<p>输出结果： </p> 
<p class="img-center"><img alt="" height="195" src="https://images2.imgbox.com/bb/40/EPz0NqY9_o.png" width="396"></p> 
<h4 id="stack.h%3A">stack.h:</h4> 
<pre><code class="language-cpp">#pragma once
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdbool.h&gt;
//#include&lt;&gt;
typedef int STDatatype;
typedef struct{
	STDatatype* a;
	int top;//栈顶
	int capacity;//栈的容量
}Stack;

//初始化
void STInit(Stack* pst);
//销毁
void STDestory(Stack* pst);
//入栈
void STPush(Stack* pst, STDatatype x);
//出栈
void STPop(Stack* pst);
//栈顶元素
STDatatype STTop(Stack* pst);
//判空
bool IsEmpty(Stack* pst);
//求元素个数
int STSize(Stack* pst);</code></pre> 
<h4 id="stack.c%3A">stack.c:</h4> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 
#include"stack.h"
//初始化
void STInit(Stack* pst) {
	assert(pst);
	pst-&gt;a = NULL;
	pst-&gt;capacity = pst-&gt;top = 0;
};
//销毁
void STDestory(Stack* pst) {
	assert(pst);
	free(pst-&gt;a);
	pst-&gt;a = NULL;
	pst-&gt;capacity = pst-&gt;top = 0;
};
//入栈
void STPush(Stack * pst,STDatatype x){
	assert(pst);
	if (pst-&gt;top == pst-&gt;capacity) {
		int newcapacity = pst-&gt;capacity == 0 ? 4 : pst-&gt;capacity * 2;
		STDatatype* tmp = (STDatatype*)realloc(pst-&gt;a,newcapacity * sizeof(STDatatype));
		if (tmp == NULL)
		{
			perror("malloc fail");
			exit(1);
		}
		pst-&gt;a = tmp;
		pst-&gt;capacity = newcapacity;
	}
	pst-&gt;a[pst-&gt;top++] = x;
};
//出栈
void STPop(Stack* pst) {
	assert(pst);
	assert(pst-&gt;top&gt;0);
	pst-&gt;top--;
};
//栈顶元素
STDatatype STTop(Stack* pst) {
	assert(pst);
	assert(pst-&gt;top&gt;0);
	return pst-&gt;a[pst-&gt;top - 1];
};
//判空
bool IsEmpty(Stack* pst) {
	assert(pst);
	return pst-&gt;top == 0;
}
//求元素个数
int STSize(Stack* pst) {
	assert(pst);
	return pst-&gt;top;
};</code></pre> 
<h2 id="%E4%BA%8C.%E9%98%9F%E5%88%97%C2%A0">二.队列 </h2> 
<h3 id="1.%E9%98%9F%E5%88%97%E7%9A%84%E4%BB%8B%E7%BB%8D">1.队列的介绍</h3> 
<p> 队列是一种常见的数据结构，它遵循先进先出（FIFO）的原则，只允许在一端（<span style="color:#fe2c24;">队尾</span>）进行插入数据，在另一端（<span style="color:#fe2c24;">队头</span>）进行删除数据。队列有两个主要操作：入队（enqueue）和出队（dequeue）。入队将元素添加到队列的末尾，出队将队列的第一个元素删除并返回。</p> 
<p class="img-center"><img alt="" height="243" src="https://images2.imgbox.com/e9/ab/moFYMT5y_o.png" width="1000"></p> 
<p class="img-center"><img alt="" height="333" src="https://images2.imgbox.com/51/f5/1UFH1oKu_o.png" width="1000"></p> 
<p> 队列与排队类似，有素质的人，不会插队，会从排到队尾，完成事情后，从队头离开。</p> 
<p>所以我们，是不能访问中间元素的。</p> 
<p>队列通常用于存储需要按照顺序处理的数据。例如，在计算机科学中，可以使用队列来实现广度优先搜索算法（BFS）。</p> 
<p>在实现队列时，可以使用数组或链表来存储队列中的元素。数组实现的队列被称为顺序队列，链表实现的队列被称为链式队列。</p> 
<p><span style="color:#777777;">队列也可以数组和链表的结构实现，使用链表的结构实现更优一些，因为如果使用数组的结构，出队列在数组头上出数据，效率会比较低。 </span></p> 
<p>本文，作者采用链式队列。</p> 
<p>队列的时间复杂度如下：</p> 
<ul><li>入队：O(1)</li><li>出队：O(1)</li><li>查看队首元素：O(1)</li></ul> 
<p>队列的空间复杂度为O(n)，其中n是队列中的元素数量。</p> 
<pre><code class="language-cpp">typedef int QDatatype;
typedef struct QueueNode {
	struct QueueNode* next;
	QDatatype val;
}QNode;
typedef struct Queue {
	QNode* phead;
	QNode* ptail;
	int size;//节点个数
}Queue;</code></pre> 
<p>这里采用两个指针分别指向队头与队尾，为了方便，把两个指针与size存放在一个结构体中，这样传参更加的方便。</p> 
<h3>2.初始化与销毁</h3> 
<p>1.初始化</p> 
<p>最开始时，队列中是没有任何元素的。</p> 
<pre><code class="language-cpp">//初始化
void QueueInit(Queue* pq) {
	assert(pq);
	pq-&gt;phead = pq-&gt;ptail = NULL;
	pq-&gt;size = 0;
};</code></pre> 
<p>注意观察此处的参数，如果不放在一个结构体 中，那么传参的时候，就需要传递三个指针，大大地增加了使用者的操作难度。开始要断言一下，以免pq为NULL。</p> 
<p>2.销毁</p> 
<pre><code class="language-cpp">//销毁
void QueueDestory(Queue* pq) {
	assert(pq);
	QNode* cur = pq-&gt;phead;
	while (cur) {
		QNode* next = cur-&gt;next;
		free(cur);
		cur = next;
	}
	pq-&gt;phead = pq-&gt;ptail = NULL;
	pq-&gt;size = 0;
};</code></pre> 
<p>队列的销毁与单链表的销毁很相似，这里不过多介绍。</p> 
<h3 id="3.%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4%C2%A0">3.插入与删除 </h3> 
<p>1.插入</p> 
<p>插入数据，先malloc动态申请内存来存放这个数据。</p> 
<p>然后考虑当这个队列没有元素的时候，phead和ptail指针均指向NULL,这个新插入的节点，即是头节点又是尾节点，所以需要分开讨论。 </p> 
<pre><code class="language-cpp">//队尾插入数据
void QueuePush(Queue* pq, QDatatype x)
{
	QNode* newnode = (QNode*)malloc(sizeof(QNode));
	if (newnode == NULL)
	{
		perror("malloc fail");
		exit(1);
	}
	newnode-&gt;val = x;
	newnode-&gt;next = NULL;
	if (pq-&gt;phead == NULL) {
		pq-&gt;phead = pq-&gt;ptail = newnode;
		pq-&gt;size++;
	}
	else {
		pq-&gt;ptail-&gt;next = newnode;
		pq-&gt;ptail = newnode;
		pq-&gt;size++;
	}
}</code></pre> 
<p>当队列为空的时候，就直接将phead与ptail指针指向newnode既可。如果队列不为空就尾插。</p> 
<p>2.删除</p> 
<p>删除数据，需要释放第一个节点即可，然后让phead指针指向下一个节点。</p> 
<p>可是这样写有一个问题，如果此时队列只有一个节点，如果只改变phead的话，ptail仍然指向原来的节点，这样的就会造成野指针了，所以仍然分开讨论。</p> 
<pre><code class="language-cpp">//队头删除数据
void QueuePop(Queue* pq)
{
	assert(pq);
	assert(pq-&gt;phead);
	//一个节点
	if (pq-&gt;phead == pq-&gt;ptail) {
		free(pq-&gt;phead);
		pq-&gt;phead = pq-&gt;ptail = NULL;
	}//多个节点
	else {
		QNode* del = pq-&gt;phead;
		pq-&gt;phead = pq-&gt;phead-&gt;next;
		free(del);
		del = NULL;
	}
	--pq-&gt;size;
}</code></pre> 
<p>第二个断言是为了防止队列为空仍然删除数据。</p> 
<h3 id="4.%E6%9F%A5%E7%9C%8B%E9%98%9F%E5%A4%B4%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0">4.查看队头队尾元素</h3> 
<pre><code class="language-cpp">// 取队头和队尾的数据
QDatatype QueueFront(Queue* pq) {
	assert(pq);
	assert(pq-&gt;size);
	return pq-&gt;phead-&gt;val;
};
QDatatype QueueBack(Queue* pq) {
	assert(pq);
	assert(pq-&gt;size);
	return pq-&gt;ptail-&gt;val;
};</code></pre> 
<p> 在查看之前，首先要确定这个队列中有元素，否则不能查看</p> 
<h3 id="%C2%A05.%E5%88%A4%E7%A9%BA%E4%B8%8E%E9%98%9F%E5%88%97%E5%A4%A7%E5%B0%8F"> 5.判空与队列大小</h3> 
<pre><code class="language-cpp">int QueueSize(Queue* pq) {
	assert(pq);
	return pq-&gt;size;
};
bool QueueEmpty(Queue* pq) {
	assert(pq);
	return pq-&gt;size == 0;
};</code></pre> 
<p>判空与队列大小很简单这里就不过多讲解。</p> 
<h3>代码：</h3> 
<p>Queue.h:</p> 
<pre><code class="language-cpp">#pragma once
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdbool.h&gt;
typedef int QDatatype;
typedef struct QueueNode {
	struct QueueNode* next;
	QDatatype val;
}QNode;
typedef struct Queue {
	QNode* phead;
	QNode* ptail;
	int size;
}Queue;
//初始化与销毁
void QueueInit(Queue* pq);
void QueueDestory(Queue* pq);

//队尾插入数据/队头删除数据
void QueuePush(Queue* pq,QDatatype x);
void QueuePop(Queue* pq);

// 取队头和队尾的数据
QDatatype QueueFront(Queue* pq);
QDatatype QueueBack(Queue* pq);
//判空与队列大小
int QueueSize(Queue* pq);
bool QueueEmpty(Queue* pq);</code></pre> 
<p>Queue.c:</p> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 
#include"queue.h"
//初始化
void QueueInit(Queue* pq) {
	assert(pq);
	pq-&gt;phead = pq-&gt;ptail = NULL;
	pq-&gt;size = 0;
};
//销毁
void QueueDestory(Queue* pq) {
	assert(pq);
	QNode* cur = pq-&gt;phead;
	while (cur) {
		QNode* next = cur-&gt;next;
		free(cur);
		cur = next;
	}
	pq-&gt;phead = pq-&gt;ptail = NULL;
	pq-&gt;size = 0;
};
//队尾插入数据
void QueuePush(Queue* pq, QDatatype x)
{
	QNode* newnode = (QNode*)malloc(sizeof(QNode));
	if (newnode == NULL)
	{
		perror("malloc fail");
		exit(1);
	}
	newnode-&gt;val = x;
	newnode-&gt;next = NULL;
	if (pq-&gt;phead == NULL) {
		pq-&gt;phead = pq-&gt;ptail = newnode;
		pq-&gt;size++;
	}
	else {
		pq-&gt;ptail-&gt;next = newnode;
		pq-&gt;ptail = newnode;
		pq-&gt;size++;
	}
}
//队头删除数据
void QueuePop(Queue* pq)
{
	assert(pq);
	assert(pq-&gt;phead);
	//一个节点
	if (pq-&gt;phead == pq-&gt;ptail) {
		free(pq-&gt;phead);
		pq-&gt;phead = pq-&gt;ptail = NULL;
	}//多个节点
	else {
		QNode* del = pq-&gt;phead;
		pq-&gt;phead = pq-&gt;phead-&gt;next;
		free(del);
		del = NULL;

	}
	--pq-&gt;size;
}
// 取队头和队尾的数据
QDatatype QueueFront(Queue* pq) {
	assert(pq);
	assert(pq-&gt;size);
	return pq-&gt;phead-&gt;val;
};
QDatatype QueueBack(Queue* pq) {
	assert(pq);
	assert(pq-&gt;size);
	return pq-&gt;ptail-&gt;val;
};

int QueueSize(Queue* pq) {
	assert(pq);
	return pq-&gt;size;
};
bool QueueEmpty(Queue* pq) {
	assert(pq);
	return pq-&gt;size == 0;
};</code></pre> 
<p></p> 
<div> 
 <span style="color:#777777;">另外扩展了解一下，实际中我们有时还会使用一种队列叫循环队列。如操作系统课程讲解生产者消费者模型时可以就会使用循环队列。环形队列可以使用数组实现,也可以使用循环链表完成。</span> 
</div> 
<p class="img-center"><img alt="" height="326" src="https://images2.imgbox.com/e6/41/eHjYM8vw_o.png" width="500"></p> 
<p><img alt="" height="218" src="https://images2.imgbox.com/04/a4/Wtx9qz30_o.png" width="500"></p> 
<p>循环队列与双端队列，下一篇文章讲解。</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7fb1c3a5fc4171e2be9814c80bf614ba/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">AI绘图开源工具Stable Diffusion WebUI前端API调用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0125519803b7adbbde940323c420982f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AI绘画，用stable diffusion将图片转成线稿，手绘稿快速生成</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>