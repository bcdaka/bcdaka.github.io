<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Qt5.14.2 深入理解Qt多线程编程，掌握线程池架构实现高效并发 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/d6f56b22b7c741f0ffb75d898462279d/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Qt5.14.2 深入理解Qt多线程编程，掌握线程池架构实现高效并发">
  <meta property="og:description" content="在高并发的软件系统中，多线程编程是解决性能瓶颈和提高系统吞吐量的有效手段。作为跨平台的应用程序开发框架，Qt为我们提供了强大的多线程支持。本文将深入探讨Qt多线程编程的实现细节，并介绍线程池的设计思想，帮助读者彻底掌握Qt多线程编程技巧。
一、Qt的两种多线程实现方式剖析 Qt中实现多线程编程主要有两种方式：重写QThread类的run()函数和使用信号与槽。
1、重写QThread的run()函数 这种方式需要继承QThread类并重写虚函数run()，将需要并发执行的代码逻辑放在run()函数中。例如:
class WorkThread : public QThread { public: void run() override { //并发执行的代码 qDebug() &lt;&lt; &#34;Current thread:&#34; &lt;&lt; QThread::currentThreadId(); //执行耗时操作 heavyWorkLoad(); } }; 在主线程中，我们只需创建WorkThread对象并调用start()即可启动新线程:
WorkThread *worker = new WorkThread; worker-&gt;start(); 这种方法的优点是直观简单，缺点是run()函数作为线程执行体只能有一个入口，不太适合处理多个工作单元并发执行的场景。
2、使用信号与槽方式 Qt的信号与槽机制也可以用于实现多线程编程，它的思路是:
（1）、创建QThread对象作为新线程
（2）、创建执行体对象，并使用QObject::moveToThread()将其移动到新线程
（3）、在主线程通过连接信号与槽的方式，间接调用执行体对象的槽函数，从而启动新线程中的任务
具体代码如下:
//ExecutionBody.h class ExecutionBody : public QObject { Q_OBJECT public slots: void execution() { //并发执行的代码 qDebug() &lt;&lt; &#34;Executing in thread&#34; &lt;&lt; QThread::currentThreadId(); heavyWorkLoad(); } }; //main.cpp int main() { QThread *worker = new QThread; ExecutionBody *body = new ExecutionBody; body-&gt;moveToThread(worker); QObject::connect(worker， &amp;QThread::started， body， &amp;ExecutionBody::execution); worker-&gt;start(); return app.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-18T14:51:47+08:00">
    <meta property="article:modified_time" content="2024-03-18T14:51:47+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Qt5.14.2 深入理解Qt多线程编程，掌握线程池架构实现高效并发</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <br> 
<p>在高并发的软件系统中，多线程编程是解决性能瓶颈和提高系统吞吐量的有效手段。作为跨平台的应用程序开发框架，Qt为我们提供了强大的多线程支持。本文将深入探讨Qt多线程编程的实现细节，并介绍线程池的设计思想，帮助读者彻底掌握Qt多线程编程技巧。</p> 
<br> 
<h4><a id="Qt_9"></a>一、Qt的两种多线程实现方式剖析</h4> 
<p>Qt中实现多线程编程主要有两种方式：重写QThread类的run()函数和使用信号与槽。</p> 
<br> 
<h4><a id="1QThreadrun_18"></a>1、重写QThread的run()函数</h4> 
<p>这种方式需要继承QThread类并重写虚函数run()，将需要并发执行的代码逻辑放在run()函数中。例如:</p> 
<pre><code>class WorkThread : public QThread {
public:
    void run() override {
        //并发执行的代码
        qDebug() &lt;&lt; "Current thread:" &lt;&lt; QThread::currentThreadId();
        //执行耗时操作
        heavyWorkLoad();
    }
};
</code></pre> 
<br> 
<p>在主线程中，我们只需创建WorkThread对象并调用start()即可启动新线程:</p> 
<pre><code>WorkThread *worker = new WorkThread;
worker-&gt;start();
</code></pre> 
<br> 
<p>这种方法的优点是直观简单，缺点是run()函数作为线程执行体只能有一个入口，不太适合处理多个工作单元并发执行的场景。</p> 
<br> 
<h4><a id="2_54"></a>2、使用信号与槽方式</h4> 
<p>Qt的信号与槽机制也可以用于实现多线程编程，它的思路是:</p> 
<p>（1）、创建QThread对象作为新线程</p> 
<p>（2）、创建执行体对象，并使用QObject::moveToThread()将其移动到新线程</p> 
<p>（3）、在主线程通过连接信号与槽的方式，间接调用执行体对象的槽函数，从而启动新线程中的任务</p> 
<br> 
<p><img src="https://images2.imgbox.com/a7/23/d5rvgrGQ_o.png" alt="在这里插入图片描述"></p> 
<p>具体代码如下:</p> 
<pre><code>//ExecutionBody.h
class ExecutionBody : public QObject {
    Q_OBJECT
public slots:
    void execution() {
        //并发执行的代码  
        qDebug() &lt;&lt; "Executing in thread" &lt;&lt; QThread::currentThreadId();
        heavyWorkLoad();
    }
};

//main.cpp
int main() {
    QThread *worker = new QThread;
    ExecutionBody *body = new ExecutionBody;
    body-&gt;moveToThread(worker);
    
    QObject::connect(worker， &amp;QThread::started， body， &amp;ExecutionBody::execution);
    worker-&gt;start();
    
    return app.exec();
}
</code></pre> 
<p>相比第一种方法，信号与槽方式支持在新线程中执行多个函数，更加灵活。但也相对复杂一些，开发者需要清晰地理解信号连接、事件循环等概念。</p> 
<br> 
<h4><a id="_107"></a>二、突破瓶颈，构建高效线程池</h4> 
<p>前面介绍了Qt的基本多线程实现方式，不过在实际项目中，如果只是简单地启动固定数量的线程，可能会面临以下问题:</p> 
<p>（1）、线程的创建和销毁代价较高</p> 
<p>（2）、线程数量太多，会加重系统的线程调度开销</p> 
<p>（3）、大量线程空转，造成CPU资源浪费</p> 
<p>为了解决这些问题，我们需要引入线程池的概念，将闲置的线程资源统一管理和调度，避免频繁创建和销毁线程。Qt提供了QThreadPool类实现了这一机制。</p> 
<br> 
<h4><a id="1QThreadPool_126"></a>1、QThreadPool设计原理</h4> 
<br> 
<p>QThreadPool内部管理了一组工作线程(工作者线程)，当有任务投递时，线程池会将任务分配给空闲的工作线程执行，避免频繁创建和销毁线程。此外，QThreadPool还支持设置活跃线程数上限，在线程全部忙碌时也不会盲目创建新的工作线程，从而避免过度占用系统资源。<br> <br></p> 
<p>QThreadPool采用信号与槽的方式将任务分发给工作线程。具体来说，当我们调用QThreadPool::start()投递任务时，QThreadPool会为任务创建一个QRunnable对象，并通过内部信号连接到某个工作线程，由工作线程执行QRunnable的run()函数。<br> <br></p> 
<p><img src="https://images2.imgbox.com/9c/31/rtE9v04Y_o.png" alt="在这里插入图片描述"></p> 
<br> 
<h4><a id="2QThreadPool_141"></a>2、QThreadPool使用示例</h4> 
<p>下面通过一个简单的例子展示如何使用QThreadPool:</p> 
<pre><code>//WorkerTask.h
class WorkerTask : public QRunnable {
public:
    void run() override {
        //执行任务逻辑
        qDebug() &lt;&lt; "Executing task in thread" &lt;&lt; QThread::currentThreadId();
        heavyWorkLoad();
    }
};

//main.cpp 
int main() {
    QThreadPool *pool = QThreadPool::globalInstance();
    
    //设置最大线程数
    pool-&gt;setMaxThreadCount(QThread::idealThreadCount());
    
    //投递任务
    for(int i=0; i&lt;200; ++i) {  
        WorkerTask *task = new WorkerTask;
        pool-&gt;start(task);
    }

    return app.exec();
}
</code></pre> 
<br> 
<p>这个示例首先获取全局QThreadPool实例，并设置最大工作线程数为当前系统的理想线程数(通常为CPU核心数)。然后循环构建WorkerTask对象并调用QThreadPool::start()投递，线程池会自动将任务分发给空闲的线程执行。<br> <br></p> 
<p>需要注意的是，QThreadPool默认采用栈内存管理QRunnable对象，也就是说在QRunnable的run()函数执行完毕后，QThreadPool会自动销毁对象。如果我们需要在run()函数执行完毕后继续访问QRunnable对象的数据成员，应该设置QThreadPool的stackSize属性(即将对象放在堆内存分配)。</p> 
<br> 
<h4><a id="_182"></a>三、多线程开发中的注意事项</h4> 
<p>尽管QThreadPool大大简化了多线程编程流程，但在实际开发中，我们仍需注意一些潜在的安全隐患和性能风险:<br> <br></p> 
<h4><a id="1_189"></a>1、线程间数据访问安全</h4> 
<p>当多个线程并发访问同一份数据时，很容易出现竞态条件。Qt提供了QMutex、QSemaphore、QReadWriteLock等同步原语类，我们可以利用它们来保护线程间共享数据的完整性。<br> <br></p> 
<p>另外，Qt还提供了QAtomicInteger和QAtomicPointer等原子操作类，能够确保基础数据类型的读写操作的原子性。对于简单的计数、状态位的读写，使用原子操作类可以避免加锁开销。</p> 
<br> 
<h4><a id="2_199"></a>2、任务队列控制策略</h4> 
<p>使用QThreadPool虽然能避免频繁创建销毁线程，但如果任务投递过多且执行时间过长，任务队列会持续积压，可能导致响应延迟或内存占用過高。</p> 
<p>因此，我们需要对任务队列的长度作出合理控制。QThreadPool提供了两个相关的API:</p> 
<ul><li>QThreadPool::reserveThread()可以为高优先级任务预留线程资源</li><li>QThreadPool::setMaxThreadCount()可以动态调整线程池的最大线程数</li></ul> 
<p>我们可以在投递任务前检查当前队列长度，对于优先级较高的任务使用reserveThread()保留资源，对于优先级较低的任务可以选择延迟投递或动态增加线程池大小。</p> 
<br> 
<h4><a id="3_213"></a>3、避免死锁</h4> 
<p>在多线程编程中，如果多个线程互相持有对方所需要的锁资源，就会发生死锁。例如下面的代码:</p> 
<pre><code>QMutex mutex1， mutex2;

//线程1
mutex1.lock(); 
...
mutex2.lock(); //阻塞

//线程2  
mutex2.lock();
...
mutex1.lock(); //阻塞
</code></pre> 
<p>避免死锁的一个常用策略是:对所有需要加锁的代码采用统一的加锁顺序，每个线程按相同顺序申请锁。</p> 
<br> 
<h4><a id="4_238"></a>4、减少线程切换开销</h4> 
<p>线程切换是一个非常耗时的操作，会带来较大的性能开销。我们应该尽量减少线程切换的发生，例如:</p> 
<ul><li>将密集计算的代码块集中在一个或几个线程中，避免在多个线程间切换</li><li>避免线程中的循环中阻塞操作(如休眠、加锁等)，这会使该线程长时间占用CPU</li><li>采用无锁编程，利用原子操作和内存屏障指令实现线程安全操作</li></ul> 
<br> 
<p>通过本文的介绍，希望你能够加深对Qt多线程编程的理解，在实际开发中合理使用多线程，提高应用程序的整体性能。下一篇文章将为你带来更多实战案例，进一步展示Qt多线程编程的实践技巧。<br> <br></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f2f8104a560116fa0ce94383db593c84/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SpringBoot3.0 有哪些新特性？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/72f222d04fb8cab8823e263a45dd284e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决mysql：2059 -Authentication plugin ‘caching sha2 password‘ cannot be loaded: ◆X◆◆◆參◆◆◆◆願</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>