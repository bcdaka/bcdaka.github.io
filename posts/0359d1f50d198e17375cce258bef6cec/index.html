<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【高阶数据结构】图 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/0359d1f50d198e17375cce258bef6cec/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【高阶数据结构】图">
  <meta property="og:description" content="图 1. 图的基本概念2. 图的存储结构2.1 邻接矩阵2.2 邻接表2.3 邻接矩阵的实现2.4 邻接表的实现 3. 图的遍历3.1 图的广度优先遍历3.2 图的深度优先遍历 4. 最小生成树4.1 Kruskal算法4.2 Prim算法 5. 最短路径5.1 单源最短路径--Dijkstra算法5.2 单源最短路径--Bellman-Ford算法5.3 多源最短路径--Floyd-Warshall算法 点赞👍👍收藏🌟🌟关注💖💖
你的支持是对我最大的鼓励，我们一起努力吧!😃😃
1. 图的基本概念 图是由顶点集合及顶点间的关系组成的一种数据结构：G = (V， E)，其中：
顶点集合V = {x|x属于某个数据对象集}是有穷非空集合；
E = {(x,y)|x,y属于V}或者E = {&lt;x, y&gt;|x,y属于V &amp;&amp; Path(x, y)}是顶点间关系的有穷集合，也叫做边的集合。
(x, y)表示x到y的一条双向通路，即(x, y)是无方向的；Path(x, y)表示从x到y的一条单向通路，即Path(x, y)是有方向的。
顶点和边：图中结点称为顶点，第i个顶点记作vi。两个顶点vi和vj相关联称作顶点vi和顶点vj之间有一条边，图中的第k条边记作ek，ek = (vi，vj)或&lt;vi，vj&gt;。
有向图和无向图：在有向图中，顶点对&lt;x, y&gt;是有序的，顶点对&lt;x，y&gt;称为顶点x到顶点y的一条边(弧)，&lt;x, y&gt;和&lt;y, x&gt;是两条不同的边，比如下图G3和G4为有向图。在无向图中，顶点对(x, y)是无序的，顶点对(x,y)称为顶点x和顶点y相关联的一条边，这条边没有特定方向，(x, y)和(y，x)是同一条边，比如下图G1和G2为无向图。注意：无向边(x, y)等于有向边&lt;x, y&gt;和&lt;y, x&gt;。
下面是一些常见的图，G2看着是一颗二叉树为什么也说是图呢？
可以这样理解，树是一种特殊(无环连通)的图，图不一定是树。树关注的节点(顶点)中存的值以及连通关系，图关注的是顶点及边的权值。（边由三部分组成：两个顶点、权值）
树是一种存储式数据结构，节点内存值，然后构成二叉搜索树，AVL树，红黑树。
图是一种表示型数据结构，表示某种场景。
比如说下面的图，顶点可能表示城市，边表示城市之间一个关系（高铁距离、高铁价格、高铁时间。。。）
有了这个东西，提出DFS，BFS遍历，最小生成树（最小代价把图连图），最短路径(一个顶点到其他顶点 或者 多个顶点之间 最短路径)的问题。
图还可以用来表示社交关系
顶点：人">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-19T10:15:33+08:00">
    <meta property="article:modified_time" content="2024-08-19T10:15:33+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【高阶数据结构】图</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>图</h4> 
 <ul><li><a href="#1__8" rel="nofollow">1. 图的基本概念</a></li><li><a href="#2__76" rel="nofollow">2. 图的存储结构</a></li><li><ul><li><a href="#21__93" rel="nofollow">2.1 邻接矩阵</a></li><li><a href="#22__122" rel="nofollow">2.2 邻接表</a></li><li><a href="#23__156" rel="nofollow">2.3 邻接矩阵的实现</a></li><li><a href="#24__400" rel="nofollow">2.4 邻接表的实现</a></li></ul> 
  </li><li><a href="#3__502" rel="nofollow">3. 图的遍历</a></li><li><ul><li><a href="#31__506" rel="nofollow">3.1 图的广度优先遍历</a></li><li><a href="#32__596" rel="nofollow">3.2 图的深度优先遍历</a></li></ul> 
  </li><li><a href="#4__632" rel="nofollow">4. 最小生成树</a></li><li><ul><li><a href="#41_Kruskal_658" rel="nofollow">4.1 Kruskal算法</a></li><li><a href="#42_Prim_810" rel="nofollow">4.2 Prim算法</a></li></ul> 
  </li><li><a href="#5__909" rel="nofollow">5. 最短路径</a></li><li><ul><li><a href="#51_Dijkstra_917" rel="nofollow">5.1 单源最短路径--Dijkstra算法</a></li><li><a href="#52_BellmanFord_1030" rel="nofollow">5.2 单源最短路径--Bellman-Ford算法</a></li><li><a href="#53_FloydWarshall_1238" rel="nofollow">5.3 多源最短路径--Floyd-Warshall算法</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<p><img src="https://images2.imgbox.com/0f/6d/5qVhOTFf_o.jpg" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>点赞</strong>👍👍<strong>收藏</strong>🌟🌟<strong>关注</strong>💖💖<br> <font color="red"><strong>你的支持是对我最大的鼓励，我们一起努力吧!😃😃</strong></font></p> 
</blockquote> 
<h2><a id="1__8"></a>1. 图的基本概念</h2> 
<p><strong>图是由顶点集合及顶点间的关系组成的一种数据结构：G = (V， E)</strong>，其中：</p> 
<p><strong>顶点集合V = {x|x属于某个数据对象集}是有穷非空集合</strong>；</p> 
<p><strong>E = {(x,y)|x,y属于V}或者E = {&lt;x, y&gt;|x,y属于V &amp;&amp; Path(x, y)}是顶点间关系的有穷集合，也叫做边的集合。</strong></p> 
<p>(x, y)表示x到y的一条双向通路，即(x, y)是无方向的；Path(x, y)表示从x到y的一条单向通路，即Path(x, y)是有方向的。</p> 
<p>顶点和边：<strong>图中结点称为顶点</strong>，第i个顶点记作vi。<strong>两个顶点vi和vj相关联称作顶点vi和顶点vj之间有一条边</strong>，图中的第k条边记作ek，ek = (vi，vj)或&lt;vi，vj&gt;。</p> 
<p>有向图和无向图：<strong>在有向图中，顶点对&lt;x, y&gt;是有序的，顶点对&lt;x，y&gt;称为顶点x到顶点y的一条边(弧)，&lt;x, y&gt;和&lt;y, x&gt;是两条不同的边</strong>，比如下图G3和G4为有向图。<strong>在无向图中，顶点对(x, y)是无序的，顶点对(x,y)称为顶点x和顶点y相关联的一条边，这条边没有特定方向，(x, y)和(y，x)是同一条边</strong>，比如下图G1和G2为无向图。注意：<strong>无向边(x, y)等于有向边&lt;x, y&gt;和&lt;y, x&gt;</strong>。</p> 
<p>下面是一些常见的图，G2看着是一颗二叉树为什么也说是图呢？<br> 可以这样理解，<strong>树是一种特殊(无环连通)的图，图不一定是树。树关注的节点(顶点)中存的值以及连通关系，图关注的是顶点及边的权值。（边由三部分组成：两个顶点、权值）</strong><br> <img src="https://images2.imgbox.com/81/47/wNyjC6sg_o.png" alt="在这里插入图片描述"></p> 
<p>树是一种存储式数据结构，节点内存值，然后构成二叉搜索树，AVL树，红黑树。<br> 图是一种表示型数据结构，表示某种场景。</p> 
<p>比如说下面的图，顶点可能表示城市，边表示城市之间一个关系（高铁距离、高铁价格、高铁时间。。。）</p> 
<p>有了这个东西，提出DFS，BFS遍历，最小生成树（最小代价把图连图），最短路径(一个顶点到其他顶点 或者 多个顶点之间 最短路径)的问题。</p> 
<p><img src="https://images2.imgbox.com/be/67/TJ7Zmw9Q_o.png" alt="在这里插入图片描述"></p> 
<p>图还可以用来表示社交关系</p> 
<p>顶点：人<br> 边：表示两个人是好友<br> 边权值：亲密度等</p> 
<p>微信，qq等关系-&gt;无向图(强社交关系)<br> 微博，抖音等关系-&gt;有向图(弱社交关系、媒体社交)</p> 
<p><img src="https://images2.imgbox.com/c4/af/MYoJb7T0_o.png" alt="在这里插入图片描述"></p> 
<p>完全图(任意两个顶点都有边)：在<strong>有n个顶点的无向图中</strong>，若<strong>有n * (n-1)/2条边(n个顶点 1-&gt;n-1，2-&gt;n-2 … n-&gt;0 等差数列)</strong>，即<strong>任意两个顶点之间有且仅有一条边</strong>，则称此图为<strong>无向完全图</strong>，比如上图G1；在<strong>n个顶点的有向图</strong>中，若有<strong>n * (n-1)条边</strong>，即<strong>任意两个顶点之间有且仅有方向相反的边</strong>，则称此图为<strong>有向完全图</strong>，比如上图G4。</p> 
<p>邻接顶点：在<strong>无向图中G中，若(u, v)是E(G)中的一条边，则称u和v互为邻接顶点</strong>，并称<strong>边(u,v)依附于顶点u和v；在有向图G中，若&lt;u, v&gt;是E(G)中的一条边，则称顶点u邻接到v，顶点v邻接自顶点u，并称边&lt;u, v&gt;与顶点u和顶点v相关联。</strong></p> 
<p>顶点的度：<strong>顶点v的度是指与它相关联的边的条数，记作deg(v)</strong>。在<strong>有向图</strong>中，<strong>顶点的度等于该顶点的入度与出度之和</strong>，其中<strong>顶点v的入度是以v为终点的有向边的条数</strong>，记作indev(v)；<strong>顶点v的出度是以v为起始点的有向边的条数</strong>，记作outdev(v)。因此：dev(v) = indev(v) + outdev(v)。注意：对于<strong>无向图，顶点的度等于该顶点的入度和出度</strong>，即dev(v) = indev(v) = outdev(v)。</p> 
<p>路径：在图G = (V， E)中，若<strong>从顶点vi出发有一组边使其可到达顶点vj，则称顶点vi到顶点vj的顶点序列为从顶点vi到顶点vj的路径</strong>。</p> 
<p>路径长度：对于<strong>不带权的图，一条路径的路径长度是指该路径上的边的条数</strong>；对于<strong>带权的图，一条路径的路径长度是指该路径上各个边权值的总和</strong>。</p> 
<p><img src="https://images2.imgbox.com/15/02/DRY1atXG_o.png" alt="在这里插入图片描述"></p> 
<p>简单路径与回路：<strong>若路径上各顶点v1，v2，v3，…，vm均不重复，则称这样的路径为简单路径</strong>。<strong>若路径上第一个顶点v1和最后一个顶点vm重合，则称这样的路径为回路或环</strong>。</p> 
<p><img src="https://images2.imgbox.com/ed/db/Nr1LcaM5_o.png" alt="在这里插入图片描述"></p> 
<p>子图：<strong>设图G = {V, E}和图G1 = {V1，E1}，若V1属于V且E1属于E，则称G1是G的子图。</strong></p> 
<p><img src="https://images2.imgbox.com/e3/c6/mQJ4yUHX_o.png" alt="在这里插入图片描述"></p> 
<p>连通图(连通图是针对无向图来说的)：在<strong>无向图</strong>中，若从顶点v1到顶点v2有路径，则称顶点v1与顶点v2是连通的。<strong>如果图中任意一对顶点都是连通的，则称此图为连通图</strong>。</p> 
<p>强连通图(强连通图是针对有向图来说的)：在<strong>有向图</strong>中，若在<strong>每一对顶点vi和vj之间都存在一条从vi到vj的路径，也存在一条从vj到vi的路径，则称此图是强连通图。</strong></p> 
<p>生成树：一个<strong>连通图的最小连通子图</strong>称作该图的<strong>生成树</strong>。<strong>有n个顶点的连通图的生成树有n个顶点和n-1条边。</strong></p> 
<h2><a id="2__76"></a>2. 图的存储结构</h2> 
<p>因为图中既有节点，又有边(节点与节点之间的关系)，因此，在<strong>图的存储中，只需要保存：节点和边关系即可</strong>。节点保存比较简单，只需要一段连续空间即可，那边关系该怎么保存呢？</p> 
<p>顶点我们可以像并查集哪里一样用vector和map保存，那边如何保存呢？</p> 
<pre><code class="prism language-cpp"><span class="token comment">//V 顶点类型,  W 权值类型, Direction  表示有向/无向</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">V</span><span class="token punctuation">,</span><span class="token keyword">class</span> <span class="token class-name">W</span><span class="token punctuation">,</span><span class="token keyword">bool</span> Direction<span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Graph</span>
<span class="token punctuation">{<!-- --></span>

<span class="token keyword">private</span><span class="token operator">:</span>
	vector<span class="token operator">&lt;</span>V<span class="token operator">&gt;</span> _vertexs<span class="token punctuation">;</span><span class="token comment">//顶点集合</span>
	map<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> _IndexMap<span class="token punctuation">;</span><span class="token comment">//顶点与下标映射</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="21__93"></a>2.1 邻接矩阵</h3> 
<p>因为节点与节点之间的关系就是连通与否，即为0或者1，因此<strong>邻接矩阵(二维数组)即是：先用一个数组将顶点保存(<font color="red">将顶点转化成对应的下标</font>，比如说顶点是abcd编号就是0123)，然后采用矩阵来表示节点与节点之间的关系。</strong></p> 
<p><img src="https://images2.imgbox.com/e3/c1/DaSHekXa_o.png" alt="在这里插入图片描述"></p> 
<p>注意：</p> 
<ol><li><strong>无向图的邻接矩阵是对称的，第i行(列)元素之和，就是顶点i的度。有向图的邻接矩阵则不一定是对称的，第i行(列)元素之后就是顶点i 的出(入)度。</strong></li><li>如果边带有权值，并且两个节点之间是连通的，上图中的边的关系就用权值代替，如果两个顶点不通，则使用无穷大代替</li></ol> 
<p><img src="https://images2.imgbox.com/f5/55/EX2NHHDN_o.png" alt="在这里插入图片描述"><br> 3. 用邻接矩阵存储图的有点是能够快速知道两个顶点是否连通，缺陷是如果顶点比较多，边比较少时，矩阵中存储了大量的0成为系数矩阵，比较浪费空间，并且要求两个节点之间的路径不是很好求。</p> 
<p>优点：</p> 
<p><strong>邻接矩阵存储方式非常适合稠密图<br> 邻接矩阵O(1)判断两个顶点的连接关系，并取到权值</strong></p> 
<p>缺点：</p> 
<p><strong>相对而言不适合查找一个顶点连接所有边 — O(N)</strong></p> 
<p>假设有n个顶点，是不是要所有顶点遍历一遍才知道某个顶点到底和那些顶点相连。<br> 时间复杂度是O(N)，N是顶点个数。</p> 
<p>假设有100个顶点，我这个顶点只和三个顶点相连只有三条边，但也要遍历100次，能不能有个方法快速把与之相连的三条边都找到呢？</p> 
<h3><a id="22__122"></a>2.2 邻接表</h3> 
<p>邻接表：使用数组表示顶点的集合，使用链表表示边的关系。</p> 
<p><strong>邻接表和哈希桶类似。使用一个指针数组，把自己和连接的顶点边都挂在下面。</strong></p> 
<ol><li>无向图邻接表存储</li></ol> 
<p><img src="https://images2.imgbox.com/71/aa/dQpEQNAQ_o.png" alt="在这里插入图片描述"></p> 
<p>注意：<strong>无向图中同一条边在邻接表中出现了两次。如果想知道顶点vi的度，只需要知道顶点vi边链表集合中结点的数目即可。</strong></p> 
<p>优点：</p> 
<p><strong>适合存储稀疏图<br> 适合查找一个顶点连接出去的边</strong></p> 
<p>缺点：</p> 
<p><strong>不适合确定两个顶点是否相连及权值</strong></p> 
<ol start="2"><li>有向图邻接表存储</li></ol> 
<p><img src="https://images2.imgbox.com/8c/d9/G48Uc7bn_o.png" alt="在这里插入图片描述"></p> 
<p>注意：有向图中每条边在邻接表中只出现一次，与顶点vi对应的邻接表所含结点的个数，就是该顶点的出度，也称出度表，要得到vi顶点的入度，必须检测其他所有顶点对应的边链表，看有多少边顶点的dst取值是i。</p> 
<p>一般情况下有向图，存储一个出边表即可。</p> 
<p>总结一下：<font color="red"><strong>邻接矩阵和邻接表其实属于相辅相成，各有优缺点的互补结构。具体还是看场景选择用邻接矩阵和邻接表</strong></font></p> 
<h3><a id="23__156"></a>2.3 邻接矩阵的实现</h3> 
<pre><code class="prism language-cpp"><span class="token comment">//类型模板参数: V 顶点类型(int,char...),  W 权值类型(int,double...), Direction  表示有向/无向(默认无向)</span>
<span class="token comment">//非类型模板参数: MAX_W  默认权值</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">V</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">W</span><span class="token punctuation">,</span> W MAX_W <span class="token operator">=</span> INT_MAX<span class="token punctuation">,</span> <span class="token keyword">bool</span> Direction <span class="token operator">=</span> <span class="token boolean">false</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Graph</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	vector<span class="token operator">&lt;</span>V<span class="token operator">&gt;</span> _vertexs<span class="token punctuation">;</span>        <span class="token comment">//顶点集合</span>
	map<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> _IndexMap<span class="token punctuation">;</span>    <span class="token comment">//顶点与下标映射</span>
	vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>W<span class="token operator">&gt;&gt;</span> _matrix<span class="token punctuation">;</span> <span class="token comment">//邻接矩阵(边的集合)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>图的创建有下面几种方式：</p> 
<ol><li>IO输入 ------ （自己写不方便测试，oj中更适合）</li><li>图的结构关系写到文件，读取文件</li><li>手动添加边 （我们采用的方式）</li></ol> 
<pre><code class="prism language-cpp"><span class="token function">Graph</span><span class="token punctuation">(</span><span class="token keyword">const</span> V<span class="token operator">*</span> a<span class="token punctuation">,</span> size_t n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	_vertexs<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		_vertexs<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		_IndexMap<span class="token punctuation">[</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	_matrix<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> MAX_W<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>	
<span class="token punctuation">}</span>
</code></pre> 
<p>添加边</p> 
<p>首先我们要找到边对应两个顶点的下标，然后才在矩阵添加边的信息，注意区分有向图还是无向图。</p> 
<pre><code class="prism language-cpp">size_t <span class="token function">GetVertexindex</span><span class="token punctuation">(</span><span class="token keyword">const</span> V<span class="token operator">&amp;</span> v<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//不能直接用[]去查,万一不在就成插入了</span>
	<span class="token keyword">auto</span> it <span class="token operator">=</span> _IndexMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> _IndexMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> it<span class="token operator">-&gt;</span>second<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">throw</span> <span class="token function">invalid_argument</span><span class="token punctuation">(</span><span class="token string">"不存在的顶点"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">_AddEdge</span><span class="token punctuation">(</span><span class="token keyword">const</span> size_t<span class="token operator">&amp;</span> srci<span class="token punctuation">,</span> <span class="token keyword">const</span> size_t<span class="token operator">&amp;</span> dsti<span class="token punctuation">,</span> <span class="token keyword">const</span> W<span class="token operator">&amp;</span> w<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	_matrix<span class="token punctuation">[</span>srci<span class="token punctuation">]</span><span class="token punctuation">[</span>dsti<span class="token punctuation">]</span> <span class="token operator">=</span> w<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>Direction <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token comment">// 无向图</span>
	<span class="token punctuation">{<!-- --></span>
		_matrix<span class="token punctuation">[</span>dsti<span class="token punctuation">]</span><span class="token punctuation">[</span>srci<span class="token punctuation">]</span> <span class="token operator">=</span> w<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token keyword">const</span> V<span class="token operator">&amp;</span> src<span class="token punctuation">,</span> <span class="token keyword">const</span> V<span class="token operator">&amp;</span> dst<span class="token punctuation">,</span> <span class="token keyword">const</span> W<span class="token operator">&amp;</span> w<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	size_t srci <span class="token operator">=</span> <span class="token function">GetVertexindex</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>
	size_t dsti <span class="token operator">=</span> <span class="token function">GetVertexindex</span><span class="token punctuation">(</span>dst<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">_AddEdge</span><span class="token punctuation">(</span>srci<span class="token punctuation">,</span> dsti<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>打印</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 顶点</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> _vertexs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"["</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">"]"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"-&gt;"</span> <span class="token operator">&lt;&lt;</span> _vertexs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	<span class="token comment">// 矩阵</span>
	<span class="token comment">// 横下标</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"  "</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> _vertexs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//cout &lt;&lt; i &lt;&lt; " ";</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%4d"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> _matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span> <span class="token comment">// 竖下标</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> _matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//cout &lt;&lt; _matrix[i][j] &lt;&lt; " ";</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> MAX_W<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token comment">//cout &lt;&lt; "* ";</span>
				<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%4c"</span><span class="token punctuation">,</span> <span class="token char">'*'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token comment">//cout &lt;&lt; _matrix[i][j] &lt;&lt; " ";</span>
				<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%4d"</span><span class="token punctuation">,</span> _matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>下面我们测试一下</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">TestGraph</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Graph<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> INT_MAX<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token operator">&gt;</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token string">"0123"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	g<span class="token punctuation">.</span><span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token char">'0'</span><span class="token punctuation">,</span> <span class="token char">'1'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	g<span class="token punctuation">.</span><span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token char">'0'</span><span class="token punctuation">,</span> <span class="token char">'3'</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	g<span class="token punctuation">.</span><span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token char">'1'</span><span class="token punctuation">,</span> <span class="token char">'3'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	g<span class="token punctuation">.</span><span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token char">'1'</span><span class="token punctuation">,</span> <span class="token char">'2'</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	g<span class="token punctuation">.</span><span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token char">'2'</span><span class="token punctuation">,</span> <span class="token char">'3'</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	g<span class="token punctuation">.</span><span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token char">'2'</span><span class="token punctuation">,</span> <span class="token char">'1'</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	g<span class="token punctuation">.</span><span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token char">'2'</span><span class="token punctuation">,</span> <span class="token char">'0'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	g<span class="token punctuation">.</span><span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token char">'3'</span><span class="token punctuation">,</span> <span class="token char">'2'</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	g<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/83/50/SdD138uO_o.png" alt="在这里插入图片描述"><br> 完整代码</p> 
<pre><code class="prism language-cpp"><span class="token comment">//类型模板参数: V 顶点类型(int,char...),  W 权值类型(int,double...), Direction  表示有向/无向(默认无向)</span>
<span class="token comment">//非类型模板参数: MAX_W  默认权值</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">V</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">W</span><span class="token punctuation">,</span> W MAX_W <span class="token operator">=</span> INT_MAX<span class="token punctuation">,</span> <span class="token keyword">bool</span> Direction <span class="token operator">=</span> <span class="token boolean">false</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Graph</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">Graph</span><span class="token punctuation">(</span><span class="token keyword">const</span> V<span class="token operator">*</span> a<span class="token punctuation">,</span> size_t n<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		_vertexs<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			_vertexs<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			_IndexMap<span class="token punctuation">[</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		_matrix<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> MAX_W<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>	
	<span class="token punctuation">}</span>

	size_t <span class="token function">GetVertexindex</span><span class="token punctuation">(</span><span class="token keyword">const</span> V<span class="token operator">&amp;</span> v<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//不能直接用[]去查,万一不在就成插入了</span>
		<span class="token keyword">auto</span> it <span class="token operator">=</span> _IndexMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> _IndexMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> it<span class="token operator">-&gt;</span>second<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">throw</span> <span class="token function">invalid_argument</span><span class="token punctuation">(</span><span class="token string">"不存在的顶点"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">void</span> <span class="token function">_AddEdge</span><span class="token punctuation">(</span><span class="token keyword">const</span> size_t<span class="token operator">&amp;</span> srci<span class="token punctuation">,</span> <span class="token keyword">const</span> size_t<span class="token operator">&amp;</span> dsti<span class="token punctuation">,</span> <span class="token keyword">const</span> W<span class="token operator">&amp;</span> w<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		_matrix<span class="token punctuation">[</span>srci<span class="token punctuation">]</span><span class="token punctuation">[</span>dsti<span class="token punctuation">]</span> <span class="token operator">=</span> w<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>Direction <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token comment">// 无向图</span>
		<span class="token punctuation">{<!-- --></span>
			_matrix<span class="token punctuation">[</span>dsti<span class="token punctuation">]</span><span class="token punctuation">[</span>srci<span class="token punctuation">]</span> <span class="token operator">=</span> w<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">void</span> <span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token keyword">const</span> V<span class="token operator">&amp;</span> src<span class="token punctuation">,</span> <span class="token keyword">const</span> V<span class="token operator">&amp;</span> dst<span class="token punctuation">,</span> <span class="token keyword">const</span> W<span class="token operator">&amp;</span> w<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		size_t srci <span class="token operator">=</span> <span class="token function">GetVertexindex</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>
		size_t dsti <span class="token operator">=</span> <span class="token function">GetVertexindex</span><span class="token punctuation">(</span>dst<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">_AddEdge</span><span class="token punctuation">(</span>srci<span class="token punctuation">,</span> dsti<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 顶点</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> _vertexs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			cout <span class="token operator">&lt;&lt;</span> <span class="token string">"["</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">"]"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"-&gt;"</span> <span class="token operator">&lt;&lt;</span> _vertexs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

		<span class="token comment">// 矩阵</span>
		<span class="token comment">// 横下标</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"  "</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> _vertexs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//cout &lt;&lt; i &lt;&lt; " ";</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%4d"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

		<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> _matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span> <span class="token comment">// 竖下标</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> _matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token comment">//cout &lt;&lt; _matrix[i][j] &lt;&lt; " ";</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> MAX_W<span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token comment">//cout &lt;&lt; "* ";</span>
					<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%4c"</span><span class="token punctuation">,</span> <span class="token char">'*'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">else</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token comment">//cout &lt;&lt; _matrix[i][j] &lt;&lt; " ";</span>
					<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%4d"</span><span class="token punctuation">,</span> _matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	vector<span class="token operator">&lt;</span>V<span class="token operator">&gt;</span> _vertexs<span class="token punctuation">;</span>        <span class="token comment">//顶点集合</span>
	map<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> _IndexMap<span class="token punctuation">;</span>    <span class="token comment">//顶点与下标映射</span>
	vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>W<span class="token operator">&gt;&gt;</span> _matrix<span class="token punctuation">;</span> <span class="token comment">//邻接矩阵(边的集合)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="24__400"></a>2.4 邻接表的实现</h3> 
<p>邻接表实际也是一个哈希桶，这里实现很简单</p> 
<pre><code class="prism language-cpp"><span class="token comment">//存储边的信息</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">W</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">Edge</span>
<span class="token punctuation">{<!-- --></span>
	size_t _srci<span class="token punctuation">;</span><span class="token comment">//起始点</span>
	size_t _dsti<span class="token punctuation">;</span><span class="token comment">//目标点的下标</span>
	W _w<span class="token punctuation">;</span><span class="token comment">//权值</span>
	Edge<span class="token operator">&lt;</span>W<span class="token operator">&gt;</span><span class="token operator">*</span> _next<span class="token punctuation">;</span>

	<span class="token function">Edge</span><span class="token punctuation">(</span><span class="token keyword">const</span> size_t<span class="token operator">&amp;</span> srci<span class="token punctuation">,</span><span class="token keyword">const</span> size_t<span class="token operator">&amp;</span> dsti<span class="token punctuation">,</span><span class="token keyword">const</span> W<span class="token operator">&amp;</span> w<span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_srci</span><span class="token punctuation">(</span>srci<span class="token punctuation">)</span>
		<span class="token punctuation">,</span><span class="token function">_dsti</span><span class="token punctuation">(</span>dsti<span class="token punctuation">)</span>
		<span class="token punctuation">,</span><span class="token function">_w</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span>
		<span class="token punctuation">,</span><span class="token function">_next</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">V</span><span class="token punctuation">,</span><span class="token keyword">class</span> <span class="token class-name">W</span><span class="token punctuation">,</span><span class="token keyword">bool</span> Direction <span class="token operator">=</span> <span class="token boolean">false</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Graph</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">typedef</span> Edge<span class="token operator">&lt;</span>W<span class="token operator">&gt;</span> Edge<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">Graph</span><span class="token punctuation">(</span><span class="token keyword">const</span> V<span class="token operator">*</span> a<span class="token punctuation">,</span> size_t n<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		_vertexs<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			_vertexs<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			_IndexMap<span class="token punctuation">[</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		_tables<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	size_t <span class="token function">GetVertexindex</span><span class="token punctuation">(</span><span class="token keyword">const</span> V<span class="token operator">&amp;</span> v<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">auto</span> it <span class="token operator">=</span> _IndexMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> _IndexMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> it<span class="token operator">-&gt;</span>second<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">throw</span> <span class="token function">invalid_argument</span><span class="token punctuation">(</span><span class="token string">"不存在的顶点"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">void</span> <span class="token function">_AddEdge</span><span class="token punctuation">(</span><span class="token keyword">const</span> size_t<span class="token operator">&amp;</span> srci<span class="token punctuation">,</span> <span class="token keyword">const</span> size_t<span class="token operator">&amp;</span> dsti<span class="token punctuation">,</span><span class="token keyword">const</span> W<span class="token operator">&amp;</span> w<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//头插</span>
		Edge<span class="token operator">*</span> edge <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Edge</span><span class="token punctuation">(</span>srci<span class="token punctuation">,</span> dsti<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>
		edge<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> _tables<span class="token punctuation">[</span>srci<span class="token punctuation">]</span><span class="token punctuation">;</span>
		_tables<span class="token punctuation">[</span>srci<span class="token punctuation">]</span> <span class="token operator">=</span> edge<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>Direction <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span>  <span class="token comment">// 无向图</span>
		<span class="token punctuation">{<!-- --></span>
			Edge<span class="token operator">*</span> new_edge <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Edge</span><span class="token punctuation">(</span>dsti<span class="token punctuation">,</span> srci<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>
			new_edge<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> _tables<span class="token punctuation">[</span>dsti<span class="token punctuation">]</span><span class="token punctuation">;</span>
			_tables<span class="token punctuation">[</span>dsti<span class="token punctuation">]</span> <span class="token operator">=</span> new_edge<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">void</span> <span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token keyword">const</span> V<span class="token operator">&amp;</span> src<span class="token punctuation">,</span> <span class="token keyword">const</span> V<span class="token operator">&amp;</span> dst<span class="token punctuation">,</span> <span class="token keyword">const</span> W<span class="token operator">&amp;</span> w<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		size_t srci <span class="token operator">=</span> <span class="token function">GetVertexindex</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>
		size_t dsti <span class="token operator">=</span> <span class="token function">GetVertexindex</span><span class="token punctuation">(</span>dst<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">_AddEdge</span><span class="token punctuation">(</span>srci<span class="token punctuation">,</span> dsti<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 顶点</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> _vertexs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			cout <span class="token operator">&lt;&lt;</span> <span class="token string">"["</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">"]"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"-&gt;"</span> <span class="token operator">&lt;&lt;</span> _vertexs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

		<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> _tables<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			cout <span class="token operator">&lt;&lt;</span> _vertexs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"["</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">"]-&gt;"</span><span class="token punctuation">;</span>
			Edge<span class="token operator">*</span> cur <span class="token operator">=</span> _tables<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				cout <span class="token operator">&lt;&lt;</span> <span class="token string">"["</span> <span class="token operator">&lt;&lt;</span> _vertexs<span class="token punctuation">[</span>cur<span class="token operator">-&gt;</span>_dsti<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">":"</span> <span class="token operator">&lt;&lt;</span> cur<span class="token operator">-&gt;</span>_dsti <span class="token operator">&lt;&lt;</span> <span class="token string">":"</span> <span class="token operator">&lt;&lt;</span> cur<span class="token operator">-&gt;</span>_w <span class="token operator">&lt;&lt;</span> <span class="token string">"]-&gt;"</span><span class="token punctuation">;</span>
				cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			cout <span class="token operator">&lt;&lt;</span> <span class="token string">"nullptr"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	vector<span class="token operator">&lt;</span>V<span class="token operator">&gt;</span> _vertexs<span class="token punctuation">;</span>     <span class="token comment">//顶点集合</span>
	map<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> _IndexMap<span class="token punctuation">;</span>  <span class="token comment">//顶点与下标映射</span>
	vector<span class="token operator">&lt;</span>Edge<span class="token operator">*</span><span class="token operator">&gt;</span> _tables<span class="token punctuation">;</span> <span class="token comment">//邻接表(哈希桶)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>接下来图的遍历，最小生成树，最短路径我们都以邻接矩阵构的图去实现。</p> 
<h2><a id="3__502"></a>3. 图的遍历</h2> 
<p><strong>给定一个图G和其中任意一个顶点v0，从v0出发，沿着图中各边访问图中的所有顶点，且每个顶点仅被遍历一次。"遍历"即对顶点进行某种操作的意思。</strong></p> 
<h3><a id="31__506"></a>3.1 图的广度优先遍历</h3> 
<p>有树的基础就知道广度优先遍历必然要借助队列来实现。广度优先遍历就是以某个点为起点，当这个顶点出队列就把和这个顶点的邻接顶点都入队列，然后一层一层往外走。但是要注意的是已经入过队列的顶点下一次不能在入队列，否则就会死循环，因此还要来一个标记bool类型数组。当一个顶点入队列后就标记一下。</p> 
<p><img src="https://images2.imgbox.com/c5/a1/F9oxszo1_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">BFS</span><span class="token punctuation">(</span><span class="token keyword">const</span> V<span class="token operator">&amp;</span> src<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	size_t srci <span class="token operator">=</span> <span class="token function">GetVertexindex</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>
	size_t n <span class="token operator">=</span> _vertexs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//队列和标记数组</span>
	queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> q<span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;</span> <span class="token function">vis</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>srci<span class="token punctuation">)</span><span class="token punctuation">;</span>
	vis<span class="token punctuation">[</span>srci<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		size_t front <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		cout <span class="token operator">&lt;&lt;</span> front <span class="token operator">&lt;&lt;</span> <span class="token string">":"</span> <span class="token operator">&lt;&lt;</span> _vertexs<span class="token punctuation">[</span>front<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token comment">//把和front顶点的临界顶点入队列</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>_matrix<span class="token punctuation">[</span>front<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> MAX_W <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>vis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
				vis<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">TestBDFS</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	string a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token string">"张三"</span><span class="token punctuation">,</span> <span class="token string">"李四"</span><span class="token punctuation">,</span> <span class="token string">"王五"</span><span class="token punctuation">,</span> <span class="token string">"赵六"</span><span class="token punctuation">,</span> <span class="token string">"周七"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	Graph<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">g1</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	g1<span class="token punctuation">.</span><span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">,</span> <span class="token string">"李四"</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	g1<span class="token punctuation">.</span><span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">,</span> <span class="token string">"王五"</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	g1<span class="token punctuation">.</span><span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token string">"王五"</span><span class="token punctuation">,</span> <span class="token string">"赵六"</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	g1<span class="token punctuation">.</span><span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token string">"王五"</span><span class="token punctuation">,</span> <span class="token string">"周七"</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	g1<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	g1<span class="token punctuation">.</span><span class="token function">BFS</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//g1.DFS("张三");</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/60/a7/uA0riQyn_o.png" alt="在这里插入图片描述"></p> 
<p>接下来看一道题图的BFS应用题</p> 
<p><img src="https://images2.imgbox.com/0e/f5/2b4Xajwz_o.png" alt="在这里插入图片描述"></p> 
<p>举一个例子，告诉我们一度好友、二度好友。。。是什么样的，让我们找到小点的六度好友。这就是一个典型的图BFS应用。回想一下刚才我们的BFS顶点出队列是怎么出的？是一个一个出的。对于这道题我们出队列的就要求一层一层出。那怎么一层一层出呢？很简单出队列之前计算一下当前队列内元素的个数。每次出队列内元素个数次。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">BFS</span><span class="token punctuation">(</span><span class="token keyword">const</span> V<span class="token operator">&amp;</span> src<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	size_t srci <span class="token operator">=</span> <span class="token function">GetVertexindex</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>
	size_t n <span class="token operator">=</span> _vertexs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> q<span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;</span> <span class="token function">vis</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>srci<span class="token punctuation">)</span><span class="token punctuation">;</span>
	vis<span class="token punctuation">[</span>srci<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//出队列之前计算队列内元素个数，一层一层出</span>
		size_t k <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>k<span class="token operator">--</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			size_t front <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			cout <span class="token operator">&lt;&lt;</span> front <span class="token operator">&lt;&lt;</span> <span class="token string">":"</span> <span class="token operator">&lt;&lt;</span> _vertexs<span class="token punctuation">[</span>front<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>_matrix<span class="token punctuation">[</span>front<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> MAX_W <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>vis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
					vis<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="32__596"></a>3.2 图的深度优先遍历</h3> 
<p>图的深度优先遍历和树的前序遍历一样。先往深走，当走到不能走的就回溯换条路走，最终直到所有顶点遍历完然后返回。因此我们用递归来实现，这里我们还是需要一个标记bool类型数组，已经访问过的不能在访问否则就会死递归。</p> 
<p><img src="https://images2.imgbox.com/6f/41/DhdS2pLv_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">_DFS</span><span class="token punctuation">(</span>size_t srci<span class="token punctuation">,</span> <span class="token keyword">const</span> size_t<span class="token operator">&amp;</span> n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> vis<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> srci <span class="token operator">&lt;&lt;</span> <span class="token string">":"</span> <span class="token operator">&lt;&lt;</span> _vertexs<span class="token punctuation">[</span>srci<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	vis<span class="token punctuation">[</span>srci<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token comment">//找一个srci相邻的且没有被访问过的顶点,去往深度遍历</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>_matrix<span class="token punctuation">[</span>srci<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> MAX_W <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>vis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">_DFS</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> n<span class="token punctuation">,</span> vis<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span><span class="token keyword">const</span> V<span class="token operator">&amp;</span> src<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	size_t srci <span class="token operator">=</span> <span class="token function">GetVertexindex</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>
	size_t n <span class="token operator">=</span> _vertexs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;</span> <span class="token function">vis</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">_DFS</span><span class="token punctuation">(</span>srci<span class="token punctuation">,</span> n<span class="token punctuation">,</span> vis<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>其实这里还有一个遗漏的问题，如果无向图是一个连通图或者有向图是一个强连通图，一次BFS和DFS就可以把所有顶点遍历一遍。但是<strong>如果图不是连通的。那以某个点为起点就没有办法一次BFS或者DSF把所有顶点遍历一遍，那如何把图中所有顶点都访问到呢？</strong></p> 
<p><img src="https://images2.imgbox.com/01/84/O5lwA87f_o.png" alt="在这里插入图片描述"></p> 
<p><strong>其实很简单，不是有标记数组吗。把标记数组在遍历一遍，如果还有顶点没有被遍历到那就以这个顶点在做一次BFS或DFS。</strong></p> 
<h2><a id="4__632"></a>4. 最小生成树</h2> 
<p>首先生成树对应的一定是连通图。连通图中找生成树。</p> 
<p>连通图(连通图是针对无向图来说的)：在<strong>无向图</strong>中，若从顶点v1到顶点v2有路径，则称顶点v1与顶点v2是连通的。<strong>如果图中任意一对顶点都是连通的，则称此图为连通图</strong>。</p> 
<p>生成树：一个<strong>连通图的最小连通子图</strong>称作该图的生成树。有<strong>n个顶点的连通图的生成树有n个顶点和n-1条边</strong>。(最少的边连通起来)</p> 
<p><font color="red"><strong>最小生成树：构成生成树的边的权值加起来是最小的。（最小的成本让n个顶点连通）</strong></font></p> 
<p>连通图中的每一棵生成树，都是原图的一个极大无环子图，即：<strong>从其中删去任何一条边，生成树就不在连通；反之，在其中引入任何一条新边，都会形成一条回路</strong>。</p> 
<p>若<strong>连通图由n个顶点组成，则其生成树必含n个顶点和n-1条边</strong>。因此构造最小生成树的准则有三条：</p> 
<ol><li><strong>只能使用图中的权值最小的边来构造最小生成树</strong></li><li><strong>只能使用恰好n-1条边来连接图中的n个顶点</strong></li><li><strong>选用的n-1条边不能构成回路</strong></li></ol> 
<p>构造最小生成树的方法：<strong>Kruskal算法</strong>和<strong>Prim算法</strong>。这两个算法都采用了<strong>逐步求解的贪心策略。</strong></p> 
<p>贪心算法：是指在问题求解时，总是做出当前看起来最好的选择。也就是说贪心算法做出的不是整体</p> 
<p>最优的的选择，而是某种意义上的局部最优解。贪心算法不是对所有的问题都能得到整体最优解。</p> 
<p><font color="red"><strong>最小生成树不唯一，但是权值是唯一的。</strong></font></p> 
<h3><a id="41_Kruskal_658"></a>4.1 Kruskal算法</h3> 
<p>任<strong>给一个有n个顶点的连通网络N={V,E}</strong>，</p> 
<p><strong>首先构造一个由这n个顶点组成、不含任何边的图G={V,NULL}</strong>，其中每个顶点自成一个连通分量，</p> 
<p><strong>其次不断从E中取出权值最小的一条边(若有多条任取其一)，若该边的两个顶点来自不同的连通分量，则将此边加入到G中</strong>。如此重复，直到所有顶点在同一个连通分量上为止。</p> 
<p><strong>核心：每次迭代时，选出一条具有最小权值，且两端点不在同一连通分量上的边，加入生成树。</strong></p> 
<p>其实上面说了这么多，<font color="red"><strong>Kruskal算法核心思想：就是每次都从边中选权值最小的边(全局选最小)。</strong></font></p> 
<p><strong>那怎么去选最小的边呢</strong>？可以把所有的边拿出来排序。但是这不是好方法。更好的方法就是用<font color="red"><strong>优先级队列</strong>。<strong>建一个小堆。每次拿堆顶元素，然后pop堆顶元素，再拿次小的边。</strong></font></p> 
<p>但是这里还有一个问题，可能<strong>选的边会造成回路</strong>！</p> 
<p>比如选择 i - g 权值为6的这条边，构成了回路！</p> 
<p><strong>如何判断选择的边构成了回路呢？</strong></p> 
<p><img src="https://images2.imgbox.com/02/14/cjjsu8dz_o.png" alt="在这里插入图片描述"><br> 使用<font color="red"><strong>并查集 -&gt; 判环</strong></font></p> 
<p>刚开始每一个顶点都是一个独立的集合，选边的时候判断一下构成这个边的两个顶点是否是一个集合，如果不是一个集合就可以选这个边。然后把对应的两个顶点合并成一个集合。</p> 
<p><img src="https://images2.imgbox.com/3f/92/Js7ocBed_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Edge</span>
<span class="token punctuation">{<!-- --></span>
	size_t _srci<span class="token punctuation">;</span>
	size_t _dsti<span class="token punctuation">;</span>
	W _w<span class="token punctuation">;</span>

	<span class="token function">Edge</span><span class="token punctuation">(</span>size_t<span class="token operator">&amp;</span> srci<span class="token punctuation">,</span> size_t<span class="token operator">&amp;</span> dsti<span class="token punctuation">,</span> W<span class="token operator">&amp;</span> w<span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_srci</span><span class="token punctuation">(</span>srci<span class="token punctuation">)</span>
		<span class="token punctuation">,</span><span class="token function">_dsti</span><span class="token punctuation">(</span>dsti<span class="token punctuation">)</span>
		<span class="token punctuation">,</span><span class="token function">_w</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

	<span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> Edge<span class="token operator">&amp;</span> e<span class="token punctuation">)</span> <span class="token keyword">const</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> _w <span class="token operator">&gt;</span> e<span class="token punctuation">.</span>_w<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//把最小生成树权值和返回去</span>
W <span class="token function">Kruskal</span><span class="token punctuation">(</span>Self<span class="token operator">&amp;</span> minTree<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	size_t n <span class="token operator">=</span> _vertexs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//最小生成树是连通图的一个子图,信息是一样的，先初始化</span>
	minTree<span class="token punctuation">.</span>_vertexs <span class="token operator">=</span> _vertexs<span class="token punctuation">;</span>
	minTree<span class="token punctuation">.</span>_IndexMap <span class="token operator">=</span> _IndexMap<span class="token punctuation">;</span>
	minTree<span class="token punctuation">.</span>_matrix<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		minTree<span class="token punctuation">.</span>_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> MAX_W<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>


	<span class="token comment">//建小堆,因为Edge是自定义类型,库中的greater不支持自定义类型比较,所以写一个对应的仿函数</span>
	priority_queue<span class="token operator">&lt;</span>Edge<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>Edge<span class="token operator">&gt;</span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span>Edge<span class="token operator">&gt;&gt;</span> heap<span class="token punctuation">;</span>
	<span class="token comment">//并查集</span>
	UnionFindSet <span class="token function">ufs</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//将所有边入堆</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//无向图的邻接矩阵是一个对称矩阵</span>
			<span class="token comment">//因此只用存矩阵上半部分或者下半部分就行了</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> _matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> MAX_W<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				heap<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">Edge</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> _matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//选出n-1条边</span>
	size_t sz <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	W total <span class="token operator">=</span> <span class="token function">W</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>heap<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		Edge minedge <span class="token operator">=</span> heap<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		heap<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//构成边的两个顶点不在一个集合,说明不构成环,可以选</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ufs<span class="token punctuation">.</span><span class="token function">IsSet</span><span class="token punctuation">(</span>minedge<span class="token punctuation">.</span>_srci<span class="token punctuation">,</span> minedge<span class="token punctuation">.</span>_dsti<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//可以打印一下看选了那条边</span>
			cout <span class="token operator">&lt;&lt;</span> _vertexs<span class="token punctuation">[</span>minedge<span class="token punctuation">.</span>_srci<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"-&gt;"</span> <span class="token operator">&lt;&lt;</span> _vertexs<span class="token punctuation">[</span>minedge<span class="token punctuation">.</span>_dsti<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">":"</span> <span class="token operator">&lt;&lt;</span> minedge<span class="token punctuation">.</span>_w <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
			minTree<span class="token punctuation">.</span><span class="token function">_AddEdge</span><span class="token punctuation">(</span>minedge<span class="token punctuation">.</span>_srci<span class="token punctuation">,</span> minedge<span class="token punctuation">.</span>_dsti<span class="token punctuation">,</span> minedge<span class="token punctuation">.</span>_w<span class="token punctuation">)</span><span class="token punctuation">;</span>
			ufs<span class="token punctuation">.</span><span class="token function">Union</span><span class="token punctuation">(</span>minedge<span class="token punctuation">.</span>_srci<span class="token punctuation">,</span> minedge<span class="token punctuation">.</span>_dsti<span class="token punctuation">)</span><span class="token punctuation">;</span>
			sz<span class="token operator">++</span><span class="token punctuation">;</span>
			total <span class="token operator">+=</span> minedge<span class="token punctuation">.</span>_w<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>
			cout <span class="token operator">&lt;&lt;</span> <span class="token string">"构成环："</span><span class="token punctuation">;</span>
			cout <span class="token operator">&lt;&lt;</span> _vertexs<span class="token punctuation">[</span>minedge<span class="token punctuation">.</span>_srci<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"-&gt;"</span> <span class="token operator">&lt;&lt;</span> _vertexs<span class="token punctuation">[</span>minedge<span class="token punctuation">.</span>_dsti<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">":"</span> <span class="token operator">&lt;&lt;</span> minedge<span class="token punctuation">.</span>_w <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>sz <span class="token operator">==</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> total<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>



<span class="token keyword">void</span> <span class="token function">TestGraphMinTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> str <span class="token operator">=</span> <span class="token string">"abcdefghi"</span><span class="token punctuation">;</span>
	Graph<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">g</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	g<span class="token punctuation">.</span><span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token char">'a'</span><span class="token punctuation">,</span> <span class="token char">'b'</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	g<span class="token punctuation">.</span><span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token char">'a'</span><span class="token punctuation">,</span> <span class="token char">'h'</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//g.AddEdge('a', 'h', 9);</span>
	g<span class="token punctuation">.</span><span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token char">'b'</span><span class="token punctuation">,</span> <span class="token char">'c'</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	g<span class="token punctuation">.</span><span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token char">'b'</span><span class="token punctuation">,</span> <span class="token char">'h'</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	g<span class="token punctuation">.</span><span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token char">'c'</span><span class="token punctuation">,</span> <span class="token char">'i'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	g<span class="token punctuation">.</span><span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token char">'c'</span><span class="token punctuation">,</span> <span class="token char">'f'</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	g<span class="token punctuation">.</span><span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token char">'c'</span><span class="token punctuation">,</span> <span class="token char">'d'</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	g<span class="token punctuation">.</span><span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token char">'d'</span><span class="token punctuation">,</span> <span class="token char">'f'</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	g<span class="token punctuation">.</span><span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token char">'d'</span><span class="token punctuation">,</span> <span class="token char">'e'</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	g<span class="token punctuation">.</span><span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token char">'e'</span><span class="token punctuation">,</span> <span class="token char">'f'</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	g<span class="token punctuation">.</span><span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token char">'f'</span><span class="token punctuation">,</span> <span class="token char">'g'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	g<span class="token punctuation">.</span><span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token char">'g'</span><span class="token punctuation">,</span> <span class="token char">'h'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	g<span class="token punctuation">.</span><span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token char">'g'</span><span class="token punctuation">,</span> <span class="token char">'i'</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	g<span class="token punctuation">.</span><span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token char">'h'</span><span class="token punctuation">,</span> <span class="token char">'i'</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	Graph<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> kminTree<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Kruskal:"</span> <span class="token operator">&lt;&lt;</span> g<span class="token punctuation">.</span><span class="token function">Kruskal</span><span class="token punctuation">(</span>kminTree<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	kminTree<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


	<span class="token comment">//Graph&lt;char, int&gt; pminTree;</span>
	<span class="token comment">//cout &lt;&lt; "Prim:" &lt;&lt; g.Prim(pminTree, 'a') &lt;&lt; endl;</span>
	<span class="token comment">//pminTree.Print();</span>
	<span class="token comment">//cout &lt;&lt; endl;</span>

	<span class="token comment">//for (size_t i = 0; i &lt; strlen(str); ++i)</span>
	<span class="token comment">//{<!-- --></span>
	<span class="token comment">//	cout &lt;&lt; "Prim:" &lt;&lt; g.Prim(pminTree, str[i]) &lt;&lt; endl;</span>
	<span class="token comment">//}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="42_Prim_810"></a>4.2 Prim算法</h3> 
<p>Prim算法也是用的贪心，但是它跟Kruskal算法不一样，Kruskal的核心思想是每次都在全局选最小，Prim是给一个起点，然后从这个起点开始去找最小边（局部选最小）。它选边是先把所有顶点归成两个集合，一个集合是已经被选择的顶点（已经加入到最小生成树的顶点），剩下顶点是一个集合。<strong>它是在两个集合之间去选最小边。每次都从两个集合各选一个顶点构成的最小边。</strong></p> 
<p><img src="https://images2.imgbox.com/4b/97/I19pwgfc_o.png" alt="在这里插入图片描述"></p> 
<p>为什么会这样选边的呢？也就说这个地方贪心不是一个全局的贪心，是一个局部的贪心。以某个点为起点去找周围最小的边。而之前是全局贪心。那<strong>局部贪心的优势是什么？</strong></p> 
<p><font color="red"><strong>它的优势就是选边不会构成环。</strong></font></p> 
<p><font color="red"><strong>它是在两个集合之间去选最小边。每次都从两个集合各选一个顶点构成的最小边。天然避环。</strong></font></p> 
<p><strong>那怎么去区分已经加入到最小生成树的顶点集合和剩余顶点的集合呢？</strong><br> 我们可以搞两个vector，一个X集合，一个Y集合。<br> X表示已经加入最小生成树顶点的结合<br> Y表示剩余顶点的集合</p> 
<p>刚开始所以顶点都没加入到最小生成树也就是都在Y集合，因此Y集合的所有顶点都标记成true，如果某个顶点加入到最小生成树就把对应顶点从Y中变成false，而在X中变为true。</p> 
<p><strong>那如何从X-&gt;Y集合连接的边里面选出最小的边？</strong><br> 搞一个优先级队列（小堆）把已经加入最小生成树顶点相连的边加入到队列中，这样去选最小边可不可以？其实不行！</p> 
<p><img src="https://images2.imgbox.com/eb/ab/kQBHSQfR_o.png" alt="在这里插入图片描述"></p> 
<p>加入h到X集合的时候 a - h 就已经在一个集合了，这条边就不该在这个队列里面了，但是你又不能控制把它删除。</p> 
<p>所以直接用优先级队列也不太好。</p> 
<p>第二种方式就是每次去遍历，因为我们这里是矩阵很方便，每次去遍历去找X集合的顶点与Y集合的顶点构成最小的边。但是时间复杂度挺高的。</p> 
<p><strong>其实我们还是用优先级队列，不过选边的时候要判一下环，如果选出来最小的边的两个顶点在一个集合是构成环的，不能选！</strong></p> 
<pre><code class="prism language-cpp">W <span class="token function">Prim</span><span class="token punctuation">(</span>Self<span class="token operator">&amp;</span> minTree<span class="token punctuation">,</span> <span class="token keyword">const</span> V<span class="token operator">&amp;</span> src<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	size_t n <span class="token operator">=</span> _vertexs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	minTree<span class="token punctuation">.</span>_vertexs <span class="token operator">=</span> _vertexs<span class="token punctuation">;</span>
	minTree<span class="token punctuation">.</span>_IndexMap <span class="token operator">=</span> _IndexMap<span class="token punctuation">;</span>
	minTree<span class="token punctuation">.</span>_matrix<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		minTree<span class="token punctuation">.</span>_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> MAX_W<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//从X-&gt;Y集合中连接的边里面选出最小的边</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;</span> <span class="token function">X</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;</span> <span class="token function">Y</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	priority_queue<span class="token operator">&lt;</span>Edge<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>Edge<span class="token operator">&gt;</span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span>Edge<span class="token operator">&gt;&gt;</span> heap<span class="token punctuation">;</span>
	size_t srci <span class="token operator">=</span> <span class="token function">GetVertexindex</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//先把srci连接的边添加到队列中</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>_matrix<span class="token punctuation">[</span>srci<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> MAX_W<span class="token punctuation">)</span>
			heap<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">Edge</span><span class="token punctuation">(</span>srci<span class="token punctuation">,</span> i<span class="token punctuation">,</span> _matrix<span class="token punctuation">[</span>srci<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	X<span class="token punctuation">[</span>srci<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	Y<span class="token punctuation">[</span>srci<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

	size_t sz <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	W total <span class="token operator">=</span> <span class="token function">W</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>heap<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		Edge minedge <span class="token operator">=</span> heap<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		heap<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>X<span class="token punctuation">[</span>minedge<span class="token punctuation">.</span>_dsti<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//每次从两个集合中各选一个顶点构成的最小边,防止成环</span>
		<span class="token punctuation">{<!-- --></span>
			cout <span class="token operator">&lt;&lt;</span> _vertexs<span class="token punctuation">[</span>minedge<span class="token punctuation">.</span>_srci<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"-&gt;"</span> <span class="token operator">&lt;&lt;</span> _vertexs<span class="token punctuation">[</span>minedge<span class="token punctuation">.</span>_dsti<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">":"</span> <span class="token operator">&lt;&lt;</span> minedge<span class="token punctuation">.</span>_w <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
			minTree<span class="token punctuation">.</span><span class="token function">_AddEdge</span><span class="token punctuation">(</span>minedge<span class="token punctuation">.</span>_srci<span class="token punctuation">,</span> minedge<span class="token punctuation">.</span>_dsti<span class="token punctuation">,</span> minedge<span class="token punctuation">.</span>_w<span class="token punctuation">)</span><span class="token punctuation">;</span>
			sz<span class="token operator">++</span><span class="token punctuation">;</span>
			total <span class="token operator">+=</span> minedge<span class="token punctuation">.</span>_w<span class="token punctuation">;</span>
			X<span class="token punctuation">[</span>minedge<span class="token punctuation">.</span>_dsti<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
			Y<span class="token punctuation">[</span>minedge<span class="token punctuation">.</span>_dsti<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

			<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token comment">//已经选过的最小边,不要重复添加</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>_matrix<span class="token punctuation">[</span>minedge<span class="token punctuation">.</span>_dsti<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> MAX_W <span class="token operator">&amp;&amp;</span> Y<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
					heap<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">Edge</span><span class="token punctuation">(</span>minedge<span class="token punctuation">.</span>_dsti<span class="token punctuation">,</span> i<span class="token punctuation">,</span> _matrix<span class="token punctuation">[</span>minedge<span class="token punctuation">.</span>_dsti<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>
			cout <span class="token operator">&lt;&lt;</span> <span class="token string">"构成环："</span><span class="token punctuation">;</span>
			cout <span class="token operator">&lt;&lt;</span> _vertexs<span class="token punctuation">[</span>minedge<span class="token punctuation">.</span>_srci<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"-&gt;"</span> <span class="token operator">&lt;&lt;</span> _vertexs<span class="token punctuation">[</span>minedge<span class="token punctuation">.</span>_dsti<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">":"</span> <span class="token operator">&lt;&lt;</span> minedge<span class="token punctuation">.</span>_w <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>sz <span class="token operator">==</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> total<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="5__909"></a>5. 最短路径</h2> 
<p>最短路径问题：从在带权有向图G中的某一顶点出发，找出一条通往另一顶点的最短路径，最短也就是沿路径各边的权值总和达到最小。</p> 
<p>一般而言：<br> 最小生成树 -&gt; 无向图<br> 最短路径 -&gt; 有向图</p> 
<h3><a id="51_Dijkstra_917"></a>5.1 单源最短路径–Dijkstra算法</h3> 
<p><strong>单源最短路径：一个起点到其他所有点，最短路径。</strong></p> 
<p>单源最短路径问题：给定一个图G = ( V ， E ) G=(V，E)G=(V，E)，求源结点s ∈ V s∈Vs∈V到图中每个结点v ∈ V v∈Vv∈V的最短路径。Dijkstra算法就适用于解决带权重的有向图上的单源最短路径问题，<strong>同时算法要求图中所有边的权重非负</strong>。一般在求解最短路径的时候都是已知一个起点和一个终点，所以使用Dijkstra算法求解过后也就得到了所需起点到终点的最短路径。</p> 
<p>针对一个带权有向图G，<strong>将所有结点分为两组S和Q</strong>，<strong>S是已经确定最短路径的结点集合，在初始时为空（初始时就可以将源节点s放入，毕竟源节点到自己的代价是0）</strong>，<strong>Q 为其余未确定最短路径的结点集合</strong>，<strong>每次从Q 中找出一个起点到该结点代价最小的结点u ，将u 从Q 中移出，并放入S 中，对u 的每一个相邻结点v 进行松弛操作</strong>。松弛即对每一个相邻结点v ，判断源节点s到结点u 的代价与u 到v 的代价之和是否比原来s 到v 的代价更小，若代价比原来小则要将s 到v 的代价更新为s 到u 与u 到v 的代价之和，否则维持原样。如此一直循环直至集合Q 为空，即所有节点都已经查找过一遍并确定了最短路径，至于一些起点到达不了的结点在算法循环后其代价仍为初始设定的值，不发生变化。Dijkstra算法每次都是选择V-S中最小的路径节点来进行更新，并加入S中，所以该算法使用的是贪心策略。</p> 
<p><strong>Dijkstra算法存在的问题是不支持图中带负权路径，如果带有负权路径，则可能会找不到一些路径的最短路径</strong></p> 
<p>比如这里是以s为源点去找和其他点的最短路径。<br> 刚开始S集合里面只有起点s，s到其他起点初始都是∞指的是还没有最短路径。s是自己到自己可以初始为0，初始选择a这个起点，以这个点去做松弛操作，去遍历与s相连的顶点去更新s到其他顶点的最短路径，然后从未被加入到S里面的点里面去选一个从源点到这些顶点的最短路径。以这个顶点开始在去做松弛操作。</p> 
<p><font color="red"><strong>Dijkstra算法贪心策略：每次去选从起点-&gt;还没加入到最短路径的顶点中去选最短路径那个顶点，去更新其连接的路径(做松弛操作)</strong></font></p> 
<p>用最小的边在去更新其他边也是相对很小。<br> <img src="https://images2.imgbox.com/4d/a0/JQgbWEvx_o.png" alt="在这里插入图片描述"></p> 
<p><strong>如何存储起点到其他顶点最短路径的权值和存储最短路径呢？</strong></p> 
<p>它这里用的是抽象表示，用了两个数组，本来是二维的。但是压缩成了一维。<br> 每个顶点都确定过一个下标。根据下标搞了一个数组，把起点到其他顶点的最短路径的权值存储到这个dist数组里。在根据下标搞一个Ppath记录起点到其他顶点的路径，数组里面存的是路径前一个顶点下标。</p> 
<p><img src="https://images2.imgbox.com/f8/65/Yh8UGV9I_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-cpp"><span class="token comment">//顶点个数是 N, 时间复杂度 O(N^2)  空间复杂度 O(N)</span>
<span class="token keyword">void</span> <span class="token function">Dijkstra</span><span class="token punctuation">(</span><span class="token keyword">const</span> V<span class="token operator">&amp;</span> src<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>W<span class="token operator">&gt;</span><span class="token operator">&amp;</span> dist<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> Ppath<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	size_t n <span class="token operator">=</span> _vertexs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	size_t srci <span class="token operator">=</span> <span class="token function">GetVertexindex</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//dist,记录srci-其他顶点最短路径权值数组</span>
	dist<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> MAX_W<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//Ppath 记录srci-其他顶点最短路径父顶点数组</span>
	Ppath<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//初始化</span>
	dist<span class="token punctuation">[</span>srci<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	Ppath<span class="token punctuation">[</span>srci<span class="token punctuation">]</span> <span class="token operator">=</span> srci<span class="token punctuation">;</span>
	<span class="token comment">//已经确定最短路径的顶点集合</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;</span> <span class="token function">S</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// n个顶点更新N次</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//每次去选从起点-&gt;还未加入到最短路径的顶点中去选最短路径的那个顶点,去更新其连接的路径(松弛操作)</span>
		W min <span class="token operator">=</span> MAX_W<span class="token punctuation">;</span>
		size_t u <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>S<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> min<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				u <span class="token operator">=</span> j<span class="token punctuation">;</span>
				min <span class="token operator">=</span> dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		S<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment">//选到的顶点加入到最短路径</span>

		<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>v<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//松弛操作,已经加入到最短路径的顶点路径已经是最小不用更新,其他顶点如果 s -&gt; u + u -&gt; v &lt; s -&gt; v 更新</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>S<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> _matrix<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">!=</span> MAX_W <span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> _matrix<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> _matrix<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span>
				Ppath<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> u<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>		
<span class="token punctuation">}</span>
</code></pre> 
<p>打印最短路径，各个顶点的最短路径是倒着存的，存的是前一个顶点的下标。我们把路径算出来之后还要逆置一下才能把路径找到。</p> 
<p><img src="https://images2.imgbox.com/c9/46/I9mBkvwB_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">PrintShortPath</span><span class="token punctuation">(</span><span class="token keyword">const</span> V<span class="token operator">&amp;</span> src<span class="token punctuation">,</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span>W<span class="token operator">&gt;</span><span class="token operator">&amp;</span> dist<span class="token punctuation">,</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> Ppath<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	size_t srci <span class="token operator">=</span> <span class="token function">GetVertexindex</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>
	size_t n <span class="token operator">=</span> _vertexs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> srci<span class="token punctuation">)</span><span class="token comment">//自己到自己不算</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//找出i顶点的路径，和并查集类似</span>
			vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> path<span class="token punctuation">;</span>
			<span class="token keyword">int</span> parent <span class="token operator">=</span> i<span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> srci<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				path<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
				parent <span class="token operator">=</span> Ppath<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//前一个顶点的下标</span>
			<span class="token punctuation">}</span>
			path<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>srci<span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token function">reverse</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> path<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> e <span class="token operator">:</span> path<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				cout <span class="token operator">&lt;&lt;</span> _vertexs<span class="token punctuation">[</span>e<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"-&gt;"</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			cout <span class="token operator">&lt;&lt;</span> <span class="token string">"权值和 "</span> <span class="token operator">&lt;&lt;</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/2b/57/CrHUjBrz_o.png" alt="在这里插入图片描述"></p> 
<p><strong>Dijkstra算法存在的问题是不支持图中带负权路径，如果带有负权路径，则可能会找不到一些路径的最短路径</strong></p> 
<p>可以看到 s -&gt; y 并不是最短路径。Dijkstra算法本身用了一个贪心，如果对已加入到最小路径的顶点更新这个贪心就失效了。如果边的权值都是正的，以其他边去更新已经加入最小路径的顶点就比之前更大没有必要更新，但是有负数就不一样了，贪心就失效了。</p> 
<p><img src="https://images2.imgbox.com/2b/8b/dexF97rz_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="52_BellmanFord_1030"></a>5.2 单源最短路径–Bellman-Ford算法</h3> 
<p>Dijkstra算法只能用来解决正权图的单源最短路径问题，但有些题目会出现负权图。这时这个算法就不能帮助我们解决问题了，而<strong>bellman—ford算法可以解决负权图的单源最短路径问题</strong>。<strong>它的优点是可以解决有负权边的单源最短路径问题，而且可以用来判断是否有负权回路</strong>。它也有明显的缺点，它的时间复杂度 O(N*E) (N是点数，E是边数)普遍是要高于Dijkstra算法O(N²)的。像这里如果我们使用邻接矩阵实现，那么遍历所有边的数量的<strong>时间复杂度就是O(N^3)</strong>，这里也可以看出来Bellman-Ford就是一种<strong>暴力求解更新</strong>。</p> 
<p><img src="https://images2.imgbox.com/36/d1/uweGvdiu_o.png" alt="在这里插入图片描述"></p> 
<p>s -&gt; { j } 其他顶点的集合，要么是直接相连，要么是找中间边边去更新，<strong>Dijkstra</strong>是去找s-&gt;某个顶点特别短那就优先拿这条边去作为<strong>起始边</strong>去更新，它是我到这个顶点边是最短的，那我从这个顶点到其他顶点也是最短的。<strong>Bellman-Ford</strong>是去找<strong>终止边</strong>暴力去更新。</p> 
<p><strong>Dijkstra <font color="red">最小起始边，贪心</font></strong><br> <strong>Bellman-Ford <font color="red">终止边，暴力</font></strong></p> 
<p><strong>终止边就是以 i -&gt; j 去进行更新，i -&gt; j 就是图中所有边</strong></p> 
<p>s -&gt; { j } 其他顶点，要么直接相连，要么 s -&gt; i i -&gt; j，这个时候仅需要探测s -&gt; i 是通的 i -&gt; j 也是通的 它们加起来比 s -&gt; j 更小，就松弛更新一下。i -&gt; j 代表图中所有边，拿图中所有边去暴力更新一遍。</p> 
<p><font color="red"><strong>Bellman-Ford算法借助终止边（i -&gt; j ，图中所有边）暴力更新起点 -&gt; { j } 所有顶点。要么直接相连，要么借助终止边。</strong></font></p> 
<p>但是拿所有边走一遍并不是说就一定能更新出来！</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">BellmanFord</span><span class="token punctuation">(</span><span class="token keyword">const</span> V<span class="token operator">&amp;</span> src<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>W<span class="token operator">&gt;</span><span class="token operator">&amp;</span> dist<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> Ppath<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	size_t srci <span class="token operator">=</span> <span class="token function">GetVertexindex</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>
	size_t n <span class="token operator">=</span> _vertexs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// vector&lt;W&gt; dist, 记录srci -&gt; 其他顶点最短路径权值数组</span>
	dist<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> MAX_W<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// vector&lt;int&gt; pPath 记录srci -&gt; 其他顶点最短路径父顶点数组</span>
	Ppath<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 先更新srci-&gt;srci为缺省值</span>
	dist<span class="token punctuation">[</span>srci<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">W</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Ppath<span class="token punctuation">[</span>srci<span class="token punctuation">]</span> <span class="token operator">=</span> srci<span class="token punctuation">;</span>


	<span class="token comment">// i -&gt; j 更新一轮</span>
	<span class="token comment">// 借助终止边i-&gt;j(图中所有顶点之间的边),更新srci到所有顶点的最小路径(做松弛操作)</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//srci -&gt; i + i -&gt; j &lt; srci -&gt; j </span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> MAX_W <span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> _matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> _matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
				Ppath<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<p>最短路径似乎更新出来了， 但是为什么s-&gt;z的权值不对呢？</p> 
<p><img src="https://images2.imgbox.com/d7/0d/YlLKaM0P_o.png" alt="在这里插入图片描述"></p> 
<p>接下来画图分析一下</p> 
<p>第一次更新是 s-&gt;s s-&gt;y，因为更新规则是 dist[i] + _matrix[i][j] &lt; dist[j]，我们初始的时候是把 dist[srci] = W()给了初始值。先先更新与s直连的边。</p> 
<p><img src="https://images2.imgbox.com/66/92/YHrRn7CK_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/03/5a/XnosS3cc_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/69/3f/BBqQPi6e_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f8/d9/ZKURW02F_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/42/c0/TfMtb6Ul_o.png" alt="在这里插入图片描述"></p> 
<p>s-&gt;x x-&gt;t，这一句的更新就导致了问题。4 + （-2）&lt; 6， s-&gt;t 最短路径更新成2，t的前一个顶点变成x。也就是从s到t的路径变成了 s -&gt; y -&gt; x -&gt; t， s -&gt; t 最短路径更新成2。</p> 
<p>但是注意到 s -&gt; t 的最短路径更新到2 ，而从 s -&gt; z 要经过t，s -&gt; z 路径因为我们更新了 s -&gt; t 的路径，而变成了 s -&gt; y -&gt; x -&gt; t -&gt; z，但是s -&gt; z 最短路径可没有更新，依旧是上次 s -&gt;(直连) t -&gt; z的最短路径2。所以 s -&gt; t 有了路径更新，但是 s -&gt; t 最短路径没有更新。权值和路径对不上。</p> 
<p><img src="https://images2.imgbox.com/5f/15/cYiFDiC1_o.png" alt="在这里插入图片描述"></p> 
<p><strong>只要你更新出了一条更短路径，可能就会影响其他路径。</strong> 如何解决？</p> 
<p>s -&gt; z， 在更新一次就变成了 s -&gt; y -&gt; x -&gt; t -&gt; z 的权值 -2了。</p> 
<p><strong>在更新一次就修正了，但是新更新路径又可能会影响其他路径，所以还要继续更新，最多更新n轮（极端情况下最多用n条边去更新某一个顶点）。</strong></p> 
<p>这里还有一个优化，可能某一轮就不会在更新了也不会影响其他路径。因此可以增加一个标记位，某一轮没有更新就结束更新。</p> 
<pre><code class="prism language-cpp"><span class="token comment">//时间复杂度 O(N^3), 空间复杂度 O(N)</span>
<span class="token keyword">void</span> <span class="token function">BellmanFord</span><span class="token punctuation">(</span><span class="token keyword">const</span> V<span class="token operator">&amp;</span> src<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>W<span class="token operator">&gt;</span><span class="token operator">&amp;</span> dist<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> Ppath<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	size_t srci <span class="token operator">=</span> <span class="token function">GetVertexindex</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>
	size_t n <span class="token operator">=</span> _vertexs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// vector&lt;W&gt; dist, 记录srci -&gt; 其他顶点最短路径权值数组</span>
	dist<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> MAX_W<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// vector&lt;int&gt; pPath 记录srci -&gt; 其他顶点最短路径父顶点数组</span>
	Ppath<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 先更新srci-&gt;srci为缺省值</span>
	dist<span class="token punctuation">[</span>srci<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">W</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Ppath<span class="token punctuation">[</span>srci<span class="token punctuation">]</span> <span class="token operator">=</span> srci<span class="token punctuation">;</span>

	<span class="token comment">// 总体最多更新n轮</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//优化</span>
		<span class="token keyword">bool</span> update <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

		<span class="token comment">// i -&gt; j 更新一轮</span>
		<span class="token comment">// 借助终止边i-&gt;j(图中所有顶点之间的边),更新srci到所有顶点的最小路径(做松弛操作)</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token comment">//srci -&gt; i + i -&gt; j &lt; srci -&gt; j </span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> MAX_W <span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> _matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token comment">//只要更新出一条更短路径,可能会影响其他路径,在更新一次就修正了</span>
					<span class="token comment">//但是新更新的路径又可能会影响其他路径,所以还要继续更新,最多更新n轮</span>
					dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> _matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
					Ppath<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
					update <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// 如果这个轮次中没有更新出更短路径，那么后续轮次就不需要再走了</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>update <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/2c/47/k8VxEyg7_o.png" alt="在这里插入图片描述"></p> 
<p>还有一个优化思路，第一个轮次所有边都会参与更新，但是第二个轮次并一定所有边都参与更新，只有那些第一个轮次更新的最短路径的会影响其他路径的，然后第二轮去更新就好了。具体可以搞一个队列优化。</p> 
<p><strong>第一轮更新：所有边入队列<br> 后面的轮次：更新出最短路径的边入队列</strong></p> 
<p><img src="https://images2.imgbox.com/0c/8d/rNcAHAdm_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/14/6a/83gv0X7o_o.png" alt="在这里插入图片描述"></p> 
<p>Bellman-Ford算法它的优点是可以解决有负权边的单源最短路径问题，但是解决不了带负权回路的的单源最短路径问题。因此可以用来<strong>判断是否有负权回路</strong>。</p> 
<p>s-&gt;s 每次都会更新。</p> 
<p><img src="https://images2.imgbox.com/cb/cb/s62l9uit_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token function">BellmanFord</span><span class="token punctuation">(</span><span class="token keyword">const</span> V<span class="token operator">&amp;</span> src<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>W<span class="token operator">&gt;</span><span class="token operator">&amp;</span> dist<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> Ppath<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	size_t srci <span class="token operator">=</span> <span class="token function">GetVertexindex</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>
	size_t n <span class="token operator">=</span> _vertexs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// vector&lt;W&gt; dist, 记录srci -&gt; 其他顶点最短路径权值数组</span>
	dist<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> MAX_W<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// vector&lt;int&gt; pPath 记录srci -&gt; 其他顶点最短路径父顶点数组</span>
	Ppath<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 先更新srci-&gt;srci为缺省值</span>
	dist<span class="token punctuation">[</span>srci<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">W</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Ppath<span class="token punctuation">[</span>srci<span class="token punctuation">]</span> <span class="token operator">=</span> srci<span class="token punctuation">;</span>

	<span class="token comment">// 总体最多更新n轮</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//优化</span>
		<span class="token keyword">bool</span> update <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

		<span class="token comment">// i -&gt; j 更新一轮</span>
		<span class="token comment">// 借助终止边i-&gt;j(图中所有顶点之间的边),更新srci到所有顶点的最小路径(做松弛操作)</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token comment">//srci -&gt; i + i -&gt; j &lt; srci -&gt; j </span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> MAX_W <span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> _matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token comment">//只要更新出一条更短路径,可能会影响其他路径,在更新一次就修正了</span>
					<span class="token comment">//但是新更新的路径又可能会影响其他路径,所以还要继续更新,最多更新n轮</span>
					dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> _matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
					Ppath<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
					update <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// 如果这个轮次中没有更新出更短路径，那么后续轮次就不需要再走了</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>update <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token comment">//更新n轮后还能更新就是带负权回路</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//srci -&gt; i + i -&gt; j &lt; srci -&gt; j </span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> MAX_W <span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> _matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/83/dc/GWv0JoX2_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="53_FloydWarshall_1238"></a>5.3 多源最短路径–Floyd-Warshall算法</h3> 
<p><strong>Floyd-Warshall算法是解决图中任意两点间的最短路径的一种算法，也可以解决带负权路径</strong>。</p> 
<p><strong>Dijkstra算法和BellmanFord算法也可以以所有点为起点也可以求出任意两点之间的最短距离。但是Dijkstra算法不能带负权，BellmanFord算法效率低一点。</strong></p> 
<p>Floyd-Warshall算法真正优势在于同时更新多源，既然要记录多源的权值和数组那就意味着一维已经不行了，那这个时候就要搞成一个二维的。二维就能记录任意两个点。它和一维的区别就是以前算 srci -&gt; i i -&gt; j 要去矩阵里面取，现在就去dist这个矩阵里面去取。</p> 
<p><img src="https://images2.imgbox.com/41/50/ZAnUxLQ6_o.png" alt="在这里插入图片描述"></p> 
<p>Floyd算法考虑的是一条最短路径的中间节点，即简单路径p={v1,v2,…,vn}上除v1和vn的任意节点。</p> 
<p>任意两点之间要么直接相连，要么最多经过其它点（n - 2个顶点）。</p> 
<p><strong>Dijkstra算法是用最小起始边来算<br> BellmanFord算法是用终止边来算<br> Floyd-Warshall算法使用中间点来算</strong></p> 
<p>设k是p的一个中间节点，那么从i到j的最短路径p就被分成i到k和k到j的两段最短路径p1，p2。p1是从i到k且中间节点属于{1，2，…，k-1}取得的一条最短路径。p2是从k到j且中间节点属于{1，2，…，k-1}取得的一条最短路径。</p> 
<p><img src="https://images2.imgbox.com/f6/6d/A43lkxxz_o.png" alt="在这里插入图片描述"></p> 
<p><strong>Floyd-Warshall算法本质还是用了动态规划。距离都在dsti里面去取，i -&gt; j 要么直接相连，要么经过 （（1…k)集合中的顶点(n-2个顶点)） i -&gt; k，k - &gt; j。取两种情况中的最小值为最短路径。</strong></p> 
<p>具体做法如下：</p> 
<ol><li>先将直接相连的 i -&gt; j 的 dist ，Ppath初始化</li><li>最短路径更新，i -&gt; 中间点 -&gt; j，k作为中间点尝试更新 i -&gt; j 的路径， 如果 i -&gt; k，k -&gt; j &lt; i -&gt; j 更新 dist[i][j]和Ppath[i][j]，注意如果是i -&gt; k，k -&gt; j &lt; i -&gt; j，Ppath[i][j] 更新要注意，Ppath要的是跟 j 相连的上一个邻接顶点，如果 k 与 j 直接相连 Ppath[k][j]存的就是 k ，如果 k -&gt; j 没有直接相连，k -&gt; … -&gt; x - &gt; j，Ppath[k][j] 存的就是 x。所以Ppath[i][j] = Ppath[k][j] ，而不是直接等于 k。</li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">FloydWarshall</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>W<span class="token operator">&gt;&gt;</span><span class="token operator">&amp;</span> vvDist<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span><span class="token operator">&amp;</span> vvPpath<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	size_t n <span class="token operator">=</span> _vertexs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//初始化权值和路径矩阵</span>
	vvDist<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span>W<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> MAX_W<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	vvPpath<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//先将之间相连的 i-&gt;j 更新一下</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> MAX_W<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				vvDist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> _matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
				vvPpath<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> j<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				vvDist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">W</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 最短路径的更新i-&gt; {其他顶点} -&gt;j</span>
	<span class="token comment">// K严格来说最多是n-2个,但是不能循环n-2次,要循环n次,因为 i -&gt; j 一直在变,要把所有点作为中间点</span>
	<span class="token comment">// abcdef  a-&gt;f k这次是a或者f 对于a-&gt;f也没有影响,  a-&gt;a a-&gt;f,  a-&gt;f f-&gt;f,</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token comment">// k 作为的中间点尝试去更新 i-&gt;j 的路径</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>vvDist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">!=</span> MAX_W <span class="token operator">&amp;&amp;</span> vvDist<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> MAX_W
					<span class="token operator">&amp;&amp;</span> vvDist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> vvDist<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> vvDist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					vvDist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> vvDist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> vvDist<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>

					<span class="token comment">// 找跟j相连的上一个邻接顶点</span>
					<span class="token comment">// 如果k-&gt;j 直接相连，上一个点就k，vvpPath[k][j]存就是k</span>
					<span class="token comment">// 如果k-&gt;j 没有直接相连，k-&gt;...-&gt;x-&gt;j，vvpPath[k][j]存就是x</span>
					vvPpath<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> vvPpath<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>


			<span class="token comment">// 打印权值和路径矩阵观察数据</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span>vvDist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> MAX_W<span class="token punctuation">)</span>
					<span class="token punctuation">{<!-- --></span>
						<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%3c"</span><span class="token punctuation">,</span> <span class="token char">'*'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
					<span class="token keyword">else</span>
					<span class="token punctuation">{<!-- --></span>
						<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%3d"</span><span class="token punctuation">,</span> vvDist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
				<span class="token punctuation">}</span>
				cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

			<span class="token punctuation">}</span>
			cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

			<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%3d"</span><span class="token punctuation">,</span> vvPpath<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			cout <span class="token operator">&lt;&lt;</span> <span class="token string">"================================="</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">TestFloydWarShall</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> str <span class="token operator">=</span> <span class="token string">"12345"</span><span class="token punctuation">;</span>
	Graph<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> INT_MAX<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token operator">&gt;</span> <span class="token function">g</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	g<span class="token punctuation">.</span><span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token char">'1'</span><span class="token punctuation">,</span> <span class="token char">'2'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	g<span class="token punctuation">.</span><span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token char">'1'</span><span class="token punctuation">,</span> <span class="token char">'3'</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	g<span class="token punctuation">.</span><span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token char">'1'</span><span class="token punctuation">,</span> <span class="token char">'5'</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	g<span class="token punctuation">.</span><span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token char">'2'</span><span class="token punctuation">,</span> <span class="token char">'4'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	g<span class="token punctuation">.</span><span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token char">'2'</span><span class="token punctuation">,</span> <span class="token char">'5'</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	g<span class="token punctuation">.</span><span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token char">'3'</span><span class="token punctuation">,</span> <span class="token char">'2'</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	g<span class="token punctuation">.</span><span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token char">'4'</span><span class="token punctuation">,</span> <span class="token char">'1'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	g<span class="token punctuation">.</span><span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token char">'4'</span><span class="token punctuation">,</span> <span class="token char">'3'</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	g<span class="token punctuation">.</span><span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token char">'5'</span><span class="token punctuation">,</span> <span class="token char">'4'</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> vvDist<span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> vvParentPath<span class="token punctuation">;</span>
	g<span class="token punctuation">.</span><span class="token function">FloydWarshall</span><span class="token punctuation">(</span>vvDist<span class="token punctuation">,</span> vvParentPath<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//打印任意两点之间的最短路径</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		g<span class="token punctuation">.</span><span class="token function">PrintShortPath</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> vvDist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> vvParentPath<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/77/7b/gjJum2Mf_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/039dfab3f6f0fcd539d822de73b41ecf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ee trade：黄金投资与股票投资的区别</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/20ece005b236ecbc90dc5f23a4d1596c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C&#43;&#43;】unordered_set和unordered_map的封装（哈希）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>