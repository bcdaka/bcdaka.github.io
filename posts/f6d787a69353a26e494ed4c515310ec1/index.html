<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>八大排序算法(含时间复杂度、空间复杂度、算法稳定性) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/f6d787a69353a26e494ed4c515310ec1/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="八大排序算法(含时间复杂度、空间复杂度、算法稳定性)">
  <meta property="og:description" content="文章目录 八大排序算法(含时间复杂度、空间复杂度、算法稳定性)1、（直接）插入排序1.1、算法思想1.2、排序过程图解1.3、排序代码 2、希尔排序3、冒泡排序3.1、算法思想3.2、排序过程图解3.3、排序代码 4、（简单）选择排序4.1、算法思想4.2、排序过程图解4.3、排序代码 5、堆排序6、快速排序7、归并排序8、计数排序8.1、算法思想8.2、排序过程图解8.3、排序代码 八大排序算法(含时间复杂度、空间复杂度、算法稳定性) 下列算法默认都是对数组进行升序
1、（直接）插入排序 1.1、算法思想 插入排序是一种简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
插入排序的具体步骤如下：
从第一个元素开始，该元素可以认为已经被排序；取出下一个元素，在已经排序的元素序列中从后向前扫描；如果该元素（已排序）大于新元素，将该元素移到下一位置；重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；将新元素插入到该位置后；重复步骤2~5。 1.2、排序过程图解 从第一个元素开始，该元素可以认为已经被排序，取出下一个元素并记录到临时变量tmp中，在已经排序的元素序列中从后向前扫描（end--），如果该元素（已排序）大于新元素，将该元素移到下一位置，如果该元素小于等于新元素，则直接在这个元素的后面把新元素放进来。
这里仅演示部分过程，其他过程自行考虑（和上述过程类似）。 1.3、排序代码 end指向当前要插入元素的前一个位置（end&#43;1指向当前要插入元素的位置），tmp保存当前要插入的元素，在已经排序的元素序列中从后向前扫描，找到比新元素小的元素的时候（因为有序，这个位置前面的元素比这个元素更小），直接把新元素插入到这个位置的后面。
//插入排序 void InsertSort(int *arr, int n) { for (int i = 0; i &lt; n - 1; &#43;&#43;i) { //一趟 int end = i; int tmp = arr[end &#43; 1]; while (end &gt;= 0) { if (tmp &lt; arr[end]) { arr[end &#43; 1] = arr[end]; } else { break; } --end; } arr[end &#43; 1] = tmp; } } 时间复杂度计算：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-10-13T18:59:18+08:00">
    <meta property="article:modified_time" content="2023-10-13T18:59:18+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">八大排序算法(含时间复杂度、空间复杂度、算法稳定性)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_3" rel="nofollow">八大排序算法(含时间复杂度、空间复杂度、算法稳定性)</a></li><li><ul><li><a href="#1_7" rel="nofollow">1、（直接）插入排序</a></li><li><ul><li><a href="#11_9" rel="nofollow">1.1、算法思想</a></li><li><a href="#12_30" rel="nofollow">1.2、排序过程图解</a></li><li><a href="#13_44" rel="nofollow">1.3、排序代码</a></li></ul> 
   </li><li><a href="#2_95" rel="nofollow">2、希尔排序</a></li><li><a href="#3_103" rel="nofollow">3、冒泡排序</a></li><li><ul><li><a href="#31_105" rel="nofollow">3.1、算法思想</a></li><li><a href="#32_115" rel="nofollow">3.2、排序过程图解</a></li><li><a href="#33_129" rel="nofollow">3.3、排序代码</a></li></ul> 
   </li><li><a href="#4_189" rel="nofollow">4、（简单）选择排序</a></li><li><ul><li><a href="#41_191" rel="nofollow">4.1、算法思想</a></li><li><a href="#42_205" rel="nofollow">4.2、排序过程图解</a></li><li><a href="#43_223" rel="nofollow">4.3、排序代码</a></li></ul> 
   </li><li><a href="#5_272" rel="nofollow">5、堆排序</a></li><li><a href="#6_280" rel="nofollow">6、快速排序</a></li><li><a href="#7_288" rel="nofollow">7、归并排序</a></li><li><a href="#8_296" rel="nofollow">8、计数排序</a></li><li><ul><li><a href="#81_298" rel="nofollow">8.1、算法思想</a></li><li><a href="#82_312" rel="nofollow">8.2、排序过程图解</a></li><li><a href="#83_330" rel="nofollow">8.3、排序代码</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<br> 
<img src="https://images2.imgbox.com/69/92/XmeKzcyA_o.gif" alt="img"> 
<p></p> 
<h2><a id="_3"></a>八大排序算法(含时间复杂度、空间复杂度、算法稳定性)</h2> 
<blockquote> 
 <p><mark><strong>下列算法默认都是对数组进行升序</strong></mark></p> 
</blockquote> 
<h3><a id="1_7"></a>1、（直接）插入排序</h3> 
<h4><a id="11_9"></a>1.1、算法思想</h4> 
<ul><li> <p>插入排序是一种简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p> <p>插入排序的具体步骤如下：</p> 
  <ol><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ol> </li></ul> 
<img src="https://images2.imgbox.com/55/54/8XKAqq2H_o.gif"> 
<p><img src="https://images2.imgbox.com/41/c9/1317ERW5_o.gif" alt="img"></p> 
<hr> 
<h4><a id="12_30"></a>1.2、排序过程图解</h4> 
<ul><li> <p>从第一个元素开始，该元素可以认为已经被排序，取出下一个元素并记录到临时变量<code>tmp</code>中，在已经排序的元素序列中从后向前扫描（<code>end--</code>），如果该元素（已排序）大于新元素，将该元素移到下一位置，如果该元素小于等于新元素，则直接在<strong>这个元素的后面</strong>把新元素放进来。</p> <p><img src="https://images2.imgbox.com/01/45/DZwdAbIK_o.png" alt=""></p> <p><img src="https://images2.imgbox.com/94/51/j6f2dbb0_o.png" alt=""></p> 
  <ul><li>这里仅演示部分过程，其他过程自行考虑（和上述过程类似）。</li></ul> </li></ul> 
<hr> 
<h4><a id="13_44"></a>1.3、排序代码</h4> 
<ul><li> <p><code>end</code>指向当前<strong>要插入元素的前一个位置</strong>（<code>end+1</code>指向当前<strong>要插入元素的位置</strong>），<code>tmp</code>保存当前要插入的元素，在已经排序的元素序列中从后向前扫描，找到比新元素小的元素的时候（因为<strong>有序</strong>，这个位置前面的元素比这个元素更小），直接把新元素插入到这个位置的后面。</p> <pre><code class="prism language-c"><span class="token comment">//插入排序</span>
<span class="token keyword">void</span> <span class="token function">InsertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>arr<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//一趟</span>
        <span class="token keyword">int</span> end <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>end <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                arr<span class="token punctuation">[</span>end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token operator">--</span>end<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        arr<span class="token punctuation">[</span>end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> </li><li> <p><strong>时间复杂度</strong>计算：</p> 
  <ul><li> <p>最坏时间复杂度：数组元素原本是降序，现要求使其升序。那么每个元素需要移动或者比较的次数为:</p> 
    <ul><li>第一个元素：<code>0</code>次</li><li>第二个元素：<code>1</code>次</li><li>第三个元素：<code>2</code>次</li><li>…</li><li>第n个元素：<code>n-1</code>次</li></ul> 
    <blockquote> 
     <p>总次数：<code>0+1+2+3+...+n-1 = n*(n-1)/2</code>次</p> 
     <p>所以<strong>最坏时间复杂度为：O(n^2)</strong>。</p> 
    </blockquote> </li><li> <p>最好时间复杂度：考虑数组原本是升序，那么所有元素需要移动或者比较的总次数为：<code>0+1+1+...+1 = n-1</code>。所以<strong>最好时间复杂度为O(n)</strong>。</p> </li><li> <p>平均<mark>时间复杂度：O(n^2)</mark> ----&gt; <strong>算法不太行</strong>。</p> </li></ul> </li><li> <p><strong>空间复杂度</strong>计算：由于没有开辟额外空间来辅助数组排序，故<mark>空间复杂度为O(1)</mark>。</p> </li><li> <p><strong>算法稳定性</strong>：<mark>稳定</mark>，因为对于值相同的元素，后插入的时候不会插到相同元素的前面（<code>tmp &gt;= arr[end]</code>会<code>break</code>，即不插入）。</p> </li></ul> 
<hr> 
<h3><a id="2_95"></a>2、希尔排序</h3> 
<p><a href="http://t.csdnimg.cn/svxim" rel="nofollow">希尔排序详解</a></p> 
<hr> 
<h3><a id="3_103"></a>3、冒泡排序</h3> 
<h4><a id="31_105"></a>3.1、算法思想</h4> 
<ul><li>冒泡排序是通过对<strong>相邻元素</strong>的比较和位置交换，使得每次遍历都可以得到剩余元素中的最大值，将其放入有序序列中<strong>最终的位置</strong>，然后下一趟排序的时候就不用去比较这个已经确定了的元素。在冒泡排序中，会依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就如同水底下的气泡一样逐渐向上冒。</li></ul> 
<img src="https://images2.imgbox.com/c3/5b/GmOiVlwu_o.gif"> 
<hr> 
<h4><a id="32_115"></a>3.2、排序过程图解</h4> 
<ul><li> <p>每趟排序可以把一个元素”冒“到最终位置上，下一趟排序就可以少排序一个元素。</p> <p><img src="https://images2.imgbox.com/f6/8a/tpjts5wE_o.png" alt=""></p> <p><img src="https://images2.imgbox.com/16/c2/beRq54zq_o.png" alt=""></p> 
  <ul><li>这里仅演示部分过程，其他过程自行考虑（和上述过程类似）。</li></ul> </li></ul> 
<hr> 
<h4><a id="33_129"></a>3.3、排序代码</h4> 
<ul><li> <p>指针<code>i</code>控制每趟需要少排序的元素个数（即已经有<code>i</code>个元素已经在最终位置上），指针<code>j</code>用来比较相邻元素的大小，若相邻元素是降序，则交换这两个元素。</p> </li><li> <p>这里定义了一个<code>flag</code>，用来标记每趟排序是否有交换，如果有交换，就需要继续下一趟排序，<strong>没有交换则说明数组已经有序</strong>，那么就不用继续下一趟排序！</p> <pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token operator">*</span>a<span class="token punctuation">;</span>
    <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>
    <span class="token operator">*</span>b <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//冒泡排序</span>
<span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>arr<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>flag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> </li><li> <p><strong>时间复杂度</strong>计算：</p> 
  <ul><li> <p>最坏时间复杂度：考虑数组原本是降序，现在要求其升序。那么每个元素需要移动或者比较的次数为:</p> 
    <ul><li>第一趟排序：<code>n-1</code>次</li><li>第二趟排序：<code>n-2</code>次</li><li>第三趟排序：<code>n-3</code>次</li><li>…</li><li>第n趟排序：<code>1</code>次</li></ul> 
    <blockquote> 
     <p>总次数：<code>n-1+n-2+n-3+...+1 = n*(n-1)/2</code>次</p> 
     <p>所以<strong>最坏时间复杂度为：O(n^2)</strong>。</p> 
    </blockquote> </li><li> <p>最好时间复杂度：考虑数组原本是升序。那么所有元素需要移动或者比较的次数为：</p> <p>若不使用<code>flag</code>：比较次数为<code>n-1+n-2+n-3+...+1 = n*(n-1)/2</code>次。</p> <p>使用<code>flag</code>：比较次数为<code>n-1</code>次。</p> </li><li> <p>平均<mark>时间复杂度：O(n^2)</mark> —&gt; <strong>算法不太行</strong>。</p> </li></ul> </li><li> <p><strong>空间复杂度</strong>计算：由于没有开辟额外空间来辅助数组排序，故<mark>空间复杂度为O(1)</mark>。</p> </li><li> <p><strong>算法稳定性</strong>：<mark>稳定</mark>，因为对于值相同的元素，每一趟排序的时候不会交换（<code>arr[j + 1] &lt; arr[j]</code>才交换）。</p> </li></ul> 
<hr> 
<h3><a id="4_189"></a>4、（简单）选择排序</h3> 
<h4><a id="41_191"></a>4.1、算法思想</h4> 
<ul><li>选择排序是一种简单直观的排序算法。它的工作原理如下：（<strong>优化后的选择排序</strong>–&gt;每次都能确定当前未排序序列的最小元素和最大元素的最终位置） 
  <ol><li>在未排序序列中找到最小元素和最大元素，最小元素存放到排序序列的起始位置，最大元素存放到排序序列的末尾位置。</li><li>再从剩余未排序元素中继续寻找最小元素和最大元素，然后<strong>最小元素放到前面已排序序列的末尾</strong>，<strong>最大元素放到后面已排序序列的前面</strong>。</li><li>以此类推，直到所有元素均排序完毕。</li></ol> </li><li>这里动画排序是每次选出一个最小值。（我们讲的算法更优哈哈）</li></ul> 
<img src="https://images2.imgbox.com/9c/e2/5lE67TLW_o.gif"> 
<hr> 
<h4><a id="42_205"></a>4.2、排序过程图解</h4> 
<ul><li> <p>在未排序序列中找到最小元素和最大元素，最小元素存放到排序序列的起始位置，最大元素存放到排序序列的末尾位置。</p> <p><img src="https://images2.imgbox.com/88/37/nHbemtQB_o.png" alt=""></p> </li><li> <p>再从剩余未排序元素中继续寻找最小元素和最大元素，然后<strong>最小元素放到前面已排序序列的末尾</strong>，<strong>最大元素放到后面已排序序列的前面</strong>。</p> <p><img src="https://images2.imgbox.com/ed/5b/uJ02teF4_o.png" alt=""></p> 
  <ul><li>这里仅演示部分过程，其他过程自行考虑（和上述过程类似）。</li></ul> </li><li> <p>以此类推，直到所有元素均排序完毕。</p> </li></ul> 
<hr> 
<h4><a id="43_223"></a>4.3、排序代码</h4> 
<ul><li> <p>使用<code>mini</code>和<code>maxi</code>分别记录当前未排序的最小值下标和最大值下标在未排序的序列中找出最小值和最大值，然后分别交换到当前未排序的起始位置和末尾位置。<strong>需要注意的是</strong>：<mark>如果当前未排序的序列中，最大值刚好在未排序序列的起始位置，那么就需要记录好这个最大值与当前未排序的序列中的最小值交换后的位置，不记录的话，那么当前maxi指向的值不一定是最大值！</mark></p> <pre><code class="prism language-c"><span class="token comment">//选择排序</span>
<span class="token keyword">void</span> <span class="token function">SelectSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>arr<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> mini <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> maxi <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> end <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> end<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>maxi<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                maxi <span class="token operator">=</span> i<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>mini<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                mini <span class="token operator">=</span> i<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>mini<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//注意此时如果start刚好是最大值的话，就会把最大值换走了，也就是本来最大值在 0 位置，交换后换到其他位置了，所以判断一下</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">==</span> maxi<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            maxi <span class="token operator">=</span> mini<span class="token punctuation">;</span><span class="token comment">//找到最大值的下标</span>
        <span class="token punctuation">}</span>
        <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>maxi<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//向中间靠拢</span>
        <span class="token operator">++</span>start<span class="token punctuation">;</span>
        <span class="token operator">--</span>end<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> </li><li> <p><strong>时间复杂度</strong>计算：对于选择排序排序来说，没有什么最坏时间复杂度和最好时间复杂度，因为不管原数组起始是升序还是降序，元素之间的比较次数都是一样的：</p> 
  <ul><li>确定了2个元素的最终位置：<code>n-1</code></li><li>确定了4个元素的最终位置：<code>n-1+n-3</code></li><li>确定了6个元素的最终位置：<code>n-1+n-3+n-5</code></li><li>…</li><li>确定了n个元素的最终位置：<code>n+n-3+n-5+...+1 = n*(n+1)/4 &lt;---大约</code>，所以<mark>时间复杂度为O(n^2)</mark>。</li></ul> </li><li> <p><strong>空间复杂度</strong>计算：由于没有开辟额外空间来辅助数组排序，故<mark>空间复杂度为O(1)</mark>。</p> </li><li> <p><strong>算法稳定性</strong>：<mark>不稳定</mark>，考虑序列（1，2，<font color="red">2</font>），排序后序列为（1，<font color="red">2</font>，2），我们发现<code>2</code>的相对位置发生了变化，所以是不稳定的排序算法。</p> </li></ul> 
<hr> 
<h3><a id="5_272"></a>5、堆排序</h3> 
<p><a href="http://t.csdnimg.cn/ySdL6" rel="nofollow">堆排序详解</a></p> 
<hr> 
<h3><a id="6_280"></a>6、快速排序</h3> 
<p><a href="http://t.csdnimg.cn/CcE4O" rel="nofollow">快速排序递归方法和非递归方法详解</a></p> 
<hr> 
<h3><a id="7_288"></a>7、归并排序</h3> 
<p><a href="http://t.csdnimg.cn/tpgoo" rel="nofollow">快速排序递归方法和非递归方法详解</a></p> 
<hr> 
<h3><a id="8_296"></a>8、计数排序</h3> 
<h4><a id="81_298"></a>8.1、算法思想</h4> 
<ul><li> <p>计数排序就是使用一个<strong>临时数组</strong>来记录这个<strong>原数组</strong>的元素对应这个<strong>临时数组下标</strong>出现的次数，然后再对这个<strong>临时数组</strong>从<code>0</code>开始往后按<strong>下标出现的次数</strong>遍历。</p> </li><li> <p>优化：对于原数组最小值较大的情况，我们可以使用对这个<strong>临时数组</strong>进行==<strong>重定位</strong>==。</p> 
  <ul><li> <p><strong>重定位</strong>：相当于计算机组成原理里面的将逻辑地址转化为物理地址的过程，比如序列<code>110,110,111,120,125,122,115,118,112,118</code>，其实它的范围就是在<code>110~125</code>，区间长度为<code>16</code>，如果我们按照这个序列的最大值来建立数组，那么需要长度为<code>126</code>的数组，但是这个数组的前<code>110</code>个空间都是<code>0</code>，也就是并没有用上，浪费了。但是如果创建一个长度为<code>16</code>的数组，下标为<code>0~15</code>（原数组每个元素减<code>110</code>，这个<code>110</code>是这个原数组的最小值），是不是就可以匹配这个序列的范围了呢？</p> <p>那么问题是之后遍历这个临时数组，只能得到<code>0~15</code>的下标，并不是我们要的<code>110~125</code>！其实，在遍历这个临时数组的时候，可以继续使用重定位，把这个<code>0~15</code>的下标重定位到<code>110~125</code>（每个下标都加<code>110</code>，这个<code>110</code>是这个原数组的最小值）！</p> </li></ul> </li></ul> 
<img src="https://images2.imgbox.com/2e/69/bXyWb1d1_o.gif"> 
<h4><a id="82_312"></a>8.2、排序过程图解</h4> 
<ul><li> <p>先找到原数组的最大值和最小值，然后就可以确定临时数组的长度，然后初始化这个临时数组（全<code>0</code>）。</p> <p><img src="https://images2.imgbox.com/38/4a/7DGae4PV_o.png" alt=""></p> </li><li> <p>然后依次遍历原数组，根据重定位，将原数组的元素减去最小值去对应临时数组的下标，并对这个下标里的元素<code>+1</code>。</p> <p><img src="https://images2.imgbox.com/9f/44/lFY8kA9D_o.png" alt=""></p> </li><li> <p>遍历这个临时数组，对每个下标进行遍历，按下标对应的元素值看需要对此下标遍历几次（需要重定位回去—加上原数组的最小值）。</p> <p><img src="https://images2.imgbox.com/4b/5f/eFpk8ccJ_o.png" alt=""></p> </li></ul> 
<hr> 
<h4><a id="83_330"></a>8.3、排序代码</h4> 
<ul><li> <p>用<code>min</code>和<code>max</code>记录原数组的最小值和最大值，确定临时数组的长度(<code>max-min+1</code>)，然后对临时数组<code>count</code>进行初始化，接下来就是把原数组里的元素<strong>重定位</strong>为临时数组的下标（元素值减原数组的最小值），并对此下标对应的元素<code>+1</code>，一直到遍历完原数组。</p> </li><li> <p>遍历这个临时数组<code>count</code>，对每个下标进行遍历，按下标对应的元素值看需要对此下标遍历几次（需要重定位回去—加上原数组的最小值）。</p> </li><li> <p>注意：<mark><strong>这里不能找最大最小值的下标</strong></mark>，因为在重定位回去的时候<code>arr[j++]</code>在变，也就是最小值下标不一定对应到最小值了！</p> <pre><code class="prism language-c"><span class="token comment">//计数排序</span>
<span class="token keyword">void</span> <span class="token function">CountSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>arr<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//先找出数组的最大最小值</span>
    <span class="token keyword">int</span> max <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> min <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> max<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            max <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> min<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            min <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//节省空间，需要对元素重定位</span>
    <span class="token keyword">int</span> capacity <span class="token operator">=</span> max <span class="token operator">-</span> min <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//元素大小区间</span>
    <span class="token comment">//记录每个元素的出现次数</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>count <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> capacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"malloc error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">memset</span><span class="token punctuation">(</span>count<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> capacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        count<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> min<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> capacity<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            arr<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> min<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">free</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li><li> <p><strong>时间复杂度</strong>计算：这里找最大值最小值花费时间<code>n</code>，遍历临时数组花费时间<code>k</code>（临时数组长度），所以<mark>时间复杂度为O(n+k)</mark>。</p> </li><li> <p><strong>空间复杂度</strong>计算：使用了临时数组（临时数组长度为k），所以<mark>空间复杂度为O(k)</mark>。</p> </li><li> <p><strong>算法稳定性</strong>：<mark>稳定</mark>，因为它是利用一个数据的索引来记录元素出现的次数，而这个数组的索引就是元素的数值。当计数排序完成后，具有相同数值的元素在数组中的位置也相同，因此它们的顺序保持不变。</p> </li></ul> 
<hr> 
<blockquote> 
 <p><mark><strong>八大排序算法整体的时间复杂度、空间复杂度、算法稳定性</strong>等看如下表格</mark>:</p> 
 <table><thead><tr><th align="center">排序算法</th><th align="center">平均时间复杂度</th><th align="center">最好情况</th><th align="center">最坏情况</th><th align="center">空间复杂度</th><th align="center">排序方式</th><th align="center">稳定性</th></tr></thead><tbody><tr><td align="center">（直接）插入排序</td><td align="center">O(n^2)</td><td align="center">O(n)</td><td align="center">O(n^2)</td><td align="center">O(1)</td><td align="center">内部排序</td><td align="center">稳定</td></tr><tr><td align="center">希尔排序</td><td align="center">O(n^1.3)</td><td align="center">O(n^1.3)</td><td align="center">O(n^1.3)</td><td align="center">O(1)</td><td align="center">内部排序</td><td align="center">不稳定</td></tr><tr><td align="center">冒泡排序</td><td align="center">O(n^2)</td><td align="center">O(n)</td><td align="center">O(n^2)</td><td align="center">O(1)</td><td align="center">内部排序</td><td align="center">稳定</td></tr><tr><td align="center">（简单）选择排序</td><td align="center">O(n^2)</td><td align="center">O(n^2)</td><td align="center">O(n^2)</td><td align="center">O(1)</td><td align="center">内部排序</td><td align="center">不稳定</td></tr><tr><td align="center">堆排序</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(1)</td><td align="center">内部排序</td><td align="center">不稳定</td></tr><tr><td align="center">快速排序</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(n^2)</td><td align="center">O(logn)</td><td align="center">内部排序</td><td align="center">不稳定</td></tr><tr><td align="center">归并排序</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(n)</td><td align="center">外部排序</td><td align="center">稳定</td></tr><tr><td align="center">计数排序</td><td align="center">O(n+k)</td><td align="center">O(n+k)</td><td align="center">O(n+k)</td><td align="center">O(k)</td><td align="center">外部排序</td><td align="center">稳定</td></tr></tbody></table> 
</blockquote> 
<hr> 
<p>OKOK，八大排序算法就到这里。如果你对Linux和C++也感兴趣的话，可以看看我的主页哦。下面是我的github主页，里面记录了我的学习代码和leetcode的一些题的题解，有兴趣的可以看看。</p> 
<p><a href="https://github.com/Xpccccc">Xpccccc的github主页</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2decc1252d673b5e3d169f8ba73df3a1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">手把手教你搭建微信聊天机器人系列（一）：文心一言（百度千帆ERNIE-Bot大模型）API测试</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0f5e91e8e2b4d38977a17e38a47607b2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">RSA加密，公钥、私钥的生成，前端使用公钥加密，JSEncrypt返回值为false的原因以及解决方法，XML转换Pkcs1、8</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>