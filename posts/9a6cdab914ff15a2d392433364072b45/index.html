<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【微服务】SpringCloud-eureka光速入门 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/9a6cdab914ff15a2d392433364072b45/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【微服务】SpringCloud-eureka光速入门">
  <meta property="og:description" content="SpringCloud-eureka光速入门
一、Eureka 主要组件
二、工作流程
三、优势
四、Eureka-光速入门【重点】
4.1 案例准备
4.1.1 创建父工程 tingyi-shop
4.1.2 创建子工程 tingyi-goods
4.1.3 创建子工程 tingyi-order
4.1.4 案例调整
4.1.4.1 在order模块创建 RestTemplate对象
4.1.4.2 修改OrderController
4.1.4.2 重启并测试
4.2 为什么使用eureka
4.2 Eureka光速入门
4.2.1 创建EurekaServer
4.2.2 调整商品模块
4.2.3 调整订单模块
4.2.4 调整订单模块， 调用商品模块
4.2.4 测试
4.3 Eureka的安全性
4.4 Eureka的高可用
4.4.1 配置以及代码
4.4.2 测试
4.4.3 Eureka的细节
🎈边走、边悟🎈迟早会好
Eureka 是 Netflix 开源的一个服务注册和发现工具，主要用于构建分布式系统中的服务发现机制。它在 Spring Cloud 生态系统中广泛使用，尤其在微服务架构中扮演重要角色。
一、Eureka 主要组件 Eureka Server:
作为服务注册中心，负责管理服务实例的注册和心跳检测。服务实例在启动时向 Eureka Server 注册，并定期发送心跳以保持注册信息的有效性。Eureka Server 通常部署为集群，确保高可用性和容错性。 Eureka Client:">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-12T10:58:27+08:00">
    <meta property="article:modified_time" content="2024-07-12T10:58:27+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【微服务】SpringCloud-eureka光速入门</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>SpringCloud-eureka光速入门</strong></p> 
<p id="%E4%B8%80%E3%80%81Eureka%20%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81Eureka%20%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6" rel="nofollow">一、Eureka 主要组件</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B" rel="nofollow">二、工作流程</a></p> 
<p id="%E4%B8%89%E3%80%81%E4%BC%98%E5%8A%BF-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81%E4%BC%98%E5%8A%BF" rel="nofollow">三、优势</a></p> 
<p id="%E5%9B%9B%E3%80%81Eureka-%E5%85%89%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91-toc" style="margin-left:40px;"><a href="#%E5%9B%9B%E3%80%81Eureka-%E5%85%89%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91" rel="nofollow">四、Eureka-光速入门【重点】</a></p> 
<p id="4.1%20%E6%A1%88%E4%BE%8B%E5%87%86%E5%A4%87-toc" style="margin-left:80px;"><a href="#4.1%20%E6%A1%88%E4%BE%8B%E5%87%86%E5%A4%87" rel="nofollow">4.1 案例准备</a></p> 
<p id="4.1.1%20%E5%88%9B%E5%BB%BA%E7%88%B6%E5%B7%A5%E7%A8%8B%20tingyi-shop-toc" style="margin-left:120px;"><a href="#4.1.1%20%E5%88%9B%E5%BB%BA%E7%88%B6%E5%B7%A5%E7%A8%8B%20tingyi-shop" rel="nofollow">4.1.1 创建父工程 tingyi-shop</a></p> 
<p id="4.1.2%20%E5%88%9B%E5%BB%BA%E5%AD%90%E5%B7%A5%E7%A8%8B%20tingyi-goods-toc" style="margin-left:120px;"><a href="#4.1.2%20%E5%88%9B%E5%BB%BA%E5%AD%90%E5%B7%A5%E7%A8%8B%20tingyi-goods" rel="nofollow">4.1.2 创建子工程 tingyi-goods</a></p> 
<p id="4.1.3%20%E5%88%9B%E5%BB%BA%E5%AD%90%E5%B7%A5%E7%A8%8B%20tingyi-order-toc" style="margin-left:120px;"><a href="#4.1.3%20%E5%88%9B%E5%BB%BA%E5%AD%90%E5%B7%A5%E7%A8%8B%20tingyi-order" rel="nofollow">4.1.3 创建子工程 tingyi-order</a></p> 
<p id="4.1.4%20%E6%A1%88%E4%BE%8B%E8%B0%83%E6%95%B4-toc" style="margin-left:120px;"><a href="#4.1.4%20%E6%A1%88%E4%BE%8B%E8%B0%83%E6%95%B4" rel="nofollow">4.1.4 案例调整</a></p> 
<p id="4.1.4.1%20%E5%9C%A8order%E6%A8%A1%E5%9D%97%E5%88%9B%E5%BB%BA%20RestTemplate%E5%AF%B9%E8%B1%A1-toc" style="margin-left:160px;"><a href="#4.1.4.1%20%E5%9C%A8order%E6%A8%A1%E5%9D%97%E5%88%9B%E5%BB%BA%20RestTemplate%E5%AF%B9%E8%B1%A1" rel="nofollow">4.1.4.1 在order模块创建 RestTemplate对象</a></p> 
<p id="4.1.4.2%20%E4%BF%AE%E6%94%B9OrderController-toc" style="margin-left:160px;"><a href="#4.1.4.2%20%E4%BF%AE%E6%94%B9OrderController" rel="nofollow">4.1.4.2 修改OrderController</a></p> 
<p id="4.1.4.2%20%E9%87%8D%E5%90%AF%E5%B9%B6%E6%B5%8B%E8%AF%95-toc" style="margin-left:160px;"><a href="#4.1.4.2%20%E9%87%8D%E5%90%AF%E5%B9%B6%E6%B5%8B%E8%AF%95" rel="nofollow">4.1.4.2 重启并测试</a></p> 
<p id="4.2%20%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8eureka-toc" style="margin-left:80px;"><a href="#4.2%20%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8eureka" rel="nofollow">4.2 为什么使用eureka</a></p> 
<p id="4.2%20Eureka%E5%85%89%E9%80%9F%E5%85%A5%E9%97%A8-toc" style="margin-left:80px;"><a href="#4.2%20Eureka%E5%85%89%E9%80%9F%E5%85%A5%E9%97%A8" rel="nofollow">4.2 Eureka光速入门</a></p> 
<p id="4.2.1%20%E5%88%9B%E5%BB%BAEurekaServer-toc" style="margin-left:120px;"><a href="#4.2.1%20%E5%88%9B%E5%BB%BAEurekaServer" rel="nofollow">4.2.1 创建EurekaServer</a></p> 
<p id="4.2.2%20%E8%B0%83%E6%95%B4%E5%95%86%E5%93%81%E6%A8%A1%E5%9D%97-toc" style="margin-left:120px;"><a href="#4.2.2%20%E8%B0%83%E6%95%B4%E5%95%86%E5%93%81%E6%A8%A1%E5%9D%97" rel="nofollow">4.2.2 调整商品模块</a></p> 
<p id="4.2.3%20%E8%B0%83%E6%95%B4%E8%AE%A2%E5%8D%95%E6%A8%A1%E5%9D%97-toc" style="margin-left:120px;"><a href="#4.2.3%20%E8%B0%83%E6%95%B4%E8%AE%A2%E5%8D%95%E6%A8%A1%E5%9D%97" rel="nofollow">4.2.3 调整订单模块</a></p> 
<p id="4.2.4%20%E8%B0%83%E6%95%B4%E8%AE%A2%E5%8D%95%E6%A8%A1%E5%9D%97%EF%BC%8C%20%E8%B0%83%E7%94%A8%E5%95%86%E5%93%81%E6%A8%A1%E5%9D%97-toc" style="margin-left:120px;"><a href="#4.2.4%20%E8%B0%83%E6%95%B4%E8%AE%A2%E5%8D%95%E6%A8%A1%E5%9D%97%EF%BC%8C%20%E8%B0%83%E7%94%A8%E5%95%86%E5%93%81%E6%A8%A1%E5%9D%97" rel="nofollow">4.2.4 调整订单模块， 调用商品模块</a></p> 
<p id="4.2.4%20%E6%B5%8B%E8%AF%95-toc" style="margin-left:80px;"><a href="#4.2.4%20%E6%B5%8B%E8%AF%95" rel="nofollow">4.2.4 测试</a></p> 
<p id="4.3%20Eureka%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7-toc" style="margin-left:80px;"><a href="#4.3%20Eureka%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7" rel="nofollow">4.3 Eureka的安全性</a></p> 
<p id="4.4%20Eureka%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8-toc" style="margin-left:80px;"><a href="#4.4%20Eureka%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8" rel="nofollow">4.4 Eureka的高可用</a></p> 
<p id="4.4.1%20%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81-toc" style="margin-left:120px;"><a href="#4.4.1%20%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81" rel="nofollow">4.4.1 配置以及代码</a></p> 
<p id="4.4.2%20%E6%B5%8B%E8%AF%95-toc" style="margin-left:120px;"><a href="#4.4.2%20%E6%B5%8B%E8%AF%95" rel="nofollow">4.4.2 测试</a></p> 
<p id="4.4.3%20Eureka%E7%9A%84%E7%BB%86%E8%8A%82-toc" style="margin-left:120px;"><a href="#4.4.3%20Eureka%E7%9A%84%E7%BB%86%E8%8A%82" rel="nofollow">4.4.3 Eureka的细节</a></p> 
<hr id="hr-toc"> 
<p></p> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:690px;"><tbody><tr><td> <p style="text-align:center;"><em><span style="color:#ff9900;"><strong>🎈边走、边悟🎈迟早会好</strong></span></em></p> </td></tr></tbody></table> 
<p>Eureka 是 Netflix 开源的一个服务注册和发现工具，主要用于构建分布式系统中的服务发现机制。它在 Spring Cloud 生态系统中广泛使用，尤其在微服务架构中扮演重要角色。</p> 
<h3 id="%E4%B8%80%E3%80%81Eureka%20%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6">一、Eureka 主要组件</h3> 
<ol><li> <p><strong>Eureka Server</strong>:</p> 
  <ul><li>作为服务注册中心，负责管理服务实例的注册和心跳检测。</li><li>服务实例在启动时向 Eureka Server 注册，并定期发送心跳以保持注册信息的有效性。</li><li>Eureka Server 通常部署为集群，确保高可用性和容错性。</li></ul></li><li> <p><strong>Eureka Client</strong>:</p> 
  <ul><li>是注册在 Eureka Server 上的服务实例。</li><li>它可以是任何类型的微服务应用程序，在启动时向 Eureka Server 注册并定期发送心跳。</li><li>Eureka Client 也可以从 Eureka Server 获取其他已注册服务的信息，以实现服务间的调用和负载均衡。</li></ul></li></ol> 
<h3 id="%E4%BA%8C%E3%80%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">二、工作流程</h3> 
<ol><li> <p><strong>服务注册</strong>:</p> 
  <ul><li>服务实例在启动时向 Eureka Server 注册其自身的元数据信息，如 IP 地址、端口号、服务名称等。</li></ul></li><li> <p><strong>服务心跳</strong>:</p> 
  <ul><li>注册后，服务实例定期向 Eureka Server 发送心跳请求，以表明其仍然活跃。若在一段时间内未收到心跳，Eureka Server 将认为该实例已失效，并将其从注册列表中移除。</li></ul></li><li> <p><strong>服务发现</strong>:</p> 
  <ul><li>服务调用者（客户端）通过 Eureka Server 查询可用的服务实例列表，以实现服务调用。</li><li>Eureka Client 缓存这些信息，并定期从 Eureka Server 更新，确保负载均衡和高可用性。</li></ul></li><li> <p><strong>负载均衡</strong>:</p> 
  <ul><li>客户端根据从 Eureka Server 获取的服务实例列表，实现客户端负载均衡。</li><li>常见的负载均衡策略包括轮询、随机选择、加权轮询等。</li></ul></li></ol> 
<h3 id="%E4%B8%89%E3%80%81%E4%BC%98%E5%8A%BF">三、优势</h3> 
<ul><li><strong>高可用性</strong>: Eureka Server 支持集群部署，确保在某些节点故障时系统仍然可用。</li><li><strong>自我保护机制</strong>: 当 Eureka Server 检测到大量客户端失效时，进入自我保护模式，避免因网络分区等原因误判服务失效。</li><li><strong>易扩展性</strong>: 新的服务实例可以动态注册和发现，支持弹性扩展。</li></ul> 
<p>Eureka 在 Netflix 的微服务架构中得到了广泛应用，并成为 Spring Cloud 的核心组件之一，用于实现服务注册与发现。</p> 
<h3 id="%E5%9B%9B%E3%80%81Eureka-%E5%85%89%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91">四、Eureka-光速入门【<code>重点</code>】</h3> 
<h4 id="4.1%20%E6%A1%88%E4%BE%8B%E5%87%86%E5%A4%87">4.1 案例准备</h4> 
<h5 id="4.1.1%20%E5%88%9B%E5%BB%BA%E7%88%B6%E5%B7%A5%E7%A8%8B%20tingyi-shop">4.1.1 创建父工程 tingyi-shop</h5> 
<p><strong>pom.xml</strong></p> 
<pre><code class="language-java">&lt;properties&gt;
  &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
  &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
&lt;/properties&gt;
​
&lt;packaging&gt;pom&lt;/packaging&gt;
​
&lt;parent&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
  &lt;version&gt;2.2.8.RELEASE&lt;/version&gt;
&lt;/parent&gt;
​
&lt;dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
      &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
      &lt;!-- 版本号是按照伦敦地铁站的名字命名的 --&gt;
      &lt;version&gt;Hoxton.SR4&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
      &lt;scope&gt;import&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</code></pre> 
<p></p> 
<h5 id="4.1.2%20%E5%88%9B%E5%BB%BA%E5%AD%90%E5%B7%A5%E7%A8%8B%20tingyi-goods">4.1.2 创建子工程 tingyi-goods</h5> 
<p><strong>pom.xml</strong></p> 
<pre><code class="language-java">&lt;dependencies&gt;
    &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre> 
<p><strong>引导类</strong></p> 
<pre>​
</pre> 
<pre><code class="language-java">@SpringBootApplication
public class GoodsApplication {
​
    public static void main(String[] args) {
        SpringApplication.run(GoodsApplication.class, args);
    }
}</code></pre> 
<p><strong>application.yml</strong></p> 
<pre><code class="language-java">server:
  port: 9001
#指定服务的名称
spring:
  application:
    name: TINGYI-GOODS</code></pre> 
<p><strong>controller编写</strong></p> 
<pre><code class="language-java">@RestController
public class GoodsController {
​
    @RequestMapping("/query")
    public String query() {
        return "查询商品信息!";
    }
}</code></pre> 
<p><strong>启动并查看效果</strong></p> 
<p><img alt="" height="178" src="https://images2.imgbox.com/54/c3/0431OXzK_o.png" width="551"></p> 
<p></p> 
<h5 id="4.1.3%20%E5%88%9B%E5%BB%BA%E5%AD%90%E5%B7%A5%E7%A8%8B%20tingyi-order">4.1.3 创建子工程 tingyi-order</h5> 
<p><strong>pom.xml</strong></p> 
<pre><code class="language-java">&lt;dependencies&gt;
    &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre> 
<p><strong>引导类</strong></p> 
<pre><code class="language-java">@SpringBootApplication
public class OrderApplication {
​
    public static void main(String[] args) {
        SpringApplication.run(OrderApplication.class,args);
    }
​
}</code></pre> 
<p></p> 
<pre><code class="language-java">application.yml

server:
  port: 9002
#指定服务的名称
spring:
  application:
    name: TINGYI-ORDER</code></pre> 
<pre></pre> 
<p><strong>编写controller</strong></p> 
<pre><code class="language-java">@RestController
public class OrderController {
    @RequestMapping("/query")
    public String query(){
        return "查询订单";
    }
}</code></pre> 
<p><strong>启动并查看效果</strong></p> 
<p><img alt="" height="180" src="https://images2.imgbox.com/76/24/9f9DoFlx_o.png" width="574"></p> 
<h5 id="4.1.4%20%E6%A1%88%E4%BE%8B%E8%B0%83%E6%95%B4">4.1.4 案例调整</h5> 
<p>​ 在查询订单时，同时也需要获取商品的信息，那么我们如何查询商品信息呢？</p> 
<p>​ 我们可以通过spring为我们提供的RestTemplate 模板对象 远程调用商品模块中的 控制器。</p> 
<h6 id="4.1.4.1%20%E5%9C%A8order%E6%A8%A1%E5%9D%97%E5%88%9B%E5%BB%BA%20RestTemplate%E5%AF%B9%E8%B1%A1">4.1.4.1 在order模块创建 RestTemplate对象</h6> 
<pre><code class="language-java">@Configuration
public class RestTemplateConfig {
    @Bean
    public RestTemplate restTemplate(ClientHttpRequestFactory factory) {
        return new RestTemplate(factory);
    }
​
    @Bean
    public ClientHttpRequestFactory simpleClientHttpRequestFactory() {
        SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();
        factory.setReadTimeout(5000);//ms
        factory.setConnectTimeout(15000);//ms
        return factory;
    }
}</code></pre> 
<h6 id="4.1.4.2%20%E4%BF%AE%E6%94%B9OrderController">4.1.4.2 修改OrderController</h6> 
<p><img alt="" height="479" src="https://images2.imgbox.com/80/c9/nX6ew1o0_o.png" width="1135"></p> 
<h6 id="4.1.4.2%20%E9%87%8D%E5%90%AF%E5%B9%B6%E6%B5%8B%E8%AF%95">4.1.4.2 重启并测试</h6> 
<p><img alt="" height="182" src="https://images2.imgbox.com/1b/8d/wTw0UfWU_o.png" width="560"></p> 
<p></p> 
<h4 id="4.2%20%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8eureka">4.2 为什么使用eureka</h4> 
<blockquote> 
 <p>问题分析</p> 
 <p>​ 如果 <code>被调用方</code>，ip或者端口号发生了变化，需要维护<code>调用方</code>的方法。</p> 
 <p>​ 如果<code>调用方</code>搭建了<code>集群</code>，需要对所有的<code>调用方</code>维护。</p> 
 <p>解决</p> 
 <p>​ Eureka就是帮助我们维护所有服务的信息，以便服务之间的相互调用</p> 
</blockquote> 
<table><thead><tr><th>Eureka</th></tr></thead><tbody><tr><td></td></tr></tbody></table> 
<p></p> 
<h4 id="4.2%20Eureka%E5%85%89%E9%80%9F%E5%85%A5%E9%97%A8">4.2 Eureka光速入门</h4> 
<h5 id="4.2.1%20%E5%88%9B%E5%BB%BAEurekaServer">4.2.1 创建EurekaServer</h5> 
<blockquote> 
 <p>创建eureka的server，创建moudle，并且导入依赖，在启动类中添加注解，编写yml文件</p> 
 <p>微服务名字可以叫做 tingyi<code>-eureka</code></p> 
</blockquote> 
<blockquote> 
 <p>导入依赖</p> 
</blockquote> 
<pre><code class="language-java">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
    &lt;/dependency&gt;
​
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre> 
<blockquote> 
 <p>启动类添加注解</p> 
</blockquote> 
<pre><code class="language-java">@SpringBootApplication
@EnableEurekaServer
public class EurekaApplication {
​
    public static void main(String[] args) {
        SpringApplication.run(EurekaApplication.class,args);
    }
​
}</code></pre> 
<blockquote> 
 <p>编写yml配置文件</p> 
</blockquote> 
<pre><code class="language-java">server:
  port: 8761      # 端口号
spring:
  application:
    name: EUREKA-SERVER
eureka:
  instance:
    hostname: localhost   # localhost
  client:
    # 表示是否将自己注册到Eureka Server，默认为true
    registerWithEureka: false
    # 表示是否从Eureka Server获取注册信息，默认为true。
    # 因为这是一个单点的Eureka Server，不需要同步其他的Eureka Server节点的数据，故而设为false
    fetchRegistry: false
    # 设置与Eureka Server交互的地址，查询服务和注册服务都需要依赖这个地址
    serviceUrl:
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/</code></pre> 
<p><strong>启动 eurekaServer并访问</strong></p> 
<p><img alt="" height="728" src="https://images2.imgbox.com/b3/4c/GUMkSmN3_o.png" width="1200"></p> 
<p></p> 
<p></p> 
<h5 id="4.2.2%20%E8%B0%83%E6%95%B4%E5%95%86%E5%93%81%E6%A8%A1%E5%9D%97">4.2.2 调整商品模块</h5> 
<blockquote> 
 <p>导入依赖</p> 
</blockquote> 
<pre><code class="language-java">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
  &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
  &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<blockquote> 
 <p>在启动类上添加注解</p> 
</blockquote> 
<pre><code class="language-java">@SpringBootApplication
@EnableEurekaClient
public class GoodsApplication {
​
    public static void main(String[] args) {
        SpringApplication.run(GoodsApplication.class,args);
    }
​
}</code></pre> 
<blockquote> 
 <p>在配置文件中添加如下代码</p> 
</blockquote> 
<pre><code class="language-java"># 指定Eureka服务地址
eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka
    # Eureka服务中, 显示的当前search业务微服务的访问地址.
  instance:
    home-page-url: http://localhost:${server.port}  </code></pre> 
<pre>  </pre> 
<blockquote> 
 <p>重启服务，浏览器访问地址 : <a href="http://localhost:8761" rel="nofollow" title="http://localhost:8761">http://localhost:8761</a></p> 
</blockquote> 
<p></p> 
<h5 id="4.2.3%20%E8%B0%83%E6%95%B4%E8%AE%A2%E5%8D%95%E6%A8%A1%E5%9D%97">4.2.3 调整订单模块</h5> 
<blockquote> 
 <p>导入依赖</p> 
</blockquote> 
<pre><code class="language-java">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
  &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
  &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<blockquote> 
 <p>在启动类上添加注解</p> 
</blockquote> 
<pre><code class="language-java">@SpringBootApplication
@EnableEurekaClient
public class OrderApplication {
​
    public static void main(String[] args) {
        SpringApplication.run(OrderApplication.class,args);
    }
​
}</code></pre> 
<blockquote> 
 <p>在配置文件中添加如下代码</p> 
</blockquote> 
<pre><code class="language-java"># 指定Eureka服务地址
eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka</code></pre> 
<blockquote> 
 <p>重启服务，浏览器访问地址 : <a href="http://localhost:8761" rel="nofollow" title="http://localhost:8761">http://localhost:8761</a>   浏览器下方就会出现</p> 
</blockquote> 
<p></p> 
<h5 id="4.2.4%20%E8%B0%83%E6%95%B4%E8%AE%A2%E5%8D%95%E6%A8%A1%E5%9D%97%EF%BC%8C%20%E8%B0%83%E7%94%A8%E5%95%86%E5%93%81%E6%A8%A1%E5%9D%97">4.2.4 调整订单模块， 调用商品模块</h5> 
<blockquote> 
 <p>远程调用 订单模块controller</p> 
</blockquote> 
<pre><code class="language-java">@RestController
public class OrderController {
​
    @Autowired
    EurekaClient eurekaClient;
​
    //自动注入RestTemplate对象
    @Autowired
    RestTemplate template;
​
    @RequestMapping("/query")
    public String query(){
        //根据Eureka上注册的服务名称获取实例对象
        InstanceInfo instanceInfo = eurekaClient.getNextServerFromEureka("TINGYI-GOODS", false);
        //获取对应模块的url
        String url = instanceInfo.getHomePageUrl();
        ResponseEntity&lt;String&gt; responseEntity = template.getForEntity(url + "/query", String.class);
​
        //返回结果
        return "查询订单" + "&amp;" + responseEntity.getBody();
    }
}</code></pre> 
<h4 id="4.2.4%20%E6%B5%8B%E8%AF%95">4.2.4 测试</h4> 
<blockquote> 
 <p>与原来效果一致</p> 
</blockquote> 
<p><img alt="" height="190" src="https://images2.imgbox.com/7d/47/Fle8SYZv_o.png" width="737"></p> 
<h4 id="4.3%20Eureka%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7">4.3 Eureka的安全性</h4> 
<blockquote> 
 <p>实现Eureka认证</p> 
</blockquote> 
<blockquote> 
 <p><code>tingyi_eureka</code> 微服务导入依赖</p> 
</blockquote> 
<pre><code class="language-java">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre> 
<blockquote> 
 <p><code>tingyi_eureka</code> 微服务加入配置类:</p> 
</blockquote> 
<pre><code class="language-java">package com.tingyi.config;
​
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
​
/**
 * @author tingyi
 */
@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {
​
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // 忽略掉/eureka/**
        http.csrf().ignoringAntMatchers("/eureka/**");
        super.configure(http);
    }
}</code></pre> 
<blockquote> 
 <p><code>tingyi_eureka</code> 微服务编写配置文件, 加入Eureka的用户名和密码:</p> 
</blockquote> 
<pre><code class="language-java">server:
  port: 8761      # 端口号
spring:
  application:
    name: EUREKA-SERVER
  # 指定Eureka的用户名和密码
  security:
    user:
      name: root
      password: root
eureka:
  instance:
    hostname: localhost   # localhost
  client:
    # 表示是否将自己注册到Eureka Server，默认为true
    registerWithEureka: false
    # 表示是否从Eureka Server获取注册信息，默认为true。
    # 因为这是一个单点的Eureka Server，不需要同步其他的Eureka Server节点的数据，故而设为false
    fetchRegistry: false
    # 设置与Eureka Server交互的地址，查询服务和注册服务都需要依赖这个地址
    serviceUrl:
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/</code></pre> 
<pre>​</pre> 
<blockquote> 
 <p>其他服务想注册到Eureka上需要添加用户名和密码</p> 
</blockquote> 
<pre><code class="language-java">eureka:
  client:
    service-url:
      defaultZone: http://用户名:密码@localhost:8761/eureka</code></pre> 
<p></p> 
<h4 id="4.4%20Eureka%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8">4.4 Eureka的高可用</h4> 
<blockquote> 
 <p>如果程序的正在运行，突然Eureka宕机了。</p> 
 <ul><li> <p>如果调用方访问过一次被调用方了，Eureka的宕机不会影响到功能。</p> </li><li> <p>如果调用方没有访问过被调用方，Eureka的宕机就会造成当前功能不可用。</p> </li></ul> 
</blockquote> 
<blockquote> 
 <p>搭建Eureka高可用</p> 
</blockquote> 
<blockquote> 
 <p>准备多台Eureka</p> 
 <p><a href="" rel="nofollow">采用了复制的方式，删除iml和target文件，并且修改pom.xml中的项目名称，再给父工程添加一个module</a></p> 
</blockquote> 
<p></p> 
<h5 id="4.4.1%20%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81">4.4.1 配置以及代码</h5> 
<blockquote> 
 <p>让服务注册到多台Eureka, 下面是更改tingyi<code>_order</code> 业务微服务配置:</p> 
</blockquote> 
<pre><code class="language-java">server:
  port: 9001
#指定服务的名称
spring:
  application:
    name: tingyi-order
# 指定Eureka服务地址
eureka:
  client:
    service-url:
      defaultZone: http://root:root@EUREKA-SERVER1:8761/eureka,http://root:root@EUREKA-SERVER2:8762/eureka</code></pre> 
<blockquote> 
 <p>让服务注册到多台Eureka, 下面是更改tingyi<code>_goods</code> 业务微服务配置:</p> 
</blockquote> 
<pre><code class="language-java">server:
  port: 9002
#指定服务的名称
spring:
  application:
    name: tingyi-goods
# 指定Eureka服务地址
eureka:
  client:
    service-url:
      defaultZone: http://root:root@EUREKA-SERVER1:8761/eureka,http://root:root@EUREKA-SERVER2:8762/eureka</code></pre> 
<p></p> 
<blockquote> 
 <p>让多台Eureka之间相互通讯, 更改 tingyi<code>_eureka</code> 微服务配置</p> 
</blockquote> 
<pre><code class="language-java">server:
  port: 8761      # 端口号
spring:
  application:
    name: EUREKA-SERVER
  security:
    user:
      name: root
      password: root
eureka:
  instance:
    hostname: localhost   # localhost
  client:
    # 表示是否将自己注册到Eureka Server，默认为true
    registerWithEureka: true
    # 表示是否从Eureka Server获取注册信息，默认为true。
    fetchRegistry: true
    # 设置与Eureka Server交互的地址，查询服务和注册服务都需要依赖这个地址
    serviceUrl:
      defaultZone: http://EUREKA-SERVER1:8761/eureka,http://EUREKA-SERVER2:8762/eureka/
  # Eureka自我保护机制关闭, 当开启自我保护机制开启后，实例不会删除，
  # 导致部分请求会连接不存在的实例，客户端没有做重试或者熔断的话会出大量问题
  server:
    enable-self-preservation: false</code></pre> 
<p>配置域名（只是用来欺骗自己的电脑）</p> 
<p><img alt="" height="266" src="https://images2.imgbox.com/8d/e9/0KK7qOve_o.png" width="384"></p> 
<p>​</p> 
<p><img alt="" height="137" src="https://images2.imgbox.com/ad/a3/bTEzr1C6_o.png" width="397"></p> 
<h5 id="4.4.2%20%E6%B5%8B%E8%AF%95">4.4.2 测试</h5> 
<p><strong>演示Eureka集群</strong></p> 
<ul><li> <p>先将 多个tingyi<code>_eureka</code> 微服务启动</p> </li><li> <p>登录后，可以在任意管理页看到集群信息</p> </li></ul> 
<p><img alt="" height="166" src="https://images2.imgbox.com/12/95/mTybxIyP_o.png" width="620"></p> 
<p>​</p> 
<h5 id="4.4.3%20Eureka%E7%9A%84%E7%BB%86%E8%8A%82">4.4.3 Eureka的细节</h5> 
<blockquote> 
 <p>EurekaClient启动时，将自己的信息注册到EurekaServer上，EurekaSever就会存储上EurekaClient的注册信息。</p> 
</blockquote> 
<blockquote> 
 <p>当EurekaClient调用服务时，本地没有注册信息的缓存时，去EurekaServer中去获取注册信息。</p> 
</blockquote> 
<blockquote> 
 <p>EurekaClient会通过心跳的方式去和EurekaServer进行连接。（<strong>默认30sEurekaClient会发送一次心跳请求，如果超过了90s还没有发送心跳信息的话，EurekaServer就认为你宕机了，将当前EurekaClient从注册表中移除</strong>）</p> 
</blockquote> 
<pre><code class="language-java">eureka:
  instance:
    lease-renewal-interval-in-seconds: 30      #心跳的间隔
    lease-expiration-duration-in-seconds: 90    # 多久没发送，就认为你宕机了</code></pre> 
<blockquote> 
 <p>EurekaClient会每隔30s去EurekaServer中去更新本地的注册表</p> 
</blockquote> 
<pre><code class="language-java">eureka:
  client:
    registry-fetch-interval-seconds: 30 # 每隔多久去更新一下本地的注册表缓存信息</code></pre> 
<blockquote> 
 <p>Eureka的自我保护机制，统计15分钟内，如果一个服务的心跳发送比例低于85%，EurekaServer就会开启自我保护机制</p> 
 <ul><li> <p>不会从EurekaServer中去移除长时间没有收到心跳的服务。</p> </li><li> <p>EurekaServer还是可以正常提供服务的。</p> </li><li> <p>网络比较稳定时，EurekaServer才会开始将自己的信息被其他节点同步过去</p> </li></ul> 
</blockquote> 
<pre><code class="language-java">eureka:
  server:
    enable-self-preservation: true  # 开启自我保护机制, 建议开发阶段设置为false, 不然服务停了, eureka中的信息还在.</code></pre> 
<p></p> 
<blockquote> 
 <p> 🌟感谢支持 <a href="https://blog.csdn.net/weixin_64296810?type=blog" title="听忆.-CSDN博客">听忆.-CSDN博客</a></p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ef/7b/ua76ePod_o.jpg"></p> 
<p></p> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:690px;"><tbody><tr><td style="text-align:center;"><em><strong><span style="color:#ff9900;">🎈众口难调🎈从心就好</span></strong></em></td></tr></tbody></table> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/769018fbed34a7e14fb6b49283dc3a7b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">生成一个完整的购物商城代码跨越多种编程语言会非常复杂，因为每个部分（前端、后端、数据库）通常会使用最适合该任务的特定语言或框架。不过，我可以为你提供一个简化的概述，以及每个部分可能使用的示例代码片段。</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/33714953dfd3260879921a412e78508d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">攻防世界 string</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>