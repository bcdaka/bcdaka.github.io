<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>『C&#43;&#43;成长记』string模拟实现 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/32f89ff661e65f1968b27126925320ed/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="『C&#43;&#43;成长记』string模拟实现">
  <meta property="og:description" content="🔥博客主页：小王又困了
📚系列专栏：C&#43;&#43;
🌟人之为学，不日近则日退
❤️感谢大家点赞👍收藏⭐评论✍️
​
目录
一、存储结构
二、默认成员函数
📒2.1构造函数
📒2.2析构函数
📒2.3拷贝构造
📒2.4赋值重载
三、容量操作
📒3.1获取有效字符长度
📒3.2获取对象空间大小
📒3.3使用reserve扩容
四、字符串的遍历
📒4.1下标访问
📒4.2迭代器访问
五、修改操作
📒5.1尾插字符
📒5.2尾插字符串
📒5.3任意位置插入字符
📒5.4任意位置插入字符串
📒5.5&#43;=重载
六、其他操作
📒6.1删除操作
📒6.2查找操作
📒6.3交换操作
📒6.4获取字符串
📒6.5运算符重载
📒6.6清理字符串
📒6.7流操作
🗒️前言：
在上一篇中我们对string类进行了简单的介绍，介绍了各个接口的作用和使用方法，今天我们将为大家介绍string常用接口的模拟实现。
一、存储结构 string本质上是一个char类型的顺序表，所以结构上和顺序表类似。
namespace bit { class string { public: private: char* _str; size_t _size; size_t _capacity; const static size_t npos; }; } 结构上使用命名空间 bit 进行封装，防止与库冲突,其中：
_str ：指向存放字符串存空间的指针_size ：表示当前所存储的有效字符个数_capacity ：表示当前可存储的最大容量nops：此值设置为 -1，无符号整型转换就是42亿，且此值为const和静态参数具有全局效应，这个值常常被用来当作循环结束判断条件和查找时未找到的标志，某些函数设置其为缺省参数。 nops的初始化：
#include&#34;string.h&#34; namespace bit { const size_t string::nops = -1; } 小Tips：我们使用声明与定义分离实现，nops只能在CPP文件中定义，因为类里面的静态成员变量相当于全局变量，在.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-08T09:29:35+08:00">
    <meta property="article:modified_time" content="2024-07-08T09:29:35+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">『C&#43;&#43;成长记』string模拟实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b5/95/5PKUHdoZ_o.gif"></p> 
<p style="text-align:center;">🔥<strong><span style="color:#38d8f0;">博客主页：</span><a class="link-info" href="https://blog.csdn.net/2301_76207836?spm=1010.2135.3001.5343" title="小王又困了"><span style="color:#956fe7;">小王又困了</span></a></strong></p> 
<p style="text-align:center;">📚<span style="color:#ff9900;"><strong>系列专栏：<a class="link-info" href="https://blog.csdn.net/2301_76207836/category_12387505.html?spm=1001.2014.3001.5482" title="C++"><span style="color:#a2e043;">C++</span></a></strong></span></p> 
<p style="text-align:center;"><span style="color:#fe2c24;">🌟<strong>人之为学，不日近则日退</strong></span></p> 
<p style="text-align:center;"><span style="color:#ad720d;"><strong>❤️感谢大家点赞👍收藏⭐评论✍️</strong></span></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/36/03/QzrU6dRc_o.gif"><span title="点击并拖拽以改变尺寸">​</span></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84" rel="nofollow">一、存储结构</a></p> 
<p id="%E4%BA%8C%E3%80%81%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0" rel="nofollow">二、默认成员函数</a></p> 
<p id="%F0%9F%93%922.1%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%F0%9F%93%922.1%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" rel="nofollow">📒2.1构造函数</a></p> 
<p id="%F0%9F%93%922.2%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%F0%9F%93%922.2%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0" rel="nofollow">📒2.2析构函数</a></p> 
<p id="%F0%9F%93%922.3%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0-toc" style="margin-left:40px;"><a href="#%F0%9F%93%922.3%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0" rel="nofollow">📒2.3拷贝构造</a></p> 
<p id="%F0%9F%93%922.4%E8%B5%8B%E5%80%BC%E9%87%8D%E8%BD%BD-toc" style="margin-left:40px;"><a href="#%F0%9F%93%922.4%E8%B5%8B%E5%80%BC%E9%87%8D%E8%BD%BD" rel="nofollow">📒2.4赋值重载</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%AE%B9%E9%87%8F%E6%93%8D%E4%BD%9C-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%AE%B9%E9%87%8F%E6%93%8D%E4%BD%9C" rel="nofollow">三、容量操作</a></p> 
<p id="%F0%9F%93%923.1%E8%8E%B7%E5%8F%96%E6%9C%89%E6%95%88%E5%AD%97%E7%AC%A6%E9%95%BF%E5%BA%A6-toc" style="margin-left:40px;"><a href="#%F0%9F%93%923.1%E8%8E%B7%E5%8F%96%E6%9C%89%E6%95%88%E5%AD%97%E7%AC%A6%E9%95%BF%E5%BA%A6" rel="nofollow">📒3.1获取有效字符长度</a></p> 
<p id="%F0%9F%93%923.2%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F-toc" style="margin-left:40px;"><a href="#%F0%9F%93%923.2%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F" rel="nofollow">📒3.2获取对象空间大小</a></p> 
<p id="%F0%9F%93%923.3%E4%BD%BF%E7%94%A8reserve%E6%89%A9%E5%AE%B9-toc" style="margin-left:40px;"><a href="#%F0%9F%93%923.3%E4%BD%BF%E7%94%A8reserve%E6%89%A9%E5%AE%B9" rel="nofollow">📒3.3使用reserve扩容</a></p> 
<p id="%E5%9B%9B%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%81%8D%E5%8E%86-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%81%8D%E5%8E%86" rel="nofollow">四、字符串的遍历</a></p> 
<p id="%F0%9F%93%924.1%E4%B8%8B%E6%A0%87%E8%AE%BF%E9%97%AE-toc" style="margin-left:40px;"><a href="#%F0%9F%93%924.1%E4%B8%8B%E6%A0%87%E8%AE%BF%E9%97%AE" rel="nofollow">📒4.1下标访问</a></p> 
<p id="%F0%9F%93%924.2%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BF%E9%97%AE-toc" style="margin-left:40px;"><a href="#%F0%9F%93%924.2%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BF%E9%97%AE" rel="nofollow">📒4.2迭代器访问</a></p> 
<p id="%E4%BA%94%E3%80%81%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C" rel="nofollow">五、修改操作</a></p> 
<p id="%F0%9F%93%925.1%E5%B0%BE%E6%8F%92%E5%AD%97%E7%AC%A6-toc" style="margin-left:40px;"><a href="#%F0%9F%93%925.1%E5%B0%BE%E6%8F%92%E5%AD%97%E7%AC%A6" rel="nofollow">📒5.1尾插字符</a></p> 
<p id="%F0%9F%93%925.2%E5%B0%BE%E6%8F%92%E5%AD%97%E7%AC%A6%E4%B8%B2-toc" style="margin-left:40px;"><a href="#%F0%9F%93%925.2%E5%B0%BE%E6%8F%92%E5%AD%97%E7%AC%A6%E4%B8%B2" rel="nofollow">📒5.2尾插字符串</a></p> 
<p id="%F0%9F%93%925.3%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%E5%AD%97%E7%AC%A6-toc" style="margin-left:40px;"><a href="#%F0%9F%93%925.3%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%E5%AD%97%E7%AC%A6" rel="nofollow">📒5.3任意位置插入字符</a></p> 
<p id="%F0%9F%93%925.4%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2-toc" style="margin-left:40px;"><a href="#%F0%9F%93%925.4%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2" rel="nofollow">📒5.4任意位置插入字符串</a></p> 
<p id="%F0%9F%93%925.5%2B%3D%E9%87%8D%E8%BD%BD-toc" style="margin-left:40px;"><a href="#%F0%9F%93%925.5%2B%3D%E9%87%8D%E8%BD%BD" rel="nofollow">📒5.5+=重载</a></p> 
<p id="%E5%85%AD%E3%80%81%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C" rel="nofollow">六、其他操作</a></p> 
<p id="%F0%9F%93%926.1%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#%F0%9F%93%926.1%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C" rel="nofollow">📒6.1删除操作</a></p> 
<p id="%F0%9F%93%926.2%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#%F0%9F%93%926.2%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C" rel="nofollow">📒6.2查找操作</a></p> 
<p id="%F0%9F%93%926.3%E4%BA%A4%E6%8D%A2%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#%F0%9F%93%926.3%E4%BA%A4%E6%8D%A2%E6%93%8D%E4%BD%9C" rel="nofollow">📒6.3交换操作</a></p> 
<p id="%F0%9F%93%926.4%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2-toc" style="margin-left:40px;"><a href="#%F0%9F%93%926.4%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2" rel="nofollow">📒6.4获取字符串</a></p> 
<p id="%F0%9F%93%926.5%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc" style="margin-left:40px;"><a href="#%F0%9F%93%926.5%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD" rel="nofollow">📒6.5运算符重载</a></p> 
<p id="%F0%9F%93%926.6%E6%B8%85%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2-toc" style="margin-left:40px;"><a href="#%F0%9F%93%926.6%E6%B8%85%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2" rel="nofollow">📒6.6清理字符串</a></p> 
<p id="%F0%9F%93%926.7%E6%B5%81%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#%F0%9F%93%926.7%E6%B5%81%E6%93%8D%E4%BD%9C" rel="nofollow">📒6.7流操作</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p><span style="color:#0d0016;">🗒️前言：</span></p> 
<blockquote> 
 <p><span style="color:#0d0016;">在上一篇中我们对string类进行了简单的介绍，介绍了各个接口的作用和使用方法，今天我们将为大家介绍string常用接口的模拟实现。</span></p> 
</blockquote> 
<h2 id="%E4%B8%80%E3%80%81%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span style="color:#e6b223;">一、存储结构</span></h2> 
<p><span style="color:#0d0016;">        string本质上是一个char类型的顺序表，所以结构上和顺序表类似。</span></p> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-keyword">namespace</span> bit
{
    <span class="hljs-keyword">class</span> <span class="class_ hljs-title">string</span>
    {
    <span class="hljs-keyword">public</span>:

    <span class="hljs-keyword">private</span>:
        <span class="hljs-type">char</span>* _str;
        <span class="hljs-type">size_t</span> _size;
        <span class="hljs-type">size_t</span> _capacity;

        <span class="hljs-type">const</span> <span class="hljs-type">static</span> <span class="hljs-type">size_t</span> npos;
    };
}</code></pre> 
</div> 
<p><span style="color:#0d0016;">结构上使用命名空间</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;"> bit </span></span><span style="color:#0d0016;">进行封装，防止与库冲突,其中：</span></p> 
<ul><li><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">_str </span></span><span style="color:#0d0016;">：指向存放字符串存空间的指针</span></li><li><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">_size </span></span><span style="color:#0d0016;">：表示当前所存储的有效字符个数</span></li><li><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">_capacity </span></span><span style="color:#0d0016;">：表示当前可存储的最大容量</span></li><li><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">nops</span></span><span style="color:#0d0016;">：此值设置为 -1，无符号整型转换就是42亿，且此值为const和静态参数具有全局效应，这个值常常被用来当作循环结束判断条件和查找时未找到的标志，某些函数设置其为缺省参数。</span></li></ul> 
<blockquote> 
 <p><span style="color:#0d0016;">nops的初始化：</span></p> 
 <div> 
  <pre><code class="language-cpp hljs"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">"string.h"</span></span>

<span class="hljs-keyword">namespace</span> bit
{
	 <span class="hljs-type">const</span>  <span class="hljs-type">size_t</span> string::nops = <span class="hljs-number">-1</span>;
}</code></pre> 
 </div> 
 <p><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">小Tips</span></span><span style="color:#0d0016;">：我们使用声明与定义分离实现，</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">nops</span></span><span style="color:#0d0016;">只能在</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">CPP</span></span><span style="color:#0d0016;">文件中定义，因为类里面的静态成员变量相当于全局变量，在</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">.h</span></span><span style="color:#0d0016;">文件中定义会出现链接错误。我们还要通过</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">类名::成员(函数/变量) </span></span><span style="color:#0d0016;">定义和实现函数！</span></p> 
 <p><img alt="" height="191" src="https://images2.imgbox.com/82/8c/8HclOqvg_o.png" width="855"><span title="点击并拖拽以改变尺寸">​</span></p> 
</blockquote> 
<h2 id="%E4%BA%8C%E3%80%81%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span style="color:#e6b223;">二、默认成员函数</span></h2> 
<h3 id="%F0%9F%93%922.1%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span style="color:#0d0016;">📒2.1构造函数</span></h3> 
<div> 
 <pre><code class="language-cpp hljs">string.<span class="hljs-function">h
<span class="hljs-title">string</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str = <span class="hljs-string">""</span>)</span></span>;  <span class="hljs-comment">//给缺省值 构造空串</span>

string.<span class="hljs-function">cpp
<span class="hljs-title">string::string</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str)</span>
    :_size(strlen(str))
{<!-- --></span>
    _str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[_size + <span class="hljs-number">1</span>];
    _capacity = _size;
    <span class="hljs-built_in">strcpy</span>(_str, str);
}</code></pre> 
</div> 
<blockquote> 
 <p><span style="color:#0d0016;">构造函数的思路：</span></p> 
 <ul><li><span style="color:#0d0016;">构造函数可以接收字符串，如果没有参数，默认构造一个空串</span></li><li><span style="color:#0d0016;">通过</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">strlen</span></span><span style="color:#0d0016;">先计算出字符串的长度，并通过初始化列表初始化</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">_size</span></span></li><li><span style="color:#0d0016;">使用</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">new</span></span><span style="color:#0d0016;">开辟空间，这里我们要多开一个空间存放</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">‘\0’</span></span></li><li><span style="color:#0d0016;">最终将字符串中的字符拷贝到我们所开的空间中</span></li></ul> 
 <p><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">小Tips</span></span><span style="color:#0d0016;">：因为</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">_size</span></span><span style="color:#0d0016;">的大小没有包含</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">‘\0’</span></span><span style="color:#0d0016;">，所以我们要多开辟一个空间。</span></p> 
</blockquote> 
<h3 id="%F0%9F%93%922.2%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span style="color:#0d0016;">📒2.2析构函数</span></h3> 
<p><span style="color:#0d0016;">        我们开辟内存是使用</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;"> new[ ] </span></span><span style="color:#0d0016;">申请的，所以对应使用</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;"> delete[ ]</span></span><span style="color:#0d0016;">释放</span>。</p> 
<div> 
 <pre><code class="language-cpp hljs">string::~<span class="hljs-built_in">string</span>()
{
    <span class="hljs-keyword">delete</span>[] _str;
    _str = <span class="hljs-literal">nullptr</span>;
    _size = _capacity = <span class="hljs-number">0</span>;
}</code></pre> 
</div> 
<h3 id="%F0%9F%93%922.3%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0"><span style="color:#0d0016;">📒2.3拷贝构造</span></h3> 
<p><span style="color:#0d0016;">        拷贝构造函数，如果我们不写，编译器会默认生成一个，<strong>但是默认生成的拷贝构造函数只支持浅拷贝，新构造的对象只是拷贝了_str的指针地址，两个对象都指向同一块空间，最终两个对象析构时释放同一片空间的资源势必会导致程序崩溃</strong>！</span></p> 
<p><img alt="" height="465" src="https://images2.imgbox.com/94/13/sycG2JLl_o.jpg" width="1200"><span title="点击并拖拽以改变尺寸">​</span></p> 
<p><span style="color:#0d0016;">我们需要新构造的对象通过拷贝构造开辟一片新的空间将数据复制过去，也就是深拷贝，需要我们自己写一个拷贝构造。</span></p> 
<blockquote> 
 <p><span style="color:#0d0016;"> 🌟传统写法：</span></p> 
 <div> 
  <pre><code class="language-cpp hljs">string::<span class="hljs-built_in">string</span>(<span class="hljs-type">const</span> string&amp; s)
{
    _str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[s._size + <span class="hljs-number">1</span>];
    <span class="hljs-built_in">strcpy</span>(_str, s._str);
    _size = s._size;
    _capacity = s._capacity;
}</code></pre> 
 </div> 
</blockquote> 
<blockquote> 
 <p><span style="color:#0d0016;"> 🌟现代写法：</span></p> 
 <div> 
  <pre><code class="language-cpp hljs">string::<span class="hljs-built_in">string</span>(<span class="hljs-type">const</span> string&amp; s)
{
    <span class="hljs-function">string <span class="hljs-title">tmp</span><span class="hljs-params">(s._str)</span></span>;
    <span class="hljs-built_in">swap</span>(tmp);
}
<span class="hljs-comment">//string s2(s1);</span></code></pre> 
 </div> 
 <p> <span style="color:#0d0016;">通过复用构造函数，构造出tmp对象，在将两个对象进行交换，就可以实现拷贝构造。</span></p> 
</blockquote> 
<h3 id="%F0%9F%93%922.4%E8%B5%8B%E5%80%BC%E9%87%8D%E8%BD%BD"><span style="color:#0d0016;">📒2.4赋值重载</span></h3> 
<p><span style="color:#0d0016;">        赋值重载需要注意自己给自己赋值这种冗余的行为，同时也要控制空间大小</span></p> 
<blockquote> 
 <p> <span style="color:#0d0016;"> 🌟传统写法：</span></p> 
 <div> 
  <pre><code class="language-cpp hljs">string&amp; string::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> string&amp; s)
{
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> != &amp;s)
    {
        <span class="hljs-type">char</span>* tmp = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[s._size + <span class="hljs-number">1</span>];
        <span class="hljs-built_in">strcpy</span>(tmp, s._str);
        <span class="hljs-keyword">delete</span>[] _str;
        _str = tmp;
        _size = s._size;
        _capacity = s._capacity;
    }
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}</code></pre> 
 </div> 
</blockquote> 
<blockquote> 
 <p><span style="color:#0d0016;"> 🌟现代写法：</span></p> 
 <div> 
  <pre><code class="language-cpp hljs">string&amp; string::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> string&amp; s)
{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;s)
    {
        string <span class="hljs-built_in">tmp</span>(s._str);
        <span class="hljs-built_in">swap</span>(tmp);
    }
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}

string&amp; string::<span class="hljs-keyword">operator</span>=(string tmp)
{
    <span class="hljs-built_in">swap</span>(tmp);
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;   
}</code></pre> 
 </div> 
</blockquote> 
<h2 id="%E4%B8%89%E3%80%81%E5%AE%B9%E9%87%8F%E6%93%8D%E4%BD%9C"><span style="color:#e6b223;">三、容量操作</span></h2> 
<h3 id="%F0%9F%93%923.1%E8%8E%B7%E5%8F%96%E6%9C%89%E6%95%88%E5%AD%97%E7%AC%A6%E9%95%BF%E5%BA%A6"><span style="color:#0d0016;">📒3.1获取有效字符长度</span></h3> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">string::size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>
</span>{
    <span class="hljs-keyword">return</span> _size;
}
</code></pre> 
</div> 
<p><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">小Tips</span></span><span style="color:#0d0016;">：</span></p> 
<ul><li><span style="color:#0d0016;">这个函数比较小，可以写在类中形成内联函数。 </span></li><li><span style="color:#0d0016;">对于不涉及对字符串的增删查改的函数，<strong>使用</strong></span><span style="color:#fe2c24;"><strong><span style="background-color:#fbd4d0;">const</span></strong></span><span style="color:#0d0016;"><strong>修饰</strong></span><span style="color:#fe2c24;"><strong><span style="background-color:#fbd4d0;">this</span></strong></span><span style="color:#0d0016;"><strong>增强安全性。</strong></span></li></ul> 
<h3 id="%F0%9F%93%923.2%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F"><span style="color:#0d0016;">📒3.2获取对象空间大小</span></h3> 
<p>    <span style="color:#0d0016;">    与</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">size</span></span><span style="color:#0d0016;">函数规则一致。</span></p> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">string::capacity</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>
</span>{
    <span class="hljs-keyword">return</span> _capacity;
}
</code></pre> 
</div> 
<h3 id="%F0%9F%93%923.3%E4%BD%BF%E7%94%A8reserve%E6%89%A9%E5%AE%B9"><span style="color:#0d0016;">📒3.3使用reserve扩容</span></h3> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">string::reserve</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n)</span>
</span>{
    <span class="hljs-type">char</span>* tmp = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n + <span class="hljs-number">1</span>];
    <span class="hljs-built_in">strcpy</span>(tmp, _str);    <span class="hljs-comment">//将原字符串的数据拷贝到新空间上</span>
    <span class="hljs-keyword">delete</span>[] _str;        <span class="hljs-comment">//释放原字符串的空间</span>
    _str = tmp;
    _capacity = n;
}</code></pre> 
</div> 
<h2 id="%E5%9B%9B%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%81%8D%E5%8E%86"><span style="color:#e6b223;">四、字符串的遍历</span></h2> 
<h3 id="%F0%9F%93%924.1%E4%B8%8B%E6%A0%87%E8%AE%BF%E9%97%AE"><span style="color:#0d0016;">📒4.1下标访问</span></h3> 
<p><span style="color:#0d0016;">        下标访问是通过重载</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;"> [ ] </span></span><span style="color:#0d0016;">运算符实现的，在下标pos正确的情况下，返回当前下标字符的引用，否则assert报错。</span></p> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-type">char</span>&amp; string::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> pos)
{
    <span class="hljs-built_in">assert</span>(pos &lt; _size);
    <span class="hljs-keyword">return</span> _str[pos];
}</code></pre> 
</div> 
<h3 id="%F0%9F%93%924.2%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BF%E9%97%AE"><span style="color:#0d0016;">📒4.2迭代器访问</span></h3> 
<p>        <span style="color:#0d0016;">现在我们可以简单认为迭代器是指针对象，就是对指针的封装。</span></p> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-comment">//迭代器的声明</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span>* iterator;
<span class="hljs-keyword">typedef</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* const_iterator;  <span class="hljs-comment">//对数据无法修改</span></code></pre> 
</div> 
<p><span style="color:#0d0016;">迭代器的</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">begin</span></span><span style="color:#0d0016;">返回字符串的地址，</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">end</span></span><span style="color:#0d0016;">返回字符串末端的下一个即</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">‘\0’</span></span><span style="color:#0d0016;">。</span></p> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-function">string::iterator <span class="hljs-title">string::begin</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">return</span> _str;
}

<span class="hljs-function">string::iterator <span class="hljs-title">string::end</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">return</span> _str + _size;
}

<span class="hljs-function">string::const_iterator <span class="hljs-title">string::begin</span><span class="hljs-params">()</span><span class="hljs-type">const</span>
</span>{
    <span class="hljs-keyword">return</span> _str;
}

<span class="hljs-function">string::const_iterator <span class="hljs-title">string::end</span><span class="hljs-params">()</span><span class="hljs-type">const</span>
</span>{
    <span class="hljs-keyword">return</span> _str + _size;
}
</code></pre> 
</div> 
<h2 id="%E4%BA%94%E3%80%81%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C"><span style="color:#e6b223;">五、修改操作</span></h2> 
<h3 id="%F0%9F%93%925.1%E5%B0%BE%E6%8F%92%E5%AD%97%E7%AC%A6"><span style="color:#0d0016;">📒5.1尾插字符</span></h3> 
<p>     <span style="color:#0d0016;">   在插入字符前，先要判断是否需要扩容。</span></p> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">string::push_back</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span>
</span>{
    <span class="hljs-keyword">if</span> (_size == _capacity)
    {
        <span class="hljs-type">size_t</span> newcapacity = _capacity == <span class="hljs-number">0</span> ? <span class="hljs-number">4</span>: _capacity * <span class="hljs-number">2</span>;
        <span class="hljs-built_in">reserve</span>(newcapacity);
    }
    _str[_size] = ch;
    _str[_size + <span class="hljs-number">1</span>] = <span class="hljs-string">'\0'</span>;
    _size++;
}</code></pre> 
</div> 
<h3 id="%F0%9F%93%925.2%E5%B0%BE%E6%8F%92%E5%AD%97%E7%AC%A6%E4%B8%B2"><span style="color:#0d0016;">📒5.2尾插字符串</span></h3> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">string::append</span><span class="hljs-params">(<span class="hljs-type">char</span>* s)</span>
</span>{
    <span class="hljs-type">size_t</span> len = <span class="hljs-built_in">strlen</span>(s);
    <span class="hljs-keyword">if</span> (_size +len &gt; _capacity)
    {
        <span class="hljs-built_in">reserve</span>(_size + len);
    }
    <span class="hljs-built_in">strcpy</span>(_str + _size, s);
    _size += len;
}</code></pre> 
</div> 
<h3 id="%F0%9F%93%925.3%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%E5%AD%97%E7%AC%A6"><span style="color:#0d0016;"><strong>📒5.3任意位置插入字符</strong></span></h3> 
<p><span style="color:#0d0016;">        我们要考虑头插的位置，</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">end</span></span><span style="color:#0d0016;">和</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">pos</span></span><span style="color:#0d0016;">的类型都是</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">size_t</span></span><span style="color:#0d0016;">，代码会陷入死循环，这里我们提供两种解决方法。</span></p> 
<blockquote> 
 <p><span style="color:#0d0016;">🌟方法一：</span></p> 
 <p><span style="color:#0d0016;">        将</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">end</span></span><span style="color:#0d0016;">的类型定为</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">int</span></span><span style="color:#0d0016;">，同时将</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">pos</span></span><span style="color:#0d0016;">强转为</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">int</span></span><span style="color:#0d0016;">型。</span></p> 
 <div> 
  <pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">string::insert</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos, <span class="hljs-type">char</span> ch)</span>
</span>{
    <span class="hljs-built_in">assert</span>(pos &lt;= _size);
		
    <span class="hljs-keyword">if</span> (_size == _capacity)
    {
        <span class="hljs-type">size_t</span> newcapacity = _capacity == <span class="hljs-number">0</span> ? <span class="hljs-number">4</span> : _capacity * <span class="hljs-number">2</span>;
        <span class="hljs-built_in">reserve</span>(newcapacity);
    }

    <span class="hljs-type">int</span> end = _size;
    <span class="hljs-keyword">while</span> (end &gt;= (<span class="hljs-type">int</span>)pos)
    {
        _str[end + <span class="hljs-number">1</span>] = _str[end];
        --end;
    }
    _str[pos] = ch;
    ++_size;
}</code></pre> 
 </div> 
 <p><img alt="" height="500" src="https://images2.imgbox.com/07/ee/ywpqNJeK_o.jpg" width="594"><span title="点击并拖拽以改变尺寸">​</span></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#0d0016;"> 🌟方法二：</span></p> 
 <p><span style="color:#0d0016;">        将</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">end</span></span><span style="color:#0d0016;">定位到</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">‘\0’</span></span><span style="color:#0d0016;">的下一位。</span></p> 
 <div> 
  <pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">string::insert</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos, <span class="hljs-type">char</span> ch)</span>
</span>{
    <span class="hljs-built_in">assert</span>(pos &lt;= _size);
	
    <span class="hljs-keyword">if</span> (_size == _capacity)
    {
        <span class="hljs-type">size_t</span> newcapacity = _capacity == <span class="hljs-number">0</span> ? <span class="hljs-number">4</span> : _capacity * <span class="hljs-number">2</span>;
        <span class="hljs-built_in">reserve</span>(newcapacity);
    }

    <span class="hljs-type">size_t</span> end = _size + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (end &gt; pos)
    {
        _str[end] = _str[end - <span class="hljs-number">1</span>];
        --end;
    }
    _str[pos] = ch;
    ++_size;
}</code></pre> 
 </div> 
 <p><img alt="" height="500" src="https://images2.imgbox.com/84/9b/0aCXQ6iE_o.jpg" width="585"><span title="点击并拖拽以改变尺寸">​</span></p> 
</blockquote> 
<p><span style="color:#0d0016;">我们可以通过复用来实现尾插</span></p> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">string::push_back</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span>
</span>{
    <span class="hljs-built_in">insert</span>(_size, ch);
}</code></pre> 
</div> 
<h3 id="%F0%9F%93%925.4%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2"><span style="color:#0d0016;">📒5.4任意位置插入字符串</span></h3> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">string::insert</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* s)</span>
</span>{
    <span class="hljs-built_in">assert</span>(pos &lt;= _size);
    <span class="hljs-type">size_t</span> len = <span class="hljs-built_in">strlen</span>(s);
    <span class="hljs-keyword">if</span> (_size + len &gt; _capacity)
    {
        <span class="hljs-built_in">reserve</span>(_size + len);
    }
    <span class="hljs-comment">//方法一：</span>
    <span class="hljs-comment">//int end = _size;</span>
    <span class="hljs-comment">//while (end &gt;= (int)pos )</span>
    <span class="hljs-comment">//{<!-- --></span>
    <span class="hljs-comment">//    _str[end + len] = _str[end];</span>
    <span class="hljs-comment">//    --end;</span>
    <span class="hljs-comment">//}</span>
    
    <span class="hljs-comment">//方法二：</span>
    <span class="hljs-type">size_t</span> end = _size+len;
    <span class="hljs-keyword">while</span> (end &gt; pos+len<span class="hljs-number">-1</span>)
    {
        _str[end] = _str[end - len];
        --end;
    }		
    <span class="hljs-built_in">memcpy</span>(_str + pos, s, len);
    _size += len;
}</code></pre> 
</div> 
<p><span style="color:#0d0016;">我们也可以通过复用来实现尾插字符串</span></p> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">string::append</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str)</span>
</span>{
    <span class="hljs-built_in">insert</span>(_size, str);
}</code></pre> 
</div> 
<h3 id="%F0%9F%93%925.5%2B%3D%E9%87%8D%E8%BD%BD"><span style="color:#0d0016;">📒5.5+=重载</span></h3> 
<p>       <span style="color:#0d0016;"> </span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">+=</span></span><span style="color:#0d0016;">运算符可以在当前字符串尾部追加字符或字符串，我们可以通过复用</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">push_back</span></span><span style="color:#0d0016;">和</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">append</span></span><span style="color:#0d0016;">函数来实现。</span></p> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-comment">//追加字符</span>
string&amp; string::<span class="hljs-keyword">operator</span>+=(<span class="hljs-type">char</span> ch)
{
    <span class="hljs-built_in">push_back</span>(ch);
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}

<span class="hljs-comment">//追加字符串</span>
string&amp; string::<span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str)
{
    <span class="hljs-built_in">append</span>(str);
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}</code></pre> 
</div> 
<h2 id="%E5%85%AD%E3%80%81%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C"><span style="color:#e6b223;">六、其他操作</span></h2> 
<h3 id="%F0%9F%93%926.1%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span style="color:#0d0016;">📒6.1删除操作</span></h3> 
<p><span style="color:#0d0016;">        </span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">erase</span></span><span style="color:#0d0016;">从</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">pos</span></span><span style="color:#0d0016;">下标开始删除</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">len</span></span><span style="color:#0d0016;">个字符，其中</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">len</span></span><span style="color:#0d0016;">是一个缺省参数，默认是</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">npos</span></span><span style="color:#0d0016;">。<strong>如果没有传值或</strong></span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">len</span></span><span style="color:#0d0016;"><strong>超过从</strong></span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">pos</span></span><span style="color:#0d0016;"><strong>位置开始到字符串尾部的字符个数则默认从</strong></span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">pos</span></span><span style="color:#0d0016;"><strong>位置开始删除后面的所有字符</strong>，且不允许在空串的情况下进行删除！</span></p> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">string::erase</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos, <span class="hljs-type">size_t</span> len)</span>
</span>{
    <span class="hljs-built_in">assert</span>(pos &lt; _size);
    <span class="hljs-keyword">if</span> (len &gt;= _size - pos)
    {
        _str[pos] = <span class="hljs-string">'\0'</span>;
        _size = pos;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-built_in">strcpy</span>(_str + pos, _str + pos + len);
        _size -= len;
    }
}</code></pre> 
</div> 
<h3 id="%F0%9F%93%926.2%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C"><span style="color:#0d0016;"><strong>📒6.2查找操作</strong></span></h3> 
<p><span style="color:#0d0016;"><strong>   </strong>     查找函数是</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">find</span></span><span style="color:#0d0016;">，是从</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">pos</span></span><span style="color:#0d0016;">位置开始查找，可以查找一个字符或一个子串，查找到后字符返回下标，字符串返回首字符的地址，如果有多个重复的字符或字符串，返回查找到的第一个字符的下标或字符串首的下标；如果没找到则返回</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">npos</span></span><span style="color:#0d0016;">。</span></p> 
<blockquote> 
 <p><span style="color:#0d0016;">🌟查找一个字符：</span></p> 
 <div> 
  <pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">string::find</span><span class="hljs-params">(<span class="hljs-type">char</span> ch, <span class="hljs-type">size_t</span> pos)</span>
</span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = pos; i &lt; _size; i++)
    {
        <span class="hljs-keyword">if</span> (_str[i] == ch)
        <span class="hljs-keyword">return</span> i;
    }
    <span class="hljs-keyword">return</span> npos;
}</code></pre> 
 </div> 
</blockquote> 
<blockquote> 
 <p><span style="color:#0d0016;">🌟查找一个子串</span></p> 
 <div> 
  <pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">string::find</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str, <span class="hljs-type">size_t</span> pos )</span>
</span>{
    <span class="hljs-type">char</span>* p = <span class="hljs-built_in">strstr</span>(_str + pos, str);
    <span class="hljs-keyword">return</span>  p - _str;
}</code></pre> 
 </div> 
</blockquote> 
<h3 id="%F0%9F%93%926.3%E4%BA%A4%E6%8D%A2%E6%93%8D%E4%BD%9C"><span style="color:#0d0016;"><strong>📒</strong>6.3交换操作</span></h3> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">string::swap</span><span class="hljs-params">(string&amp; s)</span>
</span>{
    std::<span class="hljs-built_in">swap</span>(_str, s._str);
    std::<span class="hljs-built_in">swap</span>(_size, s._size);
    std::<span class="hljs-built_in">swap</span>(_capaicty, s._capaicty);
}
</code></pre> 
</div> 
<h3 id="%F0%9F%93%926.4%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2"><span style="color:#0d0016;"><strong>📒</strong>6.4获取字符串</span></h3> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-function">string <span class="hljs-title">string::substr</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos, <span class="hljs-type">size_t</span> len)</span>
</span>{
    <span class="hljs-built_in">assert</span>(pos &lt; _size);
    <span class="hljs-keyword">if</span> (len &gt; _size - pos)
    {
        <span class="hljs-function">string <span class="hljs-title">sub</span><span class="hljs-params">(_str + pos)</span></span>;
        <span class="hljs-keyword">return</span> sub;
    }
    <span class="hljs-keyword">else</span>
    {
        string sub;
        sub.<span class="hljs-built_in">reserve</span>(len);
        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)
        {
            sub += _str[pos + i];
        }
        <span class="hljs-keyword">return</span> sub;
    }
}</code></pre> 
</div> 
<h3 id="%F0%9F%93%926.5%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span style="color:#0d0016;"><strong>📒</strong>6.5运算符重载</span></h3> 
<p><span style="color:#0d0016;">        逻辑判断运算符只需要实现两个，其余的通过复用就可以全部实现。</span> </p> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-type">bool</span> string::<span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> string&amp; s) <span class="hljs-type">const</span>
{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(_str, s._str) &lt; <span class="hljs-number">0</span>;
}

<span class="hljs-type">bool</span> string::<span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> string&amp; s) <span class="hljs-type">const</span>
{
    <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> &lt;= s);
}

<span class="hljs-type">bool</span> string::<span class="hljs-keyword">operator</span>&lt;=(<span class="hljs-type">const</span> string&amp; s) <span class="hljs-type">const</span>
{
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span> &lt; s || *<span class="hljs-keyword">this</span> == s;
}

<span class="hljs-type">bool</span> string::<span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-type">const</span> string&amp; s) <span class="hljs-type">const</span>
{
    <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> &lt; s);
}

<span class="hljs-type">bool</span> string::<span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> string&amp; s) <span class="hljs-type">const</span>
{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(_str, s._str) == <span class="hljs-number">0</span>;
}

<span class="hljs-type">bool</span> string::<span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> string&amp; s) <span class="hljs-type">const</span>
{
    <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == s);
}</code></pre> 
</div> 
<h3 id="%F0%9F%93%926.6%E6%B8%85%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2"><span style="color:#0d0016;"><strong>📒6.6清理字符串</strong></span></h3> 
<p><span style="color:#0d0016;">        </span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">clear</span></span><span style="color:#0d0016;">函数支持清空一个字符串，但不是释放对象，区别于析构函数。</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">clear</span></span><span style="color:#0d0016;">函数清理字符串并不会引起缩容，只是在下标0位置置为</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;"> \0 </span></span><span style="color:#0d0016;">，</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">_size</span></span><span style="color:#0d0016;">置为0即可。</span></p> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">string::clear</span><span class="hljs-params">()</span>
</span>{
    _str[<span class="hljs-number">0</span>] = <span class="hljs-string">'\0'</span>;
    _size = <span class="hljs-number">0</span>;
}</code></pre> 
</div> 
<h3 id="%F0%9F%93%926.7%E6%B5%81%E6%93%8D%E4%BD%9C"><span style="color:#0d0016;"><strong>📒</strong>6.7流操作</span></h3> 
<p><span style="color:#0d0016;">        流操作属于</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">iostream</span></span><span style="color:#0d0016;">中的对象，所以不需要定义在类中作为成员函数，也不需要声明为友元，因为使用流体去和流插入需要</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">ostream</span></span><span style="color:#0d0016;">和</span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">istream</span></span><span style="color:#0d0016;">对象作为左操作参数。</span></p> 
<blockquote> 
 <p><span style="color:#0d0016;">🌟流插入</span></p> 
 <div> 
  <pre><code class="hljs language-cpp">ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt; (ostream&amp; os, <span class="hljs-type">const</span> string&amp; str)
{
    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++)
    {
        os &lt;&lt; str[i];
    }
    <span class="hljs-keyword">return</span> os;
}
</code></pre> 
 </div> 
</blockquote> 
<blockquote> 
 <p><span style="color:#0d0016;">🌟流提取</span></p> 
 <pre><code class="language-cpp">istream&amp; Mystring::operator&gt;&gt;(istream&amp; in, string&amp; s)
{
    s.clear(); 
    char buff[256] = {0}; 
    char ch = in.get(); 
    size_t sub = 0; 
	
    while (ch != ' ' &amp;&amp; ch != '\n') //当缓冲区中有空格和换行就结束提取
    {
        buff[sub++] = ch; 
        if (sub == 255) 
        {
            buff[sub] = '\0'; 
            s += buff; 
            sub = 0; 
        }
        ch = in.get(); 
    }
    if (sub != 0) 
    {
        buff[sub] = '\0'; 
        s += buff;
    }

    return is; 
}
</code></pre> 
 <p><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">小Tips</span></span><span style="color:#0d0016;">：我们定义一个缓冲区buff，先将字符串输入到缓冲区中，如果字符串很长则分批写入string字符串中，每次写入string后就刷新缓冲区再继续接收，这样就避免了频繁开辟空间。</span></p> 
</blockquote> 
<hr> 
<p><span style="color:#956fe7;">🎁<strong>结语： </strong></span></p> 
<p><span style="color:#956fe7;"><strong>     本次的内容到这里就结束啦。希望大家阅读完可以有所收获，同时也感谢各位读者三连支持。文章有问题可以在评论区留言，博主一定认真认真修改，以后写出更好的文章。你们的支持就是博主最大的动力。</strong></span></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fa8618a1d5c624282c28b46a8d74dd3e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">AI集成工具平台一站式体验，零门槛使用国内外主流大模型</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/77d3e91b4a4c8b2e3824ccc69b9ba65e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【初阶数据结构】深入解析循环队列:探索底层逻辑</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>