<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>随机采样一致性（RANSAC）三维点云的平面拟合算法（含C&#43;&#43;代码） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/78008cbacaf0f3b4430342ce5a34ed1e/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="随机采样一致性（RANSAC）三维点云的平面拟合算法（含C&#43;&#43;代码）">
  <meta property="og:description" content="背景 随机采样一致性（Random sample consensus，RANSAC）：RANSAC是一种鲁棒的模型拟合方法，它可以处理存在大量噪声和异常值的数据。在进行平面拟合时，RANSAC会随机选择三个点，然后计算这三个点确定的平面模型。然后，RANSAC会计算其他所有点到这个平面的距离，并根据一个预设的阈值来判断这些点是否符合这个平面模型。这个过程会重复多次，最后选择符合点最多的平面模型作为最终的结果。
原理 随机采样一致性（RANSAC）是一种迭代的模型估计方法，它的主要目标是从一组包含大量异常值的观测数据中估计出数学模型的参数。在进行平面拟合时，RANSAC的工作原理如下：
随机选择最小样本集：在进行平面拟合时，RANSAC首先会随机选择三个点作为最小样本集。这是因为在三维空间中，三个非共线的点可以确定一个平面。构建模型：然后，RANSAC会根据这三个点计算出一个平面模型。这个模型就是通过这三个点的平面。计算误差：接着，RANSAC会计算其他所有点到这个平面的距离，这个距离就是每个点的误差。确定内点：然后，RANSAC会根据一个预设的阈值来判断每个点是否为内点，也就是说，如果一个点的误差小于这个阈值，那么就认为这个点符合平面模型，将其标记为内点。更新模型：如果内点的数量超过了之前的最大内点数量，那么就用所有的内点来更新平面模型。迭代：以上的过程会重复多次。在每次迭代中，RANSAC都会随机选择一个新的最小样本集，然后构建模型，计算误差，确定内点，更新模型。这个过程会一直进行，直到达到预设的迭代次数。计算最佳模型：最后，RANSAC会选择内点数量最多的样本，再用这些内点进行求解最终的方程，作为最终的结果。通过这种方式，RANSAC可以有效地处理存在大量噪声和异常值的数据，从而得到鲁棒的模型估计结果。 C&#43;&#43;代码 CMakeLists.txt
cmake_minimum_required(VERSION 2.8 FATAL_ERROR) project(ransac_example) find_package(PCL 1.8 REQUIRED) include_directories(${PCL_INCLUDE_DIRS}) link_directories(${PCL_LIBRARY_DIRS}) add_definitions(${PCL_DEFINITIONS}) add_executable (ransac_example ransac_example.cpp) target_link_libraries (ransac_example ${PCL_LIBRARIES}) ransac_example.cpp
在这段代码中，我们首先读取一个PCD文件，并将数据存储到一个PointCloud对象中。然后，我们创建一个表示平面模型的SampleConsensusModelPlane对象，并使用RANSAC算法来估计模型。我们设置RANSAC算法的距离阈值为0.01，然后执行算法并获取平面模型的内点的索引。
#include &lt;pcl/ModelCoefficients.h&gt; #include &lt;pcl/point_types.h&gt; #include &lt;pcl/io/pcd_io.h&gt; #include &lt;pcl/filters/extract_indices.h&gt; #include &lt;pcl/features/normal_3d.h&gt; #include &lt;pcl/sample_consensus/method_types.h&gt; #include &lt;pcl/sample_consensus/model_types.h&gt; #include &lt;pcl/segmentation/sac_segmentation.h&gt; #include &lt;pcl/sample_consensus/sac_model_plane.h&gt; #include &lt;pcl/sample_consensus/ransac.h&gt; // Add this line #include &lt;Eigen/Dense&gt; // Add this line int main(int argc, char** argv) { // 创建一个PointCloud对象，用于存储输入的点云数据 pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;); // 创建一个PCDReader对象，用于读取PCD文件 pcl::PCDReader reader; // 使用PCDReader对象读取PCD文件，并将数据存储到PointCloud对象中 reader.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-07-01T15:25:12+08:00">
    <meta property="article:modified_time" content="2023-07-01T15:25:12+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">随机采样一致性（RANSAC）三维点云的平面拟合算法（含C&#43;&#43;代码）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>背景</h2> 
<p><strong>        随机采样一致性（Random sample consensus，RANSAC）</strong>：RANSAC是一种鲁棒的模型拟合方法，它可以处理存在大量噪声和异常值的数据。在进行平面拟合时，RANSAC会随机选择三个点，然后计算这三个点确定的平面模型。然后，RANSAC会计算其他所有点到这个平面的距离，并根据一个预设的阈值来判断这些点是否符合这个平面模型。这个过程会重复多次，最后选择符合点最多的平面模型作为最终的结果。</p> 
<h2><strong>原理</strong></h2> 
<p>        随机采样一致性（RANSAC）是一种迭代的模型估计方法，它的主要目标是从一组包含大量异常值的观测数据中估计出数学模型的参数。在进行平面拟合时，RANSAC的工作原理如下：</p> 
<p><strong>        随机选择最小样本集</strong>：在进行平面拟合时，RANSAC首先会随机选择三个点作为最小样本集。这是因为在三维空间中，三个非共线的点可以确定一个平面。<strong>构建模型</strong>：然后，RANSAC会根据这三个点计算出一个平面模型。这个模型就是通过这三个点的平面。<strong>计算误差</strong>：接着，RANSAC会计算其他所有点到这个平面的距离，这个距离就是每个点的误差。<strong>确定内点</strong>：然后，RANSAC会根据一个预设的阈值来判断每个点是否为内点，也就是说，如果一个点的误差小于这个阈值，那么就认为这个点符合平面模型，将其标记为内点。<strong>更新模型</strong>：如果内点的数量超过了之前的最大内点数量，那么就用所有的内点来更新平面模型。<strong>迭代</strong>：以上的过程会重复多次。在每次迭代中，RANSAC都会随机选择一个新的最小样本集，然后构建模型，计算误差，确定内点，更新模型。这个过程会一直进行，<span style="color:#fe2c24;">直到达到预设的迭代次数。</span><strong>计算最佳模型</strong>：最后，RANSAC会选择内点数量最多的样本，再用这些内点进行求解最终的方程，作为最终的结果。通过这种方式，RANSAC可以有效地处理存在大量噪声和异常值的数据，从而得到鲁棒的模型估计结果。 <img alt="" height="594" src="https://images2.imgbox.com/40/76/3wckuv1j_o.png" width="985"></p> 
<h2><strong>C++代码</strong></h2> 
<p>        CMakeLists.txt</p> 
<pre><code class="language-cpp">cmake_minimum_required(VERSION 2.8 FATAL_ERROR)

project(ransac_example)

find_package(PCL 1.8 REQUIRED)

include_directories(${PCL_INCLUDE_DIRS})
link_directories(${PCL_LIBRARY_DIRS})
add_definitions(${PCL_DEFINITIONS})

add_executable (ransac_example ransac_example.cpp)
target_link_libraries (ransac_example ${PCL_LIBRARIES})</code></pre> 
<p>        ransac_example.cpp</p> 
<p>        在这段代码中，我们首先读取一个PCD文件，并将数据存储到一个PointCloud对象中。然后，我们创建一个表示平面模型的SampleConsensusModelPlane对象，并使用RANSAC算法来估计模型。我们设置RANSAC算法的距离阈值为0.01，然后执行算法并获取平面模型的内点的索引。</p> 
<pre><code class="language-cpp">#include &lt;pcl/ModelCoefficients.h&gt;
#include &lt;pcl/point_types.h&gt;
#include &lt;pcl/io/pcd_io.h&gt;
#include &lt;pcl/filters/extract_indices.h&gt;
#include &lt;pcl/features/normal_3d.h&gt;
#include &lt;pcl/sample_consensus/method_types.h&gt;
#include &lt;pcl/sample_consensus/model_types.h&gt;
#include &lt;pcl/segmentation/sac_segmentation.h&gt;
#include &lt;pcl/sample_consensus/sac_model_plane.h&gt;
#include &lt;pcl/sample_consensus/ransac.h&gt;  // Add this line
#include &lt;Eigen/Dense&gt;  // Add this line

int main(int argc, char** argv)
{
    // 创建一个PointCloud对象，用于存储输入的点云数据
    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);

    // 创建一个PCDReader对象，用于读取PCD文件
    pcl::PCDReader reader;
    // 使用PCDReader对象读取PCD文件，并将数据存储到PointCloud对象中
    reader.read&lt;pcl::PointXYZ&gt; ("/home/fairlee/000000.pcd", *cloud);

    // 创建一个整型向量，用于存储平面模型的内点的索引
    std::vector&lt;int&gt; inliers;

    // 创建一个SampleConsensusModelPlane对象，用于表示平面模型
    pcl::SampleConsensusModelPlane&lt;pcl::PointXYZ&gt;::Ptr
            model_p(new pcl::SampleConsensusModelPlane&lt;pcl::PointXYZ&gt; (cloud));

    // 创建一个RandomSampleConsensus对象，用于执行RANSAC算法
    pcl::RandomSampleConsensus&lt;pcl::PointXYZ&gt; ransac (model_p);
    // 设置RANSAC算法的距离阈值
    ransac.setDistanceThreshold (.01);
    // 设置RANSAC算法的最大迭代次数
    ransac.setMaxIterations(1000);
    // 执行RANSAC算法，计算模型
    ransac.computeModel();
    // 获取平面模型的内点的索引
    ransac.getInliers(inliers);

    // 创建一个Eigen::VectorXf对象，用于存储平面模型的系数
    Eigen::VectorXf coefficients;
    // 获取平面模型的系数
    ransac.getModelCoefficients(coefficients);
    // 打印平面模型的系数
    std::cout &lt;&lt; "The coefficients of the plane model are: " &lt;&lt; coefficients &lt;&lt; std::endl;

    // 打印平面方程
    std::cout &lt;&lt; "The plane equation is: " &lt;&lt; coefficients[0] &lt;&lt; "X + " &lt;&lt; coefficients[1] &lt;&lt; "Y + " &lt;&lt; coefficients[2] &lt;&lt; "Z + " &lt;&lt; coefficients[3] &lt;&lt; " = 0" &lt;&lt; std::endl;

    // 创建一个ExtractIndices对象，用于提取平面模型的内点
    pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract;
    // 设置输入的点云
    extract.setInputCloud (cloud);
    // 设置需要提取的点的索引
    extract.setIndices (boost::make_shared&lt;std::vector&lt;int&gt; &gt; (inliers));
    // 设置提取模式为非负，即提取内点
    extract.setNegative (false);

    // 创建一个新的PointCloud对象，用于存储提取的内点
    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_plane (new pcl::PointCloud&lt;pcl::PointXYZ&gt; ());
    //执行提取操作
    extract.filter (*cloud_plane);

    // 创建一个PCDWriter对象，用于写入PCD文件
    pcl::PCDWriter writer;
    // 使用PCDWriter对象写入PCD文件，将提取的内点写入到新的PCD文件中
    writer.write&lt;pcl::PointXYZ&gt; ("/home/fairlee/plane.pcd", *cloud_plane, false);

    return 0;
}
</code></pre> 
<h4>拟合前：</h4> 
<p class="img-center"><img alt="" height="565" src="https://images2.imgbox.com/df/6e/A3Z87SQO_o.png" width="856"></p> 
<h4> 拟合后：</h4> 
<p class="img-center"><img alt="" height="578" src="https://images2.imgbox.com/7c/86/YmbcSKEs_o.png" width="856"></p> 
<h3></h3>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ab29768572a491e759204e79fb4692d5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2023年最新IDEA中 Java程序 | Java&#43;Kotlin混合开发的程序如何打包成jar包和exe文件(gradle版本)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f910bbc6779faf8aac893ef4e303b3af/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android studio中文汉化详细教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>