<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;高阶】高效数据结构的探索（map&amp;&amp;set） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/746a341ecdf3104b98e5423d4fb88ee3/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;高阶】高效数据结构的探索（map&&set）">
  <meta property="og:description" content="✨ 人生到处知何似，应似飞鸿踏雪泥 🌏 📃个人主页：island1314
🔥个人专栏：C&#43;&#43;学习
🚀 欢迎关注：👍点赞 👂🏽留言 😍收藏 💞 💞 💞
🚀前言： 【C&#43;&#43;深度学习】二叉搜索树的全面解析与高效实现-CSDN博客
通过之前对二叉搜索树的学习，我相信大家对set和map也应该有所了解，set就类似于二叉搜索树的K模型，而map就类似于二叉搜索树的KV模型，下面就让我们进入对其的了解吧，踏上这神秘的学习之旅
1. 关联式容器 📒在初阶阶段，我们已经接触过STL中的部分容器，比如：vector、list、deque、
forward_list(C&#43;&#43;11)等，这些容器统称为序列式容器，因为其底层为线性序列的数据结构，里面存储的是元素本身
📙关联式容器（Associative Containers） 是C&#43;&#43;标准模板库（STL）中的一类重要容器，主要用于存储和快速检索键值对（key-value pairs）形式的数据。这类容器与序列式容器（如vector、deque、list）的主要区别在于，关联式容器中的元素是按照特定的排序准则（通常是键的大小）进行排序的，从而允许通过键来快速查找、插入和删除元素。
关联式容器： 也是用来存储数据的，与序列式容器不同的是，其里面存储的是&lt;key, value&gt;结构的键值对，在数据检索时比序列式容器效率更高
2. 键值对 概念： 用来表示具有一一对应关系的一种结构，该结构中一般只包含两个成员变量key和value，key代表键值，value表示与key对应的信息，比如我们上一篇所提到的kv模型结构 存在对应关系
SGI-STL中关于键值对的定义：(示例)
template &lt;class T1, class T2&gt; struct pair { typedef T1 first_type; typedef T2 second_type; T1 first; T2 second; pair(): first(T1()), second(T2()) {} pair(const T1&amp; a, const T2&amp; b) : first(a) , second(b) {} }; 3. 树形结构的关联式容器 📕根据应用场景的不桶，STL总共实现了两种不同结构的管理式容器：树型结构与哈希结构">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-18T17:03:32+08:00">
    <meta property="article:modified_time" content="2024-07-18T17:03:32+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;高阶】高效数据结构的探索（map&amp;&amp;set）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b2/b3/bcB9Cu8q_o.jpg"></p> 
<p>✨                                                       人生到处知何似，应似飞鸿踏雪泥       🌏 </p> 
<p>📃<a href="https://so.csdn.net/so/search?q=%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5&amp;spm=1001.2101.3001.7020" title="个人主页">个人主页</a>：<a href="https://blog.csdn.net/island1314?spm=1011.2266.3001.5343" title="island1314">island1314</a></p> 
<p>🔥个人专栏：<a href="https://blog.csdn.net/island1314/category_12622912.html" title="C++学习">C++学习</a></p> 
<p>🚀 欢迎关注：👍点赞 👂🏽留言 😍收藏  💞 💞 💞</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/34/f1/n3mbbvCM_o.gif"></p> 
<hr> 
<h3>🚀前言：</h3> 
<p><a href="https://blog.csdn.net/island1314/article/details/140522805?spm=1001.2014.3001.5501" title="【C++深度学习】二叉搜索树的全面解析与高效实现-CSDN博客">【C++深度学习】二叉搜索树的全面解析与高效实现-CSDN博客</a></p> 
<p>通过之前对二叉搜索树的学习，我相信大家对set和map也应该有所了解，set就类似于二叉搜索树的K模型，而map就类似于二叉搜索树的KV模型，下面就让我们进入对其的了解吧，踏上这神秘的学习之旅</p> 
<h3>1. 关联式容器</h3> 
<p>📒在初阶阶段，<strong>我们已经接触过STL中的部分容器，比如：vector、list、deque、</strong><br><strong>forward_list(C++11)等</strong>，这些容器统称为<strong>序列式容器，</strong>因为<strong>其底层为线性序列的数据结构，里面存储的是元素本身</strong></p> 
<p>📙<strong>关联式容器（Associative Containers）</strong> 是C++标准模板库（STL）中的一类重要容器，主<strong>要用于存储和快速检索键值对（key-value pairs）形式的数据。这类容器与序列式容器（如vector、deque、list）的主要区别在于，关联式容器中的元素是按照特定的排序准则（通常是键的大小）进行排序的，</strong>从而<strong>允许通过键来快速查找、插入和删除元素。</strong></p> 
<blockquote> 
 <p><strong>关联式容器：</strong> <strong>也是用来存储数据的</strong>，与序列式容器不同的是，<strong>其里面存储的是&lt;key, value&gt;结构的键值对，在数据检索时比序列式容器效率更高</strong></p> 
</blockquote> 
<h3>2. 键值对</h3> 
<blockquote> 
 <p><strong>概念：</strong> 用来表示具有一一对应关系的一种结构，该结构中一般只包含两个成员变量key和value，key代表键值，value表示与key对应的信息，<strong>比如我们上一篇所提到的kv模型结构</strong> 存在对应关系</p> 
</blockquote> 
<p><img alt="" height="174" src="https://images2.imgbox.com/ec/fe/9L1RcrWd_o.png" width="1015"></p> 
<p><img alt="" height="122" src="https://images2.imgbox.com/be/53/R5XBTI92_o.png" width="451"></p> 
<p><strong>SGI-STL中关于键值对的定义：(示例)</strong></p> 
<pre><code class="language-cpp">template &lt;class T1, class T2&gt;
struct pair
{
	typedef T1 first_type;
	typedef T2 second_type;
	T1 first;
	T2 second;
	
	pair(): first(T1()), second(T2())
	{}
	
	pair(const T1&amp; a, const T2&amp; b)
	: first(a)
	, second(b)
	{}
};
</code></pre> 
<h3>3. 树形结构的关联式容器</h3> 
<p>📕<strong>根据应用场景的不桶，STL总共实现了两种不同结构的管理式容器：树型结构与哈希结构</strong></p> 
<blockquote> 
 <ul><li><strong>树型结构的关联式容器主要有四种：map、set、multimap、multiset</strong></li><li><strong>共同点是：使用平衡搜索树(即红黑树)作为其底层结果，容器中的元素是一个有序的序列</strong></li></ul> 
</blockquote> 
<p>📕<strong>关联式容器是C++ STL中一类重要的容器，它们通过键值对的形式存储数据，并支持快速的查找、插入和删除操作。常见的关联式容器包括set、multiset、map和multimap等，它们在不同的应用场景下提供了高效的解决方案</strong></p> 
<h3>4. set &amp;&amp; multiset</h3> 
<h4>📜set的概念</h4> 
<p><strong>概念：</strong> set 是 C++ 标准模板库 (STL) 中的一个关联式容器，它包含的元素是唯一的，且默认情况下元素会按照升序排序。set 的内部实现通常使用红黑树来保持其有序性和唯一性</p> 
<blockquote> 
 <ul><li><strong>set是按照一定次序存储元素的容器</strong></li><li><strong>在set中，元素的value也标识它(value就是key，类型为T)，并且每个value必须是唯一的</strong></li><li>set中的元素<strong>不能在容器中修改(元素总是const)</strong>，但是可以从容器中插入或删除它们</li><li><strong>set默认是升序</strong>，但是其内部默认不是按照大于比较，而是<strong>按照小于比较</strong>，set中的元素总是按照其内部比较对象(类型比较)所指示的特定严格<strong>弱排序</strong>准则进行排序</li><li>set容器通过key访问单个元素的速度通常比unordered_set容器慢，但它们允许根据顺序对子集进行直接迭代</li></ul> 
 <ul><li>set在底层是用二叉搜索树(红黑树)实现的</li></ul> 
</blockquote> 
<h4>📙<strong>set特征：</strong></h4> 
<blockquote> 
 <ul><li>与map/multimap不同，<strong>map/multimap中存储的是真正的键值对&lt;key, value&gt;，set中只放value，但在底层实际存放的是由&lt;value, value&gt;构成的键值对，</strong></li><li>set中插入元素时，只需要插入value即可，<strong>不需要</strong>构造键值对，但是set中可以存储键值对，实例化set时，<strong>将set中元素类型设置为pair即可</strong>。</li><li>set中<strong>没有重载 [] 运算符</strong></li><li>因为set要保证其有序，因此set中元素不能被直接修改，若要修改可以先删除，再插入</li><li>set中的元素不可以重复(因此可以使用set进行去重)</li><li>使用set的迭代器遍历set中的元素，可以得到有序序列</li><li>set中的元素默认按照小于来比较</li><li> <p>set中查找某个元素，时间复杂度为：<img alt="\log N" class="mathcode" src="https://images2.imgbox.com/ae/64/aeAOzeHm_o.png"></p> </li><li><strong>set中的元素不允许修改</strong></li><li><strong>set中的底层使用二叉搜索树(红黑树)来实现</strong></li></ul> 
</blockquote> 
<h4></h4> 
<h4>🎈multiset的概念</h4> 
<p><strong>概念：<code>multiset</code> 是 C++ 标准库 中的一个容器，它允许存储重复的元素。与 <code>set</code> 不同，<code>set</code> 中的元素是唯一的，而 <code>multiset</code> 中的元素可以重复</strong></p> 
<blockquote> 
 <p><strong>它与<code>set</code>唯一不同的一点就是 <code>multiset</code> 中的元素<span style="color:#fe2c24;">可以重复</span></strong></p> 
</blockquote> 
<p><strong>简单演示一下差别:</strong></p> 
<pre><code class="language-cpp">void test3()
{
	multiset&lt;int&gt; s;
	s.insert(5); s.insert(5);
	s.insert(2); s.insert(2); s.insert(2);
	s.insert(1);
	s.insert(9);
	s.insert(7);

	//set&lt;int&gt;::iterator it = s.begin();
	auto it = s.begin();
	while (it != s.end())
	{
		cout &lt;&lt; *it &lt;&lt; " ";
		++it;
	}
	cout &lt;&lt; endl;

	int x;
	cin &gt;&gt; x;
	auto pos = s.find(x); //查找x时，返回中序第一个
	while (pos != s.end() &amp;&amp; *pos == x)  
	{
		cout &lt;&lt; *pos &lt;&lt; " ";
		++pos;
	}
	cout &lt;&lt; endl;

}</code></pre> 
<h4> 📒set使用</h4> 
<h5><strong>🌈set的模板参数列表</strong></h5> 
<p><img alt="" height="185" src="https://images2.imgbox.com/dd/0a/8poNKka5_o.png" width="998"></p> 
<blockquote> 
 <ul><li><strong>T: set中存放元素的类型，实际在底层存储&lt;value, value&gt;的键值对</strong></li><li><strong>Compare：set中元素默认按照小于来比较</strong></li><li><strong>Alloc：set中元素空间的管理方式，使用STL提供的空间配置器管理</strong></li></ul> 
</blockquote> 
<pre><code class="language-cpp">void test1()
{
	set&lt;int&gt; s;
	s.insert(5); s.insert(5);
	s.insert(2); s.insert(2);
	s.insert(1);
	s.insert(9);
	s.insert(7);

	//set&lt;int&gt;::iterator it = s.begin();
	auto it = s.begin();
	while (it != s.end())
	{
		cout &lt;&lt; *it &lt;&lt; " ";
		++it;
	}
	cout &lt;&lt; endl;

	for (auto e : s)
	{
		cout &lt;&lt; e &lt;&lt; " ";
	}
	cout &lt;&lt; endl;

	auto rit = s.rbegin();
	while (rit != s.rend())
	{
		cout &lt;&lt; *rit &lt;&lt; " ";
		++rit;
	}
	cout &lt;&lt; endl;

	int x;
	cin &gt;&gt; x;

	if (s.find(x) != s.end()) cout &lt;&lt; "存在" &lt;&lt; endl;
	else cout &lt;&lt; "不存在" &lt;&lt; endl;

	auto pos1 = find(s.begin(), s.end(), x); //O(N)
	auto pos2 = s.find(x); // O(log(N))

	if (s.count(x))  //O(log(N))
		cout &lt;&lt; "存在" &lt;&lt; endl;
	else cout &lt;&lt; "不存在" &lt;&lt; endl;

	s.insert(x);
	cout &lt;&lt; "插入：";
	for (auto e : s)
	{
		cout &lt;&lt; e &lt;&lt; " ";
	}
	cout &lt;&lt; endl;

	cout &lt;&lt; "删除：";
	s.erase(s.begin(),s.end());
	for (auto e : s)
	{
		cout &lt;&lt; e &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
}

void test2()
{
	std::set&lt;int&gt; myset;
	std::set&lt;int&gt;::iterator itlow, itup;
	
	for (int i = 1; i &lt; 10; i++) myset.insert(i * 10); // 10 20 30 40 50 60 70 80 90
	
	// [30, 60]
	// &gt;= 30

	itlow = myset.lower_bound(24);                //
	// &gt; 60
	itup = myset.upper_bound(34);         
	cout &lt;&lt; *itlow &lt;&lt; " " &lt;&lt; *itup &lt;&lt; endl;

	myset.erase(itlow, itup);                     // 10 20 70 80 90

	std::cout &lt;&lt; "myset contains:";
	for (std::set&lt;int&gt;::iterator it = myset.begin(); it != myset.end(); ++it)
	    std::cout &lt;&lt; ' ' &lt;&lt; *it;
	std::cout &lt;&lt; '\n';
}
</code></pre> 
<p>在上面中：</p> 
<p>在set的这些函数中，用的最多的就是<code>insert，find，erase</code></p> 
<h5><strong>🌈insert</strong></h5> 
<h5><img alt="" height="199" src="https://images2.imgbox.com/f8/87/P1U5aK2d_o.png" width="1074"><br>  </h5> 
<blockquote> 
 <ul><li>首先<strong>insert</strong>一般是直接插入元素，或者是一段迭代器区间，在直接插入一个元素时，它的返回值是<strong>pair</strong></li><li>当插入成功时<strong>，first返回新位置的迭代器，然后second返回true;</strong></li><li>当set中已经存在该元素时，插入失败，first返回已有元素位置的迭代器，然后second返回false</li></ul> 
</blockquote> 
<h5><strong>🌈find</strong></h5> 
<p><img alt="" height="137" src="https://images2.imgbox.com/d8/f1/PVjEZEgC_o.png" width="1044"></p> 
<blockquote> 
 <ul><li><strong><code>find</code>不用多说，在<code>set</code>中是找到则返回该位置迭代器</strong></li><li><strong>在<code>multiset</code>中是返回第一个该元素位置的迭代器</strong></li></ul> 
</blockquote> 
<h5><strong>🌈erase</strong></h5> 
<p><img alt="" height="189" src="https://images2.imgbox.com/1b/e0/yfEWiVlt_o.png" width="1026"></p> 
<blockquote> 
 <ul><li> <p><strong><code>erase</code>在set中主要的作用就是删除该迭代器位置的元素，或者删除迭代器区间</strong></p> </li><li> <p><strong>第二种用法是针对<code>multiset</code>的，<code>multiset</code>可以有重复元素，因此可以返回删除元素的个数</strong></p> </li></ul> 
</blockquote> 
<h5><strong>🌈lower_bound 和 upper_bound</strong></h5> 
<h5><img alt="" height="212" src="https://images2.imgbox.com/ff/f8/eWTZrPjT_o.png" width="1041"></h5> 
<p><img alt="" height="193" src="https://images2.imgbox.com/a5/d4/x2RaKvEU_o.png" width="1026"></p> 
<blockquote> 
 <p><strong>这里介绍两个没有见过的函数<code>upper_bound，lower_bound</code></strong></p> 
 <ul><li><strong>lower_bound：返回&gt;=该值元素位置的迭代器</strong></li><li><strong>upper_bound：返回&gt;该值元素位置的迭代器</strong></li></ul> 
</blockquote> 
<p><span style="color:#fe2c24;"><strong>这两个函数通常可以和erase结合使用删除一段迭代器区间</strong></span></p> 
<h3>5. map 与 multimap</h3> 
<h4>🎩map的概念</h4> 
<p>📚概念：<strong><span style="color:#0d0016;"> map</span> </strong>是 C++ 标准库中的一个关联容器，它存储的元素都是键值对<strong>（key-value pairs）</strong>，并且键（key）是唯一的。在<strong>map</strong>中，键值key通常用于排序和惟一地标识元素，而值value中存储与此键值key关联的内容。键值key和值value的类型可能不同，并且在<strong>map</strong>的内部，key与value通过成员类型<strong>value_type</strong>绑定在一起，为其取别名称为<strong>pair</strong>：</p> 
<pre><code class="language-cpp">typedef pair&lt;const key, T&gt; value_type;
</code></pre> 
<h4>🎩特点:</h4> 
<blockquote> 
 <ul><li>map中key不能修改，因为如果修改了就不能保证红黑树的特性了，即有序</li><li><strong>map中key是唯一的，每个key都有与之对应的value，经常需要通过key获取value</strong>，因此 map为了形象简    单重载了[]运算符, multimap中key是可以重复的，如果重载了[]运算符，给定 一个key时，就没有办法返回 value了，因此<strong>，multimap中没有重载[]运算符</strong></li><li></ul> 
</blockquote> 
<h4>🎈multimap的概念</h4> 
<p><strong>概念：</strong> <code>multimap</code> 是 C++ 标准库 中的一个关联容器，它允许存储具有相同键的多个值。与 <code>map</code> 不同，<code>map</code> 中的键是唯一的，而 <code>multimap</code> 中的键可以重复</p> 
<p><strong>multimap中的接口可以参考map，功能都是类似的。</strong></p> 
<blockquote> 
 <p></p> 
 <p><strong>注意：</strong></p> 
 <ul><li><strong>multimap中的key是可以重复的</strong></li><li><strong>multimap中的元素默认将key按照小于来比较</strong></li><li><strong>multimap中没有重载<code>operator[]</code>操作</strong></li></ul> 
</blockquote> 
<h4>🧩map的使用</h4> 
<pre><code class="language-cpp">void test1()   //遍历
{
	/*map&lt;string, string&gt; dict;
	pair&lt;string, string&gt; kv1("left", "左边");*/
	
	map的多种初始化方式
	//dict.insert(kv1);
	//dict.insert(pair&lt;string, string&gt;("right", "右边"));
	//dict.insert(make_pair("insert", "插入"));

	pair&lt;string, string&gt; kv2 = {"string","字符串" };
	//dict.insert({ "string", "字符串" });

	map&lt;string, string&gt; dict = { {"left", "左边"}, {"right", "右边"},{"insert", "插入"},{ "string", "字符串" } };

	map&lt;string, string&gt;::iterator it = dict.begin();
	while (it != dict.end())
	{
		//cout &lt;&lt; (*it).first &lt;&lt;":"&lt;&lt;(*it).second &lt;&lt; endl;
		//cout &lt;&lt; (*it).first &lt;&lt; ":" &lt;&lt; (*it).second &lt;&lt; endl;
		cout &lt;&lt; it-&gt;first &lt;&lt; ":" &lt;&lt; it-&gt;second &lt;&lt; endl;

		++it;
	}
	cout &lt;&lt; endl;
	for (const auto&amp; e : dict)
	{
		cout &lt;&lt; e.first &lt;&lt; ":" &lt;&lt; e.second &lt;&lt; endl;
	}
	cout &lt;&lt; endl;

	for (auto&amp; [x, y] : dict) //C++17支持
	{
		cout &lt;&lt; x &lt;&lt; ":" &lt;&lt; y &lt;&lt; endl;
	}
	cout &lt;&lt; endl;

	string str;
	while (cin &gt;&gt; str)
	{
		auto ret = dict.find(str);
		if (ret != dict.end())
		{
			cout &lt;&lt; "-&gt;" &lt;&lt; ret-&gt;second &lt;&lt; endl;
		}
		else
		{
			cout &lt;&lt; "无此单词，请重新输入" &lt;&lt; endl;
		}
	}
}

void test3()   //插入
{
	map&lt;string, string&gt; dict;
	dict.insert(make_pair("sort", "排序"));
	//插入 + 修改
	dict["left"] = "左边"; 

	//修改
	dict["left"] = "左边 + 修改";

	//key不存在-&gt;插入&lt;"insert", ""&gt;
	dict["insert"];

	//存在-&gt;查找
	cout &lt;&lt; dict["left"] &lt;&lt; endl;


}
</code></pre> 
<h5>🌈map的模板参数说明</h5> 
<p><img alt="" height="208" src="https://images2.imgbox.com/35/76/g2kq67ZT_o.png" width="940"></p> 
<blockquote> 
 <ul><li><strong>key: 键值对中key的类型</strong></li><li><strong>T： 键值对中value的类型</strong></li><li><strong>Compare: 比较器的类型，默认按小于比较</strong></li></ul> 
</blockquote> 
<h5>🌈<strong>insert</strong></h5> 
<p><img alt="" height="205" src="https://images2.imgbox.com/ee/f2/opVQROAI_o.png" width="1036"></p> 
<p><strong>在<code>insert</code>插入中，所需要的元素类型是<code>value_type</code> - &gt; <code>pair</code></strong></p> 
<p><strong><code>insert</code>：插入成功 pair&lt;新插入key所在节点的iterator， true&gt;插入失败 pair&lt;已经存在的key所在节点的iterator，false&gt;</strong></p> 
<h5>🌈<strong>map的成员类型</strong></h5> 
<p><img alt="" height="172" src="https://images2.imgbox.com/3c/a5/GL1EEXGy_o.png" width="797"></p> 
<h5>🌈pair</h5> 
<p><img alt="" height="186" src="https://images2.imgbox.com/6f/c8/9WfDBZi3_o.png" width="1043"></p> 
<p><strong><code>pair</code>可以支持带参构造，无参构造和拷贝构造</strong></p> 
<p><strong>map插入代码演示：</strong></p> 
<pre><code class="language-cpp">int main()
{
	map&lt;string,string&gt; d;
	d.insert(pair&lt;string, string&gt;("insert", "插入"));
	d.insert(pair&lt;const char*, const char*&gt;("find", "查找"));
	return 0;
}
</code></pre> 
<h5>🌈make_pair</h5> 
<p><strong>而一般我们并不会这没写，因为有<code>make_pair</code>的存在，我们往往使用<code>make_pair</code></strong></p> 
<p><img alt="" height="159" src="https://images2.imgbox.com/16/aa/gersBm20_o.png" width="1036"></p> 
<p><img alt="" height="132" src="https://images2.imgbox.com/c7/e3/axf1mKoF_o.png" width="578"></p> 
<p><strong><code>make_pair</code>是一个函数模板，他可以自己推演类型</strong></p> 
<pre><code class="language-cpp">int main()
{
	map&lt;string,string&gt; d;
	d.insert(make_pair("erase", "删除"));
	return 0;
}
</code></pre> 
<h5>🌈<strong>operator[ ]</strong></h5> 
<p><strong>map中重载了[]运算符，因为其需要通过key获取value,set没有</strong></p> 
<h5><img alt="" height="329" src="https://images2.imgbox.com/bd/4d/SnJqhsc0_o.png" width="1023"></h5> 
<p><strong>在使用operator[ ]时，它会自动插入一个元素，在插入成功时，返回该位置的<code>second</code>(默认为0)，在插入失败时，它就会返回已有位置的<code>second。</code></strong></p> 
<h4>💧map实际应用</h4> 
<h5>✨计数</h5> 
<pre><code class="language-cpp">void test2()  //映射计数
{
	string arr[] = { "苹果", "西瓜", "苹果", "西瓜", "苹果", "苹果", "西瓜", "苹果", "香蕉", "苹果", "香蕉" };
	int i = int(); //匿名构造, 为0
	int j = int(10);
	map&lt;string, int&gt; countTree; //故其second的值最初为0
	for (const auto&amp; str : arr)
	{
		// 先查找水果在不在搜索树中
		// 1、不在，说明水果第一次出现，则插入&lt;水果, 1&gt;
		// 2、在，则查找到的节点中水果对应的次数++
		//BSTreeNode&lt;string, int&gt;* ret = countTree.Find(str);
		auto ret = countTree.find(str);  
		if (ret == countTree.end())  //没有找到
		{
			countTree.insert({ str, 1 });
		}
		else
		{
			ret-&gt;second++;
		}
	}
	
	for (const auto&amp; e : countTree)
	{
		cout &lt;&lt; e.first &lt;&lt; ":" &lt;&lt; e.second &lt;&lt; endl;
	}
	cout &lt;&lt; endl;


	map&lt;string, int&gt; countTree1; //第二种统计方法
	for (const auto&amp; str : arr)
	{
		countTree1[str]++;
	}
	for (const auto&amp; e : countTree1)
	{
		cout &lt;&lt; e.first &lt;&lt; ":" &lt;&lt; e.second &lt;&lt; endl;
	}
	cout &lt;&lt; endl;
}</code></pre> 
<p></p> 
<h3>📖6. 总结拓展</h3> 
<h4><a name="t21"></a><a id="_315"></a>💧在实际中的练习与运用</h4> 
<p><strong>这里推荐两个题目让大家练习一下，方便巩固set与map</strong><br><a href="https://leetcode.cn/problems/top-k-frequent-words/description/" rel="nofollow" title="前K个高频单词">前K个高频单词</a><br><a href="https://leetcode.cn/problems/intersection-of-two-arrays/submissions/" rel="nofollow" title="两个数组的交集">两个数组的交集</a></p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/85/01/5lBzCXxM_o.gif"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/84183fc0a41f8f3913d08613ecf44a95/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Qt】QTcpServer/QTcpSocket通信</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/335e7f7732f9a429518383eb0fefd011/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">算法笔记|Day1数组基础</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>