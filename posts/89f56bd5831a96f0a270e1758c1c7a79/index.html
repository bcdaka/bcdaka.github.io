<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>论文阅读报告: 在时间双向图上查询基于时间的的密集子图 | ICDE 2024 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/89f56bd5831a96f0a270e1758c1c7a79/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="论文阅读报告: 在时间双向图上查询基于时间的的密集子图 | ICDE 2024">
  <meta property="og:description" content="摘要 本文提出了一个新的模型（α, β, T）-core，用于在时间双向图上寻找凝聚子图。时间双向图中，不同实体之间的关系随着时间的推移而变化。为了提高查询效率，本文提出了顶点分区和时间分区的历史索引（VH-Index和TH-Index），并进一步提出了时间交集索引（TH*-Index）。实验结果表明，本文提出的模型和算法在多个真实数据集上表现出色。
什么是时间双向图 时间双向图（Temporal Bipartite Graph）是指在图中存在两类不同的顶点集合，并且这些顶点之间的关系（边）随着时间的推移而变化。每条边都有一个时间戳，表示该边在特定时间发生。时间双向图可以用于建模许多现实世界的应用场景，如用户-商品购买关系、作者-论文发表关系等。
时间双向图的构成 顶点集合： 上层顶点集（U）：表示一种类型的实体。例如，在用户-商品购买网络中，上层顶点可以表示用户。下层顶点集（L）：表示另一种类型的实体。例如，在用户-商品购买网络中，下层顶点可以表示商品。 边集合（E）： 边连接上层顶点和下层顶点，表示两种实体之间的关系。例如，用户购买商品。在时间双向图中，边带有时间戳，表示这种关系发生的时间。 举例说明 我们以一个简化的用户-商品购买网络为例，其中：
顶点集U表示用户顶点集L表示商品边表示用户在某一时间购买某一商品每条边都有一个时间戳，表示购买时间 假设有以下用户和商品：
用户U: {Alice, Bob, Carol}商品L: {Book, Pen, Notebook} 时间双向图的边集可以如下表示：
(Alice, Book, 2024-01-01): 表示Alice在2024年1月1日购买了Book
(Bob, Pen, 2024-01-03): 表示Bob在2024年1月3日购买了Pen
(Alice, Notebook, 2024-01-05): 表示Alice在2024年1月5日购买了Notebook
(Carol, Book, 2024-01-06): 表示Carol在2024年1月6日购买了Book
(Bob, Notebook, 2024-01-07): 表示Bob在2024年1月7日购买了Notebook
研究背景 在许多现实世界的应用中，例如作者-论文网络、用户-物品网络等，不同实体之间的关系可以自然地表示为双向图。双向图由两类顶点和连接它们的边组成，这些边只在不同类别的顶点之间存在。在时间双向图中，边不仅连接不同类别的顶点，还带有时间戳，表示这种关系在某一特定时间发生或存在。随着时间的推移，这些关系会发生变化，形成时间双向图。传统的凝聚子图(密集子图)模型没有考虑时间维度，因此无法捕捉关系的动态变化。为了弥补这一不足，本文提出了时间双向图上的（α, β, T）-core模型。
研究问题 本文研究的问题是在时间双向图上找到满足给定度约束的最大子图。具体来说，给定时间窗口T=[ts, te]，以及度约束α和β，目标是找到一个子图，使得在该时间窗口内，上层和下层顶点的度分别至少为α和β。
主要贡献 提出新的凝聚子图模型（α, β, T）-core：该模型结合了时间维度，能够捕捉关系的动态变化。设计了高效的索引结构：包括顶点分区历史索引（VH-Index）、时间分区历史索引（TH-Index）和时间交集索引（TH*-Index），以提高查询效率。开发了高效的构建和查询算法：提出了顺序和并行算法，用于高效构建时间交集索引。实验验证：在10个真实数据集上进行了大量实验，验证了模型和算法的有效性和效率。 预备知识 本文使用了一些基本的数学符号和定义：
时间双向图G(V, E)：V表示顶点集，E表示带有时间戳的边集。U(G)和L(G)：分别表示上层和下层顶点集。快照G[ts, te]：表示在时间窗口[ts, te]内的子图。度和邻居：顶点u在图G中的度表示为deg(u, G)，邻居集表示为N(u)。 索引的基本思想 顶点分区历史索引（VH-Index）： 基本思想：存储每个顶点在不同时间窗口内的状态，以便快速检索满足（α, β, T）-core条件的顶点。实现方式：对于每个顶点u，VH-Index存储所有可能的（α, β, T）-core组合的时间窗口。 时间分区历史索引（TH-Index）： 基本思想：通过按时间存储顶点，减少查询过程中需要访问的顶点数量。实现方式：TH-Index按时间分区存储顶点，将每个时间窗口内的（α, β, T）-core顶点集合存储在一起。 时间交集索引（TH-Index）*： 基本思想：结合VH-Index和TH-Index的优点，既减少存储空间，又提高查询效率。实现方式：通过存储代表性的时间点，减少冗余信息的存储，并在查询时进行交集计算。 索引的构建 顶点分区历史索引（VH-Index）： 步骤： 对于每个顶点u和每个可能的α、β组合，计算u在不同时间窗口内的状态。存储每个顶点在不同时间窗口内的状态，以便快速查询。 构建算法： 通过对图进行多次遍历，依次计算每个顶点在各个时间窗口内的（α, β, T）-core状态，并将这些状态存储在VH-Index中。 时间分区历史索引（TH-Index）： 步骤：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-07T23:03:45+08:00">
    <meta property="article:modified_time" content="2024-08-07T23:03:45+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">论文阅读报告: 在时间双向图上查询基于时间的的密集子图 | ICDE 2024</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_3"></a>摘要</h3> 
<p>本文提出了一个新的模型（α, β, T）-core，用于在时间双向图上寻找凝聚子图。时间双向图中，不同实体之间的关系随着时间的推移而变化。为了提高查询效率，本文提出了顶点分区和时间分区的历史索引（VH-Index和TH-Index），并进一步提出了时间交集索引（TH*-Index）。实验结果表明，本文提出的模型和算法在多个真实数据集上表现出色。</p> 
<h3><a id="_7"></a>什么是时间双向图</h3> 
<p>时间双向图（Temporal Bipartite Graph）是指在图中存在两类不同的顶点集合，并且这些顶点之间的关系（边）随着时间的推移而变化。每条边都有一个时间戳，表示该边在特定时间发生。时间双向图可以用于建模许多现实世界的应用场景，如用户-商品购买关系、作者-论文发表关系等。</p> 
<h4><a id="_11"></a>时间双向图的构成</h4> 
<ol><li> <h5><a id="_13"></a><strong>顶点集合</strong>：</h5> 
  <ul><li><strong>上层顶点集（U）</strong>：表示一种类型的实体。例如，在用户-商品购买网络中，上层顶点可以表示用户。</li><li><strong>下层顶点集（L）</strong>：表示另一种类型的实体。例如，在用户-商品购买网络中，下层顶点可以表示商品。</li></ul> </li><li> <h5><a id="E_18"></a><strong>边集合（E）</strong>：</h5> 
  <ul><li>边连接上层顶点和下层顶点，表示两种实体之间的关系。例如，用户购买商品。在时间双向图中，边带有时间戳，表示这种关系发生的时间。</li></ul> </li></ol> 
<h4><a id="_22"></a>举例说明</h4> 
<p>我们以一个简化的用户-商品购买网络为例，其中：</p> 
<ul><li>顶点集U表示用户</li><li>顶点集L表示商品</li><li>边表示用户在某一时间购买某一商品</li><li>每条边都有一个时间戳，表示购买时间</li></ul> 
<p>假设有以下用户和商品：</p> 
<ul><li>用户U: {Alice, Bob, Carol}</li><li>商品L: {Book, Pen, Notebook}</li></ul> 
<p>时间双向图的边集可以如下表示：</p> 
<ul><li> <p>(Alice, Book, 2024-01-01): 表示Alice在2024年1月1日购买了Book</p> </li><li> <p>(Bob, Pen, 2024-01-03): 表示Bob在2024年1月3日购买了Pen</p> </li><li> <p>(Alice, Notebook, 2024-01-05): 表示Alice在2024年1月5日购买了Notebook</p> </li><li> <p>(Carol, Book, 2024-01-06): 表示Carol在2024年1月6日购买了Book</p> </li><li> <p>(Bob, Notebook, 2024-01-07): 表示Bob在2024年1月7日购买了Notebook</p> <p><img src="https://images2.imgbox.com/2d/a0/KfRd8ZXE_o.png" alt="在这里插入图片描述"></p> </li></ul> 
<h3><a id="_51"></a>研究背景</h3> 
<p>在许多现实世界的应用中，例如作者-论文网络、用户-物品网络等，不同实体之间的关系可以自然地表示为双向图。双向图由两类顶点和连接它们的边组成，这些边只在不同类别的顶点之间存在。在时间双向图中，边不仅连接不同类别的顶点，还带有时间戳，表示这种关系在某一特定时间发生或存在。随着时间的推移，这些关系会发生变化，形成时间双向图。传统的凝聚子图(密集子图)模型没有考虑时间维度，因此无法捕捉关系的动态变化。为了弥补这一不足，本文提出了时间双向图上的（α, β, T）-core模型。</p> 
<h3><a id="_55"></a>研究问题</h3> 
<p>本文研究的问题是在时间双向图上找到满足给定度约束的最大子图。具体来说，给定时间窗口T=[ts, te]，以及度约束α和β，目标是找到一个子图，使得在该时间窗口内，上层和下层顶点的度分别至少为α和β。</p> 
<h3><a id="_59"></a>主要贡献</h3> 
<ol><li><strong>提出新的凝聚子图模型（α, β, T）-core</strong>：该模型结合了时间维度，能够捕捉关系的动态变化。</li><li><strong>设计了高效的索引结构</strong>：包括顶点分区历史索引（VH-Index）、时间分区历史索引（TH-Index）和时间交集索引（TH*-Index），以提高查询效率。</li><li><strong>开发了高效的构建和查询算法</strong>：提出了顺序和并行算法，用于高效构建时间交集索引。</li><li><strong>实验验证</strong>：在10个真实数据集上进行了大量实验，验证了模型和算法的有效性和效率。</li></ol> 
<h3><a id="_66"></a>预备知识</h3> 
<p>本文使用了一些基本的数学符号和定义：</p> 
<ul><li><strong>时间双向图G(V, E)</strong>：V表示顶点集，E表示带有时间戳的边集。</li><li><strong>U(G)和L(G)</strong>：分别表示上层和下层顶点集。</li><li><strong>快照G[ts, te]</strong>：表示在时间窗口[ts, te]内的子图。</li><li><strong>度和邻居</strong>：顶点u在图G中的度表示为deg(u, G)，邻居集表示为N(u)。</li></ul> 
<h3><a id="_75"></a>索引的基本思想</h3> 
<ol><li> <h4><a id="VHIndex_77"></a><strong>顶点分区历史索引（VH-Index）</strong>：</h4> 
  <ul><li><strong>基本思想</strong>：存储每个顶点在不同时间窗口内的状态，以便快速检索满足（α, β, T）-core条件的顶点。</li><li><strong>实现方式</strong>：对于每个顶点u，VH-Index存储所有可能的（α, β, T）-core组合的时间窗口。</li></ul> </li><li> <h4><a id="THIndex_82"></a><strong>时间分区历史索引（TH-Index）</strong>：</h4> 
  <ul><li><strong>基本思想</strong>：通过按时间存储顶点，减少查询过程中需要访问的顶点数量。</li><li><strong>实现方式</strong>：TH-Index按时间分区存储顶点，将每个时间窗口内的（α, β, T）-core顶点集合存储在一起。</li></ul> </li><li> <h4><a id="THIndex_87"></a><em><em>时间交集索引（TH</em>-Index）</em>*：</h4> 
  <ul><li><strong>基本思想</strong>：结合VH-Index和TH-Index的优点，既减少存储空间，又提高查询效率。</li><li><strong>实现方式</strong>：通过存储代表性的时间点，减少冗余信息的存储，并在查询时进行交集计算。</li></ul> </li></ol> 
<h3><a id="_92"></a>索引的构建</h3> 
<ol><li> <h4><a id="VHIndex_94"></a><strong>顶点分区历史索引（VH-Index）</strong>：</h4> 
  <ul><li>步骤： 
    <ol><li>对于每个顶点u和每个可能的α、β组合，计算u在不同时间窗口内的状态。</li><li>存储每个顶点在不同时间窗口内的状态，以便快速查询。</li></ol> </li><li>构建算法： 
    <ul><li>通过对图进行多次遍历，依次计算每个顶点在各个时间窗口内的（α, β, T）-core状态，并将这些状态存储在VH-Index中。</li></ul> </li></ul> </li><li> <h4><a id="THIndex_102"></a><strong>时间分区历史索引（TH-Index）</strong>：</h4> 
  <ul><li> <p>步骤：</p> 
    <ol><li>按时间窗口对图进行分割，计算每个时间窗口内的（α, β, T）-core顶点集合。</li><li>存储这些顶点集合，以便快速查询。</li></ol> </li><li> <p>构建算法：</p> 
    <ul><li> <p>对于每个时间窗口，计算（α, β, T）-core，并将结果存储在相应的时间分区中。</p> <p><img src="https://images2.imgbox.com/a8/b0/05Wv39sj_o.png" alt="在这里插入图片描述"></p> </li></ul> </li></ul> </li><li> <h4><a id="THIndex_116"></a><em><em>时间交集索引（TH</em>-Index）</em>*：</h4> 
  <ul><li>步骤： 
    <ol><li>选取代表性的时间点，计算这些时间点内的（α, β, T）-core。</li><li>存储这些代表性时间点的结果，减少冗余信息。</li><li>在查询时，通过这些代表性时间点进行交集计算，快速得到查询结果。</li></ol> </li><li>构建算法： 
    <ul><li>通过逐步增加时间窗口的大小，计算并存储代表性时间点的（α, β, T）-core，并将结果存储在TH*-Index中。</li></ul> </li></ul> </li></ol> 
<h4><a id="_125"></a>查询</h4> 
<ol><li> <h5><a id="VHIndex_127"></a><strong>基于顶点分区历史索引（VH-Index）的查询</strong>：</h5> 
  <ul><li> <p>步骤：</p> 
    <ol><li>根据查询参数α、β和时间窗口T=[ts, te]，在VH-Index中查找每个顶点u的状态。</li><li>通过二分搜索找到满足条件的时间窗口，收集符合条件的顶点。</li></ol> </li><li> <p>算法</p> <pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">query_vh_index</span><span class="token punctuation">(</span>VH_Index<span class="token punctuation">,</span> alpha<span class="token punctuation">,</span> beta<span class="token punctuation">,</span> ts<span class="token punctuation">,</span> te<span class="token punctuation">)</span><span class="token punctuation">:</span>
    result <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> vertex <span class="token keyword">in</span> VH_Index<span class="token punctuation">:</span>
        time_windows <span class="token operator">=</span> VH_Index<span class="token punctuation">[</span>vertex<span class="token punctuation">]</span><span class="token punctuation">[</span>alpha<span class="token punctuation">]</span><span class="token punctuation">[</span>beta<span class="token punctuation">]</span>
        <span class="token keyword">for</span> window <span class="token keyword">in</span> time_windows<span class="token punctuation">:</span>
            <span class="token keyword">if</span> window<span class="token punctuation">.</span>start <span class="token operator">&gt;=</span> ts <span class="token keyword">and</span> window<span class="token punctuation">.</span>end <span class="token operator">&lt;=</span> te<span class="token punctuation">:</span>
                result<span class="token punctuation">.</span>add<span class="token punctuation">(</span>vertex<span class="token punctuation">)</span>
    <span class="token keyword">return</span> result
</code></pre> </li></ul> </li><li> <h5><a id="THIndex_147"></a><strong>基于时间分区历史索引（TH-Index）的查询</strong>：</h5> </li></ol> 
<ul><li>步骤： 
  <ol><li>根据查询参数α、β和时间窗口T=[ts, te]，在TH-Index中查找相应时间窗口内的顶点集合。</li><li>通过二分搜索找到符合条件的顶点集合，返回结果。</li></ol> </li><li><strong>算法</strong>：</li></ul> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">query_th_index</span><span class="token punctuation">(</span>TH_Index<span class="token punctuation">,</span> alpha<span class="token punctuation">,</span> beta<span class="token punctuation">,</span> ts<span class="token punctuation">,</span> te<span class="token punctuation">)</span><span class="token punctuation">:</span>
    result <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> t <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>ts<span class="token punctuation">,</span> te <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> TH_Index<span class="token punctuation">[</span>alpha<span class="token punctuation">]</span><span class="token punctuation">[</span>beta<span class="token punctuation">]</span><span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">:</span>
            result<span class="token punctuation">.</span>update<span class="token punctuation">(</span>TH_Index<span class="token punctuation">[</span>alpha<span class="token punctuation">]</span><span class="token punctuation">[</span>beta<span class="token punctuation">]</span><span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> result
</code></pre> 
<ol start="3"><li> <h5><a id="THIndex_163"></a><strong>基于时间交集索引（TH*-Index）的查询</strong>：</h5> </li></ol> 
<ul><li> <p>步骤：</p> 
  <ol><li>根据查询参数α、β和时间窗口T=[ts, te]，分别在TH*-Index的前向索引和后向索引中查找符合条件的顶点集合。</li><li>计算前向索引和后向索引的交集，得到最终结果。</li></ol> </li><li> <p><strong>算法</strong>：</p> <pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">query_th_star_index</span><span class="token punctuation">(</span>TH_Star_Index<span class="token punctuation">,</span> alpha<span class="token punctuation">,</span> beta<span class="token punctuation">,</span> ts<span class="token punctuation">,</span> te<span class="token punctuation">)</span><span class="token punctuation">:</span>
    forward_result <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    backward_result <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    
    <span class="token comment"># 查询前向索引</span>
    <span class="token keyword">for</span> t <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>ts<span class="token punctuation">,</span> TH_Star_Index<span class="token punctuation">.</span>max_time<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> TH_Star_Index<span class="token punctuation">.</span>forward<span class="token punctuation">[</span>alpha<span class="token punctuation">]</span><span class="token punctuation">[</span>beta<span class="token punctuation">]</span><span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">:</span>
            forward_result<span class="token punctuation">.</span>update<span class="token punctuation">(</span>TH_Star_Index<span class="token punctuation">.</span>forward<span class="token punctuation">[</span>alpha<span class="token punctuation">]</span><span class="token punctuation">[</span>beta<span class="token punctuation">]</span><span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">)</span>
    
    <span class="token comment"># 查询后向索引</span>
    <span class="token keyword">for</span> t <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>te<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> TH_Star_Index<span class="token punctuation">.</span>backward<span class="token punctuation">[</span>alpha<span class="token punctuation">]</span><span class="token punctuation">[</span>beta<span class="token punctuation">]</span><span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">:</span>
            backward_result<span class="token punctuation">.</span>update<span class="token punctuation">(</span>TH_Star_Index<span class="token punctuation">.</span>backward<span class="token punctuation">[</span>alpha<span class="token punctuation">]</span><span class="token punctuation">[</span>beta<span class="token punctuation">]</span><span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">)</span>
    
    <span class="token comment"># 计算交集</span>
    <span class="token keyword">return</span> forward_result<span class="token punctuation">.</span>intersection<span class="token punctuation">(</span>backward_result<span class="token punctuation">)</span>
</code></pre> </li></ul> 
<h3><a id="_191"></a>实验结果</h3> 
<ol><li> <p><strong>实验设置</strong>：实验在10个真实数据集上进行，评估模型和算法的性能。</p> </li><li> <p><strong>结果分析</strong>：结果表明，提出的模型和算法在不同数据集上的表现优异，查询效率和索引构建时间均有显著提升。</p> <p><img src="https://images2.imgbox.com/e2/36/TYS2lycK_o.png" alt="在这里插入图片描述"></p> <p>图7展示了不同数据集上构建TH*-Index的内存使用情况和时间成本。黑色柱状图表示原始图的大小，白色柱状图表示TH*-Index的大小，折线图（带三角形标记）表示构建TH*-Index所需的时间。可以观察到，大多数情况下，TH*-Index的大小显著大于原始图的大小，这表明索引构建会增加内存开销。同时，构建TH*-Index的时间随数据集大小的增加而显著增加，尤其是在较大的数据集（如RU）上，构建时间超过了10^5秒。尽管构建TH*-Index需要较大的内存和时间成本，但它显著提高了查询效率，特别是在需要频繁查询的大规模时间双向图上。因此，对于这些场景，构建TH*-Index是值得的，而在较小数据集或查询频率较低的场景下，则需要权衡索引构建的必要性。</p> <p><img src="https://images2.imgbox.com/cc/79/n47nGJpg_o.png" alt="在这里插入图片描述"></p> </li></ol> 
<h3><a id="_205"></a>结论</h3> 
<p>本文提出了第一个适用于时间双向图的凝聚子图模型（α, β, T）-core，并设计了高效的索引结构和算法。通过大量实验验证，本文提出的方法在实际应用中具有很高的效率和实用性。未来的研究方向可以包括进一步优化索引结构和算法，以处理更大规模的时间双向图。此外，可以探索该模型在更多实际应用中的潜力，例如社交网络中的社区检测、电子商务中的推荐系统、以及生物网络中的功能模块识别等。这些应用可以利用本文提出的模型和算法，来有效地分析和挖掘数据中的动态关系，从而提供更有价值的见解和服务。</p> 
<p>论文地址:https://www.researchgate.net/publication/382506975_Querying_Historical_Cohesive_Subgraphs_Over_Temporal_Bipartite_Graphs</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e41a71f0433c09ea282abd1d60688d6d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于Java Swing &#43; MySQL的飞机航空机票订票系统（客户端）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/173a6aee0a397c4be2687e2fee677661/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【AI学习】[2024北京智源大会]具身智能：具身智能关键技术研究：操纵、决策、导航</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>