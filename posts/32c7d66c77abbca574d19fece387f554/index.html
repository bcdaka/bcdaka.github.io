<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>常用中间件redis，kafka及其测试方法 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/32c7d66c77abbca574d19fece387f554/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="常用中间件redis，kafka及其测试方法">
  <meta property="og:description" content="常用消息中间件及其测试方法 一、中间件的使用场景引入中间件的目的一般有两个：1、提升性能常用的中间件：1) 高速缓存：redis2) 全文检索：ES3) 存日志：ELK架构4) 流量削峰：kafka 2、提升可用性产品架构中高可用设计：1) 分布式锁：redis2) 数据分布式存储：redis，es，kafka 二、Redis1、redis 的数据同步策略以及数据一致性保证？2、哨兵模式的设计架构，如何理解读写分离，选举和脑裂1、什么是哨兵？2、哨兵的配置文件3、网络分区故障网络故障：1）master节点和哨兵节点出现网络故障：2）master节点和slave节点出现网络分区故障： 4、脑裂是什么，怎么解决？ 3、缓存失效下的熔断和降级以及测试方法1、造成缓存失效的几种情况？2、采取的应对策略？3、 如何模拟redis缓存失效？ 4、缓存击穿下的处理方法和测试方法1、什么是缓存击穿？2、缓存击穿解决方案？ 5、缓存穿透下的测试方法1、什么是缓存穿透？2、缓存穿透的解决方案？3、如何测试？ 6、淘汰缓存还是更新缓存1、缓存操作方式1）读操作流程？2）写操作流程：淘汰缓存 or更新缓存？3）写操作：先淘汰缓存再更新数据库 or 先更新数据库再淘汰缓存？ 7、缓存雪崩的测试方法1、如何处理雪崩？2、如何模拟雪崩？ 三、Kafka1、kafka的两个常用场景？2、为什么要用消息队列？3、和其他消息队列相比，kafka的优势在哪里？4、队列模型了解吗？Kafka 的消息模型知道吗？5、什么是Producer、Consumer、Broker、Topic、Partition？6、Kafka 的多副本机制了解吗？带来了什么好处？7、Zookeeper 在 Kafka 中的作用知道吗？8、Kafka 如何保证消息的消费顺序？9、Kafka 如何保证消息不重复消费？10、如何测试kafka？ 一、中间件的使用场景 引入中间件的目的一般有两个： 1、提升性能 产品架构中的性能设计： 常用的中间件： 1) 高速缓存：redis 基于内存，所以比mysql块（存在磁盘io）为什么查询速度快？ 单进程&#43;IO多路复用去提高性能基于内存 做缓存，极大缓解了数据库压力非常适合读多写少的场景 2) 全文检索：ES 适用于大量搜索的场景用的倒排索引，应对读多写少的场景mysql用的正序索引，应对写多读少的场景 3) 存日志：ELK架构 logstash收集日志（目前已经被filebeat替代），然后存入es，再通过kibana展示
4) 流量削峰：kafka 目前最流行的消息中间件 2、提升可用性 产品架构中高可用设计： 1) 分布式锁：redis 应用场景：解决高可用设计中多实例部署下数据访问加锁的问题
2) 数据分布式存储：redis，es，kafka 自身就有非常好的高可用设计，都是集群，可以分布式部署，集群中一台挂了，其他机器也能继续提供服务。数据保存到这些软件，也是分布式部署，可以保证都有相应备份，即使一台挂了，其他机器也可以对外提供服务，也可以确保机器更加安全。 二、Redis 1、redis 的数据同步策略以及数据一致性保证？ 现在软件架构非常复杂，面对数以万计的qps的情况下，如果单台机器到达性能瓶颈，需要一种横向扩展策略，希望把用户请求用负载均衡方式分布在其他机器分担压力。当把所有数据分布到不同机器时候，如何保证每一台机器的数据是完全一致的呢？
为了提升性能，必须使用集群部署，比如我们现在要一主两从架构进行部署，我们可以把写请求发送到主节点，把读请求发送到从节点，以降低主节点的压力（读写分离的意义）。如果保证主从节点的数据是一致的呢，我们就需要数据同步策略（异步同步）
2、哨兵模式的设计架构，如何理解读写分离，选举和脑裂 1、什么是哨兵？ 哨兵是redis官方推荐的集群高可用解决方案它能够自动识别redis集群的健康状态并在master节点异常时将从节点提升为master节点 2、哨兵的配置文件 3、网络分区故障 高可用测试最常注入的故障类型之一 网络故障： 1）master节点和哨兵节点出现网络故障： 1、出现在master节点和哨兵节点之间。比如用户和master节点是正常的，但是master和哨兵节点连接不上，会造成哨兵认为master挂了，开始新一轮选举过程。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-25T00:54:43+08:00">
    <meta property="article:modified_time" content="2024-03-25T00:54:43+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">常用中间件redis，kafka及其测试方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>常用消息中间件及其测试方法</h4> 
 <ul><li><ul><li><ul><li><a href="#_2" rel="nofollow">一、中间件的使用场景</a></li><li><ul><li><a href="#_3" rel="nofollow">引入中间件的目的一般有两个：</a></li><li><ul><li><a href="#1_4" rel="nofollow">1、提升性能</a></li><li><a href="#_6" rel="nofollow">常用的中间件：</a></li><li><ul><li><a href="#1_redis_7" rel="nofollow">1) 高速缓存：redis</a></li><li><a href="#2_ES_14" rel="nofollow">2) 全文检索：ES</a></li><li><a href="#3_ELK_18" rel="nofollow">3) 存日志：ELK架构</a></li><li><a href="#4_kafka_22" rel="nofollow">4) 流量削峰：kafka</a></li></ul> 
      </li><li><a href="#2_24" rel="nofollow">2、提升可用性</a></li><li><a href="#_25" rel="nofollow">产品架构中高可用设计：</a></li><li><ul><li><a href="#1_redis_26" rel="nofollow">1) 分布式锁：redis</a></li><li><a href="#2_rediseskafka_31" rel="nofollow">2) 数据分布式存储：redis，es，kafka</a></li></ul> 
     </li></ul> 
    </li></ul> 
    </li><li><a href="#Redis_34" rel="nofollow">二、Redis</a></li><li><ul><li><a href="#1redis__35" rel="nofollow">1、redis 的数据同步策略以及数据一致性保证？</a></li><li><a href="#2_41" rel="nofollow">2、哨兵模式的设计架构，如何理解读写分离，选举和脑裂</a></li><li><ul><li><a href="#1_42" rel="nofollow">1、什么是哨兵？</a></li><li><a href="#2_45" rel="nofollow">2、哨兵的配置文件</a></li><li><a href="#3_47" rel="nofollow">3、网络分区故障</a></li><li><a href="#_49" rel="nofollow">网络故障：</a></li><li><ul><li><a href="#1master_50" rel="nofollow">1）master节点和哨兵节点出现网络故障：</a></li><li><a href="#2masterslave_59" rel="nofollow">2）master节点和slave节点出现网络分区故障：</a></li></ul> 
      </li><li><a href="#4_63" rel="nofollow">4、脑裂是什么，怎么解决？</a></li></ul> 
     </li><li><a href="#3_69" rel="nofollow">3、缓存失效下的熔断和降级以及测试方法</a></li><li><ul><li><a href="#1_70" rel="nofollow">1、造成缓存失效的几种情况？</a></li><li><a href="#2_75" rel="nofollow">2、采取的应对策略？</a></li><li><a href="#3_redis_79" rel="nofollow">3、 如何模拟redis缓存失效？</a></li></ul> 
     </li><li><a href="#4_85" rel="nofollow">4、缓存击穿下的处理方法和测试方法</a></li><li><ul><li><a href="#1_86" rel="nofollow">1、什么是缓存击穿？</a></li><li><a href="#2_88" rel="nofollow">2、缓存击穿解决方案？</a></li></ul> 
     </li><li><a href="#5_95" rel="nofollow">5、缓存穿透下的测试方法</a></li><li><ul><li><a href="#1_96" rel="nofollow">1、什么是缓存穿透？</a></li><li><a href="#2_98" rel="nofollow">2、缓存穿透的解决方案？</a></li><li><a href="#3_103" rel="nofollow">3、如何测试？</a></li></ul> 
     </li><li><a href="#6_106" rel="nofollow">6、淘汰缓存还是更新缓存</a></li><li><ul><li><a href="#1_107" rel="nofollow">1、缓存操作方式</a></li><li><ul><li><a href="#1_109" rel="nofollow">1）读操作流程？</a></li><li><a href="#2_or_114" rel="nofollow">2）写操作流程：淘汰缓存 or更新缓存？</a></li><li><a href="#3_or__123" rel="nofollow">3）写操作：先淘汰缓存再更新数据库 or 先更新数据库再淘汰缓存？</a></li></ul> 
     </li></ul> 
     </li><li><a href="#7_135" rel="nofollow">7、缓存雪崩的测试方法</a></li><li><ul><li><a href="#1_137" rel="nofollow">1、如何处理雪崩？</a></li><li><a href="#2_141" rel="nofollow">2、如何模拟雪崩？</a></li></ul> 
    </li></ul> 
    </li><li><a href="#Kafka_144" rel="nofollow">三、Kafka</a></li><li><ul><li><a href="#1kafka_145" rel="nofollow">1、kafka的两个常用场景？</a></li><li><a href="#2_151" rel="nofollow">2、为什么要用消息队列？</a></li><li><a href="#3kafka_155" rel="nofollow">3、和其他消息队列相比，kafka的优势在哪里？</a></li><li><a href="#4Kafka__161" rel="nofollow">4、队列模型了解吗？Kafka 的消息模型知道吗？</a></li><li><a href="#5ProducerConsumerBrokerTopicPartition_163" rel="nofollow">5、什么是Producer、Consumer、Broker、Topic、Partition？</a></li><li><a href="#6Kafka__170" rel="nofollow">6、Kafka 的多副本机制了解吗？带来了什么好处？</a></li><li><a href="#7Zookeeper__Kafka__175" rel="nofollow">7、Zookeeper 在 Kafka 中的作用知道吗？</a></li><li><a href="#8Kafka__179" rel="nofollow">8、Kafka 如何保证消息的消费顺序？</a></li><li><a href="#9Kafka__184" rel="nofollow">9、Kafka 如何保证消息不重复消费？</a></li><li><a href="#10kafka_189" rel="nofollow">10、如何测试kafka？</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h4><a id="_2"></a>一、中间件的使用场景</h4> 
<h5><a id="_3"></a>引入中间件的目的一般有两个：</h5> 
<ul><li> <h6><a id="1_4"></a>1、提升性能</h6> 
  <ul><li>产品架构中的性能设计：</li><li> <h6><a id="_6"></a>常用的中间件：</h6> 
    <ul><li> <h6><a id="1_redis_7"></a>1) 高速缓存：redis</h6> 
      <ul><li>基于内存，所以比mysql块（存在磁盘io）</li><li>为什么查询速度快？ 
        <ul><li>单进程+IO多路复用去提高性能</li><li>基于内存</li></ul> </li><li>做缓存，极大缓解了数据库压力</li><li>非常适合<code>读多写少</code>的场景</li></ul> </li><li> <h6><a id="2_ES_14"></a>2) 全文检索：ES</h6> 
      <ul><li>适用于大量搜索的场景</li><li>用的<code>倒排索引</code>，应对读多写少的场景</li><li>mysql用的正序索引，应对写多读少的场景</li></ul> </li><li> <h6><a id="3_ELK_18"></a>3) 存日志：ELK架构</h6> 
      <ul><li>logstash收集日志（目前已经被filebeat替代），然后存入es，再通过kibana展示<br> <img src="https://images2.imgbox.com/43/4d/GRjb4yVM_o.png" alt="在这里插入图片描述"></li></ul> </li><li> <h6><a id="4_kafka_22"></a>4) 流量削峰：kafka</h6> 
      <ul><li>目前最流行的消息中间件</li></ul> </li></ul> </li></ul> </li><li> <h6><a id="2_24"></a>2、提升可用性</h6> 
  <ul><li> <h6><a id="_25"></a>产品架构中高可用设计：</h6> </li><li> <h6><a id="1_redis_26"></a>1) 分布式锁：redis</h6> 
    <ul><li>应用场景：解决高可用设计中多实例部署下数据访问加锁的问题<br> <img src="https://images2.imgbox.com/d2/ac/zCtH3bhC_o.png" alt="在这里插入图片描述"></li></ul> </li><li> <h6><a id="2_rediseskafka_31"></a>2) 数据分布式存储：redis，es，kafka</h6> 
    <ul><li>自身就有非常好的高可用设计，都是集群，可以分布式部署，集群中一台挂了，其他机器也能继续提供服务。数据保存到这些软件，也是分布式部署，可以保证都有相应备份，即使一台挂了，其他机器也可以对外提供服务，也可以确保机器更加安全。</li></ul> </li></ul> </li></ul> 
<h4><a id="Redis_34"></a>二、Redis</h4> 
<h5><a id="1redis__35"></a>1、redis 的数据同步策略以及数据一致性保证？</h5> 
<ul><li>现在软件架构非常复杂，面对数以万计的qps的情况下，如果单台机器到达性能瓶颈，需要一种横向扩展策略，希望把用户请求用负载均衡方式分布在其他机器分担压力。当把所有数据分布到不同机器时候，如何保证每一台机器的数据是完全一致的呢？<br> <img src="https://images2.imgbox.com/2a/e2/mzB7PDzd_o.png" alt="在这里插入图片描述"></li><li>为了提升性能，必须使用集群部署，比如我们现在要一主两从架构进行部署，我们可以把写请求发送到主节点，把读请求发送到从节点，以降低主节点的压力（读写分离的意义）。如果保证主从节点的数据是一致的呢，我们就需要数据同步策略（异步同步）<br> <img src="https://images2.imgbox.com/12/f5/kffJr0m6_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/6b/fe/tTIzi8EF_o.png" alt="在这里插入图片描述"></li></ul> 
<h5><a id="2_41"></a>2、哨兵模式的设计架构，如何理解读写分离，选举和脑裂</h5> 
<h6><a id="1_42"></a>1、什么是哨兵？</h6> 
<ul><li>哨兵是redis官方推荐的集群高可用解决方案</li><li>它能够自动识别redis集群的健康状态并在master节点异常时将从节点提升为master节点</li></ul> 
<h6><a id="2_45"></a>2、哨兵的配置文件</h6> 
<p><img src="https://images2.imgbox.com/be/49/m6skqbNl_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="3_47"></a>3、网络分区故障</h6> 
<ul><li>高可用测试最常注入的故障类型之一</li><li> <h6><a id="_49"></a>网络故障：</h6> </li><li> <h6><a id="1master_50"></a>1）master节点和哨兵节点出现网络故障：</h6> 
  <ul><li>1、出现在master节点和哨兵节点之间。比如用户和master节点是正常的，但是master和哨兵节点连接不上，会造成哨兵认为master挂了，开始新一轮选举过程。<br> <img src="https://images2.imgbox.com/3d/38/tP9P89Ta_o.png" alt="在这里插入图片描述"></li><li>2、这样会导致节点出现2个master节点都可以接受请求，导致脑裂。<br> <img src="https://images2.imgbox.com/31/f7/rCH3o1NV_o.png" alt="在这里插入图片描述"></li><li>3、所以哨兵必须集群状态部署，当其中一个哨兵认为master节点是下线状态，会给master节点标记<code>主观下线状态</code>，但是被标记后master节点仍然可以对外提供服务，哨兵也不会重新选举master。<br> <img src="https://images2.imgbox.com/7a/ae/bbVVdu0D_o.png" alt="在这里插入图片描述"></li><li>4、只有其他哨兵也认为主节点挂了，这时候才会触发（只有当xx哨兵认为主节点是下线状态，它才会被标记为<code>客观下线状态</code>）哨兵重新选举的功能<br> <img src="https://images2.imgbox.com/2e/1b/F2Qfh788_o.png" alt="在这里插入图片描述"></li></ul> </li><li> <h6><a id="2masterslave_59"></a>2）master节点和slave节点出现网络分区故障：</h6> 
  <ul><li>导致master节点数据没有同步到slave节点，会出现数据不一致的问题，用户读取的是旧数据</li><li>如果这个时候master节点也挂了，slave会变为master，会出现数据彻底的丢失的问题，<strong>所以连接不上的时候会禁止写请求</strong><br> <img src="https://images2.imgbox.com/86/af/Kmm91Fz3_o.png" alt="在这里插入图片描述"></li></ul> </li></ul> 
<h6><a id="4_63"></a>4、脑裂是什么，怎么解决？</h6> 
<ul><li>脑裂就是出现网络分区故障后，同时存在多个master节点。</li><li>解决方案： 
  <ul><li>1、master节点连接不上哨兵节点：只有多个哨兵标记它为主观下线状态，它才会真正的下线</li><li>2、master节点连接不上slave节点：就会禁止写操作</li></ul> </li></ul> 
<h5><a id="3_69"></a>3、缓存失效下的熔断和降级以及测试方法</h5> 
<ul><li> <h6><a id="1_70"></a>1、造成缓存失效的几种情况？</h6> 
  <ul><li>缓存过期</li><li>缓存更新：更新缓存一般采用淘汰更新，这个时候缓存取不到，就会去数据库里面取，再更新缓存。这就造成有极短的一段时间内，缓存是失效的</li><li>redis异常</li><li>网络异常</li></ul> </li><li> <h6><a id="2_75"></a>2、采取的应对策略？</h6> 
  <ul><li>禁用某些接口，只开放核心接口：非核心接口用户一请求，就直接返回异常。保证缓存失效时候核心接口可以继续工作</li><li>禁用某些服务<br> <img src="https://images2.imgbox.com/ae/13/HJWQq3Nq_o.png" alt="在这里插入图片描述"></li></ul> </li><li> <h6><a id="3_redis_79"></a>3、 如何模拟redis缓存失效？</h6> 
  <ul><li>1）你需要输入出系统的核心服务列表和服务中的核心接口列表。</li><li>2）注入故障，然后验证（非核心接口去访问时候应该是拒绝的） 
    <ul><li>直接把redis下线</li><li>注入一个网络故障 
      <ul><li>比如可以用iptables模拟断网故障，tc模拟延迟故障，也可以去下载阿里开源工具<code>chaos-blade</code>，下载后一条命令就可以模拟故障</li></ul> </li></ul> </li></ul> </li></ul> 
<h5><a id="4_85"></a>4、缓存击穿下的处理方法和测试方法</h5> 
<ul><li> <h6><a id="1_86"></a>1、什么是缓存击穿？</h6> 当redis中的某个热key（比如首页广告）过期或者因为某些异常原因导致无法从缓存中读取，导致大量的并发访问数据库而崩溃</li><li> <h6><a id="2_88"></a>2、缓存击穿解决方案？</h6> 
  <ul><li>首先要和运维沟通，确认线上哪些key是热key。如果不知道哪些key是热key，我们压测的时候，可以使用比较大的并发去压，然后登录到redis，手动删除这条缓存，人为模拟热key过期的场景，再看系统的反应，会不会触发熔断和降级策略</li><li>对于固定热key可以不设置失效时间，通过人工手动去维护</li><li>利用熔断和降级策略，同上 
    <ul><li>禁用某些接口，只开放核心接口：非核心接口用户一请求，就直接返回异常。保证缓存失效时候核心接口可以继续工作</li><li>禁用某些服务<br> <img src="https://images2.imgbox.com/10/5b/67gOoxWD_o.png" alt="在这里插入图片描述"></li></ul> </li></ul> </li></ul> 
<h5><a id="5_95"></a>5、缓存穿透下的测试方法</h5> 
<ul><li> <h6><a id="1_96"></a>1、什么是缓存穿透？</h6> 数据既不存在在缓存中，也不存在在数据库中。常见一些网络攻击场景以及前端逻辑错误时发生。</li><li> <h6><a id="2_98"></a>2、缓存穿透的解决方案？</h6> 
  <ul><li>采用布隆过滤器 
    <ul><li>误判率。布隆过滤器有一定的误判率，但这种误判通常发生在未曾添加到过滤器中的元素上。对于已添加的元素，过滤器能正确判断其存在与否。</li><li>预校验。在查询数据前，可以先使用布隆过滤器进行预校验，判断数据是否可能存在。如果数据不存在，可以直接返回空结果，避免了对底层存储系统的不必要访问。</li></ul> </li><li>如果一个查询返回的数据为空，不管数据是否存在或系统故障，都把空的数据进行缓存，只不过过期时间比较短。这样下一次查询就有数据可以返回</li></ul> </li><li> <h6><a id="3_103"></a>3、如何测试？</h6> 通过接口请求方式发送不存在缓存和数据库的查询请求，验证系统是否可以处理大量既不存在在缓存中，也不存在在数据库中的数据。</li></ul> 
<h5><a id="6_106"></a>6、淘汰缓存还是更新缓存</h5> 
<ul><li> <h6><a id="1_107"></a>1、缓存操作方式</h6> redis是高速缓存组件，需要跟数据库进行频繁交流才能让缓存生效。缓存操作方式就需要一定的步骤和规则，如果出错，就会导致出现bug 
  <ul><li> <h6><a id="1_109"></a>1）读操作流程？</h6> 
    <ul><li>先查询redis，如果redis有数据，就直接返回redis数据</li><li>如果redis没有数据，就从数据库中读取数据 
      <ul><li><code>读取数据库是有延迟的</code>，是比较慢的操作，所以在高并发下，可能不仅有一次的读请求会从数据库中读取数据。因为假如说我们第一个请求过来之后，它还没有完成把数据库的数据更新到redis缓存的时候，其他并发也过来了，就会导致在一个比较瞬时的状态的时候，会有相当多的读数据库的请求出现</li></ul> </li><li>从数据库读取数据后，更新redis缓存</li></ul> </li><li> <h6><a id="2_or_114"></a>2）写操作流程：淘汰缓存 or更新缓存？</h6> 
    <ul><li>淘汰缓存 
      <ul><li>优点是操作简单</li><li>缺点是淘汰后下一次请求就会读取数据库</li></ul> </li><li>更新缓存 
      <ul><li>数据库更新完了之后，就会更新缓存的内容。</li><li>优点是不会出现下一次cache miss</li><li>缺点是代价比较大（比如更新操作涉及到好几张表，会导致性能差，延缓更新缓存时间。如果在更新的时候其他的读请求进来了，会造成数据不一致的情况，可能会读到旧的数据）</li></ul> </li><li>结论：淘汰缓存作为通用方案</li></ul> </li><li> <h6><a id="3_or__123"></a>3）写操作：先淘汰缓存再更新数据库 or 先更新数据库再淘汰缓存？</h6> 
    <ul><li>先更新数据库：如果更新数据库后还没来得及淘汰缓存服务就挂掉了，那么就会出现脏数据</li><li>先淘汰缓存：如果淘汰缓存后更新数据库之前的这段时间有其他的读请求发送过来，就会把老数据读取到redis缓存中 
      <ul><li>但是他在复杂场景下还是可能遇到数据不一致问题，比如写操作出现问题，比如所在磁盘io特别高，导致写缓存和更新数据库操作比较慢，可能会出现如下问题，当把淘汰缓存执行完还没有更新数据库的时候，另一个请求过来读取缓存，取的仍然是旧的值<br> <img src="https://images2.imgbox.com/4a/60/Z9uoQG3O_o.png" alt="在这里插入图片描述"></li></ul> </li><li>结论：先淘汰缓存，可以使用延迟双删策略弥补缺陷 
      <ul><li>延迟双删是什么？ 
        <ul><li>1）先删除缓存</li><li>2）再写数据库</li><li>3）休眠500毫秒（根据具体业务时间来定）</li><li>4）再次删除缓存<br> <img src="https://images2.imgbox.com/81/e8/PhAutEha_o.png" alt="在这里插入图片描述"></li></ul> </li></ul> </li></ul> </li></ul> <h5><a id="7_135"></a>7、缓存雪崩的测试方法</h5> 当redis中大量缓存在一个较短的时间内全部过期，导致于在一个瞬间时间内大量的请求直接访问数据库，造成数据库崩溃 
  <ul><li> <h6><a id="1_137"></a>1、如何处理雪崩？</h6> 
    <ul><li>一般会采用熔断或降级策略。 
      <ul><li>禁用某些接口，只开放核心接口：非核心接口用户一请求，就直接返回异常。保证缓存失效时候核心接口可以继续工作</li><li>禁用某些服务</li></ul> </li></ul> </li><li> <h6><a id="2_141"></a>2、如何模拟雪崩？</h6> 
    <ul><li>弄挂redis服务，比如在redis和服务之间注入网络分区故障，让服务连接不上redis，看看服务是否熔断或降级</li><li>写一个接口，把redis常用的缓存删了</li></ul> </li></ul> <h4><a id="Kafka_144"></a>三、Kafka</h4> <h5><a id="1kafka_145"></a>1、kafka的两个常用场景？</h5> 
  <ul><li>1） 流量削峰 
    <ul><li>先将短时间高并发产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息，这样就避免直接把后端服务打垮掉</li></ul> </li><li>2） 流计算 
    <ul><li>大数据处理的一种<br> <img src="https://images2.imgbox.com/6c/e5/BwesZdfO_o.png" alt="在这里插入图片描述"></li></ul> </li></ul> <h5><a id="2_151"></a>2、为什么要用消息队列？</h5> 
  <ul><li>1、通过异步处理提高系统性能（减少响应所需时间）</li><li>2、降低系统耦合性：生产者（客户端）发送消息到消息队列中去，接收者（服务端）处理消息，需要消费的系统直接去消息队列取消息进行消费即可而不需要和其他系统有耦合，也提高了系统的扩展性。</li><li>3、流量削锋：先将短时间高并发产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息，这样就避免直接把后端服务打垮掉。</li></ul> <h5><a id="3kafka_155"></a>3、和其他消息队列相比，kafka的优势在哪里？</h5> 
  <ul><li>1、极致的性能：最快可以每秒处理千万级别的数据</li><li>2、和其他生态系统的兼容性好：Kafka 与周边生态系统的兼容性是最好的没有之一，特别是在大数据和流计算领域</li><li>Kafka 主要有两大应用场景： 
    <ul><li>消息队列 ：建立实时流数据管道，以可靠地在系统或应用程序之间获取数据。</li><li>数据处理： 构建实时的流数据处理程序来转换或处理数据流。</li></ul> </li></ul> <h5><a id="4Kafka__161"></a>4、队列模型了解吗？Kafka 的消息模型知道吗？</h5> 早期的队列模型就是生产者把消息发到消息队列，然后消费者从消息队列去取消息，但是这样做有个弊端，就是如果这个消息需要发送给多个消费者，每个消费者都要收到完整的内容，这种情况队列模型就不好解决了。kafka用的是发布订阅的消息模型，用topic作为消息载体，相当于是广播模型。只要生产者把消息发到topic里，该条消息通过主题传递的方式通知所有的消费者<h5><a id="5ProducerConsumerBrokerTopicPartition_163"></a>5、什么是Producer、Consumer、Broker、Topic、Partition？</h5> 
  <ul><li>producer：生产者，生产消息的人</li><li>consumer：消费者，消费消息的人</li><li>broker：代理，相当于kafka的实例，多个broker可以构成一个cluster[ˈklʌstə®]（集群），broker里面包含topic和partition</li><li>topic：主题，消费者可以通过订阅topic来消费消息</li><li>partition：分区，一个topic里面可以有多个分区<br> <img src="https://images2.imgbox.com/74/d0/1Fmz0e4w_o.png" alt="在这里插入图片描述"></li></ul> <h5><a id="6Kafka__170"></a>6、Kafka 的多副本机制了解吗？带来了什么好处？</h5> 每个分区里都有多个副本，副本里面又有一个leader副本和多个follower副本，follower副本是从leader副本里面拉取消息进行同步，相当于leader副本的拷贝。当leader副本出现问题的时候，会从follower副本里面选取新的leader。生产者和消费者只和leader副本做交互。<br> 好处： 
  <ul><li>1、一个topic里有多个partition，然后一个partition可以在多个broker里，这样可以提升并发能力（负载均衡）</li><li>2、因为partition可以指定副本数量，这样可以提升消息存储的安全性，但是同时也相应的增加了存储空间</li></ul> </li></ul> 
<h5><a id="7Zookeeper__Kafka__175"></a>7、Zookeeper 在 Kafka 中的作用知道吗？</h5> 
<ul><li>1、broker注册：每个broker启动时候，会到zookeeper进行注册</li><li>2、topic注册：同一个topic会分成多个分区，并将其分布到多个broker，这些分区和broker对应关系由zookeeper记录</li><li>3、负载均衡：对于同一个topic里有多个partition，当生产者产生消息后，kafka会尽力的将一个partition投递到多个broker里，当消费者消费的时候，zookeeper会根据当前消费者数量和broker数量来实现动态负载均衡</li></ul> 
<h5><a id="8Kafka__179"></a>8、Kafka 如何保证消息的消费顺序？</h5> 
<p>因为kafka里消息是存放在partition里，而且每次添加消息到partition里都是采用尾追法，kafka只能保证partition里的消息有序。消息被添加到partition的时候都会分配一个特定的偏移量来保证顺序。<br> 这个时候我们就有2种方式来保证消费顺序</p> 
<ul><li>1、一个topic里只对应一个partition（不推荐）</li><li>2、发送消息的时候指定key/partition（推荐）：发送消息的时候我们可以发送topic，partition，key，data四个参数。如果指定partition的话，kafka可以把消息发送到指定的partition。并且，同一个key的消息可以保证只发送到一个partition</li></ul> 
<h5><a id="9Kafka__184"></a>9、Kafka 如何保证消息不重复消费？</h5> 
<p>根本原因：消息已经消费了，但是没有提交offset<br> 处理方案：<br> 消费方做幂等校验，比如redis分布式锁，mysql的主键等<br> enable.auto.commit设置成false，改成手动提交offset</p> 
<h5><a id="10kafka_189"></a>10、如何测试kafka？</h5> 
<ul><li>因为功能上出问题的概率不大，我们测试需要做的就是模拟producer到broker，broker到consumer之间的各种故障，再验证数据是否完整，有没有数据丢失或者重复 
  <ul><li>比如网络抖动一下后，producer推送到broker的数据丢失怎么办？一般来说会做retry操作，比如重试3次，如果3次都失败了，那么可能broker本身有问题，或者网络问题，抛异常是可以的。但是retry有副作用，假设当producer推送数据给broker，broker已经保存到本地之后，把响应返回给producer的时候失败了，这时候再retry就会导致broker重复保存数据到本地存储，造成数据重复<br> <img src="https://images2.imgbox.com/d0/75/9AFv4PE3_o.png" alt="在这里插入图片描述"></li><li>如何解决这个问题呢？ 
    <ul><li>kafka有专门的包把producer变成幂等的producer（判断是否消息之前推送过，如果是的话就不会进行第二次存储。）这个是如何实现的呢，就是根据消息生成id，producer会把消息+id一起推送到broker，broker根据消息的id和本地存储数据进行对比就可以知道消息是否重复。但是这个也有缺陷，就是只对单broker有用，多broker/partition是不行的</li><li>kafka有分布式事务的producer，保证broker不会重复保存数据。producer开了分布式事务以后，consumer也要做改动，要把消息读取变成<code>committed read</code>（只会去读取已经提交的事务）只是提供了框架，里面的逻辑是自己写的，包括consumer怎么维护offset状态，producer里事务怎么提交</li></ul> </li></ul> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9026288b20d5db28b48f23f084e81796/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">深入解析Java中锁机制以及底层原理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b428201ea8386ed84387467175960734/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">kafka3.7 集群 docker部署 springboot</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>