<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Sylar C&#43;&#43;高性能服务器学习记录01 【日志管理-知识储备篇】 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/66c09814d01ae0e09e5ed4a2148ab8ff/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Sylar C&#43;&#43;高性能服务器学习记录01 【日志管理-知识储备篇】">
  <meta property="og:description" content="早在19年5月就在某站上看到sylar的视频了，一直认为这是一个非常不错的视频。
由于本人一直是自学编程，基础不扎实，也没有任何人的督促，没能坚持下去。
每每想起倍感惋惜，遂提笔再续前缘。
为了能更好的看懂sylar，本套笔记会分两步走，每个系统都会分为两篇博客。
分别是【知识储备篇】和【代码分析篇】
(ps:纯粹做笔记的形式给自己记录下，欢迎大家评论，不足之处请多多赐教)
QQ交流群：957100923
B站视频：https://b23.tv/YusP39I
日志管理-知识储备 知识点01 （switch使用宏定义简化） 在日常编码中我们经常使用枚举
不仅可以统一管理，还能提高代码可读性，还能避免代码写错
如下是一个水果枚举类型
enum Fruit { UNKNOW = 0,	//未知 CHERRIES = 1,	//车厘子 STRABERRY = 2,	//草莓 APPLE = 3,	//苹果 WATERMELON = 4	//西瓜 }; 但是往往会有这样的情况，因为枚举中的值我们赋与的是数字 所以他方便运算但是不利于展示
//例如:我们想要输出对应枚举时 看到的是 3 而不是 APPLE std::cout &lt;&lt; Fruit::APPLE &lt;&lt; std::endl; 有时我们在数据存储时想要存储具体数值
但是在显示输出时 希望看到的是对应的枚举字段
那么我们就需要使用以下代码来进行输出时的转化
//这个方法名称我喜欢使用2来替换to fruit2string==fruitToString const char* fruit2string(Fruit fruit){ switch(fruit){ case fruit::CHERRIES: return &#34;CHERRIES&#34;; break; case fruit::STRABERRY: return &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-24T16:07:38+08:00">
    <meta property="article:modified_time" content="2024-07-24T16:07:38+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Sylar C&#43;&#43;高性能服务器学习记录01 【日志管理-知识储备篇】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>早在19年5月就在某站上看到sylar的视频了，一直认为这是一个非常不错的视频。<br> 由于本人一直是自学编程，基础不扎实，也没有任何人的督促，没能坚持下去。<br> 每每想起倍感惋惜，遂提笔再续前缘。</p> 
<p>为了能更好的看懂sylar，本套笔记会分两步走，每个系统都会分为两篇博客。<br> 分别是【知识储备篇】和【代码分析篇】<br> (ps:纯粹做笔记的形式给自己记录下，欢迎大家评论，不足之处请多多赐教)<br> QQ交流群：957100923<br> B站视频：<a href="https://b23.tv/YusP39I" rel="nofollow">https://b23.tv/YusP39I</a></p> 
<h2><a id="_9"></a>日志管理-知识储备</h2> 
<h4><a id="01_switch_10"></a>知识点01 （switch使用宏定义简化）</h4> 
<p>在日常编码中我们经常使用枚举<br> 不仅可以统一管理，还能提高代码可读性，还能避免代码写错<br> 如下是一个水果枚举类型</p> 
<pre><code class="prism language-c++">enum Fruit {
	UNKNOW = 0,		//未知
	CHERRIES = 1,	//车厘子
	STRABERRY = 2,	//草莓
	APPLE = 3,		//苹果
	WATERMELON = 4	//西瓜
};
</code></pre> 
<p>但是往往会有这样的情况，因为枚举中的值我们赋与的是数字 所以他方便运算但是不利于展示</p> 
<pre><code class="prism language-c++">//例如:我们想要输出对应枚举时 看到的是 3 而不是 APPLE 
std::cout &lt;&lt; Fruit::APPLE &lt;&lt; std::endl;
</code></pre> 
<p>有时我们在数据存储时想要存储具体数值<br> 但是在显示输出时 希望看到的是对应的枚举字段<br> 那么我们就需要使用以下代码来进行输出时的转化</p> 
<pre><code class="prism language-c++">//这个方法名称我喜欢使用2来替换to fruit2string==fruitToString 
const char* fruit2string(Fruit fruit){
	switch(fruit){
		case fruit::CHERRIES:
			return "CHERRIES";
			break;
		case fruit::STRABERRY:
			return "STRABERRY";
			break; 
		case fruit::APPLE:
			return "APPLE";
			break; 
		case fruit::WATERMELON:
			return "WATERMELON";
			break; 
		default:
			return "UNKNOW";
			break;
	}
	return "UNKNOW";	
}
</code></pre> 
<p>以上的写法没有问题 但是在C++中 并不 “优雅”<br> 所以，以下是在Sylar中常用的手法，可以说非常优雅</p> 
<pre><code class="prism language-c++">const char* fruit2string(Fruit fruit){
	switch(fruit){
#define XX(name) 		\
	case fruit::name:	\
		return #name;	\		//注意 #name 是将对应的参数名称变成了字符串(这个是核心)
		break;
		
		//宏定义是简单的文本替换 所以这里请不要加双引号，错误写法 XX("APPLE")
		XX(CHERRIES)
		XX(STRABERRY)
		XX(APPLE)
		XX(WATERMELON)
		
#undef XX
		default:
			return "UNKNOW";
			break;
	}
	return "UNKNOW";	
}
</code></pre> 
<h4><a id="02_va_list__vasprintf_C_80"></a>知识点02 （va_list 与 vasprintf 配合实现C风格的输出）</h4> 
<p>在c++中我们会用以下方式来进行输出</p> 
<pre><code class="prism language-c++">const std::string name = "XYZ";
int age = 28;
std::cout &lt;&lt; "Name: " &lt;&lt; name &lt;&lt; " " &lt;&lt; "Age: " &lt;&lt; age &lt;&lt; std::endl;
</code></pre> 
<p>但是很多人喜欢c的输出方式，这样更加简洁</p> 
<pre><code class="prism language-c++">#include &lt;stdio.h&gt;

const char* name = "XYZ";
int age = 28;
printf("Name: %s Age: %d \n",name,age);
</code></pre> 
<p>在sylar中有一个格式化的方法可以使用C风格的方式来进行字符串的格式化<br> 先解释以下为什么C中有printf我们还要自己实现一个格式化<br> 因为我们要的是格式化好了之后的字符串 而不是输出格式化后的内容<br> 所以我们需要使用 va_list 和 vasprintf来实现一个format方法返回格式化后的字符串</p> 
<pre><code class="prism language-c++">#include &lt;sstream&gt;
#include &lt;stdarg.h&gt;

std::string format(const char* fmt,...){
	std::stringstream ss;
	va_list args;
	va_start(args,fmt);
	char* buf = nullptr;
	int len = vasprintf(&amp;buf,fmt,args);
	if(len != -1){
		ss&lt;&lt;std::string(buf,len);
		free(buf);
	}
	va_end(args);
	return ss.str();
}
</code></pre> 
<h4><a id="03_RAII_117"></a>知识点03 （巧用匿名对象析构函数进行流式输出）有点RAII的意思在里面</h4> 
<p>标题不太好理解，用以下例子来解释<br> 假设我们需要一个日志对象来提供日志输出的方法，将指定字符串打印到控制台显示<br> 那么我们常规方法如下：</p> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;

//日志对象
class Logger {
public:
	//构造
	Logger();	
	//析构
	~Logger();	
	//输出日志
	void log(const std::string&amp; msg);
};
Logger::Logger(){
	std::cout &lt;&lt; "Logger()" &lt;&lt; std::endl;
}
Logger::~Logger(){
	std::cout &lt;&lt; "~Logger()" &lt;&lt; std::endl;
}
void Logger::log(const std::string&amp; msg){
	std::cout &lt;&lt; msg &lt;&lt; std::endl;
}

int main(int argc,char** argv){
	std::cout &lt;&lt; "===start===" &lt;&lt; std::endl;
	Logger lg;
	lg.log("Good good study, day day up!");
	std::cout &lt;&lt; "====end====" &lt;&lt; std::endl;
	return 0;
}
</code></pre> 
<p>以下是对应的输出</p> 
<pre><code>------------------------------------------------
===start===
Logger()
Good good study, day day up!
====end====
~Logger()
------------------------------------------------
</code></pre> 
<p>可以看到我们需要 lg.log(“Good good study, day day up!”);的方式来进行输出，这样并不方便<br> 我们希望的是 lg.getSS() &lt;&lt; “Hello” &lt;&lt; " " &lt;&lt; “Sylar” &lt;&lt; “\n”; 这样的方式来连续调用<br> 我们需要有 std::stringstream 来存储内容 并且在析构时输出<br> 以下进行改造</p> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;sstream&gt;

//日志对象
class Logger {
public:
	//构造
	Logger();	
	//析构
	~Logger();	
	std::stringstream&amp; getSS() { return m_ss; }
private:
	std::stringstream m_ss;
};
Logger::Logger(){
	std::cout &lt;&lt; "Logger()" &lt;&lt; std::endl;
}
Logger::~Logger(){
	std::cout &lt;&lt; m_ss.str() &lt;&lt; std::endl;
	std::cout &lt;&lt; "~Logger()" &lt;&lt; std::endl;
}

int main(int argc,char** argv){
	std::cout &lt;&lt; "===start===" &lt;&lt; std::endl;
	Logger lg;
	lg.getSS() &lt;&lt; "hello" &lt;&lt; " " &lt;&lt; "sylar";
	std::cout &lt;&lt; "====end====" &lt;&lt; std::endl;
	return 0;
}
</code></pre> 
<p>以下是对应的输出 输出位置是不理想的，在程序结束后对象才析构，所以输出后置了</p> 
<pre><code>------------------------------------------------
===start===
Logger()
====end====
hello sylar
~Logger()
------------------------------------------------
</code></pre> 
<p>可以看到在作用域外才能进行输出，那么输出位置将无法精准<br> 这里其实要注意：匿名对象的析构时机和具名对象的析构时机是不一样的<br> 匿名对象：执行完后立即析构<br> 具名对象(栈内)：超出作用域后析构<br> 具名对象(堆内)：手动释放后析构<br> 我们可以利用匿名对象及时析构的特点，让输出时机变得精准<br> 以下代码只需改动main方法中的调用部分即可</p> 
<pre><code class="prism language-c++">int main(int argc,char** argv){
	std::cout &lt;&lt; "===start===" &lt;&lt; std::endl;
	//改成匿名对象
	Logger().getSS() &lt;&lt; "hello" &lt;&lt; " " &lt;&lt; "sylar";
	std::cout &lt;&lt; "====end====" &lt;&lt; std::endl;
	return 0;
}
</code></pre> 
<p>以下是对应的输出 输出位置是精准的</p> 
<pre><code>------------------------------------------------
===start===
Logger()
hello sylar
~Logger()
====end====
------------------------------------------------
</code></pre> 
<p>但是这里需要 Logger().getSS() 的方式 其实还是不方便<br> 我们更希望使用：SYLAR_LOG &lt;&lt; “Hello”; 的方式来输出<br> 所以我们可以定义一个宏来完成：</p> 
<pre><code class="prism language-c++">#define SYLAR_LOG Logger().getSS()

int man(int argc,char** argv){
	std::cout &lt;&lt; "===start===" &lt;&lt; std::endl;
	//改成宏调用
	SYLAR_LOG &lt;&lt; "hello" &lt;&lt; " " &lt;&lt; "sylar";
	std::cout &lt;&lt; "====end====" &lt;&lt; std::endl;
	return 0;
}
</code></pre> 
<p>以下是对应的输出 可以看到效果是一样的但是更加舒服了</p> 
<pre><code>------------------------------------------------
===start===
Logger()
hello sylar
~Logger()
====end====
------------------------------------------------
</code></pre> 
<h4><a id="04__258"></a>知识点04 （巧用模板类实现单例）</h4> 
<p>在sylar中有一个单例的模板类,一共20几行代码却需要细细琢磨<br> 十分精湛的写法，让人叹为观止<br> 以下代码十年的功力，不知阁下如何应对<br> singleton.h</p> 
<pre><code class="prism language-c++">#ifndef __SYLAR_SINGLETON_H_
#define __SYLAR_SINGLETON_H_

namespace sylar {

//X 为了创造多个实例对应的Tag
//N 同一个Tag创造多个实例索引
template&lt;class T, class X = void, int N = 0&gt;
class Singleton {
public:
    static T* GetInstance() {
        static T v;
        return &amp;v;
    }
};

//X 为了创造多个实例对应的Tag
//N 同一个Tag创造多个实例索引
template&lt;class T, class X = void, int N = 0&gt;
class SingletonPtr {
public:
    static std::shared_ptr&lt;T&gt; GetInstance() {
        static std::shared_ptr&lt;T&gt; v(new T);
        return v;
    }
};

}

#endif
</code></pre> 
<p>这个类不太好解释，以下是我网上找的例子希望能帮助大家理解</p> 
<pre><code class="prism language-c++">#include&lt;iostream&gt;
#include&lt;stdio.h&gt;

using namespace std;

class X{
public:
	void func() { cout &lt;&lt; "XXXXXXXXXXX" &lt;&lt; endl; }
};

class Y{
public:
	void func() { cout &lt;&lt; " YYYYYYYYYY" &lt;&lt; endl; }
};

template&lt;class T, class X = void, int N = 0&gt;	
class Singleton	{
public:
	static T* GetInstance(){
		static T v;
		static int x;
		x++;
		printf("x = %d\tX: %p\n", x, &amp;x);
		return &amp;v;
	}
};

int main(int argc,char** argv){
	X* x1 = Singleton&lt;X&gt;::GetInstance();
	x1-&gt;func();
	X* x2 = Singleton&lt;X, Y&gt;::GetInstance();
	x2-&gt;func();
	X* x11 = Singleton&lt;X&gt;::GetInstance();
	x11-&gt;func();
	printf("%p\n%p\n%p\n", x1, x2, x11);
	return 0;
}
</code></pre> 
<p>以下是输出内容</p> 
<pre><code>X =1X:0x563d1eb8d154
xxxXXXXXXXX
X= 1
X:0x563d1eb8d15c
xxxxxxxxXXX
X = 2X:0x563d1eb8d154
xxXXXXXXXXX
x1:0x563d1eb8d152
x2:0x563d1eb8d158
x11:0x563d1eb8d152
</code></pre> 
<p>可以看到 <em><strong>只要模板参数一致那么得到的对象就是同一个</strong></em>也就是单例<br> 模板参数 T 是需要被单例化的类 <strong>必传的</strong><br> 模板参数 X 可以理解为 <strong>标签</strong> 这一类标签下的单例<br> 模板参数 N 可以理解为<strong>下标</strong> 这一类标签下的 n号单例<br> 其实严格来说后面两个参数的存在 违背了单例的定义 但是实际开发中确实是能够用到<br> 可以说这个模板类 包含了单例的功能 又增强了单例的功能<br> 这里举个例子（不一定恰当）</p> 
<pre><code>背景：
	一家公司在 A市 B市 C市 都各自有一个子公司
	每个子公司下都有： 
		行政部门：Adm1 Adm2
		技术部门：Tec1 Tec2
		财务部门：Fin1 Fin2
需求：
 	在整个公司系统中，每个子公司的每个部门需要有单独的管理类来进行管理
方式：
	//A市行政部1号管理类
	A* mgr_a_adm_1 = Singleton&lt;A, Adm, 1&gt;::GetInstance();
 	//B市技术部2号管理类
    B* mgr_b_tec_2 = Singleton&lt;B, Tec, 2&gt;::GetInstance();
    ...
</code></pre> 
<h4><a id="05_371"></a>知识点05（时间戳的获取和人性化展示）</h4> 
<pre><code class="prism language-c++">int main(int argc,char** argv){
    const std::string m_format = "%Y-%m-%d %H:%M:%S";
    struct tm tm;
    time_t t = time(0);
    localtime_r(&amp;t, &amp;tm);
    char buf[64];
    strftime(buf, sizeof(buf), m_format.c_str(), &amp;tm);
    std::cout &lt;&lt; buf &lt;&lt; std::endl;
	return 0;
}
</code></pre> 
<p>以下是输出</p> 
<pre><code>2024-04-20 04:38:57
</code></pre> 
<h4><a id="06_IDlinuxPID_388"></a>知识点06 获取程序在系统中的线程ID(和linux中的PID对应)</h4> 
<pre><code class="prism language-c++">#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/syscall.h&gt;

int main(int argc,char** argv){
    std::cout &lt;&lt; syscall(SYS_gettid) &lt;&lt; std::endl;
    return 0;
}
</code></pre> 
<h5><a id="httpsblogcsdnnetqq_35099224articledetails137960280_400"></a>下一篇：<a href="https://blog.csdn.net/qq_35099224/article/details/137960280">【日志管理-代码分析篇】</a>该篇篇幅较长，建议做完眼保健操后食用</h5> 
<p>QQ交流群：957100923</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c0c627b93ded6a690cb29aaed18c3467/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【常微分方程】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/58eaa1d00f8f5d4878887d7cf16b5040/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">xLua | xLua Framework | 2 加载</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>