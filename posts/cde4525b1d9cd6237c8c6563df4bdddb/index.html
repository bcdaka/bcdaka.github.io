<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Flink 实时数仓（七）【DWS 层搭建（一）流量域汇总表创建】 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/cde4525b1d9cd6237c8c6563df4bdddb/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Flink 实时数仓（七）【DWS 层搭建（一）流量域汇总表创建】">
  <meta property="og:description" content="前言 今天开始 DWS 层的搭建，不知不觉又是周一，都忘了昨天是周末，近两年对我来说，周六日晚上八九点能打一小会篮球就算一周的休息了。不得不说自己真的是天生打工体质，每天不管多累，晚上十二点睡，第二天六点多七点准时自然醒，依然精神焕发，中午都不带困的；那既然老天给我这个特质让我像牛一样可以不知疲倦的工作，那我也希望是让我在热爱的领域发光发热；那既然这样，总得先让我找到个满意的工作吧哈哈哈 ...
1、DWS 层搭建 设计要点：
DWS层的设计参考指标体系（需求驱动）；（前面的 DIM 和 DWD 的设计都是参考建模理论，是业务驱动）DWS层表名的命名规范为dws_数据域_统计粒度_业务过程_统计周期（window） 离线数仓中的 DWS 层的统计周期我们当时做的是 1/7/30 ，那实时数仓的统计周期当然不能这么大；离线数仓中每一天就相当于一个窗口，而在实时数仓当中，窗口都是秒级别的，我们这里开窗的大小选择 10 s，因为我们的可视化平台只能 10s 刷新一次，开得太小没有意义；（生产环境中可以更小比如 1s ，甚至可以不开窗。开窗还是不开窗是性能和时效性的取舍）
1.1、流量域来源关键词粒度页面浏览各窗口汇总表 主要任务：
从 Kafka 页面浏览明细（dwd_traffic_page_log）主题读取数据，过滤搜索行为，使用自定义 UDTF（一进多出）函数对搜索内容分词。统计各窗口各关键词出现频次，写入 ClickHouse。
1.1.1、思路分析 在 DWD 层，我们对日志根据日志类型进行了分流，写入到了 5 个不同的主题当中现在我们需要统计搜索内容中的关键词，所以需要消费页面浏览日志使用分词器将搜索内容分为多个关键词划分窗口，词频统计后存储进 clickhouse 思考：既然用到分词，为啥不直接用 ES 存呢？
答：确实是要分词，但是我们这里是要做词频统计，ES 是对关键词做索引，相当于用 key（关键词）去获得 value（文档），而我们这里是要对 key 进行统计，所以不合适；
1.1.2、代码实现 1）IK 分词器工具类 public class KeywordUtil { public static List&lt;String&gt; analyze(String text){ // 创建集合用于存放切分或的数据 List&lt;String&gt; keywordList = new ArrayList&lt;&gt;(); // 封装待分词内容 StringReader reader = new StringReader(text); // 创建 IK 分词器(ik_smart 智能分词,ik_max_word: 尽可能分最多的词) IKSegmenter ikSegmenter = new IKSegmenter(reader,true); try { // 取出切分好的词 Lexeme lexeme = null; while((lexeme = ikSegmenter.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-05T17:58:43+08:00">
    <meta property="article:modified_time" content="2024-08-05T17:58:43+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Flink 实时数仓（七）【DWS 层搭建（一）流量域汇总表创建】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="background-color:transparent;">前言</h2> 
<p>        今天开始 DWS 层的搭建，不知不觉又是周一，都忘了昨天是周末，近两年对我来说，周六日晚上八九点能打一小会篮球就算一周的休息了。不得不说自己真的是天生打工体质，每天不管多累，晚上十二点睡，第二天六点多七点准时自然醒，依然精神焕发，中午都不带困的；那既然老天给我这个特质让我像牛一样可以不知疲倦的工作，那我也希望是让我在热爱的领域发光发热；那既然这样，总得先让我找到个满意的工作吧哈哈哈 ...</p> 
<h2 style="background-color:transparent;">1、DWS 层搭建</h2> 
<p style="margin-left:.0001pt;text-align:justify;">设计要点：</p> 
<ul><li style="margin-left:.0001pt;text-align:justify;">DWS层的设计参考指标体系（需求驱动）；（前面的 DIM 和 DWD 的设计都是参考建模理论，是业务驱动）</li><li style="margin-left:.0001pt;text-align:justify;">DWS层表名的命名规范为dws_数据域_统计粒度_业务过程_统计周期（window）</li></ul> 
<p style="margin-left:.0001pt;text-align:justify;">        离线数仓中的 DWS 层的统计周期我们当时做的是 1/7/30 ，那实时数仓的统计周期当然不能这么大；离线数仓中每一天就相当于一个窗口，而在实时数仓当中，窗口都是秒级别的，我们这里开窗的大小选择 10 s，因为我们的可视化平台只能 10s 刷新一次，开得太小没有意义；（生产环境中可以更小比如 1s ，甚至可以不开窗。开窗还是不开窗是性能和时效性的取舍）</p> 
<h3 style="margin-left:.0001pt;text-align:justify;">1.1、流量域<span style="color:#ff9900;">来源关键词</span>粒度<span style="color:#ff9900;">页面浏览</span>各窗口汇总表</h3> 
<p><strong>主要任务</strong>：</p> 
<p style="margin-left:.0001pt;text-align:justify;">        从 Kafka <strong>页面浏览明细（dwd_traffic_page_log）</strong>主题读取数据，过滤搜索行为，使用<strong>自定义 UDTF</strong>（一进多出）函数对搜索内容分词。统计各窗口各关键词出现频次，写入 ClickHouse。</p> 
<h4 style="background-color:transparent;">1.1.1、思路分析</h4> 
<ul><li>在 DWD 层，我们对日志根据日志类型进行了分流，写入到了 5 个不同的主题当中</li><li>现在我们需要统计搜索内容中的关键词，所以需要消费页面浏览日志</li><li>使用分词器将搜索内容分为多个关键词</li><li>划分窗口，词频统计后存储进 clickhouse</li></ul> 
<p><img alt="" height="890" src="https://images2.imgbox.com/8f/8b/CkmCOV6u_o.png" width="1200"></p> 
<p>思考：既然用到分词，为啥不直接用 ES 存呢？</p> 
<p>答：确实是要分词，但是我们这里是要做词频统计，ES 是对关键词做索引，相当于用 key（关键词）去获得 value（文档），而我们这里是要对 key 进行统计，所以不合适；</p> 
<h4 style="background-color:transparent;">1.1.2、代码实现</h4> 
<h5 style="background-color:transparent;">1）IK 分词器工具类</h5> 
<pre><code class="language-java">public class KeywordUtil {
    public static List&lt;String&gt; analyze(String text){
        // 创建集合用于存放切分或的数据
        List&lt;String&gt; keywordList = new ArrayList&lt;&gt;();
        // 封装待分词内容
        StringReader reader = new StringReader(text);
        // 创建 IK 分词器(ik_smart 智能分词,ik_max_word: 尽可能分最多的词)
        IKSegmenter ikSegmenter = new IKSegmenter(reader,true);
        try {
            // 取出切分好的词
            Lexeme lexeme = null;
            while((lexeme = ikSegmenter.next())!=null){
                String keyword = lexeme.getLexemeText();
                keywordList.add(keyword);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return keywordList;
    }

    public static void main(String[] args) {
        List&lt;String&gt; list = analyze("Apple iPhoneXSMax (A2104) 256GB 深空灰色 移动联通电信4G手机 双卡双待");
        System.out.println(list);
    }
}</code></pre> 
<h5 style="background-color:transparent;">2）自定义 UDTF</h5> 
<pre><code class="language-java">@FunctionHint(output = @DataTypeHint("ROW&lt;word STRING&gt;"))
public class IkUDTF extends TableFunction&lt;Row&gt; {
    public void eval(String str){
        for (String word : KeywordUtil.analyze(str)) {
            collect(Row.of(word));
        }
    }
}</code></pre> 
<h5>3） 消费页面浏览日志主题</h5> 
<p>我们相当于一个消费者去消费页面浏览主题，那么就需要先创建该表，也就需要先确定我们要的字段。在事件时间语义下使用窗口函数的时候我们需要指定事件时间的字段；</p> 
<p>前面我们为了 join lookup 表的时候那样（要想 join lookup 表，必须要有一个处理时间字段）：</p> 
<p><img alt="" height="497" src="https://images2.imgbox.com/01/b9/PnPdvzu9_o.png" width="1106"></p> 
<p> 只不过我们现在需要指定一个事件时间，我们同样可以通过 DDL 中来指定：</p> 
<p><img alt="" height="691" src="https://images2.imgbox.com/95/89/gjWNVfKN_o.png" width="1101"></p> 
<p>对于这里的关键词需求而言，我们不需要保留 common 字段，所以建表如下： </p> 
<pre><code class="language-java">​
// TODO 3. 消费 Kafka dwd_traffic_page_log 主题
        String groupId = "dws_traffic_source_keyword_page_view_window";
        tableEnv.executeSql(
                "CREATE TABLE dwd_traffic_page_log " +
                        "       page map&lt;string,string&gt;, " +
                        "       ts bigint , " +
                        "       time_ltz AS TO_TIMESTAMP(FROM_UNIXTIME(ts/1000)), " +
                        "       WATERMARK FOR time_ltz AS time_ltz - INTERVAL '2' SECOND " +
                        MyKafkaUtil.getKafkaDDL("dwd_traffic_page_log", groupId));

​</code></pre> 
<p>这里我们指定了 time_ltz 为事件时间字段以及乱序延迟时间最大为 2s，这里为什么不直接使用 ts 字段呢？这是因为 json 默认把数值类型都当做 bigint 来处理，而 Flink SQL 中，表的事件时间必须为 timestamp 类型，所以我们需要进行转换；</p> 
<p><strong>注意</strong>：<span style="color:#fe2c24;">建表语句中尽量加 AS ，尤其字段涉及函数！</span></p> 
<h5>4）过滤出搜索数据</h5> 
<pre><code class="language-java">// TODO 4. 过滤出搜索数据
Table searchLog = tableEnv.sqlQuery("SELECT " +
        "page['item'] item, " +
        "time_ltz " +
        "FROM dwd_traffic_page_log " +
        "WHERE page['last_page_id' = 'search'] " +
        "AND page['item_type'] = 'keyword' " +
        "AND page['item'] is not null "
);
tableEnv.createTemporaryView("search_log_table",searchLog);</code></pre> 
<h5>5）注册 udtf 函数并进行分词</h5> 
<pre><code class="language-java">// TODO 5. 注册 udtf &amp; 分词
tableEnv.createTemporaryFunction("ik", IkUDTF.class);
Table splitTable = tableEnv.sqlQuery("SELECT " +
        "word, " +
        "time_ltz " +
        "FROM search_log_table " +
        "LATERAL TABLE(ik(item))"
);
tableEnv.createTemporaryView("split_table",splitTable);</code></pre> 
<h5>6）分组、开窗、聚合</h5> 
<p>之前离线数仓写过窗口函数，但是都是没有边界的窗口。这里我们学习一下 Flink 中的三种窗口怎么用 Flink SQL 去写：</p> 
<p><img alt="" height="673" src="https://images2.imgbox.com/3d/58/R8iuzdGi_o.png" width="1068"></p> 
<p>上面三种窗口分别对应：滚动，滑动和会话，下面是使用案例：</p> 
<p><img alt="" height="233" src="https://images2.imgbox.com/ea/56/BLQmBNoC_o.png" width="500"></p> 
<p>现在我们需要考虑将来写入到 ck 时，ck 应该采用什么引擎？</p> 
<ul><li>选择 SummingMergeTree 
  <ul><li>优点：自动预聚合，存储的内容少了，查询效率高</li><li>缺点：只能做求和指标，比如峰值指标就做不了。再有假如数据消费后挂了（Flink 读取后数据写入到 ck 了，但是这时候挂了，Flink 恢复后会重新消费，ck 就会重复处理。如果是别的引擎还好，因为数据不是聚合的状态，而是一条一条存储的，我们可以对数据根据 uuid 进行区分是否已经处理过）</li></ul></li><li>选择ReplacingMergeTree 
  <ul><li>它有去重的功能，但是是在任务挂掉的时候我们才用得到（保证一致性）</li><li>可以做更多的指标</li><li>缺点就是会存储更多的数据</li></ul></li></ul> 
<p>那么，我们当然选择 ReplacingMergeTree ，现在我们需要考虑去重字段（在 ck 中去重字段比主键都重要）：</p> 
<ul><li>去重（order by 字段）： 
  <ul><li>根据 <strong>窗口时间（起始+终止）+关键词</strong> 进行去重（这里会添加一个 source 字段区分日志的来源，比如 search、cart、order）</li></ul></li></ul> 
<p>窗口的起始和终止时间同样有特定的函数来获取：</p> 
<p><img alt="" height="297" src="https://images2.imgbox.com/f5/c0/7J1rB2Qu_o.png" width="605"></p> 
<p>最终，我们的代码：</p> 
<pre><code class="language-java">        // TODO 6. 分组、开窗、聚合
        Table resultTable = tableEnv.sqlQuery("SELECT " +
                "    date_format(tumble_start(time_ltz,interval '10' second),'yyyy-MM-dd HH:mm:ss') stt," +
                "    date_format(tumble_end(time_ltz,interval '10' second),'yyyy-MM-dd HH:mm:ss') edt," +
                "    'search' source," +
                "    word keyword," +
                "    count(*) keyword_count," +
                "    unix_timestamp() ts" +
                "FROM split_table" +
                "GROUP BY word,tumble(time_ltz,interval '10' second)");</code></pre> 
<h5>7）创建 ck 表格</h5> 
<pre><code class="language-sql">create table if not exists dws_traffic_source_keyword_page_view_window
(
    stt           DateTime,
    edt           DateTime,
    source        String,
    keyword       String,
    keyword_count UInt64,
    ts            UInt64
) engine = ReplacingMergeTree(ts)
      partition by toYYYYMMDD(stt)
      order by (stt, edt, source, keyword);</code></pre> 
<h5>8）ck 工具类</h5> 
<p>上面第 6 步之后，我们得到了开窗聚合后的一个结果，要写入 ck 我们需要先将动态表转为流：</p> 
<pre><code class="language-java">// TODO 7. 将动态表转换为流
        DataStream&lt;KeywordBean&gt; dataStream = tableEnv.toAppendStream(resultTable, KeywordBean.class);
</code></pre> 
<p>接着我们需要通过 JdbcSink 写出到 ck 集群中，因为之后每个聚合结果都是存在 DWS 层的，所以都会用到该 JdbcSink，所以我们统一封装成一个工具类：</p> 
<pre><code class="language-java">public class ClickHouseUtil {

    // 泛型方法需要再返回值类型前面放一个泛型
    public static &lt;T&gt; SinkFunction&lt;T&gt; getSinkFunction(String sql) {
        return JdbcSink.sink(
                sql,
                new JdbcStatementBuilder&lt;T&gt;() {
                    @SneakyThrows
                    @Override
                    public void accept(PreparedStatement preparedStatement, T t) throws SQLException {
                        // 利用反射获得 t 对象的属性
                        Class&lt;?&gt; tClz = t.getClass();
                        int index = 1;
                        for (Field field : tClz.getDeclaredFields()) {
                            field.setAccessible(true); // 防止访问呢 private 属性失败
                            // 尝试获得字段上的注解
                            TransientSink transientSink = field.getAnnotation(TransientSink.class);
                            if (transientSink != null){
                                continue;
                            }
                            // 获得字段值
                            Object value = field.get(t);
                            // 给占位符赋值
                            preparedStatement.setObject(index++,value);
                        }
                    }
                }, new JdbcExecutionOptions.Builder()
                        .withBatchSize(5)
                        .withBatchIntervalMs(1000L)
                        .build()
                , new JdbcConnectionOptions.JdbcConnectionOptionsBuilder()
                        .withDriverName(GmallConfig.CLICKHOUSE_DRIVER)
                        .withUrl(GmallConfig.CLICKHOUSE_URL)
                        .build()
        );
    }
}
</code></pre> 
<p>在代码中我们有一个获取注解的操作，是为了防止 JavaBean 中的字段（可能是辅助字段）在 ck 表中并没有能对应上的，所以我们通过注解来甄别：</p> 
<pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME) // 生效时机: 运行时
@Target(ElementType.FIELD) // 该注解的作用域: 属性上
public @interface TransientSink {

}</code></pre> 
<p>补全主程序： </p> 
<pre><code class="language-java">        // TODO 8. 写入 clickhouse
        // 插入字段顺序尽量和ck库的表保持一致
        dataStream.addSink(ClickHouseUtil.getSinkFunction(
                "insert into dws_traffic_source_keyword_page_view_window " +
                        "values(?,?,?,?,?,?)"
        ));

        // TODO 9. 启动任务
        env.execute("DwsTrafficSourceKeywordPageViewWindow");</code></pre> 
<p><strong>注意</strong>：因为我们是通过反射获取 Bean 对象字段来向 ck 表插入数据的，所以一定要保证 Bean 对象的顺序要和 ck 表对应上；</p> 
<h3 style="background-color:transparent;">1.2、流量域<span style="color:#ff9900;">版本-渠道-地区-访客类别</span>粒度<span style="color:#ff9900;">页面浏览</span>各窗口汇总表</h3> 
<p>上面 DWS 的第一个需求我们是用 Flink SQL 来实现的，从这个需求开始，我们将使用 DataStream API 来实现；</p> 
<h4><strong>1.2.1、需求分析</strong></h4> 
<ul><li><span style="color:#ff9900;"><strong>维度</strong></span>有 4 个：版本，渠道，地区和访客类别；</li><li><span style="color:#ff9900;"><strong>度量值</strong></span>有 5 个：会话数、页面浏览数、浏览总时长、独立访客数、跳出会话数等；</li></ul> 
<p>        关于独立访客数和跳出会话数我们之前在 DWD 层已经实现并分别写入到了 dwd_traffic_unique_visitor_detail（状态编程保存 lastVisitDate 实现） 和 dwd_traffic_user_jump_detail（Flink CEP 实现） 主题了；所以这里只需要分析前 2 个度量值怎么计算：</p> 
<ul><li>会话数 
  <ul><li>我们的数据中没有 session_id，但是要求也很简单：last_page_id 为 null 即代表一个新会话的开始</li></ul></li><li>页面浏览数（PV） 
  <ul><li>页面浏览记录中每一行数据就是一个浏览记录（count(1) ）</li></ul></li><li>浏览总时长 
  <ul><li>还是从页面浏览记录中获取浏览时间（during_time）</li></ul></li></ul> 
<p>思考：这三个度量值都可以从 dwd_traffic_page_log 中一次计算出来，但是怎么和另外两个来自不同主题的度量值聚合呢？</p> 
<p>答：使用 join，根据 dws 表的粒度进行 join，但是在 SQL 中使用 join 的话也许好一点，可是我们使用 API 就比较复杂；所以其实我们还可以使用另一种方式实现——使用 <strong>union + 分组聚合</strong>也可以实现；</p> 
<p>那么最终写入到 ck 中的字段其实一共有 12 个：4个维度字段 + 5 个度量值 + ts + 窗口起始、终止时间字段；</p> 
<p><img alt="" height="945" src="https://images2.imgbox.com/95/f2/NZ2x4Z8X_o.png" width="1200"></p> 
<h4>1.2.2、代码实现</h4> 
<h5>1）建表语句</h5> 
<pre><code class="language-sql">create table if not exists dws_traffic_vc_ch_ar_is_new_page_view_window
(
    stt     DateTime,
    edt     DateTime,
    vc      String,
    ch      String,
    ar      String,
    is_new  String,
    uv_ct   UInt64,
    sv_ct   UInt64,
    pv_ct   UInt64,
    dur_sum UInt64,
    uj_ct   UInt64,
    ts      UInt64
) engine = ReplacingMergeTree(ts)
      partition by toYYYYMMDD(stt)
      order by (stt, edt, vc, ch, ar, is_new);</code></pre> 
<h5>2）创建 ck 表对应的 Bean</h5> 
<pre><code class="language-java">import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class TrafficPageViewBean {
    // 窗口起始时间
    String stt;
    // 窗口结束时间
    String edt;
    // app 版本号
    String vc;
    // 渠道
    String ch;
    // 地区
    String ar;
    // 新老访客状态标记
    String isNew ;
    // 独立访客数
    Long uvCt;
    // 会话数
    Long svCt;
    // 页面浏览数
    Long pvCt;
    // 累计访问时长
    Long durSum;
    // 跳出会话数
    Long ujCt;
    // 时间戳
    Long ts;
}</code></pre> 
<h5>3）读取三个主题的数据</h5> 
<pre><code class="language-java">        // TODO 3. 读取三个主题的数据
        String uvTopic = "dwd_traffic_unique_visitor_detail";
        String ujdTopic = "dwd_traffic_user_jump_detail";
        String topic = "dwd_traffic_page_log";
        String groupId = "dws_traffic_channel_page_view_window";
        DataStreamSource&lt;String&gt; uvDS = env.addSource(MyKafkaUtil.getFlinkKafkaConsumer(uvTopic, groupId));
        DataStreamSource&lt;String&gt; ujdDS = env.addSource(MyKafkaUtil.getFlinkKafkaConsumer(ujdTopic, groupId));
        DataStreamSource&lt;String&gt; pageDS = env.addSource(MyKafkaUtil.getFlinkKafkaConsumer(topic, groupId));
</code></pre> 
<h5>4）统一数据格式</h5> 
<p>将 3 个主题的数据进行格式统一，方便后面 union + 聚合</p> 
<pre><code class="language-java">        // TODO 4. 统一数据格式
        SingleOutputStreamOperator&lt;TrafficPageViewBean&gt; trafficWithUvDS = uvDS.map(line -&gt; {
            JSONObject jsonObject = JSONObject.parseObject(line);

            JSONObject common = jsonObject.getJSONObject("common");

            return new TrafficPageViewBean("", "",
                    common.getString("vc"),
                    common.getString("ch"),
                    common.getString("ar"),
                    common.getString("is_new"),
                    1L, 0L, 0L, 0L, 0L,
                    common.getLong("ts")
            );
        });
        SingleOutputStreamOperator&lt;TrafficPageViewBean&gt; trafficWithUJ = ujdDS.map(line -&gt; {
            JSONObject jsonObject = JSONObject.parseObject(line);

            JSONObject common = jsonObject.getJSONObject("common");

            return new TrafficPageViewBean("", "",
                    common.getString("vc"),
                    common.getString("ch"),
                    common.getString("ar"),
                    common.getString("is_new"),
                    0L, 0L, 0L, 0L, 1L,
                    common.getLong("ts")
            );
        });
        SingleOutputStreamOperator&lt;TrafficPageViewBean&gt; trafficWithSvPvDurSumDS = pageDS.map(line -&gt; {
            JSONObject jsonObject = JSONObject.parseObject(line);

            JSONObject common = jsonObject.getJSONObject("common");
            JSONObject page = jsonObject.getJSONObject("page");

            return new TrafficPageViewBean("", "",
                    common.getString("vc"),
                    common.getString("ch"),
                    common.getString("ar"),
                    common.getString("is_new"),
                    0L,
                    page.getString("last_page_id") == null ? 1L : 0L,
                    1L,
                    page.getLong("during_time"),
                    0L,
                    common.getLong("ts")
            );
        });</code></pre> 
<p><strong>注意</strong>： trafficWithUJ 这条流本就存在延时，所以很可能下面在 union 的时候，窗口都关闭了它还没来，所以我们只能给水位线的最大乱序等待时间 + 判定为用户跳出的最大时间（也就是超时时间）；</p> 
<h5>5）三流 union</h5> 
<p>对三条流进行 union 然后提取出事件时间生成水位线，之后就需要开窗聚合了，而开窗聚合我们一般都会指定 keyby 再开窗，全窗口几乎不用；而 keyby 的字段我们选择 4 个维度（可以用 String  拼接也可以用一个四元组 Tuple4）</p> 
<p>窗口分类：</p> 
<ul><li>OpWindow：windowAll()</li><li>KeyedWindow：window() 
  <ul><li>时间：滚动、滑动、会话</li><li>计数：滚动、滑动</li></ul></li></ul> 
<pre><code class="language-java">// TODO 5. 三条流进行 union
        DataStream&lt;TrafficPageViewBean&gt; unionDS = trafficWithUvDS.union(trafficWithUJDS, trafficWithSvPvDurSumDS);

        // TODO 6. 提取事件时间(去 ts 字段生成水位线)
        SingleOutputStreamOperator&lt;TrafficPageViewBean&gt; trafficPageViewWithWaterMarkDS = unionDS.assignTimestampsAndWatermarks(WatermarkStrategy.&lt;TrafficPageViewBean&gt;forBoundedOutOfOrderness(Duration.ofSeconds(14))
                .withTimestampAssigner(new SerializableTimestampAssigner&lt;TrafficPageViewBean&gt;() {
                    @Override
                    public long extractTimestamp(TrafficPageViewBean element, long recordTimestamp) {
                        return element.getTs();
                    }
                })
        );

        // TODO 7. 分组开窗聚合(按照维度做keyby)
        WindowedStream&lt;TrafficPageViewBean, Tuple4&lt;String, String, String, String&gt;, TimeWindow&gt; windowedStream = trafficPageViewWithWaterMarkDS.keyBy(new KeySelector&lt;TrafficPageViewBean, Tuple4&lt;String, String, String, String&gt;&gt;() {
            @Override
            public Tuple4&lt;String, String, String, String&gt; getKey(TrafficPageViewBean value) throws Exception {
                return Tuple4.of(value.getAr(),
                        value.getCh(),
                        value.getIsNew(),
                        value.getVc());
            }
        }).window(TumblingEventTimeWindows.of(Time.seconds(10)));</code></pre> 
<p><strong>注意</strong>：这里在设置水位线延迟时间时，我们设置为 14，因为需求中包含用户跳出会话数，而跳出这个需求本就存在延迟（我们在 DWD 层设置了两种判断跳出策略（前提是按照 mid 分区）：1. last_page_id = null &amp; 下一条数据的 last_page_id 也为 null  2. last_page_id = null &amp; 超时时间达到 10s 视作跳出）</p> 
<h5 style="background-color:transparent;">6） 聚合</h5> 
<p>回顾一下窗口聚合函数：</p> 
<ul><li>增量聚合函数：来一条计算一条（效率高，存储数据量小）</li><li>全量聚合函数：可以求平均值和百分比，<span style="color:#fe2c24;">可以获取窗口信息</span></li></ul> 
<blockquote> 
 <p>与增量聚合函数不同，全窗口函数需要先收集窗口中的数据，并在内部缓存起来，等到窗口要输出结果的时候再取出数据进行计算。很明显，这就是典型的批处理思路了——先攒数据，等一批都到齐了再正式启动处理流程。</p> 
 <p>        但是把计算放到窗口关闭才去计算无疑是低效的，毕竟如果数据量比较大的时候，这种方式肯定没有增量聚合函数计算的快。那为什么还要使用这种方式呢？这是因为<span style="color:#fe2c24;">有些场景下，我们要做的计算必须基于全部的数据才有效（比如求平均值），这时做增量聚合就没什么意义了</span>；</p> 
</blockquote> 
<p>那么，现在我们应该对 keyby 后的数据流进行聚合，把相同 key 的度量值进行累加，那么我们应该选用哪种聚合函数呢？</p> 
<p>选用增量聚合函数其实可以实现度量值的累加，但是由于我们的 ck 表中还有两个窗口字段需要补充（窗口起始和终止时间），所以我们需要获取窗口信息，那这就只能使用全量聚合函数了，毕竟全量窗口函数才能获得窗口信息；但是全窗口函数的计算往往是放到最后才执行的，这就很难受，那能不能结合二者的优点呢？</p> 
<p>其实是可以的，我们在之前学习<strong><a class="link-info" href="https://blog.csdn.net/m0_64261982/article/details/134682035" title="Flink 窗口">Flink 窗口</a></strong>的时候是讲过的：</p> 
<blockquote> 
 <p>增量聚合函数处理计算会更高效。举一个最简单的例子，对一组数据求和。大量的数据连续不断到来，全窗口函数只是把它们收集缓存起来，并没有处理；到了窗口要关闭、输出结果的时候，再遍历所有数据依次叠加，得到最终结果。而如果我们采用增量聚合的方式，那么只需要保存一个当前和的状态，每个数据到来时就会做一次加法，更新状态；到了要输出结果的时候，只要将当前状态直接拿出来就可以了。增量聚合相当于把计算量“均摊”到了窗口收集数据的过程中，自然就会比全窗口聚合更加高效、输出更加实时。<br>         而全窗口函数的优势在于提供了更多的信息，可以认为是更加“通用”的窗口操作。它只负责收集数据、提供上下文相关信息，把所有的原材料都准备好，至于拿来做什么我们完全可以任意发挥。这就使得窗口计算更加灵活，功能更加强大。<br> 所以在实际应用中，我们往往希望兼具这两者的优点，把它们结合在一起使用。Flink 的Window API 就给我们实现了这样的用法。</p> 
</blockquote> 
<pre><code class="language-java">SingleOutputStreamOperator&lt;TrafficPageViewBean&gt; resultDS = windowedStream.reduce(new ReduceFunction&lt;TrafficPageViewBean&gt;() {
            @Override
            public TrafficPageViewBean reduce(TrafficPageViewBean value1, TrafficPageViewBean value2) throws Exception {
                value1.setSvCt(value1.getSvCt() + value2.getSvCt());
                value1.setUvCt(value1.getUvCt() + value2.getUvCt());
                value1.setUvCt(value1.getUjCt() + value2.getUjCt());
                value1.setPvCt(value1.getPvCt() + value2.getPvCt());
                value1.setDurSum(value1.getDurSum() + value2.getDurSum());
                return value1;
            }
        }, new WindowFunction&lt;TrafficPageViewBean, TrafficPageViewBean, Tuple4&lt;String, String, String, String&gt;, TimeWindow&gt;() {
            @Override
            public void apply(Tuple4&lt;String, String, String, String&gt; stringStringStringStringTuple4, TimeWindow window, Iterable&lt;TrafficPageViewBean&gt; input, Collector&lt;TrafficPageViewBean&gt; out) throws Exception {
                // 获取数据
                TrafficPageViewBean next = input.iterator().next();

                // 补充信息
                next.setStt(DateFormatUtil.toYmdHms(window.getStart()));
                next.setEdt(DateFormatUtil.toYmdHms(window.getEnd()));

                // 修改 ts
                next.setTs(System.currentTimeMillis());

                // 输出数据
                out.collect(next);
            }
        });</code></pre> 
<p>这样，我们既高效地完成了窗口聚合（增量聚合），也拿到了窗口信息（全量聚合获得起止时间）； </p> 
<h5>7）写出到 clickhouse</h5> 
<pre><code class="language-java">        // TODO 8. 写入 clickhouse
        resultDS.addSink(ClickHouseUtil.getSinkFunction("insert into dws_traffic_channel_page_view_window " +
                "values(?,?,?,?,?,?,?,?,?,?,?,?)"));
        // TODO 9. 启动任务
        env.execute("DwsTrafficVcChArIsNewPageViewWindow");</code></pre> 
<h2>总结</h2> 
<p>        至此，流量域两张汇总表创建完毕，关于流量域就剩一张表明天完成，先去吃饭；</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/02e7340ed02a5ebc7d3fa6c681fc36dd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【无标题】mysql用户&#43;角色&#43;密码安全策略</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1c06b1ce13230a3e50167e676db86708/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">c＋＋STL容器中vector的使用，模拟实现及迭代器使用注意事项和迭代器失效问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>