<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>React三原理和路由 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/a7bca482ac83c3f0459102d54a28457f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="React三原理和路由">
  <meta property="og:description" content="代码下载 React 组件通讯原理 setState() 说明 setState() 是异步更新数据的，使用该语法时，后面的 setState() 不要依赖于前面的 setState()，可以多次调用 setState() ，只会触发一次重新渲染：
this.setState({ count: this.state.count &#43; 1 }) console.log(&#39;count: &#39;, this.state.count); this.setState({ count: this.state.count &#43; 1 }) console.log(&#39;count: &#39;, this.state.count); 推荐使用 setState((state, props) =&gt; {}) 语法，参数state表示最新的state，参数props表示最新的props：
this.setState((state, props) =&gt; { console.log(&#39;第一次 count: &#39;, state.count); return { count: state.count &#43; 1 } }) this.setState((state, props) =&gt; { console.log(&#39;第二次 count: &#39;, state.count); return { count: state.count &#43; 1 } }) console.log(&#39;count: &#39;, this.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-01T22:59:55+08:00">
    <meta property="article:modified_time" content="2024-08-01T22:59:55+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">React三原理和路由</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4><a id="httpsgithubcomjiuchabaikaishuireactlearn1_0"></a><a href="https://github.com/jiuchabaikaishui/react-learn1">代码下载</a></h4> 
<h3><a id="React__3"></a>React 组件通讯原理</h3> 
<h4><a id="setState__6"></a><code>setState()</code> 说明</h4> 
<p>setState() 是异步更新数据的，使用该语法时，后面的 setState() 不要依赖于前面的 setState()，可以多次调用 setState() ，只会触发一次重新渲染：</p> 
<pre><code>    this.setState({ count: this.state.count + 1 })
    console.log('count: ', this.state.count);
    this.setState({ count: this.state.count + 1 })
    console.log('count: ', this.state.count);
</code></pre> 
<p>推荐使用 setState((state, props) =&gt; {}) 语法，参数state表示最新的state，参数props表示最新的props：</p> 
<pre><code>    this.setState((state, props) =&gt; {
      console.log('第一次 count: ', state.count);
      return { count: state.count + 1 }
    })
    this.setState((state, props) =&gt; {
      console.log('第二次 count: ', state.count);
      return { count: state.count + 1 }
    })
    console.log('count: ', this.state.count);
</code></pre> 
<p>第二个参数在状态更新（页面完成重新渲染）后立即执行某个操作，语法 <code>setState(updater[, callback])</code>：</p> 
<pre><code>    this.setState((state, props) =&gt; {
      return { count: state.count + 1 }
    }, () =&gt; {
      console.log('count: ', this.state.count);
    })
</code></pre> 
<h4><a id="JSX__38"></a>JSX 语法的转化过程</h4> 
<p>JSX 仅仅是 createElement() 方法的语法糖（简化语法），JSX 语法被 @babel/preset-react 插件编译为 createElement() 方法。React 元素是一个对象，用来描述你希望在屏幕上看到的内容：<br> <img src="https://images2.imgbox.com/bb/42/zI4nuZei_o.png" height="300px"></p> 
<h4><a id="_43"></a>组件更新机制</h4> 
<p>setState() 的两个作用： 1. 修改 state 2. 更新组件（UI）</p> 
<p>过程：父组件重新渲染时，也会重新渲染子组件。但只会渲染当前组件子树（当前组件及其所有子组件）</p> 
<img src="https://images2.imgbox.com/e3/6e/CgmENIjz_o.png" height="230px"> 
<pre><code>// 组件更新机制
class UpdateCom extends React.Component {
  state = { color: 'skyblue'}
  render() {
    console.log('根组件 render');
    return (
      &lt;div className='root' style={<!-- -->{ backgroundColor: this.state.color}}&gt;
        &lt;p&gt;根组件&lt;/p&gt;
        &lt;button onClick={this.changeColor}&gt;变色&lt;/button&gt;
        &lt;div className='rootContainer'&gt;
          &lt;LeftCom&gt;&lt;/LeftCom&gt;
          &lt;RightCom&gt;&lt;/RightCom&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }
  getColor = () =&gt; Math.floor(Math.random() * 256)
  changeColor = () =&gt; {
    this.setState({ color: `rgb(${this.getColor()}, ${this.getColor()}, ${this.getColor()})` })
  }
}
class LeftCom extends React.Component {
  state = { count: 0 }
  render() {
    console.log('左父组件 render');
    return (
      &lt;div className='leftParent'&gt;
        &lt;p&gt;左父组件 count: {this.state.count}&lt;/p&gt;
        &lt;button onClick={() =&gt; this.setState({count: this.state.count + 1})}&gt;+1&lt;/button&gt;
        &lt;div className='leftParentContainer'&gt;
          &lt;LeftChildOne&gt;&lt;/LeftChildOne&gt;
          &lt;LeftChildTwo&gt;&lt;/LeftChildTwo&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }
}
class RightCom extends React.Component {
  state = { count: 0 }
  render() {
    console.log('右父组件 render');
    return (
      &lt;div className='rightParent'&gt;
        &lt;p&gt;右父组件 count: {this.state.count}&lt;/p&gt;
        &lt;button onClick={() =&gt; { this.setState({count: this.state.count + 1}) }}&gt;+1&lt;/button&gt;
        &lt;div className='rightParentContainer'&gt;
          &lt;RightChildOne&gt;&lt;/RightChildOne&gt;
          &lt;RightChildTwo&gt;&lt;/RightChildTwo&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }
}
const LeftChildOne = () =&gt; {
  console.log('左子组件1 render');
   return (&lt;div className='leftChildOne'&gt;左子组件1&lt;/div&gt;)
  }
const LeftChildTwo = () =&gt; { 
  console.log('左子组件2 render');
  return (&lt;div className='leftChildTwo'&gt;左子组件2&lt;/div&gt;)
}
const RightChildOne = () =&gt; { 
  console.log('右子组件1 render');
  return (&lt;div className='rightChildOne'&gt;右子组件1&lt;/div&gt;)
}
const RightChildTwo = () =&gt; {
  console.log('右子组件2 render');
  return (&lt;div className='rightChildTwo'&gt;右子组件2&lt;/div&gt;)
}
ReactDOM.createRoot(document.getElementById('updateCom')).render(&lt;UpdateCom&gt;&lt;/UpdateCom&gt;)
</code></pre> 
<p>css:</p> 
<pre><code class="prism language-.root">  width: 800px;
}
.rootContainer, .leftParentContainer, .rightParentContainer {
  display: flex;
}
.leftParent {
  flex: 1;
  background-color: green;
}
.leftParentContainer &gt; div {
  flex: 1;
  background-color: blue;
  margin: 10px;
}
.rightParent {
  flex: 1;
  background-color: cyan;
}
.rightParentContainer &gt; div {
  flex: 1;
  background-color: pink;
  margin: 10px;
}
</code></pre> 
<h4><a id="_151"></a>组件性能优化</h4> 
<p>1、 减轻 state，state 只存储跟组件渲染相关的数据（比如：count / 列表数据 / loading 等）</p> 
<blockquote> 
 <p>注意：不用做渲染的数据不要放在 state 中，比如定时器 id等，对于这种需要在多个方法中用到的数据，应该放在 this 中。</p> 
</blockquote> 
<p>2、避免不必要的重新渲染，父组件更新会引起子组件也被更新，这种思路很清晰</p> 
<p>问题：子组件没有任何变化时也会重新渲染？如何避免不必要的重新渲染呢？</p> 
<blockquote> 
 <p>解决方式：使用钩子函数 shouldComponentUpdate(nextProps, nextState)，通过返回值决定该组件是否重新渲染，返回 true 表示重新渲染，false 表示不重新渲染。更新阶段的钩子函数，组件重新渲染前执行 （shouldComponentUpdate -&gt; render）。</p> 
</blockquote> 
<pre><code>class NumCom extends React.Component {
  shouldComponentUpdate(nextProps, nextState) {
    console.log('props: ', this.props, 'nextProps: ', nextProps);
    // 根据 props 数据是否变化，决定渲染
    return this.props.num !== nextProps.num
  }
  render() {
    console.log('NumCom render');
    return (&lt;&gt;&lt;p&gt;随机数：{this.props.num}&lt;/p&gt;&lt;/&gt;)
  }
}
class RefreshCom extends React.Component {
  state = { num: 1 }
  shouldComponentUpdate(nextProps, nextState) {
    console.log('state: ', this.state, 'nextState: ', nextState);
    // 根据 state 数据是否变化，决定渲染
    return this.state.num !== nextState.num
  }
  render() {
    console.log('RefreshCom render');
    return (
      &lt;&gt;
        &lt;h4&gt;避免不必要的重新渲染&lt;/h4&gt;
        &lt;NumCom num={this.state.num}&gt;&lt;/NumCom&gt;
        &lt;button onClick={() =&gt; this.setState({ num: Math.ceil(Math.random()*3)})}&gt;生成随机数&lt;/button&gt;
      &lt;/&gt;
    )
  }
}
</code></pre> 
<p>3、纯组件，PureComponent 与 React.Component 功能相似，PureComponent 内部自动实现了 shouldComponentUpdate 钩子，不需要手动比较</p> 
<blockquote> 
 <p>原理：纯组件内部通过分别 对比 前后两次 props 和 state 的值，来决定是否重新渲染组件。纯组件内部的对比是 shallow compare（浅层对比），对于值类型来说比较两个值是否相同（直接赋值即可，没有坑）；对于引用类型来说只比较对象的引用（地址）是否相同。注意 state 或 props 中属性值为引用类型时，应该创建新数据，不要直接修改原数据！</p> 
</blockquote> 
<pre><code>class PureNum extends React.PureComponent {
  render() {
    console.log('PureNum render');
    return (&lt;&gt;&lt;p&gt;随机数：{this.props.num}&lt;/p&gt;&lt;/&gt;)
  }
}
class PureObjNum extends React.PureComponent {
  render() {
    console.log('PureObjNum render');
    return (&lt;&gt;&lt;p&gt;随机数：{this.props.numObj.num}&lt;/p&gt;&lt;/&gt;)
  }
}
class PureCom extends React.PureComponent {
  state = {
    num: 1,
    numObj: { num: 1 }
  }
  render() {
    console.log('PureCom render');
    return (
      &lt;&gt;
        &lt;h4&gt;纯组件&lt;/h4&gt;
        &lt;PureNum num={this.state.num}&gt;&lt;/PureNum&gt;
        &lt;button onClick={this.handle}&gt;生成随机数&lt;/button&gt;
        &lt;PureObjNum numObj={this.state.numObj}&gt;&lt;/PureObjNum&gt;
        &lt;button onClick={this.handleOne}&gt;生成随机数对象(修改原对象)&lt;/button&gt; &lt;br&gt;&lt;/br&gt;
        &lt;button onClick={this.handleTwo}&gt;生成随机数对象（创建新对象）&lt;/button&gt;
      &lt;/&gt;
    )
  }
  handle = () =&gt; {
    const number = Math.ceil(Math.random()*3)
    console.log('num: ', this.state.num, ', new num: ', number);
    this.setState({ num: number })
  }
  handleOne = () =&gt; {
    // 修改原对象，错误，因为不会刷新
    const number = Math.ceil(Math.random()*3)
    console.log('num: ', this.state.numObj.num, ', new num: ', number);
    const obj = this.state.numObj
    obj.num = number
    this.setState({ numObj: obj})
  }
  handleTwo = () =&gt; {
    // 创建新对象，正确，但是也得判断，否则每次都会刷新
    const number = Math.ceil(Math.random()*3)
    console.log('num: ', this.state.numObj.num, ', new num: ', number);
    if (number !== this.state.numObj.num) {
      const obj = {...this.state.numObj, num: number}
      this.setState({ numObj: obj})
    }
  }
}
</code></pre> 
<h4><a id="DOMDiff_253"></a>虚拟DOM和Diff算法</h4> 
<p>React 更新视图的思想是：只要 state 变化就重新渲染视图，特点就是思路非常清晰。</p> 
<blockquote> 
 <p>问题：组件中只有一个 DOM 元素需要更新时，也得把整个组件的内容重新渲染到页面中？答案是否定的。理想状态是部分更新，只更新变化的地方。那么 React 是如何做到部分更新的？虚拟 DOM 配合 Diff 算法。</p> 
</blockquote> 
<p>虚拟 DOM 本质上就是一个 JS 对象，用来描述你希望在屏幕上看到的内容（UI）：<br> <img src="https://images2.imgbox.com/b5/d4/eTsrnRLv_o.png" height="200px"></p> 
<p>执行过程</p> 
<ol><li>初次渲染时，React 会根据初始state（Model），创建一个虚拟 DOM 对象（树）。</li><li>根据虚拟 DOM 生成真正的 DOM，渲染到页面中。</li><li>当数据变化后（setState()），重新根据新的数据，创建新的虚拟DOM对象（树）。</li><li>与上一次得到的虚拟 DOM 对象，使用 Diff 算法 对比（找不同），得到需要更新的内容。</li><li>最终，React 只将变化的内容更新（patch）到 DOM 中，重新渲染到页面。<br> <img src="https://images2.imgbox.com/e4/41/dfXDqlsl_o.png" height="187px"></li></ol> 
<p>虚拟DOM最大的特点是 脱离了浏览器的束缚，也就是意味着只要是能支持js的地方都可以用到react，所以为什么说react是可以进行跨平台的开发。</p> 
<p>render 方法调用并不意味着浏览器中的重新渲染，render 方法调用仅仅说明创建了新的虚拟 DOM 对象（树）要进行diff 算法。</p> 
<h3><a id="React__274"></a>React 路由</h3> 
<p>现代的前端应用大多都是 SPA（单页应用程序），也就是只有一个 HTML 页面的应用程序。因为它的用户体<br> 验更好、对服务器的压力更小，所以更受欢迎。为了有效的使用单个页面来管理原来多页面的功能，前端路由<br> 应运而生。</p> 
<ul><li>前端路由的功能是让用户从一个视图（页面）导航到另一个视图（页面）</li><li>前端路由是一套映射规则，在React中，是 URL路径 与 组件 的对应关系</li><li>使用React路由简单来说，就是配置 路径和组件（配对）</li></ul> 
<h4><a id="_283"></a>使用步骤</h4> 
<p>1、安装，在项目根目录执行 <code>npm i react-router-dom</code> 或 <code>yarn add react-router-dom</code></p> 
<p>2、导入路由的5个核心组件：Router、Routes、Route、Link 或 NavLink</p> 
<pre><code>import { BrowserRouter as Router, Routes, Route, Link, NavLink } from 'react-router-dom'
</code></pre> 
<p>3、使用 Router 组件包裹整个应用（重要）</p> 
<p>4、路由的本质就是映射关系，用 Routes（就是router5里的Switch组件） 组件去盛放这层路由映射关系</p> 
<p>5、使用 Link 或 NavLink 组件作为导航菜单（路由入口），这两个组件主要包含两个属性：to属性和replace属性。</p> 
<ul><li>to属性: 用来设置跳转到哪个路径，相当于是push操作；</li><li>replace属性：和to类似，也会跳转到目标路径，但其执行的是replace操作，设置了replace属性会把路由栈里当前路由替换掉</li></ul> 
<p>6、使用 Route 组件配置路由规则和要展示的组件（路由出口），注意 Route 组件必须包裹在 Routes 组件内</p> 
<ul><li>path属性：用于设置匹配到的路径</li><li>element属性：设置匹配到路径后要渲染的组件；（在Router5里是使用component属性）</li></ul> 
<pre><code>// 使用步骤
const Home = () =&gt; (&lt;p&gt;首页&lt;/p&gt;)
const First = () =&gt; (&lt;p&gt;页面一&lt;/p&gt;)
const Second = () =&gt; (&lt;p&gt;页面二&lt;/p&gt;)
const NotFound = () =&gt; (&lt;p&gt;没有发现该内容&lt;/p&gt;)

const RouterStep = () =&gt; {
  return (
    &lt;&gt;
      &lt;Router&gt;
        &lt;p&gt;Link&lt;/p&gt;
        &lt;Link to='/home'&gt;首页&lt;/Link&gt;
        &lt;Link to='/first'&gt;页面一&lt;/Link&gt; 
        &lt;Link to='/second' replace={true}&gt;页面二&lt;/Link&gt;
        &lt;Link to='/xxx'&gt;NotFound&lt;/Link&gt;
        &lt;p&gt;NavLink&lt;/p&gt;
        &lt;NavLink to='/first' style={({isActive}) =&gt; { return isActive ? { color: 'blue' } : {} }}&gt;页面一&lt;/NavLink&gt;
        &lt;NavLink to='/second' className={({isActive}) =&gt; { return isActive ? 'selected smoll' : ''}}&gt;页面二&lt;/NavLink&gt;
        &lt;Routes&gt;
          &lt;Route path='/home' element={&lt;Home&gt;&lt;/Home&gt;}&gt;&lt;/Route&gt;
          &lt;Route path='/first' element={&lt;First&gt;&lt;/First&gt;}&gt;&lt;/Route&gt;
          &lt;Route path='/second' element={&lt;Second&gt;&lt;/Second&gt;}&gt;&lt;/Route&gt;
          &lt;Route path='*' element={&lt;NotFound&gt;&lt;/NotFound&gt;}&gt;&lt;/Route&gt;
        &lt;/Routes&gt;
      &lt;/Router&gt;
    &lt;/&gt;
  )
}
</code></pre> 
<p>说明：<br> 1、Router 组件包裹整个应用，一个 React 应用只需要使用一次</p> 
<p>2、两种常用 Router：HashRouter 和 BrowserRouter</p> 
<ul><li>HashRouter：使用 URL 的哈希值实现（localhost:3000/#/first）</li><li>（推荐）BrowserRouter：使用 H5 的 history API 实现（localhost:3000/first）</li></ul> 
<p>3、Link 或 NavLink 组件：用于指定导航链接（a标签）。最终Link会编译成a标签，而to属性会被编译成 a标签的href属性。</p> 
<p>4、Route 组件指定路由展示组件相关信息，Route组件写在哪，渲染出来的组件就展示在哪</p> 
<ul><li>path属性：路由规则</li><li>element属性：展示的 React 元素</li></ul> 
<p>5、NavLink就是Link组件的样式增强版，它与Link的用法基本相同，只不过就是多了几个属性进行设置样式，并且当前选中的NavLink组件上会多出一个active类名</p> 
<ul><li>style 属性：接收一个函数，函数接收一个对象，包含isActive属性，表示当前是否被选中；</li><li>className 属性：接收一个函数，函数接收一个对象，包含isActive属性，表示当前是否被选中</li></ul> 
<p>6、通配符，在router6中，支持如下的几种通配符：</p> 
<ul><li>/xxx 确定的路径名，如 ： /home 表示home页面组件能匹配上路径只能是 /home ；</li><li>/xxx/:xxx 动态路径名，:xxx会动态变化的 。如：/home/:id 表示home页面能匹配上 /home/11、/home/22、/home/abc、/home/xxx 等路径；</li><li>/xxx/:xxx/xxx动态路径名后跟确定路径，如： /home/:id/abc 表示home页面能匹配上 /home/11/abc、/home/22/abc 、/home/aa/abc 等路径；</li><li>/xxx/* 确定路径名，后面可以跟多个子路径，如：/home/* 表示home页面能匹配上 /home、/home/12、/home/ab、/home/cd/123 等路径；</li><li>/xxx/:xxx/* 动态路径名后不限制子路径，如：/home/:id/* 表示home页面匹配 /home/11/abc/bcd、 /home/22/qwe 等路径；</li></ul> 
<h4><a id="_358"></a>默认路由</h4> 
<p>现在的路由都是点击导航菜单后展示的，如何在进入页面的时候就展示呢？</p> 
<p>默认路由表示进入页面时就会匹配的路由，默认路由path为 <code>/</code>：</p> 
<pre><code>{/* 默认路由 */}
&lt;Route path='/' element={&lt;home&gt;&lt;/home&gt;}&gt;&lt;/Route&gt;
</code></pre> 
<h4><a id="_368"></a>路由重定向</h4> 
<p>使用Navigate 组件来实现路由的重定向，只要这个组件出现，就会执行重定向跳转，并跳到其对应的to路径中，导入组件：</p> 
<pre><code>import { Navigate } from 'react-router-dom';
</code></pre> 
<p>使用Navigate也很简单，只要将想要被重定向的Route匹配关系中将element属性里的原组件替换成Navigate组件即可；至于想要被重定向到哪个路径，只需要将这个路径写入到Navigate组件中的to属性即可：</p> 
<pre><code>&lt;Route path='/' element={&lt;Navigate to='/home' replace&gt;&lt;/Navigate&gt;}&gt;&lt;/Route&gt;
</code></pre> 
<h4><a id="_379"></a>路由的执行过程</h4> 
<ul><li>点击 Link 或 NavLink 组件（a标签），修改了浏览器地址栏中的 url 。</li><li>React 路由监听到地址栏 url 的变化。</li><li>React 路由内部遍历所有 Route 组件，使用路由规则（ path ）与 pathname 进行匹配。</li><li>当路由规则（path）能够匹配地址栏中的 pathname 时，就展示该 Route 组件的内容。</li></ul> 
<h4><a id="_386"></a>匹配模式</h4> 
<ul><li>精确匹配：只有当 path 和 pathname 完全匹配时才会展示该路由</li><li>模糊匹配：只要 pathname 以 path 开头就会匹配成功</li></ul> 
<p>在router6中，不必再特别去设置exact属性去进行精确匹配组件了，因为router6中已经帮内置进去了。</p> 
<p>如果想模糊匹配某一部分，在路径后加 <code>/*</code>，增加一个匹配规则，将默认路由设置为模糊匹配：</p> 
<pre><code>        &lt;Routes&gt;
          &lt;Route path='/*' element={&lt;Home&gt;&lt;/Home&gt;}&gt;&lt;/Route&gt;
        &lt;/Routes&gt;
</code></pre> 
<h4><a id="_400"></a>路由懒加载</h4> 
<p>在路由中通常会定义很多不同的页面。如果不应用懒加载的话，很多页面都会打包到同一个js文件中，文件将会异常的大。造成进入首页时，需要加载的内容过多，时间过长，在浏览器中可能会出现短暂的空白页，从而降低用户体验，而运用路由懒加载是将各个模块分开打包，用户查看的时候再加载对应的模块，减少加载用时。</p> 
<p>懒加载就是延迟加载，也即在需要的时候才会进行加载所需组件。</p> 
<p>在react中借助React.lazy方法来进行懒加载，用法如下 <code>React.lazy(() =&gt; import("懒加载组件的路径"))</code></p> 
<p>1、定义一个单文件组件：</p> 
<pre><code>import React from "react";

export default class LazyOne extends React.Component {
    render() {
        return (
            &lt;&gt;
                &lt;p&gt;第一个懒加载组件&lt;/p&gt;
            &lt;/&gt;
        )
    }
}
</code></pre> 
<p>2、采用lazy懒加载的形式加载组件</p> 
<pre><code>  const LazyOne = React.lazy(() =&gt; import('./LazyOne'))
</code></pre> 
<p>3、增加路由匹配规则</p> 
<pre><code>&lt;Route path='/lazyOne' element={&lt;LazyOne&gt;&lt;/LazyOne&gt;}&gt;&lt;/Route&gt;
</code></pre> 
<p>4、导航懒加载组件路由</p> 
<pre><code>&lt;Link to='/lazyOne'&gt;懒加载一&lt;/Link&gt;
</code></pre> 
<p>5、此时点击路径跳转，控制台会报错，这是因为当我们是用lazy去懒加载时，应该同时引入Suspense去包裹懒加载的组件。也就是说，lazy处理的懒加载组件一定要处于Suspense组件包裹下。</p> 
<pre><code>      &lt;React.Suspense&gt;
        &lt;Router&gt;
          &lt;Link to='/lazyOne'&gt;懒加载一&lt;/Link&gt;
          &lt;Routes&gt;
            &lt;Route path='/lazyOne' element={&lt;LazyOne&gt;&lt;/LazyOne&gt;}&gt;&lt;/Route&gt;
            &lt;Route path='*' element={&lt;NotFound&gt;&lt;/NotFound&gt;}&gt;&lt;/Route&gt;
          &lt;/Routes&gt;
        &lt;/Router&gt;
      &lt;/React.Suspense&gt;
</code></pre> 
<p>引入Suspense之后，再去点击跳转控制台就不会再报错了。</p> 
<p>6、当网络不好的时候进行页面跳转，会出现长时间的白屏现象。可以利用Suspense组件的fallback属性来进行改善用户体感，将fallback的值设置为antd的Spin组件：</p> 
<pre><code>      &lt;React.Suspense fallback={&lt;Spin&gt;&lt;/Spin&gt;}&gt;
        &lt;Router&gt;
          &lt;Link to='/lazyOne'&gt;懒加载一&lt;/Link&gt;
          &lt;Routes&gt;
            &lt;Route path='/lazyOne' element={&lt;LazyOne&gt;&lt;/LazyOne&gt;}&gt;&lt;/Route&gt;
            &lt;Route path='*' element={&lt;NotFound&gt;&lt;/NotFound&gt;}&gt;&lt;/Route&gt;
          &lt;/Routes&gt;
        &lt;/Router&gt;
      &lt;/React.Suspense&gt;
</code></pre> 
<blockquote> 
 <p>fallback是Suspense组件的属性，其作用是当lazy处理的懒加载组件还没有加载出来时要显示的内容。一般地都会往fallback属性里传入一个loading动画，用来缓解加载白屏的问题。</p> 
</blockquote> 
<p>当组件处于加载状态时，fallback组件是替换了整个 Suspense 组件包裹的内容，此时只显示了Spin组件。但实际上在路由切换的时候是不应该全部被 Suspense 的 fallback 替代的，因为路由切换时有的部分是不变的。造成此部分也被替换的原因是，Suspense 组件包裹的范围太广了。按照正常逻辑只要动态加载的那部分被替换，其余不变的部分就仍然展示。对此需要缩小 Suspense 组件的包裹范围，只让它包裹住懒加载的组件即可。这时候可以使用 高阶组件 或 render-props来配合处理懒加载组件：</p> 
<pre><code>// 高阶组件
const withLoading = (WrapedComponent) =&gt; {
  class LoadingCom extends React.Component {
    render() {
      return (&lt;React.Suspense fallback={&lt;Spin&gt;&lt;/Spin&gt;}&gt;&lt;WrapedComponent {...this.props}&gt;&lt;/WrapedComponent&gt;&lt;/React.Suspense&gt;)
    }
  }
  LoadingCom.displayName = `WithLoading${getDisplayName(WrapedComponent)}`
  return LoadingCom
}

// render-props 
function FuncLoading(props) {
  return (
    &lt;React.Suspense fallback={&lt;Spin&gt;&lt;/Spin&gt;}&gt;
      {props.children}
    &lt;/React.Suspense&gt;
  )
}

const RouteLazy = () =&gt; {
  const LazyOne = React.lazy(() =&gt; import('./LazyOne'))
  const LazyTwo = React.lazy(() =&gt; import('./LazyTwo'))
  const LazyThree = React.lazy(() =&gt; import('./LazyThree'))
  const LoadingOne = withLoading(LazyTwo)
  return (
    &lt;&gt;
      &lt;React.Suspense fallback={&lt;Spin&gt;&lt;/Spin&gt;}&gt;
        &lt;Router&gt;
          &lt;div&gt;
            &lt;Link to='/lazyOne'&gt;懒加载一&lt;/Link&gt;
            &lt;Link to='/loadingOne'&gt;懒加载二优化&lt;/Link&gt;
            &lt;Link to='/loadingTwo'&gt;懒加载三优化&lt;/Link&gt;
          &lt;/div&gt;
          &lt;Routes&gt;
            &lt;Route path='/lazyOne' element={&lt;LazyOne&gt;&lt;/LazyOne&gt;}&gt;&lt;/Route&gt;
            &lt;Route path='/loadingOne' element={&lt;LoadingOne&gt;&lt;/LoadingOne&gt;}&gt;&lt;/Route&gt;
            &lt;Route path='/loadingTwo' element={&lt;FuncLoading&gt;&lt;LazyThree&gt;&lt;/LazyThree&gt;&lt;/FuncLoading&gt;}&gt;&lt;/Route&gt;
            &lt;Route path='*' element={&lt;NotFound&gt;&lt;/NotFound&gt;}&gt;&lt;/Route&gt;
          &lt;/Routes&gt;
        &lt;/Router&gt;
      &lt;/React.Suspense&gt;
    &lt;/&gt;
  )
}
ReactDOM.createRoot(document.getElementById('routeLazy')).render(&lt;RouteLazy&gt;&lt;/RouteLazy&gt;)
</code></pre> 
<p>其中 LazyTwo、LazyThree 组件与前面的 LazyOne 类似，略。</p> 
<h4><a id="_520"></a>路由嵌套</h4> 
<p>在Router5中是将嵌套的子路由直接写在父路由对应的组件内部的。这样有个弊端就是Route太分散了，各个组件里都有Route。Router6.X对此做了一个调整，现在不用分散嵌套子路由，取而代之的是路由嵌套统一在一个 Routes 组件下维护。</p> 
<p>想要子路由生效，必须还得在其所属的父路由里引入一个Outlet组件进行路由占位。想要让子路由在哪里展示，就把Outlet放到其内部即可：</p> 
<pre><code>import { BrowserRouter as Router, Routes, Route, Link, NavLink, Outlet } from 'react-router-dom'

const ContentOne = () =&gt; { return (&lt;p&gt;内容一&lt;/p&gt;) }
const ContentTwo = () =&gt; { return (&lt;p&gt;内容二&lt;/p&gt;) }
const ContentThree = () =&gt; { return (&lt;p&gt;内容三&lt;/p&gt;) }
const NoContent = () =&gt; { return (&lt;p&gt;没有内容&lt;/p&gt;) }
// 主体结构组件
const MainBody = () =&gt; {
  return (
    &lt;div className='mainBody'&gt;
      {/* 头部区域 */}
      &lt;div className='top'&gt;
        路由嵌套
        &lt;Consumer&gt;
          {(data) =&gt; &lt;button onClick={data.logout}&gt;退出&lt;/button&gt;}
        &lt;/Consumer&gt;
      &lt;/div&gt;

      {/* 左边栏区域 */}
      &lt;div className='leftAside'&gt;
        左边栏
        &lt;ul&gt;
          &lt;li&gt;&lt;Link to='/'&gt;内容一&lt;/Link&gt;&lt;/li&gt;
          &lt;li&gt;&lt;Link to='/two'&gt;内容二&lt;/Link&gt;&lt;/li&gt;
          &lt;li&gt;&lt;Link to='/three'&gt;内容三&lt;/Link&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt;
      
      {/* 内容区域 */}
      &lt;div className='content'&gt;
        内容
        &lt;Outlet&gt;&lt;/Outlet&gt;
      &lt;/div&gt;

      {/* 底部区域 */}
      &lt;div className='bottom'&gt;底部区域&lt;/div&gt;
    &lt;/div&gt;
  )
}
// 登录组件
const Login = () =&gt; {
  return (
    &lt;Consumer&gt;
      {(data) =&gt; &lt;button onClick={data.login}&gt;登录&lt;/button&gt;}
    &lt;/Consumer&gt;
  )
}
class RouteNest extends React.Component {
  state = { isLogin: false }
  render() {
    const main = &lt;Provider value={<!-- -->{ logout: () =&gt; this.setState({ isLogin: false }) }}&gt;&lt;MainBody&gt;&lt;/MainBody&gt;&lt;/Provider&gt;
    const login = &lt;Provider value={<!-- -->{ login: () =&gt; this.setState({ isLogin: true }) }}&gt;&lt;Login&gt;&lt;/Login&gt;&lt;/Provider&gt;
    const first = (&lt;&gt;{this.state.isLogin ? main : login}&lt;/&gt;)
    return (
      &lt;Router&gt;
        &lt;Routes&gt;
          {/* 父路由（默认） */}
          &lt;Route path='/' element={first}&gt;
            {/* 子路由 */}
            {/* 默认子路由 */}
            {/* &lt;Route path='/' element={&lt;ContentOne&gt;&lt;/ContentOne&gt;}&gt;&lt;/Route&gt; */}
            &lt;Route index element={&lt;ContentOne&gt;&lt;/ContentOne&gt;}&gt;&lt;/Route&gt;
            &lt;Route path='/two' element={&lt;ContentTwo&gt;&lt;/ContentTwo&gt;}&gt;&lt;/Route&gt;
            &lt;Route path='/three' element={&lt;ContentThree&gt;&lt;/ContentThree&gt;}&gt;&lt;/Route&gt;
          &lt;/Route&gt;
          &lt;Route path='/login' element={&lt;Login&gt;&lt;/Login&gt;}&gt;&lt;/Route&gt;
          &lt;Route path='*' element={&lt;NotFound&gt;&lt;/NotFound&gt;}&gt;&lt;/Route&gt;
        &lt;/Routes&gt;
      &lt;/Router&gt;
    )
  }
}
ReactDOM.createRoot(document.getElementById('routeNest')).render(&lt;RouteNest&gt;&lt;/RouteNest&gt;)
</code></pre> 
<img src="https://images2.imgbox.com/7e/69/PlGs1Z4n_o.png" height="250px"> 
<blockquote> 
 <p>如何设置默认显示的子路由？只需要在想要被设为默认展示的子路由上写一个 index属性即可（注意，被设置index的子路由不能再设置path属性），那么当访问 ‘/’ 就能做到默认展示子路由了，跳转路径也的相应调整为 <code>&lt;Link to='/'&gt;内容一&lt;/Link&gt;</code>。也可以直接将默认子路由设置为 <code>&lt;Route path='/' element={&lt;ContentOne&gt;&lt;/ContentOne&gt;}&gt;&lt;/Route&gt;</code>。</p> 
</blockquote> 
<blockquote> 
 <p>注意：路由嵌套时，子路由的path路径要以父路由的path名开头，否则会报错。</p> 
</blockquote> 
<h4><a id="_606"></a>编程式导航</h4> 
<p>如果希望通过JS代码跳转，需要通过useNavigate获取到navigate对象对象然后进行后续操作。</p> 
<pre><code>import { useNavigate } from 'react-router-dom'
</code></pre> 
<p>使用类组件开发则需要封装高阶函数，也即手动封装withRouter：</p> 
<pre><code>function withRouter(WrapedComponent) {
  function ComponentWithRouter(props) {
    const navigate = useNavigate()
    return &lt;WrapedComponent {...props} router={navigate}&gt;&lt;/WrapedComponent&gt;
  }
  ComponentWithRouter.displayName = `WithRouter${getDisplayName(WrapedComponent)}`

  return ComponentWithRouter
}
</code></pre> 
<p>可以直接调用 useNavigate 函数去返回一个navigate，然后调用navigate并将跳转路径作为参数传进去，例如：navigate(‘url路径’)，当的navigate传入数字时（一般是-1），是跳到路由栈当前路由前面几个对应的路由。 navigate里也可以传第二个options参数: {replace,state} 。replace参数代表替换当前路由栈中的路由，state代表路由传参：</p> 
<pre><code>function Red() { return (&lt;div style={<!-- -->{ backgroundColor: 'red', width: '100px', height: '100px' }}&gt;&lt;/div&gt;) }
function Green() { return (&lt;div style={<!-- -->{ backgroundColor: 'green', width: '100px', height: '100px' }}&gt;&lt;/div&gt;) }
// 类组件
class ClassComponent extends React.Component {
  render() { return (&lt;&gt;
    &lt;p&gt;类组件&lt;/p&gt;
    &lt;button onClick={() =&gt; this.props.router('/red')}&gt;红&lt;/button&gt;
    &lt;button onClick={() =&gt; this.props.router('/green', { replace: true, state: { data: '数据' }})}&gt;绿&lt;/button&gt;
    &lt;button onClick={() =&gt; this.props.router(-1)}&gt;返回&lt;/button&gt;
  &lt;/&gt;) }
}
// 函数组件
function FuncComponent() {
  const navigate = useNavigate()
  return (&lt;&gt;
    &lt;p&gt;函数组件&lt;/p&gt;
    &lt;button onClick={() =&gt; navigate('/red')}&gt;红&lt;/button&gt;
    &lt;button onClick={() =&gt; navigate('/green', { replace: true, state: { data: '数据' }})}&gt;绿&lt;/button&gt;
    &lt;button onClick={() =&gt; navigate(-1)}&gt;返回&lt;/button&gt;
  &lt;/&gt;)
}
function FuncRoute(props) {
  const WithRouterCom = withRouter(ClassComponent)
  return (
    &lt;Router&gt;
      &lt;WithRouterCom&gt;&lt;/WithRouterCom&gt;
      &lt;FuncComponent&gt;&lt;/FuncComponent&gt;
      &lt;Routes&gt;
        &lt;Route path='/red' element={&lt;Red&gt;&lt;/Red&gt;}&gt;&lt;/Route&gt;
        &lt;Route path='/green' element={&lt;Green&gt;&lt;/Green&gt;}&gt;&lt;/Route&gt;
        &lt;Route path='*' element={&lt;NotFound&gt;&lt;/NotFound&gt;}&gt;&lt;/Route&gt;
      &lt;/Routes&gt;
    &lt;/Router&gt;
  )
}
ReactDOM.createRoot(document.getElementById('funcRoute')).render(&lt;FuncRoute&gt;&lt;/FuncRoute&gt;)
</code></pre> 
<blockquote> 
 <p>路径如果以 <code>/</code> 开头代表 根路由+当前路径拼接成新路由； 不以 <code>/</code> 开头表示在当前路由后再跟上路径拼接成新路由路径。</p> 
</blockquote> 
<pre><code>navigate("/register") // 跳转后路径为 http://localhost:3000/register
navigate("register") // 跳转后路径为 http://localhost:3000/home/register
</code></pre> 
<h4><a id="_672"></a>路由传参</h4> 
<p>路由传参一般用到三种方式：动态路径传参、search参数传递、state传递参数。</p> 
<h5><a id="_676"></a>动态路径传参</h5> 
<p>如果将path在Route匹配时写成 <code>/detail/:id</code> 那么 <code>/detail/abc</code> 、 <code>/detail/123</code> 都可以匹配到该Route对应的组件并进行显示，针对动态路径传参的这种方式，常用 useParams 来进行获取参数。</p> 
<pre><code>import { useParams } from 'react-router-dom'

function Detail() { 
  const params = useParams()
  let value = ''
  switch (params.id) {
    case '1':
      value = '一'
      break;
    case '2':
      value = '二'
      break
    default:
      break;
  }
  return (&lt;p&gt;详情{value}&lt;/p&gt;) 
}

function ParamsCom() {
  const navigate = useNavigate()
  return (&lt;&gt;
    &lt;p&gt;动态路径传参&lt;/p&gt;
    &lt;Link to='/detail/1'&gt;详情一&lt;/Link&gt;
    &lt;button onClick={() =&gt; navigate('/detail/2')}&gt;去详情二&lt;/button&gt;
  &lt;/&gt;)
}

function RouteParams() {
  return (&lt;Router&gt;
    &lt;ParamsCom&gt;&lt;/ParamsCom&gt;
    &lt;Routes&gt;
      &lt;Route path='/detail/:id' element={&lt;Detail&gt;&lt;/Detail&gt;}&gt;&lt;/Route&gt;
      &lt;Route path='*' element={&lt;NotFound&gt;&lt;/NotFound&gt;}&gt;&lt;/Route&gt;
    &lt;/Routes&gt;
  &lt;/Router&gt;)
}
ReactDOM.createRoot(document.getElementById('routeParams')).render(&lt;RouteParams&gt;&lt;/RouteParams&gt;)
</code></pre> 
<blockquote> 
 <p>说明：动态路径可以配置多个参数，如 <code>&lt;Route path='/detail/:id/:lastId' element={&lt;Detail&gt;&lt;/Detail&gt;}&gt;&lt;/Route&gt;</code></p> 
</blockquote> 
<h5><a id="search_721"></a>search传参</h5> 
<p>seatch 传递参数就是把我们要传递的参数拼接到url上进行传递，具体方式是以 <code>?</code> 开头，键值对的形式传参，每个参数之间用 <code>&amp;</code> 连接，如 <code>http://localhost:3000/list?page=1&amp;size=10</code>。</p> 
<p>一般使用 useSearchParams 这个函数来获取 search 参数（也可用useLocation，不过得额外再处理下search参数），注意 <code>useSearchParams</code> 返回的是个数组，且数组里是一个 URLSearchParams 当前值和 set 方法。并且取值时常借助 <code>Object.fromEntries</code> 这个方法：</p> 
<pre><code>import { useSearchParams } from 'react-router-dom'

function User() {
  const [searchParams] = useSearchParams()
  const params = Object.fromEntries(searchParams)
  return (&lt;p&gt;id: {params.id}, name: {params.name}, age: {params.age}&lt;/p&gt;)
}
function ParamsCom() {
  const navigate = useNavigate()
  return (&lt;&gt;
    &lt;p&gt;search传参&lt;/p&gt;
    &lt;Link to='/user?id=1&amp;name=zhangsan&amp;age=18'&gt;用户一&lt;/Link&gt;
    &lt;button onClick={() =&gt; navigate('/user?id=2&amp;name=lisi&amp;age=19')}&gt;去用户二&lt;/button&gt;
  &lt;/&gt;)
}
function RouteParams() {
  return (&lt;Router&gt;
    &lt;ParamsCom&gt;&lt;/ParamsCom&gt;
    &lt;Routes&gt;
      &lt;Route path='/user' element={&lt;User&gt;&lt;/User&gt;}&gt;&lt;/Route&gt;
      &lt;Route path='*' element={&lt;NotFound&gt;&lt;/NotFound&gt;}&gt;&lt;/Route&gt;
    &lt;/Routes&gt;
  &lt;/Router&gt;)
}
ReactDOM.createRoot(document.getElementById('routeParams')).render(&lt;RouteParams&gt;&lt;/RouteParams&gt;)
</code></pre> 
<blockquote> 
 <p><code>Object.entries()</code> 是将对象转成一个自身可枚举属性的键值对数组，同样也可以把键值对数组转成了对象。<code>Object.fromEntries</code> 是 <code>Object.entries</code> 反向，<code>Object.fromEntries()</code> 方法把键值对列表转换为一个对象。</p> 
</blockquote> 
<h5><a id="state_756"></a>state传参</h5> 
<p>上面两种方式的传参都有一个缺点即传递的参数都在url路径上体现了，并且涉及到复杂类型的参数传递就显得很麻烦了。如果不想参数在url上面，且想传些对象时就可以采取这种state传参的方式。使用useLocation钩子来获取state参数。</p> 
<pre><code>import { useLocation } from 'react-router-dom'

function Content() {
  const { state } = useLocation()
  console.log('state: ', state);
  return (&lt;p&gt;{state.content}&lt;/p&gt;)
}
function ParamsCom() {
  const navigate = useNavigate()
  return (&lt;&gt;
    &lt;p&gt;state传参&lt;/p&gt;
    &lt;Link to='/content' state={<!-- -->{content: '这是内容一的内容'}}&gt;内容一&lt;/Link&gt;
    &lt;button onClick={() =&gt; navigate('/content', {state: { content: '这是内容二的内容' } })}&gt;去内容二&lt;/button&gt;
  &lt;/&gt;)
}
function RouteParams() {
  return (&lt;Router&gt;
    &lt;ParamsCom&gt;&lt;/ParamsCom&gt;
    &lt;Routes&gt;
      &lt;Route path='/content' element={&lt;Content&gt;&lt;/Content&gt;}&gt;&lt;/Route&gt;
      &lt;Route path='*' element={&lt;NotFound&gt;&lt;/NotFound&gt;}&gt;&lt;/Route&gt;
    &lt;/Routes&gt;
  &lt;/Router&gt;)
}
ReactDOM.createRoot(document.getElementById('routeParams')).render(&lt;RouteParams&gt;&lt;/RouteParams&gt;)
</code></pre> 
<h4><a id="useRoutes__787"></a>useRoutes 配置化路由</h4> 
<p>前面都是用Route组件的方式来实现路由配置的，但现在都提倡配置化，能不能把routes相关的配置都维护到一串数据里，不用以组件-属性这种方式管理呢？</p> 
<p>在 router5 中需引入的 react-router-config 这个三方库来帮维护。但在 Router6 官方给提供了 useRoutes 这个函数。凭此可以将 routes 对象以参数形式传入 useRoutes 中，此函数会根据 routes 里的匹配关系对应渲染成相关的路由组件。</p> 
<p>routes其本身是一个数组，数组里维护各个匹配关系的对象。匹配关系这个对象里一般都有path、element、children、index属性：</p> 
<ul><li>path属性就是组件对应的路径；</li><li>element属性就是要对应的组件；</li><li>index属性就是默认要展示的页面组件;</li><li>children属性是路由嵌套时需要用也是一个数组，children数组里的属性和外层一样，子路由的配置就是在children属性里维护的。</li></ul> 
<p>useRoutes的使用只要将路由配置对象 routes 传到 useRoutes 函数即可：</p> 
<pre><code>// 军事新闻组件
const Junshi = () =&gt; { return (&lt;p&gt;军事新闻&lt;/p&gt;) }
// 财经新闻组件
const Caijin = () =&gt; { return (&lt;p&gt;财经新闻&lt;/p&gt;) }
// 体验新闻组件
const Tiyu = () =&gt; { return (&lt;p&gt;体育新闻&lt;/p&gt;) }
// 布局组件
const Layout = () =&gt; {
  return (
    &lt;div className='mainBody'&gt;
      {/* 头部区域 */}
      &lt;div className='top'&gt;useRoutes 配置化路由&lt;/div&gt;

      {/* 左边栏区域 */}
      &lt;div className='leftAside'&gt;
        左边栏
        &lt;ul&gt;
          &lt;li&gt;&lt;Link to='/'&gt;军事&lt;/Link&gt;&lt;/li&gt;
          &lt;li&gt;&lt;Link to='/caijin'&gt;财经&lt;/Link&gt;&lt;/li&gt;
          &lt;li&gt;&lt;Link to='/tiyu'&gt;体育&lt;/Link&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt;

      {/* 内容区域 */}
      &lt;div className='content'&gt;
        内容
        &lt;Outlet&gt;&lt;/Outlet&gt;
      &lt;/div&gt;

      {/* 底部区域 */}
      &lt;div className='bottom'&gt;底部区域&lt;/div&gt;
    &lt;/div&gt;
  )
}

// 路由配置对象
const routes = [
  {
    path: '/',
    element: &lt;Layout&gt;&lt;/Layout&gt;,
    children: [
      {
        index: true,
        element: &lt;Junshi&gt;&lt;/Junshi&gt;
      },
      {
        path: '/caijin',
        element: &lt;Caijin&gt;&lt;/Caijin&gt;
      },
      {
        path: '/tiyu',
        element: &lt;Tiyu&gt;&lt;/Tiyu&gt;
      }
    ]
  },
  {
    path: '*',
    element: &lt;NotFound&gt;&lt;/NotFound&gt;
  }
]
function RouteCom() {
  console.log('RouteCom render');
  
  // useRoutes 配置化路由
  return (&lt;&gt;{useRoutes(routes)}&lt;/&gt;)
}
function ConfigRoute() {
  return (&lt;Router&gt;&lt;RouteCom&gt;&lt;/RouteCom&gt;&lt;/Router&gt;)
}
ReactDOM.createRoot(document.getElementById('configRoute')).render(&lt;ConfigRoute&gt;&lt;/ConfigRoute&gt;)
</code></pre> 
<h5><a id="useRoutes__rerender__873"></a>useRoutes 的 rerender 问题</h5> 
<p>可以发现 useRoutes 配置化路由只要切换路由 RouteCom 组件就会重新渲染，而换成如下方式则不会重新渲染：</p> 
<pre><code>function RouteCom() {
  console.log('RouteCom render');

  return &lt;Routes&gt;
    &lt;Route path='/' element={&lt;Layout&gt;&lt;/Layout&gt;}&gt;
      &lt;Route index element={&lt;Junshi&gt;&lt;/Junshi&gt;}&gt;&lt;/Route&gt;
      &lt;Route path='/caijin' element={&lt;Caijin&gt;&lt;/Caijin&gt;}&gt;&lt;/Route&gt;
      &lt;Route path='/tiyu' element={&lt;Tiyu&gt;&lt;/Tiyu&gt;}&gt;&lt;/Route&gt;
    &lt;/Route&gt;
    &lt;Route path='*' element={&lt;NotFound&gt;&lt;/NotFound&gt;}&gt;&lt;/Route&gt;
  &lt;/Routes&gt;
}
</code></pre> 
<p>由于 useRoutes 是通过 context 实现的，切换路由时 context 共享出来的 value 值发生了变化，从而使得使用到这个 context 的组件触发了 rerender，这也就造成了使用 useRoutes 的 RouteCom 组件在切换路由时重新渲染了！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a1acb10464c033cc7196a9b42c5e68d9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">IDEA切换分支，会影响当前在跑的项目吗？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/439ca4349c137571ce64b633af3d220c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C&#43;&#43;进阶学习】第十一弹——C&#43;&#43;11（上）——右值引用和移动语义</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>