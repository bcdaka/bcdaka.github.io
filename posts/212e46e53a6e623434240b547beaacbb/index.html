<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>docker k8s - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/212e46e53a6e623434240b547beaacbb/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="docker k8s">
  <meta property="og:description" content="1、docker是什么？
将环境和程序一起打包给到 服务器运行的工具软件。
2、基础镜像base image是什么？
操作系统：用户空间、内核空间
阉割操作系统，利用其的用户空间（因为应用程序运行在用户空间），文件系统，依赖库打包成一个类似“压缩包”的文件。这就是所谓的基础镜像base image。
3、dockerfile是什么？
有了base image还不够，我们还需安装一些依赖和创建一些文件夹，最后才是运行我们的目标应用程序。因此我们将所有的要做的事情以命令行的形式分行列举出来，类似于一份todo List。像这份列清楚了从操作系统到应用服务启动需要做哪些事情的清单文件就是所谓的dockerfile。
4、container image（容器镜像）是什么
dockerfile只是描述了做哪些事情，并没开始做，用命令docker build执行的时候，docker软件就按照dockerfile说明，一行行构建环境加应用程序，最终将这个环境和应用程序打包成一个类似“压缩包”的东西，我们把它称之为容器镜像。
只要将容器镜像传到任意一台服务器对该“压缩包”进行“解压缩”，就可以同时运行环境和程序。
5、registry是什么？
服务器那么多，挨个将容器镜像传到上去，压力给到发送方的网络带宽了。
因此弄一个镜像仓库，通过docker push到镜像仓库，有需要的服务器通过docker pull将镜像拉到机器上，这个负责管理镜像仓库推拉能力的服务叫做docker registry。
6、容器是什么？
通过指令docker pull在服务器上拿到容器镜像，通过docker run，将这个类似压缩包的容器镜像进行解压缩，获得一个独立的环境和应用程序，并运行起来，这样一个独立的环境和应用程序就是所谓的容器。我们可以在一个操作系统上同时跑多个容器，且这些容器互相独立和隔离。
7、容器和虚拟机的关系
区别：容器不带操作系统，虚拟机带有一个操作系统。容器只包含核心依赖库和配置文件等必要组件，它利用一个namespace的能力，让它看起来像一个独立的操作系统。再利用一个cgroup的能力限制它能使用的计算资源。因此容器是一个自带独立运行环境的特殊进程，底层用的是宿主机的操作系统内核。
8、docker 的架构原理
经典的client-server架构。client对应docker-cli，sever对应docker daemon。我们在命令行里敲docker命令，使用的就是docker-cli，docker-cli会解析我们输入的command命令，然后调用docker daemon守护进程提供的restful-api，守护进程收到命令后，会根据命令创建和管理各个容器。
docker daemon架构：
docker daemon分成docker server和engine两层。docker server是个http服务器，负责对外提供操作容器和镜像api。接口接收到api请求后，会分发任务给engine层，engine层负责创建job，由job实际执行各种工作。
不同的docker命令会执行不同类型的job任务。
（1）docker build命令执行过程。
job根据dockerfile指令，像包洋葱皮似的一层层构建容器镜像文件。
（2）docker pull/push命令执行过程。
镜像推拉操作，job会根据外部的docker registry交互将镜像上传/下载。
（3）docker run命令执行过程。
job基于镜像文件调用containerd组件，驱使runC组件创建和运行容器。
9、docker compose是什么？多个容器一整套的部署。
docker容器本身是一个特殊的进程，但我们想部署多个容器，且对这些容器的顺序有一定的要求。比如一个博客，先启动数据库，再启动身份验证服务，最后启动博客微服务。因此普通做法是依次启动服务，但有更优雅的启动方式，通过一个yaml文件，写清楚要部署的容器有哪些，以及部署顺序，以及容器占有的cpu和内存信息。只需要通过docker compose命令解析yaml文件，将容器们一键按照顺序部署，就完成一整套的部署。
10、docker swam
它解决的是一整套服务，在多台服务器上的集群部署问题。如在a服务器上坏了，可以部署到b服务器上。还能根据需要对应用做扩缩容。
11、docker和k8s的关系。
k8s它会在多台node的服务器上调度pod进行部署和扩缩容。每个pod含有多个container，每个container本质上是一个服务进程。
k8s和swam的功能很像。
docker部署的容器就是k8s调度的pod里的container，它们都叫容器。docker compose基于多个docker container创建一整套服务，其实就是k8s里的pod。而docker swarn做的事情和k8s一样，本质就是在调度pod。
k8s称之为容器编排引擎，将它理解为以api编程的方式管理安排各个容器的引擎。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-30T21:44:56+08:00">
    <meta property="article:modified_time" content="2024-06-30T21:44:56+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">docker k8s</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p>1、docker是什么？</p> 
<p>将环境和程序一起打包给到 服务器运行的工具软件。</p> 
<p></p> 
<p><img alt="" height="802" src="https://images2.imgbox.com/84/ca/m50TzGqb_o.jpg" width="796"></p> 
<p>2、基础镜像base image是什么？</p> 
<p>操作系统：用户空间、内核空间</p> 
<p>阉割操作系统，利用其的用户空间（因为应用程序运行在用户空间），文件系统，依赖库打包成一个类似“压缩包”的文件。这就是所谓的基础镜像base image。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b7/1a/aQpSzvFz_o.png"></p> 
<hr> 
<p>3、dockerfile是什么？</p> 
<p>有了base image还不够，我们还需安装一些依赖和创建一些文件夹，最后才是运行我们的目标应用程序。因此我们将所有的要做的事情以命令行的形式分行列举出来，类似于一份todo List。像这份列清楚了从操作系统到应用服务启动需要做哪些事情的清单文件就是所谓的dockerfile。<img alt="" src="https://images2.imgbox.com/c2/e4/MdoWK8kT_o.png"></p> 
<p>4、container image（容器镜像）是什么</p> 
<p>dockerfile只是描述了做哪些事情，并没开始做，用命令docker build执行的时候，docker软件就按照dockerfile说明，一行行构建环境加应用程序，最终将这个环境和应用程序打包成一个类似“压缩包”的东西，我们把它称之为容器镜像。</p> 
<p>只要将容器镜像传到任意一台服务器对该“压缩包”进行“解压缩”，就可以同时运行环境和程序。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/87/28/8lNgXWlw_o.png"></p> 
<p>5、registry是什么？</p> 
<p>服务器那么多，挨个将容器镜像传到上去，压力给到发送方的网络带宽了。</p> 
<p>因此弄一个镜像仓库，通过docker push到镜像仓库，有需要的服务器通过docker pull将镜像拉到机器上，这个负责管理镜像仓库推拉能力的服务叫做docker registry。</p> 
<p>6、容器是什么？</p> 
<p>通过指令docker pull在服务器上拿到容器镜像，通过docker run，将这个类似压缩包的容器镜像进行解压缩，获得一个独立的环境和应用程序，并运行起来，这样一个独立的环境和应用程序就是所谓的容器。我们可以在一个操作系统上同时跑多个容器，且这些容器互相独立和隔离。</p> 
<p><img alt="" src="https://images2.imgbox.com/29/d0/Jf1KgyIh_o.png"></p> 
<p>7、容器和虚拟机的关系</p> 
<p>区别：容器不带操作系统，虚拟机带有一个操作系统。容器只包含核心依赖库和配置文件等必要组件，它利用一个namespace的能力，让它看起来像一个独立的操作系统。再利用一个cgroup的能力限制它能使用的计算资源。因此容器是一个自带独立运行环境的特殊进程，底层用的是宿主机的操作系统内核。</p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2c/15/bpJ2S5yy_o.png"></p> 
<p>8、docker 的架构原理</p> 
<p>经典的client-server架构。client对应docker-cli，sever对应docker daemon。我们在命令行里敲docker命令，使用的就是docker-cli，docker-cli会解析我们输入的command命令，然后调用docker daemon守护进程提供的restful-api，守护进程收到命令后，会根据命令创建和管理各个容器。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c1/92/p3GftN6s_o.png"></p> 
<p>docker daemon架构：</p> 
<p>docker daemon分成docker server和engine两层。docker server是个http服务器，负责对外提供操作容器和镜像api。接口接收到api请求后，会分发任务给engine层，engine层负责创建job，由job实际执行各种工作。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/77/2c/AzCC4AO9_o.png"></p> 
<p style="text-align:center;">不同的docker命令会执行不同类型的job任务。</p> 
<p><img alt="" src="https://images2.imgbox.com/09/2e/PbOSlt7H_o.png"></p> 
<p>（1）docker build命令执行过程。</p> 
<p>job根据dockerfile指令，像包洋葱皮似的一层层构建容器镜像文件。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b8/84/fTMMTto5_o.png"></p> 
<p>（2）docker pull/push命令执行过程。</p> 
<p>镜像推拉操作，job会根据外部的docker registry交互将镜像上传/下载。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e4/7a/P9MFg8vb_o.png"></p> 
<p style="text-align:center;"></p> 
<p>（3）docker run命令执行过程。</p> 
<p>job基于镜像文件调用containerd组件，驱使runC组件创建和运行容器。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d5/3d/Gzox3n8a_o.png"></p> 
<p></p> 
<p>9、docker compose是什么？多个容器一整套的部署。</p> 
<p>docker容器本身是一个特殊的进程，但我们想部署多个容器，且对这些容器的顺序有一定的要求。比如一个博客，先启动数据库，再启动身份验证服务，最后启动博客微服务。因此普通做法是依次启动服务，但有更优雅的启动方式，通过一个yaml文件，写清楚要部署的容器有哪些，以及部署顺序，以及容器占有的cpu和内存信息。只需要通过docker compose命令解析yaml文件，将容器们一键按照顺序部署，就完成一整套的部署。</p> 
<p>10、docker swam</p> 
<p>它解决的是一整套服务，在多台服务器上的集群部署问题。如在a服务器上坏了，可以部署到b服务器上。还能根据需要对应用做扩缩容。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/0b/68/gltGYo1x_o.png"></p> 
<p>11、docker和k8s的关系。</p> 
<p>k8s它会在多台node的服务器上调度pod进行部署和扩缩容。每个pod含有多个container，每个container本质上是一个服务进程。</p> 
<p>k8s和swam的功能很像。</p> 
<p>docker部署的容器就是k8s调度的pod里的container，它们都叫容器。docker compose基于多个docker container创建一整套服务，其实就是k8s里的pod。而docker swarn做的事情和k8s一样，本质就是在调度pod。</p> 
<p>k8s称之为容器编排引擎，将它理解为以api编程的方式管理安排各个容器的引擎。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2f/2d/Oe86ZF2U_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c5/f8/8cHtWAVh_o.png"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/be515d95b92f33d0779ea69aabc9dd57/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">记一次小程序渗透</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bb625b9c60ce28d4df47081a81d61c80/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AI陪伴产品的情感设计：从孤独感到恋爱感评分：9/10</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>