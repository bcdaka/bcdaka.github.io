<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【算法】基础算法001之双指针 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/ef522a726a24f0f569730baad9c253d3/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【算法】基础算法001之双指针">
  <meta property="og:description" content="👀樊梓慕：个人主页
🎥个人专栏：《C语言》《数据结构》《蓝桥杯试题》《LeetCode刷题笔记》《实训项目》《C&#43;&#43;》《Linux》《算法》
🌝每一个不曾起舞的日子，都是对生命的辜负
目录
前言
1.数组分块（数组划分）
移动零
复写零
2.快慢双指针（循环往复）
快乐数
3.对撞指针-&gt;暴力枚举的优化-&gt;利用单调性
盛最多水的容器
有效三角形的个数
4.对撞指针-&gt;两数之和、三数之和、四数之和
两数之和
三数之和
四数之和
前言 💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐
《算法》专栏正式挂牌成立
《算法》专栏主要是会系统的梳理一些OJ题的算法思想，将他们按照解题方法的不同划分出来，然后归纳总结，当然希望大家多多收藏，以后忘了可以常回来看看！ 💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐
本篇文章主要会讲解双指针的思想，双指针是一种非常优秀的算法思想，有对撞指针和快慢指针两种基本用法。
双指针对于有序数据的处理是比较有优势的，当你遇到有序的数据时，你可以尝试着利用双指针或者二分来解题，当然本篇文章只会讲解双指针。
那么双指针思想具体的应用，以及为什么双指针适用于有序数组的处理呢？
欢迎大家📂收藏📂以便未来做题时可以快速找到思路，巧妙的方法可以事半功倍。
=========================================================================
GITEE相关代码：🌟fanfei_c的仓库🌟
=========================================================================
1.数组分块（数组划分） 数组分块顾名思义，该类题目有一个特性就是将数组中的数据进行分类，然后将分类的数据放在不同的区域上。
移动零 移动零 - 力扣（LeetCode）https://leetcode.cn/problems/move-zeroes/description/
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
请注意 ，必须在不复制数组的情况下原地对数组进行操作。
利用数组分块的思想，我们可以将该数组划分为三个区域：非零的已处理区域、零的已处理区域、待处理区域。
三个区域恰好可以利用两个指针进行分割得到。
所以我们定义两个指针：
cur：从左向右扫描数组（遍历数组的作用），主要用来分割已处理区域和待处理区域用；dest：已处理的区域内，非零元素的最后一个位置，主要用来分隔已处理区域内部非零元素和零元素。 得到三个区间：
非零的已处理区域：[0,dest]零的已处理区域：[dest&#43;1,cur-1]待处理区域：[cur,n-1] 有了思路，画图独立完成代码，不要直接看博主的代码。
class Solution { public: void moveZeroes(vector&lt;int&gt;&amp; nums) { for (int dest = -1, cur = 0; cur &lt;= nums.size() - 1; cur&#43;&#43;) { //如果是零就跳过，不是零进入 if (nums[cur]) { swap(nums[&#43;&#43;dest], nums[cur]); } } } }; 复写零 复写零 - 力扣（LeetCode）https://leetcode.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-01-11T15:15:38+08:00">
    <meta property="article:modified_time" content="2024-01-11T15:15:38+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【算法】基础算法001之双指针</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 id="%E2%80%8B%E7%BC%96%E8%BE%91" style="text-align:center;"><a id="_0"></a></h3> 
<p class="img-center"><img alt="" height="154" src="https://images2.imgbox.com/94/ca/XfYySCS1_o.png" width="350"></p> 
<p style="text-align:center;"><strong>👀<span style="color:#98c091;">樊梓慕：</span><strong><strong><strong><a href="https://blog.csdn.net/2301_77112634?type=blog" title="个人主页">个人主页</a></strong></strong></strong></strong></p> 
<p style="text-align:center;"><strong> 🎥<span style="color:#956fe7;">个人专栏：</span><strong><strong><strong><a href="http://t.csdn.cn/e7GFn" rel="nofollow" title="《C语言》">《C语言》</a></strong></strong></strong><strong><strong><strong><a href="http://t.csdn.cn/jUErT" rel="nofollow" title="《数据结构》">《数据结构》</a></strong></strong></strong><strong><strong><strong><a href="http://t.csdn.cn/q3iyZ" rel="nofollow" title="《蓝桥杯试题》">《蓝桥杯试题》</a></strong></strong></strong><strong><strong><strong><a href="http://t.csdn.cn/IUyeH" rel="nofollow" title="《LeetCode刷题笔记》">《LeetCode刷题笔记》</a></strong></strong></strong><strong><strong><strong><a href="http://t.csdn.cn/uK6me" rel="nofollow" title="《实训项目》">《实训项目》</a></strong></strong></strong><strong><strong><strong><a href="http://t.csdnimg.cn/uOlnu" rel="nofollow" title="《C++》">《C++》</a></strong></strong></strong><strong><strong><strong><a href="http://t.csdnimg.cn/cUhZr" rel="nofollow" title="《Linux》">《Linux》</a><a class="link-info" href="http://t.csdnimg.cn/S7d8A" rel="nofollow" title="《算法》">《算法》</a></strong></strong></strong></strong></p> 
<p style="text-align:center;"><strong>🌝<span style="color:#faa572;">每一个不曾起舞的日子，都是对生命的辜负</span></strong></p> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p id="1.%E6%95%B0%E7%BB%84%E5%88%86%E5%9D%97%EF%BC%88%E6%95%B0%E7%BB%84%E5%88%92%E5%88%86%EF%BC%89-toc" style="margin-left:0px;"><a href="#1.%E6%95%B0%E7%BB%84%E5%88%86%E5%9D%97%EF%BC%88%E6%95%B0%E7%BB%84%E5%88%92%E5%88%86%EF%BC%89" rel="nofollow">1.数组分块（数组划分）</a></p> 
<p id="%E7%A7%BB%E5%8A%A8%E9%9B%B6-toc" style="margin-left:40px;"><a href="#%E7%A7%BB%E5%8A%A8%E9%9B%B6" rel="nofollow">移动零</a></p> 
<p id="%E5%A4%8D%E5%86%99%E9%9B%B6-toc" style="margin-left:40px;"><a href="#%E5%A4%8D%E5%86%99%E9%9B%B6" rel="nofollow">复写零</a></p> 
<p id="2.%E5%BF%AB%E6%85%A2%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%88%E5%BE%AA%E7%8E%AF%E5%BE%80%E5%A4%8D%EF%BC%89-toc" style="margin-left:0px;"><a href="#2.%E5%BF%AB%E6%85%A2%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%88%E5%BE%AA%E7%8E%AF%E5%BE%80%E5%A4%8D%EF%BC%89" rel="nofollow">2.快慢双指针（循环往复）</a></p> 
<p id="%E5%BF%AB%E4%B9%90%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E5%BF%AB%E4%B9%90%E6%95%B0" rel="nofollow">快乐数</a></p> 
<p id="3.%E5%AF%B9%E6%92%9E%E6%8C%87%E9%92%88-%3E%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE%E7%9A%84%E4%BC%98%E5%8C%96-%3E%E5%88%A9%E7%94%A8%E5%8D%95%E8%B0%83%E6%80%A7-toc" style="margin-left:0px;"><a href="#3.%E5%AF%B9%E6%92%9E%E6%8C%87%E9%92%88-%3E%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE%E7%9A%84%E4%BC%98%E5%8C%96-%3E%E5%88%A9%E7%94%A8%E5%8D%95%E8%B0%83%E6%80%A7" rel="nofollow">3.对撞指针-&gt;暴力枚举的优化-&gt;利用单调性</a></p> 
<p id="%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8-toc" style="margin-left:40px;"><a href="#%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8" rel="nofollow">盛最多水的容器</a></p> 
<p id="%E6%9C%89%E6%95%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E4%B8%AA%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E6%9C%89%E6%95%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E4%B8%AA%E6%95%B0" rel="nofollow">有效三角形的个数</a></p> 
<p id="4.%E5%AF%B9%E6%92%9E%E6%8C%87%E9%92%88-%3E%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E3%80%81%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E3%80%81%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C-toc" style="margin-left:0px;"><a href="#4.%E5%AF%B9%E6%92%9E%E6%8C%87%E9%92%88-%3E%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E3%80%81%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E3%80%81%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C" rel="nofollow">4.对撞指针-&gt;两数之和、三数之和、四数之和</a></p> 
<p id="%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-toc" style="margin-left:40px;"><a href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C" rel="nofollow">两数之和</a></p> 
<p id="%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C" rel="nofollow">三数之和</a></p> 
<p id="%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C-toc" style="margin-left:40px;"><a href="#%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C" rel="nofollow">四数之和</a></p> 
<hr id="hr-toc"> 
<h2>前言</h2> 
<p><strong>💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐</strong></p> 
<p style="text-align:center;"><strong><span style="color:#ed7976;">《算法》专栏正式挂牌成立</span></strong></p> 
<ul><li>《算法》专栏主要是会系统的梳理一些OJ题的算法思想，将他们按照解题方法的不同划分出来，然后归纳总结，<span style="color:#1c7331;">当然希望大家多多收藏，以后忘了可以常回来看看！</span><strong><span style="color:#ed7976;">                                    </span></strong></li></ul> 
<p style="text-align:center;"><strong>💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐💐</strong></p> 
<p>本篇文章主要会讲解双指针的思想，双指针是一种非常优秀的算法思想，有对撞指针和快慢指针两种基本用法。</p> 
<p>双指针对于<span style="color:#ad720d;"><strong>有序数据</strong></span>的处理是比较有优势的，当你遇到有序的数据时，你可以尝试着利用<strong>双指针</strong>或者<strong>二分</strong>来解题，当然本篇文章只会讲解双指针。</p> 
<p>那么双指针思想具体的应用，以及为什么双指针适用于有序数组的处理呢？</p> 
<hr> 
<p><span style="color:#ed7976;"><strong>欢迎大家📂</strong></span><span style="color:#be191c;"><strong>收藏</strong></span><span style="color:#ed7976;"><strong>📂以便未来做题时可以快速找到思路，巧妙的方法可以事半功倍。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>=========================================================================</strong></span></p> 
<p><span style="color:#9c8ec1;"><strong>GITEE相关代码：</strong></span><span style="color:#0d0016;"><strong>🌟<a class="link-info" href="https://gitee.com/fanfei_c" rel="nofollow" title="fanfei_c的仓库">fanfei_c的仓库</a>🌟</strong></span></p> 
<p><span style="color:#0d0016;"><strong>=========================================================================</strong></span></p> 
<hr> 
<h2 id="1.%E6%95%B0%E7%BB%84%E5%88%86%E5%9D%97%EF%BC%88%E6%95%B0%E7%BB%84%E5%88%92%E5%88%86%EF%BC%89">1.数组分块（数组划分）</h2> 
<p>数组分块顾名思义，该类题目有一个特性就是将数组中的数据进行分类，然后将分类的数据放在不同的区域上。</p> 
<hr> 
<h3 id="%E7%A7%BB%E5%8A%A8%E9%9B%B6">移动零</h3> 
<p><a class="link-info has-card" href="https://leetcode.cn/problems/move-zeroes/description/" rel="nofollow" title="移动零  - 力扣（LeetCode）"><span class="link-card-box"><span class="link-title">移动零 - 力扣（LeetCode）</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/35/12/cdfMFJIR_o.png" alt="icon-default.png?t=N7T8">https://leetcode.cn/problems/move-zeroes/description/</span></span></a></p> 
<blockquote> 
 <p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p> 
 <p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p> 
</blockquote> 
<p class="img-center"><img alt="" height="296" src="https://images2.imgbox.com/17/c6/gLGb327R_o.png" width="595"></p> 
<p> 利用数组分块的思想，我们可以将该数组划分为三个区域：非零的已处理区域、零的已处理区域、待处理区域。</p> 
<p>三个区域恰好可以利用两个指针进行分割得到。</p> 
<p>所以我们定义两个指针：</p> 
<ul><li>cur：从左向右扫描数组（遍历数组的作用），主要用来分割已处理区域和待处理区域用；</li><li>dest：已处理的区域内，非零元素的最后一个位置，主要用来分隔已处理区域内部非零元素和零元素。</li></ul> 
<p>得到三个区间：</p> 
<ul><li>非零的已处理区域：[0,dest]</li><li>零的已处理区域：[dest+1,cur-1]</li><li>待处理区域：[cur,n-1]</li></ul> 
<p> 有了思路，画图独立完成代码，不要直接看博主的代码。</p> 
<pre><code class="language-cpp">class Solution {
public:
    void moveZeroes(vector&lt;int&gt;&amp; nums) {
        for (int dest = -1, cur = 0; cur &lt;= nums.size() - 1; cur++)
        {
            //如果是零就跳过，不是零进入
            if (nums[cur])
            {
                swap(nums[++dest], nums[cur]);
            }
        }
    }
};</code></pre> 
<hr> 
<h3 id="%E5%A4%8D%E5%86%99%E9%9B%B6">复写零</h3> 
<p><a class="link-info has-card" href="https://leetcode.cn/problems/duplicate-zeros/description/" rel="nofollow" title="复写零  - 力扣（LeetCode）"><span class="link-card-box"><span class="link-title">复写零 - 力扣（LeetCode）</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/f5/5c/N1GJLwWZ_o.png" alt="icon-default.png?t=N7T8">https://leetcode.cn/problems/duplicate-zeros/description/</span></span></a></p> 
<blockquote> 
 <p>给你一个长度固定的整数数组 <code>arr</code> ，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。</p> 
 <p>注意：请不要在超过该数组长度的位置写入元素。请对输入的数组 <strong>就地 </strong>进行上述修改，不要从函数返回任何东西。</p> 
</blockquote> 
<p><img alt="" height="340" src="https://images2.imgbox.com/bb/50/RRCkTjjZ_o.png" width="1119"></p> 
<p>我们可以先尝试着进行异地复写，然后尝试着进行原地复写，看看会发生什么问题？</p> 
<p><img alt="" height="423" src="https://images2.imgbox.com/b2/73/zLjf42qB_o.png" width="850"></p> 
<p>如果「从前向后」进行原地复写操作的话，由于0的出现会复写两次，导致没有复写的数「被覆<br> 盖掉」。</p> 
<p><strong>因此我们选择「从后往前」的复写策略。</strong></p> 
<p>但是「从后向前」复写的时候，我们需要找到「最后一个复写的数」，因此我们的大体流程分两<br> 步：</p> 
<ol><li>先找到最后一个复写的数；</li><li>然后从后向前进行复写操作。</li></ol> 
<p> 这两步仍然包含一些细节需要处理，比如会不会出现越界问题等？</p> 
<ul><li>cur：用来遍历数组用。</li><li>dest：根据cur指向的指进行移动一步或两步，如果dest的位置处于最后一位或者已经越界，跳出循环，如果是越界的情况，我们需要手动将其"拉回"，然后进行从后向前的复写操作。</li></ul> 
<p>有了思路，画图独立完成代码，不要直接看博主的代码。</p> 
<pre><code class="language-cpp">class Solution {
public:
    void duplicateZeros(vector&lt;int&gt;&amp; arr) {
        int dest=-1,cur=0,n=arr.size();
        //1.先找到cur位置
        while(cur&lt;n)
        {
            if(arr[cur])
                dest++;
            else
                dest+=2;
            if(dest&gt;=n-1)//这里是为了及时检测是否跳出
                break;
            cur++; 
        }

        //1.5判断dest位置
        if(dest==n)
        {
            arr[dest-1]=0;
            dest-=2;
            cur--;
        }
        //2.然后向前复写
        while(cur&gt;=0)
        {
            if(arr[cur])
                arr[dest--]=arr[cur--]; 
            else{
                arr[dest--]=0;
                arr[dest--]=0;
                cur--;
            }
            
        }
    }
};</code></pre> 
<hr> 
<h2 id="2.%E5%BF%AB%E6%85%A2%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%88%E5%BE%AA%E7%8E%AF%E5%BE%80%E5%A4%8D%EF%BC%89">2.快慢双指针（循环往复）</h2> 
<p>快慢双指针基本思想：使用两个移动速度不同的指针在数组或链表等序列结构上移动。</p> 
<p><span style="color:#ad720d;">一般什么情况下适用快慢双指针的题目呢？</span></p> 
<p>这种方法对于处理环形链表或数组非常有用，或者说循环往复的数据都比较适用快慢双指针算法来进行解决。</p> 
<h3 id="%E5%BF%AB%E4%B9%90%E6%95%B0">快乐数</h3> 
<p><a class="link-info has-card" href="https://leetcode.cn/problems/happy-number/description/" rel="nofollow" title="快乐数  - 力扣（LeetCode）"><span class="link-card-box"><span class="link-title">快乐数 - 力扣（LeetCode）</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/50/d2/I9InWrVG_o.png" alt="icon-default.png?t=N7T8">https://leetcode.cn/problems/happy-number/description/</span></span></a></p> 
<blockquote> 
 <p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p> 
 <p><strong>「快乐数」</strong> 定义为：</p> 
 <ul><li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li><li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li><li>如果这个过程 <strong>结果为</strong> 1，那么这个数就是快乐数。</li></ul> 
 <p>如果 <code>n</code> 是 <em>快乐数</em> 就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p> 
</blockquote> 
<p><img alt="" height="428" src="https://images2.imgbox.com/a8/e6/IdcDWiQT_o.png" width="1188"> 请注意题目意义，只会有两种情况：</p> 
<ul><li>情况1：无限循环但始终变不到1</li><li>情况2：有限次数内，结果为1</li></ul> 
<p>所以对于这种循环往复的数据我们就可以联想到快慢双指针来做：</p> 
<p>为了方便理解，我抽象的将数据做成链：</p> 
<p><img alt="" height="674" src="https://images2.imgbox.com/f6/5c/XOpFmDWA_o.png" width="1002"></p> 
<p>所以必然会成环，slow与fast必然会相遇，我们需要做的就是在他们相遇的时刻，检测以下slow或者fast的值是否为1即可。</p> 
<p>有了思路，画图独立完成代码，不要直接看博主的代码。</p> 
<pre><code class="language-cpp">class Solution {
public:
    int bitSum(int n) {
        int sum = 0;
        while (n) {
            int t = n % 10;
            sum += t * t;
            n /= 10;
        }
        return sum;
    }
    bool isHappy(int n) {
        int slow = n;
        int fast = bitSum(n);
        while (slow != fast) {
            slow = bitSum(slow);
            fast = bitSum(bitSum(fast));
        }
        return slow == 1;
    }
};</code></pre> 
<hr> 
<h2 id="3.%E5%AF%B9%E6%92%9E%E6%8C%87%E9%92%88-%3E%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE%E7%9A%84%E4%BC%98%E5%8C%96-%3E%E5%88%A9%E7%94%A8%E5%8D%95%E8%B0%83%E6%80%A7">3.对撞指针-&gt;暴力枚举的优化-&gt;利用单调性</h2> 
<p>一般用于顺序结构中，也称左右指针。</p> 
<p>对撞指针从两端向中间移动。⼀个指针从最左端开始，另⼀个从最右端开始，然后逐渐往中间逼<br> 近。</p> 
<p>对撞指针的终止条件一般是两个指针相遇或者错开（也可能在循环内部找到结果直接跳出循<br> 环），也就是：</p> 
<ul><li>left == right（两个指针指向同⼀个位置）</li><li>left &gt; right（两个指针错开）</li></ul> 
<hr> 
<p> 单调性解题的思路不好想到，但这是一种非常优秀的对暴力枚举方法的优化思想。</p> 
<h3 id="%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8">盛最多水的容器</h3> 
<p><a class="link-info has-card" href="https://leetcode.cn/problems/container-with-most-water/description/" rel="nofollow" title="盛最多水的容器  - 力扣（LeetCode）"><span class="link-card-box"><span class="link-title">盛最多水的容器 - 力扣（LeetCode）</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/6a/18/HAYKAAO6_o.png" alt="icon-default.png?t=N7T8">https://leetcode.cn/problems/container-with-most-water/description/</span></span></a></p> 
<blockquote> 
 <p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p> 
 <p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p> 
 <p>返回容器可以储存的最大水量。</p> 
 <p><strong>说明：</strong>你不能倾斜容器。</p> 
</blockquote> 
<p><img alt="" height="904" src="https://images2.imgbox.com/f1/ec/mtQ4SvW6_o.png" width="1194"></p> 
<p> 如果说利用暴力枚举的方式来做，很明显你需要固定一边，两层for循环解决，时间复杂度O(N^2)，但这道题目作为一道中等难度的题，利用暴力枚举必然会超时。</p> 
<p>我们尝试利用对撞指针的方式来做：</p> 
<p>w(宽)=right-left;</p> 
<p>容积的计算公式：V=h*w</p> 
<p>当计算完一组结果之后，我们需要将左指针或右指针向中间移动，这样如此反复就能得到最终答案，可是这样并没有降低时间复杂度，仍然是暴力枚举的思路。</p> 
<p>我们观察：</p> 
<p>当左指针或右指针向中间移动时w是必然减小的。</p> 
<p>又根据木桶原理，h取决于左右指针指向的值小的那一个数据。</p> 
<p><img alt="" height="958" src="https://images2.imgbox.com/0a/3a/VBDbD8FM_o.png" width="1200"></p> 
<p>本题是依据数据分析，进而得到单调性的关系，需要大家自行画图分析，然后将思路转化成代码。</p> 
<pre><code class="language-cpp">class Solution {
public:
    int maxArea(vector&lt;int&gt;&amp; height) {
        int left=0;
        int right=height.size()-1;
        int v=0;
        int ret=0;
        while(left&lt;right)
        {
            int v=min(height[left],height[right])*(right-left);
            ret=max(v,ret);
            if(height[left]&lt;height[right]) left++;
            else right--;
        }
        return ret;
    }
};</code></pre> 
<hr> 
<h3 id="%E6%9C%89%E6%95%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E4%B8%AA%E6%95%B0">有效三角形的个数</h3> 
<p><a class="link-info has-card" href="https://leetcode.cn/problems/valid-triangle-number/description/" rel="nofollow" title="有效三角形的个数  - 力扣（LeetCode）"><span class="link-card-box"><span class="link-title">有效三角形的个数 - 力扣（LeetCode）</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/29/3d/fqmz19zC_o.png" alt="icon-default.png?t=N7T8">https://leetcode.cn/problems/valid-triangle-number/description/</span></span></a></p> 
<blockquote> 
 <p> 给定一个包含非负整数的数组 <code>nums</code> ，返回其中可以组成三角形三条边的三元组个数。</p> 
</blockquote> 
<p><img alt="" height="401" src="https://images2.imgbox.com/c9/0b/7HKh2mKq_o.png" width="1132"></p> 
<p>构成三角形的条件：任意两边之和大于第三边</p> 
<p>但这个条件转化成代码需要三次判断未免有些麻烦，所以我们可以将数组先进行排序，排序之后如果较小的两个值之和大于第三边，那么就可以构成三角形了。 </p> 
<p>暴力枚举的方式很显然时间复杂度O(N^3)。</p> 
<p>那我们尝试着对数据进行分析，看看能否利用单调性来优化。</p> 
<p>首先排序，我们将最大的数固定，然后利用对撞指针的思想进行优化。</p> 
<p><img alt="" height="821" src="https://images2.imgbox.com/16/ec/mTYCqCmO_o.png" width="1200"></p> 
<p> 有了思路，画图独立完成代码，不要直接看博主的代码。</p> 
<pre><code class="language-cpp">class Solution {
public:
    int triangleNumber(vector&lt;int&gt;&amp; nums) {
        sort(nums.begin(),nums.end());
        int n=nums.size();
        int maxIndex=n-1;
        int ret=0;
        while(maxIndex&gt;=2)
        {
            int left=0;
            int right=maxIndex-1;
            while(left&lt;right)
            {
                if(nums[left]+nums[right]&gt;nums[maxIndex])
                {  
                    ret+=right-left;
                    right--;
                }
                else
                {
                    left++;
                }
            }
            maxIndex--;
        }
        return ret;
    }
};</code></pre> 
<hr> 
<h2 id="4.%E5%AF%B9%E6%92%9E%E6%8C%87%E9%92%88-%3E%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E3%80%81%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E3%80%81%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C">4.对撞指针-&gt;两数之和、三数之和、四数之和</h2> 
<h3 id="%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C">两数之和</h3> 
<p><a class="link-info has-card" href="https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/description/" rel="nofollow" title="两数之和 - 力扣（LeetCode）"><span class="link-card-box"><span class="link-title">两数之和 - 力扣（LeetCode）</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/ee/47/ObO54gry_o.png" alt="icon-default.png?t=N7T8">https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/description/</span></span></a></p> 
<blockquote> 
 <p>购物车内的商品价格按照升序记录于数组 <code>price</code>。请在购物车中找到两个商品的价格总和刚好是 <code>target</code>。若存在多种情况，返回任一结果即可。</p> 
</blockquote> 
<p><img alt="" height="287" src="https://images2.imgbox.com/a6/5b/scpMgzTz_o.png" width="1144"> 首先我们发现数组是升序排列的，所以我们想到可以利用双指针来解决，同样的我们利用单调性，看看能否对暴力枚举的策略作优化。</p> 
<p>暴力枚举的时间复杂度很明显O(N^2)。</p> 
<p>两数之和大于target时，利用单调性，令right--即可；</p> 
<p>两数之和小于target时，利用单调性，令left++即可；</p> 
<p>两数之和等于target时，我们将此时的结果尾插到结果数组中。</p> 
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; price, int target) {
        int left=0;
        int right=price.size()-1;
        vector&lt;int&gt; ret;
        while(left&lt;right)
        {
            int sum=price[left]+price[right];
            if(sum&lt;target) left++;
            else if(sum&gt;target) right--;
            else{
                ret.push_back(price[left]);
                ret.push_back(price[right]);
                break;
            }
        }
        return ret;
    }
};</code></pre> 
<hr> 
<h3 id="%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C" style="background-color:transparent;"><strong>三数之和</strong></h3> 
<p><strong><a class="link-info has-card" href="https://leetcode.cn/problems/3sum/description/" rel="nofollow" title="三数之和 - 力扣（LeetCode）"><span class="link-card-box"><span class="link-title">三数之和 - 力扣（LeetCode）</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/4e/71/RoYywlGr_o.png" alt="icon-default.png?t=N7T8">https://leetcode.cn/problems/3sum/description/</span></span></a></strong></p> 
<blockquote> 
 <p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p> 
 <p>你返回所有和为 <code>0</code> 且不重复的三元组。</p> 
 <p><strong>注意：</strong>答案中不可以包含重复的三元组。</p> 
</blockquote> 
<p><img alt="" height="658" src="https://images2.imgbox.com/30/74/81HRIIiU_o.png" width="1173"> 本题可以借助两数之和的思想进行解题，无非就是需要多加一层循环，将第三个数固定即可。</p> 
<p>另外的两个数仍然为两数之和的思想，只不过此时两数之和等于负的第三个数。</p> 
<blockquote> 
 <p>难点：注意本题要求去重，并且要求返回所有满足的数据，所以我们需要处理一些细节问题。</p> 
</blockquote> 
<p>首先，关于返回所有：</p> 
<ul><li>当找到一种结果后，不能直接返回，要继续缩小区间继续寻找。</li></ul> 
<p>其次，关于去重：</p> 
<ul><li>找到一种结果之后，left和right要跳过重复元素。</li><li>当使用完一次双指针算法后，即更换第三个数时，也要跳过重复元素。</li><li>注意防止越界。</li></ul> 
<hr> 
<p>  有了思路，画图独立完成代码，不要直接看博主的代码。</p> 
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {
        sort(nums.begin(), nums.end());
        vector&lt;vector&lt;int&gt;&gt; ret;
        int n = nums.size();
        for (int i = 0; i &lt; n;)
        {
            if (nums[i] &gt; 0) break;//小优化
            int left = i + 1, right = n - 1, target = -nums[i];
            while (left &lt; right)
            {
                int sum = nums[left] + nums[right];
                if (sum &lt; target) left++;
                else if (sum &gt; target) right--;
                else
                {
                    ret.push_back({ nums[left++],nums[right--],nums[i] });
                    //去重 left 和 right
                    while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) left++;
                    while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) right--;
                }
            }
            //去重 i
            i++;
            while (i &lt; n &amp;&amp; nums[i] == nums[i - 1]) i++;
        }
        return ret;
    }
};</code></pre> 
<h3></h3> 
<hr> 
<h3 id="%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C">四数之和</h3> 
<p><a class="link-info has-card" href="https://leetcode.cn/problems/4sum/description/" rel="nofollow" title="四数之和 - 力扣（LeetCode）"><span class="link-card-box"><span class="link-title">四数之和 - 力扣（LeetCode）</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/d3/d5/TyVWvtgq_o.png" alt="icon-default.png?t=N7T8">https://leetcode.cn/problems/4sum/description/</span></span></a></p> 
<blockquote> 
 <p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p> 
 <ul><li><code>0 &lt;= a, b, c, d &lt; n</code></li><li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li><li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul> 
 <p>你可以按 <strong>任意顺序</strong> 返回答案 。</p> 
</blockquote> 
<p><img alt="" height="286" src="https://images2.imgbox.com/8e/94/BKgJmpdh_o.png" width="1144"> 四数之和是三数之和的升级，本质上没有任何区别，只不过多加了一个需要固定的数，多加了一层循环而已，如果你已经掌握了三数之和，那么这道题对你来说会非常简单。</p> 
<p> 有了思路，画图独立完成代码，不要直接看博主的代码。</p> 
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) {
        sort(nums.begin(),nums.end());
        vector&lt;vector&lt;int&gt;&gt; ret;
        int n=nums.size();
        for(int i=0;i&lt;n;)
        {
            for(int j=i+1;j&lt;n;)
            {
                int left=j+1,right=n-1; 
                long long num=(long long)target-nums[j]-nums[i];//需要注意的细节
                while(left&lt;right)
                {
                    int sum=nums[left]+nums[right];
                    if(sum&gt;num) right--;
                    else if(sum&lt;num) left++;
                    else
                    {
                        ret.push_back({nums[i],nums[j],nums[left++],nums[right--]});

                        //去重 left 和 right
                        while(left&lt;right &amp;&amp; nums[left]==nums[left-1]) left++;
                        while(left&lt;right &amp;&amp; nums[right]==nums[right+1]) right--;
                    }
                }
                //去重 j
                j++;
                while(j&lt;n &amp;&amp; nums[j]==nums[j-1]) j++;
            }
            //去重i
            i++;
            while(i&lt;n &amp;&amp; nums[i]==nums[i-1]) i++;
        }
        return ret;
    }
};</code></pre> 
<hr> 
<p>以上就是双指针算法在实际题目中的应用，总的来说，双指针算法是比较基础并且简单的算法。</p> 
<p>大家只需要记住：当所给数据为有序时，不妨考虑用双指针算法进行解决。</p> 
<hr> 
<p style="text-align:center;">🐸<span style="color:#98c091;"><strong>简单总结</strong></span>🐸</p> 
<p>双指针擅于处理有序数据，可以解决数组分块、循环往复数据可以利用快慢指针思想（得到某个值可以理解为在某个值处循环）、对撞指针结合单调性可以优化暴力枚举（注意细节：去重和不漏）。</p> 
<hr> 
<p style="text-align:center;"><span style="color:#0d0016;"><strong>=========================================================================</strong></span></p> 
<p style="text-align:center;"><span style="color:#956fe7;"><strong>如果你对该系列文章有兴趣的话，欢迎持续关注博主动态，博主会持续输出优质内容</strong></span></p> 
<p style="text-align:center;"><span style="color:#0d0016;"><strong>🍎博主很需要大家的支持，你的支持是我创作的不竭动力🍎</strong></span></p> 
<p style="text-align:center;"><span style="color:#0d0016;"><strong>🌟</strong></span><span style="color:#79c6cd;"><strong>~ 点赞收藏＋关注 ~</strong></span><span style="color:#0d0016;"><strong>🌟</strong></span></p> 
<p style="text-align:center;"><span style="color:#0d0016;"><strong>=========================================================================</strong></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dfc0960639da5dbb0af7a15befee61c1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何在 Ubuntu 20.04 上安装 Rust</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/46bacd301cfa6ef35496aa88eb04f75d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Stable Diffusion（SD）核心基础知识——（文生图、图生图）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>