<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Halcon区域生长的几种算法regiongrowing/regiongrowing_mean/watersheds - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/d35780cba55efc22c73239d0906cf0d5/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Halcon区域生长的几种算法regiongrowing/regiongrowing_mean/watersheds">
  <meta property="og:description" content="Halcon区域生长的几种算法 文章目录 Halcon区域生长的几种算法1. regiongrowing 算子2. regiongrowing_mean算子3. 分水岭算法 如果想要获得具有相似灰度的相连区域，可以使用区域生长法寻找相邻的符合条件的像素。区域生长法的基本思想是，在图像上选定一个“种子”像素或“种子”区域，然后从“种子”的邻域像素开始拽索，将灰度或者颜色相近的像素附加在“种子”上，最终将代表同一物体的像素全部归属于同一“种子”区域，达到将目标物体分割出来的目的。区域生长法的算法执行速度非常快，适用于对检测速度要求高的情况。 1. regiongrowing 算子 Halcon 中的regiongrowing算子实现了区域生长的功能，它能将灰度相近的相邻像素合并为同一区域。regiongrowing 算子的原型如下：
regiongrowing(Image : Regions : Row, Column, Tolerance, Minsize :) 其中各参数的含义如下。
（1）参数1：Image为输入的单通道图像。
（2）参数2：Regions 为输出的一组区域。
（3）参数3和4：Row、Column分别为矩形区域的宽和高，需要是奇数，以便计算中心点坐标。默认为1,1，也可以选择其他奇数。
（4）参数5：Tolerance 为灰度差值的分割标准。如果另一个点的灰度与种子区域的灰度差值小于Tolerance，则认为它们可以合并为同一区域。这个值默认为6.0。
（5)参数6：MinSize，表示输出区域的最小像素数，默认为100。
其工作步骤如下。
（1)设定一个尺寸为RowColumn的卷积核，以及一个作为分界依据的像素灰度差值Tolerance。
（2）使用上述指定尺寸的卷积核在原图上进行扫描，并计算卷积核内矩形图像的中心点灰度与邻域矩形图像的中心点灰度差。如果差值小于Tolerance，则将这两个矩形区域合并为同一个。
卷积核默认为11，一般长宽都为奇数。如果大于11，需要先对图像进行平滑处理，平滑的卷积核大小至少为RowColum，这是为了使矩形中心更突出。如果图像上的噪点比较多并且卷积核比较小，也可以省略平滑这一步骤，以减少误判。
（3)对合并后的区域进行判断，如果该区域包含的像素数大于设定的MineSize，则输出结果区域。举例如下：
*导入图像 read_image (Image,&#39;data/village&#39;) *对原图进行均值处理，选用5*5的滤波器 mean _image (Image, Mean, 5,5) *使用regiongrowing算子寻找颜色相似的邻域 regiongrowing(Mean,Regions,1,1,3.0,100) *对提取区域进行形态学处理，使区域更加平滑和完整 closing_circle (Regions, RegionClosing, 3.5) 使用regiongrowing算子进行区域分割的效果如图所示。
图（a）为输入的原始图像，图(b)为使用regiongrowing算子进行区域生长后分割出的区域。由图中可以看出，颜色相近的邻域被合并成了同一区域，并以同一种颜色显示。分割的效果与滤波器的方法、尺寸有关，也与regiongrowing算子的参数有关，可根据实际需要进行调节。
2. regiongrowing_mean算子 regiongrowing_mean算子的作用与regiongrowing算子类似，也是使用区域生长法进行分割不同的是，regiongrowingmean 算子的输入需要是灰度均值图像。regiongrowing_mean算子的原型如下：
regiongrowing_mean (Image : Regions : startRow, startColumn,Tolerance,MinSize:) 其中各参数的含义如下。
（1）参数1：Image为输入的单通道图像。
（2）参数2：Regions 为输出的一组区域。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-12-28T22:01:58+08:00">
    <meta property="article:modified_time" content="2023-12-28T22:01:58+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Halcon区域生长的几种算法regiongrowing/regiongrowing_mean/watersheds</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Halcon_0"></a>Halcon区域生长的几种算法</h2> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#Halcon_0" rel="nofollow">Halcon区域生长的几种算法</a></li><li><ul><li><a href="#1__regiongrowing__3" rel="nofollow">1. regiongrowing 算子</a></li><li><a href="#2__regiongrowing_mean_32" rel="nofollow">2. regiongrowing_mean算子</a></li><li><a href="#3___62" rel="nofollow">3. 分水岭算法</a></li></ul> 
 </li></ul> 
</div> 
<br> 如果想要获得具有相似灰度的相连区域，可以使用区域生长法寻找相邻的符合条件的像素。区域生长法的基本思想是，在图像上选定一个“种子”像素或“种子”区域，然后从“种子”的邻域像素开始拽索，将灰度或者颜色相近的像素附加在“种子”上，最终将代表同一物体的像素全部归属于同一“种子”区域，达到将目标物体分割出来的目的。区域生长法的算法执行速度非常快，适用于对检测速度要求高的情况。 
<p></p> 
<h3><a id="1__regiongrowing__3"></a>1. regiongrowing 算子</h3> 
<p>Halcon 中的regiongrowing算子实现了区域生长的功能，它能将灰度相近的相邻像素合并为同一区域。regiongrowing 算子的原型如下：</p> 
<pre><code class="prism language-bash">regiongrowing<span class="token punctuation">(</span>Image <span class="token builtin class-name">:</span> Regions <span class="token builtin class-name">:</span> Row, Column, Tolerance, Minsize <span class="token builtin class-name">:</span><span class="token punctuation">)</span>
</code></pre> 
<p>其中各参数的含义如下。<br> （1）参数1：Image为输入的单通道图像。<br> （2）参数2：Regions 为输出的一组区域。<br> （3）参数3和4：Row、Column分别为矩形区域的宽和高，需要是奇数，以便计算中心点坐标。默认为1,1，也可以选择其他奇数。<br> （4）参数5：Tolerance 为灰度差值的分割标准。如果另一个点的灰度与种子区域的灰度差值小于Tolerance，则认为它们可以合并为同一区域。这个值默认为6.0。<br> （5)参数6：MinSize，表示输出区域的最小像素数，默认为100。<br> 其工作步骤如下。<br> （1)设定一个尺寸为Row<em>Column的卷积核，以及一个作为分界依据的像素灰度差值Tolerance。<br> （2）使用上述指定尺寸的卷积核在原图上进行扫描，并计算卷积核内矩形图像的中心点灰度与邻域矩形图像的中心点灰度差。如果差值小于Tolerance，则将这两个矩形区域合并为同一个。<br> 卷积核默认为1</em>1，一般长宽都为奇数。如果大于1<em>1，需要先对图像进行平滑处理，平滑的卷积核大小至少为Row</em>Colum，这是为了使矩形中心更突出。如果图像上的噪点比较多并且卷积核比较小，也可以省略平滑这一步骤，以减少误判。<br> （3)对合并后的区域进行判断，如果该区域包含的像素数大于设定的MineSize，则输出结果区域。举例如下：</p> 
<pre><code class="prism language-bash">*导入图像
read_image <span class="token punctuation">(</span>Image,<span class="token string">'data/village'</span><span class="token punctuation">)</span>
*对原图进行均值处理，选用5*5的滤波器
mean _image <span class="token punctuation">(</span>Image, Mean, <span class="token number">5,5</span><span class="token punctuation">)</span>
*使用regiongrowing算子寻找颜色相似的邻域
regiongrowing<span class="token punctuation">(</span>Mean,Regions,1,1,3.0,100<span class="token punctuation">)</span>
*对提取区域进行形态学处理，使区域更加平滑和完整
closing_circle <span class="token punctuation">(</span>Regions, RegionClosing, <span class="token number">3.5</span><span class="token punctuation">)</span>
</code></pre> 
<p>使用regiongrowing算子进行区域分割的效果如图所示。<br> <img src="https://images2.imgbox.com/a2/db/LI8FEjZP_o.jpg" alt="在这里插入图片描述"><br> 图（a）为输入的原始图像，图(b)为使用regiongrowing算子进行区域生长后分割出的区域。由图中可以看出，颜色相近的邻域被合并成了同一区域，并以同一种颜色显示。分割的效果与滤波器的方法、尺寸有关，也与regiongrowing算子的参数有关，可根据实际需要进行调节。</p> 
<h3><a id="2__regiongrowing_mean_32"></a>2. regiongrowing_mean算子</h3> 
<p>regiongrowing_mean算子的作用与regiongrowing算子类似，也是使用区域生长法进行分割不同的是，regiongrowingmean 算子的输入需要是灰度均值图像。regiongrowing_mean算子的原型如下：</p> 
<pre><code class="prism language-bash">regiongrowing_mean <span class="token punctuation">(</span>Image <span class="token builtin class-name">:</span> Regions <span class="token builtin class-name">:</span> startRow, startColumn,Tolerance,MinSize:<span class="token punctuation">)</span>
</code></pre> 
<p>其中各参数的含义如下。<br> （1）参数1：Image为输入的单通道图像。<br> （2）参数2：Regions 为输出的一组区域。<br> （3) 参数3和4：startRow、startColumn分别为起始生长点的坐标。<br> （4）参数5：Tolerance 为灰度差值的分割标准。如果另一个点的灰度与种子区域的灰度差值小于Tolerance，则认为它们可以合并为同一区域。这个值默认为5.0。<br> （5）参数6：MinSize 为输出区域的最小像素数，默认为100。<br> 该算子指明了开始进行区域生长算法的点(x，y)的坐标，并以指定的点为中心，不断搜索其邻域，寻找符合设定条件的区域。这里的条件有两种，一是区域边缘的灰度值与当前均值图中对应的灰度值的差小于Tolerance参数的值；二是区域包含的像素数应大于MinSize参数的值。举例如下：</p> 
<pre><code class="prism language-bash">*读取图像
read_image <span class="token punctuation">(</span>Image, <span class="token string">' data/village'</span><span class="token punctuation">)</span>
*对原图进行均值处理，选用circle类型的中值滤波器
median_image <span class="token punctuation">(</span>Image, ImageMedian, <span class="token string">'circle'</span>, <span class="token number">2</span>, <span class="token string">'mirrored'</span><span class="token punctuation">)</span>
*使用regiongrowing算子寻找颜色相似的邻域
regiongrowing <span class="token punctuation">(</span>ImageMedian, Regions, <span class="token number">1</span>, <span class="token number">1</span>, <span class="token number">3</span>, <span class="token number">500</span><span class="token punctuation">)</span>
*对图像进行粗略的区域分割，提取满足条件的各个独立区域
shape_trans <span class="token punctuation">(</span>Regions, Centers, <span class="token string">'inner _center'</span><span class="token punctuation">)</span>
connection <span class="token punctuation">(</span>Centers, Singlecenters<span class="token punctuation">)</span>
*计算出初步提取的区域的中心点坐标
area_center <span class="token punctuation">(</span>Singlecenters, Area, Row, Column<span class="token punctuation">)</span>
*以均值灰度图像为输入，进行区域生长计算，计算的起始坐标为上一步的各区域中心
regiongrowing_mean <span class="token punctuation">(</span>ImageMedian, RegionsMean, Row, Column, <span class="token number">25</span>, <span class="token number">100</span><span class="token punctuation">)</span>
</code></pre> 
<p>这样满足参数条件的相似邻域就合并成了一个区域，提取的效果如图所示。<br> 图（a）为输入的原始图像，图（b）为使用regiongrowing_mean算子进行区域生长后分割出的区域。可以看出，与上图相比，本图分割出的区域单个面积更大，更多的小面积区域被大的邻近区域合并，边界也更加清晰。可以根据实际需要调节所用的参数，以便更理想地分割出目标物体。<br> <img src="https://images2.imgbox.com/22/61/qD0ZxdCF_o.jpg" alt="在这里插入图片描述"></p> 
<h3><a id="3___62"></a>3. 分水岭算法</h3> 
<p>分水岭算法是一种典型的基于边缘的图像分割算法，通过寻找区域之间的分界线，对图像进行分割。“分水岭”这个名字与一种地貌特点有关，它的思想是，把图像的灰度看作一张地形图，其中像素的灰度表示该地点的高度。灰度值低的区域是低地，灰度值越高，地势越高。<br> 低地聚集的地方如同一块盆地，如果模拟向整片区域注水，那么每块盆地将成为一个单独的积水区，即图像上的分割区域，盆地与盆地之间的边界就是区域的边界。随着注水的量越来越多，盆地的积水面积会不断扩大，边界区域则会越来越小，最后形成的分割边界就是分水岭。<br> 分水岭算法能较好地适用于复杂背景下的目标分割，特别是具有蜂窝状结构的画面的内容分<br> 割。Halcon 中使用watersheds算子提取图像的分水岭。如果图像上包含过多的精细区域或者噪点，输出的区域数量将非常庞大，并影响算法的速度。该算子的原型如下：</p> 
<pre><code class="prism language-bash">watersheds <span class="token punctuation">(</span>Image <span class="token builtin class-name">:</span> Basins, Watersheds ：:<span class="token punctuation">)</span>
</code></pre> 
<p>其中各参数的含义如下。<br> (1）参数1：Image 为输入的图像，一般为单通道图像。这里要注意，因为盆地一般指的是灰度值低的区域，所以如果前景目标比较亮而背景比较暗，可以在导入图像后使用invert_image 算子将图像颜色进行反转。<br> （2）参数2：Basins为输出的盆地区域。<br> (3）参数3：Watersheds 为输出的分水岭区域。一般一幅输入图像对应一个分水岭区域，而输出的Basins 区域则是多个区域的集合。<br> 除了watersheds算子外，也可以使用watersheds_threshold算子进行分水岭分割。二者的区别在于，后者比前者多了一步操作，即在得到初步的分水岭分割结果之后，将灰度小于阈值的分水岭合并。具体来说，假设分水岭的最小灰度为Wmin，分水岭两侧的“洼地”区域的最小灰度分别为B1，B2，如果max{（Wmin-B,)，（Wmin-B2,）}的值小于阈值，则将这两个“洼地”区域合并，分水岭消失。通过这样的阈值处理，符合灰度阈值条件的灰度“洼地”区域即被提取出来。该算子的原型如下：</p> 
<pre><code class="prism language-bash">watersheds_threshold<span class="token punctuation">(</span>Image <span class="token builtin class-name">:</span> Basins:Threshold:<span class="token punctuation">)</span>
</code></pre> 
<p>其中各参数的含义如下。<br> （1）参数1：Image为输入的图像，<br> 一般为单通道图像。如果前景目标比较亮而背景比较暗<br> 可以在导入图像后使用invert_image算子将图像颜色进行反转。<br> （2）参数2：Basins 为输出的盆地区域。<br> (3）参数3：Threshold为设置的灰度阈值。建议该值不要超过原图的最大灰度，否则将无法提<br> 取出分水岭，图像整体将作为一个区域被提取出来。<br> 这里以一个实际场景图片为例，介绍图像分水岭算法的算子与应用。案例的图像如图所示,其中：图(a）为输入的原始图像，图(b)为使用Watershcds算子进行分割的结果，图©为提取出的缺陷区域，并以不同的颜色对分割出的区域进行了区分。<br> <img src="https://images2.imgbox.com/85/00/u5fm4RL7_o.jpg" alt="在这里插入图片描述"><br> 使用分水岭算法进行分割的代码如下：</p> 
<pre><code class="prism language-bash">*输入待检测的木材图像
read_image <span class="token punctuation">(</span>Image, <span class="token string">'data/woodboard'</span><span class="token punctuation">)</span>
*将原始图转化为灰度图，便于后续的平滑处理
rgbi_to_gray <span class="token punctuation">(</span>Image, GrayImage<span class="token punctuation">)</span>
*对单通道图像进行高斯平滑处理，以去除噪声
gauss filter <span class="token punctuation">(</span>GrayImage, ImageGauss, <span class="token number">11</span><span class="token punctuation">)</span>
*对高斯平滑后的图像进行分水岭处理与阙值分割，提取出盆地区域
watersheds <span class="token punctuation">(</span>ImageGauss, Basinsl, Watersheds<span class="token punctuation">)</span>
watersheds threshold<span class="token punctuation">(</span>ImageGauss, Basins, <span class="token number">50</span><span class="token punctuation">)</span>
</code></pre> 
<p>经过上述步骤，即可得到图像中的灰度“洼地”区域，结合图像的内容，这部分区域即为木材<br> 缺陷的局部区域。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/540a09923cfcb2ab63a58bc6cb4b5620/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">zookeeper之节点基本操作(二）（头歌）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/04355ad41d32a59bd17bb48ad3a70ca2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">文心一言降重好用吗 PaperGPT</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>