<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MongoDB的安全认证详解 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/24135ca22a6682c1bb2a03f3a2c76ad8/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="MongoDB的安全认证详解">
  <meta property="og:description" content="一、 用户和角色权限介绍 默认情况下，MongoDB实例启动运行时是没有启用用户访问权限控制的，在实例本机服务器上都可以随意连接到实例进行各种操作，MongoDB不会对连接客户端的请求进行用户验证，这是非常危险的。
MongoDB官网上说，为了能保障MongoDB的安全可以做以下几个步骤：
(1）使用新的端口，默认的27017端口如果一旦知道了ip就能连接上，不太安全。
(2）设置MongoDB的网络环境，最好将MongoDB部署到公司服务器内网，这样外网是访问不到的。公司内部访问使用vpn等。
(3）开启安全认证。认证要同时设置服务器之间的内部认证方式，同时要设置客户端连接到集群的账号密码认证方式。
为了强制开启用户访问控制(用户验证)，则需要在MongoDB实例启动时使用选项 --auth 或在指定启动
配置文件中添加选项 --auth=true 。
相关概念：
启用访问控制：
MongoDB使用的是基于角色的访问控制(Role-Based Access
Control,RBAC)来管理用户对实例的访问。通过对用户授予一个或多个角色来控制用户访问数据库资源的权限和数据库操作的权限，在对用户分配角色之前，用户无法访问实例。在实例启动时添加选项
–auth 或指定启动配置文件中添加选项–auth=true
角色：
在MongoDB中通过角色对用户授予相应数据库资源的操作权限，每个角色当中的权限可以显式指定，也可以通过继承其他角色的权限，或者两都都存在的权限。
权限：
权限由指定的数据库资源(resource)以及允许在指定资源上进行的操作(action)组成。
资源(resource)包括：数据库、集合、部分集合和集群。操作(action)包括：对资源进行的增、删、改、查(CRUD)操作。
在角色定义时可以包含一个或多个已存在的角色，新创建的角色会继承包含的角色所有的权限。在同一个数据库中，新创建的角色可以继承其他角色的权限，在 admin
数据库中创建的角色可以继承在其它任意数据库中角色的权限。
关于角色权限的查看，可以通过如下命令查询（了解）：
db.runCommand({ rolesInfo: 1 }) #查询所有角色权限(仅用户自定义角色 db.runCommand({ rolesInfo: &#34;&lt;rolename&gt;&#34; }) #查询当前数据库中的某角色的权限 db.runCommand({ rolesInfo: { role: &#34;&lt;rolename&gt;&#34;, db: &#34;&lt;database&gt;&#34; } } #查询其它数据库中指定的角色权限 #查询多个角色权限： db.runCommand( { rolesInfo: [ &#34;&lt;rolename&gt;&#34;, { role: &#34;&lt;rolename&gt;&#34;, db: &#34;&lt;database&gt;&#34; }, ... ] } ) 查询所有角色权限(包含内置角色)
db.runCommand({ rolesInfo: 1, showBuiltinRoles: true } 1.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-02-29T16:33:28+08:00">
    <meta property="article:modified_time" content="2024-02-29T16:33:28+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MongoDB的安全认证详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="__0"></a>一、 用户和角色权限介绍</h3> 
<p>默认情况下，MongoDB实例启动运行时是没有启用用户访问权限控制的，在实例本机服务器上都可以随意连接到实例进行各种操作，MongoDB不会对连接客户端的请求进行用户验证，这是非常危险的。</p> 
<p>MongoDB官网上说，为了能保障MongoDB的安全可以做以下几个步骤：</p> 
<blockquote> 
 <p>(1）使用新的端口，默认的27017端口如果一旦知道了ip就能连接上，不太安全。<br> (2）设置MongoDB的网络环境，最好将MongoDB部署到公司服务器内网，这样外网是访问不到的。公司内部访问使用vpn等。<br> (3）开启安全认证。认证要同时设置服务器之间的内部认证方式，同时要设置客户端连接到集群的账号密码认证方式。</p> 
</blockquote> 
<p>为了强制开启用户访问控制(用户验证)，则需要在MongoDB实例启动时使用选项 --auth 或在指定启动<br> 配置文件中添加选项 --auth=true 。</p> 
<p>相关概念：</p> 
<ul><li> <p>启用访问控制：<br> MongoDB使用的是基于角色的访问控制(Role-Based Access<br> Control,RBAC)来管理用户对实例的访问。通过对用户授予一个或多个角色来控制用户访问数据库资源的权限和数据库操作的权限，在对用户分配角色之前，用户无法访问实例。在实例启动时添加选项<br> –auth 或指定启动配置文件中添加选项–auth=true</p> </li><li> <p>角色：<br> 在MongoDB中通过角色对用户授予相应数据库资源的操作权限，每个角色当中的权限可以显式指定，也可以通过继承其他角色的权限，或者两都都存在的权限。</p> </li><li> <p>权限：<br> 权限由指定的数据库资源(resource)以及允许在指定资源上进行的操作(action)组成。<br> 资源(resource)包括：数据库、集合、部分集合和集群。操作(action)包括：对资源进行的增、删、改、查(CRUD)操作。</p> </li></ul> 
<p>在角色定义时可以包含一个或多个已存在的角色，新创建的角色会继承包含的角色所有的权限。在同一个数据库中，新创建的角色可以继承其他角色的权限，在 admin<br> 数据库中创建的角色可以继承在其它任意数据库中角色的权限。</p> 
<p><strong>关于角色权限的查看，可以通过如下命令查询（了解）：</strong></p> 
<pre><code>db.runCommand({ rolesInfo: 1 })   #查询所有角色权限(仅用户自定义角色
db.runCommand({ rolesInfo: "&lt;rolename&gt;" })   #查询当前数据库中的某角色的权限
db.runCommand({ rolesInfo: { role: "&lt;rolename&gt;", db: "&lt;database&gt;" } }  #查询其它数据库中指定的角色权限

#查询多个角色权限：
db.runCommand(
{
rolesInfo: [
"&lt;rolename&gt;",
{ role: "&lt;rolename&gt;", db: "&lt;database&gt;" },
...
]
}
)
</code></pre> 
<p>查询所有角色权限(包含内置角色)</p> 
<pre><code>db.runCommand({ rolesInfo: 1, showBuiltinRoles: true }
</code></pre> 
<h4><a id="11BuiltIn_Roles_57"></a>1.1、常用的内置角色（Built-In Roles）</h4> 
<pre><code>数据库用户角色：read、readWrite
所有数据库用户角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase
数据库管理角色：dbAdmin、dbOwner、userAdmin
集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManager
备份恢复角色：backup、restore
超级用户角色：root
内部角色：system
</code></pre> 
<p>常用的内置角色说明：<br> 内置角色是MongoDB预定义的角色，操作的资源是在DB级别上。MongoDB拥有一个SuperUser的角色：root，拥有最大权限，能够在系统的所有资源上执行任意操作。<br> <strong>超级用户角色（Super user role）：</strong></p> 
<pre><code> root：超级账号，超级权限
</code></pre> 
<p><strong>数据库用户角色（Database User Roles）：</strong></p> 
<pre><code>read：授予用户只读数据的权限，可以读取指定数据库中任何数据
readWrite：授予用户读写数据的权限，可以读写指定数据库中任何数据，包括创建、重命名、删除集合
</code></pre> 
<p><strong>数据库管理角色（Database Administration Roles）：</strong></p> 
<pre><code>dbOwner：在当前DB中执行任意操作。
dbAdmin：在当前dB中执行管理操作，可以读取指定数据库以及对数据库进行清理、修改、压缩、获取统计信息、执行 检查等操作。
userAdmin：在当前DB中管理用户，可以在指定数据库创建和修改用户。
</code></pre> 
<p><strong>备份和还原角色（Backup and Restoration Roles）：</strong></p> 
<pre><code>backup：备份MongoDB数据最小的权限。
restore：从备份文件中还原恢复MongoDB数据（除了system.profile集合）的权限
</code></pre> 
<p><strong>所有数据库的用户角色（All-Database Roles）：</strong></p> 
<pre><code>readAnyDatabase：授予在所有数据库上读取数据的权限，可以读取所有数据库中任何数据（除了数据库config和local之外）
readWriteAnyDatabase：授予在所有数据库上读写数据的权限，可以读写所有数据库中任何数据（除了数据库config和local之外）。
userAdminAnyDatabase：授予在所有数据库上管理User的权限，可以在指定数据库创建和修改用户（除了数据库config和local之外）。
dbAdminAnyDatabase：授予管理所有数据库的权限，可以读取任何数据库以及对数据库进行清理、修改、压缩、获取统计信息、执行 检查等操作（除了数据库config和local之外）。
</code></pre> 
<p><strong>集群管理角色（Cluster Administration Roles）：</strong></p> 
<pre><code>clusterAdmin：授予管理集群的最高权限，可以对整个集群或数据库系统进行管理操作。
clusterManager：授予管理和监控集群的权限，具有此角色的用户可以访问分别用于分片和复制的配置数据库和本地数据库。
clusterMonitor：授予监控集群的权限，对监控工具具有readonly的权限
hostManager：管理Server
</code></pre> 
<h4><a id="12UserDefined_Roles_124"></a>1.2、用户自定义角色（User-Defined Roles）</h4> 
<p>内置角色只能控制User在DB级别上执行的操作，管理员可以创建自定义角色，控制用户在集合级别（Collection-<br> Level）上执行的操作，即，控制User在当前DB的特定集合上执行特定的操作。</p> 
<p>在创建角色时，必须明确Role的四个特性：</p> 
<pre><code>Scope：角色作用的范围，创建在Admin中的角色，能够在其他DB中使用；在其他DB中创建的角色，只能在当前DB中使用；
Resource：角色控制的资源，表示授予在该资源上执行特定操作的权限；
Privilege Actions：定义了User能够在资源上执行的操作，系统定义Action是：Privilege Actions；
Inherit：角色能够继承其他角色权限
</code></pre> 
<p><strong>2.1 角色作用的范围（Scope）</strong></p> 
<p>在admin<br> 数据库中创建的角色，Scope是全局的，能够在admin，其他DB和集群中使用，并且能够继承其他DB的Role；而在非admin中创建的角色，Scope是当前数据库，只能在当前DB中使用，只能继承当前数据库的角色。</p> 
<p>在管理数据库中创建的角色可以包括应用于管理数据库、其他数据库或集群资源的权限，并且可以继承其他数据库以及管理数据库中的角色。除了在管理数据库中创建的角色之外，角色只能包括应用于其数据库的权限，并且只能从其数据库中的其他角色继承。</p> 
<p><strong>2.2 权限的操作（Privilege actions）</strong></p> 
<p>MongoDB的权限包由资源（Resource）和操作（Action）两部分组成。<br> Privilege Actions 定义User能够在资源上执行的操作。例如：MongoDB在文档级别（Document-<br> Level）上执行的读写操作（Query and Write Actions）列表是：</p> 
<pre><code>find
insert
remove
update
</code></pre> 
<p><strong>2.3 创建自定义角色</strong><br> 使用db.CreateRole()在当前DB中创建角色，创建的语法示例如下：</p> 
<pre><code>use admin
db.createRole(
   {
    role: "new_role",
    privileges: [
     { resource: { cluster: true }, actions: [ "addShard" ] },
     { resource: { db: "config", collection: "" }, actions: [ "find", "update", "insert", "remove" ] },
     { resource: { db: "users", collection: "usersCollection" }, actions: [ "update", "insert", "remove" ] },
     { resource: { db: "", collection: "" }, actions: [ "find" ] }
    ],
    roles: [
      { role: "read", db: "admin" }
    ]
   },
   { w: "majority" , wtimeout: 5000 }
)
</code></pre> 
<p>在roles数组中，指定被继承的role，即，新建的new_role从roles数组中继承权限：</p> 
<pre><code>如果被继承的role在当前DB中，定义的格式是：roles:["role"]；
如果被继承的role不在当前DB中，需要使用doc，指定该role所在的DB，定义的格式是：roles:[{role:"role_name", db:"db_name"}]；
</code></pre> 
<p><strong>2.4 自定义角色相关管理函数介绍</strong></p> 
<p>db.createRole()：创建角色并指定其权限。<br> db.updateRole()：更新用户定义的角色。<br> db.dropRole()：删除用户定义的角色。<br> db.dropAllRoles()：删除与数据库关联的所有用户定义角色。<br> db.grantPrivilegesToRole()：为用户定义的角色分配权限。<br> db.revokePrivilegesFromRole()：从用户定义的角色中删除指定的权限。<br> db.grantRolesToRole()：指定用户定义角色从中继承权限的角色。<br> db.revokeRolesFromRole()：从角色中删除继承的角色。<br> db.getRole()：返回指定角色的信息。<br> db.getRoles()：返回数据库中所有用户定义角色的信息。</p> 
<h4><a id="13_204"></a>1.3、管理用户和权限</h4> 
<p><strong>3.1 创建用户</strong></p> 
<pre><code>use db_name
db.createUser(
{
    user: "user_name",
    pwd: "user_pwd",
    roles: [   { role: "clusterAdmin", db: "admin" },
               { role: "readAnyDatabase", db: "admin" },
               "readWrite"
           ]
}
)
</code></pre> 
<p>为新建的User，授予一个或多个角色，通过roles数组来实现：</p> 
<pre><code>如果role存在于当前DB中，roles的格式：roles:["role"]；
如果role不存在于当前DB中，roles的格式：roles:[Role:"role_name", db:"db_name"]；
</code></pre> 
<p><strong>3.2 权限认证（Authenticate）</strong><br> mongo连接到mongod，有两种权限认证的方式：</p> 
<ul><li> <p>在连接时认证用户访问的权限，mongo 使用参数 --authenticationDatabase 指定认证数据库；</p> </li><li> <p>在连接后，认证用户访问的权限，mongo 没有使用参数 --authenticationDatabase ，在连接到mongod之后，切换到验证数据库（authentication database）中，使用db.auth() 验证User是否有权限访问当前数据库；</p> <p>use db_name<br> db.auth(“user_name”, “user_pwd” )</p> </li></ul> 
<p>3.3 用户管理相关函数<br> db.auth()：对数据库的用户进行身份验证。<br> db.createUser()：创建新用户。<br> db.updateUser()：更新用户数据。<br> db.changeUserPassword()：更改现有用户的密码。<br> db.dropAllUsers()：删除与数据库关联的所有用户。<br> db.dropUser()：删除单个用户。<br> db.grantRolesToUser()：向用户授予角色及其权限。<br> db.revokeRolesFromUser()：从用户中删除角色。<br> db.getUser()：返回有关指定用户的信息。<br> db.getUsers()：返回与数据库关联的所有用户的信息。</p> 
<h3><a id="2__255"></a>2. 单实例环境</h3> 
<p>下面介绍对单实例（未开启副本集或分片的MongoDB实例）的MongoDB服务开启安全认证</p> 
<h4><a id="21Mongo_259"></a>2.1、关闭Mongo服务</h4> 
<p>增加mongod的单实例的安全认证功能，可以在服务搭建的时候直接添加，也可以在之前搭建好的服务上添加。</p> 
<p><strong>停止服务的方式有两种：快速关闭和标准关闭，下面依次说明：</strong><br> （一）快速关闭方法，通过系统的kill命令直接杀死进程。杀完要检查一下，避免有的没有杀掉。</p> 
<pre><code>#查看mongo进程
ps -aux | grep mongod
#通过进程编号关闭节点
kill -2 5865
</code></pre> 
<p>如果一旦是因为数据损坏，则需要进行如下操作：<br> 1）删除lock文件</p> 
<pre><code>rm -f /mongodb/single/data/db/*.lock
</code></pre> 
<p>(2)修复数据</p> 
<pre><code>mongod --repair --dbpath=/mongodb/single/data/db 
</code></pre> 
<p>（二）标准的关闭方法：<br> 标准的关闭方法,数据不容易出错，但麻烦。通过mongo客户端中的shutdownServer命令来关闭服务，主要的操作步骤参考如下：</p> 
<pre><code>#客户端登录服务，注意，这里通过localhost登录，如果需要远程登录，必须先登录认证才行。
 mongo --port 27017 
 #切换到admin库 
 use admin
 #关闭服务 
 db.shutdownServer()
</code></pre> 
<h4><a id="22_302"></a>2.2、添加用户和权限</h4> 
<p><strong>(1)配置服务端的配置文件 /mongodb/single/mongod.conf：</strong></p> 
<pre><code>systemLog:
  #MongoDB发送所有日志输出的目标指定为文件
  # #The path of the log file to which mongod or mongos should send all diagnostic   logging information
  destination: file
  #mongod或mongos应向其发送所有诊断日志记录信息的日志文件的路径
  path: "/mongodb/single/log/mongod.log"
  #当mongos或mongod实例重新启动时，mongos或mongod会将新条目附加到现有日志文件的末尾。
  logAppend: true
storage:
  #mongod实例存储其数据的目录。storage.dbPath设置仅适用于mongod。
  ##The directory where the mongod instance stores its data.Default Value is "/data/db".
  dbPath: "/mongodb/single/data/db"
  journal:
  #启用或禁用持久性日志以确保数据文件保持有效和可恢复。
    enabled: true
processManagement:
  #启用在后台运行mongos或mongod进程的守护进程模式。
  fork: true
net:
  #服务实例绑定的IP，默认是localhost
  bindIp: localhost,10.0.16.9
  #bindIp
  #绑定的端口，默认是27017
  port: 27017
</code></pre> 
<p><strong>（2）按未开启认证的方式（不添加 --auth 参数）来启动MongoDB服务</strong></p> 
<pre><code>mongod -f /mongodb/single/mongod.conf
</code></pre> 
<p><strong>（3）使用Mongo客户端登录</strong></p> 
<pre><code>mongo --host 110.0.16.9 --port 27017
</code></pre> 
<p><strong>（4）创建两个管理员用户，一个是系统的超级管理员 myroot ，一个是admin库的管理用户myadmin ：</strong></p> 
<ol><li>切换到admin库，创建系统超级用户 myroot,设置密码123456，设置角色root</li></ol> 
<pre><code>use admin
db.createUser({user:"myroot",pwd:"123456",roles:["root"]})
</code></pre> 
<ol start="2"><li>创建专门用来管理admin库的账号myadmin，只用来作为用户权限的管理</li></ol> 
<pre><code>db.createUser({user:"myadmin",pwd:"123456",roles:[{role:"userAdminAnyDatabase",db:"admin"}]})
</code></pre> 
<ol start="3"><li>查看已经创建了的用户的情况:</li></ol> 
<pre><code>db.system.users.find()
</code></pre> 
<ol start="4"><li>删除用户</li></ol> 
<p>db.dropUser(“myadmin”)</p> 
<ol start="5"><li>修改密码</li></ol> 
<pre><code>db.changeUserPassword("myroot", "123456")
</code></pre> 
<p>提示：<br> 1）本案例创建了两个用户，分别对应超管和专门用来管理用户的角色，事实上，你只需要一个用户即可。如果你对安全要求很高，防止超管泄漏，则不要创建超管用户。<br> 2）和其它数据库（MySQL）一样，权限的管理都差不多一样，也是将用户和权限信息保存到数据库对应的表中。Mongodb存储所有的用户信息在admin<br> 数据库的集合system.users中，保存用户名、密码和数据库信息。<br> 3）如果不指定数据库，则创建的指定的权限的用户在所有的数据库上有效，如<code>{role:"userAdminAnyDatabase", db:""}</code></p> 
<p><strong>（5）认证测试</strong></p> 
<pre><code>#切换到admin
&gt; use admin
#密码输错
&gt; db.auth("myroot","12345")
Error: Authentication failed.
0
#密码正确
&gt; db.auth("myroot","123456")
</code></pre> 
<p><strong>（6）创建普通用户</strong><br> 创建普通用户可以在没有开启认证的时候添加，也可以在开启认证之后添加，但开启认证之后，必须使用有操作admin库的用户登录认证后才能操作。底层都是将用户信息保存在了admin数据库的集合system.users中。</p> 
<p>创建(切换)数据库articledb,拥有articledb数据库的读写权限readWrite的用户</p> 
<pre><code>use articledb
db.createUser({user: "bobo", pwd: "123456", roles: [{role:"readWrite", db:"articledb" }]})
</code></pre> 
<p>测试账号是否可用</p> 
<pre><code>db.auth("bobo","123456)
</code></pre> 
<p>注意：开启了认证后，登录的客户端的用户必须使用admin库的角色，如拥有root角色的myadmin用户，再通过myadmin用户去创建其他角色的用户。</p> 
<h4><a id="23_423"></a>2.3、服务端开启认证</h4> 
<p>（1）关闭已经启动的服务</p> 
<pre><code> use admin
 db.shutdownServer()
</code></pre> 
<p>执行该命令db.shutdownServer()的条件：</p> 
<ul><li>必须是在admin库下执行该关闭服务命令。</li><li>如果没有开启认证，必须是从localhost登陆的，才能执行关闭服务命令。</li><li>非localhost的、通过远程登录的，必须有登录且必须登录用户有对admin操作权限才可以。</li></ul> 
<p>（2）以开启认证的方式启动服务</p> 
<p>有两种方式开启权限认证启动服务：一种是参数方式，一种是配置文件方式。<br> <strong>参数方式</strong> ，在启动时指定参数 --auth ，如：</p> 
<pre><code>mongod -f /mongodb/single/mongod.conf --auth
</code></pre> 
<p><strong>配置文件方式</strong><br> 在mongod.conf配置文件添加以下配置：</p> 
<pre><code>security:
  #开启授权认证
  authorization: enabled
</code></pre> 
<p>添加完这个配置之后就可以启动时不用加参数–auth</p> 
<h4><a id="24_461"></a>2.4、客户端连接登录</h4> 
<p>启了认证的情况下的客户端登录，有两种认证方式：一种是先登录，在mongo shell中认证；一种是登录时直接认证。</p> 
<p><strong>先连接再认证</strong></p> 
<p>mongo --host 180.76.159.126 --port 27017</p> 
<p>开启认证后再登录，发现打印的日志比较少了。相关操作需要认证才可以：查询admin库中的system.users集合的用户：</p> 
<pre><code>use admin
db.system.users.find()
</code></pre> 
<p>登录超级管理员账号</p> 
<pre><code>db.auth("myroot","123456")
db.system.users.find()
</code></pre> 
<p>退出后再次登录，查询articledb库中的comment集合的内容</p> 
<pre><code>use articledb
db.comment.find()
db.auth("bobo","123")
db.comment.find()
</code></pre> 
<p><strong>连接时直接认证</strong><br> 对admin数据库进行登录认证和相关操作：</p> 
<pre><code>mongo --host 180.76.159.126 --port 27017 --authenticationDatabase  admin -u myroot -p 123456
</code></pre> 
<p>参数说明：</p> 
<ul><li>-u ：用户名</li><li>-p ：密码</li><li>-authenticationDatabase ：指定连接到哪个库。当登录是指定用户名密码时，必须指定对应的数据库！</li></ul> 
<p>对articledb数据库进行登录认证和相关操作：</p> 
<pre><code>mongo --host 180.76.159.126 --port
27017 --authenticationDatabase articledb -u bobo -p 12345
</code></pre> 
<h4><a id="25Spring_Data_Mongo_517"></a>2.5、Spring Data Mongo连接认证</h4> 
<p>使用用户名和密码连接到 MongoDB 服务器，你必须使用<br> ‘username:password@hostname/dbname’ 格式，'username’为用户名，‘password’ 为密码。</p> 
<p>配置示例：</p> 
<pre><code>spring:
  #数据源配置
  data:
    mongodb:
      #主机地址
      #host: 180.76.159.126
      # 数据库
      #database: articledb
      # 默认端口是27017
      #port: 27017
      #帐号
      #username: bobo
      #密码
      #password: 123456
      #单机有认证的情况下，也使用字符串连接
      uri: mongodb://bobo:123456@180.76.159.126:27017/articled
</code></pre> 
<h3><a id="3__544"></a>3. 副本集环境</h3> 
<p>对于搭建好的mongodb副本集，为了安全，启动安全认证，使用账号密码登录。配置副本集架构如下：<br> ![在这里插入图片描述](https://img-<br> blog.csdnimg.cn/ee2ee00d03a34a07b6d083afb4b4ca55.png#pic_center)<br> 对副本集执行访问控制需要配置两个方面：</p> 
<blockquote> 
 <p>1）副本集和共享集群的各个节点成员之间使用内部身份验证，可以使用密钥文件或x.509证书。密钥文件比较简单，本文使用密钥文件，官方推荐如果是测试环境可以使用密钥文件，但是正式环境，官方推荐x.509证书。原理就是，集群中每一个实例彼此连接的时候都检验彼此使用的证书的内容是否相同。只有证书相同的实例彼此才可以访问。<br> 2）使用客户端连接到mongodb集群时，开启访问授权。对于集群外部的访问。如通过可视化客户端， 或者通过代码连接的时候，需要开启授权。</p> 
</blockquote> 
<p>在keyfile身份验证中，副本集中的每个mongod实例都使用keyfile的内容作为共享密码，只有具有正确密钥文件的mongod或者mongos实例可以连接到副本集。密钥文件的内容必须在6到1024个字符之间，并且在unix/linux系统中文件所有者必须有对文件至少有读的权限。</p> 
<h4><a id="31__557"></a>3.1 关闭已开启的副本集服务</h4> 
<p>增加副本集的安全认证和服务鉴权功能，可以在副本集搭建的时候直接添加，也可以在之前搭建好的副本集服务上添加。</p> 
<p><strong>（1）快速关闭方法</strong><br> 通过系统的kill命令直接杀死进程。</p> 
<pre><code>#通过进程编号关闭节点
kill -2 54410
</code></pre> 
<p>依次杀死仲裁者、副本节点、主节点，直到所有成员都离线。建议主节点最后kill，以避免潜在的回滚。杀完要检查一下，避免有的没有杀掉</p> 
<p><strong>2）标准的关闭方法（数据不容易出错，但麻烦）：</strong><br> 通过mongo客户端中的shutdownServer命令来依次关闭各个服务，操作命令如下。</p> 
<pre><code>//客户端登录服务，注意，这里通过localhost登录，如果需要远程登录，必须先登录认证才行。
mongo --port 27017
//告知副本集说本机要下线
rs.stepDown()
//#切换到admin库
use admin
//关闭服务
db.shutdownServer()
</code></pre> 
<p>关闭副本集中的服务，建议依次关闭仲裁节点、副本节点、主节点。</p> 
<h4><a id="32__589"></a>3.2 通过主节点添加一个管理员帐号</h4> 
<p>只需要在主节点上添加用户，副本集会自动同步。开启认证之前，创建超管用户：myroot，密码：123456。</p> 
<pre><code>use admin
db.createUser({user:"myroot",pwd:"123456",roles:["root"]})
</code></pre> 
<p>详细操作详见单实例环境的 添加用户和权限 的相关操作。<br> 提示：该步骤也可以在开启认证之后，但需要通过localhost登录才允许添加用户，用户数据也会自动同步到副本集。后续再创建其他用户，都可以使用该超管用户创建.</p> 
<h4><a id="33_key_602"></a>3.3 创建副本集认证的key文件</h4> 
<p>可以使用任何方法生成密钥文件。例如，以下操作使用openssl生成密码文件，然后使用chmod来更改<br> 文件权限，仅为文件所有者提供读取权限</p> 
<pre><code>openssl rand -base64 90 -out ./mongo.keyfile
chmod 400 ./mongo.keyfile
ll mongo.keyfile
</code></pre> 
<p>提示：<br> 所有副本集节点都必须要用同一份keyfile，一般是在一台机器上生成，然后拷贝到其他机器上，且必须<br> 有读的权限，否则将来会报错： permissions on /mongodb/replica_sets/myrs_27017/mongo.keyfile<br> are too open</p> 
<p>一定要保证密钥文件一致，文件位置随便。但是为了方便查找，建议每台机器都放到一个固定的位置，<br> 都放到和配置文件一起的目录中。</p> 
<p>这里将该文件分别拷贝到多个目录中：</p> 
<pre><code>cp mongo.keyfile /mongodb/replica_sets/myrs_27017
cp mongo.keyfile /mongodb/replica_sets/myrs_27018
cp mongo.keyfile /mongodb/replica_sets/myrs_27019
</code></pre> 
<h4><a id="34_keyfile_631"></a>3.4 修改配置文件指定keyfile</h4> 
<p>分别编辑几个服务的mongod.conf文件，添加相关内容：</p> 
<p>mongodb/replica_sets/myrs_27017/mongod.conf的配置文件:</p> 
<pre><code>security:
  #KeyFile鉴权文件
  keyFile: /mongodb/replica_sets/myrs_27017/mongo.keyfile
  #开启认证方式运行
  authorization: enabled
</code></pre> 
<p>/mongodb/replica_sets/myrs_27018/mongod.conf</p> 
<pre><code>security:
  #KeyFile鉴权文件
  keyFile: /mongodb/replica_sets/myrs_27018/mongo.keyfile
  #开启认证方式运行
  authorization: enabled
</code></pre> 
<p>/mongodb/replica_sets/myrs_27019/mongod.conf</p> 
<pre><code>security:
  #KeyFile鉴权文件
  keyFile: /mongodb/replica_sets/myrs_27019/mongo.keyfile
  #开启认证方式运行
  authorization: enabled
</code></pre> 
<h4><a id="35__668"></a>3.5 重新启动副本集</h4> 
<p>如果副本集是开启状态，则先分别关闭关闭复本集中的每个mongod，从次节点开始。直到副本集的所<br> 有成员都离线，包括任何仲裁者。主节点必须是最后一个成员关闭以避免潜在的回滚。</p> 
<pre><code>#通过进程编号关闭三个节点
kill -2 54410 54361 54257
</code></pre> 
<p>分别启动副本集节点：</p> 
<pre><code>mongod -f /mongodb/replica_sets/myrs_27017/mongod.conf
mongod -f /mongodb/replica_sets/myrs_27018/mongod.conf
mongod -f /mongodb/replica_sets/myrs_27019/mongod.conf
</code></pre> 
<p>查看进程情况,查看三个副本集节点是否启动成功</p> 
<pre><code>ps -ef |grep mongod
</code></pre> 
<h4><a id="36__695"></a>3.6 在主节点上添加普通账号</h4> 
<p>先用管理员账号登录，切换到admin库</p> 
<pre><code>use admin
</code></pre> 
<p>管理员账号认证</p> 
<pre><code>db.auth("myroot","123456")
</code></pre> 
<p>切换到要认证的库</p> 
<pre><code>use articledb
</code></pre> 
<p>添加普通用户</p> 
<pre><code>db.createUser({user: "bobo", pwd: "123456", roles: ["readWrite"]})
</code></pre> 
<p>重新连接，使用普通用户bobo重新登录，查看数据。</p> 
<h4><a id="37_Spring_Data_Mongo_727"></a>3.7 Spring Data Mongo连接认证</h4> 
<p>使用用户名和密码连接到 MongoDB 服务器，你必须使用’username:password@hostname/dbname’<br> 格式，'username’为用户名，‘password’ 为密码。</p> 
<p>示例：</p> 
<pre><code>spring:
#数据源配置
data:
mongodb:
#副本集有认证的情况下，字符串连接
uri:
mongodb://bobo:123456@180.76.159.126:27017,180.76.159.126:27018,180.76.159.126:27019/articledb?connect=replicaSet&amp;slaveOk=true&amp;replicaSet=myrs
</code></pre> 
<h3><a id="4__745"></a>4. 分片集群环境</h3> 
<h4><a id="41__747"></a>4.1 关闭已开启的副本集服务</h4> 
<p>片集群的服务器环境和架构较为复杂，建议在搭建分片集群的时候，直接加入安全认证和服务器间的鉴权，如果之前有数据，可先将之前的数据备份出来，再还原回去。</p> 
<p>停止服务的方式有两种：快速关闭和标准关闭。<br> <strong>（1）快速关闭</strong><br> 通过系统的kill命令直接杀死进程快速关闭Mongo服务的方法快速，简单，数据可能会出错。依次杀死mongos路由节点、配置副本集服务，分片副本集服务，从次节点开始。直到所有成员都离线。副本集杀的时候，建议先杀仲裁者，再杀副本节点，最后是主节点，以避免潜在的回滚。杀完要检查一下，避免有的没有杀掉。命令如下：</p> 
<pre><code>ps aux|grep mongo
#通过进程编号关闭节点
kill -2 54410
</code></pre> 
<p><strong>（2）标准关闭的方法</strong><br> 通过mongo客户端中的shutdownServer命令来依次关闭各个服务。</p> 
<p>关闭分片服务器副本集中的服务，建议依次关闭仲裁节点、副本节点、主节点。主要的操作步骤参考如下：</p> 
<pre><code>#客户端登录服务，注意，这里通过localhost登录，如果需要远程登录，必须先登录认证才行。
mongo --port 27018
#告知副本集说本机要下线
rs.stepDown()
#切换到admin库
use admin
#关闭服务
db.shutdownServer()
</code></pre> 
<p>关闭配置服务器副本集的服务，建议依次关闭副本节点、主节点。主要的操作步骤参考如下：</p> 
<pre><code>#客户端登录服务，注意，这里通过localhost登录，如果需要远程登录，必须先登录认证才行。
mongo --port 27019
#告知副本集说本机要下线
rs.stepDown()
#切换到admin库
use admin
#关闭服务
db.shutdownServer()
</code></pre> 
<p>关闭路由服务器的服务，建议依次关闭两个路由节点。主要的操作步骤参考如下:</p> 
<pre><code>#客户端登录服务，注意，这里通过localhost登录，如果需要远程登录，必须先登录认证才行。
mongo --port 27017
#告知副本集说本机要下线
rs.stepDown()
#切换到admin库
use admin
#关闭服务
db.shutdownServer()
</code></pre> 
<h4><a id="42_key_807"></a>4.2 创建副本集认证的key文件</h4> 
<p>(1)第一步：生成一个key文件到当前文件夹中。</p> 
<p>可以使用任何方法生成密钥文件。例如，以下操作使用openssl生成密码文件，然后使用chmod来更改<br> 文件权限，仅为文件所有者提供读取权限</p> 
<pre><code>openssl rand -base64 90 -out ./mongo.keyfile
chmod 400 ./mongo.keyfile
ll mongo.keyfil
</code></pre> 
<p>提示：<br> 所有副本集节点都必须要用同一份keyfile，一般是在一台机器上生成，然后拷贝到其他机器上，且必须<br> 有读的权限，否则将来会报错： permissions on /mongodb/replica_sets/myrs_27017/mongo.keyfile<br> are too open</p> 
<p>一定要保证密钥文件一致，文件位置随便。但是为了方便查找，建议每台机器都放到一个固定的位置，都放到和配置文件一起的目录中。</p> 
<pre><code>这里将该文件分别拷贝到多个目录中：

echo '/mongodb/sharded_cluster/myshardrs01_27018/mongo.keyfile
/mongodb/sharded_cluster/myshardrs01_27118/mongo.keyfile
/mongodb/sharded_cluster/myshardrs01_27218/mongo.keyfile
/mongodb/sharded_cluster/myshardrs02_27318/mongo.keyfile
/mongodb/sharded_cluster/myshardrs02_27418/mongo.keyfile
/mongodb/sharded_cluster/myshardrs02_27518/mongo.keyfile
/mongodb/sharded_cluster/myconfigrs_27019/mongo.keyfile
/mongodb/sharded_cluster/myconfigrs_27119/mongo.keyfile
/mongodb/sharded_cluster/myconfigrs_27219/mongo.keyfile
/mongodb/sharded_cluster/mymongos_27017/mongo.keyfile
/mongodb/sharded_cluster/mymongos_27117/mongo.keyfile' | xargs -n 1 cp -v
/root/mongo.keyfile
</code></pre> 
<h4><a id="43_keyfile_846"></a>4.3 修改配置文件指定keyfile</h4> 
<p>分别编辑几个服务的mongod.conf文件，添加相关内容：</p> 
<p>/mongodb/sharded_cluster/myshardrs01_27018/mongod.conf</p> 
<pre><code>security:
  #KeyFile鉴权文件
  keyFile: /mongodb/sharded_cluster/myshardrs01_27018/mongo.keyfile
  #开启认证方式运行
  authorization: enabled
</code></pre> 
<p>/mongodb/sharded_cluster/myshardrs01_27118/mongod.conf</p> 
<pre><code>security:
  #KeyFile鉴权文件
  keyFile: /mongodb/sharded_cluster/myshardrs01_27118/mongo.keyfile
  #开启认证方式运行
  authorization: enabled
</code></pre> 
<p>/mongodb/sharded_cluster/myshardrs01_27218/mongod.conf</p> 
<pre><code>security:
  #KeyFile鉴权文件
  keyFile: /mongodb/sharded_cluster/myshardrs01_27218/mongo.keyfile
  #开启认证方式运行
  authorization: enabled
</code></pre> 
<p>/mongodb/sharded_cluster/myshardrs02_27318/mongod.conf</p> 
<pre><code>security:
  #KeyFile鉴权文件
  keyFile: /mongodb/sharded_cluster/myshardrs02_27318/mongo.keyfile
  #开启认证方式运行
  authorization: enabled
</code></pre> 
<p>/mongodb/sharded_cluster/myshardrs02_27418/mongod.conf</p> 
<pre><code>security:
  #KeyFile鉴权文件
  keyFile: /mongodb/sharded_cluster/myshardrs02_27418/mongo.keyfile
  #开启认证方式运行
  authorization: enabled
</code></pre> 
<p>/mongodb/sharded_cluster/myshardrs02_27518/mongod.conf</p> 
<pre><code>security:
  #KeyFile鉴权文件
  keyFile: /mongodb/sharded_cluster/myshardrs02_27518/mongo.keyfile
  #开启认证方式运行
  authorization: enabled
</code></pre> 
<p>/mongodb/sharded_cluster/myconfigrs_27019/mongod.conf</p> 
<pre><code>security:
  #KeyFile鉴权文件
  keyFile: /mongodb/sharded_cluster/myconfigrs_27019/mon/mongo.keyfile
  #开启认证方式运行
  authorization: enabled
</code></pre> 
<p>/mongodb/sharded_cluster/myconfigrs_27119/mongod.conf</p> 
<pre><code>security:
  #KeyFile鉴权文件
  keyFile: /mongodb/sharded_cluster/myconfigrs_27119/mon/mongo.keyfile
  #开启认证方式运行
  authorization: enabled
</code></pre> 
<p>/mongodb/sharded_cluster/myconfigrs_27219/mongod.conf</p> 
<pre><code>security:
  #KeyFile鉴权文件
  keyFile: /mongodb/sharded_cluster/myconfigrs_27219/mon/mongo.keyfile
  #开启认证方式运行
  authorization: enabled
</code></pre> 
<p>/mongodb/sharded_cluster/mymongos_27017/mongos.conf</p> 
<pre><code>security:
  #KeyFile鉴权文件
  keyFile: /mongodb/sharded_cluster/mymongos_27017/mon/mongo.keyfile
</code></pre> 
<p>/mongodb/sharded_cluster/mymongos_27117/mongos.conf</p> 
<pre><code>security:
  #KeyFile鉴权文件
  keyFile: /mongodb/sharded_cluster/mymongos_27117/mon/mongo.keyfile
</code></pre> 
<p>mongos比mongod少了authorization：enabled的配置。原因是，副本集加分片的安全认证需要配置两方面的，副本集各个节点之间使用内部身份验证，用于内部各个mongo实例的通信，只有相同keyfile才能相互访问。所以都要开启<br> keyFile:/mongodb/sharded_cluster/mymongos_27117/mongo.keyfile 。</p> 
<p>然而对于所有的mongod，才是真正的保存数据的分片。mongos只做路由，不保存数据。所以所有的mongod开启访问数据的授权authorization:enabled。这样用户只有账号密码正确才能访问到数据。</p> 
<h4><a id="44__972"></a>4.4 重新启动节点</h4> 
<p>必须依次启动配置节点、分片节点、路由节点：</p> 
<pre><code>#启动配置节点
/usr/local/mongodb/bin/mongod -f /mongodb/sharded_cluster/myconfigrs_27019/mongod.conf
/usr/local/mongodb/bin/mongod -f /mongodb/sharded_cluster/myconfigrs_27119/mongod.conf
/usr/local/mongodb/bin/mongod -f /mongodb/sharded_cluster/myconfigrs_27219/mongod.conf
#启动分片节点
/usr/local/mongodb/bin/mongod -f /mongodb/sharded_cluster/myshardrs01_27018/mongod.conf
/usr/local/mongodb/bin/mongod -f /mongodb/sharded_cluster/myshardrs01_27118/mongod.conf
/usr/local/mongodb/bin/mongod -f /mongodb/sharded_cluster/myshardrs01_27218/mongod.conf
/usr/local/mongodb/bin/mongod -f /mongodb/sharded_cluster/myshardrs02_27318/mongod.conf
/usr/local/mongodb/bin/mongod -f /mongodb/sharded_cluster/myshardrs02_27418/mongod.conf
/usr/local/mongodb/bin/mongod -f /mongodb/sharded_cluster/myshardrs02_27518/mongod.conf
#启动路由节点
/usr/local/mongodb/bin/mongod -f /mongodb/sharded_cluster/mymongos_27017/mongos.conf
/usr/local/mongodb/bin/mongod -f /mongodb/sharded_cluster/mymongos_27117/mongos.conf
</code></pre> 
<p>注意：这里有个非常特别的情况，就是启动顺序。先启动配置节点，再启动分片节点，最后启动路由节点。</p> 
<h4><a id="45__996"></a>4.5 创建帐号和认证</h4> 
<p>客户端mongo，通过localhost登录任意一个mongos路由</p> 
<pre><code>/usr/local/mongodb/bin/mongo --port 27017
</code></pre> 
<p>只能在admin下添加用户。创建一个管理员帐号：</p> 
<pre><code>use admin
db.createUser({user:"myroot",pwd:"123456",roles:["root"]})
</code></pre> 
<p>创建一个普通权限帐号：</p> 
<pre><code> use admin
 db.auth("myroot","123456")
 use articledb
 db.createUser({user: "bobo", pwd: "123456", roles: [{ role: "readWrite",db:"articledb"}]}
db.auth("bobo","123456")
</code></pre> 
<p>通过mongos添加的账号信息，只会保存到配置节点的服务中，具体的数据节点不保存账号信息，因<br> 此，分片中的账号信息不涉及到同步问题</p> 
<p>mongo客户端登录mongos路由，用管理员帐号登录可查看分片情况：</p> 
<pre><code>use admin
db.auth("myroot","123456")
 sh.status()
</code></pre> 
<p>退出连接，重新连接服务，使用普通权限帐号访问数据：</p> 
<pre><code>mongo --host 180.76.159.126 --port 27017
db.auth("bobo","123456")
show collections
db.comment.count()
</code></pre> 
<h4><a id="46_Spring_Data_Mongo_1046"></a>4.6 Spring Data Mongo连接认证</h4> 
<p>使用用户名和密码连接到 MongoDB 服务器，你必须使用’username:password@hostname/dbname’<br> 格式，'username’为用户名，‘password’ 为密码。</p> 
<p>目标：使用用户bobo使用密码 123456 连接到MongoDB 服务上。application.yml示例：</p> 
<pre><code>spring:
  #数据源配置
  data:
    mongodb:
    # 分片集群有认证的情况下，字符串连接
     uri:
    mongodb://bobo:123456@180.76.159.126:27017,180.76.159.126:27117/articledb
</code></pre> 
<p>接下来我将给各位同学划分一张学习计划表！</p> 
<h2><a id="_1066"></a>学习计划</h2> 
<p>那么问题又来了，作为萌新小白，我应该先学什么，再学什么？<br> 既然你都问的这么直白了，我就告诉你，零基础应该从什么开始学起：</p> 
<h3><a id="_1071"></a>阶段一：初级网络安全工程师</h3> 
<p>接下来我将给大家安排一个为期1个月的网络安全初级计划，当你学完后，你基本可以从事一份网络安全相关的工作，比如渗透测试、Web渗透、安全服务、安全分析等岗位；其中，如果你等保模块学的好，还可以从事等保工程师。</p> 
<p><font color="red"><strong>综合薪资区间6k~15k</strong></font></p> 
<p>1、网络安全理论知识（2天）<br> ①了解行业相关背景，前景，确定发展方向。<br> ②学习网络安全相关法律法规。<br> ③网络安全运营的概念。<br> ④等保简介、等保规定、流程和规范。（非常重要）</p> 
<p>2、渗透测试基础（1周）<br> ①渗透测试的流程、分类、标准<br> ②信息收集技术：主动/被动信息搜集、Nmap工具、Google Hacking<br> ③漏洞扫描、漏洞利用、原理，利用方法、工具（MSF）、绕过IDS和反病毒侦察<br> ④主机攻防演练：MS17-010、MS08-067、MS10-046、MS12-20等</p> 
<p>3、操作系统基础（1周）<br> ①Windows系统常见功能和命令<br> ②Kali Linux系统常见功能和命令<br> ③操作系统安全（系统入侵排查/系统加固基础）</p> 
<p>4、计算机网络基础（1周）<br> ①计算机网络基础、协议和架构<br> ②网络通信原理、OSI模型、数据转发流程<br> ③常见协议解析（HTTP、TCP/IP、ARP等）<br> ④网络攻击技术与网络安全防御技术<br> ⑤Web漏洞原理与防御：主动/被动攻击、DDOS攻击、CVE漏洞复现</p> 
<p>5、数据库基础操作（2天）<br> ①数据库基础<br> ②SQL语言基础<br> ③数据库安全加固</p> 
<p>6、Web渗透（1周）<br> ①HTML、CSS和JavaScript简介<br> ②OWASP Top10<br> ③Web漏洞扫描工具<br> ④Web渗透工具：Nmap、BurpSuite、SQLMap、其他（菜刀、漏扫等）<br> <img src="https://images2.imgbox.com/6e/6c/tvQJTXYr_o.png" alt=""><br> <strong>那么，到此为止，已经耗时1个月左右。你已经成功成为了一名“脚本小子”。那么你还想接着往下探索吗？</strong></p> 
<h3><a id="or_1114"></a>阶段二：中级or高级网络安全工程师（看自己能力）</h3> 
<p><font color="red"><strong>综合薪资区间15k~30k</strong></font></p> 
<p>7、脚本编程学习（4周）<br> 在网络安全领域。是否具备编程能力是“脚本小子”和真正网络安全工程师的本质区别。在实际的渗透测试过程中，面对复杂多变的网络环境，当常用工具不能满足实际需求的时候，往往需要对现有工具进行扩展，或者编写符合我们要求的工具、自动化脚本，这个时候就需要具备一定的编程能力。在分秒必争的CTF竞赛中，想要高效地使用自制的脚本工具来实现各种目的，更是需要拥有编程能力。</p> 
<p>零基础入门的同学，我建议选择脚本语言Python/PHP/Go/Java中的一种，对常用库进行编程学习<br> 搭建开发环境和选择IDE，PHP环境推荐Wamp和XAMPP，IDE强烈推荐Sublime；</p> 
<p>Python编程学习，学习内容包含：语法、正则、文件、 网络、多线程等常用库，推荐《Python核心编程》，没必要看完</p> 
<p>用Python编写漏洞的exp,然后写一个简单的网络爬虫</p> 
<p>PHP基本语法学习并书写一个简单的博客系统</p> 
<p>熟悉MVC架构，并试着学习一个PHP框架或者Python框架 (可选)</p> 
<p>了解Bootstrap的布局或者CSS。</p> 
<h3><a id="_1134"></a>阶段三：顶级网络安全工程师</h3> 
<p>如果你对网络安全入门感兴趣，那么你需要的话可以点击这里<strong>👉</strong><a href="https://mp.weixin.qq.com/s/BWb9OzaB-gVGVpkm161PMw" rel="nofollow">网络安全重磅福利：入门&amp;进阶全套282G学习资源包免费分享！</a></p> 
<p><img src="https://images2.imgbox.com/6c/11/830m5pvT_o.png" alt=""></p> 
<h2><a id="_1140"></a>学习资料分享</h2> 
<p>当然，<strong>只给予计划不给予学习资料的行为无异于耍流氓</strong>，这里给大家整理了一份【282G】的网络安全工程师从入门到精通的学习资料包，可点击下方二维码链接领取哦。</p> 
<img src="https://images2.imgbox.com/cb/d5/odmUFp5T_o.jpg">
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/94b84907744234c48654409bf02c36b3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">AI、AIGC、AGI、ChatGPT它们的区别？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ff4d4ba7421e26269cca7e3515bb1147/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java参数校验详解：使用@Valid注解和自定义注解进行参数验证</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>