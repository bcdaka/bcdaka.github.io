<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Go语言精进之路】构建高效Go程序：了解map实现原理并高效使用 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/e09f855ded4efdd837c7de9c925bfade/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【Go语言精进之路】构建高效Go程序：了解map实现原理并高效使用">
  <meta property="og:description" content="🔥 个人主页：空白诗 🔥 热门专栏：【Go语言精进之路】 文章目录 引言一、什么是`map`1.1 `map`的基本概念与特性1.2 map的初始化与零值问题1.3 `map`作为引用类型的行为 二、`map`的基本操作2.1 插入数据2.2 获取数据个数2.3 查找和数据读取2.4 删除数据2.5 遍历数据 三、map的内部实现3.1 初始状态3.2 `map`扩容3.3 `map`并发 四、尽量使用cap参数创建map五、总结 引言 在Go语言中，map 是一种无序的键值对集合，它以其高效的查找、插入和删除操作而闻名。了解 map 的基本概念、特性和内部实现机制，对于编写高效且稳定的Go代码至关重要。本文将深入探讨 map 的各个方面，包括其初始化、基本操作、内部实现细节，并讨论为何在创建 map 时应尽量使用带有容量提示参数的做法。
一、什么是map 1.1 map的基本概念与特性 map是Go语言中的一种内建引用类型，它表示一组无序的键值对集合。每个键值对用冒号“:”分隔，其中键（key）是唯一的，用于标识对应的值（value）。map允许我们根据特定的键快速检索、更新或删除对应的值。
在Go语言中，map对值（value）的数据类型没有特定限制，它可以是任意类型，包括基本类型、结构体、自定义类型等。但是，键（key）的类型有严格要求：key的类型必须可以通过“==”和“!=”操作符进行比较，这意味着键的类型需要是可比较的。因此，像函数、map和切片这样不可比较的类型不能作为map的键。
1.2 map的初始化与零值问题 需要注意的是，map类型不支持“零值可用”，也就是说，未显式初始化的map变量其默认值为nil。尝试对nil的map变量进行操作将会导致运行时错误（panic）。例如：
var m map[string]int // 此时m的值为nil // 下面的操作将会导致运行时panic，因为m未被初始化 m[&#34;key&#34;] = 1 // panic: assignment to entry in nil map 为了避免这种情况，我们需要在使用map之前对其进行初始化。可以通过以下两种方式之一来初始化map：
使用make函数初始化： m := make(map[string]int) m[&#34;key&#34;] = 1 // 现在这是安全的，因为m已经被初始化 使用字面量初始化： m := map[string]int{&#34;key&#34;: 1} // 或者 m := map[string]int{} m[&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-11T09:20:02+08:00">
    <meta property="article:modified_time" content="2024-06-11T09:20:02+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Go语言精进之路】构建高效Go程序：了解map实现原理并高效使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/cf/70/VEX75gT2_o.png" alt="在这里插入图片描述"></p> 
<center> 
 <strong><font color="red">🔥 个人主页：<a href="https://blog.csdn.net/m0_52827996?spm=1010.2135.3001.5343">空白诗</a></font></strong> 
</center> 
<center> 
 <strong><font color="red">🔥 热门专栏：<a href="https://blog.csdn.net/m0_52827996/category_12690926.html?spm=1001.2014.3001.5482">【Go语言精进之路】</a></font></strong> 
</center> 
<p><img src="https://images2.imgbox.com/08/7f/lQyKsAdR_o.gif" alt="在这里插入图片描述"></p> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#_12" rel="nofollow">引言</a></li><li><a href="#map_20" rel="nofollow">一、什么是`map`</a></li><li><ul><li><a href="#11_map_22" rel="nofollow">1.1 `map`的基本概念与特性</a></li><li><a href="#12_map_28" rel="nofollow">1.2 map的初始化与零值问题</a></li><li><a href="#13_map_57" rel="nofollow">1.3 `map`作为引用类型的行为</a></li></ul> 
   </li><li><a href="#map_90" rel="nofollow">二、`map`的基本操作</a></li><li><ul><li><a href="#21__96" rel="nofollow">2.1 插入数据</a></li><li><a href="#22__112" rel="nofollow">2.2 获取数据个数</a></li><li><a href="#23__125" rel="nofollow">2.3 查找和数据读取</a></li><li><a href="#24__140" rel="nofollow">2.4 删除数据</a></li><li><a href="#25__151" rel="nofollow">2.5 遍历数据</a></li></ul> 
   </li><li><a href="#map_212" rel="nofollow">三、map的内部实现</a></li><li><ul><li><a href="#31__216" rel="nofollow">3.1 初始状态</a></li><li><a href="#32_map_236" rel="nofollow">3.2 `map`扩容</a></li><li><a href="#33_map_244" rel="nofollow">3.3 `map`并发</a></li></ul> 
   </li><li><a href="#capmap_259" rel="nofollow">四、尽量使用cap参数创建map</a></li><li><a href="#_338" rel="nofollow">五、总结</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<p><img src="https://images2.imgbox.com/27/a9/wVfehxbE_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_12"></a>引言</h3> 
<blockquote> 
 <p>在Go语言中，<code>map</code> 是一种无序的键值对集合，它以其高效的查找、插入和删除操作而闻名。了解 <code>map</code> 的基本概念、特性和内部实现机制，对于编写高效且稳定的Go代码至关重要。本文将深入探讨 <code>map</code> 的各个方面，包括其初始化、基本操作、内部实现细节，并讨论为何在创建 <code>map</code> 时应尽量使用带有容量提示参数的做法。</p> 
</blockquote> 
<hr> 
<h3><a id="map_20"></a>一、什么是<code>map</code></h3> 
<p><img src="https://images2.imgbox.com/0b/45/2RP6oBVw_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="11_map_22"></a>1.1 <code>map</code>的基本概念与特性</h4> 
<p><code>map</code>是Go语言中的一种内建引用类型，它表示一组<mark>无序的键值对集合</mark>。每个键值对用冒号“:”分隔，其中键（key）是唯一的，用于标识对应的值（value）。<code>map</code>允许我们根据特定的键快速检索、更新或删除对应的值。</p> 
<p>在Go语言中，<code>map</code>对值（value）的数据类型没有特定限制，它可以是任意类型，包括基本类型、结构体、自定义类型等。但是，键（key）的类型有严格要求：key的类型必须可以通过“==”和“!=”操作符进行比较，这意味着键的类型需要是可比较的。<font color="#efsdsf"><strong>因此，像函数、map和切片这样不可比较的类型不能作为map的键</strong></font>。</p> 
<h4><a id="12_map_28"></a>1.2 map的初始化与零值问题</h4> 
<p>需要注意的是，<font color="#efsdsf"><strong><code>map</code>类型不支持“零值可用”</strong></font>，也就是说，<strong>未显式初始化的map变量其默认值为<code>nil</code></strong>。尝试对<code>nil</code>的<code>map</code>变量进行操作将会导致运行时错误（panic）。例如：</p> 
<pre><code class="prism language-go"><span class="token keyword">var</span> m <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span>  <span class="token comment">// 此时m的值为nil</span>
<span class="token comment">// 下面的操作将会导致运行时panic，因为m未被初始化</span>
m<span class="token punctuation">[</span><span class="token string">"key"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">// panic: assignment to entry in nil map</span>
</code></pre> 
<p>为了避免这种情况，我们需要在使用<code>map</code>之前对其进行初始化。可以通过以下两种方式之一来初始化<code>map</code>：</p> 
<ol><li>使用<code>make</code>函数初始化：</li></ol> 
<pre><code class="prism language-go">m <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>
m<span class="token punctuation">[</span><span class="token string">"key"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">// 现在这是安全的，因为m已经被初始化</span>
</code></pre> 
<ol start="2"><li>使用字面量初始化：</li></ol> 
<pre><code class="prism language-go">m <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{<!-- --></span><span class="token string">"key"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span>
<span class="token comment">// 或者</span>
m <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
m<span class="token punctuation">[</span><span class="token string">"key"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">// 同样是安全的，因为m已经被初始化</span>
</code></pre> 
<p>初始化后的<code>map</code>可以被安全地用于存储和检索键值对，而不会导致运行时错误。在Go程序中，<code>map</code>是非常有用的数据结构，特别适用于需要根据键快速查找、添加或删除相应值的场景。</p> 
<h4><a id="13_map_57"></a>1.3 <code>map</code>作为引用类型的行为</h4> 
<p>和切片一样，<strong><code>map</code>也是引用类型</strong>。这意味着，当你<font color="#efsdsf"><strong>将一个<code>map</code>类型的变量传递给函数时，实际上传递的是指向底层数据结构的指针，而不是整个数据结构的拷贝</strong></font>。因此，将<code>map</code>类型变量作为函数参数传入不会有很大的性能消耗。</p> 
<p>此外，由于在函数内部和外部引用的是同一个底层数据结构，所以在函数内部对<code>map</code>变量的修改（如添加、删除键值对或更新值）在函数外部也是可见的。这种特性使得<code>map</code>在需要在多个函数或方法间共享和修改数据时非常有用。</p> 
<p>以下是一个示例，展示了在函数内部修改<code>map</code>，并在函数外部观察到这些修改：</p> 
<pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">modifyMap</span><span class="token punctuation">(</span>m <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 在函数内部修改map</span>
    m<span class="token punctuation">[</span><span class="token string">"apple"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">5</span>
    m<span class="token punctuation">[</span><span class="token string">"banana"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 初始化一个map</span>
    fruitMap <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>
    
    <span class="token comment">// 调用函数，传入map作为参数</span>
    <span class="token function">modifyMap</span><span class="token punctuation">(</span>fruitMap<span class="token punctuation">)</span>
    
    <span class="token comment">// 打印修改后的map，可以看到在modifyMap函数中所做的修改</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>fruitMap<span class="token punctuation">)</span> <span class="token comment">// 输出: map[apple:5 banana:10]</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在这个例子中，<code>modifyMap</code>函数接收一个<code>map</code>作为参数，并在函数内部添加了两个键值对。当函数执行完毕后，<code>main</code>函数中的<code>fruitMap</code>已经被修改，反映了<code>modifyMap</code>函数中所做的更改。这是因为<code>map</code>是引用类型，<code>modifyMap</code>接收的是<code>fruitMap</code>的引用，因此对它的任何修改都会反映在原始<code>map</code>上。</p> 
<hr> 
<h3><a id="map_90"></a>二、<code>map</code>的基本操作</h3> 
<p><img src="https://images2.imgbox.com/b5/05/ixmhYdL1_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="21__96"></a>2.1 插入数据</h4> 
<p>当面对一个非<code>nil</code>的<code>map</code>类型变量时，我们可以向其中插入符合<code>map</code>类型定义的任意键值对。值得注意的是，如果试图插入的键（key）已经存在于<code>map</code>中，那么新的值将会覆盖旧的值。Go运行时会管理<code>map</code>内部的内存，因此，除非系统内存耗尽，否则我们不必担心向<code>map</code>中插入大量数据。</p> 
<pre><code class="prism language-go">m <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>
m<span class="token punctuation">[</span><span class="token string">"apple"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">5</span>  <span class="token comment">// 插入键值对 "apple": 5</span>
m<span class="token punctuation">[</span><span class="token string">"apple"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">7</span>  <span class="token comment">// 更新键 "apple" 的值为 7，旧值5被覆盖</span>
m<span class="token punctuation">[</span><span class="token string">"banana"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span> <span class="token comment">// 插入键值对 "banana": 10</span>
</code></pre> 
<p>在上述代码中，我们首先创建了一个从<code>string</code>类型到<code>int</code>类型的<code>map</code>。然后，我们插入了键值对<code>"apple": 5</code>。紧接着，我们尝试再次插入键<code>"apple"</code>，但这次赋予它一个新的值<code>7</code>。由于这个键已经存在于<code>map</code>中，因此旧的值<code>5</code>会被新的值<code>7</code>覆盖。最后，我们插入了一个新的键值对<code>"banana": 10</code>。</p> 
<p>这种覆盖行为是<code>map</code>的一个重要特性，它允许我们根据需要更新存储在<code>map</code>中的值。在实际编程中，这一特性非常有用，比如当我们需要根据某些条件动态改变值时。</p> 
<h4><a id="22__112"></a>2.2 获取数据个数</h4> 
<p>要获取<code>map</code>中数据的个数，可以使用内置的<code>len()</code>函数。</p> 
<pre><code class="prism language-go">count <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Number of items in map:"</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span> <span class="token comment">// 输出map中的元素个数</span>
</code></pre> 
<p><code>len(m)</code>返回<code>m</code>中当前存储的键值对数量。</p> 
<h4><a id="23__125"></a>2.3 查找和数据读取</h4> 
<p>可以根据键来查找和读取<code>map</code>中的数据。如果键不存在，则返回该类型的零值。</p> 
<pre><code class="prism language-go">value<span class="token punctuation">,</span> exists <span class="token operator">:=</span> m<span class="token punctuation">[</span><span class="token string">"apple"</span><span class="token punctuation">]</span> <span class="token comment">// 查找键为"apple"的值，并检查键是否存在</span>
<span class="token keyword">if</span> exists <span class="token punctuation">{<!-- --></span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"The value of 'apple' is:"</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"'apple' does not exist in the map."</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>使用<code>value, exists := m[key]</code>的格式可以同时获取键对应的值和该键是否存在。如果键存在，<code>exists</code>为<code>true</code>，并且<code>value</code>为该键对应的值；如果键不存在，<code>exists</code>为<code>false</code>，<code>value</code>为该类型的零值。</p> 
<h4><a id="24__140"></a>2.4 删除数据</h4> 
<p>要从<code>map</code>中删除一个键值对，可以使用<code>delete()</code>函数。</p> 
<pre><code class="prism language-go"><span class="token function">delete</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token string">"banana"</span><span class="token punctuation">)</span> <span class="token comment">// 删除键为"banana"的键值对</span>
</code></pre> 
<p><code>delete(m, key)</code>函数会从<code>m</code>中删除与<code>key</code>关联的键值对。如果<code>key</code>不存在，则<code>delete</code>什么也不做。</p> 
<h4><a id="25__151"></a>2.5 遍历数据</h4> 
<p>可以使用<code>range</code>关键字来遍历<code>map</code>中的所有键值对。</p> 
<pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	m <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{<!-- --></span>
		<span class="token number">1</span><span class="token punctuation">:</span> <span class="token number">11</span><span class="token punctuation">,</span> 
		<span class="token number">2</span><span class="token punctuation">:</span> <span class="token number">12</span><span class="token punctuation">,</span> 
		<span class="token number">3</span><span class="token punctuation">:</span> <span class="token number">13</span><span class="token punctuation">,</span>
	<span class="token punctuation">}</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"{ "</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token operator">:=</span> <span class="token keyword">range</span> m <span class="token punctuation">{<!-- --></span>
		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"key: %d, value: %d  "</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">" }\n"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>range m</code>会迭代<code>m</code>中的所有键值对，每次迭代都会返回当前的键和值。在上面的循环中，<code>key</code>和<code>value</code>分别被赋值为当前迭代的键和值，然后打印出来。<br> <img src="https://images2.imgbox.com/f0/e5/kUFL9Ucl_o.png" alt="在这里插入图片描述"></p> 
<p>上面的输出结果非常理想，给我们的表象是迭代器按照<code>map</code>中的元素插入次序逐一遍历。那让我们再多遍历几次这个<code>map</code>：</p> 
<pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">doIteration</span><span class="token punctuation">(</span>m <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"{ "</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token operator">:=</span> <span class="token keyword">range</span> m <span class="token punctuation">{<!-- --></span>
		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"key: %d, value: %d  "</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">" }\n"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	m <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{<!-- --></span>
		<span class="token number">1</span><span class="token punctuation">:</span> <span class="token number">11</span><span class="token punctuation">,</span>
		<span class="token number">2</span><span class="token punctuation">:</span> <span class="token number">12</span><span class="token punctuation">,</span>
		<span class="token number">3</span><span class="token punctuation">:</span> <span class="token number">13</span><span class="token punctuation">,</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">doIteration</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/3f/a0/EyYe9t4l_o.png" alt="在这里插入图片描述"></p> 
<p>我们看见对同一<code>map</code>进行多次遍历，遍历的元素次序并不相同。这是因为Go运行时在初始化map迭代器时对起始位置做了随机处理。因此<font color="efsdsf"><strong>千万不要依赖遍历<code>map</code>所得到的元素次序</strong></font>。</p> 
<hr> 
<h3><a id="map_212"></a>三、map的内部实现</h3> 
<p><img src="https://images2.imgbox.com/21/40/AYRH5vL2_o.png" alt="在这里插入图片描述"><br> 和切片相比，<code>map</code>类型的内部实现要复杂得多。Go运行时使用一张哈希表来实现抽象的<code>map</code>类型，运行时实现了<code>map</code>操作的所有功能，包括查找、插入、删除、遍历等。本文这里只做一些简单的介绍。</p> 
<h4><a id="31__216"></a>3.1 初始状态</h4> 
<p>在Go语言中，当一个<code>map</code>被初始化时，它会分配一个较小的内存空间来存储键值对数据。这个初始的内存空间包含一定数量的桶（buckets），每个桶能够存储一个或多个键值对。初始状态下，这些桶都是空的。</p> 
<p><code>map</code>的初始化可以通过字面量、<code>make</code>函数或者直接使用<code>map</code>类型进行。例如：</p> 
<pre><code class="prism language-go"><span class="token comment">// 使用字面量初始化</span>
m1 <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{<!-- --></span><span class="token string">"apple"</span><span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">"banana"</span><span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">}</span>

<span class="token comment">// 使用make函数初始化</span>
m2 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>

<span class="token comment">// 直接声明map类型变量（需要后续进行初始化）</span>
<span class="token keyword">var</span> m3 <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span>
m3 <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>
</code></pre> 
<p>在初始化时，<code>map</code>会预留一定的空间以准备存储键值对，但这个初始空间相对较小。</p> 
<h4><a id="32_map_236"></a>3.2 <code>map</code>扩容</h4> 
<p>当<code>map</code>中的元素数量增加，负载因子（已存储的键值对数量与桶的数量的比例）也会随之增加。当负载因子超过某个预定的阈值时，<code>map</code>会进行扩容以保证性能。</p> 
<p>扩容过程中，<code>map</code>会创建一个更大的桶数组，并且重新计算所有现有键值对的哈希值，将它们重新分布到新的桶数组中。这个重新哈希和分布的过程是为了确保键值对能够更均匀地分散在新的桶中，从而减少哈希冲突并提高查找效率。</p> 
<p>扩容是一个相对昂贵的操作，因为它涉及到内存分配和大量数据的迁移。因此，在实际使用中，如果可能的话，最好提前预估<code>map</code>的大小并一次性分配足够的空间。</p> 
<h4><a id="33_map_244"></a>3.3 <code>map</code>并发</h4> 
<p>Go语言的<code>map</code>类型并不是并发安全的。这意味着如果多个goroutine同时对一个<code>map</code>进行读写操作，就可能导致数据竞争（data race）和不可预知的行为。</p> 
<p>为了在并发环境中安全地使用<code>map</code>，有几种常见的解决方案：</p> 
<ol><li> <p><strong>使用互斥锁（Mutex）</strong>：通过使用<code>sync.Mutex</code>或<code>sync.RWMutex</code>来同步对<code>map</code>的访问。在每次读写<code>map</code>之前，先获取锁，操作完成后再释放锁。</p> </li><li> <p><strong>使用<code>sync.Map</code></strong>：Go语言标准库提供了一个并发安全的<code>map</code>实现，即<code>sync.Map</code>。它内部使用了分段锁和其他优化技术来提供高效的并发访问。</p> </li><li> <p><strong>通道（Channel）</strong>：另一种方法是使用Go的通道来序列化对<code>map</code>的访问。通过将所有对<code>map</code>的操作都通过一个或多个通道来进行，可以确保在同一时间只有一个goroutine能够访问<code>map</code>。</p> </li></ol> 
<p>在实际应用中，选择哪种并发控制方法取决于具体的使用场景和性能要求。对于简单的用例，使用互斥锁可能就足够了；而在需要高并发性能的场景中，<code>sync.Map</code>可能更为合适。</p> 
<hr> 
<h3><a id="capmap_259"></a>四、尽量使用cap参数创建map</h3> 
<p><img src="https://images2.imgbox.com/d0/08/riD7yPB1_o.png" alt="在这里插入图片描述"><br> 由于扩容是一个相对昂贵的操作，因为它涉及到内存分配和大量数据的迁移，因此，如果可以的话我们最好对<code>map</code>使用规模做出粗略的估算，并使用<code>cap</code>参数对<code>map</code>实例进行初始化。</p> 
<p>当你创建一个 <code>map</code> 而不指定容量时，Go 会自动为你分配一个初始的、未指定的容量。这个容量足以满足初始需求，并且随着 <code>map</code> 中元素的增加，Go 的运行时会自动管理其内部结构的大小调整，以容纳更多的元素。这是最常见也是最简单的初始化方式。</p> 
<pre><code class="prism language-go">m <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>
</code></pre> 
<p>如果你在创建 <code>map</code> 时明确指定了 <code>cap</code> 参数，你是在给 Go 提供一个关于你期望 <code>map</code> 最终可能包含多少个键值对的提示。这有助于减少 <code>map</code> 在增长过程中需要重新分配内存的次数，从而提高效率，尤其是在你知道 <code>map</code> 大致会有多大时。但请注意，指定的 <code>cap</code> 是一个提示而不是严格的限制，<code>map</code> 的实际容量可能会略高于指定的值，且 <code>map</code> 仍然可以在达到这个预设容量后继续增长。</p> 
<pre><code class="prism language-go">m <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>
</code></pre> 
<p><strong>优缺点分析：</strong></p> 
<ul><li><strong>不使用 cap</strong>：简化初始化过程，让Go自动管理容量，适用于大多数情况，特别是当你不确定<code>map</code>最终大小时。</li><li><strong>使用 cap</strong>：通过预先估计<code>map</code>的大小，可以略微优化性能，减少动态扩容的次数，适合于明确知道或能估算<code>map</code>容量的场景。</li></ul> 
<p>选择是否使用 <code>cap</code> 主要取决于你对<code>map</code>最终规模的了解程度和对性能的特定需求。在不需要精确控制初始容量的情况下，省略 <code>cap</code> 是一个简洁且有效的方法。然而，如果你正处理大量数据且关心性能优化，明智地设定初始容量可以带来益处。</p> 
<p>下面对两种初始化方式的性能进行对比：</p> 
<pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"testing"</span>

<span class="token keyword">const</span> mapSize <span class="token operator">=</span> <span class="token number">10000</span>

<span class="token keyword">func</span> <span class="token function">BenchmarkMapInitWithoutCap</span><span class="token punctuation">(</span>b <span class="token operator">*</span>testing<span class="token punctuation">.</span>B<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> b<span class="token punctuation">.</span>N<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
		m <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>
		<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> mapSize<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
			m<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">BenchmarkMapInitWithCap</span><span class="token punctuation">(</span>b <span class="token operator">*</span>testing<span class="token punctuation">.</span>B<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> b<span class="token punctuation">.</span>N<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
		m <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> mapSize<span class="token punctuation">)</span>
		<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> mapSize<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
			m<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>BenchmarkMapInitWithoutCap</code>函数执行以下操作：</p> 
<ol><li> <p>它使用一个循环，该循环将运行<code>b.N</code>次，其中<code>b.N</code>是<code>testing.B</code>提供的，表示基准测试应该运行的次数。这是为了确保我们获得足够的数据点来平均性能测试结果，从而获得更准确的数据。</p> </li><li> <p>在每次循环中，它创建一个新的map，没有指定初始容量（<code>make(map[int]int)</code>）。</p> </li><li> <p>然后，它向这个map中插入<code>mapSize</code>（即10000）个键值对，其中键和值都是循环变量<code>i</code>。</p> </li></ol> 
<p>这个基准测试的目的是测量在不指定初始容量的情况下，初始化并填充一个map的性能。</p> 
<p>执行结果如下：<br> <img src="https://images2.imgbox.com/e2/ff/gWH1UCLZ_o.png" alt="在这里插入图片描述"></p> 
<p><code>BenchmarkMapInitWithCap</code>函数与<code>BenchmarkMapInitWithoutCap</code>非常相似，但有一个关键区别：</p> 
<ol><li>在创建map时，它使用<code>make(map[int]int, mapSize)</code>来指定一个初始容量提示，这个容量提示等于将要插入的键值对的数量（即10000）。</li></ol> 
<p>这个基准测试的目的是测量在指定了与将要插入的键值对数量相等的初始容量提示的情况下，初始化并填充一个map的性能。</p> 
<p>下面是执行结果：<br> <img src="https://images2.imgbox.com/40/0b/oVFNWOJ4_o.png" alt="在这里插入图片描述"><br> 可以看出，使用<code>cap</code>参数的<code>map</code>实例的平均写性能是不使用<code>cap</code>参数的2倍。</p> 
<hr> 
<h3><a id="_338"></a>五、总结</h3> 
<p>本文通过详细阐述了Go语言中 <code>map</code> 的基本概念、特性及其作为引用类型的行为，介绍了 <code>map</code> 的基本操作如插入、获取数据个数、查找、删除和遍历数据等。同时，深入剖析了 <code>map</code> 的内部实现，包括其初始状态、扩容机制以及并发问题。最后，本文强调了在使用 <code>map</code> 时，为了提高性能和减少内存重新分配的次数，应尽量在创建时提供合理的容量提示参数。通过全面理解 <code>map</code> 的工作原理和最佳实践，开发者可以更加有效地利用这一强大的数据结构来优化程序性能。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/44aef51890592f430e9dd34f70506cc3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Go语言精进之路】构建高效Go程序：掌握变量、常量声明法则与iota在枚举中的奥秘</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f0ba67f25e092637af5e6e6d0b24a56d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C语言详解（文件操作）2</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>