<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【算法专题】二分查找 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/0d3b38b92d2007fb60356c9b8cab53c7/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【算法专题】二分查找">
  <meta property="og:description" content="二分查找 二分查找1. 二分查找2. 在排序数组中查找元素的第一和最后一个位置3. 搜索插入位置4. x 的平方根5. 山脉数组的峰顶索引6. 寻找峰值7. 寻找旋转排序数组中的最小值8. 点名 二分查找 1. 二分查找 题目链接 -&gt; Leetcode -704.二分查找
Leetcode -704.二分查找
题目：给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 - 1。
示例 1:
输入: nums = [-1, 0, 3, 5, 9, 12], target = 9
输出 : 4
解释 : 9 出现在 nums 中并且下标为 4
示例 2 :
输入 : nums = [-1, 0, 3, 5, 9, 12], target = 2">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-12-03T00:53:32+08:00">
    <meta property="article:modified_time" content="2023-12-03T00:53:32+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【算法专题】二分查找</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>二分查找</h4> 
 <ul><li><a href="#_2" rel="nofollow">二分查找</a></li><li><ul><li><a href="#1__3" rel="nofollow">1. 二分查找</a></li><li><a href="#2__59" rel="nofollow">2. 在排序数组中查找元素的第一和最后一个位置</a></li><li><a href="#3__152" rel="nofollow">3. 搜索插入位置</a></li><li><a href="#4_x__209" rel="nofollow">4. x 的平方根</a></li><li><a href="#5__260" rel="nofollow">5. 山脉数组的峰顶索引</a></li><li><a href="#6__324" rel="nofollow">6. 寻找峰值</a></li><li><a href="#7__383" rel="nofollow">7. 寻找旋转排序数组中的最小值</a></li><li><a href="#8__462" rel="nofollow">8. 点名</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_2"></a>二分查找</h2> 
<h3><a id="1__3"></a>1. 二分查找</h3> 
<p>题目链接 -&gt; <a href="https://leetcode.cn/problems/binary-search/" rel="nofollow">Leetcode -704.二分查找</a></p> 
<p>Leetcode -704.二分查找</p> 
<p>题目：给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 - 1。</p> 
<p>示例 1:<br> 输入: nums = [-1, 0, 3, 5, 9, 12], target = 9<br> 输出 : 4<br> 解释 : 9 出现在 nums 中并且下标为 4</p> 
<p>示例 2 :<br> 输入 : nums = [-1, 0, 3, 5, 9, 12], target = 2<br> 输出 : -1<br> 解释 : 2 不存在 nums 中因此返回 - 1</p> 
<p>提示：<br> 你可以假设 nums 中的所有元素是不重复的。<br> n 将在[1, 10000]之间。<br> nums 的每个元素都将在[-9999, 9999]之间。</p> 
<p>思路：</p> 
<ol><li> <p><strong>定义 left ， right 指针，分别指向数组的左右区间。</strong></p> </li><li> <p><strong>找到待查找区间的中间点 mid ，找到之后分三种情况讨论：</strong></p> </li></ol> 
<ul><li><strong>arr[mid] == target 说明正好找到，返回 mid 的值；</strong></li><li><strong>arr[mid] &gt; target 说明 [mid, right] 这段区间都是大于 target 的，因此舍去右边区间，在左边 [left, mid -1] 的区间继续查找，即让 right = mid - 1 ，然后重复 2 过程；</strong></li><li><strong>arr[mid] &lt; target 说明 [left, mid] 这段区间的值都是小于 target 的，因此舍去左边区间，在右边 [mid + 1, right] 区间继续查找，即让 left = mid + 1 ，然后重复 2 过程；</strong></li></ul> 
<ol start="3"><li><strong>当 left 与 right 错开时，说明整个区间都没有这个数，返回 -1 。</strong></li></ol> 
<p>代码如下：</p> 
<pre><code>		class Solution {
		public:
		    int search(vector&lt;int&gt;&amp; nums, int target)
		    {
		        int left = 0, right = nums.size() - 1;
		        while (left &lt;= right)
		        {
		            int mid = left + (right - left) / 2;  // 防止溢出
		            if (nums[mid] &gt; target) right = mid - 1; // 中间数比 target 大，改变右指针
		            else if (nums[mid] &lt; target) left = mid + 1; // 中间数比 target 小，改变左指针
		            else return mid; // 找到返回下标
		        }
		        return -1;
		    }
		};
</code></pre> 
<h3><a id="2__59"></a>2. 在排序数组中查找元素的第一和最后一个位置</h3> 
<p>题目链接 -&gt; <a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/" rel="nofollow">Leetcode -34.在排序数组中查找元素的第一和最后一个位置</a></p> 
<p>Leetcode -34.在排序数组中查找元素的第一和最后一个位置</p> 
<p>题目：给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p> 
<p>如果数组中不存在目标值 target，返回[-1, -1]。</p> 
<p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p> 
<p>示例 1：<br> 输入：nums = [5, 7, 7, 8, 8, 10], target = 8<br> 输出：[3, 4]</p> 
<p>示例 2：<br> 输入：nums = [5, 7, 7, 8, 8, 10], target = 6<br> 输出：[-1, -1]</p> 
<p>示例 3：<br> 输入：nums = [], target = 0<br> 输出：[-1, -1]</p> 
<p>提示：</p> 
<ul><li>0 &lt;= nums.length &lt;= 10^5</li><li>10^9 &lt;= nums[i] &lt;= 10^9<br> nums 是一个非递减数组</li><li>10^9 &lt;= target &lt;= 10^9</li></ul> 
<p><strong>思路：二分思想，就是根据数据的性质，在某种判断条件下将区间一分为二，然后舍去其中一个区间，然后再另一个区间内查找；为了方便叙述，用 x 表示该元素， resLeft 表示左边界， resRight 表示右边界；</strong></p> 
<p><strong>寻找左边界思路：<br> 我们注意到以左边界划分的两个区间的特点：</strong></p> 
<ul><li><strong>左边区间 [left, resLeft - 1] 都是小于 x 的；</strong></li><li><strong>右边区间（包括左边界） [resLeft, right] 都是大于等于 x 的；</strong></li></ul> 
<p><strong>因此，关于 mid 的落点，我们可以分为下面两种情况：</strong></p> 
<ul><li><strong>当我们的 mid 落在 [left, resLeft - 1] 区间的时候，也就是 arr[mid] &lt; target 。说明 [left, mid] 都是可以舍去的，此时更新 left 到 mid + 1 的位置，继续在 [mid + 1, right] 上寻找左边界</strong>；</li><li><strong>当 mid 落在 [resLeft， right] 的区间的时候，也就是 arr[mid] &gt;= target 。说明 [mid + 1, right] （因为 mid 可能是最终结果，不能舍去）是可以舍去的，此时更新 right 到 mid 的位置，继续在 [left, mid] 上寻找左边界；</strong></li></ul> 
<p><strong>注意：这里找中间元素需要向下取整。因为后续移动左右指针的时候：</strong></p> 
<ul><li><strong>左指针： left = mid + 1 ，是会向后移动的，因此区间是会缩小的；</strong></li><li><strong>右指针： right = mid ，可能会原地踏步（比如：如果向上取整的话，如果剩下 1,2 两个元素， left == 1 ， right == 2 ， mid == 2 。更新区间之后， left，right，mid 的值没有改变，就会陷入死循环）。因此一定要注意，当 right = mid 的时候，要向下取整。</strong></li></ul> 
<p>同理大家可以尝试分析寻找右边界的思路。</p> 
<p>代码如下：</p> 
<pre><code>		class Solution {
		public:
		    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target)
		    {
		        if (nums.size() == 0) return { -1, -1 };
		
		        int left = 0, right = nums.size() - 1;
		        int begin = -1;
		
		        // 寻找左端点
		        while (left &lt; right)
		        {
		            // 当元素个数为偶数个时，取左边的为中间元素，因为要找的是左边界
		            int mid = left + (right - left) / 2;  
		            if (nums[mid] &lt; target) left = mid + 1;
		            else right = mid;
		        }
		        if (target == nums[left]) begin = left;
		        else return { -1, -1 };
		
		        left = 0, right = nums.size() - 1;
		        // 寻找右端点
		        while (left &lt; right)
		        {
		            // 当元素个数为偶数个时，取右边的为中间元素，因为要找的是右边界
		            // 或者当更新 right / left 时出现 -1 取mid的时候就要+1
		            int mid = left + (right - left + 1) / 2;  
		            if (nums[mid] &gt; target) right = mid - 1;
		            else left = mid;
		        }
		        return { begin, right };
		    }
		};
</code></pre> 
<h3><a id="3__152"></a>3. 搜索插入位置</h3> 
<p>题目链接 -&gt; <a href="https://leetcode.cn/problems/search-insert-position/" rel="nofollow">Leetcode -35.搜索插入位置</a></p> 
<p>Leetcode -35.搜索插入位置</p> 
<p>题目：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p> 
<p>请必须使用时间复杂度为 O(log n) 的算法。</p> 
<p>示例 1:<br> 输入: nums = [1, 3, 5, 6], target = 5<br> 输出 : 2</p> 
<p>示例 2 :<br> 输入 : nums = [1, 3, 5, 6], target = 2<br> 输出 : 1</p> 
<p>示例 3 :<br> 输入 : nums = [1, 3, 5, 6], target = 7<br> 输出 : 4</p> 
<p>提示 :</p> 
<ul><li>1 &lt;= nums.length &lt;= 10^4</li><li>10^4 &lt;= nums[i] &lt;= 10^4<br> nums 为 无重复元素 的 升序 排列数组</li><li>10^4 &lt;= target &lt;= 10^4</li></ul> 
<p><strong>思路与上题思路类似，寻找目标值的左边界即可。</strong></p> 
<p>代码如下：</p> 
<pre><code>		class Solution {
		public:
		    int searchInsert(vector&lt;int&gt;&amp; nums, int target)
		    {
		        // 如果插入的位置在最后
		        if (nums[nums.size() - 1] &lt; target) return nums.size();
		
		        int left = 0, right = nums.size() - 1;
		
		        // 二分查找找左边界
		        while (left &lt; right)
		        {
		            int mid = left + (right - left) / 2;
		            if (nums[mid] &lt; target) left = mid + 1;
		            else right = mid;
		        }
		        return left;
		    }
		};
</code></pre> 
<h3><a id="4_x__209"></a>4. x 的平方根</h3> 
<p>题目链接 -&gt; <a href="https://leetcode.cn/problems/sqrtx/" rel="nofollow">Leetcode -69.x 的平方根</a></p> 
<p>Leetcode -69.x 的平方根</p> 
<p>题目：给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</p> 
<p>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</p> 
<p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x** 0.5 。</p> 
<p>示例 1：<br> 输入：x = 4<br> 输出：2</p> 
<p>示例 2：<br> 输入：x = 8<br> 输出：2<br> 解释：8 的算术平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。</p> 
<p>提示：<br> 0 &lt;= x &lt;= 2^31 - 1</p> 
<p><strong>思路也和上题类似，寻找右边界即可；</strong></p> 
<p>代码如下：</p> 
<pre><code>		class Solution {
		public:
		    int mySqrt(int x)
		    {
		        // long long 防止溢出
		        long long left = 0, right = x;
		
		        // 二分查找寻找右边界
		        while (left &lt; right)
		        {
		            long long mid = left + (right - left + 1) / 2;
		            if (mid * mid &gt; x) right = mid - 1;
		            else left = mid;
		        }
		        return left;
		    }
		};
</code></pre> 
<h3><a id="5__260"></a>5. 山脉数组的峰顶索引</h3> 
<p>题目链接 -&gt; <a href="https://leetcode.cn/problems/peak-index-in-a-mountain-array/" rel="nofollow">Leetcode -825.山脉数组的峰顶索引</a></p> 
<p>Leetcode -825.山脉数组的峰顶索引</p> 
<p>题目：符合下列属性的数组 arr 称为 山脉数组 ：<br> arr.length &gt;= 3<br> 存在 i（0 &lt; i &lt; arr.length - 1）使得：<br> arr[0] &lt; arr[1] &lt; … arr[i - 1] &lt; arr[i]<br> arr[i] &gt; arr[i + 1] &gt; … &gt; arr[arr.length - 1]<br> 给你由整数组成的山脉数组 arr ，返回满足 arr[0] &lt; arr[1] &lt; … arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; … &gt; arr[arr.length - 1] 的下标 i 。<br> 你必须设计并实现时间复杂度为 O(log(n)) 的解决方案。</p> 
<p>示例 1：<br> 输入：arr = [0, 1, 0]<br> 输出：1</p> 
<p>示例 2：<br> 输入：arr = [0, 2, 1, 0]<br> 输出：1</p> 
<p>示例 3：<br> 输入：arr = [0, 10, 5, 2]<br> 输出：1</p> 
<p>提示：<br> 3 &lt;= arr.length &lt;= 10^5<br> 0 &lt;= arr[i] &lt;= 10^6<br> 题目数据保证 arr 是一个山脉数组</p> 
<p>思路：</p> 
<ol><li><strong>分析峰顶位置的数据特点，以及山峰两旁的数据的特点：</strong></li></ol> 
<ul><li><strong>峰顶数据特点： arr[i] &gt; arr[i - 1] &amp;&amp; arr[i] &gt; arr[i + 1] ；</strong></li><li><strong>峰顶左边的数据特点： arr[i] &gt; arr[i - 1] &amp;&amp; arr[i] &lt; arr[i + 1] ，也就是呈现上升趋势；</strong></li><li><strong>峰顶右边数据的特点： arr[i] &lt; arr[i - 1] &amp;&amp; arr[i] &gt; arr[i + 1] ，也就是呈现下降趋势。</strong></li></ul> 
<ol start="2"><li><strong>因此，根据 mid 位置的信息，我们可以分为下面三种情况：</strong></li></ol> 
<ul><li><strong>如果 mid 位置呈现上升趋势，说明我们接下来要在 [mid + 1, right] 区间继续搜索；</strong></li><li><strong>如果 mid 位置呈现下降趋势，说明我们接下来要在 [left, mid - 1] 区间搜索；</strong></li><li><strong>如果 mid 位置就是山峰，直接返回结果。</strong></li></ul> 
<p>代码如下：</p> 
<pre><code>		class Solution {
		public:
		    int peakIndexInMountainArray(vector&lt;int&gt;&amp; arr) 
		    {
		        int left = 0,right = arr.size() - 1;
		        // 符合二段性，就可以用二分查找
		        while(left &lt; right)
		        {
		            int mid = left + (right - left + 1)/2;
		            if(arr[mid] &gt; arr[mid - 1]) left = mid;
		            else right = mid - 1;
		        }
		        return left;
		    }
		};
</code></pre> 
<h3><a id="6__324"></a>6. 寻找峰值</h3> 
<p>题目链接 -&gt; <a href="https://leetcode.cn/problems/find-peak-element/" rel="nofollow">Leetcode -162.寻找峰值</a></p> 
<p>Leetcode -162.寻找峰值</p> 
<p>题目：峰值元素是指其值严格大于左右相邻值的元素。</p> 
<p>给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。</p> 
<p>你可以假设 nums[-1] = nums[n] = -∞ 。</p> 
<p>你必须实现时间复杂度为 O(log n) 的算法来解决此问题。</p> 
<p>示例 1：<br> 输入：nums = [1, 2, 3, 1]<br> 输出：2<br> 解释：3 是峰值元素，你的函数应该返回其索引 2。</p> 
<p>示例 2：<br> 输入：nums = [1, 2, 1, 3, 5, 6, 4]<br> 输出：1 或 5<br> 解释：你的函数可以返回索引 1，其峰值元素为 2；<br> 或者返回索引 5， 其峰值元素为 6。</p> 
<p>提示：</p> 
<ul><li>1 &lt;= nums.length &lt;= 1000</li><li>2^31 &lt;= nums[i] &lt;= 2^31 - 1</li><li>对于所有有效的 i 都有 nums[i] != nums[i + 1]</li></ul> 
<p><strong>思路：寻找二段性：<br> 任取⼀个点 i ，与下一个点 i + 1 ，会有如下两种情况：</strong></p> 
<ul><li><strong>arr[i] &gt; arr[i + 1] ：此时「左侧区域」一定会存在山峰（因为最左侧是负无穷，但此时还没有下降趋势），那么我们可以去左侧去寻找结果；</strong></li><li><strong>arr[i] &lt; arr[i + 1] ：此时「右侧区域」一定会存在山峰（因为最右侧是负无穷，但此时还没有下降趋势），那么我们可以去右侧去寻找结果。</strong></li></ul> 
<p><strong>当我们找到「二段性」的时候，就可以尝试用「二分查找」算法来解决问题。</strong></p> 
<p>代码如下：</p> 
<pre><code>		class Solution {
		public:
		    int findPeakElement(vector&lt;int&gt;&amp; nums) 
		    {
		        int left = 0, right = nums.size() - 1;
		        // 符合二段性，可以用二分查找
		        while(left &lt; right)
		        {
		            int mid = left + (right - left)/2;
		            if(nums[mid] &gt; nums[mid + 1]) right = mid;
		            else left = mid + 1;
		        }
		        return left;
		    }
		};
</code></pre> 
<h3><a id="7__383"></a>7. 寻找旋转排序数组中的最小值</h3> 
<p>题目链接 -&gt; <a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/" rel="nofollow">Leetcode -153.寻找旋转排序数组中的最小值</a></p> 
<p>Leetcode -153.寻找旋转排序数组中的最小值</p> 
<p>题目：已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0, 1, 2, 4, 5, 6, 7] 在变化后可能得到：<br> 若旋转 4 次，则可以得到[4, 5, 6, 7, 0, 1, 2]<br> 若旋转 7 次，则可以得到[0, 1, 2, 4, 5, 6, 7]<br> 注意，数组[a[0], a[1], a[2], …, a[n - 1]] 旋转一次 的结果为数组[a[n - 1], a[0], a[1], a[2], …, a[n - 2]] 。</p> 
<p>给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。</p> 
<p>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p> 
<p>示例 1：<br> 输入：nums = [3, 4, 5, 1, 2]<br> 输出：1<br> 解释：原数组为[1, 2, 3, 4, 5] ，旋转 3 次得到输入数组。</p> 
<p>示例 2：<br> 输入：nums = [4, 5, 6, 7, 0, 1, 2]<br> 输出：0<br> 解释：原数组为[0, 1, 2, 4, 5, 6, 7] ，旋转 4 次得到输入数组。</p> 
<p>示例 3：<br> 输入：nums = [11, 13, 15, 17]<br> 输出：11<br> 解释：原数组为[11, 13, 15, 17] ，旋转 4 次得到输入数组。</p> 
<p>提示：</p> 
<ul><li>n == nums.length</li><li>1 &lt;= n &lt;= 5000</li><li>5000 &lt;= nums[i] &lt;= 5000<br> nums 中的所有整数 互不相同<br> nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转</li></ul> 
<p><strong>思路：题目中的数组规则如下图所示：</strong></p> 
<p><img src="https://images2.imgbox.com/c0/e1/p7bFHXmn_o.png" alt="在这里插入图片描述"></p> 
<p><strong>其中 C 点就是我们要求的点。<br> 二分的本质：找到一个判断标准，使得查找区间能够一分为二。<br> 通过图像我们可以发现， [A，B] 区间内的点都是严格大于 D 点的值的， C 点的值是严格小于 D 点的值的。但是当 [C，D] 区间只有一个元素的时候， C 点的值是可能等于 D 点的值的。</strong></p> 
<p><strong>因此，初始化左右两个指针 left ， right ：<br> 然后根据 mid 的落点，我们可以这样划分下一次查询的区间：</strong></p> 
<ul><li><strong>当 mid 在 [A，B] 区间的时候，也就是 mid 位置的值严格大于 D 点的值，下一次查询区间在 [mid + 1，right] 上；</strong></li><li><strong>当 mid 在 [C，D] 区间的时候，也就是 mid 位置的值严格小于等于 D 点的值，下次查询区间在 [left，mid] 上。</strong></li></ul> 
<p><strong>当区间长度变成 1 的时候，就是我们要找的结果。</strong></p> 
<p>代码如下：</p> 
<pre><code>		class Solution {
		public:
		    int findMin(vector&lt;int&gt;&amp; nums) 
		    {
		        int left = 0, right = nums.size() - 1;
		        while(left &lt; right)
		        {
		            // 以最右边的元素为目标进行比较
		            int mid = left + (right - left )/2;
		            if(nums[mid] &gt; nums[nums.size() - 1]) left = mid + 1;
		            else right = mid;
		        }
		        return nums[left];
		    }
		};
</code></pre> 
<h3><a id="8__462"></a>8. 点名</h3> 
<p>题目链接 -&gt; <a href="https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/" rel="nofollow">Leetcode -LCR 173.点名</a></p> 
<p>Leetcode -LCR 173.点名</p> 
<p>题目：某班级 n 位同学的学号为 0 ~n - 1。点名结果记录于升序数组 records。假定仅有一位同学缺席，请返回他的学号。</p> 
<p>示例 1:<br> 输入: records = [0, 1, 2, 3, 5]<br> 输出 : 4</p> 
<p>示例 2 :<br> 输入 : records = [0, 1, 2, 3, 4, 5, 6, 8]<br> 输出 : 7</p> 
<p>提示：<br> 1 &lt;= records.length &lt;= 10000</p> 
<p><strong>思路是以数组下标为目标对象进行比较，寻找左边界即可；</strong></p> 
<p>代码如下：</p> 
<pre><code>		class Solution {
		public:
		    int missingNumber(vector&lt;int&gt;&amp; nums) 
		    {
		        int left = 0, right = nums.size() - 1;
		        while(left &lt; right)
		        {
		            // 以数组下标为目标对象进行比较
		            int mid = left + (right - left)/2;
		            if(nums[mid] &gt; mid) right = mid;
		            else left = mid + 1;
		        }
		        return left == nums[left]? left + 1 : left;
		    }
		};
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ac6cd5a727f8a917841e28573fc8c73a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【算法】动态规划中的路径问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/99ebd1d389b9ad5ff58605705b32c888/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JWT从0到1，小白入门（JWT在vue前端中的使用）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>