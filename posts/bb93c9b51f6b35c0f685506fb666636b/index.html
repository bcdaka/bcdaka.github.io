<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【学习笔记】树上差分总结(点差分/边差分) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/bb93c9b51f6b35c0f685506fb666636b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【学习笔记】树上差分总结(点差分/边差分)">
  <meta property="og:description" content="一.树上差分的基本概念 1.树上差分的定义 树上差分，顾名思义，意思就是在树上做差分。
至于什么是差分呢？如果不会的同学，可以先看看我的这篇博客:一维,二维差分の详解（简单易懂）_一维差分-CSDN博客
2.树上差分能解决的问题 树上差分有什么作用？举个例子，如果题目要求对树上的一段路径进行操作，并询问某个点或某条边被经过的次数，树上差分就可以派上用场了。
类比于差分数组,树上差分利用的思想也是前缀和思想。(在这里应该是子树和思想）
树上差分，就是利用差分的性质，对路径上的重要节点进行修改（而不是暴力全改），作为其差分数组的值，最后在求值时，利用dfs遍历求出差分数组的前缀和得出答案，就可以达到降低复杂度的目的。
树上差分时需要求LCA，不会的同学可以先看看我的这篇博客:详解最近公共祖先(LCA)-CSDN博客
树上差分一般有两种类型的题目，一种是对边进行差分，另一种就是对点进行差分。
下面我将会分别讲解一下这两种问题。
二.点差分 1.思路 直接去dfs暴力加点权的话，肯定会TLE,但是我们现在在讲啥?树上差分啊!
假设需要将两点u,v之间路径上的所有点权增加x,l是lca(u,v),p是l的父亲节点，则差分操作如下：
sum[u] &#43;= x; sum[v] &#43;= x; sum[l] -= x; sum[p] -= x; 举个栗子(其中假设x=1):
其中s和t就是题目中树上点权需要加1的节点的起始点，绿色的数字代表点权(已经加1了) 则操作后有：
至于为什么要这么操作呢?别急，继续往下看。
做完上述的差分操作后，我们就要统计答案了。
当我们dfs搜索到s，向上回溯。
下面以u表示当前dfs搜索到的节点。
对于每个u统计它的子树大小(要用前缀和的思想记录每个点的点权了)，顺着路径标起来。
(即sum[u] &#43;= sum[son])
我们会发现第一次从s回溯到s与t的LCA时候,sum[LCA(s,t)] &#43;= sum[son[LCA(s,t)]]
此时sum[LCA(s,t)]=0(-1&#43;1=0)。这时我们不禁会有一个疑问: &#34;不是LCA(s,t)会被经过一次嘛,为什么是0!&#34;
别急,我们继续搜另一边。.
继续：我们搜索到t,向上回溯。
依旧统计每个u的子树大小sum[u]&#43;=sum[son]
再度回到LCA(s,t)，依旧是sum[LCA(s,t)]&#43;=sum[son[LCA(s,t)]]
这个时候 sum[LCA(s,t)]=1 这就达到了我们要的效果 (是不是特别优秀φ(゜▽゜*)♪)
但是我们还要思考一个问题:万一我们再从LCA(s,t)向上回溯的时候使得其父亲节点的子树和为1怎么办?这样我们不就使得其父亲节点被多经过了一次?
其实很简单，我们只需要在前面差分操作时将sum[fa[lca(s,t)]]-=x就行了。
这样就达到了标记我们路径上的点的要求! 是否有一种恍然大悟的感觉呢?
2.例题Max flow 问题 参考代码 #include&lt;bits/stdc&#43;&#43;.h&gt; using namespace std; int n,q,mx[300001][41],deep[300001],sum[300001],ans; vector&lt;int&gt; vec[300001]; void dfs(int x,int fa)//lca的初始化 { deep[x] = deep[fa] &#43; 1; mx[x][0] = fa; for(int i = 0;i &lt; vec[x].">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-02-04T13:46:46+08:00">
    <meta property="article:modified_time" content="2024-02-04T13:46:46+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【学习笔记】树上差分总结(点差分/边差分)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一.树上差分的基本概念</h2> 
<h3>1.树上差分的定义</h3> 
<p><strong>树上差分</strong>，顾名思义，意思就是<strong>在树上做差分</strong>。</p> 
<p>至于什么是差分呢？如果不会的同学，可以先看看我的这篇博客:<a href="https://blog.csdn.net/weq2011/article/details/129148518?spm=1001.2014.3001.5502" title="一维,二维差分の详解（简单易懂）_一维差分-CSDN博客">一维,二维差分の详解（简单易懂）_一维差分-CSDN博客</a></p> 
<h3>2.树上差分能解决的问题</h3> 
<p>树上差分有什么作用？举个例子，如果题目要求<strong>对树上的一段路径进行操作</strong>，并询问<strong>某个点或某条边被经过的次数</strong>，树上差分就可以派上用场了。</p> 
<p>类比于差分数组,树上差分利用的思想也是<strong>前缀和思想</strong>。(在这里应该是<strong>子树和思想</strong>）</p> 
<p>树上差分，就是<strong>利用差分的性质</strong>，对路径上的<strong>重要节点</strong>进行修改（而<strong>不是暴力全改</strong>），作为其差分数组的值，最后在求值时，利用<strong>dfs遍历</strong>求出<strong>差分数组的前缀和得出答案</strong>，就可以达到降低复杂度的目的。</p> 
<p>树上差分时需要求<strong>LCA</strong>，不会的同学可以先看看我的这篇博客:<a href="https://blog.csdn.net/weq2011/article/details/128693388?spm=1001.2014.3001.5502" title="详解最近公共祖先(LCA)-CSDN博客">详解最近公共祖先(LCA)-CSDN博客</a></p> 
<p>树上差分一般有两种类型的题目，一种是<strong>对边进行差分</strong>，另一种就是<strong>对点进行差分</strong>。</p> 
<p>下面我将会分别讲解一下这两种问题。</p> 
<p></p> 
<h2>二.点差分</h2> 
<h3>1.思路</h3> 
<p>直接去<strong>dfs暴力加点权</strong>的话，肯定会<strong>TLE</strong>,但是我们现在在讲啥?<strong>树上差分啊!</strong></p> 
<p>假设需要<strong>将两点u,v之间路径上的所有点权增加x,l是lca(u,v),p是l的父亲节点</strong>，则差分操作如下：</p> 
<pre><code class="language-cpp">sum[u] += x;
sum[v] += x;
sum[l] -= x;
sum[p] -= x;</code></pre> 
<p>举个栗子(其中假设x=1):</p> 
<p></p> 
<p><img alt="" height="492" src="https://images2.imgbox.com/44/e7/cqm5qW30_o.png" width="502"></p> 
<p>其中s和t就是题目中树上点权需要加1的节点的起始点，绿色的数字代表点权(已经加1了) </p> 
<p>则操作后有：</p> 
<p><img alt="" height="603" src="https://images2.imgbox.com/61/66/SrQuI8GC_o.png" width="670"></p> 
<p>至于为什么要这么操作呢?别急，继续往下看。</p> 
<p>做完上述的差分操作后，我们就要<strong>统计答案</strong>了。</p> 
<p>当我们<strong>dfs搜索到s</strong>，向上回溯。</p> 
<p>下面以<strong>u表示当前dfs搜索到的节点</strong>。</p> 
<p>对于<strong>每个u统计它的子树大小(要用前缀和的思想记录每个点的点权了)，</strong>顺着路径标起来。</p> 
<p>(即<strong>sum[u] += sum[son]</strong>)</p> 
<p>我们会发现<strong>第一次从s回溯到s与t的LCA</strong>时候,<strong>sum[LCA(s,t)] += sum[son[LCA(s,t)]]</strong></p> 
<p>此时<strong>sum[LCA(s,t)]=0(-1+1=0)</strong>。这时我们不禁会有一个疑问: "不是LCA(s,t)会被经过一次嘛,为什么是0!"</p> 
<p>别急,我们继续搜另一边。.</p> 
<p>继续：<strong>我们搜索到t,向上回溯。</strong></p> 
<p>依旧统计每个u的子树大小<strong>sum[u]+=sum[son]</strong></p> 
<p><strong>再度回到LCA(s,t)</strong>，依旧是<strong>sum[LCA(s,t)]+=sum[son[LCA(s,t)]]</strong></p> 
<p>这个时候 <strong>sum[LCA(s,t)]=1</strong> 这就达到了我们要的效果 (是不是特别优秀φ(゜▽゜*)♪)</p> 
<p>但是我们还要思考一个问题:<strong>万一我们再从LCA(s,t)向上回溯的时候使得其父亲节点的子树和为1怎么办?这样我们不就使得其父亲节点被多经过了一次?</strong></p> 
<p>其实很简单，我们只需要在前面差分操作时将<strong>sum[fa[lca(s,t)]]-=x</strong>就行了。</p> 
<p>这样就达到了标记我们路径上的点的要求! 是否有一种恍然大悟的感觉呢?</p> 
<p> <img alt="" height="451" src="https://images2.imgbox.com/2e/06/busUc4fT_o.png" width="448"></p> 
<h3> 2.例题Max flow</h3> 
<h4>问题</h4> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/38/16/exnI2tG7_o.png" width="1200"></p> 
<h4>参考代码</h4> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,q,mx[300001][41],deep[300001],sum[300001],ans;
vector&lt;int&gt; vec[300001];
void dfs(int x,int fa)//lca的初始化
{
  deep[x] = deep[fa] + 1;
  mx[x][0] = fa;
  for(int i = 0;i &lt; vec[x].size();i++)
    if(vec[x][i] != fa)
      dfs(vec[x][i],x);
}
int lca(int x,int y)//倍增法求lca
{
  if(deep[x] &lt; deep[y]) swap(x,y);
  for(int i = 40;i &gt;= 0;i--)
    if(deep[mx[x][i]] &gt;= deep[y])
      x = mx[x][i];
  if(x == y) return x;
  for(int i = 40;i &gt;= 0;i--)
    if(mx[x][i] != mx[y][i])
    {
      x = mx[x][i];
      y = mx[y][i];
	}
  return mx[x][0];
}
void dfss(int x,int fa)//统计答案的最大值
{
  for(int i = 0;i &lt; vec[x].size();i++)
  {
  	int t = vec[x][i];
    if(t == fa) continue;
    dfss(t,x);
    sum[x] += sum[t];//在树上进行类似于前缀和的操作
  }
  ans = max(ans,sum[x]);//取最大值
}
signed main()
{
  cin&gt;&gt;n&gt;&gt;q;
  for(int i = 1;i &lt; n;i++)
  {
  	int u,v;
  	scanf("%d%d",&amp;u,&amp;v);
  	vec[u].push_back(v);
  	vec[v].push_back(u);
  }
  dfs(1,0);
  for(int j = 1;j &lt;= 40;j++)
    for(int i = 1;i &lt;= n;i++)
      mx[i][j] = mx[mx[i][j - 1]][j - 1];
  while(q--)
  {
  	int u,v;
  	cin&gt;&gt;u&gt;&gt;v;
  	int l = lca(u,v);
	sum[u]++;//树上差分
	sum[v]++;
	sum[l]--;
	if(l != 1) sum[mx[l][0]]--;//如果l有父节点就进行后面的操作
  }
  dfss(1,0);
  cout&lt;&lt;ans;
  return 0;
}</code></pre> 
<h2></h2> 
<h2>三.边差分</h2> 
<h3 style="background-color:transparent;">1.思路</h3> 
<p>思想其实和<strong>点差分</strong>是<strong>一样的</strong>，我来讲一下操作。</p> 
<p>设<strong>将两点s,t之间路径上的所有边权增加x</strong>，<strong>l=LCA(s,t)</strong>，<strong>以每条边两端深度较大的节点存储该边的差分数组</strong>，则操作如下：</p> 
<pre><code class="language-cpp">sum[s] += x;
sum[t] += x;
sum[l] -= 2 * x;</code></pre> 
<p>举个栗子(其中假设x=1):</p> 
<p><img alt="" height="532" src="https://images2.imgbox.com/b8/34/7YOFfdBW_o.png" width="602"></p> 
<p>红色边为<strong>需要经过的边,</strong>绿色的数字代表<strong>经过次数</strong>。</p> 
<p>但是由于我们<strong>不能储存边权</strong>，所以只能<strong>把边权塞给了点权</strong>,因此我们的图应该是这样的</p> 
<p> <img alt="" height="479" src="https://images2.imgbox.com/7b/e5/OOsOmMtS_o.png" width="537"></p> 
<p>这样的话我们只要把<strong>sum[s]++,sum[t]++,sum[lca(s,t)]-=2</strong>就可以实现差分操作了。</p> 
<p>同样地，只要<strong>dfs一遍</strong>，遍历时统计<strong>以每个节点为根的树的节点的权值和</strong>，就是当前节点到父亲节点的边的<strong>最终权值</strong>了！</p> 
<p><s> 是不是很厉害</s></p> 
<p>至于为什么点差分和边差分的操作不一样，很简单，请读者自己思考。</p> 
<p>树上差分主要还是学习思想吧！</p> 
<h3>2.例题树上必经边--边差分</h3> 
<h4>问题</h4> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/99/ea/E9xy703i_o.png" width="1200"></p> 
<h4> 参考代码</h4> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,q,mx[300001][41],deep[300001],sum[300001],ans,k;
vector&lt;int&gt; vec[300001];
void dfs(int x,int fa)
{
  deep[x] = deep[fa] + 1;
  mx[x][0] = fa;
  for(int i = 0;i &lt; vec[x].size();i++)
    if(vec[x][i] != fa)
      dfs(vec[x][i],x);
}
int lca(int x,int y)
{
  if(deep[x] &lt; deep[y]) swap(x,y);
  for(int i = 40;i &gt;= 0;i--)
    if(deep[mx[x][i]] &gt;= deep[y])
      x = mx[x][i];
  if(x == y) return x;
  for(int i = 40;i &gt;= 0;i--)
    if(mx[x][i] != mx[y][i])
    {
      x = mx[x][i];
      y = mx[y][i];
	}
  return mx[x][0];
}
void dfss(int x,int fa)
{
  for(int i = 0;i &lt; vec[x].size();i++)
  {
  	int t = vec[x][i];
    if(t == fa) continue;
    dfss(t,x);
    sum[x] += sum[t];
  }
}
signed main()
{
  cin&gt;&gt;n&gt;&gt;q&gt;&gt;k;
  for(int i = 1;i &lt; n;i++)
  {
  	int u,v;
  	scanf("%d%d",&amp;u,&amp;v);
  	vec[u].push_back(v);
  	vec[v].push_back(u);
  }
  dfs(1,0);
    for(int j = 1;j &lt;= 40;j++)
  for(int i = 1;i &lt;= n;i++)
      mx[i][j] = mx[mx[i][j - 1]][j - 1];
  while(q--)
  {
  	int u,v;
  	cin&gt;&gt;u&gt;&gt;v;
  	int l = lca(u,v);
	  sum[u]++;
	  sum[v]++;
	  sum[l] -= 2;
  }
  dfss(1,0);
  for(int i = 2;i &lt;= n;i++)
    if(sum[i] == k)
      ans++;
  cout&lt;&lt;ans;
  return 0;
}</code></pre> 
<h2></h2> 
<h2>四.BB in last </h2> 
<p>如果这篇博客对您有帮助的话，别忘了点赞收藏加关注支持一下吖~(小声BB)(oﾟvﾟ)ノ</p> 
<p><img alt="" height="363" src="https://images2.imgbox.com/0d/51/n8q5eojY_o.png" width="539"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6f5d884dbb9efa966069bf0971b05549/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">HiveSQL题——collect_set()/collect_list()聚合函数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e037395ddaec01c259911c5666c4e780/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mongodb数据库集合（表）的创建和数据修改</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>