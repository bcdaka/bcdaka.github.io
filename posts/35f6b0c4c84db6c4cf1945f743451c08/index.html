<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java的MVC架构中，controller层、service层、serviceImpl和mapper层的作用 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/35f6b0c4c84db6c4cf1945f743451c08/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java的MVC架构中，controller层、service层、serviceImpl和mapper层的作用">
  <meta property="og:description" content="1.controller层 也被称为控制器，它是业务模块流程的控制中心。Controller负责接收页面传递过来的参数，然后将这些参数传给service进行处理。同时，controller还会接收service处理后的返回值，并将这些返回值再次传给页面。此外，controller还负责处理前端请求和响应，与前端进行交互，为前端提供接口。
@RestController @RequestMapping(&#34;/user&#34;) @Slf4j public class UserController { @Autowired private UserService userService; /** * 移动端用户登录 * @param map * @param session * @return */ @PostMapping(&#34;/login&#34;) public R&lt;User&gt; login(@RequestBody Map map, HttpSession session) { //获取用户手机号 String phone = map.get(&#34;phone&#34;).toString(); //获取验证码 String code = map.get(&#34;code&#34;).toString(); //获取session的验证码； Object sessionInCode = session.getAttribute(phone); if(sessionInCode != null &amp;&amp; sessionInCode.equals(code)) { //判断是不是新用户 LambdaQueryWrapper&lt;User&gt; userLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;(); userLambdaQueryWrapper.eq(User::getPhone,phone); User user = userService.getOne(userLambdaQueryWrapper); if(user == null) { //说明是新用户 user = new User(); user.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-01-06T17:48:32+08:00">
    <meta property="article:modified_time" content="2024-01-06T17:48:32+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java的MVC架构中，controller层、service层、serviceImpl和mapper层的作用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h5>1.controller层</h5> 
<p>        也被称为控制器，它是业务模块流程的控制中心。Controller负责<span style="color:#be191c;">接收页面传递过来的参数</span>，然后将这些<span style="color:#be191c;">参数传给service</span>进行处理。同时，controller还会<span style="color:#be191c;">接收service处理后的返回值</span>，并将这些<span style="color:#be191c;">返回值再次传给页面</span>。此外，controller还负责处理前端请求和响应，与前端进行交互，<span style="color:#be191c;">为前端提供接口</span>。</p> 
<pre><code class="language-java">@RestController
@RequestMapping("/user")
@Slf4j
public class UserController {
    @Autowired
    private UserService userService;
  
    /**
     * 移动端用户登录
     * @param map
     * @param session
     * @return
     */
    @PostMapping("/login")
    public R&lt;User&gt; login(@RequestBody Map map, HttpSession session) {
        //获取用户手机号
        String phone = map.get("phone").toString();
        //获取验证码
        String code = map.get("code").toString();
        //获取session的验证码；
        Object sessionInCode = session.getAttribute(phone);
        if(sessionInCode != null &amp;&amp; sessionInCode.equals(code)) {
            //判断是不是新用户
            LambdaQueryWrapper&lt;User&gt; userLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();
            userLambdaQueryWrapper.eq(User::getPhone,phone);
            User user = userService.getOne(userLambdaQueryWrapper);
            if(user == null) {
                //说明是新用户
                user = new User();
                user.setPhone(phone);
                user.setStatus(1);
                userService.save(user);
            }
            session.setAttribute("user",user.getId());
            return R.success(user);
        }
        return R.error("登录失败");
    }

}</code></pre> 
<h5>2.service层</h5> 
<p>        Service层是业务逻辑的处理层，它是一个接口类，负责<span style="color:#be191c;">处理业务逻辑的设计</span>。它相对独立于其他层，只负责定义业务逻辑的接口。</p> 
<pre><code class="language-java">@Service
public interface UserService extends IService&lt;User&gt; {
}</code></pre> 
<h5>3.serviceImpl</h5> 
<p>        ServiceImpl层是对Service接口的实现层，它<span style="color:#be191c;">调用Mapper层进行数据访问</span>，完成<span style="color:#be191c;">具体的业务逻辑处理</span>。</p> 
<pre><code class="language-java">@Service
public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService {
}
</code></pre> 
<h5>4.mapper层</h5> 
<p>        Mapper层也被称为DAO层，它是数据访问层。Mapper层的主要职责是封装对数据库的增删改查等底层操作。某个DAO一定是和数据库的某一张表一一对应的。</p> 
<pre><code class="language-java">@Mapper
public interface UserMapper extends BaseMapper&lt;User&gt; {
}</code></pre> 
<h5>5.几个层次之间的关系</h5> 
<p>        在这四个层次之间，存在着紧密的联系。当用户发起请求时，请求首先会到达Controller层。接着，Controller层会解析请求，并调用相应的Service层方法。Service层会处理业务逻辑，这可能会涉及到对数据库的操作，因此它会调用Mapper层进行数据访问。最后，Mapper层会执行SQL语句，与数据库进行交互，并将结果返回给Service层。</p> 
<h5>6.存在的疑问</h5> 
<h6>（1）为什么Controller层调用的是service接口，而不是其实现类？</h6> 
<p>        在Java的MVC架构中，通常Controller层注入的是服务层的接口，而不是实现类。这样做的原因主要是为了实现面向接口编程和依赖注入，有助于降低各层之间的耦合性，提高代码的灵活性和可维护性。例如，如果Service接口有多个ServiceImpl实现类，就可以通过指定参数名来选择需要调用的具体ServiceImpl实现类。此外，使用接口类型来引用对象是Java编程的一种良好实践，它符合“针对接口编程，而不是针对实现编程”的设计原则。</p> 
<h6>（2）Controller层调用的是service接口，为什么能使用其实现类的方法?</h6> 
<p>        在Spring MVC框架中，这种能实现调用Service层接口方法的能力，是通过依赖注入（Dependency Injection）实现的。在Controller层中，我们可以通过依赖注入将需要的Service接口或类注入进来，进而在Controller层中调用Service层的方法来处理业务逻辑。</p> 
<p>具体来说，当我们在Controller层定义一个变量并使用@Autowired注解它时，Spring框架会自动为我们生成这个类的实例，并将该实例注入到我们定义的变量中。在这个过程中，如果这个类的成员变量或者方法上的参数是另一个类的实例，那么Spring框架会自动将这个实例也注入进来。</p> 
<p>例如，假设我们有一个Service层的接口名为UserService，以及它的两个实现类AdminUserServiceImpl和NormalUserServiceImpl。我们在Controller层定义了一个名为userService的变量，并使用@Autowired注解它</p> 
<pre><code class="language-java">@Controller
public class UserController {
    @Autowired
    private UserService userService;
}</code></pre> 
<p>     在这个例子中，当Spring框架创建UserController类的一个实例时，它会自动将UserService接口的实现类注入到userService变量中。因此，我们实际上可以在Controller层调用Service层接口的方法了。</p> 
<h6>   (3）若这个接口有多个实现类，那是怎么确定你注入的是哪个实现类？</h6> 
<p>        在Spring框架中，我们可以通过使用<code>@Qualifier</code>注解来指定注入的实现类。</p> 
<p>例如，假设我们有一个名为<code>UserService</code>的接口，它有两个实现类：<code>AdminUserServiceImpl</code>和<code>NormalUserServiceImpl</code>。我们可以在controller层使用<code>@Autowired</code>注解来注入这个接口，并使用<code>@Qualifier</code>注解来指定注入的具体实现类。</p> 
<pre><code class="language-java">Controller
public class UserController {
    @Autowired
    @Qualifier("adminUserService")
    private UserService userService;
}</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/32b24f6d676bdffbcf174963ce9837e7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Paragon NTFS for Mac 破解版 15.5 Mac读写NTFS硬盘必备软件（附激活序列号）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f9b6bf571ac6159d153f444d313854ea/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Copilot在PyCharm中可能遇到的问题及其解决方案</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>