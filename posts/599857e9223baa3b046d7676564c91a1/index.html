<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【人工智能】-- 受限玻尔兹曼机 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/599857e9223baa3b046d7676564c91a1/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【人工智能】-- 受限玻尔兹曼机">
  <meta property="og:description" content="个人主页：欢迎来到 Papicatch的博客
课设专栏 ：学生成绩管理系统
专业知识专栏： 专业知识 文章目录
🍉引言
🍉受限玻尔兹曼机
🍈RBM的结构
🍍RBM的架构图
🍍RBM的经典实现
🍍代码实现
🍍代码分析
🍉总结
🍉引言 在当今科技飞速发展的时代，人工智能的研究不断取得突破性的进展。其中，受限玻尔兹曼机作为一种重要的模型，正逐渐引起人们的广泛关注。它独特的结构和强大的学习能力，为解决各种复杂的问题提供了新的思路和方法。受限玻尔兹曼机不仅在理论研究上具有深刻的意义，在实际应用中也展现出了巨大的潜力，例如图像识别、语音处理、自然语言处理等领域。
🍉受限玻尔兹曼机 受限玻尔兹曼机（Restricted Boltzmann Machine，RBM）是一种生成性随机人工神经网络，也是一种无向概率图模型，并且受限为二分图。
整个模型有两层，即可见层（包含可见单元）和隐藏层（包含隐单元），满足层内无连接，层间全连接。这种限制使得它在神经元之间的连接上有特定的规则，来自两组单元中的每一组的一对节点（通常称为“可见”和“隐藏”单元）可以在它们之间具有对称连接，而组内的节点之间没有连接。相比一般的玻尔兹曼机，这种限制允许使用更有效的训练算法。
RBM 通常由二值隐单元和可见单元组成，其中权重矩阵 中的每个元素指定了隐单元 和可见层单元 之间边的权重。
此外，对于每个可见层单元 有偏置项 ，对每个隐层单元 有偏置项 。具体来说，需满足以下条件
其能量函数对于一组给定的状态 定义为：
由能量函数可以给出状态 的联合概率分布：
其中， 是归一化常数，计算式为 ，其计算复杂度为 。可见层的边缘分布: ;隐藏层的边缘分布: 。
RBM 的一个重要性质是，由于它是一个二分图，层内没有边相连，因而隐藏层的激活状态在给定可见层节点取值的情况下是条件独立的，类似地，可见层节点的激活状态在给定隐藏层节点取值的情况下也条件独立，用数学公式表示为：
由此可以推导得出在给定可视层 的基础上，隐层第 个节点为 1 或者为 0 的概率为：
在给定隐层 的基础上，可视层第 个节点为 1 或者为 0 的概率为：
在训练 RBM 时，关键是计算模型中的参数 。通常采用对数损失函数，并考虑最大化对数似然函数。但直接按梯度公式计算梯度的复杂度很高，因为其中涉及到归一化常数 的计算，而 的计算复杂度为 。
为解决这个问题，一般使用基于马尔可夫链蒙特卡罗（MCMC）的方法来模拟计算梯度，如 Geoffrey Hinton 提出的对比散度（contrastive divergence，CD）算法。该算法给定样本 后，取初始值 ，然后执行 步 Gibbs 采样，先后采样得到 和 。Gibbs 采样得到的样本服从联合分布 ，利用采样得到的 可以估算梯度公式中期望项的近似值，从而得到梯度的近似值，之后在每一步利用梯度上升法进行参数更新。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-12T23:25:13+08:00">
    <meta property="article:modified_time" content="2024-07-12T23:25:13+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【人工智能】-- 受限玻尔兹曼机</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="2a20c54b85e042bfa2440367ae4807e9.gif" height="53" src="https://images2.imgbox.com/72/54/f5LcfjJm_o.gif" width="1000"></p> 
<p style="text-align:center;"><img alt="https://blog.csdn.net/2302_76516899?spm=1000.2115.3001.5343" height="1000" src="https://images2.imgbox.com/e3/4f/hSmR7vzA_o.jpg" width="1000"></p> 
<p style="text-align:center;"><span style="color:#ffd900;"><strong>个人主页：</strong></span><strong><a class="link-info" href="https://blog.csdn.net/2302_76516899?spm=1000.2115.3001.5343" title="欢迎来到 Papicatch的博客">欢迎来到 Papicatch的博客</a></strong></p> 
<p style="text-align:center;"><span style="color:#a2e043;"><strong> 课设专栏 ：</strong></span><strong><a href="https://blog.csdn.net/2302_76516899/category_12701462.html?spm=1001.2014.3001.5482" title="学生成绩管理系统">学生成绩管理系统</a></strong></p> 
<p style="text-align:center;"><span style="color:#956fe7;"><strong>专业知识专栏： </strong></span><strong><a href="https://blog.csdn.net/2302_76516899/category_12677356.html" title="专业知识">专业知识</a></strong> </p> 
<p><img alt="" height="53" src="https://images2.imgbox.com/21/68/RhDueVyn_o.gif" width="1000"></p> 
<p id="main-toc"><strong>文章目录</strong></p> 
<p id="%F0%9F%8D%89%E5%BC%95%E8%A8%80-toc" style="margin-left:0px;"><a href="#%F0%9F%8D%89%E5%BC%95%E8%A8%80" rel="nofollow">🍉引言</a></p> 
<p id="%F0%9F%8D%89%E5%8F%97%E9%99%90%E7%8E%BB%E5%B0%94%E5%85%B9%E6%9B%BC%E6%9C%BA-toc" style="margin-left:0px;"><a href="#%F0%9F%8D%89%E5%8F%97%E9%99%90%E7%8E%BB%E5%B0%94%E5%85%B9%E6%9B%BC%E6%9C%BA" rel="nofollow">🍉受限玻尔兹曼机</a></p> 
<p id="%F0%9F%8D%88RBM%E7%9A%84%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#%F0%9F%8D%88RBM%E7%9A%84%E7%BB%93%E6%9E%84" rel="nofollow">🍈RBM的结构</a></p> 
<p id="%F0%9F%8D%8DRBM%E7%9A%84%E6%9E%B6%E6%9E%84%E5%9B%BE-toc" style="margin-left:80px;"><a href="#%F0%9F%8D%8DRBM%E7%9A%84%E6%9E%B6%E6%9E%84%E5%9B%BE" rel="nofollow">🍍RBM的架构图</a></p> 
<p id="%F0%9F%8D%8DRBM%E7%9A%84%E7%BB%8F%E5%85%B8%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#%F0%9F%8D%8DRBM%E7%9A%84%E7%BB%8F%E5%85%B8%E5%AE%9E%E7%8E%B0" rel="nofollow">🍍RBM的经典实现</a></p> 
<p id="%F0%9F%8D%8D%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#%F0%9F%8D%8D%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">🍍代码实现</a></p> 
<p id="%F0%9F%8D%8D%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#%F0%9F%8D%8D%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90" rel="nofollow">🍍代码分析</a></p> 
<p id="%F0%9F%8D%89%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%F0%9F%8D%89%E6%80%BB%E7%BB%93" rel="nofollow">🍉总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p><img alt="2a20c54b85e042bfa2440367ae4807e9.gif" height="53" src="https://images2.imgbox.com/e6/c1/a18tlVfh_o.gif" width="1000"></p> 
<h2 id="%F0%9F%8D%89%E5%BC%95%E8%A8%80">🍉引言</h2> 
<p>        在当今科技飞速发展的时代，人工智能的研究不断取得突破性的进展。其中，受限玻尔兹曼机作为一种重要的模型，正逐渐引起人们的广泛关注。它独特的结构和强大的学习能力，为解决各种复杂的问题提供了新的思路和方法。受限玻尔兹曼机不仅在理论研究上具有深刻的意义，在实际应用中也展现出了巨大的潜力，例如图像识别、语音处理、自然语言处理等领域。</p> 
<h2 id="%F0%9F%8D%89%E5%8F%97%E9%99%90%E7%8E%BB%E5%B0%94%E5%85%B9%E6%9B%BC%E6%9C%BA">🍉受限玻尔兹曼机</h2> 
<p>        受限玻尔兹曼机（Restricted Boltzmann Machine，RBM）是一种生成性随机人工神经网络，也是一种无向概率图模型，并且受限为二分图。</p> 
<p>        整个模型有两层，即可见层（包含可见单元）和隐藏层（包含隐单元），满足层内无连接，层间全连接。这种限制使得它在神经元之间的连接上有特定的规则，来自两组单元中的每一组的一对节点（通常称为“可见”和“隐藏”单元）可以在它们之间具有对称连接，而组内的节点之间没有连接。相比一般的玻尔兹曼机，这种限制允许使用更有效的训练算法。</p> 
<p>RBM 通常由二值隐单元和可见单元组成，其中权重矩阵 <img alt="W=\left (w_{ij} \right )" class="mathcode" src="https://images2.imgbox.com/c6/5e/YPS69VLL_o.png"> 中的每个元素指定了隐单元 <img alt="h_{i}" class="mathcode" src="https://images2.imgbox.com/01/6e/UrkdbjMy_o.png"> 和可见层单元 <img alt="v_{j}" class="mathcode" src="https://images2.imgbox.com/bc/14/pxfgz529_o.png"> 之间边的权重。</p> 
<p>        此外，对于每个可见层单元 <img alt="v_{i}" class="mathcode" src="https://images2.imgbox.com/98/43/u7WtKZWv_o.png"> 有偏置项 <img alt="a_{i}" class="mathcode" src="https://images2.imgbox.com/40/07/H3MhR6d0_o.png">，对每个隐层单元 <img alt="h_{j}" class="mathcode" src="https://images2.imgbox.com/c3/ba/L07KY5X5_o.png"> 有偏置项 <img alt="b_{j}" class="mathcode" src="https://images2.imgbox.com/e1/28/OL7y46m6_o.png">。具体来说，需满足以下条件</p> 
<p class="img-center"><img alt="" height="90" src="https://images2.imgbox.com/2a/41/FR4ccDo9_o.png" width="779"></p> 
<p>其能量函数对于一组给定的状态 <img alt="\left ( v,h \right )" class="mathcode" src="https://images2.imgbox.com/ee/b0/rHlZtLHH_o.png"> 定义为：</p> 
<p class="img-center"><img alt="" height="162" src="https://images2.imgbox.com/29/be/gjpWBaJ9_o.png" width="836"></p> 
<p>由能量函数可以给出状态 <img alt="\left ( v,h \right )" class="mathcode" src="https://images2.imgbox.com/2d/c9/aF2vkWco_o.png"> 的联合概率分布：</p> 
<p class="img-center"><img alt="" height="150" src="https://images2.imgbox.com/1f/fb/mVpcNbSs_o.png" width="267"></p> 
<p>其中，<img alt="Z" class="mathcode" src="https://images2.imgbox.com/69/e6/A3B7yff2_o.png"> 是归一化常数，计算式为 <img alt="Z=\sum_{v,h}e^{-E\left ( v,h \right )}" class="mathcode" src="https://images2.imgbox.com/7a/de/rjk2ZKkO_o.png">，其计算复杂度为 <img alt="O(2^{p+q})" class="mathcode" src="https://images2.imgbox.com/7c/f1/gG5azmmC_o.png">。可见层的边缘分布: <img alt="P\left ( v \right )=\sum_{h}^{}P\left ( v,h \right )" class="mathcode" src="https://images2.imgbox.com/35/45/dpyLOmIS_o.png"> ;隐藏层的边缘分布: <img alt="P\left ( h \right )=\sum_{v}^{}P\left ( v,h \right )" class="mathcode" src="https://images2.imgbox.com/ce/64/W09ylfJc_o.png"> 。</p> 
<p>        RBM 的一个重要性质是，由于它是一个二分图，层内没有边相连，因而隐藏层的激活状态在给定可见层节点取值的情况下是条件独立的，类似地，可见层节点的激活状态在给定隐藏层节点取值的情况下也条件独立，用数学公式表示为：</p> 
<p class="img-center"><img alt="" height="237" src="https://images2.imgbox.com/29/8e/akedYVmX_o.png" width="272"></p> 
<p>由此可以推导得出在给定可视层 <img alt="v" class="mathcode" src="https://images2.imgbox.com/1f/91/CMkuViaA_o.png"> 的基础上，隐层第 <img alt="j" class="mathcode" src="https://images2.imgbox.com/19/6d/CJvFBwYn_o.png"> 个节点为 1 或者为 0 的概率为：</p> 
<p class="img-center"><img alt="" height="138" src="https://images2.imgbox.com/ad/31/JIbv1U3N_o.png" width="465"></p> 
<p>在给定隐层 <img alt="h" class="mathcode" src="https://images2.imgbox.com/ae/cb/Sp88BhNN_o.png"> 的基础上，可视层第 <img alt="i" class="mathcode" src="https://images2.imgbox.com/cd/85/Gzca04LJ_o.png"> 个节点为 1 或者为 0 的概率为：</p> 
<p class="img-center"><img alt="" height="131" src="https://images2.imgbox.com/39/e6/nuVVNmbi_o.png" width="471"></p> 
<p>        在训练 RBM 时，关键是计算模型中的参数 <img alt="\theta =\left ( W,a,b \right )" class="mathcode" src="https://images2.imgbox.com/47/6a/dSNqXgkB_o.png"> 。通常采用对数损失函数，并考虑最大化对数似然函数。但直接按梯度公式计算梯度的复杂度很高，因为其中涉及到归一化常数 <img alt="Z" class="mathcode" src="https://images2.imgbox.com/4b/fd/yaVujxPI_o.png"> 的计算，而 <img alt="Z" class="mathcode" src="https://images2.imgbox.com/d8/30/fmwazRkD_o.png"> 的计算复杂度为 <img alt="O(2^{p+q})" class="mathcode" src="https://images2.imgbox.com/f0/b4/mlzWYCny_o.png"> 。</p> 
<p>        为解决这个问题，一般使用基于马尔可夫链蒙特卡罗（MCMC）的方法来模拟计算梯度，如 Geoffrey Hinton 提出的对比散度（contrastive divergence，CD）算法。该算法给定样本 <img alt="x" class="mathcode" src="https://images2.imgbox.com/f5/16/UXbkY418_o.png"> 后，取初始值 <img alt="v^{\left ( 0 \right )}:=x" class="mathcode" src="https://images2.imgbox.com/94/16/55dOqfuo_o.png"> ，然后执行 <img alt="k" class="mathcode" src="https://images2.imgbox.com/10/fd/H0cH2IIL_o.png"> 步 Gibbs 采样，先后采样得到 <img alt="h^{(t-1)}" class="mathcode" src="https://images2.imgbox.com/1e/26/wsrLRU3N_o.png"> 和 <img alt="v^{(t)}" class="mathcode" src="https://images2.imgbox.com/76/61/8QWGi970_o.png"> 。Gibbs 采样得到的样本服从联合分布 <img alt="p(v,h)" class="mathcode" src="https://images2.imgbox.com/3c/db/zan693Gu_o.png"> ，利用采样得到的 <img alt="v^{(k)}" class="mathcode" src="https://images2.imgbox.com/d8/82/uKIBkMR3_o.png"> 可以估算梯度公式中期望项的近似值，从而得到梯度的近似值，之后在每一步利用梯度上升法进行参数更新。</p> 
<p>        RBM 可用于降维、分类、协同过滤、特征学习、生成模型等任务。根据任务的不同，它可以使用监督学习或无监督学习的方法进行训练。例如在推荐系统中，可以把每个用户对各个物品的评分作为可见层神经元的输入，从而进行训练。</p> 
<p>        RBM 在深度学习中有重要应用，它可以通过“堆叠”形成深层信念网络等更复杂的结构。但 RBM 也存在一些局限性，例如在处理大规模数据时可能效率不高，对初始值敏感等。不过，研究人员仍在不断探索和改进 RBM 及其相关算法，以拓展其应用领域和提高性能。</p> 
<h3 id="%F0%9F%8D%88RBM%E7%9A%84%E7%BB%93%E6%9E%84">🍈RBM的结构</h3> 
<h4 id="%F0%9F%8D%8DRBM%E7%9A%84%E6%9E%B6%E6%9E%84%E5%9B%BE">🍍RBM的架构图</h4> 
<p class="img-center"><img alt="" height="319" src="https://images2.imgbox.com/ac/e4/SjmM8k7e_o.png" width="339"></p> 
<h4 id="%F0%9F%8D%8DRBM%E7%9A%84%E7%BB%8F%E5%85%B8%E5%AE%9E%E7%8E%B0">🍍RBM的经典实现</h4> 
<p class="img-center"><img alt="" height="300" src="https://images2.imgbox.com/0b/e9/Iil3mpFf_o.png" width="414"></p> 
<h4 id="%F0%9F%8D%8D%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">🍍代码实现</h4> 
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from sklearn import preprocessing
from sklearn.datasets import fetch_openml
from sklearn.model_selection import train_test_split

# 加载 MNIST 数据集
mnist = fetch_openml('mnist_784', version=1, cache=True)
X = mnist.data
y = mnist.target

# 数据预处理
X = preprocessing.MinMaxScaler().fit_transform(X)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

class RBM:
    def __init__(self, n_visible, n_hidden, learning_rate=0.1, n_epochs=100):
        """
        初始化 RBM 模型

        参数：
        n_visible：可见层神经元数量（输入数据的维度）
        n_hidden：隐藏层神经元数量
        learning_rate：学习率
        n_epochs：训练轮数
        """
        self.n_visible = n_visible
        self.n_hidden = n_hidden
        self.learning_rate = learning_rate
        self.n_epochs = n_epochs

        # 随机初始化权重矩阵 W，偏置向量 bv（可见层）和 bh（隐藏层）
        self.W = np.random.randn(n_visible, n_hidden) * 0.1
        self.bv = np.zeros(n_visible)
        self.bh = np.zeros(n_hidden)

    def sigmoid(self, x):
        """
        Sigmoid 激活函数

        参数：
        x：输入值

        返回：
        Sigmoid 函数的输出
        """
        return 1 / (1 + np.exp(-x))

    def sample_hidden(self, v):
        """
        根据给定的可见层状态 v 采样隐藏层

        参数：
        v：可见层状态

        返回：
        隐藏层的激活概率 p_hidden 和采样后的隐藏层状态 h
        """
        hidden_activation = np.dot(v, self.W) + self.bh
        p_hidden = self.sigmoid(hidden_activation)
        return p_hidden, np.random.binomial(1, p_hidden)

    def sample_visible(self, h):
        """
        根据给定的隐藏层状态 h 采样可见层

        参数：
        h：隐藏层状态

        返回：
        可见层的激活概率 p_visible 和采样后的可见层状态 v_prime
        """
        visible_activation = np.dot(h, self.W.T) + self.bv
        p_visible = self.sigmoid(visible_activation)
        return p_visible, np.random.binomial(1, p_visible)

    def train(self, X):
        """
        训练 RBM 模型

        参数：
        X：训练数据
        """
        for epoch in range(self.n_epochs):
            for v in X:
                # 正向传播：根据输入的可见层状态 v 计算隐藏层的激活概率和采样后的隐藏层状态
                p_hidden, h = self.sample_hidden(v)

                # 反向传播：根据采样得到的隐藏层状态 h 计算可见层的激活概率和采样后的可见层状态 v_prime
                p_visible, v_prime = self.sample_visible(h)

                # 更新参数
                # 计算权重更新量 dW
                dW = np.outer(v, p_hidden) - np.outer(v_prime, p_hidden)
                # 更新权重 W
                self.W += self.learning_rate * dW
                # 更新可见层偏置 bv
                self.bv += self.learning_rate * (v - v_prime)
                # 更新隐藏层偏置 bh
                self.bh += self.learning_rate * (p_hidden - np.mean(p_hidden))

    def reconstruct(self, X):
        """
        对输入数据进行重建

        参数：
        X：输入数据

        返回：
        重建后的可见层状态
        """
        h = np.zeros((X.shape[0], self.n_hidden))
        for i, v in enumerate(X):
            _, h[i] = self.sample_hidden(v)
        _, v_prime = self.sample_visible(h)
        return v_prime

# 初始化 RBM 模型，设置可见层神经元数量为 784（MNIST 图像的维度），隐藏层神经元数量为 128
rbm = RBM(n_visible=784, n_hidden=128, learning_rate=0.1, n_epochs=50)

# 训练模型
rbm.train(X_train)

# 重建测试集图像
reconstructed_images = rbm.reconstruct(X_test)

# 展示原始图像和重建图像
n_images = 5
for i in range(n_images):
    original_image = X_test[i].reshape(28, 28)
    reconstructed_image = reconstructed_images[i].reshape(28, 28)

    plt.subplot(2, n_images, i + 1)
    plt.imshow(original_image, cmap='gray')
    plt.axis('off')

    plt.subplot(2, n_images, i + 1 + n_images)
    plt.imshow(reconstructed_image, cmap='gray')
    plt.axis('off')

plt.show()</code></pre> 
<h4 id="%F0%9F%8D%8D%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90">🍍代码分析</h4> 
<p><strong><code>RBM</code> 类的 <code>__init__</code> 方法</strong>：</p> 
<blockquote> 
 <ul><li>初始化模型的参数，包括可见层和隐藏层的神经元数量、学习率和训练轮数。</li><li>随机初始化权重矩阵 <code>W</code> 、可见层偏置 <code>bv</code> 和隐藏层偏置 <code>bh</code> 。</li></ul> 
</blockquote> 
<p><strong><code>sigmoid</code> 方法：定义了 Sigmoid 激活函数，用于计算神经元的激活概率。</strong></p> 
<p><strong><code>sample_hidden</code> 方法：</strong></p> 
<blockquote> 
 <ul><li>计算给定可见层状态下隐藏层的激活值。</li><li>通过激活值计算隐藏层的激活概率。</li><li>基于激活概率进行二项分布采样得到隐藏层的状态。</li></ul> 
</blockquote> 
<p><strong><code>sample_visible</code> 方法：与 <code>sample_hidden</code> 类似，用于根据隐藏层状态采样可见层状态。</strong></p> 
<p><strong><code>train</code> 方法：</strong></p> 
<blockquote> 
 <ul><li>在每一轮训练中，遍历训练数据中的每个样本。</li><li>进行正向传播，从可见层到隐藏层的采样。</li><li>进行反向传播，从隐藏层到可见层的采样。</li><li>根据采样结果计算权重和偏置的更新量，并进行更新。</li></ul> 
</blockquote> 
<p><strong><code>reconstruct</code> 方法：</strong></p> 
<blockquote> 
 <ul><li>首先对输入数据采样得到隐藏层状态。</li><li>然后根据隐藏层状态采样重建可见层状态。</li></ul> 
</blockquote> 
<p>在主程序中：</p> 
<blockquote> 
 <ul><li>加载 MNIST 数据集并进行预处理和划分。</li><li>初始化 RBM 模型并进行训练。</li><li>对测试集数据进行重建，并展示原始图像和重建图像的对比。</li></ul> 
</blockquote> 
<p>        这段代码主要实现了一个受限玻尔兹曼机（RBM）模型，并将其应用于 MNIST 数据集的图像重建任务。</p> 
<p>        首先，代码从开放数据集中加载 MNIST 数据，进行预处理和划分。然后定义了 <code>RBM</code> 类，在类的初始化方法中，设定了模型的关键参数，包括可见层和隐藏层的神经元数量、学习率以及训练轮数，并随机初始化了权重和偏置。</p> 
<p><code>   RBM</code> 类中包含了 <code>sigmoid</code> 激活函数，以及用于正向和反向传播的 <code>sample_hidden</code> 和 <code>sample_visible</code> 方法。训练方法 <code>train</code> 通过不断的正向和反向传播，并基于采样结果更新权重和偏置来优化模型。<code>reconstruct</code> 方法用于对输入数据进行重建。</p> 
<p>        在主程序中，初始化并训练 RBM 模型，最后对测试集数据进行重建，并通过图像展示原始图像和重建图像的对比，以直观评估模型的重建效果。</p> 
<h2 id="%F0%9F%8D%89%E6%80%BB%E7%BB%93">🍉总结</h2> 
<p>        受限玻尔兹曼机（RBM）是一种具有独特结构和强大学习能力的概率图模型。</p> 
<p>        在结构上，RBM 由两层神经元组成，即可见层和隐藏层。层内神经元无连接，层间神经元全连接。这种结构简化了计算，同时也使得模型能够有效地学习数据中的特征和模式。</p> 
<p>        在学习过程中，RBM 通过不断调整参数（包括权重、可见层偏置和隐藏层偏置）来优化模型。常见的学习算法如对比散度（CD）算法，通过采样和近似计算梯度来更新参数。</p> 
<p>        RBM 具有多种应用，例如在数据降维方面，它能够将高维数据映射到低维的隐藏层表示；在特征学习中，能够自动从原始数据中提取有意义的特征；在生成模型中，可以生成新的数据样本。</p> 
<p>        然而，RBM 也存在一些局限性。例如，训练时间可能较长，尤其是在处理大规模数据时；对初始参数的设置较为敏感；模型的解释性相对较复杂等。</p> 
<p>        尽管如此，RBM 在深度学习领域仍然具有重要地位，其思想和方法为后续更复杂的深度模型的发展提供了基础和启发。</p> 
<p><img alt="2a20c54b85e042bfa2440367ae4807e9.gif" height="53" src="https://images2.imgbox.com/8f/de/dg1LZwp6_o.gif" width="1000"></p> 
<p><img alt="" src="https://images2.imgbox.com/03/90/hdWbSLg8_o.png"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ebce29f665ec098035981b135f1fc591/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据结构：链表详解 (c&#43;&#43;实现)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4e28403739593660eb3c9d93591d4224/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据结构【顺序表】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>