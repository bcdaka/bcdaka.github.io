<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构之栈 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/f5f0215783e7785916531243560f03c6/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构之栈">
  <meta property="og:description" content="栈 首先宏观上是在干什么？ 概念 栈：⼀种特殊的线性表，其只允许在固定的⼀端进⾏插⼊和删除元素操作。进⾏数据插⼊和删除操作 的⼀端称为栈顶，另⼀端称为栈底。栈中的数据元素遵守后进先出LIFO（Last In First Out）的原则。
压栈：栈的插⼊操作叫做进栈/压栈/⼊栈，⼊数据在栈顶。
出栈：栈的删除操作叫做出栈。出数据也在栈顶。
栈底层结构选型
核心原则：后来者居上
其次有哪些假设？ 栈的实现可以用哪个数据结构实现？ 栈的实现⼀般可以使⽤数组或者链表实现，相对⽽⾔数组的结构实现更优⼀些。因为数组在尾上插⼊ 数据的代价⽐较⼩。
栈的实现 入栈 代码如下：
// ⼊栈 void STPush(ST* ps, STDataType x) { assert(ps); //1.判断空间是否足够 if (ps-&gt;capacity == ps-&gt;top) { int newCapacity = ps-&gt;capacity == 0 ? 4 : 2 * ps-&gt;capacity; STDataType* tmp = (STDataType*)realloc(ps-&gt;arr, newCapacity * sizeof(STDataType)); if (tmp == NULL) { perror(&#34;realloc fail!&#34;); exit(1); } ps-&gt;arr = tmp; ps-&gt;capacity = newCapacity; } //空间足够 ps-&gt;arr[ps-&gt;top&#43;&#43;] = x; } 和写顺序表进行插入数据的操作非常的相似">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-22T19:51:10+08:00">
    <meta property="article:modified_time" content="2024-07-22T19:51:10+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构之栈</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>栈</h2> 
<h3><a id="_2"></a>首先宏观上是在干什么？</h3> 
<h4><a id="_4"></a>概念</h4> 
<p>栈：⼀种特殊的<mark>线性表</mark>，<strong>其只允许在固定的⼀端进⾏插⼊和删除元素操作</strong>。进⾏数据插⼊和删除操作 的⼀端称为栈顶，另⼀端称为栈底。栈中的数据元素遵守后进先出LIFO（Last In First Out）的原则。</p> 
<p><strong>压栈</strong>：栈的插⼊操作叫做进栈/压栈/⼊栈，⼊数据在栈顶。</p> 
<p><strong>出栈</strong>：栈的删除操作叫做出栈。<strong>出数据也在栈顶。</strong></p> 
<p><img src="https://images2.imgbox.com/33/6c/ykitKmek_o.png" alt="在这里插入图片描述"></p> 
<p>栈底层结构选型</p> 
<p><strong>核心原则</strong>：<mark>后来者居上</mark></p> 
<h3><a id="_19"></a>其次有哪些假设？</h3> 
<h4><a id="_21"></a>栈的实现可以用哪个数据结构实现？</h4> 
<p>栈的实现⼀般可以使⽤数组或者链表实现，相对⽽⾔数组的结构实现更优⼀些。因为数组在尾上插⼊ 数据的代价⽐较⼩。</p> 
<p><img src="https://images2.imgbox.com/44/32/WEpKKHYQ_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_28"></a>栈的实现</h4> 
<h5><a id="_30"></a>入栈</h5> 
<p><img src="https://images2.imgbox.com/9a/85/t3QSTgZY_o.png" alt="在这里插入图片描述"></p> 
<p>代码如下：</p> 
<pre><code class="prism language-C">// ⼊栈
void STPush(ST* ps, STDataType x)
{
	assert(ps);
	//1.判断空间是否足够
	if (ps-&gt;capacity == ps-&gt;top)
	{
		int newCapacity = ps-&gt;capacity == 0 ? 4 : 2 * ps-&gt;capacity;
		STDataType* tmp = (STDataType*)realloc(ps-&gt;arr, newCapacity * sizeof(STDataType));
		if (tmp == NULL)
		{
			perror("realloc fail!");
			exit(1);
		}
		ps-&gt;arr = tmp;
		ps-&gt;capacity = newCapacity;
	}
	//空间足够
	ps-&gt;arr[ps-&gt;top++] = x;
}
</code></pre> 
<p>和写<strong>顺序表</strong>进行插入数据的操作非常的相似</p> 
<h5><a id="_62"></a>出栈</h5> 
<p><img src="https://images2.imgbox.com/90/dc/8bwLK6nN_o.png" alt="在这里插入图片描述"></p> 
<p><mark>如果栈为空，不可以出数据</mark>，所以要先判断栈是否为空</p> 
<p>代码如下：</p> 
<pre><code class="prism language-c"><span class="token operator">/</span>判断栈是否为空
bool <span class="token function">StackEmpty</span><span class="token punctuation">(</span>ST<span class="token operator">*</span> ps<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>ps<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> ps<span class="token operator">-&gt;</span>top <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>根据栈的性质，我们可以返回栈顶的方式来判断</p> 
<pre><code class="prism language-C">//出栈
void STPop(ST* ps)
{
	assert(ps);
	assert(!StackEmpty(ps));
	--ps-&gt;top;
}
</code></pre> 
<p>代码如下：</p> 
<p>Stack.h</p> 
<pre><code>#pragma once
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdbool.h&gt;
//定义栈的结构
typedef int STDataType;
 typedef struct Stack
{
	STDataType* arr;
	int capacity;//栈的空间大小
	int top;//栈顶
}ST;
// 初始化栈
void STInit(ST* ps);
// 销毁栈
void STDestroy(ST* ps);
//栈顶--入数据 出数据
// ⼊栈
void STPush(ST* ps, STDataType x);
//出栈
void STPop(ST* ps);
//判断栈是否为空
bool StackEmpty(ST* ps);
//获取栈中有效元素个数
int STSize(ST* ps);
</code></pre> 
<p>Stack.c</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_CRT_SECURE_NO_WARNINGS</span> <span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Stack.h"</span></span>
<span class="token comment">// 初始化栈</span>
<span class="token keyword">void</span> <span class="token function">STInit</span><span class="token punctuation">(</span>ST<span class="token operator">*</span> ps<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>ps<span class="token punctuation">)</span><span class="token punctuation">;</span>
	ps<span class="token operator">-&gt;</span>arr <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	ps<span class="token operator">-&gt;</span>capacity <span class="token operator">=</span> ps<span class="token operator">-&gt;</span>top <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 销毁栈</span>
<span class="token keyword">void</span> <span class="token function">STDestroy</span><span class="token punctuation">(</span>ST<span class="token operator">*</span> ps<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>ps<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ps<span class="token operator">-&gt;</span>arr<span class="token punctuation">)</span>
		<span class="token function">free</span><span class="token punctuation">(</span>ps<span class="token operator">-&gt;</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	ps<span class="token operator">-&gt;</span>arr <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	ps<span class="token operator">-&gt;</span>capacity <span class="token operator">=</span> ps<span class="token operator">-&gt;</span>top <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// ⼊栈</span>
<span class="token keyword">void</span> <span class="token function">STPush</span><span class="token punctuation">(</span>ST<span class="token operator">*</span> ps<span class="token punctuation">,</span> STDataType x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>ps<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//1.判断空间是否足够</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ps<span class="token operator">-&gt;</span>capacity <span class="token operator">==</span> ps<span class="token operator">-&gt;</span>top<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> newCapacity <span class="token operator">=</span> ps<span class="token operator">-&gt;</span>capacity <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">4</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token operator">*</span> ps<span class="token operator">-&gt;</span>capacity<span class="token punctuation">;</span>
		STDataType<span class="token operator">*</span> tmp <span class="token operator">=</span> <span class="token punctuation">(</span>STDataType<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">realloc</span><span class="token punctuation">(</span>ps<span class="token operator">-&gt;</span>arr<span class="token punctuation">,</span> newCapacity <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>STDataType<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>tmp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"realloc fail!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		ps<span class="token operator">-&gt;</span>arr <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
		ps<span class="token operator">-&gt;</span>capacity <span class="token operator">=</span> newCapacity<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//空间足够</span>
	ps<span class="token operator">-&gt;</span>arr<span class="token punctuation">[</span>ps<span class="token operator">-&gt;</span>top<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//判断栈是否为空</span>
bool <span class="token function">StackEmpty</span><span class="token punctuation">(</span>ST<span class="token operator">*</span> ps<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>ps<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> ps<span class="token operator">-&gt;</span>top <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//出栈</span>
<span class="token keyword">void</span> <span class="token function">STPop</span><span class="token punctuation">(</span>ST<span class="token operator">*</span> ps<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>ps<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">StackEmpty</span><span class="token punctuation">(</span>ps<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token operator">--</span>ps<span class="token operator">-&gt;</span>top<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//获取栈中有效元素个数</span>
<span class="token keyword">int</span> <span class="token function">STSize</span><span class="token punctuation">(</span>ST<span class="token operator">*</span> ps<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>ps<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> ps<span class="token operator">-&gt;</span>top<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>Test.c</p> 
<pre><code class="prism language-C">#define _CRT_SECURE_NO_WARNINGS 1
#include "stack.h"
void STTest()
{
	ST st;
	STInit(&amp;st);
	STDestroy(&amp;st);
	STPush(&amp;st, 1);
	STPush(&amp;st, 2);
	STPush(&amp;st, 3);
	STPush(&amp;st, 4);
	printf("size:%d\n", STSize(&amp;st));
	//循环出栈，直至栈为空
	while (!StackEmpty(&amp;st))
	{
		STDataType data = StackTop(&amp;st);
		printf("%d", data);
		//出栈
		StackPop(&amp;st);
	}
}
int main()
{
	STTest();
	return 0;
}
</code></pre> 
<h3><a id="_218"></a>栈这个概念和我们之前学的概念有什么区别？</h3> 
<p><mark>栈里面的数据不能被遍历，也不能被随机访问</mark>，这是和顺序表，链表不同的地方</p> 
<h3><a id="_222"></a>有关栈的一道算法题</h3> 
<p><strong>有效的括号</strong></p> 
<p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'{'</code>，<code>'}'</code>，<code>'['</code>，<code>']'</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p> 
<p>有效字符串需满足：</p> 
<ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol> 
<p><strong>示例 1：</strong></p> 
<pre><code>输入：s = "()"
输出：true
</code></pre> 
<p><strong>示例 2：</strong></p> 
<pre><code>输入：s = "()[]{}"
输出：true
</code></pre> 
<p><strong>示例 3：</strong></p> 
<pre><code>输入：s = "(]"
输出：false
</code></pre> 
<p><strong>提示：</strong></p> 
<ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由括号 <code>'()[]{}'</code> 组成</li></ul> 
<p><strong>思路</strong>：</p> 
<p>借助<mark>数据结构中的栈</mark>来解决</p> 
<p>先定义ps ,ps是{[()]}</p> 
<p>若ps遍历到的符号是左括号，入栈，若ps遍历到的字符为右括号，取栈顶元素，与ps进行比较，栈顶元素<mark>匹配</mark>*ps,出栈，ps++;</p> 
<p>栈顶元素<mark>不匹配</mark>*ps,返回false</p> 
<p>代码如下：<br> <img src="https://images2.imgbox.com/92/12/H61ZpVMP_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/5c/b8/eapdXqWm_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/83/27/gjxO13Un_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4915619c39851f77ace7a6efb0fb5ee2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">详解数据结构之二叉树(堆)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b5b4037974583761c74a3da44cccf7a3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">人工智能学习笔记 - 初级篇Ⅱ - 图形可视化 - 第2节-简单的正弦图和余弦图</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>