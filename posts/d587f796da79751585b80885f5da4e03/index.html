<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【用Java学习数据结构系列】探索Java集合框架的无尽秘密pro - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/d587f796da79751585b80885f5da4e03/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【用Java学习数据结构系列】探索Java集合框架的无尽秘密pro">
  <meta property="og:description" content="看到这句话的时候证明：此刻你我都在努力
加油陌生人
个人主页：Gu Gu Study
专栏：用Java学习数据结构系列
喜欢的一句话： 常常会回顾努力的自己，所以要为自己的努力留下足迹
喜欢的话可以点个赞谢谢了。
作者：小闭
前言 与C语言学习数据结构不同，Java在数据结构的学习和使用上我们必须要了解一下Java的集合框架。
Java中的顺序表，链表，栈，队列，二叉树等，Java都是已经写好的了，其中队列是一个接口。
那么既然Java已经实现了这些数据结构，那么我们只需要认识和会使用这些接口和类就好，那么想认识这些数据结构之前，我们必须要先了解一下Java的集合框架。
什么是集合框架 集合框架是用于表示和操作集合的统一体系结构。所有集合框架都包含以下内容：
接口： 这些是表示集合的抽象数据类型。接口允许独立于其表示的细节来操作集合。在面向对象的语言中，接口通常形成一个层次结构。
实现： 这些是集合接口的具体实现。从本质上讲，它们是可重用的数据结构。
算法： 这些是对实现集合接口的对象执行有用计算（如搜索和排序）的方法。这些算法被称为多态算法：也就是说，相同的方法可以用于适当集合接口的许多不同实现。从本质上讲，算法是可重用的功能。
每个接口都要要实现的方法，当然上图中显示的都是集合框架中的接口。可能有人会问没见到要学习的顺序表和链表之类的东西啊。往下看：
ArrayList（顺序表）
LinkedList（链表）
Vector
Stack（栈）
CopyOnWriteArrayList
这五个类都是实现了这个框架中的List接口。也就是说List中的方法在这些个类中都会是实现。
其中
Java 集合框架的优点 Java 集合框架具有以下优点：
减少编程工作量： 通过提供有用的数据结构和算法，集合框架使您可以专注于程序的重要部分，而不是专注于使其运行所需的低级&#34;管道&#34;。通过促进不相关的
API 之间的互操作性，爪哇岛
集合框架使您无需编写适配器对象或转换代码来连接 API。
提高程序速度和质量： 此集合框架提供了有用数据结构和算法的高性能、高质量实现。每个接口的各种实现都是可以互换的，因此可以通过切换集合实现来轻松调整程序。因为您摆脱了编写自己的数据结构的苦差事，所以您将有更多时间投入到提高程序的质量和性能上。
允许在不相关的 API 之间实现互操作性： 集合接口是 API
来回传递集合的白话。如果我的网络管理 API
提供了节点名称的集合，并且您的 GUI
工具包需要列标题的集合，那么我们的 API
将无缝互操作，即使它们是独立编写的。
减少学习和使用新 API 的工作量： 许多 API
自然而然地在输入上获取集合，并将它们作为输出提供。过去，每个这样的
API 都有一个小的子 API，专门用于操作其集合。这些临时集合子 API
之间几乎没有一致性，因此您必须从头开始学习每个子
API，并且在使用它们时很容易出错。随着标准集合接口的出现，问题消失了。
减少设计新 API
的工作量： 这是前一个优势的另一面。设计人员和实现者不必在每次创建依赖于集合的">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-06T18:01:06+08:00">
    <meta property="article:modified_time" content="2024-08-06T18:01:06+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【用Java学习数据结构系列】探索Java集合框架的无尽秘密pro</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>看到这句话的时候证明：此刻你我都在努力</strong><br> <strong>加油陌生人</strong><br> <img src="https://images2.imgbox.com/62/6e/oKrfqryl_o.jpg" alt="在这里插入图片描述"></p> 
<p>个人主页：<a href="https://blog.csdn.net/2302_81249757?type=lately"><strong>Gu Gu Study</strong></a><br><strong>专栏：<a href="https://blog.csdn.net/2302_81249757/category_12741050.html?spm=1001.2014.3001.5482">用Java学习数据结构系列</a><br> 喜欢的一句话： 常常会回顾努力的自己，所以要为自己的努力留下足迹</strong><br> <br><strong>喜欢的话可以点个赞谢谢了。</strong><br> <strong>作者：小闭</strong></p> 
<hr> 
<h3><a id="_11"></a>前言</h3> 
<p>与C语言学习数据结构不同，Java在数据结构的学习和使用上我们必须要了解一下Java的集合框架。<br> Java中的顺序表，链表，栈，队列，二叉树等，Java都是已经写好的了，其中队列是一个接口。<br> 那么既然Java已经实现了这些数据结构，那么我们只需要认识和会使用这些接口和类就好，那么想认识这些数据结构之前，我们必须要先了解一下Java的集合框架。</p> 
<hr> 
<h4><a id="_19"></a>什么是集合框架</h4> 
<p><img src="https://images2.imgbox.com/04/09/ycM8hBEx_o.png" alt=""><br> <em>集合框架</em>是用于表示和操作集合的统一体系结构。所有集合框架都包含以下内容：</p> 
<ul><li> <p><strong>接口：</strong> 这些是表示集合的抽象数据类型。接口允许独立于其表示的细节来操作集合。在面向对象的语言中，接口通常形成一个层次结构。</p> </li><li> <p><strong>实现：</strong> 这些是集合接口的具体实现。从本质上讲，它们是可重用的数据结构。</p> </li><li> <p><strong>算法：</strong> 这些是对实现集合接口的对象执行有用计算（如搜索和排序）的方法。这些算法被称为<em>多态算法</em>：也就是说，相同的方法可以用于适当集合接口的许多不同实现。从本质上讲，算法是可重用的功能。</p> </li></ul> 
<p>每个接口都要要实现的方法，当然上图中显示的都是集合框架中的接口。可能有人会问没见到要学习的顺序表和链表之类的东西啊。往下看：</p> 
<ol><li> <p><strong>ArrayList</strong>（顺序表）</p> </li><li> <p><strong>LinkedList</strong>（链表）</p> </li><li> <p><strong>Vector</strong></p> </li><li> <p><strong>Stack</strong>（栈）</p> </li><li> <p><strong>CopyOnWriteArrayList</strong></p> </li></ol> 
<p>这五个类都是实现了这个框架中的List接口。也就是说List中的方法在这些个类中都会是实现。<br> 其中</p> 
<h3><a id="Java__45"></a>Java 集合框架的优点</h3> 
<p>Java 集合框架具有以下优点：</p> 
<ul><li> <p><strong>减少编程工作量：</strong> 通过提供有用的数据结构和算法，集合框架使您可以专注于程序的重要部分，而不是专注于使其运行所需的低级"管道"。通过促进不相关的<br> API 之间的互操作性，爪哇岛<br> 集合框架使您无需编写适配器对象或转换代码来连接 API。</p> </li><li> <p><strong>提高程序速度和质量：</strong> 此集合框架提供了有用数据结构和算法的高性能、高质量实现。每个接口的各种实现都是可以互换的，因此可以通过切换集合实现来轻松调整程序。因为您摆脱了编写自己的数据结构的苦差事，所以您将有更多时间投入到提高程序的质量和性能上。</p> </li><li> <p><strong>允许在不相关的 API 之间实现互操作性：</strong> 集合接口是 API<br> 来回传递集合的白话。如果我的网络管理 API<br> 提供了节点名称的集合，并且您的 GUI<br> 工具包需要列标题的集合，那么我们的 API<br> 将无缝互操作，即使它们是独立编写的。</p> </li><li> <p><strong>减少学习和使用新 API 的工作量：</strong> 许多 API<br> 自然而然地在输入上获取集合，并将它们作为输出提供。过去，每个这样的<br> API 都有一个小的子 API，专门用于操作其集合。这些临时集合子 API<br> 之间几乎没有一致性，因此您必须从头开始学习每个子<br> API，并且在使用它们时很容易出错。随着标准集合接口的出现，问题消失了。</p> </li><li> <p><strong>减少设计新 API<br> 的工作量：</strong> 这是前一个优势的另一面。设计人员和实现者不必在每次创建依赖于集合的<br> API 时都重新发明轮子;相反，他们可以使用标准集合接口。</p> </li><li> <p><strong>促进软件重用：</strong> 符合标准集合接口的新数据结构本质上是可重用的。对实现这些接口的对象进行操作的新算法也是如此。</p> </li></ul> 
<p>上面是官方文档的介绍，看不太懂很正常，毕竟我们还没学到那个程度，包括我也不是完全理解的。</p> 
<hr> 
<p>最后奉上<strong>比特</strong>的一张集合框架的接口和类的关系图<br> <img src="https://images2.imgbox.com/1f/ad/npasqwWQ_o.png" alt=""></p> 
<h4><a id="Collection_80"></a>认识Collection</h4> 
<p>Java中的<code>Collection</code>是<code>java.util</code>包下的一个根接口，它是Java集合框架的基础。<code>Collection</code>接口定义了所有单列集合（即只包含单一类型元素的集合）的基本操作。以下是<code>Collection</code>接口的一些详细解析：</p> 
<h4><a id="_84"></a>基本概念</h4> 
<ul><li> <p><strong>单列集合</strong>：<code>Collection</code>接口代表的集合只包含单一类型的元素。</p> </li><li> <p><strong>不可变性</strong>：<code>Collection</code>接口本身是不可变的，即一旦集合被创建，其类型就不能改变。</p> </li></ul> 
<h4><a id="_90"></a>子接口</h4> 
<p><code>Collection</code>接口有两个主要的子接口：</p> 
<ol><li> <p><strong>List</strong>：代表有序的集合，允许重复元素。如<code>ArrayList</code>、<code>LinkedList</code>等。</p> </li><li> <p><strong>Set</strong>：代表不允许重复元素的集合，无特定顺序。如<code>HashSet</code>、<code>TreeSet</code>等。</p> </li><li> <p><strong>Queue：</strong> 队列通常（但不一定）以<br> FIFO（先进先出）方式对元素进行排序。例外情况包括优先级队列，它根据提供的比较器或元素的自然顺序对元素进行排序。无论使用何种排序，队列的头部都是通过调用<br> or 来删除的元素。在 FIFO<br> 队列中，所有新元素都插入到队列的尾部。其他类型的队列可能使用不同的放置规则。每个实现都必须指定其排序属性</p> </li></ol> 
<h4><a id="_103"></a>常用方法</h4> 
<p><code>Collection</code>接口定义了以下一些基本操作：</p> 
<ul><li> <p><code>add(E e)</code>：添加一个元素到集合中。</p> </li><li> <p><code>remove(Object o)</code>：从集合中移除一个元素。</p> </li><li> <p><code>contains(Object o)</code>：检查集合是否包含指定的元素。</p> </li><li> <p><code>size()</code>：返回集合中元素的数量。</p> </li><li> <p><code>isEmpty()</code>：检查集合是否为空。</p> </li><li> <p><code>toArray()</code>：返回包含集合中所有元素的数组。</p> </li><li> <p><code>iterator()</code>：返回一个迭代器，用于遍历集合中的元素。</p> </li></ul> 
<h4><a id="Iterator_iterator_121"></a>迭代器（Iterator） {#迭代器iterator）}</h4> 
<p><code>Collection</code>接口通过<code>iterator()</code>方法提供了一种遍历集合元素的方式。迭代器是一个对象，它允许程序逐个访问集合中的每个元素，而不需要关心集合的具体实现细节。</p> 
<h4><a id="_125"></a>子接口的扩展方法</h4> 
<p><code>List</code>和<code>Set</code>接口除了继承<code>Collection</code>的方法外，还提供了一些额外的方法来支持它们特定的行为：</p> 
<ul><li> <p><code>List</code>接口提供了插入、替换和访问特定位置元素的方法。</p> </li><li> <p><code>Set</code>接口通常不提供对元素的直接访问，而是通过迭代器或<code>Collection</code>的通用方法来操作。</p> </li></ul> 
<h4><a id="_133"></a>泛型</h4> 
<p>从Java<br> 5开始，<code>Collection</code>及其子接口支持泛型，这意味着你可以指定集合中元素的类型，从而提高代码的类型安全性和重用性。</p> 
<h4><a id="_138"></a>线程安全性</h4> 
<p>大多数<code>Collection</code>实现不是线程安全的。如果需要线程安全的集合，可以使用<code>Collections.synchronizedCollection()</code>方法包装一个集合，或者使用并发集合类，如<code>ConcurrentHashMap</code>的键集合。</p> 
<h4><a id="_142"></a>选择适当的实现</h4> 
<p>选择适当的<code>Collection</code>实现对于性能至关重要。例如：</p> 
<ul><li> <p>使用<code>ArrayList</code>如果需要快速随机访问集合中的元素。</p> </li><li> <p>使用<code>LinkedList</code>如果需要频繁地在集合中插入或删除元素。</p> </li><li> <p>使用<code>HashSet</code>如果不需要保证元素的顺序，并且希望快速查找元素。</p> </li></ul> 
<h4><a id="_152"></a>性能考虑</h4> 
<p>不同的<code>Collection</code>实现在不同操作下的性能表现不同。例如，<code>ArrayList</code>在随机访问方面表现更好，而<code>LinkedList</code>在插入和删除方面更高效。<br> <code>Collection</code>接口是Java集合框架的核心，提供了一种统一的方式来操作集合，无论它们的具体实现是什么。了解和合理使用<code>Collection</code>及其子接口可以大大提高Java程序的性能和可维护性。</p> 
<hr> 
<h3><a id="%0A_159"></a>好了通过这篇文章呢，相信你对集合框架有了一个基本的了解，其中更加深奥的知识需要你们更加努力的探索哦。<br> 喜欢的话点个关注唔，之后会为大家继续更新这个系列。</h3> 
<p>好了通过这篇文章呢，相信你对集合框架有了一个基本的了解，其中更加深奥的知识需要你们更加努力的探索哦。<br> 喜欢的话点个关注唔，之后会为大家继续更新这个系列。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ca870a930da2404dc61b621c53eb30b9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">类和对象（下）C&#43;&#43;</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/104b1a38593a12ce863d8b056561dd4d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【用Java学习数据结构系列】初识泛型</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>