<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java 数据结构篇-实现堆的核心方法与堆的应用（实现 TOP-K 问题：最小 k 个数） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/cc14a86d58973ffd28f8dc0c34904e5c/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java 数据结构篇-实现堆的核心方法与堆的应用（实现 TOP-K 问题：最小 k 个数）">
  <meta property="og:description" content="🔥博客主页： 【小扳_-CSDN博客】
❤感谢大家点赞👍收藏⭐评论✍ 文章目录
1.0 堆的说明
2.0 堆的成员变量及其构造方法 3.0 实现堆的核心方法
3.1 实现堆的核心方法 - 获取堆顶元素 peek()
3.2 实现堆的核心方法 - 下潜 down(int i)
3.3 实现堆的核心方法 - 交换元素 swap(int i,int j)
3.4 实现堆核心方法 - 删除堆顶元素 poll()
3.5 实现堆的核心方法 - 替换堆顶元素 replace(int i)
3.6 实现堆的核心方法 - 添加元素 offer(int value)
3.7 实现堆的核心方法 - 建堆 heapify()
3.8 实现堆的核心方法完整代码
4.0 TOP - K 问题：最小的 K 个数
4.1 实现最小 k 个数的思路
4.2 代码实现最小 k 个数
1.0 堆的说明 堆（Heap）是一种基于树的数据结构，通常用于动态分配内存空间。堆可以被看作是一棵完全二叉树，其中每个节点都满足堆的性质，即父节点的值大于或等于子节点的值（大根堆），或父节点的值小于或等于子节点的值（小根堆）。在堆中，根节点的值是最大或最小的，因此也被称为最大堆或最小堆。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-12-19T20:52:09+08:00">
    <meta property="article:modified_time" content="2023-12-19T20:52:09+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java 数据结构篇-实现堆的核心方法与堆的应用（实现 TOP-K 问题：最小 k 个数）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><strong>🔥博客主页： 【<strong><a href="https://blog.csdn.net/Tingfeng__?spm=1000.2115.3001.5343" title="小扳_-CSDN博客】">小扳_-CSDN博客】</a></strong><br> ❤感谢大家点赞👍收藏⭐评论✍</strong>  </p> 
</blockquote> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/cd/33/lZtZzEtP_o.jpg" width="400"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/2f/a3/rIpEbgKD_o.gif"></p> 
<p> </p> 
<p id="main-toc"><strong>文章目录</strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.0%20%E5%A0%86%E7%9A%84%E8%AF%B4%E6%98%8E-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.0%20%E5%A0%86%E7%9A%84%E8%AF%B4%E6%98%8E" rel="nofollow">        1.0 堆的说明</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.0%20%E5%A0%86%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%C2%A0-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.0%20%E5%A0%86%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%C2%A0" rel="nofollow">        2.0 堆的成员变量及其构造方法 </a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.0%20%E5%AE%9E%E7%8E%B0%E5%A0%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.0%20%E5%AE%9E%E7%8E%B0%E5%A0%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95" rel="nofollow">        3.0 实现堆的核心方法</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.1%C2%A0%E5%AE%9E%E7%8E%B0%E5%A0%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%20-%20%E8%8E%B7%E5%8F%96%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A0%20peek()-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.1%C2%A0%E5%AE%9E%E7%8E%B0%E5%A0%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%20-%20%E8%8E%B7%E5%8F%96%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A0%20peek%28%29" rel="nofollow">        3.1 实现堆的核心方法 - 获取堆顶元素 peek()</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.2%C2%A0%E5%AE%9E%E7%8E%B0%E5%A0%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%20-%20%E4%B8%8B%E6%BD%9C%20down(int%20i)-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.2%C2%A0%E5%AE%9E%E7%8E%B0%E5%A0%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%20-%20%E4%B8%8B%E6%BD%9C%20down%28int%20i%29" rel="nofollow">        3.2 实现堆的核心方法 - 下潜 down(int i)</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.3%C2%A0%E5%AE%9E%E7%8E%B0%E5%A0%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%20-%20%E4%BA%A4%E6%8D%A2%E5%85%83%E7%B4%A0%20swap(int%20i%2Cint%20j)-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.3%C2%A0%E5%AE%9E%E7%8E%B0%E5%A0%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%20-%20%E4%BA%A4%E6%8D%A2%E5%85%83%E7%B4%A0%20swap%28int%20i%2Cint%20j%29" rel="nofollow">        3.3 实现堆的核心方法 - 交换元素 swap(int i,int j)</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.4%C2%A0%E5%AE%9E%E7%8E%B0%E5%A0%86%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%20-%20%E5%88%A0%E9%99%A4%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A0%20poll()-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.4%C2%A0%E5%AE%9E%E7%8E%B0%E5%A0%86%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%20-%20%E5%88%A0%E9%99%A4%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A0%20poll%28%29" rel="nofollow">        3.4 实现堆核心方法 - 删除堆顶元素 poll()</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.5%C2%A0%E5%AE%9E%E7%8E%B0%E5%A0%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%20-%20%E6%9B%BF%E6%8D%A2%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A0%20replace(int%20i)-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.5%C2%A0%E5%AE%9E%E7%8E%B0%E5%A0%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%20-%20%E6%9B%BF%E6%8D%A2%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A0%20replace%28int%20i%29" rel="nofollow">        3.5 实现堆的核心方法 - 替换堆顶元素 replace(int i)</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.6%C2%A0%E5%AE%9E%E7%8E%B0%E5%A0%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%20-%20%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%20offer(int%20value)-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.6%C2%A0%E5%AE%9E%E7%8E%B0%E5%A0%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%20-%20%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%20offer%28int%20value%29" rel="nofollow">        3.6 实现堆的核心方法 - 添加元素 offer(int value)</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.7%C2%A0%E5%AE%9E%E7%8E%B0%E5%A0%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%20-%20%E5%BB%BA%E5%A0%86%20heapify()-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.7%C2%A0%E5%AE%9E%E7%8E%B0%E5%A0%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%20-%20%E5%BB%BA%E5%A0%86%20heapify%28%29" rel="nofollow">        3.7 实现堆的核心方法 - 建堆 heapify()</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.8%20%E5%AE%9E%E7%8E%B0%E5%A0%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.8%20%E5%AE%9E%E7%8E%B0%E5%A0%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" rel="nofollow">        3.8 实现堆的核心方法完整代码</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.0%20TOP%20-%20K%20%E9%97%AE%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E7%9A%84%20K%20%E4%B8%AA%E6%95%B0-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.0%20TOP%20-%20K%20%E9%97%AE%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E7%9A%84%20K%20%E4%B8%AA%E6%95%B0" rel="nofollow">        4.0 TOP - K 问题：最小的 K 个数</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.1%20%E5%AE%9E%E7%8E%B0%E6%9C%80%E5%B0%8F%20k%20%E4%B8%AA%E6%95%B0%E7%9A%84%E6%80%9D%E8%B7%AF-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.1%20%E5%AE%9E%E7%8E%B0%E6%9C%80%E5%B0%8F%20k%20%E4%B8%AA%E6%95%B0%E7%9A%84%E6%80%9D%E8%B7%AF" rel="nofollow">        4.1 实现最小 k 个数的思路</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.2%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%9C%80%E5%B0%8F%20k%20%E4%B8%AA%E6%95%B0-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.2%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%9C%80%E5%B0%8F%20k%20%E4%B8%AA%E6%95%B0" rel="nofollow">        4.2 代码实现最小 k 个数</a></strong></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.0%20%E5%A0%86%E7%9A%84%E8%AF%B4%E6%98%8E">        1.0 堆的说明</h2> 
<p>        <strong>堆（Heap）是一种基于树的数据结构，通常用于动态分配内存空间。堆可以被看作是<span style="color:#fe2c24;">一棵完全二叉树</span>，其中每个节点都满足堆的性质，即<span style="color:#fe2c24;">父节点的值大于或等于子节点的值（大根堆），或父节点的值小于或等于子节点的值（小根堆）</span>。在堆中，根节点的值是最大或最小的，因此也被称为最大堆或最小堆。</strong></p> 
<p><strong>        堆的实现通常使用<span style="color:#fe2c24;">数组来存储堆中的元素</span>，<span style="color:#fe2c24;">通过计算数组下标来实现节点之间的关系</span>。堆的<span style="color:#fe2c24;">时间复杂度为 O(log n)</span>，其中 n 是堆中元素的数量。</strong></p> 
<p><strong>        堆的操作包括<span style="color:#fe2c24;">插入</span>、<span style="color:#fe2c24;">删除</span>和<span style="color:#fe2c24;">查找等</span>。插入操作将一个新元素插入到堆中，删除操作将堆中的最大或最小元素删除，查找操作可以在堆中查找特定元素的位置。</strong></p> 
<p></p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.0%20%E5%A0%86%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%C2%A0">        2.0 堆的成员变量及其构造方法 </h2> 
<p>        <strong>主要的成员变量为：<span style="color:#fe2c24;">int[] arr</span> <span style="color:#fe2c24;">数组</span>：用来存放元素的容器；<span style="color:#fe2c24;">int size</span> ：代表当前的元素个数。</strong></p> 
<p><strong>        构造方法：指定<span style="color:#fe2c24;">数组大小带参数的构造器</span>、<span style="color:#fe2c24;">参数为数组的构造器</span>。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">public class MyHeap {
    public int[] arr;
    public int size;

    public MyHeap(int capacity) {
        arr = new int[capacity];
    }

    public MyHeap(int[] arr) {
        this.arr = arr;
        this.size = arr.length;
        heapify();
    }

}</code></pre> 
 <p>        </p> 
</blockquote> 
<p></p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.0%20%E5%AE%9E%E7%8E%B0%E5%A0%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95">        3.0 实现堆的核心方法</h2> 
<p>        <span style="color:#fe2c24;"><strong>获取堆顶元素、下潜、交换元素、添加元素、替换元素、删除元素、建堆。</strong></span></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.1%C2%A0%E5%AE%9E%E7%8E%B0%E5%A0%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%20-%20%E8%8E%B7%E5%8F%96%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A0%20peek()">        3.1 实现堆的核心方法 - 获取堆顶元素 peek()</h3> 
<p>        <strong>用数组实现堆，在获取堆顶元之前，先需要判断该数组是否为空，若不为空，则直接返回数组索引为 0 的元素；若数组为空，则返回 0 或者抛出异常也可以。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //获取栈顶元素
    public int peek() {
        if (isEmpty()) {
            return -1;
        }
        return arr[0];
    }</code></pre> 
 <p></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.2%C2%A0%E5%AE%9E%E7%8E%B0%E5%A0%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%20-%20%E4%B8%8B%E6%BD%9C%20down(int%20i)">        3.2 实现堆的核心方法 - 下潜 down(int i)</h3> 
<p>        <strong>该方法主要用于删除栈顶元素、替换元素等核心方法。下潜的意思就是<span style="color:#fe2c24;">将当前的元素所在的位置不符合大顶堆或者小顶堆的规则，因此需要向下调整。找到合适的位置来存放当前的元素</span>。</strong></p> 
<p><strong> 具体下潜的思路：</strong></p> 
<blockquote> 
 <p><strong>假设需要满足大顶堆的规则：</strong></p> 
 <p class="img-center"><img alt="" height="273" src="https://images2.imgbox.com/39/6d/I0BffTnZ_o.png" width="317"></p> 
 <p>        <strong>由以上的图来看，当前的索引为 0 处的元素 7 小于该左孩子的元素，因此当前不满足大顶堆的规则。需要将两者进行交换。</strong></p> 
 <p><strong>交换的结果为：</strong></p> 
 <p class="img-center"><img alt="" height="301" src="https://images2.imgbox.com/9a/8a/k2czRbfp_o.png" width="317"></p> 
 <p>        <strong>交换完之后，当前索引为 2 处的元素 7 小于该右孩子的元素，所以索引 2 与 索引 5 需要继续交换。若当前为 i 该<span style="color:#fe2c24;">右孩子的索引 left = 2 * i + 1</span>；该<span style="color:#fe2c24;">左孩子的索引 right = 2 * i + 2</span> （也可以表示为 <span style="color:#fe2c24;">right = left + 1</span> ）一开始默认当前的最大元素的索引 <span style="color:#fe2c24;">max = i </span>，接着来判断该左右孩子的元素是否大于当前索引<span style="color:#fe2c24;"> max </span>，若大于当前索引 <span style="color:#fe2c24;">max</span> 时，需要进行交换<span style="color:#fe2c24;"> max = left 或者 max = right </span>。若不大于当前索引为<span style="color:#fe2c24;"> max </span>处的元素，则不需要交换。由于每一次都是子问题过程，所以可以利用递归来实现，<span style="color:#fe2c24;">当且仅当 max != i 时</span>，说明 max 已经被交换过了，需要继续向下递出，<span style="color:#fe2c24;">直到 max == i 时，结束递出，开始回溯</span>。当然，这里不需要回带任何值或者变量，即该递归函数的返回类型为 viod 。</strong></p> 
</blockquote> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //下潜
    public void down(int i) {
        int left = 2 * i + 1;
        int right = left + 1;
        int max = i;
        if (left &lt; size &amp;&amp; arr[left] &gt; arr[max]) {
            max = left;
        }
        if (right &lt; size &amp;&amp; arr[right] &gt; arr[max]) {
            max = right;
        }
        if (max != i) {

            //交换
            swap(i,max);

            //继续下潜
            down(max);
        }
    }</code></pre> 
 <p></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.3%C2%A0%E5%AE%9E%E7%8E%B0%E5%A0%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%20-%20%E4%BA%A4%E6%8D%A2%E5%85%83%E7%B4%A0%20swap(int%20i%2Cint%20j)">        3.3 实现堆的核心方法 - 交换元素 swap(int i,int j)</h3> 
<p>        <strong><span style="color:#fe2c24;">交换数组索引中 i 与 j 处的元素</span>。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //交换
    public void swap(int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }</code></pre> 
 <p></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.4%C2%A0%E5%AE%9E%E7%8E%B0%E5%A0%86%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%20-%20%E5%88%A0%E9%99%A4%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A0%20poll()">        3.4 实现堆核心方法 - 删除堆顶元素 poll()</h3> 
<p>        <strong>具体实现思路：为了更高效率的删除堆顶元素后保持原来大顶堆或者小顶堆的规则。</strong></p> 
<p><strong>        <span style="color:#fe2c24;">步骤一：先将堆顶元素与最后一个元素进行交换。即 arr[0] = arr[size - 1] 。</span></strong></p> 
<p><span style="color:#fe2c24;"><strong>        步骤二：将 size-- 。</strong></span></p> 
<p><strong><span style="color:#fe2c24;">        步骤三：交换后的堆，可能会不满足大顶堆或者小顶堆的规则，则需要将堆顶元素进行下潜调整，找到合适的位置存放该元素。最后需要返回删除的元素。</span></strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //删除堆顶元素
    public int poll() {
        if (isEmpty()) {
            return 0;
        }
        int t = arr[0];
        arr[0] = arr[size - 1];
        size--;
        //下潜
        down(0);

        return t;
    }</code></pre> 
 <p><strong>        注意：在删除堆顶元素之前，需要先判断当前的数组是否为空数组。</strong></p> 
</blockquote> 
<p>        <strong>同理，若需要删除指定堆中的元素索引，实现思路是一样的。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //指定删除元素
    public int poll(int i) {
        if (i &gt; size) {
            return 0;
        }
        int temp = arr[i];
        arr[i] = arr[size - 1];
        size--;
        //下潜
        down(i);
        return temp;
    }</code></pre> 
 <p><strong>        先判断索引是否合法，若不合法，则返回 0 或者抛出异常也可以。</strong></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.5%C2%A0%E5%AE%9E%E7%8E%B0%E5%A0%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%20-%20%E6%9B%BF%E6%8D%A2%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A0%20replace(int%20i)">        3.5 实现堆的核心方法 - 替换堆顶元素 replace(int i)</h3> 
<p>        <strong>具体思路为：<span style="color:#fe2c24;">先判断该数组是否为空数组，若不为空数组，则直接替换堆顶元素 arr[0] = i；之后可能会不满足大顶堆或者小顶堆的规则，所以索引为 0 处需要下潜调整，找到合适的位置存放元素。</span></strong></p> 
<p><strong>代码实现：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //替换堆顶元素
    public void replace(int i) {
        if (isEmpty()) {
            return;
        }
        arr[0] = i;
        down(0);
    }</code></pre> 
 <p></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.6%C2%A0%E5%AE%9E%E7%8E%B0%E5%A0%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%20-%20%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%20offer(int%20value)">        3.6 实现堆的核心方法 - 添加元素 offer(int value)</h3> 
<p>        <strong>具体实现思路：先判断当前索引为 <span style="color:#fe2c24;">i = size</span> 处的双亲节点为<span style="color:#fe2c24;"> j = (i - 1) / 2 </span>，判断 <span style="color:#fe2c24;">arr[j]</span> 与 <span style="color:#fe2c24;">value</span> 的大小，若为大顶堆规则，则当 <span style="color:#fe2c24;">arr[j] &gt; value</span> 时，不需要继续往上走了，在 <span style="color:#fe2c24;">i </span>处存放 <span style="color:#fe2c24;">value </span>即可 <span style="color:#fe2c24;">arr[i] = value </span>；当 <span style="color:#fe2c24;">arr[j] &lt;= value</span> 时，先将 <span style="color:#fe2c24;">arr[j] </span>处的元素存放在 <span style="color:#fe2c24;">arr[i] </span>中，接着需要继续往上走，<span style="color:#fe2c24;"> i = j ，j = (i - 1) / 2 </span>直到<span style="color:#fe2c24;"> i == 0 或者 arr[j] &gt; value </span>时，退出循环。在<span style="color:#fe2c24;"> arr[i] </span>处存放 <span style="color:#fe2c24;">value</span> 。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //添加元素
    public boolean offer(int value) {
        if (isFull()) {
            return false;
        }
        int i = size;
        int j = (size - 1) / 2;
        while (i &gt; 0 &amp;&amp; arr[j] &lt; value) {
            arr[i] = arr[j];
            i = j;
            j = (i - 1) / 2;
        }
        arr[i] = value;
        size++;
        return true;
    }</code></pre> 
 <p>       <strong> 需要注意：添加元素前，需要先判断该数组是否满了。还有添加完之后，需要进行 <span style="color:#fe2c24;">size++</span> 。</strong></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.7%C2%A0%E5%AE%9E%E7%8E%B0%E5%A0%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%20-%20%E5%BB%BA%E5%A0%86%20heapify()">        3.7 实现堆的核心方法 - 建堆 heapify()</h3> 
<p>        <strong>该方法实现的意义，若随机给出一个数组，需要实现由大顶堆或者小顶堆的结构存放元素。因此就会用到该方法。</strong></p> 
<p><strong>        实现思路为：<span style="color:#fe2c24;">需要找到最后一个非叶子节点，从后往前，将当前的元素进行下潜处理即可完成建堆。</span></strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //建堆
    public void heapify() {

        //先找到最后非叶子节点
        int lastNonLeafNodes = size / 2 - 1;
        for (int i = lastNonLeafNodes; i &gt;= 0 ; i--) {
            //下潜
            down(i);
        }
    }</code></pre> 
 <p></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.8%20%E5%AE%9E%E7%8E%B0%E5%A0%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">        3.8 实现堆的核心方法完整代码</h3> 
<blockquote> 
 <pre><code class="language-java">public class MyHeap {
    public int[] arr;
    public int size;

    public MyHeap(int capacity) {
        arr = new int[capacity];
    }

    public MyHeap(int[] arr) {
        this.arr = arr;
        this.size = arr.length;
        heapify();
    }

    //获取栈顶元素
    public int peek() {
        if (isEmpty()) {
            return -1;
        }
        return arr[0];
    }

    //删除堆顶元素
    public int poll() {
        if (isEmpty()) {
            return 0;
        }
        int t = arr[0];
        arr[0] = arr[size - 1];
        size--;
        //下潜
        down(0);

        return t;
    }

    //指定删除元素
    public int poll(int i) {
        if (i &gt; size) {
            return 0;
        }
        int temp = arr[i];
        arr[i] = arr[size - 1];
        size--;
        //下潜
        down(i);
        return temp;
    }

    //替换堆顶元素
    public void replace(int i) {
        if (isEmpty()) {
            return;
        }
        arr[0] = i;
        down(0);
    }


    //添加元素
    public boolean offer(int value) {
        if (isFull()) {
            return false;
        }
        int i = size;
        int j = (size - 1) / 2;
        while (i &gt; 0 &amp;&amp; arr[j] &lt; value) {
            arr[i] = arr[j];
            i = j;
            j = (i - 1) / 2;
        }
        arr[i] = value;
        size++;
        return true;
    }

    //建堆
    public void heapify() {

        //先找到最后非叶子节点
        int lastNonLeafNodes = size / 2 - 1;
        for (int i = lastNonLeafNodes; i &gt;= 0 ; i--) {
            //下潜
            down(i);
        }
    }

    //下潜
    public void down(int i) {
        int left = 2 * i + 1;
        int right = left + 1;
        int max = i;
        if (left &lt; size &amp;&amp; arr[left] &gt; arr[max]) {
            max = left;
        }
        if (right &lt; size &amp;&amp; arr[right] &gt; arr[max]) {
            max = right;
        }
        if (max != i) {

            //交换
            swap(i,max);

            //继续下潜
            down(max);
        }
    }

    //交换
    public void swap(int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }


    //判断是否为空数组
    public boolean isEmpty() {
        return size == 0;
    }

    //判断是否为满数组
    public boolean isFull() {
        return  size == arr.length;
    }
}</code></pre> 
 <p></p> 
</blockquote> 
<p></p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.0%20TOP%20-%20K%20%E9%97%AE%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E7%9A%84%20K%20%E4%B8%AA%E6%95%B0">        4.0 TOP - K 问题：最小的 K 个数</h2> 
<blockquote> 
 <p><strong>题目：</strong></p> 
 <p><strong>        设计一个算法，找出数组中最小的k个数。以任意顺序返回这 k 个数均可。</strong></p> 
 <p><strong>示例：</strong></p> 
 <pre><strong>输入：</strong> <strong>arr = [1,3,5,7,2,4,6,8], k = 4
输出： [1,2,3,4]</strong>
</pre> 
 <p><strong>提示：</strong></p> 
 <p><strong><code>0 &lt;= len(arr) &lt;= 100000</code></strong></p> 
 <p><strong><code>0 &lt;= k &lt;= min(100000, len(arr))</code></strong></p> 
 <p></p> 
 <p><strong>OJ 链接：</strong></p> 
 <p><a href="https://leetcode.cn/problems/smallest-k-lcci/" rel="nofollow" title="面试题 17.14. 最小K个数">面试题 17.14. 最小K个数</a></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.1%20%E5%AE%9E%E7%8E%B0%E6%9C%80%E5%B0%8F%20k%20%E4%B8%AA%E6%95%B0%E7%9A%84%E6%80%9D%E8%B7%AF">        4.1 实现最小 k 个数的思路</h3> 
<p>        <strong>具体思路为：<span style="color:#fe2c24;">结合大顶堆的数据结构的特点，根节点的元素永远比孩子节点的元素大。先将给定的 arr 数组的前 k 个元素直接通过 heap.offer() 方法添加到大顶堆上，然后 arr 数组剩下的元素需要跟堆顶元素相对比，若堆顶元素大于 arr[i] 中的元素，则需要进行交换，将 arr[i] 的元素替换到堆顶，接着还不能结束，有可能替换完的元素就不符合大顶堆的规则了，因此还需要将堆顶元素下潜处理调整，找到合适的位置存放该元素；若堆顶元素不大于 arr[i] 中的元素，则不需要交换。一直将 arr 数组中的元素遍历结束，则循环停止。最后堆上存储的 k 个元素就是该数组 arr 中最小的元素了。</span></strong></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.2%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%9C%80%E5%B0%8F%20k%20%E4%B8%AA%E6%95%B0" style="background-color:transparent;">        4.2 代码实现最小 k 个数</h3> 
<blockquote> 
 <pre><code class="language-java">public class Solution {
    public int[] smallestK(int[] arr, int k) {
        MaxHeap heap = new MaxHeap(k);
        for(int i = 0; i &lt; k ; i++) {
            heap.offer(arr[i]);
        }
        for(int i = k; i &lt; arr.length; i++) {
            if(heap.peek() &gt; arr[i]) {
                heap.arr[0] = arr[i];
                heap.down(0);
            }
        }
        return heap.arr;
    }

}

//实现一个大顶堆
class MaxHeap {
    int[] arr;
    int size;

    public MaxHeap(int capacity) {
        arr = new int[capacity];
    }

    public MaxHeap(int[] smallestK) {
        this.arr = smallestK;
        this.size = smallestK.length;
    }

    //插入元素
    public boolean offer(int value) {
        if(isFull()) {
            return false;
        }
        int i = size;
        int j = (i - 1) / 2;
        while(i &gt; 0 &amp;&amp; arr[j] &lt; value) {
            arr[i] = arr[j];
            i = j;
            j = (i - 1) / 2;
        }
        arr[i] = value;
        size++;
        return true;
    }

    //删除堆顶元素
    public int poll() {
        if(isEmpty()) {
            return 0;
        }
        int ret = arr[0];
        arr[0] = arr[size - 1];
        size--;
        down(0);
        return ret;
    }
    //下潜
    public void down(int i) {
        int left = 2 * i + 1;
        int right = left + 1;
        int max = i;
        if(left &lt; size &amp;&amp; arr[left] &gt; arr[max]) {
            max = left;
        }
        if(right &lt; size &amp;&amp; arr[right] &gt; arr[max]) {
            max = right;
        }
        if(max != i) {
            swap(max,i);
            down(max);
        }

    }

    //交换
    public void swap(int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    //获取堆顶元素
    public int peek() {
        if(isEmpty()) {
            return 0;
        }
        return arr[0];
    }

    //判断是否为空
    public boolean isEmpty() {
        return size == 0;
    }

    //判断是否为满
    public boolean isFull() {
        return size == arr.length;
    }

}</code></pre> 
 <p></p> 
</blockquote> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/67/9a/i6YZfPns_o.gif"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/06b4853c0eec41970a130dbf4da7b697/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">宽带信号处理实现DOA估计（ISM算法、MUSIC、MVDR、CBF）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/12e37005d8c84051484e525f9cdfce6e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">redisTemplate.opsForValue() 懂这些就够了</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>