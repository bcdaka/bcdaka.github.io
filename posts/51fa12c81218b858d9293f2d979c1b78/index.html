<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>贪心算法总结（3） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/51fa12c81218b858d9293f2d979c1b78/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="贪心算法总结（3）">
  <meta property="og:description" content="一、最长回文串 409. 最长回文串 - 力扣（LeetCode）
class Solution { public: int longestPalindrome(string s) { int hash[127]={0}; for(char&amp;ch:s) &#43;&#43;hash[ch]; int ret=0; for(int&amp;x:hash) ret&#43;=x/2*2; //技巧1 利用向下取整 return ret&lt;s.size()?ret&#43;1:ret; } }; 二、增减字符串匹配 942. 增减字符串匹配 - 力扣（LeetCode）
class Solution { public: vector&lt;int&gt; diStringMatch(string s) { //如果是升 就把最小的放进去 如果是降 就把最大的放进去 int left=0,right=s.size(); vector&lt;int&gt; ret; ret.reserve(s.size()&#43;1); for(auto&amp;ch:s) if(ch==&#39;I&#39;) ret.emplace_back(left&#43;&#43;); else ret.emplace_back(right--); ret.emplace_back(left); return ret; } }; 三、重构字符串 767. 重构字符串 - 力扣（LeetCode）
class Solution { public: string reorganizeString(string s) { int hash[26]={0}; int n=s.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-10T01:02:11+08:00">
    <meta property="article:modified_time" content="2024-08-10T01:02:11+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">贪心算法总结（3）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="text-align:center;"><img alt="" height="292" src="https://images2.imgbox.com/c3/1c/vfxmNKjv_o.gif" width="569"></h2> 
<h2>一、最长回文串</h2> 
<p><a href="https://leetcode.cn/problems/longest-palindrome/" rel="nofollow" title="409. 最长回文串 - 力扣（LeetCode）">409. 最长回文串 - 力扣（LeetCode）</a></p> 
<p><img alt="" height="924" src="https://images2.imgbox.com/96/b0/CWmsvE9K_o.png" width="1191"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/5d/c3/5Tw1BVoF_o.png" width="1200"></p> 
<pre><code class="language-cpp">class Solution {
public:
    int longestPalindrome(string s) {
          int hash[127]={0};
          for(char&amp;ch:s) ++hash[ch];
          int ret=0;
          for(int&amp;x:hash)  ret+=x/2*2; //技巧1 利用向下取整
          return ret&lt;s.size()?ret+1:ret;
    }
};</code></pre> 
<h2>二、增减字符串匹配</h2> 
<p><a href="https://leetcode.cn/problems/di-string-match/description/" rel="nofollow" title="942. 增减字符串匹配 - 力扣（LeetCode）">942. 增减字符串匹配 - 力扣（LeetCode）</a></p> 
<p><img alt="" height="1097" src="https://images2.imgbox.com/07/02/2BO1fSJs_o.png" width="1125"></p> 
<p><img alt="" height="992" src="https://images2.imgbox.com/73/74/ocaLbFFH_o.png" width="1200"></p> 
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; diStringMatch(string s) {
       //如果是升 就把最小的放进去  如果是降 就把最大的放进去
       int left=0,right=s.size();
       vector&lt;int&gt; ret;
       ret.reserve(s.size()+1);
       for(auto&amp;ch:s) 
         if(ch=='I') ret.emplace_back(left++);
         else ret.emplace_back(right--);
       ret.emplace_back(left);
       return ret;
    }
};</code></pre> 
<h2>三、重构字符串</h2> 
<p><a href="https://leetcode.cn/problems/reorganize-string/description/" rel="nofollow" title="767. 重构字符串 - 力扣（LeetCode）">767. 重构字符串 - 力扣（LeetCode）</a></p> 
<p><img alt="" height="757" src="https://images2.imgbox.com/e9/c3/iR2jtXW4_o.png" width="1190"></p> 
<p><img alt="" height="520" src="https://images2.imgbox.com/fe/21/N7QuQ1AU_o.png" width="788"></p> 
<pre><code class="language-cpp">class Solution {
public:
    string reorganizeString(string s) {
          int hash[26]={0};
          int n=s.size(),maxcount=0,maxchar=' ';
          for(auto&amp;ch:s)
           if(maxcount&lt;++hash[ch-'a']) maxcount=hash[ch-'a'],maxchar=ch;
           //先处理最多的那个
           if(maxcount&gt;(n+1)/2) return "";
           string ret(n,' ');
           int index=0;
           for(int i=0;i&lt;maxcount;++i)
           {
              ret[index]=maxchar;
              index+=2;
           }
           hash[maxchar-'a']=0;
           for(int i=0;i&lt;26;++i)
            for(int j=0;j&lt;hash[i];++j)
             {
                if(index&gt;=n) index=1;
                ret[index]='a'+i;
                index+=2;
             }
             return ret;
    }
};</code></pre> 
<h2 style="background-color:transparent;">四、最优除法</h2> 
<p><a href="https://leetcode.cn/problems/optimal-division/" rel="nofollow" title="553. 最优除法 - 力扣（LeetCode）">553. 最优除法 - 力扣（LeetCode）</a></p> 
<p><img alt="" height="1165" src="https://images2.imgbox.com/28/b9/n6fzERPa_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/2b/8a/56ulweUd_o.png" width="1200"></p> 
<pre><code class="language-cpp">class Solution {
public:
    string optimalDivision(vector&lt;int&gt;&amp; nums) {
       int n=nums.size();
       if(n==1) return to_string(nums[0]);
       if(n==2) return to_string(nums[0])+"/"+to_string(nums[1]);
        string ret=to_string(nums[0])+"/("+to_string(nums[1]);
        for(int i=2;i&lt;n;++i) ret+="/"+to_string(nums[i]);
        ret+=")";
       return ret;
    }
};</code></pre> 
<h2> 五、单调递增的数字</h2> 
<p><a href="https://leetcode.cn/problems/monotone-increasing-digits/description/" rel="nofollow" title="738. 单调递增的数字 - 力扣（LeetCode）">738. 单调递增的数字 - 力扣（LeetCode）</a></p> 
<p><img alt="" height="924" src="https://images2.imgbox.com/03/0c/15N9NrDV_o.png" width="1190"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/65/e6/eYvBaBZ4_o.png" width="1200"></p> 
<pre><code class="language-cpp">class Solution {
public:
//要获取一个数的数位关系的时候 一般有两个技巧，第一个是变成字符串 第二个就是/10 %10
    int monotoneIncreasingDigits(int n) {
       //根据贪心策略，首先第一步我们要找到第一个下降的数，然后让他-1 之后再把后面所有的数都变成9
       //但是比如12345555123这种情况。就需要进行回退 回退到第一个5的位置然后再进行上面的操作
       string s=to_string(n);
       int m=s.size(),i=0;
       while(i+1&lt;n&amp;&amp;s[i]&lt;=s[i+1]) ++i; //找到第一个下降趋势的
       if(i==m-1) return n;//可能直接走到头了
       //如果没有走到头，开始回退
       while(i-1&gt;=0&amp;&amp;s[i]==s[i-1]) --i;
       --s[i];
       //然后让后面的位置变成9
       for(int j=i+1;j&lt;m;++j) s[j]='9';
       return stoi(s);
    }
};</code></pre> 
<h2>六、坏了的计算机</h2> 
<p><a href="https://leetcode.cn/problems/broken-calculator/" rel="nofollow" title="991. 坏了的计算器 - 力扣（LeetCode）">991. 坏了的计算器 - 力扣（LeetCode）</a></p> 
<p><img alt="" height="969" src="https://images2.imgbox.com/e9/b7/sZnQnP6w_o.png" width="1191"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/9c/04/MFoaKhPu_o.png" width="1200"></p> 
<pre><code class="language-cpp">class Solution {
public:
    int brokenCalc(int startValue, int target) {
        int ret=0;
      while(target&gt;startValue) 
      {
        if(target%2) ++target;
        else target/=2;
        ++ret;
      } 
      return ret+startValue-target;
    }
};</code></pre> 
<h2>七、整数替换</h2> 
<p><a href="https://leetcode.cn/problems/integer-replacement/" rel="nofollow" title="397. 整数替换 - 力扣（LeetCode）">397. 整数替换 - 力扣（LeetCode）</a></p> 
<p><img alt="" height="1030" src="https://images2.imgbox.com/16/16/XRHbPX2m_o.png" width="1171"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/65/5d/PyKIyFpq_o.png" width="1200"></p> 
<p> 解法1：递归+记忆化搜索</p> 
<pre><code class="language-cpp">class Solution {
public:
    unordered_map&lt;int,int&gt; hash;
    int integerReplacement(int n) {
       return dfs(n);
    }
    int dfs(long n) //细节问题 容易溢出
    {
          //模拟 递归 记忆化搜索 
        if(hash.count(n)) return hash[n];
        if(n==1) return hash[1]=0;
        else if(n%2)  return hash[n]=1+min(dfs(n-1),dfs(n+1));
        else  return hash[n]=dfs(n/2)+1;
    }
};</code></pre> 
<p>解法2：贪心</p> 
<pre><code class="language-cpp">class Solution {
public:
    int integerReplacement(int n) {
        int ret=0;
       while(n&gt;1)
       {
        if(n%2==0) n/=2,++ret;
        else
        {
            if(n==3) n=1;
            else if(n%4==1)  n/=2;
            else n=n/2+1;
            ret+=2;
        }
       }
       return ret;
    }
};</code></pre> 
<h2 style="background-color:transparent;">八、可被三数整除的最大和</h2> 
<p><a href="https://leetcode.cn/problems/greatest-sum-divisible-by-three/" rel="nofollow" title="1262. 可被三整除的最大和 - 力扣（LeetCode）">1262. 可被三整除的最大和 - 力扣（LeetCode）</a></p> 
<p><img alt="" height="1008" src="https://images2.imgbox.com/d0/09/CUFTebSj_o.png" width="1182"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/d1/f6/XJsSGHz5_o.png" width="1200"></p> 
<pre><code class="language-cpp">class Solution {
public:
    int maxSumDivThree(vector&lt;int&gt;&amp; nums) {
        // 正难则反
        //sum%3==0  
        //sum%3==1     x1  或者y1y2
        //sum%3==2     x1x2或者y1
        const int INF=0x3f3f3f3f;
        int sum=0,x1=INF,x2=INF,y1=INF,y2=INF;
        for(auto&amp;e:nums)
        {
           sum+=e;
           if(e%3==1) 
           {
             if(e&lt;x1) x2=x1,x1=e;
             else if(e&lt;x2) x2=e;
           }
           else if(e%3==2)
           {
             if(e&lt;y1) y2=y1,y1=e;
             else if(e&lt;y2) y2=e;
           }
        }
        if(sum%3==0) return sum;
        else if(sum%3==1) return max(sum-x1,sum-y1-y2);
        else return max(sum-x1-x2,sum-y1);
    }
};</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/30/ce/DXZBLz5s_o.jpg"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ee72a6bb254beb449398d0e5a6464229/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">后端Web开发之Maven</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6e270be4cac88ca564bfb9cefebb3935/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AI大模型额外学习一：斯坦福AI西部世界小镇笔记（包括部署和源码分析）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>