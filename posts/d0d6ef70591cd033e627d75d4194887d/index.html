<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构-顺序表 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/d0d6ef70591cd033e627d75d4194887d/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构-顺序表">
  <meta property="og:description" content="1.线性表 线性表（linear list）是n个具有相同特性的数据元素的有限序列。 线性表是一种在实际中广泛使用的数据结构，常见的线性表：顺序表、链表、栈、队列、字符串...
线性表在逻辑上是线性结构，也就说是连续的一条直线。但是在物理结构上并不一定是连续的，线性表在物理上存储时，通常以数组和链式结构的形式存储
2.顺序表 2.1概念及结构 顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般情况下采用数组存
储。在数组上完成数据的增删查改。
顺序表一般可以分为：
1. 静态顺序表：使用定长数组存储元素。
2. 动态顺序表：使用动态开辟的数组存储。
2.2 接口实现 静态顺序表只适用于确定知道需要存多少数据的场景。静态顺序表的定长数组导致N定大了，空
间开多了浪费，开少了不够用。所以现实中基本都是使用动态顺序表，根据需要动态的分配空间
大小，所以下面我们实现动态顺序表。
在头文件SeqList.h中声明定义一下这个顺序表，然后声明基本功能，那么顺序表的基本功能就是增删查改，头插头删，尾插尾删。
typedef int SLDataType; typedef struct SeqList { SLDataType* a;//动态开辟的的数组 int size;//有效数据个数 int capacity;//空间大小 }SL; //管理数据-增删查改 void SLInit(SL* ps); void SLDestory(SL* ps); void SLPrint(SL* ps); void SLCheckCapacity(SL* ps); int SLFind(SL* ps, SLDataType x); //头插头删，尾插尾删 void SLPushBack(SL* ps,SLDataType x); void SLPopBack(SL* ps); void SLPushFront(SL* ps, SLDataType x); void SLPopFront(SL* ps); //在pos位置上插入x void SLInSert(SL* ps, int pos, SLDataType x); //删除pos位置上的值 void SLErase(SL* ps, int pos); //修改pos位置的值 void SLModify(SL* ps, int pos, SLDataType x); 2.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-11-05T17:28:53+08:00">
    <meta property="article:modified_time" content="2023-11-05T17:28:53+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构-顺序表</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1.线性表</h2> 
<blockquote> 
 <p>线性表（linear list）是n个具有相同特性的数据元素的有限序列。 线性表是一种在实际中广泛使用的数据结构，常见的线性表：顺序表、链表、栈、队列、字符串...<br> 线性表在逻辑上是线性结构，也就说是连续的一条直线。但是在物理结构上并不一定是连续的，线性表在物理上存储时，通常以数组和链式结构的形式存储</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/93/39/AMLPR4rv_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9d/b8/B77Fkkeu_o.png"></p> 
<hr> 
<h2>2.顺序表</h2> 
<h3>2.1概念及结构</h3> 
<p>顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般情况下采用数组存<br> 储。在数组上完成数据的增删查改。<br> 顺序表一般可以分为：<br><br>                                     1. 静态顺序表：使用定长数组存储元素。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a9/55/d1ODnxAK_o.png"></p> 
<p style="text-align:center;">2. 动态顺序表：使用动态开辟的数组存储。<br><img alt="" src="https://images2.imgbox.com/c8/f3/UdXMKstK_o.png"></p> 
<h3> 2.2 接口实现</h3> 
<p>静态顺序表只适用于确定知道需要存多少数据的场景。静态顺序表的定长数组导致N定大了，空<br> 间开多了浪费，开少了不够用。所以现实中基本都是使用动态顺序表，根据需要动态的分配空间<br> 大小，所以下面我们实现动态顺序表。</p> 
<p>在头文件SeqList.h中声明定义一下这个顺序表，然后声明基本功能，那么顺序表的基本功能就是增删查改，头插头删，尾插尾删。</p> 
<pre><code class="language-cpp">typedef int SLDataType;

typedef struct SeqList
{
	SLDataType* a;//动态开辟的的数组
	int size;//有效数据个数
	int capacity;//空间大小
}SL;

//管理数据-增删查改
void SLInit(SL* ps);
void SLDestory(SL* ps);
void SLPrint(SL* ps);
void SLCheckCapacity(SL* ps);
int SLFind(SL* ps, SLDataType x);

//头插头删，尾插尾删
void SLPushBack(SL* ps,SLDataType x);
void SLPopBack(SL* ps);
void SLPushFront(SL* ps, SLDataType x);
void SLPopFront(SL* ps);

//在pos位置上插入x
void SLInSert(SL* ps, int pos, SLDataType x);

//删除pos位置上的值
void SLErase(SL* ps, int pos);

//修改pos位置的值
void SLModify(SL* ps, int pos, SLDataType x);</code></pre> 
<h3>2.3管理数据-增删查改</h3> 
<p><strong>需要注意的是，这里的传参是传地址。</strong></p> 
<h4>2.3.1初始化</h4> 
<p>首先我们要对顺序表进行初始化，先对这个数组动态开辟一块空间，判断是否成功，如果失败则退出程序，然后size置为0，capacity就是开辟的空间大小。</p> 
<pre><code class="language-cpp">void SLInit(SL* ps)
{
	assert(ps);

	ps-&gt;a = (SLDataType*)malloc(sizeof(SLDataType) * 4);
	if (ps-&gt;a == NULL)
	{
		perror("malloc failed");
		exit(-1);
		//return;
	}

	ps-&gt;size = 0;
	ps-&gt;capacity = 4;
}</code></pre> 
<h4>2.3.2销毁</h4> 
<p>销毁就是把动态开辟给数组的空间释放，然后置为空指针，再把size和capacity置为0.</p> 
<pre><code class="language-cpp">void SLDestroy(SL* ps)
{
	assert(ps);

	free(ps-&gt;a);
	ps-&gt;a = NULL;
	ps-&gt;capacity = ps-&gt;size = 0;
}
</code></pre> 
<h4>2.3.3尾插</h4> 
<p>尾删就是在数组的末尾插入需要的数据，首先我们要判断一下空间是否满了，满了的话就使用realloc进行扩容，使用另外一块空间tmp来接收，如果成功则将tmp这块空间给a，然后将capacity乘上2。数组的末尾也就是size元素个数，因为size是下标加1，所以直接在size这个位置上插入就行了，然后将size++。</p> 
<pre><code class="language-cpp">void SLPushBack(SL* ps, SLDataType x)
{
	assert(ps);
    //满了要扩容
    if(ps-&gt;size==ps-&gt;capacity)
    {
       SLDataType* tmp=(SLDataType*)realloc(pa-&gt;a,ps-&gt;capacity*2*(sizeof(SLDataType)));
       if(tmp==NULL)
       {
          perror("realloc")
          exit(-1);
       }
       ps-&gt;a=tmp;
       ps-&gt;capacity*=2;
     }
	ps-&gt;a[ps-&gt;size] = x;
	ps-&gt;size++;
}
</code></pre> 
<h4>2.3.4打印</h4> 
<p>打印顺序表比较简单，需要注意的是要使用assert断言一下。</p> 
<pre><code class="language-cpp">void SLPrint(SL* ps)
{
	assert(ps);

	for (int i = 0; i &lt; ps-&gt;size; i++)
	{
		printf("%d ", ps-&gt;a[i]);
	}
	printf("\n");
}</code></pre> 
<h4>2.3.5尾删</h4> 
<p>很多人认为尾删要把那个数据置为0，其实这样是没有意义的，因为如果那个位置刚好是0的话，就多余了。其实<span style="color:#fe2c24;">正确的做法是直接size--就可以了</span>，因为如果进行插入的话就直接覆盖了，置不置为0都是一样的效果。因为容量capacity没有变化，所以不需要改变。其实仅仅是这样做的话还是有问题的，因为如果尾删了太多再插入，就越界了，所以要进行检查，ps-&gt;size&gt;0，才能正常进行。</p> 
<pre><code class="language-cpp">void SLPopBack(SL* ps)
{
	assert(ps);

	// 暴力的检查
	assert(ps-&gt;size &gt; 0);

	ps-&gt;a[ps-&gt;size - 1] = 0;
	ps-&gt;size--;

	SLErase(ps, ps-&gt;size - 1);
}</code></pre> 
<h4>2.3.6头插</h4> 
<p>头插就是在下标为0的位置上插入一个数据，那么就需要从后面开始挪动数据，为这个数据腾出空间，end就是size-1的位置，将end位置的数据赋给end+1的位置，这个循环的最后一次执行是将0这个位置的值赋给1这个位置，所以循环条件是end&gt;=0，然后将x这个数据放进0这个位置就行了，最后将size++。</p> 
<pre><code class="language-cpp">void SLPushFront(SL* ps, SLDataType x)
{
	assert(ps);

	//挪动数据
	int end = ps-&gt;size - 1;
	while (end &gt;= 0)
	{
		ps-&gt;a[end + 1] = ps-&gt;a[end];
     	--end;
	}
    ps-&gt;a[0] = x;
	ps-&gt;size++;

}</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/78/0d/Ey6q6WKd_o.png"></p> 
<h4> 2.3.7头删</h4> 
<p>头删就需要将数据从后往前挪动，所以写一个whil循环，结束的位置是size-1这个位置，循环结束后将size--即可，但需要注意的是这个顺序表可能存在是空的情况，所以使用assert判断。</p> 
<pre><code class="language-cpp">void SLPopFront(SL* ps)
{
	assert(ps);

	assert(ps-&gt;size &gt; 0);

	int begin = 1;
	while (begin &lt; ps-&gt;size)
	{
		ps-&gt;a[begin - 1] = ps-&gt;a[begin];
		++begin;
	}

	ps-&gt;size--;
}</code></pre> 
<h4>2.3.8检查空间</h4> 
<p>这个函数的目的是检查空间是否满了，如果满了的话则扩容至2倍。</p> 
<pre><code class="language-cpp">void SLCheckCapacity(SL* ps)
{
	assert(ps);

	// 满了要扩容
	if (ps-&gt;size == ps-&gt;capacity)
	{
		SLDataType* tmp = (SLDataType*)realloc(ps-&gt;a, ps-&gt;capacity * 2 * (sizeof(SLDataType)));
		if (tmp == NULL)
		{
			perror("realloc failed");
			exit(-1);
		}

		ps-&gt;a = tmp;
		ps-&gt;capacity *= 2;
	}
}</code></pre> 
<h4>2.3.8在pos位置插入x</h4> 
<p>首先要判断一下插入的这个pos是不是合理的，应该是&gt;=0&amp;&amp;&lt;=size，然后调用SLCheakCapacity检查一下空间是不是满了。挪动数据从前往后挪动，直到end=pos，然后将x赋给a[pos]，最后将size++。</p> 
<pre><code class="language-cpp">void SLInsert(SL* ps, int pos, SLDataType x)
{
	assert(ps);

	assert(pos &gt;= 0 &amp;&amp; pos &lt;= ps-&gt;size);
	SLCheckCapacity(ps);

	int end = ps-&gt;size - 1;
	while (end &gt;= pos)
	{
		ps-&gt;a[end + 1] = ps-&gt;a[end];
		--end;
	}
	ps-&gt;a[pos] = x;
	ps-&gt;size++;
}</code></pre> 
<p>那么当我们写了SLInsert这个函数之后，就可以复用一下了。</p> 
<p>在头插中：</p> 
<pre><code class="language-cpp">void SLPushFront(SL* ps, SLDataType x)
{
	assert(ps);

	//SLCheckCapacity(ps);

	 挪动数据
	//int end = ps-&gt;size - 1;
	//while (end &gt;= 0)
	//{
	//	ps-&gt;a[end + 1] = ps-&gt;a[end];
	//	--end;
	//}
	//ps-&gt;a[0] = x;
	//ps-&gt;size++;

	SLInsert(ps, 0, x);
}</code></pre> 
<p> 在尾插中：</p> 
<pre><code class="language-cpp">void SLPushBack(SL* ps, SLDataType x)
{
	assert(ps);

	/*SLCheckCapacity(ps);

	ps-&gt;a[ps-&gt;size] = x;
	ps-&gt;size++;*/
	SLInsert(ps, ps-&gt;size, x);
}</code></pre> 
<h4>2.3.9删除pos位置的值</h4> 
<p>删除的话就不能等于size这个位置了，因为size这个位置是空的。删除的话就是将pos后的数据覆盖到pos这个位置，然后不停的往前挪，最后size--。</p> 
<pre><code class="language-cpp">void SLErase(SL* ps, int pos)
{
	assert(ps);

	assert(pos &gt;= 0 &amp;&amp; pos &lt; ps-&gt;size);

	int begin = pos + 1;
	while (begin &lt; ps-&gt;size)
	{
		ps-&gt;a[begin - 1] = ps-&gt;a[begin];
		++begin;
	}

	ps-&gt;size--;
}</code></pre> 
<h4>2.3.10修改</h4> 
<p>这里直接修改就是了。</p> 
<pre><code class="language-cpp">void SLModify(SL* ps, int pos, SLDataType x)
{
	assert(ps);

	assert(pos &gt;= 0 &amp;&amp; pos &lt; ps-&gt;size);

	ps-&gt;a[pos] = x;
}</code></pre> 
<hr> 
<p><strong>今天的分享到这里就结束啦！谢谢老铁们的阅读，让我们下期再见。</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a66290dbdc710f61fe9d90cddc995f6c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MySQL日期时间操作函数（全的）-九五小庞</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/612b9f18c26fc8c43ce38d73abbe9a53/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java Jar 包还不知道怎么反编译，赶紧看看这个 IDEA 插件！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>