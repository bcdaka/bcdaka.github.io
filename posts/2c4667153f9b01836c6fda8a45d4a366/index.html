<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>STM32 OV7725摄像头模块识别颜色物体（1）--HSL二值化和腐蚀中心算法，并用串口输出数据 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/2c4667153f9b01836c6fda8a45d4a366/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="STM32 OV7725摄像头模块识别颜色物体（1）--HSL二值化和腐蚀中心算法，并用串口输出数据">
  <meta property="og:description" content="目录
前言
一、摄像头采集数据流程
二、如何将图像显示到电脑上
三、图像二值化
1、什么是RGB?
2、RGB565转RGB888
I、RGB565和RGB888的区别
II、代码
3、RGB转HSL
I、什么是HSL
II、转换公式
III、代码
3、输出一张摄像头二值化图片
I、原理
II、代码 四、简单的物体识别
1、原理参考
2、识别代码
3、显示代码
总结
前言 前阵子用STM32弄摄像头，断断续续有段时间，也在网上翻阅了不少资料，写篇博客记录一下学习过程。最后成功识别单个物体，图形和多个物体暂不支。
一、摄像头采集数据流程 (1) 利用 SIO_C、SIO_D 引脚通过 SCCB 协议向 OV7725 的寄存器写入初始化配置；
(2) 初始化完成后，OV7725 传感器会使用 VGA 时序输出图像数据，它的 VSYNC 会
首先输出帧有效信号（低电平跳变），当外部的控制器（如 STM32）检测到该信号
时，把 WEN 引脚设置为高电平，并且使用 WRST 引脚复位 FIFO 的写指针到 0 地
址；
(3) 随着 OV7725 继续按 VGA 时序输出图像数据，它在传输每行有效数据时， HREF
引脚都会持续输出高电平，由于 WEN 和 HREF 同时为高电平输入至与非门，使得
其连接到 FIFO WE 引脚的输出为低电平，允许向 FIFO 写入数据，所以在这期间，">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-08-24T15:38:07+08:00">
    <meta property="article:modified_time" content="2023-08-24T15:38:07+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STM32 OV7725摄像头模块识别颜色物体（1）--HSL二值化和腐蚀中心算法，并用串口输出数据</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p id="main-toc"><strong>目录</strong></p> 
 <p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
 <p id="%E4%B8%80%E3%80%81%E6%91%84%E5%83%8F%E5%A4%B4%E9%87%87%E9%9B%86%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E6%91%84%E5%83%8F%E5%A4%B4%E9%87%87%E9%9B%86%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B" rel="nofollow">一、摄像头采集数据流程</a></p> 
 <p id="%E4%BA%8C%E3%80%81%E5%A6%82%E4%BD%95%E5%B0%86%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA%E5%88%B0%E7%94%B5%E8%84%91%E4%B8%8A-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%A6%82%E4%BD%95%E5%B0%86%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA%E5%88%B0%E7%94%B5%E8%84%91%E4%B8%8A" rel="nofollow">二、如何将图像显示到电脑上</a></p> 
 <p id="%C2%A0%E4%B8%89%E3%80%81%E5%9B%BE%E5%83%8F%E4%BA%8C%E5%80%BC%E5%8C%96-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%B8%89%E3%80%81%E5%9B%BE%E5%83%8F%E4%BA%8C%E5%80%BC%E5%8C%96" rel="nofollow"> 三、图像二值化</a></p> 
 <p id="1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFRGB%3F-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFRGB%3F" rel="nofollow">1、什么是RGB?</a></p> 
 <p id="2%E3%80%81RGB565%E8%BD%ACRGB888-toc" style="margin-left:40px;"><a href="#2%E3%80%81RGB565%E8%BD%ACRGB888" rel="nofollow">2、RGB565转RGB888</a></p> 
 <p id="I%E3%80%81RGB565%E5%92%8CRGB888%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#I%E3%80%81RGB565%E5%92%8CRGB888%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">I、RGB565和RGB888的区别</a></p> 
 <p id="II%E3%80%81%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#II%E3%80%81%E4%BB%A3%E7%A0%81" rel="nofollow">II、代码</a></p> 
 <p id="-toc" style="margin-left:40px;"></p> 
 <p id="3%E3%80%81RGB%E8%BD%ACHSL-toc" style="margin-left:40px;"><a href="#3%E3%80%81RGB%E8%BD%ACHSL" rel="nofollow">3、RGB转HSL</a></p> 
 <p id="I%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFHSL-toc" style="margin-left:80px;"><a href="#I%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFHSL" rel="nofollow">I、什么是HSL</a></p> 
 <p id="%C2%A0II%E3%80%81%E8%BD%AC%E6%8D%A2%E5%85%AC%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%C2%A0II%E3%80%81%E8%BD%AC%E6%8D%A2%E5%85%AC%E5%BC%8F" rel="nofollow"> II、转换公式</a></p> 
 <p id="%C2%A0III%E3%80%81%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%C2%A0III%E3%80%81%E4%BB%A3%E7%A0%81" rel="nofollow"> III、代码</a></p> 
 <p id="3%E3%80%81%E8%BE%93%E5%87%BA%E4%B8%80%E5%BC%A0%E6%91%84%E5%83%8F%E5%A4%B4%E4%BA%8C%E5%80%BC%E5%8C%96%E5%9B%BE%E7%89%87-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E8%BE%93%E5%87%BA%E4%B8%80%E5%BC%A0%E6%91%84%E5%83%8F%E5%A4%B4%E4%BA%8C%E5%80%BC%E5%8C%96%E5%9B%BE%E7%89%87" rel="nofollow">3、输出一张摄像头二值化图片</a></p> 
 <p id="I%E3%80%81%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#I%E3%80%81%E5%8E%9F%E7%90%86" rel="nofollow">I、原理</a></p> 
 <p id="II%E3%80%81%E4%BB%A3%E7%A0%81%C2%A0-toc" style="margin-left:80px;"><a href="#II%E3%80%81%E4%BB%A3%E7%A0%81%C2%A0" rel="nofollow">II、代码 </a></p> 
 <p id="%E5%9B%9B%E3%80%81%E7%AE%80%E5%8D%95%E7%9A%84%E7%89%A9%E4%BD%93%E8%AF%86%E5%88%AB-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E7%AE%80%E5%8D%95%E7%9A%84%E7%89%A9%E4%BD%93%E8%AF%86%E5%88%AB" rel="nofollow">四、简单的物体识别</a></p> 
 <p id="1%E3%80%81%E5%8E%9F%E7%90%86%E5%8F%82%E8%80%83-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E5%8E%9F%E7%90%86%E5%8F%82%E8%80%83" rel="nofollow">1、原理参考</a></p> 
 <p id="%C2%A02%E3%80%81%E8%AF%86%E5%88%AB%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#%C2%A02%E3%80%81%E8%AF%86%E5%88%AB%E4%BB%A3%E7%A0%81" rel="nofollow"> 2、识别代码</a></p> 
 <p id="3%E3%80%81%E6%98%BE%E7%A4%BA%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E6%98%BE%E7%A4%BA%E4%BB%A3%E7%A0%81" rel="nofollow">3、显示代码</a></p> 
 <p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">总结</a></p> 
 <hr id="hr-toc"> 
 <p></p> 
 <p></p> 
</blockquote> 
<hr> 
<h2 id="%E5%89%8D%E8%A8%80"><a id="_7"></a>前言</h2> 
<p>前阵子用STM32弄摄像头，断断续续有段时间，也在网上翻阅了不少资料，写篇博客记录一下学习过程。最后成功识别单个物体，图形和多个物体暂不支。</p> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E6%91%84%E5%83%8F%E5%A4%B4%E9%87%87%E9%9B%86%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B"><a id="pandas_16"></a>一、摄像头采集数据流程</h2> 
<p style="margin-left:0;text-align:justify;">(1) 利用 SIO_C、SIO_D 引脚通过 SCCB 协议向 OV7725 的寄存器写入初始化配置；</p> 
<p style="margin-left:0;text-align:justify;">(2) 初始化完成后，OV7725 传感器会使用 VGA 时序输出图像数据，它的 VSYNC 会</p> 
<p style="margin-left:0;text-align:justify;">首先输出帧有效信号（低电平跳变），当外部的控制器（如 STM32）检测到该信号</p> 
<p style="margin-left:0;text-align:justify;">时，把 WEN 引脚设置为高电平，并且使用 WRST 引脚复位 FIFO 的写指针到 0 地</p> 
<p style="margin-left:0;text-align:justify;">址；</p> 
<p style="margin-left:0;text-align:justify;">(3) 随着 OV7725 继续按 VGA 时序输出图像数据，它在传输每行有效数据时， HREF</p> 
<p style="margin-left:0;text-align:justify;">引脚都会持续输出高电平，由于 WEN 和 HREF 同时为高电平输入至与非门，使得</p> 
<p style="margin-left:0;text-align:justify;">其连接到 FIFO WE 引脚的输出为低电平，允许向 FIFO 写入数据，所以在这期间，</p> 
<p style="margin-left:0;text-align:justify;">OV7725 通过它的 PCLK 和 D[0:7]信号线把图像数据存储到 FIFO 中，由于前面复</p> 
<p style="margin-left:0;text-align:justify;">位了写指针，所以图像数据是从 FIFO 的 0 地址开始记录的；</p> 
<p style="margin-left:0;text-align:justify;">(4) 各行图像数据持续传输至 FIFO，受 HREF 控制的 WE 引脚确保了写入到 FIFO 中</p> 
<p style="margin-left:0;text-align:justify;">的都是有效的图像数据，OV7725 输出完一帧数据时，VSYNC 会再次输出帧有效</p> 
<p style="margin-left:0;text-align:justify;">信号，表示一帧图像已输出完成；</p> 
<p style="margin-left:0;text-align:justify;">(5) 控制器检测到上述 VSYNC 信号后，可知 FIFO 中已存储好一帧图像数据，这时控</p> 
<p style="margin-left:0;text-align:justify;">制 WEN 引脚为低电平，使得 FIFO 禁止写入，防止 OV7725 持续输出的下一帧数</p> 
<p style="margin-left:0;text-align:justify;">据覆盖当前 FIFO 数据；</p> 
<p style="margin-left:0;text-align:justify;">(6) 控制器使用RRST复位读指针到FIFO的0地址，然后通过FIFO的RCLK和DO[0:7]</p> 
<p style="margin-left:0;text-align:justify;">引脚，从 0 地址开始把 FIFO 缓存的整帧图像数据读取出来。在这期间，OV7725</p> 
<p style="margin-left:0;text-align:justify;">是持续输出它采集到的图像数据的，但由于禁止写入 FIFO，这些数据被丢弃了；</p> 
<p style="margin-left:0;text-align:justify;">(7) 控制器使用 WRST 复位写指针到 FIFO 的 0 地址，然后等待新的 VSYNC 有效信号</p> 
<p style="margin-left:0;text-align:justify;">到来，检测到后把 WEN 引脚设置为高电平，恢复 OV7725 向 FIFO 的写入权限，</p> 
<p style="margin-left:0;text-align:justify;">OV7725 输出的新一帧图像数据会被写入到 FIFO 的 0 地址中，重复上述过程。</p> 
<p class="img-center"><img alt="" height="699" src="https://images2.imgbox.com/70/71/DkOGjEkJ_o.png" width="887"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p>网上也有很多现成的文章，分享几个链接</p> 
<p>摄像头原理：</p> 
<p><a href="https://blog.csdn.net/qq_35653974/article/details/126498896?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169002937116800213043797%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169002937116800213043797&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-126498896-null-null.142%5Ev90%5Einsert_down28v1,239%5Ev3%5Einsert_chatgpt&amp;utm_term=stm32%E6%91%84%E5%83%8F%E5%A4%B4&amp;spm=1018.2226.3001.4187" title="stm32 OV7670摄像头模块的介绍以及应用（SCCB的使用）_闰土小蒋的博客-CSDN博客">stm32 OV7670摄像头模块的介绍以及应用（SCCB的使用）_闰土小蒋的博客-CSDN博客</a></p> 
<p>正点原子开发板程序：</p> 
<p><a href="http://www.openedv.com/docs/modules/camera/ov7725-fifo.html" rel="nofollow" title="http://www.openedv.com/docs/modules/camera/ov7725-fifo.html">http://www.openedv.com/docs/modules/camera/ov7725-fifo.html</a></p> 
<p></p> 
<h2 id="%E4%BA%8C%E3%80%81%E5%A6%82%E4%BD%95%E5%B0%86%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA%E5%88%B0%E7%94%B5%E8%84%91%E4%B8%8A"><a id="_19"></a>二、如何将图像显示到电脑上</h2> 
<p>使用串口发送数据到电脑，用山外调试助手显示，这里的波特率使用256000，因为调试助手的最大也只能是256000，图像配置，宽：320，高：240，<span style="color:#fe2c24;">RGB565大端</span><span style="color:#0d0016;">(这个是个大坑)</span></p> 
<p>一副图像的通信协议为：[0x01] [0xFE][…数据…][0xFE] [0x01]</p> 
<p>[…数据…] 是图像的数据，一帧图像有多少数据，这里的数据长度就有多少。换句话说， […数据…]与图像的格式，图像的宽高有关。此处的图像数据，都是从上往下，从左往右存储 的。 只有下位机发送的数据与上位机配置的格式的长度相同时，才可正确识别图像格式，从 而正确显示图像。 下位机发送图像时，先发送帧头：0x01,0xFE，接着发送图像数据，最后发送帧尾： 0xFE,0x01 完成一副图像发送。</p> 
<p></p> 
<p class="img-center"><img alt="" height="1179" src="https://images2.imgbox.com/a0/06/XxX6PfSF_o.png" width="1200"></p> 
<p>链接：https://pan.baidu.com/s/1eA3rhtNiocKxtH0rxvyGzg?pwd=0722 <br> 提取码：0722</p> 
<p>摄像头采集代码如下：</p> 
<pre><code class="language-c">        OV7725_RRST(0);                //开始复位读指针 
        OV7725_RCK_L;
        OV7725_RCK_H;
        OV7725_RCK_L;
        OV7725_RRST(1);                //复位读指针结束 
        OV7725_RCK_H;
   
        while(USART_GetFlagStatus(UART4, USART_FLAG_TC)==RESET);      //判断是否发送完成。
        USART_SendData(UART4, 0x01);
        while(USART_GetFlagStatus(UART4, USART_FLAG_TC)==RESET);      //判断是否发送完成。
        USART_SendData(UART4, 0xfe);
       
        for(x_size=0;x_size&lt;240;x_size++)
        {
            for(y_size=0;y_size&lt;320;y_size++)
            {
                OV7725_RCK_L;
                color=GPIOE-&gt;IDR;    //读数据
                OV7725_RCK_H;
                colorH=(color&gt;&gt;8) &amp;0xff;
                OV7725_RCK_L;
                color=GPIOE-&gt;IDR ;    //读数据
                OV7725_RCK_H; 
                colorL=(color&gt;&gt;8) &amp;0xff;
                
                while(USART_GetFlagStatus(UART4, USART_FLAG_TC)==RESET);      //判断是否发送完成。
                USART_SendData(UART4, colorH);
                while(USART_GetFlagStatus(UART4, USART_FLAG_TC)==RESET);      //判断是否发送完成。
                USART_SendData(UART4, colorL);
            }
        }

        while(USART_GetFlagStatus(UART4, USART_FLAG_TC)==RESET);      //判断是否发送完成。
        USART_SendData(UART4, 0xfe);
        while(USART_GetFlagStatus(UART4, USART_FLAG_TC)==RESET);      //判断是否发送完成。
        USART_SendData(UART4, 0x01);
</code>
</pre> 
<h2 id="%C2%A0%E4%B8%89%E3%80%81%E5%9B%BE%E5%83%8F%E4%BA%8C%E5%80%BC%E5%8C%96"> 三、图像二值化</h2> 
<h3 id="1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFRGB%3F">1、什么是RGB?</h3> 
<p style="margin-left:0;">        RGB是从颜色发光的原理来设计定的，通俗点说它的颜色混合方式就好像有红、绿、蓝三盏灯，当它们的光相互叠合的时候，色彩相混，而亮度却等于两者亮度之总和，越混合亮度越高，即加法混合。</p> 
<p style="margin-left:0;">        红、绿、蓝三个颜色通道每种色各分为256阶亮度，在0时“灯”最弱——是关掉的，而在255时“灯”最亮。当三色灰度数值相同时，产生不同灰度值的灰色调，即三色灰度都为0时，是最暗的黑色调；三色灰度都为255时，是最亮的白色调。</p> 
<p style="margin-left:0;">        在电脑中，RGB的所谓“多少”就是指亮度，并使用整数来表示。通常情况下，RGB各有256级亮度，用数字表示为从0、1、2...直到255。注意虽然数字最高是255，但0也是数值之一，因此共256级。</p> 
<p class="img-center"><img alt="" height="475" src="https://images2.imgbox.com/a1/bb/xjIEMZCG_o.png" width="966"></p> 
<p></p> 
<h3 id="2%E3%80%81RGB565%E8%BD%ACRGB888">2、RGB565转RGB888</h3> 
<h4 id="I%E3%80%81RGB565%E5%92%8CRGB888%E7%9A%84%E5%8C%BA%E5%88%AB">I、RGB565和RGB888的区别</h4> 
<p style="margin-left:0;text-align:justify;">在计算机中图像基本是以RGB888格式显示的，24位图每个像素保存了32bit的数据，即RGB888+Alpha，Alpha就是半透明填充字节。对于真彩的图像而言，肉眼在16bit的时候已经难以分辨了，有些时候，可以将RGB888转换为RGB565来存储，减少了存储器的容量的同时，降低了数据量；在显示的时候，再次把RGB565转换为RGB888，实现数据宽度的匹配</p> 
<p style="margin-left:0;text-align:justify;">RGB888-&gt;RGB565</p> 
<p style="margin-left:0;text-align:justify;">只要提取相应单色高位即可(R5 G6 B5)，但会导致低位的缺失，影响精度，而且无法恢复</p> 
<p style="margin-left:0;text-align:justify;">RGB565-&gt;RGB888</p> 
<p style="margin-left:0;text-align:justify;">填充相应单色低位即可</p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="207" src="https://images2.imgbox.com/96/51/SqUEsw5U_o.png" width="1200"></p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="201" src="https://images2.imgbox.com/30/bd/pdFlUKjM_o.png" width="1200"></p> 
<h4 id="II%E3%80%81%E4%BB%A3%E7%A0%81" style="margin-left:0px;text-align:justify;">II、代码</h4> 
<h3><a id="2_34"></a></h3> 
<pre><code class="language-cpp">typedef struct 					//RGB888
{
	unsigned char Red;			//红色，[0,255]
	unsigned char Green;        //绿色，[0,255]
	unsigned char Blue;         //蓝色，[0,255]
}COLOR_RGB;

void RGB565_To_RGB888(u16 rgb,COLOR_RGB *color_rgb)
{
	color_rgb-&gt;Red 	    = (unsigned char)( ( rgb &amp; 0xF800 ) &gt;&gt; 8 );
	color_rgb-&gt;Green    = (unsigned char)( ( rgb &amp; 0x07E0 ) &gt;&gt; 3 );
	color_rgb-&gt;Blue 	= (unsigned char)( ( rgb &amp; 0x001F ) &lt;&lt; 3 );	
}</code></pre> 
<h3 id="3%E3%80%81RGB%E8%BD%ACHSL">3、RGB转HSL</h3> 
<h4 id="I%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFHSL">I、什么是HSL</h4> 
<p><img alt="" height="126" src="https://images2.imgbox.com/46/f9/YqLAYuLI_o.png" width="167"></p> 
<p> HSL的H(hue)分量，代表的是人眼所能感知的颜色范围，这些颜色分布在一个平面的色相环上，取值范围是0°到360°的圆心角，每个角度可以代表一种颜色。色相值的意义在于，我们可以在不改变光感的情况下，通过旋转色相环来改变颜色。在实际应用中，我们需要记住色相环上的六大主色，用作基本参照：360°/0°红、60°黄、120°绿、180°青、240°蓝、300°洋红，它们在色相环上按照60°圆心角的间隔排列</p> 
<p><img alt="" height="197" src="https://images2.imgbox.com/37/ec/HcjOSSmr_o.png" width="362"></p> 
<p style="margin-left:0;text-align:left;">HSL的S(saturation)分量，指的是色彩的饱和度，它用0%至100%的值描述了相同色相、明度下色彩纯度的变化。数值越大，颜色中的灰色越少，颜色越鲜艳，呈现一种从灰度到纯色的变化。</p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="115" src="https://images2.imgbox.com/4e/08/fQMR91VA_o.png" width="554"></p> 
<p style="margin-left:0;text-align:left;">HSL的L(lightness)分量，指的是色彩的明度，作用是控制色彩的明暗变化。它同样使用了0%至100%的取值范围。数值越小，色彩越暗，越接近于黑色；数值越大，色彩越亮，越接近于白色。</p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="115" src="https://images2.imgbox.com/ad/13/VtMV34dZ_o.png" width="554"></p> 
<h4 id="%C2%A0II%E3%80%81%E8%BD%AC%E6%8D%A2%E5%85%AC%E5%BC%8F"> II、转换公式</h4> 
<p><img alt="" height="375" src="https://images2.imgbox.com/6f/e9/nB34IYqq_o.png" width="1096"></p> 
<h4 id="%C2%A0III%E3%80%81%E4%BB%A3%E7%A0%81"> III、代码</h4> 
<pre><code class="language-cs">typedef struct					//HLS颜色
{
	unsigned char Hue;			//色度，[0,240]				
	unsigned char Lightness;	//亮度，[0,240]	     
	unsigned char Saturation;	//饱和度，[0,240]	     
}COLOR_HLS;

#define maxOf3Values( v1, v2, v3 )			( (v1&gt;v2) ? ( (v1&gt;v3) ? (v1) : (v3) ) : ( (v2&gt;v3) ? (v2) : (v3) ) ) //取rgb中的最大值
#define minOf3Values( v1, v2, v3 )			( (v1&lt;v2) ? ( (v1&lt;v3) ? (v1) : (v3) ) : ( (v2&lt;v3) ? (v2) : (v3) ) ) //取rgb中的最小值


void RGB888_TO_HSL(COLOR_RGB* color_rgb, COLOR_HLS* color_hls)
{
	unsigned char r, g, b;
	unsigned char h, l, s;
	unsigned char max, min, dif;
	
	r = color_rgb-&gt;Red;
	g = color_rgb-&gt;Green;
	b = color_rgb-&gt;Blue;
	
	max = maxOf3Values( r, g, b );  //取rgb中的最大值
	min = minOf3Values( r, g, b );  //取rgb中的最小值
	dif = max - min;                //计算最大值和最小值的差值
    
	//计算l，亮度
	l = ( max + min ) * 240 / 255 / 2;
	//计算h，色度
	if( max == min )//无定义 RGB一样  黑灰白
	{
		s = 0;//饱和度0
		h = 0;//色度0
	}
	else
	{
		/*计算色度h*/
		if( max == r )      //如果R值最大
		{
			if( g &gt;= b )    //h介于0到40
			{
				h = 40 * ( g - b ) / dif;
			}
			else if( g &lt; b )//h介于200到240
			{
				h = 40 * ( g - b ) / dif + 240;
			}
		}
		else if( max == g )
		{
			h = 40 * ( b - r ) / dif + 80;
		}
		else if( max == b )
		{
			h = 40 * ( r - g ) / dif + 160;
		}
		/*计算饱和度s*/
		if( l == 0 )
		{
			s = 0;
		}
		else if( l &lt;= 120 )      /* 0&lt;l&lt;=1/2 */
		{
			s = dif * 240 / ( max + min );                  
		}
		else                    /* l&gt;1/2 */
		{
			s = dif * 240 / ( 480 - ( max + min ) );        
		}		 
	}   
    color_hls-&gt;Hue = h;				//色度
	color_hls-&gt;Lightness = l;		//亮度
	color_hls-&gt;Saturation = s;		//饱和度
}</code></pre> 
<h3 id="3%E3%80%81%E8%BE%93%E5%87%BA%E4%B8%80%E5%BC%A0%E6%91%84%E5%83%8F%E5%A4%B4%E4%BA%8C%E5%80%BC%E5%8C%96%E5%9B%BE%E7%89%87">3、输出一张摄像头二值化图片</h3> 
<h4 id="I%E3%80%81%E5%8E%9F%E7%90%86">I、原理</h4> 
<p>摄像头采集到的每个像素点，先由RGB格式转换成HSL格式，再与定义阈值进行对比，判断颜色是否和定义颜色匹配</p> 
<h4 id="II%E3%80%81%E4%BB%A3%E7%A0%81%C2%A0">II、代码 </h4> 
<pre><code class="language-cs">typedef struct					//判定为目标的条件
{
	unsigned char H_MIN;		//目标最小色度
	unsigned char H_MAX;		//目标最大色度
	
	unsigned char S_MIN;		//目标最小饱和度
	unsigned char S_MAX;		//目标最大饱和度
	
	unsigned char L_MIN;		//目标最小亮度
	unsigned char L_MAX;		//目标最大亮度
	
	unsigned short WIDTH_MIN;	//目标最小宽度
	unsigned short HEIGHT_MIN;	//目标最小高度
	
	unsigned short WIDTH_MAX;   //目标最大宽度
	unsigned short HEIGHT_MAX;	//目标最大高度
}TARGET_CONDITION;

int ColorMatch(const COLOR_HLS* color_hls, const TARGET_CONDITION* condition )
{
	if(	color_hls-&gt;Lightness &gt;= condition-&gt;L_MIN &amp;&amp; color_hls-&gt;Lightness &lt;= condition-&gt;L_MAX &amp;&amp;
		color_hls-&gt;Saturation &gt;= condition-&gt;S_MIN &amp;&amp; color_hls-&gt;Saturation &lt;= condition-&gt;S_MAX )   //比较饱和度和亮度
    {      
        if( color_hls-&gt;Hue &gt;= condition-&gt;H_MIN &amp;&amp; color_hls-&gt;Hue &lt;= condition-&gt;H_MAX )   //颜色在范围内
        {   
            return 1;
        }       
        else if( condition-&gt;H_MAX &lt; condition-&gt;H_MIN )  //设定的最大颜色小于最小颜色 说明有向下溢出 可能需要和高位颜色匹配            
        {
            /*0——有效——最大值——无效——最小值——有效——240*/
            if( color_hls-&gt;Hue &lt;= condition-&gt;H_MAX )     //小于最大值
                return 1;
            if( color_hls-&gt;Hue &gt;= condition-&gt;H_MIN )     //大于最小值
                return 1;
        } 
    }
	return 0;
}</code></pre> 
<p>判断颜色是否和定义颜色匹配。</p> 
<p>输入变量，color_hls：COLOR_HLS结构体，存储HLS格式颜色数据； </p> 
<p>                 condition ：TARGET_CONDITION结构体，存放希望的颜色数据阈值。</p> 
<p>返回数据，1：像素点颜色在目标范围内；0：像素点颜色不在目标范围内。</p> 
<pre><code class="language-cs">u8 Bmp_Minimize_SDRAM[240][40];  /*用于存放二值化后像素点数据，Bmp_Minimize_SDRAM[X][Y]*/

TARGET_CONDITION condition0={
	40,		  //目标最小色度，H_MIN
	80,       //目标最大色度，H_MAX
	           
	0,        //目标最小饱和度，S_MIN
	240,       //目标最大饱和度，S_MAX
	           
	0,        //目标最小亮度，L_MIN
	240,       //目标最大亮度，L_MAX
	           
	40,        //目标最小宽度，WIDTH_MIN
	40,        //目标最小高度，HEIGHT_MIN
	           
	240,       //目标最大宽度，WIDTH_MAX
	320        //目标最大高度，HEIGHT_MAX
};

for(x_size=0;x_size&lt;240;x_size++)   //此种方式可以兼容任何彩屏,但是速度很慢
{
    for(y_size=0;y_size&lt;320;y_size++)
    {
        OV7725_RCK_L;
        color=GPIOE-&gt;IDR;	//读数据
        OV7725_RCK_H;
        colorH=(color&gt;&gt;8) &amp;0xff;
        OV7725_RCK_L;
        color=GPIOE-&gt;IDR ;	//读数据
        OV7725_RCK_H; 
        colorL=(color&gt;&gt;8) &amp;0xff;
        
        color=(colorH&lt;&lt;8)|colorL;

        RGB565_TO_HSL(color,&amp;hls_value);        /*RGB565转换为HLS*/
        
        if(y_size%8==0)
        {
            Bmp_Minimize_SDRAM[x_size][y_size/8]=color_buffer;      /*二值化后的数据，存入缓存*/
        }
        color_buffer&lt;&lt;=1;
        color_buffer|=ColorMatch(&amp;hls_value,&amp;condition0);
    }
}</code></pre> 
<p>摄像头采集数据二值化，由于STM32F1内存有限，存放不了一帧320*240的彩色图像，故将处理好后的数据存入数组</p> 
<pre><code class="language-cs">while(USART_GetFlagStatus(UART4, USART_FLAG_TC)==RESET);      //判断是否发送完成。
USART_SendData(UART4, 0x01);
while(USART_GetFlagStatus(UART4, USART_FLAG_TC)==RESET);      //判断是否发送完成。
USART_SendData(UART4, 0xfe);
for(y_size=0;y_size&lt;240;y_size++)     /*数组数据串口打印到电脑*/
{
    for(x_size=0;x_size&lt;40;x_size++)
    {
        color=Bmp_Minimize_SDRAM[y_size][x_size+1];
        for(color_buffer=0;color_buffer&lt;8;color_buffer++)
        {
            if((color&lt;&lt;color_buffer) &amp;0x80)
            {
                while(USART_GetFlagStatus(UART4, USART_FLAG_TC)==RESET);      //判断是否发送完成。
                USART_SendData(UART4, 0xff);
                while(USART_GetFlagStatus(UART4, USART_FLAG_TC)==RESET);      //判断是否发送完成。
                USART_SendData(UART4, 0xff);
            }
            else
            {
                while(USART_GetFlagStatus(UART4, USART_FLAG_TC)==RESET);      //判断是否发送完成。
                USART_SendData(UART4, 0x00);
                while(USART_GetFlagStatus(UART4, USART_FLAG_TC)==RESET);      //判断是否发送完成。
                USART_SendData(UART4, 0x00);                        
            }
        }
    }
}
while(USART_GetFlagStatus(UART4, USART_FLAG_TC)==RESET);      //判断是否发送完成。
USART_SendData(UART4, 0xfe);
while(USART_GetFlagStatus(UART4, USART_FLAG_TC)==RESET);      //判断是否发送完成。
USART_SendData(UART4, 0x01);</code></pre> 
<p>将存放在缓存中的二值化数据，通过简单位操作输出到调试助手</p> 
<p><img alt="" height="1186" src="https://images2.imgbox.com/14/b0/XGknc4Av_o.png" width="1200"></p> 
<h2 id="%E5%9B%9B%E3%80%81%E7%AE%80%E5%8D%95%E7%9A%84%E7%89%A9%E4%BD%93%E8%AF%86%E5%88%AB">四、简单的物体识别</h2> 
<h3 id="1%E3%80%81%E5%8E%9F%E7%90%86%E5%8F%82%E8%80%83">1、原理参考</h3> 
<p>首先遍历寻找腐蚀中心，然后在之前腐蚀中心点处进行迭代向外寻找新的腐蚀中心。腐蚀算法从该点开始分别向上下左右四个方向进行读点，若点的颜色符合条件则往外读，等四个方向都结束后得到四个边缘点的坐标，记左边缘点的x轴坐标为left，右边缘点的x轴坐标为right，上边缘点的y轴坐标为up，下边缘点的y轴坐标为bottom，那么坐标( (right-left)/2 , (up-bottom)/2 ) 即为新的腐蚀中心。当确定4个点通过，泽围绕4个点画框，将色块识别区域框起来。</p> 
<p>2、腐蚀中心算法（如下图详解）<br> 一个40/3=13 1313大小的色块为单位进行识别<br> 每次只读取这色块的以y的2/1 为点（也就是这个1313色块y轴为中心点） x轴向右开始查询识别颜色 如识别失败个数大于6次 则认为这一个1313的色块无效 跳出循环 继续查询下一个1313的色块。</p> 
<p class="img-center"><img alt="" height="341" src="https://images2.imgbox.com/92/4c/2G9lcPDa_o.png" width="675"></p> 
<p></p> 
<p>如果失败次数少于6次则改变查询方向 查询这色块的以X/2 为点 对y轴进行查询方法同上 ，如果y轴有6次失败则，退出循环不认同这个色块合格（因为太小了，失败次数又多），但如果少于六次失败，则认为这个色块识别成功 并记录下这个色块的中心点，这就是腐蚀中心 /。</p> 
<p> </p> 
<p class="img-center"><img alt="" height="326" src="https://images2.imgbox.com/3a/b2/QexMQs1Q_o.png" width="652"></p> 
<p> </p> 
<h3 id="%C2%A02%E3%80%81%E8%AF%86%E5%88%AB%E4%BB%A3%E7%A0%81"> 2、识别代码</h3> 
<pre><code class="language-cs">extern u8 Bmp_Minimize_SDRAM[240][40];

static uint8_t ReadColor( uint16_t usX, uint16_t usY)
{
    uint8_t color_value;
    usY=usY/8;
    color_value=Bmp_Minimize_SDRAM[usX][usY];
    usY=usY%8;
    return (color_value&gt;&gt;usY)&amp;0x01;
}

#define IMG_X 0				//图片x坐标
#define IMG_Y 0             //图片y坐标
#define IMG_W 240           //图片宽度
#define IMG_H 320           //图片高度

#define ALLOW_FAIL_PER 10    //容错率
#define ITERATER_NUM   8   //迭代次数

/**
 * @brief  寻找腐蚀中心
 * @param  x ：腐蚀中心x坐标
 * @param  y ：腐蚀中心y坐标
 * @param  condition ：TARGET_CONDITION结构体，存放希望的颜色数据阈值
 * @param  area ：SEARCH_AREA结构体，查找腐蚀中心的区域
 * @retval 1：找到了腐蚀中心，x、y为腐蚀中心的坐标；0：没有找到腐蚀中心。
 */
static int SearchCenter(unsigned short* x, unsigned short* y, const TARGET_CONDITION* condition, SEARCH_AREA* area )
{
	unsigned short i, j, k;
	unsigned short FailCount=0;
	unsigned short SpaceX, SpaceY;
	
	SpaceX = condition-&gt;WIDTH_MIN / 3;      //以最小宽度除以3 为 横向查询的步进的一个单位
	SpaceY = condition-&gt;HEIGHT_MIN / 3;     //以最小高度除以3 为 垂直查询的步进的一个单位
	
    /*横向步进单位+垂直步进单位 组成了一个矩形的色块*/
	for(i=area-&gt;Y_Start; i&lt;area-&gt;Y_End; i+=SpaceY)
	{
		for(j=area-&gt;X_Start; j&lt;area-&gt;X_End; j+=SpaceX)
		{
			FailCount = 0;      //失败次数初始化
			for(k=0; k&lt;SpaceX+SpaceY; k++)
			{
				if(k&lt;SpaceX)    //查询色块中间一横的颜色
                {   
                    if(ReadColor(j+k, i+SpaceY/2)==0)
                    {
                       FailCount++;     //颜色不匹配 失败计数+1 
                    }
                }
				else            //查询色块中间一竖的颜色     
                {
					if(ReadColor( j+SpaceX/2, i+k-SpaceX)==0)
                    {
                        FailCount++;    //颜色不匹配 失败计数+1
                    }
				}
					
				if(FailCount&gt;( (SpaceX+SpaceY) / ALLOW_FAIL_PER ))     //失败计数大于 色块需要查询的总点数/容错率
					break;  //失败次数太多 退出
			}
			
			if(k == SpaceX+SpaceY)  //k坚持到查询完毕，说明基本匹配
			{
                /*记录该色块的中心点为腐蚀中心*/
				*x = j + SpaceX / 2;
				*y = i + SpaceY / 2;
				return 1;   //记录到第一个腐蚀中心后退出函数
			}
		}	
	}
	return 0;	
}


/**
 * @brief  从腐蚀中心向外腐蚀，得到新的腐蚀中心
 * @param  oldX ：先前的腐蚀中心x坐标
 * @param  oldX ：先前的腐蚀中心y坐标
 * @param  condition ：TARGET_CONDITION结构体，存放希望的颜色数据阈值
 * @param  result ：RESULT结构体，存放检测结果
 * @retval 1：检测成功；0：检测失败。
 */
static int Corrode(unsigned short oldX, unsigned short oldY, const TARGET_CONDITION* condition, RESULT* result )
{
	unsigned short Xmin, Xmax, Ymin, Ymax;
	unsigned short i;
	unsigned short FailCount=0;
	for(i=oldX; i&gt;IMG_X; i--)           //从中心点查到x最左侧
	{
		if(!ReadColor(i, oldY))
			FailCount++;    //不匹配计数自加1
        if( FailCount&gt; ((condition-&gt;WIDTH_MIN)/ALLOW_FAIL_PER) | i&lt;=0)//当识别失败点大于最小宽度/2是跳出  
			break;
	}
	Xmin=i;     //更新X轴最小坐标值
    
	FailCount=0;    //清空错误次数
	for(i=oldX; i&lt;IMG_X+IMG_W; i++)     //从中心点查到x最右侧
	{
		if(!ReadColor(i, oldY))
			FailCount++;    //不匹配计数自加1

        if( FailCount&gt; ((condition-&gt;WIDTH_MIN)/ALLOW_FAIL_PER) | i&gt;=240)
			break;
	}
	Xmax=i;     //更新X轴最大坐标值

	FailCount=0;    //清空错误次数
	for(i=oldY; i&gt;IMG_Y; i--)           //从中心点查到y最上侧
	{
		if(!ReadColor(oldX, i)) 
			FailCount++;    //不匹配计数自加1

        if( FailCount&gt; ((condition-&gt;HEIGHT_MIN)/ALLOW_FAIL_PER) | i&lt;=0)
			break;
	}
	Ymin=i;     //更新Y轴最小坐标值

	FailCount=0;    //清空错误次数
	for(i=oldY; i&lt;IMG_Y+IMG_H; i++)     //从中心点查到y最下侧
	{
		if(!ReadColor(oldX, i))
			FailCount++;

        if( FailCount&gt; ((condition-&gt;HEIGHT_MIN)/ALLOW_FAIL_PER)| i&gt;=320)
			break;
	}
	Ymax=i;     //更新Y轴最大坐标值
	
    FailCount=0;    //清空错误次数

    //获得腐蚀区域的中点和xy范围
    result-&gt;x = (Xmin + Xmax) / 2;
    result-&gt;y = (Ymin + Ymax) / 2;
    result-&gt;w = (Xmax - Xmin);
    result-&gt;h = (Ymax - Ymin);
    
	if( (result-&gt;w &gt;= condition-&gt;WIDTH_MIN)  &amp;&amp; (result-&gt;w &lt;= condition-&gt;WIDTH_MAX) &amp;&amp;
        (result-&gt;h &gt;= condition-&gt;HEIGHT_MIN) &amp;&amp; (result-&gt;h &lt;= condition-&gt;HEIGHT_MAX) )
        {
               return 1;   //如果腐蚀后的区域没有超过最大限定区域且没有小于最小限定区域 有效！！ 
        }
	return 0;
}

/**
 * @brief  用户将识别条件写入Condition指向的结构体中，该函数将返回目标的x，y坐标和长宽
 * @param  condition ：TARGET_CONDITION结构体，存放希望的颜色数据阈值
 * @param  result ：RESULT结构体，存放检测结果
 * @retval 1：检测成功；0：检测失败。
 */
int Trace(const TARGET_CONDITION* condition, RESULT* result_final)
{
	unsigned char i;
	static unsigned short x0, y0;
    static unsigned char Flag=0;
	static SEARCH_AREA area = {IMG_X, IMG_X+IMG_W, IMG_Y, IMG_Y+IMG_H};//搜索区域
	RESULT result;      //RESULT识别结果
    
    if(Flag==0)     //如果首次使用或上一次腐蚀失败
    {
        if(SearchCenter(&amp;x0, &amp;y0, condition, &amp;area))    //搜索腐蚀中心并返回给x0，y0，如果成功搜索到，那么flag置1
        {
            Flag = 1;
        }
        else        //如果还没腐蚀成功，那么把腐蚀区域再次扩大到整个图像范围内进行腐蚀
        {
            area.X_Start = IMG_X;
            area.X_End   = IMG_X+IMG_W;
            area.Y_Start = IMG_Y;
            area.Y_End   = IMG_Y+IMG_H;
            
            if(SearchCenter(&amp;x0, &amp;y0, condition, &amp;area))    //如果整个范围腐蚀成功，那么flag置1
            {
                Flag = 1;
                return 1;
            }
            else
            {
				Flag = 0;
				return 0;               
            }
        }      
    }
    
	//找到腐蚀中心 得到中点
	result.x = x0;      //如果flag!=0，说明上一次有腐蚀中心结果，所以直接使用上一次结果腐蚀即可，而不需要再次遍历图像搜索腐蚀中心
	result.y = y0;      //上一次的腐蚀中心赋值给这次的oldx，oldy
    for(i=0; i&lt;ITERATER_NUM; i++)   //进行腐蚀迭代计算
    {
        Corrode(result.x, result.y, condition, &amp;result);
    }
    
    if(Corrode(result.x, result.y, condition, &amp;result))     //从腐蚀中心向外腐蚀成功
    {
        //更新腐蚀中心，以便下次使用
		x0 = result.x;      
		y0 = result.y;
        
        //更新/返回结果值
		result_final-&gt;x = result.x;
		result_final-&gt;y = result.y;
		result_final-&gt;w = result.w;
		result_final-&gt;h = result.h;
        Flag=1;
        
        //缩小下次搜索腐蚀中心图像范围
		area.X_Start = result.x - ((result.w)&gt;&gt;1);
		area.X_End   = result.x + ((result.w)&gt;&gt;1);
		area.Y_Start = result.y - ((result.h)&gt;&gt;1);
		area.Y_End   = result.y + ((result.h)&gt;&gt;1);
        return 1;
	}
    else    //如果腐蚀失败，那么标志位flag置0，返回失败值0
    {
        Flag=0;
        return 0;
    }
}
</code></pre> 
<p>代码有点多，都有写注释哈，就不一一讲解了</p> 
<h3 id="3%E3%80%81%E6%98%BE%E7%A4%BA%E4%BB%A3%E7%A0%81">3、显示代码</h3> 
<pre><code class="language-cs">void GUI_DrawPoint(u16 x,u16 y)
{
    u8 color_value=0x80;
    color_value&gt;&gt;=y%8;
    Bmp_Minimize_SDRAM[x][y/8]|=color_value;
}

void GUI_DrawLine(u16 x1, u16 y1, u16 x2, u16 y2)
{
	u16 t; 
	int xerr=0,yerr=0,delta_x,delta_y,distance; 
	int incx,incy,uRow,uCol; 

	delta_x=x2-x1; //计算坐标增量 
	delta_y=y2-y1; 
	uRow=x1; 
	uCol=y1; 
	if(delta_x&gt;0)incx=1; //设置单步方向 
	else if(delta_x==0)incx=0;//垂直线 
	else {incx=-1;delta_x=-delta_x;} 
	if(delta_y&gt;0)incy=1; 
	else if(delta_y==0)incy=0;//水平线 
	else{incy=-1;delta_y=-delta_y;} 
	if( delta_x&gt;delta_y)distance=delta_x; //选取基本增量坐标轴 
	else distance=delta_y; 
	for(t=0;t&lt;=distance+1;t++ )//画线输出 
	{  
		GUI_DrawPoint(uRow,uCol);//画点 
		xerr+=delta_x ; 
		yerr+=delta_y ; 
		if(xerr&gt;distance) 
		{ 
			xerr-=distance; 
			uRow+=incx; 
		} 
		if(yerr&gt;distance) 
		{ 
			yerr-=distance; 
			uCol+=incy; 
		} 
	}  
} 

void GUI_DrawRectangle(u16 x1, u16 y1, u16 x2, u16 y2)
{
	GUI_DrawLine(x1,y1,x2,y1);
	GUI_DrawLine(x1,y1,x1,y2);
	GUI_DrawLine(x1,y2,x2,y2);
	GUI_DrawLine(x2,y1,x2,y2);
}</code></pre> 
<p>在二值化数据中画矩形</p> 
<pre><code class="language-cs">if(Trace(&amp;condition0, &amp;result))
{
    for(y_size=0;y_size&lt;240;y_size++)     /*检测到物体，清空二值化数据*/
    {
        for(x_size=0;x_size&lt;40;x_size++)
        {
            Bmp_Minimize_SDRAM[y_size][x_size]=0;
        }
    }
    /*画矩形，和中心点*/
    GUI_DrawRectangle ( result.x-result.w/2, result.y-result.h/2, result.x+result.w/2, result.y+result.h/2);
    GUI_DrawLine(result.x-10,result.y,result.x+10,result.y);
    GUI_DrawLine(result.x,result.y-10,result.x,result.y+10);
}</code></pre> 
<p>识别物体满足颜色和大小的判断条件，更新二值化数组，用矩形框出物体，并标出中心点 </p> 
<p><img alt="" height="1185" src="https://images2.imgbox.com/ee/24/OCSClIKM_o.png" width="1200"></p> 
<hr> 
<h2 id="%E6%80%BB%E7%BB%93"><a id="_45"></a>总结</h2> 
<p>第一次写博客，有诸多不足，望多包涵，后续会更新多物体识别和图形识别。</p> 
<p>END...</p> 
<p>参考文章</p> 
<p><a href="https://blog.csdn.net/qq_35653974/article/details/126546250?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-0-126546250-blog-105021009.235%5Ev38%5Epc_relevant_anti_t3&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3" title="stm32 OV7670/摄像头模块颜色区域定位（腐蚀中心算法）_摄像头模块颜色识别_闰土小蒋的博客-CSDN博客">stm32 OV7670/摄像头模块颜色区域定位（腐蚀中心算法）_摄像头模块颜色识别_闰土小蒋的博客-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/qq_35988224/article/details/108179834?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-13-108179834-blog-105021009.235%5Ev38%5Epc_relevant_anti_t3&amp;spm=1001.2101.3001.4242.8&amp;utm_relevant_index=16" title="识别车牌-识别颜色-基于stm32f4 ov7670（无晶振，无fifo，ov7725，ov2640类似可用）_stm32f4 ov7670颜色识别_qq斯国一的博客-CSDN博客">识别车牌-识别颜色-基于stm32f4 ov7670（无晶振，无fifo，ov7725，ov2640类似可用）_stm32f4 ov7670颜色识别_qq斯国一的博客-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/qq_37603131/article/details/105021009/?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E6%91%84%E5%83%8F%E5%A4%B4HSL&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-105021009.142%5Ev89%5Einsert_down28v1,239%5Ev2%5Einsert_chatgpt&amp;spm=1018.2226.3001.4187" title="STM32+ov7725图像识别（HSL原理）_stm32图像识别_大桶矿泉水的博客-CSDN博客">STM32+ov7725图像识别（HSL原理）_stm32图像识别_大桶矿泉水的博客-CSDN博客</a></p> 
<p><a href="https://zhuanlan.zhihu.com/p/335815455?utm_id=0" title="《STM32》EasyTrace物体追踪 源代码个人注释+完整例程 - 知乎">《STM32》EasyTrace物体追踪 源代码个人注释+完整例程 - 知乎</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/023ac9da79feebabc3539d17feeb9062/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Oracle Database12c数据库官网下载和安装教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bf1dedafd76e602050cb2c4dbd1e24a9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【错误记录】Android Studio 中 Kotlin 版本报错 ( Module was compiled with an incompatible version of Kotlin. T )</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>