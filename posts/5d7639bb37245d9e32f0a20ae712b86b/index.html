<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>目前初阶数据结构最难的一集-树&#43;二叉树_堆 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/5d7639bb37245d9e32f0a20ae712b86b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="目前初阶数据结构最难的一集-树&#43;二叉树_堆">
  <meta property="og:description" content="1.树的概念以及结构 1.1.树的概念 在数据结构中我们都是怎样定义树的？
树是一种非线性的数据结构，它是由n（n&gt;=0）个有限结点组成一个具有层次关系的集合。把它叫做树是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。
有一个特殊的结点，称为根结点，根节点没有前驱结点
其实很简单，为了更适合理解，我们引用出了树木&#43;亲缘关系，结构上像倒过来的树，每个节点关系像父子关系，有点像家谱
节点的度：一个节点含有的子树的个数称为该节点的度； 就是看这个节点有几个孩子
叶节点或终端节点（也就是这棵树的最后）：度为0的节点称为叶节点； 如上图：J、K、H、I...等节点为叶节点；就是看辈分最小（没有孩子的节点）的几个孩子
非终端节点或分支节点：度不为0的节点； 如上图：D、E、F、G...等节点为分支节点
双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点； 如上图：A是B的父节点
孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点； 如上图：B是A的孩子节点
兄弟节点：具有相同父节点的节点互称为兄弟节点； 如上图：B、C是兄弟节点
树的度：一棵树中，最大的节点的度称为树的度； 如上图：度最大的节点为A 树的度为3
节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推
树的高度或深度：树中节点的最大层次； 如上图：树的高度为4（用家族的感觉就是这个家族有几代人）
堂兄弟节点：双亲在同一层的节点互为堂兄弟；如上图：H、I互为兄弟节点
节点的祖先：从根到该节点所经分支上的所有节点；如上图：A是所有节点的祖先，相当于直系亲属
子孙：以某节点为根的子树中任一节点都称为该节点的子孙。如上图：所有节点都是A的子孙
森林：由m（m&gt;0）棵互不相交的树的集合称为森林； 子树之间不能相交，比如说BC不能相连，相连则不为树，
相连为另一种数据结构：图 1.2.树的相关概念 树是递归定义的 任何一棵树都由【根和N（N&gt;=0）个子树】构成
比如，A由A和3个子树（B,C,D）构成，而B又由2个子树（E,F）构成，就这样一层层的递归，最终形成一整个树
1.3.树的表示 总体来说，有三种表达方式
1.直接暴力c&#43;&#43;
2.利用顺序表，存储指针数组
3.定义出孩子指针和兄弟指针，找出父节点的第一个左孩子，然后由这个左孩子找出他的兄弟们
1.4.树在实际生活中的应用 2.二叉树的概念以及结构 2.1.概念 一棵二叉树是结点的一个有限集合，该集合:
1. 或者为空
2. 由一个根节点加上两棵别称为左子树和右子树的二叉树组成
简单来说就是树最多只能分成俩叉
2.2.特殊的二叉树 1.满二叉树：满二叉树是一种特殊的二叉树，它的每个非叶子节点都有两个子节点，而且所有的叶子节点都在同一层上。换句话说，它是一棵深度为k且恰好有2^k-1个节点的二叉树，其中k为正整数。相当于每个父亲都有俩儿子，他也是一种特殊的完全二叉树
2.完全二叉树：完全二叉树是一种特殊的二叉树，它除了最后一层节点不满外，其余各层节点数都达到了最大值，并且最后一层的节点都集中在树的左侧。换句话说，如果把一棵完全二叉树的节点按照从上到下、从左到右的顺序依次编号，那么编号为i的节点的左儿子的编号一定为2i，右儿子的编号一定为2i&#43;1，相当于之前都是俩儿子，到最后一辈开始参差不齐，但是从左到右必须连续，不能空
2.3.二叉树的性质 2.4.二叉树的存储结构 在我们想象中二叉树是像上面一样的，但是实际在计算机内存中却不是这么存储的
逻辑结构
物理结构
因此我们要把他想象成如下的结构
3.二叉树的顺序结构以及其实现 3.1.二叉树的顺序结构 相当于数组存储，因此我们在进行代码实现时必须代换成我们想象中的逻辑结构
我们假设上图中父亲为i,则左儿子则为2i&#43;1,右儿子则为2i&#43;2
假设儿子为i,则父亲为（i-1）/ 2,（因为计算机在进行整形除法时会删除小数点，所以不用区分左右儿子）
正式讲二叉树之前就让我们先看二叉树的衍生物--堆，来帮助我们更好理解
3.2.堆的概念及其结构 首先堆必须是一个完全二叉树
其次通过父亲和孩子的大小关系可以区分为大小堆，大堆的根皆为最大，小堆同上
注意落实在内存中的存储不一定为升序 / 降序（因为兄弟之间没有大小关系）">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-10T10:39:26+08:00">
    <meta property="article:modified_time" content="2024-06-10T10:39:26+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">目前初阶数据结构最难的一集-树&#43;二叉树_堆</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3><img alt="" height="1200" src="https://images2.imgbox.com/18/90/n2TnHJUp_o.jpg" width="994"></h3> 
<h3>1.树的概念以及结构</h3> 
<h4>1.1.树的概念</h4> 
<p>在数据结构中我们都是怎样定义树的？</p> 
<p><strong>树是一种非线性的数据结构，它是由n（n&gt;=0）个有限结点组成一个具有层次关系的集合。把它叫做树是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。</strong></p> 
<p><strong>有一个特殊的结点，称为根结点，根节点没有前驱结点</strong></p> 
<p>其实很简单，为了更适合理解，我们引用出了<strong>树木+亲缘关系，结构上像倒过来的树，每个节点关系像父子关系，有点像家谱</strong></p> 
<p><img alt="" height="1080" src="https://images2.imgbox.com/17/57/AKRe7HZH_o.jpg" width="1200"></p> 
<p>节点的度：一个节点含有的子树的个数称为该节点的度； <strong>就是看这个节点有几个孩子</strong></p> 
<p>叶节点或终端节点（也就是这棵树的最后）：度为0的节点称为叶节点； 如上图：J、K、H、I...等节点为叶节点；<strong>就是看辈分最小（没有孩子的节点）的几个孩子</strong></p> 
<p>非终端节点或分支节点：度不为0的节点； 如上图：D、E、F、G...等节点为分支节点</p> 
<p>双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点； 如上图：A是B的父节点</p> 
<p>孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点； 如上图：B是A的孩子节点</p> 
<p>兄弟节点：具有相同父节点的节点互称为兄弟节点； 如上图：B、C是兄弟节点</p> 
<p>树的度：一棵树中，最大的节点的度称为树的度； 如上图：度最大的节点为A 树的度为3</p> 
<p>节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推</p> 
<p>树的高度或深度：树中节点的最大层次； 如上图：树的高度为4（<strong>用家族的感觉就是这个家族有几代人）</strong></p> 
<p>堂兄弟节点：双亲在同一层的节点互为堂兄弟；如上图：H、I互为兄弟节点</p> 
<p>节点的祖先：从根到该节点所经分支上的所有节点；如上图：A是所有节点的祖先，<strong>相当于直系亲属</strong></p> 
<p>子孙：以某节点为根的子树中任一节点都称为该节点的子孙。如上图：所有节点都是A的子孙</p> 
<p>森林：由m（m&gt;0）棵互不相交的树的集合称为森林；         </p> 
<p><span style="color:#fe2c24;"><strong>子树之间不能相交，比如说BC不能相连，相连则不为树，</strong></span></p> 
<p>相连为另一种数据结构：图                </p> 
<h4>1.2.树的相关概念</h4> 
<p><span style="color:#fe2c24;"><strong>树是递归定义的  </strong></span><span style="color:#0d0016;"><strong>任何一棵树都由【根和N（N&gt;=0）个子树】构成</strong></span></p> 
<p>比如，A由A和3个子树（B,C,D）构成，而B又由2个子树（E,F）构成，就这样一层层的递归，最终形成一整个树</p> 
<h4>1.3.树的表示</h4> 
<p>总体来说，有三种表达方式</p> 
<p>1.直接暴力c++</p> 
<p>2.利用顺序表，存储指针数组</p> 
<p><span style="color:#fe2c24;">3.定义出孩子指针和兄弟指针，找出父节点的第一个左孩子，然后由这个左孩子找出他的兄弟们</span></p> 
<p><img alt="" height="472" src="https://images2.imgbox.com/39/ec/a51I4KfS_o.png" width="1200"></p> 
<p><img alt="" height="333" src="https://images2.imgbox.com/5a/cf/m92jag6F_o.png" width="682"></p> 
<h4>1.4.树在实际生活中的应用</h4> 
<p><img alt="" height="552" src="https://images2.imgbox.com/36/41/CZ9UWvcr_o.png" width="1200"></p> 
<h3>2.二叉树的概念以及结构</h3> 
<h4>2.1.概念</h4> 
<p>一棵二叉树是结点的一个有限集合，该集合:</p> 
<p>1. 或者为空</p> 
<p>2. 由一个根节点加上两棵别称为左子树和右子树的二叉树组成</p> 
<p><span style="color:#ff9900;"><strong>简单来说就是树最多只能分成俩叉</strong></span></p> 
<p><img alt="" height="469" src="https://images2.imgbox.com/aa/0f/aEexwKzN_o.png" width="570"></p> 
<h4>2.2.特殊的二叉树</h4> 
<p><strong>1.满二叉树：</strong>满二叉树是一种特殊的二叉树，它的每个非叶子节点都有两个子节点，而且所有的叶子节点都在同一层上。换句话说，它是一棵深度为k且恰好有2^k-1个节点的二叉树，其中k为正整数。<strong>相当于每个父亲都有俩儿子，他也是一种特殊的完全二叉树</strong></p> 
<p><img alt="" height="309" src="https://images2.imgbox.com/93/cf/VolhCQ5l_o.png" width="465"></p> 
<p><strong>2.完全二叉树：</strong>完全二叉树是一种特殊的二叉树，它除了最后一层节点不满外，其余各层节点数都达到了最大值，并且最后一层的节点都集中在树的左侧。换句话说，如果把一棵完全二叉树的节点按照从上到下、从左到右的顺序依次编号，那么编号为i的节点的左儿子的编号一定为2i，右儿子的编号一定为2i+1，<strong>相当于之前都是俩儿子，到最后一辈开始参差不齐，但是从左到右必须连续，不能空</strong></p> 
<p><img alt="" height="289" src="https://images2.imgbox.com/61/2f/op3QIClf_o.png" width="417"></p> 
<h4>2.3.二叉树的性质</h4> 
<p></p> 
<h4>2.4.二叉树的存储结构</h4> 
<p>在我们想象中二叉树是像上面一样的，但是实际在计算机内存中却不是这么存储的</p> 
<p><strong>逻辑结构</strong></p> 
<p><img alt="" height="289" src="https://images2.imgbox.com/c1/96/lAs94uZG_o.png" width="417"></p> 
<p><strong>物理结构</strong></p> 
<p><img alt="" height="87" src="https://images2.imgbox.com/23/25/gfaT7a2w_o.png" width="303"></p> 
<p>因此我们要把他想象成如下的结构</p> 
<p><img alt="" height="267" src="https://images2.imgbox.com/ff/c2/3WbOtNTa_o.png" width="177"></p> 
<h3>3.二叉树的顺序结构以及其实现</h3> 
<h4>3.1.二叉树的顺序结构</h4> 
<p>相当于数组存储，因此我们在进行代码实现时必须代换成我们想象中的逻辑结构</p> 
<p><img alt="" height="87" src="https://images2.imgbox.com/15/fa/dKC8kHqa_o.png" width="303"></p> 
<p>我们假设上图中<span style="color:#fe2c24;"><strong>父亲为i,则左儿子则为2i+1,右儿子则为2i+2</strong></span></p> 
<p><span style="color:#956fe7;"><strong>假设儿子为i,则父亲为（i-1）/ 2,</strong></span><span style="color:#0d0016;"><strong>（因为计算机在进行整形除法时会删除小数点，所以不用区分左右儿子）</strong></span></p> 
<p><span style="color:#0d0016;"><strong>正式讲二叉树之前就让我们先看二叉树的衍生物--堆，来帮助我们更好理解</strong></span></p> 
<h4>3.2.堆的概念及其结构  </h4> 
<p>首先堆必须是一个完全二叉树</p> 
<p>其次通过父亲和孩子的大小关系可以区分为大小堆，<span style="color:#0d0016;"><strong>大堆的根皆为最大，小堆同上</strong></span></p> 
<p><span style="color:#fe2c24;">注意落实在内存中的存储不一定为升序 / 降序（因为兄弟之间没有大小关系）</span></p> 
<p><span style="color:#fe2c24;"><strong>升序：在数组中由下标0开始存储数据不断变大</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>降序：在数组中由下标0开始存储数据不断变小</strong></span></p> 
<h4>3.3.堆的实现</h4> 
<h5>3.3.1 堆的向下调整算法和向上排序算法</h5> 
<h6>1.向下调整算法</h6> 
<p><strong>为什么要用向下调整算法？</strong></p> 
<p>当我们进行想要删除堆的元素时往往需要删除堆的根节点，此时我们可能会想到直接将根节点取出来，但是堆并不是数组，如果盲目的将根节点删除，然后其他的补充位置的话，父子关系就会打乱，左右子节点将不会形成堆的结构，不利于调整</p> 
<p><img alt="" height="402" src="https://images2.imgbox.com/b0/a7/LsFKF8nZ_o.png" width="531"></p> 
<p>于是我们就用向下调整，先交换9和1，将1干到堆顶</p> 
<p>然后与他的儿子比较比儿子小就下去，（谁大谁当爹）</p> 
<p>代码如下：</p> 
<p><img alt="" height="930" src="https://images2.imgbox.com/df/48/c5bwcZGd_o.png" width="1200"></p> 
<p><span style="color:#fe2c24;"><strong>特别注意：要使用向下调整算法左右子树都必须为大 / 小堆</strong></span></p> 
<h6>2.向上调整算法</h6> 
<p>常用于堆的插入，知道儿子，找到爹，然后比，谁大谁当爹</p> 
<p><img alt="" height="705" src="https://images2.imgbox.com/f3/38/pxbbYbFX_o.png" width="1006"></p> 
<h5>3.3.2 堆的创建</h5> 
<p>首先我们直接说结论</p> 
<p><span style="color:#fe2c24;"><strong>要升序，建大堆</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>要降序，建小堆</strong></span></p> 
<p>那么就有人问为什么了？</p> 
<p>别着急，小L来解答</p> 
<p>首先假设我们建好了大堆然后想要进行排序   <strong>假设要排降序</strong>，此时最大值9已经在堆顶了  我们接下来要排次大，我们就只能将9先取出来，于是乎，就造成和向下调整算法一样的局面，父子关系直接乱套了，<strong>就要重新建堆</strong>，极大地增加了算法量，反观<strong>假如要进行升序</strong>我们直接<strong>使用向下调整算法</strong>，然后再将每次的最后一个孩子不管，于是就能拿到升序的结构，小堆同理</p> 
<p><img alt="" height="535" src="https://images2.imgbox.com/33/7e/FP2ccfFp_o.png" width="1200"></p> 
<p>然后大家就会有疑问，为啥降序的时候不把堆顶和最后一个元素交换，然后用一样的思路？</p> 
<p>其实不瞒大家，我之前也因为这个问题困惑很久，但是大家看，如果利用此思路，9就会调到</p> 
<p>最后，调整完后8会到倒数第二，此时也还是升序啊！（<strong>在数组中由下标0开始存储数据不断变大</strong>）所以说，想要升序就要建大堆，想要降序就要建小堆</p> 
<p>代码如下</p> 
<p><img alt="" height="593" src="https://images2.imgbox.com/ac/11/dYtWciJ0_o.png" width="778"></p> 
<p>有的铁铁会发现，我们建堆时使用的是向上调整算法，那么有没有其他算法来建堆呢？</p> 
<p>答案是有的，向下调整算法也能用，这时候大家就会问，向下调整算法不是<span style="color:#fe2c24;"><strong>左右子树都必须为大 / 小堆吗？</strong></span></p> 
<p><span style="color:#0d0016;">俗话说的好，没条件我们也能创造条件，我们可以从底层开始做起，一步步实现，我们可以倒着调整</span>，从倒数第一个父亲开始调整，将他实现成大堆，然后把他前面父亲也这么调，直到都为大堆</p> 
<p> <img alt="" height="435" src="https://images2.imgbox.com/70/4e/R3NfVy0x_o.png" width="574"></p> 
<p><img alt="" height="192" src="https://images2.imgbox.com/c6/67/X38qFRhV_o.png" width="733"></p> 
<p>n-1是为了算出最后一个元素下标，再-1/2是为了算出他父亲</p> 
<h5>3.3.3 建堆的时间复杂度</h5> 
<h6>1.向下调整算法O(N)</h6> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/fe/da/40pD1how_o.png" width="1200"></p> 
<h6>2.向上调整算法O(N*logN)</h6> 
<p><img alt="" height="686" src="https://images2.imgbox.com/a0/af/lUaBmt1Y_o.png" width="1200"></p> 
<p>由上可得向下调整算法要优于向上调整算法</p> 
<h5>3.3.4 堆的插入</h5> 
<p><img alt="" height="673" src="https://images2.imgbox.com/d3/29/Xg9JCzRa_o.png" width="1200"></p> 
<h5>3.3.5 堆的删除</h5> 
<h5><strong>进行删除时需要将根节点和最后一个元素互相交换，再尾删最后一个，然后进行向下调整</strong></h5> 
<p><img alt="" height="288" src="https://images2.imgbox.com/f0/08/zQbZ6Q0C_o.png" width="714"></p> 
<h5>3.3.6 堆的代码实现</h5> 
<h6>Heap.h</h6> 
<p><img alt="" height="653" src="https://images2.imgbox.com/4d/0a/VTnN8i6N_o.png" width="1003"></p> 
<h6>Heap.c</h6> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/f9/a0/gec2awzO_o.png" width="1200"></p> 
<h4>3.4 堆的应用</h4> 
<h5>3..1 Top-k问题</h5> 
<p>例如我的寝室长老王 王者是国服，游戏里的排行榜就是由此设计的，能利用堆排序来实现</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/6c/91/CRLX0e9X_o.png" width="813"></p> 
<p><img alt="" height="175" src="https://images2.imgbox.com/14/37/oXlNb2ao_o.png" width="1147"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5a9acb3f7c180f9294b0acb4005bad10/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">说说Lambda架构</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b75f1ce534015b602bc279de2b12a752/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2024-06-10 问AI: 在大语言模型中，ReAct Agents的理论基础是什么</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>