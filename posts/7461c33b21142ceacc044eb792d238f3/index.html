<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构初阶】单链表经典算法题十二道——得道飞升（上篇） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/7461c33b21142ceacc044eb792d238f3/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构初阶】单链表经典算法题十二道——得道飞升（上篇）">
  <meta property="og:description" content="目录
1、移除元素
2、反转链表
3、链表的中间节点
4、合并两个有序链表
Relaxing Time！！！
———————————————— 天气之子·幻 ————————————————
1、移除元素 思路：
创建一个新链表（newhead，newtail），遍历原链表，把不等于 val 的结点尾插到新链表中。
/** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ typedef struct ListNode ListNode; struct ListNode* removeElements(struct ListNode* head, int val) { //创建新链表 ListNode* newhead;ListNode* newtail; newhead=newtail=NULL; //遍历数组 ListNode* pcur=head; while(pcur) { if(pcur-&gt;val!=val) { //又分两种情况，链表为空，不为空 if(newhead==NULL) { newtail=newhead=pcur; } else { newtail-&gt;next=pcur; newtail=newtail-&gt;next; } } pcur=pcur-&gt;next; } //[7,7,7,7,7]，val=7 ，这种情况下，newtail=NULL，newtail-&gt;next=NULL，此时newtail不能解引用，所以加上if条件 if(newtail) newtail-&gt;next=NULL; return newhead; } 注意：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-26T12:43:25+08:00">
    <meta property="article:modified_time" content="2024-07-26T12:43:25+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构初阶】单链表经典算法题十二道——得道飞升（上篇）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1%E3%80%81%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-toc" style="margin-left:0px;"><a href="#1%E3%80%81%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0" rel="nofollow">1、移除元素</a></p> 
<p id="2%E3%80%81%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-toc" style="margin-left:0px;"><a href="#2%E3%80%81%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8" rel="nofollow">2、反转链表</a></p> 
<p id="3%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9-toc" style="margin-left:0px;"><a href="#3%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9" rel="nofollow">3、链表的中间节点</a></p> 
<p id="4%E3%80%81%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-toc" style="margin-left:0px;"><a href="#4%E3%80%81%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8" rel="nofollow">4、合并两个有序链表</a></p> 
<p id="Relaxing%20Time%EF%BC%81%EF%BC%81%EF%BC%81-toc" style="margin-left:0px;"><a href="#Relaxing%20Time%EF%BC%81%EF%BC%81%EF%BC%81" rel="nofollow">Relaxing Time！！！</a></p> 
<p id="%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%C2%A0%20Good%20Time%C2%A0%20%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94-toc" style="margin-left:0px;"><a href="#%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%C2%A0%20Good%20Time%C2%A0%20%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94" rel="nofollow">————————————————  天气之子·幻  ————————————————</a></p> 
<p></p> 
<hr> 
<p></p> 
<p></p> 
<h2 id="1%E3%80%81%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0">1、移除元素</h2> 
<p><img alt="" class="left" height="688" src="https://images2.imgbox.com/5b/22/K4CF7GRc_o.png" width="800"></p> 
<p></p> 
<p><strong>思路：</strong></p> 
<p>创建一个新链表（newhead，newtail），遍历原链表，把不等于 val 的结点尾插到新链表中。</p> 
<pre><code class="language-cs">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
typedef struct ListNode ListNode;
struct ListNode* removeElements(struct ListNode* head, int val) {
    //创建新链表
    ListNode* newhead;ListNode* newtail;
    newhead=newtail=NULL;
    //遍历数组
    ListNode* pcur=head;
    while(pcur)
    {
        if(pcur-&gt;val!=val)
        {
            //又分两种情况，链表为空，不为空
            if(newhead==NULL)
            {
                newtail=newhead=pcur;
            }
            else
            {
                newtail-&gt;next=pcur;
                newtail=newtail-&gt;next;
            }
        }
        pcur=pcur-&gt;next;
    }
    //[7,7,7,7,7]，val=7 ，这种情况下，newtail=NULL，newtail-&gt;next=NULL，此时newtail不能解引用，所以加上if条件
    if(newtail)               
        newtail-&gt;next=NULL;
    return newhead;
}

</code></pre> 
<p><strong>注意：</strong></p> 
<p>当原链表为空时，newhead = newtail = pcur； </p> 
<p>在实例中，最后一个5结点被尾插到新链表中时，5结点的next指针指向的仍然是后面的6结点，所以最后返回的时候结果里面含有6，所以我们把最后一个等于val结点的next指针指向NULL即可！</p> 
<p></p> 
<h2 id="2%E3%80%81%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8">2、反转链表</h2> 
<p style="text-align:center;"><img alt="" class="left" height="824" src="https://images2.imgbox.com/49/d6/8vdpuFHa_o.png" width="800"></p> 
<p></p> 
<p><strong>新奇思路：</strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/57/5e/4BmieooF_o.png"></p> 
<pre><code class="language-cs">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
 typedef struct ListNode ListNode;
struct ListNode* reverseList(struct ListNode* head) {
    //链表也有可能是空链表
    if(head==NULL)
    {
        return head;
    }
    //定义三个指针变量
    ListNode* n1,*n2,*n3;
    n1=NULL;n2=head;n3=n2-&gt;next;
    while(n2)
    {
        n2-&gt;next=n1;
        n1=n2;
        n2=n3;
        if(n3)
        n3=n3-&gt;next;
    }
    return n1;
}

</code></pre> 
<p></p> 
<h2 id="3%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9">3、链表的中间节点</h2> 
<p style="text-align:center;"><img alt="" class="left" height="575" src="https://images2.imgbox.com/3a/67/ifbH4Rx6_o.png" width="800"></p> 
<p><strong>思路： </strong></p> 
<p><strong>奇数个结点</strong></p> 
<p class="img-center"><img alt="" height="811" src="https://images2.imgbox.com/a1/ce/nTmWHnfJ_o.png" width="700"></p> 
<p><strong>偶数个结点 </strong></p> 
<p class="img-center"><img alt="" height="946" src="https://images2.imgbox.com/f3/61/Ew250sSr_o.png" width="700"></p> 
<pre><code class="language-cs">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
 typedef struct ListNode ListNode;
struct ListNode* middleNode(struct ListNode* head) {
    ListNode* slow=head;
    ListNode* fast=head;

    //while(fast-&gt;next&amp;&amp;fast)错误，不可互换顺序，当为偶数个结点时，fast==NULL循环结束，但是while
      循环内会先判断fast-&gt;next,空指针不能解引用，会报错

    while(fast&amp;&amp;fast-&gt;next)
    {
        //慢指针每次走一步
        //快指针每次走两步
        slow=slow-&gt;next;
        fast=fast-&gt;next-&gt;next;
    }
    //此时slow指向的结点恰好是中间结点
    return slow;
}</code></pre> 
<p><strong>快慢指针为什么可以找到中间结点？（快慢指针的原理）</strong></p> 
<p>慢指针每次走一步，快指针每次走两步，当快指针走到链表的尾结点时，假设链表的长度为n，快指针走的路程是慢指针的两倍，2*慢=快，即慢指针走的路程是n/2。</p> 
<p></p> 
<h2 id="4%E3%80%81%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8">4、合并两个有序链表</h2> 
<p><img alt="" height="756" src="https://images2.imgbox.com/df/bd/f5NP6CF7_o.png" width="800"></p> 
<p></p> 
<p><strong>思路：</strong></p> 
<p>创建一个新链表，newhead，newtail 指向新链表的头结点，定义两个指针分别指向原链表的头结点，两个指针指向的数据比较大小，谁小谁尾插到新链表里面。思路清晰，不过要注意很多细节，直接上代码：</p> 
<pre><code class="language-cs">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
typedef struct ListNode ListNode;
struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) {

    //处理原链表为空链表的情况
    if(list1==NULL)
    {
        return list2;
    }
    if(list2==NULL)
    {
        return list1;
    }

    //创建一个新链表
    ListNode* newhead=NULL;
    ListNode* newtail=NULL;

    //创建两个指针分别指向两个链表的头结点来遍历原链表
    ListNode* l1=list1;
    ListNode* l2=list2;
    
    while(l1&amp;&amp;l2)
    {
        if(l1-&gt;val&lt;l2-&gt;val)
        {
            //l1尾插到新链表
            if(newtail==NULL)
            {
                newtail=newhead=l1;
            }
            else
            {
                newtail-&gt;next=l1;
                newtail=newtail-&gt;next;
            }
            l1=l1-&gt;next;
        }
        else
        {
            //l2尾插到新链表
            if(newhead==NULL)
            {
                newtail=newhead=l2;
            }
            else
            {
                newtail-&gt;next=l2;
                newtail=newtail-&gt;next;
            }
             l2=l2-&gt;next;
        }
    }
    //出循环，要么l1==NULL，要么l2==NULL
        if(l1)
            newtail-&gt;next=l1;  想想这里为啥不用while循环？
        if(l2)
            newtail-&gt;next=l2;
    return newhead;
}</code></pre> 
<pre><code class="language-cs">//优化过后，申请一个不为空的链表，就无需再判断新链表是否为空，最后不要忘记free
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
 typedef struct ListNode ListNode;
struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) {

    //链表为空的情况
    if(list1==NULL)
    {
        return list2;
    }
    if(list2==NULL)
    {
        return list1;
    }
    
    //创建一个新链表
    ListNode* newhead,*newtail;
     newhead=newtail=(ListNode*)malloc(sizeof(ListNode));
    //定义两个指针来遍历数组
    ListNode* l1=list1;
    ListNode* l2=list2;

    while(l1&amp;&amp;l2)
    {
        if(l1-&gt;val&lt;l2-&gt;val)
        {
            newtail-&gt;next=l1;
            l1=l1-&gt;next;
            newtail=newtail-&gt;next;
        }
        else
        {
            newtail-&gt;next=l2;
            l2=l2-&gt;next;
            newtail=newtail-&gt;next;
        }
    }
    if(l1)
        newtail-&gt;next=l1;
    if(l2)
        newtail-&gt;next=l2;

    ListNode* ret=newhead-&gt;next;
    free(newhead);
    newhead=NULL;
    return ret;
    
}</code></pre> 
<p></p> 
<p></p> 
<hr> 
<p>完—</p> 
<p></p> 
<h2 id="Relaxing%20Time%EF%BC%81%EF%BC%81%EF%BC%81"><span style="color:#a2e043;"><strong>Relaxing Time！！！</strong></span></h2> 
<p></p> 
<h2 id="%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%C2%A0%20Good%20Time%C2%A0%20%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94"><span style="background-color:#ff9900;">—</span><span style="background-color:#ffd900;">—</span><span style="background-color:#a2e043;">—</span><span style="background-color:#38d8f0;">—</span><span style="background-color:#4da8ee;">—</span><span style="background-color:#956fe7;">—</span><span style="background-color:#efedf6;">—</span><span style="background-color:#eaf4fc;">—</span><span style="background-color:#e7fafa;">—</span><span style="background-color:#edf6e8;">—</span><span style="background-color:#fefcd8;">—</span><span style="background-color:#fef2f0;">—</span><span style="background-color:#cccccc;">—</span><span style="background-color:#f3f3f4;">—</span>——  <span style="color:#1a439c;"><span style="background-color:#fbd4d0;">天气之子·幻</span></span>  ——<span style="background-color:#e6b223;">—</span><span style="background-color:#ed7976;">—</span><span style="background-color:#9c8ec1;">—</span><span style="background-color:#1c7331;">—</span><span style="background-color:#1c7892;">—</span><span style="background-color:#1a439c;">—</span><span style="background-color:#511b78;">—</span><span style="background-color:#9c8ec1;">—</span><span style="background-color:#79c6cd;">—</span><span style="background-color:#e6b223;">—</span><span style="background-color:#faa572;">—</span><span style="background-color:#fff5e6;">—</span><span style="background-color:#fef2f0;">—</span><span style="background-color:#cccccc;">—</span></h2> 
<p></p> 
<p></p> 
<p><a class="has-card" href="https://t4.kugou.com/song.html?id=b43Kh7aCPV2" rel="nofollow" title="天气之子·幻_TypeD_高音质在线试听_天气之子·幻歌词|歌曲下载_酷狗音乐"><span class="link-card-box"><span class="link-title">天气之子·幻_TypeD_高音质在线试听_天气之子·幻歌词|歌曲下载_酷狗音乐</span><span class="link-desc">酷狗音乐为您提供由TypeD演唱的高清音质无损天气之子·幻mp3在线听,听天气之子·幻,只来酷狗音乐!</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/31/04/JY8vkyW3_o.png" alt="icon-default.png?t=N7T8">https://t4.kugou.com/song.html?id=b43Kh7aCPV2</span></span></a></p> 
<p></p> 
<p></p> 
<p class="img-center"><img alt="" height="867" src="https://images2.imgbox.com/9d/c4/kqfOXeEb_o.jpg" width="400"></p> 
<p></p> 
<p></p> 
<p>至此结束——</p> 
<p>再见——</p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7f9bf5d23cf266c49f6aa5a44b5502b3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">前端三大主流框架Vue React Angular有何不同？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/33c5d76015b70d94b1d69f54534bcc40/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">lua 游戏架构 之 游戏 AI （八）ai_tbl 行为和优先级</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>