<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python 妙用运算符重载——玩出“点”花样来 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/ccbcd4b51f0165ec018af3a6c48d49b4/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Python 妙用运算符重载——玩出“点”花样来">
  <meta property="og:description" content="目录
运算符重载
主角点类
魔法方法
__getitem__
__setitem__
__iter__
__next__
__len__
__neg__
__pos__
__abs__
__bool__
__call__
重载运算符
比较运算符
相等 ==
不等 !=
大于和小于 &gt;、&lt;
大于等于和小于等于 &gt;=、&lt;=
位运算符
位与 &amp;
位或 |
位异或 ^
位取反 ~ 左位移 &lt;&lt;
右位移 &gt;&gt;
算术运算符
加 &#43;
减 -
乘 *
除 /
幂 **
取模 %
整除 // 右加 &#43;
右幂 **
右整除 //
总结
本篇的主角正是“点”，今天要用运算符重载来，把它玩出“点”花样来！那什么是运算符重载呢？
运算符重载 运算符重载是面向对象编程中的一个概念，它允许程序员为自定义类型（如类或结构体）定义特定的运算符行为，使得这些类的实例可以使用语言中预定义的运算符。在Python等编程语言中，运算符重载是一种强大的特性，它使得我们可以用更加自然和直观的方式处理自定义类型。在实际编程中，我们应该根据需要合理使用这一特性，以提高代码的质量和效率。
主角点类 class Point 这个类很简单，就两个属性：横坐标x和纵坐标y。
class Point: def __init__(self, x=0, y=0): self.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-04T22:12:17+08:00">
    <meta property="article:modified_time" content="2024-04-04T22:12:17+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python 妙用运算符重载——玩出“点”花样来</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="900" src="https://images2.imgbox.com/49/4b/p2gohYbM_o.png" width="1200"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc" style="margin-left:0px;"><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD" rel="nofollow">运算符重载</a></p> 
<p id="%E4%B8%BB%E8%A7%92%E7%82%B9%E7%B1%BB-toc" style="margin-left:40px;"><a href="#%E4%B8%BB%E8%A7%92%E7%82%B9%E7%B1%BB" rel="nofollow">主角点类</a></p> 
<p id="%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95" rel="nofollow">魔法方法</a></p> 
<p id="__getitem__-toc" style="margin-left:80px;"><a href="#__getitem__" rel="nofollow">__getitem__</a></p> 
<p id="__setitem__-toc" style="margin-left:80px;"><a href="#__setitem__" rel="nofollow">__setitem__</a></p> 
<p id="__iter__-toc" style="margin-left:80px;"><a href="#__iter__" rel="nofollow">__iter__</a></p> 
<p id="__next__-toc" style="margin-left:80px;"><a href="#__next__" rel="nofollow">__next__</a></p> 
<p id="__len__-toc" style="margin-left:80px;"><a href="#__len__" rel="nofollow">__len__</a></p> 
<p id="__neg__-toc" style="margin-left:80px;"><a href="#__neg__" rel="nofollow">__neg__</a></p> 
<p id="__pos__-toc" style="margin-left:80px;"><a href="#__pos__" rel="nofollow">__pos__</a></p> 
<p id="__abs__-toc" style="margin-left:80px;"><a href="#__abs__" rel="nofollow">__abs__</a></p> 
<p id="__bool__-toc" style="margin-left:80px;"><a href="#__bool__" rel="nofollow">__bool__</a></p> 
<p id="__call__-toc" style="margin-left:80px;"><a href="#__call__" rel="nofollow">__call__</a></p> 
<p id="%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6-toc" style="margin-left:40px;"><a href="#%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6" rel="nofollow">重载运算符</a></p> 
<p id="%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6-toc" style="margin-left:80px;"><a href="#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6" rel="nofollow">比较运算符</a></p> 
<p id="%E7%9B%B8%E7%AD%89%20%3D%3D-toc" style="margin-left:120px;"><a href="#%E7%9B%B8%E7%AD%89%20%3D%3D" rel="nofollow">相等 ==</a></p> 
<p id="%E4%B8%8D%E7%AD%89%20!%3D-toc" style="margin-left:120px;"><a href="#%E4%B8%8D%E7%AD%89%20!%3D" rel="nofollow">不等 !=</a></p> 
<p id="%E5%A4%A7%E4%BA%8E%E5%92%8C%E5%B0%8F%E4%BA%8E%20%3E%E3%80%81%3C-toc" style="margin-left:120px;"><a href="#%E5%A4%A7%E4%BA%8E%E5%92%8C%E5%B0%8F%E4%BA%8E%20%3E%E3%80%81%3C" rel="nofollow">大于和小于 &gt;、&lt;</a></p> 
<p id="%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%E5%92%8C%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E%20%3E%3D%E3%80%81%3C%3D-toc" style="margin-left:120px;"><a href="#%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%E5%92%8C%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E%20%3E%3D%E3%80%81%3C%3D" rel="nofollow">大于等于和小于等于 &gt;=、&lt;=</a></p> 
<p id="%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6-toc" style="margin-left:80px;"><a href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6" rel="nofollow">位运算符</a></p> 
<p id="%E4%BD%8D%E4%B8%8E%20%26-toc" style="margin-left:120px;"><a href="#%E4%BD%8D%E4%B8%8E%20%26" rel="nofollow">位与 &amp;</a></p> 
<p id="%E4%BD%8D%E6%88%96%20%7C-toc" style="margin-left:120px;"><a href="#%E4%BD%8D%E6%88%96%20%7C" rel="nofollow">位或 |</a></p> 
<p id="%E4%BD%8D%E5%BC%82%E6%88%96%20%5E-toc" style="margin-left:120px;"><a href="#%E4%BD%8D%E5%BC%82%E6%88%96%20%5E" rel="nofollow">位异或 ^</a></p> 
<p id="%E4%BD%8D%E5%8F%96%E5%8F%8D%20~%C2%A0-toc" style="margin-left:120px;"><a href="#%E4%BD%8D%E5%8F%96%E5%8F%8D%20~%C2%A0" rel="nofollow">位取反 ~ </a></p> 
<p id="%E5%B7%A6%E4%BD%8D%E7%A7%BB%20%3C%3C-toc" style="margin-left:120px;"><a href="#%E5%B7%A6%E4%BD%8D%E7%A7%BB%20%3C%3C" rel="nofollow">左位移 &lt;&lt;</a></p> 
<p id="%E5%8F%B3%E4%BD%8D%E7%A7%BB%20%3E%3E-toc" style="margin-left:120px;"><a href="#%E5%8F%B3%E4%BD%8D%E7%A7%BB%20%3E%3E" rel="nofollow">右位移 &gt;&gt;</a></p> 
<p id="%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6-toc" style="margin-left:80px;"><a href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6" rel="nofollow">算术运算符</a></p> 
<p id="%E5%8A%A0%20%2B-toc" style="margin-left:120px;"><a href="#%E5%8A%A0%20%2B" rel="nofollow">加 +</a></p> 
<p id="%E5%87%8F%20--toc" style="margin-left:120px;"><a href="#%E5%87%8F%20-" rel="nofollow">减 -</a></p> 
<p id="%E4%B9%98%20*-toc" style="margin-left:120px;"><a href="#%E4%B9%98%20*" rel="nofollow">乘 *</a></p> 
<p id="%E9%99%A4%20%2F-toc" style="margin-left:120px;"><a href="#%E9%99%A4%20%2F" rel="nofollow">除 /</a></p> 
<p id="%E5%B9%82%20**-toc" style="margin-left:120px;"><a href="#%E5%B9%82%20**" rel="nofollow">幂 **</a></p> 
<p id="%E5%8F%96%E6%A8%A1%C2%A0%25-toc" style="margin-left:120px;"><a href="#%E5%8F%96%E6%A8%A1%C2%A0%25" rel="nofollow">取模 %</a></p> 
<p id="%E6%95%B4%E9%99%A4%20%2F%2F%C2%A0-toc" style="margin-left:120px;"><a href="#%E6%95%B4%E9%99%A4%20%2F%2F%C2%A0" rel="nofollow">整除 // </a></p> 
<p id="%E5%8F%B3%E5%8A%A0%20%2B-toc" style="margin-left:120px;"><a href="#%E5%8F%B3%E5%8A%A0%20%2B" rel="nofollow">右加 +</a></p> 
<p id="%E5%8F%B3%E5%B9%82%20**-toc" style="margin-left:120px;"><a href="#%E5%8F%B3%E5%B9%82%20**" rel="nofollow">右幂 **</a></p> 
<p id="%E5%8F%B3%E6%95%B4%E9%99%A4%20%2F%2F-toc" style="margin-left:120px;"><a href="#%E5%8F%B3%E6%95%B4%E9%99%A4%20%2F%2F" rel="nofollow">右整除 //</a></p> 
<p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p>本篇的主角正是“点”，今天要用运算符重载来，把它玩出“点”花样来！那什么是运算符重载呢？</p> 
<h2 id="%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">运算符重载</h2> 
<p><strong>运算符重载</strong>是面向对象编程中的一个概念，它允许程序员为自定义类型（如类或结构体）定义特定的运算符行为，使得这些类的实例可以使用语言中预定义的运算符。在Python等编程语言中，运算符重载是一种强大的特性，它使得我们可以用更加自然和直观的方式处理自定义类型。在实际编程中，我们应该根据需要合理使用这一特性，以提高代码的质量和效率。</p> 
<h3 id="%E4%B8%BB%E8%A7%92%E7%82%B9%E7%B1%BB">主角点类</h3> 
<p>class Point 这个类很简单，就两个属性：横坐标x和纵坐标y。</p> 
<pre><code class="language-python">class Point:
    def __init__(self, x=0, y=0):
        self.x, self.y = x, y
    def __repr__(self):
        return f'Point({self.x}, {self.y})'
    def __str__(self):
        return f'({self.x}, {self.y})'</code></pre> 
<p>测试：</p> 
<p>&gt;&gt;&gt; a = Point()<br> &gt;&gt;&gt; a<br><span style="color:#1a439c;">Point(0, 0)</span><br> &gt;&gt;&gt; str(a)<br><span style="color:#1a439c;">'(0, 0)'</span><br> &gt;&gt;&gt; b = Point(2, 5)<br> &gt;&gt;&gt; b<br><span style="color:#1a439c;">Point(2, 5)</span></p> 
<p>对于只需要整数坐标的类，比如二维数组的行列坐标，本文主要讨论<strong>整数坐标值</strong>的坐标，可以在类初始化函数里加上类型判断：</p> 
<pre><code class="language-python">class Point:
    def __init__(self, x=0, y=0):
        self.x, self.y = x, y
        assert(isinstance(x, str) and isinstance(y, str))
    def __repr__(self):
        return f'Point({self.x}, {self.y})'
    def __str__(self):
        return f'({self.x}, {self.y})'</code></pre> 
<p>测试： </p> 
<p>&gt;&gt;&gt; p = Point(2, 5)<br> &gt;&gt;&gt; p<br><span style="color:#1a439c;">Point(2, 5)</span><br> &gt;&gt;&gt; q = Point(2.1, 5.5)<br><span style="color:#fe2c24;">Traceback (most recent call last):<br>   File "&lt;pyshell#25&gt;", line 1, in &lt;module&gt;<br>     q = Point(2.1, 5.5)<br>   File "&lt;pyshell#22&gt;", line 4, in __init__<br>     assert(isinstance(x, int) and isinstance(y, int))<br> AssertionError</span></p> 
<h3 id="%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95">魔法方法</h3> 
<p>也称为特殊方法或双下划线方法，是python语言中的一种特殊方法，用于在类中实现一些特殊的功能。这些方法的名称始终以双下划线开头和结尾，比如上面点类定义时用到 __init__，__repr__，__str__。重载运算符时，我们就是靠魔法方法来重新定义运算符的，例如 __add__，__sub__，__mul__，__truediv__ 分别对应<strong>加减乘除</strong>四则运算。</p> 
<p>在重载运算符前，再来学习几个其他类型的魔法方法：</p> 
<h4 id="__getitem__">__getitem__</h4> 
<p>__getitem__ 方法用于获取下标对应的值。</p> 
<h4 id="__setitem__">__setitem__</h4> 
<p>__setitem__ 方法用于设置下标对应的值。</p> 
<p>定义完后，点类可以用下标0，1或者-2，-1来取值，和元组、列表等一样：obj[0], obj[1]。</p> 
<pre><code class="language-python">class Point:
    def __init__(self, x=0, y=0):
        self.x, self.y = x, y
    def __repr__(self):
        return f'Point({self.x}, {self.y})'
    def __getitem__(self, index):
        if index in range(-2,2):
            return self.y if index in (1,-1) else self.x
        raise IndexError("Index out of range")
    def __setitem__(self, index, value):
        if index in (0, -2):
            self.x = value
        elif index in (1, -1):
            self.y = value
        else:
            raise IndexError("Index out of range.")</code></pre> 
<p>测试：</p> 
<p>&gt;&gt;&gt; a = Point(1,2)<br> &gt;&gt;&gt; a[0], a[1]<br> (1, 2)<br> &gt;&gt;&gt; a[-1], a[-2]<br> (2, 1)<br> &gt;&gt;&gt; a[0] = 5<br> &gt;&gt;&gt; a<br> Point(5, 2)<br> &gt;&gt;&gt; a[1] = 3<br> &gt;&gt;&gt; a<br> Point(5, 3)<br> &gt;&gt;&gt; [i for i in a]<br> [5, 3]<br> &gt;&gt;&gt; x, y = a<br> &gt;&gt;&gt; x<br> 5<br> &gt;&gt;&gt; y<br> 3<br> &gt;&gt;&gt; b = iter(a)<br> &gt;&gt;&gt; next(b)<br> 5<br> &gt;&gt;&gt; next(b)<br> 3<br> &gt;&gt;&gt; next(b)<br><span style="color:#fe2c24;">Traceback (most recent call last):<br>   File "&lt;pyshell#67&gt;", line 1, in &lt;module&gt;<br>     next(b)<br> StopIteration</span></p> 
<h4 id="__iter__">__iter__</h4> 
<h4 id="__next__">__next__</h4> 
<p>共同定义一个对象的迭代行为，迭代器必须实现__iter__()方法，该方法返回迭代器自身，或者返回一个新的迭代器对象。__next__()方法返回迭代器的下一个元素。</p> 
<pre><code class="language-python">class Point:
    def __init__(self, x=0, y=0):
        self.x, self.y = x, y
        self.index = 0
    def __repr__(self):
        return f'Point({self.x}, {self.y})'
    def __iter__(self):
        self.index = 0
        return self
    def __next__(self):
        if self.index &lt; 2:
            result = self.y if self.index else self.x
            self.index += 1
            return result
        else:
            raise StopIteration</code></pre> 
<p>测试：</p> 
<p>&gt;&gt;&gt; a = Point(5, 3)<br> &gt;&gt;&gt; x, y = a<br> &gt;&gt;&gt; x, y<br> (5, 3)<br> &gt;&gt;&gt; next(a)<br><span style="color:#fe2c24;">Traceback (most recent call last):<br>   File "&lt;pyshell#115&gt;", line 1, in &lt;module&gt;<br>     next(a)<br>   File "&lt;pyshell#111&gt;", line 16, in __next__<br>     raise StopIteration<br> StopIteration</span><br> &gt;&gt;&gt; a = Point(5, 3)<br> &gt;&gt;&gt; next(a)<br> 5<br> &gt;&gt;&gt; next(a)<br> 3<br> &gt;&gt;&gt; a<br> Point(5, 3)<br> &gt;&gt;&gt; a.x<br> 5<br> &gt;&gt;&gt; next(a)<br><span style="color:#fe2c24;">Traceback (most recent call last):<br>   File "&lt;pyshell#121&gt;", line 1, in &lt;module&gt;<br>     next(a)<br>   File "&lt;pyshell#111&gt;", line 16, in __next__<br>     raise StopIteration<br> StopIteration</span><br> &gt;&gt;&gt; a[0]<br><span style="color:#fe2c24;">Traceback (most recent call last):<br>   File "&lt;pyshell#122&gt;", line 1, in &lt;module&gt;<br>     a[0]<br> TypeError: 'Point' object is not subscriptable</span></p> 
<p>对于点类说，可迭代魔法方法完全可弃用；因为使用__getitem__方法和iter()函数已有此功能。</p> 
<h4 id="__len__">__len__</h4> 
<p>求长度的方法，原义就是计算可迭代对象元素的个数；点类的长度就是2。</p> 
<pre><code class="language-python">    def __len__(self):
        return 2</code></pre> 
<h4 id="__neg__">__neg__</h4> 
<p>求相反数的方法，也就是单目的<strong><span style="color:#ff9900;">“ - ”</span></strong>符号；重载为横纵坐标都取相反数。</p> 
<pre><code class="language-python">    def __neg__(self):
        return Point(-self.x, -self.y)</code></pre> 
<h4 id="__pos__">__pos__</h4> 
<p>这是单目的<span style="color:#ff9900;"><strong>“ + ”</strong></span>符号，一般无需重新定义；但是我们还是把它重载成穿过点的横纵两条直线上所有的整数点坐标，还是有点象形的，如一个十字架。</p> 
<pre><code class="language-python">class Point:
    def __init__(self, x=0, y=0):
        self.x, self.y = x, y
    def __repr__(self):
        return f'Point({self.x}, {self.y})'
    def __pos__(self):
        n = 0
        while True:
            yield Point(n, self.y), Point(self.x, n)
            n += 1</code></pre> 
<p>测试：</p> 
<p>&gt;&gt;&gt; a = Point(2, 4)<br> &gt;&gt;&gt; b = +a<br> &gt;&gt;&gt; next(b)<br> (Point(0, 4), Point(2, 0))<br> &gt;&gt;&gt; next(b)<br> (Point(1, 4), Point(2, 1))<br> &gt;&gt;&gt; next(b)<br> (Point(2, 4), Point(2, 2))<br> &gt;&gt;&gt; next(b)<br> (Point(3, 4), Point(2, 3))<br> &gt;&gt;&gt; next(b)<br> (Point(4, 4), Point(2, 4))<br> &gt;&gt;&gt; next(b)<br> (Point(5, 4), Point(2, 5))<br> &gt;&gt;&gt; b = +a<br> &gt;&gt;&gt; horizontal = [next(b)[0] for _ in range(5)]<br> &gt;&gt;&gt; horizontal<br> [Point(0, 4), Point(1, 4), Point(2, 4), Point(3, 4), Point(4, 4)]<br> &gt;&gt;&gt; b = +a<br> &gt;&gt;&gt; vertical = [next(b)[1] for _ in range(5)]<br> &gt;&gt;&gt; vertical<br> [Point(2, 0), Point(2, 1), Point(2, 2), Point(2, 3), Point(2, 4)] </p> 
<p>这种设计返回的点太多，使用并不方便。有必要改成只返回上下左右相邻的四个点：</p> 
<pre><code class="language-python">class Point:
    def __init__(self, x=0, y=0):
        self.x, self.y = x, y
    def __repr__(self):
        return f'Point({self.x}, {self.y})'
    def __pos__(self):
        return Point(self.x, self.y+1), Point(self.x, self.y-1), Point(self.x-1, self.y), Point(self.x+1, self.y)</code></pre> 
<h4 id="__abs__">__abs__</h4> 
<p>求绝对值的方法，重载时定义为把横纵坐标都取绝对。</p> 
<pre><code class="language-python">    def __abs__(self):
        return Point(*map(abs,(self.x, self.y)))</code></pre> 
<p>以上三种方法不改变类自身，注意以下写法会使类改变自身：</p> 
<pre><code class="language-python">    def __neg__(self):
        self.x = -self.x
        return self
    def __pos__(self):
        self.y = -self.y
        return self
    def __abs__(self):
        self.x, self.y = map(abs,(self.x, self.y))
        return self</code></pre> 
<h4 id="__bool__">__bool__</h4> 
<p>布尔值方法，重载时定义为点处在坐标系第一象限及其边界上，就返回True；否则返回False。</p> 
<pre><code class="language-python">    def __bool__(self):
        return self.x&gt;=0 and self.y&gt;=0</code></pre> 
<h4 id="__call__">__call__</h4> 
<p> 这个魔术方法比较特殊，它允许一个类像函数一样被调用；我们借此定义一个点的移动。</p> 
<pre><code class="language-python">    def __call__(self, dx=0, dy=0):
        return Point(self.x + dx, self.y + dy)</code></pre> 
<p>测试：</p> 
<p>&gt;&gt;&gt; a = Point(-5,5)<br> &gt;&gt;&gt; b = a(3, 2)<br> &gt;&gt;&gt; b<br> Rc(-2, 7)<br> &gt;&gt;&gt; b = b(3, 2)<br> &gt;&gt;&gt; b<br> Rc(1, 9)<br> &gt;&gt;&gt; a<br> Rc(-5, 5)</p> 
<p>扩展一下__call__方法，让它除了能移动点还能计算点到点的实际距离：</p> 
<pre><code class="language-python">    def __call__(self, dx=0, dy=0, distance=False):
        if distance:
            return ((self.x-dx)**2 + (self.y-dy)**2)**0.5
        return Point(self.x + dx, self.y + dy)</code></pre> 
<p>测试：</p> 
<p> &gt;&gt;&gt; a = Point(3,4)<br> &gt;&gt;&gt; a(0,0,True)<br> 5.0<br> &gt;&gt;&gt; len(a)<br> 5<br> &gt;&gt;&gt; a(*a(1, 1), True)<br> 1.4142135623730951<br> &gt;&gt;&gt; a<br> Rc(3, 4)<br> &gt;&gt;&gt; a(2, 3, True)<br> 1.4142135623730951</p> 
<p>注：一旦定义了__call__这个方法，__pos__方法就能改进得更简洁。</p> 
<pre><code class="language-python">class Point:
    def __init__(self, r=0, c=0):
        self.x, self.y = r, c
    def __repr__(self):
        return f'Point({self.x}, {self.y})'
    def __pos__(self):
        return self(0, 1), self(0, -1), self(-1), self(1)
    def __call__(self, dx=0, dy=0):
        return Point(self.x + dx, self.y + dy)</code></pre> 
<p>测试：</p> 
<p> &gt;&gt;&gt; a=Point()<br> &gt;&gt;&gt; +a<br> (Point(0, 1), Point(0, -1), Point(-1, 0), Point(1, 0))<br> &gt;&gt;&gt; +Point()   # 直接返回上下左右四个方向<br> (Point(0, 1), Point(0, -1), Point(-1, 0), Point(1, 0))<br> &gt;&gt;&gt; b = Point(7, 8)<br> &gt;&gt;&gt; +b<br> (Point(7, 9), Point(7, 7), Point(6, 8), Point(8, 8))</p> 
<p>最后，综合以上所有<strong>有用的</strong>魔术方法，代码如下： </p> 
<pre><code class="language-python">class Point:
    def __init__(self, x=0, y=0):
        self.x, self.y = x, y
    def __repr__(self):
        return f'Point({self.x}, {self.y})'
    def __str__(self):
        return f'({self.x}, {self.y})'
    def __getitem__(self, index):
        if index in range(-2,2):
            return self.y if index in (1,-1) else self.x
        raise IndexError("Index out of range")
    def __setitem__(self, index, value):
        if index in (0, -2):
            self.x = value
        elif index in (1, -1):
            self.y = value
        else:
            raise IndexError("Index out of range.")
    def __len__(self):
        return 2
    def __abs__(self):
        return Point(*map(abs,(self.x, self.y)))
    def __bool__(self):
        return self.x&gt;=0 and self.y&gt;=0
    def __neg__(self):
        return Point(-self.x, -self.y)
    def __pos__(self):
        return self(0, 1), self(0, -1), self(-1), self(1)
    def __call__(self, dx=0, dy=0):
        return Point(self.x + dx, self.y + dy)</code></pre> 
<h3 id="%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6">重载运算符</h3> 
<p>python中，常用的运算符都有对应的魔法方法可以重新定义新的运算操作。</p> 
<h4 id="%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6">比较运算符</h4> 
<h5 id="%E7%9B%B8%E7%AD%89%20%3D%3D">相等 ==</h5> 
<p>两个点相等，就是它俩的横纵坐标分别相等。</p> 
<pre><code class="language-python">    def __eq__(self, other):
        return self.x == other.x and self.y == other.y
</code></pre> 
<p>为使得类更强健，可以对参数other作一类型判断：</p> 
<p>    def __eq__(self, other):<br>         assert(isinstance(other, Point))<br>         return self.x == other.x and self.y == other.y </p> 
<p>或者：</p> 
<p>    def __eq__(self, other):<br>         if isinstance(other, Point):<br>             return self.x == other.x and self.y == other.y<br>         else:<br>             raise TypeError("Operand must be an instance of Point")</p> 
<h5 id="%E4%B8%8D%E7%AD%89%20!%3D">不等 !=</h5> 
<pre><code class="language-python">    def __ne__(self, other):
        return self.x != other.x or self.y != other.y</code></pre> 
<p>也可以这样表示：</p> 
<blockquote> 
 <p>    def __ne__(self, other):<br>         return not self.__eq__(other)</p> 
</blockquote> 
<p>因为 not self.x == other.x and self.y == other.y 即 not self.x == other.x or not self.y == other.y 。</p> 
<p>经测试，有了__eq__，__ne__可有可无，直接可以用 != 运算。</p> 
<p>&gt;&gt;&gt; class Point:<br> ...     def __init__(self, x=0, y=0):<br> ...         self.x, self.y = x, y<br> ...     def __eq__(self, other):<br> ...         return self.x == other.x and self.y == other.y<br> ... <br> ...     <br> &gt;&gt;&gt; a = Point(2, 5)<br> &gt;&gt;&gt; b = Point(2, 5)<br> &gt;&gt;&gt; c = Point(1, 3)<br> &gt;&gt;&gt; a == a<br> True<br> &gt;&gt;&gt; a == b<br> True<br> &gt;&gt;&gt; a == c<br> False<br> &gt;&gt;&gt; a != b<br> False<br> &gt;&gt;&gt; b != c<br> True <br> &gt;&gt;&gt; class Point:<br> ...     def __init__(self, x=0, y=0):<br> ...         self.x, self.y = x, y<br> ...     def __eq__(self, other):<br> ...         return self.x == other.x and self.y == other.y<br> ...     def __ne__(self, other):<br> ...         return self.x != other.x or self.y != other.y<br> ... <br> ...     <br> &gt;&gt;&gt; a = Point(2, 5)<br> &gt;&gt;&gt; b = Point(2, 3)<br> &gt;&gt;&gt; a != b<br> True</p> 
<h5 id="%E5%A4%A7%E4%BA%8E%E5%92%8C%E5%B0%8F%E4%BA%8E%20%3E%E3%80%81%3C">大于和小于 &gt;、&lt;</h5> 
<p>坐标比大小没什么物理意义，就搞点“花样”出来：小于 &lt; 判断左边的横坐标是否相等；大于 &gt; 判断右边的纵坐标是否相等；但纵横坐标不能同时相等。实际用处就是判断两点是否在同一水平线或同一垂直线上。</p> 
<pre><code class="language-python">    def __lt__(self, other):
        return self.x == other.x and self.y != other.y
    def __gt__(self, other):
        return self.x != other.x and self.y == other.y</code></pre> 
<h5 id="%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%E5%92%8C%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E%20%3E%3D%E3%80%81%3C%3D">大于等于和小于等于 &gt;=、&lt;=</h5> 
<p>在大于小于的基础上，大于等于和小于等于就重载成计算同一水平线或垂直线上的两点的距离。即小于等于 &lt;= 横坐标相等时计算纵坐标的差；而大于等于 &gt;= 纵坐标相等时计算横坐标的差。</p> 
<pre><code class="language-python">    def __le__(self, other):
        return self.x == other.x and self.y - other.y
    def __ge__(self, other):
        return self.y == other.y and self.x - other.x</code></pre> 
<p>测试：</p> 
<p>&gt;&gt;&gt; a = Point(2, 5)<br> &gt;&gt;&gt; b = Point(2, 3)<br> &gt;&gt;&gt; a &lt;= b<br> 2<br> &gt;&gt;&gt; b &lt;= a<br> -2<br> &gt;&gt;&gt; a &gt;= b<br> False<br> &gt;&gt;&gt; b &gt;= a<br> False<br> &gt;&gt;&gt; a = Point(5, 1)<br> &gt;&gt;&gt; b = Point(2, 1)<br> &gt;&gt;&gt; a &gt;= b<br> 3<br> &gt;&gt;&gt; b &gt;= a<br> -3<br> &gt;&gt;&gt; a &lt;= b<br> False<br> b &lt;= a<br> False<br> a &lt; b<br> False<br> b &gt; a<br> True<br> b &lt; a<br> False<br> a &gt; b<br> True<br> c = Point(2, 2)<br> c &gt;= c<br> 0<br> c &gt; c<br> False<br> 0 is False<br> False<br> 0 == False<br> True</p> 
<p>基于以上结果，只要注意对相同两点判断时，使用==False可能误判，因为0 is False，但用 is 来判断就能区别开来，is False 和 is 0 效果是不相同。所以我们把&gt;=和&lt;=的功能让给&gt;和&lt;，大于等于和小于等于重新定义为<strong>两点的横坐标或纵坐标是否(整数)相邻</strong>，并且为了好记忆，让 &lt; 和 &lt;= 管左边的横坐标，让 &gt; 和 &gt;= 管右边的纵坐标。修改后的所有比较运算符的重载代码如下：</p> 
<pre><code class="language-python">class Point:
    def __init__(self, x=0, y=0):
        self.x, self.y = x, y
    def __repr__(self):
        return f'Point({self.x}, {self.y})'
    def __str__(self):
        return f'({self.x}, {self.y})'
    def __eq__(self, other):
        return self.x == other.x and self.y == other.y
    def __ne__(self, other):
        return self.x != other.x or self.y != other.y
    def __gt__(self, other):
        return self.x == other.x and self.y - other.y
    def __lt__(self, other):
        return self.y == other.y and self.x - other.x
    def __ge__(self, other):
        return self.x == other.x and abs(self.y - other.y)==1
    def __le__(self, other):
        return self.y == other.y and abs(self.x - other.x)==1</code></pre> 
<h4 id="%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6">位运算符</h4> 
<p>位运算符是一类专门用于处理整数类型数据的二进制位操作的运算符。</p> 
<h5 id="%E4%BD%8D%E4%B8%8E%20%26">位与 &amp;</h5> 
<p>原义是对两个数的二进制表示进行按位与操作，只有当两个位都为1时，结果位才为1，否则为0。</p> 
<h5 id="%E4%BD%8D%E6%88%96%20%7C">位或 |</h5> 
<p>原义是对两个数的二进制表示进行按位或操作，只要有一个位为1，结果位就为1。</p> 
<p>== 和 != 分别表示横纵坐标 <strong>“x,y都相等”</strong> 和 <strong>“至少有一个不等”</strong>，互为反运算；</p> 
<p>那就把 <span style="color:#ff9900;"><strong>与</strong> &amp; </span>和 <span style="color:#ff9900;"><strong>或 </strong>| </span>重载成 <strong>“x,y都不相等” </strong>和 <strong>“至少有一个不等”</strong>，正好也互为反运算。</p> 
<pre><code class="language-python">     def __and__(self, other):
         return self.x != other.x and self.y != other.y
     def __or__(self, other):
         return self.x == other.x or self.y == other.y</code></pre> 
<p>可以理解为：==是严格的<strong>相等</strong>，“与” 是严格的<strong>不等</strong>；“或”是不严格的<strong>相等</strong>，!=是不严格的<strong>不等</strong>。</p> 
<h5 id="%E4%BD%8D%E5%BC%82%E6%88%96%20%5E">位异或 ^</h5> 
<p>原义是对两个数的二进制表示进行按位异或操作，当两个位不相同时，结果位为1；相同时为0。</p> 
<p>那就把 <span style="color:#ff9900;"><strong>异或</strong> ^</span> 重载成横纵坐标 <strong>“x,y有且只有一个值相等”</strong>，非常接近异或的逻辑意义。</p> 
<pre><code class="language-python">     def __xor__(self, other):
         return self.x == other.x and self.y != other.y or self.x != other.x and self.y == other.y</code></pre> 
<h5 id="%E4%BD%8D%E5%8F%96%E5%8F%8D%20~%C2%A0">位取反 ~ </h5> 
<p>原义是将整数的二进制每一位进行取反操作，即将0变为1，将1变为0。对一个十进制整数n来说， ~n == -n-1；有个妙用列表的索引从0开始，索引下标0,1,2,3表示列表的前4个，而~0,~1,~2,~3正好索引列表的倒数4个元素，因为它们分别等于-1, -2, -3, -4。</p> 
<p><span style="color:#ff9900;"><strong>取反</strong></span>重载时，我们把它定义成交换坐标点的纵横坐标。</p> 
<pre><code class="language-python">    def __invert__(self):
        return Point(self.y, self.x)</code></pre> 
<p>测试：</p> 
<p>&gt;&gt;&gt; a = Point(1, 5)<br> &gt;&gt;&gt; a<br> Point(1, 5)<br> &gt;&gt;&gt; ~a<br> Point(5, 1)<br> &gt;&gt;&gt; a<br> Point(1, 5)<br> &gt;&gt;&gt; a = ~a<br> &gt;&gt;&gt; a<br> Point(5, 1)</p> 
<h5 id="%E5%B7%A6%E4%BD%8D%E7%A7%BB%20%3C%3C">左位移 &lt;&lt;</h5> 
<p>位移运算符的原义是将整数的二进制位全部左移或右移指定的位数。左移时，低位溢出的位被丢弃，高位空出的位用0填充；左移运算相当于对数值进行乘以2的运算 。</p> 
<h5 id="%E5%8F%B3%E4%BD%8D%E7%A7%BB%20%3E%3E">右位移 &gt;&gt;</h5> 
<p>右移运算对于有符号整数，右移时会保留符号位（即最高位），并在左侧填充与符号位相同的位。对于无符号整数，右移时左侧填充0；每次右移相当于将数值整除2的运算。</p> 
<p><span style="color:#ff9900;"><strong>位移</strong></span>运算符重载时采用和比较运算符重载时相同的箭头指向性，即左位移管横坐标的移动，右位移管纵坐标的位移，此时other为整数，正整数指坐标点向右移动或向上移动；负整数刚好相反。</p> 
<pre><code class="language-python">    def __lshift__(self, other):
        return Point(self.x + other, self.y)
    def __rshift__(self, other):
        return Point(self.x, self.y + other)</code></pre> 
<p>测试：</p> 
<p>&gt;&gt;&gt; a = Point(5, 1)<br> a<br> Point(5, 1)<br> a &gt;&gt; 4<br> Point(5, 5)<br> a &lt;&lt; -4<br> Point(1, 1)<br> a<br> Point(5, 1)<br> a &gt;&gt;= 4<br> a<br> Point(5, 5)<br> a &lt;&lt;= -4<br> a<br> Point(1, 5)<br> &gt;&gt;&gt; a = Point(1, 5)<br> &gt;&gt;&gt; b = Point(1, 1)<br> &gt;&gt;&gt; a &gt; b<br> 4<br> &gt;&gt;&gt; if (n:=a&gt;b):<br> ...     a &gt;&gt;= -n<br> ... <br> ...     <br> &gt;&gt;&gt; a == b<br> True</p> 
<p><span style="color:#4da8ee;"><strong>位移运算重载后，同时位移并赋值功能也生效，即 &gt;&gt;= 和 &lt;&lt;= 也同时被重载。</strong></span> 这种赋值功能也可以用 __ilshift__(self, other)，__irshift__(self, other)；大部分方法都有字母 <strong>i </strong>开头对应的运算并赋值的方法，如__iadd__、__isub__、__imul__、__ior__......等等。</p> 
<p>与__call__方法调用的比较：__call__更灵活可以同时改变横、纵坐标。</p> 
<p>&gt;&gt;&gt; a = Point(-5,5)<br> &gt;&gt;&gt; a &lt;&lt; 5<br> Rc(0, 5)<br> &gt;&gt;&gt; a<br> Rc(-5, 5)<br> &gt;&gt;&gt; a(5)<br> Rc(0, 5)<br> &gt;&gt;&gt; a<br> Rc(-5, 5)<br> &gt;&gt;&gt; a(0,-5)<br> Rc(-5, 0)<br> &gt;&gt;&gt; a &gt;&gt; -5<br> Rc(-5, 0)<br> &gt;&gt;&gt; a<br> Rc(-5, 5) </p> 
<p>综合所有位运算符，代码如下：</p> 
<pre><code class="language-python">class Point:
    def __init__(self, x=0, y=0):
        self.x, self.y = x, y
    def __repr__(self):
        return f'Point({self.x}, {self.y})'
    def __and__(self, other):
        return self.x != other.x and self.y != other.y
    def __or__(self, other):
        return self.x == other.x or self.y == other.y
    def __xor__(self, other):
        return self.x == other.x and self.y != other.y or self.x != other.x and self.y == other.y
    def __invert__(self):
        return Point(self.y, self.x)
    def __lshift__(self, other):
        return Point(self.x + other, self.y)
    def __rshift__(self, other):
        return Point(self.x, self.y + other)</code></pre> 
<h4 id="%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6">算术运算符</h4> 
<p>算术运算很简单，除了加减乘除+，-，*，/，还有幂运算 **、取模 %、整除 // 等。</p> 
<h5 id="%E5%8A%A0%20%2B">加 +</h5> 
<p><span style="color:#ff9900;"><strong>加法</strong></span>很明显重载成坐标值的相加最接近加法的本义：</p> 
<p>    def __add__(self, other):<br>         return Point(self.x + other.x, self.y + other.y)</p> 
<p>我们可以让other的定义域进一步扩大不仅限于是个点类，只要符合指定条件都可以“相加”，即移动为另一个点；如果“点”和不符合条件的对象相加，则返回 None。</p> 
<p>指定条件为 <strong><span style="color:#956fe7;">hasattr</span></strong>(other, <strong><span style="color:#a2e043;">'__getitem__'</span></strong>) <strong><span style="color:#ff9900;">and</span></strong> <strong><span style="color:#956fe7;">len</span></strong>(other)==2 ，重载定义如下：</p> 
<pre><code class="language-python">class Point:
    def __init__(self, x=0, y=0):
        self.x, self.y = x, y
    def __repr__(self):
        return f'Point({self.x}, {self.y})'
    def __getitem__(self, index):
        if index in range(-2,2):
            return self.y if index in (1,-1) else self.x
        raise IndexError("Index out of range")
    def __len__(self):
        return 2
    def __call__(self, dx=0, dy=0):
        return Point(self.x + dx, self.y + dy)
    def __add__(self, other):
        if hasattr(other, '__getitem__') and len(other)==2:
            return self.__call__(*map(int, other))</code></pre> 
<p>测试：</p> 
<p>&gt;&gt;&gt; a = Point(3,4)<br> &gt;&gt;&gt; b = Point(2,-2)<br> &gt;&gt;&gt; a + b<br> Point(5, 2)<br> &gt;&gt;&gt; a + (1,1)<br> Point(4, 5)<br> &gt;&gt;&gt; a + '11'<br> Point(4, 5)<br> &gt;&gt;&gt; a + '1'    # None</p> 
<p>与调用__call__方法的比较：</p> 
<p>&gt;&gt;&gt; p = Point(5, 5)<br> &gt;&gt;&gt; d = Point(2, 3)<br> &gt;&gt;&gt; p + d<br> Point(7, 8)<br> &gt;&gt;&gt; p(d.x, d.y)<br> Point(7, 8)<br> &gt;&gt;&gt; p(2, 3)<br> Point(7, 8)<br> &gt;&gt;&gt; p<br> Point(5, 5)</p> 
<h5 id="%E5%87%8F%20-">减 -</h5> 
<p>因为减一个数就是加它的相反数，所以没必要把减法运算重载成和加法一样的模式；我们可以把<span style="color:#ff9900;"><strong>减法</strong></span>重载成两点之间的距离，重载定义为：</p> 
<pre><code class="language-python">class Point:
    def __init__(self, x=0, y=0):
        self.x, self.y = x, y
    def __repr__(self):
        return f'Point({self.x}, {self.y})'
    def __getitem__(self, index):
        if index in range(-2,2):
            return self.y if index in (1,-1) else self.x
        raise IndexError("Index out of range")
    def __len__(self):
        return 2
    def __sub__(self, other):
        if hasattr(other, '__getitem__') and len(other)==2:
            dx, dy = tuple(map(float, other))
            return ((self.x-dx)**2 + (self.y-dy)**2)**0.5</code></pre> 
<p>测试： </p> 
<p>&gt;&gt;&gt; a = Point(3,4)<br> &gt;&gt;&gt; a - Point()<br> 5.0<br> &gt;&gt;&gt; a - (4,5)<br> 1.4142135623730951<br> &gt;&gt;&gt; a - '44'<br> 1.0<br> &gt;&gt;&gt; a - 3   # None</p> 
<h5 id="%E4%B9%98%20*">乘 *</h5> 
<p><span style="color:#ff9900;"><strong>乘法</strong></span>就重载为判断两点是否整数相邻，即： self &gt;= other or self &lt;= other</p> 
<pre><code class="language-python">class Point:
    def __init__(self, x=0, y=0):
        self.x, self.y = x, y
    def __repr__(self):
        return f'Point({self.x}, {self.y})'
    def __ge__(self, other):
        return self.x == other.x and abs(self.y - other.y)==1
    def __le__(self, other):
        return self.y == other.y and abs(self.x - other.x)==1
    def __call__(self, dx=0, dy=0):
        return Point(self.x + dx, self.y + dy)
    def __mul__(self, other):
        return self &gt;= other or self &lt;= other</code></pre> 
<p>测试：</p> 
<p>&gt;&gt;&gt; P0 = Point(3, 5)<br> &gt;&gt;&gt; lst = (0,1), (0,-1), (-1,0), (1,0), (1,1)<br> &gt;&gt;&gt; P5 = [P0(x,y) for x,y in lst]<br> &gt;&gt;&gt; P5<br> [Point(3, 6), Point(3, 4), Point(2, 5), Point(4, 5), Point(4, 6)]<br> &gt;&gt;&gt; [P0*p for p in P5]<br> [True, True, True, True, False]</p> 
<h5 id="%E9%99%A4%20%2F">除 /</h5> 
<p><span style="color:#ff9900;"><strong>除法</strong></span>就重载为判断在同一水平线或垂直线上的两点，是正序还是反序；正序是指前左后右或前下后上，返回1；反序则相反，前右后左或前上后下，返回-1；不符条件的，则返回False。</p> 
<pre><code class="language-python">class Point:
    def __init__(self, x=0, y=0):
        self.x, self.y = x, y
    def __repr__(self):
        return f'Point({self.x}, {self.y})'
    def __gt__(self, other):
        return self.x == other.x and self.y - other.y
    def __lt__(self, other):
        return self.y == other.y and self.x - other.x
    def __xor__(self, other):
        return self.x == other.x and self.y != other.y or self.x != other.x and self.y == other.y
    def __truediv__(self, other):
        return (self^other) and (1 if (self&lt;other)&lt;0 or (self&gt;other)&lt;0 else -1)</code></pre> 
<p>测试：</p> 
<p>&gt;&gt;&gt; a = Point(1, 2)<br> &gt;&gt;&gt; b = Point(5, 2)<br> &gt;&gt;&gt; c = Point(5, 5)<br> &gt;&gt;&gt; a / b , b / a, b / c, c / b<br> (1, -1, 1, -1)<br> &gt;&gt;&gt; a / c, c / a,  a / a,  c / c<br> (False, False, False, False)</p> 
<h5 id="%E5%B9%82%20**">幂 **</h5> 
<p><span style="color:#ff9900;"><strong>幂</strong></span>运算就重载为返回在同一水平线或垂直线上的两点之间的点；不符合条件的，则返回None。</p> 
<pre><code class="language-python">class Point:
    def __init__(self, x=0, y=0):
        self.x, self.y = x, y
    def __repr__(self):
        return f'Point({self.x}, {self.y})'
    def __gt__(self, other):
        return self.x == other.x and self.y - other.y
    def __lt__(self, other):
        return self.y == other.y and self.x - other.x
    def __xor__(self, other):
        return self.x == other.x and self.y != other.y or self.x != other.x and self.y == other.y
    def __truediv__(self, other):
        return (self^other) and (1 if (self&lt;other)&lt;0 or (self&gt;other)&lt;0 else -1)
    def __pow__(self, other):
        if self^other:
            if self&lt;other: return [Point(_,self.y) for _ in range(self.x+(self/other),other.x,self/other)]
            if self&gt;other: return [Point(self.x,_) for _ in range(self.y+(self/other),other.y,self/other)]</code></pre> 
<p>测试：</p> 
<p>&gt;&gt;&gt; a = Point(1, 2)<br> &gt;&gt;&gt; b = Point(5, 2)<br> &gt;&gt;&gt; c = Point(5, 5)<br> &gt;&gt;&gt; a ** b<br> [Point(2, 2), Point(3, 2), Point(4, 2)]<br> &gt;&gt;&gt; b ** a<br> [Point(4, 2), Point(3, 2), Point(2, 2)]<br> &gt;&gt;&gt; b ** c<br> [Point(5, 3), Point(5, 4)]<br> &gt;&gt;&gt; c ** b<br> [Point(5, 4), Point(5, 3)]<br> &gt;&gt;&gt; a ** c   # None<br> &gt;&gt;&gt; a ** a   # None<br> &gt;&gt;&gt; a ** a == []<br> False<br> &gt;&gt;&gt; a ** a == None<br> True<br> &gt;&gt;&gt; a ** c == None<br> True</p> 
<h5 id="%E5%8F%96%E6%A8%A1%C2%A0%25">取模 %</h5> 
<p><span style="color:#ff9900;"><strong>取模</strong></span>运算就重载为返回所给两点作对角线的水平矩形的另外两个端点；如果所得矩形面积为0，则返回值就是原来所给的两点。</p> 
<pre><code class="language-python">class Point:
    def __init__(self, x=0, y=0):
        self.x, self.y = x, y
    def __repr__(self):
        return f'Point({self.x}, {self.y})'
    def __mod__(self, other):
        return [Point(self.x, dy), Point(dx, self.y)]
</code></pre> 
<p>测试：</p> 
<p>&gt;&gt;&gt; a = Point(1, 2)<br> &gt;&gt;&gt; b = Point(5, 5)<br> &gt;&gt;&gt; a % b<br> [Point(1, 5), Point(5, 2)]<br> &gt;&gt;&gt; (a%b)[0]<br> Point(1, 5)<br> &gt;&gt;&gt; (a%b)[1]<br> Point(5, 2)<br> &gt;&gt;&gt; c, d = a % b<br> &gt;&gt;&gt; c % d<br> [Point(1, 2), Point(5, 5)]<br> &gt;&gt;&gt; c % a<br> [Point(1, 2), Point(1, 5)]<br> &gt;&gt;&gt; c % b<br> [Point(1, 5), Point(5, 5)]</p> 
<p>示意图： </p> 
<p><img alt="" height="996" src="https://images2.imgbox.com/21/dc/6TRqBraL_o.png" width="1200"></p> 
<h5 id="%E6%95%B4%E9%99%A4%20%2F%2F%C2%A0">整除 // </h5> 
<p><span style="color:#ff9900;"><strong>整除</strong></span>运算就重载为返回所给两点作对角线的矩形上的两组邻边上的所有点；返回点的列表也分组，如上图，一组是路径a-&gt;c-&gt;b上的点，另一级是路径a-&gt;d-&gt;b上的点。</p> 
<pre><code class="language-python">
class Point:
    def __init__(self, x=0, y=0):
        self.x, self.y = x, y
    def __repr__(self):
        return f'Point({self.x}, {self.y})'
    def __gt__(self, other):
        return self.x == other.x and self.y - other.y
    def __lt__(self, other):
        return self.y == other.y and self.x - other.x
    def __and__(self, other):
        return self.x != other.x and self.y != other.y
    def __xor__(self, other):
        return self.x == other.x and self.y != other.y or self.x != other.x and self.y == other.y
    def __mod__(self, other):
        return [Point(self.x, other.y), Point(other.x, self.y)]
    def __truediv__(self, other):
        return (self^other) and (1 if (self&lt;other)&lt;0 or (self&gt;other)&lt;0 else -1)
    def __pow__(self, other):
        if self^other:
            if self&lt;other: return [Point(_,self.y) for _ in range(self.x+(self/other),other.x,self/other)]
            if self&gt;other: return [Point(self.x,_) for _ in range(self.y+(self/other),other.y,self/other)]
    def __floordiv__(self, other):
        if self&amp;other:
            mod1, mod2 = self % other
            return self**mod1 + [mod1] + mod1**other, self**mod2 + [mod2] + mod2**other</code></pre> 
<p>测试： </p> 
<p>&gt;&gt;&gt; a = Point(1, 2)<br> &gt;&gt;&gt; b = Point(5, 5)<br> &gt;&gt;&gt; a // b<br> ([Point(1, 3), Point(1, 4), Point(1, 5), Point(2, 5), Point(3, 5), Point(4, 5)],<br> [Point(2, 2), Point(3, 2), Point(4, 2), Point(5, 2), Point(5, 3), Point(5, 4)])<br> &gt;&gt;&gt; b // a<br> ([Point(5, 4), Point(5, 3), Point(5, 2), Point(4, 2), Point(3, 2), Point(2, 2)],<br> [Point(4, 5), Point(3, 5), Point(2, 5), Point(1, 5), Point(1, 4), Point(1, 3)])</p> 
<h5 id="%E5%8F%B3%E5%8A%A0%20%2B">右加 +</h5> 
<p>大部分运算符都有对应的右侧运算操作，由字母 <span style="color:#fe2c24;"><strong>r</strong></span> 开头，如右加__radd__、右减__rsub__、右乘__rmul__......等等；只有当自定义对象位于运算符号的右侧时，右运算方法才会被调用。与普通的加法相比，__radd__(self, other) 方法只有当 other 在加号+的左边，对象在加号+的右边才会被调用。</p> 
<p>我们把<strong><span style="color:#ff9900;">右加</span></strong>方法重载成单目运算+差不多的规则，只是多了距离n，不一定是相邻的四点：</p> 
<pre><code class="language-python">    def __radd__(self, n):
        return self(0, n), self(0, -n), self(-n), self(n)</code></pre> 
<p>测试： </p> 
<p>&gt;&gt;&gt; a = Point(1,2); b = Point(); n = 2<br> &gt;&gt;&gt; a + b<br> Point(1, 2)<br> &gt;&gt;&gt; b + a<br> Point(1, 2)<br> &gt;&gt;&gt; a + n <br><span style="color:#fe2c24;">Traceback (most recent call last):<br>   File "&lt;pyshell#29&gt;", line 1, in &lt;module&gt;<br>     a + n<br> AttributeError: 'int' object has no attribute 'x'</span><br> &gt;&gt;&gt; n + a<br> (Point(1, 4), Point(1, 0), Point(-1, 2), Point(3, 2))<br> &gt;&gt;&gt; n + b<br> (Point(0, 2), Point(0, -2), Point(-2, 0), Point(2, 0))<br> &gt;&gt;&gt; 1 + b  # 当n==1就返回上下左右相邻的四个点<br> (Point(0, 1), Point(0, -1), Point(-1, 0), Point(1, 0))<br> &gt;&gt;&gt; 1 + b == +b<br> True<br> &gt;&gt;&gt; -1 + b<br> (Point(0, -1), Point(0, 1), Point(1, 0), Point(-1, 0))<br> &gt;&gt;&gt; 0 + b<br> (Point(0, 0), Point(0, 0), Point(0, 0), Point(0, 0)) </p> 
<h5 id="%E5%8F%B3%E5%B9%82%20**">右幂 **</h5> 
<h5 id="%E5%8F%B3%E6%95%B4%E9%99%A4%20%2F%2F">右整除 //</h5> 
<p>分别返回两点间的水平线或垂直线上所有的整数点，other是由横纵坐标x,y与n组成的三元元组。</p> 
<pre><code class="language-python">    def __rpow__(self, other):
        assert(isinstance(other, tuple) and len(other)==3)
        x, y, n = other
        return [Point(i, n) for i in range(min(x, self.x), max(x, self.x)+1)]
    def __rfloordiv__(self, other: tuple):
        assert(isinstance(other, tuple) and len(other)==3)
        x, y, n = other
        return [Point(n, i) for i in range(min(y, self.y), max(y, self.y)+1)]</code></pre> 
<p>测试：</p> 
<p>&gt;&gt;&gt; a = Point(1,2)<br> &gt;&gt;&gt; b = Point(5,5)<br> &gt;&gt;&gt; (a.x, a.y, 4)**b<br> [Point(1, 4), Point(2, 4), Point(3, 4), Point(4, 4), Point(5, 4)]<br> &gt;&gt;&gt; (*b, 4)**a<br> [Point(1, 4), Point(2, 4), Point(3, 4), Point(4, 4), Point(5, 4)]<br> &gt;&gt;&gt; (a.x, a.y, 3)//b<br> [Point(3, 2), Point(3, 3), Point(3, 4), Point(3, 5)]<br> &gt;&gt;&gt; (*a, 3)//b<br> [Point(3, 2), Point(3, 3), Point(3, 4), Point(3, 5)]<br> &gt;&gt;&gt; (*b, 3)//a<br> [Point(3, 2), Point(3, 3), Point(3, 4), Point(3, 5)]</p> 
<p>示意图：</p> 
<p><img alt="" height="996" src="https://images2.imgbox.com/61/1c/EwHAQi1h_o.png" width="1200"></p> 
<hr> 
<h2 id="%E6%80%BB%E7%BB%93">总结</h2> 
<p>本文通过魔法方法的巧妙使用，为 Point 类定义了丰富多彩的“花样”功能，使其不仅能够表示一个二维空间中的点，还能够执行各种运算和操作。例如，我们可以重载加法运算符来计算两个点之间的移动，重载比较运算符来判断两个点是否在同一直线上，或者重载位运算符来交换点的横纵坐标等。本篇共涉及了四大类30多种魔法方法：</p> 
<p><strong>算术运算符</strong>：包括加 __add__、右加 __radd__、减 __sub__、乘 __mul__、除 __truediv__、取模 __mod__、整除 __floordiv__、__rfloordiv__ 和幂 __pow__、__rpow__。</p> 
<p><strong>比较运算符</strong>：包括等于 __eq__、不等于 __ne__、小于 __lt__、大于 __gt__、小于等于 __le__ 和大于等于 __ge__。</p> 
<p><strong>位运算符</strong>：包括位与 __and__、位或 __or__、位异或 __xor__、位取反 __invert__、左位移 &lt;&lt; 和右位移 &gt;&gt;。</p> 
<p><strong>其他魔术方法</strong>：如显示__repr__、转字符串__str__、求长度 __len__、单目正负操作符 __pos__, __neg__、求绝对值 __abs__、布尔值 __bool__、下标获取和设置 __getitem__, __setitem__ 以及迭代功能 __iter__, __next__。</p> 
<p>在实际编程中，我们应该根据实际需求来决定是否需要重载这些运算符；但过度使用运算符重载可能会导致代码难以理解和维护，而恰当的使用则可以提高代码的可读性和效率。总的来说，运算符重载是一种强大的工具，它可以让自定义类型更加自然地融入到Python的生态系统中。</p> 
<p>全部完整代码：</p> 
<pre><code class="language-python">class Point:
    def __init__(self, x=0, y=0):
        self.x, self.y = x, y
    def __repr__(self):
        return f'Point({self.x}, {self.y})'
    def __str__(self):
        return f'({self.x}, {self.y})'
    def __getitem__(self, index):
        if index in range(-2,2):
            return self.y if index in (1,-1) else self.x
        raise IndexError("Index out of range")
    def __setitem__(self, index, value):
        if index in (0, -2):
            self.x = value
        elif index in (1, -1):
            self.y = value
        else:
            raise IndexError("Index out of range.")
    @property
    def value(self):
        return self.x, self.y
    def __len__(self):
        return 2
    def __abs__(self):
        return Point(*map(abs,(self.x, self.y)))
    def __bool__(self):
        return self.x&gt;=0 and self.y&gt;=0
    def __neg__(self):
        return Point(-self.x, -self.y)
    def __pos__(self):
        return self(0, 1), self(0, -1), self(-1), self(1)
    def __call__(self, dx=0, dy=0):
        return Point(self.x + dx, self.y + dy)
    def __eq__(self, other):
        return self.x == other.x and self.y == other.y
    def __ne__(self, other):
        return self.x != other.x or self.y != other.y
    def __gt__(self, other):
        return self.x == other.x and self.y - other.y
    def __lt__(self, other):
        return self.y == other.y and self.x - other.x
    def __ge__(self, other):
        return self.x == other.x and abs(self.y - other.y)==1
    def __le__(self, other):
        return self.y == other.y and abs(self.x - other.x)==1
    def __and__(self, other):
        return self.x != other.x and self.y != other.y
    def __radd__(self, n):
        return self(0, n), self(0, -n), self(-n), self(n)
    def __or__(self, other):
        return self.x == other.x or self.y == other.y
    def __xor__(self, other):
        return self.x == other.x and self.y != other.y or self.x != other.x and self.y == other.y
    def __invert__(self):
        return Point(self.y, self.x)
    def __lshift__(self, other):
        return Point(self.x + other, self.y)
    def __rshift__(self, other):
        return Point(self.x, self.y + other)
    def __add__(self, other):
        return Point(self.x + other.x, self.y + other.y)
    def __sub__(self, other):
        return ((self.x - other.x)**2 + (self.y - other.y)**2)**0.5
    def __mul__(self, other):
        return self &gt;= other or self &lt;= other
    def __truediv__(self, other):
        return (self^other) and (1 if (self&lt;other)&lt;0 or (self&gt;other)&lt;0 else -1)
    def __pow__(self, other):
        if self^other:
            if self&lt;other: return [Point(_, self.y) for _ in range(self.x+(self/other),other.x,self/other)]
            if self&gt;other: return [Point(self.x, _) for _ in range(self.y+(self/other),other.y,self/other)]
    def __mod__(self, other):
        return [Point(self.x, other.y), Point(other.x, self.y)]
    def __floordiv__(self, other):
        if self&amp;other:
            mod1, mod2 = self % other
            return self**mod1 + [mod1] + mod1**other, self**mod2 + [mod2] + mod2**other
    def __rpow__(self, other):
        assert(isinstance(other, (tuple, list)) and len(other)==3)
        x, y, n = other
        return [Point(i, n) for i in range(min(x, self.x), max(x, self.x)+1)]
    def __rfloordiv__(self, other: tuple):
        assert(isinstance(other, (tuple, list)) and len(other)==3)
        x, y, n = other
        return [Point(n, i) for i in range(min(y, self.y), max(y, self.y)+1)]</code></pre> 
<p>注：把这些代码保存为文件 pointlib.py，可以当作一个自定义库来使用。这个自定义库的实例操作请见链接：<a href="https://hannyang.blog.csdn.net/article/details/137063657" rel="nofollow" title="Python 一步一步教你用pyglet制作“彩色方块连连看”游戏(续)-CSDN博客">Python 一步一步教你用pyglet制作“彩色方块连连看”游戏(续)-CSDN博客</a></p> 
<hr> 
<p id="%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8">完。</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/27e489b9bab38ab02e470daedca8c30e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Webpack5 搭建 Vue3 &#43; TS 项目，web网页开发</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0214bcfddafaf8d8639250ed1fed107b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Kotlin：for循环的几种示例</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>