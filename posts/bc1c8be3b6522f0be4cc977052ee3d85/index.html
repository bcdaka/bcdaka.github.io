<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>醒醒，别睡了...讲《数据分析pandas库》了—/—＜6＞ - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/bc1c8be3b6522f0be4cc977052ee3d85/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="醒醒，别睡了...讲《数据分析pandas库》了—/—＜6＞">
  <meta property="og:description" content="一、
1、长宽格式转换 基于多重索引，Pandas 可以很容易地完成长型、宽型数据格式的相互转换。 1.1 转换为最简格式 stack（）其使用法如下：
stack函数用于将DataFrame中的列转换为行，即将宽格式数据转换为长格式数据。
df.stack( level = -1 :需要处理的索引级别，默认为全部，int/string/list dropna = True :是否删除为缺失值的行 )#转换后的结果可能为 Series 例如下列代码
import pandas as pd # 创建DataFrame data = { &#39;A&#39;: [1, 2, 3], &#39;B&#39;: [4, 5, 6], &#39;C&#39;: [7, 8, 9] } df = pd.DataFrame(data) # 将列转换为行 stacked = df.stack() print(stacked) 其打印结果为： 即stack函数将原本的DataFrame转换为了一个Series对象，每个元素的索引由原先的行索引和列索引组成。 1.2 长宽型格式的自由互转 df.unstack( level = -1 :需要处理的索引级别，默认为全部，int/string/list fill_value :用于填充缺失值的数值 ) 例如下列代码演示：
import pandas as pd # 创建堆叠的数据 data = { (&#39;A&#39;, &#39;x&#39;): [1, 2, 3], (&#39;A&#39;, &#39;y&#39;): [4, 5, 6], (&#39;B&#39;, &#39;x&#39;): [7, 8, 9], (&#39;B&#39;, &#39;y&#39;): [10, 11, 12] } stacked = pd.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-28T18:03:53+08:00">
    <meta property="article:modified_time" content="2024-07-28T18:03:53+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">醒醒，别睡了...讲《数据分析pandas库》了—/—＜6＞</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>一、</p> 
<h4>1、<span style="color:#333333;"><strong>长宽格式转换</strong></span></h4> 
<div> 
 <span style="color:#333333;">        基于多重索引，Pandas </span> 
 <span style="color:#333333;">可以很容易地完成长型、宽型数据格式的相互转换。</span> 
</div> 
<h5><span style="color:#333333;">1.1 <strong>转换为最简格式</strong></span></h5> 
<p><span style="color:#333333;"><strong>stack（）其使用法如下：</strong></span></p> 
<p>        stack函数用于将DataFrame中的列转换为行，即将宽格式数据转换为长格式数据。</p> 
<pre><code class="language-python">df.stack(
    level = -1 :需要处理的索引级别，默认为全部，int/string/list
    dropna = True :是否删除为缺失值的行
)#转换后的结果可能为 Series</code></pre> 
<p>例如下列代码</p> 
<pre><code class="language-python">import pandas as pd

# 创建DataFrame
data = {
    'A': [1, 2, 3],
    'B': [4, 5, 6],
    'C': [7, 8, 9]
}
df = pd.DataFrame(data)

# 将列转换为行
stacked = df.stack()
print(stacked)
</code></pre> 
<div>
  其打印结果为： 
 <img alt="" height="163" src="https://images2.imgbox.com/77/48/UThmqZW4_o.png" width="111"> 
</div> 
<div>
  即stack函数将原本的DataFrame转换为了一个Series对象，每个元素的索引由原先的行索引和列索引组成。 
</div> 
<div></div> 
<div></div> 
<div> 
 <h5><span style="color:#333333;"><strong>1.2 长宽型格式的自由互转</strong></span></h5> 
</div> 
<div> 
 <pre><code class="language-python">df.unstack(
    level = -1 :需要处理的索引级别，默认为全部，int/string/list
    fill_value :用于填充缺失值的数值
)</code></pre> 
 <p>例如下列代码演示：</p> 
 <pre><code class="language-python">import pandas as pd

# 创建堆叠的数据
data = {
    ('A', 'x'): [1, 2, 3],
    ('A', 'y'): [4, 5, 6],
    ('B', 'x'): [7, 8, 9],
    ('B', 'y'): [10, 11, 12]
}
stacked = pd.DataFrame(data)

# 将数据恢复为原始格式
unstacked = stacked.unstack()
print(unstacked)
</code></pre> 
</div> 
<div>
  其运行结果为： 
 <img alt="" height="291" src="https://images2.imgbox.com/ef/75/tBpAAT8c_o.png" width="153"> 
</div> 
<div>
  即unstack函数将原本的堆叠的数据恢复为了原始的DataFrame数据格式，每个列索引成为了多级的列索引。 
</div> 
<div></div> 
<div></div> 
<div> 
 <h5><span style="color:#333333;"><strong>1.3 数据转置</strong></span><span style="color:#333333;">: df.T </span></h5> 
</div> 
<div></div> 
<div> 
 <p>        数据转置是将数据的行和列进行互换的操作。在Python中，可以通过使用pandas库的<strong>transpose()</strong>函数或<strong>T</strong>属性来实现数据的转置。如果df是一个pandas数据框（DataFrame），可以使用df.T来转置数据。</p> 
</div> 
<div> 
 <pre><code class="language-python">import pandas as pd

data = {'A': [1, 2, 3],
        'B': [4, 5, 6],
        'C': [7, 8, 9]}
df = pd.DataFrame(data)

print(df)
</code></pre> 
 <p>其打印结果为：<img alt="" height="107" src="https://images2.imgbox.com/f0/1b/NHuHyL5R_o.png" width="135"></p> 
</div> 
<h6></h6> 
<h6>• 可以使用stack函数将列转换为索引：</h6> 
<div> 
 <pre><code class="language-python">stacked_df = df.stack()
print(stacked_df)
</code></pre> 
 <p>其输出结果如图所示：    <img alt="" height="235" src="https://images2.imgbox.com/b5/3d/L6Z5iV8h_o.png" width="207"></p> 
</div> 
<div></div> 
<h6>• 可以使用unstack函数将索引转换为列：</h6> 
<div> 
 <pre><code class="language-python">unstacked_df = stacked_df.unstack()
print(unstacked_df)</code></pre> 
 <p>此时转换会原来的结果：<img alt="" height="139" src="https://images2.imgbox.com/d0/f6/7VHSXpx5_o.png" width="167"></p> 
</div> 
<div></div> 
<div></div> 
<h4>2、<span style="color:#333333;"><strong>多个数据源的合并 </strong></span></h4> 
<div></div> 
<h5><span style="color:#333333;"><strong>2.1 数据的纵向合并</strong></span></h5> 
<div> 
 <p class="img-center"><img alt="" height="301" src="https://images2.imgbox.com/eb/0f/fuzg862y_o.png" width="616"></p> 
</div> 
<div> 
 <strong>concat函数 </strong>实现数据的纵向合并。默认情况下，concat按照行进行合并。 
</div> 
<div></div> 
<div>
  其具体函数属性以及用法如下： 
</div> 
<div></div> 
<div> 
 <pre><code class="language-python">pd.concat(
    objs :需要合并的对象，列表形式提供
    left=pd.DataFrame({'key':['k0','k1','k2','k3'],'A':['A0','A1','A2','A3'],'B':['B0','B1','B2','B3'],})
    right=pd.DataFrame({'key':['k0','k1','k2','k3'],'C':['C0','C1','C2','C3'],'D':
['D0','D1','D2','D3'],})

    axis = 0 :对行还是对列方向逬行合并(0 index 、 1 columns )
    join = outer :对另一个轴向的索引值如何逬行处理(inner 、outer )ignore_index = False
    keys = None :为不同数据源的提供合并后的索引值
    verify_integrity = False 是否检查索引值的唯一性，有重复时报错
    copy = True
)</code></pre> 
</div> 
<h6></h6> 
<h6>2.1.1 一维series拼接</h6> 
<div> 
 <pre><code class="language-python">ser1=pd.Series([1,2,3],index=list('ABC'))
ser2=pd.Series([4,5,6],index=list('DEF'))
pd.concat([ser1,ser2])</code></pre> 
 <h6>2.1.2 df 对象拼接</h6> 
</div> 
<div> 
 <pre><code class="language-python">import pandas as pd

df1 = pd.DataFrame({'A': [1, 2, 3],'B': [4, 5, 6]})
df2 = pd.DataFrame({'A': [7, 8, 9],'B': [10, 11, 12]})
# 使用concat函数进行纵向合并
combined_df = pd.concat([df1, df2])
print(combined_df)
</code></pre> 
 <p>        <span style="color:#0d0016;">在这个例子中，df1和df2是两个具有相同列的DataFrame。通过使用concat函数并传入一个包含df1和df2的列表，可以将它们纵向合并为一个新的DataFrame。合并后的DataFrame保留了原始的行索引。</span></p> 
 <p><span style="color:#0d0016;">        需要注意的是，如果两个DataFrame在列的数量或列名上有差异，那么合并时可能会出现缺失值。此时，可以使用参数axis=1来进行横向合并。</span></p> 
</div> 
<div>
  此时的生成结果为： 
 <img alt="" height="163" src="https://images2.imgbox.com/ee/48/lY7ydXp8_o.png" width="114"> 
</div> 
<div>
  可以使用reset_index重置一下第一列的索引，即下列代码 
</div> 
<div></div> 
<div> 
 <pre><code class="language-python">combined_df.reset_index(drop=True)</code></pre> 
 <p>其中drop=True表示将生成的index列删除</p> 
 <p></p> 
 <h6>2.1.3 两个df对象拼接，按行进行拼接</h6> 
 <pre><code class="language-python">df1=make_df('AB',[1,2])
df2=make_df('AB',[3,4])
pd.concat([df1,df2],axis=1)
#或者
pd.concat([df1,df2],axis='columns')</code></pre> 
 <p>                <img alt="" height="167" src="https://images2.imgbox.com/47/90/KJCuwsn7_o.png" width="222"></p> 
 <p></p> 
 <h6>2.1.4 <span style="color:#333333;"><strong>两个</strong></span><span style="color:#333333;"><strong>df</strong></span><span style="color:#333333;"><strong>对象拼接，如果索引重复</strong></span></h6> 
 <pre><code class="language-python">x=make_df('AB',[1,2])
y=make_df('AB',[1,2])
pd.concat([x,y])
#解决索引重复问题加ignore_index属性
pd.concat([x,y],ignore_index=True)#重置索引
# #解决索引重复问题，加keys属性
pd.concat([x,y],keys=list('xy')) #复合索引</code></pre> 
 <p></p> 
 <h6>2.1.5 <span style="color:#333333;"><strong>两个</strong></span><span style="color:#333333;"><strong>df</strong></span><span style="color:#333333;"><strong>对象拼接，</strong></span><span style="color:#333333;"><strong>join</strong></span><span style="color:#333333;"><strong>参数的使用 </strong></span></h6> 
 <pre><code class="language-python">a=make_df('ABC',[1,2])
b=make_df('BCD',[3,4])
# pd.concat([a,b],join='inner')#内连接,只合并有相同列名的数据
pd.concat([a,b],join='outer')#外连接,合并所有的列
# a=make_df('ABC',[1,2,3,4])
# b=make_df('BCD',[3,4,5])
# pd.concat([a,b],join='outer',axis=1)#沿着y轴方向拼接</code></pre> 
 <p></p> 
 <h5>2.2 数据的横向合并</h5> 
 <p><img alt="" height="235" src="https://images2.imgbox.com/6e/dc/tcBhrVON_o.png" width="774"></p> 
 <h6>2.2.1 可以使用concat（）函数</h6> 
 <p>在其中的参数增加一个参数axis=1，即表示横向合并</p> 
 <pre><code class="language-python">import pandas as pd

# 创建两个数据集
df1 = pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6]})
df2 = pd.DataFrame({'C': [7, 8, 9], 'D': [10, 11, 12]})

# 使用 pd.concat() 函数横向合并
result = pd.concat([df1, df2], axis=1)

print(result)
</code></pre> 
 <h6>2.2.2 使用pd.merge（）函数</h6> 
 <p>函数属性及其用法为：</p> 
 <pre><code class="language-python">merge 命令使用像 SQL 的连接方式
pd.merge（
    需要合并的 DF
    left :需要合并的左侧 DF
    right :需要合并的右侧 DF
    how = ' inner':具体的连接类型{left、right 、outer 、 inner、）
    两个 DF 的连接方式
    on :用于连接两个 DF 的关键变量（多个时为列表），必须在两侧都出现
    left_on :左侧 DF 用于连接的关键变量（多个时为列表）
    right_on :右侧 DF 用于连接的关键变量（多个时为列表）
    left_index = False :是否将左侧 DF 的索引用于连接
    right_index = False :是否将右侧 DF 的索引用于连接
)</code></pre> 
 <h6></h6> 
 <h6>• 当两个数据有一列完全相同时</h6> 
 <pre><code class="language-python">left=pd.DataFrame({'key':['k0','k1','k2','k3'],'A':['A0','A1','A2','A3'],'B':['B0','B1','B2','B3'],})
right=pd.DataFrame({'key':['k0','k1','k2','k3'],'C':['C0','C1','C2','C3'],'D':['D0','D1','D2','D3'],})
result=pd.merge(left,right)</code></pre> 
 <p>其生成结果为：<img alt="" height="192" src="https://images2.imgbox.com/a5/47/UT6IOwD4_o.png" width="220"></p> 
 <h6><span style="color:#0d0016;">  </span></h6> 
 <h6>•<span style="color:#0d0016;"> left_on与right_on</span></h6> 
 <p><span style="color:#0d0016;">        即如果没有一个列相同的，则无法连接，需使用left_on与right_on来确定连接位置</span></p> 
 <pre><code class="language-python">import pandas as pd

# 创建两个数据集
df1 = pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6]})
df2 = pd.DataFrame({'C': [7, 8, 9], 'D': [10, 11, 12]})

# 使用 DataFrame.merge() 方法横向合并
result = df1.merge(df2, left_index=True, right_index=True)

print(result)
</code></pre> 
 <p>其打印结果为：   <img alt="" height="103" src="https://images2.imgbox.com/8f/a5/KRuWpzKx_o.png" width="177"></p> 
 <p></p> 
 <h6>• how参数的使用</h6> 
 <pre><code class="language-python">#how参数的使用
left=pd.DataFrame({'key':['k0','k1','k2','k3'],'A':['A0','A1','A2','A3'],'B':['B0','B1','B2','B3'],})
right=pd.DataFrame({'key':['k0','k1','k2','k4'],'C':['C0','C1','C2','C3'],'D':['D0','D1','D2','D3'],})
result=pd.merge(left,right,how='left')</code></pre> 
 <p>即当有一整列相同可以配对时，指定连接类型</p> 
 <p></p> 
 <p></p> 
</div> 
<div></div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3d1e6ab3685f5e0004489940d8053c14/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Postman中的代理艺术：配置与使用指南</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1d2fc542a07103444e4da240c2b59373/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Postman自定义函数：扩展测试脚本功能的秘籍</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>