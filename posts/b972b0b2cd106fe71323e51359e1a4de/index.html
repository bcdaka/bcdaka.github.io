<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【动态规划】子数组系列一（数组中连续的一段） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b972b0b2cd106fe71323e51359e1a4de/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【动态规划】子数组系列一（数组中连续的一段）">
  <meta property="og:description" content="子数组系列一（数组中连续的一段） 1.最大子数组和2.环形子数组的最大和3.乘积最大子数组4.乘积为正数的最长子数组长度 点赞👍👍收藏🌟🌟关注💖💖
你的支持是对我最大的鼓励，我们一起努力吧!😃😃
1.最大子数组和 题目链接： 53. 最大子数组和
题目分析：
子数组 是数组中的一个连续部分。子数组最少包含一个元素也就是说本身也是子数组！
算法原理：
1.状态表示
像这种研究的是子数组这样的模型，状态表示 依旧可以用 经验 &#43; 题目要求
以 i 位置为结尾，巴拉巴拉。
以 i 位置为结尾，我们要的是最大子数组和，是不是先把以 i 位置为结尾的所有子数组拿到。单独 i 元素 是一个子数组，还有前面以 i 元素 为结尾的所有子数组，我要的是一个最大和。
dp[i] 表示：以 i 位置元素为结尾的所有子数组中的最大和。
2.状态转移方程
找出所有子数组最大和就可以了，所有子数组可以划分两大类。第一类就是单独自己构成子数组，第二类就是它自己与前面元素的结合构成子数组。所以可以根据长度来划分，长度为1 单独自己构成子数组，子数组最大和 nums[i]，长度大于1，nums[i]一定是要的，然后在找到以 i - 1 位置元素为结尾的所有子数组中的最大和，两个相加就可以了，而dp[i - 1] 就是以 i - 1 位置元素为结尾的所有子数组中的最大和，因此 dp[i &#43; 1] &#43; nums[i]，我要求的是 i 位置元素为结尾的所有子数组中的最大和。因此两种情况取最大就好了
3.初始化
多申请一个节点
里面的值要保证后面填表的正确下标映射关系 先考虑如果不多加一个节点第一个位置应该填多少呢？是不是填自己本身啊，为了不让多加的节点影响后面的填表正确，因此可以给 0。注意下标映射关系，我们躲开了一个空间相当于整体往右移动一位，如果要回原数组下标要 -1
4.填表顺序
从左往右
5.返回值
注意这里可不是返回最后一个位置的值，因为最大子数组可能在这个数组中任何一个地方。所以返回的是dp中最大值
class Solution { public: int maxSubArray(vector&lt;int&gt;&amp; nums) { // 1.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-29T10:02:21+08:00">
    <meta property="article:modified_time" content="2024-08-29T10:02:21+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【动态规划】子数组系列一（数组中连续的一段）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>子数组系列一（数组中连续的一段）</h4> 
 <ul><li><a href="#1_7" rel="nofollow">1.最大子数组和</a></li><li><a href="#2_86" rel="nofollow">2.环形子数组的最大和</a></li><li><a href="#3_195" rel="nofollow">3.乘积最大子数组</a></li><li><a href="#4_277" rel="nofollow">4.乘积为正数的最长子数组长度</a></li></ul> 
</div> 
<p></p> 
<p><img src="https://images2.imgbox.com/a6/8c/9Nl8bSP8_o.jpg" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>点赞</strong>👍👍<strong>收藏</strong>🌟🌟<strong>关注</strong>💖💖<br> <font color="red"><strong>你的支持是对我最大的鼓励，我们一起努力吧!😃😃</strong></font></p> 
</blockquote> 
<h2><a id="1_7"></a>1.最大子数组和</h2> 
<p><strong>题目链接：</strong> <a href="https://leetcode.cn/problems/maximum-subarray/description/" rel="nofollow">53. 最大子数组和</a></p> 
<p><strong>题目分析：</strong></p> 
<p><img src="https://images2.imgbox.com/53/bf/TJlg9Qho_o.png" alt="在这里插入图片描述"></p> 
<p><strong>子数组</strong> 是数组中的一个连续部分。子数组最少包含一个元素也就是说本身也是子数组！</p> 
<p><img src="https://images2.imgbox.com/af/a4/wvr7EM0h_o.png" alt="在这里插入图片描述"></p> 
<p><strong>算法原理：</strong></p> 
<blockquote> 
 <p>1.状态表示</p> 
</blockquote> 
<p>像这种研究的是子数组这样的模型，状态表示 依旧可以用 经验 + 题目要求</p> 
<p>以 i 位置为结尾，巴拉巴拉。</p> 
<p>以 i 位置为结尾，我们要的是最大子数组和，是不是先把以 i 位置为结尾的所有子数组拿到。单独 i 元素 是一个子数组，还有前面以 i 元素 为结尾的所有子数组，我要的是一个最大和。</p> 
<p>dp[i] 表示：以 i 位置元素为结尾的所有子数组中的最大和。</p> 
<p><img src="https://images2.imgbox.com/ac/58/ry0nxYIl_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>2.状态转移方程</p> 
</blockquote> 
<p>找出所有子数组最大和就可以了，所有子数组可以划分两大类。第一类就是单独自己构成子数组，第二类就是它自己与前面元素的结合构成子数组。所以可以根据长度来划分，<strong>长度为1</strong> 单独自己构成子数组，子数组最大和 nums[i]，<strong>长度大于1</strong>，nums[i]一定是要的，然后在找到以 i - 1 位置元素为结尾的所有子数组中的最大和，两个相加就可以了，而dp[i - 1] 就是以 i - 1 位置元素为结尾的所有子数组中的最大和，因此 dp[i + 1] + nums[i]，我要求的是 i 位置元素为结尾的所有子数组中的最大和。因此两种情况取最大就好了</p> 
<p><img src="https://images2.imgbox.com/1a/9a/DqTbQOno_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>3.初始化</p> 
</blockquote> 
<p>多申请一个节点</p> 
<ol><li>里面的值要保证后面填表的正确</li><li>下标映射关系</li></ol> 
<p>先考虑如果不多加一个节点第一个位置应该填多少呢？是不是填自己本身啊，为了不让多加的节点影响后面的填表正确，因此可以给 0。注意下标映射关系，我们躲开了一个空间相当于整体往右移动一位，如果要回原数组下标要 -1</p> 
<p><img src="https://images2.imgbox.com/75/75/3mPoup0o_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>4.填表顺序</p> 
</blockquote> 
<p>从左往右</p> 
<blockquote> 
 <p>5.返回值</p> 
</blockquote> 
<p>注意这里可不是返回最后一个位置的值，因为最大子数组可能在这个数组中任何一个地方。所以返回的是dp中最大值</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 1.创建 dp 表</span>
        <span class="token comment">// 2.初始化</span>
        <span class="token comment">// 3.填表</span>
        <span class="token comment">// 4.返回值</span>

        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">int</span> ret <span class="token operator">=</span> INT_MIN<span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
            ret <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="2_86"></a>2.环形子数组的最大和</h2> 
<p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/maximum-sum-circular-subarray/description/" rel="nofollow">918. 环形子数组的最大和<br> </a></p> 
<p><strong>题目分析：</strong></p> 
<p><img src="https://images2.imgbox.com/2b/5d/ZZ60zavL_o.png" alt="在这里插入图片描述"></p> 
<p>给一个环形数组，让找子数组最大和。子数组可能是中间连续部分，包括自己本身也是子数组。子数组可能是绕一圈的。</p> 
<p><img src="https://images2.imgbox.com/89/53/s0Li1Yig_o.png" alt="在这里插入图片描述"></p> 
<p><strong>算法原理：</strong></p> 
<p>如果直接就在环形上面做有很多边界问题需要考虑。前面我们做过一道题 " 打家劫舍II " 也是一个环形的，我们是将 " 打家劫舍II " 转换成 " 打家劫舍I “，也就是将一个环形数组转换成一个普通数组，然后在普通数组上用” 打家劫舍I "来做。</p> 
<p>这里也是将环形数组转换成一个普通数组来解决问题。</p> 
<p><strong>分类讨论一：子数组没有跨过数组的边界，在数组的中间。</strong><br> 这个就和上面求最大子数组和一模一样。</p> 
<p><img src="https://images2.imgbox.com/26/05/ypaV7mwh_o.png" alt="在这里插入图片描述"></p> 
<p><strong>分类讨论二：子数组跨过数组边界，在数组两端</strong></p> 
<p><img src="https://images2.imgbox.com/64/33/8ragiNvp_o.png" alt="在这里插入图片描述"><br> 那前面一部分和后面一部分求最大和，直接求是非常恶心的，但是可以看到空白的地方正好在数组内部，整段数组的和是一个定值 sum，如果阴影部分的和是最大的，那空白地方和是最小的！所以只要在整个数组找一个连续的区间使和最小，那剩下两部分拼起来和就是最大的。</p> 
<p><img src="https://images2.imgbox.com/dc/4b/7d7LopHb_o.png" alt="在这里插入图片描述"></p> 
<p>因此这里就转化成两个问题，求子数组和最大值，求子数组和最小值。都没环形无关了。求子数组和最小值然后用sum减去这个最小值就是两端最大值。最后返回这两种情况的最大值就好了。</p> 
<blockquote> 
 <p>1.状态表示</p> 
</blockquote> 
<p>经验 + 题目要求</p> 
<p>以 i 位置为结尾，巴拉巴拉。</p> 
<p>以 i 位置为结尾，我们要的是最大子数组和，是不是先把以 i 位置为结尾的所有子数组拿到。单独 i 元素 是一个子数组，还有前面以 i 元素 为结尾的所有子数组，我要的是一个最大和。</p> 
<p>f[i] 表示：以 i 位置元素为结尾的所有子数组中的最大和。</p> 
<p>同理：</p> 
<p>g[i] 表示：以 i 位置元素为结尾的所有子数组中的最小和。</p> 
<p><img src="https://images2.imgbox.com/e1/89/MMJgNy0C_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>2.状态转移方程</p> 
</blockquote> 
<p>我们可以把所有子数组分成两类，第一类是自己本身就是子数组，第二类就是自己加上前面一个或者两个等等构成的子数组。</p> 
<p><img src="https://images2.imgbox.com/a1/6b/AxJ3pga7_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>3.初始化</p> 
</blockquote> 
<p>注意到填表填 0 位置的时候会越界。我们这里可以多申请一个节点</p> 
<ol><li>里面的值要保证后面填表的正确</li><li>下标映射关系</li></ol> 
<p>先考虑如果不多加一个节点第一个位置应该填多少呢？是不是填自己本身啊，为了不让多加的节点影响后面的填表正确，因此可以给 0。f求最大和可以给0，g求最小和也可以给0。</p> 
<p>注意下标映射关系，我们躲开了一个空间相当于整体往右移动一位，如果要回原数组下标要 -1</p> 
<p><img src="https://images2.imgbox.com/ff/c4/rRxngNRR_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>4.填表顺序</p> 
</blockquote> 
<p>从左往右</p> 
<blockquote> 
 <p>5.返回值</p> 
</blockquote> 
<p>回到分类讨论，我们是把问题分成两个子问题，一个是在数组不跨边界找最大子数组和 记为 fmax，一个在数组跨界也就是数组两端找子数组最小和 记为 gmin，然后sum - gmin 就是两端子数组最大和。然后比较一下。</p> 
<p>但是如果数组全都是负数的，这样就有些问题。比如：</p> 
<p><img src="https://images2.imgbox.com/6e/8f/ot6Ukfkp_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">maxSubarraySumCircular</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 1. 创建 dp 表</span>
        <span class="token comment">// 2.初始化</span>
        <span class="token comment">// 3.填表</span>
        <span class="token comment">// 4.返回值</span>

        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">auto</span> g <span class="token operator">=</span> f<span class="token punctuation">;</span>
        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> fmax <span class="token operator">=</span> INT_MIN<span class="token punctuation">,</span> gmin <span class="token operator">=</span> INT_MAX<span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            g<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> g<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            fmax <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>fmax<span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            gmin <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>gmin<span class="token punctuation">,</span>g<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            sum <span class="token operator">+=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> sum <span class="token operator">==</span> gmin <span class="token operator">?</span> fmax <span class="token operator">:</span> <span class="token function">max</span><span class="token punctuation">(</span>fmax<span class="token punctuation">,</span> sum <span class="token operator">-</span> gmin<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="3_195"></a>3.乘积最大子数组</h2> 
<p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/maximum-product-subarray/description/" rel="nofollow">152. 乘积最大子数组</a></p> 
<p><strong>题目分析：</strong></p> 
<p><img src="https://images2.imgbox.com/9f/30/IpNRt0T3_o.png" alt="在这里插入图片描述"></p> 
<p>这道题和上面一样思想，不过求得是子数组中最大乘积</p> 
<p><strong>算法原理：</strong></p> 
<blockquote> 
 <p>1.状态表示</p> 
</blockquote> 
<p>经验 + 题目要求</p> 
<p>dp[i] 表示 ：以 i 位置元素为结尾的所有子数组中最大乘积。</p> 
<p>现在我们先以这个状态表示分析状态转移方程。</p> 
<p>i 本身也是子数组。还有以 i 位置为结尾的子数组，以 i 位置为结尾的子数组我们求最大，nums[i] 肯定要乘上，剩下的子数组都有一个特点就是以 i - 1结尾，所以我们可以将以i - 1位置为结束的子数组乘积最大拿到然后在乘nums[i]，而dp[i-1]就是i - 1位置为结束的子数组乘积最大。</p> 
<p>但是到这里先停住，我们发现了不对劲。i 位置 如果是 &gt; 0的数，用dp[i-1]*nums[i]可以得到更大的数，但是如果 i 位置是 &lt; 0 ，dp[i-1]*nums[i]就是一个很小的数。</p> 
<p>因此我们的状态表示还不过，还要细分下去：</p> 
<p><img src="https://images2.imgbox.com/95/ad/miucP8Mm_o.png" alt="在这里插入图片描述"><br> <strong>f[i] 表示：以 i 位置元素为结尾的所有子数组中最大乘积。</strong></p> 
<p><strong>g[i] 表示：以 i 位置元素为结尾的所有子数组中最小乘积。</strong></p> 
<blockquote> 
 <p>2.状态转移方程</p> 
</blockquote> 
<p>有上面的基础，这里不在细说了</p> 
<p><img src="https://images2.imgbox.com/32/71/KHPBqGf8_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>3.初始化</p> 
</blockquote> 
<p>注意到填表填 0 位置的时候会越界。我们这里可以多申请一个节点</p> 
<ol><li>里面的值要保证后面填表的正确</li><li>下标映射关系</li></ol> 
<p>先不考虑虚拟节点填多少，先考虑不添加虚拟节点第一个位置填多少，是不是填自己本身啊。为了使填的值不影响后填表，可以给1，</p> 
<p><img src="https://images2.imgbox.com/8b/25/JLhAb654_o.png" alt="在这里插入图片描述"></p> 
<p>下标映射，整体往右移动一位，回原本要往左移动一位</p> 
<blockquote> 
 <p>4.填表顺序</p> 
</blockquote> 
<p>从左往右，两个表一起填</p> 
<blockquote> 
 <p>5.返回值</p> 
</blockquote> 
<p>要的是最大乘积，f中放的是最大乘积，遍历一下f，找到最大乘积</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">maxProduct</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 1. 创建 dp 表</span>
        <span class="token comment">// 2. 初始化</span>
        <span class="token comment">// 3. 填表</span>
        <span class="token comment">// 4. 返回值</span>

        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">auto</span> g <span class="token operator">=</span> f<span class="token punctuation">;</span>
        f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> g<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">double</span> ret <span class="token operator">=</span> INT_MIN<span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">double</span> x <span class="token operator">=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y <span class="token operator">=</span> f<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> z <span class="token operator">=</span> g<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token function">max</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span>z<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            g<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token function">min</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span>z<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            ret <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="4_277"></a>4.乘积为正数的最长子数组长度</h2> 
<p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/maximum-length-of-subarray-with-positive-product/description/" rel="nofollow">1567. 乘积为正数的最长子数组长度</a></p> 
<p><strong>题目分析：</strong></p> 
<p><img src="https://images2.imgbox.com/b8/8c/5EnSw6Ar_o.png" alt="在这里插入图片描述"></p> 
<p>求乘积为正数最大子数组长度。</p> 
<p><strong>算法原理：</strong></p> 
<blockquote> 
 <p>1.状态表示</p> 
</blockquote> 
<p>经验 + 题目要求</p> 
<p>dp[i] 表示 ：以 i 位置元素为结尾的所有子数组中乘积为正数的最大长度</p> 
<p>还是先以这个分析</p> 
<p>i 本身也是子数组，然后为空看nums[i] 是正还是负。还有以 i 位置为结尾的子数组，求所有子数组中乘积为正数的最大长度，nums[i]要分正还是负，剩下的子数组都有一个特点就是以 i - 1结尾，所以我们可以将以 i -1 位置元素为结尾的所有子数组中乘积为正数的最大长度拿到，然后在加上nums[i]为正为负的情况。</p> 
<p>我们由上面的状态表示去分析，发现当子数组长度大于1，nums[i] &lt; 0，分析不下去了，如果前面 i - 1 位置有乘积为负数最大长度，负数乘nums[i] &gt; 0，乘积也大于0，那长度不也应该加+1嘛。</p> 
<p>所以一个状态表示不够。</p> 
<p><img src="https://images2.imgbox.com/a6/ee/I2rbVSJb_o.png" alt="在这里插入图片描述"></p> 
<p>f[i] 表示：以 i 位置元素为结尾所有子数组中乘积为正数的最大长度</p> 
<p>g[i] 表示：以 i 位置元素为结尾所有子数组中乘积为负数的最大长度</p> 
<blockquote> 
 <p>2.状态转移方程</p> 
</blockquote> 
<p>当长度大于1，nums[i] &lt; 0，所以我们要找到的是 i - 1位置元素为结尾所有子数组中乘积为负数的最大长度，但是要注意的是，万一 g[i - 1] 位置为0呢？也就是说前面根本就没有乘积为负数的最大长度。那nums[i] 又小于 0，乘积肯定不为正！</p> 
<p><img src="https://images2.imgbox.com/21/a9/HajdYYaP_o.png" alt="在这里插入图片描述"></p> 
<p>因此这里不能这样写，需要判断一下：</p> 
<p><img src="https://images2.imgbox.com/09/06/j2MPGYAG_o.png" alt="在这里插入图片描述"></p> 
<p>再来分析一下g</p> 
<p>长度大于1，nums[i] &gt; 0，所以我们要找到的是 i - 1位置元素为结尾所有子数组中乘积为负数的最大长度，但是万一 g[i - 1] 是 0呢？乘积不可能为负，而nums[i] &gt; 0，这种情况以 i 位置元素为结尾所有子数组中乘积为负数的最大长度就是0，因此下面写的就不对。</p> 
<p><img src="https://images2.imgbox.com/1f/18/NavVnYz0_o.png" alt="在这里插入图片描述"></p> 
<p>所以最终状态转移方程如下：</p> 
<p>有人可能会有疑问，为什么f 当长度大于1，nums[i] &gt; 0，不去考虑 f[i -1] 为0的情况呢，其实我们已经考虑过了，f[i -1] 为0就为0好了，反正nums[i] &gt; 0至少有1个。</p> 
<p>同样g 当长度大于1，nums[i] &lt; 0， 不去考虑 f[i -1]为0的情况，都是一样的，f[i -1] 为0就为0好了，反正nums[i] &lt; 0至少有1个。如果大于0 就加上好了。</p> 
<p><img src="https://images2.imgbox.com/f4/c9/PGv7sKEU_o.png" alt="在这里插入图片描述"></p> 
<p>下面可以整体一下状态转移方程</p> 
<p>f[i]，可以把 nums[i] &gt; 0 两种情况合并成 f[i - 1] + 1，因为nums[i] &gt; 0 至少保证有一个了，如果f[i - 1] == 0 最终结果可以是两个1中任何一个，如果 f[i - 1] &gt; 0，最大值是由f[i - 1] + 1来决定，所以不用考虑上面单独1了。</p> 
<p>nums[i] &lt; 0 两种情况合并成 g[i -1] == 0 ？：g[i -1] + 1，要么是0，要么是比0更大的数，最大值由g[i -1] == 0 ？：g[i -1]决定</p> 
<p>同理g也是这样合并</p> 
<p><img src="https://images2.imgbox.com/b8/fb/2f9PqzIj_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>3.初始化</p> 
</blockquote> 
<p>注意到填表填 0 位置的时候会越界。我们这里可以多申请一个节点</p> 
<ol><li>里面的值要保证后面填表的正确</li><li>下标映射关系</li></ol> 
<p>考虑没有填表的时候g第一个位置填什么，nums[0] &gt; 0 填0，nums[0] &lt; 0填1。<br> 代入是不是f[i - 1] 和 g[i -1] 的位置都填0啊，所以虚拟节点填0。</p> 
<p><img src="https://images2.imgbox.com/4a/bb/wJr78jmW_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>4.填表顺序</p> 
</blockquote> 
<p>从左往右，两个表一起填</p> 
<blockquote> 
 <p>5.返回值</p> 
</blockquote> 
<p>f表中最大值</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">getMaxLen</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 1. 创建 dp 表</span>
        <span class="token comment">// 2. 初始化</span>
        <span class="token comment">// 3. 填表</span>
        <span class="token comment">// 4. 返回值</span>

        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">g</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> ret <span class="token operator">=</span> INT_MIN<span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//不要考虑nums[i - 1] == 0的情况,因为初始化为0 </span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
                g<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> g<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> g<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> g<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> g<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
                g<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            ret <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d2b28fc0100600db4ac388e444090cad/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Idea插件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0187575e4ef8fbeee272c6bf63aab7a4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【多视图聚类】Reconsidering Representation Alignment for Multi-view Clustering</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>