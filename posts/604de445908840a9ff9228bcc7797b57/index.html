<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java中的二叉搜索树（如果想知道Java中有关二叉搜索树的知识点，那么只看这一篇就足够了！） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/604de445908840a9ff9228bcc7797b57/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java中的二叉搜索树（如果想知道Java中有关二叉搜索树的知识点，那么只看这一篇就足够了！）">
  <meta property="og:description" content="前言：Java 提供了丰富的数据结构来处理和管理数据，其中 TreeSet 和 TreeMap 是基于红黑树实现的集合和映射接口。它们有序地存储数据，提供高效的搜索、插入和删除操作。
✨✨✨这里是秋刀鱼不做梦的BLOG
✨✨✨想要了解更多内容可以访问我的主页秋刀鱼不做梦-CSDN博客
先让我们看一下本文大致的讲解内容：
目录
1.二叉搜索树的认识
（1）二叉搜索树的概念
（2）二叉搜索树的性质
2.有关二叉搜索树的常用操作
【1】插入操作
【2】查找操作
【3】删除操作
1.cur.left == null
2.cur.right == null
3.cur.left != null &amp;&amp; cur.right != null
3.二叉树的应用场景
1. 数据结构和算法
2. 数据库和文件系统
3. 图形和游戏开发
1.二叉搜索树的认识 （1）二叉搜索树的概念 在开始学习TreeSet与TreeMap之前，我们需要先学习一下Java中的二叉搜索树，二叉搜索树是一种特殊的二叉树，其中每个节点都有一个值，并满足以下性质：
对于每个节点，左子树所有节点的值都小于该节点的值。
对于每个节点，右子树所有节点的值都大于该节点的值。
如图：
从上图中我们可以很明显的观察出二叉搜索树的上述两个特性。
（2）二叉搜索树的性质 在了解完了二叉搜索树的概念之后，我们需要学习一下有关二叉搜索树的性质，对于一棵二叉搜索树而言，其都有以下三个性质：
有序性：二叉搜索树的中序遍历结果是一个递增的有序序列。
动态性：二叉搜索树支持动态插入和删除操作，适用于需要频繁更新的数据集合。
查找效率：在理想情况下，二叉搜索树的查找、插入和删除操作的时间复杂度为 O(log n)。
——这里读者可能会对其中的一些性质不是很理解，没有关系，继续向下进行阅读即可，在后续的文本中，我们会慢慢的理解其中的意思。
2.有关二叉搜索树的常用操作 【1】插入操作 插入操作用于向二叉搜索树中插入新值。插入过程从根节点开始，根据当前节点的值与新值的比较结果，决定将新值插入到左子树还是右子树。
以下是实现该操作的代码：
public void insertNode(int key) { // 如果根节点为空，直接插入新节点作为根节点 if (root == null) { root = new TreeNode(key); return; } // 初始化当前节点为根节点，父节点为null TreeNode cur = root; TreeNode parent = null; TreeNode node = new TreeNode(key); // 寻找合适的位置插入节点 while (cur !">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-29T19:54:34+08:00">
    <meta property="article:modified_time" content="2024-07-29T19:54:34+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java中的二叉搜索树（如果想知道Java中有关二叉搜索树的知识点，那么只看这一篇就足够了！）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>       <strong> 前言：Java 提供了丰富的数据结构来处理和管理数据，其中 TreeSet 和 TreeMap 是基于红黑树实现的集合和映射接口。它们有序地存储数据，提供高效的搜索、插入和删除操作。</strong></p> 
<hr> 
<blockquote> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/3b/e2/hdmpF29Z_o.jpg"></p> 
 <p><strong>✨✨✨<span style="color:#ff9900;">这里是秋刀鱼不做梦的BLOG</span></strong></p> 
 <p><span style="color:#ff9900;"><strong>✨✨✨想要了解更多内容可以访问我的主页</strong></span><a href="https://blog.csdn.net/2302_80198073?type=blog" title="秋刀鱼不做梦-CSDN博客">秋刀鱼不做梦-CSDN博客</a></p> 
</blockquote> 
<p><span style="color:#a2e043;"><strong>先让我们看一下本文大致的讲解内容：</strong></span></p> 
<p style="text-align:center;"><span style="color:#a2e043;"><strong><img alt="" src="https://images2.imgbox.com/45/d7/QMsxuIqX_o.png"></strong></span></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%AE%A4%E8%AF%86-toc" style="margin-left:0px;"><strong><a href="#1.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%AE%A4%E8%AF%86" rel="nofollow">1.二叉搜索树的认识</a></strong></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%881%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%881%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">        （1）二叉搜索树的概念</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%882%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%882%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8" rel="nofollow">        （2）二叉搜索树的性质</a></strong></p> 
<p id="2.%E6%9C%89%E5%85%B3%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C-toc" style="margin-left:0px;"><strong><a href="#2.%E6%9C%89%E5%85%B3%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C" rel="nofollow">2.有关二叉搜索树的常用操作</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E3%80%901%E3%80%91%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E3%80%901%E3%80%91%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C" rel="nofollow">        【1】插入操作</a></strong></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E3%80%902%E3%80%91%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E3%80%902%E3%80%91%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C" rel="nofollow">        【2】查找操作</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E3%80%903%E3%80%91%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E3%80%903%E3%80%91%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C" rel="nofollow">        【3】删除操作</a></strong></p> 
<p id="1.cur.left%20%3D%3D%20null-toc" style="margin-left:120px;"><strong><a href="#1.cur.left%20%3D%3D%20null" rel="nofollow">1.cur.left == null</a></strong></p> 
<p id="2.cur.right%20%3D%3D%20null-toc" style="margin-left:120px;"><strong><a href="#2.cur.right%20%3D%3D%20null" rel="nofollow">2.cur.right == null</a></strong></p> 
<p id="3.cur.left%20!%3D%20null%20%26%26%20cur.right%20!%3D%20null-toc" style="margin-left:120px;"><strong><a href="#3.cur.left%20!%3D%20null%20%26%26%20cur.right%20!%3D%20null" rel="nofollow">3.cur.left != null &amp;&amp; cur.right != null</a></strong></p> 
<p id="3.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:0px;"><strong><a href="#3.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">3.二叉树的应用场景</a></strong></p> 
<p id="1.%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-toc" style="margin-left:80px;"><strong><a href="#1.%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95" rel="nofollow">1. 数据结构和算法</a></strong></p> 
<p id="2.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-toc" style="margin-left:80px;"><strong><a href="#2.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F" rel="nofollow">2. 数据库和文件系统</a></strong></p> 
<p id="3.%20%E5%9B%BE%E5%BD%A2%E5%92%8C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91-toc" style="margin-left:80px;"><strong><a href="#3.%20%E5%9B%BE%E5%BD%A2%E5%92%8C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91" rel="nofollow">3. 图形和游戏开发</a></strong></p> 
<hr id="hr-toc"> 
<p></p> 
<p></p> 
<h2 id="1.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%AE%A4%E8%AF%86"><span style="color:#956fe7;">1.二叉搜索树的认识</span></h2> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%881%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5"><span style="color:#956fe7;">        </span><span style="color:#4da8ee;">（1）二叉搜索树的概念</span></h3> 
<p><strong>     </strong>   在开始学习TreeSet与TreeMap之前，我们需要先学习一下Java中的二叉搜索树，二叉搜索树是一种特殊的二叉树，其中每个节点都有一个值，并满足以下性质：</p> 
<ul><li> <p><span style="color:#ff9900;"><strong>对于每个节点，左子树所有节点的值都小于该节点的值。</strong></span></p> </li><li> <p><span style="color:#ff9900;"><strong>对于每个节点，右子树所有节点的值都大于该节点的值。</strong></span></p> </li></ul> 
<p><strong>如图：</strong></p> 
<p style="text-align:center;"><strong><img alt="" src="https://images2.imgbox.com/cf/3b/f5tkn3cy_o.png"></strong></p> 
<p>从上图中我们可以很明显的观察出二叉搜索树的上述两个特性。</p> 
<p></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%882%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8">        <span style="color:#4da8ee;">（2）二叉搜索树的性质</span></h3> 
<p>        在了解完了二叉搜索树的概念之后，我们需要学习一下有关二叉搜索树的性质，对于一棵二叉搜索树而言，其都有以下三个性质：</p> 
<ul><li> <p><span style="color:#ff9900;">有序性：二叉搜索树的中序遍历结果是一个递增的有序序列。</span></p> </li><li> <p><span style="color:#ff9900;">动态性：二叉搜索树支持动态插入和删除操作，适用于需要频繁更新的数据集合。</span></p> </li><li> <p><span style="color:#ff9900;">查找效率：在理想情况下，二叉搜索树的查找、插入和删除操作的时间复杂度为 O(log n)。</span></p> </li></ul> 
<p><span style="color:#a2e043;"><strong>        ——这里读者可能会对其中的一些性质不是很理解，没有关系，继续向下进行阅读即可，在后续的文本中，我们会慢慢的理解其中的意思。</strong></span></p> 
<p></p> 
<h2 id="2.%E6%9C%89%E5%85%B3%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span style="color:#4da8ee;">2.有关二叉搜索树的常用操作</span></h2> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E3%80%901%E3%80%91%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C">     <span style="color:#fe2c24;">   【1】插入操作</span></h3> 
<p><strong>        插入操作用于向二叉搜索树中插入新值。插入过程从根节点开始，根据当前节点的值与新值的比较结果，决定将新值插入到左子树还是右子树。</strong></p> 
<p><span style="color:#ffd900;"><strong>以下是实现该操作的代码：</strong></span></p> 
<pre><code class="language-java">public void insertNode(int key) {
    // 如果根节点为空，直接插入新节点作为根节点
    if (root == null) {
        root = new TreeNode(key);
        return;
    }

    // 初始化当前节点为根节点，父节点为null
    TreeNode cur = root;
    TreeNode parent = null;
    TreeNode node = new TreeNode(key);

    // 寻找合适的位置插入节点
    while (cur != null) {
        if (cur.val &lt; key) { // 当前值小于插入值，向右子树移动
            parent = cur;
            cur = cur.right;
        } else if (cur.val &gt; key) { // 当前值大于插入值，向左子树移动
            parent = cur;
            cur = cur.left;
        } else { // 当前值等于插入值，直接返回，不插入重复值
            return;
        }
    }

    // 根据父节点值与插入值的比较结果，插入新节点到左子树或右子树
    if (parent.val &gt; key) {
        parent.left = node;
    } else {
        parent.right = node;
    }
}
</code></pre> 
<p></p> 
<p><span style="color:#ffdd1a;"><strong>读者可以跟着下面的解释来对上边的代码进行理解：</strong></span></p> 
<blockquote> 
 <ol><li> <p><span style="color:#38d8f0;"><strong>根节点为空检查</strong>：</span></p> 
   <ul><li>如果 <code>root</code> 为空，直接将新节点 <code>TreeNode(key)</code> 作为根节点插入，并返回。</li></ul></li><li> <p><span style="color:#38d8f0;"><strong>初始化当前节点和父节点</strong>：</span></p> 
   <ul><li><code>cur</code> 用于遍历树，从 <code>root</code> 开始。</li><li><code>parent</code> 用于记录 <code>cur</code> 的父节点。</li></ul></li><li> <p><span style="color:#38d8f0;"><strong>寻找合适的插入位置</strong>：</span></p> 
   <ul><li>当 <code>cur</code> 不为空时，比较 <code>cur.val</code> 与 <code>key</code>： 
     <ul><li>如果 <code>cur.val</code> 小于 <code>key</code>，移动到右子树。</li><li>如果 <code>cur.val</code> 大于 <code>key</code>，移动到左子树。</li><li>如果 <code>cur.val</code> 等于 <code>key</code>，直接返回，不插入重复值。</li></ul></li></ul></li><li> <p><span style="color:#38d8f0;"><strong>插入新节点</strong>：</span></p> 
   <ul><li>根据 <code>parent.val</code> 与 <code>key</code> 的比较结果，将新节点插入到 <code>parent</code> 的左子树或右子树。</li></ul></li></ol> 
</blockquote> 
<p><strong><span style="color:#a2e043;">  </span>      ——这样我们就学会了插入操作了！</strong></p> 
<p></p> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E3%80%902%E3%80%91%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C"><strong>        <span style="color:#fe2c24;">【2】查找</span></strong><span style="color:#fe2c24;">操作</span></h3> 
<p>    <strong>    查找操作用于在二叉搜索树中查找特定值。查找过程从根节点开始，根据当前节点的值与目标值的比较结果，决定在左子树还是右子树继续查找。</strong></p> 
<p><span style="color:#ffd900;"><strong>以下是实现该操作的代码：</strong></span></p> 
<pre><code class="language-java">public TreeNode search(int key) {
    // 初始化当前节点为根节点
    TreeNode cur = root;
    
    // 遍历树，直到找到目标节点或遍历到空节点
    while (cur != null) {
        if (cur.val &lt; key) { // 当前节点值小于目标值，移动到右子树
            cur = cur.right;
        } else if (cur.val &gt; key) { // 当前节点值大于目标值，移动到左子树
            cur = cur.left;  // 这里应修正为cur = cur.left;
        } else { // 找到目标节点
            return cur;
        }
    }
    // 如果没有找到目标节点，返回 null
    return null;
}
</code></pre> 
<p><span style="color:#ffdd1a;"><strong>读者可以跟着下面的解释来对上边的代码进行理解：</strong></span></p> 
<blockquote> 
 <ol><li> <p><span style="color:#38d8f0;"><strong>初始化当前节点</strong>：</span></p> 
   <ul><li><code>cur</code> 用于遍历树，从 <code>root</code> 开始。</li></ul></li><li> <p><span style="color:#38d8f0;"><strong>遍历树</strong>：</span></p> 
   <ul><li>当 <code>cur</code> 不为空时，比较 <code>cur.val</code> 与 <code>key</code>： 
     <ul><li>如果 <code>cur.val</code> 小于 <code>key</code>，移动到右子树 (<code>cur = cur.right</code>)。</li><li>如果 <code>cur.val</code> 大于 <code>key</code>，移动到左子树 (<code>cur = cur.left</code>)。</li><li>如果 <code>cur.val</code> 等于 <code>key</code>，返回当前节点。</li></ul></li></ul></li><li> <p><span style="color:#38d8f0;"><strong>返回结果</strong>：</span></p> 
   <ul><li>如果遍历完整棵树没有找到目标节点，返回 <code>null</code>。</li></ul></li></ol> 
</blockquote> 
<p></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E3%80%903%E3%80%91%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C">      <span style="color:#4da8ee;">  【3】删除操作</span></h3> 
<p>        <strong>删除操作用于从二叉搜索树中删除指定值。删除节点分为三种情况：叶子节点、只有一个子节点的节点和有两个子节点的节点。</strong></p> 
<p>        由于删除操作比较哦啊复杂，所以我们这里重点讲解一下，对于删除操作，我们可能会有以下的可能情况：</p> 
<p><span style="color:#ff9900;"><strong>——现在我们假设待删除结点为 cur, 待删除结点的双亲结点为 parent：</strong></span></p> 
<h5 id="1.cur.left%20%3D%3D%20null"><span style="color:#ffd900;"><strong>1.cur.left == null</strong></span></h5> 
<blockquote> 
 <p><strong>        1. cur 是 root，则 root = cur.right<br>         2. cur 不是 root，cur 是 parent.left，则 parent.left = cur.right<br>         3. cur 不是 root，cur 是 parent.right，则 parent.right = cur.right</strong></p> 
</blockquote> 
<h5 id="2.cur.right%20%3D%3D%20null"><span style="color:#ffd900;">2.cur.right == null</span></h5> 
<blockquote> 
 <p>    <strong>    1. cur 是 root，则 root = cur.left<br>         2. cur 不是 root，cur 是 parent.left，则 parent.left = cur.left</strong></p> 
 <p><strong>        3. cur 不是 root，cur 是 parent.right，则 parent.right = cur.left</strong></p> 
</blockquote> 
<h5 id="3.cur.left%20!%3D%20null%20%26%26%20cur.right%20!%3D%20null"><span style="color:#ffd900;"><strong>3.cur.left != null &amp;&amp; cur.right != null</strong></span></h5> 
<blockquote> 
 <p> <strong>       这时我们就需要使用替换法进行删除，即在它的右子树中寻找中序下的第一个结点(关键码最小)，用它的值填补到被删除节点中，再来处理该结点的删除问题</strong></p> 
</blockquote> 
<p><span style="color:#38d8f0;"><strong>我们大致了解了删除的三种可能的大情况之后，现在让我们尝试着编写一下代码：</strong></span></p> 
<pre><code class="language-java">public void remove(int key) {
    TreeNode parent = null; // 父节点初始化为 null
    TreeNode cur = root; // 当前节点初始化为根节点
    // 遍历树，寻找要删除的节点
    while (cur != null) {
        if (cur.val &lt; key) { // 当前值小于目标值，移动到右子树
            parent = cur;
            cur = cur.right;
        } else if (cur.val &gt; key) { // 当前值大于目标值，移动到左子树
            parent = cur;
            cur = cur.left;
        } else { // 找到目标节点
            removeNode(parent, cur); // 调用辅助方法删除节点
            return; // 删除节点后退出方法
        }
    }
}

private void removeNode(TreeNode parent, TreeNode cur) {
    if (cur.right == null) { // 当前节点没有右子树
        if (cur == root) { // 当前节点是根节点
            root = root.left; // 根节点指向左子树
        } else if (parent.left == cur) { // 当前节点是父节点的左子节点
            parent.left = cur.left; // 父节点左子节点指向当前节点的左子树
        } else { // 当前节点是父节点的右子节点
            parent.right = cur.left; // 父节点右子节点指向当前节点的左子树
        }
    } else if (cur.left == null) { // 当前节点没有左子树
        if (cur == root) { // 当前节点是根节点
            root = root.right; // 根节点指向右子树
        } else if (parent.left == cur) { // 当前节点是父节点的左子节点
            parent.left = cur.right; // 父节点左子节点指向当前节点的右子树
        } else { // 当前节点是父节点的右子节点
            parent.right = cur.right; // 父节点右子节点指向当前节点的右子树
        }
    } else { // 当前节点有两个子节点
        TreeNode targetParent = cur; // 目标节点的父节点初始化为当前节点
        TreeNode target = cur.right; // 目标节点初始化为当前节点的右子节点
        // 寻找右子树中的最左节点
        while (target.left != null) {
            targetParent = target;
            target = target.left;
        }
        cur.val = target.val; // 用右子树中最左节点的值替换当前节点的值
        // 调整指针以删除目标节点
        if (targetParent.left == target) {
            targetParent.left = target.right;
        } else {
            targetParent.right = target.right;
        }
    }
}
</code></pre> 
<p><strong>——这里我们给每一条代码都加上了注释，读者可以根据注释来对上述代码进行理解！！！</strong></p> 
<p>这样我们就了解了二叉搜索树中常用的操作了.</p> 
<p></p> 
<h2 id="3.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span style="color:#956fe7;">3.二叉树的应用场景</span></h2> 
<p>        <strong>学习完二叉树的概念以及其基本的使用之后，让我们来学习一些二叉树的应用场景，二叉树（Binary Tree）在日常中有着广泛的应用。以下是一些主要的实际应用场景：</strong></p> 
<h4 id="1.%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95"><span style="color:#38d8f0;">1. <strong>数据结构和算法</strong></span></h4> 
<blockquote> 
 <ul><li> <p><strong>二叉搜索树（BST）</strong>：用于实现高效的搜索、插入和删除操作，时间复杂度平均为 O(log n)。</p> </li><li> <p><strong>平衡树（如AVL树、红黑树）</strong>：这些是自平衡二叉搜索树，确保树的高度保持在 O(log n)，从而提供高效的操作。</p> </li><li> <p><strong>堆（Heap）</strong>：二叉堆用于实现优先队列。最大堆用于实现高效的最大值查找，最小堆用于最小值查找。</p> </li></ul> 
</blockquote> 
<h4 id="2.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span style="color:#38d8f0;">2. <strong>数据库和文件系统</strong></span></h4> 
<blockquote> 
 <ul><li> <p><strong>B树和B+树</strong>：这些是多路搜索树，常用于数据库索引和文件系统索引，以提高查询和检索的效率。</p> </li><li> <p><strong>Trie树</strong>：一种多叉树，用于实现前缀匹配，常用于字典存储和自动补全功能。</p> </li></ul> 
</blockquote> 
<h4 id="3.%20%E5%9B%BE%E5%BD%A2%E5%92%8C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91"><span style="color:#38d8f0;">3. <strong>图形和游戏开发</strong></span></h4> 
<blockquote> 
 <ul><li> <p><strong>四叉树和八叉树</strong>：用于空间分割，以提高碰撞检测、渲染和其他空间查询操作的效率。</p> </li><li> <p><strong>场景图（Scene Graph）</strong>：在3D图形引擎中，场景图是一个树状结构，用于管理和渲染场景中的对象。</p> </li></ul> 
</blockquote> 
<p><strong>这样我们就大致的了解了二叉树在今后的日常中有哪些用武之地了！！！</strong></p> 
<p></p> 
<hr> 
<p style="text-align:center;"><span style="color:#38d8f0;"><strong>以上就是本篇文章的主要内容了！！！</strong></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/05b633fb58f2512d952ad1c37cdd2fc2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Laravel路由模型绑定：简化依赖注入的艺术</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c50896405b04ebc81fffc2c4ca582271/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">el-ui 导航菜单重复点击报错问题解决</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>