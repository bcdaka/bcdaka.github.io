<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>斐波那契数列的C语言多种实现方法（递归、循环、动态规划、矩阵乘法和公式法） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/74752acecc2cf971ba6c224fe7cc6b2a/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="斐波那契数列的C语言多种实现方法（递归、循环、动态规划、矩阵乘法和公式法）">
  <meta property="og:description" content="介绍 斐波那契数列是一个非常有趣的数列，它的每一项都是前两项的和，前两项分别为0和1。这个数列的前几项是：0、1、1、2、3、5、8、13、21、34、55、89、144、233、377、610、987、1597、2584、4181、6765。这个数列的公式可以表示为：
F0 = 0F1 = 1Fn = Fn-1 &#43; Fn-2（n &gt;= 2） 这个数列有许多有趣的性质，例如，两个连续的斐波那契数之比会收敛于黄金比例，约等于1.61803399。
在这篇博客中，我们将探讨如何使用C语言实现斐波那契数列，并讨论各种方法的时间复杂度。
递归实现 递归是最直观的方法，直接根据斐波那契数列的定义F(n) = F(n-1) &#43; F(n-2)来实现。但是这种方法的时间复杂度是O(2^n)，因为它会重复计算很多项，效率非常低。
#include&lt;stdio.h&gt; // 斐波那契数列函数 int fibonacci(int n) { if(n == 0) { return 0; } else if(n == 1) { return 1; } else { return fibonacci(n-1) &#43; fibonacci(n-2); } } int main() { int n; printf(&#34;请输入一个整数：&#34;); scanf(&#34;%d&#34;, &amp;n); printf(&#34;斐波那契数列的第%d项为：%d\n&#34;, n, fibonacci(n)); return 0; } 循环实现 循环实现是一种更有效的方法，它使用两个变量来保存前两项，然后通过循环来计算第n项。这种方法的时间复杂度是O(n)，效率比递归高很多。
#include&lt;stdio.h&gt; // 斐波那契数列函数 int fibonacci(int n) { if(n &lt;= 1) { return n; } int a = 0, b = 1; for(int i = 2; i &lt;= n; i&#43;&#43;) { int temp = a &#43; b; a = b; b = temp; } return b; } int main() { int n; printf(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-12-03T19:12:25+08:00">
    <meta property="article:modified_time" content="2023-12-03T19:12:25+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">斐波那契数列的C语言多种实现方法（递归、循环、动态规划、矩阵乘法和公式法）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>介绍</h2> 
<p>斐波那契数列是一个非常有趣的数列，它的每一项都是前两项的和，前两项分别为0和1。这个数列的前几项是：0、1、1、2、3、5、8、13、21、34、55、89、144、233、377、610、987、1597、2584、4181、6765。这个数列的公式可以表示为：</p> 
<ul><li>F0 = 0</li><li>F1 = 1</li><li>Fn = Fn-1 + Fn-2（n &gt;= 2）</li></ul> 
<p>这个数列有许多有趣的性质，例如，两个连续的斐波那契数之比会收敛于黄金比例，约等于1.61803399。</p> 
<p>在这篇博客中，我们将探讨如何使用C语言实现斐波那契数列，并讨论各种方法的时间复杂度。</p> 
<h3>递归实现</h3> 
<p>递归是最直观的方法，直接根据斐波那契数列的定义F(n) = F(n-1) + F(n-2)来实现。但是这种方法的时间复杂度是O(2^n)，因为它会重复计算很多项，效率非常低。</p> 
<pre><code>#include&lt;stdio.h&gt;

// 斐波那契数列函数
int fibonacci(int n) {
    if(n == 0) {
        return 0;
    } else if(n == 1) {
        return 1;
    } else {
        return fibonacci(n-1) + fibonacci(n-2);
    }
}

int main() {
    int n;
    printf("请输入一个整数：");
    scanf("%d", &amp;n);
    printf("斐波那契数列的第%d项为：%d\n", n, fibonacci(n));
    return 0;
}
</code></pre> 
<h3>循环实现</h3> 
<p>循环实现是一种更有效的方法，它使用两个变量来保存前两项，然后通过循环来计算第n项。这种方法的时间复杂度是O(n)，效率比递归高很多。</p> 
<pre><code>#include&lt;stdio.h&gt;

// 斐波那契数列函数
int fibonacci(int n) {
    if(n &lt;= 1) {
        return n;
    }
    int a = 0, b = 1;
    for(int i = 2; i &lt;= n; i++) {
        int temp = a + b;
        a = b;
        b = temp;
    }
    return b;
}

int main() {
    int n;
    printf("请输入一个整数：");
    scanf("%d", &amp;n);
    printf("斐波那契数列的第%d项为：%d\n", n, fibonacci(n));
    return 0;
}
</code></pre> 
<h3>动态规划实现</h3> 
<p>动态规划也是使用循环，但是它会把前n项都保存在一个数组中，这样就可以避免重复计算。这种方法的时间复杂度也是O(n)，但是空间复杂度也是O(n)，因为需要额外的空间来保存数组。</p> 
<pre><code>#include&lt;stdio.h&gt;

// 斐波那契数列函数
int fibonacci(int n) {
    int f[n+2];   // 1 extra to handle case, n = 0
    int i;
  
    // 0th and 1st number of the series are 0 and 1
    f[0] = 0;
    f[1] = 1;
  
    for (i = 2; i &lt;= n; i++) {
        // Add the previous 2 numbers in the series and store it
        f[i] = f[i-1] + f[i-2];
    }
  
    return f[n];
}

int main () {
    int n;
    printf("请输入一个整数：");
    scanf("%d", &amp;n);
    printf("斐波那契数列的第%d项为：%d\n", n, fibonacci(n));
    return 0;
}
</code></pre> 
<h3>矩阵乘法实现</h3> 
<p>斐波那契数列还可以通过矩阵乘法来计算。具体来说，斐波那契数列可以表示为一个2x2矩阵的n次幂。这种方法的时间复杂度是O(logn)，但是实现起来比较复杂。</p> 
<pre><code>#include&lt;stdio.h&gt;

void multiply(int F[2][2], int M[2][2]);

void power(int F[2][2], int n);

// 斐波那契数列函数
int fibonacci(int n) {
    int F[2][2] = {<!-- -->{1,1},{1,0}};
    if (n == 0)
        return 0;
    power(F, n - 1);
    return F[0][0];
}

void multiply(int F[2][2], int M[2][2]) {
    int x =  F[0][0]*M[0][0] + F[0][1]*M[1][0];
    int y =  F[0][0]*M[0][1] + F[0][1]*M[1][1];
    int z =  F[1][0]*M[0][0] + F[1][1]*M[1][0];
    int w =  F[1][0]*M[0][1] + F[1][1]*M[1][1];
  
    F[0][0] = x;
    F[0][1] = y;
    F[1][0] = z;
    F[1][1] = w;
}

void power(int F[2][2], int n) {
    int i;
    int M[2][2] = {<!-- -->{1,1},{1,0}};
  
    // n - 1 times multiply the matrix to {<!-- -->{1,0},{0,1}}
    for (i = 2; i &lt;= n; i++)
        multiply(F, M);
}

int main () {
    int n;
    printf("请输入一个整数：");
    scanf("%d", &amp;n);
    printf("斐波那契数列的第%d项为：%d\n", n, fibonacci(n));
    return 0;
}
</code></pre> 
<h3>公式法实现</h3> 
<p>斐波那契数列实际上可以通过一个公式直接计算第n项，这个公式叫做Binet’s formula。但是这个公式涉及到无理数和四舍五入，所以在实际使用中可能会有精度问题。这种方法的时间复杂度是O(1)，但是只适用于n较小的情况。</p> 
<pre><code>#include&lt;stdio.h&gt;
#include&lt;math.h&gt;

// 斐波那契数列函数
int fibonacci(int n) {
    double phi = (1 + sqrt(5)) / 2;
    return round(pow(phi, n) / sqrt(5));
}

int main () {
    int n;
    printf("请输入一个整数：");
    scanf("%d", &amp;n);
    printf("斐波那契数列的第%d项为：%d\n", n, fibonacci(n));
    return 0;
}
</code></pre> 
<h3>结论</h3> 
<p>以上就是使用C语言实现斐波那契数列的几种方法，包括递归、循环、动态规划、矩阵乘法和公式法。每种方法都有其优点和缺点，适用于不同的情况。在实际编程中，我们需要根据具体的需求和条件来选择最合适的方法。希望这篇博客对你有所帮助！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/afcfae1ab3f6f08f11f4ef3cee15c5de/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据结构奇妙旅程之顺序表和链表</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bf1da976572a257c10786544f0a640d5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Mac--终端ls报错Operation not permitted</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>