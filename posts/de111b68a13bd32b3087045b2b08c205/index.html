<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python魔法之旅-魔法方法(05) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/de111b68a13bd32b3087045b2b08c205/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Python魔法之旅-魔法方法(05)">
  <meta property="og:description" content="目录
一、概述
1、定义
2、作用
二、应用场景
1、构造和析构
2、操作符重载
3、字符串和表示
4、容器管理
5、可调用对象
6、上下文管理
7、属性访问和描述符
8、迭代器和生成器
9、数值类型
10、复制和序列化
11、自定义元类行为
12、自定义类行为
13、类型检查和转换
14、自定义异常
三、学习方法
1、理解基础
2、查阅文档
3、编写示例
4、实践应用
5、阅读他人代码
6、参加社区讨论
7、持续学习
8、练习与总结
9、注意兼容性
10、避免过度使用
四、魔法方法
17、__float__方法
17-1、语法
17-2、参数
17-3、功能
17-4、返回值
17-5、说明
17-6、用法
18、__floor__方法
18-1、语法
18-2、参数
18-3、功能
18-4、返回值
18-5、说明
18-6、用法
19、__floordiv__方法
19-1、语法
19-2、参数
19-3、功能
19-4、返回值
19-5、说明
19-6、用法
五、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、博客个人主页
一、概述 1、定义 魔法方法(Magic Methods/Special Methods，也称特殊方法或双下划线方法)是Python中一类具有特殊命名规则的方法，它们的名称通常以双下划线(`__`)开头和结尾。
魔法方法用于在特定情况下自动被Python解释器调用，而不需要显式地调用它们，它们提供了一种机制，让你可以定义自定义类时具有与内置类型相似的行为。
2、作用 魔法方法允许开发者重载Python中的一些内置操作或函数的行为，从而为自定义的类添加特殊的功能。
二、应用场景 1、构造和析构 1-1、__init__(self, [args...])：在创建对象时初始化属性。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-31T07:45:00+08:00">
    <meta property="article:modified_time" content="2024-05-31T07:45:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python魔法之旅-魔法方法(05)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong><span style="color:#1a439c;">目录</span></strong></p> 
<p id="%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0-toc" style="margin-left:40px;"><strong><a href="#%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0" rel="nofollow"><span style="color:#1a439c;">一、概述</span></a></strong></p> 
<p id="1%E3%80%81%E5%AE%9A%E4%B9%89-toc" style="margin-left:80px;"><strong><a href="#1%E3%80%81%E5%AE%9A%E4%B9%89" rel="nofollow"><span style="color:#1a439c;">1、定义</span></a></strong></p> 
<p id="2%E3%80%81%E4%BD%9C%E7%94%A8-toc" style="margin-left:80px;"><strong><a href="#2%E3%80%81%E4%BD%9C%E7%94%A8" rel="nofollow"><span style="color:#1a439c;">2、作用</span></a></strong></p> 
<p id="%E4%BA%8C%E3%80%81%E4%B8%BB%E8%A6%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><strong><a href="#%E4%BA%8C%E3%80%81%E4%B8%BB%E8%A6%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow"><span style="color:#1a439c;">二、应用场景</span></a></strong></p> 
<p id="1%E3%80%81%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84-toc" style="margin-left:80px;"><strong><a href="#1%E3%80%81%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84" rel="nofollow"><span style="color:#1a439c;">1、构造和析构</span></a></strong></p> 
<p id="2%E3%80%81%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD-toc" style="margin-left:80px;"><strong><a href="#2%E3%80%81%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD" rel="nofollow"><span style="color:#1a439c;">2、操作符重载</span></a></strong></p> 
<p id="3%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E8%A1%A8%E7%A4%BA-toc" style="margin-left:80px;"><strong><a href="#3%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E8%A1%A8%E7%A4%BA" rel="nofollow"><span style="color:#1a439c;">3、字符串和表示</span></a></strong></p> 
<p id="4%E3%80%81%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86-toc" style="margin-left:80px;"><strong><a href="#4%E3%80%81%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86" rel="nofollow"><span style="color:#1a439c;">4、容器管理</span></a></strong></p> 
<p id="5%E3%80%81%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1-toc" style="margin-left:80px;"><strong><a href="#5%E3%80%81%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1" rel="nofollow"><span style="color:#1a439c;">5、可调用对象</span></a></strong></p> 
<p id="6%E3%80%81%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86-toc" style="margin-left:80px;"><strong><a href="#6%E3%80%81%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86" rel="nofollow"><span style="color:#1a439c;">6、上下文管理</span></a></strong></p> 
<p id="7%E3%80%81%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6-toc" style="margin-left:80px;"><strong><a href="#7%E3%80%81%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6" rel="nofollow"><span style="color:#1a439c;">7、属性访问和描述符</span></a></strong></p> 
<p id="8%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8-toc" style="margin-left:80px;"><strong><a href="#8%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8" rel="nofollow"><span style="color:#1a439c;">8、迭代器和生成器</span></a></strong></p> 
<p id="9%E3%80%81%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B-toc" style="margin-left:80px;"><strong><a href="#9%E3%80%81%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B" rel="nofollow"><span style="color:#1a439c;">9、数值类型</span></a></strong></p> 
<p id="10%E3%80%81%E5%A4%8D%E5%88%B6%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96-toc" style="margin-left:80px;"><strong><a href="#10%E3%80%81%E5%A4%8D%E5%88%B6%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96" rel="nofollow"><span style="color:#1a439c;">10、复制和序列化</span></a></strong></p> 
<p id="11%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%83%E7%B1%BB%E8%A1%8C%E4%B8%BA-toc" style="margin-left:80px;"><strong><a href="#11%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%83%E7%B1%BB%E8%A1%8C%E4%B8%BA" rel="nofollow"><span style="color:#1a439c;">11、自定义元类行为</span></a></strong></p> 
<p id="12%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E8%A1%8C%E4%B8%BA-toc" style="margin-left:80px;"><strong><a href="#12%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E8%A1%8C%E4%B8%BA" rel="nofollow"><span style="color:#1a439c;">12、自定义类行为</span></a></strong></p> 
<p id="13%E3%80%81%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E5%92%8C%E8%BD%AC%E6%8D%A2-toc" style="margin-left:80px;"><strong><a href="#13%E3%80%81%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E5%92%8C%E8%BD%AC%E6%8D%A2" rel="nofollow"><span style="color:#1a439c;">13、类型检查和转换</span></a></strong></p> 
<p id="14%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8-toc" style="margin-left:80px;"><strong><a href="#14%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8" rel="nofollow"><span style="color:#1a439c;">14、自定义异常</span></a></strong></p> 
<p id="%E4%B8%89%E3%80%81%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><strong><a href="#%E4%B8%89%E3%80%81%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">三、学习方法</span></a></strong></p> 
<p id="1%E3%80%81%E7%90%86%E8%A7%A3%E5%9F%BA%E7%A1%80-toc" style="margin-left:80px;"><strong><a href="#1%E3%80%81%E7%90%86%E8%A7%A3%E5%9F%BA%E7%A1%80" rel="nofollow"><span style="color:#1a439c;">1、理解基础</span></a></strong></p> 
<p id="2%E3%80%81%E6%9F%A5%E9%98%85%E6%96%87%E6%A1%A3-toc" style="margin-left:80px;"><strong><a href="#2%E3%80%81%E6%9F%A5%E9%98%85%E6%96%87%E6%A1%A3" rel="nofollow"><span style="color:#1a439c;">2、查阅文档</span></a></strong></p> 
<p id="3%E3%80%81%E7%BC%96%E5%86%99%E7%A4%BA%E4%BE%8B-toc" style="margin-left:80px;"><strong><a href="#3%E3%80%81%E7%BC%96%E5%86%99%E7%A4%BA%E4%BE%8B" rel="nofollow"><span style="color:#1a439c;">3、编写示例</span></a></strong></p> 
<p id="4%E3%80%81%E5%AE%9E%E8%B7%B5%E5%BA%94%E7%94%A8-toc" style="margin-left:80px;"><strong><a href="#4%E3%80%81%E5%AE%9E%E8%B7%B5%E5%BA%94%E7%94%A8" rel="nofollow"><span style="color:#1a439c;">4、实践应用</span></a></strong></p> 
<p id="5%E3%80%81%E9%98%85%E8%AF%BB%E4%BB%96%E4%BA%BA%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><strong><a href="#5%E3%80%81%E9%98%85%E8%AF%BB%E4%BB%96%E4%BA%BA%E4%BB%A3%E7%A0%81" rel="nofollow"><span style="color:#1a439c;">5、阅读他人代码</span></a></strong></p> 
<p id="6%E3%80%81%E5%8F%82%E5%8A%A0%E7%A4%BE%E5%8C%BA%E8%AE%A8%E8%AE%BA-toc" style="margin-left:80px;"><strong><a href="#6%E3%80%81%E5%8F%82%E5%8A%A0%E7%A4%BE%E5%8C%BA%E8%AE%A8%E8%AE%BA" rel="nofollow"><span style="color:#1a439c;">6、参加社区讨论</span></a></strong></p> 
<p id="7%E3%80%81%E6%8C%81%E7%BB%AD%E5%AD%A6%E4%B9%A0-toc" style="margin-left:80px;"><strong><a href="#7%E3%80%81%E6%8C%81%E7%BB%AD%E5%AD%A6%E4%B9%A0" rel="nofollow"><span style="color:#1a439c;">7、持续学习</span></a></strong></p> 
<p id="8%E3%80%81%E7%BB%83%E4%B9%A0%E4%B8%8E%E6%80%BB%E7%BB%93-toc" style="margin-left:80px;"><strong><a href="#8%E3%80%81%E7%BB%83%E4%B9%A0%E4%B8%8E%E6%80%BB%E7%BB%93" rel="nofollow"><span style="color:#1a439c;">8、练习与总结</span></a></strong></p> 
<p id="9%E3%80%81%E6%B3%A8%E6%84%8F%E5%85%BC%E5%AE%B9%E6%80%A7-toc" style="margin-left:80px;"><strong><a href="#9%E3%80%81%E6%B3%A8%E6%84%8F%E5%85%BC%E5%AE%B9%E6%80%A7" rel="nofollow"><span style="color:#1a439c;">9、注意兼容性</span></a></strong></p> 
<p id="10%E3%80%81%E9%81%BF%E5%85%8D%E8%BF%87%E5%BA%A6%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><strong><a href="#10%E3%80%81%E9%81%BF%E5%85%8D%E8%BF%87%E5%BA%A6%E4%BD%BF%E7%94%A8" rel="nofollow"><span style="color:#1a439c;">10、避免过度使用</span></a></strong></p> 
<p id="%E5%9B%9B%E3%80%81%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B-toc" style="margin-left:40px;"><strong><a href="#%E5%9B%9B%E3%80%81%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B" rel="nofollow"><span style="color:#1a439c;">四、魔法方法</span></a></strong></p> 
<p id="1%E3%80%81__abs__%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><strong><a href="#1%E3%80%81__abs__%E6%96%B9%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">17、__float__方法</span></a></strong></p> 
<p id="1-1%E3%80%81%E8%AF%AD%E6%B3%95-toc" style="margin-left:120px;"><strong><a href="#1-1%E3%80%81%E8%AF%AD%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">17-1、语法</span></a></strong></p> 
<p id="1-2%E3%80%81%E5%8F%82%E6%95%B0-toc" style="margin-left:120px;"><strong><a href="#1-2%E3%80%81%E5%8F%82%E6%95%B0" rel="nofollow"><span style="color:#1a439c;">17-2、参数</span></a></strong></p> 
<p id="1-3%E3%80%81%E5%8A%9F%E8%83%BD-toc" style="margin-left:120px;"><strong><a href="#1-3%E3%80%81%E5%8A%9F%E8%83%BD" rel="nofollow"><span style="color:#1a439c;">17-3、功能</span></a></strong></p> 
<p id="1-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC-toc" style="margin-left:120px;"><strong><a href="#1-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC" rel="nofollow"><span style="color:#1a439c;">17-4、返回值</span></a></strong></p> 
<p id="1-5%E3%80%81%E8%AF%B4%E6%98%8E-toc" style="margin-left:120px;"><strong><a href="#1-5%E3%80%81%E8%AF%B4%E6%98%8E" rel="nofollow"><span style="color:#1a439c;">17-5、说明</span></a></strong></p> 
<p id="1-6%E3%80%81%E7%94%A8%E6%B3%95-toc" style="margin-left:120px;"><strong><a href="#1-6%E3%80%81%E7%94%A8%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">17-6、用法</span></a></strong></p> 
<p id="2%E3%80%81__add__%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><strong><a href="#2%E3%80%81__add__%E6%96%B9%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">18、__floor__方法</span></a></strong></p> 
<p id="17-1%E3%80%81%E8%AF%AD%E6%B3%95-toc" style="margin-left:120px;"><strong><a href="#17-1%E3%80%81%E8%AF%AD%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">18-1、语法</span></a></strong></p> 
<p id="18-2%E3%80%81%E5%8F%82%E6%95%B0-toc" style="margin-left:120px;"><strong><a href="#18-2%E3%80%81%E5%8F%82%E6%95%B0" rel="nofollow"><span style="color:#1a439c;">18-2、参数</span></a></strong></p> 
<p id="18-3%E3%80%81%E5%8A%9F%E8%83%BD-toc" style="margin-left:120px;"><strong><a href="#18-3%E3%80%81%E5%8A%9F%E8%83%BD" rel="nofollow"><span style="color:#1a439c;">18-3、功能</span></a></strong></p> 
<p id="18-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC-toc" style="margin-left:120px;"><strong><a href="#18-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC" rel="nofollow"><span style="color:#1a439c;">18-4、返回值</span></a></strong></p> 
<p id="18-5%E3%80%81%E8%AF%B4%E6%98%8E-toc" style="margin-left:120px;"><strong><a href="#18-5%E3%80%81%E8%AF%B4%E6%98%8E" rel="nofollow"><span style="color:#1a439c;">18-5、说明</span></a></strong></p> 
<p id="18-6%E3%80%81%E7%94%A8%E6%B3%95-toc" style="margin-left:120px;"><strong><a href="#18-6%E3%80%81%E7%94%A8%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">18-6、用法</span></a></strong></p> 
<p id="2%E3%80%81__add__%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><strong><a href="#2%E3%80%81__add__%E6%96%B9%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">19、__floordiv__方法</span></a></strong></p> 
<p id="17-1%E3%80%81%E8%AF%AD%E6%B3%95-toc" style="margin-left:120px;"><strong><a href="#17-1%E3%80%81%E8%AF%AD%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">19-1、语法</span></a></strong></p> 
<p id="19-2%E3%80%81%E5%8F%82%E6%95%B0-toc" style="margin-left:120px;"><strong><a href="#19-2%E3%80%81%E5%8F%82%E6%95%B0" rel="nofollow"><span style="color:#1a439c;">19-2、参数</span></a></strong></p> 
<p id="19-3%E3%80%81%E5%8A%9F%E8%83%BD-toc" style="margin-left:120px;"><strong><a href="#19-3%E3%80%81%E5%8A%9F%E8%83%BD" rel="nofollow"><span style="color:#1a439c;">19-3、功能</span></a></strong></p> 
<p id="19-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC-toc" style="margin-left:120px;"><strong><a href="#19-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC" rel="nofollow"><span style="color:#1a439c;">19-4、返回值</span></a></strong></p> 
<p id="19-5%E3%80%81%E8%AF%B4%E6%98%8E-toc" style="margin-left:120px;"><strong><a href="#19-5%E3%80%81%E8%AF%B4%E6%98%8E" rel="nofollow"><span style="color:#1a439c;">19-5、说明</span></a></strong></p> 
<p id="19-6%E3%80%81%E7%94%A8%E6%B3%95-toc" style="margin-left:120px;"><strong><a href="#19-6%E3%80%81%E7%94%A8%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">19-6、用法</span></a></strong></p> 
<p id="%E4%BA%94%E3%80%81%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB-toc" style="margin-left:40px;"><strong><a href="#%E4%BA%94%E3%80%81%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB" rel="nofollow"><span style="color:#1a439c;">五、推荐阅读</span></a></strong></p> 
<p id="1%E3%80%81Python%E7%AD%91%E5%9F%BA%E4%B9%8B%E6%97%85-toc" style="margin-left:80px;"><strong><a href="#1%E3%80%81Python%E7%AD%91%E5%9F%BA%E4%B9%8B%E6%97%85" rel="nofollow"><span style="color:#1a439c;">1、Python筑基之旅</span></a></strong></p> 
<p id="2%E3%80%81Python%E5%87%BD%E6%95%B0%E4%B9%8B%E6%97%85-toc" style="margin-left:80px;"><strong><a href="#2%E3%80%81Python%E5%87%BD%E6%95%B0%E4%B9%8B%E6%97%85" rel="nofollow"><span style="color:#1a439c;">2、Python函数之旅</span></a></strong></p> 
<p id="3%E3%80%81Python%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85-toc" style="margin-left:80px;"><strong><a href="#3%E3%80%81Python%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85" rel="nofollow"><span style="color:#1a439c;">3、Python算法之旅</span></a></strong></p> 
<p id="4%E3%80%81%E5%8D%9A%E5%AE%A2%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5-toc" style="margin-left:80px;"><strong><a href="#4%E3%80%81%E5%8D%9A%E5%AE%A2%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5" rel="nofollow"><span style="color:#1a439c;">4、博客个人主页</span></a></strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/8b/c4/RaHBuhj3_o.gif"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/60/5f/DM2SuyK5_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/32/86/Jy0JIwbX_o.gif"></p> 
<h3 id="%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0">一、概述</h3> 
<h4 id="1%E3%80%81%E5%AE%9A%E4%B9%89">1、定义</h4> 
<p>        <span style="color:#fe2c24;"><strong>魔法方法</strong></span><span style="color:#956fe7;"><strong>(Magic Methods/Special Methods，</strong></span><span style="color:#fe2c24;"><strong>也称特殊方法或双下划线方法</strong></span><span style="color:#956fe7;"><strong>)</strong></span>是Python中<span style="color:#fe2c24;"><strong>一类具有特殊命名规则的方法，它们的名称通常以双下划线(`__`)开头和结尾</strong></span>。</p> 
<p>        <span style="color:#fe2c24;"><strong>魔法方法</strong></span>用于在特定情况下<strong><span style="color:#fe2c24;">自动被Python解释器调用，而不需要显式地调用它们，它们提供了一种机制</span>，</strong>让你可以定义自定义类时具有与内置类型相似的行为。</p> 
<h4 id="2%E3%80%81%E4%BD%9C%E7%94%A8">2、作用</h4> 
<p>        <span style="color:#fe2c24;"><strong>魔法方法</strong></span>允许开发者<span style="color:#fe2c24;"><strong>重载Python中的一些内置操作或函数的行为，从而为自定义的类添加特殊的功能</strong></span>。</p> 
<h3 id="%E4%BA%8C%E3%80%81%E4%B8%BB%E8%A6%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">二、应用场景</h3> 
<h4 id="1%E3%80%81%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84">1、构造和析构</h4> 
<p>1-1、__init__(self, [args...])：在创建对象时初始化属性。<br> 1-2、__new__(cls, [args...])：在创建对象时控制实例的创建过程(通常与元类一起使用)。<br> 1-3、__del__(self)：在对象被销毁前执行清理操作，如关闭文件或释放资源。</p> 
<h4 id="2%E3%80%81%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD">2、操作符重载</h4> 
<p>2-1、__add__(self, other)、__sub__(self, other)、__mul__(self, other)等：自定义对象之间的算术运算。<br> 2-2、__eq__(self, other)、__ne__(self, other)、__lt__(self, other)等：定义对象之间的比较操作。</p> 
<h4 id="3%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E8%A1%A8%E7%A4%BA">3、字符串和表示</h4> 
<p>3-1、__str__(self)：定义对象的字符串表示，常用于print()函数。<br> 3-2、__repr__(self)：定义对象的官方字符串表示，用于repr()函数和交互式解释器。</p> 
<h4 id="4%E3%80%81%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86">4、容器管理</h4> 
<p>4-1、__getitem__(self, key)、__setitem__(self, key, value)、__delitem__(self, key)：用于实现类似列表或字典的索引访问、设置和删除操作。<br> 4-2、__len__(self)：返回对象的长度或元素个数。</p> 
<h4 id="5%E3%80%81%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1">5、可调用对象</h4> 
<p>5-1、__call__(self, [args...])：允许对象像函数一样被调用。</p> 
<h4 id="6%E3%80%81%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86">6、上下文管理</h4> 
<p>6-1、__enter__(self)、__exit__(self, exc_type, exc_val, exc_tb)：用于实现上下文管理器，如with语句中的对象。</p> 
<h4 id="7%E3%80%81%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6">7、属性访问和描述符</h4> 
<p>7-1、__getattr__, __setattr__, __delattr__：这些方法允许对象在访问或修改不存在的属性时执行自定义操作。<br> 7-2、描述符(Descriptors)是实现了__get__, __set__, 和__delete__方法的对象，它们可以控制对另一个对象属性的访问。</p> 
<h4 id="8%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8">8、迭代器和生成器</h4> 
<p>8-1、__iter__和__next__：这些方法允许对象支持迭代操作，如使用for循环遍历对象。<br> 8-2、__aiter__, __anext__：这些是异步迭代器的魔法方法，用于支持异步迭代。</p> 
<h4 id="9%E3%80%81%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">9、数值类型</h4> 
<p>9-1、__int__(self)、__float__(self)、__complex__(self)：定义对象到数值类型的转换。<br> 9-2、__index__(self)：定义对象用于切片时的整数转换。</p> 
<h4 id="10%E3%80%81%E5%A4%8D%E5%88%B6%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96">10、复制和序列化</h4> 
<p>10-1、__copy__和__deepcopy__：允许对象支持浅复制和深复制操作。<br> 10-2、__getstate__和__setstate__：用于自定义对象的序列化和反序列化过程。</p> 
<h4 id="11%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%83%E7%B1%BB%E8%A1%8C%E4%B8%BA">11、自定义元类行为</h4> 
<p>11-1、__metaclass__(Python 2)或元类本身(Python 3)：允许自定义类的创建过程，如动态创建类、修改类的定义等。</p> 
<h4 id="12%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E8%A1%8C%E4%B8%BA">12、自定义类行为</h4> 
<p>12-1、__init__和__new__：用于初始化对象或控制对象的创建过程。<br> 12-2、__init_subclass__：在子类被创建时调用，允许在子类中执行一些额外的操作。</p> 
<h4 id="13%E3%80%81%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E5%92%8C%E8%BD%AC%E6%8D%A2">13、类型检查和转换</h4> 
<p>13-1、__instancecheck__和__subclasscheck__：用于自定义isinstance()和issubclass()函数的行为。</p> 
<h4 id="14%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8">14、自定义异常</h4> 
<p>14-1、你可以通过继承内置的Exception类来创建自定义的异常类，并定义其特定的行为。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e6/c4/W2ClpueU_o.png"></p> 
<h3 id="%E4%B8%89%E3%80%81%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95">三、学习方法</h3> 
<p>        要学好Python的魔法方法，你可以遵循以下方法及步骤：</p> 
<h4 id="1%E3%80%81%E7%90%86%E8%A7%A3%E5%9F%BA%E7%A1%80">1、理解基础</h4> 
<p>        首先确保你对Python的基本语法、数据类型、类和对象等概念有深入的理解，这些是理解魔法方法的基础。</p> 
<h4 id="2%E3%80%81%E6%9F%A5%E9%98%85%E6%96%87%E6%A1%A3">2、查阅文档</h4> 
<p>        仔细阅读Python官方文档中关于魔法方法的部分，文档会详细解释每个魔法方法的作用、参数和返回值。你可以通过访问Python的官方网站或使用help()函数在Python解释器中查看文档。</p> 
<h4 id="3%E3%80%81%E7%BC%96%E5%86%99%E7%A4%BA%E4%BE%8B">3、编写示例</h4> 
<p>        为每个魔法方法编写简单的示例代码，以便更好地理解其用法和效果，通过实际编写和运行代码，你可以更直观地感受到魔法方法如何改变对象的行为。</p> 
<h4 id="4%E3%80%81%E5%AE%9E%E8%B7%B5%E5%BA%94%E7%94%A8">4、实践应用</h4> 
<p>        在实际项目中尝试使用魔法方法。如，你可以创建一个自定义的集合类，使用__getitem__、__setitem__和__delitem__方法来实现索引操作。只有通过实践应用，你才能更深入地理解魔法方法的用途和重要性。</p> 
<h4 id="5%E3%80%81%E9%98%85%E8%AF%BB%E4%BB%96%E4%BA%BA%E4%BB%A3%E7%A0%81">5、阅读他人代码</h4> 
<p>        阅读开源项目或他人编写的代码，特别是那些使用了魔法方法的代码，这可以帮助你学习如何在实际项目中使用魔法方法。通过分析他人代码中的魔法方法使用方式，你可以学习到一些新的技巧和最佳实践。</p> 
<h4 id="6%E3%80%81%E5%8F%82%E5%8A%A0%E7%A4%BE%E5%8C%BA%E8%AE%A8%E8%AE%BA">6、参加社区讨论</h4> 
<p>        参与Python社区的讨论，与其他开发者交流关于魔法方法的使用经验和技巧，在社区中提问或回答关于魔法方法的问题，这可以帮助你更深入地理解魔法方法并发现新的应用场景。</p> 
<h4 id="7%E3%80%81%E6%8C%81%E7%BB%AD%E5%AD%A6%E4%B9%A0">7、持续学习</h4> 
<p>        Python语言和其生态系统不断发展，新的魔法方法和功能可能会不断被引入，保持对Python社区的关注，及时学习新的魔法方法和最佳实践。</p> 
<h4 id="8%E3%80%81%E7%BB%83%E4%B9%A0%E4%B8%8E%E6%80%BB%E7%BB%93">8、练习与总结</h4> 
<p>        多做练习，通过编写各种使用魔法方法的代码来巩固你的理解，定期总结你学到的知识和经验，形成自己的知识体系。</p> 
<h4 id="9%E3%80%81%E6%B3%A8%E6%84%8F%E5%85%BC%E5%AE%B9%E6%80%A7">9、注意兼容性</h4> 
<p>        在使用魔法方法时，要注意不同Python版本之间的兼容性差异，确保你的代码在不同版本的Python中都能正常工作。</p> 
<h4 id="10%E3%80%81%E9%81%BF%E5%85%8D%E8%BF%87%E5%BA%A6%E4%BD%BF%E7%94%A8">10、避免过度使用</h4> 
<p>        虽然魔法方法非常强大，但过度使用可能会导致代码难以理解和维护，在编写代码时，要权衡使用魔法方法的利弊，避免滥用。</p> 
<p>        总之，学好Python的魔法方法需要不断地学习、实践和总结，只有通过不断地练习和积累经验，你才能更好地掌握这些强大的工具，并在实际项目中灵活运用它们。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/07/10/eVYkIfjq_o.png"></p> 
<h3 id="%E5%9B%9B%E3%80%81%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B">四、魔法方法</h3> 
<h4 id="1%E3%80%81__abs__%E6%96%B9%E6%B3%95">17、__float__方法</h4> 
<h5 id="1-1%E3%80%81%E8%AF%AD%E6%B3%95">17-1、语法</h5> 
<pre><code class="language-python">__float__(self, /)
    float(self)</code></pre> 
<h5 id="1-2%E3%80%81%E5%8F%82%E6%95%B0">17-2、参数</h5> 
<p><span style="color:#fe2c24;"><strong>17-2-1、self</strong></span><span style="color:#956fe7;"><strong>(必须)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>一个对实例对象本身的引用，在类的所有方法中都会自动传递。</p> 
<p><span style="color:#fe2c24;"><strong>17-2-2、/</strong></span><span style="color:#956fe7;"><strong>(可选)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>这是从Python 3.8开始引入的参数注解语法，它表示这个方法不接受任何位置参数(positional-only parameters)之后的关键字参数(keyword arguments)。</p> 
<h5 id="1-3%E3%80%81%E5%8A%9F%E8%83%BD">17-3、功能</h5> 
<p>        用于定义一个对象到浮点数的转换规则。</p> 
<h5 id="1-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC">17-4、返回值</h5> 
<p>        返回一个浮点数。</p> 
<h5 id="1-5%E3%80%81%E8%AF%B4%E6%98%8E">17-5、说明</h5> 
<p>        具体来说，以下几种情况可能会触发<code>__<font face="-apple-system, SF UI Text, Arial, PingFang SC, Hiragino Sans GB, Microsoft YaHei, WenQuanYi Micro Hei, sans-serif, SimHei, SimSun">float</font></code><code>__</code>方法的调用：</p> 
<p><strong>17-5-1、</strong>使用内置的<font face="monospace">float</font>函数尝试将一个对象转换为浮点数时。</p> 
<p><strong>17-5-2、</strong>在需要进行数学运算(如加法、减法、乘法、除法等)的上下文中，如果操作数之一是对</p> 
<p>象，而另一个是浮点数或需要浮点数的操作(如除法)，则可能会调用该对象的<code>__float__</code>方法。</p> 
<p><strong>17-5-3、</strong>在需要浮点数类型的其他内置函数或方法中，如果提供了不支持直接操作的对象，可能会</p> 
<p>调用该对象的<code>__float__</code>方法。</p> 
<h5 id="1-6%E3%80%81%E7%94%A8%E6%B3%95">17-6、用法</h5> 
<pre><code class="language-python"># 017、__float__方法：
# 1、简单的数值类
# 定义一个名为SimpleNumber的类
class SimpleNumber:
    # 类的初始化方法，当创建SimpleNumber对象时自动调用
    def __init__(self, value):
        # 将传入的value参数赋值给对象的value属性
        self.value = value
    # 定义__float__方法，用于将对象转换为浮点数
    def __float__(self):
        # 返回self.value的浮点数形式
        return float(self.value)
# 如果这个脚本作为主程序运行（而不是被导入为模块）
if __name__ == '__main__':
    # 创建一个SimpleNumber对象n，并传入值5.2
    n = SimpleNumber(5.2)
    # 使用内置的float函数和SimpleNumber类的__float__方法将n转换为浮点数
    f = float(n)
    # 打印转换后的浮点数f
    print(f)  # 输出: 5.2

# 2、分数类(有理数)
# 定义一个名为Fraction的类，用于表示分数
class Fraction:
    # 初始化方法，当创建Fraction对象时调用
    def __init__(self, numerator, denominator):
        # 设置分数的分子
        self.numerator = numerator
        # 设置分数的分母
        self.denominator = denominator
    # 定义转换为浮点数的特殊方法
    def __float__(self):
        # 返回分数的浮点数值（即分子除以分母）
        return self.numerator / self.denominator
# 如果这个脚本作为主程序运行（而不是被导入为模块）
if __name__ == '__main__':
    # 创建一个Fraction对象f，分子为3，分母为4
    f = Fraction(3, 4)
    # 使用内置的float函数和Fraction类的__float__方法将f转换为浮点数
    float_f = float(f)
    # 打印转换后的浮点数float_f
    print(float_f)  # 输出: 0.75

# 3、带有单位的度量类(如距离)
# 定义一个名为Distance的类，用于表示距离
class Distance:
    # 初始化方法，用于创建Distance对象时设置距离（以米为单位）
    def __init__(self, meters):
        # 将传入的距离值（以米为单位）赋值给对象的meters属性
        self.meters = meters
    # 定义转换为浮点数的特殊方法
    # 当尝试将Distance对象转换为浮点数时，会调用这个方法
    def __float__(self):
        # 返回Distance对象的meters属性的值，作为浮点数
        return self.meters
# 如果这个脚本作为主程序运行（而不是被导入为模块）
if __name__ == '__main__':
    # 创建一个Distance对象d，表示100.5米的距离
    d = Distance(100.5)
    # 使用内置的float函数和Distance类的__float__方法将d转换为浮点数
    float_d = float(d)
    # 打印转换后的浮点数float_d
    print(float_d)  # 输出: 100.5

# 4、复数类(尽管Python内置了复数类型，但可以作为示例)
# 定义一个名为MyComplex的类，用于表示复数
class MyComplex:
    # 初始化方法，用于创建MyComplex对象时设置实部和虚部
    def __init__(self, real, imag):
        # 设置实部
        self.real = real
        # 设置虚部
        self.imag = imag
    # 定义转换为浮点数的特殊方法
    # 当尝试将MyComplex对象转换为浮点数时，会调用此方法
    def __float__(self):
        # 如果虚部不为0
        if self.imag != 0:
            # 抛出ValueError异常，表示不能将有虚部的复数转换为浮点数
            raise ValueError("Cannot convert complex number with imaginary part to float")
            # 如果虚部为0，则返回实部的浮点数值
        return float(self.real)
# 如果这个脚本作为主程序运行（而不是被导入为模块）
if __name__ == '__main__':
    # 创建一个实部为3，虚部为0的MyComplex对象c
    c = MyComplex(3, 0)
    # 使用内置的float函数和MyComplex类的__float__方法将c转换为浮点数
    f = float(c)
    # 打印转换后的浮点数f
    print(f)  # 输出: 3.0
    try:
        # 创建一个实部为3，虚部为4的MyComplex对象c_with_imag
        c_with_imag = MyComplex(3, 4)
        # 尝试将c_with_imag转换为浮点数，但由于虚部不为0，所以会抛出ValueError异常
        float_c_with_imag = float(c_with_imag)  # 这会抛出ValueError
    except ValueError as e:
        # 捕获ValueError异常并打印异常信息
        print(e)  # 输出: Cannot convert complex number with imaginary part to float

# 5、时间类(转换为以秒为单位的浮点数)
# 从datetime模块中导入timedelta类，timedelta类用于表示两个日期或时间之间的差异
from datetime import timedelta
# 定义一个名为TimeDuration的类，用于封装timedelta并允许通过不同的时间单位进行初始化
class TimeDuration:
    def __init__(self, days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0):
        # 因为timedelta不接受milliseconds参数，并且weeks参数需要转换为days，所以我们先进行计算
        # 将weeks转换为days（1周 = 7天）
        # 注意：在Python 3中，timedelta直接支持weeks参数，但在Python 2中不支持
        td = timedelta(days=days + weeks * 7, seconds=seconds, microseconds=microseconds, minutes=minutes, hours=hours)
        # 如果提供了毫秒（milliseconds），则需要将其转换为秒和微秒
        # 注意：这里我们省略了毫秒的转换，因为timedelta不接受毫秒作为直接参数
        # 如果需要，可以在此添加转换逻辑
        # 将计算好的timedelta赋值给实例的duration属性
        self.duration = td
    # 定义转换为浮点数的特殊方法，返回时间差的总秒数
    def __float__(self):
        # 调用辅助函数total_seconds来获取duration的总秒数
        # 注意：在Python 3中，timedelta有一个total_seconds()方法，但在Python 2中没有
        return total_seconds(self.duration)
# 辅助函数，用于计算timedelta对象的总秒数
# 在Python 2中，timedelta没有直接的total_seconds方法，所以我们自己实现
def total_seconds(td):
    # 计算总秒数，包括天、小时、分钟、秒和微秒
    return (td.microseconds + (td.seconds + td.days * 24 * 3600) * 1e6) / 1e6
if __name__ == '__main__':
    # 创建一个TimeDuration对象，表示1天2小时30分钟的时间差
    td = TimeDuration(days=1, hours=2, minutes=30)
    # 使用内置的float函数和TimeDuration类的__float__方法将td转换为浮点数（总秒数）
    float_td = float(td)
    # 打印转换后的总秒数
    print(float_td)  # 输出: 95400.0（具体取决于你的系统时间精度，但在这个例子中应该是准确的）

# 6、字符串表示的数字转换为浮点数
# 定义一个名为 StringNumber 的类，用于将字符串表示的数字转换为浮点数
class StringNumber:
    # 初始化方法，接收一个字符串类型的数字作为参数
    def __init__(self, number_str):
        # 将接收到的字符串类型的数字保存到实例变量 number_str 中
        self.number_str = number_str
    # 定义转换为浮点数的特殊方法
    # 当尝试将 StringNumber 对象转换为浮点数时，会调用此方法
    def __float__(self):
        # 使用 Python 内置的 float 函数将 number_str 转换为浮点数
        # 并返回这个浮点数
        return float(self.number_str)
# 判断当前脚本是否作为主程序运行（而不是被导入为模块）
if __name__ == '__main__':
    # 创建一个 StringNumber 对象，传入一个表示数字的字符串 "3.14159"
    sn = StringNumber("3.14159")
    # 使用内置的 float 函数和 StringNumber 类的 __float__ 方法将 sn 转换为浮点数
    # 注意：这里实际上不需要显式调用 float(sn)，因为当 sn 被用于需要浮点数的上下文中时，
    # Python 会自动调用 sn 的 __float__ 方法。但为了展示和明确转换，这里显式调用了 float(sn)
    f = float(sn)
    # 打印转换后的浮点数
    print(f)  # 输出: 3.14159</code></pre> 
<h4 id="2%E3%80%81__add__%E6%96%B9%E6%B3%95">18、__floor__方法</h4> 
<h5 id="17-1%E3%80%81%E8%AF%AD%E6%B3%95">18-1、语法</h5> 
<pre><code class="language-python">__floor__(self, /)
    Flooring an Integral returns itself</code></pre> 
<h5 id="18-2%E3%80%81%E5%8F%82%E6%95%B0">18-2、参数</h5> 
<p><span style="color:#fe2c24;"><strong>18-2-1、self</strong></span><span style="color:#956fe7;"><strong>(必须)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>一个对实例对象本身的引用，在类的所有方法中都会自动传递。</p> 
<p><span style="color:#fe2c24;"><strong>18-2-2、/</strong></span><span style="color:#956fe7;"><strong>(可选)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>这是从Python 3.8开始引入的参数注解语法，它表示这个方法不接受任何位置参数(positional-only parameters)之后的关键字参数(keyword arguments)。</p> 
<h5 id="18-3%E3%80%81%E5%8A%9F%E8%83%BD">18-3、功能</h5> 
<p>        用于定义数值类型的“向下取整”行为。</p> 
<h5 id="18-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC">18-4、返回值</h5> 
<p>        返回不大于对象所表示数值的最大整数，也就是所谓的“向下取整”或“地板除”的结果。</p> 
<h5 id="18-5%E3%80%81%E8%AF%B4%E6%98%8E">18-5、说明</h5> 
<p>        关于返回值，<code>__floor__</code>方法应该返回一个与原始对象相同类型或兼容类型的对象，其值是不大于原始对象所表示数值的最大整数。</p> 
<h5 id="18-6%E3%80%81%E7%94%A8%E6%B3%95">18-6、用法</h5> 
<pre><code class="language-python"># 018、__floor__方法：
# 1、基本使用
# 定义一个名为 MyNumber 的类，用于封装一个数值并提供一些特殊方法
class MyNumber:
    # 类的初始化方法，用于创建 MyNumber 类的实例
    def __init__(self, value):
        # 将传入的 value 参数赋值给实例变量 self.value
        self.value = value
    # 定义一个特殊方法 __floor__，用于返回 self.value 的向下取整值
    def __floor__(self):
        # 导入 math 模块，尽管在类中导入模块不是最佳实践，但这里为了注释而保留
        import math
        # 调用 math.floor 方法对 self.value 进行向下取整，并返回结果
        return math.floor(self.value)
# 当这个脚本作为主程序运行时，以下代码块会被执行
if __name__ == '__main__':
    # 创建一个 MyNumber 类的实例 num，并传入初始值 3.7
    num = MyNumber(3.7)
    # 调用 num 实例的 __floor__ 方法，并打印返回的结果，即 3.7 的向下取整值
    print(num.__floor__())  # 输出: 3

# 2、自定义运算符中的使用
# 导入math模块，该模块包含了一些数学运算的函数和常量
import math
# 定义一个名为MyNumber的类，用于封装数值并提供自定义的数学运算
class MyNumber:
    # 初始化方法，用于创建MyNumber对象时设置初始值
    def __init__(self, value):
        self.value = value  # 将传入的value赋值给对象的value属性
    # 定义一个特殊方法__floor__，用于返回对象的value属性的向下取整值
    def __floor__(self):
        return math.floor(self.value)  # 使用math模块中的floor函数对value进行向下取整
    # 定义一个特殊方法__int__，用于将MyNumber对象转换为整数
    def __int__(self):
        return int(self.value)  # 定义__int__方法以返回整数值，这里将value转换为整数并返回
    # 定义一个特殊方法__add__，用于实现MyNumber对象之间的加法运算
    def __add__(self, other):
        if isinstance(other, MyNumber):  # 如果other也是MyNumber对象
            return MyNumber(self.value + other.value)  # 返回两个对象value属性之和组成的新MyNumber对象
        else:  # 如果other不是MyNumber对象
            return MyNumber(self.value + other)  # 返回对象value属性与other之和组成的新MyNumber对象
    # 定义一个特殊方法__floordiv__，用于实现MyNumber对象之间的整数除法运算
    def __floordiv__(self, other):
        if isinstance(other, MyNumber):  # 如果other也是MyNumber对象
            floored_self = self.__floor__()  # 对self的value属性进行向下取整
            floored_other = other.__floor__()  # 对other的value属性进行向下取整
            return MyNumber(floored_self // floored_other)  # 返回两个向下取整后的值进行整除运算的结果组成的新MyNumber对象
        else:  # 如果other不是MyNumber对象
            return MyNumber(self.__floor__() // other)  # 对self的value属性进行向下取整，然后与other进行整除运算，返回结果组成的新MyNumber对象
# 当这个脚本作为主程序运行时，以下代码块会被执行
if __name__ == '__main__':
    # 创建两个MyNumber对象num1和num2，并分别设置初始值7.3和2
    num1 = MyNumber(7.3)
    num2 = MyNumber(2)
    # 使用//运算符调用num1的__floordiv__方法，与num2进行整数除法运算，并打印结果
    print(num1 // num2)  # 使用__floordiv__，输出: MyNumber(3)
    # 将num1和num2进行整数除法运算的结果转换为整数并打印
    print(int(num1 // num2))  # 现在可以正确转换为整数，输出: 3

# 3、在类中自动转换
# 定义一个名为MyNumber的类，用于封装数值并提供一些特殊方法
class MyNumber:
    # 类的初始化方法，用于设置对象的初始值
    def __init__(self, value):
        # 将传入的value参数赋值给对象的value属性
        self.value = value
    # 定义一个特殊方法__floor__，用于返回对象value属性的向下取整值
    def __floor__(self):
        # 导入math模块，该模块包含数学相关的函数
        import math
        # 调用math模块中的floor函数对value进行向下取整，并返回结果
        return math.floor(self.value)
    # 定义一个特殊方法__int__，用于将对象转换为整数类型
    def __int__(self):
        # 调用__floor__方法获取value的向下取整值
        # 然后将该值转换为整数类型并返回
        return int(self.__floor__())
# 当这个脚本作为主程序运行时，以下代码块会被执行
if __name__ == '__main__':
    # 创建一个MyNumber对象num，并传入初始值3.7
    num = MyNumber(3.7)
    # 调用num对象的__int__方法，将其转换为整数类型并打印结果
    # 这里通过内置的int函数间接调用了num的__int__方法
    print(int(num))  # 输出: 3

# 4、类的继承与重写
# 定义一个名为MyNumber的类，用于封装数值并提供向下取整的方法
class MyNumber:
    # 类的初始化方法，用于设置对象的初始值
    def __init__(self, value):
        # 将传入的value参数赋值给对象的value属性
        self.value = value
    # 定义一个特殊方法__floor__，用于返回对象value属性的向下取整值
    def __floor__(self):
        # 导入math模块（虽然通常建议在文件顶部导入，但这里为了说明也可在方法内部导入）
        import math
        # 调用math模块中的floor函数对value进行向下取整，并返回结果
        return math.floor(self.value)
    # 定义一个特殊方法__int__，用于将对象转换为整数类型
    def __int__(self):
        # 调用__floor__方法获取value的向下取整值
        # 然后将该值转换为整数类型并返回
        return int(self.__floor__())
# 定义一个继承自MyNumber的SpecialNumber类
class SpecialNumber(MyNumber):
    # 重写父类MyNumber的__floor__方法
    def __floor__(self):
        # 使用super()函数调用父类MyNumber的__floor__方法
        # 然后将返回的结果减1，得到SpecialNumber对象的特殊向下取整值
        return super().__floor__() - 1
# 当这个脚本作为主程序运行时，以下代码块会被执行
if __name__ == '__main__':
    # 创建一个SpecialNumber对象num，并传入初始值4.3
    num = SpecialNumber(4.3)
    # 调用num对象的__int__方法，将其转换为整数类型并打印结果
    # 这里通过内置的int函数间接调用了num的__int__方法
    # SpecialNumber类重写了__floor__方法，所以其__int__方法返回的是特殊向下取整后的整数值
    print(int(num))  # 输出: 3，因为 4.3 向下取整是 4，然后减 1 得到 3

# 5、与其他类型进行比较
# 定义一个名为MyNumber的类，用于封装数值并提供一些特殊方法
class MyNumber:
    # 类的初始化方法，用于设置对象的初始值
    def __init__(self, value):
        # 将传入的value参数赋值给对象的value属性
        self.value = value
    # 定义一个特殊方法__floor__，用于返回对象value属性的向下取整值
    def __floor__(self):
        # 导入math模块（尽管通常在文件顶部导入模块，但在此为了注释说明也可以放在方法内部）
        import math
        # 调用math模块中的floor函数对value进行向下取整，并返回结果
        return math.floor(self.value)
    # 定义一个特殊方法__eq__，用于比较两个对象是否相等
    def __eq__(self, other):
        # 如果other是整数类型
        if isinstance(other, int):
            # 则比较MyNumber对象的向下取整值是否等于other
            return self.__floor__() == other
        # 如果other不是整数类型，则返回NotImplemented，表示不支持该类型的比较
        # 这样可以让Python尝试进行其他类型的比较（如other也是MyNumber对象）
        return NotImplemented
# 当这个脚本作为主程序运行时，以下代码块会被执行
if __name__ == '__main__':
    # 创建一个MyNumber对象num，并传入初始值3.0
    num = MyNumber(3.0)
    # 使用==操作符比较num对象和整数3是否相等
    # 由于num的value是3.0，向下取整后仍为3，所以比较结果为True
    print(num == 3)  # 输出: True

# 6: 自定义格式化输出
# 定义一个名为 MyNumber 的类
class MyNumber:
    # 类的初始化方法，用于创建 MyNumber 类的实例
    def __init__(self, value):
        # 将传入的 value 赋值给实例变量 self.value
        self.value = value
    # 定义一个特殊方法 __floor__，它用于实现取整（向下取整）的功能
    def __floor__(self):
        # 导入 math 模块（尽管这里最好是在文件顶部导入，但为了符合仅注释代码的要求，这里也可以接受）
        import math
        # 使用 math.floor 方法对 self.value 进行向下取整，并返回结果
        return math.floor(self.value)
    # 定义一个特殊方法 __format__，它允许对象自定义其字符串表示形式
    # format_spec 是格式说明符，它描述了如何格式化对象
    def __format__(self, format_spec):
        # 如果格式说明符为 '.floor'，则调用 __floor__ 方法并返回其结果的字符串形式
        if format_spec == '.floor':
            return str(self.__floor__())
            # 如果格式说明符不是 '.floor'，则返回 NotImplemented，表示不支持该格式
        return NotImplemented
# 如果当前运行的脚本（而不是导入的模块）是主程序，则执行以下代码
if __name__ == '__main__':
    # 创建一个 MyNumber 类的实例 num，并传入值 3.7
    num = MyNumber(3.7)
    # 使用 format 函数和 '.floor' 格式说明符来格式化 num 对象，并打印结果
    # 由于 MyNumber 类定义了 __format__ 方法并处理了 '.floor' 格式说明符，因此这里会输出 '3'
    print(format(num, '.floor'))  # 输出: '3'</code></pre> 
<h4>19、__floordiv__方法</h4> 
<h5>19-1、语法</h5> 
<pre><code class="language-python">__floordiv__(self, other, /)
    Return self//other</code></pre> 
<h5 id="19-2%E3%80%81%E5%8F%82%E6%95%B0">19-2、参数</h5> 
<p><span style="color:#fe2c24;"><strong>19-2-1、self</strong></span><span style="color:#956fe7;"><strong>(必须)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>一个对实例对象本身的引用，在类的所有方法中都会自动传递。</p> 
<p><span style="color:#fe2c24;"><strong>19-2-2、other</strong></span><span style="color:#956fe7;"><strong>(必须)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>表示与self进行地板除法的另一个值，它可以是任何类型，但通常应该是与</p> 
<p>self兼容的数值类型。</p> 
<p><span style="color:#fe2c24;"><strong>19-2-3、/</strong></span><span style="color:#956fe7;"><strong>(可选)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>这是从Python 3.8开始引入的参数注解语法，它表示这个方法不接受任何位置参数(positional-only parameters)之后的关键字参数(keyword arguments)。</p> 
<h5 id="19-3%E3%80%81%E5%8A%9F%E8%83%BD">19-3、功能</h5> 
<p>        用于定义当对象使用<code>//</code>运算符进行地板除法时的行为。</p> 
<h5 id="19-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC">19-4、返回值</h5> 
<p>        返回一个表示地板除法结果的对象。</p> 
<h5 id="19-5%E3%80%81%E8%AF%B4%E6%98%8E">19-5、说明</h5> 
<p>        对于__floordiv__方法，它的返回值通常是与原始对象类型相同或兼容的数值类型对象，其值是两个操作数进行地板除法的结果，然而，这个返回值的具体类型完全取决于你的实现。</p> 
<h5 id="19-6%E3%80%81%E7%94%A8%E6%B3%95">19-6、用法</h5> 
<pre><code class="language-python"># 019、__floordiv__方法：
# 1、简单的整数类
class SimpleInt:
    def __init__(self, value):
        # 初始化方法，设置实例的 value 属性
        self.value = value
    def __floordiv__(self, other):
        # 定义地板除法运算符的行为
        if isinstance(other, (int, float)):
            # 如果 other 是整数或浮点数，则执行地板除法并返回结果
            return self.value // other
        else:
            # 如果 other 不是整数或浮点数，则抛出类型错误
            raise TypeError("Unsupported operand type(s) for //: 'SimpleInt' and '{}'".format(type(other).__name__))
if __name__ == '__main__':
    # 创建一个 SimpleInt 类的实例 a，并设置其值为 10
    a = SimpleInt(10)
    # 定义一个普通的整数 b，其值为 3
    b = 3
    # 使用 // 运算符调用 a 的 __floordiv__ 方法，并打印结果
    # 这里将输出整数 3，因为 10 // 3 的结果是 3
    print(a // b)  # 这会调用 SimpleInt 的 __floordiv__ 方法，输出应为 3

# 2、自定义除法规则类
class CustomDiv:
    def __init__(self, value):
        # 初始化方法，设置实例的value属性
        self.value = value
    def __floordiv__(self, other):
        # 地板除法特殊方法，用于处理自定义除法规则
        if isinstance(other, int):
            # 检查other是否为整数
            # 如果self.value是非负数，则执行正常的地板除法（即减去余数）
            # 如果self.value是负数，则先取负数的绝对值进行整除，再取负值（因为负数的整除行为是向负无穷方向取整）
            return self.value - (self.value % other) if self.value &gt;= 0 else -((-self.value) // other)
        else:
            # 如果other不是整数，则抛出类型错误
            raise TypeError("Unsupported operand type(s) for //: 'CustomDiv' and '{}'".format(type(other).__name__))
if __name__ == '__main__':
    # 创建一个CustomDiv实例，并设置其value为10
    cd = CustomDiv(10)
    # 调用CustomDiv的__floordiv__方法（即执行cd // 3），并打印结果
    # 因为10 &gt;= 0，所以直接执行self.value - (self.value % other)，即10 - (10 % 3) = 10 - 1 = 9
    print(cd // 3)  # 输出：9
    # 直接使用类名和参数创建另一个CustomDiv实例，其value为-10
    # 调用该实例的__floordiv__方法（即执行CustomDiv(-10) // 3），并打印结果
    # 因为-10 &lt; 0，所以先取-10的绝对值（即10），执行整除10 // 3 = 3，然后取负值，即-3
    print(CustomDiv(-10) // 3)  # 输出：-3（因为-10 &lt; 0, 所以取-((-10) // 3)）

# 3、时间类(用于计算时间差)
from datetime import timedelta
class TimeDuration:
    def __init__(self, hours, minutes, seconds):
        # 初始化方法，接收小时、分钟和秒作为参数，并使用timedelta创建时间差对象
        self.duration = timedelta(hours=hours, minutes=minutes, seconds=seconds)
    def __floordiv__(self, other):
        # 定义地板除法运算符的行为
        if isinstance(other, TimeDuration):
            # 如果 other 是 TimeDuration 的实例，则计算 self 的总秒数与 other 的总秒数
            # 使用整数除法来计算 self 可以包含多少个 other
            # 假设我们想以 other 的时长为单位，计算 self 的时长可以包含多少个 other
            total_seconds = self.duration.total_seconds()  # 获取 self 的总秒数
            other_seconds = other.duration.total_seconds()  # 获取 other 的总秒数
            # 使用整数除法 // 来获取结果，并返回结果
            return int(total_seconds // other_seconds)
        else:
            # 如果 other 不是 TimeDuration 的实例，则抛出类型错误
            raise TypeError(f"Unsupported operand type(s) for //: 'TimeDuration' and '{type(other).__name__}'")
    def __str__(self):
        # 定义字符串表示方法，返回 timedelta 对象的字符串表示
        return str(self.duration)
if __name__ == '__main__':
    # 创建一个 TimeDuration 对象 duration_a，表示 2 小时 30 分钟
    duration_a = TimeDuration(2, 30, 0)  # 2小时30分钟
    # 创建一个 TimeDuration 对象 duration_b，表示 15 分钟
    duration_b = TimeDuration(0, 15, 0)  # 15分钟
    # 使用地板除法运算符 // 来计算 duration_a 包含多少个 duration_b
    # 输出结果应为 10，因为 2 小时 30 分钟 包含 10 个 15 分钟
    print(duration_a // duration_b)  # 输出: 10 (因为 2小时30分钟 包含 10个15分钟)

# 4、自定义货币类(用于货币除法并取整)
class Currency:
    def __init__(self, amount, currency_code='USD'):
        # 初始化方法，接受货币金额和货币代码作为参数，默认为USD
        self.amount = float(amount)
        # 将货币金额转换为浮点数并存储在self.amount中
        self.currency_code = currency_code
        # 存储货币代码在self.currency_code中
    def __floordiv__(self, other):
        # 定义地板除法运算符的行为
        if isinstance(other, (int, float, Currency)):
            # 检查其他对象是否为整数、浮点数或Currency的实例
            if isinstance(other, Currency):
                # 如果其他对象是Currency的实例，则提取其金额
                other_amount = other.amount
            else:
                # 如果其他对象是整数或浮点数，则将其转换为浮点数
                other_amount = float(other)
            # 使用Python内置的整数除法//来计算结果，并创建一个新的Currency对象来存储结果
            return Currency(self.amount // other_amount, self.currency_code)
        else:
            # 如果其他对象不是整数、浮点数或Currency的实例，则抛出TypeError
            raise TypeError(f"Unsupported operand type(s) for //: 'Currency' and '{type(other).__name__}'")
    def __str__(self):
        # 定义字符串表示方法，返回货币金额和货币代码的字符串表示
        return f"{self.amount} {self.currency_code}"
if __name__ == '__main__':
    # 创建一个Currency对象money_a，表示100.00 USD
    money_a = Currency(100.00)
    # 创建一个Currency对象money_b，表示20.00 USD
    money_b = Currency(20.00)
    # 使用地板除法运算符//计算money_a除以money_b的结果，并打印结果，预期输出: 5.0 USD
    print(money_a // money_b)  # 输出: 5.0 USD (注意这里虽然用浮点数表示，但实际是整数除法)
    # 使用浮点数2作为除数，再次计算money_a的结果，并打印结果，预期输出: 50.0 USD
    # 注意这里由于self.amount是浮点数，而//是整数除法，但在Python 3中，//对于浮点数执行的是向下取整的除法
    print(money_a // 2)  # 输出: 50.0 USD</code></pre> 
<h3 id="%E4%BA%94%E3%80%81%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB">五、推荐阅读</h3> 
<h4 id="1%E3%80%81Python%E7%AD%91%E5%9F%BA%E4%B9%8B%E6%97%85">1、<a href="https://myelsa1024.blog.csdn.net/article/details/139241094?spm=1001.2014.3001.5502" rel="nofollow" title="Python筑基之旅">Python筑基之旅</a></h4> 
<h4 id="2%E3%80%81Python%E5%87%BD%E6%95%B0%E4%B9%8B%E6%97%85">2、<a href="https://myelsa1024.blog.csdn.net/article/details/138916144?spm=1001.2014.3001.5502" rel="nofollow" title="Python函数之旅">Python函数之旅</a></h4> 
<h4 id="3%E3%80%81Python%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85">3、<a href="https://blog.csdn.net/ygb_1024/article/details/136889623?spm=1001.2014.3001.5501" title="Python算法之旅">Python算法之旅</a></h4> 
<h4 id="4%E3%80%81%E5%8D%9A%E5%AE%A2%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5">4、<a href="https://blog.csdn.net/ygb_1024?spm=1010.2135.3001.5421" title="博客个人主页">博客个人主页</a></h4> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5fbc9ec8df7a3e14562528de5ffba1ab/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Kafka 如何保证可靠性</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/27d9198412950e8667fbbba1ff4f0987/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Redis用GEO实现附近的人功能</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>