<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言 链表经典OJ题 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/ac5c9191f718b888db6acef06c78c59f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C语言 链表经典OJ题">
  <meta property="og:description" content="链表经典OJ题 移除链表元素链表的中间节点反转链表合并两个有序链表分割链表 移除链表元素 给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。
示例 1：
输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5]
示例 2：
输入：head = [], val = 1 输出：[]
示例 3：
输入：head = [7,7,7,7], val = 7 输出：[]
提示：
列表中的节点数目在范围 [0, 104] 内 1 &lt;= Node.val &lt;= 50 0 &lt;= val &lt;= 50 题目链接：link
本题不同于基本操作中的头删尾删等，因为头结点也有可能是要删掉的，那这个时候就比较麻烦了，所以我们最好是重新定义一个链表，遍历原链表不为val的节点，尾插在新链表中。
/** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ struct ListNode* create(int x) { struct ListNode* new=(struct ListNode*)malloc(sizeof(struct ListNode)); new-&gt;val=x; new-&gt;next=NULL; return new; } void PushBack(struct ListNode** pp,int x,struct ListNode** ppt) { struct ListNode* new=create(x); if(*pp==NULL) { *pp=new; *ppt=new; return; } (*ppt)-&gt;next=new; (*ppt)=(*ppt)-&gt;next; } struct ListNode* removeElements(struct ListNode* head, int val) { struct ListNode* newhead=NULL; struct ListNode* tail=NULL; struct ListNode* cur=head; while(cur!">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-03T19:56:01+08:00">
    <meta property="article:modified_time" content="2024-06-03T19:56:01+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言 链表经典OJ题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>链表经典OJ题</h4> 
 <ul><li><a href="#_1" rel="nofollow">移除链表元素</a></li><li><a href="#_112" rel="nofollow">链表的中间节点</a></li><li><a href="#_152" rel="nofollow">反转链表</a></li><li><a href="#_220" rel="nofollow">合并两个有序链表</a></li><li><a href="#_282" rel="nofollow">分割链表</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>移除链表元素</h2> 
<blockquote> 
 <p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并<em><strong>返回 新的头节点</strong></em> 。</p> 
</blockquote> 
<blockquote> 
 <p>示例 1：</p> 
 <p>输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5]</p> 
 <p>示例 2：</p> 
 <p>输入：head = [], val = 1 输出：[]</p> 
 <p>示例 3：</p> 
 <p>输入：head = [7,7,7,7], val = 7 输出：[]</p> 
 <p>提示：</p> 
 <pre><code>列表中的节点数目在范围 [0, 104] 内
1 &lt;= Node.val &lt;= 50
0 &lt;= val &lt;= 50
</code></pre> 
</blockquote> 
<p><strong>题目链接</strong>：<a href="https://leetcode.cn/problems/remove-linked-list-elements/description/" rel="nofollow">link</a></p> 
<p>本题不同于基本操作中的头删尾删等，因为头结点也有可能是要删掉的，那这个时候就比较麻烦了，所以我们最好是重新定义一个链表，遍历原链表不为val的节点，<strong>尾插在新链表中</strong>。</p> 
<pre><code class="prism language-c"><span class="token comment">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> new<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    new<span class="token operator">-&gt;</span>val<span class="token operator">=</span>x<span class="token punctuation">;</span>
    new<span class="token operator">-&gt;</span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> new<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">PushBack</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span><span class="token operator">*</span> pp<span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span><span class="token operator">*</span> ppt<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> new<span class="token operator">=</span><span class="token function">create</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>pp<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token operator">*</span>pp<span class="token operator">=</span>new<span class="token punctuation">;</span>
        <span class="token operator">*</span>ppt<span class="token operator">=</span>new<span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">(</span><span class="token operator">*</span>ppt<span class="token punctuation">)</span><span class="token operator">-&gt;</span>next<span class="token operator">=</span>new<span class="token punctuation">;</span>
    <span class="token punctuation">(</span><span class="token operator">*</span>ppt<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token operator">*</span>ppt<span class="token punctuation">)</span><span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> <span class="token function">removeElements</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> newhead<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> tail<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> cur<span class="token operator">=</span>head<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>val<span class="token operator">!=</span>val<span class="token punctuation">)</span>
            <span class="token function">PushBack</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>newhead<span class="token punctuation">,</span>cur<span class="token operator">-&gt;</span>val<span class="token punctuation">,</span><span class="token operator">&amp;</span>tail<span class="token punctuation">)</span><span class="token punctuation">;</span>
        cur<span class="token operator">=</span>cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> newhead<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>另外官方题解用了递归迭代的方式也很值得学习：</p> 
<p>迭代：</p> 
<pre><code class="prism language-c"><span class="token comment">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> <span class="token function">removeElements</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> dummyHead<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    dummyHead<span class="token operator">-&gt;</span>next<span class="token operator">=</span>head<span class="token punctuation">;</span>

    <span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> cur<span class="token operator">=</span>dummyHead<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>next<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>val<span class="token operator">==</span>val<span class="token punctuation">)</span>
            cur<span class="token operator">-&gt;</span>next<span class="token operator">=</span>cur<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            cur<span class="token operator">=</span>cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> dummyHead<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>递归的话，反正我是理解的不太好（每次都得画好久递归图才能理解呜呜呜）</p> 
<pre><code class="prism language-c"><span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> <span class="token function">removeElements</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> head<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    head<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token function">removeElements</span><span class="token punctuation">(</span>head<span class="token operator">-&gt;</span>next<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> head<span class="token operator">-&gt;</span>val <span class="token operator">==</span> val <span class="token operator">?</span> head<span class="token operator">-&gt;</span>next <span class="token operator">:</span> head<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_112"></a>链表的中间节点</h2> 
<blockquote> 
 <p>给你单链表的头结点 head ，请你找出并返回链表的中间结点。</p> 
 <p>如果有两个中间结点，则返回第二个中间结点。</p> 
</blockquote> 
<blockquote> 
 <p>示例 1：<br> <img src="https://images2.imgbox.com/0e/d2/sAFOxzS1_o.png" alt="在这里插入图片描述"></p> 
 <p>输入：head = [1,2,3,4,5] 输出：[3,4,5] 解释：链表只有一个中间结点，值为 3 。</p> 
 <p>示例 2：<br> <img src="https://images2.imgbox.com/73/d8/24FM0q8B_o.png" alt="在这里插入图片描述"></p> 
 <p>输入：head = [1,2,3,4,5,6] 输出：[4,5,6] 解释：该链表有两个中间结点，值分别为 3 和 4 ，返回第二个结点。</p> 
</blockquote> 
<p><strong>题目链接</strong>：<a href="https://leetcode.cn/problems/middle-of-the-linked-list/" rel="nofollow">link</a><br> 这道题的思路是：设置两个指针，一个slow指针，一个fast指针，slow指针一次走一步，fast指针一次走两步，当fast<strong>或</strong>fast的next为空的时候，slow就是我们要找的中间节点。</p> 
<pre><code class="prism language-c"><span class="token comment">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">ListNode</span> LN<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> <span class="token function">middleNode</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    LN<span class="token operator">*</span> slow<span class="token operator">=</span>head<span class="token punctuation">;</span>
    LN<span class="token operator">*</span> fast<span class="token operator">=</span>head<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token operator">&amp;&amp;</span>fast<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        slow<span class="token operator">=</span>slow<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        fast<span class="token operator">=</span>fast<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> slow<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_152"></a>反转链表</h2> 
<blockquote> 
 <p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表</p> 
</blockquote> 
<blockquote> 
 <p>示例 1：<br> <img src="https://images2.imgbox.com/da/0a/hq9a2fSg_o.png" alt="在这里插入图片描述"></p> 
 <p>输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1]</p> 
 <p>示例 2：<br> <img src="https://images2.imgbox.com/1b/23/oLU38mWK_o.png" alt="在这里插入图片描述"></p> 
 <p>输入：head = [1,2] 输出：[2,1]</p> 
 <p>示例 3：</p> 
 <p>输入：head = [] 输出：[]</p> 
</blockquote> 
<p><strong>题目链接</strong>：<a href="https://leetcode.cn/problems/reverse-linked-list/solutions/551596/fan-zhuan-lian-biao-by-leetcode-solution-d1k2/" rel="nofollow">link</a></p> 
<p>这道题的思路非常精巧。<br> 设立三个指针，n1，n2和n3，分别指向NULL，头结点和头结点的next。<br> 当<strong>n2不为空的时候</strong>，将n2的next指向n1，然后将n3赋值给n2（这也是n3存在的意义，因为改变n2的next指针以后，n2就无法通过n2=n2-&gt;next语句访问到原链表的下一个指针了）n3=n3-&gt;next，n1=n2；</p> 
<pre><code class="prism language-c"><span class="token comment">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */</span>
 <span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">ListNode</span> LN<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> <span class="token function">reverseList</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">-&gt;</span>next<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> head<span class="token punctuation">;</span>
    LN<span class="token operator">*</span> n1<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
    LN<span class="token operator">*</span> n2<span class="token operator">=</span>head<span class="token punctuation">;</span>
    LN<span class="token operator">*</span> n3<span class="token operator">=</span>head<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>n2<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        n2<span class="token operator">-&gt;</span>next<span class="token operator">=</span>n1<span class="token punctuation">;</span>
        n1<span class="token operator">=</span>n2<span class="token punctuation">;</span>
        n2<span class="token operator">=</span>n3<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>n3<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
            n3<span class="token operator">=</span>n3<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> n1<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>当然n3也可以不用一开始就定义，也可以在循环中当做一个临时变量：</p> 
<pre><code class="prism language-c"><span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> <span class="token function">reverseList</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> prev <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> curr <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>curr<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> next <span class="token operator">=</span> curr<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span><span class="token comment">//在这里设置n3，就不用单独考虑head是否为空或者只有一个节点的情况了</span>
        curr<span class="token operator">-&gt;</span>next <span class="token operator">=</span> prev<span class="token punctuation">;</span>
        prev <span class="token operator">=</span> curr<span class="token punctuation">;</span>
        curr <span class="token operator">=</span> next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> prev<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_220"></a>合并两个有序链表</h2> 
<blockquote> 
 <p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p> 
 <p>示例 1：<br> <img src="https://images2.imgbox.com/da/8e/7WByAW0V_o.png" alt="在这里插入图片描述"><br> 输入：l1 = [1,2,4], l2 = [1,3,4] 输出：[1,1,2,3,4,4]</p> 
 <p>示例 2：</p> 
 <p>输入：l1 = [], l2 = [] 输出：[]</p> 
 <p>示例 3：</p> 
 <p>输入：l1 = [], l2 = [0] 输出：[0]</p> 
</blockquote> 
<p><strong>题目链接</strong>：<a href="https://leetcode.cn/problems/merge-two-sorted-lists/description/" rel="nofollow">link</a><br> 设置四个指针，l1遍历链表1，l2遍历链表2，newhead是新链表头结点（哨兵位），newtail是新链表尾指针，l1和l2比较，谁小谁尾插到newtail后，然后向后走一位，没有尾插的不动，直到l1或l2有一方为空，再把没有遍历完的那个链表的剩余部分直接尾插到newtail后面。</p> 
<pre><code class="prism language-c"><span class="token comment">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">ListNode</span> LN<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> list1<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> list2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    LN<span class="token operator">*</span> l1<span class="token operator">=</span>list1<span class="token punctuation">;</span>
    LN<span class="token operator">*</span> l2<span class="token operator">=</span>list2<span class="token punctuation">;</span>
    LN<span class="token operator">*</span> newhead<span class="token operator">=</span><span class="token punctuation">(</span>LN<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LN<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    LN<span class="token operator">*</span> tail<span class="token operator">=</span>newhead<span class="token punctuation">;</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span>l1<span class="token operator">==</span><span class="token constant">NULL</span><span class="token operator">&amp;&amp;</span>l2<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>l1<span class="token operator">&amp;&amp;</span>l2<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>l1<span class="token operator">-&gt;</span>val<span class="token operator">&lt;=</span>l2<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            tail<span class="token operator">-&gt;</span>next<span class="token operator">=</span>l1<span class="token punctuation">;</span>
            l1<span class="token operator">=</span>l1<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">{<!-- --></span>
            tail<span class="token operator">-&gt;</span>next<span class="token operator">=</span>l2<span class="token punctuation">;</span>
            l2<span class="token operator">=</span>l2<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        tail<span class="token operator">=</span>tail<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>l1<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        tail<span class="token operator">-&gt;</span>next<span class="token operator">=</span>l2<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{<!-- --></span>
        tail<span class="token operator">-&gt;</span>next<span class="token operator">=</span>l1<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> newhead<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_282"></a>分割链表</h2> 
<blockquote> 
 <p>给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。</p> 
 <p>你不需要 保留 每个分区中各节点的初始相对位置。</p> 
</blockquote> 
<blockquote> 
 <p>示例 1：<br> <img src="https://images2.imgbox.com/e0/9e/YZlgPxCa_o.png" alt="在这里插入图片描述"><br> 输入：head = [1,4,3,2,5,2], x = 3 输出：[1,2,2,4,3,5]</p> 
 <p>示例 2：</p> 
 <p>输入：head = [2,1], x = 2 输出：[1,2]</p> 
</blockquote> 
<p>题目链接：<a href="https://leetcode.cn/problems/partition-list-lcci/" rel="nofollow">link</a></p> 
<p>大小链表法，新设两个链表一个放小的，一个放大的，然后最后把他们拼起来。</p> 
<pre><code class="prism language-c"><span class="token comment">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">ListNode</span> LN<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    LN<span class="token operator">*</span> s<span class="token operator">=</span><span class="token punctuation">(</span>LN<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LN<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    LN<span class="token operator">*</span> b<span class="token operator">=</span><span class="token punctuation">(</span>LN<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LN<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    LN<span class="token operator">*</span> st<span class="token operator">=</span>s<span class="token punctuation">;</span>
    LN<span class="token operator">*</span> bt<span class="token operator">=</span>b<span class="token punctuation">;</span>
    LN<span class="token operator">*</span> cur<span class="token operator">=</span>head<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>val<span class="token operator">&lt;</span>x<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            st<span class="token operator">-&gt;</span>next<span class="token operator">=</span>cur<span class="token punctuation">;</span>
            st<span class="token operator">=</span>st<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">{<!-- --></span>
            bt<span class="token operator">-&gt;</span>next<span class="token operator">=</span>cur<span class="token punctuation">;</span>
            bt<span class="token operator">=</span>bt<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        cur<span class="token operator">=</span>cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    bt<span class="token operator">-&gt;</span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
    st<span class="token operator">-&gt;</span>next<span class="token operator">=</span>b<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>

</code></pre> 
<p>这个题要注意的是，最后在处理bt-&gt;next，也就是大链表的最后时一定要记得“<strong>封尾</strong>”，也就是要给他赋值为NULL，因为我们在把原链表中的节点挪到新的大小链表中的时候，连同他的next指针一起挪动了，那也就是说，如果不“封尾”，那么大链表的最后一个元素后还连着他在原链表中的后继元素。</p> 
<p>好了今天的分享就结束了，马上又要期末考试啦！期中数据结构得了满分，希望期末可以继续保持下去！！！下学期就是真正的软工人啦~</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4162b663559c494d1bc1636251779928/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">玄机科技闪耀中国国际动漫节，携手百度共绘 AI 国漫新篇章</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/96914f387014d2e4b114f8ceef629a8f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">map函数友好讲解（狠狠爱住）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>