<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android分区挂载原理介绍（下） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/83d8d06614954458ef660395424b2d9f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Android分区挂载原理介绍（下）">
  <meta property="og:description" content="上章内容请点击链接：Android分区挂载原理介绍（上）
三、分区挂载流程介绍 3.1 分区挂载顺序总览
挂载顺序
实际内容所在物理分区
挂载点名称
是否为logical分区
Avb校验
avb校验信息保存位置
挂载阶段
fstab生效位置
1
metadata
/metadata
否
否
N/A
init first stage
vendor_boot（ramdisk）
2
super
/system
是
是
vbmeta_system
init first stage
vendor_boot（ramdisk）
5
super
/system_ext
是
是
vbmeta_system
init first stage
vendor_boot（ramdisk）
6
super
/product
是
是
vbmeta_system
init first stage
vendor_boot（ramdisk）
7
super
/vendor
是
是
vbmeta_vendor
init first stage
vendor_boot（ramdisk）
8
super
/vendor_dlkm
是
是
vbmeta_vendor
init first stage">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-01-26T17:00:12+08:00">
    <meta property="article:modified_time" content="2024-01-26T17:00:12+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android分区挂载原理介绍（下）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p><a href="" rel="nofollow">上章内容请点击链接：Android分区挂载原理介绍（上）</a></p> 
 <p>三、分区挂载流程介绍    </p> 
 <p>3.1 分区挂载顺序总览</p> 
 <table width="578"><tbody><tr><td width="34" height="14"><p style="text-align:left;">挂载顺序</p></td><td width="111" height="14"><p style="text-align:left;">实际内容所在物理分区</p></td><td width="105" height="14"><p>挂载点名称</p></td><td width="79" height="14"><p>是否为logical分区</p></td><td width="38" height="14"><p>Avb校验</p></td><td width="79" height="14"><p>avb校验信息保存位置</p></td><td width="160" height="14"><p style="text-align:left;">挂载阶段</p></td><td width="128" height="14"><p style="text-align:left;">fstab生效位置</p></td></tr><tr><td width="34" height="14"><p style="text-align:left;">1</p></td><td width="111" height="14"><p style="text-align:left;">metadata</p></td><td width="105" height="14"><p>/metadata</p></td><td width="79" height="14"><p>否</p></td><td width="38" height="14"><p>否</p></td><td width="79" height="14"><p>N/A</p></td><td width="160" height="14"><p style="text-align:left;">init first stage</p></td><td width="128" height="14"><p style="text-align:left;">vendor_boot（ramdisk）</p></td></tr><tr><td width="34" height="14"><p style="text-align:left;">2</p></td><td width="111" height="14"><p style="text-align:left;">super</p></td><td width="105" height="14"><p>/system</p></td><td width="79" height="14"><p>是</p></td><td width="38" height="14"><p>是</p></td><td width="79" height="14"><p>vbmeta_system</p></td><td width="160" height="14"><p style="text-align:left;">init first stage</p></td><td width="128" height="14"><p style="text-align:left;">vendor_boot（ramdisk）</p></td></tr><tr><td width="34" height="14"><p style="text-align:left;">5</p></td><td width="111" height="14"><p style="text-align:left;">super</p></td><td width="105" height="14"><p>/system_ext</p></td><td width="79" height="14"><p>是</p></td><td width="38" height="14"><p>是</p></td><td width="79" height="14"><p>vbmeta_system</p></td><td width="160" height="14"><p style="text-align:left;">init first stage</p></td><td width="128" height="14"><p style="text-align:left;">vendor_boot（ramdisk）</p></td></tr><tr><td width="34" height="14"><p style="text-align:left;">6</p></td><td width="111" height="14"><p style="text-align:left;">super</p></td><td width="105" height="14"><p>/product</p></td><td width="79" height="14"><p>是</p></td><td width="38" height="14"><p>是</p></td><td width="79" height="14"><p>vbmeta_system</p></td><td width="160" height="14"><p style="text-align:left;">init first stage</p></td><td width="128" height="14"><p style="text-align:left;">vendor_boot（ramdisk）</p></td></tr><tr><td width="34" height="14"><p style="text-align:left;">7</p></td><td width="111" height="14"><p style="text-align:left;">super</p></td><td width="105" height="14"><p>/vendor</p></td><td width="79" height="14"><p>是</p></td><td width="38" height="14"><p>是</p></td><td width="79" height="14"><p>vbmeta_vendor</p></td><td width="160" height="14"><p style="text-align:left;">init first stage</p></td><td width="128" height="14"><p style="text-align:left;">vendor_boot（ramdisk）</p></td></tr><tr><td width="34" height="14"><p style="text-align:left;">8</p></td><td width="111" height="14"><p style="text-align:left;">super</p></td><td width="105" height="14"><p>/vendor_dlkm</p></td><td width="79" height="14"><p>是</p></td><td width="38" height="14"><p>是</p></td><td width="79" height="14"><p>vbmeta_vendor</p></td><td width="160" height="14"><p style="text-align:left;">init first stage</p></td><td width="128" height="14"><p style="text-align:left;">vendor_boot（ramdisk）</p></td></tr><tr><td width="34" height="14"><p style="text-align:left;">9</p></td><td width="111" height="14"><p style="text-align:left;">super</p></td><td width="105" height="14"><p>/odm</p></td><td width="79" height="14"><p>是</p></td><td width="38" height="14"><p>否</p></td><td width="79" height="14"><p>N/A</p></td><td width="160" height="14"><p style="text-align:left;">init first stage</p></td><td width="128" height="14"><p style="text-align:left;">vendor_boot（ramdisk）</p></td></tr><tr><td width="34" height="14"><p style="text-align:left;">10</p></td><td width="111" height="14"><p style="text-align:left;">super</p></td><td width="105" height="14"><p>/odm_dlkm</p></td><td width="79" height="14"><p>是</p></td><td width="38" height="14"><p>否</p></td><td width="79" height="14"><p>N/A</p></td><td width="160" height="14"><p style="text-align:left;">init first stage</p></td><td width="128" height="14"><p style="text-align:left;">vendor_boot（ramdisk）</p></td></tr><tr><td width="34" height="14"><p style="text-align:left;">32</p></td><td width="111" height="14"><p style="text-align:left;">persist </p></td><td width="105" height="14"><p style="text-align:left;">/mnt/vendor/persist</p></td><td width="79" height="14"><p style="text-align:left;">否</p></td><td width="38" height="14"><p>否</p></td><td width="79" height="14"><p>N/A</p></td><td width="160" height="14"><p style="text-align:left;">init second stage （mount_all --early）</p></td><td width="128" height="14"><p style="text-align:left;">/vendor/etc/fstab.qcom</p></td></tr><tr><td width="34" height="14"><p style="text-align:left;">33</p></td><td width="111" height="14"><p style="text-align:left;">modem</p></td><td width="105" height="14"><p style="text-align:left;">/vendor/firmware</p></td><td width="79" height="14"><p style="text-align:left;">否</p></td><td width="38" height="14"><p>否</p></td><td width="79" height="14"><p>N/A</p></td><td width="160" height="14"><p style="text-align:left;">init second stage （mount_all --early）</p></td><td width="128" height="14"><p style="text-align:left;">/vendor/etc/fstab.qcom</p></td></tr><tr><td width="34" height="14"><p style="text-align:left;">34</p></td><td width="111" height="14"><p style="text-align:left;">dsp</p></td><td width="105" height="14"><p style="text-align:left;">/vendor/dsp</p></td><td width="79" height="14"><p style="text-align:left;">否</p></td><td width="38" height="14"><p>否</p></td><td width="79" height="14"><p>N/A</p></td><td width="160" height="14"><p style="text-align:left;">init second stage （mount_all --early）</p></td><td width="128" height="14"><p style="text-align:left;">/vendor/etc/fstab.qcom</p></td></tr><tr><td width="34" height="14"><p style="text-align:left;">35</p></td><td width="111" height="14"><p style="text-align:left;">bluetooth</p></td><td width="105" height="14"><p style="text-align:left;">/vendor/bt_firmware</p></td><td width="79" height="14"><p style="text-align:left;">否</p></td><td width="38" height="14"><p>否</p></td><td width="79" height="14"><p>N/A</p></td><td width="160" height="14"><p style="text-align:left;">init second stage （mount_all --early）</p></td><td width="128" height="14"><p style="text-align:left;">/vendor/etc/fstab.qcom</p></td></tr><tr><td width="34" height="14"><p style="text-align:left;">36</p></td><td width="111" height="14"><p style="text-align:left;">qmcs</p></td><td width="105" height="14"><p style="text-align:left;">/mnt/vendor/qmcs</p></td><td width="79" height="14"><p style="text-align:left;">否</p></td><td width="38" height="14"><p>否</p></td><td width="79" height="14"><p>N/A</p></td><td width="160" height="14"><p style="text-align:left;">init second stage （mount_all --early）</p></td><td width="128" height="14"><p style="text-align:left;">/vendor/etc/fstab.qcom</p></td></tr><tr><td width="34" height="14"><p style="text-align:left;">37</p></td><td width="111" height="14"><p style="text-align:left;">userdata</p></td><td width="105" height="14"><p style="text-align:left;">/data</p></td><td width="79" height="14"><p style="text-align:left;">否</p></td><td width="38" height="14"><p>否</p></td><td width="79" height="14"><p>N/A</p></td><td width="160" height="14"><p style="text-align:left;">init second stage （mount_all --late）</p></td><td width="128" height="14"><p style="text-align:left;">/vendor/etc/fstab.qcom</p></td></tr></tbody></table> 
 <p><br> 3.2 metadata分区挂载流程  </p> 
 <p>metadata分区是开机后第一个挂载的分区，挂载流程也比较简单。本节内容就介绍一下metadata分区挂载流程，挂载位置在如下代码</p> 
 <p><img src="https://images2.imgbox.com/b7/ce/Z8t2tuNt_o.png" alt="545ac427c47ca13a38e6b185f36ddce4.png"></p> 
 <p>调用通用的MountPartition函数，进行挂载。这里就不再赘述，感兴趣的可以走读一下代码。</p> 
 <p><img src="https://images2.imgbox.com/73/f9/TcVj92VA_o.png" alt="7dc87f2574c2caa60200b2c353d0306e.png"></p> 
 <h3>3.3 system分区挂载流程</h3> 
 <h3>  </h3> 
 <p>System挂载代码如下    </p> 
 <p><img src="https://images2.imgbox.com/70/c8/qKTLxlWC_o.png" alt="07e127a274d3f72b1c3bac5dfd082e48.png"></p> 
 <p>System分区是一个逻辑分区，前面《dm实现动态卷(逻辑分区)功能介绍》一章中介绍过</p> 
 <p>System是一个逻辑分区，实际存在在super这个物理分区中。</p> 
 <p><strong>第一步：</strong></p> 
 <p>就是先创建一个dm-linear的dm设备，将super分区中对应的system image存放的物理地址映射成一个dm设备，相关代码如下。</p> 
 <p><img src="https://images2.imgbox.com/34/d6/GB6p25JY_o.png" alt="6c695ef3d914f4cd29606493886874c0.png"></p> 
 <p>通过fs_mgr_updata_logical_partition找到system分区对应的dm-xx编号</p> 
 <p>通过InitDmDevice等待/sys/block/dm-xx创建好</p> 
 <p><strong>第二步：</strong>判断是否需要开启dm校验</p> 
 <p><img src="https://images2.imgbox.com/f0/10/XNf3XvTW_o.png" alt="80fbe85e38535da4790ed9f54da2ac59.png"> </p> 
 <p><strong>第三步：</strong></p> 
 <p>之后就可以和挂载普通分区一样，挂载system分区    </p> 
 <p><img src="https://images2.imgbox.com/02/50/QX4hwz7U_o.png" alt="4fe043195c353e8ad9ca33840c12e960.png"></p> 
 <p><strong>3.4 userdata分区挂载流程</strong></p> 
 <p>元数据加密(default-key)一节中已经介绍了，userdata分区是依赖dm实现元数据加密的。</p> 
 <p>所以userdata挂载结构如下图    </p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/06/81/p59QPRCm_o.png" alt="f6f9c63c1840d48f1f10f1106afcd411.png"></p> 
 <p>下面就详细介绍一下userdata分区挂载流程</p> 
 <p>Userdata挂载阶段是在second stage （mount_all --late）阶段。对应rc文件如下。</p> 
 <p><img src="https://images2.imgbox.com/99/65/NfMj4bH7_o.png" alt="b5fa8e15a522e84c0ae9f05ce6284ac8.png"></p> 
 <p>进行一些fstab解析后，就调用到了fs_mgr_mount_all进行userdata挂载    </p> 
 <p><img src="https://images2.imgbox.com/06/82/8nbvk4IW_o.png" alt="3ae7ee16ba19c9f44820d5f61f71b9c1.png"></p> 
 <p>之前提到，Default-key加密只能在分区首次进行格式化时设置。所以userdata分区挂载就需要分两种情况。情况一：首次开机。情况二：已经完成元数据加密的后续开机。下面就分别介绍这两种情况的流程</p> 
 <p>情况一：首次开机关键流程如下    </p> 
 <p><img src="https://images2.imgbox.com/01/e3/NPCwzlOs_o.png" alt="49da49e265bd8487f08498c5ed68bf1c.png"></p> 
 <p>主要流程在encryptFstab中，可以查看前面章节的详细介绍。</p> 
 <p>功能就是创建用于元数据加密的key，将userdata分区映射为key-default的dm设备，并格式化成f2fs文件系统，挂载这个分区。</p> 
 <p>情况二：第二次开机关键流程</p> 
 <p><img src="https://images2.imgbox.com/7e/63/tPIKdDpu_o.png" alt="282729ab707db9847c05924d2fad0bd9.png">    </p> 
 <p><img src="https://images2.imgbox.com/96/54/oygumhpy_o.png" alt="7021993d16e919b91cb6e19afeb6b99d.png"></p> 
 <p>主要流程在mountFstab中，细节可以查看前面章节</p> 
 <p>所以第二次开机会先尝试挂载userdata分区，此时userdata分区已经被元数据加密了。无法挂载(读取不到superblock头)。就会经过判断，通过mountFstab挂载元数据加密的userdata分区。</p> 
 <p><strong>四、常见问题汇总</strong></p> 
 <p>4.1 set_policy_failed问题</p> 
 <p style="text-align:left;">故障现象：重启进recovery，进recovery原因为set_policy_failed</p> 
 <p style="text-align:left;">故障原理介绍：</p> 
 <p style="text-align:left;">在FBE加密一章节中我们介绍过，/data路径下部分文件夹需要进行FBE加密。</p> 
 <p style="text-align:left;">在启动时会准备 FBE Master key，设置和校验各加密存储位置的加密策略（Encryption Policy）。真正的解密发生在文件I/O时，会根据对应文件设置的加密策略（Encryption Policy），使用对应的解密算法及key，进行解密。而set_policy_failed的原因就是在针对某个文件夹设置加密策略时，出现了错误</p> 
 <p style="text-align:left;">rc文件在使用mkdir创建文件夹时，会检查创建文件夹的前缀是否为/data，之后会根据    一些默认的路径，觉得当前路径是否需要进行FBE加密，以及是使用哪种加密策略，一般开机会有两种参考的加密策略</p> 
 <p style="text-align:left;">A.ref，对应的是System DE Storage 的key和加密策略</p> 
 <p style="text-align:left;">B.per_boot_ref，对应的是每次开机生成的per_boot Storage 的key和加密策略</p> 
 <p style="text-align:left;">这两个加密策略分别存放在/data/unencrypted/ref和/data/unencrypted/per_boot_ref</p> 
 <p style="text-align:left;">当然我们也可以在rc文件中指定创建的文件夹的加密策略(添加encryption=&lt;加密</p> 
 <p style="text-align:left;">策略选项&gt;)，或指定FBE加密使用的Master key类型(添加key=&lt;ref/per_boot_ref&gt;)</p> 
 <pre class="has"><code class="language-go">加密策略由如下选项:</code></pre> 
 <table width="578"><tbody><tr><td width="138"><pre class="has"><code class="language-go">encryption参数</code></pre>     </td><td width="287"><pre class="has"><code class="language-go">参数作用</code></pre>     </td></tr><tr><td width="138"><pre class="has"><code class="language-go">Require</code></pre>     </td><td width="287"><pre class="has"><code class="language-go">指定加密策略，可选ref/per_boot_ref</code></pre>     </td></tr><tr><td width="138"><pre class="has"><code class="language-go">None</code></pre>     </td><td width="287"><pre class="has"><code class="language-go">不进行加密</code></pre>     </td></tr><tr><td width="138"><pre class="has"><code class="language-go">Attempt</code></pre>     </td><td width="287">     </td></tr><tr><td width="138"><pre class="has"><code class="language-go">DeleteIfNecessary</code></pre>     </td><td width="287"><pre class="has"><code class="language-go">如果解密失败/尝试删除文件后再加密</code></pre></td></tr></tbody></table> 
 <p style="text-align:left;">如果在指定文件夹的加密策略时出现了异常，就会导致set_policy_failed。之后就会</p> 
 <p style="text-align:left;">引导机器进recovery，相关代码在make_dir_with_options函数中</p> 
 <pre class="has"><code class="language-go">设置文件夹加密策略的处理函数如下</code></pre> 
 <pre class="has"><code class="language-go">那什么情况下会set_policy_failed呢？</code></pre> 
 <pre class="has"><code class="language-go">Set policy 流程简单总结如下</code></pre> 
 <p style="text-align:left;">根据FBE storage的加密策略，对应设置到文件夹的拓展属性中。Set_policy_failed</p> 
 <p style="text-align:left;">的原因就是黄色和绿色部分不匹配。可能的原因是</p> 
 <pre class="has"><code class="language-go">a.黄色部分更新，但绿色部分还是保留的老的加密策略(最常见)</code></pre> 
 <p style="text-align:left;">b.文件中的加密策略需要通过ioctl读取，如果没有权限打开对应文件夹的话，也会导</p> 
 <p style="text-align:left;">致失败</p> 
 <pre class="has"><code class="language-go">c.黄色/绿色部分出现损坏，导致两者不匹配</code></pre> 
 <pre class="has"><code class="language-go">d.keymaster相关错误导致两个不匹配</code></pre> 
 <pre class="has"><code class="language-go">问题分析思路：</code></pre> 
 <pre class="has"><code class="language-go">a.出问题的文件路径是什么？</code></pre> 
 <p style="text-align:left;">b.使用的哪个FBE storage的加密策略，这个FBE storage加密策略的更新时机是什</p> 
 <p style="text-align:left;">么？</p> 
 <pre class="has"><code class="language-go">c.这个路径删除的时机是什么？</code></pre> 
 <p style="text-align:left;">然后去分析加密策略的更新时机与路径的删除时机是否同步。是否存在加密策略更新，但路径未删除或删除失败的情况。</p> 
 <pre class="has"><code class="language-go">典型案例：</code></pre> 
 <pre class="has"><code class="language-go">案例一：旧文件未删除，与新生成的FBE storage加密策略不匹配</code></pre> 
 <p style="text-align:left;">之前介绍fbeEnable提到，每次开机会生成一个新的per_boot_ref。用于加密/data/per_boot路径。但是如果/data/per_boot路径未删除的话，就会导致/data/per_boot 文件夹拓展属性中的加密策略还是上一次开机的(绿色部分)，此时mkdir 指定key=per_boot_ref是本次开机新生成的(黄色部分)，</p> 
 <p style="text-align:left;">导致两者不匹配报set_policy_failed。</p> 
 <p style="text-align:left;">典型log</p> 
 <pre class="has"><code class="language-go">这个问题最后分析是某些修改导致概率性的rm -rf/data/per_boot导致的。这里就不展开了。</code></pre> 
 <pre class="has"><code class="language-go">案例二：权限不够，无法执行ioctl设置文件夹加密策略</code></pre> 
 <p style="text-align:left;">加密策略是通过ioctl设置到文件的拓展属性中的。所以设置时需要先打开文件夹，通过fd去设置加密策略。如果没有权限打开文件夹的话，就会导致set_policy_failed</p> 
 <pre class="has"><code class="language-go">相关代码在fscrypt.cpp</code></pre> 
 <pre class="has"><code class="language-go">主要log</code></pre> 
 <p>4.2 init_user0_failed问题</p> 
 <p>故障现象：重启进recovery，进recovery原因为init_user0_failed</p> 
 <p>故障原理介绍：</p> 
 <p>init_user0 的主要流程前面章节有详细介绍，摘取如下:</p> 
 <p>“如果是首次开机(根据user DE key存放路径判断)，</p> 
 <p>创建 User 0 DE Master Key 和生成 User 0 DE Encryption Policy；</p> 
 <p>创建 User 0 CE  Master Key 和生成 User 0 CE Encryption Policy；</p> 
 <p>创建 User 0 DE Storage，并为这些文件夹设置 User 0 DE Encryption Policy</p> 
 <p>后续开机</p> 
 <p>加载 User 0 DE Master Key”</p> 
 <p style="text-align:left;">根据原理，init_user0 failed的原因可以结合代码和前面章节中initUser0重要流程的介绍进行查看分析，看fscrypt_init_user0函数中return false的位置。</p> 
 <p>分析思路也主要是关注几个重点流程</p> 
 <p>a.保存master key的文件夹是否正常</p> 
 <p>b.创建Master Key和生成Encryption Policy是否正常</p> 
 <p>c.设置文件夹的Encryption Policy是否正常</p> 
 <p>常见的故障原因有</p> 
 <p>a.userdata分区未正常挂载，导致保存master key的文件夹无法正常正常。从而导致failed</p> 
 <p>b.Keymaster(安全相关)报错，导致创建Mater Key和生成Encryption policy异常    </p> 
 <p><strong>典型案例</strong>          <br>案例一：data分区未挂载，导致init user0创建保存key的文件夹失败(最常见)</p> 
 <p>典型log</p> 
 <p><img src="https://images2.imgbox.com/fa/70/6n0r6mC6_o.png" alt="70e52e28cfbd6ba30803a2c61670e5a8.png"></p> 
 <p>出错代码位置</p> 
 <p><img src="https://images2.imgbox.com/e1/f5/yOU3IOGd_o.png" alt="fbf0e76aaa4dc9609bdc0baf5e34ab78.png"></p> 
 <p>Fscrypt_init_user0的第一件时间就是创建/data/misc/vold/user_keys文件夹，用于存放生成的master key。所以mkdir失败时，一般都是其他原因导致userdata分区未正常挂载，进而导致init user0 failed。Userdata挂载失败的原因就不在本章节展开，在后面userdata挂载失败的案例分析中详细介绍</p> 
 <p>案例二：</p> 
 <p>典型log：这个问题从描述来看，应该是必现的，所以没有保存log。应该是root后查看/data/misc文件夹下内容是乱码    </p> 
 <p>这个问题原因应该是安全有相关修改，导致升级后/data/misc文件夹无法正常进行FBE解密，从而无法读取user DE key，从而导致init_user0 failed</p> 
 <p>案例三：de key丢失，或tee keymaster安全接口返回异常</p> 
 <p>这两种情况暂未搜索到对应BUGID，但是在工作中可能也会遇到。例如我们手动将/data/misc/vold/user_keys/de/0/encrypted_key删掉后，就会导致init_user0读取master_key时出现错误。从而导致init_user0 failed</p> 
 <p>或者在init_user0 出现了keymaster报错导致无法加载key</p> 
 <p>典型log如下</p> 
 <p><img src="https://images2.imgbox.com/29/c2/O7urkkrg_o.png" alt="76549dab3aaa99c205bd7e13440f25e1.png"></p> 
 <h3><strong>4.3 enablefilecrypto_failed问题</strong>  </h3> 
 <p>故障现象：进recovery，原因为enablefilecrypto failed</p> 
 <p>Enablefilecrypto，实际执行的是fbeEnable。</p> 
 <p><img src="https://images2.imgbox.com/3e/e3/ZOFxQAMW_o.png" alt="02359d905d68953d05fe454d935621c3.png">    </p> 
 <p>相关调用流程是在data分区挂载后，会调用installkey /data 执行fbeEnable</p> 
 <p><img src="https://images2.imgbox.com/bf/92/AHJwMX83_o.png" alt="37d34dbbe2f50a7225d85b1091868e95.png"></p> 
 <p><img src="https://images2.imgbox.com/c1/01/RxtVMaSz_o.png" alt="4404b3f031b8c4d4a9a3f4831f9de7f4.png"></p> 
 <p>Fbeenable的详细流程参考前面章节。抽象异常关键步骤如下</p> 
 <p><img src="https://images2.imgbox.com/10/a3/GS1u4M3c_o.png" alt="ee53cbd95ad6087d66b01242ce58399b.png"></p> 
 <p>同样关注fscrypt_initialize_systemwide_keys返回false的位置</p> 
 <p>故障点一：创建或读取key异常    </p> 
 <p><img src="https://images2.imgbox.com/03/fe/cJoYb98w_o.png" alt="e70d7e5da9814702eb7e028056fc309c.png"></p> 
 <p>典型log:</p> 
 <p>读取到/data/unencrypted/key后，keystore2(安全模块)报错，导致device_key无法正常初始化</p> 
 <p><img src="https://images2.imgbox.com/75/38/pcHUdhcy_o.png" alt="17f3dae6e7a142ac7711815ddef70872.png"></p> 
 <p>其他原因故障暂时没有遇到相关案例，不过遇到问题时，还是从上面的原理入手进行分析。这样才能以不变应万变。</p> 
 <h3>4.4 userdata挂载失败问题  </h3> 
 <p>故障现象：进recovery，原因为init_user0_failed</p> 
 <p>Userdata挂载失败不会直接导致机器重启，而是由于userdata无法挂载，后续的init user0执行失败，从而导致进recovery。先看一下userdata挂载的几个关键流程。任一流程出错都可能导致userdata分区挂载失败。    </p> 
 <p><img src="https://images2.imgbox.com/d4/44/XU8zysBQ_o.png" alt="2dab5a2206c958e73870bab2acd10ed3.png"></p> 
 <p>故障点一：</p> 
 <p>红色部分出现了问题。无法读取到key</p> 
 <p><img src="https://images2.imgbox.com/56/5a/3B3GxCpj_o.png" alt="2f11c1358450022f4c20521aa7254fde.png"></p> 
 <p>案例一：</p> 
 <p>因为某些原因，导致metadata分区中保存的key丢失。导致无法完成metadata解密。可以手动删掉/metadata/vold/metadata_encryption/key模拟这种场景</p> 
 <p>典型log:</p> 
 <p><img src="https://images2.imgbox.com/55/21/UC5CGC2Y_o.png" alt="89477c4eba0405560871ab9ce05f5691.png"></p> 
 <p>故障点二：</p> 
 <p>Key可以读取到，但是实际解密失败。    </p> 
 <p><img src="https://images2.imgbox.com/21/5f/RbkrRlAL_o.png" alt="f3ce3b1571d265dfb3fff2bc842a1f0f.png"></p> 
 <p>案例二：</p> 
 <p>安全模块异常，导致解密过程失败-&gt;无法完成元数据解密-&gt;无法生成解密后的dm设备-&gt;userdata无法挂载</p> 
 <p>典型log</p> 
 <p><img src="https://images2.imgbox.com/64/74/ZbVSi4pe_o.png" alt="2e0a8ed5b7f56696d028c2a5ad7a78f8.png"></p> 
 <p>案例三：</p> 
 <p>key存在，但是依旧无法进行元数据解密。</p> 
 <p>例如userdata已经完成元数据加密，此时强制userdata不进行元数据解密挂载(普通用户版本-&gt;保留用户数据刷到工厂版本)。就会出现这种问题。</p> 
 <p>对于userdata是否完成了元数据加密，有个小技巧可以通过回读userdata分区前4k内容查看。</p> 
 <p>如果没有进行元数据加密，那userdata分区的前4k就是superblock头。如果完成了元数据加密，userdata分区前4k就不是superblock头相关内容。</p> 
 <p>故障点三：</p> 
 <p>dm设备相关异常。Userdata解密依赖dm设备驱动，所以当dm设备驱动出现问题后，也会导致userdata无法完成解密</p> 
 <p><img src="https://images2.imgbox.com/1d/87/2TWfYDfY_o.png" alt="698fc554f722949c22a4a250e5c19d6b.png"></p> 
 <p>案例四：</p> 
 <p>之前遇到过dm设备失败的问题(DEV_BUS或创建超时)，导致userdata无法完成元数据解密。但是bugid暂时无法找到。这个案例不展开。分析问题的时候也需要注意是否是dm设备创建的问题。</p> 
 <h3><strong>4.5 关机时ServiceManager crash导致vold shutdown超时死机重启</strong>  </h3> 
 <pre class="has"><code class="language-go">典型log：</code></pre> 
 <pre class="has"><code class="language-go">结论：</code></pre> 
 <p style="text-align:left;">关机时ServiceManager crash了，导致binder通信节点为空，vdc没法通过binder</p> 
 <p style="text-align:left;"> abort_fuse，从而不能volume shutdown，shutdown超时导致死机重启        </p> 
 <p>往</p> 
 <p>期</p> 
 <p>推</p> 
 <p>荐</p> 
 <p><a href="" rel="nofollow">Linux内核并发与同步机制解读（arm64）上</a><br></p> 
 <p><a href="" rel="nofollow">Linux内核并发与同步机制解读（arm64）下</a><br></p> 
 <p><a href="" rel="nofollow">crash实战：手把手教你使用crash分析内核dump</a><br></p> 
 <p><img src="https://images2.imgbox.com/62/d7/JH7NfkJO_o.gif" alt="193d91e436e7c2a5bceaad76ba778ea3.gif"></p> 
 <p>长按关注内核工匠微信</p> 
 <p>Linux内核黑科技| 技术文章| 精选教程</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/92a6302b2daa71347cd86c1dddd238bc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue2中使用WebSDK_V3.3.0(231027)展示监控视频</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3017cefd40e70b55a9ad24ac00402539/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">人工智能的未来展望：自然语言处理（NLP）与计算机视觉（CV）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>