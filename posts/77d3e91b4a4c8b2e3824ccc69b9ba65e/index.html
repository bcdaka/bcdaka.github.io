<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【初阶数据结构】深入解析循环队列:探索底层逻辑 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/77d3e91b4a4c8b2e3824ccc69b9ba65e/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【初阶数据结构】深入解析循环队列:探索底层逻辑">
  <meta property="og:description" content="初阶数据结构相关知识点可以通过点击以下链接进行学习一起加油！时间与空间复杂度的深度剖析深入解析顺序表:探索底层逻辑深入解析单链表:探索底层逻辑深入解析带头双向循环链表:探索底层逻辑深入解析栈:探索底层逻辑深入解析队列:探索底层逻辑深入解析循环队列:探索底层逻辑 🔥引言
本篇将介绍如何实现循环队列并实现过程需要注意的事项，虽然篇幅较小，但是其中逻辑还是值得引人思考的，循环队列可以采用数组或链表实现，这篇将采用数组实现循环队列
🌈个人主页：是店小二呀
🌈C语言笔记专栏：C语言笔记
🌈C&#43;&#43;笔记专栏： C&#43;&#43;笔记
🌈初阶数据结构笔记专栏： 初阶数据结构笔记
🌈喜欢的诗句:无人扶我青云志 我自踏雪至山巅
文章目录 一、循环队列的概念二、实现循环队列的知识铺垫(核心实现逻辑)2.1 队列满足什么条件为空2.2 解决何时为空何时为满的方案2.3 小总结2.4 循环队列中如何保证闭环2.5 计算循环队列的数据个数 三、实现循环队列相关步骤3.1 循环队列的搭建3.2 构建器(设置队列长度为 k)3.3 判断循环队列是否为满和空的情况3.4 检查是否能插入数据和删除数据3.5 获得队首元素和队尾元素3.6 循环的销毁 一、循环队列的概念 循环队列是一种用数组实现的队列数据结构，与普通队列不同的是，循环队列允许队列的头尾相接，实现循环利用数组空间。它解决了普通队列在出队操作频繁时需要大量元素迁移的效率问题。循环队列通常通过两个指针来实现：一个指向队列的头部（front），一个指向队列的尾部（rear）。当队列满时，rear 指针可以绕回到数组的起始位置，实现循环存储；当队列为空时，front 和 rear 指针指向同一个位置。
二、实现循环队列的知识铺垫(核心实现逻辑) 2.1 队列满足什么条件为空 当front==back时不一定为空。这里是循环队列，如果出现front= =back时会出现下列两种情况
back通过循环与front相遇，此时front==back，则队列满了一开始back没有移动，back和front在同位置，此时front==back，则队列为空 对此我们无法通过front==back区分开空和满的情况，需要重新定义为空或满的标志
2.2 解决何时为空何时为满的方案 关于front和back初始位置，front指向对头，而由于back指向队尾会很难看，需要手动back置为-1，对此这里back指向队尾的下一个元素(跟栈中top定义问题是类似的)
判断满的两种方案:
增加一个size，当front== back并且size= =0就为空，size！=0就是为满多开一个空间，这样的好处就是back&#43;1==front为满（不要存储数据，这样又回到了不能判断空或满） 2.3 小总结 这里我们选择第二种方案进行实现，对此我们总结下，定义好的方式。
front == back就是为空back &#43; 1 == front就是为满 2.4 循环队列中如何保证闭环 如果遇到循环相关问题，可以考虑取模(解决问题上十分巧妙)。我们想要达到的目的是当back到达空位置时，就是相当于到了头位置。
同时取模中，如果左边小于右边，没有改变。如果左边大于左边，就会删除右边的倍数，直到左边小于右边(这里就是取模的逻辑，如果很难理解，可以通过图来理解下)
这里需要注意的是:这张图我们需要关注的地方back &#43; 1和 head的位置，k &#43;1是空位置，下标为4和0位置重叠处三处。这里size为有效元素个数，这里只多开一个空间并没有算上有效元素，然后k &#43; 1到达空位置，我们想要的结果是我们想要达到的目的是当back到达空位置时，就是相当于到了头位置，这里(obj-&gt;back&#43;1)%(obj-&gt;size&#43;1)==obj-&gt;head;就满足了这种情况，相同数据取模模为0，意味着下标为0
2.5 计算循环队列的数据个数 如果是计算队列的数据个数，通常就是back - front，但是这里是循环队列可能会出现back在front前面的特殊情况。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-08T09:45:04+08:00">
    <meta property="article:modified_time" content="2024-07-08T09:45:04+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【初阶数据结构】深入解析循环队列:探索底层逻辑</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/fd/0d/efRyKAL9_o.gif" alt="请添加图片描述"></p> 
<table><thead><tr><th align="center">初阶数据结构</th><th align="center">相关知识点</th><th align="center">可以通过点击</th><th align="center">以下链接进行学习</th><th align="center">一起加油！</th></tr></thead><tbody><tr><td align="center"><a href="https://editor.csdn.net/md?not_checkout=1&amp;spm=1001.2100.3001.4503&amp;articleId=140254426" rel="nofollow">时间与空间复杂度的深度剖析</a></td><td align="center"><a href="https://blog.csdn.net/2302_79177254/article/details/139603098?spm=1001.2014.3001.5502">深入解析顺序表:探索底层逻辑</a></td><td align="center"><a href="https://blog.csdn.net/2302_79177254/article/details/139676495?spm=1001.2014.3001.5502">深入解析单链表:探索底层逻辑</a></td><td align="center"><a href="https://blog.csdn.net/2302_79177254/article/details/139718355?spm=1001.2014.3001.5501">深入解析带头双向循环链表:探索底层逻辑</a></td><td align="center"><a href="https://blog.csdn.net/2302_79177254/article/details/139702199?spm=1001.2014.3001.5501">深入解析栈:探索底层逻辑</a></td></tr><tr><td align="center"><a href="https://blog.csdn.net/2302_79177254/article/details/139703543?spm=1001.2014.3001.5501">深入解析队列:探索底层逻辑</a></td><td align="center"><a href="https://blog.csdn.net/2302_79177254/article/details/139719110?spm=1001.2014.3001.5501">深入解析循环队列:探索底层逻辑</a></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table> 
<p>🔥引言</p> 
<blockquote> 
 <p>本篇将介绍如何实现循环队列并实现过程需要注意的事项，虽然篇幅较小，但是其中逻辑还是值得引人思考的，循环队列可以采用数组或链表实现，这篇将采用数组实现循环队列</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/c3/40/jtFWhcpc_o.gif" alt="请添加图片描述" width="600" height="60"><br> <img src="https://images2.imgbox.com/4a/56/PeHr42ww_o.png" alt="Alt" width="200" height="200"></p> 
<p>🌈个人主页：<a href="https://blog.csdn.net/2302_79177254?type=blog">是店小二呀</a><br> 🌈C语言笔记专栏：<a href="https://blog.csdn.net/2302_79177254/category_12498683.html?spm=1001.2014.3001.5482">C语言笔记</a><br> 🌈C++笔记专栏： <a href="https://blog.csdn.net/2302_79177254/category_12596619.html">C++笔记</a><br> 🌈初阶数据结构笔记专栏： <a href="https://blog.csdn.net/2302_79177254/category_12596619.html">初阶数据结构笔记</a></p> 
<p>🌈喜欢的诗句:无人扶我青云志 我自踏雪至山巅<br> <img src="https://images2.imgbox.com/b7/43/tnMS6BKz_o.gif" alt="请添加图片描述" width="600" height="60"></p> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#font_colorcornflowerbluefont_27" rel="nofollow"><font color="cornflowerblue">一、循环队列的概念</font></a></li><li><a href="#font_colorcornflowerbluefont_35" rel="nofollow"><font color="cornflowerblue">二、实现循环队列的知识铺垫(核心实现逻辑)</font></a></li><li><ul><li><a href="#font_colorcornflowerblue21_font_37" rel="nofollow"><font color="cornflowerblue">2.1 队列满足什么条件为空</font></a></li><li><a href="#font_colorcornflowerblue22_font_46" rel="nofollow"><font color="cornflowerblue">2.2 解决何时为空何时为满的方案</font></a></li><li><a href="#font_colorcornflowerblue23_font_55" rel="nofollow"><font color="cornflowerblue">2.3 小总结</font></a></li><li><a href="#font_colorcornflowerblue24_font_62" rel="nofollow"><font color="cornflowerblue">2.4 循环队列中如何保证闭环</font></a></li><li><a href="#font_colorcornflowerblue25_font_77" rel="nofollow"><font color="cornflowerblue">2.5 计算循环队列的数据个数</font></a></li></ul> 
  </li><li><a href="#font_colorcornflowerbluefont_89" rel="nofollow"><font color="cornflowerblue">三、实现循环队列相关步骤</font></a></li><li><ul><li><a href="#font_colorcornflowerblue31_font_91" rel="nofollow"><font color="cornflowerblue">3.1 循环队列的搭建</font></a></li><li><a href="#font_colorcornflowerblue32__kfont_106" rel="nofollow"><font color="cornflowerblue">3.2 构建器(设置队列长度为 k)</font></a></li><li><a href="#font_colorcornflowerblue33_font_127" rel="nofollow"><font color="cornflowerblue">3.3 判断循环队列是否为满和空的情况</font></a></li><li><a href="#font_colorcornflowerblue34_font_144" rel="nofollow"><font color="cornflowerblue">3.4 检查是否能插入数据和删除数据</font></a></li><li><a href="#font_colorcornflowerblue35_font_177" rel="nofollow"><font color="cornflowerblue">3.5 获得队首元素和队尾元素</font></a></li><li><a href="#font_colorcornflowerblue36_font_205" rel="nofollow"><font color="cornflowerblue">3.6 循环的销毁</font></a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="font_colorcornflowerbluefont_27"></a><font color="cornflowerblue">一、循环队列的概念</font></h2> 
<p>循环队列是一种用数组实现的队列数据结构，与普通队列不同的是，循环队列允许队列的头尾相接，实现循环利用数组空间。它解决了普通队列在出队操作频繁时需要大量元素迁移的效率问题。循环队列通常通过两个指针来实现：一个指向队列的头部（front），一个指向队列的尾部（rear）。当队列满时，rear 指针可以绕回到数组的起始位置，实现循环存储；当队列为空时，front 和 rear 指针指向同一个位置。</p> 
<p><img src="https://images2.imgbox.com/e3/4d/6E3H6atF_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/52/59/VaS3rKgH_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="font_colorcornflowerbluefont_35"></a><font color="cornflowerblue">二、实现循环队列的知识铺垫(核心实现逻辑)</font></h2> 
<h3><a id="font_colorcornflowerblue21_font_37"></a><font color="cornflowerblue">2.1 队列满足什么条件为空</font></h3> 
<p><strong>当front==back时不一定为空。这里是循环队列，如果出现front= =back时会出现下列两种情况</strong></p> 
<ul><li>back通过循环与front相遇，此时front==back，则队列满了</li><li>一开始back没有移动，back和front在同位置，此时front==back，则队列为空</li></ul> 
<p>对此我们无法通过front==back区分开空和满的情况，需要重新定义为空或满的标志</p> 
<h3><a id="font_colorcornflowerblue22_font_46"></a><font color="cornflowerblue">2.2 解决何时为空何时为满的方案</font></h3> 
<p>关于front和back初始位置，front指向对头，而由于back指向队尾会很难看，需要手动back置为-1，对此这里back指向队尾的下一个元素(跟栈中top定义问题是类似的)</p> 
<p><strong>判断满的两种方案</strong>:</p> 
<ul><li>增加一个size，当front== back并且size= =0就为空，size！=0就是为满</li><li>多开一个空间，这样的好处就是back+1==front为满（不要存储数据，这样又回到了不能判断空或满）</li></ul> 
<h3><a id="font_colorcornflowerblue23_font_55"></a><font color="cornflowerblue">2.3 小总结</font></h3> 
<p>这里我们选择第二种方案进行实现，对此我们总结下，定义好的方式。</p> 
<ol><li>front == back就是为空</li><li>back + 1 == front就是为满</li></ol> 
<h3><a id="font_colorcornflowerblue24_font_62"></a><font color="cornflowerblue">2.4 循环队列中如何保证闭环</font></h3> 
<p>如果遇到循环相关问题，可以考虑取模(解决问题上十分巧妙)。<strong>我们想要达到的目的是当back到达空位置时，就是相当于到了头位置。</strong></p> 
<p>同时取模中，如果左边小于右边，没有改变。如果左边大于左边，就会删除右边的倍数，直到左边小于右边(这里就是取模的逻辑，如果很难理解，可以通过图来理解下)</p> 
<p><img src="https://images2.imgbox.com/7c/c8/TdCAW8Ng_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/30/0f/XnUae9Y9_o.png" alt="在这里插入图片描述"></p> 
<p><strong>这里需要注意的是</strong>:这张图我们需要关注的地方<code>back + 1和 head的位置</code>，<code>k +1是空位置</code>，<code>下标为4和0位置重叠处</code>三处。这里size为有效元素个数，这里只多开一个空间并没有算上有效元素，然后k + 1到达空位置，我们想要的结果是我们想要达到的目的是当back到达空位置时，就是相当于到了头位置，这里<code>(obj-&gt;back+1)%(obj-&gt;size+1)==obj-&gt;head;</code>就满足了这种情况，相同数据取模模为<code>0</code>，意味着下标为<code>0</code></p> 
<h3><a id="font_colorcornflowerblue25_font_77"></a><font color="cornflowerblue">2.5 计算循环队列的数据个数</font></h3> 
<p>如果是计算队列的数据个数，通常就是back - front，但是这里是<strong>循环队列可能会出现back在front前面的特殊情况。</strong></p> 
<p><img src="https://images2.imgbox.com/d3/20/ww4icPhV_o.png" alt="在这里插入图片描述"></p> 
<p><strong>解决措施</strong>:(back+(k+1)-front)%k+1。这里担心back - front出现负数，个数不是存在负数这种情况的。那么可以将<code>back + (k + 1) - front % k + 1</code>这样保证了<code>back - front + (k + 1) % k + 1</code>当back - front出现负数，增加k + 1保证了正数再取模保证数据没有超过循环队列的长度，那么这样得到数据个数是否正确呢？通过画图在整个循环中的代表位置是相同的。</p> 
<p>只要理解上面相关知识，模拟实现循环队列也变得简单起来了，让我们模拟实现起来吧！</p> 
<h2><a id="font_colorcornflowerbluefont_89"></a><font color="cornflowerblue">三、实现循环队列相关步骤</font></h2> 
<h3><a id="font_colorcornflowerblue31_font_91"></a><font color="cornflowerblue">3.1 循环队列的搭建</font></h3> 
<pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">;</span>
    <span class="token keyword">int</span> size<span class="token punctuation">;</span>
    <span class="token keyword">int</span> head<span class="token punctuation">;</span>
    <span class="token keyword">int</span> back<span class="token punctuation">;</span><span class="token comment">//元素的下一个位置</span>
<span class="token punctuation">}</span> MyCircularQueue<span class="token punctuation">;</span>
<span class="token comment">//head 和 back都为下标</span>
</code></pre> 
<p><strong>这里需要注意的是</strong>:这里没有跟队列一样采用两个结构体设计，而是采用在结构体对象内开辟一块空间用于存储节点，再调用结构体成员进行头尾操作，达到循环队列的功能。</p> 
<h3><a id="font_colorcornflowerblue32__kfont_106"></a><font color="cornflowerblue">3.2 构建器(设置队列长度为 k)</font></h3> 
<pre><code class="prism language-c">MyCircularQueue<span class="token operator">*</span> <span class="token function">myCircularQueueCreate</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token comment">//为结构体开辟空间</span>
<span class="token punctuation">{<!-- --></span>   
    MyCircularQueue <span class="token operator">*</span>obj<span class="token operator">=</span><span class="token punctuation">(</span>MyCircularQueue <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>MyCircularQueue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>obj<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    obj<span class="token operator">-&gt;</span>a<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//多开一个空间</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>obj<span class="token operator">-&gt;</span>a<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

    obj<span class="token operator">-&gt;</span>size<span class="token operator">=</span>k<span class="token punctuation">;</span>
    obj<span class="token operator">-&gt;</span>back<span class="token operator">=</span>obj<span class="token operator">-&gt;</span>head<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>这里需要注意的是</strong>:关于两次调用<code>malloc</code>函数开辟空间，第一次<code>malloc</code>开辟空间，用于为该结构体对象开辟空间，第二次<code>malloc</code>开辟空间，是为了队列元素开辟空间(包含了不存放数据的空间)，这空间是关联在一起的，对此需要搞清楚需要开辟多大的空间和交给什么数据类型维护</p> 
<h3><a id="font_colorcornflowerblue33_font_127"></a><font color="cornflowerblue">3.3 判断循环队列是否为满和空的情况</font></h3> 
<pre><code class="prism language-c">bool <span class="token function">myCircularQueueIsFull</span><span class="token punctuation">(</span>MyCircularQueue<span class="token operator">*</span> obj<span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>obj<span class="token operator">-&gt;</span>back<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token punctuation">(</span>obj<span class="token operator">-&gt;</span>size<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">==</span>obj<span class="token operator">-&gt;</span>head<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

bool <span class="token function">myCircularQueueIsEmpty</span><span class="token punctuation">(</span>MyCircularQueue<span class="token operator">*</span> obj<span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span>
    <span class="token function">assert</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> obj<span class="token operator">-&gt;</span>head<span class="token operator">==</span>obj<span class="token operator">-&gt;</span>back<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>这里需要注意的是</strong>:对于判断是否为空，不是重点，对于判断是否为满，根据取模的特点进行处理，对于数据结构处理建议画图分析</p> 
<h3><a id="font_colorcornflowerblue34_font_144"></a><font color="cornflowerblue">3.4 检查是否能插入数据和删除数据</font></h3> 
<pre><code class="prism language-c">bool <span class="token function">myCircularQueueEnQueue</span><span class="token punctuation">(</span>MyCircularQueue<span class="token operator">*</span> obj<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span>
 <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">myCircularQueueIsFull</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> false<span class="token punctuation">;</span>

    obj<span class="token operator">-&gt;</span>a<span class="token punctuation">[</span>obj<span class="token operator">-&gt;</span>back<span class="token punctuation">]</span><span class="token operator">=</span>value<span class="token punctuation">;</span>
    obj<span class="token operator">-&gt;</span>back<span class="token operator">++</span><span class="token punctuation">;</span>

    <span class="token comment">//防止越界</span>
    obj<span class="token operator">-&gt;</span>back<span class="token operator">%=</span><span class="token punctuation">(</span>obj<span class="token operator">-&gt;</span>size<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

bool <span class="token function">myCircularQueueDeQueue</span><span class="token punctuation">(</span>MyCircularQueue<span class="token operator">*</span> obj<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">myCircularQueueIsEmpty</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> false<span class="token punctuation">;</span>

    obj<span class="token operator">-&gt;</span>head<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token comment">//防止越界</span>
    obj<span class="token operator">-&gt;</span>head<span class="token operator">%=</span><span class="token punctuation">(</span>obj<span class="token operator">-&gt;</span>size<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>这里需要注意的是</strong>:这里无论是插入还是删除数据，需要对<code>x %= (obj-&gt;size+1);</code><strong>防止超过队列长度，而且这里需要注意顺序问题</strong></p> 
<p><img src="https://images2.imgbox.com/00/fa/3XhBe7sD_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<h3><a id="font_colorcornflowerblue35_font_177"></a><font color="cornflowerblue">3.5 获得队首元素和队尾元素</font></h3> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">myCircularQueueFront</span><span class="token punctuation">(</span>MyCircularQueue<span class="token operator">*</span> obj<span class="token punctuation">)</span>
 <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">myCircularQueueIsEmpty</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> obj<span class="token operator">-&gt;</span>a<span class="token punctuation">[</span>obj<span class="token operator">-&gt;</span>head<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">myCircularQueueRear</span><span class="token punctuation">(</span>MyCircularQueue<span class="token operator">*</span> obj<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">myCircularQueueIsEmpty</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>obj<span class="token operator">-&gt;</span>back<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//插入的时候</span>
    <span class="token keyword">return</span> obj<span class="token operator">-&gt;</span>a<span class="token punctuation">[</span>obj<span class="token operator">-&gt;</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//表示尾的情况</span>
    <span class="token keyword">else</span>
    <span class="token keyword">return</span> obj<span class="token operator">-&gt;</span>a<span class="token punctuation">[</span>obj<span class="token operator">-&gt;</span>back<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">//return obj-&gt;a[(obj-&gt;back-1+obj-&gt;size+1)%(obj-&gt;size+1)];</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/cb/70/a6PbGsxp_o.png" alt=""></p> 
<p><strong>这里需要注意的是</strong>:<strong>这里获得队首元素和队尾元素，都需要先判断循环队列是否为空</strong>。在获得队尾元素中，一般情况下 <code>obj-&gt;a[obj-&gt;back-1]</code>是没有问题的，但是如果在插入一个数据，back回到首元素位置上，<code>back-1</code>就会出现问题，会导致越界访问，对此<code>obj-&gt;a[(obj-&gt;back-1+obj-&gt;size+1)%(obj-&gt;size+1)]; </code>可以将这个循环队列展开一段，加<code>obj-&gt;size+1</code>再取<code>obj-&gt;size+1</code>模，这里同计算循环队列有效数据长度的方式是一样的。</p> 
<h3><a id="font_colorcornflowerblue36_font_205"></a><font color="cornflowerblue">3.6 循环的销毁</font></h3> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">myCircularQueueFree</span><span class="token punctuation">(</span>MyCircularQueue<span class="token operator">*</span> obj<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">free</span><span class="token punctuation">(</span>obj<span class="token operator">-&gt;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<p><img src="https://images2.imgbox.com/5a/c6/n2hgr5w3_o.gif" alt="请添加图片描述"></p> 
<p><strong><font color="cornflowerblue">以上就是本篇文章的所有内容，在此感谢大家的观看！这里是店小二初阶数据结构笔记，希望对你在学习初阶数据结构中有所帮助！</font></strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/32f89ff661e65f1968b27126925320ed/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">『C&#43;&#43;成长记』string模拟实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6b34663013242739e0bcb203d53a434e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">XML标记语言简介</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>