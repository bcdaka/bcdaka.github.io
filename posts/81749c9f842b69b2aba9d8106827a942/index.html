<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>暴力数据结构之二叉树（堆的相关知识） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/81749c9f842b69b2aba9d8106827a942/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="暴力数据结构之二叉树（堆的相关知识）">
  <meta property="og:description" content="1. 堆的基本了解 堆（heap）是计算机科学中一种特殊的数据结构，通常被视为一个完全二叉树，并且可以用数组来存储。堆的主要应用是在一组变化频繁（增删查改的频率较高）的数据集中查找最值。堆分为大根堆和小根堆，大根堆中任意节点的值都大于其子树中节点的值，而小根堆则相反。堆的存储方式遵循层序遍历的规则，这样可以高效地利用存储空间。在数组中，根节点的下标为0，节点的左右孩子的下标可以通过特定的公式计算得出。堆的实现通常利用动态数组，这样可以快速扩展容量而不造成空间浪费。
堆的一些性质：1.堆中某个结点的值总是不大于或不小于其父结点的值；
2.堆总是一棵完全二叉树。
2. 堆的实现 我们知道堆的逻辑结构是一个完全二叉树，但是其物理结构仍然是一个数组，所以实现堆创建一个数组即可。
typedef int HPDateType; typedef struct Heap { HPDateType* a; int size; int capacity; }HP; void HPInit(HP* php) { assert(php); php-&gt;a = NULL; php-&gt;capacity = php-&gt;size = 0; } void HPDesTroy(HP* php) { assert(php); free(php-&gt;a); php-&gt;a = NULL; php-&gt;capacity = php-&gt;size = 0; } void Swap(HPDateType* p1, HPDateType* p2) { HPDateType tmp = *p1; *p1 = *p2; *p2 = tmp; } void AdjustUp(HPDateType* a, int child) { int parent = (child - 1) / 2; while (child &gt; 0) { if (a[child] &lt; a[parent]) { Swap(&amp;a[child], &amp;a[child]); child = parent; parent = (child - 1) / 2; } else { break; } } } void HPPush(HP* php, HPDateType x) { if (php-&gt;capacity == php-&gt;size) { int newcapacity = php-&gt;capacity == 0 ?">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-15T22:16:04+08:00">
    <meta property="article:modified_time" content="2024-05-15T22:16:04+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">暴力数据结构之二叉树（堆的相关知识）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <h4>1. 堆的基本了解</h4> 
</blockquote> 
<p><strong>        堆（heap）是计算机科学中一种特殊的数据结构，通常被视为一个完全二叉树，并且可以用数组来存储。堆的主要应用是在一组变化频繁（增删查改的频率较高）的数据集中查找最值。堆分为大根堆和小根堆，大根堆中任意节点的值都大于其子树中节点的值，而小根堆则相反。堆的存储方式遵循层序遍历的规则，这样可以高效地利用存储空间。在数组中，根节点的下标为0，节点的左右孩子的下标可以通过特定的公式计算得出。堆的实现通常利用动态数组，这样可以快速扩展容量而不造成空间浪费。</strong></p> 
<p><strong>堆的一些性质：1.</strong><strong>堆中某个结点的值总是不大于或不小于其父结点的值；</strong></p> 
<p><strong>                         2.堆总是一棵完全二叉树。</strong></p> 
<p style="background-color:transparent;"><img alt="" height="421" src="https://images2.imgbox.com/be/08/PqZp4D2Q_o.png" width="1102"></p> 
<blockquote> 
 <h4 style="background-color:transparent;">2. 堆的实现</h4> 
</blockquote> 
<p><strong> 我们知道堆的逻辑结构是一个完全二叉树，但是其物理结构仍然是一个数组，所以实现堆创建一个数组即可。</strong></p> 
<pre><code class="language-cs">typedef int HPDateType;

typedef struct Heap
{
	HPDateType* a;
	int size;
	int capacity;
}HP;

void HPInit(HP* php)
{
	assert(php);
	php-&gt;a = NULL;
	php-&gt;capacity = php-&gt;size = 0;
}
void HPDesTroy(HP* php)
{
	assert(php);
	free(php-&gt;a);
	php-&gt;a = NULL;
	php-&gt;capacity = php-&gt;size = 0;
}

void Swap(HPDateType* p1, HPDateType* p2)
{
	HPDateType tmp = *p1;
	*p1 = *p2;
	*p2 = tmp;
}

void AdjustUp(HPDateType* a, int child)
{
	int parent = (child - 1) / 2;
	while (child &gt; 0)
	{
		if (a[child] &lt; a[parent])
		{
			Swap(&amp;a[child], &amp;a[child]);
			child = parent;
			parent = (child - 1) / 2;
		}
		else
		{
			break;
		}
	}
}

void HPPush(HP* php, HPDateType x)
{
	if (php-&gt;capacity == php-&gt;size)
	{
		int newcapacity = php-&gt;capacity == 0 ? 4 : php-&gt;capacity * 2;
		HPDateType* tmp = (HPDateType*)realloc(php-&gt;a, sizeof(HPDateType) * newcapacity);
		if (tmp = NULL)
		{
			perror("realloc");
			return;
		}
		php-&gt;a = tmp;
		php-&gt;capacity = newcapacity;
	}

	php-&gt;a[php-&gt;size] = x;
	php-&gt;size++;

	AdjustUp(php-&gt;a, php-&gt;size - 1);
}
void AdjustDown(HPDateType* a, int n, int parent)
{
	int child = parent * 2 + 1;
	while (child &lt; n)
	{
		if (child + 1 &lt; n &amp;&amp; a[child] &gt; a[child + 1])
		{
			child++;
		}
		if (a[child] &lt; a[parent])
		{
			Swap(&amp;a[child], &amp;a[parent]);
			parent = child;
			child = parent * 2 + 1;
		}
		else
		{
			break;
		}
	}
}
void HPPop(HP* php)
{
	assert(php);
	assert(php-&gt;size &gt; 0);
	Swap(&amp;php-&gt;a[0], &amp;php-&gt;a[php-&gt;size - 1]);
	php-&gt;size--;

	AdjustDown(php-&gt;a, php-&gt;size, 0);
}

HPDateType HPTop(HP* php)
{
	assert(php);
	assert(php-&gt;size &gt; 0);

	return php-&gt;a[0];
}
bool HPEmpty(HP* php)
{
	assert(php);
	return php-&gt;size == 0;
}</code></pre> 
<h5><strong>2.1 堆的插入</strong></h5> 
<p><strong>大堆的父节点均大于子节点，小堆恰好相反，自然实现逻辑各不相同，这里主要有两个主要的思想就是"父子值交换"，"父子址交换"。解释就是（以小堆为例）：</strong></p> 
<p><strong>如果对一个已有的小堆插入新的数据（叶子），如果这个叶子与他的父节点相比更小，就与父节点交换，再与交换后节点所属的父节点对比，如果还是小于就继续交换。</strong></p> 
<p><img alt="" height="466" src="https://images2.imgbox.com/73/60/E3HVqtSt_o.png" width="1200"></p> 
<p><strong> 代码解释如下：</strong> </p> 
<p><strong>当要插入数据时先将其放在叶子节点（数组尾部），通过AdjustUp函数可以实现向上比较的动作，当然插入前判断空间是否充足，适当扩容即可。</strong></p> 
<pre><code class="language-cs">void AdjustUp(HPDateType* a, int child)
{
	int parent = (child - 1) / 2;
	while (child &gt; 0)
	{
		if (a[child] &lt; a[parent])
		{
			Swap(&amp;a[child], &amp;a[child]);
			child = parent;
			parent = (child - 1) / 2;
		}
		else
		{
			break;
		}
	}
}

void HPPush(HP* php, HPDateType x)
{
	if (php-&gt;capacity == php-&gt;size)
	{
		int newcapacity = php-&gt;capacity == 0 ? 4 : php-&gt;capacity * 2;
		HPDateType* tmp = (HPDateType*)realloc(php-&gt;a, sizeof(HPDateType) * newcapacity);
		if (tmp = NULL)
		{
			perror("realloc");
			return;
		}
		php-&gt;a = tmp;
		php-&gt;capacity = newcapacity;
	}

	php-&gt;a[php-&gt;size] = x;
	php-&gt;size++;

	AdjustUp(php-&gt;a, php-&gt;size - 1);
}</code></pre> 
<h5><strong>2.2 堆的删除</strong></h5> 
<p><strong>堆的删除就是将根节点与叶子节点交换后直接删除交换后的叶子节点（即最初的跟节点数据），然后将交换后的根节点逐渐向下交换，如图所示：</strong></p> 
<p><img alt="" height="435" src="https://images2.imgbox.com/b8/1c/gVqV8Ln2_o.png" width="1142"></p> 
<p><img alt="" height="436" src="https://images2.imgbox.com/ed/90/UncGB5FJ_o.png" width="1200"> <strong>通过代码展示就是，先交换根节点与叶子结点（即数组头尾交换）然后直接删除交换后的叶子结点。创建一个AdjustDown函数，逐层下沉交换后的跟节点，保持仍然是一个堆。</strong></p> 
<pre><code class="language-cs">void AdjustDown(HPDateType* a, int n, int parent)
{
	int child = parent * 2 + 1;
	while (child &lt; n)
	{
		if (child + 1 &lt; n &amp;&amp; a[child] &gt; a[child + 1])
		{
			child++;
		}
		if (a[child] &lt; a[parent])
		{
			Swap(&amp;a[child], &amp;a[parent]);
			parent = child;
			child = parent * 2 + 1;
		}
		else
		{
			break;
		}
	}
}
void HPPop(HP* php)
{
	assert(php);
	assert(php-&gt;size &gt; 0);
	Swap(&amp;php-&gt;a[0], &amp;php-&gt;a[php-&gt;size - 1]);
	php-&gt;size--;

	AdjustDown(php-&gt;a, php-&gt;size, 0);
}
</code></pre> 
<blockquote> 
 <h4>3.堆排序</h4> 
</blockquote> 
<p><span style="color:#0d0016;"><strong>主要思路：</strong></span><span style="color:#fe2c24;"><strong>升序建大堆，降序建小堆</strong></span></p> 
<p><strong>解释：以升序为例，创建一个大堆，即根节点为最大的数据，此时要排序，就直接将根节点与叶子结点交换（数组首尾交换），然后数组末尾的下标向前移动（此时数组末尾的数据不会参与后续运算），然后将交换后的跟节点使用AdjustDown函数下沉，以此类推，最后原数组就是一个升序排列。同理小堆也是如此。</strong></p> 
<p><strong>为什么升序不用小堆呢，因为小堆每一次运算都要再次创建一个数组，浪费更多的内存，可以使用但是不推荐。同理这也是为什么降序使用小堆。</strong></p> 
<p><strong>具体代码如下</strong></p> 
<pre><code class="language-cs">void HeapSort(int* a, int n)
{
	// 降序，建小堆
	// 升序，建大堆
	for (int i = 1; i &lt; n; i++)
	{
		AdjustUp(a, i);
	}

	

	int end = n - 1;
	while (end &gt; 0)
	{
		Swap(&amp;a[0], &amp;a[end]);
		AdjustDown(a, end, 0);
		--end;
	}
}
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/af72345a0a004e1d0bbd06d17f78132a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据结构（C）：树的概念和二叉树初见</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/08e0c13840592f6a1fa12f50ea1ab1d6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Flutter 中的 Icon 小部件：全面指南</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>