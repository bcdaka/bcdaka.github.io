<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】栈的概念、结构和实现详解 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/99b9981ee555870f6d263dea5c6fc4a0/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】栈的概念、结构和实现详解">
  <meta property="og:description" content="本文来介绍一下数据结构中的栈，以及如何用C语言去实现。
1. 栈的概念及结构 栈：一种特殊的线性表，它只允许在固定的一端进行插入和删除元素的操作。
进行数据插入和删除操作的一端称为栈顶，另一端称为栈底。
栈中元素遵循后进先出LIFO（Last In First Out）的原则
压栈：栈的插入操作叫做进栈/入栈/压栈，入数据在栈顶。
出栈：栈的删除操作叫做出栈，出数据也在栈顶。
2. 实现栈的底层方法选择 没有规定栈的哪端是栈顶，只说了数据插入和删除的一端是栈顶，所以我们栈的底层实现可以用链表或者数组 。
虽然数组和单链表都可以实现栈，但是单链表能很好入数据不好删除数据，这里单链表要删除数据就是尾删，尾删需要找到前一个结点，不是很方便。
非要用链表的话有两个解决方法，1.可以用双向链表 2.我们把单链表的头节点当作栈顶，也就是把左边当栈顶，右边当栈底，对单链表进行头插和头删的操作。
现在有3种方法实现栈，数组，单链表，双链表，我们应该如何选？
首先排除双链表，用双链表不如用单链表，双链表因为一个节点存两个指针，比单链表的一个节点多了4个字节或者8个字节。数组实现栈和单链表实现栈有什么区别?基本没区别，都可以，非要说选一个，我们还是更倾向于数组，因为数组的唯一缺点就是内存不足时需要扩容，扩容的影响也不是特别大，最重要的是数组的缓存效率更高。所以我们就用数组实现栈。
3. 栈的实现 提前说明，如果本篇看不太懂可以先看看【数据结构】顺序表-CSDN博客，我们栈的实现和顺序表的实现差不多。
还是一样，新建一个头文件和两个源文件
点开Stack.h文件，在这个文件里面我们要定义栈的结构，以及给类型和栈的结构取别名。
typedef int STDateType; typedef struct Stack { STDateType* a;//动态申请空间 调大小 int top; //用栈顶记录元素个数 int capacity; //数组实现要扩容，记录空间大小 }ST; 栈一共要实现下面这7个接口，我们将一个一个来看.
void STInit(ST* pst);//栈初始化 void STDistroy(ST* pst);//栈的销毁 void STPush(ST* pst, STDateType x);//压栈 void STPop(ST* pst);//出栈 STDateType STTopDate(ST* pst);//获取栈顶元素 bool STEmpty(ST* pst);//判断栈是否为空 int STSize(ST* pst);//获取栈元素个数 这里是会用到的头文件，且标注了是什么会用到，被包含的头文件全放在Stack.h中
#include &lt;stdio.h&gt; #include &lt;stdlib.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-05T21:01:21+08:00">
    <meta property="article:modified_time" content="2024-08-05T21:01:21+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】栈的概念、结构和实现详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"><img alt="" height="152" src="https://images2.imgbox.com/13/f1/BLHRKoVf_o.gif" width="152"></p> 
<p>本文来介绍一下数据结构中的栈，以及如何用C语言去实现。</p> 
<h2> 1. 栈的概念及结构</h2> 
<blockquote> 
 <p>栈：一种特殊的<span style="color:#ff9900;">线性表</span>，它只允许在<span style="color:#ff9900;">固定的一端</span>进行插入和删除元素的操作。</p> 
 <p>       进行数据插入和删除操作的一端称为<span style="color:#ff9900;">栈顶</span>，另一端称为<span style="color:#ff9900;">栈底</span>。</p> 
 <p>       栈中元素遵循<span style="color:#ff9900;">后进先出</span>LIFO（Last In First Out）的原则</p> 
 <p>压栈：栈的插入操作叫做进栈/入栈/压栈，<span style="color:#ff9900;">入数据在栈顶</span>。</p> 
 <p>出栈：栈的删除操作叫做出栈，<span style="color:#ff9900;">出数据也在栈顶</span>。</p> 
</blockquote> 
<p><img alt="" height="500" src="https://images2.imgbox.com/9a/be/YXoWHoM0_o.png" width="1011"></p> 
<p><img alt="" height="513" src="https://images2.imgbox.com/8a/e7/UBtA6OEA_o.png" width="1005"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/4f/02/zgAoFP4D_o.gif"></p> 
<h2>2. 实现栈的底层方法选择</h2> 
<p><span style="color:#ff9900;">没有规定栈的哪端是栈顶，只说了数据插入和删除的一端是栈顶</span>，所以我们栈的底层实现可以用链表或者数组 。</p> 
<p><img alt="" height="295" src="https://images2.imgbox.com/78/48/sfE4JS3r_o.png" width="916"></p> 
<p> 虽然数组和单链表都可以实现栈，但是单链表能很好入数据不好删除数据，这里单链表要删除数据就是尾删，尾删需要找到前一个结点，不是很方便。</p> 
<p>非要用链表的话有两个解决方法，1.可以用双向链表 2.我们把单链表的头节点当作栈顶，也就是把左边当栈顶，右边当栈底，对单链表进行头插和头删的操作。<img alt="" height="314" src="https://images2.imgbox.com/3b/f1/fjko56ny_o.png" width="962"></p> 
<p> 现在有3种方法实现栈，数组，单链表，双链表，我们应该如何选？</p> 
<p>首先排除双链表，用双链表不如用单链表，双链表因为一个节点存两个指针，比单链表的一个节点多了4个字节或者8个字节。<span style="color:#ff9900;">数组实现栈和单链表实现栈</span>有什么区别?<span style="color:#ff9900;">基本没区别</span>，都可以，非要说选一个，我们还是更倾向于数组，因为数组的唯一缺点就是内存不足时需要扩容，扩容的影响也不是特别大，最重要的是数组的缓存效率更高。所以我们就用<span style="color:#ff9900;">数组</span>实现栈。</p> 
<p style="text-align:center;"><img alt="" height="143" src="https://images2.imgbox.com/be/ba/AyCGmcPq_o.gif" width="241"></p> 
<h2>3. 栈的实现</h2> 
<p><strong>提前说明</strong>，如果本篇看不太懂可以先看看<a href="https://blog.csdn.net/2402_82757055/article/details/137359014?spm=1001.2014.3001.5501" title="【数据结构】顺序表-CSDN博客">【数据结构】顺序表-CSDN博客</a>，我们栈的实现和顺序表的实现差不多。</p> 
<p>还是一样，新建一个头文件和两个源文件</p> 
<p><img alt="" height="160" src="https://images2.imgbox.com/61/73/QLju5GKz_o.png" width="353"></p> 
<p><img alt="" height="283" src="https://images2.imgbox.com/b7/09/MvTfkB0z_o.png" width="751"></p> 
<p> 点开<span style="color:#ed7976;">Stack.h</span>文件，在这个文件里面我们要<strong>定义栈的结构，</strong>以及给类型和栈的结构取别名。</p> 
<pre><code>typedef int STDateType;
typedef struct Stack
{
	STDateType* a;//动态申请空间 调大小
	int top;      //用栈顶记录元素个数
	int capacity; //数组实现要扩容，记录空间大小
}ST;</code></pre> 
<p></p> 
<p>栈一共要实现下面这7个接口，我们将一个一个来看.</p> 
<pre><code>void STInit(ST* pst);//栈初始化
void STDistroy(ST* pst);//栈的销毁
void STPush(ST* pst, STDateType x);//压栈
void STPop(ST* pst);//出栈
STDateType STTopDate(ST* pst);//获取栈顶元素
bool STEmpty(ST* pst);//判断栈是否为空
int STSize(ST* pst);//获取栈元素个数</code></pre> 
<p></p> 
<p>这里是会用到的头文件，且标注了是什么会用到，被包含的头文件全放在<span style="color:#ed7976;">Stack.h</span>中</p> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;   //空间申请
#include &lt;stdbool.h&gt;  //布尔类型
#include &lt;assert.h&gt;   //断言</code></pre> 
<p>在<span style="color:#ed7976;">Stack.c</span>中只需要包含Stack.h</p> 
<pre><code>#include "Stack.h"
</code></pre> 
<p> 准别工作做好后我们开始实现栈。</p> 
<p></p> 
<h3>3.1 栈的初始化和销毁</h3> 
<p>在<strong><span style="color:#ed7976;">Stack.h</span></strong>中进行函数的声明。这里的参数需要传指针。</p> 
<pre><code>void STInit(ST* pst);//栈初始化
void STDistroy(ST* pst);//栈的销毁</code></pre> 
<p>在<span style="color:#ed7976;"><strong>SeqList.c</strong></span>中进行函数的实现</p> 
<pre><code>void STInit(ST* pst)//栈初始化
{
	assert(pst); //判断pst是否为空
	pst-&gt;capacity = 0;
	pst-&gt;top = 0;
	pst-&gt;a = NULL;
}</code></pre> 
<pre><code>void STDistroy(ST* pst)//栈的销毁
{
	assert(pst);
	free(pst-&gt;a);
	pst-&gt;a = NULL;
	pst-&gt;capacity = pst-&gt;top = 0;
}</code></pre> 
<p> 这里和顺序表差不多，很简单就不多说了。</p> 
<p></p> 
<h3>3.2 压栈和出栈</h3> 
<p>在<span style="color:#ed7976;">Stack.h</span>中进行函数的声明。</p> 
<pre><code>void STPush(ST* pst, STDateType x);//压栈
void STPop(ST* pst);//出栈</code></pre> 
<p>这里的参数需要传指针，压栈的函数参数还有要插入的数据。因为栈插入数据就是从栈顶插入，这里就没有什么头插尾插的概念，直接就是Push，删除数据也是，直接栈顶删除Pop。</p> 
<p>在<span style="color:#ed7976;"><strong>SeqList.c</strong></span>中进行函数的实现</p> 
<p><strong>先说压栈</strong></p> 
<p>先分析空间足够的情况，<span style="color:#ff9900;">初始化我们把top置为0</span>，放进一个元素，top就是1，但是这个元素在数组中的下标为0，所以栈顶元素数组下标是top-1，而<span style="color:#ff9900;">top指向的是栈顶元素的下一个位置</span>，而不是栈顶元素。</p> 
<p>所以我们放数据就是直接放下标为top的位置。</p> 
<p><img alt="" height="241" src="https://images2.imgbox.com/37/cd/mpaf0oel_o.png" width="695"></p> 
<pre><code>void STPush(ST* pst, STDateType x)//压栈
{
    assert(pst);
	pst-&gt;a[pst-&gt;top] = x; //先放数据
	pst-&gt;top++;   //然后top++

}</code></pre> 
<p>然后考虑扩容。capacity是数组大小，分析一下数组满了的情况</p> 
<p></p> 
<p><img alt="" height="234" src="https://images2.imgbox.com/9c/2f/sb8hOrgd_o.png" width="810"></p> 
<p> <img alt="" height="238" src="https://images2.imgbox.com/2b/ad/Zhc67n9q_o.png" width="823"></p> 
<p>应该是top和capacity相等，此时就要扩容。</p> 
<pre><code>void STPush(ST* pst, STDateType x)//压栈
{
	assert(pst);
	if (pst-&gt;top == pst-&gt;capacity)
	{
		int newcapacity = pst-&gt;capacity * 2;//原来空间2倍的扩容
		//扩容
		STDateType* tmp = (STDateType*)realloc(pst-&gt;a, newcapacity * sizeof(STDateType));
		if (tmp == NULL) //扩容失败
		{
			perror("realloc fail");
			return;
		}
		//扩容成功
		pst-&gt;a = tmp;
		pst-&gt;capacity = newcapacity;
	}
	pst-&gt;a[pst-&gt;top] = x;
	pst-&gt;top++;
}</code></pre> 
<p>但是我们要<span style="color:#ff9900;">注意</span>这句代码 int newcapacity = pst-&gt;capacity * 2;  我们一开始<span style="color:#ff9900;">capacity初始化为0</span>，0乘任何数都是0，所以这句换我们要改一下，用一个三目操作符就能解决。</p> 
<pre><code>int newcapacity = pst-&gt;capacity == 0 ? 4 : pst-&gt;capacity * 2;</code></pre> 
<p><strong> 再说出栈</strong></p> 
<p>出栈和顺序表是一样的，直接top--就行了，不理解的可以看看顺序表中数据的<span style="color:#ff9900;">尾删</span></p> 
<pre><code>void STPop(ST* pst)//出栈
{
	assert(pst);
    assert(pst-&gt;top &gt; 0);
	pst-&gt;top--;
}</code></pre> 
<p></p> 
<p>在<strong><span style="color:#ed7976;">test.c</span></strong>中测试一下栈的初始化，压栈，出栈，栈的销毁。</p> 
<pre><code>#include "Stack.h"
int main()
{
	ST s;
	STInit(&amp;s);   //初始化
	STPush(&amp;s, 1);//压栈
	STPush(&amp;s, 2);
	STPush(&amp;s, 3);
	STPush(&amp;s, 4);
	for (int i = 0; i &lt; s.top; i++)
	{
		printf("%d ", s.a[i]);
	}
	printf("\n");


	STPop(&amp;s);//出栈
	for (int i = 0; i &lt; s.top; i++)
	{
		printf("%d ", s.a[i] );
	}
	printf("\n");

	STPop(&amp;s);//出栈
	for (int i = 0; i &lt; s.top; i++)
	{
		printf("%d ", s.a[i]);
	}

	STDistroy(&amp;s);//销毁

	return 0;
}</code></pre> 
<p><img alt="" height="707" src="https://images2.imgbox.com/14/04/E1hhEXYR_o.png" width="707"><strong> 遵循后进先出</strong></p> 
<p></p> 
<h3>3.3 获取栈顶元素</h3> 
<p>在<span style="color:#ed7976;">Stack.h</span>中进行函数的声明。</p> 
<pre><code>STDateType STTopDate(ST* pst);//获取栈顶元素</code></pre> 
<p>在<span style="color:#ed7976;"><strong>SeqList.c</strong></span>中进行函数的实现</p> 
<pre><code>STDateType STTopDate(ST* pst)//获取栈顶元素
{
	assert(pst);
	assert(pst-&gt;top &gt; 0);
	return pst-&gt;a[pst-&gt;top - 1];
}</code></pre> 
<p>在<strong><span style="color:#ed7976;">test.c</span></strong>中测试一下</p> 
<pre><code>#include "Stack.h"
int main()
{
	ST s;
	STInit(&amp;s);   //初始化
	STPush(&amp;s, 1);//压栈
	STPush(&amp;s, 2);
	STPush(&amp;s, 3);
	STPush(&amp;s, 4);
	for (int i = 0; i &lt; s.top; i++)
	{
		printf("%d ", s.a[i]);
	}
	printf("\n");
	printf("栈顶元素：%d\n", STTopDate(&amp;s));

	STPop(&amp;s);//出栈
	STPop(&amp;s);
	for (int i = 0; i &lt; s.top; i++)
	{
		printf("%d ", s.a[i] );
	}
	printf("\n");
	printf("栈顶元素：%d\n", STTopDate(&amp;s));

	STDistroy(&amp;s);//销毁

	return 0;
}</code></pre> 
<p><img alt="" height="663" src="https://images2.imgbox.com/22/97/esoj0Jzm_o.png" width="797"></p> 
<p></p> 
<h3>3.4 判断栈是否为空</h3> 
<p>在<span style="color:#ed7976;">Stack.h</span>中进行函数的声明。</p> 
<pre><code>bool STEmpty(ST* pst);//判断栈是否为空
</code></pre> 
<p>这里用了bool类型，需要包含头文件stdbool.h</p> 
<p>在<span style="color:#ed7976;"><strong>SeqList.c</strong></span>中进行函数的实现</p> 
<pre><code>bool STEmpty(ST* pst)//判断栈是否为空
{
	assert(pst);
	if (pst-&gt;top == 0) //为空，返回真
		return true;
	else               //不为空，返回假
		return false;
}</code></pre> 
<p>还有一个更简单的写法，如下</p> 
<pre><code> bool STEmpty(ST* pst)//判断栈是否为空
{
	assert(pst);
	return pst-&gt;top == 0;
}</code></pre> 
<p> 为空，返回真，不为空返回假。</p> 
<p>在<strong><span style="color:#ed7976;">test.c</span></strong>中测试一下，<strong>用栈的后进先出的特点访问</strong></p> 
<pre><code>#include "Stack.h"
int main()
{
	ST s;
	STInit(&amp;s);   //初始化
	STPush(&amp;s, 1);//压栈
	STPush(&amp;s, 2);
	STPush(&amp;s, 3);
	STPush(&amp;s, 4);
    
    //栈标准的后进先出访问方式
	while (!STEmpty(&amp;s))
	{
		printf("%d ", STTopDate(&amp;s));//先访问栈顶元素
		STPop(&amp;s); //然后把栈顶元素删除
	}

	STDistroy(&amp;s);//销毁

	return 0;
}</code></pre> 
<p><img alt="" height="392" src="https://images2.imgbox.com/16/c6/9yQgQ00S_o.png" width="800"></p> 
<p></p> 
<h3>3.5 获取栈元素个数</h3> 
<p>在<span style="color:#ed7976;">Stack.h</span>中进行函数的声明。</p> 
<pre><code>int STSize(ST* pst);//获取栈元素个数
</code></pre> 
<p>在<span style="color:#ed7976;"><strong>SeqList.c</strong></span>中进行函数的实现</p> 
<p>因为我们前面的top初始化为0，所以top就是栈的元素个数，直接返回top就行了。</p> 
<pre><code>int STSize(ST* pst)//获取栈元素个数
{
	assert(pst);
	return pst-&gt;top;
}</code></pre> 
<p>在<strong><span style="color:#ed7976;">test.c</span></strong>中自己测试一下，这里就不测试了</p> 
<p></p> 
<p>到这里这个栈就实现好了，本篇也就结束啦，拜拜~</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/7e/13/2n9arAMU_o.gif"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/56ee8286eef2bad456503190913351f8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Redis01——Redis简介</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a27413fc03fa4bdd98585abac2b3c9c4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C语言】qsort函数的介绍和使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>