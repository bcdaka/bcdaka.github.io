<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>GNU/Linux - Linux Kernel Device model - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/890d45d77f5f87016a1b4d9eda3ae7c9/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="GNU/Linux - Linux Kernel Device model">
  <meta property="og:description" content="Linux 设备模型是 Linux 内核中的一个框架，它提供了一种统一、一致的方式来管理和表示硬件设备。设备模型抽象了硬件的细节，使得开发和维护驱动程序和子系统变得更加容易。以下是 Linux 设备模型的关键组成部分和概念：
关键组成部分 设备 (Devices)
表示系统中的硬件组件。
每个设备在内核中由 struct device 表示。
设备按照层次结构组织，反映它们的物理或逻辑关系（例如，USB 设备是 USB 主机控制器的子设备）。
驱动程序 (Drivers)
管理和控制设备的软件组件。
每个驱动程序在内核中由 struct device_driver 表示。
驱动程序提供初始化、配置和管理设备的方法。
总线 (Buses)
表示设备之间的通信通道。
例如 PCI、USB 和 I2C。
每种总线类型在内核中由 struct bus_type 表示。
总线负责设备的枚举和设备与驱动程序的绑定。
类 (Classes)
表示具有共同功能的设备类别。
例如块设备、网络设备和输入设备。
每个类在内核中由 struct class 表示。
类提供了一种将具有相似功能的设备分组并以一致的方式向用户空间公开的方法。
子系统 (Subsystems)
分组相关设备和驱动程序的更高级抽象。
子系统通常对应于特定类型的硬件或功能（例如 USB 子系统、SCSI 子系统）。
核心概念 设备树 (Device Tree)
系统中设备的层次表示。
设备树反映设备的物理或逻辑排列。
用于表示内置硬件和可热插拔设备。
Sysfs
一个虚拟文件系统，将设备、驱动程序和总线的信息暴露给用户空间。
位于文件系统层次结构中的 /sys。
允许用户空间应用程序与设备进行交互和配置。
设备注册和注销 (Device Registration and Deregistration)">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-04T09:18:11+08:00">
    <meta property="article:modified_time" content="2024-07-04T09:18:11+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">GNU/Linux - Linux Kernel Device model</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p></p> 
<p>Linux 设备模型是 Linux 内核中的一个框架，它提供了一种统一、一致的方式来管理和表示硬件设备。设备模型抽象了硬件的细节，使得开发和维护驱动程序和子系统变得更加容易。以下是 Linux 设备模型的关键组成部分和概念：</p> 
<h4>关键组成部分</h4> 
<ol><li> <p>设备 (Devices)</p> 
  <ul><li> <p>表示系统中的硬件组件。</p> </li><li> <p>每个设备在内核中由 struct device 表示。</p> </li><li> <p>设备按照层次结构组织，反映它们的物理或逻辑关系（例如，USB 设备是 USB 主机控制器的子设备）。</p> </li></ul></li><li> <p>驱动程序 (Drivers)</p> 
  <ul><li> <p>管理和控制设备的软件组件。</p> </li><li> <p>每个驱动程序在内核中由 struct device_driver 表示。</p> </li><li> <p>驱动程序提供初始化、配置和管理设备的方法。</p> </li></ul></li><li> <p>总线 (Buses)</p> 
  <ul><li> <p>表示设备之间的通信通道。</p> </li><li> <p>例如 PCI、USB 和 I2C。</p> </li><li> <p>每种总线类型在内核中由 struct bus_type 表示。</p> </li><li> <p>总线负责设备的枚举和设备与驱动程序的绑定。</p> </li></ul></li><li> <p>类 (Classes)</p> 
  <ul><li> <p>表示具有共同功能的设备类别。</p> </li><li> <p>例如块设备、网络设备和输入设备。</p> </li><li> <p>每个类在内核中由 struct class 表示。</p> </li><li> <p>类提供了一种将具有相似功能的设备分组并以一致的方式向用户空间公开的方法。</p> </li></ul></li><li> <p>子系统 (Subsystems)</p> 
  <ul><li> <p>分组相关设备和驱动程序的更高级抽象。</p> </li><li> <p>子系统通常对应于特定类型的硬件或功能（例如 USB 子系统、SCSI 子系统）。</p> </li></ul></li></ol> 
<h4>核心概念</h4> 
<ol><li> <p>设备树 (Device Tree)</p> 
  <ul><li> <p>系统中设备的层次表示。</p> </li><li> <p>设备树反映设备的物理或逻辑排列。</p> </li><li> <p>用于表示内置硬件和可热插拔设备。</p> </li></ul></li><li> <p>Sysfs</p> 
  <ul><li> <p>一个虚拟文件系统，将设备、驱动程序和总线的信息暴露给用户空间。</p> </li><li> <p>位于文件系统层次结构中的 /sys。</p> </li><li> <p>允许用户空间应用程序与设备进行交互和配置。</p> </li></ul></li><li> <p>设备注册和注销 (Device Registration and Deregistration)</p> 
  <ul><li> <p>设备和驱动程序注册到内核，内核管理它们的生命周期。</p> </li><li> <p>注册涉及将设备或驱动程序添加到内核中的适当数据结构。</p> </li><li> <p>注销涉及从这些数据结构中删除设备或驱动程序。</p> </li></ul></li><li> <p>设备探测和绑定 (Device Probing and Binding)</p> 
  <ul><li> <p>内核将设备与驱动程序匹配的过程。</p> </li><li> <p>探测涉及内核调用驱动程序的探测方法来初始化设备。</p> </li><li> <p>绑定指的是设备与驱动程序的关联。</p> </li></ul></li><li> <p>电源管理 (Power Management)</p> 
  <ul><li> <p>设备模型包括对电源管理的支持，允许设备挂起和恢复。</p> </li><li> <p>这对于节省电源尤其重要，特别是在移动和嵌入式系统中。</p> </li></ul></li></ol> 
<h4>示例：USB 设备模型</h4> 
<ol><li> <p>USB 设备</p> 
  <ul><li> <p>由 struct usb_device 表示。</p> </li><li> <p>连接到 USB 总线（由 struct usb_bus 表示）。</p> </li></ul></li><li> <p>USB 驱动程序</p> 
  <ul><li> <p>由 struct usb_driver 表示。</p> </li><li> <p>管理 USB 设备并提供初始化、配置和处理 USB 特定操作的方法。</p> </li></ul></li><li> <p>枚举</p> 
  <ul><li> <p>USB 子系统枚举连接到总线的设备。</p> </li><li> <p>设备被添加到设备树中，并与适当的驱动程序匹配。</p> </li></ul></li><li> <p>Sysfs 接口</p> 
  <ul><li> <p>有关 USB 设备和驱动程序的信息暴露在 /sys/bus/usb 中。</p> </li><li> <p>用户空间应用程序可以读取和写入这些文件与 USB 设备进行交互。</p> </li></ul></li></ol> 
<h4>Linux 设备模型的优点</h4> 
<ul><li> <p>一致性：提供了一种在不同类型的硬件上管理设备和驱动程序的一致方式。</p> </li><li> <p>模块化：鼓励模块化设计，使得开发和维护驱动程序更容易。</p> </li><li> <p>可扩展性：支持可热插拔设备和动态设备管理。</p> </li><li> <p>用户空间交互：Sysfs 提供了一种标准化方式，使用户空间应用程序可以与设备进行交互。</p> </li></ul> 
<p>通过提供这些抽象和框架，Linux 设备模型简化了设备驱动程序的开发，并改进了 Linux 内核中硬件设备的整体组织和可管理性。</p> 
<hr> 
<p></p> 
<p></p> 
<p>The Linux device model is a framework within the Linux kernel that provides a unified and consistent way to manage and represent hardware devices. It abstracts the details of the hardware from the kernel and user-space software, making it easier to develop and maintain drivers and subsystems. Here's an overview of the key components and concepts in the Linux device model:</p> 
<p></p> 
<p>Key Components</p> 
<p>1. Devices</p> 
<p>    * Represent hardware components in the system.</p> 
<p>    * Each device is represented by a struct device in the kernel.</p> 
<p>    * Devices are organized in a hierarchical manner, reflecting their physical or logical relationships (e.g., a USB device is a child of a USB host controller).</p> 
<p>2. Drivers</p> 
<p>    * Software components that manage and control devices.</p> 
<p>    * Each driver is represented by a struct device_driver in the kernel.</p> 
<p>    * Drivers provide methods to initialize, configure, and manage devices.</p> 
<p>3. Buses</p> 
<p>    * Represent the communication pathways through which devices are connected.</p> 
<p>    * Examples include PCI, USB, and I2C.</p> 
<p>    * Each bus type is represented by a struct bus_type in the kernel.</p> 
<p>    * Buses manage the enumeration of devices and the binding of devices to drivers.</p> 
<p>4. Classes</p> 
<p>    * Represent categories of devices that share common functionality.</p> 
<p>    * Examples include block devices, network devices, and input devices.</p> 
<p>    * Each class is represented by a struct class in the kernel.</p> 
<p>    * Classes provide a way to group devices with similar functionality and expose them to user space in a consistent manner.</p> 
<p>5. Subsystems</p> 
<p>    * Higher-level abstractions that group related devices and drivers.</p> 
<p>    * Subsystems often correspond to specific types of hardware or functionality (e.g., the USB subsystem, the SCSI subsystem).</p> 
<p></p> 
<p>Core Concepts</p> 
<p>1. Device Tree</p> 
<p>    * A hierarchical representation of the devices in the system.</p> 
<p>    * The device tree reflects the physical or logical arrangement of devices.</p> 
<p>    * It is used to represent both built-in hardware and hot-pluggable devices.</p> 
<p>2. Sysfs</p> 
<p>    * A virtual filesystem that exposes information about devices, drivers, and buses to user space.</p> 
<p>    * Located at /sys in the filesystem hierarchy.</p> 
<p>    * Allows user-space applications to interact with and configure devices.</p> 
<p>3. Device Registration and Deregistration</p> 
<p>    * Devices and drivers register with the kernel, which then manages their lifecycle.</p> 
<p>    * Registration involves adding a device or driver to the appropriate data structures in the kernel.</p> 
<p>    * Deregistration involves removing a device or driver from these data structures.</p> 
<p>4. Device Probing and Binding</p> 
<p>    * The process by which the kernel matches devices to drivers.</p> 
<p>    * Probing involves the kernel invoking the driver's probe method to initialize the device.</p> 
<p>    * Binding refers to the association of a device with a driver.</p> 
<p>5. Power Management</p> 
<p>    * The device model includes support for power management, allowing devices to be suspended and resumed.</p> 
<p>    * This is critical for conserving power, especially in mobile and embedded systems.</p> 
<p></p> 
<p>Example: USB Device Model</p> 
<p>1. USB Device</p> 
<p>    * Represented by a struct usb_device.</p> 
<p>    * Connected to a USB bus (represented by a struct usb_bus).</p> 
<p>2. USB Driver</p> 
<p>    * Represented by a struct usb_driver.</p> 
<p>    * Manages USB devices and provides methods to initialize, configure, and handle USB-specific operations.</p> 
<p>3. Enumeration</p> 
<p>    * The USB subsystem enumerates devices connected to the bus.</p> 
<p>    * Devices are added to the device tree and matched with appropriate drivers.</p> 
<p>4. Sysfs Interface</p> 
<p>    * Information about USB devices and drivers is exposed in /sys/bus/usb.</p> 
<p>    * User-space applications can read and write to these files to interact with USB devices.</p> 
<p></p> 
<p>Benefits of the Linux Device Model</p> 
<p>* Consistency: Provides a uniform way to manage devices and drivers across different types of hardware.</p> 
<p>* Modularity: Encourages modular design, making it easier to develop and maintain drivers.</p> 
<p>* Extensibility: Supports hot-pluggable devices and dynamic device management.</p> 
<p>* User-Space Interaction: Sysfs provides a standardized way for user-space applications to interact with devices.</p> 
<p>By providing these abstractions and frameworks, the Linux device model simplifies the development of device drivers and improves the overall organization and manageability of hardware devices within the Linux kernel.</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/48873b734e0dcfbb965310df7af85644/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Python】Python中的数据类型</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/267e0876d5c66d8895fbd6df89f41e60/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【DataSophon】DataSophon1.2.1服务组件开启 kerberos</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>