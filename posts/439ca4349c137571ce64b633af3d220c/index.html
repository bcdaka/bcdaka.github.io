<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;进阶学习】第十一弹——C&#43;&#43;11（上）——右值引用和移动语义 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/439ca4349c137571ce64b633af3d220c/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;进阶学习】第十一弹——C&#43;&#43;11（上）——右值引用和移动语义">
  <meta property="og:description" content="前言：
前面我们已经将C&#43;&#43;的重点语法讲的大差不差了，但是在C&#43;&#43;11版本之后，又出来了很多新的语法，其中有一些作用还是非常大的，今天我们就先来学习其中一个很重要的点——右值引用以及它所扩展的移动定义
目录
一、左值引用和右值引用
左值引用 右值引用
二、左值引用与右值引用的比较
三、右值引用的使用
移动构造
移动赋值
四、总结
一、左值引用和右值引用 左值引用 左值引用是最常见的引用类型，通常用于绑定到一个左值。左值是一个具有名称的对象，可以取地址，通常出现在赋值操作符的左边。（简单的说，能取地址的就是左值）
语法：
类型 &amp;引用名 = 左值; 示例：
int a = 10; int &amp;refA = a; // refA是一个左值引用，绑定到左值a 特点：
左值引用必须初始化，并且只能绑定到左值。左值引用可以修改绑定的对象。 右值引用 右值引用是C&#43;&#43;11引入的新特性，用于绑定到一个右值。右值是一个临时对象，通常没有名称，不能取地址，通常出现在赋值操作符的右边。（右值不能取地址，比如常量）
语法：
类型 &amp;&amp;引用名 = 右值; 示例：
int &amp;&amp;refB = 20; // refB是一个右值引用，绑定到右值20 特点：
右值引用必须初始化，并且只能绑定到右值。右值引用主要用于实现移动语义和完美转发。 有一个需要强调的是，常变量虽然也属于常量，但是它可以取地址，所以它属于左值
二、左值引用与右值引用的比较 左值引用：
1. 左值引用只能引用左值，不能引用右值。 2. 但是const左值引用既可引用左值，也可引用右值 int main() { // 左值引用只能引用左值，不能引用右值。 int a = 10; int&amp; ra1 = a; // ra为a的别名 //int&amp; ra2 = 10; // 编译失败，因为10是右值 // const左值引用既可引用左值，也可引用右值。 const int&amp; ra3 = 10; const int&amp; ra4 = a; return 0； } 右值引用：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-01T23:01:15+08:00">
    <meta property="article:modified_time" content="2024-08-01T23:01:15+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;进阶学习】第十一弹——C&#43;&#43;11（上）——右值引用和移动语义</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>前言：</strong></p> 
<blockquote> 
 <p>前面我们已经将C++的重点语法讲的大差不差了，但是在C++11版本之后，又出来了很多新的语法，其中有一些作用还是非常大的，今天我们就先来学习其中一个很重要的点——右值引用以及它所扩展的移动定义</p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E4%B8%80%E3%80%81%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8" rel="nofollow">一、左值引用和右值引用</a></p> 
<p id="%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%C2%A0-toc" style="margin-left:80px;"><a href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%C2%A0" rel="nofollow">左值引用 </a></p> 
<p id="%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8-toc" style="margin-left:80px;"><a href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8" rel="nofollow">右值引用</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E7%9A%84%E6%AF%94%E8%BE%83-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E7%9A%84%E6%AF%94%E8%BE%83" rel="nofollow">二、左值引用与右值引用的比较</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">三、右值引用的使用</a></p> 
<p id="%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0-toc" style="margin-left:80px;"><a href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0" rel="nofollow">移动构造</a></p> 
<p id="%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC-toc" style="margin-left:80px;"><a href="#%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC" rel="nofollow">移动赋值</a></p> 
<p id="%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93" rel="nofollow">四、总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8">一、左值引用和右值引用</h2> 
<h4 id="%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%C2%A0">左值引用 </h4> 
<p>左值引用是最常见的引用类型，通常用于绑定到一个左值。左值是一个具有名称的对象，可以取地址，通常出现在赋值操作符的左边。（简单的说，能取地址的就是左值）</p> 
<p><strong>语法：</strong></p> 
<pre><code class="language-cpp">类型 &amp;引用名 = 左值;</code></pre> 
<p><strong>示例：</strong></p> 
<pre><code class="language-cpp">int a = 10;
int &amp;refA = a;  // refA是一个左值引用，绑定到左值a</code></pre> 
<p><strong>特点：</strong></p> 
<blockquote> 
 <ul><li>左值引用必须初始化，并且只能绑定到左值。</li><li>左值引用可以修改绑定的对象。</li></ul> 
</blockquote> 
<h4 id="%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8">右值引用</h4> 
<p>右值引用是C++11引入的新特性，用于绑定到一个右值。右值是一个临时对象，通常没有名称，不能取地址，通常出现在赋值操作符的右边。（右值不能取地址，比如常量）</p> 
<p><strong>语法：</strong></p> 
<pre><code class="language-cpp">类型 &amp;&amp;引用名 = 右值;</code></pre> 
<p><strong>示例：</strong></p> 
<pre><code class="language-cpp">int &amp;&amp;refB = 20;  // refB是一个右值引用，绑定到右值20</code></pre> 
<p><strong>特点：</strong></p> 
<blockquote> 
 <ul><li>右值引用必须初始化，并且只能绑定到右值。</li><li>右值引用主要用于实现移动语义和完美转发。</li></ul> 
</blockquote> 
<p><span style="background-color:#ffd900;">有一个需要强调的是，常变量虽然也属于常量，但是它可以取地址，所以它属于左值</span></p> 
<h2 id="%E4%BA%8C%E3%80%81%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E7%9A%84%E6%AF%94%E8%BE%83">二、左值引用与右值引用的比较</h2> 
<p><strong>左值引用：</strong></p> 
<blockquote> 
 <div> 
  <strong><span style="color:#777777;">1. </span><span style="color:#777777;">左值引用只能引用左值，不能引用右值。 </span></strong> 
 </div> 
 <div> 
  <strong><span style="color:#777777;">2. </span><span style="color:#777777;">但是</span><span style="color:#777777;">const</span><span style="color:#777777;">左值引用既可引用左值，也可引用右值</span></strong> 
 </div> 
</blockquote> 
<div> 
 <pre><code class="language-cpp">int main()
{
    // 左值引用只能引用左值，不能引用右值。
    int a = 10;
    int&amp; ra1 = a;   // ra为a的别名
    //int&amp; ra2 = 10;   // 编译失败，因为10是右值
    // const左值引用既可引用左值，也可引用右值。
    const int&amp; ra3 = 10;
    const int&amp; ra4 = a;
    return 0；
}</code></pre> 
 <p><strong>右值引用：</strong></p> 
 <blockquote> 
  <div> 
   <strong><span style="color:#777777;">1. </span><span style="color:#777777;">右值引用只能右值，不能引用左值。 </span></strong> 
  </div> 
  <div> 
   <strong><span style="color:#777777;">2. </span><span style="color:#777777;">但是右值引用可以</span><span style="color:#777777;">move</span><span style="color:#777777;">以后的左值。</span></strong> 
  </div> 
 </blockquote> 
 <div> 
  <pre><code class="language-cpp">int main()
{
 // 右值引用只能右值，不能引用左值。
 int&amp;&amp; r1 = 10;
 
 // error C2440: “初始化”: 无法从“int”转换为“int &amp;&amp;”
 // message : 无法将左值绑定到右值引用
 int a = 10;
 int&amp;&amp; r2 = a;
 // 右值引用可以引用move以后的左值
 int&amp;&amp; r3 = std::move(a);
 return 0;
}</code></pre> 
  <h2 id="%E4%B8%89%E3%80%81%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E7%9A%84%E4%BD%BF%E7%94%A8">三、右值引用的使用</h2> 
  <p>在上面我们也已经讲到了，左值引用及可以引用左值，又可以引用右值，那么C++11为什么还要设计右值引用呢？下面我们来看一下原因。</p> 
  <p><strong><span style="background-color:#ffd900;">我们借助string类来讲解</span></strong></p> 
  <p><strong><span style="background-color:#ffd900;">先来看一下下面所出现的所有代码，可以先思考看看思考思考</span></strong></p> 
  <pre><code class="language-cpp">namespace zda
{
	class string
	{
	public:
		typedef char* iterator;
		iterator begin()
		{
			return _str;
		}
		iterator end()
		{
			return _str + _size;
		}
		string(const char* str = "")
			:_size(strlen(str))
			, _capacity(_size)
		{
			//cout &lt;&lt; "string(char* str)" &lt;&lt; endl;
			_str = new char[_capacity + 1];
			strcpy(_str, str);
		}
		// s1.swap(s2)
		void swap(string&amp; s)
		{
			::swap(_str, s._str);
			::swap(_size, s._size);
			::swap(_capacity, s._capacity);
		}
		// 拷贝构造
		string(const string&amp; s)
			:_str(nullptr)
		{
			cout &lt;&lt; "string(const string&amp; s) -- 深拷贝" &lt;&lt; endl;
			string tmp(s._str);
			swap(tmp);
		}
		// 赋值重载
		string&amp; operator=(const string&amp; s)
		{
			cout &lt;&lt; "string&amp; operator=(string s) -- 深拷贝" &lt;&lt; endl;
			string tmp(s);
			swap(tmp);
			return *this;
		}
		// 移动构造
		string(string&amp;&amp; s)   //右值引用
			:_str(nullptr)
			, _size(0)
			, _capacity(0)
		{
			cout &lt;&lt; "string(string&amp;&amp; s) -- 移动语义" &lt;&lt; endl;
			swap(s);
		}
		// 移动赋值
		string&amp; operator=(string&amp;&amp; s)    //右值引用
		{
			cout &lt;&lt; "string&amp; operator=(string&amp;&amp; s) -- 移动语义" &lt;&lt; endl;
			swap(s);
			return *this;
		}
		~string()
		{
			delete[] _str;
			_str = nullptr;
		}
		char&amp; operator[](size_t pos)
		{
			assert(pos &lt; _size);
			return _str[pos];
		}
		void reserve(size_t n)
		{
			if (n &gt; _capacity)
			{
				char* tmp = new char[n + 1];
				strcpy(tmp, _str);
				delete[] _str;
				_str = tmp;
				_capacity = n;
			}
		}
		void push_back(char ch)
		{
			if (_size &gt;= _capacity)
			{
				size_t newcapacity = _capacity == 0 ? 4 : _capacity * 2;
				reserve(newcapacity);
			}
			_str[_size] = ch;
			++_size;
			_str[_size] = '\0';
		}
		//string operator+=(char ch)
		string&amp; operator+=(char ch)
		{
			push_back(ch);
			return *this;
		}
		const char* c_str() const
		{
			return _str;
		}
	private:
		char* _str;
		size_t _size;
		size_t _capacity; // 不包含最后做标识的\0
	};
	string to_string(int value)
	{
		bool flag = true;
		if (value &lt; 0)
		{
			flag = false;
			value = 0 - value;
		}
		string str;
		while (value &gt; 0)
		{
			int x = value % 10;
			value /= 10;
			str += ('0' + x);
		}
		if (flag == false)
		{
			str += '-';
		}
		std::reverse(str.begin(), str.end());
		return str;
	}
}

</code></pre> 
  <p><strong>左值引用使用场景：</strong></p> 
  <pre><code class="language-cpp">void func1(bit::string s)
{}
void func2(const bit::string&amp; s)
{}
int main()
{
 bit::string s1("hello world");
 // func1和func2的调用我们可以看到左值引用做参数减少了拷贝，提高效率的使用场景和价值
 func1(s1);
 func2(s1);
 // string operator+=(char ch) 传值返回存在深拷贝
 // string&amp; operator+=(char ch) 传左值引用没有拷贝提高了效率
 s1 += '!';
 return 0;
}</code></pre> 
  <p><strong>左值引用短板：</strong></p> 
  <blockquote> 
   <p>当函数返回对象为临时变量的时候，左值引用就派不上用场了，就只能传值返回，就需要拷贝至少一次（老一点的编译器为两次）</p> 
  </blockquote> 
  <p><img alt="" height="557" src="https://images2.imgbox.com/e3/45/TzTVQrJA_o.png" width="1200"></p> 
 </div> 
 <div> 
  <img alt="" height="636" src="https://images2.imgbox.com/57/ba/izHUq9NF_o.png" width="1179"> 
 </div> 
 <div> 
  <strong>右值引用和移动语义：</strong> 
 </div> 
 <div></div> 
 <div> 
  <strong><span style="background-color:#ffd900;">对于上面这种问题，我们就可以通过右值引用和移动语义来实现</span></strong> 
 </div> 
 <h4 id="%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0"><strong>移动构造</strong></h4> 
 <div>
   移动构造的本质就是将参数的右值窃取过来，占为己有，这样它就不用再深度拷贝了，所以叫做移动构造 
 </div> 
 <div></div> 
 <div> 
  <pre><code class="language-cpp">// 移动构造
string(string&amp;&amp; s)
 :_str(nullptr)
 ,_size(0)
 ,_capacity(0)
{
 cout &lt;&lt; "string(string&amp;&amp; s) -- 移动语义" &lt;&lt; endl;
 swap(s);
}
int main()
{
 zda::string ret2 = bit::to_string(-1234);
 return 0;
}</code></pre> 
  <p>当返回值是右值时，因为移动构造并没有开辟空间进行深拷贝，所以效率就会更高</p> 
  <p>需要注意的是，当拷贝构造和移动构造同时存在时，编译器默认的也会调用移动构造，因为编译器会默认调用效率更高的函数</p> 
  <h4 id="%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC">移动赋值</h4> 
 </div> 
 <div> 
  <pre><code class="language-cpp">// 移动赋值
string&amp; operator=(string&amp;&amp; s)
{
cout &lt;&lt; "string&amp; operator=(string&amp;&amp; s) -- 移动语义" &lt;&lt; endl;
swap(s);
return *this;
}
int main()
{
 zda::string ret1;
 ret1 = zda::to_string(1234);
 return 0;
}

// 运行结果：
// string(string&amp;&amp; s) -- 移动语义
// string&amp; operator=(string&amp;&amp; s) -- 移动语义</code></pre> 
  <blockquote> 
   <p>这里运行后发现，调用了一次移动构造和一次移动赋值，因为这里的ret1是一个已经存在的对象，用它来接受函数返回值的时候编译器就无法再优化了，所以会在移动构造后创建一个临时变量，且这个临时变量会被编译器识别为右值，从而调用移动赋值</p> 
  </blockquote> 
 </div> 
 <h2 id="%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93">四、总结</h2> 
 <blockquote> 
  <p>上面我们就简单的先提了一下右值引用的应用：移动语义，下一篇我们再重点讲解一下右值引用的另一个重点语法：完美挥发</p> 
 </blockquote> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2d/81/UyfS1f6l_o.jpg"></p> 
 <div> 
  <strong><span style="background-color:#ffd900;">感谢各位大佬观看，创作不易，还请各位大佬点赞支持一下！！！</span></strong> 
 </div> 
 <div></div> 
 <div></div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a7bca482ac83c3f0459102d54a28457f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">React三原理和路由</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/009d88de267530e08968434669583a2d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">matplotLib在图中标出最后一个点的值</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>