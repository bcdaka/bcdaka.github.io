<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>.NET操作RabbitMQ(全球最简单实现) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/ac87e4ddcb256cbd5e08103da80bfafd/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content=".NET操作RabbitMQ(全球最简单实现)">
  <meta property="og:description" content="🏆作者：科技、互联网行业优质创作者
🏆专注领域：.Net技术、软件架构、人工智能、数字化转型、DeveloperSharp、微服务、工业互联网、智能制造
🏆欢迎关注我（Net数字智慧化基地），里面有很多高价值技术文章，是你刻苦努力也积累不到的经验，能助你快速成长。升职&#43;涨薪！！
(提示：最新版已解决部署为“服务”时报错的问题，关键配置文件要放对位置) RabbitMQ作为一款主流的消息队列工具早已广受欢迎。相比于其它的MQ工具，RabbitMQ支持的语言更多、功能更完善。
1.发送消息、获取消息、使用消息 本文提供一种市面上最/极简单的使用RabbitMQ的方式，只需要会调用以下三个方法，你就几乎可以掌握整个RabbitMQ的使用：
（1） SendMessage，发送一个消息
（2） GetMessage，获取一个消息
（3） UseMessage，使用一个消息（连续使用）
为了调用以上三个方法，首先需要从NuGet引用DeveloperSharp.RabbitMQ包。
然后，对RabbitMQ消息服务器的链接信息进行配置（分.Net Core与.Net Framework两种情况）：
若是在.Net Core环境下，你则需要在DeveloperSharp.json文件中添加“DeveloperSharp.RabbitMQ”节点（如下配置示例），并把DeveloperSharp.json文件放到程序执行目录中（即bin目录下与dll、exe等文件的同一目录中，放错了位置会报错）（注意：有些.Net Core版本在Visual Studio“调试”时，不会在bin目录下生成全部的dll、exe，此时需要把此配置文件放在应用程序的“根目录”下）。
{ &#34;DeveloperSharp.RabbitMQ&#34;:[{ &#34;HostName&#34;:&#34;135.208.12.236&#34;, &#34;VirtualHost&#34;:&#34;/&#34;, &#34;UserName&#34;:&#34;sa&#34;, &#34;Password&#34;:&#34;aevin.gang&#34;, &#34;Port&#34;:5672 }] } 若是在.Net Framework环境下，你则需要在App.config/Web.config里面添加如下配置：
&lt;appSettings&gt; &lt;add key=&#34;RabbitMQConnectionString&#34; value=&#34;hostName=135.208.12.236,virtualHost=/,port=5672,userName=sa,password=aevin.gang&#34; /&gt; &lt;/appSettings&gt; 说明：上述配置中分别设置了RabbitMQ应用所在的服务器IP地址hostName、虚拟主机virtualHost、端口port、用户名userName、密码password（请把这五项的对应值修改成你自己那边的RabbitMQ的对应值）
下面，我们给出一个使用了上述SendMessage、GetMessage、UseMessage三个方法的示例。该示例的功能说明如下：
先向RabbitMQ服务器上名为“aa”的队列发送了5个消息，然后从RabbitMQ服务器上的“aa”队列中获取，并打印出第1个消息，最后再连续从RabbitMQ服务器上的“aa”队列中获取剩余4个消息，并把它们写入名为fj.txt的文件。 代码如下：
using DeveloperSharp.RabbitMQ; -------------------------- static void Main(string[] args) { //发送5个消息（使用SendMessage） RabbitMQHelper.SendMessage(&#34;aa&#34;, &#34;世界1，你好！&#34;); RabbitMQHelper.SendMessage(&#34;aa&#34;, &#34;世界2，你好！&#34;); RabbitMQHelper.SendMessage(&#34;aa&#34;, &#34;世界3，你好！&#34;); RabbitMQHelper.SendMessage(&#34;aa&#34;, &#34;世界4，你好！&#34;); RabbitMQHelper.SendMessage(&#34;aa&#34;, &#34;世界5，你好！&#34;); //获取1个消息（使用GetMessage） string OneMessage = RabbitMQHelper.GetMessage(&#34;aa&#34;).Message; Console.WriteLine(OneMessage); //向fj.txt这个文本文件中写入4个消息（使用UseMessage） RabbitMQHelper.UseMessage(&#34;aa&#34;, t =&gt; { System.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-28T07:30:00+08:00">
    <meta property="article:modified_time" content="2024-04-28T07:30:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">.NET操作RabbitMQ(全球最简单实现)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>🏆作者：科技、互联网行业优质创作者<br> 🏆专注领域：.Net技术、软件架构、人工智能、数字化转型、DeveloperSharp、微服务、工业互联网、智能制造<br> 🏆欢迎关注我（<a href="https://blog.csdn.net/alan200995?spm=1011.2124.3001.5343" title="Net数字智慧化基地">Net数字智慧化基地</a>），里面有很多<strong>高价值</strong>技术文章，<strong>是你刻苦努力也积累不到的经验</strong>，能助你快速成长。升职+涨薪！！</p> 
</blockquote> 
<p><span style="color:#fe2c24;">(提示：最新版已解决部署为“服务”时报错的问题，关键配置文件要放对位置) </span></p> 
<p>RabbitMQ作为一款主流的消息队列工具早已广受欢迎。相比于其它的MQ工具，RabbitMQ支持的语言更多、功能更完善。</p> 
<h2><strong>1.发送消息、获取消息、使用消息</strong></h2> 
<p>本文提供一种市面上<strong>最/极</strong>简单的使用RabbitMQ的方式，只需要会调用以下三个方法，<strong>你就几乎可以掌握整个RabbitMQ的使用：</strong></p> 
<p>（1）     SendMessage，发送一个消息</p> 
<p>（2）     GetMessage，获取一个消息</p> 
<p>（3）     UseMessage，使用一个消息（连续使用）</p> 
<p></p> 
<p>为了调用以上三个方法，首先需要从NuGet引用DeveloperSharp.RabbitMQ包。</p> 
<p>然后，对RabbitMQ消息服务器的链接信息进行配置（分.Net Core与.Net Framework两种情况）：</p> 
<p>若是在.Net Core环境下，你则需要在DeveloperSharp.json文件中添加“DeveloperSharp.RabbitMQ”节点（如下配置示例），并把DeveloperSharp.json文件放到程序执行目录中（即bin目录下与dll、exe等文件的同一目录中，放错了位置会报错）（注意：有些.Net Core版本在Visual Studio“调试”时，不会在bin目录下生成全部的dll、exe，此时需要把此配置文件放在应用程序的“根目录”下）。</p> 
<pre><code class="language-cs">{
  "DeveloperSharp.RabbitMQ":[{
    "HostName":"135.208.12.236",
    "VirtualHost":"/",
    "UserName":"sa",
    "Password":"aevin.gang",
    "Port":5672
  }]
}</code></pre> 
<p></p> 
<p>若是在.Net Framework环境下，你则需要在App.config/Web.config里面添加如下配置：</p> 
<pre><code class="language-XML">  &lt;appSettings&gt;
    &lt;add key="RabbitMQConnectionString" value="hostName=135.208.12.236,virtualHost=/,port=5672,userName=sa,password=aevin.gang" /&gt;
  &lt;/appSettings&gt;</code></pre> 
<p>说明：上述配置中分别设置了RabbitMQ应用所在的服务器IP地址hostName、虚拟主机virtualHost、端口port、用户名userName、密码password（请把这五项的对应值修改成你自己那边的RabbitMQ的对应值）</p> 
<p></p> 
<p>下面，我们给出一个使用了上述SendMessage、GetMessage、UseMessage三个方法的示例。该示例的功能说明如下：</p> 
<ul><li>先向RabbitMQ服务器上名为“aa”的队列发送了5个消息，</li><li>然后从RabbitMQ服务器上的“aa”队列中获取，并打印出第1个消息，</li><li>最后再连续从RabbitMQ服务器上的“aa”队列中获取剩余4个消息，并把它们写入名为fj.txt的文件。</li></ul> 
<p>代码如下：</p> 
<pre><code class="language-cs">using DeveloperSharp.RabbitMQ;
--------------------------

        static void Main(string[] args)
        {
            //发送5个消息（使用SendMessage）
            RabbitMQHelper.SendMessage("aa", "世界1，你好！");
            RabbitMQHelper.SendMessage("aa", "世界2，你好！");
            RabbitMQHelper.SendMessage("aa", "世界3，你好！");
            RabbitMQHelper.SendMessage("aa", "世界4，你好！");
            RabbitMQHelper.SendMessage("aa", "世界5，你好！");

            //获取1个消息（使用GetMessage）
            string OneMessage = RabbitMQHelper.GetMessage("aa").Message;
            Console.WriteLine(OneMessage);

            //向fj.txt这个文本文件中写入4个消息（使用UseMessage）
            RabbitMQHelper.UseMessage("aa", t =&gt; 
            {
                System.IO.File.AppendAllText("D:/fj.txt", t.Message);
                return true;
            });
        }</code></pre> 
<p></p> 
<p>运行结果如下：</p> 
<p>【控制台显示出】：<span style="color:#fe2c24;"><span style="background-color:#fff5e6;">世界1，你好！</span></span></p> 
<p>【fj.txt文件中显示出】：<span style="color:#fe2c24;"><span style="background-color:#fff5e6;">世界2，你好！世界3，你好！世界4，你好！世界5，你好！</span></span></p> 
<p></p> 
<p>（上述示例中，由于SendMessage是同步方法，故“世界1，你好！”~“世界5，你好！”会按顺序显示。若我们把SendMessage方法全部改为异步的SendMessageAsync，则显示结果将不再是按顺序来的，很有可能显示成类似这样：“世界3，你好！世界1，你好！世界5，你好！世界2，你好！世界4，你好！”）</p> 
<p></p> 
<p>三个方法的详细功能说明（辅助参考）：</p> 
<pre><code class="language-cs">（1）发送一个消息
void SendMessage(string QueueName, string Message, Dictionary&lt;string, object&gt; Header = null)
//异步方法：SendMessageAsync

（2）获取一个消息
RabbitMQMessage GetMessage(string QueueName)
//异步方法：GetMessageAsync

（3）使用一个消息（连续使用）
void UseMessage(string QueueName, Func&lt;RabbitMQMessage, bool?&gt; Use)
//异步方法：UseMessageAsync
附加说明：
    （I）Use返回值为true时，代表当前消息已被有效处理并会被服务器删除。然后程序自动进入下一条消息的使用。
         若Use返回值为false时，代表当前消息未被有效处理但仍会被服务器删除。然后程序自动进入下一条消息的使用。
         若Use返回值为null时，代表当前消息会被服务器重新队列分配到其它可用的实例上再处理。然后程序自动进入下一条消息的使用。
         若Use内部发生未被处理的异常，程序会停止。
    （II）RabbitMQMessage对象定义如下：
          public class RabbitMQMessage
          {
             public string Message;
             public IDictionary&lt;string, object&gt; Header;
             public string Id; //此处系统自动生成的Id是分布式唯一Id。
          }</code></pre> 
<p></p> 
<h2><strong>2.延时队列 &amp; 死信队列</strong></h2> 
<p>有些场景下，我们希望为使用的消息设定有效期。在有效期内，这些消息有效可用；但过期后，这些消息将变得无效不可用，同时，它们还将自动被丢弃进一个称之为“死信”的队列。</p> 
<p>为了说明这些概念，我们还是来举一个具体的例子。该例子的功能说明如下：</p> 
<ul><li>首先，在RabbitMQ服务器上定义一个名为"bbq"、且其中存放的消息会在60秒后过期失效的队列。</li><li>然后，在RabbitMQ服务器上定义一个与"bbq"队列对应的死信队列。并连续从该死信队列中获取消息并把它们写入名为BB.txt的文件。</li><li>最后，向RabbitMQ服务器上的"bbq"队列发送3个消息。</li></ul> 
<p> 代码如下：</p> 
<pre><code class="language-cs">using DeveloperSharp.RabbitMQ;//从NuGet引用DeveloperSharp.RabbitMQ包
--------------------------

            //定义bbq队列，其中存放的消息会在60秒后过期
            var myQ = RabbitMQHelper.SetQueue("bbq", 60000);

            //定义与bbq队列对应的死信队列
            var expQ = RabbitMQHelper.GetQueue("bbq");
            //向BB.txt这个文本文件中连续写入死信队列中的消息
            expQ.UseMessage(t =&gt;
            {
                System.IO.File.AppendAllText("D:/BB.txt", t.Message);
                return true;
            });

            //向bbq队列发送3个消息
            myQ.SendMessage("jinA");
            myQ.SendMessage("jinB");
            myQ.SendMessage("jinC");</code></pre> 
<p>运行以上程序：</p> 
<p>60秒之内，【BB.txt文件】中没有内容</p> 
<p>60秒以后，【BB.txt文件】中显示出：<span style="color:#fe2c24;"><span style="background-color:#fefcd8;">jinAjinBjinC</span></span></p> 
<p></p> 
<p>通过以上例子，我们可简单预测一下，延时队列&amp;死信队列常用在“限时消费”、“过期处理”等场景。生活中最常见示例如：<span style="color:#956fe7;">文章定时发布、订单请在10分钟内支付完毕、等等之类功能...</span></p> 
<p></p> 
<p><span style="color:#fe2c24;">（其它说明：为了演示便利，文本前面给出的几个代码示例中，把SendMessage、GetMessage、UseMessage三个方法都放到了同一段代码程序中，这样做不好，偶尔会造成一些资源冲突。在实际使用中，最好是把它们分开分别放到三段不同的代码程序中，以获取最佳效果。比如：三个按钮、三个服务，之类...）</span></p> 
<p></p> 
<p>使用消息服务对解耦分布式系统、实现发布/订阅、提高系统性能、等方面都有巨大用处，相信本文会扩展你的思维认知，让你在相关技术解决方案上有更多灵活思路+联想空间！</p> 
<blockquote> 
 <p>🏆<strong>点击下方卡片关注公众号</strong>，向大佬学习，探行业内幕，享时代机遇。</p> 
 <p>（若需技术支持，可进入加群）</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dbb0bb8667db8a4a6e0118e4dc113725/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于Java和GDAL实现的GeoJSON数据读取与入库实践</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/00e1c124f7021d843136ca3657e9d23c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ZooKeeper 搭建详细步骤之一（单机模式）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>