<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】链表带环问题分析及顺序表链表对比分析 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/2f085bc96e43abed7175b51faa886d34/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】链表带环问题分析及顺序表链表对比分析">
  <meta property="og:description" content="【C语言】链表带环问题分析及顺序表链表对比分析 🔥个人主页：大白的编程日记
🔥专栏：C语言学习之路
文章目录 【C语言】链表带环问题分析及顺序表链表对比分析前言一.顺序表和链表对比1.1顺序表和链表的区别1.2缓存利用率（缓存命中率） 二.链表的带环问题2.1快慢指针2.2证明快慢指针相遇问题2.3快指针的步长2.4环的入口 后言 前言 哈喽，各位小伙伴大家好！由于考试周很久没有更新博客了。今天给大家带来的是链表的带环问题和顺序表链表的对比分析。话不多说，进入正题。向大厂冲锋！
一.顺序表和链表对比 1.1顺序表和链表的区别 顺序表和链表是两种不同的数据结构。他们各有各的优劣。我们就来对比分析一下他们的区别。我们这里用带头双向循环链表和顺序表做对比。
存储空间
顺序表：物理上是连续的。
链表：因为链表是由节点组成，每个节点由指针连接。 所以在逻辑上是连续的，但每个节点都是malloc动态开辟的，在物理空间上不一定连续。
随机访问
顺序表：顺序表可以通过下标来进行随机访问。
链表：链表不支持随机访问，只能从头节点开始遍历寻找节点。
任意位置插入删除
顺序表：如果不是尾插尾删，需要挪动数据。
链表：链表由节点组成，插入或删除只需要修改前后节点的指针指向即可。
扩容
顺序表：空间不够需要扩容。
扩容realloc本身会有消耗且异地扩容消耗不小，2倍扩容可能存在空间浪费。
链表：按需申请释放，需要一个申请一个，不存在扩容，不会浪费空间。 #define _CRT_SECURE_NO_WARNINGS 1 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; int main() { int* p = (int*)malloc(4); printf(&#34;%p\n&#34;, p); int* p1 = (int*)realloc(p, 40); printf(&#34;%p&#34;, p1); } 异地扩容：
只要空间大一点，基本都是异地扩容。
原地扩容：
应用场景 顺序表和链表的优劣是互补的。
顺序表适合随机访问，不适合中间位置的插入删除。
链表适合任意位置的插入删除，但无法随机访问。
所以如果经常随机访问，但只需要尾插尾删就选择顺序表。
如果不经常随机访问，在中间位置插入删除就选择链表。
具体根据他们的优劣进行选择。
1.2缓存利用率（缓存命中率） 顺序表和链表的区别还有一个就是
顺序表的缓存命中率高。
链表的缓存命中率低。
为什么呢?什么是缓存命中率呢?
内存和硬盘
这是我们计算机的内部的存储结构。
主存也就是我们的内存和硬盘的区别就是
内存的存储空间更小，通常为8G和16G,但速度快。需要带电存储
硬盘存储空间更大，速度慢，但不需要带电存储。
他们的本质是带不带电。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-07T20:42:34+08:00">
    <meta property="article:modified_time" content="2024-07-07T20:42:34+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】链表带环问题分析及顺序表链表对比分析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="C_0"></a>【C语言】链表带环问题分析及顺序表链表对比分析</h2> 
<p><img src="https://images2.imgbox.com/25/4e/EWmUz2i5_o.gif" alt=""></p> 
<p><font color="pink" size="4"><b>🔥个人主页</b>：<a href="https://blog.csdn.net/2301_81670477?spm=1011.2415.3001.5343"><font color="#33CCCC" size="4"><b>大白的编程日记</b></font></a></font></p> 
<p><font color="pink" size="4">🔥<strong>专栏</strong></font>：<a href="https://blog.csdn.net/2301_81670477/category_12572839.html"><font color="#33CCCC" size="4"><b>C语言学习之路</b></font></a><br> <img src="https://images2.imgbox.com/7d/fb/sfmoaU6q_o.gif" alt=""></p> 
<hr> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#C_0" rel="nofollow">【C语言】链表带环问题分析及顺序表链表对比分析</a></li><li><ul><li><a href="#_11" rel="nofollow">前言</a></li><li><a href="#_17" rel="nofollow">一.顺序表和链表对比</a></li><li><ul><li><a href="#11_18" rel="nofollow">1.1顺序表和链表的区别</a></li><li><a href="#12_70" rel="nofollow">1.2缓存利用率（缓存命中率）</a></li></ul> 
   </li><li><a href="#_142" rel="nofollow">二.链表的带环问题</a></li><li><ul><li><a href="#21_146" rel="nofollow">2.1快慢指针</a></li><li><a href="#22_180" rel="nofollow">2.2证明快慢指针相遇问题</a></li><li><a href="#23_188" rel="nofollow">2.3快指针的步长</a></li><li><a href="#24_203" rel="nofollow">2.4环的入口</a></li></ul> 
   </li><li><a href="#_255" rel="nofollow">后言</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_11"></a>前言</h3> 
<blockquote> 
 <p>哈喽，各位小伙伴大家好！由于考试周很久没有更新博客了。今天给大家带来的是链表的带环问题和顺序表链表的对比分析。话不多说，进入正题。向大厂冲锋！<br> <img src="https://images2.imgbox.com/0d/7c/2E4Z81pN_o.gif" alt=""></p> 
</blockquote> 
<h3><a id="_17"></a>一.顺序表和链表对比</h3> 
<h4><a id="11_18"></a>1.1顺序表和链表的区别</h4> 
<blockquote> 
 <p>顺序表和链表是两种不同的数据结构。他们各有各的优劣。我们就来对比分析一下他们的区别。我们这里用带头双向循环链表和顺序表做对比。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/b6/7a/s15T2Iud_o.png" alt=""></p> 
<ul><li>存储空间<br> 顺序表：物理上是连续的。<br> 链表：因为链表是由节点组成，每个节点由指针连接。 所以在逻辑上是连续的，但每个节点都是malloc动态开辟的，在物理空间上不一定连续。<br> <img src="https://images2.imgbox.com/88/70/D4jQsmHP_o.png" alt=""></li><li>随机访问<br> 顺序表：顺序表可以通过下标来进行随机访问。<br> 链表：链表不支持随机访问，只能从头节点开始遍历寻找节点。<br> <img src="https://images2.imgbox.com/32/3f/DAowKAhF_o.png" alt=""></li><li>任意位置插入删除<br> 顺序表：如果不是尾插尾删，需要挪动数据。<br> 链表：链表由节点组成，插入或删除只需要修改前后节点的指针指向即可。<br> <img src="https://images2.imgbox.com/25/3a/gBp9d1rt_o.png" alt=""></li><li>扩容<br> 顺序表：空间不够需要扩容。<br> 扩容realloc本身会有消耗且异地扩容消耗不小，2倍扩容可能存在空间浪费。<br> 链表：按需申请释放，需要一个申请一个，不存在扩容，不会浪费空间。</li></ul> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_CRT_SECURE_NO_WARNINGS</span> <span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">realloc</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p"</span><span class="token punctuation">,</span> p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>异地扩容：<img src="https://images2.imgbox.com/16/fb/r0TJt1No_o.png" alt=""><br> 只要空间大一点，基本都是异地扩容。<br> 原地扩容：<br> <img src="https://images2.imgbox.com/84/4d/dbREUb9P_o.png" alt=""></p> 
<ul><li>应用场景</li></ul> 
<blockquote> 
 <p>顺序表和链表的优劣是互补的。<br> 顺序表适合随机访问，不适合中间位置的插入删除。<br> 链表适合任意位置的插入删除，但无法随机访问。<br> 所以如果经常随机访问，但只需要尾插尾删就选择顺序表。<br> 如果不经常随机访问，在中间位置插入删除就选择链表。<br> 具体根据他们的优劣进行选择。</p> 
</blockquote> 
<h4><a id="12_70"></a>1.2缓存利用率（缓存命中率）</h4> 
<blockquote> 
 <p>顺序表和链表的区别还有一个就是<br> 顺序表的缓存命中率高。<br> 链表的缓存命中率低。</p> 
</blockquote> 
<p>为什么呢?什么是缓存命中率呢?</p> 
<ul><li>内存和硬盘<br> <img src="https://images2.imgbox.com/67/bc/KJQm5hxp_o.png" alt=""></li></ul> 
<p>这是我们计算机的内部的存储结构。<br> 主存也就是我们的内存和硬盘的区别就是</p> 
<blockquote> 
 <p>内存的存储空间更小，通常为8G和16G,但速度快。需要带电存储<br> 硬盘存储空间更大，速度慢，但不需要带电存储。<br> 他们的本质是带不带电。</p> 
</blockquote> 
<p>例如：</p> 
<blockquote> 
 <p>如果我正在写一份ppt，因为硬盘的速度慢，所以是存在内存中的，如果我这时电脑突然没电关机。重新开机后，我的ppt就不见了。因为我没有另存到硬盘中。<br> 只用当我们另存到硬盘中才存在。</p> 
</blockquote> 
<ul><li>寄存器和三级缓存<br> 那既然已经有内存，内存的速度也还行，为什么还有寄存器和三级缓存呢？</li></ul> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_CRT_SECURE_NO_WARNINGS</span> <span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> ret <span class="token operator">=</span> i<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>以这段代码为例：</p> 
<blockquote> 
 <p>i存在内存中，也就是main函数的栈帧里。i++的执行过程是这样的：<br> 先把i放在eax寄存器中，<br> 对eax++,<br> 把eax寄存器放i的内存位置</p> 
</blockquote> 
<p>那为什么要这样做呢？<br> 因为CPU和内存不同频，CPU跑的太快了。<br> 如果直接访问内存数据进行++,因为内存太慢了。<br> 他宁愿把内存中数据加载到寄存器中，CPU在寄存器执行指令，再把运行结果返回内存。</p> 
<p>一般来说，CPU不会直接访问内存</p> 
<ul><li> <p>寄存器<br> 如果数据比较小(4或8字节)就会把数据加载到寄存器。</p> </li><li> <p>缓存<br> 如果数据比较大就加载到缓存中。</p> </li></ul> 
<blockquote> 
 <p>缓存命中：如果要访问的数据在缓存，叫缓存命中，直接访问。<br> 缓存不命中，如果要访问的数据不在缓存，叫缓存不命中，先把数据加载到缓存中，再访问。</p> 
</blockquote> 
<ul><li>缓存的加载<br> 如果你要加载4个字节到缓存，通常会加载一长段空间到缓存中。而不只是4个字节。为什么呢？</li></ul> 
<p>把内存看作学校，缓存看作大巴，CPU看作度假村。<br> 现在学校安排大巴把学生(数据)送到度假村去。<br> <img src="https://images2.imgbox.com/b9/38/r2boYYWu_o.png" alt=""></p> 
<p>所以顺序表的缓存命中率高，<br> 链表的缓存命中率低，而且会造成缓存污染。<br> 如果大家想多了解缓存的话可以看这篇文章<br> <a href="https://coolshell.cn/articles/20793.html" rel="nofollow">与程序员相关的CPU缓存知识</a></p> 
<h3><a id="_142"></a>二.链表的带环问题</h3> 
<blockquote> 
 <p>链表带环是链表中的经典问题，值得我们深入学习。解决带环问题通常使用快慢指针相遇解决。但是你如何证明快慢指针一定相遇，以及快指针的步长不同会怎样呢？接下来，小编带大家一一探讨。</p> 
</blockquote> 
<h4><a id="21_146"></a>2.1快慢指针</h4> 
<ul><li>题目<br> <a href="https://leetcode.cn/problems/linked-list-cycle/description/" rel="nofollow">环形链表</a></li></ul> 
<p><img src="https://images2.imgbox.com/fe/48/4MulNmtG_o.png" alt=""></p> 
<ul><li>思路<br> 创建一个快指针和一个慢指针，快指针一次走两步，慢指针一次走一步。<br> 如果是链表带环，快慢指针最终会相遇。不带环，则快指针走到尾。</li><li>代码实现</li></ul> 
<pre><code class="prism language-c"> <span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">ListNode</span> ListNode<span class="token punctuation">;</span> 
bool <span class="token function">hasCycle</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ListNode</span> <span class="token operator">*</span>head<span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span>
    ListNode<span class="token operator">*</span>slow<span class="token punctuation">,</span><span class="token operator">*</span>fast<span class="token punctuation">;</span>
    slow<span class="token operator">=</span>fast<span class="token operator">=</span>head<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token operator">&amp;&amp;</span>fast<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        slow<span class="token operator">=</span>slow<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span><span class="token comment">//慢指针走一步</span>
        fast<span class="token operator">=</span>fast<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span><span class="token comment">//快指针走两步</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>fast<span class="token operator">==</span>slow<span class="token punctuation">)</span><span class="token comment">//快慢指针相遇</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> true<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token comment">//不带环</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="22_180"></a>2.2证明快慢指针相遇问题</h4> 
<p>那如何证明题目一定会相遇呢？<br> <img src="https://images2.imgbox.com/e8/e8/jd8lfGeA_o.png" alt=""><br> 当慢指针入环时，快指针与慢指针相差N个节点。<br> 由于快指针每次走两步，慢指针走一步。<br> 每次移动快指针都会与慢指针的距离缩小一个节点。<br> 当他们的距离节点缩小为0时，就会相遇。<br> 所以快慢指针一定能够相遇。</p> 
<h4><a id="23_188"></a>2.3快指针的步长</h4> 
<p>那快指针是不是只能走一步呢？如果快指针走3，4，5…N步还一定能相遇吗？</p> 
<ul><li>步长为3时<br> 证明结果如下<br> <img src="https://images2.imgbox.com/76/37/HolQlkGo_o.png" alt=""></li></ul> 
<p>我们用快慢指针步长的关系列出等式，反推证明N为奇数和C为偶数的情况不会出现，从而得出结论步长为3时一定能相遇。</p> 
<ul><li> <p>验证<br> <img src="https://images2.imgbox.com/79/72/zYJbaB9S_o.png" alt=""></p> </li><li> <p>步长为3，4，5…N<br> 这些情况和前面的推导证明过程相似，大家有兴趣可以自己深入探究。</p> </li></ul> 
<h4><a id="24_203"></a>2.4环的入口</h4> 
<ul><li> <p>题目<br> <a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/" rel="nofollow">环形链表二</a> <img src="https://images2.imgbox.com/7b/4a/9mGU7hZx_o.png" alt=""></p> </li><li> <p>思路<br> 创建一个快指针和一个慢指针，快指针一次走两步，慢指针一次走一步。<br> 如果是链表带环，快慢指针最终会相遇。<br> 一个指针相遇点开始走，一个指针从头节点开始走，每次两个指针都走一步。<br> 当两个指针相遇时，相遇节点就是入环节点。<br> 不带环，则快指针走到尾。</p> </li><li> <p>代码实现</p> </li></ul> 
<pre><code class="prism language-c"> <span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">ListNode</span> ListNode <span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">ListNode</span> <span class="token operator">*</span><span class="token function">detectCycle</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ListNode</span> <span class="token operator">*</span>head<span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span>
    ListNode<span class="token operator">*</span>slow<span class="token punctuation">,</span><span class="token operator">*</span>fast<span class="token punctuation">;</span>
    slow<span class="token operator">=</span>fast<span class="token operator">=</span>head<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token operator">&amp;&amp;</span>fast<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        fast<span class="token operator">=</span>fast<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        slow<span class="token operator">=</span>slow<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>slow<span class="token operator">==</span>fast<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            ListNode<span class="token operator">*</span> pcur<span class="token operator">=</span>slow<span class="token punctuation">;</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>pcur<span class="token operator">!=</span>head<span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                pcur<span class="token operator">=</span>pcur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
                head<span class="token operator">=</span>head<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> pcur<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>证明</li></ul> 
<p>具体证明过程如下：</p> 
<p><img src="https://images2.imgbox.com/97/d4/ZeygRCB7_o.png" alt=""></p> 
<ul><li>验证<br> -<img src="https://images2.imgbox.com/17/dd/3pTjvdWH_o.png" alt="在这里插入图片描述"></li></ul> 
<p>所以根据推导我们得出只要再相遇后，一个head指针从头节点出发，一个pcur节点从相遇点出发，等他们相遇时，相遇点就是入环点。</p> 
<h3><a id="_255"></a>后言</h3> 
<blockquote> 
 <p>这就是链表的带环问题和顺序表链表的对比。这些都是我们数据结构学习时的重要内容。大家一定要好好掌握。今天就分享到这里，咱们下期见！拜拜~<br> <img src="https://images2.imgbox.com/03/84/fugreo9H_o.gif" alt="在这里插入图片描述"></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7a726d694fec9a34a90bfbe3c3e78af7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【C语言】 —— 编译和链接</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7295d852720963ecd19a9e2eefb33a93/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">day01：项目概述，环境搭建</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>