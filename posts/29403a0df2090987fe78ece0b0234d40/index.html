<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[Algorithm][动态规划][动态规划原理][整体理解]详细讲解 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/29403a0df2090987fe78ece0b0234d40/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="[Algorithm][动态规划][动态规划原理][整体理解]详细讲解">
  <meta property="og:description" content="目录 0.前言1.动态规划一般思路2.状态表示如何来？3.状态转移方程如何推导？4.处理边界问题以及初始化问题的技巧5.空间优化思路6.子序列 vs 子数组 0.前言 本节非常重要哦，有关后面动态规划题的总体理解建议和后面的题搭配起来食用哦~ 1.动态规划一般思路 创建dp表 可能是一维数组，也可能是二维数组 确定状态表示 -&gt; dp[i]的含义推导状态转移方程 -&gt; dp[i] = ? 用之前或之后的值，推导出dp[i]的值根据最近的一步，来划分问题 初始化：保证填表的时候不越界确定填表顺序：为了保证填写当前状态的时候，所需要的状态已经计算过了确定返回值 题目要求 &#43; 状态标识 2.状态表示如何来？ 题目要求经验 &#43; 题目要求 一维线性dp 以i位置为结尾以i位置为起点 分析问题的过程中，发现重复子问题 3.状态转移方程如何推导？ 简单问题可以直接写出状态转移方程复杂问题，多个状态时，可以画图表示各个状态的关系，最后对着关系机写出状态转移方程
4.处理边界问题以及初始化问题的技巧 虚拟结点如何开？
一维：dp表多开一位
注意事项： 虚拟节点里面的值，要保证后面填表时是正确的下标的映射关系
二维：dp表多开一行和一列
注意事项： 虚拟节点里面的值，要保证后面填表时是正确的下标的映射关系
算法里面初始化为无穷：INT_MAX || INT_MIN时，要注意潜在的溢出风险
替换为0x3f3f3f3f || -0x3f3f3f3f即可解决该问题首先它足够大，其次它没有溢出风险 多个状态方程，其中只有一部分的状态方程需要特殊的初始化，那么可以想办法把这个状态方程拆成多步，分步执行，尝试避免特殊处理初始化
根据实际情况，可以考虑将dp表中的值，都初始化为最次的情况
这样处理或许可以省去一些步骤 关于字符串dp问题，空串是有研究意义的
引入空串后，会方便初始化倘若在dp表中加入了虚拟结点，那么可以在初始化时，在源字符串前面加上&#39; &#39; 这是为了确保字符串下标正确，避免在字符串中找子串时不必要的麻烦 5.空间优化思路 优化方法： 滚动数组 优化效果： O ( N 2 ) − &gt; O ( N ) O(N^2) -&gt; O(N) O(N2)−&gt;O(N) O ( N ) − &gt; O ( 1 ) O(N) -&gt; O(1) O(N)−&gt;O(1) 6.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-22T00:04:38+08:00">
    <meta property="article:modified_time" content="2024-05-22T00:04:38+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[Algorithm][动态规划][动态规划原理][整体理解]详细讲解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#0_3" rel="nofollow">0.前言</a></li><li><a href="#1_7" rel="nofollow">1.动态规划一般思路</a></li><li><a href="#2_21" rel="nofollow">2.状态表示如何来？</a></li><li><a href="#3_31" rel="nofollow">3.状态转移方程如何推导？</a></li><li><a href="#4_39" rel="nofollow">4.处理边界问题以及初始化问题的技巧</a></li><li><a href="#5_66" rel="nofollow">5.空间优化思路</a></li><li><a href="#6_vs__75" rel="nofollow">6.子序列 vs 子数组</a></li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="0_3"></a>0.前言</h2> 
<ul><li><font color="red"><strong>本节非常重要哦，有关后面动态规划题的总体理解</strong></font></li><li><font color="red"><strong>建议和后面的题搭配起来食用哦~</strong></font></li></ul> 
<hr> 
<h2><a id="1_7"></a>1.动态规划一般思路</h2> 
<ul><li><strong>创建<code>dp</code>表</strong> 
  <ul><li>可能是一维数组，也可能是二维数组</li></ul> </li><li>确定<strong>状态表示</strong> -&gt; <code>dp[i]</code>的含义</li><li>推导<strong>状态转移方程</strong> -&gt; <code>dp[i] = ?</code> 
  <ul><li>用之前或之后的值，推导出<code>dp[i]</code>的值</li><li>根据最近的一步，来划分问题</li></ul> </li><li><strong>初始化</strong>：保证填表的时候不越界</li><li><strong>确定填表顺序</strong>：为了保证填写当前状态的时候，所需要的状态已经计算过了</li><li><strong>确定返回值</strong> 
  <ul><li>题目要求 + 状态标识</li></ul> </li></ul> 
<hr> 
<h2><a id="2_21"></a>2.状态表示如何来？</h2> 
<ul><li>题目要求</li><li>经验 + 题目要求 
  <ul><li>一维线性<code>dp</code> 
    <ul><li>以<code>i</code>位置为结尾</li><li>以<code>i</code>位置为起点</li></ul> </li></ul> </li><li>分析问题的过程中，发现重复子问题</li></ul> 
<hr> 
<h2><a id="3_31"></a>3.状态转移方程如何推导？</h2> 
<ul><li>简单问题可以直接写出状态转移方程</li><li>复杂问题，多个状态时，可以画图表示各个状态的关系，最后对着<strong>关系机</strong>写出状态转移方程<br> <img src="https://images2.imgbox.com/b4/a8/ArstWghK_o.png" alt="请添加图片描述"></li></ul> 
<hr> 
<h2><a id="4_39"></a>4.处理边界问题以及初始化问题的技巧</h2> 
<ul><li> <p><font color="blue"><strong>虚拟结点如何开？</strong></font></p> 
  <ul><li> <p><strong>一维</strong>：<code>dp</code>表多开一位</p> 
    <ul><li><strong>注意事项</strong>： 
      <ul><li>虚拟节点里面的值，要保证后面填表时是正确的</li><li>下标的映射关系<br> <img src="https://images2.imgbox.com/ff/bc/5LSmF79G_o.png" alt="请添加图片描述"></li></ul> </li></ul> </li><li> <p><strong>二维</strong>：<code>dp</code>表多开一行和一列</p> 
    <ul><li><strong>注意事项</strong>： 
      <ul><li>虚拟节点里面的值，要保证后面填表时是正确的</li><li>下标的映射关系<br> <img src="https://images2.imgbox.com/52/5a/pC70WKMJ_o.png" alt="请添加图片描述"></li></ul> </li></ul> </li></ul> </li><li> <p><font color="orange"><strong>算法里面初始化为无穷：<code>INT_MAX || INT_MIN</code>时，要注意潜在的溢出风险</strong></font></p> 
  <ul><li>替换为<code>0x3f3f3f3f || -0x3f3f3f3f</code>即可解决该问题</li><li><strong>首先它足够大，其次它没有溢出风险</strong></li></ul> </li><li> <p><font color="purple"><strong>多个状态方程，其中只有一部分的状态方程需要特殊的初始化，那么可以想办法把这个状态方程拆成多步，分步执行，尝试避免特殊处理初始化</strong></font></p> </li><li> <p>根据实际情况，可以考虑将dp表中的值，都初始化为<strong>最次</strong>的情况</p> 
  <ul><li>这样处理<strong>或许</strong>可以省去一些步骤</li></ul> </li><li> <p><strong>关于字符串dp问题，空串是有研究意义的</strong></p> 
  <ul><li>引入空串后，会方便初始化</li><li>倘若在<code>dp</code>表中加入了虚拟结点，那么可以在初始化时，在源字符串前面加上<code>' '</code> 
    <ul><li>这是为了确保字符串下标正确，避免在字符串中找子串时不必要的麻烦</li></ul> </li></ul> </li></ul> 
<hr> 
<h2><a id="5_66"></a>5.空间优化思路</h2> 
<ul><li><strong>优化方法</strong>： 
  <ul><li><strong>滚动数组</strong></li></ul> </li><li><strong>优化效果</strong>： 
  <ul><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            O 
           
          
            ( 
           
           
           
             N 
            
           
             2 
            
           
          
            ) 
           
          
            − 
           
          
            &gt; 
           
          
            O 
           
          
            ( 
           
          
            N 
           
          
            ) 
           
          
         
           O(N^2) -&gt; O(N) 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">−</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="mclose">)</span></span></span></span></span></li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            O 
           
          
            ( 
           
          
            N 
           
          
            ) 
           
          
            − 
           
          
            &gt; 
           
          
            O 
           
          
            ( 
           
          
            1 
           
          
            ) 
           
          
         
           O(N) -&gt; O(1) 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="mclose">)</span><span class="mord">−</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></li></ul> </li></ul> 
<hr> 
<h2><a id="6_vs__75"></a>6.子序列 vs 子数组</h2> 
<ul><li><strong>子序列</strong>： 
  <ul><li><strong>相对顺序</strong>是跟源字符串/数组是一致的</li><li>但是元素和元素之间，在源字符串/数组中<strong>可以是不连续的</strong></li><li>一般时间复杂度：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            O 
           
          
            ( 
           
           
           
             2 
            
           
             n 
            
           
          
            ) 
           
          
         
           O(2^n) 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.6644em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></li></ul> </li><li><strong>子数组</strong>： 
  <ul><li>在源字符串/数组中挑出来，<strong>必须是连续的</strong></li><li>一般时间复杂度：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            O 
           
          
            ( 
           
           
           
             N 
            
           
             2 
            
           
          
            ) 
           
          
         
           O(N^2) 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></li></ul> </li><li><font color="red"><strong>子序列其实相当于包含了子数组</strong></font></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e9908708dd27c7a84f5b7fb63e0438cd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">正在进行：微软Build 2024大会宣布的Team Copilot：你的会议助手</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f8b79a3ba1c603b89c6c5d70fb99dbfc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MongoDB白皮书｜应用程序驱动型智能：定义下一代成功的现代应用程序</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>