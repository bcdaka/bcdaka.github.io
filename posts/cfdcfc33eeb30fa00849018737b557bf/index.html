<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Java】了解线程 Thread 类的使用，如何创建、终止、等待一个线程以及获取线程的状态 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/cfdcfc33eeb30fa00849018737b557bf/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【Java】了解线程 Thread 类的使用，如何创建、终止、等待一个线程以及获取线程的状态">
  <meta property="og:description" content="线程是什么 线程是操作系统中调度的基本单位，是比进程更小的执行单元。线程在进程内部运行，共享该进程的资源，如内存和文件句柄，但每个线程都有自己的执行栈和程序计数器。
线程的主要特点包括：
轻量级：线程相较于进程更加轻量，创建和销毁的开销较小。共享资源：同一进程中的线程共享该进程的内存空间和资源，从而可以更高效地进行数据交换。并发执行：多个线程可以并发执行，充分利用多核处理器，提高程序的执行效率。简化管理：线程的切换和管理相对于进程更为简单和迅速，有助于提升系统的响应速度。 线程的使用在现代操作系统中非常普遍，尤其是在需要高并发和高性能的应用场景中，例如网络服务器和多任务应用程序等。
为什么要有线程 首先, &#34;并发编程&#34; 成为 &#34;刚需&#34;。
单核 CPU 的发展遇到了瓶颈. 要想提高算力, 就需要多核 CPU. 而并发编程能更充分利用多核 CPU资源。
有些任务场景需要 &#34;等待 IO&#34;, 为了让等待 IO 的时间能够去做一些其他的工作, 也需要用到并发编
程。
其次, 虽然多进程也能实现 并发编程, 但是线程比进程更轻量。
创建线程比创建进程更快.销毁线程比销毁进程更快.调度线程比调度进程更快. 创建出一个线程 在Java中，可以通过两种主要方式创建线程：继承Thread类和实现Runnable接口。下面分别介绍这两种方式，并附上代码示例。
方法一：继承 Thread 类 创建一个子类，继承Thread类，并重写run()方法，该方法包含了线程的执行代码。创建子类的实例，然后调用start()方法来启动线程。 示例代码：
class MyThread extends Thread { @Override public void run() { // 线程执行的代码 for (int i = 0; i &lt; 5; i&#43;&#43;) { System.out.println(&#34;Thread running: &#34; &#43; i); try { Thread.sleep(1000); // 暂停1秒 } catch (InterruptedException e) { e.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-24T19:42:37+08:00">
    <meta property="article:modified_time" content="2024-08-24T19:42:37+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Java】了解线程 Thread 类的使用，如何创建、终止、等待一个线程以及获取线程的状态</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>线程是什么</h2> 
<p>线程是操作系统中调度的基本单位，是比进程更小的执行单元。线程在进程内部运行，共享该进程的资源，如内存和文件句柄，但每个线程都有自己的执行栈和程序计数器。</p> 
<p>线程的主要特点包括：</p> 
<ol><li><strong>轻量级</strong>：线程相较于进程更加轻量，创建和销毁的开销较小。</li><li><strong>共享资源</strong>：同一进程中的线程共享该进程的内存空间和资源，从而可以更高效地进行数据交换。</li><li><strong>并发执行</strong>：多个线程可以并发执行，充分利用多核处理器，提高程序的执行效率。</li><li><strong>简化管理</strong>：线程的切换和管理相对于进程更为简单和迅速，有助于提升系统的响应速度。</li></ol> 
<p>线程的使用在现代操作系统中非常普遍，尤其是在需要高并发和高性能的应用场景中，例如网络服务器和多任务应用程序等。</p> 
<p></p> 
<h2>为什么要有线程</h2> 
<p><strong>首先, "并发编程" 成为 "刚需"。</strong></p> 
<p>单核 CPU 的发展遇到了瓶颈. 要想提高算力, 就需要多核 CPU. 而并发编程能更充分利用多核 CPU资源。<br> 有些任务场景需要 "等待 IO", 为了让等待 IO 的时间能够去做一些其他的工作, 也需要用到并发编<br> 程。</p> 
<p><strong>其次, 虽然多进程也能实现 并发编程, 但是线程比进程更轻量。</strong></p> 
<ul><li>创建线程比创建进程更快.</li><li>销毁线程比销毁进程更快.</li><li>调度线程比调度进程更快.</li></ul> 
<p></p> 
<h2>创建出一个线程</h2> 
<p>在Java中，可以通过两种主要方式创建线程：继承<code>Thread</code>类和实现<code>Runnable</code>接口。下面分别介绍这两种方式，并附上代码示例。</p> 
<h3 id="方法一：继承-thread-类">方法一：继承 <code>Thread</code> 类</h3> 
<ol><li><strong>创建一个子类</strong>，继承<code>Thread</code>类，并重写<code>run()</code>方法，该方法包含了线程的执行代码。</li><li><strong>创建子类的实例</strong>，然后调用<code>start()</code>方法来启动线程。</li></ol> 
<p id="示例代码：">示例代码：</p> 
<pre><code class="language-java">class MyThread extends Thread {
    @Override
    public void run() {
        // 线程执行的代码
        for (int i = 0; i &lt; 5; i++) {
            System.out.println("Thread running: " + i);
            try {
                Thread.sleep(1000); // 暂停1秒
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

public class ThreadExample {
    public static void main(String[] args) {
        Thread thread = new MyThread(); // 创建线程对象
        thread.start(); // 启动线程
    }
}
</code></pre> 
<p></p> 
<h3 id="方法二：实现-runnable-接口">方法二：实现 <code>Runnable</code> 接口</h3> 
<ol><li><strong>创建一个类</strong>，实现<code>Runnable</code>接口，并实现<code>run()</code>方法。</li><li><strong>创建<code>Runnable</code>接口的实例</strong>，将其传递给<code>Thread</code>构造函数，然后调用<code>start()</code>方法启动线程。</li></ol> 
<p id="示例代码：-1">示例代码：</p> 
<pre><code class="language-java">class MyRunnable implements Runnable {
    @Override
    public void run() {
        // 线程执行的代码
        for (int i = 0; i &lt; 5; i++) {
            System.out.println("Runnable thread running: " + i);
            try {
                Thread.sleep(1000); // 暂停1秒
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

public class RunnableExample {
    public static void main(String[] args) {
        MyRunnable myRunnable = new MyRunnable(); // 创建Runnable实例
        Thread thread = new Thread(myRunnable); // 将Runnable实例传递给Thread
        thread.start(); // 启动线程
    }
}
</code></pre> 
<p id="解析：">解析：</p> 
<ul><li>在这两个示例中，我们创建了一个简单的线程，该线程在运行时每秒打印一次数字（0到4）。</li><li>使用<code>Thread.sleep(1000)</code>使线程暂停1秒，这样可以模拟一些耗时的操作，也使得输出不至于淹没在快速的执行中。</li><li>调用<code>start()</code>方法时，Java虚拟机会调用线程的<code>run()</code>方法，而不是直接调用<code>run()</code>。这保证了线程的正确启动和管理。</li></ul> 
<p id="总结：">总结：</p> 
<p>通过这两种方式，Java允许灵活地创建和管理线程，开发者可以根据具体需求选择适合的方式。继承<code>Thread</code>类比较直接，但实现<code>Runnable</code>接口则可以实现更灵活的线程管理和资源共享。</p> 
<p></p> 
<h3>引入匿名内部类和 Lambda 简化上述方法</h3> 
<h4>匿名内部类</h4> 
<p><strong>方法一</strong></p> 
<pre><code class="language-java">public class ThreadExample {
    public static void main(String[] args) {
        Thread thread = new Thread() {
            // 线程执行的代码
            @Override
            public void run() {
                // 线程执行的代码
                for (int i = 0; i &lt; 5; i++) {
                    System.out.println("Runnable thread running: " + i);
                    try {
                        Thread.sleep(1000); // 暂停1秒
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        };

        thread.start();
    }
}</code></pre> 
<p>方法二</p> 
<pre><code class="language-java">public class ThreadExample {
    public static void main(String[] args) {
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                // 线程执行的代码
                for (int i = 0; i &lt; 5; i++) {
                    System.out.println("Runnable thread running: " + i);
                    try {
                        Thread.sleep(1000); // 暂停1秒
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        });

        thread.start();
    }
}</code></pre> 
<h4>   Lambda 表达式</h4> 
<pre><code class="language-java">public class ThreadExample {
    public static void main(String[] args) {
        Thread thread = new Thread(() -&gt; {
            // 线程执行的代码
            for (int i = 0; i &lt; 5; i++) {
                System.out.println("Runnable thread running: " + i);
                try {
                    Thread.sleep(1000); // 暂停1秒
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        thread.start();
    }
}</code></pre> 
<p>Lambda 表达式由于简洁，所以是日常开发中常用的方法。</p> 
<p></p> 
<h2>查看线程</h2> 
<p>当我们创建好一个线程后如何查看线程的状态呢？</p> 
<p><strong>使用 jconsole 命令观察线程</strong></p> 
<p>我们打开 jdk 文件夹所在目录，找到 bin 文件夹。</p> 
<p><img alt="" height="1011" src="https://images2.imgbox.com/f8/59/vL9Y5ndo_o.png" width="1200"></p> 
<p>找到 <strong>jconsole.exe </strong>双击打开。</p> 
<p> <img alt="" height="1011" src="https://images2.imgbox.com/ba/8f/cnwxY6BM_o.png" width="1200"></p> 
<p> 选择我们的类名的选项，点击连接。</p> 
<p><img alt="" height="741" src="https://images2.imgbox.com/0d/7c/gUs2L9mN_o.png" width="882"></p> 
<p> 连接好了后，选择线程，然后找到 Thread-0 这个就是我们手动创建的线程，我们可以查看该线程的运行情况。</p> 
<p><img alt="" height="741" src="https://images2.imgbox.com/1c/d4/E5oiK0lp_o.png" width="882"></p> 
<p></p> 
<h2> Thread 中常见的方法</h2> 
<p><code>Thread</code>类是Java中用于创建和管理线程的重要类，提供了多种方法来控制线程的行为和状态。以下是一些常见的<code>Thread</code>类方法：</p> 
<ol><li> <p>**<code>start()</code>**：启动线程，JVM会调用线程的<code>run()</code>方法。</p> </li><li> <p>**<code>run()</code>**：线程执行的代码逻辑所在的方法。可以被重写来定义线程的任务。</p> </li><li> <p>**<code>sleep(long millis)</code>**：使当前线程暂停指定的时间（毫秒），在此期间线程不会执行。</p> </li><li> <p>**<code>join()</code>**：等待调用该方法的线程完成后再继续执行。这是实现线程间的同步的一种方式。</p> </li><li> <p>**<code>interrupt()</code>**：中断线程，设置线程的中断状态。如果该线程正在阻塞（例如在<code>sleep()</code>或<code>wait()</code>中），则会抛出<code>InterruptedException</code>。</p> </li><li> <p>**<code>isAlive()</code>**：判断线程是否仍在运行中，返回<code>true</code>表示线程处于活动状态。</p> </li><li> <p>**<code>getName()</code>**：返回线程的名称。</p> </li><li> <p>**<code>setName(String name)</code>**：设置线程的名称。</p> </li><li> <p>**<code>getPriority()</code>**：返回线程的优先级。</p> </li><li> <p>**<code>setPriority(int priority)</code>**：设置线程的优先级，优先级范围为<code>Thread.MIN_PRIORITY</code>（1）到<code>Thread.MAX_PRIORITY</code>（10）。</p> </li><li> <p>**<code>yield()</code>**：提示调度器当前线程愿意让出对 CPU 的占用，由其他同等或更高优先级的线程获得执行机会。</p> </li><li> <p>**<code>currentThread()</code>**：静态方法，返回对当前正在执行的线程对象的引用。</p> </li></ol> 
<p id="示例："><strong>示例：</strong></p> 
<p>以下是一个简单的代码示例，演示了部分常见方法的用法：</p> 
<pre><code class="language-java">class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println(getName() + " is running");
        try {
            sleep(1000); // 暂停1秒
        } catch (InterruptedException e) {
            System.out.println(getName() + " was interrupted");
        }
        System.out.println(getName() + " has finished running");
    }
}

public class ThreadMethodsExample {
    public static void main(String[] args) {
        MyThread thread1 = new MyThread();
        MyThread thread2 = new MyThread();
        
        thread1.setName("Thread-1");
        thread2.setName("Thread-2");
        
        thread1.start();
        thread2.start();

        try {
            thread1.join(); // 等待thread1完成
            thread2.join(); // 等待thread2完成
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        
        System.out.println("All threads have finished executing.");
    }
}
</code></pre> 
<p>在这个示例中，我们创建了两个线程，设置了它们的名称，并演示了<code>start()</code>、<code>sleep()</code>和<code>join()</code>方法的使用。</p> 
<p></p> 
<h2>如何中断一个线程</h2> 
<p>在Java中，手动中断一个线程的原理主要依赖于线程的 <code>interrupt()</code> 方法和线程的 <code>isInterrupted()</code> 状态。通过调用一个线程的 <code>interrupt()</code> 方法，可以设置该线程的中断状态为 <code>true</code>。这通常用于通知线程它应该停止当前的工作，并进行清理或其他的收尾操作。</p> 
<p>当一个线程被中断后，如果该线程在阻塞状态（例如，等待输入、休眠等），则会抛出 <code>InterruptedException</code>。如果线程在其他执行状态中，通常需要在合适的位置检查该线程的中断状态，决定是否需要停止执行。</p> 
<p>以下是一个简单的案例，展示如何手动中断一个线程：</p> 
<p id="示例代码">示例代码</p> 
<pre><code class="language-java">class MyRunnable implements Runnable {
    @Override
    public void run() {
        try {
            System.out.println("线程开始工作...");
            // 模拟长时间工作的情况
            for (int i = 0; i &lt; 10; i++) {
                // 检查线程是否被中断
                if (Thread.currentThread().isInterrupted()) {
                    System.out.println("线程被中断，退出工作...");
                    return; // 退出运行
                }
                System.out.println("工作中: " + i);
                // 模拟工作过程中的延时
                Thread.sleep(1000);
            }
        } catch (InterruptedException e) {
            // 如果线程因为sleep被中断，会抛出InterruptedException
            System.out.println("线程被中断，捕获到异常: " + e.getMessage());
        } finally {
            System.out.println("线程清理工作，准备结束...");
        }
    }
}

public class ThreadInterruptExample {
    public static void main(String[] args) throws InterruptedException {
        Thread myThread = new Thread(new MyRunnable());
        myThread.start();

        // 主线程等待2秒，然后中断myThread
        Thread.sleep(2000);
        System.out.println("主线程请求中断myThread...");
        myThread.interrupt(); // 中断线程

        // 等待myThread结束
        myThread.join();
        System.out.println("主线程结束。");
    }
}
</code></pre> 
<p id="代码解释">代码解释</p> 
<ol><li><code>MyRunnable</code> 类实现 <code>Runnable</code> 接口并重写 <code>run()</code> 方法。</li><li>在 <code>run()</code> 方法中，模拟了一个长时间工作的循环，每次循环检查线程的中断状态。</li><li>如果线程被中断，可以通过 <code>Thread.currentThread().isInterrupted()</code> 方法来检测，并通过返回来优雅地退出工作。</li><li>在主线程中，创建并启动一个新线程，等待2秒后调用 <code>interrupt()</code> 方法中断它。</li><li>如果在 <code>sleep()</code> 等待期间线程被中断，<code>InterruptedException</code> 将被抛出，因此可以在 <code>catch</code> 块中进行相应处理。</li><li>最后，使用 <code>join()</code> 等待 <code>myThread</code> 完成所有操作后再结束主线程。</li></ol> 
<p id="总结">总结</p> 
<p>通过这个案例，可以清晰地看到如何手动中断线程以及如何处理线程的中断状态。这种机制在多线程编程中非常重要，确保了线程可以在合适的时机响应中断请求，从而实现更好的资源管理和程序健壮性。</p> 
<p></p> 
<h2>join 等待一个线程</h2> 
<p>在Java中，等待一个线程的原理主要依赖于 <code>Thread</code> 类中的 <code>join()</code> 方法。调用 <code>join()</code> 方法可以使当前线程（即调用 <code>join()</code> 的线程）等待另一个线程完成执行。原理是通过线程的状态管理，使得调用 <code>join()</code> 的线程在被调用线程执行完之前不会继续执行，确保线程之间的执行顺序。</p> 
<p id="示例代码">示例代码</p> 
<p>下面是一个简单的案例，展示如何等待一个线程的完成：</p> 
<pre><code class="language-java">class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("线程 " + Thread.currentThread().getName() + " 开始工作...");
        try {
            // 模拟长时间的工作
            Thread.sleep(2000); // 休眠2秒
        } catch (InterruptedException e) {
            System.out.println("线程被中断: " + e.getMessage());
        }
        System.out.println("线程 " + Thread.currentThread().getName() + " 工作完成。");
    }
}

public class ThreadJoinExample {
    public static void main(String[] args) {
        Thread myThread = new Thread(new MyRunnable(), "MyThread");
        myThread.start(); // 启动线程

        try {
            System.out.println("主线程等待 " + myThread.getName() + " 完成...");
            myThread.join(); // 等待 myThread 完成
        } catch (InterruptedException e) {
            System.out.println("主线程被中断: " + e.getMessage());
        }

        System.out.println("主线程继续执行，已等待 " + myThread.getName() + " 完成。");
    }
}
</code></pre> 
<p id="代码解释">代码解释</p> 
<ol><li><strong>MyRunnable 类</strong>：实现 <code>Runnable</code> 接口并重写 <code>run()</code> 方法。在 <code>run()</code> 方法中，我们模拟了一个长时间的工作，使用 <code>Thread.sleep(2000)</code> 使线程休眠 2 秒。</li><li><strong>主类 ThreadJoinExample</strong>： 
  <ul><li>创建一个新的线程 <code>myThread</code>，并将 <code>MyRunnable</code> 实例作为参数传入。</li><li>启动线程 <code>myThread</code>，这会调用其 <code>run()</code> 方法。</li><li>在主线程中，调用 <code>myThread.join()</code>，这将使主线程等待 <code>myThread</code> 完成执行。</li><li>一旦 <code>myThread</code> 执行完成，主线程将继续执行，并打印出相应的信息。</li></ul></li></ol> 
<p id="总结">总结</p> 
<p>通过这个案例，可以看到如何使用 <code>join()</code> 方法来等待线程的完成。这样可以有效地控制线程的执行顺序，确保在某些操作完成后再进行后续处理。例如，在多个线程之间需要协调工作时，使用 <code>join()</code> 使得某些操作依赖于另一个线程的完成，可以减少潜在的竞争和数据不一致问题。这种机制在多线程编程中非常重要，特别是在任务依赖的场景下。</p> 
<p></p> 
<h2>获取线程的状态</h2> 
<p>在Java中，线程的状态主要有以下几种：</p> 
<ol><li><strong>NEW</strong>（新建）：当线程被创建但尚未开始运行时，处于此状态。</li><li><strong>RUNNABLE</strong>（可运行）：线程可以运行，也可能正在运行。这并不一定意味着线程正在执行，因为线程调度可能把该线程挂起。</li><li><strong>BLOCKED</strong>（阻塞）：线程在等待一个监视器锁时被阻塞，无法继续执行。</li><li><strong>WAITING</strong>（等待）：线程在等待另一个线程执行特定动作时进入此状态，如等待锁的释放。</li><li><strong>TIMED_WAITING</strong>（计时等待）：线程在等待特定时间段内的某个条件时进入此状态。</li><li><strong>TERMINATED</strong>（终止）：线程完成执行或因异常退出后进入此状态。</li></ol> 
<p id="如何获取线程状态">如何获取线程状态</p> 
<p>可以使用 <code>Thread</code> 类的 <code>getState()</code> 方法来获取线程的当前状态。下面是一个示例代码，展示了如何创建线程并获取其状态：</p> 
<pre><code class="language-java">public class ThreadStateExample {

    public static void main(String[] args) {
        Thread thread = new Thread(new MyRunnable());
        
        // 获取并打印状态：NEW
        System.out.println("Thread state after creation: " + thread.getState());
        
        thread.start();
        
        // 获取并打印状态：RUNNABLE
        System.out.println("Thread state after starting: " + thread.getState());
        
        try {
            // 主线程等待一段时间以确保子线程有机会运行
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // 获取并打印状态：TERMINATED
        System.out.println("Thread state after completion: " + thread.getState());
    }

    static class MyRunnable implements Runnable {
        @Override
        public void run() {
            // 子线程正在运行
            try {
                // 模拟一些工作
                Thread.sleep(200);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre> 
<p id="说明">说明</p> 
<ol><li><strong>创建线程</strong>：在创建 <code>Thread</code> 对象后，可以通过 <code>getState()</code> 获取其状态，初始状态为 <code>NEW</code>。</li><li><strong>启动线程</strong>：调用 <code>start()</code> 方法后，线程状态可能变为 <code>RUNNABLE</code>。</li><li><strong>等待</strong>：主线程通过 <code>sleep()</code> 方法等待，使子线程有机会执行。</li><li><strong>观察状态</strong>：通过 <code>getState()</code> 方法可以随时获取线程的状态。</li></ol> 
<p>这种方式能够有效地跟踪线程的状态变化，以便在多线程编程中进行调试和控制。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/30cee809c0fc1c84a49f7147b96126b3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">防患未然：构建AIGC时代下开发团队应对突发技术故障与危机的全面策略</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4aba29b68c835df9c4107914c12fc1a0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Mysql语句性能优化</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>