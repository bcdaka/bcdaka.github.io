<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【用Java学习数据结构系列】探索顺序表和链表的无尽秘密（附带练习唔）pro - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/936fba1a9dc3e815b432ee254b5d677b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【用Java学习数据结构系列】探索顺序表和链表的无尽秘密（附带练习唔）pro">
  <meta property="og:description" content="看到这句话的时候证明：此刻你我都在努力
加油陌生人
前言 今天给大家带来一篇有关Java顺序表和链表的文章，顺序表和链表我之前的专栏也是写过的，是用C语言实现的，也是模仿实现了顺序表和链表里的方法了。
下面是传送门：
顺序表：
你真的了解线性表中的顺序表了吗？（静态与动态顺序）-CSDN博客
链表：
数据结构对链表的初步认识（一）-CSDN博客
数据结构的带头，双向，循环链表来咯-CSDN博客
但是呢，学习了新语言Java那么就在用新语言在巩固一下了。
认识List Java中的List是java.util包下的一个接口，它是Collection接口的一个子接口，表示一个有序的集合，可以包含重复的元素。List接口提供了一些独特的方法来插入、访问、删除元素以及搜索列表中的元素。以下是List接口的一些关键特性和常用实现：
特性 有序性：List中的元素按照添加的顺序进行排序。允许重复：可以包含重复的元素。动态数组：大多数List实现（如ArrayList）使用动态数组来存储元素，这使得随机访问非常高效。 常用方法 add(E e)：向列表末尾添加一个元素。add(int index, E element)：在指定位置插入一个元素。remove(int index)：移除指定位置的元素并返回被移除的元素。remove(Object o)：移除列表中第一次出现的指定元素。get(int index)：返回指定位置的元素。set(int index, E element)：用指定元素替换列表中指定位置的元素。size()：返回列表中的元素数量。indexOf(Object o)：返回第一次出现的指定元素的索引。lastIndexOf(Object o)：返回最后一次出现的指定元素的索引。clear()：移除列表中的所有元素。 常用实现 ArrayList：基于动态数组实现，支持快速随机访问。但插入和删除操作可能需要数组复制，效率较低。LinkedList：基于双向链表实现，适合频繁的插入和删除操作。但随机访问效率较低。Vector：和ArrayList类似，但它是同步的。Stack：继承自Vector，实现栈的功能，后进先出（LIFO）。CopyOnWriteArrayList：线程安全的变体，在读多写少的场景下性能较好。 泛型 从Java 5开始，List接口支持泛型，允许开发者指定列表中元素的类型，提高类型安全。
使用场景 当你需要有序集合并且频繁进行随机访问时，选择ArrayList。当你需要频繁在列表中插入或删除元素，并且对随机访问的需求不高时，选择LinkedList。 注意事项 List的实现不是线程安全的。如果需要线程安全，可以使用Collections.synchronizedList()方法或CopyOnWriteArrayList。选择合适的List实现对于性能至关重要，因为不同的实现在不同的操作下表现不同。 List接口是Java集合框架中非常重要的一部分，合理选择和使用List可以提高程序的性能和可读性。
认识ArrayList（顺序表） 顺序表一个用数组实现的一个结构，他和数组不同的就是它是一个类，数组是一个引用类型，顺序表还扩展了一些方法
像增，删，查，改等是最基本的，还有一些其它方法，像List里的接口方法也实现了。
ArrayList是Java集合框架中的一种实现，属于List接口的实现类之一，同时也实现了RandomAccess接口，表明它支持快速的随机访问。
基本特性 基于数组：ArrayList内部使用一个动态数组（Object数组）来存储元素。动态扩容：当添加元素导致数组容量不足时，ArrayList会自动扩容，通常是将现有容量增加到原来的1.5倍（或根据需要调整）。允许空元素：可以包含null值。非同步：ArrayList不是线程安全的。 性能特点 随机访问：由于基于数组实现，ArrayList提供了快速的随机访问能力，即get(int index)操作的时间复杂度为O(1)。添加和删除：在列表末尾添加元素（add(E e)）是高效的，时间复杂度为O(1)。但是，如果需要在列表中间或开始位置添加或删除元素，可能需要移动其他元素以维持数组的连续性，这会导致时间复杂度为O(n)。 常用方法 代码演示：
import java.util.ArrayList; public class T { public static void main(String[] args) { ArrayList&lt;Integer&gt; arrayList1=new ArrayList&lt;&gt;(); //创建一个存储整数的顺序表 ArrayList&lt;Character&gt; arrayList2=new ArrayList&lt;&gt;(); //创建一个存储字符的顺序表 ArrayList&lt;String&gt; arrayList3=new ArrayList&lt;&gt;(); //创建一个存储字符串的顺序表 //给整形顺序表添加数据 arrayList1.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-07T13:44:04+08:00">
    <meta property="article:modified_time" content="2024-08-07T13:44:04+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【用Java学习数据结构系列】探索顺序表和链表的无尽秘密（附带练习唔）pro</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>看到这句话的时候证明：此刻你我都在努力</strong><br> <strong>加油陌生人</strong><br> <img src="https://images2.imgbox.com/76/34/6vyXuILi_o.png" alt="微信图片编辑_20240229212205.png"></p> 
<hr> 
<h3><a id="_7"></a>前言</h3> 
<p>今天给大家带来一篇有关Java顺序表和链表的文章，顺序表和链表我之前的专栏也是写过的，是用C语言实现的，也是模仿实现了顺序表和链表里的方法了。<br> <strong>下面是传送门：</strong><br> 顺序表：<br> <a href="http://t.csdnimg.cn/iBVMU" rel="nofollow">你真的了解线性表中的顺序表了吗？（静态与动态顺序）-CSDN博客</a><br> 链表：<br> <a href="http://t.csdnimg.cn/PjrLJ" rel="nofollow">数据结构对链表的初步认识（一）-CSDN博客</a><br> <a href="http://t.csdnimg.cn/dVGAR" rel="nofollow">数据结构的带头，双向，循环链表来咯-CSDN博客</a><br> 但是呢，学习了新语言Java那么就在用新语言在巩固一下了。</p> 
<hr> 
<h4><a id="List_19"></a>认识List</h4> 
<p>Java中的<code>List</code>是<code>java.util</code>包下的一个接口，它是<code>Collection</code>接口的一个子接口，表示一个有序的集合，可以包含重复的元素。<code>List</code>接口提供了一些独特的方法来插入、访问、删除元素以及搜索列表中的元素。以下是<code>List</code>接口的一些关键特性和常用实现：</p> 
<h6><a id="_21"></a>特性</h6> 
<ol><li><strong>有序性</strong>：<code>List</code>中的元素按照添加的顺序进行排序。</li><li><strong>允许重复</strong>：可以包含重复的元素。</li><li><strong>动态数组</strong>：大多数<code>List</code>实现（如<code>ArrayList</code>）使用动态数组来存储元素，这使得随机访问非常高效。</li></ol> 
<h6><a id="_26"></a>常用方法</h6> 
<ul><li><code>add(E e)</code>：向列表末尾添加一个元素。</li><li><code>add(int index, E element)</code>：在指定位置插入一个元素。</li><li><code>remove(int index)</code>：移除指定位置的元素并返回被移除的元素。</li><li><code>remove(Object o)</code>：移除列表中第一次出现的指定元素。</li><li><code>get(int index)</code>：返回指定位置的元素。</li><li><code>set(int index, E element)</code>：用指定元素替换列表中指定位置的元素。</li><li><code>size()</code>：返回列表中的元素数量。</li><li><code>indexOf(Object o)</code>：返回第一次出现的指定元素的索引。</li><li><code>lastIndexOf(Object o)</code>：返回最后一次出现的指定元素的索引。</li><li><code>clear()</code>：移除列表中的所有元素。</li></ul> 
<h6><a id="_38"></a>常用实现</h6> 
<ol><li><strong>ArrayList</strong>：基于动态数组实现，支持快速随机访问。但插入和删除操作可能需要数组复制，效率较低。</li><li><strong>LinkedList</strong>：基于双向链表实现，适合频繁的插入和删除操作。但随机访问效率较低。</li><li><strong>Vector</strong>：和<code>ArrayList</code>类似，但它是同步的。</li><li><strong>Stack</strong>：继承自<code>Vector</code>，实现栈的功能，后进先出（LIFO）。</li><li><strong>CopyOnWriteArrayList</strong>：线程安全的变体，在读多写少的场景下性能较好。</li></ol> 
<h6><a id="_45"></a>泛型</h6> 
<p>从Java 5开始，<code>List</code>接口支持泛型，允许开发者指定列表中元素的类型，提高类型安全。</p> 
<h6><a id="_47"></a>使用场景</h6> 
<ul><li>当你需要有序集合并且频繁进行随机访问时，选择<code>ArrayList</code>。</li><li>当你需要频繁在列表中插入或删除元素，并且对随机访问的需求不高时，选择<code>LinkedList</code>。</li></ul> 
<h6><a id="_51"></a>注意事项</h6> 
<ul><li><code>List</code>的实现不是线程安全的。如果需要线程安全，可以使用<code>Collections.synchronizedList()</code>方法或<code>CopyOnWriteArrayList</code>。</li><li>选择合适的<code>List</code>实现对于性能至关重要，因为不同的实现在不同的操作下表现不同。</li></ul> 
<p><code>List</code>接口是Java集合框架中非常重要的一部分，合理选择和使用<code>List</code>可以提高程序的性能和可读性。</p> 
<hr> 
<h4><a id="ArrayList_60"></a>认识ArrayList（顺序表）</h4> 
<p>顺序表一个用数组实现的一个结构，他和数组不同的就是它是一个类，数组是一个引用类型，顺序表还扩展了一些方法<br> 像增，删，查，改等是最基本的，还有一些其它方法，像List里的接口方法也实现了。<br> <code>ArrayList</code>是Java集合框架中的一种实现，属于<code>List</code>接口的实现类之一，同时也实现了<code>RandomAccess</code>接口，表明它支持快速的随机访问。</p> 
<h6><a id="_64"></a>基本特性</h6> 
<ol><li><strong>基于数组</strong>：<code>ArrayList</code>内部使用一个动态数组（<code>Object</code>数组）来存储元素。</li><li><strong>动态扩容</strong>：当添加元素导致数组容量不足时，<code>ArrayList</code>会自动扩容，通常是将现有容量增加到原来的1.5倍（或根据需要调整）。</li><li><strong>允许空元素</strong>：可以包含<code>null</code>值。</li><li><strong>非同步</strong>：<code>ArrayList</code>不是线程安全的。</li></ol> 
<h6><a id="_70"></a>性能特点</h6> 
<ol><li><strong>随机访问</strong>：由于基于数组实现，<code>ArrayList</code>提供了快速的随机访问能力，即<code>get(int index)</code>操作的时间复杂度为O(1)。</li><li><strong>添加和删除</strong>：在列表末尾添加元素（<code>add(E e)</code>）是高效的，时间复杂度为O(1)。但是，如果需要在列表中间或开始位置添加或删除元素，可能需要移动其他元素以维持数组的连续性，这会导致时间复杂度为O(n)。</li></ol> 
<h6><a id="_74"></a>常用方法</h6> 
<p>代码演示：</p> 
<pre><code>import java.util.ArrayList;

public class T {

    public static void main(String[] args) {
        ArrayList&lt;Integer&gt; arrayList1=new ArrayList&lt;&gt;();  //创建一个存储整数的顺序表
        ArrayList&lt;Character&gt; arrayList2=new ArrayList&lt;&gt;();  //创建一个存储字符的顺序表
        ArrayList&lt;String&gt; arrayList3=new ArrayList&lt;&gt;();   //创建一个存储字符串的顺序表

        //给整形顺序表添加数据
        arrayList1.add(1);
        arrayList1.add(2);
        arrayList1.add(3);

        //给字符顺序表添加数据
        arrayList2.add('a');
        arrayList2.add('b');
        arrayList2.add('c');

        //给字符串顺序表添加数据
        arrayList3.add("abc");
        arrayList3.add("abcd");
        arrayList3.add("abcde");

        //分别打印三个顺序表
        System.out.println(arrayList1.toString());
        System.out.println(arrayList2.toString());
        System.out.println(arrayList3.toString());

        //也可以单独取其中的元素进行打印
        //如下取每个顺序表第一个元素进行打印
        System.out.println(arrayList1.get(0));
        System.out.println(arrayList2.get(0));
        System.out.println(arrayList3.get(0));


    }
}
</code></pre> 
<p><img src="https://images2.imgbox.com/12/24/uRwIwJMk_o.png" alt="image.png"><br> 注：<strong>使用ArrayList前需先导入对应的包 ：import java.util.ArrayList;</strong></p> 
<p>上面代码中我只是简单使用了其中的几个方法，但是顺序表即：ArrayList类还自带许多方法呢。<br> <img src="https://images2.imgbox.com/11/76/mm0cWRJ5_o.png" alt="image.png"><img src="https://images2.imgbox.com/e1/46/VrdFJRza_o.png" alt="image.png"><br> 这张图的方法仅仅只是ArrayList中2/3的方法呢，所以ArrayList功能还是很强大的。</p> 
<p>顺序表之类的集合方法都有个非常厉害的功能，就是可以将另一个顺序表，一次性直接加入另一个顺序表。<br> 代码演示：</p> 
<pre><code>public class T {
    public static void main(String[] args) {

        ArrayList&lt;Integer&gt; arrayList1=new ArrayList&lt;&gt;();
        ArrayList&lt;Integer&gt; arrayList2=new ArrayList&lt;&gt;();

        //给arrayList1添加数据
        arrayList1.add(1);
        arrayList1.add(2);
        arrayList1.add(3);

        //给arrayList2添加数据
        arrayList2.add(4);
        arrayList2.add(5);
        arrayList2.add(6);


        arrayList1.addAll(arrayList2);
        System.out.println(arrayList1.toString());
        

    }
    }
</code></pre> 
<p><img src="https://images2.imgbox.com/03/42/PZdjbIXr_o.png" alt="image.png"><br> 这样是否见识到ArrayList的强大呢。<br> 除了继承自<code>Collection</code>和<code>List</code>接口的方法外，<code>ArrayList</code>还提供了一些特定方法：</p> 
<ol><li><code>ensureCapacity(int minCapacity)</code>：增加内部数组的容量至少为指定的最小容量，有助于减少扩容操作。</li><li><code>trimToSize()</code>：将内部数组的大小调整为当前元素的数量，释放多余的内存。</li><li>扩容机制</li></ol> 
<p>当<code>ArrayList</code>中的元素数量达到当前数组容量时，会进行扩容操作：</p> 
<ol><li>创建一个新的数组，容量为原数组的1.5倍（加上原数组容量）。</li><li>将原数组中的所有元素复制到新数组中。</li><li>用新数组替换原数组。</li></ol> 
<h6><a id="_163"></a>使用场景</h6> 
<ul><li>当你需要一个可以快速随机访问元素的集合时，<code>ArrayList</code>是一个好选择。</li><li>当元素的添加主要集中在列表末尾时，<code>ArrayList</code>的性能较好。</li></ul> 
<hr> 
<h4><a id="LinkedList_170"></a>认识LinkedList（链表）</h4> 
<p><strong>链表也是一个实现了List的一个类。它的功能和ArrayList比较相似，不同的是LinkedList是没有扩容机制的。</strong><br> <strong>且他们在某些地方插入数据的时间复杂度是不一样的。</strong><br> <code>LinkedList</code> 在 Java 中是一种实现了 <code>List</code> 和 <code>Deque</code> 接口的双向链表。<br> <strong><em>基本特性</em></strong><br> <strong>双向链表</strong>：<code>LinkedList</code> 中的每个元素都是一个节点，包含数据和两个指针，分别指向前一个和后一个节点。<br> <strong>动态数组</strong>：链表的长度可以根据需要动态增长或缩小。<br> <strong>非线程安全</strong>：<code>LinkedList</code> 默认不是线程安全的。如果需要线程安全，可以使用 <code>Collections.synchronizedList()</code> 方法或 <code>CopyOnWriteArrayList</code>。</p> 
<p><strong><em>内部结构</em></strong><br> <code>LinkedList</code> 的内部结构由 <code>Node</code> 内部类实现，每个 <code>Node</code> 对象包含：<br> <code>item</code>：存储数据。<br> <code>next</code>：指向下一个节点的引用。<br> <code>prev</code>：指向前一个节点的引用。</p> 
<p><strong><em>性能特点</em></strong><br> <strong>插入和删除</strong>：在列表的头部或尾部进行插入和删除操作非常高效（O(1)），因为不需要移动其他元素。在列表中间进行这些操作需要 O(n) 时间复杂度，因为需要遍历到特定位置。<br> <strong>随机访问</strong>：由于链表的非连续性，随机访问（通过索引获取元素）的时间复杂度为 O(n)，因为需要从头开始遍历链表。</p> 
<h6><a id="_189"></a>常用方法</h6> 
<p>代码演示：</p> 
<pre><code>import java.util.LinkedList;

public class T {

    public static void main(String[] args) {
        LinkedList&lt;Integer&gt; linkedList1=new LinkedList&lt;&gt;();//创建一个存储整数的链表
        LinkedList&lt;Character&gt; linkedList2=new LinkedList&lt;&gt;();//创建一个存储字符的链表
        LinkedList&lt;String&gt; linkedList3=new LinkedList&lt;&gt;();//创建一个存储字符串的链表


        //给整形顺序表添加数据
        linkedList1.add(1);
        linkedList1.add(2);
        linkedList1.add(3);


        //给字符顺序表添加数据
        linkedList2.add('a');
        linkedList2.add('b');
        linkedList2.add('c');


        //给字符串顺序表添加数据
        linkedList3.add("abc");
        linkedList3.add("abcd");
        linkedList3.add("abcde");

        //分别打印三个顺序表
        System.out.println(linkedList1.toString());
        System.out.println(linkedList2.toString());
        System.out.println(linkedList3.toString());

        //也可以单独取其中的元素进行打印
        //如下取每个顺序表第一个元素进行打印
        System.out.println(linkedList1.get(0));
        System.out.println(linkedList2.get(0));
        System.out.println(linkedList3.get(0));

    }

}
</code></pre> 
<p><img src="https://images2.imgbox.com/cd/f5/IlQvnE3I_o.png" alt="image.png"><br> 链表也是支持addall（）方法的，也是可以将一个链表添加到另一个链表。</p> 
<pre><code>import java.util.LinkedList;

public class T {

    public static void main(String[] args) {
        LinkedList&lt;Integer&gt; linkedList1=new LinkedList&lt;&gt;();
        LinkedList&lt;Integer&gt; linkedList2=new LinkedList&lt;&gt;();


        linkedList1.add(1);
        linkedList1.add(2);
        linkedList1.add(3);

        linkedList2.add(4);
        linkedList2.add(5);
        linkedList2.add(6);

        linkedList1.addAll(linkedList2);

        System.out.println(linkedList1.toString());
    }
    }
</code></pre> 
<p><img src="https://images2.imgbox.com/ba/09/spMQpVpG_o.png" alt="image.png"></p> 
<p>除了继承自 <code>List</code> 的方法外，<code>LinkedList</code> 还提供了以下特有方法：</p> 
<ol><li><code>addFirst(E e)</code> 和 <code>addLast(E e)</code>：在链表头部和尾部添加元素。</li><li><code>getFirst()</code> 和 <code>getLast()</code>：获取链表头部和尾部的元素。</li><li><code>removeFirst()</code> 和 <code>removeLast()</code>：移除链表头部和尾部的元素。</li><li><code>offerFirst(E e)</code>、<code>offerLast(E e)</code>、<code>pollFirst()</code> 和 <code>pollLast()</code>：这些方法提供了双端队列的功能。</li></ol> 
<h6><a id="_268"></a>使用场景</h6> 
<ol><li>当需要频繁地在列表的头部或尾部添加或删除元素时，<code>LinkedList</code> 是一个很好的选择。</li><li>当不需要频繁地进行随机访问时，<code>LinkedList</code> 可以提供比 <code>ArrayList</code> 更好的性能。</li></ol> 
<hr> 
<h4><a id="_275"></a>总结：</h4> 
<h6><a id="ArrayList_276"></a>顺序表（如ArrayList）</h6> 
<ol><li><strong>基于数组</strong>：顺序表使用数组来存储元素，元素在内存中连续存放。</li><li><strong>随机访问</strong>：支持快速的随机访问，即可以直接通过索引访问任意位置的元素（时间复杂度O(1)）。</li><li><strong>动态扩容</strong>：当元素数量超过数组容量时，需要进行扩容操作，这通常涉及到创建更大的数组并复制现有元素。</li><li><strong>插入和删除</strong>：在数组末尾添加元素非常快（时间复杂度O(1)），但在中间或开始位置插入或删除元素可能较慢，因为需要移动后续元素以维持连续性（时间复杂度O(n)）。</li><li><strong>内存使用</strong>：通常比链表更紧凑，因为不需要额外存储指向其他元素的引用。</li><li><strong>适用场景</strong>：适合于随机访问频繁的场景，以及在列表末尾添加元素的操作。</li></ol> 
<h6><a id="LinkedList_284"></a>链表（如LinkedList）</h6> 
<ol><li><strong>基于节点</strong>：链表由一系列节点组成，每个节点包含数据和指向下一个（及前一个，对于双向链表）节点的指针。</li><li><strong>非连续存储</strong>：元素在内存中可以是不连续的，通过指针连接。</li><li><strong>动态大小</strong>：大小可以动态变化，不需要预先分配大量内存。</li><li><strong>插入和删除</strong>：在已知前一个节点的情况下，可以在O(1)时间内完成，因为只需要改变几个指针。但在中间位置进行操作可能需要O(n)时间来找到前一个节点。</li><li><strong>随机访问</strong>：不支持高效的随机访问，访问特定位置的元素需要从头开始遍历（时间复杂度O(n)）。</li><li><strong>内存使用</strong>：每个节点需要额外存储至少一个（单向链表）或两个（双向链表）指针，因此内存使用相对较高。</li><li><strong>适用场景</strong>：适合于插入和删除操作频繁的场景，尤其是在列表中间，以及不需要频繁随机访问元素的应用。</li></ol> 
<h4><a id="_293"></a>总结</h4> 
<ul><li><strong>顺序表</strong>适合于需要快速随机访问元素的场景，以及主要在列表末尾添加元素的情况。</li><li><strong>链表</strong>适合于插入和删除操作频繁，尤其是在列表中间，且不经常进行随机访问的场景。</li></ul> 
<p>选择使用顺序表还是链表，取决于具体的应用需求和操作模式。理解它们的特点可以帮助开发者选择最合适的数据结构，以优化程序的性能。</p> 
<p><a href="https://leetcode.cn/problems/remove-linked-list-elements/" rel="nofollow">. - 力扣（LeetCode）</a>：给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 新的头节点 。<br> <a href="https://leetcode.cn/problems/reverse-linked-list/submissions/" rel="nofollow">. - 力扣（LeetCode）</a>：逆置单链表<br> <a href="https://leetcode.cn/problems/middle-of-the-linked-list/description/" rel="nofollow">. - 力扣（LeetCode）</a>：给你单链表的头结点 <code>head</code> ，请你找出并返回链表的中间结点。<br> 如果有两个中间结点，则返回第二个中间结点。<br> <a href="https://leetcode.cn/problems/pascals-triangle/" rel="nofollow">. - 力扣（LeetCode）</a>：给定一个非负整数 <code>numRows</code>，生成「杨辉三角」的前 <code>numRows</code> 行。<br> 在「杨辉三角」中，每个数是它左上方和右上方的数的和。<br> <a href="https://leetcode.cn/problems/merge-two-sorted-lists/description/" rel="nofollow">. - 力扣（LeetCode）</a>：合并两个有序链表<br> <a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/" rel="nofollow">. - 力扣（LeetCode）</a>：求环的路口<br> <a href="https://leetcode.cn/problems/linked-list-cycle/description/" rel="nofollow">. - 力扣（LeetCode）</a>：判断链表是否为环<br> <a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/description/" rel="nofollow">. - 力扣（LeetCode）</a>：给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。<br> <a href="https://www.nowcoder.com/practice/d281619e4b3e4a60a2cc66ea32855bfa?tpId=49&amp;&amp;tqId=29370&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/2016test/question-ranking" rel="nofollow">链表的回文结构_牛客题霸_牛客网</a>：判断链表是否回文</p> 
<p>需要答案可私聊我，当然官方也有题解唔。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/48cc43d67b0ed4279f3341c977f05644/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">贪心算法的初涉（双指针 &#43; “过山车思想”）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/853cae635f7c48ed89233ad74834c436/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2024牛客多校7 D-Interval Selection，数字哈希&#43;状态记录</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>