<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构初阶】二叉树--堆(顺序结构实现) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/96ab3b53f9901fa34d042ec04144e06d/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构初阶】二叉树--堆(顺序结构实现)">
  <meta property="og:description" content="hello！
目录
一、实现顺序结构二叉树
1.1 堆的概念和结构
1.2 堆及二叉树的性质
1.3 堆的实现
1.3.1 创建堆的结构
1.3.2 初始化和销毁
1.3.3 入堆&#43;向上调整算法（创建一个小堆）
1.3.4 出堆&#43;向下调整算法（小堆）
1.3.5 判空&#43;取堆顶数据&#43;堆中有效数据个数
二、顺序结构二叉树---源码
Heap.h
Heap.c
test.c
Relaxing Time！
————————————— 《星空物语》 —————————————
正文开始——
一、实现顺序结构二叉树 一般堆使用顺序结构的数组来存储数据，堆是一种特殊的二叉树，分为大根堆（大堆）和小根堆（小堆），具有二叉树的特性的同时，还具备其他的特性。
1.1 堆的概念和结构 如果有一个关键码的集合K={k1，k2,，k3，...，k（n-1）}，把它的所有元素按完全二叉树的顺序存储方式存储，在一个一维数组中，并满足：Ki &lt;= K(2*i&#43;1)（Ki &gt;= K(2*i&#43;1) 且 Ki &gt;= K(2*i&#43;2)），i = 0，1，2...，则称为小堆（或大堆）。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。
小堆：父结点不大于孩子结点；大堆：父结点不小于孩子结点。
数组不一定是有序地。小堆堆顶是堆的最小值，大堆堆顶是堆的最大值。 1.2 堆及二叉树的性质 堆的性质
堆中某个结点的值总是不大于或不小于其父结点的值；堆总是一棵完全二叉树。 二叉树的性质
对于具有 n 个结点的完全二叉树，如果按照从上至下从左至右的数组顺序对所有结点从0开始编号，则对于序号为 i 的结点有： 若 i &gt; 0，i 位置结点的双亲序号：（ i - 1）/ 2；i = 0，i 为根结点编号，无双亲结点；若 2i &#43; 1 &lt; n，左孩子序号：2i &#43; 1，2i &#43; 1 &gt;= n 则无左孩子；若 2i &#43; 2 &lt; n，右孩子序号：2i &#43; 2，2i &#43; 2 &gt;= n 则无右孩子； 通俗点来讲，父结点i---&gt; 左孩子：2i&#43;1，右孩子：2i&#43;2。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-09-01T22:27:36+08:00">
    <meta property="article:modified_time" content="2024-09-01T22:27:36+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构初阶】二叉树--堆(顺序结构实现)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="color:#0d0016;"><strong>hello！</strong></span></p> 
<p class="img-center"><img alt="" height="150" src="https://images2.imgbox.com/21/55/3HnAn1C3_o.jpg" width="150"></p> 
<p></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E5%AE%9E%E7%8E%B0%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%AE%9E%E7%8E%B0%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">一、实现顺序结构二叉树</a></p> 
<p id="1.1%C2%A0%20%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#1.1%C2%A0%20%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%BB%93%E6%9E%84" rel="nofollow">1.1  堆的概念和结构</a></p> 
<p id="1.2%C2%A0%20%E5%A0%86%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8-toc" style="margin-left:40px;"><a href="#1.2%C2%A0%20%E5%A0%86%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8" rel="nofollow">1.2  堆及二叉树的性质</a></p> 
<p id="1.3%C2%A0%20%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#1.3%C2%A0%20%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">1.3  堆的实现</a></p> 
<p id="1.3.1%C2%A0%20%E5%88%9B%E5%BB%BA%E5%A0%86%E7%9A%84%E7%BB%93%E6%9E%84-toc" style="margin-left:80px;"><a href="#1.3.1%C2%A0%20%E5%88%9B%E5%BB%BA%E5%A0%86%E7%9A%84%E7%BB%93%E6%9E%84" rel="nofollow">1.3.1  创建堆的结构</a></p> 
<p id="1.3.2%C2%A0%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81-toc" style="margin-left:80px;"><a href="#1.3.2%C2%A0%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81" rel="nofollow">1.3.2  初始化和销毁</a></p> 
<p id="1.3.3%C2%A0%20%E5%85%A5%E5%A0%86%2B%E5%90%91%E4%B8%8A%E8%B0%83%E6%95%B4%E7%AE%97%E6%B3%95%EF%BC%88%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%A0%86%EF%BC%89-toc" style="margin-left:80px;"><a href="#1.3.3%C2%A0%20%E5%85%A5%E5%A0%86%2B%E5%90%91%E4%B8%8A%E8%B0%83%E6%95%B4%E7%AE%97%E6%B3%95%EF%BC%88%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%A0%86%EF%BC%89" rel="nofollow">1.3.3  入堆+向上调整算法（创建一个小堆）</a></p> 
<p id="1.3.4%C2%A0%20%E5%87%BA%E5%A0%86%2B%E5%90%91%E4%B8%8B%E8%B0%83%E6%95%B4%E7%AE%97%E6%B3%95%EF%BC%88%E5%B0%8F%E5%A0%86%EF%BC%89-toc" style="margin-left:80px;"><a href="#1.3.4%C2%A0%20%E5%87%BA%E5%A0%86%2B%E5%90%91%E4%B8%8B%E8%B0%83%E6%95%B4%E7%AE%97%E6%B3%95%EF%BC%88%E5%B0%8F%E5%A0%86%EF%BC%89" rel="nofollow">1.3.4  出堆+向下调整算法（小堆）</a></p> 
<p id="1.3.5%C2%A0%20%E5%88%A4%E7%A9%BA%2B%E5%8F%96%E5%A0%86%E9%A1%B6%E6%95%B0%E6%8D%AE%2B%E5%A0%86%E4%B8%AD%E6%9C%89%E6%95%88%E6%95%B0%E6%8D%AE%E4%B8%AA%E6%95%B0-toc" style="margin-left:80px;"><a href="#1.3.5%C2%A0%20%E5%88%A4%E7%A9%BA%2B%E5%8F%96%E5%A0%86%E9%A1%B6%E6%95%B0%E6%8D%AE%2B%E5%A0%86%E4%B8%AD%E6%9C%89%E6%95%88%E6%95%B0%E6%8D%AE%E4%B8%AA%E6%95%B0" rel="nofollow">1.3.5  判空+取堆顶数据+堆中有效数据个数</a></p> 
<p id="%E4%BA%8C%E3%80%81%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84%E4%BA%8C%E5%8F%89%E6%A0%91---%E6%BA%90%E7%A0%81-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84%E4%BA%8C%E5%8F%89%E6%A0%91---%E6%BA%90%E7%A0%81" rel="nofollow">二、顺序结构二叉树---源码</a></p> 
<p id="Heap.h-toc" style="margin-left:40px;"><a href="#Heap.h" rel="nofollow">Heap.h</a></p> 
<p id="Heap.c-toc" style="margin-left:40px;"><a href="#Heap.c" rel="nofollow">Heap.c</a></p> 
<p id="test.c-toc" style="margin-left:40px;"><a href="#test.c" rel="nofollow">test.c</a></p> 
<p id="Relaxing%20Time%EF%BC%81-toc" style="margin-left:0px;"><a href="#Relaxing%20Time%EF%BC%81" rel="nofollow">Relaxing Time！</a></p> 
<p id="%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%C2%A0%20%E3%80%8A%E6%98%9F%E7%A9%BA%E7%89%A9%E8%AF%AD%E3%80%8B%C2%A0%C2%A0%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94-toc" style="margin-left:0px;"><a href="#%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%C2%A0%20%E3%80%8A%E6%98%9F%E7%A9%BA%E7%89%A9%E8%AF%AD%E3%80%8B%C2%A0%C2%A0%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94" rel="nofollow">—————————————  《星空物语》  —————————————</a></p> 
<p style="margin-left:0px;"></p> 
<hr id="hr-toc"> 
<p></p> 
<p>正文开始——</p> 
<p></p> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E5%AE%9E%E7%8E%B0%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span style="color:#0d0016;">一、实现顺序结构二叉树</span></h2> 
<p>一般<span style="color:#4da8ee;"><strong>堆</strong></span>使用<span style="color:#4da8ee;"><strong>顺序结构的数组</strong></span>来存储数据，堆是一种特殊的二叉树，分为大根堆（大堆）和小根堆（小堆），具有二叉树的特性的同时，还具备其他的特性。</p> 
<h4></h4> 
<h4></h4> 
<p></p> 
<h3 id="1.1%C2%A0%20%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%BB%93%E6%9E%84"><span style="color:#0d0016;">1.1  堆的概念和结构</span></h3> 
<p>如果有一个关键码的集合K={k1，k2,，k3，...，k（n-1）}，把它的所有元素按完全二叉树的顺序存储方式存储，在一个一维数组中，并满足：Ki &lt;= K(2*i+1)（Ki &gt;= K(2*i+1) 且 Ki &gt;= K(2*i+2)），i = 0，1，2...，则称为小堆（或大堆）。将根节点最大的堆叫做<span style="color:#4da8ee;"><strong>最大堆</strong></span>或<span style="color:#4da8ee;"><strong>大根堆</strong></span>，根节点最小的堆叫做<span style="color:#4da8ee;"><strong>最小堆</strong></span>或<strong><span style="color:#4da8ee;">小根堆</span></strong>。</p> 
<p>小堆：父结点不大于孩子结点；大堆：父结点不小于孩子结点。</p> 
<p class="img-center"><img alt="" height="388" src="https://images2.imgbox.com/48/be/YR8GRodE_o.png" width="700"></p> 
<p class="img-center"><img alt="" height="403" src="https://images2.imgbox.com/fd/0a/LecmCwN2_o.png" width="700"></p> 
<p>数组不一定是有序地。小堆堆顶是堆的最小值，大堆堆顶是堆的最大值。 </p> 
<p></p> 
<p></p> 
<h3 id="1.2%C2%A0%20%E5%A0%86%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span style="color:#0d0016;">1.2  堆及二叉树的性质</span></h3> 
<p></p> 
<blockquote> 
 <p><span style="color:#4da8ee;"><strong>堆的性质</strong></span></p> 
 <ul><li>堆中某个结点的值总是不大于或不小于其父结点的值；</li><li>堆总是一棵完全二叉树。</li></ul> 
</blockquote> 
<blockquote> 
 <p><span style="color:#4da8ee;"><strong>二叉树的性质</strong></span></p> 
 <ul><li>对于具有 n 个结点的完全二叉树，如果按照从上至下从左至右的数组顺序对所有结点从0开始编号，则对于序号为 i 的结点有：</li></ul> 
 <ol><li> 若 i &gt; 0，i 位置结点的双亲序号：（ i - 1）/ 2；i = 0，i 为根结点编号，无双亲结点；</li><li>若 2i + 1 &lt; n，左孩子序号：2i + 1，2i + 1 &gt;= n 则无左孩子；</li><li>若 2i + 2 &lt; n，右孩子序号：2i + 2，2i + 2 &gt;= n 则无右孩子；</li></ol> 
 <p>通俗点来讲，父结点i---&gt; 左孩子：2i+1，右孩子：2i+2。</p> 
</blockquote> 
<p></p> 
<p></p> 
<h3 id="1.3%C2%A0%20%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0"><span style="color:#0d0016;">1.3  堆的实现</span></h3> 
<h4 id="1.3.1%C2%A0%20%E5%88%9B%E5%BB%BA%E5%A0%86%E7%9A%84%E7%BB%93%E6%9E%84" style="background-color:transparent;"><span style="color:#ed7976;">1.3.1  创建堆的结构</span></h4> 
<p>堆的底层结构是数组 </p> 
<pre><code class="language-cpp">//创建堆的结构
typedef int HPDataType;
typedef struct Heap
{
	HPDataType* arr;
	int size;//堆中有效数据的个数
	int capacity;//堆的容量
}HP;</code></pre> 
<h4></h4> 
<h4 id="1.3.2%C2%A0%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81"><span style="color:#ed7976;">1.3.2  初始化和销毁</span></h4> 
<pre><code class="language-cpp">//初始化
void HPInit(HP* php)
{
	assert(php);
	php-&gt;arr = NULL;
	php-&gt;size = php-&gt;capacity = 0;
}

//销毁
void HPDestroy(HP* php)
{
	assert(php);

	 if(php-&gt;arr)
	{
		free(php-&gt;arr);
		php-&gt;arr = NULL;
	}

	php-&gt;size = php-&gt;capacity = 0;

}</code></pre> 
<h4></h4> 
<h4 id="1.3.3%C2%A0%20%E5%85%A5%E5%A0%86%2B%E5%90%91%E4%B8%8A%E8%B0%83%E6%95%B4%E7%AE%97%E6%B3%95%EF%BC%88%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%A0%86%EF%BC%89"><span style="color:#ed7976;">1.3.3  入堆+向上调整算法（创建一个小堆）</span></h4> 
<p>将新数据插入到数组的尾上，再进行向上调整算法，直到满足堆。</p> 
<blockquote> 
 <p><span style="color:#4da8ee;"><strong>向上调整算法</strong></span></p> 
 <ul><li>先将元素插入到堆的末尾，即最后一个子结点之后；</li><li>插入之后如果堆的性质遭到破坏，将新插入结点顺着双亲结点往上调整到合适位置即可。 </li></ul> 
</blockquote> 
<p>【举例，向上调整算法】</p> 
<p><strong>思路：</strong>新插入的数据作为子结点（child），找到新插入数据的父结点（parent=（child-1）/ 2）（上面二叉树的性质），父结点和子结点进行比较，若父结点大于子结点，数据交换，不大于则不交换。再找新的父结点和子结点，循环条件是 child&gt;0，child不需要等于0，child等于0时为根结点，根结点没有父结点不需要发生交换。</p> 
<p class="img-center"><img alt="" height="977" src="https://images2.imgbox.com/2f/d9/VmKisqSI_o.png" width="1200"></p> 
<pre><code class="language-cpp">void Swap(int* x, int* y)
{
	int tmp = *x;
	*x = *y;
	*y = tmp;
}

//向上调整算法
void AdjustUp(HPDataType* arr, int child)
{
	int parent = (child - 1) / 2;
	while (child &gt; 0)
	{
		if (arr[child] &lt; arr[parent])
		{
			Swap(&amp;arr[child], &amp;arr[parent]);
			child = parent;
			parent = (child - 1) / 2;
		}
		else
		{
			break;
		}
	}
}

//入堆
void HPPush(HP* php, HPDataType x)
{
	assert(php);

	//判断空间是否充足
	if (php-&gt;size == php-&gt;capacity)
	{
		int newCapacity = php-&gt;capacity == 0 ? 4 : 2 * php-&gt;capacity;
		HPDataType* tmp = (HPDataType*)realloc(php-&gt;arr, newCapacity * sizeof(HPDataType));
		if (tmp == NULL)
		{
			perror("realloc file!");
			exit(1);
		}
		php-&gt;arr = tmp;
		php-&gt;capacity = newCapacity;
	}
	//此时空间已经充足
    //我们应该清楚地知道，size是x的下标，size在数组中指向x这个元素
	php-&gt;arr[php-&gt;size] = x;

	//向上调整算法
	AdjustUp(php-&gt;arr, php-&gt;size);

	php-&gt;size++;
}
</code></pre> 
<p></p> 
<h4 id="1.3.4%C2%A0%20%E5%87%BA%E5%A0%86%2B%E5%90%91%E4%B8%8B%E8%B0%83%E6%95%B4%E7%AE%97%E6%B3%95%EF%BC%88%E5%B0%8F%E5%A0%86%EF%BC%89"><span style="color:#ed7976;">1.3.4  出堆+向下调整算法（小堆）</span></h4> 
<p><strong>堆的删除（出堆）</strong></p> 
<p><span style="color:#4da8ee;"><strong>删除堆是删除堆顶的数据</strong></span>，将堆顶的数据跟最后一个数据进行交换，然后删除数组最后一个数据，再进行向下调整算法。</p> 
<p><span style="color:#0d0016;">向下调整算法有一个前提：左右子树必须是一个堆，才能进行调整。</span></p> 
<blockquote> 
 <p><strong>出堆</strong></p> 
 <ul><li>将堆顶元素与堆中最后一个元素进行交换；</li><li>删除堆中最后一个元素；</li><li>将堆顶元素向下调整到满足堆特性为止。</li></ul> 
</blockquote> 
<p class="img-center"><img alt="" height="704" src="https://images2.imgbox.com/fb/18/LgcRDYX1_o.png" width="1200"></p> 
<p><strong> 【向下调整算法】</strong></p> 
<p><strong>思路：</strong>堆顶元素为父结点，找到左右孩子中最小的那个子结点与之比较，若父结点大于子结点，交换，不大于则不交换，不断找新的父结点和子结点，就这样循环，注意循环结束的条件。上代码，结合代码中的注释更好的理解。</p> 
<p class="img-center"><img alt="" height="761" src="https://images2.imgbox.com/93/8d/5f4LLfOH_o.png" width="1200"></p> 
<pre><code class="language-cpp">//向下调整算法
void AdjustDown(HPDataType* arr, int parent, int n)
{
	int child = parent * 2 + 1;//左孩子
	while (child &lt; n)
	{
		//找左右孩子中最小的
        //child + 1 &lt; n , 保证不越界
		if (child + 1 &lt; n &amp;&amp; arr[child] &gt; arr[child + 1])
		{
			child++;
		}
		if (arr[parent] &gt; arr[child])
		{
			Swap(&amp;arr[child], &amp;arr[parent]);
			parent = child;
			child = parent * 2 + 1;
		}
		else
		{
			break;
		}
	}
}

//出堆
void HPPop(HP* php)
{
	assert(php &amp;&amp; php-&gt;size);
    
	Swap(&amp;php-&gt;arr[0], &amp;php-&gt;arr[php-&gt;size-1]);
	php-&gt;size--;//删除掉最后一个数据(堆顶元素)

	//向下调整算法
	AdjustDown(php-&gt;arr, 0, php-&gt;size);

}</code></pre> 
<p></p> 
<h4 id="1.3.5%C2%A0%20%E5%88%A4%E7%A9%BA%2B%E5%8F%96%E5%A0%86%E9%A1%B6%E6%95%B0%E6%8D%AE%2B%E5%A0%86%E4%B8%AD%E6%9C%89%E6%95%88%E6%95%B0%E6%8D%AE%E4%B8%AA%E6%95%B0"><span style="color:#ed7976;">1.3.5  判空+取堆顶数据+堆中有效数据个数</span></h4> 
<p></p> 
<pre><code class="language-cpp">//判空
bool HPEmpty(HP* php)
{
	assert(php);
	return php-&gt;size == 0;
}

//取堆顶数据
HPDataType HPTop(HP* php)
{
	assert(php &amp;&amp; php-&gt;size);

	return php-&gt;arr[0];
}

//堆中有效数据的个数
int HPSize(HP* php)
{
	assert(php);
	return php-&gt;size;
}</code></pre> 
<p></p> 
<h2 id="%E4%BA%8C%E3%80%81%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84%E4%BA%8C%E5%8F%89%E6%A0%91---%E6%BA%90%E7%A0%81">二、顺序结构二叉树---源码</h2> 
<p></p> 
<h3 id="Heap.h">Heap.h</h3> 
<pre><code class="language-cpp">#pragma once
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;stdbool.h&gt;
#include&lt;assert.h&gt;

//创建堆的结构
typedef int HPDataType;
typedef struct Heap
{
	HPDataType* arr;
	int size;//堆中有效数据个数
	int capacity;//堆的容量
}HP;

//初始化
void HPInit(HP* php);

//销毁
void HPDestroy(HP* php);

//入堆
void HPPush(HP* php, HPDataType x);

//出堆
void HPPop(HP* php);

//判空
bool HPEmpty(HP* php);

//取堆顶数据
HPDataType HPTop(HP* php);

//堆中有效数据的个数
int HPSize(HP* php);

</code></pre> 
<p></p> 
<h3 id="Heap.c">Heap.c</h3> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1
#include"Heap.h"

//初始化
void HPInit(HP* php)
{
	assert(php);
	php-&gt;arr = NULL;
	php-&gt;size = php-&gt;capacity = 0;
}

//销毁
void HPDestroy(HP* php)
{
	assert(php);
	if (php-&gt;arr)
	{
		free(php-&gt;arr);
		php-&gt;arr = NULL;
	}
}

void Swap(int* x, int* y)
{
	int tmp = *x;
	*x = *y;
	*y = tmp;
}

//向上调整算法
void AdjustUp(HPDataType* arr, int child)
{
	int parent = (child - 1) / 2;

	while (child &gt; 0)//不需要等于0，child等于0时为根结点，根结点没有父结点不需要发生交换
	{
		if (arr[child] &lt; arr[parent])
		{
			Swap(&amp;arr[child], &amp;arr[parent]);
			child = parent;
			parent = (child - 1) / 2;
		}
		else
		{
			break;
		}
	}
}

//入堆
void HPPush(HP* php,HPDataType x)
{
	assert(php);

	//判断空间是否充足
	if (php-&gt;size == php-&gt;capacity)
	{
		int newCapacity = php-&gt;capacity == 0 ? 4 : 2 * php-&gt;capacity;
		HPDataType* tmp = (HPDataType*)realloc(php-&gt;arr, newCapacity * sizeof(HPDataType));
		if (tmp == NULL)
		{
			perror("realloc file!");
			exit(1);
		}
		php-&gt;arr = tmp;
		php-&gt;capacity = newCapacity;
	}

	//此时空间已经充足
	php-&gt;arr[php-&gt;size] = x;

	//向上调整算法
	AdjustUp(php-&gt;arr, php-&gt;size);

	php-&gt;size++;

}

//向下调整算法
void AdjustDown(HPDataType* arr, int parent, int n)
{
	int child = parent * 2 + 1;//左孩子
	while (child &lt; n)
	{
		//找左右孩子中最小的
		if (child + 1 &lt; n &amp;&amp; arr[child] &gt; arr[child + 1])
		{
			child++;
		}
		if (arr[parent] &gt; arr[child])
		{
			Swap(&amp;arr[child], &amp;arr[parent]);
			parent = child;
			child = parent * 2 + 1;
		}
		else
		{
			break;
		}
	}
}

//出堆
void HPPop(HP* php)
{
	assert(php &amp;&amp; php-&gt;size);

	Swap(&amp;php-&gt;arr[0], &amp;php-&gt;arr[php-&gt;size-1]);
	php-&gt;size--;

	//向下调整算法
	AdjustDown(php-&gt;arr, 0, php-&gt;size);

}

//判空
bool HPEmpty(HP* php)
{
	assert(php);
	return php-&gt;size == 0;
}

//取堆顶数据
HPDataType HPTop(HP* php)
{
	assert(php &amp;&amp; php-&gt;size);

	return php-&gt;arr[0];
}

//堆中有效数据的个数
int HPSize(HP* php)
{
	assert(php);
	return php-&gt;size;
}</code></pre> 
<p></p> 
<h3 id="test.c">test.c</h3> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1
#include"Heap.h"

void test01()
{
	HP hp;
	HPInit(&amp;hp);

	int arr[] = { 1,3,5,7,4,10,8 };

	for (int i = 0; i &lt; 7; i++)
	{
		HPPush(&amp;hp, arr[i]);
	}

	printf("堆中有效数据个数：%d\n", HPSize(&amp;hp));

	while (!HPEmpty(&amp;hp))
	{
		printf("%d ", HPTop(&amp;hp));
		HPPop(&amp;hp);
	}



	HPDestroy(&amp;hp);


}

int main()
{

	test01();
	return 0;
}</code></pre> 
<p></p> 
<p>完——</p> 
<hr> 
<p></p> 
<p></p> 
<h2>Relaxing Time!</h2> 
<p style="text-align:center;"></p> 
<p></p> 
<h2 id="%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%C2%A0%20%E3%80%8A%E6%98%9F%E7%A9%BA%E7%89%A9%E8%AF%AD%E3%80%8B%C2%A0%C2%A0%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94"><span style="color:#0d0016;">—————————————</span><span style="color:#ff9900;">  </span><span style="color:#38d8f0;">《星空物语》  </span><span style="color:#0d0016;">—————————————</span></h2> 
<p></p> 
<p></p> 
<p><a href="https://music.163.com/song?id=4872531&amp;uct2=U2FsdGVkX1/1x1m+f/pY7coRc00R1p0xS3Mg2ShQnzI=" rel="nofollow" title="星空物语（电视剧《一起来看流星雨》主题曲） - 张翰/朱梓骁/魏晨/俞灏明 - 单曲 - 网易云音乐">星空物语（电视剧《一起来看流星雨》主题曲） - 张翰/朱梓骁/魏晨/俞灏明 - 单曲 - 网易云音乐</a></p> 
<p></p> 
<p></p> 
<p style="text-align:center;"><img alt="" class="left" height="469" src="https://images2.imgbox.com/52/0d/Sk7igkz5_o.jpg" width="300"></p> 
<p></p> 
<p>我是<span style="color:#38d8f0;">云边有个稻草人</span></p> 
<p>期待与你的下一次相遇——</p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7a1d609ed8d98eaff6df8fcc7aaf5206/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【微服务】springboot 自定义注解&#43;反射&#43;aop实现动态修改请求参数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/db2fccf90e69242ac9b666769df4d5ec/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">yolo8 目标检测、鉴黄</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>