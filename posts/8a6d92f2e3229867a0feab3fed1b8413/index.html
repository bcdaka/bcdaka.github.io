<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】第十七弹---C语言实现选择排序 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/8a6d92f2e3229867a0feab3fed1b8413/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】第十七弹---C语言实现选择排序">
  <meta property="og:description" content="✨个人主页： 熬夜学编程的小林
💗系列专栏： 【C语言详解】 【数据结构详解】【C&#43;&#43;详解】
目录
1、选择排序
1.1、基本思想
1.2、代码实现
1.3、代码测试
1.4、时空复杂度分析
总结
1、选择排序 1.1、基本思想 选择排序是一种简单直观的比较排序算法。该算法的基本思想是在每一轮中选出当前未排序部分的最小（或最大）元素，然后将其放置到未排序序列的起始位置，这个过程一直重复直至整个数组被排序。
选择排序的具体步骤如下：
★ 从数组的当前未排序部分选择最小（或最大）的一个元素。
★ 将这个最小（或最大）元素与未排序序列的第一个元素交换位置。
★ 然后从剩余未排序的元素中继续这个过程，将每一次找到的最小（或最大）元素放到未排序序列的开始。
★ 这个过程一直进行到整个数组的所有元素都被排为有序状态。
1.2、代码实现 此处可以进行一个小的优化，同时找最小值与最大值，但是有一个细节需要注意，先上代码。
此处还需要交换元素，所以提前封装一个交换函数。
void Swap(int* p1, int* p2) { int tmp = *p1; *p1 = *p2; *p2 = tmp; } void SelectSort(int a[], int n) { int begin = 0; int end = n - 1; while (begin &lt; end) { int maxi = begin;//找最大值的下标 int mini = begin;//找最小值的下标 for (int i = begin &#43; 1; i &lt;= end; i&#43;&#43;) { if (a[i] &lt; a[mini]) { mini = i; } if (a[i] &gt; a[maxi]) { maxi = i; } } Swap(&amp;a[begin], &amp;a[mini]); Swap(&amp;a[end], &amp;a[maxi]); begin&#43;&#43;; end--; } } ★ 首先初始化两个索引begin和end，分别代表当前未排序序列的开始和结束位置。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-18T12:12:30+08:00">
    <meta property="article:modified_time" content="2024-06-18T12:12:30+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】第十七弹---C语言实现选择排序</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" src="https://images2.imgbox.com/72/98/fyOKSvO8_o.jpg"></p> 
<p style="text-align:center;">✨<span style="color:#956fe7;">个人主页：</span><a href="https://blog.csdn.net/2201_75584283?spm=1011.2415.3001.5343" title=" 熬夜学编程的小林"> 熬夜学编程的小林</a></p> 
<p style="text-align:center;">💗<span style="color:#fe2c24;">系列专栏：</span> <a href="https://blog.csdn.net/2201_75584283/category_12556736.html" title="【C语言详解】">【C语言详解】</a> <a href="https://blog.csdn.net/2201_75584283/category_12556751.html" title="【数据结构详解】">【数据结构详解】</a><a href="https://blog.csdn.net/2201_75584283/category_12577595.html?spm=1001.2014.3001.5482" title="【C++详解】">【C++详解】</a></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="1.2%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-toc" style="margin-left:0px;"><a href="#1.2%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" rel="nofollow">1、选择排序</a></p> 
<p id="1.2.1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-toc" style="margin-left:40px;"><a href="#1.2.1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3" rel="nofollow">1.1、基本思想</a></p> 
<p id="1.2.2%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#1.2.2%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">1.2、代码实现</a></p> 
<p id="%C2%A01.2.3%E3%80%81%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95-toc" style="margin-left:40px;"><a href="#%C2%A01.2.3%E3%80%81%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95" rel="nofollow">1.3、代码测试</a></p> 
<p id="1.4%E3%80%81%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><a href="#1.4%E3%80%81%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90" rel="nofollow">1.4、时空复杂度分析</a></p> 
<p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1.2%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">1、选择排序</h2> 
<p></p> 
<h3 id="1.2.1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3">1.1、基本思想</h3> 
<blockquote> 
 <p>选择排序是一种简单直观的比较排序算法。该算法的基本思想是在每一轮中<strong><span style="color:#0d0016;">选出当前未排序部分的最小（或最大）元素</span></strong>，然后将其<strong><span style="color:#0d0016;">放置到未排序序列的起始位置</span></strong>，这个过程一直重复直至整个数组被排序。</p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/57/e9/yGrlkLRi_o.gif"></p> 
<p>选择排序的具体步骤如下：</p> 
<blockquote> 
 <p>★ 从数组的<span style="color:#0d0016;"><strong>当前未排序部分选择最小（或最大）的一个元素</strong></span>。<br> ★ 将这个<strong><span style="color:#0d0016;">最小（或最大）元素与未排序序列的第一个元素交换位置</span></strong>。<br> ★ 然后从剩余未排序的元素中继续这个过程，将每一次找到的最小（或最大）元素放到未排序序列的开始。<br> ★ 这个过程<strong><span style="color:#0d0016;">一直进行到整个数组的所有元素都被排为有序状态</span></strong>。</p> 
</blockquote> 
<p></p> 
<h3 id="1.2.2%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">1.2、代码实现</h3> 
<p><span style="color:#fe2c24;"><strong>此处可以进行一个小的优化，同时找最小值与最大值，但是有一个细节需要注意，先上代码。</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>此处还需要交换元素，所以提前封装一个交换函数。</strong></span></p> 
<pre><code>void Swap(int* p1, int* p2)
{
	int tmp = *p1;
	*p1 = *p2;
	*p2 = tmp;
}
void SelectSort(int a[], int n)
{
	int begin = 0;
	int end = n - 1;
	while (begin &lt; end)
	{
		int maxi = begin;//找最大值的下标
		int mini = begin;//找最小值的下标
		for (int i = begin + 1; i &lt;= end; i++)
		{
			if (a[i] &lt; a[mini])
			{
				mini = i;
			}
			if (a[i] &gt; a[maxi])
			{
				maxi = i;
			}
		}
		Swap(&amp;a[begin], &amp;a[mini]);
		Swap(&amp;a[end], &amp;a[maxi]);
		begin++;
		end--;
	}
}</code></pre> 
<blockquote> 
 <p>★ 首先初始化两个索引<code>begin</code>和<code>end</code>，分别代表当前未排序序列的<strong>开始和结束位置。</strong></p> 
 <p>★ 进入一个循环，条件是<code>begin &lt; end</code>，确保在数组中还有未排序的元素。</p> 
 <p>★ 遍历一遍序列，<strong>找到最大元素和最小元素的下标。</strong></p> 
 <p>★ 将最小元素与序列的始端交换，最大元素与序列的尾端交换。</p> 
 <p>★ <strong>更新begin与end。</strong></p> 
</blockquote> 
<p><strong><span style="color:#fe2c24;">思考一下上面写的代码有没有问题呢？？？</span></strong></p> 
<blockquote> 
 <p><strong>答案是有问题的，因为这里我们是首先进行最小元素与首位置更换，再进行最大元素与末尾更换，如果我的最大元素就在首位置就会有问题，如下图：</strong></p> 
</blockquote> 
<p><img alt="" height="799" src="https://images2.imgbox.com/f0/8b/SwrZeoIJ_o.png" width="1200"></p> 
<p></p> 
<p><strong><span style="color:#fe2c24;">如果最大值就在第一个位置时需要更新最大值的下标！！！ </span></strong></p> 
<p><strong><span style="color:#0d0016;">正确的代码如下：</span></strong></p> 
<pre><code>void Swap(int* p1, int* p2)
{
	int tmp = *p1;
	*p1 = *p2;
	*p2 = tmp;
}
void SelectSort(int a[], int n)
{
	int begin = 0;
	int end = n - 1;
	while (begin &lt; end)
	{
		int maxi = begin;//找最大值的下标
		int mini = begin;//找最小值的下标
		for (int i = begin + 1; i &lt;= end; i++)
		{
			if (a[i] &lt; a[mini])
			{
				mini = i;
			}
			if (a[i] &gt; a[maxi])
			{
				maxi = i;
			}
		}
		Swap(&amp;a[begin], &amp;a[mini]);
		//最大值的位置跟最小值重合
		//mini被换到maxi位置时  原本的最大值则是mini
		if (maxi == begin)
			maxi = mini;
		Swap(&amp;a[end], &amp;a[maxi]);

		begin++;
		end--;
	}
}</code></pre> 
<p></p> 
<p><strong><span style="color:#0d0016;">注意：</span></strong></p> 
<blockquote> 
 <p>1.这里是对最初的选择排序进行优化，最小值最大值一起进行的。</p> 
 <p><strong>2.当最大值被交换后，需要重新赋值。 </strong></p> 
</blockquote> 
<p></p> 
<h3 id="%C2%A01.2.3%E3%80%81%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95"><br>  1.3、代码测试</h3> 
<p></p> 
<p><strong><span style="color:#0d0016;">测试代码：</span></strong></p> 
<pre><code>//测试选择排序
int main()
{
	int a[] = { 9,8,7,6,5,4,3,2,1,0 };//给一组数据
	int sz = sizeof(a) / sizeof(a[0]);//计算数组元素个数
	printf("排序前：\n");
	ArrayPrint(a, sz);
	SelectSort(a, sz);
	printf("排序后：\n");
	ArrayPrint(a, sz);
	return 0;
}</code></pre> 
<p></p> 
<p><strong><span style="color:#0d0016;"> 测试结果：</span></strong></p> 
<p><img alt="" height="400" src="https://images2.imgbox.com/9d/93/ril6nKqd_o.png" width="730"></p> 
<h3 id="1.4%E3%80%81%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90">1.4、时空复杂度分析</h3> 
<p><strong><span style="color:#0d0016;">时间复杂度</span></strong></p> 
<p><strong><span style="color:#38d8f0;">最好、平均、最坏情况下的时间复杂度都是 O(n^2)。</span></strong></p> 
<blockquote> 
 <p>原因在于，不管数组的初始顺序如何，选择排序都需要比较所有未排序的元素来找到最小（或最大）的元素，并执行这个过程 n-1 次（对于 n 个元素的数组）。每次选择操作需要比较的次数从 n-1 次减少到 1 次，总共的比较次数是 (n-1) + (n-2) + … + 1 = n(n-1)/2，这是一个二次函数，因此时间复杂度为 O(n^2)。</p> 
</blockquote> 
<p><strong><span style="color:#0d0016;">空间复杂度</span></strong></p> 
<p><strong><span style="color:#38d8f0;">选择排序是一种原地排序算法，除了输入数组外，它只需要有限的几个变量（比如，用于存储最小元素下标的变量和循环计数器）。因此，它的空间复杂度为常数空间O(1)。</span></strong></p> 
<p></p> 
<p>选择排序的特性总结：</p> 
<blockquote> 
 <p>1. 选择排序思考非常好理解，但是效率不是很好。实际中很少使用。<br> 2. 时间复杂度：O(N^2)<br> 3. 空间复杂度：O(1)<br> 4. 稳定性：不稳定</p> 
 <p>5. 复杂性：简单</p> 
</blockquote> 
<p></p> 
<h2 id="1.3%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F"></h2> 
<h2 id="%E6%80%BB%E7%BB%93">总结</h2> 
<p><br> 本篇博客就结束啦，谢谢大家的观看，如果公主少年们有好的建议可以留言喔，谢谢大家啦！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/825e3b5e55d456979dc0271c45233306/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【机器学习】CART决策树算法的核心思想及其大数据时代银行贷款参考案例——机器认知外界的重要算法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3573528397cdcef7085346e8b9245c1a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">编程猫怎么编程汽车：探索虚拟与现实交汇的编程之旅</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>