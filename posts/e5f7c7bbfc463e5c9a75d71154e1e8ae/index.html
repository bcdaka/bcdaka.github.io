<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SpringBoot整合Netty(服务端) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/e5f7c7bbfc463e5c9a75d71154e1e8ae/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="SpringBoot整合Netty(服务端)">
  <meta property="og:description" content="工作场景:使用Netty长连接实时获取第三方接口的车辆定位数据
开发环境:JDK8
Netty基本介绍 一、什么是Netty Netty是由JBOSS提供的一个Java开源框架，现为Github上的独立项目。它是一个异步的、基于事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络IO程序。Netty主要针对在TCP协议下，面向Clients端的高并发应用，或者Peer-to-Peer场景下的大量数据持续传输的应用。
Netty提供了一套完整的API，用于处理网络IO操作，如TCP和UDP套接字。它封装了底层的网络编程细节，使得开发者可以更加专注于业务逻辑的实现。Netty使用了一种高效的线程模型，可以处理大量的并发连接，并且具有很好的伸缩性。
Netty在多个领域都有广泛的应用，如RPC框架、游戏行业、大数据领域等。它支持多种传输类型和协议，如阻塞和非阻塞、基于BIO和NIO的UDP传输、本地传输（in-VM传输）、HTTP通道等。同时，Netty还提供了丰富的编解码器，用于处理各种协议的编解码操作。
Netty的整体结构包括核心层和协议支持层。核心层提供了底层网络通信的通用抽象和实现，包括可扩展的事件模型、通用的通信API、支持零拷贝的ByteBuf等。协议支持层则覆盖了主流协议的编解码实现，如HTTP、SSL、Protobuf等。
总的来说，Netty是一个功能强大、易于使用的网络应用框架，它可以帮助开发者快速构建高性能、高可靠性的网络应用程序。
二、Netty核心组件 Netty的核心组件主要包括以下几个部分：
Channels：Channel是Netty网络通信的抽象，用于进行I/O操作。它可以被看作是Java NIO的一个基本抽象，代表了与硬件设备、文件、网络socket等实体的开放连接，或者是一个能够完成读、写等I/O操作的程序。Channel可以被打开或关闭，连接或断开。Callbacks（回调）：Callback是一个方法，它是提供给另一个方法的引用，使得另一个方法可以在适当的时候回过头来调用这个Callback方法。Callback在很多编程情形中被广泛使用，是用于通知相关方某个操作已经完成最常用的方法之一。Futures：在Netty中，Futures用于异步I/O操作的结果。当一个异步操作开始时，会立即返回一个Future，这个Future会在操作完成时得到结果或者异常。Handlers：Handlers是Netty中处理I/O事件或拦截I/O操作的组件。Netty提供了许多内置的Handler，如ChannelInboundHandler、ChannelOutboundHandler等，这些Handler可以处理各种I/O事件，如连接建立、数据接收、异常处理等。Bootstrap与ServerBootstrap：Bootstrap和ServerBootstrap是Netty程序的引导类，主要用于配置各种参数并启动整个Netty服务。它们都继承自AbstractBootstrap抽象类，不同的是，Bootstrap用于客户端引导，而ServerBootstrap用于服务端引导。EventLoopGroup：EventLoopGroup可以理解为一个线程池，用于处理I/O操作。在服务端程序中，一般会绑定两个EventLoopGroup，一个用于处理Accept事件（即新的连接请求），另一个用于处理读写事件。 以上这些组件共同构成了Netty的核心框架，使得开发者可以更加专注于业务逻辑的实现，而无需过多关心底层的网络通信细节。
三、SpringBoot与Netty整合 1. 添加依赖 在SpringBoot项目的pom.xml文件中，我们需要添加Netty的依赖。Netty的官方Maven仓库地址为：https://mvnrepository.com/artifact/io.netty/netty-all
&lt;dependencies&gt; &lt;!-- mybatis-plus --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Mysql --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 数据源 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- netty --&gt; &lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;dynamic-datasource-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;${mybatis-plus.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2.创建Netty服务端 @Component public class NettyServer { //负责处理接受进来的链接 private EventLoopGroup bossGroup; //负责处理已经被接收的连接上的I/O操作 private EventLoopGroup workerGroup; //在这个场景中，它表示服务器的绑定操作的结果 private ChannelFuture future; @PostConstruct public void startServer() throws Exception { bossGroup = new NioEventLoopGroup(); workerGroup = new NioEventLoopGroup(); try { //创建ServerBootstrap,这个类封装了服务器端的网络配置，使得我们可以轻松地设置服务器参数 ServerBootstrap bootstrap = new ServerBootstrap(); bootstrap.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-23T15:19:39+08:00">
    <meta property="article:modified_time" content="2024-05-23T15:19:39+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SpringBoot整合Netty(服务端)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>工作场景:使用Netty长连接实时获取第三方接口的车辆定位数据</p> 
<p>开发环境:JDK8</p> 
<h2>Netty基本介绍</h2> 
<h4>一、什么是Netty</h4> 
<p><strong>Netty是由JBOSS提供的一个Java开源框架，现为Github上的独立项目</strong>。它是一个异步的、基于事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络IO程序。Netty主要针对在TCP协议下，面向Clients端的高并发应用，或者Peer-to-Peer场景下的大量数据持续传输的应用。</p> 
<p>Netty提供了一套完整的API，用于处理网络IO操作，如TCP和UDP套接字。它封装了底层的网络编程细节，使得开发者可以更加专注于业务逻辑的实现。Netty使用了一种高效的线程模型，可以处理大量的并发连接，并且具有很好的伸缩性。</p> 
<p>Netty在多个领域都有广泛的应用，如RPC框架、游戏行业、大数据领域等。它支持多种传输类型和协议，如阻塞和非阻塞、基于BIO和NIO的UDP传输、本地传输（in-VM传输）、HTTP通道等。同时，Netty还提供了丰富的编解码器，用于处理各种协议的编解码操作。</p> 
<p>Netty的整体结构包括核心层和协议支持层。核心层提供了底层网络通信的通用抽象和实现，包括可扩展的事件模型、通用的通信API、支持零拷贝的ByteBuf等。协议支持层则覆盖了主流协议的编解码实现，如HTTP、SSL、Protobuf等。</p> 
<p>总的来说，Netty是一个功能强大、易于使用的网络应用框架，它可以帮助开发者快速构建高性能、高可靠性的网络应用程序。</p> 
<h4>二、Netty核心组件</h4> 
<p>Netty的核心组件主要包括以下几个部分：</p> 
<ol><li><span style="color:#fe2c24;"><strong>Channels</strong></span>：Channel是Netty网络通信的抽象，用于进行I/O操作。它可以被看作是Java NIO的一个基本抽象，代表了与硬件设备、文件、网络socket等实体的开放连接，或者是一个能够完成读、写等I/O操作的程序。Channel可以被打开或关闭，连接或断开。</li><li><strong>Callbacks（回调）</strong>：Callback是一个方法，它是提供给另一个方法的引用，使得另一个方法可以在适当的时候回过头来调用这个Callback方法。Callback在很多编程情形中被广泛使用，是用于通知相关方某个操作已经完成最常用的方法之一。</li><li><strong>Futures</strong>：在Netty中，Futures用于异步I/O操作的结果。当一个异步操作开始时，会立即返回一个Future，这个Future会在操作完成时得到结果或者异常。</li><li><span style="color:#fe2c24;"><strong>Handlers</strong></span>：Handlers是Netty中处理I/O事件或拦截I/O操作的组件。Netty提供了许多内置的Handler，如ChannelInboundHandler、ChannelOutboundHandler等，这些Handler可以处理各种I/O事件，如连接建立、数据接收、异常处理等。</li><li><strong>Bootstrap与ServerBootstrap</strong>：Bootstrap和ServerBootstrap是Netty程序的引导类，主要用于配置各种参数并启动整个Netty服务。它们都继承自AbstractBootstrap抽象类，不同的是，Bootstrap用于客户端引导，而ServerBootstrap用于服务端引导。</li><li><span style="color:#fe2c24;"><strong>EventLoopGroup</strong></span>：EventLoopGroup可以理解为一个线程池，用于处理I/O操作。在服务端程序中，一般会绑定两个EventLoopGroup，一个用于处理Accept事件（即新的连接请求），另一个用于处理读写事件。</li></ol> 
<p>以上这些组件共同构成了Netty的核心框架，使得开发者可以更加专注于业务逻辑的实现，而无需过多关心底层的网络通信细节。</p> 
<h4>三、SpringBoot与Netty整合</h4> 
<h5><strong>1. 添加依赖</strong></h5> 
<p>在SpringBoot项目的pom.xml文件中，我们需要添加Netty的依赖。Netty的官方Maven仓库地址为：https://mvnrepository.com/artifact/io.netty/netty-all</p> 
<pre><code class="language-XML">    &lt;dependencies&gt;
        &lt;!-- mybatis-plus --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- Mysql --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!--   数据源     --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!--   netty     --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.netty&lt;/groupId&gt;
            &lt;artifactId&gt;netty-all&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
            &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
            &lt;artifactId&gt;dynamic-datasource-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;${mybatis-plus.version}&lt;/version&gt;
        &lt;/dependency&gt;

    &lt;/dependencies&gt;</code></pre> 
<h5>2.创建Netty服务端</h5> 
<pre><code class="language-java">@Component
public class NettyServer {

    //负责处理接受进来的链接
    private EventLoopGroup bossGroup;
    //负责处理已经被接收的连接上的I/O操作
    private EventLoopGroup workerGroup;
    //在这个场景中，它表示服务器的绑定操作的结果
    private ChannelFuture future;

    @PostConstruct
    public void startServer() throws Exception {
        bossGroup = new NioEventLoopGroup();
        workerGroup = new NioEventLoopGroup();
        try {
            //创建ServerBootstrap,这个类封装了服务器端的网络配置，使得我们可以轻松地设置服务器参数
            ServerBootstrap bootstrap = new ServerBootstrap();
            bootstrap.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .childHandler(new NettyServerInitializer());

            // 绑定端口并开始接受进来的连接
            future = bootstrap.bind(7000).sync();

            // 等待服务器套接字关闭
            future.channel().closeFuture().sync();
        } finally {
            workerGroup.shutdownGracefully();
            bossGroup.shutdownGracefully();
        }
    }

    @PreDestroy
    public void stopServer() {
        if (future != null &amp;&amp; !future.isDone()) {
            future.cancel(true);
        }
        workerGroup.shutdownGracefully();
        bossGroup.shutdownGracefully();
    }
}
</code></pre> 
<h6>代码解析</h6> 
<ol><li> <h6><strong>类注解</strong></h6> 
  <ul><li><code>@Component</code>: 这是Spring框架的注解，表示这个类是一个组件，Spring会扫描到这个类并将其作为Bean注册到Spring容器中。因此，这个类可以被其他Spring管理的Bean自动装配（如果需要的话）。</li></ul></li><li> <h6><strong>类成员变量</strong></h6> 
  <ul><li><code>bossGroup</code> 和 <code>workerGroup</code>: 这两个是<code>EventLoopGroup</code>的实例，用于处理网络事件。<code>bossGroup</code> 主要负责接收进来的连接，而 <code>workerGroup</code> 负责处理已经被接收的连接上的I/O操作。</li><li><code>future</code>: 这是一个<code>ChannelFuture</code>的实例，代表了一个异步的I/O操作的结果。在这个场景中，它表示服务器的绑定操作的结果。</li></ul></li><li> <h6><strong><code>startServer</code> 方法</strong></h6> 
  <ul><li>该方法使用<code>@PostConstruct</code>注解，这意味着当Spring容器实例化这个Bean并完成依赖注入后，会自动调用这个方法。</li><li>在这个方法中，首先创建了两个<code>NioEventLoopGroup</code>实例，一个用于boss，一个用于worker。</li><li>然后，使用<code>ServerBootstrap</code>类来配置和启动服务器。这个类封装了服务器端的网络配置，使得我们可以轻松地设置服务器参数。</li><li>通过<code>group</code>方法设置boss和worker的<code>EventLoopGroup</code>。</li><li>通过<code>channel</code>方法指定使用<code>NioServerSocketChannel</code>作为服务器的通道实现。</li><li>通过<code>childHandler</code>方法设置一个新的连接被接受后如何处理。这里使用了<code>NettyServerInitializer</code>（这个类没有在提供的代码段中定义，但我们可以假设它是一个<code>ChannelInitializer</code>的实现，用于配置新的<code>Channel</code>）。</li><li>使用<code>bind</code>方法绑定服务器到指定的端口（这里是7000），并使用<code>sync</code>方法阻塞直到绑定完成。</li><li>最后，使用<code>closeFuture().sync()</code>方法阻塞当前线程，直到服务器套接字关闭。</li><li>在<code>finally</code>块中，无论是否发生异常，都会优雅地关闭<code>EventLoopGroup</code>。</li></ul></li><li> <h6><strong><code>stopServer</code> 方法</strong></h6> 
  <ul><li>该方法使用<code>@PreDestroy</code>注解，意味着当Spring容器销毁这个Bean之前，会自动调用这个方法。</li><li>在这个方法中，首先检查<code>future</code>是否已经完成（即服务器是否已经关闭）。如果没有，就调用<code>cancel(true)</code>方法来尝试取消这个操作。但是，需要注意的是，这里的<code>cancel</code>可能并不总是能立即停止服务器，它更多的是尝试停止服务器，而不是强制停止。</li></ul></li></ol> 
<h5>3.创建字符解析器,用于解析收到的消息</h5> 
<pre><code class="language-java">public class NettyServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; {

    @Override
    protected void initChannel(SocketChannel ch){
        ChannelPipeline pipeline = ch.pipeline();

        // 添加一个字符串解码器，用于将接收到的ByteBuf转换成字符串
        // 这里假设使用的是UTF-8字符集
        pipeline.addLast("decoder", new StringDecoder(CharsetUtil.UTF_8));

        // 添加一个字符串编码器，用于将发送的字符串转换成ByteBuf
        // 这样服务器发送字符串时，客户端可以直接接收到字符串
        pipeline.addLast("encoder", new StringEncoder(CharsetUtil.UTF_8));

        // 添加自定义的ChannelInboundHandlerAdapter来处理业务逻辑
        pipeline.addLast("handler", new MyChannelHandler());
    }
}</code></pre> 
<ol><li>这段代码定义了一个<code>NettyServerInitializer</code>类，它继承自<code>ChannelInitializer&lt;SocketChannel&gt;</code>，并覆盖了<code>initChannel</code>方法。在Netty中，<code>ChannelInitializer</code>是一个特殊的处理器，它的主要目的是帮助用户配置一个新的<code>Channel</code>的<code>ChannelPipeline</code>。当一个新的连接被接受时，Netty会自动调用<code>ChannelInitializer</code>的<code>initChannel</code>方法来设置这个新连接的<code>ChannelPipeline</code>。</li></ol> 
<p>具体来说，<code>initChannel</code>方法会在以下情况下被调用：</p> 
<ol><li>当<code>ServerBootstrap</code>的<code>bind</code>方法被调用并成功绑定到某个端口后，开始监听传入的连接。</li><li>一旦有客户端连接到服务器，<code>ServerBootstrap</code>会接受这个连接，并创建一个新的<code>SocketChannel</code>来表示这个连接。</li><li>对于这个新的<code>SocketChannel</code>，Netty会调用之前设置的<code>ChannelInitializer</code>（在这个例子中是<code>NettyServerInitializer</code>）的<code>initChannel</code>方法。</li><li><code>initChannel</code>方法内部会配置这个新<code>SocketChannel</code>的<code>ChannelPipeline</code>，添加解码器、编码器、业务处理器等。</li><li>一旦<code>initChannel</code>方法执行完毕，这个<code>ChannelInitializer</code>的使命就完成了，并且会从<code>ChannelPipeline</code>中移除自身，因为它只负责初始化工作，不参与后续的数据处理。</li></ol> 
<p>所以，总结来说，<code>NettyServerInitializer</code>的<code>initChannel</code>方法会在一个新的客户端连接被服务器接受时运行，用于初始化这个新连接的<code>ChannelPipeline</code>。</p> 
<p></p> 
<h5>4.创建Handler处理接受到的消息</h5> 
<pre><code class="language-java">public class MyChannelHandler extends ChannelInboundHandlerAdapter {
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        // 在这里处理接收到的数据


        System.out.println("msg = " + msg);
    }
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        // 在这里处理异常
    }
}</code></pre> 
<p></p> 
<h5>四、开发中遇到的问题(暂未解决)</h5> 
<p>1.字符解析器定义之后,接收到的消息仍然乱码</p> 
<p>2.项目启动后,可以访问netty的端口号,但是访问不了项目的端口号(已解决)</p> 
<p><span style="color:#fe2c24;">// future.channel().closeFuture().sync()</span>;把这段代码屏蔽就可以</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8abf5e84582085900c4abe779e27379c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">引领“工作流时代”的AI绘画工具！Comfyui零基础入门操作教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dc0c4c5b62abc77bf65dfd9fc0e0c498/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【数据结构】快速排序</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>