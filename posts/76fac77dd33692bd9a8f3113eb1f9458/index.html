<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构：栈(Stack)的各种操作（入栈，出栈，判断栈非空，判断栈已满，附源码） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/76fac77dd33692bd9a8f3113eb1f9458/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构：栈(Stack)的各种操作（入栈，出栈，判断栈非空，判断栈已满，附源码）">
  <meta property="og:description" content="前言：在前面的文章中，我们讲解了顺序表，单链表，双向链表。而我们今天要分享的栈则是基于之前的数据结构上搭建的，但是相较于顺序表和链表来说，栈的实现就非常简单了。
目录
一.栈(Stack)的概念
二.栈的数据结构
三.栈的实现
判断栈已满
判断栈非空
入栈push
出栈pop
查看栈顶元素
完整代码
Java版本
c语言版
一.栈(Stack)的概念 栈是一种先进后出（LIFO）的数据结构，在其中元素的的添加（称为“入栈”）和删除（称为“出栈”）仅在栈的顶部进行。因此，最后一个插入到栈中的元素是第一个从栈中删除的元素。
它通常有两个主要操作：
push：在栈的顶部插入一个元素。pop：从栈的顶部移除一个元素。 栈的push入栈图解：
栈的pop出栈图解 ：
我们可以看见对于栈的操作，我们都是在栈顶上操作的，先进来的元素会被后面的元素覆盖，而最后一个进来的元素也就是栈顶，因此我们称为先进后出（LIFO）
像传统的狙击步枪的弹夹就属于是一种栈的结构 二.栈的数据结构 对于栈的实现，我们通常使用数组，当然也可以使用链表，不过相对而言数组的实现是更容易的。
而对于一个栈的数据结构，他首先得有存放元素的位置，我们这里选择用数组来存放，其次还得有栈内元素个数的记录：
public class MyStack { public int[] elem; public int usedSize; } 三.栈的实现 对于一个栈，他应该有以下这些功能：
入栈出栈判断栈是否为空判断栈已满查看栈顶元素 判断栈已满 当已经使用的数组的大小等于数组本身的大小的时候，栈就相当于满了
public boolean isFull() { return usedSize == elem.length; } 判断栈非空 当数组内一个元素都没有，也就是已经使用的数组大小为0的时候，栈就是空的
public boolean isEmpety() { return usedSize == 0; } 入栈push 当我们要将元素放入栈内的时候，先进行判断，只有在栈内还有剩余空间的情况下，我们才会进行入栈操作，如果没有剩余空间，我们就进行扩容
public void push(int val) { if (isFull()) { //扩容 elem = Arrays.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-12-12T13:22:49+08:00">
    <meta property="article:modified_time" content="2023-12-12T13:22:49+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构：栈(Stack)的各种操作（入栈，出栈，判断栈非空，判断栈已满，附源码）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p class="img-center"><img alt="" height="325" src="https://images2.imgbox.com/ce/b9/14EsH2qe_o.gif" width="611"></p> 
<hr> 
<blockquote> 
 <p><strong>前言：</strong>在前面的文章中，我们讲解了<strong>顺序表，单链表，双向链表</strong>。而我们今天要分享的栈则是基于之前的数据结构上搭建的，但是相较于顺序表和链表来说，栈的实现就非常简单了。</p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80.%E6%A0%88(Stack)%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#%E4%B8%80.%E6%A0%88%28Stack%29%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">一.栈(Stack)的概念</a></p> 
<p id="%E4%BA%8C.%E6%A0%88%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.%E6%A0%88%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" rel="nofollow">二.栈的数据结构</a></p> 
<p id="%E4%B8%89.%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%E4%B8%89.%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">三.栈的实现</a></p> 
<p id="%E5%88%A4%E6%96%AD%E6%A0%88%E5%B7%B2%E6%BB%A1-toc" style="margin-left:40px;"><a href="#%E5%88%A4%E6%96%AD%E6%A0%88%E5%B7%B2%E6%BB%A1" rel="nofollow">判断栈已满</a></p> 
<p id="%E5%88%A4%E6%96%AD%E6%A0%88%E9%9D%9E%E7%A9%BA-toc" style="margin-left:40px;"><a href="#%E5%88%A4%E6%96%AD%E6%A0%88%E9%9D%9E%E7%A9%BA" rel="nofollow">判断栈非空</a></p> 
<p id="%E5%85%A5%E6%A0%88push-toc" style="margin-left:40px;"><a href="#%E5%85%A5%E6%A0%88push" rel="nofollow">入栈push</a></p> 
<p id="%E5%87%BA%E6%A0%88pop-toc" style="margin-left:40px;"><a href="#%E5%87%BA%E6%A0%88pop" rel="nofollow">出栈pop</a></p> 
<p id="%E6%9F%A5%E7%9C%8B%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0-toc" style="margin-left:40px;"><a href="#%E6%9F%A5%E7%9C%8B%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0" rel="nofollow">查看栈顶元素</a></p> 
<p id="%E5%AE%8C%E6%95%B4-toc" style="margin-left:0px;"><a href="#%E5%AE%8C%E6%95%B4" rel="nofollow">完整代码</a></p> 
<p id="Java%E7%89%88%E6%9C%AC-toc" style="margin-left:40px;"><a href="#Java%E7%89%88%E6%9C%AC" rel="nofollow">Java版本</a></p> 
<p id="c%E8%AF%AD%E8%A8%80%E7%89%88-toc" style="margin-left:40px;"><a href="#c%E8%AF%AD%E8%A8%80%E7%89%88" rel="nofollow">c语言版</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80.%E6%A0%88(Stack)%E7%9A%84%E6%A6%82%E5%BF%B5">一.栈(Stack)的概念</h2> 
<p>栈是一种先进后出（LIFO）的数据结构，在其中元素的的添加（称为“入栈”）和删除（称为“出栈”）仅在栈的顶部进行。因此，最后一个插入到栈中的元素是第一个从栈中删除的元素。</p> 
<p>它通常有两个主要操作：</p> 
<ul><li><strong><span style="background-color:#7b7f82;">push：</span></strong>在栈的顶部插入一个元素。</li><li><strong><span style="background-color:#7b7f82;">pop：</span></strong>从栈的顶部移除一个元素。</li></ul> 
<p>栈的<span style="color:#be191c;"><strong><span style="background-color:#ffd7b9;">push</span></strong></span>入栈图解：</p> 
<p><img alt="" height="268" src="https://images2.imgbox.com/6d/80/D9SrGSNe_o.png" width="471"></p> 
<p>栈的<span style="color:#be191c;"><strong><span style="background-color:#ffd7b9;">pop</span></strong></span>出栈图解 ：</p> 
<p><img alt="" height="301" src="https://images2.imgbox.com/e6/97/bVhkEF8e_o.png" width="471"></p> 
<p>我们可以看见对于栈的操作，我们都是在栈顶上操作的，先进来的元素会被后面的元素覆盖，而最后一个进来的元素也就是栈顶，因此我们称为<span style="color:#be191c;"><strong><span style="background-color:#ffd7b9;">先进后出（LIFO）</span></strong></span></p> 
<p>像传统的狙击步枪的弹夹就属于是一种栈的结构 </p> 
<p><img alt="" height="167" src="https://images2.imgbox.com/d5/57/tm6LTAU1_o.png" width="400"></p> 
<hr> 
<h2 id="%E4%BA%8C.%E6%A0%88%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">二.栈的数据结构</h2> 
<p>对于栈的实现，我们通常使用数组，当然也可以使用链表，不过相对而言数组的实现是更容易的。</p> 
<p>而对于一个栈的数据结构，他首先得有存放元素的位置，我们这里选择用数组来存放，其次还得有栈内元素个数的记录：</p> 
<pre><code class="language-java">public class MyStack {
    public int[] elem;
    public int usedSize;
}
</code></pre> 
<hr> 
<h2 id="%E4%B8%89.%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0">三.栈的实现</h2> 
<p>对于一个栈，他应该有以下这些功能：</p> 
<ul><li><span style="background-color:#7b7f82;">入栈</span></li><li><span style="background-color:#7b7f82;">出栈</span></li><li><span style="background-color:#7b7f82;">判断栈是否为空</span></li><li><span style="background-color:#7b7f82;">判断栈已满</span></li><li><span style="background-color:#7b7f82;">查看栈顶元素</span></li></ul> 
<h3 id="%E5%88%A4%E6%96%AD%E6%A0%88%E5%B7%B2%E6%BB%A1">判断栈已满</h3> 
<p>当已经使用的数组的大小等于数组本身的大小的时候，栈就相当于满了</p> 
<pre><code class="language-java">    public boolean isFull() {
        return usedSize == elem.length;
    }</code></pre> 
<h3 id="%E5%88%A4%E6%96%AD%E6%A0%88%E9%9D%9E%E7%A9%BA">判断栈非空</h3> 
<p>当数组内一个元素都没有，也就是已经使用的数组大小为0的时候，栈就是空的</p> 
<pre><code class="language-java">    public boolean isEmpety() {
        return usedSize == 0;
    }</code></pre> 
<h3 id="%E5%85%A5%E6%A0%88push">入栈push</h3> 
<p>当我们要将元素放入栈内的时候，先进行判断，只有在栈内还有剩余空间的情况下，我们才会进行入栈操作，如果没有剩余空间，我们就进行扩容</p> 
<p><img alt="" height="282" src="https://images2.imgbox.com/82/10/GR0Pwiaf_o.png" width="479"></p> 
<pre><code class="language-java">    public void push(int val) {
        if (isFull()) {
            //扩容
            elem = Arrays.copyOf(elem, elem.length * 2);
        }
        elem[usedSize++] = val;
    }</code></pre> 
<h3 id="%E5%87%BA%E6%A0%88pop">出栈pop</h3> 
<p>出栈前要先进行判断，如果栈内一个元素都没有，那自然是不能进行出栈操作的，我们就抛出一个自定义异常然后抛出；对于正常的出栈操作，我们拿出栈顶的元素，然后让记录数组的个数减一</p> 
<pre><code class="language-java">    public int pop() {
        if (isEmpety()) {
            //栈为空，无法出栈
            throw new EmptyStackException("栈为空，无法弹出");
        }
        int popNumber = elem[usedSize-1];
        usedSize--;
        return popNumber;
    }</code></pre> 
<h3 id="%E6%9F%A5%E7%9C%8B%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0">查看栈顶元素</h3> 
<p>和出栈不一样的是，查看栈顶元素只是将元素拿出来展示，并没有实际上删除这个元素</p> 
<pre><code class="language-java">    public int peek() {
        if (isEmpety()) {
            //栈为空，无法出栈
            throw new EmptyStackException("栈为空，无法弹出");
        }
        return elem[usedSize - 1];
    }</code></pre> 
<hr> 
<h2 id="%E5%AE%8C%E6%95%B4">完整代码</h2> 
<p>栈的整体实现相较于顺序表和链表是非常简单的，这里附上完整代码</p> 
<h3 id="Java%E7%89%88%E6%9C%AC">Java版本</h3> 
<pre><code class="language-java">import java.util.Arrays;

public class MyStack {
    public int[] elem;
    public int usedSize;
    public static int DEFULT_SIZE = 10;
    
    public MyStack() {
        this.elem = new int[DEFULT_SIZE];
    }
    
    public void push(int val) {
        if (isFull()) {
            //扩容
            elem = Arrays.copyOf(elem, elem.length * 2);
        }
        elem[usedSize++] = val;
    }
    
    public int pop() {
        if (isEmpety()) {
            //栈为空，无法出栈
            throw new EmptyStackException("栈为空，无法弹出");
        }
        int popNumber = elem[usedSize-1];
        usedSize--;
        return popNumber;
    }
    
    public int peek() {
        if (isEmpety()) {
            //栈为空，无法出栈
            throw new EmptyStackException("栈为空，无法弹出");
        }
        return elem[usedSize - 1];
    }
    
    public boolean isFull() {
        return usedSize == elem.length;
    }
    
    public boolean isEmpety() {
        return usedSize == 0;
    }

}
</code></pre> 
<h3 id="c%E8%AF%AD%E8%A8%80%E7%89%88">c语言版</h3> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define STACK_SIZE 10

// 定义栈结构体
typedef struct {
    int data[STACK_SIZE];  // 存放数据的数组
    int top;               // 栈顶指针
} Stack;

// 初始化栈
void init_stack(Stack *s) {
    s-&gt;top = -1;  // 栈顶初始化为-1
}

// 判断栈是否为空
int is_empty(Stack *s) {
    return s-&gt;top == -1;
}

// 判断栈是否已满
int is_full(Stack *s) {
    return s-&gt;top == STACK_SIZE-1;
}

// 入栈
void push(Stack *s, int value) {
    if (is_full(s)) {
        printf("Stack overflow\n");
        exit(1);
    }
    s-&gt;data[++s-&gt;top] = value;  // 栈顶指针先加1，再将元素入栈
}

// 出栈
int pop(Stack *s) {
    if (is_empty(s)) {
        printf("Stack underflow\n");
        exit(1);
    }
    return s-&gt;data[s-&gt;top--];  // 先将元素出栈，再将栈顶指针减1
}

// 获取栈顶元素
int peek(Stack *s) {
    if (is_empty(s)) {
        printf("Stack underflow\n");
        exit(1);
    }
    return s-&gt;data[s-&gt;top];
}

</code></pre> 
<hr> 
<hr> 
<hr> 
<p> <img alt="" height="23" src="https://images2.imgbox.com/0e/fd/Na1J3YMr_o.png" width="23"><strong> 本次的分享就到此为止了，希望我的分享能给您带来帮助，也欢迎大家三连支持，你们的点赞就是博主更新最大的动力！</strong><img alt="" height="23" src="https://images2.imgbox.com/47/a7/xBuqZmxO_o.png" width="23"><strong>如有不同意见，欢迎评论区积极讨论交流，让我们一起学习进步！</strong><img alt="" height="23" src="https://images2.imgbox.com/48/30/MyfVNEhB_o.png" width="23"><strong>有相关问题也可以私信博主，评论区和私信都会认真查看的，我们下次再见</strong><img alt="" height="23" src="https://images2.imgbox.com/fb/8b/aYEozkQC_o.png" width="23"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6de0bc5f895ce2b03476a864cc9e62e0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JavaScript随机数生成方法演变：摒弃substr()，安全替代方案详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0690a73b3b1aabbb7a54be8f5e289af9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">手机显示此应用专为旧版android打造,因此可能无法运行，点击应用后闪退的问题解决方案</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>