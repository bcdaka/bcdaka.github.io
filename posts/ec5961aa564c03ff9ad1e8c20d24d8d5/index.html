<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>算法训练 | 图论Part3 | 101.孤岛的总面积、102.沉没孤岛、103.水流问题、104.建造最大岛屿 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/ec5961aa564c03ff9ad1e8c20d24d8d5/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="算法训练 | 图论Part3 | 101.孤岛的总面积、102.沉没孤岛、103.水流问题、104.建造最大岛屿">
  <meta property="og:description" content="目录
101.孤岛的总面积
图论法
102.沉没孤岛
图论法
103.水流问题
图论法
104.建造最大岛屿
图论法
101.孤岛的总面积 题目链接：101. 孤岛的总面积
文章讲解：代码随想录
图论法 代码一：深搜
#include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int dir[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1}; // 保存四个方向 int count; // 统计符合题目要求的陆地空格数量 void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y) { grid[x][y] = 0; count&#43;&#43;; for (int i = 0; i &lt; 4; i&#43;&#43;) { // 向四个方向遍历 int nextx = x &#43; dir[i][0]; int nexty = y &#43; dir[i][1]; // 超过边界 if (nextx &lt; 0 || nextx &gt;= grid.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-04T12:45:36+08:00">
    <meta property="article:modified_time" content="2024-07-04T12:45:36+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">算法训练 | 图论Part3 | 101.孤岛的总面积、102.沉没孤岛、103.水流问题、104.建造最大岛屿</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="101.%E5%AD%A4%E5%B2%9B%E7%9A%84%E6%80%BB%E9%9D%A2%E7%A7%AF-toc" style="margin-left:80px;"><a href="#101.%E5%AD%A4%E5%B2%9B%E7%9A%84%E6%80%BB%E9%9D%A2%E7%A7%AF" rel="nofollow">101.孤岛的总面积</a></p> 
<p id="%E5%9B%BE%E8%AE%BA%E6%B3%95-toc" style="margin-left:120px;"><a href="#%E5%9B%BE%E8%AE%BA%E6%B3%95" rel="nofollow">图论法</a></p> 
<p id="102.%E6%B2%89%E6%B2%A1%E5%AD%A4%E5%B2%9B-toc" style="margin-left:80px;"><a href="#102.%E6%B2%89%E6%B2%A1%E5%AD%A4%E5%B2%9B" rel="nofollow">102.沉没孤岛</a></p> 
<p id="%E5%9B%BE%E8%AE%BA%E6%B3%95-toc" style="margin-left:120px;"><a href="#%E5%9B%BE%E8%AE%BA%E6%B3%95" rel="nofollow">图论法</a></p> 
<p id="103.%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98-toc" style="margin-left:80px;"><a href="#103.%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98" rel="nofollow">103.水流问题</a></p> 
<p id="%E5%9B%BE%E8%AE%BA%E6%B3%95-toc" style="margin-left:120px;"><a href="#%E5%9B%BE%E8%AE%BA%E6%B3%95" rel="nofollow">图论法</a></p> 
<p id="104.%E5%BB%BA%E9%80%A0%E6%9C%80%E5%A4%A7%E5%B2%9B%E5%B1%BF-toc" style="margin-left:80px;"><a href="#104.%E5%BB%BA%E9%80%A0%E6%9C%80%E5%A4%A7%E5%B2%9B%E5%B1%BF" rel="nofollow">104.建造最大岛屿</a></p> 
<p id="%E5%9B%BE%E8%AE%BA%E6%B3%95-toc" style="margin-left:120px;"><a href="#%E5%9B%BE%E8%AE%BA%E6%B3%95" rel="nofollow">图论法</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h4><strong>101.孤岛的总面积 </strong></h4> 
<ul><li> <p>题目链接：<a href="https://kamacoder.com/problempage.php?pid=1173" rel="nofollow" title="101. 孤岛的总面积">101. 孤岛的总面积</a></p> </li><li> <p>文章讲解：<a href="https://www.programmercarl.com/kamacoder/0101.%E5%AD%A4%E5%B2%9B%E7%9A%84%E6%80%BB%E9%9D%A2%E7%A7%AF.html" rel="nofollow" title="代码随想录">代码随想录</a></p> </li></ul> 
<h5 id="%E5%9B%BE%E8%AE%BA%E6%B3%95">图论法</h5> 
<ul><li> <p><strong>代码一：深搜</strong></p> </li></ul> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
int dir[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1}; // 保存四个方向
int count; // 统计符合题目要求的陆地空格数量
void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y) {
    grid[x][y] = 0;
    count++;
    for (int i = 0; i &lt; 4; i++) { // 向四个方向遍历
        int nextx = x + dir[i][0];
        int nexty = y + dir[i][1];
        // 超过边界
        if (nextx &lt; 0 || nextx &gt;= grid.size() || nexty &lt; 0 || nexty &gt;= grid[0].size()) continue;
        // 不符合条件，不继续遍历
        if (grid[nextx][nexty] == 0) continue;

        dfs (grid, nextx, nexty);
    }
    return;
}

int main() {
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0));
    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; m; j++) {
            cin &gt;&gt; grid[i][j];
        }
    }

    // 从左侧边，和右侧边 向中间遍历
    for (int i = 0; i &lt; n; i++) {
        if (grid[i][0] == 1) dfs(grid, i, 0);
        if (grid[i][m - 1] == 1) dfs(grid, i, m - 1);
    }
    // 从上边和下边 向中间遍历
    for (int j = 0; j &lt; m; j++) {
        if (grid[0][j] == 1) dfs(grid, 0, j);
        if (grid[n - 1][j] == 1) dfs(grid, n - 1, j);
    }
    count = 0;
    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; m; j++) {
            if (grid[i][j] == 1) dfs(grid, i, j);
        }
    }
    cout &lt;&lt; count &lt;&lt; endl;
}</code></pre> 
<ul><li> <p><strong>代码二：广搜</strong></p> </li></ul> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
using namespace std;
int count = 0;
int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向
void bfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y) {
    queue&lt;pair&lt;int, int&gt;&gt; que;
    que.push({x, y});
    grid[x][y] = 0; // 只要加入队列，立刻标记
    count++;
    while(!que.empty()) {
        pair&lt;int ,int&gt; cur = que.front(); que.pop();
        int curx = cur.first;
        int cury = cur.second;
        for (int i = 0; i &lt; 4; i++) {
            int nextx = curx + dir[i][0];
            int nexty = cury + dir[i][1];
            if (nextx &lt; 0 || nextx &gt;= grid.size() || nexty &lt; 0 || nexty &gt;= grid[0].size()) continue;  // 越界了，直接跳过
            if (grid[nextx][nexty] == 1) {
                que.push({nextx, nexty});
                count++;
                grid[nextx][nexty] = 0; // 只要加入队列立刻标记
            }
        }
    }
}

int main() {
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0));
    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; m; j++) {
            cin &gt;&gt; grid[i][j];
        }
    }
    // 从左侧边，和右侧边 向中间遍历
    for (int i = 0; i &lt; n; i++) {
        if (grid[i][0] == 1) bfs(grid, i, 0);
        if (grid[i][m - 1] == 1) bfs(grid, i, m - 1);
    }
    // 从上边和下边 向中间遍历
    for (int j = 0; j &lt; m; j++) {
        if (grid[0][j] == 1) bfs(grid, 0, j);
        if (grid[n - 1][j] == 1) bfs(grid, n - 1, j);
    }
    count = 0;
    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; m; j++) {
            if (grid[i][j] == 1) bfs(grid, i, j);
        }
    }

    cout &lt;&lt; count &lt;&lt; endl;
}</code></pre> 
<h4 id="102.%E6%B2%89%E6%B2%A1%E5%AD%A4%E5%B2%9B"><strong>102.沉没孤岛 </strong></h4> 
<ul><li> <p>题目链接：<a href="https://kamacoder.com/problempage.php?pid=1174" rel="nofollow" title="102. 沉没孤岛">102. 沉没孤岛</a></p> </li><li> <p>文章讲解：<a href="https://www.programmercarl.com/kamacoder/0102.%E6%B2%89%E6%B2%A1%E5%AD%A4%E5%B2%9B.html" rel="nofollow" title="代码随想录">代码随想录</a></p> </li></ul> 
<h5>图论法</h5> 
<ul><li> <p><strong>代码一：</strong><strong>dfs</strong></p> </li></ul> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
int dir[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1}; // 保存四个方向
void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y) {
    grid[x][y] = 2;
    for (int i = 0; i &lt; 4; i++) { // 向四个方向遍历
        int nextx = x + dir[i][0];
        int nexty = y + dir[i][1];
        // 超过边界
        if (nextx &lt; 0 || nextx &gt;= grid.size() || nexty &lt; 0 || nexty &gt;= grid[0].size()) continue;
        // 不符合条件，不继续遍历
        if (grid[nextx][nexty] == 0 || grid[nextx][nexty] == 2) continue;
        dfs (grid, nextx, nexty);
    }
    return;
}

int main() {
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0));
    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; m; j++) {
            cin &gt;&gt; grid[i][j];
        }
    }

    // 步骤一：
    // 从左侧边，和右侧边 向中间遍历
    for (int i = 0; i &lt; n; i++) {
        if (grid[i][0] == 1) dfs(grid, i, 0);
        if (grid[i][m - 1] == 1) dfs(grid, i, m - 1);
    }

    // 从上边和下边 向中间遍历
    for (int j = 0; j &lt; m; j++) {
        if (grid[0][j] == 1) dfs(grid, 0, j);
        if (grid[n - 1][j] == 1) dfs(grid, n - 1, j);
    }
    // 步骤二、步骤三
    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; m; j++) {
            if (grid[i][j] == 1) grid[i][j] = 0;
            if (grid[i][j] == 2) grid[i][j] = 1;
        }
    }
    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; m; j++) {
            cout &lt;&lt; grid[i][j] &lt;&lt; " ";
        }
        cout &lt;&lt; endl;
    }
}</code></pre> 
<h4 id="103.%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98">103.水流问题</h4> 
<ul><li> <p>题目链接：<a href="https://kamacoder.com/problempage.php?pid=1175" rel="nofollow" title="103. 水流问题">103. 水流问题</a></p> </li><li> <p>文章讲解：<a href="https://www.programmercarl.com/kamacoder/0103.%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98.html" rel="nofollow" title="代码随想录">代码随想录</a></p> </li></ul> 
<h5>图论法</h5> 
<ul><li> <p><strong>代码一：</strong><strong>dfs</strong></p> </li></ul> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
int n, m;
int dir[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1};
void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x, int y) {
    if (visited[x][y]) return;

    visited[x][y] = true;

    for (int i = 0; i &lt; 4; i++) {
        int nextx = x + dir[i][0];
        int nexty = y + dir[i][1];
        if (nextx &lt; 0 || nextx &gt;= n || nexty &lt; 0 || nexty &gt;= m) continue;
        if (grid[x][y] &gt; grid[nextx][nexty]) continue; // 注意：这里是从低向高遍历

        dfs (grid, visited, nextx, nexty);
    }
    return;
}



int main() {

    cin &gt;&gt; n &gt;&gt; m;
    vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0));

    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; m; j++) {
            cin &gt;&gt; grid[i][j];
        }
    }
    // 标记从第一组边界上的节点出发，可以遍历的节点
    vector&lt;vector&lt;bool&gt;&gt; firstBorder(n, vector&lt;bool&gt;(m, false));

    // 标记从第一组边界上的节点出发，可以遍历的节点
    vector&lt;vector&lt;bool&gt;&gt; secondBorder(n, vector&lt;bool&gt;(m, false));

    // 从最上和最下行的节点出发，向高处遍历
    for (int i = 0; i &lt; n; i++) {
        dfs (grid, firstBorder, i, 0); // 遍历最左列，接触第一组边界
        dfs (grid, secondBorder, i, m - 1); // 遍历最右列，接触第二组边界
    }

    // 从最左和最右列的节点出发，向高处遍历
    for (int j = 0; j &lt; m; j++) {
        dfs (grid, firstBorder, 0, j); // 遍历最上行，接触第一组边界
        dfs (grid, secondBorder, n - 1, j); // 遍历最下行，接触第二组边界
    }
    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; m; j++) {
            // 如果这个节点，从第一组边界和第二组边界出发都遍历过，就是结果
            if (firstBorder[i][j] &amp;&amp; secondBorder[i][j]) cout &lt;&lt; i &lt;&lt; " " &lt;&lt; j &lt;&lt; endl;;
        }
    }


}
</code></pre> 
<h4 id="104.%E5%BB%BA%E9%80%A0%E6%9C%80%E5%A4%A7%E5%B2%9B%E5%B1%BF"><strong>104.建造最大岛屿</strong></h4> 
<ul><li> <p>题目链接：<a href="https://kamacoder.com/problempage.php?pid=1176" rel="nofollow" title="104. 建造最大岛屿">104. 建造最大岛屿</a></p> </li><li> <p>文章讲解：<a href="https://www.programmercarl.com/kamacoder/0104.%E5%BB%BA%E9%80%A0%E6%9C%80%E5%A4%A7%E5%B2%9B%E5%B1%BF.html" rel="nofollow" title="代码随想录">代码随想录</a></p> </li></ul> 
<h5>图论法</h5> 
<ul><li> <p><strong>代码一：深搜</strong></p> </li></ul> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_set&gt;
#include &lt;unordered_map&gt;
using namespace std;
int n, m;
int count;

int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向
void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x, int y, int mark) {
    if (visited[x][y] || grid[x][y] == 0) return; // 终止条件：访问过的节点 或者 遇到海水
    visited[x][y] = true; // 标记访问过
    grid[x][y] = mark; // 给陆地标记新标签
    count++;
    for (int i = 0; i &lt; 4; i++) {
        int nextx = x + dir[i][0];
        int nexty = y + dir[i][1];
        if (nextx &lt; 0 || nextx &gt;= n || nexty &lt; 0 || nexty &gt;= m) continue;  // 越界了，直接跳过
        dfs(grid, visited, nextx, nexty, mark);
    }
}

int main() {
    cin &gt;&gt; n &gt;&gt; m;
    vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0));

    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; m; j++) {
            cin &gt;&gt; grid[i][j];
        }
    }
    vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(m, false)); // 标记访问过的点
    unordered_map&lt;int ,int&gt; gridNum;
    int mark = 2; // 记录每个岛屿的编号
    bool isAllGrid = true; // 标记是否整个地图都是陆地
    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; m; j++) {
            if (grid[i][j] == 0) isAllGrid = false;
            if (!visited[i][j] &amp;&amp; grid[i][j] == 1) {
                count = 0;
                dfs(grid, visited, i, j, mark); // 将与其链接的陆地都标记上 true
                gridNum[mark] = count; // 记录每一个岛屿的面积
                mark++; // 记录下一个岛屿编号
            }
        }
    }
    if (isAllGrid) {
        cout &lt;&lt; n * m &lt;&lt; endl; // 如果都是陆地，返回全面积
        return 0; // 结束程序
    }

    // 以下逻辑是根据添加陆地的位置，计算周边岛屿面积之和
    int result = 0; // 记录最后结果
    unordered_set&lt;int&gt; visitedGrid; // 标记访问过的岛屿
    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; m; j++) {
            count = 1; // 记录连接之后的岛屿数量
            visitedGrid.clear(); // 每次使用时，清空
            if (grid[i][j] == 0) {
                for (int k = 0; k &lt; 4; k++) {
                    int neari = i + dir[k][1]; // 计算相邻坐标
                    int nearj = j + dir[k][0];
                    if (neari &lt; 0 || neari &gt;= n || nearj &lt; 0 || nearj &gt;= m) continue;
                    if (visitedGrid.count(grid[neari][nearj])) continue; // 添加过的岛屿不要重复添加
                    // 把相邻四面的岛屿数量加起来
                    count += gridNum[grid[neari][nearj]];
                    visitedGrid.insert(grid[neari][nearj]); // 标记该岛屿已经添加过
                }
            }
            result = max(result, count);
        }
    }
    cout &lt;&lt; result &lt;&lt; endl;

}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2b35554eec758605159b9c8ade89169b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【人工智能】GPT-5的即将到来：从高中生进化到,,,博士生？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/83a2f27e88929f54e561a5a213bcf6ea/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MATLAB常用语句总结7</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>