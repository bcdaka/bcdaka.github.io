<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深挖Redis分布式缓存：你还在为缓存架构感到困惑吗？灵办AI为你揭开文献背后的秘密！ - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/0866e82a9c4f3a5c5b08cbcd3994020e/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="深挖Redis分布式缓存：你还在为缓存架构感到困惑吗？灵办AI为你揭开文献背后的秘密！">
  <meta property="og:description" content="文章目录 1 灵办AI插件2 翻译~外文文献3 解释~文献标题分析4 文档解析~文献总结5 搜索~全网搜索总结6 总体评价~文献代码分析总结 本文将引用 Research and Application of Distributed Cache Based on Redis [1] 外文文献解读为案例进行剥削，进而提高对 Redis的分布式缓存技术的认知，教你如何使用灵办AI插件来逐层剥削，从而揭开文献背后的秘密！
1 灵办AI插件 今天我要给大家分享一款超实用的神器——灵办AI！和那些专攻表格处理的 Chat Excel，或者生成酷炫图片的 Midjourney 不一样，灵办AI可是个全能小帮手。它不仅会智能聊天，还能帮你翻译网页、总结阅读、分析文档，甚至在各种场景下帮你搞定写作！是不是很不错？功能多到让人忍不住想要马上试一试！
体验链接：https://ilingban.com/browser_extension/?from=ysy
安装灵办的方式超级简单，目前它支持网页版、插件版和小程序版，云端还能无缝同步信息。日常工作习惯使用使用Edge浏览器，下方是安装方式，点击获取即可安装！
更妙的是，灵办AI就像个小精灵，安安静静地待在桌面的一角，随时等你召唤，轻轻一点就能用！功能丰富，用起来效果还挺不错，起初还会定制化给你设定模型角色，让AI生成的内容更加符合自身的职业定位，让内容显得更加专业，更符合我们的需求。
2 翻译~外文文献 对于想要解读外文文献，往往会因为英语不熟悉或者有些词语不记得了等问题，让阅读外文文献举步维艰。或者将内容copy拿去翻译，步骤较为繁琐，也有一些翻译插件，翻译出来的文章，效果很不理想。
但是现在需要翻译的文档，有很多快捷的方式，比如将文档拖进灵办，或者点击翻译的小组件，或者选中想要翻译的文字，再点击翻译功能，分分钟帮你搞定！灵办AI的翻译引擎是由顶尖大模型加持，翻译效果非常的精准地道，简直就是你的小翻译精灵，帮你轻松应对各种场合！
不过也遇到了点击翻译功能，只翻译了菜单和部分内容，应该是对一些有特殊设计的网站，内容抓取方式不同，导致有些内容没抓取到的原因，有待完善哦~
不过呢~对于无法正确抓取的内容或者不需要全文翻译的场景，可以使用选中的方式进行抓取进行翻译，我比较喜欢这一种翻译的方式，既简单又高效，还能提高英语阅读能力，或者使用总结、搜索、解释、无格式复制等功能。
第一句翻译效果：作为传统的关系型数据库，MySQL提供完整的ACID操作，支持丰富的数据类型，强大的关联查询，where语句等，可以方便地建立查询索引，执行内部连接、外部连接、求和、排序、分组等复杂操作，并支持存储过程等功能。
3 解释~文献标题分析 当遇到一段不太明白的内容，选中它后，灵办马上会给我提供清晰的解释（还会使用比喻等手法，将内容简单化，易于理解）和简洁的总结，以及扩展内容，非常的贴心。
我对文献的标题进行选中，接着解释的内容也相当人性化，从标题就大致了解整篇文献的大致内容，给接下来的阅读文献提供了有力的知识支持。
4 文档解析~文献总结 对于想下载文献的uu们，可以看左下角有个[PDF]，点击下载即可。接着可以将PDF上传给灵办，让它帮你总结文献的大致内容。
总结文献的效果：
总结
本文研究了基于Redis的分布式缓存系统及其在提升数据库性能方面的应用。文章首先指出了传统关系型数据库（如MySQL）在面临大规模数据访问时，磁盘I/O成为性能瓶颈的问题。特别是在复杂的电信业务场景中，高频次的数据访问会直接导致数据库负载增加和效率降低。为解决这一问题，文章提出了一种基于Redis的分布式缓存系统方案。
要点
问题背景： MySQL等传统关系型数据库在处理大规模数据和高并发访问时存在性能瓶颈。电信业务中的高频数据访问（如产品实例、销售产品实例、规格、账户等）直接导致数据库负载高和效率低。 解决方案： 提出了基于Redis的分布式缓存系统，旨在解决大规模和高并发数据库访问导致的磁盘I/O性能瓶颈。Redis是一个内存基础的、持久化、高性能、高可靠性和水平可扩展的分布式NoSQL内存数据库产品。 Redis特点： 支持子数据库和子表的内存管理。提供灾难恢、监控、迁移等能力。支持API透明访问。 系统优势： 低延迟、高性能、高可用性和高可扩展性。支持复杂业务对象的表示。 实验系统数据： 提供了实验系统中不同缓存实例的峰值、均值、占用空间等具体数据，展示了Redis在不同业务场景下的应用效果。 结论： 文章提出的基于Redis的分布式缓存系统是一个能够有效提升数据库性能的解决方案。该系统具有低延迟、高性能、高可用性和高可扩展性的特点，适用于复杂业务场景。 版权信息： 文章以开放获取形式发布，遵循Creative Commons Attribution License (CC BY 4.0)，允许在正确引用原文的情况下自由使用、分发和再生产。 你可能还想问我：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-15T17:32:15+08:00">
    <meta property="article:modified_time" content="2024-08-15T17:32:15+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深挖Redis分布式缓存：你还在为缓存架构感到困惑吗？灵办AI为你揭开文献背后的秘密！</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/1c/67/mue9k5MM_o.gif" alt="在这里插入图片描述"></p> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#1_AI_6" rel="nofollow">1 灵办AI插件</a></li><li><a href="#2__22" rel="nofollow">2 翻译~外文文献</a></li><li><a href="#3__41" rel="nofollow">3 解释~文献标题分析</a></li><li><a href="#4__50" rel="nofollow">4 文档解析~文献总结</a></li><li><a href="#5__94" rel="nofollow">5 搜索~全网搜索总结</a></li><li><a href="#6__101" rel="nofollow">6 总体评价~文献代码分析总结</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<blockquote> 
 <p>本文将引用 <code>Research and Application of Distributed Cache Based on Redis</code> [1] 外文文献解读为案例进行剥削，进而提高对 Redis的分布式缓存技术的认知，教你如何使用灵办AI插件来逐层剥削，从而揭开文献背后的秘密！</p> 
</blockquote> 
<h3><a id="1_AI_6"></a>1 灵办AI插件</h3> 
<p>今天我要给大家分享一款超实用的神器——灵办AI！和那些专攻表格处理的 Chat Excel，或者生成酷炫图片的 Midjourney 不一样，灵办AI可是个全能小帮手。它不仅会智能聊天，还能帮你翻译网页、总结阅读、分析文档，甚至在各种场景下帮你搞定写作！是不是很不错？功能多到让人忍不住想要马上试一试！</p> 
<p><strong>体验链接：</strong><a href="https://ilingban.com/browser_extension/?from=ysy" rel="nofollow">https://ilingban.com/browser_extension/?from=ysy</a></p> 
<p>安装灵办的方式超级简单，目前它支持网页版、插件版和小程序版，云端还能无缝同步信息。日常工作习惯使用使用Edge浏览器，下方是安装方式，点击获取即可安装！<br> <img src="https://images2.imgbox.com/62/8a/dC2ldBGE_o.png" alt="在这里插入图片描述"></p> 
<p>更妙的是，灵办AI就像个小精灵，安安静静地待在桌面的一角，随时等你召唤，轻轻一点就能用！功能丰富，用起来效果还挺不错，起初还会定制化给你设定模型角色，让AI生成的内容更加符合自身的职业定位，让内容显得更加专业，更符合我们的需求。</p> 
<p><img src="https://images2.imgbox.com/0a/41/jOGpCwjn_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2__22"></a>2 翻译~外文文献</h3> 
<p>对于想要解读外文文献，往往会因为英语不熟悉或者有些词语不记得了等问题，让阅读外文文献举步维艰。或者将内容copy拿去翻译，步骤较为繁琐，也有一些翻译插件，翻译出来的文章，效果很不理想。</p> 
<p>但是现在需要翻译的文档，有很多快捷的方式，比如将文档拖进灵办，或者点击翻译的小组件，或者选中想要翻译的文字，再点击翻译功能，分分钟帮你搞定！灵办AI的翻译引擎是由顶尖大模型加持，翻译效果非常的精准地道，简直就是你的小翻译精灵，帮你轻松应对各种场合！</p> 
<p>不过也遇到了点击翻译功能，只翻译了菜单和部分内容，应该是对一些有特殊设计的网站，内容抓取方式不同，导致有些内容没抓取到的原因，有待完善哦~</p> 
<p><img src="https://images2.imgbox.com/fe/bc/KH3hc9co_o.png" alt="在这里插入图片描述"></p> 
<p>不过呢~对于无法正确抓取的内容或者不需要全文翻译的场景，可以使用选中的方式进行抓取进行翻译，我比较喜欢这一种翻译的方式，既简单又高效，还能提高英语阅读能力，或者使用总结、搜索、解释、无格式复制等功能。</p> 
<p><img src="https://images2.imgbox.com/12/a7/3gcuLKzO_o.png" alt="在这里插入图片描述"></p> 
<p><strong>第一句翻译效果</strong>：作为传统的关系型数据库，MySQL提供完整的ACID操作，支持丰富的数据类型，强大的关联查询，where语句等，可以方便地建立查询索引，执行内部连接、外部连接、求和、排序、分组等复杂操作，并支持存储过程等功能。</p> 
<h3><a id="3__41"></a>3 解释~文献标题分析</h3> 
<p>当遇到一段不太明白的内容，选中它后，灵办马上会给我提供清晰的解释（还会使用比喻等手法，将内容简单化，易于理解）和简洁的总结，以及扩展内容，非常的贴心。</p> 
<p>我对文献的标题进行选中，接着解释的内容也相当人性化，从标题就大致了解整篇文献的大致内容，给接下来的阅读文献提供了有力的知识支持。</p> 
<p><img src="https://images2.imgbox.com/a5/de/eMdfcgoG_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4__50"></a>4 文档解析~文献总结</h3> 
<p>对于想下载文献的uu们，可以看左下角有个<code>[PDF]</code>，点击下载即可。接着可以将PDF上传给灵办，让它帮你总结文献的大致内容。</p> 
<p><img src="https://images2.imgbox.com/97/f4/dVVXlb0P_o.png" alt="在这里插入图片描述"></p> 
<p><strong>总结文献的效果：</strong></p> 
<p><strong>总结</strong></p> 
<p>本文研究了基于Redis的分布式缓存系统及其在提升数据库性能方面的应用。文章首先指出了传统关系型数据库（如MySQL）在面临大规模数据访问时，磁盘I/O成为性能瓶颈的问题。特别是在复杂的电信业务场景中，高频次的数据访问会直接导致数据库负载增加和效率降低。为解决这一问题，文章提出了一种基于Redis的分布式缓存系统方案。</p> 
<p><strong>要点</strong></p> 
<ol><li><strong>问题背景</strong>： 
  <ul><li>MySQL等传统关系型数据库在处理大规模数据和高并发访问时存在性能瓶颈。</li><li>电信业务中的高频数据访问（如产品实例、销售产品实例、规格、账户等）直接导致数据库负载高和效率低。</li></ul> </li><li><strong>解决方案</strong>： 
  <ul><li>提出了基于Redis的分布式缓存系统，旨在解决大规模和高并发数据库访问导致的磁盘I/O性能瓶颈。</li><li>Redis是一个内存基础的、持久化、高性能、高可靠性和水平可扩展的分布式NoSQL内存数据库产品。</li></ul> </li><li><strong>Redis特点</strong>： 
  <ul><li>支持子数据库和子表的内存管理。</li><li>提供灾难恢、监控、迁移等能力。</li><li>支持API透明访问。</li></ul> </li><li><strong>系统优势</strong>： 
  <ul><li>低延迟、高性能、高可用性和高可扩展性。</li><li>支持复杂业务对象的表示。</li></ul> </li><li><strong>实验系统数据</strong>： 
  <ul><li>提供了实验系统中不同缓存实例的峰值、均值、占用空间等具体数据，展示了Redis在不同业务场景下的应用效果。</li></ul> </li><li><strong>结论</strong>： 
  <ul><li>文章提出的基于Redis的分布式缓存系统是一个能够有效提升数据库性能的解决方案。</li><li>该系统具有低延迟、高性能、高可用性和高可扩展性的特点，适用于复杂业务场景。</li></ul> </li><li><strong>版权信息</strong>： 
  <ul><li>文章以开放获取形式发布，遵循Creative Commons Attribution License (CC BY 4.0)，允许在正确引用原文的情况下自由使用、分发和再生产。</li></ul> </li></ol> 
<hr> 
<p>你可能还想问我：</p> 
<ol><li>Redis作为分布式缓存技术，在本文中是如何被研究并应用于提高数据库性能的？</li><li>本文提到的MySQL数据库的ACID特性以及丰富数据类型在分布式缓存系统中起到了哪些作用或影响？</li><li>分布式缓存技术在实际应用中可能遇到哪些挑战？本文提出了哪些解决方案或改进措施？</li></ol> 
<h3><a id="5__94"></a>5 搜索~全网搜索总结</h3> 
<p>对于需要搜索的内容，灵办AI会在侧边进行分析，并总结出需要的答案进行呈现，大大减少了人工检索内容的时间，提高了工作的效率。</p> 
<p><img src="https://images2.imgbox.com/f3/62/1y7X0EaG_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="6__101"></a>6 总体评价~文献代码分析总结</h3> 
<p>接着对文献出现的代码片段进行分析和总结，分析出在分布式系统中处理库存减少的两种不同方法，让我们接着往下看叭~</p> 
<p><img src="https://images2.imgbox.com/1c/50/02FDj8yb_o.png" alt="在这里插入图片描述"></p> 
<p><strong>代码注释与总结</strong></p> 
<p><strong>示例方案 1:</strong></p> 
<pre><code class="prism language-java"><span class="token comment">// 这是一个使用Redis的decrBy命令来减少库存的函数，不涉及复杂的冲突解决机制。</span>
<span class="token comment">// 假设没有冲突的库存减少原子函数，并且正在执行库存判断。</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">decreaseFunction2</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token keyword">long</span> value<span class="token punctuation">,</span> <span class="token class-name">Jedis</span> jedis<span class="token punctuation">,</span> <span class="token keyword">int</span> retryNumber<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 使用jedis的decrBy方法尝试减少key对应的值（库存），减少的量为value</span>
    <span class="token comment">// 注意：这里硬编码了减少1，但函数参数传入的是value，应该使用value</span>
    <span class="token class-name">Long</span> remain <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">decrBy</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 修正为使用value作为减少的量</span>
    <span class="token comment">// 返回剩余库存是否大于0</span>
    <span class="token keyword">return</span> remain<span class="token punctuation">.</span><span class="token function">longValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 注意：原代码中decrBy的调用错误地使用了1作为减少量，已修正为使用传入的value参数。</span>
</code></pre> 
<p><strong>示例方案 2:</strong></p> 
<pre><code class="prism language-java"><span class="token comment">// 使用乐观锁客户端的乐观锁机制来实现库存减少，确保操作的原子性和一致性。</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">decreaseFunction</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token keyword">long</span> value<span class="token punctuation">,</span> <span class="token class-name">VProxyJedis</span> vjedis<span class="token punctuation">,</span> <span class="token keyword">int</span> retryNumber<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 操作成功的标志</span>
    <span class="token comment">// 当减库存操作失败时，根据重试次数进行重试</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>retryNumber <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 原子操作1：通过vget获取当前key对应的值和版本号</span>
            <span class="token class-name">VersionResult</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> vjedis<span class="token punctuation">.</span><span class="token function">vget</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 判断剩余库存量是否足够</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token function">parseLong</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span> value<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 原子操作2：基于当前条件确定的版本号更新库存（剩余量 - 销售量）</span>
                <span class="token comment">// 注意：原代码中vdecrBy的参数拼写错误，已修正</span>
                vjedis<span class="token punctuation">.</span><span class="token function">vdecrBy</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> result<span class="token punctuation">.</span><span class="token function">getVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 修正为getVersion()</span>
                <span class="token comment">// 库存扣除成功，设置操作成功标志</span>
                flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 如果其他进程修改了数据，则会发生版本号冲突</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">ErrorMessage_DiffVersion</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 假设这是正确的错误码名称，注意拼写</span>
                flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 设置操作成功标志为false</span>
                retryNumber<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">// 减去重试次数，通过while循环继续操作</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> flag<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 注意：</span>
<span class="token comment">// 1. 代码中假设了ErrorMessage_DiffVersion是版本号冲突的错误码，实际使用时需要确认正确的错误码。</span>
<span class="token comment">// 2. vjedis.vdecrBy的参数拼写错误已修正，原代码中为result.getVersion()，应为result.getVersion()。</span>
<span class="token comment">// 3. 示例展示了如何在存在并发修改时，通过乐观锁机制保证库存扣减的准确性和一致性。</span>
</code></pre> 
<p><strong>总结</strong></p> 
<p>这两个示例展示了在分布式系统中处理库存减少的两种不同方法。第一种方法简单直接，使用Redis的decrBy命令减少库存，但不适用于需要处理并发修改的场景。第二种方法则采用了乐观锁机制，通过版本号来确保库存扣减的原子性和一致性，适用于高并发的场景。通过重试机制，可以在出现版本号冲突时重新尝试操作，直到成功或达到最大重试次数为止。</p> 
<p>总体来说， 灵办AI的体验感非常不错，是一款非常好用的国产应用。毕竟在使用的习惯上，国人最懂国人啦。而且让我意外的是，这款应用十分的简洁易用，我用了大半天，上手也是相当顺手，体验感满满的。</p> 
<p>[1] Shi* L ,Qiao H ,Yang C , et al.Research and Application of Distributed Cache Based on Redis[J].Journal of Software,2024,19(1):</p> 
<p><code>即使在纷繁复杂的事务中，也要保持内心的宁静与专注</code></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7e185ee92af06df1c4cc0aad285cb1c8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">每日一题-贪心算法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/380d218cf0c619d4f2dbcb371307f5c7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">云原生和安装Ubuntu 22系统</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>