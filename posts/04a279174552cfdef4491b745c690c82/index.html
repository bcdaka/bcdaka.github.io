<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>《故障复盘 · 记一次事务用法错误导致的大量锁表问题》 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/04a279174552cfdef4491b745c690c82/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="《故障复盘 · 记一次事务用法错误导致的大量锁表问题》">
  <meta property="og:description" content="📢 大家好，我是 【战神刘玉栋】，有10多年的研发经验，致力于前后端技术栈的知识沉淀和传播。 💗
🌻 CSDN入驻不久，希望大家多多支持，后续会继续提升文章质量，绝不滥竽充数，如需交流，欢迎留言评论。👍
文章目录 写在前面的话故障描述排查过程排查前期排查过程 1排查过程 2排查过程 3排查结论 知识拓展事务前置知识回到上述问题关于手动控制关于事务封装问题排查经验事务使用经验 总结陈词 写在前面的话 博主所在公司的产品线，部署上线了多家客户，遇到的线上故障的场景也较多，这里新开一个故障复盘系列，记录并分享一下这些故障的的定位、分析、解决过程。
首先分享的这篇，是排查定位耗时较久的一个由于事务用法错误，导致的大量锁表，进而引发大范围故障的问题。
故障描述 某客户线上环境的死锁问题持续了一个多月了，隔一天会出现一次，业务侧的代码，陆续调整过几次，但都治标不治本。
现象大概是，业务高峰期（9点-9点30），会出现大量锁表，DBA介入杀锁有时候仍无法正常，需要搭配重启相关服务才可以。
相关报错截图如下所示：
由于影响越来越大，公司领导组织研发骨干，针对DBA提供的数据库锁表语法.xslt，以此为突破口进行技术攻关，最终发现了相关问题代码，修正后故障得到恢复，这里针对本次故障进行复盘总结，交流分享排查经验和事务用法。
排查过程 排查前期 【DBA发出锁表Excel】
2024-03-20下午，DBA发出了锁表语法，如下图所示，发现单个事务就执行了大量的语法，9点10分开始事务，9点25失败回滚，持续了15分钟的事务（该事务包含了 976 个语法）。
【分析锁表业务语法特征】
通过分析上面的数据库锁表语法发现里面涉及到的语法并不是来源于同一个接口，且业务范围也各不相同，说明各个不同业务的数据库操作都被嵌入到了同一个事务当中，且定位到锁表语法来自于收费服务，后续开始重点排查收费服务项目。
【组织人员排查】
Excel 暴露出一些问题：
这些语法背后的数据确实没入库，但为何用户没有反馈问题语法涉及的接口看日志是操作成功了，但是为何数据没入库为什么这么多语句会在同一个事务中一起 rollback 疑问点比较多，但可以先从“为什么接口成功了，但数据确没有入库”这一点来分析。
排查过程 1 通过Excel提供的信息，结合应用日志分析，定位到收费服务的encounterCardInfoAdd是属于有问题的接口。
从应用日志看，该接口基本都是INFO，即操作成功的。
接口完整地址：[HTTP] /open/thirdParty/physical/encounterCardInfoAdd
但是比对了SkyWalking，确实DBA反馈的Excel里面合并到一个事务的SQL，所在的接口在SkyWaling看就是没有 commit。
然后该接口的正常的情况，看日志是有commit的，如下图，89ba3310ce46ffa2 没提交，ef65b1e6ea8a2280有提交 查看代码，除了一些规范问题，并没有看到什么不妥之处，也没有手动控制事务。
但没有定位到，为什么会有这种接口成功，但是没有commit或rollback的情况。
排查过程 2 上面接口上没看出来问题，那就继续观察现场环境，发现下面两个异常点。
1、锁的高峰期，收费控制台日志有大量异常：
Closed Connection org.springframework.dao.RecoverableDataAccessException: ### Error querying database. Cause: java.sql.SQLRecoverableException: Closed Connection
30分钟2000个，其中9点28分，1分钟有500个。
其他服务和其他时间段都没有。
2、锁的高峰期，从prometheus看，收费的数据库连接数比其他服务高很多，同时段其他服务，或非该时段，收费的连接数正常。
从上面两个点，可以得出的结论是，出现锁问题的时间段，确实收费服务的数据库连接是有问题的。
结合之前排查来看，感觉大概率和手动开启事务但没操作回滚提交有关系，应该和TransactionSynchronizationManager.registerSynchronization关系不大。
继续测试了一下，只要有手动开启事务，但没有提交。
这次事务里面又有for update语句，那数据就会一直处于锁状态，这时候其他也锁同样数据的接口，将被阻塞。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-11T09:20:03+08:00">
    <meta property="article:modified_time" content="2024-07-11T09:20:03+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">《故障复盘 · 记一次事务用法错误导致的大量锁表问题》</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>📢 大家好，我是 【战神刘玉栋】，有10多年的研发经验，致力于前后端技术栈的知识沉淀和传播。 💗<br> 🌻 CSDN入驻不久，希望大家多多支持，后续会继续提升文章质量，绝不滥竽充数，如需交流，欢迎留言评论。👍</p> 
</blockquote> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#_9" rel="nofollow">写在前面的话</a></li><li><a href="#_15" rel="nofollow">故障描述</a></li><li><a href="#_24" rel="nofollow">排查过程</a></li><li><ul><li><a href="#_26" rel="nofollow">排查前期</a></li><li><a href="#_1_46" rel="nofollow">排查过程 1</a></li><li><a href="#_2_59" rel="nofollow">排查过程 2</a></li><li><a href="#_3_81" rel="nofollow">排查过程 3</a></li><li><a href="#_101" rel="nofollow">排查结论</a></li></ul> 
   </li><li><a href="#_107" rel="nofollow">知识拓展</a></li><li><ul><li><a href="#_112" rel="nofollow">事务前置知识</a></li><li><a href="#_132" rel="nofollow">回到上述问题</a></li><li><a href="#_142" rel="nofollow">关于手动控制</a></li><li><a href="#_194" rel="nofollow">关于事务封装</a></li><li><a href="#_283" rel="nofollow">问题排查经验</a></li><li><a href="#_292" rel="nofollow">事务使用经验</a></li></ul> 
   </li><li><a href="#_322" rel="nofollow">总结陈词</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h3><a id="_9"></a>写在前面的话</h3> 
<p>博主所在公司的产品线，部署上线了多家客户，遇到的线上故障的场景也较多，这里新开一个<code>故障复盘</code>系列，记录并分享一下这些故障的的定位、分析、解决过程。<br> 首先分享的这篇，是排查定位耗时较久的一个由于事务用法错误，导致的大量锁表，进而引发大范围故障的问题。</p> 
<hr> 
<h3><a id="_15"></a>故障描述</h3> 
<p>某客户线上环境的死锁问题持续了一个多月了，隔一天会出现一次，业务侧的代码，陆续调整过几次，但都治标不治本。<br> 现象大概是，业务高峰期（9点-9点30），会出现大量锁表，DBA介入杀锁有时候仍无法正常，需要搭配重启相关服务才可以。<br> 相关报错截图如下所示：<br> <img src="https://images2.imgbox.com/69/de/ShlgHn7e_o.png" alt="image.png"><img src="https://images2.imgbox.com/0d/5b/xroMECXB_o.png" alt="image.png"><br> 由于影响越来越大，公司领导组织研发骨干，针对DBA提供的<code>数据库锁表语法.xslt</code>，以此为突破口进行技术攻关，最终发现了相关问题代码，修正后故障得到恢复，这里针对本次故障进行复盘总结，交流分享排查经验和事务用法。</p> 
<hr> 
<h3><a id="_24"></a>排查过程</h3> 
<h4><a id="_26"></a>排查前期</h4> 
<p><strong>【DBA发出锁表Excel】</strong><br> 2024-03-20下午，DBA发出了锁表语法，如下图所示，发现单个事务就执行了大量的语法，9点10分开始事务，9点25失败回滚，持续了15分钟的事务（该事务包含了 976 个语法）。<br> <img src="https://images2.imgbox.com/7e/49/URw32EPv_o.png" alt="image.png"></p> 
<p><strong>【分析锁表业务语法特征】</strong><br> 通过分析上面的数据库锁表语法发现里面涉及到的语法并不是来源于同一个接口，且业务范围也各不相同，说明各个不同业务的数据库操作都被嵌入到了同一个事务当中，且定位到锁表语法来自于收费服务，后续开始重点排查收费服务项目。</p> 
<p><strong>【组织人员排查】</strong><br> Excel 暴露出一些问题：</p> 
<ul><li>这些语法背后的数据确实没入库，但为何用户没有反馈问题</li><li>语法涉及的接口看日志是操作成功了，但是为何数据没入库</li><li>为什么这么多语句会在同一个事务中一起 rollback</li></ul> 
<p>疑问点比较多，但可以先从“为什么接口成功了，但数据确没有入库”这一点来分析。</p> 
<hr> 
<h4><a id="_1_46"></a>排查过程 1</h4> 
<p>通过<code>Excel</code>提供的信息，结合<code>应用日志</code>分析，定位到收费服务的<code>encounterCardInfoAdd</code>是属于有问题的接口。<br> 从应用日志看，该接口基本都是INFO，即操作成功的。<br> 接口完整地址：[HTTP] /open/thirdParty/physical/encounterCardInfoAdd<br> 但是比对了<code>SkyWalking</code>，确实DBA反馈的<code>Excel</code>里面合并到一个事务的SQL，所在的接口在<code>SkyWaling</code>看就是没有 commit。<br> <img src="https://images2.imgbox.com/90/04/rMaI9Xcl_o.png" alt="image.png"><br> 然后该接口的正常的情况，看日志是有commit的，如下图，89ba3310ce46ffa2 没提交，ef65b1e6ea8a2280有提交 <br> <img src="https://images2.imgbox.com/ee/a7/A6Emksbb_o.png" alt="image.png"><br> 查看代码，除了一些规范问题，并没有看到什么不妥之处，也没有手动控制事务。<br> 但没有定位到，为什么会有这种接口成功，但是没有commit或rollback的情况。</p> 
<hr> 
<h4><a id="_2_59"></a>排查过程 2</h4> 
<p>上面接口上没看出来问题，那就继续观察现场环境，发现下面两个异常点。<br> 1、锁的高峰期，收费控制台日志有大量异常：<br> Closed Connection org.springframework.dao.RecoverableDataAccessException: ### Error querying database. Cause: java.sql.SQLRecoverableException: Closed Connection<br> 30分钟2000个，其中9点28分，1分钟有500个。<br> 其他服务和其他时间段都没有。<br> <img src="https://images2.imgbox.com/37/8a/dNUhpOxB_o.png" alt="image[1].png"><br> 2、锁的高峰期，从prometheus看，收费的数据库连接数比其他服务高很多，同时段其他服务，或非该时段，收费的连接数正常。<br> <img src="https://images2.imgbox.com/4b/83/GuNl7k69_o.png" alt="image[1].png"><br> <img src="https://images2.imgbox.com/39/f1/PducbxiK_o.png" alt="在这里插入图片描述"></p> 
<p>从上面两个点，可以得出的结论是，出现锁问题的时间段，确实收费服务的数据库连接是有问题的。<br> 结合之前排查来看，感觉大概率和手动开启事务但没操作回滚提交有关系，应该和TransactionSynchronizationManager.registerSynchronization关系不大。<br> 继续测试了一下，只要有手动开启事务，但没有提交。<br> 这次事务里面又有for update语句，那数据就会一直处于锁状态，这时候其他也锁同样数据的接口，将被阻塞。<br> 如果请求量又比较大，就会出现杀完锁，又马上出现锁的情况。<br> 之前现场有反馈，每次出现问题，必须重启收费，才可以正常，应该也是重启后才真正释放了链接。<br> 这种手动开启事务未提交，比较贴合昨天Skywaling没提交但是接口没报错，以及现场的日志耗时情况。<br> 至于小孙发的Excel，目前还不好判断。怀疑是程序重启或者触发了回收机制，一次性rollbabck了，但目前貌似druid没配置回收。</p> 
<hr> 
<h4><a id="_3_81"></a>排查过程 3</h4> 
<p>继续通过<code>Excel</code>，结合<code>应用日志</code>分析，收费服务的<code>savePrescriptionToHospital</code>方法也可能存在问题。<br> 接口完整地址：[HTTP] /open/internetHospital/savePrescriptionToHospital<br> 接口链路ID：ce07a0a7f900548a<br> 接口触发时间：2024-03-20 09:09:52.292<br> 接口现象如下：<br> 1、该接口发生在问题产生的时间段，接口显示成功，但是可以看到相关语法在上面的 Excel 却显示了回滚；<br> 2、查看SkyWaling，也看到了前面类似的情况（有的有commit、有的没有）；<br> 3、查看该接口的关联日志，该接口请求了医嘱的<code>saveSelectedRecords</code>，该接口存在异常；<br> 通过查看代码，发现了问题，如下图所示：该接口的子方法中，手动开启了事务，但在调用医嘱接口，报错的时候，没有做任何处理，导致是否没有提交或回滚。<br> <img src="https://images2.imgbox.com/bd/78/kyKYBaDg_o.png" alt="企业微信截图_17109850224097.png"><br> 上面的代码并未使用 try-catch 来保证事务开启后一定会被提交或者回滚，结合该接口对应的链路追踪信息，可以发现在调用 this.saveSelectedRecords 时抛出了异常。于是该事务一直处于开启状态，后续复用该连接的请求，对数据库进行操作时会默认被该事务管理。<br> <img src="https://images2.imgbox.com/a2/78/ylTb61bs_o.png" alt="image.png"></p> 
<p><strong>【另一种思路】</strong><br> 当没有发现问题接口的情况下，出现上述没有commit的情况。<br> 另外一个思路就是，如果正常通过框架提供的 @Transactional 来进行数据库事务操作，是不可能出现不同接口的数据库操作被关联到同一个事务的情况，所以上述的情况只能是开发者使用了 Spring 事务管理器<code>DataSourceTransactionManager</code>来手动管理各个事务阶段提交的场景，且开启后未正确处理相关异常等逻辑，没有及时关闭，导致数据库事务一致处于开启状态。</p> 
<hr> 
<h4><a id="_101"></a>排查结论</h4> 
<p>故障的原因是因为收费服务下的某个接口，没有正确使用Spring事务管理器，手动开启事务后，当程序发生异常，没有做出相应的处理，导致事务一直处于开启状态。<br> 同时，这些开启的事务被绑定到了 <code>Tomcat</code> 的请求连接池中，当其他请求进来复用了这些请求连接时，会自动持有之前未关闭的事务，这导致不同的业务接口对数据库的操作一直处于同一个事务中，没有被正确提交。</p> 
<hr> 
<h3><a id="_107"></a>知识拓展</h3> 
<blockquote> 
 <p>Tips：问题是基本排查出来也解决了，但是没有知识总结，那就是不是一个完整的技术复盘。<br> Tips：很明显，这次故障是由于程序猿对事务用法不熟悉、或者说不严谨导致的了，因此针对事务相关知识补充。</p> 
</blockquote> 
<h4><a id="_112"></a>事务前置知识</h4> 
<p>Spring 支持两种事务方式，分别是声明式事务和编程式事务，两者各有优缺点。<br> 声明式事务，其代表就是使用@Transactional，优点是简化配置、降低代码侵入性、易于理解。<br> 缺点主要有：</p> 
<ul><li>不够灵活，仅支持方法级别的事务控制，无法实现细粒度的事务控制；</li><li>有较多导致注解失效的场景需要考虑，例如自调用问题、非public、异常不匹配、被标记回滚等；</li></ul> 
<p>编程式事务，典型代表有<code>手动控制DataSourceTransactionManager</code>和<code>直接使用TransactionTemplate</code>。<br> 优点和@Transactional是相对的，灵活性高，细粒度的控制。<br> 缺点主要有：</p> 
<ul><li>代码冗长，编程式事务管理需要在业务代码中显式地编写事务管理逻辑，可能会导致代码变得冗长和复杂；</li><li>可读性差，由于事务管理逻辑与业务逻辑交织在一起，可能会降低代码的可读性和可维护性；</li><li>由于是手动控制，容易产生未关闭事务的情况出现；</li></ul> 
<p>综上所述，@Transactional 注解和编程式事务管理各有优缺点，可以根据项目的需求、复杂度和团队的技术水平来选择合适的事务管理方式。在简单的业务场景中，@Transactional 注解可能更加适用，而在复杂的事务管理需求下，编程式事务管理可能更加灵活。</p> 
<hr> 
<h4><a id="_132"></a>回到上述问题</h4> 
<p>前面介绍完声明式事务和编程式事务的优缺点，公司框架鉴于安全性考虑，大部分简单场景推荐直接使用Spring声明式事务即@Transactional注解完成，但由于某产品线业务场景较为复杂，需要借助编程式事务写法，更精细的手动控制事务的提交和回滚动作。<br> 全局搜该产品线的项目代码，可以看到如下图的大量事务控制代码。<br> <img src="https://images2.imgbox.com/c1/cf/AQnpo60b_o.png" alt="image.png"><br> 不管是这次的遇到的锁问题，还是事务错乱的问题。追其根源，还是研发人员对手动控制事务的把控不到位，事务开启后如果没正常关闭，会导致后续各种问题的出现。<br> 收费服务的接口手动开启了事务，期间Feign调用了医嘱服务，但没有对这部分代码块进行异常捕获，当医嘱服务异常，此方法直接结束，事务未关闭，一直处于活动状态，本事务里面涉及的锁表语法都会阻塞，同时造成后续其他影响。<br> <img src="https://images2.imgbox.com/a1/62/jvoXyVwf_o.png" alt="企业微信截图_17109850224097.png"></p> 
<hr> 
<h4><a id="_142"></a>关于手动控制</h4> 
<p>1、尽量使用<code>try-catch</code>代码块控制手动事务代码，保障异常发生时，可以正常回滚事务；<br> 2、当又遇到<code>if-else</code>分支时，要充分考虑每个代码段都有提交或回滚动作，不要有疏漏；<br> 3、如果怕疏漏，可以在<code>finally</code>添加兜底操作，或者封装一个公用事务操作方法；<br> 4、可以尝试使用Spring自带的TransactionTemplate来尝试操作事务；<br> 5、研发主管审核手动控制事务的代码要特别注意，减少错误几率；</p> 
<p><strong>【某编程事务示例代码】</strong></p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TransactionService</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">DataSourceTransactionManager</span> transactionManager<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">someTransactionalMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 定义事务属性</span>
        <span class="token class-name">DefaultTransactionDefinition</span> def <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultTransactionDefinition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 设置事务隔离级别，默认是 ISOLATION_DEFAULT</span>
        def<span class="token punctuation">.</span><span class="token function">setIsolationLevel</span><span class="token punctuation">(</span><span class="token class-name">DefaultTransactionDefinition</span><span class="token punctuation">.</span><span class="token constant">ISOLATION_DEFAULT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 设置事务传播行为，默认是 PROPAGATION_REQUIRED</span>
        def<span class="token punctuation">.</span><span class="token function">setPropagationBehavior</span><span class="token punctuation">(</span><span class="token class-name">DefaultTransactionDefinition</span><span class="token punctuation">.</span><span class="token constant">PROPAGATION_REQUIRED</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 开启事务</span>
        <span class="token class-name">TransactionStatus</span> status <span class="token operator">=</span> transactionManager<span class="token punctuation">.</span><span class="token function">getTransaction</span><span class="token punctuation">(</span>def<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 执行事务操作，例如执行数据库操作</span>
            <span class="token comment">// ...</span>

            <span class="token comment">// 提交事务</span>
            transactionManager<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 如果发生异常，则回滚事务</span>
            transactionManager<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">throw</span> e<span class="token punctuation">;</span> <span class="token comment">// 可以选择抛出异常或者处理异常</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 确保在方法结束时关闭事务</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>status<span class="token punctuation">.</span><span class="token function">isCompleted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">isRollbackOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    transactionManager<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                    transactionManager<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<hr> 
<h4><a id="_194"></a>关于事务封装</h4> 
<p><strong>【问题说明】</strong><br> 手动控制事务的代码，存在大量冗余，下面的这几句代码，全局可以搜到多处，应该是研发人员拷贝了其他人的代码。<br> <img src="https://images2.imgbox.com/45/58/NZib5IaT_o.png" alt="image.png"><br> 无独有偶，类似的还有下面的用法，应该是拷贝其他代码直接过来。<br> <img src="https://images2.imgbox.com/cc/0e/TxcgclGR_o.png" alt="image.png"></p> 
<p><strong>【改进说明】</strong><br> 涉及重复的代码，应该考虑抽离公用部分封装一个方法，这样后续的好处如下：</p> 
<ul><li>研发可以直接试用公用方法，而不是选择拷贝大量代码；</li><li>后续发现代码问题，对代码的修改也集中在公用部分；</li><li>可以在公用方法上做一些扩展和封装，例如事务正常关闭；</li><li></ul> 
<blockquote> 
 <p>Tips：程序猿允许拷贝代码，但在拷贝之前要先熟悉用法背后的原理，同时考虑一下复用性。</p> 
</blockquote> 
<p><strong>【封装手动控制事务示例】</strong></p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TransactionUtils</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">DataSourceTransactionManager</span> transactionManager<span class="token punctuation">;</span>

    <span class="token comment">/**
     * 执行事务操作
     *
     * @param transactionalCode 执行事务操作的逻辑，可以是一个 Lambda 表达式或者方法引用
     * @param isolationLevel    事务隔离级别
     * @param &lt;T&gt;               返回值类型
     * @return 事务操作的返回值
     */</span>
    <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">doInTransaction</span><span class="token punctuation">(</span><span class="token class-name">TransactionCode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> transactionalCode<span class="token punctuation">,</span> <span class="token keyword">int</span> isolationLevel<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 定义事务属性</span>
        <span class="token class-name">DefaultTransactionDefinition</span> def <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultTransactionDefinition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        def<span class="token punctuation">.</span><span class="token function">setIsolationLevel</span><span class="token punctuation">(</span>isolationLevel<span class="token punctuation">)</span><span class="token punctuation">;</span>
        def<span class="token punctuation">.</span><span class="token function">setPropagationBehavior</span><span class="token punctuation">(</span><span class="token class-name">DefaultTransactionDefinition</span><span class="token punctuation">.</span><span class="token constant">PROPAGATION_REQUIRED</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 开启事务</span>
        <span class="token class-name">TransactionStatus</span> status <span class="token operator">=</span> transactionManager<span class="token punctuation">.</span><span class="token function">getTransaction</span><span class="token punctuation">(</span>def<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 执行事务操作</span>
            <span class="token class-name">T</span> result <span class="token operator">=</span> transactionalCode<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// 提交事务</span>
            transactionManager<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">return</span> result<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 发生异常，则回滚事务</span>
            transactionManager<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">throw</span> e<span class="token punctuation">;</span> <span class="token comment">// 抛出异常</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 定义一个函数式接口，用于执行事务操作的逻辑
     *
     * @param &lt;T&gt; 返回值类型
     */</span>
    <span class="token annotation punctuation">@FunctionalInterface</span>
    <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">TransactionCode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">T</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TransactionalService</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">private</span> <span class="token class-name">TransactionUtils</span> transactionUtils<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">TransactionalService</span><span class="token punctuation">(</span><span class="token class-name">TransactionUtils</span> transactionUtils<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>transactionUtils <span class="token operator">=</span> transactionUtils<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">someTransactionalMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        transactionUtils<span class="token punctuation">.</span><span class="token function">doInTransaction</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 在这里执行你的事务逻辑</span>
            <span class="token comment">// 返回值可以是任何类型，根据需要自行定义</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token class-name">DefaultTransactionDefinition</span><span class="token punctuation">.</span><span class="token constant">ISOLATION_DEFAULT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h4><a id="_283"></a>问题排查经验</h4> 
<p>这次出现问题后，除了代码写法的注意事项，还有就是遇到问题时排查定位的经验分享。<br> 回过头来，可以总结一下哪些是我们可以快速定位问题的宝贵经验。<br> 1、出现死锁问题，第一时间要找DBA积极配合，无论是导致死锁的语法，还是事务错乱的回滚情况，DBA这边的情况是很重要的，尤其是每天卡顿的第一时间产生死锁的语法；<br> 2、遇到线上问题，灵活借用Prometheus、Grafana、Skywalking、Zipkin、Kibana、SpringBootAdmin、Nacos、Rancher、应用日志等工具，知道每个工具能做什么。例如使用Prometheus定位程序线程数，工程反馈每次需要重启恢复，死锁杀不完，其实可以往这方面验证；利用Kibana可以查应用日志看不到的更多信息；利用Skywalking和Zipkin可以定位到全链路更多信息；当然，最重要的还是应用日志的使用，这是基础功能，研发人员必备；<br> 3、代码提交记录很关键，优先定位出现卡顿问题开始的那天，之前一段时间的代码提交和发布记录，越拖越久，越难定位；</p> 
<hr> 
<h4><a id="_292"></a>事务使用经验</h4> 
<blockquote> 
 <p>Tips：问题排查的手段，毕竟是基于问题已经产生情况下的兜底操作，需要耗费较大的代价，程序猿还是尽量把问题消灭在编码阶段。</p> 
</blockquote> 
<p>上面说了一大堆，关于声明式事务和编程式事务，没必要去纠结好坏，也不能一捆子打死必须都用<code>@Transactional</code>。<br> 像复杂的业务必须使用手动控制事务的方式，更加灵活，技术没有好坏，还是用法问题。<br> 目前来看，部分业务经常使用<code>for update</code>行锁机制，在事务控制下，编码不科学出现锁表的可能性较大，如何做好复杂事务的控制，减低锁表概率？</p> 
<p><strong>避免长时间的事务阻塞</strong></p> 
<ul><li>合理设计事务边界是避免锁表的关键，事务应该尽可能地短小，仅在必要时才持有数据库锁，长时间的事务可能导致数据库锁的持有时间过长，增加了锁表的风险。因此，将事务的范围限制在必要的最小范围内是非常重要的。</li><li>避免长时间的查询操作，可以的话，查询可以放在事务外，只有必要动作才在事务中完成。</li><li>避免在事务中使用远程调用，这部分耗时是不可控的。</li><li>尽量少用嵌套或挂起事务，使用也要保障子事务耗时。</li><li>适当选择@Transactional(timeout = 30)指定事务超时时间。</li><li>如果使用@Transactional，事务所在方法也不宜过大，不适合在复杂方法上、甚至整个接口逻辑上，直接加事务。</li><li>。。。</li></ul> 
<p><strong>尽量保障锁表的顺序</strong><br> 在编写事务代码时，注意控制加锁的顺序，尽量按照固定的顺序对数据进行加锁。确保在事务中对数据进行操作时，按照相同的顺序加锁和解锁，避免出现死锁或锁表的顺序问题。</p> 
<p><strong>避免跨事务的查询操作</strong><br> 尽量避免在一个事务中执行长时间的查询操作，而在另一个事务中更新相同的数据，这样容易导致锁表的情况发生。如果需要跨事务操作，可以考虑使用乐观锁或者分布式锁来控制并发访问。</p> 
<p><strong>其他事务措施</strong></p> 
<ul><li>不要局限于数据库锁，可以灵活搭配使用分布式锁等其他机制；</li><li>更精准的行锁，减少锁的数据范围；</li><li>。。。</li></ul> 
<hr> 
<h3><a id="_322"></a>总结陈词</h3> 
<p>上文分享了某次事务用法导致的故障，针对故障做了排查总结和知识沉淀，关于事务更详细的用法，后面再专栏补充。</p> 
<p>💗 后续会逐步分享企业实际开发中的实战经验，有需要交流的可以联系博主。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7cc926e8fda23cf0fcc24dc0327c63d0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">机器学习库实战：DL4J与Weka在Java中的应用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8d5903cda7aec11d83c8246fb4d7c1d6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SQL职场必备：掌握数据库技能提升职场竞争力</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>