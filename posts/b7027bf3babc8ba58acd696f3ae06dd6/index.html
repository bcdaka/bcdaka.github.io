<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c&#43;&#43; nanoMQ 发布和订阅消息，代码优化 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b7027bf3babc8ba58acd696f3ae06dd6/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="c&#43;&#43; nanoMQ 发布和订阅消息，代码优化">
  <meta property="og:description" content="c&#43;&#43; nanoMQ 发布和订阅消息，代码优化，实现了发布消息和订阅消息的打印输出监听。
nanomq.h
#ifndef NANOMQ_H #define NANOMQ_H #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;iostream&gt; #include &lt;stdio.h&gt; #include &lt;MQTTClient.h&gt; #define ADDRESS &#34;tcp://broker.emqx.io:1883&#34; #define USERNAME &#34;xgdd&#34; #define PASSWORD &#34;xgdd&#34; #define CLIENTID &#34;mqttx_47b97142&#34; #define QOS 0 #define TIMEOUT 10000L class NanoMQ { public: NanoMQ(); /// /// \brief init 连接nanomq /// \return -1-连接失败 0-连接成功 /// int init(); /// /// \brief quit 断开连接 /// void quit(); /// /// \brief sendInfo 发送信息 /// \param topic 节点 /// \param data 数据 /// void sendInfo(char *topic, char *data); private: MQTTClient client; void publish(MQTTClient client, char *topic, char *payload); }; /// /// \brief on_message 接收消息 /// \param context /// \param topicName 节点 用于区分不同节点 /// \param topicLen /// \param message 数据 结构中的message-&gt;payload /// \return /// int on_message(void *context, char *topicName, int topicLen, MQTTClient_message *message); #endif // NANOMQ_H nanomq.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-22T16:51:40+08:00">
    <meta property="article:modified_time" content="2024-08-22T16:51:40+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c&#43;&#43; nanoMQ 发布和订阅消息，代码优化</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>c++ nanoMQ 发布和订阅消息，代码优化，实现了发布消息和订阅消息的打印输出监听。</p> 
<p>nanomq.h</p> 
<pre><code>#ifndef NANOMQ_H
#define NANOMQ_H

#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;MQTTClient.h&gt;

#define ADDRESS     "tcp://broker.emqx.io:1883"
#define USERNAME    "xgdd"
#define PASSWORD    "xgdd"
#define CLIENTID    "mqttx_47b97142"
#define QOS         0
#define TIMEOUT     10000L

class NanoMQ
{
public:
    NanoMQ();
    ///
    /// \brief init 连接nanomq
    /// \return  -1-连接失败 0-连接成功
    ///
    int init();
    ///
    /// \brief quit 断开连接
    ///
    void quit();
    ///
    /// \brief sendInfo 发送信息
    /// \param topic    节点
    /// \param data     数据
    ///
    void sendInfo(char *topic, char *data);

private:
    MQTTClient client;

    void publish(MQTTClient client, char *topic, char *payload);

};

///
/// \brief on_message   接收消息
/// \param context
/// \param topicName    节点 用于区分不同节点
/// \param topicLen
/// \param message      数据 结构中的message-&gt;payload
/// \return
///
int on_message(void *context, char *topicName, int topicLen, MQTTClient_message *message);

#endif // NANOMQ_H
</code></pre> 
<p>nanomq.cpp</p> 
<pre><code>#include "nanomq.h"

int on_message(void *context, char *topicName, int topicLen, MQTTClient_message *message)
{
    printf("Message arrived \n");
    printf("  topic: %s\n", topicName);
    printf("  message: %d...%s\n", message-&gt;payloadlen, (char*)message-&gt;payload);

    MQTTClient_freeMessage(&amp;message);
    MQTTClient_free(topicName);
    return 1;   //此处不能为0，若为0则topicName打印乱码
}

NanoMQ::NanoMQ()
{

}

int NanoMQ::init()
{
    MQTTClient_create(&amp;client, ADDRESS, CLIENTID, 0, NULL);
    MQTTClient_connectOptions conn_opts = MQTTClient_connectOptions_initializer;
    conn_opts.username = USERNAME;
    conn_opts.password = PASSWORD;

    MQTTClient_setCallbacks(client, NULL, NULL, on_message, NULL);

    if (MQTTClient_connect(client, &amp;conn_opts) != MQTTCLIENT_SUCCESS) {
        printf("Failed to connect\n");
        return -1;
    } else {
        printf("Connected to MQTT Broker!\n");
    }

    //监听以testtopic/开头的所有主题
    if (MQTTClient_subscribe(client, "testtopic/#", QOS) != MQTTCLIENT_SUCCESS)
    {
        printf("Failed to subscribe\n");
    }

    return 0;
}

void NanoMQ::quit()
{
    MQTTClient_disconnect(client, TIMEOUT);
    MQTTClient_destroy(&amp;client);
}

void NanoMQ::sendInfo(char *topic, char *data)
{
    publish(client, topic, data);
}

void NanoMQ::publish(MQTTClient client, char *topic, char *payload)
{
    MQTTClient_message message = MQTTClient_message_initializer;
    message.payload = payload;
    message.payloadlen = strlen(payload);
    message.qos = QOS;
    message.retained = 0;
    MQTTClient_deliveryToken token;
    MQTTClient_publishMessage(client, topic, &amp;message, &amp;token);
    MQTTClient_waitForCompletion(client, token, TIMEOUT);
    printf("Send `%s`\n", payload);
}

</code></pre> 
<p>main.cpp</p> 
<pre><code>#include &lt;iostream&gt;
#include &lt;thread&gt;

#include "nanomq.h"

using namespace std;

NanoMQ nanomq;

void topic_1()
{
    while(true) {
        nanomq.sendInfo("testtopic/1", "this is test topic 1");
        sleep(1);
    }
}

int main(int argc, char *argv[])
{
    cout&lt;&lt;"hello world"&lt;&lt;endl;

    if(nanomq.init() &lt; 0) {
        cout&lt;&lt;"nanomq connect failed.."&lt;&lt;endl;
    }

    thread t1(&amp;topic_1);

    while (true) {
        sleep(1);
    }

    nanomq.quit();

    return 0;
}
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9c4d90b832130544490fe02d71ad82da/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux安装并配置Hadoop</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/edfc3419b6cc0e0e59c29ef79c284fe2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">122-域信息收集&amp;应用网络凭据&amp;CS插件&amp;Adfind&amp;BloodHound</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>