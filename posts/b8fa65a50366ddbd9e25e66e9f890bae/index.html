<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>线程池概念、线程池的不同创建方式、线程池的拒绝策略 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b8fa65a50366ddbd9e25e66e9f890bae/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="线程池概念、线程池的不同创建方式、线程池的拒绝策略">
  <meta property="og:description" content="文章目录 💐线程池概念以及什么是工厂模式💐标准库中的线程池💐什么是工厂模式？💐ThreadPoolExecutor💐模拟实现线程池 💐线程池概念以及什么是工厂模式 线程的诞生是因为，频繁的创建进程太重量了(开销较大),所以引入了线程，但是呢，对于线程来讲，如果更加频繁的创建和销毁，那么开销也会慢慢的变大，所以，又引入了两种经典的方法来进一步提高：
1.协程：又称为轻量级线程，线程比较轻量是因为线程省略了分配资源的环节，而协程它在着基础上又省略了操作系统调度执行的环节，由程序员自己调度；在Java中呢，主要使用线程池，所以对于协程只是简单提一下；
2.线程池：
举一个例子：
假如我是一个很漂亮的妹子，又有许多的男生正在追我，然后我就选择了一个男生A做我男朋友，但是呢，经过一段时间之后，我就腻了，就想要和男生B谈恋爱，所以，我就和男生A提出了分手，然后和男生B培养感情，等到有了感情基础，等有了感情基础后就拿下男生B，但是，过来一段时间后，我又想和男生C谈恋爱，所以就接着重复上面的套路，先培养感情等等………
而对于上面这种换男朋友的方式，感觉效率太慢，所以，我就有了一种新的方式，在和男生A谈恋爱的同时，偷偷的和男生B、C、D等多个男生培养感情，等到我向和谁谈恋爱时，那不就是捅破一层窗户纸的事情么，就可以挑选一个直接谈恋爱，这样的效率不久高了很多么，所以，对于偷偷的和我培养感情的这群男生也就可以称为“备胎池”；
而我们的线程池也是上面这种模式，在向池中添加任务时，直接从线程池中拿线程就可以了，就不比再创建了，直接拿过来使用即可，这样也就降低了线程创建的开销；所以线程池的就是先把线程创建好，放进池子里，等到后续想要使用时，直接从池子里取；
这里就会有一个问题：为啥从线程池里面取线程比创建线程效率高？
首先，创建新的线程这个动作，是内核态&#43;用户态相互配合完成的；
而从线程池中取这个动作，是用户态操作完成的；
所以这里就涉及到了两个新名词，什么是用户态，什么是内核态
如果一段程序是在系统内核中完成的，此时就称为内核态
如果不是，则称为用户态；
而操作系统呢，是由内核&#43;配套的应用程序组成的，创建线程，就需要调用系统API,进入到内核中，按照内核态的方式来完成一系列的动作；
但是，为什么内核态操作的效率比较低呢？请看下图
💐标准库中的线程池 在Java中，提供了一个类——Executors创建线程池；但是，线程池对象的创建并不是直接new出来的，而是通过一个方法的返回值，返回了一个线程池对象；
public class MyThreadPool { public static void main(String[] args) { //创建一个动态的线程池 ExecutorService es = Executors.newCachedThreadPool(); es.submit(new Runnable() { @Override public void run() { System.out.println(&#34;hello&#34;); } }); } } 创建线程池对象分为以下步骤：
1.使用Executors.newCachedThreadPool 创建出一个动态增长的线程池，为什么要用Executors.newCachedThreadPool的方式创建线程池，而不是直接new Executors？这里就涉及到了一个设计模式——工厂模式：
💐什么是工厂模式？ 工厂模式：定义一个工厂类，通过调用工厂类中的不同方法来实现对象的实例化，从而创建出不同作用的对象；
举个例子，我们在创建对象时，会使用new关键字，通过构造方法来创建对象，但是使用构造方法创建对象会又很大的局限性，举个例子：假如我现在想要使用笛卡尔坐标来创建一个点对象，代码如下：
public class Point { //笛卡尔坐标系需要提供一个x，y坐标 private int x; private int y; //通过笛卡尔坐标的方式创建一个对象 public Point(int x, int y) {}; } 但是，我现在又想通过极坐标的方式创建点对象">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-24T17:14:13+08:00">
    <meta property="article:modified_time" content="2024-06-24T17:14:13+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">线程池概念、线程池的不同创建方式、线程池的拒绝策略</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_3" rel="nofollow">💐线程池概念以及什么是工厂模式</a></li><li><a href="#_37" rel="nofollow">💐标准库中的线程池</a></li><li><a href="#_60" rel="nofollow">💐什么是工厂模式？</a></li><li><a href="#ThreadPoolExecutor_185" rel="nofollow">💐ThreadPoolExecutor</a></li><li><a href="#_253" rel="nofollow">💐模拟实现线程池</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_3"></a>💐线程池概念以及什么是工厂模式</h2> 
<p>线程的诞生是因为，频繁的创建进程太重量了(开销较大),所以引入了线程，但是呢，对于线程来讲，如果更加频繁的创建和销毁，那么开销也会慢慢的变大，所以，又引入了两种经典的方法来进一步提高：</p> 
<p><strong>1.协程</strong>：又称为轻量级线程，线程比较轻量是因为线程省略了分配资源的环节，而协程它在着基础上又省略了操作系统调度执行的环节，由程序员自己调度；在Java中呢，主要使用线程池，所以对于协程只是简单提一下；</p> 
<p><strong>2.线程池</strong>：</p> 
<blockquote> 
 <p>举一个例子：</p> 
 <p>假如我是一个很漂亮的妹子，又有许多的男生正在追我，然后我就选择了一个男生A做我男朋友，但是呢，经过一段时间之后，我就腻了，就想要和男生B谈恋爱，所以，我就和男生A提出了分手，然后和男生B培养感情，等到有了感情基础，等有了感情基础后就拿下男生B，但是，过来一段时间后，我又想和男生C谈恋爱，所以就接着重复上面的套路，先培养感情等等………</p> 
 <p>而对于上面这种换男朋友的方式，感觉效率太慢，所以，我就有了一种新的方式，在和男生A谈恋爱的同时，偷偷的和男生B、C、D等多个男生培养感情，等到我向和谁谈恋爱时，那不就是捅破一层窗户纸的事情么，就可以挑选一个直接谈恋爱，这样的效率不久高了很多么，所以，对于偷偷的和我培养感情的这群男生也就可以称为“备胎池”；</p> 
</blockquote> 
<p>而我们的线程池也是上面这种模式，在向池中添加任务时，直接从线程池中拿线程就可以了，就不比再创建了，直接拿过来使用即可，这样也就降低了线程创建的开销；<strong>所以线程池的就是先把线程创建好，放进池子里，等到后续想要使用时，直接从池子里取；</strong></p> 
<p>这里就会有一个问题：为啥从线程池里面取线程比创建线程效率高？</p> 
<blockquote> 
 <p>首先，创建新的线程这个动作，是<strong>内核态+用户态</strong>相互配合完成的；</p> 
 <p>而从线程池中取这个动作，是<strong>用户态</strong>操作完成的；</p> 
 <p>所以这里就涉及到了两个新名词，什么是用户态，什么是内核态</p> 
 <p>如果一段程序是在系统内核中完成的，此时就称为内核态</p> 
 <p>如果不是，则称为用户态；</p> 
 <p>而操作系统呢，是由内核+配套的应用程序组成的，创建线程，就需要调用系统API,进入到内核中，按照内核态的方式来完成一系列的动作；</p> 
 <p>但是，为什么内核态操作的效率比较低呢？请看下图</p> 
</blockquote> 
<h2><a id="_37"></a>💐标准库中的线程池</h2> 
<p>在Java中，提供了一个类——Executors创建线程池；但是，线程池对象的创建并不是直接new出来的，而是通过一个方法的返回值，返回了一个线程池对象；</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThreadPool</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//创建一个动态的线程池</span>
        <span class="token class-name">ExecutorService</span> es <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        es<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>创建线程池对象分为以下步骤：</p> 
<p>1.使用<strong>Executors.newCachedThreadPool</strong> 创建出一个动态增长的线程池，为什么要用Executors.newCachedThreadPool的方式创建线程池，而不是直接new Executors？这里就涉及到了一个设计模式——工厂模式：</p> 
<h2><a id="_60"></a>💐什么是工厂模式？</h2> 
<blockquote> 
 <p>工厂模式：定义一个工厂类，通过调用工厂类中的不同方法来实现对象的实例化，从而创建出不同作用的对象；</p> 
 <p>举个例子，我们在创建对象时，会使用new关键字，通过构造方法来创建对象，但是使用构造方法创建对象会又很大的局限性，举个例子：假如我现在想要使用笛卡尔坐标来创建一个点对象，代码如下：</p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//笛卡尔坐标系需要提供一个x，y坐标</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span>
    <span class="token comment">//通过笛卡尔坐标的方式创建一个对象</span>
    <span class="token keyword">public</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>但是，我现在又想通过极坐标的方式创建点对象</p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span>
    <span class="token comment">//通过笛卡尔坐标的方式创建一个对象</span>
    <span class="token keyword">public</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">//极坐标的方式就需要提供一个半径和角度</span>
    <span class="token keyword">public</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>但是以上这种方式就会编译错误，因为，如果想要使用多种构造方法的方式创建对象的话，就需要将构造方法重载，而重载的条件是要保证参数列表的类型或者个数不同，所以以上代码是行不通过的，针对这种问题，就可以利用工厂模式解决</p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span>
    
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setX</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setY</span><span class="token punctuation">(</span><span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//创建一个点对象的工厂</span>
<span class="token keyword">class</span> <span class="token class-name">PointFactor</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">//通过笛卡尔坐标系创建对象</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Point</span> <span class="token function">newPointByXY</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Point</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//对Point中的属性进行初始化</span>
        p<span class="token punctuation">.</span><span class="token function">setX</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        p<span class="token punctuation">.</span><span class="token function">setY</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token keyword">return</span> p<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//通过极坐标创建对象</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Point</span> <span class="token function">newPointByRA</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Point</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        p<span class="token punctuation">.</span><span class="token function">setX</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
        p<span class="token punctuation">.</span><span class="token function">setY</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> p<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//测试类</span>
<span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//这样通过调用点工厂中不同方法，就可以根据不同的方式创建出对象</span>
        <span class="token class-name">Point</span> point1 <span class="token operator">=</span> <span class="token class-name">PointFactor</span><span class="token punctuation">.</span><span class="token function">newPointByXY</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Point</span> point2 <span class="token operator">=</span> <span class="token class-name">PointFactor</span><span class="token punctuation">.</span><span class="token function">newPointByRA</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>回到这里的线池：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThreadPool</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//创建一个动态的线程池</span>
        <span class="token class-name">ExecutorService</span> es <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        es<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在线程池中，也提供了几个比较重要的方法：</p> 
<p>（重点）创建线程池也提供了几种不同的方式：</p> 
<ul><li> <p>newCachedThreadPool() 创建线程数目动态增长的线程池</p> 
  <blockquote> 
   <p>这种方式创建的线程池，池子中的线程会根据你添加的任务的需要，自动创建线程出来，线程结束以后也不会立即销毁，而是会在池子中保留一段时间，以备后续再随时使用；</p> 
  </blockquote> </li><li> <p>newFixedThreadPoll() 创建固定线程数的线程池</p> </li><li> <p>newSingleThreadPool() 创建只包含一个线程的线程池</p> </li><li> <p>newScheduleThreadPool() 类似于定时器，只不过不是一个扫描线程，而是多个扫描线程执行时间到的任务</p> </li></ul> 
<p><strong>方法的返回值类型是ExecutorService</strong></p> 
<p><strong>通过ExecutorService定义的对象调用submit()方法注册一个任务到线程池中</strong></p> 
<pre><code class="prism language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//创建一个动态的线程池</span>
        <span class="token class-name">ExecutorService</span> es1 <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ExecutorService</span> es2 <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ExecutorService</span> es3 <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ExecutorService</span> es4 <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//指定扫描线程的数量</span>
        
    <span class="token punctuation">}</span>
</code></pre> 
<p>上述几个使用工厂方法创建的线程池，本质上都是对一个类进行了封装，这个类就是——<strong>ThreadPoolExecutor</strong></p> 
<p>这个类的功能非常丰富，提供了很多不同参数方法，上述的几个工厂方法呢，其实就是给这个ThreadPoolExecutor 类填写了不同的构造参数从而创建出了不同的线程池；</p> 
<p>接下来就看一下ThreadPoolExecutor的使用方法👇</p> 
<h2><a id="ThreadPoolExecutor_185"></a>💐ThreadPoolExecutor</h2> 
<p>ThreadPoolExecutor的构造方法中提供了很多可选的参数，进一步的细化了线程池的设定，下面针对这些参数进行一个讲解：</p> 
<p><img src="https://images2.imgbox.com/d0/5a/A6Qiyy5V_o.png" alt="在这里插入图片描述"></p> 
<p>上图就是ThreadPoolExecutor的所有构造方法，也可以看到，最后一个构造方法的参数最多，并且当中的参数也都包含了其他三个方法的参数，所以，这里针对最后一个方法参数进行讲解：</p> 
<ul><li> <p>int corePoolSize :核心线程数</p> </li><li> <p>int maximumPoolSize :最大线程数目</p> 
  <blockquote> 
   <p>在一个线程池中，是有多个线程的，以上两个参数就指定了线程池中线程数目的范围，最少有corePoolSize个线程，最多不会超过maxMumPoolSize个线程</p> 
  </blockquote> </li><li> <p>long keepAliveTime 和 TimeUnit unit :空余线程存活的时间以及时间的单位</p> 
  <blockquote> 
   <p>在创建线程时， 默认会先使用核心线程数，上面提到过，当任务执行结束后，线程不会立马销毁，而是会有一个保留的时间，一方面是为了如果后续再需要使用时，就不用再进行创建，另一方面是，当保留时间到了以后，进行销毁，也减少了资源消耗，后续使用时再进行创建即可</p> 
  </blockquote> </li><li> <p>BlockingQueue workQueue ：阻塞队列</p> 
  <blockquote> 
   <p>当使用submit向线程池中添加任务时，如果任务个数少于核心线程数，那么会创建新的线程去执行任务，如果任务个数超过了核心线程数，就会先添加到阻塞队列中，然后工作线程从队列中取出任务执行，如果任务不能排队等候，那么也会创建一个新的线程，前提是不会超过最大的线程数，需要注意的是，这里的队列不光可以是阻塞队列，还可以是其他的队列，例如如果需要使用优先级就可以设置为：PriorityBlockingQueue，如果任务数目变动不大就可以使用：ArrayBlockingQueue，如果任务数目变动较大就可以使用：LinkedBlockingQueue;</p> 
  </blockquote> </li><li> <p>ThreadFactory threadFactory ：线程工厂类</p> 
  <blockquote> 
   <p>这个类也是工厂模式的体现，由ThreadFactory这个工厂类来创建线程，使用工厂类创建线程，主要是对线程的属性进行设置，通过这个类对这些属性进行了封装，就不需要我们手动进行设置；</p> 
  </blockquote> </li><li> <p>ThreadPoolExecutor.DiscardPolicy ：拒绝策略</p> 
  <blockquote> 
   <p>一个线程池中的线程数量是有上限的，当线程数量达到上限后，如果还继续往线程池中添加任务，那么针对不同的拒绝策略就会出现不同的效果；</p> 
  </blockquote> <p>（重点）任务策略分为：</p> <p><img src="https://images2.imgbox.com/7a/10/biOTyw7J_o.png" alt="在这里插入图片描述"></p> </li></ul> 
<p>这四种拒绝策略使用了类来实现，想要使用哪种策略，直接创建出对象，将对象传过去即可；</p> 
<p>下面针对这四种策略进行一个讲解：</p> 
<blockquote> 
 <p>ThreadPoolExecutor.AbortPolicy ：如果队列已经满了，直接抛出异常</p> 
 <p>ThreadPoolExecutor.CallerRunsPolicy ：新添加的任务由调用任务的线程执行</p> 
 <p>ThreadPoolExecutor.DiscardOldestPolicy ：丢弃任务队列中最老的任务</p> 
 <p>ThreadPoolExecutor.DiscardPolicy ：丢弃新添7加的任务</p> 
</blockquote> 
<p>上面讲过，针对于线程池可以设置线程的数目，但是，这个数目设置成多少合适呢？</p> 
<p>针对这个问题，网上有很多的答案，假设CPU的逻辑核心数是N，线程数目的设置就有多个答案，例如：</p> 
<p>N个，N+1个，N+2个，2N个等等；</p> 
<p>针对以上答案，没有一个是正确的，因为这需要根据项目代码进行设置，一个线程执行的代码主要分为两类：</p> 
<ul><li> <p>CPU 密集型</p> 
  <blockquote> 
   <p>CPU 密集型，代码里面的主要逻辑都是在算数运算/逻辑判断</p> 
  </blockquote> </li><li> <p>IO 密集型</p> 
  <blockquote> 
   <p>IO 密集型，代码里面的主要逻辑都是在进行IO操作</p> 
  </blockquote> <p>如果代码是都是CPU密集型，这时设置的线程数目就不能超过N，如果代码都是IO密集型的，此时设置的线程数目就可以超过N，而在现实中，没有代码都是纯CPU密集型和纯IO密集型的，同时，我们也无法知道有多少代码是CPU密集，有多少代码是IO密集的；</p> <p>所以要想知道该设置多少线程数，正确的做法就是用实验的方式，尝试改变线程池中不同线程的数目，来观察出哪种数目更合适；</p> </li></ul> 
<h2><a id="_253"></a>💐模拟实现线程池</h2> 
<p>这里来模拟一个简单的newFixedThreadPool()版本的线程池，步骤：</p> 
<ul><li> <p>创建一个MyThreadPool,描述一个线程池</p> </li><li> <p>使用一个阻塞队列组织所有的任务</p> <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThreadPool</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//创建一个阻塞队列组织所有的任务</span>
    <span class="token keyword">private</span> <span class="token class-name">BlockingDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">MyThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//创建n个线程</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>

                    <span class="token class-name">Runnable</span> runnable <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    runnable<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> runnable<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{<!-- --></span>
        queue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">MyThreadPool</span> myThreadPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThreadPool</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">int</span> n <span class="token operator">=</span> i<span class="token punctuation">;</span>
            myThreadPool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token annotation punctuation">@Override</span>
                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/18066cdd975064c2eba1f591ce8969ce/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">playwright录制脚本原理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c15fe76314f2b350984d3178b6a4bd46/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">前端之jQuery</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>