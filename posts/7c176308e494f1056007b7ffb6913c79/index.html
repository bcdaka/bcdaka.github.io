<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】详解栈 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/7c176308e494f1056007b7ffb6913c79/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】详解栈">
  <meta property="og:description" content="今天我们主要来了解栈！如果对知识点有模糊，可翻阅以往文章哦！
个人主页：小八哥向前冲~-CSDN博客
所属专栏：数据结构【c语言版】_小八哥向前冲~的博客-CSDN博客
c语言专栏：c语言_小八哥向前冲~的博客-CSDN博客
值得注意的是，如果你十分了解顺序表和链表，今天这期会很轻松哦！
哈哈哈哈！当然，这期也能检测你对顺序表和链表的理解！一起看看吧！
目录
栈的定义
顺序表和链表的比较
栈的实现--顺序表
初始化
栈为空的判定
入栈
出栈
销毁
栈顶数据
数据个数
题目操练：配括号问题
栈的实现--链表
栈为空的判定
入栈
出栈
销毁
栈顶数据
数据个数
码源--栈（顺序表）
码源--栈（链表）
栈的定义 栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端 称为栈顶，另一端称为栈底。栈中的数据元素遵守后进先出LIFO（Last In First Out）的原则。压栈：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶。出栈：栈的删除操作叫做出栈。出数据也在栈顶。 上图理解一下：
注意：遵循后进先出的原则！
知道了这个原则，我们来巩固一下：
1.一个栈的初始状态为空。现将元素1、2、3、4、5、A、B、C、D、E依次入栈，然后再依次出栈，则元素出 栈的顺序是（ ）。
A .12345ABCDE
B.EDCBA54321
C.ABCDE12345
D.54321EDCBA
2.若进栈序列为 1,2,3,4 ，进栈过程中可以出栈，则下列不可能的一个出栈序列是（）
A.1,4,3,2
B.2,3,4,1
C.3,1,4,2
D.3,4,2,1
显然：1.B 2.C
相信第一题不难，我们解释一下第二题：看到C选项，1，2，3进栈后，3出栈，而第二次出栈的只能是2或4，不可能是1，所以C错误！
了解了栈的概念，我们实现这个栈是使用顺序表还是链表呢？
如果是顺序表的话，我们的栈顶应该要在数组末尾！如果在数组头部的话，数据进栈时还需要挪动其余数据以便数据的存入！效率很低！如果是链表的话，我们的栈顶要在链表的头，入栈时，头插即可！如果栈顶在链表尾部的话，虽然入栈尾插即可，但需要遍历，效率低，那么这时就需要使用双链表！ 综上所述，我们栈使用顺序表较好！(两种都实现看看)
上图看看它们：
为了更好透彻了解顺序表和链表，我们将它们比较看看！
顺序表和链表的比较 图文更加直观：
这里的缓存利用率不做过多解释，详情见：https://www.cnblogs.com/yungyu16/p/13054874.html
栈的实现--顺序表 既然是要在顺序表基础上实现栈，那么就要实现顺序表和栈的基本框架。
（单链表若有不懂的知识点，可见：通讯录的实现（顺序表版本）-CSDN博客）
stack.h文件--包含各种需要的函数
栈里面的变量：top表示栈顶下标，capacity表示栈空间。
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;assert.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-09T18:05:30+08:00">
    <meta property="article:modified_time" content="2024-05-09T18:05:30+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】详解栈</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>今天我们主要来了解栈！如果对知识点有模糊，可翻阅以往文章哦！</p> 
<blockquote> 
 <p>个人主页：<a href="https://blog.csdn.net/Qiwaw?spm=1000.2115.3001.5343" title="小八哥向前冲~-CSDN博客">小八哥向前冲~-CSDN博客</a></p> 
 <p>所属专栏：<a href="https://blog.csdn.net/qiwaw/category_12656458.html" title="数据结构【c语言版】_小八哥向前冲~的博客-CSDN博客">数据结构【c语言版】_小八哥向前冲~的博客-CSDN博客</a></p> 
 <p>c语言专栏：<a href="https://blog.csdn.net/qiwaw/category_12656236.html" title="c语言_小八哥向前冲~的博客-CSDN博客">c语言_小八哥向前冲~的博客-CSDN博客</a></p> 
</blockquote> 
<p>值得注意的是，如果你十分了解顺序表和链表，今天这期会很轻松哦！</p> 
<p>哈哈哈哈！当然，这期也能检测你对顺序表和链表的理解！一起看看吧！</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:0px;"><a href="#%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">栈的定义</a></p> 
<p id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83-toc" style="margin-left:0px;"><a href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83" rel="nofollow">顺序表和链表的比较</a></p> 
<p id="%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0--%E9%A1%BA%E5%BA%8F%E8%A1%A8-toc" style="margin-left:0px;"><a href="#%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0--%E9%A1%BA%E5%BA%8F%E8%A1%A8" rel="nofollow">栈的实现--顺序表</a></p> 
<p id="%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:40px;"><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">初始化</a></p> 
<p id="%E6%A0%88%E4%B8%BA%E7%A9%BA%E7%9A%84%E5%88%A4%E5%AE%9A-toc" style="margin-left:40px;"><a href="#%E6%A0%88%E4%B8%BA%E7%A9%BA%E7%9A%84%E5%88%A4%E5%AE%9A" rel="nofollow">栈为空的判定</a></p> 
<p id="%E5%85%A5%E6%A0%88-toc" style="margin-left:40px;"><a href="#%E5%85%A5%E6%A0%88" rel="nofollow">入栈</a></p> 
<p id="%E5%87%BA%E6%A0%88-toc" style="margin-left:40px;"><a href="#%E5%87%BA%E6%A0%88" rel="nofollow">出栈</a></p> 
<p id="%E9%94%80%E6%AF%81-toc" style="margin-left:40px;"><a href="#%E9%94%80%E6%AF%81" rel="nofollow">销毁</a></p> 
<p id="%E6%A0%88%E9%A1%B6%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#%E6%A0%88%E9%A1%B6%E6%95%B0%E6%8D%AE" rel="nofollow">栈顶数据</a></p> 
<p id="%E6%95%B0%E6%8D%AE%E4%B8%AA%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E6%95%B0%E6%8D%AE%E4%B8%AA%E6%95%B0" rel="nofollow">数据个数</a></p> 
<p id="%E9%A2%98%E7%9B%AE%E6%93%8D%E7%BB%83%EF%BC%9A%E9%85%8D%E7%AC%A6%E5%8F%B7%E9%97%AE%E9%A2%98-toc" style="margin-left:0px;"><a href="#%E9%A2%98%E7%9B%AE%E6%93%8D%E7%BB%83%EF%BC%9A%E9%85%8D%E7%AC%A6%E5%8F%B7%E9%97%AE%E9%A2%98" rel="nofollow">题目操练：配括号问题</a></p> 
<p id="%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0--%E9%93%BE%E8%A1%A8-toc" style="margin-left:0px;"><a href="#%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0--%E9%93%BE%E8%A1%A8" rel="nofollow">栈的实现--链表</a></p> 
<p id="%E6%A0%88%E4%B8%BA%E7%A9%BA%E7%9A%84%E5%88%A4%E5%AE%9A-toc" style="margin-left:40px;"><a href="#%E6%A0%88%E4%B8%BA%E7%A9%BA%E7%9A%84%E5%88%A4%E5%AE%9A" rel="nofollow">栈为空的判定</a></p> 
<p id="%E5%85%A5%E6%A0%88-toc" style="margin-left:40px;"><a href="#%E5%85%A5%E6%A0%88" rel="nofollow">入栈</a></p> 
<p id="%E5%87%BA%E6%A0%88-toc" style="margin-left:40px;"><a href="#%E5%87%BA%E6%A0%88" rel="nofollow">出栈</a></p> 
<p id="%E9%94%80%E6%AF%81-toc" style="margin-left:40px;"><a href="#%E9%94%80%E6%AF%81" rel="nofollow">销毁</a></p> 
<p id="%E6%A0%88%E9%A1%B6%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#%E6%A0%88%E9%A1%B6%E6%95%B0%E6%8D%AE" rel="nofollow">栈顶数据</a></p> 
<p id="%E6%95%B0%E6%8D%AE%E4%B8%AA%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E6%95%B0%E6%8D%AE%E4%B8%AA%E6%95%B0" rel="nofollow">数据个数</a></p> 
<p id="%E6%A0%88%E4%B8%BA%E7%A9%BA%E7%9A%84%E5%88%A4%E5%AE%9A-toc" style="margin-left:0px;"><a href="#%E6%A0%88%E4%B8%BA%E7%A9%BA%E7%9A%84%E5%88%A4%E5%AE%9A" rel="nofollow">码源--栈（顺序表）</a></p> 
<p id="%E7%A0%81%E6%BA%90--%E6%A0%88%EF%BC%88%E9%93%BE%E8%A1%A8%EF%BC%89-toc" style="margin-left:0px;"><a href="#%E7%A0%81%E6%BA%90--%E6%A0%88%EF%BC%88%E9%93%BE%E8%A1%A8%EF%BC%89" rel="nofollow">码源--栈（链表）</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89">栈的定义</h2> 
<ul><li><strong>栈</strong>：一种<span style="color:#fe2c24;">特殊的线性表</span>，其<span style="color:#fe2c24;">只允许在固定的一端进行插入和删除元素操作</span>。进行数据插入和删除操作的一端 称为<span style="color:#fe2c24;">栈顶</span>，另一端称为<span style="color:#fe2c24;">栈底</span>。栈中的数据元素遵守<span style="color:#fe2c24;">后进先出</span>LIFO（Last In First Out）的原则。</li><li><strong>压栈</strong>：栈的插入操作叫做进栈/压栈/入栈，<span style="color:#fe2c24;">入数据在栈顶</span>。</li><li><strong>出栈</strong>：栈的删除操作叫做出栈。<span style="color:#fe2c24;">出数据也在栈顶</span>。</li></ul> 
<p>上图理解一下：</p> 
<p><img alt="" src="https://images2.imgbox.com/8c/e4/prTGd0n7_o.png"></p> 
<p><strong><span style="color:#fe2c24;">注意：遵循后进先出的原则！</span></strong></p> 
<p>知道了这个原则，我们来巩固一下：</p> 
<blockquote> 
 <p>1.一个栈的初始状态为空。现将元素1、2、3、4、5、A、B、C、D、E依次入栈，然后再依次出栈，则元素出 栈的顺序是（ ）。</p> 
 <p>A .12345ABCDE</p> 
 <p>B.EDCBA54321</p> 
 <p>C.ABCDE12345</p> 
 <p>D.54321EDCBA</p> 
 <p>2.若进栈序列为 1,2,3,4 ，进栈过程中可以出栈，则下列不可能的一个出栈序列是（）</p> 
 <p>A.1,4,3,2</p> 
 <p>B.2,3,4,1</p> 
 <p>C.3,1,4,2</p> 
 <p>D.3,4,2,1</p> 
</blockquote> 
<p>显然：1.B      2.C</p> 
<p><span style="background-color:#a2e043;">相信第一题不难，我们解释一下第二题：看到C选项，1，2，3进栈后，3出栈，而第二次出栈的只能是2或4，不可能是1，所以C错误！</span></p> 
<p><strong>了解了栈的概念，我们实现这个栈是使用顺序表还是链表呢？</strong></p> 
<ul><li>如果是顺序表的话，<span style="color:#fe2c24;">我们的栈顶应该要在数组末尾</span>！如果<span style="color:#fe2c24;">在数组头部的话</span>，数据进栈时还需要挪动其余数据以便数据的存入！<span style="color:#fe2c24;">效率很低</span>！</li><li>如果是链表的话，我们的<span style="color:#fe2c24;">栈顶要在链表的头</span>，<span style="color:#fe2c24;">入栈时，头插即可</span>！如果<span style="color:#fe2c24;">栈顶在链表尾部的话</span>，虽然入栈尾插即可，但<span style="color:#fe2c24;">需要遍历，效率低</span>，那么这时就需要使用双链表！</li></ul> 
<p><span style="color:#fe2c24;"><strong>综上所述，我们栈使用顺序表较好！(两种都实现看看)</strong></span></p> 
<p>上图看看它们：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/98/e7/X6aesNOE_o.png"></p> 
<p>为了更好透彻了解顺序表和链表，我们将它们比较看看！</p> 
<h2 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83">顺序表和链表的比较</h2> 
<p>图文更加直观：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/98/9d/LAb5cRDF_o.png"></p> 
<p><span style="color:#fe2c24;"><strong>这里的缓存利用率不做过多解释，详情见</strong></span>：<a href="https://www.cnblogs.com/yungyu16/p/13054874.html" rel="nofollow" title="https://www.cnblogs.com/yungyu16/p/13054874.html">https://www.cnblogs.com/yungyu16/p/13054874.html</a></p> 
<h2 id="%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0--%E9%A1%BA%E5%BA%8F%E8%A1%A8">栈的实现--顺序表</h2> 
<p>既然是要在顺序表基础上实现栈，那么就要实现顺序表和栈的基本框架。</p> 
<p><span style="color:#fe2c24;">（单链表若有不懂的知识点，可见：<a href="https://blog.csdn.net/Qiwaw/article/details/137750610" title="通讯录的实现（顺序表版本）-CSDN博客">通讯录的实现（顺序表版本）-CSDN博客</a>）</span></p> 
<p><strong>stack.h文件--包含各种需要的函数</strong></p> 
<p><strong>栈里面的变量：top表示栈顶下标，capacity表示栈空间。</strong></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdbool.h&gt;

typedef int STDateType;
//栈
typedef struct stack
{
	STDateType* a;
	int top;
	int capacity;
}ST;

//栈的初始化和销毁
void STInit(ST* p);
void STDestroy(ST* p);
//入栈，出栈
void STpush(ST* p,STDateType x);
void STpop(ST* p);
//栈顶的数据
STDateType STtop(ST* p);
//栈的数据个数
int STsize(ST* p);
//判空
bool STEmpty(ST* p);</code></pre> 
<p>接下来我们一一实现！</p> 
<h3 id="%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</h3> 
<p><span style="background-color:#a2e043;">我们要将栈中各个变量进行初始化。</span></p> 
<pre><code class="language-cpp">void STInit(ST* p)
{
	assert(p);
	p-&gt;a = NULL;
	p-&gt;capacity = 0;
	p-&gt;top = 0;
}</code></pre> 
<h3 id="%E6%A0%88%E4%B8%BA%E7%A9%BA%E7%9A%84%E5%88%A4%E5%AE%9A">栈为空的判定</h3> 
<p><span style="background-color:#a2e043;">我们在实现这个函数时，很多人会用 if语句来判断是否为空，但我们仔细一想，可以好好优化一下代码！</span></p> 
<pre><code class="language-cpp">//判空
bool STEmpty(ST* p)
{
	assert(p);
	return p-&gt;top == 0;
}</code></pre> 
<h3 id="%E5%85%A5%E6%A0%88">入栈</h3> 
<p><span style="background-color:#a2e043;">经过我们刚刚的分析，入栈要在数组尾部！记得每次入栈需要判断空间是否够用哦！</span></p> 
<pre><code class="language-cpp">void STpush(ST* p, STDateType x)
{
	assert(p);
	if (p-&gt;top == p-&gt;capacity)
	{
		int newcapacity = p-&gt;capacity == 0 ? 4 : p-&gt;capacity * 2;
		STDateType* tmp = (STDateType*)realloc(p-&gt;a, newcapacity * sizeof(STDateType));
		if (tmp == NULL)
		{
			perror("realloc failed!");
			return;
		}
		p-&gt;a = tmp;
		p-&gt;capacity = newcapacity;
	}
	p-&gt;a[p-&gt;top++] = x;
}</code></pre> 
<h3 id="%E5%87%BA%E6%A0%88">出栈</h3> 
<p><span style="background-color:#a2e043;">入栈要在尾部，出栈也要在尾部，后进先出的原则要时刻记住！</span></p> 
<p><span style="color:#fe2c24;"><span style="background-color:#a2e043;">需要注意的是：当栈为空时，数据出不了栈！所以我们先需要判断是否为空！</span></span></p> 
<pre><code class="language-cpp">void STpop(ST* p)
{
	assert(p);
	//出栈的话要判断一下空的情况
	assert(!STEmpty(p));
	p-&gt;top--;
}</code></pre> 
<h3 id="%E9%94%80%E6%AF%81">销毁</h3> 
<p><span style="background-color:#a2e043;">我们既然用了开辟内存函数，当我们不使用栈时，要将空间释放掉！</span></p> 
<pre><code class="language-cpp">void STDestroy(ST* p)
{
	assert(p);
	free(p-&gt;a);
	p-&gt;capacity = p-&gt;top = 0;
}</code></pre> 
<h3 id="%E6%A0%88%E9%A1%B6%E6%95%B0%E6%8D%AE">栈顶数据</h3> 
<p><span style="background-color:#cbe0f1;">在访问栈顶数据时，我们也要先判断栈是否为空，否则当栈为空时，访问栈顶数据便会越界访问！</span></p> 
<pre><code class="language-cpp">//栈顶的数据
STDateType STtop(ST* p)
{
	assert(p);
	//出栈的话要判断一下空的情况
	assert(!STEmpty(p));
	return p-&gt;a[p-&gt;top-1];
}</code></pre> 
<h3 id="%E6%95%B0%E6%8D%AE%E4%B8%AA%E6%95%B0">数据个数</h3> 
<pre><code class="language-cpp">//栈的数据个数
int STsize(ST* p)
{
	assert(p);
	return p-&gt;top;
}</code></pre> 
<h2 id="%E9%A2%98%E7%9B%AE%E6%93%8D%E7%BB%83%EF%BC%9A%E9%85%8D%E7%AC%A6%E5%8F%B7%E9%97%AE%E9%A2%98">题目操练：配括号问题</h2> 
<p>既然我们已经实现的栈，我们来应用一下吧！</p> 
<p><strong>题目：</strong>详情--<a href="https://leetcode.cn/problems/valid-parentheses/description/" rel="nofollow" title="20. 有效的括号 - 力扣（LeetCode）">20. 有效的括号 - 力扣（LeetCode）</a></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/55/4e/tAVj4sh1_o.png"></p> 
<p><strong>思路：</strong></p> 
<p><span style="background-color:#c7e6ea;">遍历数组，当是左括号时（"(","{","】"）时就入栈，当不是左括号时就出栈比较，直到遍历完成！</span></p> 
<p><span style="background-color:#c7e6ea;">这样听是不是很简单呢？当然里面没有栈，我们需要将栈创建一下！</span></p> 
<p><strong>代码：</strong></p> 
<pre><code class="language-cpp">typedef char STDateType;
//栈
typedef struct stack
{
	STDateType* a;
	int top;
	int capacity;
}ST;

//栈的初始化和销毁
void STInit(ST* p);
void STDestroy(ST* p);
//入栈，出栈
void STpush(ST* p,STDateType x);
void STpop(ST* p);
//栈顶的数据
STDateType STtop(ST* p);
//栈的数据个数
int STsize(ST* p);
//判空
bool STEmpty(ST* p);
//栈的初始化和销毁
void STInit(ST* p)
{
	assert(p);
	p-&gt;a = NULL;
	p-&gt;capacity = 0;
	p-&gt;top = 0;
}
void STDestroy(ST* p)
{
	assert(p);
	free(p-&gt;a);
	p-&gt;capacity = p-&gt;top = 0;
}
//入栈，出栈
void STpush(ST* p, STDateType x)
{
	assert(p);
	if (p-&gt;top == p-&gt;capacity)
	{
		int newcapacity = p-&gt;capacity == 0 ? 4 : p-&gt;capacity * 2;
		STDateType* tmp = (STDateType*)realloc(p-&gt;a, newcapacity * sizeof(STDateType));
		if (tmp == NULL)
		{
			perror("realloc failed!");
			return;
		}
		p-&gt;a = tmp;
		p-&gt;capacity = newcapacity;
	}
	p-&gt;a[p-&gt;top++] = x;
}
void STpop(ST* p)
{
	assert(p);
	//出栈的话要判断一下空的情况
	assert(!STEmpty(p));
	p-&gt;top--;
}
//栈顶的数据
STDateType STtop(ST* p)
{
	assert(p);
	//出栈的话要判断一下空的情况
	assert(!STEmpty(p));
	return p-&gt;a[p-&gt;top-1];
}
//栈的数据个数
int STsize(ST* p)
{
	assert(p);
	return p-&gt;top;
}
//判空
bool STEmpty(ST* p)
{
	assert(p);
	return p-&gt;top == 0;
}
bool isValid(char* s) {
    ST st;
    STInit(&amp;st);
    while(*s)
    {
//左括号入栈
        if(*s=='('||*s=='['||*s=='{')
        {
            STpush(&amp;st,*s);
        }
        else
//不是左括号出栈比较
        {
            if(STEmpty(&amp;st))
            {
                STDestroy(&amp;st);
                return false;
            }
            char top=STtop(&amp;st);
            STpop(&amp;st);
            if(top=='('&amp;&amp;*s!=')'
            ||top=='['&amp;&amp;*s!=']'
            ||top=='{'&amp;&amp;*s!='}')
            {
            STDestroy(&amp;st);
            return false;
            }
        }
        s++;
    }
//当栈中没有左括号比较完时，便匹配不成
    bool ret=STEmpty(&amp;st);
    STDestroy(&amp;st);
    return ret;
}</code></pre> 
<p>可能有人说太麻烦了，但c语言中没有栈，只能自己创建哦！这是用目前c语言最简单的方法！</p> 
<h2 id="%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0--%E9%93%BE%E8%A1%A8">栈的实现--链表</h2> 
<p>和顺序表一样，我们首先要创建栈和链表的基本框架！</p> 
<p><strong>stack.h文件--包含需要的函数</strong></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdbool.h&gt;

typedef int STDataType;
//栈
typedef struct stack
{
	struct stcak* next;
	STDataType data;
}STNode;


//栈的销毁
void STDestroy(STNode* phead);
//入栈
void STpush(STNode** pphead,STDataType x);
//出栈
void STpop(STNode** pphead);
//栈顶数据
STDataType STtop(STNode* phead);
//判空
bool STEmpty(STNode* phead);
//栈数据个数
int STsize(STNode* phead);</code></pre> 
<h3>栈为空的判定</h3> 
<p><span style="background-color:#79c6cd;">有了顺序表的基础，接下来依葫芦画瓢----最简单不过！</span></p> 
<pre><code class="language-cpp">//判空
bool STEmpty(STNode* phead)
{
	return phead == NULL;
}</code></pre> 
<h3>入栈</h3> 
<p><span style="background-color:#79c6cd;">我们分析将链表的头部为栈顶，进出都在头！（这种方案最佳！）</span></p> 
<pre><code class="language-cpp">//创建节点
STNode* STBuyNode(STDataType x)
{
	STNode* node = (STNode*)malloc(sizeof(STNode));
	if (node == NULL)
	{
		perror("malloc failed!");
		return NULL;
	}
	node-&gt;data = x;
	node-&gt;next = NULL;
	return node;
}

//入栈
void STpush(STNode** pphead, STDataType x)
{
	STNode* node = STBuyNode(x);
	node-&gt;next = *pphead;
	*pphead = node;
}
</code></pre> 
<h3>出栈</h3> 
<p><span style="background-color:#c7e6ea;">将头节点指向下一个节点，原来的头节点释放！</span></p> 
<pre><code class="language-cpp">//出栈
void STpop(STNode** pphead)
{
	assert(!STEmpty(*pphead));
	STNode* cur = *pphead;
	*pphead = (*pphead)-&gt;next;
	free(cur);
}</code></pre> 
<h3>销毁</h3> 
<p><span style="background-color:#e7fafa;">同样的，动态开辟了空间，当我们不用栈时，要将开辟的空间释放掉！</span></p> 
<pre><code class="language-cpp">//栈的销毁
void STDestroy(STNode* phead)
{
	STNode* cur = phead;
	while (cur)
	{
		STNode* next = cur-&gt;next;
		free(cur);
		cur = next;
	}
}</code></pre> 
<h3>栈顶数据</h3> 
<p><span style="background-color:#cccccc;">也是一样的，在访问栈顶数据时，要判断栈是否为空，防止越界访问！</span></p> 
<pre><code class="language-cpp">//栈顶数据
STDataType STtop(STNode* phead)
{
	assert(!STEmpty(phead));
	return phead-&gt;data;
}</code></pre> 
<h3>数据个数</h3> 
<p><span style="background-color:#efedf6;">遍历链表，将一个一个节点计数起来！</span></p> 
<pre><code class="language-cpp">//栈数据个数
int STsize(STNode* phead)
{
	STNode* cur = phead;
	int count = 0;
	while (cur)
	{
		count++;
		cur = cur-&gt;next;
	}
	return count;
}</code></pre> 
<h2>码源--栈（顺序表）</h2> 
<p><strong>stack.h文件</strong></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdbool.h&gt;

typedef int STDateType;
//栈
typedef struct stack
{
	STDateType* a;
	int top;
	int capacity;
}ST;

//栈的初始化和销毁
void STInit(ST* p);
void STDestroy(ST* p);
//入栈，出栈
void STpush(ST* p,STDateType x);
void STpop(ST* p);
//栈顶的数据
STDateType STtop(ST* p);
//栈的数据个数
int STsize(ST* p);
//判空
bool STEmpty(ST* p);</code></pre> 
<p><strong>stack.c文件</strong></p> 
<pre><code class="language-cpp">#include"stack.h"
//栈的初始化和销毁
void STInit(ST* p)
{
	assert(p);
	p-&gt;a = NULL;
	p-&gt;capacity = 0;
	p-&gt;top = 0;
}
void STDestroy(ST* p)
{
	assert(p);
	free(p-&gt;a);
	p-&gt;capacity = p-&gt;top = 0;
}
//入栈，出栈
void STpush(ST* p, STDateType x)
{
	assert(p);
	if (p-&gt;top == p-&gt;capacity)
	{
		int newcapacity = p-&gt;capacity == 0 ? 4 : p-&gt;capacity * 2;
		STDateType* tmp = (STDateType*)realloc(p-&gt;a, newcapacity * sizeof(STDateType));
		if (tmp == NULL)
		{
			perror("realloc failed!");
			return;
		}
		p-&gt;a = tmp;
		p-&gt;capacity = newcapacity;
	}
	p-&gt;a[p-&gt;top++] = x;
}
void STpop(ST* p)
{
	assert(p);
	//出栈的话要判断一下空的情况
	assert(!STEmpty(p));
	p-&gt;top--;
}
//栈顶的数据
STDateType STtop(ST* p)
{
	assert(p);
	//出栈的话要判断一下空的情况
	assert(!STEmpty(p));
	return p-&gt;a[p-&gt;top-1];
}
//栈的数据个数
int STsize(ST* p)
{
	assert(p);
	return p-&gt;top;
}
//判空
bool STEmpty(ST* p)
{
	assert(p);
	return p-&gt;top == 0;
}</code></pre> 
<h2 id="%E7%A0%81%E6%BA%90--%E6%A0%88%EF%BC%88%E9%93%BE%E8%A1%A8%EF%BC%89">码源--栈（链表）</h2> 
<p><strong>stack.h文件</strong></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdbool.h&gt;

typedef int STDataType;
//栈
typedef struct stack
{
	struct stcak* next;
	STDataType data;
}STNode;


//栈的销毁
void STDestroy(STNode* phead);
//入栈
void STpush(STNode** pphead,STDataType x);
//出栈
void STpop(STNode** pphead);
//栈顶数据
STDataType STtop(STNode* phead);
//判空
bool STEmpty(STNode* phead);
//栈数据个数
int STsize(STNode* phead);</code></pre> 
<p><strong>stack.c文件</strong></p> 
<pre><code class="language-cpp">#include"stack.h"

STNode* STBuyNode(STDataType x)
{
	STNode* node = (STNode*)malloc(sizeof(STNode));
	if (node == NULL)
	{
		perror("malloc failed!");
		return NULL;
	}
	node-&gt;data = x;
	node-&gt;next = NULL;
	return node;
}

//入栈
void STpush(STNode** pphead, STDataType x)
{
	STNode* node = STBuyNode(x);
	node-&gt;next = *pphead;
	*pphead = node;
}

//出栈
void STpop(STNode** pphead)
{
	assert(!STEmpty(*pphead));
	STNode* cur = *pphead;
	*pphead = (*pphead)-&gt;next;
	free(cur);
}

//栈顶数据
STDataType STtop(STNode* phead)
{
	assert(!STEmpty(phead));
	return phead-&gt;data;
}

//判空
bool STEmpty(STNode* phead)
{
	return phead == NULL;
}

//栈数据个数
int STsize(STNode* phead)
{
	STNode* cur = phead;
	int count = 0;
	while (cur)
	{
		count++;
		cur = cur-&gt;next;
	}
	return count;
}

//栈的销毁
void STDestroy(STNode* phead)
{
	STNode* cur = phead;
	while (cur)
	{
		STNode* next = cur-&gt;next;
		free(cur);
		cur = next;
	}
}</code></pre> 
<p>是不是觉得今天的比较简单？好了，我们下期见！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c3490504e8ee02aba2c254ff2669e791/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">A100 解析：为何它成为 AI 大模型时代的首选？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e298aaee23e9269ac44327c26dffe669/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">[Flutter] 运行时报错Execution failed for task ‘:connectivity_plus:compileDebugJavaWithJavac‘ 解决方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>