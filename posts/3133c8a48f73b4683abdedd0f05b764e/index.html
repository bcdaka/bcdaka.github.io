<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据在内存中的存储＜C语言＞ - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/3133c8a48f73b4683abdedd0f05b764e/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据在内存中的存储＜C语言＞">
  <meta property="og:description" content="导言 在计算机中不同类型的数据在计算机内部存储形式各不相同，弄懂各种数据在计算机内部存储形式是有必要的，C语言的学习不能浮于表面，更要锻炼我们的“内功”，将来在写程序的时候遇见各种稀奇古怪的bug时，也便能迎刃而解，所以本文将着重介绍，整数在内存中的存储、大小端字节序和判断、浮点数的存储。
整数在内存中的存储 这部分的内容在前面已经讲过，现在让我们来复习一下：
一个数的二进制表示方法有三种：原码、反码、补码
原码：直接将数转为2进制序列，得到的就是原码
反码：符号位不变，将其它位取反
补码：在反码基础上&#43;1
在C语言中整数可分为有符号整数和无符号整数
有符号整数：有符号位（第一位），0为正、1为负
有符号整数：没有符号位，即全为正数。
在计算机内部存放的是补码，为啥是补码？
因为CPU只有加法器，在计算机内部，正数的补码是本身，负数补码符号位不变，其他位取反，存放补码可实现加减法的统一运算（不需要添加减法器）：
//在计算机内部存放的是补码，为啥是补码？ int main() { int a = 9; //a的补码：00000000 00000000 00000000 00001001 int b = 4; //b的补码：00000000 00000000 00000000 00000100 int c = a - b; //c=a-b会被转化为c=a&#43;(-b) // a的补码：00000000 00000000 00000000 00001001 //-b的补码：11111111 11111111 11111111 11111100 // c的补码 100000000 00000000 00000000 00000101 //相加结果多出一位，int型只有4字节、32位，高位抛弃 // c的补码: 00000000 00000000 00000000 00000101 //正数原反补相同，10进制数为5 printf(&#34;%d&#34;, c); return 0; } 运行结果：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-01T19:26:09+08:00">
    <meta property="article:modified_time" content="2024-06-01T19:26:09+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据在内存中的存储＜C语言＞</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>导言</h4> 
<p>        在计算机中不同类型的数据在计算机内部存储形式各不相同，弄懂各种数据在计算机内部存储形式是有必要的，C语言的学习不能浮于表面，更要锻炼我们的“内功”，将来在写程序的时候遇见各种稀奇古怪的bug时，也便能迎刃而解，所以本文将着重介绍，整数在内存中的存储、大小端字节序和判断、浮点数的存储。</p> 
<hr> 
<h4>整数在内存中的存储</h4> 
<p>       这部分的内容在前面已经讲过，现在让我们来复习一下：</p> 
<p>一个数的二进制表示方法有三种：原码、反码、补码</p> 
<p>        原码：直接将数转为2进制序列，得到的就是原码</p> 
<p>        反码：符号位不变，将其它位取反</p> 
<p>        补码：在反码基础上+1</p> 
<p>在C语言中整数可分为有符号整数和无符号整数</p> 
<p>        有符号整数：有符号位（第一位），0为正、1为负</p> 
<p>        有符号整数：没有符号位，即全为正数。</p> 
<p><strong>在计算机内部存放的是补码，</strong>为啥是补码？</p> 
<p>        因为CPU只有加法器，在计算机内部，正数的补码是本身，负数补码符号位不变，其他位取反，存放补码可实现加减法的统一运算（不需要添加减法器）：</p> 
<pre><code class="language-cpp">//在计算机内部存放的是补码，为啥是补码？
int main() {
	int a = 9;
	//a的补码：00000000 00000000 00000000 00001001
	int b = 4;
	//b的补码：00000000 00000000 00000000 00000100
	int c = a - b;
	//c=a-b会被转化为c=a+(-b)
	// a的补码：00000000 00000000 00000000 00001001
	//-b的补码：11111111 11111111 11111111 11111100
	// c的补码 100000000 00000000 00000000 00000101
	//相加结果多出一位，int型只有4字节、32位，高位抛弃
	// c的补码: 00000000 00000000 00000000 00000101
	//正数原反补相同，10进制数为5
	printf("%d", c);
	return 0;
}</code></pre> 
<p>运行结果：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ba/3a/8sn43MnW_o.png"></p> 
<hr> 
<h4> 大小端字节序和判断</h4> 
<p>        超过一个字节的数据在存储时就会有存储顺序的问题：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/02/c8/2qzmYqUb_o.png"></p> 
<p>         通过调试观察一个整型在内存中的存储可知：a的低位存储在低地址处，当前平台属于小端存储模式。</p> 
<p><strong>大端存储模式：</strong></p> 
<p>        是指数据的低位字节存储在内存空间的高位地址处。(大对大)</p> 
<p><strong>小端存储模式：</strong></p> 
<p><strong>        </strong>是指数据的低位字节存储在内存空间的低位地址处。(小对小)</p> 
<p><strong>为了更好的理解下面给出几道练习：</strong></p> 
<h5><strong>        </strong>练习1（百度笔试10分）</h5> 
<p>简述大端字节序和小端字节序的概念，设计一个程序来判断当前机器的字节序。</p> 
<p style="text-align:center;">        <img alt="" src="https://images2.imgbox.com/3c/1e/dy1pvFHU_o.png"></p> 
<h5>         <strong>练习2</strong></h5> 
<p>以下代码输出结果是啥？</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
//X86环境 ⼩端字节序 
int main()
{
	int a[4] = { 1, 2, 3, 4 };
	int* ptr1 = (int*)(&amp;a + 1);
	int* ptr2 = (int*)((int)a + 1);
	printf("%x,%x", ptr1[-1], *ptr2);
	return 0;
}</code></pre> 
<p><strong>运行结果：</strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/1d/71/8YXL0H7p_o.png"></p> 
<p> 分析一下：</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
//X86环境 ⼩端字节序 
int main()
{
	int a[4] = { 1, 2, 3, 4 };
	int* ptr1 = (int*)(&amp;a + 1);
    //&amp;a取出整个整个数组的地址(访问权限为4*sizeof(int)个字节)，再加1到元素4的后面
	int* ptr2 = (int*)((int)a + 1);
    //(int)a:将地址转为int类型的数，并加1,就是加了一个字节
    //因为当前平台为小端字节序，加1跳过了01，并从第二个字节开始00 00 00 02
	printf("%x,%x", ptr1[-1], *ptr2);
    //ptr[-1],访问权限为int型，倒退4字节，来到4的起始地址并打印
    //*ptr2:00 00 00 02，因为平台为小端字节序，所以该数为2000000
	return 0;
}</code></pre> 
<h4><strong>浮点数的存储</strong></h4> 
<p><strong>        </strong>浮点数的存储是比较特殊的，因为它具有小数位，如果采用整数存储方法肯定是不行的，于是IEEE（国际电气和电子工程协会）754规定，任意一个浮点数<strong>V</strong>可以表示为下面这种形式：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e0/71/Q6daeVfl_o.png"></p> 
<p>●-1的S次方:符号位，S为1时负数，S为0时正数</p> 
<p>●M:有效数字，M大于1小于2</p> 
<p>●E:指数位</p> 
<p>如10进制数5.5转为二进制数101.1</p> 
<p>那么S=1</p> 
<p>        M=1.011</p> 
<p>        E=2</p> 
<p>浮点数在存储时就是存储的SME，值得注意的是，常见浮点数float和double型的字节长度是不一样的，那么在存储时，SME的内存分配会有所不同：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/15/ec/vtwis3TZ_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e9/e8/zlLrEGjF_o.png"></p> 
<p>注意点：</p> 
<p>●前⾯说过， 1≤M，也就是说，M可以写成 1.xxxxxx 的形式，其中 xxxxxx 表⽰⼩数部分。 因此1.可以舍去。</p> 
<p>●指数E，E为一个无符号整数，为了能存负数，754规定：存入内存时E的真实值必须再加上一个中间数，float：127，double:1023</p> 
<p><strong>举例：</strong></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
int main()
{
	int n = 9;
	//小端字节序：00001001 00000000 00000000 00000000
	float* pFloat = (float*)&amp;n;
	//转为float,但是存储的数据没有发生变化，依旧是00001001 00000000 00000000 00000000
	printf("n的值为：%d\n", n);//9
	printf("*pFloat的值为：%f\n", *pFloat);//0.000000
	//以%f的形式打印，那么会把这个数据float的方式读取,也就是SEM的形式
	//0 0001001 000000000000000000000000=1.0*2的(9-127)次方，无限接近于0
	*pFloat = 9.0;
	//以浮点数存储也就是0 10000010 00100000000000000000000
	printf("num的值为：%d\n", n);
	//将0 10000010 00100000000000000000000以整数形式读取也就是1,091,567,616
	printf("*pFloat的值为：%f\n", *pFloat);
	//9.000000
	return 0;
}</code></pre> 
<p><strong>运行结果：</strong></p> 
<p style="text-align:center;"><strong><img alt="" src="https://images2.imgbox.com/21/8c/4IqHFi8l_o.png"></strong></p> 
<p> 值得注意的是在浮点数存储的时候，E有几种特殊情况：</p> 
<p>●E全为0时，还原成2进制数时，还要减去中间数，那么这个值就会无限的小（并且M不会加上省略的1），接近于0，超出数据表示范围</p> 
<p>●E全为1时，还原成2进制数时，255减去中间数，指数E为255，那么这个值就会无限的大，超出数据表示范围</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3156ce90cd5fe51a343dc7f2193afd66/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">从0开始制作微信小程序</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5e6f549841d6a080b9cd17c72d9c7533/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何在 Ubuntu 14.04 上使用 Apache 配置 WebDAV 访问</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>