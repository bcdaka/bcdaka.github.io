<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】包装类和泛型 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/d3d0756a3d0c9e737546fe53be37c73a/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】包装类和泛型">
  <meta property="og:description" content="🎉欢迎大家收看，请多多支持🌹
🥰关注小哇，和我一起成长🚀个人主页🚀
⭐在更专栏Java ⭐数据结构
⭐已更专栏有C语言、计算机网络⭐
👑目录
包装类🌙
⭐基本类型对应的包装类
⭐装箱与拆箱
🌈自动装箱和显式装箱
🚀自动装箱：
🚀显式装箱
🚀 Integer类的缓存机制：
🌈自动拆箱和显式拆箱
🚀自动拆箱
🚀显式拆箱
🌈相关面试题及知识点
泛型🌙
⭐语法
🌈基本泛型类定义：
🌈多类型参数的泛型类：
🌈泛型类继承自其它泛型类：
🌈泛型类继承自特定类型的泛型类：
🌈具体代码举例：
⭐泛型类的使用：
🌈语法：
🌈举例：
⭐裸类型（了解）：
⭐泛型的擦除机制（泛型如何编译）：
⭐泛型的上界
🌈语法：
🌈例子：
🌈复杂例子：
⭐泛型方法：
🌈方法示例：
🌈 使用方法示例：
🚀可以类型推导：
🚀不使用类型推导：
包装类🌙 Java中每个基本数据类型都对应了一个包装类，
除了int的包装类是Integer，char的包装类是Character，其他的基本类型对应的包装类都是将首字母大写。
⭐基本类型对应的包装类 基本数据类型包装类byteByteshortShortintIntegerlongLongcharCharacterbooleanBooleanfloatFloatdoubleDouble Java中的泛型中，不能直接使用基本数据类型作为类型参数；
如果需要使用与基本数据类型相关的泛型，应该使用它们对应的包装类。
⭐装箱与拆箱 又叫装包或拆包。
🌈自动装箱和显式装箱 🚀自动装箱： 自动地将基本数据类型（如int、double等）转换为它们对应的包装类（如Integer、Double等）
int a = 6; //自动装箱 Integer b = a; Integer b2 = (Integer)a; 🚀显式装箱 int a = 6; //显式装箱,调用valueOf()方法 Integer d = Integer.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-30T18:40:56+08:00">
    <meta property="article:modified_time" content="2024-07-30T18:40:56+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】包装类和泛型</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"><img alt="" height="355" src="https://images2.imgbox.com/27/49/GYyUV0ax_o.gif" width="710"></p> 
<p><img alt="" height="90" src="https://images2.imgbox.com/0e/fd/wvQYTarw_o.gif" width="722"></p> 
<blockquote> 
 <p style="text-align:center;"><span style="color:#b95514;"><span style="background-color:#fff5e6;"> 🎉欢迎大家收看，请多多支持🌹</span></span></p> 
 <p style="text-align:center;"><span style="color:#b95514;"><span style="background-color:#fff5e6;">🥰关注小哇，和我一起成长🚀<a href="https://blog.csdn.net/kiku20231213?spm=1010.2135.3001.5421" title="个人主页">个人主页</a>🚀</span></span></p> 
 <p style="text-align:center;">⭐<span style="color:#b95514;"><span style="background-color:#fff5e6;">在更专栏<a class="link-info" href="https://blog.csdn.net/kiku20231213/category_12737882.html" title="Java ⭐">Java ⭐</a><a class="link-info" href="https://blog.csdn.net/kiku20231213/category_12745355.html" title="数据结构">数据结构</a></span></span></p> 
 <p style="text-align:center;">⭐<span style="color:#b95514;"><span style="background-color:#fff5e6;">已更专栏有<a class="link-info" href="https://blog.csdn.net/kiku20231213/category_12648019.html" title="C语言">C语言</a></span></span>、<a class="link-info" href="https://blog.csdn.net/kiku20231213/category_12677275.html" title="计算机网络">计算机网络</a>⭐</p> 
</blockquote> 
<hr> 
<p id="main-toc"><strong>👑目录</strong></p> 
<p id="%E5%8C%85%E8%A3%85%E7%B1%BB%F0%9F%8C%99-toc" style="margin-left:0px;"><a href="#%E5%8C%85%E8%A3%85%E7%B1%BB%F0%9F%8C%99" rel="nofollow"><span style="color:#faa572;"><span style="background-color:#fefcd8;">包装类🌙</span></span></a></p> 
<p id="%E2%AD%90%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB-toc" style="margin-left:40px;"><a href="#%E2%AD%90%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB" rel="nofollow"><span style="color:#faa572;"><span style="background-color:#fefcd8;">⭐基本类型对应的包装类</span></span></a></p> 
<p id="%E2%AD%90%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1-toc" style="margin-left:40px;"><a href="#%E2%AD%90%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1" rel="nofollow"><span style="color:#faa572;"><span style="background-color:#fefcd8;">⭐装箱与拆箱</span></span></a></p> 
<p id="%F0%9F%8C%88%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E6%98%BE%E5%BC%8F%E8%A3%85%E7%AE%B1-toc" style="margin-left:80px;"><a href="#%F0%9F%8C%88%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E6%98%BE%E5%BC%8F%E8%A3%85%E7%AE%B1" rel="nofollow"><span style="color:#faa572;"><span style="background-color:#fefcd8;">🌈自动装箱和显式装箱</span></span></a></p> 
<p id="%F0%9F%9A%80%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%EF%BC%9A-toc" style="margin-left:120px;"><a href="#%F0%9F%9A%80%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%EF%BC%9A" rel="nofollow"><span style="color:#faa572;"><span style="background-color:#fefcd8;">🚀自动装箱：</span></span></a></p> 
<p id="%F0%9F%9A%80%E6%98%BE%E5%BC%8F%E8%A3%85%E7%AE%B1-toc" style="margin-left:120px;"><a href="#%F0%9F%9A%80%E6%98%BE%E5%BC%8F%E8%A3%85%E7%AE%B1" rel="nofollow"><span style="color:#faa572;"><span style="background-color:#fefcd8;">🚀显式装箱</span></span></a></p> 
<p id="%F0%9F%9A%80%C2%A0Integer%E7%B1%BB%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%EF%BC%9A-toc" style="margin-left:120px;"><a href="#%F0%9F%9A%80%C2%A0Integer%E7%B1%BB%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%EF%BC%9A" rel="nofollow"><span style="color:#faa572;"><span style="background-color:#fefcd8;">🚀 Integer类的缓存机制：</span></span></a></p> 
<p id="%F0%9F%8C%88%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%E5%92%8C%E6%98%BE%E5%BC%8F%E6%8B%86%E7%AE%B1-toc" style="margin-left:80px;"><a href="#%F0%9F%8C%88%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%E5%92%8C%E6%98%BE%E5%BC%8F%E6%8B%86%E7%AE%B1" rel="nofollow"><span style="color:#faa572;"><span style="background-color:#fefcd8;">🌈自动拆箱和显式拆箱</span></span></a></p> 
<p id="%F0%9F%9A%80%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1-toc" style="margin-left:120px;"><a href="#%F0%9F%9A%80%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1" rel="nofollow"><span style="color:#faa572;"><span style="background-color:#fefcd8;">🚀自动拆箱</span></span></a></p> 
<p id="%F0%9F%9A%80%E6%98%BE%E5%BC%8F%E6%8B%86%E7%AE%B1-toc" style="margin-left:120px;"><a href="#%F0%9F%9A%80%E6%98%BE%E5%BC%8F%E6%8B%86%E7%AE%B1" rel="nofollow"><span style="color:#faa572;"><span style="background-color:#fefcd8;">🚀显式拆箱</span></span></a></p> 
<p id="%C2%A0%F0%9F%8C%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%9F%A5%E8%AF%86%E7%82%B9-toc" style="margin-left:80px;"><a href="#%C2%A0%F0%9F%8C%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%9F%A5%E8%AF%86%E7%82%B9" rel="nofollow"><span style="color:#faa572;"><span style="background-color:#fefcd8;"> 🌈相关面试题及知识点</span></span></a></p> 
<p id="%E6%B3%9B%E5%9E%8B%F0%9F%8C%99-toc" style="margin-left:0px;"><a href="#%E6%B3%9B%E5%9E%8B%F0%9F%8C%99" rel="nofollow"><span style="color:#be191c;"><span style="background-color:#fff5e6;">泛型🌙</span></span></a></p> 
<p id="%E2%AD%90%E8%AF%AD%E6%B3%95-toc" style="margin-left:40px;"><a href="#%E2%AD%90%E8%AF%AD%E6%B3%95" rel="nofollow"><span style="color:#be191c;"><span style="background-color:#fff5e6;">⭐语法</span></span></a></p> 
<p id="%F0%9F%8C%88%E5%9F%BA%E6%9C%AC%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%AE%9A%E4%B9%89%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%F0%9F%8C%88%E5%9F%BA%E6%9C%AC%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%AE%9A%E4%B9%89%EF%BC%9A" rel="nofollow"><span style="color:#be191c;"><span style="background-color:#fff5e6;">🌈基本泛型类定义：</span></span></a></p> 
<p id="%F0%9F%8C%88%E5%A4%9A%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E6%B3%9B%E5%9E%8B%E7%B1%BB%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%F0%9F%8C%88%E5%A4%9A%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E6%B3%9B%E5%9E%8B%E7%B1%BB%EF%BC%9A" rel="nofollow"><span style="color:#be191c;"><span style="background-color:#fff5e6;">🌈多类型参数的泛型类：</span></span></a></p> 
<p id="%F0%9F%8C%88%E6%B3%9B%E5%9E%8B%E7%B1%BB%E7%BB%A7%E6%89%BF%E8%87%AA%E5%85%B6%E5%AE%83%E6%B3%9B%E5%9E%8B%E7%B1%BB%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%F0%9F%8C%88%E6%B3%9B%E5%9E%8B%E7%B1%BB%E7%BB%A7%E6%89%BF%E8%87%AA%E5%85%B6%E5%AE%83%E6%B3%9B%E5%9E%8B%E7%B1%BB%EF%BC%9A" rel="nofollow"><span style="color:#be191c;"><span style="background-color:#fff5e6;">🌈泛型类继承自其它泛型类：</span></span></a></p> 
<p id="%F0%9F%8C%88%E6%B3%9B%E5%9E%8B%E7%B1%BB%E7%BB%A7%E6%89%BF%E8%87%AA%E7%89%B9%E5%AE%9A%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%B3%9B%E5%9E%8B%E7%B1%BB%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%F0%9F%8C%88%E6%B3%9B%E5%9E%8B%E7%B1%BB%E7%BB%A7%E6%89%BF%E8%87%AA%E7%89%B9%E5%AE%9A%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%B3%9B%E5%9E%8B%E7%B1%BB%EF%BC%9A" rel="nofollow"><span style="color:#be191c;"><span style="background-color:#fff5e6;">🌈泛型类继承自特定类型的泛型类：</span></span></a></p> 
<p id="%C2%A0%F0%9F%8C%88%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0%F0%9F%8C%88%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B%EF%BC%9A" rel="nofollow"><span style="color:#be191c;"><span style="background-color:#fff5e6;"> 🌈具体代码举例：</span></span></a></p> 
<p id="%E2%AD%90%E6%B3%9B%E5%9E%8B%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E2%AD%90%E6%B3%9B%E5%9E%8B%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A" rel="nofollow"><span style="color:#be191c;"><span style="background-color:#fff5e6;">⭐泛型类的使用：</span></span></a></p> 
<p id="%F0%9F%8C%88%E8%AF%AD%E6%B3%95%EF%BC%9A-toc" style="margin-left:120px;"><a href="#%F0%9F%8C%88%E8%AF%AD%E6%B3%95%EF%BC%9A" rel="nofollow"><span style="color:#be191c;"><span style="background-color:#fff5e6;">🌈语法：</span></span></a></p> 
<p id="%F0%9F%8C%88%E4%B8%BE%E4%BE%8B%EF%BC%9A-toc" style="margin-left:120px;"><a href="#%F0%9F%8C%88%E4%B8%BE%E4%BE%8B%EF%BC%9A" rel="nofollow"><span style="color:#be191c;"><span style="background-color:#fff5e6;">🌈举例：</span></span></a></p> 
<p id="%E2%AD%90%E8%A3%B8%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E2%AD%90%E8%A3%B8%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89%EF%BC%9A" rel="nofollow"><span style="color:#be191c;"><span style="background-color:#fff5e6;">⭐裸类型（了解）：</span></span></a></p> 
<p id="%E2%AD%90%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%93%A6%E9%99%A4%E6%9C%BA%E5%88%B6%EF%BC%88%E6%B3%9B%E5%9E%8B%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%EF%BC%89%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E2%AD%90%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%93%A6%E9%99%A4%E6%9C%BA%E5%88%B6%EF%BC%88%E6%B3%9B%E5%9E%8B%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%EF%BC%89%EF%BC%9A" rel="nofollow"><span style="color:#be191c;"><span style="background-color:#fff5e6;">⭐泛型的擦除机制（泛型如何编译）：</span></span></a></p> 
<p id="%E2%AD%90%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%B8%8A%E7%95%8C-toc" style="margin-left:40px;"><a href="#%E2%AD%90%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%B8%8A%E7%95%8C" rel="nofollow"><span style="color:#be191c;"><span style="background-color:#fff5e6;">⭐泛型的上界</span></span></a></p> 
<p id="%F0%9F%8C%88%E8%AF%AD%E6%B3%95%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%F0%9F%8C%88%E8%AF%AD%E6%B3%95%EF%BC%9A" rel="nofollow"><span style="color:#be191c;"><span style="background-color:#fff5e6;">🌈语法：</span></span></a></p> 
<p id="%F0%9F%8C%88%E4%BE%8B%E5%AD%90%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%F0%9F%8C%88%E4%BE%8B%E5%AD%90%EF%BC%9A" rel="nofollow"><span style="color:#be191c;"><span style="background-color:#fff5e6;">🌈例子：</span></span></a></p> 
<p id="%F0%9F%8C%88%E5%A4%8D%E6%9D%82%E4%BE%8B%E5%AD%90%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%F0%9F%8C%88%E5%A4%8D%E6%9D%82%E4%BE%8B%E5%AD%90%EF%BC%9A" rel="nofollow"><span style="color:#be191c;"><span style="background-color:#fff5e6;">🌈复杂例子：</span></span></a></p> 
<p id="%E2%AD%90%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E2%AD%90%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%EF%BC%9A" rel="nofollow"><span style="color:#be191c;"><span style="background-color:#fff5e6;">⭐泛型方法：</span></span></a></p> 
<p id="%F0%9F%8C%88%E6%96%B9%E6%B3%95%E7%A4%BA%E4%BE%8B%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%F0%9F%8C%88%E6%96%B9%E6%B3%95%E7%A4%BA%E4%BE%8B%EF%BC%9A" rel="nofollow"><span style="color:#be191c;"><span style="background-color:#fff5e6;">🌈方法示例：</span></span></a></p> 
<p id="%F0%9F%8C%88%C2%A0%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%A4%BA%E4%BE%8B%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%F0%9F%8C%88%C2%A0%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%A4%BA%E4%BE%8B%EF%BC%9A" rel="nofollow"><span style="color:#be191c;"><span style="background-color:#fff5e6;">🌈 使用方法示例：</span></span></a></p> 
<p id="%F0%9F%9A%80%E5%8F%AF%E4%BB%A5%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%EF%BC%9A-toc" style="margin-left:120px;"><a href="#%F0%9F%9A%80%E5%8F%AF%E4%BB%A5%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%EF%BC%9A" rel="nofollow"><span style="color:#be191c;"><span style="background-color:#fff5e6;">🚀可以类型推导：</span></span></a></p> 
<p id="%F0%9F%9A%80%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%EF%BC%9A-toc" style="margin-left:120px;"><a href="#%F0%9F%9A%80%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%EF%BC%9A" rel="nofollow"><span style="color:#be191c;"><span style="background-color:#fff5e6;">🚀不使用类型推导：</span></span></a></p> 
<hr id="hr-toc"> 
<p></p> 
<p></p> 
<h2 id="%E5%8C%85%E8%A3%85%E7%B1%BB%F0%9F%8C%99">包装类🌙</h2> 
<p>Java中每个基本数据类型都对应了一个包装类，</p> 
<p>除了int的包装类是Integer，char的包装类是Character，其他的基本类型对应的包装类都是将首字母大写。</p> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:500px;"><caption> 
  <h3 id="%E2%AD%90%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB">⭐基本类型对应的包装类</h3> 
 </caption><tbody><tr><td style="width:246px;"><strong>基本数据类型</strong></td><td style="width:252px;"><strong>包装类</strong></td></tr><tr><td style="width:246px;">byte</td><td style="width:252px;">Byte</td></tr><tr><td style="width:246px;">short</td><td style="width:252px;">Short</td></tr><tr><td style="width:246px;">int</td><td style="width:252px;">Integer</td></tr><tr><td style="width:246px;">long</td><td style="width:252px;">Long</td></tr><tr><td style="width:246px;">char</td><td style="width:252px;">Character</td></tr><tr><td style="width:246px;">boolean</td><td style="width:252px;">Boolean</td></tr><tr><td style="width:246px;">float</td><td style="width:252px;">Float</td></tr><tr><td style="width:246px;">double</td><td style="width:252px;">Double</td></tr></tbody></table> 
<p>Java中的泛型中，不能直接使用基本数据类型作为类型参数；</p> 
<p>如果需要使用与基本数据类型相关的泛型，应该使用它们对应的包装类。</p> 
<h3 id="%E2%AD%90%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1">⭐装箱与拆箱</h3> 
<p>又叫装包或拆包。</p> 
<h4 id="%F0%9F%8C%88%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E6%98%BE%E5%BC%8F%E8%A3%85%E7%AE%B1">🌈自动装箱和显式装箱</h4> 
<h5 id="%F0%9F%9A%80%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%EF%BC%9A">🚀自动装箱：</h5> 
<p>自动地将基本数据类型（如int、double等）转换为它们对应的包装类（如Integer、Double等）</p> 
<pre><code class="language-java">        int a = 6;
        //自动装箱
        Integer b = a;
        Integer b2 = (Integer)a;</code></pre> 
<h5 id="%F0%9F%9A%80%E6%98%BE%E5%BC%8F%E8%A3%85%E7%AE%B1">🚀显式装箱</h5> 
<pre><code class="language-java">        int a = 6;
         //显式装箱,调用valueOf()方法
        Integer d = Integer.valueOf(888);
        Integer d2 = Integer.valueOf(a);
        Integer d3 = new Integer(a);//已弃用，避免使用</code></pre> 
<h5 id="%F0%9F%9A%80%C2%A0Integer%E7%B1%BB%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%EF%BC%9A">🚀 Integer类的缓存机制：</h5> 
<p>这个缓存机制默认缓存 -128~127的所以Integer对象。</p> 
<p>当你创建Integer类型的对象时，（使用.valueOf或自动装箱来创建对象，）</p> 
<p>如果值在这个范围内，Java会直接从内存中返回已经存在的对象，而不是创建新对象。</p> 
<p>因此在这个范围内的Integer变量可能指向同一个对象示例。</p> 
<p>为什么是可能？</p> 
<p>如果使用显式装箱new Integer(int value)来创建，那么即使值在 -128~127这个范围内，也不会从内存中调用已经存在的对象，而是创建一个新的对象示例。</p> 
<h4 id="%F0%9F%8C%88%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%E5%92%8C%E6%98%BE%E5%BC%8F%E6%8B%86%E7%AE%B1">🌈自动拆箱和显式拆箱</h4> 
<h5 id="%F0%9F%9A%80%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1">🚀自动拆箱</h5> 
<pre><code class="language-java">         Integer a = 99;
        //自动拆箱
        int b = a;
        int b2 = (int)a;
        </code></pre> 
<h5 id="%F0%9F%9A%80%E6%98%BE%E5%BC%8F%E6%8B%86%E7%AE%B1">🚀显式拆箱</h5> 
<pre><code class="language-java">        Integer a = 99;
         //显式拆箱
        int c = a.intValue();
        double d = a.doubleValue();</code></pre> 
<h4 id="%C2%A0%F0%9F%8C%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%9F%A5%E8%AF%86%E7%82%B9"> 🌈相关面试题及知识点</h4> 
<p>下面代码输出内容是什么？</p> 
<pre><code class="language-java"> public static void main(String[] args) {
        Integer aa = 128;
        Integer bb = 128;
        System.out.println(aa == bb);
        Integer a = 127;
        Integer b = 127;
        System.out.println(a == b);
    }</code></pre> 
<p>答案是false和true<img alt="" height="451" src="https://images2.imgbox.com/ed/f0/7iYC0OYB_o.png" width="601"> </p> 
<p>为什么呢？</p> 
<p>这涉及两个知识点：Integer的缓存机制、引用类型的比较方式。</p> 
<p>这里用自动装箱将int类型值转换为Integer对象，其中a和b为127，在 -128~127这个范围内，因此a和b都指向内存中返回的同一个对象。</p> 
<p>而aa、bb值不在范围内，因此aa、bb各自创建一个新的对象。</p> 
<p>另外，代码中是用 == 来比较的，在引用类型中，==比较的是实例对象的地址，.equals()比较的是对象的内容，.compareTo()比较的是内容大小。</p> 
<p>a和b指向同一个对象，因此 a==b结果为true；</p> 
<p>aa和bb指向的不是同一个对象，因此 aa==bb结果为false。</p> 
<h2 id="%E6%B3%9B%E5%9E%8B%F0%9F%8C%99">泛型🌙</h2> 
<p>通俗讲，泛型就是适用于许多类型。</p> 
<p>从代码角度上看，泛型就是将类型参数化。编译时自动进行类型检查和转换</p> 
<p>泛型的主要目的：</p> 
<p>就是指定当前的容器，要持有什么类型的对象。让编译器去做检查。此时，就需要把类型，作为参数传递。需要什么类型，就传入什么类型。</p> 
<h3 id="%E2%AD%90%E8%AF%AD%E6%B3%95">⭐语法</h3> 
<h4 id="%F0%9F%8C%88%E5%9F%BA%E6%9C%AC%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%AE%9A%E4%B9%89%EF%BC%9A">🌈基本泛型类定义：</h4> 
<pre><code class="language-java">class 泛型类名称&lt;类型形参列表&gt; {  
    // 这里可以使用类型参数  
}</code></pre> 
<p>这里的泛型类名称是类的名称就，&lt;类型形参列表&gt;是定义在尖括号中的类型参数列表，它们是占位符，用于在类的定义中指定不确定的类型。</p> 
<p>例如</p> 
<pre><code class="language-java">class Box&lt;T&gt; {  
    private T t;  
  
    public void set(T t) {
     this.t = t; 
    }  
    public T get() {
     return t; 
    }  
}</code></pre> 
<h4 id="%F0%9F%8C%88%E5%A4%9A%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E6%B3%9B%E5%9E%8B%E7%B1%BB%EF%BC%9A">🌈多类型参数的泛型类：</h4> 
<pre><code class="language-java">class ClassName&lt;T1, T2, ..., Tn&gt; {  
}</code></pre> 
<p>该类可以拥有多个类型参数。类型参数之间用逗号分隔。这样的类可以更加灵活，因为它可以同时处理多种类型的数据。</p> 
<p>例如：</p> 
<pre><code class="language-java">class Pair&lt;K, V&gt; {  
    private K key;  
    private V value;  
  
    public void setKey(K key) {
     this.key = key; 
    }  
    public void setValue(V value) { 
     this.value = value; 
    }  
    public K getKey() { 
     return key;
    }  
    public V getValue() { 
     return value;
    }  
}</code></pre> 
<h4 id="%F0%9F%8C%88%E6%B3%9B%E5%9E%8B%E7%B1%BB%E7%BB%A7%E6%89%BF%E8%87%AA%E5%85%B6%E5%AE%83%E6%B3%9B%E5%9E%8B%E7%B1%BB%EF%BC%9A">🌈泛型类继承自其它泛型类：</h4> 
<pre><code class="language-java">class 泛型类名称&lt;类型形参列表&gt; extends 继承类&lt;这里可以使用类型参数&gt; {  
    // 这里可以使用类型参数  
}</code></pre> 
<p>当泛型类继承自另一个泛型类时，子类可以定义自己的类型参数列表，并且可以在继承时使用父类的类型参数。子类可以选择性地覆盖或保留父类的类型参数。</p> 
<p>例如：</p> 
<pre><code class="language-java">class GenericList&lt;E&gt; {  
    // 假设这里有一些与E类型相关的操作  
}  
  
class MyList&lt;T&gt; extends GenericList&lt;T&gt; {  
    // 这里可以直接使用T，因为T被传递给了GenericList  
}</code></pre> 
<h4 id="%F0%9F%8C%88%E6%B3%9B%E5%9E%8B%E7%B1%BB%E7%BB%A7%E6%89%BF%E8%87%AA%E7%89%B9%E5%AE%9A%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%B3%9B%E5%9E%8B%E7%B1%BB%EF%BC%9A">🌈泛型类继承自特定类型的泛型类：</h4> 
<pre><code class="language-java">class ClassName&lt;T1, T2, ..., Tn&gt; extends ParentClass&lt;T1&gt; {  
    // 可以只使用部分类型参数  
}</code></pre> 
<hr> 
<h4 id="%C2%A0%F0%9F%8C%88%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B%EF%BC%9A"> 🌈具体代码举例：</h4> 
<pre><code class="language-java"> class MyArray&lt;T&gt; {
    public Object[] array =  new Object[10];
 
    public T getPos(int pos) {
        return (T)this.array[pos];
    }
    public void setVal(int pos,T val) {
        this.array[pos] = val;
    }
 }
 public class TestDemo {
    public static void main(String[] args) {
        MyArray&lt;Integer&gt; myArray = new MyArray&lt;&gt;();//1
        myArray.setVal(0,10);
        myArray.setVal(1,12);
        int ret = myArray.getPos(1);//2
        System.out.println(ret);
        myArray.setVal(2,"Java");//3，此处报错
    }
 }
</code></pre> 
<p>注释1处，类型后加入&lt;Integer&gt;指定当前类型。</p> 
<p>注释2处不用再进行强制类型转换，因为在getpos()中返回值前就转换了。</p> 
<p>注释3处报错，"Java"是String类型，但myArray已经指定了Integer类型，编译报错。编译器会在我们存放元素时进行类型检查。</p> 
<p>类名后的&lt;T&gt;代表占位符，表示当前类是一个泛型类，&lt; &gt;中必须是引用类型，不能是基本数据类型。</p> 
<p>类型形参一般用一个大写字母表示，常见的有：</p> 
<blockquote> 
 <p>T代表Type                E代表Element                K代表Key                V代表Value        </p> 
 <p>N代表Number           S、U、V……第二、第三、第四个类型</p> 
</blockquote> 
<h3 id="%E2%AD%90%E6%B3%9B%E5%9E%8B%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A">⭐泛型类的使用：</h3> 
<h5 id="%F0%9F%8C%88%E8%AF%AD%E6%B3%95%EF%BC%9A">🌈语法：</h5> 
<p>泛型类&lt;类型参数&gt; 变量名字；   //定义一个泛型类引用</p> 
<p>new 泛型类&lt;类型实参&gt; （构造方法实参);    //实例化一个泛型类对象</p> 
<h5 id="%F0%9F%8C%88%E4%B8%BE%E4%BE%8B%EF%BC%9A">🌈举例：</h5> 
<blockquote> 
 <p>MyArray&lt;Integer&gt; arr = new MyArray&lt;Integer&gt;();</p> 
</blockquote> 
<p>当编译器可根据上下文推导处类型参数的时候，可以省略&lt; &gt;中的类型参数</p> 
<blockquote> 
 <p>MyArray&lt;Integer&gt; arr = new MyArray&lt;&gt;(); </p> 
</blockquote> 
<h3 id="%E2%AD%90%E8%A3%B8%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89%EF%BC%9A">⭐裸类型（了解）：</h3> 
<p>是一个泛型类，但是没有类型实参：</p> 
<blockquote> 
 <p>MyArray arr = new MyArray();</p> 
</blockquote> 
<p>我们不需要自己去使用裸类型，它是为了兼容老版本的API保留的机制。 </p> 
<h3 id="%E2%AD%90%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%93%A6%E9%99%A4%E6%9C%BA%E5%88%B6%EF%BC%88%E6%B3%9B%E5%9E%8B%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%EF%BC%89%EF%BC%9A">⭐泛型的擦除机制（泛型如何编译）：</h3> 
<p>在编译过程中将所有的T替换为Object，这种机制就是擦除机制。</p> 
<p>当泛型类被类型擦除时，如果泛型类中的类型参数部分指定上限（如&lt;T extends String&gt;），则类型参数会被替换成类型上限。</p> 
<p>Java的泛型机制是在编译级别实现的，因此编译器生成的字节码文件中不包含泛型的类型信息。</p> 
<h3 id="%E2%AD%90%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%B8%8A%E7%95%8C">⭐泛型的上界</h3> 
<h4>🌈语法：</h4> 
<pre><code class="language-java">class 泛型类名称&lt;类型形参 extends 类型边界&gt; {
    ...
 }</code></pre> 
<p>注意与继承了其它泛型类的泛型类区别</p> 
<h4 id="%F0%9F%8C%88%E4%BE%8B%E5%AD%90%EF%BC%9A">🌈例子：</h4> 
<pre><code class="language-java"> public class MyArray&lt;E extends Number&gt; {
    ...
 }</code></pre> 
<p> 这里只接收Number的子类作为类型参数</p> 
<blockquote> 
 <p>MyArray&lt;Integer&gt; l1;         // 正常，因为 Integer 是 Number 的子类型</p> 
 <p>MyArray&lt;String&gt; l2;         // 编译错误，因为 String 不是 Number 的子类型</p> 
</blockquote> 
<p>没有指定类型上界时，可视为&lt;E extends Object&gt; </p> 
<h4 id="%F0%9F%8C%88%E5%A4%8D%E6%9D%82%E4%BE%8B%E5%AD%90%EF%BC%9A">🌈复杂例子：</h4> 
<pre><code class="language-java">public class MyArray&lt;E extends Comparable&lt;E&gt;&gt; {
    ...
 }</code></pre> 
<p>这里表示类型参数E必须是实现了Comparable&lt;E&gt;接口的任何类型，实现了这个接口后，</p> 
<p>这个类的对象可以与其它同类型的对象进行比较。</p> 
<h3 id="%E2%AD%90%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%EF%BC%9A">⭐泛型方法：</h3> 
<blockquote> 
 <p>方法限定符 返回值类型 方法名称(形参列表) { ... }</p> 
</blockquote> 
<h4 id="%F0%9F%8C%88%E6%96%B9%E6%B3%95%E7%A4%BA%E4%BE%8B%EF%BC%9A">🌈方法示例：</h4> 
<pre><code class="language-java">public class Util {
    //静态的泛型方法 需要在static后用&lt;&gt;声明泛型类型参数
    public static &lt;E&gt; void swap(E[] array, int i, int j) {
        E t = array[i];
        array[i] = array[j];
        array[j] = t;
    }
 }</code></pre> 
<h4 id="%F0%9F%8C%88%C2%A0%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%A4%BA%E4%BE%8B%EF%BC%9A">🌈 使用方法示例：</h4> 
<h5 id="%F0%9F%9A%80%E5%8F%AF%E4%BB%A5%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%EF%BC%9A">🚀可以类型推导：</h5> 
<pre><code class="language-java">Integer[] a = { ... };
 swap(a, 0, 9);
 
String[] b = { ... };
 swap(b, 0, 9);</code></pre> 
<h5 id="%F0%9F%9A%80%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%EF%BC%9A">🚀不使用类型推导：</h5> 
<pre><code class="language-java"> Integer[] a = { ... };
 Util.&lt;Integer&gt;swap(a, 0, 9);
 
String[] b = { ... };
 Util.&lt;String&gt;swap(b, 0, 9)</code></pre> 
<hr> 
<p><span style="background-color:#e7fafa;"><span style="color:#956fe7;">🎉🎉本次内容结束啦</span></span></p> 
<p><span style="background-color:#e7fafa;"><span style="color:#956fe7;">🌹如有问题，欢迎评论区讨论~~🌹</span></span></p> 
<p><span style="background-color:#e7fafa;"><span style="color:#956fe7;">感谢支持🥰</span></span></p> 
<p style="text-align:center;"><span style="background-color:#e7fafa;"><span style="color:#956fe7;"><img alt="" src="https://images2.imgbox.com/4a/bb/8BMP4Cuw_o.gif"></span></span> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c1d648018dcaa9c4f1fa601f8a0dd789/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python爬虫技术 第24节 数据清洗和预处理（二）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6aef1d44f4be98e44863b0d3017c3ce1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">c语言第七天笔记</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>