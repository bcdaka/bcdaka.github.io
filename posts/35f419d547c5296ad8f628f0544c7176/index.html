<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C/排序算法】：快速排序和归并排序的非递归实现 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/35f419d547c5296ad8f628f0544c7176/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C/排序算法】：快速排序和归并排序的非递归实现">
  <meta property="og:description" content="目录 1. 递归实现的缺陷2. 递归改非递归的实现方式3. 快速排序的非递归 --- 使用栈4. 归并排序的非递归 --- 使用循环 1. 递归实现的缺陷 在以前的文章中我们把快速排序和归并排序的递归实现方式进行了介绍，但是在校招面试和在企业的日常开发过程中，仅掌握递归方法是不够的，因为递归也有它的缺陷。
我们知道在函数调用过程中会在内存中建立栈帧，栈帧的建立是会消耗空间的。而递归最致命的缺陷就是：在极端情况下，当栈帧的深度太深时，栈空间不够用，就会导致栈溢出！
1.1 栈溢出的例子
可以举一个简单的例子来证明存在栈溢出的情况。
比如：我们用递归实现 1 &#43; 2 &#43; 3 &#43; …… &#43; n 的求和。
#define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; int func(int n) { return n == 1 ? 1 : n &#43; func(n - 1); } int main() { int n = 0; scanf(&#34;%d&#34;, &amp;n); int sum = func(n); printf(&#34;%d\n&#34;, sum); return 0; } 当输入的 n = 10000 时 ，调试结果如下：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-23T22:32:48+08:00">
    <meta property="article:modified_time" content="2024-06-23T22:32:48+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C/排序算法】：快速排序和归并排序的非递归实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#1__1" rel="nofollow">1. 递归实现的缺陷</a></li><li><a href="#2__36" rel="nofollow">2. 递归改非递归的实现方式</a></li><li><a href="#3____41" rel="nofollow">3. 快速排序的非递归 --- 使用栈</a></li><li><a href="#4_____150" rel="nofollow">4. 归并排序的非递归 --- 使用循环</a></li></ul> 
</div> 
<p></p> 
<h2><a id="1__1"></a>1. 递归实现的缺陷</h2> 
<p>在以前的文章中我们把快速排序和归并排序的递归实现方式进行了介绍，但是在校招面试和在企业的日常开发过程中，仅掌握递归方法是不够的，因为递归也有它的缺陷。</p> 
<p>我们知道在函数调用过程中会在内存中建立栈帧，栈帧的建立是会消耗空间的。<em><strong>而递归最致命的缺陷就是：在极端情况下，当栈帧的深度太深时，栈空间不够用，就会导致栈溢出！</strong></em></p> 
<p><strong>1.1 栈溢出的例子</strong><br> 可以举一个简单的例子来证明存在栈溢出的情况。<br> <strong>比如：我们用递归实现 1 + 2 + 3 + …… + n 的求和。</strong></p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_CRT_SECURE_NO_WARNINGS</span> </span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> n <span class="token operator">+</span> <span class="token function">func</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>当输入的 n = 10000 时</strong> ，调试结果如下：</p> 
<p><img src="https://images2.imgbox.com/36/ed/SvEeJB6j_o.png" alt="![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/656443118d0e4b79a8993831e158fa7d.png"></p> 
<h2><a id="2__36"></a>2. 递归改非递归的实现方式</h2> 
<p>通常来说，递归改非递归有两种方式：<br> <strong>1. 直接改成循环(迭代)</strong>；<br> <strong>2. 借助数据结构的栈模拟</strong>。</p> 
<h2><a id="3____41"></a>3. 快速排序的非递归 — 使用栈</h2> 
<p>1.首先先来观察快排的递归实现(<strong>三种方法均可，这里用的"前后"指针法</strong> )：</p> 
<p><img src="https://images2.imgbox.com/67/af/cLLU9jAp_o.png" alt="在这里插入图片描述"><br> 通过观察我们发现，每次递归调用传过去的是<strong>一个数组</strong>和<strong>一个区间</strong>，数组不用多说，<strong>这个区间就是我们的突破点。</strong><br> <strong>也就是说我们要想一个方法来拿到每左右子区间，再对它们分别进行排序，这样才能模拟出递归的过程</strong>。那该如何做呢？<strong>借助数据结构的栈。</strong></p> 
<p><strong>2.非递归的代码实现：</strong></p> 
<p><strong>注意：由于C语言没有栈函数的库，所以这里使用的栈要提前准备好，实现栈的过程这里不再介绍。若想了解请前往我的主页。</strong></p> 
<pre><code class="prism language-c">
<span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> p2<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token operator">*</span>p1<span class="token punctuation">;</span>
	<span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">*</span>p2<span class="token punctuation">;</span>
	<span class="token operator">*</span>p2 <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">QuickSortNonR</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	ST st<span class="token punctuation">;</span>
	<span class="token function">StackInit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//先入右，后入左</span>
	<span class="token function">StackPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">StackPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">StackEmpty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//先出左边界</span>
		<span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">StackTop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">StackPop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">//后出右边界</span>
		<span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token function">StackTop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">StackPop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token comment">//单趟</span>
		<span class="token keyword">int</span> keyi <span class="token operator">=</span> left<span class="token punctuation">;</span>
		<span class="token keyword">int</span> prev <span class="token operator">=</span> left<span class="token punctuation">;</span>
		<span class="token keyword">int</span> cur <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>

		<span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//++prev != cur是指当cur和prev重合时不用多于的交换</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">++</span>prev <span class="token operator">!=</span> cur<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>prev<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			cur<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		
		<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>prev<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		keyi <span class="token operator">=</span> prev<span class="token punctuation">;</span>
		
		<span class="token comment">//说明这个区间还有两个及其以上的值</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>keyi <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> right<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">StackPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">StackPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">,</span> keyi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> keyi <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">StackPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">,</span> keyi <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">StackPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">,</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token function">StackDestory</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>排序结果如下：</p> 
<p><img src="https://images2.imgbox.com/02/ce/esjIKVNt_o.png" alt="在这里插入图片描述"></p> 
<p><strong>3.步骤总结：</strong></p> 
<p>3.1.首先要先把数组 <strong>最右端</strong> 和 <strong>最左端</strong> 入栈，<strong>这样就有了一个初始区间</strong>，然后开始循环。</p> 
<p>3.2.取出栈顶的两个数据，分别赋给 <strong>left</strong> 和 <strong>right</strong>，<strong>注意在这之后要pop掉取出的数据</strong>；</p> 
<p>3.3.再使用前后指针法走完一趟后就得到了<strong>keyi</strong> ；</p> 
<p>3.4.然后数组就被 keyIndex 分成了两个子区间，分别是：<br> <strong>左区间：[left，keyi -1]</strong><br> <strong>右区间：[keyi +1，right]</strong></p> 
<p>3.5.<strong>由于我们一般是先排左区间，再排右区间，根据栈的后进先出特性，所以要先入右区间</strong>。</p> 
<p><strong>分别将左区间和右区间入栈，注意这里要判断</strong>：<br> <strong>keyi + 1 &lt; right</strong><br> <strong>left &lt; keyi - 1</strong><br> <strong>否则会出现数组访问越界或是死循环的情况。</strong></p> 
<p>3.6.循环结束后，销毁栈。</p> 
<p><strong>4.总结一下</strong></p> 
<p><strong>最后我们要知道的是，快排的非递归并不会使性能受到破坏，它的时间复杂度也是O(N*logN)，它的效率依旧极高。使用非递归的主要原因就是防止溢出。</strong></p> 
<h2><a id="4_____150"></a>4. 归并排序的非递归 — 使用循环</h2> 
<p>首先我们知道归并排序的思想是将两组有序的数据合成一组有序的数据。</p> 
<p><strong>1. 循环步骤如下：</strong></p> 
<p>1.1 那么我们会这样想，当第一组只有1个数据，第二组也只有1个数据时，我们认为这两个数是有序的，把它们<strong>一一归并</strong>到一个临时数组中，此时临时数组里的2个数据就有序了。</p> 
<p>1.2.当第一组有2个有序数据，第二组也有2个有序数据时，把它们<strong>两两归并</strong>到一个临时数组中此时临时数组里的4个数据就有序了。</p> 
<p>1.3.当第一组有3个有序数据，第二组也有3个有序数据时，把它们<strong>三三归并</strong>到一个临时数组中，此时临时数组里的6个数据就有序了。</p> 
<p>1.4 重复上述步骤……直到全部数据有序为止。</p> 
<p><strong>2.循环图解如下：</strong></p> 
<p>我们<strong>假设 gap 为每一组的数据个数</strong>，这里<strong>最难的是如何控制每一组的范围，即那个区间的边界</strong>。</p> 
<p>假设<strong>循环的初始值从 i = 0 开始</strong>，则两组的范围可以分别表示为：</p> 
<blockquote> 
 <p><em><strong>第一组：[ i , i + gap - 1 ]</strong></em><br> <strong><em>第二组：[ i + gap , i + 2</em>gap - 1 ]</strong></p> 
</blockquote> 
<p>每组1个数据，一一归，归完后临时数组里的2个数据就有序了；<br> <img src="https://images2.imgbox.com/59/a9/InktjotY_o.png" alt="![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/388cbe63cedd45ed9a8c8a013bd8a29e.png"></p> 
<p>每组2个数据，二二归，归完后临时数组里的4个数据就有序了；<br> <img src="https://images2.imgbox.com/cd/ea/u3r8VBRG_o.png" alt="在这里插入图片描述"><br> 每组4个数据，四四归，归完后临时数组里的8个数据就有序了；<br> <img src="https://images2.imgbox.com/fc/6e/Yvp5SyuW_o.png" alt="在这里插入图片描述"></p> 
<p><strong>2. 非递归的代码实现：</strong></p> 
<p><strong>这里有两种边界修正问题需要特别注意：</strong><br> <em><strong>(1)在归并过程中右半区间可能不存在</strong></em><br> <strong>这时直接跳出循环，把剩下的那一个数据直接拷贝进数组即可。</strong><br> 比如在一一归并时：<br> <img src="https://images2.imgbox.com/65/17/nLVAHtBT_o.png" alt="在这里插入图片描述"></p> 
<p><em><strong>(2)在归并过程中右半区间可能算多了</strong></em></p> 
<p><strong>此时要把右半区间的右边界修改为数组最后一个元素的下标。</strong><br> <img src="https://images2.imgbox.com/9c/a4/0JsS78NN_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c"><span class="token comment">//归并排序的非递归</span>
<span class="token keyword">void</span> <span class="token function">MergeSortNonR</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> sz<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span><span class="token operator">*</span> tmp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>sz<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">int</span> gap <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 每组数据个数</span>

	<span class="token keyword">while</span> <span class="token punctuation">(</span>gap <span class="token operator">&lt;</span> sz<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">2</span> <span class="token operator">*</span> gap<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">// [i, i+gap-1] [i+gap,i+2*gap-1]</span>
			<span class="token keyword">int</span> begin1 <span class="token operator">=</span> i<span class="token punctuation">,</span> end1 <span class="token operator">=</span> i <span class="token operator">+</span> gap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//确定闭区间的位置，要-1</span>
			<span class="token keyword">int</span> begin2 <span class="token operator">=</span> i <span class="token operator">+</span> gap<span class="token punctuation">,</span> end2 <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> gap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>

			<span class="token comment">// 归并过程中右半区间可能就不存在</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>end1 <span class="token operator">&gt;=</span> sz <span class="token operator">||</span> begin2 <span class="token operator">&gt;=</span> sz<span class="token punctuation">)</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>

			<span class="token comment">// 归并过程中右半区间算多了, 修正一下</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>end2 <span class="token operator">&gt;=</span> sz<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				end2 <span class="token operator">=</span> sz <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			
            <span class="token comment">//归并的过程</span>
			<span class="token keyword">int</span> index <span class="token operator">=</span> i<span class="token punctuation">;</span>
			
			<span class="token keyword">while</span> <span class="token punctuation">(</span>begin1 <span class="token operator">&lt;=</span> end1 <span class="token operator">&amp;&amp;</span> begin2 <span class="token operator">&lt;=</span> end2<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>begin1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>begin2<span class="token punctuation">]</span><span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					tmp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>begin1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">else</span>
				<span class="token punctuation">{<!-- --></span>
					tmp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>begin2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>

			<span class="token keyword">while</span> <span class="token punctuation">(</span>begin1 <span class="token operator">&lt;=</span> end1<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				tmp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>begin1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			<span class="token keyword">while</span> <span class="token punctuation">(</span>begin2 <span class="token operator">&lt;=</span> end2<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				tmp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>begin2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

		    <span class="token comment">// 归一部分，拷一部分，没归的就不拷</span>
			<span class="token function">memecpy</span><span class="token punctuation">(</span>arr <span class="token operator">+</span> j<span class="token punctuation">,</span> tmp <span class="token operator">+</span> j<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>end2 <span class="token operator">-</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		
		gap <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token function">free</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
	tmp <span class="token operator">=</span> <span class="token constant">NULL</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>排序结果如下：</p> 
<p><img src="https://images2.imgbox.com/d3/0f/ikkHbW7v_o.png" alt="在这里插入图片描述"></p> 
<p><strong>3.总结一下</strong></p> 
<p><strong>归并排序的非递归的时间复杂度也是O(N*logN)，它与递归的性能也差不多。</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4ad1878b4cbc7d6e1716c3f1d6eac2d5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">20240624 每日AI必读资讯</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/946827ec1fc4f030767b912b691614bf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C/排序算法】：堆排序和选择排序</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>