<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>RabbitMQ简单介绍 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/a6d89fb0f5a7759fb7600df84cb71644/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="RabbitMQ简单介绍">
  <meta property="og:description" content="18. RabbitMQ 18.1. RabbitMQ简介 首先引入一个消息队列中间件概念： 消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题，实现高性能，高可用，可伸缩和最终一致性[架构] 使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQRabbitMQ是一种消息中间件，用于处理来自客户端的异步消息。服务端将要发送的消息放入到队列池中。接收端可以根据RabbitMQ配置的转发机制接收服务端发来的消息。RabbitMQ依据指定的转发规则进行消息的转发、缓冲和持久化操作，主要用在多服务器间或单服务器的子系统间进行通信，是分布式系统标准的配置。RabbitMQ的使用场景： 服务解耦、流量削峰、异步调用 服务解耦： 假设有这样一个场景, 服务A产生数据, 而服务B,C,D需要这些数据, 那么我们可以在A服务中直接调用B,C,D服务,把数据传递到下游服务即可，但是,随着我们的应用规模不断扩大,会有更多的服务需要A的数据,如果有几十甚至几百个下游服务,而且会不断变更,再加上还要考虑下游服务出错的情况,那么A服务中调用代码的维护会极为困难，这是由于服务之间耦合度过于紧密A服务只需要向消息服务器发送消息,而不用考虑谁需要这些数据;下游服务如果需要数据,自行从消息服务器订阅消息,不再需要数据时则取消订阅即可 流量削峰： 假设我们有一个应用,平时访问量是每秒300请求,我们用一台服务器即可轻松应对而在高峰期,访问量瞬间翻了十倍,达到每秒3000次请求,那么单台服务器肯定无法应对,这时我们可以考虑增加到10台服务器,来分散访问压力，但如果这种瞬时高峰的情况每天只出现一次,每次只有半小时,那么我们10台服务器在多数时间都只分担每秒几十次请求,这样就有点浪费资源了流量削峰情况下,瞬间出现的大量请求数据,先发送到消息队列服务器,排队等待被处理,而我们的应用,可以慢慢的从消息队列接收请求数据进行处理,这样把数据处理时间拉长,以减轻瞬时压力 异步调用: 考虑定外卖支付成功的情况,支付后要发送支付成功的通知,再寻找外卖小哥来进行配送,而寻找外卖小哥的过程非常耗时,尤其是高峰期,可能要等待几十秒甚至更长。这样就造成整条调用链路响应非常缓慢引入RabbitMQ消息队列,订单数据可以发送到消息队列服务器,那么调用链路也就可以到此结束,订单系统则可以立即得到响应,整条链路的响应时间只有200毫秒左右，寻找外卖小哥的应用可以以异步的方式从消息队列接收订单消息,再执行耗时的寻找操作 原文链接：RabbitMQ_rabbitmq csdn-CSDN博客
18.2. 一些概念解析 RabbitMQ Server：也叫broker server，它是一种传输服务。他的角色就是维护一条从Producer到Consumer的路线，保证数据能够按照指定的方式进行传输。Producer：消息生产者，如图A、B、C，数据的发送方。消息生产者连接RabbitMQ服务器然后将消息投递到Exchange。Consumer：消息消费者，如图1、2、3，数据的接收方。消息消费者订阅队列，RabbitMQ将Queue中的消息发送到消息消费者。Exchange：生产者将消息发送到Exchange（交换器），由Exchange将消息路由到一个或多个Queue中（或者丢弃）Exchange并不存储消息。RabbitMQ中的Exchange有direct、fanout、topic、headers四种类型，每种类型对应不同的路由规则。Queue：（队列）是RabbitMQ的内部对象，用于存储消息。消息消费者就是通过订阅队列来获取消息的，RabbitMQ中的消息都只能存储在Queue中，多个消费者可以订阅同一个Queue，其中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。RoutingKey：生产者在将消息发送给Exchange的时候，一般会指定一个routing key，来指定这个消息的路由规则。 Exchange： 消息交换机，它指定消息按什么规则，路由到哪个队列 Queue： 消息队列载体，每个消息都会被投入到一个或多个队列 Binding： 绑定，它的作用就是把exchange和queue按照路由规则绑定起来 Routing Key： 路由关键字，exchange根据这个关键字进行消息投递 Producer： 消息生产者，就是投递消息的程序 Consumer： 消息消费者，就是接受消息的程序 Channel： 消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务 注 ：由Exchange、Queue、RoutingKey三个才能决定一个从Exchange到Queue的唯一的线路。 18.3. RabbitMQ的三种模式 18.3.1. 直接模式 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; 消息一次发给一个队列
18.3.2. 分裂模式 任何发送到Fanout Exchange的消息都会被转发到与该Exchange绑定(Binding)的所有Queue上。
可以理解为路由表的模式这种模式不需要RouteKey这种模式需要提前将Exchange与Queue进行绑定，一个Exchange可以绑定多个Queue，一个Queue可以同多个Exchange进行绑定。如果接受到消息的Exchange没有与任何Queue绑定，则消息会被抛弃。 18.3.3. 主题模式 任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的Queue上。此类交换器使得来自不同的源头的消息可以到达一个对列，其实说的更明白一点就是模糊匹配的意思，a.# #.b a.b注：交换器说到底是一个名称与队列绑定的列表。当消息发布到交换器时，实际上是由你所连接的信道，将消息路由键同交换器上绑定的列表进行比较，最后路由消息。任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的Queue上新建一个交换器，类型选择topic -- 点击新建的交换器topictest @RunWith(SpringRunner.class) @SpringBootTest(classes = RabbitMQApplication.class) public class RabbitTest { @Autowired private RabbitTemplate rabbitTemplate; @Test public void send1(){//给队列中放东西测试 String message = &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-09-01T11:01:33+08:00">
    <meta property="article:modified_time" content="2024-09-01T11:01:33+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">RabbitMQ简单介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="x3LvD">18. RabbitMQ</h2> 
<h3 id="EIUHU">18.1. RabbitMQ简介</h3> 
<ol><li id="ue153bb63">首先引入一个消息队列中间件概念： 消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题，实现高性能，高可用，可伸缩和最终一致性[架构] 使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ</li><li id="u8b882ce2">RabbitMQ<strong>是一种消息中间件</strong>，用于处理来自客户端的异步消息。服务端将要发送的消息放入到队列池中。接收端可以根据RabbitMQ配置的转发机制接收服务端发来的消息。RabbitMQ依据指定的转发规则进行消息的转发、缓冲和持久化操作，主要用在多服务器间或单服务器的子系统间进行通信，是分布式系统标准的配置。</li><li id="ucab60d89">RabbitMQ的使用场景：<strong> 服务解耦</strong>、<strong>流量削峰</strong>、<strong>异步调用</strong></li></ol> 
<ul><li id="uc19fd8a5">服务解耦：</li></ul> 
<ul><li> 
  <ul><li id="ub3b99e0a">假设有这样一个场景, 服务A产生数据, 而服务B,C,D需要这些数据, 那么我们可以在A服务中直接调用B,C,D服务,把数据传递到下游服务即可，但是,随着我们的应用规模不断扩大,会有更多的服务需要A的数据,如果有几十甚至几百个下游服务,而且会不断变更,再加上还要考虑下游服务出错的情况,那么A服务中调用代码的维护会极为困难，这是由于服务之间耦合度过于紧密</li><li id="u3dcbd716">A服务只需要向消息服务器发送消息,而不用考虑谁需要这些数据;下游服务如果需要数据,自行从消息服务器订阅消息,不再需要数据时则取消订阅即可</li></ul></li></ul> 
<ul><li id="u3512b4a0">流量削峰：</li></ul> 
<ul><li> 
  <ul><li id="uf9f35f78">假设我们有一个应用,平时访问量是每秒300请求,我们用一台服务器即可轻松应对而在高峰期,访问量瞬间翻了十倍,达到每秒3000次请求,那么单台服务器肯定无法应对,这时我们可以考虑增加到10台服务器,来分散访问压力，但如果这种瞬时高峰的情况每天只出现一次,每次只有半小时,那么我们10台服务器在多数时间都只分担每秒几十次请求,这样就有点浪费资源了</li><li id="u5d77cf89">流量削峰情况下,瞬间出现的大量请求数据,<strong>先发送到消息队列服务器,排队等待被处理</strong>,而我们的应用,可以慢慢的从消息队列接收请求数据进行处理,这样把<strong>数据处理时间拉长</strong>,以<strong>减轻瞬时压力</strong></li></ul></li></ul> 
<ul><li id="u42ec46fb">异步调用:</li></ul> 
<ul><li> 
  <ul><li id="uf6a7e123">考虑定外卖支付成功的情况,支付后要发送支付成功的通知,再寻找外卖小哥来进行配送,而寻找外卖小哥的过程非常耗时,尤其是高峰期,可能要等待几十秒甚至更长。这样就造成整条调用链路响应非常缓慢</li><li id="ue1dfbfbd">引入RabbitMQ消息队列,订单数据可以发送到消息队列服务器,那么调用链路也就可以到此结束,订单系统则可以立即得到响应,整条链路的响应时间只有200毫秒左右，寻找外卖小哥的应用可以以异步的方式从消息队列接收订单消息,再执行耗时的寻找操作</li></ul></li></ul> 
<p id="u885b294d">原文链接：<a href="https://blog.csdn.net/weixin_38305440/article/details/102810522" title="RabbitMQ_rabbitmq csdn-CSDN博客">RabbitMQ_rabbitmq csdn-CSDN博客</a></p> 
<h3 id="kak8x">18.2. 一些概念解析</h3> 
<ul><li id="u4380c5a5"><strong>RabbitMQ Server</strong>：也叫broker server，它是一种传输服务。他的角色就是维护一条从Producer到Consumer的路线，保证数据能够按照指定的方式进行传输。</li><li id="u6f3f2c1d"><strong>Producer</strong>：消息生产者，如图A、B、C，数据的发送方。<strong>消息生产者连接RabbitMQ服务器然后将消息投递到Exchange</strong>。</li><li id="u0f111913"><strong>Consumer</strong>：消息消费者，如图1、2、3，数据的接收方。<strong>消息消费者订阅队列，RabbitMQ将Queue中的消息发送到消息消费者。</strong></li><li id="u777d0d88"><strong>Exchange</strong>：生产者将消息发送到Exchange（<strong>交换器</strong>），<strong>由Exchange将消息路由到一个或多个Queue中</strong>（或者丢弃）<strong>Exchange并不存储消息</strong>。RabbitMQ中的Exchange有direct、<strong>fanout</strong>、<strong>topic</strong>、headers四种类型，每种类型对应不同的路由规则。</li><li id="u32732185"><strong>Queue</strong>：（<strong>队列</strong>）是RabbitMQ的内部对象，<strong>用于存储消息</strong>。消息消费者就是通过订阅队列来获取消息的，RabbitMQ中的消息都只能存储在Queue中，多个消费者可以订阅同一个Queue，其中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。</li><li id="u334732a2"><strong>RoutingKey</strong>：生产者在将消息发送给Exchange的时候，一般会指定一个routing key，来指定这个消息的路由规则。</li></ul> 
<pre id="MkkDn"><code>Exchange： 消息交换机，它指定消息按什么规则，路由到哪个队列
Queue： 消息队列载体，每个消息都会被投入到一个或多个队列
Binding： 绑定，它的作用就是把exchange和queue按照路由规则绑定起来
Routing Key： 路由关键字，exchange根据这个关键字进行消息投递
Producer： 消息生产者，就是投递消息的程序
Consumer： 消息消费者，就是接受消息的程序
Channel： 消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务
注 ：由Exchange、Queue、RoutingKey三个才能决定一个从Exchange到Queue的唯一的线路。</code></pre> 
<p id="u8987e920"></p> 
<p class="img-center"><img alt="" height="535" id="u9ea32096" src="https://images2.imgbox.com/f5/d4/tK8yb9ge_o.png" width="1200"></p> 
<h3 id="jDWgz">18.3. RabbitMQ的三种模式</h3> 
<h4 id="UrqyD">18.3.1. 直接模式</h4> 
<pre id="atLDL"><code>&lt;dependency&gt; 
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; 
  &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; 
&lt;/dependency&gt; </code></pre> 
<p id="ud0e87a18">消息一次发给一个队列</p> 
<h4 id="jaELX">18.3.2. 分裂模式</h4> 
<p id="u3db370e1"><strong>任何发送到Fanout Exchange的消息都会被转发到与该Exchange绑定(Binding)的所有Queue上。</strong></p> 
<ol><li id="uec871724">可以理解为路由表的模式</li><li id="uf65588af">这种模式不需要RouteKey</li><li id="u6dc1c593">这种模式需要提前将Exchange与Queue进行绑定，一个Exchange可以绑定多个Queue，一个Queue可以同多个Exchange进行绑定。</li><li id="uc81aa622">如果接受到消息的Exchange没有与任何Queue绑定，则消息会被抛弃。</li></ol> 
<h4 id="AW77j">18.3.3. 主题模式</h4> 
<ol><li id="uaf4b67ab">任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的Queue上。此类交换器使得来自不同的源头的消息可以到达一个对列，其实说的更明白一点就是模糊匹配的意思，<code>a.# #.b a.b</code></li><li id="u9ee1a492">注：交换器说到底<strong>是一个名称与队列绑定的列表</strong>。当消息发布到交换器时，实际上是由你所连接的信道，将消息路由键同交换器上绑定的列表进行比较，最后路由消息。任何发送到<strong>Topic Exchange</strong>的消息都会被转发到所有关心<strong>RouteKey</strong>中指定话题的<strong>Queue</strong>上</li><li id="ub61a8ceb">新建一个交换器，类型选择topic -- 点击新建的交换器topictest</li></ol> 
<pre id="dNaBd"><code>@RunWith(SpringRunner.class)
@SpringBootTest(classes = RabbitMQApplication.class)
public class RabbitTest {
    @Autowired
    private RabbitTemplate rabbitTemplate;
    @Test
    public void send1(){//给队列中放东西测试
        String message = "1111111_syx";
        rabbitTemplate.convertAndSend("syx01","直接添加队列"+message);
    }

    @Test
    public void send2(){//给队列中放东西测试
        String message = "1111111_syx";
        rabbitTemplate.convertAndSend("syx","","分裂添加队列"+message);
    }

    @Test
    public void send3(){//给队列中放东西测试
        String message = "1111111_syx";
        rabbitTemplate.convertAndSend("bx","a.111","主题添加队列a.#==="+message);
    }
    </code></pre> 
<pre id="jHe2w"><code>spring:
  rabbitmq:
    host: 192.168.134.128
server:
  port: 8081
</code></pre> 
<pre id="IwknZ"><code>@Component
@RabbitListener(queues = "syx01")
public class RabbitMQLinster01 {
    @RabbitHandler
    public void get(String message){
        System.out.println("syx01接收到的信息"+message);
    }
}</code></pre> 
<h2 id="oTwPc"></h2>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dfbbf9a668b5efd3bde0a7c1da88fb10/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据同步的艺术：探索PostgreSQL和Redis的一致性策略</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6d695dd9171039801f69b7e94f8f475d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AutoGen 检索增强生成（RAG）功能解析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>