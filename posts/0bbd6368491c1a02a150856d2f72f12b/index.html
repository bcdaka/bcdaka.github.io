<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[C&#43;&#43;] 类和对象：运算符重载 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/0bbd6368491c1a02a150856d2f72f12b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="[C&#43;&#43;] 类和对象：运算符重载">
  <meta property="og:description" content="前言： 在C&#43;&#43;中，运算符重载是一种强大的特性，它允许我们重新定义已有的运算符，以便用于用户自定义的数据类型。通过运算符重载，我们可以使得我们自定义的类对象像内置类型一样进行运算，这为编写清晰、简洁且易于理解的代码提供了便利。
为什么要进行运算符重载？ 在学习运算符重载之前：
我们对于内置类型的运算是这样的：int = int &#43; int;
但是我们对于自定义类型的类无法使用简单的运算符进行运算，我们需要特别得去写一个函数或者一段过程性代码来实现这个功能。
使用重载运算符：
比如说在一个日期类内有该重载 bool operator==(const Date&amp; d2) { return _year == d2._year; &amp;&amp; _month == d2._month &amp;&amp; _day == d2._day;	} 该代码就是对“”运算符的重载，之后通过使用”“就可以对比日期类的两个对象（根据该运算是否有意义来决定）。
使用时的代码就是如此：d1 == d2。
运算符重载的语法 函数原型：**返回值类型 operator操作符(参数列表)** 注意：
不能通过连接其他符号来创建新的操作符：比如operator@重载操作符必须有一个类类型参数用于内置类型的运算符，其含义不能改变，例如：内置的整型&#43;，不能改变其含义作为类成员函数重载时，其形参看起来比操作数数目少1，因为成员函数的第一个参数为隐 藏的this
. * :: sizeof ? : . 注意以上5个运算符不能重载。这个经常在笔试选择题中出 现。
以日期类进行举例：
①非成员函数重载：
bool operator==(const Date&amp; d1, const Date&amp; d2) { return d1._year == d2._year &amp;&amp; d1._month == d2._month &amp;&amp; d1._day == d2.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-09T09:10:11+08:00">
    <meta property="article:modified_time" content="2024-05-09T09:10:11+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[C&#43;&#43;] 类和对象：运算符重载</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/a8/19/jwwiFING_o.png" alt=""></p> 
<hr> 
<h2><a id="_4"></a>前言：</h2> 
<p>在C++中，运算符重载是一种强大的特性，它允许我们重新定义已有的运算符，以便用于用户自定义的数据类型。通过运算符重载，我们可以使得我们自定义的类对象像内置类型一样进行运算，这为编写清晰、简洁且易于理解的代码提供了便利。</p> 
<h2><a id="_8"></a>为什么要进行运算符重载？</h2> 
<p>在学习运算符重载之前：<br>我们对于内置类型的运算是这样的：<code>int = int + int</code>;<br>但是我们对于自定义类型的类无法使用简单的运算符进行运算，我们需要特别得去写一个函数或者一段过程性代码来实现这个功能。</p> 
<p>使用重载运算符：</p> 
<ul><li>比如说在一个日期类内有该重载</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date<span class="token operator">&amp;</span> d2<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> _year <span class="token operator">==</span> d2<span class="token punctuation">.</span>_year<span class="token punctuation">;</span>
        <span class="token operator">&amp;&amp;</span> _month <span class="token operator">==</span> d2<span class="token punctuation">.</span>_month
        <span class="token operator">&amp;&amp;</span> _day <span class="token operator">==</span> d2<span class="token punctuation">.</span>_day<span class="token punctuation">;</span>	
<span class="token punctuation">}</span>
</code></pre> 
<p>该代码就是对“<mark>”运算符的重载，之后通过使用”</mark>“就可以对比日期类的两个对象（根据该运算是否有意义来决定）。<br>使用时的代码就是如此：<code>d1 == d2</code>。</p> 
<h2><a id="_25"></a>运算符重载的语法</h2> 
<blockquote> 
 <p><code>函数原型：**返回值类型 operator操作符(参数列表)** </code><br> 注意：</p> 
 <ul><li>不能通过连接其他符号来创建新的操作符：比如operator@</li><li>重载操作符必须有一个类类型参数</li><li>用于内置类型的运算符，其含义不能改变，例如：内置的整型+，不能改变其含义</li><li>作为类成员函数重载时，其形参看起来比操作数数目少1，因为成员函数的第一个参数为隐</li></ul> 
</blockquote> 
<p>藏的this</p> 
<blockquote> 
 <ul><li>. * :: sizeof ? : . 注意以上5个运算符不能重载。这个经常在笔试选择题中出</li></ul> 
</blockquote> 
<p>现。</p> 
<p>以日期类进行举例：</p> 
<p>①非成员函数重载：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date<span class="token operator">&amp;</span> d1<span class="token punctuation">,</span> <span class="token keyword">const</span> Date<span class="token operator">&amp;</span> d2<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> d1<span class="token punctuation">.</span>_year <span class="token operator">==</span> d2<span class="token punctuation">.</span>_year
        <span class="token operator">&amp;&amp;</span> d1<span class="token punctuation">.</span>_month <span class="token operator">==</span> d2<span class="token punctuation">.</span>_month
        <span class="token operator">&amp;&amp;</span> d1<span class="token punctuation">.</span>_day <span class="token operator">==</span> d2<span class="token punctuation">.</span>_day<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>用<code>d1.operator(d2)</code>或者<code>d1 == d2</code>都可以实现；<br> 由于在类外实现重载，所以没有this指针，所以可以用类内，但是C++的语法会对此进行优化直接使用<code>d1 == d2</code>也可以完成。</p> 
</blockquote> 
<p>②成员函数重载：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date<span class="token operator">&amp;</span> d2<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> _year <span class="token operator">==</span> d2<span class="token punctuation">.</span>_year<span class="token punctuation">;</span>
        <span class="token operator">&amp;&amp;</span> _month <span class="token operator">==</span> d2<span class="token punctuation">.</span>_month
        <span class="token operator">&amp;&amp;</span> _day <span class="token operator">==</span> d2<span class="token punctuation">.</span>_day<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>类内时，左操作数为this，指向调用函数的对象，可以直接用 <code>d1 == d2</code>进行运算。</p> 
</blockquote> 
<p>当运行到使用重载运算符的时候就会进行调用重载函数：<br><img src="https://images2.imgbox.com/65/d2/AWNCUgkA_o.png" alt="image.png"><br><img src="https://images2.imgbox.com/47/f3/vSgDIJyR_o.png" alt="image.png"></p> 
<h2><a id="_68"></a>赋值运算符重载</h2> 
<h3><a id="_70"></a>赋值运算符重载格式</h3> 
<blockquote> 
 <p><strong>参数类型</strong>：const T&amp;，传递引用可以提高传参效率<br><strong>返回值类型</strong>：T&amp;，返回引用可以提高返回的效率，有返回值目的是为了支持连续赋值<br>**检测是否自己给自己赋值<br>返回*this **：要复合连续赋值的含义</p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token comment">//作为成员函数，赋值运算符重载函数：</span>
<span class="token comment">// 用Date类型引用返回使得可以连续赋值</span>
Date<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date<span class="token operator">&amp;</span> d<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token operator">&amp;</span>d<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        _year <span class="token operator">=</span> d<span class="token punctuation">.</span>_year<span class="token punctuation">;</span>
        _month <span class="token operator">=</span> d<span class="token punctuation">.</span>_month<span class="token punctuation">;</span>
        _day <span class="token operator">=</span> d<span class="token punctuation">.</span>_day<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_90"></a>为什么赋值运算符重载函数为成员函数？</h3> 
<p>当尝试将赋值运算符重载函数作为静态函数进行定义时：<br><img src="https://images2.imgbox.com/dd/a3/doPPgslh_o.png" alt="image.png"><br><img src="https://images2.imgbox.com/1b/7e/Jkzzj6GD_o.png" alt="image.png"></p> 
<hr> 
<p>在C++中，赋值运算符 = 被设计为类的成员函数，这是因为它需要访问类的内部状态，并且需要能够处理自赋值的情况（即对象赋值给自己）。当你尝试将赋值运算符重载为全局函数时，会出现问题，原因如下：</p> 
<blockquote> 
 <ol><li><strong>成员访问权限</strong>：作为全局函数，赋值运算符将无法访问类的非公共（private或protected）成员变量。成员函数可以直接访问这些成员，因为它们是类的一部分。</li><li><strong>this指针</strong>：成员函数有一个隐式的指针 this，它指向调用该成员函数的对象。在成员函数内部，this 指针允许你访问对象的成员变量和其它成员函数。全局函数没有 this 指针，因此无法访问特定对象的状态。</li><li><strong>自赋值保护</strong>：成员函数版本的赋值运算符可以检查自赋值，即对象赋值给自己。这可以通过比较 this 指针和传入的右值的地址来实现。全局函数没有 this 指针，因此无法进行这种检查。</li><li><strong>语法要求</strong>：C++ 语法要求赋值运算符 = 必须是类的成员函数。尝试将其定义为非成员函数会导致编译错误，因为编译器期望赋值运算符是类的成员。</li><li><strong>语义问题</strong>：赋值运算符的语义是将一个对象的值设置为另一个对象的值。作为成员函数，它清楚地表达了这一点，因为它是在对象上直接调用的。作为全局函数，这种语义就不那么明确了。</li><li><strong>重载规则</strong>：C++ 的运算符重载规则限制了某些运算符（包括赋值运算符）只能作为成员函数重载。这是为了保持语言的一致性和防止潜在的错误使用。</li></ol> 
</blockquote> 
<p>因此，当尝试将赋值运算符重载为全局函数时，编译器会报错，因为它违反了C++的规则和赋值运算符的预期行为。正确的做法是将其作为类的成员函数来重载，以确保正确的访问权限、自赋值保护以及符合C++的语法和语义要求。</p> 
<h3><a id="_105"></a>默认赋值运算符重载</h3> 
<blockquote> 
 <ul><li>用户没有显式实现时，编译器会生成一个默认赋值运算符重载，以值的方式逐字节拷贝。、（值拷贝/浅拷贝 类似Date ）。</li><li>这个默认的赋值运算符会进行成员到成员的简单赋值，也就是逐个复制每个非引用、非指针成员变量的值。</li><li>如果类中包含了其他自定义类型作为其成员变量，并且这些自定义类型重载了赋值运算符 =，那么在进行类实例的赋值操作时，编译器会尝试调用这些成员变量类型的赋值运算符来完成赋值（MyQueue）。</li></ul> 
</blockquote> 
<p>注意：如果类中未涉及到资源管理，赋值运算符是否实现都可以；一旦涉及到资源管理则必<br>须要实现。</p> 
<h2><a id="_113"></a>前置++和后置++重载</h2> 
<h3><a id="_114"></a>前置++</h3> 
<pre><code class="prism language-cpp"><span class="token comment">// 由于this指向的是函数外定义的对象，所以不会销毁，使用引用返回提高效率</span>
Date<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    _day <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>当<code>++d1</code>执行的时候将会返回++后的日期。</p> 
<h3><a id="_125"></a>后置++</h3> 
<pre><code class="prism language-cpp">Date <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    Date <span class="token function">temp</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    _day <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>d1++</code>：后置++的效果是对++的对象进行处理后返回处理前的数值，所以在函数内定义一个对象进行储存++前的数据，不使用引用返回，使得在返回后构造函数，使程序正常进行。</p> 
<blockquote> 
 <p>由于前置++和后置++的源代码原本是没区别的，所以为了区别这两个，祖师爷用一种机制来进行区分使用：后置++运算符重载时，需要声明一个额外的int类型的参数，这个参数在实际使用时并不需要由程序员显式传递，而是由编译器在调用后置++时自动传递。</p> 
</blockquote> 
<br> # 对象的流插入和流输出 ![image.png](https://img-blog.csdnimg.cn/img_convert/9e5c619629b007e8e08be6fee14cd4fe.png) ```cpp class Date { friend istream&amp; operator&gt;&gt;(istream&amp; in, Date&amp; d); friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const Date&amp; d); } ``` 用引用返回保证可以连续的进行使用，类似：`in &gt;&gt; d1 &gt;&gt; d2 &gt;&gt; d3;` ## 流输出 ( &lt;&lt; ) 为了按照`out &lt;&lt; d`的形式来进行使用重载运算符，所以用在类中用友元函数，这样既避免了this指针，还可以使该函数可以使用成员变量，以达到使用这种操作格式的目的。 ```cpp // 在类外实现 ostream&amp; operator&lt;&lt;(ostream&amp; out, const Date&amp; d) { out &lt;&lt; d._year &lt;&lt; "年" &lt;&lt; d._month &lt;&lt; "月" &lt;&lt; d._day &lt;&lt; "日"; return out; } ``` 
<h3><a id="_159"></a>流输出</h3> 
<p>和流输入一样类内用友元函数。</p> 
<pre><code class="prism language-cpp">istream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">(</span>istream<span class="token operator">&amp;</span> in<span class="token punctuation">,</span> Date<span class="token operator">&amp;</span> d<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> year<span class="token punctuation">,</span> month<span class="token punctuation">,</span> day<span class="token punctuation">;</span>
	in <span class="token operator">&gt;&gt;</span> year <span class="token operator">&gt;&gt;</span> month <span class="token operator">&gt;&gt;</span> day<span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>month <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> month <span class="token operator">&lt;</span> <span class="token number">13</span>
		<span class="token operator">&amp;&amp;</span> day <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> day <span class="token operator">&lt;=</span> d<span class="token punctuation">.</span><span class="token function">GetMonthDay</span><span class="token punctuation">(</span>year<span class="token punctuation">,</span> month<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		d<span class="token punctuation">.</span>_year <span class="token operator">=</span> year<span class="token punctuation">;</span>
		d<span class="token punctuation">.</span>_month <span class="token operator">=</span> month<span class="token punctuation">;</span>
		d<span class="token punctuation">.</span>_day <span class="token operator">=</span> day<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"非法日期"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token function">assert</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">return</span> in<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="const_185"></a>取地址及const取地址操作符重载</h2> 
<h3><a id="_187"></a>对象取地址</h3> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Date</span> 
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>

    <span class="token comment">// 重载 operator&amp;()，返回指向 Date 的常量指针  </span>
    <span class="token keyword">const</span> Date<span class="token operator">*</span> <span class="token keyword">operator</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> 
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 这里通常应该直接返回 this，但出于示例的目的，我们可能会做一些检查或其他逻辑  </span>
        <span class="token comment">// 但实际上，直接返回 this 是最简单和最直接的方式  </span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 注意：如果你还想要一个非 const 版本的 operator&amp;()，你可以这样重载它  </span>
    Date<span class="token operator">*</span> <span class="token keyword">operator</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 同样的，直接返回 this  </span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span>
   Date date<span class="token punctuation">;</span>

   <span class="token comment">// 使用重载的 operator&amp;()  </span>
   <span class="token keyword">const</span> Date<span class="token operator">*</span> constPtrToDate <span class="token operator">=</span> date<span class="token punctuation">.</span><span class="token keyword">operator</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用成员函数调用方式  </span>

   <span class="token comment">// 但是通常你会这样写，因为编译器会隐式地使用 &amp; 运算符  </span>
   <span class="token keyword">const</span> Date<span class="token operator">*</span> anotherConstPtrToDate <span class="token operator">=</span> <span class="token operator">&amp;</span>date<span class="token punctuation">;</span>

   <span class="token comment">// 注意：如果你重载了非 const 版本的 operator&amp;()，你也可以这样使用  </span>
   Date<span class="token operator">*</span> ptrToDate <span class="token operator">=</span> <span class="token operator">&amp;</span>date<span class="token punctuation">;</span> <span class="token comment">// 或者 ptrToDate = date.operator&amp;();  </span>

   <span class="token comment">// ... 其他代码 ...  </span>

   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="const_this_228"></a>const this</h3> 
<p>例如在类中有以下函数：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> _year <span class="token operator">&lt;&lt;</span> _month <span class="token operator">&lt;&lt;</span> _day <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>当我们想在主函数中调用该函数时，有两个不同的对象，<code>const d1（2021.2.3），d2（2031, 2,1）</code>，当我们直接调用时会发现const d1无法调用Print，这时候就涉及到了权限的放大。<br>d1 和 d2是作为this指针传递的，Print中的this指针是<code>Date* this</code>类型的，而d1是一个<code>const Date*</code>型的，所以无法传入d2进行调用函数。<br>这时候就涉及到了<code>const this</code>当使用const修饰this后，就可以将之前d1的权限放大变为权限平移，d2的权限平移变成权限缩小，这样就都可以实现调用。<br>实现代码格式如下：</p> 
<pre><code class="prism language-cpp"><span class="token comment">// 将const加在函数后面</span>
<span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> _year <span class="token operator">&lt;&lt;</span> _month <span class="token operator">&lt;&lt;</span> _day <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>在使用的过程中要注意：<br> ①要修改对象成员变量的函数不能加；<br> ②只要成员函数内部不修改成员变量，就都应该加const，这样const对象和普通对象都可以调用。<br> ③这两个运算符一般不需要重载，使用编译器生成的默认取地址的重载即可，只有特殊情况，才需要重载，比如想让别人获取到指定的内容！</p> 
</blockquote> 
<hr> 
<p><img src="https://images2.imgbox.com/4f/7d/d2tvWzsq_o.png" alt=""></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ae7b37b7ec353cc0f3bcb071857bbbbd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Oracle SQL Developer导出数据库表结构，表数据，索引以及序列号等对象</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6559a04df237e3b19b988695266de42d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【高阶数据结构(二)】初识图论</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>