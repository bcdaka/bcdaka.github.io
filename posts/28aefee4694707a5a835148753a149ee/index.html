<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>代码随想录算法训练营第五天 |242.有效的字母异位词；349. 两个数组的交集；202. 快乐数；1. 两数之和 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/28aefee4694707a5a835148753a149ee/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="代码随想录算法训练营第五天 |242.有效的字母异位词；349. 两个数组的交集；202. 快乐数；1. 两数之和">
  <meta property="og:description" content="今日任务 ● 哈希表理论基础
● 242.有效的字母异位词
● 349. 两个数组的交集
● 202. 快乐数
● 1. 两数之和
详细布置 哈希表理论基础 建议：大家要了解哈希表的内部实现原理，哈希函数，哈希碰撞，以及常见哈希表的区别，数组，set 和map。
什么时候想到用哈希法，当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法。 这句话很重要，大家在做哈希表题目都要思考这句话。
文章讲解：代码随想录 总结: 数据结构： Java 中 HashMap 主要由数组和链表（在 Java 8 后还有红黑树）组成。数组被称为哈希桶(hashTable)，用于存储键值对的链表或红黑树的头节点引用 哈希函数： 通过哈希函数计算键的哈希值，然后对数组长度取模，得到在数组中的索引位置，以此来决定键值对应该存储在哪个哈希桶中 扩容机制： 当 HashMap 中的元素数量超过负载因子（默认 0.75）与当前容量的乘积时，会触发扩容操作。扩容时会创建一个新的、更大的数组，并将原有数据重新哈希到新数组中 键值存储与查找： 存储键值对时，将其放入对应的哈希桶中，如果发生哈希冲突（多个键映射到同一个索引位置），则在链表中依次添加节点（在 Java 8 后，如果链表长度超过一定阈值会转换为红黑树）查找键值对时，通过相同的哈希函数计算键的索引位置，然后在对应的链表或红黑树中进行查找 线程不安全： HashMap 在并发环境下可能会出现数据丢失、数据覆盖等问题，不适合多线程环境下直接使用，如果需要在多线程环境中使用，可以使用 ConcurrentHashMap 等线程安全的类。 线程安全问题的本质原因: 1&gt;结构的并发修改问题
同时进行扩容操作：
HashMap 在进行扩容时，需要重新计算已有元素的哈希值，并将它们迁移到新的数组位置。如果多个线程同时进行扩容操作，可能会导致数据丢失或者迁移错误。
节点插入和链接的混乱：
在正常情况下，当向 HashMap 中插入一个新的键值对时，需要根据哈希值找到对应的链表位置，并将新节点插入到链表中。如果多个线程同时进行插入操作，可能会导致节点链接的顺序错误，或者出现循环链表的情况。
2&gt;数据不一致问题
读写冲突：
一个线程正在读取 HashMap 的数据，而另一个线程正在对其进行写入操作（例如添加、删除或修改键值对）。在没有适当的同步机制的情况下，读取线程可能会获取到不一致的数据状态。
哈希表状态的不一致：
HashMap 的内部状态包括哈希桶数组的大小、每个链表的结构以及元素的分布等。在多线程环境下，这些状态可能会被多个线程同时修改，导致哈希表的状态变得不可预测和不一致。
3&gt;没有同步机制来保证原子性和可见性
原子性操作的缺失：
许多对 HashMap 的操作，如 put ()、remove () 等，实际上是由多个步骤组成的复合操作。在多线程环境下，这些操作需要保证原子性，即要么全部完成，要么完全不做，以避免中间状态被其他线程看到。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-19T21:39:25+08:00">
    <meta property="article:modified_time" content="2024-08-19T21:39:25+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">代码随想录算法训练营第五天 |242.有效的字母异位词；349. 两个数组的交集；202. 快乐数；1. 两数之和</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div></div> 
<div> 
 <h3 style="margin-left:0;text-align:left;"><span style="color:#000000;"><strong><span style="color:#1a1a1a;">今日任务</span></strong></span></h3> 
 <blockquote> 
  <p style="margin-left:16.8pt;text-align:left;"><span style="color:#000000;">● <span style="color:#333333;"> 哈希表理论基础</span></span></p> 
  <p style="margin-left:16.8pt;text-align:left;"><span style="color:#000000;">● <span style="color:#333333;"> 242.有效的字母异位词</span></span></p> 
  <p style="margin-left:16.8pt;text-align:left;"><span style="color:#000000;">● <span style="color:#333333;"> 349. 两个数组的交集</span></span></p> 
  <p style="margin-left:16.8pt;text-align:left;"><span style="color:#000000;">● <span style="color:#333333;"> 202. 快乐数</span></span></p> 
  <p style="margin-left:16.8pt;text-align:left;"><span style="color:#000000;">● <span style="color:#333333;"> 1. 两数之和</span></span></p> 
 </blockquote> 
 <h3 style="margin-left:0;text-align:left;"><span style="color:#000000;"><strong><span style="color:#1a1a1a;">详细布置</span></strong></span></h3> 
 <h3 style="margin-left:0px;text-align:left;"><span style="color:#000000;"><strong><span style="color:#1a1a1a;">哈希表理论基础</span></strong></span></h3> 
 <p style="margin-left:0;text-align:left;"><span style="color:#000000;"><span style="color:#333333;">建议：大家要了解哈希表的内部实现原理，哈希函数，哈希碰撞，以及常见哈希表的区别，数组，set 和map。</span></span></p> 
 <p style="margin-left:0;text-align:left;"><span style="color:#000000;"><span style="color:#333333;">什么时候想到用哈希法，</span><strong><span style="color:#333333;">当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</span></strong><span style="color:#333333;">。 这句话很重要，大家在做哈希表题目都要思考这句话。</span></span></p> 
 <p style="margin-left:0;text-align:left;"><span style="color:#000000;"><span style="color:#333333;">文章讲解：</span><a href="https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html" rel="nofollow" title="代码随想录">代码随想录</a> </span></p> 
 <h4 style="margin-left:0px;text-align:left;">总结:</h4> 
 <h5><strong>数据结构</strong>：</h5> 
 <ul><li>Java 中 HashMap 主要由数组和链表（在 Java 8 后还有红黑树）组成。数组被称为哈希桶(hashTable)，用于存储键值对的链表或红黑树的头节点引用</li></ul> 
 <h5><strong>哈希函数</strong>：</h5> 
 <ul><li>通过哈希函数计算键的哈希值，然后对数组长度取模，得到在数组中的索引位置，以此来决定键值对应该存储在哪个哈希桶中</li></ul> 
 <h5><strong>扩容机制</strong>：</h5> 
 <ul><li>当 HashMap 中的元素数量超过负载因子（默认 0.75）与当前容量的乘积时，会触发扩容操作。扩容时会创建一个新的、更大的数组，并将原有数据重新哈希到新数组中</li></ul> 
 <h5><strong>键值存储与查找</strong>：</h5> 
 <ul><li>存储键值对时，将其放入对应的哈希桶中，如果发生哈希冲突（多个键映射到同一个索引位置），则在链表中依次添加节点（在 Java 8 后，如果链表长度超过一定阈值会转换为红黑树）</li><li>查找键值对时，通过相同的哈希函数计算键的索引位置，然后在对应的链表或红黑树中进行查找</li></ul> 
 <h5><strong>线程不安全</strong>：</h5> 
 <ul><li>HashMap 在并发环境下可能会出现数据丢失、数据覆盖等问题，不适合多线程环境下直接使用，如果需要在多线程环境中使用，可以使用 ConcurrentHashMap 等线程安全的类。</li></ul> 
 <h6>        线程安全问题的本质原因:</h6> 
 <p><strong>                1&gt;结构的并发修改问题</strong></p> 
 <p><strong>                        同时进行扩容操作</strong>：</p> 
 <p>        HashMap 在进行扩容时，需要重新计算已有元素的哈希值，并将它们迁移到新的数组位置。如果多个线程同时进行扩容操作，可能会导致数据丢失或者迁移错误。</p> 
 <p><strong>                        节点插入和链接的混乱</strong>：</p> 
 <p>        在正常情况下，当向 HashMap 中插入一个新的键值对时，需要根据哈希值找到对应的链表位置，并将新节点插入到链表中。如果多个线程同时进行插入操作，可能会导致节点链接的顺序错误，或者出现循环链表的情况。</p> 
 <p><strong>                 2&gt;数据不一致问题</strong></p> 
 <p><strong>                        读写冲突</strong>：</p> 
 <p>        一个线程正在读取 HashMap 的数据，而另一个线程正在对其进行写入操作（例如添加、删除或修改键值对）。在没有适当的同步机制的情况下，读取线程可能会获取到不一致的数据状态。</p> 
 <p><strong>                        哈希表状态的不一致</strong>：</p> 
 <p>        HashMap 的内部状态包括哈希桶数组的大小、每个链表的结构以及元素的分布等。在多线程环境下，这些状态可能会被多个线程同时修改，导致哈希表的状态变得不可预测和不一致。</p> 
 <p><strong>                3&gt;没有同步机制来保证原子性和可见性</strong></p> 
 <p><strong>                        原子性操作的缺失</strong>：</p> 
 <p>        许多对 HashMap 的操作，如 put ()、remove () 等，实际上是由多个步骤组成的复合操作。在多线程环境下，这些操作需要保证原子性，即要么全部完成，要么完全不做，以避免中间状态被其他线程看到。</p> 
 <p><strong>                        可见性问题</strong>：</p> 
 <p>        由于每个线程都有自己的本地缓存（工作内存），线程对 HashMap 的修改可能不会立即被其他线程看到。这就可能导致其他线程读取到过期的数据。</p> 
 <p></p> 
 <h4 style="margin-left:0;text-align:left;"><span style="color:#000000;"><strong><span style="color:#1a1a1a;">242.有效的字母异位词</span></strong></span></h4> 
 <p style="margin-left:0;text-align:left;"><span style="color:#000000;"><span style="color:#333333;">建议： 这道题目，大家可以感受到 数组 用来做哈希表 给我们带来的遍历</span><span style="color:#333333;">之处。</span></span></p> 
 <p style="margin-left:0;text-align:left;"><span style="color:#000000;"><span style="color:#333333;">题目链接:</span></span><a href="https://leetcode.cn/problems/valid-anagram/description/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></p> 
 <p style="margin-left:0;text-align:left;"><span style="color:#000000;"><span style="color:#333333;">题目链接/文章讲解/视频讲解： </span><a href="https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html" rel="nofollow" title="代码随想录">代码随想录</a> </span></p> 
 <h5 style="margin-left:0px;text-align:left;">暴力解:</h5> 
 <pre><code class="language-java">public boolean isAnagram(String s, String t) {
        boolean res = false;
        char[] charArr_s = s.toCharArray();
        //仅包含小写字符
        Map&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(26);
        for(Character c:charArr_s){
            map.put(c,map.getOrDefault(c,0)+1);
        }
        char[] charArr_t = t.toCharArray();
        for(Character c:charArr_t){
            if(map.containsKey(c)){
                int cnt = map.get(c)-1;
                if(cnt &lt;= 0){
                    map.remove(c);
                }else{
                    map.put(c,cnt);
                }
            }else{
                return res;
            }
        }
        return map.size() == 0;
    }</code></pre> 
 <h4 style="margin-left:0;text-align:left;">字典解</h4> 
 <pre><code class="language-java">public boolean isAnagram(String s, String t) {
        //为什么可以用数组来做字典:
        // "s 和 t 仅包含小写字母" 和 "进阶: 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？" 已经提示了
        int[] arr = new int[26];
        for(int i=0;i&lt;s.length();i++){
            arr[s.charAt(i)-'a']++;
        }
        for(int i=0;i&lt;t.length();i++){
            arr[t.charAt(i)-'a']--;
        }
        for(int a:arr){
            if(a!=0){
                return false;
            }
        }
        return true;
    }</code></pre> 
 <h4 style="margin-left:0;text-align:left;"><span style="color:#000000;"><strong><span style="color:#1a1a1a;">349. 两个数组的交集</span></strong></span></h4> 
 <p style="margin-left:0;text-align:left;"><span style="color:#000000;"><span style="color:#333333;">建议：本题就开始考虑 什么时候用set 什么时候用数组，本题其实是使用set的好题，但是后来力扣改了题目描述和 测试用例，添加了 0 &lt;= nums1[i], nums2[i] &lt;= 1000 条件，所以使用数组也可以了，不过建议大家忽略这个条件。 尝试去使用set。</span></span></p> 
 <p style="margin-left:0;text-align:left;"><span style="color:#000000;"><span style="color:#333333;">题目链接/文章讲解/视频讲解：</span><a href="https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html" rel="nofollow" title="代码随想录">代码随想录</a> </span></p> 
 <h5 style="margin-left:0px;text-align:left;"><span style="color:#000000;">暴力解:</span></h5> 
 <pre><code class="language-java">public int[] intersection(int[] nums1, int[] nums2) {
        Set&lt;Integer&gt; set = new HashSet(nums1.length);
        for(Integer n : nums1){
            set.add(n);
        }
        Set&lt;Integer&gt; res = new HashSet();
        for(Integer n : nums2){
            if(set.contains(n)){
                res.add(n);
            }
        }
        //将结果集合转为数组
        return res.stream().mapToInt(x -&gt; x).toArray();
    }</code></pre> 
 <h5 style="margin-left:0px;text-align:left;">利用限制求解:</h5> 
 <blockquote> 
  <ul><li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li><li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li></ul> 
  <p>这里限制 length 也限制了 值的大小, 都 &lt;=1000 ,那么就提供了, 数组与值的转化土壤,即可以利用这个特性来快速标记数组某元素是否存在的状态</p> 
 </blockquote> 
 <pre><code class="language-java">public int[] intersection(int[] nums1, int[] nums2) {
        int[] flag = new int[1001];
        for(int i = 0; i &lt; nums1.length; i++)
            if(flag[nums1[i]] == 0)
                flag[nums1[i]] = 1;
        int[] ans = new int[1001];
        int idx = 0;
        for(int i = 0; i &lt; nums2.length; i++)
            if(flag[nums2[i]] == 1){
                ans[idx++] = nums2[i];
                flag[nums2[i]] = 2;
            }
        return Arrays.copyOf(ans, idx);
    }</code></pre> 
 <h4 style="margin-left:0;text-align:left;"></h4> 
 <h4 style="margin-left:0;text-align:left;"><span style="color:#000000;"><strong><span style="color:#1a1a1a;">202. 快乐数</span></strong></span></h4> 
 <p style="margin-left:0;text-align:left;"><span style="color:#000000;"><span style="color:#333333;">建议：这道题目也是set的应用，其实和上一题差不多，就是 套在快乐数一个壳子</span></span></p> 
 <p style="margin-left:0;text-align:left;">题目链接:<a href="https://leetcode.cn/problems/happy-number/description/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></p> 
 <p style="margin-left:0;text-align:left;"><span style="color:#000000;"><span style="color:#333333;">题目链接/文章讲解：</span><a href="https://programmercarl.com/0202.%E5%BF%AB%E4%B9%90%E6%95%B0.html" rel="nofollow" title="代码随想录">代码随想录</a> </span></p> 
 <h6 style="margin-left:0px;text-align:left;">利用字符串求解</h6> 
 <pre><code class="language-java">public boolean isHappy(int n) {
        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
        //如果n之前已经出现了,说明会出现死循环,即不是快乐数了,这时就需要返回了
        while(n!=1 &amp;&amp; !set.contains(n)){
            set.add(n);
            //重置n的值
            n = getSum(n);
        }
        return n == 1;
    }

    public int getSum(int n){
        int sum = 0;
        String str = String.valueOf(n);
        for(int i=0;i&lt;str.length();i++){
            int tmp = Integer.valueOf(String.valueOf(str.charAt(i)));
            sum += tmp * tmp;
        }
        return sum;
    }</code></pre> 
 <h6 style="margin-left:0px;text-align:left;">利用每次n/10 来累加各位置的和</h6> 
 <pre><code class="language-java">public boolean isHappy(int n) {
        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
        //如果n之前已经出现了,说明会出现死循环,即不是快乐数了,这时就需要返回了
        while(n!=1 &amp;&amp; !set.contains(n)){
            set.add(n);
            //重置n的值
            n = getSum(n);
        }
        return n == 1;
    }

    public int getSum(int n){
        int sum = 0;
        while(n&gt;0){
            //每次取最后一位
            int tmp = n%10;
            sum += tmp * tmp;
            //重置n的值
            n = n/10;
        }
        return sum;
    }</code></pre> 
 <h6 style="margin-left:0px;text-align:left;">核心:</h6> 
 <p>        缺少对数字处理的常识</p> 
 <h6>        从个位后高位依次取数</h6> 
 <p>                获取最后一位数组,用n%10,取余即可,忽略最后一位数字,则用n/10 取整即可</p> 
 <p>                tmp = n%10; 每次取个位</p> 
 <p>                n = n /10; 数字忽略个位,缩小10倍,位数整体减1</p> 
 <h6>        从高位后往个位依次取数</h6> 
 <p>                用栈依次入栈之后再取即可</p> 
 <pre><code class="language-java">int sum = 0;
Stack&lt;Integer&gt; stack = new Stack();
while (n&gt;0){
     stack.push(n%10);
     n = n/10;
}
//依次获取最高位数字
stack.pop();</code></pre> 
 <p>                也可以直接用字符串的方式取(相对占用内存较多)</p> 
 <h6>        数字的位运算</h6> 
 <ol><li><strong>高效的乘除 2 运算: n乘以 2 可写为: n&lt;&lt;1 ; n除以 2 可写为: n&gt;&gt;1</strong></li><li><strong>快速判断奇偶性: </strong>与数字 <code>1</code> 进行按位与（<code>&amp;</code>）操作，如果结果为 <code>0</code>，则该数为偶数；如果结果为 <code>1</code>，则该数为奇数; 7 &amp; 1 = 1 为奇数;8 &amp; 1 = 0 为偶数</li></ol> 
 <h4 style="margin-left:0;text-align:left;"><span style="color:#000000;"><strong><span style="color:#1a1a1a;">1. 两数之和</span></strong></span></h4> 
 <p style="margin-left:0;text-align:left;"><span style="color:#000000;"><span style="color:#333333;">建议：本题虽然是 力扣第一题，但是还是挺难的，也是 代码随想录中 数组，set之后，使用map解决哈希问题的第一题。</span></span></p> 
 <p style="margin-left:0;text-align:left;"><span style="color:#000000;"><span style="color:#333333;">建议大家先看视频讲解，然后尝试自己写代码，在看文章讲解，加深印象。</span></span></p> 
 <p style="margin-left:0;text-align:left;"><span style="color:#000000;"><span style="color:#333333;">题目链接:</span></span><a href="https://leetcode.cn/problems/two-sum/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></p> 
 <p style="margin-left:0;text-align:left;"><span style="color:#000000;"><span style="color:#333333;">题目链接/文章讲解/视频讲解：</span><a href="https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html" rel="nofollow" title="代码随想录">代码随想录</a> </span></p> 
 <pre><code class="language-java">public int[] twoSum(int[] nums, int target) {
        int[] res = new int[2];
        //记录 值是key 即对应的索引的位置 为val
        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();
        for(int i=0;i&lt;nums.length;i++){
            if(map.containsKey(target-nums[i])){
                res[0] = i;
                res[1] = map.get(target-nums[i]);
                break;
            }
            map.put(nums[i],i);
        }
        return res;
    }</code></pre> 
 <ul><li>为什么会想到用哈希表 
   <ul><li>记录已表里的数组,避免重复遍历</li></ul></li><li>哈希表为什么用map 
   <ul><li>因为返回的结果是索引位置,所以同步记录 值 及 索引</li></ul></li><li>本题map是用来存什么的 
   <ul><li>key: 数组元素值  val: 元素再数组的中偏移量(索引)</li></ul></li></ul> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3425fe7831df6eb31867d4ce7cbbba7f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Eureka故障排查指南：常见问题与解决方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6c5a68357398733c17f45992b94acd54/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于Python的火车票售票系统/基于django的火车购票系统</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>