<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【微服务】第33节：Redis的数据结构 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/5ca3e3b111148ecee6c5524162468da6/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【微服务】第33节：Redis的数据结构">
  <meta property="og:description" content="IT领域往往都是面试造火箭，实际工作拧螺丝。为了更好的应对面试，让大家能拿到更高的offer✉，我们接下来就讲讲“造火箭”的事情🧑‍🚀。
🔥🔥🔥 包括以下几方面🔽 🎈：
🌈 - Redis - 高级：
📛 -Redis主从
🤿 - Redis哨兵
🧩 - Redis分片集群
👨‍💻 - Redis数据结构（◀️）
♻️ - Redis内存回收
✅ - Redis缓存一致性
1.Redis数据结构 我们常用的Redis数据类型有5种，分别是：
💠String
💠List
💠Set
💠SortedSet
💠Hash
还有一些高级数据类型，比如Bitmap、HyperLogLog、GEO等，其底层都是基于上述5种基本数据类型。因此在Redis的源码中，其实只有5种数据类型。
1.1.RedisObject 不管是任何一种数据类型，最终都会封装为RedisObject格式，它是一种结构体，C语言中的一种结构，可以理解为Java中的类。
结构大概是这样的：
可以看到整个结构体中并不包含真实的数据，仅仅是对象头信息，内存占用的大小为4&#43;4&#43;24&#43;32&#43;64 = 128bit
也就是16字节，然后指针ptr指针指向的才是真实数据存储的内存地址。所以RedisObject的内存开销是很大的。
属性中的encoding就是当前对象底层采用的数据结构或编码方式，可选的有11种之多：
编号 编码方式 说明 0
OBJ_ENCODING_RAW
raw编码动态字符串
1
OBJ_ENCODING_INT
long类型的整数的字符串
2
OBJ_ENCODING_HT
hash表（也叫dict）
3
OBJ_ENCODING_ZIPMAP
已废弃
4
OBJ_ENCODING_LINKEDLIST
双端链表
5
OBJ_ENCODING_ZIPLIST
压缩列表
6
OBJ_ENCODING_INTSET
整数集合
7
OBJ_ENCODING_SKIPLIST
跳表">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-12T13:42:15+08:00">
    <meta property="article:modified_time" content="2024-07-12T13:42:15+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【微服务】第33节：Redis的数据结构</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>  IT领域往往都是面试造火箭，实际工作拧螺丝。为了更好的应对面试，让大家能拿到更高的offer✉，我们接下来就讲讲“造火箭”的事情🧑‍🚀。</p> 
<blockquote> 
 <p>🔥🔥🔥 包括以下几方面🔽 🎈：</p> 
 <p>🌈 - Redis - 高级：</p> 
 <ul><li> <p>📛 -Redis主从</p> </li><li> <p>🤿 - Redis哨兵</p> </li><li> <p><a href="https://www.emojiall.com/zh-hans/blog/471" rel="nofollow" title="🧩 - ">🧩 - </a>Redis分片集群</p> </li><li> <p>👨‍💻 - Redis数据结构（◀️）</p> </li><li> <p>♻️ - Redis内存回收</p> </li><li> <p>✅ - Redis缓存一致性</p> </li></ul> 
</blockquote> 
<h2> 1.Redis数据结构</h2> 
<p>我们常用的Redis数据类型有5种，分别是：</p> 
<ul><li> <p>💠String</p> </li><li> <p>💠List</p> </li><li> <p>💠Set</p> </li><li> <p>💠SortedSet</p> </li><li> <p>💠Hash</p> </li></ul> 
<p>还有一些高级数据类型，比如Bitmap、HyperLogLog、GEO等，其底层都是基于上述5种基本数据类型。因此在Redis的源码中，其实只有5种数据类型。</p> 
<p></p> 
<h3>1.1.RedisObject</h3> 
<p>不管是任何一种数据类型，最终都会封装为RedisObject格式，它是一种结构体，C语言中的一种结构，可以理解为Java中的类。</p> 
<p>结构大概是这样的：</p> 
<p><img alt="" height="274" src="https://images2.imgbox.com/50/ce/NOlGSIdY_o.png" width="813"></p> 
<p>可以看到整个结构体中并不包含真实的数据，仅仅是对象头信息，内存占用的大小为4+4+24+32+64 = 128bit</p> 
<p>也就是16字节，然后指针<code>ptr</code>指针指向的才是真实数据存储的内存地址。所以RedisObject的内存开销是很大的。</p> 
<p></p> 
<p>属性中的<code>encoding</code>就是当前对象底层采用的<strong>数据结构</strong>或<strong>编码方式</strong>，可选的有11种之多：</p> 
<table border="2" cellpadding="2"><thead><tr><th colspan="1" rowspan="1" style="background-color:#ccff33;width:116px;"> <h6><strong>编号</strong></h6> </th><th colspan="1" rowspan="1" style="background-color:#ccff33;width:302px;"> <h6><strong>编码方式</strong></h6> </th><th colspan="1" rowspan="1" style="background-color:#ccff33;width:271px;"> <h6><strong>说明</strong></h6> </th></tr></thead><tbody><tr><td colspan="1" rowspan="1" style="width:116px;"> <p>0</p> </td><td colspan="1" rowspan="1" style="width:302px;"> <p>OBJ_ENCODING_RAW</p> </td><td colspan="1" rowspan="1" style="width:271px;"> <p>raw编码动态字符串</p> </td></tr><tr><td colspan="1" rowspan="1" style="width:116px;"> <p>1</p> </td><td colspan="1" rowspan="1" style="width:302px;"> <p>OBJ_ENCODING_INT</p> </td><td colspan="1" rowspan="1" style="width:271px;"> <p>long类型的整数的字符串</p> </td></tr><tr><td colspan="1" rowspan="1" style="width:116px;"> <p>2</p> </td><td colspan="1" rowspan="1" style="width:302px;"> <p>OBJ_ENCODING_HT</p> </td><td colspan="1" rowspan="1" style="width:271px;"> <p>hash表（也叫dict）</p> </td></tr><tr><td colspan="1" rowspan="1" style="width:116px;"> <p>3</p> </td><td colspan="1" rowspan="1" style="width:302px;"> <p>OBJ_ENCODING_ZIPMAP</p> </td><td colspan="1" rowspan="1" style="width:271px;"> <p>已废弃</p> </td></tr><tr><td colspan="1" rowspan="1" style="width:116px;"> <p>4</p> </td><td colspan="1" rowspan="1" style="width:302px;"> <p>OBJ_ENCODING_LINKEDLIST</p> </td><td colspan="1" rowspan="1" style="width:271px;"> <p>双端链表</p> </td></tr><tr><td colspan="1" rowspan="1" style="width:116px;"> <p>5</p> </td><td colspan="1" rowspan="1" style="width:302px;"> <p>OBJ_ENCODING_ZIPLIST</p> </td><td colspan="1" rowspan="1" style="width:271px;"> <p>压缩列表</p> </td></tr><tr><td colspan="1" rowspan="1" style="width:116px;"> <p>6</p> </td><td colspan="1" rowspan="1" style="width:302px;"> <p>OBJ_ENCODING_INTSET</p> </td><td colspan="1" rowspan="1" style="width:271px;"> <p>整数集合</p> </td></tr><tr><td colspan="1" rowspan="1" style="width:116px;"> <p>7</p> </td><td colspan="1" rowspan="1" style="width:302px;"> <p>OBJ_ENCODING_SKIPLIST</p> </td><td colspan="1" rowspan="1" style="width:271px;"> <p>跳表</p> </td></tr><tr><td colspan="1" rowspan="1" style="width:116px;"> <p>8</p> </td><td colspan="1" rowspan="1" style="width:302px;"> <p>OBJ_ENCODING_EMBSTR</p> </td><td colspan="1" rowspan="1" style="width:271px;"> <p>embstr编码的动态字符串</p> </td></tr><tr><td colspan="1" rowspan="1" style="width:116px;"> <p>9</p> </td><td colspan="1" rowspan="1" style="width:302px;"> <p>OBJ_ENCODING_QUICKLIST</p> </td><td colspan="1" rowspan="1" style="width:271px;"> <p>快速列表</p> </td></tr><tr><td colspan="1" rowspan="1" style="width:116px;"> <p>10</p> </td><td colspan="1" rowspan="1" style="width:302px;"> <p>OBJ_ENCODING_STREAM</p> </td><td colspan="1" rowspan="1" style="width:271px;"> <p>Stream流</p> </td></tr><tr><td colspan="1" rowspan="1" style="width:116px;"> <p>11</p> </td><td colspan="1" rowspan="1" style="width:302px;"> <p>OBJ_ENCODING_LISTPACK</p> </td><td colspan="1" rowspan="1" style="width:271px;"> <p>紧凑列表</p> </td></tr></tbody></table> 
<p>Redis中的5种不同的数据类型采用的底层数据结构和编码方式如下：</p> 
<table border="2"><thead><tr><th colspan="1" rowspan="1" style="background-color:#99ccff;width:219px;"> <h6><strong>数据类型</strong></h6> </th><th colspan="1" rowspan="1" style="background-color:#99ccff;width:469px;"> <h6><strong>编码方式</strong></h6> </th></tr></thead><tbody><tr><td colspan="1" rowspan="1" style="width:219px;"> <p>STRING</p> </td><td colspan="1" rowspan="1" style="width:469px;"> <p><code>int</code>、<code>embstr</code>、<code>raw</code></p> </td></tr><tr><td colspan="1" rowspan="1" style="width:219px;"> <p>LIST</p> </td><td colspan="1" rowspan="1" style="width:469px;"> <p><code>LinkedList和ZipList</code>(3.2以前)、<code>QuickList</code>（3.2以后）</p> </td></tr><tr><td colspan="1" rowspan="1" style="width:219px;"> <p>SET</p> </td><td colspan="1" rowspan="1" style="width:469px;"> <p><code>intset</code>、<code>HT</code></p> </td></tr><tr><td colspan="1" rowspan="1" style="width:219px;"> <p>ZSET</p> </td><td colspan="1" rowspan="1" style="width:469px;"> <p><code>ZipList</code>（7.0以前）、<code>Listpack</code>（7.0以后）、<code>HT</code>、<code>SkipList</code></p> </td></tr><tr><td colspan="1" rowspan="1" style="width:219px;"> <p>HASH</p> </td><td colspan="1" rowspan="1" style="width:469px;"> <p><code>ZipList</code>（7.0以前）、<code>Listpack</code>（7.0以后）、<code>HT</code></p> </td></tr></tbody></table> 
<p>这些数据类型比较复杂，我们<strong>重点讲解几个面试会问</strong>的，其它的大家可以查看黑马程序员发布的Redis专业课程：</p> 
<p>暂时无法在飞书文档外展示此内容</p> 
<h3>1.2.SkipList</h3> 
<p>SkipList（跳表）首先是链表，但与传统链表相比有几点差异：</p> 
<ul><li> <p>元素按照升序排列存储</p> </li><li> <p>节点可能包含多个指针，指针跨度不同。</p> </li></ul> 
<p></p> 
<p>传统链表只有指向前后元素的指针，因此只能顺序依次访问。如果查找的元素在链表中间，查询的效率会比较低。而SkipList则不同，它内部包含跨度不同的多级指针，可以让我们跳跃查找链表中间的元素，效率非常高。</p> 
<p>其结构如图：</p> 
<p><img alt="" height="274" src="https://images2.imgbox.com/5f/56/MnukXvjy_o.png" width="819"></p> 
<p>我们可以看到1号元素就有指向3、5、10的多个指针，查询时就可以跳跃查找。例如我们要找大小为14的元素，查找的流程是这样的：</p> 
<p><img alt="" height="269" src="https://images2.imgbox.com/b2/37/Cz5yiOit_o.png" width="817"></p> 
<ul><li> <p>首先找元素1节点最高级指针，也就是4级指针，起始元素大小为1，指针跨度为9，可以判断出目标元素大小为10。由于14比10大，肯定要从10这个元素向下接着找。</p> </li><li> <p>找到10这个元素，发现10这个元素的最高级指针跨度为5，判断出目标元素大小为15，大于14，需要判断下级指针</p> </li><li> <p>10这个元素的2级指针跨度为3，判断出目标元素为13，小于14，因此要基于元素13接着找</p> </li><li> <p>13这个元素最高级级指针跨度为2，判断出目标元素为15，比14大，需要判断下级指针。</p> </li><li> <p>13的下级指针跨度为1，因此目标元素是14，刚好于目标一致，找到。</p> </li></ul> 
<p></p> 
<p>这种多级指针的查询方式就避免了传统链表的逐个遍历导致的查询效率下降问题。在对有序数据做随机查询和排序时效率非常高。</p> 
<p></p> 
<p>跳表的结构体如下：</p> 
<pre><code class="language-cpp">typedef struct zskiplist {
    // 头尾节点指针
    struct zskiplistNode *header, *tail;
    // 节点数量
    unsigned long length;
    // 最大的索引层级
    int level;
} zskiplist;</code></pre> 
<p></p> 
<p>可以看到SkipList主要属性是header和tail，也就是头尾指针，因此它是支持双向遍历的。</p> 
<p>跳表中节点的结构体如下：</p> 
<pre><code class="language-cpp">typedef struct zskiplistNode {
    sds ele; // 节点存储的字符串
    double score;// 节点分数，排序、查找用
    struct zskiplistNode *backward; // 前一个节点指针
    struct zskiplistLevel {
        struct zskiplistNode *forward; // 下一个节点指针
        unsigned long span; // 索引跨度
    } level[]; // 多级索引数组
} zskiplistNode;</code></pre> 
<p>每个节点中都包含ele和score两个属性，其中score是得分，也就是节点排序的依据。ele则是节点存储的字符串数据指针。</p> 
<p>其内存结构如下：</p> 
<p><img alt="" height="334" src="https://images2.imgbox.com/5a/a8/ca0jE1wk_o.png" width="818"></p> 
<p></p> 
<h3>1.3.SortedSet</h3> 
<blockquote> 
 <p><strong>✅ 面试题</strong>：Redis的<code>SortedSet</code>底层的数据结构是怎样的？</p> 
 <p><strong>💡 答</strong>：SortedSet是有序集合，底层的存储的每个数据都包含element和score两个值。score是得分，element则是字符串值。SortedSet会根据每个element的score值排序，形成有序集合。</p> 
 <p>它支持的操作很多，比如：</p> 
 <ul><li> <p>ℹ️ 根据element查询score值</p> </li><li> <p>ℹ️ 按照score值升序或降序查询element</p> </li></ul> 
 <p>要实现根据element查询对应的score值，就必须实现element与score之间的键值映射。SortedSet底层是基于<strong>HashTable💾 </strong>来实现的。</p> 
 <p>要实现对score值排序，并且查询效率还高，就需要有一种高效的有序数据结构，SortedSet是基于<strong>跳表</strong>实现的。</p> 
 <p><strong>【📍 加分项】</strong>：因为SortedSet底层需要用到两种数据结构，对内存占用比较高。因此Redis底层会对SortedSet中的元素大小做判断。如果<strong>元素大小小于128</strong>且<strong>每个元素都小于64字节</strong>，SortedSet底层会采用<strong>ZipList</strong>，也就是<strong>压缩列</strong>表来代替<strong>HashTable</strong>和<strong>SkipList</strong></p> 
 <p>不过，<code>ZipList</code>存在连锁更新问题，因此而在Redis7.0版本以后，<code>ZipList</code>又被替换为<strong>Listpack</strong>（紧凑列表）。</p> 
</blockquote> 
<p>Redis源码中<code>zset</code>，也就是<code>SortedSet</code>的结构体如下：</p> 
<pre><code class="language-cpp">typedef struct zset {
    dict *dict; // dict，底层就是HashTable
    zskiplist *zsl; // 跳表
} zset;</code></pre> 
<p></p> 
<p>其内存结构如图：</p> 
<p><img alt="" height="434" src="https://images2.imgbox.com/27/4c/CGfafbYM_o.png" width="814"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8416741205968880072c273d3bec3091/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">The Web3 社区 Web3 产品经理课程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a0e8cc1a885d84c37d129d68df1eeeed/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【WEB前端2024】3D智体编程：乔布斯3D纪念馆-第60集-agent训练资讯APP重点推荐AI资讯内容（含视频）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>