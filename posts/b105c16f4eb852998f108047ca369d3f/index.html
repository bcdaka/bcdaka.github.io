<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构:堆的实现与建堆时间复杂度分析 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b105c16f4eb852998f108047ca369d3f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构:堆的实现与建堆时间复杂度分析">
  <meta property="og:description" content="目录
前言
一.堆的介绍
1.堆的本质
2.堆的分类
二.堆的实现(以小根堆为例)
1.关于二叉树的两组重要结论：
2.堆的物理存储结构框架(动态数组的简单构建)
3. 堆元素插入接口(以小根堆为例)
堆尾元素向上调整的算法接口:
4.堆元素插入接口测试
5.堆元素插入接口建堆的时间复杂度分析(建堆时间复杂度)
6.堆元素删除接口(同样以小根堆为例子)
堆元素向下调整算法接口实现:
7.堆元素删除接口测试
8.逐个删除堆顶数据过程的时间复杂度分析(删堆的时间复杂度分析)
9.堆的实现代码总览(以小根堆为例)
10.结语
前言 关于数据结构的文章:写博客的时候我感觉在表达层面上有点费劲,如果文章整体在表述上让人感觉不够清楚,恳请读者原谅,本菜狗已经尽力了.
一.堆的介绍 1.堆的本质 关于二叉树的图论基础参见:http://t.csdn.cn/Nv325http://t.csdn.cn/Nv325青菜友情提示:基础概念对于理解堆的实现与运用非常重要
堆的本质是映射在内存中顺序存储结构(数组)上的完全二叉树(完全二叉树是堆的逻辑结构).
堆的图解:
结点中的数据存储在相应下标的数组元素空间中 2.堆的分类 堆的两个类型：
大根堆:在大根堆中任何子结构的父结点中存储的值大于其左右孩子结点中存储的值(即任何一条连通路径上从上往下满足降序排列)小根堆:在小根堆中任何子结构的父结点中存储的值小于其左右孩子结点中存储的值(即任何一条连通路径上从上往下满足升序排列) 二.堆的实现(以小根堆为例) 1.关于二叉树的两组重要结论： 堆的任何一个父结点的编号parent与其左孩子结点的编号leftchild满足如下关系式:堆的任何一个父结点的编号parent与其右孩子结点的编号rightchild满足如下关系式: 这两组重要结论的推导和分析参见青菜的博客:http://t.csdn.cn/Nv325http://t.csdn.cn/Nv325
2.堆的物理存储结构框架(动态数组的简单构建) 堆是存储在数组上的(大小根)完全二叉树,因此在实现堆之前我们先构建一个简单的动态数组作为物理存储结构框架:
维护动态数组的结构体: typedef int HPDataType; //堆元素类型 typedef struct Heap { HPDataType* arry; //堆区内存指针 size_t size; //堆元素个数 size_t capacity; //数组的空间容量 }HP; 堆的基础操作接口声明： //维护堆的结构体的初始化接口 void HeapInit(HP* php); //销毁堆的接口 void HeapDestroy(HP* php); //堆元素的打印接口 void HeapPrint(HP* php); //判断堆是否为空(堆中有无元素)的接口 bool HeapEmpty(HP* php); //返回堆中元素个数的接口 size_t HeapSize(HP* php); //返回堆顶元素(即编号为0的元素)的接口 HPDataType HeapTop(HP* php); 基础接口的实现: //堆结构体的初始化接口 void HeapInit(HP* ptrheap) { assert(ptrheap); ptrheap-&gt;arry = NULL; ptrheap-&gt;capacity = 0; ptrheap-&gt;size = 0; } //销毁堆的接口 void HeapDestroy(HP* ptrheap) { assert(ptrheap); free(ptrheap-&gt;arry); ptrheap-&gt;arry = NULL; ptrheap-&gt;capacity = 0; ptrheap-&gt;size = 0; } //堆的打印接口 void HeapPrint(HP* ptrheap) { assert(ptrheap); size_t tem = 0; for (tem = 0; tem &lt; ptrheap-&gt;size; &#43;&#43;tem) { printf(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-03-04T11:33:50+08:00">
    <meta property="article:modified_time" content="2023-03-04T11:33:50+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构:堆的实现与建堆时间复杂度分析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p id="%E4%B8%80.%E5%A0%86%E7%9A%84%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><a href="#%E4%B8%80.%E5%A0%86%E7%9A%84%E4%BB%8B%E7%BB%8D" rel="nofollow">一.堆的介绍</a></p> 
<p id="1.%E5%A0%86%E7%9A%84%E6%9C%AC%E8%B4%A8-toc" style="margin-left:80px;"><a href="#1.%E5%A0%86%E7%9A%84%E6%9C%AC%E8%B4%A8" rel="nofollow">1.堆的本质</a></p> 
<p id="2.%E5%A0%86%E7%9A%84%E5%88%86%E7%B1%BB-toc" style="margin-left:80px;"><a href="#2.%E5%A0%86%E7%9A%84%E5%88%86%E7%B1%BB" rel="nofollow">2.堆的分类</a></p> 
<p id="%E4%BA%8C.%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0(%E4%BB%A5%E5%B0%8F%E6%A0%B9%E5%A0%86%E4%B8%BA%E4%BE%8B)-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0%28%E4%BB%A5%E5%B0%8F%E6%A0%B9%E5%A0%86%E4%B8%BA%E4%BE%8B%29" rel="nofollow">二.堆的实现(以小根堆为例)</a></p> 
<p id="1.%E5%85%B3%E4%BA%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%A4%E7%BB%84%E9%87%8D%E8%A6%81%E7%BB%93%E8%AE%BA%EF%BC%9A-toc" style="margin-left:40px;"><a href="#1.%E5%85%B3%E4%BA%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%A4%E7%BB%84%E9%87%8D%E8%A6%81%E7%BB%93%E8%AE%BA%EF%BC%9A" rel="nofollow">1.关于二叉树的两组重要结论：</a></p> 
<p id="2.%E5%A0%86%E7%9A%84%E7%89%A9%E7%90%86%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E6%A1%86%E6%9E%B6(%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E7%AE%80%E5%8D%95%E6%9E%84%E5%BB%BA)-toc" style="margin-left:40px;"><a href="#2.%E5%A0%86%E7%9A%84%E7%89%A9%E7%90%86%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E6%A1%86%E6%9E%B6%28%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E7%AE%80%E5%8D%95%E6%9E%84%E5%BB%BA%29" rel="nofollow">2.堆的物理存储结构框架(动态数组的简单构建)</a></p> 
<p id="3.%20%E5%A0%86%E5%85%83%E7%B4%A0%E6%8F%92%E5%85%A5%E6%8E%A5%E5%8F%A3(%E4%BB%A5%E5%B0%8F%E6%A0%B9%E5%A0%86%E4%B8%BA%E4%BE%8B)-toc" style="margin-left:40px;"><a href="#3.%20%E5%A0%86%E5%85%83%E7%B4%A0%E6%8F%92%E5%85%A5%E6%8E%A5%E5%8F%A3%28%E4%BB%A5%E5%B0%8F%E6%A0%B9%E5%A0%86%E4%B8%BA%E4%BE%8B%29" rel="nofollow">3. 堆元素插入接口(以小根堆为例)</a></p> 
<p id="%E5%A0%86%E5%B0%BE%E5%85%83%E7%B4%A0%E5%90%91%E4%B8%8A%E8%B0%83%E6%95%B4%E7%9A%84%E7%AE%97%E6%B3%95%E6%8E%A5%E5%8F%A3%3A-toc" style="margin-left:80px;"><a href="#%E5%A0%86%E5%B0%BE%E5%85%83%E7%B4%A0%E5%90%91%E4%B8%8A%E8%B0%83%E6%95%B4%E7%9A%84%E7%AE%97%E6%B3%95%E6%8E%A5%E5%8F%A3%3A" rel="nofollow">堆尾元素向上调整的算法接口:</a></p> 
<p id="4.%E5%A0%86%E5%85%83%E7%B4%A0%E6%8F%92%E5%85%A5%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95-toc" style="margin-left:40px;"><a href="#4.%E5%A0%86%E5%85%83%E7%B4%A0%E6%8F%92%E5%85%A5%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95" rel="nofollow">4.堆元素插入接口测试</a></p> 
<p id="5.%E5%A0%86%E5%85%83%E7%B4%A0%E6%8F%92%E5%85%A5%E6%8E%A5%E5%8F%A3%E5%BB%BA%E5%A0%86%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90(%E5%BB%BA%E5%A0%86%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)-toc" style="margin-left:40px;"><a href="#5.%E5%A0%86%E5%85%83%E7%B4%A0%E6%8F%92%E5%85%A5%E6%8E%A5%E5%8F%A3%E5%BB%BA%E5%A0%86%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%28%E5%BB%BA%E5%A0%86%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%29" rel="nofollow">5.堆元素插入接口建堆的时间复杂度分析(建堆时间复杂度)</a></p> 
<p id="6.%E5%A0%86%E5%85%83%E7%B4%A0%E5%88%A0%E9%99%A4%E6%8E%A5%E5%8F%A3(%E5%90%8C%E6%A0%B7%E4%BB%A5%E5%B0%8F%E6%A0%B9%E5%A0%86%E4%B8%BA%E4%BE%8B%E5%AD%90)-toc" style="margin-left:40px;"><a href="#6.%E5%A0%86%E5%85%83%E7%B4%A0%E5%88%A0%E9%99%A4%E6%8E%A5%E5%8F%A3%28%E5%90%8C%E6%A0%B7%E4%BB%A5%E5%B0%8F%E6%A0%B9%E5%A0%86%E4%B8%BA%E4%BE%8B%E5%AD%90%29" rel="nofollow">6.堆元素删除接口(同样以小根堆为例子)</a></p> 
<p id="%E5%A0%86%E5%85%83%E7%B4%A0%E5%90%91%E4%B8%8B%E8%B0%83%E6%95%B4%E7%AE%97%E6%B3%95%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%3A-toc" style="margin-left:80px;"><a href="#%E5%A0%86%E5%85%83%E7%B4%A0%E5%90%91%E4%B8%8B%E8%B0%83%E6%95%B4%E7%AE%97%E6%B3%95%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%3A" rel="nofollow">堆元素向下调整算法接口实现:</a></p> 
<p id="7.%E5%A0%86%E5%85%83%E7%B4%A0%E5%88%A0%E9%99%A4%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95-toc" style="margin-left:40px;"><a href="#7.%E5%A0%86%E5%85%83%E7%B4%A0%E5%88%A0%E9%99%A4%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95" rel="nofollow">7.堆元素删除接口测试</a></p> 
<p id="8.%E9%80%90%E4%B8%AA%E5%88%A0%E9%99%A4%E5%A0%86%E9%A1%B6%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90(%E5%88%A0%E5%A0%86%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90)-toc" style="margin-left:40px;"><a href="#8.%E9%80%90%E4%B8%AA%E5%88%A0%E9%99%A4%E5%A0%86%E9%A1%B6%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%28%E5%88%A0%E5%A0%86%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%29" rel="nofollow">8.逐个删除堆顶数据过程的时间复杂度分析(删堆的时间复杂度分析)</a></p> 
<p id="9.%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E6%80%BB%E8%A7%88(%E4%BB%A5%E5%B0%8F%E6%A0%B9%E5%A0%86%E4%B8%BA%E4%BE%8B)-toc" style="margin-left:40px;"><a href="#9.%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E6%80%BB%E8%A7%88%28%E4%BB%A5%E5%B0%8F%E6%A0%B9%E5%A0%86%E4%B8%BA%E4%BE%8B%29" rel="nofollow">9.堆的实现代码总览(以小根堆为例)</a></p> 
<p id="10.%E7%BB%93%E8%AF%AD-toc" style="margin-left:40px;"><a href="#10.%E7%BB%93%E8%AF%AD" rel="nofollow">10.结语</a></p> 
<p id="%C2%A0-toc" style="margin-left:40px;"><a href="#%C2%A0" rel="nofollow"> </a></p> 
<p id="%C2%A0-toc" style="margin-left:40px;"><a href="#%C2%A0" rel="nofollow"> </a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E5%89%8D%E8%A8%80">前言</h2> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>关于数据结构的文章:写博客的时候我感觉在表达层面上有点费劲,如果文章整体在表述上让人感觉不够清楚,恳请读者原谅,本菜狗已经尽力了.</strong></span></p> 
</blockquote> 
<h2 id="%E4%B8%80.%E5%A0%86%E7%9A%84%E4%BB%8B%E7%BB%8D">一.堆的介绍</h2> 
<h4 id="1.%E5%A0%86%E7%9A%84%E6%9C%AC%E8%B4%A8">1.堆的本质</h4> 
<blockquote> 
 <p><strong>关于二叉树的图论基础参见:</strong><a class="has-card" href="http://t.csdn.cn/Nv325" rel="nofollow" title="http://t.csdn.cn/Nv325"><span class="link-card-box"><span class="link-title">http://t.csdn.cn/Nv325</span><span class="link-link"><img alt="" class="link-link-icon" src="https://images2.imgbox.com/a1/09/LkU9GAv1_o.png">http://t.csdn.cn/Nv325</span></span></a><span style="color:#0d0016;"><strong>青菜友情提示:</strong></span><span style="color:#fe2c24;"><strong>基础概念</strong></span><span style="color:#0d0016;"><strong>对于理解堆的实现与运用非常重要</strong></span></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">堆的本质</span>是<span style="background-color:#ffd900;">映射</span>在<span style="background-color:#ffd900;">内存中顺序存储结构</span>(数组)上的</strong></span><span style="color:#fe2c24;"><strong>完全二叉树(</strong></span><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">完全二叉树是堆的逻辑结构</span></strong></span><span style="color:#fe2c24;"><strong>).</strong></span></p> 
 <p><span style="color:#0d0016;"><strong>堆的图解:</strong></span></p> 
 <p><img alt="" height="776" src="https://images2.imgbox.com/91/4d/U2GqbZL9_o.png" width="1200"></p> 
 <ul><li><strong><span style="background-color:#ffd900;">结点中的数据</span>存储在<span style="color:#0d0016;"><span style="background-color:#ffd900;">相应下标</span></span>的数组元素空间中</strong></li></ul> 
</blockquote> 
<h4 id="2.%E5%A0%86%E7%9A%84%E5%88%86%E7%B1%BB">2.堆的分类</h4> 
<blockquote> 
 <p><strong><span style="color:#0d0016;">堆的两个类型：</span></strong></p> 
 <ol><li><span style="color:#0d0016;"><strong>大根堆:在<span style="background-color:#ffd900;">大根堆中</span></strong></span><span style="color:#fe2c24;"><strong>任何子结构</strong></span><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">的父结点</span></strong></span><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">中存储的值</span></strong></span><span style="color:#fe2c24;"><strong>大于</strong></span><span style="color:#0d0016;"><strong>其</strong></span><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">左右孩子结点中存储的值</span>(即<span style="background-color:#ffd900;">任何一条连通路径上</span><span style="background-color:#a2e043;">从上往下</span></strong></span><span style="color:#fe2c24;"><strong>满足降序排列</strong></span><span style="color:#0d0016;"><strong>)</strong></span><img alt="" height="762" src="https://images2.imgbox.com/a7/c8/8rsVs232_o.png" width="1200"></li><li><strong>小根堆:</strong><span style="color:#0d0016;"><strong>在<span style="background-color:#ffd900;">小根堆中</span></strong></span><span style="color:#fe2c24;"><strong>任何子结构</strong></span><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">的父结点</span></strong></span><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">中存储的值</span></strong></span><span style="color:#fe2c24;"><strong>小于</strong></span><span style="color:#0d0016;"><strong>其<span style="background-color:#ffd900;">左右孩子结点中存储的值</span>(即<span style="background-color:#ffd900;">任何一条连通路径上</span><span style="background-color:#a2e043;">从上往下</span></strong></span><span style="color:#fe2c24;"><strong>满足升序排列</strong></span><span style="color:#0d0016;"><strong>)</strong></span><img alt="" height="728" src="https://images2.imgbox.com/fa/2d/hOEL6KF4_o.png" width="1200"></li></ol> 
</blockquote> 
<h2 id="%E4%BA%8C.%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0(%E4%BB%A5%E5%B0%8F%E6%A0%B9%E5%A0%86%E4%B8%BA%E4%BE%8B)">二.堆的实现(以小根堆为例)</h2> 
<h3 id="1.%E5%85%B3%E4%BA%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%A4%E7%BB%84%E9%87%8D%E8%A6%81%E7%BB%93%E8%AE%BA%EF%BC%9A">1.关于二叉树的<strong>两组重要结论：</strong></h3> 
<blockquote> 
 <ul><li><strong>堆的任何一个<span style="background-color:#ffd900;">父结点的编号parent</span>与其<span style="background-color:#ffd900;">左孩子结点的编号leftchild</span>满足如下关系式:</strong><img alt="" height="737" src="https://images2.imgbox.com/cf/16/oJSpj0To_o.png" width="958"></li><li><strong>堆的任何一个<span style="background-color:#ffd900;">父结点的编号parent</span>与其<span style="background-color:#ffd900;">右孩子结点的编号rightchild</span>满足如下关系式:</strong><img alt="" height="476" src="https://images2.imgbox.com/09/7a/vRI0PyUt_o.png" width="613"></li></ul> 
 <p><span style="color:#0d0016;"><strong>这两组重要结论的</strong></span><span style="color:#fe2c24;"><strong>推导和分析</strong></span><span style="color:#0d0016;"><strong>参见青菜的博客:</strong></span><a class="has-card" href="http://t.csdn.cn/Nv325" rel="nofollow" title="http://t.csdn.cn/Nv325"><span class="link-card-box"><span class="link-title">http://t.csdn.cn/Nv325</span><span class="link-link"><img alt="" class="link-link-icon" src="https://images2.imgbox.com/7f/85/NW5lNru2_o.png">http://t.csdn.cn/Nv325</span></span></a></p> 
</blockquote> 
<h3 id="2.%E5%A0%86%E7%9A%84%E7%89%A9%E7%90%86%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E6%A1%86%E6%9E%B6(%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E7%AE%80%E5%8D%95%E6%9E%84%E5%BB%BA)">2.堆的物理存储结构框架(动态数组的简单构建)</h3> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>堆是<span style="background-color:#ffd900;">存储在数组上的(大小根)完全二叉树</span>,因此在实现堆之前我们先</strong></span><span style="color:#fe2c24;"><strong>构建一个简单的动态数组</strong></span><span style="color:#0d0016;"><strong>作为物理存储结构框架:</strong></span></p> 
 <ul><li><strong>维护动态数组的结构体:</strong> <pre><code class="language-cpp">typedef int HPDataType;   //堆元素类型
typedef struct Heap
{
	HPDataType* arry;     //堆区内存指针
	size_t size;          //堆元素个数
	size_t capacity;      //数组的空间容量
}HP;
</code></pre> </li><li><strong>堆的基础操作接口声明：</strong> <pre><code class="language-cpp">//维护堆的结构体的初始化接口
void HeapInit(HP* php);


//销毁堆的接口
void HeapDestroy(HP* php);


//堆元素的打印接口
void HeapPrint(HP* php);


//判断堆是否为空(堆中有无元素)的接口
bool HeapEmpty(HP* php);


//返回堆中元素个数的接口
size_t HeapSize(HP* php);


//返回堆顶元素(即编号为0的元素)的接口
HPDataType HeapTop(HP* php);</code></pre> </li><li><strong>基础接口的实现:</strong> <pre><code class="language-cpp">//堆结构体的初始化接口
void HeapInit(HP* ptrheap)
{
	assert(ptrheap);
	ptrheap-&gt;arry = NULL;
	ptrheap-&gt;capacity = 0;
	ptrheap-&gt;size = 0;

}


//销毁堆的接口
void HeapDestroy(HP* ptrheap)
{
	assert(ptrheap);
	free(ptrheap-&gt;arry);
	ptrheap-&gt;arry = NULL;
	ptrheap-&gt;capacity = 0;
	ptrheap-&gt;size = 0;
}


//堆的打印接口
void HeapPrint(HP* ptrheap)
{
	assert(ptrheap);
	size_t tem = 0;
	for (tem = 0; tem &lt; ptrheap-&gt;size; ++tem)
	{
		printf("%d-&gt;", ptrheap-&gt;arry[tem]);

	}
	printf("END\n");
}



//判断堆是否为空的接口
bool HeapEmpty(HP* ptrheap)
{
	assert(ptrheap);
	return (0 == ptrheap-&gt;size);
}


//返回堆元素个数的接口
size_t HeapSize(HP* ptrheap)
{
	assert(ptrheap);
	return ptrheap-&gt;size;
}


//返回堆顶元素的接口
HPDataType HeapTop(HP* ptrheap)
{
	assert(!HeapEmpty(ptrheap));
	return ptrheap-&gt;arry[0];
}</code></pre> <p><span style="color:#0d0016;"><strong>主函数建堆时的内存布局简单图示:</strong></span></p> <p><img alt="" height="951" src="https://images2.imgbox.com/86/cb/X9ddQCRc_o.png" width="1200"></p> <p><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">堆区上的数组</span>是在<span style="background-color:#ffd900;">堆元素插入接口中调用malloc申请出来的</span>(我们暂时还没有实现堆元素插入的接口)</strong></span></p> </li><li> <p><span style="color:#0d0016;"><strong>以上是堆在内存中的存储框架的构建,然而</strong></span><span style="color:#fe2c24;"><strong>堆的核心接口是</strong></span><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">堆元素的插入和删除接口</span></strong></span></p> </li></ul> 
</blockquote> 
<h3 id="3.%20%E5%A0%86%E5%85%83%E7%B4%A0%E6%8F%92%E5%85%A5%E6%8E%A5%E5%8F%A3(%E4%BB%A5%E5%B0%8F%E6%A0%B9%E5%A0%86%E4%B8%BA%E4%BE%8B)">3. 堆元素插入接口(以小根堆为例)</h3> 
<blockquote> 
 <ul><li><span style="color:#0d0016;"><strong>堆的构建过程概述:向堆尾<span style="background-color:#ffd900;">逐个插入元素(将元素尾插进数组中)</span>,</strong></span><span style="color:#be191c;"><strong>每次插入一个元素后</strong></span><span style="color:#0d0016;"><strong>都通过</strong></span><span style="color:#be191c;"><strong>堆的调整算法</strong></span><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">逐层向上(二叉树意义上的层)(</span><span style="background-color:#a2e043;">子结点和父结点进行大小比较,</span><span style="background-color:#ffd900;">若不满足小根堆的性质</span><span style="background-color:#a2e043;">就进行数值交换</span><span style="background-color:#ffd900;">)调整该元素在堆中的位置以保持小根堆的数据结构</span>.</strong></span></li><li><span style="color:#0d0016;"><strong>算法过程简图:</strong></span><img alt="" height="418" src="https://images2.imgbox.com/46/c6/2kcm9OO5_o.png" width="1200"></li><li><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">从0个结点的堆开始</span>,<span style="background-color:#ffd900;">每尾插一个元素</span>我们都按照小根堆的性质(</strong></span><span style="color:#be191c;"><strong>通过元素向上调整算法</strong></span><span style="color:#0d0016;"><strong>)<span style="background-color:#ffd900;">调整该元素在堆中的位置</span></strong></span><span style="color:#be191c;"><strong>来保持小根堆的数据结构</strong></span><span style="color:#0d0016;"><strong>,<span style="background-color:#ffd900;">我们就是以这样的基本思想来建堆的</span>.</strong></span></li><li><span style="color:#fe2c24;"><strong>建堆</strong></span><span style="color:#0d0016;"><strong>的思路细解:</strong></span><img alt="" height="896" src="https://images2.imgbox.com/fe/78/PPJKuEuz_o.png" width="1200"></li></ul> 
 <p></p> 
 <ul><li><strong>显然在堆尾插入元素6后<span style="background-color:#ffd900;">破坏了小根堆的结构(</span><span style="color:#be191c;">6小于其父结点20不满足小根堆的性质</span><span style="background-color:#ffd900;">)(</span><span style="color:#fe2c24;">将</span><span style="color:#0d0016;"><span style="background-color:#ffd900;">任意一个子结构中</span></span><span style="color:#be191c;">子结点与父结点进行大小比较</span><span style="color:#0d0016;"><span style="background-color:#ffd900;">就可以知道堆的结构有没有被破坏</span></span><span style="background-color:#ffd900;">)</span>,因此我们就需要<span style="background-color:#ffd900;">将6这个元素逐层向二叉树的上层调整(</span><span style="background-color:#a2e043;">每个调整的子步骤都是</span><span style="color:#fe2c24;">从子结点向父结点调整</span><span style="background-color:#ffd900;">)</span></strong></li><li><strong>通过<span style="background-color:#ffd900;">树的子结构中</span><span style="color:#fe2c24;">子结点与父结点的编号关系</span>可以找到堆尾<span style="background-color:#ffd900;">8号结点</span>(<span style="color:#fe2c24;">元素6</span>)的<span style="background-color:#ffd900;">父结点</span>(<span style="color:#fe2c24;">元素20,结点编号为3</span>)</strong></li><li><strong>接下来<span style="background-color:#ffd900;">将元素逐层向上调整(子结点和父结点进行数值交换)</span>来<span style="color:#fe2c24;">恢复小根堆的数据结构:</span></strong></li></ul> 
 <p><span style="color:#be191c;"><strong>向上调整的第一步</strong></span><span style="color:#0d0016;"><strong>:将<span style="background-color:#ffd900;">尾插进堆尾的结点</span>(8号结点,值为6)与<span style="background-color:#ffd900;">其父结点</span>(3号结点,值为20)进行比较,<span style="background-color:#ffd900;">父结点大于子结点</span>,交换父结点与子结点的值(下图中的Swap是元素数值交换接口):</strong></span><img alt="" height="906" src="https://images2.imgbox.com/d3/ad/clvTkpG5_o.png" width="1200"></p> 
 <p><span style="color:#be191c;"><strong>向上调整的第二步</strong></span><span style="color:#0d0016;"><strong>:交换了8号结点和3号结点的值后,<span style="background-color:#ffd900;">我们发现小堆结构依然不成立</span>,于是<span style="background-color:#ffd900;">重复上述的调整过程</span>,<span style="background-color:#ffd900;">将元素6继续向上层的父结点位置进行调整</span>,<span style="background-color:#ffd900;">不断重复迭代</span></strong></span><span style="color:#fe2c24;"><strong>直到小堆结构恢复</strong></span><span style="color:#0d0016;"><strong>或者</strong></span><span style="color:#fe2c24;"><strong>元素6被调到堆顶为止</strong></span><span style="color:#0d0016;"><strong>:</strong></span><img alt="" height="855" src="https://images2.imgbox.com/9c/49/IhKybUCr_o.png" width="1200"></p> 
 <ul><li><span style="color:#0d0016;"><strong>可见经过再一次调整后,<span style="background-color:#ffd900;">元素6来到了1号结点</span>,此时<span style="background-color:#ffd900;">1号结点大于0号结点</span>,<span style="background-color:#ffd900;">小堆数据结构得到恢复</span>,调整过程终止。</strong></span></li></ul> 
 <p><span style="color:#fe2c24;"><strong>同时不难分析出</strong></span><span style="color:#0d0016;"><strong>,任何<span style="background-color:#ffd900;">堆尾元素向上调整的过程</span>都是</strong></span><span style="color:#fe2c24;"><strong>在堆尾到堆顶元素的</strong></span><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">连通路径上进行的(</span></strong></span><span style="color:#be191c;"><strong>该路径长度数量级为logk</strong></span><span style="color:#fe2c24;"><strong>)</strong></span><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">(k为当前树结点总个数))</span>:</strong></span><img alt="" height="1020" src="https://images2.imgbox.com/ad/80/eqt7uasG_o.png" width="1200"></p> 
 <p></p> 
 <ul><li><strong>根据上面的分析我们可以设计出一个<span style="background-color:#ffd900;">堆尾元素向上调整的算法接口</span>:</strong></li></ul> 
 <p><span style="color:#0d0016;"><strong>接口首部: arry是</strong></span><span style="color:#fe2c24;"><strong>指向数组首地址的指针</strong></span><span style="color:#0d0016;"><strong>,child是</strong></span><span style="color:#fe2c24;"><strong>堆尾元素的编号(</strong></span><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">结点编号同时也是该元素的数组下标</span></strong></span><span style="color:#fe2c24;"><strong>)</strong></span></p> 
 <pre><code class="language-cpp">void AdjustUp(HPDataType* arry, size_t child);</code></pre> 
 <h4 id="%E5%A0%86%E5%B0%BE%E5%85%83%E7%B4%A0%E5%90%91%E4%B8%8A%E8%B0%83%E6%95%B4%E7%9A%84%E7%AE%97%E6%B3%95%E6%8E%A5%E5%8F%A3%3A"><span style="color:#0d0016;"><strong>堆尾元素向上调整的算法接口:</strong></span></h4> 
 <pre><code class="language-cpp">//元素交换接口
void Swap(HPDataType* e1, HPDataType* e2)
{
	assert(e1 &amp;&amp; e2);
	HPDataType tem = *e1;
	*e1 = *e2;
	*e2 = tem;
}



//小堆元素的向上调整接口
void AdjustUp(HPDataType* arry, size_t child)  //child表示孩子结点的编号
{
	assert(arry);
	size_t parent = (child - 1) / 2;    //算出父结点的数组下标(堆编号)
	while (child &gt; 0)			        //child减小到0时则调整结束(堆尾元素已调到堆顶)
	{
		if (arry[child] &lt; arry[parent]) //父结点大于子结点,则子结点需要上调以保持小堆的结构
		{
			Swap(arry + child, arry+parent);
			child = parent;				//将原父结点作为新的子结点继续迭代过程
			parent = (child - 1) / 2;	//算出父结点的数组下标(堆编号)
		}
		else
		{
			break;						//父结点不大于子结点,则堆结构恢复,无需再调整
		}
	}
}</code></pre> 
 <p><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">堆尾元素向上调整的算法接口中</span>需要注意的细节:</strong></span></p> 
 <ul><li><span style="color:#0d0016;"><strong>调整循环的终止条件有两个:</strong></span></li></ul> 
 <ol><li><span style="color:#0d0016;"><strong>一个是<span style="background-color:#ffd900;">被调整元素</span>被调到了堆顶(即child=0的时候)</strong></span></li><li><span style="color:#0d0016;"><strong>当<span style="background-color:#ffd900;">被调整元素</span>大于其父结点时<span style="background-color:#ffd900;">小堆的数据结构得到恢复</span>,break终止循环</strong></span></li></ol> 
 <p><span style="color:#0d0016;"><strong>有了该接口,我们就可以<span style="background-color:#ffd900;">设计堆元素插入接口:</span></strong></span></p> 
 <ul><li><span style="color:#0d0016;"><strong>HP * ptrheap是<span style="background-color:#ffd900;">指向堆结构体的结构体指针</span>,x是要插入的元素的数值</strong></span></li></ul> 
 <pre><code class="language-cpp">void HeapPush(HP* ptrheap, HPDataType x)</code></pre> 
 <pre><code class="language-cpp">// 插入一个小堆元素的接口
// 插入x以后，保持其数据结构依旧是小堆
void HeapPush(HP* ptrheap, HPDataType x)        //ptrheap是指向堆结构体的结构体指针
{
	assert(ptrheap);
	if (ptrheap-&gt;capacity == ptrheap-&gt;size)	    //数组容量检查,容量不够则扩容
	{
		size_t newcapacity = (0 == ptrheap-&gt;capacity) ? 4 : 2 * ptrheap-&gt;capacity;
        //注意容量为0则将堆区数组容量调整为4
		HPDataType* tem = (HPDataType*)realloc(ptrheap-&gt;arry, newcapacity*sizeof(HPDataType)); //空间不够则扩容
		assert(tem);             //检查扩容是否成功
		ptrheap-&gt;arry = tem;     //将堆区地址赋给结构体中的指针成员
		ptrheap-&gt;capacity = newcapacity; //容量标记更新
	}
	ptrheap-&gt;arry[ptrheap-&gt;size] = x;			//元素尾插入堆
	ptrheap-&gt;size++;


	//将尾插的元素进行向上调整以保持堆的数据结构(复用元素向上调整接口)
	AdjustUp(ptrheap-&gt;arry, ptrheap-&gt;size - 1); //根据完全二叉树的结构特点可知堆尾元素                
                                                //在二叉树中编号为size-1
}
</code></pre> 
 <ul><li><strong>该接口<span style="background-color:#ffd900;">可以完成一个堆元素的插入</span>(而且<span style="background-color:#ffd900;">每次完成插入后</span><span style="color:#be191c;">小根堆的数据结构都可以得到保持</span>)</strong></li><li><strong>如果我们想要创建一个n个元素小根堆,则n次调用HeapPush接口即可</strong></li></ul> 
</blockquote> 
<h3 id="4.%E5%A0%86%E5%85%83%E7%B4%A0%E6%8F%92%E5%85%A5%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95">4.堆元素插入接口测试</h3> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>现在我们试着用HeapPush接口来构建<span style="background-color:#ffd900;">六个元素的小堆,并将堆打印出来观察其逻辑结构:</span></strong></span></p> 
 <ul><li><span style="color:#0d0016;"><strong>主函数代码:</strong></span> <pre><code class="language-cpp">int main ()
{
    HP hp;              //创建一个堆结构体
	HeapInit(&amp;hp);      //结构体初始化
	HeapPush(&amp;hp, 1);   //调用堆元素插入接口建堆
	HeapPush(&amp;hp, 5);
	HeapPush(&amp;hp, 0);
	HeapPush(&amp;hp, 8);
	HeapPush(&amp;hp, 3);
	HeapPush(&amp;hp, 9);
	HeapPrint(&amp;hp);     //打印堆元素
}</code></pre> <p><img alt="" height="253" src="https://images2.imgbox.com/4d/0b/7LOXDZYG_o.png" width="739"></p> <p><span style="color:#0d0016;"><strong>我们来观察一下打印出来的<span style="background-color:#ffd900;">小根堆的逻辑结构:</span></strong></span><img alt="" height="490" src="https://images2.imgbox.com/83/37/9HEtkxIB_o.png" width="830"></p> <p></p> </li></ul> 
</blockquote> 
<h3 id="5.%E5%A0%86%E5%85%83%E7%B4%A0%E6%8F%92%E5%85%A5%E6%8E%A5%E5%8F%A3%E5%BB%BA%E5%A0%86%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90(%E5%BB%BA%E5%A0%86%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)">5.堆元素插入接口建堆的时间复杂度分析(建堆时间复杂度)</h3> 
<blockquote> 
 <ul><li><strong>假设现在我们要<span style="background-color:#ffd900;">调用</span><span style="color:#0d0016;"><span style="background-color:#ffd900;">HeapPush接口</span>来<span style="background-color:#ffd900;">创建一个N个元素的小堆(</span></span><span style="color:#fe2c24;">调用N次HeapPush接口</span><span style="color:#0d0016;"><span style="background-color:#ffd900;">)</span></span></strong></li><li><span style="color:#0d0016;"><strong>注意:我们只关注时间复杂度最坏的情况(即<span style="background-color:#ffd900;">假设每个插入堆尾的元素都</span></strong></span><span style="color:#fe2c24;"><strong>沿着连通路径</strong></span><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">向上调整到了堆顶</span>)</strong></span><img alt="" height="742" src="https://images2.imgbox.com/a8/2c/VpnfQMY4_o.png" width="1200"></li><li><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">分析建堆的时间复杂度时</span>我们将堆看成满二叉树(</strong></span><span style="color:#be191c;"><strong>满二叉树是特殊的完全二叉树</strong></span><span style="color:#0d0016;"><strong>),也就是说当堆有N个元素时,<span style="background-color:#ffd900;">堆的层数h=log(N+1)</span>(该对数以2为底,<span style="background-color:#ffd900;">计算机科学中我们一般不关注对数的底数</span>)</strong></span><img alt="" height="583" src="https://images2.imgbox.com/6b/7c/YFqpRxuJ_o.png" width="1200"></li><li><strong>接下来我们<span style="color:#0d0016;"><span style="background-color:#ffd900;">将所有元素的向上调整次数进行求和</span></span>,即可得出用<span style="color:#0d0016;"><span style="background-color:#ffd900;">HeapPush接口</span></span><span style="background-color:#ffd900;">建堆</span>的时间复杂度:</strong><img alt="" height="884" src="https://images2.imgbox.com/64/d7/zNfV1Rrd_o.png" width="1200"></li><li><strong>用<span style="background-color:#ffd900;">错位相减法</span>可对上面公式<span style="color:#0d0016;"><span style="background-color:#ffd900;">进行求和计算:</span></span></strong><img alt="" height="1200" src="https://images2.imgbox.com/d4/83/CwgEOq1m_o.png" width="1200"></li><li><strong>因此可以得到用堆元素插入接口(<span style="background-color:#ffd900;">堆元素向上调整算法</span>)建堆(<span style="color:#0d0016;"><span style="background-color:#ffd900;">建立N个元素的小根堆</span></span>)的时间复杂度为:O(NlogN);</strong></li></ul> 
 <p></p> 
</blockquote> 
<h3 id="6.%E5%A0%86%E5%85%83%E7%B4%A0%E5%88%A0%E9%99%A4%E6%8E%A5%E5%8F%A3(%E5%90%8C%E6%A0%B7%E4%BB%A5%E5%B0%8F%E6%A0%B9%E5%A0%86%E4%B8%BA%E4%BE%8B%E5%AD%90)">6.堆元素删除接口(同样以小根堆为例子)</h3> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>我们讨论的</strong></span><span style="color:#fe2c24;"><strong>堆元素删除</strong></span><span style="color:#0d0016;"><strong>指的是:<span style="background-color:#ffd900;">删除堆顶数据</span></strong></span></p> 
</blockquote> 
<blockquote> 
 <p><strong><span style="color:#0d0016;"><span style="background-color:#ffd900;">删除堆顶的元素</span>的基本思路:</span></strong></p> 
 <ul><li><strong>先<span style="color:#0d0016;"><span style="background-color:#ffd900;">将堆顶元素与堆尾元素进行交换</span></span>,然后令<span style="background-color:#ffd900;">维护堆的结构体</span>中的size(<span style="color:#0d0016;"><span style="background-color:#ffd900;">记录堆元素个数的成员变量</span></span>)减一(<span style="color:#be191c;">相当于移除堆尾元素</span>)</strong><img alt="" height="377" src="https://images2.imgbox.com/03/08/GuqHZhz8_o.png" width="1200"></li><li><strong>然而原来的<span style="background-color:#ffd900;">堆尾元素</span><span style="background-color:#a2e043;">被交换到堆顶位置后</span>,<span style="background-color:#ffd900;">小根堆的数据结构会被破坏</span>,因此<span style="color:#fe2c24;">我们需要将堆顶元素进行向下调整操作</span><span style="color:#0d0016;"><span style="background-color:#ffd900;">:</span></span></strong><img alt="" height="687" src="https://images2.imgbox.com/f9/26/j2EKT8aP_o.png" width="1200"></li><li><strong>堆顶元素向下调整图解演示:</strong><img alt="" height="862" src="https://images2.imgbox.com/4d/b1/LdJ5xVzX_o.gif" width="1200"></li><li><span style="color:#fe2c24;"><strong>同样不难分析出</strong></span><span style="color:#0d0016;"><strong>,任何<span style="background-color:#ffd900;">堆顶元素向下调整的过程</span>都是</strong></span><span style="color:#fe2c24;"><strong>在堆顶到堆尾元素的</strong></span><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">连通路径上进行的(</span></strong></span><span style="color:#be191c;"><strong>该路径长度数量级为logk</strong></span><span style="color:#fe2c24;"><strong>)</strong></span><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">(k为当前树结点总个数))</span>:</strong></span><img alt="" height="692" src="https://images2.imgbox.com/aa/07/QOVxWywM_o.png" width="1200"></li><li><strong>通过<span style="background-color:#ffd900;">算法分析</span>我们可以<span style="background-color:#ffd900;">设计一个堆元素向下调整算法接口</span>:</strong>  </li></ul> 
 <p><strong><span style="color:#0d0016;">arry是<span style="background-color:#ffd900;">指向内存堆区数组首地址的指针</span>,size是<span style="background-color:#ffd900;">堆的结点总个数</span>,parent是<span style="background-color:#ffd900;">待调整结点在堆中的编号;</span></span></strong></p> 
 <pre><code class="language-cpp">void AdjustDown(HPDataType* arry,size_t size,size_t parent)</code></pre> 
 <h4 id="%E5%A0%86%E5%85%83%E7%B4%A0%E5%90%91%E4%B8%8B%E8%B0%83%E6%95%B4%E7%AE%97%E6%B3%95%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%3A"><span style="color:#0d0016;"><strong>堆元素向下调整算法接口实现:</strong></span></h4> 
 <pre><code class="language-cpp">//元素交换接口
void Swap(HPDataType* e1, HPDataType* e2)
{
	assert(e1 &amp;&amp; e2);
	HPDataType tem = *e1;
	*e1 = *e2;
	*e2 = tem;
}

//小堆元素的向下调整接口
void AdjustDown(HPDataType* arry,size_t size,size_t parent)
{
	assert(arry);
	size_t child = 2 * parent + 1;   //确定父结点的左孩子的编号
	while (child &lt; size)			 //child增加到大于或等于size时说明被调整元素被调整到了叶结点上,调整过程结束
	{
		if (child + 1 &lt; size &amp;&amp; arry[child + 1] &lt; arry[child])//确定左右孩子中较小的孩子结点
		{
			++child;   //条件成立说明右孩子较小,child更新为右孩子编号
		}
		if ( arry[child] &lt; arry[parent])//父结点大于子结点,则父结点需要下调以保持小堆的结构
		{
			Swap(arry + parent, arry + child);//父子结点进行值交换
			parent = child;				      //将原来的子结点作为新的父结点继续迭代过程
			child = 2 * parent + 1;		      //继续向下找另外一个子结点
		}
		else
		{
			break;						//父结点不大于子结点,则小堆结构成立,无需继续调整
		}
	}
}</code></pre> 
 <ul><li><span style="color:#0d0016;"><strong> 注意一下<span style="background-color:#ffd900;">算法接口</span>的一些细节和边界条件:</strong></span></li></ul> 
 <ol><li><span style="color:#0d0016;"><strong>child&lt;size说明被调整元素已经被调整到叶结点位置,结束调整过程</strong></span></li><li><span style="color:#0d0016;"><strong>算法接口中<span style="background-color:#ffd900;">我们只设计了一个child变量</span>来<span style="background-color:#ffd900;">记录当前父结点的孩子结点的编号</span>,接着<span style="background-color:#ffd900;">通过arry[child + 1] &lt; arry[child]来比较左右孩子大小</span><span style="background-color:#a2e043;">来确定child到底是取左孩子的编号还是取右孩子的编号</span>(注意<span style="background-color:#ffd900;">child+1&lt;size判断语句</span>是为了确定右孩子是否存在)</strong></span></li></ol> 
 <ul><li><span style="color:#0d0016;"><strong>有了堆元素向下调整算法接口我们就可以实现<span style="background-color:#ffd900;">堆顶数据删除接口:</span></strong></span> <pre><code class="language-cpp">//删除堆顶元素
void HeapPop(HP* ptrheap)
{
	assert(ptrheap);
	Swap(ptrheap-&gt;arry, ptrheap-&gt;arry + ptrheap-&gt;size - 1); //交换堆顶与堆尾元素
	ptrheap-&gt;size--;										//删除堆尾元素
	AdjustDown(ptrheap-&gt;arry, ptrheap-&gt;size, 0);    //将堆顶元素进行向下调整以保持堆的数据结构
}</code></pre> <p><span style="color:#0d0016;"><strong>注意:AdjustDown接口的传参中,ptrheadp-&gt;size指的是<span style="background-color:#ffd900;">堆元素的总个数</span>,由于我们要<span style="background-color:#ffd900;">将堆顶元素向下调整</span>,因此<span style="background-color:#ffd900;">传入的被调整结点编号为0</span></strong></span></p> </li><li> <p><span style="color:#0d0016;"><strong>该接口</strong></span><span style="color:#fe2c24;"><strong>每调用一次</strong></span><span style="color:#0d0016;"><strong>就可以</strong></span><span style="color:#fe2c24;"><strong>删除一个堆顶数据</strong></span><span style="color:#0d0016;"><strong>(<span style="background-color:#ffd900;">并保持小根堆的数据结构</span>):</strong></span><img alt="" height="411" src="https://images2.imgbox.com/41/36/bc1JsDiB_o.png" width="1200"></p> </li></ul> 
</blockquote> 
<h3 id="7.%E5%A0%86%E5%85%83%E7%B4%A0%E5%88%A0%E9%99%A4%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95">7.堆元素删除接口测试</h3> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>我们<span style="background-color:#ffd900;">先6次调用HeapPush接口</span><span style="background-color:#a2e043;">创建一个六个元素的小堆</span>,然后再6次调用HeapPop接口<span style="background-color:#ffd900;">逐个删除堆顶元素</span>(</strong></span><span style="color:#be191c;"><strong>每删除一个堆顶数据打印一次堆</strong></span><span style="color:#0d0016;"><strong>,借此<span style="background-color:#ffd900;">观察每次删除堆顶数据后堆的数据结构</span>).</strong></span></p> 
 <pre><code class="language-cpp">int main ()
{
    HP hp;
	HeapInit(&amp;hp);
	HeapPush(&amp;hp, 1);
	HeapPush(&amp;hp, 5);
	HeapPush(&amp;hp, 0);
	HeapPush(&amp;hp, 8);
	HeapPush(&amp;hp, 3);
	HeapPush(&amp;hp, 9);
	HeapPrint(&amp;hp);

	HeapPop(&amp;hp);
	HeapPrint(&amp;hp);
	HeapPop(&amp;hp);
	HeapPrint(&amp;hp);
	HeapPop(&amp;hp);
	HeapPrint(&amp;hp);
	HeapPop(&amp;hp);
	HeapPrint(&amp;hp);
	HeapPop(&amp;hp);
	HeapPrint(&amp;hp);


	HeapDestroy(&amp;hp);

}</code></pre> 
 <p><img alt="" height="582" src="https://images2.imgbox.com/55/77/JIujApkG_o.png" width="819"></p> 
 <p><span style="color:#0d0016;"><strong>观察小根堆的数据结构(逻辑结构): </strong></span></p> 
 <p><img alt="" height="381" src="https://images2.imgbox.com/31/38/SDUcrwjB_o.png" width="1200"></p> 
 <ul><li><strong>可见<span style="background-color:#ffd900;">逐个删除堆顶数据的过程中</span><span style="background-color:#a2e043;">小根堆的数据结构得到了保持</span></strong></li></ul> 
</blockquote> 
<h3 id="8.%E9%80%90%E4%B8%AA%E5%88%A0%E9%99%A4%E5%A0%86%E9%A1%B6%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90(%E5%88%A0%E5%A0%86%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90)">8.逐个删除堆顶数据过程的时间复杂度分析(删堆的时间复杂度分析)</h3> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>假设<span style="background-color:#ffd900;">现在有一个N个元素的小根堆</span>,我们<span style="background-color:#a2e043;">逐个删除堆顶数据直到将堆删空</span>。</strong></span></p> 
 <p><span style="color:#0d0016;"><strong>现在我们来分析这个过程的时间复杂度(我们同样</strong></span><span style="color:#fe2c24;"><strong>将二叉树看成满二叉树来分析</strong></span><span style="color:#0d0016;"><strong>):</strong></span></p> 
 <ul><li><span style="color:#0d0016;"><strong>同样我们考虑的是<span style="background-color:#ffd900;">时间复杂度最坏的情况</span>:即<span style="background-color:#a2e043;">每次调用堆元素删除接口后</span>,<span style="background-color:#ffd900;">被交换到堆顶的元素都</span><span style="background-color:#ffd900;">沿着连通路径</span>向下<span style="background-color:#a2e043;">被调整到叶结点</span></strong></span></li><li><strong>分析：假设</strong><strong><span style="background-color:#ffd900;">堆的高度为h</span>,则<span style="background-color:#a2e043;">满树的总结点个数N</span>为  : 2^h - 1 <br> 需要注意的是<span style="background-color:#ffd900;">满树的第h层(最后一层)</span>的结点个数为: 2^(h-1)</strong><img alt="" height="643" src="https://images2.imgbox.com/52/c2/hb0hDyLG_o.png" width="1200"></li></ul> 
 <p><strong><span style="color:#0d0016;">所以<span style="background-color:#ffd900;">满树的最后一层的结点个数</span>占树的<span style="background-color:#ffd900;">总结点个数</span>的一半</span></strong></p> 
 <p><span style="color:#0d0016;"><strong>因此如果我们<span style="background-color:#ffd900;">删去满树的前h-1层的所有结点</span>,则<span style="background-color:#a2e043;">由最后一层结点所构成的新树的高度大致为h-1:</span></strong></span><img alt="" height="423" src="https://images2.imgbox.com/bf/80/0CcI6PGZ_o.png" width="1128"></p> 
 <p><span style="color:#0d0016;"><strong>这也就意味着,在<span style="background-color:#ffd900;">删除前h-1层结点的过程中</span><span style="background-color:#a2e043;">树的总高度几乎不会发生变化:</span></strong></span></p> 
 <p><span style="color:#0d0016;"><strong>因此可以得到<span style="background-color:#ffd900;">删除满树的前h-1层所有结点过程中</span>,每个被交换到堆顶的元素都要被向下调整log(N+1)次,则<span style="background-color:#ffd900;">删除满树的前h-1层所有结点过程中</span>,向下调整算法中循环语句执行总次数<span style="background-color:#a2e043;">约为</span>:</strong></span></p> 
 <p><img alt="" height="81" src="https://images2.imgbox.com/d0/b6/2N9PfdyE_o.png" width="201"></p> 
 <p><strong><span style="color:#0d0016;">接着,对于<span style="background-color:#ffd900;">由原树的最后一层(第h层)结点</span>构成的<span style="background-color:#a2e043;">新树(层数为h-1层)</span>我们可以作类似的分析(<span style="background-color:#ffd900;">即先删除其前h-2层结点</span>,<span style="background-color:#a2e043;">得到由其第h-1层结点构成的新树</span>),以这种方式递推下去直到树被删空为止:</span></strong><img alt="" height="1200" src="https://images2.imgbox.com/bb/3c/9BheeRpf_o.png" width="1200"></p> 
 <ul><li><strong>由此可得,</strong> <span style="color:#0d0016;"><strong><span style="background-color:#a2e043;">逐个删除堆顶数据直到将堆删空过程中,</span><span style="background-color:#ffd900;">堆元素的向下调整算法中</span><span style="background-color:#a2e043;">循环语句总的执行次数估算为</span>:</strong></span></li></ul> 
 <p><img alt="" height="129" src="https://images2.imgbox.com/18/03/aTdgs48k_o.png" width="871"></p> 
 <p><span style="color:#0d0016;"><strong>该多项式的和化为大O阶渐进表示法结果为O(NlogN). </strong></span></p> 
 <ul><li><strong><span style="background-color:#ffd900;">逐个删除堆顶数据</span><span style="background-color:#a2e043;">直到将堆删空</span>的过程的时间复杂度分析为:O(NlogN)</strong></li></ul> 
</blockquote> 
<h3 id="9.%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E6%80%BB%E8%A7%88(%E4%BB%A5%E5%B0%8F%E6%A0%B9%E5%A0%86%E4%B8%BA%E4%BE%8B)">9.堆的实现代码总览(以小根堆为例)</h3> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>接口和结构类型声明的头文件:</strong></span></p> 
 <pre><code class="language-cpp">#pragma once
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;time.h&gt;

//实现小堆

typedef int HPDataType;
typedef struct Heap
{
	HPDataType* arry;
	size_t size;
	size_t capacity;
}HP;


//堆的初始化接口
void HeapInit(HP* php);
//销毁堆的接口
void HeapDestroy(HP* php);
//堆的打印接口
void HeapPrint(HP* php);
//判断堆是否为空的接口
bool HeapEmpty(HP* php);
//返回堆元素个数的接口
size_t HeapSize(HP* php);
//返回堆顶元素的接口
HPDataType HeapTop(HP* php);


void Swap(HPDataType* pa, HPDataType* pb);
//堆元素向上调整算法接口
void AdjustUp(HPDataType* a, size_t child);
//堆元素向下调整算法接口
void AdjustDown(HPDataType* a, size_t size,size_t parent);
// 插入元素x以后，保持数据结构是(大/小)堆
void HeapPush(HP* php, HPDataType x);
// 删除堆顶的数据后,保持数据结构是(大/小)堆
void HeapPop(HP* php);
</code></pre> 
 <p><span style="color:#0d0016;"><strong>各个堆操作接口的实现:</strong></span></p> 
 <pre><code class="language-cpp">#include "heap.h"


//堆的初始化接口
void HeapInit(HP* ptrheap)
{
	assert(ptrheap);
	ptrheap-&gt;arry = NULL;
	ptrheap-&gt;capacity = 0;
	ptrheap-&gt;size = 0;

}
//销毁堆的接口
void HeapDestroy(HP* ptrheap)
{
	assert(ptrheap);
	free(ptrheap-&gt;arry);
	ptrheap-&gt;arry = NULL;
	ptrheap-&gt;capacity = 0;
	ptrheap-&gt;size = 0;
}


//堆的打印接口
void HeapPrint(HP* ptrheap)
{
	assert(ptrheap);
	size_t tem = 0;
	for (tem = 0; tem &lt; ptrheap-&gt;size; ++tem)
	{
		printf("%d-&gt;", ptrheap-&gt;arry[tem]);

	}
	printf("END\n");
}



//判断堆是否为空的接口
bool HeapEmpty(HP* ptrheap)
{
	assert(ptrheap);
	return (0 == ptrheap-&gt;size);
}


//返回堆元素个数的接口
size_t HeapSize(HP* ptrheap)
{
	assert(ptrheap);
	return ptrheap-&gt;size;
}




//返回堆顶元素的接口
HPDataType HeapTop(HP* ptrheap)
{
	assert(!HeapEmpty(ptrheap));
	return ptrheap-&gt;arry[0];
}





//元素交换接口
void Swap(HPDataType* e1, HPDataType* e2)
{
	assert(e1 &amp;&amp; e2);
	HPDataType tem = *e1;
	*e1 = *e2;
	*e2 = tem;
}



//小堆元素的向上调整接口
void AdjustUp(HPDataType* arry, size_t child)  //child表示孩子结点的编号
{
	assert(arry);
	size_t parent = (child - 1) / 2;
	while (child &gt; 0)						   //child减小到0时则调整结束
	{
		if (arry[child] &lt; arry[parent])        //父结点大于子结点,则子结点需要上调以保持小堆的结构
		{
			Swap(arry + child, arry+parent);
			child = parent;				//将原父结点作为新的子结点继续迭代过程
			parent = (child - 1) / 2;	//继续向上找另外一个父结点
		}
		else
		{
			break;						//父结点不大于子结点,则堆结构任然成立,无需调整
		}
	}
}

// 插入一个小堆元素的接口
// 插入x以后，保持其数据结构依旧是小堆
void HeapPush(HP* ptrheap, HPDataType x)
{
	assert(ptrheap);
	if (ptrheap-&gt;capacity == ptrheap-&gt;size)	//容量检查,容量不够则扩容
	{
		size_t newcapacity = (0 == ptrheap-&gt;capacity) ? 4 : 2 * ptrheap-&gt;capacity;
		HPDataType* tem = (HPDataType*)realloc(ptrheap-&gt;arry, newcapacity * sizeof(HPDataType));
		assert(tem);
		ptrheap-&gt;arry = tem;
		ptrheap-&gt;capacity = newcapacity;
	}
	ptrheap-&gt;arry[ptrheap-&gt;size] = x;			//先尾插一个元素
	ptrheap-&gt;size++;
	//将尾插的元素进行向上调整以保持堆的数据结构
	AdjustUp(ptrheap-&gt;arry, ptrheap-&gt;size - 1); //根据完全二叉树的结构特点可知尾插进数组的元素在二叉树中编号为size-1
}



//小堆元素的向下调整接口
void AdjustDown(HPDataType* arry,size_t size,size_t parent)
{
	assert(arry);
	size_t child = 2 * parent + 1;   //确定父结点的左孩子的编号
	while (child &lt; size)			 //child增加到大于或等于size时则调整结束
	{
		if (child + 1 &lt; size &amp;&amp; arry[child + 1] &lt; arry[child]) //确定左右孩子中较小的孩子结点
		{
			++child;
		}
		if ( arry[child] &lt; arry[parent])//父结点大于子结点,则子结点需要上调以保持小堆的结构
		{
			Swap(arry + parent, arry + child);
			parent = child;				//将原子结点作为新的父结点继续迭代过程
			child = 2 * parent + 1;		//继续向下找另外一个子结点
		}
		else
		{
			break;						//父结点不大于子结点,则堆结构任然成立,无需调整
		}
	}
}


//删除堆顶元素
void HeapPop(HP* ptrheap)
{
	assert(ptrheap);
	Swap(ptrheap-&gt;arry, ptrheap-&gt;arry + ptrheap-&gt;size - 1); //交换堆顶与堆尾元素
	ptrheap-&gt;size--;										//删除堆尾元素
	AdjustDown(ptrheap-&gt;arry, ptrheap-&gt;size, 0);			//将堆顶元素进行向下调整以保持堆的数据结构
}</code></pre> 
</blockquote> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>我们只需将小根堆的<span style="background-color:#ffd900;">堆元素上下调整算法接口</span>中的<span style="background-color:#a2e043;">子父结点值大小比较符号改为大于号</span>即可实现大根堆</strong></span></p> 
</blockquote> 
<h3 id="10.%E7%BB%93%E8%AF%AD">10.结语</h3> 
<blockquote> 
 <ul><li><strong>本文的核心:通过堆元素的<span style="background-color:#a2e043;">上下调整算法接口完成</span><span style="background-color:#ffd900;">堆的构建和删空</span>(并分析过程的时间复杂度)</strong></li><li><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">堆元素上下调整算法接口</span>在后续的<span style="background-color:#a2e043;">堆排序和TopK问题中</span>还会</strong></span><span style="color:#fe2c24;"><strong>直接用到</strong></span></li><li><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">堆的高效性</span>来源于如下数学思想:利用</strong></span><span style="color:#0d0016;"><strong><span style="background-color:#a2e043;">指数级展开的数据结构</span></strong></span><span style="color:#0d0016;"><strong>模型<span style="background-color:#a2e043;">实现对数级连通路径遍历算法</span></strong></span><span style="color:#0d0016;"><strong>,从而降低了排序和查找的时间复杂度(不得不说前人的创造真的是无可比拟)</strong></span></li></ul> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/5a/2c/AuZk5LAh_o.jpg"></p> 
<p></p> 
<p></p> 
<p></p> 
<h3 id="%C2%A0"></h3> 
<h3></h3> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e3915c2db8cea33a5ea14f26788f5377/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">LVI-SAM：配置环境、安装测试、适配自己采集数据集</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5a5d25ed7a4af346a614fd88ec749e26/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用stable diffusion webui时，安装gfpgan失败的解决方案（windows下的操作）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>