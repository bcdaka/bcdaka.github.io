<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>浅析Vue3基础知识(vue3笔记之入门篇) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/53f4b0d75d3243d88328d64854a03bcd/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="浅析Vue3基础知识(vue3笔记之入门篇)">
  <meta property="og:description" content="本文是结合实践中和学习技术文章总结出来的笔记(个人使用),如有雷同纯属正常((✿◠‿◠))
喜欢的话点个赞,谢谢!
时下Vue框架都是使用Vue3版本来开发项目了,为了加深对Vue3基本知识的了解,特写了这个笔记
1. 生命周期 1.1. vue3生命周期 一个组件从开始到结束,正常的生命周期流程应该是这样:
//1.开始创建组件，在 beforeCreate 和 created 之前执行，创建的是 data 和 method setup() //2.在组件挂载之前执行 onBeforeMount() //3.在组件挂载之后执行 onMount() //4.在组件更新之前执行 onBeforeUpdate() //5.在组件更新之后执行 onUpdated() //6.在组件卸载之前执行 onBeforeUnmount() //7.在组件卸载之后执行 onUnmounted() 还有三个函数是特殊情况执行的:
onErrorCaptured
当捕获一个来自一个来自子孙组件的异常时触发的钩子函数
&lt;keep-alive&gt;: 被包含在&lt;keep-alive&gt;中的组件,会多出2个生命周期钩子函数:
onActivated
每次进入该组件页面都会触发
onDeactivated
比如从A组件切换到B组件,A组件消失时执行(等于是离开组件时触发)
1.2. vue2生命周期 vue2生命周期对比vue3生命周期,主要是beforeCreate和created被setup取代,还有一些方法名的变化:
//1.开始创建组件，在 beforeCreate 和 created 之前执行，创建的是 data 和 method beforeCreate &#43; created = setup() //2.在组件挂载之前执行 beforeMount() =&gt; onBeforeMount() //3.在组件挂载之后执行 mounted() =&gt; onMount() //4.在组件更新之前执行 beforUpdated() =&gt; onBeforeUpdate() //5.在组件更新之后执行 Updated() =&gt; onUpdated() //6.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-04T22:24:01+08:00">
    <meta property="article:modified_time" content="2024-06-04T22:24:01+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">浅析Vue3基础知识(vue3笔记之入门篇)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="u761af5d4">本文是结合实践中和学习技术文章总结出来的笔记(个人使用),如有雷同纯属正常((✿◠‿◠))</p> 
<p id="u96a4d144">喜欢的话点个赞,谢谢!</p> 
<p id="u88ebdb3f"></p> 
<p id="udadc53b3">时下Vue框架都是使用Vue3版本来开发项目了,为了加深对Vue3基本知识的了解,特写了这个笔记</p> 
<h4 id="swHGt">1. 生命周期</h4> 
<h5 id="itQCA">1.1. vue3生命周期</h5> 
<p id="u6fa8a73d">一个组件从开始到结束,正常的生命周期流程应该是这样:</p> 
<pre id="FT0FK"><code class="language-javascript">//1.开始创建组件，在 beforeCreate 和 created 之前执行，创建的是 data 和 method
setup()
//2.在组件挂载之前执行
onBeforeMount()
//3.在组件挂载之后执行
onMount()
//4.在组件更新之前执行
onBeforeUpdate()
//5.在组件更新之后执行
onUpdated()
//6.在组件卸载之前执行
onBeforeUnmount()
//7.在组件卸载之后执行
onUnmounted()</code></pre> 
<p id="ucdd93c0d"><strong>还有三个函数是特殊情况执行的:</strong></p> 
<p id="u52771494"><strong>onErrorCaptured</strong></p> 
<p id="uf36c9aac">当捕获一个来自一个来自子孙组件的异常时触发的钩子函数</p> 
<p id="ud82329a5"><strong>&lt;keep-alive&gt;: </strong>被包含在&lt;keep-alive&gt;中的组件,会多出2个生命周期钩子函数:</p> 
<p id="udd784815"><strong>onActivated</strong></p> 
<p id="u93c639b4">每次进入该组件页面都会触发</p> 
<p id="u690f3c72"><strong>onDeactivated</strong></p> 
<p id="uf9dbdb26">比如从A组件切换到B组件,A组件消失时执行(<strong>等于是离开组件时触发</strong>)</p> 
<h5 id="gApmi">1.2. vue2生命周期</h5> 
<p id="ua005e3b4">vue2生命周期对比vue3生命周期,主要是<strong>beforeCreate和created被setup取代,还有一些方法名的变化:</strong></p> 
<pre id="yIK75"><code class="language-javascript">//1.开始创建组件，在 beforeCreate 和 created 之前执行，创建的是 data 和 method
beforeCreate +  created  =  setup()
//2.在组件挂载之前执行
beforeMount()   =&gt;  onBeforeMount() 
//3.在组件挂载之后执行
mounted()       =&gt;  onMount()
//4.在组件更新之前执行
beforUpdated()  =&gt;  onBeforeUpdate()
//5.在组件更新之后执行
Updated()       =&gt;  onUpdated()
//6.在组件卸载之前执行
beforeDestory() =&gt;  onBeforeUnmount()
//7.在组件卸载之后执行
destoryed()     =&gt;  onUnmounted()
//&lt;keep-alive&gt;
activated()     =&gt;  onActivated() 
deactivated()   =&gt;  onDeactivated()
//当捕获一个来自一个来自子孙组件的异常时触发的钩子函数
errorCaptured()   =&gt;  onErrorCaptured()</code></pre> 
<p id="uf47f778e"></p> 
<h4 id="nA4as">2. 选项式api和组合式api</h4> 
<p id="uecb5d6cf">在做React开发的时候经常听到朋友抱怨vue2历史项目难以维护,代码分层逻辑乱的一团糟,本人也有幸维护过几个vue2项目,深有感触</p> 
<h5 id="Wi94C">2.1. 选项式api的痛点:</h5> 
<p id="u0ee4aa5f">一个整体的逻辑会被拆分到data、method、watch里面去,如果开发者经验不足或者不编写注释,代码维护程度简直令人抓狂(^_^)</p> 
<h5 id="zk6LK">2.2. 组合式api</h5> 
<p id="uceeef2f8"><strong>组合式api的特点就是可以将单个功能的状态、方法、计算属性都融合在一起组成一个hook</strong>(抽离逻辑自定义hook),然后再将这个hook引入到组合api里面,这样做的好处是便于阅读和代码维护,如下图所示:</p> 
<p id="ua89240dd"><strong>这图是社区复制而来(^_^)</strong></p> 
<p id="u8c05b74a"></p> 
<p><img alt="" class="left" height="223" id="uba9b495c" src="https://images2.imgbox.com/07/42/llt9Vh6C_o.gif" width="324"><img alt="" class="left" height="222" id="u8b0fd89b" src="https://images2.imgbox.com/77/b6/ROcP6pGv_o.gif" width="273"></p> 
<h6 id="jCL93">2.2.1. setup</h6> 
<p id="u8ac42459">Vue3新的一个配置项,所有的组合式函数都在此使用,<strong>只在初始化的时候执行一次。</strong>setup可以在选项式api里面使用,也可以在组合式api里面使用,不过官方更推荐在组合api风格里面使用,如下图所示:</p> 
<p id="uac67c710"><strong>选项式api风格:</strong></p> 
<pre id="gpkMi"><code class="language-javascript">&lt;script&gt;
import { ref } from 'vue'
export default {
    setup () {
        const count = ref(0)
        return {
            count
        }
    }
}
&lt;/script&gt;
&lt;template&gt;
  &lt;div&gt;{<!-- -->{ count }}&lt;/div&gt;
  &lt;button @click="count++"&gt;
    +
  &lt;/button&gt;
&lt;/template&gt;
&lt;style lang='less' scoped&gt;
&lt;/style&gt;</code></pre> 
<p id="u38963638"><strong>组合式api风格:</strong></p> 
<pre id="rGLIr"><code class="language-javascript">&lt;script setup lang="ts"&gt;
import { ref } from 'vue'
const count = ref(0)
&lt;/script&gt;
&lt;template&gt;
  &lt;div&gt;{<!-- -->{ count }}&lt;/div&gt;
  &lt;button @click="count++"&gt;
    +
  &lt;/button&gt;
&lt;/template&gt;
&lt;style lang='less' scoped&gt;&lt;/style&gt;</code></pre> 
<p id="u915e0a82"><strong>区别:</strong></p> 
<p id="uae0b3d68"><strong>此处官网介绍的比较详细,可以跳转查阅</strong><a href="https://cn.vuejs.org/guide/extras/composition-api-faq.html#more-flexible-code-organization" rel="nofollow" title="Vue3.js组合式api">Vue3.js组合式api</a></p> 
<ul><li id="uabb99b24">&lt;srcipt setup&gt;可以直接使用顶层变量和函数,选项式代码则还需要导出才能使用</li><li id="ub86b8455">&lt;srcipt setup&gt;对ts支持更好</li><li id="u3286a1e3">&lt;srcipt setup&gt;打包出来的体积更小</li><li id="ub4c3eee2">&lt;srcipt setup&gt;肉眼可见的代码直观性和简洁</li></ul> 
<h4 id="HWMZn">3. 响应式</h4> 
<p id="u1c4dab0d">Vue2与Vue3响应式的区别在于,vue2的响应式是基于Object.definePropert做数据劫持,而Vue3是基于Es6的Proxy来进行数据劫持</p> 
<h6 id="G7RKf">3.1.1. ref</h6> 
<p id="ubdcdc4cf">ref接收一个值,返回一个响应式对象,可以处理简单的数据类型,底层还是基于Object.definePropert做数据劫持,如果在处理对象类型的时候会求助reactive。如下图所示:</p> 
<pre id="BiU38"><code class="language-javascript">&lt;script setup lang="ts"&gt;
import { ref } from 'vue'
const count = ref(0)
&lt;/script&gt;
&lt;template&gt;
  &lt;div&gt;{<!-- -->{ count }}&lt;/div&gt;
  &lt;button @click="count++"&gt;
    +
  &lt;/button&gt;
&lt;/template&gt;
&lt;style lang='less' scoped&gt;&lt;/style&gt;</code></pre> 
<h6 id="XGjlm">3.1.2. reactive</h6> 
<p id="u15add22a">reactive是用来做深层响应式代理的,如果传入的是基本数据类型如数字、字符串等它将不是响应式对象,reactive返回一个Proxy对象,Proxy对象是专门用来处理代理的,内部可以实现数据的增删改查操作,所以reactive可以实现基本的拦截和自定义。如下图所示:</p> 
<pre id="CWOT6"><code class="language-javascript">&lt;script setup lang="ts"&gt;
import { ref } from 'vue'
const count = ref({
    arr: [1, 2, 3, 4]
})
const add = (value:number) =&gt; {
    count.value.arr.push(value)
}
&lt;/script&gt;
&lt;template&gt;
  &lt;div&gt;{<!-- -->{ count.arr }}&lt;/div&gt;
  &lt;button @click="add(1)"&gt;
    +
  &lt;/button&gt;
&lt;/template&gt;
&lt;style lang='less' scoped&gt;&lt;/style&gt;</code></pre> 
<h6 id="Q9GVC">3.1.3. shallowReactive 与 shallowRef</h6> 
<p id="u594bbe36">shallowRef传入对象不会求助reactive,只会对value值响应,shallowReactive只处理第一层的对象响应,更深层次不会进行响应。这两个api所用甚少,这里就不过多介绍了<br>  </p> 
<h4 id="AU8xt">4. 计算属性和监听</h4> 
<h5 id="Y4i5j">4.1. computed函数</h5> 
<p id="u4d4f79d4">computed函数是用来做计算的,通过监听某一个值得到一个新的值,有两种写法</p> 
<ol><li id="u8172c872"><strong>只读写法</strong>: computed(()=&gt;a + b)</li><li id="u784cbcca"><strong>可读可改写法:computed({get:()=&gt;a + b,set:(val)=&gt; {xxxxx}})</strong></li></ol> 
<pre id="qSTec"><code class="language-javascript">&lt;script setup lang="ts"&gt;
import { computed, ref } from 'vue'
const count = ref(0)
const setCount2 = computed({
    get: () =&gt; {
        return count.value + 1
    },
    set: (value) =&gt; {
        count.value = value + 1
    }
})
&lt;/script&gt;
&lt;template&gt;
  &lt;div&gt;{<!-- -->{ count }}&lt;/div&gt;
  &lt;button @click="count++"&gt;
    +1
  &lt;/button&gt;
  &lt;button @click="setCount2++"&gt;
    +3
  &lt;/button&gt;
&lt;/template&gt;
&lt;style lang='less' scoped&gt;&lt;/style&gt;</code></pre> 
<p id="uc02469ec"></p> 
<p class="img-center"><img alt="" height="128" id="u241dba7b" src="https://images2.imgbox.com/d9/95/6TEWZetb_o.png" width="256"></p> 
<p class="img-center"><img alt="" height="126" id="uc54cf1d7" src="https://images2.imgbox.com/59/fa/1mWeEJgl_o.png" width="228"></p> 
<p id="u4399917c"></p> 
<h5 id="Pheob">4.2. watch函数</h5> 
<p id="u858dbfb6">watch函数是用来监听一个响应式对象,或者多个(多个时第一个参数为数数组),当监听对象发生变化时返回一个回调函数</p> 
<pre id="tZEAh"><code class="language-javascript">&lt;script setup lang="ts"&gt;
import { ref } from 'vue'
const count = ref(0)
//监听
watch(count,(newvalue,oldvalue)=&gt;{
    console.log(newvalue)
})
&lt;/script&gt;
&lt;template&gt;
  &lt;div&gt;{<!-- -->{ count }}&lt;/div&gt;
  &lt;button @click="count++"&gt;
    +
  &lt;/button&gt;
&lt;/template&gt;
&lt;style lang='less' scoped&gt;&lt;/style&gt;</code></pre> 
<h5 id="k7qR3">4.3. watchEffect</h5> 
<p id="ue9712386">watchEffect函数用于监听传入的函数内部所有的响应式对象的变化,就是回调里面用了哪个对象就监听哪个对象</p> 
<pre id="dhOGB"><code class="language-javascript">&lt;script setup lang="ts"&gt;
import { ref, watchEffect } from 'vue'
const count = ref(0)
const add = (count:number) =&gt; {
    console.log(count)
}
// 监听
watchEffect(() =&gt; {
    add(count.value)
})
&lt;/script&gt;
&lt;template&gt;
  &lt;div&gt;{<!-- -->{ count }}&lt;/div&gt;
  &lt;button @click="count++"&gt;
    +
  &lt;/button&gt;
&lt;/template&gt;
&lt;style lang='less' scoped&gt;&lt;/style&gt;</code></pre> 
<p id="u8f34f8bc"></p> 
<h4 id="ZILYo">5. 组件通信</h4> 
<p id="u11edda99">vue的组件通信与React不太一样,React因为JSX语法的原因不需要特殊处理,vue的话因为采用的模板语法,所以需要使用一些方法来处理</p> 
<h5 id="Oc4we">5.1. 父子通信</h5> 
<p id="uc2b1b270">在vue3里面传递数据的时候,可以使用<strong>definePorps</strong>来接收父组件传入的props参数:</p> 
<p id="u66508a0d">在父组件使用子组件时,使用props对其传入数据:</p> 
<pre id="EUY2W"><code>  &lt;Child :count="count" /&gt;</code></pre> 
<p id="ud1fe7852">子组件接收:</p> 
<pre id="Mz8Kv"><code class="language-javascript">&lt;script setup lang='ts'&gt;
import { defineProps } from 'vue'
const props = defineProps({
    count: {
        type: Number,
        default: 0
    }
})
&lt;/script&gt;
&lt;template&gt;
  &lt;div&gt;{<!-- -->{ props.count }}&lt;/div&gt;
&lt;/template&gt;</code></pre> 
<p id="u11dc45d9"><strong>注意点:props为只读属性,不可更改,如果需要更改传入的数据,可以在当前组件重新定义一个ref对象</strong></p> 
<h5 id="xJ2zv">5.2. 子父通信</h5> 
<p id="u4465b95a">子组件向父组件发送消息会稍微麻烦一点,毕竟框架数据流通都是基于单向数据流的理念的,所以需要采用额外的方法来处理</p> 
<h6 id="e60oN">5.2.1. 添加回调函数</h6> 
<p id="uf6c55223">通过向子组件发送一个回调函数的方式,直接在子组件调用</p> 
<pre id="id8p3"><code class="language-javascript">&lt;script setup lang="ts"&gt;
import { ref } from 'vue'
import Child from './test.vue'
const count = ref(0)
const add = () =&gt; {
    count.value = count.value + 1
}
&lt;/script&gt;
&lt;template&gt;
  &lt;div /&gt;
  父组件显示:{<!-- -->{ count }}
  &lt;Child
    :count="count"
    :add="add"
  /&gt;
&lt;/template&gt;
&lt;style lang='less' scoped&gt;&lt;/style&gt;</code></pre> 
<p id="uab56e22f">子组件:</p> 
<pre id="nl5A9"><code class="language-javascript">&lt;script setup lang='ts'&gt;
import { defineProps } from 'vue'
const props = defineProps({
    add: {
        type: Function,
        default: () =&gt; {}
    }
})
&lt;/script&gt;
&lt;template&gt;
  &lt;button :onclick="props.add"&gt;
    +
  &lt;/button&gt;
&lt;/template&gt;
&lt;style lang='less' scoped&gt;
&lt;/style&gt;</code></pre> 
<h6 id="mJ64F">5.2.2. provide与inject</h6> 
<p id="ua2aa1dc6">可以实现隔代组件通信</p> 
<p id="u446b80f9">父组件:</p> 
<pre id="RHpD3"><code class="language-javascript">&lt;script setup lang="ts"&gt;
import { ref, provide } from 'vue'
import Child from './test.vue'
const count = ref(0)
provide('Count', count)
&lt;/script&gt;
&lt;template&gt;
  &lt;div /&gt;
  父组件显示:{<!-- -->{ count }}
  &lt;Child
    :count="count"
  /&gt;
&lt;/template&gt;
&lt;style lang='less' scoped&gt;&lt;/style&gt;</code></pre> 
<p id="ud6396c99">子组件:</p> 
<pre id="rvgmw"><code class="language-javascript">&lt;script setup lang='ts'&gt;
import { inject } from 'vue'
const count = inject('Count')
const add = () =&gt; {
    count.value = count.value + 1
}
&lt;/script&gt;
&lt;template&gt;
  &lt;button :onclick="add"&gt;
    +
  &lt;/button&gt;
&lt;/template&gt;
&lt;style lang='less' scoped&gt;
&lt;/style&gt;</code></pre> 
<h6 id="h2rLU">5.2.3. 使用pinia通信</h6> 
<p id="u32f1e142"><strong>安装</strong></p> 
<pre id="KP2LA"><code class="language-javascript">yarn add pinia</code></pre> 
<p id="u6406b342"><strong>创建store</strong></p> 
<pre id="mUzEr"><code class="language-javascript">import { createPinia } from 'pinia'
// 创建store
const store = createPinia()
// 对外暴露,安装仓库
export default store</code></pre> 
<p id="u9252fd8d"><strong>注册</strong></p> 
<pre id="fAJBB"><code class="language-javascript">...
import pinia from './store/pinia'

...

app.use(router)
    .use(Antd)
    .use(store)
+   .use(pinia)
    .mount('#app')</code></pre> 
<p id="uc1f76ae2"><strong>添加models</strong></p> 
<pre id="FFEqZ"><code class="language-javascript">import { defineStore } from 'pinia'
const Store = defineStore('test', {
    state: () =&gt; {
        return {
            count: 0
        }
    },
    actions: {
        add (count:number) {
            this.count = this.count + count
        }
    },
    getters: {

    }
})
export default Store</code></pre> 
<p id="uc290884b"><strong>页面显示</strong></p> 
<pre id="w0rjP"><code class="language-javascript">&lt;script setup lang="ts"&gt;
import infostore from '@/store/piniamodels'
import Child from './test.vue'
const store = infostore()
const add = () =&gt; {
    store.add(1)
}
&lt;/script&gt;
&lt;template&gt;
  父组件显示:{<!-- -->{ store.count }}
  &lt;button :onclick="add"&gt;
    +
  &lt;/button&gt;
  子组件显示:
  &lt;Child /&gt;
&lt;/template&gt;
&lt;style lang='less' scoped&gt;&lt;/style&gt;</code></pre> 
<p id="u79870501">子组件:</p> 
<pre id="QXDkm"><code class="language-javascript">&lt;script setup lang='ts'&gt;
import infostore from '@/store/piniamodels/index'
const store = infostore()
&lt;/script&gt;
&lt;template&gt;
  {<!-- -->{ store.count }}
&lt;/template&gt;
&lt;style lang='less' scoped&gt;
&lt;/style&gt;</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2a70330f352d23d7a235c5f101ac2bb6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">初识JAVA中的包装类，时间复杂度及空间复杂度</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c060429b1942a4f17915e1c21e422806/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何评价GPT-4o?【模板】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>