<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【javaSE】内部类（来自类和对象的补充） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/bd10394c7da441999d3a9b1a75ed20b5/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【javaSE】内部类（来自类和对象的补充）">
  <meta property="og:description" content="❤️❤️前言~🥳🎉🎉🎉 hellohello~，大家好💕💕，这里是E绵绵呀✋✋ ，如果觉得这篇文章还不错的话还请点赞❤️❤️收藏💞 💞 关注💥💥，如果发现这篇文章有问题的话，欢迎各位评论留言指正，大家一起加油！一起chin up！👍👍 💥个人主页：E绵绵的博客
💥所属专栏：JAVASE题目练习 JAVASE知识点专栏 c语言知识点专栏 c语言题目练习
之前我们在讲类和对象时就提到过内部类，不过当时说了等讲完抽象类和接口再讲这个，现在兑现诺言的时候到了，那我们开始内部类的学习吧！
内部类 ❤️❤️内部类是指在一个类的内部定义的另一个类。内部类可以访问外部类的所有成员，包括私有成员。内部类提供了一种封装和组织代码的方式，可以将相关的类和接口放在一起，增加代码的可读性和可维护性。
分为以下四种：
实例（成员）内部类，静态内部类，局部（方法）内部类，匿名内部类。
内部类虽然在外部类里面，但是它编译时内部类会形成单独的字节码文件
实例内部类 ❤️❤️实例内部类的成员变量和成员方法都不能用static修饰。
但存在一个特殊的点：实例内部类中的成员变量也可以用static修饰，只不过那必须加上final修饰使其变为常量才可以用static修饰。
❤️❤️我们要清楚虽然内部类在外部类里面，但实例化外部类并不会同时实例出内部类，所以当实例出外部类后，内部类需要我们主动实例化。
所以实例内部类的实例化需要先创建外部类的实例，然后再通过外部类的实例来创建实例内部类的对象。
例如，如果外部类是Outer，实例内部类是Inner，那么可以通过Outer outer = new Outer(); Outer.Inner inner = outer.new Inner(); 来实例化实例内部类.
当然还有另外一种方式也可以实例化实例内部类：Outer.Inner inner=new Outer().new lnner(); ❤️❤️在实例内部类中我们可以访问外部类的所有成员，包括私有成员。具体细节如下：
1. 🎯🎯当外部类和内部类成员不同名时，我们可以在实例内部类中直接使用外部类的成员变量和成员方法，无需前面还要引用：
在上图中InnerClass是实例内部类，我们在该内部类中直接使用了外部类中的成员变量a，但切记注意这里的a前面不能带this，如果带了this就表示这是内部类中的a，但我们内部类中不存在同名的a，所以报错。不带this直接用a时因为内部类没a所以就表示这是外部类中的a。
成员方法跟成员变量同理。
2. 🎯🎯而当内部类和外部类存在同名的成员变量时，内部类直接使用它时会优先选择自己的成员变量。如下：
此时就因为a同名导致直接使用a时优先选择内部类中的a，所以a和this.a都表示内部类中的a，而如果我们硬要使用外部类中的a时，就可以用 外部类的类名.this.a如OutClass.this.a表示这是外部类的a（注意这是特定的语法规则，我也不知道为什么用这样的格式能表示出外部类）.
成员方法跟成员变量同理
❤️❤️而在外部类中我们不能直接访问实例内部类的成员，需要通过创建实例内部类的对象再引用访问。（这个懂得都懂，就不多讲了）
❤️❤️除此之外，到了其他类中我们用内部类对象引用就只能引用其内部方法和变量（不能引用外部类的）
用外部类对象引用也只能引用其方法和变量（不能引用内部类的）
❤️❤️下面我们再看下文案，防止你们没看懂：
静态内部类 ❤️❤️我们现在说一下静态内部类跟实例内部类不同的点吧：
🎯🎯1.静态内部类可以有静态方法和变量，也可以有实例方法和变量。 🎯🎯2.静态内部类的创建不依赖于外部类的实例对象，可以直接通过外部类名创建。
如 OutClass.InnerClass innerClass = new OutClass.InnerClass();（OutClass为外部类，InnerClass为内部类）。
所以因为静态内部类的创建不需要先创建外部类，我们往往用静态内部类比实例内部类多一点。
🎯🎯3. 静态内部类可以直接访问外部类的静态成员，但不能直接访问外部类的非静态成员。如果需要访问外部类的非静态成员，可以通过在内部类中创建外部类的对象来实现。
如添加OutClass outclass=new OutClass（）；而后将在内部类中且原本来自外部类的实例变量和实例方法前加上outclass. 就可以了。
🎯🎯4. 如果在外部类中创建静态内部类的实例，可以省略外部类名，例如：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-07T10:39:51+08:00">
    <meta property="article:modified_time" content="2024-05-07T10:39:51+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【javaSE】内部类（来自类和对象的补充）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2> <strong> ❤️❤️前言~🥳</strong>🎉🎉🎉</h2> 
<blockquote> 
 <p><strong>hellohello~，大家好💕💕，这里是E绵绵呀✋✋ ，如果觉得这篇文章还不错的话还请点赞❤️❤️收藏💞 💞 关注💥💥，如果发现这篇文章有问题的话，欢迎各位评论留言指正，大家一起加油！一起chin up！👍👍 </strong></p> 
 <p></p> 
 <p><img alt="" height="800" src="https://images2.imgbox.com/26/1a/s7bKaKy0_o.png" width="889"></p> 
 <p></p> 
 <p><strong>💥<span style="color:#956fe7;">个人主页</span>：<a href="https://blog.csdn.net/Easonmax?type=blog" title="E绵绵的博客">E绵绵的博客</a><br> 💥<span style="color:#956fe7;">所属专栏：</span><a href="https://blog.csdn.net/easonmax/category_12611045.html?spm=1001.2014.3001.5482" title="JAVASE题目练习">JAVASE题目练习</a>  <a href="https://blog.csdn.net/easonmax/category_12591491.html" title="JAVASE知识点专栏">JAVASE知识点专栏</a>  <a href="https://blog.csdn.net/easonmax/category_12546237.html" title="c语言知识点专栏">c语言知识点专栏</a><a href="https://blog.csdn.net/easonmax/category_12546244.html" title="   c语言题目练习">   c语言题目练习</a></strong></p> 
</blockquote> 
<p><strong>之前我们在讲类和对象时就提到过内部类，不过当时说了等讲完抽象类和接口再讲这个，现在兑现诺言的时候到了，那我们开始内部类的学习吧！</strong></p> 
<p class="img-center"><img alt="" height="356" src="https://images2.imgbox.com/45/25/JLw5EWdK_o.gif" width="650"></p> 
<h2>内部类 </h2> 
<blockquote> 
 <p><strong>❤️❤️<span style="color:#1c7331;">内部类是指在一个类的内部定义的另一个类。内部类可以访问外部类的所有成员，包括私有成员。内部类提供了一种封装和组织代码的方式，可以将相关的类和接口放在一起，增加代码的可读性和可维护性。</span></strong></p> 
 <p></p> 
 <p><strong>分为以下四种：</strong></p> 
 <p><span style="color:#fe2c24;"><strong>实例（成员）内部类，静态内部类，局部（方法）内部类，匿名内部类。</strong></span></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#1c7331;"><strong>内部类虽然在外部类里面，但是它编译时内部类会形成单独的字节码文件</strong></span></p> 
</blockquote> 
<h2>实例内部类</h2> 
<blockquote> 
 <p><strong>❤️❤️<span style="color:#fe2c24;">实例内部类的成员变量和成员方法都不能用static修饰。</span></strong></p> 
 <p><strong><span style="color:#fe2c24;">但存在一个特殊的点：实例内部类中的成员变量也可以用static修饰，只不过那必须加上final修饰使其变为常量才可以用static修饰。</span></strong></p> 
</blockquote> 
<blockquote> 
 <p> <strong>❤️❤️<span style="color:#fe2c24;">我们要清楚虽然内部类在外部类里面，但实例化外部类并不会同时实例出内部类，所以当实例出外部类后，内部类需要我们主动实例化。</span></strong></p> 
 <p><strong><span style="color:#1c7331;">所以实例内部类的实例化需要先创建外部类的实例，然后再通过外部类的实例来创建实例内部类的对象。</span></strong></p> 
 <p><strong><span style="color:#fe2c24;">例如，如果外部类是Outer，实例内部类是Inner，那么可以通过Outer outer = new Outer(); Outer.Inner inner = outer.new Inner(); 来实例化实例内部类.</span></strong></p> 
 <p><strong><span style="color:#fe2c24;">当然还有另外一种方式也可以实例化实例内部类：Outer.Inner inner=new Outer().new lnner(); </span></strong></p> 
</blockquote> 
<p></p> 
<p></p> 
<blockquote> 
 <p><strong><span style="color:#fe2c24;"> </span>❤️❤️<span style="color:#fe2c24;">在实例内部类中我们可以访问外部类的所有成员，包括私有成员。具体细节如下：</span></strong></p> 
</blockquote> 
<blockquote> 
 <p></p> 
 <p><strong>1.<span style="color:#fe2c24;"> 🎯🎯</span>当外部类和内部类成员不同名时，我们可以在实例内部类中直接使用外部类的成员变量和成员方法，无需前面还要引用：</strong></p> 
 <p class="img-center"><img alt="" height="233" src="https://images2.imgbox.com/5c/d8/gieNaJAY_o.png" width="513"></p> 
 <p><strong><span style="color:#1c7331;"> </span></strong></p> 
 <p><strong><span style="color:#1c7331;">在上图中InnerClass是实例内部类，我们在该内部类中直接使用了外部类中的成员变量a，</span><span style="color:#fe2c24;">但切记注意这里的a前面不能带this，如果带了this就表示这是内部类中的a，但我们内部类中不存在同名的a，所以报错</span><span style="color:#1c7331;">。不带this直接用a时因为内部类没a所以就表示这是外部类中的a。</span></strong></p> 
 <p><strong><span style="color:#fe2c24;">成员方法跟成员变量同理。</span></strong></p> 
</blockquote> 
<blockquote> 
 <p><strong>2.<span style="color:#fe2c24;"> 🎯🎯</span>而当内部类和外部类存在同名的成员变量时，内部类直接使用它时会优先选择自己的成员变量。如下：</strong></p> 
 <p class="img-center"><img alt="" height="144" src="https://images2.imgbox.com/27/19/i7t2AQCG_o.png" width="518"></p> 
 <p><span style="color:#1c7331;"><strong>此时就因为a同名导致直接使用a时优先选择内部类中的a，所以a和this.a都表示内部类中的a，</strong></span><span style="color:#fe2c24;"><strong>而如果我们硬要使用外部类中的a时，就可以用 外部类的类名.this.a如OutClass.this.a</strong></span><span style="color:#fe2c24;"><strong>表示这是外部类的a</strong></span><span style="color:#1c7331;"><strong>（注意这是特定的语法规则，我也不知道为什么用这样的格式能表示出外部类）.</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>成员方法跟成员变量同理</strong></span></p> 
</blockquote> 
<p></p> 
<blockquote> 
 <p><strong>❤️❤️<span style="color:#fe2c24;">而在外部类中我们不能直接访问实例内部类的成员，需要通过创建实例内部类的对象再引用访问。</span>（这个懂得都懂，就不多讲了）</strong></p> 
</blockquote> 
<p></p> 
<blockquote> 
 <p><strong>❤️❤️</strong><span style="color:#1c7331;"><strong>除此之外，到了其他类中我们用内部类对象引用就只能引用其内部方法和变量（不能引用外部类的）</strong></span></p> 
 <p><span style="color:#1c7331;"><strong>用外部类对象引用也只能引用其方法和变量（不能引用内部类的）</strong></span></p> 
</blockquote> 
<blockquote> 
 <p><strong>❤️❤️下面我们再看下文案，防止你们没看懂：</strong></p> 
 <p></p> 
 <p> <img alt="" height="1200" src="https://images2.imgbox.com/f9/45/4z1Htopw_o.png" width="1200"> </p> 
</blockquote> 
<h2 style="background-color:transparent;"><strong>静态内部类</strong></h2> 
<blockquote> 
 <p><strong>❤️❤️</strong><strong>我们现在说一下静态内部类跟实例内部类不同的点吧：</strong></p> 
</blockquote> 
<blockquote> 
 <p>🎯🎯<strong><span style="color:#fe2c24;">1.静态内部类可以有静态方法和变量，也可以有实例方法和变量。 </span></strong></p> 
</blockquote> 
<blockquote> 
 <p>🎯🎯<strong>2.<span style="color:#1c7331;">静态内部类的创建不依赖于外部类的实例对象，可以直接通过外部类名创建。</span></strong></p> 
 <p><strong><span style="color:#fe2c24;">如 OutClass.InnerClass innerClass = new OutClass.InnerClass();（OutClass为外部类，InnerClass为内部类）。</span></strong></p> 
 <p><span style="color:#1c7331;"><strong>所以因为静态内部类的创建不需要先创建外部类，我们往往用静态内部类比实例内部类多一点。</strong></span></p> 
</blockquote> 
<blockquote> 
 <p>🎯🎯<span style="color:#fe2c24;"><strong>3. 静态内部类可以直接访问外部类的静态成员，但不能直接访问外部类的非静态成员。如果需要访问外部类的非静态成员，可以通过在内部类中创建外部类的对象来实现。</strong></span></p> 
 <p><span style="color:#1c7331;"><strong>如添加OutClass  outclass=new  OutClass（）；而后将在内部类中且原本来自外部类的实例变量和实例方法前加上outclass.   就可以了。</strong></span><img alt="" height="952" src="https://images2.imgbox.com/66/1e/LpvgGUSP_o.png" width="1165"></p> 
</blockquote> 
<blockquote> 
 <p>🎯🎯<span style="color:#fe2c24;"><strong>4. 如果在外部类中创建静态内部类的实例，可以省略外部类名，例如：</strong></span></p> 
 <pre><code>class OuterClass {
    static class InnerClass {
        void doSomething() {
            System.out.println("do something");
        }
    }

    static void test1() {
        InnerClass inner = new InnerClass();
        inner.doSomething();
    }

     void test2() {
        InnerClass inner = new InnerClass();
        inner.doSomething();
    }
}</code></pre> 
 <p><strong>但是在其他类中我们必须直接使用外部类名和内部类名来创建内部类的实例，否则会报错。例如：</strong></p> 
 <pre><code>OuterClass.InnerClass inner = new OuterClass.InnerClass();</code></pre> 
</blockquote> 
<blockquote> 
 <p><strong>❤️❤️所以这就是静态内部类跟实例内部类的不同，其他的它们两基本都相同，所以我们了解了这些不同点就可以了。</strong></p> 
</blockquote> 
<h2>局部内部类 </h2> 
<blockquote> 
 <p><strong>❤️❤️<span style="color:#fe2c24;">定义在外部类的方法体中，该种内部类只能在其定义的位置使用，一般使用的非常少，此处简单了解下语法格式。不过多了解。</span></strong></p> 
 <p><img alt="" height="750" src="https://images2.imgbox.com/96/2a/SCshL8sc_o.png" width="823"></p> 
 <p><strong>所以对于局部内部类它只能在外部类的某个方法体内使用，使用性很有限。</strong></p> 
</blockquote> 
<blockquote> 
 <p><strong><span style="color:#1c7331;">❤️❤️【注意事项】</span></strong></p> 
 <p><strong><span style="color:#1c7331;">1. 局部内部类只能在所定义的方法体内部使用 </span></strong></p> 
 <p><strong><span style="color:#1c7331;">2. 不能被public、static等修饰符修饰 </span></strong></p> 
 <p><strong><span style="color:#1c7331;">3. 编译器也有自己独立的字节码文件，命名格式：外部类名字$数字内部类名字.class </span></strong></p> 
 <p><span style="color:#fe2c24;"><strong>4. 几乎不会使用，所以我们不必过多了解  </strong></span></p> 
</blockquote> 
<h2> 匿名内部类</h2> 
<blockquote> 
 <p>🎯🎯<strong>匿名内部类是指在使用时才定义并同时实例化的内部类，<span style="color:#fe2c24;">没有显式的类名</span>。其语法格式如下：</strong></p> 
 <pre><code>​
接口 类名 = new 接口() {
    // 匿名内部类的成员变量和方法
};

​</code></pre> 
 <p><span style="color:#1c7331;"><strong>注意实施该接口的类被隐藏了，没有显示出来（以及implements也没显示出来），我们new是对隐藏的该类进行实例化。对于该种格式它是特有的，所以我们只需要记住就行。</strong></span></p> 
 <p></p> 
 <p><strong>下面直接看匿名内部类的使用：</strong></p> 
 <pre><code>public class Main {
    public static void main(String[] args) {
        // 创建一个接口对象，并实现其方法
        MyInterface myInterface = new MyInterface() {
            @Override
            public void doSomething() {
                System.out.println("匿名内部类实现的方法");
            }
        };
        
        // 调用接口方法
        myInterface.doSomething();
    }
}

// 定义一个接口
interface MyInterface {
    void doSomething();
}</code></pre> 
 <p><strong>所以这就是匿名内部类的使用，之后当学到线程时我们会经常接触这种语法的。</strong></p> 
</blockquote> 
<p></p> 
<h2>总结 </h2> 
<blockquote> 
 <p><strong>所以我们内部类就结束啦，内部类结束我们的类与对象才算真正的结束。之后将给大家把之前学的知识点总结起来写一个小项目。<span style="color:#fe2c24;">还请各位铁汁们给作者点一个小小的关注，评评论呀，感谢各位大佬~❤️❤️🥳🎉🎉🎉！</span></strong></p> 
</blockquote> 
<p class="img-center"><img alt="" height="430" src="https://images2.imgbox.com/8f/5c/RICOCaCs_o.gif" width="600"></p> 
<p style="text-align:center;"></p> 
<p style="text-align:center;"><span style="color:#1c7331;"><strong>下面是一个推荐，有兴趣的大佬们可以来腾讯云入驻，超多福利方式也很简单，快来加入吧。</strong></span></p> 
<p class="img-center"><img alt="" height="1200" src="https://images2.imgbox.com/f3/32/vkm9Xh26_o.jpg" width="380"></p> 
<p>          <span style="color:#fe2c24;"><strong>我的博客即将同步至腾讯云开发者社区，邀请大家一同入驻：https://cloud.tencent.com/developer/support-plan?invite_code=csh4tocaxqx1</strong></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/81efee50a3ea4de5cb52e35d12cc6403/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">LocalAi，Ollama&#43;AnythingLLM搭建部署本地大模型AI知识库，汉化版本</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6cd84977d0de31e7924019894600cb5c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Linux网络编程】高级IO——五种IO模型</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>