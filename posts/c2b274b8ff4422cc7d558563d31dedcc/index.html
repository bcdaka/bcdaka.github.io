<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言：数据结构（双向链表） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/c2b274b8ff4422cc7d558563d31dedcc/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C语言：数据结构（双向链表）">
  <meta property="og:description" content="目录 1、双向链表的结构2、顺序表和双向链表的优缺点分析3、双向链表的实现 1、双向链表的结构 注意：这⾥的“带头“跟前面我们说的“头节点”是两个概念，实际前面的在单链表阶段称呼不严谨，但是为了更好的理解就直接称为单链表的头节点。
带头链表里的头节点，实际为“放哨的”，哨兵位节点不存储任何有效元素，只是站在这里“放哨的”。
“哨兵位”存在的意义：遍历循环链表避免死循环。
2、顺序表和双向链表的优缺点分析 不同点顺序表链表存储空间上物理上一定连续逻辑上连续，但物理上不一定连续随机访问支持O(1)不支持O(N)任意位置插⼊或者删除元素可能需要搬移元素，效率低只需修改指针指向插入动态顺序表，空间不够时需要扩容没有容量的概念应用场景元素高效存储和频繁访问任意位置频繁插入和删除 3、双向链表的实现 ListNode.h
#pragma once #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;assert.h&gt; //定义双向链表节点的结构 typedef int Ltdatatype; typedef struct ListNode { Ltdatatype data; struct ListNode* prev;//指向前一个节点的指针 struct ListNode* next;//指向后一个节点的指针 }ListNode; //双向链表的初始化 ListNode* LtInit(); //尾插 //不改变哨兵位的地址，所以传一级即可 void LtPushBack(ListNode* phead, Ltdatatype x);//插入数据之前，链表必须初始化到只有一个头结点的情况 //打印链表 void LtPrint(ListNode* phead); //头插 void LtPushFront(ListNode* phead, Ltdatatype x); //尾删 LtPopBack(ListNode* phead); //头删 LtPopFront(ListNode* phead); //查找 ListNode* LtFind(ListNode* phead, Ltdatatype x); //指定位置前插入 void LtInsert(ListNode* pos, Ltdatatype x); //删除pos位置 void LtErase(ListNode* pos); //销毁链表 void LtDestroy(ListNode* phead); ListNode.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-28T12:25:42+08:00">
    <meta property="article:modified_time" content="2024-04-28T12:25:42+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言：数据结构（双向链表）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#1_1" rel="nofollow">1、双向链表的结构</a></li><li><a href="#2_6" rel="nofollow">2、顺序表和双向链表的优缺点分析</a></li><li><a href="#3_40" rel="nofollow">3、双向链表的实现</a></li></ul> 
</div> 
<p></p> 
<h2><a id="1_1"></a>1、双向链表的结构</h2> 
<p><img src="https://images2.imgbox.com/4e/50/agSwhKAA_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><font color="red"><strong>注意：</strong></font>这⾥的“带头“跟前面我们说的“头节点”是两个概念，实际前面的在单链表阶段称呼不严谨，但是为了更好的理解就直接称为单链表的头节点。<br> 带头链表里的头节点，实际为“放哨的”，哨兵位节点不存储任何有效元素，只是站在这里“放哨的”。<br> “哨兵位”存在的意义：遍历循环链表避免死循环。</p> 
</blockquote> 
<h2><a id="2_6"></a>2、顺序表和双向链表的优缺点分析</h2> 
<table><tbody><tr><td align="left"><b>不同点</b></td><td align="left"><b>顺序表</b></td><td align="left"><b>链表</b></td></tr><tr><td align="left">存储空间上</td><td align="left">物理上一定连续</td><td align="left">逻辑上连续，但物理上不一定连续</td></tr><tr><td align="left">随机访问</td><td align="left">支持O(1)</td><td align="left">不支持O(N)</td></tr><tr><td align="left">任意位置插⼊或者删除元素</td><td align="left">可能需要搬移元素，效率低</td><td align="left">只需修改指针指向</td></tr><tr><td align="left">插入</td><td align="left">动态顺序表，空间不够时需要扩容</td><td align="left">没有容量的概念</td></tr><tr><td align="left">应用场景</td><td align="left">元素高效存储和频繁访问</td><td align="left">任意位置频繁插入和删除</td></tr></tbody></table> 
<h2><a id="3_40"></a>3、双向链表的实现</h2> 
<p><strong><code>ListNode.h</code></strong></p> 
<pre><code>#pragma once
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
//定义双向链表节点的结构
typedef int Ltdatatype;
typedef struct ListNode
{
	Ltdatatype data;
	struct ListNode* prev;//指向前一个节点的指针
	struct ListNode* next;//指向后一个节点的指针
}ListNode;
//双向链表的初始化
ListNode* LtInit();
//尾插
//不改变哨兵位的地址，所以传一级即可
void LtPushBack(ListNode* phead, Ltdatatype x);//插入数据之前，链表必须初始化到只有一个头结点的情况
//打印链表
void LtPrint(ListNode* phead);
//头插
void LtPushFront(ListNode* phead, Ltdatatype x);
//尾删
LtPopBack(ListNode* phead);
//头删
LtPopFront(ListNode* phead);
//查找
ListNode* LtFind(ListNode* phead, Ltdatatype x);
//指定位置前插入
void LtInsert(ListNode* pos, Ltdatatype x);
//删除pos位置
void LtErase(ListNode* pos);
//销毁链表
void LtDestroy(ListNode* phead);
</code></pre> 
<p><strong><code>ListNode.c</code></strong></p> 
<pre><code>#define _CRT_SECURE_NO_WARNINGS
#include "ListNode.h"
//申请节点
ListNode* LtBuyNode(Ltdatatype x)
{
	ListNode* node = (ListNode*)malloc(sizeof(ListNode));
	if (node == NULL)
	{
		perror("malloc fail");
		exit(1);
	}
	//申请成功
	node-&gt;data = x;
	node-&gt;next = node-&gt;prev = node;
	return node;
}
//双向链表的初始化
ListNode* LtInit()
{
	ListNode*phead = LtBuyNode(-1);
	return phead;
}
//尾插
void LtPushBack(ListNode* phead, Ltdatatype x)
{
	assert(phead);
	ListNode* newnode = LtBuyNode(x);
	//改变新节点的指向
	newnode-&gt;prev = phead-&gt;prev;
	newnode-&gt;next = phead;
	//改变尾节点和哨兵位的指向
	phead-&gt;prev-&gt;next = newnode;
	phead-&gt;prev = newnode;
}
//打印链表
void LtPrint(ListNode* phead)
{
	ListNode* pcur = phead-&gt;next;
	//遍历链表
	while (pcur != phead)
	{
		printf("%d-&gt;", pcur-&gt;data);
		pcur = pcur-&gt;next;
	}
	printf("\n");
}
//头插
void LtPushFront(ListNode* phead,Ltdatatype x)
{
	assert(phead);
	ListNode* newnode = LtBuyNode(x);
	newnode-&gt;prev = phead;
	newnode-&gt;next = phead-&gt;next;
	//修改哨兵位和第一个有效节点的指向
	phead-&gt;next-&gt;prev = newnode;
	phead-&gt;next = newnode;
}
//尾删
LtPopBack(ListNode* phead)
{
	//链表必须有效且链表不能为空（只有一个哨兵位）
	assert(phead &amp;&amp; phead-&gt;next != phead);
	ListNode* Del = phead-&gt;prev;//尾节点
	ListNode* DelPrev = Del-&gt;prev;//尾节点的前一个节点
	phead-&gt;prev = DelPrev;
	DelPrev-&gt;next = phead;
	free(Del);//删除Del节点
	Del = NULL;
}
//头删
LtPopFront(ListNode* phead)
{
	//判断链表是否有效和链表是否为空
	assert(phead &amp;&amp; phead-&gt;next != phead);
	ListNode* Del = phead-&gt;next;//第一个有效节点
	ListNode* DelNext = Del-&gt;next;//有效节点的下一个节点
	phead-&gt;next = DelNext;
	DelNext-&gt;prev = phead;
	free(Del);//删除Del节点
	Del = NULL;
}
//查找
ListNode* LtFind(ListNode* phead, Ltdatatype x)
{
	ListNode* pcur = phead-&gt;next;
	//遍历链表
	while (pcur != phead)
	{
		if (pcur-&gt;data == x)
			return pcur;
		pcur = pcur-&gt;next;//继续让pcur往下遍历
	}
	return NULL;//没有找到
}
//在pos位置之前插入数据
void LtInsert(ListNode* pos,Ltdatatype x)
{
	ListNode* newnode = LtBuyNode(x);
	newnode-&gt;prev = pos-&gt;prev;
	newnode-&gt;next = pos;
	pos-&gt;prev-&gt;next = newnode;
	pos-&gt;prev = newnode;
}
//删除pos位置
void LtErase(ListNode* pos)
{
	assert(pos);
	ListNode* PosPrev = pos-&gt;prev;//pos的前一个节点
	ListNode* PosNext = pos-&gt;next;//pos的后一个节点
	PosPrev-&gt;next = PosNext;
	PosNext-&gt;prev = PosPrev;
	free(pos);
	//pos = NULL;这里就算置空了，也不会影响实参
}
//销毁链表
void LtDestroy(ListNode* phead)
{
	ListNode* pcur = phead-&gt;next;
	//边遍历边释放节点
	while (pcur != phead)
	{
		ListNode* Next = pcur-&gt;next;//保存要释放掉节点的下一个地址
		free(pcur);
		pcur = Next;
	}
	//此时pcur指向phead，而phead还没有被销毁
	free(phead);
	pcur = NULL;
}
</code></pre> 
<p><strong><code>text.c</code></strong></p> 
<pre><code>#define _CRT_SECURE_NO_WARNINGS
#include "ListNode.h"
void LtnodeTest()
{
	//测试初始化
	ListNode* plist = LtInit();
	//测试尾插
	LtPushBack(plist,1);
	LtPushBack(plist,2);
	LtPushBack(plist,3);
	//测试打印
	LtPrint(plist);
	//测试头插
	//LtPushFront(plist,4);
	//LtPushFront(plist,5);
	//LtPushFront(plist,6);
	//LtPrint(plist);
	//测试尾删
	LtPopBack(plist);
	LtPrint(plist);
	//测试头删
	//LtPopFront(plist);
	//LtPrint(plist);
	//测试查找
	//ListNode*find = LtFind(plist,2);
	//if (find)
	//	printf("找到了！\n");
	//else
	//	printf("没找到！\n");
	//测试在pos位置之前插入数据
	//LtInsert(find,88);
	//LtPrint(plist);
	//测试删除pos位置
	//LtErase(find);
	//find = NULL;//形参的改变不会影响实参，所以要在函数调用结束之后置为空
	//LtPrint(plist);
	//测试销毁链表
	//LtDestroy(plist);
	//plist = NULL;
}
int main()
{
	LtnodeTest();
	return 0;
}
</code></pre> 
<hr> 
<p>如果对你有所帮助的话，别忘了一键三连哟，谢谢宝子们😘！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6b092e3a45196a0dc190a13cfe4db9e7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux系统安装Redis7（详细版）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/674ba46c903045d74a924113df90ad85/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C#实现 IDbConnection / IDbCommand 等相关通用数据接口</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>