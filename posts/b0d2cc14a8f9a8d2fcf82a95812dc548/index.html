<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【MySQL】复合查询&#43;表的内外连接 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b0d2cc14a8f9a8d2fcf82a95812dc548/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【MySQL】复合查询&#43;表的内外连接">
  <meta property="og:description" content="复合查询&#43;表的内外连接 1.基本查询回顾2.多表查询3.自连接4.子查询4.1单列子查询4.2多列子查询 5.在from子句中使用子查询6.合并查询7.表的内连和外连7.1内连接7.2外连接7.2.1左外连接 7.2.2右外连接 点赞👍👍收藏🌟🌟关注💖💖
你的支持是对我最大的鼓励，我们一起努力吧!😃😃
前面我们讲解的mysql表的查询都是对一张表进行查询，在实际开发中这远远不够，未来可能还有多表查询，子查询。
1.基本查询回顾 查询工资高于500或岗位为MANAGER的雇员，同时还要满足他们的姓名首字母为大写的J
下面有两种写法，都没问题
select * from emp where (sal&gt;500 or job=&#39;MANAGER&#39;) and ename like &#39;J%&#39;; select * from emp where (sal&gt;500 or job=&#39;MANAGER&#39;) and &#39;J&#39;=substring(ename,1,1); 按照部门号升序而雇员的工资降序排序
select * from emp order by deptno asc,sal desc; 使用年薪进行降序排序
我们看到这个表奖金这一列有的是有的，有的是没有的为null，年薪=月薪*12&#43;奖金
，但是null不参与运算，我们前面刚学的ifnull函数这个时候就可以用上了
ifnull(val1，val2)，如果val1为null，返回val2，否则返回val1的值
select ename,sal*12&#43;ifnull(comm,0) 年薪 from emp order by 年薪 desc; 显示工资最高的员工的名字和工作岗位
最高工资我们可以使用聚合函数做统计，但是聚合函数只是对一列的相同数据做聚合，今天还要有名字，所以单纯的做聚合是无法满足需求的，它只能最高工资是多少。名字和工作岗位显示不出来。
因此我们先找最高工资是多少。然后拿着这个最高工资去把这个人和工作岗位找到。很显然这是两句select。
但是这样写太挫了。怎么办呢，想办法把两个select查询语句合在一块写。
sql允许在一条sql内部在执行select查询，这称为子查询，先执行内部的sql然后在执行外部的sql
select ename,job,sal from emp where sal=(select max(sal) from emp); 显示工资高于平均工资的员工信息">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-11T09:48:47+08:00">
    <meta property="article:modified_time" content="2024-06-11T09:48:47+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【MySQL】复合查询&#43;表的内外连接</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>复合查询+表的内外连接</h4> 
 <ul><li><a href="#1_9" rel="nofollow">1.基本查询回顾</a></li><li><a href="#2_97" rel="nofollow">2.多表查询</a></li><li><a href="#3_147" rel="nofollow">3.自连接</a></li><li><a href="#4_187" rel="nofollow">4.子查询</a></li><li><ul><li><a href="#41_193" rel="nofollow">4.1单列子查询</a></li><li><a href="#42_271" rel="nofollow">4.2多列子查询</a></li></ul> 
  </li><li><a href="#5from_290" rel="nofollow">5.在from子句中使用子查询</a></li><li><a href="#6_384" rel="nofollow">6.合并查询</a></li><li><a href="#7_411" rel="nofollow">7.表的内连和外连</a></li><li><ul><li><a href="#71_413" rel="nofollow">7.1内连接</a></li><li><a href="#72_438" rel="nofollow">7.2外连接</a></li><li><ul><li><a href="#721_440" rel="nofollow">7.2.1左外连接</a></li></ul> 
   </li><li><a href="#722_463" rel="nofollow">7.2.2右外连接</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<p><img src="https://images2.imgbox.com/ee/eb/GGO7VG9Y_o.jpg" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>点赞</strong>👍👍<strong>收藏</strong>🌟🌟<strong>关注</strong>💖💖<br> <font color="red"><strong>你的支持是对我最大的鼓励，我们一起努力吧!😃😃</strong></font></p> 
</blockquote> 
<p>前面我们讲解的mysql表的查询都是对一张表进行查询，在实际开发中这远远不够，未来可能还有多表查询，子查询。</p> 
<h2><a id="1_9"></a>1.基本查询回顾</h2> 
<p><strong>查询工资高于500或岗位为MANAGER的雇员，同时还要满足他们的姓名首字母为大写的J</strong></p> 
<p>下面有两种写法，都没问题</p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp where <span class="token punctuation">(</span><span class="token function">sal</span>&gt;500 or job=<span class="token string">'MANAGER'</span><span class="token punctuation">)</span> and ename like <span class="token string">'J%'</span><span class="token punctuation">;</span>

<span class="token function">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp where <span class="token punctuation">(</span><span class="token function">sal</span>&gt;500 or job=<span class="token string">'MANAGER'</span><span class="token punctuation">)</span> and <span class="token string">'J'</span>=substring<span class="token punctuation">(</span>ename<span class="token punctuation">,</span>1<span class="token punctuation">,</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/41/c2/VKaVaVSS_o.png" alt="在这里插入图片描述"></p> 
<p><strong>按照部门号升序而雇员的工资降序排序</strong></p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp order by deptno asc<span class="token punctuation">,</span><span class="token function">sal</span> desc<span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/bc/06/AVvnPKbP_o.png" alt="在这里插入图片描述"></p> 
<p><strong>使用年薪进行降序排序</strong></p> 
<p>我们看到这个表奖金这一列有的是有的，有的是没有的为null，年薪=月薪*12+奖金<br> ，但是null不参与运算，我们前面刚学的ifnull函数这个时候就可以用上了</p> 
<p><img src="https://images2.imgbox.com/1c/69/RIk55OoB_o.png" alt="在这里插入图片描述"></p> 
<p>ifnull(val1，val2)，如果val1为null，返回val2，否则返回val1的值</p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> ename<span class="token punctuation">,</span><span class="token function">sal</span><span class="token operator">*</span>12+ifnull<span class="token punctuation">(</span>comm<span class="token punctuation">,</span>0<span class="token punctuation">)</span> 年薪 <span class="token keyword">from</span> emp order by 年薪 desc<span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/60/3a/CFqDPzlT_o.png" alt="在这里插入图片描述"></p> 
<p><strong>显示工资最高的员工的名字和工作岗位</strong><br> 最高工资我们可以使用聚合函数做统计，但是聚合函数只是对一列的相同数据做聚合，今天还要有名字，所以单纯的做聚合是无法满足需求的，它只能最高工资是多少。名字和工作岗位显示不出来。</p> 
<p>因此我们先找最高工资是多少。然后拿着这个最高工资去把这个人和工作岗位找到。很显然这是两句select。</p> 
<p><img src="https://images2.imgbox.com/b0/3e/Ab2WbkTT_o.png" alt="在这里插入图片描述"></p> 
<p>但是这样写太挫了。怎么办呢，想办法把两个select查询语句合在一块写。<br> sql允许在一条sql内部在执行select查询，这称为<strong>子查询</strong>，<strong>先执行内部的sql然后在执行外部的sql</strong></p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> ename<span class="token punctuation">,</span>job<span class="token punctuation">,</span><span class="token function">sal</span> <span class="token keyword">from</span> emp where <span class="token function">sal</span>=<span class="token punctuation">(</span><span class="token function">select</span> max<span class="token punctuation">(</span><span class="token function">sal</span><span class="token punctuation">)</span> <span class="token keyword">from</span> emp<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/6a/8f/xNMtPvcK_o.png" alt="在这里插入图片描述"></p> 
<p><strong>显示工资高于平均工资的员工信息</strong></p> 
<p>还是要先使用聚合函数把平均工资找到，然后在找到工资高于平均工资的员工。因此还可以使用子查询。</p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp where <span class="token function">sal</span>&gt;<span class="token punctuation">(</span><span class="token function">select</span> avg<span class="token punctuation">(</span><span class="token function">sal</span><span class="token punctuation">)</span> <span class="token keyword">from</span> emp<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/f7/72/N7NKjgmH_o.png" alt="在这里插入图片描述"></p> 
<p><strong>显示每个部门的平均工资和最高工资</strong></p> 
<p>首先是对部门分组，分组就是分表，表分好之后一个表内部门号是相同的，然后就是在每张表中找每个部门的平均工资和最高工资。其实在子表和在一个整表内找是一样的。在我看来不管是整表还是子表其实都是在表内查询。</p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> deptno<span class="token punctuation">,</span>max<span class="token punctuation">(</span><span class="token function">sal</span><span class="token punctuation">)</span> 最高<span class="token punctuation">,</span>avg<span class="token punctuation">(</span><span class="token function">sal</span><span class="token punctuation">)</span> 平均 <span class="token keyword">from</span> emp <span class="token function">group</span> by deptno<span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/c2/cb/tkYaZcmN_o.png" alt="在这里插入图片描述"></p> 
<p><strong>显示平均工资低于2000的部门号和它的平均工资</strong></p> 
<p>这里要的是平均工资低于2000的部门号，因此要按照部门号分组，统计出每个部分的平均工资，然后在筛选出低于2000的部门号和平均工资</p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> deptno<span class="token punctuation">,</span>avg<span class="token punctuation">(</span><span class="token function">sal</span><span class="token punctuation">)</span> myavg <span class="token keyword">from</span> emp <span class="token function">group</span> by deptno having myavg&lt;2000<span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/c6/2e/g7uf6XPm_o.png" alt="在这里插入图片描述"></p> 
<p><strong>显示每种岗位的雇员总数，平均工资</strong></p> 
<p>这个不就是对岗位分组，然后在统计每个岗位的人数和平均工资</p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> job<span class="token punctuation">,</span>count<span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span>avg<span class="token punctuation">(</span><span class="token function">sal</span><span class="token punctuation">)</span> <span class="token keyword">from</span> emp <span class="token function">group</span> by job<span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/43/41/N5omSgcD_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="2_97"></a>2.多表查询</h2> 
<p>以前我们都是从一张表拿数据，但是实际开发中往往数据来自不同的表，所以需要多表查询。</p> 
<p><strong>显示雇员名、雇员工资以及所在部门的名字</strong></p> 
<p><img src="https://images2.imgbox.com/86/02/x6KoduQ2_o.png" alt="在这里插入图片描述"><br> 我们发现上面emp表中是没有部门名称的，换句话说要的数据是从两张表来的。<br> 员工名和员工工资来自于emp表，部门名称来来自于dept表，<strong>因此注定了我们要将两个表做整合然后在查询。</strong></p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp<span class="token punctuation">,</span>dept<span class="token punctuation">;</span>
</code></pre> 
<p>可以看到形成了一张大表，仔细观察一下，将两张表信息做整合的时候，就光SMITH这一条消息就和整个dept表做组合形成了更多的记录，发现下面都是这样的。</p> 
<p><img src="https://images2.imgbox.com/f7/d6/qmSf5muv_o.png" alt="在这里插入图片描述"></p> 
<p>我们可以看到如果今天对两张表的信息做组合，<strong>新形成表本质是将两张表中数据进行穷举组合的结果。我们把它称之为笛卡尔积。</strong></p> 
<p><strong>在我们看来这不就是把两张表变成了一张表吗。所以未来在做数据的查找的时候，不就还是相当于单表的查找吗！然后就可以按照条件筛选出想要的信息。注意穷举是把所有组合结果都放在一起了，但是有些信息是有无意义的，因此可以先去除无意义的信息(不过还是看具体情况在决定是否保留)，然后在按条件查找。</strong></p> 
<p>去除无效信息</p> 
<p><img src="https://images2.imgbox.com/03/8d/GcUJ15XA_o.png" alt="在这里插入图片描述"></p> 
<p>在按条件筛选</p> 
<p><img src="https://images2.imgbox.com/b5/b6/mzdXYTz1_o.png" alt="在这里插入图片描述"><br> 在我们看来mysql一切皆表，换句话说这里做笛卡尔积之后，它形成的组合结果也是表结构，然后按照条件筛选<br> <img src="https://images2.imgbox.com/d0/62/niyN5v7O_o.png" alt="在这里插入图片描述"></p> 
<p><strong>显示部门号为10的部门名，员工名和工资</strong></p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> ename<span class="token punctuation">,</span><span class="token function">sal</span><span class="token punctuation">,</span>emp<span class="token punctuation">.</span>deptno<span class="token punctuation">,</span>dept<span class="token punctuation">.</span>dname <span class="token keyword">from</span> emp<span class="token punctuation">,</span>dept where emp<span class="token punctuation">.</span>deptno=dept<span class="token punctuation">.</span>deptno<span class="token punctuation">;</span>
</code></pre> 
<p><strong>注意，如果指定的字段是这个表中是唯一的字段，不用指定表名直接显示即可，如果不是这个表中唯一的字段就需要指定表名显示，用来区分要显示是那个表的字段。</strong></p> 
<p><img src="https://images2.imgbox.com/92/c5/KGdDXztx_o.png" alt="在这里插入图片描述"></p> 
<p><strong>显示各个员工的姓名，工资，及工资级别</strong><br> emp表中有员工的姓名和工资，工资级别在工资表里的，因此也还要将两个表笛卡尔积。</p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> ename<span class="token punctuation">,</span><span class="token function">sal</span><span class="token punctuation">,</span>grade <span class="token keyword">from</span> emp t1<span class="token punctuation">,</span>salgrade t2 where t1<span class="token punctuation">.</span><span class="token function">sal</span> between t2<span class="token punctuation">.</span>losal and t2<span class="token punctuation">.</span>hisal<span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/17/47/r145bynA_o.png" alt="在这里插入图片描述"></p> 
<p>上面我们是将两个不同的表做笛卡尔积，那可不可以把同一张表做笛卡尔积呢？</p> 
<h2><a id="3_147"></a>3.自连接</h2> 
<p>自连接是指同一张表做笛卡尔积。</p> 
<p>我们发现直接把同一张表做笛卡尔积是不行的。主要原因这是同一张表这样不太好，字段名有重复不知道用的是那个表的字段名。</p> 
<p><img src="https://images2.imgbox.com/31/0a/KpKW2lHP_o.png" alt="在这里插入图片描述"></p> 
<p>因此我们可以给<strong>两个表做重命名</strong>。</p> 
<p><strong>重命名也可以对表进行重命名，一旦对表进行重命名之后几乎可以在这条sql语句任何地方出现。因为sql语句执行一定是先告诉是从那个表拿数据。</strong></p> 
<p><img src="https://images2.imgbox.com/a5/e6/RN1jbtLP_o.png" alt="在这里插入图片描述"></p> 
<p>我们看到同一个表也是拿着前面的表每一条记录去和后面的表中所有记录做组合。所以哪怕是同一张表也可以做笛卡尔积，只不过是对表名重新命名一下即可。</p> 
<p><strong>显示员工FORD的上级领导的编号和姓名（mgr是员工领导的编号–empno）</strong></p> 
<p><img src="https://images2.imgbox.com/bc/08/OBNd0q5g_o.png" alt="在这里插入图片描述"></p> 
<p>我们首先会想到把这个人的领导编号拿到，然后根据这个编号在去找这个人拿到他的信息。两条select查询语句，但是我们可以把两个整和成一条sql语句</p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> empno<span class="token punctuation">,</span>ename <span class="token keyword">from</span> emp where empno=<span class="token punctuation">(</span><span class="token function">select</span> mgr <span class="token keyword">from</span> emp where ename=<span class="token string">'FORD'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/48/03/1rInzGxf_o.png" alt="在这里插入图片描述"></p> 
<p>还有一种做法，我们发现 先找到FORD的领导编是要从 <strong>EMP</strong> 表中找，然后根据领导编号找领导信息也是要从 <strong>EMP</strong> 表中找。 因此我们可以把同一张表自连接然后再找。</p> 
<p><img src="https://images2.imgbox.com/34/36/TisrTzKE_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> t2<span class="token punctuation">.</span>empno<span class="token punctuation">,</span>t2<span class="token punctuation">.</span>ename <span class="token keyword">from</span> emp t1<span class="token punctuation">,</span>emp t2 where t1<span class="token punctuation">.</span>mgr=t2<span class="token punctuation">.</span>empno and t1<span class="token punctuation">.</span>ename=<span class="token string">'FORD'</span><span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/89/30/fjCAkZP5_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="4_187"></a>4.子查询</h2> 
<p>在之前编写的时候，子查询我们也写了一些。现在我们正式来说一下子查询的概念。除了刚才的笛卡尔积是一种整合表的做法，子查询也是多表查询或者一张表中复杂查询时常用的做法。</p> 
<p><strong>子查询是指嵌入在其他sql语句中的select语句，也叫嵌套查询</strong><br> 一般我们在子查询时依赖的永远都是子查询查出来的结果，根据结果我们可以把子查询划分为单列单行子查询、单例多行子查询、多列单行子查询、多列多行子查询。</p> 
<h3><a id="41_193"></a>4.1单列子查询</h3> 
<blockquote> 
 <p><strong>单例单行子查询</strong></p> 
</blockquote> 
<p><strong>显示SMITH同一部门的员工</strong></p> 
<p>首先会执行子查询将SMITH的部门号查出来，然后充当外面select的筛选条件。</p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp where deptno=<span class="token punctuation">(</span><span class="token function">select</span> deptno <span class="token keyword">from</span> emp where ename=<span class="token string">'SMITH'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>子查询筛选出来的是单列单行的信息。</p> 
<p><img src="https://images2.imgbox.com/91/90/ayQ0KC3d_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>单列多行子查询</strong></p> 
</blockquote> 
<p>子查询筛选出来的是单例多行的信息。</p> 
<p><font color="red"><strong>in关键字</strong></font> <strong>判断一个列值是否在集合中。</strong><br> <strong>查询和10号部门的工作岗位相同的雇员的名字，岗位，工资，部门号，但是不包含10自己的</strong></p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> ename<span class="token punctuation">,</span>job<span class="token punctuation">,</span><span class="token function">sal</span><span class="token punctuation">,</span>deptno <span class="token keyword">from</span> emp where job in<span class="token punctuation">(</span><span class="token function">select</span> job <span class="token keyword">from</span> emp where deptno<span class="token punctuation">)</span> and deptno&lt;&gt;10<span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/82/12/kHhctlQD_o.png" alt="在这里插入图片描述"></p> 
<p><strong>查询和10号部门的工作岗位相同的雇员的名字，岗位，工资，部门号，但是不包含10自己的，并且知道对应的员工属于哪一个部门的名字</strong></p> 
<p>还想要名字怎么办呢，但是emp里面并没有部门名字，只有dept表里面有。结合刚才所学，我们可以进行多表查询。首先确定一定要用的是dept表，还有一张表用谁呢？刚才我们不是已经得到一张表了。所以就把dept表和刚才的表做笛卡尔积。</p> 
<p>子查询不仅可以在where充当筛选条件，还可以在from中，先用下面在解释。</p> 
<p><img src="https://images2.imgbox.com/22/4a/UITdLdOx_o.png" alt="在这里插入图片描述"></p> 
<p>然后去除不对的信息，就得到我们要的数据了</p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> ename<span class="token punctuation">,</span>job<span class="token punctuation">,</span><span class="token function">sal</span><span class="token punctuation">,</span>tmp<span class="token punctuation">.</span>deptno<span class="token punctuation">,</span>dname <span class="token keyword">from</span> <span class="token punctuation">(</span><span class="token function">select</span> ename<span class="token punctuation">,</span>job<span class="token punctuation">,</span><span class="token function">sal</span><span class="token punctuation">,</span>deptno <span class="token keyword">from</span> emp where job in<span class="token punctuation">(</span><span class="token function">select</span> job <span class="token keyword">from</span> emp where deptno=10<span class="token punctuation">)</span> and deptno&lt;&gt;10<span class="token punctuation">)</span> as tmp<span class="token punctuation">,</span>dept where tmp<span class="token punctuation">.</span>deptno=dept<span class="token punctuation">.</span>deptno<span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/17/0c/Fz0TAMOQ_o.png" alt="在这里插入图片描述"></p> 
<p>我们不仅仅用子查询把要的结果筛选出来，我想说的是，<font color="red"><strong>一个SQL整体的查询结果本身就是表结构，mysql一切解表，所以不要认为只有物理上真实存在的表才可以做笛卡尔积，我们可以将一个查出来的表结构也可以和其他表或者其他查询结果做笛卡尔积。其次，子查询不仅能出现在where后面充当判断条件，而且也能出现在from后面充当笛卡尔积。</strong></font> 在from哪里解释。</p> 
<p><strong>显示工资比部门30的所有员工的工资高的员工的姓名、工资和部门号</strong><br> 可能会想到先把30号部门最高工资先拿到，然后在去筛选比30号部门最高工资还高的信息。</p> 
<p><img src="https://images2.imgbox.com/19/c0/nXC44reW_o.png" alt="在这里插入图片描述"></p> 
<p>下面这种写法我们也是先查找30部分最高工资然后充当筛选条件，在筛选</p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> ename<span class="token punctuation">,</span><span class="token function">sal</span><span class="token punctuation">,</span>deptno <span class="token keyword">from</span> emp where <span class="token function">sal</span>&gt;<span class="token punctuation">(</span><span class="token function">select</span> max<span class="token punctuation">(</span><span class="token function">sal</span><span class="token punctuation">)</span> <span class="token keyword">from</span> emp where deptno=30<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/8b/c3/Tcgy0Wmr_o.png" alt="在这里插入图片描述"></p> 
<p>除了这样的写法之外，我们还有一种做法，先把30号部门工资筛选出来，然后使用<br> <font color="red"><strong>all关键字</strong></font> <strong>表示全部</strong></p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> ename<span class="token punctuation">,</span><span class="token function">sal</span><span class="token punctuation">,</span>deptno <span class="token keyword">from</span> emp where <span class="token function">sal</span>&gt;all<span class="token punctuation">(</span><span class="token function">select</span> distinct <span class="token function">sal</span> <span class="token keyword">from</span> emp where deptno=30<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/aa/c5/hThDkw74_o.png" alt="在这里插入图片描述"></p> 
<p><strong>显示工资比部门30的任意员工的工资高的员工的姓名、工资和部门号（包含自己部门的员工）</strong><br> 只要比30号部分任意一个人工资高就可以了<br> <font color="red"><strong>any关键字</strong></font> <strong>表示任意</strong></p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> ename<span class="token punctuation">,</span><span class="token function">sal</span><span class="token punctuation">,</span>deptno <span class="token keyword">from</span> emp where <span class="token function">sal</span>&gt;any<span class="token punctuation">(</span><span class="token function">select</span> distinct <span class="token function">sal</span> <span class="token keyword">from</span> emp where deptno=30<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/a4/b5/EHssPze4_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="42_271"></a>4.2多列子查询</h3> 
<p>单行子查询是指子查询只返回单列，单行数据；多行子查询是指返回单列多行数据，都是针对单列而言的，而多列子查询则是指查询返回多个列数据的子查询语句。</p> 
<p><strong>查询和SMITH的部门和岗位完全相同的所有雇员，不含SMITH本人</strong></p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp where <span class="token punctuation">(</span>deptno<span class="token punctuation">,</span>job<span class="token punctuation">)</span>=<span class="token punctuation">(</span><span class="token function">select</span> deptno<span class="token punctuation">,</span>job <span class="token keyword">from</span> emp where ename=<span class="token string">'SMITH'</span><span class="token punctuation">)</span> and ename&lt;&gt;<span class="token string">'SMITH'</span><span class="token punctuation">;</span>
</code></pre> 
<p>子查询查出来的多列单行，没关系mysql支持( ，)</p> 
<p><img src="https://images2.imgbox.com/03/09/hoRcYR04_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp where <span class="token punctuation">(</span>deptno<span class="token punctuation">,</span>job<span class="token punctuation">)</span> in <span class="token punctuation">(</span><span class="token function">select</span> deptno<span class="token punctuation">,</span>job <span class="token keyword">from</span> emp where ename=<span class="token string">'SMITH'</span><span class="token punctuation">)</span> and ename&lt;&gt;<span class="token string">'SMITH'</span><span class="token punctuation">;</span>
</code></pre> 
<p>我们发现这里也支持子查询多列多行</p> 
<p><img src="https://images2.imgbox.com/ec/1c/wU5ohGrh_o.png" alt="在这里插入图片描述"></p> 
<p>目前全部的子查询，全部都在where子句中，充当判断条件！但是任何时刻，查询出来的临时结构，本质在逻辑上也是表结构！</p> 
<h2><a id="5from_290"></a>5.在from子句中使用子查询</h2> 
<p>子查询不仅可以出现where中充当判断条件，也可以出现在from中，from是在sql中告诉数据库去那个表里拿数据。在这里说一下任意查出来的表结构在我看来全都是表结构。子查询语句出现在from子句中，把一个子查询结果当做一个临时表使用，可以解决很多问题。</p> 
<p><strong>显示每个高于自己部门平均工资的员工的姓名、部门、工资、平均工资</strong><br> 首先我们要把每个部门的平均工资拎出来，如果找呢？那就需要分组然后聚合统计了。然后找出高于自己部门平均工资的姓名、部门、工资、平均工资。这个怎么找呢？如果你想的子查询找出自己部门的平均工资然后在做筛选找出这个部门中高于平均工资的，你会发现你做不下去的，因为今天这里并不是一个部门。首先我们先把每个部门平均工资拿出来走一步看一步。</p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> deptno<span class="token punctuation">,</span>avg<span class="token punctuation">(</span><span class="token function">sal</span><span class="token punctuation">)</span> myavg <span class="token keyword">from</span> emp <span class="token function">group</span> by deptno<span class="token punctuation">;</span>
</code></pre> 
<p>按照之前这就是多列多行子查询，然后在子查询去where中筛选可能就比较麻烦了</p> 
<p><img src="https://images2.imgbox.com/1d/f6/UcrsEc8e_o.png" alt="在这里插入图片描述"></p> 
<p>可以看我们目前有什么，目前我们有部门号和部门平均工资，在我看来这就是一张表，然后我手里还有一张员工表，所以是不是可以把两张表做笛卡尔积，做完之后每个员工它所在那个部门已经所在部门的平均工资，在新的表中不就有了吗</p> 
<p><strong>子查询做表必须要给一个别名</strong></p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token function">select</span> deptno<span class="token punctuation">,</span>avg<span class="token punctuation">(</span><span class="token function">sal</span><span class="token punctuation">)</span> myavg <span class="token keyword">from</span> emp <span class="token function">group</span> by deptno<span class="token punctuation">)</span> tmp<span class="token punctuation">;</span>
</code></pre> 
<p>这个笛卡尔积将两张表的信息做了穷举，可是做完笛卡尔积有些信息是有意义的，有些一看就无意义的的，就如一个员工所属部门它目前并不需要和它不是同一个部门号的平均工资做对比，如果将来需要再说。因此可以过滤掉。</p> 
<p><img src="https://images2.imgbox.com/2f/99/1tv6SNd3_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token function">select</span> deptno<span class="token punctuation">,</span>avg<span class="token punctuation">(</span><span class="token function">sal</span><span class="token punctuation">)</span> myavg <span class="token keyword">from</span> emp <span class="token function">group</span> by deptno<span class="token punctuation">)</span> tmp where emp<span class="token punctuation">.</span>deptno=tmp<span class="token punctuation">.</span>deptno<span class="token punctuation">;</span>
</code></pre> 
<p>筛选之后，现在这不就是一张符合条件的单表查询了吗</p> 
<p><img src="https://images2.imgbox.com/fc/c1/JP7VH3UR_o.png" alt="在这里插入图片描述"></p> 
<p>然后在这张表里，在筛选出需要的信息就可以了</p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> ename<span class="token punctuation">,</span>emp<span class="token punctuation">.</span>deptno<span class="token punctuation">,</span><span class="token function">sal</span><span class="token punctuation">,</span>myavg <span class="token keyword">from</span> emp<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token function">select</span> deptno<span class="token punctuation">,</span>avg<span class="token punctuation">(</span><span class="token function">sal</span><span class="token punctuation">)</span> myavg <span class="token keyword">from</span> emp <span class="token function">group</span> by deptno<span class="token punctuation">)</span> tmp where emp<span class="token punctuation">.</span>deptno=tmp<span class="token punctuation">.</span>deptno and <span class="token function">sal</span>&gt;myavg<span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/74/08/OsGWLLkD_o.png" alt="在这里插入图片描述"></p> 
<p>如果再加要求呢，要求这些人的办公地点在哪里？很简单我们可以把上面筛选出来的表结构充当一个表然后再和物理存在的dept表做笛卡尔积。</p> 
<p>然后不又得到一张表了吗</p> 
<p><img src="https://images2.imgbox.com/70/09/zvh8rl84_o.png" alt="在这里插入图片描述"></p> 
<p>然后只把有意义的消息筛选出来，</p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> dept<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token function">select</span> ename<span class="token punctuation">,</span>emp<span class="token punctuation">.</span>deptno<span class="token punctuation">,</span><span class="token function">sal</span><span class="token punctuation">,</span>myavg <span class="token keyword">from</span> emp<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token function">select</span> deptno<span class="token punctuation">,</span>avg<span class="token punctuation">(</span><span class="token function">sal</span><span class="token punctuation">)</span> myavg <span class="token keyword">from</span> emp <span class="token function">group</span> by deptno<span class="token punctuation">)</span> tmp where emp<span class="token punctuation">.</span>deptno=tmp<span class="token punctuation">.</span>deptno and <span class="token function">sal</span>&gt;myavg<span class="token punctuation">)</span> tmp where dept<span class="token punctuation">.</span>deptno=tmp<span class="token punctuation">.</span>deptno<span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/a7/5b/07ryIYzq_o.png" alt="在这里插入图片描述"></p> 
<p>在把谁在哪里上班，部门号是多少消息拿出来不就好了吗</p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> tmp<span class="token punctuation">.</span>ename<span class="token punctuation">,</span>dept<span class="token punctuation">.</span>loc<span class="token punctuation">,</span>tmp<span class="token punctuation">.</span>deptno <span class="token keyword">from</span> dept<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token function">select</span> ename<span class="token punctuation">,</span>emp<span class="token punctuation">.</span>deptno<span class="token punctuation">,</span><span class="token function">sal</span><span class="token punctuation">,</span>myavg <span class="token keyword">from</span> emp<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token function">select</span> deptno<span class="token punctuation">,</span>avg<span class="token punctuation">(</span><span class="token function">sal</span><span class="token punctuation">)</span> myavg <span class="token keyword">from</span> emp <span class="token function">group</span> by deptno<span class="token punctuation">)</span> tmp where emp<span class="token punctuation">.</span>deptnmp<span class="token punctuation">.</span>deptno=tmp<span class="token punctuation">.</span>deptno and <span class="token function">sal</span>&gt;myavg<span class="token punctuation">)</span> tmp where dept<span class="token punctuation">.</span>deptno=tmp<span class="token punctuation">.</span>deptno<span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/cd/b9/yaNiGCzl_o.png" alt="在这里插入图片描述"></p> 
<p>只要你想做还可以在笛卡尔积。<strong>所以我们面对非常复杂的查询本质上都是在任务分解，复杂问题是由简单问题构成的。</strong></p> 
<p><strong>查找每个部门工资最高的人的姓名、工资、部门、最高工资</strong><br> 首先也是要分组聚合统计找每个部门的最高工资，只不过只能统计到部门号和部门工资，这个人其他信息是没有办法在group by找到的。然后我们把这个临时表结构和emp做笛卡尔积。 最后在筛选出来部门号相同的，这个时候不有我们想要的信息的一张表了吗，然后在筛选自己想要的信息。</p> 
<p><img src="https://images2.imgbox.com/c4/e3/swCpafo9_o.png" alt="在这里插入图片描述"></p> 
<p>然后筛选出部门号相同的信息，最后找出自己要的数据就可以了</p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> ename<span class="token punctuation">,</span><span class="token function">sal</span><span class="token punctuation">,</span>emp<span class="token punctuation">.</span>deptno<span class="token punctuation">,</span>mymax <span class="token keyword">from</span> emp<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token function">select</span> deptno<span class="token punctuation">,</span>max<span class="token punctuation">(</span><span class="token function">sal</span><span class="token punctuation">)</span> mymax <span class="token keyword">from</span> emp <span class="token function">group</span> by deptno<span class="token punctuation">)</span> tmp where emp<span class="token punctuation">.</span>deptno=tmp<span class="token punctuation">.</span>deptno and <span class="token function">sal</span>=mymax<span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/71/dd/eGeWtU2z_o.png" alt="在这里插入图片描述"></p> 
<p><font color="red"><strong>记住mysql一切皆表，所谓的一切皆表就意味着可以把查询出来的临时结果在from后面也充当表。</strong></font></p> 
<p><strong>显示每个部门的信息（部门名，编号，地址）和人员数量</strong><br> 首先人员数量一定是聚合出来的员工表里面是没有这个信息的。其次部门名、编号、地址是在dept表里面的。因此我们还可以像上面的做法一样解决。</p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> t1<span class="token punctuation">.</span>deptno<span class="token punctuation">,</span>dname<span class="token punctuation">,</span>loc<span class="token punctuation">,</span>mycnt <span class="token keyword">from</span> dept t1<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token function">select</span> deptno<span class="token punctuation">,</span>count<span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> mycnt <span class="token keyword">from</span> emp <span class="token function">group</span> by deptno<span class="token punctuation">)</span> t2 where t1<span class="token punctuation">.</span>deptno=t2<span class="token punctuation">.</span>deptno<span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/5b/d3/TYDRCayM_o.png" alt="在这里插入图片描述"></p> 
<p>其实还有一种方法就是单纯使用多表，不涉及子查询，不过这样太简单粗暴了，不够优雅！直接对emp表和dept表做笛卡尔积，然后筛选出部门和相同的一张表，然后对这张表做分组，分组之后在做聚合统计。</p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> t2<span class="token punctuation">.</span>deptno<span class="token punctuation">,</span>t2<span class="token punctuation">.</span>dname<span class="token punctuation">,</span>t2<span class="token punctuation">.</span>loc<span class="token punctuation">,</span>count<span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> mycnt <span class="token keyword">from</span> emp t1<span class="token punctuation">,</span>dept t2 where t1<span class="token punctuation">.</span>deptno=t2<span class="token punctuation">.</span>deptno <span class="token function">group</span> by t2<span class="token punctuation">.</span>deptno<span class="token punctuation">,</span>t2<span class="token punctuation">.</span>dname<span class="token punctuation">,</span>t2<span class="token punctuation">.</span>loc<span class="token punctuation">;</span>
</code></pre> 
<p>要的信息除了部门号和人员数量，还有编号和地址，但是根据我们前面所学知识知道分组聚合统计只有跟在group by后面的列和聚合函数才可以聚合情况下出现，因此还要对编号和地址分组。</p> 
<p><img src="https://images2.imgbox.com/86/ab/DvCHlOWl_o.png" alt="在这里插入图片描述"></p> 
<p>这种方法并不推荐，推荐使用子查询多表这种方法。</p> 
<p>总结一下：mysql在我的心里是没有多表结构的，永远就是一张表。group by在我看来也是一张表，分组就是分表。只要解决一个问题其他都是解决。 多张表我可以在where中充当判断条件，在from中也做一个表然后和其他表做笛卡尔积。所以根本就没有多表问题。</p> 
<p><font color="red"><strong>解决多表问题的本质：想办法将多表转化成为单表，所以mysql中，所有select的问题全部都可以转成单表问题！这就是我们多表查询的指导思想！</strong></font></p> 
<h2><a id="6_384"></a>6.合并查询</h2> 
<p>在实际应用中，为了合并多个select的执行结果，可以使用集合操作符 union，union all，合并并不是笛卡尔积，笛卡尔积是将两个表的信息穷举。合并就是单纯的合起来。</p> 
<p><strong>union</strong><br> 该操作符用于取得两个结果集的并集。当使用该操作符时，会自动去掉结果集中的重复行。</p> 
<p><img src="https://images2.imgbox.com/8a/47/hIzmsXR6_o.png" alt="在这里插入图片描述"></p> 
<p><strong>将工资大于2500或职位是MANAGER的人找出来</strong><br> 其实我们可以直接筛选出来的，但是我们用一下union</p> 
<p>我们可以看到这两条sql查询出来的信息是有重复的。</p> 
<p><img src="https://images2.imgbox.com/f8/f8/xAFbataL_o.png" alt="在这里插入图片描述"></p> 
<p>这里我们可以使用union把两条sql合并起来并且去掉重复的</p> 
<p><img src="https://images2.imgbox.com/88/e5/E5MJRi5t_o.png" alt="在这里插入图片描述"></p> 
<p>不想去重使用union all，就会把所有信息保留</p> 
<p><img src="https://images2.imgbox.com/5c/53/XBpRDLh4_o.png" alt="在这里插入图片描述"></p> 
<p><strong>注意合并时，两个表结构列必须是一样的才能把两个表合并起来</strong></p> 
<p><img src="https://images2.imgbox.com/f8/8d/bs4sbJYt_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="7_411"></a>7.表的内连和外连</h2> 
<p>表的连接分为内连和外连</p> 
<h3><a id="71_413"></a>7.1内连接</h3> 
<p>内连接实际上就是利用where子句对两种表形成的笛卡儿积进行筛选，我们前面学习的查询都是内连接，也是在开发过程中使用的最多的连接查询。</p> 
<p>除了上面学习的from 逗号 连接两个表然后用where筛选有效信息，还可以用下面inner join连接两个表，然后用on并且可以用and级联多个筛选条件 对笛卡尔积筛选出有效信息。之前学到的其实就是内连接的一种。</p> 
<p>语法：</p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> 字段 <span class="token keyword">from</span> 表1 inner join 表2 on 连接条件 and 其他条件；
</code></pre> 
<p><strong>显示SMITH的名字和部门名称</strong></p> 
<p>这是之前的写法</p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> ename<span class="token punctuation">,</span>emp<span class="token punctuation">.</span>deptno<span class="token punctuation">,</span>dname <span class="token keyword">from</span> emp<span class="token punctuation">,</span>dept where emp<span class="token punctuation">.</span>deptno=dept<span class="token punctuation">.</span>deptno and ename=<span class="token string">'SMITH'</span><span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/89/0b/MATfYK4s_o.png" alt="在这里插入图片描述"></p> 
<p>标准内连接写法</p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> ename<span class="token punctuation">,</span>emp<span class="token punctuation">.</span>deptno<span class="token punctuation">,</span>dname <span class="token keyword">from</span> emp inner join dept on emp<span class="token punctuation">.</span>deptno=dept<span class="token punctuation">.</span>deptno where ename=<span class="token string">'SMITH'</span><span class="token punctuation">;</span>
</code></pre> 
<p>两种写法都可以得到同样的数据，换句话说这种标准写法可以让我们的sql逻辑更清楚 ，哪一个部分是要形成笛卡尔积的，那一部分是进一步做条件筛选的。当然也直接用and连接，不过还是建议用where，逻辑更清楚。</p> 
<p><img src="https://images2.imgbox.com/28/a6/Uyjz8cVh_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="72_438"></a>7.2外连接</h3> 
<p>外连接分为左外连接和右外连接</p> 
<h4><a id="721_440"></a>7.2.1左外连接</h4> 
<p>如果多表查询，我们想让左侧的表完全显示不要过任何过滤筛选，如果和右侧的表配不上，让右侧的都为空也可以。必须保持左侧表的全貌。我们就叫做左外连接。</p> 
<p>语法：</p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> 字段名 <span class="token keyword">from</span> 表名1 left join 表名2 on 连接条件
</code></pre> 
<p>我们发现目前这两张表id是对不上的。</p> 
<p><img src="https://images2.imgbox.com/d9/58/FD0N2DqE_o.png" alt="在这里插入图片描述"></p> 
<p><strong>查询所有学生的成绩，如果这个学生没有成绩，也要将学生的个人信息显示出来</strong></p> 
<p>如果要用id做内连接的话，那只有1，2号学生符合条件，而我们要保留左侧表结构要完全显示，那内连接就不能满足条件了。因此我们使用<strong>左外连接</strong></p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> stu left join exam on stu<span class="token punctuation">.</span>id=exam<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
</code></pre> 
<p><strong>左侧表完全保留，右侧表按条件拼接，条件满足直接拼上，条件不满足拼null</strong></p> 
<p><img src="https://images2.imgbox.com/60/07/Wltf0St4_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="722_463"></a>7.2.2右外连接</h3> 
<p>如果联合查询，要求右侧的表完全显示我们就说是右外连接。<br> 其实只有左外连接也可以，把顺序换一下就可以，不过mysql这里也给我提供了右外连接。</p> 
<p>语法：</p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> 字段 <span class="token keyword">from</span> 表名1 right join 表名2 on 连接条件；
</code></pre> 
<p><strong>对stu表和exam表联合查询，把所有的成绩都显示出来，即使这个成绩没有学生与它对应，也要显示出来</strong></p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> stu right join exam on stu<span class="token punctuation">.</span>id=exam<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
</code></pre> 
<p><strong>右侧表完全保留，左侧表按条件拼接，条件满足直接拼上，条件不满足拼null</strong></p> 
<p><img src="https://images2.imgbox.com/61/b0/XMTgPpTD_o.png" alt="在这里插入图片描述"></p> 
<p><strong>列出部门名称和这些部门的员工信息，同时列出没有员工的部门</strong><br> 首先是要将dept表和emp表做连接，要求的是必须把部门全部显示出来即使没有员工，这不是要求以dep表为主吗。</p> 
<p>这里使用左外连接和右外连接都可以，不过就是换一下位置</p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> dept<span class="token punctuation">.</span>dname<span class="token punctuation">,</span>emp<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">from</span> dept left join emp on dept<span class="token punctuation">.</span>deptno=emp<span class="token punctuation">.</span>deptno order by dept<span class="token punctuation">.</span>deptno asc<span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/cb/f6/xJxqm63N_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> dept<span class="token punctuation">.</span>dname<span class="token punctuation">,</span>emp<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">from</span> emp right join dept on dept<span class="token punctuation">.</span>deptno=emp<span class="token punctuation">.</span>deptno order by dept<span class="token punctuation">.</span>deptno asc<span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/df/30/KjMi3glO_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e47701173ea6f497db955d5f3f60e940/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">再度牵手，制造升级 | 毅达科技IMS OS&#43;通用产品集&#43;行业套件项目正式启动！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ea9032cbec035f3dbed56247966bb106/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">推荐开源项目： LetsPPT - AI智能生成PPT助手</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>