<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构/C&#43;&#43;】位图 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/8444cda559bfce304034107606d2720a/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构/C&#43;&#43;】位图">
  <meta property="og:description" content="这里写自定义目录标题 哈希思想的应用位图位图概念经典面试题位图所开的空间大小STL库中的 `bitset` 位图 位图实现大框架位运算符&lt;&lt;左移 和 &gt;&gt;右移 移动的方位set()：把x映射的位标记成1set() 接口实现reset：把x映射的位标记成0reset() 接口test()：检测x位是1还是0 效率海量面试题 布隆过滤器布隆过滤器提出数据在内存中查找布隆过滤器的引入布隆过滤器 布隆过滤器 实现大框架模板参数 讨论1：哈希函数个数 的选择 —— 开`3`个哈希函数(一个值映射`3`个位)讨论2：布隆过滤器长度 —— 开要进行插入元素个数的`5`倍大小reset() 删除 不能实现 布隆过滤器 码源实现经典面试题对于 切分的文件数量多少 的讨论极端情况：某个文件冲突很多，导致`Ai`或者`Bi`太大了，比如超过1G， `i=HashFunc(query)%100`哈希切分出各`Ai`文件 &#43; `map&lt;string, int&gt;`统计次数 &#43; `topK` `priority_queue`小堆 ：统计出`topK的IP`地址`i=HashFunc(query)%100`哈希切分成各`Ai`文件 &#43; `map&lt;int, int&gt;` 逐一遍历哈希切分出的各`Ai`文件：统计出现的次数海量数据处理 问题的特征 哈希思想的应用 哈希(也叫 散列) 是一种 映射 的思想
哈希表：解决问题的思想（算法思想）：哈希表通过映射这种思想，实现了哈希表这种数据结构
还有其他的数据结构：位图、布隆过滤器。小众点的，基数树（多阶哈希）
位图 位图概念 经典面试题 给40亿个不重复的无符号整数，没排过序。给一个无符号整数，如何快速判断一个数是否在这40亿个数中。
排序&#43;二分set &#43; find 1G=1024MB；1MB=1024KB；1KB=1024byte 。( 1024=2^ 10. )
则 1G=1024 * 1024 * 1024=(2^ 10)^ 3 = 2^ 30 byte 。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-05T13:23:18+08:00">
    <meta property="article:modified_time" content="2024-07-05T13:23:18+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构/C&#43;&#43;】位图</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>这里写自定义目录标题</h4> 
 <ul><li><a href="#_7" rel="nofollow">哈希思想的应用</a></li><li><a href="#_17" rel="nofollow">位图</a></li><li><a href="#_19" rel="nofollow">位图概念</a></li><li><ul><li><a href="#_21" rel="nofollow">经典面试题</a></li><li><a href="#_37" rel="nofollow">位图所开的空间大小</a></li><li><a href="#STL_bitset__66" rel="nofollow">STL库中的 `bitset` 位图</a></li></ul> 
  </li><li><a href="#_86" rel="nofollow">位图实现</a></li><li><ul><li><a href="#_87" rel="nofollow">大框架</a></li><li><a href="#____124" rel="nofollow">位运算符&lt;&lt;左移 和 &gt;&gt;右移 移动的方位</a></li><li><ul><li><a href="#setx1_134" rel="nofollow">set()：把x映射的位标记成1</a></li><li><a href="#set__161" rel="nofollow">set() 接口实现</a></li><li><a href="#resetx0_178" rel="nofollow">reset：把x映射的位标记成0</a></li><li><a href="#reset__198" rel="nofollow">reset() 接口</a></li><li><a href="#testx10_214" rel="nofollow">test()：检测x位是1还是0</a></li></ul> 
   </li><li><a href="#_239" rel="nofollow">效率</a></li><li><a href="#_246" rel="nofollow">海量面试题</a></li></ul> 
  </li><li><a href="#_380" rel="nofollow">布隆过滤器</a></li><li><ul><li><a href="#_382" rel="nofollow">布隆过滤器提出</a></li><li><a href="#_385" rel="nofollow">数据在内存中查找</a></li><li><a href="#_408" rel="nofollow">布隆过滤器的引入</a></li><li><a href="#_428" rel="nofollow">布隆过滤器</a></li></ul> 
  </li><li><a href="#__437" rel="nofollow">布隆过滤器 实现</a></li><li><ul><li><a href="#_438" rel="nofollow">大框架</a></li><li><ul><li><a href="#_455" rel="nofollow">模板参数</a></li></ul> 
   </li><li><a href="#1____33_469" rel="nofollow">讨论1：哈希函数个数 的选择 —— 开`3`个哈希函数(一个值映射`3`个位)</a></li><li><a href="#2__5_485" rel="nofollow">讨论2：布隆过滤器长度 —— 开要进行插入元素个数的`5`倍大小</a></li><li><a href="#reset___513" rel="nofollow">reset() 删除 不能实现</a></li></ul> 
  </li><li><a href="#__521" rel="nofollow">布隆过滤器 码源实现</a></li><li><ul><li><a href="#_650" rel="nofollow">经典面试题</a></li><li><ul><li><a href="#___676" rel="nofollow">对于 切分的文件数量多少 的讨论</a></li><li><a href="#AiBi1G_690" rel="nofollow">极端情况：某个文件冲突很多，导致`Ai`或者`Bi`太大了，比如超过1G，</a></li></ul> 
   </li><li><a href="#iHashFuncquery100Ai__mapstring_int__topK_priority_queue_topKIP_717" rel="nofollow">`i=HashFunc(query)%100`哈希切分出各`Ai`文件 + `map&lt;string, int&gt;`统计次数 + `topK` `priority_queue`小堆 ：统计出`topK的IP`地址</a></li><li><a href="#iHashFuncquery100Ai__mapint_int_Ai_741" rel="nofollow">`i=HashFunc(query)%100`哈希切分成各`Ai`文件 + `map&lt;int, int&gt;` 逐一遍历哈希切分出的各`Ai`文件：统计出现的次数</a></li><li><a href="#__749" rel="nofollow">海量数据处理 问题的特征</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<br> 
<hr> 
<h2><a id="_7"></a>哈希思想的应用</h2> 
<p><strong>哈希(也叫 散列)</strong> 是一种 <strong>映射</strong> 的思想<br> 哈希表：解决问题的思想（算法思想）：<strong>哈希表通过映射这种思想，实现了哈希表这种数据结构</strong></p> 
<p>还有其他的数据结构：位图、布隆过滤器。小众点的，基数树（多阶哈希）</p> 
<br> 
<hr> 
<h2><a id="_17"></a>位图</h2> 
<h2><a id="_19"></a>位图概念</h2> 
<h3><a id="_21"></a>经典面试题</h3> 
<p>给40亿个不重复的无符号整数，没排过序。给一个无符号整数，如何快速判断一个数是否在这40亿个数中。</p> 
<ol><li>排序+二分</li><li>set + find</li></ol> 
<p>1G=1024MB；1MB=1024KB；1KB=1024byte 。( 1024=2^ 10. )<br> 则 <strong><font color="red">1G</font></strong>=1024 * 1024 * 1024=(2^ 10)^ 3 = <strong><font color="red"><code>2^ 30</code> byte</font></strong> 。<br> 由此得出，1G就能存放<code>1,000,000,000</code> (10亿)个数据。每一个数据存放的单位是1byte。<br> <mark><strong><font color="red">42亿 (即 2^32 )</font></strong> 则需 <strong><font color="red">4G</font></strong> 的数据大小（基本单位为 byte）</mark>。<mark><strong>通过位图，一个<code>bit</code>位便能 映射表示一个数</strong>（1byte=8bit）</mark>，因此 <mark><strong>开一个 <font color="dark">能够映射42亿数据</font> 的 <font color="dark">位图</font> 所需的内存空间大小为</strong> <strong><code>4G / 8bit = 0.5G (512M)</code></strong></mark> 。</p> 
<br> 
<h3><a id="_37"></a>位图所开的空间大小</h3> 
<p>位图 开的大小，是按范围去开。<mark><strong><font color="dark">无符号整数</font></strong> 的范围是 <strong><code>0~4,294,967,295</code></strong></mark>，因此我们需要开<code>0~4,294,967,295</code>大的范围 。即使是100亿个数据，<mark><strong>不管开多大还是开多小，都开<code>Unsigned_int</code>大小的位置</strong>， 除这42亿9千万个数外，其他的都是重复的</mark>。</p> 
<p>开 <code>INT_MAX</code> 大小是不够的才 <code>2,147,483,647</code>（因为是有符号整型，还有另一半 <code>INT_MIN</code>，所以为 <code>2,147,483,647</code>）<br> <mark>2*<code>INT_MAX</code>：默认给出<code>INT_MAX</code>的时候识别是<strong>整型(<code>int</code>) * 2 以后会溢出</strong></mark> 。因此要用<code>UINT_MAX</code> (unsigned_int_max)范围就是从<code>0~4,294,967,295</code></p> 
<p>bitset&lt;&gt; bs;</p> 
<blockquote> 
 <p>(size_t)-1 将-1强转为无符号整形<br> UINT_MAX (unsigned_intMAX)<br> 0xffffffff(16进制:8个f)<br> pow(2,32)-1</p> 
</blockquote> 
<br> 
<p>倘若是<strong>通过数据结构来存储的</strong>， 4G(个数据) X <strong>一个整数<code>4byte</code></strong> = <strong>总共<code>16G-</code>的内存大小</strong> 。排序需要连续的物理地址空间大小。平时普通的电脑内存根本不够用。像红黑树一个节点中存放三指针和一个数据，其所消耗的内存大小就更不用说了。</p> 
<p>对于这道题目而言，一个数据只有两种状态：在/不在。如果我们想要标识两种状态，其实 <strong>只需要一个比特位就够了，0表示不存在，1表示存在</strong>。 <strong>通过<mark>哈希的映射思想</mark>，我们可以<mark>把每一个数据映射到一个比特位中</mark>，这就是<mark>位图的概念</mark>。</strong></p> 
<ol start="3"><li>开2^32个bit位【 按范围去开：<code>Unsigned_int</code> <strong>42亿9千万</strong> 】<br> 表示一个数在或者不在，用一个bit比特位来表示</li></ol> 
<br> 
<hr> 
<h3><a id="STL_bitset__66"></a>STL库中的 <code>bitset</code> 位图</h3> 
<p>简单了解<code>bitset</code>的最常用接口，明白其的功能有哪些，后面实现 。<br> <img src="https://images2.imgbox.com/d9/1b/w4vz3EnI_o.png" alt="在这里插入图片描述"><br> 类模板：<br> 非类型模板参数<code>N</code>，位图中要开多少个比特位。</p> 
<table><thead><tr><th>接口</th><th>功能</th></tr></thead><tbody><tr><td><code>operator[]</code></td><td>返回对应位置的引用</td></tr><tr><td><code>count</code></td><td>计算所有比特位中1的个数</td></tr><tr><td><code>size</code></td><td>返回比特位的个数</td></tr><tr><td><code>test</code></td><td>检测某一个位，是1返回true，是0返回false</td></tr><tr><td><code>set</code></td><td>把某一个位的值改为1</td></tr><tr><td><code>reset</code></td><td>把某一个位的值改为0</td></tr></tbody></table> 
<br> 
<hr> 
<h2><a id="_86"></a>位图实现</h2> 
<h3><a id="_87"></a>大框架</h3> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span>size_t N<span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">bitSet</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    
   
<span class="token keyword">private</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> _bits<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>模板参数<code>N</code> ：用于<strong>传参</strong>，代表<strong>传过来的有多少个数需要判断</strong>。<mark><strong><code>N</code>就是要开的<code>bit</code>位的数量</strong></mark>。</p> 
<p>但位图的 <mark><strong>底层结构是<code>vector&lt; int &gt;</code></strong></mark>（ <code>int</code>类型的数组 ），而 <mark><strong>一个<code>int</code>有32个<code>bit</code>位</strong></mark>，一个位置能容下判断32个数。那么我们应开的空间为 <code>N / 32</code>个 <code>int</code>空间大小的<code>vector&lt;&gt;</code> 。</p> 
<p>但由于<mark>C++的除法会向下取整</mark>，所以我们要<strong>额外<code>+1</code></strong>，<strong>避免开出来的位不够</strong>。如63/32=1，那剩下的31位怎么办？</p> 
<p>这样我们就可以写一个构造函数 。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span>size_t N<span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">bitSet</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">bitSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        _bits<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>N <span class="token operator">/</span> <span class="token number">32</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> _bits<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<br> 
<hr> 
<h3><a id="____124"></a>位运算符&lt;&lt;左移 和 &gt;&gt;右移 移动的方位</h3> 
<p>左移还是右移，是由大小端来决定的吗？大小端在内存窗口中查看。小端(低位在地址低位，高位在地址高位)，大端(高位在地址低位，低位位在地址高位)</p> 
<p>不是的，也没有说在小端机中右移是往高位移，左移往低位移这样的说法。<br> <strong>左移和右移并不是单纯的方向上的移动</strong>，而是<strong>统一</strong> <mark><font color="dark"><strong>左移是往高位移，右移是往低位移</strong></font></mark> 。而 <strong>硬件层</strong> 会单独判断处理数值是小端机还是大端机，(cpu)<mark><strong>硬件体系中的指令体系</strong></mark> <strong>相当于 <font color="dark">封装</font> 了左移和右移，直接执行左移所对应的往高位移的操作，右移所对应的往低位移的操作</strong>。</p> 
<br> 
<hr> 
<h4><a id="setx1_134"></a>set()：把x映射的位标记成1</h4> 
<p>大体逻辑：</p> 
<ul><li>先定位（ 一个元素有32个bit位 ） 
  <ul><li>确定是vector中的第<code>i</code>个元素</li><li>第<code>i</code>个元素的第<code>j</code>个比特位</li></ul> </li></ul> 
<pre><code class="prism language-cpp">size_t i <span class="token operator">=</span> x <span class="token operator">/</span> <span class="token number">32</span><span class="token punctuation">;</span> <span class="token comment">// vector的第i个元素</span>
size_t j <span class="token operator">=</span> x <span class="token operator">%</span> <span class="token number">32</span><span class="token punctuation">;</span> <span class="token comment">// 第i个元素的第j个比特位</span>
</code></pre> 
<ul><li>先将1左移<code>&lt;&lt;</code>（往高处移）到要标记成的位置（ 除了该位置为1，其他位置都是0 ）</li><li>按位<strong>或等<code>|=</code></strong> ：有1则为1，（ 除了该位置为1，其他位置都是0 ）则能控制<code>j</code>位修改为1，而其他位置不受影响。</li></ul> 
<p>如把<code>11001100</code>的第4位变为1：</p> 
<pre><code class="prism language-cpp">   <span class="token number">11001100</span> 	<span class="token comment">// 待修改数据</span>
   <span class="token number">00000001</span> 	<span class="token comment">// 数字1</span>
   <span class="token number">00010000</span> 	<span class="token comment">// 数字1左移4位</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
   <span class="token number">11001100</span>
<span class="token operator">|=</span> <span class="token number">00010000</span> 	<span class="token comment">// 按位或等</span>
 <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
   <span class="token number">11011100</span>
</code></pre> 
<h4><a id="set__161"></a>set() 接口实现</h4> 
<pre><code class="prism language-cpp">	<span class="token comment">// 把x映射的位标记成1</span>
	<span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>size_t x<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">assert</span><span class="token punctuation">(</span>x <span class="token operator">&lt;=</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		size_t i <span class="token operator">=</span> x <span class="token operator">/</span> <span class="token number">32</span><span class="token punctuation">;</span>
		size_t j <span class="token operator">=</span> x <span class="token operator">%</span> <span class="token number">32</span><span class="token punctuation">;</span>
	
		_bits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<br> 
<hr> 
<h4><a id="resetx0_178"></a>reset：把x映射的位标记成0</h4> 
<p>将改为设置成0：</p> 
<ul><li>定位</li><li>将除了该位置设置成0，其他都设置成1<br> 这要怎么做到呢？对上面将该位置标记成1的<code>( 1&lt;&lt;j )</code>进行 取反操作<code>~</code>，就得到该位置是0，其他位置都为1 的底部</li><li>然后 <strong><code>&amp;=</code></strong> 按位<strong>与等</strong>：有0则为0，将该为修改为0。（其他位置都是1，则不会受到影响）</li></ul> 
<pre><code class="prism language-cpp">   <span class="token number">11011100</span>  <span class="token comment">// 待修改数据</span>
   <span class="token number">00000001</span>  <span class="token comment">// 数字1</span>
   <span class="token number">00010000</span>  <span class="token comment">// 数字1左移4位（1&lt;&lt;j）</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
   <span class="token number">11011100</span>
 <span class="token operator">~</span> <span class="token number">00010000</span>  <span class="token comment">// ~取反</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
   <span class="token number">11011100</span>
<span class="token operator">&amp;=</span> <span class="token number">11101111</span>  <span class="token comment">// 按位与&amp;=: 0来修改1</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
   <span class="token number">11001100</span> 
</code></pre> 
<h4><a id="reset__198"></a>reset() 接口</h4> 
<pre><code class="prism language-cpp">	<span class="token comment">// 把x映射的位标记成0</span>
	<span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span>size_t x<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">assert</span><span class="token punctuation">(</span>x <span class="token operator">&lt;=</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>

		size_t i <span class="token operator">=</span> x <span class="token operator">/</span> <span class="token number">32</span><span class="token punctuation">;</span>
		size_t j <span class="token operator">=</span> x <span class="token operator">%</span> <span class="token number">32</span><span class="token punctuation">;</span>

		_bits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;=</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<br> 
<hr> 
<h4><a id="testx10_214"></a>test()：检测x位是1还是0</h4> 
<ul><li>左移<code>1&lt;&lt;j</code>（ 让1与其按位与判断 ）</li><li><code>&amp;</code> 按位与判断 就行了，不进行修改<br> 最后 return 该<code>_bits[i]</code>位的 整型值 转化成 <code>bool</code>值：0就是假，非0就是真。</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token function">test</span><span class="token punctuation">(</span>size_t x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">assert</span><span class="token punctuation">(</span>x <span class="token operator">&lt;=</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>
    size_t i <span class="token operator">=</span> x <span class="token operator">/</span> <span class="token number">32</span><span class="token punctuation">;</span>
    size_t j <span class="token operator">=</span> x <span class="token operator">%</span> <span class="token number">32</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> _bits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// &amp; 按位与判断，不进行修改</span>
<span class="token punctuation">}</span>
</code></pre> 
<br> 
<hr> 
<p><code>#include"BitSet.h"</code> 展开在.cpp中，展开后BitSet.h里的内容也就只能向上查找<br> 【链接】</p> 
<br> 
<hr> 
<h3><a id="_239"></a>效率</h3> 
<p>把数都遍历一遍，全都set到位图中。<br> 剩下的查找就直接根据O(1)，就能映射到要找的数据</p> 
<br> 
<hr> 
<h3><a id="_246"></a>海量面试题</h3> 
<ol><li>给定100亿个整数，设计算法找到只出现一次的整数</li></ol> 
<ul><li> <p>思路1：用map 内存存不下这些值<br> 10,000,000,000<br> <strong><font color="dark">10亿多byte是1G</font></strong>，100亿多是10G，是整数因此还要<code>x4</code>byte，因此这里需要40G-的内存</p> </li><li> <p>思路2：还是通过位图来映射找到对应数据出现的次数<br> 1次 和 2次及以上，需要2个比特位，只需要判断3中状态就可以了"00,01,10"（00 - 0次，01 - 1次，10 - 2次及以上）</p> 
  <ul><li>连开两个bit位，映射关系处理的有点麻烦</li><li><mark><strong>直接开两个位图</strong></mark> ，两个位图组合起来就是其统计的次数</li></ul> </li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span>size_t N<span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">two_bit_set</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token comment">// 00 -&gt; 01 1次</span>
	<span class="token comment">// 01 -&gt; 10 2次及以上(10以后就不变)</span>
	<span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>size_t x<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 00 -&gt; 01</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>_bs1<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">false</span>
			<span class="token operator">&amp;&amp;</span> _bs2<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			_bs2<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>_bs1<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">false</span>      
			<span class="token operator">&amp;&amp;</span> _bs2<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span>   
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 01 -&gt; 10</span>
			_bs1<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
			_bs2<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>


	<span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>size_t x<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 00 </span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>_bs1<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">false</span>
			<span class="token operator">&amp;&amp;</span> _bs2<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>_bs1<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">false</span>
			<span class="token operator">&amp;&amp;</span> _bs2<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 01</span>
			<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>   <span class="token comment">// 2次及以上</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	bitSet<span class="token operator">&lt;</span>N<span class="token operator">&gt;</span> _bs1<span class="token punctuation">;</span>
	bitSet<span class="token operator">&lt;</span>N<span class="token operator">&gt;</span> _bs2<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>也可以按照自己的需求自己造轮子：</p> 
<pre><code class="prism language-cpp">	<span class="token comment">// 根据需求自己造轮子：只需判断出只出现一次的</span>
	<span class="token keyword">bool</span> <span class="token function">test</span><span class="token punctuation">(</span>size_t x<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>_bs1<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">false</span>
			<span class="token operator">&amp;&amp;</span> _bs2<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 01</span>
			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<br> 
<hr> 
<ol start="2"><li>给两个文件，分别有100亿个整数，我们只有1G内存，如何找到两个文件交集?</li></ol> 
<p>思路：分别set到两个位图，两个位图同时为1，按位与<code>&amp;</code> 后为1，则为交集</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">test_bitset2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">4</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> a2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">9</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

	bitSet<span class="token operator">&lt;</span><span class="token number">100</span><span class="token operator">&gt;</span> bs1<span class="token punctuation">;</span>
	bitSet<span class="token operator">&lt;</span><span class="token number">100</span><span class="token operator">&gt;</span> bs2<span class="token punctuation">;</span>

	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> a1<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		bs1<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> a2<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		bs2<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">100</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>bs1<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> bs2<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment">// 都存在</span>
		<span class="token punctuation">{<!-- --></span>
			cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<br> 
<hr> 
<ol start="3"><li> <p>位图应用变形：1个文件有100亿个int，<strong>只有<code>512M</code>内存</strong>，设计算法找到出现次数不超过2次的所有整数</p> <p>处理 <strong><code>Unsigned_int_max</code>无符号整型</strong>(范围为<code>0~42亿9千万</code>)，所需开的<strong>位图</strong>大小为 <strong><code>0.5G</code></strong>。<br> 这里有100亿个int整型，则大概需要1G多的内存大小来处理数据，内存不够，怎么办？</p> <p>位图所开的空间大小，是取决于需要映射的数的范围 。 若只有<code>512M</code>的内存，则<mark>每次只映射一半范围的数据，因此则能一次只使用<code>256M</code>的内存（直接映射）</mark> 。第二次值统计，则统计后半部分（通过间接映射 <code>x-2^31</code> ）。</p> <p>将分开遍历的两组值，一个位图对这分开的两组值，分别都进行遍历 。</p> </li></ol> 
<br> 
<hr> 
<h2><a id="_380"></a>布隆过滤器</h2> 
<h3><a id="_382"></a>布隆过滤器提出</h3> 
<p>我们在使用新闻客户端看新闻时，它会给我们不停地推荐新的内容，它每次推荐时要去重，去掉那些已经看过的内容。问题来了，新闻客户端推荐系统如何实现推送去重的？ 用服务器记录了用户看过的所有历史记录，当推荐系统推荐新闻时会从每个用户的历史记录里进行筛选，过滤掉那些已经存在的记录。 如何快速查找呢？</p> 
<h3><a id="_385"></a>数据在内存中查找</h3> 
<ul><li> <p>排序 + 二分查找：<br> 排序只需要排一次，后面的查找。<br> 不足：主要的问题是在 <mark>数组 上，插入在头部、中间都要挪动数据，消耗很大</mark> 。</p> </li><li> <p>搜索树<br> 按照搜索树规则，搜索的时间复杂度为O(log_2 N)<br> 不足： <mark>该数据结构 在内存大小上的消耗很大</mark>，一个节点存放三指针一数据。</p> </li><li> <p>哈希表<br> 映射规则，<br> 不足：<strong>浪费空间</strong>，一个空间存储数据的大小根据要存储的数据通过 <strong><code>Hash</code>哈希函数</strong> 转化成整型来进行哈希映射存储。<strong>整型大小的位为<code>int</code></strong> 。</p> </li><li> <p>位图（应用了<strong>哈希映射思想</strong> + <strong>位运算<code>0</code> <code>1</code> 标记</strong>，仅需<code>bit</code>位的大小）<br> （ <mark><strong>局限：只是要简单判断这个值在不在</strong></mark> -&gt; <mark>只需要 <strong>位映射</strong> 来进行<code>0</code> <code>1</code><strong>标记</strong>，仅需<code>bit</code>位的大小</mark> ）</p> 
  <ul><li> <p><strong>特点：1. 快 ； 2. 节省空间</strong></p> </li><li> <p><mark><strong>不足</strong>：<strong>只能解决整型</strong></mark></p> <p><mark><font color="red"><strong>只是要简单判断这个值在不在</strong></font>，就能<font color="red"><strong>用位图 位映射标记，直接查找该位置标记的值是<code>0</code>还是<code>1</code>来直接判断是否存在</strong></font> 的思想，来解决问题。</mark></p> </li></ul> </li></ul> 
<br> 
<hr> 
<h3><a id="_408"></a>布隆过滤器的引入</h3> 
<p>若想将位图这样，只是想简单判断这个值在不在 的思想，同样应用在其他自定义类型上。</p> 
<p>要是是其他类型，（如自定义类型，string类型，怎么办？）通过字符串来判断</p> 
<p>若仍采用位图来解决string类 有可能会存在哈希冲突：<br> 不同的字符串（无限） —&gt; 整型（有限 42亿9千万） —&gt; 映射存储位置 ，字符串的多少是无限多(假设开的位图大小是10个位置，这能组合出来的字符串是已经256^10个了，这远超 有限个整型个数)，即一定会存在整型重复，而造成误判的情况存在。</p> 
<br> 
<p>误判：</p> 
<ul><li><mark>在：有误判的可能（本来不在，映射位置冲突了，误判成在了）</mark></li><li>不在：准确的</li></ul> 
<br> 
<hr> 
<p>存在误判，但如果将要将这样的映射位置冲突的概率降低 。</p> 
<h3><a id="_428"></a>布隆过滤器</h3> 
<p>一个数据插入多个位置，这多个位置，可能会存在映射和其他位置存在冲突，只要遍历到的该位置 不存在，则进行映射插入，则大大降低了映射冲突的概率。</p> 
<p><img src="https://images2.imgbox.com/0f/4f/kjbYUAFN_o.png" alt="在这里插入图片描述"></p> 
<br> 
<hr> 
<h2><a id="__437"></a>布隆过滤器 实现</h2> 
<h3><a id="_438"></a>大框架</h3> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span>size_t N<span class="token punctuation">,</span>       <span class="token comment">// 要插入数据的个数</span>
	<span class="token keyword">class</span> <span class="token class-name">K</span><span class="token operator">=</span> string<span class="token punctuation">,</span>	    <span class="token comment">// 常用于布隆过滤器的key值是string</span>
	<span class="token keyword">class</span> <span class="token class-name">Hash1</span>	<span class="token operator">=</span> HashFuncBKDR<span class="token punctuation">,</span>       <span class="token comment">// Hash1,Hash2,Hash3 通过不同的Hash哈希，分别映射到不同的三个位置</span>
	<span class="token keyword">class</span> <span class="token class-name">Hash2</span> <span class="token operator">=</span> HashFuncAP<span class="token punctuation">,</span> 
	<span class="token keyword">class</span> <span class="token class-name">Hash3</span> <span class="token operator">=</span> HashFuncDJB<span class="token operator">&gt;</span>
<span class="token keyword">class</span>  <span class="token class-name">BloomFilter</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	bitSet<span class="token operator">&lt;</span><span class="token number">5</span><span class="token operator">*</span>N<span class="token operator">&gt;</span> _bs<span class="token punctuation">;</span>	   
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="_455"></a>模板参数</h4> 
<p><code>class K = String</code> 缺省参数传string，因为最常传的类型是string 。<mark><code>K</code>是指需要位图进行标识是否存在的数据的类型： 传 自定义类型</mark>(如 日期类)，只要对应传对应自定义类型的仿函数(将其转化成整型) 就行</p> 
<p><mark><code>size_t N</code> 需要进行存储在位图中，需要进行Hash哈希函数映射处理的数据个数</mark>：想要通过建立映射关系来达到<code>O(1)</code>的查找时间复杂度 。</p> 
<br> 
<p>而 <strong>布隆过滤器 的之所以能实现不同字符串之间不冲突，来实现自定义类型也能使用位图来达到<code>O(1)</code>查找的时间复杂度的直接映射</strong>，是通过<mark>实行多个哈希函数在位图中进行多个位置同时映射，来降低哈希冲突的概率</mark>，<mark>从而让非整型类型也能采用哈希思想<code>O(1)</code>的时间复杂度直接判断出该数据是否存在。</mark></p> 
<p>但这样的<mark>实行 <strong>多个哈希函数</strong> 进行的 <strong>多个位置同时映射</strong>，来判断该数据是否存在的做法，<strong><font color="dark">对空间消耗非常大</font></strong></mark>，因此 <strong><font color="dark">对于因为要建立这样多个映射关系，要开多大的布隆过滤器 也是有讲究的</font></strong>，下面让我们来进行一下讨论分析。</p> 
<br> 
<hr> 
<h3><a id="1____33_469"></a>讨论1：哈希函数个数 的选择 —— 开<code>3</code>个哈希函数(一个值映射<code>3</code>个位)</h3> 
<br> 
<p><strong>哈希函数的个数（一个值映射几个位 的）</strong> 也需要权衡：</p> 
<ul><li><strong>个数越多</strong> 则布隆过滤器 bit 位置位 1 的速度越快，且<strong>布隆过滤器的效率越低</strong>；</li><li>但是如果<strong>太少</strong>的话，那我们的<strong>误报率会变高</strong></li></ul> 
<p><img src="https://images2.imgbox.com/3d/8b/jQIMzXGt_o.png" alt="在这里插入图片描述"><br> <mark><code>k</code> 为哈希函数个数（一个值映射几个位）</mark>，<code>m</code> 为布隆过滤器长度（有多少个位），<code>n</code> 为插入的元素个数（数据个数），<code>p</code> 为误报率</p> 
<p>由图可看出，当<code>k==3</code>时，就已经把 误报率<code>p</code> 由原来的<code>1</code>降低到接近<code>0.01</code>了。则映射位置再拉大，对误报率的降低也没差多少了。<mark>得出结论：一个值的映射位数，一般取3位，因此需三个映射函数。</mark></p> 
<br> 
<hr> 
<h3><a id="2__5_485"></a>讨论2：布隆过滤器长度 —— 开要进行插入元素个数的<code>5</code>倍大小</h3> 
<p><code>x</code>为哈希函数的个数，<code>m</code>是布隆过滤器的长度，<code>n</code>是插入元素的个数。经过研究发现，三者满足以下关系式时，布隆过滤器的误判率最低：</p> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         x 
        
       
         = 
        
       
         m 
        
       
         / 
        
       
         n 
        
       
         ∗ 
        
       
         l 
        
       
         n 
        
       
         2 
        
       
      
        x=m/n * ln2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">m</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">n</span><span class="mord">2</span></span></span></span></span></p> 
<p>由上得出的 <mark><strong>哈希函数个数<code>x</code> 的 最优数量大小是<code>3</code></strong></mark>，那么<mark>我们所开的<strong>布隆过滤器的长度大小<code>m</code></strong> 大约是 <strong>插入元素的个数<code>n</code></strong> 的 <strong><code>4.3</code>倍</strong></mark> 。因此我们自己模拟实现布隆过滤器我们取整数<code>5</code>倍：<code>bitset&lt;5 * N&gt; _bs;</code></p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span>size_t N<span class="token punctuation">,</span>       <span class="token comment">// 要插入数据的个数</span>
	<span class="token keyword">class</span> <span class="token class-name">K</span><span class="token operator">=</span> string<span class="token punctuation">,</span>	    <span class="token comment">// 常用于布隆过滤器的key值是string</span>
	<span class="token keyword">class</span> <span class="token class-name">Hash1</span>	<span class="token operator">=</span> HashFuncBKDR<span class="token punctuation">,</span>       <span class="token comment">// Hash1,Hash2,Hash3 通过不同的Hash哈希，分别映射到不同的三个位置</span>
	<span class="token keyword">class</span> <span class="token class-name">Hash2</span> <span class="token operator">=</span> HashFuncAP<span class="token punctuation">,</span> 
	<span class="token keyword">class</span> <span class="token class-name">Hash3</span> <span class="token operator">=</span> HashFuncDJB<span class="token operator">&gt;</span>
<span class="token keyword">class</span>  <span class="token class-name">BloomFilter</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">const</span> size_t M <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">*</span> N<span class="token punctuation">;</span>		<span class="token comment">// 【★】经研究得：布隆过滤器的长度最好是 开 要插入数据大小N 的 5倍</span>
	bitSet<span class="token operator">&lt;</span>M<span class="token operator">&gt;</span> _bs<span class="token punctuation">;</span>	    <span class="token comment">// 后面扩容，直接将bitSet的容器大小设置成M，方便后面扩容变动</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<br> 
<hr> 
<h3><a id="reset___513"></a>reset() 删除 不能实现</h3> 
<p><img src="https://images2.imgbox.com/b2/c9/CnjjQXGJ_o.png" alt="在这里插入图片描述"><br> 删除了百度，则腾讯有一个位被reset()为<code>0</code>，则一个位为<code>0</code>，则直接判断腾讯不存在，即出现了误判的情况 。</p> 
<br> 
<hr> 
<h2><a id="__521"></a>布隆过滤器 码源实现</h2> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;set&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"bitset.h"</span></span>


<span class="token keyword">struct</span> <span class="token class-name">HashFuncBKDR</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// BKDR</span>
	size_t <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		size_t hash <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> ch <span class="token operator">:</span> s<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			ch<span class="token operator">*=</span><span class="token number">131</span><span class="token punctuation">;</span>
			hash <span class="token operator">+=</span> ch<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> hash<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">HashFuncAP</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// AP</span>
	size_t <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		size_t hash <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>	   <span class="token comment">// 偶数位字符</span>
			<span class="token punctuation">{<!-- --></span>
				hash <span class="token operator">^=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>hash <span class="token operator">&lt;&lt;</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>hash <span class="token operator">&gt;&gt;</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span>       <span class="token comment">// 奇数位字符</span>
			<span class="token punctuation">{<!-- --></span>
				hash <span class="token operator">^=</span> <span class="token punctuation">(</span><span class="token operator">~</span><span class="token punctuation">(</span>hash <span class="token operator">&lt;&lt;</span> <span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>hash <span class="token operator">&gt;&gt;</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> hash<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">HashFuncDJB</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// DJB</span>
	size_t <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		size_t hash <span class="token operator">=</span> <span class="token number">5381</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> ch <span class="token operator">:</span> s<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			hash <span class="token operator">=</span> hash <span class="token operator">*</span> <span class="token number">33</span> <span class="token operator">^</span> ch<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">return</span> hash<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>



<span class="token keyword">template</span><span class="token operator">&lt;</span>size_t N<span class="token punctuation">,</span>       <span class="token comment">// 要插入数据的个数</span>
	<span class="token keyword">class</span> <span class="token class-name">K</span><span class="token operator">=</span> string<span class="token punctuation">,</span>	    <span class="token comment">// 常用于布隆过滤器的key值是string</span>
	<span class="token keyword">class</span> <span class="token class-name">Hash1</span>	<span class="token operator">=</span> HashFuncBKDR<span class="token punctuation">,</span>       <span class="token comment">// Hash1,Hash2,Hash3 通过不同的Hash哈希，分别映射到不同的三个位置</span>
	<span class="token keyword">class</span> <span class="token class-name">Hash2</span> <span class="token operator">=</span> HashFuncAP<span class="token punctuation">,</span> 
	<span class="token keyword">class</span> <span class="token class-name">Hash3</span> <span class="token operator">=</span> HashFuncDJB<span class="token operator">&gt;</span>
<span class="token keyword">class</span>  <span class="token class-name">BloomFilter</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">bool</span> <span class="token function">Set</span><span class="token punctuation">(</span><span class="token keyword">const</span> K<span class="token operator">&amp;</span> key<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		size_t hash1 <span class="token operator">=</span> <span class="token function">Hash1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> M<span class="token punctuation">;</span>
		size_t hash2 <span class="token operator">=</span> <span class="token function">Hash2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> M<span class="token punctuation">;</span>
		size_t hash3 <span class="token operator">=</span> <span class="token function">Hash3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> M<span class="token punctuation">;</span>

		_bs<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>hash1<span class="token punctuation">)</span><span class="token punctuation">;</span>
		_bs<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>hash2<span class="token punctuation">)</span><span class="token punctuation">;</span>
		_bs<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>hash3<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">bool</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">const</span> K<span class="token operator">&amp;</span> key<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		size_t hash1 <span class="token operator">=</span> <span class="token function">Hash1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> M<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>_bs<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>hash1<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span>		<span class="token comment">// 只要判断出一个位不在，那就是(准确的)不在</span>
			<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

		size_t hash2 <span class="token operator">=</span> <span class="token function">Hash2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> M<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>_bs<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>hash2<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span>		
			<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

		size_t hash3 <span class="token operator">=</span> <span class="token function">Hash3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> M<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>_bs<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>hash3<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span>		
			<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>	<span class="token comment">// 存在误判(有可能判断到这3个位都是在的，但可能这3个位都冲突了)</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 布隆过滤器不好实现reset(),</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">static</span> <span class="token keyword">const</span> size_t M <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">*</span> N<span class="token punctuation">;</span>		<span class="token comment">// 经研究得：布隆过滤器的长度最好是 开 要插入数据大小N 的 5倍	   // static是被放到静态区，不独属于对象，而是属于整个类</span>
	bitSet<span class="token operator">&lt;</span>M<span class="token operator">&gt;</span> _bs<span class="token punctuation">;</span>	    <span class="token comment">// 后面扩容，直接将bitSet的容器大小设置成M，方便后面扩容变动</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<br> 
<hr> 
<p><img src="https://images2.imgbox.com/f1/6c/EDzniTF8_o.png" alt="在这里插入图片描述"></p> 
<br> 
<p><img src="https://images2.imgbox.com/ef/db/GfeMvKnA_o.png" alt="在这里插入图片描述"></p> 
<p>为避免误判，先经过布隆过滤器判断：</p> 
<ul><li>在，有可能昵称未注册过，位置被其他数据映射到，而发生误判</li><li>不在，昵称没注册过 <mark>布隆过滤器的价值：（准确的，直接返回结果，提速，减少了数据库的访问压力）【以空间换时间】</mark></li></ul> 
<p>误判的，再到数据库中进行验证 。</p> 
<br> 
<hr> 
<h3><a id="_650"></a>经典面试题</h3> 
<ol><li>给两个文件，分别有100亿个query(查询)，我们只有1G内存，如何找到两个文件交集？分别给出精确算法和近似算法</li></ol> 
<ul><li>近似算法：把一个文件放到布隆过滤器里面，另外一个文件 再去看，在就是交集，不在就不是交集<br> 【为什么说是近似的：因为布隆过滤器筛选出来的值，存在误判，】<br> <br></li></ul> 
<hr> 
<ul><li>精确算法：</li></ul> 
<p><strong>哈希切分：都放到内存（数据结构<code>set</code>）里面，<strong>去重</strong>，找交集</strong></p> 
<ol><li> <p>内存大小<br> 假设一个query 平均50byte，100亿个query占用多少空间？1G 约等于 10亿字节，那么一共需要500G。</p> </li><li> <p>将数据存储到一个一个文件(细分一千份)中（文件的存储，就是单纯的字节流的存储）：<br> <mark>依次每一个query，<code>i = HashFunc(query) % 1000</code>，<strong>这个query就进入<code>Ai</code>文件中</strong></mark>：<br> <mark>存放的是这个query本身，而HashFunc计算出来的hash值，只是用来得出query内容要放入的文件的编号</mark>；</p> <p><mark>★ <font color="dark">A和B相同的query 一定会进入 <strong>编号相同的<code>Ai</code>和<code>Bi</code>小文件</strong></font></mark>；<mark><font color="dark"><strong>只需要 遍历编号相同的文件 找交集</strong></font></mark> 就可以了。<br> <strong>平均切</strong> 找交集 <strong><code>O(N^2)</code></strong>（平均切：每个Ai文件都去遍历一遍Bi的每个文件），<strong><font color="dark">哈希切</font></strong> 找交集 <strong><code>O(N)</code></strong>。<br> <br></p> </li></ol> 
<hr> 
<h4><a id="___676"></a>对于 切分的文件数量多少 的讨论</h4> 
<p>按理说，1G内存找切500份，<strong>这里切1000份，平均每份文件就是500M</strong>，<mark>因为哈希切分是有的文件是冲突的有点多</mark>，有的文件大，有的文件小，避免出现因单个文件的内存存储的空间不够了，而存到下一个文件中，则不能做到哈希切分，找到对应标号的文件。</p> 
<br> 
<hr> 
<ol start="3"><li>而后 <strong>将文件中的内容读到内存当中</strong>，运用内存当中的 <strong>哈希表<code>unordered_set</code></strong>、<strong>红黑树</strong> 进行处理，处理完了再把它清掉再读下一组文件：<br> Ai的query放 哈希表<code>set&lt;string&gt; seta</code>，Bi的query放 哈希表<code>set&lt;string&gt; setb</code>，<code>seta</code>和<code>setb</code>找交集即可</li></ol> 
<p><img src="https://images2.imgbox.com/83/2e/0n59RsG2_o.png" alt="在这里插入图片描述"></p> 
<br> 
<h4><a id="AiBi1G_690"></a>极端情况：某个文件冲突很多，导致<code>Ai</code>或者<code>Bi</code>太大了，比如超过1G，</h4> 
<p>那就 <strong>再走一层递归</strong>就可以了，<strong>再换一个哈希函数，再进行一次哈希切分</strong>。<br> <strong>还是解决不了，某个文件还是特别特别的大</strong>，那就是 因为<strong>文件中存放的大部分 都是 相同的值</strong> 。<br> <mark>但 文件存入到 哈希表<code>unordered_set</code>中，有去重功能，重复的值不会再次插入</mark>。</p> 
<p><mark><strong><font color="dark">因此不会出现 文件中冲突的值很多</font></strong>，<strong><font color="dark">是因为 重复的很多 而出现的 文件过大 的情况</font></strong> ，<strong>在存放进内存数据结构<code>set</code>中，就已经解决了这个问题</strong>。</mark><br> + 重复出现的值很多的情况，<code>set</code>就已经解决了<br> + <mark><strong>因此，只可能是因为其本身经过Hash函数后，哈希冲突还是很多 而造成的 。</strong></mark></p> 
<p>query 插入<code>set</code>里面时，倘若抛异常，则代表query太多，且重复不多 。<br> <img src="https://images2.imgbox.com/76/8a/G6G3mQk8_o.png" alt="在这里插入图片描述"><br> <strong>解决办法：进行二次处理：换个哈希函数，对Ai和Bi文件再进行哈希切分 。</strong></p> 
<br> 
<hr> 
<ol start="2"><li>如何扩展BloomFilter使得它支持删除元素的操作<br> 引用计数：每个位置 改成 多个位的引用计数 就可以支持 。比如一个映射位置给8个bit位标记，但是这样空间消耗太大了。<br> 以前位图只需要标记<code>0</code>,<code>1</code>，只需要标记 <strong>在</strong> 或者 <strong>不在</strong>；而启用计数后，在位图中，最起码得 额外开八个<code>bit</code>位( 八个位能表示出255个数 ) (在原来位图的基础上开 )来进行映射 。</li></ol> 
<p><a href="https://cloud.tencent.com/developer/article/1136056" rel="nofollow">Counting Bloom Filter 的原理和实现</a></p> 
<br> 
<hr> 
<h3><a id="iHashFuncquery100Ai__mapstring_int__topK_priority_queue_topKIP_717"></a><code>i=HashFunc(query)%100</code>哈希切分出各<code>Ai</code>文件 + <code>map&lt;string, int&gt;</code>统计次数 + <code>topK</code> <code>priority_queue</code>小堆 ：统计出<code>topK的IP</code>地址</h3> 
<p>给一个超过100G大小的log ﬁle, log中<strong>存着IP地址</strong>，设计算法 <strong>找到出现次数最多的IP地址</strong> ？<br> 与上题条件相同，如何找到 <strong>top K的IP</strong> ？如何直接用<strong>Linux系统命令实现</strong> ？</p> 
<p>分析：</p> 
<ul><li>用map和set：100G大小的数据 内存占用太大了，内存搞不定。</li><li>平均切分：这是个IP地址，平均切会*被分到不同的文件中。</li></ul> 
<br> 
<p>哈希切分：</p> 
<ol><li>依次读取每个<code>ip</code>，<strong><code>i = HashFunc(ip) % 100</code></strong>（一个文件开多大，取决于你设备的性能，最好是一个文件能放下 差不多两三百个IP地址 就好）</li><li><strong>每个<code>ip</code>就 进入对应算出的<code>Ai</code>小文件</strong>：能进入同一个<code>Ai</code>小文件的，要么是相同的IP，要么是哈希冲突的IP 。</li><li>依次使用 <strong><code>map&lt;string,int&gt; countMap</code>：统计每个文件<code>ip</code>的出现次数</strong> 。<br> （ 如果<strong>map抛异常，则说明冲突很多</strong>，小文件很大 =&gt; 必须得换 哈希函数，二次切分处理；相同的文件<code>ip</code>就只是<code>++int</code>并不会对内存上开辟新的内存空间占用 ）</li><li>然后 用 <strong><code>pair&lt;string, int&gt; maxIP</code>来依次遍历每个文件找出 出现次数最大的文件<code>ip</code></strong> ，比其大就进行更新，直到每个文件都遍历完了为止 。</li><li><strong><code>topK</code></strong> 就建立一个 <strong>小堆<code>priority_queue&lt; pair&lt;string, int&gt;, __?__ &gt; minHeap</code></strong>，<code>priority_queue</code>默认是大堆，因此此处若要实现 小堆 就需要自己实现 <strong>仿函数</strong>，<strong>根据需求 “取pair&lt;string, int&gt;中的second 进行比较”</strong> 。</li></ol> 
<br> 
<hr> 
<h3><a id="iHashFuncquery100Ai__mapint_int_Ai_741"></a><code>i=HashFunc(query)%100</code>哈希切分成各<code>Ai</code>文件 + <code>map&lt;int, int&gt;</code> 逐一遍历哈希切分出的各<code>Ai</code>文件：统计出现的次数</h3> 
<p>重新看回【 海量面试题 】：给定100亿个整数，设计算法找到只出现一次的整数</p> 
<p>原本采取的措施：</p> 
<ul><li>开双位图：来记录出现的次数<code>00 - 0次</code>，<code>01 - 1次</code>，<code>10 - 2次即以上</code></li><li>哈希切分：这里的类型是 整型，直接用 整型 去 <code>%</code>取模 就好了</li></ul> 
<h3><a id="__749"></a>海量数据处理 问题的特征</h3> 
<ol><li>数据量大，内存存不下<br> 如 哈希表unordered_map、红黑树 这样的数据结构</li><li>先考虑具有特点的数据结构能否解决？<br> 位图、堆、布隆过滤器（节省空间）</li><li>大事化小 思路<br> 文件指针，磁盘中的一个磁头来定位，真的效率太慢了<br> 哈希切分 [ 不能平均切分 ]：相同的值进入相同的文件<br> 找交集、统计次数</li><li>文件当中有很多数据，这个时候只是想找这个数据 单纯的在不在<br> B树/B+树</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/10e000223c4fd7a48f5f005fcfcd0d17/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">安卓的组件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/90b1462edcbb4d69f954d7196251387b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java面试八股之MySQL怎么优化查询语句</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>