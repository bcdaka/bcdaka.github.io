<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>30天拿下Rust之unsafe代码 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/4a793c4bf53075b3e212cd6e586aefa0/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="30天拿下Rust之unsafe代码">
  <meta property="og:description" content="概述 在Rust语言的设计哲学中，&#34;安全优先&#34; 是其核心原则之一。然而，在追求极致性能或者与底层硬件进行交互等特定场景下，Rust提供了unsafe关键字。unsafe代码允许开发者暂时脱离Rust的安全限制，直接操作内存和执行低级操作。虽然unsafe代码在某些情况下是必要的，但使用它时必须格外小心，以避免引入难以调试的内存错误。
什么是unsafe代码 在Rust中，unsafe关键字用于标记那些可能破坏Rust的内存安全保证的代码块，使用unsafe关键字编写的代码块或函数被称为unsafe代码。unsafe代码允许程序员执行诸如裸指针操作、类型转换和直接内存访问等低级别操作。由于这些操作可能导致未定义行为或内存安全漏洞，Rust编译器不会对它们进行常规的安全性检查。
unsafe代码主要用于以下三个场景。
性能优化：在某些性能关键的应用中，程序员可能会选择使用unsafe代码来绕过Rust的一些安全检查，以获得更高的性能。
底层系统编程：在操作系统开发、设备驱动或嵌入式系统编程中，可能需要直接操作硬件或使用特定的内存布局，这时就需要使用unsafe代码。
与C语言库交互：当使用Rust调用C语言编写的库时，可能需要执行一些不安全的操作来正确地管理内存和调用约定。
在Rust中，unsafe代码的使用主要涉及以下三个方面：使用裸指针、使用外部函数接口、实现不安全Trait，下面分别进行介绍。
使用裸指针 在Rust中，裸指针是一种可以绕过Rust的常规所有权和借用检查机制的低级工具。它允许程序员直接操作内存地址，从而进行更为底层和灵活的操作。然而，正因为裸指针绕过了Rust的内存安全保证，使用时必须格外小心，以避免引入未定义行为或内存安全问题。
裸指针有两种主要类型：*const T（指向常量数据的裸指针）和*mut T（指向可变数据的裸指针）。前者用于读取数据，后者用于读取和修改数据。
裸指针通常通过取址操作符&amp;和类型转换来创建。在下面的示例代码中，我们首先创建了一个整数x和一个可变的整数y。然后，我们使用取址操作符&amp;获取它们的地址，并通过类型转换将它们转换为裸指针raw_ptr和mut_raw_ptr 。获取裸指针并不是unsafe代码，解引用裸指针才是unsafe代码。
fn main() { let x = 66; let raw_ptr: *const i32 = &amp;x as *const i32; let mut y = 99; let mut_raw_ptr = &amp;mut y as *mut i32; } 解引用裸指针是通过在裸指针前使用*操作符来完成的，这允许我们读取或修改裸指针指向的值。注意：解引用裸指针时，必须确保指针是有效的，否则会导致未定义行为。
在下面的示例代码中，我们使用unsafe块来解引用裸指针。在unsafe块内，我们打印出raw_ptr指向的值，并将mut_raw_ptr指向的值修改为1024。
fn main() { let x = 66; let raw_ptr: *const i32 = &amp;x as *const i32; let mut y = 99; let mut_raw_ptr = &amp;mut y as *mut i32; unsafe { println!">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-01T07:00:00+08:00">
    <meta property="article:modified_time" content="2024-04-01T07:00:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">30天拿下Rust之unsafe代码</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>概述</h4> 
<p>        在Rust语言的设计哲学中，"安全优先" 是其核心原则之一。然而，在追求极致性能或者与底层硬件进行交互等特定场景下，Rust提供了unsafe关键字。unsafe代码允许开发者暂时脱离Rust的安全限制，直接操作内存和执行低级操作。虽然unsafe代码在某些情况下是必要的，但使用它时必须格外小心，以避免引入难以调试的内存错误。</p> 
<p></p> 
<h4>什么是unsafe代码</h4> 
<p>        在Rust中，unsafe关键字用于标记那些可能破坏Rust的内存安全保证的代码块，使用unsafe关键字编写的代码块或函数被称为unsafe代码。unsafe代码允许程序员执行诸如裸指针操作、类型转换和直接内存访问等低级别操作。由于这些操作可能导致未定义行为或内存安全漏洞，Rust编译器不会对它们进行常规的安全性检查。</p> 
<p>        unsafe代码主要用于以下三个场景。</p> 
<p>        <span style="color:#4da8ee;">性能优化</span>：在某些性能关键的应用中，程序员可能会选择使用unsafe代码来绕过Rust的一些安全检查，以获得更高的性能。</p> 
<p>        <span style="color:#4da8ee;">底层系统编程</span>：在操作系统开发、设备驱动或嵌入式系统编程中，可能需要直接操作硬件或使用特定的内存布局，这时就需要使用unsafe代码。</p> 
<p>        <span style="color:#4da8ee;">与C语言库交互</span>：当使用Rust调用C语言编写的库时，可能需要执行一些不安全的操作来正确地管理内存和调用约定。</p> 
<p>        在Rust中，unsafe代码的使用主要涉及以下三个方面：使用裸指针、使用外部函数接口、实现不安全Trait，下面分别进行介绍。</p> 
<p></p> 
<h4>使用裸指针</h4> 
<p>        在Rust中，裸指针是一种可以绕过Rust的常规所有权和借用检查机制的低级工具。它允许程序员直接操作内存地址，从而进行更为底层和灵活的操作。然而，正因为裸指针绕过了Rust的内存安全保证，使用时必须格外小心，以避免引入未定义行为或内存安全问题。</p> 
<p>        裸指针有两种主要类型：*const T（指向常量数据的裸指针）和*mut T（指向可变数据的裸指针）。前者用于读取数据，后者用于读取和修改数据。</p> 
<p>        裸指针通常通过取址操作符&amp;和类型转换来创建。在下面的示例代码中，我们首先创建了一个整数x和一个可变的整数y。然后，我们使用取址操作符&amp;获取它们的地址，并通过类型转换将它们转换为裸指针raw_ptr和mut_raw_ptr 。获取裸指针并不是unsafe代码，解引用裸指针才是unsafe代码。</p> 
<pre><code class="language-rust">fn main() {
    let x = 66;
    let raw_ptr: *const i32 = &amp;x as *const i32;

    let mut y = 99;
    let mut_raw_ptr = &amp;mut y as *mut i32;
}</code></pre> 
<p>        解引用裸指针是通过在裸指针前使用*操作符来完成的，这允许我们读取或修改裸指针指向的值。注意：解引用裸指针时，必须确保指针是有效的，否则会导致未定义行为。</p> 
<p>        在下面的示例代码中，我们使用unsafe块来解引用裸指针。在unsafe块内，我们打印出raw_ptr指向的值，并将mut_raw_ptr指向的值修改为1024。</p> 
<pre><code class="language-rust">fn main() {
    let x = 66;
    let raw_ptr: *const i32 = &amp;x as *const i32;

    let mut y = 99;
    let mut_raw_ptr = &amp;mut y as *mut i32;

    unsafe {
        println!("{}", *raw_ptr);
        *mut_raw_ptr = 1024;
        println!("{}", *mut_raw_ptr);
    }
}</code></pre> 
<p></p> 
<h4>使用外部函数接口</h4> 
<p>        在Rust中，使用unsafe关键字的一个常见场景是调用C语言或其他语言编写的库函数。Rust通过extern块和extern关键字提供了对外部函数的支持，而这些函数的调用通常需要标记为unsafe。这是因为，Rust编译器无法验证这些外部函数的行为是否符合Rust的内存安全规则。</p> 
<p>        假如我们有下面的C语言库，其Add接口为计算两个整数的和。</p> 
<pre><code class="language-cpp">// Add.h
#ifdef __cplusplus
extern "C" {
#endif

int Add(int a, int b);

#ifdef __cplusplus
}
#endif


// Add.c
#include "Add.h"

int Add(int a, int b)
{
    return a + b;
}</code></pre> 
<p>        在下面的示例代码中，我们首先引入了libc库。这是Rust提供的一个包含C语言类型的库，使得我们可以使用与C兼容的类型。然后，我们使用extern "C"块来声明C语言中的Add函数。注意：extern "C"告诉Rust编译器这个函数是用C语言的链接约定来链接的。</p> 
<p>        在main函数中，我们使用unsafe块来调用这个外部函数。这是必须的，因为Rust编译器无法验证这个C函数是否遵守Rust的内存安全规则。如果C函数违反了这些规则（比如解引用空指针或写入只读内存），那么Rust程序可能会崩溃或产生未定义行为。</p> 
<p>        最后，编译和运行这个Rust程序需要确保实现Add函数的C库是可用的。我们可能需要编译这个C库为动态链接库或静态库，并在编译Rust程序时链接这个库。另外，我们还需要在Cargo.toml 文件中添加类似下面的依赖性以引入libc库：<span style="color:#4da8ee;">libc = "0.2"</span>。</p> 
<pre><code class="language-rust">use libc::{c_int};

extern "C" {
    fn Add(a: c_int, b: c_int) -&gt; c_int;
}

fn main() {
    unsafe {
        let sum = Add(66, 99);
        println!("{}", sum);
    }
}</code></pre> 
<p></p> 
<h4>实现不安全Trait</h4> 
<p>        在Rust中，可以直接声明一个Trait是不安全的，即整个Trait都带有unsafe修饰符。也可以不声明Trait为不安全的，而在Trait的具体实现中使用unsafe来执行不安全的操作。这意味着，我们可以安全地定义一个Trait，但在其某个或某些具体实现中执行不安全操作。</p> 
<p>        在下面的示例代码中，UnsafeTrait声明了一个unsafe_method方法。CustomStruct实现了这个Trait，并提供了unsafe_method的一个默认实现，该实现是unsafe的。在main函数中，我们使用unsafe块来调用这个方法，因为我们知道这个调用可能涉及不安全操作。</p> 
<p>        重要的是，即使unsafe_method是在Trait中定义的，调用它的责任仍然落在调用者身上。调用者必须确保在调用unsafe方法时遵循所有安全准则，比如：确保传递给方法的参数是有效的，并处理任何可能由unsafe操作引起的错误或未定义行为。</p> 
<pre><code class="language-rust">trait UnsafeTrait {
    unsafe fn unsafe_method(&amp;self) -&gt; Result&lt;(), String&gt;;
}

struct CustomStruct;

impl UnsafeTrait for CustomStruct {
    unsafe fn unsafe_method(&amp;self) -&gt; Result&lt;(), String&gt; {
        // 在这里执行一些可能不安全的操作
        Ok(())
    }
}

fn main() {
    let my_struct = CustomStruct;
    unsafe {
        match my_struct.unsafe_method() {
            Ok(()) =&gt; println!("success"),
            Err(e) =&gt; println!("failed: {}", e),
        }
    }
}</code></pre> 
<p>        通常，应该尽量避免在Trait中使用unsafe，除非确实需要执行一些低级的、不安全的操作，并且调用者能够清楚地理解并处理这些不安全操作可能带来的风险。在大多数情况下，更好的做法是：使用安全的Rust特性来实现相关的需求。</p> 
<p></p> 
<h4>unsafe代码的安全抽象</h4> 
<p>        unsafe代码的安全抽象是一种设计模式，它允许开发者在不安全代码和安全代码之间建立清晰的边界。这种抽象通过封装不安全操作在安全的接口之后来实现，使得库的使用者能够在不了解或不关心内部实现细节的情况下安全地使用库的功能。这种设计模式的关键在于：将不安全代码限制在尽可能小的范围内，并通过安全的接口暴露给使用者。这样，库的使用者可以依赖这些安全的接口，而无需担心底层可能的不安全操作。</p> 
<p>        在下面的示例代码中，unsafe_operation函数执行一些不安全操作。然而，它并没有直接公开给库的使用者，而是被封装在safe_operation函数中。safe_operation函数是一个安全的接口，它内部使用unsafe块来调用unsafe_operation，但在调用前后可以添加额外的安全检查或清理工作。这样，库的使用者只需要调用safe_operation，而无需关心其内部是否使用了unsafe。</p> 
<pre><code class="language-rust">unsafe fn unsafe_operation() {
    // ...
}

pub fn safe_operation() {
    unsafe {
        unsafe_operation();
    }
    // 可以在这里添加额外的安全检查或清理工作
}
  
fn main() {
    safe_operation();
}</code></pre> 
<p>        通过安全抽象这种方式，库的设计者可以确保库的使用者不会误用不安全操作，同时仍然能够利用不安全代码提供的性能优势或底层功能。在构建大型Rust项目或库时，将不安全代码限制在最小的必要范围内，并通过安全的接口暴露功能是非常重要的。这有助于减少错误和漏洞的风险，同时提高代码的可维护性和可理解性。</p> 
<p></p> 
<h4>注意事项</h4> 
<p>        虽然unsafe并非完全不受控制，但它确实把内存安全的责任交还给了程序员。在编写unsafe代码时，我们需要特别注意以下几点。</p> 
<p>        1、最小化unsafe代码的使用。尽量将unsafe代码的使用限制在必要的范围内，并尽量避免在库或模块的公共API中使用它。</p> 
<p>        2、仔细审查unsafe代码。对unsafe代码进行严格的代码审查和测试，以确保它不会引入内存安全漏洞。</p> 
<p>        3、文档化unsafe代码。为unsafe代码提供清晰的文档说明，解释为什么需要使用它，以及使用它时需要注意的事项。</p> 
<p>        4、使用Rust的安全抽象。尽可能利用Rust提供的所有权模型、生命周期和借用检查器等安全抽象来减少unsafe代码的使用。</p> 
<p></p> 
<h4>总结</h4> 
<p>        Rust的unsafe代码是强大且必要的工具，它让Rust能够在提供高级抽象的同时，依然保留对底层资源的精细控制能力。然而，unsafe代码也是一个潜在的危险源。使用unsafe代码需要开发者具备足够的经验和谨慎，始终坚守Rust的内存和类型安全准则。只有这样，我们才能充分利用Rust的优势，构建出既高效又安全的系统级软件。</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8c002de5def4d75e171b4ca6c7d31253/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android输入法框架，安卓开发实战</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cb406c04b5eca1b72b372e2f10e189e3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Java初阶（七）】接口</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>