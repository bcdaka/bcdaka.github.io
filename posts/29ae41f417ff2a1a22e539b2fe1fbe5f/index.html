<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】二叉搜索树（Binary Search Tree）基本介绍 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/29ae41f417ff2a1a22e539b2fe1fbe5f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】二叉搜索树（Binary Search Tree）基本介绍">
  <meta property="og:description" content="目录
前言
一、什么是二叉搜索树
概念及其介绍
适用说明
二、C语言实例代码
1. 创建节点
2. 插入节点
3. 查找节点
4.主函数
三、内存中的栈与堆讲解
内存四区
程序运行时栈和堆的变化
结语
前言 最近正在学习数据结构，听的是mycodeschool.com中程序员Harsha Suryanarayana的课程，二叉搜索树是数据结构中的重点，并且比较难理解，所以我会按照这位老师的讲法把二叉搜索树这一部分以博客的形式记录下来，加深理解学习。如果有错误的地方，希望大家可以指出，帮助我改正，十分感谢。
一、什么是二叉搜索树 概念及其介绍 二叉搜索树（英语：Binary Search Tree，BST），也称为 二叉查找树 、二分搜索树 、有序二叉树或排序二叉树。满足以下几个条件：
若它的左子树不为空，左子树上所有节点的值都小于它的根节点。若它的右子树不为空，右子树上所有的节点的值都大于它的根节点。 它的左、右子树也都是二叉搜索树（因此可以使用递归实现）。
如下图所示：
适用说明 二分搜索树有着高效的插入、删除、查询操作。
平均时间的时间复杂度为 O(log n)，最差情况为 O(n)。二分搜索树与堆不同，不一定是完全二叉树，底层不容易直接用数组表示故采用链表来实现二分搜索树。
查找元素插入元素删除元素普通数组O(n)O(n)O(n)顺序数组O(logn)O(n)O(n)二分搜索树O(logn)O(logn)O(logn) 二、C语言实例代码 1. 创建节点 首先，我们需要定义一个节点结构，如下图所示，并创建一个新的节点。
//定义二叉搜索树的节点结构 struct Node { int data; struct Node* left; struct Node* right; }; //创建一个新的节点,返回一个指针 struct Node* createNode(int data) { struct Node* newNode = (struct Node*)malloc(sizeof(struct Node)); newNode-&gt;data = data; newNode-&gt;left = NULL; newNode-&gt;right = NULL; return newNode; } 2.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-23T17:40:33+08:00">
    <meta property="article:modified_time" content="2024-08-23T17:40:33+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】二叉搜索树（Binary Search Tree）基本介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>目录</strong></p> 
<p style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91" rel="nofollow">一、什么是二叉搜索树</a></p> 
<p style="margin-left:80px;"><a href="#%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E4%BB%8B%E7%BB%8D" rel="nofollow">概念及其介绍</a></p> 
<p style="margin-left:80px;"><a href="#%E9%80%82%E7%94%A8%E8%AF%B4%E6%98%8E" rel="nofollow">适用说明</a></p> 
<p style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81C%E8%AF%AD%E8%A8%80%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81" rel="nofollow">二、C语言实例代码</a></p> 
<p style="margin-left:80px;"><a href="#1.%20%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9" rel="nofollow">1. 创建节点</a></p> 
<p style="margin-left:80px;"><a href="#2.%20%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9" rel="nofollow">2. 插入节点</a></p> 
<p style="margin-left:80px;"><a href="#3.%20%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9" rel="nofollow">3. 查找节点</a></p> 
<p style="margin-left:80px;"><a href="#4.%E4%B8%BB%E5%87%BD%E6%95%B0" rel="nofollow">4.主函数</a></p> 
<p style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%A0%88%E4%B8%8E%E5%A0%86%E8%AE%B2%E8%A7%A3" rel="nofollow">三、内存中的栈与堆讲解</a></p> 
<p style="margin-left:80px;"><a href="#%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA" rel="nofollow">内存四区</a></p> 
<p style="margin-left:80px;"><a href="#%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%88%E5%92%8C%E5%A0%86%E7%9A%84%E5%8F%98%E5%8C%96" rel="nofollow">程序运行时栈和堆的变化</a></p> 
<p style="margin-left:0px;"><a href="#%E7%BB%93%E8%AF%AD" rel="nofollow">结语</a></p> 
<hr> 
<p> </p> 
<h2>前言</h2> 
<p>最近正在学习数据结构，听的是mycodeschool.com中程序员Harsha Suryanarayana的课程，二叉搜索树是数据结构中的重点，并且比较难理解，所以我会按照这位老师的讲法把二叉搜索树这一部分以博客的形式记录下来，加深理解学习。如果有错误的地方，希望大家可以指出，帮助我改正，十分感谢。</p> 
<hr> 
<h2>一、什么是二叉搜索树</h2> 
<h4>概念及其介绍</h4> 
<p>二叉搜索树（英语：Binary Search Tree，BST），也称为 二叉查找树 、二分搜索树 、有序二叉树或排序二叉树。满足以下几个条件：</p> 
<blockquote> 
 <ul><li>若它的左子树不为空，左子树上所有节点的值都小于它的根节点。</li><li>若它的右子树不为空，右子树上所有的节点的值都大于它的根节点。</li></ul> 
</blockquote> 
<p>它的左、右子树也都是二叉搜索树（因此可以使用递归实现）。</p> 
<p>如下图所示：</p> 
<p><img src="https://images2.imgbox.com/8f/6b/TFj1IwUz_o.png" alt="54f991a4a1264dc1845d13a403cbd9da.png"></p> 
<h4>适用说明</h4> 
<p>二分搜索树有着高效的插入、删除、查询操作。</p> 
<p>平均时间的时间复杂度为 <strong>O(log n)</strong>，最差情况为 <strong>O(n)</strong>。二分搜索树与堆不同，不一定是完全二叉树，底层不容易直接用数组表示故采用链表来实现二分搜索树。</p> 
<table><thead><tr><th> </th><th>查找元素</th><th>插入元素</th><th>删除元素</th></tr></thead><tbody><tr><td>普通数组</td><td>O(n)</td><td>O(n)</td><td>O(n)</td></tr><tr><td>顺序数组</td><td>O(logn)</td><td>O(n)</td><td>O(n)</td></tr><tr><td>二分搜索树</td><td>O(logn)</td><td>O(logn)</td><td>O(logn)</td></tr></tbody></table> 
<h2>二、C语言实例代码</h2> 
<h4>1. 创建节点</h4> 
<p>首先，我们需要定义一个节点结构，如下图所示，并创建一个新的节点。</p> 
<p><img src="https://images2.imgbox.com/8c/da/KDYss8kg_o.png" alt="57e9d2e39636467fbc56c4d07f288f83.png"></p> 
<pre><code class="language-cpp">//定义二叉搜索树的节点结构
struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

//创建一个新的节点,返回一个指针
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode-&gt;data = data;
    newNode-&gt;left = NULL;
    newNode-&gt;right = NULL;
    return newNode;
}</code></pre> 
<h4>2. 插入节点</h4> 
<p>插入节点的过程是递归的。我们从根节点开始，根据键值的大小决定是向左子树还是右子树插入。</p> 
<pre><code class="language-cpp">//插入一个节点到二叉搜索树中，返回根节点的地址
struct Node* insert(struct Node* root, int data) {
    if (root == NULL) {   //如果树是空的，创建一个新节点，把它设置为根节点
        root = createNode(data);
        return root;
    }

    if (data &lt; root-&gt;data) {
        root-&gt;left = insert(root-&gt;left, data);
    } else if (data &gt; root-&gt;data) {
        root-&gt;right = insert(root-&gt;right, data);
    }

    return root;
}

//主函数
int main()
{
    struct Node* root = NULL;//创建一个空的树
    insert(root, 20);
    insert(root, 40);
    insert(root, 70);
    insert(root, 60);
    insert(root, 80);
}</code></pre> 
<h4>3. 查找节点</h4> 
<p>查找节点的过程也是递归的。我们从根节点开始，根据键值的大小决定是向左子树还是右子树查找。</p> 
<pre><code class="language-cpp">//在二叉树中查找一个节点，返回一个指针
struct Node* search(struct Node* root, int data) {
    if (root == NULL || root-&gt;data == data) {
        return root;
    }

    if (data &lt; root-&gt;data) {
        return search(root-&gt;left, data);
    } else {
        return search(root-&gt;right, data);
    }
}
</code></pre> 
<h4>4.主函数</h4> 
<p>最后我们编写一个主函数来测试这些功能</p> 
<pre><code class="language-cpp">//主函数
int main() {
    struct Node* root = NULL;//创建一个空的树
    insert(root, 20);//在二叉树中插入一个节点
    insert(root, 40);
    insert(root, 70);
    insert(root, 60);
    insert(root, 80);
   
    int key = 40;//在二叉树中查找值为40的节点
    if (search(root, key) != NULL) {
        printf("%d 存在于二叉搜索树中。\n", key);
    }
    else {
        printf("%d 不存在于二叉搜索树中。\n", key);
    }

    key = 10;//在二叉树中查找值为10的节点
    if (search(root, key) != NULL) {
        printf("%d 存在于二叉搜索树中。\n", key);
    }
    else {
        printf("%d 不存在于二叉搜索树中。\n", key);
    }

    return 0;
}</code></pre> 
<h2>三、内存中的栈与堆讲解</h2> 
<h4>内存四区</h4> 
<p>系统分配给一个程序的内存，在经典的架构中可以被分为四部分，如下图所示，</p> 
<blockquote> 
 <p>代码区（Code)：用来存放程序的指令</p> 
 <p>全局区（Static/Global)：用于存放<strong>全局变量</strong>和<strong>静态变量</strong>以及<strong>常量</strong></p> 
 <p>栈区（Stack):  暂存空间，用来执行<strong>函数</strong>，暂存所有的<strong>局部变量</strong>和<strong>函数参数</strong>以及<strong>函数调用后返回的地址</strong></p> 
 <p>堆区（Heap):  <strong>自由储存空间</strong>，由程序员来进行分配，灵活性大，但其分配的速度较慢，地址不连续，容易碎片化</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/64/8d/yVxehPwy_o.png" alt="d907c7ce38ba4fc594bd7c4026ff8b83.png"></p> 
<h4>程序运行时栈和堆的变化</h4> 
<blockquote> 
 <p>程序首先进入main函数，栈中开辟出一部分空间给main函数，程序运行到第一行创建一个root指针指向空，运行到第二行main函数运行暂停，程序进入insert函数，分配栈帧给insert函数，在insert函数中因为root是空的，所以程序进入createNode函数，分配栈帧给createNode函数，insert函数停止运行，在堆中创建一个新的节点，栈中创建一个newNode指针指向这个节点，并给节点赋值，如下图所示。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/68/eb/Y3YeXxOl_o.png" alt="3217c88f14f64284a64dd7d9d550fc8b.png"></p> 
<blockquote> 
 <p>createNode函数结束，分配给它的栈帧将会被收回，将root指针返回给insert函数，继续运行insert函数，root指向节点，insert函数运行结束，栈帧收回，返回root指针，此时main函数中root指针指向节点。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/9e/52/rkoEEhcg_o.png" alt="d0df3cf641d1492ea1cfe9d6af141b5f.png"></p> 
<blockquote> 
 <p>程序继续执行下一行，main函数暂停，分配给insert函数所需的栈帧，root不为空，比较数据的大小，然后进行函数递归，root左节点再插入一个节点，新的root为空，再进入createNode函数创建一个新的节点，返回节点的指针。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/4b/7f/tsdj0q45_o.png" alt="6e3cd29cd4e74549b9bea9a6f571ef39.png"></p> 
<blockquote> 
 <p>creatNode函数栈帧被收回，继续执行insert，root指向新节点，insert函数暂停，返回到第一层insert函数，root地址返回给root-&gt;left,root-&gt;left指向新节点，也就是root指向的地址为200节点的左孩节点地址为150，因此这两个节点连接起来了，最后insert函数结束，控制返回到main这一行，此时二叉树成功插入两个节点。接下来程序执行过程和上面类似，就不再模拟演示了。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/f8/47/v9lM5gGl_o.png" alt="b49ea1740f73464bb59076f7ae1798dc.png"></p> 
<hr> 
<h2>结语</h2> 
<p>十分感谢大家能看到这里，这篇博客主要是对二叉搜索树进行一些基本介绍，和讲解它的运行逻辑，希望能对初学者带来一些帮助，也希望大家能提出宝贵的建议，下一篇将会解决二叉搜索树的一些问题和它的简单使用。</p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/35aff7594adc9b69c598159842ccf36e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">31套科技风PPT模版免费下载</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/edfd8333a26006a0f5acb191eee65518/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Tomcat 优化</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>