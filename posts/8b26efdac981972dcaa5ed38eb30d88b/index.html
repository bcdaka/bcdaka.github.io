<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>web播放rtsp流视频，使用webrtc毫秒级延迟 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/8b26efdac981972dcaa5ed38eb30d88b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="web播放rtsp流视频，使用webrtc毫秒级延迟">
  <meta property="og:description" content="目录
一、zlmediakit环境搭建和编译
1)、下载zlmediakit
2)、安装依赖
3)、编译webrtc
4)、启动zlmediakit
二、播放webrtc视频
1)、动态添加拉流代理
2)、播放视频 三、嵌入到自己的vue项目中。
1)、拷贝demo到自己的vue项目中
2)、mkcert生成证书
背景：需要在web应用中播放摄像头的rtsp流视频，并且延迟需要做到1秒以内。试过网上很多方法，都不能做到1秒内的延迟，可能有这种方案，只是我还没找到。所以我尝试了使用zlmediakit的webrtc功能进行播放。效果不错，视频画面很实时，目前只做了初步尝试，实际应用还需要研究。下面是我的步骤：
系统：在ubuntu20.04和树莓派的raspberrypi系统都有尝试。
一、zlmediakit环境搭建和编译 1)、下载zlmediakit #下载代码 git clone https://github.com/ZLMediaKit/ZLMediaKit.git cd ZLMediaKit #千万不要忘记执行这句命令 git submodule update --init 2)、安装依赖 gcc #一般系统都会自带gcc,可以使用命令gcc -v 查看版本 #如果没有的话使用以下命令安装 sudo apt-get install build-essential cmake #先查看系统有没有已经安装 cmake --version #没安装就使用以下命令安装 sudo apt-get install cmake openssl #首先查看是否已经安装 openssl version #没安装使用以下命令安装 sudo apt-get install libssl-dev 3)、编译webrtc 编译libsrtp #依次执行以下命令 git clone https://gitee.com/mirrors/cisco-libsrtp.git cd cisco-libsrtp ./configure --enable-openssl make -j4 sudo make install 编译Zlmediakit 回到zlmediakit目录下 #依次执行以下命令 mkdir build cd build cmake -DENABLE_WEBRTC=on .">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-09-19T15:44:43+08:00">
    <meta property="article:modified_time" content="2023-09-19T15:44:43+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">web播放rtsp流视频，使用webrtc毫秒级延迟</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81zlmediakit%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E7%BC%96%E8%AF%91-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81zlmediakit%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E7%BC%96%E8%AF%91" rel="nofollow">一、zlmediakit环境搭建和编译</a></p> 
<p id="1)%E3%80%81%E4%B8%8B%E8%BD%BDzlmediakit-toc" style="margin-left:80px;"><a href="#1%29%E3%80%81%E4%B8%8B%E8%BD%BDzlmediakit" rel="nofollow">1)、下载zlmediakit</a></p> 
<p id="2)%E3%80%81%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96-toc" style="margin-left:80px;"><a href="#2%29%E3%80%81%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96" rel="nofollow">2)、安装依赖</a></p> 
<p id="3)%E3%80%81%E7%BC%96%E8%AF%91webrtc-toc" style="margin-left:80px;"><a href="#3%29%E3%80%81%E7%BC%96%E8%AF%91webrtc" rel="nofollow">3)、编译webrtc</a></p> 
<p id="4)%E3%80%81%E5%90%AF%E5%8A%A8zlmediakit-toc" style="margin-left:80px;"><a href="#4%29%E3%80%81%E5%90%AF%E5%8A%A8zlmediakit" rel="nofollow">4)、启动zlmediakit</a></p> 
<p id="%E4%BA%8C%E3%80%81%E6%92%AD%E6%94%BEwebrtc%E8%A7%86%E9%A2%91-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E6%92%AD%E6%94%BEwebrtc%E8%A7%86%E9%A2%91" rel="nofollow">二、播放webrtc视频</a></p> 
<p id="1)%E3%80%81%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%8B%89%E6%B5%81%E4%BB%A3%E7%90%86-toc" style="margin-left:80px;"><a href="#1%29%E3%80%81%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%8B%89%E6%B5%81%E4%BB%A3%E7%90%86" rel="nofollow">1)、动态添加拉流代理</a></p> 
<p id="2)%E3%80%81%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91%C2%A0-toc" style="margin-left:80px;"><a href="#2%29%E3%80%81%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91%C2%A0" rel="nofollow">2)、播放视频 </a></p> 
<p id="%E4%B8%89%E3%80%81%E5%B5%8C%E5%85%A5%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E3%80%82-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%B5%8C%E5%85%A5%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E3%80%82" rel="nofollow">三、嵌入到自己的vue项目中。</a></p> 
<p id="1)%E3%80%81%E6%8B%B7%E8%B4%9Ddemo%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84vue%E9%A1%B9%E7%9B%AE%E4%B8%AD-toc" style="margin-left:80px;"><a href="#1%29%E3%80%81%E6%8B%B7%E8%B4%9Ddemo%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84vue%E9%A1%B9%E7%9B%AE%E4%B8%AD" rel="nofollow">1)、拷贝demo到自己的vue项目中</a></p> 
<p id="2)%E3%80%81mkcert%E7%94%9F%E6%88%90%E8%AF%81%E4%B9%A6-toc" style="margin-left:80px;"><a href="#2%29%E3%80%81mkcert%E7%94%9F%E6%88%90%E8%AF%81%E4%B9%A6" rel="nofollow">2)、mkcert生成证书</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p></p> 
<blockquote> 
 <p>背景：需要在web应用中播放摄像头的rtsp流视频，并且延迟需要做到1秒以内。试过网上很多方法，都不能做到1秒内的延迟，可能有这种方案，只是我还没找到。所以我尝试了使用zlmediakit的webrtc功能进行播放。效果不错，视频画面很实时，目前只做了初步尝试，实际应用还需要研究。下面是我的步骤：</p> 
</blockquote> 
<p> 系统：在ubuntu20.04和树莓派的raspberrypi系统都有尝试。</p> 
<h2 id="%E4%B8%80%E3%80%81zlmediakit%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E7%BC%96%E8%AF%91">一、zlmediakit环境搭建和编译</h2> 
<h4 id="1)%E3%80%81%E4%B8%8B%E8%BD%BDzlmediakit">1)、下载zlmediakit</h4> 
<pre><code class="language-bash">#下载代码
git clone https://github.com/ZLMediaKit/ZLMediaKit.git
cd ZLMediaKit
#千万不要忘记执行这句命令
git submodule update --init</code></pre> 
<h4 id="2)%E3%80%81%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96">2)、安装依赖</h4> 
<ul><li>gcc</li></ul> 
<pre><code class="language-bash">#一般系统都会自带gcc,可以使用命令gcc -v 查看版本

#如果没有的话使用以下命令安装
sudo apt-get install build-essential</code></pre> 
<ul><li>cmake</li></ul> 
<pre><code class="language-bash">#先查看系统有没有已经安装
cmake --version

#没安装就使用以下命令安装
sudo apt-get install cmake</code></pre> 
<ul><li>openssl</li></ul> 
<pre><code class="language-bash">#首先查看是否已经安装
openssl version
#没安装使用以下命令安装
sudo apt-get install libssl-dev</code></pre> 
<h4 id="3)%E3%80%81%E7%BC%96%E8%AF%91webrtc">3)、编译webrtc</h4> 
<ul><li>编译libsrtp</li></ul> 
<pre><code class="language-bash">#依次执行以下命令
git clone https://gitee.com/mirrors/cisco-libsrtp.git
cd cisco-libsrtp
./configure --enable-openssl
make -j4
sudo make install
</code></pre> 
<ul><li> 编译Zlmediakit</li></ul> 
<p>回到zlmediakit目录下 </p> 
<pre><code class="language-bash">#依次执行以下命令
mkdir build
cd build
cmake -DENABLE_WEBRTC=on ../
cmake --build . --target MediaServer</code></pre> 
<p> 当进度变成100%就是编译完成了，可以看到目录下多了一个release目录。</p> 
<p><img alt="" height="206" src="https://images2.imgbox.com/aa/49/BESqeSKJ_o.png" width="1200"></p> 
<h4 id="4)%E3%80%81%E5%90%AF%E5%8A%A8zlmediakit">4)、启动zlmediakit</h4> 
<pre><code class="language-bash">cd release/linux/Debug
#通过-h可以了解启动参数
./MediaServer -h
#以守护进程模式启动
./MediaServer -d &amp;

</code></pre> 
<p>  建议先使用sudo ./MediaServer 启动，可以方便查看日志<img alt="" height="622" src="https://images2.imgbox.com/74/0c/rbjc9p7l_o.png" width="1200"></p> 
<p>这时候zlmediakit已经启动了， 可以在浏览器输入虚拟机地址加上/webrtc访问webrtc播放demo</p> 
<p><img alt="" height="942" src="https://images2.imgbox.com/b6/6b/b0h42V0n_o.png" width="1200"></p> 
<p>这时候还不能播放视频，需要将摄像头视频流注册到zlmediakit中，可以使用zlm的restful接口添加拉流代理，下面将有介绍。</p> 
<h2 id="%E4%BA%8C%E3%80%81%E6%92%AD%E6%94%BEwebrtc%E8%A7%86%E9%A2%91">二、播放webrtc视频</h2> 
<h4 id="1)%E3%80%81%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%8B%89%E6%B5%81%E4%BB%A3%E7%90%86">1)、动态添加拉流代理</h4> 
<p>在zlm官方文档中，有对restful接口的说明<a href="https://github.com/zlmediakit/ZLMediaKit/wiki/MediaServer%E6%94%AF%E6%8C%81%E7%9A%84HTTP-API" title="https://github.com/zlmediakit/ZLMediaKit/wiki/MediaServer%E6%94%AF%E6%8C%81%E7%9A%84HTTP-API">https://github.com/zlmediakit/ZLMediaKit/wiki/MediaServer%E6%94%AF%E6%8C%81%E7%9A%84HTTP-API</a></p> 
<p>我们只需要使用这个动态添加拉流代理的接口即可</p> 
<p><img alt="" height="678" src="https://images2.imgbox.com/d7/38/gwQDw9tQ_o.png" width="1000"></p> 
<p>首先打开api工具，我这里使用的是apipost,当然还有其他的比如postman、apifox都是可以的。 </p> 
<p>输入请求地址，发送的请求是post请求</p> 
<p><img alt="" height="496" src="https://images2.imgbox.com/65/48/t44XLGHi_o.png" width="1200"></p> 
<p>根据文档中所需要填入的参数，我们这里将几个必选的参数加上，其中secret需要我们在配置文件中查看，打开/ZlmediaKit/release/linux/Debug目录，有一个config.ini文件，使用nano config.ini命令打开，可以看到secret的内容，我们将后面的字符串复制下来</p> 
<p><img alt="" height="512" src="https://images2.imgbox.com/a4/3f/fb6zlXIx_o.png" width="1162"></p> 
<p>在api工具中，我们在query里填入参数如下:</p> 
<p><img alt="" height="490" src="https://images2.imgbox.com/79/dc/lwpCxFAz_o.png" width="1200"></p> 
<blockquote> 
 <p> secret就是我们刚刚获取的密钥。</p> 
 <p>vhost就填入运行zlm机器的ip就行。</p> 
 <p>app是流应用名，可以写live。</p> 
 <p>stream是流id,我们需要保证每个流id是唯一的，可以使用当前时间的时间戳,时间戳可以在ctool.dev中获取。</p> 
 <p>url为摄像头rtsp流地址，以海康摄像头为例，流地址组成格式为：rtsp://账号:密码@ip:554/h264/ch1/sub/av_stream,这里使用的是sub子码流，如果想用主码流换成main即可。</p> 
</blockquote> 
<p>填写完成后点击发送，可以看到响应code为0,还响应了一个key,这个key就是我们拼接播放地址所需要的</p> 
<p><img alt="" height="238" src="https://images2.imgbox.com/e7/2c/gELxb9gW_o.png" width="904"></p> 
<h4 id="2)%E3%80%81%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91%C2%A0">2)、播放视频 </h4> 
<p>打开前面那个/webrtc/播放demo界面，将url中的ip和stream的值改成实际的值就可以点击开始播放了。</p> 
<p><img alt="" height="992" src="https://images2.imgbox.com/f1/3d/NqtzXYli_o.png" width="1200"></p> 
<p>到此web中使用webrtc播放rtsp视频就结束了。下面我将介绍在自己的vue项目中播放的方法。</p> 
<h2 id="%E4%B8%89%E3%80%81%E5%B5%8C%E5%85%A5%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E3%80%82">三、嵌入到自己的vue项目中。</h2> 
<h4 id="1)%E3%80%81%E6%8B%B7%E8%B4%9Ddemo%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84vue%E9%A1%B9%E7%9B%AE%E4%B8%AD" style="background-color:transparent;">1)、拷贝demo到自己的vue项目中</h4> 
<p>在release/linux/Debug目录下有一个www目录，进入后有一个webrtc目录，将里卖弄的index.html和ZLMRTCClient.js拷贝出来。</p> 
<p><img alt="" height="98" src="https://images2.imgbox.com/8c/90/19LCx6J5_o.png" width="1200"></p> 
<p>将ZLMRTCClient.js拷贝到自己的vue项目中，在文件的最下方加入</p> 
<pre><code class="language-javascript">export {
	ZLMRTCClient
}</code></pre> 
<p>创建一个player.vue文件，将index.html文件中的内容拷贝到.vue文件下，根据自己的需求，将一些选项隐藏掉，将值改为固定的即可，文末我会给出我的player.vue完整代码。</p> 
<p>因为webrtc是基于https协议的，我们还需要解决证书问题，这里我选用一个开源项目mckert来生成证书。</p> 
<h4 id="2)%E3%80%81mkcert%E7%94%9F%E6%88%90%E8%AF%81%E4%B9%A6">2)、mkcert生成证书</h4> 
<p>我这里使用windows本地开发的，所以直接在mkcert官网下载exe文件就可以。</p> 
<p><a href="https://github.com/FiloSottile/mkcert/releases" title="https://github.com/FiloSottile/mkcert/releases">https://github.com/FiloSottile/mkcert/releases</a></p> 
<p>下载后将整个exe文件拖入终端命令行，加上-install,如下图</p> 
<p><img alt="" height="134" src="https://images2.imgbox.com/b8/b9/1nY1yl8q_o.png" width="1166"></p> 
<p>回车执行安装。</p> 
<p>在工程下新建一个keys文件夹，进入到keys文件夹下，再次将exe拖入终端，执行如下命令</p> 
<p><img alt="" height="106" src="https://images2.imgbox.com/41/c9/pF2UZaGR_o.png" width="1200"></p> 
<p>这时候keys文件夹下会生成两个文件</p> 
<p><img alt="" height="148" src="https://images2.imgbox.com/84/e0/UilGqg1n_o.png" width="508"></p> 
<p>我使用的是vite搭建的vue项目，所以我在vite.config.js中配置以下内容</p> 
<pre><code class="language-javascript">server:{
    https:{
        key: 'keys/localhost+1-key.pem',
        cert: 'keys/localhost+1.pem',
    }
}</code></pre> 
<p>重启系统便可以看到访问地址变成了https开头</p> 
<p><img alt="" height="140" src="https://images2.imgbox.com/72/00/i2l3Azja_o.png" width="650"></p> 
<p>这时候便可以在你的项目中播放摄像头rtsp视频流了。</p> 
<p>下面是我的player.vue代码，写的比较粗糙，凑合用。我只保留了输入url和开始停止按钮。手动输入正确的url点击开始就可以播放了。</p> 
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div class="play-content"&gt;
    &lt;div&gt;
      &lt;video id="video" controls autoplay style="text-align: left;width: 60%;"&gt;
        Your browser is too old which doesn't support HTML5 video.
      &lt;/video&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;p&gt;
        &lt;label for="streamUrl"&gt;url:&lt;/label&gt;
        &lt;input
          type="text"
          style="co"
          v-model="PlayUrl"
          id="streamUrl"
        /&gt;
      &lt;/p&gt;
      &lt;button @click="start()"&gt;开始(start)&lt;/button&gt;
      &lt;button @click="stop()"&gt;停止(stop)&lt;/button&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import {ZLMRTCClient} from '../../utils/ZLMRTCClient'
import {ref}from 'vue'

var player = null
var recvOnly = false
var resArr = []

var ishttps = 'https:' == document.location.protocol ? true : false
var isLocal = 'file:' == document.location.protocol ? true : false
var url =
  document.location.protocol +
  '//' +
  window.location.host +
  '/index/api/webrtc?app=live&amp;stream=test&amp;type=play'
if (!ishttps &amp;&amp; !isLocal) {
  alert(
    '本demo需要在https的网站访问 ,如果你要推流的话(this demo must access in site of https if you want push stream)'
  )
}
if (isLocal) {
  url = 'http://127.0.0.1' + '/index/api/webrtc?app=live&amp;stream=test&amp;type=play'
}
// document.getElementById('streamUrl').value = url
const PlayUrl = ref(url)

const start_play = () =&gt; {
  let h = 720
  let w = 1280

  player = new ZLMRTCClient.Endpoint({
    element: document.getElementById('video'), // video 标签
    debug: true, // 是否打印日志
    zlmsdpUrl: document.getElementById('streamUrl').value, //流地址
    simulcast: false,
    useCamera: true,
    audioEnable: true,
    videoEnable: true,
    recvOnly: recvOnly,
    resolution: { w: w, h: h },
    usedatachannel: false
  })

  player.on(ZLMRTCClient.Events.WEBRTC_ICE_CANDIDATE_ERROR, function (e) {
    // ICE 协商出错
    console.log('ICE 协商出错')
  })

  player.on(ZLMRTCClient.Events.WEBRTC_ON_REMOTE_STREAMS, function (e) {
    //获取到了远端流，可以播放
    console.log('播放成功', e.streams)
  })

  player.on(ZLMRTCClient.Events.WEBRTC_OFFER_ANWSER_EXCHANGE_FAILED, function (e) {
    // offer anwser 交换失败
    console.log('offer anwser 交换失败', e)
    stop()
  })


  player.on(ZLMRTCClient.Events.CAPTURE_STREAM_FAILED, function (s) {
    // 获取本地流失败

    console.log('获取本地流失败')
  })

  player.on(ZLMRTCClient.Events.WEBRTC_ON_CONNECTION_STATE_CHANGE, function (state) {
    // RTC 状态变化 ,详情参考 https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/connectionState
    console.log('当前状态==&gt;', state)
  })

  player.on(ZLMRTCClient.Events.WEBRTC_ON_DATA_CHANNEL_OPEN, function (event) {
    console.log('rtc datachannel 打开 :', event)
  })

  // player.on(ZLMRTCClient.Events.WEBRTC_ON_DATA_CHANNEL_MSG, function (event) {
  //   console.log('rtc datachannel 消息 :', event.data)
  //   document.getElementById('msgrecv').value = event.data
  // })
  player.on(ZLMRTCClient.Events.WEBRTC_ON_DATA_CHANNEL_ERR, function (event) {
    console.log('rtc datachannel 错误 :', event)
  })
  player.on(ZLMRTCClient.Events.WEBRTC_ON_DATA_CHANNEL_CLOSE, function (event) {
    console.log('rtc datachannel 关闭 :', event)
  })
}

const start = () =&gt; {
  stop()

  let h = 720
  let w = 1280

  if (!recvOnly) {
    ZLMRTCClient.isSupportResolution(w, h)
      .then((e) =&gt; {
        start_play()
      })
      .catch((e) =&gt; {
        alert('not support resolution')
      })
  } else {
    start_play()
  }
}
const stop = () =&gt; {
  if (player) {
    player.close()
    player = null
    var remote = document.getElementById('video')
    if (remote) {
      remote.srcObject = null
      remote.load()
    }

  }
}
&lt;/script&gt;

&lt;style scoped&gt;
.play-content{
  background-color: black;
  border: red 1px solid;
  width: 100%;
  height: 100%;
  color: white;
}
&lt;/style&gt;

</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/378f744ac24b61417909b3284856187f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">推荐几款实用的Google浏览器插件（各种翻译）——AI时代 实现 无障碍阅读各种英文网站</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ca1f07aad4ea38855270cd2dfc592d8d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python做学生信息管理系统,python学生信息管理系统</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>