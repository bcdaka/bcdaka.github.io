<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】栈和队列的深度探索，从实现到应用详解 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/4ff4e9aea327e247b1cefa8a70b88850/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】栈和队列的深度探索，从实现到应用详解">
  <meta property="og:description" content="💎所属专栏：数据结构与算法学习 💎 欢迎大家互三：2的n次方_
🍁1. 栈的介绍 栈是一种后进先出的数据结构，栈中的元素只能从栈顶进行插入和删除操作，类似于叠盘子，最后放上去的盘子最先拿下来。
🍁2. 栈的基本操作 压栈（Push）：将一个元素压入栈顶。出栈（Pop）：移除并返回栈顶元素。栈顶元素（Peek）：返回栈顶元素但不移除。判空（IsEmpty）：检查栈是否为空。栈的大小（Size）：返回栈中的元素个数。 栈的定义方法也是和ArrayList一样的，然后就是使用对象去调用栈的方法
public class Text { public static void main(String[] args) { Stack&lt;Integer&gt; stack1 = new Stack&lt;&gt;(); stack1.push(1); stack1.push(2); stack1.push(3); System.out.println(stack1.pop()); System.out.println(stack1.peek()); System.out.println(stack1.isEmpty()); System.out.println(stack1.size()); } } 🍁3. 栈的实现 首先，栈是通过数组实现的，就像之前实现的顺序表一样
public class MyStack { public int[] elem; public int usedSize; public MyStack() { this.elem = new int[10]; } } 接下来实现一些栈的基本操作
🍁3.1 push() 当1 2 3 4依次入栈时，如下图
入栈其实很简单，只需要把元素放进去，接着usedSize&#43;&#43;就可以了，但是学习数据结构我们的思维要严谨，如果栈满了怎么办，所以还需要处理栈满的情况，栈满之后就扩容，扩容也是和之前的顺序表一样的，判断是否栈满了也很简单，只需要判断数组的长度和usedSize是否相等就可以了
public void push(int val) { if(isFull()) { this.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-15T07:10:00+08:00">
    <meta property="article:modified_time" content="2024-07-15T07:10:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】栈和队列的深度探索，从实现到应用详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p class="img-center"><img alt="在这里插入图片描述" src="https://images2.imgbox.com/d3/23/KSr4yVXA_o.gif"></p> 
<blockquote> 
 <p></p> 
 <p class="img-center"><img alt="" height="418" src="https://images2.imgbox.com/72/db/ZIEDke3h_o.gif" width="759"></p> 
 <p style="text-align:center;"></p> 
 <p style="text-align:center;">💎<strong><span style="color:#38d8f0;">所属专栏：<a class="link-info" href="https://blog.csdn.net/2202_76097976?spm=1010.2135.3001.5343" title="数据结构与算法学习">数据结构与算法学习</a> </span></strong></p> 
 <p style="text-align:center;">💎 <strong><span style="color:#38d8f0;">欢迎大家互三：</span><a class="link-info" href="https://blog.csdn.net/2202_76097976?spm=1010.2135.3001.5343" title="2的n次方_">2的n次方_</a></strong></p> 
</blockquote> 
<h2>🍁<span style="color:#fe2c24;">1. 栈的介绍</span></h2> 
<p>栈是一种<strong><span style="background-color:#ffd900;">后进先出</span></strong>的数据结构，栈中的元素<span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">只能从栈顶进行插入和删除操作</span></strong></span>，类似于叠盘子，最后放上去的盘子最先拿下来。</p> 
<h2>🍁<span style="color:#fe2c24;">2. 栈的基本操作</span></h2> 
<ul><li><strong>压栈（Push）</strong>：将一个元素压入栈顶。</li><li><strong>出栈（Pop）</strong>：移除并返回栈顶元素。</li><li><strong>栈顶元素（Peek）</strong>：返回栈顶元素但不移除。</li><li><strong>判空（IsEmpty）</strong>：检查栈是否为空。</li><li><strong>栈的大小（Size）</strong>：返回栈中的元素个数。</li></ul> 
<p><img alt="" height="362" src="https://images2.imgbox.com/64/b0/X33RnvHv_o.png" width="972"></p> 
<p>栈的定义方法也是和ArrayList一样的，然后就是使用对象去调用栈的方法</p> 
<pre><code class="language-java">public class Text {
    public static void main(String[] args) {
        Stack&lt;Integer&gt; stack1 = new Stack&lt;&gt;();
        stack1.push(1);
        stack1.push(2);
        stack1.push(3);
        System.out.println(stack1.pop());
        System.out.println(stack1.peek());
        System.out.println(stack1.isEmpty());
        System.out.println(stack1.size());
    }
}</code></pre> 
<h2>🍁<span style="color:#fe2c24;">3. 栈的实现</span></h2> 
<p>首先，栈是通过数组实现的，就像之前实现的顺序表一样</p> 
<pre><code class="language-java">public class MyStack {
    public int[] elem;
    public int usedSize;

    public MyStack() {
        this.elem = new int[10];
    }
}
</code></pre> 
<p>接下来实现一些栈的基本操作</p> 
<h3>🍁<span style="color:#fe2c24;">3.1 push()</span></h3> 
<p><span style="color:#0d0016;">当1 2 3 4依次入栈时，如下图</span></p> 
<p><img alt="" height="366" src="https://images2.imgbox.com/3b/50/glLCwDIa_o.png" width="449"></p> 
<p></p> 
<p>入栈其实很简单，只需要把元素放进去，接着usedSize++就可以了，但是学习数据结构我们的思维要严谨，如果栈满了怎么办，所以还需要处理栈满的情况，栈满之后就扩容，扩容也是和之前的顺序表一样的，判断是否栈满了也很简单，只需要判断数组的长度和usedSize是否相等就可以了</p> 
<pre><code class="language-java">   public void push(int val) {
        if(isFull()) {
            this.elem = Arrays.copyOf(elem,2*elem.length);
        }
        elem[usedSize++] = val;
   }
   public boolean isFull() {
        return usedSize == elem.length;
   }</code></pre> 
<h3>🍁<span style="color:#fe2c24;">3.2 pop()</span></h3> 
<p>遵循后进先出的原则，第一次出栈取到的元素是4</p> 
<p><img alt="" height="365" src="https://images2.imgbox.com/73/ec/aZQCDlUY_o.png" width="519"></p> 
<p>那怎么去实现这个效果呢</p> 
<p>只需要定义一个val，把栈顶的元素取出来，赋值给val，进行返回，同时出栈之后usedSize的值要减1</p> 
<p>之后还需要考虑栈为空的情况，如果栈为空，肯定是不能再进行出栈的操作了，此时就需要抛出一个异常</p> 
<pre><code class="language-java">    public int pop() {
        if(isEmpty()){
            throw new EmptyStackException();
        }
        int val = elem[usedSize - 1];
        usedSize--;
        return val;
    }
    public boolean isEmpty() {
        return usedSize == 0;
    }</code></pre> 
<p>判断栈为空只需要判断usedSize是否为空</p> 
<h3>🍁<span style="color:#fe2c24;">3.3 peek()</span></h3> 
<p>peek(）是获取栈顶元素，但是不删除，这个其实更简单，只需要把下标为usedSize的元素进行返回就可以了，也不需要usedSize--</p> 
<p>同时，还是需要处理一下栈为空的情况</p> 
<pre><code class="language-java">    public int peek() {
        if(usedSize == 0){
            throw new EmptyStackException();
        }
        return elem[usedSize - 1];
    }</code></pre> 
<blockquote> 
 <p>接下来把之前写的方法测试一下：</p> 
</blockquote> 
<pre><code class="language-java">public class Text {
    public static void main(String[] args) {
        MyStack stack = new MyStack();
        stack.push(1);
        stack.push(2);
        stack.push(3);
        System.out.print(stack.pop() + " ");
        System.out.print(stack.pop() + " ");
        System.out.print(stack.peek() + " ");
    }
}</code></pre> 
<p><img alt="" height="125" src="https://images2.imgbox.com/e6/80/4QrhXBY0_o.png" width="434"></p> 
<h2>🍁<span style="color:#fe2c24;">4. 栈的使用场景</span></h2> 
<h3><span style="color:#0d0016;">🍁</span><span style="color:#fe2c24;">4.1 链表实现栈</span></h3> 
<p>问题：单链表是否可以实现栈？</p> 
<p><img alt="" height="151" src="https://images2.imgbox.com/af/e3/XKfZKyBR_o.png" width="533"></p> 
<p>单链表其实是可以实现栈的，用链表实现的栈叫做链式栈</p> 
<p><span style="color:#956fe7;">入栈：如果采用尾插法入栈，入栈的时间复杂度为O(n)，如果给出last节点为O(1),出栈的时间复杂度为O(n),因为需要遍历到末尾才能入栈</span></p> 
<p><span style="color:#956fe7;">如果采用头插法，入栈和出栈的时间复杂度都是O(1)</span></p> 
<p><span style="color:#956fe7;">既然单链表可以实现栈了，那么双向链表肯定也可以实现栈，不论是头插还是尾插，双链表实现的栈出栈和入栈时间复杂度都是O(1)。</span></p> 
<p><img alt="" height="629" src="https://images2.imgbox.com/6d/ec/dUtih2CW_o.png" width="1137"></p> 
<p>而且会发现，LinkedList也定义了栈的一些基本操作，可以当作栈来使用</p> 
<h3>🍁<span style="color:#fe2c24;">4.2 将递归转化为循环</span></h3> 
<p>一个典型的例子就是逆序打印链表，我们都知道，正常情况下，单链表是不能逆序打印的，递归的调用就类似于栈，最外面的一层先被打印，也就是最末尾元素最先打印，还可以通过栈来模拟递归</p> 
<pre><code class="language-java">    //递归方式
    private void printList1(MySingleList.ListNode head){
        if(head!=null){
            printList1(head.next);
            System.out.print(head.value + " ");
        }
    }
    //循环方式
    private void printList2(MySingleList.ListNode head){
        if(head == null) return;
        Stack&lt;MySingleList.ListNode&gt; s = new Stack&lt;&gt;();
        MySingleList.ListNode cur = head;
        //将节点保存在栈中
        while(cur!=null){
            s.push(cur);
            cur = cur.next;
        }
        //打印栈中节点
        while(!s.empty()){
            System.out.print(s.pop().value + " ");
        }
    }</code></pre> 
<h2>🍁<span style="color:#fe2c24;">5. 队列的介绍</span></h2> 
<p>队列是一种<span style="background-color:#ffd900;">先进先出</span>的数据结构。队列中的元素只能从队尾插入，从队首移除，类似于排队买票，最先排队的人最先买到票。</p> 
<p><img alt="" height="486" src="https://images2.imgbox.com/56/49/yF1ZM4dK_o.png" width="1172"></p> 
<p> Java中的Queue是一个接口，Deque叫做双端队列</p> 
<h2>🍁6. 队列的基本操作</h2> 
<ol><li><strong>入队（offer）</strong>：将一个元素插入队尾。</li><li><strong>出队（poll）</strong>：移除并返回队首元素。</li><li><strong>队首元素（Peek）</strong>：返回队首元素但不移除。</li><li><strong>判空（IsEmpty）</strong>：检查队列是否为空。</li><li><strong>队列的大小（Size）</strong>：返回队列中的元素个数。</li></ol> 
<p><img alt="" height="283" src="https://images2.imgbox.com/c9/9d/OrXrmnYP_o.png" width="922">由于Queue是一个接口，不能直接创建对象，所以这里通过LinkedList来创建对象 </p> 
<pre><code class="language-java">public class Text {
    public static void main(String[] args) {
        //使用接口的实现类LinkedList创建对象
        Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;();
        q.offer(1);
        q.offer(2);
        q.offer(3);
        //出队
        System.out.println(q.poll());
        //获取对头元素
        System.out.println(q.peek());
    }
}
</code></pre> 
<h2>🍁<span style="color:#fe2c24;">7. 队列的实现</span></h2> 
<h3>🍁<span style="color:#fe2c24;">7.1 双向链表实现队列</span></h3> 
<p>双向链表的话，和栈一样，入队和出队的操作时间复杂度为O(n)，因为队列是先进先出的原则，入队就采用尾插的方法，出队也就是头删的方法</p> 
<pre><code class="language-java">public class MyQueue {
    //双向链表
    static class ListNode {
        public int val;
        ListNode pre;
        ListNode next;

        public ListNode(int val) {
            this.val = val;
        }
    }

    ListNode first = null;
    ListNode last = null;
    public int usedSize = 0;
    //尾插的方法进行入队
    public void offer(int val) {
        ListNode node = new ListNode(val);
        if (isEmpty()) {
            first = last = node;
        } else {
            last.next = node;
            node.pre = last;
            last = last.next;
        }
        usedSize++;
    }
    //头删的方法进行出队
    public int poll() {
        if (first == null) {
            throw new EmptyQueueException("队列为空");
        }
        int value = first.val;
        first = first.next;
        if(first!=null){
            first.pre = null;
        }
        usedSize--;
        return value;
    }
    //获取队头元素
    public int peek() {
        if (first == null) {
            throw new EmptyQueueException("队列为空");
        }
        return first.val;
    }

    public boolean isEmpty() {
        return usedSize == 0;
    }
}</code></pre> 
<h3>🍁<span style="color:#fe2c24;">7.2 数组实现的循环队列</span></h3> 
<p><span style="color:#0d0016;">如果采用正常的数组来实现队列的话就会有以下的弊端，</span></p> 
<p> <img alt="" height="500" src="https://images2.imgbox.com/40/07/LZ4i9WSB_o.png" width="775"></p> 
<p>这样出队之后，数组前面的空间就会空出来，造成空间的浪费，那如何把这些空间也利用起来呢</p> 
<p><img alt="" height="345" src="https://images2.imgbox.com/ef/6c/ACtOML1s_o.png" width="974"></p> 
<p>使用这样的循环结构，就可以解决这个问题，也就是循环队列</p> 
<blockquote> 
 <p>front和rear在同一个位置时，表示队列为空，那么队列满了也是这样的情况，此时怎么区分呢？</p> 
 <p><strong><span style="color:#fe2c24;">1.定义一个size专门判断</span></strong></p> 
 <p><strong><span style="color:#fe2c24;">2.添加标记，定义一个boolean类型的flag，表示走过没有</span></strong></p> 
 <p><strong><span style="color:#fe2c24;">3.空出一个空间，此时rear.next == front就表示队列已满 </span></strong></p> 
</blockquote> 
<p></p> 
<p class="img-center"><img alt="" height="282" src="https://images2.imgbox.com/78/d6/bZHGYyxQ_o.png" width="315"></p> 
<p></p> 
<p>此时还有一个问题：对于以上的例子，怎么解决下标的问题，例如从7下标是怎么到0下标的</p> 
<p> 也就是下标最后再往后怎么表示：</p> 
<p>公式：(数组下标 - 偏移量) % 数组长度 </p> 
<p>7 ~ 0  可以通过 （7 + 1）% 8 来表示</p> 
<p>还有一种情况：下标最前再往前</p> 
<p><img alt="" height="359" src="https://images2.imgbox.com/4c/9b/XHIrRDzY_o.png" width="906"></p> 
<p>例如 2 下标往前走到 7 下标</p> 
<p>公式：(数组下标 + 数组长度 - 偏移量) % 数组长度 </p> 
<p>（2 + 9 - 4）% 9，加上数组长度也就是为了避免负数的情况</p> 
<p>代码</p> 
<p>测试用例</p> 
<p>测试用例</p> 
<p>测试结果</p> 
<p><a href="https://leetcode.cn/problems/design-circular-queue/" rel="nofollow" title="622. 设计循环队列">622. 设计循环队列</a></p> 
<p>我们通过力扣上的这道题来实现一下：</p> 
<pre><code class="language-java">class MyCircularQueue {
    public int front;
    public int rear;
    public int[] elem;

    public MyCircularQueue(int k) {
        elem = new int[k + 1];//由于有一个位置空出来了，所以要额外再多一个位置
    }

    public boolean enQueue(int value) {
        if (isFull()) {
            return false;
        }
        elem[rear] = value;
        rear = (rear + 1) % elem.length;
        return true;
    }

    public boolean deQueue() {
        if (isEmpty()) {
            return false;
        }
        front = (front + 1) % elem.length;
        return true;
    }

    public int Front() {
        if (isEmpty()) {
            return -1;
        } else {
            return elem[front];
        }
    }

    public int Rear() {
        if (isEmpty())
            return -1;
        int index = (rear == 0 )? elem.length - 1 : rear - 1;
        return elem[index];
    }

    public boolean isEmpty() {
        return rear == front;
    }

    public boolean isFull() {
        return (rear + 1) % elem.length == front;
    }
}</code></pre> 
<h2 style="background-color:transparent;">🍁<span style="color:#fe2c24;">8. 双端队列 </span></h2> 
<p>在Java中，<code>Deque</code>（双端队列）是一个接口，它扩展了<code>Queue</code>接口。<code>Deque</code>支持在两端插入和删除元素，提供了比<code>Queue</code>更丰富的操作集合。可以使用<code>Deque</code>作为栈（后进先出）、队列（先进先出）、或者两者兼有。</p> 
<blockquote> 
 <p>Java提供了几种<code>Deque</code>的实现，其中最常见的是<code>ArrayDeque</code>和<code>LinkedList</code>。<code>ArrayDeque</code>是基于数组的双端队列，它在大多数操作中都提供了更好的性能。而<code>LinkedList</code>也实现了<code>Deque</code>接口，但由于其基于链表的结构，它在添加和删除元素时可能不如<code>ArrayDeque</code>高效。</p> 
</blockquote> 
<pre><code class="language-java">public class DequeDemo {
    public static void main(String[] args) {
        //线性实现
        Deque&lt;Integer&gt; deque = new ArrayDeque&lt;&gt;();
        deque.add(1);
        deque.add(2);
        deque.add(3);
        for(int i : deque){
            System.out.println(i);
        }
        //链式实现
        Deque&lt;Integer&gt; ldeque = new LinkedList&lt;&gt;();
        ldeque.add(1);
        ldeque.add(1);
        ldeque.add(1);
        for(int i : ldeque){
            System.out.println(i);
        }
    }
}</code></pre> 
<p class="img-center"><img alt="在这里插入图片描述" src="https://images2.imgbox.com/5b/59/cV4oAUsY_o.gif"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/38068c6b668842815c258d17676a4b67/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">在Ubuntu 14.04上安装和保护phpMyAdmin的方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dd220b54af82543c7dee7e5a7606eec4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Hadoop数仓中常用端口详解:(第36天)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>