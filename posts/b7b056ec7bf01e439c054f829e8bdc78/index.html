<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;】高精度模板大整合！高精度模板看这篇真的就够了 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b7b056ec7bf01e439c054f829e8bdc78/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;】高精度模板大整合！高精度模板看这篇真的就够了">
  <meta property="og:description" content="版本信息 版本号版本内容版本时间V 1.0.0 高精定义
高精加高精（普通&#43;负数版）
高精减高精（普通&#43;负数版）
高精乘高精（普通&#43;负数版）
高精除高精（普通&#43;负数版）
高精取模高精（普通&#43;负数版）
高精加低精（普通版）
高精减低精（普通版）
高精乘低精（普通版）
高精除低精（普通版）
高精取模低精（普通版）
高精开根低精（普通版）
2023/9/29 开工
2023/9/30 完工
引语 大家好！本期我们来看一下高精度的C&#43;&#43;代码
首先感谢一下那些为我提供帮助的人，主要包括CSDN和洛谷的好心人
制作不易，求支持qwq
正文 高精度定义 高精度算法（High Accuracy Algorithm）是处理大数字的数学计算方法。在一般的科学计算中，会经常算到小数点后几百位或者更多，当然也可能是几千亿几百亿的大数字。一般这类数字我们统称为高精度数，高精度算法是用计算机对于超大数据的一种模拟加，减，乘，除，乘方，阶乘，开方等运算。对于非常庞大的数字无法在计算机中正常存储，于是，将这个数字拆开，拆成一位一位的，或者是四位四位的存储到一个数组中， 用一个数组去表示一个数字，这样这个数字就被称为是高精度数。高精度算法就是能处理高精度数各种运算的算法，但又因其特殊性，故从普通数的算法中分离，自成一家。
——百度百科
高精度op高精度 高精度加法（高精度加高精度） 普通版 #include &lt;bits/stdc&#43;&#43;.h&gt; using namespace std; // 函数名称:add // 函数参数:两个vector&lt;int&gt; // 函数返回值:一个vector&lt;int&gt; // 函数功能:返回输入的两个vector的和 // 中文名称:高精度加法 vector &lt;int&gt; add(vector&lt;int&gt; &amp;A,vector&lt;int&gt; &amp;B){ if (A.size() &lt; B.size()) return add(B,A); // 因为下面for循环用A.size()当条件，所以现在只能让A比B长 vector&lt;int&gt; C; int t = 0; for(int i = 0;i &lt; A.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-09-30T18:32:30+08:00">
    <meta property="article:modified_time" content="2023-09-30T18:32:30+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;】高精度模板大整合！高精度模板看这篇真的就够了</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>版本信息</h2> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><thead><tr><th>版本号</th><th>版本内容</th><th>版本时间</th></tr></thead><tbody><tr><td><strong>V 1.0.0</strong></td><td> <p>高精定义</p> <p>高精加高精（普通+负数版）</p> <p>高精减高精（普通+负数版）</p> <p>高精乘高精（普通+负数版）</p> <p>高精除高精（普通+负数版）</p> <p>高精取模高精（普通+负数版）</p> <p>高精加低精（普通版）</p> <p>高精减低精（普通版）</p> <p>高精乘低精（普通版）</p> <p>高精除低精（普通版）</p> <p>高精取模低精（普通版）</p> <p>高精开根低精（普通版）</p> </td><td> <p>2023/9/29 开工</p> <p>2023/9/30 完工</p> </td></tr></tbody></table> 
<h2>引语</h2> 
<blockquote> 
 <p>大家好！本期我们来看一下高精度的C++代码</p> 
 <p>首先感谢一下那些为我提供帮助的人，主要包括CSDN和洛谷的好心人</p> 
 <p>制作不易，求支持qwq</p> 
</blockquote> 
<hr> 
<h2>正文</h2> 
<hr> 
<h3> 高精度定义</h3> 
<blockquote> 
 <p><strong>高精度算法</strong>（<strong>High Accuracy Algorithm</strong>）是处理大数字的数学计算方法。在一般的<a href="https://baike.baidu.com/item/%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97/10573887?fromModule=lemma_inlink" rel="nofollow" title="科学计算">科学计算</a>中，会经常算到小数点后几百位或者更多，当然也可能是几千亿几百亿的大数字。一般这类数字我们统称为高精度数，高精度算法是用计算机对于超大数据的一种模拟加，减，乘，除，<a href="https://baike.baidu.com/item/%E4%B9%98%E6%96%B9/9539611?fromModule=lemma_inlink" rel="nofollow" title="乘方">乘方</a>，<a href="https://baike.baidu.com/item/%E9%98%B6%E4%B9%98/4437932?fromModule=lemma_inlink" rel="nofollow" title="阶乘">阶乘</a>，<a href="https://baike.baidu.com/item/%E5%BC%80%E6%96%B9/5705?fromModule=lemma_inlink" rel="nofollow" title="开方">开方</a>等运算。对于非常庞大的数字无法在<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338?fromModule=lemma_inlink" rel="nofollow" title="计算机">计算机</a>中正常存储，于是，将这个数字拆开，拆成一位一位的，或者是四位四位的存储到一个<a href="https://baike.baidu.com/item/%E6%95%B0%E7%BB%84/3794097?fromModule=lemma_inlink" rel="nofollow" title="数组">数组</a>中， 用一个数组去表示一个数字，这样这个数字就被称为是高精度数。高精度算法就是能处理高精度数各种运算的算法，但又因其特殊性，故从普通数的算法中分离，自成一家。</p> 
 <p>                                                                                                                            ——百度百科</p> 
</blockquote> 
<hr> 
<h3>高精度op高精度</h3> 
<h4>高精度加法（高精度加高精度）</h4> 
<h5>普通版</h5> 
<div> 
 <pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std; 
// 函数名称:add
// 函数参数:两个vector&lt;int&gt;
// 函数返回值:一个vector&lt;int&gt;
// 函数功能:返回输入的两个vector的和 
// 中文名称:高精度加法 
vector &lt;int&gt; add(vector&lt;int&gt; &amp;A,vector&lt;int&gt; &amp;B){
	if (A.size() &lt; B.size()) return add(B,A); // 因为下面for循环用A.size()当条件，所以现在只能让A比B长
	vector&lt;int&gt; C;
	int t = 0;
	for(int i = 0;i &lt; A.size();i++){
		t += A[i];
		if(i &lt; B.size()) t += B[i]; // 判断B是否够长 
		C.push_back(t % 10);
		t /= 10;
	}
	if (t) C.push_back(t);
	return C;
}

// 应用部分
vector &lt;int&gt; A,B,C; // 请不要将这个定义放在函数上面 
string CA,CB;// 因为A、B过长，所以需要使用字符串读入
int main(){
    cin &gt;&gt; CA &gt;&gt; CB;
	// 别忘了是逆序读入 
	for (int i = CA.size() - 1;i &gt;= 0;i--) A.push_back(CA[i] - '0');
	for (int i = CB.size() - 1;i &gt;= 0;i--) B.push_back(CB[i] - '0');
	C = add(A,B);
	// 逆序输出 
	for (int i = C.size() - 1;i &gt;= 0;i--) cout &lt;&lt; C[i];
	cout &lt;&lt; endl; 
    return 0;
}</code></pre> 
</div> 
<h5>能处理负数版 </h5> 
<div> 
 <pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
// 可以处理负数 
char a[1000005],b[1000005];
int fa,fb,la,lb;
void show(int ed) {
	if (fa) cout &lt;&lt; "-";
	for (int i = ed;i &gt;= fa;--i)
		printf("%d",a[i]);
}
void add(){
	int i,j,t = 0,s,l;
	for (i = fa;i &lt; la || i &lt; lb;++i) {
		s = a[i] + b[i] + t;
		t = s / 10;
		a[i] = s % 10;
	}
	a[i] = t;
	l = t ? i : i - 1;
	show(l);
}
int cmp(){
	int la = strlen(a),lb = strlen(b);
	if (la - fa &gt; lb - fb) return 1;
	else if (la - fa &lt; lb - fb) return 0;
	else{
		int i;
		for (i = 0;i &lt; la &amp;&amp; a[i + fa] == b[i + fb];++i);
		return a[i + fa] &gt; b[i + fb];
	}
}
void minu(){
	int i,j,c = 0,l = -1,s;
	for (i = 0;i + fa &lt; la;i++) {
		s = a[i + fa] - b[i + fb] - c &gt;= 0 ? 0 : 1;
		a[i + fa] = (10 + a[i + fa] - b[i + fb] - c) % 10;
		l = a[i + fa] ? i + fa : l,c = s;
	}
	if (l &lt; 0) cout &lt;&lt; 0;
	else show(l);
}

// 应用部分 
int main(){
	scanf("%s%s",a,b);
	fa = ('-' == a[0]), fb = ('-' == b[0]);
	if (!cmp()) swap(a, b),swap(fa, fb);
	la = strlen(a), lb = strlen(b);
	reverse(a + fa, a + la),reverse(b + fb, b + lb);
	int i = fa,j = fb;
	while (i &lt; la) a[i] -= '0',i++;
	while (j &lt; lb) b[j] -= '0',j++;
	if (fa ^ fb) minu();
	else add();
	return 0;
}</code></pre> 
</div> 
<h4>高精度减法（高精度减高精度）</h4> 
<h5>普通版</h5> 
<div> 
 <pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
// 函数名称:cmp
// 函数参数:两个vector&lt;int&gt;
// 函数返回值:true或false 
// 函数功能:返回输入的第一个vector&lt;int&gt;是否大于第二个vector&lt;int&gt; 
// 函数备注:请与减法sub1配合使用 
// 中文名称:高精度大小判断 
bool cmp(vector&lt;int&gt; &amp;A,vector&lt;int&gt; &amp;B){
	if (A.size() != B.size()) return A.size() &gt; B.size();
	for (int i = A.size() - 1;i &gt;= 0;i++){
		if (A[i] != B[i]) return A[i] &gt; B[i];
	}
	return true;
}
// 函数名称:sub
// 函数参数:两个vector&lt;int&gt;
// 函数返回值:一个vector&lt;int&gt;
// 函数功能:返回输入的两个vector的差 
// 函数备注:请与判断大小cmp配合使用 
// 中文名称:高精度减法 
vector &lt;int&gt; sub(vector&lt;int&gt; &amp;A,vector&lt;int&gt; &amp;B){
    vector &lt;int&gt; C;
    int t = 0;
    for(int i = 0; i &lt; A.size(); i++){
        t = A[i] - t;
        if(i &lt; B.size()) t -= B[i];
        C.push_back((t + 10) % 10); // t+10是为了避免t&lt;0 
        if(t &lt; 0) t = 1; // 借位 
        else t = 0; // 不借位 
    }
    while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();  //去掉前导0
    return C;
}

// 应用部分
vector &lt;int&gt; A,B,C; // 请不要将这个定义放在函数上面 
string CA,CB;// 因为A、B过长，所以需要使用字符串读入
int main(){
    cin &gt;&gt; CA &gt;&gt; CB;
	// 别忘了是逆序读入 
	for (int i = CA.size() - 1;i &gt;= 0;i--) A.push_back(CA[i] - '0');
	for (int i = CB.size() - 1;i &gt;= 0;i--) B.push_back(CB[i] - '0');
	if (cmp(A,B)){
        C = sub(A,B);
        for (int i = C.size() - 1;i &gt;= 0;i--) cout &lt;&lt; C[i];
    }else{
        C = sub(B,A);
        cout &lt;&lt; "-";
        for (int i = C.size() - 1;i &gt;= 0;i--) cout &lt;&lt; C[i];
    }
    cout &lt;&lt; endl;
    return 0;
}</code></pre> 
</div> 
<h5>能处理负数版 </h5> 
<div> 
 <pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
string a,b,s,t;
int fa,fb;
void init(){
	fa = (a[0] == '-'), fb = (b[0] == '-');
	s = a.substr( 1, a.size() ), t = b.substr( 1, b.size() );
}
bool cmp(string a,string b){
	int as = a.size(), bs = b.size();
	if (as &gt; bs || as == bs &amp;&amp; a &gt; b) return 1;
	else return 0;
}
void change(string &amp;s,string &amp;t,string a,string b) {
	int as = a.size(), bs = b.size(),d = as &gt; bs ? as - bs : bs - as;
	for (int i = 0;i &lt; d;i++) as &gt; bs ? t += "0" : s += "0";
	s += a,t += b;
}
string cA(string a,string b){
	string s = "0", t = "0";
	change(s,t,a,b);
	int len = s.size();
	for (int i = len - 1;i &gt;= 1;i--){
		s[i] += t[i] - '0';
		if (s[i] &gt; '9') s[i] -= 10,s[i - 1]++;
	}
	bool j = 1;
	for ( int i = 0;i &lt; len;i++)
		if (s[i] != '0') j = 0;
	if (j) return "0";
	return s[0] == '0' ? s.substr( 1, len ) : s;
}
string cB(string a,string b){
	string s = "", t = "";
	change(s,t,a,b);
	if (s &lt; t) swap(s,t);
	int len = s.size();
	for (int i = len - 1;i &gt;= 0;i--){
		if (s[i] &lt; t[i]){
			s[i] += 10;
			if (s[i - 1] &gt;= '1') s[i - 1]--;
			else{
				int j = i - 1;
				while (s[j] == '0') s[j--] += 9;
				s[j]--;
			}
		}
		s[i] -= (t[i] - '0');
	}
	if (len == 1) return s;
	return s[0] == '0' ? cA(s.substr(1,len),"0") : s;
}

// 应用部分 
int main() {
	cin &gt;&gt; a &gt;&gt; b;
	init();
	if (fa &amp;&amp; fb){
		if (cmp(s, t)) cout &lt;&lt; "-";
		cout &lt;&lt; cB(s,t) &lt;&lt; endl;
	}else if (!fa &amp;&amp; !fb){
		if (!cmp(a, b) ) cout &lt;&lt; "-";
		cout &lt;&lt; cB(a,b) &lt;&lt; endl;
	}else if (fa) cout &lt;&lt; "-" &lt;&lt; cA(s,b) &lt;&lt; endl;
	else cout &lt;&lt; cA(a,t) &lt;&lt; endl;
	return 0;
}</code></pre> 
</div> 
<h4>高精度乘法（高精度乘高精度）</h4> 
<h5>普通版</h5> 
<div> 
 <pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
// 函数名称:mul
// 函数参数:两个vector&lt;int&gt;
// 函数返回值:一个vector&lt;int&gt;
// 函数功能:返回输入的两个vector的积 
// 中文名称:高精度乘法 
vector &lt;int&gt; mul(vector &lt;int&gt; &amp;A, vector &lt;int&gt; &amp;B) {
    vector &lt;int&gt; C(A.size() + B.size(), 0);
    for (int i = 0; i &lt; A.size(); i ++) {
	    for (int j = 0; j &lt; B.size(); j ++){
		    C[i + j] += A[i] * B[j];
		    C[i + j + 1] += C[i + j] / 10;
		    C[i + j] %= 10;
		}
    }
    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();
    return C;
}

// 应用部分 
vector &lt;int&gt; A,B,C;
string CA,CB; // 字符串存储 
int main(){
	cin &gt;&gt; CA &gt;&gt; CB;
	for (int i = CA.size() - 1;i &gt;= 0;i--) A.push_back(CA[i] - '0');
	for (int i = CB.size() - 1;i &gt;= 0;i--) B.push_back(CB[i] - '0');
	C = mul(A,B);
	for (int i = C.size() - 1;i &gt;= 0;i--) cout &lt;&lt; C[i]; 
	cout &lt;&lt; endl;
	return 0;
}</code></pre> 
</div> 
<h5> 能处理负数版</h5> 
<div> 
 <pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
// 可以处理负数版
const int T = 1000000;
char a1[T],b1[T];
int a[T],b[T],c[T],lena,lenb,lenc,x,t,f;
void mul() {
	for (int i = 1;i &lt;= lena;i++) {
		x = 0; //x是进位
		for (int j = 1;j &lt;= lenb;j++) {
			c[i + j - 1] += a[i] * b[j] + x;
			x = c[i + j - 1] / 10;
			c[i + j - 1] %= 10;
		}
		c[i + lenb] = x;
	}
	lenc = lena + lenb;
	while (c[lenc] == 0 &amp;&amp; lenc &gt; 1) lenc--;
	if (f == -1) cout &lt;&lt; "-";
	for (int i = lenc;i &gt;= 1;i--) cout &lt;&lt; c[i];
	cout &lt;&lt; endl;
}

// 应用部分 
int main() {
	cin &gt;&gt; a1 &gt;&gt; b1 ;
	lena = strlen(a1), lenb = strlen(b1);
	f = 1, t = 0;
	if (a1[0] == '-') f *= -1, t++;
	for (int i = t;i &lt;= lena - 1;i++) a[lena - i] = a1[i] - '0'; // 转换为int 
	t = 0;
	if (b1[0] == '-') f *= -1,t++;
	for (int i = t;i &lt;= lenb - 1;i++) b[lenb - i] = b1[i] - '0';
	mul();
	return 0;
}</code></pre> 
</div> 
<h4>高精度除法（高精度除高精度）</h4> 
<h5>普通版（带余数）</h5> 
<div> 
 <pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
// 减法部分
int a[101],b[101],c[101],d,i;
void inp(int a[]){ // 读入 
    string s;
    cin &gt;&gt; s; //读入字符串
    a[0] = s.size(); //a[0]储存字符串的长度
    for (i = 1;i &lt;= a[0];i++) a[i] = s[a[0] - i] - '0';
}
void pri(int a[]){ // 输出 
    if (a[0] == 0){
    	cout &lt;&lt; "0" &lt;&lt; endl;
		return;
	}
    for (i = a[0];i &gt; 0;i--) cout &lt;&lt; a[i];
    cout &lt;&lt; endl;
    return;
}
int cmp(int a[],int b[]){//比较a和b的大小关系，若a&gt;b则为1，若a&lt;b则为-1，若a=b则为0
    if (a[0] &gt; b[0]) return 1;  //若a的位数大于b，则a&gt;b
    if (a[0] &lt; b[0]) return -1;  //若a的位数小于b，则a&lt;b
    for (i = a[0];i &gt; 0;i--){
    	if (a[i] &gt; b[i]) return 1;
		if (a[i] &lt; b[i]) return -1;
	}
    return 0;
}
void jian(int a[],int b[]){ 
    int pd = cmp(a,b); // 比较大小 
    if (pd == 0){ // 相等 
    	a[0] = 0;
		return;
	}else if (pd == 1){
        for (i = 1;i &lt;= a[0];i++){
            if (a[i] &lt; b[i]) a[i + 1]--,a[i] += 10; // 借位 
            if (a[i] &gt;= b[i]) a[i] -= b[i];
        }
        while((a[a[0]] == 0) &amp;&amp; (a[0] &gt; 0)) a[0]--;
        return;
    }
}
void numcpy(int p[],int q[],int det){
    for (i = 1;i &lt;= p[0];i++) q[i + det - 1] = p[i];
    q[0] = p[0] + det - 1;
}
void chugao(int a[],int b[],int c[]){
    int i,tmp[101];
    c[0] = a[0] - b[0] + 1;
    for (i = c[0];i &gt; 0;i--){
        memset(tmp,0,sizeof(tmp));
        numcpy(b,tmp,i);
        while (cmp(a,tmp) &gt;= 0){
        	c[i]++;
			jian(a,tmp);
		}
    }
    while((c[c[0]] == 0) &amp;&amp; (c[0] &gt; 0)) c[0]--;
}

// 应用部分 
int main(){
    inp(a),inp(b);
    chugao(a,b,c);
    pri(c),pri(a);
    return 0;
}</code></pre> 
</div> 
<h5>能处理负数版（不带余数，见取模） </h5> 
<div> 
 <pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
// 此版本无法输出余数，求余数见高精度取模 
string fixedNum(string a) {
	if (a.size() == 1) return a;
	for (int i = 0;i &lt; a.size();i++){
		if ('1' &lt;= a[i] &amp;&amp; a[i] &lt;= '9') return a.substr( i, a.size() );
	}
	return "0";
}
string cA(string a,string b) {
	a = fixedNum(a),b = fixedNum(b);
	int as = a.size(), bs = b.size(), d = as &gt; bs ? as - bs : bs - as;
	string s = "0", t = "0";
	for (int i = 0;i &lt; d;i++) as &gt; bs ? t += "0" : s += "0";
	s += a,t += b;
	for (int i = s.size() - 1;i &gt;= 1;i--){
		s[i] += t[i] - '0';
		if (s[i] &gt; '9') s[i] -= 10,s[i - 1]++;
	}
	return s[0] == '0' ? s.substr( 1, s.size() ) : s;
}
string cS(string a, string b){
	int as = a.size(), bs = b.size(), d = as - bs;
	string s = "", t = "";
	for (int i = 0;i &lt; d;i++) t += "0";
	s += a,t += b;
	for (int i = s.size() - 1;i &gt;= 0;i--) {
		if (s[i] &lt; t[i]) {
			s[i] += 10;
			if (s[i - 1] &gt;= '1') s[i - 1]--;
			else {
				int j = i - 1;
				while (s[j] == '0') s[j--] += 9;
				s[j]--;
			}
		}
		s[i] -= (t[i] - '0');
	}
	if (s.size() == 1) return s;
	for (int i = 0;i &lt; s.size();i++){
		if ('1' &lt;= s[i] &amp;&amp; s[i] &lt;= '9') return s.substr(i,s.size());
	}
	return "0";
}

// 应用部分 
int main() {
	string a, b, c, sum = "0", cnt = "1";
	bool j1 = 0;
	cin &gt;&gt; a &gt;&gt; b;
	if (a == "0"){
		cout &lt;&lt; 0 &lt;&lt; endl;
		return 0;
	}else if (a[0] == '-' &amp;&amp; b[0] == '-') a = a.substr(1,a.size()),b = b.substr(1,b.size());
	else if (a[0] == '-') j1 = 1,a = a.substr(1, a.size());
	else if (b[0] == '-') j1 = 1,b = b.substr(1, b.size());
	c = b;
	int as = a.size(),bs = b.size(), cs, d = as - bs;
	for (int i = 0;i &lt; d - 1;i++) c += "0",cnt += "0";
	cs = c.size();
	bool j2 = 0;
	while (c != b) {
		while (as &gt; cs || as == cs &amp;&amp; a &gt;= c) j2 = 1,a = cS(a,c),as = a.size(),sum = cA(sum,cnt);
		c = c.substr(0,c.size() - 1),cnt = cnt.substr(0,cnt.size() - 1),cs = c.size();
	}
	while (as &gt; bs || as == bs &amp;&amp; a &gt;= b) j2 = 1,a = cS(a,b),sum = cA(sum,cnt),as = a.size();
	if (j1 &amp;&amp; j2) cout &lt;&lt; '-';
	cout &lt;&lt; sum &lt;&lt; endl;
	return 0;
}</code></pre> 
</div> 
<h4> 高精度取模（高精度取模高精度）</h4> 
<h5>普通版</h5> 
<blockquote> 
 <p>在高精度除法（普通版）中作为余数实现，此处不再重复</p> 
</blockquote> 
<h5>能处理负数版</h5> 
<div> 
 <pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt; 
using namespace std;
// 可以处理负数版
string cA(string a,string b){
	int as = a.size(), bs = b.size(), d = as &gt; bs ? as - bs : bs - as;
	string s = "0", t = "0";
	for (int i = 0;i &lt; d;i++) as &gt; bs ? t += "0" : s += "0";
	s += a,t += b;
	for ( int i = s.size() - 1; i &gt;= 1; i-- ) {
		s[i] += t[i] - '0';
		if (s[i] &gt; '9') s[i] -= 10,s[i - 1]++;
	}
	bool j = true;
	for (int i = 0;i &lt; s.size();i++)
		if (s[i] != '0') j = false;
	if (j) return "0";
	return s[0] == '0' ? s.substr( 1, s.size() ) : s;
}
string cS(string a,string b){
	int as = a.size(), bs = b.size(), d = as - bs;
	string s = "", t = "";
	for (int i = 0;i &lt; d;i++) t += "0";
	s += a,t += b;
	for (int i = s.size() - 1;i &gt;= 0;i--){
		if (s[i] &lt; t[i]){
			s[i] += 10;
			if (s[i - 1] &gt;= '1') s[i - 1]--;
			else{
				int j = i - 1;
				while (s[j] == '0') s[j--] += 9;
				s[j]--;
			}
		}
		s[i] -= (t[i] - '0');
	}
	if (s.size() == 1) return s;
	for ( int i = 0; i &lt; s.size(); i++ ) {
		if ('1' &lt;= s[i] &amp;&amp; s[i] &lt;= '9') return s.substr(i,s.size());
	}
	return "0";
}

// 应用部分
int main() {
	string a, b, c;
	cin &gt;&gt; a &gt;&gt; b;
	c = b;
	int as = a.size(), bs = b.size(),cs,d = as - bs;
	for (int i = 0;i &lt; d - 1;i++) c += "0";
	cs = c.size();
	while ( c != b ) {
		while (as &gt; cs || as == cs &amp;&amp; a &gt;= c) a = cS(a,c),as = a.size();
		c = c.substr(0,c.size() - 1),cs = c.size();
	}
	while (as &gt; bs || as == bs &amp;&amp; a &gt;= b) a = cS(a,b),as = a.size();
	cout &lt;&lt; a &lt;&lt; endl;
	return 0;
}</code></pre> 
</div> 
<h5></h5> 
<hr> 
<h3>高精度op低精度</h3> 
<h4>高精度加低精度</h4> 
<div> 
 <pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
// 函数名称:add
// 函数参数:一个vector&lt;int&gt;和一个int变量 
// 函数返回值:一个vector&lt;int&gt;
// 函数功能:返回输入的一个vector和一个int的和 
// 中文名称:高精度加低精度 
vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, int b){
	vector&lt;int&gt; C;
	int t = A.size();
	A[0] += b;
	for(int i = 0;i &lt; t - 1; i ++){
		C.push_back(A[i] % 10);
		A[i + 1] += A[i] / 10;
	}
	if (A[t - 1] &gt; 0){
		C.push_back(A[t - 1] % 10);
		A[t - 1] /= 10;
	} 
	return C;
}

// 应用部分 
vector &lt;int&gt; A,C;
string CA;
int b;
int main(){
	cin &gt;&gt; CA &gt;&gt; b;
	for (int i = CA.size() - 1;i &gt;= 0;i--) A.push_back(CA[i] - '0');
	C = add(A,b);
	for (int i = C.size() - 1;i &gt;= 0;i--) cout &lt;&lt; C[i]; 
	cout &lt;&lt; endl;
	return 0;
}</code></pre> 
</div> 
<h4>高精度减低精度</h4> 
<div> 
 <pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
// 函数名称:sub
// 函数参数:一个vector&lt;int&gt;和一个int变量 
// 函数返回值:一个vector&lt;int&gt;
// 函数功能:返回输入的一个vector和一个int的差 
// 中文名称:高精度减低精度 
vector&lt;int&gt; sub(vector&lt;int&gt; A, int b){
	int t = A.size();
	A[0] -= b;
	for (int i = 0;i &lt; t - 1; i ++){
		if (A[i] &lt; 0){
			int x = (( -1 * A[i] ) / 10 + 1);
			A[i] += x * 10;
			A[i + 1] -= x;
		} 
	}
	while (A.size() &gt; 1 &amp;&amp; A.back() == 0) A.pop_back();
	return A;
}

// 应用部分 
vector &lt;int&gt; A,C;
string CA;
int b;
int main(){
	cin &gt;&gt; CA &gt;&gt; b;
	for (int i = CA.size() - 1;i &gt;= 0;i--) A.push_back(CA[i] - '0');
	C = sub(A,b);
	for (int i = C.size() - 1;i &gt;= 0;i--) cout &lt;&lt; C[i]; 
	cout &lt;&lt; endl;
	return 0;
}</code></pre> 
</div> 
<h4>高精度乘低精度</h4> 
<div> 
 <pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
// 函数名称:mul2
// 函数参数:一个vector&lt;int&gt;和一个int变量 
// 函数返回值:一个vector&lt;int&gt;
// 函数功能:返回输入的一个vector和一个int的积 
// 中文名称:高精度乘低精度 
vector &lt;int&gt; mul(vector &lt;int&gt; &amp; A, int b) {
    vector &lt;int&gt; C;
    int t = 0;
    for (int i = 0; i &lt; A.size(); i ++) {
        t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }
    while (t){
        C.push_back(t % 10);
        t /= 10;
    }
    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();
    return C;
}

// 应用部分
vector &lt;int&gt; C,A;
string a;
int b;
int main() {
    cin &gt;&gt; a &gt;&gt; b;
    for (int i = a.size() - 1; i &gt;= 0; i --) A.push_back(a[i] - '0');
    C = mul(A,b);
    for (int i = C.size() - 1; i &gt;= 0; i --) cout &lt;&lt; C[i];
    return 0;
}</code></pre> 
</div> 
<h4>高精度除低精度</h4> 
<div> 
 <pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
// 函数名称:mul2
// 函数参数:一个vector&lt;int&gt;和一个int变量 
// 函数返回值:一个vector&lt;int&gt;
// 函数功能:返回输入的一个vector和一个int的积 
// 中文名称:高精度乘低精度 
vector &lt;int&gt; mul(vector &lt;int&gt; &amp;A,int b,int &amp;r) {
    vector &lt;int&gt; C;
    r = 0;
    for (int i = A.size() - 1;i &gt;= 0;i--){
    	r = r * 10 + A[i];
    	C.push_back(r / b);
    	r %= b;
    }
    reverse(C.begin(),C.end());
    while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();  //去掉前导0
    return C;
}

// 应用部分
vector &lt;int&gt; C,A;
string a;
int b,r; // 不要漏了r，r是余数 
int main() {
    cin &gt;&gt; a &gt;&gt; b;
    for (int i = a.size() - 1; i &gt;= 0; i --) A.push_back(a[i] - '0');
	C = mul(A,b,r);
    for (int i = C.size() - 1; i &gt;= 0; i --) cout &lt;&lt; C[i];
    cout &lt;&lt; endl &lt;&lt; r &lt;&lt; endl;
    return 0;
}</code></pre> 
</div> 
<h4>高精度取模低精度 </h4> 
<div> 
 <pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
// 高精度取模低精度
int mod(string a,int b){
    int d = 0;
    for(int i = 0;i &lt; a.size();i++) d = (d * 10 + (a[i] - '0')) % b; //求出余数
    return d;
}

// 应用部分
string a;
int b;
int main(){
    cin &gt;&gt; a &gt;&gt; b;
    cout &lt;&lt; mod(a,b);
    return 0;
}</code></pre> 
</div> 
<h4>高精度开根低精度 </h4> 
<p><a class="link-info" href="https://www.luogu.com.cn/problem/P2293" rel="nofollow" title="洛谷P2293">洛谷P2293</a></p> 
<blockquote> 
 <p>感谢<a class="link-info" href="https://www.luogu.com.cn/user/7442" rel="nofollow" title="这位dalao">这位dalao</a></p> 
</blockquote> 
<div> 
 <pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define Ll unsigned long long
// 感谢洛谷的dalao
using namespace std;
const Ll NN = 1e9;
const int N = 9;
struct H{
    Ll a[1500],len;
    H(){
    	memset(a,0,sizeof a);
		len = 1;
	}
};
int n;
H s;
void init(H &amp;a){//读入 
    string s;
	cin &gt;&gt; s; 
    int l; 
    a.len = 0;
    for(int r = s.size() - 1;r &gt;= 0;r -= N){
        a.len++;                      
        if(r &gt;= N - 1) l = r - N + 1;
		else l = 0;
        for(int i = l;i &lt;= r;i++) a.a[a.len] = a.a[a.len] * 10 + s[i] - '0';
    }
}  
void outit(H a){//输出 
    cout &lt;&lt; a.a[a.len];
    for(int i = a.len - 1;i;i--){
        for(int k = NN / 10;a.a[i] &lt; k;k /= 10) cout &lt;&lt; 0;
        if(a.a[i]) cout &lt;&lt; a.a[i];
    }
	cout &lt;&lt; endl;
}
void in(H &amp;a,int x){
    if(!x)return;
    a.len = 0;
    while(x) a.a[++a.len] = x % NN,x /= NN;
}
bool bigD(H a,H b){ // 比较 
    if(a.len &gt; b.len) return 1;
    if(a.len &lt; b.len) return 0;
    for(int i = a.len;i;i--){
    	if(a.a[i] != b.a[i]){
    		if(a.a[i] &gt; b.a[i]) return 1;
			else return 0;
		}
	}
    return 1;
}
H jia(H a,H b){
    H c;
    int l = max(a.len,b.len);
    for(int i = 1;i &lt;= l;i++){
        c.a[i] += a.a[i] + b.a[i];
        c.a[i+1] = c.a[i] / NN;
        c.a[i] %= NN;
    }
    if(c.a[l + 1]) l++;
    c.len = l;
    return c;
}
H chu(H a){
    H c;
    if(a.len == 1){
    	c.a[1] = a.a[1] &gt;&gt; 1;
		return c;
	}
    for(int i = a.len;i;i--){
        if(a.a[i] &amp; 1ll)a.a[i-1] += NN;
        c.a[i] = a.a[i] &gt;&gt; 1;
    }
    if(c.a[a.len]) c.len = a.len;
	else c.len = a.len - 1;
    return c;
}
H rrr(H a){
    if(a.len == 1) a.a[1]--;return a;
    H c = a;
    c.a[1]--;
    int l = 1;
    while(c.a[l] &lt; 0) c.a[l] = NN - 1,c.a[++l]--;
    if(!c.a[c.len]) c.len--;
    return c;
}
H chen(H a,H b){
    H z;
    z.len = a.len + b.len + 2;
    for(int i = 1;i &lt;= a.len;i++){
    	for(int j = 1;j &lt;= b.len;j++) z.a[i + j - 1] += (a.a[i] * b.a[j]);
	}
    for(int i = 1;i &lt;= z.len;i++) z.a[i + 1] += z.a[i] / NN,z.a[i] %= NN;
    while(z.len &gt; 1 &amp;&amp; !z.a[z.len]) z.len--;
    return z;
}
H ksm(H a,int n){
    if(n == 1) return a;
    H c = ksm(a,n &gt;&gt; 1);
    c = chen(c,c);
    if(n &amp; 1) c = chen(c,a);
    return c;
}
bool Chu(H a){
    if(a.len * n - n + 1 &gt; s.len) return 0;
    if(bigD(s,ksm(a,n))) return 1;
    return 0;
}

// 应用部分
int main(){
    cin &gt;&gt; n;
    init(s);
    if(n == 1){
    	outit(s);
		return 0;
	}
    H l,r,mid,ans;
    in(l,1);
    r = s;
    while(bigD(r,l)){
        mid = jia(l,r);
        mid = chu(mid);
        if(Chu(mid)){
            if(bigD(mid,ans)) ans = mid;
            H c;
            in(c,1);
            l = jia(mid,c);
        }else{
        	r = rrr(mid);
		}
    }
    outit(ans);
    return 0;
}</code></pre> 
</div> 
<h3> 高精度浮点数 </h3> 
<div> 
 <pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
// 高精浮点数
const int SIZE=264000;
complex&lt;double&gt; e[SIZE],A[SIZE],w1[SIZE],w2[SIZE];
void DFT(complex&lt;double&gt; *A, complex&lt;double&gt; *w, int l, int r, int dt){
    int N = r - l; // 全检长度 
    if (N == 1){
        w[l] = A[l];
        return;
    }
    int N1 = N &gt;&gt; 1,mid = (l + r) &gt;&gt; 1,pos1 = l,pos2 = mid;
    for (int i = 0; i &lt; N; i++){
        if (i &amp; 1) w[pos2] = A[i + l],pos2++;
        else w[pos1] = A[i + l],pos1++;
    }
    DFT(w,A,l,mid,dt &lt;&lt; 1),DFT(w,A,mid,r,dt &lt;&lt; 1);
    for (int i = 0;i &lt; N1;i++) w[l + i] = A[l + i] + e[i*dt] * A[i + mid],w[i + mid] = A[l + i] - e[i*dt] * A[i + mid];
}
struct Wfloat{
    const static int size = SIZE;
    int *a,length,sign,pos;
    Wfloat(){
        a = (int*)malloc(sizeof(int)* size);
        a[0] = 0,length = 1,sign = 0,pos = 0;
    }
    Wfloat(const Wfloat &amp;ans){
        a = (int*)malloc(sizeof(int)* size);
        length = ans.length,sign = ans.sign,pos = ans.pos;
        for (int i = 0;i &lt; length;i++) a[i] = ans.a[i];
    }
    Wfloat(char *word){
        a = (int*)malloc(sizeof(int)* size);
        int wordlength = strlen(word);
        pos = 0,length = 0,sign = 0;
        for (int i = wordlength - 1; i &gt;= 0; i--){
            char c = word[i];
            if (c == '.') pos = length + 1;
            else if (c == '-') sign = 1;
            else a[length] = c - '0',length++;
        }
    }
    Wfloat operator = (const Wfloat &amp;ans){
        length = ans.length,sign = ans.sign,pos = ans.pos;
        for (int i = 0; i &lt; length; i++) a[i] = ans.a[i];
        return *this;
    }
    Wfloat operator =(char *word){ // 无小数点 
        int wordlength = strlen(word);
        pos = 0,length = 0,sign = 0;
        for (int i = wordlength - 1; i &gt;= 0; i--){
            char c = word[i];
            if (c == '.') pos = length + 1;
            else if (c == '-') sign = 1;
            else a[length] = c - '0',length++;
        }
        return *this;
    }
    ~Wfloat(){free(a);}
};
void Print(const Wfloat &amp;ans){
    if (ans.sign == 1) cout &lt;&lt; "-";
    if (ans.pos &gt;= ans.length){
        cout &lt;&lt; "0.";
        for (int i = 0;i &lt; ans.pos - ans.length;i++) cout &lt;&lt; "0";
        for (int i = ans.length - 1;i &gt;= 0;i--) cout &lt;&lt; ans.a[i];
    }else{
        for (int i = ans.length - 1;i &gt;= ans.pos;i--) cout &lt;&lt; ans.a[i];
        if (ans.pos != 0){
            cout &lt;&lt; ".";
            for (int i = ans.pos - 1;i &gt;= 0;i--) cout &lt;&lt; ans.a[i];
        }
    }
    cout &lt;&lt; endl;
}
Wfloat operator * (const Wfloat &amp;number1, int number2){
    Wfloat ans = number1;
    if (number2 &lt; 0) ans.sign = -number1.sign,number2 = -number2;
    for (int i = 0;i &lt; ans.length;i++) ans.a[i] *= number2;
    for (int i = 0;i &lt; ans.length;i++){
        if (ans.a[i] &gt;= 10){
            if (i == ans.length - 1) ans.length++,ans.a[i + 1] = 0;
            ans.a[i + 1] += ans.a[i] / 10.ans.a[i] %= 10;
        }
    }
    return ans;
}
Wfloat operator / (const Wfloat &amp;number1, int number2){
    Wfloat answer;
    int lastnumber = 0,length = -1;
    for (int i = number1.length - 1;i &gt;= 0;i--){
        lastnumber *= 10,lastnumber += number1.a[i],answer.a[i] = lastnumber / number2,lastnumber -= answer.a[i] * number2;
        if (length == -1 &amp;&amp; answer.a[i] != 0) length = i + 1;
    }
    answer.length = length,answer.pos = number1.pos,answer.sign = number1.sign;
    return answer;
}
Wfloat Multiplication(const Wfloat &amp;number1, const Wfloat &amp;number2, int eps){
    Wfloat ans;
    double pi = 3.1415926535897932384626;
    int length1 = min(eps, number1.length),length2 = min(eps, number2.length);
    if (length1 &gt; 1000 &amp;&amp; length2 &gt; 1000){
        int tempLength = max(length1 / 3, length2 / 3),N = 1;
        while (N &lt; tempLength) N &lt;&lt;= 1;
        N &lt;&lt;= 1;
        for (int i = 0; i &lt; N; i++) e[i] = complex&lt;double&gt;(cos(2 * pi * i / N), sin(2 * pi * i / N));
        int lastPos;
        for (int i = 0; i &lt; length1; i++){
            lastPos = i / 3;
            if (i % 3 == 0) A[lastPos] = complex&lt;double&gt;(number1.a[number1.length - length1 + i], 0);
            else if (i % 3 == 1) A[lastPos] += complex&lt;double&gt;(number1.a[number1.length - length1 + i] * 10.0, 0);
            else if (i % 3 == 2) A[lastPos] += complex&lt;double&gt;(number1.a[number1.length - length1 + i] * 100.0, 0);
        }
        for (int i = lastPos + 1; i &lt; N; i++) A[i] = complex&lt;double&gt;(0, 0);
        DFT(A, w1, 0, N, 1);
        for (int i = 0; i &lt; length2; i++){
            lastPos = i / 3;
            if (i % 3 == 0) A[lastPos] = complex&lt;double&gt;(number2.a[number2.length - length2 + i], 0);
            else if (i % 3 == 1) A[lastPos] += complex&lt;double&gt;(number2.a[number2.length - length2 + i] * 10.0, 0);
            else if (i % 3 == 2) A[lastPos] += complex&lt;double&gt;(number2.a[number2.length - length2 + i] * 100.0, 0);
        }
        for (int i = lastPos + 1; i &lt; N; i++) A[i] = complex&lt;double&gt;(0, 0);
        DFT(A, w2, 0, N, 1);
        for (int i = 0;i &lt; N;i++) w2[i] *= w1[i];
        for (int i = 0;i &lt; N;i++) e[i] = complex&lt;double&gt;(cos(-2 * pi * i / N), sin(-2 * pi * i / N));
        DFT(w2,w1,0,N,1);
        long long temp = 0,temp1 = 0;
        for (int i = 0;i &lt; N;i++){
            temp += w1[i].real() / N + 0.001,temp1 = temp / 1000,temp %= 1000;
            ans.a[i * 3] = temp % 10,ans.a[i * 3 + 1] = temp % 100 / 10,ans.a[i * 3 + 2] = temp / 100;
            temp = temp1;
            if (ans.a[i * 3 + 2] != 0) ans.length = i * 3 + 3;
            else if (ans.a[i * 3 + 1] != 0) ans.length = i * 3 + 2;
            else if (ans.a[i * 3] != 0) ans.length = i * 3 + 1;
        }
        ans.pos = number1.pos + number2.pos - (number1.length - length1 + number2.length - length2),ans.sign = number1.sign^number2.sign;
        return ans;
    }else{
        int length3 = length1 + length2 + 4;
        for (int i = 0;i &lt; length3;i++) ans.a[i] = 0;
        ans.length = 0;
        for (int i = 0;i &lt; length1;i++){
            int number = number1.a[number1.length - length1 + i];
            for (int j = 0; j &lt; length2; j++) ans.a[i + j] += number2.a[number2.length - length2 + j] * number,ans.length = max(ans.length, i + j + 1);
        }
        for (int k = 0;k &lt; ans.length;k++){
            if (ans.a[k] &gt;= 10){
                if (k == ans.length - 1) ans.length++;
                ans.a[k + 1] += ans.a[k] / 10,ans.a[k] %= 10;
            }
        }
        ans.pos = number1.pos + number2.pos - (number1.length - length1 + number2.length - length2),ans.sign = number1.sign^number2.sign;
        return ans;
    }
}
Wfloat Multiplication(const Wfloat &amp;number3, const Wfloat &amp;number4){
    Wfloat number1 = number3,number2 = number4,ans;
    int eps = max(number1.length, number2.length),length1 = number1.length,length2 = number2.length;
    if (length1 &gt; length2){
        int length3 = length1 - length2;
        for (int i = 0; i &lt; length3; i++) number2.a[number2.length] = 0,number2.length++;
    }else if (length1 &lt; length2){
        int length3 = length2 - length1;
        for (int i = 0;i &lt; length3;i++) number1.a[number1.length] = 0,number1.length++;
    }
    ans = Multiplication(number1, number2,eps);
    int temp = ans.length - ans.pos;
    for (int i = 0;i &lt; temp;i++) ans.a[i] = ans.a[ans.pos + i];
    ans.length = temp,ans.pos = 0;
    return ans;
}
Wfloat Subtraction(const Wfloat &amp;number3, const Wfloat &amp;number4, int eps){
    Wfloat number1 = number3,number2 = number4,ans;
    int tempLength = eps,length1 = number1.pos - number1.length,length2 = number2.pos - number2.length;
    if (length1 &gt; length2){
        int length3 = length1 - length2;
        for (int i = 0;i &lt; length3;i++) number1.a[number1.length] = 0,number1.length++;
    }else if (length1 &lt; length2){
        int length3 = length2 - length1;
        for (int i = 0;i &lt; length3;i++) number2.a[number2.length] = 0,number2.length++;
    }
    int pos = 1;
    for (int i = tempLength - 1; i &gt;= 0; i--){
        int b1,b2;
        if (number1.length - pos &lt; 0) b1 = 0;
        else b1 = number1.a[number1.length - pos];
        if (number2.length - pos &lt; 0) b2 = 0;
        else b2 = number2.a[number2.length - pos];
        ans.a[i] = b1 - b2;
        pos++;
    }
    int length = 0;
    for (int i = 0; i &lt; tempLength; i++){
        if (ans.a[i] &lt; 0) ans.a[i + 1]--,ans.a[i] += 10;
        if (ans.a[i] != 0) length = i;
    }
    length++;
    ans.length = length,ans.pos = number1.pos - number1.length + tempLength;
    return ans;
}
Wfloat Subtraction(const Wfloat &amp;number1, const Wfloat &amp;number2){
    Wfloat ans;
    int eps = max(number1.length, number2.length);
    ans = Subtraction(number1, number2, eps);
    int temp = ans.length - ans.pos;
    for (int i = 0;i &lt; temp;i++) ans.a[i] = ans.a[ans.pos + i];
    ans.length = temp,ans.pos = 0;
    return ans;
}
Wfloat Reciprocal(const Wfloat &amp;N, int eps1){
    Wfloat ans;
    if (N.pos == 0){ // 整数 
        Wfloat  x0, x1;
        int N1length = N.length;
        int Effectbit = 16;
        Effectbit = min(Effectbit, N.length);
        int lastZero = N1length - Effectbit;
        double num = 0;
        for (int i = 1; i &lt;= Effectbit; i++) num *= 10,num += N.a[N1length - i];
        x0.pos = lastZero;
        num = pow(num, -1);
        int tempNum,count1 = 0,flag = 0;
        x0.length = 16;
        int n1 = 15;
        while (count1 &lt; 16){
            num *= 10,tempNum = num;
            if (tempNum != 0) num -= tempNum;
            if (tempNum == 0 &amp;&amp; flag == 0) x0.pos++;
            else flag = 1,x0.a[n1] = tempNum,n1--,x0.pos++;
            if (flag) count1++;
        }
        int lastbiteps = eps1;
        int biteps = 32;
        while (1){
            x1 = Multiplication(N, x0, biteps);
            x1 = Multiplication(x1, x0, biteps);
            x0 = Subtraction(x0 * 2, x1, biteps);
            if (biteps &gt; lastbiteps) break;
            biteps *= 2;
        }
        ans = x0;
        return ans;
    }
    return ans;
}
Wfloat Division(const Wfloat &amp;number1, const Wfloat &amp;number2, int eps){
    Wfloat ans;
    
    return ans;
}
Wfloat Division(const Wfloat &amp;number1, const Wfloat &amp;number2){
    Wfloat ans;
    if (number1.length &lt; number2.length) return ans;
    int eps = number1.length - number2.length + 50;
    ans = Reciprocal(number2, eps),ans = Multiplication(ans, number1, eps);
    int temp = ans.length - ans.pos;
    for (int i = 0; i &lt; temp; i++) ans.a[i] = ans.a[ans.pos + i];
    ans.length = temp;
    ans.pos = 0;
    return ans;
}
Wfloat sqrt(Wfloat &amp;N){
    Wfloat ans;
    if (N.sign == 1) return ans;
    if (N.pos == 0){ // 整数 
        int eps = 50;
        Wfloat x0, x1;
        int N1length = N.length,Effectbit = 16;
        Effectbit = min(Effectbit, N.length);
        int lastZero = N1length - Effectbit;
        double num = 0;
        for (int i = 1; i &lt;= Effectbit; i++) num *= 10,num += N.a[N1length - i];
        if (lastZero % 2 != 0) num *= 10,Effectbit++,lastZero--;
        x0.pos = lastZero / 2;
        num = pow(num, -0.5);
        int tempNum,count1 = 0,flag = 0,n1 = 15;
        x0.length = 16;
        while (count1 &lt; 16){
            num *= 10,tempNum = num;
            if (tempNum != 0) num -= tempNum;
            if (tempNum == 0 &amp;&amp; flag == 0) x0.pos++;
            else flag = 1,x0.a[n1] = tempNum,n1--,x0.pos++;
            if (flag) count1++;
        }
        int lastbiteps = N.length / 2 + eps;//最终需要的精度
        int biteps = 32;
        x0.a[1]--;
        if (x0.a[1] &lt; 0){
            for (int i = 1;; i++){
                if (x0.a[i] &lt; 0) x0.a[i + 1]--,x0.a[i] += 10;
                else break;
            }
        }
        while (1){
            x1 = Multiplication(N, x0, biteps),x1 = Multiplication(x1, x0, biteps),x1.a[x1.pos] = 3,x1.length = x1.pos + 1;
            for (int i = 0;i &lt; x1.pos;i++) x1.a[i] = -x1.a[i];
            for (int i = 0;i &lt; x1.pos;i++){
                if (x1.a[i] &lt; 0) x1.a[i] += 10,x1.a[i + 1]--;
            }
            x1.length = x1.pos + 1,x1 = x1 / 2,x1 = Multiplication(x0, x1, biteps),x0 = x1;
            if (biteps &gt; lastbiteps) break;
            biteps *= 2;
        }
        ans = Multiplication(x0, N, lastbiteps);
        int temp = ans.length - ans.pos;
        for (int i = 0;i &lt; temp;i++) ans.a[i] = ans.a[ans.pos + i];
        ans.length = temp;
        ans.pos = 0;
        return ans;
    }
}
double Reciprocal(double a){
    double x0 = 0.2,x1;
    while (1){
        x1 = 2 * x0 - a * x0 * x0;
        if (abs(x0 - x1) &lt; 1e-15) break;
        printf("%.16lf\n", x1);
        getchar();
        swap(x0, x1);
    }
    return x1;
}

// 应用部分 
char word[100100];
int main(){
    Wfloat A, B;
    scanf("%s", word);
    A = word;
    scanf("%s", word);
    B = word;
    Wfloat ans = Division(A, B);
    Print(ans);
    ans = Subtraction(A, Multiplication(ans, B));
    Print(ans);
}</code></pre> 
 <p class="img-center"><img alt="wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" height="299" src="https://images2.imgbox.com/c2/bb/uIlsn9AK_o.png" width="534"></p> 
</div> 
<p></p> 
<p>转自<a class="link-info" href="https://blog.csdn.net/w_weilan/article/details/80012997" title="这里">这里</a></p> 
<h3>高精度低精度互转</h3> 
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
// 对于这份代码的to_string函数，版本低的C++识别不出来
vector&lt;int&gt; int_to_vec(int in){
	string str = to_string(in);
    vector&lt;int&gt; res;
    for (int i = str.size() - 1;i &gt;= 0;i--) res.push_back(str[i] - '0');
    return res;
}
int vec_to_str(vector&lt;int&gt; &amp;A){ // 请确保int能装下
    string res;
    for (int i = 0;i &lt; A.size();i++) res += to_string(A[i]);
    reverse(res.begin(),res.end());
    return stoi(res);
}
vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B){ // 用乘法示范
    vector&lt;int&gt; C(A.size() + B.size(), 0);
    for (int i = 0; i &lt; A.size(); i++) {
        for (int j = 0;j &lt; B.size();j++){
            C[i + j] += A[i] * B[j];
            if (C[i + j] &gt;= 10){
                C[i + j + 1] += C[i + j] / 10;
                C[i + j] %= 10;
            }
        }
    }
    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();
    return C;
}

// 应用部分
int CA,CB;
int main(){
    cin &gt;&gt; CA &gt;&gt; CB;
    vector &lt;int&gt; A = int_to_vec(CA);
    vector &lt;int&gt; B = int_to_vec(CB);
    int result = vec_to_str(A) + vec_to_str(B); // 用加法当范例
    vector &lt;int&gt; C = mul(A,B); // 用乘法测试
    cout &lt;&lt; vec_to_str(A) &lt;&lt; endl &lt;&lt; vec_to_str(B) &lt;&lt; endl;
    for (int i = A.size() - 1;i &gt;= 0;i--) cout &lt;&lt; A[i];
    cout &lt;&lt; endl;
    for (int i = B.size() - 1;i &gt;= 0;i--) cout &lt;&lt; B[i];
    cout &lt;&lt; endl;
    for (int i = C.size() - 1;i &gt;= 0;i--) cout &lt;&lt; C[i];
    cout &lt;&lt; endl;
    cout &lt;&lt; result &lt;&lt; endl;
    return 0;
}</code></pre> 
<hr> 
<h2>结语</h2> 
<blockquote> 
 <p>求支持！</p> 
 <p>还是感谢一下那些为我提供帮助的人</p> 
 <p>此外，还有什么没有嘛？可以告诉我一下，我要是能找到就补充上去</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d50e4916e6c7c1bd7324c5b4c93adb36/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【腾讯云 TDSQL-C Serverless 产品体验】基于TDSQL-C Serverless最佳实践助力企业降本增效</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/61aa1715b12e0030f79a5fab3cccd5d0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【腾讯云 TDSQL-C Serverless 产品体验】TDSQL-C MySQL Serverless实践之路</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>