<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;期末编程题题库】代码&#43;详解18道 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/cbfd81175cec7cf51236631214bcbf38/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;期末编程题题库】代码&#43;详解18道">
  <meta property="og:description" content="适合期末复习c&#43;&#43;看，或者刚入门c&#43;&#43;的小白看，有的题会补充知识点，期末复习题的代码一般比较简单，所以语法上没那么严谨。本文所有题目要求全在代码块的最上面。
目录
1、设计复数类
2、设计Computer类
3、实现相加的函数模板
4、圆类的设计
5、学生类设计
6、求圆与直线位置关系
7、家庭账户共享
8、栈类的设计
9、主人召唤宠物
10、点圆圆柱单继承
11、点长方形长方体单继承
12、点圆球体运行时多态
13、学生数据写入文件和读取
14、图形抽象类派生具体类求多个图形面积
15、 除数为0的异常处理
16、学生数据修改【文件操作】
17、分数的加减
18、统计字符数组中某个字符出现次数
1、设计复数类 //设计复数类Complex和友元运算符重载&gt;&gt;及&lt;&lt;实现复数类对象的标准输入和输出 #include&lt;iostream&gt; using namespace std; class Complex { private: double real, imag; public: Complex(double r = 0, double i = 0) { real = r; imag = i; } //下面是友元的声明，所以函数参数只写类型是可以的 friend istream&amp; operator&gt;&gt;(istream&amp;, Complex&amp;); friend ostream&amp; operator&lt;&lt;(ostream&amp;, Complex&amp;); }; istream&amp; operator&gt;&gt;(istream&amp; input, Complex&amp; c) { //输入实部和虚部 input &gt;&gt; c.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-01-05T19:19:04+08:00">
    <meta property="article:modified_time" content="2024-01-05T19:19:04+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;期末编程题题库】代码&#43;详解18道</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="524" src="https://images2.imgbox.com/1d/05/yhStDdV3_o.png" width="1159"></p> 
<p><span style="color:#fe2c24;"><strong><span style="background-color:#fefcd8;">适合期末复习c++看，或者刚入门c++的小白看，有的题会补充知识点，期末复习题的代码一般比较简单，所以</span></strong></span><span style="color:#511b78;"><strong><span style="background-color:#fefcd8;">语法上没那么严谨</span></strong></span><span style="color:#fe2c24;"><strong><span style="background-color:#fefcd8;">。本文所有题目要求全在代码块的最上面。</span></strong></span></p> 
<p id="main-toc"><span style="color:#4da8ee;"><strong>目录</strong></span></p> 
<p id="1%E3%80%81%E8%AE%BE%E8%AE%A1%E5%A4%8D%E6%95%B0%E7%B1%BB-toc" style="margin-left:0px;"><a href="#1%E3%80%81%E8%AE%BE%E8%AE%A1%E5%A4%8D%E6%95%B0%E7%B1%BB" rel="nofollow">1、设计复数类</a></p> 
<p id="%C2%A02%E3%80%81%E8%AE%BE%E8%AE%A1Computer%E7%B1%BB-toc" style="margin-left:0px;"><a href="#%C2%A02%E3%80%81%E8%AE%BE%E8%AE%A1Computer%E7%B1%BB" rel="nofollow"> 2、设计Computer类</a></p> 
<p id="3%E3%80%81%E5%AE%9E%E7%8E%B0%E7%9B%B8%E5%8A%A0%E7%9A%84%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF-toc" style="margin-left:0px;"><a href="#3%E3%80%81%E5%AE%9E%E7%8E%B0%E7%9B%B8%E5%8A%A0%E7%9A%84%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF" rel="nofollow">3、实现相加的函数模板</a></p> 
<p id="4%E3%80%81%E5%9C%86%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1-toc" style="margin-left:0px;"><a href="#4%E3%80%81%E5%9C%86%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1" rel="nofollow">4、圆类的设计</a></p> 
<p id="5%E3%80%81%E5%AD%A6%E7%94%9F%E7%B1%BB%E8%AE%BE%E8%AE%A1-toc" style="margin-left:0px;"><a href="#5%E3%80%81%E5%AD%A6%E7%94%9F%E7%B1%BB%E8%AE%BE%E8%AE%A1" rel="nofollow">5、学生类设计</a></p> 
<p id="6%E3%80%81%E6%B1%82%E5%9C%86%E4%B8%8E%E7%9B%B4%E7%BA%BF%E4%BD%8D%E7%BD%AE%E5%85%B3%E7%B3%BB-toc" style="margin-left:0px;"><a href="#6%E3%80%81%E6%B1%82%E5%9C%86%E4%B8%8E%E7%9B%B4%E7%BA%BF%E4%BD%8D%E7%BD%AE%E5%85%B3%E7%B3%BB" rel="nofollow">6、求圆与直线位置关系</a></p> 
<p id="7%E3%80%81%E5%AE%B6%E5%BA%AD%E8%B4%A6%E6%88%B7%E5%85%B1%E4%BA%AB-toc" style="margin-left:0px;"><a href="#7%E3%80%81%E5%AE%B6%E5%BA%AD%E8%B4%A6%E6%88%B7%E5%85%B1%E4%BA%AB" rel="nofollow">7、家庭账户共享</a></p> 
<p id="8%E3%80%81%E6%A0%88%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1-toc" style="margin-left:0px;"><a href="#8%E3%80%81%E6%A0%88%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1" rel="nofollow">8、栈类的设计</a></p> 
<p id="9%E3%80%81%E4%B8%BB%E4%BA%BA%E5%8F%AC%E5%94%A4%E5%AE%A0%E7%89%A9-toc" style="margin-left:0px;"><a href="#9%E3%80%81%E4%B8%BB%E4%BA%BA%E5%8F%AC%E5%94%A4%E5%AE%A0%E7%89%A9" rel="nofollow">9、主人召唤宠物</a></p> 
<p id="10%E3%80%81%E7%82%B9%E5%9C%86%E5%9C%86%E6%9F%B1%E5%8D%95%E7%BB%A7%E6%89%BF-toc" style="margin-left:0px;"><a href="#10%E3%80%81%E7%82%B9%E5%9C%86%E5%9C%86%E6%9F%B1%E5%8D%95%E7%BB%A7%E6%89%BF" rel="nofollow">10、点圆圆柱单继承</a></p> 
<p id="11%E3%80%81%E7%82%B9%E9%95%BF%E6%96%B9%E5%BD%A2%E9%95%BF%E6%96%B9%E4%BD%93%E5%8D%95%E7%BB%A7%E6%89%BF-toc" style="margin-left:0px;"><a href="#11%E3%80%81%E7%82%B9%E9%95%BF%E6%96%B9%E5%BD%A2%E9%95%BF%E6%96%B9%E4%BD%93%E5%8D%95%E7%BB%A7%E6%89%BF" rel="nofollow">11、点长方形长方体单继承</a></p> 
<p id="12%E3%80%81%E7%82%B9%E5%9C%86%E7%90%83%E4%BD%93%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A4%9A%E6%80%81-toc" style="margin-left:0px;"><a href="#12%E3%80%81%E7%82%B9%E5%9C%86%E7%90%83%E4%BD%93%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A4%9A%E6%80%81" rel="nofollow">12、点圆球体运行时多态</a></p> 
<p id="13%E3%80%81%E5%AD%A6%E7%94%9F%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6%E5%92%8C%E8%AF%BB%E5%8F%96-toc" style="margin-left:0px;"><a href="#13%E3%80%81%E5%AD%A6%E7%94%9F%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6%E5%92%8C%E8%AF%BB%E5%8F%96" rel="nofollow">13、学生数据写入文件和读取</a></p> 
<p id="14%E3%80%81%E5%9B%BE%E5%BD%A2%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%B4%BE%E7%94%9F%E5%85%B7%E4%BD%93%E7%B1%BB%E6%B1%82%E5%A4%9A%E4%B8%AA%E5%9B%BE%E5%BD%A2%E9%9D%A2%E7%A7%AF-toc" style="margin-left:0px;"><a href="#14%E3%80%81%E5%9B%BE%E5%BD%A2%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%B4%BE%E7%94%9F%E5%85%B7%E4%BD%93%E7%B1%BB%E6%B1%82%E5%A4%9A%E4%B8%AA%E5%9B%BE%E5%BD%A2%E9%9D%A2%E7%A7%AF" rel="nofollow">14、图形抽象类派生具体类求多个图形面积</a></p> 
<p id="15%E3%80%81%20%E9%99%A4%E6%95%B0%E4%B8%BA0%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-toc" style="margin-left:0px;"><a href="#15%E3%80%81%20%E9%99%A4%E6%95%B0%E4%B8%BA0%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86" rel="nofollow">15、 除数为0的异常处理</a></p> 
<p id="%C2%A016%E3%80%81%E5%AD%A6%E7%94%9F%E6%95%B0%E6%8D%AE%E4%BF%AE%E6%94%B9%E3%80%90%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E3%80%91-toc" style="margin-left:0px;"><a href="#%C2%A016%E3%80%81%E5%AD%A6%E7%94%9F%E6%95%B0%E6%8D%AE%E4%BF%AE%E6%94%B9%E3%80%90%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E3%80%91" rel="nofollow"> 16、学生数据修改【文件操作】</a></p> 
<p id="17%E3%80%81%E5%88%86%E6%95%B0%E7%9A%84%E5%8A%A0%E5%87%8F-toc" style="margin-left:0px;"><a href="#17%E3%80%81%E5%88%86%E6%95%B0%E7%9A%84%E5%8A%A0%E5%87%8F" rel="nofollow">17、分数的加减</a></p> 
<p id="%C2%A018%E3%80%81%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%90%E4%B8%AA%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0-toc" style="margin-left:0px;"><a href="#%C2%A018%E3%80%81%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%90%E4%B8%AA%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0" rel="nofollow"> 18、统计字符数组中某个字符出现次数</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1%E3%80%81%E8%AE%BE%E8%AE%A1%E5%A4%8D%E6%95%B0%E7%B1%BB" style="background-color:transparent;"><span style="color:#be191c;"><span style="background-color:#fef2f0;">1、设计复数类</span></span></h2> 
<pre><code class="language-cpp">//设计复数类Complex和友元运算符重载&gt;&gt;及&lt;&lt;实现复数类对象的标准输入和输出
#include&lt;iostream&gt;
using namespace std;

class Complex
{
private:
	double real, imag;
public:
	Complex(double r = 0, double i = 0)
	{
		real = r;
		imag = i;
	}
	//下面是友元的声明，所以函数参数只写类型是可以的
	friend istream&amp; operator&gt;&gt;(istream&amp;, Complex&amp;);
	friend ostream&amp; operator&lt;&lt;(ostream&amp;, Complex&amp;);
};
istream&amp; operator&gt;&gt;(istream&amp; input, Complex&amp; c)
{
	//输入实部和虚部
	input &gt;&gt; c.real &gt;&gt; c.imag;
	return input;//返回istream，符合operator&gt;&gt;的实现
}

ostream&amp; operator&lt;&lt;(ostream&amp; output, Complex&amp; c)
{
	if (c.imag &gt; 0)
		output &lt;&lt; c.real &lt;&lt; "i+" &lt;&lt; c.imag;
	else if (c.imag &lt; 0)
		output &lt;&lt; c.real &lt;&lt; "i" &lt;&lt; c.imag;
	else
		output &lt;&lt; c.real &lt;&lt; "i";

	return output;
}

int main()
{
	Complex c;
	cin &gt;&gt; c;
	cout &lt;&lt; c;
	return 0;
}
</code></pre> 
<p><img alt="" height="137" src="https://images2.imgbox.com/1f/79/rGtdwTpa_o.png" width="1200"></p> 
<hr> 
<h2 id="%C2%A02%E3%80%81%E8%AE%BE%E8%AE%A1Computer%E7%B1%BB"> <span style="color:#be191c;"><span style="background-color:#fef2f0;">2、设计Computer类</span></span></h2> 
<pre><code class="language-cpp">//计算机Computer的属性包括型号、生产厂家和价格，用文件流中write()函数将若干
//计算机中的信息写入文件Computer.dat中，然后用read()函数将Computer.dat中所有数据读出。
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;fstream&gt;
using namespace std;

//涉及文件读写操作了，肯定要访问成员变量，用struct即可
struct Computer
{
	int id;
	string manufacter;
	double price;
};

int main()
{
	Computer c;
	cout &lt;&lt; "Please input the id, manufacter and price of Computer:";
	cin &gt;&gt; c.id &gt;&gt; c.manufacter &gt;&gt; c.price;
	ofstream out("Computer.dat", ios::binary | ios::out);
	if (!out.is_open())//如果文件打开不成功//也可写为if(!out)
	{
		cout &lt;&lt; "fail to open the file\n" &lt;&lt; endl;
		exit(-1);
	}
	out.write((const char*)&amp;c, sizeof(c));//写入是const char*
	out.close();

	ifstream in("Computer.dat", ios::binary | ios::in);
	if (!in)
	{
		cout &lt;&lt; "fail to open the file\n" &lt;&lt; endl;
		exit(-1);
	}
	in.read((char*)&amp;c, sizeof(c));//读取是char*
	in.close();
	
	cout &lt;&lt; "the data of Computer is:" &lt;&lt; endl;
	cout &lt;&lt; c.id &lt;&lt; " " &lt;&lt; c.manufacter &lt;&lt; " " &lt;&lt; c.price &lt;&lt; endl;

	return 0;
}</code></pre> 
<p><img alt="" height="184" src="https://images2.imgbox.com/87/5a/vexeinSA_o.png" width="1199"></p> 
<h2></h2> 
<hr> 
<h2 id="3%E3%80%81%E5%AE%9E%E7%8E%B0%E7%9B%B8%E5%8A%A0%E7%9A%84%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF" style="background-color:transparent;"><span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">3、实现相加的函数模板</span></strong></span></h2> 
<pre><code class="language-cpp">//编写两个相长度数值型一维数组对应元素相加的函数模板
#include&lt;iostream&gt;
using namespace std;

template&lt;class T&gt;
void add(T a[], T b[], T c[], int n)
{
	for (int i = 0; i &lt; n; i++)
		c[i] = a[i] + b[i];
}

int main()
{
	int a[5] = { 1, 2, 3, 4, 5 };
	int b[5] = { 1, 2, 3, 4, 5 };
	int c[5];
	add(a, b, c, 5);
	for (int i = 0; i &lt; 5; i++) cout &lt;&lt; c[i] &lt;&lt; " ";
	cout &lt;&lt; endl;

	return 0;
}</code></pre> 
<p><img alt="" height="113" src="https://images2.imgbox.com/57/97/A1AIOqcf_o.png" width="925"></p> 
<hr> 
<h2 id="4%E3%80%81%E5%9C%86%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1" style="background-color:transparent;"><span style="color:#be191c;"><span style="background-color:#fef2f0;">4、圆类的设计</span></span></h2> 
<pre><code class="language-cpp">//1、圆类的设计：设计一个圆类，计算出它的周长，面积，
//并有圆心移动和半径移动(就是变化的意思)的操作，并打印出数据
#include&lt;iostream&gt;
using namespace std;

//这里最好不要用float,除非你写为3.14f，因为你写一个小数3.14默认为double
//如果你用float，这里就会发生截断，因为是从double到float
const double pi = 3.14;

class Circle
{
public:
	//也可采用c++11的初始化列表方式
	/*Circle(int x = 0, int y = 0, int r = 0)
		:_x(x)
		,_y(y)
		,_r(r)
	{}*/

	Circle(double x = 0, double y = 0, double r = 0)
	{
		_x = x; _y = y; _r = r;
	}
	double circum()
	{
		return 2 * pi * _r;
	}
	double area()
	{
		return pi * _r * _r;
	}
	void movep(double x, double y)
	{
		_x += x; _y += y;
	}
	void mover(double r)
	{
		_r += r;
	}
	void show()
	{
		cout &lt;&lt; "圆心：(" &lt;&lt; _x &lt;&lt; "," &lt;&lt; _y &lt;&lt; ") 半径：" &lt;&lt; _r &lt;&lt; endl;
	}

private:
	double _x, _y, _r;
};

int main()
{
	Circle c(1.2, 1.3, 2.1);
	c.show();
	cout &lt;&lt; "circum:" &lt;&lt; c.circum() &lt;&lt; "   " &lt;&lt; "area:" &lt;&lt; c.area() &lt;&lt; endl;
	c.movep(1.1, 2.2);
	c.show();
	c.mover(1.2);
	c.show();

	return 0;
}</code></pre> 
<p><img alt="" height="221" src="https://images2.imgbox.com/b1/e7/ZYfIIeJo_o.png" width="953"></p> 
<hr> 
<h2 id="5%E3%80%81%E5%AD%A6%E7%94%9F%E7%B1%BB%E8%AE%BE%E8%AE%A1" style="background-color:transparent;"><span style="color:#be191c;"><span style="background-color:#fef2f0;">5、学生类设计</span></span></h2> 
<pre><code class="language-cpp">//学生类设计求学生最高分最低分和平均分,并打印出学生信息
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

class Student
{
private:
	int _id;
	string _name;
	double _score;

public:
	Student(int id = 0, string name = "", double score = 0.0)
	{
		_id = id;
		_name = name;
		_score = score;
	}

	void input(int id, string name, double score)
	{
		_id = id;
		_name = name;
		_score = score;
	}

	double Getscore()
	{
		return _score;
	}

	void show()
	{
		cout &lt;&lt; "id:" &lt;&lt; _id &lt;&lt; " " &lt;&lt; "name:" &lt;&lt; _name &lt;&lt; " " &lt;&lt; "score:" &lt;&lt; _score &lt;&lt; endl;
	}
};

double maxscore(Student stu[], int n)
{
	double maximum = 0.0;
	for (int i = 0; i &lt; n; i++)
		if (maximum &lt; stu[i].Getscore()) maximum = stu[i].Getscore();
	return maximum;
}

double minscore(Student stu[], int n)
{
	double minimum = 100;
	for (int i = 0; i &lt; n; i++)
		if (minimum &gt; stu[i].Getscore()) minimum = stu[i].Getscore();
	return minimum;
}

double averscore(Student stu[], int n)
{
	double sum = 0.0;
	for (int i = 0; i &lt; n; i++)
		sum += stu[i].Getscore();
	return sum / n;
}

int main()
{
	Student stu[3];
	int id; string name; double score;
	for (int i = 0; i &lt; 3; i++)
	{
		cin &gt;&gt; id &gt;&gt; name &gt;&gt; score;
		stu[i].input(id, name, score);
	}

	for (int i = 0; i &lt; 3; i++) stu[i].show();

	cout &lt;&lt; "maxscore:" &lt;&lt; maxscore(stu, 3) &lt;&lt; endl;
	cout &lt;&lt; "minscore:" &lt;&lt; minscore(stu, 3) &lt;&lt; endl;
	cout &lt;&lt; "averscore:" &lt;&lt; averscore(stu, 3) &lt;&lt; endl;

	return 0;
}</code></pre> 
<p><img alt="" height="362" src="https://images2.imgbox.com/70/74/4zG0lqYC_o.png" width="1139"></p> 
<hr> 
<h2 id="6%E3%80%81%E6%B1%82%E5%9C%86%E4%B8%8E%E7%9B%B4%E7%BA%BF%E4%BD%8D%E7%BD%AE%E5%85%B3%E7%B3%BB" style="background-color:transparent;"><span style="color:#be191c;"><span style="background-color:#fef2f0;">6、求圆与直线位置关系</span></span></h2> 
<pre><code class="language-cpp">//定义直线类和圆类，求两者位置关系（相切、相交或相离）
#include&lt;iostream&gt;
#include&lt;cmath&gt;
using namespace std;

//直线：ax + by + c = 0
class Circle;//必须先声明Circle类，不然友元函数找不到Circle
class Line
{
private:
	double _a, _b, _c;
public:
	Line(double a = 0, double b = 0, double c = 0)
	{
		_a = a;
		_b = b;
		_c = c;
	}
	//这里不用友元也可以，你可以用一个geta等等来获取私有成员，对于圆类同理
	friend int position_relation(const Line&amp;, const Circle&amp;);
};

class Circle
{
private:
	double _x, _y, _r;//圆心和半径
public:
	Circle(double x = 0, double y = 0, double r = 0)
	{
		_x = x;
		_y = y;
		_r = r;
	}
	friend int position_relation(const Line&amp;, const Circle&amp;);
};

//圆与直线位置关系公式:d=ax+by+c/根号下a*a+b*b【其中abc均为直线的，x和y是圆的圆心】
//如果d&gt;r：相离 d==r：相切 d&lt;r：相交
int position_relation(const Line&amp; l, const Circle&amp; c)
{
	double d = l._a * c._x + l._b * c._y + l._c / sqrt(l._a * l._a + l._b * l._b);
	//因为d是算出来的，浮点数会有精度损失，所以比较的时候要靠精度来比
	if (fabs(d - c._r) &gt; 0.000001) return -1;     //相离
	else if (fabs(d - c._r) &lt; 0.000001) return 1; //相交
	else return 0;							//相切
}

int main()
{
	Line l(2.1, 2.2, 2.3);
	Circle c(1.1, 1.2, 1.3);
	int ret = position_relation(l, c);
	if (ret == -1) cout &lt;&lt; "相离" &lt;&lt; endl;
	else if (ret == 1) cout &lt;&lt; "相交" &lt;&lt; endl;
	else cout &lt;&lt; "相切" &lt;&lt; endl;

	return 0;
}</code></pre> 
<p><img alt="" height="112" src="https://images2.imgbox.com/68/e1/5xEZFPzg_o.png" width="924"></p> 
<p><span style="color:#fe2c24;"><strong><span style="background-color:#fefcd8;">回顾友元：</span></strong></span></p> 
<blockquote> 
 <p>在C++中，<strong>友元函数（Friend Function）</strong>是一种特殊的函数，它可以访问并操作类的私有成员，即使它不是类的成员函数。通过友元函数，我们可以实现对类的私有成员的非成员函数访问权限。友元提供了一种突破封装的方式。友元函数提供了一种在需要时访问类的私有成员的机制，但应该慎重使用，因为过多的友元函数可能破坏类的封装性。</p> 
 <p><strong><span style="color:#511b78;"><span style="background-color:#fefcd8;">友元函数特性：</span></span></strong></p> 
 <ul><li>(1) 友元函数可以访问类的私有和保护成员，但不是类的成员函数。</li><li>(2) 友元函数不能被const修饰。由于友元函数不属于任何类的成员函数，它们无法被 const 修饰。</li><li>(3) 友元函数可以在类定义的任何地方声明，不受类访问限定符限制。</li><li>(4) 一个函数可以是多个类的友元函数。</li><li>(5) 友元函数的调用与普通函数的调用和原理相同。</li><li>(6)友元函数/友元类是单向的，A在B类中被声明为友元函数/友元类，表示A是B的友元函数/友元类，但B不是A的友元类函数/友元类；</li><li>(7)友元函数在类中声明时用friend修饰，但是在定义时不需要用friend修饰；</li><li>(8)友元函数不能被继承：父类的友元函数，继承后并不会成为子类的友元函数；</li><li>(9)友元函数不具有传递性：A类和B类都是C类的友元类，但是A类和B类并不是友元类；</li></ul> 
</blockquote> 
<hr> 
<h2 id="7%E3%80%81%E5%AE%B6%E5%BA%AD%E8%B4%A6%E6%88%B7%E5%85%B1%E4%BA%AB" style="background-color:transparent;"><span style="color:#be191c;"><span style="background-color:#fef2f0;">7、家庭账户共享</span></span></h2> 
<pre><code class="language-cpp">//家庭银行账户共享，即一个家庭几个成员共享财产，设计一个Familymember类
//实现钱财的支出和存钱，并显示剩余钱额【定义静态成员实现】
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

class Familymember
{
private:
	string _name;
public:
	Familymember(string name = "");
	static double money;
	static void save(double m);
	static void expend(double m);
	static void show();
};
//类外初始化静态成员变量不要加static
double Familymember::money = 0;//类內声明，类外定义

Familymember::Familymember(string name)
{//类內声明已经有默认参数，类外就不能给了，否则就重定义默认参数了
	_name = name;
}
//类外定义静态成员函数不能加static
void Familymember:: save(double m)
{
	money += m;
}

void Familymember::expend(double m)
{
	money -= m;
}

void Familymember::show()
{
	cout &lt;&lt; "remained money:" &lt;&lt; money &lt;&lt; endl;
}

int main()
{
	Familymember wife("zhu"), husband("jiang");
	wife.save(10000);
	husband.expend(5000);
	husband.save(20000);
	wife.show();//对象可以访问静态成员函数，但静态成员函数没有this指针
	husband.show();
	Familymember::show();

	return 0;
}</code></pre> 
<p><img alt="" height="563" src="https://images2.imgbox.com/5f/c8/sNMdYanA_o.png" width="1200"></p> 
<hr> 
<h2 id="8%E3%80%81%E6%A0%88%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1" style="background-color:transparent;"><span style="color:#be191c;"><span style="background-color:#fef2f0;">8、栈类的设计</span></span></h2> 
<pre><code class="language-cpp">//设计一个静态栈类，内有构造函数，且有压栈和入栈操作，并返回栈顶元素，输入数据
//以0表示结束
//学校期末要求不高，我以前的博客写过动态栈，想了解的可以看看
#include&lt;iostream&gt;
using namespace std;

//这里不要定义为size，因为size是一个关键字，用于定义类型大小，如果你这里
//常量名称定义为size就会冲突！但是在devc++就能跑过去，可能dev不严谨，vs下是过不去的
const int stackSize = 100;

class Stack
{
private:
	int sta[stackSize];
	int _top;//栈顶

public:
	Stack();
	int push(int x);//入栈
	int pop();//出栈
};

Stack::Stack()
{//直接置空即可
	_top = 0;
}

int Stack::push(int x)
{
	if (_top == stackSize)
		return 0;//栈满返回0

	sta[_top++] = x;
	return x;
}

int Stack::pop()
{
	if (_top == 0)
		return 0;//栈空返回0
	//返回删除之后的栈顶
	return sta[--_top];
}

int main()
{
	Stack s;
	int x;
	cout &lt;&lt; "Please input pushed data:" &lt;&lt; endl;
	cin &gt;&gt; x;
	while (x &amp;&amp; s.push(x))
	{
		cout &lt;&lt; "Please input pushed data:" &lt;&lt; endl;
		cin &gt;&gt; x;
	}
	
	while (x = s.pop())
		cout &lt;&lt; "the poped data is :" &lt;&lt; x &lt;&lt; endl;

	return 0;
}</code></pre> 
<p><img alt="" height="521" src="https://images2.imgbox.com/f2/5e/I89K1oXD_o.png" width="1175"></p> 
<hr> 
<h2 id="9%E3%80%81%E4%B8%BB%E4%BA%BA%E5%8F%AC%E5%94%A4%E5%AE%A0%E7%89%A9" style="background-color:transparent;"><span style="color:#be191c;"><span style="background-color:#fef2f0;">9、主人召唤宠物</span></span></h2> 
<pre><code class="language-cpp">//主人召唤宠物，宠物有名字和应答语，主人也有名字，他可以召唤宠物，看召唤名字与宠物
//的名字是否一致，若一致，宠物就会回应应答语
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
class Pet
{
private:
	string _name;
	string _ans;

public:
	Pet(string name = "", string ans = "")
	{
		_name = name;
		_ans = ans;
	}

	void answer(string name) const
	{
		if (name == _name)//调用string的operator==
			cout &lt;&lt; _ans &lt;&lt; endl;
		else
			cout &lt;&lt; "dear host, you are not calling me!" &lt;&lt; endl;
	}
};

class Host
{
private:
	string _name;

public:
	Host(string name = "")
	{
		_name = name;
	}
	
	void call(const Pet&amp; p, string name)
	{
		p.answer(name);
	}
};

int main()
{
	Host h("MeiZhu");
	Pet dog("huihui", "wangwang");
	Pet cat("huahua", "miaomiao~");
	h.call(dog, "huihui");
	h.call(cat, "huahuaya");

	return 0;
}</code></pre> 
<p><img alt="" height="359" src="https://images2.imgbox.com/77/d8/FhGko505_o.png" width="1200"></p> 
<hr> 
<h2 id="10%E3%80%81%E7%82%B9%E5%9C%86%E5%9C%86%E6%9F%B1%E5%8D%95%E7%BB%A7%E6%89%BF" style="background-color:transparent;"><span style="color:#be191c;"><span style="background-color:#fef2f0;">10、点圆圆柱单继承</span></span></h2> 
<pre><code class="language-cpp">//点圆圆柱单继承，即圆类继承点【圆心】类，再由圆柱类继承圆类,求出面积和体积
#include&lt;iostream&gt;
using namespace std;

const double pi = 3.14;

class Point
{
private://private即可，圆类求面积和体积用不到圆心
	double _x, _y;
public:
	Point(double x = 0, double y = 0)
	{
		_x = x;
		_y = y;
	}
	double area()
	{
		return 0.0;
	}
	double volume()
	{
		return 0.0;
	}
};

class Circle : public Point
{
protected://这里若用private的话，Cylinder求面积和体积就无法使用了
	double _r;

public:
	Circle(double r = 0.0, double x = 0.0, double y = 0.0)
		:Point(x, y)
	{
		_r = r;
	}
	double area()
	{
		return pi * _r * _r;
	}
	double volume()
	{
		return 0.0;
	}
};

class Cylinder : public Circle
{
private:
	double _h;

public:
	Cylinder(double x = 0.0, double y = 0.0, double r = 0.0, double h = 0.0)
		:Circle(r, x, y)
	{
		_h = h;
	}
	double area()
	{	//上下底圆的面积+侧面积：长方形面积
		return 2 * pi * _r * _r + 2 * pi * _r * _h;
	}
	double volume()
	{	//圆柱体积为底面积*高
		return Circle::area() * _h;
	}
};

int main()
{
	Circle cir(2.1, 1.1, 2.2);
	Cylinder cy(2.2, 2.3, 2.4, 1.2);
	cout &lt;&lt; cir.area() &lt;&lt; "    " &lt;&lt; cir.volume() &lt;&lt; endl;
	cout &lt;&lt; cy.area() &lt;&lt; "    " &lt;&lt; cy.volume() &lt;&lt; endl;

	return 0;
}</code></pre> 
<p><img alt="" height="153" src="https://images2.imgbox.com/97/0d/ahd0WQ2f_o.png" width="924"></p> 
<hr> 
<h2 id="11%E3%80%81%E7%82%B9%E9%95%BF%E6%96%B9%E5%BD%A2%E9%95%BF%E6%96%B9%E4%BD%93%E5%8D%95%E7%BB%A7%E6%89%BF" style="background-color:transparent;"><span style="color:#be191c;"><span style="background-color:#fef2f0;">11、点长方形长方体单继承</span></span></h2> 
<pre><code class="language-cpp">//点长方形长方体单继承，长方形继承点类，长方体继承长方形类，求面积和体积
#include&lt;iostream&gt;
using namespace std;

class Point
{
private:
	double _x, _y;

public:
	Point(double x = 0.0, double y = 0.0)
	{
		_x = x;
		_y = y;
	}
	double area()
	{
		return 0.0;
	}
	double volume()
	{
		return 0.0;
	}
};
//长方形
class Rectangle : public Point
{
protected://不能设为private，不然长方体类中用不了了
	double _length, _width;

public:
	Rectangle(double x = 0.0, double y = 0.0, double l = 0.0, double w = 0.0)
		:Point(x, y)
	{
		_length = l;
		_width = w;
	}
	double area()
	{
		return _length * _width;
	}
	double volume()
	{
		return 0.0;
	}
};
//长方体
class Cuboid : public Rectangle
{
private:
	double _h;

public:
	Cuboid(double x, double y, double l, double w, double h)
		:Rectangle(x, y, l, w)
	{
		_h = h; 
	}
	double area()
	{//长方体表面积：2长*宽+2长*高+2宽*高
		return 2 * _length * _width + 2 * _length * _h + 2 * _width * _h;
	}
	double volume()
	{//长方体体积：底面积*高
		return _length * _width * _h;
	}
};

int main()
{
	Rectangle rec(1.1, 2.0, 2.3, 2.4);
	Cuboid cub(1.2, 2.2, 2.4, 4.5, 1.1);
	cout &lt;&lt; "area of rectangle is :" &lt;&lt; rec.area()  &lt;&lt; "\t" &lt;&lt; "volume of rectangle is:" &lt;&lt; rec.volume() &lt;&lt; endl;
	cout &lt;&lt; "area of cuboid is :" &lt;&lt; cub.area() &lt;&lt; "\t" &lt;&lt; "volume of cuboid is:" &lt;&lt; cub.volume() &lt;&lt; endl;

	return 0;
}</code></pre> 
<p><img alt="" height="164" src="https://images2.imgbox.com/c6/8e/GlzTIqn0_o.png" width="1138"></p> 
<hr> 
<h2 id="12%E3%80%81%E7%82%B9%E5%9C%86%E7%90%83%E4%BD%93%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A4%9A%E6%80%81" style="background-color:transparent;"><span style="color:#be191c;"><span style="background-color:#fef2f0;">12、点圆球体运行时多态</span></span></h2> 
<pre><code class="language-cpp">//点圆球体运行时多态：由圆类继承点类，球类继承圆类，实现求面积和体积，要求多态实现
#include&lt;iostream&gt;
using namespace std;

const double pi = 3.14;

class Point
{
private:
	double _x, _y;
public:
	Point(const double&amp; x, const double&amp; y)
	{//这种加const写法的才是最标准的，因为应付期末，没有那么高的要求的
		_x = x;
		_y = y;
	}
	virtual double area() = 0;
	virtual double volume() = 0;
};

class Circle : public Point
{
protected:
	double _r;
public:
	Circle(double x, double y, double r)
		:Point(x, y)
	{
		_r = r; 
	}
	virtual double area()
	{	//圆的面积：π*r*r
		return pi * _r * _r;
	}
	virtual double volume()
	{
		return 0.0;
	}
};
//球体类
class Sphere : public Circle
{
private:
	double _z; //因为球体的是三维的，所以它的圆心应该再增加一个维度
public:
	Sphere(double x, double y, double r, double z)
		:Circle(x, y, r)
	{
		_z = z;
	}
	double area()
	{
		return 4 * pi * _r * _r;
	}
	double volume()
	{   //V=(4/3)πr^3
		return 4 * pi * _r * _r * _r / 3;
	}
};


int main()
{
	Point* p;
	Circle c(1.1, 1.2, 1.3);
	Sphere s(1.2, 1.3, 1.4, 1.5);
	p = &amp;c;
	cout &lt;&lt; " circle: " &lt;&lt; p-&gt;area() &lt;&lt; "\t\t" &lt;&lt; p-&gt;volume() &lt;&lt; endl;
	p = &amp;s;
	cout &lt;&lt; " sphere: " &lt;&lt; p-&gt;area() &lt;&lt; "\t" &lt;&lt; p-&gt;volume() &lt;&lt; endl;

	return 0;
}</code></pre> 
<p><img alt="" height="144" src="https://images2.imgbox.com/dc/46/LBcIWPdJ_o.png" width="939"></p> 
<hr> 
<h2 id="13%E3%80%81%E5%AD%A6%E7%94%9F%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6%E5%92%8C%E8%AF%BB%E5%8F%96" style="background-color:transparent;"><span style="color:#be191c;"><span style="background-color:#fef2f0;">13、学生数据写入文件和读取</span></span></h2> 
<pre><code class="language-cpp">//学生数据写入文件，并读取文件数据到程序中【使用read和write实现】
#include&lt;iostream&gt;
#include&lt;fstream&gt;
using namespace std;

struct Student
{
	char name[20];
	int id;
	int age;
	char gender[5];
};

int main()
{
	//创建一个输出流对象，并打开文件，以二进制的方式写
	//写法1：
	//ofstream outfile;
	//outfile.open("test.txt", ios::binary | ios::trunc);
	//trunc:如果文件存在先删除，再创建【一般是不用的】
	//写法2：更简洁！
	ofstream outfile("test.txt", ios::binary | ios::trunc);
	if (!outfile)//或写为if(!outfile.is_open())
	{//判断文件是否打开成功
		cout &lt;&lt; "file open error!" &lt;&lt; endl;
		exit(1);//exit(非0)都代表异常退出
	}

	Student stu[3];
	cout &lt;&lt; "Please input the data of 3 students" &lt;&lt; endl;
	for (int i = 0; i &lt; 3; i++)
	{
		cin &gt;&gt; stu[i].name &gt;&gt; stu[i].id &gt;&gt; stu[i].age &gt;&gt; stu[i].gender;
		//写入文件，以二进制形式写入
		outfile.write((const char*)&amp;stu[i], sizeof(stu[i]));
	}
	outfile.close();//关闭文件以便以下一次的读出数据

	//再把学生数据读出
	Student tmp[3];//保存从文件中读出的数据
	ifstream infile("test.txt", ios::binary);

	//读取方法一：直接读取整个数组的数据中
	//infile.read((char*)tmp, sizeof(tmp));
	//或写为infile.read((char*)&amp;tmp[0], sizeof(tmp));//因为都是首元素的地址，读取的是一整个数组

	cout &lt;&lt; "The Student data read from file is:" &lt;&lt; endl;
	for (int i = 0; i &lt; 3; i++)
	{//读取方法二：读取数据一个一个数组元素来读取
		infile.read((char*)&amp;tmp[i], sizeof(tmp[i]));
		cout &lt;&lt; tmp[i].name &lt;&lt; " " &lt;&lt; tmp[i].id &lt;&lt; " " &lt;&lt; tmp[i].age
			&lt;&lt; " " &lt;&lt; tmp[i].gender &lt;&lt; endl;
	}
	infile.close();

	return 0;
}</code></pre> 
<p><span style="color:#1c7331;"><strong><span style="background-color:#fef2f0;">测试结果如下：</span></strong></span></p> 
<p><img alt="" height="338" src="https://images2.imgbox.com/46/05/FE4VD4AJ_o.png" width="1043"></p> 
<p> 此时打开<strong>test.txt文件</strong>可以看出是二进制的形式，我们看不懂，但是从<strong>文件中读入到程序</strong>当中就能看出来了，主要是因为这种<strong>二进制读写方式</strong>很方便</p> 
<p><img alt="" height="102" src="https://images2.imgbox.com/e0/5c/HFcLYCiM_o.png" width="1200"></p> 
<hr> 
<h2 id="14%E3%80%81%E5%9B%BE%E5%BD%A2%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%B4%BE%E7%94%9F%E5%85%B7%E4%BD%93%E7%B1%BB%E6%B1%82%E5%A4%9A%E4%B8%AA%E5%9B%BE%E5%BD%A2%E9%9D%A2%E7%A7%AF" style="background-color:transparent;"><span style="color:#be191c;"><span style="background-color:#fef2f0;">14、图形抽象类派生具体类求多个图形面积</span></span></h2> 
<pre><code class="language-cpp">//用图形类派生圆类和三角形类，分别求面积，并求出面积之和【多态实现】
#include&lt;iostream&gt;
using namespace std;

const double pi = 3.14;

class Graph
{
public:
	virtual double area() = 0;
};

class Circle : public Graph
{
private:
	double _x, _y, _r;
public:
	Circle(const double&amp; x, const double&amp; y, const double&amp; r)
		:_x(x)
		,_y(y)
		,_r(r)
	{}
	double area()
	{
		return pi * _r * _r;
	}
};

class Triangle : public Graph
{
private:
	double _bottom, _h;
public:
	Triangle(const double&amp; bottom, const double&amp; h)
		:_bottom(bottom)
		,_h(h)
	{}
	double area()
	{
		return 0.5 * _bottom * _h;
	}
};

double sumarea(Graph* g[], int n)
{
	double sum = 0.0;
	for (int i = 0; i &lt; n; i++)
		sum += g[i]-&gt;area();

	return sum;
}

int main()
{
	Circle c1(1.1, 1.2, 1.3), c2(1.2, 1.3, 1.4);
	Triangle t1(2.1, 3.1), t2(1.1, 3.4);
	Graph* g[4] = { &amp;c1, &amp;c2, &amp;t1, &amp;t2 };
	cout &lt;&lt; sumarea(g, 4) &lt;&lt; endl;

	return 0;
}</code></pre> 
<p><img alt="" height="110" src="https://images2.imgbox.com/e4/a3/9gaDkZI5_o.png" width="1024"></p> 
<hr> 
<h2 id="15%E3%80%81%20%E9%99%A4%E6%95%B0%E4%B8%BA0%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span style="color:#be191c;"><span style="background-color:#fef2f0;">15、 除数为0的异常处理</span></span></h2> 
<p><strong><span style="color:#1a439c;"><span style="background-color:#fefcd8;">建议先看我写过的异常文章：</span></span></strong><a href="https://blog.csdn.net/m0_74044018/article/details/134125192" title="【C++】异常【完整版】-CSDN博客">【C++】异常【完整版】-CSDN博客</a></p> 
<pre><code class="language-cpp">//写一个实现除法的函数，主函数利用异常处理除数为0的情况
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

//division:除法，dividend:被除数，divisor:除数
double division(double x, double y)
{
	if (y == 0)
	{
		//我们不建议写为throw 0.0, 因为这种处理方式和之前讲的错误码一样，没什么意义
		//不如直接用错误码了
		throw string("发生除0错误!");
	}
	return x / y;
}

int main()
{
	try
	{
		double x, y;
		cin &gt;&gt; x &gt;&gt; y;
		cout &lt;&lt; "x / y = " &lt;&lt; division(x, y) &lt;&lt; endl;
		cin &gt;&gt; x &gt;&gt; y;
		cout &lt;&lt; "x / y = " &lt;&lt; division(x, y) &lt;&lt; endl;
	}
	catch (const string&amp; err)
	{
		cout &lt;&lt; err &lt;&lt; endl;
	}
	//下面用基类捕获的方式，若除数为0，会直接报错！
	//但有时如出现数组越界问题等，会直接打印出错误信息
	//catch (exception&amp; e)
	//{
	//	cout &lt;&lt; e.what() &lt;&lt; endl;
	//}

	return 0;
}</code></pre> 
<p><img alt="" height="197" src="https://images2.imgbox.com/9f/03/QyCpaWS4_o.png" width="865"></p> 
<hr> 
<h2 id="%C2%A016%E3%80%81%E5%AD%A6%E7%94%9F%E6%95%B0%E6%8D%AE%E4%BF%AE%E6%94%B9%E3%80%90%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E3%80%91" style="background-color:transparent;"><span style="color:#be191c;"><span style="background-color:#fef2f0;"> 16、学生数据修改【文件操作</span></span><span style="color:#be191c;"><span style="background-color:#fef2f0;">】</span></span></h2> 
<pre><code class="language-cpp">//建立学生类，将学生数据写入文件，然后读取回程序中，并修改第3个学生的信息，然后写入文件
//然后再读取到程序中并打印【要求：read和write实现，并使用文件指针定位的seekp和seekg】
#include&lt;iostream&gt;
#include&lt;fstream&gt;
#include&lt;string&gt;
using namespace std;

struct Stu
{
	int id;
	char name[20];//不能用string，不然会报错：读取访问权限冲突，除非用c_str，原因下面解释
	double score;
};

int main()
{
	Stu stu[20];
	//为什么要用fstream呢？因为下面有读指针和写指针操作同时进行的，这里定义fstream对象
	//既可以读又可以写，很方便，省得下面你又得关闭文件，然后又打开文件...
	fstream io("stu.txt", ios::binary | ios::out | ios::in);
	if (!io)
	{
		cout &lt;&lt; "Fail to open the file!" &lt;&lt; endl;
		exit(-1);
	}

	cout &lt;&lt; "Please input the datas of students:" &lt;&lt; endl;
	for (int i = 0; i &lt; 3; i++)
		cin &gt;&gt; stu[i].id &gt;&gt; stu[i].name &gt;&gt; stu[i].score;
	io.write((const char*)stu, sizeof(stu));//一次性把整个数组全都写入文件中
	io.close();

	io.open("stu.txt", ios::binary | ios::in | ios::out);
	if (!io)
	{
		cout &lt;&lt; "Fail to open the file!" &lt;&lt; endl;
		exit(-1);
	}
	Stu tmp;
	cout &lt;&lt; "Please input the updated datas of the third student:" &lt;&lt; endl;
	cin &gt;&gt; tmp.id &gt;&gt; tmp.name &gt;&gt; tmp.score;
	io.seekp(2 * sizeof(tmp), ios::beg);//写文件指针定位，从原来第3个学生的位置开始
	io.write((const char*)&amp;tmp, sizeof(tmp));//把修改后的数据放回文件中第3个学生的位置
	io.close();

	io.open("stu.txt", ios::binary | ios::out | ios::in);
	io.read((char*)stu, sizeof(stu));//修改完第3个学生数据后读回数组中
	io.close();//一定要关闭文件！

	cout &lt;&lt; "The students' datas read from file are:" &lt;&lt; endl;
	for (int i = 0; i &lt; 3; i++)
		cout &lt;&lt; stu[i].id &lt;&lt; " " &lt;&lt; stu[i].name &lt;&lt; " " &lt;&lt; stu[i].score &lt;&lt; endl;

	return 0;
}
</code></pre> 
<p><img alt="" height="428" src="https://images2.imgbox.com/e8/bc/g3EPPJQL_o.png" width="1200"></p> 
<p><strong><span style="color:#511b78;"><span style="background-color:#fefcd8;">问题①、C++中文件读写类对象时，如果类对象中有string类型的成员变量，如何处理？</span></span></strong></p> 
<blockquote> 
 <p>在C++中，对于类对象的二进制读写，涉及到对象的内存布局和成员变量的特性。而对于`string`这样的对象，它的内部实现复杂，包括指针指向堆上的动态内存，涉及到分配和释放内存等操作。因此，<span style="color:#511b78;"><strong>直接进行二进制读写可能会导致读取权限冲突。</strong></span>当你尝试<span style="color:#9c8ec1;"><strong>将包含`string`成员变量的对象写入文件时，实际上只会将指针的值写入文件，而不是字符串的内容</strong></span>。而在读取文件时，再次加载这个对象，那个指针就指向了一个无效的内存地址。这会导致访问非法内存，进而出现读取权限冲突。为了避免这个问题，你可以考虑使用序列化和反序列化来实现文件的读写操作。序列化是指将对象转换为序列化的字节流，而反序列化则是将字节流重新转换为对象。<strong><span style="color:#1c7331;">通过序列化和反序列化操作，可以确保对象的完整性和正确性</span></strong>。你可以使用C++的一些库（如Boost.Serialization、Protocol Buffers）来实现对象的序列化和反序列化。这些库提供了易于使用和强大的功能，让你可以方便地进行对象的读写操作，而不会发生读取权限冲突的问题。</p> 
 <p></p> 
 <p><span style="color:#1a439c;"><strong>在C++中，文件读写类对象时，是可以包含string类型的成员变量的。</strong></span>C++的文件读写操作对于大多数基本类型和标准库类型（包括string）都有支持。当你将一个自定义的类对象写入文件时，包含了string类型成员变量的类实例将被完整地写入文件中。但需要注意的是，string对象的存储是动态的，所以仅将类对象的二进制数据写入文件是不够的，还需要将string的内容一并写入文件，并在读取时进行相应处理。你可以使用C++标准库中的fstream类进行文件读写操作。例如，可以使用ofstream类对象将类对象写入文件，再使用ifstream类对象从文件中读取类对象。<span style="color:#be191c;"><strong>在写入时，可以使用成员函数c_str()将string类型转换为C风格字符串，并使用成员函数write()写入文件；在读取时，可以使用成员函数getline()读取文件中的字符串，并重新构造string对象。</strong></span></p> 
 <p><strong>注意，</strong>在进行文件读写操作时，需要保证文件的打开和关闭操作正确执行，并处理可能出现的异常情况，以确保数据的完整性与安全性。同时，为了确保跨平台的文件读写兼容性，建议在二进制读写时使用文本模式（例如使用"rb"和"wb"参数）。</p> 
</blockquote> 
<p>以下是一个简单的示例代码，<strong>演示了如何进行文件读写操作：</strong></p> 
<pre><code class="language-cpp">#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

class MyClass {
public:
    std::string name;
    int age;
};

int main() {
    MyClass obj;
    obj.name = "Alice";
    obj.age = 20;

    std::ofstream outfile("data.txt", std::ios::binary);
    if (outfile.is_open()) {
        outfile.write(obj.name.c_str(), obj.name.length() + 1);
        outfile.write(reinterpret_cast&lt;char*&gt;(&amp;obj.age), sizeof(obj.age));
        outfile.close();
        std::cout &lt;&lt; "对象写入文件成功" &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "打开文件失败" &lt;&lt; std::endl;
        return 1;
    }

    std::ifstream infile("data.txt", std::ios::binary);
    if (infile.is_open()) {
        std::string name;
        std::getline(infile, name, '\0');
        obj.name = name;
        infile.read(reinterpret_cast&lt;char*&gt;(&amp;obj.age), sizeof(obj.age));
        infile.close();

        std::cout &lt;&lt; "从文件中读取的对象：" &lt;&lt; std::endl;
        std::cout &lt;&lt; "name: " &lt;&lt; obj.name &lt;&lt; std::endl;
        std::cout &lt;&lt; "age: " &lt;&lt; obj.age &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "打开文件失败" &lt;&lt; std::endl;
        return 1;
    }

    return 0;
}</code></pre> 
<blockquote> 
 <p>该示例中，定义了一个包含string类型成员变量的MyClass类，通过ofstream对象将类的实例写入文件，再通过ifstream对象从文件中读取类对象。在写入时，使用了成员函数c_str()获取string对象的C风格字符串；在读取时，使用了成员函数getline()读取字符串，并重新构造了string对象。最后，将读取到的类对象的成员变量输出到控制台。</p> 
</blockquote> 
<p><span style="color:#511b78;"><strong><span style="background-color:#fefcd8;">问题②、c++中，在文件操作中，为什么读取完数据后，要关闭文件，才能写入数据到文件？  </span></strong></span></p> 
<blockquote> 
 <p>在C++中，<strong>关闭文件的目的</strong>不是为了读取完数据后才能写入数据到文件，而<span style="color:#511b78;"><strong>是为了确保对文件进行完整的操作并释放相关资源。</strong></span></p> 
 <p>文件在被打开后会占用一些系统资源，如文件描述符等。当读取完数据后，如果不关闭文件，文件依然保持打开状态，此时其他程序可能无法对该文件进行操作或者文件的状态可能不会及时更新。此外，一些操作系统可能会限制同时打开的文件数量，如果不关闭文件，可能会达到限制而导致其他文件无法正常打开。最重要的是，关闭文件还可以确保数据的完整性和正确性。在写入数据时，操作系统会将数据缓存到内存中，然后根据一定的策略将数据写入到文件中，这个过程是异步的。如果在写入数据的过程中突然关闭文件，可能会导致数据丢失或不完整。</p> 
 <p>因此，为了保证文件操作的正确性和系统资源的释放，我们通常会在读取完数据后关闭文件，然后再进行写入操作。这样可以确保文件的状态正确、数据的完整性并释放相关的资源。</p> 
</blockquote> 
<hr> 
<h2 id="17%E3%80%81%E5%88%86%E6%95%B0%E7%9A%84%E5%8A%A0%E5%87%8F" style="background-color:transparent;"><span style="color:#be191c;"><span style="background-color:#fef2f0;">17、分数的加减</span></span></h2> 
<p><img alt="" height="454" src="https://images2.imgbox.com/4c/2c/H96zCJWA_o.png" width="1162"></p> 
<pre><code class="language-cpp">//定义分数类，内有构造函数和显示分数的show函数，并利用友元函数实现分数的加减
#include&lt;iostream&gt;
using namespace std;

class Fraction
{
private:
	double dividend, divisor;//dividend:被除数，即分子 divisor:除数，即分母
public:
	Fraction(const double&amp; divid = 0.0, const double&amp; divir = 0.0)
		:dividend(divid)
		,divisor(divir)
	{}

	void show()
	{
		cout &lt;&lt; dividend &lt;&lt; "/" &lt;&lt; divisor &lt;&lt; endl;
	}

	friend Fraction operator+(const Fraction&amp;, const Fraction&amp;);
	friend Fraction operator-(const Fraction&amp;, const Fraction&amp;);
};

Fraction operator+(const Fraction&amp; f1, const Fraction&amp; f2)
{
	return Fraction(f1.dividend * f2.divisor + f1.divisor * f2.dividend
		, f1.divisor * f2.divisor);
}

Fraction operator-(const Fraction&amp; f1, const Fraction&amp; f2)
{
	return Fraction(f1.dividend * f2.divisor - f1.divisor * f2.dividend
		, f1.divisor * f2.divisor);
}

int main()
{
	Fraction f1(2, 3), f2(1, 2), f3;
	f3 = f1 + f2;
	f3.show();
	f3 = f1 - f2;
	f3.show();
	
	return 0;
}</code></pre> 
<p><img alt="" height="146" src="https://images2.imgbox.com/e8/f4/iXgKitwO_o.png" width="989"></p> 
<hr> 
<h2 id="%C2%A018%E3%80%81%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%90%E4%B8%AA%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0"><span style="color:#be191c;"><span style="background-color:#fef2f0;"> 18、统计字符数组中某个字符出现次数</span></span></h2> 
<pre><code class="language-cpp">//定义求一个字符数组中某字符有多少个的函数sum()，用c++实现
#include&lt;iostream&gt;
using namespace std;

int sum(char* arr, char target)
{
	int cnt = 0;
	int i = 0;
	while (arr[i] != '\0')
	{
		if (arr[i] == target)
			cnt++;
		i++;
	}

	return cnt;
}

int main()
{
	char arr[] = "hello world!";
	char target = 'o';
	int ret = sum(arr, target);
	cout &lt;&lt; target &lt;&lt; "出现了：" &lt;&lt; ret &lt;&lt; "次" &lt;&lt; endl;

	return 0;
}</code></pre> 
<p><img alt="" height="104" src="https://images2.imgbox.com/38/68/ZRcuflt2_o.png" width="1200"></p> 
<hr> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3432c52806813f23da45b2c966c878f4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python &#43; Selenium 模拟登录jd</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f89938e9d18e15df3b7c1d79374632e4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android Studio初学者实例：ContentProvider读取手机通讯录</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>