<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Rust】——所有可能会用到模式的位置 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/523e8ed2bfa47445d40857815bc817a5/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【Rust】——所有可能会用到模式的位置">
  <meta property="og:description" content="💻博主现有专栏：
C51单片机（STC89C516），c语言，c&#43;&#43;，离散数学，算法设计与分析，数据结构，Python，Java基础，MySQL，linux，基于HTML5的网页设计及应用，Rust（官方文档重点总结），jQuery，前端vue.js，Javaweb开发，Python机器学习等
🥏主页链接：
Y小夜-CSDN博客
目录
🎯match分支
🎯if let 条件表达式
🎯while let条件循环
🎯for循环
🎯let语句
🎯函数参数
🎯match分支 一个模式常用的位置是 match 表达式的分支。在形式上 match 表达式由 match 关键字、用于匹配的值和一个或多个分支构成，这些分支包含一个模式和在值匹配分支的模式时运行的表达式：
match VALUE { PATTERN =&gt; EXPRESSION, PATTERN =&gt; EXPRESSION, PATTERN =&gt; EXPRESSION, } match x { None =&gt; None, Some(i) =&gt; Some(i &#43; 1), } 这个 match 表达式中的模式为每个箭头左边的 None 和 Some(i)。
match 表达式必须是 穷尽（exhaustive）的，意为 match 表达式所有可能的值都必须被考虑到。一个确保覆盖每个可能值的方法是在最后一个分支使用捕获所有的模式：比如，一个匹配任何值的名称永远也不会失败，因此可以覆盖所有匹配剩下的情况。
🎯if let 条件表达式 以前讨论过了 if let 表达式，以及它是如何主要用于编写等同于只关心一个情况的 match 语句简写的。if let 可以对应一个可选的带有代码的 else 在 if let 中的模式不匹配时运行。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-24T10:49:23+08:00">
    <meta property="article:modified_time" content="2024-06-24T10:49:23+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Rust】——所有可能会用到模式的位置</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><strong>💻博主现有专栏：</strong></p> 
 <p><strong>                C51单片机（STC89C516），c语言，c++，离散数学，算法设计与分析，数据结构，Python，Java基础，MySQL，linux，基于HTML5的网页设计及应用，Rust（官方文档重点总结），jQuery，前端vue.js，Javaweb开发，Python机器学习等<br> 🥏主页链接：</strong></p> 
 <p><strong>                </strong><a href="https://blog.csdn.net/shsjssnn?spm=1000.2115.3001.5343" title="Y小夜-CSDN博客">Y小夜-CSDN博客</a></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%F0%9F%8E%AFmatch%E5%88%86%E6%94%AF-toc" style="margin-left:0px;"><a href="#%F0%9F%8E%AFmatch%E5%88%86%E6%94%AF" rel="nofollow">🎯match分支</a></p> 
<p id="%F0%9F%8E%AFif%20let%20%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F-toc" style="margin-left:0px;"><a href="#%F0%9F%8E%AFif%20let%20%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F" rel="nofollow">🎯if let 条件表达式</a></p> 
<p id="%F0%9F%8E%AFwhile%20let%E6%9D%A1%E4%BB%B6%E5%BE%AA%E7%8E%AF-toc" style="margin-left:0px;"><a href="#%F0%9F%8E%AFwhile%20let%E6%9D%A1%E4%BB%B6%E5%BE%AA%E7%8E%AF" rel="nofollow">🎯while let条件循环</a></p> 
<p id="%F0%9F%8E%AFfor%E5%BE%AA%E7%8E%AF-toc" style="margin-left:0px;"><a href="#%F0%9F%8E%AFfor%E5%BE%AA%E7%8E%AF" rel="nofollow">🎯for循环</a></p> 
<p id="%F0%9F%8E%AFlet%E8%AF%AD%E5%8F%A5-toc" style="margin-left:0px;"><a href="#%F0%9F%8E%AFlet%E8%AF%AD%E5%8F%A5" rel="nofollow">🎯let语句</a></p> 
<p id="%F0%9F%8E%AF%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-toc" style="margin-left:0px;"><a href="#%F0%9F%8E%AF%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0" rel="nofollow">🎯函数参数</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%F0%9F%8E%AFmatch%E5%88%86%E6%94%AF">🎯match分支</h2> 
<blockquote> 
 <p>        一个模式常用的位置是 <code>match</code> 表达式的分支。在形式上 <code>match</code> 表达式由 <code>match</code> 关键字、用于匹配的值和一个或多个分支构成，这些分支包含一个模式和在值匹配分支的模式时运行的表达式：</p> 
 <pre><code class="language-rust">match VALUE {
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
}
</code></pre> 
 <pre><code class="language-rust">match x {
    None =&gt; None,
    Some(i) =&gt; Some(i + 1),
}</code></pre> 
 <p>这个 <code>match</code> 表达式中的模式为每个箭头左边的 <code>None</code> 和 <code>Some(i)</code>。</p> 
 <p><code> match</code> 表达式必须是 <strong>穷尽</strong>（<em>exhaustive</em>）的，意为 <code>match</code> 表达式所有可能的值都必须被考虑到。一个确保覆盖每个可能值的方法是在最后一个分支使用捕获所有的模式：比如，一个匹配任何值的名称永远也不会失败，因此可以覆盖所有匹配剩下的情况。</p> 
</blockquote> 
<h2 id="%F0%9F%8E%AFif%20let%20%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F">🎯if let 条件表达式</h2> 
<blockquote> 
 <p>        以前讨论过了 <code>if let</code> 表达式，以及它是如何主要用于编写等同于只关心一个情况的 <code>match</code> 语句简写的。<code>if let</code> 可以对应一个可选的带有代码的 <code>else</code> 在 <code>if let</code> 中的模式不匹配时运行。</p> 
 <p>        这相比 <code>match</code> 表达式一次只能将一个值与模式比较提供了更多灵活性。并且 Rust 并不要求一系列 <code>if let</code>、<code>else if</code>、<code>else if let</code> 分支的条件相互关联。</p> 
 <pre><code class="language-rust">fn main() {
    let favorite_color: Option&lt;&amp;str&gt; = None;
    let is_tuesday = false;
    let age: Result&lt;u8, _&gt; = "34".parse();

    if let Some(color) = favorite_color {
        println!("Using your favorite color, {color}, as the background");
    } else if is_tuesday {
        println!("Tuesday is green day!");
    } else if let Ok(age) = age {
        if age &gt; 30 {
            println!("Using purple as the background color");
        } else {
            println!("Using orange as the background color");
        }
    } else {
        println!("Using blue as the background color");
    }
}</code></pre> 
 <p>        如果用户指定了中意的颜色，将使用其作为背景颜色。如果没有指定中意的颜色且今天是星期二，背景颜色将是绿色。如果用户指定了他们的年龄字符串并能够成功将其解析为数字的话，我们将根据这个数字使用紫色或者橙色。最后，如果没有一个条件符合，背景颜色将是蓝色。</p> 
 <p>        这个条件结构允许我们支持复杂的需求。使用这里硬编码的值，例子会打印出 <code>Using purple as the background color</code>。</p> 
 <p>        注意 <code>if let</code> 也可以像 <code>match</code> 分支那样引入覆盖变量：<code>if let Ok(age) = age</code> 引入了一个新的覆盖变量 <code>age</code>，它包含 <code>Ok</code> 成员中的值。这意味着 <code>if age &gt; 30</code> 条件需要位于这个代码块内部；不能将两个条件组合为 <code>if let Ok(age) = age &amp;&amp; age &gt; 30</code>，因为我们希望与 30 进行比较的被覆盖的 <code>age</code> 直到大括号开始的新作用域才是有效的。</p> 
 <p><code>  if let</code> 表达式的缺点在于其穷尽性没有为编译器所检查，而 <code>match</code> 表达式则检查了。如果去掉最后的 <code>else</code> 块而遗漏处理一些情况，编译器也不会警告这类可能的逻辑错误。</p> 
</blockquote> 
<h2 id="%F0%9F%8E%AFwhile%20let%E6%9D%A1%E4%BB%B6%E5%BE%AA%E7%8E%AF">🎯while let条件循环</h2> 
<blockquote> 
 <p>它使用 vector 作为栈并以先进后出的方式打印出 vector 中的值：</p> 
 <pre><code class="language-rust">    let mut stack = Vec::new();

    stack.push(1);
    stack.push(2);
    stack.push(3);

    while let Some(top) = stack.pop() {
        println!("{}", top);
    }
</code></pre> 
 <p>        这个例子会打印出 3、2 接着是 1。<code>pop</code> 方法取出 vector 的最后一个元素并返回 <code>Some(value)</code>。如果 vector 是空的，它返回 <code>None</code>。<code>while</code> 循环只要 <code>pop</code> 返回 <code>Some</code> 就会一直运行其块中的代码。一旦其返回 <code>None</code>，<code>while</code> 循环停止。我们可以使用 <code>while let</code> 来弹出栈中的每一个元素。</p> 
</blockquote> 
<h2 id="%F0%9F%8E%AFfor%E5%BE%AA%E7%8E%AF">🎯for循环</h2> 
<blockquote> 
 <p>在 <code>for</code> 循环中，模式是 <code>for</code> 关键字直接跟随的值，正如 <code>for x in y</code> 中的 <code>x</code>。</p> 
 <pre><code class="language-rust">    let v = vec!['a', 'b', 'c'];

    for (index, value) in v.iter().enumerate() {
        println!("{} is at index {}", value, index);
    }
</code></pre> 
 <p>会打印：</p> 
 <pre><code class="language-rust">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
    Finished dev [unoptimized + debuginfo] target(s) in 0.52s
     Running `target/debug/patterns`
a is at index 0
b is at index 1
c is at index 2
</code></pre> 
</blockquote> 
<h2 id="%F0%9F%8E%AFlet%E8%AF%AD%E5%8F%A5">🎯let语句</h2> 
<blockquote> 
 <p>        在本章之前，我们只明确的讨论过通过 <code>match</code> 和 <code>if let</code> 使用模式，不过事实上也在别的地方使用过模式，包括 <code>let</code> 语句。例如，考虑一下这个直白的 <code>let</code> 变量赋值：</p> 
 <pre><code class="language-rust">let x = 5;
</code></pre> 
 <p>        不过你可能没有发觉，每一次像这样使用 <code>let</code> 语句就是在使用模式！<code>let</code> 语句更为正式的样子如下：</p> 
 <pre><code class="language-rust">let PATTERN = EXPRESSION;
</code></pre> 
 <p>        像 <code>let x = 5;</code> 这样的语句中变量名位于 <code>PATTERN</code> 位置，变量名不过是形式特别朴素的模式。我们将表达式与模式比较，并为任何找到的名称赋值。所以例如 <code>let x = 5;</code> 的情况，<code>x</code> 是一个代表 “将匹配到的值绑定到变量 x” 的模式。同时因为名称 <code>x</code> 是整个模式，这个模式实际上等于 “将任何值绑定到变量 <code>x</code>，不管值是什么”。</p> 
 <p>        为了更清楚的理解 <code>let</code> 的模式匹配方面的内容，考虑示例 18-4 中使用 <code>let</code> 和模式解构一个元组：</p> 
 <pre><code class="language-rust">    let (x, y, z) = (1, 2, 3);
</code></pre> 
 <p>        这里将一个元组与模式匹配。Rust 会比较值 <code>(1, 2, 3)</code> 与模式 <code>(x, y, z)</code> 并发现此值匹配这个模式。在这个例子中，将会把 <code>1</code> 绑定到 <code>x</code>，<code>2</code> 绑定到 <code>y</code> 并将 <code>3</code> 绑定到 <code>z</code>。你可以将这个元组模式看作是将三个独立的变量模式结合在一起。</p> 
 <p>        如果模式中元素的数量不匹配元组中元素的数量，则整个类型不匹配，并会得到一个编译时错误。</p> 
 <pre><code class="language-rust">    let (x, y) = (1, 2, 3);
</code></pre> 
 <p>尝试编译这段代码会给出如下类型错误：</p> 
 <pre><code class="language-rust">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0308]: mismatched types
 --&gt; src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^   --------- this expression has type `({integer}, {integer}, {integer})`
  |         |
  |         expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected tuple `({integer}, {integer}, {integer})`
             found tuple `(_, _)`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `patterns` due to previous error
</code></pre> 
 <p>为了修复这个错误，可以使用 <code>_</code> 或 <code>..</code> 来忽略元组中一个或多个值</p> 
</blockquote> 
<h2 id="%F0%9F%8E%AF%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0">🎯函数参数</h2> 
<blockquote> 
 <p>它获取一个 <code>i32</code> 类型的参数 <code>x</code>，现在这看起来应该很熟悉：</p> 
 <pre><code class="language-rust">fn foo(x: i32) {
    // code goes here
}
</code></pre> 
 <p><code>x</code> 部分就是一个模式！类似于之前对 <code>let</code> 所做的，可以在函数参数中匹配元组。</p> 
 <pre><code class="language-rust">fn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {
    println!("Current location: ({}, {})", x, y);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&amp;point);
}</code></pre> 
 <p>        这会打印出 <code>Current location: (3, 5)</code>。值 <code>&amp;(3, 5)</code> 会匹配模式 <code>&amp;(x, y)</code>，如此 <code>x</code> 得到了值 <code>3</code>，而 <code>y</code>得到了值 <code>5</code>。</p> 
</blockquote> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/178096a91ad5252edd907b945419a25b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">神州信息与国科量子联合进军量子网络应用服务市场（中国军民两用通信技术展览会）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/66a78f818af033c201d31fffcb8d07ea/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【人工智能】百度文心一言智能体：AI领域的新里程碑</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>