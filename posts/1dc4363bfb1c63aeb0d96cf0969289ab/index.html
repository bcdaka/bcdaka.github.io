<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构之并查集 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/1dc4363bfb1c63aeb0d96cf0969289ab/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构之并查集">
  <meta property="og:description" content="找往期文章包括但不限于本期文章中不懂的知识点：
个人主页：我要学编程(ಥ_ಥ)-CSDN博客
所属专栏：数据结构（Java版） 并查集相关概念 并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题（即所谓的并、查）。比如说，我们可以用并查集来判断这两个人是否是亲戚（有没有最近公共祖先）或者两个人是否属于一个阵营等。
虽然并查集是一种树形结构，但是其底层的实现和堆一样是一个数组。这个数组的大小就代表了我们要处理的集合大小，而这个数组下标对应的值就是这个下标的根结点。如下所示：
通过上述图片我们可以知道一下几个结论：
1、查找元素属于哪个集合沿着数组表示树形关系以上一直找到根(即：树中中元素为负数的位置)；
2、查看两个元素是否属于同一个集合沿着数组表示的树形关系往上一直找到树的根，如果根相同表明在同一个集合，否则不在；
3、将两个集合归并成一个集合，即将一个集合的根结点对应的值改为另一个集合的根结点即可；
在改动的时候要注意：
(1)：另一个集合被改的下标为未被改的集合的根结点
(2)：未被改的集合的根结点的值要发生改变：加上另一个集合根结点的值。
4、集合的个数：遍历数组，数组中元素为负数的个数即为集合的个数。
模拟实现并查集 public class UnionFindSet { public int[] elem; // 将数组初始化为-1，证明每个元素刚开始都是一个独立的集合 public UnionFindSet() { elem = new int[10]; Arrays.fill(elem, -1); } public UnionFindSet(int n) { elem = new int[n]; Arrays.fill(elem, -1); } // 找到val对应的根结点 public int findRoot(int val) { // 注意val是数组的下标 // 得判断下标的合法性 if (val &lt; 0) { throw new IndexOutOfBoundsException(&#34;数据下标不合法&#34;); } // 只有当数组下标对应的值为负数时，才算找到了根节点 while (elem[val] &gt;= 0) { val = elem[val]; } return val; } // 合并两个元素 public void union(int val1, int val2){ if (val1 &lt; 0 || val2 &lt; 0) { throw new IndexOutOfBoundsException(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-21T08:30:00+08:00">
    <meta property="article:modified_time" content="2024-08-21T08:30:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构之并查集</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>找往期文章包括但不限于本期文章中不懂的知识点：</p> 
<blockquote> 
 <p><strong>个人主页：</strong><a href="https://blog.csdn.net/2301_80854132?type=blog" title="我要学编程(ಥ_ಥ)-CSDN博客">我要学编程(ಥ_ಥ)-CSDN博客</a></p> 
 <p><strong>所属专栏：<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><a href="https://blog.csdn.net/2301_80854132/category_12650676.html" title="数据结构（Java版）">数据结构（Java版）</a></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong> </p> 
</blockquote> 
<h2 style="background-color:transparent;"><span style="color:#fe2c24;">并查集相关概念 </span></h2> 
<p>并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题（即所谓的并、查）。比如说，我们可以用并查集来判断这两个人是否是亲戚（有没有最近公共祖先）或者两个人是否属于一个阵营等。</p> 
<p>虽然并查集是一种树形结构，但是其底层的实现和堆一样是一个数组。<strong><span style="color:#a2e043;">这个数组的大小就代表了我们要处理的集合大小，而这个数组下标对应的值就是这个下标的根结点</span></strong>。如下所示：</p> 
<p><img alt="" height="825" src="https://images2.imgbox.com/c0/ad/jcSI3mBS_o.png" width="1200"></p> 
<p>通过上述图片我们可以知道一下几个结论：</p> 
<p>1、查找元素属于哪个集合沿着数组表示树形关系以上一直找到根(即：树中中元素为负数的位置)；</p> 
<p>2、查看两个元素是否属于同一个集合沿着数组表示的树形关系往上一直找到树的根，如果根相同表明在同一个集合，否则不在；</p> 
<p>3、将两个集合归并成一个集合，即将一个集合的根结点对应的值改为另一个集合的根结点即可；</p> 
<p>在改动的时候要注意：</p> 
<p>(1)：另一个集合被改的下标为未被改的集合的根结点</p> 
<p>(2)：未被改的集合的根结点的值要发生改变：加上另一个集合根结点的值。</p> 
<p>4、集合的个数：遍历数组，数组中元素为负数的个数即为集合的个数。</p> 
<h2 style="background-color:transparent;"><span style="color:#fe2c24;">模拟实现并查集</span></h2> 
<pre><code class="language-java">public class UnionFindSet {
    public int[] elem;

    // 将数组初始化为-1，证明每个元素刚开始都是一个独立的集合
    public UnionFindSet() {
        elem = new int[10];
        Arrays.fill(elem, -1);
    }

    public UnionFindSet(int n) {
        elem = new int[n];
        Arrays.fill(elem, -1);
    }

    // 找到val对应的根结点
    public int findRoot(int val) {
        // 注意val是数组的下标
        // 得判断下标的合法性
        if (val &lt; 0) {
            throw new IndexOutOfBoundsException("数据下标不合法");
        }
        // 只有当数组下标对应的值为负数时，才算找到了根节点
        while (elem[val] &gt;= 0) {
            val = elem[val];
        }
        return val;
    }

    // 合并两个元素
    public void union(int val1, int val2){
        if (val1 &lt; 0 || val2 &lt; 0) {
            throw new IndexOutOfBoundsException("数据下标不合法");
        }
        // 先找到对应的根结点
        int index1 = findRoot(val1);
        int index2 = findRoot(val2);
        // 如果根结点一致，就无需合并了
        if (index1 == index2) {
            return;
        }
        
        // 这种合并方法会导致两棵树的高低不均匀
       /* elem[index1] += elem[index2];
        elem[index2] = index1;*/

        // 开始合并：看哪个树高，就把哪个树作为母树
        if (index1 &lt; index2) {
            // index1树高
            elem[index1] += elem[index2];
            elem[index2] = index1;
        } else {
            // index2树高
            elem[index2] += elem[index1];
            elem[index1] = index2;
        }
    }

    // 判断两个元素是否在同一个集合中
    public boolean isSameSet(int val1, int val2) {
        // 看看找到的根结点是否一样
        int index1 = findRoot(val1);
        int index2 = findRoot(val2);
        if (index1 == index2) {
            return true;
        }
        return false;
    }

    // 求数组中集合的个数
    public int getCountSet() {
        int count = 0;
        for (int x : elem) {
            // 如果元素下标对应的值为负树，则说明是一个集合
            if (x &lt; 0) {
                count++;
            }
        }
        return count;
    }

    // 打印集合中的全部元素
    public void printElem() {
        for (int i = 0; i &lt; elem.length; i++) {
            System.out.print(i+" ");
        }
        System.out.println();
    }
}
</code></pre> 
<p>总体实现还是比较简单的。 </p> 
<h2><span style="color:#fe2c24;">并查集的应用</span></h2> 
<h3><a class="link-info" href="https://leetcode.cn/problems/number-of-provinces/" rel="nofollow" title="547.省份数量">547.省份数量</a></h3> 
<p>题目：</p> 
<blockquote> 
 <p>有 <code>n</code> 个城市，其中一些彼此相连，另一些没有相连。如果城市 <code>a</code> 与城市 <code>b</code> 直接相连，且城市 <code>b</code> 与城市 <code>c</code> 直接相连，那么城市 <code>a</code> 与城市 <code>c</code> 间接相连。</p> 
 <p><strong>省份</strong> 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p> 
 <p>给你一个 <code>n x n</code> 的矩阵 <code>isConnected</code> ，其中 <code>isConnected[i][j] = 1</code> 表示第 <code>i</code> 个城市和第 <code>j</code> 个城市直接相连，而 <code>isConnected[i][j] = 0</code> 表示二者不直接相连。</p> 
 <p>返回矩阵中 <strong>省份</strong> 的数量。</p> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <img alt="" height="316" src="https://images2.imgbox.com/27/b4/T8ZqQwVP_o.png" width="656"> 
 <pre><strong>输入：</strong>isConnected = [[1,1,0],[1,1,0],[0,0,1]]
<strong>输出：</strong>2
</pre> 
 <p><strong>示例 2：</strong></p> 
 <img alt="" height="315" src="https://images2.imgbox.com/14/8d/DrAghHL1_o.png" width="761"> 
 <pre><strong>输入：</strong>isConnected = [[1,0,0],[0,1,0],[0,0,1]]
<strong>输出：</strong>3

</pre> 
 <p><strong>提示：</strong></p> 
 <ul><li><code>1 &lt;= n &lt;= 200</code></li><li><code>n == isConnected.length</code></li><li><code>n == isConnected[i].length</code></li><li><code>isConnected[i][j]</code> 为 <code>1</code> 或 <code>0</code></li><li><code>isConnected[i][i] == 1</code></li><li><code>isConnected[i][j] == isConnected[j][i]</code></li></ul> 
</blockquote> 
<p>思路：通过阅读题目可知：相邻的城市被称为一组省份，而我们要做的就是把省份的数量统计出来。利用并查集的思想就是：把相邻的城市合并成一个集合，然后再求集合的数量。相邻的城市就是 <code>isConnected[i][j] == 1<strong>，因此只需要遍历数组，如果相邻，就合并；最后再看集合的数量。</strong></code></p> 
<p><code><strong>代码实现：</strong></code></p> 
<pre><code class="language-java">class Solution {
    public int findCircleNum(int[][] isConnected) {
        // 因为这个数组并不是按照我们的要求来创建的，因此得发生改变
        // 重新创建一个数组
        // ufs底层的数组的长度就是城市的个数（因为最终合并的还是城市）
        UnionFindSet ufs = new UnionFindSet(isConnected.length); 
        // 遍历数组将相邻的城市合并成一组省份
        for (int i = 0; i &lt; isConnected.length; i++) {
            // 根据 提示可知：isConnected[i][j] == isConnected[j][i]
            // 即 j = i+1，也是可以的(类似去重了)
            for (int j = 0; j &lt; isConnected[i].length; j++) {
                if (isConnected[i][j] == 1) {
                    ufs.union(i, j);
                }
            }
        }
        return ufs.getCountSet();
    }
}

class UnionFindSet {
    public int[] elem;

    // 将数组初始化为1，证明每个元素刚开始都是一个独立的集合
    public UnionFindSet() {
        elem = new int[10];
        Arrays.fill(elem, -1);
    }

    public UnionFindSet(int n) {
        elem = new int[n];
        Arrays.fill(elem, -1);
    }

    // 找到val对应的根结点
    public int findRoot(int val) {
        // 注意val是数组的下标
        // 得判断下标的合法性
        if (val &lt; 0) {
            throw new IndexOutOfBoundsException("数据下标不合法");
        }
        while (elem[val] &gt;= 0) {
            val = elem[val];
        }
        return val;
    }

    // 合并两个元素
    public void union(int val1, int val2){
        if (val1 &lt; 0 || val2 &lt; 0) {
            throw new IndexOutOfBoundsException("数据下标不合法");
        }
        // 先找到对应的根结点
        int index1 = findRoot(val1);
        int index2 = findRoot(val2);
        // 如果根结点一致，就无需合并了
        if (index1 == index2) {
            return;
        }

       /* elem[index1] += elem[index2];
        elem[index2] = index1;*/

        // 开始合并：看哪个树高，就把哪个树作为母树
        if (index1 &lt; index2) {
            // index1树高
            elem[index1] += elem[index2];
            elem[index2] = index1;
        } else {
            // index2树高
            elem[index2] += elem[index1];
            elem[index1] = index2;
        }
    }

    // 判断两个元素是否在同一个集合中
    public boolean isSameSet(int val1, int val2) {
        // 看看找到的根结点是否一样
        int index1 = findRoot(val1);
        int index2 = findRoot(val2);
        if (index1 == index2) {
            return true;
        }
        return false;
    }

    // 求数组中集合的个数
    public int getCountSet() {
        int count = 0;
        for (int x : elem) {
            // 如果元素下标对应的值为负树，则说明是一个集合
            if (x &lt; 0) {
                count++;
            }
        }
        return count;
    }

    // 打印集合中的全部元素
    public void printElem() {
        for (int i = 0; i &lt; elem.length; i++) {
            System.out.print(i+" ");
        }
        System.out.println();
    }
}</code></pre> 
<p>上面是其中一种处理方式：创建一个新的同等大小的数组，并实现一个并查集；另外一种方式是：直接创建一个数组，实现部分方法：合并、求根、求集合个数。</p> 
<p>代码实现：</p> 
<pre><code class="language-java">class Solution {
    public int findCircleNum(int[][] isConnected) {
        // 创建一个新的数组
        int[] nums = new int[isConnected.length];
        Arrays.fill(nums, -1);
        for (int i = 0; i &lt; isConnected.length; i++) {
            for (int j = 0; j &lt; isConnected[i].length; j++) {
                if (isConnected[i][j] == 1) {
                    union(nums, i, j);
                }
            }
        }
        return getCountSet(nums);
    }

    private int getCountSet(int[] nums) {
        int count = 0;
        for (int i = 0; i &lt; nums.length; i++) {
            if (nums[i] &lt; 0) {
                count++;
            }
        }
        return count;
    }

    private void union(int[] nums, int i, int j) {
        // 合并两个集合
        int index1 = findRoot(nums, i);
        int index2 = findRoot(nums, j);
        // 同一个集合就不做处理
        if (index1 == index2) {
            return;
        }
        // 根据母树的高度来处理
        if (index1 &lt; index2) {
            nums[index1] += nums[index2];
            nums[index2] = index1;
        } else {
            nums[index2] += nums[index1];
            nums[index1] = index2;
        }
    }

    private int findRoot(int[] nums, int i) {
        // 题目给的数据都是合法的
        while (nums[i] &gt;= 0) {
            i = nums[i];
        }
        return i;
    }
}</code></pre> 
<h3 style="background-color:transparent;"><a class="link-info" href="https://leetcode.cn/problems/satisfiability-of-equality-equations/description/" rel="nofollow" title="990.等式方程的可满足性">990.等式方程的可满足性</a> </h3> 
<p>题目：</p> 
<blockquote> 
 <p>给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 <code>equations[i]</code> 的长度为 <code>4</code>，并采用两种不同的形式之一：<code>"a==b"</code> 或 <code>"a!=b"</code>。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。</p> 
 <p>只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 <code>true</code>，否则返回 <code>false</code>。 </p> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <pre><strong>输入：</strong>["a==b","b!=a"]
<strong>输出：</strong>false
<strong>解释：</strong>如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。
</pre> 
 <p><strong>示例 2：</strong></p> 
 <pre><strong>输入：</strong>["b==a","a==b"]
<strong>输出：</strong>true
<strong>解释：</strong>我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。
</pre> 
 <p><strong>示例 3：</strong></p> 
 <pre><strong>输入：</strong>["a==b","b==c","a==c"]
<strong>输出：</strong>true
</pre> 
 <p><strong>示例 4：</strong></p> 
 <pre><strong>输入：</strong>["a==b","b!=c","c==a"]
<strong>输出：</strong>false
</pre> 
 <p><strong>示例 5：</strong></p> 
 <pre><strong>输入：</strong>["c==c","b==d","x!=z"]
<strong>输出：</strong>true

</pre> 
 <p><strong>提示：</strong></p> 
 <ol><li><code>1 &lt;= equations.length &lt;= 500</code></li><li><code>equations[i].length == 4</code></li><li><code>equations[i][0]</code> 和 <code>equations[i][3]</code> 是小写字母</li><li><code>equations[i][1]</code> 要么是 <code>'='</code>，要么是 <code>'!'</code></li><li><code>equations[i][2]</code> 是 <code>'='</code></li></ol> 
</blockquote> 
<p>思路：其实就是遍历数组，将等价的方程字母放置一个集合。第二次遍历的时候，如果出现了不在这个集合中的元素，那么就肯定不满足；如果遍历完成之后，没有返回，那么就满足了。这里其实运用的是并查集的思想。</p> 
<p>代码实现：</p> 
<p>错误代码示例：</p> 
<pre><code class="language-java">class Solution {
    // 错误解法：
    public boolean equationsPossible(String[] equations) {
        Set&lt;Character&gt; set = new TreeSet&lt;&gt;();
        for (int i = 0; i &lt; equations.length; i++) {
            char ch1 = equations[i].charAt(0);
            char ch2 = equations[i].charAt(3);
            // 属于同一个集合就入
            if ((equations[i].charAt(1) == '=') &amp;&amp; (ch1 != ch2) ) {
                set.add(ch1);
                set.add(ch2);
            }
        }

        for (int i = 0; i &lt; equations.length; i++) {
            char ch1 = equations[i].charAt(0);
            char ch2 = equations[i].charAt(3);
            // ！下并存在集合中或者本身相同，就返回false
            if (equations[i].charAt(1) == '!') {
                if ((set.contains(ch1) &amp;&amp; set.contains(ch2)) || (ch1 == ch2) ) {
                    return false;
                }
            }
        }
        return true;
    }
}</code></pre> 
<p>上面的代码可以跑过大部分的情况，但是还有一种情况是不行的。如下图所示： </p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/94/0f/j3PT6D19_o.png" width="1200"></p> 
<p>因此，正确的解法是用并查集。</p> 
<pre><code class="language-java">class Solution {
    public boolean equationsPossible(String[] equations) {
        // 普通的集合行不通，只能用并查集解决
        int[] nums = new int[26]; // 26个小写的英文字母
        Arrays.fill(nums, -1);
        for (int i = 0; i &lt; equations.length; i++) {
            char ch1 = equations[i].charAt(0);
            char ch2 = equations[i].charAt(3);
            if (equations[i].charAt(1) == '=') {
                union(nums, ch1-'a', ch2-'a');
            }
        }

        for (int i = 0; i &lt; equations.length; i++) {
            char ch1 = equations[i].charAt(0);
            char ch2 = equations[i].charAt(3);
            if (equations[i].charAt(1) == '!') {
                if (isSameSet(nums, ch1-'a', ch2-'a')) {
                    return false;
                }
            }
        }
        return true;
    }

    private boolean isSameSet(int[] nums, int i, int j) {
        return findRoot(nums, i) == findRoot(nums, j);
    }

    private void union(int[] nums, int i, int j) {
        int index1 = findRoot(nums, i);
        int index2 = findRoot(nums, j);
        if (index1 == index2) {
            return;
        }
        if (index1 &lt; index2) {
            nums[index1] += nums[index2];
            nums[index2] = index1;
        } else {
            nums[index2] += nums[index1];
            nums[index1] = index2;
        }
    }

    private int findRoot(int[] nums, int i) {
        while (nums[i] &gt;= 0) {
            i = nums[i];
        }
        return i;
    }</code></pre> 
<p> 好啦！本期 数据结构之并查集 的学习之旅就到此结束啦！我们下一期再一起学习吧！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7ec0e94b8a25001ea1092b8089f3c1a2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ECMAScript 性能优化技巧与陷阱</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8bedcb0fdbb3aa1f8a32b7cbb1ee4555/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">未设置辅助手机的谷歌账号停用，申诉回来后登录需要手机验证，验证两次后成功恢复。</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>