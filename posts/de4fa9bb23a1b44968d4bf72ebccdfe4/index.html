<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Asp.NET Core WebAPI 入门学习笔记，超详细 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/de4fa9bb23a1b44968d4bf72ebccdfe4/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Asp.NET Core WebAPI 入门学习笔记，超详细">
  <meta property="og:description" content="1.WebAPI概述 1.1 WebAPI WebAPI 是一种传统的方式，用于构建和暴露 RESTUI风格的Web服务。它提供了丰富的功能和灵活性，可以处理各种HTTP请求，并支持各种数据格式，如JSON、XML等。
WebAPI使用控制器(Controllers)和动作方法(ActionMethods)的概念、通过路由配置将请求映射到相应的方法上。
开发人员可以使用各种属性和过滤器来处理请求、控制访问权限、验证数据等。
1.2 MinimaIAPI MinimaIAPI 是ASP.NET COre6引入的一种新的轻量级 API开发模型。
它旨在简化 API的创建过程，提供更简洁、更集中的代码结构。
MinimalAP1基于函数式编程模型，通过一个顶级的webAppiication 类来配置路由和请求处理。开发人员可以使用链式调用的方式定义路由、请求处理逻辑和中间件。这种模型更加直观和易于理解，尤其适合构建小型的、单一用途的 WebAPI。
与WebAPI相比，MinimalAPI的主要区别包括:
1.代码量更少:MinimalAPI基于函数式编程模型，代码更加简洁、消除了控制器和动作方法的概念。2.更少的依赖项:MinimalAPI不需要使用额外的NuGet包，只需使用ASP.NET Core 本身的核心包即可。3.更直观的路由配置:MinimaAP1使用链式调用的方式定义路由，路由配置更加直观和易于理解。4.更轻量级的应用:由于代码量少、依赖项少，MinimalAPI应用程序的启动时间更快，内存占用更小。 2.新建WebAPI Web API项目模板提供了一个入门版控制器:
[ApiConyroller]
[Route(&#34;[controller]&#34;)]
public class WeatherForecastController : ControllerBase
Web API控制器通常应派生自 ControllerBase 而不是 Controler。Controller派生自ControlerBase，并添加对视图的支持，因此它用于处理 Web页面，而不是WebAPI请求。如果同一控制器必须支持视图和 Web API，则派生自Controller.
写一个简洁的API，我们新建一个控制器VauleController：
using Microsoft.AspNetCore.Http; using Microsoft.AspNetCore.Mvc; namespace WebAPI.Controllers { [Route(&#34;api/[controller]/[action]&#34;)] [ApiController] public class ValuesController : ControllerBase { [HttpGet] public string Test() { return &#34;ok&#34;; } } } 在浏览器上访问：
通过在浏览器上输入api/[controller]/[action] 从而调用接口，如下图所示接口可用。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-16T11:34:10+08:00">
    <meta property="article:modified_time" content="2024-04-16T11:34:10+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Asp.NET Core WebAPI 入门学习笔记，超详细</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<h2 id="1.WebAPI%E6%A6%82%E8%BF%B0">1.WebAPI概述</h2> 
<h3 id="1.1%20WebAPI">1.1 WebAPI</h3> 
<p>WebAPI 是一种传统的方式，用于构建和暴露 RESTUI风格的Web服务。它提供了丰富的功能和灵活性，可以处理各种HTTP请求，并支持各种数据格式，如JSON、XML等。</p> 
<p>WebAPI使用控制器(Controllers)和动作方法(ActionMethods)的概念、通过路由配置将请求映射到相应的方法上。</p> 
<p>开发人员可以使用各种属性和过滤器来处理请求、控制访问权限、验证数据等。</p> 
<h3 id="1.2%20MinimaIAPI">1.2 MinimaIAPI</h3> 
<p>MinimaIAPI 是ASP.NET COre6引入的一种新的<span style="color:#fe2c24;">轻量级 API</span>开发模型。</p> 
<p>它旨在<span style="color:#fe2c24;">简化 API</span>的创建过程，提供更简洁、更集中的代码结构。</p> 
<p>MinimalAP1基于函数式编程模型，通过一个顶级的<span style="color:#4da8ee;">webAppiication </span>类来配置路由和请求处理。开发人员可以使用链式调用的方式定义路由、请求处理逻辑和中间件。这种模型更加直观和易于理解，尤其<span style="color:#fe2c24;">适合构建小型的、单一用途的 WebAPI</span>。</p> 
<p><strong>与WebAPI相比，MinimalAPI的主要区别包括:</strong></p> 
<ul><li>1.<span style="color:#a2e043;">代码量更少</span>:MinimalAPI基于函数式编程模型，代码更加简洁、消除了控制器和动作方法的概念。</li><li>2.<span style="color:#a2e043;">更少的依赖项</span>:MinimalAPI不需要使用额外的NuGet包，只需使用ASP.NET Core 本身的核心包即可。</li><li>3.更直观的路由配置:MinimaAP1使用链式调用的方式定义路由，路由配置更加直观和易于理解。</li><li>4.<span style="color:#a2e043;">更轻量级</span>的应用:由于代码量少、依赖项少，MinimalAPI应用程序的启动时间更快，内存占用更小。</li></ul> 
<h2 id="2.%E6%96%B0%E5%BB%BAWebAPI">2.新建WebAPI</h2> 
<p><strong>Web API项目模板提供了一个入门版控制器:<br> [ApiConyroller]<br> [Route("[controller]")]<br> public class WeatherForecastController : ControllerBase</strong></p> 
<p>Web API控制器通常应<strong>派生自 ControllerBase</strong> 而不是 Controler。Controller派生自ControlerBase，并添加对视图的支持，因此它用于处理 Web页面，而不是WebAPI请求。如果同一控制器必须支持视图和 Web API，则派生自Controller.</p> 
<p><img alt="" height="622" src="https://images2.imgbox.com/22/85/qu34L9ND_o.png" width="923"></p> 
<h2 id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="594" src="https://images2.imgbox.com/c8/59/B1S6zwn9_o.png" width="606"></h2> 
<p><img alt="" height="386" src="https://images2.imgbox.com/f7/ef/uUhC36VF_o.png" width="661"></p> 
<h2><img alt="" height="623" src="https://images2.imgbox.com/d9/82/DGEnHkfD_o.png" width="927"></h2> 
<h2><img alt="" height="579" src="https://images2.imgbox.com/16/a4/isGhLSfs_o.png" width="1112"></h2> 
<p>写一个简洁的API，我们新建一个控制器VauleController：</p> 
<pre><code class="language-cs">using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;

namespace WebAPI.Controllers
{
    [Route("api/[controller]/[action]")]
    [ApiController]
    public class ValuesController : ControllerBase
    {
        [HttpGet]
        public string Test()
        { 
            return "ok";
        }
    }
}</code></pre> 
<p> 在浏览器上访问：</p> 
<p><img alt="" height="778" src="https://images2.imgbox.com/08/9b/gcXsbA67_o.png" width="941"></p> 
<p>通过在浏览器上输入<span style="color:#fe2c24;">api/[controller]/[action] </span><span style="color:#0d0016;">从而调用接口，如下图所示接口可用。</span></p> 
<p><img alt="" height="221" src="https://images2.imgbox.com/1c/ef/L9zLmOIS_o.png" width="710"></p> 
<h2 id="3.%E7%BB%91%E5%AE%9A%E6%BA%90%E5%8F%82%E6%95%B0%E6%8E%A8%E7%90%86">3.绑定源参数推理</h2> 
<p>下面内容了解为主，绑定源特性定义可找到操作参数值的位置。存在以下绑定源特性:</p> 
<p><img alt="" height="419" src="https://images2.imgbox.com/c6/a4/flkmkr7F_o.png" width="942"></p> 
<ul><li>[Apicontzoller]属性将推理规则应用于<strong>操作参数的默认数据源</strong>。借助这些规则，无需通过将属性应用于操作参数来手动识别绑定源。绑定源推理规则的行为如下:</li><li>[FromSprvices]针对在 DI容器中注册的复杂类型参数进行推断。</li><li>[FromBody}针对未在 DI容器中注册的复杂类型参数进行推断。[FromBody]不适用于具有特殊含义的任何复杂</li><li>的内置类型，如IFormCollection和CancellationToken。绑定源推理代码将忽略这些特殊类型。</li><li>[FromForm]针对IFormFile和IFormFileCollection类型的操作参数进行推断。该特性不针对任何简单类型或用户定义类型进行推断。</li><li>[FromRoute]针对与路由模板中的参数相匹配的任何操作参数名称进行推断。当多个路由与一个操作参数匹配时，任何路由值都视为[FromRoute]。</li><li>[FromQuery]针对任何其他操作参数进行推断 。</li></ul> 
<h2 id="4.%E8%AE%BE%E7%BD%AEJson%E6%A0%BC%E5%BC%8F%E4%B9%8B%E5%A4%A7%E5%B0%8F%E5%86%99">4.设置Json格式之大小写</h2> 
<h2><img alt="" height="313" src="https://images2.imgbox.com/ce/7b/dMJwmIpm_o.png" width="285"></h2> 
<p><strong>ValuesController修改后：</strong></p> 
<pre><code class="language-cs">namespace WebAPI.Controllers
{
    [Route("api/[controller]/[action]")]
    [ApiController]
    public class ValuesController : ControllerBase
    {
        [HttpGet]
        public string Test()
        { 
            return "ok";
        }
        [HttpGet]
        public List&lt;TestModel&gt; Get() 
        {
            List&lt;TestModel&gt; list = new List&lt;TestModel&gt;() { };
            list.Add(new TestModel(){ Id=1,Name="张三", Description="描述",Time=DateTime.Now });
            list.Add(new TestModel() { Id = 2, Name = "李四", Description = "描述", Time = DateTime.Now });
            return list;
        }
    }
}</code></pre> 
<h2><img alt="" height="253" src="https://images2.imgbox.com/3a/fd/sTMG4FE2_o.png" width="454"></h2> 
<h2><img alt="" height="674" src="https://images2.imgbox.com/b2/ed/W89EP4w5_o.png" width="945"></h2> 
<h2><img alt="" height="394" src="https://images2.imgbox.com/aa/8b/ElRw7zAe_o.png" width="884"></h2> 
<p><strong>解决：安装 Microsoft,AspNetCore.Mvc,Newtonsoftjson 7.0.7 </strong></p> 
<h2><img alt="" height="341" src="https://images2.imgbox.com/da/03/sGPhz5Ju_o.png" width="1046"></h2> 
<p>在 Program.cs 文件 添加JSON的配置服务</p> 
<p><img alt="" height="535" src="https://images2.imgbox.com/60/24/pZLKpDlQ_o.png" width="735"></p> 
<p><img alt="" height="860" src="https://images2.imgbox.com/57/12/qk971FkE_o.png" width="843"></p> 
<h2 id="5.%E8%AE%BE%E7%BD%AEJson%E6%A0%BC%E5%BC%8F%E4%B9%8B%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96">5.设置Json格式之日期格式化</h2> 
<p><img alt="" height="208" src="https://images2.imgbox.com/e4/c3/KOuUdbVX_o.png" width="360"></p> 
<p>上诉图片返回的时间不是我们常见的 “年月份时分秒”的格式，故用户一般都看不懂，这样的日期格式给用户的体验较差。</p> 
<p><strong>笨拙的方法</strong></p> 
<p>将ValuesController返回Get 中的日期改成常见的 “<span style="color:#fe2c24;">yyyy-MM-dd HH:mm:ss</span>”，此方法缺点是List的数量越多，修改越麻烦。</p> 
<p><strong>统一设置API的日期格式</strong></p> 
<pre><code class="language-cs">    //统一设置API的日期格式
    options.SerializerSettings.DateFormatString = "yyyy-MM-dd HH:mm:ss";</code></pre> 
<p class="img-center"><img alt="" height="288" src="https://images2.imgbox.com/90/12/bB5TXx3u_o.png" width="737"></p> 
<p class="img-center"><img alt="" height="329" src="https://images2.imgbox.com/28/29/Sf0JGSUC_o.png" width="515"></p> 
<h2 id="6.%E9%80%9A%E8%BF%87%E7%B1%BB%E5%9E%8B%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC">6.通过类型设置参数默认值</h2> 
<p>默认情况下，请求的字符串参数不为空如下图所示，我们可以定义一个过滤器将请求的字符串参数设置为空。</p> 
<p class="img-center"><img alt="" height="428" src="https://images2.imgbox.com/78/11/kTZcblT8_o.png" width="520"></p> 
<p><strong>Swagger 配置</strong></p> 
<p>（1）添加查询实体</p> 
<pre><code class="language-cs">namespace WebAPI.Model
{
    /// &lt;summary&gt;
    /// 查询实体
    /// &lt;/summary&gt;
    public class SearchReq
    {
        public string Name { get; set; }
        public string Description { get; set; }
        public int PageIndex { get; set; }
        public int PageSize { get; set; }
    }
}</code></pre> 
<p>（2） 调用的方法</p> 
<p class="img-center"><img alt="" height="316" src="https://images2.imgbox.com/7a/30/AMYwa2Cm_o.png" width="424"></p> 
<p>(3) 创建Config，并创建过滤器。</p> 
<pre><code class="language-cs">using Microsoft.OpenApi.Any;
using Microsoft.OpenApi.Models;
using Swashbuckle.AspNetCore.SwaggerGen;

namespace WebAPI.Config
{
    // 定义过滤器
    public class DefaultValueSchemaFilter : ISchemaFilter
    {
        public void Apply(OpenApiSchema schema, SchemaFilterContext context)
        {
            // 判断获取的对象是否为空
            if (schema == null)
            {
                return;
            }

            var objectSchema = schema;
            // 遍历每一个属性
            foreach (var property in objectSchema.Properties) {
                // 判断如果数据类型为字符串，且默认为空
                if (property.Value.Type == "string" &amp;&amp; property.Value.Default == null)
                {
                    property.Value.Default = new OpenApiString("");
                }
            }
        }
    }
}</code></pre> 
<p>（3）配置过滤器。</p> 
<pre><code class="language-cs">builder.Services.AddSwaggerGen(option =&gt;{
    // 设置对象类型参数默认追
    option.SchemaFilter&lt;DefaultValueSchemaFilter&gt;();  // 配置过滤器
});</code></pre> 
<p>运行并请求 ValuesController 控制器的 Test 方法。</p> 
<p class="img-center"><img alt="" height="464" src="https://images2.imgbox.com/ac/21/U49JgAiK_o.png" width="448"></p> 
<h2 id="7.%E9%80%9A%E8%BF%87%E5%B1%9E%E6%80%A7%E5%90%8D%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC"><br> 7.通过属性名设置参数默认值</h2> 
<p><strong>如何根据字段名制定数值</strong>，比如设置PageIndex 和PageSize 数值，这样就不用担心默认查询时需要手动输出的麻烦(<strong>不用手动修改默认值)</strong>。</p> 
<p class="img-center"><img alt="" height="549" src="https://images2.imgbox.com/cc/06/MWoQDmWh_o.png" width="607"></p> 
<h2 id="8.%E9%80%9A%E8%BF%87%E7%89%B9%E6%80%A7%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC"><br> 8.通过特性设置参数默认值</h2> 
<p>如果有很多字段要设置默认值，在上述的过滤器设置默认值显得很繁琐，为了解决这个问题，可以<span style="color:#fe2c24;">通过特性设置参数默认值</span>。</p> 
<p>(1) 在过滤器添加</p> 
<pre><code class="language-cs">// 通过特性来实现
DefaultValueAttribute defaultAttribute = context.ParameterInfo?.GetCustomAttribute&lt;DefaultValueAttribute&gt;();
if (defaultAttribute != null)
{
    property.Value.Example = (IOpenApiAny)defaultAttribute.Value;
}</code></pre> 
<p>(2) SearchReq</p> 
<p>设置默认值</p> 
<p class="img-center"><img alt="" height="338" src="https://images2.imgbox.com/8e/87/m1M3XoLJ_o.png" width="387"></p> 
<p><span style="color:#fe2c24;">通过特性设置参数默认值</span>，后面的默认值可以直接在SearchReq字段上设置。</p> 
<p>下图是查询时，参数的默认值。</p> 
<h2 id="%E2%80%8B%E7%BC%96%E8%BE%91%C2%A09.%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><img alt="" height="506" src="https://images2.imgbox.com/5a/1e/Q1mFluBH_o.png" width="554"> <br> 9.序列化和反序列化</h2> 
<p><strong>手动序列化对象</strong>：</p> 
<p>(1). 引入命令空间 </p> 
<pre><code class="language-cs">using System.Text.Json</code></pre> 
<p>(2) 把一个对象序列化成一个字符串</p> 
<pre><code class="language-cs">        [HttpGet]
        public string Test()
        {
            List&lt;TestModel&gt; list = new List&lt;TestModel&gt;() { };
            list.Add(new TestModel() { Id = 1, Name = "张三", Description = "描述", Time = DateTime.Now });
            list.Add(new TestModel() { Id = 2, Name = "李四", Description = "描述", Time = DateTime.Now });
            // 手动序列化
            return JsonSerializer.Serialize(list); // 把一个对象序列化成一个字符串
        }</code></pre> 
<p>(3) 请求时返回一个json字符串 </p> 
<p><img alt="" height="133" src="https://images2.imgbox.com/2e/77/T5M6wtqO_o.png" width="1200"></p> 
<p>反序列化：</p> 
<pre><code class="language-cs">            List&lt;TestModel&gt; list = new List&lt;TestModel&gt;() { };
            list.Add(new TestModel() { Id = 1, Name = "张三", Description = "描述", Time = DateTime.Now });
            list.Add(new TestModel() { Id = 2, Name = "李四", Description = "描述", Time = DateTime.Now });
            // 反序列化成一个对象
            string str = JsonSerializer.Serialize(list);
            var list2=JsonSerializer.Deserialize&lt;List&lt;Tesplodel&gt;&gt;(str):</code></pre> 
<h2 id="10.%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90">10.跨域问题分析</h2> 
<p><br> 跨域问题(Cross-Origin Resource Sharing，简称CORS)是由<strong>浏览器的同源策略</strong>(Same-Origin Policy)引起的。</p> 
<p>同源策略是一种安全机制，限制了一个网页从不同源加载的资源与当前页面进行交互。<strong>同源是指两个页面的协议、域名和端口号都相同。</strong></p> 
<p><img alt="" height="328" src="https://images2.imgbox.com/45/12/wv8ZsPYm_o.png" width="911"><br> 当一个网页尝试从不同的域名、端口或协议加载资源时，浏览器会根据同源策略阻止这种跨域资源访问。例如，如果一个网页在域名A上加载的]avaScript代码试图向域名B发送Ajax请求，浏览器会阻止这个跨域请求。<br><span style="color:#fe2c24;">跨域问题的产生是因为现代Web应用程序通常采用前后端分离架构</span>，前端代码通常运行在浏览器中，而后端代码则运行在不同的服务器上。<span style="color:#fe2c24;">为了保护用户数据安全和防止恶意攻击，浏览器引入了同源策略，限制了跨域资源的访问。</span></p> 
<p>跨域问题可以<strong>通过跨域资源共享(CORS)机制来解决。CORS是一种机制</strong>，允许服务器在响应中<strong>添加一些特定的HTTP头部</strong>，告诉<strong>浏览器允许跨域访问资源</strong>。通过在服务器端配置响应头，可以允许特定的域名或所有域名跨域访问资源。<br> 通常情况下，服务器端需要设置以下HTTP头部来启用CORS:</p> 
<ul><li>1.Access-Control-Allow-Origin:指定允许访问资源的域名，可以是具体的域名或通配符(如*)表示允许所有域名访问。</li><li>2.Access-Control-Allow-Methods:指定允许的HTTP请求方法，如GET、POST等。</li><li>3.Access-Control-Allow-Headers:指定允许的自定义HTTP请求头部。</li><li>4.Access-Control-Allow-Credentials:指定是否允许发送凭据(如Cookie、HTTP认证)。</li></ul> 
<p>通过设置这些HTTP头部，服务器可以告知浏览器允许跨域访问资源，从而解决跨域问题。<br> 需要注意的是，<strong>CORS只是一种浏览器机制、对于其他非浏览器环境，如服务器之间的请求，不受同源策略的限制。</strong></p> 
<h2 id="11.%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86">11.跨域问题处理</h2> 
<p>// 添加跨域策略</p> 
<pre><code class="language-cs">//添加跨域策略
builder.Services.AddCors(options =&gt;
{
    // 策略名称 （允许所有的来源，允许所有请求头，允许所有的方法）
    options.AddPolicy("CorsPolicy", opt =&gt; opt.AllowAnyOrigin().AllowAnyHeader().AllowAnyMethod());
    // 如果需要单独处理跨域的地址，可以通过AllowAnyOrigin，AllowAnyHeader，AllowAnyMethod 进一步配置
});
</code></pre> 
<p>// 使用跨域策略</p> 
<pre><code class="language-cs">// 使用跨域策略
app.UseCors("CorsPolicy");</code></pre> 
<blockquote> 
 <p>发生跨域时、请求是经过了后端的返回数据以后，被浏览器拦截了，不给客户端。</p> 
</blockquote> 
<h2 id="12.%E5%8F%91%E8%B5%B7HttpGet%E8%AF%B7%E6%B1%82"><br> 12.发起HttpGet请求</h2> 
<p>很多时候都是别人来请求我们的API，但是也有一些时候，是我们在自身WebAPI或者MVC里面调用别人写好的API，那么如何做呢?下面以两个例子来说明。</p> 
<p><strong>前置条件</strong></p> 
<p class="img-center"><img alt="" height="341" src="https://images2.imgbox.com/7f/e9/wXhHoLP8_o.png" width="514"></p> 
<p class="img-center"><img alt="" height="521" src="https://images2.imgbox.com/52/66/GCOOefxa_o.png" width="758"></p> 
<h2 id="13.%E5%8F%91%E8%B5%B7HttpPost%E8%AF%B7%E6%B1%82"><br> 13.发起HttpPost请求</h2> 
<pre><code class="language-cs">app.MapGet("post",async(IHttpClientFactory httpclientFactory)&gt;
RequestModel reg=new RequestModel();
req.userName = "admin";
reg.passWord=“123456";
// 包装参数
var regdson = new stringContent(
JsonSerializer.Serialize(reg)
Encoding .UTF8,
Application.Json //using static System.Net.Mime.MediaTypeNames;
var httpClient = httpClientFactory.CreateClient();
using var httpResponseMessageawaithttpClient,PostAsync("http://localhost:5201/api/ogin/GetToken",reqJson);var readStr=await httpResponseMessage.Content.ReadAsStringAsync();return readstr;
});</code></pre> 
<p><a class="link-info" href="https://download.csdn.net/download/nmmking/89095518" title="案例代码">案例代码</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a66778e333b7be11e4290f274524051e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">技术爆炸！AI一图换脸新王者，Instant ID保姆级安装与使用教程！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d29f158e0669a59ddca28cb8201206ee/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Java】通过java将doc文件转换为docx</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>