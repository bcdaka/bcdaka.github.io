<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>单例模式-＞饿汉模式-＞懒汉模式-＞阻塞队列-＞模拟实现阻塞队列-＞生产者消费者模型 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/c5976b058e232a5e06b1f5a6566d85db/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="单例模式-＞饿汉模式-＞懒汉模式-＞阻塞队列-＞模拟实现阻塞队列-＞生产者消费者模型">
  <meta property="og:description" content="单例模式-&gt;是一种固定套路,类似于&#34;棋谱&#34;,按照套路来,可以避免一些问题
单例模式的特点-&gt;能够保证在某个类中只存在一个实例,不会创建多个实例
饿汉模式(线程安全):最基础的单例模式,类加载的同时就会创建实例,是线程安全的 public class Singleton { // 在类加载时就完成了实例化，避免了线程同步的问题 private static Singleton instance = new Singleton(); private Singleton() {}// 私有构造函数，防止被外部实例化 public static Singleton getInstance() {// 获取单例对象的静态方法 return instance; } } 懒汉模式 (线程不安全):类加载的时候不会创建实例,第一次使用的时候才创建实例,线程不安全 public class SingleLaze { private static volatile SingleLaze instance = null; private SingleLaze() {} // 私有构造函数，防止外部实例化 public static SingleLaze getInstance() { if (instance == null) { //首次调用get方法instance==null才会创建实例 instance = new SingleLaze(); } return instance; } } 懒汉模式(线程安全版) 两个懒汉模式横向对比可以发现,修改后的加上了锁和双重if判定以及给instance加上lvolatile 加锁/解锁在懒汉模式只会发生在第一次创建实例的时候,后面使用的时候就不需要加锁外层的if是判断当前是否已有实例对象内层if是判定是否需要创建对象,由于第一个if语句和第二个if语句之间 因为synchronized发生的阻塞过程中,期间可能instance被其他线程创建了实例,所以双重判定在多线程/阻塞中很有必要volatile修饰instance确保多线程情况下的内存可见性和禁止指令重排序 public class SingleLaze { private static volatile SingleLaze instance = null; private SingleLaze() {} // 私有构造函数，防止外部实例化 public static SingleLaze getInstance() { if (instance == null) { // 第一次检查，避免已有实例对象,再次创建新的对象情况 synchronized (SingleLaze.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-15T09:57:28+08:00">
    <meta property="article:modified_time" content="2024-07-15T09:57:28+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">单例模式-＞饿汉模式-＞懒汉模式-＞阻塞队列-＞模拟实现阻塞队列-＞生产者消费者模型</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><strong>单例模式-&gt;是一种固定套路,类似于"棋谱",按照套路来,可以避免一些问题</strong></p> 
 <p></p> 
 <p><strong>单例模式的特点-&gt;能够保证在某个类中只存在一个实例,不会创建多个实例</strong></p> 
</blockquote> 
<h3>饿汉模式(线程安全):最基础的单例模式,类加载的同时就会创建实例,是线程安全的</h3> 
<pre><code class="language-java">public class Singleton {
    // 在类加载时就完成了实例化，避免了线程同步的问题
    private static Singleton instance = new Singleton();

    private Singleton() {}// 私有构造函数，防止被外部实例化

    public static Singleton getInstance() {// 获取单例对象的静态方法
        return instance;
    }
}</code></pre> 
<h3>懒汉模式 (线程不安全):类加载的时候不会创建实例,第一次使用的时候才创建实例,线程不安全</h3> 
<pre><code class="language-java">public class SingleLaze {
    private static volatile SingleLaze instance = null;

    private SingleLaze() {} // 私有构造函数，防止外部实例化

    public static SingleLaze getInstance() {
        if (instance == null) { //首次调用get方法instance==null才会创建实例
             instance = new SingleLaze();           
        }
        return instance;
    }
}</code></pre> 
<h3>懒汉模式(线程安全版)</h3> 
<p>两个懒汉模式横向对比可以发现,修改后的加上了锁和双重if判定以及给instance加上lvolatile </p> 
<ul><li>加锁/解锁在懒汉模式只会发生在第一次创建实例的时候,后面使用的时候就不需要加锁</li><li>外层的if是判断当前是否已有实例对象</li><li>内层if是判定是否需要创建对象,由于第一个if语句和第二个if语句之间 因为synchronized发生的阻塞过程中,期间可能instance被其他线程创建了实例,所以双重判定在多线程/阻塞中很有必要</li><li>volatile修饰instance确保多线程情况下的内存可见性和禁止指令重排序</li></ul> 
<pre><code class="language-java">public class SingleLaze {
    private static volatile SingleLaze instance = null;

    private SingleLaze() {} // 私有构造函数，防止外部实例化

    public static SingleLaze getInstance() {
        if (instance == null) { // 第一次检查，避免已有实例对象,再次创建新的对象情况

            synchronized (SingleLaze.class) { // 使用类对象作为锁,里面表示了singlelaze这个类

                if (instance == null) { // 第二次检查，确保单例

                    instance = new SingleLaze();
                }
            }
        }
        return instance;
    }
}</code></pre> 
<p>阻塞队列是什么?</p> 
<blockquote> 
 <ul><li>阻塞队列是一种线程安全的数据结构,并具有以下特性</li><li>当队列空的时候,出队列操作就会阻塞,直到有元素入队列</li><li>当队列满的时候,入队列操作就会阻塞,直到有元素出队列</li></ul> 
</blockquote> 
<p>为什么要用阻塞队列?</p> 
<p>在包饺子的场景中,如果不用阻塞队列,擀饺子皮的一直擀,但是包饺子的包的很慢,会出现饺子皮摆不下桌子的情况,如果用到阻塞队列,擀的人快,在桌子摆不下的情况就会阻塞等待,直到桌子能摆的下再擀,而包饺子快的情况下,就会等有饺子皮再包</p> 
<p><img alt="" height="478" src="https://images2.imgbox.com/4e/b0/aLPNKC7N_o.png" width="934"></p> 
<h3>标准库中阻塞队列BlockingQueue</h3> 
<pre><code class="language-java">BlockingQueue&lt;String&gt; queue=new ArrayBlockingQueue&lt;String&gt;(1000);
//创建新的阻塞队列,元素类型string,元素个数1000
        
queue.put("abc");//put阻塞式入队列
// 需要throws声明可能会抛出异常
        
String elem=queue.take();//阻塞式出队列
//elem元素</code></pre> 
<h3 style="background-color:transparent;"> 模拟实现阻塞队列</h3> 
<ol><li>使用循环队列的方式来实现<img alt="" height="268" src="https://images2.imgbox.com/75/93/tfc5TV8f_o.jpg" width="304"></li><li>put插入元素的时候,判定如果队列满了,就进行wait(需要注意要循环进行wait,可能在被唤醒的时候队列依旧是满的)</li><li>take取出元素的时候,判定如果队列为空,就进行wait(也需要循环wait,<strong>确保线程在唤醒后能够再次检查等待条件，从而避免虚假唤醒等问题</strong>)</li><li> 唤醒需要注意逻辑问题,wait是在满了或者空了的情况下才会运行,并且数据不可能是又满又空的状态,所以一次只会唤醒一个wait,两个wait不会同时运行,只有put下面的notify才能唤醒take上的wait,同理也只有take下面的notify才能唤醒put的wait</li><li>注意while和读写操作都要上锁,并且是一把锁才有用</li></ol> 
<p>代码实现</p> 
<pre><code class="language-java">public class MyBlockingQueue1 {
    //为了简单,不写作泛型,只考虑元素类型是string
    private String[]elems=null;
    private int head=0;//指向头结点下标
    private int tail=0;//指向尾节点下标
    private int size=0;//当前数组所存的元素个数

    //准备锁对象
    private Object locker =new Object();

    public MyBlockingQueue1(int capacity){//使用构造函数指定阻塞队列的最大容量
        elems=new String[capacity];
    }

    public void put(String elem) throws InterruptedException {
        synchronized (locker){
            while (size&gt;=elems.length){
                locker.wait();//当前所占容量等于或超过最大容量,就阻塞等待
            }
            //没满
            elems[tail++]=elem;//将传入的元素从尾节点插入到数组,同时尾节点++
            if(tail&gt;= elems.length){
                tail=0;
            }
            size++;//元素个数++

            //入队成功后唤醒可能在take时候阻塞的wait
            locker.notify();

        }
    }

    public String take() throws InterruptedException {
        String elem=null;//在锁里面创建对象就在锁外面返回不了
        synchronized (locker){
            while (size==0){
                locker.wait();//当前数组元素为0,就阻塞等待
            }
            //没空
            elem=elems[head++];
            if(head&gt;= elems.length){
                head=0;
            }
            size--;//元素个数++

            //入队成功后唤醒可能在take时候阻塞的wait
            locker.notify();
        }
        return elem;
    }

    public static void main(String[] args) throws InterruptedException {
        MyBlockingQueue1 queue=new MyBlockingQueue1(1000);
        queue.put("aaa");
        queue.put("bbb");
        queue.put("ccc");
        queue.put("ddd");

        String elem= queue.take();
        System.out.println("elem="+elem);
         elem= queue.take();
        System.out.println("elem="+elem);
         elem= queue.take();
        System.out.println("elem="+elem);
         elem= queue.take();
        System.out.println("elem="+elem);
    }
}
</code></pre> 
<p>运行结果</p> 
<p><img alt="" height="164" src="https://images2.imgbox.com/e2/13/t8OVPfg2_o.png" width="419"></p> 
<h3>使用模拟实现的阻塞队列实现生产者消费者模型</h3> 
<p> 只需要更改主函数内容</p> 
<pre><code class="language-java">public static void main(String[] args)  {
        MyBlockingQueue1 queue=new MyBlockingQueue1(1000);

        //生产者
        Thread t1=new Thread(()-&gt;{
            int n=1;
            while (true){
                try {
                    queue.put(n+"");
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("生产元素"+n);
                n++;
            }
        });

        //消费者
        Thread t2=new Thread(()-&gt;{
           while (true){
               try {
                   String n= queue.take();
                   System.out.println("消费元素"+n);
               //    Thread.sleep(500);
               } catch (InterruptedException e) {
                   e.printStackTrace();
               }
           }
        });

        t1.start();
        t2.start();
    }
}</code></pre> 
<p>如果在生产后加上延时,消费后不加延时,就会出现生产一个消费一个的情况</p> 
<p><img alt="" height="371" src="https://images2.imgbox.com/7f/3e/14375WcG_o.png" width="265"></p> 
<p>如果在消费后面加上延时而生产后面不加延时,就会出现生产了1000多个才开始消费第一个的情况</p> 
<p> <img alt="" height="422" src="https://images2.imgbox.com/c7/c0/bsLRFBKe_o.png" width="214"></p> 
<h3></h3> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2181ba423a328c30496822dde18f4624/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【AI大模型】李彦宏从“卷模型”到“卷应用”的深度解析：卷用户场景卷能给用户解决什么问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9a7dc4d384614fc30706033bc3bc52b6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【爱上C&#43;&#43;】vector模拟实现</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>