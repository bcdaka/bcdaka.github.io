<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>前端冲刺必备指南 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/915807d928b111b3c3661f76d6810058/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="前端冲刺必备指南">
  <meta property="og:description" content="前言 每天努力一点点💪，就能升职加薪💰当上总经理出任 CEO 迎娶白富美走上人生巅峰🗻，想想还有点小激动呢😎。
希望能够把每一处知识点，说明白，（当然，如果哪一处不了解，可以在评论区进行探讨哦！）⏰，计时开始！
如果您发现本文有帮助，请您点赞，收藏，评论，留下您学习的脚印👣，我很乐意谈论😃
话不多说，开始学习！！！
我会不断修改这篇文章内容，一起来探讨吧！😁
学习 css 布局🤣 display 属性，它是 css 中最重要的用于控制布局的属性，每个元素都有一个默认的 display 值，这与元素的类型有关，大多数元素的默认值一般是 block 或 inline。
每个元素都有一个默认的 display
block 元素叫做块级元素；inline 元素叫做行内元素
常用的 display 值，有时候为 none，它是用来再不删除元素的情况下隐藏或显示，display:none。
display 设置成 none 元素不会占据它本来应该显示的空间；使用 visibility:hidden 会占据空间，只是隐藏了，元素还在。
position 属性：static 是默认值，口诀，子绝父相。fixed，一个固定定位元素会相对于视窗来定位，即使页面滚动，它也会停留再相同的位置上。
css 属性中的 float，float 可实现文字环绕图片效果：
img { float: right; margin: 0 0 1em 1em;} 复制代码
clear 属性可以用于被控制的浮动元素，如果一个盒子添加了 float: left 浮动，可以使用 clear: left 清楚元素的向左浮动。
清楚浮动，clearfix hack，可以使用新的 css 样式：
.clearfix { overflow: auto;} 复制代码">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-19T07:28:42+08:00">
    <meta property="article:modified_time" content="2024-06-19T07:28:42+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">前端冲刺必备指南</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>前言</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/11/a1/TzrcT3m0_o.jpg"></p> 
<p>每天努力一点点💪，就能升职加薪💰当上总经理出任 CEO 迎娶白富美走上人生巅峰🗻，想想还有点小激动呢😎。</p> 
<p></p> 
<p>希望能够把每一处知识点，说明白，（当然，如果哪一处不了解，可以在评论区进行探讨哦！）⏰，计时开始！</p> 
<p></p> 
<p>如果您发现本文有帮助，请您点赞，收藏，评论，留下您学习的脚印👣，我很乐意谈论😃</p> 
<p></p> 
<p>话不多说，开始学习！！！</p> 
<p></p> 
<blockquote> 
 <p>我会不断修改这篇文章内容，一起来探讨吧！😁</p> 
</blockquote> 
<p></p> 
<h4>学习 css 布局🤣</h4> 
<p></p> 
<p>display 属性，它是 css 中最重要的用于控制布局的属性，每个元素都有一个默认的 display 值，这与元素的类型有关，大多数元素的默认值一般是 block 或 inline。</p> 
<p></p> 
<ul><li> <p>每个元素都有一个默认的 display</p> </li></ul> 
<p></p> 
<p>block 元素叫做块级元素；inline 元素叫做行内元素</p> 
<p></p> 
<p>常用的 display 值，有时候为 none，它是用来再不删除元素的情况下隐藏或显示，display:none。</p> 
<p></p> 
<p>display 设置成 none 元素不会占据它本来应该显示的空间；使用 visibility:hidden 会占据空间，只是隐藏了，元素还在。</p> 
<p></p> 
<p>position 属性：static 是默认值，口诀，子绝父相。fixed，一个固定定位元素会相对于视窗来定位，即使页面滚动，它也会停留再相同的位置上。</p> 
<p></p> 
<p>css 属性中的 float，float 可实现文字环绕图片效果：</p> 
<p></p> 
<pre><code>img {<!-- --></code><code>    float: right;</code><code>    margin: 0 0 1em 1em;</code><code>}</code></pre> 
<p>复制代码</p> 
<p></p> 
<p>clear 属性可以用于被控制的浮动元素，如果一个盒子添加了 float: left 浮动，可以使用 clear: left 清楚元素的向左浮动。</p> 
<p></p> 
<p>清楚浮动，clearfix hack，可以使用新的 css 样式：</p> 
<p></p> 
<pre><code>.clearfix {<!-- --></code><code>    overflow: auto;</code><code>}</code></pre> 
<p>复制代码</p> 
<p></p> 
<p>百分比宽度，百分比是一种相对于包含块的计量单位。</p> 
<p></p> 
<pre><code>.clearfix {<!-- --></code><code>    float: right;</code><code>    width: 50%;</code><code>}</code>
<code>nav {<!-- --></code><code>  float: left;</code><code>  width: 15%;</code><code>}</code>
<code>section {<!-- --></code><code>  margin-left: 15%;</code><code>}</code></pre> 
<p>复制代码</p> 
<p></p> 
<p><strong>响应式设计</strong>是一种让网站针对不同的浏览器和设备“呈现”不同显示效果的策略，可以让网站在不同情况下呈现很好的效果。</p> 
<p></p> 
<p>inline-block 为行内块标签</p> 
<p></p> 
<pre><code>.box {<!-- --></code><code>  float: left;</code><code>  width: 200px;</code><code>  height: 100px;</code><code>  margin: 1em;</code><code>}</code><code>.after-box {<!-- --></code><code>  clear: left;</code><code>}</code>
<code>// 相同效果</code><code>.box1 {<!-- --></code><code>  display: inline-block;</code><code>  width: 200px;</code><code>  height: 100px;</code><code>  margin: 1em;</code><code>}</code></pre> 
<p>复制代码</p> 
<p></p> 
<p>flexbox 是 css3 种的一种新的布局模式，用于满足现代 web 的复杂需求。</p> 
<p></p> 
<p></p> 
<p class="img-center"><img alt="" height="236" src="https://images2.imgbox.com/8b/0e/3oH0o4eZ_o.png" width="300"></p> 
<p></p> 
<pre><code>&lt;div class="flex-container"&gt;</code><code>    &lt;div class="flex-item"&gt;flex item 1&lt;/div&gt;</code><code>    &lt;div class="flex-item"&gt;flex item 2&lt;/div&gt;</code><code>&lt;/div&gt;</code>
<code>.flex-container {<!-- --></code><code>    display: -webkit-flex;</code><code>    display: flex;</code><code>    width: 300px;</code><code>    height: 240px;</code><code>    background-color: Silver;</code><code>}</code>
<code>.flex-item {<!-- --></code><code>    background-color: DeepSkyBlue;</code><code>    width: 100px;</code><code>    height: 100px;</code><code>    margin: 5px;</code><code>}</code></pre> 
<p>复制代码</p> 
<p></p> 
<h4>JavaScript 变量😊</h4> 
<p></p> 
<p>1，Int 整型</p> 
<p>2，Float 浮点</p> 
<p>3，Boolean 布尔</p> 
<p>4，String 字符串</p> 
<p>5，Array 数组</p> 
<p>6，Object 对象</p> 
<p>7，Function 函数</p> 
<p>8，Regular Expression 正则</p> 
<p></p> 
<blockquote> 
 <p>驼峰命名法😀</p> 
</blockquote> 
<p></p> 
<ul><li> <p>全部小写，单词与单词间用下划线分割</p> </li><li> <p>大小写混合，大驼峰，每个单词首字母大写，小驼峰，第一个单词首字母小写，其他首字母大写。</p> </li></ul> 
<p></p> 
<blockquote> 
 <p>规则😁</p> 
</blockquote> 
<p></p> 
<p>首字符，英文字母或者下划线；组成，英文字母，数字，下划线；（禁用，JavaScript 关键词与保留字）</p> 
<p></p> 
<blockquote> 
 <p>声明😃</p> 
</blockquote> 
<p></p> 
<p>显示声明，使用 var 变量名，（{没有类型，重复声明，隐式声明，不声明直接复制}），（{先声明，后读写，先赋值，后运算}）。</p> 
<p></p> 
<blockquote> 
 <p>变量类型😃</p> 
</blockquote> 
<p></p> 
<p>值类型，占用空间固定，保存在栈中，保存与复制的是值本身，使用 typeof 检测数据的类型，基本类型数据是值类型。</p> 
<p></p> 
<p>引用类型，占用空间 不固定，保存在堆中，保存与复制的是指向对象的一个指针，使用 instanceof 检测数据的类型，使用 new()方法构造出的对象是引用型。</p> 
<p></p> 
<blockquote> 
 <p>作用域😄</p> 
</blockquote> 
<p></p> 
<p>全局变量，包括，在函数体外定义的变量，在函数体内部定义的无 var 的变量；调用，在任何位置。</p> 
<p></p> 
<p>局部变量，包括，在函数内部使用 var 声明的变量，函数的参数变量；调用，当前函数体内部。</p> 
<p></p> 
<p>优先级，局部变量高于同名全局变量，参数变量高于同名全局变量，局部变量高于同名参数变量。</p> 
<p></p> 
<p>特性：忽略块级作用域，全局变量是全局对象的属性，局部变量是调用对象的属性。</p> 
<p></p> 
<p>作用域链，内层函数可访问外层函数局部变量，外层函数不能访问内层函数局部变量。</p> 
<p></p> 
<p>声明周期：全局变量，除了被删除，否则一直在，局部变量，声明起到函数运行完毕或显示删除。回收机制，标记清楚，引用计数。</p> 
<p></p> 
<h4>逻辑运算符😅</h4> 
<p></p> 
<blockquote> 
 <p>！逻辑非</p> 
</blockquote> 
<p></p> 
<p>返回 true</p> 
<p></p> 
<pre><code>空字符串</code><code>0</code><code>null</code><code>NaN</code><code>undefined</code></pre> 
<p>复制代码</p> 
<p></p> 
<p>返回 false</p> 
<p></p> 
<pre><code>对象</code><code>非空字符串</code><code>非0数值（Infinity）</code></pre> 
<p>复制代码</p> 
<p></p> 
<p>注意：逻辑非，连续使用两次，可以将任意类型转为布尔型值</p> 
<p></p> 
<blockquote> 
 <p>&amp;&amp;逻辑与😆</p> 
</blockquote> 
<p></p> 
<ul><li> <p>当第一个操作数是对象，返回第二个操作数</p> </li><li> <p>当第二个操作数是对象，第一个操作数值为 true 时返回该对象</p> </li><li> <p>两个操作数都是对象，返回第二个操作数</p> </li></ul> 
<p></p> 
<ol><li> <p>一个操作数为 null 时，返回 null</p> </li><li> <p>一个操作数为 NaN 时，返回 NaN</p> </li><li> <p>一个操作数为 undefined，返回 undefined</p> </li></ol> 
<p></p> 
<p>注意：当第一个操作数的值时 false，则不对第二个操作数进行求值。</p> 
<p></p> 
<blockquote> 
 <p>逻辑或 ||😉</p> 
</blockquote> 
<p></p> 
<ul><li> <p>第一个操作数是对象，返回第一个操作数</p> </li><li> <p>第一个操作数值为 false，返回第二个操作数</p> </li><li> <p>两个操作数都是对象，返回第一个操作数</p> </li><li> <p>两个操作数都是 null，返回 null</p> </li><li> <p>两个操作数都是 NaN，返回 NaN</p> </li><li> <p>两个操作数都是 undefined，返回 undefined</p> </li></ul> 
<p></p> 
<p>注意：如果第一个操作数值为 true，就不会对第二个操作数求值。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/78/4c/fp6AWsXw_o.png"></p> 
<h4>JavaScript 数组</h4> 
<p></p> 
<blockquote> 
 <p>添加</p> 
</blockquote> 
<p></p> 
<p>push()在数组末尾添加数组</p> 
<p>unshift()在数组头部添加元素</p> 
<p>concat()合并两个数组</p> 
<p></p> 
<blockquote> 
 <p>删除</p> 
</blockquote> 
<p></p> 
<p>pop()删除并返回数值的最后一个元素</p> 
<p>shift()删除并返回数组的第一个元素</p> 
<p></p> 
<p>队列方法（先进先出）；栈方法（后进先出）。</p> 
<p></p> 
<blockquote> 
 <p>splice()和 slice()</p> 
</blockquote> 
<p></p> 
<p>splice()</p> 
<p></p> 
<ul><li> <p>删除任意数量的项：1，要删除的起始下标，2，要删除的项数</p> </li><li> <p>在指定位置插入指定的项：1，起始下标，2，0（不删除任何项），3，要插入的项。</p> </li><li> <p>替换任意数量的项：1，起始下标，2，要删除的项数，3，要插入的项</p> </li></ul> 
<p></p> 
<p>splice()方法，注解，<strong>该方法会改变原始数组</strong>。用于添加或删除数组中的元素。</p> 
<p></p> 
<pre><code>arrayObject.splice(index,howmany,item1,.....,itemX)</code>
<code>var arr = ['a', 'b', 'c']</code>
<code>arr.splice(2,1) // 删除一个，返回删除元素的数组</code>
<code>['c']</code>
<code>arr.splice(2,0) // 删除0个，返回空数组</code>
<code>[]</code>
<code>var array = [1,2,3,4,5];</code><code>array.splice(3,2);</code><code>console.log(array);</code><code>// 结果: [1,2,3]</code>
<code>var myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];</code><code>var removed = myFish.splice(2);</code><code>// 从第 2 位开始删除所有元素</code><code>// 运算后的 myFish: ["angel", "clown"]</code><code>// 被删除的元素: ["mandarin", "sturgeon"]</code></pre> 
<p>复制代码</p> 
<p></p> 
<blockquote> 
 <p>所有主要浏览器都支持 splice()</p> 
</blockquote> 
<p></p> 
<p>Array 数组的 splice()方法，它的作用删除，插入，替换</p> 
<p></p> 
<p>插入的用法</p> 
<p></p> 
<pre><code>语法：array.splice(starti,0,值1，值2...);</code>
<code>// 表示要在哪个位置插入，0表示删除0个元素，因为插入和替换都是由删除功能拓展的，值1，值2，需要插入的值</code>
<code>var array = [1,2,3,4,5];</code><code>array.splice(2,0,11,22);</code>
<code>// 结果：[1,2,11,22,3,4,5]</code></pre> 
<p>复制代码</p> 
<p></p> 
<p>替换的用法</p> 
<p></p> 
<pre><code>语法:array.splice(starti,n,值1，值2);</code>
<code>var array = [1,2,3,4,5];</code><code>array.splice(2,2,11,22);</code>
<code>// 结果：[1,2,11,22,5]</code></pre> 
<p>复制代码</p> 
<p></p> 
<blockquote> 
 <p>slice()功能，从已有数组中选取部分元素构成新数组</p> 
</blockquote> 
<p></p> 
<ol><li> <p>返回项的起始位置</p> </li><li> <p>返回项的结束位置</p> </li></ol> 
<p></p> 
<p>特性，如果是负数，则用数组长度加上该值确定位置，启示位置实为数组的实际下标，结束位置的实际下标为结束数值减 1。</p> 
<p></p> 
<p>Array.prototype.slice()</p> 
<p></p> 
<p>slice()方法返回一个新的数组对象。<strong>原始数组不会被改变。</strong>这一对象是一个由 begin 和 end 决定的<strong>原数组的浅拷贝。</strong></p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/55/c3/1lKPpzS2_o.jpg"></p> 
<p></p> 
<pre><code>const animals = ['1', '2', '3', '4', '5'];</code>
<code>console.log(animals.slice(2));</code><code>// expected output: Array ["3", "4", "5"]</code>
<code>console.log(animals.slice(2, 4));</code><code>// expected output: Array ["3", "4"]</code>
<code>console.log(animals.slice(1, 5));</code><code>// expected output: Array ["2", "3", "4", "5"]</code></pre> 
<p>复制代码</p> 
<p></p> 
<p>slice(start,end)，从 start 开始截取到 end 单不包含 end，返回值为截取出来的元素的集合(只是返回一个浅复制了原数组中的元素的要给新数组)</p> 
<p></p> 
<pre><code>var fruits = ['a', 'b', 'c', 'd', 'e'];</code><code>var citrus = fruits.slice(1, 3);</code>
<code>// fruits contains ['a', 'b', 'c', 'd', 'e']</code><code>// citrus contains ['b','c']</code></pre> 
<p>复制代码</p> 
<p></p> 
<p>slice 方法用一个类数组对象/集合转换成一个新数组。</p> 
<p></p> 
<pre><code>function list() {<!-- --></code><code>  return Array.prototype.slice.call(arguments);</code><code>}</code>
<code>var list1 = list(1, 2, 3); // [1, 2, 3]</code></pre> 
<p>复制代码</p> 
<p></p> 
<p>在 JavaScript 中，几乎所有东西都是一个对象，除了 string，number 和 booleans 这样不可变的原始值。</p> 
<p></p> 
<p>Array.prototype.slice</p> 
<p></p> 
<pre><code>function myFunc() {<!-- --></code><code>    // 错误, arguments是一个类数组对象, 不是一个真实的数组</code><code>    arguments.sort();</code><code>    // 借用 Array 原型中的方法 slice</code><code>    // 它接受一个类数组对象 (key:value)</code><code>    // 并返回一个真实的数组</code><code>    var args = Array.prototype.slice.call(arguments);</code><code>    // args 现在是一个真正的数组, 所以可以使用Array的sort()方法</code><code>    args.sort();</code><code>}</code></pre> 
<p>复制代码</p> 
<p></p> 
<p>数组排序，reverse()颠倒数组中元素的顺序，sort()对字符数组或数字数组进行排序。</p> 
<p></p> 
<pre><code>function compare(value1, value2) {<!-- --></code><code>    if(value1 &lt; value2) {<!-- --></code><code>        return -1;</code><code>    }else if(value1 &gt; value2) {<!-- --></code><code>        return 1;</code><code>    }else{<!-- --></code><code>        return 0;</code><code>    }</code><code>}</code></pre> 
<p>复制代码</p> 
<p></p> 
<blockquote> 
 <p>数组转换</p> 
</blockquote> 
<p></p> 
<ul><li> <p>toString()转换为字符串并返回</p> </li><li> <p>toLocaleString()转换为本地格式字符串并返回</p> </li><li> <p>join()用指定分割符分割数组并转换为字符串</p> </li></ul> 
<p></p> 
<p>toString()函数用于将当前对象已字符串的形式返回。该方法属于 Object 对象。</p> 
<p></p> 
<p>迭代方法：参数</p> 
<p></p> 
<ul><li> <p>every 如果该函数对每一项都返回 true，则返回 true</p> </li><li> <p>filter 返回值为 true 的所有数组成员</p> </li><li> <p>forEach <strong>无返回值</strong></p> </li><li> <p>map 返回每次函数调用的结果数组</p> </li><li> <p>some 有任意一项返回 true，则返回 true</p> </li></ul> 
<p></p> 
<p>接收参数：</p> 
<p></p> 
<ol><li> <p>要在每一项上运行的函数</p> </li><li> <p>运行该函数的作用域对象</p> </li></ol> 
<p></p> 
<p>传入参数：</p> 
<p></p> 
<ol><li> <p>数组项的值 item</p> </li><li> <p>该项在数组中的位置 index</p> </li><li> <p>数组对象本身 array</p> </li></ol> 
<p></p> 
<p>缩小方法：</p> 
<p></p> 
<ul><li> <p>reduce 从数组起始位开始遍历</p> </li><li> <p>reduceRight 从数组末尾开始遍历</p> </li></ul> 
<p></p> 
<p>reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。</p> 
<p></p> 
<p>reduce() 可以作为一个高阶函数，用于函数的 compose。</p> 
<p></p> 
<p>注意: reduce() <strong>对于空数组是不会执行回调函数的</strong>。</p> 
<p></p> 
<pre><code>var numbers = [1, 2, 3, 4];</code><code>numbers.reduce(回调函数);</code></pre> 
<p>复制代码</p> 
<p></p> 
<pre><code>const array1 = [1, 2, 3, 4];</code><code>const reducer = (accumulator, currentValue) =&gt; accumulator + currentValue;</code>
<code>// 1 + 2 + 3 + 4</code><code>console.log(array1.reduce(reducer));</code><code>//  10</code>
<code>// 5 + 1 + 2 + 3 + 4</code><code>console.log(array1.reduce(reducer, 5));</code><code>//  15</code>
<code>var arr = [1,2,3,4];</code><code>// 求和</code><code>var sum = arr.reduce((x,y)=&gt;x+y)</code><code>var sum1 = arr.reduce((x,y)=&gt;x*y)</code></pre> 
<p>复制代码</p> 
<p></p> 
<p>求数组项的最大值</p> 
<p></p> 
<pre><code>var max = arr.reduce(function (prev, cur) {<!-- --></code><code>    return Math.max(prev,cur);</code><code>});</code></pre> 
<p>复制代码</p> 
<p>取两值最大值后继续进入下一轮回调。</p> 
<p></p> 
<p>数组去重</p> 
<p></p> 
<p></p> 
<p class="img-center"><img alt="" height="207" src="https://images2.imgbox.com/46/9e/BGD7vqi8_o.png" width="402"></p> 
<p></p> 
<pre><code>arr.reduce(function(prev,cur,index,arr){<!-- --></code><code>...</code><code>}, init);</code>
<code>arr 表示原数组；</code><code>prev 表示上一次调用回调时的返回值，或者初始值 init;</code><code>cur 表示当前正在处理的数组元素；</code><code>index 表示当前正在处理的数组元素的索引，若提供 init 值，则索引为0，否则索引为1；</code><code>init 表示初始值。</code>
<code>arr.reduce(callback,[initialValue])</code><code>initialValue （作为第一次调用 callback 的第一个参数。）</code></pre> 
<p>复制代码</p> 
<p></p> 
<p>如果这个数组为空，运用 reduce 是什么情况？</p> 
<p></p> 
<pre><code>var  arr = [];</code><code>var sum = arr.reduce(function(prev, cur, index, arr) {<!-- --></code><code>    console.log(prev, cur, index);</code><code>    return prev + cur;</code><code>})</code><code>//报错，"TypeError: Reduce of empty array with no initial value"</code>
<code>var  arr = [];</code><code>var sum = arr.reduce(function(prev, cur, index, arr) {<!-- --></code><code>    console.log(prev, cur, index);</code><code>    return prev + cur;</code><code>}，0)</code><code>console.log(arr, sum); // [] 0</code></pre> 
<p>复制代码</p> 
<p></p> 
<p>js 中 in，一般用来遍历对象, 也可以用来遍历数组</p> 
<p></p> 
<p>in 作用，判断属性是否存在于对象中，在 true，不在 false。</p> 
<p></p> 
<p>in 作用，判断数组，索引号就是属性。</p> 
<p></p> 
<p></p> 
<p class="img-center"><img alt="" height="259" src="https://images2.imgbox.com/d6/e9/0FkNGsJ5_o.png" width="274"></p> 
<p></p> 
<p>对于数组循环出来的是数组元素；对于对象循环出来的是对象属性；当‘对象’是数组时：“变量”指的是数组的“索引”；当‘对象’为对象是，“变量”指的是对象的“属性”。</p> 
<p></p> 
<p>计算数组中每个元素出现的次数</p> 
<p></p> 
<p></p> 
<p class="img-center"><img alt="" height="389" src="https://images2.imgbox.com/73/33/4ZzTi6jk_o.png" width="435"></p> 
<p></p> 
<pre><code>// 求总成绩</code><code>var scoreReport = [</code><code> {<!-- --></code><code>   name: 'dada',</code><code>   score: 100</code><code> },</code><code> {<!-- --></code><code>     name: '魔王哪吒',</code><code>     score: 99</code><code> }</code><code>]</code>
<code>// for</code><code>var sum = 0</code><code>for(var i = 0; i&lt;scoreReport.length; i++) {<!-- --></code><code>    sum += scoreReport[i].score</code><code>}</code></pre> 
<p>复制代码</p> 
<p></p> 
<p>如果使用 reduce</p> 
<p></p> 
<pre><code>var sum = scoreReport.reduce(function(prev, cur) {<!-- --></code><code>    return cur.score + prev</code><code>},0);</code></pre> 
<p>复制代码</p> 
<h4>Vuex</h4> 
<p></p> 
<p>Vuex 中规则只能在 mutations 里修改 state 中的数据，actions 不能直接修改 state</p> 
<p></p> 
<p>创建 Vuex.Store 实例保存到变量 store 中，使用 export default 导出 store</p> 
<p></p> 
<pre><code>import Vuex from 'vue'</code><code>import Vuex from 'vuex'</code><code>Vue.use(Vuex)</code><code>const store = new Vuex.Store({<!-- --></code><code>    </code><code>})</code><code>export default store</code></pre> 
<p>复制代码</p> 
<p></p> 
<blockquote> 
 <p>state</p> 
</blockquote> 
<p></p> 
<p>常常写的文件 store.js</p> 
<p></p> 
<pre><code>import Vue from 'vue'</code><code>import Vuex from 'vuex'</code><code>// import * as getters from './getters'</code><code>Vue.use(Vuex)</code><code>const state = {<!-- --></code><code>    // 放置初始状态</code><code>    a: 123</code><code>};</code>
<code>const mutations = {<!-- --></code><code>    // 放置我们的状态变更函数</code><code>};</code>
<code>export default new Vuex.Store({<!-- --></code><code>    state,</code><code>    mutations,</code><code>    // getters</code><code>})</code></pre> 
<p>复制代码</p> 
<p></p> 
<p><code>this.$store.state</code>来获取定义的数据</p> 
<p></p> 
<pre><code>import Vuex from 'vue'</code><code>import Vuex from 'vuex'</code><code>Vue.use(Vuex)</code><code>const store = new Vuex.Store({<!-- --></code><code>    state: {<!-- --></code><code>        count: 1</code><code>    }</code><code>})</code><code>export default store</code></pre> 
<p>复制代码</p> 
<p></p> 
<pre><code>import Vuex from 'vue'</code><code>import Vuex from 'vuex'</code><code>Vue.use(Vuex)</code><code>const store = new Vuex.Store({<!-- --></code><code>    state: {<!-- --></code><code>        count: 1</code><code>    },</code><code>    getters: {<!-- --></code><code>        // getters相当与vue中的computed计算属性</code><code>        getStateCount: function(state){<!-- --></code><code>            return state.count+1;</code><code>        }</code><code>    }</code><code>})</code><code>export default store</code></pre> 
<p>复制代码</p> 
<p></p> 
<p>要修改 state 中的值，需要提交 mutation 来修改</p> 
<p></p> 
<p>Vuex 中的 getter，就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，并且只有当它的依赖值发生了改变才会被重新计算。</p> 
<p></p> 
<p>Getter 接受 state 作为其第一个参数：</p> 
<p></p> 
<pre><code>const store = new Vuex.Store({<!-- --></code><code>  state: {<!-- --></code><code>    todos: [</code><code>      { id: 1, text: '...', done: true },</code><code>      { id: 2, text: '...', done: false }</code><code>    ]</code><code>  },</code><code>  getters: {<!-- --></code><code>    doneTodos: state =&gt; {<!-- --></code><code>      return state.todos.filter(todo =&gt; todo.done)</code><code>    }</code><code>  }</code><code>})</code></pre> 
<p>复制代码</p> 
<p></p> 
<blockquote> 
 <p>getter 在通过属性访问时，是作为 Vue 的响应式系统的一部分缓存其中的</p> 
 <p>getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。</p> 
</blockquote> 
<p></p> 
<pre><code>某函数中{<!-- --></code><code>    this.$store.commit('add');</code><code>}</code>
<code>import Vuex from 'vue'</code><code>import Vuex from 'vuex'</code><code>Vue.use(Vuex)</code><code>const store = new Vuex.Store({<!-- --></code><code>    state: {<!-- --></code><code>        count: 1</code><code>    },</code><code>    getters: {<!-- --></code><code>        // getters相当与vue中的computed计算属性</code><code>        getStateCount: function(state){<!-- --></code><code>            return state.count+1;</code><code>        }</code><code>    },</code><code>    mutations: {<!-- --></code><code>        add(state) {<!-- --></code><code>            state.count += 1;</code><code>        },</code><code>    }</code><code>})</code><code>export default store</code>
<code>// xxx.vue</code><code>{<!-- -->{$store.getters.getStateCount}}</code></pre> 
<p>复制代码</p> 
<p></p> 
<p>提交 mutation-对象风格的提交方式，直接使用包含 type 属性的对象：</p> 
<p></p> 
<pre><code>store.commit({<!-- --></code><code>  type: 'increment',</code><code>  amount: 10</code><code>})</code></pre> 
<p>复制代码</p> 
<p></p> 
<p>Vuex 中还有一个 Actions，这个目的是不想上面那样直接修改 store 里面的值，而是通过去提交一个 actions，然后再在 actions 中提交 mutations 中去修改状态值。</p> 
<p></p> 
<blockquote> 
 <p>先定义 actions 提交 mutations 的函数</p> 
</blockquote> 
<p></p> 
<p>示例：</p> 
<p></p> 
<pre><code>某函数中{<!-- --></code><code>    this.$store.dispatch('addFun')</code><code>}</code>
<code>import Vuex from 'vue'</code><code>import Vuex from 'vuex'</code><code>Vue.use(Vuex)</code><code>const store = new Vuex.Store({<!-- --></code><code>    state: {<!-- --></code><code>        count: 1</code><code>    },</code><code>    getters: {<!-- --></code><code>        // getters相当与vue中的computed计算属性</code><code>        getStateCount: function(state){<!-- --></code><code>            return state.count+1;</code><code>        }</code><code>    },</code><code>    mutations: {<!-- --></code><code>        add(state) {<!-- --></code><code>            state.count += 1;</code><code>        },</code><code>    },</code><code>    actions: {<!-- --></code><code>    // 注册actions，相当于vue中的methods</code><code>        addFun(context){<!-- --></code><code>            // context接收一个与store实例具有相同方法的属性的context对象</code><code>            context.commit('add')</code><code>        },</code><code>    }</code><code>})</code><code>export default store</code></pre> 
<p>复制代码</p> 
<p></p> 
<blockquote> 
 <p>使用 mapState，mapGetters，mapActions，代替<code>this.$store.state.count和this.$store.dispatch('addFun')</code>这种写法。</p> 
</blockquote> 
<p></p> 
<p>如何使用：</p> 
<p></p> 
<pre><code>import {mapState, mapGetters, mapActions} from 'vuex';</code>
<code>// 使用computed 状态变化</code>
<code>computed: {<!-- --></code><code>    ...mapState({<!-- --></code><code>        countdada: state=&gt;state.count</code><code>    })</code><code>}</code>
<code>// 将 store 中的 getter 映射到局部计算属性：</code><code>import { mapGetters } from 'vuex'</code>
<code>export default {<!-- --></code><code>  // ...</code><code>  computed: {<!-- --></code><code>  // 使用对象展开运算符将 getter 混入 computed 对象中</code><code>    ...mapGetters([</code><code>      'doneTodosCount',</code><code>      'anotherGetter',</code><code>      // ...</code><code>    ])</code><code>  }</code><code>}</code>
<code>...mapGetters({<!-- --></code><code>  // 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`</code><code>  doneCount: 'doneTodosCount'</code><code>})</code></pre> 
<p>复制代码</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f0ed5bd9b3aa3313281c842b0d7285ad/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python GUI开发: tkinter菜单创建，记事本和画图软件综合项目的实战演练</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/47b088de00723d596ec05c594a7c91f6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python酷库之旅-比翼双飞情侣库(15)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>