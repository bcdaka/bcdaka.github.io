<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据集划分】oracle数据集划分（总结版） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/38e129fa372812c94d2cde7f9998c74a/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据集划分】oracle数据集划分（总结版）">
  <meta property="og:description" content="【数据集划分】假如你有接近百万条oracle数据库数据（成真版） 写在最前面最终代码原理：生成随机索引并打乱顺序示例作用应用场景 遇到报错：ORA-01795，通过CTE（Common Table Expressions）和窗口函数解决 🌈你好呀！我是 是Yu欸 🌌 2024每日百字篆刻时光，感谢你的陪伴与支持 ~ 🚀 欢迎一起踏上探险之旅，挖掘无限可能，共同成长！ 写在最前面 前文：【数据集划分】假如你有超百万条oracle数据库数据（成真版）
大模型，何所谓大？先从大数据开始。
假如你有超百万条oracle数据库数据，那么一直使用的代码：train_df, temp_df = train_test_split(df, test_size=0.3, random_state=42)，很可能1h还没划分完数据。
最终解决方案：生成一列随机数，然后随机打乱。取前70%的样本划分为训练集，70%到90%之间的样本划分为测试集，剩余的样本划分为验证集。
最终代码 连接Oracle数据库：使用jaydebeapi连接Oracle数据库，确保提供正确的JDBC驱动路径和数据库连接信息。添加新列：在deal_ct_report表中添加一个新列dataset来保存数据集标签。如果列已经存在，会捕捉到异常并继续执行后续操作。获取总行数：查询表的总行数，用于生成随机索引。生成随机索引并打乱顺序：生成从1到总行数的索引列表，并打乱顺序。计算各数据集的分界点：计算训练集、测试集和验证集的分界点。创建临时表：将原表的rowid和ROWNUM保存到临时表中。更新数据集标签列：使用CTE和窗口函数一次性更新所有记录，避免分批次更新的效率问题。 使用dbms_random.value生成随机数进行排序。使用ROW_NUMBER()窗口函数为每条记录分配一个随机序号。根据随机序号进行数据集划分并更新dataset列。 删除临时表：删除临时表以清理临时数据。提交事务：将所有更改提交到数据库。关闭连接：关闭数据库连接。 通过将参数直接插入到SQL语句中，避免了参数传递中的问题。这种方法可以高效地实现数据集的随机划分和更新操作。
import jaydebeapi import random # 连接Oracle数据库 conn = jaydebeapi.connect( &#39;oracle.jdbc.driver.OracleDriver&#39;, &#39;jdbc:oracle:thin:@hostname:port:service_name&#39;, [&#39;username&#39;, &#39;password&#39;], &#39;path/to/ojdbc8.jar&#39; ) cursor = conn.cursor() # 添加新列dataset try: cursor.execute(&#34;ALTER TABLE deal_ct_report ADD dataset VARCHAR2(10)&#34;) except jaydebeapi.DatabaseError as e: print(&#34;Column &#39;dataset&#39; may already exist. Proceeding with data split...&#34;) # 获取表的行数 cursor.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-06T18:07:31+08:00">
    <meta property="article:modified_time" content="2024-06-06T18:07:31+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据集划分】oracle数据集划分（总结版）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>【数据集划分】假如你有接近百万条oracle数据库数据（成真版）</h4> 
 <ul><li><a href="#_14" rel="nofollow">写在最前面</a></li><li><a href="#_26" rel="nofollow">最终代码</a></li><li><a href="#_115" rel="nofollow">原理：生成随机索引并打乱顺序</a></li><li><ul><li><a href="#_125" rel="nofollow">示例</a></li><li><a href="#_147" rel="nofollow">作用</a></li><li><a href="#_153" rel="nofollow">应用场景</a></li></ul> 
  </li><li><a href="#ORA01795CTECommon_Table_Expressions_159" rel="nofollow">遇到报错：ORA-01795，通过CTE（Common Table Expressions）和窗口函数解决</a></li></ul> 
</div> 
<p></p> 
<hr> 
<p><img src="https://images2.imgbox.com/9c/53/KO1KS3lH_o.png" alt="请添加图片描述" width="100" height="100"></p> 
<center> 
 <font color="#FF77A9" face="STKaiti" size="4">🌈你好呀！我是 <a href="https://blog.csdn.net/WTYuong?spm=1010.2135.3001.5343">是Yu欸 </a></font> 
</center> 
<center> 
 <font color="#007FFF" face="KaiTi">🌌 2024每日百字篆刻时光，感谢你的陪伴与支持 ~</font> 
</center> 
<center> 
 <font color="#007FFF" face="KaiTi">🚀 欢迎一起踏上探险之旅，挖掘无限可能，共同成长！</font> 
</center> 
<hr> 
<h2><a id="_14"></a>写在最前面</h2> 
<p>前文：【数据集划分】假如你有超百万条oracle数据库数据（成真版）<br> 大模型，何所谓大？先从大数据开始。</p> 
<p>假如你有超百万条oracle数据库数据，那么一直使用的代码：<code>train_df, temp_df = train_test_split(df, test_size=0.3, random_state=42)</code>，很可能1h还没划分完数据。</p> 
<p>最终解决方案：生成一列随机数，然后随机打乱。取前70%的样本划分为训练集，70%到90%之间的样本划分为测试集，剩余的样本划分为验证集。</p> 
<p><img src="https://images2.imgbox.com/7b/c4/sw4Xg8b3_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_26"></a>最终代码</h2> 
<ol><li><strong>连接Oracle数据库</strong>：使用<code>jaydebeapi</code>连接Oracle数据库，确保提供正确的JDBC驱动路径和数据库连接信息。</li><li><strong>添加新列</strong>：在<code>deal_ct_report</code>表中添加一个新列<code>dataset</code>来保存数据集标签。如果列已经存在，会捕捉到异常并继续执行后续操作。</li><li><strong>获取总行数</strong>：查询表的总行数，用于生成随机索引。</li><li><strong>生成随机索引并打乱顺序</strong>：生成从1到总行数的索引列表，并打乱顺序。</li><li><strong>计算各数据集的分界点</strong>：计算训练集、测试集和验证集的分界点。</li><li><strong>创建临时表</strong>：将原表的<code>rowid</code>和<code>ROWNUM</code>保存到临时表中。</li><li><strong>更新数据集标签列</strong>：使用CTE和窗口函数一次性更新所有记录，避免分批次更新的效率问题。 
  <ul><li>使用<code>dbms_random.value</code>生成随机数进行排序。</li><li>使用<code>ROW_NUMBER()</code>窗口函数为每条记录分配一个随机序号。</li><li>根据随机序号进行数据集划分并更新<code>dataset</code>列。</li></ul> </li><li><strong>删除临时表</strong>：删除临时表以清理临时数据。</li><li><strong>提交事务</strong>：将所有更改提交到数据库。</li><li><strong>关闭连接</strong>：关闭数据库连接。</li></ol> 
<p>通过将参数直接插入到SQL语句中，避免了参数传递中的问题。这种方法可以高效地实现数据集的随机划分和更新操作。</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> jaydebeapi
<span class="token keyword">import</span> random

<span class="token comment"># 连接Oracle数据库</span>
conn <span class="token operator">=</span> jaydebeapi<span class="token punctuation">.</span>connect<span class="token punctuation">(</span>
    <span class="token string">'oracle.jdbc.driver.OracleDriver'</span><span class="token punctuation">,</span>
    <span class="token string">'jdbc:oracle:thin:@hostname:port:service_name'</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span><span class="token string">'username'</span><span class="token punctuation">,</span> <span class="token string">'password'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token string">'path/to/ojdbc8.jar'</span>
<span class="token punctuation">)</span>
cursor <span class="token operator">=</span> conn<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 添加新列dataset</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
    cursor<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"ALTER TABLE deal_ct_report ADD dataset VARCHAR2(10)"</span><span class="token punctuation">)</span>
<span class="token keyword">except</span> jaydebeapi<span class="token punctuation">.</span>DatabaseError <span class="token keyword">as</span> e<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Column 'dataset' may already exist. Proceeding with data split..."</span><span class="token punctuation">)</span>

<span class="token comment"># 获取表的行数</span>
cursor<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"SELECT COUNT(*) FROM deal_ct_report"</span><span class="token punctuation">)</span>
total_rows <span class="token operator">=</span> cursor<span class="token punctuation">.</span>fetchone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>

<span class="token comment"># 生成随机索引并打乱顺序</span>
indices <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> total_rows <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
random<span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span>indices<span class="token punctuation">)</span>

<span class="token comment"># 计算各数据集的分界点</span>
train_limit <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token number">0.7</span> <span class="token operator">*</span> total_rows<span class="token punctuation">)</span>
test_limit <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token number">0.9</span> <span class="token operator">*</span> total_rows<span class="token punctuation">)</span>

<span class="token comment"># 创建一个临时表来存储带有索引的数据</span>
cursor<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"CREATE TABLE deal_ct_report_temp AS SELECT rowid AS rid, ROWNUM AS rnum FROM deal_ct_report"</span><span class="token punctuation">)</span>

<span class="token comment"># 更新数据集标签列</span>
update_sql <span class="token operator">=</span> <span class="token string-interpolation"><span class="token string">f"""
    MERGE INTO deal_ct_report d
    USING (
        WITH temp_data AS (
            SELECT rid, rnum,
                   CASE
                       WHEN rnum &lt;= </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>train_limit<span class="token punctuation">}</span></span><span class="token string"> THEN 'train'
                       WHEN rnum &lt;= </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>test_limit<span class="token punctuation">}</span></span><span class="token string"> THEN 'test'
                       ELSE 'validate'
                   END AS dataset
            FROM (
                SELECT rid, ROW_NUMBER() OVER (ORDER BY dbms_random.value) AS rnum
                FROM deal_ct_report_temp
            )
        )
        SELECT rid, dataset
        FROM temp_data
    ) t
    ON (d.rowid = t.rid)
    WHEN MATCHED THEN
    UPDATE SET d.dataset = t.dataset
"""</span></span>

cursor<span class="token punctuation">.</span>execute<span class="token punctuation">(</span>update_sql<span class="token punctuation">)</span>

<span class="token comment"># 删除临时表</span>
cursor<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"DROP TABLE deal_ct_report_temp"</span><span class="token punctuation">)</span>

<span class="token comment"># 提交事务</span>
conn<span class="token punctuation">.</span>commit<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 关闭数据库连接</span>
cursor<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
conn<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<h2><a id="_115"></a>原理：生成随机索引并打乱顺序</h2> 
<p>生成随机索引并打乱顺序的原理是将数据集进行随机化处理，以确保数据集的随机划分，使训练集、测试集和验证集的样本分布尽可能地均匀和独立。这种方法有助于消除因数据顺序带来的偏差，从而使模型训练和评估更加准确。</p> 
<p>具体步骤如下：</p> 
<ol><li><strong>生成索引列表</strong>：创建一个从1到总行数的索引列表，这些索引表示数据集中每一条记录的序号。</li><li><strong>打乱索引顺序</strong>：使用<code>random.shuffle</code>函数将索引列表随机打乱。这样可以确保索引的顺序是随机的，而不是按原始顺序排列。</li></ol> 
<h3><a id="_125"></a>示例</h3> 
<p>假设数据集中有10条记录，生成的索引列表为：[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]。打乱后可能变为：[3, 8, 1, 6, 7, 2, 5, 9, 4, 10]。</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> random

<span class="token comment"># 获取表的行数</span>
total_rows <span class="token operator">=</span> <span class="token number">10</span>  <span class="token comment"># 这里假设总行数为10</span>

<span class="token comment"># 生成索引列表</span>
indices <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> total_rows <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment"># 打乱索引顺序</span>
random<span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span>indices<span class="token punctuation">)</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>indices<span class="token punctuation">)</span>
</code></pre> 
<p>打乱后的索引列表是随机的。例如，输出可能是：[7, 2, 9, 1, 5, 3, 10, 6, 4, 8]。</p> 
<h3><a id="_147"></a>作用</h3> 
<ol><li><strong>随机化数据顺序</strong>：确保数据集的样本顺序是随机的，这样可以防止某些样本因顺序而集中在同一个子集。</li><li><strong>均匀分布</strong>：在随后的数据集划分中（如7:2:1），可以保证训练集、测试集和验证集中的样本更加均匀和独立。</li><li><strong>减少偏差</strong>：通过随机化处理，可以减少因数据顺序带来的潜在偏差，从而提高模型的泛化能力。</li></ol> 
<h3><a id="_153"></a>应用场景</h3> 
<p>这种方法特别适用于需要将大数据集随机划分为多个子集的场景，如机器学习中的数据集划分（训练集、测试集、验证集）。在这种情况下，确保每个子集的样本分布尽可能均匀和独立是至关重要的。</p> 
<p>通过这种方式，可以在后续的模型训练和评估过程中，尽量避免因数据顺序或分布不均而导致的模型偏差，从而提高模型的性能和可靠性。</p> 
<h2><a id="ORA01795CTECommon_Table_Expressions_159"></a>遇到报错：ORA-01795，通过CTE（Common Table Expressions）和窗口函数解决</h2> 
<p>DatabaseError: java.sql.SQLException: ORA-01795: maximum number of expressions in a list is 1000</p> 
<p>ORA-01795错误表示Oracle数据库限制了在IN子句中最多只能包含1000个表达式。</p> 
<p>为了克服这一限制，我们可以：</p> 
<ol><li>（还是很慢，pass）将大的更新分成多个批次，每个批次最多包含1000个表达式。</li><li>可以使用CTE（Common Table Expressions）和窗口函数来一次性更新所有记录，而不是分批次更新。</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e086a8b241feba4da3bbb8278ce6e8ad/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Flink协调器Coordinator及自定义Operator</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/da3d54ecb19aee2849e307911b4f3f2f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C语言：详解gcc驱动程序完成编译、汇编、链接的过程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>