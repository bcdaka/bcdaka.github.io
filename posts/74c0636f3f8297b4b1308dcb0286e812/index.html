<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Hive详解（一篇文章让你彻底学会Hive） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/74c0636f3f8297b4b1308dcb0286e812/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Hive详解（一篇文章让你彻底学会Hive）">
  <meta property="og:description" content="简介 概述 Hive是由Facebook(脸书)开发的后来贡献给了Apache的一套数据仓库管理工具，针对海量的结构化数据提供了读、写和管理的功能。
图-1 Hive图标
Hive本身是基于Hadoop，提供了类SQL(Hive Query Language，简称为HQL)语言来操作HDFS上的数据，而底层实际上是将用户书写的SQL转化为了MapReduce程序来执行，因此效率相对较低，更适合于离线批处理的场景。
之所以Facebook开发了Hive这个项目，是因为Facebook在使用Hadoop过程中发现了一些问题：
1)Hadoop只提供了MapReduce这一种用于数据处理方案，但是当需要大量的数据进行处理的时候，就需要编写大量的MapReduce，这种方式效率较低，逻辑复杂度较高，难度较大。
2)早期的时候，Hadoop只支持Java语言(即使现在，Hadoop也只支持C/C&#43;&#43;，Java，Python，Scala这几门语言)，那么就导致其他开发者如果想要使用Hadoop，尤其是MapReduce，那么需要学习Java语言，极大地增加了学习和使用成本。
所以在这种背景下，Facebook就想对Hive尤其是MapReduce模块进行封装，且封装好之后使用的结构最好与语言无关(即不绑定某一门编程语言的语法)，所以最后选定了SQL作为封装结构，由此，Hive也就诞生了。
Hive VS 数据库 Hive和数据库的比较如下：
1) 查询语言：由于SQL的易学特性，因此被广泛的应用在数据仓库中。Hive专门设计了类SQL的查询语言HQL，使得熟悉SQL开发的开发者可以很方便的使用Hive进行开发。
2)数据存储位置：Hive是建立在Hadoop之上的，因此Hive中的数据是存储在HDFS上的。而数据库则可以将数据保存在块设备或者本地文件系统中。
3)数据更新：Hive一般是针对历史数据进行处理，因此数据一般是不可修改的。而数据库中的数据通常是需要经常进行修改的。
4)索引：Hive在加载数据的过程中不会对数据进行任何处理，甚至不会对数据进行扫描，因此不会主动针对数据建立索引。Hive要访问数据中满足条件的特定值时，需要暴力扫描整个数据，因此访问延迟较高。由于MapReduce的引入，Hive可以并行访问数据，因此即使没有索引，对于大数据量的访问，Hive仍然可以体现出优势。而在数据库中，通常会针对一个或者几个列建立索引，因此对于少量的特定条件的数据的访问，数据库可以有很高的效率，较低的延迟。
5)执行引擎：默认情况下，Hive通过Hadoop提供的MapReduce来实现数据处理的，当然，Hive支持将执行引擎替换为Tez或者是Spark。而数据库通常有自己的执行引擎，例如MySQL的执行引擎为innodb。
6)执行延迟：Hive在查询数据的时候，由于没有索引，需要扫描整个表，因此延迟较高。另外一个导致Hive执行延迟高的因素是MapReduce框架。由于MapReduce本身就具有较高的延迟，因此在利用MapReduce执行Hive查询时，也会有较高的延迟。相对的，数据库的执行延迟较低。当然，这个低是有条件的，即数据规模较小，当数据规模大到超过数据库的处理能力的时候，Hive的并行计算显然能体现出优势。
7)可扩展性：由于Hive是建立在Hadoop之上的，因此Hive的可扩展性是和Hadoop的可扩展性是一致的(现在很多公司的Hadoop集群的规模超过了10000个节点)。而数据库由于ACID语义的严格限制，扩展行非常有限。目前最先进的并行数据库Oracle在理论上的扩展能力也只有100台左右。
8)数据规模:由于Hive建立在集群上并可以利用MapReduce进行并行计算，因此可以支持很大规模的数据，实际开发过程中一般是GB起步，可以达到PB级别及以上；相应的，数据库由于规模较小，因此可以支持的数据规模较小，一般单张表中能存储百万条数据(最新版的MySQL经过优化，单表中可以存储千万条或者上亿条数据，即使是一亿条数据，也就10GB大小，且此时效率会非常低)。
特点 优点 1)操作接口采用类SQL语法，用户只要熟悉SQL语法即可快速转化(简单、学习成本低、容易上手)；
2)避免书写MapReduce，减少开发人员的学习成本以及维护成本；
3)对于大量数据，Hive能够进行分布式处理，从而节省了数据的处理时间；
4)Hive支持用户自定义函数，用户可以根据自己的需求来实现自己的函数，从而提高了灵活性，能够更好的应对复杂业务。
缺点 1)基于HQL的方式导致表达能力有限：首先Hive中迭代式算法无法表达；其次Hive不擅长数据挖掘，由于MapReduce数据处理流程的限制，效率更高的算法却无法实现。
2)Hive的效率比较低：首先Hive的执行延迟比较高，因此Hive常用离线分析，适用于对实时性要求不高的场合；其次HQL自动编译生成MapReduce作业，通常情况下不够智能化；然后，由于MapReduce本身的特点，导致Hive对小文件的处理不占优势。
3)Hive调优比较困难，粒度较粗。
4)Hive对于数据更新操作支持性不好：一般用Hive处理的是离线的历史数据，因此默认情况下Hive是不支持对数据进行修改的。而如果需要对数据进行修改(update、delete)，那么需要改变Hive中数据文件的存储格式，且此时效率非常非常低。
编译和安装 编译 源码编译 步骤如下：
1) 上传或者下载Hive的源码包：
# 进入预安装目录
cd /opt/software/
# 下载Hive的源码包，官方下载地址：
wget https://dlcdn.apache.org/hive/hive-3.1.3/apache-hive-3.1.3-src.tar.gz
2)解压：
tar -xvf apache-hive-3.1.3-src.tar.gz -C /opt/source/
3) 进入Hive的源码包：
cd /opt/source/apache-hive-3.1.3-src/
4) 执行编译过程：
mvn -X package -Pdist,nativeN,docs -DskipTests -Dtar -Dmaven.skip.test=true -Dmaven.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-26T14:37:37+08:00">
    <meta property="article:modified_time" content="2024-03-26T14:37:37+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Hive详解（一篇文章让你彻底学会Hive）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="text-align:justify;"><strong><strong><strong>简介</strong></strong></strong></h2> 
<h4 style="text-align:justify;"><strong><strong><strong>概述</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;">Hive是由Facebook(脸书)开发的后来贡献给了Apache的一套数据仓库管理工具，针对海量的结构化数据提供了读、写和管理的功能。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ca/11/uwoYZYTQ_o.png"></p> 
<p style="text-align:center;">图-1 Hive图标</p> 
<p style="margin-left:.0001pt;text-align:justify;">Hive本身是基于Hadoop，提供了类SQL(Hive Query Language，简称为HQL)语言来操作HDFS上的数据，而底层实际上是将用户书写的SQL转化为了MapReduce程序来执行，因此效率相对较低，更适合于离线批处理的场景。</p> 
<p style="margin-left:.0001pt;text-align:justify;">之所以Facebook开发了Hive这个项目，是因为Facebook在使用Hadoop过程中发现了一些问题：</p> 
<p style="margin-left:.0001pt;text-align:justify;">1)Hadoop只提供了MapReduce这一种用于数据处理方案，但是当需要大量的数据进行处理的时候，就需要编写大量的MapReduce，这种方式效率较低，逻辑复杂度较高，难度较大。</p> 
<p style="margin-left:.0001pt;text-align:justify;">2)早期的时候，Hadoop只支持Java语言(即使现在，Hadoop也只支持C/C++，Java，Python，Scala这几门语言)，那么就导致其他开发者如果想要使用Hadoop，尤其是MapReduce，那么需要学习Java语言，极大地增加了学习和使用成本。</p> 
<p style="margin-left:.0001pt;text-align:justify;">所以在这种背景下，Facebook就想对Hive尤其是MapReduce模块进行封装，且封装好之后使用的结构最好与语言无关(即不绑定某一门编程语言的语法)，所以最后选定了SQL作为封装结构，由此，Hive也就诞生了。</p> 
<h3 style="text-align:justify;"><strong><strong><strong>H</strong></strong><strong><strong>ive VS </strong></strong><strong><strong>数据库</strong></strong></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify;">Hive和数据库的比较如下：</p> 
<p style="margin-left:.0001pt;text-align:justify;">1) 查询语言：由于SQL的易学特性，因此被广泛的应用在数据仓库中。Hive专门设计了类SQL的查询语言HQL，使得熟悉SQL开发的开发者可以很方便的使用Hive进行开发。</p> 
<p style="margin-left:.0001pt;text-align:justify;">2)数据存储位置：Hive是建立在Hadoop之上的，因此Hive中的数据是存储在HDFS上的。而数据库则可以将数据保存在块设备或者本地文件系统中。</p> 
<p style="margin-left:.0001pt;text-align:justify;">3)数据更新：Hive一般是针对历史数据进行处理，因此数据一般是不可修改的。而数据库中的数据通常是需要经常进行修改的。</p> 
<p style="margin-left:.0001pt;text-align:justify;">4)索引：Hive在加载数据的过程中不会对数据进行任何处理，甚至不会对数据进行扫描，因此不会主动针对数据建立索引。Hive要访问数据中满足条件的特定值时，需要暴力扫描整个数据，因此访问延迟较高。由于MapReduce的引入，Hive可以并行访问数据，因此即使没有索引，对于大数据量的访问，Hive仍然可以体现出优势。而在数据库中，通常会针对一个或者几个列建立索引，因此对于少量的特定条件的数据的访问，数据库可以有很高的效率，较低的延迟。</p> 
<p style="margin-left:.0001pt;text-align:justify;">5)执行引擎：默认情况下，Hive通过Hadoop提供的MapReduce来实现数据处理的，当然，Hive支持将执行引擎替换为Tez或者是Spark。而数据库通常有自己的执行引擎，例如MySQL的执行引擎为innodb。</p> 
<p style="margin-left:.0001pt;text-align:justify;">6)执行延迟：Hive在查询数据的时候，由于没有索引，需要扫描整个表，因此延迟较高。另外一个导致Hive执行延迟高的因素是MapReduce框架。由于MapReduce本身就具有较高的延迟，因此在利用MapReduce执行Hive查询时，也会有较高的延迟。相对的，数据库的执行延迟较低。当然，这个低是有条件的，即数据规模较小，当数据规模大到超过数据库的处理能力的时候，Hive的并行计算显然能体现出优势。</p> 
<p style="margin-left:.0001pt;text-align:justify;">7)可扩展性：由于Hive是建立在Hadoop之上的，因此Hive的可扩展性是和Hadoop的可扩展性是一致的(现在很多公司的Hadoop集群的规模超过了10000个节点)。而数据库由于ACID语义的严格限制，扩展行非常有限。目前最先进的并行数据库Oracle在理论上的扩展能力也只有100台左右。</p> 
<p style="margin-left:.0001pt;text-align:justify;">8)数据规模:由于Hive建立在集群上并可以利用MapReduce进行并行计算，因此可以支持很大规模的数据，实际开发过程中一般是GB起步，可以达到PB级别及以上；相应的，数据库由于规模较小，因此可以支持的数据规模较小，一般单张表中能存储百万条数据(最新版的MySQL经过优化，单表中可以存储千万条或者上亿条数据，即使是一亿条数据，也就10GB大小，且此时效率会非常低)。</p> 
<h3 style="text-align:justify;"><strong><strong><strong>特点</strong></strong></strong></h3> 
<h4 style="text-align:justify;"><strong><strong><strong>优点</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">1)操作接口采用类SQL语法，用户只要熟悉SQL语法即可快速转化(简单、学习成本低、容易上手)；</p> 
<p style="margin-left:.0001pt;text-align:justify;">2)避免书写MapReduce，减少开发人员的学习成本以及维护成本；</p> 
<p style="margin-left:.0001pt;text-align:justify;">3)对于大量数据，Hive能够进行分布式处理，从而节省了数据的处理时间；</p> 
<p style="margin-left:.0001pt;text-align:justify;">4)Hive支持用户自定义函数，用户可以根据自己的需求来实现自己的函数，从而提高了灵活性，能够更好的应对复杂业务。</p> 
<h4 style="text-align:justify;"><strong><strong><strong>缺点</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">1)基于HQL的方式导致表达能力有限：首先Hive中迭代式算法无法表达；其次Hive不擅长数据挖掘，由于MapReduce数据处理流程的限制，效率更高的算法却无法实现。</p> 
<p style="margin-left:.0001pt;text-align:justify;">2)Hive的效率比较低：首先Hive的执行延迟比较高，因此Hive常用离线分析，适用于对实时性要求不高的场合；其次HQL自动编译生成MapReduce作业，通常情况下不够智能化；然后，由于MapReduce本身的特点，导致Hive对小文件的处理不占优势。</p> 
<p style="margin-left:.0001pt;text-align:justify;">3)Hive调优比较困难，粒度较粗。</p> 
<p style="margin-left:.0001pt;text-align:justify;">4)Hive对于数据更新操作支持性不好：一般用Hive处理的是离线的历史数据，因此默认情况下Hive是不支持对数据进行修改的。而如果需要对数据进行修改(update、delete)，那么需要改变Hive中数据文件的存储格式，且此时效率非常非常低。</p> 
<h2 style="text-align:justify;"><strong><strong><strong>编译和安装</strong></strong></strong></h2> 
<h3 style="text-align:justify;"><strong><strong><strong>编译</strong></strong></strong></h3> 
<h4 style="text-align:justify;"><strong><strong><strong>源码编译</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">步骤如下：</p> 
<p style="margin-left:.0001pt;text-align:justify;">1) 上传或者下载Hive的源码包：</p> 
<p># 进入预安装目录</p> 
<p>cd /opt/software/</p> 
<p># 下载Hive的源码包，官方下载地址：</p> 
<p>wget https://dlcdn.apache.org/hive/hive-3.1.3/apache-hive-3.1.3-src.tar.gz</p> 
<p style="margin-left:.0001pt;text-align:justify;">2)解压：</p> 
<p>tar -xvf apache-hive-3.1.3-src.tar.gz -C /opt/source/</p> 
<p style="margin-left:.0001pt;text-align:justify;">3) 进入Hive的源码包：</p> 
<p>cd /opt/source/apache-hive-3.1.3-src/</p> 
<p style="margin-left:.0001pt;text-align:justify;">4) 执行编译过程：</p> 
<p>mvn -X package -Pdist,nativeN,docs -DskipTests -Dtar -Dmaven.skip.test=true -Dmaven.javadoc.skip=true -Denforcer.skip=true</p> 
<p style="margin-left:.0001pt;text-align:justify;">如果出现Could not find artifact org.pentaho:pentaho-aggdesigner-algorithm，则上传或者下载对应的jar包之后执行命令：</p> 
<p>mvn install:install-file \</p> 
<p>-Dfile=pentaho-aggdesigner-algorithm-5.1.5-jhyde.jar \</p> 
<p>-DgroupId=org.pentaho \</p> 
<p>-DartifactId=pentaho-aggdesigner-algorithm \</p> 
<p>-Dversion=5.1.5-jhyde \</p> 
<p>-Dpackaging=jar</p> 
<p style="margin-left:.0001pt;text-align:justify;">然后重新编译即可。</p> 
<h4 style="text-align:justify;"><strong><strong><strong>g</strong></strong><strong><strong>uava</strong></strong><strong><strong>版本修改</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">Hive3.1.3默认使用的是guava19.0，而Hadoop3版本默认使用的是guava27.0-jre版本，因此会产生版本冲突问题，需要替换guava版本。</p> 
<p style="margin-left:.0001pt;text-align:justify;">1) 由于需要修改一部分Hive的源码，所以此处先安装Centos的桌面，然后利用idea来修改：</p> 
<p># 安装桌面</p> 
<p>yum groupinstall "GNOME Desktop"</p> 
<p># 启用桌面版</p> 
<p>init 5</p> 
<p style="margin-left:.0001pt;text-align:justify;">2) 上传或者下载idea的安装包，然后解压：</p> 
<p>tar -xvf ideaIC-2023.1.2.tar.gz -C /opt/software/</p> 
<p style="margin-left:.0001pt;text-align:justify;">3)启动idea：</p> 
<p>sh /opt/software/idea-IC-231.9011.34/bin/idea.sh</p> 
<p style="margin-left:.0001pt;text-align:justify;">4)导入Hive源码包，然后配置maven。</p> 
<p style="margin-left:.0001pt;text-align:justify;">5) 打开POM文件，修改guava的版本(第147行)：</p> 
<p>&lt;guava.version&gt;27.0-jre&lt;/guava.version&gt;</p> 
<p style="margin-left:.0001pt;text-align:justify;">6) 修改hive-service模块的pom文件：</p> 
<pre><code class="hljs">&lt;dependency&gt;

    &lt;groupId&gt;org.apache.directory.server&lt;/groupId&gt;

    &lt;artifactId&gt;apacheds-server-integ&lt;/artifactId&gt;

    &lt;version&gt;${apache-directory-server.version}&lt;/version&gt;

    &lt;scope&gt;test&lt;/scope&gt;

    &lt;!--添加如下内容--&gt;

    &lt;exclusions&gt;

        &lt;exclusion&gt;

            &lt;groupId&gt;org.apache.directory.client.ldap&lt;/groupId&gt;

            &lt;artifactId&gt;ldap-client-api&lt;/artifactId&gt;

        &lt;/exclusion&gt;

    &lt;/exclusions&gt;

&lt;/dependency&gt;</code></pre> 
<p style="margin-left:.0001pt;">7) 修改DruidScanQueryRecordReader.java类源码：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b4/bf/rqhNnFRP_o.png"></p> 
<p style="text-align:center;">图-2 DruidScanQueryRecordReader类</p> 
<p style="margin-left:.0001pt;text-align:justify;">8)修改MReporter类源码：</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/6e/e2/CQPW0XSi_o.png"></p> 
<p style="text-align:center;">图-3 AMReporter类</p> 
<p style="margin-left:.0001pt;text-align:justify;">9)修改LlapTaskReporter类源码：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/a2/5e/muNF1SAw_o.png"></p> 
<p style="text-align:center;">图-4 LlapTaskReporter类</p> 
<p style="margin-left:.0001pt;text-align:justify;">10)修改SampleTezSessionState类源码：</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/76/e9/vR7Lt38p_o.png"></p> 
<p style="text-align:center;">图-5 SampleTezSessionState类</p> 
<p style="margin-left:.0001pt;text-align:justify;">11) 修改TaskExecutorService类源码：</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/1e/af/7SSZkVZr_o.png"></p> 
<p style="text-align:center;">图-6 TaskExecutorService类</p> 
<p style="margin-left:.0001pt;text-align:justify;">12) 修改WorkloadManager类源码：</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/43/df/Wte6UjUA_o.png"></p> 
<p style="text-align:center;">图-7 WorkloadManager类</p> 
<p style="margin-left:.0001pt;text-align:justify;">13) 修改LlapTaskSchedulerService类源码：</p> 
<p style="margin-left:.0001pt;"><img alt="" src="https://images2.imgbox.com/a8/81/uSgeuZsf_o.png"></p> 
<p style="text-align:center;">图-8 LlapTaskSchedulerService类</p> 
<p style="margin-left:.0001pt;text-align:justify;">14) 修改AsyncPbRpcProxy类源码：</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/6f/ea/eip8oGRN_o.png"></p> 
<p style="text-align:center;">图-9 AsyncPbRpcProxy类</p> 
<p style="margin-left:.0001pt;text-align:justify;">15) 编译Hive：</p> 
<p>mvn -X package -Pdist,nativeN,docs -DskipTests -Dtar -Dmaven.skip.test=true -Dmaven.javadoc.skip=true -Denforcer.skip=true</p> 
<h4 style="text-align:justify;"><strong><strong><strong>集成S</strong></strong><strong><strong>park</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">1)Hive3默认支持的Spark版本为2.4而不是Spark3，所以如果需要使用Spark3作为Hive的执行引擎，那么需要修改Hive的pom文件(201行)：</p> 
<p>&lt;spark.version&gt;3.1.2&lt;/spark.version&gt;</p> 
<p>&lt;scala.binary.version&gt;2.12&lt;/scala.binary.version&gt;</p> 
<p>&lt;scala.version&gt;2.12.11&lt;/scala.version&gt;</p> 
<p style="margin-left:.0001pt;text-align:justify;">2)修改TestStatsUtils类的源码：</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/3a/87/mTkiVONc_o.png"></p> 
<p style="text-align:center;">图-10 TestStatsUtils类</p> 
<p style="margin-left:.0001pt;text-align:justify;">3) 修改ShuffleWriteMetrics类的源码：</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/ab/df/vCvT6bo2_o.png"></p> 
<p style="text-align:center;">图-11 ShuffleWriteMetrics类</p> 
<p style="margin-left:.0001pt;text-align:justify;">4) 修改SparkCounter类的源码：</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/c1/27/ij2zFEP3_o.png"></p> 
<p style="text-align:center;">图-12 SparkCounter类</p> 
<p style="margin-left:.0001pt;text-align:justify;">5) 重新编译Hive：</p> 
<p>mvn -X package -Pdist,nativeN,docs -DskipTests -Dtar -Dmaven.skip.test=true -Dmaven.javadoc.skip=true -Denforcer.skip=true</p> 
<p style="margin-left:.0001pt;text-align:justify;">6) 编译好的安装包在/opt/software/apache-hive-3.1.3-src/packaging/target/下。</p> 
<h3 style="text-align:justify;"><strong><strong><strong>安装</strong></strong></strong></h3> 
<h4 style="text-align:justify;"><strong><strong><strong>M</strong></strong><strong><strong>ySQL</strong></strong><strong><strong>安装</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">1)卸载CentOS7自带的MySQL：</p> 
<p>rpm -qa | grep -i mysql | xargs rpm -ev –nodeps</p> 
<p>rpm -qa | grep -i mariadb | xargs rpm -ev –nodeps</p> 
<p style="margin-left:.0001pt;text-align:justify;">2)删除MySQL可能残留的文件：</p> 
<p>find / -name mysql | xargs rm -rf</p> 
<p>find / -name my.cnf | xargs rm -rf</p> 
<p>cd /var/lib/</p> 
<p>rm -rf mysql/</p> 
<p style="margin-left:.0001pt;text-align:justify;">3)进入软件预安装目录，上传MySQL的安装包：</p> 
<p># 进入预安装目录</p> 
<p>cd /opt/presoftware/</p> 
<p># 选择MySQL安装包，上传</p> 
<p>rz</p> 
<p style="margin-left:.0001pt;text-align:justify;">4)解压：</p> 
<p>tar -xvf mysql-5.7.33-1.el7.x86_64.rpm-bundle.tar</p> 
<p style="margin-left:.0001pt;text-align:justify;">5)安装MySQL，注意安装顺序不能颠倒：</p> 
<pre><code class="hljs">rpm -ivh mysql-community-common-5.7.33-1.el7.x86_64.rpm

rpm -ivh mysql-community-libs-5.7.33-1.el7.x86_64.rpm

rpm -ivh mysql-community-devel-5.7.33-1.el7.x86_64.rpm

rpm -ivh mysql-community-libs-compat-5.7.33-1.el7.x86_64.rpm

rpm -ivh mysql-community-client-5.7.33-1.el7.x86_64.rpm

rpm -ivh mysql-community-server-5.7.33-1.el7.x86_64.rpm</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">6)启动MySQL：</p> 
<p>systemctl start mysqld</p> 
<p style="margin-left:.0001pt;text-align:justify;">7)查看MySQL的初始密码：</p> 
<p>grep 'temporary password' /var/log/mysqld.log</p> 
<p style="margin-left:.0001pt;text-align:justify;">8)登录MySQL，修改初始密码：</p> 
<p>mysql -u root -p</p> 
<p># 回车后输入初始密码</p> 
<p style="margin-left:.0001pt;text-align:justify;">默认情况下，MySQL的密码要求至少12个字符，至少包含1个小写字母，1个大写字母，1个数字以及1个特殊符号，在学习环境下，不需要如此复杂的密码，所以更改MySQL的密码策略：</p> 
<p>-- 更改MySQL关于密码长度的要求</p> 
<p>set global validate_password_length=4;</p> 
<p>-- 更改MySQL关于密码字符类型的要求</p> 
<p>set global validate_password_policy=0;</p> 
<p style="margin-left:.0001pt;text-align:justify;">更改MySQL的密码：</p> 
<p>SET PASSWORD FOR 'root'@'localhost'= "root";</p> 
<p style="margin-left:.0001pt;text-align:justify;">9)配置MySQL远程登录：</p> 
<p>-- 权限</p> 
<p>GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'root' WITH GRANT OPTION;</p> 
<p>-- 策略生效</p> 
<p>FLUSH PRIVILEGES;</p> 
<p>-- 退出MySQL</p> 
<p>quit;</p> 
<p style="margin-left:.0001pt;text-align:justify;">10)设置忽略MySQL的大小写：</p> 
<p># 编辑文件</p> 
<p>vim /etc/my.cnf</p> 
<p># 在[mysqld]下添加</p> 
<p>lower_case_table_names=1</p> 
<p style="margin-left:.0001pt;text-align:justify;">11) 重启mysql：</p> 
<p>systemctl restart mysqld</p> 
<h4 style="text-align:justify;"><strong><strong><strong>H</strong></strong><strong><strong>ive</strong></strong><strong><strong>安装</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">1)进入软件预安装目录，上传或者下载Hive的安装包：</p> 
<p># 进入预安装目录</p> 
<p>cd /opt/presoftware/</p> 
<p># 上传或者下载Hive的安装包，官网下载地址为：</p> 
<p>wget https://dlcdn.apache.org/hive/hive-3.1.3/apache-hive-3.1.3-bin.tar.gz</p> 
<p># 注意：官网提供的Hive默认是不支持Spark3的，所以最好使用我们自己编译产生的Hive安装包</p> 
<p style="margin-left:.0001pt;text-align:justify;">2)解压：</p> 
<p>tar -xvf apache-hive-3.1.3-bin.tar.gz -C /opt/software/</p> 
<p style="margin-left:.0001pt;text-align:justify;">3)重命名：</p> 
<p># 进入软件安装目录</p> 
<p>cd /opt/software/</p> 
<p># 重命名</p> 
<p>mv apache-hive-3.1.3-bin/ hive-3.1.3</p> 
<p style="margin-left:.0001pt;text-align:justify;">4)配置环境变量：</p> 
<p># 编辑文件</p> 
<p>vim /etc/profile.d/hivehome.sh</p> 
<p># 在文件中添加</p> 
<p>export HIVE_HOME=/opt/software/hive-3.1.3</p> 
<p>export PATH=$PATH:$HIVE_HOME/bin</p> 
<p># 保存退出，生效</p> 
<p>source /etc/profile.d/hivehome.sh</p> 
<p># 测试</p> 
<p>hive --version</p> 
<p style="margin-left:.0001pt;text-align:justify;">5)解决Hive的日志jar包冲突问题：</p> 
<p># 进入Hive的lib目录</p> 
<p>cd /opt/software/hive-3.1.3/lib/</p> 
<p># 重命名</p> 
<p>mv log4j-slf4j-impl-2.17.1.jar log4j-slf4j-impl-2.17.1.jar.bak</p> 
<p style="margin-left:.0001pt;text-align:justify;">6)给Hive添加MySQL的连接驱动：</p> 
<p># 选择驱动jar包，上传</p> 
<p>rz</p> 
<p style="margin-left:.0001pt;text-align:justify;">7)修改Hive的配置：</p> 
<p># 进入Hive的配置目录</p> 
<p>cd ../conf</p> 
<p># 编辑文件</p> 
<p>vim hive-site.xml</p> 
<p style="margin-left:.0001pt;text-align:justify;">在文件中添加：</p> 
<pre><code class="hljs">&lt;?xml version="1.0"?&gt;

&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;

&lt;configuration&gt;

&lt;!--Hive元数据库--&gt;

&lt;property&gt;

&lt;name&gt;hive.metastore.db.type&lt;/name&gt;

&lt;value&gt;mysql&lt;/value&gt;

&lt;/property&gt;

&lt;!--MySQL连接地址--&gt;

&lt;property&gt;

&lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;

&lt;value&gt;jdbc:mysql://hadoop01:3306/hive?useSSL=false&lt;/value&gt;

&lt;/property&gt;

&lt;!--MySQL驱动--&gt;

&lt;property&gt;

&lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt;

&lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;

&lt;/property&gt;

&lt;!--MySQL用户名--&gt;

&lt;property&gt;

&lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;

&lt;value&gt;root&lt;/value&gt;

&lt;/property&gt;

&lt;!--MySQL密码--&gt;

&lt;property&gt;

&lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt;

&lt;value&gt;root&lt;/value&gt;

&lt;/property&gt;

&lt;!--Hive元数据的存储位置--&gt;

&lt;property&gt;

&lt;name&gt;hive.metastore.warehouse.dir&lt;/name&gt;

&lt;value&gt;/user/hive/warehouse&lt;/value&gt;

&lt;/property&gt;

&lt;!--Hive元数据的约束--&gt;

&lt;property&gt;

&lt;name&gt;hive.metastore.schema.verification&lt;/name&gt;

&lt;value&gt;false&lt;/value&gt;

&lt;/property&gt;

&lt;!--Hive元数据的访问位置--&gt;

&lt;property&gt;

&lt;name&gt;hive.metastore.uris&lt;/name&gt;

&lt;value&gt;thrift://hadoop01:9083&lt;/value&gt;

&lt;/property&gt;

&lt;!--Hive服务的访问端口--&gt;

&lt;property&gt;

&lt;name&gt;hive.server2.thrift.port&lt;/name&gt;

&lt;value&gt;10000&lt;/value&gt;

&lt;/property&gt;

&lt;!--Hive服务监听的主机--&gt;

&lt;property&gt;

&lt;name&gt;hive.server2.thrift.bind.host&lt;/name&gt;

&lt;value&gt;hadoop01&lt;/value&gt;

&lt;/property&gt;

&lt;!--Hive的自动认证--&gt;

&lt;property&gt;

&lt;name&gt;hive.metastore.event.db.notification.api.auth&lt;/name&gt;

&lt;value&gt;false&lt;/value&gt;

&lt;/property&gt;

&lt;property&gt;

&lt;name&gt;datanucleus.schema.autoCreateAll&lt;/name&gt;

&lt;value&gt;true&lt;/value&gt;

&lt;/property&gt;

&lt;/configuration&gt;</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">8)初始化Hive的元数据库：</p> 
<p># 进入MySQL</p> 
<p>mysql -u root -p</p> 
<p># 回车之后输入密码</p> 
<p style="margin-left:.0001pt;text-align:justify;">建立Hive的元数据库：</p> 
<p>-- 建库吗、，需要注意的是，Hive的元数据只能是西欧编码</p> 
<p>create database hive character set latin1;</p> 
<p>-- 退出MySQL</p> 
<p>quit;</p> 
<p style="margin-left:.0001pt;text-align:justify;">9)初始化元数据库：</p> 
<p>schematool -initSchema -dbType mysql –verbose</p> 
<p style="margin-left:.0001pt;text-align:justify;">10)启动Hadoop：</p> 
<p>start-all.sh</p> 
<p style="margin-left:.0001pt;text-align:justify;">11)启动Hive的元数据服务：</p> 
<p>hive --service metastore &amp;</p> 
<p style="margin-left:.0001pt;text-align:justify;">12)启动Hive：</p> 
<p>hive</p> 
<h3 style="text-align:justify;"><strong><strong><strong>其他</strong></strong></strong></h3> 
<h4 style="text-align:justify;"><strong><strong><strong>H</strong></strong><strong><strong>ive</strong></strong><strong><strong>的运行日志</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">Hive启动之后，其运行日志默认是放在/tmp/用户名/hive.log中。例如root用户就是/tmp/root/hive.log，tom用户就是/tmp/tom/hive.log。</p> 
<p style="margin-left:.0001pt;text-align:justify;">由于/tmp目录的特殊性，所以一般需要修改hive运行日志的存储位置：</p> 
<p style="margin-left:.0001pt;text-align:justify;">1)进入Hive的配置文件目录：</p> 
<p>cd /opt/software/hive-3.1.3/conf/</p> 
<p style="margin-left:.0001pt;text-align:justify;">2)复制文件：</p> 
<p>cp hive-log4j2.properties.template hive-log4j2.properties</p> 
<p style="margin-left:.0001pt;text-align:justify;">3)编辑文件，修改属性值：</p> 
<p># 编辑文件</p> 
<p>vim hive-log4j2.properties</p> 
<p># 修改property.hive.log.dir的属性值：</p> 
<p>property.hive.log.dir = /opt/software/hive-3.1.3/logs</p> 
<p style="margin-left:.0001pt;text-align:justify;">4)创建日志目录：</p> 
<p># 回到Hive的安装目录</p> 
<p>cd ..</p> 
<p># 创建日志目录</p> 
<p>mkdir logs</p> 
<p style="margin-left:.0001pt;text-align:justify;">Hive重启之后，就会在指定目录下生成hive.log文件了。</p> 
<h4 style="text-align:justify;"><strong><strong><strong>参数修改方式</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">Hive中提供了三种指定和修改参数的方式：</p> 
<p style="margin-left:.0001pt;text-align:justify;">1)修改hive-site.xml。这种配置方式的特点是永久有效，并且对所有的Hive进程都有效果；</p> 
<p style="margin-left:.0001pt;text-align:justify;">2)通过hive -hiveconf XXX来修改配置。这种方式仅对当前一次会话有效，不影响其他的Hive会话。例如：</p> 
<p>hive -hiveconf mapred.reduce.tasks = 3;</p> 
<p style="margin-left:.0001pt;text-align:justify;">3)进入Hive之后，通过set方式修改参数配置。这种方式也是仅对当前会话有效，不影响其他的Hive会话。</p> 
<p style="margin-left:.0001pt;text-align:justify;">三种方式的优先级是：set方式&gt;hiveconf&gt;配置文件hive-site.xml。</p> 
<h4 style="text-align:justify;"><strong><strong><strong>Hi</strong></strong><strong><strong>ve SQL</strong></strong><strong><strong>的执行方式</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">Hive中提供了三种执行SQL的方式：</p> 
<p style="margin-left:.0001pt;text-align:justify;">1)通过hive -e "xxx"来执行SQL，例如：</p> 
<p>hive -e "select * from person;"</p> 
<p style="margin-left:.0001pt;text-align:justify;">2)通过hive -f xxx.sql来执行指定的SQL脚本文件；</p> 
<p style="margin-left:.0001pt;text-align:justify;">3)进入Hive命令行之后执行SQL。</p> 
<h4 style="text-align:justify;"><strong><strong><strong>H</strong></strong><strong><strong>ive</strong></strong><strong><strong>的访问方式</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">Hive提供了两种访问方式：cli方式和hiveserver2方式。</p> 
<p style="margin-left:.0001pt;text-align:justify;">cli方式，顾名思义，通过Hive提供的客户端来访问Hive。执行命令</p> 
<p>hive</p> 
<p style="margin-left:.0001pt;text-align:justify;">就可以直接进入Hive的客户端。</p> 
<p style="margin-left:.0001pt;text-align:justify;">cli方式的优势在于不需要额外启动其他的进程，也不需要额外安装，在安装了Hive的服务器上通过hive命令就能直接使用；劣势在于这种方式无法灵活的远程连接其他服务器。</p> 
<p style="margin-left:.0001pt;text-align:justify;">hiveserver2方式，本质上就是通过JDBC(beeline)的方式来连接Hive，这种方式需要Hadoop中指定运行环境，且还需要启动hiveserver2进程：</p> 
<p>hive --service hiveserver2 &amp;</p> 
<p style="margin-left:.0001pt;text-align:justify;">hiveserver2方式的优势在于可以远程连接其他节点，劣势在于安装了Hive的服务器上需要多启动线程，而且连接客户端需要有hive jdbc的支持。</p> 
<h4 style="text-align:justify;"><strong><strong><strong>Idea</strong></strong><strong><strong>/Datagrip</strong></strong><strong><strong>连接H</strong></strong><strong><strong>ive</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">1)下载Hive的连接驱动：</p> 
<p># 进入Hive的jdbc目录</p> 
<p>cd /opt/software/hive-3.1.3/jdbc/</p> 
<p># 下载Hive的连接驱动jar包</p> 
<p>sz hive-jdbc-3.1.3-standalone.jar</p> 
<p style="margin-left:.0001pt;text-align:justify;">2)启动Hive的元数据服务和远程连接服务：</p> 
<p>hive --service metastore &amp;</p> 
<p>hive --service hiveserver &amp;</p> 
<p style="margin-left:.0001pt;text-align:justify;">3)启动idea或者Datagrip：</p> 
<p style="margin-left:.0001pt;text-align:justify;">4)点击+，选择Data Source，选择Apache Hive：</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/d5/eb/yFD7jk1u_o.png"></p> 
<p style="text-align:center;">图-13 选择Hive连接</p> 
<p style="margin-left:.0001pt;text-align:justify;">5)给Hive起名，指定连接的主机和端口，指定用户以及连接的库：</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/2b/6d/mLxZlRb2_o.png"></p> 
<p style="text-align:center;">图-14 Hive连接配置</p> 
<p style="margin-left:.0001pt;text-align:justify;">6)点击Driver：</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/52/c1/HMTEp6la_o.png"></p> 
<p style="text-align:center;">图-15 点击Driver</p> 
<p style="margin-left:.0001pt;text-align:justify;">7) 指定驱动，然后返回:</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/2c/12/ELrdVSfO_o.png"></p> 
<p style="text-align:center;">图-16 指定驱动</p> 
<p style="margin-left:.0001pt;text-align:justify;">8)测试连接：</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/1a/32/nQbNkH6g_o.png"></p> 
<p style="text-align:center;">图-17 测试连接</p> 
<p style="margin-left:.0001pt;text-align:justify;">9)应用之后，确定连接：</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/35/a7/1F141JXX_o.png"></p> 
<p style="text-align:center;">图-18 确定连接</p> 
<p style="margin-left:.0001pt;text-align:justify;">10)DataGrip/idea连接Hive的时候，容易出现java.lang.OutOfMemoryError: GC overhead limit exceeded。此时需要调节YARN给Hive分配的默认内存：</p> 
<p># 进入Hive的配置目录</p> 
<p>cd /opt/software/hive-3.1.3/conf/</p> 
<p># 复制文件</p> 
<p>cp hive-env.sh.template hive-env.sh</p> 
<p># 编辑文件</p> 
<p>vim hive-env.sh</p> 
<p># 在文件中添加</p> 
<p>export HADOOP_HEAPSIZE=1024</p> 
<p># 保存退出，生效</p> 
<p>source hive-env.sh</p> 
<p># 重新启动Hive的metastore以及hiveserver2服务即可</p> 
<p>hive --service metastore &amp;</p> 
<p>hive --service hiveserver2 &amp;</p> 
<h2 style="text-align:justify;"><strong><strong><strong>基本语法</strong></strong></strong></h2> 
<h3 style="text-align:justify;"><strong><strong><strong>库操作</strong></strong></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify;">Hive和MySQL类似，提供了针对database的操作。</p> 
<p style="margin-left:.0001pt;text-align:justify;">1)创建库：</p> 
<p>create database demo;</p> 
<p style="margin-left:.0001pt;text-align:justify;">注意，每一个database在HDFS上都会对应一个目录，如果不指定，那么默认是放在/user/hive/warehouse/下。在Hive中，database的名字和存储位置一旦确定就不能修改。</p> 
<p style="margin-left:.0001pt;text-align:justify;">2)创建库demo2，并且指定demo2在HDFS上的存储位置：</p> 
<p>create database demo2 location '/demo2.db';</p> 
<p style="margin-left:.0001pt;text-align:justify;">3)如果demo3库不存在，那么创建demo3：</p> 
<p>create database if not exists demo3;</p> 
<p style="margin-left:.0001pt;text-align:justify;">4)创建库的时候为其指定属性：</p> 
<p>create database demo4 with dbproperties ('create_time' = '2023-07-20');</p> 
<p style="margin-left:.0001pt;text-align:justify;">5)查询所有的库：</p> 
<p>show databases;</p> 
<p style="margin-left:.0001pt;text-align:justify;">6)利用正则表达式过滤符合规则的库：</p> 
<p>show databases like 'demo*';</p> 
<p style="margin-left:.0001pt;text-align:justify;">7)描述库的信息：</p> 
<p>describe database demo;</p> 
<p>-- 或者</p> 
<p>desc database demo;</p> 
<p style="margin-left:.0001pt;text-align:justify;">8)获取库的详细描述信息：</p> 
<p>desc database extended demo;</p> 
<p style="margin-left:.0001pt;text-align:justify;">9)切换/使用指定的库：</p> 
<p>use demo;</p> 
<p style="margin-left:.0001pt;text-align:justify;">10)修改指定库demo的属性信息：</p> 
<p>alter database demo set dbproperties ('create_time' = '2023-07-20');</p> 
<p style="margin-left:.0001pt;text-align:justify;">11)删除库demo4，注意，要求这个库为空：</p> 
<p>drop database demo4;</p> 
<p style="margin-left:.0001pt;text-align:justify;">12)判断库是否存在，如果存在，则删除：</p> 
<p>drop database if exists demo3;</p> 
<p style="margin-left:.0001pt;text-align:justify;">13)如果库非空，那么需要强制删除库：</p> 
<p>drop database demo2 cascade;</p> 
<h3 style="text-align:justify;"><strong><strong><strong>表及数据操作</strong></strong></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify;">1)创建表：</p> 
<p>create table person(id int, name string, age int);</p> 
<p style="margin-left:.0001pt;text-align:justify;">需要注意的是，Hive中的每一个表在HDFS上同样对应了一个单独的目录。且在Hive中，没有主键的说法。</p> 
<p style="margin-left:.0001pt;text-align:justify;">2)向表中添加数据：</p> 
<p>insert into table person values (1, 'tom', 15);</p> 
<p style="margin-left:.0001pt;text-align:justify;">Hive默认的执行引擎是MapReduce，所以所有的insert语句在底层都会转化为MapReduce任务来执行，因此效率相对较低。</p> 
<p style="margin-left:.0001pt;text-align:justify;">3)查询数据：</p> 
<p>select * from person;</p> 
<p style="margin-left:.0001pt;text-align:justify;">4)将本地数据加载到Hive中：</p> 
<p>load data local inpath '/opt/hivedata/person' into table person;</p> 
<p style="margin-left:.0001pt;text-align:justify;">5)删除表：</p> 
<p>drop table person;</p> 
<p style="margin-left:.0001pt;text-align:justify;">6)在Hive中，建表的时候一般需要指定字段之间的间隔符号。当表建好之后，间隔符号就不能发生变化了：</p> 
<p>create table person(id int, name string, age int) row format delimited fields terminated by ' ';</p> 
<p style="margin-left:.0001pt;text-align:justify;">row format表示按行进行格式化处理，delimited表示对什么进行限制，fields表示属性，delimited fields就表示对属性进行限制，terminated by表示用什么符号作为间隔。</p> 
<p style="margin-left:.0001pt;text-align:justify;">7)仿照person的表结构创建p2表：</p> 
<p>create table p2 like person;</p> 
<p style="margin-left:.0001pt;text-align:justify;">8)如果p3表不存在，那么仿照person的表结构创建p3表：</p> 
<p>create table if not exists p3 like person;</p> 
<p style="margin-left:.0001pt;text-align:justify;">9)创建p4表，并且复制person表的数据：</p> 
<p>-- 复制表</p> 
<p>create table p4 as select * from person;</p> 
<p>-- 查询数据</p> 
<p>select * from p4;</p> 
<p style="margin-left:.0001pt;text-align:justify;">10)描述表的结构：</p> 
<p>describe person;</p> 
<p>-- 或者</p> 
<p>desc person;</p> 
<p style="margin-left:.0001pt;text-align:justify;">11)获取表的详细结构信息：</p> 
<p>desc extended person;</p> 
<p>-- 或者</p> 
<p>desc formatted person;</p> 
<p style="margin-left:.0001pt;text-align:justify;">12)从person表中查询age&lt;18的数据，并且将查询出来的数据放到p2表中：</p> 
<p>insert into table p2 select * from person where age &lt; 18;</p> 
<p style="margin-left:.0001pt;text-align:justify;">此处需要注意的是，如果使用的是insert into表示向表中追加数据。如果使用的是insert overwrite，则表示将表中原来的数据清空掉，覆盖写入新的数据。</p> 
<p style="margin-left:.0001pt;text-align:justify;">13)从person表中查询数据，将id&lt;5的数据查询出来覆盖到p2表中，将age≥18的数据查询出来追加到p3表中：</p> 
<p>from person</p> 
<p> insert overwrite table p2 select * where id &lt; 5</p> 
<p> insert into table p3 select * where age &gt;= 18;</p> 
<p style="margin-left:.0001pt;text-align:justify;">14) 从person表中查询数据，将查询出来age&lt;18的数据放到本地目录下，字段之间用\t间隔：</p> 
<p>insert overwrite local directory '/opt/hive_demo'</p> 
<p>row format delimited fields terminated by '\t'</p> 
<p>select * from person where age &lt; 18;</p> 
<p style="margin-left:.0001pt;text-align:justify;">注意，向文件中写入数据的时候只能使用insert overwrite，所以此时要求目标目录为空(即目标目录中没有子文件或者子目录，如果有子文件或者子目录，那么会被清理掉)。</p> 
<p style="margin-left:.0001pt;text-align:justify;">15)从person表中查询数据，将查询出来age≥18的数据放到HDFS的指定目录下，字段之间用逗号间隔：</p> 
<p>insert overwrite directory '/person_demo'</p> 
<p>row format delimited fields terminated by ','</p> 
<p>select * from person where age &gt;= 18;</p> 
<p style="margin-left:.0001pt;text-align:justify;">16)将HDFS上的指定文件加载到Hive中：</p> 
<p>load data inpath '/person.txt' into table person;</p> 
<p style="margin-left:.0001pt;text-align:justify;">17)将表person重命名为p1：</p> 
<p>alter table person rename to p1;</p> 
<p style="margin-left:.0001pt;text-align:justify;">18)修改列名：将p1表的id列名改为pid，数据类型不变：</p> 
<p>alter table p1 change column id pid int;</p> 
<p style="margin-left:.0001pt;text-align:justify;">19)修改列的类型：将p1表的pid列类型改为string：</p> 
<p>alter table p1 change column pid pid string;</p> 
<p style="margin-left:.0001pt;text-align:justify;">20)新增列：在p1表中新增一列gender：</p> 
<p>alter table p1 add columns (gender string);</p> 
<p style="margin-left:.0001pt;text-align:justify;">21)更换列的位置：将p1表中的name列调为第一列(注意：这种方式不更将数据更换了位置，只是列名更换了位置)：</p> 
<p>alter table p1 change column name name string first;</p> 
<p style="margin-left:.0001pt;text-align:justify;">22)更换列的位置：将p1表中的name列放到gender列之后(注意：这种方式不更将数据更换了位置，只是列名更换了位置)：</p> 
<p>alter table p1 change column name name string after gender;</p> 
<p style="margin-left:.0001pt;text-align:justify;">23)清空表中的数据：</p> 
<p>truncate table p1;</p> 
<p style="margin-left:.0001pt;text-align:justify;">24)覆盖加载：</p> 
<p>load data local inpath '/opt/hivedata/person' overwrite into table p1;</p> 
<h3 style="text-align:justify;"><strong><strong><strong>表结构</strong></strong></strong></h3> 
<h4 style="text-align:justify;"><strong><strong><strong>内部表和外部表</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">在Hive中，所有的表都分为内部表(又叫管理表，Managed Table)和外部表(External Table)。一般而言，在Hive中手动建表手动添加数据(load或者insert)的表，大部分是内部表，而外部表是在Hive中建表来管理HDFS上已经存在的数据。</p> 
<p style="margin-left:.0001pt;text-align:justify;">如果想要区分一个表是内部表还是外部表，可以通过命令：</p> 
<p>desc extened tableName;</p> 
<p>-- 或者</p> 
<p>desc formatted tableName;</p> 
<p style="margin-left:.0001pt;text-align:justify;">来描述这个表的详细信息，在详细信息中查看Table Type属性的值。如果是Table Type属性的值为Managed Table，就是内部表；如果是External Table，则表示外部表。</p> 
<p style="margin-left:.0001pt;text-align:justify;">案例：建立外部表。</p> 
<p>-- 将文件上传到HDFS的/orders目录下</p> 
<p>-- 创建外部表</p> 
<p>create external table orders (</p> 
<p>    name       string, -- 用户名</p> 
<p>    order_date string, -- 订单日期</p> 
<p>    cost       int     -- 消费</p> 
<p>) row format delimited fields terminated by ','</p> 
<p>    location '/orders';</p> 
<p>-- 查询数据</p> 
<p>select * from orders;</p> 
<p style="margin-left:.0001pt;text-align:justify;">需要注意的是，外部表在删除的时候不会删除HDFS上对应的文件，但是内部表在删除的时候会删除对应的目录。</p> 
<p style="margin-left:.0001pt;text-align:justify;">将外部表转化为内部表：</p> 
<p>alter table orders set tblproperties ('EXTERNAL' = 'false');</p> 
<p style="margin-left:.0001pt;text-align:justify;">将内部表转化为外部表：</p> 
<p>alter table orders set tblproperties ('EXTERNAL' = 'true');</p> 
<h4 style="text-align:justify;"><strong><strong><strong>分区表</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">在Hive中，如果数据量特别大，需要对数据进行分类存储，那么要怎么处理呢？此时可以使用分区表。分区表最常见的作用就是对数据进行分类。</p> 
<p style="margin-left:.0001pt;text-align:justify;">案例：创建分区表并加载数据。</p> 
<p>-- 原始数据wei.txt</p> 
<p>1 曹操</p> 
<p>2 司马懿</p> 
<p>3 张辽</p> 
<p>4 荀彧</p> 
<p>-- 原始数据shu.txt</p> 
<p>1 刘备</p> 
<p>2 诸葛亮</p> 
<p>3 关羽</p> 
<p>4 张飞</p> 
<p>-- 原始数据wu.txt</p> 
<p>1 孙权</p> 
<p>2 周瑜</p> 
<p>3 吕蒙</p> 
<p>4 陆逊</p> 
<p>-- 建立外部表</p> 
<p>create table countries (</p> 
<p>    id   int,   -- 编号</p> 
<p>    name string -- 姓名</p> 
<p>) partitioned by (country string) -- 以国家作为分类(分区)</p> 
<p>    row format delimited fields terminated by ' ';</p> 
<p>-- 加载数据</p> 
<p>load data local inpath '/opt/hivedata/wei.txt' into table countries partition (country = 'wei');</p> 
<p>load data local inpath '/opt/hivedata/shu.txt' into table countries partition (country = 'shu');</p> 
<p>load data local inpath '/opt/hivedata/wu.txt' into table countries partition (country = 'wu');</p> 
<p>-- 查询数据</p> 
<p>select * from countries;</p> 
<p style="margin-left:.0001pt;text-align:justify;">查看HDFS会发现，每一个分区在HDFS上对应了一个单独的目录。在查询数据的时候，如果指定了分区作为查询条件，那么此时不需要读取整个表中所有的数据，而只需要读取对应分区目录下的数据即可，此时提高了查询效率；如果在查询数据的时候进行了跨分区查询，那么此时由于要读取多个文件，效率反而会有所降低。</p> 
<p style="margin-left:.0001pt;text-align:justify;">如果在HDFS上手动创建了目录上传了文件，那么怎么让Hive知道这个新创建的目录是我们要增加的分区呢？</p> 
<p>-- 原始数据hero.txt</p> 
<p>1 董卓</p> 
<p>2 吕布</p> 
<p>3 袁术</p> 
<p>4 袁绍</p> 
<p>-- 在HDFS中创建目录</p> 
<p>dfs -mkdir '/user/hive/warehouse/demo.db/countries/country=heroes';</p> 
<p>-- 将文件传到这个目录下</p> 
<p>dfs -put '/opt/hivedata/hero.txt' '/user/hive/warehouse/demo.db/countries/country=heroes';</p> 
<p>-- 手动添加分区</p> 
<p>alter table countries add partition (country = 'heroes')</p> 
<p>location '/user/hive/warehouse/demo.db/countries/country=heroes';</p> 
<p>-- 或者，可以选择修复分区</p> 
<p>msck repair table countries;</p> 
<p style="margin-left:.0001pt;text-align:justify;">注意，如果添加多个分区，那么分区之间用空格间隔：</p> 
<p>alter table tableName add partition(partitionName = 'name1') partition(partitionName = 'name2') partition(partitionName = 'name3')...;</p> 
<p style="margin-left:.0001pt;text-align:justify;">修改分区的名字：</p> 
<p>alter table countries partition (country = 'heroes') rename to partition (country = 'other');</p> 
<p style="margin-left:.0001pt;text-align:justify;">删除分区：</p> 
<p>alter table countries drop partition (country = 'other');</p> 
<p style="margin-left:.0001pt;text-align:justify;">注意，如果删除多个分区，那么分区之间用逗号隔开：</p> 
<p>alter table tableName drop partition(partitionName = 'name1'), partition(partitionName = 'name2'), partition(partitionName = 'name3'), ...;</p> 
<p style="margin-left:.0001pt;text-align:justify;">需要注意的是，在Hive中，分区表的分区字段要求在原始数据中不存在，可以认为分区字段就是要给伪劣。如果要是原始数据中存在了分区字段，那么此时就需要进行动态分区了。</p> 
<p style="margin-left:.0001pt;text-align:justify;">动态分区案例：</p> 
<p>-- 原始数据heroes.txt 1 wei 荀攸</p> 
<p>2 wei 张辽</p> 
<p>3 shu 孙乾</p> 
<p>4 shu 马超</p> 
<p>5 wu 张昭</p> 
<p>6 wu 甘宁</p> 
<p>7 wei 贾诩</p> 
<p>8 wu 太史慈</p> 
<p>9 shu 法正</p> 
<p>10 shu 赵云</p> 
<p>11 wei 程昱</p> 
<p>12 wei 郭嘉</p> 
<p>13 wu 黄盖</p> 
<p>14 wu 鲁肃</p> 
<p>15 shu 黄忠</p> 
<p>-- 在Hive中创建临时表</p> 
<p>create table countries_tmp ( cid int, c_country string, c_name string) row format delimited fields terminated by ' ';</p> 
<p>-- 加载数据到临时表</p> 
<p>load data local inpath '/opt/hivedata/heroes.txt' into table countries_tmp;</p> 
<p>-- 查询数据</p> 
<p>select * from countries_tmp tablesample (5 rows);</p> 
<p>-- 开启动态分区 - 非严格模式</p> 
<p>set hive.exec.dynamic.partition.mode=nonstrict;</p> 
<p>-- 当有空分区生成时，是否报错</p> 
<p>set hive.error.on.empty.partition=false;</p> 
<p>-- 动态分区 - 从未分区表中查询数据放到已分区表中</p> 
<p>insert into table countries partition (country)</p> 
<p>select cid, c_name, c_country from countries_tmp distribute by c_country;</p> 
<p style="margin-left:.0001pt;text-align:justify;">Hive也支持多字段分区。如果进行了多字段分区，那么此时前一个分区字段形成的目录会包含后一个分区字段形成的目录。多字段分区通常用于多级分类，例如省市县，学生的年级和班级，商品的一级二级三级分类等。</p> 
<p>-- 原始数据students</p> 
<p>1 1 1 tom</p> 
<p>1 1 2 sam</p> 
<p>1 1 3 bob</p> 
<p>1 1 4 alex</p> 
<p>1 2 1 bruce</p> 
<p>1 2 2 cindy</p> 
<p>1 2 3 jack</p> 
<p>1 2 4 john</p> 
<p>2 1 1 tex</p> 
<p>2 1 2 helen</p> 
<p>2 1 3 charles</p> 
<p>2 1 4 frank</p> 
<p>2 2 1 david</p> 
<p>2 2 2 simon</p> 
<p>2 2 3 lucy</p> 
<p>2 2 4 lily</p> 
<p>-- 建立临时表</p> 
<p>create table students_tmp (</p> 
<p>    t_grade int,   -- 年纪</p> 
<p>    t_class int,   -- 班级</p> 
<p>    t_id    int,   -- 编号</p> 
<p>    t_name  string -- 姓名</p> 
<p>) row format delimited fields terminated by ' ';</p> 
<p>-- 加载数据</p> 
<p>load data local inpath '/opt/hivedata/students' into table students_tmp;</p> 
<p>-- 查询数据</p> 
<p>select *</p> 
<p>from students_tmp tablesample (5 rows);</p> 
<p>-- 开启动态分区</p> 
<p>set hive.exec.dynamic.partition.mode=nonstric;</p> 
<p>-- 当有空分区生成时，是否报错</p> 
<p>set hive.error.on.empty.partition=false;</p> 
<p>-- 创建分区表</p> 
<p>create table students ( id int, name string) partitioned by (grade int, class int) row format delimited fields terminated by ' ';</p> 
<p>-- 动态分区</p> 
<p>insert into table students partition (grade, class)</p> 
<p>select t_id, t_name, t_grade, t_class</p> 
<p>from students_tmp distribute by t_grade, t_class;</p> 
<p>-- 查询数据</p> 
<p>select * from students;</p> 
<h4 style="text-align:justify;"><strong><strong><strong>分桶表</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">当数据量比较大，又需要对数据进行快速分析的时候，可以考虑从原始数据中抽取一部分数据来进行分析。需要注意的是，抽取的字段和要分析的字段之间不能有关联性，例如年龄和身高是有关联性的，但是姓名和身高就没有关联性。</p> 
<p style="margin-left:.0001pt;text-align:justify;">分桶表的分桶规则是：先计算分桶字段的哈希值，然后对桶的个数进行取余，根据余数决定讲数据放入哪一个桶中。</p> 
<p style="margin-left:.0001pt;text-align:justify;">需要注意的是，在老版本的Hive中，使用load方式加载数据不会对数据进行分桶，只能使用insert方式来回对数据进行分桶；最新版本的Hive(Hive3.1.3版本)中支持load方式分桶，但是会存在问题，所以依然建议使用insert方式来将数据放入分桶表中。</p> 
<p style="margin-left:.0001pt;text-align:justify;">案例：</p> 
<p>-- 开启分桶机制</p> 
<p>set hive.enforce.bucketing = true;</p> 
<p>-- 设置ReduceTask的个数，-1表示根据情况由Hive自己决定</p> 
<p>set mapreduce.job.reduces = -1;</p> 
<p>-- 建立分桶表，根据name字段的值，将数据分到4个桶中</p> 
<p>create table students_bucket ( id int, name string ) clustered by (name) into 4 buckets row format delimited fields terminated by ' ';</p> 
<p>-- 向分区表加载数据</p> 
<p>insert overwrite table students_bucket select id, name from students;</p> 
<h3 style="text-align:justify;"><strong><strong><strong>数据类型</strong></strong></strong></h3> 
<h4 style="text-align:justify;"><strong><strong><strong>概述</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">Hive针对数据提供了非常丰富的数据类型，这些数据类型大致可以分为两类：基本类型和复杂类型。</p> 
<p style="margin-left:.0001pt;text-align:justify;">Hive提供的基本类型主要包括：</p> 
<p><strong>表-</strong><strong>1 </strong><strong>基本数据类型</strong></p> 
<table align="center" cellspacing="0"><tbody><tr><td> <p style="text-align:center;"><strong>H</strong><strong>ive</strong><strong>类型</strong></p> </td><td> <p style="text-align:center;"><strong>J</strong><strong>ava</strong><strong>类型</strong></p> </td></tr><tr><td> <p style="text-align:center;">tinyint</p> </td><td> <p style="text-align:center;">byte</p> </td></tr><tr><td> <p style="text-align:center;">smallint</p> </td><td> <p style="text-align:center;">short</p> </td></tr><tr><td> <p style="text-align:center;">int</p> </td><td> <p style="text-align:center;">int</p> </td></tr><tr><td> <p style="text-align:center;">bigint</p> </td><td> <p style="text-align:center;">long</p> </td></tr><tr><td> <p style="text-align:center;">float</p> </td><td> <p style="text-align:center;">float</p> </td></tr><tr><td> <p style="text-align:center;">double</p> </td><td> <p style="text-align:center;">double</p> </td></tr><tr><td> <p style="text-align:center;">boolean</p> </td><td> <p style="text-align:center;">boolean</p> </td></tr><tr><td> <p style="text-align:center;">string</p> </td><td> <p style="text-align:center;">String</p> </td></tr><tr><td> <p style="text-align:center;">binary</p> </td><td> <p style="text-align:center;">byte[]</p> </td></tr><tr><td> <p style="text-align:center;">timestamp</p> </td><td> <p style="text-align:center;">Timestamp</p> </td></tr></tbody></table> 
<p style="margin-left:.0001pt;text-align:justify;">Hive提供的复杂类型主要是三个：array，map和struct类型。</p> 
<h4 style="text-align:justify;"><strong><strong><strong>复杂数据类型</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">array(数组)类型，对应了Java中的数组以及集合结构。</p> 
<p>-- 原始数据</p> 
<p>1 bob,alex lucy,lily,jack</p> 
<p>2 tom,sam,smith rose,john</p> 
<p>3 peter,bruce david,kathy</p> 
<p>4 helen,eden,iran cindy,grace,mike</p> 
<p>-- 建表</p> 
<p>create table battles (</p> 
<p>    id      int,           -- 编号</p> 
<p>    group_a array&lt;string&gt;, -- A组</p> 
<p>    group_b array&lt;string&gt;  -- B组</p> 
<p>) row format delimited</p> 
<p>    fields terminated by ' ' -- 字段之间用空格间隔</p> 
<p>    collection items terminated by ','; -- 数组/集合元素之间用逗号间隔</p> 
<p>-- 加载数据</p> 
<p>load data local inpath '/opt/hivedata/battles' into table battles;</p> 
<p>-- 查询数据</p> 
<p>select * from battles tablesample (5 rows);</p> 
<p>-- 查询A组的第一个成员</p> 
<p>select group_a[0] from battles;</p> 
<p>-- 非空查询</p> 
<p>select group_a[2] from battles where group_a[2] is not null;</p> 
<p style="margin-left:.0001pt;text-align:justify;">map(映射)类型，对应了Java中的Map类型。</p> 
<p>-- 原始数据</p> 
<p>1 alex,bruce</p> 
<p>2 carl,duck</p> 
<p>3 eden,fred</p> 
<p>4 gill,hack</p> 
<p>5 iran,jack</p> 
<p>-- 建表</p> 
<p>create table groups (</p> 
<p>    id      int,                -- 小组编号</p> 
<p>    members map&lt;string, string&gt; -- 小组成员</p> 
<p>) row format delimited</p> 
<p>    fields terminated by ' ' -- 字段之间用空格间隔</p> 
<p>    map keys terminated by ','; -- 映射键值之间用逗号间隔</p> 
<p>-- 加载数据</p> 
<p>load data local inpath '/opt/hivedata/groups' into table groups;</p> 
<p>-- 查询数据</p> 
<p>select * from groups;</p> 
<p>-- 非空查询</p> 
<p>select members['carl'] from groups where members['carl'] is not null;</p> 
<p style="margin-left:.0001pt;text-align:justify;">struct(结构体)类型，对应了Java中的对象，可以看作是将数据封装成了json串形式。</p> 
<p>-- 原始数据</p> 
<p>1 tom,19,male sam,20,male</p> 
<p>2 lily,18,female lucy,19,female</p> 
<p>3 charles,19,male mark,21,male</p> 
<p>4 joan,18,female james,20,male</p> 
<p>5 linda,20,female matin,21,male</p> 
<p>-- 建表</p> 
<p>create table infos</p> 
<p>(</p> 
<p>    id       int,                                         -- 小组编号</p> 
<p>    member_a struct&lt;name:string, age:int, gender:string&gt;, -- 成员A</p> 
<p>    member_b struct&lt;name:string, age:int, gender:string&gt;  -- 成员B</p> 
<p>) row format delimited fields terminated by ' ' -- 字段之间用空格间隔</p> 
<p>    collection items terminated by ','; -- 属性之间用逗号间隔</p> 
<p>-- 加载数据</p> 
<p>load data local inpath '/opt/hivedata/infos' into table infos;</p> 
<p>-- 查询数据</p> 
<p>select * from infos tablesample (5 rows);</p> 
<p>-- 查看成员A的名字</p> 
<p>select member_a.name from infos;</p> 
<h2 style="text-align:justify;"><strong><strong><strong>运算符和函数</strong></strong></strong></h2> 
<h4 style="text-align:justify;"><strong><strong><strong>概述</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">Hive针对大量的数据，提供了非常丰富的运算符和函数用于进行数据的处理和分析。同时，为了提供更灵活的操作，Hive还允许用户自定义函数。</p> 
<p style="margin-left:.0001pt;text-align:justify;">但是需要注意的是，在Hive中，所有的运算符和函数都不能直接使用，而是必须结合其他关键字构成语句，例如结合select构成查询语句等。</p> 
<p style="margin-left:.0001pt;text-align:justify;">如果想要查看Hive中提供的所有运算符和函数，可以通过命令：</p> 
<p>show functions;</p> 
<p style="margin-left:.0001pt;text-align:justify;">如果想要查看某一个函数的介绍，可以通过命令：</p> 
<p>desc function functionName;</p> 
<p>-- 例如</p> 
<p>desc function sum;</p> 
<p style="margin-left:.0001pt;text-align:justify;">如果想要查看某一个函数的详细用户，可以通过命令：</p> 
<p>desc function extended functionName;</p> 
<p>-- 例如：</p> 
<p>desc function extended trim;</p> 
<h3 style="text-align:justify;"><strong><strong><strong>入门案例</strong></strong></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify;">案例一：给定某一个日期，例如'2023-07-20'，从中截取年份。</p> 
<p>-- 方式一：通过-来切分日期，然后获取切分之后的第一个字段</p> 
<p>select cast(split('2023-07-20', '-')[0] as int);</p> 
<p>-- 方式二：通过year函数提取，但是这种方式要求年月日之间必须用-间隔</p> 
<p>select year('2023-07-20');</p> 
<p style="margin-left:.0001pt;text-align:justify;">案例二：给定某一个日期，例如'2023/07/20'，从中截取年份。</p> 
<p>-- 方式一：切分之后提取</p> 
<p>select cast(split('2023/07/20', '/')[0] as int);</p> 
<p>-- 方式二：先将日期中的/替换为-，再用year函数提取</p> 
<p>select year(regexp_replace('2023/07/20', '/', '-'));</p> 
<p style="margin-left:.0001pt;text-align:justify;">案例三：给定邮箱，例如'tom@test.com'，从中提取邮箱后缀。</p> 
<p>-- 方式一：切分之后提取</p> 
<p>select split('tom@test.com', '@')[1];</p> 
<p>-- 方式二：利用正则表达式提取</p> 
<p>select regexp_extract('tom@test.com', '(.+)@(.+)', 2);</p> 
<h3 style="text-align:justify;"><strong><strong><strong>常用函数</strong></strong></strong></h3> 
<h4 style="text-align:justify;"><strong><strong><strong>n</strong></strong><strong><strong>vl</strong></strong><strong><strong>函数</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">nvl(v1, v2)函数，在使用的时候需要传入两个参数v1和v2。如果v1的值不为null，则返回v1；反之，如果v1的值为null，则返回v2；如果v1和v2的值都是null，则返回null。</p> 
<p style="margin-left:.0001pt;text-align:justify;">案例：计算员工的平均奖金。</p> 
<p>-- 原始数据</p> 
<p>1 Bill 1000</p> 
<p>2 Vincent 800</p> 
<p>3 William 500</p> 
<p>4 Henry</p> 
<p>5 Betty 500</p> 
<p>6 Fred 300</p> 
<p>7 Karl</p> 
<p>8 Lee 400</p> 
<p>9 Thomas 600</p> 
<p>10 Shirley 900</p> 
<p>-- 建表</p> 
<p>create table rewards (</p> 
<p>    id     int,    -- 员工编号</p> 
<p>    name   string, -- 员工姓名</p> 
<p>    reward double  -- 获得的奖金</p> 
<p>) row format delimited fields terminated by ' ';</p> 
<p>-- 加载数据</p> 
<p>load data local inpath '/opt/hivedata/rewards' into table rewards;</p> 
<p>-- 查询数据</p> 
<p>select *</p> 
<p>from rewards tablesample (5 rows);</p> 
<p>-- 计算员工的平均奖金</p> 
<p>-- 对于avg这一类聚合函数而言，当数据的值为null的时候，会自动跳过</p> 
<p>select avg(reward) from rewards;</p> 
<p>-- 如果员工没有发放奖金，那么奖金应该记为0</p> 
<p>select avg(nvl(reward, 0)) from rewards;</p> 
<h4 style="text-align:justify;"><strong><strong><strong>c</strong></strong><strong><strong>ase when</strong></strong><strong><strong>函数</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">case when函数，类似于Java中的switch-case结构，用于对数据进行判断。</p> 
<p style="margin-left:.0001pt;text-align:justify;">案例：统计每一个部门中男生和女生的人数。</p> 
<p>-- 原始数据</p> 
<p>1 财务 bill 男</p> 
<p>2 技术 charles 男</p> 
<p>3 技术 lucy 女</p> 
<p>4 技术 lily 女</p> 
<p>5 财务 helen 女</p> 
<p>6 财务 jack 男</p> 
<p>7 财务 john 男</p> 
<p>8 技术 alex 男</p> 
<p>9 技术 cindy 女</p> 
<p>10 技术 david 男</p> 
<p>-- 建表</p> 
<p>create table employers (</p> 
<p>    id         int,    -- 员工编号</p> 
<p>    department string, -- 员工部门</p> 
<p>    name       string, -- 员工姓名</p> 
<p>    gender     string  -- 性别</p> 
<p>) row format delimited fields terminated by ' ';</p> 
<p>-- 加载数据</p> 
<p>load data local inpath '/opt/hivedata/employers' into table employers;</p> 
<p>-- 查询每一个部门中男生和女生的人数分别是多少</p> 
<p>-- if结构</p> 
<p>select department                   as `部门`,</p> 
<p>       sum(if(gender = '男', 1, 0)) as `男生人数`,</p> 
<p>       sum(if(gender = '女', 1, 0)) as `女生人数`</p> 
<p>from employers group by department;</p> 
<p>-- case-when结构</p> 
<p>select department                                   as `部门`,</p> 
<p>       sum(case gender when '男' then 1 else 0 end) as `男生人数`,</p> 
<p>       sum(case gender when '女' then 1 else 0 end) as `女生人数`</p> 
<p>from employers group by department;</p> 
<h4 style="text-align:justify;"><strong><strong><strong>e</strong></strong><strong><strong>xplode</strong></strong><strong><strong>函数</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">explode函数，在使用的时候需要传入一个数组或者映射类型的参数。如果传入的是数组，那么会将这个数组中的每一个元素提取出来形成单独的一行数据；如果传入的是一个映射，那么会将这个映射中的键值对提取出来形成两列元素。</p> 
<p style="margin-left:.0001pt;text-align:justify;">案例：统计文件中每一个单词出现的次数。</p> 
<p>-- 原始数据</p> 
<p>hello tom hello bob david joy hello</p> 
<p>hello rose joy hello rose</p> 
<p>jerry hello tom hello joy</p> 
<p>hello rose joy tom hello David</p> 
<p>-- 建表</p> 
<p>create table words (</p> 
<p>    line array&lt;string&gt;</p> 
<p>) row format delimited collection items terminated by ' ';</p> 
<p>-- 加载数据</p> 
<p>load data local inpath '/opt/hivedata/words' into table words;</p> 
<p>-- 查询数据</p> 
<p>select * from words;</p> 
<p>-- 统计文件中每一个单词出现的次数</p> 
<p>select w as `word`, count(w) as `count` from (</p> 
<p> select explode(line) as w from words</p> 
<p>) ws group by w;</p> 
<h4 style="text-align:justify;"><strong><strong><strong>列转行</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">所谓列转行，顾名思义，指的是将一列的数据拆分成多行。在列转行的过程中，要使用的非常重要的函数就是explode。</p> 
<p style="margin-left:.0001pt;text-align:justify;">案例：查询所有的恐怖片。</p> 
<p>-- 原始数据</p> 
<p>封神第一部：朝歌风云 动作/战争/奇幻/古装</p> 
<p>芭比 喜剧/奇幻/冒险</p> 
<p>长安三万里 动画/历史</p> 
<p>超能一家人 喜剧/家庭/奇幻</p> 
<p>茶啊二中 喜剧/动画/奇幻</p> 
<p>祭屋出租 悬疑/惊悚/恐怖</p> 
<p>东北警察故事2 剧情/动作/犯罪</p> 
<p>触底反弹 剧情/运动</p> 
<p>-- 建表</p> 
<p>create table movies (</p> 
<p>    name  string,       -- 电影名</p> 
<p>    types array&lt;string&gt; -- 电影类型</p> 
<p>) row format delimited fields terminated by ' '</p> 
<p>    collection items terminated by '/';</p> 
<p>-- 加载数据</p> 
<p>load data local inpath '/opt/hivedata/movies' into table movies;</p> 
<p>-- 查询数据</p> 
<p>select * from movies tablesample (5 rows);</p> 
<p>-- 查询所有的动画片</p> 
<p>-- 语法：lateral view functionName(expression) tableAlias as colAlias</p> 
<p>-- 这个过程称之为'炸列'</p> 
<p>select name, t from movies lateral view explode(types) ts as t where t = '动画';</p> 
<p style="margin-left:.0001pt;text-align:justify;">同样，列转行，也支持对多列进行拆分：</p> 
<p>-- 原始数据</p> 
<p>Kevin 活泼/开朗 打篮球/看电影</p> 
<p>Lisa 大方/活泼 看电影/听音乐</p> 
<p>Carl 活泼/幽默 打篮球/打游戏</p> 
<p>Joy 大方/文静 听音乐/看书</p> 
<p>--建表</p> 
<p>drop table students;</p> 
<p>create table students (</p> 
<p>    name       string,        -- 姓名</p> 
<p>    characters array&lt;string&gt;, -- 性格</p> 
<p>    hobbies    array&lt;string&gt;  -- 爱好</p> 
<p>) row format delimited fields terminated by ' '</p> 
<p>    collection items terminated by '/';</p> 
<p>-- 加载数据</p> 
<p>load data local inpath '/opt/hivedata/students' into table students;</p> 
<p>-- 查询性格活泼，喜欢打篮球的学生</p> 
<p>select name from students</p> 
<p>  lateral view explode(characters) cs as c lateral view explode(hobbies) hs as h</p> 
<p>  where c = '活泼' and h = '打篮球';</p> 
<h4 style="text-align:justify;"><strong><strong><strong>列转行</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">所谓列转行，顾名思义，是将多行的数据合并到一列上。这个过程中，一般需要使用函数collect_set或者collect_list，如果是转化为stuct结构，那么需要使用named_struct函数。</p> 
<p style="margin-left:.0001pt;text-align:justify;">collect_set和collect_list都是将多个元素汇聚成一个数组，二者的区别是：collect_set不允许元素重复，collect_list允许元素重复。</p> 
<p style="margin-left:.0001pt;text-align:justify;">案例：将同一个年级同一个班级的学生汇聚到一行。</p> 
<p>-- 原始数据</p> 
<p>1 1 burt</p> 
<p>1 2 james</p> 
<p>1 4 fred</p> 
<p>1 2 bruce</p> 
<p>1 1 carol</p> 
<p>1 3 taylor</p> 
<p>1 4 evan</p> 
<p>1 3 grace</p> 
<p>1 1 richard</p> 
<p>1 3 adam</p> 
<p>1 4 ben</p> 
<p>1 1 ross</p> 
<p>1 2 charles</p> 
<p>1 4 cody</p> 
<p>1 3 wendy</p> 
<p>1 2 david</p> 
<p>-- 建表</p> 
<p>drop table students;</p> 
<p>create table students (</p> 
<p>    grade int,   -- 年纪</p> 
<p>    class int,   -- 班级</p> 
<p>    name  string -- 姓名</p> 
<p>) row format delimited fields terminated by ' ';</p> 
<p>-- 加载数据</p> 
<p>load data local inpath '/opt/hivedata/students' into table students;</p> 
<p>-- 查询数据</p> 
<p>select * from students tablesample (5 rows);</p> 
<p>-- 将同一个年级同一个班级的学生汇聚到一行</p> 
<p>select grade, class, concat_ws(',', collect_list(name)) from students group by grade, class;</p> 
<h3 style="text-align:justify;"><strong><strong><strong>函数分类</strong></strong></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify;">在Hive中，函数可以分为UDF、UDAF、UDTF以及窗口函数。</p> 
<p style="margin-left:.0001pt;text-align:justify;">UDF(User Defined Function)：用户定义函数。特点是一进一出，即用户输入一行数据会获取到一行结果。例如year、length、regexp_replace、concat、split等。</p> 
<p style="margin-left:.0001pt;text-align:justify;">UDAF(User Defined Aggration Function)：用户定义聚合函数。特点是多进一出，即用户输入多行数据会获取到一行结果。例如min、max、sum、avg、collect_set、collect_list等。</p> 
<p style="margin-left:.0001pt;text-align:justify;">UDTF(User Defined Table-generated Function)：用户定义表生成函数。特点是一进多出，即用户输入一行数据会获取到多行结果。例如explode、posexplode、inline、stack、json_tuple、parse_url_tuple等。</p> 
<p style="margin-left:.0001pt;text-align:justify;">Hive中提供的大部分函数都是UDF函数。</p> 
<h3 style="text-align:justify;"><strong><strong><strong>自定义函数</strong></strong></strong></h3> 
<h4 style="text-align:justify;"><strong><strong><strong>P</strong></strong><strong><strong>OM</strong></strong><strong><strong>依赖</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">创建Maven工程，导入POM依赖：</p> 
<pre><code class="hljs">&lt;dependencies&gt;

&lt;dependency&gt;

&lt;groupId&gt;org.apache.hive&lt;/groupId&gt;

&lt;artifactId&gt;hive-exec&lt;/artifactId&gt;

&lt;version&gt;3.1.3&lt;/version&gt;

&lt;/dependency&gt;

&lt;dependency&gt;

&lt;groupId&gt;org.apache.hive&lt;/groupId&gt;

&lt;artifactId&gt;hive-jdbc&lt;/artifactId&gt;

&lt;version&gt;3.1.3&lt;/version&gt;

&lt;exclusions&gt;

&lt;exclusion&gt;

&lt;groupId&gt;org.glassfish&lt;/groupId&gt;

&lt;artifactId&gt;javax.el&lt;/artifactId&gt;

&lt;/exclusion&gt;

&lt;/exclusions&gt;

&lt;/dependency&gt;

&lt;dependency&gt;

&lt;groupId&gt;org.apache.hive&lt;/groupId&gt;

&lt;artifactId&gt;hive-metastore&lt;/artifactId&gt;

&lt;version&gt;3.1.3&lt;/version&gt;

&lt;/dependency&gt;

&lt;dependency&gt;

&lt;groupId&gt;org.apache.hive&lt;/groupId&gt;

&lt;artifactId&gt;hive-common&lt;/artifactId&gt;

&lt;version&gt;3.1.3&lt;/version&gt;

&lt;/dependency&gt;

&lt;/dependencies&gt;</code></pre> 
<h4 style="text-align:justify;"><strong><strong><strong>自定义U</strong></strong><strong><strong>DF</strong></strong><strong><strong>函数</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">如果需要自定义UDF函数，那么需要定义类继承父类。需要注意的是，Hive1.x和Hive2.x中需要继承的是UDF类，Hive3.x中需要继承的是GenericUDF。</p> 
<pre><code class="hljs">package com.auth;



import org.apache.hadoop.hive.ql.exec.UDFArgumentException;

import org.apache.hadoop.hive.ql.metadata.HiveException;

import org.apache.hadoop.hive.ql.udf.generic.GenericUDF;

import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;

import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorFactory;



public class AuthUDF extends GenericUDF {



    // 初始化方法，这个方法的返回值决定了evaluate方法的返回值类型

    @Override

    public ObjectInspector initialize(ObjectInspector[] arguments) throws UDFArgumentException {

        if (arguments.length != 2)

            throw new UDFArgumentException("参数个数必须是2个！");

        return PrimitiveObjectInspectorFactory.javaIntObjectInspector;

    }



    // 函数实际的处理逻辑覆盖在这个方法中

    @Override

    public Object evaluate(DeferredObject[] arguments) throws HiveException {

        // 获取原字符串

        String str = arguments[0].get().toString();

        // 获取子串

        String sub = arguments[1].get().toString();

        // 返回子串第一次出现的位置

        return str.indexOf(sub);

    }



    @Override

    public String getDisplayString(String[] children) {

        return "";

    }

}</code></pre> 
<h4 style="text-align:justify;"><strong><strong><strong>自定义U</strong></strong><strong><strong>DTF</strong></strong><strong><strong>函数</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">在Hive3.x中，如果需要自定义UDTF函数，那么需要定义类继承GenericUDTF，覆盖其中的方法。</p> 
<pre><code class="hljs">package com.auth;



import org.apache.hadoop.hive.ql.metadata.HiveException;

import org.apache.hadoop.hive.ql.udf.generic.GenericUDTF;

import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;

import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorFactory;

import org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;

import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorFactory;



import java.util.ArrayList;

import java.util.List;



// 根据指定符号，将字符串切分为多行数据

public class AuthUDTF extends GenericUDTF {



    // 定义列表用于存储数据

    private final List&lt;String&gt; values = new ArrayList&lt;&gt;();



    @Override

    public StructObjectInspector initialize(StructObjectInspector argOIs) {

        // 定义列表，用于存储输出列名

        List&lt;String&gt; fieldName = new ArrayList&lt;&gt;();

        fieldName.add("strToLine");

        // 定义数据输出的类型

        List&lt;ObjectInspector&gt; fieldType = new ArrayList&lt;&gt;();

        fieldType.add(PrimitiveObjectInspectorFactory.javaStringObjectInspector);

        // 返回

        return ObjectInspectorFactory.getStandardStructObjectInspector(fieldName, fieldType);

    }



    @Override

    public void process(Object[] args) throws HiveException {

        // 获取字符串

        String str = args[0].toString();

        // 判断是否指定了切分符号，如果没有指定，那么默认以-作为切分符号

        String symbol = "-";

        if (args.length &gt; 1) symbol = args[1].toString();

        // 拆分字段

        String[] arr = str.split(symbol);

        // 遍历，写出

        for (String s : arr) {

            // 集合复用

            values.clear();

            // 添加元素

            values.add(s);

            // 推出元素

            forward(values);

        }





    }



    @Override

    public void close() {

    }

}</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">无论是自定义UDF还是自定义UDTF函数，都需要将定义好的程序打成jar包。</p> 
<h4 style="text-align:justify;"><strong><strong><strong>创建函数</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">创建临时函数：</p> 
<p style="margin-left:.0001pt;text-align:justify;">1)将jar包上传到Linux的目录下，例如/opt/hivedata目录。</p> 
<p style="margin-left:.0001pt;text-align:justify;">2)在Hive中指定命令，添加jar包：</p> 
<p>add jar /opt/hivedata/G_Hive-1.0-SNAPSHOT</p> 
<p style="margin-left:.0001pt;text-align:justify;">3)创建临时函数：</p> 
<p>create temporary function indexof as 'com.auth.AuthUDF';</p> 
<p>create temporary function stringToLine as 'com.auth.AuthUDTF';</p> 
<p style="margin-left:.0001pt;text-align:justify;">注意：临时函数只和会话有关。如果当前会话关闭，那么临时函数就会失效，下次连接之后如果想要使用只能重新add和create。</p> 
<p style="margin-left:.0001pt;text-align:justify;">创建永久函数：</p> 
<p style="margin-left:.0001pt;text-align:justify;">1)将jar包上传到HDFS上。</p> 
<p style="margin-left:.0001pt;text-align:justify;">2)创建函数：</p> 
<p>-- UDF函数</p> 
<p>create function indexOf</p> 
<p>    as 'com.auth.AuthUDF'</p> 
<p>    using jar 'hdfs://hadoop01:9000/hive_function/G_Hive-1.0-SNAPSHOT.jar';</p> 
<p>-- UDTF函数</p> 
<p>create function strToLine</p> 
<p>    as 'com.auth.AuthUDTF'</p> 
<p>using jar 'hdfs://hadoop01:9000/hive_function/G_Hive-1.0-SNAPSHOT.jar';</p> 
<p style="margin-left:.0001pt;text-align:justify;">如果需要删除永久函数，那么命令为：</p> 
<p>drop function functionName;</p> 
<h3 style="text-align:justify;"><strong><strong><strong>窗口函数</strong></strong></strong></h3> 
<h4 style="text-align:justify;"><strong><strong><strong>概述</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">窗口函数(over函数)，又叫开窗函数，不同于之前函数的地方在于，它是针对每一行数据进行一次计算返回一个结果。实际过程中，需要灵活运用窗口函数来限定数据的处理范围。</p> 
<p style="margin-left:.0001pt;text-align:justify;">窗口函数的基本语法结构为：</p> 
<p>分析函数() over(partition by 字段 order by 字段 [asc/desc] rows between 起始行 and 结束行)</p> 
<p style="margin-left:.0001pt;text-align:justify;">其中，rows between表示限定数据处理范围，需要用的关键字包含：preceding-向前，following-向后，unbounded-无边界，current row-当前行。例如：</p> 
<p style="margin-left:.0001pt;text-align:justify;">1)2 preceding and current row表示当前行以及前两行。例如当前行为第5行，那么就表示处理3-5行的数据。</p> 
<p style="margin-left:.0001pt;text-align:justify;">2)current row and 2 following表示当前行以及后两行。例如当前行为第5行，那么就表示处理5-7行的数据。</p> 
<p style="margin-left:.0001pt;text-align:justify;">3)unbounded preceding and current row表示从开始处理到当前行。</p> 
<p style="margin-left:.0001pt;text-align:justify;">4)current row and unbounded following表示从当前行开始处理到最后一行。</p> 
<p style="margin-left:.0001pt;text-align:justify;">partition by表示对数据进行分区，order by表示对数据进行排序，asc表示升序，desc表示降序。需要注意的是，如果没有指定partition by，那么就是对数据进行整体排序；如果指定了partition by，那么则表示在每一个分区中对数据进行排序。</p> 
<p style="margin-left:.0001pt;text-align:justify;">分析函数指的是对每一行数据进行处理的函数，可以总结为三大类函数：聚合函数、移位函数和排序函数：</p> 
<p style="margin-left:.0001pt;text-align:justify;">1)聚合函数，对数据进行聚合处理，例如min、max、sum、avg等。</p> 
<p style="margin-left:.0001pt;text-align:justify;">2)移位函数，包含lag、lead和ntile三个。</p> 
<p style="margin-left:.0001pt;text-align:justify;">3)排序函数，包含row_number，rank和dense_rank三个。</p> 
<h4 style="text-align:justify;"><strong><strong><strong>聚合及移位案例</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">有原始数据如下：</p> 
<p>jack,2017-01-01,10</p> 
<p>tony,2017-01-02,15</p> 
<p>jack,2017-02-03,23</p> 
<p>tony,2017-01-04,29</p> 
<p>jack,2017-01-05,46</p> 
<p>jack,2017-04-06,42</p> 
<p>tony,2017-01-07,50</p> 
<p>jack,2017-01-08,55</p> 
<p>mart,2017-04-08,62</p> 
<p>mart,2017-04-09,68</p> 
<p>neil,2017-05-10,12</p> 
<p>mart,2017-04-11,75</p> 
<p>neil,2017-06-12,80</p> 
<p>mart,2017-04-13,94</p> 
<p style="margin-left:.0001pt;text-align:justify;">建表：</p> 
<p>create table orders (</p> 
<p>    name       string, -- 顾客姓名</p> 
<p>    order_date string, -- 消费日期</p> 
<p>    cost       double  -- 消费金额</p> 
<p>) row format delimited fields terminated by ',';</p> 
<p style="margin-left:.0001pt;text-align:justify;">加载数据：</p> 
<p>load data local inpath '/opt/hivedata/orders' into table orders;</p> 
<p style="margin-left:.0001pt;text-align:justify;">需求一：查询每一个顾客的消费明细以及到当前日期为止的总计消费。</p> 
<p>select *,</p> 
<p>sum(cost) over (partition by name order by order_date rows between unbounded preceding and current row ) as total</p> 
<p>from orders;</p> 
<p style="margin-left:.0001pt;text-align:justify;">需求二：查询顾客上一次购买的时间。</p> 
<p>-- lag(col, n)：表示以当前行为基础，处理第前n行。例如当前行为第5行，那么lag(col, 2)就表示处理第三行数据</p> 
<p>-- 上一次的购买时间，那么就是上一行数据</p> 
<p>select name, order_date,</p> 
<p>    lag(order_date, 1) over (partition by name order by order_date) as last_date</p> 
<p>from orders;</p> 
<p style="margin-left:.0001pt;text-align:justify;">需求三：获取最早进店消费的前20%的顾客名单。</p> 
<p>-- ntile(n)：将数据排序之后，平均分发到指定的n个桶中</p> 
<p>-- ntile会给每一个桶进行编号，编号从1开始，之后会将这个编号分发给这个桶中的每一个数据上</p> 
<p>-- 如果数据不能平均分配，则会优先将较小的数据分配到较小的桶中，各个桶之间的行数只差不能超过1个</p> 
<p>-- 获取前20%的数据，就是前1/5的数据，那么只需要将数据排序之后分到5个桶中，然后获取编号为1的桶即可</p> 
<p>select name from (</p> 
<p>  select name, ntile(5) over (order by order_date ) as n from orders</p> 
<p>) tmp where n = 1;</p> 
<h4 style="text-align:justify;"><strong><strong><strong>排序函数案例</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">有原始数据如下：</p> 
<p>Charles Chinese 87</p> 
<p>Charles Math 95</p> 
<p>Charles English 68</p> 
<p>Lily Chinese 94</p> 
<p>Lily Math 56</p> 
<p>Lily English 84</p> 
<p>William Chinese 64</p> 
<p>William Math 86</p> 
<p>William English 84</p> 
<p>Vincent Chinese 65</p> 
<p>Vincent Math 85</p> 
<p>Vincent English 78</p> 
<p style="margin-left:.0001pt;text-align:justify;">建表语句如下：</p> 
<p>create table scores (</p> 
<p>    name    string, -- 姓名</p> 
<p>    subject string, -- 科目</p> 
<p>    score   int     -- 成绩</p> 
<p>) row format delimited fields terminated by '\t';</p> 
<p style="margin-left:.0001pt;text-align:justify;">加载数据：</p> 
<p>load data local inpath '/opt/hivedata/scores' into table scores;</p> 
<p style="margin-left:.0001pt;text-align:justify;">需求一：按照各科成绩对学生进行降序排序。</p> 
<p>-- row_number：顺次编号，不产生空位。即使值一样，编号也是顺次的</p> 
<p>-- rank：顺次编号，产生空位。即值一样，编号相同，但是会跳过后边几个编号</p> 
<p>-- dense_rank：顺次编号，不产生空位。即值一样，编号相同，但是不会跳过编号</p> 
<p>select *,</p> 
<p>       row_number() over (partition by subject order by score desc) as `row_number`,</p> 
<p>       rank() over (partition by subject order by score desc)       as `rank`,</p> 
<p>       dense_rank() over (partition by subject order by score desc) as `dense_rank`</p> 
<p>from scores;</p> 
<p style="margin-left:.0001pt;text-align:justify;">需求二：获取各科考试成绩的前三名同学的姓名、科目和成绩。</p> 
<p>select name, subject, score, n from (</p> 
<p>  select *, rank() over (partition by subject order by score desc) as n from scores</p> 
<p>) tmp where n &lt;= 3;</p> 
<h2 style="text-align:justify;"><strong><strong><strong>其他操作</strong></strong></strong></h2> 
<h3 style="text-align:justify;"><strong><strong><strong>join</strong></strong></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify;">同MySQL类似，Hive也提供了表之间的连接操作，包含内连接inner join，左外连接left join，右外连接right join，全外连接full outer join。同时，Hive中还提供了left semi join。</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/b1/f3/dAkh6RIs_o.png"></p> 
<p style="text-align:center;">图-19 join方式</p> 
<p style="margin-left:.0001pt;text-align:justify;">案例：</p> 
<p>-- 原始数据 - orders.txt</p> 
<p>1001 20170710 4 2</p> 
<p>1002 20170710 3 100</p> 
<p>1003 20170710 2 40</p> 
<p>1004 20170711 2 23</p> 
<p>1005 20170711 4 55</p> 
<p>1006 20170823 3 20</p> 
<p>1007 20170823 2 3</p> 
<p>1008 20170823 4 23</p> 
<p>1009 20170912 2 10</p> 
<p>1010 20170912 2 2</p> 
<p>1011 20170914 3 14</p> 
<p>1012 20170914 3 18</p> 
<p>-- 原始数据 - products.txt</p> 
<p>1 chuizi 3999</p> 
<p>2 huawei 3999</p> 
<p>3 xiaomi 2999</p> 
<p>4 apple 5999</p> 
<p>-- 建立orders表</p> 
<p>drop table if exists orders;</p> 
<p>create table orders (</p> 
<p>    order_id   string, -- 订单号</p> 
<p>    order_date string, -- 订单日期</p> 
<p>    product_id string, -- 商品号</p> 
<p>    num        int     -- 售出数量</p> 
<p>) row format delimited fields terminated by ' ';</p> 
<p>-- 建立products表</p> 
<p>drop table if exists products;</p> 
<p>create table products (</p> 
<p>    product_id   string, -- 商品编号</p> 
<p>    product_name string, -- 商品名</p> 
<p>    price        double  -- 单价</p> 
<p>) row format delimited fields terminated by ' ';</p> 
<p>-- 加载数据</p> 
<p>load data local inpath '/opt/hivedata/orders' into table orders;</p> 
<p>load data local inpath '/opt/hivedata/products' into table products;</p> 
<p>-- 查询数据，确保数据正常加载</p> 
<p>select * from orders tablesample (5 rows);</p> 
<p>select * from products tablesample (5 rows);</p> 
<p>-- 需求一：获取每天卖了多少钱</p> 
<p>select o.order_date as order_date,</p> 
<p>       sum(o.num * p.price) as total</p> 
<p>from orders o join products p on o.product_id = p.product_id</p> 
<p>group by o.order_date;</p> 
<p>-- 需求二：获取哪些商品被卖出去过</p> 
<p>-- a left semi join b：表示a表中哪些数据在b表中出现过</p> 
<p>-- 获取哪些商品被卖出去过，那么就是获取商品表中哪些数据在订单表中出现过</p> 
<p>select p.product_id, p.product_name, p.price</p> 
<p>from products p left semi join orders o on p.product_id = o.product_id;</p> 
<h3 style="text-align:justify;"><strong><strong><strong>h</strong></strong><strong><strong>aving</strong></strong></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify;">having关键字，需要结合group by来使用，对分组之后的聚合结果进行过滤。having和where不同的地方在于：where是直接对已有字段进行查询过滤；having是对聚合函数的结果进行过滤。</p> 
<p style="margin-left:.0001pt;text-align:justify;">案例：获取平均工资超过5000的员工。</p> 
<p>-- 原始数据</p> 
<p>1 Apollo 4900</p> 
<p>1 Billy 5100</p> 
<p>1 Cary 4700</p> 
<p>1 Dylan 5000</p> 
<p>1 Ford 4800</p> 
<p>2 Apollo 5200</p> 
<p>2 Billy 4700</p> 
<p>2 Cary 4900</p> 
<p>2 Dylan 5100</p> 
<p>2 Ford 5000</p> 
<p>3 Apollo 4900</p> 
<p>3 Billy 5200</p> 
<p>3 Cary 4700</p> 
<p>3 Dylan 4600</p> 
<p>3 Ford 5300</p> 
<p>-- 建表</p> 
<p>drop table if exists salaries;</p> 
<p>create table salaris (</p> 
<p>    month  int,    -- 月份</p> 
<p>    name   string, -- 员工姓名</p> 
<p>    salary double  -- 员工薪资</p> 
<p>) row format delimited fields terminated by ' ';</p> 
<p>-- 加载数据</p> 
<p>load data local inpath '/opt/hivedata/salaries' into table salaris;</p> 
<p>-- 查询数据</p> 
<p>select * from salaris tablesample (5 rows);</p> 
<p>-- 需求：查询平均工资超过5000的员工</p> 
<p>select name, avg(salary) as avg_sal from salaris group by name having avg_sal &gt; 5000;</p> 
<h3 style="text-align:justify;"><strong><strong><strong>排序</strong></strong></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify;">在Hive中，针对数据提供了两种排序方式：</p> 
<p style="margin-left:.0001pt;text-align:justify;">1)order by：全局排序。在排序的时候会忽略掉ReduceTask的数量，对所有的数据进行整体的排序，默认是升序排序。</p> 
<p style="margin-left:.0001pt;text-align:justify;">2)sort by：局部排序。这种方式，会在每一个ReduceTask内部对数据进行排序。假设设置了3个ReduceTaks，那么默认情况下，会先根据数据的哈希码，将数据分发到3个ReduceTask中，然后每一个ReduceTask中对数据进行排序，默认是升序排序。</p> 
<p style="margin-left:.0001pt;text-align:justify;">如果只有1个ReduceTask，那么order by和sort by效果相同。</p> 
<p style="margin-left:.0001pt;text-align:justify;">案例演示：</p> 
<p>-- 原始数据</p> 
<p>3 Max 89</p> 
<p>1 Eric 89</p> 
<p>3 Paul 82</p> 
<p>1 Hank 95</p> 
<p>2 Larry 74</p> 
<p>1 Henry 84</p> 
<p>2 Justin 82</p> 
<p>3 Tim 85</p> 
<p>2 ken 84</p> 
<p>1 Ivan 85</p> 
<p>3 Nick 84</p> 
<p>2 Leo 82</p> 
<p>2 Mars 86</p> 
<p>1 Jim 74</p> 
<p>3 Reed 81</p> 
<p>-- 建表</p> 
<p>drop table if exists students;</p> 
<p>create table students (</p> 
<p>    class int,    -- 班级</p> 
<p>    name  string, -- 姓名</p> 
<p>    score int     -- 成绩</p> 
<p>) row format delimited fields terminated by ' ';</p> 
<p>-- 加载数据</p> 
<p>load data local inpath '/opt/hivedata/students' into table students;</p> 
<p>-- 查询数据</p> 
<p>select * from students tablesample (5 rows);</p> 
<p>-- 设置ReduceTask的数量为3</p> 
<p>set mapred.reduce.tasks = 1;</p> 
<p>-- 或者</p> 
<p>set mapreduce.job.reduces = 3;</p> 
<p>-- order by排序</p> 
<p>insert overwrite local directory '/opt/hive_demo/order_by' row format delimited fields terminated by ' '</p> 
<p>select * from students order by score desc;</p> 
<p>-- sort by排序</p> 
<p>insert overwrite local directory '/opt/hive_demo/sort_by' row format delimited fields terminated by ' '</p> 
<p>select * from students sort by score desc;</p> 
<p style="margin-left:.0001pt;text-align:justify;">实际过程中，sort by一般会结合distribute by来使用。distribute by是将数据进行分区(分类)，而sort by是针对每一个分区中的数据进行排序。</p> 
<p>-- 需求：按照班级，在每一个班级内按照学生的成绩降序排序</p> 
<p>insert overwrite local directory '/opt/hive_demo/distribute_by' row format delimited fields terminated by ' '</p> 
<p>select * from students distribute by class sort by score desc;</p> 
<p style="margin-left:.0001pt;text-align:justify;">当distribyte by和sort by字段相同时，可以使用cluster by。不过需要注意的是cluster by只能升序排序，不能降序排序。</p> 
<p>insert overwrite local directory '/opt/hive_demo/cluster_by' row format delimited fields terminated by ' '</p> 
<p>select * from students cluster by score;</p> 
<h3 style="text-align:justify;"><strong><strong><strong>beeline</strong></strong></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify;">beeline是Hive提供的用于进行远程连接的一种方式，本质上底层是使用JDBC的方式来连接Hive。使用beeline的时候需要开启Hive的远程连接服务hiveserver2。</p> 
<p style="margin-left:.0001pt;text-align:justify;">启动beeline的命令如下：</p> 
<p>beeline -u jdbc:hive2://hadoop01:10000/demo -n root</p> 
<p style="margin-left:.0001pt;text-align:justify;">其中，参数-u表示url连接地址，-n表示name连接用户名。</p> 
<h3 style="text-align:justify;"><strong><strong><strong>J</strong></strong><strong><strong>DBC</strong></strong></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify;">Hive支持JDBC操作，语法与MySQL类似：</p> 
<p>import java.sql.*;</p> 
<p></p> 
<p>public class HiveJDBCDemo {<!-- --></p> 
<p></p> 
<p>    public static void main(String[] args) throws ClassNotFoundException, SQLException {<!-- --></p> 
<p>        // 注册驱动</p> 
<p>        Class.forName("org.apache.hive.jdbc.HiveDriver");</p> 
<p>        // 获取连接</p> 
<p>        Connection con = DriverManager.getConnection("jdbc:hive2://hadoop01:10000/demo", "root", "root");</p> 
<p>        // 获取表述</p> 
<p>        Statement stat = con.createStatement();</p> 
<p>        // 执行查询，获取结果集</p> 
<p>        ResultSet set = stat.executeQuery("select * from products");</p> 
<p>        // 遍历结果集</p> 
<p>        while (set.next()) {<!-- --></p> 
<p>            System.out.println(set.getString("product_name"));</p> 
<p>        }</p> 
<p>        // 关闭连接</p> 
<p>        set.close();</p> 
<p>        stat.close();</p> 
<p>        con.close();</p> 
<p>    }</p> 
<p>}</p> 
<h3 style="text-align:justify;"><strong><strong><strong>S</strong></strong><strong><strong>erDe</strong></strong></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify;">SerDe(Serializar/Deserializar)是Hive提供的一套用于对数据进行序列化和反序列化的机制。在使用SerDe的时候，需要指定正则表达式，然后利用正则表达式去解析数据。而正则表达式中的每一个捕获组对应Hive表中的一个字段。</p> 
<p style="margin-left:.0001pt;text-align:justify;">案例：</p> 
<p>-- 原始数据tomcat.log</p> 
<p>192.168.120.23 -- [30/Apr/2018:20:25:32 +0800] "GET /asf.avi HTTP/1.1" 304 -</p> 
<p>192.168.120.23 -- [30/Apr/2018:20:25:32 +0800] "GET /bupper.png HTTP/1.1" 304 -</p> 
<p>192.168.120.23 -- [30/Apr/2018:20:25:32 +0800] "GET /bupper.css HTTP/1.1" 304 -</p> 
<p>192.168.120.23 -- [30/Apr/2018:20:25:33 +0800] "GET /bg-button HTTP/1.1" 304 -</p> 
<p>192.168.120.23 -- [30/Apr/2018:20:25:33 +0800] "GET /bbutton.css HTTP/1.1" 304 -</p> 
<p>192.168.120.23 -- [30/Apr/2018:20:25:33 +0800] "GET /asf.jpg HTTP/1.1" 304 -</p> 
<p>192.168.120.23 -- [30/Apr/2018:20:25:33 +0800] "GET /tomcat.css HTTP/1.1" 304 -</p> 
<p>192.168.120.23 -- [30/Apr/2018:20:25:33 +0800] "GET /tomcat.png HTTP/1.1" 304 -</p> 
<p>192.168.120.23 -- [30/Apr/2018:20:25:33 +0800] "GET /tbutton.png HTTP/1.1" 304 -</p> 
<p>192.168.120.23 -- [30/Apr/2018:20:25:33 +0800] "GET /tinput.png HTTP/1.1" 304 -</p> 
<p>192.168.120.23 -- [30/Apr/2018:20:25:33 +0800] "GET /tbg.css HTTP/1.1" 304 -</p> 
<p>192.168.120.23 -- [30/Apr/2018:20:25:34 +0800] "GET /tomcat.css HTTP/1.1" 304 -</p> 
<p>192.168.120.23 -- [30/Apr/2018:20:25:34 +0800] "GET /bg.css HTTP/1.1" 304 -</p> 
<p>192.168.120.23 -- [30/Apr/2018:20:25:34 +0800] "GET /bg-button.css HTTP/1.1" 304 -</p> 
<p>192.168.120.23 -- [30/Apr/2018:20:25:34 +0800] "GET /bg-input.css HTTP/1.1" 304 -</p> 
<p>192.168.120.23 -- [30/Apr/2018:20:25:34 +0800] "GET /bd-input.png HTTP/1.1" 304 -</p> 
<p>192.168.120.23 -- [30/Apr/2018:20:25:34 +0800] "GET /bg-input.png HTTP/1.1" 304 -</p> 
<p>192.168.120.23 -- [30/Apr/2018:20:25:34 +0800] "GET /music.mp3 HTTP/1.1" 304 -</p> 
<p>-- 方式一：不使用SerDe</p> 
<p>-- 建立临时表</p> 
<p>create table logs_tmp ( log string);</p> 
<p>-- 加载数据</p> 
<p>load data local inpath '/opt/hivedata/tomcat.log' into table logs_tmp;</p> 
<p>-- 查询数据</p> 
<p>select * from logs_tmp tablesample (5 rows);</p> 
<p>-- 建立日志表</p> 
<p>create table logs (</p> 
<p>    host        string, -- 主机名/ip</p> 
<p>    log_date    string, -- 访问日期</p> 
<p>    timezone    string, -- 时区</p> 
<p>    request_way string, -- 请求方式</p> 
<p>    resources   string, -- 请求资源</p> 
<p>    protocol    string, -- 请求协议</p> 
<p>    state_id    int     -- 状态码</p> 
<p>) row format delimited fields terminated by '\t';</p> 
<p>-- 解析数据，放入日志表中</p> 
<p>insert into table logs</p> 
<p>select arr[0], arr[1], arr[2], arr[3], arr[4], arr[5], cast(arr[6] as int) from (</p> 
<p>  select split(regexp_replace(log, '(.*) \-\- \\[(.*) (.*)\\] \"(.*) (.*) (.*)\" ([0-9]+) \-','$1 $2 $3 $4 $5 $6 $7'), ' ') as arr from logs_tmp</p> 
<p>) tmp;</p> 
<p>-- 查询数据</p> 
<p>select * from logs tablesample (5 rows);</p> 
<p>-- 方式二：使用SerDe</p> 
<p>-- 建立日志表</p> 
<p>create table logs2 (</p> 
<p>    host        string, -- 主机名/ip</p> 
<p>    log_date    string, -- 访问日期</p> 
<p>    timezone    string, -- 时区</p> 
<p>    request_way string, -- 请求方式</p> 
<p>    resources   string, -- 请求资源</p> 
<p>    protocol    string, -- 请求协议</p> 
<p>    state_id    int     -- 状态码</p> 
<p>) row format serde 'org.apache.hadoop.hive.serde2.RegexSerDe'</p> 
<p>    with serdeproperties ('input.regex' = '(.*) \-\- \\[(.*) (.*)\\] \"(.*) (.*) (.*)\" ([0-9]+) \-')</p> 
<p>    stored as textfile;</p> 
<p>-- 加载数据</p> 
<p>load data local inpath '/opt/hivedata/tomcat.log' into table logs2;</p> 
<p>-- 查询数据</p> 
<p>select * from logs2 tablesample (5 rows);</p> 
<h3 style="text-align:justify;"><strong><strong><strong>视图</strong></strong></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify;">视图是对原表中部分字段进行抽取，可以看作是原表的一个子表，但是本质上是一个虚拟表。通过视图，可以展现基表中的部分数据。视图可以分为虚拟视图和物化视图，而Hive只支持虚拟视图。</p> 
<p style="margin-left:.0001pt;text-align:justify;">在定义视图的时候，需要封装一个select语句，用于从基表中抽取数据，而封装的这个select语句在创建视图的时候并不执行，而是在第一次使用视图的时候才会真正执行。</p> 
<p style="margin-left:.0001pt;text-align:justify;">视图的优点：</p> 
<p style="margin-left:.0001pt;text-align:justify;">1)简单。使用视图的时候，完全不需要关心视图背后的基表结构、关联条件和筛选条件，对用户而言，视图就是过滤好的符合条件的结果集。</p> 
<p style="margin-left:.0001pt;text-align:justify;">2)安全。使用试图的用户只能访问他们被允许查询的结果集，且视图只能查询不能修改，不影响之后基表数据。</p> 
<p style="margin-left:.0001pt;text-align:justify;">3)数据独立。一旦视图的结构确定，那么就可以屏蔽表结构变化对用户的影响。例如基表中增添列，不会影响视图的操作。</p> 
<p style="margin-left:.0001pt;text-align:justify;">创建视图：</p> 
<p>create view logs_view as select host, log_date, resources from logs order by log_date;</p> 
<p style="margin-left:.0001pt;text-align:justify;">查询视图：</p> 
<p>select * from logs_view;</p> 
<p style="margin-left:.0001pt;text-align:justify;">删除视图：</p> 
<p>drop view logs_view;</p> 
<h2 style="text-align:justify;"><strong><strong><strong>H</strong></strong><strong><strong>ive</strong></strong><strong><strong>存储</strong></strong></strong></h2> 
<h3 style="text-align:justify;"><strong><strong><strong>文件存储格式</strong></strong></strong></h3> 
<h4 style="text-align:justify;"><strong><strong><strong>概述</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">在Hive中，主流的文件存储格式主要是6种：textfile，RCFile，avro，orc，parquet以及sequencefile形式。其中，textfile和sequencefile采用的是行存储形式，orc和parquet采用的是列存储形式。如果不指定，那么Hive默认采用textfile形式将数据落地到HDFS上。</p> 
<h4 style="text-align:justify;"><strong><strong><strong>textfile</strong></strong><strong><strong>格式</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">Hive默认就是以textfile格式落地到HDFS上。默认情况下，textfile不对数据进行压缩，因此占用磁盘空间比较大，在进行数据分析的时候开销也相对较大。</p> 
<p style="margin-left:.0001pt;text-align:justify;">textfile支持Gzip和Bzip2格式的压缩，但是Gzip格式不支持切片，因此使用Gzip格式就无法对数据进行并行操作。</p> 
<h4 style="text-align:justify;"><strong><strong><strong>o</strong></strong><strong><strong>rc</strong></strong><strong><strong>格式</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">orc(Optimized Row Columnar，优化的行列)格式是Hive0.11版本中引入的一种文件格式，是以列存储的方式来存放数据。</p> 
<p style="margin-left:.0001pt;text-align:justify;">每一个orc文件主要由1到多个Stripe，1个File Footer以及1个Postscript构成。每一个Stripe中包含了多条数据，这些数据按照列形式来独立存储。默认情况下，每一个Stripe大小为250M。</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/7b/30/vF3ugDUQ_o.png"></p> 
<p style="text-align:center;">图-20 orc文件</p> 
<p style="margin-left:.0001pt;text-align:justify;">Stripe主要由三部分组成：Index Data，Row Data和Stripe Footer。</p> 
<p style="margin-left:.0001pt;text-align:justify;">1)Index Data：轻量级的索引结构，默认是每10000行数据形成一次索引，会记录每一列的最小值、最大值以及每一列中的行索引。如果指定，还可能包含位域或者是布隆过滤器。 </p> 
<p style="margin-left:.0001pt;text-align:justify;">2)Row Data：存储数据。在存储的时候，先取部分行，然后将每一行数据的字段拆分之后以列形式存储。在存储的时候，会对每一个列进行编码，封装成一个个的Stream结构来存储。因为同一个列中的字段类型是一致的，所以可以更好的采用压缩机制来进行压缩。</p> 
<p style="margin-left:.0001pt;text-align:justify;">3)Stripe Footer：存储每一个Stream的类型、长度等信息，实际上就是记录每一列的数据类型、存储的数据的大小等信息。</p> 
<p style="margin-left:.0001pt;text-align:justify;">每一个文件尾部都会有一个File Footer，用于记录每一个Stripe中的行数，每一个列的数据类型信息。File Footer中还包含列级别的聚合结果，包含count、min、max、sum。</p> 
<p style="margin-left:.0001pt;text-align:justify;">每一个文件末尾都是一个Postscript，这里面记录了整个文件的信息，例如文件是否压缩，压缩算法等信息，还记录了File Footer在orc文件中的其实位置。因此，在读取orc文件的时候，需要先读取文件末尾的Postscript，获取到File Footer在文件中的存储位置，然后再读取File Footer，获取到Stripe所在的偏移量(文件中的存储位置)，之后读取Stripe中的Index Data，锁定数据在Row Data中的位置，最后读取Row Data中的数。</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/00/08/bFWPFz6l_o.png"></p> 
<p style="text-align:center;">图-21 orc解析</p> 
<h4 style="text-align:justify;"><strong><strong><strong>p</strong></strong><strong><strong>arquet</strong></strong><strong><strong>格式</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">parquet格式是从Hive0.10开始提供的一种文件格式，本身是一种二进制形式的文件，所以不能直接读取。parquet文件中包含了数据以及描述数据的元数据，所以parquet文件是自解析文件。</p> 
<p style="margin-left:.0001pt;text-align:justify;">每一个parquet文件会包含四部分：1个Magic Code(魔数编码)，1个Footer Length，1个Metastore，以及包含1个到多个行组(Row Group)。</p> 
<p style="margin-left:.0001pt;text-align:justify;">其中，Magic Code用于确保当前文件是一个parquet文件；Footer Length记录了元数据的大小，通过这个值以及文件的大小可以计算出元数据在文件中的偏移量；Metastore是元数据，记录了当前parquet文件的文件信息，例如文件大小，Row Group的数量等。</p> 
<p style="margin-left:.0001pt;text-align:justify;">Row Group是将数据从行方向上进行的物理切分。默认情况下，每一个Row Group和HDFS的Block是等大的。</p> 
<p style="margin-left:.0001pt;text-align:justify;">每一个Row Group中包含一个到多个列块(Column Chunk)。列块是将数据按照列形式进行存储，每一列对应一个列块，因此每一个列块中数据的类型是相同的，不同列块之间可以使用不同的压缩算法。列块之间是连续存储在这个行组中的。</p> 
<p style="margin-left:.0001pt;text-align:justify;">每一个Column Chunk中会包含一个到多个页(Page)，Page是parquet文件中数据存储的最小单元，同一个列块的不同页可以使用不同的编码方式。</p> 
<p style="margin-left:.0001pt;text-align:justify;">Page分为三种：数据页，字典页和索引页。</p> 
<p style="margin-left:.0001pt;text-align:justify;">1)数据页用于存储当前列块中的数据；</p> 
<p style="margin-left:.0001pt;text-align:justify;">2)字典页用于存储编码信息；</p> 
<p style="margin-left:.0001pt;text-align:justify;">3)索引页用于存储数据在文件中偏移位置。每一个列块中最多只有一个字典页。</p> 
<p style="margin-left:.0001pt;text-align:justify;">需要注意的是，Hive原生生成的parquet文件中不支持索引页。</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/04/ed/0ARt2Y5l_o.png"></p> 
<p style="text-align:center;">图-22 parquet文件格式</p> 
<h3 style="text-align:justify;"><strong><strong><strong>H</strong></strong><strong><strong>ive压缩</strong></strong></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify;">Hive支持对输出的数据进行压缩，根据文件格式不同，支持的压缩算法不同。其中，比较常用的是orc格式的文件压缩和parquet格式的文件压缩。</p> 
<p style="margin-left:.0001pt;text-align:justify;">如果想要对orc格式的文件进行压缩，可以通过orc.compress属性进行配置，可以配置的属性值包含NONE，ZLIB，SNAPPY。其中NONE表示不压缩。</p> 
<p style="margin-left:.0001pt;text-align:justify;">创建一个表，文件格式为orc格式，压缩格式为zlib：</p> 
<p>create table orc_zlib (id int, name string)</p> 
<p>row format delimited fields terminated by ' '</p> 
<p>stored as orc tblproperties ("orc.compress" = "ZLIB");</p> 
<p style="margin-left:.0001pt;text-align:justify;">创建一个表，文件格式为orc格式，压缩格式为snappy：</p> 
<p>create table orc_snappy(id int, name string)</p> 
<p>row format delimited fields terminated by ' '</p> 
<p>stored as orc tblproperties ("orc.compress" = "SNAPPY");</p> 
<p style="margin-left:.0001pt;text-align:justify;">如果想要对parquet格式的文件进行压缩，可以通过属性parquet.compression进行配置，经常使用的是SNAPPY。</p> 
<p>create table parquet_snappy ( id int, name string)</p> 
<p>row format delimited fields terminated by ' '</p> 
<p>stored as parquet tblproperties ("parquet.compression" = "SNAPPY");</p> 
<h2 style="text-align:justify;"><strong><strong><strong>Hive</strong></strong><strong><strong>结构及优化</strong></strong></strong></h2> 
<h3 style="text-align:justify;"><strong><strong><strong>结构</strong></strong></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify;">Hive结构如下图：</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/02/c1/4opeQz2i_o.png"></p> 
<p style="text-align:center;">图-23 Hive结构</p> 
<p style="margin-left:.0001pt;text-align:justify;">1)Client Interface主要分为两种：CLI(command-line interface，命令行方式)和JDBC/ODBC(beeline采用的就是JDBC方式)。</p> 
<p style="margin-left:.0001pt;text-align:justify;">2)Metastore：用于存储元数据，维系在关系型数据库中，默认是Derby，实际过程中一般是使用MySQL。</p> 
<p style="margin-left:.0001pt;text-align:justify;">3)Driver：驱动器，包含了四部分。SQL Parser(SQL解析器)会查询元数据，确认SQL语法是否正确，然后将SQL转化为抽象语法树AST。Physical Plan(编译器)会将抽象语法树AST编译生成要执行的逻辑执行计划。Query Optimizer(优化器)对逻辑计划进行优化。Execution(执行器)负责将逻辑计划转化为要实际执行的物理计划，例如MapReduce程序。</p> 
<h3 style="text-align:justify;"><strong><strong><strong>优化</strong></strong></strong></h3> 
<h4 style="text-align:justify;"><strong><strong><strong>列裁剪或者分区裁剪</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">在生产环境中，经常要处理大量数据，而此时如果使用select * from tableName的形式，会对整个表进行扫描，数据量越大效率月底。所以在实际过程中查询数据的时候，最好指定列或者指定分区；如果是按行查询，最好限定行数，例如使用limit或者tablesample(x rows)形式。</p> 
<h4 style="text-align:justify;"><strong><strong><strong>group </strong></strong><strong><strong>by优化</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">在Hive中进行group by的时候，会将相同的key对应的值分发给同一个ReduceTask处理。此时如果某一个key对应的数据格外多，那么就会造成整个ReduceTaks效率较低，从而产生了数据倾斜。针对这个问题，有两种优化方式：map端聚合以及二阶段聚合(负载均衡机制)。</p> 
<p style="margin-left:.0001pt;text-align:justify;">map端聚合，顾名思义，就是先将数据在Map端经过一次聚合计算，再将聚合结果发送给Reduce端处理。</p> 
<p>-- 开启聚合机制</p> 
<p>set hive.map.aggr = true;</p> 
<p>-- 指定聚合条数</p> 
<p>set hive.groupby.mapaggr.checkinterval = 10000;</p> 
<p style="margin-left:.0001pt;text-align:justify;">二阶段聚合(负载均衡模式)，顾名思义，是将Hive的执行过程拆分成两个MapReduce任务来执行：第一个MapReduce Job负责将数据大三，此时相同的键可以不会分布到同一个ReduceTask上，然后每一个ReduceTask对结果进行聚合；之后第二个MapReduce Job再读取上一次的聚合结果，按照指定分组处理数据，此时相同的键才会分不到同一个ReduceTask上。</p> 
<p>-- 开启二阶段聚合</p> 
<p>set hive.groupby.skewindata = true;</p> 
<h4 style="text-align:justify;"><strong><strong><strong>CBO</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">从Hive0.1.0开始，加入了CBO(Cost based Optimizer，基于成本的优化器)来对SQL执行计划进行优化。从Hive1.1.0版本开始，CBO默认是开启的，可以通过属性hive.cbo.enable来调节。</p> 
<p style="margin-left:.0001pt;text-align:justify;">CBO，成本优化器，遵循的原则是：代价最小的执行计划就是最好的执行计划。在任务最终执行之前，CBO会优化每一个查询的执行逻辑和物理执行计划，在底层会根据查询成本执行优化，自动优化SQL中多个join的执行顺序，并选择合适的join算法。</p> 
<h4 style="text-align:justify;"><strong><strong><strong>谓词下推</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">所谓谓词下推，指的是在保证结果正确的前提下，将SQL语句中的where过滤(过滤条件就是谓词)尽可能的提前执行，以此来减少下游处理的数据量。通过谓词下推，过滤条件将在Map端提前执行，减少了Map端的输出，降低了数据的IO，从而提升了性能。</p> 
<p>-- 开启谓词下推</p> 
<p>-- 此选项默认为true，ppd全称为PredicatePushDown，预测/谓词下推</p> 
<p>set hive.optimize.ppd = true;</p> 
<h4 style="text-align:justify;"><strong><strong><strong>M</strong></strong><strong><strong>ap join</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">Map join，指的是在两个表或者多个表进行join的时候，将较小的表直接分发到各个MapTask所在节点的内存中，在MapTask中进行join，从而避免了Reduce端的join操作。如果不指定Map join或者不符合Map join的条件，那么Hive解析器会将Join操作转化为Common Join(普通join)，然后在Reduce端完成join，那么此时容易产生数据倾斜。</p> 
<p>-- 开启map side join。Hive3.X中，这个属性默认为true</p> 
<p>set hive.auto.convert.join = true;</p> 
<p>-- 设置小表阈值，默认为25M</p> 
<p>set hive.mapjoin.smalltable.filesize = 25000000</p> 
<h4 style="text-align:justify;"><strong><strong><strong>SMB</strong></strong><strong><strong> join</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">SMB(sort merge bucket) join，是基于分桶机制和Map join实现的一种join方式，旨在用于解决大表和大表之间的join问题。当A表和B表都比较大的时候，那么此时两个表进行join，那么需要计算的数据量就会较大，相对效率较低，此时可以采用SMB join。</p> 
<p style="margin-left:.0001pt;text-align:justify;">SMB join本质上就是将数据分到多个桶中，那么此时每一个桶就相当于是一个小表，那么在join的时候就是小表和大表的join，可以采用map join方式，所以本质上就是一种"分而治之"的思想。</p> 
<p style="margin-left:.0001pt;text-align:justify;">SMB join的使用必须符合两个条件：</p> 
<p style="margin-left:.0001pt;text-align:justify;">1)A表和B表必须是分桶表，且B表的桶数必须是A表桶数的整数倍。例如A表分了6个桶，那么B表的桶数必须是6n(n≥1)。</p> 
<p style="margin-left:.0001pt;text-align:justify;">2)分桶条件和join条件必须一致。即对于select * from a join b on a.id = b.pid而言，由于join条件是a.id和b.pid，所以此时要求A表必须根据id字段分桶，B表必须根据pid字段分桶，根据其他字段分桶无效。</p> 
<p style="margin-left:.0001pt;text-align:justify;">SMB join相关参数：</p> 
<p>-- 开启SMB join</p> 
<p>set hive.optimize.bucketmapjoin = true;</p> 
<p>set hive.optimize.bucketmapjoin.sortedmerge = true;</p> 
<p>set hive.input.format = org.apache.hadoop.hive.ql.io.BucketizedHiveInputFormat;</p> 
<h4 style="text-align:justify;"><strong><strong><strong>启用严格模式</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">将hive.strict.checks.no.partition.filter设置为true之后，对于分区表，除非where语句中含有分区字段过滤条件来限制范围，否则不允许执行。换句话说，就是用户不允许扫描所有分区。进行这个限制的原因是，通常分区表都拥有非常大的数据集，而且数据增加迅速。没有进行分区限制的查询可能会消耗令人不可接受的巨大资源来处理这个表。</p> 
<p style="margin-left:.0001pt;text-align:justify;">将hive.strict.checks.orderby.no.limit设置为true时，对于使用了order by语句的查询，要求必须使用limit语句。因为order by为了执行排序过程会将所有的结果数据分发到同一个Reducer中进行处理，强制要求用户增加这个LIMIT语句可以防止Reducer额外执行很长一段时间。</p> 
<p style="margin-left:.0001pt;text-align:justify;">将hive.strict.checks.cartesian.product设置为true时，会限制笛卡尔积的查询。对关系型数据库非常了解的用户可能期望在执行JOIN查询的时候不使用ON语句而是使用where语句，这样关系数据库的执行优化器就可以高效地将WHERE语句转化成那个ON语句。不幸的是，Hive并不会执行这种优化，因此，如果表足够大，那么这个查询就会出现不可控的情况。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5d49e38faa794c0b719ffa4f2837004a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据库SqSever2022在windows10系统的安装与卸载</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/43615494f7a822902d50fa862f94c0f0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Java虚拟线程】Java21、SpringBoot3中使用虚拟线程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>