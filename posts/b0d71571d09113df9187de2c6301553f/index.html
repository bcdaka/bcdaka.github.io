<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【动态规划】子数组系列二（数组中连续的一段） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b0d71571d09113df9187de2c6301553f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【动态规划】子数组系列二（数组中连续的一段）">
  <meta property="og:description" content="子数组系列一（数组中连续的一段） 1.等差数列划分2.最长湍流子数组3.单词拆分4.环绕字符串中唯一的子字符串 点赞👍👍收藏🌟🌟关注💖💖
你的支持是对我最大的鼓励，我们一起努力吧!😃😃
1.等差数列划分 题目链接： 413. 等差数列划分
题目分析：
如果一个数列 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该数列为等差数列。返回数组 nums 中所有为等差数组的 子数组 个数。
算法原理：
1.状态表示
经验 &#43; 题目要求
以 i 位置为结尾，巴拉巴拉。
题目要求，求数组中为等差数组的子数组个数，也就是子数组中有多少个等差数列
dp[i] 表示：以 i 位置元素为结尾的所有子数组中有多少个等差数列。
2.状态转移方程
如果[a, b, c, d]已经构成一个等差数列，d后面在加一个e，与c、d、e构成等差数列，[a, b, c, d, e]也是构成等差数列。
dp[i] 表示：以 i 位置元素为结尾的所有子数组中有多少个等差数列。子数组要求是连续的，所以求 i 位置，要先去看 i -1 和 i - 2 的位置。
i - 2 位置元素设为a，i - 1 位置元素设为b、i 位置元素设为c
先考虑a、b、c是否构成一个等差数列。
如果abc能构成一个等差数列，那就是以ab为结尾的等差数列后面在加一个c，这些数列也是构成一个等差数列，以ab为结尾就相当于以b为结尾，以b为结尾的等差数列，就在dp[i-1]存着。别忘记 abc也能构成一个等差数列。
abc不能构成一个等差数列，即使a前面能构成等差数列，但是与 i 位置不连续，因此就构不成以 i 位置为结尾的等差数列
3.初始化
这里我们可以直接把dp[0] = dp[1] = 0">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-09-02T10:43:16+08:00">
    <meta property="article:modified_time" content="2024-09-02T10:43:16+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【动态规划】子数组系列二（数组中连续的一段）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>子数组系列一（数组中连续的一段）</h4> 
 <ul><li><a href="#1_7" rel="nofollow">1.等差数列划分</a></li><li><a href="#2_84" rel="nofollow">2.最长湍流子数组</a></li><li><a href="#3_193" rel="nofollow">3.单词拆分</a></li><li><a href="#4_283" rel="nofollow">4.环绕字符串中唯一的子字符串</a></li></ul> 
</div> 
<p></p> 
<p><img src="https://images2.imgbox.com/11/b6/Apb78mAf_o.jpg" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>点赞</strong>👍👍<strong>收藏</strong>🌟🌟<strong>关注</strong>💖💖<br> <font color="red"><strong>你的支持是对我最大的鼓励，我们一起努力吧!😃😃</strong></font></p> 
</blockquote> 
<h2><a id="1_7"></a>1.等差数列划分</h2> 
<p><strong>题目链接：</strong> <a href="https://leetcode.cn/problems/arithmetic-slices/description/" rel="nofollow">413. 等差数列划分</a></p> 
<p><strong>题目分析：</strong></p> 
<p><img src="https://images2.imgbox.com/9e/d7/mKsetuCC_o.png" alt="在这里插入图片描述"></p> 
<p>如果一个数列 <strong>至少有三个元素</strong> ，并且任意两个相邻元素之差相同，则称该数列为等差数列。返回数组 nums 中所有为等差数组的 子数组 个数。</p> 
<p><img src="https://images2.imgbox.com/da/c5/4dRgMkJj_o.png" alt="在这里插入图片描述"></p> 
<p><strong>算法原理：</strong></p> 
<blockquote> 
 <p>1.状态表示</p> 
</blockquote> 
<p>经验 + 题目要求</p> 
<p>以 i 位置为结尾，巴拉巴拉。<br> 题目要求，求数组中为等差数组的子数组个数，也就是子数组中有多少个等差数列</p> 
<p>dp[i] 表示：以 i 位置元素为结尾的所有子数组中有多少个等差数列。</p> 
<blockquote> 
 <p>2.状态转移方程</p> 
</blockquote> 
<p>如果[a, b, c, d]已经构成一个等差数列，d后面在加一个e，与c、d、e构成等差数列，[a, b, c, d, e]也是构成等差数列。</p> 
<p>dp[i] 表示：以 i 位置元素为结尾的所有子数组中有多少个等差数列。子数组要求是连续的，所以求 i 位置，要先去看 i -1 和 i - 2 的位置。</p> 
<p>i - 2 位置元素设为a，i - 1 位置元素设为b、i 位置元素设为c</p> 
<p>先考虑a、b、c是否构成一个等差数列。</p> 
<p>如果abc能构成一个等差数列，那就是以ab为结尾的等差数列后面在加一个c，这些数列也是构成一个等差数列，以ab为结尾就相当于以b为结尾，以b为结尾的等差数列，就在dp[i-1]存着。别忘记 abc也能构成一个等差数列。</p> 
<p><img src="https://images2.imgbox.com/b7/60/31Cnq7ZQ_o.png" alt="在这里插入图片描述"><br> abc不能构成一个等差数列，即使a前面能构成等差数列，但是与 i 位置不连续，因此就构不成以 i 位置为结尾的等差数列</p> 
<p><img src="https://images2.imgbox.com/41/9c/U691Xqvi_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>3.初始化</p> 
</blockquote> 
<p>这里我们可以直接把dp[0] = dp[1] = 0</p> 
<blockquote> 
 <p>4.填表顺序</p> 
</blockquote> 
<p>从左往右</p> 
<blockquote> 
 <p>5.返回值</p> 
</blockquote> 
<p>注意并不是返回最后一个位置，题目要求找的是所有等差数列的个数，因此我们返回的是dp表所有元素的和。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">numberOfArithmeticSlices</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 1.创建 dp 表</span>
        <span class="token comment">// 2.初始化</span>
        <span class="token comment">// 3.填表</span>
        <span class="token comment">// 4.返回值</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">?</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> dp<span class="token punctuation">)</span>
            ret <span class="token operator">+=</span> e<span class="token punctuation">;</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="2_84"></a>2.最长湍流子数组</h2> 
<p><strong>题目链接：</strong> <a href="https://leetcode.cn/problems/longest-turbulent-subarray/description/" rel="nofollow">978. 最长湍流子数组</a></p> 
<p><strong>题目分析：</strong></p> 
<p><img src="https://images2.imgbox.com/b3/59/8SVYl9gh_o.png" alt="在这里插入图片描述"></p> 
<p>给定一个整数数组 arr ，返回 arr 的 最大湍流子数组的长度 。</p> 
<p>如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是 湍流子数组 。</p> 
<p>湍流子数组到底什么东西，我们举个例子，比如说下面，元素大小呈现一升一降的趋势这就是湍流数组。那就称这个数组是湍流子数组。</p> 
<p><img src="https://images2.imgbox.com/1f/0e/23jV80vv_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/9b/e8/MKSXUN5Q_o.png" alt="在这里插入图片描述"><br> <strong>算法原理：</strong></p> 
<blockquote> 
 <p>1.状态表示</p> 
</blockquote> 
<p>经验 + 题目要求</p> 
<p>以 i 位置为结尾，巴拉巴拉</p> 
<p>要求找子数组中最大湍流长度。</p> 
<p>dp[i] 表示：以 i 位置元素为结束的所有子数组中，最大湍流数组的长度</p> 
<p><img src="https://images2.imgbox.com/83/7d/yusekJs3_o.png" alt="在这里插入图片描述"></p> 
<p>根据最近的一步分析问题，设 i - 1 位置元素为 a，i 位置元素为 b。此时会有三种情况。</p> 
<p>a &gt; b i位置最后呈现下降趋势<br> a &lt; b i位置最后呈现上升趋势<br> a == b i位置最呈现平稳趋势</p> 
<p>a &gt; b i位置最后呈现下降趋势，我们是不是要找到以 i - 1 位置为结尾呈现升序趋势的湍流数组啊。</p> 
<p>但是我们的状态表示只是表示 以 i 位置元素为结束的所有子数组中，最大湍流数组的长度，并没有分是上升趋势还是下降趋势。因此一个状态表示不能满足现在的情况。所以我们要换状态表示。</p> 
<p><img src="https://images2.imgbox.com/ab/e0/1l0Hgdev_o.png" alt="在这里插入图片描述"></p> 
<p>f[i] 表示：以 i 位置元素为结尾的所有子数组中，最后呈现 “上升” 状态下的最长湍流数组的长度</p> 
<p>g[i] 表示：以 i 位置元素为结尾的所有子数组中，最后呈现 “下降” 状态下的最长湍流数组的长度</p> 
<p><img src="https://images2.imgbox.com/19/b3/XkGz20s7_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>2.状态转移方程</p> 
</blockquote> 
<p>先来分析f表，<br> 当a &gt; b i 位置最后呈现下降趋势，但是f表要的是 i 位置最后呈现上升趋势，别忘记本身也可以是湍流子数组，因此是1</p> 
<p>当a &lt; b i 位置最后呈现上升趋势，去 i - 1位置找到以 i - 1位置为结尾最后呈现下降趋势的最长湍流数组的长度这个就在 g[i - 1]存着，最后别忘记加上1</p> 
<p>当 a == b，本身也可以是湍流子数组，因此是1</p> 
<p>g表分析和f表分析一样，可以自己试着分析一下。</p> 
<p>当a &gt; b i 位置最后呈现下降趋势，去 i - 1位置找到以 i - 1位置为结尾最后呈现上升趋势的最长湍流数组的长度这个就在 f[i - 1]存着，最后别忘记加上1</p> 
<p>当a &lt; b i 位置最后呈现上升趋势，但是g表要的是 i 位置最后呈现下降趋势，别忘记本身也可以是湍流子数组，因此是1</p> 
<p>当 a == b，本身也可以是湍流子数组，因此是1</p> 
<p><img src="https://images2.imgbox.com/8f/17/MtNYv7Il_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>3.初始化</p> 
</blockquote> 
<p>填第一个位置会越界，可以把第一个位置初始化，注意本身也可以是湍流子数组，因此第一个位置可以初始化为1，不过这里我们可以把数组初始化都为1，这样的话<br> f表 a &gt; b 和 a == b ，g表 a &lt; b 和 a == b，填表的时候就不用考虑了，反正f[i]和g[i]都已经初始化为1了。</p> 
<p><img src="https://images2.imgbox.com/8d/9e/VgnVqJ7C_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>4.填表顺序</p> 
</blockquote> 
<p>从左往右，两个表一起填</p> 
<blockquote> 
 <p>5.返回值</p> 
</blockquote> 
<p>我们要的是子数组中最大湍流数组的长度，因此是找两个表里面的最大值。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">maxTurbulenceSize</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 1.创建 dp 表</span>
        <span class="token comment">// 2.初始化</span>
        <span class="token comment">// 3.填表</span>
        <span class="token comment">// 4.返回值</span>

        <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">g</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> g<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> g<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> 
            ret <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span> <span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>g<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="3_193"></a>3.单词拆分</h2> 
<p><strong>题目链接：</strong> <a href="https://leetcode.cn/problems/word-break/description/" rel="nofollow">139. 单词拆分</a></p> 
<p><strong>题目描述：</strong></p> 
<p><img src="https://images2.imgbox.com/57/68/SMlL9xjy_o.png" alt="在这里插入图片描述"></p> 
<p><strong>算法原理：</strong></p> 
<blockquote> 
 <p>1.状态表示</p> 
</blockquote> 
<p>经验 + 题目要求</p> 
<p>以 i 位置为结尾，巴拉巴拉<br> 题目要求看字符串能否被字典中单词拼接而成</p> 
<p>dp[i] 表示：[0,i] 区间内的字符串，能否被字典中的单词拼接而成</p> 
<blockquote> 
 <p>2.状态转移方程</p> 
</blockquote> 
<p>根据最近一个位置的情况，来划分问题</p> 
<p>i的位置是最后一个单词的位置，那最后一个单词是什么样子呢？可能本身就是最后一个单词，或者往前几位然后和 i 位置组成一个单词。又或者前面所有位置构成最后一个单词。这样划分可以把0-i位置字符串划分成两部分，前面部分字符串+后面的单词。</p> 
<p><strong>如果我们能确定前面部分字符串能够拼接而成并且后面的单词在字典中</strong>，那 0 - i 位置字符串肯定能被拼接而成。</p> 
<p>但是我们并不知道最后一个单词起始下标在哪里，因此<strong>设一个 j 为最后一个单词的起始位置下标</strong>。（0 &lt;= j &lt;= i)</p> 
<p>所以我们的状态转移方程就有了</p> 
<p><img src="https://images2.imgbox.com/13/3a/Um91BnGz_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>3.初始化</p> 
</blockquote> 
<p>填第一个位置，dp[j -1]会越界，因此多开一个空间</p> 
<ol><li>虚拟节点里面的值要保证后序填表正确</li><li>下标的映射关系</li></ol> 
<p>虚拟节点如果给false，整个表不管字符串是什么样子都是false，因此给true。</p> 
<p>下标的映射关系，对于普通数据我们都是下标减一然后才能找到原数组，但是<strong>字符串这里有特殊技巧，可以把原始字符前面多加一个辅助字符 ‘ ’ 如 s = ’ ’ + s， 那原始字符串有效字符是不是从下标1开始了，正好就和多开一个空间的dp对应起来了。</strong> 因为字符串涉及找子串的问题，如果不这样搞，找子串非常头疼，因为下标都不对应了。</p> 
<p><img src="https://images2.imgbox.com/5d/39/j3oL7Nhj_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>4.填表顺序</p> 
</blockquote> 
<p>从左往右</p> 
<blockquote> 
 <p>5.返回值</p> 
</blockquote> 
<p>看整个字符串能否被拼接成功，所以返回dp表最后一个位置，dp[i]</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">bool</span> <span class="token function">wordBreak</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token operator">&amp;</span> wordDict<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 1.创建 dp 表</span>
        <span class="token comment">// 2.初始化</span>
        <span class="token comment">// 3.填表</span>
        <span class="token comment">// 4.返回值</span>

        <span class="token comment">//优化</span>
        unordered_set<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> us<span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> str <span class="token operator">:</span> wordDict<span class="token punctuation">)</span>
            us<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">//保证后序填表是正确的</span>
        s <span class="token operator">=</span> <span class="token char">' '</span> <span class="token operator">+</span> s<span class="token punctuation">;</span> <span class="token comment">//使原始字符串的下标统一+1,和填表顺序下标一样</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> us<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> i <span class="token operator">-</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">{<!-- --></span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="4_283"></a>4.环绕字符串中唯一的子字符串</h2> 
<p><strong>题目链接：</strong> <a href="https://leetcode.cn/problems/unique-substrings-in-wraparound-string/description/" rel="nofollow">467. 环绕字符串中唯一的子字符串<br> </a></p> 
<p><strong>题目分析：</strong></p> 
<p><img src="https://images2.imgbox.com/bf/d6/ok1TjjNd_o.png" alt="在这里插入图片描述"></p> 
<p>给一个字符串s，返回字符串s中有多少非空子串在 base 中出现。</p> 
<p>注意最后结果是去重的！</p> 
<p><img src="https://images2.imgbox.com/a5/76/pOYZ7bJ6_o.png" alt="在这里插入图片描述"></p> 
<p><strong>算法原理：</strong></p> 
<blockquote> 
 <p>1.状态表示</p> 
</blockquote> 
<p>经验 + 题目要求</p> 
<p>以 i 位置为结尾，巴拉巴拉。</p> 
<p>题目要求返回字符串s中有多少非空子串在 base 中出现。<br> 以 i 位置为结尾我要先确定 以 i 位置为结尾的所有子串，要么是自己本身，要么就是和前面位置形成的子串，接下来找多少个在base中出现。所以状态表示：</p> 
<p><img src="https://images2.imgbox.com/b9/74/rMnE7qZx_o.png" alt="在这里插入图片描述"></p> 
<p>dp[i] 表示：以 i 位置元素为结尾的所有子串里面，有多少个在base中出现</p> 
<blockquote> 
 <p>2.状态转移方程</p> 
</blockquote> 
<p>单独本身就是一个子串，和前面元素结合构成子串。所以dp[i]也分这两种情况：</p> 
<p>长度为1，长度大于1</p> 
<p>长度为1，在base出现一次</p> 
<p>长度大于1，前面元素都有一个共同点，都是以 i - 1 位置元素为结尾形成的子串，那我先找到以 i - 1 位置元素为结尾所有子串在base中出现的次数，然后在加上 i 位置元素构成的子串，看新的子串在base中出现的次数不就可以了吗。而dp[i-1] 就是以 i - 1位置元素为结尾所有子串在base中出现的次数。然后如果 i 位置元素s[i - 1] == s[i] || (s[i - 1] == z &amp;&amp; s[i] ==a)说明长度大于1以 i 位置结束的字符串也在base出现了，出现次数是dp[i - 1]，不能在后面 + 1！前面出现次数加上i位置这个字符次数还是一样的。</p> 
<p><img src="https://images2.imgbox.com/bd/cb/U9nIB8VY_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>3.初始化</p> 
</blockquote> 
<p>我们可以把dp表里面的值都初始化为1，首先本身肯定子串。其次初始化为1的话，上面dp表长度为1 填表时就不要在考虑了，只需要看是否满足长度为1的条件就行了。</p> 
<p><img src="https://images2.imgbox.com/5f/99/ZhrV8RTs_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>4.填表顺序</p> 
</blockquote> 
<p>从左往右</p> 
<blockquote> 
 <p>5.返回值</p> 
</blockquote> 
<p>题目要求返回s 中有多少 不同非空子串 也在 base 中出现次数，<br> 而dp[i] 表示：以 i 位置元素为结尾的所有子串里面，有多少个在base中出现。<br> 因此返回 dp 表里面所有元素的和。</p> 
<p>但是这样并不对！</p> 
<p>我们初始化为1之后，这个例子我们最终返回的是3，但是答案最终是2，是去过重的。</p> 
<p><img src="https://images2.imgbox.com/68/b7/LRMGv9vX_o.png" alt="在这里插入图片描述"></p> 
<p>思考一下如何去重？相同子串只统计一次！</p> 
<p>看下面例子，两个字符串都是以c为结尾，dp表里面存的值，肯定是短的子串小，长的子串大。并且长的子串包含了短的子串的，因此长的子串里面统计的次数也包含了短的子串，因此当相同字符结尾的dp表里面的值较大的累加上，较小的直接舍去因为里面全都是重复的。</p> 
<p>如何保证相同字符结尾的 dp 值，我们取最大的呢？</p> 
<ol><li>创建一个大小为 26 的数组</li><li>里面的的值保存相应字符结尾的最大 dp 值即可</li></ol> 
<p>最后返回数组里面的和</p> 
<p><img src="https://images2.imgbox.com/70/c8/Qm5PJR6k_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">findSubstringInWraproundString</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 1.创建 dp 表</span>
        <span class="token comment">// 2.初始化</span>
        <span class="token comment">// 3.填表</span>
        <span class="token comment">// 4.返回值</span>

        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'z'</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        

        <span class="token keyword">int</span> hash<span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            hash<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>hash<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> hash<span class="token punctuation">)</span> 
            sum <span class="token operator">+=</span> x<span class="token punctuation">;</span>
        
        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c65ee48bf653e4a3e5bcd1d354cc7c67/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">GO 下载依赖改成国内代理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/40e3f8231f7c7bcb30604e778b74e0be/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【高阶数据结构】B树、B&#43;树、B*树</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>