<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;庖丁解牛】哈希表/散列表的设计原理 | 哈希函数 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/ecfbf37fb24204c7df9956965a2761fd/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;庖丁解牛】哈希表/散列表的设计原理 | 哈希函数">
  <meta property="og:description" content="🍁你好，我是 RO-BERRY 📗 致力于C、C&#43;&#43;、数据结构、TCP/IP、数据库等等一系列知识 🎄感谢你的陪伴与支持 ，故事既有了开头，就要画上一个完美的句号，让我们一起加油 目录 前言1.哈希概念2.哈希冲突3.哈希函数4.哈希冲突解决4.1闭散列4.2 开散列 前言 unordered系列的关联式容器之所以效率比较高，是因为其底层使用了哈希结构。
1.哈希概念 哈希又称为散列，有些书上对于哈希取名为散列表，其本质就是一个存储的值和存储的位置的映射
顺序结构以及平衡树中，元素关键码与其存储位置之间没有对应的关系，因此在查找一个元素时，必须要经过关键码的多次比较。顺序查找时间复杂度为O(N)，平衡树中为树的高度，即O( l o g 2 N log_2 N log2​N)，搜索的效率取决于搜索过程中元素的比较次数。
理想的搜索方法：可以不经过任何比较，一次直接从表中得到要搜索的元素。
如果构造一种存储结构，通过某种函数(hashFunc)使元素的存储位置与它的关键码之间能够建立一一映射的关系，那么在查找时通过该函数可以很快找到该元素。
当向该结构中：
插入元素
根据待插入元素的关键码，以此函数计算出该元素的存储位置并按此位置进行存放搜索元素
对元素的关键码进行同样的计算，把求得的函数值当做元素的存储位置，在结构中按此位置取元素比较，若关键码相等，则搜索成功 该方式即为哈希(散列)方法，哈希方法中使用的转换函数称为哈希(散列)函数，构造出来的结构称为哈希表(Hash Table)(或者称散列表)
例如：数据集合{1，7，6，4，5，9}；
哈希函数设置为：hash(key) = key % capacity; capacity为存储元素底层空间总的大小。
用该方法进行搜索不必进行多次关键码的比较，因此搜索的速度比较快
问题：按照上述哈希方式，向集合中插入元素44，会出现什么问题？
使用上面这个方法就可以发现44 % 10 = 4，就会出现哈希冲突/哈希碰撞，不同的值可能会映射到相同的位置，一个空间只能存储一个值，就会出现冲突
2.哈希冲突 对于两个数据元素的关键字 k i k_i ki​和 k j k_j kj​(i != j)，有 k i k_i ki​ != k j k_j kj​，但有：Hash( k i k_i ki​) == Hash( k j k_j kj​)，即：不同关键字通过相同哈希哈数计算出相同的哈希地址，该种现象称为哈希冲突或哈希碰撞。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-14T21:03:58+08:00">
    <meta property="article:modified_time" content="2024-04-14T21:03:58+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;庖丁解牛】哈希表/散列表的设计原理 | 哈希函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <center> 
 <img src="https://images2.imgbox.com/6e/b0/BspIRTA2_o.png" width="20%"> 
</center> 
<center> 
 <font face="仿宋" color="#00FFFF" size="3"> 🍁你好，我是 <a href="https://blog.csdn.net/weixin_60521256?spm=1010.2135.3001.5343">RO-BERRY</a> </font> 
</center> 
<center> 
 <font face="仿宋" color="bluie" size="3"> 📗 致力于C、C++、数据结构、TCP/IP、数据库等等一系列知识</font> 
 <center> 
  <font face="仿宋" color="orange" size="3"> 🎄感谢你的陪伴与支持 ，故事既有了开头，就要画上一个完美的句号，让我们一起加油</font> 
 </center> 
</center> 
<hr> 
<p><img src="https://images2.imgbox.com/68/a8/7AxHoOZm_o.gif" alt="在这里插入图片描述"></p> 
<hr> 
<p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_14" rel="nofollow">前言</a></li><li><a href="#1_17" rel="nofollow">1.哈希概念</a></li><li><a href="#2_44" rel="nofollow">2.哈希冲突</a></li><li><a href="#3_49" rel="nofollow">3.哈希函数</a></li><li><a href="#4_93" rel="nofollow">4.哈希冲突解决</a></li><li><ul><li><a href="#41_96" rel="nofollow">4.1闭散列</a></li><li><a href="#42__159" rel="nofollow">4.2 开散列</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_14"></a>前言</h2> 
<p>unordered系列的关联式容器之所以效率比较高，是因为其底层使用了哈希结构。</p> 
<h2><a id="1_17"></a>1.哈希概念</h2> 
<p>哈希又称为散列，有些书上对于哈希取名为散列表，其本质就是一个<strong>存储的值和存储的位置的映射</strong></p> 
<p><strong>顺序结构以及平衡树</strong>中，元素关键码与其存储位置之间没有对应的关系，因此在查找一个元素时，<strong>必须要经过关键码的多次比较</strong>。<strong>顺序查找时间复杂度为O(N)，平衡树中为树的高度，即O(<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          l 
         
        
          o 
         
         
         
           g 
          
         
           2 
          
         
        
          N 
         
        
       
         log_2 N 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span></span></span></span></span>)</strong>，搜索的效率取决于搜索过程中元素的比较次数。</p> 
<blockquote> 
 <p>理想的搜索方法：可以<strong>不经过任何比较，一次直接从表中得到要搜索的元素</strong>。</p> 
</blockquote> 
<p><strong>如果构造一种存储结构，通过某种函数(hashFunc)使元素的存储位置与它的关键码之间能够建立一一映射的关系，那么在查找时通过该函数可以很快找到该元素。</strong><br> 当向该结构中：</p> 
<ul><li><strong>插入元素</strong><br> 根据待插入元素的关键码，以此函数计算出该元素的存储位置并按此位置进行存放</li><li><strong>搜索元素</strong><br> 对元素的关键码进行同样的计算，把求得的函数值当做元素的存储位置，在结构中按此位置取元素比较，若关键码相等，则搜索成功</li></ul> 
<p><strong>该方式即为哈希(散列)方法，哈希方法中使用的转换函数称为哈希(散列)函数，构造出来的结构称为哈希表(Hash Table)(或者称散列表)</strong></p> 
<blockquote> 
 <p>例如：数据集合{1，7，6，4，5，9}；<br> 哈希函数设置为：hash(key) = key % capacity; capacity为存储元素底层空间总的大小。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/d8/73/jE3iXwLC_o.png" alt="在这里插入图片描述"></p> 
<p>用该方法进行搜索不必进行多次关键码的比较，因此搜索的速度比较快<br> 问题：按照上述哈希方式，向集合中插入元素44，会出现什么问题？</p> 
<blockquote> 
 <p>使用上面这个方法就可以发现44 % 10 = 4，就会出现哈希冲突/哈希碰撞，不同的值可能会映射到相同的位置，一个空间只能存储一个值，就会出现冲突</p> 
</blockquote> 
<h2><a id="2_44"></a>2.哈希冲突</h2> 
<p>对于两个数据元素的关键字<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          k 
         
        
          i 
         
        
       
      
        k_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0315em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>和 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          k 
         
        
          j 
         
        
       
      
        k_j 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.9805em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0315em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span></span></span></span></span>(i != j)，有<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          k 
         
        
          i 
         
        
       
      
        k_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0315em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> != <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          k 
         
        
          j 
         
        
       
      
        k_j 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.9805em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0315em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span></span></span></span></span>，但有：Hash(<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          k 
         
        
          i 
         
        
       
      
        k_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0315em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>) == Hash(<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          k 
         
        
          j 
         
        
       
      
        k_j 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.9805em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0315em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span></span></span></span></span>)，即：<strong>不同关键字通过相同哈希哈数计算出相同的哈希地址，该种现象称为哈希冲突或哈希碰撞。</strong><br> 把具有不同关键码而具有相同哈希地址的数据元素称为“同义词”。<br> 发生哈希冲突该如何处理呢？</p> 
<h2><a id="3_49"></a>3.哈希函数</h2> 
<blockquote> 
 <p>引起哈希冲突的一个原因可能是：<strong>哈希函数设计不够合理。</strong></p> 
</blockquote> 
<p><strong>哈希函数设计原则：</strong></p> 
<ul><li>哈希函数的定义域必须包括需要存储的全部关键码，而如果散列表允许有m个地址时，其值域必须在0到m-1之间</li><li>哈希函数计算出来的地址能均匀分布在整个空间中</li><li>哈希函数应该比较简单</li></ul> 
<p><strong>常见哈希函数:</strong></p> 
<ol><li>直接定址法–(常用)</li></ol> 
<blockquote> 
 <p><strong>取关键字的某个线性函数为散列地址</strong>：<code>Hash（Key）= A*Key + B</code><br> <strong>优点</strong>：简单、均匀<br> <strong>缺点</strong>：需要事先知道关键字的分布情况<br> <strong>使用场景</strong>：适合查找比较小且连续的情况</p> 
</blockquote> 
<ol start="2"><li>除留余数法–(常用)</li></ol> 
<blockquote> 
 <p><strong>设散列表中允许的地址数为m，取一个不大于m，但最接近或者等于m的质数p作为除数，按照哈希函数：Hash(key) = key% p(p&lt;=m),将关键码转换成哈希地址</strong></p> 
</blockquote> 
<ol start="3"><li>平方取中法–(了解)</li></ol> 
<blockquote> 
 <p>假设关键字为1234，对它平方就是1522756，抽取中间的3位227作为哈希地址；<br> 再比如关键字为4321，对它平方就是18671041，抽取中间的3位671(或710)作为哈希地址<br> <strong>平方取中法比较适合：不知道关键字的分布，而位数又不是很大的情况</strong></p> 
</blockquote> 
<ol start="4"><li>折叠法–(了解)</li></ol> 
<blockquote> 
 <p>折叠法是将关键字从左到右分割成位数相等的几部分(最后一部分位数可以短些)，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。<br> <strong>折叠法适合事先不需要知道关键字的分布，适合关键字位数比较多的情况</strong></p> 
</blockquote> 
<ol start="5"><li>随机数法–(了解)</li></ol> 
<blockquote> 
 <p>选择一个随机函数，取关键字的随机函数值为它的哈希地址，即H(key) = random(key),其中random为随机数函数。<br> <strong>通常应用于关键字长度不等时采用此法</strong></p> 
</blockquote> 
<ol start="6"><li>数学分析法–(了解)</li></ol> 
<blockquote> 
 <p>设有n个d位数，每一位可能有r种不同的符号，这r种不同的符号在各位上出现的频率不一定相同，可能在某些位上分布比较均匀，每种符号出现的机会均等，在某些位上分布不均匀只有某几种符号经常出现。可根据散列表的大小，选择其中各种符号分布均匀的若干位作为散列地址。例如：<br> <img src="https://images2.imgbox.com/13/be/ailrtFiq_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p>假设要存储某家公司员工登记表，如果用手机号作为关键字，那么极有可能前7位都是 相同的，那么我们可以选择后面的四位作为散列地址，如果这样的抽取工作还容易出现 冲突，还可以对抽取出来的数字进行反转(如1234改成4321)、右环位移(如1234改成4123)、左环移位、前两数与后两数叠加(如1234改成12+34=46)等方法。<br> <strong>数字分析法通常适合处理关键字位数比较大的情况，如果事先知道关键字的分布且关键字的<br> 若干位分布较均匀的情况</strong></p> 
</blockquote> 
<p><strong>注意：哈希函数设计的越精妙，产生哈希冲突的可能性就越低，但是无法避免哈希冲突</strong></p> 
<hr> 
<h2><a id="4_93"></a>4.哈希冲突解决</h2> 
<blockquote> 
 <p>解决哈希冲突两种常见的方法是：闭散列和开散列</p> 
</blockquote> 
<h3><a id="41_96"></a>4.1闭散列</h3> 
<p>闭散列：也叫开放定址法，当发生哈希冲突时，如果哈希表未被装满，说明在哈希表中必然还有空位置，那么可以把key存放到冲突位置中的“下一个” 空位置中去。那如何寻找下一个空位置呢？</p> 
<blockquote> 
 <p><font color="orange">哈希冲突冲突越多，效率就越低<br> 负载因子/载荷因子 = 实际存进去的数据个数/表的大小<br> 闭散列（开放寻址法）：一般会控制在0.7左右</font></p> 
</blockquote> 
<ol><li>线性探测<br> 如上方中的场景，现在需要插入元素44，先通过哈希函数计算哈希地址，hashAddr为4，因此44理论上应该插在该位置，但是该位置已经放了值为4的元素，即发生哈希冲突。</li></ol> 
<ul><li><strong>线性探测：从发生冲突的位置开始，依次向后探测，直到寻找到下一个空位置为止。</strong></li></ul> 
<blockquote> 
 <p><strong>插入</strong></p> 
 <ul><li><strong>通过哈希函数获取待插入元素在哈希表中的位置</strong><br> <strong>i = key % 表的大小</strong></li><li><strong>如果该位置中没有元素则直接插入新元素，如果该位置中有元素发生哈希冲突，<br> 使用线性探测找到下一个空位置，插入新元素</strong></li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/fe/3a/75YSHQVq_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>查找</strong></p> 
 <ul><li><strong>i = key % 表的大小</strong><br> <strong>如果i为表示要查找的key就线性往后查找，直到找到或者遇到空，如果找到表结尾位置，要往头回绕（）</strong></li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>删除</strong></p> 
 <ul><li><strong>采用闭散列处理哈希冲突时，不能随便物理删除哈希表中已有的元素，若直接删除元素会影响其他元素的搜索。比如删除元素4，如果直接删除掉，44查找起来可能会受影响。</strong><br> <img src="https://images2.imgbox.com/bc/f6/p9VSYR3o_o.png" alt="在这里插入图片描述"></li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>因此线性探测采用标记的伪删除法来删除一个元素。即在查找过程中找到或者空才结束，遇到删除会继续查找</strong></p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token keyword">enum</span> <span class="token class-name">State</span>   <span class="token comment">//标记方法</span>
<span class="token punctuation">{<!-- --></span>
	EMPTY<span class="token punctuation">,</span>   <span class="token comment">//空</span>
	EXIST<span class="token punctuation">,</span>   <span class="token comment">//存在数据</span>
	DELETE   <span class="token comment">//删除</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">K</span><span class="token punctuation">,</span><span class="token keyword">class</span> <span class="token class-name">V</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">HashData</span>    
<span class="token punctuation">{<!-- --></span>
	pair<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span> _data<span class="token punctuation">;</span>
	State _state<span class="token operator">=</span> EMPTY<span class="token punctuation">;</span>   <span class="token comment">//标记状态</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">K</span><span class="token punctuation">,</span><span class="token keyword">class</span> <span class="token class-name">V</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">HashTable</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>
	vector<span class="token operator">&lt;</span>HashData<span class="token operator">&gt;</span> _tables<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p><strong>线性探测优点</strong>：实现非常简单，<br> <strong>线性探测缺点</strong>：一旦发生哈希冲突，所有的冲突连在一起，容易产生数据“堆积”，即：不同关键码占据了可利用的空位置，使得寻找某关键码的位置需要许多次比较，导致搜索效率降低。如何缓解呢？</p> 
</blockquote> 
<ol start="2"><li>二次探测</li></ol> 
<p>线性探测的缺陷是产生冲突的数据堆积在一块，这与其找下一个空位置有关系，因为找空位置的方式就是挨着往后逐个去找，因此二次探测为了避免该问题，找下一个空位置的方法为：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          H 
         
        
          i 
         
        
       
      
        H_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0813em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0813em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> = (<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          H 
         
        
          0 
         
        
       
      
        H_0 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0813em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0813em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> + <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          i 
         
        
          2 
         
        
       
      
        i^2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8141em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> )% m, 或者：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          H 
         
        
          i 
         
        
       
      
        H_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0813em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0813em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> = (<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          H 
         
        
          0 
         
        
       
      
        H_0 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0813em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0813em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> - <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          i 
         
        
          2 
         
        
       
      
        i^2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8141em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> )% m。其中：i = 1,2,3…， <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          H 
         
        
          0 
         
        
       
      
        H_0 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0813em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0813em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>是通过散列函数Hash(x)对元素的关键码 key 进行计算得到的位置，m是表的大小。</p> 
<p>对于上例中如果要插入44，产生冲突，使用解决后的情况为：<br> <img src="https://images2.imgbox.com/55/11/oATKP567_o.png" alt="在这里插入图片描述"></p> 
<p><font color="buile"><strong>研究表明：当表的长度为质数且表装载因子a不超过0.5时，新的表项一定能够插入，而且任何一个位置都不会被探查两次。因此只要表中有一半的空位置，就不会存在表满的问题。在搜索时可以不考虑表装满的情况，但在插入时必须确保表的装载因子a不超过0.5，如果超出必须考虑增容。</strong></font></p> 
<h3><a id="42__159"></a>4.2 开散列</h3> 
<ol><li><strong>开散列概念</strong></li></ol> 
<p><strong>开散列法又叫链地址法(开链法)又可以叫哈希桶，首先对关键码集合用散列函数计算散列地址，具有相同地址的关键码归于同一子集合，每一个子集合称为一个桶，各个桶中的元素通过一个单链表链接起来，各链表的头结点存储在哈希表中。</strong></p> 
<p>我们不直接将数据存储在空间里，我们采用链表的形式，每一个节点存储一个指针<br> <img src="https://images2.imgbox.com/2c/93/c3FnBSWA_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>我们插入一个44就会变成下面这样</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/12/4b/6UUs0ZTC_o.png" alt="在这里插入图片描述"><br> 从上图可以看出，开散列中每个桶中放的都是发生哈希冲突的元素。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/15ba2fa16554120bac1c3f3b8a039a03/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python作品 运动模糊图像修复算法(上)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cee4c6d587580182ebc350e6910ff177/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Spring Boot】深入解密Spring Boot日志：最佳实践与策略解析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>