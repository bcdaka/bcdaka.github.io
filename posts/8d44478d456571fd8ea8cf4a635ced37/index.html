<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JVM 运行时内存结构简介 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/8d44478d456571fd8ea8cf4a635ced37/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="JVM 运行时内存结构简介">
  <meta property="og:description" content="JVM 运行时内存结构简介 一、前言二、JVM 运行时内存结构2.1 线程隔离数据区：2.2 线程共享数据区： 三、JVM 内存区域划分1. 程序计数器（PC）2. 虚拟机栈3. 本地方法栈4. Java 堆5. 方法区6. 运行时常量池 附录 一、前言 JVM（Java 虚拟机）的运行时内存结构在 Java 程序的运行中起着关键支撑作用。而在 Android 系统中，虽然没有直接使用传统的 JVM，但 Android 运行时环境（AndroidRuntime）借鉴了许多 JVM 的设计理念和机制。了解 JVM 的运行时内存结构，不仅有助于 Java 开发者更好地理解 Java 程序的运行机制，对于 Android 开发者来说，也能更深入地理解 Android 系统中应用程序的运行原理，优化程序性能，以及排查内存相关的问题。
二、JVM 运行时内存结构 2.1 线程隔离数据区： 程序计数器：记录正在执行的虚拟机字节码的地址；虚拟机栈：方法执行的内存区，每个方法执行时会在虚拟机栈中创建栈帧；本地方法栈：虚拟机的Native方法执行的内存区； 2.2 线程共享数据区： Java堆：对象分配内存的区域；方法区：存放类信息、常量、静态变量、编译器编译后的代码等数据；常量池：存放编译器生成的各种字面量和符号引用，是方法区的一部分。 三、JVM 内存区域划分 1. 程序计数器（PC） 程序计数器是当前线程所执行的字节码行号指示器。每个线程都拥有自己独立的程序计数器，属于私有内存空间，在整个内存中占比较小。当线程执行 Java 方法时，PC 计数器记录正在执行的虚拟机字节码地址；而当线程执行 Native 方法时，PC 计数器为空。 2. 虚拟机栈 虚拟机栈的生命周期与线程相同，是 Java 方法执行的内存模型。每个方法执行时都会创建一个栈帧，方法的执行过程对应着虚拟机栈的入栈到出栈过程。栈帧是支持虚拟机进行方法执行的数据结构，也是虚拟机栈的栈元素。栈帧包括局部变量表（容量以 slot 为最小单位，用于存储一组变量，其大小在编译期确定）、操作栈（操作栈元素的数据类型需与字节码指令序列严格匹配，大小同样在编译期确定）、动态连接（指向运行时常量池中该栈帧所属方法的引用，用于动态连接）、方法返回地址（正常退出时，执行引擎遇到方法返回的字节码，将返回值传递给调用者；异常退出时，若遇到未被捕捉的 Exception，则不会有任何返回值）以及可能的额外附加信息（由具体虚拟机实现，虚拟机规范未明确规定）。Java 虚拟机规范规定该区域可能出现两种异常：当线程请求栈深度超出虚拟机栈所允许的深度时抛出 StackOverFlowError；当 Java 虚拟机动态扩展到无法申请足够内存时抛出 OutOfMemoryError。 3.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-21T18:21:46+08:00">
    <meta property="article:modified_time" content="2024-08-21T18:21:46+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JVM 运行时内存结构简介</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>JVM 运行时内存结构简介</h4> 
 <ul><li><a href="#_1" rel="nofollow">一、前言</a></li><li><a href="#JVM__5" rel="nofollow">二、JVM 运行时内存结构</a></li><li><ul><li><a href="#21__8" rel="nofollow">2.1 线程隔离数据区：</a></li><li><a href="#22__13" rel="nofollow">2.2 线程共享数据区：</a></li></ul> 
  </li><li><a href="#JVM__19" rel="nofollow">三、JVM 内存区域划分</a></li><li><ul><li><a href="#1_PC_20" rel="nofollow">1. 程序计数器（PC）</a></li><li><a href="#2__24" rel="nofollow">2. 虚拟机栈</a></li><li><a href="#3__29" rel="nofollow">3. 本地方法栈</a></li><li><a href="#4_Java__33" rel="nofollow">4. Java 堆</a></li><li><a href="#5__38" rel="nofollow">5. 方法区</a></li><li><a href="#6__42" rel="nofollow">6. 运行时常量池</a></li></ul> 
  </li><li><a href="#_52" rel="nofollow">附录</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>一、前言</h2> 
<p>JVM（Java 虚拟机）的运行时内存结构在 Java 程序的运行中起着关键支撑作用。而在 Android 系统中，虽然没有直接使用传统的 JVM，但 Android 运行时环境（AndroidRuntime）借鉴了许多 JVM 的设计理念和机制。了解 JVM 的运行时内存结构，不仅有助于 Java 开发者更好地理解 Java 程序的运行机制，对于 Android 开发者来说，也能更深入地理解 Android 系统中应用程序的运行原理，优化程序性能，以及排查内存相关的问题。</p> 
<h2><a id="JVM__5"></a>二、JVM 运行时内存结构</h2> 
<p><img src="https://images2.imgbox.com/22/e0/wCLzfyBy_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="21__8"></a>2.1 线程隔离数据区：</h3> 
<ul><li>程序计数器：记录正在执行的虚拟机字节码的地址；</li><li>虚拟机栈：方法执行的内存区，每个方法执行时会在虚拟机栈中创建栈帧；</li><li>本地方法栈：虚拟机的Native方法执行的内存区；</li></ul> 
<h3><a id="22__13"></a>2.2 线程共享数据区：</h3> 
<ul><li>Java堆：对象分配内存的区域；</li><li>方法区：存放类信息、常量、静态变量、编译器编译后的代码等数据；</li><li>常量池：存放编译器生成的各种字面量和符号引用，是方法区的一部分。</li></ul> 
<h2><a id="JVM__19"></a>三、JVM 内存区域划分</h2> 
<h3><a id="1_PC_20"></a>1. 程序计数器（PC）</h3> 
<ul><li>程序计数器是当前线程所执行的字节码行号指示器。每个线程都拥有自己独立的程序计数器，属于私有内存空间，在整个内存中占比较小。</li><li>当线程执行 Java 方法时，PC 计数器记录正在执行的虚拟机字节码地址；而当线程执行 Native 方法时，PC 计数器为空。</li></ul> 
<h3><a id="2__24"></a>2. 虚拟机栈</h3> 
<ul><li>虚拟机栈的生命周期与线程相同，是 Java 方法执行的内存模型。每个方法执行时都会创建一个栈帧，方法的执行过程对应着虚拟机栈的入栈到出栈过程。</li><li>栈帧是支持虚拟机进行方法执行的数据结构，也是虚拟机栈的栈元素。栈帧包括局部变量表（容量以 slot 为最小单位，用于存储一组变量，其大小在编译期确定）、操作栈（操作栈元素的数据类型需与字节码指令序列严格匹配，大小同样在编译期确定）、动态连接（指向运行时常量池中该栈帧所属方法的引用，用于动态连接）、方法返回地址（正常退出时，执行引擎遇到方法返回的字节码，将返回值传递给调用者；异常退出时，若遇到未被捕捉的 Exception，则不会有任何返回值）以及可能的额外附加信息（由具体虚拟机实现，虚拟机规范未明确规定）。</li><li>Java 虚拟机规范规定该区域可能出现两种异常：当线程请求栈深度超出虚拟机栈所允许的深度时抛出 StackOverFlowError；当 Java 虚拟机动态扩展到无法申请足够内存时抛出 OutOfMemoryError。</li></ul> 
<h3><a id="3__29"></a>3. 本地方法栈</h3> 
<ul><li>本地方法栈为虚拟机使用的 Native 方法提供内存空间，与为 Java 方法提供内存空间的虚拟机栈类似。有些虚拟机的实现将本地方法栈和虚拟机栈合二为一，如 Sun HotSpot 虚拟机。</li><li>该区域可能抛出 StackOverFlowError 和 OutOfMemoryError 异常。</li></ul> 
<h3><a id="4_Java__33"></a>4. Java 堆</h3> 
<ul><li>Java 堆是 Java 虚拟机管理的最大一块内存，也是垃圾回收的主要区域，存放着几乎所有的对象实例和数组数据。由于 JIT 编译器的栈上分配、标量替换等优化技术，部分对象实例数据可能不在 Java 堆中，而是在栈内存。</li><li>从内存回收角度，Java 堆分为新生代和老年代，以更快地回收内存；从内存分配角度，可划分出线程私有的分配缓冲区（TLAB），以便更快地分配内存。对象实例在堆上的结构包括对象头和实例数据，可能还有填充数据以保证对象起始地址是 8 字节的整数倍。</li><li>Java 虚拟机规范规定该区域可抛出 OutOfMemoryError 异常。</li></ul> 
<h3><a id="5__38"></a>5. 方法区</h3> 
<ul><li>方法区主要存储已被虚拟机加载的类信息、常量、静态变量、编译器编译后的代码等数据。垃圾回收在该区域出现较少。</li><li>该区域可能抛出 OutOfMemoryError 异常。</li></ul> 
<h3><a id="6__42"></a>6. 运行时常量池</h3> 
<p>运行时常量池是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。除了编译期产生的 Class 文件的常量池外，还可以在运行期间将新的常量加入常量池，如 String 类的 intern()方法。</p> 
<ul><li>字面量：与Java语言层面的常量概念相近，包含文本字符串、声明为final的常量值等。</li><li>符号引用：编译语言层面的概念，包括以下3类： 
  <ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul> </li></ul> 
<p>该区域不会抛出 OutOfMemoryError 异常。</p> 
<h2><a id="_52"></a>附录</h2> 
<p><a href="https://gityuan.com/2015/10/17/java-memory/" rel="nofollow">Jvm系列1—运行时内存结构</a><br> <a href="https://blog.csdn.net/m0_37796683/article/details/139089496">深入研究Android内存优化（上）- 至少解决 APP 中 90% 的内存异常问题</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/85af3ef70b610711e657be68891945d2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">STM32——I2C通信外设</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4c4ac2bc6cded0ba7c6c5b3c1a05b63e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java语言程序设计——篇十一（3）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>