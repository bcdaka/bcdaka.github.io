<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>初阶数据结构——二叉树大汇总 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/d337be5954428476340df22df2bfdf86/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="初阶数据结构——二叉树大汇总">
  <meta property="og:description" content="这篇博客将会讲到二叉树的部分内容及堆的相关知识~ 这里将会涉及到大量的递归（头大）
目录
1.树
1.1树的概念
1.2树的相关概念
1.3树的表示
1.4树的实际应用
2.二叉树
2.1二叉树的概念
2.2特殊的二叉树 2.2.1 满二叉树
2.2.2 完全二叉树
2.2.3堆 2.3 二叉树的性质
2.4二叉树的存储 2.4.1顺序结构存储
2.4.2链式结构存储
2.5二叉树的遍历
2.5.1前序遍历
代码表示 2.5.2中序遍历
代码表示 2.5.3后续遍历
代码表示 2.5.4层序遍历 代码表示
总结示例 2.6二叉树的其他代码 1.树 1.1树的概念 树这个东东，真的不同于之前学到的数据结构 树是一种非线性的数据结构，它是由n（n&gt;=0）个有限结点组成一个具有层次关系的集合。把它叫做树是因 为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。
有一个特殊的结点，称为根结点，根结点没有前驱结点除根结点外，其余结点被分成M(M&gt;0)个互不相交的集合T1、T2、……、Tm，其中每一个集合Ti(1&lt;=i&lt;=m)又是一棵结构与树类似的子树。每棵子树的根结点有且只有一个前驱，可以有0个或多个后继树是递归定义的。 如图： 注意：子树与子树之间不能相连，不然就变成另一种数据结构——图 1.2树的相关概念 结点的度：一个结点含有的子树的个数称为该结点的度； 如上图：A的为6
叶结点或终端结点：度为0的结点称为叶结点； 如上图：B、C、H、I...等结点为叶结点
非终端结点或分支结点：度不为0的结点； 如上图：D、E、F、G...等结点为分支结点
双亲结点或父结点：若一个结点含有子结点，则这个结点称为其子结点的父结点； 如上图：A是B的父结点
孩子结点或子结点：一个结点含有的子树的根结点称为该结点的子结点； 如上图：B是A的孩子结点
兄弟结点：具有相同父结点的结点互称为兄弟结点； 如上图：B、C是兄弟结点
树的度：一棵树中，最大的结点的度称为树的度； 如上图：树的度为6
结点的层次：从根开始定义起，根为第1层，根的子结点为第2层，以此类推；
树的高度或深度：树中结点的最大层次； 如上图：树的高度为4
堂兄弟结点：双亲在同一层的结点互为堂兄弟；如上图：H、I互为兄弟结点
结点的祖先：从根到该结点所经分支上的所有结点；如上图：A是所有结点的祖先
子孙：以某结点为根的子树中任一结点都称为该结点的子孙。如上图：所有结点都是A的子孙
森林：由m（m&gt;0）棵互不相交的树的集合称为森林； 1.3树的表示 树结构相对线性表结构比较复杂，要存储表示起来比较麻烦，因为既要保存值，也要保存结点和结点之间的关系
实际中树有很多种表示方式如：双亲表示法，孩子表示法、孩子双亲表示法以及孩子兄弟表示法 等。我们这里就简单的了解其中最常用的孩子兄弟表示法。
所谓孩子兄弟表示法就是左孩子右兄弟（节点的分支左边第一个是孩子，剩下的都是兄弟）如图所示：
1.4树的实际应用 2.二叉树 2.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-24T18:18:06+08:00">
    <meta property="article:modified_time" content="2024-07-24T18:18:06+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">初阶数据结构——二叉树大汇总</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>这篇博客将会讲到二叉树的部分内容及堆的相关知识~ 这里将会涉及到大量的递归（头大）</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E6%A0%91-toc" style="margin-left:0px;"><a href="#1.%E6%A0%91" rel="nofollow">1.树</a></p> 
<p id="1.1%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#1.1%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">1.1树的概念</a></p> 
<p id="1.2%E6%A0%91%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#1.2%E6%A0%91%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5" rel="nofollow">1.2树的相关概念</a></p> 
<p id="1.3%E6%A0%91%E7%9A%84%E8%A1%A8%E7%A4%BA-toc" style="margin-left:40px;"><a href="#1.3%E6%A0%91%E7%9A%84%E8%A1%A8%E7%A4%BA" rel="nofollow">1.3树的表示</a></p> 
<p id="1.4%E6%A0%91%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8-toc" style="margin-left:40px;"><a href="#1.4%E6%A0%91%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8" rel="nofollow">1.4树的实际应用</a></p> 
<p id="2.%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:0px;"><a href="#2.%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">2.二叉树</a></p> 
<p id="2.1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#2.1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">2.1二叉树的概念</a></p> 
<p id="2.2%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%C2%A0-toc" style="margin-left:40px;"><a href="#2.2%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%C2%A0" rel="nofollow">2.2特殊的二叉树 </a></p> 
<p id="2.2.1%C2%A0%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:80px;"><a href="#2.2.1%C2%A0%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">2.2.1 满二叉树</a></p> 
<p id="2.2.2%20%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:80px;"><a href="#2.2.2%20%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">2.2.2 完全二叉树</a></p> 
<p id="2.2.3%E5%A0%86%C2%A0-toc" style="margin-left:80px;"><a href="#2.2.3%E5%A0%86%C2%A0" rel="nofollow">2.2.3堆 </a></p> 
<p id="2.3%C2%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8-toc" style="margin-left:40px;"><a href="#2.3%C2%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8" rel="nofollow">2.3 二叉树的性质</a></p> 
<p id="2.4%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%C2%A0-toc" style="margin-left:40px;"><a href="#2.4%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%C2%A0" rel="nofollow">2.4二叉树的存储 </a></p> 
<p id="2.4.1%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8-toc" style="margin-left:80px;"><a href="#2.4.1%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8" rel="nofollow">2.4.1顺序结构存储</a></p> 
<p id="2.4.2%E9%93%BE%E5%BC%8F%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8-toc" style="margin-left:80px;"><a href="#2.4.2%E9%93%BE%E5%BC%8F%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8" rel="nofollow">2.4.2链式结构存储</a></p> 
<p id="2.5%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-toc" style="margin-left:40px;"><a href="#2.5%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86" rel="nofollow">2.5二叉树的遍历</a></p> 
<p id="2.5.1%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-toc" style="margin-left:80px;"><a href="#2.5.1%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86" rel="nofollow">2.5.1前序遍历</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E8%A1%A8%E7%A4%BA%C2%A0-toc" style="margin-left:120px;"><a href="#%E4%BB%A3%E7%A0%81%E8%A1%A8%E7%A4%BA%C2%A0" rel="nofollow">代码表示 </a></p> 
<p id="%C2%A02.5.2%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-toc" style="margin-left:80px;"><a href="#%C2%A02.5.2%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86" rel="nofollow"> 2.5.2中序遍历</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E8%A1%A8%E7%A4%BA%C2%A0-toc" style="margin-left:120px;"><a href="#%E4%BB%A3%E7%A0%81%E8%A1%A8%E7%A4%BA%C2%A0" rel="nofollow">代码表示 </a></p> 
<p id="2.5.3%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86-toc" style="margin-left:80px;"><a href="#2.5.3%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86" rel="nofollow">2.5.3后续遍历</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E8%A1%A8%E7%A4%BA%C2%A0-toc" style="margin-left:120px;"><a href="#%E4%BB%A3%E7%A0%81%E8%A1%A8%E7%A4%BA%C2%A0" rel="nofollow">代码表示 </a></p> 
<p id="%C2%A02.5.4%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%C2%A0-toc" style="margin-left:80px;"><a href="#%C2%A02.5.4%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%C2%A0" rel="nofollow"> 2.5.4层序遍历 </a></p> 
<p id="%E4%BB%A3%E7%A0%81%E8%A1%A8%E7%A4%BA-toc" style="margin-left:120px;"><a href="#%E4%BB%A3%E7%A0%81%E8%A1%A8%E7%A4%BA" rel="nofollow">代码表示</a></p> 
<p id="%E6%80%BB%E7%BB%93%E7%A4%BA%E4%BE%8B%C2%A0-toc" style="margin-left:80px;"><a href="#%E6%80%BB%E7%BB%93%E7%A4%BA%E4%BE%8B%C2%A0" rel="nofollow">总结示例 </a></p> 
<p id="2.6%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%B6%E4%BB%96%E4%BB%A3%E7%A0%81%C2%A0-toc" style="margin-left:40px;"><a href="#2.6%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%B6%E4%BB%96%E4%BB%A3%E7%A0%81%C2%A0" rel="nofollow">2.6二叉树的其他代码 </a></p> 
<hr id="hr-toc"> 
<p></p> 
<p></p> 
<h2 id="1.%E6%A0%91" style="background-color:transparent;">1.树</h2> 
<h3 id="1.1%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5">1.1树的概念</h3> 
<p>树这个东东，真的不同于之前学到的数据结构 </p> 
<p>树是一种<span style="background-color:#98c091;">非线性</span>的数据结构，它是由n（n&gt;=0）个有限结点组成一个具有<span style="background-color:#d4e9d5;">层次关系</span>的集合。把它叫做树是因 为它看起来像一棵倒挂的树，也就是说它是<span style="background-color:#d4e9d5;">根朝上，而叶朝下</span>的。</p> 
<ol><li>有一个特殊的结点，称为根结点，<span style="color:#be191c;">根结点没有前驱结点</span></li><li>除根结点外，其余结点被分成M(M&gt;0)个互不相交的集合T1、T2、……、Tm，其中每一个集合Ti(1&lt;=i&lt;=m)又是一棵结构与树类似的子树。<span style="color:#be191c;">每棵子树的根结点有且只有一个前驱</span>，可以有0个或多个后继</li><li><span style="color:#be191c;">树是递归定义的</span>。 </li></ol> 
<p>如图： </p> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/25/42/9dPRO1sW_o.png"></p> 
<p></p> 
<p>注意：<span style="background-color:#d4e9d5;">子树与子树之间不能相连</span>，不然就变成另一种数据结构——图 </p> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/bf/dc/jotRVEa7_o.png"></p> 
<h3 id="1.2%E6%A0%91%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5">1.2树的相关概念</h3> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/ed/b7/4BFU2vwB_o.png"></p> 
<p><strong>结点的度：</strong>一个结点含有的子树的个数称为该结点的度； 如上图：A的为6</p> 
<p><strong><span style="color:#be191c;">叶结点或终端结点</span>：</strong>度为0的结点称为叶结点； 如上图：B、C、H、I...等结点为叶结点</p> 
<p><strong>非终端结点或分支结点：</strong>度不为0的结点； 如上图：D、E、F、G...等结点为分支结点</p> 
<p><strong><span style="color:#be191c;">双亲结点或父结点</span>：</strong>若一个结点含有子结点，则这个结点称为其子结点的父结点； 如上图：A是B的父结点</p> 
<p><strong><span style="color:#be191c;">孩子结点或子结点</span>：</strong>一个结点含有的子树的根结点称为该结点的子结点； 如上图：B是A的孩子结点</p> 
<p><strong>兄弟结点：</strong>具有相同父结点的结点互称为兄弟结点； 如上图：B、C是兄弟结点</p> 
<p><strong><span style="color:#be191c;">树的度</span>：</strong>一棵树中，最大的结点的度称为树的度； 如上图：树的度为6</p> 
<p><strong><span style="color:#be191c;">结点的层次</span>：</strong>从根开始定义起，根为第1层，根的子结点为第2层，以此类推；</p> 
<p><strong><span style="color:#be191c;">树的高度或深度</span>：</strong>树中结点的最大层次； 如上图：树的高度为4</p> 
<p><strong>堂兄弟结点：</strong>双亲在同一层的结点互为堂兄弟；如上图：H、I互为兄弟结点</p> 
<p><strong>结点的祖先：</strong>从根到该结点所经分支上的所有结点；如上图：A是所有结点的祖先</p> 
<p><strong>子孙：</strong>以某结点为根的子树中任一结点都称为该结点的子孙。如上图：所有结点都是A的子孙</p> 
<p><strong>森林：</strong>由m（m&gt;0）棵互不相交的树的集合称为森林； </p> 
<h3 id="1.3%E6%A0%91%E7%9A%84%E8%A1%A8%E7%A4%BA">1.3树的表示</h3> 
<p>树结构相对线性表结构比较复杂，要存储表示起来比较麻烦，因为既要保存<span style="background-color:#d4e9d5;">值</span>，也要保存<span style="background-color:#d4e9d5;">结点和结点之间的关系</span></p> 
<p>实际中树有很多种表示方式如：双亲表示法，孩子表示法、孩子双亲表示法以及孩子兄弟表示法 等。我们这里就简单的了解其中最常用的<strong>孩子兄弟表示法</strong>。</p> 
<p>所谓孩子兄弟表示法就是左孩子右兄弟（节点的分支左边第一个是孩子，剩下的都是兄弟）如图所示：</p> 
<p><img alt="" height="228" src="https://images2.imgbox.com/4f/2d/VVLTp30Y_o.png" width="688"></p> 
<h3 id="1.4%E6%A0%91%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8">1.4树的实际应用</h3> 
<p><img alt="" height="686" src="https://images2.imgbox.com/bb/cf/RaOoLUUA_o.png" width="1200"></p> 
<h2 id="2.%E4%BA%8C%E5%8F%89%E6%A0%91">2.二叉树</h2> 
<h3 id="2.1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5">2.1二叉树的概念</h3> 
<p>通俗来讲，二叉树就是度为2的树，也就是节点的度最大为2。如下图：</p> 
<p style="text-align:center;"><img alt="" height="295" src="https://images2.imgbox.com/8a/de/3WIIuh7x_o.png" width="358"></p> 
<p>二叉树可以是空树，任何一棵二叉树都由下面几种情况组成：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/5d/95/vPtcIKOF_o.png"></p> 
<h3 id="2.2%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%C2%A0">2.2特殊的二叉树 </h3> 
<h4 id="2.2.1%C2%A0%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91">2.2.1 满二叉树</h4> 
<p>一个二叉树，如果<span style="color:#be191c;">每一个层的结点数都达到最大值</span>，则这个二叉树就是满二叉树。也就是 说，如果一个二叉树的层数为K，且结点总数是 ，则它就是满二叉树。也可以叫做正则二叉树</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/24/8e/kpo0gzcY_o.png"></p> 
<h4 id="2.2.2%20%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91">2.2.2 完全二叉树</h4> 
<p>完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为K 的，有n个结点的二叉树，当且仅当<span style="color:#be191c;">其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应</span>时称之为完全二叉树。 要注意的是满二叉树是一种特殊的完全二叉树。</p> 
<p>简单来说，就是从第一层到倒数第二层是满二叉树，最后一层从左向右填充（可以不满）</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ca/8d/eTRp9EPJ_o.png"></p> 
<h4 id="2.2.3%E5%A0%86%C2%A0">2.2.3堆 </h4> 
<p>如果有一个关键码的集合K = { k0，k1 ，k2 ，…，kn-1 }，把它的所有元素按完全二叉树的顺序存储方式存储 在一个一维数组中，并满足：Ki&lt;=K2i+1 且 Ki&lt;=K2i+2 (Ki&gt;=K2i+1 且 Ki&gt;=K2i+2) i = 0，1， 2…，则称为小堆(或大堆)。将根结点最大的堆叫做最大堆或大根堆，根结点最小的堆叫做最小堆或小根堆。  </p> 
<p>简单来说就是：</p> 
<p>每一个父亲都比孩子小，叫小堆（头小脚大）；每一个父亲都比孩子大，叫大堆（头大脚小）</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/48/1f/j2LUUykm_o.png"></p> 
<h3 id="2.3%C2%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8">2.3 二叉树的性质</h3> 
<p>1. 若规定根结点的层数为1，则一棵<span style="background-color:#d4e9d5;">非空二叉树的第i层上最多</span>有2^(i-1)个结点。</p> 
<p>2. 若规定根结点的层数为1，则<span style="background-color:#d4e9d5;">深度为h的二叉树</span>的最大结点数是2^h -1。</p> 
<p>3. 对任何一棵二叉树, 如果度为0的叶结点个数为n，度为2的分支结个数为m ，则有 m＝n - 1。 </p> 
<p>4. 若规定根结点的层数为1，<span style="background-color:#d4e9d5;">具有n个结点的满二叉树</span>的深度，h= log(n+1)  (ps： 是log以2 为底，n+1为对数)</p> 
<p>5. 对于<span style="background-color:#d4e9d5;">具有n个结点的完全二叉树</span>，如果按照从上至下从左至右的数组顺序对所有结点从0开始编号，则对于序号为i的结点有：</p> 
<ol><li>若i&gt;0，i位置结点的双亲序号：(i-1)/2；i=0，i为根结点编号，无双亲结点</li><li>若2i+1&lt;n，<span style="color:#be191c;">左孩子</span>序号：<span style="color:#be191c;">2i+1</span>，2i+1&gt;=n则无左孩子</li><li>若2i+2&lt;n，<span style="color:#be191c;">右孩子</span>序号：<span style="color:#be191c;">2i+2</span>，2i+2&gt;=n则无右孩子</li></ol> 
<h3 id="2.4%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%C2%A0">2.4二叉树的存储 </h3> 
<p>二叉树的存储方式有两种，一种顺序结构存储，一种链式结构存储。 </p> 
<h4 id="2.4.1%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8">2.4.1顺序结构存储</h4> 
<p>顺序结构存储也就是用<span style="background-color:#79c6cd;">数组</span>来存储，一般使用数组<span style="background-color:#d4e9d5;">只适合表示完全二叉树</span>，因为不是完全二叉树会有空间的浪费。 </p> 
<p><span style="color:#be191c;">二叉树顺序存储在物理上是一个数组，在逻辑上是一颗二叉树。</span></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/16/de/3WckP42W_o.png"></p> 
<h4 id="2.4.2%E9%93%BE%E5%BC%8F%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8">2.4.2链式结构存储</h4> 
<p>二叉树的链式存储结构是指用<span style="background-color:#79c6cd;">链表</span>来表示一棵二叉树，即用链来指示元素的逻辑关系。 通常的方法是链表中<span style="background-color:#d4e9d5;">每个结点由三个域组成</span>，<span style="background-color:#d4e9d5;">数据域和左右指针域</span>，左右指针分别用来给出该结点左孩子和右孩子所在的链结点的存储地址 。 </p> 
<p style="text-align:center;"><img alt="" height="207" src="https://images2.imgbox.com/1a/11/EdcCPBLH_o.png" width="261"></p> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/6c/43/lFMqqOxt_o.png"></p> 
<pre><code class="language-cpp">typedef int BTDataType;
// 二叉链
struct BinaryTreeNode
{

	struct BinTreeNode* left;// 指向当前结点左孩子
	struct BinTreeNode* right;// 指向当前结点右孩子
	BTDataType data;// 当前结点值域
}

// 三叉链
struct BinaryTreeNode
{

	struct BinTreeNode* left;// 指向当前结点左孩子
	struct BinTreeNode* right;// 指向当前结点右孩子
	BTDataType data;// 当前结点值域

	struct BinTreeNode* parent;//指向当前结点的双亲

}</code></pre> 
<h3 id="2.5%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86">2.5二叉树的遍历</h3> 
<p>这里的遍历就需要用到大量的递归了 </p> 
<p>递归是个难点，学习递归就要弄懂两件事：<span style="color:#be191c;">当前问题，子问题</span></p> 
<p>所谓递归，不过是一堆相同步骤的叠加，用很短的代码来处理相同的步骤。</p> 
<p>写代码时需要把握好<span style="background-color:#98c091;">递归的截止条件、每一步递归进行的相同的步骤</span></p> 
<p>二叉树的前、中、后序遍历常用的就是递归方式，当然也可以写非递归方式（这里常用栈的结构、循环来解决） </p> 
<h4 id="2.5.1%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86">2.5.1前序遍历</h4> 
<p>前序遍历(Preorder Traversal 亦称先序遍历)——访问根结点的操作发生在遍历其左右子树之前。</p> 
<p>前序遍历的过程中，所有节点的访问顺序都是<span style="background-color:#d4e9d5;">根、左子树、右子树</span></p> 
<p>下面这幅图表示的很形象</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b0/93/sGTkYx2Q_o.png"></p> 
<p></p> 
<h5 id="%E4%BB%A3%E7%A0%81%E8%A1%A8%E7%A4%BA%C2%A0">代码表示 </h5> 
<pre><code class="language-cpp">// 二叉树前序遍历 
void BinaryTreePrevOrder(BTNode* root)
{
	if (root == NULL)
	{
		printf("N ");
		return;
	}//结束条件
	printf("%c ", root-&gt;_data);
	BinaryTreePrevOrder(root-&gt;_left);
	BinaryTreePrevOrder(root-&gt;_right);//相同的每一步

	
}</code></pre> 
<h4 id="%C2%A02.5.2%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"> 2.5.2中序遍历</h4> 
<p>中序遍历(Inorder Traversal)——访问根结点的操作发生在遍历其左右子树之中（间）。</p> 
<p>中序遍历的过程中，所有节点的访问顺序都是<span style="background-color:#d4e9d5;">左子树、根、右子树</span> </p> 
<p style="text-align:center;"><img alt="" height="360" src="https://images2.imgbox.com/78/5b/zFLJCF0e_o.png" width="501"></p> 
<h5>代码表示 </h5> 
<pre><code class="language-cpp">// 二叉树中序遍历
void BinaryTreeInOrder(BTNode* root)
{
	if (root == NULL)
	{
		printf("N ");
		return;
	}
	BinaryTreeInOrder(root-&gt;_left);
	printf("%c ", root-&gt;_data);
	BinaryTreeInOrder(root-&gt;_right);
}</code></pre> 
<h4 id="2.5.3%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86">2.5.3后续遍历</h4> 
<p>后序遍历(Postorder Traversal)——访问根结点的操作发生在遍历其左右子树之后。  </p> 
<p>后序遍历的过程中，所有节点的访问顺序都是<span style="background-color:#d4e9d5;">左子树、右子树、根</span> </p> 
<p style="text-align:center;"><img alt="" height="400" src="https://images2.imgbox.com/4b/7a/8IHT2i2f_o.png" width="640"></p> 
<h5>代码表示 </h5> 
<pre><code class="language-cpp">// 二叉树后序遍历
void BinaryTreePostOrder(BTNode* root)
{
	if (root == NULL)
	{
		printf("N ");
		return;
	}
	BinaryTreePostOrder(root-&gt;_left);
	BinaryTreePostOrder(root-&gt;_right);
	printf("%c ", root-&gt;_data);

}</code></pre> 
<h4 id="%C2%A02.5.4%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%C2%A0" style="background-color:transparent;"> 2.5.4层序遍历 </h4> 
<p>层序遍历是最符合人类习惯的遍历方式 </p> 
<p>设二叉树的根结点所在层数为1，层序遍历就是从所在二叉树的根结点出发，首先访问第一层的树根结点，然后从左到右访问第2层上的结点，接着是第3层的结点，以此类推，自上而下，自左至右逐层访问树的结点的过程就是层序遍历。  </p> 
<p style="text-align:center;"><img alt="" height="202" src="https://images2.imgbox.com/c8/b4/79Se3HSX_o.png" width="415">  </p> 
<h5 id="%E4%BB%A3%E7%A0%81%E8%A1%A8%E7%A4%BA">代码表示</h5> 
<p>层序遍历的基础要用到数据结构<span style="background-color:#d4e9d5;">队列</span>， 先让第一个节点入队，后续按照：<span style="background-color:#d4e9d5;">一个节点出队，该节点的子节点入队</span>，这一方式进行循环遍历</p> 
<pre><code class="language-cpp">// 层序遍历
void BinaryTreeLevelOrder(BTNode* root)
{
	Queue q;
	QueueInit(&amp;q);
	QueuePush(&amp;q, root);
	while (!QueueEmpty(&amp;q))
	{
		BTNode* front = QueueFront(&amp;q);
		
		printf("%c ", front-&gt;_data);

		QueuePop(&amp;q);
		if(front-&gt;_left!=NULL)
			QueuePush(&amp;q, front-&gt;_left);
		if (front-&gt;_right != NULL)
			QueuePush(&amp;q, front-&gt;_right);
	}
	printf("\n");

}</code></pre> 
<h4 id="%E6%80%BB%E7%BB%93%E7%A4%BA%E4%BE%8B%C2%A0">总结示例 </h4> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/59/74/qQ7Fq7Xo_o.png"></p> 
<ul><li>前序遍历结果：1 2 3 4 5 6</li><li>中序遍历结果：3 2 1 5 4 6</li><li>后序遍历结果：3 2 5 6 4 1  </li><li>层序遍历结果：1 2 4 3 5 6 </li></ul> 
<h3 id="2.6%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%B6%E4%BB%96%E4%BB%A3%E7%A0%81%C2%A0" style="background-color:transparent;">2.6二叉树的其他代码 </h3> 
<pre><code class="language-cpp">// 二叉树查找值为x的节点
BTNode* BinaryTreeFind(BTNode* root, BTDataType x)
{
	if (root == NULL)
	{
		return NULL;
	}
	if (root-&gt;_data == x)
	{
		return root;
	}
	BTNode* ret1 = BinaryTreeFind(root-&gt;_left,x);
	if (ret1)
	{
		return ret1;
	}
	BTNode* ret2 = BinaryTreeFind(root-&gt;_left, x);
	if (ret2)
	{
		return ret2;
	}
	return NULL;
}</code></pre> 
<pre><code class="language-cpp">// 二叉树第k层节点个数
int BinaryTreeLevelKSize(BTNode* root, int k)
{
	if (root == NULL)
	{
		return 0;
	}
	if (k == 1)
	{
		return 1;
	}
	int left = BinaryTreeLevelKSize(root-&gt;_left, k - 1);
	int right = BinaryTreeLevelKSize(root-&gt;_right, k - 1);
	return left + right;
}</code></pre> 
<pre><code class="language-cpp">// 二叉树叶子节点个数
int BinaryTreeLeafSize(BTNode* root)
{
	if (root == NULL)
	{
		return 0;
	}
	if (root-&gt;_left == NULL &amp;&amp; root-&gt;_right == NULL)
	{
		return 1;
	}

	return BinaryTreeLeafSize(root-&gt;_left) + BinaryTreeLeafSize(root-&gt;_right) ;

}</code></pre> 
<pre><code class="language-cpp">// 二叉树节点个数
int BinaryTreeSize(BTNode* root)
{

	return root == NULL ? 0 : BinaryTreeSize(root-&gt;_left) + BinaryTreeSize(root-&gt;_right) + 1;
}</code></pre> 
<p>---------------------------------------------------------------------------------------------------------------------------------</p> 
<p>好啦二叉树的相关内容就先到这啦，后续应该会有所补充，敬请期待~</p> 
<p>看到这里的小伙伴，求求点赞、关注、收藏~</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/56a948995bbe2e2a1b6eef4479418d92/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【java SE语法篇】1. 运算符</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b25e77705c9db11643fb357783c1a08b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【算法专题】双指针算法之LCR 179. 查找总价格为目标值的两个商品（力扣）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>