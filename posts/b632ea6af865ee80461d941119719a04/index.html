<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言数据结构知识点小结(全） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b632ea6af865ee80461d941119719a04/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C语言数据结构知识点小结(全）">
  <meta property="og:description" content="Catologue C语言数据结构一、基本概念和术语二、时间、空间复杂度（1）时间复杂度（2）空间复杂度 三、类C语言有关操作补充1：数组定义补充2：动态内存分配补充3：C&#43;&#43;中的参数传递 四、线性表（1）定义（2）线性表的表示和实现1、线性表的==顺序==表示和实现2、顺序表的优缺点3、线性表的==链式==表示和实现a、单链表的实现b、单向循环链表的实现c、双向链表的实现d、双向循环链表的实现 4、链表的优缺点 （3）单链表、循环链表、双向链表的时间效率比较（4）顺序表和链表的比较（5）案例引入1、线性表的应用2、一元多项式的运算3、图书管理系统 五、栈和队列（1）栈（LIFO）（2）栈的表示和实现1、栈的==顺序==表示和实现2、栈的==链式==表示和实现 （3）栈与==递归==（4）队列（FIFO）（5）队列的表示和实现1、队列的==顺序==表示和实现2、队列的==链式==表示和实现 六、串、数组和广义表（1）串（2）串的表示和实现1、串的==顺序==表示2、串的==链式==表示3、串的模式匹配算法 （3）数组（4）数组的表示（5）广义表 七、树和二叉树（1）树（2）二叉树（3）二叉树的表示1、二叉树的==顺序==存储结构2、二叉树的==链式==存储结构 （4）二叉树的遍历1、==先序==遍历的实现2、==中序==遍历的实现3、==后序==遍历的实现4、中序遍历的==非递归==算法5、二叉树的==层次==遍历 （5）二叉树遍历算法的==应用==1、二叉树的建立2、复制二叉树3、计算二叉树的深度4、计算二叉树结点的总个数5、计算二叉树叶子结点的总个数 （6）==线索==二叉树（7）树的存储结构1、双亲表示法2、孩子链表3、孩子兄弟表示法（二叉树表示法）4、树和二叉树的转换5、森林和二叉树的转换 （8）树与森林的遍历1、树的遍历2、森林的遍历 （9）==哈夫曼树==（10）哈夫曼树的表示1、哈夫曼树的==顺序==存储结构 （11）哈夫曼编码 八、图（1）图的定义（2）图的表示1、==数组==（邻接矩阵）表示法2、==链表==（邻接表）表示法 （3）图的遍历1、==深度==优先搜索遍历（Depth First Search --- DFS）2、==广度==优先搜索遍历（Breath First Search --- BFS） （4）图的应用1、最小生成树2、最短路径3、拓扑排序4、关键路径 九、查找（1） 查找表（2）线性表的查找1、顺序查找（线性查找）2、二分查找3、分块查找 （3）树表的查找（4）==哈希表==的查找 十、排序（1）插入排序1、直接插入排序2、折半插入排序3、==希尔==排序 （2）交换排序1、冒泡排序2、==快速==排序 （3）选择排序1、直接选择排序2、==堆==排序 （4）归并排序（5）基数排序（6）排序算法小结 附录A- ASCII C语言数据结构 一、基本概念和术语 **数据（data）**是对客观事物的符号表示。
**数据元素（data element）**是数据中的基本单位，在计算机程序中作为一个整体进行考虑和处理。
**数据对象（data object）**是性质相同的数据元素的集合，是数据的一个子集。
数据结构（data structrue）是相互之间存在一种或多种特定关系的数据元素的集合。通常有以下4类基本逻辑结构：1、集合，结构中的数据元素之间除了同属于一个集合的关系外，别无其他关系；2、线性结构，结构中的数据元素之间存在一个对一个的关系；3、树形结构，结构中的元素之间存在一个对多个的关系；4、图状结构或网状结构，结构种的数据元素之间存在多个对多个的关系。存储结构也有四种：1、顺序结构，2、链式结构，3、索引结构，4、散列结构
C语言缺少类这一关键字，所以一般使用结构体和函数搭配起来构造数据类型，举个例子构造复数数据类型:
//定义复数数据类型 #include &lt;stdio.h&gt; typedef struct { float realpart; float imagpart; } Complex; void assign(Complex* A, float real, float image); void add(Complex* C, const Complex A, const Complex B); void minus(Complex* C, const Complex A, const Complex B); void multiply(Complex* C, const Complex A, const Complex B); void divide(Complex* C, const Complex A, const Complex B); void assign(Complex* A, float real, float imag) { A-&gt;realpart = real; A-&gt;imagpart = imag; } void add(Complex* C, const Complex A, const Complex B) { C-&gt;realpart = A.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2022-07-14T16:05:22+08:00">
    <meta property="article:modified_time" content="2022-07-14T16:05:22+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言数据结构知识点小结(全）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>Catologue</h4> 
 <ul><li><a href="#C_4" rel="nofollow">C语言数据结构</a></li><li><ul><li><a href="#_10" rel="nofollow">一、基本概念和术语</a></li><li><a href="#_73" rel="nofollow">二、时间、空间复杂度</a></li><li><ul><li><a href="#1_75" rel="nofollow">（1）时间复杂度</a></li><li><a href="#2_122" rel="nofollow">（2）空间复杂度</a></li></ul> 
   </li><li><a href="#C_135" rel="nofollow">三、类C语言有关操作</a></li><li><ul><li><ul><li><a href="#1_137" rel="nofollow">补充1：数组定义</a></li><li><a href="#2_142" rel="nofollow">补充2：动态内存分配</a></li><li><a href="#3C_150" rel="nofollow">补充3：C++中的参数传递</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_162" rel="nofollow">四、线性表</a></li><li><ul><li><a href="#1_164" rel="nofollow">（1）定义</a></li><li><a href="#2_178" rel="nofollow">（2）线性表的表示和实现</a></li><li><ul><li><a href="#1_180" rel="nofollow">1、线性表的==顺序==表示和实现</a></li><li><a href="#2_419" rel="nofollow">2、顺序表的优缺点</a></li><li><a href="#3_425" rel="nofollow">3、线性表的==链式==表示和实现</a></li><li><ul><li><a href="#a_460" rel="nofollow">a、单链表的实现</a></li><li><a href="#b_819" rel="nofollow">b、单向循环链表的实现</a></li><li><a href="#c_844" rel="nofollow">c、双向链表的实现</a></li><li><a href="#d_883" rel="nofollow">d、双向循环链表的实现</a></li></ul> 
     </li><li><a href="#4_888" rel="nofollow">4、链表的优缺点</a></li></ul> 
    </li><li><a href="#3_893" rel="nofollow">（3）单链表、循环链表、双向链表的时间效率比较</a></li><li><a href="#4_898" rel="nofollow">（4）顺序表和链表的比较</a></li><li><a href="#5_903" rel="nofollow">（5）案例引入</a></li><li><ul><li><a href="#1_905" rel="nofollow">1、线性表的应用</a></li><li><a href="#2_936" rel="nofollow">2、一元多项式的运算</a></li><li><a href="#3_961" rel="nofollow">3、图书管理系统</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_971" rel="nofollow">五、栈和队列</a></li><li><ul><li><a href="#1LIFO_975" rel="nofollow">（1）栈（LIFO）</a></li><li><a href="#2_984" rel="nofollow">（2）栈的表示和实现</a></li><li><ul><li><a href="#1_986" rel="nofollow">1、栈的==顺序==表示和实现</a></li><li><a href="#2_1177" rel="nofollow">2、栈的==链式==表示和实现</a></li></ul> 
    </li><li><a href="#3_1373" rel="nofollow">（3）栈与==递归==</a></li><li><a href="#4FIFO_1390" rel="nofollow">（4）队列（FIFO）</a></li><li><a href="#5_1394" rel="nofollow">（5）队列的表示和实现</a></li><li><ul><li><a href="#1_1396" rel="nofollow">1、队列的==顺序==表示和实现</a></li><li><a href="#2_1576" rel="nofollow">2、队列的==链式==表示和实现</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_1751" rel="nofollow">六、串、数组和广义表</a></li><li><ul><li><a href="#1_1753" rel="nofollow">（1）串</a></li><li><a href="#2_1766" rel="nofollow">（2）串的表示和实现</a></li><li><ul><li><a href="#1_1768" rel="nofollow">1、串的==顺序==表示</a></li><li><a href="#2_1784" rel="nofollow">2、串的==链式==表示</a></li><li><a href="#3_1808" rel="nofollow">3、串的模式匹配算法</a></li></ul> 
    </li><li><a href="#3_1858" rel="nofollow">（3）数组</a></li><li><a href="#4_1871" rel="nofollow">（4）数组的表示</a></li><li><a href="#5_1890" rel="nofollow">（5）广义表</a></li></ul> 
   </li><li><a href="#_1915" rel="nofollow">七、树和二叉树</a></li><li><ul><li><a href="#1_1917" rel="nofollow">（1）树</a></li><li><a href="#2_1931" rel="nofollow">（2）二叉树</a></li><li><a href="#3_1965" rel="nofollow">（3）二叉树的表示</a></li><li><ul><li><a href="#1_1969" rel="nofollow">1、二叉树的==顺序==存储结构</a></li><li><a href="#2_1991" rel="nofollow">2、二叉树的==链式==存储结构</a></li></ul> 
    </li><li><a href="#4_2030" rel="nofollow">（4）二叉树的遍历</a></li><li><ul><li><a href="#1_2072" rel="nofollow">1、==先序==遍历的实现</a></li><li><a href="#2_2087" rel="nofollow">2、==中序==遍历的实现</a></li><li><a href="#3_2095" rel="nofollow">3、==后序==遍历的实现</a></li><li><a href="#4_2110" rel="nofollow">4、中序遍历的==非递归==算法</a></li><li><a href="#5_2117" rel="nofollow">5、二叉树的==层次==遍历</a></li></ul> 
    </li><li><a href="#5_2129" rel="nofollow">（5）二叉树遍历算法的==应用==</a></li><li><ul><li><a href="#1_2131" rel="nofollow">1、二叉树的建立</a></li><li><a href="#2_2138" rel="nofollow">2、复制二叉树</a></li><li><a href="#3_2145" rel="nofollow">3、计算二叉树的深度</a></li><li><a href="#4_2152" rel="nofollow">4、计算二叉树结点的总个数</a></li><li><a href="#5_2161" rel="nofollow">5、计算二叉树叶子结点的总个数</a></li></ul> 
    </li><li><a href="#6_2168" rel="nofollow">（6）==线索==二叉树</a></li><li><a href="#7_2212" rel="nofollow">（7）树的存储结构</a></li><li><ul><li><a href="#1_2214" rel="nofollow">1、双亲表示法</a></li><li><a href="#2_2237" rel="nofollow">2、孩子链表</a></li><li><a href="#3_2266" rel="nofollow">3、孩子兄弟表示法（二叉树表示法）</a></li><li><a href="#4_2286" rel="nofollow">4、树和二叉树的转换</a></li><li><a href="#5_2305" rel="nofollow">5、森林和二叉树的转换</a></li></ul> 
    </li><li><a href="#8_2317" rel="nofollow">（8）树与森林的遍历</a></li><li><ul><li><a href="#1_2319" rel="nofollow">1、树的遍历</a></li><li><a href="#2_2323" rel="nofollow">2、森林的遍历</a></li></ul> 
    </li><li><a href="#9_2327" rel="nofollow">（9）==哈夫曼树==</a></li><li><a href="#10_2355" rel="nofollow">（10）哈夫曼树的表示</a></li><li><ul><li><a href="#1_2359" rel="nofollow">1、哈夫曼树的==顺序==存储结构</a></li></ul> 
    </li><li><a href="#11_2395" rel="nofollow">（11）哈夫曼编码</a></li></ul> 
   </li><li><a href="#_2424" rel="nofollow">八、图</a></li><li><ul><li><a href="#1_2426" rel="nofollow">（1）图的定义</a></li><li><a href="#2_2459" rel="nofollow">（2）图的表示</a></li><li><ul><li><a href="#1_2463" rel="nofollow">1、==数组==（邻接矩阵）表示法</a></li><li><a href="#2_2516" rel="nofollow">2、==链表==（邻接表）表示法</a></li></ul> 
    </li><li><a href="#3_2572" rel="nofollow">（3）图的遍历</a></li><li><ul><li><a href="#1Depth_First_Search__DFS_2581" rel="nofollow">1、==深度==优先搜索遍历（Depth First Search --- DFS）</a></li><li><a href="#2Breath_First_Search__BFS_2591" rel="nofollow">2、==广度==优先搜索遍历（Breath First Search --- BFS）</a></li></ul> 
    </li><li><a href="#4_2601" rel="nofollow">（4）图的应用</a></li><li><ul><li><a href="#1_2603" rel="nofollow">1、最小生成树</a></li><li><a href="#2_2632" rel="nofollow">2、最短路径</a></li><li><a href="#3_2652" rel="nofollow">3、拓扑排序</a></li><li><a href="#4_2666" rel="nofollow">4、关键路径</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_2685" rel="nofollow">九、查找</a></li><li><ul><li><a href="#1__2687" rel="nofollow">（1） 查找表</a></li><li><a href="#2_2695" rel="nofollow">（2）线性表的查找</a></li><li><ul><li><a href="#1_2697" rel="nofollow">1、顺序查找（线性查找）</a></li><li><a href="#2_2721" rel="nofollow">2、二分查找</a></li><li><a href="#3_2746" rel="nofollow">3、分块查找</a></li></ul> 
    </li><li><a href="#3_2761" rel="nofollow">（3）树表的查找</a></li><li><a href="#4_2800" rel="nofollow">（4）==哈希表==的查找</a></li></ul> 
   </li><li><a href="#_2855" rel="nofollow">十、排序</a></li><li><ul><li><a href="#1_2872" rel="nofollow">（1）插入排序</a></li><li><ul><li><a href="#1_2884" rel="nofollow">1、直接插入排序</a></li><li><a href="#2_2902" rel="nofollow">2、折半插入排序</a></li><li><a href="#3_2915" rel="nofollow">3、==希尔==排序</a></li></ul> 
    </li><li><a href="#2_2935" rel="nofollow">（2）交换排序</a></li><li><ul><li><a href="#1_2937" rel="nofollow">1、冒泡排序</a></li><li><a href="#2_2954" rel="nofollow">2、==快速==排序</a></li></ul> 
    </li><li><a href="#3_2981" rel="nofollow">（3）选择排序</a></li><li><ul><li><a href="#1_2985" rel="nofollow">1、直接选择排序</a></li><li><a href="#2_2990" rel="nofollow">2、==堆==排序</a></li></ul> 
    </li><li><a href="#4_3048" rel="nofollow">（4）归并排序</a></li><li><a href="#5_3060" rel="nofollow">（5）基数排序</a></li><li><a href="#6_3064" rel="nofollow">（6）排序算法小结</a></li></ul> 
   </li><li><a href="#A_ASCII_3075" rel="nofollow">附录A- ASCII</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="C_4"></a>C语言数据结构</h2> 
<p><img src="https://images2.imgbox.com/96/08/PNz75Ur2_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h3><a id="_10"></a>一、基本概念和术语</h3> 
<blockquote> 
 <p>**数据（data）**是对客观事物的符号表示。</p> 
 <p>**数据元素（data element）**是数据中的基本单位，在计算机程序中作为一个整体进行考虑和处理。</p> 
 <p>**数据对象（data object）**是性质相同的数据元素的集合，是数据的一个子集。</p> 
 <p><strong>数据结构（data structrue）<strong>是相互之间存在一种或多种特定关系的数据元素的集合。通常有以下4类基本</strong>逻辑结构</strong>：1、<strong>集合</strong>，结构中的数据元素之间除了同属于一个集合的关系外，别无其他关系；2、<strong>线性结构</strong>，结构中的数据元素之间存在一个对一个的关系；3、<strong>树形结构</strong>，结构中的元素之间存在一个对多个的关系；4、<strong>图状结构或网状结构</strong>，结构种的数据元素之间存在多个对多个的关系。<strong>存储结构</strong>也有四种：1、顺序结构，2、链式结构，3、索引结构，4、散列结构</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/50/91/X9y80Fcz_o.png" alt="在这里插入图片描述"></p> 
<p>C语言缺少类这一关键字，所以一般使用结构体和函数搭配起来构造数据类型，举个例子构造复数数据类型:</p> 
<pre><code class="prism language-c"><span class="token comment">//定义复数数据类型</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">float</span> realpart<span class="token punctuation">;</span>
	<span class="token keyword">float</span> imagpart<span class="token punctuation">;</span>
<span class="token punctuation">}</span> Complex<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">assign</span><span class="token punctuation">(</span>Complex<span class="token operator">*</span> A<span class="token punctuation">,</span> <span class="token keyword">float</span> real<span class="token punctuation">,</span> <span class="token keyword">float</span> image<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>Complex<span class="token operator">*</span> C<span class="token punctuation">,</span> <span class="token keyword">const</span> Complex A<span class="token punctuation">,</span> <span class="token keyword">const</span> Complex B<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">minus</span><span class="token punctuation">(</span>Complex<span class="token operator">*</span> C<span class="token punctuation">,</span> <span class="token keyword">const</span> Complex A<span class="token punctuation">,</span> <span class="token keyword">const</span> Complex B<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">multiply</span><span class="token punctuation">(</span>Complex<span class="token operator">*</span> C<span class="token punctuation">,</span> <span class="token keyword">const</span> Complex A<span class="token punctuation">,</span> <span class="token keyword">const</span> Complex B<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">divide</span><span class="token punctuation">(</span>Complex<span class="token operator">*</span> C<span class="token punctuation">,</span> <span class="token keyword">const</span> Complex A<span class="token punctuation">,</span> <span class="token keyword">const</span> Complex B<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">assign</span><span class="token punctuation">(</span>Complex<span class="token operator">*</span> A<span class="token punctuation">,</span> <span class="token keyword">float</span> real<span class="token punctuation">,</span> <span class="token keyword">float</span> imag<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	A<span class="token operator">-&gt;</span>realpart <span class="token operator">=</span> real<span class="token punctuation">;</span>
	A<span class="token operator">-&gt;</span>imagpart <span class="token operator">=</span> imag<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>Complex<span class="token operator">*</span> C<span class="token punctuation">,</span> <span class="token keyword">const</span> Complex A<span class="token punctuation">,</span> <span class="token keyword">const</span> Complex B<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	C<span class="token operator">-&gt;</span>realpart <span class="token operator">=</span> A<span class="token punctuation">.</span>realpart <span class="token operator">+</span> B<span class="token punctuation">.</span>realpart<span class="token punctuation">;</span>
	C<span class="token operator">-&gt;</span>imagpart <span class="token operator">=</span> A<span class="token punctuation">.</span>imagpart <span class="token operator">+</span> B<span class="token punctuation">.</span>imagpart<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">minus</span><span class="token punctuation">(</span>Complex<span class="token operator">*</span> C<span class="token punctuation">,</span> <span class="token keyword">const</span> Complex A<span class="token punctuation">,</span> <span class="token keyword">const</span> Complex B<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	C<span class="token operator">-&gt;</span>realpart <span class="token operator">=</span> A<span class="token punctuation">.</span>realpart <span class="token operator">-</span> B<span class="token punctuation">.</span>realpart<span class="token punctuation">;</span>
	C<span class="token operator">-&gt;</span>imagpart <span class="token operator">=</span> A<span class="token punctuation">.</span>imagpart <span class="token operator">-</span> B<span class="token punctuation">.</span>imagpart<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">multiply</span><span class="token punctuation">(</span>Complex<span class="token operator">*</span> C<span class="token punctuation">,</span> <span class="token keyword">const</span> Complex A<span class="token punctuation">,</span> <span class="token keyword">const</span> Complex B<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	C<span class="token operator">-&gt;</span>realpart <span class="token operator">=</span> A<span class="token punctuation">.</span>realpart <span class="token operator">*</span> B<span class="token punctuation">.</span>realpart <span class="token operator">-</span> A<span class="token punctuation">.</span>imagpart <span class="token operator">*</span> B<span class="token punctuation">.</span>imagpart<span class="token punctuation">;</span>
	C<span class="token operator">-&gt;</span>imagpart <span class="token operator">=</span> A<span class="token punctuation">.</span>realpart <span class="token operator">*</span> B<span class="token punctuation">.</span>imagpart <span class="token operator">+</span> A<span class="token punctuation">.</span>imagpart <span class="token operator">*</span> B<span class="token punctuation">.</span>realpart<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">divide</span><span class="token punctuation">(</span>Complex<span class="token operator">*</span> C<span class="token punctuation">,</span> <span class="token keyword">const</span> Complex A<span class="token punctuation">,</span> <span class="token keyword">const</span> Complex B<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Complex temp<span class="token punctuation">;</span>
	Complex B1<span class="token punctuation">;</span>
	B1<span class="token punctuation">.</span>realpart <span class="token operator">=</span> B<span class="token punctuation">.</span>realpart<span class="token punctuation">;</span>
	B1<span class="token punctuation">.</span>imagpart <span class="token operator">=</span> <span class="token operator">-</span>B<span class="token punctuation">.</span>imagpart<span class="token punctuation">;</span>
	<span class="token function">multiply</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>temp<span class="token punctuation">,</span> A<span class="token punctuation">,</span> B1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	C<span class="token operator">-&gt;</span>realpart <span class="token operator">=</span> temp<span class="token punctuation">.</span>realpart <span class="token operator">/</span> <span class="token punctuation">(</span>B<span class="token punctuation">.</span>realpart <span class="token operator">*</span> B<span class="token punctuation">.</span>realpart <span class="token operator">+</span> B<span class="token punctuation">.</span>imagpart <span class="token operator">*</span> B<span class="token punctuation">.</span>imagpart<span class="token punctuation">)</span><span class="token punctuation">;</span>
	C<span class="token operator">-&gt;</span>imagpart <span class="token operator">=</span> temp<span class="token punctuation">.</span>imagpart <span class="token operator">/</span> <span class="token punctuation">(</span>B<span class="token punctuation">.</span>realpart <span class="token operator">*</span> B<span class="token punctuation">.</span>realpart <span class="token operator">+</span> B<span class="token punctuation">.</span>imagpart <span class="token operator">*</span> B<span class="token punctuation">.</span>imagpart<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h3><a id="_73"></a>二、时间、空间复杂度</h3> 
<h4><a id="1_75"></a>（1）时间复杂度</h4> 
<p>算法的时间效率分析采用事前分析法</p> 
<p><img src="https://images2.imgbox.com/0e/08/JeQSANgy_o.png" alt="在这里插入图片描述"></p> 
<p>​ 我们假设执行每条语句所需的时间均为单位时间。此时对算法的运行时间的讨论就可以转化为讨论该算法中所有语句的执行次数，即语句频度之和。举一个例子：<br> <img src="https://images2.imgbox.com/92/3b/CNvmmu7o_o.png" alt="在这里插入图片描述"></p> 
<p>该算法的时间效率就为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
         = 
        
       
         2 
        
        
        
          n 
         
        
          3 
         
        
       
         + 
        
       
         3 
        
        
        
          n 
         
        
          2 
         
        
       
         + 
        
       
         2 
        
       
         n 
        
       
         + 
        
       
         1 
        
       
      
        T(n)=2n^3+3n^2+2n+1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.897438em; vertical-align: -0.08333em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.897438em; vertical-align: -0.08333em;"></span><span class="mord">3</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>，但是这样计算过于麻烦，于是，为了比较不同算法的时间效率，我们仅仅比较它们的<strong>数量级</strong>。该算法的时间效率即为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
        
        
          n 
         
        
          3 
         
        
       
         ) 
        
       
      
        O(n^3) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>。</p> 
<p>​ 引入<mark>时间复杂度</mark>的概念：一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
      
        f(n) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>算法的时间度量记作</p> 
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          T 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          = 
         
        
          O 
         
        
          ( 
         
        
          f 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          ) 
         
        
       
         T(n)=O(f(n)) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></span><br> 它表示随问题规模n的增大，算法执行时间的增长和f(n)的增长率相同，称作算法的<mark>渐进时间复杂度</mark>，简称<mark>时间复杂度</mark>。其中<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
      
        O 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span></span></span></span></span>是数量级符号<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         r 
        
       
         d 
        
       
         e 
        
       
         r 
        
       
      
        Order 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span></span></span></span></span>。</p> 
<p><img src="https://images2.imgbox.com/77/0d/4ylgfvKW_o.png" alt="在这里插入图片描述"></p> 
<p>时间复杂度定义中所指的基本语句是在算法的执行过程中重复最多的语句，<mark>时间复杂度实际上是由嵌套层次最深语句的频度决定的</mark>。例如：</p> 
<p><img src="https://images2.imgbox.com/02/2a/6baXTWwO_o.png" alt="在这里插入图片描述"></p> 
<p>对于较为复杂的时间复杂度计算问题，可以采用<strong>级数的方法来进行计算</strong>，例如：</p> 
<p><img src="https://images2.imgbox.com/3c/a3/hIOd0vnA_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>在考虑算法的时间复杂度时，还需要考虑问题的规模和问题的形式，因此，出现了：</p> 
 <p><strong>最坏时间复杂度</strong>：指在最坏的情况下，算法的时间复杂度。</p> 
 <p><strong>最好时间复杂度</strong>：指在最优的情况下，算法的时间复杂度。</p> 
 <p><strong>平均时间复杂度</strong>：指在所有可能输入实例等概率出现的情况下，算法的期望运行时间。</p> 
 <p>对于复杂的算法，可以将它分成几个容易估算的部分，然后利用大<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
       
         O 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span></span></span></span></span>的运算规则，计算算法的时间复杂度：</p> 
 <p><strong>加法规则</strong>：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          T 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          = 
         
        
          T 
         
        
          1 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          + 
         
        
          T 
         
        
          2 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          = 
         
        
          O 
         
        
          ( 
         
        
          f 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          ) 
         
        
          + 
         
        
          O 
         
        
          ( 
         
        
          g 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          ) 
         
        
          = 
         
        
          O 
         
        
          ( 
         
        
          m 
         
        
          a 
         
        
          x 
         
        
          ( 
         
        
          f 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          , 
         
        
          g 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          ) 
         
        
          ) 
         
        
       
         T(n)=T1(n)+T2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n))) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p> 
 <p><strong>乘法规则</strong>：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          T 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          = 
         
        
          T 
         
        
          1 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          × 
         
        
          T 
         
        
          2 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          = 
         
        
          O 
         
        
          ( 
         
        
          f 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          ) 
         
        
          × 
         
        
          O 
         
        
          ( 
         
        
          g 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          ) 
         
        
          = 
         
        
          O 
         
        
          ( 
         
        
          f 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          × 
         
        
          g 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          ) 
         
        
       
         T(n)=T1(n) \times T2(n)=O(f(n)) \times O(g(n))=O(f(n) \times g(n)) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p> 
</blockquote> 
<h4><a id="2_122"></a>（2）空间复杂度</h4> 
<p>​ 引入空间复杂度的概念：<mark>空间复杂度</mark>作为算法所需存储空间的度量，记作<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          S 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          = 
         
        
          O 
         
        
          ( 
         
        
          f 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          ) 
         
        
       
         S(n)=O(f(n)) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></span><br> 其中<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
      
        n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>为问题大小的规模。算法要占据的空间包括，算法本身要占据的空间，输入/输出，指令，常数，变量等，算法在执行时所需的辅助空间。</p> 
<p>例题：<br> <img src="https://images2.imgbox.com/52/be/YTCwMtDt_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h3><a id="C_135"></a>三、类C语言有关操作</h3> 
<h5><a id="1_137"></a>补充1：数组定义</h5> 
<p><img src="https://images2.imgbox.com/76/80/TJIWeNRZ_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2_142"></a>补充2：动态内存分配</h5> 
<p><img src="https://images2.imgbox.com/12/eb/dEWPAoNR_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/5d/03/yAF79ca3_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="3C_150"></a>补充3：C++中的参数传递</h5> 
<p><img src="https://images2.imgbox.com/63/b0/5ahjuxC0_o.png" alt="在这里插入图片描述"></p> 
<p>C++特有的引用类型作为参数：</p> 
<p><img src="https://images2.imgbox.com/77/e6/8tDOKHIZ_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h3><a id="_162"></a>四、线性表</h3> 
<h4><a id="1_164"></a>（1）定义</h4> 
<p>​ <mark>线性表</mark>是具有相同特性元素的一个有限序列，数据元素之间是线性关系，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
         
          
          
            ( 
           
           
           
             a 
            
           
             1 
            
           
          
            , 
           
           
           
             a 
            
           
             2 
            
           
          
            , 
           
          
            … 
           
          
            , 
           
           
           
             a 
            
            
            
              i 
             
            
              − 
             
            
              1 
             
            
           
          
            , 
           
           
           
             a 
            
           
             i 
            
           
          
            , 
           
           
           
             a 
            
            
            
              i 
             
            
              + 
             
            
              1 
             
            
           
          
            , 
           
          
            … 
           
          
            , 
           
           
           
             a 
            
           
             n 
            
           
          
            ) 
           
          
         
           ⏟ 
          
         
         
         
           数 
          
         
           据 
          
         
           元 
          
         
           素 
          
         
        
       
      
        \underbrace{(a_1,a_2, \dots,a_{i-1},a_i,a_{i+1},\dots,a_n)}_{数据元素} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.848em; vertical-align: -1.098em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.75em;"><span class="" style="top: -1.902em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">数</span><span class="mord cjk_fallback mtight">据</span><span class="mord cjk_fallback mtight">元</span><span class="mord cjk_fallback mtight">素</span></span></span></span><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.75em;"><span class="svg-align" style="top: -2.102em;"><span class="pstrut" style="height: 3em;"></span><span class="stretchy" style="height: 0.548em; min-width: 1.6em;"><span class="brace-left" style="height: 0.548em;"> 
                 <svg width="400em" height="0.548em" viewbox="0 0 400000 548" preserveaspectratio="xMinYMin slice"> 
                  <path d="M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z"></path> 
                 </svg></span><span class="brace-center" style="height: 0.548em;"> 
                 <svg width="400em" height="0.548em" viewbox="0 0 400000 548" preserveaspectratio="xMidYMin slice"> 
                  <path d="M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z"></path> 
                 </svg></span><span class="brace-right" style="height: 0.548em;"> 
                 <svg width="400em" height="0.548em" viewbox="0 0 400000 548" preserveaspectratio="xMaxYMin slice"> 
                  <path d="M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z"></path> 
                 </svg></span></span></span><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.208331em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.208331em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.898em;"><span class=""></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.098em;"><span class=""></span></span></span></span></span></span></span></span></span>，起始元素称为线性起点，终端元素称为线性终点。</p> 
<blockquote> 
 <p>线性表具有如下的特点：</p> 
 <p>(1)存在唯一的一个被称为“第一个”的数据元素；</p> 
 <p>(2)存在唯一的一个被称为“最后一个”的数据元素；</p> 
 <p>(3)除第一个元素外，集合中的每个元素均只有一个前驱；</p> 
 <p>(4)除最后一个元素外，集合中的每个元素均只有一个后继。</p> 
</blockquote> 
<h4><a id="2_178"></a>（2）线性表的表示和实现</h4> 
<h5><a id="1_180"></a>1、线性表的<mark>顺序</mark>表示和实现</h5> 
<p>​ 线性表的顺序表示又称为<strong>顺序存储结构</strong>或者<strong>顺序映像</strong>。顺序存储的<strong>定义</strong>：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构。换句话说，以元素在计算机内存中**“物理位置相邻”**来表示线性表中数据元素之间的逻辑关系。由此，只要确定了存储线性表的起始位置，线性表中任一数据元素都可以随机存取，所以线性表的顺序结构是一种随机存取的存储结构。</p> 
<p>​ 顺序表中元素存储位置的计算：假设线性表中的每个元素需要占据<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         l 
        
       
      
        l 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span></span></span></span></span>个存储单元，则第<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         i 
        
       
         + 
        
       
         1 
        
       
      
        i+1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.74285em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>个数据元素的存储位置和第<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         i 
        
       
      
        i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span>个数据元素的存储位置之间的关系满足<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          L 
         
        
          O 
         
        
          C 
         
        
          ( 
         
         
         
           a 
          
          
          
            i 
           
          
            + 
           
          
            1 
           
          
         
        
          ) 
         
        
          = 
         
        
          L 
         
        
          O 
         
        
          C 
         
        
          ( 
         
         
         
           a 
          
         
           i 
          
         
        
          ) 
         
        
          + 
         
        
          l 
         
        
       
         LOC(a_{i+1})=LOC(a_i)+l 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mord mathdefault" style="margin-right: 0.07153em;">C</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.208331em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mord mathdefault" style="margin-right: 0.07153em;">C</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span></span></span></span></span></span><br> 由此，所有数据元素的存储位置均可由第一个数据元素的存储位置得到：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          L 
         
        
          O 
         
        
          C 
         
        
          ( 
         
         
         
           a 
          
         
           i 
          
         
        
          ) 
         
        
          = 
         
        
          L 
         
        
          O 
         
        
          C 
         
        
          ( 
         
         
         
           a 
          
         
           1 
          
         
        
          ) 
         
        
          + 
         
        
          ( 
         
        
          i 
         
        
          − 
         
        
          1 
         
        
          ) 
         
        
          × 
         
        
          l 
         
        
       
         LOC(a_i)=LOC(a_1)+(i-1)\times{l} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mord mathdefault" style="margin-right: 0.07153em;">C</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mord mathdefault" style="margin-right: 0.07153em;">C</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span></span></span></span></span></span></span><br> 由此可以看出顺序表的特点是：1、以物理位置表示相邻的逻辑关系；2、任意的元素均可以快速访问，故称为<mark>随机存取</mark>。</p> 
<p><img src="https://images2.imgbox.com/1e/6b/aixMO0ll_o.png" alt="在这里插入图片描述"></p> 
<p>顺序表（Sequence List）的类型定义模板：</p> 
<pre><code class="prism language-c"><span class="token comment">//顺序表定义模板</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LIST_INIT_SIZE</span> <span class="token expression"><span class="token number">100</span>		</span><span class="token comment">//顺序表存储空间的初始分配</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
    ElemType<span class="token operator">*</span> elem<span class="token punctuation">;</span>			<span class="token comment">//数据指针，动态分配存储空间</span>
   <span class="token keyword">int</span> length<span class="token punctuation">;</span>		<span class="token comment">//当前的长度</span>
<span class="token punctuation">}</span> SqList<span class="token punctuation">;</span>
</code></pre> 
<p>使用类型定义模板的案例：</p> 
<p><img src="https://images2.imgbox.com/d3/07/TxOhTM2O_o.png" alt="在这里插入图片描述"></p> 
<p>顺序表的示意图：</p> 
<p><img src="https://images2.imgbox.com/28/82/K8ELI8vY_o.png" alt="在这里插入图片描述"></p> 
<p>在一些较为复杂的时间复杂度计算的问题中，我们往往采用问题的<strong>时间复杂度期望</strong>来作为整体问题的复杂度，例如在顺序表中计算插入算法的时间复杂度或者是计算删除算法的时间复杂度：</p> 
<p><img src="https://images2.imgbox.com/f5/8b/h19ppwH2_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/28/d4/KagaqPqr_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c"><span class="token comment">//头文件包含</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token comment">//函数结果状态代码</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TRUE</span> <span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FALSE</span> <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">OK</span> <span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ERROR</span> <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">INFEASIBLE</span> <span class="token expression"><span class="token operator">-</span><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">OVERFLOW</span> <span class="token expression"><span class="token operator">-</span><span class="token number">2</span></span></span>
<span class="token comment">//Status 是函数的类型，其值是函数结果状态代码</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> Status<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">char</span> ElemType<span class="token punctuation">;</span>
<span class="token comment">//顺序表的定义</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXSIZE</span> <span class="token expression"><span class="token number">100</span></span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	ElemType<span class="token operator">*</span> elem<span class="token punctuation">;</span>
	<span class="token keyword">int</span> length<span class="token punctuation">;</span>
<span class="token punctuation">}</span> SqList<span class="token punctuation">;</span>

<span class="token comment">//顺序表的初始化函数</span>
Status <span class="token function">InitList_Sq</span><span class="token punctuation">(</span>SqList<span class="token operator">*</span> L<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	L<span class="token operator">-&gt;</span>elem <span class="token operator">=</span> <span class="token punctuation">(</span>ElemType<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>MAXSIZE <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>ElemType<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>L<span class="token operator">-&gt;</span>elem<span class="token punctuation">)</span>
		<span class="token function">exit</span><span class="token punctuation">(</span>OVERFLOW<span class="token punctuation">)</span><span class="token punctuation">;</span>
	L<span class="token operator">-&gt;</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//销毁线性表</span>
<span class="token keyword">void</span> <span class="token function">DestroyList_Sq</span><span class="token punctuation">(</span>SqList<span class="token operator">*</span> L<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">-&gt;</span>elem<span class="token punctuation">)</span>
		<span class="token function">free</span><span class="token punctuation">(</span>L<span class="token operator">-&gt;</span>elem<span class="token punctuation">)</span><span class="token punctuation">;</span>
	L <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//清空线性表</span>
<span class="token keyword">void</span> <span class="token function">ClearList</span><span class="token punctuation">(</span>SqList<span class="token operator">*</span> L<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	L<span class="token operator">-&gt;</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//求线性表的长度</span>
<span class="token keyword">int</span> <span class="token function">GetLength</span><span class="token punctuation">(</span><span class="token keyword">const</span> SqList<span class="token operator">*</span> L<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> L<span class="token operator">-&gt;</span>length<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//判断线性表是否为空</span>
Status <span class="token function">IsEmpty</span><span class="token punctuation">(</span><span class="token keyword">const</span> SqList<span class="token operator">*</span> L<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">-&gt;</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> TRUE<span class="token punctuation">;</span>
	<span class="token keyword">else</span>
		<span class="token keyword">return</span> FALSE<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//线性表取第i个值</span>
Status <span class="token function">GetElem</span><span class="token punctuation">(</span><span class="token keyword">const</span> SqList<span class="token operator">*</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> ElemType e<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token number">1</span> <span class="token operator">||</span> i<span class="token operator">&gt;</span>L<span class="token operator">-&gt;</span>length<span class="token punctuation">)</span>
		<span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		e <span class="token operator">=</span> L<span class="token operator">-&gt;</span>elem<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> OK<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//线性表按值顺序查找</span>
Status <span class="token function">LocateElem</span><span class="token punctuation">(</span><span class="token keyword">const</span> SqList<span class="token operator">*</span> L<span class="token punctuation">,</span> <span class="token keyword">const</span> ElemType e<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> i<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> L<span class="token operator">-&gt;</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">-&gt;</span>elem<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> e<span class="token punctuation">)</span>
			<span class="token keyword">return</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>		<span class="token comment">//查找成功返回元素位置</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>		<span class="token comment">//查找失败返回0</span>
<span class="token punctuation">}</span>
<span class="token comment">//顺序表的插入</span>
Status <span class="token function">InsertList_Sq</span><span class="token punctuation">(</span>SqList<span class="token operator">*</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">const</span> ElemType e<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> i<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">&lt;=</span> L<span class="token operator">-&gt;</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>	<span class="token comment">//判断插入位置是否合法</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">-&gt;</span>length <span class="token operator">==</span> MAXSIZE<span class="token punctuation">)</span>		<span class="token comment">//判断存储空间是否已满</span>
			<span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>L<span class="token operator">-&gt;</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&gt;=</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>		<span class="token comment">//插入位置及之后元素后移</span>
		<span class="token punctuation">{<!-- --></span>
			L<span class="token operator">-&gt;</span>elem<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token operator">-&gt;</span>elem<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		L<span class="token operator">-&gt;</span>elem<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
		L<span class="token operator">-&gt;</span>length <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> OK<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//顺序表删除</span>
Status <span class="token function">DeleteElem</span><span class="token punctuation">(</span>SqList<span class="token operator">*</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> i<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">&lt;=</span> L<span class="token operator">-&gt;</span>length<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		L<span class="token operator">-&gt;</span>elem<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>		<span class="token comment">//删除指定元素</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> L<span class="token operator">-&gt;</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>		<span class="token comment">//剩余元素移位</span>
		<span class="token punctuation">{<!-- --></span>
			L<span class="token operator">-&gt;</span>elem<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token operator">-&gt;</span>elem<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		L<span class="token operator">-&gt;</span>length<span class="token operator">--</span><span class="token punctuation">;</span>		<span class="token comment">//顺序表长度-1</span>
		<span class="token keyword">return</span> OK<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//顺序表显示</span>
<span class="token keyword">void</span> <span class="token function">ShowList_Sq</span><span class="token punctuation">(</span><span class="token keyword">const</span> SqList<span class="token operator">*</span> L<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">-&gt;</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"The SqList is empty!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> i<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> L<span class="token operator">-&gt;</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> L<span class="token operator">-&gt;</span>elem<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">putchar</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The length of SqList is %d\n"</span><span class="token punctuation">,</span> L<span class="token operator">-&gt;</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//合并两个顺序表,将L2合并到L1中</span>
Status <span class="token function">MergeList_Sq</span><span class="token punctuation">(</span>SqList<span class="token operator">*</span> L1<span class="token punctuation">,</span> <span class="token keyword">const</span> SqList<span class="token operator">*</span> L2<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>L1<span class="token operator">-&gt;</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> L2<span class="token operator">-&gt;</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Length must be non-zero!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>L1<span class="token operator">-&gt;</span>length <span class="token operator">+</span> L2<span class="token operator">-&gt;</span>length <span class="token operator">&gt;</span> MAXSIZE<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Overflow"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> OVERFLOW<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> 
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> i<span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> L2<span class="token operator">-&gt;</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			L1<span class="token operator">-&gt;</span>elem<span class="token punctuation">[</span>i <span class="token operator">+</span> L1<span class="token operator">-&gt;</span>length<span class="token punctuation">]</span> <span class="token operator">=</span> L2<span class="token operator">-&gt;</span>elem<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		L1<span class="token operator">-&gt;</span>length <span class="token operator">+=</span> L2<span class="token operator">-&gt;</span>length<span class="token punctuation">;</span>
		<span class="token keyword">return</span> OK<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>测试代码：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	SqList my_list<span class="token punctuation">;</span>
	ElemType a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> e<span class="token punctuation">,</span> f<span class="token punctuation">;</span>
	a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
	d <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
	e <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
	f <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>
	SqList my_list2<span class="token punctuation">;</span>
	<span class="token function">InitList_Sq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_list<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">InsertList_Sq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_list<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">InsertList_Sq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_list<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">InsertList_Sq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_list<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">InsertList_Sq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_list<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">InsertList_Sq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_list<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">InsertList_Sq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_list<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//printf("%d\n", LocateElem(&amp;my_list, a));</span>
	<span class="token comment">//ShowList_Sq(&amp;my_list);</span>
	<span class="token comment">//DeleteElem(&amp;my_list, 2);</span>
	<span class="token function">ShowList_Sq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_list<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">InitList_Sq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_list2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">InsertList_Sq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_list2<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">InsertList_Sq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_list2<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">InsertList_Sq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_list2<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">ShowList_Sq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_list2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">MergeList_Sq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>my_list2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">ShowList_Sq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_list<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="2_419"></a>2、顺序表的优缺点</h5> 
<blockquote> 
 <p>优点：1、存储密度大；2、可以随机存取表中任一元素。</p> 
 <p>缺点：1、在插入、删除某一元素时，需要移动大量其他元素；2、浪费大量存储空间；3、属于静态存储形式，数据元素的个数不能够自由扩充。</p> 
</blockquote> 
<h5><a id="3_425"></a>3、线性表的<mark>链式</mark>表示和实现</h5> 
<p>​ 线性表的链式结构的特点是用一组任意的存储单元存储线性表的数据元素（这种存储单元可以是连续的，也可以是不连续的）。因此，为了表示每个数据元素<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          a 
         
        
          i 
         
        
       
      
        a_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>与其直接后继数据元素<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          a 
         
         
         
           i 
          
         
           + 
          
         
           1 
          
         
        
       
      
        a_{i+1} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.638891em; vertical-align: -0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.208331em;"><span class=""></span></span></span></span></span></span></span></span></span></span>之间的逻辑关系，对数据元素<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          a 
         
        
          i 
         
        
       
      
        a_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>来说，除了本身的存储信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。这两部分信息组成数据元素<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          a 
         
        
          i 
         
        
       
      
        a_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>的存储映像，称为<strong>结点</strong>（node）。它包括两个域：其中存储信息数据元素信息的域被称为<strong>数据域</strong>；存储直接后继存储位置的域被称为<strong>指针域</strong>。指针域中存储的信息称为<strong>指针</strong>或<strong>链</strong>。<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
      
        n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>个结点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ( 
        
        
        
          a 
         
        
          i 
         
        
       
         ( 
        
       
         1 
        
       
         &lt; 
        
       
         = 
        
       
         i 
        
       
         &lt; 
        
       
         = 
        
       
         n 
        
       
         ) 
        
       
         ) 
        
       
      
        (a_i(1&lt;=i&lt;=n)) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.69862em; vertical-align: -0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span>的存储映像链结成一个<strong>链表</strong>，即为线性表<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          ( 
         
         
         
           a 
          
         
           1 
          
         
        
          , 
         
         
         
           a 
          
         
           2 
          
         
        
          , 
         
        
          … 
         
         
         
           , 
          
          
          
            a 
           
          
            n 
           
          
         
        
          ) 
         
        
       
         (a_1,a_2,\dots{,a_n}) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></span><br> 的<strong>链式</strong>存储结构。又由于此链表的每个结点中只包含一个指针域，故又称为<strong>线性链表</strong>或<strong>单链表</strong>。整个链表的存取必须从<strong>头指针</strong>开始，头指针指示链表中第一个结点（即第一个数据元素的存储映像）。</p> 
<p>​ 链式存储结构的特点：1、结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻。线性表的链式表示又称为<strong>非顺序映像</strong>或<strong>链式映像</strong>。2、访问时只能通过头指针进入链表，并通过每个结点的指针域依次向后顺序扫描其余结点，所以寻找第一个结点和最后一个结点所花费的时间不等，这种存取元素的方式称为<mark>顺序存取</mark>。</p> 
<p>链表（Link List）的分类：单链表、双链表、循环链表</p> 
<p><img src="https://images2.imgbox.com/2f/bf/s0EWpf2q_o.png" alt="在这里插入图片描述"></p> 
<p>单链表还分为是否带头结点两种情况：</p> 
<p><img src="https://images2.imgbox.com/5c/18/uiAUBGrk_o.png" alt="在这里插入图片描述"></p> 
<p>如何判断是否是空表：</p> 
<p><img src="https://images2.imgbox.com/14/fd/QyKHafQP_o.png" alt="在这里插入图片描述"></p> 
<p>设置链表的头结点有什么好处：</p> 
<p><img src="https://images2.imgbox.com/aa/de/e2456ohH_o.png" alt="在这里插入图片描述"></p> 
<p>头结点的数据域能够存放什么内容：</p> 
<p><img src="https://images2.imgbox.com/93/9e/slKcN9bI_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="a_460"></a>a、单链表的实现</h6> 
<p><img src="https://images2.imgbox.com/26/26/mEfm8vFW_o.png" alt="在这里插入图片描述"></p> 
<p>单链表的每个结点都可以通过一个结构体来表示：</p> 
<p><img src="https://images2.imgbox.com/36/32/6h3ZCLT0_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c"><span class="token comment">// 链表定义模板</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Lnode</span> <span class="token punctuation">{<!-- --></span>
	ElemType data<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">Lnode</span><span class="token operator">*</span> next<span class="token punctuation">;</span>			<span class="token comment">//注意这里需要struct关键字</span>
<span class="token punctuation">}</span>Lnode<span class="token punctuation">,</span> <span class="token operator">*</span>LinkList<span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/67/50/z1BYpST5_o.png" alt=""></p> 
<p>举个例子，定义一个学生链表：</p> 
<p><img src="https://images2.imgbox.com/dd/a0/P0wOyj0f_o.png" alt="在这里插入图片描述"></p> 
<p><strong>单链表基本操作的实现</strong>：</p> 
<ol><li>单链表的初始化</li></ol> 
<p><img src="https://images2.imgbox.com/b5/e4/vCSWHXF0_o.png" alt="在这里插入图片描述"></p> 
<ol start="2"><li>判断单链表是否为空</li></ol> 
<p><img src="https://images2.imgbox.com/f7/08/wvTB5NFl_o.png" alt="在这里插入图片描述"></p> 
<ol start="3"><li>单链表的销毁</li></ol> 
<p><img src="https://images2.imgbox.com/76/e1/jscgQ5ju_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/34/d4/4mfMwZrT_o.png" alt="在这里插入图片描述"></p> 
<ol start="4"><li>清空单链表<br> <img src="https://images2.imgbox.com/ea/d3/DE6P64P4_o.png" alt="在这里插入图片描述"></li></ol> 
<p><img src="https://images2.imgbox.com/80/6c/nH2oIaDi_o.png" alt="在这里插入图片描述"></p> 
<ol start="5"><li>求单链表的表长</li></ol> 
<p><img src="https://images2.imgbox.com/88/f2/zZLVnKLu_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/91/8d/0kTGQfGD_o.png" alt="在这里插入图片描述"></p> 
<ol start="6"><li>取单链表中第i个元素内容</li></ol> 
<p><img src="https://images2.imgbox.com/56/c1/oKDJCclH_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/f3/e9/eTJli7xg_o.png" alt="在这里插入图片描述"></p> 
<ol start="7"><li>单链表按值查找</li></ol> 
<p><img src="https://images2.imgbox.com/34/a9/t4KeWVdL_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/54/8d/3AvUQmbx_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/23/9c/M3GPZeZa_o.png" alt="在这里插入图片描述"></p> 
<ol start="8"><li>单链表插入，在第<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          i 
         
        
       
         i 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span>个结点的前面插入新结点</li></ol> 
<p><img src="https://images2.imgbox.com/b4/bb/ObrnIKNP_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/a8/85/VtAZPWjy_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/25/c5/HtEZ6PLq_o.png" alt="在这里插入图片描述"></p> 
<ol start="9"><li>单链表删除，删除第<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          i 
         
        
       
         i 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span>个结点</li></ol> 
<p><img src="https://images2.imgbox.com/69/c6/A8PaWEPt_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/3c/88/r1VkUzKB_o.png" alt="在这里插入图片描述"></p> 
<ol start="10"><li>单链表的建立–头插法<br> <img src="https://images2.imgbox.com/4f/9f/NHT3P8Zh_o.png" alt="在这里插入图片描述"></li></ol> 
<p><img src="https://images2.imgbox.com/f0/94/PWZlozGh_o.png" alt="在这里插入图片描述"></p> 
<ol start="11"><li>单链表的建立–尾插法</li></ol> 
<p><img src="https://images2.imgbox.com/78/a1/SbCalBKP_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/d0/52/eC41FsLj_o.png" alt="在这里插入图片描述"></p> 
<p><mark>单链表实现完整算法</mark>：</p> 
<pre><code class="prism language-c"><span class="token comment">//头文件导入</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token comment">//函数结果状态代码</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">OK</span> <span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ERROR</span> <span class="token expression"><span class="token number">0</span></span></span>
<span class="token comment">//Status 是函数的类型，其值是函数结果状态代码</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> Status<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> ElemType<span class="token punctuation">;</span>
<span class="token comment">//单链表</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Signle_Link_List</span><span class="token punctuation">{<!-- --></span>
	ElemType data<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">LNode</span><span class="token operator">*</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span> LNode<span class="token punctuation">,</span> <span class="token operator">*</span>LinkList<span class="token punctuation">;</span>

<span class="token comment">//创建空链表</span>
Status <span class="token function">InitLinkList</span><span class="token punctuation">(</span>LinkList<span class="token operator">*</span> L<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token operator">*</span>L <span class="token operator">=</span> <span class="token punctuation">(</span>LinkList<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>L <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
	<span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//判断链表是否为空</span>
<span class="token keyword">int</span> <span class="token function">IsEmptyLinkList</span><span class="token punctuation">(</span><span class="token keyword">const</span> LinkList<span class="token operator">*</span> L<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token operator">-&gt;</span>next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span>
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//单链表的销毁</span>
Status <span class="token function">DestoryLinkList</span><span class="token punctuation">(</span>LinkList<span class="token operator">*</span> L<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	LNode<span class="token operator">*</span> p<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>L <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		p <span class="token operator">=</span> <span class="token operator">*</span>L<span class="token punctuation">;</span>
		<span class="token operator">*</span>L <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//清空单链表</span>
Status <span class="token function">ClearLinkList</span><span class="token punctuation">(</span>LinkList<span class="token operator">*</span> L<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	LNode<span class="token operator">*</span> p<span class="token punctuation">,</span> <span class="token operator">*</span> q<span class="token punctuation">;</span>
	q <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		p <span class="token operator">=</span> q<span class="token punctuation">;</span>
		q <span class="token operator">=</span> q<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//求单链表的表长</span>
<span class="token keyword">int</span> <span class="token function">LenLinkList</span><span class="token punctuation">(</span><span class="token keyword">const</span> LinkList<span class="token operator">*</span> L<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	LNode<span class="token operator">*</span> p<span class="token punctuation">;</span>
	p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		i<span class="token operator">++</span><span class="token punctuation">;</span>
		p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token operator">-&gt;</span>data <span class="token operator">=</span> i<span class="token punctuation">;</span>			<span class="token comment">//将长度存储到L头结点的数据域中</span>
	<span class="token keyword">return</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//取出单链表中第i个元素</span>
Status <span class="token function">LocateElem</span><span class="token punctuation">(</span><span class="token keyword">const</span> LinkList <span class="token operator">*</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> ElemType <span class="token operator">*</span>e<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	LNode<span class="token operator">*</span> p<span class="token punctuation">;</span>
	p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		j<span class="token operator">++</span><span class="token punctuation">;</span>
		p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p <span class="token operator">||</span> j <span class="token operator">&gt;</span> i<span class="token punctuation">)</span>		<span class="token comment">//如果待查找的元素大于链表长度或者小于1，查找错误</span>
		<span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
	<span class="token operator">*</span>e <span class="token operator">=</span> p<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>
	<span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//单链表按值查找,返回LNode</span>
LNode<span class="token operator">*</span> <span class="token function">LocateElem_V_LNode</span><span class="token punctuation">(</span><span class="token keyword">const</span> LinkList <span class="token operator">*</span>L<span class="token punctuation">,</span> ElemType value<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	LNode<span class="token operator">*</span> p<span class="token punctuation">;</span>
	p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">&amp;&amp;</span> p<span class="token operator">-&gt;</span>data <span class="token operator">!=</span> value<span class="token punctuation">)</span>		<span class="token comment">//p不为空指针，并且没找到</span>
	<span class="token punctuation">{<!-- --></span>
		p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> p<span class="token punctuation">;</span>			<span class="token comment">//找到返回结点的地址，没找到返回NULL</span>
<span class="token punctuation">}</span>
<span class="token comment">//单链表按值查找,返回元素位置</span>
<span class="token keyword">int</span> <span class="token function">LocateElem_V_Index</span><span class="token punctuation">(</span><span class="token keyword">const</span> LinkList <span class="token operator">*</span>L<span class="token punctuation">,</span> ElemType value<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	LNode<span class="token operator">*</span> p<span class="token punctuation">;</span>
	p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">&amp;&amp;</span> p<span class="token operator">-&gt;</span>data <span class="token operator">!=</span> value<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		j<span class="token operator">++</span><span class="token punctuation">;</span>
		p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>		<span class="token comment">//没找到,返回0</span>
	<span class="token keyword">else</span>
		<span class="token keyword">return</span> j<span class="token punctuation">;</span>		<span class="token comment">//找到,返回第几个结点</span>
<span class="token punctuation">}</span>
<span class="token comment">//单链表插入,在第i个结点之前插入一个结点</span>
Status <span class="token function">InsertLinkList</span><span class="token punctuation">(</span>LinkList <span class="token operator">*</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> ElemType value<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	LNode<span class="token operator">*</span> p<span class="token punctuation">;</span>
	p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>		<span class="token comment">//找到第i-1个结点</span>
	<span class="token punctuation">{<!-- --></span>
		j<span class="token operator">++</span><span class="token punctuation">;</span>
		p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p <span class="token operator">||</span> j <span class="token operator">&gt;</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>		<span class="token comment">//i大于表长+1,或者小于1,插入位置非法</span>
		<span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>

	LNode<span class="token operator">*</span> newlnode<span class="token punctuation">;</span>
	newlnode <span class="token operator">=</span> <span class="token punctuation">(</span>LNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	newlnode<span class="token operator">-&gt;</span>data <span class="token operator">=</span> value<span class="token punctuation">;</span>
	newlnode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	p<span class="token operator">-&gt;</span>next <span class="token operator">=</span> newlnode<span class="token punctuation">;</span>
	<span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//单链表删除,删除第i个结点</span>
Status <span class="token function">DeleteLinkList</span><span class="token punctuation">(</span>LinkList <span class="token operator">*</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	LNode<span class="token operator">*</span> p<span class="token punctuation">,</span> <span class="token operator">*</span> q<span class="token punctuation">;</span>
	<span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		j<span class="token operator">++</span><span class="token punctuation">;</span>
		p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p <span class="token operator">||</span> j <span class="token operator">&gt;</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>

	q <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	p<span class="token operator">-&gt;</span>next <span class="token operator">=</span> q<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//单链表建立-头插法</span>
<span class="token keyword">void</span> <span class="token function">CreateLinkList_H</span><span class="token punctuation">(</span>LinkList<span class="token operator">*</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token operator">*</span>L <span class="token operator">=</span> <span class="token punctuation">(</span>LinkList<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>					<span class="token comment">//先建立一个头结点</span>
	<span class="token keyword">int</span> i<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> n<span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		LNode<span class="token operator">*</span> newlnode<span class="token punctuation">;</span>
		newlnode <span class="token operator">=</span> <span class="token punctuation">(</span>LNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Enter the node data:_____\b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>newlnode<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
		newlnode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token operator">-&gt;</span>next <span class="token operator">=</span> newlnode<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//单链表建立-尾插法</span>
<span class="token keyword">void</span> <span class="token function">CreateLinkList_R</span><span class="token punctuation">(</span>LinkList <span class="token operator">*</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token operator">*</span>L <span class="token operator">=</span> <span class="token punctuation">(</span>LinkList<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>					<span class="token comment">//先建立一个头结点</span>
	LNode<span class="token operator">*</span> p<span class="token punctuation">;</span>
	p <span class="token operator">=</span> <span class="token operator">*</span>L<span class="token punctuation">;</span>
	<span class="token keyword">int</span> i<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> n<span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		LNode<span class="token operator">*</span> newlnode<span class="token punctuation">;</span>
		newlnode <span class="token operator">=</span> <span class="token punctuation">(</span>LNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Enter the node data:___\b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>newlnode<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
		newlnode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
		p<span class="token operator">-&gt;</span>next <span class="token operator">=</span> newlnode<span class="token punctuation">;</span>
		p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//显示单链表</span>
<span class="token keyword">void</span> <span class="token function">ShowLinkList</span><span class="token punctuation">(</span><span class="token keyword">const</span> LinkList<span class="token operator">*</span> L<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	LNode<span class="token operator">*</span> p<span class="token punctuation">;</span>
	p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"The LinkList is empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d : %d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
		i<span class="token operator">++</span><span class="token punctuation">;</span>
		p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">putchar</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>测试函数：</p> 
<pre><code class="prism language-c"><span class="token comment">//测试函数</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	LinkList my_list<span class="token punctuation">;</span>
	my_list <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	ElemType answer <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token comment">//InitLinkList(my_list);</span>
	<span class="token comment">//CreateLinkList_H(&amp;my_list, 3);		//测试头插法建立链表</span>
	<span class="token function">CreateLinkList_R</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_list<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">//测试尾插法建立链表</span>
	<span class="token comment">//ClearLinkList(&amp;my_list);				//测试清空链表</span>
	<span class="token function">ShowLinkList</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_list<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//DestoryLinkList(&amp;my_list);				//测试销毁链表</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span><span class="token function">IsEmptyLinkList</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_list<span class="token punctuation">)</span> <span class="token operator">&gt;</span><span class="token number">0</span><span class="token operator">?</span>
		<span class="token string">"LinkList is Empty"</span><span class="token operator">:</span><span class="token string">"LinkList isn't Empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//测试判断链表函数</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The length of LinkList is %d\n"</span><span class="token punctuation">,</span> <span class="token function">LenLinkList</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//测试求长度函数</span>
	<span class="token function">LocateElem</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_list<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>answer<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The %d elem is %d\n"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> answer<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//测试取元素函数</span>
	LNode <span class="token operator">*</span>answer1<span class="token punctuation">;</span>
	answer1 <span class="token operator">=</span> <span class="token function">LocateElem_V_LNode</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_list<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The answer is %d\n"</span><span class="token punctuation">,</span> answer1<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//测试取元素函数</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The Index of 3 is %d\n"</span><span class="token punctuation">,</span> <span class="token function">LocateElem_V_Index</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_list<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">//测试取元素函数</span>
	<span class="token function">InsertLinkList</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_list<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//测试增加结点函数</span>
	<span class="token function">ShowLinkList</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_list<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">DeleteLinkList</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_list<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">//测试删除结点函数</span>
	<span class="token function">ShowLinkList</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_list<span class="token punctuation">)</span><span class="token punctuation">;</span>					
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h6><a id="b_819"></a>b、单向循环链表的实现</h6> 
<p><img src="https://images2.imgbox.com/ad/d0/eo3rGFHR_o.png" alt="在这里插入图片描述"></p> 
<p>判断循环链表结束的条件：</p> 
<p><img src="https://images2.imgbox.com/5b/d5/WhYCrCak_o.png" alt="在这里插入图片描述"></p> 
<p>当循环链表需要经常使用头结点和尾结点的时候，循环链表通常使用<mark>尾指针</mark>表示法更简单：</p> 
<p><img src="https://images2.imgbox.com/a5/ae/Dc158bLc_o.png" alt="在这里插入图片描述"></p> 
<p><strong>循环链表的基本操作实现</strong></p> 
<ol><li>循环链表的合并</li></ol> 
<p><img src="https://images2.imgbox.com/06/c9/zXTo5AdC_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/9b/49/5co7B2JR_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="c_844"></a>c、双向链表的实现</h6> 
<p><img src="https://images2.imgbox.com/0c/fd/zbogGtlE_o.png" alt="在这里插入图片描述"></p> 
<p>双向链表的定义：</p> 
<p><img src="https://images2.imgbox.com/b0/08/6tztRWeV_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c"><span class="token comment">//双向链表的定义</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">DuLNode</span> <span class="token punctuation">{<!-- --></span>
	ElemType data<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">DuLNode</span><span class="token operator">*</span> prior<span class="token punctuation">,</span> <span class="token operator">*</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span> DuLNode<span class="token punctuation">,</span> <span class="token operator">*</span>DuLinkList<span class="token punctuation">;</span>
</code></pre> 
<p><strong>双向链表的操作</strong></p> 
<p><img src="https://images2.imgbox.com/fe/af/zC4jVaUy_o.png" alt="在这里插入图片描述"></p> 
<ol><li>双向链表的插入</li></ol> 
<p><img src="https://images2.imgbox.com/d5/6a/cw3M9aoU_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/97/a3/Q3OnK9TO_o.png" alt="在这里插入图片描述"></p> 
<ol start="2"><li>双向链表的删除</li></ol> 
<p><img src="https://images2.imgbox.com/05/fd/Gl0XGdvM_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/4c/51/RMt3BqMw_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="d_883"></a>d、双向循环链表的实现</h6> 
<p><img src="https://images2.imgbox.com/f3/ec/kd3GOfcc_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="4_888"></a>4、链表的优缺点</h5> 
<p><img src="https://images2.imgbox.com/62/c6/2oGY2nN2_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="3_893"></a>（3）单链表、循环链表、双向链表的时间效率比较</h4> 
<p><img src="https://images2.imgbox.com/99/7a/WrHMrxAo_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="4_898"></a>（4）顺序表和链表的比较</h4> 
<p><img src="https://images2.imgbox.com/8d/01/Uifva16d_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="5_903"></a>（5）案例引入</h4> 
<h5><a id="1_905"></a>1、线性表的应用</h5> 
<p>线性表的合并</p> 
<p><img src="https://images2.imgbox.com/73/89/AERv8ajb_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/04/0a/bBdwhcdd_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/ac/00/YgUraK2H_o.png" alt="在这里插入图片描述"></p> 
<p>有序表的合并</p> 
<p><img src="https://images2.imgbox.com/54/43/TL3dnJhN_o.png" alt="在这里插入图片描述"></p> 
<p>用顺序存储结构来实现</p> 
<p><img src="https://images2.imgbox.com/71/5e/mCCUuoxQ_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/ee/f6/Q1NlHfOi_o.png" alt="在这里插入图片描述"></p> 
<p>用链式存储结构来实现</p> 
<p><img src="https://images2.imgbox.com/d3/18/f1Mh6Nar_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2_936"></a>2、一元多项式的运算</h5> 
<p><img src="https://images2.imgbox.com/22/de/auWoSay7_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/91/a4/rGht2amN_o.png" alt="在这里插入图片描述"></p> 
<p>采用链式结构会更简单。</p> 
<p><img src="https://images2.imgbox.com/d0/ef/9bdRA8zX_o.png" alt="在这里插入图片描述"></p> 
<p>尾插法建立链表<br> <img src="https://images2.imgbox.com/d4/4c/keSKk9Rt_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/c2/6a/ceZGUfI0_o.png" alt="在这里插入图片描述"></p> 
<p>多项式相加</p> 
<p><img src="https://images2.imgbox.com/ec/63/fCrHhbal_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="3_961"></a>3、图书管理系统</h5> 
<p><img src="https://images2.imgbox.com/d8/8c/tnAlPvuW_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/f6/16/v5V3m9nA_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h3><a id="_971"></a>五、栈和队列</h3> 
<p>​ 栈和队列是两种重要的线性结构，从数据结构的角度来看，栈和队列也是线性表，其特殊性在于栈和队列的基本操作是线性表操作的子集，它们是操作受限的线性表，因此，可以称为限定数据类型。</p> 
<h4><a id="1LIFO_975"></a>（1）栈（LIFO）</h4> 
<p>​ **栈（stack）**是限定仅在表位进行插入或删除操作的线性表。对栈来说，表尾称为栈顶（Top），表头称为栈尾（Base）。换句话说，栈的修改是按后进先出的原则进行的。因此，栈又称为后进先出（last-in-first-out）的线性表（简称LIFO）。插入元素到栈顶称为入栈（压栈Push），从栈尾删除一个元素称为出栈（弹栈Pop）。</p> 
<p>栈和线性表有什么不同：</p> 
<p><img src="https://images2.imgbox.com/c6/10/vjxEFQB7_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2_984"></a>（2）栈的表示和实现</h4> 
<h5><a id="1_986"></a>1、栈的<mark>顺序</mark>表示和实现</h5> 
<p>栈的顺序表示又称为<strong>顺序栈</strong>，具体如下所示：</p> 
<p><img src="https://images2.imgbox.com/38/1c/pab1HMIg_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/00/28/fdXZO9UC_o.png" alt="在这里插入图片描述"></p> 
<p>​ 栈存在两种溢出的情况，当栈已经存放满元素时，若还将元素进行压栈此时会发生上溢（overflow）；当栈已经为空时，若还进行出栈此时会发生下溢（underflow）。上溢是一种错误，使问题的处理无法进行；而下溢一般认为是一种结束条件，即问题的处理结束。</p> 
<p>顺序栈的表示：</p> 
<p><img src="https://images2.imgbox.com/4e/98/DGHOxDzH_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c"><span class="token comment">//栈的顺序表示</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	SElemType<span class="token operator">*</span> top<span class="token punctuation">;</span>		<span class="token comment">//栈顶指针</span>
	SElemType<span class="token operator">*</span> base<span class="token punctuation">;</span>	<span class="token comment">//栈底指针，用于初始化动态存储空间</span>
	<span class="token keyword">int</span> stacksize<span class="token punctuation">;</span>		<span class="token comment">//栈的最大容量</span>
<span class="token punctuation">}</span> SqStack<span class="token punctuation">;</span>
</code></pre> 
<ol><li>顺序栈的初始化</li></ol> 
<p><img src="https://images2.imgbox.com/17/c9/y7sJEslI_o.png" alt="在这里插入图片描述"></p> 
<ol start="2"><li>判断顺序栈是否为空</li></ol> 
<p><img src="https://images2.imgbox.com/02/3a/TiJYeiep_o.png" alt="在这里插入图片描述"></p> 
<ol start="3"><li>清空栈</li></ol> 
<p><img src="https://images2.imgbox.com/f2/91/k5hjY0cj_o.png" alt="在这里插入图片描述"></p> 
<ol start="4"><li>销毁栈</li></ol> 
<p><img src="https://images2.imgbox.com/5b/5a/bbFXnbRo_o.png" alt="在这里插入图片描述"></p> 
<ol start="5"><li>顺序栈的入栈</li></ol> 
<p><img src="https://images2.imgbox.com/cb/81/xUYkLDjQ_o.png" alt="在这里插入图片描述"></p> 
<ol start="6"><li>顺序栈的出栈</li></ol> 
<p><img src="https://images2.imgbox.com/64/be/LlcYUhEG_o.png" alt="在这里插入图片描述"></p> 
<p>这里一定是先进行指针下移，因为top指针指向的是栈顶空位置，用于存放下一个元素地址的地方，先进行下移则top指向栈中的栈顶第一个元素。</p> 
<p><mark>顺序栈的完整实现</mark>：</p> 
<pre><code class="prism language-c"><span class="token comment">// 顺序栈的实现</span>
<span class="token comment">//导入头文件</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span>	</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token comment">//函数结果状态代码</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">OK</span> <span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ERROR</span> <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">OVERFLOW</span> <span class="token expression"><span class="token operator">-</span><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TRUE</span> <span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FALSE</span> <span class="token expression"><span class="token number">0</span></span></span>
<span class="token comment">//宏定义</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXSIZE</span> <span class="token expression"><span class="token number">100</span></span></span>
<span class="token comment">//Status 是函数的类型，其值是函数结果状态代码</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> Status<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> SElemType<span class="token punctuation">;</span>
<span class="token comment">//顺序栈的定义</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	SElemType<span class="token operator">*</span> top<span class="token punctuation">;</span>
	SElemType<span class="token operator">*</span> base<span class="token punctuation">;</span>
	<span class="token keyword">int</span> stacksize<span class="token punctuation">;</span>
<span class="token punctuation">}</span> SqStack<span class="token punctuation">;</span>
<span class="token comment">//顺序栈的初始化</span>
Status <span class="token function">InitSqStack</span><span class="token punctuation">(</span>SqStack<span class="token operator">*</span> S<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	S<span class="token operator">-&gt;</span>base <span class="token operator">=</span> <span class="token punctuation">(</span>SElemType<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>MAXSIZE <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>SElemType<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>S<span class="token operator">-&gt;</span>base<span class="token punctuation">)</span>			<span class="token comment">//S-&gt;base为NULL，开辟空间失败</span>
		<span class="token function">exit</span><span class="token punctuation">(</span>OVERFLOW<span class="token punctuation">)</span><span class="token punctuation">;</span>
	S<span class="token operator">-&gt;</span>top <span class="token operator">=</span> S<span class="token operator">-&gt;</span>base<span class="token punctuation">;</span>
	S<span class="token operator">-&gt;</span>stacksize <span class="token operator">=</span> MAXSIZE<span class="token punctuation">;</span>
	<span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//判断顺序栈是否为空</span>
Status <span class="token function">IsEmptySqStack</span><span class="token punctuation">(</span><span class="token keyword">const</span> SqStack<span class="token operator">*</span> S<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token operator">-&gt;</span>base <span class="token operator">==</span> S<span class="token operator">-&gt;</span>top<span class="token punctuation">)</span>
		<span class="token keyword">return</span> TRUE<span class="token punctuation">;</span>
	<span class="token keyword">else</span>
		<span class="token keyword">return</span> FALSE<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//判断顺序栈是否已满</span>
Status <span class="token function">IsFullSqStack</span><span class="token punctuation">(</span><span class="token keyword">const</span> SqStack<span class="token operator">*</span> S<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>S<span class="token operator">-&gt;</span>base<span class="token punctuation">)</span>
		<span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token operator">-&gt;</span>top <span class="token operator">-</span> S<span class="token operator">-&gt;</span>base <span class="token operator">==</span> S<span class="token operator">-&gt;</span>stacksize<span class="token punctuation">)</span>
		<span class="token keyword">return</span> TRUE<span class="token punctuation">;</span>
	<span class="token keyword">else</span>
		<span class="token keyword">return</span> FALSE<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//清空栈</span>
Status <span class="token function">ClearSqStack</span><span class="token punctuation">(</span>SqStack<span class="token operator">*</span> S<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token operator">-&gt;</span>base<span class="token punctuation">)</span>
		S<span class="token operator">-&gt;</span>top <span class="token operator">=</span> S<span class="token operator">-&gt;</span>base<span class="token punctuation">;</span>
	<span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//销毁栈</span>
Status <span class="token function">DestroySqStack</span><span class="token punctuation">(</span>SqStack<span class="token operator">*</span> S<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>S<span class="token operator">-&gt;</span>base<span class="token punctuation">)</span>
		<span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>S<span class="token operator">-&gt;</span>base<span class="token punctuation">)</span><span class="token punctuation">;</span>
	S<span class="token operator">-&gt;</span>top <span class="token operator">=</span> S<span class="token operator">-&gt;</span>base <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	S<span class="token operator">-&gt;</span>stacksize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//顺序栈的入栈</span>
Status <span class="token function">Push</span><span class="token punctuation">(</span>SqStack<span class="token operator">*</span> S<span class="token punctuation">,</span> SElemType<span class="token operator">*</span> e<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>S<span class="token operator">-&gt;</span>base <span class="token operator">||</span> S<span class="token operator">-&gt;</span>top <span class="token operator">-</span> S<span class="token operator">-&gt;</span>base <span class="token operator">==</span> S<span class="token operator">-&gt;</span>stacksize<span class="token punctuation">)</span>		<span class="token comment">//栈为NULL,或者上溢</span>
		<span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
	<span class="token operator">*</span><span class="token punctuation">(</span>S<span class="token operator">-&gt;</span>top<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">*</span>e<span class="token punctuation">;</span>
	<span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//顺序栈的出栈</span>
Status <span class="token function">Pop</span><span class="token punctuation">(</span>SqStack<span class="token operator">*</span> S<span class="token punctuation">,</span> SElemType<span class="token operator">*</span> e<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>S<span class="token operator">-&gt;</span>base <span class="token operator">||</span> S<span class="token operator">-&gt;</span>top <span class="token operator">==</span> S<span class="token operator">-&gt;</span>base<span class="token punctuation">)</span>						<span class="token comment">//栈为NULL,或者下溢</span>
		<span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
	<span class="token operator">*</span>e <span class="token operator">=</span> <span class="token operator">*</span><span class="token operator">--</span>S<span class="token operator">-&gt;</span>top<span class="token punctuation">;</span>
	<span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//栈显示函数</span>
<span class="token keyword">void</span> <span class="token function">ShowSqStack</span><span class="token punctuation">(</span><span class="token keyword">const</span> SqStack<span class="token operator">*</span> S<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>S<span class="token operator">-&gt;</span>base <span class="token operator">||</span> S<span class="token operator">-&gt;</span>top <span class="token operator">==</span> S<span class="token operator">-&gt;</span>base<span class="token punctuation">)</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"SqStack is Empty!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	SElemType<span class="token operator">*</span> p<span class="token punctuation">;</span>
	p <span class="token operator">=</span> S<span class="token operator">-&gt;</span>top<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">--</span> <span class="token operator">!=</span> S<span class="token operator">-&gt;</span>base<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">putchar</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>测试函数：</p> 
<pre><code class="prism language-c"><span class="token comment">//测试函数</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	SqStack my_stack<span class="token punctuation">;</span>
	<span class="token function">InitSqStack</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">)</span><span class="token punctuation">;</span>							<span class="token comment">//测试栈初始化函数</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token function">IsEmptySqStack</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//测试判断空函数</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token function">IsFullSqStack</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//测试判断满函数</span>
	SElemType a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	SElemType b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	SElemType c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
	SElemType d <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	SElemType answer<span class="token punctuation">;</span>
	<span class="token function">Push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>							<span class="token comment">//测试入栈函数</span>
	<span class="token function">Push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">Push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">Push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">,</span> <span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>						
	<span class="token function">ShowSqStack</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">)</span><span class="token punctuation">;</span>							<span class="token comment">//显示栈中元素</span>
	<span class="token function">Pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">,</span> <span class="token operator">&amp;</span>answer<span class="token punctuation">)</span><span class="token punctuation">;</span>						<span class="token comment">//测试出栈函数</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The answer is %d\n"</span><span class="token punctuation">,</span> answer<span class="token punctuation">)</span><span class="token punctuation">;</span>			
	<span class="token function">ShowSqStack</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">ClearSqStack</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">)</span><span class="token punctuation">;</span>						<span class="token comment">//测试清空栈函数</span>
	<span class="token function">ShowSqStack</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//DestroySqStack(&amp;my_stack);						//测试销毁栈函数</span>
	<span class="token comment">//ShowSqStack(&amp;my_stack);</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="2_1177"></a>2、栈的<mark>链式</mark>表示和实现</h5> 
<p>栈的链式表示又称为<strong>链栈</strong>，具体如下：</p> 
<p><img src="https://images2.imgbox.com/38/74/0AeBID4D_o.png" alt="在这里插入图片描述"></p> 
<p>在这个表示方法中，**栈顶指针就用单链表的头结点指针来表示，栈底指针就用单链表的尾结点指针来表示。链栈需要一个指针就能进行操作，是因为栈只能在栈顶进行入栈和出栈，所以仅仅直到栈顶的指针就可以操作整个链栈。**链栈是没有头结点的单链表，但是链栈也可以添加头结点，具体操作方法，要看自己是如何进行定义的。链栈的使用和创建，类似于单链表建立的头插法，都是从头部开始进行插入。</p> 
<pre><code class="prism language-c"><span class="token comment">//链栈</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">StackNode</span> <span class="token punctuation">{<!-- --></span>
	SElemType data<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">StackNode</span><span class="token operator">*</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span> StackNode<span class="token punctuation">,</span> <span class="token operator">*</span>LinkStack<span class="token punctuation">;</span>
</code></pre> 
<ol><li>链栈的初始化</li></ol> 
<p><img src="https://images2.imgbox.com/f7/05/ftQyKk6E_o.png" alt="在这里插入图片描述"></p> 
<ol start="2"><li>判断链栈是否为空</li></ol> 
<p><img src="https://images2.imgbox.com/77/ec/0nPcQX3C_o.png" alt="在这里插入图片描述"></p> 
<ol start="3"><li>链栈的入栈</li></ol> 
<p><img src="https://images2.imgbox.com/24/0f/lmMlWvg2_o.png" alt="在这里插入图片描述"></p> 
<ol start="4"><li>链栈的出栈</li></ol> 
<p><img src="https://images2.imgbox.com/0e/9e/MCqqP8hA_o.png" alt="在这里插入图片描述"></p> 
<ol start="5"><li>取栈顶的元素</li></ol> 
<p><img src="https://images2.imgbox.com/4b/b8/subwMZj8_o.png" alt="在这里插入图片描述"></p> 
<p><mark>链栈实现完整代码</mark></p> 
<pre><code class="prism language-c"><span class="token comment">//链栈的实现 --该实现是保留了头结点，栈为空的条件为头结点的next为NULL</span>
<span class="token comment">//导入头文件</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span>	</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token comment">//函数状态宏定义</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TRUE</span> <span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FALSE</span> <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ERROR</span> <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">OK</span> <span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">OVERFLOW</span> <span class="token expression"><span class="token operator">-</span><span class="token number">1</span></span></span>
<span class="token comment">//类型定义</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> Status<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> SElemType<span class="token punctuation">;</span>
<span class="token comment">//链栈定义</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">StackNode</span> <span class="token punctuation">{<!-- --></span>
	SElemType data<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">StackNode</span><span class="token operator">*</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span> StackNode<span class="token punctuation">,</span> <span class="token operator">*</span>LinkStack<span class="token punctuation">;</span>
<span class="token comment">//链栈的初始化</span>
Status <span class="token function">InitLinkStack</span><span class="token punctuation">(</span>LinkStack<span class="token operator">*</span> S<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token operator">*</span>S <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStack<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>StackNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>S<span class="token punctuation">)</span>			<span class="token comment">//开辟空间失败</span>
		<span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
	<span class="token punctuation">(</span><span class="token operator">*</span>S<span class="token punctuation">)</span><span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//判断链栈是否为空</span>
Status <span class="token function">IsEmptyLinkStack</span><span class="token punctuation">(</span>LinkStack<span class="token operator">*</span> S<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>S<span class="token punctuation">)</span><span class="token operator">-&gt;</span>next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>	
		<span class="token keyword">return</span> TRUE<span class="token punctuation">;</span>
	<span class="token keyword">else</span>
		<span class="token keyword">return</span> FALSE<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//链栈清空</span>
Status <span class="token function">ClearLinkStack</span><span class="token punctuation">(</span>LinkStack<span class="token operator">*</span> S<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">*</span>S<span class="token punctuation">)</span><span class="token operator">-&gt;</span>next<span class="token punctuation">)</span>		<span class="token comment">//当链栈已经为空时报错</span>
		<span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
	StackNode<span class="token operator">*</span> p<span class="token punctuation">,</span> <span class="token operator">*</span>q<span class="token punctuation">;</span>
	p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		q <span class="token operator">=</span> p<span class="token punctuation">;</span>
		p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token function">free</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token punctuation">(</span><span class="token operator">*</span>S<span class="token punctuation">)</span><span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//链表销毁</span>
Status <span class="token function">DestroyLinkStack</span><span class="token punctuation">(</span>LinkStack<span class="token operator">*</span> S<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">*</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span>			<span class="token comment">//当链栈不存在时报错</span>
		<span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
	StackNode<span class="token operator">*</span> p<span class="token punctuation">,</span> <span class="token operator">*</span>q<span class="token punctuation">;</span>
	p <span class="token operator">=</span> <span class="token operator">*</span>S<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		q <span class="token operator">=</span> p<span class="token punctuation">;</span>
		p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token function">free</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">free</span><span class="token punctuation">(</span><span class="token operator">*</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token operator">*</span>S <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//链栈入栈--链栈无上溢，所以不需要判断</span>
Status <span class="token function">Push</span><span class="token punctuation">(</span>LinkStack<span class="token operator">*</span> S<span class="token punctuation">,</span> SElemType<span class="token operator">*</span> e<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	StackNode<span class="token operator">*</span> new<span class="token punctuation">;</span>
	new <span class="token operator">=</span> <span class="token punctuation">(</span>StackNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>StackNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	new<span class="token operator">-&gt;</span>data <span class="token operator">=</span> <span class="token operator">*</span>e<span class="token punctuation">;</span>
	new<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">(</span><span class="token operator">*</span>S<span class="token punctuation">)</span> <span class="token operator">=</span> new<span class="token punctuation">;</span>
	<span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//链栈出栈--链栈有下溢，需要判断下溢</span>
Status <span class="token function">Pop</span><span class="token punctuation">(</span>LinkStack<span class="token operator">*</span> S<span class="token punctuation">,</span> SElemType<span class="token operator">*</span> e<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">*</span>S<span class="token punctuation">)</span><span class="token operator">-&gt;</span>next<span class="token punctuation">)</span>			<span class="token comment">//判断链栈下溢</span>
		<span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
	StackNode<span class="token operator">*</span> p<span class="token punctuation">;</span>
	p <span class="token operator">=</span> <span class="token operator">*</span>S<span class="token punctuation">;</span>
	<span class="token operator">*</span>e <span class="token operator">=</span> p<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>
	<span class="token operator">*</span>S <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>					<span class="token comment">//释放栈顶空间</span>
<span class="token punctuation">}</span>
<span class="token comment">//获取链栈顶部元素，并不出栈</span>
SElemType <span class="token function">GetTop</span><span class="token punctuation">(</span>LinkStack<span class="token operator">*</span> S<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>S<span class="token punctuation">)</span><span class="token operator">-&gt;</span>next<span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span>S<span class="token punctuation">)</span><span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//显示链栈</span>
<span class="token keyword">void</span> <span class="token function">ShowLinkStack</span><span class="token punctuation">(</span><span class="token keyword">const</span> LinkStack<span class="token operator">*</span> S<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">*</span>S<span class="token punctuation">)</span><span class="token operator">-&gt;</span>next<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The LinkStack is Empty\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">*</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The LinkStack dosen't  exsist\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	StackNode<span class="token operator">*</span> p<span class="token punctuation">;</span>
	p <span class="token operator">=</span> <span class="token operator">*</span>S<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
		p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">putchar</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>测试函数：</p> 
<pre><code class="prism language-c"><span class="token comment">//测试函数</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	LinkStack my_stack<span class="token punctuation">;</span>
	my_stack <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	SElemType a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	SElemType b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	SElemType c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
	SElemType d <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	SElemType answer<span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token function">InitLinkStack</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//测试初始化函数</span>
	<span class="token function">ShowLinkStack</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">)</span><span class="token punctuation">;</span>						<span class="token comment">//显示链栈</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token function">IsEmptyLinkStack</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//测试判断为空函数</span>
	<span class="token function">Push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>							<span class="token comment">//测试入栈函数</span>
	<span class="token function">Push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">Push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">Push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">,</span> <span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">ShowLinkStack</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">Pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">,</span> <span class="token operator">&amp;</span>answer<span class="token punctuation">)</span><span class="token punctuation">;</span>						<span class="token comment">//测试出栈函数</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> answer<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">ShowLinkStack</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token function">GetTop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">//测试获取首元素函数</span>
	<span class="token function">ClearLinkStack</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">)</span><span class="token punctuation">;</span>						<span class="token comment">//测试清空函数</span>
	<span class="token function">ShowLinkStack</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//DestroyLinkStack(&amp;my_stack);					//测试销毁函数</span>
	<span class="token comment">//ShowLinkStack(&amp;my_stack);</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="3_1373"></a>（3）栈与<mark>递归</mark></h4> 
<p>递归的定义：</p> 
<p><img src="https://images2.imgbox.com/7f/5e/GadMVxVE_o.png" alt="在这里插入图片描述"></p> 
<p>递归的问题往往采用<strong>分治法</strong>来解决，分治法是对于一个较为复杂的问题，能够分解成几个相对简单的且解法相同或类似的子问题来求解。分治法必备的三个条件：1、能够将一个问题转变成另一个新问题，而新问题的解法与原问题的解法相同或类似，不同仅是处理的对象，且这些处理这些问题是有变化规律的。2、可以通过上述转化来进行问题的简化。3、必须有一个明确的递归出口，或称为递归边界。</p> 
<p><img src="https://images2.imgbox.com/58/ad/TpWjGgcx_o.png" alt="在这里插入图片描述"></p> 
<p>递归的调用过程，举个例子：</p> 
<p><img src="https://images2.imgbox.com/a0/c7/lwpv6hhE_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="4FIFO_1390"></a>（4）队列（FIFO）</h4> 
<p>​ **队列（queue）**是一种先进后出（first-in-first-out，简称为FIFO）的线性表，它只允许在表的一端进行插入，另一端进行删除元素。在队列中，允许插入的一端叫做队尾（Rear），允许删除的一端叫做队头（Front）。插入操作称为入队，删除操作称为出队。</p> 
<h4><a id="5_1394"></a>（5）队列的表示和实现</h4> 
<h5><a id="1_1396"></a>1、队列的<mark>顺序</mark>表示和实现</h5> 
<p>队列的顺序表示又称为<strong>顺序队</strong>，具体表示如下：</p> 
<p><img src="https://images2.imgbox.com/c9/32/2CcL27pC_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c"><span class="token comment">//顺序队的实现</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXISIZE</span> <span class="token expression"><span class="token number">100</span></span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	QElemType<span class="token operator">*</span> base<span class="token punctuation">;</span>	<span class="token comment">//数据指针，初始化动态存储空间</span>
	<span class="token keyword">int</span> front<span class="token punctuation">;</span>			<span class="token comment">//头元素的索引，不是指针</span>
	<span class="token keyword">int</span> rear<span class="token punctuation">;</span>			<span class="token comment">//尾元素的索引，不是指针</span>
<span class="token punctuation">}</span> SqQueue<span class="token punctuation">;</span>
</code></pre> 
<p>顺序队入队时的假上溢问题：</p> 
<p><img src="https://images2.imgbox.com/db/eb/3kXs8Zet_o.png" alt="在这里插入图片描述"></p> 
<p>顺序队存在<strong>假上溢</strong>的问题，即当队尾指针指向了最大元素个数MAXQSIZE，但是队头指针却不为0，这种情况称为假上溢，为了解决这个问题有以下两种做法：1、每次都将队列中剩余的元素向队头方向移动，这种方式时间效率低。2、把队列视为循环队列。</p> 
<p><img src="https://images2.imgbox.com/67/7d/RhYxbnuT_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/12/d5/2JDFGTMk_o.png" alt="在这里插入图片描述"></p> 
<p>如何判断队空队满：</p> 
<p><img src="https://images2.imgbox.com/05/c4/BEdO0uo7_o.png" alt="在这里插入图片描述"></p> 
<p>采用少用一个元素空间的方法比较简单。</p> 
<p><img src="https://images2.imgbox.com/9a/49/dCkiKh0J_o.png" alt="在这里插入图片描述"></p> 
<ol><li>循环队列的初始化</li></ol> 
<p><img src="https://images2.imgbox.com/77/ab/Dccsb1JS_o.png" alt="在这里插入图片描述"></p> 
<ol start="2"><li>求队列的长度</li></ol> 
<p><img src="https://images2.imgbox.com/87/a9/9e8EkzCS_o.png" alt="在这里插入图片描述"></p> 
<ol start="3"><li>循环队列入队</li></ol> 
<p><img src="https://images2.imgbox.com/99/0a/cKSmvfX3_o.png" alt="在这里插入图片描述"></p> 
<ol start="4"><li>循环队列出队</li></ol> 
<p><img src="https://images2.imgbox.com/60/60/q409u31n_o.png" alt="在这里插入图片描述"></p> 
<ol start="5"><li>取队头元素</li></ol> 
<p><img src="https://images2.imgbox.com/4c/95/MXZqP4Db_o.png" alt="在这里插入图片描述"></p> 
<p><mark>顺序队列的完整实现</mark>：</p> 
<pre><code class="prism language-c"><span class="token comment">//顺序队列的实现</span>
<span class="token comment">//头文件包含</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token comment">//函数状态宏定义</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">OK</span> <span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ERROR</span> <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TRUE</span> <span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FALSE</span> <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">OVERFLOW</span> <span class="token expression"><span class="token operator">-</span><span class="token number">1</span></span></span>
<span class="token comment">//类型定义</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> Status<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> QElemType<span class="token punctuation">;</span>
<span class="token comment">//顺序队定义</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXQSIZE</span> <span class="token expression"><span class="token number">100</span></span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">SqQueue</span> <span class="token punctuation">{<!-- --></span>
	QElemType<span class="token operator">*</span> base<span class="token punctuation">;</span>	<span class="token comment">//动态分配数据域，指针</span>
	<span class="token keyword">int</span> front<span class="token punctuation">;</span>			<span class="token comment">//队头索引</span>
	<span class="token keyword">int</span> rear<span class="token punctuation">;</span>			<span class="token comment">//队尾索引</span>
<span class="token punctuation">}</span> SqQueue<span class="token punctuation">;</span>
<span class="token comment">//初始化</span>
Status <span class="token function">InitSqQueue</span><span class="token punctuation">(</span>SqQueue<span class="token operator">*</span> Q<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Q<span class="token operator">-&gt;</span>base <span class="token operator">=</span> <span class="token punctuation">(</span>QElemType<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>MAXQSIZE <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>QElemType<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Q<span class="token operator">-&gt;</span>base<span class="token punctuation">)</span>
		<span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
	Q<span class="token operator">-&gt;</span>front <span class="token operator">=</span> Q<span class="token operator">-&gt;</span>rear <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//求循环队列的长度</span>
<span class="token keyword">int</span> <span class="token function">GetLength</span><span class="token punctuation">(</span>SqQueue<span class="token operator">*</span> Q<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>Q<span class="token operator">-&gt;</span>rear <span class="token operator">-</span> Q<span class="token operator">-&gt;</span>front <span class="token operator">+</span> MAXQSIZE<span class="token punctuation">)</span> <span class="token operator">%</span> MAXQSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//入队</span>
Status <span class="token function">EnQueue</span><span class="token punctuation">(</span>SqQueue<span class="token operator">*</span> Q<span class="token punctuation">,</span> QElemType<span class="token operator">*</span> e<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>Q<span class="token operator">-&gt;</span>rear <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MAXQSIZE <span class="token operator">==</span> Q<span class="token operator">-&gt;</span>front<span class="token punctuation">)</span>		<span class="token comment">//出现上溢</span>
		<span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
	Q<span class="token operator">-&gt;</span>base<span class="token punctuation">[</span>Q<span class="token operator">-&gt;</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">*</span>e<span class="token punctuation">;</span>
	Q<span class="token operator">-&gt;</span>rear <span class="token operator">=</span> <span class="token punctuation">(</span>Q<span class="token operator">-&gt;</span>rear <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MAXQSIZE<span class="token punctuation">;</span>
	<span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//出队</span>
Status <span class="token function">DeQueue</span><span class="token punctuation">(</span>SqQueue<span class="token operator">*</span> Q<span class="token punctuation">,</span> QElemType<span class="token operator">*</span> e<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>Q<span class="token operator">-&gt;</span>front <span class="token operator">==</span> Q<span class="token operator">-&gt;</span>rear<span class="token punctuation">)</span>				<span class="token comment">//出现下溢</span>
		<span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
	<span class="token operator">*</span>e <span class="token operator">=</span> Q<span class="token operator">-&gt;</span>base<span class="token punctuation">[</span>Q<span class="token operator">-&gt;</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>
	Q<span class="token operator">-&gt;</span>front <span class="token operator">=</span> <span class="token punctuation">(</span>Q<span class="token operator">-&gt;</span>front <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MAXQSIZE<span class="token punctuation">;</span>
	<span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//取队头元素</span>
QElemType <span class="token function">GetHead</span><span class="token punctuation">(</span>SqQueue<span class="token operator">*</span> Q<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>Q<span class="token operator">-&gt;</span>rear <span class="token operator">!=</span> Q<span class="token operator">-&gt;</span>front<span class="token punctuation">)</span>
		<span class="token keyword">return</span> Q<span class="token operator">-&gt;</span>base<span class="token punctuation">[</span>Q<span class="token operator">-&gt;</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//销毁队列</span>
Status <span class="token function">DestoryQueue</span><span class="token punctuation">(</span>SqQueue<span class="token operator">*</span> Q<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>Q<span class="token operator">-&gt;</span>base<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>Q<span class="token operator">-&gt;</span>base<span class="token punctuation">)</span><span class="token punctuation">;</span>
	Q<span class="token operator">-&gt;</span>front <span class="token operator">=</span> Q<span class="token operator">-&gt;</span>rear <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//显示队列</span>
<span class="token keyword">void</span> <span class="token function">ShowSqQueue</span><span class="token punctuation">(</span>SqQueue Q<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front <span class="token operator">==</span> Q<span class="token punctuation">.</span>rear<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The SqQueue is Empty\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear <span class="token operator">!=</span> Q<span class="token punctuation">.</span>front<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> Q<span class="token punctuation">.</span>base<span class="token punctuation">[</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		Q<span class="token punctuation">.</span>front <span class="token operator">=</span> <span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MAXQSIZE<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">putchar</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>测试函数：</p> 
<pre><code class="prism language-c"><span class="token comment">//测试函数</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	SqQueue my_queue<span class="token punctuation">;</span>
	QElemType a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	QElemType b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	QElemType c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
	QElemType d <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	QElemType answer<span class="token punctuation">;</span>
	<span class="token function">InitSqQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">//测试初始化</span>
	<span class="token function">ShowSqQueue</span><span class="token punctuation">(</span>my_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">EnQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_queue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">//测试入队函数</span>
	<span class="token function">EnQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_queue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">EnQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_queue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">EnQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_queue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">ShowSqQueue</span><span class="token punctuation">(</span>my_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">DeQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_queue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>answer<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//测试出队函数</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The answer is %d\n"</span><span class="token punctuation">,</span> answer<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">DestoryQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">//测试销毁函数</span>
	<span class="token function">ShowSqQueue</span><span class="token punctuation">(</span>my_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="2_1576"></a>2、队列的<mark>链式</mark>表示和实现</h5> 
<p>队列的链式表示又称为<strong>链队</strong>，具体表示如下：</p> 
<p><img src="https://images2.imgbox.com/4b/d3/E4ABqwin_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c"><span class="token comment">//链队的实现</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Qnode</span> <span class="token punctuation">{<!-- --></span>
	QElemType data<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">Qndoe</span><span class="token operator">*</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span> QNode<span class="token punctuation">,</span> <span class="token operator">*</span>QueuePtr<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	QueuePtr front<span class="token punctuation">;</span>		<span class="token comment">//队头指针</span>
	QueuePtr rear<span class="token punctuation">;</span>		<span class="token comment">//队尾指针</span>
<span class="token punctuation">}</span> LinkQueue<span class="token punctuation">;</span>
</code></pre> 
<p>在这种表示方法中，<strong>队头是单链表的头结点的指针，队尾是单链表尾结点的指针。与链栈不同，链队需要两个指针进行操作，是因为队列是在队头进行出队，队尾进行入队，需要两个指针分别来指示队列的队头和队尾。</strong></p> 
<ol><li>链队的初始化</li></ol> 
<p><img src="https://images2.imgbox.com/05/59/jZkWXfER_o.png" alt="在这里插入图片描述"></p> 
<ol start="2"><li>链队列的销毁</li></ol> 
<p><img src="https://images2.imgbox.com/4a/87/PwquP8Gi_o.png" alt="在这里插入图片描述"></p> 
<ol start="3"><li>链队列的入队</li></ol> 
<p><img src="https://images2.imgbox.com/f6/ae/i3T8eC2K_o.png" alt="在这里插入图片描述"></p> 
<ol start="4"><li>链队的出队</li></ol> 
<p><img src="https://images2.imgbox.com/56/42/lMcU1jdh_o.png" alt="在这里插入图片描述"></p> 
<ol start="5"><li>链队列求队头元素</li></ol> 
<p><img src="https://images2.imgbox.com/82/69/QlX8QwLs_o.png" alt="在这里插入图片描述"></p> 
<p><mark>链队的完整实现</mark>：</p> 
<pre><code class="prism language-c"><span class="token comment">//链队的实现</span>
<span class="token comment">//头文件包含</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token comment">//函数状态宏定义</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">OK</span> <span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ERROR</span> <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TRUE</span> <span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FALSE</span> <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">OVERFLOW</span> <span class="token expression"><span class="token operator">-</span><span class="token number">1</span></span></span>
<span class="token comment">//类型定义</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> Status<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> QElemType<span class="token punctuation">;</span>
<span class="token comment">//链队结点的定义</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Qnode</span> <span class="token punctuation">{<!-- --></span>
	QElemType data<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">Qnode</span><span class="token operator">*</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span> QNode<span class="token punctuation">,</span> <span class="token operator">*</span>QueuePtr<span class="token punctuation">;</span>
<span class="token comment">//链队的定义</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	QueuePtr front<span class="token punctuation">;</span>		<span class="token comment">//队头指针</span>
	QueuePtr rear<span class="token punctuation">;</span>
<span class="token punctuation">}</span> LinkQueue<span class="token punctuation">;</span>
<span class="token comment">//链队的初始化</span>
Status <span class="token function">InitLinkQueue</span><span class="token punctuation">(</span>LinkQueue<span class="token operator">*</span> Q<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Q<span class="token operator">-&gt;</span>front <span class="token operator">=</span> Q<span class="token operator">-&gt;</span>rear <span class="token operator">=</span> <span class="token punctuation">(</span>QNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>QNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Q<span class="token operator">-&gt;</span>rear<span class="token punctuation">)</span>
		<span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
	Q<span class="token operator">-&gt;</span>rear<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//链队的销毁</span>
Status <span class="token function">DestoryLinkQueue</span><span class="token punctuation">(</span>LinkQueue<span class="token operator">*</span> Q<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	QNode<span class="token operator">*</span> p<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>Q<span class="token operator">-&gt;</span>front<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		p <span class="token operator">=</span> Q<span class="token operator">-&gt;</span>front<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token function">free</span><span class="token punctuation">(</span>Q<span class="token operator">-&gt;</span>front<span class="token punctuation">)</span><span class="token punctuation">;</span>
		Q<span class="token operator">-&gt;</span>front <span class="token operator">=</span> p<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//链队的入队</span>
Status <span class="token function">EnLinkQueue</span><span class="token punctuation">(</span>LinkQueue<span class="token operator">*</span> Q<span class="token punctuation">,</span> QElemType<span class="token operator">*</span> e<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	QNode<span class="token operator">*</span> new<span class="token punctuation">;</span>
	new <span class="token operator">=</span> <span class="token punctuation">(</span>QNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>QNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	new<span class="token operator">-&gt;</span>data <span class="token operator">=</span> <span class="token operator">*</span>e<span class="token punctuation">;</span>
	new<span class="token operator">-&gt;</span>next <span class="token operator">=</span> Q<span class="token operator">-&gt;</span>rear<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	Q<span class="token operator">-&gt;</span>rear<span class="token operator">-&gt;</span>next <span class="token operator">=</span> new<span class="token punctuation">;</span>
	Q<span class="token operator">-&gt;</span>rear <span class="token operator">=</span> new<span class="token punctuation">;</span>		<span class="token comment">//更新队列尾指针</span>
	<span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//链队的出队</span>
Status <span class="token function">DeLinkQueue</span><span class="token punctuation">(</span>LinkQueue<span class="token operator">*</span> Q<span class="token punctuation">,</span> QElemType<span class="token operator">*</span> e<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>Q<span class="token operator">-&gt;</span>front <span class="token operator">==</span> Q<span class="token operator">-&gt;</span>rear<span class="token punctuation">)</span>
		<span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
	QNode<span class="token operator">*</span> p<span class="token punctuation">;</span>
	p <span class="token operator">=</span> Q<span class="token operator">-&gt;</span>front<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token operator">*</span>e <span class="token operator">=</span> p<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>
	Q<span class="token operator">-&gt;</span>front<span class="token operator">-&gt;</span>next <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>Q<span class="token operator">-&gt;</span>rear <span class="token operator">==</span> p<span class="token punctuation">)</span>
		Q<span class="token operator">-&gt;</span>front <span class="token operator">=</span> Q<span class="token operator">-&gt;</span>rear<span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//获取链队头元素</span>
QElemType <span class="token function">GetHead</span><span class="token punctuation">(</span>LinkQueue<span class="token operator">*</span> Q<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token operator">-&gt;</span>front <span class="token operator">!=</span> Q<span class="token operator">-&gt;</span>rear<span class="token punctuation">)</span>
		<span class="token keyword">return</span> Q<span class="token operator">-&gt;</span>front<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//显示链队</span>
<span class="token keyword">void</span> <span class="token function">ShowLinkQueue</span><span class="token punctuation">(</span>LinkQueue Q<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front <span class="token operator">==</span> Q<span class="token punctuation">.</span>rear<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The LinkQueue is Empty\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	Q<span class="token punctuation">.</span>front <span class="token operator">=</span> Q<span class="token punctuation">.</span>front<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>			<span class="token comment">//跳过头结点</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> Q<span class="token punctuation">.</span>front<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
		Q<span class="token punctuation">.</span>front <span class="token operator">=</span> Q<span class="token punctuation">.</span>front<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">putchar</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>测试函数：</p> 
<pre><code class="prism language-c"><span class="token comment">//测试函数</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	LinkQueue my_queue<span class="token punctuation">;</span>

	QElemType a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	QElemType b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	QElemType c <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
	QElemType d <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>
	QElemType answer<span class="token punctuation">;</span>
	<span class="token function">InitLinkQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">//测试初始化链队</span>
	<span class="token function">ShowLinkQueue</span><span class="token punctuation">(</span>my_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">EnLinkQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_queue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">//测试链队入队</span>
	<span class="token function">EnLinkQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_queue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">EnLinkQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_queue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">EnLinkQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_queue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">ShowLinkQueue</span><span class="token punctuation">(</span>my_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">DeLinkQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_queue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>answer<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//测试链队出队</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The answer is %d\n"</span><span class="token punctuation">,</span> answer<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">ShowLinkQueue</span><span class="token punctuation">(</span>my_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The head is %d\n"</span><span class="token punctuation">,</span> <span class="token function">GetHead</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//测试获取头元素</span>
	<span class="token function">DestoryLinkQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">//测试销毁链队</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>my_queue<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h3><a id="_1751"></a>六、串、数组和广义表</h3> 
<h4><a id="1_1753"></a>（1）串</h4> 
<p>​ 串（string）（或字符串）是由零个或多个字符组成的有限序列，一般记为<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          s 
         
         
         
           = 
          
         
           ′ 
          
         
         
         
           a 
          
         
           1 
          
         
         
         
           a 
          
         
           2 
          
         
        
          … 
         
         
          
          
            a 
           
          
            n 
           
          
         
           ′ 
          
         
        
          ( 
         
        
          n 
         
        
          ≥ 
         
        
          0 
         
        
          ) 
         
        
       
         s='a_1a_2\dots{a_n}'(n\ge0) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.801892em; vertical-align: 0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.801892em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.05189em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.801892em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span></span><br> 其中，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         s 
        
       
      
        s 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">s</span></span></span></span></span>是串的名字，用单引号<code>''</code>括起来的字符序列是串的值；<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          a 
         
        
          i 
         
        
       
         ( 
        
       
         1 
        
       
         ≤ 
        
       
         i 
        
       
         ≤ 
        
       
         n 
        
       
         ) 
        
       
      
        a_i(1\le{i}\le{n}) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.79549em; vertical-align: -0.13597em;"></span><span class="mord"><span class="mord mathdefault">i</span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault">n</span></span><span class="mclose">)</span></span></span></span></span>可以是字母、数字或其他字符；串中字符的数目<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
      
        n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>称为串的长度。零个字符的串称为空串（null string），它的长度为0。串中任意个连续的字符组成的子序列称为该串的子串。包含<strong>子串</strong>的串相应的称为<strong>主串</strong>。通常称字符在序列中的序号为该字符在串中的位置。<strong>子串的位置</strong>是子串的第一个字符在主串中的位置。</p> 
<p><img src="https://images2.imgbox.com/60/22/Te3bGscc_o.png" alt="在这里插入图片描述"></p> 
<p>​ 串也具有顺序存储结构和链式存储结构，分别称为顺序串和链串。</p> 
<h4><a id="2_1766"></a>（2）串的表示和实现</h4> 
<h5><a id="1_1768"></a>1、串的<mark>顺序</mark>表示</h5> 
<p>​ 类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。在串的定长顺序存储结构中，按照预定义大小，为每个定义的串变量分配一个固定长度的存储区。具体描述如下：</p> 
<p><img src="https://images2.imgbox.com/0e/df/rE3tutvx_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c"><span class="token comment">//串的顺序存储结构</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXLEN</span> <span class="token expression"><span class="token number">255</span></span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span> ch<span class="token punctuation">[</span>MAXLEN <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>	 <span class="token comment">//存储串的一维字符数组</span>
	<span class="token keyword">int</span> length<span class="token punctuation">;</span>				<span class="token comment">//串的当前长度</span>
<span class="token punctuation">}</span> SString<span class="token punctuation">;</span>
</code></pre> 
<h5><a id="2_1784"></a>2、串的<mark>链式</mark>表示</h5> 
<p>​ 和线性表的链式存储结构类似，串也可以采用链式表示方法存储串值。由于串结构的特殊性——结构中的每个元素是一个字符，则用链表存储串值时，存在一个“结点大小”的问题，即每个结点可以存放一个字符，也可以存放多个字符，这种结构一般称为<strong>块链</strong>。由于串长不一定是结点大小的整数倍，所以链表的最后一个结点不一定全被串值占满，此时通常补上“#”或其他非串值字符。</p> 
<p><img src="https://images2.imgbox.com/0c/66/Y7uMiAr3_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/92/d1/TadM1zov_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c"><span class="token comment">//串的链式存储结构（块链）</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CHUNKSIZE</span> <span class="token expression"><span class="token number">80</span>		</span><span class="token comment">//定义块的大小</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Chunk</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span> ch<span class="token punctuation">[</span>CHUNKSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">Chunk</span><span class="token operator">*</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span> CHUNK<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	CHUNK<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token operator">*</span> tail<span class="token punctuation">;</span>		<span class="token comment">//串的头指针和尾指针</span>
	<span class="token keyword">int</span> curlen<span class="token punctuation">;</span>					<span class="token comment">//串的当前长度</span>
<span class="token punctuation">}</span> LString<span class="token punctuation">;</span>						<span class="token comment">//字符串的块链结构</span>
</code></pre> 
<h5><a id="3_1808"></a>3、串的模式匹配算法</h5> 
<p>​ 算法的目的是：确定主串中所含子串（模式串）第一次出现的位置（定位）。算法的种类：<strong>BE算法</strong>（Brute Force，暴力破解法）；<strong>KMP算法</strong>（特点：速度快）。</p> 
<p><strong><mark>BE算法</mark></strong>：采用顺序串进行实现</p> 
<p><img src="https://images2.imgbox.com/4b/02/G6XLQg5e_o.png" alt="在这里插入图片描述"></p> 
<p>算法的步骤：</p> 
<p><img src="https://images2.imgbox.com/26/2d/qLAqFOL4_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/5e/22/mqyT7GgG_o.png" alt="在这里插入图片描述"></p> 
<p>新增了待查找的位置，从pos位置处开始进行查找。</p> 
<p><img src="https://images2.imgbox.com/52/0a/BZqe8diu_o.png" alt="在这里插入图片描述"></p> 
<p><mark>BF</mark>算法的时间复杂度：</p> 
<p>​ <strong>最好</strong>的情况是第一次匹配就成功，设子串的长度为m，主串的长度为n，那么最优的时间复杂度为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         m 
        
       
         ) 
        
       
      
        O(m) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></span>；<strong>最坏</strong>的情况为前<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
         − 
        
       
         m 
        
       
      
        n-m 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">m</span></span></span></span></span>次匹配均失败，最后一次匹配成功，时间复杂度为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         ( 
        
       
         n 
        
       
         − 
        
       
         m 
        
       
         + 
        
       
         1 
        
       
         ) 
        
       
         × 
        
       
         m 
        
       
         ) 
        
       
      
        O((n-m+1)\times{m}) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault">m</span></span><span class="mclose">)</span></span></span></span></span>，若<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         m 
        
       
         &lt; 
        
       
         &lt; 
        
       
         n 
        
       
      
        m&lt;&lt;n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5782em; vertical-align: -0.0391em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height: 0.5782em; vertical-align: -0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>，则时间复杂度为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         n 
        
       
         ∗ 
        
       
         m 
        
       
         ) 
        
       
      
        O(n*m) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></span>；<strong>平均</strong>时间复杂度为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
        
        
          n 
         
        
          2 
         
        
       
         ∗ 
        
       
         m 
        
       
         ) 
        
       
      
        O(\frac{n}{2}*m) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.095em; vertical-align: -0.345em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.695392em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></span>，数量级仍为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         n 
        
       
         ∗ 
        
       
         m 
        
       
         ) 
        
       
      
        O(n*m) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></span>。</p> 
<p><img src="https://images2.imgbox.com/b4/f0/Sv0IlndN_o.png" alt="在这里插入图片描述"></p> 
<p><mark>KMP算法</mark>：采用顺序串进行实现</p> 
<p><img src="https://images2.imgbox.com/92/60/znCo79Zx_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/cd/9a/4oeT8kvW_o.png" alt="在这里插入图片描述"></p> 
<p>next函数使用示例：</p> 
<p><img src="https://images2.imgbox.com/10/41/U3HG6fE9_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/9d/ac/9qXlzzL0_o.png" alt="在这里插入图片描述"></p> 
<p>对next函数的修正方法：（掌握到会计算即可）</p> 
<p><img src="https://images2.imgbox.com/c2/7f/WS4AMndx_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="3_1858"></a>（3）数组</h4> 
<p>​ 之前讨论的线性结构中的数据元素都是非结构的原子类型，元素的值是不再分解的。而数组和广义表可以看成线性表的一种扩展：表中的数据元素本身也是一个数据结构。</p> 
<p>​ 数组：是按照一定格式排列起来的具有相同类型的数据元素的集合。一维数组：若线性表中的数据元素为非结构的简单元素，则称为一维数组。一维数组的逻辑结构：线性结构，定长的线性表。二维数组：若有一维数组中的数据元素又是一维数组结构，则称为二维数组。</p> 
<p>数组的定义方法：</p> 
<p><img src="https://images2.imgbox.com/02/a5/tTCVgp5r_o.png" alt="在这里插入图片描述"></p> 
<p>由此可以看出，线性表结构是数组结构的一个特例，而数组结构又是线性表结构的扩展。</p> 
<h4><a id="4_1871"></a>（4）数组的表示</h4> 
<p>​ 数组的特点是：结构固定，且一般不做插入和删除操作，所以一般都是采用顺序结构来表示数组。在C语言中一般采用内置的数组数据类型的定义。</p> 
<p>数组的存储，以二维数组为例：</p> 
<p><img src="https://images2.imgbox.com/14/6a/burNFB8q_o.png" alt="在这里插入图片描述"></p> 
<p>稀疏矩阵的十字链表存储方式：</p> 
<p><img src="https://images2.imgbox.com/ed/cc/T2L5ILWn_o.png" alt="在这里插入图片描述"></p> 
<p>分别设置行的头指针，和列的头指针。</p> 
<p><img src="https://images2.imgbox.com/9f/91/rYWqddFm_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="5_1890"></a>（5）广义表</h4> 
<p>​ <strong>广义表</strong>（又称为列表list）是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
         ≥ 
        
       
         0 
        
       
      
        n\ge{0} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.77194em; vertical-align: -0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord"><span class="mord">0</span></span></span></span></span></span>个元素<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ( 
        
        
        
          a 
         
        
          0 
         
        
       
         , 
        
        
        
          a 
         
        
          1 
         
        
       
         , 
        
       
         … 
        
        
        
          a 
         
         
         
           n 
          
         
           − 
          
         
           1 
          
         
        
       
         ) 
        
       
      
        (a_0,a_1,\dots{a_{n-1}}) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.208331em;"><span class=""></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>的有限序列，其中每一个<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          a 
         
        
          i 
         
        
       
      
        a_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>或者是<strong>原子</strong>，或者是一个<strong>广义表</strong>。广义表通常记作：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         L 
        
       
         S 
        
       
         = 
        
       
         ( 
        
        
        
          a 
         
        
          1 
         
        
       
         , 
        
        
        
          a 
         
        
          2 
         
        
       
         , 
        
       
         … 
        
        
        
          , 
         
         
         
           a 
          
         
           n 
          
         
        
       
         ) 
        
       
      
        LS=(a_1,a_2,\dots{,a_n}) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>，其中<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         L 
        
       
         S 
        
       
      
        LS 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span></span></span></span></span>为表名，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
      
        n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>为表的长度，每一个<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          a 
         
        
          i 
         
        
       
      
        a_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>为表的元素，习惯上一般使用大写字母表示广义表，小写字母表示原子。<strong>表头</strong>：若<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         L 
        
       
         S 
        
       
      
        LS 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span></span></span></span></span>非空<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ( 
        
       
         n 
        
       
         ≥ 
        
       
         1 
        
       
         ) 
        
       
      
        (n\ge{1}) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord">1</span></span><span class="mclose">)</span></span></span></span></span>，则其第一个元素<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          a 
         
        
          1 
         
        
       
      
        a_1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>就是表头，记作<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         h 
        
       
         e 
        
       
         a 
        
       
         d 
        
       
         ( 
        
       
         L 
        
       
         S 
        
       
         ) 
        
       
         = 
        
        
        
          a 
         
        
          1 
         
        
       
      
        head(LS)=a_1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>。<strong>表尾</strong>：除表头之外的其他元素组成表称为表尾。记作<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         t 
        
       
         a 
        
       
         i 
        
       
         l 
        
       
         ( 
        
       
         L 
        
       
         S 
        
       
         ) 
        
       
         = 
        
       
         ( 
        
        
        
          a 
         
        
          2 
         
        
       
         , 
        
       
         … 
        
        
        
          , 
         
         
         
           a 
          
         
           n 
          
         
        
       
         ) 
        
       
      
        tail(LS)=(a_2,\dots{,a_n}) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>。一定注意表尾不是最后一个元素，而是一个子表。</p> 
<p>广义表的示例：</p> 
<p><img src="https://images2.imgbox.com/8d/c2/kzPZiauU_o.png" alt="在这里插入图片描述"></p> 
<p>广义表的<strong>长度</strong>定义为最外层包含的元素个数；广义表的<strong>深度</strong>定义为该广义表展开后所含括号的重数，特殊的有，原子的深度为0，空表的深度为1。</p> 
<p>广义表和线性表的区别：</p> 
<p><img src="https://images2.imgbox.com/d8/2c/UV9aMhTI_o.png" alt="在这里插入图片描述"></p> 
<p>广义表的基本运算操作：</p> 
<p><img src="https://images2.imgbox.com/9e/8c/ZTXTB8Q6_o.png" alt="在这里插入图片描述"></p> 
<p>广义表的存储：广义表通常采用链表来进行存储（暂不介绍）</p> 
<hr> 
<h3><a id="_1915"></a>七、树和二叉树</h3> 
<h4><a id="1_1917"></a>（1）树</h4> 
<p>​ <strong>树（Tree）<strong>是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           n 
          
         
           ( 
          
         
           n 
          
         
           ≥ 
          
         
           0 
          
         
           ) 
          
         
        
          n(n\ge{0}) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord">0</span></span><span class="mclose">)</span></span></span></span></span>个结点的有限集。若<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           n 
          
         
           = 
          
         
           0 
          
         
        
          n=0 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span>，则称为空树，若<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           n 
          
         
           &gt; 
          
         
           0 
          
         
        
          n&gt;0 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5782em; vertical-align: -0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span>，且满足如下两个条件：1、有且仅有一个特定的称为</strong>根</strong>（Root）的结点；2、其余结点可分为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         m 
        
       
         ( 
        
       
         m 
        
       
         ≥ 
        
       
         0 
        
       
         ) 
        
       
      
        m(m\ge{0}) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord">0</span></span><span class="mclose">)</span></span></span></span></span>个互不相交的有限集<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         1 
        
       
         , 
        
       
         T 
        
       
         2 
        
       
         , 
        
       
         T 
        
       
         3 
        
       
         , 
        
       
         … 
        
       
         , 
        
       
         T 
        
       
         m 
        
       
      
        T1,T2,T3,\dots,Tm 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.87777em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mord mathdefault">m</span></span></span></span></span>，其中每一个集合本身又是一棵树，并称为根的<strong>子树</strong>（SubTree）。树是典型的非线性结构。</p> 
<p>​ 树的基本术语：1、<strong>根节点</strong>：非空树中无前驱结点的结点；2、结点的<strong>度</strong>：该结点拥有子树（分支）的个数；3、<strong>树的度</strong>：树内所有结点的度的最大值；4、<strong>叶子</strong>（终端）结点：度为零的结点称为叶子结点；5、<strong>分支（<strong>非终端）结点：度不为零的结点；6、<strong>兄弟</strong>结点：有共同双亲的结点称为兄弟结点；7、树的</strong>深度</strong>（高度）：树中结点的最大层次；8、<strong>有序树</strong>：树中结点的各子树从左到右有次序；9、<strong>无序树</strong>：树中结点的各子树无次序；10、<strong>森林</strong>：是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         m 
        
       
         ( 
        
       
         m 
        
       
         ≥ 
        
       
         0 
        
       
         ) 
        
       
      
        m(m\ge{0}) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord">0</span></span><span class="mclose">)</span></span></span></span></span>棵互不相交的树的集合。</p> 
<p><img src="https://images2.imgbox.com/76/92/qOZfLxlA_o.png" alt="在这里插入图片描述"></p> 
<p>线性结构和树型结构的对比：</p> 
<p><img src="https://images2.imgbox.com/36/75/yKkfjNBX_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2_1931"></a>（2）二叉树</h4> 
<p>​ <strong>二叉树（Binary Tree）</strong>，是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
         ( 
        
       
         n 
        
       
         ≥ 
        
       
         0 
        
       
         ) 
        
       
      
        n(n\ge{0}) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord">0</span></span><span class="mclose">)</span></span></span></span></span>个结点的有限集，或者它是空集<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ( 
        
       
         n 
        
       
         = 
        
       
         0 
        
       
         ) 
        
       
      
        (n=0) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span>，或者有一个根节点及两颗互不相交的分别称作这个根的左子树和右子树的二叉树组成。二叉树的特点：1、每个结点最多有两个子树；2、子树有左右之分，其次序不能颠倒；3、二叉树可以是空集合，根可以有空的左子树或空的右子树。</p> 
<p>​ <strong>二叉树和树的区别</strong>：二叉树的结点的子树要区分左子树和右子树，即使只有一棵子树也要进行区分，说明该子树是左子树还是右子树。当树只有一个结点时，就无需区分它是左还是右的次序，因此二者是不同的。这就是二叉树和树的主要区别。</p> 
<p>​ 二叉树的<strong>性质</strong>：1、在二叉树的第<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         i 
        
       
      
        i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span>层上至多有<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          2 
         
         
         
           i 
          
         
           − 
          
         
           1 
          
         
        
       
      
        2^{i-1} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.824664em; vertical-align: 0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.824664em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span>个结点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ( 
        
       
         i 
        
       
         ≥ 
        
       
         1 
        
       
         ) 
        
       
      
        (i\ge{1}) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord">1</span></span><span class="mclose">)</span></span></span></span></span>，那么有<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
      
        n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>个结点的二叉树，深度为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ⌊ 
        
        
        
          l 
         
        
          o 
         
         
         
           g 
          
         
           2 
          
         
        
          n 
         
        
       
         ⌋ 
        
       
         + 
        
       
         1 
        
       
      
        \lfloor{log_2n}\rfloor+1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault">n</span></span><span class="mclose">⌋</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>；2、第<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         i 
        
       
      
        i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span>层上最少有一个结点；3、深度为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         k 
        
       
      
        k 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span></span></span></span></span>的二叉树至多有<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          2 
         
        
          k 
         
        
       
         − 
        
       
         1 
        
       
      
        2^k-1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.932438em; vertical-align: -0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.849108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>个结点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ( 
        
       
         k 
        
       
         ≥ 
        
       
         1 
        
       
         ) 
        
       
      
        (k\ge{1}) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord">1</span></span><span class="mclose">)</span></span></span></span></span>；4、对于任何一棵二叉树<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
      
        T 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span></span></span></span></span>，如果其叶子树为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          n 
         
        
          0 
         
        
       
      
        n_0 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>，所有度为2的节点数为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          n 
         
        
          2 
         
        
       
      
        n_2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>，则<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          n 
         
        
          2 
         
        
       
         = 
        
        
        
          n 
         
        
          2 
         
        
       
         + 
        
       
         1 
        
       
      
        n_2=n_2+1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.73333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>。</p> 
<p>性质4分析：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          n 
         
        
          i 
         
        
       
      
        n_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>是度为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         i 
        
       
      
        i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span>的结点，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
      
        n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>是所有结点的总数。</p> 
<p><img src="https://images2.imgbox.com/81/17/RRI8jX8c_o.png" alt="在这里插入图片描述"></p> 
<pre><code>**满二叉树**，一棵深度为$k$且有$2^k-1$个结点的二叉树称为满二叉树。特点：1、每一层上的结点数都是最大结点数（即每层都是满的）；2、叶子结点全部在最底层。对满二叉树位置进行编号，编号规则：从根结点开始，**自上而下，自左而右**；每一结点位置都有元素。
</code></pre> 
<p><img src="https://images2.imgbox.com/a7/b7/c4QYHr3b_o.png" alt="在这里插入图片描述"></p> 
<p>​ <strong>完全二叉树</strong>，深度为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         k 
        
       
      
        k 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span></span></span></span></span>的具有<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
      
        n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>个结点的二叉树，当且仅当其每一个结点都与深度为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         k 
        
       
      
        k 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span></span></span></span></span>的满二叉树中编号为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         1 
        
       
           
        
       
         n 
        
       
      
        1~n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span><span class="mspace nobreak"> </span><span class="mord mathdefault">n</span></span></span></span></span>的结点一一对应时，称之为完全二叉树。</p> 
<p><img src="https://images2.imgbox.com/b5/92/rUq2lWgf_o.png" alt="在这里插入图片描述"></p> 
<p>完全二叉树的<strong>简单判别方式</strong>：在满二叉树中，从最后一个结点开始，<strong>连续</strong>去掉<strong>任意</strong>个结点，即获得了一棵完全二叉树。</p> 
<p>​ 完全二叉树的<strong>特点</strong>：1、叶子只可能分布在层次最大的两层上；2、对任一结点，如果其右子树的最大层次为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         i 
        
       
      
        i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span>，则其左子树的最大层次必为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         i 
        
       
      
        i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span>或<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         i 
        
       
         + 
        
       
         1 
        
       
      
        i+1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.74285em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>。</p> 
<p>​ 完全二叉树的<strong>性质</strong>：1、具有<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
      
        n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>个结点的完全二叉树的深度为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ⌊ 
        
        
        
          l 
         
        
          o 
         
         
         
           g 
          
         
           2 
          
         
        
          n 
         
        
       
         ⌋ 
        
        
        
          + 
         
        
          1 
         
        
       
      
        \lfloor{log_2{n}}\rfloor{+1} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">n</span></span></span><span class="mclose">⌋</span><span class="mord"><span class="mord">+</span><span class="mord">1</span></span></span></span></span></span>，其中<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ⌊ 
        
       
         x 
        
       
         ⌋ 
        
       
      
        \lfloor{x}\rfloor 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mord mathdefault">x</span></span><span class="mclose">⌋</span></span></span></span></span>称作<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         x 
        
       
      
        x 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span>的底（向下取整），表示不大于<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         x 
        
       
      
        x 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span>的最大整数。2、如果对一棵有<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
      
        n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>个结点的完全二叉树（深度为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ⌊ 
        
        
        
          l 
         
        
          o 
         
         
         
           g 
          
         
           2 
          
         
        
          n 
         
        
       
         ⌋ 
        
        
        
          + 
         
        
          1 
         
        
       
      
        \lfloor{log_2{n}}\rfloor{+1} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">n</span></span></span><span class="mclose">⌋</span><span class="mord"><span class="mord">+</span><span class="mord">1</span></span></span></span></span></span>的结点按层序编号（从第<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         1 
        
       
      
        1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>层到第<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ⌊ 
        
        
        
          l 
         
        
          o 
         
         
         
           g 
          
         
           2 
          
         
        
          n 
         
        
       
         ⌋ 
        
        
        
          + 
         
        
          1 
         
        
       
      
        \lfloor{log_2{n}}\rfloor{+1} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">n</span></span></span><span class="mclose">⌋</span><span class="mord"><span class="mord">+</span><span class="mord">1</span></span></span></span></span></span>层，每层从左往右），则对任一结点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         i 
        
       
         ( 
        
       
         1 
        
       
         ≤ 
        
       
         i 
        
       
         ≤ 
        
       
         n 
        
       
         ) 
        
       
      
        i(1\le{i}\le{n}) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">i</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.79549em; vertical-align: -0.13597em;"></span><span class="mord"><span class="mord mathdefault">i</span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault">n</span></span><span class="mclose">)</span></span></span></span></span>有：a、如果<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         i 
        
       
         = 
        
       
         1 
        
       
      
        i=1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>，则结点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         i 
        
       
      
        i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span>是二叉树的根，无双亲；如果<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         i 
        
       
         &gt; 
        
       
         1 
        
       
      
        i&gt;1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69862em; vertical-align: -0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>，则其双亲结点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ⌊ 
        
        
        
          i 
         
        
          / 
         
        
          2 
         
        
       
         ⌋ 
        
       
      
        \lfloor{i/2}\rfloor 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mord mathdefault">i</span><span class="mord">/</span><span class="mord">2</span></span><span class="mclose">⌋</span></span></span></span></span>。b、如果<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         2 
        
       
         i 
        
       
         &gt; 
        
       
         n 
        
       
      
        2i&gt;n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69862em; vertical-align: -0.0391em;"></span><span class="mord">2</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>，则结点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         i 
        
       
      
        i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span>为叶子结点，无左孩子；否则，其左孩子结点是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         2 
        
       
         i 
        
       
      
        2i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord">2</span><span class="mord mathdefault">i</span></span></span></span></span>。c、如果<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         2 
        
       
         i 
        
       
         + 
        
       
         1 
        
       
         &gt; 
        
       
         n 
        
       
      
        2i+1&gt;n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.74285em; vertical-align: -0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.68354em; vertical-align: -0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>，则结点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         i 
        
       
      
        i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span>无右孩子；否则，其右孩子是结点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         2 
        
       
         i 
        
       
         + 
        
       
         1 
        
       
      
        2i+1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.74285em; vertical-align: -0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>。</p> 
<p><img src="https://images2.imgbox.com/0d/12/9GV2yvd5_o.png" alt="在这里插入图片描述"></p> 
<p>该性质2表明了完全二叉树中<strong>双亲结点</strong>编号和<strong>孩子结点</strong>编号之间的关系。</p> 
<h4><a id="3_1965"></a>（3）二叉树的表示</h4> 
<p>​ 二叉树的存储结构，包括顺序存储结构和链式存储结构，链式存储结构又包括二叉链表和三叉链表。</p> 
<h5><a id="1_1969"></a>1、二叉树的<mark>顺序</mark>存储结构</h5> 
<p>​ 二叉树的顺序存储结构：实现，按照满二叉树的结点层次进行编号，依次存放二叉树中的数据元素。</p> 
<p><img src="https://images2.imgbox.com/e6/a7/bho1ew1Y_o.png" alt="在这里插入图片描述"></p> 
<p>不完全二叉树如何进行存储：</p> 
<p><img src="https://images2.imgbox.com/20/38/gbdSIr4q_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/9b/d1/D0hECbpa_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c"><span class="token comment">//二叉树的顺序存储</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXTSIZE</span> <span class="token expression"><span class="token number">100</span></span></span>
<span class="token keyword">typedef</span> TElemType SqBiTree<span class="token punctuation">[</span>MAXTSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
SqBiTree bt<span class="token punctuation">;</span>			<span class="token comment">//创建一个二叉树</span>
</code></pre> 
<h5><a id="2_1991"></a>2、二叉树的<mark>链式</mark>存储结构</h5> 
<p>​ 二叉树的链式存储结构中的<mark>二叉链表</mark>，需要包含指向左右子树的指针，还需包含本身结点的数据域。</p> 
<p><img src="https://images2.imgbox.com/2a/0b/cIw7Cr4X_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/c6/fc/Q3XUVjd4_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c"><span class="token comment">//二叉树的链式存储结构</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Binode</span> <span class="token punctuation">{<!-- --></span>
	TElemType data<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">Binode</span><span class="token operator">*</span> lchild<span class="token punctuation">,</span> <span class="token operator">*</span> rchild<span class="token punctuation">;</span>	<span class="token comment">//左右孩子指针</span>
<span class="token punctuation">}</span>BiNode<span class="token punctuation">,</span> <span class="token operator">*</span>BiTree<span class="token punctuation">;</span>
</code></pre> 
<p>二叉树链式存储（二叉链表）示例：</p> 
<p><img src="https://images2.imgbox.com/f3/9c/tXWqTtwM_o.png" alt="在这里插入图片描述"></p> 
<p><strong>结论</strong>：在<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
      
        n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>个结点的二叉链表中，一定有<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
         + 
        
       
         1 
        
       
      
        n+1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>个空指针域。分析：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
      
        n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>个结点的二叉链表，一定有<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         2 
        
       
         n 
        
       
      
        2n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span></span></span></span></span>个链域，每个结点都会有一个双亲（除根节点），所以会存在<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
         − 
        
       
         1 
        
       
      
        n-1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>个结点的链域存放指针，那么空指针的个数为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         2 
        
       
         n 
        
       
         − 
        
       
         ( 
        
       
         n 
        
       
         − 
        
       
         1 
        
       
         ) 
        
       
         = 
        
       
         n 
        
       
         + 
        
       
         1 
        
       
      
        2n-(n-1)=n+1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>。</p> 
<p>​ <mark>三叉链表</mark>，除了需要包含指向左右子树的指针，还需要包含指向双亲结点的指针，同时还需要含本身结点的数据域。</p> 
<p><img src="https://images2.imgbox.com/7f/cb/wOiaPiMJ_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c"><span class="token comment">//三叉链表</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Trinode</span> <span class="token punctuation">{<!-- --></span>
	TElemType data<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">Trinode</span><span class="token operator">*</span> lchild<span class="token punctuation">,</span> <span class="token operator">*</span> rchild<span class="token punctuation">;</span>	<span class="token comment">//左右孩子指针</span>
	<span class="token keyword">struct</span> <span class="token class-name">Trinode</span><span class="token operator">*</span> parent<span class="token punctuation">;</span>  <span class="token comment">//双亲指针</span>
<span class="token punctuation">}</span> TriNode<span class="token punctuation">,</span> <span class="token operator">*</span>TriTree<span class="token punctuation">;</span>
</code></pre> 
<h4><a id="4_2030"></a>（4）二叉树的遍历</h4> 
<p>​ 二叉树遍历的<strong>定义</strong>：顺着某一条搜索路径巡防二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次。遍历的目的是得到树种所有结点的一个线性排列。 如果规定左右子树的访问顺序为先左后右，那么有三种遍历方式：都是以<strong>递归</strong>的方式进行</p> 
<p><img src="https://images2.imgbox.com/f8/c8/Zje6mX3E_o.png" alt="在这里插入图片描述"></p> 
<p>先序遍历（根左右）示例：</p> 
<p><img src="https://images2.imgbox.com/e8/b0/5Lxpuo6r_o.png" alt="在这里插入图片描述"></p> 
<p>中序遍历（左根右）示例：</p> 
<p><img src="https://images2.imgbox.com/0d/8b/ANJRb2VW_o.png" alt="在这里插入图片描述"></p> 
<p>后序遍历（左右根）示例：</p> 
<p><img src="https://images2.imgbox.com/6c/84/F4dBxVd3_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/d9/6e/nTOJgsoc_o.png" alt="在这里插入图片描述"></p> 
<p><strong>已知先序和中序序列求二叉树</strong>的方法：</p> 
<p><img src="https://images2.imgbox.com/49/03/zpcl5qM5_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/0b/a1/TtStRsQC_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/bd/41/6opfx2ZR_o.png" alt="在这里插入图片描述"></p> 
<p><strong>已知中序和后序序列求二叉树</strong>的方法：</p> 
<p><img src="https://images2.imgbox.com/5e/04/eKFlu9x3_o.png" alt="在这里插入图片描述"></p> 
<p>如果只知道先序和后序序列是不能确定二叉树的形状的，因为只知道先序和后序不能唯一确定根结点的位置。</p> 
<h5><a id="1_2072"></a>1、<mark>先序</mark>遍历的实现</h5> 
<p>均在<strong>二叉链表</strong>的基础上进行实现：</p> 
<p><img src="https://images2.imgbox.com/6f/0d/PCBdYwu7_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/51/0d/ayv2GFWI_o.png" alt="在这里插入图片描述"></p> 
<p>先序遍历递归调用的执行过程：</p> 
<p><img src="https://images2.imgbox.com/0d/13/TwLCLn9F_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2_2087"></a>2、<mark>中序</mark>遍历的实现</h5> 
<p><img src="https://images2.imgbox.com/04/5d/71MFLZgz_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/9f/b2/h0APlJBu_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="3_2095"></a>3、<mark>后序</mark>遍历的实现</h5> 
<p><img src="https://images2.imgbox.com/69/6c/aCWjOHBs_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/e2/a8/kg3oXoM9_o.png" alt="在这里插入图片描述"></p> 
<p>​ 三种遍历算法的对比，如果去掉输出语句，从递归的角度来看，三种算法是完全相同的，或者说这三种算法的访问路径是相同的，只是算法访问结点的时机不同。</p> 
<p><img src="https://images2.imgbox.com/90/43/fcAolYHf_o.png" alt="在这里插入图片描述"></p> 
<p>遍历算法分析，时间复杂度为：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
      
        O(n) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>，因为每个结点都只访问一次；空间复杂度：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
      
        O(n) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>，最坏情况下栈占用最大的辅助空间。</p> 
<h5><a id="4_2110"></a>4、中序遍历的<mark>非递归</mark>算法</h5> 
<p>​ 二叉树中序遍历的非递归算法的关键：在中序遍历过某个结点的整个左子树后，如何找到该结点的根以及右子树。基本思想如下：1、建立一个<strong>栈</strong>；2、根结点进栈，遍历左子树；3、根结点出栈，输出根结点，遍历右子树。（很巧妙）</p> 
<p><img src="https://images2.imgbox.com/bd/ce/VNAmwCkV_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="5_2117"></a>5、二叉树的<mark>层次</mark>遍历</h5> 
<p>​ 二叉树的层次遍历：对于一棵二叉树，从根结点开始，按从上到下，从左到右的顺序逐层访问每一个结点，每个结点仅访问一次。</p> 
<p>​ 算法设计<strong>思路</strong>：使用一个队列。1、将根结点入队；2、队列不为空时循环，从队列中出队一个结点<code>*p</code>，访问它；若它有左孩子结点，将左孩子结点入队；若它有右孩子结点，将右孩子结点入队。这里实现时，采用顺序循环队列。</p> 
<p><img src="https://images2.imgbox.com/b7/57/eg7Pxq45_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/e8/a2/PkhdyEfG_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="5_2129"></a>（5）二叉树遍历算法的<mark>应用</mark></h4> 
<h5><a id="1_2131"></a>1、二叉树的建立</h5> 
<p>应用先序遍历算法</p> 
<p><img src="https://images2.imgbox.com/86/3b/J3vgMirv_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2_2138"></a>2、复制二叉树</h5> 
<p>应用先序遍历算法</p> 
<p><img src="https://images2.imgbox.com/8f/ab/0rntcT6q_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="3_2145"></a>3、计算二叉树的深度</h5> 
<p>应用先序遍历算法</p> 
<p><img src="https://images2.imgbox.com/43/24/b7mZUKkz_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="4_2152"></a>4、计算二叉树结点的总个数</h5> 
<p>应用先序遍历算法</p> 
<p><img src="https://images2.imgbox.com/10/9d/pvK9Tm8V_o.png" alt="在这里插入图片描述"></p> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ( 
        
       
         ( 
        
       
         0 
        
       
         + 
        
       
         0 
        
       
         + 
        
       
         1 
        
       
         ) 
        
       
         + 
        
       
         ( 
        
       
         ( 
        
       
         0 
        
       
         + 
        
       
         0 
        
       
         + 
        
       
         1 
        
       
         ) 
        
       
         + 
        
       
         0 
        
       
         + 
        
       
         1 
        
       
         ) 
        
       
         + 
        
       
         1 
        
       
         ) 
        
       
         + 
        
       
         ( 
        
       
         ( 
        
       
         ( 
        
       
         0 
        
       
         + 
        
       
         0 
        
       
         + 
        
       
         1 
        
       
         ) 
        
       
         + 
        
       
         1 
        
       
         ) 
        
       
         + 
        
       
         0 
        
       
         + 
        
       
         1 
        
       
         ) 
        
       
         + 
        
       
         1 
        
       
      
        ((0+0+1)+((0+0+1)+0+1)+1)+(((0+0+1)+1)+0+1)+1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span></p> 
<h5><a id="5_2161"></a>5、计算二叉树叶子结点的总个数</h5> 
<p>应用先序遍历算法</p> 
<p><img src="https://images2.imgbox.com/ea/86/JElmLVAW_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="6_2168"></a>（6）<mark>线索</mark>二叉树</h4> 
<p>​ 二叉链表存储的特点：</p> 
<p><img src="https://images2.imgbox.com/45/5e/AZ48XvzV_o.png" alt="在这里插入图片描述"></p> 
<p>​ <strong>线索二叉树（Threaded Binary Tree）</strong>，线索二叉树的改进：利用二叉链表中的空指针域。如果某个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱；如果某个结点的右孩子为空，则将空的右孩子指针域改为指向其后继。（<strong>注</strong>：这里说的前驱和后继指的是按照先序、中序或者后序遍历得到的结点顺序。）这种改变指向的指针称为“线索”。对二叉树按某种遍历次序使其变为线索二叉树的过程称为<strong>线索化</strong>。</p> 
<p>线索二叉树示例：</p> 
<p><img src="https://images2.imgbox.com/bc/eb/OGn6xrdo_o.png" alt="在这里插入图片描述"></p> 
<p>线索二叉树的表示：</p> 
<p><img src="https://images2.imgbox.com/4c/e6/afO7xDsQ_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/55/d3/31bWSKa3_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c"><span class="token comment">//线索二叉树</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">BiThrnode</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> data<span class="token punctuation">;</span>
	<span class="token keyword">int</span> ltag<span class="token punctuation">,</span> rtag<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">BiThrnode</span><span class="token operator">*</span> lchild<span class="token punctuation">,</span> <span class="token operator">*</span> rchild<span class="token punctuation">;</span>
<span class="token punctuation">}</span> BiThrNode<span class="token punctuation">,</span> <span class="token operator">*</span>BiThrTree<span class="token punctuation">;</span>
</code></pre> 
<p>线索二叉树表示示例：</p> 
<p><img src="https://images2.imgbox.com/de/f2/3YErI7S3_o.png" alt="在这里插入图片描述"></p> 
<p>为了统一，给线索二叉树新增了头结点，如示例：</p> 
<p><img src="https://images2.imgbox.com/6d/8a/xtiofeUM_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/c6/21/95tnYMqu_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="7_2212"></a>（7）树的存储结构</h4> 
<h5><a id="1_2214"></a>1、双亲表示法</h5> 
<p>​ 树的<strong>双亲表示法</strong>：定义结构数组存放树的结点每个结点含有两个域，数据域：存放结点本身信息；双亲域：指示本届点的双亲结点在数组中的位置。</p> 
<p><img src="https://images2.imgbox.com/fd/a6/UwU8L0ln_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/ae/84/oVTR4O6x_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c"><span class="token comment">//树的双亲表示法</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">PTnode</span> <span class="token punctuation">{<!-- --></span>
	TElemType data<span class="token punctuation">;</span>
	<span class="token keyword">int</span> parent<span class="token punctuation">;</span>		<span class="token comment">//双亲位置域</span>
<span class="token punctuation">}</span> PTNode<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_TREE_SIZE</span> <span class="token expression"><span class="token number">100</span></span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	PTNode nodes<span class="token punctuation">[</span>MAX_TREE_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> r<span class="token punctuation">,</span> n<span class="token punctuation">;</span>		<span class="token comment">//指向根结点的位置和结点的个数的索引</span>
<span class="token punctuation">}</span> PTree<span class="token punctuation">;</span>
</code></pre> 
<h5><a id="2_2237"></a>2、孩子链表</h5> 
<p>​ 树的<strong>孩子链表</strong>，是把每个结点的孩子结点排列起来，看成一个线性表，用单链表存储，则<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
      
        n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>个结点有<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
      
        n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>个孩子链表（叶子结点的孩子链表为空）。而<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
      
        n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>个头指针又组成了一个线性表，用顺序表（含<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
      
        n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>个元素的结构数组）存储。</p> 
<p><img src="https://images2.imgbox.com/f4/2a/66LPAU61_o.png" alt="在这里插入图片描述"></p> 
<p>将孩子链表和双亲表示法结合起来，获得了带双亲的孩子链表。</p> 
<p><img src="https://images2.imgbox.com/75/43/faAXBfwe_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c"><span class="token comment">//孩子链表</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CTnode</span> <span class="token punctuation">{<!-- --></span>	<span class="token comment">//孩子结点 child + next</span>
	<span class="token keyword">int</span> child<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">CTnode</span><span class="token operator">*</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token operator">*</span>ChildPtr<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>	<span class="token comment">//双亲结点 data + firstchild</span>
	TElemType data<span class="token punctuation">;</span>
	ChildPtr firstchild<span class="token punctuation">;</span>	<span class="token comment">//孩子链表头指针</span>
<span class="token punctuation">}</span> CTBox<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_TREE_SIZE</span> <span class="token expression"><span class="token number">100</span></span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	CTBox nodes<span class="token punctuation">[</span>MAX_TREE_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> n<span class="token punctuation">,</span> r<span class="token punctuation">;</span>		<span class="token comment">//指向结点数和根结点位置的索引</span>
<span class="token punctuation">}</span> CTree<span class="token punctuation">;</span>
</code></pre> 
<h5><a id="3_2266"></a>3、孩子兄弟表示法（二叉树表示法）</h5> 
<p>​ 二叉树表示法，实现：用二叉链表作为树的存储结构，链表中每个结点的两个指针域分别指向其第一个孩子结点和下一个兄弟结点。</p> 
<p><img src="https://images2.imgbox.com/11/a7/HJuLTe8e_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c"><span class="token comment">//孩子兄弟表示法（二叉树表示法）</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CSnode</span> <span class="token punctuation">{<!-- --></span>
	ElemType data<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">CSnode</span><span class="token operator">*</span> firstchild<span class="token punctuation">,</span> <span class="token operator">*</span>nextsiblingl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>CSNode<span class="token punctuation">,</span> <span class="token operator">*</span>CSTree<span class="token punctuation">;</span>
</code></pre> 
<p>孩子兄弟表示法示例：</p> 
<p><img src="https://images2.imgbox.com/cc/f5/YXts5tj0_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="4_2286"></a>4、树和二叉树的转换</h5> 
<p>​ 由于树和二叉树都可以用二叉链表作为存储结构，则以<strong>二叉链表作为媒介</strong>可以导出数和二叉树之间的一个对应关系。</p> 
<p>举个例子：</p> 
<p><img src="https://images2.imgbox.com/46/47/qeAJoG2r_o.png" alt="在这里插入图片描述"></p> 
<p>​ <strong>将树转化为二叉树</strong>：1、加线，在兄弟结点之间加一条线；2、抹线，对于每个结点，除了其左孩子外，去除与其他孩子之间的关系；3、旋转，以树的根结点为轴心，将整个树顺时针旋转<strong>45°</strong>。示例：</p> 
<p><img src="https://images2.imgbox.com/b9/77/XlvSP8Wt_o.png" alt="在这里插入图片描述"></p> 
<p>​ <strong>将二叉树转化为树</strong>：1、加线，若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         … 
        
       
      
        \dots 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.12em; vertical-align: 0em;"></span><span class="minner">…</span></span></span></span></span>沿分支找到所有的右孩子，都与p的双亲用线连起来；2、抹线，抹掉原二叉树中双亲与右孩子之间的连线；3、调整，将结点按层次排列，形成树结构。</p> 
<p><img src="https://images2.imgbox.com/68/05/mjjCkZzF_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="5_2305"></a>5、森林和二叉树的转换</h5> 
<p>​ <strong>森林转换成二叉树</strong>：1、将各棵树分别转换成二叉树；2、将每棵树的根结点用线相连；3、以第一棵树根结点为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树结构。示例：</p> 
<p><img src="https://images2.imgbox.com/cf/b0/9Mk2STSx_o.png" alt="在这里插入图片描述"></p> 
<p>​ <strong>二叉树转换成森林</strong>：1、抹线，将二叉树中根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树；2、还原， 将孤立的二叉树还原成树。示例：</p> 
<p><img src="https://images2.imgbox.com/e1/aa/BcHGfYRp_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="8_2317"></a>（8）树与森林的遍历</h4> 
<h5><a id="1_2319"></a>1、树的遍历</h5> 
<p>​ 树的遍历主要包括三种方式。1、<strong>先根</strong>次序遍历：若树不为空，则先访问根结点，然后依次先根遍历各子树；2、<strong>后根</strong>次序遍历：若树不为空，则先依次后根遍历各子树，然后访问根结点；3、按<strong>层次</strong>遍历：若树不为空，则自上而下自左而右访问树中每个结点。</p> 
<h5><a id="2_2323"></a>2、森林的遍历</h5> 
<p>​ 将森林看作由<strong>三部分</strong>构成：1、森林中第一棵树的根结点；2、森林中第一棵树的子树森林；3、森林中其它树构成的森林。森林的遍历方式有：1、<strong>先序遍历</strong>：访问森林中第一棵树的根结点，先序遍历森林中第一棵树的子树森林，先序遍历森林中其余树构成的森林。2、<strong>中序遍历</strong>：中序遍历森林中第一棵子树的子树森林，访问森森林中第一棵树的根结点，中序遍历森林中其余树构成的森林。</p> 
<h4><a id="9_2327"></a>（9）<mark>哈夫曼树</mark></h4> 
<p>​ 哈夫曼树（最优二叉树）的<strong>基本概念</strong>，1、<strong>路径</strong>：从树中一个结点到另一个结点之间的<strong>分支</strong>构成这两个结点间的路径；2、<strong>结点</strong>的路径长度：两结点间路径上的分支数；3、<strong>树</strong>的路径长度：从树根结点到每个结点的路径长度之和，记作<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         L 
        
       
      
        TL 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mord mathdefault">L</span></span></span></span></span>；4、<strong>权</strong>：将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权；5、结点的<strong>带权路径长度</strong>（Weighted Path Length，WPL）：从根结点到该结点之间的路径长度<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         × 
        
       
      
        \times 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord">×</span></span></span></span></span>该结点的权；6、<strong>树</strong>的带权路径长度：树中所有<strong>叶子</strong>结点的带权路径长度之和，记作<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          W 
         
        
          P 
         
        
          L 
         
        
          = 
         
         
         
           ∑ 
          
          
          
            k 
           
          
            = 
           
          
            1 
           
          
         
           n 
          
         
         
          
          
            w 
           
          
            k 
           
          
          
          
            l 
           
          
            k 
           
          
         
        
       
         WPL=\sum_{k=1}^{n}{w_kl_k} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.13889em;">W</span><span class="mord mathdefault" style="margin-right: 0.13889em;">P</span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 2.95351em; vertical-align: -1.30211em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.6514em;"><span class="" style="top: -1.84789em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span class="" style="top: -3.05em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span><span class="" style="top: -4.3em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.30211em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: -0.02691em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: -0.01968em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span></span></span><br> 7、哈夫曼树的<strong>定义</strong>：<strong>最优树</strong>，带权路径长度（WPL）最短的树；8、哈夫曼树的<strong>定义</strong>：<strong>最优二叉树</strong>，带权路径长度（WPL）最短的二叉树。</p> 
<p>哈夫曼树的<strong>构造方法</strong>：</p> 
<blockquote> 
 <p>1、根据<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          n 
         
        
       
         n 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>个给定的权值<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          { 
         
         
          
          
            W 
           
          
            1 
           
          
         
           , 
          
          
          
            W 
           
          
            2 
           
          
         
           , 
          
         
           … 
          
          
          
            W 
           
          
            n 
           
          
         
        
          } 
         
        
       
         \{<!-- -->{W_1,W_2,\dots{W_n}}\} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">{<!-- --></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></span> 构成<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          n 
         
        
       
         n 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>棵二叉树的森林<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          F 
         
        
          = 
         
        
          { 
         
         
          
          
            T 
           
          
            1 
           
          
         
           , 
          
          
          
            T 
           
          
            2 
           
          
         
           , 
          
         
           … 
          
         
           , 
          
          
          
            T 
           
          
            n 
           
          
         
        
          } 
         
        
       
         F=\{<!-- -->{T_1,T_2,\dots,{T_n}}\} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.13889em;">F</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">{<!-- --></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></span>，其中<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           T 
          
         
           i 
          
         
        
       
         T_i 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>只有一个带权为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           W 
          
         
           i 
          
         
        
       
         W_i 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>的根结点。（构造森林全是根）</p> 
 <p>2、在<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          F 
         
        
       
         F 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.13889em;">F</span></span></span></span></span>中选取两棵根结点的权值最小的树作为左右子树，构造一棵新的二叉树，且设置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。（选用两小造新树）</p> 
 <p>3、在<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          F 
         
        
       
         F 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.13889em;">F</span></span></span></span></span>中删除这两棵树，同时将得到的二叉树加入森林中。（选用两小造新树）</p> 
 <p>4、重复2和3，直到森林中只有一棵树为止，这棵树即待构造的哈夫曼树。（删除两小添新人）</p> 
</blockquote> 
<p>哈夫曼树构造示例：</p> 
<p><img src="https://images2.imgbox.com/37/59/ORapVYFp_o.png" alt="在这里插入图片描述"></p> 
<p>哈夫曼树小结：</p> 
<p><img src="https://images2.imgbox.com/28/3d/QJnXItc8_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="10_2355"></a>（10）哈夫曼树的表示</h4> 
<p>​ 哈夫曼树实际上就是一种特殊的二叉树，可以采用顺序存储结构，也可以采用链式存储结构。</p> 
<h5><a id="1_2359"></a>1、哈夫曼树的<mark>顺序</mark>存储结构</h5> 
<p><img src="https://images2.imgbox.com/9d/12/W1YNmFuW_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c"><span class="token comment">//哈夫曼树Huffman Tree</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> weight<span class="token punctuation">;</span>
	<span class="token keyword">int</span> parent<span class="token punctuation">,</span> lch<span class="token punctuation">,</span> rch<span class="token punctuation">;</span>
<span class="token punctuation">}</span> HTNode<span class="token punctuation">,</span> <span class="token operator">*</span>HuffmanTree<span class="token punctuation">;</span>
</code></pre> 
<p>哈夫曼构造算法的实现：</p> 
<blockquote> 
 <p>1、初始化<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          H 
         
        
          T 
         
        
          [ 
         
        
          1 
         
        
          … 
         
         
         
           2 
          
         
           n 
          
         
           − 
          
         
           1 
          
         
        
          ] 
         
        
       
         HT[1\dots{2n-1}] 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.08125em;">H</span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord">1</span></span><span class="mclose">]</span></span></span></span></span>，lch=rch=parent=0。</p> 
 <p>2、输入初始<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          n 
         
        
       
         n 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>个叶子结点，置<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          H 
         
        
          T 
         
        
          [ 
         
        
          1 
         
        
          … 
         
        
          n 
         
        
          ] 
         
        
       
         HT[1\dots{n}] 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.08125em;">H</span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault">n</span></span><span class="mclose">]</span></span></span></span></span>的weight值。</p> 
 <p>3、进行以下<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          n 
         
        
          − 
         
        
          1 
         
        
       
         n-1 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>次合并，依次产生<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          n 
         
        
          − 
         
        
          1 
         
        
       
         n-1 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>个结点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          H 
         
        
          T 
         
        
          [ 
         
        
          i 
         
        
          ] 
         
        
          , 
         
        
          i 
         
        
          = 
         
        
          n 
         
        
          + 
         
        
          1 
         
        
          … 
         
         
         
           2 
          
         
           n 
          
         
           − 
          
         
           1 
          
         
        
       
         HT[i],i=n+1\dots{2n-1} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.08125em;">H</span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord">1</span></span></span></span></span></span>：</p> 
 <blockquote> 
  <p>a）在<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           H 
          
         
           T 
          
         
           [ 
          
         
           1 
          
         
           … 
          
          
          
            i 
           
          
            − 
           
          
            1 
           
          
         
           ] 
          
         
        
          HT[1\dots{i-1}] 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.08125em;">H</span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord">1</span></span><span class="mclose">]</span></span></span></span></span>中选择两个未被选过（从parent==0的结点中选择）的weight最小的两个结点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           H 
          
         
           T 
          
         
           [ 
          
         
           s 
          
         
           1 
          
         
           ] 
          
         
        
          HT[s1] 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.08125em;">H</span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">[</span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           H 
          
         
           T 
          
         
           [ 
          
         
           s 
          
         
           2 
          
         
           ] 
          
         
        
          HT[s2] 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.08125em;">H</span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">[</span><span class="mord mathdefault">s</span><span class="mord">2</span><span class="mclose">]</span></span></span></span></span>，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           s 
          
         
           1 
          
         
           , 
          
         
           s 
          
         
           2 
          
         
        
          s1,s2 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83888em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">s</span><span class="mord">2</span></span></span></span></span>为两个最小结点的下标。</p> 
  <p>b）修改<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           H 
          
         
           T 
          
         
           [ 
          
         
           s 
          
         
           1 
          
         
           ] 
          
         
        
          HT[s1] 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.08125em;">H</span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">[</span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           H 
          
         
           T 
          
         
           [ 
          
         
           s 
          
         
           2 
          
         
           ] 
          
         
        
          HT[s2] 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.08125em;">H</span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">[</span><span class="mord mathdefault">s</span><span class="mord">2</span><span class="mclose">]</span></span></span></span></span>的parent值，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           H 
          
         
           T 
          
         
           [ 
          
         
           s 
          
         
           1 
          
         
           ] 
          
         
           . 
          
         
           p 
          
         
           a 
          
         
           r 
          
         
           e 
          
         
           n 
          
         
           t 
          
         
           = 
          
         
           i 
          
         
        
          HT[s1].parent=i 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.08125em;">H</span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">[</span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span>；<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           H 
          
         
           T 
          
         
           [ 
          
         
           s 
          
         
           2 
          
         
           ] 
          
         
           . 
          
         
           p 
          
         
           a 
          
         
           r 
          
         
           e 
          
         
           n 
          
         
           t 
          
         
           = 
          
         
           i 
          
         
        
          HT[s2].parent=i 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.08125em;">H</span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">[</span><span class="mord mathdefault">s</span><span class="mord">2</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span>；</p> 
  <p>c）修改新产生的<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           H 
          
         
           T 
          
         
           [ 
          
         
           i 
          
         
           ] 
          
         
        
          HT[i] 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.08125em;">H</span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span></span>：</p> 
  <blockquote> 
   <ul><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             H 
            
           
             T 
            
           
             [ 
            
           
             i 
            
           
             ] 
            
           
             . 
            
           
             w 
            
           
             e 
            
           
             i 
            
           
             g 
            
           
             h 
            
           
             t 
            
           
             = 
            
           
             H 
            
           
             T 
            
           
             [ 
            
           
             s 
            
           
             1 
            
           
             ] 
            
           
             . 
            
           
             w 
            
           
             e 
            
           
             i 
            
           
             g 
            
           
             h 
            
           
             t 
            
           
             + 
            
           
             H 
            
           
             T 
            
           
             [ 
            
           
             s 
            
           
             2 
            
           
             ] 
            
           
             . 
            
           
             w 
            
           
             e 
            
           
             i 
            
           
             g 
            
           
             h 
            
           
             t 
            
           
          
            HT[i].weight=HT[s1].weight+HT[s2].weight 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.08125em;">H</span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.08125em;">H</span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">[</span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.08125em;">H</span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">[</span><span class="mord mathdefault">s</span><span class="mord">2</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span></span>；</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             H 
            
           
             T 
            
           
             [ 
            
           
             i 
            
           
             ] 
            
           
             . 
            
           
             l 
            
           
             c 
            
           
             h 
            
           
             = 
            
           
             s 
            
           
             1 
            
           
             ; 
            
           
             H 
            
           
             T 
            
           
             [ 
            
           
             i 
            
           
             ] 
            
           
             . 
            
           
             r 
            
           
             c 
            
           
             h 
            
           
             = 
            
           
             s 
            
           
             2 
            
           
          
            HT[i].lch=s1; HT[i].rch=s2 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.08125em;">H</span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mpunct">;</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.08125em;">H</span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord mathdefault">s</span><span class="mord">2</span></span></span></span></span>；</li></ul> 
  </blockquote> 
 </blockquote> 
</blockquote> 
<p><img src="https://images2.imgbox.com/4a/1d/nf19n1lD_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/f5/f7/dc4e4YGe_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="11_2395"></a>（11）哈夫曼编码</h4> 
<p>​ 哈夫曼编码：1、统计字符集中每个字符在电文中出现的平均概率（概率越大，要求编码越短）。2、利用哈夫曼树的特点，权越大的叶子离根越近；将每个字符的概率值作为权值，构造哈夫曼树，则概率越大的结点路径越短。3、在哈夫曼树的每个分支上标0或1，结点的左分支标0，右分支标1，把从根到每个叶子的路径上的标号连接起来，作为该叶子代表的字符的编码。示例：</p> 
<p><img src="https://images2.imgbox.com/98/5e/8FxmzaDI_o.png" alt="在这里插入图片描述"></p> 
<p>哈夫曼编码不仅能够保证是前缀码，并且能保证字符编码总长最短。</p> 
<p><img src="https://images2.imgbox.com/1b/d3/Fm2PRvMa_o.png" alt="在这里插入图片描述"></p> 
<p>哈夫曼编码的实现：<br> <img src="https://images2.imgbox.com/2d/d5/RDgoKJMc_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/06/38/3V9Wervv_o.png" alt="在这里插入图片描述"></p> 
<p>文件的编码和解码：</p> 
<p><img src="https://images2.imgbox.com/b8/15/GRNvRpdu_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/e9/28/HFUYd1p6_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h3><a id="_2424"></a>八、图</h3> 
<h4><a id="1_2426"></a>（1）图的定义</h4> 
<p>​ <strong>图</strong>是一种较为复杂的数据结构，在图中两个结点之间的关系可以是任意的，图中任意两个数据元素之间都有可能相关。在图中的数据元素通常称为顶点（Vertex），<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         V 
        
       
      
        V 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.22222em;">V</span></span></span></span></span>是顶点的有穷非空集合，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         E 
        
       
      
        E 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.05764em;">E</span></span></span></span></span>是边有穷集合；<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         V 
        
       
         R 
        
       
      
        VR 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.22222em;">V</span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span></span></span></span></span>是两个顶点之间的关系的集合。若<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ⟨ 
        
        
        
          v 
         
        
          , 
         
        
          w 
         
        
       
         ⟩ 
        
       
         ∈ 
        
       
         V 
        
       
         R 
        
       
      
        \langle{v,w}\rangle{\in}VR 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">⟨</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span></span><span class="mclose">⟩</span><span class="mord"><span class="mrel">∈</span></span><span class="mord mathdefault" style="margin-right: 0.22222em;">V</span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span></span></span></span></span> ，则<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ⟨ 
        
        
        
          v 
         
        
          , 
         
        
          w 
         
        
       
         ⟩ 
        
       
      
        \langle{v,w}\rangle 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">⟨</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span></span><span class="mclose">⟩</span></span></span></span></span>表示从<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         v 
        
       
      
        v 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span></span></span></span></span>到<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         w 
        
       
      
        w 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span></span></span></span></span>的一条弧（Arc），且称<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         v 
        
       
      
        v 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span></span></span></span></span>为弧尾（Tail），称<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         w 
        
       
      
        w 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span></span></span></span></span>尾弧头（Head），此时的图称为<strong>有向图</strong>（Digraph）。若<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ⟨ 
        
        
        
          v 
         
        
          , 
         
        
          w 
         
        
       
         ⟩ 
        
       
         ∈ 
        
        
        
          V 
         
        
          R 
         
        
       
      
        \langle{v,w}\rangle\in{VR} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">⟨</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span></span><span class="mclose">⟩</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.22222em;">V</span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span></span></span></span></span></span>，则必有<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ⟨ 
        
        
        
          w 
         
        
          , 
         
        
          v 
         
        
       
         ⟩ 
        
       
         ∈ 
        
        
        
          V 
         
        
          R 
         
        
       
      
        \langle{w,v}\rangle\in{VR} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">⟨</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span></span><span class="mclose">⟩</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.22222em;">V</span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span></span></span></span></span></span>，即<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         V 
        
       
         R 
        
       
      
        VR 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.22222em;">V</span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span></span></span></span></span>是对称的，则以无序对<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ( 
        
       
         v 
        
       
         , 
        
       
         w 
        
       
         ) 
        
       
      
        (v,w) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span><span class="mclose">)</span></span></span></span></span>代替这两个有序对，表示<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         v 
        
       
      
        v 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         w 
        
       
      
        w 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span></span></span></span></span>之间的一条边（Edge），此时的图称为<strong>无向图</strong>（Undigraph）。当任意两个顶点之间都具有边的时候，此时的图称为<strong>完全图</strong>，完全图又分为有向完全图和无向完全图。</p> 
<p><img src="https://images2.imgbox.com/c0/7e/1Mk3GHV9_o.png" alt="在这里插入图片描述"></p> 
<p>有很少的边或者弧<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ( 
        
       
         e 
        
       
         &lt; 
        
       
         n 
        
       
         l 
        
       
         o 
        
       
         g 
        
       
         n 
        
       
         ) 
        
       
      
        (e&lt;nlogn) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>的图称为<strong>稀疏图</strong>（Sparse graph），反之称为<strong>稠密图</strong>（Dense graph）。有些图的边或者弧具有与之相关的数，这种数称为<strong>权</strong>（Weight），这种带权的图称为<strong>网</strong>（Network)。</p> 
<p><img src="https://images2.imgbox.com/b2/ba/H92R2274_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/36/20/5KYcQUR2_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/27/c5/Vr83gdJZ_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/67/d8/aegTC2gZ_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/97/7a/boS59Qly_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/de/10/0Ue8n0nJ_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/70/27/eNKhpLg1_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/ef/75/bayu2apG_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2_2459"></a>（2）图的表示</h4> 
<p>​ 图没有顺序结构，但是可以借助二维数组来描述元素之间的关系。数组表示法可以采用<strong>邻接矩阵</strong>（数组表示法）来表示。图具有链式结构，可以采用<strong>邻接表</strong>（链式表示法）来表示。</p> 
<h5><a id="1_2463"></a>1、<mark>数组</mark>（邻接矩阵）表示法</h5> 
<p><img src="https://images2.imgbox.com/72/89/tifGWgdQ_o.png" alt="在这里插入图片描述"></p> 
<p>邻接矩阵表示示例：</p> 
<p><img src="https://images2.imgbox.com/b1/4c/mjjisuBI_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/4d/f1/jmX6kw2e_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/69/37/u5kc8uoz_o.png" alt="在这里插入图片描述"></p> 
<p>邻接矩阵表示图的类型定义：</p> 
<p><img src="https://images2.imgbox.com/b3/30/UgQROGkt_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c"><span class="token comment">//邻接矩阵表示图</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxInt</span> <span class="token expression"><span class="token number">32767</span>			</span><span class="token comment">//表示极大值，即无穷大</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MVNum</span> <span class="token expression"><span class="token number">100</span>				</span><span class="token comment">//最大顶点数</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">char</span> VerTexType<span class="token punctuation">;</span>		<span class="token comment">//设顶点数的数据类型为字符型</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> ArcType<span class="token punctuation">;</span>			<span class="token comment">//假设边的权值类型为整型</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	VerTexType vexs<span class="token punctuation">[</span>MVNum<span class="token punctuation">]</span><span class="token punctuation">;</span>		<span class="token comment">//顶点表</span>
	ArcType arcs<span class="token punctuation">[</span>MVNum<span class="token punctuation">]</span><span class="token punctuation">[</span>MVNum<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//邻接矩阵</span>
	<span class="token keyword">int</span> vexnum<span class="token punctuation">,</span> arcnum<span class="token punctuation">;</span>			<span class="token comment">//图的当前点数和边数</span>
<span class="token punctuation">}</span> AMGraph<span class="token punctuation">;</span>						<span class="token comment">//Adjecency Matrix Graph</span>
</code></pre> 
<p>1、采用邻接矩阵创建无向网</p> 
<p><img src="https://images2.imgbox.com/47/48/1Lx2MiSX_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/0e/72/IxOb8V48_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/57/ca/IT5S37fK_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/5e/20/CTDREsjb_o.png" alt="在这里插入图片描述"></p> 
<p>2、采用邻接矩阵创建无向图、有向图（由算法1改进而来）</p> 
<p><img src="https://images2.imgbox.com/0e/87/KGNer2h8_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2_2516"></a>2、<mark>链表</mark>（邻接表）表示法</h5> 
<p><img src="https://images2.imgbox.com/60/2d/YANXzyPW_o.png" alt="在这里插入图片描述"></p> 
<p>无向图的邻接表：</p> 
<p><img src="https://images2.imgbox.com/8f/07/LJyCjeDE_o.png" alt="在这里插入图片描述"></p> 
<p>有向图的邻接表：</p> 
<p><img src="https://images2.imgbox.com/1d/b7/2vcNnrFi_o.png" alt="在这里插入图片描述"></p> 
<p>邻接表表示法的实现：</p> 
<p><img src="https://images2.imgbox.com/60/bd/er6WPP7a_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/a1/dd/kKDfMQjl_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/9a/23/zSVGcjPr_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c"><span class="token comment">//邻接表表示法的实现</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MVNum</span> <span class="token expression"><span class="token number">100</span>			</span><span class="token comment">//最大顶点数</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Arcnode</span> <span class="token punctuation">{<!-- --></span>	<span class="token comment">//边结点</span>
	<span class="token keyword">int</span> adjvex<span class="token punctuation">;</span>				<span class="token comment">//该边所指向的顶点的位置</span>
	<span class="token keyword">struct</span> <span class="token class-name">Arcnode</span><span class="token operator">*</span> nextarc<span class="token punctuation">;</span>	<span class="token comment">//指向下一条边的指针</span>
	OtherInfo info<span class="token punctuation">;</span>				<span class="token comment">//和边相关的信息</span>
<span class="token punctuation">}</span>ArcNode<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Vnode</span> <span class="token punctuation">{<!-- --></span>
	VerTexType data<span class="token punctuation">;</span>		<span class="token comment">//顶点信息</span>
	ArcNode<span class="token operator">*</span> firstarc<span class="token punctuation">;</span>		<span class="token comment">//指向第一条衣服该顶点的指针</span>
<span class="token punctuation">}</span> VNode<span class="token punctuation">,</span> AdjList<span class="token punctuation">[</span>MVNum<span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token comment">//AdjList表示邻接表类型</span>
<span class="token comment">//图结构的定义</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	AdjList vertices<span class="token punctuation">;</span>		<span class="token comment">//vertices-vertex的复数</span>
	<span class="token keyword">int</span> vexnum<span class="token punctuation">;</span> arcnum<span class="token punctuation">;</span>		<span class="token comment">//图当前的顶点数和弧数</span>
<span class="token punctuation">}</span>ALGraph<span class="token punctuation">;</span>
</code></pre> 
<p>1、采用邻接表建立无向网</p> 
<p><img src="https://images2.imgbox.com/cd/15/In7shxQD_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/75/c6/KyPS1P2r_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/70/f2/uA4eCDfw_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="3_2572"></a>（3）图的遍历</h4> 
<p>​ 从已给的连通图中某一顶点出发，沿着一些边访问图中所有的顶点，且使每个顶点仅被访问一次，这就叫做图的遍历，它是图的基本运算。遍历的<strong>实质</strong>是找每个顶点的邻接点的过程。</p> 
<p>如何避免重复访问：</p> 
<p><img src="https://images2.imgbox.com/d0/19/xGNF0eRP_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="1Depth_First_Search__DFS_2581"></a>1、<mark>深度</mark>优先搜索遍历（Depth First Search — DFS）</h5> 
<p><img src="https://images2.imgbox.com/40/bd/Zqt2t7eZ_o.png" alt="在这里插入图片描述"></p> 
<p>用邻接矩阵实现图的深度优先搜索遍历：</p> 
<p><img src="https://images2.imgbox.com/36/6b/jB15PUqL_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2Breath_First_Search__BFS_2591"></a>2、<mark>广度</mark>优先搜索遍历（Breath First Search — BFS）</h5> 
<p><img src="https://images2.imgbox.com/e5/26/y0SNMhyz_o.png" alt="在这里插入图片描述"></p> 
<p>用邻接表实现图的广度优先搜索遍历：广度优先搜索遍历和树的层次遍历的思想类似。</p> 
<p><img src="https://images2.imgbox.com/c8/4b/esOb7kak_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="4_2601"></a>（4）图的应用</h4> 
<h5><a id="1_2603"></a>1、最小生成树</h5> 
<p>​ 生成树是所有顶点都连在一起，但不存在回路的图。</p> 
<p><img src="https://images2.imgbox.com/24/71/JuXDWufu_o.png" alt="在这里插入图片描述"></p> 
<p>​ 最小生成树：给定一个无向网，在该网的所有生成树中，使得各边权值之和最小的那棵生成树称为该网的最小生成树。</p> 
<p><img src="https://images2.imgbox.com/72/fe/GXHQeO7p_o.png" alt="在这里插入图片描述"></p> 
<p>MST性质</p> 
<p><img src="https://images2.imgbox.com/b1/94/aoTI2OHM_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/eb/3a/9yOpseCs_o.png" alt="在这里插入图片描述"></p> 
<p>构造最小生成树**普里姆（Prim）**算法：<br> <img src="https://images2.imgbox.com/93/c2/Dhf8iECT_o.png" alt="在这里插入图片描述"></p> 
<p>构造最小生成树**克鲁斯卡尔（Kruskal）**算法：（贪心算法）</p> 
<p><img src="https://images2.imgbox.com/0b/0d/hg7sn5JL_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2_2632"></a>2、最短路径</h5> 
<p>​ 最短路径问题：在有向图中A点（源点）到达B点（终点）的多条路径中，寻找一条各边权值之和最小的路径，即最短路径。第一类问题（<strong>单源最短路径</strong>）采用**Dijkstra（迪杰斯特拉）<strong>算法，第二类问题（<strong>所有顶点间的最短路径</strong>），采用</strong>Floyd（佛洛依德）**算法。</p> 
<p><strong>Dijkstra算法</strong>：</p> 
<p><img src="https://images2.imgbox.com/c9/79/d1dXABFu_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/36/6e/b9NUkmRc_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/96/44/bLe9IWwx_o.png" alt="在这里插入图片描述"></p> 
<p><strong>Floyd算法</strong>：</p> 
<p><img src="https://images2.imgbox.com/19/26/lt0Vsfdv_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="3_2652"></a>3、拓扑排序</h5> 
<p>有向无环图：是一种特殊的有向图，该有向图中没有环形结构。</p> 
<p><img src="https://images2.imgbox.com/08/c6/3eLwmqjW_o.png" alt="在这里插入图片描述"></p> 
<p>​ <strong>拓扑排序</strong>：在AOV网没有回路的前提下，我们将全部活动排列成一个线性序列，使得若AOV网中有弧<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         &lt; 
        
       
         i 
        
       
         , 
        
       
         j 
        
       
         &gt; 
        
       
      
        &lt;i,j&gt; 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5782em; vertical-align: -0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.05724em;">j</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&gt;</span></span></span></span></span>存在，则在这个序列中，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         i 
        
       
      
        i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span>一定排在<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         j 
        
       
      
        j 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.05724em;">j</span></span></span></span></span>的前面，具有这种性质的线性序列称为拓扑有序序列，相应的拓扑有序排序的算法称为拓扑排序。</p> 
<p><img src="https://images2.imgbox.com/b5/31/WaVI9D7e_o.png" alt="在这里插入图片描述"></p> 
<p>拓扑排序的作用是，判断图中是否存在环，如果图中存在环，那么存在一些顶点不在图的拓扑序列中。</p> 
<h5><a id="4_2666"></a>4、关键路径</h5> 
<p><img src="https://images2.imgbox.com/f0/0c/mdG5yPpK_o.png" alt="在这里插入图片描述"></p> 
<p>关键路径的描述量：</p> 
<p><img src="https://images2.imgbox.com/f9/aa/eWq1afdr_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/a3/31/74HWYkF6_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/8c/2f/x3qVscK6_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/a6/62/r7JTl8Im_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_2685"></a>九、查找</h3> 
<h4><a id="1__2687"></a>（1） 查找表</h4> 
<p>​ 查找表是由同一类型的数据元素构成的集合，由于“集合”中的数据元素之间存在着松散的关系，因此查找表是一种应用灵便的结构。查找是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素或记录，若查找表中存在这样一个记录，则称为“查找成功”，此时给出整个记录的信息，或者指示该记录在查找表中的位置；否则称为“查找失败”，查找结果给出空指针。查找算法的评价指标：<strong>关键字平均比较次数</strong>，也称为<strong>平均比较长度</strong>（<strong>ASL</strong>，Average Search Length）<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          A 
         
        
          S 
         
        
          L 
         
        
          = 
         
         
         
           ∑ 
          
          
          
            i 
           
          
            = 
           
          
            1 
           
          
         
           n 
          
         
         
          
          
            p 
           
          
            i 
           
          
          
          
            c 
           
          
            i 
           
          
         
        
       
         ASL=\sum_{i=1}^{n}{p_ic_i} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 2.92907em; vertical-align: -1.27767em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.6514em;"><span class="" style="top: -1.87233em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span class="" style="top: -3.05001em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span><span class="" style="top: -4.30001em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.27767em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span></span></span><br> 其中，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
      
        n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>是记录个数，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          i 
         
        
       
      
        p_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>查找的第<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         i 
        
       
      
        i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span>个记录的概率（通常认为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          i 
         
        
       
         = 
        
       
         1 
        
       
         / 
        
       
         n 
        
       
      
        p_i=1/n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault">n</span></span></span></span></span>），<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          c 
         
        
          i 
         
        
       
      
        c_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>是找到的第<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         i 
        
       
      
        i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span>个记录所需的比较次数。查找表分为静态查找表和动态查找表。</p> 
<h4><a id="2_2695"></a>（2）线性表的查找</h4> 
<h5><a id="1_2697"></a>1、顺序查找（线性查找）</h5> 
<p>​ 应用范围：1、顺序表或线性表表示的静态查找表；2、表内元素之间无序。<strong>思想</strong>：从线性表的某一端开始，遍历线性表进行查找。</p> 
<p><img src="https://images2.imgbox.com/e9/73/gZmzk9E4_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/c0/b3/3KJJpcon_o.png" alt="在这里插入图片描述"></p> 
<p>为了避免每次查找都进行两次比较，可以作如下改进：<strong>带哨兵的顺序查找</strong></p> 
<p><img src="https://images2.imgbox.com/92/51/oXU7Jebg_o.png" alt="在这里插入图片描述"></p> 
<p>当待查找的长度过长时，这样改进之后能使所需的平均时间减少一半。</p> 
<p>顺序查找的复杂度分析：</p> 
<p><img src="https://images2.imgbox.com/7b/0b/lCVeW2Zc_o.png" alt="在这里插入图片描述"></p> 
<p>顺序查找的<strong>特点</strong>：1、算法简单，逻辑次序无要求，且不同存储结构均适用；2、缺点是时间复杂度高。</p> 
<h5><a id="2_2721"></a>2、二分查找</h5> 
<p>​ 应用范围：表内之间元素有序，且顺序可知。<strong>思想</strong>是：每次将待查找的记录所在的区间缩小一半。</p> 
<p><img src="https://images2.imgbox.com/63/fe/Pgqd70n5_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/9f/f3/PCpocvvC_o.png" alt="在这里插入图片描述"></p> 
<p>非递归的写法：</p> 
<p><img src="https://images2.imgbox.com/66/e7/qE0vOli7_o.png" alt="在这里插入图片描述"></p> 
<p>递归的写法：</p> 
<p><img src="https://images2.imgbox.com/32/be/dc1Y8eOw_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/d6/09/MYB54mjW_o.png" alt="在这里插入图片描述"></p> 
<p>​ 二分查找的特点：优点，查找效率比顺序查找高；缺点，只适用于有序表，且限于顺序存储结构（对线性表链表无效）。</p> 
<h5><a id="3_2746"></a>3、分块查找</h5> 
<p>分块查找法的思想：</p> 
<p><img src="https://images2.imgbox.com/93/70/AVjb7Aqs_o.png" alt="在这里插入图片描述"></p> 
<p>分块查找法的时间效率：</p> 
<p><img src="https://images2.imgbox.com/56/ed/M3joZOyr_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/b5/64/FRG7K2SS_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="3_2761"></a>（3）树表的查找</h4> 
<p>​ 当表插入、删除等操作频繁时，为了维护表的有序性，需要移动很多记录，此时就可以采用动态查找表。表的结构在查找的过程中动态生成。</p> 
<p>​ <mark><strong>二叉排序树</strong></mark>（Binary Sort Tree），又称为二叉搜索树，二叉查找树。二叉排序树的定义：1、若其左子树非空，则左子树上所有结点的值均<strong>小于</strong>根结点的值；2、若其右子树非空，则右子树上的所有节点的值均<strong>大于等于</strong>根结点的值；3、其左右子树本身又各是一棵二叉排序树。</p> 
<p>二叉排序树的<strong>性质</strong>：</p> 
<p><img src="https://images2.imgbox.com/eb/22/12Bh3xMp_o.png" alt="在这里插入图片描述"></p> 
<p>二叉排序树的<strong>存储</strong>：采用二叉链表来进行存储</p> 
<p><img src="https://images2.imgbox.com/77/8a/DgaEoZGK_o.png" alt="在这里插入图片描述"></p> 
<p>二叉排序树的<strong>查找</strong>：（递归算法）</p> 
<p><img src="https://images2.imgbox.com/28/b5/gZezrp9T_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/10/72/tHBSEDY7_o.png" alt="在这里插入图片描述"></p> 
<p>二叉排序树查找<strong>性能分析</strong>：</p> 
<p><img src="https://images2.imgbox.com/d6/69/nZBydm8V_o.png" alt="在这里插入图片描述"></p> 
<p>二叉排序树的<strong>插入</strong>：<br> <img src="https://images2.imgbox.com/fc/e7/H720xFkQ_o.png" alt="在这里插入图片描述"></p> 
<p>二叉排序树的<strong>生成</strong>：从空树出发，经过一系列的查找、插入操作之后，可以生成一棵二叉排序树。</p> 
<p>​ <mark><strong>平衡二叉树</strong></mark>（Balanced Binary Tree）又称为（AVL树），一棵平衡二叉树或者是空树，或者是具有下列性质的二叉排序树：1、左子树与右子树的高度只差的绝对值小于等于1；2、左子树和右子树也是平衡二叉排序树。<strong>平衡因子</strong>就是左子树的高度减去右子树高度的绝对值。</p> 
<p>平衡二叉树的调整有四种，分别是LL、RR、LR、RL调整。</p> 
<h4><a id="4_2800"></a>（4）<mark>哈希表</mark>的查找</h4> 
<p>​ <strong>哈希表</strong>又称为<strong>散列表</strong>，其基本思想：记录的存储位置与关键字之间存在对应关系——hash函数，通过hash函数就可以对元素进行查找，查找效率高，但是空间效率低。</p> 
<p>​ <strong>关键术语</strong>：1、<strong>散列方法</strong>，选取某个函数，依照该函数按照关键字计算元素的存储位置，并按此存放；查找时，由同一个函数对给定值k计算地址，将k与地址单元中元素关键码进行比对，确定查找是否成功。2、<strong>散列函数</strong>（hash），散列方法中运用的转换函数。3、<strong>散列表</strong>，按照上述思想构造的表。 4、<strong>冲突</strong>，不同关键码映射到同一个散列地址上。</p> 
<p>​ 散列函数的<strong>构造方法</strong>：</p> 
<p><img src="https://images2.imgbox.com/13/4a/3TZS4NWi_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/fd/fd/90w6tVlw_o.png" alt="在这里插入图片描述"></p> 
<p><strong>直接定址法</strong>：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         H 
        
       
         a 
        
       
         s 
        
       
         h 
        
       
         ( 
        
       
         k 
        
       
         e 
        
       
         y 
        
       
         ) 
        
       
         = 
        
       
         a 
        
       
         × 
        
        
        
          k 
         
        
          e 
         
        
          y 
         
        
       
         + 
        
       
         b 
        
       
      
        Hash(key)=a\times{key}+b 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.08125em;">H</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">b</span></span></span></span></span>（<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         a 
        
       
         、 
        
       
         b 
        
       
      
        a、b 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">a</span><span class="mord cjk_fallback">、</span><span class="mord mathdefault">b</span></span></span></span></span>为常数），优点是以关键字<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         k 
        
       
         e 
        
       
         y 
        
       
      
        key 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span></span></span></span></span>的某个线性函数为散列地址，不会产生冲突。缺点是要占用连续的地址空间，空间效率较低。</p> 
<p><strong>除留余数法</strong>：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         H 
        
       
         a 
        
       
         s 
        
       
         h 
        
       
         ( 
        
       
         k 
        
       
         e 
        
       
         y 
        
       
         ) 
        
       
         = 
        
       
         k 
        
       
         e 
        
       
         y 
        
        
        
        
          m 
         
        
          o 
         
        
          d 
         
        
        
       
         p 
        
       
      
        Hash(key)=key\qquad{mod}\qquad{p} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.08125em;">H</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span><span class="mspace" style="margin-right: 2em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span></span><span class="mspace" style="margin-right: 2em;"></span><span class="mord"><span class="mord mathdefault">p</span></span></span></span></span></span>（<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         p 
        
       
      
        p 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span></span>是一个整数），设表长为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         m 
        
       
      
        m 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">m</span></span></span></span></span>，取<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         p 
        
       
         ≤ 
        
       
         m 
        
       
      
        p\le{m} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83041em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault">m</span></span></span></span></span></span>且<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         p 
        
       
      
        p 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span></span>为质数。</p> 
<p>​ <strong>解决散列表中的冲突</strong>问题的方法：1、开放定址法（开地址法）；2、链地址法（拉链法）；3、再散列法（双散列函数法）；4、建立一个公共溢出区。</p> 
<p><strong>1、开放定址法</strong>：有冲突时就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将数据元素存入。</p> 
<p><img src="https://images2.imgbox.com/70/f0/UeUDr8Ss_o.png" alt="在这里插入图片描述"></p> 
<p><strong>线性探测法</strong>的示例：</p> 
<p><img src="https://images2.imgbox.com/0a/c3/mkSuGaDr_o.png" alt="在这里插入图片描述"></p> 
<p><strong>二次探测法</strong>的示例：</p> 
<p><img src="https://images2.imgbox.com/cf/66/SBjF7NzJ_o.png" alt="在这里插入图片描述"></p> 
<p><strong>2、链地址法</strong>：将具有相同散列地址的记录链成一单链表，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         m 
        
       
      
        m 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">m</span></span></span></span></span>个散列地址就设<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         m 
        
       
      
        m 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">m</span></span></span></span></span>个单链表，然后用一个数组将<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         m 
        
       
      
        m 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">m</span></span></span></span></span>个单链表的表头指针存储起来，形成一个动态结构。（散列表的链式存储结构）</p> 
<p><img src="https://images2.imgbox.com/ce/59/ruAE7XZD_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/51/ee/CKxj2OuW_o.png" alt="在这里插入图片描述"></p> 
<p>散列表的<strong>查找</strong>：</p> 
<p><img src="https://images2.imgbox.com/a2/9f/wHGMlmVm_o.png" alt="在这里插入图片描述"></p> 
<p>散列表的<strong>查找效率</strong>分析：</p> 
<p><img src="https://images2.imgbox.com/9d/b1/CyBY6smX_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h3><a id="_2855"></a>十、排序</h3> 
<p>​ 排序是将一组杂乱无章的数据按照一定规律顺次排列起来，即将无序序列排成一个有序序列的运算。排序的分类：</p> 
<p><img src="https://images2.imgbox.com/49/3b/imUMzo7A_o.png" alt="在这里插入图片描述"></p> 
<p>排序算法是否稳定，看排序的过程中记录的相对次序是否发生改变，若发生改变那么是不稳定的，反之，是稳定的。自然排序，如果排序算法在序列基本有序的情况下，排序速率越快，那么排序算法是自然的，反之，是非自然的。</p> 
<p><img src="https://images2.imgbox.com/d3/ed/1einbajW_o.png" alt="在这里插入图片描述"></p> 
<p>待排序的数据存储结构定义：</p> 
<p><img src="https://images2.imgbox.com/8e/db/dJeDWoTY_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="1_2872"></a>（1）插入排序</h4> 
<p>​ 基本<strong>思想</strong>：每步将一个待排序的对象，按其关键码的大小，插入到前面已经排好序的一组对象的适当位置上，直到对象全部插入为止。</p> 
<p><img src="https://images2.imgbox.com/f8/bc/wJFxZBd5_o.png" alt="在这里插入图片描述"></p> 
<p>插入排序的分类：</p> 
<p><img src="https://images2.imgbox.com/49/16/JY92LGIO_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="1_2884"></a>1、直接插入排序</h5> 
<p><img src="https://images2.imgbox.com/29/16/Ja0wERyW_o.png" alt="在这里插入图片描述"></p> 
<p>使用带<strong>哨兵</strong>的直接插入排序：</p> 
<p><img src="https://images2.imgbox.com/49/e5/ntAwPe5p_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/b3/f2/vrCNkMUG_o.png" alt="在这里插入图片描述"></p> 
<p>直接插入排序的<strong>时间复杂度</strong>分析：</p> 
<p><img src="https://images2.imgbox.com/a7/28/sKJymQAm_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2_2902"></a>2、折半插入排序</h5> 
<p><img src="https://images2.imgbox.com/db/82/FJHi7PXs_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/c1/71/wdTvOPUi_o.png" alt="在这里插入图片描述"></p> 
<p>折半插入排序时间复杂度分析：</p> 
<p><img src="https://images2.imgbox.com/70/79/YHNPPnAc_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="3_2915"></a>3、<mark>希尔</mark>排序</h5> 
<p>​ <strong>基本思想</strong>：先将整个待排序的记录序列分割成若干子序列，分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序。希尔排序的特点是：1、缩小增量，2、多遍插入排序。示例：</p> 
<p><img src="https://images2.imgbox.com/f7/4c/rIMaR4cV_o.png" alt="在这里插入图片描述"></p> 
<p>​ 希尔排序的<strong>基本思路</strong>：1、定义增量序列<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          D 
         
        
          K 
         
        
       
         : 
        
        
        
          D 
         
        
          M 
         
        
       
         &gt; 
        
        
        
          D 
         
         
         
           M 
          
         
           − 
          
         
           1 
          
         
        
       
         &gt; 
        
       
         … 
        
        
        
          &gt; 
         
         
         
           D 
          
         
           1 
          
         
        
       
         = 
        
       
         1 
        
       
      
        D_K:D_M&gt;D_{M-1}&gt;\dots{&gt;D_1}=1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.02778em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.02778em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.891661em; vertical-align: -0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.02778em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.10903em;">M</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.208331em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.02778em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>；2、对每个<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          D 
         
        
          K 
         
        
       
      
        D_K 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.02778em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>进行"<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          D 
         
        
          K 
         
        
       
         − 
        
       
         间 
        
       
         隔 
        
       
      
        D_K-间隔 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.02778em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0em; vertical-align: 0em;"></span><span class="mord cjk_fallback">间</span><span class="mord cjk_fallback">隔</span></span></span></span></span>"插入排序（<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         K 
        
       
         = 
        
       
         M 
        
       
         , 
        
       
         M 
        
       
         − 
        
       
         1 
        
       
         , 
        
       
         … 
        
        
        
          , 
         
        
          1 
         
        
       
      
        K=M,M-1,\dots{,1} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.07153em;">K</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.87777em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.10903em;">M</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.10903em;">M</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.83888em; vertical-align: -0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">1</span></span></span></span></span></span>）</p> 
<p><img src="https://images2.imgbox.com/7b/e2/7VryMzir_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/9d/b6/iCaEc0fi_o.png" alt="在这里插入图片描述"></p> 
<p>希尔排序的时间复杂度分析：</p> 
<p><img src="https://images2.imgbox.com/70/4c/yIoOUhCB_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2_2935"></a>（2）交换排序</h4> 
<h5><a id="1_2937"></a>1、冒泡排序</h5> 
<p>​ 基本<strong>思想</strong>：每趟不断将记录两两进行比较，并按照前小后大规则进行交换。</p> 
<p><img src="https://images2.imgbox.com/d4/c2/IwTz9bU8_o.png" alt="在这里插入图片描述"></p> 
<p>当某一趟比较时不出想记录的交换，说明已经排好序了，可以结束算法了。</p> 
<p><img src="https://images2.imgbox.com/62/7c/2v0oXpGJ_o.png" alt="在这里插入图片描述"></p> 
<p>冒泡排序的时间复杂分析：</p> 
<p><img src="https://images2.imgbox.com/6b/3e/NcR925FT_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2_2954"></a>2、<mark>快速</mark>排序</h5> 
<p>​ 基本思想：任取一个元素作为中心，所有比它小的元素一律放在前面，比它大的元素一律后放，形成左右两个子表。对各子表重新选择中心元素并依次规则进行调整，直到每个子表的元素只有一个。</p> 
<p><img src="https://images2.imgbox.com/de/81/HN9nLoeb_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/7a/2d/ofu1Mf4q_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/f1/7f/WO530t7i_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/ff/dc/Nj4MudvV_o.png" alt="在这里插入图片描述"></p> 
<p>快速排序的时间复杂度分析：</p> 
<p><img src="https://images2.imgbox.com/ce/c6/pi4OwdYB_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/ab/a8/qDuDrWhB_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/1f/25/DoY17C88_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="3_2981"></a>（3）选择排序</h4> 
<p>​ 基本<strong>思想</strong>：在待排序的数据中选出最大（小）的元素放在最终的位置。基本<strong>操作</strong>：1、首先通过<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
         − 
        
       
         1 
        
       
      
        n-1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>次关键字比较，从<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
      
        n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>个记录中找出关键字最小的记录，将他与第一个记录交换；2、再通过<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
         − 
        
       
         2 
        
       
      
        n-2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">2</span></span></span></span></span>次比较，从剩余的<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
         − 
        
       
         1 
        
       
      
        n-1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>个记录中找出关键字次小的记录，将它与第二个记录交换；3、重复上述操作，共进行<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
         − 
        
       
         1 
        
       
      
        n-1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>趟排序后，排序结束。</p> 
<h5><a id="1_2985"></a>1、直接选择排序</h5> 
<p><img src="https://images2.imgbox.com/85/fb/UOgfPfOe_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2_2990"></a>2、<mark>堆</mark>排序</h5> 
<p>​ 堆的<strong>定义</strong>：若<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
      
        n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>个元素的序列<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         { 
        
        
        
          a 
         
        
          1 
         
        
       
         , 
        
        
        
          a 
         
        
          2 
         
        
       
         , 
        
       
         … 
        
       
         , 
        
        
        
          a 
         
        
          n 
         
        
       
         } 
        
       
      
        \{a_1,a_2,\dots ,a_n\} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">{<!-- --></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></span>满足<br> <span class="katex--display">KaTeX parse error: Unknown column alignment: * at position 39: … \begin{array}{*̲*lr**} a_i\le…</span><br> 则分别称该序列<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         { 
        
        
        
          a 
         
        
          1 
         
        
       
         , 
        
        
        
          a 
         
        
          2 
         
        
       
         , 
        
       
         … 
        
       
         , 
        
        
        
          a 
         
        
          n 
         
        
       
         } 
        
       
      
        \{a_1,a_2,\dots ,a_n\} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">{<!-- --></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></span>为<strong>小根堆</strong>和<strong>大根堆</strong>。从<strong>堆</strong>的定义可以看出，堆实质是满足如下性质的<strong>完全二叉树</strong>：二叉树中任一非叶子结点均<strong>小于</strong>（<strong>大于</strong>）它的孩子结点。</p> 
<p>堆判别的示例：</p> 
<p><img src="https://images2.imgbox.com/d1/1d/7x1jlzf9_o.png" alt="在这里插入图片描述"></p> 
<p>​ 堆排序的<strong>思想</strong>：若在输出堆顶的最小值（最大值）后，使得<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
         − 
        
       
         1 
        
       
      
        n-1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>个元素的序列又建成一个堆，则得到<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
      
        n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>个元素的次小值（次大值）…如此反复，便能得到一个有序序列，这个过程称为<strong>堆排序</strong>。</p> 
<p>​ 堆的<strong>向下调整</strong>：</p> 
<p><img src="https://images2.imgbox.com/50/cd/jNGV0NjT_o.png" alt="在这里插入图片描述"></p> 
<p>堆的实现采用<strong>顺序表</strong>的结构，具体的关系如下，父亲结点和孩子结点之间的<strong>编号关系</strong>：<strong>当列表从0开始编号时</strong>，1、父亲结点和左孩子结点之间的编号关系<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         i 
        
       
         → 
        
        
        
          2 
         
        
          i 
         
        
          + 
         
        
          1 
         
        
       
      
        i\to{2i+1} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.74285em; vertical-align: -0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord">1</span></span></span></span></span></span>；2、父亲结点和右孩子之间的编号关系<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         i 
        
       
         → 
        
        
        
          2 
         
        
          i 
         
        
          + 
         
        
          2 
         
        
       
      
        i\to{2i+2} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.74285em; vertical-align: -0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord">2</span></span></span></span></span></span>；3、从孩子结点找父亲结点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         i 
        
       
         → 
        
        
        
          ⌊ 
         
         
         
           ( 
          
         
           i 
          
         
           − 
          
         
           1 
          
         
           ) 
          
         
           / 
          
         
           2 
          
         
           ⌋ 
          
         
        
       
      
        i\to{\lfloor{(i-1)/2\rfloor}} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mopen">⌊</span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">⌋</span></span></span></span></span></span></span>。<strong>当列表从1开始编号时</strong>，1、父亲结点和左孩子结点之间的编号关系<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         i 
        
       
         → 
        
        
        
          2 
         
        
          i 
         
        
       
      
        i\to{2i} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathdefault">i</span></span></span></span></span></span>；2、父亲结点和右孩子之间的编号关系<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         i 
        
       
         → 
        
        
        
          2 
         
        
          i 
         
        
          + 
         
        
          1 
         
        
       
      
        i\to{2i+1} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.74285em; vertical-align: -0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord">1</span></span></span></span></span></span>；3、从孩子结点找父亲结点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         i 
        
       
         → 
        
        
        
          ⌊ 
         
         
         
           i 
          
         
           / 
          
         
           2 
          
         
           ⌋ 
          
         
        
       
      
        i\to{\lfloor{i/2\rfloor}} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mopen">⌊</span><span class="mord"><span class="mord mathdefault">i</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">⌋</span></span></span></span></span></span></span>。</p> 
<p><img src="https://images2.imgbox.com/83/fc/MUEiC7AL_o.png" alt="在这里插入图片描述"></p> 
<p>​ 堆的<strong>建立</strong>：</p> 
<p><img src="https://images2.imgbox.com/de/9f/7E6K9MzJ_o.png" alt="在这里插入图片描述"></p> 
<p>堆建立的示例：</p> 
<p><img src="https://images2.imgbox.com/20/c1/oexg3Sce_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/60/77/cSILYFpt_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/e8/96/8DgSX2JY_o.png" alt="在这里插入图片描述"></p> 
<p><strong>堆排序算法</strong>：</p> 
<p><img src="https://images2.imgbox.com/65/50/2QhT8D8p_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="4_3048"></a>（4）归并排序</h4> 
<p>​ 基本<strong>思想</strong>：将两个或两个以上的有序子序列“归并”为一个有序子序列。在内部排序中，通常采用的是2-路归并排序。即：将两个位置相邻的有序子序列<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         R 
        
       
         [ 
        
       
         l 
        
       
         … 
        
       
         m 
        
       
         ] 
        
       
      
        R[l\dots{m}] 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault">m</span></span><span class="mclose">]</span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         R 
        
       
         [ 
        
       
         m 
        
       
         + 
        
       
         1 
        
       
         … 
        
       
         n 
        
       
         ] 
        
       
      
        R[m+1\dots{n}] 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault">n</span></span><span class="mclose">]</span></span></span></span></span>归并为一个有序子序列<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         R 
        
       
         [ 
        
       
         l 
        
       
         … 
        
       
         n 
        
       
         ] 
        
       
      
        R[l\dots{n}] 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault">n</span></span><span class="mclose">]</span></span></span></span></span>。</p> 
<p><img src="https://images2.imgbox.com/ab/24/GGxShRZ5_o.png" alt="在这里插入图片描述"></p> 
<p>归并排序<strong>算法</strong>：</p> 
<p><img src="https://images2.imgbox.com/b9/a7/5ns8CB4V_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="5_3060"></a>（5）基数排序</h4> 
<p>​ 基本<strong>思想</strong>：分配+收集，也叫桶排序或箱排序，设置若干个箱子，将关键字为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         k 
        
       
      
        k 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span></span></span></span></span>的记录放入第<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         k 
        
       
      
        k 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span></span></span></span></span>个箱子，让后再按序号将非空的箱子连接。基数排序：数字是有范围的，均由<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         0 
        
       
         ∼ 
        
       
         9 
        
       
      
        0\sim9 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">9</span></span></span></span></span>这十个数字组成，则只需设置十个箱子，相继按个、十、百…进行搜索。</p> 
<h4><a id="6_3064"></a>（6）排序算法小结</h4> 
<p><img src="https://images2.imgbox.com/8e/21/Be0I5wL2_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/77/47/Lr0Ym7Kp_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h3><a id="A_ASCII_3075"></a>附录A- ASCII</h3> 
<p><img src="https://images2.imgbox.com/74/95/J2MbrJS3_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/91a211f2ba9efb58a781b2192e4c309a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">在VScode中配置Python开发环境</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/efb460c7bbe263442937142cdd9d89b9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Go语言超全详解（入门级）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>