<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>树莓派4B学习笔记14：Python多线程编程_线程间的同步通信_(锁‘threading.Lock’) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/0a6a6083c9ce0dcc4cb65ea3d6b1b9e3/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="树莓派4B学习笔记14：Python多线程编程_线程间的同步通信_(锁‘threading.Lock’)">
  <meta property="og:description" content="今日继续学习树莓派4B 4G：（Raspberry Pi，简称RPi或RasPi）
本人所用树莓派4B 装载的系统与版本如下:
版本可用命令 (lsb_release -a) 查询:
Opencv 版本是4.5.1：
今日学习树莓派与Python的多进程编程_线程间同步通信
文章提供测试代码讲解，整体代码贴出、测试效果图
目录
建立简单的多线程：
创建一个新的线程对象：
代码示例：
测试效果与解释：
join方法的使用：
线程间的同步与通信：
问题代码与说明：
竞态条件：
使用锁同步对共享资源的访问：
代码改进提示：
网上学习网址贴出：
建立简单的多线程： 创建一个新的线程对象： threading.Thread 类用于创建一个新的线程对象。
这个类接受几个参数，其中最重要的是 target 和 args
target
target 参数是一个可调用的对象（如函数或方法），当线程启动时，这个对象会被线程执行。在这个例子中，target 被设置为 counter 函数，所以新创建的线程会执行 counter 函数。
args
args 参数是一个元组，用于给 target 函数传递参数。在这个例子中，args 是一个只包含一个元素的元组，即字符串 &#34;计数A&#34;。当 t1 线程启动并调用 counter 函数时，它会传递这个字符串作为参数。
需要注意的是，由于 args 需要是一个元组，所以即使只传递一个参数，也需要用逗号 , 来表明它是一个元组（在只有一个元素的元组后面加上逗号是一个常见的约定）。
代码示例： 以下代码简单示例了如何编写一个简单的多线程程序：
# -*- coding: utf-8 -*- import time import threading def counter(name): for i in range(5): print(name, i) time.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-28T21:25:52+08:00">
    <meta property="article:modified_time" content="2024-06-28T21:25:52+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">树莓派4B学习笔记14：Python多线程编程_线程间的同步通信_(锁‘threading.Lock’)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>今日继续学习<a href="https://so.csdn.net/so/search?q=%E6%A0%91%E8%8E%93%E6%B4%BE4B&amp;spm=1001.2101.3001.7020" title="树莓派4B">树莓派4B</a> 4G：（Raspberry Pi，简称RPi或RasPi）</p> 
<blockquote> 
 <p><strong> 本人所用树莓派4B 装载的系统与版本如下:</strong></p> 
 <p><strong> 版本可用命令 (lsb_release -a) 查询:</strong></p> 
 <p><img alt="" height="159" src="https://images2.imgbox.com/e5/04/87q9KoMr_o.png" width="752"></p> 
 <p><strong> Opencv 版本是4.5.1：</strong></p> 
 <p><img alt="" height="41" src="https://images2.imgbox.com/03/1b/s7FQLPU0_o.png" width="610"></p> 
</blockquote> 
<p> 今日学习树莓派与Python的多进程编程_线程间同步通信</p> 
<p><span style="color:#be191c;"> <strong>文章提供测试代码讲解，整体代码贴出、测试效果图</strong></span></p> 
<blockquote> 
 <p id="main-toc"><strong>目录</strong></p> 
 <p id="-toc" style="margin-left:0px;"></p> 
 <p id="%E5%BB%BA%E7%AB%8B%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%BB%BA%E7%AB%8B%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9A" rel="nofollow">建立简单的多线程：</a></p> 
 <p id="%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AF%B9%E8%B1%A1%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AF%B9%E8%B1%A1%EF%BC%9A" rel="nofollow">创建一个新的线程对象：</a></p> 
 <p id="%C2%A0%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%C2%A0%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A" rel="nofollow"> 代码示例：</a></p> 
 <p id="%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C%E4%B8%8E%E8%A7%A3%E9%87%8A%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C%E4%B8%8E%E8%A7%A3%E9%87%8A%EF%BC%9A" rel="nofollow">测试效果与解释：</a></p> 
 <p id="join%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A-toc" style="margin-left:40px;"><a href="#join%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A" rel="nofollow">join方法的使用：</a></p> 
 <p id="%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E9%80%9A%E4%BF%A1%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E9%80%9A%E4%BF%A1%EF%BC%9A" rel="nofollow">线程间的同步与通信：</a></p> 
 <p id="%E9%97%AE%E9%A2%98%E4%BB%A3%E7%A0%81%E4%B8%8E%E8%AF%B4%E6%98%8E%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E9%97%AE%E9%A2%98%E4%BB%A3%E7%A0%81%E4%B8%8E%E8%AF%B4%E6%98%8E%EF%BC%9A" rel="nofollow">问题代码与说明：</a></p> 
 <p id="%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6%EF%BC%9A" rel="nofollow">竞态条件：</a></p> 
 <p id="%E4%BD%BF%E7%94%A8%E9%94%81%E5%90%8C%E6%AD%A5%E5%AF%B9%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E4%BD%BF%E7%94%A8%E9%94%81%E5%90%8C%E6%AD%A5%E5%AF%B9%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE%EF%BC%9A" rel="nofollow">使用锁同步对共享资源的访问：</a></p> 
 <p id="%E4%BB%A3%E7%A0%81%E6%94%B9%E8%BF%9B%E6%8F%90%E7%A4%BA%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E4%BB%A3%E7%A0%81%E6%94%B9%E8%BF%9B%E6%8F%90%E7%A4%BA%EF%BC%9A" rel="nofollow">代码改进提示：</a></p> 
 <p id="%E7%BD%91%E4%B8%8A%E5%AD%A6%E4%B9%A0%E7%BD%91%E5%9D%80%E8%B4%B4%E5%87%BA%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E7%BD%91%E4%B8%8A%E5%AD%A6%E4%B9%A0%E7%BD%91%E5%9D%80%E8%B4%B4%E5%87%BA%EF%BC%9A" rel="nofollow">网上学习网址贴出：</a></p> 
 <hr id="hr-toc"> 
</blockquote> 
<h2></h2> 
<h2 id="%E5%BB%BA%E7%AB%8B%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9A"><span style="color:#1a439c;">建立简单的多线程：</span></h2> 
<blockquote> 
 <h3 id="%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AF%B9%E8%B1%A1%EF%BC%9A"><span style="color:#511b78;">创建一个新的线程对象：</span></h3> 
 <p><code>threading.Thread</code> 类用于创建一个新的线程对象。</p> 
 <p>这个类接受几个参数，其中最重要的是 <code>target</code> 和 <code>args</code></p> 
 <p><img alt="" height="110" src="https://images2.imgbox.com/10/98/E7zdDDA2_o.png" width="846"></p> 
 <p><span style="color:#1c7331;"><strong>target</strong></span></p> 
 <p><code>target</code> 参数是一个可调用的对象（如函数或方法），当线程启动时，这个对象会被线程执行。在这个例子中，<code>target</code> 被设置为 <code>counter</code> 函数，所以新创建的线程会执行 <code>counter</code> 函数。</p> 
 <p><span style="color:#1c7331;"><strong>args</strong></span></p> 
 <p><code>args</code> 参数是一个元组，用于给 <code>target</code> 函数传递参数。在这个例子中，<code>args</code> 是一个只包含一个元素的元组，即字符串 <code>"计数A"</code>。当 <code>t1</code> 线程启动并调用 <code>counter</code> 函数时，它会传递这个字符串作为参数。</p> 
 <p>需要注意的是，由于 <code>args</code> 需要是一个元组，所以即使只传递一个参数，也需要用逗号 <code>,</code> 来表明它是一个元组（在只有一个元素的元组后面加上逗号是一个常见的约定）。</p> 
 <p></p> 
</blockquote> 
<blockquote> 
 <h3 id="%C2%A0%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span style="color:#511b78;"> 代码示例：</span></h3> 
 <p>以下代码简单示例了如何编写一个简单的多线程程序：</p> 
 <pre><code class="language-python"># -*- coding: utf-8 -*-  
import time  
import threading  
  
def counter(name):  
    for i in range(5):  
        print(name, i)  
        time.sleep(1)  

t1 = threading.Thread(target=counter, args=("计数A",))  
t2 = threading.Thread(target=counter, args=("计数B",))  
  
t1.start()  
t2.start() 
  
print("主线程完成")</code></pre> 
</blockquote> 
<blockquote> 
 <h3 id="%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C%E4%B8%8E%E8%A7%A3%E9%87%8A%EF%BC%9A"><span style="color:#511b78;">测试效果与解释：</span></h3> 
 <p>我们发现这个程序中一共三条线程：t1、t2、主线程</p> 
 <p>主线程因为只有一句prtint，因此在t1、t2计数第一次后就结束了</p> 
 <p>同时：t1、t2俩个线程是一起运行的</p> 
 <p><img alt="" height="386" src="https://images2.imgbox.com/dd/73/0LfeJ9PH_o.png" width="1130"></p> 
</blockquote> 
<blockquote> 
 <h3 id="join%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A"><span style="color:#511b78;">join方法的使用：</span></h3> 
 <p><strong>如果想主线程等待其余线程执行完，则可以使用join方法：</strong></p> 
 <p><img alt="" height="491" src="https://images2.imgbox.com/23/14/ePDNjvA1_o.png" width="826"></p> 
 <p></p> 
 <p><strong>这样主线程就会在俩个子线程结束后才执行：</strong></p> 
 <p><img alt="" height="341" src="https://images2.imgbox.com/e2/81/xRv343ZC_o.png" width="791"></p> 
</blockquote> 
<p></p> 
<h2 id="%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E9%80%9A%E4%BF%A1%EF%BC%9A"><span style="color:#1a439c;">线程间的同步与通信：</span></h2> 
<blockquote> 
 <h3 id="%E9%97%AE%E9%A2%98%E4%BB%A3%E7%A0%81%E4%B8%8E%E8%AF%B4%E6%98%8E%EF%BC%9A"><span style="color:#be191c;">问题代码与说明：</span></h3> 
 <p>下面展示一段问题代码，该段代码有个全局变量N，程序试图通过多个线程对其进行加操作</p> 
 <p>从而达到快速加到某个值的效果：</p> 
 <pre><code class="language-python"># -*- coding: utf-8 -*-  
import time  
import threading  

# 定义一个全局变量，整数类型  
N=0

def Add(name):
    global N                  # 如果想在函数内部修改全局变量的值，需要使用global关键字  
    for i in range(10000):  
        N += 1                 # 使用 += 来递增全局变量

t1 = threading.Thread(target=Add, args=("累加1",))  
t2 = threading.Thread(target=Add, args=("累加2",))  
t3 = threading.Thread(target=Add, args=("累加3",))  
  
t1.start()  
t2.start() 
t3.start()   

t1.join() 
t2.join() 
t3.join()
 
print("主线程完成 N的最终值为:{}".format(N))</code></pre> 
 <p>虽然我们发现这个操作结果是预期的30000，并未出现更改全局变量 <code>N</code> 冲突的情况，主要是因为线程间对 <code>N</code> 的增加操作是原子的（atomic）。在Python中，对于整数类型（int）和不可变类型（如元组、字符串等），在CPython实现中，简单的赋值和算术操作通常是原子的。</p> 
 <p></p> 
 <p class="img-center"><img alt="" height="161" src="https://images2.imgbox.com/1b/04/6Te1Y2bm_o.png" width="686"></p> 
 <p></p> 
 <p>但是，请注意，这种情况并不意味着多线程环境下对全局变量的修改总是安全的。对于更复杂的操作或可变类型（如列表、字典等），多线程访问和修改可能会出现问题，例如数据竞争（data race）、死锁（deadlock）或条件竞争（condition race）。</p> 
</blockquote> 
<blockquote> 
 <h3 id="%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6%EF%BC%9A"><span style="color:#be191c;">竞态条件：</span></h3> 
 <p>在以下给出的网址中的视频内就展示了对全局变量的非原子操作导致的加减输出混乱的情况</p> 
 <p><a href="https://www.bilibili.com/video/BV1oQ4y1C73G/?spm_id_from=333.337.search-card.all.click&amp;vd_source=090e0b0724f6022d9ce8b14853097061" rel="nofollow" title="多线程编程：一次性搞懂线程同步机制_哔哩哔哩_bilibili">多线程编程：一次性搞懂线程同步机制_哔哩哔哩_bilibili</a></p> 
 <p></p> 
 <p></p> 
 <p class="img-center"><img alt="" height="356" src="https://images2.imgbox.com/82/8c/QtRV0yiA_o.png" width="654"></p> 
 <p></p> 
 <p>我们发现他的多线程程序并未累加全局变量到预期的值10万，而是运行出了六次不同的结果</p> 
 <p></p> 
 <p class="img-center"><img alt="" height="606" src="https://images2.imgbox.com/ab/3a/l3zrrZXW_o.png" width="1200"></p> 
</blockquote> 
<h3 id="%E4%BD%BF%E7%94%A8%E9%94%81%E5%90%8C%E6%AD%A5%E5%AF%B9%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE%EF%BC%9A"><span style="color:#1c7892;">使用锁同步对共享资源的访问：</span></h3> 
<blockquote> 
 <p><code>threading.Lock</code></p> 
 <p><code>Lock</code> 对象提供了一种方法来同步线程，以确保在任何时候只有一个线程可以访问共享资源。</p> 
 <p>下面是修改后的代码，其中添加了 <code>Lock</code> 来保护对全局变量 <code>N</code> 的访问：</p> 
 <pre><code class="language-python"># -*- coding: utf-8 -*-    
import time    
import threading    
  
# 定义一个全局变量，整数类型  
N = 0  
# 定义一个全局锁  
lock = threading.Lock()  
  
def Add(name):  
    global N, lock  
    for i in range(10000):  
        # 在修改N之前先获取锁  
        with lock:  
            N += 1                 # 使用 += 来递增全局变量  
  
t1 = threading.Thread(target=Add, args=("累加1",))    
t2 = threading.Thread(target=Add, args=("累加2",))    
t3 = threading.Thread(target=Add, args=("累加3",))    
    
t1.start()    
t2.start()   
t3.start()     
  
t1.join()   
t2.join()   
t3.join()  
   
print("主线程完成 N的最终值为:{}".format(N))</code></pre> 
 <p>添加了一个名为 <code>lock</code> 的 <code>threading.Lock</code> 对象。</p> 
 <p></p> 
 <p>在 <code>Add</code> 函数中，我使用 <code>with lock:</code> 语句块来确保在修改 <code>N</code> 时锁是获取的。</p> 
 <p>这个 <code>with</code> 语句块会在进入时自动调用 <code>lock.acquire()</code> 来获取锁，并在退出时自动调用 <code>lock.release()</code> 来释放锁。</p> 
 <p>这样，在任何时候只有一个线程可以执行 <code>N += 1</code> 这行代码。</p> 
 <p></p> 
 <p>现在，即使你运行多个线程来同时修改 <code>N</code>，也不会出现数据不一致的问题，因为每个线程在修改 <code>N</code> 之前都会先获取锁，确保其他线程在此期间不会修改 <code>N</code>。</p> 
 <p></p> 
 <p><strong><span style="color:#be191c;">运行效果展示：</span></strong></p> 
 <p></p> 
 <p class="img-center"><img alt="" height="110" src="https://images2.imgbox.com/8b/ea/QYfP1FYv_o.png" width="639"></p> 
</blockquote> 
<p></p> 
<blockquote> 
 <h3 id="%E4%BB%A3%E7%A0%81%E6%94%B9%E8%BF%9B%E6%8F%90%E7%A4%BA%EF%BC%9A"><span style="color:#b95514;">代码改进提示：</span></h3> 
 <p>但频繁地上锁解锁十分浪费资源，可以先定义一个局部变量代为运算，最后赋值给全局：</p> 
 <p>这样我们<span style="color:#b95514;"><strong>只需一次上锁与释放的操作</strong></span>就可以做到目标结果：</p> 
 <p></p> 
 <p><span style="color:#1c7331;"><strong>修改前繁琐的部分：</strong></span></p> 
 <p><span style="color:#0d0016;">会进行高达10000次的：获取锁、释放锁的操作</span></p> 
 <p></p> 
 <p class="img-center"><img alt="" height="136" src="https://images2.imgbox.com/43/23/QSHQlG5R_o.png" width="732"></p> 
 <p></p> 
 <p><span style="color:#1c7331;"><strong>修改的部分：</strong></span></p> 
 <p><span style="color:#0d0016;"><strong>只进行了一次获取、释放锁的操作</strong></span></p> 
 <p></p> 
 <p class="img-center"><img alt="" height="272" src="https://images2.imgbox.com/68/07/GHnf1WWo_o.png" width="737"></p> 
 <p></p> 
 <p><span style="color:#1c7331;"><strong>整体代码：</strong></span></p> 
 <pre><code class="language-python"># -*- coding: utf-8 -*-    
import time    
import threading    
  
# 定义一个全局变量，整数类型  
N = 0  
# 定义一个全局锁  
lock = threading.Lock()  
  
def Add(name):  
    global N, lock
    n=0
    for i in range(10000):  
        n+=1
    # 在修改N之前先获取锁  
    with lock:  
        N += n                 # 使用 += 来递增全局变量  
  
t1 = threading.Thread(target=Add, args=("累加1",))    
t2 = threading.Thread(target=Add, args=("累加2",))    
t3 = threading.Thread(target=Add, args=("累加3",))    
    
t1.start()
t2.start()
t3.start()
  
t1.join()
t2.join()
t3.join()  
   
print("主线程完成 N的最终值为:{}".format(N))</code></pre> 
 <p><span style="color:#1c7331;"><strong>运行结果：</strong></span></p> 
 <p></p> 
 <p class="img-center"><img alt="" height="127" src="https://images2.imgbox.com/7a/58/HqgLQOhP_o.png" width="744"></p> 
</blockquote> 
<p></p> 
<p class="img-center"><img alt="" height="749" src="https://images2.imgbox.com/a6/11/zx3KStJC_o.png" width="1200"></p> 
<p></p> 
<h2 id="%E7%BD%91%E4%B8%8A%E5%AD%A6%E4%B9%A0%E7%BD%91%E5%9D%80%E8%B4%B4%E5%87%BA%EF%BC%9A"><span style="color:#1a439c;">网上学习网址贴出：</span></h2> 
<blockquote> 
 <p><a href="https://www.bilibili.com/video/BV1Pm4y1J7b8/?spm_id_from=333.337.search-card.all.click" rel="nofollow" title="100秒学会Python多线程threading_哔哩哔哩_bilibili">100秒学会Python多线程threading_哔哩哔哩_bilibili</a></p> 
</blockquote> 
<blockquote> 
 <p><a href="https://www.bilibili.com/video/BV1oQ4y1C73G/?spm_id_from=333.337.search-card.all.click&amp;vd_source=090e0b0724f6022d9ce8b14853097061" rel="nofollow" title="多线程编程：一次性搞懂线程同步机制_哔哩哔哩_bilibili">多线程编程：一次性搞懂线程同步机制_哔哩哔哩_bilibili</a></p> 
</blockquote> 
<blockquote> 
 <p></p> 
</blockquote> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/69420da790ef5e4bc334e840f6906a83/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">同步模式之保护性暂停模式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d662d25e51ca5c95caedfe27d2ecc04b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">我在高职教STM32——GPIO入门之按键输入（2）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>