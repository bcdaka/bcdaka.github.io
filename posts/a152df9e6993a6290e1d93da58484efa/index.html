<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python requests最全使用指南 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/a152df9e6993a6290e1d93da58484efa/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="python requests最全使用指南">
  <meta property="og:description" content="文章目录 前言安装 ReuqestsHTTP 简介什么是 HTTPHTTP工作原理HTTP的9种请求方法HTTP状态码 requests 快速上手requests 发起请求的步骤requests 发起请求的两种方式请求参数发起 GET 请求发起 POST 请求 requests 实战登录接口的测试获取用户信息接口的测试对响应结果的处理（序列化和反序列化）关于Python技术储备一、Python所有方向的学习路线二、Python基础学习视频三、精品Python学习书籍四、Python工具包&#43;项目源码合集①Python工具包②Python实战案例③Python小游戏源码五、面试资料六、Python兼职渠道 前言 Requests 是一个 Python 的一个第三方库，通过发送 HTTP 请求获取响应数据，一般应用于编写网络爬虫和接口测试等。
相比 urllib 库，它语法简单，更容易上手。
官方中文文档地址：Requests: 让 HTTP 服务人类
离线文档下载地址：Requests document download
安装 Reuqests pip install requests HTTP 简介 在使用 requests 模拟发送网络请求之前，先来简单学习一下HTTP和常见的请求方式。
什么是 HTTP HTTP（HyperText Transfer Protocol ，超文本传输协议）是一个简单的请求/响应协议。即一个客户端与服务器建立连接后，向服务器发送一个请求;服务器接到请求后，给予相应的响应信息。
HTTP工作原理 1.客户端与服务器端建立连接
2.客户端向服务器端发起请求
3.服务器接受请求，并根据请求返回相应的内容
4.客服端与服务器端连接关闭
客户端和服务器端之间的HTTP连接是一种一次性连接，它限制每次连接只处理一个请求，当服务器返回本次请求的应答后便立即关闭，下次请求再重新建立连接。这样做的好处就是让服务器不会处于一个一直等待的状态，及时释放连接可极大提高服务器的执行效率。
HTTP是一种无状态协议，意思就是服务器不保留与客户端连接时的任何状态。这减轻了服务器的记忆负担，从而保持较快的响应速度。
HTTP的9种请求方法 每种请求方式规定了客户端和服务器端之间不同的信息交换方式。
请求方法描述GET请求指定的页面信息，并返回实体主体。POST向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立或已有资源的修改。HEAD类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头PUT从客户端向服务器传送数据取代指定的文档的内容。PATCH是对 PUT 方法的补充，用来对已知资源进行局部更新DELETE请求服务器删除指定的页面OPTIONS允许客户端查看服务器的性能TRACE回显服务器收到的请求，主要用于测试或诊断CONNECTHTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器 请求方法GET和POST的区别：
GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码 HTTP状态码 状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:
分类分类描述1**指示信息–服务器收到请求，需要请求者继续执行操作2**成功–操作被成功接收并处理3**重定向–需要进一步的操作以完成请求4**客户端错误–请求包含语法错误或无法完成请求5**服务器错误–服务器在处理请求的过程中发生了错误 常见的状态码：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-01-08T17:19:00+08:00">
    <meta property="article:modified_time" content="2024-01-08T17:19:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python requests最全使用指南</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#_7" rel="nofollow">前言</a></li><li><a href="#_Reuqests_19" rel="nofollow">安装 Reuqests</a></li><li><a href="#HTTP__27" rel="nofollow">HTTP 简介</a></li><li><ul><li><a href="#_HTTP_32" rel="nofollow">什么是 HTTP</a></li><li><a href="#HTTP_36" rel="nofollow">HTTP工作原理</a></li><li><a href="#HTTP9_50" rel="nofollow">HTTP的9种请求方法</a></li><li><a href="#HTTP_73" rel="nofollow">HTTP状态码</a></li></ul> 
   </li><li><a href="#requests__101" rel="nofollow">requests 快速上手</a></li><li><ul><li><a href="#requests__104" rel="nofollow">requests 发起请求的步骤</a></li><li><a href="#requests__109" rel="nofollow">requests 发起请求的两种方式</a></li><li><a href="#_139" rel="nofollow">请求参数</a></li><li><a href="#_GET__157" rel="nofollow">发起 GET 请求</a></li><li><a href="#_POST__275" rel="nofollow">发起 POST 请求</a></li></ul> 
   </li><li><a href="#requests__509" rel="nofollow">requests 实战</a></li><li><ul><li><a href="#_512" rel="nofollow">登录接口的测试</a></li><li><a href="#_553" rel="nofollow">获取用户信息接口的测试</a></li><li><a href="#_583" rel="nofollow">对响应结果的处理（序列化和反序列化）</a></li><li><a href="#Python_663" rel="nofollow">关于Python技术储备</a></li><li><ul><li><a href="#Python_671" rel="nofollow">一、Python所有方向的学习路线</a></li><li><a href="#Python_675" rel="nofollow">二、Python基础学习视频</a></li><li><a href="#Python_687" rel="nofollow">三、精品Python学习书籍</a></li><li><a href="#Python_692" rel="nofollow">四、Python工具包+项目源码合集</a></li><li><a href="#Python_693" rel="nofollow">①Python工具包</a></li><li><a href="#Python_698" rel="nofollow">②Python实战案例</a></li><li><a href="#Python_703" rel="nofollow">③Python小游戏源码</a></li><li><a href="#_707" rel="nofollow">五、面试资料</a></li><li><a href="#Python_712" rel="nofollow">六、Python兼职渠道</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<p><img src="https://images2.imgbox.com/bf/a0/00wq5dmq_o.gif" alt="在这里插入图片描述"></p> 
<h3><a id="_7"></a>前言</h3> 
<p>Requests 是一个 Python 的一个第三方库，通过发送 HTTP 请求获取响应数据，一般应用于编写网络爬虫和接口测试等。</p> 
<p>相比 urllib 库，它语法简单，更容易上手。</p> 
<p>官方中文文档地址：<a href="https://cn.python-requests.org/zh_CN/latest/" rel="nofollow">Requests: 让 HTTP 服务人类</a></p> 
<p>离线文档下载地址：<a href="https://github.com/lyx2099/RequestsDoc">Requests document download</a></p> 
<hr> 
<h3><a id="_Reuqests_19"></a>安装 Reuqests</h3> 
<pre><code>pip install requests

</code></pre> 
<h3><a id="HTTP__27"></a>HTTP 简介</h3> 
<p>在使用 requests 模拟发送网络请求之前，先来简单学习一下HTTP和常见的请求方式。</p> 
<h4><a id="_HTTP_32"></a>什么是 HTTP</h4> 
<p>HTTP（HyperText Transfer Protocol ，超文本传输协议）是一个简单的请求/响应协议。即一个客户端与服务器建立连接后，向服务器发送一个请求;服务器接到请求后，给予相应的响应信息。</p> 
<h4><a id="HTTP_36"></a>HTTP工作原理</h4> 
<blockquote> 
 <p>1.客户端与服务器端建立连接</p> 
 <p>2.客户端向服务器端发起请求</p> 
 <p>3.服务器接受请求，并根据请求返回相应的内容</p> 
 <p>4.客服端与服务器端连接关闭</p> 
</blockquote> 
<p>客户端和服务器端之间的HTTP连接是一种一次性连接，它限制每次连接只处理一个请求，当服务器返回本次请求的应答后便立即关闭，下次请求再重新建立连接。这样做的好处就是让服务器不会处于一个一直等待的状态，及时释放连接可极大提高服务器的执行效率。</p> 
<p>HTTP是一种无状态协议，意思就是服务器不保留与客户端连接时的任何状态。这减轻了服务器的记忆负担，从而保持较快的响应速度。</p> 
<h4><a id="HTTP9_50"></a>HTTP的9种请求方法</h4> 
<p>每种请求方式规定了客户端和服务器端之间不同的信息交换方式。</p> 
<table><thead><tr><th>请求方法</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>请求指定的页面信息，并返回实体主体。</td></tr><tr><td>POST</td><td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立或已有资源的修改。</td></tr><tr><td>HEAD</td><td>类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td>PUT</td><td>从客户端向服务器传送数据取代指定的文档的内容。</td></tr><tr><td>PATCH</td><td>是对 PUT 方法的补充，用来对已知资源进行局部更新</td></tr><tr><td>DELETE</td><td>请求服务器删除指定的页面</td></tr><tr><td>OPTIONS</td><td>允许客户端查看服务器的性能</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断</td></tr><tr><td>CONNECT</td><td>HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器</td></tr></tbody></table> 
<p>请求方法GET和POST的区别：</p> 
<blockquote> 
 <ul><li>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中</li><li>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制</li><li>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</li><li>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码</li></ul> 
</blockquote> 
<h4><a id="HTTP_73"></a>HTTP状态码</h4> 
<p>状态代码有<strong>三位数字</strong>组成，第一个数字定义了响应的类别，共分五种类别:</p> 
<table><thead><tr><th>分类</th><th>分类描述</th></tr></thead><tbody><tr><td>1**</td><td>指示信息–服务器收到请求，需要请求者继续执行操作</td></tr><tr><td>2**</td><td>成功–操作被成功接收并处理</td></tr><tr><td>3**</td><td>重定向–需要进一步的操作以完成请求</td></tr><tr><td>4**</td><td>客户端错误–请求包含语法错误或无法完成请求</td></tr><tr><td>5**</td><td>服务器错误–服务器在处理请求的过程中发生了错误</td></tr></tbody></table> 
<p>常见的状态码：</p> 
<table><thead><tr><th>状态码</th><th>含义</th></tr></thead><tbody><tr><td>200 OK</td><td>客户端请求成功</td></tr><tr><td>400 Bad Request</td><td>客户端请求有语法错误，不能被服务器理解</td></tr><tr><td>401 Unauthorized</td><td>请求未经授权，这个状态码必须和 WWW-Authenticate 报头域一起使用</td></tr><tr><td>403 Forbidden</td><td>服务器收到请求，但是拒绝服务</td></tr><tr><td>404 Not Found</td><td>请求资源不存在，eg：输入了错误的URL</td></tr><tr><td>500 Internal Server Error</td><td>服务器发生不可预期的错误</td></tr><tr><td>503 Server Unavailable</td><td>服务器当掐你不能处理客户端的请求，一段时间后可能恢复</td></tr></tbody></table> 
<hr> 
<h3><a id="requests__101"></a>requests 快速上手</h3> 
<h4><a id="requests__104"></a>requests 发起请求的步骤</h4> 
<p>使用 requests 的流程大致可以分为以下三步：</p> 
<p>填写method url params等参数➡发起请求➡查看响应结果</p> 
<h4><a id="requests__109"></a>requests 发起请求的两种方式</h4> 
<p>使用 requests 发起请求有两种方式，以发起post请求为例：</p> 
<pre><code>import requests

# 方式一：
r = requests.request("post","https://www.baidu.com")
print(r.text)

# 方式二：
r = requests.post("https://www.baidu.com")
print(r.text)

</code></pre> 
<p><code>requests.request(method, url, ...)</code>的 request 是 requests 封装好根据 method 传参的不同而调用对应的请求方法。method 参数的值可以是 get/post/put/delete/head/patch/options 等，对应我们上一节的 HTTP 请求方法。上面的示例代码中方式一和方式二达到的效果都是一样的，但是推荐使用方式一，因为在后面的接口自动化测试中便于参数化，如下：</p> 
<pre><code>import requests

method = "get"
url = "https://www.baidu.com"

r = requests.request(method=method, url=url)
print(r.text)

</code></pre> 
<h4><a id="_139"></a>请求参数</h4> 
<p>requests 发起请求时，支持传递的参数列表：</p> 
<ul><li>method：请求的类型，格式为字符串。值可以是 get\post\put\delete\files\head\patch\options</li><li>url：请求的接口地址，格式为字符串。此参数必传</li><li>params： get类型的接口请求的数据，格式为字典</li><li>data：form-data 一般用于 post 类型的接口请求的数据，格式为字典/json/字符串</li><li>json： json格式的参数，格式为字典</li><li>headers：请求头，格式为字典</li><li>cookies：格式为字典</li><li>files：上传文件，格式为字典</li><li>timeout：请求超时时间，float</li><li>allow_redirects：是否支持重定向，格式为boolean</li><li>verify：是否忽略http协议的证书错误，boolean：True 不忽略</li></ul> 
<p>在接下来的案例我们会逐一对上面的参数进行详细讲些。</p> 
<h4><a id="_GET__157"></a>发起 GET 请求</h4> 
<p>使用 Requests 模拟发送 GET 请求，以请求百度首页为例：</p> 
<pre><code># 导入requests库
import requests

# 要请求的地址
url = "http://www.baidu.com"

# 发起 GET 请求，并将响应结果存储在 res 中，res是一个 responses 对象
res = requests.get(url)	

print(res.request.headers)		# 查看请求头信息
print(res.request.body)			# 查看请求正文
print(res.request.url)			# 查看请求url
print(res.request.method)		# 查看请求方法

print(res.content)		# 响应结果的字节码格式，一般用于图片，视频数据等
print(res.encoding)		# 查看响应正文的编码格式
print(res.text)			# 响应结果的字符串格式，非字节码
print(res.status_code)	# 响应结果状态码，200 表示成功
print(r.reason)			# 响应状态码的描述信息，如 OK，NotFound 等
print(res.cookies)		# 获取 cookies
print(res.headers)		# 查看响应的响应头
print(res.url)			# 查看响应的url

</code></pre> 
<p>如果响应内容中文显示是乱码，在此提供2种解决方案：</p> 
<pre><code>import requests

url = "http://www.baidu.com"
res = requests.get(url)

# 方案1：
res.encoding="utf-8"	# 如果 res.text 中有中文乱码，修改编码格式为 "utf-8"
print(res.text)

# 方案2：
res.content.decode("utf-8")		# 将响应结果的字节码格式转换为 "utf-8" 格式
print(res.text)

</code></pre> 
<p><strong>1）发起携带参数的 GET 请求</strong></p> 
<p>来看一下 Request 中 get 方法的定义：</p> 
<pre><code>def get(url, params=None, **kwargs):
    return request("get", url, params=params, **kwargs)

</code></pre> 
<p>这意味着发起 GET 请求时，允许我们使用 params 关键字参数，参数的类型为字典（dict）。接下来看一个案例：</p> 
<p>慕课网（<a href="https://www.imooc.com/" rel="nofollow">https://www.imooc.com/</a>）首页搜索 “python”，按 F12 --&gt; 点击 NetWork 抓包获取其接口。</p> 
<p>我们得到的接口部分信息如下：</p> 
<pre><code>请求方式：get
请求url：https://www.imooc.com/search/coursesearchconditions?words=python

</code></pre> 
<p><code>?words=python</code>问号后面的 <code>word=python</code> 就是我们在发起 get 请求时的要提供的参数，接下来使用 requests 来发起请求：</p> 
<pre><code>import requests

# 慕课网首页课程查询接口
url = "https://www.imooc.com/search/coursesearchconditions"

# 查询时携带的参数
payload = {
    'words': 'python'
}

res = requests.get(url, params=payload)	# 发起携带参数的 get 请求
print(res.json())	# 响应内容是 json 格式的字符串，我们使用 res.json() 方法进行解码

</code></pre> 
<p><strong>2）定制请求头</strong></p> 
<blockquote> 
 <p>如果你想为请求添加 HTTP 头部，只需要传递一个字典（dict）给 headers 参数即可。例如，我们发起请求时要传递一个 UA（User-Agent）。User-Agent 中文名为用户代理，是Http协议中的一部分。它可以向访问网站提供你所使用的浏览器类型及版本、操作系统及版本、浏览器内核、等信息的标识。通过这个标 识，用户所访问的网站可以显示不同的排版从而为用户提供更好的体验或者进行信息统计。</p> 
</blockquote> 
<p><strong>为什么要添加 UA？</strong></p> 
<p>在使用 Python 的 Requests 模拟浏览器向服务器发送 Http 请求时，于某些网站会设置对 User-Agent 反爬虫机制，因此我们发送 Http 请求时有必要的加上 <code>User-Agent</code> 来将爬虫程序的UA伪装成某一款浏览器的身份标识。</p> 
<pre><code>import requests

url = "https://www.imooc.com/search/coursesearchconditions"

headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36'}

# 查询时携带的参数
payload = {
    'words': 'python'
}

res = requests.get(url, params=payload, headers=headers)
print(res.json())	# 响应内容是 json 格式的字符串，我们使用 res.json() 方法进行解码
print(res.request.headers)  # 查看请求头

</code></pre> 
<h4><a id="_POST__275"></a>发起 POST 请求</h4> 
<p><strong>1）传递 data 参数</strong></p> 
<p>当我们要向网页上的一些表单（form）传递数据时，经常需要发起 post 请求。使用 requests 发起 post 请求的方法也非常简单，只需要传递一个字典给 data 参数。</p> 
<pre><code>import requests

url = 'http://httpbin.org/post'
payload = {'name': 'joy', 'phone': '400-7865-6666'}

r = requests.post(url=url, data=payload)
print(r.text)

</code></pre> 
<p>运行结果：</p> 
<pre><code>{
  ...
  "form": {
    "key2": "value2",
    "key1": "value1"
  },
  ...
}

</code></pre> 
<p>还可以为 data 参数传入一个元组列表。例如表单中多个元素使用同一个 key 时，可以像下面这样做：</p> 
<pre><code>import requests

url = 'http://httpbin.org/post'
payload = (('course', 'Python'), ('course', 'Java'))

r = requests.post(url=url, data=payload)
print(r.text)

</code></pre> 
<p>响应结果：</p> 
<pre><code>{
  ...
  "form": {
    "course": [
      "Python",
      "Java"
    ]
  },
  ...
}

</code></pre> 
<p>当你想用 data 参数去接收 json 格式的数据，那么需要把请求的数据转换成 json 格式，并且要将请求头设置为 <code>application/json</code>。</p> 
<pre><code>import requests, json

url = 'https://api.github.com/some/endpoint'
data = json.dumps({
    "some": "data"
})
headers = {"Content-Type":"application/json"}

r = requests.post(url, data=data, headers=headers)
print(r.text)

</code></pre> 
<p><strong>2） 传递json参数</strong></p> 
<p>可以使用 <code>json</code> 参数直接传递，然后它就会被自动编码</p> 
<pre><code>import requests, json

url = "http://119.45.233.102:6677/testgoup/test/json"
data = {
    'name': 'jay',
    'age': 23
}
r = requests.post(url,json=data)
print(r.text)

</code></pre> 
<p>这里科普一下 json 和 dict（字典）的区别：</p> 
<blockquote> 
 <p>（1）字典是一种数据结构，是python中的一种数据类型；它是一种可变类型，可以存储任意类型的数值，以 key：value 的形式存储数据，但是 key 可以是任意可<a href="https://so.csdn.net/so/search?q=hash&amp;spm=1001.2101.3001.7020">hash</a>的对象 ，在一个字典中<strong>不允许出现两个相同的key值</strong>，如果出现，后面一个key值会覆盖前面的key值。</p> 
 <p>（2）Json是一种打包的数据格式，本质上是字符串，也是按照 key：value 来存储数据，key 只能时字符串，且可以有序、重复；必须使用双引号作为key或者值的边界符，不能使用单引号，使用单引号或者不使用引号会使解析错误。可以被解析为字典或者其他形式。</p> 
 <p>（3）<strong>json.loads函数的使用，将字符串转化为字典</strong></p> 
 <pre><code>import json

a = {'a': '1',
     'b': '2',
     'c': '3'
     }
print(type(a))  # 输出 &lt;class 'dict'&gt;

b = json.loads('{"age": "12"}')  # 参数是str行，loads之后，变成dict字典了
print(b)    # 输出 {'age': '12'}
print(type(b))  # 输出 &lt;class 'dict'&gt;

</code></pre> 
 <p>（4）<strong>json.dumps()函数的使用，将字典转化为字符串</strong></p> 
 <pre><code>import json
 
# json.dumps()函数的使用，将字典转化为字符串
dict1 = {"age": "12"}
json_info = json.dumps(dict1)
print("dict1的类型："+str(type(dict1)))
print("通过json.dumps()函数处理：")
print("json_info的类型："+str(type(json_info)))

</code></pre> 
</blockquote> 
<p><strong>3）传递 from-data 参数：</strong><br> 注意，requests默认是不支持from-data的请求数据的格式的。所以我们要传from-data格式，我们需要安装一个requests的插件：</p> 
<pre><code>pip install requests_toolbelt -i https://pypi.douban.com/simple

</code></pre> 
<pre><code>import requests
from requests_toolbelt.multipart.encoder import MultipartEncoder

method = "post"
url = "http://119.45.233.102:6677/testgoup/test/data"
data = MultipartEncoder({
    "name":"张三",
    "age":"23"
})
headers = {"Content-Type":data.content_type}
r = requests.request(method,url,data=data,headers=headers)
print(r.text)

</code></pre> 
<p><strong>4）传递 auth 参数</strong></p> 
<p>auth是一种对接口进行鉴权的方式，和cookies和token的作用差不多的。格式：元组，比如:(“账号”,“密码”)</p> 
<pre><code>import requests
url = "http://119.45.233.102:6677/testgoup/test/auth"
method  = "post"
auth = ("admin","123456")
r = requests.request(method,url,auth=auth)
print(r.text)

</code></pre> 
<p><strong>5）传递 timeout 参数</strong></p> 
<p>timeout用于控制响应的时间，如果超过了timeout规定的时间，那么会直接抛出连接失败的错误信息。timeout格式是整数，单位是秒。</p> 
<pre><code>import requests

method = "post"
url = "http://119.45.233.102:6677/testgoup/test/json"
data = {
    "name":"张三",
    "age":23
}
r = requests.request(method,url,json=data,timeout=10)
print(r.text)

</code></pre> 
<p><strong>6）传递 allow_redirects 参数</strong></p> 
<p>是否允许接口重定向。格式：布尔值</p> 
<p><strong>7）传递 proxies 参数</strong></p> 
<p>在编写爬虫程序时，同一个IP频繁对网站进行访问，可能会被封IP，为了避免这种情况我们就需要用到 proxies 参数来设置代理。proxies 参数可以将代理地址替换为你的IP地址，隐藏自身IP。<br> proxies 参数类型</p> 
<pre><code>proxies = { '协议':'协议://IP:端口号' }
proxies = {
    'http':'http://IP:端口号',
    'https':'https://IP:端口号',
}

</code></pre> 
<p>可以去网上搜索免费的代理IP网站中查找免费代理IP（注意：如果获取到的免费IP地址无效就会报错）：</p> 
<pre><code># 使用免费普通代理IP访问测试网站: http://httpbin.org/get
import requests

url = 'http://httpbin.org/get'
headers = {'User-Agent':'Mozilla/5.0'}
# 定义代理,在代理IP网站中查找免费代理IP
proxies = {
    'http':'http://182.116.239.37:9999',
    'https':'https://182.116.239.37:9999'
}
html = requests.get(url,proxies=proxies,headers=headers,timeout=5).text
print(html)

</code></pre> 
<p>这里推荐几个免费代理网站，可自行尝试：</p> 
<ul><li><a href="http://www.66ip.cn/" rel="nofollow">http://www.66ip.cn/</a></li><li><a href="https://www.kuaidaili.com/free/inha" rel="nofollow">https://www.kuaidaili.com/free/inha</a></li></ul> 
<p><strong>8）传递 verify 参数</strong><br> 当我们请求https协议的接口的时候，如果它的证书过期了，我们就可以使用这个参数verify，设置为Fasle不检查证书，忽略证书的问题，继续请求。</p> 
<h3><a id="requests__509"></a>requests 实战</h3> 
<h4><a id="_512"></a>登录接口的测试</h4> 
<p>TGU登录接口测试，登录接口信息如下：</p> 
<pre><code>地址：http://119.45.233.102:2244/testgoup/login
类型：post
请求头：application/json
请求参数：{
  "phone": "133********",
  "password": "e10adc3949ba59abbe56e057f20f883e",
  "type": 1
}
返回值：{
  "code": 1, 
  "data": {
    "nickName": "liuyanzu666", 
    "token": "eyJ..."
  }, 
  "message": "登录成功！"
}

</code></pre> 
<p>使用requests测试登录接口：</p> 
<pre><code>import requests

loginUrl = 'http://119.45.233.102:2244/testgoup/login'
method='post'
data = {
  "phone": "133********",
  "password": "e10adc3949ba59abbe56e057f20f883e",
  "type": 1
}
r = requests.request(method=method, url=loginUrl, json=data)
print(r.text)

</code></pre> 
<h4><a id="_553"></a>获取用户信息接口的测试</h4> 
<p>由于需要登录后才能获取到用户信息，在获取用户信息时需要传入登录后返回的token。完整代码如下：</p> 
<pre><code>import requests

loginUrl = 'http://119.45.233.102:2244/testgoup/login'
method='post'
data = {
  "phone": "133********",
  "password": "e10adc3949ba59abbe56e057f20f883e",
  "type": 1
}

#登录接口
r = requests.request(method=method, url=loginUrl, json=data)
# print(r.text)
token = r.json()['data']['token']

# 获取用户信息接口
userinfoUrl = 'http://119.45.233.102:2244/testgoup/user/getUserInfo'
headers = {'token': token}
r = requests.request(method='get', url=userinfoUrl, headers=headers)
print(r.text)

</code></pre> 
<blockquote> 
 <p>上述实战代码均在 <a href="http://119.45.233.102:2244/register" rel="nofollow">TestGoUp</a> 网站开展测试，并对账号进行了加密，可自行注册获取自己的账号进行测试。</p> 
</blockquote> 
<h4><a id="_583"></a>对响应结果的处理（序列化和反序列化）</h4> 
<p>上面代码中的 <code>token = r.json()['data']['token']</code> 里有一个细节这里要展开叙述一下。来看一下登录接口返回的响应结果，也就是 <code>print(r.text)</code> 的值：</p> 
<pre><code>{
  "code": 1, 
  "data": {
    "nickName": "liuyanzu666", 
    "token": "eyJhbGci..."		# token太长了，这里删掉部分数据
  }, 
  "message": "登录成功！"
}

</code></pre> 
<p>咋一看这是一个python字典类型的数据，有的同学可能说这是 json 类型的数据。到底是字典还是json类型的数据，我们使用 <code>type()</code> 方法对 <code>r.text</code> 进行判断即可。</p> 
<pre><code>print(type(r.text))		# 返回结果是 &lt;class 'str'&gt;

</code></pre> 
<p>返回结果居然是 str 类型的数据。现在我们要从 <code>r.text</code> 中获取 <code>token</code> 值，如果我们将它从 str 类型转换成字典类型，那么就可以通过 <code>token</code> 键获取对应的 <code>toekn</code> 值了。这里就引出了我们要讲的知识点：</p> 
<p><strong>Python序列化和反序列化</strong></p> 
<p>序列化：将Python中字典类型的数据转换成json格式的字符串，以便进行存储和传输。</p> 
<p>反序列化：将json格式的字符串转换成Python的字典类型数据，便于对其分析和处理。</p> 
<p>我们可以使用 json 模块来实现序列化和反序列化：</p> 
<pre><code>import json

# 字典类型的数据
data = {
  "name": "张三",
  "age": 18
}

# 使用 json.dumps() 进行序列化：字典--&gt;字符串
res = json.dumps(data)
print(res)  # 输出结果：{"name": "\u5f20\u4e09", "age": 18}
print(type(res))  # 输出结果：&lt;class 'str'&gt;

# 使用 json.loads() 进行反序列化：字符串--&gt;字典
res2 = json.loads(res)
print(res2)   # 输出结果：{'name': '张三', 'age': 18}
print(type(res2)) # 输出结果：&lt;class 'dict'&gt;

</code></pre> 
<p>上面阐述了使用 python 进行序列化和反序列化的方法，但是在登录接口中获取token值的时候 ，我们并没有使用 <code>json.loads()</code> 进行反序列化，而是使用 ``token = r.json()[‘data’][‘token’]<code>，也就是</code>r.json()` 方法。</p> 
<p>也就是说在上面的代码中，获取token我们可以使用两种方法：</p> 
<pre><code>...
r = requests.request(method=method, url=loginUrl, json=data)

方法一：
token = json.loads(r.text)['data']['token']

方法二：
token = r.json()['data']['token']

...	

</code></pre> 
<hr> 
<h4><a id="Python_663"></a>关于Python技术储备</h4> 
<p>学好 Python 不论是就业还是做副业赚钱都不错，但要学会 Python 还是要有一个学习规划。最后给大家分享一份全套的 Python 学习资料，希望提供给想学习 Python 的小伙伴们一点帮助！</p> 
<p><strong>保存图片微信扫描</strong>下方CSDN官方认证二维码免费领取【<code>保证100%免费</code>】</p> 
<center> 
 <img src="https://images2.imgbox.com/97/a3/GwXgaJfO_o.png"> 
 <center> 
 </center> 
</center> 
<h5><a id="Python_671"></a>一、Python所有方向的学习路线</h5> 
<p>Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。<br> <img src="https://images2.imgbox.com/de/93/jmmA7Zoa_o.jpg" alt="在这里插入图片描述"></p> 
<h5><a id="Python_675"></a>二、Python基础学习视频</h5> 
<p><strong>② 路线对应学习视频</strong></p> 
<p>还有很多适合0基础入门的学习视频，有了这些视频，轻轻松松上手Python~在这里插入图片描述<br> <img src="https://images2.imgbox.com/22/87/CqFWGboa_o.png" alt="在这里插入图片描述"></p> 
<p><strong>③练习题</strong></p> 
<p>每节视频课后，都有对应的练习题哦，可以检验学习成果哈哈！<br> <img src="https://images2.imgbox.com/b2/72/Ebl7VoW6_o.gif" alt="在这里插入图片描述"><br> <strong>因篇幅有限，仅展示部分资料</strong></p> 
<h5><a id="Python_687"></a>三、精品Python学习书籍</h5> 
<p>当我学到一定基础，有自己的理解能力的时候，会去阅读一些前辈整理的书籍或者手写的笔记资料，这些笔记详细记载了他们对一些技术点的理解，这些理解是比较独到，可以学到不一样的思路。<br> <img src="https://images2.imgbox.com/bc/15/FZRGA3is_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="Python_692"></a>四、Python工具包+项目源码合集</h5> 
<h5><a id="Python_693"></a>①Python工具包</h5> 
<p>学习Python常用的开发软件都在这里了！每个都有详细的安装教程，保证你可以安装成功哦！<br> <img src="https://images2.imgbox.com/4c/32/V3rkxRzN_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="Python_698"></a>②Python实战案例</h5> 
<p>光学理论是没用的，要学会跟着一起敲代码，动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。100+实战案例源码等你来拿！<br> <img src="https://images2.imgbox.com/fa/81/KwKaSiPA_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="Python_703"></a>③Python小游戏源码</h5> 
<p>如果觉得上面的实战案例有点枯燥，可以试试自己用Python编写小游戏，让你的学习过程中增添一点趣味！<br> <img src="https://images2.imgbox.com/53/78/yri6zYgP_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_707"></a>五、面试资料</h5> 
<p>我们学习Python必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。<br> <img src="https://images2.imgbox.com/ce/39/bBrzZafi_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/cb/3a/KP9uMefc_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="Python_712"></a>六、Python兼职渠道</h5> 
<p>而且学会Python以后，还可以在各大兼职平台接单赚钱，各种兼职渠道+兼职注意事项+如何和客户沟通，我都整理成文档了。<br> <img src="https://images2.imgbox.com/90/d8/Gtrco50U_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/2e/a7/s6afQNfw_o.gif" alt="在这里插入图片描述"><br> 这份完整版的Python全套学习资料已经上传CSDN，朋友们如果需要可以<strong>保存图片微信扫描</strong>下方CSDN官方认证二维码免费领取【<code>保证100%免费</code>】</p> 
<center> 
 <img src="https://images2.imgbox.com/6e/18/jOLUqGlr_o.png"> 
 <center> 
 </center> 
</center>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/faa335cbf3f56772f82cfe3ec6257e1e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言——结构体类型（一）【结构体定义，创建，初始化和引用】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/26c4799eb78a3f0f613f73df47b1b952/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C# 进行图像处理的几种方法（Bitmap,BitmapData,IntPtr）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>