<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>kafka 由浅入深 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/5be41ab4250970eabb6796442fa3959d/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="kafka 由浅入深">
  <meta property="og:description" content="目录
一、什么是kafka？
1.使用消息队列的好处？
2.典型应用：日志系统架构模型
二、架构
1.Kafka的一些重要相关概念
2.工作流程
3.副本原理
4.生产者
4.1.为什么分区可以水平扩展？
4.2.分区策略
1.轮询策略（Round-robin）
2.随机策略（Randomness）
3.按消息键保序策略（Key-ordering）
4.默认分区策略
5.消费者
5.1 消费方式
5.2 分区分配策略
5.2.1 Range（默认策略）
5.2.2 RoundRobin
6.数据可靠性保证
6.1 副本数据同步策略
6.2 ACK应答机制
参考
一、什么是kafka？ kafka本质上是一个消息队列MQ（Message Queue），用做数据流转。
1.使用消息队列的好处？ 1.1、解耦：允许独立扩展或修改队列两头的处理过程；
1.2、可恢复性：即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理；
1.3、缓冲：解决生产消息和消费消息速度不一致的问题； 1.4、灵活、峰值处理能力：不会因为突发的超负荷请求而完全崩溃，消息队列能使关键组件顶住突发的访问压力；
1.5、异步通信：允许用户将消息放入队列，但不立即处理它。
2.典型应用：日志系统架构模型 v1.日志系统架构模型| ProcessOn免费在线作图,在线流程图,在线思维导图
Logstash是一个开源数据收集引擎，具有实时管道功能。Logstash可以动态地将来自不同数据源的数据统一起来，并将数据标准化到你所选择的目的地。
Elasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎，能够解决不断涌现出的各种用例。作为 Elastic Stack 的核心，它集中存储您的数据，帮助您发现意料之中以及意料之外的情况。
二、架构 注意：因为篇幅原因，没有画zookeeper，broker都是由zookeeper管理。 Kafka 存储的消息来自任意多被称为 Producer 生产者的进程。数据从而可以被发布到不同的 Topic 主题下的不同 Partition 分区。
在一个分区内，这些消息被索引并连同时间戳存储在一起。其它被称为 Consumer 消费者的进程可以从分区订阅消息。
Kafka 运行在一个由一台或多台服务器组成的集群上，并且分区可以跨集群结点分布。
1.Kafka的一些重要相关概念 Producer：消息生产者，向 Kafka Broker 发消息的客户端。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-11T15:02:50+08:00">
    <meta property="article:modified_time" content="2024-08-11T15:02:50+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">kafka 由浅入深</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFkafka%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFkafka%EF%BC%9F" rel="nofollow">一、什么是kafka？</a></p> 
<p id="1.%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%A5%BD%E5%A4%84%EF%BC%9F-toc" style="margin-left:40px;"><a href="#1.%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%A5%BD%E5%A4%84%EF%BC%9F" rel="nofollow">1.使用消息队列的好处？</a></p> 
<p id="2.%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%EF%BC%9A%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B-toc" style="margin-left:40px;"><a href="#2.%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%EF%BC%9A%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B" rel="nofollow">2.典型应用：日志系统架构模型</a></p> 
<p id="%E4%BA%8C%E3%80%81%E6%9E%B6%E6%9E%84-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E6%9E%B6%E6%9E%84" rel="nofollow">二、架构</a></p> 
<p id="1.Kafka%E7%9A%84%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#1.Kafka%E7%9A%84%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5" rel="nofollow">1.Kafka的一些重要相关概念</a></p> 
<p id="2.%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-toc" style="margin-left:40px;"><a href="#2.%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B" rel="nofollow">2.工作流程</a></p> 
<p id="3.%E5%89%AF%E6%9C%AC%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#3.%E5%89%AF%E6%9C%AC%E5%8E%9F%E7%90%86" rel="nofollow">3.副本原理</a></p> 
<p id="4.%E7%94%9F%E4%BA%A7%E8%80%85-toc" style="margin-left:40px;"><a href="#4.%E7%94%9F%E4%BA%A7%E8%80%85" rel="nofollow">4.生产者</a></p> 
<p id="4.1.%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%86%E5%8C%BA%E5%8F%AF%E4%BB%A5%E6%B0%B4%E5%B9%B3%E6%89%A9%E5%B1%95%EF%BC%9F-toc" style="margin-left:80px;"><a href="#4.1.%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%86%E5%8C%BA%E5%8F%AF%E4%BB%A5%E6%B0%B4%E5%B9%B3%E6%89%A9%E5%B1%95%EF%BC%9F" rel="nofollow">4.1.为什么分区可以水平扩展？</a></p> 
<p id="4.2.%E5%88%86%E5%8C%BA%E7%AD%96%E7%95%A5-toc" style="margin-left:80px;"><a href="#4.2.%E5%88%86%E5%8C%BA%E7%AD%96%E7%95%A5" rel="nofollow">4.2.分区策略</a></p> 
<p id="1.%E8%BD%AE%E8%AF%A2%E7%AD%96%E7%95%A5%EF%BC%88Round-robin%EF%BC%89-toc" style="margin-left:120px;"><a href="#1.%E8%BD%AE%E8%AF%A2%E7%AD%96%E7%95%A5%EF%BC%88Round-robin%EF%BC%89" rel="nofollow">1.轮询策略（Round-robin）</a></p> 
<p id="2.%E9%9A%8F%E6%9C%BA%E7%AD%96%E7%95%A5%EF%BC%88Randomness%EF%BC%89-toc" style="margin-left:120px;"><a href="#2.%E9%9A%8F%E6%9C%BA%E7%AD%96%E7%95%A5%EF%BC%88Randomness%EF%BC%89" rel="nofollow">2.随机策略（Randomness）</a></p> 
<p id="3.%E6%8C%89%E6%B6%88%E6%81%AF%E9%94%AE%E4%BF%9D%E5%BA%8F%E7%AD%96%E7%95%A5%EF%BC%88Key-ordering%EF%BC%89-toc" style="margin-left:120px;"><a href="#3.%E6%8C%89%E6%B6%88%E6%81%AF%E9%94%AE%E4%BF%9D%E5%BA%8F%E7%AD%96%E7%95%A5%EF%BC%88Key-ordering%EF%BC%89" rel="nofollow">3.按消息键保序策略（Key-ordering）</a></p> 
<p id="4.%E9%BB%98%E8%AE%A4%E5%88%86%E5%8C%BA%E7%AD%96%E7%95%A5-toc" style="margin-left:120px;"><a href="#4.%E9%BB%98%E8%AE%A4%E5%88%86%E5%8C%BA%E7%AD%96%E7%95%A5" rel="nofollow">4.默认分区策略</a></p> 
<p id="5.%E6%B6%88%E8%B4%B9%E8%80%85-toc" style="margin-left:40px;"><a href="#5.%E6%B6%88%E8%B4%B9%E8%80%85" rel="nofollow">5.消费者</a></p> 
<p id="5.1%20%E6%B6%88%E8%B4%B9%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;"><a href="#5.1%20%E6%B6%88%E8%B4%B9%E6%96%B9%E5%BC%8F" rel="nofollow">5.1 消费方式</a></p> 
<p id="5.2%20%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5-toc" style="margin-left:80px;"><a href="#5.2%20%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5" rel="nofollow">5.2 分区分配策略</a></p> 
<p id="5.2.1%20Range%EF%BC%88%E9%BB%98%E8%AE%A4%E7%AD%96%E7%95%A5%EF%BC%89-toc" style="margin-left:120px;"><a href="#5.2.1%20Range%EF%BC%88%E9%BB%98%E8%AE%A4%E7%AD%96%E7%95%A5%EF%BC%89" rel="nofollow">5.2.1 Range（默认策略）</a></p> 
<p id="5.2.2%20RoundRobin-toc" style="margin-left:120px;"><a href="#5.2.2%20RoundRobin" rel="nofollow">5.2.2 RoundRobin</a></p> 
<p id="6.%E6%95%B0%E6%8D%AE%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BF%9D%E8%AF%81-toc" style="margin-left:40px;"><a href="#6.%E6%95%B0%E6%8D%AE%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BF%9D%E8%AF%81" rel="nofollow">6.数据可靠性保证</a></p> 
<p id="6.1%20%E5%89%AF%E6%9C%AC%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E7%AD%96%E7%95%A5-toc" style="margin-left:80px;"><a href="#6.1%20%E5%89%AF%E6%9C%AC%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E7%AD%96%E7%95%A5" rel="nofollow">6.1 副本数据同步策略</a></p> 
<p id="6.2%20ACK%E5%BA%94%E7%AD%94%E6%9C%BA%E5%88%B6-toc" style="margin-left:80px;"><a href="#6.2%20ACK%E5%BA%94%E7%AD%94%E6%9C%BA%E5%88%B6" rel="nofollow">6.2 ACK应答机制</a></p> 
<p id="%E5%8F%82%E8%80%83-toc" style="margin-left:0px;"><a href="#%E5%8F%82%E8%80%83" rel="nofollow">参考</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFkafka%EF%BC%9F">一、什么是kafka？</h2> 
<p>        kafka本质上是一个消息队列MQ（Message Queue），用做数据流转。</p> 
<h3 id="1.%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%A5%BD%E5%A4%84%EF%BC%9F">1.使用消息队列的好处？</h3> 
<p>    <strong>    1.1、解耦</strong>：允许独立扩展或修改队列两头的处理过程；</p> 
<p>     <strong>   1.2、可恢复性</strong>：即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理；</p> 
<p>  <strong>      1.3、缓冲</strong>：解决生产消息和消费消息速度不一致的问题；        </p> 
<p>        <strong>1.4、灵活、峰值处理能力</strong>：不会因为突发的超负荷请求而完全崩溃，消息队列能使关键组件顶住突发的访问压力；</p> 
<p>    <strong>    1.5、异步通信</strong>：允许用户将消息放入队列，但不立即处理它。</p> 
<h3 id="2.%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%EF%BC%9A%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B">2.典型应用：日志系统架构模型</h3> 
<p><a href="https://www.processon.com/view/link/60ed48030e3e74074e05f7f9" rel="nofollow" title="v1.日志系统架构模型| ProcessOn免费在线作图,在线流程图,在线思维导图">v1.日志系统架构模型| ProcessOn免费在线作图,在线流程图,在线思维导图</a></p> 
<h3 id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="1200" src="https://images2.imgbox.com/c9/da/sJQplovu_o.png" width="1200"></h3> 
<p><strong>        Logstash</strong>是一个开源数据收集引擎，具有实时管道功能。Logstash可以动态地将来自不同数据源的数据统一起来，并将数据标准化到你所选择的目的地。</p> 
<p><strong>        Elasticsearch </strong>是一个分布式、RESTful 风格的搜索和数据分析引擎，能够解决不断涌现出的各种用例。作为 Elastic Stack 的核心，它集中存储您的数据，帮助您发现意料之中以及意料之外的情况。</p> 
<h2 id="%E4%BA%8C%E3%80%81%E6%9E%B6%E6%9E%84">二、架构</h2> 
<h2><img alt="" height="1004" src="https://images2.imgbox.com/63/1c/BOlAF9Xz_o.png" width="1200"></h2> 
<p><strong>注意：因为篇幅原因，没有画zookeeper，broker都是由zookeeper管理。 </strong></p> 
<p>        Kafka 存储的消息来自任意多被称为 Producer 生产者的进程。数据从而可以被发布到不同的 Topic 主题下的不同 Partition 分区。<br>         在一个分区内，这些消息被索引并连同时间戳存储在一起。其它被称为 Consumer 消费者的进程可以从分区订阅消息。<br>         Kafka 运行在一个由一台或多台服务器组成的集群上，并且分区可以跨集群结点分布。</p> 
<h3 id="1.Kafka%E7%9A%84%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5">1.Kafka的一些重要相关概念</h3> 
<p><span style="color:#0d0016;"><strong>        Producer：</strong></span>消息生产者，向 Kafka Broker 发消息的客户端。</p> 
<p><strong>        Consumer：</strong>消息消费者，从 Kafka Broker 取消息的客户端。</p> 
<p><strong>        Consumer Group：</strong>消费者组（CG），消费者组内每个消费者负责消费不同分区的数据，提高消费能力。一个分区只能由组内一个消费者消费，消费者组之间互不影响。所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。</p> 
<p><strong>        Broker：</strong>一台 Kafka 机器就是一个 Broker。一个集群(kafka cluster)由多个 Broker 组成。一个Broker 可以容纳多个 Topic。</p> 
<p><strong>        Topic：</strong>可以理解为一个队列，Topic 将消息分类，生产者和消费者面向的是同一个 Topic。</p> 
<p><strong>        Partition：</strong>为了实现扩展性，提高并发能力，一个非常大的 Topic 可以分布到多个 Broker （即服务器）上，一个 Topic 可以分为多个 Partition，同一个topic在不同的分区的数据是不重复的，每个 Partition 是一个有序的队列，其表现形式就是一个一个的文件夹。</p> 
<p><strong>        Replication：</strong>每一个分区都有多个副本，副本的作用是做备胎。当主分区（Leader）故障的时候会选择一个备胎（Follower）上位，成为Leader。在kafka中默认副本的最大数量是10个，且副本的数量不能大于Broker的数量，follower和leader绝对是在不同的机器，同一机器对同一个分区也只可能存放一个副本（包括自己）。</p> 
<p><strong>        Message：</strong>消息，每一条发送的消息主体。</p> 
<p><strong>        Leader：</strong>每个分区多个副本的“主”副本，生产者发送数据的对象，以及消费者消费数据的对象，都是 Leader。</p> 
<p><strong>        Follower：</strong>每个分区多个副本的“从”副本，实时从 Leader 中同步数据，保持和 Leader 数据的同步。Leader 发生故障时，某个 Follower 还会成为新的 Leader。</p> 
<p><strong>        Offset：</strong>消费者消费的位置信息，监控数据消费到什么位置，当消费者挂掉再重新恢复的时候，可</p> 
<p>以从消费位置继续消费。</p> 
<p><strong>        ZooKeeper：</strong>Kafka 集群能够正常工作，需要依赖于 ZooKeeper，ZooKeeper 帮助 Kafka 存储和管理集群信息</p> 
<h3 id="2.%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">2.工作流程</h3> 
<p><img alt="" height="914" src="https://images2.imgbox.com/f4/7d/FnrbBVEL_o.png" width="1200"></p> 
<p><strong>不同的partition的offset是独立的。</strong></p> 
<p>        Kafka 中消息是以<strong> Topic 进行分类</strong>的，生产者生产消息，消费者消费消息，面向的都是同一个 Topic。</p> 
<p>        Topic 是逻辑上的概念，而 Partition 是物理上的概念，每个 Partition 对应于一个 log 文件，该 log 文件中存储的就是 Producer 生产的数据。</p> 
<p>        Producer 生产的数据会不断追加到该 log 文件末端，且每条数据都有自己的 Offset。</p> 
<p>        消费者组中的每个消费者，都会实时记录自己消费到了哪个 Offset，以便出错恢复时，从上次的位置继续消费。</p> 
<p><strong>日志默认在：/tmp/kafka-logs</strong></p> 
<h3 id="3.%E5%89%AF%E6%9C%AC%E5%8E%9F%E7%90%86"><strong>3.副本原理</strong></h3> 
<p><strong>        副本机制（Replication）</strong>，也可以称之为备份机制，通常是指分布式系统在多台网络互联的机器上保存有相同的数据拷贝。副本机制的好处在于：<br>         1.提供数据冗余。在一部分节点宕机的时候，系统仍能继续工作（即提高可用性）</p> 
<p>        2.提供高伸缩性。支持扩大机器数量，从而可以支撑更高的读请求量，比如fastdfs、mongodb。<strong>kafka是否支持通过副本机制提高读的请求量？-&gt; 不支持这样的机制</strong></p> 
<p>        3.改善数据局部性。允许将数据放入与用户地理位置相近的地方，从而降低系统延时。 kafka也不支持。</p> 
<p><strong>目前Kafka只实现了副本机制带来的第 1 个好处，即是提供数据冗余实现高可用性和高持久性。</strong></p> 
<p></p> 
<p>        在kafka生产环境中，<strong>每台 Broker 都可能保存有各个主题下不同分区的不同副本</strong>，因此，单个 Broker上存有成百上千个副本的现象是非常正常的。</p> 
<p>        下图展示了一个有 3 台 Broker 的 Kafka 集群上的副本分布情况。从图中可以看到，主题 1 分区 0 的 3个副本分散在 3 台 Broker 上，其他主题分区的副本也都散落在不同的 Broker 上，从而实现数据冗余。</p> 
<p><img alt="" height="669" src="https://images2.imgbox.com/a4/72/nRFKZByY_o.png" width="1200"></p> 
<p>基于<strong>领导者</strong>的副本机制：</p> 
<p><img alt="" height="622" src="https://images2.imgbox.com/47/3e/bNbAW7DD_o.png" width="1200"></p> 
<p>        1. 在 Kafka 中，副本分成两类：领导者副本（Leader Replica）和追随者副本（FollowerReplica）。每个分区在创建时都要选举一个副本，称为领导者副本，其余的副本自动称为追随者副本。</p> 
<p>        2. Kafka 副本机制中的追随者副本是<strong>不对外提供服务</strong>的，不同于Fastdfs、MongdoDB等。</p> 
<p>        3.当领导者副本挂掉了，或领导者副本所在的 Broker 宕机时，Kafka 依托于 ZooKeeper 提供的监控功能能够实时感知到，并立即开启新一轮的领导者选举，从追随者副本中选一个作为新的领导者。老 Leader 副本重启回来后，只能作为追随者副本加入到集群中。</p> 
<h3 id="4.%E7%94%9F%E4%BA%A7%E8%80%85">4.生产者</h3> 
<p>        producer就是生产者，是数据的入口。<strong>Producer在写入数据的时候永远的找leader，不会直接将数据写入follower。</strong><br><img alt="" height="581" src="https://images2.imgbox.com/bd/57/UQs6zuNF_o.png" width="1200"></p> 
<h4 id="4.1.%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%86%E5%8C%BA%E5%8F%AF%E4%BB%A5%E6%B0%B4%E5%B9%B3%E6%89%A9%E5%B1%95%EF%BC%9F">4.1.为什么分区可以水平扩展？</h4> 
<p>         Kafka 的消息组织方式实际上是三级结构：主题 - 分区 - 消息。主题下的每条消息只会保存在某一个分区中，而不会在多个分区中被保存多份。如下所示：</p> 
<p><img alt="" height="677" src="https://images2.imgbox.com/b0/35/ADjb36sU_o.png" width="1200"></p> 
<p>        分区的作用主要<strong>提供负载均衡的能力，能够实现系统的高伸缩性（Scalability)</strong>。不同的分区能够被放置到不同节点的机器上，而数据的读写操作也都是针对分区这个粒度而进行的，这样每个节点的机器都能独立地执行各自分区的读写请求处理。这样，当性能不足的时候可以通过<strong>添加新的节点机器来增加整体系统的吞吐量。</strong></p> 
<p>        分区原则：我们需要将 Producer 发送的数据封装成一个 ProducerRecord 对象。该对象需要指定一些参数：<br><strong>        topic：</strong>string 类型，NotNull。</p> 
<p><strong>        partition：</strong>int 类型，可选。</p> 
<p><strong>        timestamp：</strong>long 类型，可选。</p> 
<p><strong>        key：</strong>string 类型，可选。</p> 
<p><strong>        value：</strong>string 类型，可选。</p> 
<p><strong>        headers：</strong>array 类型，Nullable</p> 
<h4 id="4.2.%E5%88%86%E5%8C%BA%E7%AD%96%E7%95%A5">4.2.分区策略</h4> 
<p>        分区策略是决定生产者将消息发送到哪个分区的算法。</p> 
<h5 id="1.%E8%BD%AE%E8%AF%A2%E7%AD%96%E7%95%A5%EF%BC%88Round-robin%EF%BC%89">1.轮询策略（Round-robin）</h5> 
<p>        即顺序分配。比如一个主题下有 3 个分区，那么第一条消息被发送到分区 0，第二条被发送到分区 1，第三条被发送到分区 2，以此类推。当生产第 4 条消息时又会重新开始，即将其分配到分区 0。</p> 
<p><img alt="" height="384" src="https://images2.imgbox.com/08/71/ySSAlgVG_o.png" width="1200"></p> 
<p>        轮询策略有非常优秀的负载均衡表现，它总是能保证消息最大限度地被平均分配到所有分区上，故<strong>默认情况下它是最合理的分区策略</strong>，也是我们最常用的分区策略之一。</p> 
<h5 id="2.%E9%9A%8F%E6%9C%BA%E7%AD%96%E7%95%A5%EF%BC%88Randomness%EF%BC%89">2.随机策略（Randomness）</h5> 
<p>        随机就是随意地将消息放置到任意一个分区上，如下面这张图所示。<br><img alt="" height="412" src="https://images2.imgbox.com/13/a8/bd0tPXFy_o.png" width="1200"></p> 
<h5 id="3.%E6%8C%89%E6%B6%88%E6%81%AF%E9%94%AE%E4%BF%9D%E5%BA%8F%E7%AD%96%E7%95%A5%EF%BC%88Key-ordering%EF%BC%89">3.按消息键保序策略（Key-ordering）</h5> 
<p>        Kafka 允许为每条消息定义消息键，简称为 Key。这个 Key 的作用非常大，它可以是一个有着明确业务含义的字符串，比如客户代码、部门编号或是业务 ID 等；也可以用来表征消息元数据。特别是在 Kafka不支持时间戳的年代，在一些场景中，工程师们都是直接将消息创建时间封装进 Key 里面的。<strong>一旦消息被定义了 Key，那么你就可以保证同一个 Key 的所有消息都进入到相同的分区里面</strong>，由于每个分区下的消息处理都是有顺序的，故这个策略被称为按消息键保序策略。</p> 
<h5 id="4.%E9%BB%98%E8%AE%A4%E5%88%86%E5%8C%BA%E7%AD%96%E7%95%A5">4.默认分区策略</h5> 
<p>        1. 指明 Partition 的情况下，直接将给定的 Value 作为 Partition 的值。</p> 
<p>        2. 没有指明 Partition 但有 Key 的情况下，将 Key 的 Hash 值与分区数<strong>取余</strong>得到 Partition 值。</p> 
<p>        3. 既没有 Partition 有没有 Key 的情况下，第一次调用时随机生成一个整数（后面每次调用都在这个整数上自增），将这个值与可用的分区数取余，得到 Partition 值，也就是常说的 Round-Robin轮询算法。</p> 
<p></p> 
<p>消息是按照三种策略进入分区:</p> 
<p>        1、如果指定的partition，那么直接进入该partition;</p> 
<p>        2、如果没有指定partition，但是指定了key，使用key的hash值选择partition;</p> 
<p>        3、如果既没有指定partition，也没有指定key，使用轮询的方式进入partition。</p> 
<p></p> 
<h3 id="5.%E6%B6%88%E8%B4%B9%E8%80%85">5.消费者</h3> 
<p>        传统的消息队列模型的缺陷在于消息一旦被消费，就会从队列中被删除，而且只能被下游的一个Consumer 消费。严格来说，这一点不算是缺陷，只能算是它的一个特性。但很显然，这种模型的伸缩性（scalability）很差，因为下游的多个 Consumer 都要“抢”这个共享消息队列的消息。发布 / 订阅模型倒是允许消息被多个 Consumer 消费，但它的问题也是伸缩性不高，因为每个订阅者都必须要订阅主题的所有分区。这种全量订阅的方式既不灵活，也会影响消息的真实投递效果。</p> 
<p>        当 Consumer Group 订阅了多个主题后，组内的每个实例不要求一定要订阅主题的所有分区，它只会消费部分分区中的消息。Consumer Group 之间彼此独立，互不影响，它们能够订阅相同的一组主题而互不干涉。再加上 Broker 端的消息留存机制，Kafka 的 Consumer Group 完美地规避了上面提到的伸缩性差的问题。可以这么说，Kafka 仅仅使用 Consumer Group 这一种机制，却同时实现了传统消息引擎系统的两大模型：<strong>如果所有实例都属于同一个 Group，那么它实现的就是消息队列模型；如果所有实例分别属于不同的 Group，那么它实现的就是发布 / 订阅模型。</strong></p> 
<p><img alt="" height="870" src="https://images2.imgbox.com/65/33/ONNFwQBT_o.png" width="1200"></p> 
<h4 id="5.1%20%E6%B6%88%E8%B4%B9%E6%96%B9%E5%BC%8F">5.1 消费方式</h4> 
<p>        Consumer 采用 Pull（拉取）模式从 Broker 中读取数据。</p> 
<p>        Pull 模式则可以根据 Consumer 的消费能力以适当的速率消费消息。Pull 模式不足之处是，如果 Kafka没有数据，消费者可能会陷入循环中，一直返回空数据。</p> 
<p>        因为消费者从 Broker 主动拉取数据，需要维护一个长轮询，针对这一点， Kafka 的消费者在消费数据时会传入一个时长参数 timeout。如果当前没有数据可供消费，Consumer 会等待一段时间之后再返回，这段时长即为 timeout。</p> 
<h4 id="5.2%20%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5">5.2 分区分配策略</h4> 
<p>        一个 Consumer Group 中有多个 Consumer，一个 Topic 有多个 Partition，所以必然会涉及到Partition 的分配问题，即确定<strong>哪个 Partition 由哪个 Consumer 来消费</strong>。</p> 
<p>        Kafka 有三种分配策略：</p> 
<p>                1. <strong>RoundRobin</strong></p> 
<p>                2. <strong>Range，默认为Range</strong></p> 
<p>                3. Sticky</p> 
<p>        当消费者组内消费者发生变化时，会触发分区分配策略（方法重新分配）。<strong>这里主要讲Range、RoundRobin</strong>。</p> 
<h5 id="5.2.1%20Range%EF%BC%88%E9%BB%98%E8%AE%A4%E7%AD%96%E7%95%A5%EF%BC%89">5.2.1 Range（默认策略）</h5> 
<p>        Range 方式是按照主题来分的，不会产生轮询方式的消费混乱问题。</p> 
<p><img alt="" height="1151" src="https://images2.imgbox.com/8b/39/RgmgTkpV_o.png" width="1200"></p> 
<p>        假设我们有10个分区，3个消费者，排完序的分区将会是0,1,2,3,4,5,6,7,8,9；消费者线程排完序将会是C1-0,C2-0,C3-0。然后将partitions的个数除于消费者线程的总数来决定每个消费者线程消费几个分区。如果除不尽，那么前面几个消费者线程将会多消费一个分区。</p> 
<p>        在我们的例子里面，我们有10个分区，3个消费者线程，10/3 = 3，而且除不尽，那么消费者线程 C1-0将会多消费一个分区，结果看起来是这样的：</p> 
<p>                C1-0将消费 <strong>0, 1, 2, 3 分区</strong></p> 
<p>                C2-0将消费 <strong>4,5,6分区</strong></p> 
<p>                C3-0将消费<strong> 7,8,9分区</strong></p> 
<p>        假如我们有2个主题(T1和T2)，分别有10个分区，那么最后分区分配的结果看起来是这样的：</p> 
<p>                C1-0 将消费 <strong>T1主题的 0, 1, 2, 3 分区以及T2主题的 0, 1, 2, 3分区</strong></p> 
<p>                C2-0将消费 <strong>T1主题的 4,5,6分区以及T2主题的 4,5,6分区</strong></p> 
<p>                C3-0将消费 <strong>T1主题的 7,8,9分区以及T2主题的 7,8,9分区</strong></p> 
<p>        可以看出，C1-0 消费者线程比其他消费者线程多消费了2个分区，这就是Range strategy的一个很明显的弊端，如下图所示，Consumer0、Consumer1 同时订阅了主题 A 和 B，可能造成消息分配不对等问题，当消费者组内订阅的主题越多，分区分配可能越不均衡。</p> 
<p><img alt="" height="1157" src="https://images2.imgbox.com/70/cc/pCmOH5NN_o.png" width="1200"></p> 
<h5 id="5.2.2%20RoundRobin">5.2.2 RoundRobin</h5> 
<p>        RoundRobin 轮询方式将分区所有作为一个整体进行 Hash 排序，消费者组内分配分区个数最大差别为1，是按照组来分的，可以解决多个消费者消费数据不均衡的问题。</p> 
<p>        轮询分区策略是把所有partition和所有consumer线程都列出来，然后按照hashcode进行排序。最后通过轮询算法分配partition给消费线程。<strong>如果所有consumer实例的订阅是相同的，那么partition会均匀分布。</strong></p> 
<p><img alt="" height="1150" src="https://images2.imgbox.com/8a/45/pSgKlsol_o.png" width="1200">         假如按照 hashCode排序完的topic-partitions组依次为T1-5, T1-3, T1-0, T1-8, T1- 2, T1-1, T1-4, T1-7, T1-6, T1-9，我们的消费者线程排序为C1-0,C1-1,C2-0,C2-1，最后分区分配的结果为：</p> 
<p>        C1-0将消费 T1-5,T1-2,T1-6分区；</p> 
<p>        C1-1将消费 T1-3,T1-1,T1-9分区；</p> 
<p>        C2-0将消费 T1-0,T1-4分区；</p> 
<p>        C2-1将消费 T1-8,T1-7分区；</p> 
<p>         但是，当消费者组内订阅不同主题时，可能造成消费混乱，如下图所示，<strong>Consumer0 订阅主题 A， Consumer1 订阅主题 B。</strong></p> 
<p><img alt="" height="1128" src="https://images2.imgbox.com/a3/37/3kOuwTZ3_o.png" width="1200"></p> 
<p>         将 A、B 主题的分区排序后分配给消费者组，TopicB 分区中的数据可能分配到 Consumer0 中。使用轮询分区策略必须满足两个条件</p> 
<p>        <strong>1. 每个主题的消费者实例具有相同数量的流</strong></p> 
<p>        <strong>2. 每个消费者订阅的主题必须是相同的</strong></p> 
<h4></h4> 
<h3 id="6.%E6%95%B0%E6%8D%AE%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BF%9D%E8%AF%81"><strong>6.数据可靠性保证</strong></h3> 
<p>        为保证 Producer 发送的数据，能可靠地发送到指定的 Topic，Topic 的每个 Partition 收到 Producer发送的数据后，都需要向 Producer 发送 ACK（ACKnowledge 确认收到）。如果 Producer 收到 ACK，就会进行下一轮的发送，否则重新发送数据。</p> 
<p><img alt="" height="988" src="https://images2.imgbox.com/fd/5c/CoEo5gJl_o.png" width="1200"></p> 
<h4 id="6.1%20%E5%89%AF%E6%9C%AC%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E7%AD%96%E7%95%A5">6.1 副本数据同步策略</h4> 
<p>        <strong>何时发送 ACK？</strong>确保有 Follower 与 Leader 同步完成，Leader 再发送 ACK，这样才能保证 Leader 挂掉之后，能在 Follower 中选举出新的 Leader 而不丢数据。</p> 
<p>       <strong> 多少个 Follower 同步完成后发送 ACK？</strong>全部 Follower 同步完成，再发送 ACK。</p> 
<p></p> 
<p>        所有 Follower 完成同步，Producer 才能继续发送数据，设想有一个 Follower 因为某种原因出现故障，那 Leader 就要一直等到它完成同步。这个问题怎么解决？</p> 
<p>        1. Leader 维护了一个动态的 <strong>in-sync replica set（ISR）</strong>：和 Leader 保持同步的 Follower 集合。</p> 
<p>        2. 当 ISR 集合中的 Follower 完成数据的同步之后，Leader 就会给 Follower 发送 ACK。</p> 
<p>        3. 如果 Follower 长时间未向 Leader 同步数据，则该 Follower 将被踢出 ISR 集合，该时间阈值由replica.lag.time.max.ms 参数设定。Leader 发生故障后，就会从 ISR 中选举出新的 Leader。</p> 
<h4></h4> 
<h4 id="6.2%20ACK%E5%BA%94%E7%AD%94%E6%9C%BA%E5%88%B6">6.2 ACK应答机制</h4> 
<p>        对于某些不太重要的数据，对数据的可靠性要求不是很高，能够容忍数据的少量丢失，所以没必要等 ISR 中的 Follower 全部接受成功。</p> 
<p>        所以 Kafka 为用户提供了三种可靠性级别，用户根据可靠性和延迟的要求进行权衡，选择以下的配置。</p> 
<p><img alt="" height="908" src="https://images2.imgbox.com/73/2f/5xAeF8Ng_o.png" width="1200"></p> 
<p> <strong>ACK 参数配置：</strong></p> 
<p>        0：Producer 不等待 Broker 的 ACK，这提供了最低延迟，Broker 一收到数据还没有写入磁盘就已经返回，当 Broker 故障时有可能丢失数据。</p> 
<p>        1：Producer 等待 Broker 的 ACK，Partition 的 Leader 落盘成功后返回 ACK，如果在 Follower 同步成功之前 Leader 故障，那么将会丢失数据。</p> 
<p>        -1（all）：Producer 等待 Broker 的 ACK，Partition 的 Leader 和 Follower 全部落盘成功后才返回 ACK。但是在 Broker 发送 ACK 时，Leader 发生故障，则会造成数据重复。</p> 
<p></p> 
<h2 id="%E5%8F%82%E8%80%83">参考</h2> 
<p><a class="has-card" href="https://mp.weixin.qq.com/s/dOiNT0a_dRytwatzdrJNCg" rel="nofollow" title="2 万字长文深入详解 Kafka，从源码到架构全部讲透"><span class="link-card-box"><span class="link-title">2 万字长文深入详解 Kafka，从源码到架构全部讲透</span><span class="link-desc">关于Kafka，研究透这一篇就基本够用了。</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/6f/e9/wR2BOPdS_o.png" alt="icon-default.png?t=N7T8">https://mp.weixin.qq.com/s/dOiNT0a_dRytwatzdrJNCg</span></span></a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f5c0c0ab15b41375f36d007c91eebdc4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">仲利国际融资租赁测评社招校招入职面试北森测评题库题型分析、通关技巧</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1615250c280255bea4c84a721ca161e2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">「MyBatis」数据库相关操作2</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>