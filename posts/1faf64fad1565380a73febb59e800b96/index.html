<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;——探索智能指针的设计原理 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/1faf64fad1565380a73febb59e800b96/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C&#43;&#43;——探索智能指针的设计原理">
  <meta property="og:description" content="前言: RAII是资源获得即初始化， 是一种利用对象生命周期来控制程序资源地手段。 智能指针是在对象构造时获取资源， 并且在对象的声明周期内控制资源， 最后在对象析构的时候释放资源。注意， 本篇文章参考——C&#43;&#43; 智能指针 - 全部用法详解-CSDN博客
看完博主的文章的友友们， 可以去看一下该篇文章， 该作者写的比博主通俗易懂。
目录
为什么需要智能指针
智能指针
auto_ptr
auto_ptr的用法:
auto_ptr的模拟实现:
unique_ptr
unique_ptr的用法
unique_ptr的模拟实现
shared_ptr
shared_ptr的用法
shared_ptr的模拟实现（v1版本）
weak_ptr
weak_ptr的用法:
weak_ptr的模拟实现
shared_ptr中的定制删除器
智能指针坑点 为什么需要智能指针 首先我们来看一下这一个简单的程序:
void func() { int* p = new int; } int main() { func(); return 0; } 在这个程序里面， func中定义了一个指向堆区一块空间的p。 但是当出了作用域后， p指针就被销毁了， 但是p指针指向的空间没有被销毁，这个时候就发生了内存泄漏。
另外一种情况就是我们虽然手动释放了内存， 但是中途发生了异常， 程序发生跳转， 手动释放内存被截胡了。 也会导致发生内存泄漏。
void test() { int* ptr = new int; if (1) { throw &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-29T18:35:11+08:00">
    <meta property="article:modified_time" content="2024-06-29T18:35:11+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;——探索智能指针的设计原理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>        <span style="color:#fe2c24;"><strong><span style="background-color:#ffd900;">前言:</span></strong></span> RAII是资源获得即初始化， 是一种利用对象生命周期来控制程序资源地手段。 智能指针是在对象构造时获取资源， 并且在对象的声明周期内控制资源， 最后在对象析构的时候释放资源。注意， 本篇文章参考——<a href="https://blog.csdn.net/cpp_learner/article/details/118912592?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171958188116800180698400%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=171958188116800180698400&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-118912592-null-null.142%5Ev100%5Epc_search_result_base4&amp;utm_term=%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88&amp;spm=1018.2226.3001.4187" title="C++ 智能指针 - 全部用法详解-CSDN博客">C++ 智能指针 - 全部用法详解-CSDN博客</a></p> 
 <p>        看完博主的文章的友友们， 可以去看一下该篇文章， 该作者写的比博主通俗易懂。</p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-toc" style="margin-left:0px;"><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88" rel="nofollow">为什么需要智能指针</a></p> 
<p id="%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-toc" style="margin-left:0px;"><a href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88" rel="nofollow">智能指针</a></p> 
<p id="auto_ptr-toc" style="margin-left:0px;"><a href="#auto_ptr" rel="nofollow">auto_ptr</a></p> 
<p id="auto_ptr%E7%9A%84%E7%94%A8%E6%B3%95%3A-toc" style="margin-left:40px;"><a href="#auto_ptr%E7%9A%84%E7%94%A8%E6%B3%95%3A" rel="nofollow">auto_ptr的用法:</a></p> 
<p id="auto_ptr%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%3A-toc" style="margin-left:40px;"><a href="#auto_ptr%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%3A" rel="nofollow">auto_ptr的模拟实现:</a></p> 
<p id="unique_ptr-toc" style="margin-left:0px;"><a href="#unique_ptr" rel="nofollow">unique_ptr</a></p> 
<p id="unique_ptr%E7%9A%84%E7%94%A8%E6%B3%95-toc" style="margin-left:40px;"><a href="#unique_ptr%E7%9A%84%E7%94%A8%E6%B3%95" rel="nofollow">unique_ptr的用法</a></p> 
<p id="unique_ptr%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#unique_ptr%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" rel="nofollow">unique_ptr的模拟实现</a></p> 
<p id="shared_ptr-toc" style="margin-left:0px;"><a href="#shared_ptr" rel="nofollow">shared_ptr</a></p> 
<p id="shared_ptr%E7%9A%84%E7%94%A8%E6%B3%95-toc" style="margin-left:40px;"><a href="#shared_ptr%E7%9A%84%E7%94%A8%E6%B3%95" rel="nofollow">shared_ptr的用法</a></p> 
<p id="%C2%A0shared_ptr%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%EF%BC%88v1%E7%89%88%E6%9C%AC%EF%BC%89-toc" style="margin-left:40px;"><a href="#%C2%A0shared_ptr%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%EF%BC%88v1%E7%89%88%E6%9C%AC%EF%BC%89" rel="nofollow"> shared_ptr的模拟实现（v1版本）</a></p> 
<p id="weak_ptr-toc" style="margin-left:0px;"><a href="#weak_ptr" rel="nofollow">weak_ptr</a></p> 
<p id="weak_ptr%E7%9A%84%E7%94%A8%E6%B3%95%3A-toc" style="margin-left:40px;"><a href="#weak_ptr%E7%9A%84%E7%94%A8%E6%B3%95%3A" rel="nofollow">weak_ptr的用法:</a></p> 
<p id="weak_ptr%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#weak_ptr%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" rel="nofollow">weak_ptr的模拟实现</a></p> 
<p id="shared_ptr%E4%B8%AD%E7%9A%84%E5%AE%9A%E5%88%B6%E5%88%A0%E9%99%A4%E5%99%A8-toc" style="margin-left:0px;"><a href="#shared_ptr%E4%B8%AD%E7%9A%84%E5%AE%9A%E5%88%B6%E5%88%A0%E9%99%A4%E5%99%A8" rel="nofollow">shared_ptr中的定制删除器</a></p> 
<p id="%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%9D%91%E7%82%B9%C2%A0-toc" style="margin-left:0px;"><a href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%9D%91%E7%82%B9%C2%A0" rel="nofollow">智能指针坑点 </a></p> 
<hr id="hr-toc"> 
<h2>为什么需要智能指针</h2> 
<p>        首先我们来看一下这一个简单的程序:</p> 
<pre><code class="language-cpp">
void func() 
{
	int* p = new int;
}

int main() 
{
	func();

	return 0;
}
</code></pre> 
<p>        在这个程序里面， func中定义了一个指向堆区一块空间的p。 但是当出了作用域后， p指针就被销毁了， 但是p指针指向的空间没有被销毁，这个时候就发生了内存泄漏。</p> 
<p>        另外一种情况就是我们虽然手动释放了内存， 但是中途发生了异常， 程序发生跳转， 手动释放内存被截胡了。 也会导致发生内存泄漏。</p> 
<pre><code class="language-cpp">void test() 
{
	int* ptr = new int;

	if (1) 
	{
		throw "发生异常";     //这里发生截胡， 无法走到下一行。
	}

	delete ptr;          //这里没有释放资源
}


int main() 
{
	try 
	{
		test();
	}
	catch (const char* str)
	{
		cout &lt;&lt; str &lt;&lt; endl;
	}
	catch (...) 
	{
		cout &lt;&lt; "未知异常" &lt;&lt; endl;
	}
	return 0;
}</code></pre> 
<p>而只能指针就是为了这种情况设计出来的。也就是说， 智能指针就是为了我们能够方便管理动态内存分配的资源， 它能够在对象的声明周期结束时自动释放这些资源。</p> 
<p>        如图为一个简单的智能指针</p> 
<p></p> 
<p class="img-center"><img alt="" height="553" src="https://images2.imgbox.com/8f/cf/GKvHU6sK_o.png" width="470"></p> 
<p>在这个智能指针当中， 当我们创建对象时，可以使用一块资源初始化。 然后这块资源就会在这个对象的生命周期结束时自动销毁。</p> 
<p class="img-center"><img alt="" height="162" src="https://images2.imgbox.com/3c/43/FSGzCSmP_o.png" width="604"></p> 
<p>        这就是智能指针的基本原理， 虽然我们使用指针时， 指针指向的空间不会被自动释放。但是对象在生命周期结束时会自动释放， 所以我们把指针指向的资源放到对象里， 让对象在释放自身的时候将资源一起释放掉。</p> 
<h2 id="%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88">智能指针</h2> 
<p>       </p> 
<blockquote> 
 <p>现在有三个智能指针的解决方案：</p> 
 <ul><li><span style="color:#be191c;"><strong>        auto_ptr               C++98</strong></span></li><li><span style="color:#be191c;"><strong>        unique_ptr           C++11</strong></span></li><li><span style="color:#be191c;"><strong>        share_ptr             C++11</strong></span></li></ul> 
 <p>另外， 还有一个用来解除share_ptr中的循环引用问题的解决方案。</p> 
 <ul><li>        <span style="color:#be191c;"><strong>wake_ptr               C++11</strong></span></li></ul> 
</blockquote> 
<h2 id="auto_ptr">auto_ptr</h2> 
<h3 id="auto_ptr%E7%9A%84%E7%94%A8%E6%B3%95%3A">auto_ptr的用法:</h3> 
<p>        使用智能指针需要包含头文件memory, 具体使用方法如下:</p> 
<pre><code class="language-cpp">#include&lt;memory&gt;             //只用智能指针需要包含memory头文件

int main() 
{
	auto_ptr&lt;int&gt; p(new int);                  //利用auto_ptr创建一个管理int指针资源的对象
	auto_ptr&lt;list&lt;int&gt;&gt; pl(new list&lt;int&gt;);     //利用auto_ptr创建一个管理list&lt;int&gt;类型的指针资源的对象

	*p = 4;                    //auto_ptr&lt;int&gt;类型也能进行解引用操作
	(*pl).push_back(16);       //容器的指针， 解引用后就是容器本身。
	(*pl).push_back(15);
	(*pl).push_back(14);
	(*pl).push_back(13);
	(*pl).push_back(12);
	
	cout &lt;&lt; *p &lt;&lt; endl;                   //打印*p
	auto it = (*pl).begin();              //pl解引用获得list&lt;int&gt;对象， 可以像使用指针
	while (it != (*pl).end()) 
	{
		cout &lt;&lt; *it &lt;&lt; endl;
		++it;
	}

	return 0;
}</code></pre> 
<p>        这里创建智能指针对象是: auto_ptr&lt;类型名&gt; p(new 类型名)  ， 这里创建的时候不能使用 ’ = ‘， 只能使用 ' ( ) ';</p> 
<p>        auto_ptr是在C++98创建出来的， 但是这个智能指针在之后很少被人用。 因为它有一个弊端， 就是当进行拷贝的时候， 该智能指针管理的资源会被 ”抛弃“， 另一个智能指针进行接收。 也就是如图:</p> 
<p><img alt="" height="264" src="https://images2.imgbox.com/8c/39/9hMWShmb_o.png" width="520"></p> 
<p>        这个模式存在一些弊端。如果我们使用一个容器进行插入操作的时候，插入操作一定会赋值。 那么赋值就会导致原本智能指针对象中的资源被转移。</p> 
<p>        另外， auto_ptr的另一个弊端就是auto_ptr不支持对象数组的操作。<img alt="" height="164" src="https://images2.imgbox.com/ca/2a/UlwU4TjS_o.png" width="682">所以在C++11出现更好的unique_ptr和share_ptr后，auto_ptr已经很少被使用。 </p> 
<p>        auto_ptr有三个常用接口。 get, release, reset。</p> 
<p>三个函数的主要功能</p> 
<p>1. get（）</p> 
<p>        get是获取对象中管理的资源：</p> 
<p><img alt="" height="361" src="https://images2.imgbox.com/5b/16/6lqvVARk_o.png" width="1200"></p> 
<p>2.release</p> 
<p>        release， 是取消对象中管理的资源：</p> 
<p><img alt="" height="522" src="https://images2.imgbox.com/38/1a/cxB59ChE_o.png" width="1200"></p> 
<p>3.reset</p> 
<p>        reset， 是重新分配对象中管理的资源：</p> 
<p><img alt="" height="662" src="https://images2.imgbox.com/24/b9/XrxUoXzi_o.png" width="1200"></p> 
<p></p> 
<h3 id="auto_ptr%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%3A">auto_ptr的模拟实现:</h3> 
<p><span style="color:#be191c;"><strong>//首先， 对于智能指针来说，他们的模板类名是这样的：</strong></span></p> 
<pre><code class="language-cpp">	template&lt;class T&gt;       //模板类， 可以接收T类型的资源
	class auto_ptr          //智能指针类名
	{
        
	};</code></pre> 
<p><span style="color:#be191c;"><strong>//然后， 在类里面定义资源类型的指针， 用来维护这块资源: </strong></span></p> 
<pre><code class="language-cpp">	template&lt;class T&gt;
	class auto_ptr
	{
	private:
		T* _ptr;          //T类型资源的指针， 用来维护一块资源
	};</code></pre> 
<p><span style="color:#be191c;"><strong>//所有智能指针的构造都是一样的， 就是使用一块资源交给智能指针里面的指针变量进行维护。</strong></span></p> 
<pre><code class="language-cpp">		auto_ptr(T* ptr)
			:_ptr(ptr)
		{}
</code></pre> 
<p><span style="color:#be191c;"><strong> //auto_ptr的拷贝构造， 其实就是把一个智能指针管理的资源 “抛弃”，然后另一个智能指针进行接收。 至于这样做的弊端， 上面已经提到过， 这里不赘述。</strong></span></p> 
<pre><code class="language-cpp">		auto_ptr(auto_ptr&lt;T&gt;&amp; ptr)
			:_ptr(ptr._ptr) 
		{
			ptr._ptr = nullptr;
		}</code></pre> 
<p><span style="color:#be191c;"><strong>//最重要的就是智能指针的销毁， 销毁时， 要将管理的资源一块释放掉， 代码如下:</strong></span></p> 
<pre><code class="language-cpp">		~auto_ptr() 
		{
			delete _ptr;
			_ptr = nullptr;
		}</code></pre> 
<p><span style="color:#be191c;"><strong>//然后智能指针还要像普通指针一样能够进行基本运算——加加， 减减， 解引用等。那么就要重载这些运算符， 如下图:</strong></span></p> 
<pre><code class="language-cpp">		T&amp; operator*()           //解引用
		{
			return *_ptr;
		}

		T* operator-&gt;()          //箭头
		{
			return _ptr;
		}

		auto_ptr&lt;T&gt; operator++() //加加重载
		{
			++_ptr;
			return *this;
		}</code></pre> 
<h2 id="unique_ptr">unique_ptr</h2> 
<h3 id="unique_ptr%E7%9A%84%E7%94%A8%E6%B3%95">unique_ptr的用法</h3> 
<p>unique_ptr相交于auto_ptr更加严谨， 它相对于auto_ptr做了一下改变:<br>         两块指针不能指向同一块资源(否则在释放空间时多次释放空间报错)。 同时它也不能赋值（注意， 右值可以赋值，但是右值赋值后， 如果该右值为一个左值临时转化的， 那么使用赋值后和auto_ptr的效果一样）</p> 
<p>左值赋值：</p> 
<p><img alt="" height="158" src="https://images2.imgbox.com/17/d0/3ChFjR8K_o.png" width="469"></p> 
<p> 右值赋值：</p> 
<p><img alt="" height="178" src="https://images2.imgbox.com/36/e4/ggCtBRZC_o.png" width="473"></p> 
<p><span style="color:#be191c;"><strong>要注意的坑点就是不能一块资源给多个对象赋值， 不然会报错:</strong></span></p> 
<p><img alt="" height="304" src="https://images2.imgbox.com/39/53/jmU15yPY_o.png" width="425"></p> 
<p>auto_ptr也一样</p> 
<p><img alt="" height="328" src="https://images2.imgbox.com/7f/ec/pT7gXJwA_o.png" width="425"></p> 
<p>这是unique_ptr和auto_ptr中使用的坑。 后面的share_ptr解决了这个坑点（引用计数）</p> 
<h3 id="unique_ptr%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">unique_ptr的模拟实现</h3> 
<p>有前面auto_ptr的基础， 这里unique_ptr的细节不再讲解， 只讲解重要的部分:</p> 
<p>//首先模板类：</p> 
<pre><code class="language-cpp">	template&lt;class T&gt;
	class unique_ptr 
	{

	private:
		T* _ptr;      //管理资源
	};
</code></pre> 
<p>//然后就是主要的地方 ， unique_ptr不能进行赋值， 所以要将拷贝构造和赋值重载封起来。</p> 
<pre><code class="language-cpp">	template&lt;class T&gt;
	class unique_ptr 
	{
	public:
		unique_ptr(T* ptr)
			:_ptr(ptr) 
		{}
	
	private:
		unique_ptr(unique_ptr&lt;T&gt;&amp; ) = delete;                    //将拷贝构造删掉
		unique_ptr&lt;T&gt;&amp; operator=(unique_ptr&lt;T&gt;&amp; ) = delete;      //将赋值重载删掉

	private:
		T* _ptr;
	};</code></pre> 
<h2 id="shared_ptr">shared_ptr</h2> 
<h3 id="shared_ptr%E7%9A%84%E7%94%A8%E6%B3%95">shared_ptr的用法</h3> 
<p>shared_ptr解决了unique_ptr和auto_ptr的排他性， shared_ptr即使多个智能指针指向同一块空间也能正常工作。 </p> 
<p>        shared_ptr采用了引用计数， 当一个新的share_ptr指针管理一块资源的时候， 引用计数就+1, 当一个shared_ptr指针过期时， 引用计数就-1。当一块资源的引用计数到0时， 这块资源就可以被释放。</p> 
<p>1. use_count() : 获得当前资源的引用计数：</p> 
<p><img alt="" height="268" src="https://images2.imgbox.com/1f/1c/LLsD2HqL_o.png" width="513"></p> 
<p>2.conductor: 有多种构造形式——直接赋值一块资源、 赋值一块数组资源、传送定制删除器。</p> 
<p>定义如下:</p> 
<p>//带有定制删除器</p> 
<pre><code class="language-cpp">template&lt;class U, class D&gt;

shared_ptr(U* p, D del)</code></pre> 
<p>//普通构造 </p> 
<pre><code class="language-cpp">template&lt;class U&gt;

shared_ptr(U* p)</code></pre> 
<p>//数组构造</p> 
<pre><code class="language-cpp">shared_ptr&lt;T[]&gt; p(new T[5]{1, 2, 3, 4, 5});      //据说是C++17后支持, 但是vsC++14也能跑</code></pre> 
<p>3.make_shared</p> 
<p>make_shared可以用来分配一块空间并且初始化这块空间， 效率更加高效。make_shared是一个函数模板， 并且需要指定分配资源的类型， 如图:</p> 
<p><img alt="" height="369" src="https://images2.imgbox.com/ba/b9/58jM9wBP_o.png" width="1159"></p> 
<h3 id="%C2%A0shared_ptr%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%EF%BC%88v1%E7%89%88%E6%9C%AC%EF%BC%89"> shared_ptr的模拟实现（v1版本）</h3> 
<p>首先，类名， 解引用之类和其他智能指针相差不大， 这里不做赘述， 然后有区别的就是成员变量以及构造， 拷贝， 赋值。 </p> 
<p>        首先看成员变量， 成员变量需要有一块空间来作为引用计数。</p> 
<p><img alt="" height="246" src="https://images2.imgbox.com/98/69/QaNfjOhT_o.png" width="607"></p> 
<pre><code class="language-cpp">	template&lt;class T&gt;
	class shared_ptr 
	{

	private:
		T* _ptr;
		int* _pcount;
	};
	</code></pre> 
<p>*_pcount作为引用计数。</p> 
<p>//构造</p> 
<pre><code class="language-cpp">		//引用计数ptr
		shared_ptr(T* ptr)
			:_ptr(ptr) 
		{
			*_pcount = 1;
		}</code></pre> 
<p>//拷贝构造</p> 
<pre><code class="language-cpp">		//引用计数地拷贝构造
		shared_ptr(shared_ptr&lt;T&gt;&amp; ptr) 
			:_ptr(ptr._ptr)
			,_pcount(ptr._pcount)
		{
			++(*_pcount);
		}</code></pre> 
<p>//析构</p> 
<pre><code class="language-cpp">		~shared_ptr() 
		{
			if (--(*_pcount) == 0) 
			{
				delete _ptr;
				delete _pcount;
			}
		}</code></pre> 
<p>赋值， 这里赋值要先将原本的管理的资源取消托管， 那么引用计数就要减一， 还要判断引用计数是否为0， 为0就要释放资源。</p> 
<pre><code class="language-cpp">		shared_ptr&lt;T&gt;&amp; operator=(shared_ptr&lt;T&gt;&amp; p) 
		{
			if (_ptr != p._ptr)          //如果不判断， 当自己给自己赋值的时候， 自己会先将自己的资源释放， 然后就变成了野指针。 自己再给自己赋值一个野指针。 就会报错。
			{
				if (--(*_pcount) == 0)
				{
					delete _ptr;
					delete _pcount;
				}
				//
				_ptr = p._ptr;
				_pcount = p._pcount;
				++(*_pcount);
			}

			return *this;
		}</code></pre> 
<p>shared_ptr中的坑</p> 
<p>        1. 其实， shared_ptr还有一种情况同样具有排他性, 和unique_ptr、auto_ptr一样， 当没有调用拷贝构造， 而是直接使用构造函数的时候， 引用计数不回加一， 那么就会多次释放资源。 这个无法避免。</p> 
<p><img alt="" height="296" src="https://images2.imgbox.com/c8/61/lZKc2DGh_o.png" width="518"></p> 
<p>        2.第二个坑就是循环引用的问题，为了方便观察， 我们使用我们自己定义的shared_ptr进行测试， 现在看如下一个例子:</p> 
<pre><code class="language-cpp">#include"share_ptr.h"      //自己写的shared_ptr头文件
struct chicken;            //前置声明

struct fish                //定义一个鱼类对象， 里面有一个鸡的智能指针实例
{
	cws_RAII::shared_ptr&lt;chicken&gt; _chicken;
};

struct chicken              //定义一个鸡类对象， 里面有一个鱼的智能指针实例。
{
	cws_RAII::shared_ptr&lt;fish&gt; _fish;                           
};



int main()
{
	cws_RAII::shared_ptr&lt;fish&gt; f1(new fish);
	cws_RAII::shared_ptr&lt;chicken&gt; c1(new chicken);

	(*f1)._chicken = c1;
	//(*c1)._fish = f1;

	return 0;
}</code></pre> 
<p> 在当前状态下， 我们如果运行程序， f1的资源和c1的资源可以被释放</p> 
<p><img alt="" height="320" src="https://images2.imgbox.com/75/96/CDaxUtgu_o.png" width="486"></p> 
<p>但是如过图中(*c1)._fish = f1取消注释， 那么f1的资源和c1的资源就不能被释放。 </p> 
<p><img alt="" height="316" src="https://images2.imgbox.com/24/40/Q2utGxeW_o.png" width="512"></p> 
<p>这是为什么？</p> 
<p>其实， 这就是循环引用的问题。 在这里面， 如果只定义了f1和c1. 这个时候是这样的:</p> 
<p><img alt="" height="258" src="https://images2.imgbox.com/37/30/K6C7WkvO_o.png" width="553"></p> 
<p>但是如果给执行两条赋值语句后， 就变成了这样:</p> 
<p><img alt="" height="281" src="https://images2.imgbox.com/80/0a/Aot3EVU3_o.png" width="531"></p> 
<p> 这个时候当f1和c1的生命周期结束时， f1的_pcount--， c1的_pcount--。 这两个_pcount都只能变成1， 变不成0， 所以不能释放资源。</p> 
<p>        所以， 我们在使用shared_ptr时， 要避免交叉赋值的情况。否则会出现内存泄漏。</p> 
<h2 id="weak_ptr">weak_ptr</h2> 
<p>weak_ptr是用来解决shared_ptr的循环引用问题。 当两个类需要交叉进行赋值的时候， 类中所定义的智能指针可以使用weak_ptr(原本使用shared_ptr), 因为weak_ptr不会增加资源的引用计数。 </p> 
<h3 id="weak_ptr%E7%9A%84%E7%94%A8%E6%B3%95%3A">weak_ptr的用法:</h3> 
<p>weak_ptr本人觉得最重要的一点就是可以和shared_ptr进行相互转化：</p> 
<pre><code class="language-cpp">int main()
{
	shared_ptr&lt;fish&gt; f2(new fish);

	weak_ptr&lt;fish&gt; f3(f2);     //将一个shared_ptr给给f3
	f3 = f2;                   //将shared_ptr赋值给weak_ptr
	f2 = f3.lock();            //将一个weak_ptr使用lock接口转化为shared_ptr;                   
	return 0;
}</code></pre> 
<p>同时， 还可以构造出一个空指针:</p> 
<pre><code class="language-cpp">
int main()
{
	weak_ptr&lt;fish&gt; f3;     //构造一个空指针
                 
	return 0;
}</code></pre> 
<p>但是， wear_ptr不支持解引用以及-&gt;</p> 
<p><img alt="" height="295" src="https://images2.imgbox.com/d8/8c/xMCUA9fK_o.png" width="452"></p> 
<p>weak_ptr也能使用use_count函数查看引用计数:</p> 
<p><img alt="" height="195" src="https://images2.imgbox.com/7f/59/4FhijHn1_o.png" width="449"></p> 
<h3 id="weak_ptr%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">weak_ptr的模拟实现</h3> 
<pre><code class="language-cpp">	template&lt;class T&gt;
	class weak_ptr 
	{
	public:
		//不支持RAII， 也就是不能初始化管理资源
		weak_ptr(const shared_ptr&lt;T&gt;&amp; ptr) 
		{
			_ptr = ptr._ptr;		//这里可以将weak_ptr弄成shared_ptr的友元， 就能访问私有_ptr
			_pcount = ptr._pcount;
		}
		
		weak_ptr&lt;T&gt;&amp; operator=(const shared_ptr&lt;T&gt;&amp; ptr) 
		{
			_ptr = ptr._ptr;
			_pcount = ptr._pcount;
			return *this;
		}

		int use_count() 
		{
			return (*_pcount);
		}

		T* get() 
		{
			return _ptr;
		}

	private:
		T* _ptr;
		int* _pcount;
	};</code></pre> 
<h2 id="shared_ptr%E4%B8%AD%E7%9A%84%E5%AE%9A%E5%88%B6%E5%88%A0%E9%99%A4%E5%99%A8">shared_ptr中的定制删除器</h2> 
<p>        在shared_ptr中， 可以管理一块连续的数组空间， 也可以管理一个单独的一块空间。 这两种资源类型需要不同的销毁方法。 单独的使用delete, 而数组空间需要使用delete[], 库里面的默认是使用delete, 但是如果我们想使用delete[]来销毁一块数组空间。 或者我们使用shared_ptr管理一块文件， shared_ptr生命周期结束时关闭文件。 那么就需要我们自己传一个定制删除器。 </p> 
<p>        定制删除器是放在如图所示红框框的代码块中:</p> 
<p><img alt="" height="365" src="https://images2.imgbox.com/56/38/KNjSDofO_o.png" width="473"></p> 
<p>        定制删除器的用法:</p> 
<p><img alt="" height="291" src="https://images2.imgbox.com/00/73/nhewMfOb_o.png" width="1200"></p> 
<p>如何实现定制删除器？</p> 
<p>其实定制删除器就是添加一个模板类， 如图:</p> 
<p><img alt="" height="184" src="https://images2.imgbox.com/ff/bd/8S3LUZVx_o.png" width="938"></p> 
<p><img alt="" height="264" src="https://images2.imgbox.com/ad/a3/7UsG7tKg_o.png" width="909"></p> 
<p><img alt="" height="304" src="https://images2.imgbox.com/fc/66/WI8468A9_o.png" width="987"> 下面是shared_ptr完整的版本（v2）</p> 
<pre><code class="language-cpp">	template&lt;class T&gt;
	class shared_ptr 
	{
	public:
		//引用计数ptr
		shared_ptr(T* ptr = nullptr)
			:_ptr(ptr) 
			,_pcount(new int(0))
		{
			if (_ptr != nullptr) 
			{
				*_pcount = 1;
			}
		}

		//引用计数地拷贝构造
		shared_ptr(shared_ptr&lt;T&gt;&amp; ptr) 
			:_ptr(ptr._ptr)
			,_pcount(ptr._pcount)
		{
			++(*_pcount);
		}

		//添加一个带有定制删除器的构造函数
		template&lt;class D&gt;     //D就是定制删除器的模板类
		shared_ptr(T* ptr, D del)
			:_Del(del)
			, _ptr(ptr) 
		{}

		void destroy() 
		{
			if (--(*_pcount) == 0) 
			{
				_Del;      //将定制删除器放在这就好了
			}
		}

		~shared_ptr() 
		{
			destroy();
		}
		
		//赋值
		shared_ptr&lt;T&gt;&amp; operator=(shared_ptr&lt;T&gt;&amp; p) 
		{
			if (_ptr != p._ptr) 
			{
				destroy();
				//
				_ptr = p._ptr;
				_pcount = p._pcount;
				++(*_pcount);
			}

			return *this;
		}
		
		T* operator-&gt;() 
		{
			return _ptr;
		}

		T&amp; operator*() 
		{
			return *_ptr;
		}

		T* _ptr;
		int* _pcount;
		function&lt;void(T*)&gt; _Del = [](T*) {delete _Del};
	};
</code></pre> 
<h2 id="%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%9D%91%E7%82%B9%C2%A0">智能指针坑点 </h2> 
<p>在看完大佬们的博客之后， 本人也总结了一些智能指针的 “坑点“， 这个坑点其实都是围绕 原生指针 展开的。</p> 
<p>第一个：原生指针不能用来初始化智能指针， 否则两个智能指针指向同一块资源， 引用计数不增加。智能指针过期时会报错 </p> 
<p>第二个：get获得的原生指针， 不能delete掉， 否则智能指针在过期后还会delete。会报错</p> 
<p>第三个：get获得的原生指针，也是原生指针， 不能初始化另一个智能指针。 </p> 
<p>第四个：release返回后的原生指针要被delete掉。 否则内存泄漏。</p> 
<p>----以上， 就是本篇全部内容。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/177a793a336fee1807882260fe11402e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【融合ChatGPT等AI模型】Python-GEE遥感云大数据分析、管理与可视化及多领域案例应用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/57ac47bfff656ff5da26b3379faefd4f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【大数据 复习】第3章 分布式文件系统HDFS（重中之重）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>