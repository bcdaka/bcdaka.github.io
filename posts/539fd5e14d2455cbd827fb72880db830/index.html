<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>opencv python 实现Canny检测后不连续不封闭轮廓的闭合 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/539fd5e14d2455cbd827fb72880db830/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="opencv python 实现Canny检测后不连续不封闭轮廓的闭合">
  <meta property="og:description" content="Canny检测后轮廓的闭合在网上看了一些相关文章后总结出有以下方法： 1、使用闭运算等形态学操作来对轮廓进行处理，但作为像素点级别 的形态学操作往往不能满足要求，如：两条轮廓线相距仅为一个像素，在进行闭运算操作时会使这两条轮廓粘连在一起。
2、对于规则的图像可通过对不连续的点或线段进行拟合，通过对称的修剪和补缺来处理，但适用的对象非常有限，所以只能特例分析。
3、找到图像中不连续轮廓中的端点，通过最近端点间画直线来处理，但这仅仅适用于简单的图像处理，对于一些复杂或者断续太大的轮廓反而效果比较差。
本章主要讲第三种方法，代码如下：
import cv2 import math import numpy as np import timeit start_time = timeit.default_timer() def point(img, h, w): p = [] for i in range(h): for j in range(w): if img[i, j] == 255: r = [] for y in range(i-1, i&#43;2): for x in range(j-1, j&#43;2): if y == i and x == j: continue if img[y, x] == 255: r.append((y, x)) if len(r) &gt; 0: if len(r) == 1: p.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-01-18T14:30:11+08:00">
    <meta property="article:modified_time" content="2024-01-18T14:30:11+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">opencv python 实现Canny检测后不连续不封闭轮廓的闭合</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>Canny检测后轮廓的闭合在网上看了一些相关文章后总结出有以下方法：</h4> 
<p><strong>1、</strong>使用闭运算等形态学操作来对轮廓进行处理，但作为像素点级别 的形态学操作往往不能满足要求，如：两条轮廓线相距仅为一个像素，在进行闭运算操作时会使这两条轮廓粘连在一起。</p> 
<p><strong>2、</strong>对于规则的图像可通过对不连续的点或线段进行拟合，通过对称的修剪和补缺来处理，但适用的对象非常有限，所以只能特例分析。</p> 
<p><strong>3、</strong>找到图像中不连续轮廓中的端点，通过最近端点间画直线来处理，但这仅仅适用于简单的图像处理，对于一些复杂或者断续太大的轮廓反而效果比较差。</p> 
<p>本章主要讲第三种方法，代码如下：</p> 
<pre><code class="language-python">import cv2
import math
import numpy as np
import timeit


start_time = timeit.default_timer()


def point(img, h, w):
    p = []
    for i in range(h):
        for j in range(w):
            if img[i, j] == 255:
                r = []
                for y in range(i-1, i+2):
                    for x in range(j-1, j+2):
                        if y == i and x == j:
                            continue
                        if img[y, x] == 255:
                            r.append((y, x))
                if len(r) &gt; 0:
                    if len(r) == 1:
                        p.append((i, j))
                    elif len(r) == 2:
                        dy = r[0][0] - r[1][0]
                        dx = r[0][1] - r[1][1]
                        if abs(dy) + abs(dx) == 1:
                            p.append((i, j))
    return p


max_range = 30  # 设置最大的端点连线

img = cv2.imread('dian.jpg')
h, w, c = img.shape[:]
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
img2 = cv2.bilateralFilter(gray, 5, 150, 150)

ven = cv2.Canny(img2, 77, 220)
points = point(ven, h, w)
tu = np.zeros((h, w, c), np.uint8)
tu[ven != 0] = 255
tu1 = tu.copy()
for i, j in points:
    tu[i, j, 0] = 0  #b
    tu[i, j, 1] = 0  #G
    tu[i, j, 2] = 255  # r
cv2.imshow('tu', tu)  # 查看端点

for n, i in enumerate(points):
    points.pop(n)
    distances = [np.linalg.norm(np.array(p) - np.array(i)) for p in points]  # 计算欧几里得距离
    min_index = np.argmin(distances)  # 得到列表中最短距离的索引
    if i != points[min_index] and distances[min_index] &lt;= max_range:
        cv2.line(tu1, tuple((i[1], i[0])), tuple((points[min_index][1], points[min_index][0])), (0, 0, 255), 1)
cv2.imshow('dabo', tu1)

end_time = timeit.default_timer()
print("程序运行时间: ", end_time - start_time, "秒")

cv2.waitKey(0)</code></pre> 
<h3>一、程序分析</h3> 
<p>        在关于图像中端点的定义上，可分为如下情况：</p> 
<p><img alt="" height="235" src="https://images2.imgbox.com/d3/b3/R3ImPig5_o.jpg" width="236"><img alt="" class="left" height="227" src="https://images2.imgbox.com/ca/3a/bK8akYCV_o.jpg" width="228"></p> 
<p><img alt="" height="235" src="https://images2.imgbox.com/55/bb/sy5e8Qmm_o.jpg" width="236"> <img alt="" class="left" height="229" src="https://images2.imgbox.com/c3/9e/J27aP5AB_o.jpg" width="230"></p> 
<p> 上两份对应着程序中len（r）==1的部分，下两份对应着程序中len（r）==2的部分</p> 
<p>该部分程序实现了图像中不连续轮廓端点的寻找</p> 
<pre><code class="language-python">def point(img, h, w):
    p = []
    for i in range(h):
        for j in range(w):
            if img[i, j] == 255:
                r = []
                for y in range(i-1, i+2):
                    for x in range(j-1, j+2):
                        if y == i and x == j:
                            continue
                        if img[y, x] == 255:
                            r.append((y, x))
                if len(r) &gt; 0:
                    if len(r) == 1:
                        p.append((i, j))
                    elif len(r) == 2:
                        dy = r[0][0] - r[1][0]
                        dx = r[0][1] - r[1][1]
                        if abs(dy) + abs(dx) == 1:
                            p.append((i, j))
    return p</code></pre> 
<h3> 二、程序展示</h3> 
<p>        本人通过手动调整了Canny算子的阈值参数，对得到的图像进行端点的寻找后，用红色进行了标出，如下图：</p> 
<p><img alt="" height="600" src="https://images2.imgbox.com/35/cd/xB1HgjBF_o.png" width="799"></p> 
<p>下图即为最终的闭合图像，可通过调整最大画线距离max_range来控制画线</p> 
<p> <img alt="" height="600" src="https://images2.imgbox.com/fa/bc/YxuOSGfD_o.png" width="800"></p> 
<pre><code class="language-python">for n, i in enumerate(points):
    points.pop(n)
    distances = [np.linalg.norm(np.array(p) - np.array(i)) for p in points]  # 计算欧几里得距离
    min_index = np.argmin(distances)  # 得到列表中最短距离的索引
    if i != points[min_index] and distances[min_index] &lt;= max_range:
        cv2.line(tu1, tuple((i[1], i[0])), tuple((points[min_index][1], points[min_index][0])), (0, 0, 255), 1)
cv2.imshow('dabo', tu1)</code></pre> 
<h3>三，结果分析 </h3> 
<p>        可以看到结果是非常不如意的，所以本文章仅提供一个思路，并不能直接的解决一些实际问题，可以通过对端点连线处程序进行改进，使的能够对定性的端点进行连线闭合。</p> 
<p>        如果有更好的办法欢迎各位在评论区留言！</p> 
<p></p> 
<p>参考文章：</p> 
<p><a class="link-info" href="https://blog.csdn.net/wzn0521/article/details/107162856/?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=opencv%20%E4%B8%8D%E8%BF%9E%E7%BB%AD%E8%BD%AE%E5%BB%93%E8%BF%9E%E6%8E%A5&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-107162856.142%5Ev99%5Epc_search_result_base6&amp;spm=1018.2226.3001.4187" title="Python OpenCV 连接不封闭的轮廓">Python OpenCV 连接不封闭的轮廓</a></p> 
<p><a class="link-info" href="https://blog.csdn.net/west_three_boy/article/details/68945760?locationNum=9&amp;fps=1" title="canny边缘检测不连续问题">canny边缘检测不连续问题</a></p> 
<p><a class="link-info" href="https://blog.csdn.net/TDC1942/article/details/124633152?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170554764216800213020578%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=170554764216800213020578&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-6-124633152-null-null.142%5Ev99%5Epc_search_result_base6&amp;utm_term=opencv%20%E4%B8%8D%E8%BF%9E%E7%BB%AD%E8%BD%AE%E5%BB%93%E8%BF%9E%E6%8E%A5&amp;spm=1018.2226.3001.4187" title="opencv 风挡轮廓补全">opencv 风挡轮廓补全</a></p> 
<p><a class="link-info" href="https://blog.csdn.net/wqvbjhc/article/details/6065448" title="图像轮廓缺陷修补">图像轮廓缺陷修补</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/66369188d6d11cf73b17bfe70a1cbf69/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android WLAN 直连（对等连接或 P2P）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dd63923beee1c75a664ef2cf392e7ba5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SQL两表/多表关联查询--JOIN语句</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>