<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>详解高性能中间件Iceoryx在ROS2中的使用 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/38c544d8afa364ca8cef14d5f25a17d2/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="详解高性能中间件Iceoryx在ROS2中的使用">
  <meta property="og:description" content="文章目录 0. 概述1. 系统架构对比1.1 移除 Master 节点1.2 引入 DDS 系统1.3 跨平台支持 2. DDS 系统的引入2.1 RMW 概述2.2 QoS（质量服务策略）2.3 ROS2去中心化节点注册和订阅 3. ROS2安装与配置3.1 一键安装3.2 官网教程 4. [ROS2 底层切换 Iceoryx 官方实现](https://github.com/ros2/rmw_iceoryx/blob/iron/README.md)4.1 安装4.2 使用 rmw_iceoryx_cpp4.3 零拷贝传输 5. 不同负载下的Iceoryx、cycloneDDS和FastDDS延迟对比5.1 进程间延迟5.2 进程内延迟5.3 对比总结 0. 概述 本文将概述ROS2相比ROS中间件的改进和优势，重点推荐Iceoryx
1. 系统架构对比 1.1 移除 Master 节点 ROS1：依赖 roscore 作为 Master 节点，Master 节点崩溃会导致系统无法订阅和发布。ROS2：不再依赖 roscore，避免了 Master 节点崩溃导致的系统风险。 1.2 引入 DDS 系统 ROS1：使用 TCP/UDP 进行通信，存在延迟、数据丢失和无法加密的问题。ROS2：基于 Data Distribution Service（DDS）的通信架构，提高了网络安全性和实时性。 1.3 跨平台支持 ROS1：跨平台支持较弱。ROS2：提供了更好的跨平台兼容性，支持多种操作系统和硬件架构。 2. DDS 系统的引入 2.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-04T22:39:22+08:00">
    <meta property="article:modified_time" content="2024-08-04T22:39:22+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">详解高性能中间件Iceoryx在ROS2中的使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#0__1" rel="nofollow">0. 概述</a></li><li><a href="#1__3" rel="nofollow">1. 系统架构对比</a></li><li><ul><li><a href="#11__Master__7" rel="nofollow">1.1 移除 Master 节点</a></li><li><a href="#12__DDS__12" rel="nofollow">1.2 引入 DDS 系统</a></li><li><a href="#13__17" rel="nofollow">1.3 跨平台支持</a></li></ul> 
  </li><li><a href="#2_DDS__22" rel="nofollow">2. DDS 系统的引入</a></li><li><ul><li><a href="#21_RMW__26" rel="nofollow">2.1 RMW 概述</a></li><li><a href="#22_QoS_34" rel="nofollow">2.2 QoS（质量服务策略）</a></li><li><a href="#23_ROS2_47" rel="nofollow">2.3 ROS2去中心化节点注册和订阅</a></li></ul> 
  </li><li><a href="#3_ROS2_65" rel="nofollow">3. ROS2安装与配置</a></li><li><ul><li><a href="#31__67" rel="nofollow">3.1 一键安装</a></li><li><a href="#32__76" rel="nofollow">3.2 官网教程</a></li></ul> 
  </li><li><a href="#4_ROS2__Iceoryx_httpsgithubcomros2rmw_iceoryxblobironREADMEmd_84" rel="nofollow">4. [ROS2 底层切换 Iceoryx 官方实现](https://github.com/ros2/rmw_iceoryx/blob/iron/README.md)</a></li><li><ul><li><a href="#41__86" rel="nofollow">4.1 安装</a></li><li><a href="#42__rmw_iceoryx_cpp_115" rel="nofollow">4.2 使用 rmw_iceoryx_cpp</a></li><li><a href="#43__137" rel="nofollow">4.3 零拷贝传输</a></li></ul> 
  </li><li><a href="#5_IceoryxcycloneDDSFastDDS_158" rel="nofollow">5. 不同负载下的Iceoryx、cycloneDDS和FastDDS延迟对比</a></li><li><ul><li><a href="#51__161" rel="nofollow">5.1 进程间延迟</a></li><li><a href="#52__184" rel="nofollow">5.2 进程内延迟</a></li><li><a href="#53__206" rel="nofollow">5.3 对比总结</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="0__1"></a>0. 概述</h2> 
<p>本文将概述ROS2相比ROS中间件的改进和优势，重点推荐Iceoryx</p> 
<h2><a id="1__3"></a>1. 系统架构对比</h2> 
<p><img src="https://images2.imgbox.com/34/13/nkgPMal5_o.png" alt="系统架构对比图"></p> 
<h3><a id="11__Master__7"></a>1.1 移除 Master 节点</h3> 
<ul><li><strong>ROS1</strong>：依赖 roscore 作为 Master 节点，Master 节点崩溃会导致系统无法订阅和发布。</li><li><strong>ROS2</strong>：不再依赖 roscore，避免了 Master 节点崩溃导致的系统风险。</li></ul> 
<h3><a id="12__DDS__12"></a>1.2 引入 DDS 系统</h3> 
<ul><li><strong>ROS1</strong>：使用 TCP/UDP 进行通信，存在延迟、数据丢失和无法加密的问题。</li><li><strong>ROS2</strong>：基于 Data Distribution Service（DDS）的通信架构，提高了网络安全性和实时性。</li></ul> 
<h3><a id="13__17"></a>1.3 跨平台支持</h3> 
<ul><li><strong>ROS1</strong>：跨平台支持较弱。</li><li><strong>ROS2</strong>：提供了更好的跨平台兼容性，支持多种操作系统和硬件架构。</li></ul> 
<h2><a id="2_DDS__22"></a>2. DDS 系统的引入</h2> 
<p><img src="https://images2.imgbox.com/e3/a6/nB0P4etP_o.png" alt="DDS 系统图"></p> 
<h3><a id="21_RMW__26"></a>2.1 RMW 概述</h3> 
<p>不同厂商可以根据需要实现不同的 DDS 系统，如 OpenSplice 和 FastRTPS。为了统一不同 DDS 厂商的接口，ROS2 设计了 ROS Middleware（RMW）接口，使得各 DDS 厂商能够编写适配接口，将自家 DDS 系统移植到 ROS2 中。</p> 
<p>ROS2 的核心概念与 ROS1 基本类似，但在架构上进行了优化，提供了更好的性能和灵活性。RMW 是构建 ROS 所需的原始中间件最小功能集，包括 Initialization and Shutdown、Nodes、Publisher、Subscription、Service Client、Service Server 等功能。</p> 
<p><img src="https://images2.imgbox.com/b1/5e/WkStFvz6_o.png" alt="核心概念图"></p> 
<h3><a id="22_QoS_34"></a>2.2 QoS（质量服务策略）</h3> 
<p>在开发过程中，需要关注 DDS 的 QoS 特性，它可以通过指定所需的网络传输质量来满足通信需求。</p> 
<pre><code class="prism language-bash">ros2 topic <span class="token builtin class-name">echo</span> /example_topic --qos-reliability reliable
</code></pre> 
<p>切换不同的 DDS 系统只需安装相应的包，并通过设置环境变量即可：</p> 
<pre><code class="prism language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">RMW_IMPLEMENTATION</span><span class="token operator">=</span>rmw_fastrtps_cpp
</code></pre> 
<h3><a id="23_ROS2_47"></a>2.3 ROS2去中心化节点注册和订阅</h3> 
<p>在ROS 2中，注册和订阅的机制是由节点自身以及底层的通信中间件（如Fast-RTPS)共同负责的。以下步骤描述了注册和订阅的过程：</p> 
<ul><li> <p><strong>节点启动</strong>：当一个ROS2节点启动时，它会初始化并与底层通信中间件建立连接。这个过程包括创建节点上下文、设置QoS（Quality of Service）策略等。</p> </li><li> <p><strong>创建发布者和订阅者</strong>：节点通过调用ROS2 API创建发布者和订阅者。发布者用于向特定的话题发送消息，而订阅者则用于接收特定话题的消息。</p> </li><li> <p><strong>发布者和订阅者的注册</strong>：</p> 
  <ul><li>当节点创建发布者时，它会向通信中间件注册这个发布者，表明它将在这个话题上发布消息。</li><li>当节点创建订阅者时，它同样会向通信中间件注册，声明它对某个话题感兴趣并希望接收相关消息。</li></ul> </li><li> <p><strong>发现机制</strong>：通信中间件负责维护一个关于网络上所有活动节点、话题、服务和动作的动态目录。当节点注册了发布者或订阅者后，通信中间件会广播这些信息，以便其他节点能够发现它们。</p> </li><li> <p><strong>匹配过程</strong>：一旦一个订阅者注册，通信中间件会查找与之匹配的发布者。匹配基于话题名称和消息类型，以及任何附加的QoS策略。如果找到匹配项，中间件将建立一个直接的连接，允许发布者和订阅者之间直接通信，而无需通过中心节点。</p> </li><li> <p><strong>通信</strong>：匹配成功后，发布者和订阅者之间可以直接交换数据。发布者发送消息，而订阅者接收消息。这一过程是去中心化的，意味着数据流经由直接的点对点连接，提高了效率和可靠性。</p> </li></ul> 
<p>ROS2的这种设计允许节点在不需要中心协调的情况下自主发现和通信，这极大地增强了系统的灵活性、可扩展性和鲁棒性。同时，DDS的QoS机制允许用户根据应用需求调整消息的传输特性，比如可靠性、持久性、历史记录等，从而满足不同的实时性和数据完整性要求。</p> 
<h2><a id="3_ROS2_65"></a>3. ROS2安装与配置</h2> 
<h3><a id="31__67"></a>3.1 一键安装</h3> 
<p>提供简易的一键安装脚本，支持多个版本的 ROS2 安装。</p> 
<pre><code class="prism language-sh"><span class="token function">wget</span> http://fishros.com/install <span class="token parameter variable">-O</span> fishros <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">.</span> fishros
<span class="token comment"># 支持 noetic(ROS1), foxy(ROS2), galactic(ROS2), rolling(ROS2), iron(ROS2), humble(ROS2)</span>
</code></pre> 
<h3><a id="32__76"></a>3.2 官网教程</h3> 
<p>链接到 ROS2 的官方安装教程，为用户提供详细的安装指导。</p> 
<pre><code>https://docs.ros.org/
</code></pre> 
<h2><a id="4_ROS2__Iceoryx_httpsgithubcomros2rmw_iceoryxblobironREADMEmd_84"></a>4. <a href="https://github.com/ros2/rmw_iceoryx/blob/iron/README.md">ROS2 底层切换 Iceoryx 官方实现</a></h2> 
<h3><a id="41__86"></a>4.1 安装</h3> 
<p>以下步骤展示了如何安装 Iceoryx 的 RMW 实现。安装 <code>rmw_iceoryx</code> 非常简单，因为 Iceoryx 已包含在 <a href="https://github.com/ros2/ros2/blob/master/ros2.repos">ros2.repos</a> 中。所有提供的包都可以使用 colcon 构建，因此你可以轻松地在 ROS 2 工作区内构建 <code>rmw_iceoryx</code>。<code>rmw_iceoryx</code> 使用 <a href="https://github.com/ros2/rosidl">rosidl_typesupport_introspection</a>，这允许在现有的 ROS 2 工作区或 Debian 安装基础上构建 iceoryx，因为不需要再次构建 ROS 2 消息。</p> 
<p>要在最新的 ROS 版本的 ROS 2 工作区中安装 <code>rmw_iceoryx</code>，请执行以下步骤：</p> 
<pre><code class="prism language-bash"><span class="token function">mkdir</span> <span class="token parameter variable">-p</span> ~/iceoryx_ws/src
<span class="token builtin class-name">cd</span> <span class="token variable">$_</span>
<span class="token comment"># LATEST_ROS_VERSION 可以是例如 iron</span>
<span class="token function">git</span> clone <span class="token parameter variable">--branch</span> LATEST_ROS_VERSION https://github.com/ros2/rmw_iceoryx.git
</code></pre> 
<p>有关替代安装说明和 iceoryx 内部详细信息，请参阅 <a href="https://github.com/eclipse/iceoryx">iceoryx 的 GitHub 仓库</a>。</p> 
<p><code>rmw_iceoryx</code> 与 ROS 2 从 Eloquent 版本开始兼容。假设你已正确安装 ROS 2，可以使用 colcon 编译 iceoryx 工作区：</p> 
<pre><code class="prism language-bash"><span class="token builtin class-name">cd</span> ~/iceoryx_ws/
<span class="token builtin class-name">source</span> /opt/ros/LATEST_ROS_VERSION/setup.bash  <span class="token comment"># 或者 source 你自己的 ROS 2 工作区</span>
rosdep update
rosdep <span class="token function">install</span> --from-paths src --ignore-src <span class="token parameter variable">--rosdistro</span> LATEST_ROS_VERSION <span class="token parameter variable">-y</span>
colcon build
<span class="token comment"># 或者使用更多选项</span>
colcon build --symlink-install --cmake-args <span class="token parameter variable">-DCMAKE_BUILD_TYPE</span><span class="token operator">=</span>Release <span class="token parameter variable">-DBUILD_TESTING</span><span class="token operator">=</span>OFF
</code></pre> 
<p>就是这样！你已经安装了 iceoryx，现在可以开始使用了。</p> 
<h3><a id="42__rmw_iceoryx_cpp_115"></a>4.2 使用 rmw_iceoryx_cpp</h3> 
<p>Iceoryx 基于共享内存，并具有一个名为 RouDi 的共享内存管理应用。启动守护进程：</p> 
<pre><code class="prism language-bash">./iceoryx_ws/install/iceoryx_posh/bin/iox-roudi
</code></pre> 
<p>然后指定 RMW 实现并运行 ROS 2 示例节点：</p> 
<pre><code class="prism language-bash"><span class="token builtin class-name">source</span> ~/iceoryx_ws/install/setup.bash
<span class="token assign-left variable">RMW_IMPLEMENTATION</span><span class="token operator">=</span>rmw_iceoryx_cpp ros2 run demo_nodes_cpp talker
</code></pre> 
<p>在另一个终端中订阅 <code>talker</code>：</p> 
<pre><code class="prism language-bash"><span class="token builtin class-name">source</span> ~/iceoryx_ws/install/setup.bash
<span class="token assign-left variable">RMW_IMPLEMENTATION</span><span class="token operator">=</span>rmw_iceoryx_cpp ros2 run demo_nodes_cpp listener
</code></pre> 
<h3><a id="43__137"></a>4.3 零拷贝传输</h3> 
<p>基本的零拷贝工作流程如下：</p> 
<p><img src="https://images2.imgbox.com/4c/4a/yWl2uyS6_o.png" alt="在这里插入图片描述"></p> 
<ol><li><code>loan_message()</code>：发布者请求借用一条消息。</li><li><code>publish()</code>：发布者填写数据并发布消息。</li><li><code>take_loaned_message()</code>：订阅者获取消息。</li><li><code>return_loaned_message()</code>：订阅者回调完成后，消息返回中间件。</li></ol> 
<p>示例代码：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">auto</span> pod_pub_ <span class="token operator">=</span> node<span class="token operator">-&gt;</span><span class="token generic-function"><span class="token function">create_publisher</span><span class="token generic class-name"><span class="token operator">&lt;</span>std_msgs<span class="token double-colon punctuation">::</span>msg<span class="token double-colon punctuation">::</span>Float64<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">"/float"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> pod_loaned_msg <span class="token operator">=</span> pod_pub_<span class="token operator">-&gt;</span><span class="token function">borrow_loaned_message</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
pod_loaned_msg<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token number">123.456f</span><span class="token punctuation">;</span>
pod_pub_<span class="token operator">-&gt;</span><span class="token function">publish</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>pod_loaned_msg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/24/8f/Lb2fcTaK_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="5_IceoryxcycloneDDSFastDDS_158"></a>5. 不同负载下的Iceoryx、cycloneDDS和FastDDS延迟对比</h2> 
<p>该对比数据展示了三种中间件解决方案（<strong>Iceoryx</strong>、<strong>cycloneDDS</strong>和<strong>FastDDS</strong>）的延迟性能。延迟单位为微秒（us），测试负载范围从1KB到64MB。</p> 
<h3><a id="51__161"></a>5.1 进程间延迟</h3> 
<table><thead><tr><th>负载</th><th><strong>Iceoryx</strong></th><th><strong>cycloneDDS</strong></th><th><strong>FastDDS</strong></th></tr></thead><tbody><tr><td>1KB</td><td>2.4</td><td>7.35</td><td>3.95</td></tr><tr><td>2KB</td><td>2.4</td><td>7.88</td><td>3.85</td></tr><tr><td>4KB</td><td>2.4</td><td>7.41</td><td>3.98</td></tr><tr><td>8KB</td><td>2.4</td><td>9.47</td><td>4.42</td></tr><tr><td>16KB</td><td>2.4</td><td>11.97</td><td>5.22</td></tr><tr><td>32KB</td><td>2.4</td><td>14.40</td><td>6.35</td></tr><tr><td>64KB</td><td>2.4</td><td>20.86</td><td>8.72</td></tr><tr><td>128KB</td><td>2.4</td><td>39.29</td><td>10.11</td></tr><tr><td>256KB</td><td>2.4</td><td>77.90</td><td>23.06</td></tr><tr><td>512KB</td><td>2.4</td><td>238.35</td><td>44.66</td></tr><tr><td>1MB</td><td>2.4</td><td>836.64</td><td>89.74</td></tr><tr><td>2MB</td><td>2.4</td><td>984.68</td><td>264.61</td></tr><tr><td>4MB</td><td>2.4</td><td>2809.75</td><td>526.03</td></tr><tr><td>8MB</td><td>NA</td><td>4874.37</td><td>1895.88</td></tr><tr><td>16MB</td><td>NA</td><td>8881.51</td><td>5112.93</td></tr><tr><td>32MB</td><td>NA</td><td>55535.95</td><td>11998.55</td></tr><tr><td>64MB</td><td>NA</td><td>120856.58</td><td>43563.32</td></tr></tbody></table> 
<h3><a id="52__184"></a>5.2 进程内延迟</h3> 
<table><thead><tr><th>负载</th><th><strong>Iceoryx</strong></th><th><strong>cycloneDDS</strong></th><th><strong>FastDDS</strong></th></tr></thead><tbody><tr><td>1KB</td><td>1.5</td><td>-</td><td>1.22</td></tr><tr><td>2KB</td><td>1.5</td><td>-</td><td>1.73</td></tr><tr><td>4KB</td><td>1.5</td><td>-</td><td>1.82</td></tr><tr><td>8KB</td><td>1.5</td><td>-</td><td>1.94</td></tr><tr><td>16KB</td><td>1.5</td><td>-</td><td>2.34</td></tr><tr><td>32KB</td><td>1.5</td><td>-</td><td>3.39</td></tr><tr><td>64KB</td><td>1.5</td><td>-</td><td>4.45</td></tr><tr><td>128KB</td><td>1.5</td><td>-</td><td>8.26</td></tr><tr><td>256KB</td><td>1.5</td><td>-</td><td>23.09</td></tr><tr><td>512KB</td><td>1.5</td><td>-</td><td>48.59</td></tr><tr><td>1MB</td><td>1.5</td><td>-</td><td>103.26</td></tr><tr><td>2MB</td><td>1.5</td><td>-</td><td>360.16</td></tr><tr><td>4MB</td><td>1.5</td><td>-</td><td>687.45</td></tr><tr><td>8MB</td><td>NA</td><td>-</td><td>1189.07</td></tr><tr><td>16MB</td><td>NA</td><td>-</td><td>1951.29</td></tr><tr><td>32MB</td><td>NA</td><td>-</td><td>3874.46</td></tr><tr><td>64MB</td><td>NA</td><td>-</td><td>7967.83</td></tr></tbody></table> 
<h3><a id="53__206"></a>5.3 对比总结</h3> 
<ul><li><strong>Iceoryx</strong>在处理不同负载的进程间通信时，始终保持在2.4微秒的低稳定延迟，这显示了其在处理各种负载时的高效性。在进程内通信方面，其延迟更低，仅为1.5微秒。</li><li><strong>cycloneDDS</strong>随着负载的增加，延迟逐渐增加，特别是在512KB以上，延迟显著增加，在64MB负载时达到120856.58微秒。</li><li><strong>FastDDS</strong>的延迟性能优于cycloneDDS，但仍高于Iceoryx，负载增大时，特别是在4MB以上，延迟显著增加。</li></ul> 
<p>综上所述，Iceoryx在小到中等负载的进程间和进程内通信中表现最为高效。而cycloneDDS和FastDDS虽然具有一定的处理能力，但在大数据传输时存在延迟瓶颈。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/382f0e5b05d67ca236d586c6ceda50e0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Web APIs】JavaScript 操作元素 ⑦ ( 多精灵图背景设置 | 核心要点 - 设置 backgroundPosition 属性 | 清除默认样式 | )</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/778cb5c5b5e7656dbff9fddaa55e2ff8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【MySQL进阶篇】管理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>