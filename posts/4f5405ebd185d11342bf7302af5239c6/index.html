<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;【STL】改造红黑树简单模拟实现set map（带你了解set map的底层实现结构） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/4f5405ebd185d11342bf7302af5239c6/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C&#43;&#43;【STL】改造红黑树简单模拟实现set map（带你了解set map的底层实现结构）">
  <meta property="og:description" content="目录
一、学前铺垫（泛型编程）
二、改造红黑树
1.红黑树节点的改造
2.insert的改造
3.迭代器的实现
4.完整改造代码
三、set的模拟实现封装
四、map的模拟实现封装
五、完结撒❀
前言：
下面为了简单模拟实现set map所出现的代码是以C&#43;&#43;中STL源码库中的代码逻辑基础进行的简化代码，本片博客目的是带你简单深入底层，了解set map底层的实现逻辑，对泛型编程有更加深刻的认识。
一、学前铺垫（泛型编程） 本篇博客我们通过对一个红黑树进行改造，使其可以让set和map的模拟实现都使用这一个红黑树结构，因为set map所存储的数据类型不一样,set底层存储的是pair&lt;key,key&gt;,map底层存储的是pair&lt;key,value&gt;,所以这里就一定会用上多个模板对红黑树进行改造，形成泛型编程，之后再对set map使用改造后的红黑树进行封装，达到模拟STL库中set map的效果。（有能力的可以直接去看STL中set map所实现的源码，逻辑与我所讲述的相同）
二、改造红黑树 1.红黑树节点的改造 这里节点的构造基本与二叉搜索树的节点构造相同，但是因为要同时兼顾set map两中类型，所以存储数据的类型不可以写死，要用到模板，节点代码如下：
template &lt;class T&gt; struct RBTreeNode { RBTreeNode&lt;T&gt;* _left; RBTreeNode&lt;T&gt;* _right; RBTreeNode&lt;T&gt;* _parent; Color _col; T _data; RBTreeNode(const T&amp; data) :_left(nullptr) , _right(nullptr) , _parent(nullptr) , _data(data) , _col(RED) {} }; 2.insert的改造 需要改造的地方：
1) 根据STL库中的set和map的insert的功能，插入成功返回插入位置所在的迭代器以及true，插入失败说明树中已存在改值，返回该值所在的位置的迭代器以及false，所以返回类型应为pair&lt;iterator,bool&gt;，所以返回类型需要进行改造。
2) 在insert中大小值的比较，因为要兼容set和map，而在set中的模板类型只需要一个就可以进行初始化，因为set中底层数据类型是一样的，而map不同，map底层类型其实是pair&lt;key,pair&lt;key,value&gt;&gt;实现，因为在实现find函数时需要用到key的值并且与set保持一致，所以将value类型定义为pair&lt;key,value&gt;，那么在后续的比较大小中就不能那么随意了，因为set直接拿其节点指向的_data进行比较即可，而map中的_data为pair&lt;key,pair&lt;key,value&gt;&gt;,不可以直接拿来进行比较,所以我们将代码进行改造。
下面是模拟实现set，map的简单封装。SetKeyOFT，MapKeyOFT就是解决大小比较所定义的内部类。
Mymap.h:
template &lt;class K,class V&gt; class map { public: struct MapKeyOFT { const K&amp; operator()(const pair&lt;K, V&gt;&amp; kv) { return kv.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-09T17:39:03+08:00">
    <meta property="article:modified_time" content="2024-06-09T17:39:03+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;【STL】改造红黑树简单模拟实现set map（带你了解set map的底层实现结构）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E5%AD%A6%E5%89%8D%E9%93%BA%E5%9E%AB%EF%BC%88%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%89-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%AD%A6%E5%89%8D%E9%93%BA%E5%9E%AB%EF%BC%88%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%89" rel="nofollow">一、学前铺垫（泛型编程）</a></p> 
<p id="%E4%BA%8C%E3%80%81%E6%94%B9%E9%80%A0%E7%BA%A2%E9%BB%91%E6%A0%91-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E6%94%B9%E9%80%A0%E7%BA%A2%E9%BB%91%E6%A0%91" rel="nofollow">二、改造红黑树</a></p> 
<p id="1.%E7%BA%A2%E9%BB%91%E6%A0%91%E8%8A%82%E7%82%B9%E7%9A%84%E6%94%B9%E9%80%A0-toc" style="margin-left:40px;"><a href="#1.%E7%BA%A2%E9%BB%91%E6%A0%91%E8%8A%82%E7%82%B9%E7%9A%84%E6%94%B9%E9%80%A0" rel="nofollow">1.红黑树节点的改造</a></p> 
<p id="2.insert%E7%9A%84%E6%94%B9%E9%80%A0-toc" style="margin-left:40px;"><a href="#2.insert%E7%9A%84%E6%94%B9%E9%80%A0" rel="nofollow">2.insert的改造</a></p> 
<p id="3.%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#3.%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">3.迭代器的实现</a></p> 
<p id="4.%E5%AE%8C%E6%95%B4%E6%94%B9%E9%80%A0%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#4.%E5%AE%8C%E6%95%B4%E6%94%B9%E9%80%A0%E4%BB%A3%E7%A0%81" rel="nofollow">4.完整改造代码</a></p> 
<p id="%E4%B8%89%E3%80%81set%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E5%B0%81%E8%A3%85-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81set%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E5%B0%81%E8%A3%85" rel="nofollow">三、set的模拟实现封装</a></p> 
<p id="%E5%9B%9B%E3%80%81map%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E5%B0%81%E8%A3%85-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81map%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E5%B0%81%E8%A3%85" rel="nofollow">四、map的模拟实现封装</a></p> 
<p id="%E4%BA%94%E3%80%81%E5%AE%8C%E7%BB%93%E6%92%92%E2%9D%80-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E5%AE%8C%E7%BB%93%E6%92%92%E2%9D%80" rel="nofollow">五、完结撒❀</a></p> 
<p>前言：</p> 
<p>下面为了简单模拟实现set map所出现的代码是以C++中STL源码库中的代码逻辑基础进行的简化代码，本片博客目的是带你简单深入底层，了解set map底层的实现逻辑，对泛型编程有更加深刻的认识。</p> 
<hr id="hr-toc"> 
<h2>一、学前铺垫（泛型编程）</h2> 
<blockquote> 
 <p>本篇博客我们通过对一个红黑树进行改造，使其可以让set和map的模拟实现都使用这一个红黑树结构，因为set map所存储的数据类型不一样,set底层存储的是pair&lt;key,key&gt;,map底层存储的是pair&lt;key,value&gt;,所以这里就一定会用上多个模板对红黑树进行改造，形成泛型编程，之后再对set map使用改造后的红黑树进行封装，达到模拟STL库中set map的效果。（有能力的可以直接去看STL中set map所实现的源码，逻辑与我所讲述的相同）</p> 
</blockquote> 
<h2 id="%E4%BA%8C%E3%80%81%E6%94%B9%E9%80%A0%E7%BA%A2%E9%BB%91%E6%A0%91">二、改造红黑树</h2> 
<h3 id="1.%E7%BA%A2%E9%BB%91%E6%A0%91%E8%8A%82%E7%82%B9%E7%9A%84%E6%94%B9%E9%80%A0">1.红黑树节点的改造</h3> 
<p>这里节点的构造基本与二叉搜索树的节点构造相同，但是因为要同时兼顾set map两中类型，所以存储数据的类型不可以写死，要用到模板，节点代码如下：</p> 
<pre><code class="language-cpp">template &lt;class T&gt;
struct RBTreeNode
{
	RBTreeNode&lt;T&gt;* _left;
	RBTreeNode&lt;T&gt;* _right;
	RBTreeNode&lt;T&gt;* _parent;

	Color _col;
	T _data;

	RBTreeNode(const T&amp; data)
		:_left(nullptr)
		, _right(nullptr)
		, _parent(nullptr)
		, _data(data)
		, _col(RED)
	{}
};</code></pre> 
<h3 id="2.insert%E7%9A%84%E6%94%B9%E9%80%A0">2.insert的改造</h3> 
<p>需要改造的地方：</p> 
<blockquote> 
 <p>1) 根据STL库中的set和map的insert的功能，插入成功返回插入位置所在的迭代器以及true，插入失败说明树中已存在改值，返回该值所在的位置的迭代器以及false，所以返回类型应为pair&lt;iterator,bool&gt;，所以返回类型需要进行改造。</p> 
</blockquote> 
<blockquote> 
 <p>2) 在insert中大小值的比较，因为要兼容set和map，而在set中的模板类型只需要一个就可以进行初始化，因为set中底层数据类型是一样的，而map不同，map底层类型其实是pair&lt;key,pair&lt;key,value&gt;&gt;实现，因为在实现find函数时需要用到key的值并且与set保持一致，所以将value类型定义为pair&lt;key,value&gt;，那么在后续的比较大小中就不能那么随意了，因为set直接拿其节点指向的_data进行比较即可，而map中的_data为pair&lt;key,pair&lt;key,value&gt;&gt;,不可以直接拿来进行比较,所以我们将代码进行改造。</p> 
</blockquote> 
<p>下面是模拟实现set，map的简单封装。SetKeyOFT，MapKeyOFT就是解决大小比较所定义的内部类。<br> Mymap.h:</p> 
<pre><code class="language-cpp">template &lt;class K,class V&gt;
class map
{
public:

	struct MapKeyOFT
	{
		const K&amp; operator()(const pair&lt;K, V&gt;&amp; kv)
		{
			return kv.first;
		}
	};
private:
	RBTree&lt;K, pair&lt;K,V&gt;, MapKeyOFT&gt; _t;
};</code></pre> 
<p>Myset.h:</p> 
<pre><code class="language-cpp">template &lt;class K&gt;
class set
{
public:
	struct SetKeyOFT
	{
		const K&amp; operator()(const K&amp; key)
		{
			return key;
		}
	};
private:
	RBTree&lt;K,K, SetKeyOFT&gt; _t;
};</code></pre> 
<p>insert函数改造实现：</p> 
<pre><code class="language-cpp">	pair&lt;iterator,bool&gt; Insert(const T&amp; data)
	{
		//二叉树为空，插入第一个值
		if (_root == nullptr)
		{
			_root = new Node(data);
			_root-&gt;_col = BLACK;
			return make_pair(iterator(_root),true);
		}

		KeyOfT kot;
		//后续插入
		Node* parent = nullptr;
		Node* cur = _root;
		while (cur)
		{
			if (kot(cur-&gt;_data) &gt; kot(data))
			{
				parent = cur;
				cur = cur-&gt;_left;
			}
			else if (kot(cur-&gt;_data) &lt; kot(data))
			{
				parent = cur;
				cur = cur-&gt;_right;
			}
			else
			{
				//不允许冗余
				return make_pair(iterator(cur),false);
			}
		}

		//找到对应位置
		cur = new Node(data);
		cur-&gt;_parent = parent;
		
		Node* newcur = cur;

		if (kot(parent-&gt;_data) &gt; kot(data))
		{
			parent-&gt;_left = cur;
		}
		else
		{
			parent-&gt;_right = cur;
		}

		//父亲的颜色是黑色也就结束
		while (parent &amp;&amp; parent-&gt;_col == RED)//红黑树出现错误需要改正
		{
			Node* grandfather = parent-&gt;_parent;
			if (grandfather-&gt;_left == parent)
			{
				//舅子树在右边
				Node* uncle = grandfather-&gt;_right;
				if (uncle &amp;&amp; uncle-&gt;_col == RED)
				{
					//存在且颜色为红
					parent-&gt;_col = BLACK;
					uncle-&gt;_col = BLACK;
					/*if (grandfather == _root)
					{
						grandfather-&gt;_col = BLACK;
					}
					else
					{
						grandfather-&gt;_col = RED;
					}*/

					grandfather-&gt;_col = RED;

					cur = grandfather;
					parent = grandfather-&gt;_parent;
				}
				else
				{
					//舅子树不存在或颜色为黑
					if (parent-&gt;_left == cur)
					{
						//单旋
						parent-&gt;_col = BLACK;
						grandfather-&gt;_col = RED;
						RNode(grandfather);
					}
					else
					{
						//双旋 先左再右
						LNode(parent);
						cur-&gt;_col = BLACK;
						grandfather-&gt;_col = RED;
						RNode(grandfather);
					}
					break;
				}
			}
			else
			{
				//舅子树在左边
				Node* uncle = grandfather-&gt;_left;
				if (uncle &amp;&amp; uncle-&gt;_col == RED)
				{
					parent-&gt;_col = BLACK;
					uncle-&gt;_col = BLACK;
					grandfather-&gt;_col = RED;

					cur = grandfather;
					parent = grandfather-&gt;_parent;
				}
				else
				{
					if (parent-&gt;_right == cur)
					{
						//单旋
						parent-&gt;_col = BLACK;
						grandfather-&gt;_col = RED;
						LNode(grandfather);
					}
					else
					{
						//双旋
						RNode(parent);
						LNode(grandfather);
						grandfather-&gt;_col = RED;
						cur-&gt;_col = BLACK;
					}
					break;
				}
			}
		}

		_root-&gt;_col = BLACK;

		return make_pair(iterator(newcur),true);
	}</code></pre> 
<p>因为只在红黑树insert函数里面使用的都是模板，所以是不知道所传数据的具体类型，但是在模拟实现的set，map中知道其对应的类型，所以我们可以在set，map类里面定义一个类，在这个类里面定义一个仿函数用于提取所对应比较大小的值，再将这个类用模板参数传递给红黑树中，在需要比较大小时提前用这个类定义一个变量，在通过仿函数进行大小的比较，这样就可以实现set，map的兼容。</p> 
<h3 id="3.%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0">3.迭代器的实现</h3> 
<div> 
 <span style="color:#777777;">迭代器的好处是可以方便遍历，是数据结构的底层实现与用户透明。如果想要给红黑树增加迭代 </span> 
</div> 
<div> 
 <span style="color:#777777;">器，需要考虑以前问题：</span> 
</div> 
<div></div> 
<div> 
 <span style="color:#777777;"><strong>● begin()</strong></span> 
 <span style="color:#777777;"><strong>与</strong></span> 
 <span style="color:#777777;"><strong>end() </strong></span> 
</div> 
<div></div> 
<blockquote> 
 <div> 
  <span style="color:#777777;">STL</span> 
  <span style="color:#777777;">明确规定，</span> 
  <span style="color:#777777;">begin()</span> 
  <span style="color:#777777;">与</span> 
  <span style="color:#777777;">end()</span> 
  <span style="color:#777777;">代表的是一段前闭后开的区间，而对红黑树进行中序遍历后， </span> 
 </div> 
 <div> 
  <span style="color:#777777;">可以得到一个有序的序列，因此：</span> 
  <span style="color:#777777;"><strong>begin()</strong></span> 
  <span style="color:#777777;"><strong>可以放在红黑树中最小节点</strong></span> 
  <span style="color:#777777;"><strong>(</strong></span> 
  <span style="color:#777777;"><strong>即最左侧节点</strong></span> 
  <span style="color:#777777;"><strong>)</strong></span> 
  <span style="color:#777777;"><strong>的位 </strong></span> 
 </div> 
 <div> 
  <span style="color:#777777;"><strong>置</strong></span> 
  <span style="color:#777777;">，</span> 
  <span style="color:#777777;"><strong>end()</strong></span> 
  <span style="color:#777777;"><strong>放在最大节点</strong></span> 
  <span style="color:#777777;"><strong>(</strong></span> 
  <span style="color:#777777;"><strong>最右侧节点</strong></span> 
  <span style="color:#777777;"><strong>)</strong></span> 
  <span style="color:#777777;"><strong>的下一个位置</strong></span> 
  <span style="color:#777777;">，关键是最大节点的下一个位置在哪块？ </span> 
 </div> 
 <div> 
  <span style="color:#777777;">能否给成</span> 
  <span style="color:#777777;">nullptr</span> 
  <span style="color:#777777;">呢？答案是行不通的，因为</span> 
  <span style="color:#777777;"><strong>对</strong></span> 
  <span style="color:#777777;"><strong>end()</strong></span> 
  <span style="color:#777777;"><strong>位置的迭代器进行</strong></span> 
  <span style="color:#777777;"><strong>--</strong></span> 
  <span style="color:#777777;"><strong>操作，必须要能找最 </strong></span> 
 </div> 
 <div> 
  <span style="color:#777777;"><strong>后一个元素</strong></span> 
  <span style="color:#777777;">，此处就不行，因此最好的方式是</span> 
  <span style="color:#777777;"><strong>将</strong></span> 
  <span style="color:#777777;"><strong>end()</strong></span> 
  <span style="color:#777777;"><strong>放在头结点的位置</strong></span> 
  <span style="color:#777777;">： </span> 
 </div> 
</blockquote> 
<p><img alt="" height="349" src="https://images2.imgbox.com/cd/e9/oS4l8uoR_o.png" width="525"></p> 
<p>● <span style="color:#777777;"><strong>operator++()</strong></span><span style="color:#777777;"><strong>与</strong></span><span style="color:#777777;"><strong>operator--()</strong></span></p> 
<pre><code class="language-cpp">// 找迭代器的下一个节点，下一个节点肯定比其大
void Increasement()
{
	//分两种情况讨论:_pNode的右子树存在和不存在
	// 右子树存在
	if (_pNode-&gt;_pRight)
	{
		// 右子树中最小的节点，即右子树中最左侧节点
		_pNode = _pNode-&gt;_pRight;
		while (_pNode-&gt;_pLeft)
			_pNode = _pNode-&gt;_pLeft;
	}
	else
	{
		// 右子树不存在，向上查找，直到_pNode != pParent-&gt;right
		PNode pParent = _pNode-&gt;_pParent;
		while (pParent-&gt;_pRight == _pNode)
		{
			_pNode = pParent;
			pParent = _pNode-&gt;_pParent;
		}
		// 特殊情况：根节点没有右子树
		if (_pNode-&gt;_pRight != pParent)
			_pNode = pParent;
	}
}
// 获取迭代器指向节点的前一个节点
void Decreasement()
{
	//分三种情况讨论：_pNode 在head的位置，_pNode 左子树存在，_pNode 左子树不
	存在
		// 1. _pNode 在head的位置，--应该将_pNode放在红黑树中最大节点的位置
		if (_pNode-&gt;_pParent-&gt;_pParent == _pNode &amp;&amp; _pNode-&gt;_color == RED)
			_pNode = _pNode-&gt;_pRight;
		else if (_pNode-&gt;_pLeft)
		{
			// 2. _pNode的左子树存在,在左子树中找最大的节点，即左子树中最右侧节点
			_pNode = _pNode-&gt;_pLeft;
			while (_pNode-&gt;_pRight)
				_pNode = _pNode-&gt;_pRight;
		}
		else
		{
			// _pNode的左子树不存在，只能向上找
			PNode pParent = _pNode-&gt;_pParent;
			while (_pNode == pParent-&gt;_pLeft)
			{
				_pNode = pParent;
				pParent = _pNode-&gt;_pParent;
			}
			_pNode = pParent;
		}
}</code></pre> 
<h2 id="4.%E5%AE%8C%E6%95%B4%E6%94%B9%E9%80%A0%E4%BB%A3%E7%A0%81">4.完整改造代码</h2> 
<pre><code class="language-cpp">#pragma once
#include &lt;iostream&gt;
using namespace::std;

enum Color
{
	RED,//(0)
	BLACK//(1)
};

template &lt;class T&gt;
struct RBTreeNode
{
	RBTreeNode&lt;T&gt;* _left;
	RBTreeNode&lt;T&gt;* _right;
	RBTreeNode&lt;T&gt;* _parent;

	Color _col;
	T _data;

	RBTreeNode(const T&amp; data)
		:_left(nullptr)
		, _right(nullptr)
		, _parent(nullptr)
		, _data(data)
		, _col(RED)
	{}
};

template &lt;class T,class Ref,class Ptr&gt;
struct __RBTreeIterator
{
	typedef RBTreeNode&lt;T&gt; Node;
	typedef __RBTreeIterator&lt;T, Ref, Ptr&gt; Self;

	Node* _node;

	__RBTreeIterator(Node* node)
		:_node(node)
	{}

	Ref operator*()
	{
		return _node-&gt;_data;
	}

	Ptr operator-&gt;()
	{
		return &amp;_node-&gt;_data;
	}

	bool operator!=(const Self&amp; s)
	{
		return _node != s._node;
	}

	Self&amp; operator--()
	{
		if (_node-&gt;_left)
		{
			//存在左子树
			Node* cur = _node-&gt;_left;
			while (cur-&gt;_right)
			{
				cur = cur-&gt;_right;
			}
			_node = cur;
		}
		else
		{
			//不存在左子树
			Node* parent = _node-&gt;_parent;
			if (parent &amp;&amp; parent-&gt;_left == _node)
			{
				//为父亲的左孩子
				while (parent &amp;&amp; parent-&gt;_left == _node)
				{
					_node = parent;
					parent = parent-&gt;_parent;
				}
				_node = parent;
			}
			else
			{
				//为父亲的右孩子
				_node = parent;
			}
		}

		return *this;
	}

	Self&amp; operator++()
	{
		if (_node-&gt;_right)
		{
			//存在右子树
			_node = _node-&gt;_right;
			while (_node &amp;&amp; _node-&gt;_left)
			{
				_node = _node-&gt;_left;
			}
		}
		else
		{
			//不存在右子树
			Node* parent = _node-&gt;_parent;
			while (parent &amp;&amp; _node == parent-&gt;_right)
			{
				_node = parent;
				parent = parent-&gt;_parent;
			}
			_node = parent;
		}
		return *this;
	}
};

template &lt;class K, class T, class KeyOfT&gt;
class RBTree
{
	typedef RBTreeNode&lt;T&gt; Node;
public:
	typedef __RBTreeIterator&lt;T, T&amp;, T*&gt; iterator;
	typedef __RBTreeIterator&lt;T,const T&amp;,const T*&gt; const_iterator;

	RBTree() = default;//强制编译器生成构造函数

	//拷贝构造
	RBTree(RBTree&lt;K, const T, KeyOfT&gt;&amp; t)
	{
		_root = copy(t._root);
	}

	iterator begin()
	{
		Node* LeftMin = _root;
		while (LeftMin &amp;&amp; LeftMin-&gt;_left)
		{
			LeftMin = LeftMin-&gt;_left;
		}
		return iterator(LeftMin);
	}

	iterator end()
	{
		return iterator(_root-&gt;_parent);
	}
	
	const_iterator begin() const
	{
		Node* LeftMin = _root;
		while (LeftMin &amp;&amp; LeftMin-&gt;_left)
		{
			LeftMin = LeftMin-&gt;_left;
		}
		return const_iterator(LeftMin);
	}

	const_iterator end() const
	{
		return const_iterator(nullptr);
	}

	//右单旋，满足二叉树引发右单旋之后平衡因子一定为0
	void RNode(Node* parent)
	{
		Node* pparent = parent-&gt;_parent;

		Node* subL = parent-&gt;_left;
		Node* subLR = subL-&gt;_right;

		parent-&gt;_left = subLR;
		if (subLR)
			subLR-&gt;_parent = parent;

		subL-&gt;_right = parent;
		parent-&gt;_parent = subL;

		if (pparent)
		{
			subL-&gt;_parent = pparent;

			if (pparent-&gt;_left == parent)
			{
				pparent-&gt;_left = subL;
			}
			else
			{
				pparent-&gt;_right = subL;
			}
		}
		else
		{
			_root = subL;
			subL-&gt;_parent = nullptr;
		}
	}

	//左单旋
	void LNode(Node* parent)
	{
		Node* pparent = parent-&gt;_parent;

		Node* subR = parent-&gt;_right;
		Node* subRL = subR-&gt;_left;

		parent-&gt;_right = subRL;
		if (subRL)
			subRL-&gt;_parent = parent;

		subR-&gt;_left = parent;
		parent-&gt;_parent = subR;

		if (pparent)
		{
			subR-&gt;_parent = pparent;

			if (pparent-&gt;_left == parent)
			{
				pparent-&gt;_left = subR;
			}
			else
			{
				pparent-&gt;_right = subR;
			}
		}
		else
		{
			_root = subR;
			subR-&gt;_parent = nullptr;
		}
	}

	pair&lt;iterator,bool&gt; Insert(const T&amp; data)
	{
		//二叉树为空，插入第一个值
		if (_root == nullptr)
		{
			_root = new Node(data);
			_root-&gt;_col = BLACK;
			return make_pair(iterator(_root),true);
		}

		KeyOfT kot;
		//后续插入
		Node* parent = nullptr;
		Node* cur = _root;
		while (cur)
		{
			if (kot(cur-&gt;_data) &gt; kot(data))
			{
				parent = cur;
				cur = cur-&gt;_left;
			}
			else if (kot(cur-&gt;_data) &lt; kot(data))
			{
				parent = cur;
				cur = cur-&gt;_right;
			}
			else
			{
				//不允许冗余
				return make_pair(iterator(cur),false);
			}
		}

		//找到对应位置
		cur = new Node(data);
		cur-&gt;_parent = parent;
		
		Node* newcur = cur;

		if (kot(parent-&gt;_data) &gt; kot(data))
		{
			parent-&gt;_left = cur;
		}
		else
		{
			parent-&gt;_right = cur;
		}

		//父亲的颜色是黑色也就结束
		while (parent &amp;&amp; parent-&gt;_col == RED)//红黑树出现错误需要改正
		{
			Node* grandfather = parent-&gt;_parent;
			if (grandfather-&gt;_left == parent)
			{
				//舅子树在右边
				Node* uncle = grandfather-&gt;_right;
				if (uncle &amp;&amp; uncle-&gt;_col == RED)
				{
					//存在且颜色为红
					parent-&gt;_col = BLACK;
					uncle-&gt;_col = BLACK;

					grandfather-&gt;_col = RED;

					cur = grandfather;
					parent = grandfather-&gt;_parent;
				}
				else
				{
					//舅子树不存在或颜色为黑
					if (parent-&gt;_left == cur)
					{
						//单旋
						parent-&gt;_col = BLACK;
						grandfather-&gt;_col = RED;
						RNode(grandfather);
					}
					else
					{
						//双旋 先左再右
						LNode(parent);
						cur-&gt;_col = BLACK;
						grandfather-&gt;_col = RED;
						RNode(grandfather);
					}
					break;
				}
			}
			else
			{
				//舅子树在左边
				Node* uncle = grandfather-&gt;_left;
				if (uncle &amp;&amp; uncle-&gt;_col == RED)
				{
					parent-&gt;_col = BLACK;
					uncle-&gt;_col = BLACK;
					grandfather-&gt;_col = RED;

					cur = grandfather;
					parent = grandfather-&gt;_parent;
				}
				else
				{
					if (parent-&gt;_right == cur)
					{
						//单旋
						parent-&gt;_col = BLACK;
						grandfather-&gt;_col = RED;
						LNode(grandfather);
					}
					else
					{
						//双旋
						RNode(parent);
						LNode(grandfather);
						grandfather-&gt;_col = RED;
						cur-&gt;_col = BLACK;
					}
					break;
				}
			}
		}

		_root-&gt;_col = BLACK;

		return make_pair(iterator(newcur),true);
	}

	bool IsRBTree()
	{
		if (_root-&gt;_col == RED)
		{
			cout &lt;&lt; "根节点为红节点" &lt;&lt; endl;
			return false;
		}

		int DefNum = 0;
		Node* cur = _root;
		while (cur)
		{
			if (cur-&gt;_col == BLACK)
			{
				DefNum++;
			}

			cur = cur-&gt;_left;
		}

		return _Check(_root, 0, DefNum);
	}

	~RBTree()
	{
		Destory(_root); 
		_root = nullptr;
	}

private:
	Node* copy(const Node* root)
	{
		if (root == nullptr)
		{
			return nullptr;
		}

		Node* newnode = new Node(root-&gt;_data);
		newnode-&gt;_col = root-&gt;_col;

		newnode-&gt;_left = copy(root-&gt;_left);
		if(newnode-&gt;_left)
			newnode-&gt;_left-&gt;_parent = newnode;
		newnode-&gt;_right = copy(root-&gt;_right);
		if (newnode-&gt;_left)
			newnode-&gt;_left-&gt;_parent = newnode;

		return newnode;
	}

	void Destory(Node* root)
	{
		if (root == nullptr)
		{
			return;
		}

		Destory(root-&gt;_left);
		Destory(root-&gt;_right);

		delete root;
		root = nullptr;
	}

	bool _Check(Node* root, int BlackNum, int DefNum)
	{
		if (root == nullptr)
		{
			if (BlackNum != DefNum)
			{
				cout &lt;&lt; BlackNum &lt;&lt; "|" &lt;&lt; DefNum &lt;&lt; endl;
				cout &lt;&lt; "存在黑色节点数量不相等的路径" &lt;&lt; endl;
				return false;
			}
			return true;
		}

		if (root-&gt;_col == RED &amp;&amp; root-&gt;_parent-&gt;_col == RED)
		{
			cout &lt;&lt; root-&gt;_kv.first &lt;&lt; "-&gt;存在连续的两个红节点" &lt;&lt; endl;
			return false;
		}

		if (root-&gt;_col == BLACK)
		{
			BlackNum++;
		}

		return _Check(root-&gt;_left, BlackNum, DefNum)
			&amp;&amp; _Check(root-&gt;_right, BlackNum, DefNum);
	}


	Node* _root = nullptr;

};
</code></pre> 
<h2 id="%E4%B8%89%E3%80%81set%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E5%B0%81%E8%A3%85">三、set的模拟实现封装</h2> 
<div> 
 <span style="color:#777777;">set</span> 
 <span style="color:#777777;">的底层为红黑树，因此只需在</span> 
 <span style="color:#777777;">set</span> 
 <span style="color:#777777;">内部封装一棵红黑树，即可将该容器实现出来</span> 
 <span style="color:#777777;">(</span> 
 <span style="color:#777777;">具体实现可参 </span> 
</div> 
<div> 
 <span style="color:#777777;">考</span> 
 <span style="color:#777777;">map)</span> 
 <span style="color:#777777;">。</span> 
</div> 
<pre><code class="language-cpp">template &lt;class K&gt;
class set
{
public:
	struct SetKeyOFT
	{
		const K&amp; operator()(const K&amp; key)
		{
			return key;
		}
	};

	typedef typename RBTree&lt;K, K, SetKeyOFT&gt;::iterator iterator;
	typedef typename RBTree&lt;K, const K, SetKeyOFT&gt;::iterator const_iterator;

	pair&lt;iterator,bool&gt; insert(const K&amp; key)
	{ 
		return _t.Insert(key);
	}

	iterator begin()
	{
		return _t.begin();
	}

	iterator end()
	{
		return _t.end();
	}

	const_iterator begin() const
	{
		return _t.begin();
	}

	const_iterator end() const
	{
		return _t.end();
	}

private:
	RBTree&lt;K, const K, SetKeyOFT&gt; _t;
};</code></pre> 
<h2 id="%E5%9B%9B%E3%80%81map%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E5%B0%81%E8%A3%85">四、map的模拟实现封装</h2> 
<pre><code class="language-cpp">template &lt;class K,class V&gt;
class map
{
public:

	struct MapKeyOFT
	{
		const K&amp; operator()(const pair&lt;K, V&gt;&amp; kv)
		{
			return kv.first;
		}
	};

	typedef typename RBTree&lt;K, pair&lt;const K, V&gt;, MapKeyOFT&gt;::iterator iterator;
	typedef typename RBTree&lt;K, pair&lt;const K, V&gt;, MapKeyOFT&gt;::iterator const_iterator;

	V&amp; operator[](const K&amp; key)
	{
		pair&lt;iterator,bool&gt; ret = _t.Insert(make_pair(key,V()));
		return ret.first-&gt;second;
	}

	pair&lt;iterator,bool&gt; insert(const pair&lt;K,V&gt;&amp; kv)
	{
		return _t.Insert(kv);
	}

	iterator begin()
	{
		return _t.begin();
	}

	iterator end()
	{
		return _t.end();
	}
	
	const_iterator begin() const
	{
		return _t.begin();
	}

	const_iterator end() const
	{
		return _t.end();
	}

private:
	RBTree&lt;K, pair&lt;const K,V&gt;, MapKeyOFT&gt; _t;
};</code></pre> 
<h2 id="%E4%BA%94%E3%80%81%E5%AE%8C%E7%BB%93%E6%92%92%E2%9D%80" style="background-color:transparent;">五、完结撒❀</h2> 
<p>如果以上内容对你有帮助不妨点赞支持一下，以后还会分享更多编程知识，我们一起进步。<br> 最后我想讲的是，据说点赞的都能找到漂亮女朋友❤</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/5b/4b/PJFZgbw0_o.gif"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ad445b77d97d5d48de1cfe9ec7f8af4c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据结构：旋转数组</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/533022123f88f98657df1c94b806d161/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MATLAB数学建模——数据拟合</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>