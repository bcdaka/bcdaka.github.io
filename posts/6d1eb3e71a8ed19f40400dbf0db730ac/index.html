<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c语言11天笔记 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/6d1eb3e71a8ed19f40400dbf0db730ac/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="c语言11天笔记">
  <meta property="og:description" content="函数的概述
函数：实现一定功能的，独立的代码模块。我们的函数一定是先定义，后使用。
使用函数的优势：
1. 我们可以通过函数提供功能给别人使用。当然我们也可以使用别人提供的函数，减少代码量。
2. 借助函数可以减少重复性的代码。
3. 实现结构化（模块化）
程序设计思想: 结构化程序设计思想：将大型的任务功能划分为相互独立的小型的任务模块来设计。
函数是C语言程序的基本组成单元：
C语言程序是由一个（必然是main函数）或多个函数组成。
函数的分类
从函数实现的角度：
库函数：C语言标准库实现并提供使用的函数，比如常见的有printf()，scanf()
用户自定义函数：需要程序员自行实现，开发中大部分都是这样的函数
从函数形式的角度：
无参函数：函数调用时，无需传参，可配可不配返回值。
有参函数：函数调用时，需要参数传递数据，经常需要配套返回值使用。
相关概念
主调函数：主动去调用其他函数的函数。
被调函数：被调用的函数
很多时候，一个函数既可以是主调函数，也可以是被调函数。这种情况一般出自自定义函 数。
函数的定义
语法
函数首部：
返回类型：函数返回值的类型
函数名：函数的名称，遵循标识符命名（使用英文字母、数字、_、$，不能以数字开头，建议小写 &#43;下划线命名法）
形参列表：用于接收主调函数传递的数据，如果有多个用&#34; , &#34;分隔，且每一个形参都需要指定类 型。
面试题：
注意：
函数类型标识符变量类型说明符相同，它表示返回的函数值的类型。
在C语言中还可以定义无类型（即void类型）的函数，这种函数不返回函数值，只是完成某种功 能。
如果省略函数的类型标识符，则默认为是int型。
函数中返回语句的形式为 return(表达式)；或 return 表达式；其作用是将表达式的值作为函数值返 回给调用函数。其中表达式的类型应与函数类型一致。
如果&#34;形参表列&#34;中有多个形式参数，则它们之间要用&#34; , &#34;分隔。
如果形参表中有多个形参，即使它们的类型是相同的，在形参表中也只能逐个进行说明。 fun1(in t a,int b){}
一个完整C程序中的所有函数可以放在一个文件中，也可以放在 多个文件中。
案例
案例1：
案例2：
形参和实参
概念
形参（形式参数）：
函数定义时指定的参数，形参是用来接收数据的，函数定义时，系统不会为形参申请内存，只有当函 数调用时，系统才会为形参申请内存，用于存储实际参数，并且当函数返回，系统会自动回收为形参 申请的内存资源。(本质上所有函数都有return，只不过当我们的函数返回类型是void的时候，return 关键字被省略了)
实参（实际参数）：
函数调用时主调函数传递的数据参数（常量、变量、表达式..，只要有确定的值），实参是传递的 数据。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-06T17:56:25+08:00">
    <meta property="article:modified_time" content="2024-08-06T17:56:25+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c语言11天笔记</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>函数的概述</p> 
<p>函数：实现一定功能的，独立的代码模块。我们的函数一定是先定义，后使用。</p> 
<p>使用函数的优势：</p> 
<p>1. 我们可以通过函数提供功能给别人使用。当然我们也可以使用别人提供的函数，减少代码量。</p> 
<p>2. 借助函数可以减少重复性的代码。</p> 
<p>3. 实现结构化（模块化）</p> 
<p>程序设计思想: 结构化程序设计思想：将大型的任务功能划分为相互独立的小型的任务模块来设计。</p> 
<p>函数是C语言程序的基本组成单元：</p> 
<p>C语言程序是由一个（必然是main函数）或多个函数组成。</p> 
<p>函数的分类</p> 
<p>从函数实现的角度：</p> 
<p>库函数：C语言标准库实现并提供使用的函数，比如常见的有printf()，scanf()</p> 
<p>用户自定义函数：需要程序员自行实现，开发中大部分都是这样的函数</p> 
<p>从函数形式的角度：</p> 
<p>无参函数：函数调用时，无需传参，可配可不配返回值。</p> 
<p>有参函数：函数调用时，需要参数传递数据，经常需要配套返回值使用。</p> 
<p>相关概念</p> 
<p>主调函数：主动去调用其他函数的函数。</p> 
<p>被调函数：被调用的函数</p> 
<p><img alt="" height="290" src="https://images2.imgbox.com/f1/20/bRPxVwSV_o.png" width="995"></p> 
<p>很多时候，一个函数既可以是主调函数，也可以是被调函数。这种情况一般出自自定义函 数。</p> 
<p><img alt="" height="459" src="https://images2.imgbox.com/70/ca/XPsSGuFo_o.png" width="981"></p> 
<p>函数的定义</p> 
<p>语法</p> 
<p><img alt="" height="154" src="https://images2.imgbox.com/06/b8/wKkMZYNJ_o.png" width="1087"></p> 
<p>函数首部：</p> 
<p>返回类型：函数返回值的类型</p> 
<p>函数名：函数的名称，遵循标识符命名（使用英文字母、数字、_、$，不能以数字开头，建议小写 +下划线命名法）</p> 
<p>形参列表：用于接收主调函数传递的数据，如果有多个用" , "分隔，且每一个形参都需要指定类 型。</p> 
<p><img alt="" height="171" src="https://images2.imgbox.com/d5/e7/8KbVk3VS_o.png" width="1075"></p> 
<p>面试题：</p> 
<p><img alt="" height="207" src="https://images2.imgbox.com/39/eb/8oWA9jmG_o.png" width="1099"></p> 
<p>注意：</p> 
<p>函数类型标识符变量类型说明符相同，它表示返回的函数值的类型。</p> 
<p>在C语言中还可以定义无类型（即void类型）的函数，这种函数不返回函数值，只是完成某种功 能。</p> 
<p>如果省略函数的类型标识符，则默认为是int型。</p> 
<p>函数中返回语句的形式为 return(表达式)；或 return 表达式；其作用是将表达式的值作为函数值返 回给调用函数。其中表达式的类型应与函数类型一致。</p> 
<p>如果"形参表列"中有多个形式参数，则它们之间要用" , "分隔。</p> 
<p>如果形参表中有多个形参，即使它们的类型是相同的，在形参表中也只能逐个进行说明。 fun1(in t a,int b){}</p> 
<p>一个完整C程序中的所有函数可以放在一个文件中，也可以放在 多个文件中。</p> 
<p><img alt="" height="149" src="https://images2.imgbox.com/27/36/zjGl3nrL_o.png" width="1079"></p> 
<p>案例</p> 
<p>案例1：</p> 
<p><img alt="" height="800" src="https://images2.imgbox.com/06/37/ymZtdblu_o.png" width="1102"></p> 
<p>案例2：</p> 
<p><img alt="" height="268" src="https://images2.imgbox.com/a3/a4/L9KmxTHT_o.png" width="1113"></p> 
<p><img alt="" height="924" src="https://images2.imgbox.com/f2/e3/FxG0XdeB_o.png" width="1111"></p> 
<p>形参和实参</p> 
<p>概念</p> 
<p>形参（形式参数）：</p> 
<p>函数定义时指定的参数，形参是用来接收数据的，函数定义时，系统不会为形参申请内存，只有当函 数调用时，系统才会为形参申请内存，用于存储实际参数，并且当函数返回，系统会自动回收为形参 申请的内存资源。(本质上所有函数都有return，只不过当我们的函数返回类型是void的时候，return 关键字被省略了)</p> 
<p>实参（实际参数）：</p> 
<p>函数调用时主调函数传递的数据参数（常量、变量、表达式..，只要有确定的值），实参是传递的 数据。</p> 
<p>实参和形参必须类型相同。若不同时，按赋值规定自动进行类型转换。</p> 
<p>在C语言中，参数传递遵循 单向值传递 ，实参只是将自身的值传递给形参，而不是实参本身。形参 的值的改变不会影响实参。</p> 
<p>实参与形参在内存中占据不同的内存空间，尽管可能实参和形参名称是一样的。</p> 
<p><img alt="" height="460" src="https://images2.imgbox.com/1b/57/r747YLVV_o.png" width="1100"></p> 
<p>案例2：</p> 
<p><img alt="" height="445" src="https://images2.imgbox.com/44/3f/H4BfAeBs_o.png" width="1084"></p> 
<p><img alt="" height="505" src="https://images2.imgbox.com/b8/38/ERxGD78O_o.png" width="1094"></p> 
<p>函数的返回值</p> 
<p>若不需要返回值，函数中可以没有return语句。</p> 
<p>一个函数中可以有多个return语句，但任一时刻只有一个return语句被执行。</p> 
<p>被调函数返回给主调函数的结果数据（可以是变量、常量、表达式，只要是有确定值即可。）</p> 
<p>返回值类型一般情况下需要和函数中return语句返回的数据类型保持一致，如果不一致，以函数定 义时指定的返回类型为标准。也就是返回值类型和实际返回值可以存在自动类型转换或者强制类型 转换的关系。</p> 
<p>案例1：</p> 
<p><img alt="" height="283" src="https://images2.imgbox.com/83/95/vrSbyHHV_o.png" width="1106"></p> 
<p><img alt="" height="794" src="https://images2.imgbox.com/97/52/yumcyECM_o.png" width="1110"></p> 
<p>案例2：</p> 
<p><img alt="" height="559" src="https://images2.imgbox.com/33/77/499xqNzk_o.png" width="1137"></p> 
<p><img alt="" height="463" src="https://images2.imgbox.com/df/83/XcH9WG6O_o.png" width="1105"></p> 
<p>案例3：</p> 
<p><img alt="" height="900" src="https://images2.imgbox.com/09/ab/Z59TvyL7_o.png" width="1109"></p> 
<p><img alt="" height="203" src="https://images2.imgbox.com/5d/f4/GdNON8dX_o.png" width="1120"></p> 
<p>函数的调用</p> 
<p>调用方式</p> 
<p>1. 函数语句： test(); int result = max(2,4);</p> 
<p>2. 函数表达式： 4 + max(2,4);</p> 
<p>3. 函数参数： printf("%d",max(2,4))</p> 
<p>在一个函数中调用另一个函数须具备以下条件</p> 
<p>① 被调用的函数必须是已经定义的函数；</p> 
<p>② 若使用库函数，应在本文件开头用#include包含；</p> 
<p>③ 若使用用户定义的函数，而用户函数又在主调函数的后面，则应在主调函数中对被调用的函数进 行声明。声明的作用是把函数名、函数参数的个数和类型等信息通知编译系统，以便在遇到函数时， 编译系统能正确识别函数，并检查函数调用的合法性。</p> 
<p>函数声明</p> 
<p>函数调用时，往往要遵循 先定义后调用 ，但如果我们对函数的调用操作出现在函数的定义之前，则需 要对函数进行声明。</p> 
<p>函数声明的作用：</p> 
<p>是把函数名、函数参数的个数和返回类型等信息通知给编译系统，以便于在遇到函数时，编译系统能 正确识别函数，并检查函数调用的合法性。</p> 
<p><img alt="" height="1144" src="https://images2.imgbox.com/77/fe/zy62KIY0_o.png" width="1099"></p> 
<p>声明的方式：</p> 
<p>函数首部后加上分号</p> 
<p> </p> 
<p><img alt="" height="72" src="https://images2.imgbox.com/44/9f/2N9tGBG7_o.png" width="1060"></p> 
<p>函数首部后加上分号，可省略形参名，但不能省略参数类型。</p> 
<p><img alt="" height="75" src="https://images2.imgbox.com/ca/b7/epAr4qw6_o.png" width="1059"></p> 
<p>函数的嵌套调用</p> 
<p>函数不允许嵌套定义，但允许嵌套调用。</p> 
<p>嵌套调用：在被调函数内有去主动去调用其他函数，这样的函数调用方式，称之为嵌套调用；</p> 
<p><img alt="" height="315" src="https://images2.imgbox.com/86/02/ECLR5Dvo_o.png" width="1089"></p> 
<p>案例1：</p> 
<p><img alt="" height="623" src="https://images2.imgbox.com/78/99/aMEwhmgF_o.png" width="1098"></p> 
<p><img alt="" height="548" src="https://images2.imgbox.com/e5/92/20mqKBkC_o.png" width="1103"></p> 
<p>案例2：</p> 
<p><img alt="" height="806" src="https://images2.imgbox.com/e1/3c/i3GLn1iJ_o.png" width="1104"></p> 
<p><img alt="" height="466" src="https://images2.imgbox.com/c5/c4/wQCuQttt_o.png" width="1096"></p> 
<p>函数的递归调用</p> 
<p>递归调用的含义：在一个函数中，直接或者间接调用了函数本身称之为函数的递归调用。</p> 
<p><img alt="" height="222" src="https://images2.imgbox.com/77/bf/eUgJGK8g_o.png" width="1051"></p> 
<p>递归调用的本质：</p> 
<p>是一种循环结构，它不同于之前所学的while，do-while，for这样的循环结构，这些循环结构是借 助循环变量，而递归是利用函数自身实现循环结构，如果不加以控制，很容易产生死循环。</p> 
<p>递归调用的注意事项：</p> 
<p>1. 递归调用必须要有出口，一定要终止递归（否则会产生死循环）。</p> 
<p>2. 对终止条件的判断一定要放在函数递归之前。</p> 
<p>3. 进行函数的递归调用。</p> 
<p>4. 函数递归的同时一定要将函数调用向出口逼近。</p> 
<p>案例1</p> 
<p><img alt="" height="1129" src="https://images2.imgbox.com/30/d3/VzssLaTD_o.png" width="1087"></p> 
<p>案例2：</p> 
<p><img alt="" height="149" src="https://images2.imgbox.com/1a/01/1VkjXyWw_o.png" width="1090"></p> 
<p><img alt="" height="1035" src="https://images2.imgbox.com/84/5f/SUpjaL2T_o.png" width="1124"></p> 
<p>数组做函数参数</p> 
<p>注意：</p> 
<p>当用数组做函数的实际参数时，则形参应该也要用数组/指针变量来接收，但请注意，此次并不 代表传递了数组中所有的元素数据，而是传递了第一个元素的内存地址（数组首地址），形参接收这 个地址后，则形参和实参就代表了同一块内存空间，则形参的数据修改会改变实参的。这种数据传递 方式我们可以称之为“引用传递”。</p> 
<p>如果用数组做函数形式参数，那么我们提供另一个形参表示数组的元素个数。原因是数组形参代 表的仅仅是实际数组的首地址。也就是说形参只获取到了实际数组元素的开始，并未获取元素的结 束。所以提供另一个形参表示数组的元素个数，可以防止在被调函数对实际数组元素访问的越界。</p> 
<p>但有一个例外，如果是用字符数组做形参，且实际数组中存放的是字符串数据（形参是字符数 组，实参是字符串）。则不用表示数组元素的个数的形参，原因是字符串本身会自动结束符\0。</p> 
<p>案例-数组元素做函数实参：</p> 
<p><img alt="" height="1036" src="https://images2.imgbox.com/af/6b/jsxQBIHd_o.png" width="1107"></p> 
<p><img alt="" height="946" src="https://images2.imgbox.com/75/0d/n22PApEe_o.png" width="1107"></p> 
<p>案例2：</p> 
<p><img alt="" height="409" src="https://images2.imgbox.com/c1/32/F5HiJ6ne_o.png" width="1086"></p> 
<p><img alt="" height="733" src="https://images2.imgbox.com/49/ac/lNVUFrVg_o.png" width="1096"></p> 
<p>变量的作用域</p> 
<p>引入问题</p> 
<p>我们在函数设计过程中，经常要考虑对参数的设计，换句话说，我们需要考虑函数需要几个参数，需 要什么类型的参数，但我并没有考虑函数是否需要提供参数，如果说函数可以访问到已定义的数据， 则就不需要提供函数形参，那么我么到底要不要提供函数参数，取决于什么？答案就是变量的作用域 （如果函数在变量的作用域范围内，则函数可以直接访问数据）</p> 
<p>变量的作用域</p> 
<p>概念：变量的作用范围，也就是说变量在什么范围是有效的。</p> 
<p>变量的分类</p> 
<p>根据变量的作用域不同，变量可分为全局变量和局部变量</p> 
<p>局部变量</p> 
<p><img alt="" height="290" src="https://images2.imgbox.com/1c/ff/PCtyv9Nl_o.png" width="1096"></p> 
<p>全局变量</p> 
<p><img alt="" height="169" src="https://images2.imgbox.com/16/85/458p2MFJ_o.png" width="1095"></p> 
<p>建议在全局变量定义时初始化。如果不初始化，系统会将全局变量初始化为0（0 | \0 |0.0）。</p> 
<p>使用全局变量的优缺点：</p> 
<p>优点：</p> 
<p>1. 利用全局变量可以实现一个函数对外输出的多个结果数据。</p> 
<p>2. 利用全局变量可以减少函数形参个数，从而降低内存消耗，以及因形参传递带来的时间消耗。</p> 
<p>缺点：</p> 
<p>1. 全局变量在程序的整个运行期间，始终占据内存空间，会引起资源消耗。</p> 
<p>2. 过多的全局变量会引起程序的混乱，造成程序结果错误。</p> 
<p>3. 降低程序通用性，特别是当我们进行函数移植时，不仅仅要移植函数，还要考虑全局变量。</p> 
<p>4. 违反了“高内聚，低耦合”的程序设计原则。</p> 
<p>总结：我们发现弊大于利，建议尽量减少对全局变量的使用，函数之间要产生联系，仅通过实参形参的方式产生联系。</p> 
<p>作用域举例：</p> 
<p><img alt="" height="468" src="https://images2.imgbox.com/47/12/bWUXvZrQ_o.png" width="710"></p> 
<p>案例：</p> 
<p><img alt="" height="504" src="https://images2.imgbox.com/5c/d8/3V9gHf68_o.png" width="1100"></p> 
<p>注意：</p> 
<p>如果全局变量（外部变量）和局部变量同名，程序执行的时候， 就近原则</p> 
<p><img alt="" height="351" src="https://images2.imgbox.com/cf/e5/C5qFHKch_o.png" width="1093"></p> 
<p>变量的生命周期</p> 
<p>概念：</p> 
<p>变量在程序运行中的存在时间。 根据变量存在的时间不同，变量可分为静态存储方式和动态存储方式。</p> 
<p><img alt="" height="649" src="https://images2.imgbox.com/b2/05/CU1IxKdM_o.png" width="1016"></p> 
<p>变量的存储类型</p> 
<p><img alt="" height="68" src="https://images2.imgbox.com/e4/46/YNNPbMmE_o.png" width="1058"></p> 
<p>存储类型</p> 
<p>auto</p> 
<p>auto存储类型只能修饰局部变量，被auto修饰的局部变量是存储在动态存储区的。auto也是局部变 量默认的存储类型。</p> 
<p><img alt="" height="62" src="https://images2.imgbox.com/ba/a8/qxWidVTQ_o.png" width="1058"></p> 
<p>static</p> 
<p>修饰局部变量：局部变量会被存储在静态存储区。局部变量的生命周期被延长，但是作用域不发 生改变。</p> 
<p>修改全局变量：全局变量的生命周期不变，但作用域被衰减。一般限制全局变量只能在本文件 内。</p> 
<p>demo01.c</p> 
<p><img alt="" height="181" src="https://images2.imgbox.com/eb/78/5Li7v61m_o.png" width="1041"></p> 
<p>demo02.c</p> 
<p><img alt="" height="249" src="https://images2.imgbox.com/85/5c/K4AXb0gb_o.png" width="1062"></p> 
<p>extern</p> 
<p>外部存储类型：只能修饰全局变量，次全局变量可以被其他文件访问。相当于扩展了全局变量的 作用域。</p> 
<p>extern修饰外部变量，往往是外部变量进行声明，声明该变量是在外部文件中定义的；不是变量定 义。</p> 
<p>demo01.c</p> 
<p><img alt="" height="160" src="https://images2.imgbox.com/b9/c8/6TJjxN5A_o.png" width="1064"></p> 
<p>demo02.c</p> 
<p><img alt="" height="375" src="https://images2.imgbox.com/51/61/QOb0yioq_o.png" width="1053"></p> 
<p>register</p> 
<p>寄存器存储类型：只能修饰局部变量，用register修饰的局部变量会直接存储到CPU的寄存器中， 往往将循环变量设</p> 
<p>置为寄存器存储类型。</p> 
<p>面试题</p> 
<p>static关键字的作用</p> 
<p>1. static修饰局部变量，延长其生命周期，但不影响局部变量的作用域。</p> 
<p>2. static修饰全局变量，不影响全局变量的生命周期，会限制全局变量的作用域仅限本文件内使用；</p> 
<p>3. static修饰函数：此函数就称为内部函数，仅限本文件内调用。 static int funa(){..}</p> 
<p>值传递与引用传递</p> 
<p>值传递：发生在整型、浮点型、字符型，数据传递，传递的是数值，也就是内存空间只能被当前变 量独享。</p> 
<p><img alt="" height="300" src="https://images2.imgbox.com/dd/c9/npNU7ol6_o.png" width="550"></p> 
<p>引用传递：发生在数组、指针、结构体..，数据传递，传递的是地址值，也就是内存空间可以被多 个变量共享。</p> 
<p><img alt="" height="737" src="https://images2.imgbox.com/95/cc/i40aXYMy_o.png" width="1124"></p> 
<p><img alt="" height="515" src="https://images2.imgbox.com/75/59/kOm7SaA7_o.png" width="1097"></p> 
<p>内部函数和外部函数</p> 
<p>内部函数：使用static修饰的函数，称作内部函数，内部函数只能在当前文件中调用。</p> 
<p>外部函数：使用extern修饰的函数，称作外部函数，extern是默认的，可以不写，也就是说本质上 我们所写的函数都是外部函数，建议外部函数在被其他文件调用的时候，在其他文件中声明的时 候，加上extern关键字。</p> 
<p>章节作业</p> 
<p>编程题</p> 
<p>1. 编写一个函数，通过输入球的半径，返回球的体积；</p> 
<p>2. 编写一个函数，通过输入一个数字字符，返回该数字</p> 
<p>3. 编写一个函数，输入四个数据分别表示2个点的x，y坐标，返回两点之间的距离；</p> 
<p>4. 编写一个函数，通过参数输入一个整型数，返回该数各位上数字的平方和；</p> 
<p>5. 编写一个函数，通过参数输入x的值，计算如下的数学函数值，当 x&gt;5时， f(x) = 4x+7;否则 f(x) = -2x+3,返回结果值</p> 
<p>6. 设计一个函数，用来求出多个数据的平均值；</p> 
<p>7. 设计一个函数，用来查找一个字符串中某个字符的位置；</p> 
<p>8. 设计一个函数，把一个整型数字转成对应的字符串格式</p> 
<p>9. 设计一个函数，统计字符串中大写字母的个数</p> 
<p>10. 设计函数，实现strcmp 的功能；</p> 
<p>11. 编写函数，用于判断输入的字符是不是个数字。是返回1，不是返回0.</p> 
<p>12. 设计一程序,实现一个简单的计算器。 要求：有菜单函数 和加、减、乘、除的函数 主函数调用这些函数实现程序的功能.要求菜单函数能 够输出如下的界面</p> 
<p>1、加法 2、减法 3、乘法 4、除法 0.退出</p> 
<p>13. 设计函数实现冒泡排序；</p> 
<p>思考题【选做】</p> 
<p>14. 编写一个函数，将数组中的数据首尾互换</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a79695c0ee5830156ced38f0b98ac0b4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Unity入门1——基本操作</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ca870a930da2404dc61b621c53eb30b9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">类和对象（下）C&#43;&#43;</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>