<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【算法】基础算法002之滑动窗口（二） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/af29db587ba05785db7302ceb669223d/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【算法】基础算法002之滑动窗口（二）">
  <meta property="og:description" content="👀樊梓慕：个人主页
🎥个人专栏：《C语言》《数据结构》《蓝桥杯试题》《LeetCode刷题笔记》《实训项目》《C&#43;&#43;》《Linux》《算法》
🌝每一个不曾起舞的日子，都是对生命的辜负
目录
前言
5.水果成篮（medium）
6.找到字符串中所有字母异位词
7.串联所有单词的子串（hard） 8.最小覆盖字串（hard）
前言 滑动窗口专题续作，本篇文章继续围绕滑动窗口进行讲解，并辅以实战OJ题帮助理解。
欢迎大家📂收藏📂以便未来做题时可以快速找到思路，巧妙的方法可以事半功倍。 =========================================================================
GITEE相关代码：🌟樊飞 (fanfei_c) - Gitee.com🌟
=========================================================================
5.水果成篮（medium） 904. 水果成篮 - 力扣（LeetCode）https://leetcode.cn/problems/fruit-into-baskets/description/
你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。
你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：
你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。 给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。
​ 阅读题目，其实就是找出一个最长的子数组的长度，要求子数组中不能超过两种元素。
思路：
如果大小超过2：说明窗口内水果种类超过了两种。那么就从左侧开始依次将水果划出窗口，直到哈希表的大小小于等于2，然后更新结果；如果没有超过2：说明当前窗口内水果的种类不超过两种，直接更新结果ret。
有了思路，画图独立完成代码，不要直接看博主的代码。
class Solution { public: int totalFruit(vector&lt;int&gt;&amp; fruits) { unordered_map&lt;int, int&gt; hash; int left = 0, right = 0; int ret = 0; int n = fruits.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-02-19T13:27:00+08:00">
    <meta property="article:modified_time" content="2024-02-19T13:27:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【算法】基础算法002之滑动窗口（二）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"><a id="_0"></a><img alt="" height="147" src="https://images2.imgbox.com/3e/cc/TYFhqGOL_o.png" width="334"></p> 
<p style="text-align:center;"><strong>👀<span style="color:#98c091;">樊梓慕：</span><strong><strong><strong><strong><strong><strong><strong><a href="https://blog.csdn.net/2301_77112634?type=blog" title="个人主页">个人主页</a></strong></strong></strong></strong></strong></strong></strong></strong></p> 
<p style="text-align:center;"><strong> 🎥<span style="color:#956fe7;">个人专栏：</span><strong><strong><strong><strong><strong><strong><strong><a href="http://t.csdn.cn/e7GFn" rel="nofollow" title="《C语言》">《C语言》</a></strong></strong></strong></strong></strong></strong></strong><strong><strong><strong><strong><strong><strong><strong><a href="http://t.csdn.cn/jUErT" rel="nofollow" title="《数据结构》">《数据结构》</a></strong></strong></strong></strong></strong></strong></strong><strong><strong><strong><strong><strong><strong><strong><a href="http://t.csdn.cn/q3iyZ" rel="nofollow" title="《蓝桥杯试题》">《蓝桥杯试题》</a></strong></strong></strong></strong></strong></strong></strong><strong><strong><strong><strong><strong><strong><strong><a href="http://t.csdn.cn/IUyeH" rel="nofollow" title="《LeetCode刷题笔记》">《LeetCode刷题笔记》</a></strong></strong></strong></strong></strong></strong></strong><strong><strong><strong><strong><strong><strong><strong><a href="http://t.csdn.cn/uK6me" rel="nofollow" title="《实训项目》">《实训项目》</a></strong></strong></strong></strong></strong></strong></strong><strong><strong><strong><strong><strong><strong><strong><a href="http://t.csdnimg.cn/uOlnu" rel="nofollow" title="《C++》">《C++》</a></strong></strong></strong></strong></strong></strong></strong><strong><strong><strong><strong><strong><strong><strong><a href="http://t.csdnimg.cn/cUhZr" rel="nofollow" title="《Linux》">《Linux》</a></strong></strong></strong></strong><strong><strong><strong><strong><a href="http://t.csdnimg.cn/S7d8A" rel="nofollow" title="《算法》">《算法》</a></strong></strong></strong></strong></strong></strong></strong></strong></p> 
<p style="text-align:center;"><strong>🌝<span style="color:#faa572;">每一个不曾起舞的日子，都是对生命的辜负</span></strong></p> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p id="%C2%A05.%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE%EF%BC%88medium%EF%BC%89-toc" style="margin-left:0px;"><a href="#%C2%A05.%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE%EF%BC%88medium%EF%BC%89" rel="nofollow"> 5.水果成篮（medium）</a></p> 
<p id="%C2%A06.%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D-toc" style="margin-left:0px;"><a href="#%C2%A06.%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D" rel="nofollow"> 6.找到字符串中所有字母异位词</a></p> 
<p id="7.%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2%EF%BC%88hard%EF%BC%89%C2%A0-toc" style="margin-left:0px;"><a href="#7.%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2%EF%BC%88hard%EF%BC%89%C2%A0" rel="nofollow">7.串联所有单词的子串（hard） </a></p> 
<p id="8.%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%97%E4%B8%B2%EF%BC%88hard%EF%BC%89-toc" style="margin-left:0px;"><a href="#8.%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%97%E4%B8%B2%EF%BC%88hard%EF%BC%89" rel="nofollow">8.最小覆盖字串（hard）</a></p> 
<hr id="hr-toc"> 
<h2>前言</h2> 
<p>滑动窗口专题续作，本篇文章继续围绕滑动窗口进行讲解，并辅以实战OJ题帮助理解。</p> 
<hr> 
<p> <span style="color:#ed7976;"><strong>欢迎大家📂</strong></span><span style="color:#be191c;"><strong>收藏</strong></span><span style="color:#ed7976;"><strong>📂以便未来做题时可以快速找到思路，巧妙的方法可以事半功倍。</strong></span> </p> 
<p><span style="color:#0d0016;"><strong>=========================================================================</strong></span></p> 
<p><span style="color:#9c8ec1;"><strong>GITEE相关代码：</strong></span><span style="color:#0d0016;"><strong>🌟</strong><a href="https://gitee.com/fanfei_c" rel="nofollow" title="樊飞 (fanfei_c) - Gitee.com">樊飞 (fanfei_c) - Gitee.com</a><strong>🌟</strong></span></p> 
<p><span style="color:#0d0016;"><strong>=========================================================================</strong></span></p> 
<hr> 
<h2 id="%C2%A05.%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE%EF%BC%88medium%EF%BC%89"> 5.水果成篮（medium）</h2> 
<p><a href="https://leetcode.cn/problems/fruit-into-baskets/description/" rel="nofollow" title="904. 水果成篮 - 力扣（LeetCode）https://leetcode.cn/problems/fruit-into-baskets/description/">904. 水果成篮 - 力扣（LeetCode）https://leetcode.cn/problems/fruit-into-baskets/description/</a></p> 
<blockquote> 
 <p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 <code>fruits</code> 表示，其中 <code>fruits[i]</code> 是第 <code>i</code> 棵树上的水果 <strong>种类</strong> 。</p> 
 <p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p> 
 <ul><li>你只有 <strong>两个</strong> 篮子，并且每个篮子只能装 <strong>单一类型</strong> 的水果。每个篮子能够装的水果总量没有限制。</li><li>你可以选择任意一棵树开始采摘，你必须从 <strong>每棵</strong> 树（包括开始采摘的树）上 <strong>恰好摘一个水果</strong> 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。</li><li>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</li></ul> 
 <p>给你一个整数数组 <code>fruits</code> ，返回你可以收集的水果的 <strong>最大</strong> 数目。</p> 
</blockquote> 
<p><img alt="" height="733" src="https://images2.imgbox.com/ac/96/wPWlTQ9m_o.png" width="1050">​ 阅读题目，其实就是找出一个最长的子数组的长度，要求子数组中不能超过两种元素。</p> 
<p>思路：</p> 
<ul><li>如果大小超过2：说明窗口内水果种类超过了两种。那么就从左侧开始依次将水果划出窗口，直到哈希表的大小小于等于2，然后更新结果；</li><li>如果没有超过2：说明当前窗口内水果的种类不超过两种，直接更新结果ret。<br>  </li></ul> 
<p> 有了思路，画图独立完成代码，不要直接看博主的代码。</p> 
<div> 
 <pre><code class="language-cpp">class Solution {
public:
    int totalFruit(vector&lt;int&gt;&amp; fruits) {
        unordered_map&lt;int, int&gt; hash;
        int left = 0, right = 0;
        int ret = 0;
        int n = fruits.size();
        while (right &lt; n)
        {
            hash[fruits[right]]++;//进入窗口
            while (hash.size() &gt; 2)//判断
            {
                hash[fruits[left]]--;//离开窗口
                if (hash[fruits[left]] == 0)
                {
                    hash.erase(fruits[left]);
                }
                left++;
            }
            ret = max(ret, right - left + 1);//更新结果
            right++;
        }
        return ret;
    }
};</code></pre> 
</div> 
<p>但如果使用容器，我们需要频繁地erase元素，这就牺牲了一定的时间。</p> 
<div> 
 <p class="img-center"><img alt="" height="559" src="https://images2.imgbox.com/f0/c6/GNnr6BVZ_o.png" width="1021"></p> 
</div> 
<p>又因为题目说明元素个数是有限的：</p> 
<div> 
 <p class="img-center"><img alt="" height="154" src="https://images2.imgbox.com/35/2d/skfSeSTn_o.png" width="438"></p> 
 <p>​所以我们可以利用数组模拟一个哈希表，这样效率会显著提升。 </p> 
</div> 
<div> 
 <pre><code class="language-cpp">class Solution {
public:
    int totalFruit(vector&lt;int&gt;&amp; fruits) {
        int hash[100001]={0};
        int left=0,right=0,kinds=0;
        int ret=0;
        int n=fruits.size();
        while(right&lt;n)
        {
            if(hash[fruits[right]]==0) kinds++;
            hash[fruits[right]]++;//进入窗口
            while(kinds&gt;2)//判断
            {
                hash[fruits[left]]--;//离开窗口
                if(hash[fruits[left]]==0)
                    kinds--;
                left++;
            }
            ret=max(ret,right-left+1);//更新结果
            right++;
        }
        return ret;
    }
};</code></pre> 
</div> 
<p class="img-center"><img alt="" height="574" src="https://images2.imgbox.com/0c/cb/13cDMkjq_o.png" width="1020"></p> 
<hr> 
<h2 id="%C2%A06.%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"> 6.找到字符串中所有字母异位词</h2> 
<p><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/" rel="nofollow" title="438. 找到字符串中所有字母异位词 - 力扣（LeetCode）https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词 - 力扣（LeetCode）https://leetcode.cn/problems/find-all-anagrams-in-a-string/</a></p> 
<blockquote> 
 <p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code><strong> </strong>中所有 <code>p</code><strong> </strong>的 <strong>异位词 </strong>的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p> 
 <p><strong>异位词 </strong>指由相同字母重排列形成的字符串（包括相同的字符串）。</p> 
</blockquote> 
<p><img alt="" height="495" src="https://images2.imgbox.com/36/20/eslPKBna_o.png" width="1046">​</p> 
<p>不难发现，我们需要在字符串 s 中维护一个滑动窗口，且该滑动窗口的长度始终与字符串 p 相等。</p> 
<p>然后依据该窗口内的元素构建哈希表与字符串 p 的哈希表作比较，如果两个哈希表相同，那么就证明滑动窗口内为字符串 p 的异位词。</p> 
<p>那么如何比较两个哈希表是否相同呢？如题意：</p> 
<div> 
 <p class="img-center"><img alt="" height="164" src="https://images2.imgbox.com/44/c3/CKjsk4Uj_o.png" width="455"></p> 
 <p>​字符串 s 和 p 仅包含小写字母，所以我们只要遍历即可，时间复杂度为常数级，可以忽略。 </p> 
</div> 
<p>有了思路，画图独立完成代码，不要直接看博主的代码。 </p> 
<div> 
 <pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; findAnagrams(string s, string p) {
        int hash1[26] = { 0 };
        for (auto e : p)
            hash1[e - 'a']++;
        int hash2[26] = { 0 };
        int left = 0, right = 0;
        int np = p.size();
        int ns = s.size();
        vector&lt;int&gt; ret;
        while (right &lt; ns)
        {
            hash2[s[right] - 'a']++;//进入窗口
            if (right - left + 1 &gt; np)//判断
                hash2[s[left++] - 'a']--;//离开窗口
            int flag = 0;
            for (int i = 0; i &lt; 26; i++)
                if (hash1[i] != hash2[i])
                    flag = 1;
            if (flag == 0)
                ret.push_back(left);//更新结果
            right++;
        }
        return ret;
    }
};</code></pre> 
</div> 
<hr> 
<p>可是如果 s 和 p 内不光存储小写字母，或者 s 和 p 是某种容器存储的是字符串，我们又该如何处理呢？如果还按照遍历的方式显然不现实，所以我们需要引入『 有效字符计数器count』。</p> 
<ul><li>在每次『 进入窗口』之后，要维护count的值：如果该进入窗口的字符在 s哈希表 中的数目小于或等于 p哈希表 中的数目，那么就证明此时进入窗口的字符是 有效字符，count++；</li><li>在每次『 离开窗口』之前，要维护count的值：如果该离开窗口的字符在 s哈希表 中的数目小于或等于 p哈希表 中的数目，那么就证明要离开窗口的字符是 有效字符，count--；</li><li>每轮如果 有效字符数目与 p字符串长度相等，那么就证明此时 s字符串窗口内是 p字符串 的异位词，将left尾插到vector中。</li></ul> 
<div> 
 <pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; findAnagrams(string s, string p) {
        int hash1[26] = { 0 };
        for (auto e : p)
            hash1[e - 'a']++;
        int hash2[26] = { 0 };
        int left = 0, right = 0, count = 0;
        int np = p.size();
        int ns = s.size();
        vector&lt;int&gt; ret;
        while (right &lt; ns)
        {
            char in = s[right];
            if (++hash2[in - 'a'] &lt;= hash1[in - 'a']) count++;//进入窗口后维护count
            if (right - left + 1 &gt; np)//判断
            {
                char out = s[left++];
                if (hash2[out - 'a']-- &lt;= hash1[out - 'a']) count--;//离开窗口前维护count
            }
            if (count == np)
                ret.push_back(left);//更新结果
            right++;
        }
        return ret;
    }
};</code></pre> 
</div> 
<hr> 
<h2 id="7.%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2%EF%BC%88hard%EF%BC%89%C2%A0">7.串联所有单词的子串（hard） </h2> 
<p><a class="has-card" href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/" rel="nofollow" title="30. 串联所有单词的子串 - 力扣（LeetCode）"><span class="link-card-box"><span class="link-title">30. 串联所有单词的子串 - 力扣（LeetCode）</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/f4/0e/PcEycqhR_o.png" alt="icon-default.png?t=N7T8">https://leetcode.cn/problems/substring-with-concatenation-of-all-words/</span></span></a></p> 
<blockquote> 
 <p>给定一个字符串 <code>s</code><strong> </strong>和一个字符串数组 <code>words</code><strong>。</strong> <code>words</code> 中所有字符串 <strong>长度相同</strong>。</p> 
 <p> <code>s</code><strong> </strong>中的 <strong>串联子串</strong> 是指一个包含  <code>words</code> 中所有字符串以任意顺序排列连接起来的子串。</p> 
 <ul><li>例如，如果 <code>words = ["ab","cd","ef"]</code>， 那么 <code>"abcdef"</code>， <code>"abefcd"</code>，<code>"cdabef"</code>， <code>"cdefab"</code>，<code>"efabcd"</code>， 和 <code>"efcdab"</code> 都是串联子串。 <code>"acdbef"</code> 不是串联子串，因为他不是任何 <code>words</code> 排列的连接。</li></ul> 
 <p>返回所有串联子串在 <code>s</code><strong> </strong>中的开始索引。你可以以 <strong>任意顺序</strong> 返回答案。</p> 
</blockquote> 
<p><img alt="" height="739" src="https://images2.imgbox.com/90/9c/VSFShvBr_o.png" width="1045"></p> 
<p>其实本题就是第6题的升级版，只不过第6题的原子是字符，本题的原子是字符串，因为给定的容器words内存储的字符串都是等长的。</p> 
<p>所以整体的思路与第6题是完全相同的，只不过需要处理一些细节。</p> 
<hr> 
<p>细节一：</p> 
<p>执行一次滑动窗口逻辑不能包括所有情况，因为我们把字符串看作一个原子处理，但是字符串由一个个字符构成，一个字符串内的部分字符可以和另一个字符串的部分字符组成新的字符串，所以我们需要充分考虑所有情况，经过观察发现我们需要执行 字符串原子的长度次len 就能包含所有情况，比如：</p> 
<p class="img-center"><img alt="" height="127" src="https://images2.imgbox.com/04/c1/cGYhVixi_o.png" width="629"></p> 
<p>这反映到left和right开始的位置。 </p> 
<hr> 
<p>细节二：</p> 
<p>结束条件应为 right + 原子字符串长度len &gt; 字符串长度 。</p> 
<p>因为如果大于，right再往后就够不成原子字符串了。</p> 
<hr> 
<p> 细节三：</p> 
<p>right 与 left 每次移动 原子字符串长度len，而不是1。</p> 
<hr> 
<p>细节四：</p> 
<p>『 判断』条件应为 right - left + 1 &gt; 原子字符串长度len *  words中的字符串个数。</p> 
<p class="img-center"><img alt="" height="343" src="https://images2.imgbox.com/e5/18/CdZGOqoJ_o.png" width="1071"></p> 
<hr> 
<p>有了思路，画图独立完成代码，不要直接看博主的代码。 </p> 
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) {
        unordered_map&lt;string,int&gt; hash1;
        for(auto&amp; e: words)
            hash1[e]++;
        
        int ns=s.size();
        int nw=words.size();
        int len=words[0].size();
        vector&lt;int&gt; ret;
        for(int i=0;i&lt;len;i++)//细节1
        {
            int left=i,right=i,count=0;
            unordered_map&lt;string,int&gt; hash2;//维护窗口内单词的频次
            while(right + len &lt;= ns)//细节2
            {
                //进入窗口+维护count
                string in = s.substr(right,len);
                hash2[in]++;
                if(hash2[in]&lt;=hash1[in]) count++;

                //判断
                if(right-left+1 &gt; len*nw) //细节4
                {
                    //离开窗口+维护count
                    string out=s.substr(left,len);
                    if(hash2[out]&lt;=hash1[out]) count--;
                    hash2[out]--;
                    left+=len;//细节3
                }

                if(count==nw)
                {
                    ret.push_back(left);//更新结果
                }
                right+=len;//细节3
            }
        }
        return ret;
    }
};</code></pre> 
<p>到这代码还能进一步优化。</p> 
<hr> 
<p>细节五：</p> 
<p>维护count时，因为判断语句会被执行，所以如果进入窗口的字符串in在hash1中不存在，那么in这个字符串就会加入到hash1中，这无疑是一种浪费，所以在比较之前，我们可以判断一下in是否在hash1中，如果不在那也就没有比较的必要了，out那块同理。</p> 
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) {
        unordered_map&lt;string,int&gt; hash1;
        for(auto&amp; e: words)
            hash1[e]++;
        
        int ns=s.size();
        int nw=words.size();
        int len=words[0].size();
        vector&lt;int&gt; ret;
        for(int i=0;i&lt;len;i++)//细节1
        {
            int left=i,right=i,count=0;
            unordered_map&lt;string,int&gt; hash2;//维护窗口内单词的频次
            while(right + len &lt;= ns)//细节2
            {
                //进入窗口+维护count
                string in = s.substr(right,len);
                hash2[in]++;
                if(hash1.count(in) &amp;&amp; hash2[in]&lt;=hash1[in]) count++;//细节5

                //判断
                if(right-left+1 &gt; len*nw) //细节4
                {
                    //离开窗口+维护count
                    string out=s.substr(left,len);
                    if(hash1.count(out) &amp;&amp; hash2[out]&lt;=hash1[out]) count--;//细节5
                    hash2[out]--;
                    left+=len;//细节3
                }

                if(count==nw)
                {
                    ret.push_back(left);//更新结果
                }
                right+=len;//细节3
            }
        }
        return ret;
    }
};</code></pre> 
<hr> 
<h2 id="8.%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%97%E4%B8%B2%EF%BC%88hard%EF%BC%89">8.最小覆盖字串（hard）</h2> 
<p><a class="has-card" href="https://leetcode.cn/problems/minimum-window-substring/description/" rel="nofollow" title="76. 最小覆盖子串 - 力扣（LeetCode）"><span class="link-card-box"><span class="link-title">76. 最小覆盖子串 - 力扣（LeetCode）</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/3d/31/lTMkdsf9_o.png" alt="icon-default.png?t=N7T8">https://leetcode.cn/problems/minimum-window-substring/description/</span></span></a></p> 
<blockquote> 
 <p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>""</code> 。</p> 
 <p><strong>注意：</strong></p> 
 <ul><li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li><li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li></ul> 
</blockquote> 
<p><img alt="" height="521" src="https://images2.imgbox.com/ca/bf/2diqhDN6_o.png" width="1056"></p> 
<p> 同样的我们最先想到暴力枚举+哈希表的办法，但我们可以观察得到一定的规律做优化。</p> 
<hr> 
<p>第一个问题：</p> 
<p>当right右移到满足覆盖的条件时，left左移，right是否需要回退呢？</p> 
<p>其实不需要，因为中间的元素我们是知道的，只需要在left左移时判断right是否需要移动即可。</p> 
<ul><li>当left右移后，如果窗口内还满足覆盖条件，那么就证明right此时可以不动；</li><li>当left右移后，如果窗口内不满足覆盖条件，那么就证明right要右移寻找新的满足条件的字符。</li></ul> 
<p> 而且根究上面的进出窗口，我们可以知道出窗口之前，即left右移之前，此时窗口内是满足条件的字符串，所以『 更新结果』要在『 离开窗口』之前完成。</p> 
<p>并且如果窗口内一直满足覆盖条件，那么就应该一直出窗口，直到不满足覆盖条件为止，所以这里应该用while。</p> 
<hr> 
<p>第二个问题：</p> 
<p>如何判断是否满足覆盖条件，我们之前说利用哈希表，但两个哈希表又如何判断相等呢？</p> 
<p>之前的题目相信对你有所启发，我们是利用了一个 有效字符计数器count 来判断，在这里我们同样可以利用这个 count，但唯一不同的是，此 count 要统计的是字符种类，而不是字符数，因为题目说了，<strong><span style="background-color:#79c6cd;">对于 </span><code><span style="background-color:#79c6cd;">t</span></code><span style="background-color:#79c6cd;"> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 </span><code><span style="background-color:#79c6cd;">t</span></code><span style="background-color:#79c6cd;"> 中该字符数量。</span></strong></p> 
<p>所以进入窗口之后维护count的条件，应该是哈希表中对应字符的个数相等，此时才证明恰好覆盖。</p> 
<hr> 
<p> 有了思路，画图独立完成代码，不要直接看博主的代码。 </p> 
<pre><code class="language-cpp">class Solution {
public:
    string minWindow(string s, string t) {
        int hash1[128]={0};
        int kinds=0;
        for(auto ch : t)
        {
            if(hash1[ch]==0)//统计有效字符有多少种
                kinds++;
            hash1[ch]++;
        }

        int left=0,right=0,count=0;
        int ns=s.size();
        int nt=t.size();
        int hash2[128]={0};

        int minLen=INT_MAX,begin=-1;

        while(right&lt;ns)
        {
            //进入窗口+维护count
            char in=s[right];
            if(++hash2[in]==hash1[in]) count++;

            while(count==kinds)//判断
            {
                if(right-left+1 &lt;minLen)//更新结果
                {
                    minLen=right-left+1;
                    begin=left;
                }
                //离开窗口+维护count
                char out=s[left++];
                if(hash2[out]==hash1[out]) count--;
                hash2[out]--;
            }
            right++;
        }
        if(begin==-1) return "";
        else return s.substr(begin,minLen);
    }
};</code></pre> 
<hr> 
<p style="text-align:center;">『 <span style="color:#1c7331;"><strong>滑动窗口</strong></span>』<span style="color:#1c7331;"><strong>专题结束，接下来是『 二分算法』</strong></span></p> 
<hr> 
<p style="text-align:center;"><span style="color:#0d0016;"><strong>=========================================================================</strong></span></p> 
<p style="text-align:center;"><span style="color:#956fe7;"><strong>如果你对该系列文章有兴趣的话，欢迎持续关注博主动态，博主会持续输出优质内容</strong></span></p> 
<p style="text-align:center;"><span style="color:#0d0016;"><strong>🍎博主很需要大家的支持，你的支持是我创作的不竭动力🍎</strong></span></p> 
<p style="text-align:center;"><span style="color:#0d0016;"><strong>🌟</strong></span><span style="color:#79c6cd;"><strong>~ 点赞收藏＋关注 ~</strong></span><span style="color:#0d0016;"><strong>🌟</strong></span></p> 
<p style="text-align:center;"><span style="color:#0d0016;"><strong>=========================================================================</strong></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c2caa4a03348f533789574c1eca61cfd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">前端主流框架：项目运行命令 npm 详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6abaa7962e271bb1868bf5278b8e5d72/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">人工智能|机器学习——基于机器学习的舌苔检测</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>