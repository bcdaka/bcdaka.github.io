<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>golang——Gin框架及路由介绍 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/2bb5650382f22023506422b6b5533a64/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="golang——Gin框架及路由介绍">
  <meta property="og:description" content="一. 框架介绍 Gin是一个轻量级的Go语言Web框架，它具有高性能和简洁的设计。由于其快速的路由匹配和处理性能，Gin成为Go语言中最受欢迎的Web框架之一。
特点：
快速和轻量：Gin框架的设计注重性能和效率，采用了一些优化措施，使其成为一个快速而轻量级的框架。路由和中间件：Gin提供了强大的路由功能，支持参数传递，路由分组等特性。同时，它支持中间件的使用，可以方便的在请求处理过程中执行一系列的操作，比如身份验证，日志记录等。json解析：Gin内置了对json的解析和序列化支持，使得处理json数据变得简单而高效。支持插件：Gin允许开发者通过插件来扩展框架的功能，这样可以根据项目的需求进行灵活定制。 文档：
Github地址：https://github.com/gin-gonic/gin中文文档：https://gin-gonic.com/zh-cn/docs/ 二. 安装 要安装Gin软件包，您需要安装Go并首先设置Go工作区。
命令安装Gin go get github.com/gin-gonic/gin@latest 导入代码 import &#34;github.com/gin-gonic/gin&#34; 三. 第一个Gin应用 package main import ( &#34;net/http&#34; &#34;github.com/gin-gonic/gin&#34; ) func main() { //将应用切换到“发布模式”以提升性能 gin.SetMode(gin.ReleaseMode) //创建路由 r := gin.Default() //绑定路由规则，执行函数 //gin.Context，封装了request和response r.GET(&#34;/&#34;, func(c *gin.Context) { c.String(http.StatusOK, &#34;hello world&#34;) }) //监听端口，默认绑定端口8080 r.Run(&#34;:8080&#34;) } 代码解释：
gin.Default：创建一个Gin引擎。gin.Default()返回一个带有默认中间件的Gin引擎，包括Logger和Recovery中间件，用于日志记录和恢复。 r.Get(&#34;/&#34;, func(c *gin.Context){...})：定义了一个GET方法的路由，当访问路径是&#34;/&#34;时，执行后面的回调函数。c.String(http.StatusOK, &#34;hello world&#34;)：在回调函数中，通过c.String方法返回一个字符串&#34;hello world&#34;并设置HTTP状态码为200 OK。s.Run(&#34;:8080&#34;)：启动Web服务，监听在0.0.0.0:8080。如果不指定端口号，默认使用8080端口。此时，你可以通过浏览器或HTTP客户端访问http://localhost:8080，将会得到&#34;hello world&#34;的响应。 四. 应用举例 以下项目都是使用Gin框架开发的：
gorush：Go 编写的通知推送服务器。fnproject：容器原生，云 serverless 平台。photoprism：基于 Go 和 Google TensorFlow 实现的个人照片管理工具。krakend：拥有中间件的超高性能 API 网关。picfit：Go 编写的图像尺寸调整服务器。gotify：基于 WebSocket 进行实时消息收发的简单服务器。cds：企业级持续交付和 DevOps 自动化开源平台。 五.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-26T09:35:01+08:00">
    <meta property="article:modified_time" content="2024-06-26T09:35:01+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">golang——Gin框架及路由介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一. 框架介绍</h2> 
<p>        Gin是一个轻量级的Go语言Web框架，它具有高性能和简洁的设计。由于其快速的路由匹配和处理性能，Gin成为Go语言中最受欢迎的Web框架之一。</p> 
<p>        特点：</p> 
<ul><li>快速和轻量：Gin框架的设计注重性能和效率，采用了一些优化措施，使其成为一个快速而轻量级的框架。</li><li>路由和中间件：Gin提供了强大的路由功能，支持参数传递，路由分组等特性。同时，它支持中间件的使用，可以方便的在请求处理过程中执行一系列的操作，比如身份验证，日志记录等。</li><li>json解析：Gin内置了对json的解析和序列化支持，使得处理json数据变得简单而高效。</li><li>支持插件：Gin允许开发者通过插件来扩展框架的功能，这样可以根据项目的需求进行灵活定制。</li></ul> 
<p>文档：</p> 
<ul><li>Github地址：<a href="https://github.com/gin-gonic/gin" title="https://github.com/gin-gonic/gin">https://github.com/gin-gonic/gin</a></li><li>中文文档：<a href="https://gin-gonic.com/zh-cn/docs/" rel="nofollow" title="https://gin-gonic.com/zh-cn/docs/">https://gin-gonic.com/zh-cn/docs/</a></li></ul> 
<h2> 二. 安装</h2> 
<p>        要安装Gin软件包，您需要安装Go并首先设置Go工作区。</p> 
<ul><li>命令安装Gin</li></ul> 
<pre><code class="language-bash">go get github.com/gin-gonic/gin@latest</code></pre> 
<ul><li>导入代码</li></ul> 
<pre><code class="language-bash">import "github.com/gin-gonic/gin"</code></pre> 
<h2> 三. 第一个Gin应用</h2> 
<pre><code class="language-Go">package main

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

func main() {
	//将应用切换到“发布模式”以提升性能
	gin.SetMode(gin.ReleaseMode)
	//创建路由
	r := gin.Default()
	//绑定路由规则，执行函数
	//gin.Context，封装了request和response
	r.GET("/", func(c *gin.Context) {
		c.String(http.StatusOK, "hello world")
	})

	//监听端口，默认绑定端口8080
	r.Run(":8080")
}
</code></pre> 
<p><img alt="" class="left" height="366" src="https://images2.imgbox.com/a4/b3/ZoVui3MR_o.png" width="797"></p> 
<p>代码解释：</p> 
<ul><li>gin.Default：创建一个Gin引擎。gin.Default()返回一个带有默认中间件的Gin引擎，包括Logger和Recovery中间件，用于日志记录和恢复。</li><li> r.Get("/", func(c *gin.Context){...})：定义了一个GET方法的路由，当访问路径是"/"时，执行后面的回调函数。</li><li>c.String(http.StatusOK, "hello world")：在回调函数中，通过c.String方法返回一个字符串"hello world"并设置HTTP状态码为200 OK。</li><li>s.Run(":8080")：启动Web服务，监听在0.0.0.0:8080。如果不指定端口号，默认使用8080端口。此时，你可以通过浏览器或HTTP客户端访问http://localhost:8080，将会得到"hello world"的响应。</li></ul> 
<h2>四. 应用举例</h2> 
<p>        以下项目都是使用Gin框架开发的：</p> 
<ul><li><u><a href="https://link.zhihu.com/?target=https%3A//xie.infoq.cn/link%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252Fappleboy%252Fgorush" rel="nofollow" title="gorush">gorush</a></u>：Go 编写的通知推送服务器。</li><li><u><a href="https://link.zhihu.com/?target=https%3A//xie.infoq.cn/link%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252Ffnproject%252Ffn" rel="nofollow" title="fnproject">fnproject</a></u>：容器原生，云 serverless 平台。</li><li><u><a href="https://link.zhihu.com/?target=https%3A//xie.infoq.cn/link%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252Fphotoprism%252Fphotoprism" rel="nofollow" title="photoprism">photoprism</a></u>：基于 Go 和 Google TensorFlow 实现的个人照片管理工具。</li><li><u><a href="https://link.zhihu.com/?target=https%3A//xie.infoq.cn/link%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252Fdevopsfaith%252Fkrakend" rel="nofollow" title="krakend">krakend</a></u>：拥有中间件的超高性能 API 网关。</li><li><u><a href="https://link.zhihu.com/?target=https%3A//xie.infoq.cn/link%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252Fthoas%252Fpicfit" rel="nofollow" title="picfit">picfit</a></u>：Go 编写的图像尺寸调整服务器。</li><li><u><a href="https://link.zhihu.com/?target=https%3A//xie.infoq.cn/link%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252Fgotify%252Fserver" rel="nofollow" title="gotify">gotify</a></u>：基于 WebSocket 进行实时消息收发的简单服务器。</li><li><u><a href="https://link.zhihu.com/?target=https%3A//xie.infoq.cn/link%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252Fovh%252Fcds" rel="nofollow" title="cds">cds</a></u>：企业级持续交付和 DevOps 自动化开源平台。</li></ul> 
<h2>五. Gin入门</h2> 
<ul><li>gin.Engine</li></ul> 
<p>        在Gin里面，一个Web服务器被抽象成了Engnie。你可以在一个应用里面创建多个Engine实例，监听不同的端口。Engine承担了路由注册，接入中间件的核心职责。</p> 
<p>        它组合了RouterGroup，RouterGroup才是实现路由功能的核心组件。</p> 
<p class="img-center"><img alt="" height="458" src="https://images2.imgbox.com/2b/30/d26OJNlb_o.png" width="891"></p> 
<ul><li>gin.Context</li></ul> 
<p>        gin.Context是Gin里面的核心类型。字面意思是"上下文"，在Gin里面的核心职责是：</p> 
<ul><li>处理请求</li><li>返回响应 </li></ul> 
<p class="img-center"><img alt="" height="323" src="https://images2.imgbox.com/5c/18/NXJBMQUx_o.png" width="395"></p> 
<h2>六. 路由</h2> 
<h3>        6.1 介绍</h3> 
<ul><li>gin框架中采用的路由库是基于httprouter做的</li><li>地址为：<span style="color:#4183c4;">https://github.com/julienschmidt/httprouter </span></li><li> 支持Restful风格的API，意思是"表面层状态转化"，是一个互联网应用程序的API设计理念：URL定位资源。</li><li>可以创建路由组，为了管理相同的URL。</li></ul> 
<pre><code class="language-Go">package main

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

func main() {
	//将应用切换到“发布模式”以提升性能
	gin.SetMode(gin.ReleaseMode)
	//创建路由
	//默认使用了两个中间件Logger()，Recovery()
	r := gin.Default()

	r.GET("/hello1", func(c *gin.Context) {
		c.String(http.StatusOK, "hello1")
	})
	r.GET("/hello2", func(c *gin.Context) {
		c.String(http.StatusOK, "hello2")
	})

	//路由组1
	v1 := r.Group("/v1")
	{
		v1.GET("/hellov1", func(c *gin.Context) {
			c.String(http.StatusOK, "hello v1")
		})
		v1.GET("hellov11", func(c *gin.Context) {
			c.String(http.StatusOK, "hello v11")
		})
	}

	//路由组2
	v2 := r.Group("/v2")
	{
		v2.GET("/hellov2", func(c *gin.Context) {
			c.String(http.StatusOK, "hello v2")
		})

		v2.POST("/hellov22", func(c *gin.Context) {
			c.String(http.StatusOK, "hello v22")
		})
	}

	//监听端口，默认绑定端口8080
	r.Run(":8080")
}
</code></pre> 
<h3>        6.2  API参数 </h3> 
<ul><li>可以通过Context的Param方法来获取API参数</li></ul> 
<pre><code class="language-Go">package main

import (
	"fmt"
	"net/http"
	"strings"

	"github.com/gin-gonic/gin"
)

func main() {
	r := gin.Default()

	r.GET("/user/:name/*action", func(c *gin.Context) {
		name := c.Param("name")
		action := c.Param("action")

		fmt.Println(name, ":", action) //对于url /user/wy/aa 打印 wy : /aa
		//去除/
		action = strings.Trim(action, "/")
		c.String(http.StatusOK, name+" is "+action)
	})
	r.Run()
}
</code></pre> 
<h3>        6.3 URL参数</h3> 
<ul><li>URL参数可以通过DefaultQuery()或Query方法获取</li><li>DefaultQuery()若参数不存在，返回默认值。Query()若参数不存在，返回空串。</li></ul> 
<pre><code class="language-Go">package main

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

func main() {
	r := gin.Default()

	r.GET("/user", func(c *gin.Context) {
		name := c.Query("name")
		action := c.DefaultQuery("action", "")

		c.String(http.StatusOK, name+" is "+action)
	})
	r.Run()
}</code></pre> 
<p class="img-center"><img alt="" height="213" src="https://images2.imgbox.com/63/f9/UuH6Bs1i_o.png" width="516"></p> 
<h3>        6.4 表单参数</h3> 
<ul><li> <p>表单传输参数为POST请求，http常见的传输格式为四种：</p> 
  <ul><li> <p>application/json</p> </li><li> <p>application/x-www-form-urlencode</p> </li><li> <p>application/xml</p> </li><li> <p>mulipart/form-data</p> </li></ul></li><li> <p>表单参数可以通过PostForm()方法获取，该方法默认解析的是x-www-form-urlencode或form-data格式的参数。</p> </li></ul> 
<p>POST请求的html代码：</p> 
<pre><code class="language-html">&lt;!--test.html--&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
&lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
&lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form action="/form" method="post"
action="application/x-www-form-urlencoded"&gt;
用户名：&lt;input type="text" name="username" placeholder="请输入你的用户名"&gt;
&lt;br&gt;密&amp;nbsp;&amp;nbsp;&amp;nbsp;码：&lt;input type="password" name="userpassword"
placeholder="请输入你的密码"&gt; &lt;br&gt;
&lt;input type="submit" value="提交"&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<p>服务端代码</p> 
<pre><code class="language-Go">package main

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

func main() {
	r := gin.Default()

	//设置HTML文件所在目录
	r.LoadHTMLGlob("./*.html")
	//设置GET方法路由，成功返回test.html文件
	r.GET("/", func(c *gin.Context) {
		c.HTML(http.StatusOK, "test.html", nil)
	})

	//设置POST方法路由
	r.POST("/form", func(c *gin.Context) {
		//设置没有传的参数的默认值
		types := c.DefaultPostForm("type", "post")
		username := c.PostForm("username")
		password := c.PostForm("userpassword")

		c.String(http.StatusOK, "username:%s, userpassword:%s, types:%s", username, password, types)
	})

	r.Run()
}</code></pre> 
<p>演示：</p> 
<p class="img-center"><img alt="" height="651" src="https://images2.imgbox.com/cb/6f/rN56R7W1_o.png" width="544"></p> 
<h3>         6.5 上传文件</h3> 
<p>上传单个文件：</p> 
<ul><li>multipart/form-data格式用于上传文件</li><li>gin文件上传与原生的net/http方法类似，不同在于gin吧原生的request封装到了c.Request中。</li></ul> 
<pre><code class="language-Go">package main

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

func main() {
	r := gin.Default()

	//设置HTML文件所在目录
	r.LoadHTMLGlob("./*.html")
	//设置GET方法路由，成功返回test.html文件
	r.GET("/", func(c *gin.Context) {
		c.HTML(http.StatusOK, "test.html", nil)
	})

	//设置POST方法路由
	r.MaxMultipartMemory = 8 &lt;&lt; 20 //限制上传最大尺寸
	r.POST("/upload", func(c *gin.Context) {
		//用于获取表单信息中file格式的参数，并且返回一个文件流
		file, err := c.FormFile("file") //html中的name
		if err != nil {
			c.String(500, "上次图片错误")
		}
		//参数1为指定需要保存操作的文件，参数2为指定保存路径。
		c.SaveUploadedFile(file, file.Filename)
		//返回文件名
		c.String(http.StatusOK, file.Filename)

	})

	r.Run()
}</code></pre> 
<p> 演示：</p> 
<p class="img-center"><img alt="" height="558" src="https://images2.imgbox.com/19/13/CT5fmHsg_o.png" width="837"></p> 
<p>上传特定文件：</p> 
<p>        有的用户上传文件需要限制文件的类型以及上传文件的大小，可以基于原生的函数写法自己写一个可以限制大小以及文件类型的上传函数。</p> 
<p class="img-center"><img alt="" height="242" src="https://images2.imgbox.com/d2/43/zHxdRGwp_o.png" width="434"></p> 
<pre><code class="language-Go">package main

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

func main() {
	r := gin.Default()

	r.LoadHTMLGlob("./*.html")
	r.GET("/", func(c *gin.Context) {
		c.HTML(http.StatusOK, "test.html", nil)
	})

	r.POST("/upload", func(c *gin.Context) {
		_, header, err := c.Request.FormFile("file")
		if err != nil {
			c.String(405, "文件错误")
			return
		}

		if header.Size &gt; 1024*1024*2 {
			c.String(406, "文件太大")
			return
		}

		if header.Header.Get("Content-Type") != "image/png" {
			c.String(407, "只允许上传图片")
			return
		}

		c.SaveUploadedFile(header, header.Filename)
		c.String(http.StatusOK, header.Filename)
	})

	r.Run()
}</code></pre> 
<p>上传多个文件：</p> 
<pre><code class="language-Go">package main

import (
	"fmt"
	"net/http"

	"github.com/gin-gonic/gin"
)

func main() {
	r := gin.Default()

	r.LoadHTMLGlob("./*.html")
	r.GET("/", func(c *gin.Context) {
		c.HTML(http.StatusOK, "test.html", nil)
	})
	//限制表单上传大小8MB 默认32MB
	r.MaxMultipartMemory = 8 &lt;&lt; 20 * 2
	r.POST("/upload", func(c *gin.Context) {
		//用于获取multipart表单。当用户通过表单上传文件时，浏览器通常会将表单编码为multipart/form-data格式。
		form, err := c.MultipartForm()
		if err != nil {
			c.String(http.StatusBadRequest, fmt.Sprintf("get a %v", err))
			return
		}
		//获取所有文件
		files := form.File["files"]
		//遍历所有文件
		for _, file := range files {
			if err := c.SaveUploadedFile(file, file.Filename); err != nil {
				c.String(http.StatusBadRequest, fmt.Sprintf("upload get a %v", err))
				return
			}
		}
		c.String(http.StatusOK, fmt.Sprintf("upload %d files ok", len(files)))
	})

	r.Run()
}</code></pre> 
<p class="img-center"><img alt="" height="318" src="https://images2.imgbox.com/42/63/OZ1USTsW_o.png" width="940"></p> 
<h3>         6.6 路由原理</h3> 
<p>        httprouter会将所有路由规则构造一棵前缀树。</p> 
<p>        例如有root，and，as，at，cn，com</p> 
<p class="img-center"><img alt="" height="305" src="https://images2.imgbox.com/fb/76/OI7VTykI_o.png" width="781"></p> 
<h3>        6.7 路由拆分与注册</h3> 
<ul><li>基本的路由注册</li></ul> 
<p>         下面最基础的gin路由注册方式，使用于路由条目比较少的简单项目或者项目demo。</p> 
<pre><code class="language-Go">package main

import (
	"fmt"
	"net/http"

	"github.com/gin-gonic/gin"
)

func sayHello(c *gin.Context) {
	c.JSON(http.StatusOK, gin.H{
		"message": "hello go",
	})
}

func main() {
	r := gin.Default()
	r.GET("/hello", sayHello)
	if err := r.Run(); err != nil {
		fmt.Printf("startup server err : %v", err)
	}
}</code></pre> 
<ul><li>路由拆分成单独文件或包 </li></ul> 
<p>        当项目的规模增大后，就不适合继续在项目的main.go文件中实现路由注册相关逻辑了，我们会倾向于把路由部分的代码都拆分出来，形成一个单独的文件或包。</p> 
<ul><li>形成单独文件</li></ul> 
<p class="img-center"><img alt="" height="771" src="https://images2.imgbox.com/80/b7/zCrQ50sB_o.png" width="1073"></p> 
<ul><li>形成独立的包 </li></ul> 
<p class="img-center"><img alt="" height="731" src="https://images2.imgbox.com/39/57/EMSfnn2V_o.png" width="855"></p> 
<ul><li>拆分成多个文件</li></ul> 
<p>        当业务规模继续膨胀，单独的一个router文件或包已经满足不了我们的需求了。 因为我们把所有的路由注册都写在一个SetRouter函数中的话会很复杂。</p> 
<p>        我们可以将其拆分为多个文件。</p> 
<p class="img-center"><img alt="" height="855" src="https://images2.imgbox.com/8e/be/fCZUcLkn_o.png" width="867"></p> 
<ul><li>路由拆分到不同APP </li></ul> 
<p>        有时候项目规模太大，那么我们就更倾向于把业务拆分的更加详细，例如把不同的业务代码拆分成不同的APP。</p> 
<p>        因此我们在项目目录下单独定义一个app目录，用来存放我们不同业务线的代码文件，这样就很容易进行横向扩展。</p> 
<p>目录结构：</p> 
<p class="img-center"><img alt="" height="250" src="https://images2.imgbox.com/91/94/au9OOmwT_o.png" width="203"></p> 
<p></p> 
<p>app/blog:</p> 
<p class="img-center"><img alt="" height="650" src="https://images2.imgbox.com/42/17/tR5D9M9R_o.png" width="744"></p> 
<p>代码如下： </p> 
<p>gin/app/shop: </p> 
<p class="img-center"><img alt="" height="482" src="https://images2.imgbox.com/dd/87/qMc9r98T_o.png" width="777"></p> 
<p> gin/router/router.go</p> 
<p class="img-center"><img alt="" height="473" src="https://images2.imgbox.com/3d/73/RYzgAWGn_o.png" width="630"></p> 
<p> gin/main.go</p> 
<p class="img-center"><img alt="" height="337" src="https://images2.imgbox.com/f0/b2/wx3tffSH_o.png" width="598"></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/679387bdb0c400255bf0c2e46d4b1e10/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android 解决 “Module was compiled with an incompatible version of Kotlin“ 问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8d0037a7738f3b33e388339e08a7e151/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【乐吾乐2D可视化组态编辑器】连线</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>