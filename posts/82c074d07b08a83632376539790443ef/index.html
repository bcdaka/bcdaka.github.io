<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;】 ——【模板初阶】——基础详解 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/82c074d07b08a83632376539790443ef/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;】 ——【模板初阶】——基础详解">
  <meta property="og:description" content="目录
1. 泛型编程
1.1 泛型编程的概念
1.2 泛型编程的历史与发展
1.3 泛型编程的优势
1.4 泛型编程的挑战
2. 函数模板
2.1 函数模板概念
2.2 函数模板格式
2.3 函数模板的原理
2.4 函数模板的实例化
2.5 模板参数的匹配原则
2.6 函数模板的特化
2.7 函数模板的使用注意事项
2.8 函数模板的高级用法
3. 类模板
3.1 类模板的定义格式
3.2 类模板的实例化
3.3 类模板的特化
3.4 类模板成员函数的定义
3.5 类模板的使用注意事项
3.6 类模板的高级用法
结论
专栏：C&#43;&#43;学习笔记
第一卷：C&#43;&#43; ———前言知识
第二卷：【C&#43;&#43;】——入门基础知识
第二卷升华：【C&#43;&#43;】——入门基础知识超详解
第三卷：第一篇【C&#43;&#43;】————类与对象(上)-基础知识
第三卷：第一篇升华：剖析【C&#43;&#43;】——类与对象(上)超详解——小白篇
第三卷：第二篇：剖析【C&#43;&#43;】——类与对象(中)——小白篇—超详解
第三卷：第三篇：剖析【C&#43;&#43;】——类和对象(下篇)——超详解——小白篇
第四卷：【C/C&#43;&#43;】——小白初步了解——内存管理
在C&#43;&#43;中，模板是一种强大的特性，可以实现代码的泛型编程，从而减少代码的重复，提高代码的复用性和可维护性。本文将详细讲解C&#43;&#43;模板，涵盖以下几部分内容：
泛型编程函数模板类模板 1. 泛型编程 1.1 泛型编程的概念 泛型编程是一种编程范式，旨在编写与类型无关的代码，使得同一段代码能够处理不同的数据类型。这种编程方式提高了代码的通用性和复用性。在C&#43;&#43;中，模板是实现泛型编程的核心机制。
1.2 泛型编程的历史与发展 泛型编程的概念最早由Alexander Stepanov和David Musser在1980年代提出。1990年代，泛型编程在C&#43;&#43;标准模板库（STL）的实现中得到了广泛应用。STL提供了一组基于模板的容器、算法和迭代器，这些组件极大地提高了C&#43;&#43;程序的效率和灵活性。
1.3 泛型编程的优势 代码复用：模板允许开发人员编写一次代码，适用于多种数据类型，减少了代码的重复。类型安全：模板在编译时进行类型检查，避免了运行时错误。高效：模板在编译时实例化，生成的代码与手写的特定类型代码一样高效。 1.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-30T22:42:10+08:00">
    <meta property="article:modified_time" content="2024-06-30T22:42:10+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;】 ——【模板初阶】——基础详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>目录</strong></p> 
<p style="margin-left:0px;"><a href="#1.%20%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B" rel="nofollow">1. 泛型编程</a></p> 
<p style="margin-left:40px;"><a href="#1.1%20%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">1.1 泛型编程的概念</a></p> 
<p style="margin-left:40px;"><a href="#1.2%20%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%E7%9A%84%E5%8E%86%E5%8F%B2%E4%B8%8E%E5%8F%91%E5%B1%95" rel="nofollow">1.2 泛型编程的历史与发展</a></p> 
<p style="margin-left:0px;"><a href="#1.3%20%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%E7%9A%84%E4%BC%98%E5%8A%BF" rel="nofollow">1.3 泛型编程的优势</a></p> 
<p style="margin-left:0px;"><a href="#1.4%20%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8C%91%E6%88%98" rel="nofollow">1.4 泛型编程的挑战</a></p> 
<p style="margin-left:0px;"><a href="#2.%20%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF" rel="nofollow">2. 函数模板</a></p> 
<p style="margin-left:40px;"><a href="#2.1%20%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%A6%82%E5%BF%B5" rel="nofollow">2.1 函数模板概念</a></p> 
<p style="margin-left:40px;"><a href="#2.2%20%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%A0%BC%E5%BC%8F" rel="nofollow">2.2 函数模板格式</a></p> 
<p style="margin-left:40px;"><a href="#2.3%20%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%8E%9F%E7%90%86" rel="nofollow">2.3 函数模板的原理</a></p> 
<p style="margin-left:40px;"><a href="#2.4%20%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96" rel="nofollow">2.4 函数模板的实例化</a></p> 
<p style="margin-left:40px;"><a href="#2.5%20%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E7%9A%84%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99" rel="nofollow">2.5 模板参数的匹配原则</a></p> 
<p style="margin-left:40px;"><a href="#2.6%20%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%89%B9%E5%8C%96" rel="nofollow">2.6 函数模板的特化</a></p> 
<p style="margin-left:40px;"><a href="#2.7%20%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" rel="nofollow">2.7 函数模板的使用注意事项</a></p> 
<p style="margin-left:40px;"><a href="#2.8%20%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95" rel="nofollow">2.8 函数模板的高级用法</a></p> 
<p style="margin-left:0px;"><a href="#3.%20%E7%B1%BB%E6%A8%A1%E6%9D%BF" rel="nofollow">3. 类模板</a></p> 
<p style="margin-left:40px;"><a href="#3.1%20%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F" rel="nofollow">3.1 类模板的定义格式</a></p> 
<p style="margin-left:40px;"><a href="#3.2%20%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96" rel="nofollow">3.2 类模板的实例化</a></p> 
<p style="margin-left:40px;"><a href="#3.3%20%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%89%B9%E5%8C%96" rel="nofollow">3.3 类模板的特化</a></p> 
<p style="margin-left:40px;"><a href="#3.4%20%E7%B1%BB%E6%A8%A1%E6%9D%BF%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">3.4 类模板成员函数的定义</a></p> 
<p style="margin-left:40px;"><a href="#3.5%20%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" rel="nofollow">3.5 类模板的使用注意事项</a></p> 
<p style="margin-left:40px;"><a href="#3.6%20%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95" rel="nofollow">3.6 类模板的高级用法</a></p> 
<p style="margin-left:0px;"><a href="#%E7%BB%93%E8%AE%BA" rel="nofollow">结论</a></p> 
<hr> 
<p> </p> 
<p> </p> 
<p> </p> 
<p style="text-align:center;"><img src="https://images2.imgbox.com/81/58/Ynb3SOZE_o.png" alt="823d638fbfbd45f08e401991f36f26ae.png"><img src="https://images2.imgbox.com/b5/12/mHk63wel_o.gif" alt="d6b1d13a84e94373a3d5dffec2d17b20.gif"> </p> 
<blockquote> 
 <p>专栏：<a href="https://blog.csdn.net/2303_77720864/category_12662228.html" title="C++学习笔记">C++学习笔记</a></p> 
 <p><a href="https://blog.csdn.net/2303_77720864/article/details/138634435" title="第一卷：C++ ———前言知识">第一卷：C++ ———前言知识</a></p> 
 <p><a href="https://xiaolihenzhizhuo.blog.csdn.net/article/details/138645621?spm=1001.2014.3001.5502" rel="nofollow" title="第二卷：【C++】——入门基础知识">第二卷：【C++】——入门基础知识</a></p> 
 <p><a href="https://xiaolihenzhizhuo.blog.csdn.net/article/details/139222108?spm=1001.2014.3001.5502" rel="nofollow" title="第二卷升华：【C++】——入门基础知识超详解">第二卷升华：【C++】——入门基础知识超详解</a></p> 
 <p><a href="https://xiaolihenzhizhuo.blog.csdn.net/article/details/138758573?spm=1001.2014.3001.5502" rel="nofollow" title="第三卷：第一篇【C++】————类与对象(上)-基础知识">第三卷：第一篇【C++】————类与对象(上)-基础知识</a></p> 
 <p><a href="https://xiaolihenzhizhuo.blog.csdn.net/article/details/139248534?spm=1001.2014.3001.5502" rel="nofollow" title="第三卷：第一篇升华：剖析【C++】——类与对象(上)超详解——小白篇">第三卷：第一篇升华：剖析【C++】——类与对象(上)超详解——小白篇</a></p> 
 <p><a href="https://blog.csdn.net/2303_77720864/article/details/139264244?spm=1001.2014.3001.5501" title="第三卷：第二篇：剖析【C++】——类与对象(中)——小白篇—超详解">第三卷：第二篇：剖析【C++】——类与对象(中)——小白篇—超详解</a></p> 
 <p><a href="https://blog.csdn.net/2303_77720864/article/details/139350138?spm=1001.2014.3001.5501" title="第三卷：第三篇：剖析【C++】——类和对象(下篇)——超详解——小白篇">第三卷：第三篇：剖析【C++】——类和对象(下篇)——超详解——小白篇</a></p> 
 <p><a class="link-info" href="https://mp.csdn.net/mp_blog/creation/editor/139402054" title="第四卷：【C/C++】——小白初步了解——内存管理">第四卷：【C/C++】——小白初步了解——内存管理</a></p> 
</blockquote> 
<p>在C++中，模板是一种强大的特性，可以实现代码的泛型编程，从而减少代码的重复，提高代码的复用性和可维护性。本文将详细讲解C++模板，涵盖以下几部分内容：</p> 
<ol><li>泛型编程</li><li>函数模板</li><li>类模板</li></ol> 
<h2>1. 泛型编程</h2> 
<h3>1.1 泛型编程的概念</h3> 
<p>泛型编程是一种编程范式，旨在编写与类型无关的代码，使得同一段代码能够处理不同的数据类型。这种编程方式提高了代码的通用性和复用性。在C++中，模板是实现泛型编程的核心机制。</p> 
<h3>1.2 泛型编程的历史与发展</h3> 
<p>泛型编程的概念最早由Alexander Stepanov和David Musser在1980年代提出。1990年代，泛型编程在C++标准模板库（STL）的实现中得到了广泛应用。STL提供了一组基于模板的容器、算法和迭代器，这些组件极大地提高了C++程序的效率和灵活性。</p> 
<h2>1.3 泛型编程的优势</h2> 
<ul><li><strong>代码复用</strong>：模板允许开发人员编写一次代码，适用于多种数据类型，减少了代码的重复。</li><li><strong>类型安全</strong>：模板在编译时进行类型检查，避免了运行时错误。</li><li><strong>高效</strong>：模板在编译时实例化，生成的代码与手写的特定类型代码一样高效。</li></ul> 
<h2>1.4 泛型编程的挑战</h2> 
<p>尽管泛型编程有许多优势，但它也带来了一些挑战：</p> 
<ul><li><strong>复杂性</strong>：模板代码的语法和错误信息较为复杂，初学者可能难以理解。</li><li><strong>编译时间</strong>：模板实例化会增加编译时间，尤其是在大型项目中。</li><li><strong>代码膨胀</strong>：由于模板实例化会生成多个版本的函数或类，可能导致可执行文件的体积增大。</li></ul> 
<h2>2. 函数模板</h2> 
<h3>2.1 函数模板概念</h3> 
<p>函数模板是用于创建通用函数的蓝图，允许我们编写与数据类型无关的函数。通过使用函数模板，可以避免为不同数据类型编写相同功能的多个函数，从而减少代码重复。</p> 
<h3>2.2 函数模板格式</h3> 
<p>函数模板的定义格式如下：</p> 
<pre><code>template &lt;typename T&gt;
返回类型 函数名(参数列表) {
    // 函数体
}
</code></pre> 
<p>例如，一个简单的加法函数模板：</p> 
<pre><code>template &lt;typename T&gt;
T add(T a, T b) {
    return a + b;
}
</code></pre> 
<h3>2.3 函数模板的原理</h3> 
<p>函数模板的原理是通过在编译期间进行模板的实例化，将模板参数替换为实际参数类型，从而生成具体的函数版本。例如，调用<code>add&lt;int&gt;(1, 2)</code>会实例化一个<code>int</code>类型的<code>add</code>函数：</p> 
<pre><code>int add(int a, int b) {
    return a + b;
}
</code></pre> 
<h3>2.4 函数模板的实例化</h3> 
<p>函数模板的实例化可以是显式的或隐式的。隐式实例化是指编译器自动推断模板参数类型，而显式实例化是我们明确指定模板参数类型。例如：</p> 
<p>隐式实例化：</p> 
<pre><code>add(1, 2); // 推断为 add&lt;int&gt;(1, 2)
</code></pre> 
<p>显式实例化：</p> 
<pre><code>add&lt;int&gt;(1, 2);
</code></pre> 
<h3>2.5 模板参数的匹配原则</h3> 
<p>模板参数的匹配原则是编译器如何确定模板参数类型的规则。当调用函数模板时，编译器会尝试匹配模板参数和函数参数类型。如果匹配成功，则进行实例化；否则，编译会失败。匹配原则包括：</p> 
<ol><li><strong>类型推断</strong>：编译器根据传递的实际参数类型推断模板参数类型。例如，<code>add(1, 2)</code>推断为<code>add&lt;int&gt;(1, 2)</code>。</li><li><strong>显式指定</strong>：调用模板函数时显式指定模板参数类型。例如，<code>add&lt;int&gt;(1, 2)</code>。</li><li><strong>默认参数</strong>：模板参数可以有默认类型。例如： <pre><code>template &lt;typename T = int&gt;
T multiply(T a, T b) {
    return a * b;
}
</code></pre> </li></ol> 
<h3>2.6 函数模板的特化</h3> 
<p>在某些情况下，我们可能需要对特定类型进行特殊处理，这时可以使用模板特化。模板特化允许我们为某些特定类型定义模板的特化版本。例如：</p> 
<pre><code>template &lt;&gt;
const char* add&lt;const char*&gt;(const char* a, const char* b) {
    static char result[100];
    strcpy(result, a);
    strcat(result, b);
    return result;
}
</code></pre> 
<p>上述代码特化了<code>add</code>函数模板，使其可以处理<code>const char*</code>类型的字符串连接。</p> 
<h3>2.7 函数模板的使用注意事项</h3> 
<blockquote> 
 <ol><li><strong>模板参数推断</strong>：在调用模板函数时，编译器会根据传递的参数推断模板参数类型。如果推断失败，需要显式指定模板参数类型。</li><li><strong>编译错误信息</strong>：模板代码的编译错误信息通常比较复杂，调试时需要耐心和细致。特别是在模板嵌套和特化时，错误信息可能难以解读。</li><li><strong>代码膨胀</strong>：由于模板实例化会生成多个函数版本，可能导致可执行文件体积增大。每次实例化模板时，都会生成一份新的代码副本，这在某些情况下可能导致二进制文件过大。</li><li><strong>与非模板函数的冲突</strong>：在同一作用域中，如果存在与模板函数签名相同的非模板函数，可能会导致二义性和冲突。为避免这种情况，可以使用命名空间或显式实例化来区分模板函数和非模板函数。</li></ol> 
</blockquote> 
<h3>2.8 函数模板的高级用法</h3> 
<p>函数模板的高级用法包括模板参数包（variadic templates）、模板别名（alias templates）等。例如，使用模板参数包实现一个通用的打印函数：</p> 
<pre><code>template &lt;typename T&gt;
void print(T arg) {
    std::cout &lt;&lt; arg &lt;&lt; std::endl;
}

template &lt;typename T, typename... Args&gt;
void print(T arg, Args... args) {
    std::cout &lt;&lt; arg &lt;&lt; ", ";
    print(args...);
}
</code></pre> 
<p>上述代码利用模板参数包实现了一个递归打印函数，可以处理任意数量的参数。 </p> 
<h2>3. 类模板</h2> 
<h3>3.1 类模板的定义格式</h3> 
<p>类模板允许我们创建一个通用的类，该类可以处理不同的数据类型。类模板的定义格式如下：</p> 
<pre><code>template &lt;typename T&gt;
class ClassName {
    // 类成员和方法
};
</code></pre> 
<p>例如，一个简单的栈（Stack）类模板：</p> 
<pre><code>template &lt;typename T&gt;
class Stack {
private:
    std::vector&lt;T&gt; elements;

public:
    void push(T const&amp; element) {
        elements.push_back(element);
    }

    void pop() {
        elements.pop_back();
    }

    T top() const {
        return elements.back();
    }
};
</code></pre> 
<p>在这个例子中，<code>Stack</code>类模板定义了一个通用的栈，可以存储任意类型的数据。 </p> 
<h3>3.2 类模板的实例化</h3> 
<p>类模板的实例化类似于函数模板。例如：</p> 
<pre><code>Stack&lt;int&gt; intStack;
intStack.push(1);
intStack.push(2);
intStack.pop();
int topElement = intStack.top();
</code></pre> 
<p>以上代码实例化了一个<code>int</code>类型的<code>Stack</code>对象，并对其进行了操作。</p> 
<h3>3.3 类模板的特化</h3> 
<p>与函数模板类似，我们也可以对类模板进行特化。例如：</p> 
<pre><code>template &lt;&gt;
class Stack&lt;bool&gt; {
private:
    std::vector&lt;bool&gt; elements;

public:
    void push(bool element) {
        elements.push_back(element);
    }

    void pop() {
        elements.pop_back();
    }

    bool top() const {
        return elements.back();
    }
};
</code></pre> 
<p>上述代码特化了<code>Stack</code>类模板，使其可以处理<code>bool</code>类型。</p> 
<h3>3.4 类模板成员函数的定义</h3> 
<p>类模板的成员函数可以在类外定义。定义时需要再次指定模板参数。例如：</p> 
<pre><code>template &lt;typename T&gt;
void Stack&lt;T&gt;::push(T const&amp; element) {
    elements.push_back(element);
}

template &lt;typename T&gt;
void Stack&lt;T&gt;::pop() {
    elements.pop_back();
}

template &lt;typename T&gt;
T Stack&lt;T&gt;::top() const {
    return elements.back();
}
</code></pre> 
<p>这种定义方式使得类模板的实现更加清晰和模块化。</p> 
<h3>3.5 类模板的使用注意事项</h3> 
<blockquote> 
 <ol><li><strong>模板参数推断</strong>：在实例化类模板时，需要明确指定模板参数类型，编译器无法自动推断。</li><li><strong>代码膨胀</strong>：由于模板实例化会生成多个类版本，可能导致可执行文件体积增大。每次实例化模板时，都会生成一份新的代码副本，这在某些情况下可能导致二进制文件过大。</li><li><strong>编译错误信息</strong>：模板代码的编译错误信息通常比较复杂，调试时需要耐心和细致。特别是在模板嵌套和特化时，错误信息可能难以解读。</li><li><strong>与非模板类的冲突</strong>：在同一作用域中，如果存在与模板类签名相同的非模板类，可能会导致二义性和冲突。为避免这种情况，可以使用命名空间或显式实例化来区分模板类和非模板类。</li></ol> 
</blockquote> 
<h3>3.6 类模板的高级用法</h3> 
<p>类模板的高级用法包括嵌套模板、模板模板参数（template template parameter）等。例如，使用模板模板参数实现一个通用的容器适配器：</p> 
<pre><code>template &lt;typename T, template &lt;typename&gt; class Container = std::deque&gt;
class Stack {
private:
    Container&lt;T&gt; elements;

public:
    void push(T const&amp; element) {
        elements.push_back(element);
    }

    void pop() {
        elements.pop_back();
    }

    T top() const {
        return elements.back();
    }

    bool isEmpty() const {
        return elements.empty();
    }
};
</code></pre> 
<p>上述代码定义了一个通用的<code>Stack</code>类模板，可以使用不同的容器类型（如<code>std::deque</code>、<code>std::vector</code>等）作为底层存储。 </p> 
<p><img src="https://images2.imgbox.com/54/e0/l0V9HjXR_o.png" alt="ae313b7f5e334a7483c315433dae79d7.png"></p> 
<h2>结论</h2> 
<p>通过函数模板和类模板，C++提供了强大的泛型编程能力，使得代码可以更加通用和复用。在实际编程中，合理地使用模板可以显著提高代码的质量和维护性。希望通过本文的讲解，大家能够对C++模板有一个全面的理解，并能够在自己的项目中灵活应用。</p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c665e05b99501dd8ab240314bfdeb5c7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【C&#43;&#43;深度探索】继承机制详解（一）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7b3f4665cead1ca7c9fc3abf33c99184/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">chrome-base源码分析(1)macros模块</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>