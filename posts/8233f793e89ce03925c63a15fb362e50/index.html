<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言/数据结构——每日一题（环形链表的约瑟夫问题） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/8233f793e89ce03925c63a15fb362e50/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C语言/数据结构——每日一题（环形链表的约瑟夫问题）">
  <meta property="og:description" content="一.前言 今天在牛客网上面看到了一道环形链表题，想着和大家们分享一下。可能我有点笨，那道题的链接我没搞好，所以很抱歉，只能麻烦大家们看一下截屏的题目信息了。废话不多数，让我们开始今天的题目分享吧。
二.正文 1.1题目描述 1.2题目解析 这是一道环形链表题。
本体虽然没有明确指出但是它默认结构体是:
struct ListNode { int val; ListNode* next; }; 1. 而且这道题没有给你设置好哪怕一个节点，因此我们只能先通过先通过malloc函数自己创建节点。而创建一个环形链表就需要多个节点，为了方便后面使用，因此我写了一个函数BuyNode专门来创建节点。
newnode是我为了接受malloc开辟的那块节点空间的地址。
2. 上面提到我们想要创建一个环形，链表，因此需要多个节点做到首尾相连。为此我定义了一个BuyList函数来创建环形链表。
phead是我们一开始就建立的指向头节点的指针，ptail代表的是尾节点。因为开始ptai=phead（这代表着ptail和phead都指向头节点）
上面右边是左边代码的具现图。
值得注意的是如果没有把最后的尾节点ptail和我们的头节点phead相链接的话，最后具线图将会变成下面这个样子。（下面这个图是错误示范，上面的图才是我们想要的效果）
且该函数返回的是尾节点的地址，即节点5而不是1。这一点很重要！！！
3. 主函数ysf函数中：我们用prev来接受BuyList传递的5节点指针。pcur是prev的下一个节点，初始pcur指向1节点。count是我们的计数变量，什么时候count==m，pcur代表的这个人就死掉了（代码中是free掉了）
如果count！=m，我们仅仅需要让prev指向pcur所在节点，以及pcur指向下一个节点，并让count&#43;&#43;。
否则，即（count==m）那么prev将会指向pcur指向的下一个指针，并且pcur所指向的指针会被free掉，然后pcur指向prev指向的下一个节点。最后不要忘了让count=1重新计数。
依次循环直到不满足条件（pcur-&gt;next!=pcur）后，退出循环。
1.3代码实现 /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param n int整型 * @param m int整型 * @return int整型 */ typedef struct ListNode ListNode; ListNode* BuyNode(int x) { ListNode* newnode=(ListNode*)malloc(sizeof(ListNode)); if(newnode==NULL) { return NULL; } else { newnode-&gt;next=NULL; newnode-&gt;val=x; return newnode; } } ListNode* BuyList(int n) { ListNode* phead=BuyNode(1); ListNode* ptail=phead; for(int i=2;i&lt;=n;i&#43;&#43;) { ptail-&gt;next=BuyNode(i); ptail=ptail-&gt;next; } ptail-&gt;next=phead; return ptail; } int ysf(int n, int m ) { ListNode* prev=BuyList(n); ListNode* pcur=prev-&gt;next; int count=1; while((pcur-&gt;next)!">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-03T18:08:17+08:00">
    <meta property="article:modified_time" content="2024-05-03T18:08:17+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言/数据结构——每日一题（环形链表的约瑟夫问题）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一.前言</h2> 
<p>今天在牛客网上面看到了一道环形链表题，想着和大家们分享一下。可能我有点笨，那道题的链接我没搞好，所以很抱歉，只能麻烦大家们看一下截屏的题目信息了。废话不多数，让我们开始今天的题目分享吧。</p> 
<h2>二.正文</h2> 
<h3>1.1题目描述</h3> 
<p><img alt="" height="891" src="https://images2.imgbox.com/04/71/0bAJBZ1O_o.png" width="880"></p> 
<h3>1.2题目解析</h3> 
<p>这是一道环形链表题。</p> 
<p><span style="color:#ff9900;"><strong>本体虽然没有明确指出但是它默认结构体是:</strong></span></p> 
<pre><code class="language-cpp">struct ListNode
{
int val;
ListNode* next;
};</code></pre> 
<p>1. 而且这道题没有给你设置好哪怕一个节点，因此我们只能先通过先通过malloc函数自己创建节点。而创建一个环形链表就需要多个节点，为了方便后面使用，因此我写了一个函数BuyNode专门来创建节点。</p> 
<p>newnode是我为了接受malloc开辟的那块节点空间的地址。</p> 
<p><img alt="" height="284" src="https://images2.imgbox.com/68/dd/pbdZt1FW_o.png" width="472"></p> 
<p>2. 上面提到我们想要创建一个环形，链表，因此需要多个节点做到首尾相连。为此我定义了一个BuyList函数来创建环形链表。</p> 
<p>phead是我们一开始就建立的指向头节点的指针，ptail代表的是尾节点。因为开始ptai=phead（这代表着ptail和phead都指向头节点）</p> 
<p><img alt="" height="231" src="https://images2.imgbox.com/fe/22/DZ9S612a_o.png" width="298"><img alt="" height="229" src="https://images2.imgbox.com/85/c3/hEdWi597_o.png" width="264"></p> 
<p>上面右边是左边代码的具现图。</p> 
<p>值得注意的是如果没有把最后的尾节点ptail和我们的头节点phead相链接的话，最后具线图将会变成下面这个样子。（下面这个图是错误示范，上面的图才是我们想要的效果）</p> 
<p><span style="color:#ff9900;"><strong>且该函数返回的是尾节点的地址，即节点5而不是1。这一点很重要！！</strong>！</span></p> 
<p><img alt="" height="335" src="https://images2.imgbox.com/0f/e2/mwxBQVhs_o.png" width="398"></p> 
<p>3. 主函数ysf函数中：我们用prev来接受BuyList传递的5节点指针。pcur是prev的下一个节点，初始pcur指向1节点。count是我们的计数变量，什么时候count==m，pcur代表的这个人就死掉了（代码中是free掉了）</p> 
<p>如果count！=m，我们仅仅需要让prev指向pcur所在节点，以及pcur指向下一个节点，并让count++。</p> 
<p><img alt="" height="435" src="https://images2.imgbox.com/92/6c/079AeWNP_o.png" width="1085"></p> 
<p><span style="color:#ff9900;"><strong>否则，即（count==m）那么prev将会指向pcur指向的下一个指针，并且pcur所指向的指针会被free掉，然后pcur指向prev指向的下一个节点。最后不要忘了让count=1重新计数。</strong></span></p> 
<p><img alt="" height="485" src="https://images2.imgbox.com/f2/69/4Z6mRFa1_o.png" width="1112"></p> 
<p></p> 
<p>依次循环直到不满足条件（pcur-&gt;next!=pcur）后，退出循环。</p> 
<p><img alt="" height="515" src="https://images2.imgbox.com/d1/2e/TfWZwtTp_o.png" width="885"></p> 
<h3>1.3代码实现</h3> 
<pre><code class="language-cpp">/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param n int整型 
 * @param m int整型 
 * @return int整型
 */
 typedef struct ListNode ListNode;
 ListNode* BuyNode(int x)
 {
    ListNode* newnode=(ListNode*)malloc(sizeof(ListNode));
    if(newnode==NULL)
    {
    return NULL;
    }
    else {
    newnode-&gt;next=NULL;
    newnode-&gt;val=x;
    return newnode;
    }

 }
 ListNode* BuyList(int n)
 {
    ListNode* phead=BuyNode(1);
ListNode* ptail=phead;
for(int i=2;i&lt;=n;i++)
{
    ptail-&gt;next=BuyNode(i);
    ptail=ptail-&gt;next;
}
ptail-&gt;next=phead;
return ptail;
 }
int ysf(int n, int m ) 
{
    ListNode* prev=BuyList(n);
    ListNode* pcur=prev-&gt;next;
    int count=1;
    while((pcur-&gt;next)!=pcur)
    {
        if(count!=m)
        {
              prev=pcur;
            pcur=pcur-&gt;next;
            count++;
        }
        else {
          
             prev-&gt;next=pcur-&gt;next;
        free(pcur);
        pcur=prev-&gt;next;
        count=1;
        }
        }
        return pcur-&gt;val;
    }</code></pre> 
<p><strong><span style="color:#ff9900;">值得注意的是：这是在牛客环境下运行的代码。</span></strong></p> 
<h2>三.结文</h2> 
<p>今天的分享就到此结束了，帅哥美女们，我们下次再见，拜拜。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/29a7652eb725cf4b12b1bcfb0c1d3ce6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MIMO天线的ECC计算脚本(python)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4e77292f30a81f979db51032035e1a5a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【c&#43;&#43;】继承学习(一)：继承机制与基类派生类转换</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>