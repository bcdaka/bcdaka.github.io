<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;11：列表初始化 &amp;&amp; 初始化列表initializer_list &amp;&amp; decltype关键字 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/9223b86795917a1ca6d2bc90de287da1/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C&#43;&#43;11：列表初始化 && 初始化列表initializer_list && decltype关键字">
  <meta property="og:description" content="目录
前言
列表初始化
初始化列表initializer_list
decltype关键字
左值和右值
move
前言 2003年C&#43;&#43;标准委员会曾经提交了一份技术勘误表（简称TC1），使得C&#43;&#43;03这个名字取代了C&#43;&#43;98成为了C&#43;&#43;11前最新的C&#43;&#43;标准名称。不过由于C&#43;&#43;03主要是对C&#43;&#43;98标准中的漏洞进行修复，语言的核心部分则没有改动，因此人们习惯性的把两个标准合并成为C&#43;&#43;98/03标准，从C&#43;&#43;0x到C&#43;&#43;11到，C&#43;&#43;委员会十年磨一剑，第二个真正意义上的C&#43;&#43;新标准C&#43;&#43;11在2011年姗姗来迟。
C&#43;&#43;11则带来了数量可观的变化，其中包含了约140个新特性，以及对C&#43;&#43;03标准中约600个缺陷的修正，此外C&#43;&#43;11能更好的用于系统开发和库开发、语言更加泛化和简单化、程序更加稳定和安全，不仅功能强大，而且还能提升程序员的开发效率，在公司实际项目开发中也用的较多。
官网查看各编译器对C&#43;&#43;11标准的接收情况：C&#43;&#43;11 - 维基百科，自由的百科全书 (wikipedia.org)
补充：模板的概念是C&#43;&#43;98引入的，不是C&#43;&#43;11 列表初始化 基本概念：C&#43;&#43;98只能使用{}对聚合类型进行聚合初始化（此时{}还不叫列表初始化），可以使用()对内置类型进行直接初始化，对自定义类型的对象进行构造和初始化（构造 != 初始化，先调用构造函数，可以在调用构造函数的同时进行初始化，也可以在调用构造函数后进行初始化）
问题：什么是聚合类型？
解释：聚合类型是一种特殊的自定义类型，它具有以下四个特征：
没有用户定义的构造函数：聚合类型不能有用户自定义的构造函数所有成员都是公有的：聚合类型的所有成员变量必须是公有的没有基类：聚合类型不能继承自其他类没有虚函数：聚合类型不能有虚函数 C&#43;&#43;98中{}的注意事项：
1、对聚合类型进行的初始化叫做聚合初始化，聚合初始化与构造无关，不会调用构造函数
//聚合类型 struct Point { int x; int y; }; Point p = {1, 2}; 2、{} 可对聚合类型进行部分初始化，未显式初始化的成员会被默认初始化为零
#include &lt;iostream&gt; struct Point { int x; int y; int z; }; int main() { Point p = { 1, 2 }; // 只初始化了 x 和 y，z 会被默认初始化为 0 std::cout &lt;&lt; &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-08T12:42:46+08:00">
    <meta property="article:modified_time" content="2024-06-08T12:42:46+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;11：列表初始化 &amp;&amp; 初始化列表initializer_list &amp;&amp; decltype关键字</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p id="%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:0px;"><a href="#%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">列表初始化</a></p> 
<p id="%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8initializer_list-toc" style="margin-left:0px;"><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8initializer_list" rel="nofollow">初始化列表initializer_list</a></p> 
<p id="decltype%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:0px;"><a href="#decltype%E5%85%B3%E9%94%AE%E5%AD%97" rel="nofollow">decltype关键字</a></p> 
<p id="%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC-toc" style="margin-left:0px;"><a href="#%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC" rel="nofollow">左值和右值</a></p> 
<p id="move-toc" style="margin-left:40px;"><a href="#move" rel="nofollow">move</a></p> 
<hr id="hr-toc"> 
<h2>前言</h2> 
<p><strong>        2003年C++标准委员会曾经提交了一份技术勘误表（简称TC1），使得C++03这个名字取代了C++98成为了C++11前最新的C++标准名称。不过由于C++03主要是对C++98标准中的漏洞进行修复，语言的核心部分则没有改动，因此人们习惯性的把两个标准合并成为C++98/03标准，从C++0x到C++11到，C++委员会十年磨一剑，第二个真正意义上的C++新标准C++11在2011年姗姗来迟。</strong></p> 
<p><strong>        C++11则带来了数量可观的变化，其中包含了约140个新特性，以及对C++03标准中约600个缺陷的修正，此外C++11能更好的用于系统开发和库开发、语言更加泛化和简单化、程序更加稳定和安全，不仅功能强大，而且还能提升程序员的开发效率，在公司实际项目开发中也用的较多。</strong></p> 
<blockquote> 
 <p style="text-align:center;"><em><strong><span style="color:#ff9900;">官网查看各编译器对C++11标准的接收情况：<a href="https://zh.wikipedia.org/zh-cn/C++11" rel="nofollow" title="C++11 - 维基百科，自由的百科全书 (wikipedia.org)">C++11 - 维基百科，自由的百科全书 (wikipedia.org)</a></span></strong></em></p> 
</blockquote> 
<p><span style="color:#fe2c24;"><img alt="" height="782" src="https://images2.imgbox.com/cc/de/vUN8OFHd_o.png" width="1200"></span></p> 
<blockquote> 
 <p style="text-align:center;"><strong>补充：<span style="color:#956fe7;">模板的概念是C++98引入的，不是C++11</span></strong><span style="color:#956fe7;"> </span></p> 
</blockquote> 
<h2 id="%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96">列表初始化</h2> 
<p><span style="color:#0d0016;"><strong>基本概念：</strong></span><span style="color:#fe2c24;"><strong>C++98只能使用</strong></span><span style="color:#956fe7;"><strong>{}</strong></span><span style="color:#fe2c24;"><strong>对</strong></span><span style="color:#956fe7;"><strong>聚合类型</strong></span><span style="color:#fe2c24;"><strong>进行</strong></span><span style="color:#956fe7;"><strong>聚合初始化</strong></span><span style="color:#7b7f82;"><strong><em>（此时{}还不叫列表初始化）</em></strong></span><span style="color:#fe2c24;"><strong>，可以使用</strong></span><span style="color:#956fe7;"><strong><code>()</code></strong></span><span style="color:#fe2c24;"><strong>对</strong></span><span style="color:#956fe7;"><strong>内置类型</strong></span><span style="color:#fe2c24;"><strong>进行</strong></span><span style="color:#956fe7;"><strong>直接初始化</strong></span><span style="color:#fe2c24;"><strong>，对</strong></span><span style="color:#956fe7;"><strong>自定义类型的对象</strong></span><span style="color:#fe2c24;"><strong>进行</strong></span><span style="color:#956fe7;"><strong>构造和初始化</strong></span><span style="color:#7b7f82;"><strong><em>（构造 != 初始化，先调用构造函数，可以在调用构造函数的同时进行初始化，也可以在调用构造函数后进行初始化）</em></strong></span></p> 
<blockquote> 
 <p><strong>问题：什么是聚合类型？</strong></p> 
 <p><span style="color:#0d0016;"><strong>解释：</strong></span><span style="color:#fe2c24;"><strong>聚合类型是一种特殊的自定义类型</strong></span><span style="color:#fe2c24;"><strong>，它具有以下四个特征：</strong></span></p> 
 <ol><li><strong>没有用户定义的构造函数</strong>：<span style="color:#fe2c24;"><strong>聚合类型不能有用户自定义的构造函数</strong></span></li><li><strong>所有成员都是公有的</strong>：<span style="color:#fe2c24;"><strong>聚合类型的所有成员变量必须是公有的</strong></span></li><li><strong>没有基类</strong>：<span style="color:#fe2c24;"><strong>聚合类型不能继承自其他类</strong></span></li><li><strong>没有虚函数</strong>：<span style="color:#fe2c24;"><strong>聚合类型不能有虚函数</strong></span></li></ol> 
</blockquote> 
<blockquote> 
 <p><strong>C++98中{}的注意事项：</strong></p> 
 <p><span style="color:#fe2c24;"><strong>1、对聚合类型进行的初始化叫做聚合初始化，聚合初始化与构造无关，不会调用构造函数</strong></span></p> 
 <pre><code class="language-cpp">//聚合类型
struct Point {
    int x;
    int y;
};
Point p = {1, 2};</code></pre> 
 <p><span style="color:#fe2c24;"><strong>2、{} 可对聚合类型进行部分初始化，未显式初始化的成员会被默认初始化为零</strong></span></p> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;
struct Point {
    int x;
    int y;
    int z;
};

int main() {
    Point p = { 1, 2 }; // 只初始化了 x 和 y，z 会被默认初始化为 0
    std::cout &lt;&lt; "Point: (" &lt;&lt; p.x &lt;&lt; ", " &lt;&lt; p.y &lt;&lt; ", " &lt;&lt; p.z &lt;&lt; ")" &lt;&lt; std::endl; // 输出：Point: (1, 2, 0)
    return 0;
}</code></pre> 
 <p><img alt="" height="362" src="https://images2.imgbox.com/b4/92/4FJDaqoc_o.png" width="1200"></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>问题：为什么可以使用()对内置类型进行直接初始化，对自定义类型进行构造和初始化？</strong></span></p> 
 <p><span style="color:#0d0016;"><strong>解释：</strong></span><span style="color:#fe2c24;"><strong>C++98引入了模板的概念，使用 () 时，编译器会将其解释为调用相应类型的构造函数</strong></span><span style="color:#7b7f82;"><em><strong><code>（</code>()对内置类型int i(5)直接初始化的本质是调用<code>int</code> 类型的构造函数来将整数值 <code>5</code> 转换为 <code>int</code> 类型并初始化变量 <code>i，但不能使用int i(); i = 5的形式，因为前者会被视为一个函数声明，赋值时会被视为向一个名为i函数进行赋值）</code></strong></em></span></p> 
</blockquote> 
<blockquote> 
 <p><strong>C++98中()的注意事项：</strong></p> 
 <p><span style="color:#fe2c24;"><strong>1、对自定义类型的对象进行构造时，没有（）时叫做默认构造，有（）时依据（）内参数的多少分为单参数和多参数构造</strong></span><span style="color:#fe2c24;"><strong>，</strong></span><span style="color:#956fe7;"><strong>传入的参数叫做对该对象的初始化</strong></span><span style="color:#fe2c24;"><strong>；一般不会使用（）对内置类型进行像</strong></span><span style="color:#a2e043;"><strong>int i(5)</strong></span><span style="color:#fe2c24;"><strong>这样的直接初始化，但要了解为什么可以这样</strong></span><span style="color:#7b7f82;"><strong><em>（本质还是调用了构造）</em></strong></span></p> 
 <p><strong>2、使用<code>()</code> 对自定义类型的对象进行构造时</strong><strong><span style="color:#fe2c24;">必须要有适合的构造函数</span><span style="color:#7b7f82;"><em>（传递单个参数对构造对象进行初始化时，对象中要有单参数的构造函数，传递多个参数对构造对象进行初始化时，对象中要有多参数的构造函数）</em></span><span style="color:#fe2c24;">构造时的形式为</span><span style="color:#956fe7;">类名 对象名（）</span><span style="color:#fe2c24;">或</span><span style="color:#956fe7;"> </span><span style="color:#fe2c24;"> </span><span style="color:#956fe7;">类名 对象名</span></strong></p> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Date
{
public:
	Date() 
	{
		cout &lt;&lt; "Date()" &lt;&lt; endl;
	}

	Date(int year)
		:_year(year)
	{
		cout &lt;&lt; "Date(int year)" &lt;&lt; endl;
	}

	Date(int year, int month, int day)
		:_year(year)
		, _month(month)
		, _day(day)
	{
		cout &lt;&lt; "Date(int year, int month, int day)" &lt;&lt; endl;
	}

private:
	int _year;
	int _month;
	int _day;
};

int main()
{
    Date d0;//默认构造
	Date d2(2024);//单参数构造
	Date d3(2024,5,26);//多参数构造
    
    int i(5);//单参数构造
    double f(3.14);//单参数构造
    return 0;
}

</code></pre> 
 <p><img alt="" height="440" src="https://images2.imgbox.com/83/f5/rOT93oA7_o.png" width="1200"></p> 
 <p><strong><span style="color:#fe2c24;">2、不建议以Date d =（）的形式对自定义类型的对象进行构造，因为此时（）会被编译器视为逗号表达式，（）内为空时会报错，（）有参数时，参数个数无论为多少都会去调用单参数构造函数，即使是内置类型也是一样的</span></strong></p> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Date
{
public:
	Date()
	{
		cout &lt;&lt; "Date()" &lt;&lt; endl;
	}

	Date(int year)
		:_year(year)
	{
		cout &lt;&lt; "Date(int year)" &lt;&lt; endl;
	}

	Date(int year, int month, int day)
		:_year(year)
		, _month(month)
		, _day(day)
	{
		cout &lt;&lt; "Date(int year, int month, int day)" &lt;&lt; endl;
	}
private:
	int _year;
	int _month;
	int _day;
};

int main()
{
	Date d = (2024);
	Date d1 = (2024, 5, 26);

	int z = (5, 6);
	cout &lt;&lt; "z = " &lt;&lt; z &lt;&lt; endl;
	return 0;
};
</code></pre> 
 <img alt="" height="408" src="https://images2.imgbox.com/2b/95/2cWoMkF4_o.png" width="1200"> 
 <p><span style="color:#fe2c24;"><strong>3、</strong></span><span style="color:#fe2c24;"><strong>string s = "1111" 也是直接构造，但本质是</strong></span><span style="color:#956fe7;"><strong>隐式类型转换 + 构造 + 拷贝构造</strong></span><span style="color:#fe2c24;"><strong>，只是编译器将这三个步骤优化为了直接构造</strong></span><span style="color:#7b7f82;"><strong><em>（便于用户使用）</em></strong></span><span style="color:#fe2c24;"><strong>，我们称这样的优化为</strong></span><strong><span style="color:#956fe7;">单参数的构造函数支持隐式类型转换</span><span style="color:#7b7f82;"><em>（将const char[N]常量字符数组类型的字符串"1111"隐式类型转换为const char*，然后再通过支持const char *为参数的单参数构造函数构造一个 <code>string</code> 对象，最后再将该对象拷贝给s）</em></span></strong></p> 
 <p><strong><span style="color:#fe2c24;">4、进行默认构造时，要以Date d形式进行，不能以Data d（）的形式，因为后者在编译器看来不是构造而是一个函数声明</span><span style="color:#956fe7;"><em>（这也被称为C++最烦人的解析）</em></span></strong></p> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Date
{
public:
	Date()
	{
		cout &lt;&lt; "Date()" &lt;&lt; endl;//最后打印的Date()应该只有一行
	}
};

int main()
{
	Date d1();//函数声明，不是初始化对象
	cout &lt;&lt; endl;
	cout &lt;&lt; "上面有Date()吗？" &lt;&lt; endl;
	Date d1;//默认构造
	cout &lt;&lt; "上面有Date()吗？" &lt;&lt; endl;
	return 0;
}
</code></pre> 
 <p><img alt="" height="335" src="https://images2.imgbox.com/a8/bc/BJ5eQVCm_o.png" width="1200"></p> 
</blockquote> 
<blockquote> 
 <p><strong>结论：<span style="color:#fe2c24;">使用（）对自定义类型的对象构造或对内置类型进行直接初始化时，要注意（）可能被解析为逗号表达式或函数声明的情况 </span></strong></p> 
</blockquote> 
<p><span style="color:#0d0016;"><strong>基本概念：</strong></span><span style="color:#fe2c24;"><strong>C++11中扩大了{}的使用范围，使其可以对所有类型进行初始化</strong></span><span style="color:#7b7f82;"><strong><em>（且=可以省略）</em></strong></span><span style="color:#fe2c24;"><strong>此时我们将使用{}进行初始化的行为叫做</strong></span><span style="color:#956fe7;"><strong>列表初始化</strong></span><span style="color:#fe2c24;"><strong>，（）的用法不变</strong></span></p> 
<blockquote> 
 <p><strong><span style="color:#fe2c24;">1、此时{}对聚合类型的初始化仍叫做聚合初始化，而不是列表初始化，且初始化规则不变</span></strong></p> 
 <pre><code class="language-cpp">//对聚合类型进行聚合初始化
struct Point {
    int x;
    int y;
};

Point P = {1};    // C++98支持使用{}进行部分聚合初始化
Point p = {1, 2}; // C++98支持使用{}进行完全聚合初始化
Point p{3, 4};    // C++11及以后版本均支持使用{}进行部分聚合初始化，且=可省略
Point p{3, 4};    // C++11及以后版本均支持使用{}进行聚合初始化，且=可省略

int arr[]{1,2,3,4,5}//对数组进行部分聚合化</code></pre> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>2、使用（）对内置类型进行初始化时仍叫直接初始化，而使用{}对内置类型进行初始化时叫做列表初始化</strong></span></p> 
 <pre><code class="language-cpp">//对内置类型进行初始化的多种方式
int x = 1;               //每个C++版本一定支持的
int y(5) 或 y = (5);     //C++98后开始支持的
int z{3} 或 z = {3};     //C++11后开始支持的</code></pre> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>3、此时{}和（）均可以对自定义类型的对象进行构造和初始化</strong></span></p> 
 <pre><code class="language-cpp">class Date
{
public:
    Date(int year)
		:_year(year)
	{
		cout &lt;&lt; "Date(int year)" &lt;&lt; endl;
	}

	Date(int year, int month, int day)
		:_year(year)
		, _month(month)
		, _day(day)
	{
		cout &lt;&lt; "Date(int year, int month, int day)" &lt;&lt; endl;
	}
private:
	int _year;
	int _month;
	int _day;
};

Date d1;//C++11和C++98均支持这样做

Date d2(2024);//C++98支持的使用（）进行单参数构造
Date d3(2024,5,26);//C++98支持的使用（）进行多参数构造

//省略=
Date d4{2024};//C++11支持的使用{}进行单参数构造
Date d5{2024,5,26};//C++11支持的使用{}进行多参数构造

//不省略=
Date d6 = {2024};//C++11支持的使用{}进行单参数构造
Date d6 = {2024,5,6};//C++11支持的使用{}进行多参数构造</code></pre> 
 <p></p> 
 <ul><li><span style="color:#fe2c24;"><strong>对自定义类型的对象进行构造时仍建议使用（）进行，</strong></span><span style="color:#fe2c24;"><strong>{}华而不实，</strong><strong>且使用{}时也不建议省略=，因为会导致代码可读性降低</strong></span></li></ul> 
</blockquote> 
<p><strong>注意事项：</strong></p> 
<p><strong><span style="color:#fe2c24;">1、列表初始化是一种直接调用构造函数的方式，C++11及以后版本使用列表初始化时，{}会去寻找最为适合的构造函数，如果找不到最合适的，会尝试将{}中的内容进行隐式类型转换，从而找到一个较为适合的构造函数，如果还找不到就会报错</span></strong></p> 
<p><strong><span style="color:#fe2c24;">2、所谓的</span><span style="color:#4da8ee;">单参数的构造函数支持隐式类型转换 </span><span style="color:#fe2c24;">和 </span><span style="color:#4da8ee;">多参数的构造函数支持隐式类型转换 </span><span style="color:#fe2c24;">指的是单参数和多参数的构造函数支持出现由于“</span><span style="color:#4da8ee;">传入的参数与规定的参数类型相似但不一致</span><span style="color:#fe2c24;">”导致的找不到合适的构造函数的问题时，可以将该参数转换为规定的参数然后再进行构造</span><em><span style="color:#7b7f82;">（支持隐式类型转换 != 一定发生）（还有可能会遇到编译器将构造和拷贝构造优化为直接构造的情况，具体内容可以查看：<a href="https://blog.csdn.net/Fire_Cloud_1/article/details/130180486" title="C++ | 探究拷贝对象时的一些编译器优化_gcc 优化 拷贝构造 问题-CSDN博客">C++ | 探究拷贝对象时的一些编译器优化_gcc 优化 拷贝构造 问题-CSDN博客</a>，本篇文章后续内容不再考虑编译器优化的问题）</span></em></strong></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

class Person {
public:
    std::string name;
    int age;
    int height;

    // 单参数构造函数
    Person(std::string n) : name(n), age(0) {
        std::cout &lt;&lt; "Person(std::string n)" &lt;&lt; std::endl;
    }

    Person(int a) : name("Unknown"), age(a) {
        std::cout &lt;&lt; "Person(int a)" &lt;&lt; std::endl;
    }

    Person(std::string n, int a) : name(n), age(a) {
        std::cout &lt;&lt; "Person(std::string n, int a)" &lt;&lt; std::endl;
    }

    Person(double n, double a) : height(n), age(a) {
        std::cout &lt;&lt; "Person(double n, double a)" &lt;&lt; std::endl;
    }

    Person(const char* s) : name(s) {
        std::cout &lt;&lt; "Person(const char * s)" &lt;&lt; std::endl;
    }
};  

int main() 
{
    Person a = { "Alice", 30}; // 直接调用 Person(std::string, int) 构造函数
    Person b = { "fwqfq" };    // 直接调用 Person(const char * s) 构造函数
    Person c = { 5 , 6 };      //（多参数）隐式类型转换： int -&gt; double，然后直接调用 构造Person(double n, double a) 函数
    Person d = (52.5);         //（单参数）隐式类型转换：double -&gt; int，然后直接调用  Person(int a) 构造函数
    Person e = "fewfew";       // 直接调用Person(const char* s)构造函数，如果只有Person(string s)，就会先进行隐式类型转换然后再调用该构造函数
    Person f = 40;             // 直接调用 Person(int a) 构造函数
    return 0;
}
</code></pre> 
<p class="img-center"><img alt="" height="387" src="https://images2.imgbox.com/7d/9c/klwNkS0V_o.png" width="1200"></p> 
<p><span style="color:#fe2c24;"><strong>2、列表初始化不支持窄化的隐式类型转换，窄化转换就是大范围转小范围，但是（）支持</strong></span></p> 
<p class="img-center"><img alt="" height="482" src="https://images2.imgbox.com/8a/24/lQ4iKMGF_o.png" width="1200"></p> 
<p class="img-center"><img alt="" height="358" src="https://images2.imgbox.com/03/de/CM7ZocH7_o.png" width="900"></p> 
<blockquote> 
 <p style="text-align:center;"><em><strong><span style="color:#ff9900;">关于C++的隐式类型转换的其它文章：<a href="https://www.cnblogs.com/apocelipes/p/14415033.html#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2" rel="nofollow" title="彻底理解c++的隐式类型转换 - apocelipes - 博客园">彻底理解c++的隐式类型转换 - apocelipes - 博客园</a></span></strong></em></p> 
</blockquote> 
<h2 id="%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8initializer_list"><span style="color:#333333;"><strong>初始化列表initializer_list</strong></span></h2> 
<p><strong>基本概念：<span style="color:#fe2c24;">是一个模板类，用于向自定义类型或函数</span><span style="color:#7b7f82;"><em>（前提是得有支持该类型的构造函数或者参数）</em></span><span style="color:#fe2c24;">传递一组同类型的参数，</span><span style="color:#fe2c24;">它通常与列表初始化{}配合使用</span></strong><strong><span style="color:#7b7f82;"><em>（初始化列表 != 列表初始化）</em></span></strong></p> 
<pre><code class="language-cpp">template&lt;class T&gt; class initializer_list;</code></pre> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

//printList函数有initializer_list类型的参数
void printList(std::initializer_list&lt;int&gt; list) {
    for (auto elem : list) {
        std::cout &lt;&lt; elem &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
}

class MyClass {
public:
    //MyClass有支持initializer_list类型的构造函数
    MyClass(std::initializer_list&lt;int&gt; list) {
        for (auto elem : list) {
            std::cout &lt;&lt; elem &lt;&lt; " ";
        }
        std::cout &lt;&lt; std::endl;
    }
};

int main() {
    printList({10, 20, 30, 40, 50});  
    MyClass obj = {1, 2, 3, 4, 5};    
    return 0;
}
</code></pre> 
<p><img alt="" height="368" src="https://images2.imgbox.com/4e/e8/xcwye1l1_o.png" width="1200"></p> 
<p><strong>注意事项：</strong></p> 
<p><strong><span style="color:#fe2c24;">1、{10, 20, 30, 40, 50}在正常情况下还是列表初始化，但是当{10, 20, 30, 40, 50}要作为函数参数</span><span style="color:#fe2c24;">或者要赋值给一个自定义类型时</span><span style="color:#fe2c24;">，</span><span style="color:#4da8ee;">编译器会将{10, 20, 30, 40, 50}识别为initializer_list类型</span><span style="color:#7b7f82;"><em>（不会构造initializer_list类型的匿名对象）</em></span><span style="color:#fe2c24;">，然后直接向某个有initializer_list类型形参的函数进行传参，或者调用某个支持自定义类型对象的支持initializer_list类型的构造函数</span></strong></p> 
<ul><li><span style="color:#0d0016;"><strong>MyClass obj = {1, 2, 3, 4, 5}：</strong></span><span style="color:#38d8f0;"><strong>将{1, 2, 3, 4, 5}解析为initializer_list类型—&gt;直接调用MyClass类中支持initializer_list类型的构造函数</strong></span></li><li><span style="color:#0d0016;"><strong>Myclass obj({10, 20, 30, 40, 50})：</strong></span><span style="color:#38d8f0;"><strong>将{10, 20, 30, 40, 50}解析为initializer_list类型—&gt;直接调用Myclass </strong>类<strong>中支持initializer_list类型的构造函数构造</strong></span></li><li><span style="color:#0d0016;"><strong>printList({10, 20, 30, 40, 50})：</strong></span><span style="color:#38d8f0;"><strong>将{10, 20, 30, 40, 50}解析为initializer_list类型—&gt;直接向printList函数传参</strong></span></li></ul> 
<p><span style="color:#fe2c24;"><strong>2、对于C++库中提供的各种容器，它们都有支持initializer_list类型的构造函数，不用担心直接使用即可，但是对于自定义类型如果没有支持initializer_list类型的构造函数就不能使用，上面的MyClass obj = {1, 2, 3, 4, 5}；如果没有支持initializer_list类型的构造函数就会报错</strong></span></p> 
<p><img alt="" height="873" src="https://images2.imgbox.com/68/45/s0eheeH9_o.png" width="1200"></p> 
<p><span style="color:#fe2c24;"><strong>3、编译器会优先调用支持initializer_list类型的构造函数，而不是写死参数个数的构造函数</strong></span></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

class MyClass {
public:
    MyClass(int a,int b,int c,int d,int e)
    {
        std::cout &lt;&lt; "MyClass(int a,int b,int c,int d,int e)" &lt;&lt; std::endl;
    }

    MyClass(std::initializer_list&lt;int&gt; list) 
    {
        for (auto elem : list) {
            std::cout &lt;&lt; elem &lt;&lt; " ";
        }
        std::cout &lt;&lt; std::endl;
    }
  
};

int main() 
{
    MyClass obj = { 1, 2, 3, 4, 5 }; 
    return 0;
}</code></pre> 
<p><img alt="" height="364" src="https://images2.imgbox.com/8f/8a/02eCRpyv_o.png" width="1200"></p> 
<p><span style="color:#fe2c24;"><strong>4、<strong>in</strong>itializer_list模板类的引入，使得我们在向容器中写入数据时更加的简单</strong></span></p> 
<pre><code class="language-cpp">//原来
std::vector&lt;int&gt; v;
v.push_back(1);
v.push_back(2);
v.push_back(3);
v.push_back(4);

std::set&lt;int&gt; st;
v.insert(1);
v.insert(2);
v.insert(3);
v.insert(4);

std::map&lt;string,string&gt; mt;
dict.insert(make_pair("right", "右边"));
dict.insert(make_pair("right", "右边"));
dict.insert(make_pair("right", "右边"));
dict.insert(make_pair("right", "右边"));

//现在
std::vector&lt;int&gt; v = {1，2，3，4};//直接调用支持 initializer_list 类型的构造函数
std::set&lt;int&gt; st = {1,2,3,4,5};//直接调用支持 initializer_list 类型的构造函数
std::map&lt;string,string&gt; mt = {<!-- -->{"right", "右边"},{"right", "右边"}};

</code></pre> 
<blockquote> 
 <p><strong>对于std::set&lt;int&gt; st = {1,2,3,4,5}：<span style="color:#fe2c24;">{1,2,3,4,5}是使用{}的列表初始化，又因为左边是vector容器类型，因此编译器会解析为一个<code>initializer_list类型，然后直接调用vector中支持initializer_list类型的构造函数</code></span></strong></p> 
</blockquote> 
<p><strong>对于std::map&lt;string,string&gt; mt = {<!-- -->{"right", "右边"},{"right", "右边"}}：<span style="color:#fe2c24;">编译器会先识别出<code>{<!-- -->{"right", "右边"}, {"right", "右边"}}</code>是一个用于初始化map类型对象的<code>initializer_list</code>，接着调用 <code>pair</code> 的构造函数生成两个 <code>pair&lt;const std::string, std::string&gt;</code> 对象，然后将生成的 两个 <code>pair</code> 对象组合成一个 <code>initializer_list&lt;std::pair&lt;const std::string, std::string&gt;&gt;</code> ，最后直接调用map支持<code>initializer_list类型的构造函数</code></span></strong></p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong><code>补充：</code></strong></span></p> 
 <p><span style="color:#fe2c24;"><strong> 1、pair类型不支持<code>initializer_list</code> 类型的构造函数，因此pair&lt;?&gt; p = {}是列表初始化而不是<code>initializer_list类型</code></strong></span></p> 
 <p class="img-center"><img alt="" height="321" src="https://images2.imgbox.com/bb/2b/5D8pmPaY_o.png" width="1102"></p> 
 <p><span style="color:#fe2c24;"><strong><code>2、map</code> 有一个接受<code>initializer_list</code> 的构造函数，其定义如下</strong></span><span style="color:#7b7f82;"><strong><em>（set也类似）</em></strong></span><span style="color:#fe2c24;"><strong>：</strong></span></p> 
 <pre><code class="language-cpp">map(std::initializer_list&lt;std::pair&lt;const Key, T&gt;&gt; init);</code></pre> 
 <p><span style="color:#fe2c24;"><strong>3、pair不同类型间的pair可以进行拷贝构造，是因为pair的拷贝构造是一个函数模板</strong></span></p> 
 <pre><code class="language-cpp">template&lt;class U, class V&gt;
pair(const pair&lt;U, V&gt;&amp; pr);
​
pair&lt;const char*,char*&gt; kv3 = {"sort","排序"};
pair&lt;const string,string&gt; kv4(kv3);</code></pre> 
</blockquote> 
<h2 id="decltype%E5%85%B3%E9%94%AE%E5%AD%97">decltype关键字</h2> 
<p><strong>基本概念：<span style="color:#fe2c24;">是 C++11 引入的一个关键字，用于查询表达式的类型，它解决了typeid只能进行打印变量类型但是不能作为一个类型的使用</span></strong></p> 
<p><strong>常见使用方式：</strong></p> 
<p><span style="color:#fe2c24;"><strong>1、 获取变量类型</strong></span></p> 
<pre><code class="language-cpp">int x = 0;
decltype(x) y = 5;  //y的类型是int
</code></pre> 
<p><span style="color:#fe2c24;"><strong>2、获取表达式类型</strong></span></p> 
<pre><code class="language-cpp">int a = 5;
double b = 3.14;
decltype(a + b) c = a + b; //因为a + b的类型是double,所以c的类型是 double</code></pre> 
<p><span style="color:#fe2c24;"><strong> 3、decltype关键字通常会与获取lambda表达式配合使用</strong></span></p> 
<p style="text-align:center;"><span style="color:#38d8f0;"><strong>~over~ </strong></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b955e501e5d2a5b89e6b3cfd7634767b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【数据结构】栈和队列--＞理解和实现（赋源码)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d5a0b9fc33ae96802d5dd433d09514e9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Web前端安全测试：深入剖析与实战策略</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>