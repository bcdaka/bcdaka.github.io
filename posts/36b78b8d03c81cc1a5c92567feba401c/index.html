<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java 中的阻塞 IO 和非阻塞 IO - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/36b78b8d03c81cc1a5c92567feba401c/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java 中的阻塞 IO 和非阻塞 IO">
  <meta property="og:description" content="Java 中的阻塞 IO 和非阻塞 IO 1、阻塞 IO（Blocking IO）2、非阻塞 IO（Non-blocking IO）3、区别与应用场景4、总结 💖The Begin💖点点关注，收藏不迷路💖 IO（输入输出）操作是一个基础而又关键的部分。在 Java 中，处理 IO 通常涉及到阻塞 IO 和非阻塞 IO 两种模式。本文将介绍这两种模式的概念、特点以及在 Java 编程中的应用场景与区别。
1、阻塞 IO（Blocking IO） 阻塞 IO 是指在进行 IO 操作时，如果数据没有准备好，请求会被阻塞，直到数据准备好并返回给用户线程。
在阻塞 IO 中，读取数据的操作会一直等待直到有数据可供读取或者超时。在 Java 中，传统的 IO 操作（比如基于 InputStream 和 OutputStream 的操作）通常是阻塞的。
示例代码：
InputStream inputStream = socket.getInputStream(); int data = inputStream.read(); // 如果没有数据准备好，此处会阻塞直到有数据可读 2、非阻塞 IO（Non-blocking IO） 非阻塞 IO 则不会等待数据准备就绪，而是立即返回。如果数据还没有准备好，非阻塞 IO 操作会返回一个标志信息告知当前数据未准备好，这样用户线程可以继续做其他事情而不必等待。
在 Java 中，非阻塞 IO 通常使用 NIO（New IO）或者 NIO.2 中的通道（Channel）和缓冲区（Buffer）来实现。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-10T19:38:59+08:00">
    <meta property="article:modified_time" content="2024-07-10T19:38:59+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java 中的阻塞 IO 和非阻塞 IO</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>Java 中的阻塞 IO 和非阻塞 IO </h4> 
 <ul><li><a href="#1_IOBlocking_IO_17" rel="nofollow">1、阻塞 IO（Blocking IO）</a></li><li><a href="#2_IONonblocking_IO_30" rel="nofollow">2、非阻塞 IO（Non-blocking IO）</a></li><li><a href="#3_45" rel="nofollow">3、区别与应用场景</a></li><li><a href="#4_59" rel="nofollow">4、总结</a></li></ul> 
</div> 
<p></p> 
<br> 
<table width="100%"><tbody><tr><td width="50%"> 
    <div align="center"> 
     <font face="STCAIYUN" color="red" size="4"><em>💖The Begin💖点点关注，收藏不迷路💖<em></em></em></font> 
    </div> </td></tr></tbody></table> 
<p>IO（输入输出）操作是一个基础而又关键的部分。在 Java 中，处理 IO 通常涉及到阻塞 IO 和非阻塞 IO 两种模式。本文将介绍这两种模式的概念、特点以及在 Java 编程中的应用场景与区别。</p> 
<h2><a id="1_IOBlocking_IO_17"></a>1、阻塞 IO（Blocking IO）</h2> 
<p><font color="#008000" size="4">阻塞 IO 是指在进行 IO 操作时，如果数据没有准备好，请求会被阻塞，直到数据准备好并返回给用户线程。</font></p> 
<p>在阻塞 IO 中，读取数据的操作会一直等待直到有数据可供读取或者超时。<font color="red" size="4">在 Java 中，传统的 IO 操作（比如基于 InputStream 和 OutputStream 的操作）通常是阻塞的。</font></p> 
<font color="red" size="4"> <p><strong>示例代码：</strong></p> <pre><code class="prism language-java"><span class="token class-name">InputStream</span> inputStream <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> data <span class="token operator">=</span> inputStream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果没有数据准备好，此处会阻塞直到有数据可读</span>
</code></pre> <h2><a id="2_IONonblocking_IO_30"></a>2、非阻塞 IO（Non-blocking IO）</h2> <p><font color="#008000" size="4">非阻塞 IO 则不会等待数据准备就绪，而是立即返回。</font>如果数据还没有准备好，非阻塞 IO 操作会返回一个标志信息告知当前数据未准备好，这样用户线程可以继续做其他事情而不必等待。</p> <p><font color="red" size="4">在 Java 中，非阻塞 IO 通常使用 NIO（New IO）或者 NIO.2 中的通道（Channel）和缓冲区（Buffer）来实现。</font></p><font color="red" size="4"> <p><strong>示例代码：</strong></p> <pre><code class="prism language-java"><span class="token class-name">SelectableChannel</span> channel <span class="token operator">=</span> socketChannel<span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
channel<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> bytesRead <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果数据没有准备好，read()方法会立即返回0</span>
</code></pre> <h2><a id="3_45"></a>3、区别与应用场景</h2> <p><font color="red" size="4">阻塞 IO 的应用场景：</font></p><font color="red" size="4"> <p>1、当数据处理要求不高，简单易用的场景下，可以使用阻塞 IO。例如，传统的文件读写、简单的网络操作等。</p> <p>2、在线程数量有限且可控制的情况下，阻塞 IO 可以简化编程模型，代码更易于理解和维护。</p> <p><font color="red" size="4">非阻塞 IO 的应用场景：</font></p><font color="red" size="4"> <p>1、在高并发和大量连接的网络编程中，非阻塞 IO 更为适用。它允许单个线程处理多个连接，提高了系统的吞吐量和响应性能。</p> <p>2、在需要同时处理多个 IO 操作的情况下，非阻塞 IO 可以显著提升系统的效率和资源利用率。</p> <h2><a id="4_59"></a>4、总结</h2> <p>阻塞 IO 和非阻塞 IO 是 Java 编程中常见的两种 IO 模式，它们在处理数据准备就绪时的行为方式有着明显的不同。</p> <p>选择合适的 IO 模式取决于应用程序的特性和需求。在实际开发中，通常需要权衡系统的并发性能、响应时间以及代码的复杂度等因素，来确定使用哪种 IO 模式以达到最佳的效果。<br> <img src="https://images2.imgbox.com/ec/b0/d7zxzRYz_o.png" alt="在这里插入图片描述"></p> <br> 
    <table width="100%"><tbody><tr><td width="50%"> 
        <div align="center"> 
         <font face="STCAIYUN" color="red" size="4"><em>💖The End💖点点关注，收藏不迷路💖<em></em></em></font> 
        </div> </td></tr></tbody></table> </font></font></font></font>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b675731eb04c855fa7971495fccd93a0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python酷库之旅-第三方库Pandas(014)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6ba282448b82fd6181a281708871d30a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于springboot&#43;mybatis学生管理系统</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>