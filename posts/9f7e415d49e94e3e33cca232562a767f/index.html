<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JavaScript 中 await 永远不会 resolve 的 Promise 会导致内存泄露吗？ - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/9f7e415d49e94e3e33cca232562a767f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="JavaScript 中 await 永远不会 resolve 的 Promise 会导致内存泄露吗？">
  <meta property="og:description" content="前言 在 JavaScript 中，await 关键字用于等待一个 Promise 完成，它只能在异步函数（async function）内部使用。当 await 一个永远不会 resolve 的 Promise 时，它确实会阻塞异步函数的进一步执行，但不会直接导致内存泄露（memory leak）。然而，这种情况可能会间接导致问题，特别是在处理资源（如数据库连接、文件句柄、网络请求等）时。
为什么说它不会直接导致内存泄露？ 内存泄露通常指的是程序在不需要某些内存时未能释放它，导致内存使用量持续增加。在 JavaScript（特别是在 V8 引擎中，Chrome 和 Node.js 的 JavaScript 引擎）中，垃圾回收器（Garbage Collector, GC）会定期清理不再被引用的对象。如果一个 Promise 永远不会 resolve，那么它自身及其依赖的对象（除非有其他引用指向它们）最终会因为没有任何引用指向它们而被垃圾回收器回收。
间接问题 尽管 await 一个永远不会 resolve 的 Promise 不会直接导致内存泄露，但它可能导致以下问题：
阻塞执行：异步函数将停留在 await 表达式处，无法继续执行后续代码，这可能会阻塞事件循环中的其他任务。
资源占用：如果 Promise 依赖于某些外部资源（如数据库连接、文件句柄、网络请求等），这些资源将不会被释放，直到 Promise 被解决或拒绝。如果 Promise 永远不解决，这些资源可能会长时间被占用，甚至可能导致资源耗尽。
死锁和性能问题：在复杂的应用程序中，多个异步操作可能相互依赖。如果一个操作因为等待一个永远不会 resolve 的 Promise 而阻塞，它可能会阻止其他依赖它的操作执行，从而导致死锁或性能问题。
想要知道 promise 对象有没有被回收掉，可以在控制台使用 queryObjects() ：
queryObjects(Promise) 做的是就是先手动执行一次垃圾回收，然后输出当前页面内存里还存在的 promise 对象。有 0 个，证明所有的 promise 对象都已经被回收了。
为了更明确的看到回收的确发生了，我们还可以给传入 test() 的 promise 对象和 test() 返回的 promise 对象都添加上垃圾回收的回调：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-14T18:58:44+08:00">
    <meta property="article:modified_time" content="2024-07-14T18:58:44+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JavaScript 中 await 永远不会 resolve 的 Promise 会导致内存泄露吗？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>前言</h3> 
<p>在 JavaScript 中，<code>await</code> 关键字用于等待一个 Promise 完成，它只能在异步函数（<code>async function</code>）内部使用。当 <code>await</code> 一个永远不会 resolve 的 Promise 时，它确实会阻塞异步函数的进一步执行，但不会直接导致内存泄露（memory leak）。然而，这种情况可能会间接导致问题，特别是在处理资源（如数据库连接、文件句柄、网络请求等）时。</p> 
<h4>为什么说它不会直接导致内存泄露？</h4> 
<p>内存泄露通常指的是程序在不需要某些内存时未能释放它，导致内存使用量持续增加。在 JavaScript（特别是在 V8 引擎中，Chrome 和 Node.js 的 JavaScript 引擎）中，垃圾回收器（Garbage Collector, GC）会定期清理不再被引用的对象。如果一个 Promise 永远不会 resolve，那么它自身及其依赖的对象（除非有其他引用指向它们）最终会因为没有任何引用指向它们而被垃圾回收器回收。</p> 
<h4>间接问题</h4> 
<p>尽管 <code>await</code> 一个永远不会 resolve 的 Promise 不会直接导致内存泄露，但它可能导致以下问题：</p> 
<ol><li> <p><strong>阻塞执行</strong>：异步函数将停留在 <code>await</code> 表达式处，无法继续执行后续代码，这可能会阻塞事件循环中的其他任务。</p> </li><li> <p><strong>资源占用</strong>：如果 Promise 依赖于某些外部资源（如数据库连接、文件句柄、网络请求等），这些资源将不会被释放，直到 Promise 被解决或拒绝。如果 Promise 永远不解决，这些资源可能会长时间被占用，甚至可能导致资源耗尽。</p> </li><li> <p><strong>死锁和性能问题</strong>：在复杂的应用程序中，多个异步操作可能相互依赖。如果一个操作因为等待一个永远不会 resolve 的 Promise 而阻塞，它可能会阻止其他依赖它的操作执行，从而导致死锁或性能问题。</p> </li></ol> 
<p>想要知道 <a href="https://www.zhihu.com/search?q=promise&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3270699180%7D" rel="nofollow" title="promise">promise</a> 对象有没有被回收掉，可以在控制台使用 queryObjects() ：</p> 
<p></p> 
<p class="img-center"><img alt="" height="348" src="https://images2.imgbox.com/9a/46/3BS9M0WS_o.png" width="760"></p> 
<p>queryObjects(Promise) 做的是就是先手动执行一次垃圾回收，然后输出当前页面内存里还存在的 promise 对象。有 0 个，证明所有的 promise 对象都已经被回收了。</p> 
<p>为了更明确的看到回收的确发生了，我们还可以给传入 test() 的 promise 对象和 test() 返回的 promise 对象都添加上垃圾回收的回调：</p> 
<p></p> 
<p class="img-center"><img alt="" height="475" src="https://images2.imgbox.com/40/26/Ivn3tWfR_o.png" width="720"></p> 
<p>可以看到，这两万个永远不会 resolve 的 promise 都被回收了，这也是符合预期的。</p> 
<p><a href="https://www.zhihu.com/search?q=JS%20%E6%A0%87%E5%87%86&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3270699180%7D" rel="nofollow" title="JS 标准">JS 标准</a>应该没有制定垃圾回收的具体细节，任何的对象何时被回收，甚至完全不回收，可能都不算是违反规范，毕竟 <a href="https://www.zhihu.com/search?q=test262&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3270699180%7D" rel="nofollow" title="test262">test262</a> 里没有相关测试。不过规范实际制定时肯定还是要考虑逻辑上不能存在<a href="https://www.zhihu.com/search?q=%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3270699180%7D" rel="nofollow" title="内存泄漏">内存泄漏</a>的。</p> 
<p>所以这些都是引擎实现的知识，只有少数引擎开发能讲清楚这些细节，我只知道一点皮毛，下面是我的推测。</p> 
<p>想要一个对象不被回收，必须有地方引用了它，除了直接引用，还可以间接的引用，比如：</p> 
<pre><code>new Promise((resolve, reject) =&gt; { 
  window.foo = resolve 
})
</code></pre> 
<p>因为全局变量 foo 引用了 resolve 函数，这个函数比较特殊，在 <a href="https://www.zhihu.com/search?q=C%2B%2B&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3270699180%7D" rel="nofollow" title="C++">C++</a> 层面其实引用了它所属的 promise 对象，所以会导致 promise 对象一直可达（reachable），也就无法被垃圾回收。</p> 
<pre><code>new Promise(resolve =&gt; {
  setTimeout(resolve, 10000)
})
</code></pre> 
<p>像这个 promise，在 10 秒后才会被垃圾回收，10 秒内全局的任务队列里有个定时器任务引用了它，定时器执行完销毁后，这个 promise 对象就变成不可达的，从而也就被回收了。</p> 
<p>如果 resolve 和 reject 都没被引用，它就会被直接回收掉：</p> 
<pre><code>new Promise(() =&gt; {})
</code></pre> 
<p>除非有其它引用，比如你示例里的 p：</p> 
<pre><code>async function test(p) {
  await p
}

test(new Promise(() =&gt; {}))
</code></pre> 
<p>这个局部变量 p 的确引用了 promise 对象，那这个 promise 被回收只有一个可能，就是 p 也不在了，实际上的确是，这个 test 函数的执行上下文也被回收了，虽然它还没执行完。</p> 
<p>实际上 V8 的 async function 在 parser 阶段是被 desugar 成 generator 的 <a href="https://link.zhihu.com/?target=https%3A//docs.google.com/document/d/1K38ct2dsxG_9OfmgErvFld4MPDC4Wkr8tPuqmSWu_3Y/edit" rel="nofollow" title="https://docs.google.com/document/d/1K38ct2dsxG_9OfmgErvFld4MPDC4Wkr8tPuqmSWu_3Y/edit">https://docs.google.com/document/d/1K38ct2dsxG_9OfmgErvFld4MPDC4Wkr8tPuqmSWu_3Y/edit</a>，所以 test 函数在实际执行时可能类似于：</p> 
<pre><code>function* test(p) {
  yield p
  console.log(p)
}

test(new Promise(() =&gt; {}))
</code></pre> 
<p><a href="https://www.zhihu.com/search?q=%E7%94%9F%E6%88%90%E5%99%A8&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3270699180%7D" rel="nofollow" title="生成器">生成器</a>在 yield p 这里停住，就类似于 await p 停住，因为已经没有办法引用到生成器的 next() 方法了，引擎就知道它不可能继续执行了，从而就一连串回收掉了所有的相关对象，具体的细节我是讲不清楚的。</p> 
<h4>解决方案</h4> 
<ul><li> <p><strong>超时机制</strong>：为 <code>await</code> 操作设置超时，以便在 Promise 无法在指定时间内 resolve 时采取适当的行动（如重试、记录错误或释放资源）。</p> </li><li> <p><strong>错误处理</strong>：确保 Promise 的错误处理逻辑是健全的，以便在 Promise 被拒绝时能够适当响应。</p> </li><li> <p><strong>资源清理</strong>：确保所有外部资源在使用完毕后都被正确释放，无论 Promise 是否 resolve。</p> </li><li> <p><strong>监控和日志</strong>：对异步操作进行监控，并在出现问题时记录详细的日志，以便快速定位和解决问题。</p> </li></ul> 
<p>总之，虽然 <code>await</code> 一个永远不会 resolve 的 Promise 不会直接导致内存泄露，但它可能导致其他严重的问题，因此应该避免这种情况的发生。</p> 
<blockquote> 
 <p>仅供参考!!!</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e9a38988ae232afadf58745c776a4276/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">轻松上手MYSQL：掌握MYSQL聚合函数，数据分析不再难</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1741a16bc21ce1f37f604629ca3b48dc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【机器学习-00】机器学习是什么？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>