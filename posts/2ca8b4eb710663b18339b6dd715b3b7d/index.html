<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>回溯组合篇--代码随想录算法训练营第二十一天| 回溯算法介绍，77. 组合，216.组合总和III，17.电话号码的字母组合，39. 组合总和，40.组合总和II - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/2ca8b4eb710663b18339b6dd715b3b7d/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="回溯组合篇--代码随想录算法训练营第二十一天| 回溯算法介绍，77. 组合，216.组合总和III，17.电话号码的字母组合，39. 组合总和，40.组合总和II">
  <meta property="og:description" content="回溯算法介绍 回溯算法理论基础https://www.programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80
终止条件：达到树最大深度 &amp;&amp; 满足题目额外条件
void backtracking(参数) { if (终止条件) { //常常跟树的深度有关 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { //某一层的宽度 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } 77. 组合 题目链接：. - 力扣（LeetCode） 讲解视频： 未优化：带你学透回溯算法-组合问题（对应力扣题目：77.组合） 优化：组合问题的剪枝操作
题目描述： 给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。
你可以按 任何顺序 返回答案。
示例 1：
输入：n = 4, k = 2 输出： [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] 解题思路： 树的宽度：1~n n个数
树的最大深度：k个数组合
额外条件：无">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-06T15:02:02+08:00">
    <meta property="article:modified_time" content="2024-08-06T15:02:02+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">回溯组合篇--代码随想录算法训练营第二十一天| 回溯算法介绍，77. 组合，216.组合总和III，17.电话号码的字母组合，39. 组合总和，40.组合总和II</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>回溯算法介绍</h2> 
<p><a href="https://www.programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80" rel="nofollow" title="回溯算法理论基础"><span class="link-card-box"><span class="link-title">回溯算法理论基础</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/6c/76/OiY0MIRK_o.png" alt="icon-default.png?t=N7T8">https://www.programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80</span></span></a></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/6e/76/HeQkDFZ0_o.png" width="1142"></p> 
<p><img alt="" height="736" src="https://images2.imgbox.com/1f/dd/03kBraZY_o.png" width="1200"> 终止条件：达到树最大深度 &amp;&amp; 满足题目额外条件</p> 
<pre><code class="language-cpp">void backtracking(参数) {
    if (终止条件) { //常常跟树的深度有关
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { //某一层的宽度
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}</code></pre> 
<h2 id="第77题-组合">77. 组合</h2> 
<h3>题目链接：<a href="https://leetcode.cn/problems/combinations/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></h3> 
<h3>讲解视频：</h3> 
<p>未优化：<strong><a href="https://www.bilibili.com/video/BV1ti4y1L7cv" rel="nofollow" title="带你学透回溯算法-组合问题（对应力扣题目：77.组合）">带你学透回溯算法-组合问题（对应力扣题目：77.组合）</a></strong> </p> 
<p>优化：<strong><a href="https://www.bilibili.com/video/BV1wi4y157er" rel="nofollow" title="组合问题的剪枝操作">组合问题的剪枝操作</a></strong></p> 
<h3>题目描述：</h3> 
<p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p> 
<p>你可以按 <strong>任何顺序</strong> 返回答案。</p> 
<p><strong>示例 1：</strong></p> 
<pre><strong>输入：</strong>n = 4, k = 2
<strong>输出：</strong>
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
</pre> 
<h3>解题思路：</h3> 
<blockquote> 
 <p><strong>树的宽度</strong>：1~n n个数</p> 
 <p><strong>树的最大深度</strong>：k个数组合</p> 
 <p><strong>额外条件</strong>：无</p> 
 <p><strong>终止条件</strong>：找到k个数组合</p> 
 <p><strong>剪枝</strong>：只能往后取数，若从某一位置起其后边的数不能满足题目条件，则直接舍弃。本题中若从某数开始其后数字个数达不到k，则舍弃。即保证for循环中永远都能遍历至k个数，满足i&lt;=n - (k - path.size()) + 1;</p> 
</blockquote> 
<p><img alt="" height="658" src="https://images2.imgbox.com/bc/1e/SbavAYUc_o.png" width="1200"></p> 
<p><img alt="" height="1054" src="https://images2.imgbox.com/94/21/nl2uWRox_o.png" width="1200"></p> 
<h3>代码：</h3> 
<p>优化版：</p> 
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; result;
    vector&lt;int&gt; path;
    void traversal(int n, int k, int startIdx)
    {
        if(path.size() == k) 
        {
            result.push_back(path);
            return;
        }
        for(int i = startIdx; i &lt;= n - (k - path.size()) + 1; i++)
        {
            path.push_back(i);
            traversal(n,k,i+1);
            path.pop_back();
        }
    }
    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) {
        traversal(n,k,1);
        return result;
    }
};</code></pre> 
<h2 id="_216-组合总和iii">216.组合总和III</h2> 
<h3>题目链接：<a href="https://leetcode.cn/problems/combination-sum-iii/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></h3> 
<h3>讲解视频：</h3> 
<p><strong><a href="https://www.bilibili.com/video/BV1wg411873x" rel="nofollow" title="和组合问题有啥区别？回溯算法如何剪枝？| LeetCode：216.组合总和III">和组合问题有啥区别？回溯算法如何剪枝？| LeetCode：216.组合总和III</a></strong></p> 
<h3>题目描述：</h3> 
<p>找出所有相加之和为 <code>n</code><em> </em>的 <code>k</code><strong> </strong>个数的组合，且满足下列条件：</p> 
<ul><li>只使用数字1到9</li><li>每个数字 <strong>最多使用一次</strong> </li></ul> 
<p>返回 <em>所有可能的有效组合的列表</em> 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p> 
<p><strong>示例 1:</strong></p> 
<pre><strong>输入:</strong> <em><strong>k</strong></em> = 3, <em><strong>n</strong></em> = 7
<strong>输出:</strong> [[1,2,4]]
<strong>解释:</strong>
1 + 2 + 4 = 7
没有其他符合的组合了</pre> 
<h3>解题思路：</h3> 
<blockquote> 
 <p><strong>树的宽度</strong>：1~9 9个数</p> 
 <p><strong>树的最大深度</strong>：k个数组合</p> 
 <p><strong>额外条件</strong>：数字和为n</p> 
 <p><strong>终止条件</strong>：数字和为n &amp;&amp; 找到k个数组合</p> 
 <p><strong>剪枝</strong>：若数字和大于n，则return；只能往后取数，若从某数开始其后数字个数达不到k，则舍弃。即保证for循环中永远都能遍历至k个数，满足i&lt;=9 - (k - path.size()) + 1;</p> 
</blockquote> 
<p><img alt="" height="1046" src="https://images2.imgbox.com/27/b7/9piy0ZNk_o.png" width="1200"></p> 
<h3>代码：</h3> 
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; result;
    vector&lt;int&gt; path;
    void traversal(int k ,int targetSum, int sum, int startIdx)
    {
        if(sum &gt; targetSum) return;
        if(path.size() == k) 
        {
            if(sum == targetSum)
            {
                result.push_back(path);
                return;
            }
        }
        for(int i = startIdx; i &lt;= 10 - (k - path.size()); i++)
        {
            sum += i;
            path.push_back(i);
            traversal(k,targetSum,sum,i+1);
            path.pop_back();
            sum -= i;
        }
    }
    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) {
        traversal(k,n,0,1);
        return result;
    }
};</code></pre> 
<h2 id="_17-电话号码的字母组合">17.电话号码的字母组合</h2> 
<h3>题目链接：<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></h3> 
<h3>讲解视频：</h3> 
<p><strong><a href="https://www.bilibili.com/video/BV1yV4y1V7Ug" rel="nofollow" title="还得用回溯算法！| LeetCode：17.电话号码的字母组合">还得用回溯算法！| LeetCode：17.电话号码的字母组合</a></strong></p> 
<h3>题目描述：</h3> 
<p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p> 
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p> 
<p></p> 
<p class="img-center"><img alt="" height="162" src="https://images2.imgbox.com/4f/13/Oz3hFM8d_o.png" width="200"></p> 
<p><strong>示例 1：</strong></p> 
<pre><strong>输入：</strong>digits = "23"
<strong>输出：</strong>["ad","ae","af","bd","be","bf","cd","ce","cf"]</pre> 
<h3>解题思路：</h3> 
<blockquote> 
 <p><strong>树的宽度</strong>：数字对应字母个数</p> 
 <p><strong>树的最大深度</strong>：输入字符串中数字个数</p> 
 <p><strong>额外条件</strong>：无</p> 
 <p><strong>终止条件</strong>：遍历完字符串中全部数字，即idx == digits.size()</p> 
 <p><strong>剪枝</strong>：无</p> 
</blockquote> 
<p><img alt="" height="728" src="https://images2.imgbox.com/fa/a1/PypVZd48_o.png" width="1200"></p> 
<h3>代码：</h3> 
<pre><code class="language-cpp">class Solution {
private:
    string letterMap[10]={
        "",
        "",
        "abc",
        "def",
        "ghi",
        "jkl",
        "mno",
        "pqrs",
        "tuv",
        "wxyz"
    };
public:
    vector&lt;string&gt;result;
    string s;
    void backtracking(const string&amp; digits, int idx)
    {
        if(idx == digits.size())
        {
            result.push_back(s);
            return ;
        }
        string letter = letterMap[digits[idx] - '0'];
        for(int i = 0; i &lt; letter.size(); i++)
        {
            s.push_back(letter[i]);
            backtracking(digits,idx+1);
            s.pop_back();
        }
    }
    vector&lt;string&gt; letterCombinations(string digits) {
        if(digits.size() == 0) return result;
        backtracking(digits,0);
        return result;
    }
};</code></pre> 
<h2 id="_39-组合总和">39. 组合总和</h2> 
<h3>题目链接：<a href="https://leetcode.cn/problems/combination-sum/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></h3> 
<h3>讲解视频：</h3> 
<p><strong><a href="https://www.bilibili.com/video/BV1KT4y1M7HJ" rel="nofollow" title="Leetcode:39. 组合总和讲解">Leetcode:39. 组合总和讲解</a></strong></p> 
<h3>题目描述：</h3> 
<p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有<em> </em><strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p> 
<p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p> 
<p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p> 
<p><strong>示例 1：</strong></p> 
<pre><strong>输入：</strong>candidates = <code>[2,3,6,7], </code>target = <code>7</code>
<strong>输出：</strong>[[2,2,3],[7]]
<strong>解释：</strong>
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。</pre> 
<h3>解题思路：</h3> 
<blockquote> 
 <p><strong>树的宽度：</strong>整数数组candidates的长度</p> 
 <p><strong>树的最大深度</strong>：当前选择数字组合和为target的数字数量</p> 
 <p><strong>额外条件</strong>：无</p> 
 <p><strong>终止条件</strong>：数字组合和为target</p> 
 <p><strong>剪枝</strong>：当和大于target时就return</p> 
 <p>由于题目中允许一个数可以重复使用，故递归时无需让i+1，仍传i即可</p> 
</blockquote> 
<p><img alt="" height="896" src="https://images2.imgbox.com/ff/f8/WyZLJxvt_o.png" width="1200"></p> 
<h3>代码：</h3> 
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; result;
    vector&lt;int&gt; path;
    void backtracking(const vector&lt;int&gt;&amp; candidates, int targetSum, int sum, int idx)
    {
        if(sum &gt; targetSum) return ;
        if(sum == targetSum) 
        {
            result.push_back(path);
            return;
        }
        for(int i = idx; i &lt;candidates.size(); i++)
        {
            path.push_back(candidates[i]);
            sum += candidates[i];
            backtracking(candidates,targetSum,sum,i);
            path.pop_back();
            sum -= candidates[i];
        }
    }
    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) {
        backtracking(candidates,target,0,0);
        return result;
    }
};</code></pre> 
<h2 id="_40-组合总和ii">40.组合总和II</h2> 
<h3>题目链接：<a href="https://leetcode.cn/problems/combination-sum-ii/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></h3> 
<h3>讲解视频：</h3> 
<p><strong><a href="https://www.bilibili.com/video/BV12V4y1V73A" rel="nofollow" title="回溯算法中的去重，树层去重树枝去重，你弄清楚了没？| LeetCode:40.组合总和II">回溯算法中的去重，树层去重树枝去重，你弄清楚了没？| LeetCode:40.组合总和II</a></strong></p> 
<h3>题目描述：</h3> 
<p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p> 
<p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p> 
<p><strong>注意：</strong>解集不能包含重复的组合。 </p> 
<p><strong>示例 1:</strong></p> 
<pre><strong>输入:</strong> candidates = [10,1,2,7,6,1,5], target = 8
<strong>输出:</strong>
[[1,1,6],[1,2,5],[1,7],[2,6]]</pre> 
<h3>解题思路：</h3> 
<blockquote> 
 <p><strong>树的宽度：</strong>整数数组candidates的长度</p> 
 <p><strong>树的最大深度</strong>：当前选择数字组合和为target的数字数量</p> 
 <p><strong>额外条件</strong>：无</p> 
 <p><strong>终止条件</strong>：数字组合和为target</p> 
 <p><strong>分析</strong>：横向不能有重复数，纵向可以有重复数（此处重复数是指candidates中<strong>不同位置</strong>相同的数）</p> 
 <p><strong>剪枝</strong>：当和大于target时就return；先对candidates数组进行排序，之后使用一个used数组标记candidates数组中对应位置数字是否被使用，若candidates[i] == candidates[i-1] &amp;&amp; used[i-1] == 0时就不在递归，直接跳转至下一个位置（横向used[i-1]一定为0，纵向used[i-1]一定为1）</p> 
</blockquote> 
<p><img alt="" height="1020" src="https://images2.imgbox.com/ca/4e/1SjjloId_o.png" width="1200"></p> 
<h3>代码：</h3> 
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; result;
    vector&lt;int&gt; path;
    void backtracking(const vector&lt;int&gt;&amp; candidates, int targetSum, vector&lt;int&gt;used, int sum, int idx)
    {
        if(sum &gt; targetSum) return ;
        if(sum == targetSum) 
        {
            result.push_back(path);
            return;
        }
        for(int i = idx; i &lt;candidates.size(); i++)
        {
            if(i &gt; 0 &amp;&amp; candidates[i] == candidates[i-1] &amp;&amp; used[i-1] == 0) continue;
            path.push_back(candidates[i]);
            sum += candidates[i];
            used[i] = 1;
            backtracking(candidates,targetSum,used,sum,i+1);
            path.pop_back();
            sum -= candidates[i];
            used[i] = 0;
        }
    }
    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) {
        vector&lt;int&gt; used(candidates.size(),0);
        sort(candidates.begin(),candidates.end());
        backtracking(candidates,target,used,0,0);
        return result;
    }
};</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/79b3c3b1c92da33596ed3403dd2d12f6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Unity强化工程 之 SpriteShape（精灵地形编辑器）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f64d02916ffd4472324f871afb9d1650/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">腾讯云AI代码助手评测：如何智能高效完成Go语言Web项目开发</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>