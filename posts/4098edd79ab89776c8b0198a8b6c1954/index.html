<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Faiss向量数据库 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/4098edd79ab89776c8b0198a8b6c1954/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Faiss向量数据库">
  <meta property="og:description" content="Faiss（Facebook AI Similarity Search）向量数据库是由Facebook AI研究院开发的一种高效相似性搜索和聚类的库。Faiss不仅支持在高维空间中进行高效的相似性搜索，还能够在处理大规模数据集时展现出卓越的性能，尤其适用于图像检索、文本搜索、推荐系统和语音处理等多种应用场景。 在推荐系统中，Faiss可以用于快速查找用户可能感兴趣的物品或寻找具有相似兴趣的用户。 在信息检索领域，Faiss可以用于构建文档或图像的相似性搜索引擎。在图像识别领域，Faiss可以用于构建图像特征的索引，实现快速的相似图像搜索和图像聚类。 安装Faiss： 💢cpu版本：
conda install -c pytorch faiss-cpu 💢gpu版本：
conda install -c pytorch faiss-gpu Faiss 处理固定维数 d 的向量集合，通常为几十到几百个。这些集合可以存储在矩阵中。我们假设采用行主存储，即向量编号 i 的第 j 个分量存储在矩阵的第 i 行、第 j 列中。Faiss 仅使用 32 位浮点矩阵。
import numpy as np d = 64 # 设置向量的维度为64 nb = 100000 # 向量数量为100,000 nq = 10000 # 查询向量的数量为10,000 np.random.seed(1234) # make reproducible xb = np.random.random((nb, d)).astype(&#39;float32&#39;) xb[:, 0] &#43;= np.arange(nb) / 1000. xq = np.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-09-03T15:37:51+08:00">
    <meta property="article:modified_time" content="2024-09-03T15:37:51+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Faiss向量数据库</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" src="https://images2.imgbox.com/29/32/jdMPN2yE_o.jpg"></p> 
<blockquote> 
 <p>Faiss（Facebook AI Similarity Search）向量数据库是由Facebook AI研究院开发的一种高效相似性搜索和聚类的库。Faiss不仅支持在高维空间中进行高效的相似性搜索，还能够在处理大规模数据集时展现出卓越的性能，尤其适用于图像检索、文本搜索、推荐系统和语音处理等多种应用场景。 </p> 
</blockquote> 
<ul><li>在推荐系统中，Faiss可以用于快速查找用户可能感兴趣的物品或寻找具有相似兴趣的用户。 </li><li>在信息检索领域，Faiss可以用于构建文档或图像的相似性搜索引擎。</li><li>在图像识别领域，Faiss可以用于构建图像特征的索引，实现快速的相似图像搜索和图像聚类。</li></ul> 
<h3> 安装Faiss：</h3> 
<p>💢cpu版本：</p> 
<pre><code class="language-python">conda install -c pytorch faiss-cpu</code></pre> 
<p>💢gpu版本：</p> 
<pre><code class="language-python">conda install -c pytorch faiss-gpu</code></pre> 
<p>Faiss 处理固定维数 d 的向量集合，通常为几十到几百个。这些集合可以存储在矩阵中。我们假设采用行主存储，即向量编号 i 的第 j 个分量存储在矩阵的第 i 行、第 j 列中。Faiss 仅使用 32 位浮点矩阵。</p> 
<pre><code class="language-python">import numpy as np
d = 64                           # 设置向量的维度为64
nb = 100000                      # 向量数量为100,000
nq = 10000                       # 查询向量的数量为10,000
np.random.seed(1234)             # make reproducible
xb = np.random.random((nb, d)).astype('float32')
xb[:, 0] += np.arange(nb) / 1000.
xq = np.random.random((nq, d)).astype('float32')
xq[:, 0] += np.arange(nq) / 1000.    # 修改查询向量的第一个维度</code></pre> 
<h3>建立索引 </h3> 
<p><span style="background-color:#ffd900;">Faiss 是围绕</span><code><span style="background-color:#ffd900;">Index</span></code><span style="background-color:#ffd900;">对象构建的。它封装了一组数据库向量，并可选地对它们进行预处理，以提高搜索效率。索引有很多种类型，我们将使用最简单的版本，即对它们进行强力的 L2 距离搜索：</span><code><span style="background-color:#ffd900;">IndexFlatL2</span></code><span style="background-color:#ffd900;">。</span></p> 
<p>所有索引在构建时都需要知道它们所操作的向量的维数，当索引建立并训练完成后，可以对索引进行两种操作：<code>add</code>和<code>search</code>。</p> 
<ul><li>当我们说一个索引是否被“训练”时，我们实际上是指该索引是否已经通过某种方式优化了其内部结构，以便更有效地处理搜索查询。 </li></ul> 
<pre><code class="language-python">import faiss                   
index = faiss.IndexFlatL2(d)   # 创建一个IndexFlatL2类型的索引
print(index.is_trained)        # 打印出索引是否已经被训练
index.add(xb)                  # 将向量添加到索引中
print(index.ntotal)</code></pre> 
<ul><li><code>IndexFlatL2</code>索引是一种简单的暴力搜索索引，它不需要训练过程，因为它直接计算查询向量与数据库中所有向量的L2距离，以找到最相似的向量。 </li></ul> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/6e/f9/WufA0qlL_o.png"> </p> 
<h3>搜索~</h3> 
<p><span style="color:#1f2328;"><span style="background-color:#ffffff;">可以在索引上执行的基本搜索操作是<code>k</code>最近邻搜索，即对于每个查询向量，<code>k</code>在数据库中找到其最近的邻居。</span></span></p> 
<p><span style="color:#1f2328;"><span style="background-color:#ffffff;">此操作的结果可以方便地存储在大小为<code>nq</code>-by-的整数矩阵中<code>k</code>，其中第 i 行包含查询向量 i 的邻居的 ID，按距离递增排序。除了这个矩阵之外，该<code>search</code>操作还返回一个<code>nq</code>-by-<code>k</code>浮点矩阵，其中包含相应的平方距离。</span></span></p> 
<pre><code class="language-python">k = 4                          # we want to see 4 nearest neighbors
D, I = index.search(xb[:5], k) # 在索引中搜索xb数组的前5个向量（xb[:5]）的k个最近邻居
print(I)
print(D)
D, I = index.search(xq, k)     # 整个查询集xq上搜索每个查询向量的k个最近邻居
print(I[:5])                   # 前5个查询向量的最近邻居的索引位置
print(I[-5:])   </code></pre> 
<ul><li><code>D</code>：包含了查询向量与其找到的最近邻居之间的距离。 </li><li><code>I</code>：也是一个数组，但它包含的是最近邻居在索引中的位置或索引。</li></ul> 
<p><span style="background-color:#ffd900;">结果：</span></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9f/1f/NcDJGirr_o.png"></p> 
<hr> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/ea/8a/5eJUifzm_o.png"></p> 
<p>💥由于索引中未添加任何向量，因此无法进行有效的相似性搜索。在实际应用中，我们需要先将向量添加到索引中，然后才能进行搜索操作。</p> 
<hr> 
<p>💥向索引添加向量：</p> 
<pre><code class="language-python">nb = 100000  # 假设有100,000个向量  
xb = np.random.random((nb, d)).astype('float32')  # 生成随机向量数据，100000个64维数据
index.add(xb)  # 将向量数据添加到索引中
# 优化索引(跳过)
</code></pre> 
<p>💯结果：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b8/b3/F3cNOmSJ_o.png"></p> 
<ul><li> 后两个为实际的搜索输出(前五和后五)。</li></ul> 
<h3><span style="color:#1f2328;">更快的搜索！</span></h3> 
<p><span style="color:#1f2328;"><span style="background-color:#ff9900;">为了加快搜索速度，可以将数据集分割成块。我们在 d 维空间中定义 Voronoi 单元，每个数据库向量都位于其中一个单元中。在搜索时，仅将查询 x 所在的单元中包含的数据库向量 y 和一些相邻的向量与查询向量进行比较。</span></span></p> 
<p><strong>这是通过<code>IndexIVFFlat</code>索引完成的。这种类型的索引需要一个训练阶段，可以对具有与数据库向量相同分布的任何向量集合执行。</strong></p> 
<p>还<code>IndexIVFFlat</code>需要另一个索引，即量化器，它将向量分配给 Voronoi 单元。每个单元由一个质心定义，找到向量所在的 Voronoi 单元就是在质心集合中找到向量的最近邻居。这是另一个索引的任务，通常是<code>IndexFlatL2</code>。</p> 
<pre><code class="language-python">nlist = 100
# nlist指定IndexIVFFlat索引中聚类中心的数量
k = 4
quantizer = faiss.IndexFlatL2(d)  
index = faiss.IndexIVFFlat(quantizer, d, nlist)
# 这个索引中，quantizer 被用作内部机制来量化向量，并将它们分配到倒排文件中的不同聚类中心

# assert 语句用于验证索引的状态，确保其在训练前后的行为符合预期。
assert not index.is_trained
index.train(xb)
print("~~训练完成~~")
assert index.is_trained
index.add(xb)                  
D, I = index.search(xq, k)     
print(I[-5:])                  
index.nprobe = 10              # 在搜索时控制要检查的聚类中心的数量
D, I = index.search(xq, k)
print(I[-5:])       

# quantizer 被“嵌入”到 index 中，是因为 index 需要使用 quantizer 的量化功能来将向量分配到正确的聚类中心，并实现高效的搜索。</code></pre> 
<ul><li><code>⭐️IndexIVFFlat</code>索引首先将向量空间划分为<code>nlist</code>个聚类中心，然后使用<code>quantizer</code>（<code>IndexFlatL2</code>索引）来量化这些中心。</li><li>⭐️在搜索时，<code>IndexIVFFlat</code>索引会先确定查询向量所属的聚类中心，然后只在该中心的向量中执行搜索，从而大大减少了计算量。</li><li><code>⭐️xb</code>（代表数据集的一部分或全部）来训练索引。这是为了优化量化器或聚类中心。</li><li>⭐️我们重新初始化了索引 index，所以第一次添加的操作就没有影响了。</li><li><span style="background-color:#ffd900;">🌟每创建一个索引，就相当于在向量搜索的上下文中创建了一个独立的、用于存储和查询向量的数据结构。</span></li></ul> 
<p>搜索方法有两个参数：<code>nlist</code>，即单元格数量，以及<code>nprobe</code>，即执行搜索时访问的单元格数量（共<code>nlist</code>）</p> 
<p><span style="background-color:#ffd900;">🧊</span><code><span style="background-color:#ffd900;">nprobe = 10:</span></code><span style="background-color:#ffd900;"> </span><img alt="" src="https://images2.imgbox.com/08/81/MmOFu0Ak_o.png"></p> 
<p><span style="background-color:#ffd900;">🧊nprobe = 1 ：</span></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/10/5f/OgvBxuUm_o.png"></p> 
<p>💢设置 nprobe = nlist 会得到与强力搜索相同的结果（但速度较慢）。 </p> 
<p>Faiss支持将索引保存到磁盘文件中，并在需要时重新加载它们。通过保存和重新加载索引，可以在不同的会话或应用程序中重用索引：</p> 
<pre><code class="language-python"># 保存索引  
faiss.write_index(index, 'index.faiss')  
  
# 加载索引  
index = faiss.read_index('index.faiss')</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a0047d9d8655bddf3d1add17133bbc53/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Linux】使用Linux实现小程序 - 进度条</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e860cf2cefeba8b6cc4521177fa5f15e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">rabbitmq高可用集群搭建</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>