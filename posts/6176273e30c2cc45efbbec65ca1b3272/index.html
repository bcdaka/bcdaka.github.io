<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言 之 整数在内存中的存储、大小端字节序和字节序的判断 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/6176273e30c2cc45efbbec65ca1b3272/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C语言 之 整数在内存中的存储、大小端字节序和字节序的判断">
  <meta property="og:description" content="文章目录 整数在内存中的存储大小端字节序和字节序判断大小端有大小端的原因高位和地位怎么区分？图例判断机器大端还是小端的例题 整数在内存中的存储 整数的2进制表示方法有三种，即 原码、反码和补码
三种表示方法均有符号位和数值位两部分，符号位用0表示“正”，用1表示“负”，而数值位最
高位的⼀位是被当做符号位，剩余的都是数值位。
正整数的原、反、补码都相同。
负整数的三种表示方法各不相同。
原码：直接将数值按照正负数的形式翻译成⼆进制得到的就是原码。
反码：将原码的符号位不变，其他位依次按位取反就可以得到反码。
补码：反码&#43;1就得到补码。
对于整形来说：数据存放内存中存放的是补码。
大小端字节序和字节序判断 例子：
#include &lt;stdio.h&gt; int main() { int a = 0x11223344; return 0; } 在这个例子中 int a = 0x11223344; 其中0x的意思是将11223344以16进制的形式存储，我们前面也提到过，16进制的1个位需要2进制的4个位来表示，比如16进制f表示15，那么2进制表示15就是1111，我们又知道这个a是整形，大小为4个字节，1个字节等于8个位，那么2个16进制位就刚好占用一个字节
通过调试的内存窗口，我们可以看到在a中的 0x11223344 这个数字是按照字节为单位，倒着存储的。这就是大小端的不同
大小端 其实超过⼀个字节的数据在内存中存储的时候，就会有存储顺序的问题，按照不同的存储顺序，我们分为大端字节序存储和小端字节序存储，下面是具体的概念：
⼤端（存储）模式：是指数据的低位字节内容保存在内存的高地址处，而数据的高位字节内容，保存在内存的低地址处。
小端（存储）模式：是指数据的低位字节内容保存在内存的低地址处，而数据的高位字节内容，保存在内存的高地址处。
有大小端的原因 这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着⼀个字节，⼀个字节为8
bit 位，但是在C语言中除了8 bit 的 char 之外，还有16 bit 的 short 型，32 bit 的 long 型（要看具体的编译器），另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于⼀个字节，那么必然存在着⼀个如何将多个字节安排的问题。因此就导致了⼤端存储模式和小端存
储模式。
知道是大小端之后，在像我们例子中的情况我们就可以知道内存中下一个地址单元所对应的内容
高位和地位怎么区分？ 其实高位和地位的区分就类似于我们的阿拉伯数字，例如数字123,3是个位，2是十位，1是百位，那么3就是低位，所以类似的，0x11223344中，44就是低位了
图例 判断机器大端还是小端的例题 #include &lt;stdio.h&gt; int check_sys() { int i = 1; return (*(char *)&amp;i); } int main() { int ret = check_sys(); if(ret == 1) { printf(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-23T20:03:40+08:00">
    <meta property="article:modified_time" content="2024-08-23T20:03:40+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言 之 整数在内存中的存储、大小端字节序和字节序的判断</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">整数在内存中的存储</a></li><li><a href="#_15" rel="nofollow">大小端字节序和字节序判断</a></li><li><ul><li><a href="#_31" rel="nofollow">大小端</a></li><li><a href="#_37" rel="nofollow">有大小端的原因</a></li><li><a href="#_43" rel="nofollow">高位和地位怎么区分？</a></li><li><a href="#_46" rel="nofollow">图例</a></li><li><a href="#_48" rel="nofollow">判断机器大端还是小端的例题</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>整数在内存中的存储</h2> 
<p>整数的2进制表示方法有三种，即 原码、反码和补码<br> 三种表示方法均有符号位和数值位两部分，符号位用0表示“正”，用1表示“负”，而数值位最<br> 高位的⼀位是被当做符号位，剩余的都是数值位。</p> 
<p>正整数的原、反、补码都相同。</p> 
<p>负整数的三种表示方法各不相同。<br> 原码：直接将数值按照正负数的形式翻译成⼆进制得到的就是原码。<br> 反码：将原码的符号位不变，其他位依次按位取反就可以得到反码。<br> 补码：反码+1就得到补码。</p> 
<p><strong>对于整形来说：数据存放内存中存放的是补码。</strong></p> 
<h2><a id="_15"></a>大小端字节序和字节序判断</h2> 
<p><strong>例子：</strong></p> 
<pre><code>#include &lt;stdio.h&gt;
int main()
{
	int a = 0x11223344;

	return 0;
}
</code></pre> 
<p>在这个例子中 <code>int a = 0x11223344;</code> 其中0x的意思是将<strong>11223344</strong>以16进制的形式存储，我们前面也提到过，<strong>16进制的1个位需要2进制的4个位来表示</strong>，比如16进制f表示15，那么2进制表示15就是1111，我们又知道这个a是整形，大小为4个字节，1个字节等于8个位，<strong>那么2个16进制位就刚好占用一个字节</strong></p> 
<p>通过调试的内存窗口，我们可以看到在a中的 0x11223344 这个数字是按照字节为单位，倒着存储的。这就是大小端的不同<br> <img src="https://images2.imgbox.com/92/bc/bmxEEzvk_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_31"></a>大小端</h3> 
<p>其实超过⼀个字节的数据在内存中存储的时候，就会有存储顺序的问题，按照不同的存储顺序，我们分为大端字节序存储和小端字节序存储，下面是具体的概念：</p> 
<blockquote> 
 <p>⼤端（存储）模式：是指<strong>数据的低位字节内容</strong>保存在<strong>内存的高地址</strong>处，而<strong>数据的高位字节内容</strong>，保存在<strong>内存的低地址</strong>处。<br> 小端（存储）模式：是指<strong>数据的低位字节内容</strong>保存在<strong>内存的低地址</strong>处，而<strong>数据的高位字节内容</strong>，保存在<strong>内存的高地址</strong>处。</p> 
</blockquote> 
<h3><a id="_37"></a>有大小端的原因</h3> 
<p>这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着⼀个字节，⼀个字节为8<br> bit 位，但是在C语言中除了8 bit 的 char 之外，还有16 bit 的 short 型，32 bit 的 long 型（要看具体的编译器），另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于⼀个字节，那么必然<strong>存在着⼀个如何将多个字节安排的问题</strong>。因此就导致了⼤端存储模式和小端存<br> 储模式。</p> 
<p><strong>知道是大小端之后，在像我们例子中的情况我们就可以知道内存中下一个地址单元所对应的内容</strong></p> 
<h3><a id="_43"></a>高位和地位怎么区分？</h3> 
<p>其实高位和地位的区分就类似于我们的阿拉伯数字，例如数字123,3是个位，2是十位，1是百位，那么3就是低位，所以类似的，0x11223344中，44就是低位了</p> 
<h3><a id="_46"></a>图例</h3> 
<p><img src="https://images2.imgbox.com/2b/4f/DyXmznQv_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_48"></a>判断机器大端还是小端的例题</h3> 
<pre><code>#include &lt;stdio.h&gt;
int check_sys()
{
 int i = 1;
 return (*(char *)&amp;i);
}
int main()
{
 int ret = check_sys();
 if(ret == 1)
 {
 printf("小端\n");
 }
 else
 {
 printf("大端\n");
 }
 return 0;
}

</code></pre> 
<p><strong>解析：</strong> 因为我们知道i为整形，大小为4个字节，而整形在空间中是使用二进制的方式进行存储的，<code>return (*(char *)&amp;i);</code>之所以要将i强转为char* 类型，就是因为char* 只能读取一个字节大小的空间，i在内存空间中，肯定是一端为0，一端为1，i的二进制的形式那就是最右端为1，即1为低位，当使用char*去读取这个i的内存空间时，访问的是低地址位置，若解引用得到的值是1，那就符合小端，反之则大端</p> 
<p><img src="https://images2.imgbox.com/7e/09/aCWbC1s4_o.png" alt="在这里插入图片描述"></p> 
<p><strong>输出结果：</strong><br> <img src="https://images2.imgbox.com/bf/05/iu2a88Kw_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3b8973702d2b3941669e032ab0b9bb74/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言试题（含答案解析）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/00ffcfab7ebd03ef0ccf20a469455108/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">密码生成器（HTML&#43;CSS&#43;JavaScript）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>