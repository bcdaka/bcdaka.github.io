<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【算法/题目】：递归、搜索训练 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b5488a698396d7471b68f9b5b226bb90/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【算法/题目】：递归、搜索训练">
  <meta property="og:description" content="✨ 吾与春风皆过客，君携春水揽星河 🌏 📃个人主页：island1314
🔥个人专栏：算法训练
🚀 欢迎关注：👍点赞 👂🏽留言 😍收藏 💞 💞 💞
目录
1. 找出所有子集的异或总和再求和
2. N皇后
3. 有效的数独
4、解数独
5、单词搜索
6、黄金矿工
7、不同路径III
1. 找出所有子集的异或总和再求和 思路：
假设存在[1,2,3]这个集合，那么开始的时候是空集合，画出其决策树
全局变量：sum和path
sum用于求异或和，path用来当进入某一层时，异或该数，
方法dfs : dfs(nums[]，pos) 在pos那层
回溯：异或运算：消消乐（相同的数异或为0）
AC代码如下：
int path, sum; void dfs(vector&lt;int&gt;&amp; nums, int pos) { sum &#43;= path; for (int i = pos; i &lt; nums.size(); i&#43;&#43;) { path ^= nums[i]; dfs(nums, i &#43; 1); path ^= nums[i]; //恢复现场 } } int subsetXORSum(vector&lt;int&gt;&amp; nums) { dfs(nums, 0); return sum; } 2.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-08T15:57:19+08:00">
    <meta property="article:modified_time" content="2024-08-08T15:57:19+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【算法/题目】：递归、搜索训练</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="810" src="https://images2.imgbox.com/4f/68/4gP40otd_o.jpg" width="1200"></p> 
<p>✨                                                 <strong><span style="color:#38d8f0;">吾与春风皆过客，君携春水揽星河</span></strong>         🌏 </p> 
<p>📃<a href="https://so.csdn.net/so/search?q=%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5&amp;spm=1001.2101.3001.7020" title="个人主页">个人主页</a>：<a href="https://blog.csdn.net/island1314?spm=1011.2266.3001.5343" title="island1314">island1314</a></p> 
<p>🔥个人专栏：<a href="https://blog.csdn.net/island1314/category_12727921.html" title="算法训练">算法训练</a></p> 
<p>🚀 欢迎关注：👍点赞 👂🏽留言 😍收藏  💞 💞 💞</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2d/2a/4iYUVYF1_o.gif"></p> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%C2%A0%E6%89%BE%E5%87%BA%E6%89%80%E6%9C%89%E5%AD%90%E9%9B%86%E7%9A%84%E5%BC%82%E6%88%96%E6%80%BB%E5%92%8C%E5%86%8D%E6%B1%82%E5%92%8C-toc" style="margin-left:40px;"><a href="#1.%C2%A0%E6%89%BE%E5%87%BA%E6%89%80%E6%9C%89%E5%AD%90%E9%9B%86%E7%9A%84%E5%BC%82%E6%88%96%E6%80%BB%E5%92%8C%E5%86%8D%E6%B1%82%E5%92%8C" rel="nofollow">1. 找出所有子集的异或总和再求和</a></p> 
<p id="2.%20%C2%A0N%E7%9A%87%E5%90%8E-toc" style="margin-left:40px;"><a href="#2.%20%C2%A0N%E7%9A%87%E5%90%8E" rel="nofollow">2.  N皇后</a></p> 
<p id="3.%20%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC-toc" style="margin-left:40px;"><a href="#3.%20%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC" rel="nofollow">3. 有效的数独</a></p> 
<p id="4%E3%80%81%E8%A7%A3%E6%95%B0%E7%8B%AC-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E8%A7%A3%E6%95%B0%E7%8B%AC" rel="nofollow">4、解数独</a></p> 
<p id="5%E3%80%81%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2-toc" style="margin-left:40px;"><a href="#5%E3%80%81%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2" rel="nofollow">5、单词搜索</a></p> 
<p id="6%E3%80%81%E9%BB%84%E9%87%91%E7%9F%BF%E5%B7%A5-toc" style="margin-left:40px;"><a href="#6%E3%80%81%E9%BB%84%E9%87%91%E7%9F%BF%E5%B7%A5" rel="nofollow">6、黄金矿工</a></p> 
<p id="7%E3%80%81%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84III-toc" style="margin-left:40px;"><a href="#7%E3%80%81%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84III" rel="nofollow">7、不同路径III</a></p> 
<p></p> 
<hr> 
<h3 id="1.%C2%A0%E6%89%BE%E5%87%BA%E6%89%80%E6%9C%89%E5%AD%90%E9%9B%86%E7%9A%84%E5%BC%82%E6%88%96%E6%80%BB%E5%92%8C%E5%86%8D%E6%B1%82%E5%92%8C">1. <a href="https://leetcode.cn/problems/sum-of-all-subset-xor-totals/description/" rel="nofollow" title="找出所有子集的异或总和再求和">找出所有子集的异或总和再求和</a></h3> 
<p><img alt="" height="646" src="https://images2.imgbox.com/92/aa/f7C5OqPk_o.png" width="977"></p> 
<blockquote> 
 <p><span style="color:#ad720d;"><strong>思路：</strong></span></p> 
 <p>        假设存在[1,2,3]这个集合，那么开始的时候是空集合，画出其决策树</p> 
 <p><img alt="" height="801" src="https://images2.imgbox.com/85/31/xSbQFk7B_o.png" width="924"></p> 
 <p><strong>全局变量：</strong>sum和path</p> 
 <p>sum用于求异或和，path用来当进入某一层时，异或该数，</p> 
 <p><strong>方法dfs :</strong> dfs(nums[]，pos) 在pos那层</p> 
 <p><strong>回溯：</strong>异或运算：消消乐（相同的数异或为0）</p> 
</blockquote> 
<p><span style="color:#a2e043;"><strong>AC代码</strong></span>如下：</p> 
<pre><code class="language-cpp">int path, sum;
void dfs(vector&lt;int&gt;&amp; nums, int pos)
{
	sum += path;
	for (int i = pos; i &lt; nums.size(); i++)
	{
		path ^= nums[i];
		dfs(nums, i + 1);
		path ^= nums[i]; //恢复现场
	}
}
int subsetXORSum(vector&lt;int&gt;&amp; nums) {
	dfs(nums, 0);
	return sum;
}</code></pre> 
<h3 id="2.%20%C2%A0N%E7%9A%87%E5%90%8E">2. <a class="link-info" href="https://leetcode.cn/problems/n-queens/description/" rel="nofollow" title=" N皇后"> N皇后</a></h3> 
<p><img alt="" height="1026" src="https://images2.imgbox.com/8a/80/aW0x4cs3_o.png" width="1010"></p> 
<blockquote> 
 <p><strong><span style="color:#ad720d;">思路：</span></strong></p> 
 <p>深度优先遍历（DFS）</p> 
 <p><img alt="" height="860" src="https://images2.imgbox.com/f3/7e/o4xdFqvl_o.png" width="1200"></p> 
 <p><strong>函数名：void dfs(int r): </strong>深度优先遍历函数。参数r：从第r行开始放棋子，处理第r行。</p> 
 <p><strong>递归结束判定：</strong>见代码，当 r == n的时候，说明应该处理第 n行了，也代表第 0~n-1行放好棋子，也就是整个棋盘放好了棋子，也就是得到了一种解，也就是递归结束。</p> 
 <p><strong>第r行，第i列能不能放棋子：</strong>用<strong>数组dg udl</strong> 分别表示：点对应的两个斜线以及列上是否有皇后。<br><strong>dg[x + y] </strong>表示 y行x列处，所在的对角线上有没有棋子，<strong>udg[n - x + y]</strong>表示 r行i列处，所在的反对角线上有没有棋子，cor[i]表示第i列上有没有棋子。如果 y行x列的对角线，反对角线上都没有棋子，即!col[x] &amp;&amp; !dg[i + r] &amp;&amp; !udg[n - i + r]为真，则代表 x行y列处可以放棋子。</p> 
</blockquote> 
<p><span style="color:#a2e043;"><strong>AC代码</strong></span>如下：</p> 
<pre><code class="language-cpp">vector&lt;vector&lt;string&gt;&gt; ret;
vector&lt;string&gt; path;
bool col[20], udg[20], dg[20];
int n;

void dfs(int pos) {
    if (pos == n) {
        ret.push_back(path);
        return;
    }
    int x = pos;
    for (int y = 0; y &lt; n; y++) { // 尝试在这一行放皇后
        if (!col[y] &amp;&amp; !dg[y - x + n] &amp;&amp; !udg[y + x]) {
            col[y] = dg[y - x + n] = udg[y + x] = true;
            path[x][y] = 'Q';

            dfs(x + 1);
            path[x][y] = '.';
            col[y] = dg[y - x + n] = udg[y + x] = false;
        }
    }
}

vector&lt;vector&lt;string&gt;&gt; solveNQueens(int _n) {
    n = _n;
    path.resize(n);
    for (int i = 0; i &lt; n; i++) {
        path[i].append(n, '.');
    }
    dfs(0);
    return ret;
}
   </code></pre> 
<h3 id="3.%20%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC">3. <a class="link-info" href="https://leetcode.cn/problems/valid-sudoku/description/" rel="nofollow" title="有效的数独">有效的数独</a></h3> 
<p> <img alt="" height="985" src="https://images2.imgbox.com/33/cb/2rHnqA0y_o.png" width="920"></p> 
<blockquote> 
 <p><span style="color:#ad720d;"><strong>思路：</strong></span></p> 
 <p>创建二维数组 rows 和 col 分别记录数独的每一行和每一列中的每个数字的出现次数</p> 
 <p>创建三维数组 grid 记录数独的每一个小九宫格中的每个数字的出现次数</p> 
 <p>        其中rows[i][num]、columns[j][num] 和 gird[i / 3] [j / 3][num] 分别表示数独的第 i 行第 j 列的单元格所在的行、列和小九宫格中，数字 num + 1 出现的次数，其中 0≤ num &lt;9，对应的数字 num+1 满足 1≤num+1≤9。</p> 
 <p><img alt="" height="723" src="https://images2.imgbox.com/b7/92/lETrJzJE_o.png" width="1200"></p> 
</blockquote> 
<p><span style="color:#a2e043;"><strong>AC代码</strong></span>如下：</p> 
<pre><code class="language-cpp">bool col[9][10], row[9][10];
bool grid[3][3][10];
bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {
	for (int i = 0; i &lt; 9; i++) {
		for (int j = 0; j &lt; 9; j++) {
			if (board[i][j] != '.') {
				int num = board[i][j] - '0';
				if (row[i][num] || col[j][num] || grid[i / 3][j / 3][num])
					return false;
				row[i][num] = col[j][num] = grid[i / 3][j / 3][num] = true;
			}
		}
	}
	return true;
}</code></pre> 
<h3 id="4%E3%80%81%E8%A7%A3%E6%95%B0%E7%8B%AC"><strong>4、<a class="link-info" href="https://leetcode.cn/problems/sudoku-solver/description/" rel="nofollow" title="解数独">解数独</a></strong></h3> 
<p><img alt="" height="809" src="https://images2.imgbox.com/21/09/GjLkRhOB_o.png" width="1176"></p> 
<blockquote> 
 <p><span style="color:#ad720d;"><strong>思路：</strong></span></p> 
 <p>和上题类似的是，我们同样用</p> 
 <p>   创建二维数组 rows 和 col 分别记录数独的每一行和每一列中的每个数字的出现次数</p> 
 <p>   创建三维数组 grid 记录数独的每一个小九宫格中的每个数字的出现次数</p> 
 <p><strong>我们首先对整个数独数组进行遍历，当我们遍历到第 i 行第 j 列的位置：</strong></p> 
 <ul><li> <p>如果该位置是一个空白格，那么我们将其加入一个用来存储空白格位置的列表中，方便后续的递归操作；</p> </li><li> <p>如果该位置是一个数字 num，那么我们需要将 r<strong>ow[ i ][ num ]，col[ j ][num以及 block[ ⌊i/3⌋ ][ ⌊j/3⌋ ][num] </strong>均置为 True。</p> </li></ul> 
 <p>当我们结束了遍历过程之后，就可以开始递归枚举。当递归到第 i 行第 j 列的位置时，我们枚举填入的数字 num。根据题目的要求，<strong>数字 num 不能和当前行、列、九宫格中已经填入的数字相同</strong>，因此<strong> row[i][num] = col[j][num] = grid[i / 3][j / 3][num] = false;</strong></p> 
 <p></p> 
 <p>当我们填入了数字 num 之后，我们要将<strong>上述的三个值都置为 True</strong>，并且继续对下一个空白格位置进行递归。在回溯到当前递归层时，我们还要将上述的三个值重新置为 False。</p> 
</blockquote> 
<p><span style="color:#a2e043;"><strong>AC代码</strong></span>如下：</p> 
<pre><code class="language-cpp">bool row[9][10], col[9][10];//储存每一行每一列存在的数字 
bool grid[3][3][10]; //储存每一个 3*3宫存在的数字

bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board) {
	for (int i = 0; i &lt; 9; i++) {
		for (int j = 0; j &lt; 9; j++) {
			if (board[i][j] == '.') {
				//填数
				for (int num = 1; num &lt;= 9; num++) {
					if (!row[i][num] &amp;&amp; !col[j][num] &amp;&amp; !grid[i / 3][j / 3][num]) {
						board[i][j] = '0' + num;
						row[i][num] = col[j][num] = grid[i / 3][j / 3][num] = true;
						if (dfs(board) == true) return true;

						//恢复现场
						board[i][j] = '.';
						row[i][num] = col[j][num] = grid[i / 3][j / 3][num] = false;
					}
				}
				// 当前格子 1- 9 都不能填，那么就只能返回到上一个格子进行修改
				return false;
			}
		}
	}
	return true;
}

void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {
	//初始化
	for (int i = 0; i &lt; 9; i++) {
		for (int j = 0; j &lt; 9; j++) {
			if (board[i][j] != '.') {
				int num = board[i][j] - '0';
				row[i][num] = col[j][num] = grid[i / 3][j / 3][num] = true;
			}
		}
	}
	dfs(board);
}

</code></pre> 
<h3 id="5%E3%80%81%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2">5、<a class="link-info" href="https://leetcode.cn/problems/word-search/description/https://leetcode.cn/problems/word-search/description/" rel="nofollow" title="单词搜索">单词搜索</a></h3> 
<p><img alt="" height="772" src="https://images2.imgbox.com/1b/2a/XevXvgfq_o.png" width="1080"></p> 
<blockquote> 
 <p><span style="color:#ad720d;"><strong>思路：</strong></span></p> 
 <p>设函数<strong> dfs（board，words，x，y，pos）</strong> 表示判断以网格的 （x，y）位置出发，能否搜索到单词 words[pos..]，其中 words[pos..] 表示字符串 word 从第 pos 个字符开始的后缀子串。如果能搜索到，则返回 true，反之返回 false。函数 <strong>dfs（board，words，x，y，pos）</strong>的执行步骤如下：</p> 
 <ul><li>如果 board[ x ][ y ] = words[pos]，当前字符不匹配，直接返回 false。</li><li>如果当前已经访问到字符串的末尾，且对应字符依然匹配，此时直接返回 true。</li><li>否则，遍历当前位置的所有相邻位置。如果从某个相邻位置出发，能够搜索到子串 word[pos+1..]，则返回 true，否则返回 false。</li></ul> 
 <p>这样，我们<strong>对每一个位置 （x，y）</strong>都调用函数<strong> dfs（board，words，x，y，pos）</strong>进行检查：<strong>只要有一处返回 true</strong>，就说明网格中能够找到<strong>相应的单词</strong>，否则说明不能找到。</p> 
 <p>为了防止重复遍历相同的位置，需要额外维护一个与 board 等大的 st 数组，<strong>用于标识每个位置是否被访问过。每次遍历相邻位置时，需要跳过已经被访问的位置。</strong></p> 
 <p>注意：</p> 
 <p><strong>if (dfs(board, word, i, j, 0)) return true;，而不是return dfs(board, word, i, j, 0)；</strong></p> 
</blockquote> 
<p><span style="color:#a2e043;"><strong>AC代码</strong></span>如下：</p> 
<pre><code class="language-cpp">int dir[4][2] = {
		{1,0},{0,1},{-1,0},{0,-1}
};
int n, m;
bool st[505][505];

bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word, int x, int y, int pos) {
	if (pos == word.size()) return true;
	//向量的方式，定义上下左右四个位置

	for (int i = 0; i &lt; 4; i++) {
		int dx = x + dir[i][0], dy = y + dir[i][1];
		if (dx &gt;= 0 &amp;&amp; dx &lt; n &amp;&amp; dy &gt;= 0 &amp;&amp; dy &lt; m &amp;&amp; board[dx][dy] == word[pos] &amp;&amp; !st[dx][dy]) {
			st[dx][dy] = true;
			if (dfs(board, word, dx, dy, pos + 1)) return true;
			st[dx][dy] = false;
		}
	}
	return false;
}

bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) {
	n = board.size(), m = board[0].size();
	for (int i = 0; i &lt; n; i++) {
		for (int j = 0; j &lt; m; j++) {
			if (board[i][j] == word[0]) {
				st[i][j] = true;
				if (dfs(board, word, i, j, 1)) return true;
				st[i][j] = false;
			}
		}
	}
	return false;
}</code></pre> 
<p></p> 
<h3 id="6%E3%80%81%E9%BB%84%E9%87%91%E7%9F%BF%E5%B7%A5" style="background-color:transparent;">6、<a class="link-info" href="https://leetcode.cn/problems/path-with-maximum-gold/" rel="nofollow" title="黄金矿工">黄金矿工</a></h3> 
<p><img alt="" height="735" src="https://images2.imgbox.com/a4/10/wLBPVPqV_o.png" width="1078"></p> 
<blockquote> 
 <p><span style="color:#ad720d;"><strong>思路：</strong></span></p> 
 <p>该题与上题解题步骤基本类似，只不过该题需要多加一个参数sum，来记录每条的和，然后求出最大值即可。</p> 
</blockquote> 
<p><span style="color:#a2e043;"><strong>AC代码</strong></span>如下：</p> 
<pre><code class="language-cpp">int dir[4][2] = {
    {1,0},{0,1},{-1,0},{0,-1}
};
int maxi = 0;
int n, m;
bool st[505][505];

void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y, int sum) {
    maxi = max(maxi, sum);
    for (int i = 0; i &lt; 4; i++) {
        int dx = x + dir[i][0], dy = y + dir[i][1];
        if (dx &gt;= 0 &amp;&amp; dx &lt; n &amp;&amp; dy &gt;= 0 &amp;&amp; dy &lt; m &amp;&amp; grid[dx][dy] &gt; 0 &amp;&amp; !st[dx][dy]) {
            st[dx][dy] = true;
            dfs(grid, dx, dy, sum + grid[dx][dy]);
            st[dx][dy] = false;

        }
    }
}

int getMaximumGold(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
    n = grid.size(), m = grid[0].size();
    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; m; j++) {
            if (grid[i][j] != 0) {
                st[i][j] = true;
                dfs(grid, i, j, grid[i][j]);
                st[i][j] = false;
            }
        }
    }
    return maxi;
}</code></pre> 
<p></p> 
<h3 id="7%E3%80%81%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84III">7、<a class="link-info" href="https://leetcode.cn/problems/unique-paths-iii/" rel="nofollow" title="不同路径III">不同路径III</a></h3> 
<p><img alt="" height="643" src="https://images2.imgbox.com/87/0a/fye7o0df_o.png" width="1019"></p> 
<blockquote> 
 <p><span style="color:#ad720d;"><strong>思路：</strong></span></p> 
 <p>该题我们选择dfs的方法，主要步骤和 5、6题过程类似，但是在进行dfs之前，我们先需要做一些初始化的步骤，比如找到起始位置，和记录应该需要走的总步数</p> 
</blockquote> 
<p><span style="color:#a2e043;"><strong>AC代码</strong></span>如下：</p> 
<pre><code class="language-cpp">bool st[25][25];
int dir[4][2] = {
    {1,0},{0,1},{-1,0},{0,-1}
};
int ret, step; //统计走的方法，和需要走的总步数
int n, m;

void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y, int cnt) {
    if (grid[x][y] == 2) { //走到终止位置
        if (cnt == step) ret++; //看是否走完所有路程
        return;
    }
    for (int i = 0; i &lt; 4; i++) {
        int dx = x + dir[i][0], dy = y + dir[i][1];
        if (dx &gt;= 0 &amp;&amp; dx &lt; n &amp;&amp; dy &gt;= 0 &amp;&amp; dy &lt; m &amp;&amp; grid[dx][dy] != -1 &amp;&amp; !st[dx][dy]) {
            st[dx][dy] = true;
            dfs(grid, dx, dy, cnt + 1);
            st[dx][dy] = false;
        }
    }
}

int uniquePathsIII(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
    n = grid.size(), m = grid[0].size();
    
    int bx = 0, by = 0; //记录起始位置
    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; m; j++) {
            if (grid[i][j] == 0) step++; // 统计需要走的总步数
            else if (grid[i][j] == 1) bx = i, by = j;
        }
    }
    step += 2; //还需要加上起始位置和终止位置走的步数
    st[bx][by] = true;
    dfs(grid, bx, by, 1);
    return ret;
}</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e7/97/crqBphVN_o.gif"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/211de7562229e3eac6705296a2f72e80/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">docker上传镜像至阿里云</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cb7e71718e113214e5f89634a989ea4d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java 单元测试学习</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>