<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>大数据-11-案例演习-淘宝双11数据分析与预测 （期末问题） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/04b4f09655feda50b4678f54eeddcbff/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="大数据-11-案例演习-淘宝双11数据分析与预测 （期末问题）">
  <meta property="og:description" content="目录
第一部分
Hadoop是什么
官方解释：
个人总结
HDFS 是什么?
官方解释：
个人总结
yarn是什么?
官方解释：
个人总结
mapreduce，spark 是什么?
官方解释：
MapReduce
Spark
个人总结
MapReduce
Spark
spark 生态圈有哪些内容?
官方解释
个人总结
hbase 是什么?
官方解释
个人总结
hive 是什么?
官方解释
个人总结
eChart 是什么?
官方解释
个人总结
我们接触了哪些分布式计算框架?
官方解释
个人总结
实现 spark 编程的语言有哪些?
官方解释
个人总结
我们上课讲的是哪种编程语言?
个人总结
Hive 的执行需要计算引擎吗?
官方解释
个人总结
你知道有哪些计算引擎?
官方解释
个人总结
Spark RDD的一些考查
个人分析考察点
第二部分
实验环境准备
官方
个人分析考点
本地数据集上传到数据仓库Hive
官方
个人分析考察点
流程
Hive数据分析
官方
个人分析考点
流程
将数据从Hive导入到MySQL">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-12T22:10:56+08:00">
    <meta property="article:modified_time" content="2024-06-12T22:10:56+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">大数据-11-案例演习-淘宝双11数据分析与预测 （期末问题）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-toc" style="margin-left:0px;"><a href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86" rel="nofollow">第一部分</a></p> 
<p id="Hadoop%E6%98%AF%E4%BB%80%E4%B9%88-toc" style="margin-left:0px;"><a href="#Hadoop%E6%98%AF%E4%BB%80%E4%B9%88" rel="nofollow">Hadoop是什么</a></p> 
<p id="%E5%AE%98%E6%96%B9%E8%A7%A3%E9%87%8A%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E5%AE%98%E6%96%B9%E8%A7%A3%E9%87%8A%EF%BC%9A" rel="nofollow">官方解释：</a></p> 
<p id="%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93" rel="nofollow">个人总结</a></p> 
<p id="HDFS%20%E6%98%AF%E4%BB%80%E4%B9%88%3F-toc" style="margin-left:0px;"><a href="#HDFS%20%E6%98%AF%E4%BB%80%E4%B9%88%3F" rel="nofollow">HDFS 是什么?</a></p> 
<p id="%E5%AE%98%E6%96%B9%E8%A7%A3%E9%87%8A%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E5%AE%98%E6%96%B9%E8%A7%A3%E9%87%8A%EF%BC%9A" rel="nofollow">官方解释：</a></p> 
<p id="%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93" rel="nofollow">个人总结</a></p> 
<p id="yarn%E6%98%AF%E4%BB%80%E4%B9%88%3F-toc" style="margin-left:0px;"><a href="#yarn%E6%98%AF%E4%BB%80%E4%B9%88%3F" rel="nofollow">yarn是什么?</a></p> 
<p id="%E5%AE%98%E6%96%B9%E8%A7%A3%E9%87%8A%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E5%AE%98%E6%96%B9%E8%A7%A3%E9%87%8A%EF%BC%9A" rel="nofollow">官方解释：</a></p> 
<p id="%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93" rel="nofollow">个人总结</a></p> 
<p id="mapreduce%EF%BC%8Cspark%20%E6%98%AF%E4%BB%80%E4%B9%88%3F-toc" style="margin-left:0px;"><a href="#mapreduce%EF%BC%8Cspark%20%E6%98%AF%E4%BB%80%E4%B9%88%3F" rel="nofollow">mapreduce，spark 是什么?</a></p> 
<p id="%E5%AE%98%E6%96%B9%E8%A7%A3%E9%87%8A%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E5%AE%98%E6%96%B9%E8%A7%A3%E9%87%8A%EF%BC%9A" rel="nofollow">官方解释：</a></p> 
<p id="MapReduce-toc" style="margin-left:80px;"><a href="#MapReduce" rel="nofollow">MapReduce</a></p> 
<p id="Spark-toc" style="margin-left:80px;"><a href="#Spark" rel="nofollow">Spark</a></p> 
<p id="%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93" rel="nofollow">个人总结</a></p> 
<p id="MapReduce-toc" style="margin-left:80px;"><a href="#MapReduce" rel="nofollow">MapReduce</a></p> 
<p id="Spark-toc" style="margin-left:80px;"><a href="#Spark" rel="nofollow">Spark</a></p> 
<p id="spark%20%E7%94%9F%E6%80%81%E5%9C%88%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E5%AE%B9%3F-toc" style="margin-left:0px;"><a href="#spark%20%E7%94%9F%E6%80%81%E5%9C%88%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E5%AE%B9%3F" rel="nofollow">spark 生态圈有哪些内容?</a></p> 
<p id="%E5%AE%98%E6%96%B9%E8%A7%A3%E9%87%8A-toc" style="margin-left:40px;"><a href="#%E5%AE%98%E6%96%B9%E8%A7%A3%E9%87%8A" rel="nofollow">官方解释</a></p> 
<p id="%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93" rel="nofollow">个人总结</a></p> 
<p id="hbase%20%E6%98%AF%E4%BB%80%E4%B9%88%3F-toc" style="margin-left:0px;"><a href="#hbase%20%E6%98%AF%E4%BB%80%E4%B9%88%3F" rel="nofollow">hbase 是什么?</a></p> 
<p id="%E5%AE%98%E6%96%B9%E8%A7%A3%E9%87%8A-toc" style="margin-left:40px;"><a href="#%E5%AE%98%E6%96%B9%E8%A7%A3%E9%87%8A" rel="nofollow">官方解释</a></p> 
<p id="%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93" rel="nofollow">个人总结</a></p> 
<p id="hive%20%E6%98%AF%E4%BB%80%E4%B9%88%3F-toc" style="margin-left:0px;"><a href="#hive%20%E6%98%AF%E4%BB%80%E4%B9%88%3F" rel="nofollow">hive 是什么?</a></p> 
<p id="%E5%AE%98%E6%96%B9%E8%A7%A3%E9%87%8A-toc" style="margin-left:40px;"><a href="#%E5%AE%98%E6%96%B9%E8%A7%A3%E9%87%8A" rel="nofollow">官方解释</a></p> 
<p id="%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93" rel="nofollow">个人总结</a></p> 
<p id="eChart%20%E6%98%AF%E4%BB%80%E4%B9%88%3F-toc" style="margin-left:0px;"><a href="#eChart%20%E6%98%AF%E4%BB%80%E4%B9%88%3F" rel="nofollow">eChart 是什么?</a></p> 
<p id="%E5%AE%98%E6%96%B9%E8%A7%A3%E9%87%8A-toc" style="margin-left:40px;"><a href="#%E5%AE%98%E6%96%B9%E8%A7%A3%E9%87%8A" rel="nofollow">官方解释</a></p> 
<p id="%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93" rel="nofollow">个人总结</a></p> 
<p id="%E6%88%91%E4%BB%AC%E6%8E%A5%E8%A7%A6%E4%BA%86%E5%93%AA%E4%BA%9B%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E6%A1%86%E6%9E%B6%3F-toc" style="margin-left:0px;"><a href="#%E6%88%91%E4%BB%AC%E6%8E%A5%E8%A7%A6%E4%BA%86%E5%93%AA%E4%BA%9B%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E6%A1%86%E6%9E%B6%3F" rel="nofollow">我们接触了哪些分布式计算框架?</a></p> 
<p id="%E5%AE%98%E6%96%B9%E8%A7%A3%E9%87%8A-toc" style="margin-left:40px;"><a href="#%E5%AE%98%E6%96%B9%E8%A7%A3%E9%87%8A" rel="nofollow">官方解释</a></p> 
<p id="%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93" rel="nofollow">个人总结</a></p> 
<p id="%E5%AE%9E%E7%8E%B0%20spark%20%E7%BC%96%E7%A8%8B%E7%9A%84%E8%AF%AD%E8%A8%80%E6%9C%89%E5%93%AA%E4%BA%9B%3F-toc" style="margin-left:0px;"><a href="#%E5%AE%9E%E7%8E%B0%20spark%20%E7%BC%96%E7%A8%8B%E7%9A%84%E8%AF%AD%E8%A8%80%E6%9C%89%E5%93%AA%E4%BA%9B%3F" rel="nofollow">实现 spark 编程的语言有哪些?</a></p> 
<p id="%E5%AE%98%E6%96%B9%E8%A7%A3%E9%87%8A-toc" style="margin-left:40px;"><a href="#%E5%AE%98%E6%96%B9%E8%A7%A3%E9%87%8A" rel="nofollow">官方解释</a></p> 
<p id="%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93" rel="nofollow">个人总结</a></p> 
<p id="%E6%88%91%E4%BB%AC%E4%B8%8A%E8%AF%BE%E8%AE%B2%E7%9A%84%E6%98%AF%E5%93%AA%E7%A7%8D%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%3F-toc" style="margin-left:0px;"><a href="#%E6%88%91%E4%BB%AC%E4%B8%8A%E8%AF%BE%E8%AE%B2%E7%9A%84%E6%98%AF%E5%93%AA%E7%A7%8D%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%3F" rel="nofollow">我们上课讲的是哪种编程语言?</a></p> 
<p id="%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93" rel="nofollow">个人总结</a></p> 
<p id="Hive%20%E7%9A%84%E6%89%A7%E8%A1%8C%E9%9C%80%E8%A6%81%E8%AE%A1%E7%AE%97%E5%BC%95%E6%93%8E%E5%90%97%3F-toc" style="margin-left:0px;"><a href="#Hive%20%E7%9A%84%E6%89%A7%E8%A1%8C%E9%9C%80%E8%A6%81%E8%AE%A1%E7%AE%97%E5%BC%95%E6%93%8E%E5%90%97%3F" rel="nofollow">Hive 的执行需要计算引擎吗?</a></p> 
<p id="%E5%AE%98%E6%96%B9%E8%A7%A3%E9%87%8A-toc" style="margin-left:40px;"><a href="#%E5%AE%98%E6%96%B9%E8%A7%A3%E9%87%8A" rel="nofollow">官方解释</a></p> 
<p id="%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93" rel="nofollow">个人总结</a></p> 
<p id="%E4%BD%A0%E7%9F%A5%E9%81%93%E6%9C%89%E5%93%AA%E4%BA%9B%E8%AE%A1%E7%AE%97%E5%BC%95%E6%93%8E%3F-toc" style="margin-left:0px;"><a href="#%E4%BD%A0%E7%9F%A5%E9%81%93%E6%9C%89%E5%93%AA%E4%BA%9B%E8%AE%A1%E7%AE%97%E5%BC%95%E6%93%8E%3F" rel="nofollow">你知道有哪些计算引擎?</a></p> 
<p id="%E5%AE%98%E6%96%B9%E8%A7%A3%E9%87%8A-toc" style="margin-left:40px;"><a href="#%E5%AE%98%E6%96%B9%E8%A7%A3%E9%87%8A" rel="nofollow">官方解释</a></p> 
<p id="%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93" rel="nofollow">个人总结</a></p> 
<p id="Spark%20RDD%E7%9A%84%E4%B8%80%E4%BA%9B%E8%80%83%E6%9F%A5-toc" style="margin-left:0px;"><a href="#Spark%20RDD%E7%9A%84%E4%B8%80%E4%BA%9B%E8%80%83%E6%9F%A5" rel="nofollow">Spark RDD的一些考查</a></p> 
<p id="%E4%B8%AA%E4%BA%BA%E5%88%86%E6%9E%90%E8%80%83%E5%AF%9F%E7%82%B9-toc" style="margin-left:40px;"><a href="#%E4%B8%AA%E4%BA%BA%E5%88%86%E6%9E%90%E8%80%83%E5%AF%9F%E7%82%B9" rel="nofollow">个人分析考察点</a></p> 
<p id="%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-toc" style="margin-left:40px;"><a href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86" rel="nofollow">第二部分</a></p> 
<p id="%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87-toc" style="margin-left:0px;"><a href="#%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87" rel="nofollow">实验环境准备</a></p> 
<p id="%E5%AE%98%E6%96%B9-toc" style="margin-left:40px;"><a href="#%E5%AE%98%E6%96%B9" rel="nofollow">官方</a></p> 
<p id="%E4%B8%AA%E4%BA%BA%E5%88%86%E6%9E%90%E8%80%83%E7%82%B9-toc" style="margin-left:40px;"><a href="#%E4%B8%AA%E4%BA%BA%E5%88%86%E6%9E%90%E8%80%83%E7%82%B9" rel="nofollow">个人分析考点</a></p> 
<p id="%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8A%E4%BC%A0%E5%88%B0%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93Hive-toc" style="margin-left:0px;"><a href="#%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8A%E4%BC%A0%E5%88%B0%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93Hive" rel="nofollow">本地数据集上传到数据仓库Hive</a></p> 
<p id="%E5%AE%98%E6%96%B9-toc" style="margin-left:40px;"><a href="#%E5%AE%98%E6%96%B9" rel="nofollow">官方</a></p> 
<p id="%E4%B8%AA%E4%BA%BA%E5%88%86%E6%9E%90%E8%80%83%E5%AF%9F%E7%82%B9-toc" style="margin-left:40px;"><a href="#%E4%B8%AA%E4%BA%BA%E5%88%86%E6%9E%90%E8%80%83%E5%AF%9F%E7%82%B9" rel="nofollow">个人分析考察点</a></p> 
<p id="%E6%B5%81%E7%A8%8B-toc" style="margin-left:80px;"><a href="#%E6%B5%81%E7%A8%8B" rel="nofollow">流程</a></p> 
<p id="Hive%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-toc" style="margin-left:0px;"><a href="#Hive%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90" rel="nofollow">Hive数据分析</a></p> 
<p id="%E5%AE%98%E6%96%B9-toc" style="margin-left:40px;"><a href="#%E5%AE%98%E6%96%B9" rel="nofollow">官方</a></p> 
<p id="%E4%B8%AA%E4%BA%BA%E5%88%86%E6%9E%90%E8%80%83%E7%82%B9-toc" style="margin-left:40px;"><a href="#%E4%B8%AA%E4%BA%BA%E5%88%86%E6%9E%90%E8%80%83%E7%82%B9" rel="nofollow">个人分析考点</a></p> 
<p id="%E6%B5%81%E7%A8%8B-toc" style="margin-left:80px;"><a href="#%E6%B5%81%E7%A8%8B" rel="nofollow">流程</a></p> 
<p id="%E5%B0%86%E6%95%B0%E6%8D%AE%E4%BB%8EHive%E5%AF%BC%E5%85%A5%E5%88%B0MySQL-toc" style="margin-left:0px;"><a href="#%E5%B0%86%E6%95%B0%E6%8D%AE%E4%BB%8EHive%E5%AF%BC%E5%85%A5%E5%88%B0MySQL" rel="nofollow">将数据从Hive导入到MySQL</a></p> 
<p id="%E5%AE%98%E6%96%B9-toc" style="margin-left:40px;"><a href="#%E5%AE%98%E6%96%B9" rel="nofollow">官方</a></p> 
<p id="%E4%B8%AA%E4%BA%BA%E5%88%86%E6%9E%90%E8%80%83%E7%82%B9-toc" style="margin-left:40px;"><a href="#%E4%B8%AA%E4%BA%BA%E5%88%86%E6%9E%90%E8%80%83%E7%82%B9" rel="nofollow">个人分析考点</a></p> 
<p id="%E6%B5%81%E7%A8%8B-toc" style="margin-left:80px;"><a href="#%E6%B5%81%E7%A8%8B" rel="nofollow">流程</a></p> 
<p id="%E5%88%A9%E7%94%A8Spark%E9%A2%84%E6%B5%8B%E5%9B%9E%E5%A4%B4%E5%AE%A2-toc" style="margin-left:0px;"><a href="#%E5%88%A9%E7%94%A8Spark%E9%A2%84%E6%B5%8B%E5%9B%9E%E5%A4%B4%E5%AE%A2" rel="nofollow">利用Spark预测回头客</a></p> 
<p id="%E5%AE%98%E6%96%B9-toc" style="margin-left:40px;"><a href="#%E5%AE%98%E6%96%B9" rel="nofollow">官方</a></p> 
<p id="1.%20%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E4%B8%8E%E9%A2%84%E5%A4%84%E7%90%86-toc" style="margin-left:80px;"><a href="#1.%20%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E4%B8%8E%E9%A2%84%E5%A4%84%E7%90%86" rel="nofollow">1. 数据收集与预处理</a></p> 
<p id="2.%20%E5%88%92%E5%88%86%E6%95%B0%E6%8D%AE%E9%9B%86-toc" style="margin-left:80px;"><a href="#2.%20%E5%88%92%E5%88%86%E6%95%B0%E6%8D%AE%E9%9B%86" rel="nofollow">2. 划分数据集</a></p> 
<p id="3.%20%E9%80%89%E6%8B%A9%E6%A8%A1%E5%9E%8B-toc" style="margin-left:80px;"><a href="#3.%20%E9%80%89%E6%8B%A9%E6%A8%A1%E5%9E%8B" rel="nofollow">3. 选择模型</a></p> 
<p id="4.%20%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B-toc" style="margin-left:80px;"><a href="#4.%20%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B" rel="nofollow">4. 训练模型</a></p> 
<p id="5.%20%E8%AF%84%E4%BC%B0%E6%A8%A1%E5%9E%8B-toc" style="margin-left:80px;"><a href="#5.%20%E8%AF%84%E4%BC%B0%E6%A8%A1%E5%9E%8B" rel="nofollow">5. 评估模型</a></p> 
<p id="6.%20%E8%B0%83%E4%BC%98-toc" style="margin-left:80px;"><a href="#6.%20%E8%B0%83%E4%BC%98" rel="nofollow">6. 调优</a></p> 
<p id="7.%20%E9%A2%84%E6%B5%8B%E4%B8%8E%E9%83%A8%E7%BD%B2-toc" style="margin-left:80px;"><a href="#7.%20%E9%A2%84%E6%B5%8B%E4%B8%8E%E9%83%A8%E7%BD%B2" rel="nofollow">7. 预测与部署</a></p> 
<p id="8.%20%E5%8F%8D%E9%A6%88%E5%BE%AA%E7%8E%AF-toc" style="margin-left:80px;"><a href="#8.%20%E5%8F%8D%E9%A6%88%E5%BE%AA%E7%8E%AF" rel="nofollow">8. 反馈循环</a></p> 
<p id="%E4%B8%AA%E4%BA%BA%E5%88%86%E6%9E%90%E8%80%83%E7%82%B9-toc" style="margin-left:40px;"><a href="#%E4%B8%AA%E4%BA%BA%E5%88%86%E6%9E%90%E8%80%83%E7%82%B9" rel="nofollow">个人分析考点</a></p> 
<p id="%E5%88%A9%E7%94%A8ECharts%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90-toc" style="margin-left:0px;"><a href="#%E5%88%A9%E7%94%A8ECharts%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90" rel="nofollow">利用ECharts进行数据可视化分析</a></p> 
<p id="%E5%AE%98%E6%96%B9-toc" style="margin-left:40px;"><a href="#%E5%AE%98%E6%96%B9" rel="nofollow">官方</a></p> 
<p id="1.%20%E5%87%86%E5%A4%87%E6%95%B0%E6%8D%AE-toc" style="margin-left:80px;"><a href="#1.%20%E5%87%86%E5%A4%87%E6%95%B0%E6%8D%AE" rel="nofollow">1. 准备数据</a></p> 
<p id="2.%20%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AEECharts-toc" style="margin-left:80px;"><a href="#2.%20%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AEECharts" rel="nofollow">2. 安装与配置ECharts</a></p> 
<p id="3.%20%E8%AE%BE%E8%AE%A1%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%B9%E6%A1%88-toc" style="margin-left:80px;"><a href="#3.%20%E8%AE%BE%E8%AE%A1%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%B9%E6%A1%88" rel="nofollow">3. 设计可视化方案</a></p> 
<p id="4.%20%E7%BC%96%E5%86%99ECharts%E9%85%8D%E7%BD%AE%E9%A1%B9-toc" style="margin-left:80px;"><a href="#4.%20%E7%BC%96%E5%86%99ECharts%E9%85%8D%E7%BD%AE%E9%A1%B9" rel="nofollow">4. 编写ECharts配置项</a></p> 
<p id="5.%20%E4%BA%A4%E4%BA%92%E4%B8%8E%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE-toc" style="margin-left:80px;"><a href="#5.%20%E4%BA%A4%E4%BA%92%E4%B8%8E%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE" rel="nofollow">5. 交互与动态数据</a></p> 
<p id="6.%20%E7%BE%8E%E5%8C%96%E4%B8%8E%E4%BC%98%E5%8C%96-toc" style="margin-left:80px;"><a href="#6.%20%E7%BE%8E%E5%8C%96%E4%B8%8E%E4%BC%98%E5%8C%96" rel="nofollow">6. 美化与优化</a></p> 
<p id="7.%20%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%8F%91%E5%B8%83-toc" style="margin-left:80px;"><a href="#7.%20%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%8F%91%E5%B8%83" rel="nofollow">7. 测试与发布</a></p> 
<p id="%E4%B8%AA%E4%BA%BA%E5%88%86%E6%9E%90%E8%80%83%E7%82%B9-toc" style="margin-left:40px;"><a href="#%E4%B8%AA%E4%BA%BA%E5%88%86%E6%9E%90%E8%80%83%E7%82%B9" rel="nofollow">个人分析考点</a></p> 
<p id="%E9%92%88%E5%AF%B9%20user_log%E8%A1%A8-toc" style="margin-left:0px;"><a href="#%E9%92%88%E5%AF%B9%20user_log%E8%A1%A8" rel="nofollow">针对 user_log表</a></p> 
<p id="%E4%B8%AA%E4%BA%BA%E5%88%86%E6%9E%90%E6%96%B9%E5%90%91%E7%82%B9-toc" style="margin-left:40px;"><a href="#%E4%B8%AA%E4%BA%BA%E5%88%86%E6%9E%90%E6%96%B9%E5%90%91%E7%82%B9" rel="nofollow">个人分析方向点</a></p> 
<p id="%E8%A1%A8%E5%8D%95-toc" style="margin-left:40px;"><a href="#%E8%A1%A8%E5%8D%95" rel="nofollow">表单</a></p> 
<p id="%E4%BC%9A%E8%AE%A9%E4%BD%A0%E5%86%99%E5%87%A0%E4%B8%AA%20HiveOL%E8%AF%AD%E5%8F%A5-toc" style="margin-left:0px;"><a href="#%E4%BC%9A%E8%AE%A9%E4%BD%A0%E5%86%99%E5%87%A0%E4%B8%AA%20HiveOL%E8%AF%AD%E5%8F%A5" rel="nofollow">会让你写几个 HiveOL语句</a></p> 
<p id="%E6%88%91%E8%BF%99%E9%87%8C%E5%B0%86%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5%E7%BD%97%E5%88%97%E5%87%BA%E6%9D%A5-toc" style="margin-left:40px;"><a href="#%E6%88%91%E8%BF%99%E9%87%8C%E5%B0%86%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5%E7%BD%97%E5%88%97%E5%87%BA%E6%9D%A5" rel="nofollow">我这里将基本语句罗列出来</a></p> 
<p id="1.%20%E5%88%9B%E5%BB%BA%E8%A1%A8-toc" style="margin-left:80px;"><a href="#1.%20%E5%88%9B%E5%BB%BA%E8%A1%A8" rel="nofollow">1. 创建表</a></p> 
<p id="2.%20%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE-toc" style="margin-left:80px;"><a href="#2.%20%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE" rel="nofollow">2. 加载数据</a></p> 
<p id="3.%20%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE-toc" style="margin-left:80px;"><a href="#3.%20%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE" rel="nofollow">3. 查询数据</a></p> 
<p id="4.%20%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#4.%20%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0" rel="nofollow">4. 聚合函数</a></p> 
<p id="5.%20%E5%88%86%E5%8C%BA%E8%A1%A8-toc" style="margin-left:80px;"><a href="#5.%20%E5%88%86%E5%8C%BA%E8%A1%A8" rel="nofollow">5. 分区表</a></p> 
<p id="6.%20%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C-toc" style="margin-left:80px;"><a href="#6.%20%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C" rel="nofollow">6. 删除操作</a></p> 
<p id="7.%20%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE-toc" style="margin-left:80px;"><a href="#7.%20%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE" rel="nofollow">7. 插入数据</a></p> 
<p id="8.%20%E8%A7%86%E5%9B%BE-toc" style="margin-left:80px;"><a href="#8.%20%E8%A7%86%E5%9B%BE" rel="nofollow">8. 视图</a></p> 
<p id="%E4%BC%9A%E8%AE%A9%E6%89%93%E5%BC%80%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E8%AE%A9%E4%BD%A0%E8%AE%B2%E8%A7%A3%E4%B8%80%E4%B8%8B%E4%BB%A3%E7%A0%81%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%2C%E5%B0%B1%E9%82%A3%E5%87%A0%E4%B8%AA%20index%20%E9%A1%B5%E9%9D%A2%EF%BC%8C%E8%BF%98%E6%9C%89%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%20dbtaobao%20%E7%9A%84%20java%E4%BB%A3%E7%A0%81%E3%80%82-toc" style="margin-left:0px;"><a href="#%E4%BC%9A%E8%AE%A9%E6%89%93%E5%BC%80%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E8%AE%A9%E4%BD%A0%E8%AE%B2%E8%A7%A3%E4%B8%80%E4%B8%8B%E4%BB%A3%E7%A0%81%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%2C%E5%B0%B1%E9%82%A3%E5%87%A0%E4%B8%AA%20index%20%E9%A1%B5%E9%9D%A2%EF%BC%8C%E8%BF%98%E6%9C%89%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%20dbtaobao%20%E7%9A%84%20java%E4%BB%A3%E7%A0%81%E3%80%82" rel="nofollow">会让打开一段代码让你讲解一下代码什么意思,就那几个 index 页面，还有连接数据库操作 dbtaobao 的 java代码。</a></p> 
<p id="%E5%89%8D%E7%AB%AF-toc" style="margin-left:40px;"><a href="#%E5%89%8D%E7%AB%AF" rel="nofollow">前端</a></p> 
<p id="%E5%90%8E%E7%AB%AF-toc" style="margin-left:40px;"><a href="#%E5%90%8E%E7%AB%AF" rel="nofollow">后端</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86">第一部分</h2> 
<h2 id="Hadoop%E6%98%AF%E4%BB%80%E4%B9%88">Hadoop是什么</h2> 
<h3 id="%E5%AE%98%E6%96%B9%E8%A7%A3%E9%87%8A%EF%BC%9A">官方解释：</h3> 
<p>Hadoop 是一个开源的分布式计算框架，设计用于在大规模数据集上实现高效、可靠和可扩展的数据处理。它由 Apache 软件基金会开发并维护。Hadoop 的核心组件包括：</p> 
<ol><li> <p><strong>Hadoop Distributed File System (HDFS)</strong>：这是一个高容错性的分布式文件系统，能够将大型数据集分割成块，并存储在低成本的硬件上。HDFS 设计用于运行在普通硬件集群上，提供高吞吐量的数据访问能力，非常适合大规模数据处理场景。</p> </li><li> <p><strong>MapReduce</strong>：这是一种编程模型，用于处理和生成大数据集。MapReduce 将复杂的计算任务分解为两个主要阶段：Map（映射）和 Reduce（归纳）。在 Map 阶段，输入数据被拆分成小块，并应用一个映射函数；在 Reduce 阶段，这些经过映射的中间结果被汇总和归纳，从而得出最终结果。这种架构支持并行处理，能够在大量计算机节点上高效地分布计算任务。</p> </li><li> <p><strong>YARN (Yet Another Resource Negotiator)</strong>：这是 Hadoop 2.x 版本引入的一个资源管理器，负责管理和调度集群中的资源。YARN 允许在同一个集群上运行多种类型的应用程序，而不仅仅是 MapReduce，提高了集群的利用率和灵活性。</p> </li></ol> 
<h3 id="%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93">个人总结</h3> 
<p>Hadoop 是一个开源的分布式计算框架，设计用于在大规模数据集上实现高效、可靠和可扩展的数据处理。</p> 
<p></p> 
<h2 id="HDFS%20%E6%98%AF%E4%BB%80%E4%B9%88%3F">HDFS 是什么?</h2> 
<h3>官方解释：</h3> 
<p>HDFS，全称 Hadoop Distributed File System，是 Hadoop 项目的一个核心组件，它是一个针对大数据处理而设计的分布式文件系统。HDFS 专为运行在商用硬件（commodity hardware）上的大型数据集而构建，旨在提供高吞吐量的数据访问，特别适合那些一次写入、多次读取（write-once-read-many）的工作负载，并且可以处理 PB 级别的数据。</p> 
<p>HDFS 的关键特性包括：</p> 
<ol><li> <p><strong>数据分块与复制</strong>：HDFS 将大文件分割成固定大小的块（默认是 128MB 或者 256MB），并将这些块复制到多个节点上，通常默认复制三次，以实现高容错性。即使个别节点发生故障，数据依然可以从其他节点上的副本读取，确保了数据的可用性。</p> </li><li> <p><strong>主/从架构</strong>：HDFS 包括两个主要类型的节点——NameNode（名称节点）和 DataNode（数据节点）。NameNode 负责管理文件系统的命名空间（namespace）以及控制客户端对文件的访问，而 DataNodes 存储实际的数据块，并执行 NameNode 下达的指令，例如数据块的读写操作。</p> </li><li> <p><strong>容错与恢复</strong>：HDFS 设计时考虑到了硬件故障的常态，能够自动检测到节点故障，并迅速在其他节点上复制丢失的副本，以恢复数据的完整性和可用性。</p> </li><li> <p><strong>流式数据访问</strong>：HDFS 优化了大规模连续数据读取，即“流式”数据访问模式，非常适合批量处理和分析任务，如使用 MapReduce 进行的数据分析。</p> </li><li> <p><strong>可扩展性</strong>：HDFS 架构支持水平扩展，可以通过添加更多的节点来线性地增加存储容量和计算能力，从而轻松应对数据增长的需求。</p> </li></ol> 
<p>尽管 HDFS 在处理大规模数据集方面表现出色，但它并不适合低延迟访问、小文件存储或者频繁文件修改的场景。因此，在实际应用中，HDFS 经常与其他技术（如 Apache HBase 用于实时查询、Apache Hive 用于数据仓库处理）结合使用，以满足不同种类的大数据处理需求。</p> 
<h3>个人总结</h3> 
<p>HDFS是 Hadoop 项目的一个核心组件，它是一个针对大数据处理而设计的分布式文件系统。</p> 
<p></p> 
<h2 id="yarn%E6%98%AF%E4%BB%80%E4%B9%88%3F">yarn是什么?</h2> 
<h3>官方解释：</h3> 
<p>YARN (Yet Another Resource Negotiator) 是 Apache Hadoop 生态系统中的一个组件，它是从 Hadoop 2.x 版本开始引入的资源管理系统。YARN 被设计为一个通用的、可伸缩的资源管理平台，它允许在同一个集群上运行多种不同类型的应用程序，不仅仅限于传统的 MapReduce。YARN 分离了资源管理和作业调度/监控功能，使得 Hadoop 集群可以更有效地运行各种数据处理框架，比如 Apache Spark、Apache Storm、Apache Flink 等。YARN 的核心组件包括 ResourceManager、NodeManager、ApplicationMaster 等。</p> 
<h3>个人总结</h3> 
<p>YARN 是一个通用的、可伸缩的资源管理平台，它允许在同一个集群上运行多种不同类型的应用程序。</p> 
<p></p> 
<h2 id="mapreduce%EF%BC%8Cspark%20%E6%98%AF%E4%BB%80%E4%B9%88%3F">mapreduce，spark 是什么?</h2> 
<h3>官方解释：</h3> 
<p>MapReduce 和 Spark 是两种广泛应用于大数据处理的技术框架，它们都旨在帮助处理和分析大规模数据集，但采用了不同的设计理念和执行模型。</p> 
<h4 id="MapReduce">MapReduce</h4> 
<p>MapReduce 是由 Google 开发并在 2004 年提出的一种编程模型，用于大规模数据集的并行处理。它后来成为了 Apache Hadoop 项目的核心组件之一。MapReduce 的工作流程分为两个主要阶段：Map（映射）和 Reduce（归约）。</p> 
<ul><li> <p><strong>Map阶段</strong>：将输入数据集切分成多个小块（splits），并为每个小块执行一个映射函数，将数据转换成一系列的键值对。</p> </li><li> <p><strong>Reduce阶段</strong>：将所有具有相同键的键值对聚集在一起，然后对每个键对应的值执行一个归约函数，以生成最终的输出。</p> </li></ul> 
<p>MapReduce 以批处理的方式工作，适合处理离线分析任务，但不适合实时或交互式查询。它的中间结果需要写入磁盘，这限制了处理速度，并且对于需要迭代处理的任务（如机器学习算法）效率不高。</p> 
<h4 id="Spark">Spark</h4> 
<p>Apache Spark 是一个开源的分布式计算框架，由加州大学伯克利分校的 AMPLab 开发，后来捐赠给 Apache 软件基金会。Spark 相较于 MapReduce 提供了更高级的数据处理能力，特别是在数据处理速度和灵活性方面。</p> 
<ul><li> <p><strong>内存计算</strong>：Spark 的核心特点是基于内存的计算，它可以将数据加载到内存中，从而加速迭代计算和交互式数据挖掘任务。当数据无法全部放入内存时，Spark 也能智能地使用磁盘存储。</p> </li><li> <p><strong>更丰富的计算模型</strong>：除了 Map 和 Reduce 操作，Spark 还提供了诸如 filter、join、groupBy 等丰富的转换（Transformation）和动作（Action）操作，支持流处理（Spark Streaming）、图计算（GraphX）、机器学习（MLlib）和 SQL 查询（Spark SQL）等多种计算任务。</p> </li><li> <p><strong>DAG 执行引擎</strong>：Spark 使用 Directed Acyclic Graph (DAG) 来表示计算任务之间的依赖关系，优化任务调度，减少磁盘 I/O，提高整体计算效率。</p> </li><li> <p><strong>易用性</strong>：Spark 提供了 Scala、Java、Python 和 R 等多种语言的 API，使得开发者更容易上手和编写复杂的数据处理程序。</p> </li></ul> 
<p>总的来说，MapReduce 更适合于处理大规模的批处理任务，尤其是那些对实时性要求不高的场景，而 Spark 则因为其高性能和灵活性，适用于更广泛的计算需求，包括实时处理、交互式查询和机器学习等。</p> 
<h3>个人总结</h3> 
<p>都是帮助处理和分析大规模数据集</p> 
<h4>MapReduce</h4> 
<p>主要用于大规模数据集的并行处理</p> 
<h4>Spark</h4> 
<p>提供了更高级的数据处理能力，特别是在数据处理速度和灵活性方面</p> 
<p></p> 
<h2 id="spark%20%E7%94%9F%E6%80%81%E5%9C%88%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E5%AE%B9%3F">spark 生态圈有哪些内容?</h2> 
<h3 id="%E5%AE%98%E6%96%B9%E8%A7%A3%E9%87%8A">官方解释</h3> 
<p>Apache Spark 生态圈是一个围绕 Spark 核心计算引擎构建的全面的数据处理和分析工具集合。以下是 Spark 生态圈中包含的主要组件：</p> 
<ol><li> <p><strong>Spark Core</strong>：这是 Spark 生态圈的基础，提供了分布式任务调度、内存计算、故障恢复等基本功能。Spark Core 支持创建弹性分布式数据集（RDDs），这是分布式数据处理的基本单位。</p> </li><li> <p><strong>Spark SQL</strong>：它允许用户使用 SQL 或 DataFrame API 处理结构化和半结构化数据。Spark SQL 可以查询多种数据源，并且能够将 SQL 查询转换为在 Spark 上运行的高效执行计划。</p> </li><li> <p><strong>Spark Streaming</strong>：这是一个对实时数据流进行处理的组件，支持从多种来源（如 Kafka、Flume）消费数据，并能以接近实时的方式处理这些数据流，适用于实时数据分析和监控应用。</p> </li><li> <p><strong>MLlib (Machine Learning Library)</strong>：这是一个机器学习库，提供了分类、回归、聚类、协同过滤等常见的机器学习算法，支持模型训练和预测，以及一些实用的工具和算法，便于在分布式环境中进行大规模数据的机器学习。</p> </li><li> <p><strong>GraphX</strong>：这是一个用于图和图形计算的库，提供了图数据结构 API 和一系列图算法操作，如 PageRank、三角计数等，适合进行社交网络分析、推荐系统等图处理任务。</p> </li><li> <p><strong>Structured Streaming</strong>：这是一个构建在 Spark SQL 之上的流处理引擎，它将流式计算表达为持续查询的形式，支持实时数据分析，并保证一次仅处理一次语义，适用于构建低延迟的实时应用。</p> </li><li> <p><strong>SparkR</strong>：为 R 语言用户提供接口，使他们能够利用 Spark 的分布式处理能力进行数据分析。</p> </li><li> <p><strong>PySpark</strong>：为 Python 用户提供的接口，允许 Python 开发者使用 Spark 功能进行大数据处理和分析。</p> </li></ol> 
<p>此外，Spark 生态圈还包括与其他数据存储和处理系统的集成，如 Hadoop HDFS、Apache Cassandra、Amazon S3 等数据源的支持，以及与资源管理器（如 Hadoop YARN、Apache Mesos、Kubernetes）的集成，以便于管理和调度资源。</p> 
<p>这些组件相互配合，形成了一个强大的数据处理平台，能够满足从数据摄取、处理、分析到机器学习和图形处理的全方位需求。</p> 
<h3>个人总结</h3> 
<p>Spark Core主要提供分布式任务调度、内存计算、故障恢复等基本功能，Spark SQL主要用于处理结构化和半结构化数据，Spark Streaming主要实时对数据流进行处理。</p> 
<p>（个别重点提出来经行解释）</p> 
<p></p> 
<h2 id="hbase%20%E6%98%AF%E4%BB%80%E4%B9%88%3F">hbase 是什么?</h2> 
<h3>官方解释</h3> 
<p>HBase 是一个开源的、分布式、版本化的、面向列的 NoSQL 数据库，它运行在 Hadoop 文件系统（HDFS）之上，是 Google Bigtable 的开源实现。HBase 的设计目标是为了处理非常庞大的表，能够存储数十亿行数据和数百万列，特别适合于非结构化和半结构化数据的存储。</p> 
<p>HBase 的主要特点包括：</p> 
<ol><li> <p><strong>高可靠性</strong>：通过在 HDFS 上存储数据，并利用 ZooKeeper 进行协调服务和故障恢复，HBase 提供了高可用性保障。</p> </li><li> <p><strong>高性能</strong>：HBase 支持快速随机读写访问，特别是对于大规模数据集，通过列式存储和内存缓存技术提高读写速度。</p> </li><li> <p><strong>面向列</strong>：与传统的行式存储不同，HBase 数据模型允许灵活地对列进行存储和访问，用户可以根据需求动态增加列，且每一列可以有多个版本。</p> </li><li> <p><strong>可伸缩性</strong>：HBase 可以通过增加更多的服务器到集群中来水平扩展，以处理不断增长的数据量和访问需求。</p> </li><li> <p><strong>分布式架构</strong>：数据自动分散在集群的多个节点上，实现了数据的分布式存储和并行处理。</p> </li><li> <p><strong>弱一致性模型</strong>：HBase 支持最终一致性，适合于那些对实时性要求不高，但需要处理大量数据的场景。</p> </li><li> <p><strong>稀疏存储</strong>：HBase 只存储非空值，对于稀疏数据集非常高效。</p> </li><li> <p><strong>原生支持 MapReduce</strong>：可以利用 Hadoop 的 MapReduce 对 HBase 内的数据进行批处理分析。</p> </li></ol> 
<p>HBase 通常用于需要快速读写访问的大数据应用场景，如日志处理、文档索引、实时分析、Web 访问统计等。尽管 HBase 不支持复杂的 SQL 查询，但提供了基于行键、列族和时间戳的简单数据访问接口，并可以通过 Apache Phoenix 或者 Hive 等项目实现 SQL 类似的查询能力。</p> 
<h3>个人总结</h3> 
<p>hdbase是一个面向列的 NoSQL 数据库</p> 
<p></p> 
<h2 id="hive%20%E6%98%AF%E4%BB%80%E4%B9%88%3F">hive 是什么?</h2> 
<h3>官方解释</h3> 
<p>Hive 是一个建立在 Hadoop 之上的数据仓库工具，它为大规模数据集提供了数据提取、转换、加载（ETL）以及存储、查询和分析的能力。Hive 的核心目的是让熟悉 SQL 的用户和数据分析师能够利用他们的技能来处理和查询存储在 Hadoop 分布式文件系统（HDFS）中的大规模数据，而无需直接编写复杂的 MapReduce 程序。</p> 
<p>以下是 Hive 的几个关键特征和用途：</p> 
<ol><li> <p><strong>类 SQL 查询语言（HiveQL）</strong>：Hive 提供了一个类似于 SQL 的查询语言 HiveQL，使得用户可以方便地定义表、加载数据、执行查询等操作，而不需要了解底层 MapReduce 细节。</p> </li><li> <p><strong>数据仓库工具</strong>：Hive 能够将结构化的数据文件映射为表，让用户可以通过简单的查询语言与这些数据进行交互，就像操作传统的关系型数据库一样。</p> </li><li> <p><strong>基于 Hadoop 的扩展性</strong>：由于 Hive 建立在 Hadoop 之上，它可以利用 Hadoop 集群的分布式存储和计算能力，轻松扩展以处理 PB 级别的数据。</p> </li><li> <p><strong>适合离线分析</strong>：虽然 Hive 提供了方便的数据查询手段，但由于其执行延迟较高，它更适合用于批处理和离线数据分析，而不是实时数据处理。</p> </li><li> <p><strong>用户自定义函数（UDF）</strong>：Hive 支持用户自定义函数，允许根据特定需求扩展其功能，以处理复杂的数据转换和分析任务。</p> </li><li> <p><strong>元数据管理</strong>：Hive 提供了一个统一的元数据存储，可以与 Hadoop 生态系统中的其他组件（如 Presto、Impala、Spark SQL）共享数据，促进了数据湖的互操作性。</p> </li></ol> 
<p>综上所述，Hive 是一个简化了大数据处理和分析过程的工具，它降低了大数据技术的使用门槛，使得非程序员的数据分析师也能高效地在大规模数据集上进行查询和分析。</p> 
<h3>个人总结</h3> 
<p>hive 是一个数据仓库工具，主要提供数据提取、转换、加载（ETL）以及存储、查询和分析的能力。</p> 
<p></p> 
<h2 id="eChart%20%E6%98%AF%E4%BB%80%E4%B9%88%3F">eChart 是什么?</h2> 
<h3>官方解释</h3> 
<p>ECharts 是一个使用 JavaScript 实现的开源可视化库，由 Apache 软件基金会所管理。它设计用于在网页上呈现丰富的数据可视化图表，支持流畅地运行在个人电脑和移动设备上，并兼容当前绝大多数的主流浏览器，包括 IE9/10/11、Chrome、Firefox、Safari 等。ECharts 底层依赖于矢量图形库 ZRender，这使得它能够提供高质量的图形渲染效果。</p> 
<p>ECharts 提供了一系列直观且交互性强的数据可视化图表类型，包括但不限于：</p> 
<ul><li> <p>折线图</p> </li><li> <p>柱状图</p> </li><li> <p>散点图</p> </li><li> <p>饼图</p> </li><li> <p>K线图（常用于金融数据）</p> </li><li> <p>盒须图（用于统计分析）</p> </li><li> <p>地图（支持地理数据可视化）</p> </li><li> <p>热力图</p> </li><li> <p>线图</p> </li><li> <p>关系图（用于展现数据间的关系）</p> </li><li> <p>Treemap（树状图）</p> </li><li> <p>旭日图（层次结构可视化）</p> </li><li> <p>平行坐标（多维数据展示）</p> </li><li> <p>漏斗图</p> </li><li> <p>仪表盘</p> </li><li> <p>以及更多其他图表类型</p> </li></ul> 
<p>ECharts 的强大之处在于其高度的可定制性和可扩展性。用户不仅可以通过简单的配置生成图表，还可以深入定制图表的每一个细节，甚至可以创建自定义系列来满足特殊的可视化需求。此外，ECharts 支持多种数据格式输入，包括二维表、键值对数据等，使得数据的接入变得灵活简便。</p> 
<p>由于其丰富的功能和良好的性能，ECharts 广泛应用于各种 Web 应用场景，如业务报表、BI（商业智能）、监控系统、数据产品展示等。同时，ECharts 提供了详尽的文档和示例，以及在线构建工具，便于开发者快速上手和使用。</p> 
<h3>个人总结</h3> 
<p>echart是一个可视化图表库</p> 
<p></p> 
<h2 id="%E6%88%91%E4%BB%AC%E6%8E%A5%E8%A7%A6%E4%BA%86%E5%93%AA%E4%BA%9B%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E6%A1%86%E6%9E%B6%3F">我们接触了哪些分布式计算框架?</h2> 
<h3>官方解释</h3> 
<p>我们接触到了多种分布式计算框架，这些框架旨在提高计算效率、处理大规模数据集和实现复杂任务的并行处理。以下是一些提及的分布式计算框架：</p> 
<ol><li> <p><strong>Ray</strong>: 由伯克利大学开源的一个分布式计算框架，专为并行计算和分布式Python开发设计。Ray易于使用，能够帮助开发者从笔记本电脑轻松扩展到大型集群的应用程序。</p> </li><li> <p><strong>MapReduce</strong>: Google开发的一种编程模型，用于大规模数据集的并行处理。MapReduce通过将计算任务自动并行化处理和划分数据，适用于批处理大量数据。它分为两个主要阶段：Map阶段处理原始数据，而Reduce阶段则对Map输出的结果进行聚合。</p> </li><li> <p><strong>Hadoop</strong>: 基于Java的开源软件框架，主要用于分布式存储（HDFS）和分布式处理（MapReduce）。它是处理和管理大数据集的常用工具，广泛应用于大数据生态系统中。</p> </li><li> <p><strong>Spark</strong>: 也是一个开源的大数据处理框架，相较于MapReduce，Spark提供了内存计算能力，能更加快速地进行数据处理任务。Spark支持批量处理、交互查询（Spark SQL）、实时流处理（Spark Streaming）等多种计算范式。</p> </li><li> <p><strong>MPI (Message Passing Interface)</strong>: 这是一种标准的消息传递协议，允许并行计算机之间的数据交换和同步。它常用于科学计算和高性能计算领域，特别是在需要高度优化的通信和计算密集型任务中。</p> </li><li> <p><strong>Orleans</strong>: 由Microsoft Research开发的分布式计算框架，专为构建大规模分布式系统设计。它简化了构建高可扩展性和高容错性的云服务，特别是面向那些需要处理大量并发用户的场景。</p> </li></ol> 
<p>这些框架各有优势，适用于不同的应用场景，开发者可以根据具体需求选择最合适的框架来实现分布式计算解决方案。</p> 
<h3>个人总结</h3> 
<p>主要学习了hadoop</p> 
<p></p> 
<h2 id="%E5%AE%9E%E7%8E%B0%20spark%20%E7%BC%96%E7%A8%8B%E7%9A%84%E8%AF%AD%E8%A8%80%E6%9C%89%E5%93%AA%E4%BA%9B%3F">实现 spark 编程的语言有哪些?</h2> 
<h3>官方解释</h3> 
<p>Apache Spark 支持多种编程语言进行大数据处理和分析，主要语言包括：</p> 
<ol><li> <p><strong>Scala</strong>: Spark 是用 Scala 语言编写的，因此它与 Scala 的集成度最高，提供了最丰富的特性和最佳的性能。Scala 本身也是运行在 JVM 上的一种现代多范式编程语言，结合了面向对象和函数式编程的特点。</p> </li><li> <p><strong>Java</strong>: 由于 Spark 是基于 JVM 的，所以 Java 也是其支持的重要语言之一。用户可以使用 Java 编写 Spark 应用程序，虽然相比 Scala，可能在简洁性和表达力上略逊一筹，但 Java 的广泛使用和庞大的开发者社区使其成为一个非常实用的选择。</p> </li><li> <p><strong>Python</strong>: PySpark 是 Spark 的 Python 接口，是数据科学家和工程师中非常流行的选择，因为 Python 语言本身的易读性和丰富的数据科学库生态。虽然 Python 版本可能在某些场景下性能不如 Scala 或 Java，但它在快速原型开发和数据分析领域具有很高的生产力。</p> </li><li> <p><strong>R</strong>: SparkR 是为 R 语言用户提供的接口，允许 R 语言的开发者利用 Spark 进行分布式数据处理。这对于习惯使用 R 进行统计分析和数据挖掘的用户来说非常便利。</p> </li><li> <p><strong>SQL</strong>: 通过 Spark SQL，用户可以直接使用 SQL 查询语言处理结构化数据，而不必编写程序代码。Spark SQL 支持将 SQL 查询转换为 Spark 执行计划，从而在大数据集上执行查询。</p> </li></ol> 
<p>这些语言的选择取决于开发者或数据科学家的偏好、项目需求、团队技能组合以及特定任务的性能要求。Spark 的多语言支持确保了广泛的受众能够利用这一强大的计算框架。</p> 
<h3>个人总结</h3> 
<p>分别于java，python，SQL</p> 
<p>（其他不了解我们就不说，如果老师问具体一点，如：R语言如何实现spark的，我们就没法解释）</p> 
<p></p> 
<h2 id="%E6%88%91%E4%BB%AC%E4%B8%8A%E8%AF%BE%E8%AE%B2%E7%9A%84%E6%98%AF%E5%93%AA%E7%A7%8D%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%3F">我们上课讲的是哪种编程语言?</h2> 
<h3>个人总结</h3> 
<p>使用Java语言进行讲解</p> 
<p></p> 
<h2 id="Hive%20%E7%9A%84%E6%89%A7%E8%A1%8C%E9%9C%80%E8%A6%81%E8%AE%A1%E7%AE%97%E5%BC%95%E6%93%8E%E5%90%97%3F">Hive 的执行需要计算引擎吗?</h2> 
<h3>官方解释</h3> 
<p>是的，Hive 的执行确实需要一个计算引擎来处理查询和数据分析任务。虽然 Hive 本身不直接执行计算任务，但它设计为一个数据仓库工具，用于管理和查询存储在 Hadoop 分布式文件系统（HDFS）或其他存储系统中的数据。为了执行这些查询，Hive 需要借助外部计算引擎来完成实际的数据处理工作。</p> 
<p>历史上，Hive 最初是将查询转换为 MapReduce 作业来执行的，MapReduce 是 Hadoop 生态系统中的一个分布式计算框架，非常适合处理大规模数据集的批处理任务。然而，随着技术的发展，Hive 已经支持使用更高效的计算引擎，包括：</p> 
<ol><li> <p><strong>Tez</strong>：Tez 是一个支持DAG（有向无环图）执行模型的计算框架，相较于传统的 MapReduce，它提供了更低的延迟和更高的吞吐量，适用于 Hive 中的交互式查询。</p> </li><li> <p><strong>Spark</strong>：Hive 还可以通过 Hive on Spark（也称为 Shark 或 Hive LLAP）与 Apache Spark 集成，利用 Spark 的内存计算能力来加速查询处理，特别适合于迭代计算和交互式查询场景。</p> </li><li> <p><strong>Presto</strong>：Presto 是一个为交互式分析而设计的开源分布式SQL查询引擎，Hive 可以通过 Presto 作为执行引擎，以获得更快的查询响应时间。</p> </li><li> <p><strong>Hive Vectorized Engine</strong>：Hive 自身也在不断进化，引入了向量化执行引擎，该引擎优化了单条记录处理的方式，减少了Java对象的创建，从而提高了处理速度。</p> </li></ol> 
<p>综上所述，尽管 Hive 提供了一种类似 SQL 的查询接口（HiveQL），但为了执行这些查询，它依赖于一个强大的计算引擎来处理数据并返回结果。选择哪个计算引擎通常取决于性能需求、环境配置以及对实时性或批处理能力的偏好。</p> 
<h3>个人总结</h3> 
<p>需要</p> 
<p>为什么：Hive 的查询和数据分析任务，需要借助外部计算引擎来完成数据处理</p> 
<p></p> 
<p></p> 
<h2 id="%E4%BD%A0%E7%9F%A5%E9%81%93%E6%9C%89%E5%93%AA%E4%BA%9B%E8%AE%A1%E7%AE%97%E5%BC%95%E6%93%8E%3F">你知道有哪些计算引擎?</h2> 
<h3>官方解释</h3> 
<p>当然，有许多计算引擎用于处理和分析大规模数据集，它们各自具有不同的设计哲学和应用场景。以下是一些知名的计算引擎：</p> 
<ol><li> <p><strong>Apache Hadoop MapReduce</strong>：这是一种经典的分布式计算框架，适用于批处理大规模数据集。它基于“Map（映射）”和“Reduce（归约）”两个步骤处理数据。</p> </li><li> <p><strong>Apache Spark</strong>：Spark 是一种高性能的分布式计算引擎，支持批处理、交互式查询（Spark SQL）、实时流处理（Spark Streaming）、机器学习（MLlib）和图形处理（GraphX）。Spark 使用内存计算来加速数据处理。</p> </li><li> <p><strong>Apache Flink</strong>：Flink 是一个流处理和批处理统一的计算框架，擅长事件驱动的实时处理和状态计算。它支持低延迟和高吞吐量的数据流处理。</p> </li><li> <p><strong>Apache Tez</strong>：Tez 是一个支持有向无环图（DAG）的计算框架，设计用于提高Hadoop生态系统中数据密集型应用的执行速度，特别适合 Hive 查询的加速。</p> </li><li> <p><strong>Google Cloud Dataflow</strong>：Google 的分布式数据处理服务，支持批处理和流处理，提供了统一编程模型，可以在Google Cloud Platform上运行。</p> </li><li> <p><strong>Apache Beam</strong>：Beam 是一个统一的编程模型，用于定义数据处理管道，可以在多个执行引擎（包括Flink、Spark、Dataflow等）上运行。</p> </li><li> <p><strong>Dask</strong>：Dask 是一个开源的并行计算库，专为Python设计，可以处理大规模数据集，支持分布式任务调度和高级数组计算、数据帧操作。</p> </li><li> <p><strong>Trino (前身为 PrestoDB)</strong>：一个高性能的分布式SQL查询引擎，专为交互式分析设计，能够跨多种数据源进行查询，包括Hadoop、Amazon S3、Cassandra等。</p> </li><li> <p><strong>Druid</strong>：一个开源的列式存储和实时分析数据库，特别适合于大规模事件数据的实时聚合和查询。</p> </li><li> <p><strong>Hive Vectorized Engine</strong>：Hive 自带的向量化引擎，通过优化CPU向量指令集提高查询处理速度。</p> </li></ol> 
<p>这些计算引擎各有侧重，有的擅长批处理，有的专攻流处理，有的则在实时分析或交互式查询方面表现突出，选择合适的引擎需根据具体需求和场景来决定。</p> 
<h3>个人总结</h3> 
<p>我知道的有Apache Hadoop MapReduce和Apache Spark</p> 
<p></p> 
<h2 id="Spark%20RDD%E7%9A%84%E4%B8%80%E4%BA%9B%E8%80%83%E6%9F%A5">Spark RDD的一些考查</h2> 
<h3 id="%E4%B8%AA%E4%BA%BA%E5%88%86%E6%9E%90%E8%80%83%E5%AF%9F%E7%82%B9">个人分析考察点</h3> 
<p>Spark RDD（弹性分布式数据集，Resilient Distributed Dataset）是Spark的核心概念，它是一个容错的、并行的数据结构，能够分布在多台机器上进行并行处理。下面是一些关于RDD的基本考察点：</p> 
<ol><li> <p><strong>五大属性</strong>：每个RDD内部有五个主要属性：</p> 
  <ul><li> <p><strong>分区列表</strong>：RDD被分成多个分区，这些分区可以在集群的不同节点上并行处理。</p> </li><li> <p><strong>计算函数</strong>：对于每个分区，都有一个函数来计算该分区的数据。</p> </li><li> <p><strong>依赖关系列表</strong>：记录了RDD对其它RDD的依赖，形成了RDD之间的血统（Lineage），用于容错和重计算。</p> </li><li> <p><strong>分区器（可选）</strong>：确定数据如何跨分区分布的规则，如哈希分区或范围分区。</p> </li><li> <p><strong>持久化级别（可选）</strong>：控制RDD是否及如何在内存或磁盘中缓存。</p> </li></ul></li><li> <p><strong>弹性</strong>：RDD的弹性体现在其自动容错机制和数据恢复能力。如果某个分区的数据丢失或计算失败，Spark可以根据血统重新计算该分区，而不是重新计算整个RDD。</p> </li><li> <p><strong>转换（Transformation）</strong>：RDD支持一系列转换操作，如<code>map</code>、<code>filter</code>、<code>flatMap</code>、<code>join</code>等，这些操作是延迟执行的，也就是说，它们不会立即计算结果，而是记录了需要执行的操作。</p> </li><li> <p><strong>动作（Action）</strong>：触发实际计算的动作，如<code>count</code>、<code>collect</code>、<code>saveAsTextFile</code>等，执行后才会开始计算并产生结果或副作用。</p> </li><li> <p><strong>不可变性</strong>：一旦创建，RDD就是不可变的，任何对RDD的操作都会返回一个新的RDD，这有利于并行处理和错误恢复。</p> </li><li> <p><strong>分区</strong>：RDD的分区是数据并行处理的基本单位，合理的分区策略可以优化数据的并行计算效率。</p> </li><li> <p><strong>数据本地性</strong>：Spark会尽量安排任务在数据所在的节点上执行，利用数据本地性减少网络传输开销，提升性能。</p> </li><li> <p><strong>缓存与持久化</strong>：用户可以将经常访问的RDD持久化到内存或磁盘中，以加速后续操作，这是RDD高效处理的关键特性之一。</p> </li></ol> 
<p>掌握这些基本概念和操作，是进行Spark编程和大数据处理的基础。</p> 
<p></p> 
<h3 id="%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86">第二部分</h3> 
<h2 id="%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87">实验环境准备</h2> 
<h3 id="%E5%AE%98%E6%96%B9">官方</h3> 
<p>Linux系统 MySQL Hadoop Hive Sqoop ECharts Intellij idea Spark</p> 
<h3 id="%E4%B8%AA%E4%BA%BA%E5%88%86%E6%9E%90%E8%80%83%E7%82%B9">个人分析考点</h3> 
<p>主要问你有使用了说明，使用这个干什么</p> 
<p>比如：使用了ECharts。使用ECharts实现数据可视化</p> 
<p></p> 
<h2 id="%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8A%E4%BC%A0%E5%88%B0%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93Hive">本地数据集上传到数据仓库Hive</h2> 
<h3>官方</h3> 
<p>将本地数据集上传到Hive数据仓库通常涉及以下几个简单步骤：</p> 
<ol><li> <p><strong>准备数据</strong>：首先，确保你的本地数据集格式正确，如CSV、TXT或Parquet等，并准备好上传到Hive。数据应该与你打算在Hive中创建的表结构相匹配。</p> </li><li> <p><strong>登录Hive</strong>：通过Hive命令行界面或者使用图形化工具如Hue，登录到你的Hive服务器。</p> </li><li> <p><strong>创建Hive表</strong>：在Hive中创建一个表，定义好表结构，包括列名、数据类型等，确保这个表结构与你的本地数据集结构相匹配。可以使用<code>CREATE TABLE</code>命令来完成。</p> </li><li> <p><strong>上传数据</strong>：使用Hive的<code>LOAD DATA LOCAL INPATH</code>命令将本地文件路径下的数据加载到Hive表中。例如：</p> <p>Sql</p> <pre>1LOAD DATA LOCAL INPATH '/path/to/local/dataset.txt' INTO TABLE your_table_name;</pre> <p>这里，<code>LOCAL</code>关键字表示数据来源于本地文件系统，而非HDFS。</p> </li><li> <p><strong>验证数据</strong>：执行查询语句检查数据是否成功加载到Hive表中，比如使用<code>SELECT * FROM your_table_name LIMIT 10;</code>来查看前几行数据。</p> </li></ol> 
<p>注意，为了成功执行上述步骤，确保Hive服务正在运行，且你的用户账户拥有相应的权限执行这些操作。此外，数据文件的大小和格式也需要考虑，以避免超出Hive或HDFS的限制。在处理大规模数据时，可能还需要考虑数据的分片和分区策略以优化查询性能。</p> 
<h3>个人分析考察点</h3> 
<h4 id="%E6%B5%81%E7%A8%8B">流程</h4> 
<p>本地准备csv文件，登录hive，创建hive表与本地准备数据对应，使用hive命令上传，通过通过查询语句验证是否上传。</p> 
<p></p> 
<h2 id="Hive%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90">Hive数据分析</h2> 
<h3>官方</h3> 
<p>Hive数据分析是一个利用Hive数据仓库工具处理和分析大规模数据的过程，旨在通过简单的SQL-like语言（HiveQL）来提取有价值的信息和洞察。以下是Hive数据分析的简单概括步骤：</p> 
<ol><li> <p><strong>数据准备</strong>：首先，将数据从不同源头（如数据库、日志文件、数据仓库等）导入到Hadoop分布式文件系统(HDFS)中。数据可能需要进行清洗、转换或格式化以便于Hive处理。</p> </li><li> <p><strong>创建表和架构定义</strong>：在Hive中为数据集创建表，并定义表的结构（列名、数据类型、分区等）。这一步骤通过HiveQL的<code>CREATE TABLE</code>命令完成，同时可以指定数据的存储位置和文件格式（如TextFile、ORC、Parquet等）。</p> </li><li> <p><strong>加载数据</strong>：使用<code>LOAD DATA</code>命令或者<code>INSERT INTO</code>语句将HDFS上的数据加载到Hive表中。如果数据已存在于HDFS，则直接加载；否则，可能需要先上传数据到HDFS。</p> </li><li> <p><strong>编写查询</strong>：利用HiveQL编写查询语句来进行数据分析。HiveQL支持各种SQL操作，包括SELECT、JOIN、GROUP BY、ORDER BY、窗口函数等，以及一些特定于Hive的增强功能，如桶表、动态分区等。</p> </li><li> <p><strong>数据处理与分析</strong>：执行HiveQL查询，Hive会将查询转换为执行计划，该计划可能包含一系列MapReduce、Tez或Spark作业。Hive优化器会尝试优化执行计划以提高效率。</p> </li><li> <p><strong>结果查看与导出</strong>：查询执行完毕后，查看结果。可以使用<code>SELECT</code>语句直接在命令行查看数据，或者使用<code>INSERT OVERWRITE</code>将结果导出到HDFS文件、另一张表或外部系统中。</p> </li><li> <p><strong>性能优化</strong>：根据需要，对查询、表结构或Hive配置进行优化，以提高查询速度和资源利用率。这可能涉及索引创建、分区策略调整、数据压缩、使用更高效的文件格式等。</p> </li><li> <p><strong>数据可视化与报告</strong>：虽然Hive本身不提供数据可视化功能，但分析结果可以进一步导出到诸如Tableau、Power BI等数据可视化工具中，以便于生成图表和报告，辅助决策制定。</p> </li></ol> 
<p>Hive数据分析适合离线分析和批量处理场景，对于需要快速交互查询的场景，可能需要结合使用如Impala、Presto或Druid等更适合实时分析的工具。</p> 
<h3>个人分析考点</h3> 
<h4>流程</h4> 
<p>分析的数据是否已经准备，通过不同的查询语句来实现不同类型的数据展示也是就数据分析</p> 
<p></p> 
<p></p> 
<h2 id="%E5%B0%86%E6%95%B0%E6%8D%AE%E4%BB%8EHive%E5%AF%BC%E5%85%A5%E5%88%B0MySQL">将数据从Hive导入到MySQL</h2> 
<h3>官方</h3> 
<p>将数据从Hive导入到MySQL通常涉及以下简化步骤，使用Sqoop作为主要的数据迁移工具：</p> 
<ol><li> <p><strong>环境准备</strong>：</p> 
  <ul><li> <p>确保Hadoop集群、Hive、MySQL以及Sqoop服务均处于运行状态。</p> </li><li> <p>在MySQL中预先创建目标表结构，确保其与Hive表结构兼容，包括列名和数据类型。</p> </li></ul></li><li> <p><strong>配置连接</strong>：</p> 
  <ul><li> <p>配置Sqoop以连接到MySQL数据库，这通常涉及到在Sqoop命令中指定MySQL的地址、用户名、密码等连接参数。</p> </li></ul></li><li> <p><strong>编写Sqoop命令</strong>：</p> 
  <ul><li> <p>使用Sqoop的export命令来制定数据迁移任务。基本命令结构如下：</p> <p>Bash</p> <pre>1sqoop export \
2  --connect "jdbc:mysql://mysql_host:port/database" \
3  --username username \
4  --password password \
5  --table mysql_table_name \
6  --export-dir /path/to/hive/data/in/hdfs \
7  --input-fields-terminated-by '\001' \
8  --update-key primary_key_column \
9  --update-mode allowinsert </pre> </li><li> <p>上述命令中，<code>--export-dir</code>指定HDFS上Hive数据的位置，<code>--input-fields-terminated-by</code>指定了Hive数据文件的分隔符（默认情况下，Hive使用<code>\001</code>作为分隔符），<code>--update-key</code>和<code>--update-mode</code>用于指定如何处理已存在记录的更新策略。</p> </li></ul></li><li> <p><strong>执行迁移</strong>：</p> 
  <ul><li> <p>在命令行中执行上述Sqoop命令，开始数据导出过程。Sqoop会读取HDFS上的数据，将其转换为适合MySQL的数据格式，并导入到指定的MySQL表中。</p> </li></ul></li><li> <p><strong>监控与验证</strong>：</p> 
  <ul><li> <p>监控任务执行过程，确认数据成功导入MySQL。可以通过检查MySQL表数据、查看Sqoop的输出日志或使用MySQL的查询语句来验证数据的完整性和准确性。</p> </li></ul></li><li> <p><strong>优化与调整</strong>：</p> 
  <ul><li> <p>根据数据量和导入速度，可能需要调整Sqoop的参数，比如增加map tasks的数量，以提升导入效率。</p> </li></ul></li></ol> 
<p>请注意，实际操作中可能还需根据具体情况调整命令参数和处理潜在的数据转换问题。</p> 
<h3>个人分析考点</h3> 
<h4>流程</h4> 
<p>确定hive中是否存在数据，使用Sqoop连接数据库MySQL，通过Bash命令填写基本信息，如数据库名，密码需要导入数据库地址登信息。</p> 
<p></p> 
<p></p> 
<h2 id="%E5%88%A9%E7%94%A8Spark%E9%A2%84%E6%B5%8B%E5%9B%9E%E5%A4%B4%E5%AE%A2">利用Spark预测回头客</h2> 
<h3>官方</h3> 
<p>利用Apache Spark预测回头客（即顾客是否会再次购买或使用服务）通常涉及机器学习方法，特别是分类算法。以下是一个简化的流程，介绍如何使用Spark MLlib（Spark的机器学习库）进行回头客预测：</p> 
<h4 id="1.%20%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E4%B8%8E%E9%A2%84%E5%A4%84%E7%90%86">1. 数据收集与预处理</h4> 
<ul><li> <p><strong>收集数据</strong>：收集历史交易数据，包括但不限于顾客ID、购买日期、购买金额、购买频率、商品类别、促销活动参与情况、客户反馈等。</p> </li><li> <p><strong>数据清洗</strong>：使用Spark DataFrame API或Spark SQL处理缺失值、异常值，进行数据类型转换。</p> </li><li> <p><strong>特征工程</strong>：从原始数据中构建有助于预测的特征，如顾客的购买频率、平均消费额、最近一次购买距离当前的时间间隔等。可以使用<code>VectorAssembler</code>来组装特征向量。</p> </li></ul> 
<h4 id="2.%20%E5%88%92%E5%88%86%E6%95%B0%E6%8D%AE%E9%9B%86">2. 划分数据集</h4> 
<ul><li> <p>将数据集分为训练集和测试集，通常比例为70%:30%或80%:20%。使用<code>randomSplit</code>方法实现。</p> </li></ul> 
<h4 id="3.%20%E9%80%89%E6%8B%A9%E6%A8%A1%E5%9E%8B">3. 选择模型</h4> 
<ul><li> <p>选择合适的机器学习模型，对于回头客预测，逻辑回归（Logistic Regression）、随机森林（Random Forest）、梯度提升树（Gradient Boosted Trees, GBT）或神经网络都是不错的选择。</p> </li></ul> 
<h4 id="4.%20%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B">4. 训练模型</h4> 
<ul><li> <p>使用Spark MLlib的API训练模型。例如，如果是逻辑回归：</p> <p>Python</p> <pre>1from pyspark.ml.classification import LogisticRegression
2
3lr = LogisticRegression(featuresCol='features', labelCol='is_return_customer')
4model = lr.fit(trainingData)</pre> </li></ul> 
<h4 id="5.%20%E8%AF%84%E4%BC%B0%E6%A8%A1%E5%9E%8B">5. 评估模型</h4> 
<ul><li> <p>在测试集上评估模型性能，常用的评估指标有准确率、召回率、F1分数等。可以使用<code>BinaryClassificationEvaluator</code>。</p> </li></ul> 
<h4 id="6.%20%E8%B0%83%E4%BC%98">6. 调优</h4> 
<ul><li> <p>根据评估结果，调整模型参数（如正则化参数、树的深度等），进行交叉验证（<code>CrossValidator</code>或<code>TrainValidationSplit</code>）以找到最优参数组合。</p> </li></ul> 
<h4 id="7.%20%E9%A2%84%E6%B5%8B%E4%B8%8E%E9%83%A8%E7%BD%B2">7. 预测与部署</h4> 
<ul><li> <p>使用训练好的模型对新的顾客数据进行预测，识别潜在的回头客。</p> </li><li> <p>将模型部署到生产环境，可能是通过Spark Streaming处理实时数据流，或定期对新数据进行批处理预测。</p> </li></ul> 
<h4 id="8.%20%E5%8F%8D%E9%A6%88%E5%BE%AA%E7%8E%AF">8. 反馈循环</h4> 
<ul><li> <p>实际应用中，模型的预测效果需要持续监控，根据实际业务反馈调整模型或特征，形成闭环迭代优化。</p> </li></ul> 
<p>通过以上步骤，你可以利用Spark强大的分布式计算能力来高效地预测顾客是否会成为回头客，进而为营销策略、客户服务等方面提供数据支持。</p> 
<h3>个人分析考点</h3> 
<p>首先存在需要预测回头客数据，然后划分数据集，使用训练模型进行训练。</p> 
<p></p> 
<h2 id="%E5%88%A9%E7%94%A8ECharts%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90">利用ECharts进行数据可视化分析</h2> 
<h3>官方</h3> 
<p>利用ECharts进行数据可视化分析是一个直观且高效的过程，它可以帮助你将复杂的数据转化为易于理解的图表形式。以下是使用ECharts进行数据可视化分析的一般步骤：</p> 
<h4 id="1.%20%E5%87%86%E5%A4%87%E6%95%B0%E6%8D%AE">1. 准备数据</h4> 
<ul><li> <p><strong>收集数据</strong>：首先，你需要收集相关的数据，这些数据可以来自于数据库、CSV文件、API接口等多种来源。</p> </li><li> <p><strong>整理数据</strong>：根据分析目的，整理和清洗数据，确保数据质量。可能需要进行缺失值处理、异常值剔除、数据类型转换等操作。</p> </li></ul> 
<h4 id="2.%20%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AEECharts">2. 安装与配置ECharts</h4> 
<ul><li> <p><strong>引入ECharts</strong>：在项目中通过npm安装ECharts或者直接在HTML页面中通过CDN链接引入ECharts库。</p> </li><li> <p><strong>设置环境</strong>：如果你使用的是如Vue、React等前端框架，可能需要安装对应的ECharts适配器。</p> </li></ul> 
<h4 id="3.%20%E8%AE%BE%E8%AE%A1%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%B9%E6%A1%88">3. 设计可视化方案</h4> 
<ul><li> <p><strong>选择图表类型</strong>：根据数据特性和分析目的选择合适的图表类型，ECharts提供了丰富的图表选项，如折线图、柱状图、饼图、散点图、热力图等。</p> </li><li> <p><strong>设计布局</strong>：规划图表的布局，决定哪些图表需要展示，以及它们如何排列在页面上。</p> </li></ul> 
<h4 id="4.%20%E7%BC%96%E5%86%99ECharts%E9%85%8D%E7%BD%AE%E9%A1%B9">4. 编写ECharts配置项</h4> 
<ul><li> <p><strong>初始化图表</strong>：在页面的DOM容器中初始化ECharts实例。</p> </li><li> <p>配置Option</p> <p>：编写详细的</p> <pre>option</pre> <p>对象，这个对象定义了图表的所有属性，包括标题、数据、系列、轴、图例、提示信息等。</p> <p>Javascript</p> <pre>1var myChart = echarts.init(document.getElementById('main'));
2var option = {
3    title: { text: '销售数据分析' },
4    tooltip: {},
5    xAxis: { data: ['周一', '周二', '周三', '周四', '周五', '周六', '周日'] },
6    yAxis: {},
7    series: [{
8        name: '销量',
9        type: 'bar',
10        data: [5, 20, 36, 10, 10, 20, 40]
11    }]
12};
13
14myChart.setOption(option);</pre> </li></ul> 
<h4 id="5.%20%E4%BA%A4%E4%BA%92%E4%B8%8E%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE">5. 交互与动态数据</h4> 
<ul><li> <p><strong>添加交互</strong>：利用ECharts的交互特性，如点击事件、数据区域缩放、图表切换等，增强用户体验。</p> </li><li> <p><strong>动态数据</strong>：如果数据是实时更新的，可以使用ECharts的<code>setOption</code>或<code>dispatchAction</code>方法动态更新图表数据。</p> </li></ul> 
<h4 id="6.%20%E7%BE%8E%E5%8C%96%E4%B8%8E%E4%BC%98%E5%8C%96">6. 美化与优化</h4> 
<ul><li> <p><strong>主题定制</strong>：使用ECharts内置的主题或自定义主题来美化图表。</p> </li><li> <p><strong>性能优化</strong>：对于大数据量的图表，考虑使用数据采样、分段加载、渲染优化等策略来提高性能。</p> </li></ul> 
<h4 id="7.%20%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%8F%91%E5%B8%83">7. 测试与发布</h4> 
<ul><li> <p><strong>多平台测试</strong>：确保图表在不同浏览器和设备上都能正常显示。</p> </li><li> <p><strong>集成到项目</strong>：将完成的可视化页面集成到你的应用或网站中，并进行最终测试。</p> </li></ul> 
<p>通过遵循这些步骤，你可以有效地利用ECharts进行数据可视化分析，帮助团队和决策者更好地理解和解释数据，从而做出更明智的决策。</p> 
<h3>个人分析考点</h3> 
<p>将查询到的数据，配置编写给ECharts，实现数据可视化</p> 
<p></p> 
<h2 id="%E9%92%88%E5%AF%B9%20user_log%E8%A1%A8">针对 user_log表</h2> 
<h3 id="%E4%B8%AA%E4%BA%BA%E5%88%86%E6%9E%90%E6%96%B9%E5%90%91%E7%82%B9">个人分析方向点</h3> 
<p>问表单都有哪些字段，字段中文意思是什么？</p> 
<h3 id="%E8%A1%A8%E5%8D%95">表单</h3> 
<ol><li> <p>user_id | 买家id</p> </li><li> <p>item_id | 商品id</p> </li><li> <p>cat_id | 商品类别id</p> </li><li> <p>merchant_id | 卖家id</p> </li><li> <p>brand_id | 品牌id</p> </li><li> <p>month | 交易时间:月</p> </li><li> <p>day | 交易事件:日</p> </li><li> <p>action | 行为,取值范围{0,1,2,3},0表示点击，1表示加入购物车，2表示购买，3表示关注商品</p> </li><li> <p>age_range | 买家年龄分段：1表示年龄&lt;18,2表示年龄在[18,24]，3表示年龄在[25,29]，4表示年龄在[30,34]，5表示年龄在[35,39]，6表示年龄在[40,49]，7和8表示年龄&gt;=50,0和NULL则表示未知</p> </li><li> <p>gender | 性别:0表示女性，1表示男性，2和NULL表示未知</p> </li><li> <p>province| 收获地址省份</p> </li></ol> 
<p></p> 
<h2 id="%E4%BC%9A%E8%AE%A9%E4%BD%A0%E5%86%99%E5%87%A0%E4%B8%AA%20HiveOL%E8%AF%AD%E5%8F%A5">会让你写几个 HiveOL语句</h2> 
<h3 id="%E6%88%91%E8%BF%99%E9%87%8C%E5%B0%86%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5%E7%BD%97%E5%88%97%E5%87%BA%E6%9D%A5">我这里将基本语句罗列出来</h3> 
<p>HiveQL（Hive结构化查询语言）是Hive中用于数据处理和管理的SQL-like语言。下面列举了一些常见的HiveQL语句示例，涵盖了数据表操作、数据查询、数据处理等方面的基础用法：</p> 
<h4 id="1.%20%E5%88%9B%E5%BB%BA%E8%A1%A8">1. 创建表</h4> 
<ul><li> <p>创建一个基本表</p> <p>Sql</p> <pre>1CREATE TABLE IF NOT EXISTS employees (
2  id INT,
3  name STRING,
4  department STRING,
5  salary FLOAT
6) ROW FORMAT DELIMITED FIELDS TERMINATED BY '\t';</pre> </li></ul> 
<h4 id="2.%20%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE">2. 加载数据</h4> 
<ul><li> <p><strong>从本地文件系统加载数据</strong></p> <p>Sql</p> <pre>1LOAD DATA LOCAL INPATH '/path/to/employees_data.txt' INTO TABLE employees;</pre> </li><li> <p><strong>从HDFS加载数据</strong></p> <p>Sql</p> <pre>1LOAD DATA INPATH 'hdfs://namenode:port/path/to/employees_data.txt' INTO TABLE employees;</pre> </li></ul> 
<h4 id="3.%20%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE">3. 查询数据</h4> 
<ul><li> <p><strong>简单查询</strong></p> <p>Sql</p> <pre>1SELECT * FROM employees;</pre> </li><li> <p><strong>筛选条件查询</strong></p> <p>Sql</p> <pre>1SELECT name, salary FROM employees WHERE department = 'Sales' AND salary &gt; 50000;</pre> </li></ul> 
<h4 id="4.%20%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0">4. 聚合函数</h4> 
<ul><li> <p>使用聚合函数进行分组统计</p> <p>Sql</p> <pre>1SELECT department, COUNT(*) AS employee_count, AVG(salary) AS avg_salary
2FROM employees
3GROUP BY department;</pre> </li></ul> 
<h4 id="5.%20%E5%88%86%E5%8C%BA%E8%A1%A8">5. 分区表</h4> 
<ul><li> <p><strong>创建分区表</strong></p> <p>Sql</p> <pre>1CREATE TABLE employees_partitioned (id INT, name STRING, salary FLOAT)
2PARTITIONED BY (year INT, month INT);</pre> </li><li> <p><strong>加载数据到分区</strong></p> <p>Sql</p> <pre>1ALTER TABLE employees_partitioned ADD PARTITION (year=2023, month=4);
2LOAD DATA INPATH 'hdfs://.../apr_employees_data.txt' INTO TABLE employees_partitioned PARTITION(year=2023, month=4);</pre> </li></ul> 
<h4 id="6.%20%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C">6. 删除操作</h4> 
<ul><li> <p><strong>删除表</strong></p> <p>Sql</p> <pre>1DROP TABLE IF EXISTS employees;</pre> </li><li> <p><strong>清空表数据</strong></p> <p>Sql</p> <pre>1TRUNCATE TABLE employees;</pre> </li></ul> 
<h4 id="7.%20%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE">7. 插入数据</h4> 
<ul><li> <p><strong>插入单行数据</strong></p> <p>Sql</p> <pre>1INSERT INTO TABLE employees VALUES (1, 'John Doe', 'HR', 60000);</pre> </li><li> <p><strong>从查询结果插入数据</strong></p> <p>Sql</p> <pre>1INSERT INTO TABLE employees SELECT id, name, 'New Dept' AS department, salary FROM employees WHERE department = 'Old Dept';</pre> </li></ul> 
<h4 id="8.%20%E8%A7%86%E5%9B%BE">8. 视图</h4> 
<ul><li> <p>创建视图</p> <p>Sql</p> <pre>1CREATE VIEW high_salary_employees AS
2SELECT * FROM employees WHERE salary &gt; 80000;</pre> </li></ul> 
<p>这些只是HiveQL众多功能中的一部分，实际应用中，HiveQL还支持更多高级功能，如窗口函数、连接操作、用户自定义函数(UDF)等。</p> 
<p></p> 
<h2 id="%E4%BC%9A%E8%AE%A9%E6%89%93%E5%BC%80%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E8%AE%A9%E4%BD%A0%E8%AE%B2%E8%A7%A3%E4%B8%80%E4%B8%8B%E4%BB%A3%E7%A0%81%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%2C%E5%B0%B1%E9%82%A3%E5%87%A0%E4%B8%AA%20index%20%E9%A1%B5%E9%9D%A2%EF%BC%8C%E8%BF%98%E6%9C%89%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%20dbtaobao%20%E7%9A%84%20java%E4%BB%A3%E7%A0%81%E3%80%82">会让打开一段代码让你讲解一下代码什么意思,就那几个 index 页面，还有连接数据库操作 dbtaobao 的 java代码。</h2> 
<h3 id="%E5%89%8D%E7%AB%AF">前端</h3> 
<p>index就是前端页面，前端有五个页面</p> 
<p>都是添加了ECharts实现数据可视化，其余就是静态页面，大家可以重点看看Echarts代码</p> 
<h3 id="%E5%90%8E%E7%AB%AF">后端</h3> 
<p>代码</p> 
<p>个别注释了，其余后面select可以对照前面注释</p> 
<pre>package dbtaobao;
import java.sql.*;
import java.util.ArrayList;

public class connDb {
    private static Connection con = null;
    private static Statement stmt = null;
    private static ResultSet rs = null;
//连接数据库方法
public static void startConn(){
    try{
        Class.forName("com.mysql.jdbc.Driver");
        //连接数据库中间件
        try{
            con = DriverManager.getConnection("jdbc:MySQL://localhost:3306/dbtaobao","root","root");
        }catch(SQLException e){
            e.printStackTrace();
        }
    }catch(ClassNotFoundException e){
        e.printStackTrace();
    }
}
 
//关闭连接数据库方法
public static void endConn() throws SQLException{
    if(con != null){
        con.close();
        con = null;
    }
    if(rs != null){
        rs.close();
        rs = null;
    }
    if(stmt != null){
        stmt.close();
        stmt = null;
    }
}
//数据库双11 所有买家消费行为比例
public static ArrayList index() throws SQLException{
    ArrayList&lt;String[]&gt; list = new ArrayList();
    startConn();
    stmt = con.createStatement();
    //查询user_log表，统计数据数量和action的,1表示加入购物车，2表示购买，3表示关注商品实现分组
    rs = stmt.executeQuery("select action,count(*) num from user_log group by action desc");
    while(rs.next()){
        String[] temp={rs.getString("action"),rs.getString("num")};
        list.add(temp);
    }
        endConn();
    return list;
}
//男女买家交易对比
    public static ArrayList index_1() throws SQLException{
        ArrayList&lt;String[]&gt; list = new ArrayList();
        startConn();
        stmt = con.createStatement();
        //查询user_log表，统计数据数量和gender的:0表示女性，1表示男性，2和NULL表示未知,实现分组
        rs = stmt.executeQuery("select gender,count(*) num from user_log group by gender desc");
        while(rs.next()){
            String[] temp={rs.getString("gender"),rs.getString("num")};
            list.add(temp);
        }
        endConn();
        return list;
    }
    //男女买家各个年龄段交易对比
    public static ArrayList index_2() throws SQLException{
        ArrayList&lt;String[]&gt; list = new ArrayList();
        startConn();
        stmt = con.createStatement();
        //查询user_log表，统计数据数量age_ranged的，(1表示年龄&lt;18,2表示年龄在[18,24]，3表示年龄在[25,29]，4表示年龄在[30,34]，5表示年龄在[35,39]，6表示年龄在[40,49]，7和8表示年龄&gt;=50,0和NULL则表示未知，),和gender(0表示点击，1表示加入购物车，2表示购买，3表示关注商品)
        rs = stmt.executeQuery("select gender,age_range,count(*) num from user_log group by gender,age_range desc");
        while(rs.next()){
            String[] temp={rs.getString("gender"),rs.getString("age_range"),rs.getString("num")};
            list.add(temp);
        }
        endConn();
        return list;
    }
    //获取销量前五的商品类别
    public static ArrayList index_3() throws SQLException{
        ArrayList&lt;String[]&gt; list = new ArrayList();
        startConn();
        stmt = con.createStatement();
        rs = stmt.executeQuery("select cat_id,count(*) num from user_log group by cat_id order by count(*) desc limit 5");
        while(rs.next()){
            String[] temp={rs.getString("cat_id"),rs.getString("num")};
            list.add(temp);
        }
        endConn();
        return list;
    }
//各个省份的的总成交量对比
public static ArrayList index_4() throws SQLException{
    ArrayList&lt;String[]&gt; list = new ArrayList();
    startConn();
    stmt = con.createStatement();
    rs = stmt.executeQuery("select province,count(*) num from user_log group by province order by count(*) desc");
    while(rs.next()){
        String[] temp={rs.getString("province"),rs.getString("num")};
        list.add(temp);
    }
    endConn();
    return list;
}
}
}</pre> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/266289348c952798ca7eb803df6905e4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java的集合框架总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8c9a83f4f63db06b31f870edd8afba84/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据结构之链表的经典笔试题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>