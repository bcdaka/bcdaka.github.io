<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python酷库之旅-第三方库Pandas(014) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b675731eb04c855fa7971495fccd93a0/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Python酷库之旅-第三方库Pandas(014)">
  <meta property="og:description" content="目录
一、用法精讲
34、pandas.DataFrame.to_parquet函数
34-1、语法
34-2、参数
34-3、功能
34-4、返回值
34-5、说明
34-6、用法
34-6-1、数据准备
34-6-2、代码示例
34-6-3、结果输出
35、pandas.read_sql_table函数
35-1、语法
35-2、参数
35-3、功能
35-4、返回值
35-5、说明
35-6、用法
35-6-1、数据准备
35-6-2、代码示例
35-6-3、结果输出 36、pandas.read_sql_query函数
36-1、语法
36-2、参数
36-3、功能
36-4、返回值
36-5、说明
36-6、用法
36-6-1、数据准备
36-6-2、代码示例
36-6-3、结果输出 二、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、博客个人主页
一、用法精讲 34、pandas.DataFrame.to_parquet函数 34-1、语法 # 34、pandas.DataFrame.to_parquet函数 DataFrame.to_parquet(path=None, *, engine=&#39;auto&#39;, compression=&#39;snappy&#39;, index=None, partition_cols=None, storage_options=None, **kwargs) Write a DataFrame to the binary parquet format. This function writes the dataframe as a parquet file. You can choose different parquet backends, and have the option of compression.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-10T19:21:52+08:00">
    <meta property="article:modified_time" content="2024-07-10T19:21:52+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python酷库之旅-第三方库Pandas(014)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong><span style="color:#1a439c;">目录</span></strong></p> 
<p id="%E4%B8%80%E3%80%81%E7%94%A8%E6%B3%95%E7%B2%BE%E8%AE%B2-toc" style="margin-left:80px;"><strong><a href="#%E4%B8%80%E3%80%81%E7%94%A8%E6%B3%95%E7%B2%BE%E8%AE%B2" rel="nofollow"><span style="color:#1a439c;">一、用法精讲</span></a></strong></p> 
<p id="5%E3%80%81pandas.DataFrame.to_csv%E5%87%BD%E6%95%B0-toc" style="margin-left:120px;"><strong><a href="#5%E3%80%81pandas.DataFrame.to_csv%E5%87%BD%E6%95%B0" rel="nofollow"><span style="color:#1a439c;">34、pandas.DataFrame.to_parquet函数</span></a></strong></p> 
<p id="5-1%E3%80%81%E8%AF%AD%E6%B3%95-toc" style="margin-left:160px;"><strong><a href="#5-1%E3%80%81%E8%AF%AD%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">34-1、语法</span></a></strong></p> 
<p id="5-2%E3%80%81%E5%8F%82%E6%95%B0-toc" style="margin-left:160px;"><strong><a href="#5-2%E3%80%81%E5%8F%82%E6%95%B0" rel="nofollow"><span style="color:#1a439c;">34-2、参数</span></a></strong></p> 
<p id="5-3%E3%80%81%E5%8A%9F%E8%83%BD-toc" style="margin-left:160px;"><strong><a href="#5-3%E3%80%81%E5%8A%9F%E8%83%BD" rel="nofollow"><span style="color:#1a439c;">34-3、功能</span></a></strong></p> 
<p id="5-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC-toc" style="margin-left:160px;"><strong><a href="#5-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC" rel="nofollow"><span style="color:#1a439c;">34-4、返回值</span></a></strong></p> 
<p id="5-5%E3%80%81%E8%AF%B4%E6%98%8E-toc" style="margin-left:160px;"><strong><a href="#5-5%E3%80%81%E8%AF%B4%E6%98%8E" rel="nofollow"><span style="color:#1a439c;">34-5、说明</span></a></strong></p> 
<p id="5-6%E3%80%81%E7%94%A8%E6%B3%95-toc" style="margin-left:160px;"><strong><a href="#5-6%E3%80%81%E7%94%A8%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">34-6、用法</span></a></strong></p> 
<p id="10-6-1%E3%80%81%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87-toc" style="margin-left:200px;"><strong><a href="#10-6-1%E3%80%81%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87" rel="nofollow"><span style="color:#1a439c;">34-6-1、数据准备</span></a></strong></p> 
<p id="5-6-1%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-toc" style="margin-left:200px;"><strong><a href="#5-6-1%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B" rel="nofollow"><span style="color:#1a439c;">34-6-2、代码示例</span></a></strong></p> 
<p id="5-6-2%E3%80%81%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA-toc" style="margin-left:200px;"><strong><a href="#5-6-2%E3%80%81%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA" rel="nofollow"><span style="color:#1a439c;">34-6-3、结果输出</span></a></strong></p> 
<p id="11%E3%80%81pandas.ExcelFile%E7%B1%BB-toc" style="margin-left:120px;"><strong><a href="#11%E3%80%81pandas.ExcelFile%E7%B1%BB" rel="nofollow"><span style="color:#1a439c;">35、pandas.read_sql_table函数</span></a></strong></p> 
<p id="11-1%E3%80%81%E8%AF%AD%E6%B3%95-toc" style="margin-left:160px;"><strong><a href="#11-1%E3%80%81%E8%AF%AD%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">35-1、语法</span></a></strong></p> 
<p id="11-2%E3%80%81%E5%8F%82%E6%95%B0-toc" style="margin-left:160px;"><strong><a href="#11-2%E3%80%81%E5%8F%82%E6%95%B0" rel="nofollow"><span style="color:#1a439c;">35-2、参数</span></a></strong></p> 
<p id="11-3%E3%80%81%E5%8A%9F%E8%83%BD-toc" style="margin-left:160px;"><strong><a href="#11-3%E3%80%81%E5%8A%9F%E8%83%BD" rel="nofollow"><span style="color:#1a439c;">35-3、功能</span></a></strong></p> 
<p id="11-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC-toc" style="margin-left:160px;"><strong><a href="#11-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC" rel="nofollow"><span style="color:#1a439c;">35-4、返回值</span></a></strong></p> 
<p id="11-5%E3%80%81%E8%AF%B4%E6%98%8E-toc" style="margin-left:160px;"><strong><a href="#11-5%E3%80%81%E8%AF%B4%E6%98%8E" rel="nofollow"><span style="color:#1a439c;">35-5、说明</span></a></strong></p> 
<p id="11-6%E3%80%81%E7%94%A8%E6%B3%95-toc" style="margin-left:160px;"><strong><a href="#11-6%E3%80%81%E7%94%A8%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">35-6、用法</span></a></strong></p> 
<p id="11-6-1%E3%80%81%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87-toc" style="margin-left:200px;"><strong><a href="#11-6-1%E3%80%81%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87" rel="nofollow"><span style="color:#1a439c;">35-6-1、数据准备</span></a></strong></p> 
<p id="11-6-2%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-toc" style="margin-left:200px;"><strong><a href="#11-6-2%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B" rel="nofollow"><span style="color:#1a439c;">35-6-2、代码示例</span></a></strong></p> 
<p id="11-6-3%E3%80%81%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA%C2%A0-toc" style="margin-left:200px;"><strong><a href="#11-6-3%E3%80%81%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA%C2%A0" rel="nofollow"><span style="color:#1a439c;">35-6-3、结果输出 </span></a></strong></p> 
<p id="12%E3%80%81pandas.ExcelFile.parse%E5%87%BD%E6%95%B0-toc" style="margin-left:120px;"><strong><a href="#12%E3%80%81pandas.ExcelFile.parse%E5%87%BD%E6%95%B0" rel="nofollow"><span style="color:#1a439c;">36、pandas.read_sql_query函数</span></a></strong></p> 
<p id="12-1%E3%80%81%E8%AF%AD%E6%B3%95-toc" style="margin-left:160px;"><strong><a href="#12-1%E3%80%81%E8%AF%AD%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">36-1、语法</span></a></strong></p> 
<p id="12-2%E3%80%81%E5%8F%82%E6%95%B0-toc" style="margin-left:160px;"><strong><a href="#12-2%E3%80%81%E5%8F%82%E6%95%B0" rel="nofollow"><span style="color:#1a439c;">36-2、参数</span></a></strong></p> 
<p id="12-3%E3%80%81%E5%8A%9F%E8%83%BD-toc" style="margin-left:160px;"><strong><a href="#12-3%E3%80%81%E5%8A%9F%E8%83%BD" rel="nofollow"><span style="color:#1a439c;">36-3、功能</span></a></strong></p> 
<p id="12-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC-toc" style="margin-left:160px;"><strong><a href="#12-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC" rel="nofollow"><span style="color:#1a439c;">36-4、返回值</span></a></strong></p> 
<p id="12-5%E3%80%81%E8%AF%B4%E6%98%8E-toc" style="margin-left:160px;"><strong><a href="#12-5%E3%80%81%E8%AF%B4%E6%98%8E" rel="nofollow"><span style="color:#1a439c;">36-5、说明</span></a></strong></p> 
<p id="12-6%E3%80%81%E7%94%A8%E6%B3%95-toc" style="margin-left:160px;"><strong><a href="#12-6%E3%80%81%E7%94%A8%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">36-6、用法</span></a></strong></p> 
<p id="12-6-1%E3%80%81%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87-toc" style="margin-left:200px;"><strong><a href="#12-6-1%E3%80%81%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87" rel="nofollow"><span style="color:#1a439c;">36-6-1、数据准备</span></a></strong></p> 
<p id="12-6-2%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-toc" style="margin-left:200px;"><strong><a href="#12-6-2%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B" rel="nofollow"><span style="color:#1a439c;">36-6-2、代码示例</span></a></strong></p> 
<p id="12-6-3%E3%80%81%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA%C2%A0-toc" style="margin-left:200px;"><strong><a href="#12-6-3%E3%80%81%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA%C2%A0" rel="nofollow"><span style="color:#1a439c;">36-6-3、结果输出 </span></a></strong></p> 
<p id="%E4%BA%94%E3%80%81%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB-toc" style="margin-left:80px;"><strong><a href="#%E4%BA%94%E3%80%81%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB" rel="nofollow"><span style="color:#1a439c;">二、推荐阅读</span></a></strong></p> 
<p id="1%E3%80%81-toc" style="margin-left:120px;"><strong><a href="#1%E3%80%81" rel="nofollow"><span style="color:#1a439c;">1、Python筑基之旅</span></a></strong></p> 
<p id="2%E3%80%81-toc" style="margin-left:120px;"><strong><a href="#2%E3%80%81" rel="nofollow"><span style="color:#1a439c;">2、Python函数之旅</span></a></strong></p> 
<p id="3%E3%80%81-toc" style="margin-left:120px;"><strong><a href="#3%E3%80%81" rel="nofollow"><span style="color:#1a439c;">3、Python算法之旅</span></a></strong></p> 
<p id="4%E3%80%81-toc" style="margin-left:120px;"><strong><a href="#4%E3%80%81" rel="nofollow"><span style="color:#1a439c;">4、Python魔法之旅</span></a></strong></p> 
<p id="5%E3%80%81%C2%A0-toc" style="margin-left:120px;"><strong><a href="#5%E3%80%81%C2%A0" rel="nofollow"><span style="color:#1a439c;">5、博客个人主页</span></a></strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/bf/a9/CODKqcjJ_o.gif"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/89/e0/tCruMS6R_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/19/89/4WDn2SLU_o.gif"></p> 
<h4 id="%E4%B8%80%E3%80%81%E7%94%A8%E6%B3%95%E7%B2%BE%E8%AE%B2">一、用法精讲</h4> 
<h5 id="5%E3%80%81pandas.DataFrame.to_csv%E5%87%BD%E6%95%B0">34、<span style="color:#fe2c24;">pandas.DataFrame.to_parquet</span>函数</h5> 
<h6 id="5-1%E3%80%81%E8%AF%AD%E6%B3%95">34-1、语法</h6> 
<pre><code class="language-python"># 34、pandas.DataFrame.to_parquet函数
DataFrame.to_parquet(path=None, *, engine='auto', compression='snappy', index=None, partition_cols=None, storage_options=None, **kwargs)
Write a DataFrame to the binary parquet format.

This function writes the dataframe as a parquet file. You can choose different parquet backends, and have the option of compression. See the user guide for more details.

Parameters:
path
str, path object, file-like object, or None, default None
String, path object (implementing os.PathLike[str]), or file-like object implementing a binary write() function. If None, the result is returned as bytes. If a string or path, it will be used as Root Directory path when writing a partitioned dataset.

engine
{‘auto’, ‘pyarrow’, ‘fastparquet’}, default ‘auto’
Parquet library to use. If ‘auto’, then the option io.parquet.engine is used. The default io.parquet.engine behavior is to try ‘pyarrow’, falling back to ‘fastparquet’ if ‘pyarrow’ is unavailable.

compression
str or None, default ‘snappy’
Name of the compression to use. Use None for no compression. Supported options: ‘snappy’, ‘gzip’, ‘brotli’, ‘lz4’, ‘zstd’.

index
bool, default None
If True, include the dataframe’s index(es) in the file output. If False, they will not be written to the file. If None, similar to True the dataframe’s index(es) will be saved. However, instead of being saved as values, the RangeIndex will be stored as a range in the metadata so it doesn’t require much space and is faster. Other indexes will be included as columns in the file output.

partition_cols
list, optional, default None
Column names by which to partition the dataset. Columns are partitioned in the order they are given. Must be None if path is not a string.

storage_options
dict, optional
Extra options that make sense for a particular storage connection, e.g. host, port, username, password, etc. For HTTP(S) URLs the key-value pairs are forwarded to urllib.request.Request as header options. For other URLs (e.g. starting with “s3://”, and “gcs://”) the key-value pairs are forwarded to fsspec.open. Please see fsspec and urllib for more details, and for more examples on storage options refer here.

**kwargs
Additional arguments passed to the parquet library. See pandas io for more details.

Returns:
bytes if no path argument is provided else None.</code></pre> 
<h6 id="5-2%E3%80%81%E5%8F%82%E6%95%B0">34-2、参数</h6> 
<p><span style="color:#fe2c24;"><strong>34-2-1、path</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>指定要写入Parquet文件的路径。如果为None，则不会将DataFrame保存到文件，但通常会通过其他方式(如返回字节流)使用生成的Parquet数据。</p> 
<p><span style="color:#fe2c24;"><strong>34-2-2、engine</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为'auto')</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>指定用于写入Parquet文件的引擎。'auto'会自动选择可用的库(优先使用pyarrow，如果没有安装则使用fastparquet)，'pyarrow'和 'fastparquet'是两个流行的Parquet库，各有特点和性能差异。</p> 
<p><span style="color:#fe2c24;"><strong>34-2-3、compression</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为'snappy')</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>指定用于Parquet文件的压缩方法，'snappy'是一种快速压缩算法，适合大多数情况，'gzip'和'brotli'提供更高的压缩率，但可能会降低写入和读取速度。如果设置为None，则不压缩数据。</p> 
<p><span style="color:#fe2c24;"><strong>34-2-4、index</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>控制是否将DataFrame的索引写入Parquet文件。如果为True，则索引会被写入Parquet文件的_index列；如果为False，则不会写入索引；如果为None(默认值)，则行为取决于engine的默认设置。</p> 
<p><span style="color:#fe2c24;"><strong>34-2-5、partition_cols</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>指定用于分区的列名列表，分区是一种将表数据分割成更小、更易于管理的部分的技术，通常基于某些列的值，这有助于查询性能优化和数据管理。</p> 
<p><span style="color:#fe2c24;"><strong>34-2-6、storage_options</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>用于配置存储选项的字典，如文件系统、认证信息等，这通常用于云存储服务(如AWS S3、Google Cloud Storage)或需要特殊配置的文件系统。</p> 
<p><span style="color:#fe2c24;"><strong>34-2-7、**kwargs</strong></span><span style="color:#956fe7;"><strong>(可选)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>其他关键字参数将传递给底层的Parquet引擎，这些参数依赖于所使用的引擎(pyarrow 或 fastparquet)，并允许对写入过程进行更详细的控制。</p> 
<h6 id="5-3%E3%80%81%E5%8A%9F%E8%83%BD">34-3、功能</h6> 
<p>        将Pandas DataFrame对象写入Parquet文件格式。</p> 
<h6 id="5-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC">34-4、返回值</h6> 
<p>34-4-1、如果提供了路径path参数，则to_parquet函数通常不会返回任何值(即返回值为None)，这是因为数据已经被写入到指定的Parquet文件中。</p> 
<p>34-4-2、如果没有提供路径参数，或者使用了类似io.BytesIO的对象作为路径，则函数会返回一个包含Parquet文件内容的字节流对象，这允许用户在不实际写入文件的情况下，将Parquet数据传输到其他系统或进行进一步处理。</p> 
<h6 id="5-5%E3%80%81%E8%AF%B4%E6%98%8E">34-5、说明</h6> 
<p>        Parquet是一种列式存储格式，特别适用于大规模数据集的高效存储和查询，相比于传统的行式存储格式，Parquet提供了更高的压缩率和更快的读取速度。</p> 
<h6 id="5-6%E3%80%81%E7%94%A8%E6%B3%95">34-6、用法</h6> 
<h6 id="10-6-1%E3%80%81%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87">34-6-1、数据准备</h6> 
<pre><code class="language-python">无</code></pre> 
<h6 id="5-6-1%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B">34-6-2、代码示例</h6> 
<pre><code class="language-python"># 34、pandas.DataFrame.to_parquet函数
import pandas as pd
# 创建一个示例DataFrame
data = {
    'Name': ['Alice', 'Bob', 'Charlie'],
    'Age': [25, 30, 35],
    'City': ['New York', 'Los Angeles', 'Chicago']
}
df = pd.DataFrame(data)
# 指定Parquet文件的保存路径
parquet_path = 'example.parquet'
# 使用to_parquet方法将DataFrame保存到Parquet文件
# 这里我们使用了默认的'snappy'压缩和'auto'引擎（通常会选择'pyarrow'如果已安装）
df.to_parquet(parquet_path, index=False)  # index=False 表示不将索引写入Parquet文件
# 注意：此时文件已经被保存到当前工作目录下的'example.parquet'文件中
# 你可以使用pandas.read_parquet来验证文件内容
# 读取Parquet文件以验证
read_back_df = pd.read_parquet(parquet_path)
print(read_back_df)</code></pre> 
<h6 id="5-6-2%E3%80%81%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA">34-6-3、结果输出</h6> 
<pre><code class="language-python"># 34、pandas.DataFrame.to_parquet函数
#       Name  Age         City
# 0    Alice   25     New York
# 1      Bob   30  Los Angeles
# 2  Charlie   35      Chicago</code></pre> 
<h5 id="11%E3%80%81pandas.ExcelFile%E7%B1%BB">35、<span style="color:#fe2c24;">pandas.read_sql_table</span>函数</h5> 
<h6 id="11-1%E3%80%81%E8%AF%AD%E6%B3%95">35-1、语法</h6> 
<pre><code class="language-python"># 35、pandas.read_sql_table函数
pandas.read_sql_table(table_name, con, schema=None, index_col=None, coerce_float=True, parse_dates=None, columns=None, chunksize=None, dtype_backend=_NoDefault.no_default)
Read SQL database table into a DataFrame.

Given a table name and a SQLAlchemy connectable, returns a DataFrame. This function does not support DBAPI connections.

Parameters:
table_namestr
Name of SQL table in database.

conSQLAlchemy connectable or str
A database URI could be provided as str. SQLite DBAPI connection mode not supported.

schemastr, default None
Name of SQL schema in database to query (if database flavor supports this). Uses default schema if None (default).

index_colstr or list of str, optional, default: None
Column(s) to set as index(MultiIndex).

coerce_floatbool, default True
Attempts to convert values of non-string, non-numeric objects (like decimal.Decimal) to floating point. Can result in loss of Precision.

parse_dateslist or dict, default None
List of column names to parse as dates.

Dict of {column_name: format string} where format string is strftime compatible in case of parsing string times or is one of (D, s, ns, ms, us) in case of parsing integer timestamps.

Dict of {column_name: arg dict}, where the arg dict corresponds to the keyword arguments of pandas.to_datetime() Especially useful with databases without native Datetime support, such as SQLite.

columnslist, default None
List of column names to select from SQL table.

chunksizeint, default None
If specified, returns an iterator where chunksize is the number of rows to include in each chunk.

dtype_backend{‘numpy_nullable’, ‘pyarrow’}, default ‘numpy_nullable’
Back-end data type applied to the resultant DataFrame (still experimental). Behaviour is as follows:

"numpy_nullable": returns nullable-dtype-backed DataFrame (default).

"pyarrow": returns pyarrow-backed nullable ArrowDtype DataFrame.

New in version 2.0.

Returns:
DataFrame or Iterator[DataFrame]
A SQL table is returned as two-dimensional data structure with labeled axes.</code></pre> 
<h6 id="11-2%E3%80%81%E5%8F%82%E6%95%B0">35-2、参数</h6> 
<p><span style="color:#fe2c24;"><strong>35-2-1、table_name</strong></span><span style="color:#956fe7;"><strong>(必须)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>要从数据库中读取的表的名称。</p> 
<p><span style="color:#fe2c24;"><strong>35-2-2、con</strong></span><span style="color:#956fe7;"><strong>(必须)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span><span style="color:#0d0016;">用于数据库连接的对象，通常是一个SQLAlchemy的engine对象。</span></p> 
<p><span style="color:#fe2c24;"><strong>35-2-3、schema</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>指定表的schema(模式)，在大多数SQL数据库中schema是用于组织数据库对象(如表、视图等)的命名空间，不是所有数据库都支持schema，MySQL默认不支持，而PostgreSQL支持。</p> 
<p><span style="color:#fe2c24;"><strong>35-2-4、index_col</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>将一列或多列作为返回的DataFrame的索引。默认情况下(None)，不设置索引。如果指定了单个列名，则将该列用作索引；如果指定了列名的列表，则将这些列用作多级索引。</p> 
<p><span style="color:#fe2c24;"><strong>35-2-5、coerce_float</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为True)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>尝试将非字符串、非数字对象转换为浮点数，如果设置为False，则不会进行这种转换。</p> 
<p><span style="color:#fe2c24;"><strong>35-2-6、parse_dates</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>指定要解析为日期时间类型的列，可以是一个列名的列表，也可以是一个字典，其中键是列名，值是要用于解析日期的格式字符串，如果设置为None(默认值)，则不解析任何列。</p> 
<p><span style="color:#fe2c24;"><strong>35-2-7、columns</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>指定要从表中读取的列名列表，如果为None(默认值)，则读取所有列。</p> 
<p><span style="color:#fe2c24;"><strong>35-2-8、chunksize</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>如果指定了，则返回一个迭代器，该迭代器每次产生指定大小的DataFrame块，这对于处理大型数据集非常有用，因为它允许你在不将所有数据一次性加载到内存中的情况下逐块处理数据。如果为None(默认值)，则一次性返回整个DataFrame。</p> 
<p><span style="color:#fe2c24;"><strong>35-2-9、dtype_backend</strong></span><span style="color:#956fe7;"><strong>(可选)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>内部调用，通常不需要用户直接设置。</p> 
<h6 id="11-3%E3%80%81%E5%8A%9F%E8%83%BD">35-3、功能</h6> 
<p>        从SQL数据库中读取指定的表，并将该表的数据加载到一个pandas DataFrame中。</p> 
<h6 id="11-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC">35-4、返回值</h6> 
<p>        返回值是一个pandas DataFrame，这个DataFrame包含了从指定SQL表中检索到的数据，并根据提供的参数进行了相应的转换和解析。</p> 
<h6 id="11-5%E3%80%81%E8%AF%B4%E6%98%8E">35-5、说明</h6> 
<p>        DataFrame是一个二维、大小可变的、潜在的异构表格数据结构，具有标记的轴(行和列)，它类似于Excel中的表格或SQL表，但更灵活，因为pandas提供了大量的数据处理和分析功能。</p> 
<h6 id="11-6%E3%80%81%E7%94%A8%E6%B3%95">35-6、用法</h6> 
<h6 id="11-6-1%E3%80%81%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87">35-6-1、数据准备</h6> 
<pre><code class="language-python"># 确保已经安装了sqlalchemy库
# 1、创建数据库表
from sqlalchemy import create_engine, Column, Integer, String, MetaData
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
# 数据库连接配置（使用 SQLAlchemy 的 URI 格式）
DATABASE_URI = 'mysql+pymysql://root:123456@127.0.0.1/test_database?charset=utf8mb4'
# 创建一个引擎实例
engine = create_engine(DATABASE_URI, echo=True)  # echo=True 用于显示生成的 SQL 语句，调试时可以打开
# 创建基类
Base = declarative_base()
# 定义模型类
class MyElsaTable(Base):
    __tablename__ = 'myelsa_table'
    name = Column(String(255), nullable=False)
    ID_Card = Column(String(255), primary_key=True)  # 设置为主键
    age = Column(Integer, nullable=False)
    city = Column(String(255), nullable=False)
# 创建表（如果表不存在）
Base.metadata.create_all(engine)
# 如果你想要使用 ORM 来进行操作，可以创建一个 session 类
Session = sessionmaker(bind=engine)
session = Session()
# 这里不需要执行 SQL 语句或提交更改，因为 create_all 方法会自动处理
# 关闭 session（如果需要的话，但在这种情况下我们并没有进行任何 ORM 操作）
# session.close()
print("Table myelsa_table created successfully!")

# 2、在数据库表中新增记录
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from sqlalchemy.exc import SQLAlchemyError
# 定义基类
Base = declarative_base()
# 定义数据库模型类
class MyElsaTable(Base):
    __tablename__ = 'myelsa_table'
    ID_Card = Column(String, primary_key=True)
    name = Column(String)
    age = Column(Integer)
    city = Column(String)
    def __repr__(self):
        return f"&lt;MyElsaTable(ID_Card={self.ID_Card}, name={self.name}, age={self.age}, city={self.city})&gt;"
# 数据库连接配置
config = {
    'username': 'root',  # 替换为你的MySQL用户名
    'password': '123456',  # 替换为你的MySQL密码
    'host': '127.0.0.1',  # 如果数据库在远程服务器上，请替换为相应的主机名或IP地址
    'database': 'test_database',  # 数据库名
}
# 创建数据库引擎
engine = create_engine(
    f'mysql+pymysql://{config["username"]}:{config["password"]}@{config["host"]}/{config["database"]}')
# 确保所有表都已创建（可选）
Base.metadata.create_all(engine)
# 创建会话类
Session = sessionmaker(bind=engine)
# 定义要插入的数据
new_record = {
    'name': 'Myelsa',
    'ID_Card': '443689564710526448',
    'age': 18,
    'city': 'Guangzhou'
}
try:
    # 使用上下文管理器自动管理会话
    with Session() as session:
        # 创建新的模型实例
        new_entry = MyElsaTable(**new_record)
        # 将新实例添加到会话中
        session.add(new_entry)
        # 提交更改
        session.commit()
        print("Record inserted successfully!")
except SQLAlchemyError as e:
    print(f"Error: '{e}'")
    # 在使用上下文管理器时，无需显式回滚，因为上下文管理器会在退出时处理它</code></pre> 
<h6 id="11-6-2%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B">35-6-2、代码示例</h6> 
<pre><code class="language-python"># 35、pandas.read_sql_table函数
import pandas as pd
from sqlalchemy import create_engine
# 数据库连接信息
username = 'root'
password = '123456'
host = '127.0.0.1'
port = 3306
database = 'test_database'
# 使用SQLAlchemy创建数据库引擎
# 注意：这里使用mysql+pymysql://作为前缀，如果你使用的是mysqlclient，则使用mysql+mysqldb://
# 根据你的MySQL版本和驱动，你可能需要调整这个前缀
engine = create_engine(f'mysql+pymysql://{username}:{password}@{host}:{port}/{database}')
# 调用read_sql_table函数
# 假设我们要读取的表名为'your_table_name'
table_name = 'myelsa_table'
df = pd.read_sql_table(table_name, con=engine, schema=None, index_col=None, coerce_float=True, parse_dates=None,
                       columns=None, chunksize=None)
# 显示DataFrame的前几行以验证数据
print(df.head())</code></pre> 
<h6 id="11-6-3%E3%80%81%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA%C2%A0">35-6-3、结果输出 </h6> 
<pre><code class="language-python"># 35、pandas.read_sql_table函数
#      name             ID_Card  age       city
# 0  Myelsa  443689564710526448   18  Guangzhou</code></pre> 
<h5 id="12%E3%80%81pandas.ExcelFile.parse%E5%87%BD%E6%95%B0">36、<span style="color:#fe2c24;">pandas.read_sql_query</span>函数</h5> 
<h6 id="12-1%E3%80%81%E8%AF%AD%E6%B3%95">36-1、语法</h6> 
<pre><code class="language-python"># 36、pandas.read_sql_query函数
pandas.read_sql_query(sql, con, index_col=None, coerce_float=True, params=None, parse_dates=None, chunksize=None, dtype=None, dtype_backend=_NoDefault.no_default)
Read SQL query into a DataFrame.

Returns a DataFrame corresponding to the result set of the query string. Optionally provide an index_col parameter to use one of the columns as the index, otherwise default integer index will be used.

Parameters:
sqlstr SQL query or SQLAlchemy Selectable (select or text object)
SQL query to be executed.

conSQLAlchemy connectable, str, or sqlite3 connection
Using SQLAlchemy makes it possible to use any DB supported by that library. If a DBAPI2 object, only sqlite3 is supported.

index_colstr or list of str, optional, default: None
Column(s) to set as index(MultiIndex).

coerce_floatbool, default True
Attempts to convert values of non-string, non-numeric objects (like decimal.Decimal) to floating point. Useful for SQL result sets.

paramslist, tuple or mapping, optional, default: None
List of parameters to pass to execute method. The syntax used to pass parameters is database driver dependent. Check your database driver documentation for which of the five syntax styles, described in PEP 249’s paramstyle, is supported. Eg. for psycopg2, uses %(name)s so use params={‘name’ : ‘value’}.

parse_dateslist or dict, default: None
List of column names to parse as dates.

Dict of {column_name: format string} where format string is strftime compatible in case of parsing string times, or is one of (D, s, ns, ms, us) in case of parsing integer timestamps.

Dict of {column_name: arg dict}, where the arg dict corresponds to the keyword arguments of pandas.to_datetime() Especially useful with databases without native Datetime support, such as SQLite.

chunksizeint, default None
If specified, return an iterator where chunksize is the number of rows to include in each chunk.

dtypeType name or dict of columns
Data type for data or columns. E.g. np.float64 or {‘a’: np.float64, ‘b’: np.int32, ‘c’: ‘Int64’}.

New in version 1.3.0.

dtype_backend{‘numpy_nullable’, ‘pyarrow’}, default ‘numpy_nullable’
Back-end data type applied to the resultant DataFrame (still experimental). Behaviour is as follows:

"numpy_nullable": returns nullable-dtype-backed DataFrame (default).

"pyarrow": returns pyarrow-backed nullable ArrowDtype DataFrame.

New in version 2.0.

Returns:
DataFrame or Iterator[DataFrame].</code></pre> 
<h6 id="12-2%E3%80%81%E5%8F%82%E6%95%B0">36-2、参数</h6> 
<p><span style="color:#fe2c24;"><strong>36-2-1、sql</strong></span><span style="color:#956fe7;"><strong>(必须)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>要执行的SQL查询语句，这个参数可以是一个字符串，包含要执行的SQL代码，或者是一个SQLAlchemy的Selectable对象(如一个表或查询)。</p> 
<p><span style="color:#fe2c24;"><strong>36-2-2、con</strong></span><span style="color:#956fe7;"><strong>(必须)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>用于执行SQL查询的数据库连接，这通常是一个SQLAlchemy的engine对象。</p> 
<p><span style="color:#fe2c24;"><strong>36-2-3、index_col</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>将一列或多列作为返回的DataFrame的索引，默认情况下(None)，不设置索引。如果指定了单个列名，则将该列用作索引；如果指定了列名的列表，则将这些列用作多级索引。</p> 
<p><span style="color:#fe2c24;"><strong>36-2-4、coerce_float</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为True)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>尝试将非字符串、非数字对象转换为浮点数，这有助于确保数字类型的一致性，但可能会引入精度损失。</p> 
<p><span style="color:#fe2c24;"><strong>36-2-5、params</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>一个列表、元组或字典，用于SQL查询中的参数替换，这有助于防止SQL注入攻击，并允许你安全地传递查询参数，如果提供了params，它们将在查询执行之前被替换到SQL字符串中的占位符中。</p> 
<p><span style="color:#fe2c24;"><strong>36-2-6、parse_dates</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>指定要解析为日期时间类型的列，可以是一个列名的列表，也可以是一个字典，其中键是列名，值是要用于解析日期的格式字符串，如果设置为None(默认值)，则不解析任何列。</p> 
<p><span style="color:#fe2c24;"><strong>36-2-7、chunksize</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>如果指定了，则返回一个迭代器，该迭代器每次产生指定大小的DataFrame块，这对于处理大型数据集非常有用，因为它允许你在不将所有数据一次性加载到内存中的情况下逐块处理数据，如果为None(默认值)，则一次性返回整个DataFrame。</p> 
<p><span style="color:#fe2c24;"><strong>36-2-8、dtype</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>一个字典，用于指定列的数据类型，这允许你覆盖SQLAlchemy或数据库推断的数据类型，键是列名，值是你希望该列具有的数据类型(如np.float64、str 等)。</p> 
<p><span style="color:#fe2c24;"><strong>36-2-9、dtype_backend</strong></span><span style="color:#956fe7;"><strong>(可选)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>内部调用，通常不需要用户直接设置。</p> 
<h6 id="12-3%E3%80%81%E5%8A%9F%E8%83%BD">36-3、功能</h6> 
<p>        用于从数据库中执行SQL查询并将查询结果直接加载到pandas的DataFrame中。</p> 
<h6 id="12-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC">36-4、返回值</h6> 
<p>        返回值是一个pandas DataFrame对象，该对象包含了SQL查询的结果，DataFrame是一个二维、大小可变的、潜在的异构表格数据结构，具有标记的轴(行和列)，非常类似于Excel中的表格或SQL表，返回的DataFrame可以直接用于进一步的数据分析和处理。</p> 
<h6 id="12-5%E3%80%81%E8%AF%B4%E6%98%8E">36-5、说明</h6> 
<p>        无</p> 
<h6 id="12-6%E3%80%81%E7%94%A8%E6%B3%95">36-6、用法</h6> 
<h6 id="12-6-1%E3%80%81%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87">36-6-1、数据准备</h6> 
<pre><code class="language-python"># 确保已经安装了sqlalchemy库
# 1、创建数据库表
from sqlalchemy import create_engine, Column, Integer, String, MetaData
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
# 数据库连接配置（使用 SQLAlchemy 的 URI 格式）
DATABASE_URI = 'mysql+pymysql://root:123456@127.0.0.1/test_database?charset=utf8mb4'
# 创建一个引擎实例
engine = create_engine(DATABASE_URI, echo=True)  # echo=True 用于显示生成的 SQL 语句，调试时可以打开
# 创建基类
Base = declarative_base()
# 定义模型类
class MyElsaTable(Base):
    __tablename__ = 'myelsa_table'
    name = Column(String(255), nullable=False)
    ID_Card = Column(String(255), primary_key=True)  # 设置为主键
    age = Column(Integer, nullable=False)
    city = Column(String(255), nullable=False)
# 创建表（如果表不存在）
Base.metadata.create_all(engine)
# 如果你想要使用 ORM 来进行操作，可以创建一个 session 类
Session = sessionmaker(bind=engine)
session = Session()
# 这里不需要执行 SQL 语句或提交更改，因为 create_all 方法会自动处理
# 关闭 session（如果需要的话，但在这种情况下我们并没有进行任何 ORM 操作）
# session.close()
print("Table myelsa_table created successfully!")

# 2、在数据库表中新增记录
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from sqlalchemy.exc import SQLAlchemyError
# 定义基类
Base = declarative_base()
# 定义数据库模型类
class MyElsaTable(Base):
    __tablename__ = 'myelsa_table'
    ID_Card = Column(String, primary_key=True)
    name = Column(String)
    age = Column(Integer)
    city = Column(String)
    def __repr__(self):
        return f"&lt;MyElsaTable(ID_Card={self.ID_Card}, name={self.name}, age={self.age}, city={self.city})&gt;"
# 数据库连接配置
config = {
    'username': 'root',  # 替换为你的MySQL用户名
    'password': '123456',  # 替换为你的MySQL密码
    'host': '127.0.0.1',  # 如果数据库在远程服务器上，请替换为相应的主机名或IP地址
    'database': 'test_database',  # 数据库名
}
# 创建数据库引擎
engine = create_engine(
    f'mysql+pymysql://{config["username"]}:{config["password"]}@{config["host"]}/{config["database"]}')
# 确保所有表都已创建（可选）
Base.metadata.create_all(engine)
# 创建会话类
Session = sessionmaker(bind=engine)
# 定义要插入的数据
new_record = {
    'name': 'Lucy',
    'ID_Card': '443689564710526449',
    'age': 28,
    'city': 'Shenzhen'
}
try:
    # 使用上下文管理器自动管理会话
    with Session() as session:
        # 创建新的模型实例
        new_entry = MyElsaTable(**new_record)
        # 将新实例添加到会话中
        session.add(new_entry)
        # 提交更改
        session.commit()
        print("Record inserted successfully!")
except SQLAlchemyError as e:
    print(f"Error: '{e}'")
    # 在使用上下文管理器时，无需显式回滚，因为上下文管理器会在退出时处理它</code></pre> 
<h6 id="12-6-2%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B">36-6-2、代码示例</h6> 
<pre><code class="language-python"># 36、pandas.read_sql_query函数
import pandas as pd
from sqlalchemy import create_engine
# 数据库连接信息
username = 'root'
password = '123456'
host = '127.0.0.1'
port = 3306
database = 'test_database'
# 使用 SQLAlchemy 创建数据库引擎
# 注意：这里使用 mysql+pymysql:// 作为前缀，如果你使用的是 mysqlclient，则使用 mysql+mysqldb://
engine = create_engine(f'mysql+pymysql://{username}:{password}@{host}:{port}/{database}')
# SQL 查询语句
sql_query = """  
SELECT name, ID_Card, age, city  
FROM myelsa_table  
WHERE age &gt; 18  
ORDER BY city DESC  
LIMIT 100;  
"""
# 使用read_sql_query执行查询并加载数据到DataFrame
df = pd.read_sql_query(sql_query, con=engine, index_col='ID_Card', coerce_float=True, parse_dates=['city'])
# 显示 DataFrame 的前几行以验证数据
print(df.head())</code></pre> 
<h6 id="12-6-3%E3%80%81%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA%C2%A0">36-6-3、结果输出 </h6> 
<pre><code class="language-python"># 36、pandas.read_sql_query函数
#                     name  age city
# ID_Card                           
# 443689564710526449  Lucy   28  NaT</code></pre> 
<h4 id="%E4%BA%94%E3%80%81%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB">二、推荐阅读</h4> 
<h5 id="1%E3%80%81">1、<a href="https://myelsa1024.blog.csdn.net/article/details/139241094?spm=1001.2014.3001.5502" rel="nofollow" title="Python筑基之旅">Python筑基之旅</a></h5> 
<h5 id="2%E3%80%81">2、<a href="https://myelsa1024.blog.csdn.net/article/details/138916144?spm=1001.2014.3001.5502" rel="nofollow" title="Python函数之旅">Python函数之旅</a></h5> 
<h5 id="3%E3%80%81">3、<a href="https://blog.csdn.net/ygb_1024/article/details/136889623?spm=1001.2014.3001.5501" title="Python算法之旅">Python算法之旅</a></h5> 
<h5 id="4%E3%80%81">4、<a href="https://myelsa1024.blog.csdn.net/article/details/139555733" rel="nofollow" title="Python魔法之旅">Python魔法之旅</a></h5> 
<h5 id="5%E3%80%81%C2%A0">5、<a href="https://blog.csdn.net/ygb_1024?spm=1010.2135.3001.5421" title="博客个人主页">博客个人主页</a></h5>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5afc0b436b6137399063d56bfd96a2d0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【从零开始实现stm32无刷电机FOC】【理论】【3/6 位置、速度、电流控制】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/36b78b8d03c81cc1a5c92567feba401c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java 中的阻塞 IO 和非阻塞 IO</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>