<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构之初始二叉树（2） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/d3bbeb21c3dec086fdca6b3de9bd3916/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构之初始二叉树（2）">
  <meta property="og:description" content="找往期文章包括但不限于本期文章中不懂的知识点：
个人主页：我要学编程(ಥ_ಥ)-CSDN博客
所属专栏：数据结构（Java版）
二叉树的前置知识（概念、性质、、遍历）
通过上篇文章的学习，我们已经知道什么是二叉树，以及其性质和遍历的方式了。接下来主要是实现代码。
目录
伪创建二叉树
遍历二叉树 获取二叉树中节点的个数 获取二叉树中叶子节点的个数
获取二叉树中第K层节点的个数
获取二叉树的高度 在二叉树中找寻元素 伪创建二叉树 为啥叫伪创建二叉树呢？因为我们现在才刚开始学习二叉树，而创建二叉树是一个非常复杂的过程（树的递归定义的）。因此我们就先手动的来创建二叉树。树是有一个一个的结点组成，因此得先把结点创建出来。树的结点我们采用的是简单的孩子表示法：
// 树的结点 static class TreeNode { public char val; // 数据域 public TreeNode left; // 左子树 public TreeNode right; // 右子树 public TreeNode(char val) { this.val = val; } } 创建的二叉树图形如下：
public TreeNode createBinaryTree() { TreeNode A = new TreeNode(&#39;A&#39;); TreeNode B = new TreeNode(&#39;B&#39;); TreeNode C = new TreeNode(&#39;C&#39;); TreeNode D = new TreeNode(&#39;D&#39;); TreeNode E = new TreeNode(&#39;E&#39;); TreeNode F = new TreeNode(&#39;F&#39;); TreeNode G = new TreeNode(&#39;G&#39;); // 根据图形关系把结点之间相连 A.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-15T16:25:37+08:00">
    <meta property="article:modified_time" content="2024-07-15T16:25:37+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构之初始二叉树（2）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>找往期文章包括但不限于本期文章中不懂的知识点：</p> 
<blockquote> 
 <p><strong>个人主页：</strong><a href="https://blog.csdn.net/2301_80854132?type=blog" title="我要学编程(ಥ_ಥ)-CSDN博客">我要学编程(ಥ_ಥ)-CSDN博客</a></p> 
 <p><strong>所属专栏：<strong><a href="https://blog.csdn.net/2301_80854132/category_12650676.html" title="数据结构（Java版）">数据结构（Java版）</a></strong></strong></p> 
</blockquote> 
<p><a class="link-info" href="https://blog.csdn.net/2301_80854132/article/details/139805660?spm=1001.2014.3001.5502" title="二叉树的前置知识（概念、性质、、遍历）">二叉树的前置知识（概念、性质、、遍历）</a></p> 
<p>通过上篇文章的学习，我们已经知道什么是二叉树，以及其性质和遍历的方式了。接下来主要是实现代码。</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%BC%AA%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:0px;"><a href="#%E4%BC%AA%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">伪创建二叉树</a></p> 
<p id="%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%C2%A0-toc" style="margin-left:0px;"><a href="#%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%C2%A0" rel="nofollow">遍历二叉树 </a></p> 
<p id="%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%AA%E6%95%B0%C2%A0-toc" style="margin-left:0px;"><a href="#%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%AA%E6%95%B0%C2%A0" rel="nofollow">获取二叉树中节点的个数 </a></p> 
<p id="%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%AA%E6%95%B0-toc" style="margin-left:0px;"><a href="#%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%AA%E6%95%B0" rel="nofollow">获取二叉树中叶子节点的个数</a></p> 
<p id="%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B1%82%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%AA%E6%95%B0-toc" style="margin-left:0px;"><a href="#%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B1%82%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%AA%E6%95%B0" rel="nofollow">获取二叉树中第K层节点的个数</a></p> 
<p id="%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6%C2%A0-toc" style="margin-left:0px;"><a href="#%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6%C2%A0" rel="nofollow">获取二叉树的高度 </a></p> 
<p id="%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%AF%BB%E5%85%83%E7%B4%A0%C2%A0-toc" style="margin-left:0px;"><a href="#%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%AF%BB%E5%85%83%E7%B4%A0%C2%A0" rel="nofollow">在二叉树中找寻元素 </a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%BC%AA%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91" style="background-color:transparent;"><span style="color:#fe2c24;">伪创建二叉树</span></h2> 
<p>为啥叫伪创建二叉树呢？因为我们现在才刚开始学习二叉树，而创建二叉树是一个非常复杂的过程（树的递归定义的）。因此我们就先手动的来创建二叉树。树是有一个一个的结点组成，因此得先把结点创建出来。树的结点我们采用的是简单的孩子表示法：</p> 
<pre><code class="language-java">    // 树的结点
    static class TreeNode {
        public char val; // 数据域
        public TreeNode left; // 左子树
        public TreeNode right; // 右子树

        public TreeNode(char val) {
            this.val = val;
        }
    }</code></pre> 
<p>创建的二叉树图形如下：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c3/3a/bNoAKOfk_o.png"></p> 
<pre><code class="language-java">    public TreeNode createBinaryTree() {
        TreeNode A = new TreeNode('A');
        TreeNode B = new TreeNode('B');
        TreeNode C = new TreeNode('C');
        TreeNode D = new TreeNode('D');
        TreeNode E = new TreeNode('E');
        TreeNode F = new TreeNode('F');
        TreeNode G = new TreeNode('G');
        // 根据图形关系把结点之间相连
        A.left = B;
        A.right = C;
        B.left = D;
        B.right = E;
        C.left = F;
        C.right = G;
        // 返回根结点
        return A;
    }</code></pre> 
<h2 id="%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%C2%A0" style="background-color:transparent;"><span style="color:#fe2c24;">遍历二叉树</span> </h2> 
<p>二叉树创建完成后，我们就可以遍历打印二叉树，看看是否符合我们的预期结果。遍历的四种方式，我们前面也学习了。</p> 
<p>前序遍历： </p> 
<pre><code class="language-java">    // 前序遍历
    public void preOrder(TreeNode root) {
        if (root == null) {
            return;
        }
        // 打印根结点的值
        System.out.print(root.val+" ");
        // 递归遍历根的左子树
        preOrder(root.left);
        // 递归遍历根的右子树
        preOrder(root.right);
    }</code></pre> 
<p>递归的限制条件：当递归到 root 为 null 时，就开始回退。随着递归的深入，root 不断的接近 null。</p> 
<p>中序遍历：</p> 
<pre><code class="language-java">    // 中序遍历
    public void inOrder(TreeNode root) {
        // 中序遍历：左子树-&gt;根-&gt;右子树
        if (root == null) {
            return;
        }
        // 递归遍历根的左子树
        inOrder(root.left);
        // 打印根结点的值
        System.out.print(root.val+" ");
        // 递归遍历根的右子树
        inOrder(root.right);
    }</code></pre> 
<p>后序遍历：</p> 
<pre><code class="language-java">    // 后序遍历
    public void postOrder(TreeNode root) {
        // 后序遍历：左子树-&gt;右子树-&gt;根
        if (root == null) {
            return;
        }
        // 递归遍历根的左子树
        postOrder(root.left);
        // 递归遍历根的右子树
        postOrder(root.right);
        // 打印根结点的值
        System.out.print(root.val+" ");
    }</code></pre> 
<p>由于层序遍历还是比较复杂，因此我们后面再学习。</p> 
<h2 id="%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%AA%E6%95%B0%C2%A0"><span style="color:#fe2c24;">获取二叉树中节点的个数 </span></h2> 
<p>思路一：这个同样是遍历二叉树，遇到不为空的结点就++，最后统计的就是树的节点个数。</p> 
<pre><code class="language-java">    // 记录节点个数
    public int treeNodeSize; 
    public void size(TreeNode root) {
        if (root == null) {
            return;
        }
        // 根结点
        treeNodeSize++;
        // 左子树
        size2(root.left);
        // 右子树
        size2(root.right);
    }</code></pre> 
<p>思路二：整棵树的节点个数等于 根结点+左子树的节点个数+右子树的节点个数</p> 
<pre><code class="language-java">    // 获取树中节点的个数
    public int size(TreeNode root) {
        if (root == null) {
            return 0;
        }
        // 左子树的节点个数+右子树的节点个数+根结点
        return size(root.left)+size(root.right)+1;
    }</code></pre> 
<p>思路一采用的是遍历的方式，思路二采用的是化为子问题的方式。思路二也是更加接近递归的方式。</p> 
<h2 id="%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%AA%E6%95%B0"><span style="color:#fe2c24;">获取二叉树中叶子节点的个数</span></h2> 
<p>思路：首先，我们得知道什么是叶子节点。叶子结点的特点是其左孩子和右孩子都是null。同样这也是采用遍历的方式。</p> 
<p>法一：采用子问题思路</p> 
<pre><code class="language-java">    // 获取叶子节点的个数
    public int getLeafNodeCount(TreeNode root) {
        if (root == null) {
            return 0;
        }
        // 遇到叶子结点就返回1
        if (root.left == null &amp;&amp; root.right == null) {
            return 1;
        }
        // 返回左子树的叶子节点个数+右子树的叶子节点个数
        return getLeafNodeCount(root.left) + getLeafNodeCount(root.right);
    }</code></pre> 
<p>法二：采用遍历思路</p> 
<pre><code class="language-java">    public int leafSize;
    public void getLeafNodeCount(TreeNode root) {
        if (root == null) {
            return;
        }
        if (root.left == null &amp;&amp; root.right == null) {
            leafSize++;
        }
        // 遍历左子谁
        getLeafNodeCount2(root.left);
        // 遍历右子树
        getLeafNodeCount2(root.right);
    }</code></pre> 
<h2 id="%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B1%82%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%AA%E6%95%B0"><span style="color:#fe2c24;">获取二叉树中第K层节点的个数</span></h2> 
<p><img alt="" height="647" src="https://images2.imgbox.com/97/ff/LRN5F03l_o.png" width="1200"></p> 
<p>上面是对于第K层的介绍，根结点是作为第一层。 </p> 
<p>思路：当K为1时，就可以直接返回这一层的节点个数即可。因此我们就是要递归到K不断的接近1.</p> 
<p>法一： 采用子问题思路</p> 
<pre><code class="language-java">    // 获取第K层节点的个数
    public int getKLevelNodeCount(TreeNode root, int k) {
        // 假定不存在K无效的情况
        if (root == null) {
            return 0;
        }
        if (k == 1) {
            return 1;
        }
        // 左子树的第k-1层的节点个数+右子树的第k-1层的节点个数
        return getKLevelNodeCount(root.left, k-1) +
                getKLevelNodeCount(root.right, k-1);
    }</code></pre> 
<p>法二： 采用遍历思路</p> 
<pre><code class="language-java">    public int getLevelNodeSize;
    public void getKLevelNodeCount(TreeNode root, int k) {
        // 假定不存在K无效的情况
        if (root == null) {
            return;
        }
        if (k == 1) {
            getLevelNodeSize++;
        }
        // 遍历左子树的第k-1层
        getKLevelNodeCount2(root.left, k-1);
        // 遍历右子树的第k-1层
        getKLevelNodeCount2(root.right, k-1);
    }</code></pre> 
<h2 id="%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6%C2%A0"><span style="color:#fe2c24;">获取二叉树的高度</span> </h2> 
<p>思路：获取二叉树的高度和求第K层节点的个数类似。同样根结点算高度为1。接着就是分别递归计算左子树和右子树的高度的最大值。</p> 
<p>采用子问题思路</p> 
<pre><code class="language-java">    // 获取二叉树的高度
    public int getHeight(TreeNode root) {
        if (root == null) {
            return 0;
        }
        // 左子树与右子树的最大高度+根结点
        return Math.max(getHeight(root.left), getHeight(root.right)) + 1;
    }</code></pre> 
<p>这个如果不采用子问题思路，而是用遍历思路的话，只能用层序遍历来写，又因为层序遍历过于复杂，因此我们暂时先不写这个代码。</p> 
<h2 id="%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%AF%BB%E5%85%83%E7%B4%A0%C2%A0"><span style="color:#fe2c24;">在二叉树中找寻元素 </span></h2> 
<p> 思路：这个比较简单，就是遍历去比较即可。</p> 
<pre><code class="language-java">    // 检测值为value的元素是否存在
    public TreeNode find(TreeNode root, int val) {
        if (root == null) {
            return null;
        }
        // 采用前序遍历的方式：根-&gt;左子树-&gt;右子树
        // 根
        if (root.val == val) {
            return root;
        }
        // 在左子树中寻找，肯定有一个结果
        TreeNode findLeft = find(root.left, val);
        // 如果不为null，则说明找到了
        if (findLeft != null) {
            return findLeft;
        }
        // 在右子树中寻找，肯定有一个结果，不管结果如何直接返回即可
        return find(root.right, val);
    }</code></pre> 
<p>注意：这里在寻找二叉树中的节点时，采用前序遍历的方式是最有效率的。因为前序遍历是首先比较根结点，而我们就是需要比较根结点。 </p> 
<p>对于二叉树的基本操作我们就已经学习完了。基于上述基本操作就可以进行一些简单的刷题了，后续也会在刷题中继续完善二叉树的相关操作。</p> 
<p>好啦！本期 数据结构之初始二叉树（2）的学习之旅就到此结束啦！我们下一期再一起学习吧！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1b734a5bfaa8e67e465bcb6395be71b1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue检测页面手指滑动距离，执行回调函数，使用混入的语法，多个组件都可以使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d523971b244f5236c73d795f225ad4d3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">塑胶件缺胶影响工业生产，云盘科技提供解决方案！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>