<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构之循环队列 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/623735739ca20d3ca93427621b7c8d8c/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构之循环队列">
  <meta property="og:description" content="个人主页：星纭-CSDN博客
系列文章专栏：数据结构
踏上取经路，比抵达灵山更重要！一起努力一起进步！
目录
一.循环队列
1.循环队列的介绍 2.循环队列的实现
这个循环队列的结构体怎么完成？
rear指针的实际意义
那么如何解决判满判空呢?
如何让队列循环起来？
3.代码
1.myCircularQueueCreate()函数
2.判满判空函数
3.插入删除函数
4.查看队首队尾元素
5.释放函数
一.循环队列 1.循环队列的介绍 循环队列是一种特殊的队列数据结构，它可以在固定大小的数组中实现队列的功能。
如果使用数组完成队列的话，是会存在空间浪费的问题的。比如：
在完成插入数据之后，我们在出数据的时候，为了效率，是不会将后面的数据往前移动一个位置的，而是直接让front指针&#43;1.那么数组下标为0的位置的数据就不在队列中了，可是这样是有个问题的，这个空间浪费了，不属于这个队列了。如果我们继续插入数据。
当在存储3个数据之后，此时的数组就用完了。而且随着数据不断删除，这个队列能存储的数据将会越来越少。那么应该怎么解决这个问题呢？
前面浪费的空间也可以利用起来，如果要再插入数据就将这个数据放入下标为0的位置上去，此时的队列才是真正的满了。
如果这样实现队列，就解决了数组实现队列空间浪费的问题。
2.循环队列的实现 typedef struct { } MyCircularQueue; //设置队列，队列长度为k MyCircularQueue* myCircularQueueCreate(int k); bool myCircularQueueEnQueue(MyCircularQueue* obj, int value); bool myCircularQueueDeQueue(MyCircularQueue* obj); //获取队首，队尾元素 int myCircularQueueFront(MyCircularQueue* obj); int myCircularQueueRear(MyCircularQueue* obj); //判空判满 bool myCircularQueueIsEmpty(MyCircularQueue* obj); bool myCircularQueueIsFull(MyCircularQueue* obj); //释放 void myCircularQueueFree(MyCircularQueue* obj); 这个循环队列的结构体怎么完成？ 首先一个指向数组的指针肯定需要有，然后就是两个指针front，rear分别代表头指针与尾指针。
其实还需要一个k来表示这个数组的大小。（原因文章后面解释）
rear指针的实际意义 假设此时循环队列为空，将front和rear都指向0这个下标。
此时因为循环队列没有数据，rear 指向的就是队尾元素的下一个位置。
如果要使rear指针指向队尾元素，那么rear起始就应该指向-1如果插入一个元素后加1，rear就是0，指向队尾元素。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-20T12:00:00+08:00">
    <meta property="article:modified_time" content="2024-05-20T12:00:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构之循环队列</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/97/e4/9qESIau0_o.gif"></p> 
<p style="text-align:center;"><strong>个人主页：<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><a href="https://blog.csdn.net/CNDS_lili?spm=1011.2266.3001.5343" title="星纭-CSDN博客">星纭-CSDN博客</a></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p> 
<p style="text-align:center;"><strong>系列文章专栏：<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><a href="http://t.csdnimg.cn/bzodE" rel="nofollow" title="数据结构">数据结构</a></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p> 
<p style="text-align:center;"><strong>踏上取经路，比抵达灵山更重要！一起努力一起进步！</strong></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80.%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97-toc" style="margin-left:0px;"><a href="#%E4%B8%80.%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97" rel="nofollow">一.循环队列</a></p> 
<p id="1.%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BB%8B%E7%BB%8D%C2%A0-toc" style="margin-left:40px;"><a href="#1.%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BB%8B%E7%BB%8D%C2%A0" rel="nofollow">1.循环队列的介绍 </a></p> 
<p id="2.%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#2.%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">2.循环队列的实现</a></p> 
<p id="%E8%BF%99%E4%B8%AA%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E6%80%8E%E4%B9%88%E5%AE%8C%E6%88%90%EF%BC%9F-toc" style="margin-left:80px;"><a href="#%E8%BF%99%E4%B8%AA%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E6%80%8E%E4%B9%88%E5%AE%8C%E6%88%90%EF%BC%9F" rel="nofollow">这个循环队列的结构体怎么完成？</a></p> 
<p id="%C2%A0rear%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%9E%E9%99%85%E6%84%8F%E4%B9%89-toc" style="margin-left:80px;"><a href="#%C2%A0rear%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%9E%E9%99%85%E6%84%8F%E4%B9%89" rel="nofollow"> rear指针的实际意义</a></p> 
<p id="%E9%82%A3%E4%B9%88%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%88%A4%E6%BB%A1%E5%88%A4%E7%A9%BA%E5%91%A2%3F-toc" style="margin-left:80px;"><a href="#%E9%82%A3%E4%B9%88%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%88%A4%E6%BB%A1%E5%88%A4%E7%A9%BA%E5%91%A2%3F" rel="nofollow">那么如何解决判满判空呢?</a></p> 
<p id="%C2%A0%E5%A6%82%E4%BD%95%E8%AE%A9%E9%98%9F%E5%88%97%E5%BE%AA%E7%8E%AF%E8%B5%B7%E6%9D%A5%EF%BC%9F-toc" style="margin-left:80px;"><a href="#%C2%A0%E5%A6%82%E4%BD%95%E8%AE%A9%E9%98%9F%E5%88%97%E5%BE%AA%E7%8E%AF%E8%B5%B7%E6%9D%A5%EF%BC%9F" rel="nofollow"> 如何让队列循环起来？</a></p> 
<p id="3.%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#3.%E4%BB%A3%E7%A0%81" rel="nofollow">3.代码</a></p> 
<p id="1.myCircularQueueCreate()%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#1.myCircularQueueCreate%28%29%E5%87%BD%E6%95%B0" rel="nofollow">1.myCircularQueueCreate()函数</a></p> 
<p id="2.%E5%88%A4%E6%BB%A1%E5%88%A4%E7%A9%BA%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#2.%E5%88%A4%E6%BB%A1%E5%88%A4%E7%A9%BA%E5%87%BD%E6%95%B0" rel="nofollow">2.判满判空函数</a></p> 
<p id="3.%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#3.%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E5%87%BD%E6%95%B0" rel="nofollow">3.插入删除函数</a></p> 
<p id="4.%E6%9F%A5%E7%9C%8B%E9%98%9F%E9%A6%96%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0-toc" style="margin-left:80px;"><a href="#4.%E6%9F%A5%E7%9C%8B%E9%98%9F%E9%A6%96%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0" rel="nofollow">4.查看队首队尾元素</a></p> 
<p id="5.%E9%87%8A%E6%94%BE%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#5.%E9%87%8A%E6%94%BE%E5%87%BD%E6%95%B0" rel="nofollow">5.释放函数</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80.%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97">一.<a class="link-info" href="https://leetcode.cn/problems/design-circular-queue/" rel="nofollow" title="循环队列">循环队列</a></h2> 
<h3 id="1.%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BB%8B%E7%BB%8D%C2%A0">1.循环队列的介绍 </h3> 
<p>循环队列是一种特殊的队列数据结构，它可以在固定大小的数组中实现队列的功能。</p> 
<p>如果使用数组完成队列的话，是会存在空间浪费的问题的。比如：</p> 
<p class="img-center"><img alt="" height="432" src="https://images2.imgbox.com/ce/01/1WyoBblO_o.png" width="700"></p> 
<p>在完成插入数据之后，我们在出数据的时候，为了效率，是不会将后面的数据往前移动一个位置的，而是直接让front指针+1.那么数组下标为0的位置的数据就不在队列中了，可是这样是有个问题的，这个空间浪费了，不属于这个队列了。如果我们继续插入数据。</p> 
<p class="img-center"><img alt="" height="281" src="https://images2.imgbox.com/b3/b7/BwyeMoNE_o.png" width="700"></p> 
<p>当在存储3个数据之后，此时的数组就用完了。而且随着数据不断删除，这个队列能存储的数据将会越来越少。那么应该怎么解决这个问题呢？</p> 
<p>前面浪费的空间也可以利用起来，如果要再插入数据就将这个数据放入下标为0的位置上去，此时的队列才是真正的满了。</p> 
<p>如果这样实现队列，就解决了数组实现队列空间浪费的问题。</p> 
<p></p> 
<p class="img-center"><img alt="" height="146" src="https://images2.imgbox.com/c2/07/QUc2VPfY_o.png" width="700"></p> 
<h3 id="2.%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0">2.循环队列的实现</h3> 
<pre><code class="language-cpp">typedef struct {
} MyCircularQueue;

//设置队列，队列长度为k
MyCircularQueue* myCircularQueueCreate(int k);

bool myCircularQueueEnQueue(MyCircularQueue* obj, int value);
bool myCircularQueueDeQueue(MyCircularQueue* obj);

//获取队首，队尾元素
int myCircularQueueFront(MyCircularQueue* obj);
int myCircularQueueRear(MyCircularQueue* obj);

//判空判满
bool myCircularQueueIsEmpty(MyCircularQueue* obj);
bool myCircularQueueIsFull(MyCircularQueue* obj);

//释放
void myCircularQueueFree(MyCircularQueue* obj);</code></pre> 
<h4 id="%E8%BF%99%E4%B8%AA%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E6%80%8E%E4%B9%88%E5%AE%8C%E6%88%90%EF%BC%9F">这个循环队列的结构体怎么完成？</h4> 
<p>首先一个指向数组的指针肯定需要有，然后就是两个指针front，rear分别代表头指针与尾指针。</p> 
<p>其实还需要一个k来表示这个数组的大小。（原因文章后面解释）</p> 
<h4 id="%C2%A0rear%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%9E%E9%99%85%E6%84%8F%E4%B9%89"> rear指针的实际意义</h4> 
<p class="img-center"><img alt="" height="176" src="https://images2.imgbox.com/15/31/DU2e8DkH_o.png" width="700"></p> 
<p>假设此时循环队列为空，将front和rear都指向0这个下标。</p> 
<p>此时因为循环队列没有数据，rear 指向的就是队尾元素的下一个位置。</p> 
<p class="img-center"><img alt="" height="208" src="https://images2.imgbox.com/ec/12/UMcik6JW_o.png" width="700"></p> 
<p>如果要使rear指针指向队尾元素，那么rear起始就应该指向-1如果插入一个元素后加1，rear就是0，指向队尾元素。</p> 
<p>这两者有什么区别呢？</p> 
<p></p> 
<p class="img-center"><img alt="" height="382" src="https://images2.imgbox.com/e5/93/hsPowDGP_o.png" width="700"></p> 
<p>其实没什么区别。但是不论什么情况都会有一个问题。</p> 
<p>什么时候队列为空，什么时候队列为满？</p> 
<p>如上图所示，当队列为满的时候，这两种情况下，rear指针和front指针的位置。</p> 
<p>不难发现，当队列为空的时候，位置也是一样的。</p> 
<p class="img-center"><img alt="" height="420" src="https://images2.imgbox.com/50/df/ALZdRrg1_o.png" width="700"></p> 
<p>所以无论，rear表示什么意义，在判满的时候都会遇到这样的问题。</p> 
<h4 id="%E9%82%A3%E4%B9%88%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%88%A4%E6%BB%A1%E5%88%A4%E7%A9%BA%E5%91%A2%3F">那么如何解决判满判空呢?</h4> 
<p>方法一：使用size记录放入数据的个数</p> 
<p>使用这样的方式会很容易解决这个问题？此时判断满与空，就不需要看这个front与rear指针的位置了。</p> 
<p>当size等于k的时候这个队列就满了，当size等于0的时候这个队列就是空。</p> 
<p>缺点：多创建了一个变量。</p> 
<p>方法二：在开辟数组的时候，可以多开辟一个空间，不用来存放数据。</p> 
<p>使rear表示队尾元素的下一个位置，并且对开辟一个空间不用来存放数据。</p> 
<p>队列满的情形： </p> 
<p><img alt="" height="366" src="https://images2.imgbox.com/b3/dd/Vj5thrwP_o.png" width="700"></p> 
<p>队列为空的情形：</p> 
<p class="img-center"><img alt="" height="190" src="https://images2.imgbox.com/57/53/9YbaWOxr_o.png" width="700"></p> 
<p>此时不难发现，空与满的时候，front指针与rear指针的位置就没有相同了。</p> 
<h4 id="%C2%A0%E5%A6%82%E4%BD%95%E8%AE%A9%E9%98%9F%E5%88%97%E5%BE%AA%E7%8E%AF%E8%B5%B7%E6%9D%A5%EF%BC%9F"> 如何让队列循环起来？</h4> 
<p> 观察这种情况</p> 
<p class="img-center"><img alt="" height="205" src="https://images2.imgbox.com/6a/7e/HAuzIdII_o.png" width="700"></p> 
<p>如果还要继续放入数据，那么rear的值就要从5变成0.可是在这之前插入数据都是+1即可，那么如何在数组末尾的时候，让rear指针从5变成0呢？</p> 
<p>解决这样的问题，有多种方法，最简单的就是判断以下当rear == 5的时候，再插入数据，rear就变成0即可。</p> 
<p>常用方法就是：使用取模运算符。</p> 
<blockquote> 
 <p style="text-align:center;"><strong>rear = (rear + 1) % 6</strong></p> 
 <p style="text-align:center;"><strong>k + 1 = 5 + 1 = 6,这里的6实际就是数组的大小</strong></p> 
</blockquote> 
<p>同理当front指针，在数组末尾的时候，还要进行出数据就也是f = ( + 1) % k;</p> 
<p>这也是为什么我们要在开头的时候，为啥要在队列的结构体中存放一个数据k在表示这个数组的大小 + 1，其实因为此时浪费了一个空间，所以实际上k应该是等于5的，表示实际上队列能存储的最多数据的个数。</p> 
<h3 id="3.%E4%BB%A3%E7%A0%81">3.代码</h3> 
<h4 id="1.myCircularQueueCreate()%E5%87%BD%E6%95%B0">1.myCircularQueueCreate()函数</h4> 
<pre><code class="language-cpp">typedef int CQueueDatatype;
typedef struct {
	CQueueDatatype* a;//数组
	int front;//头指针，指向第一个元素
	int rear;//尾指针，指向队尾元素的下一个位置
	int k;//队列满时的数据个数
} MyCircularQueue;

MyCircularQueue* myCircularQueueCreate(int k) {
	MyCircularQueue* CQ = (MyCircularQueue*)malloc(sizeof(MyCircularQueue));
	CQ-&gt;a = (CQueueDatatype*)malloc(sizeof(CQueueDatatype) * (k + 1));
	CQ-&gt;front = CQ-&gt;rear = 0;
	CQ-&gt;k = k;
	return CQ;
}</code></pre> 
<p>根据题目要求得知，函数参数中的k表示的队列的长度，因为要多开辟一个空间，所以在实际上这个数组的长度是k + 1.</p> 
<h4 id="2.%E5%88%A4%E6%BB%A1%E5%88%A4%E7%A9%BA%E5%87%BD%E6%95%B0">2.判满判空函数</h4> 
<p class="img-center"><img alt="" height="365" src="https://images2.imgbox.com/ae/32/QT1UTEPc_o.png" width="700"></p> 
<p>根据前面的分析，知道队列满的时候是有两种情况的。</p> 
<p>第一种就是rear + 1 = front</p> 
<p>第二种就是rear - 5 = front.</p> 
<p>需要分类讨论吗？</p> 
<p>其实是不需要的，根据数学运算不难发现 当 front  = (rear + 1) % (k + 1).的时候此时就满了，结合了两种情况，读者可以自行带入数据进行尝试，这里其实与之前讲的如何循环起来是一样的。</p> 
<p>判断空就很简单了，只有一种情况就是front和rear两个指针相同的时候，此时就相同了。</p> 
<pre><code class="language-cpp">bool myCircularQueueIsEmpty(MyCircularQueue* obj) {
	return obj-&gt;front == obj-&gt;rear;
}

bool myCircularQueueIsFull(MyCircularQueue* obj) {
	return obj-&gt;front == (obj-&gt;rear + 1) % (obj-&gt;k + 1);
}</code></pre> 
<h4 id="3.%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E5%87%BD%E6%95%B0">3.插入删除函数</h4> 
<pre><code class="language-cpp">bool myCircularQueueEnQueue(MyCircularQueue* obj, int value) {
	if (myCircularQueueIsFull(obj)) {
		return false;
	}
	obj-&gt;a[obj-&gt;rear] = value;
	obj-&gt;rear = (obj-&gt;rear + 1) % (obj-&gt;k + 1);
	return true;
}</code></pre> 
<p>删除函数</p> 
<pre><code class="language-cpp">bool myCircularQueueDeQueue(MyCircularQueue* obj) {
	if (myCircularQueueIsEmpty(obj)) {
		return false;
	}
	obj-&gt;front = (obj-&gt;front + 1) % (obj-&gt;k + 1);
	return true;
}</code></pre> 
<h4 id="4.%E6%9F%A5%E7%9C%8B%E9%98%9F%E9%A6%96%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0">4.查看队首队尾元素</h4> 
<pre><code class="language-cpp">int myCircularQueueFront(MyCircularQueue* obj) {
	if (myCircularQueueIsEmpty(obj)) {
		return -1;
	}
	return obj-&gt;a[obj-&gt;front];
}</code></pre> 
<pre><code class="language-cpp">int myCircularQueueRear(MyCircularQueue* obj) {
	if (myCircularQueueIsEmpty(obj)) {
		return -1;
	}
	return obj-&gt;a[(obj-&gt;rear - 1 + obj-&gt;k + 1) % (obj-&gt;k + 1)]
}</code></pre> 
<p>在查看队尾元素的时候，是有一个问题的，当rear指针指向数组下标为0的位置的时候，此时的队尾元素在数组的最后一个位置上。所以如何要让rear从0变成k.</p> 
<p>此时可以区分当rear为0和不为0 两个情况，也可以向以上代码中写的那样，只不过与之前讲的让队列循环起来采用了反着的方式，本质上没有区别，读者可以带入数字自行尝试。</p> 
<h4 id="5.%E9%87%8A%E6%94%BE%E5%87%BD%E6%95%B0">5.释放函数</h4> 
<pre><code class="language-cpp">void myCircularQueueFree(MyCircularQueue* obj) {
	free(obj-&gt;a);
	free(obj);
}</code></pre> 
<p> 向释放数组，再释放结构体。</p> 
<p>循环队列是一种特殊的队列数据结构，它可以在固定大小的数组中实现队列的功能。循环队列的实现方式是通过使用一个数组和两个指针来管理数据的循环插入和删除。</p> 
<p>循环队列的两个指针分别称为"front"和"rear"指针。front指针指向队列的第一个元素，rear指针指向最后一个元素的下一个位置。当队列为空时，front和rear指针指向同一个位置。</p> 
<p>循环队列的插入操作是在rear指针的位置插入一个新元素，并将rear指针向后移动一位。如果rear指针到达数组的末尾，插入操作会循环到数组的开头。当rear指针指向front指针时，表示队列已满，无法插入新的元素。</p> 
<p>循环队列的删除操作是将front指针指向的元素删除，并将front指针向后移动一位。如果front指针到达数组的末尾，删除操作会循环到数组的开头。当front指针等于rear指针时，表示队列为空。</p> 
<p>循环队列的优点是可以充分利用数组空间，避免了元素的搬迁操作。相比于普通队列，循环队列的插入和删除操作的时间复杂度都是O(1)。</p> 
<p>然而，循环队列的缺点是无法区分队列是满还是空。为了解决这个问题，可以设置一个额外的标志位来记录队列的状态。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/71cc79c82d901e862087d9b04557e48a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Coze】把 AI 嵌入到自己网站的网页中</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5be9412e6b56896d8c8de23564a17d36/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C语言】C语言零基础纯干货教学（中）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>