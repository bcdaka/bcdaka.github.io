<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【javaSE】抽象类与接口（3）（接口部分） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/6c23f455485b90fb42031a035b9439a2/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【javaSE】抽象类与接口（3）（接口部分）">
  <meta property="og:description" content="❤️❤️前言~🥳🎉🎉🎉 hellohello~，大家好💕💕，这里是E绵绵呀✋✋ ，如果觉得这篇文章还不错的话还请点赞❤️❤️收藏💞 💞 关注💥💥，如果发现这篇文章有问题的话，欢迎各位评论留言指正，大家一起加油！一起chin up！👍👍 💥个人主页：E绵绵的博客
💥 所属专栏：JAVASE题目练习 JAVASE知识点专栏 c语言知识点专栏 c语言题目练习 这篇文章就是关于抽象类与接口的最后一篇了，我们接下来将会给大家主要介绍接口的实例使用，这部分也是最难的，还请各位认真观看，不要错过每一处细节。💕💕 接口使用实例 给对象数组排序 首先在了解它之前我们一些接口以及其他知识点。
comparable ❤️❤️观察其内部结构我们可以知道在Comparable后面还有个&lt;T&gt;，在语法上这是泛型，之后会讲，这并不影响我们现在的思路，这个&lt;T&gt;中的T你写student类，后面的compareTo方法中的第一个参数就是student类，如上图。
对于comparable接口中只有一个compareTo方法，所以我们使用该接口时只需要重写该compareTo方法就行。
比较大小时可以用comparable该接口。
关于其comprable使用如下：
class Student implements Comparable&lt;Student&gt; { public String name; public int age; public Student(String name, int age) { this.name = name; this.age = age; } @Override public int compareTo(Student o) { //System.out.println(&#34;===fdsfsafdsafdsafdsafdsafdsafsafdsafa&#34;); return this.age - o.age; } @Override public String toString() { return &#34;Student{&#34; &#43; &#34;name=&#39;&#34; &#43; name &#43; &#39;\&#39;&#39; &#43; &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-25T15:57:43+08:00">
    <meta property="article:modified_time" content="2024-04-25T15:57:43+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【javaSE】抽象类与接口（3）（接口部分）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><strong> ❤️❤️<span style="color:#fe2c24;">前言</span>~🥳</strong>🎉🎉🎉 </h2> 
<blockquote> 
 <p><strong>hellohello~，大家好💕💕，这里是E绵绵呀✋✋ ，如果觉得这篇文章还不错的话还请点赞❤️❤️收藏💞 💞 关注💥💥，如果发现这篇文章有问题的话，欢迎各位评论留言指正，大家一起加油！一起chin up！👍👍 </strong></p> 
 <p></p> 
 <p><img alt="" height="800" src="https://images2.imgbox.com/77/3b/lJ651bCj_o.jpg" width="889"></p> 
 <p></p> 
 <p><strong>💥<span style="color:#956fe7;">个人主页：</span><a href="https://blog.csdn.net/Easonmax?type=blog" title="E绵绵的博客">E绵绵的博客</a><br> 💥 <span style="color:#956fe7;">所属专栏：</span><a href="https://blog.csdn.net/easonmax/category_12611045.html?spm=1001.2014.3001.5482" title="JAVASE题目练习">JAVASE题目练习</a>  <a href="https://blog.csdn.net/easonmax/category_12591491.html" title="JAVASE知识点专栏">JAVASE知识点专栏</a>  <a href="https://blog.csdn.net/easonmax/category_12546237.html" title="c语言知识点专栏">c语言知识点专栏</a><a href="https://blog.csdn.net/easonmax/category_12546244.html" title="   c语言题目练习">   c语言题目练习</a></strong> </p> 
</blockquote> 
<blockquote> 
 <p> <strong>这篇文章就是关于抽象类与接口的最后一篇了，我们接下来将会给大家主要介绍接口的实例使用，这部分也是最难的，还请各位认真观看，不要错过每一处细节。💕💕</strong> </p> 
</blockquote> 
<p class="img-center"><img alt="" height="338" src="https://images2.imgbox.com/da/6a/y8xMHTgp_o.gif" width="600"></p> 
<p></p> 
<h2>接口使用实例  </h2> 
<h3>给对象数组排序</h3> 
<blockquote> 
 <p><strong>首先在了解它之前我们一些接口以及其他知识点。</strong></p> 
</blockquote> 
<h4>comparable  </h4> 
<blockquote> 
 <p><strong><img alt="" height="825" src="https://images2.imgbox.com/a5/7e/OJWMBqrA_o.png" width="1200"></strong></p> 
 <p><strong> ❤️❤️观察其内部结构我们可以知道在Comparable后面还有个&lt;T&gt;，<span style="color:#fe2c24;">在语法上这是泛型</span>，之后会讲，这并不影响我们现在的思路，<span style="color:#fe2c24;">这个&lt;T&gt;中的T你写student类，后面的compareTo方法中的第一个参数就是student类，如上图。</span></strong></p> 
 <p><strong><span style="color:#1c7331;">对于comparable接口中只有一个compareTo方法，所以我们使用该接口时只需要重写该compareTo方法就行。</span></strong></p> 
 <p><strong><span style="color:#1c7331;">比较大小时可以用comparable该接口。</span></strong></p> 
 <p><strong><span style="color:#fe2c24;">关于其comprable使用如下：</span></strong></p> 
 <pre><code>class Student implements Comparable&lt;Student&gt; {
    public String name;
    public int age;

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

   @Override
    public int compareTo(Student o) {
        //System.out.println("===fdsfsafdsafdsafdsafdsafdsafsafdsafa");
        return this.age - o.age;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
public class Test {


    public static void bubbleSort(Comparable[] comparables) {

        for (int i = 0; i &lt; comparables.length-1; i++) {
            for (int j = 0; j &lt; comparables.length-1-i; j++) {

                if(comparables[j].compareTo(comparables[j+1]) &gt; 0) {
                    Comparable tmp = comparables[j];
                    comparables[j] = comparables[j+1];
                    comparables[j+1] = tmp;
                }
            }
        }
    }

    public static void main(String[] args) {
        Student[] students = new Student[3];
        students[0] = new Student("zhangsan",10);
        students[1] = new Student("lisi",4);
        students[2] = new Student("abc",5);
        System.out.println("排序前： "+Arrays.toString(students));

        bubbleSort(students);

        System.out.println("排序后： "+Arrays.toString(students));
    }</code></pre> 
 <p><strong>所以就通过该代码去使用comparable接口中的compareTo方法，这个代码你们自己仔细看一下应该就能看懂了，不细讲，讲个大概就行了。</strong></p> 
 <p></p> 
</blockquote> 
<h4>tostring重写 </h4> 
<blockquote> 
 <p><strong>在上文代码中出现了一个问题，就是当Arrays.toString内部为类数组时如students时，为什么要将toString重写，(<span style="color:#fe2c24;">注意这里的toString重写不是将Arrays的toString重写，是将内部的object中的tostring重写</span>)原因如下：</strong></p> 
 <p><strong>请看下面的图片：</strong></p> 
 <p><img alt="" height="760" src="https://images2.imgbox.com/d3/b7/MSeTwtUs_o.png" width="1200"></p> 
 <p><img alt="" height="169" src="https://images2.imgbox.com/7c/d3/ewcYdNgS_o.png" width="1015"></p> 
 <p><strong>分析上述图得知，当其内部为像students时的类数组时，不重写则会打印出地址</strong><img alt="" height="47" src="https://images2.imgbox.com/8d/25/rGwFZSJN_o.png" width="984"></p> 
 <p><strong>我们的目的是打印出其每个类的每个数据，所以要将toString重写，如下</strong></p> 
 <p><img alt="" height="245" src="https://images2.imgbox.com/b4/cd/4AppMhE4_o.png" width="499"></p> 
 <p><img alt="" height="54" src="https://images2.imgbox.com/d0/cb/t2E2dPfk_o.png" width="1200"></p> 
 <p><strong>所以就达成了目的，将数组的每个类的每个数据都打印出来了</strong></p> 
 <p></p> 
 <p>🎯🎯 <strong>所以一般来说我们目前遇到的需要toString重写的就两种情况。</strong></p> 
 <p><span style="color:#fe2c24;"><strong>           1.Arrays.toString（存储类的数组）打印出该数组的每个类的每个数据</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>            2.println（类），打印出该类的各个数据</strong></span></p> 
</blockquote> 
<h4>comparator </h4> 
<blockquote> 
 <p><strong>❤️❤️<span style="color:#fe2c24;">该接口有许多方法，但必须重写的只有一个，就是下图中的compare方法需要重写。</span></strong></p> 
 <p><img alt="" height="986" src="https://images2.imgbox.com/ff/e5/AZPK4AuL_o.png" width="1129"></p> 
 <p><strong>以下是使用方式</strong></p> 
 <pre><code>class Student  {
    public String name;
    public int age;

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }}
class AgeComparator implements Comparator&lt;Student&gt; {

    @Override
    public int compare(Student o1, Student o2) {
        return o2.age - o1.age ;
    }
}

class NameComparator implements Comparator&lt;Student&gt; {
    @Override
    public int compare(Student o1, Student o2) {

        //String  自己重写的 compareTo 方法
        return o1.name.compareTo(o2.name);
    }
}
public class Test {

    public static void main(String[] args) {
        { Student student1 = new Student("zhangsan", 10);
            Student student2 = new Student("lisi", 4);
            Test test = new Test();
            test.a(student1,student2);
        }
    }
        public void a(Student student1,Student student2)
    {

        AgeComparator ageComparator = new AgeComparator();
        System.out.println(ageComparator.compare(student1, student2));


        NameComparator nameComparator = new NameComparator();
        System.out.println(nameComparator.compare(student1, student2));
        }
}</code></pre> 
 <p><strong>该接口中的compare方法也是用来进行比较的。</strong></p> 
 <p><strong>在该代码中我们还出现了compareTo,不过这里出现的跟我们往常见到的不一样。接下来将介绍一下。</strong></p> 
</blockquote> 
<h4> String类中的compareTo </h4> 
<blockquote> 
 <p> <strong>❤️❤️现在我们虽然还没深入了解String，但是呢还是懂一点的，我们观察下String类的内部。</strong></p> 
 <p><img alt="" height="144" src="https://images2.imgbox.com/67/00/N3Vlk5he_o.png" width="1048"></p> 
 <p>可以发现它实施了comparable接口，则它一定重写了compareTo方法。</p> 
 <p><img alt="" height="627" src="https://images2.imgbox.com/d4/a8/CScP1rkO_o.png" width="1037"></p> 
 <p><strong>在这了解了内部之后我们只需要知道其string.compareTo的作用为</strong></p> 
 <p><strong><span style="color:#1c7331;">compareTo方法的实现会按照Unicode值的比较。它会逐个比较两个字符串对应位置上的字符的Unicode值，直到找到不同的字符或者其中一个字符串结束为止。找到不同的字符，会根据它们unicode值确定大小关系。</span></strong></p> 
 <p><strong><span style="color:#fe2c24;">如果最终一直相等，则返回0，如果调用该方法的字符串小于参数里的字符串，则返回负数  ；反之为正数。</span></strong></p> 
 <p><strong>下面是一个例子</strong></p> 
 <pre><code>​
String str1 = "abc";
String str2 = "def";
int result = str1.compareTo(str2);
System.out.println(result); 
 // 输出负数，表示str1在unicode值上小于str2（也可以认为字典顺序上小于）

​</code></pre> 
</blockquote> 
<h4> 正文（给对象数组排序）</h4> 
<blockquote> 
 <pre><code>class Student  {
    private String name;
    private int score;

    public Student(String name, int score) {
        this.name = name;
        this.score = score;

    }

    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", score=" + score +
                '}';
    }
}
public class Main{
    public static void main(String[] args) {
        Student[] students = new Student[]{
                new Student("张三", 95),
                new Student("李四", 96),
                new Student("王五", 97),
                new Student("赵六", 92),
        };

        Arrays.sort(students);

        System.out.println(Arrays.toString(students));
    }}
</code></pre> 
 <p><img alt="" height="367" src="https://images2.imgbox.com/de/43/Fhuv1RCy_o.png" width="1200"></p> 
 <p><strong>报错了这是为什么呢，我们来看下内部结构吧。</strong></p> 
 <p><strong><img alt="" height="641" src="https://images2.imgbox.com/c9/b8/MD4QAQ7T_o.png" width="1115"></strong></p> 
 <p><strong>所以如果sort（）内部参数为类（引用类型）数组，则其对应的代码如上，<span style="color:#fe2c24;">这里的a是object类，但其实指向的是创建的student类数组，发生了向上转型。下方还出现了comparable强制类型转换，但因为在上文中comparable和student没有任何关系，所以在这会报错，这也是为什么原文代码没有发生编译错误，但运行却报错了，所以我们必须得让comparable和student产生关系，这样代码才能成功。正确代码如下：</span></strong></p> 
 <pre><code>class Student implements Comparable&lt;Student&gt; {
    private String name;
    private int score;

    public Student(String name, int score) {
        this.name = name;
        this.score = score;

    }

    @Override
    public int compareTo(Student  this,Student O) {
        return  O.name .compareTo( this.name) ;//逆序，compareTo比较大小


    }
    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", score=" + score +
                '}';
    }
}
public class Main{
    public static void main(String[] args) {
        Student[] students = new Student[]{
                new Student("张三", 95),
                new Student("李四", 96),
                new Student("王五", 97),
                new Student("赵六", 92),
        };

        Arrays.sort(students);

        System.out.println(Arrays.toString(students));
    }}
</code></pre> 
 <p><img alt="" height="193" src="https://images2.imgbox.com/a3/70/ZxFkWnga_o.png" width="1200"></p> 
 <p><strong>结果如上，这是对类中的name进行排序，<span style="color:#511b78;">当然我们可以通过改变compareTo中的代码去来改变要排序的成员。</span></strong></p> 
 <p><strong><span style="color:#fe2c24;">所以当sort参数为类（引用类型）数组时，我们就必须让该类实施comparable接口，并且重写comparable中的compareTo方法使其对类中的某个成员进行排序。</span><span style="color:#1c7331;">（注意其compare to返回值为整形，分为大于0，小于0，0三种）</span></strong></p> 
</blockquote> 
<h3>拷贝</h3> 
<p><strong>之前就略微讲过拷贝，只不过之前只涉及了浅拷贝，讲的很少，这次我们认真讲下拷贝，它不仅涉及浅拷贝还有深拷贝。 </strong></p> 
<h4>clone </h4> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>❤️❤️object类中存在一个方法为clone，我们可以通过调用该方法来复制该类的对象从而去创建该类的对象的副本。</strong></span></p> 
 <p><strong>我们先来看下代码：</strong></p> 
 <pre><code>class Person implements Cloneable {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // 重写clone()方法
    @Override
    public Person clone() throws CloneNotSupportedException {
        return (Person) super.clone();

    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}

public class Date{
    public static void main(String[] args)throws  CloneNotSupportedException  {
          Person person=new Person("小美",5);
              Person  person1=person.clone();
        System.out.println(person1);
        }

}</code></pre> 
</blockquote> 
<p><strong>从这代码我们可以注意到一些事项 ：</strong></p> 
<blockquote> 
 <p>🎯​​​​​​​🎯 <strong><span style="color:#fe2c24;">1.实现Cloneable接口：要使用clone()方法，需要确保被复制的类实现了Cloneable接口</span>。否则，在调用clone()方法时会抛出CloneNotSupportedException异常。</strong></p> 
 <p><strong><span style="color:#fe2c24;">而被复制的类的对象实则是引用clone方法的类对象。如上文中的peson。</span></strong></p> 
</blockquote> 
<blockquote> 
 <p><strong> 🎯​​​​​​​🎯<span style="color:#fe2c24;">2重写clone()方法：被复制的类需要重写clone()方法，并将其访问修饰符设置为public。在重写的clone()方法中，我们通过调用父类的clone()方法来实现对象的浅拷贝。</span></strong></p> 
 <p><strong><span style="color:#fe2c24;">如下：</span></strong></p> 
 <pre><code>   public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
</code></pre> 
 <p><strong>之所以要重写clone，是因为clone是被protected修饰，只能在object的同一个包中或不同包的子类中出现。这时如果不重写clone，直接在Date类里引用person.clone，那么就会因为这是person里的clone，而clone在不同包中的非子类Date中出现，所以受访问权限不能访问。因此需要在person类里重写clone方法。（一般重写为如上代码格式）</strong><img alt="" height="60" src="https://images2.imgbox.com/cb/fc/JTZVAse7_o.png" width="876"></p> 
</blockquote> 
<blockquote> 
 <p><strong>🎯​​​​​​​🎯 3.异常处理：在调用clone()方法时，可能会抛出CloneNotSupportedException异常。因此，<span style="color:#fe2c24;">在使用clone()方法时，需要在使用clone（）方法中的成员方法上声明抛出该异常，否则会报错。  </span></strong></p> 
 <p><span style="color:#1c7331;"><em><strong>throws  CloneNotSupportedExcept</strong></em><em><strong>ion就是该异常声明</strong></em></span></p> 
 <p><img alt="" height="568" src="https://images2.imgbox.com/61/b4/sCTMqNYo_o.png" width="1092"><strong>​​</strong></p> 
</blockquote> 
<blockquote> 
 <p><strong>🎯​​​​​​​🎯<span style="color:#fe2c24;">4.注意clone返回的是object类型，所以在接收时我们还需要强制类型转换才能成功。</span></strong></p> 
</blockquote> 
<blockquote> 
 <p><strong>🎯​​​​​​​🎯5.</strong> </p> 
 <p><strong>先看代码</strong>：</p> 
 <pre><code>​
​
class Money implements Cloneable{
    public double m = 19.9;
}
class Person implements Cloneable{
    public String name;
    public int age;

    public Money money = new Money();

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "age=" + age +
                ", money=" + money.m +
                '}';
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {


        Person tmp = (Person)super.clone();
        return super.clone();
    }}
public class Date {
    public static void main(String[] args) throws  CloneNotSupportedException{
        Person person=new Person("0",99);

        Person person1= (Person) person.clone();
        person.money.m=99.9;
        System.out.println(person);
        System.out.println(person1);

    }
}

​

​</code></pre> 
 <p><strong><img alt="" height="190" src="https://images2.imgbox.com/f3/77/DJgtDrF9_o.png" width="616"></strong></p> 
 <p><strong>之所以会出现两个99.9，<span style="color:#fe2c24;">是因为默认情况下，clone()方法执行的是浅拷贝，即复制对象的引用，不会将引用所指向的对象一并复制</span>，所以person1中的money指向的依然是同一个对象，依然是99.9.<span style="color:#fe2c24;">那如果需要实现深拷贝，即复制对象的内容而不是引用，需要在clone()方法中手动处理对象内部的引用。</span></strong></p> 
 <p><strong><span style="color:#fe2c24;">如下才是深拷贝真正代码：</span></strong></p> 
 <pre><code>class Money implements Cloneable{
    public double m = 19.9;

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
class Person implements Cloneable{
    public String name;
    public int age;

    public Money money = new Money();

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "age=" + age +
                ", money=" + money.m +
                '}';
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {


        Person tmp = (Person)super.clone();
        tmp.money = (Money) this.money.clone();
        return tmp;

    }}
public class Date {
    public static void main(String[] args) throws  CloneNotSupportedException{
        Person person=new Person("0",99);

        Person person1= (Person) person.clone();
        person.money.m=99.9;
        System.out.println(person);
        System.out.println(person1);

    }
}</code></pre> 
 <p><img alt="" height="158" src="https://images2.imgbox.com/e3/f7/uExNQTeO_o.png" width="558"></p> 
 <p><strong>我们手动处理了对象内部的引用，所以money类的对象也被复制了，两个money引用所指向的对象不同，导致如上结果不同。</strong></p> 
</blockquote> 
<h4>深拷贝和浅拷贝</h4> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>❤️❤️</strong></span><strong>深拷贝和浅拷贝是在Java中用于复制对象的两种不同方式。由上文可知，我们可以知道深拷贝和浅拷贝的区别：</strong></p> 
 <p><strong><span style="color:#fe2c24;">浅拷贝是指创建一个新对象，然后将原始对象的成员变量的值复制到新对象中。如果成员变量是基本类型，则复制其值；如果成员变量是引用类型，则复制引用而不是其指向的实际对象。因此，始对象和新对象将共享相同的引用对象。这意味着，如果修改其中一个对象的引用对象，另一个对象也会受到影响。</span></strong></p> 
 <p></p> 
 <p><strong><span style="color:#fe2c24;">深拷贝是指创建一个新对象，并复制原始对象的所有成员变量及其所有引用变量所指向的对象。这意味着，虽然原始对象和新对象将拥有相同的值（引用变量的值不同，因为指向不同对象），但是它们引用的是不同的对象。因此，修改其中一个对象的引用对象不会影响另一个对象。</span></strong></p> 
 <p></p> 
 <p><strong>对于浅拷贝我们能通过clone（）实现。</strong></p> 
 <p><strong>而深拷贝我们能通过Serializable接口去实现，这个我们之后会学习，现在还没到那个时候。</strong></p> 
 <p></p> 
</blockquote> 
<h2>抽象类和接口的区别 </h2> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>❤️❤️</strong></span><strong>抽象类和接口都是 Java 中多态的常见使用方式. 都需要重点掌握. 同时又要认清两者的区别(重要!!! 常见面试题).</strong></p> 
 <p></p> 
 <p><strong><span style="color:#fe2c24;">核心区别: </span></strong></p> 
 <p><strong><span style="color:#fe2c24;">1.抽象类中可以包含方法和成员变量, 这样的方法和成员变量可以被子类直接使用(不必重写)</span></strong></p> 
 <p><strong><span style="color:#fe2c24;">2.接口中只能有抽象方法，default或static修饰的方法,。子类必须重写所有的抽象方法.</span> </strong></p> 
 <p></p> 
 <p><strong><span style="color:#1c7331;">再次提醒: 抽象类存在的意义是为了让编译器更好的校验, 像 Animal 这样的类我们并不会直接使用, 而是使用它的子类. 万一不小心创建了 Animal 的实例, 编译器会及时提醒我们.</span></strong></p> 
 <p><img alt="" height="694" src="https://images2.imgbox.com/4d/b7/wAjdChSb_o.png" width="1200"></p> 
</blockquote> 
<h2>Object类 </h2> 
<blockquote> 
 <p><strong>🎯​​​​​​​🎯Object是Java默认提供的一个类。<span style="color:#1c7331;">之前也讲过，Java里面当类没继承关系时，会默认将Object类当作父类，所以所有的类都会继承Object类。它有可能是父类，也有可能是父类的父类等。所以所有类的对象都可以使用Object的引用进行接收。</span></strong></p> 
 <p></p> 
 <p><em><strong><span style="color:#fe2c24;">对于object类，不需要自己主动将其类导入。系统会默认帮你导入这个object类。</span></strong></em></p> 
</blockquote> 
<blockquote> 
 <p></p> 
 <p><strong> </strong><span style="color:#fe2c24;"><strong>❤️❤️</strong></span><strong>范例：使用Object接收所有类的对象：</strong></p> 
 <pre><code>class Person{}
class Student{}
public class Test {
 public static void main(String[] args) {
 function(new Person());
 function(new Student());
 }
 public static void function(Object obj) {
 System.out.println(obj);
 }
}
//执行结果：
Person@1b6d3586
Student@4554617c</code></pre> 
 <p><strong><span style="color:#1c7331;">所以在开发之中，Object类是参数的最高统一类型，所有类都可以用它接收。</span>并且我们的Object类内部还存在定义好的一些方法。如下：</strong></p> 
 <p><img alt="" height="900" src="https://images2.imgbox.com/2f/f3/ASSCn5SL_o.png" width="1200"></p> 
 <p></p> 
 <p></p> 
 <p><strong><span style="color:#1c7331;">对于object类的方法，我们目前要了解的有四个，clone（），toString（），equals（），hashcode（）</span>。刚才已经讲过了clone（），所以现在讲解一下其他三个。</strong></p> 
</blockquote> 
<h2>tostring获取对象信息 </h2> 
<blockquote> 
 <p><strong>💞 💞</strong><strong>对于object里的tostring（）</strong><span style="color:#1c7331;"><strong>，如果参数是基本类型变量，则返回其基本类型变量的值。如果参数是引用类型变量，返回其引用变量的值（地址）。</strong></span><span style="color:#fe2c24;"><strong>（注意返回值是String类型，所以都要带双引号）</strong></span><img alt="" height="134" src="https://images2.imgbox.com/35/53/0CyDWBIg_o.png" width="942"></p> 
 <p><strong><span style="color:#1c7331;">所以如果我们要打印出对象中的内容，用object里的tostring（）是没用的，我们需要直接重写Object类中的toString()方法，</span>对于这个重写我们之前已经讲过了，此处不再累赘。这里直接看一个很典型的重写代码：</strong></p> 
 <pre><code> public String toString() {
        return "Person{" +
                "age=" + age +
                ", money=" + money.m +
                '}';
    }</code></pre> 
</blockquote> 
<h2> equals方法</h2> 
<blockquote> 
 <p><strong><span style="color:#fe2c24;">❤️❤️</span>在Java中，用==进行比较时：分为两种：</strong></p> 
 <p><strong>如果==左右两侧是基本类型变量，比较的是变量中值是否相同</strong></p> 
 <p><strong>如果==左右两侧是引用类型变量，比较的是引用变量地址是否相同</strong></p> 
</blockquote> 
<blockquote> 
 <p><strong><span style="color:#fe2c24;">对于我们的equals，它适用于类的对象的比较。</span></strong>以下是其equals内部代码：</p> 
 <pre><code>// Object类中的equals方法
public boolean equals(Object obj) {
    return (this == obj);   // 使用引用中的地址直接来进行比较
}
</code></pre> 
 <p><strong>通过观察以上代码可知，因为其参数为object，所以适用于类的对象的比较。</strong></p> 
 <p><strong><span style="color:#1c7331;">而通过对其观察，因为其object的equals方法是直接拿地址进行比较，所以我们要比较对象中内容时，必须重写Object中的equals方法，否则会得到错误结果。</span></strong></p> 
 <p><strong>如下：</strong></p> 
 <pre><code>class Person{
 private String name ; 
 private int age ; 
 public Person(String name, int age) {
 this.age = age ; 
 this.name = name ;
 }
}
public class Test {
 public static void main(String[] args) {
 Person p1 = new Person("gaobo", 20) ; 
 Person p2 = new Person("gaobo", 20) ; 
        int a = 10;
        int b = 10;
        System.out.println(a == b);             // 输出true
 System.out.println(p1 == p2);           // 输出false
        System.out.println(p1.equals(p2));      // 输出false
 }
}</code></pre> 
 <p><strong>此时无论如何，用equals方法比较两个类对象其结果都是false，<span style="color:#fe2c24;">所以比较类的对象中内容是否相同的时候，一定要重写equals方法。</span></strong></p> 
 <p><strong><span style="color:#fe2c24;">对于该重写方法我们可以通过快捷键自动生成equals重写方法：</span></strong></p> 
 <p><img alt="" height="381" src="https://images2.imgbox.com/ca/02/nJGh68MK_o.png" width="324"></p> 
 <p><img alt="" height="252" src="https://images2.imgbox.com/00/db/rQCp2Zo3_o.png" width="994"></p> 
 <p><span style="color:#1c7331;"><strong>对于该代码，在正常情况下我们主要考虑最后一段代码</strong></span><img alt="" height="66" src="https://images2.imgbox.com/aa/18/1MbqfE3U_o.png" width="913"></p> 
 <p><strong>我们观察下objects.equals的内部代码</strong></p> 
 <p><img alt="" height="146" src="https://images2.imgbox.com/a3/5f/iJVmRhYx_o.png" width="1200"></p> 
 <p><strong>这里有疑惑的是又出现了equals，如果这里的a和b是普通类的话，那么它们直接比较地址不就返回false，结果不又是一直false的吗，所以我们引出下文：</strong></p> 
 <p><img alt="" height="884" src="https://images2.imgbox.com/9f/f3/aHHlBJe7_o.png" width="954"></p> 
 <p><strong><span style="color:#fe2c24;">在String类中，equals跟compareTo一样都被重写了，为上图代码。通过该代码可知，只要两个字符串完全相等，则返回true，否则false。</span></strong></p> 
 <p><strong><span style="color:#fe2c24;">所以只要是有String类.equals方法,那么就会引用String类中的equals的重写方法，从而判断字符串是否相等。</span></strong></p> 
</blockquote> 
<blockquote> 
 <p><img alt="" height="231" src="https://images2.imgbox.com/5e/b6/kkBAkmLd_o.png" width="930"></p> 
 <p><strong>所以我们现在就很好的分析完这段代码以及其内部代码了，懂得了equals方法的相关知识点。</strong></p> 
</blockquote> 
<h2>hashcode方法</h2> 
<blockquote> 
 <p><strong>对于hashCode()这个方法，它的作用：它能帮我算出对象的具体位置，而这里面涉及数据结构，但是我们还没学数据结构，没法讲述，所以我们只能说它是个内存地址。我们要等到学哈希表才能真正清楚的去讲述清楚它。所以先放一下这个hashcode方法，之后再讲清楚。</strong></p> 
</blockquote> 
<h2> 总结 </h2> 
<p><strong>所以这就是我们的抽象类与接口的最后一章，里面涉及的知识点过多，还请大家认真多看几遍，好好消化。<span style="color:#fe2c24;">一起加油吧！帮作者点点关注，评评论谢谢家人们了~❤️❤️🥳🎉🎉🎉</span></strong></p> 
<p class="img-center"><img alt="" height="3" src="https://images2.imgbox.com/aa/d7/cqt5ogRO_o.jpg" width="450"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e7fba4474d4bac46831855adecbe0a21/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【javaSE】String类（2）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/00d1e8571420ef216b9eef42fe4cf0e5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【javaSE】抽象类和接口（2）（接口部分）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>