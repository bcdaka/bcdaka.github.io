<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深入探索：Zookeeper&#43;消息队列（kafka）集群 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/a9ba8c1032aaea84ff8cecaa1f663737/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="深入探索：Zookeeper&#43;消息队列（kafka）集群">
  <meta property="og:description" content="目录
前言
一、Zookeeper概述
1、Zookeeper概念
2、Zookeeper 特点
3、Zookeeper工作机制
4、Zookeeper 选举机制
4.1 第一次启动选举机制
4.2 非第一次启动选举机制
5、Zookeeper 数据结构
6、Zookeeper 应用场景
二、部署 Zookeeper 集群
1、环境部署
2、安装 zookeeper 软件
3、设置主配置文件
4、创建数据目录和日志目录
5、创建myid文件
6、配置 Zookeeper 启动脚本并设置开机自启
7、分别启动 Zookeeper
三、消息队列（Message Queue）概述
1、消息队列的概念
2、为什么使用消息队列
3、使用消息队列的好处
4、消息队列的异步处理机制
5、消息队列的两种模式
5.1 点对点模式
5.2 发布/订阅模式
6、常见的消息队列系统
四、消息队列系统-Kafka
1、Kafka的概念
2、Kafka的特性
3、Kafka系统架构
3.1 系统架构的核心组件和概念
3.2 Kafka工作流程
4、kafka的follower如何与leader同步数据
5、Kafka分区的原因
6、Kafka文件存储机制
7、数据可靠性保证
8、数据一致性问题
9、ack 应答机制
五、部署 kafka 集群
1、环境部署
2、安装 kafka 软件
3、修改主配置文件
4、修改环境变量
5、配置 Zookeeper 启动脚本并设置开机自启">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-24T10:25:48+08:00">
    <meta property="article:modified_time" content="2024-04-24T10:25:48+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深入探索：Zookeeper&#43;消息队列（kafka）集群</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p id="%E4%B8%80%E3%80%81Zookeeper%E6%A6%82%E8%BF%B0-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81Zookeeper%E6%A6%82%E8%BF%B0" rel="nofollow">一、Zookeeper概述</a></p> 
<p id="1%E3%80%81Zookeeper%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#1%E3%80%81Zookeeper%E6%A6%82%E5%BF%B5" rel="nofollow">1、Zookeeper概念</a></p> 
<p id="2%E3%80%81Zookeeper%20%E7%89%B9%E7%82%B9-toc" style="margin-left:40px;"><a href="#2%E3%80%81Zookeeper%20%E7%89%B9%E7%82%B9" rel="nofollow">2、Zookeeper 特点</a></p> 
<p id="3%E3%80%81Zookeeper%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6-toc" style="margin-left:40px;"><a href="#3%E3%80%81Zookeeper%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6" rel="nofollow">3、Zookeeper工作机制</a></p> 
<p id="4%E3%80%81Zookeeper%20%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6-toc" style="margin-left:40px;"><a href="#4%E3%80%81Zookeeper%20%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6" rel="nofollow">4、Zookeeper 选举机制</a></p> 
<p id="4.1%20%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%90%AF%E5%8A%A8%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6-toc" style="margin-left:80px;"><a href="#4.1%20%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%90%AF%E5%8A%A8%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6" rel="nofollow">4.1 第一次启动选举机制</a></p> 
<p id="4.2%20%E9%9D%9E%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%90%AF%E5%8A%A8%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6-toc" style="margin-left:80px;"><a href="#4.2%20%E9%9D%9E%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%90%AF%E5%8A%A8%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6" rel="nofollow">4.2 非第一次启动选举机制</a></p> 
<p id="5%E3%80%81Zookeeper%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#5%E3%80%81Zookeeper%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" rel="nofollow">5、Zookeeper 数据结构</a></p> 
<p id="6%E3%80%81Zookeeper%20%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#6%E3%80%81Zookeeper%20%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">6、Zookeeper 应用场景</a></p> 
<p id="%E4%BA%8C%E3%80%81%E9%83%A8%E7%BD%B2%20Zookeeper%20%E9%9B%86%E7%BE%A4-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E9%83%A8%E7%BD%B2%20Zookeeper%20%E9%9B%86%E7%BE%A4" rel="nofollow">二、部署 Zookeeper 集群</a></p> 
<p id="1%E3%80%81%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2" rel="nofollow">1、环境部署</a></p> 
<p id="2%E3%80%81%E5%AE%89%E8%A3%85%C2%A0zookeeper%20%E8%BD%AF%E4%BB%B6-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%AE%89%E8%A3%85%C2%A0zookeeper%20%E8%BD%AF%E4%BB%B6" rel="nofollow">2、安装 zookeeper 软件</a></p> 
<p id="3%E3%80%81%E8%AE%BE%E7%BD%AE%E4%B8%BB%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E8%AE%BE%E7%BD%AE%E4%B8%BB%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6" rel="nofollow">3、设置主配置文件</a></p> 
<p id="4%E3%80%81%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95%E5%92%8C%E6%97%A5%E5%BF%97%E7%9B%AE%E5%BD%95-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95%E5%92%8C%E6%97%A5%E5%BF%97%E7%9B%AE%E5%BD%95" rel="nofollow">4、创建数据目录和日志目录</a></p> 
<p id="5%E3%80%81%E5%88%9B%E5%BB%BAmyid%E6%96%87%E4%BB%B6-toc" style="margin-left:40px;"><a href="#5%E3%80%81%E5%88%9B%E5%BB%BAmyid%E6%96%87%E4%BB%B6" rel="nofollow">5、创建myid文件</a></p> 
<p id="6%E3%80%81%E9%85%8D%E7%BD%AE%20Zookeeper%20%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC%E5%B9%B6%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF-toc" style="margin-left:40px;"><a href="#6%E3%80%81%E9%85%8D%E7%BD%AE%20Zookeeper%20%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC%E5%B9%B6%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF" rel="nofollow">6、配置 Zookeeper 启动脚本并设置开机自启</a></p> 
<p id="7%E3%80%81%E5%88%86%E5%88%AB%E5%90%AF%E5%8A%A8%20Zookeeper-toc" style="margin-left:40px;"><a href="#7%E3%80%81%E5%88%86%E5%88%AB%E5%90%AF%E5%8A%A8%20Zookeeper" rel="nofollow">7、分别启动 Zookeeper</a></p> 
<p id="%E4%B8%89%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88Message%20Queue%EF%BC%89%E6%A6%82%E8%BF%B0-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88Message%20Queue%EF%BC%89%E6%A6%82%E8%BF%B0" rel="nofollow">三、消息队列（Message Queue）概述</a></p> 
<p id="1%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">1、消息队列的概念</a></p> 
<p id="2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97" rel="nofollow">2、为什么使用消息队列</a></p> 
<p id="3%E3%80%81%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%A5%BD%E5%A4%84-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%A5%BD%E5%A4%84" rel="nofollow">3、使用消息队列的好处</a></p> 
<p id="4%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6" rel="nofollow">4、消息队列的异步处理机制</a></p> 
<p id="5%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F-toc" style="margin-left:40px;"><a href="#5%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F" rel="nofollow">5、消息队列的两种模式</a></p> 
<p id="5.1%20%E7%82%B9%E5%AF%B9%E7%82%B9%E6%A8%A1%E5%BC%8F-toc" style="margin-left:80px;"><a href="#5.1%20%E7%82%B9%E5%AF%B9%E7%82%B9%E6%A8%A1%E5%BC%8F" rel="nofollow">5.1 点对点模式</a></p> 
<p id="5.2%20%E5%8F%91%E5%B8%83%2F%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F-toc" style="margin-left:80px;"><a href="#5.2%20%E5%8F%91%E5%B8%83%2F%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F" rel="nofollow">5.2 发布/订阅模式</a></p> 
<p id="6%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F-toc" style="margin-left:40px;"><a href="#6%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F" rel="nofollow">6、常见的消息队列系统</a></p> 
<p id="%E5%9B%9B%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F-Kafka-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F-Kafka" rel="nofollow">四、消息队列系统-Kafka</a></p> 
<p id="1%E3%80%81Kafka%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#1%E3%80%81Kafka%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">1、Kafka的概念</a></p> 
<p id="2%E3%80%81Kafka%E7%9A%84%E7%89%B9%E6%80%A7-toc" style="margin-left:40px;"><a href="#2%E3%80%81Kafka%E7%9A%84%E7%89%B9%E6%80%A7" rel="nofollow">2、Kafka的特性</a></p> 
<p id="3%E3%80%81Kafka%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84-toc" style="margin-left:40px;"><a href="#3%E3%80%81Kafka%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84" rel="nofollow">3、Kafka系统架构</a></p> 
<p id="3.1%20%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E5%92%8C%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#3.1%20%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E5%92%8C%E6%A6%82%E5%BF%B5" rel="nofollow">3.1 系统架构的核心组件和概念</a></p> 
<p id="3.2%C2%A0Kafka%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-toc" style="margin-left:80px;"><a href="#3.2%C2%A0Kafka%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B" rel="nofollow">3.2 Kafka工作流程</a></p> 
<p id="4%E3%80%81kafka%E7%9A%84follower%E5%A6%82%E4%BD%95%E4%B8%8Eleader%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#4%E3%80%81kafka%E7%9A%84follower%E5%A6%82%E4%BD%95%E4%B8%8Eleader%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE" rel="nofollow">4、kafka的follower如何与leader同步数据</a></p> 
<p id="4%E3%80%81Kafka%E5%88%86%E5%8C%BA%E7%9A%84%E5%8E%9F%E5%9B%A0-toc" style="margin-left:40px;"><a href="#4%E3%80%81Kafka%E5%88%86%E5%8C%BA%E7%9A%84%E5%8E%9F%E5%9B%A0" rel="nofollow">5、Kafka分区的原因</a></p> 
<p id="6%E3%80%81Kafka%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6-toc" style="margin-left:40px;"><a href="#6%E3%80%81Kafka%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6" rel="nofollow">6、Kafka文件存储机制</a></p> 
<p id="7%E3%80%81%E6%95%B0%E6%8D%AE%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BF%9D%E8%AF%81-toc" style="margin-left:40px;"><a href="#7%E3%80%81%E6%95%B0%E6%8D%AE%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BF%9D%E8%AF%81" rel="nofollow">7、数据可靠性保证</a></p> 
<p id="8%E3%80%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98-toc" style="margin-left:40px;"><a href="#8%E3%80%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98" rel="nofollow">8、数据一致性问题</a></p> 
<p id="9%E3%80%81ack%20%E5%BA%94%E7%AD%94%E6%9C%BA%E5%88%B6-toc" style="margin-left:40px;"><a href="#9%E3%80%81ack%20%E5%BA%94%E7%AD%94%E6%9C%BA%E5%88%B6" rel="nofollow">9、ack 应答机制</a></p> 
<p id="%E4%BA%94%E3%80%81%E9%83%A8%E7%BD%B2%20kafka%20%E9%9B%86%E7%BE%A4-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E9%83%A8%E7%BD%B2%20kafka%20%E9%9B%86%E7%BE%A4" rel="nofollow">五、部署 kafka 集群</a></p> 
<p id="1%E3%80%81%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2" rel="nofollow">1、环境部署</a></p> 
<p id="2%E3%80%81%E5%AE%89%E8%A3%85%20kafka%20%E8%BD%AF%E4%BB%B6-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%AE%89%E8%A3%85%20kafka%20%E8%BD%AF%E4%BB%B6" rel="nofollow">2、安装 kafka 软件</a></p> 
<p id="3%E3%80%81%E4%BF%AE%E6%94%B9%E4%B8%BB%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E4%BF%AE%E6%94%B9%E4%B8%BB%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6" rel="nofollow">3、修改主配置文件</a></p> 
<p id="4%E3%80%81%E4%BF%AE%E6%94%B9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E4%BF%AE%E6%94%B9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F" rel="nofollow">4、修改环境变量</a></p> 
<p id="5%E3%80%81%E9%85%8D%E7%BD%AE%20Zookeeper%20%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC%E5%B9%B6%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF-toc" style="margin-left:40px;"><a href="#5%E3%80%81%E9%85%8D%E7%BD%AE%20Zookeeper%20%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC%E5%B9%B6%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF" rel="nofollow">5、配置 Zookeeper 启动脚本并设置开机自启</a></p> 
<p id="6%E3%80%81%C2%A0%E5%88%86%E5%88%AB%E5%90%AF%E5%8A%A8%20Kafka-toc" style="margin-left:40px;"><a href="#6%E3%80%81%C2%A0%E5%88%86%E5%88%AB%E5%90%AF%E5%8A%A8%20Kafka" rel="nofollow">6、 分别启动 Kafka</a></p> 
<p id="7%E3%80%81Kafka%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#7%E3%80%81Kafka%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C" rel="nofollow">7、Kafka 命令行操作</a></p> 
<p id="7.1%20%E5%88%9B%E5%BB%BA%20Kafka%20%E4%B8%BB%E9%A2%98%E5%B9%B6%E6%9F%A5%E7%9C%8B%E4%B8%BB%E9%A2%98-toc" style="margin-left:80px;"><a href="#7.1%20%E5%88%9B%E5%BB%BA%20Kafka%20%E4%B8%BB%E9%A2%98%E5%B9%B6%E6%9F%A5%E7%9C%8B%E4%B8%BB%E9%A2%98" rel="nofollow">7.1 创建 Kafka 主题并查看主题</a></p> 
<p id="7.2%20%E5%8F%91%E5%B8%83%E4%B8%8E%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF-toc" style="margin-left:80px;"><a href="#7.2%20%E5%8F%91%E5%B8%83%E4%B8%8E%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF" rel="nofollow">7.2 发布与消费消息</a></p> 
<p id="7.3%C2%A0%E4%BF%AE%E6%94%B9%E5%88%86%E5%8C%BA%E6%95%B0-toc" style="margin-left:80px;"><a href="#7.3%C2%A0%E4%BF%AE%E6%94%B9%E5%88%86%E5%8C%BA%E6%95%B0" rel="nofollow">7.3 修改分区数</a></p> 
<p id="7.4%C2%A0%E5%88%A0%E9%99%A4%E4%B8%BB%E9%A2%98%EF%BC%88topic%EF%BC%89-toc" style="margin-left:80px;"><a href="#7.4%C2%A0%E5%88%A0%E9%99%A4%E4%B8%BB%E9%A2%98%EF%BC%88topic%EF%BC%89" rel="nofollow">7.4 删除主题（topic）</a></p> 
<p id="%E5%85%AD%E3%80%81%E5%88%9B%E5%BB%BA%E4%B8%BB%E9%A2%98%E4%B8%80%E8%88%AC%E6%95%85%E9%9A%9C%C2%A0-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81%E5%88%9B%E5%BB%BA%E4%B8%BB%E9%A2%98%E4%B8%80%E8%88%AC%E6%95%85%E9%9A%9C%C2%A0" rel="nofollow">六、创建主题一般故障 </a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E5%89%8D%E8%A8%80">前言</h2> 
<p>当大量客户端同时并发访问服务器时，服务器对同时涌入的大量请求来不及处理，而这些请求往往会发生阻塞，导致服务器压力过大而易产生故障。这时就引入Zookeeper+消息队列（kafka）来处理海量复杂的请求或数据</p> 
<p>总的来说，ZooKeeper 和 Kafka 架构适用于需要构建高可靠、高性能的分布式系统的场景，特别是在需要处理大量实时数据的应用中表现出色</p> 
<h2 id="%E4%B8%80%E3%80%81Zookeeper%E6%A6%82%E8%BF%B0">一、Zookeeper概述</h2> 
<h3 id="1%E3%80%81Zookeeper%E6%A6%82%E5%BF%B5">1、Zookeeper概念</h3> 
<p>ZooKeeper是一个开源的分布式协调服务，旨在解决分布式应用程序中的一致性和可靠性问题。它提供了一个分布式的协调服务，用于配置管理、命名服务、分布式同步和组服务</p> 
<h3 id="2%E3%80%81Zookeeper%20%E7%89%B9%E7%82%B9">2、Zookeeper 特点</h3> 
<ul><li>Zookeeper：一个领导者（Leader），多个跟随者（Follower）组成的集群</li><li>Zookeepe集群中只要有半数以上节点存活，Zookeeper集群就能正常服务。所以Zookeeper适合安装奇数台服务器</li><li>全局数据一致：每个Server保存一份相同的数据副本，Client无论连接到哪个Server，数据都是一致的</li><li>更新请求顺序执行，来自同一个Client的更新请求按其发送顺序依次执行，即先进先出</li><li>数据更新原子性，一次数据更新要么成功，要么失败</li><li>实时性，在一定时间范围内，Client能读到最新数据</li></ul> 
<h3 id="3%E3%80%81Zookeeper%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6">3、Zookeeper工作机制</h3> 
<p>Zookeeper工作模式：<strong>文件系统+通知机制</strong></p> 
<p><strong>工作机制：</strong></p> 
<ul><li>每个服务端上线时需要到zookeeper集群注册信息</li><li>客户端从zookeeper集群获取在线服务端信息列表并监听</li><li>服务端上线下线时，zookeeper需要更新列表信息并通知客户端</li><li>客户端接收到通知重新获取zookeeper在线服务器列表</li></ul> 
<p class="img-center"><img alt="" height="672" src="https://images2.imgbox.com/0f/26/mzwzmYde_o.png" width="700"></p> 
<h3 id="4%E3%80%81Zookeeper%20%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6">4、Zookeeper 选举机制</h3> 
<p class="img-center"><img alt="" height="222" src="https://images2.imgbox.com/d6/4d/RPrjduMk_o.png" width="700"></p> 
<h4 id="4.1%20%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%90%AF%E5%8A%A8%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6">4.1 第一次启动选举机制</h4> 
<p>（1）服务器1启动，发起一次选举。服务器1投自己一票。此时服务器1票数一票，不够半数以上（3票），选举无法完成，服务器1状态保持为LOOKING；</p> 
<p>（2）服务器2启动，再发起一次选举。服务器1和2分别投自己一票并交换选票信息：此时服务器1发现服务器2的myid比自己目前投票推举的（服务器1）大，更改选票为推举服务器2。此时服务器1票数0票，服务器2票数2票，没有半数以上结果，选举无法完成，服务器1，2状态保持LOOKING；</p> 
<p>（3）服务器3启动，发起一次选举。此时服务器1和2都会更改选票为服务器3。此次投票结果：服务器1为0票，服务器2为0票，服务器3为3票。此时服务器3的票数已经超过半数，服务器3当选Leader。服务器1，2更改状态为FOLLOWING，服务器3更改状态为LEADING；</p> 
<p>（4）服务器4启动，发起一次选举。此时服务器1，2，3已经不是LOOKING状态，不会更改选票信息。交换选票信息结果：服务器3为3票，服务器4为1票。此时服务器4服从多数，更改选票信息为服务器3，并更改状态为FOLLOWING；</p> 
<p>（5）服务器5启动，同4一样当小弟</p> 
<h4 id="4.2%20%E9%9D%9E%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%90%AF%E5%8A%A8%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6">4.2 非第一次启动选举机制</h4> 
<p>（1）当ZooKeeper 集群中的一台服务器出现以下两种情况之一时，就会开始进入Leader选举：</p> 
<p><strong>①服务器初始化启动</strong></p> 
<p><strong>②服务器运行期间无法和Leader保持连接</strong></p> 
<p>（2）而当一台机器进入Leader选举流程时，当前集群也可能会处于以下两种状态：</p> 
<p><strong>①集群中本来就已经存在一个Leader</strong></p> 
<p>对于已经存在Leader的情况，机器试图去选举Leader时，会被告知当前服务器的Leader信息，对于该机器来说，仅仅需要和 Leader机器建立连接，并进行状态同步即可</p> 
<p><strong>②集群中确实不存在Leader</strong></p> 
<p>假设ZooKeeper由5台服务器组成，SID分别为1、2、3、4、5，ZXID分别为8、8、8、7、7，并且此时SID为3的服务器是Leader。某一时刻，3和5服务器出现故障，因此开始进行Leader选举。<br> 选举Leader规则：</p> 
<ul><li>Epoch大的直接胜出</li><li>Epoch相同，事务id大的胜出</li><li>事务id相同，服务器id大的胜出</li></ul> 
<blockquote> 
 <p>SID：服务器ID。用来唯一标识一台ZooKeeper集群中的机器，每台机器不能重复，和myid一致<br> ZXID：事务ID。ZXID是一个事务ID，用来标识一次服务器状态的变更。在某一时刻，集群中的每台机器的ZXID值不一定完全一致，这和ZooKeeper服务器对于客户端“更新请求”的处理逻辑速度有关<br> Epoch：每个Leader任期的代号。没有Leader时同一轮投票过程中的逻辑时钟值是相同的。每投完一次票这个数据就会增加</p> 
</blockquote> 
<h3 id="5%E3%80%81Zookeeper%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span style="color:#4d4d4d;">5、Zookeeper 数据结构</span></h3> 
<p>ZooKeeper 的数据模型是基于类似文件系统的层次化命名空间，其中的每个节点称为 Znode。Znode 是 ZooKeeper 中最基本的数据单元，类似于文件系统中的文件或目录。每个 Znode 都可以存储一小段数据，并且可以有子节点，从而形成一个层次化的结构</p> 
<p> ZooKeeper 数据结构的关键特点：</p> 
<ul><li> <p><strong>层次化命名空间</strong>：ZooKeeper 的数据结构是一个树形结构，类似于文件系统的目录结构。每个 Znode 都有一个唯一的路径标识，类似于文件系统中的路径</p> </li><li> <p><strong>每个 Znode 包含的信息</strong>：</p> 
  <ul><li>数据（Data）：每个 Znode 可以存储少量数据，通常用于存储配置信息、状态信息等</li><li>版本号（Version）：每个 Znode 都有一个版本号，用于实现乐观并发控制</li><li>ACL（Access Control List）：每个 Znode 都有一个 ACL，用于控制对该节点的访问权限</li><li>子节点列表：每个 Znode 可以有多个子节点，形成层次化的结构</li></ul></li><li><strong>Watch 机制</strong>：ZooKeeper 提供了 Watch 机制，客户端可以注册 Watch 来监听指定 Znode 的变化。一旦 Znode 发生变化，ZooKeeper 会通知注册了 Watch 的客户端</li><li><strong>临时节点</strong>：ZooKeeper 支持临时节点，当创建临时节点的客户端会话结束时，这些节点会被自动删除。临时节点通常用于实现临时性的状态标记或锁</li></ul> 
<p class="img-center"><img alt="" height="274" src="https://images2.imgbox.com/46/44/u0RSJ56s_o.png" width="700"></p> 
<p>总的来说，ZooKeeper 的数据结构是基于层次化命名空间的 Znode，每个 Znode 包含数据、版本号、ACL 和子节点列表等信息，通过这种数据结构，ZooKeeper 提供了可靠的分布式协调服务</p> 
<h3 id="6%E3%80%81Zookeeper%20%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">6、Zookeeper 应用场景</h3> 
<p>提供的服务包括：统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下线、软负载均衡等</p> 
<ul><li>统一命名服务</li></ul> 
<p>在分布式环境下，经常需要对应用/服务进行统一命名，便于识别。例如：IP不容易记住，而域名容易记住</p> 
<ul><li>统一配置管理</li></ul> 
<p>（1）分布式环境下，配置文件同步非常常见。一般要求一个集群中，所有节点的配置信息是一致的，比如Kafka集群。对配置文件修改后，希望能够快速同步到各个节点上<br> （2）配置管理可交由ZooKeeper实现。可将配置信息写入ZooKeeper上的一个Znode。各个客户端服务器监听这个Znode。一旦 Znode中的数据被修改，ZooKeeper将通知各个客户端服务器</p> 
<ul><li>统一集群管理</li></ul> 
<p>（1）分布式环境中，实时掌握每个节点的状态是必要的。可根据节点实时状态做出一些调整<br> （2）ZooKeeper可以实现实时监控节点状态变化。可将节点信息写入ZooKeeper上的一个ZNode。监听这个ZNode可获取它的实时状态变化</p> 
<ul><li>服务器动态上下线</li></ul> 
<p>客户端能实时洞察到服务器上下线的变化。</p> 
<ul><li>软负载均衡</li></ul> 
<p>在Zookeeper中记录每台服务器的访问数，让访问数最少的服务器去处理最新的客户端请求</p> 
<h2 id="%E4%BA%8C%E3%80%81%E9%83%A8%E7%BD%B2%20Zookeeper%20%E9%9B%86%E7%BE%A4">二、部署 Zookeeper 集群</h2> 
<h3 id="1%E3%80%81%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2">1、环境部署</h3> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="width:109px;"> <p id="%E2%91%A1%E5%AE%89%E8%A3%85zookeeper">服务器ip</p> </td><td style="width:82px;">节点名称</td><td>myid/角色</td><td>软件版本</td><td>jdk版本</td><td>操作系统</td></tr><tr><td style="width:109px;">172.16.12.16</td><td style="width:82px;">zk-kfk01</td><td>1/follow</td><td> <p>zookeeper-3.5.7</p> </td><td>oraclejdk：java version "1.8.0_291"</td><td>centos7.4</td></tr><tr><td style="width:109px;">172.16.12.17</td><td style="width:82px;">zk-kfk02</td><td>2/leader</td><td> <p>zookeeper-3.5.7</p> </td><td>oraclejdk：java version "1.8.0_291"</td><td>centos7.4</td></tr><tr><td style="width:109px;">172.16.12.18</td><td style="width:82px;">zk-kfk03</td><td>3/follow</td><td> <p>zookeeper-3.5.7</p> </td><td>oraclejdk：java version "1.8.0_291"</td><td>centos7.4</td></tr></tbody></table> 
<p><strong>（1）关闭所有设备的防火墙和核心防护</strong></p> 
<pre><code class="language-bash">[root@localhost ~]#systemctl stop firewalld
[root@localhost ~]#setenforce 0</code></pre> 
<p><strong>（2）修改三台设备的主机名</strong></p> 
<pre><code class="language-bash">[root@localhost ~]#hostnamectl set-hostname zk-kfk01
[root@localhost ~]#bash
 
[root@localhost ~]#hostnamectl set-hostname zk-kfk02
[root@localhost ~]#bash
 
[root@localhost ~]#hostnamectl set-hostname zk-kfk03
[root@localhost ~]#bash</code></pre> 
<p><strong>（3）三台设备都需部署java环境，安装oraclejdk</strong></p> 
<pre><code class="language-bash">java -version    #不建议使用openjdk，所以三台设备都需安装oraclejdk</code></pre> 
<p class="img-center"><img alt="" height="118" src="https://images2.imgbox.com/df/f1/w6BKLBxK_o.png" width="700"></p> 
<pre><code class="language-bash"># rpm安装oraclejdk
 
#yum install或rpm -ivh安装oraclejdk
cd /opt    #将rpm软件包传至/opt目录下
rpm -ivh jdk-8u291-linux-x64.rpm
 
#将openjdk更换至oraclejdk
vim /etc/profile.d/jdk.sh
export JAVA_HOME=/usr/java/jdk1.8.0_201-amd64    #输出定义java的工作目录
export CLASSPATH=.:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar   #输出指定java所需的类文件
export PATH=$JAVA_HOME/bin:$PATH   #输出重新定义环境变量，$PATH一定要放在$JAVA_HOME的后面，让系统先读取到工作目录中的版本信息
 
source /etc/profile.d/jdk.sh  #执行配置文件
java -version
----------------------------------------------------------------------------------------
# 二进制包安装oraclejdk
 
cd /opt   #将二进制包传至/opt目录下
tar zxvf jdk-8u291-linux-x64.tar.gz -C /usr/local
ln -s /usr/local/jdk1.8.0_291/ /usr/local/jdk
 
vim /etc/profile.d/jdk.sh
export JAVA_HOME=/usr/local/jdk
export JRE_HOME=${JAVA_HOME}/jre
export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib
export PATH=${JAVA_HOME}/bin:$PATH
 
source /etc/profile.d/jdk.sh
java -version</code></pre> 
<p class="img-center"><img alt="" height="252" src="https://images2.imgbox.com/f2/58/6SFGe8RD_o.png" width="700"></p> 
<h3 id="2%E3%80%81%E5%AE%89%E8%A3%85%C2%A0zookeeper%20%E8%BD%AF%E4%BB%B6" style="background-color:transparent;">2、安装 zookeeper 软件</h3> 
<p><strong>三台节点服务器都要安装zookeeper</strong></p> 
<pre><code class="language-bash">#下载安装包
官方下载地址：https://archive.apache.org/dist/zookeeper/</code></pre> 
<p>下载apache-zookeeper-3.5.7-bin.tar.gz到本地的/opt目录下，进行二进制包解压，无需安装，能直接使用</p> 
<pre><code class="language-bash">cd /opt
wget https://archive.apache.org/dist/zookeeper/zookeeper-3.5.7/apache-zookeeper-3.5.7-bin.tar.gz
tar -zxvf apache-zookeeper-3.5.7-bin.tar.gz
mv apache-zookeeper-3.5.7-bin /usr/local/zookeeper-3.5.7</code></pre> 
<h3 id="3%E3%80%81%E8%AE%BE%E7%BD%AE%E4%B8%BB%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">3、设置主配置文件</h3> 
<p>三台节点服务器都要修改各自的配置文件</p> 
<p>由于三台节点服务器配置文件需要修改的内容一样，修改完zk-kfk01服务器的主配置文件后，将其直接scp远程拷贝到另外两台节点服务器：zk-kfk02和zk-kfk03</p> 
<pre><code class="language-bash">[root@zk-kfk01 opt]#cd /usr/local/zookeeper-3.5.7/conf/
[root@zk-kfk01 conf]#cp zoo_sample.cfg zoo.cfg
[root@zk-kfk01 conf]#vim zoo.cfg     #修改主配置文件
  
tickTime=2000                     
#通信心跳时间，Zookeeper服务器与客户端心跳时间，单位毫秒
initLimit=10                      
#Leader和Follower初始连接时能容忍的最多心跳数（tickTime的数量），这里表示为10*2s
syncLimit=5                       
#Leader和Follower之间同步通信的超时时间，这里表示如果超过5*2s，Leader认为Follwer死掉，并从服务器列表中删除Follwer
dataDir=/usr/local/zookeeper-3.5.7/data    
#修改，指定保存Zookeeper中的数据的目录，目录需要单独创建
dataLogDir=/usr/local/zookeeper-3.5.7/logs  
#添加，指定存放日志的目录，目录需要单独创建
clientPort=2181                   #客户端连：接端口
server.1=172.16.12.16:3188:3288
server.2=172.16.12.17:3188:3288
server.3=172.16.12.18:3188:3288

#解释
server.A=B:C:D
# A是一个数字，表示这个是第几号服务器。集群模式下需要在zoo.cfg中dataDir指定的目录下创建一个文件myid，这个文件里面有一个数据就是A的值，Zookeeper启动时读取此文件，拿到里面的数据与zoo.cfg里面的配置信息比较从而判断到底是哪个server。
# B是这个服务器的地址。
# C是这个服务器Follower与集群中的Leader服务器交换信息的端口。
# D是万一集群中的Leader服务器挂了，需要一个端口来重新进行选举，选出一个新的Leader，而这个端口就是用来执行选举时服务器相互通信的端口。</code></pre> 
<p class="img-center"><img alt="" height="581" src="https://images2.imgbox.com/1c/a0/NKLQHo2o_o.png" width="700"></p> 
<pre><code class="language-bash">#拷贝配置好的 Zookeeper 配置文件到其他节点服务器上
[root@zk-kfk01 conf]# scp zoo.cfg 172.16.12.17:/usr/local/zookeeper-3.5.7/conf/
[root@zk-kfk01 conf]# scp zoo.cfg 172.16.12.18:/usr/local/zookeeper-3.5.7/conf/</code></pre> 
<p><img alt="" height="436" src="https://images2.imgbox.com/1e/61/Q86O5yC6_o.png" width="1200"></p> 
<h3 id="4%E3%80%81%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95%E5%92%8C%E6%97%A5%E5%BF%97%E7%9B%AE%E5%BD%95">4、创建数据目录和日志目录</h3> 
<p>在每个节点上创建数据目录和日志目录</p> 
<pre><code class="language-bash">mkdir /usr/local/zookeeper-3.5.7/data
mkdir /usr/local/zookeeper-3.5.7/logs</code></pre> 
<p class="img-center"><img alt="" height="149" src="https://images2.imgbox.com/f8/f4/oVx47C14_o.png" width="700"></p> 
<h3 id="5%E3%80%81%E5%88%9B%E5%BB%BAmyid%E6%96%87%E4%BB%B6">5、创建myid文件</h3> 
<p>在每个节点的dataDir指定的目录下创建一个 myid 的文件</p> 
<pre><code class="language-bash">[root@zk-kfk01 ~]# echo 1 &gt; /usr/local/zookeeper-3.5.7/data/myid
[root@zk-kfk02 ~]# echo 2 &gt; /usr/local/zookeeper-3.5.7/data/myid
[root@zk-kfk03 ~]# echo 3 &gt; /usr/local/zookeeper-3.5.7/data/myid</code></pre> 
<p class="img-center"><img alt="" height="192" src="https://images2.imgbox.com/4c/58/BzmltFyQ_o.png" width="700"></p> 
<h3 id="6%E3%80%81%E9%85%8D%E7%BD%AE%20Zookeeper%20%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC%E5%B9%B6%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF">6、配置 Zookeeper 启动脚本并设置开机自启</h3> 
<p><strong>配置 Zookeeper 启动脚本：</strong></p> 
<pre><code class="language-bash">[root@zk-kfk01 ~]#vim /etc/init.d/zookeeper
#!/bin/bash
#chkconfig:2345 20 90
#description:Zookeeper Service Control Script
ZK_HOME='/usr/local/zookeeper-3.5.7'
case $1 in
start)
	echo "---------- zookeeper 启动 ------------"
	$ZK_HOME/bin/zkServer.sh start
;;
stop)
	echo "---------- zookeeper 停止 ------------"
	$ZK_HOME/bin/zkServer.sh stop
;;
restart)
	echo "---------- zookeeper 重启 ------------"
	$ZK_HOME/bin/zkServer.sh restart
;;
status)
	echo "---------- zookeeper 状态 ------------"
	$ZK_HOME/bin/zkServer.sh status
;;
*)
    echo "Usage: $0 {start|stop|restart|status}"
esac</code></pre> 
<p class="img-center"><img alt="" height="620" src="https://images2.imgbox.com/4b/f5/i636krrm_o.png" width="700"></p> 
<pre><code class="language-bash">#拷贝写好的zookeeper启动脚本到其他两台节点服务器
[root@zk-kfk01 ~]# scp /etc/init.d/zookeeper 172.16.12.17:/etc/init.d/zookeeper
[root@zk-kfk01 ~]# scp /etc/init.d/zookeeper 172.16.12.18:/etc/init.d/zookeeper</code></pre> 
<p class="img-center"><img alt="" height="71" src="https://images2.imgbox.com/ad/32/wp0Q8otf_o.png" width="700"></p> 
<p><strong>设置开机自启：</strong></p> 
<pre><code class="language-bash">chmod +x /etc/init.d/zookeeper
chkconfig --add zookeeper
# 将 "zookeeper" 服务添加到系统的服务管理列表中，并且配置它在系统启动时自动运行
# 前提创建一个名为 "zookeeper" 的服务脚本（通常是放在 /etc/init.d/ 目录下）</code></pre> 
<h3 id="7%E3%80%81%E5%88%86%E5%88%AB%E5%90%AF%E5%8A%A8%20Zookeeper">7、分别启动 Zookeeper</h3> 
<p>zk-kfk01服务器、zk-kfk02服务器、zk-kfk03服务器依次分别启动</p> 
<pre><code class="language-bash">#分别启动 Zookeeper
service zookeeper start

#查看当前状态
service zookeeper status
</code></pre> 
<p class="img-center"><img alt="" height="886" src="https://images2.imgbox.com/e8/29/5VcgV6Q4_o.png" width="700"></p> 
<h2 id="%E4%B8%89%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88Message%20Queue%EF%BC%89%E6%A6%82%E8%BF%B0">三、消息队列（Message Queue）概述</h2> 
<h3 id="1%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%A6%82%E5%BF%B5">1、消息队列的概念</h3> 
<p>消息队列（Message Queue，简称MQ）是一种用于在应用程序之间传递消息的通信机制。通过消息队列，应用程序可以异步地发送消息给其他应用程序，从而实现解耦、异步通信和提高系统的可靠性和可伸缩性</p> 
<p>消息队列通常包括以下几个重要组件和概念：</p> 
<ul><li> <p><strong>消息</strong>：消息是传递的数据单元，可以是文本、JSON、XML等格式的数据。消息队列通过存储和转发消息来实现应用程序之间的通信</p> </li><li> <p><strong>生产者（Producer）</strong>：生产者是向消息队列发送消息的应用程序。生产者将消息发送到队列中，然后由消费者来消费这些消息</p> </li><li> <p><strong>消费者（Consumer）</strong>：消费者是从消息队列接收消息的应用程序。消费者从队列中获取消息并进行处理</p> </li><li> <p><strong>队列（Queue）</strong>：队列是消息的缓冲区，用于存储消息直到消费者准备好接收并处理它们。消息通常按照先进先出（FIFO）的顺序进行处理</p> </li><li> <p><strong>消息代理（Message Broker）</strong>：消息代理是消息队列系统的核心组件，负责接收、存储和转发消息。消息代理通常提供消息持久化、消息确认、消息路由等功能</p> </li></ul> 
<h3 id="2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">2、为什么使用消息队列</h3> 
<p>主要原因是由于在高并发环境下，同步请求来不及处理，请求往往会发生阻塞。比如大量的请求并发访问数据库，导致行锁表锁，最后请求线程会堆积过多，从而触发 too many connection 错误，引发雪崩效应<br> 我们使用消息队列，通过异步处理请求，从而缓解系统的压力。消息队列常应用于异步处理，流量削峰，应用解耦，消息通讯等场景</p> 
<h3 id="3%E3%80%81%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%A5%BD%E5%A4%84">3、使用消息队列的好处</h3> 
<ul><li><strong>解耦：</strong>允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束</li><li><strong>可恢复性：</strong>系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理</li><li><strong>缓冲：</strong>有助于控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度不一致的情况</li><li><strong>灵活性 &amp; 峰值处理能力：</strong>在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃</li><li><strong>异步通信：</strong>很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们</li></ul> 
<h3 id="4%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6">4、消息队列的异步处理机制</h3> 
<p>消息队列的异步处理机制主要包括以下几个方面：</p> 
<ul><li> <p><strong>生产者-消费者模型</strong>：消息队列采用生产者-消费者模型，生产者负责将消息发送到队列，而消费者则从队列中接收消息进行处理。这种模型实现了消息的异步传递，生产者和消费者之间不需要直接通信，可以独立地进行消息的生产和消费</p> </li><li> <p><strong>消息缓冲</strong>：消息队列作为中间件，可以缓冲消息并持久化存储，等待消费者处理。这样即使消费者不在线或暂时无法处理消息，消息也不会丢失，待消费者准备好后可以继续消费之前的消息</p> </li><li> <p><strong>解耦系统组件</strong>：通过消息队列，系统中的各个组件可以解耦，彼此之间不直接依赖，而是通过消息队列进行通信。这样一来，系统的各个组件可以独立演化和扩展，不会因为某个组件的变化而影响到其他组件</p> </li><li> <p><strong>削峰填谷</strong>：消息队列可以帮助平滑处理系统的消息流量，避免突发的高峰导致系统崩溃。当消息到达时，先存储在消息队列中，然后由消费者按照自身处理能力逐步消费，从而平衡系统的负载</p> </li><li> <p><strong>实现异步通信</strong>：消息队列实现了生产者和消费者之间的异步通信，生产者无需等待消费者的响应即可继续执行其他任务。这种异步通信方式可以提高系统的响应速度和吞吐量</p> </li></ul> 
<p class="img-center"><img alt="" height="341" src="https://images2.imgbox.com/52/ac/HSLjBS35_o.png" width="700"></p> 
<p>通过以上异步处理机制，消息队列在系统架构中扮演着重要的角色，可以提高系统的可靠性、性能和扩展性，同时降低系统的耦合度，适用于各种场景下的消息传递和通信需求</p> 
<h3 id="5%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F">5、消息队列的两种模式</h3> 
<h4 id="5.1%20%E7%82%B9%E5%AF%B9%E7%82%B9%E6%A8%A1%E5%BC%8F"><strong>5.1 点对点模式</strong></h4> 
<p><strong>一对一，消费者主动拉取数据，消息收到后消息清除</strong></p> 
<p>消息生产者生产消息发送到消息队列中，然后消息消费者从消息队列中取出并且消费消息。消息被消费以后，消息队列中不再有存储，所以消息消费者不可能消费到已经被消费的消息。消息队列支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费</p> 
<p><img alt="" height="273" src="https://images2.imgbox.com/a4/b6/4YcQ6csE_o.png" width="973"></p> 
<h4 id="5.2%20%E5%8F%91%E5%B8%83%2F%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"><strong>5.2 发布/订阅模式</strong></h4> 
<p><strong>一对多，又叫观察者模式，消费者消费数据之后不会清除消息</strong></p> 
<p>消息生产者（发布）将消息发布到 topic 中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到 topic 的消息会被所有订阅者消费</p> 
<p>发布/订阅模式是定义对象间一种一对多的依赖关系，使得每当一个对象（目对标象）的状态发生改变，则所有依赖于它的对象（观察者对象）都会得到通知并自动更新</p> 
<p class="img-center"><img alt="" height="470" src="https://images2.imgbox.com/23/96/hEuizyXa_o.png" width="700"></p> 
<h3 id="6%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F">6、常见的消息队列系统</h3> 
<ul><li> <p><strong>RabbitMQ</strong>：RabbitMQ 是一个开源的消息队列系统，采用 Erlang 编程语言开发，支持多种消息协议，如 AMQP、STOMP 和 MQTT。它具有高可靠性、高可用性和良好的性能特点</p> </li><li> <p><strong>Apache Kafka</strong>：Apache Kafka 是一个分布式流处理平台和消息系统，设计用于处理大规模的实时数据流。它支持高吞吐量、水平扩展和持久性存储</p> </li><li> <p><strong>RocketMQ：</strong>RocketMQ 是一个功能强大、性能优越的开源消息队列系统，适用于大规模分布式系统中的消息传输和处理需求。它是阿里巴巴开源的分布式消息队列系统</p> </li><li> <p><strong>ActiveMQ</strong>：ActiveMQ 是一个流行的开源消息代理软件，实现了 JMS（Java Message Service）规范，支持多种传输协议和消息模型</p> </li></ul> 
<h2 id="%E5%9B%9B%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F-Kafka">四、消息队列系统-Kafka</h2> 
<p>Kafka 是一个分布式的基于发布/订阅模式的消息队列（MQ，Message Queue），主要应用于大数据实时处理领域</p> 
<h3 id="1%E3%80%81Kafka%E7%9A%84%E6%A6%82%E5%BF%B5">1、Kafka的概念</h3> 
<p>Kafka 是最初由 Linkedin 公司开发，是一个分布式、支持分区的（partition）、多副本的（replica），基于 Zookeeper 协调的分布式消息中间件系统，它的最大的特性就是可以实时的处理大量数据以满足各种需求场景，比如基于 hadoop 的批处理系统、低延迟的实时系统、Spark/Flink 流式处理引擎，nginx 访问日志，消息服务等等，用 scala 语言编写，<br> Linkedin 于 2010 年贡献给了 Apache 基金会并成为顶级开源项目</p> 
<h3 id="2%E3%80%81Kafka%E7%9A%84%E7%89%B9%E6%80%A7">2、Kafka的特性</h3> 
<ul><li>高吞吐量、低延迟</li></ul> 
<p>Kafka 每秒可以处理几十万条消息，它的延迟最低只有几毫秒。每个 topic 可以分多个 Partition，Consumer Group 对 Partition 进行消费操作，提高负载均衡能力和消费能力。</p> 
<ul><li>可扩展性</li></ul> 
<p>kafka 集群支持热扩展</p> 
<ul><li>持久性、可靠性</li></ul> 
<p>消息被持久化到本地磁盘，并且支持数据备份防止数据丢失</p> 
<ul><li>容错性</li></ul> 
<p>允许集群中节点失败（多副本情况下，若副本数量为 n，则允许 n-1 个节点失败）</p> 
<ul><li>高并发</li></ul> 
<p>支持数千个客户端同时读写</p> 
<h3 id="3%E3%80%81Kafka%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84">3、Kafka系统架构</h3> 
<h4 id="3.1%20%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E5%92%8C%E6%A6%82%E5%BF%B5">3.1 系统架构的核心组件和概念</h4> 
<ul><li><strong>服务器节点（Broker）</strong></li></ul> 
<p>一台 kafka 服务器就是一个 broker</p> 
<p>一个集群由多个 broker 组成。一个 broker 可以容纳多个 topic</p> 
<p>broker 是消息的代理，Producers往Brokers里面的指定Topic中写消息，Consumers从Brokers里面拉取指定Topic的消息，然后进行业务处理，broker在中间起到一个代理保存消息的中转站</p> 
<ul><li> <p><strong>主题（Topic）</strong></p> </li></ul> 
<p>主题是消息的分类，每条消息都会被发布到一个特定的主题。主题在 Kafka 中起到消息的逻辑容器，不同主题之间相互独立。生产者和消费者面向的都是一个 topic。类似于数据库的表名或者 ES 的 index。物理上不同 topic 的消息分开存储</p> 
<ul><li> <p><strong>分区（Partition）</strong></p> </li></ul> 
<p>每个主题可以分成一个或多个分区，分区是消息存储的基本单元。消息在分区内顺序存储，每条消息都有一个在分区内唯一的偏移量（offset）</p> 
<p>为了实现扩展性，一个非常大的 topic 可以分布到多个 broker（即服务器）上，一个 topic 可以分割为一个或多个 partition，每个 partition 是一个有序的队列。Kafka 只保证 partition 内的记录是有序的，而不保证 topic 中不同 partition 的顺序</p> 
<p>每个 topic 至少有一个 partition，当生产者产生数据的时候，会根据分配策略选择分区，然后将消息追加到指定的分区的队列末尾</p> 
<p>每条消息都会有一个自增的编号，用于标识消息的偏移量，标识顺序从 0 开始</p> 
<p>每个 partition 中的数据使用多个 segment 文件存储</p> 
<p>如果 topic 有多个 partition，消费数据时就不能保证数据的顺序。严格保证消息的消费顺序的场景下（例如商品秒杀、 抢红包），需要将 partition 数目设为 1 </p> 
<blockquote> 
 <p>Partation 数据路由规则：<br> ① 指定了 patition，则直接使用<br> ② 未指定 patition 但指定 key（相当于消息中某个属性），通过对 key 的 value 进行 hash 取模，选出一个 patition<br> ③ patition 和 key 都未指定，使用轮询选出一个 patition</p> 
</blockquote> 
<p class="img-center"><img alt="" height="487" src="https://images2.imgbox.com/28/e7/VgDxURhJ_o.png" width="700"></p> 
<blockquote> 
 <p><strong>总结：</strong></p> 
 <ul><li>broker 存储 topic 的数据。如果某 topic 有 N 个 partition，集群有 N 个 broker，那么每个 broker 存储该 topic 的一个 partition</li><li>如果某 topic 有 N 个 partition，集群有 (N+M) 个 broker，那么其中有 N 个 broker 存储 topic 的一个 partition， 剩下的 M 个 broker 不存储该 topic 的 partition 数据</li><li>如果某 topic 有 N 个 partition，集群中 broker 数目少于 N 个，那么一个 broker 存储该 topic 的一个或多个 partition。在实际生产环境中，尽量避免这种情况的发生，这种情况容易导致 Kafka 集群数据不均衡</li></ul> 
</blockquote> 
<ul><li><strong>副本（Replica）</strong></li></ul> 
<p>副本，为保证集群中的某个节点发生故障时，该节点上的 partition 数据不丢失，且 kafka 仍然能够继续工作，kafka 提供了副本机制，一个 topic 的每个分区都有若干个副本，一个 leader 和若干个 follower</p> 
<ul><li><strong>领导者（Leader）</strong></li></ul> 
<p>每个 partition 有多个副本，其中有且仅有一个作为 Leader，Leader 是当前负责数据的读写的 partition</p> 
<ul><li><strong>追随者（Follower）</strong></li></ul> 
<p>Follower 跟随 Leader，所有写请求都通过 Leader 路由，数据变更会广播给所有 Follower，Follower 与 Leader 保持数据同步</p> 
<p>Follower 只负责备份，不负责数据的读写</p> 
<p>如果 Leader 故障，则从 Follower 中选举出一个新的 Leader</p> 
<p>当 Follower 挂掉、卡住或者同步太慢，Leader 会把这个 Follower 从 ISR（Leader 维护的一个和 Leader 保持同步的 Follower 集合） 列表中删除，重新创建一个 Follower</p> 
<ul><li><strong>生产者（Producer）</strong></li></ul> 
<p>生产者即数据的发布者，该角色将消息 push 发布到 Kafka 的 topic 中</p> 
<p>broker 接收到生产者发送的消息后，broker 将该消息追加到当前用于追加数据的 segment 文件中</p> 
<p>生产者发送的消息，存储到一个 partition 中，生产者也可以指定数据存储的 partition</p> 
<ul><li> <p><strong>消费者（Consumer）</strong></p> </li></ul> 
<p>消费者可以从 broker 中 pull 拉取数据。消费者可以消费多个 topic 中的数据</p> 
<ul><li><strong>消费者组（Consumer Group）</strong></li></ul> 
<p>消费者组，由多个 消费者（Consumer） 组成</p> 
<p>所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。可为每个消费者指定组名，若不指定组名则属于默认的组</p> 
<p>将多个消费者集中到一起去处理某一个 Topic 的数据，可以更快的提高数据的消费能力</p> 
<p>消费者组内每个消费者负责消费不同分区的数据，一个分区只能由一个组内消费者消费，防止数据被重复读取</p> 
<p>消费者组之间互不影响</p> 
<ul><li><strong>偏移量（Offset）</strong></li></ul> 
<p>偏移量是消息在分区中的唯一标识</p> 
<p>偏移量决定读取数据的位置，不会有线程安全的问题，消费者通过偏移量来决定下次读取的消息（即消费位置）</p> 
<p>消息被消费之后，并不被马上删除，这样多个业务就可以重复使用 Kafka 的消息</p> 
<p>某一个业务也可以通过修改偏移量达到重新读取消息的目的，偏移量由用户控制</p> 
<p>消息最终还是会被删除的，默认生命周期为 1 周（7*24小时）</p> 
<ul><li><strong>ZooKeeper</strong></li></ul> 
<p>Kafka 通过 Zookeeper 来存储集群的 meta 信息</p> 
<p>由于 consumer 在消费过程中可能会出现断电宕机等故障，consumer 恢复后，需要从故障前的位置的继续消费，所以 consumer 需要实时记录自己消费到了哪个 offset，以便故障恢复后继续消费</p> 
<p>Kafka 0.9 版本之前，consumer 默认将 offset 保存在 Zookeeper 中；从 0.9 版本开始，consumer 默认将 offset 保存在 Kafka 一个内置的 topic 中，该 topic 为 __consumer_offsets</p> 
<p>也就是说，zookeeper的作用就是，生产者push数据到kafka集群，就必须要找到kafka集群的节点在哪里，这些都是通过zookeeper去寻找的。消费者消费哪一条数据，也需要zookeeper的支持，从zookeeper获得offset，offset记录上一次消费的数据消费到哪里，这样就可以接着下一条数据进行消费</p> 
<h4 id="3.2%C2%A0Kafka%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">3.2 Kafka工作流程</h4> 
<p class="img-center"><img alt="" height="473" src="https://images2.imgbox.com/d3/4c/5ChYGEo7_o.png" width="700"></p> 
<ul><li>生产者生产数据传给broker即kafka服务器集群</li><li>kafka集群将数据存储在topic主题中，每个topic主题中有多个分片(分片做了备份在其他topic)</li><li>分片中存储数据，kafka集群注册在zookeeper中，zookeeper通知消费者kafka服务器在线列表</li><li>消费者收到zookeeper通知的在线列表，从broker中拉取数据</li><li>消费者保存偏移量到zookeeper中，以便记录自己宕机消费到什么地方</li></ul> 
<h3 id="4%E3%80%81kafka%E7%9A%84follower%E5%A6%82%E4%BD%95%E4%B8%8Eleader%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE">4、kafka的follower如何与leader同步数据</h3> 
<p>Kafka的复制机制既不是完全的同步复制，也不是单纯的异步复制。完全同步复制要求All Alive Follower都复制完，这条消息才会被认为commit，这种复制方式极大的影响了吞吐率。</p> 
<p>而异步复制方式下，Follower异步的从Leader复制数据，数据只要被Leader写入log就被认为已经commit，这种情况下，如果leader挂掉，会丢失数据，kafka使用ISR的方式很好的均衡了确保数据不丢失以及吞吐率。</p> 
<p>Follower可以批量的从Leader复制数据，而且Leader充分利用磁盘顺序读以及send file(zero copy)机制，这样极大的提高复制性能，内部批量写磁盘，大幅减少了Follower与Leader的消息量差</p> 
<h3 id="4%E3%80%81Kafka%E5%88%86%E5%8C%BA%E7%9A%84%E5%8E%9F%E5%9B%A0">5、Kafka分区的原因</h3> 
<ul><li>方便在集群中扩展，每个Partition可以通过调整以适应它所在的机器，而一个topic又可以有多个Partition组成，因此整个集群就可以适应任意大小的数据了</li><li>可以提高并发，因为可以以Partition为单位读写了</li></ul> 
<h3 id="6%E3%80%81Kafka%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6">6、Kafka文件存储机制</h3> 
<p>Kafka 中消息是以 topic 进行分类的，生产者生产消息，消费者消费消息，都是面向 topic 的</p> 
<p>topic 是逻辑上的概念，而 partition 是物理上的概念，每个 partition 对应于一个 log 文件，该 log 文件中存储的就是 producer 生产的数据。Producer 生产的数据会被不断追加到该 log 文件末端，且每条数据都有自己的 offset。 消费者组中的每个消费者，都会实时记录自己消费到了哪个 offset，以便出错恢复时，从上次的位置继续消费</p> 
<p>由于生产者生产的消息会不断追加到 log 文件末尾，为防止 log 文件过大导致数据定位效率低下，Kafka 采取了分片和索引机制，将每个 partition 分为多个 segment。每个 segment 对应两个文件：“.index” 文件和 “.log” 文件。这些文件位于一个文件夹下，该文件夹的命名规则为：topic名称+分区序号。例如，test 这个 topic 有三个分区， 则其对应的文件夹为 test-0、test-1、test-2</p> 
<p>index 和 log 文件以当前 segment 的第一条消息的 offset 命名</p> 
<p>“.index” 文件存储大量的索引信息，“.log” 文件存储大量的数据，索引文件中的元数据指向对应数据文件中 message 的物理偏移地址</p> 
<h3 id="7%E3%80%81%E6%95%B0%E6%8D%AE%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BF%9D%E8%AF%81">7、数据可靠性保证</h3> 
<p>为保证 producer 发送的数据，能可靠的发送到指定的 topic，topic 的每个 partition 收到 producer 发送的数据后， 都需要向 producer 发送 ack（acknowledgement 确认收到），如果 producer 收到 ack，就会进行下一轮的发送，否则重新发送数据</p> 
<h3 id="8%E3%80%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98">8、数据一致性问题</h3> 
<p>LEO：指的是每个副本最大的 offset； <br> HW：指的是消费者能见到的最大的 offset，所有副本中最小的 LEO。</p> 
<p>（1）follower 故障 <br> follower 发生故障后会被临时踢出 ISR（Leader 维护的一个和 Leader 保持同步的 Follower 集合），待该 follower 恢复后，follower 会读取本地磁盘记录的上次的 HW，并将 log 文件高于 HW 的部分截取掉，从 HW 开始向 leader 进行同步。等该 follower 的 LEO 大于等于该 Partition 的 HW，即 follower 追上 leader 之后，就可以重新加入 ISR 了。</p> 
<p>（2）leader 故障 <br> leader 发生故障之后，会从 ISR 中选出一个新的 leader， 之后，为保证多个副本之间的数据一致性，其余的 follower 会先将各自的 log 文件高于 HW 的部分截掉，然后从新的 leader 同步数据。</p> 
<p>注：这只能保证副本之间的数据一致性，并不能保证数据不丢失或者不重复。 </p> 
<h3 id="9%E3%80%81ack%20%E5%BA%94%E7%AD%94%E6%9C%BA%E5%88%B6">9、ack 应答机制</h3> 
<p>对于某些不太重要的数据，对数据的可靠性要求不是很高，能够容忍数据的少量丢失，所以没必要等 ISR 中的 follower 全部接收成功。所以 Kafka 为用户提供了三种可靠性级别，用户根据对可靠性和延迟的要求进行权衡选择。</p> 
<p>当 producer 向 leader 发送数据时，可以通过 request.required.acks 参数来设置数据可靠性的级别：</p> 
<ul><li>0：这意味着producer无需等待来自broker的确认而继续发送下一批消息。这种情况下数据传输效率最高，但是数据可靠性确是最低的。当broker故障时有可能丢失数据</li><li>1（默认配置）：这意味着producer在ISR中的leader已成功收到的数据并得到确认后发送下一条message。如果在follower同步成功之前leader故障，那么将会丢失数据</li><li>-1（或者是all）：producer需要等待ISR中的所有follower都确认接收到数据后才算一次发送完成，可靠性最高。但是如果在 follower 同步完成后，broker 发送ack 之前，leader 发生故障，那么会造成数据重复</li></ul> 
<p>三种机制性能依次递减，数据可靠性依次递增</p> 
<blockquote> 
 <p>注：在 0.11 版本以前的Kafka，对此是无能为力的，只能保证数据不丢失，再在下游消费者对数据做全局去重。在 0.11 及以后版本的 Kafka，引入了一项重大特性：幂等性。所谓的幂等性就是指 Producer 不论向 Server 发送多少次重复数据， Server 端都只会持久化一条</p> 
</blockquote> 
<h2 id="%E4%BA%94%E3%80%81%E9%83%A8%E7%BD%B2%20kafka%20%E9%9B%86%E7%BE%A4">五、部署 kafka 集群</h2> 
<h3 style="background-color:transparent;">1、环境部署</h3> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="width:109px;"> <p id="%E2%91%A1%E5%AE%89%E8%A3%85zookeeper">服务器ip</p> </td><td style="width:82px;">节点名称</td><td>myid/角色</td><td>软件版本</td><td>jdk版本</td><td>操作系统</td></tr><tr><td style="width:109px;">172.16.12.16</td><td style="width:82px;">zk-kfk01</td><td>1/follow</td><td> <p>zookeeper-3.5.7</p> <p>kafka_2.13-2.7.1</p> </td><td>oraclejdk：java version "1.8.0_291"</td><td>centos7.4</td></tr><tr><td style="width:109px;">172.16.12.17</td><td style="width:82px;">zk-kfk02</td><td>2/leader</td><td> <p>zookeeper-3.5.7</p> <p>kafka_2.13-2.7.1</p> </td><td>oraclejdk：java version "1.8.0_291"</td><td>centos7.4</td></tr><tr><td style="width:109px;">172.16.12.18</td><td style="width:82px;">zk-kfk03</td><td>3/follow</td><td> <p>zookeeper-3.5.7</p> <p>kafka_2.13-2.7.1</p> </td><td>oraclejdk：java version "1.8.0_291"</td><td>centos7.4</td></tr></tbody></table> 
<p><span style="color:#fe2c24;"><strong>在上面 Zookeeper集群 搭建成功的环境下，需要部署 kafka集群</strong></span></p> 
<h3 id="2%E3%80%81%E5%AE%89%E8%A3%85%20kafka%20%E8%BD%AF%E4%BB%B6" style="background-color:transparent;">2、安装 kafka 软件</h3> 
<p><strong>三台节点服务器都要安装kafka</strong></p> 
<pre><code class="language-bash">#下载安装包
官方下载地址：http://kafka.apache.org/downloads.html</code></pre> 
<p class="img-center"><img alt="" height="387" src="https://images2.imgbox.com/f8/6a/1dFrys7E_o.png" width="700"></p> 
<p>上传kafka_2.13-2.7.1.tgz到本地的/opt目录下，进行二进制包解压，无需安装，能直接使用 </p> 
<pre><code class="language-bash">cd /opt       #上传kafka_2.13-2.7.1.tgz到本地的/opt目录下
tar zxvf kafka_2.13-2.7.1.tgz
mv kafka_2.13-2.7.1 /usr/local/kafka</code></pre> 
<h3 id="3%E3%80%81%E4%BF%AE%E6%94%B9%E4%B8%BB%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">3、修改主配置文件</h3> 
<p>三台节点服务器都需要修改主配置文件</p> 
<p>修改完zk-kfk01服务器的主配置文件后，将其直接scp远程拷贝到另外两台节点服务器：zk-kfk02和zk-kfk03，注意修改另外两台节点服务器的 broker.id 和 listeners 地址</p> 
<pre><code class="language-bash">[root@zk-kfk01 opt]#cd /usr/local/kafka/config/
[root@zk-kfk01 config]#cp server.properties{,.bak}
[root@zk-kfk01 config]#vim server.properties

broker.id=0    
#21行，broker的全局唯一编号，每个broker不能重复，因此要在其他节点服务器上配置 broker.id=1、broker.id=2
listeners=PLAINTEXT://172.16.12.16:9092
#31行，指定监听的IP和端口，如果修改每个broker的IP需区分开来，也可保持默认配置不用修改
num.network.threads=3    
#42行，broker 处理网络请求的线程数量，一般情况下不需要去修改
num.io.threads=8         
#45行，用来处理磁盘IO的线程数量，数值应该大于硬盘数
socket.send.buffer.bytes=102400       #48行，发送套接字的缓冲区大小
socket.receive.buffer.bytes=102400    #51行，接收套接字的缓冲区大小
socket.request.max.bytes=104857600    #54行，请求套接字的缓冲区大小
log.dirs=/usr/local/kafka/logs        #60行，kafka运行日志存放的路径，也是数据存放的路径
num.partitions=1    
#65行，topic在当前broker上的默认分区个数，会被topic创建时的指定参数覆盖
num.recovery.threads.per.data.dir=1    #69行，用来恢复和清理data下数据的线程数量
log.retention.hours=168    
#103行，segment文件（数据文件）保留的最长时间，单位为小时，默认为7天，超时将被删除
log.segment.bytes=1073741824    
#110行，一个segment文件最大的大小，默认为 1G，超出将新建一个新的segment文件
zookeeper.connect=172.16.12.16:2181,172.16.12.17:2181,172.16.12.18:2181    
#123行，配置连接Zookeeper集群地址</code></pre> 
<p class="img-center"><img alt="" height="648" src="https://images2.imgbox.com/97/3b/MXyefYGo_o.png" width="700"></p> 
<pre><code class="language-bash">[root@zk-kfk01 config]# scp server.properties 172.16.12.17:/usr/local/kafka/config/
[root@zk-kfk01 config]# scp server.properties 172.16.12.18:/usr/local/kafka/config/</code></pre> 
<p class="img-center"><img alt="" height="255" src="https://images2.imgbox.com/88/7f/Ze5J7mjG_o.png" width="700"></p> 
<p class="img-center"><img alt="" height="104" src="https://images2.imgbox.com/81/75/0IXIkgoq_o.png" width="700"></p> 
<p class="img-center"><img alt="" height="114" src="https://images2.imgbox.com/d6/a5/0OtUZvxe_o.png" width="700"></p> 
<h3 id="4%E3%80%81%E4%BF%AE%E6%94%B9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">4、修改环境变量</h3> 
<pre><code class="language-bash">vim /etc/profile
export KAFKA_HOME=/usr/local/kafka
export PATH=$PATH:$KAFKA_HOME/bin

source /etc/profile</code></pre> 
<h3 id="5%E3%80%81%E9%85%8D%E7%BD%AE%20Zookeeper%20%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC%E5%B9%B6%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF">5、配置 Zookeeper 启动脚本并设置开机自启</h3> 
<p><strong>配置 Zookeeper 启动脚本：</strong></p> 
<pre><code class="language-bash">[root@zk-kfk01 ~]#vim /etc/init.d/kafka
#!/bin/bash
#chkconfig:2345 22 88
#description:Kafka Service Control Script
KAFKA_HOME='/usr/local/kafka'
case $1 in
start)
	echo "---------- Kafka 启动 ------------"
	${KAFKA_HOME}/bin/kafka-server-start.sh -daemon ${KAFKA_HOME}/config/server.properties
;;
stop)
	echo "---------- Kafka 停止 ------------"
	${KAFKA_HOME}/bin/kafka-server-stop.sh
;;
restart)
	$0 stop
	$0 start
;;
status)
	echo "---------- Kafka 状态 ------------"
	count=$(ps -ef | grep kafka | egrep -cv "grep|$$")
	if [ "$count" -eq 0 ];then
        echo "kafka is not running"
    else
        echo "kafka is running"
    fi
;;
*)
    echo "Usage: $0 {start|stop|restart|status}"
esac</code></pre> 
<p class="img-center"><img alt="" height="474" src="https://images2.imgbox.com/1b/a0/xbF5IB51_o.png" width="700"></p> 
<pre><code class="language-bash">#拷贝写好的zookeeper启动脚本到其他两台节点服务器
[root@zk-kfk01 ~]# scp /etc/init.d/kafka 172.16.12.17:/etc/init.d/kafka
[root@zk-kfk01 ~]# scp /etc/init.d/kafka 172.16.12.18:/etc/init.d/kafka</code></pre> 
<p><img alt="" height="130" src="https://images2.imgbox.com/ae/56/4dMo0fYN_o.png" width="740"> <strong>设置开机自启： </strong>  </p> 
<pre><code class="language-bash">chmod +x /etc/init.d/kafka
chkconfig --add kafka
# 将 "kafka" 服务添加到系统的服务管理列表中，并且配置它在系统启动时自动运行
# 前提创建一个名为 "kafka" 的服务脚本（通常是放在 /etc/init.d/ 目录下）</code></pre> 
<h3 id="6%E3%80%81%C2%A0%E5%88%86%E5%88%AB%E5%90%AF%E5%8A%A8%20Kafka">6、 分别启动 Kafka</h3> 
<p> zk-kfk01服务器、zk-kfk02服务器、zk-kfk03服务器依次分别启动</p> 
<pre><code class="language-bash">#分别启动 Kafka
service kafka start

#查看当前状态
service kafka status</code></pre> 
<p class="img-center"><img alt="" height="510" src="https://images2.imgbox.com/8a/e4/p9r1OemX_o.png" width="700"></p> 
<h3 id="7%E3%80%81Kafka%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C">7、Kafka 命令行操作</h3> 
<h4 id="7.1%20%E5%88%9B%E5%BB%BA%20Kafka%20%E4%B8%BB%E9%A2%98%E5%B9%B6%E6%9F%A5%E7%9C%8B%E4%B8%BB%E9%A2%98">7.1 创建 Kafka 主题并查看主题</h4> 
<p>（1）创建一个名为 "test" 的 Kafka 主题（topic）：任意一台机器即可</p> 
<pre><code class="language-bash">kafka-topics.sh --create --zookeeper 192.168.190.104:2181,192.168.190.105:2181,192.168.190.106:2181 --replication-factor 2 --partitions 3 --topic test

# kafka-topics.sh: 这是 Kafka 提供的一个脚本工具，用于管理 Kafka 中的主题。
# --create: 这是告诉 kafka-topics.sh 要创建一个新的主题。
# --zookeeper 192.168.190.104:2181,192.168.190.105:2181,192.168.190.106:2181: 这是指定 ZooKeeper 的连接信息，用于管理 Kafka 集群。在这里，指定了三个 ZooKeeper 实例的地址和端口号。
# --replication-factor 2: 这表示设置每个分区的副本数量为 2。副本是为了数据的冗余和容错性而存在的。
# --partitions 3: 这表示要创建 3 个分区。
# --topic test: 这表示要创建一个名为 "test" 的主题。
# 在 Kafka 集群中创建一个名为 "test" 的主题，该主题有 3 个分区，并且每个分区有 2 个副本。</code></pre> 
<p class="img-center"><img alt="" height="60" src="https://images2.imgbox.com/c3/71/REVXrU7b_o.png" width="700"></p> 
<p>（2） 查看当前服务器中的所有 topic</p> 
<pre><code class="language-bash">kafka-topics.sh --list --zookeeper 172.16.12.16:2181,172.16.12.17:2181,172.16.12.18:2181</code></pre> 
<p>（3） 查看 test topic 的详情</p> 
<pre><code class="language-bash">kafka-topics.sh --describe --zookeeper 172.16.12.16:2181,172.16.12.17:2181,172.16.12.18:2181 test

Topic: test	PartitionCount: 3	ReplicationFactor: 2	Configs:  
# 表示主题 "test" 共有 3 个分区。每个分区的复制因子为 2，即每个分区都有两个副本
	Topic: test	Partition: 0	Leader: 0	Replicas: 0,2	Isr: 0,2
	Topic: test	Partition: 1	Leader: 1	Replicas: 1,0	Isr: 1,0
	Topic: test	Partition: 2	Leader: 2	Replicas: 2,1	Isr: 2,1
# Partition: x 指明了每个分区的编号。
# Leader: x 显示了每个分区的 leader 副本所在的 broker 编号。
# Replicas: x,y 展示了每个分区的所有副本所在的 broker 编号。
# Isr: x,y 描述了每个分区的“在同步副本集”（In-Sync Replica）中的副本编号</code></pre> 
<p class="img-center"><img alt="" height="79" src="https://images2.imgbox.com/32/b1/TB47P0IR_o.png" width="700"></p> 
<h4 id="7.2%20%E5%8F%91%E5%B8%83%E4%B8%8E%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF">7.2 发布与消费消息</h4> 
<p>发布消息：</p> 
<pre><code class="language-bash">kafka-console-producer.sh --broker-list 172.16.12.16:9092,172.16.12.17:9092,172.16.12.18:9092  --topic test</code></pre> 
<p>消费消息： </p> 
<pre><code class="language-bash">kafka-console-consumer.sh --bootstrap-server 172.16.12.16:9092,172.16.12.17:9092,172.16.12.18:9092 --topic test --from-beginning</code></pre> 
<p class="img-center"><img alt="" height="113" src="https://images2.imgbox.com/fa/ab/cWcTUCca_o.png" width="700"></p> 
<pre><code class="language-bash">'zkfkf-01模拟发布消息'
kafka-console-producer.sh
#Kafka提供的一个命令行工具，用于模拟生产者发送消息到Kafka集群。
 
--broker-list 172.16.12.16:9092,172.16.12.17:9092,172.16.12.18:9092
#指定了Kafka集群的Broker列表，包含了三个Broker节点的IP地址和端口号。
#生产者会随机选择这些Broker之一进行消息发布。
 
--topic test
#指定要发送消息到的主题名称为test。一旦命令执行成功，控制台将变成一个可以输入消息的环境
#用户每输入一行文本并按下回车键，这一行文本就会作为一条消息发送到指定的test主题
 
 
'zkfkf-02消费消息'
kafka-console-consumer.sh
#Kafka提供的一个命令行工具，用于模拟消费者从Kafka集群中读取消息。
 
--bootstrap-server 172.16.12.16:9092,172.16.12.17:9092,172.16.12.18:9092
#指定了Kafka集群的Broker列表，消费者会通过这些Broker连接到集群以获取消息。
#当消费者启动时，它首先会与bootstrap服务器建立连接，然后发现集群中的其他Broker和分区信息。
 
--topic test
#指定要消费的主题名称为test。消费者将从这个主题中读取消息并显示在命令行终端上。
 
--from-beginning
#消费者在启动时，会从指定主题的起始位置开始消费消息，而不是只消费最新产生的消息。
#这意味着消费者会读取主题中存在的所有历史消息。</code></pre> 
<h4 id="7.3%C2%A0%E4%BF%AE%E6%94%B9%E5%88%86%E5%8C%BA%E6%95%B0">7.3 修改分区数</h4> 
<pre><code class="language-bash">kafka-topics.sh --zookeeper 172.16.12.16:2181,172.16.12.17:2181,172.16.12.18:2181 --alter --topic test --partitions 6
#修改该主题为六个分区

kafka-topics.sh --describe --zookeeper 172.16.12.16:2181,172.16.12.17:2181,172.16.12.18:2181 test
#查看指定主题的详细信息</code></pre> 
<p class="img-center"><img alt="" height="157" src="https://images2.imgbox.com/68/f6/mQliB53h_o.png" width="700"></p> 
<h4 id="7.4%C2%A0%E5%88%A0%E9%99%A4%E4%B8%BB%E9%A2%98%EF%BC%88topic%EF%BC%89">7.4 删除主题（topic）</h4> 
<pre><code class="language-bash">#删除 topic
kafka-topics.sh --delete --zookeeper 172.16.12.16:2181,172.16.12.17:2181,172.16.12.18:2181 --topic test</code></pre> 
<p class="img-center"><img alt="" height="131" src="https://images2.imgbox.com/05/bc/XTNKuruj_o.png" width="700"></p> 
<h2 id="%E5%85%AD%E3%80%81%E5%88%9B%E5%BB%BA%E4%B8%BB%E9%A2%98%E4%B8%80%E8%88%AC%E6%95%85%E9%9A%9C%C2%A0" style="background-color:transparent;">六、创建主题一般故障 </h2> 
<p><strong>故障示例：</strong></p> 
<pre><code class="language-bash">[root@zk-kfk01 ~]#kafka-topics.sh --create --zookeeper 172.16.12.16:2181,172.16.12.17:2181,172.16.12.18:2181 --replication-factor 2 --partitions 3 --topic test
Error while executing topic command : Replication factor: 2 larger than available brokers: 0.
[2024-04-13 20:17:55,154] ERROR org.apache.kafka.common.errors.InvalidReplicationFactorException: Replication factor: 2 larger than available brokers: 0.

# 指定的副本因子大于可用的 broker 数量。这可能是由于 ZooKeeper 中注册的 broker 数量与实际运行的 broker 数量不匹配导致的。</code></pre> 
<p><strong>排查过程：</strong></p> 
<p>① 确保 broker 数量足够</p> 
<p>② 查看 server.properties 配置</p> 
<pre><code class="language-bash">broker.id         
listeners=PLAINTEXT://ip:9092
确保编号唯一；监听地址是否正确</code></pre> 
<p>③ 查看端口是否正常</p> 
<pre><code class="language-bash">telenet 主机名 2181</code></pre> 
<p>④ 关闭 kafka，再挨个启动</p> 
<pre><code class="language-bash">service kafka stop
service kafka start</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/004eee71b969ecaac75dc22748ebddff/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JAVA与人工智能：开发未来的AI</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/98b901bcc3cb8ef6da87a1d990b80204/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【AIGC调研系列】Phi-3 VS Llama3</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>