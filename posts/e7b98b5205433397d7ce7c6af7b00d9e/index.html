<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>嵌入式学习day8（C基础函数） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/e7b98b5205433397d7ce7c6af7b00d9e/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="嵌入式学习day8（C基础函数）">
  <meta property="og:description" content="一丶函数 定义： 一个可以完成特定功能的代码模块 函数可以实现代码的复用
三要素： 功能，参数，返回值
格式： 存储类型 数据类型 函数名(参数列表) // 参数 形参
{
函数体; // 功能
return 返回值; // 返回值
}
注意：（1) 没有参数：参数列表可以省略，也可以用 void
（2) 没有返回值：数据类型为 void，函数内部没有return语句
（3) 有返回值：要根据返回值的数据类型定义函数的数据类型
（4) 定义子函数时可以直接定义在主函数的上面，如果定义在主函数下面需要提前声明函数，声明函数：数据类型 函数名(参数列表); // 形参
形参和实参的区别：
形参是函数定义时，定义的形参变量。是形式上存在的参数，只有在电泳函数时才会开辟内存空间。
实参是调用函数时，实际传递的值。实际存在的值。
形参的个数要和实参的个数一一对应（数据类型也要对应）
特点： 函数不调用不执行， 函数调用多次就会执行多次
函数的传参： 1.值传递： 单向传递（实参---&gt;形参）修改形参的值 实参不会发生变化
#include&lt;stdio.h&gt; int fun(int a,int b) { int sum; sum = a &#43; b; return sum; } int main(int argc, char const *argv[]) { int a = 10; int b =20; int sum = fun(a,b); //a,b传参给函数后，a，b的值并不会发生改变 printf(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-03T21:21:20+08:00">
    <meta property="article:modified_time" content="2024-08-03T21:21:20+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">嵌入式学习day8（C基础函数）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><img alt="" height="1200" src="https://images2.imgbox.com/bd/1c/RtJKCzkt_o.jpg" width="1200"></h2> 
<h2><img alt="" height="1180" src="https://images2.imgbox.com/88/bf/9jgcdinx_o.jpg" width="1200"></h2> 
<h2>一丶函数</h2> 
<h3>  定义：</h3> 
<p><span style="color:#000000;"><span style="color:#333333;">           一个可以完成特定功能的代码模块 函数可以实现代码的复用</span></span></p> 
<h3><span style="color:#333333;">  三要素：</span></h3> 
<p><span style="color:#333333;">             功能，参数，返回值</span></p> 
<h3><span style="color:#333333;">  格式：</span></h3> 
<div> 
 <div> 
  <p style="margin-left:0;text-align:left;"><span style="color:#000000;"><span style="color:#333333;">              存储类型 数据类型 函数名(参数列表) // 参数 形参</span></span></p> 
  <p style="margin-left:0;text-align:left;"><span style="color:#000000;"><span style="color:#333333;">                {<!-- --></span></span></p> 
  <p style="margin-left:0;text-align:left;"><span style="color:#000000;"><span style="color:#333333;">                  函数体; // 功能</span></span></p> 
  <p style="margin-left:0;text-align:left;"><span style="color:#000000;"><span style="color:#333333;">                  return 返回值; // 返回值</span></span></p> 
  <p style="margin-left:0;text-align:left;"><span style="color:#000000;"><span style="color:#333333;">                 }<br>             注意：（</span>1)  <span style="color:#333333;">没有参数：参数列表可以省略，也可以用 void</span><br>                        （2)  <span style="color:#333333;">没有返回值：数据类型为 void，函数内部没有return语句</span><br>                        （3)  <span style="color:#333333;">有返回值：要根据返回值的数据类型定义函数的数据类型</span><br>                        （4)  <span style="color:#333333;">定义子函数时可以直接定义在主函数的上面，如果定义在主函数下面需要提前声明函数，声明函数：</span></span><span style="color:#000000;"><span style="color:#333333;">数据类型 函数名(参数列表); // </span><span style="color:#00a3f5;">形参</span></span></p> 
  <p style="margin-left:0;text-align:left;">            形参和实参的区别：<br>                         <span style="color:#000000;"><span style="color:#333333;">形参是函数定义时，定义的形参变量。是形式上存在的参数，只有在电泳函数时才会开辟内存空间。<br>                         实参是调用函数时，实际传递的值。实际存在的值。<br>                         </span></span>形参的个数要和实参的个数一一对应（数据类型也要对应）</p> 
 </div> 
</div> 
<h3><span style="color:#333333;">  特点：</span></h3> 
<p><span style="color:#000000;">         <span style="color:#333333;">函数不调用不执行，</span> <span style="color:#333333;">函数</span><span style="color:#333333;">调用</span><span style="color:#333333;">多次</span><span style="color:#333333;">就会</span><span style="color:#333333;">执行</span><span style="color:#333333;">多次</span></span></p> 
<h3>函数的传参：</h3> 
<h4>        1.值传递：</h4> 
<p>                   <span style="color:#000000;"><span style="color:#333333;">单向传递（实参---&gt;形参）</span><span style="color:#333333;">修改</span><span style="color:#333333;">形参</span><span style="color:#333333;">的</span><span style="color:#333333;">值</span> <span style="color:#333333;">实参</span><span style="color:#333333;">不会</span><span style="color:#333333;">发生</span><span style="color:#333333;">变化</span></span></p> 
<pre><code class="language-cs">#include&lt;stdio.h&gt;
int fun(int a,int b)
{
    int sum;
    sum = a + b;
    return sum;
}
int main(int argc, char const *argv[])
{
    int a = 10;
    int b =20;
    int sum = fun(a,b); //a,b传参给函数后，a，b的值并不会发生改变
    printf("%d\n",sum);
    return 0;
}
</code></pre> 
<h4>2.<span style="color:#000000;"><strong><span style="color:#1a1a1a;">地址传递：</span></strong></span></h4> 
<p><span style="color:#000000;"><strong><span style="color:#1a1a1a;">                 </span></strong></span>双向传递，在函数中修改形参，实参会一起改变<span style="color:#000000;"><span style="color:#333333;">(把变量的地址传递过去，通过地址对原内容修改)</span></span></p> 
<pre><code class="language-cs">#include&lt;stdio.h&gt;
void fun(int *p1,int*p2)
{
    int c =*p1;                  
    *p1 = *p2;
    *p2 = c;                  //交换ab的值
}
int main(int argc, char const *argv[])
{
    int a =1,b=2;             //a = 1，b=2
    fun(&amp;a,&amp;b);               //将a，b的地址传给fun函数，函数中形参改变后，实参也会改变
    printf("%d %d\n",a,b);    //a = 2 ， a = 1
    return 0;
}</code></pre> 
<h4>3.数组传递</h4> 
<div> 
 <span style="color:#000000;"><span style="color:#333333;">                和地址传递一样，参数中如果存在数组的定义，也会认为是指针</span></span> 
 <span style="color:#000000;"><span style="color:#333333;">(本质也会认为是地址传递，传递的是数组的首地址(一维数组))</span></span> 
</div> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
void *fun(char *p)
{
    for (int a = 0; a &lt; 5; a++,p++)
        printf("%c", *p);
}
int main(int argc, char const *argv[])
{
    char buf[32] = "hello";
    char *p = fun(buf);
    return 0;
}</code></pre> 
<h2>二丶开辟堆区空间</h2> 
<h3><span style="color:#000000;"><span style="color:#333333;">为什么存在动态内存开辟</span></span></h3> 
<div> 
 <p style="margin-left:0;text-align:left;"><span style="color:#000000;"><span style="color:#333333;">          在技术方面，普通的空间申请，都是在全局或者栈区，全局一般不太建议大量使用，而栈空间有限，那么如果一个应 用需要大量的内存空间的时候，需要通过申请堆空间来支持基本业务。</span></span><br><span style="color:#000000;"><span style="color:#333333;">          在应用方面，程序员很难一次预估好自己总共需要花费多大的空间。想想之前我们定义的所有数组，因为其语法约束，我们必须得明确"指出"空间大小.但是如果用动态内存申请（malloc）因为malloc是函数，而函数就可以传参，也就意味着，我们可以通过具体的情况，对需要的内存大小进行动态计算，进而在传参申请，提供了很大的灵活性。<br>           </span></span><span style="color:#000000;"><span style="color:#333333;">需要手动开辟空间，手动释放、如果只开辟不释放，所用的空间会越来越少</span></span></p> 
 <h3 style="margin-left:0px;text-align:left;"><span style="color:#000000;"><span style="color:#333333;">开辟空间</span></span></h3> 
</div> 
<div> 
 <span style="color:#000000;"><span style="color:#333333;">                #include &lt;stdlib.h&gt;</span></span> 
</div> 
<div> 
 <div> 
  <p style="margin-left:0;text-align:left;"><span style="color:#000000;"><span style="color:#333333;">                void *malloc(size_t size);</span></span><br><span style="color:#000000;"><span style="color:#333333;">                功能：在堆区开辟空间</span></span><br><span style="color:#000000;"><span style="color:#333333;">                参数：size：开辟空间的大小(单位：字节)</span></span><br><span style="color:#000000;"><span style="color:#333333;">                返回值：</span></span><span style="color:#000000;"><span style="color:#333333;">成功：返回开辟空间的首地址</span></span><br><span style="color:#000000;"><span style="color:#333333;">                              失败：NULL // 为什么出现开辟失败，它没有足够大的空间了</span></span></p> 
  <h3 style="background-color:transparent;margin-left:0px;text-align:left;"><strong><span style="color:#1a1a1a;">释放空间</span></strong></h3> 
 </div> 
</div> 
<div> 
 <div> 
  <p style="margin-left:0;text-align:left;"><span style="color:#000000;"><span style="color:#333333;">                #include &lt;stdlib.h&gt;</span></span><br><span style="color:#000000;"><span style="color:#333333;">                void free(void *ptr);</span></span><br><span style="color:#000000;"><span style="color:#333333;">                功能：释放堆区空间</span></span><br><span style="color:#000000;"><span style="color:#333333;">                参数：ptr：堆区空间的首地址</span></span><br><span style="color:#000000;"><span style="color:#333333;">                返回值：无</span></span><br>  </p> 
  <pre><code class="language-cs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main(int argc, char const *argv[])
{
    // 你可以这么开辟 malloc(40);
    // 也可以这么开辟 malloc(size(int)*10);
    int *p = (int *)malloc(sizeof(int)*10);
    if (NULL == p)
    {
        printf("开辟失败!\n");
        return -1;
    }
    printf("开辟成功!\n");
    // 在此去书写一些功能
    for (int i = 0; i &lt; 9; i++)
    {
        scanf("%d", &amp;p[i]);
    }
    for (int i = 0; i &lt; 9; i++)
    {
        printf("%d\n", p[i]);
    }
    // 空间使用完成之后，记得释放
    free(p);
    p=NULL;
    return 0;
}</code></pre> 
  <div> 
   <span style="color:#000000;"><span style="color:#000000;">注意：</span></span> 
  </div> 
  <div> 
   <p style="margin-left:0;text-align:left;"><span style="color:#000000;"><span style="color:#990055;">           1.</span><span style="color:#000000;"> 手动开辟堆区空间，要注意内存泄漏 ,</span></span><span style="color:#000000;"><span style="color:#000000;">当指针指向开辟堆区的空间之后，又对指针重新赋值，则没有指针指向开辟堆区空间，就会造成内存泄露</span></span><br><span style="color:#000000;"><span style="color:#990055;">            2.</span><span style="color:#000000;"> 使用完堆区空间之后及时释放空间</span></span></p> 
  </div> 
 </div> 
</div> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e7058c30f1fc2bcc336a5b26ea578a2f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">破解PyCharm插件更新难题：让IDE焕发新生</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6900e2a3d95160f01dd17d8747820454/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">破解PyCharm SSH配置难题：一站式故障排查与修复指南</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>