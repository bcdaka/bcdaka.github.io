<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[C&#43;&#43;] 深入理解面向对象编程特性 : 继承 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/01c4881ccf831696279344e9c189359f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="[C&#43;&#43;] 深入理解面向对象编程特性 : 继承">
  <meta property="og:description" content="文章目录 继承的概念与定义继承的定义定义格式不同继承方式与继承的基类中访问限定符间的影响C&#43;&#43;中的继承和访问控制总结父类的`private`成员在子类中的访问限制`protected`成员的使用场景成员访问方式总结继承方式的默认值实际应用中的继承方式 示例代码 OOP中类之间的关系“is a” 关系“has a” 关系 类模板的继承类模板继承的基本语法访问控制和作用域解析名称查找和依赖名称名称查找和作用域解析示例 父类和子类对象赋值兼容转换子类对象可以赋值给父类对象、父类指针或父类引用父类对象不能赋值给子类对象父类的指针或引用可以通过强制类型转换赋值给子类的指针或引用安全的类型转换强制类型转换 总结 继承中的作⽤域隐藏规则作⽤域相关知识考察 ⼦类的默认成员函数子类的构造函数子类的拷贝构造函数子类的赋值运算符子类的析构函数子类的赋值运算符重载不能被继承的类 继承：友元&amp;静态成员继承与友元继承与静态成员 多继承与菱形继承继承模型单继承多继承多继承中指针偏移问题： 菱形继承 虚继承虚继承的原理虚继承的内存分布注意事项 继承和组合继承（Inheritance）组合（Composition）继承与组合的比较继承与组合的使用原则实例分析示例 1：组合（has-a 关系）示例 2：继承（is-a 关系） 组合与继承的实际应用综合示例 继承的概念与定义 面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。
当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。
继承的定义 定义格式 继承格式：class derived-class: access-specifier base-class
Person是⽗类，也称作基类。Student是⼦类，也称作派⽣类 ：
不同继承方式与继承的基类中访问限定符间的影响 类的继承有三种类型：公有继承（public）、保护继承（protected）和私有继承（private）。C&#43;&#43;中的访问限定符有public、protected和private，它们分别控制成员的可访问性。 具体的继承后访问权限如下:
类成员/继承方式public继承protected继承private继承父类的public成员子类的public成员子类的protected成员子类的private成员父类的protected成员子类的protected成员子类的protected成员子类的private成员父类的private成员在子类中不可见在子类中不可见在子类中不可见 C&#43;&#43;中的继承和访问控制总结 父类的private成员在子类中的访问限制 父类的private成员在子类中是不可见的。这意味着，虽然子类对象中仍然包含父类的private成员，但语法上子类无法访问这些成员，无论是在子类的内部还是外部。
protected成员的使用场景 父类的private成员在子类中不能被访问。如果需要父类成员在类外不能直接访问，但在子类中能够访问，那么应该将这些成员定义为protected。protected成员限定符主要是为了解决继承中的访问控制问题而出现的。
成员访问方式总结 通过继承方式和父类成员的访问限定符，可以总结出父类的其他成员在子类中的访问方式：
public &gt; protected &gt; private 子类对父类成员的访问权限是取父类成员的访问限定符与继承方式的最小值。
继承方式的默认值 在使用关键字class时，默认的继承方式是private。而使用关键字struct时，默认的继承方式是public。尽管如此，最好显式地写出继承方式以提高代码的可读性。
class Base { private: int privateMember; protected: int protectedMember; public: int publicMember; }; class Derived : public Base { // 继承方式为public，访问权限如下： // privateMember：不可见 // protectedMember：protected // publicMember：public }; 实际应用中的继承方式 在实际应用中，通常使用public继承，很少使用protected或private继承。原因在于protected或private继承的成员只能在子类内部使用，限制了代码的扩展性和可维护性。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-11T19:19:32+08:00">
    <meta property="article:modified_time" content="2024-08-11T19:19:32+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[C&#43;&#43;] 深入理解面向对象编程特性 : 继承</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/a7/70/kbqC7uO4_o.png" alt="Kevin的技术博客.png"><br> </p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_4" rel="nofollow">继承的概念与定义</a></li><li><ul><li><a href="#_10" rel="nofollow">继承的定义</a></li><li><ul><li><a href="#_11" rel="nofollow">定义格式</a></li><li><a href="#_17" rel="nofollow">不同继承方式与继承的基类中访问限定符间的影响</a></li><li><a href="#C_30" rel="nofollow">C++中的继承和访问控制总结</a></li><li><ul><li><a href="#private_31" rel="nofollow">父类的`private`成员在子类中的访问限制</a></li><li><a href="#protected_33" rel="nofollow">`protected`成员的使用场景</a></li><li><a href="#_35" rel="nofollow">成员访问方式总结</a></li><li><a href="#_41" rel="nofollow">继承方式的默认值</a></li><li><a href="#_60" rel="nofollow">实际应用中的继承方式</a></li></ul> 
    </li><li><a href="#_62" rel="nofollow">示例代码</a></li></ul> 
   </li><li><a href="#OOP_93" rel="nofollow">OOP中类之间的关系</a></li><li><ul><li><a href="#is_a__94" rel="nofollow">“is a” 关系</a></li><li><a href="#has_a__115" rel="nofollow">“has a” 关系</a></li></ul> 
   </li><li><a href="#_141" rel="nofollow">类模板的继承</a></li><li><ul><li><a href="#_142" rel="nofollow">类模板继承的基本语法</a></li><li><a href="#_155" rel="nofollow">访问控制和作用域解析</a></li><li><a href="#_169" rel="nofollow">名称查找和依赖名称</a></li><li><ul><li><a href="#_181" rel="nofollow">名称查找和作用域解析示例</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#_236" rel="nofollow">父类和子类对象赋值兼容转换</a></li><li><ul><li><a href="#_237" rel="nofollow">子类对象可以赋值给父类对象、父类指针或父类引用</a></li><li><a href="#_274" rel="nofollow">父类对象不能赋值给子类对象</a></li><li><a href="#_284" rel="nofollow">父类的指针或引用可以通过强制类型转换赋值给子类的指针或引用</a></li><li><ul><li><a href="#_286" rel="nofollow">安全的类型转换</a></li><li><a href="#_299" rel="nofollow">强制类型转换</a></li></ul> 
   </li><li><a href="#_309" rel="nofollow">总结</a></li></ul> 
  </li><li><a href="#_317" rel="nofollow">继承中的作⽤域</a></li><li><ul><li><a href="#_318" rel="nofollow">隐藏规则</a></li><li><a href="#_327" rel="nofollow">作⽤域相关知识考察</a></li></ul> 
  </li><li><a href="#_360" rel="nofollow">⼦类的默认成员函数</a></li><li><ul><li><a href="#_361" rel="nofollow">子类的构造函数</a></li><li><a href="#_372" rel="nofollow">子类的拷贝构造函数</a></li><li><a href="#_381" rel="nofollow">子类的赋值运算符</a></li><li><a href="#_395" rel="nofollow">子类的析构函数</a></li><li><a href="#_406" rel="nofollow">子类的赋值运算符重载</a></li><li><a href="#_419" rel="nofollow">不能被继承的类</a></li></ul> 
  </li><li><a href="#_442" rel="nofollow">继承：友元&amp;静态成员</a></li><li><ul><li><a href="#_443" rel="nofollow">继承与友元</a></li><li><a href="#_485" rel="nofollow">继承与静态成员</a></li></ul> 
  </li><li><a href="#_536" rel="nofollow">多继承与菱形继承</a></li><li><ul><li><a href="#_537" rel="nofollow">继承模型</a></li><li><ul><li><a href="#_538" rel="nofollow">单继承</a></li><li><a href="#_541" rel="nofollow">多继承</a></li><li><ul><li><a href="#_564" rel="nofollow">多继承中指针偏移问题：</a></li></ul> 
    </li><li><a href="#_597" rel="nofollow">菱形继承</a></li></ul> 
   </li><li><a href="#_642" rel="nofollow">虚继承</a></li><li><ul><li><a href="#_675" rel="nofollow">虚继承的原理</a></li><li><a href="#_677" rel="nofollow">虚继承的内存分布</a></li><li><a href="#_679" rel="nofollow">注意事项</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_696" rel="nofollow">继承和组合</a></li><li><ul><li><a href="#Inheritance_698" rel="nofollow">继承（Inheritance）</a></li><li><a href="#Composition_722" rel="nofollow">组合（Composition）</a></li><li><a href="#_749" rel="nofollow">继承与组合的比较</a></li><li><a href="#_756" rel="nofollow">继承与组合的使用原则</a></li><li><a href="#_761" rel="nofollow">实例分析</a></li><li><ul><li><a href="#_1hasa__762" rel="nofollow">示例 1：组合（has-a 关系）</a></li><li><a href="#_2isa__779" rel="nofollow">示例 2：继承（is-a 关系）</a></li></ul> 
   </li><li><a href="#_798" rel="nofollow">组合与继承的实际应用</a></li><li><a href="#_803" rel="nofollow">综合示例</a></li></ul> 
 </li></ul> 
</div> 
<br> 
<img src="https://images2.imgbox.com/af/2c/kOHZne9d_o.gif" alt=""> 
<br> 
<img src="https://images2.imgbox.com/9e/44/fKgQvN8X_o.png" alt=""> 
<p></p> 
<h2><a id="_4"></a>继承的概念与定义</h2> 
<p>面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。<br> 当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为<strong>基类</strong>，新建的类称为<strong>派生类</strong>。<br> <img src="https://images2.imgbox.com/82/aa/XOHDFYOC_o.png" alt="cpp-inheritance-2020-12-15-1.png"></p> 
<h3><a id="_10"></a>继承的定义</h3> 
<h4><a id="_11"></a>定义格式</h4> 
<blockquote> 
 <p><strong>继承格式：</strong><code>class derived-class: access-specifier base-class</code></p> 
</blockquote> 
<p>Person是⽗类，也称作基类。Student是⼦类，也称作派⽣类 ：<br> <img src="https://images2.imgbox.com/bd/de/kzuV1VCn_o.png" alt="image.png"></p> 
<h4><a id="_17"></a>不同继承方式与继承的基类中访问限定符间的影响</h4> 
<ul><li>类的继承有三种类型：公有继承（public）、保护继承（protected）和私有继承（private）。</li><li>C++中的访问限定符有<code>public</code>、<code>protected</code>和<code>private</code>，它们分别控制成员的可访问性。</li></ul> 
<p><strong>具体的继承后访问权限如下:</strong></p> 
<table><thead><tr><th><strong>类成员/继承方式</strong></th><th><strong>public继承</strong></th><th><strong>protected继承</strong></th><th><strong>private继承</strong></th></tr></thead><tbody><tr><td>父类的public成员</td><td>子类的public成员</td><td>子类的protected成员</td><td>子类的private成员</td></tr><tr><td>父类的protected成员</td><td>子类的protected成员</td><td>子类的protected成员</td><td>子类的private成员</td></tr><tr><td>父类的private成员</td><td>在子类中不可见</td><td>在子类中不可见</td><td>在子类中不可见</td></tr></tbody></table> 
<h4><a id="C_30"></a>C++中的继承和访问控制总结</h4> 
<h5><a id="private_31"></a>父类的<code>private</code>成员在子类中的访问限制</h5> 
<p>父类的<code>private</code>成员在子类中是不可见的。这意味着，虽然子类对象中仍然包含父类的<code>private</code>成员，但语法上子类无法访问这些成员，无论是在子类的内部还是外部。</p> 
<h5><a id="protected_33"></a><code>protected</code>成员的使用场景</h5> 
<p>父类的<code>private</code>成员在子类中不能被访问。如果需要父类成员在类外不能直接访问，但在子类中能够访问，那么应该将这些成员定义为<code>protected</code>。<code>protected</code>成员限定符主要是为了解决继承中的访问控制问题而出现的。</p> 
<h5><a id="_35"></a>成员访问方式总结</h5> 
<p>通过继承方式和父类成员的访问限定符，可以总结出父类的其他成员在子类中的访问方式：</p> 
<ul><li><code>public</code> &gt; <code>protected</code> &gt; <code>private</code></li></ul> 
<p>子类对父类成员的访问权限是取父类成员的访问限定符与继承方式的最小值。</p> 
<h5><a id="_41"></a>继承方式的默认值</h5> 
<p>在使用关键字<code>class</code>时，默认的继承方式是<code>private</code>。而使用关键字<code>struct</code>时，默认的继承方式是<code>public</code>。尽管如此，最好显式地写出继承方式以提高代码的可读性。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> privateMember<span class="token punctuation">;</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token keyword">int</span> protectedMember<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> publicMember<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 继承方式为public，访问权限如下：</span>
    <span class="token comment">// privateMember：不可见</span>
    <span class="token comment">// protectedMember：protected</span>
    <span class="token comment">// publicMember：public</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="_60"></a>实际应用中的继承方式</h5> 
<p>在实际应用中，通常使用<code>public</code>继承，很少使用<code>protected</code>或<code>private</code>继承。原因在于<code>protected</code>或<code>private</code>继承的成员只能在子类内部使用，限制了代码的扩展性和可维护性。</p> 
<h4><a id="_62"></a>示例代码</h4> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> privateMember<span class="token punctuation">;</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token keyword">int</span> protectedMember<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> publicMember<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">PublicDerived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// privateMember：不可见</span>
    <span class="token comment">// protectedMember：protected</span>
    <span class="token comment">// publicMember：public</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">ProtectedDerived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">protected</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// privateMember：不可见</span>
    <span class="token comment">// protectedMember：protected</span>
    <span class="token comment">// publicMember：protected</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">PrivateDerived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">private</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// privateMember：不可见</span>
    <span class="token comment">// protectedMember：private</span>
    <span class="token comment">// publicMember：private</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="OOP_93"></a>OOP中类之间的关系</h3> 
<h4><a id="is_a__94"></a>“is a” 关系</h4> 
<blockquote> 
 <p>“is a”关系：通过继承（Inheritance）来表示，表示类之间的层次关系。</p> 
</blockquote> 
<p>“is a”关系通常表示继承（Inheritance）关系，也就是一个类是另一个类的特殊类型。比如，狗（Dog）是动物（Animal）的一种，我们可以通过继承来表示这种关系：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">makeSound</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Animal sound"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Animal</span></span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// Dog is an Animal</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">makeSound</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Bark"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>在这个例子中，<code>Dog</code>类继承自<code>Animal</code>类，这表明“狗是一种动物”（Dog is an Animal）。<code>Dog</code>类可以访问<code>Animal</code>类中的公共成员函数和变量。</p> 
<h4><a id="has_a__115"></a>“has a” 关系</h4> 
<blockquote> 
 <p>“has a”关系：通过组合（Composition）或聚合（Aggregation）来表示，表示一个类拥有另一个类的实例。</p> 
</blockquote> 
<p>“has a”关系通常表示组合（Composition）或聚合（Aggregation）关系，即一个类包含另一个类作为其成员。这种关系强调一个类拥有另一个类的实例。比如，汽车（Car）有一个引擎（Engine），可以用组合来表示这种关系：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Engine</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Engine starts"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// Car has an Engine</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    Engine engine<span class="token punctuation">;</span>

<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">startCar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        engine<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Car starts"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>在这个例子中，<code>Car</code>类包含一个<code>Engine</code>类的实例，这表明“汽车有一个引擎”（Car has an Engine）。<code>Car</code>类可以使用<code>Engine</code>类中的方法来实现其功能。</p> 
<h3><a id="_141"></a>类模板的继承</h3> 
<h4><a id="_142"></a>类模板继承的基本语法</h4> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 基类内容</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 派生类内容</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="_155"></a>访问控制和作用域解析</h4> 
<ul><li><strong>访问控制</strong>：继承时，基类的成员的访问权限在派生类中依旧遵循C++的访问控制规则，即<code>public</code>、<code>protected</code>和<code>private</code>。</li><li><strong>作用域解析</strong>：在派生类中访问基类的成员时，需要使用<strong>作用域解析符</strong>来明确调用基类的成员：</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Base</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用基类的bar函数</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="_169"></a>名称查找和依赖名称</h4> 
<p>名称查找与依赖名称的问题主要源于模板的按需实例化机制和两阶段名称查找机制</p> 
<p><strong>两阶段名称查找</strong><br> C++编译器对模板代码进行两次名称查找：</p> 
<blockquote> 
 <ol><li><strong>第一次名称查找</strong>：在模板定义时进行。编译器解析所有与模板参数无关的非依赖名称。</li><li><strong>第二次名称查找</strong>：在模板实例化时进行。编译器解析依赖于模板参数的名称，即依赖名称。</li></ol> 
</blockquote> 
<p><strong>依赖名称</strong>（Dependent Names）是指那些依赖于模板参数的名称。在第一次名称查找时，编译器无法确定这些名称的具体含义，只有在模板实例化时才能解析。</p> 
<h5><a id="_181"></a>名称查找和作用域解析示例</h5> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base foo"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 问题点：编译器在第一次名称查找时不知道foo()是从Base&lt;T&gt;继承的</span>
        <span class="token comment">// 因为foo()是依赖于模板参数T的名称</span>
        <span class="token comment">// foo(); // 这会导致编译错误</span>

        <span class="token comment">// 解决方法1：使用this指针</span>
        <span class="token keyword">this</span><span class="token operator">-&gt;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 解决方法2：使用作用域解析符</span>
        <span class="token class-name">Base</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    Derived<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> d<span class="token punctuation">;</span>
    d<span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 "Base foo"</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>编译器会在第一次名称查找时尝试解析<code>foo()</code>。但是由于<code>foo()</code>是依赖于模板参数<code>T</code>的成员函数，编译器无法确定<code>foo()</code>是从基类继承的。这是因为模板是<strong>按需实例化</strong>的，编译器在第一次查找时并不知道派生类实例化时会包含哪些基类成员。<br> 在使用<code>Derived&lt;int&gt; d;</code>初始化的时候会对构造函数进行实例化并调用构造函数，但是当使用<code>d.bar();</code>时，如果在<code>bar()</code>中为<code>foo();</code>即会编译错误，原因就如上述，无法确定从基类继承。<br> 所以解决如下：</p> 
<ol><li><strong>使用</strong><code>**this**</code><strong>指针</strong>：</li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">this</span><span class="token operator">-&gt;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 正确</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>编译器会在第二阶段名称查找时解析<code>foo()</code>，并正确地找到基类中的<code>foo()</code>成员函数。这是因为<code>this</code>指针在类定义中总是已知的，并且它指向当前对象**（包括从基类继承的部分）**。</p> 
<ol start="2"><li><strong>使用作用域解析符</strong>：</li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Base</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 正确</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>Base&lt;T&gt;::foo()</code>明确指出了<code>foo()</code>来自基类<code>Base&lt;T&gt;</code>，消除了编译器的名称查找歧义。</p> 
<p><img src="https://images2.imgbox.com/65/10/5Q7yB03F_o.png" alt=""></p> 
<h2><a id="_236"></a>父类和子类对象赋值兼容转换</h2> 
<h3><a id="_237"></a>子类对象可以赋值给父类对象、父类指针或父类引用</h3> 
<p>在公有继承中，子类对象可以赋值给父类对象、父类指针或父类引用（把⼦类中⽗类那部分切来赋值过去）。这种转换称为向上转换（upcasting）。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">baseMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base method"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">derivedMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Derived method"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    Derived derivedObj<span class="token punctuation">;</span>
    Base baseObj <span class="token operator">=</span> derivedObj<span class="token punctuation">;</span>  <span class="token comment">// 子类对象赋值给父类对象</span>
    Base<span class="token operator">*</span> basePtr <span class="token operator">=</span> <span class="token operator">&amp;</span>derivedObj<span class="token punctuation">;</span>  <span class="token comment">// 子类对象的地址赋值给父类指针</span>
    Base<span class="token operator">&amp;</span> baseRef <span class="token operator">=</span> derivedObj<span class="token punctuation">;</span>  <span class="token comment">// 子类对象赋值给父类引用</span>

    baseObj<span class="token punctuation">.</span><span class="token function">baseMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 可以调用父类的方法</span>
    basePtr<span class="token operator">-&gt;</span><span class="token function">baseMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 可以通过父类指针调用父类的方法</span>
    baseRef<span class="token punctuation">.</span><span class="token function">baseMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 可以通过父类引用调用父类的方法</span>

    <span class="token comment">// 以下调用都会导致编译错误，因为父类对象/指针/引用不能访问子类特有的方法</span>
    <span class="token comment">// baseObj.derivedMethod();</span>
    <span class="token comment">// basePtr-&gt;derivedMethod();</span>
    <span class="token comment">// baseRef.derivedMethod();</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/2d/bc/44l7zMi7_o.png" alt="image.png"></p> 
<h3><a id="_274"></a>父类对象不能赋值给子类对象</h3> 
<p>父类对象不能赋值给子类对象，因为父类对象可能不包含子类对象所需的所有信息。这种转换会导致子类特有的数据丢失或变得不确定。</p> 
<pre><code class="prism language-cpp">Base baseObj<span class="token punctuation">;</span>
Derived derivedObj<span class="token punctuation">;</span>

<span class="token comment">// 以下赋值会导致编译错误</span>
<span class="token comment">// derivedObj = baseObj;</span>
</code></pre> 
<h3><a id="_284"></a>父类的指针或引用可以通过强制类型转换赋值给子类的指针或引用</h3> 
<p>父类的指针或引用可以通过强制类型转换赋值给子类的指针或引用，但必须确保父类的指针实际上指向一个子类对象。这种转换称为向下转换（downcasting）</p> 
<h4><a id="_286"></a>安全的类型转换</h4> 
<p>如果父类是多态类型，可以使用RTTI（运行时类型信息）中的<code>dynamic_cast</code>来进行安全转换。</p> 
<pre><code class="prism language-cpp">Base<span class="token operator">*</span> basePtr <span class="token operator">=</span> <span class="token keyword">new</span> Derived<span class="token punctuation">;</span>

Derived<span class="token operator">*</span> derivedPtr <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Derived<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>basePtr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>derivedPtr<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    derivedPtr<span class="token operator">-&gt;</span><span class="token function">derivedMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 安全转换后可以调用子类方法</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 转换失败，basePtr并不指向Derived对象</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_299"></a>强制类型转换</h4> 
<p>虽然可以使用<code>static_cast</code>进行强制转换，但这种转换在父类指针不指向子类对象时是危险的。</p> 
<pre><code class="prism language-cpp">Base<span class="token operator">*</span> basePtr <span class="token operator">=</span> <span class="token keyword">new</span> Derived<span class="token punctuation">;</span>

Derived<span class="token operator">*</span> derivedPtr <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Derived<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>basePtr<span class="token punctuation">)</span><span class="token punctuation">;</span>
derivedPtr<span class="token operator">-&gt;</span><span class="token function">derivedMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 需要确保basePtr实际指向Derived对象</span>
</code></pre> 
<h3><a id="_309"></a>总结</h3> 
<ul><li><strong>子类对象可以赋值给父类对象、父类指针或父类引用</strong>，称为向上转换（upcasting），但会发生对象切片（slicing）。</li><li><strong>父类对象不能赋值给子类对象</strong>，因为父类对象缺乏子类特有的信息。</li><li><strong>父类指针或引用可以赋值给子类指针或引用</strong>，但必须确保指向实际的子类对象。可以使用<code>dynamic_cast</code>进行安全转换。</li></ul> 
<p><img src="https://images2.imgbox.com/a4/73/YwRXza7v_o.png" alt=""></p> 
<h2><a id="_317"></a>继承中的作⽤域</h2> 
<h3><a id="_318"></a>隐藏规则</h3> 
<ol><li>在继承体系中⽗类和⼦类都有独⽴的作⽤域。</li><li>⼦类和⽗类中有同名成员，⼦类成员将<strong>屏蔽⽗类对同名成员的直接访问</strong>，这种情况叫隐藏。（在⼦<br> 类成员函数中，可以使⽤<code>⽗类::⽗类成员</code>显式访问）</li><li>需要注意的是如果是成员函数的隐藏，只需要<strong>函数名相同就构成隐藏</strong>。</li><li>注意在实际中在继承体系⾥⾯最好不要定义同名的成员。</li></ol> 
<h3><a id="_327"></a>作⽤域相关知识考察</h3> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span> <span class="token comment">// 不要忘记包含 iostream 头文件以使用 cout</span></span>

<span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func()"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func(int i)"</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    B b<span class="token punctuation">;</span>
    b<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用 B 类的 fun(int i)</span>
    b<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 尝试调用 A 类的 fun()，但由于重载，实际上调用的是 B 类的 fun(int i) </span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol><li><strong>A和B类中的两个func构成什么关系？</strong></li></ol> 
<ul><li>此时的A和B类构成的是隐藏的关系。</li></ul> 
<ol start="2"><li><strong>编译运⾏结果是什么？</strong></li></ol> 
<ul><li>编译报错。（<code>b.fun(); </code>）</li></ul> 
<p><img src="https://images2.imgbox.com/09/28/SuAJaBk0_o.png" alt=""></p> 
<h2><a id="_360"></a>⼦类的默认成员函数</h2> 
<h3><a id="_361"></a>子类的构造函数</h3> 
<p>子类的构造函数必须调<strong>用父类的构造函数</strong>来初始化父类的那部分成员。如果父类没有默认构造函数，则必须在子类构造函数的初始化列表中显式调用父类的构造函数。</p> 
<pre><code class="prism language-cpp"><span class="token function">Student</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> num<span class="token punctuation">)</span>
    <span class="token operator">:</span> <span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_num</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Student()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>在初始化列表中可以注意初始化顺序，先声明的先初始化，所以先声明的父类会先定义。</p> 
</blockquote> 
<h3><a id="_372"></a>子类的拷贝构造函数</h3> 
<p>子类的拷贝构造函数必须调用父类的拷贝构造函数来完成父类部分的拷贝初始化。</p> 
<pre><code class="prism language-cpp"><span class="token function">Student</span><span class="token punctuation">(</span><span class="token keyword">const</span> Student<span class="token operator">&amp;</span> s<span class="token punctuation">)</span>
    <span class="token operator">:</span> <span class="token function">Person</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_num</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>_num<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Student(const Student&amp; s)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_381"></a>子类的赋值运算符</h3> 
<p>子类的赋值运算符必须调用父类的赋值运算符来完成父类部分的复制。需要注意的是，子类的赋值运算符会隐藏父类的赋值运算符，所以需要显式调用父类的赋值运算符。</p> 
<pre><code class="prism language-cpp">Student<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Student<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Student&amp; operator=(const Student&amp; s)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 构成隐藏，所以需要显式调用</span>
        Person<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
        _num <span class="token operator">=</span> s<span class="token punctuation">.</span>_num<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_395"></a>子类的析构函数</h3> 
<p>不用再子类析构函数中显式调用父类的析构函数，子类的析构函数在被调用完成后，会自动调用父类的析构函数来清理父类成员。这样可以保证子类对象先清理子类成员再清理父类成员的顺序。</p> 
<pre><code class="prism language-cpp"><span class="token operator">~</span><span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~Student()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>析构会按照后定义的先析，先调用子类析构，再调用父类析构。</p> 
</blockquote> 
<p>多态中⼀些场景析构函数需要构成重写，重写的条件之⼀是函数名相同。那么编译器会对析构函数名进⾏特殊处理，处理成<code>destructor()</code>，所以⽗类析构函数不加<code>virtual</code>的情况下，⼦类析构函数和⽗类析构函数构成隐藏关系。</p> 
<h3><a id="_406"></a>子类的赋值运算符重载</h3> 
<p>⼦类的operator=必须要调⽤⽗类的operator=完成⽗类的复制。需要注意的是⼦类的operator=隐<br> 藏了⽗类的operator=，所以显⽰调⽤⽗类的operator=，需要指定⽗类作⽤域</p> 
<pre><code class="prism language-cpp">student<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> student<span class="token operator">&amp;</span> s<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		person<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_419"></a>不能被继承的类</h3> 
<p>有两种方法可以使类不可以被继承：</p> 
<blockquote> 
 <ol><li>⽗类的构造函数私有，⼦类的构成必须调⽤⽗类的构造函数，但是⽗类的构成函数私有化以后，⼦类看不⻅就不能调⽤了，那么⼦类就⽆法实例化出对象。</li><li>C++11新增了⼀个<code>final</code>关键字，<code>final</code>修改⽗类，⼦类就不能继承了。</li></ol> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token keyword">final</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token keyword">void</span> <span class="token function">func5</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base::func5"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">protected</span><span class="token operator">:</span>
<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
<span class="token comment">// C++98的⽅法</span>
<span class="token comment">/*Base()
	{}*/</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/aa/18/Q8xRjRO7_o.png" alt=""></p> 
<h2><a id="_442"></a>继承：友元&amp;静态成员</h2> 
<h3><a id="_443"></a>继承与友元</h3> 
<p><strong>友元关系不继承：</strong><br> 在C++中，友元关系是特定于某个类的。一个函数或类如果是父类的友元，它不会自动成为子类的友元。因此，父类的友元函数不能访问子类的私有成员和保护成员。同样地，如果你希望某个函数既是父类的友元，又是子类的友元，也可以在子类中声明该友元函数。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">friend</span> <span class="token keyword">void</span> <span class="token function">Display</span><span class="token punctuation">(</span><span class="token keyword">const</span> Person<span class="token operator">&amp;</span> p<span class="token punctuation">,</span> <span class="token keyword">const</span> Student<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 声明友元函数</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    string _name<span class="token punctuation">;</span> <span class="token comment">// 姓名</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token keyword">int</span> _stuNum<span class="token punctuation">;</span> <span class="token comment">// 学号</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">Display</span><span class="token punctuation">(</span><span class="token keyword">const</span> Person<span class="token operator">&amp;</span> p<span class="token punctuation">,</span> <span class="token keyword">const</span> Student<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    cout <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">.</span>_name <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span>_stuNum <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment">// 尝试访问子类的保护成员，编译错误</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    Person p<span class="token punctuation">;</span>
    Student s<span class="token punctuation">;</span>
    <span class="token function">Display</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 编译报错：error C2248: “Student::_stuNum”: 无法访问 protected 成员</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>Display</code>函数是<code>Person</code>类的友元，因此它可以访问<code>Person</code>类的保护成员 <code>_name</code>。但是，当它尝试访问<code>Student</code>类的保护成员<code>_stuNum</code>时，会产生编译错误。原因是友元关系不继承：<code>Display</code>函数虽然是<code>Person</code>的友元，但它不是<code>Student</code>的友元，所以不能访问<code>Student</code>的保护成员。<br> 将<code>Display</code>在子类中声明即可解决该问题：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">friend</span> <span class="token keyword">void</span> <span class="token function">Display</span><span class="token punctuation">(</span><span class="token keyword">const</span> Person<span class="token operator">&amp;</span> p<span class="token punctuation">,</span> <span class="token keyword">const</span> Student<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 友元函数也要声明在子类中</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token keyword">int</span> _stuNum<span class="token punctuation">;</span> <span class="token comment">// 学号</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>这样，<code>Display</code>函数就能同时访问<code>Person</code>和<code>Student</code>的保护成员了。</p> 
<h3><a id="_485"></a>继承与静态成员</h3> 
<p>在C++中，静态成员是属于类而不是某个特定对象的。⽗类定义了<code>static</code>静态成员，则整个继承体系⾥⾯只有⼀个这样的成员，这意味着即使类派生出了多个子类，它们都<strong>共享</strong>同一个静态成员实例。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    string _name<span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> _count<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> Person<span class="token double-colon punctuation">::</span>_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 静态成员初始化</span>

<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token keyword">int</span> _stuNum<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    Person p<span class="token punctuation">;</span>
    Student s<span class="token punctuation">;</span>
    
    <span class="token comment">// 非静态成员_name地址不同，说明子类继承后，父子类对象各有一份</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>p<span class="token punctuation">.</span>_name <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>s<span class="token punctuation">.</span>_name <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token comment">// 静态成员_count地址相同，说明子类和父类共用同一个静态成员</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>p<span class="token punctuation">.</span>_count <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>s<span class="token punctuation">.</span>_count <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token comment">// 公有的情况下，父子类都可以访问静态成员</span>
    cout <span class="token operator">&lt;&lt;</span> Person<span class="token double-colon punctuation">::</span>_count <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> Student<span class="token double-colon punctuation">::</span>_count <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>运行结果：</p> 
<pre><code class="prism language-cpp"><span class="token number">0133F</span>DE4
<span class="token number">0133F</span>DBC
<span class="token number">0014E478</span>
<span class="token number">0014E478</span>
<span class="token number">0</span>
<span class="token number">0</span>
</code></pre> 
<blockquote> 
 <ul><li><code>_name</code>是一个非静态成员，在<code>Person</code>和<code>Student</code>对象中分别有独立的实例，所以它们的地址不同。</li><li><code>_count</code>是一个静态成员，<code>Person</code>和<code>Student</code>共享同一个静态成员实例，因此它们的地址相同。</li><li>无论是通过父类还是子类，都可以访问静态成员。</li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/12/4d/2rSFbuyX_o.png" alt=""></p> 
<h2><a id="_536"></a>多继承与菱形继承</h2> 
<h3><a id="_537"></a>继承模型</h3> 
<h4><a id="_538"></a>单继承</h4> 
<p>单继承是指一个子类只有一个直接父类。在这种情况下，子类继承父类的所有非私有成员，继承结构简单明了，访问成员变量也不存在歧义问题。</p> 
<h4><a id="_541"></a>多继承</h4> 
<p>多继承是指一个子类有多个直接父类。C++支持多继承，这意味着一个子类可以从多个父类继承成员。在多继承中，C++规定在内存布局上，先继承的父类放在前面，后继承的父类放在后面，子类自己的成员放在最后。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    string _name<span class="token punctuation">;</span> <span class="token comment">// 姓名</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token keyword">int</span> _num<span class="token punctuation">;</span> <span class="token comment">// 学号</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Teacher</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token keyword">int</span> _id<span class="token punctuation">;</span> <span class="token comment">// 职工编号</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Assistant</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">Teacher</span></span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    string _majorCourse<span class="token punctuation">;</span> <span class="token comment">// 主修课程</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="_564"></a>多继承中指针偏移问题：</h5> 
<blockquote> 
 <p><strong>问题：下⾯说法正确的是()</strong><br> A：p1<mark>p2</mark>p3 B：p1&lt;p2&lt;p3<br> C：p1==p3!=p2 D：p1!=p2!=p3</p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base2</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">public</span><span class="token operator">:</span> <span class="token keyword">int</span> _b2<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Base1</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">public</span><span class="token operator">:</span> <span class="token keyword">int</span> _b1<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Derive</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base1</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">Base2</span></span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">public</span><span class="token operator">:</span> <span class="token keyword">int</span> _d<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Derive d<span class="token punctuation">;</span>
	Base1<span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>d<span class="token punctuation">;</span>
	Base2<span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>d<span class="token punctuation">;</span>
	Derive<span class="token operator">*</span> p3 <span class="token operator">=</span> <span class="token operator">&amp;</span>d<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/3a/98/UbmrMN6J_o.png" alt="image.png"><br> 继承的时候会按照生命顺序来进行分配空间，也就是<strong>继承顺序</strong>。上述例子中先继承的是<code>Base1</code>，后继承的是<code>Base2</code>，所以按照规则栈会先为继承的<code>Base1</code>的信息进行开辟空间（栈向下开辟空间），然后再为<code>Base2</code>开辟空间，所以空间图如上图所示。</p> 
<pre><code class="prism language-cpp">Base1<span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>d<span class="token punctuation">;</span>
Base2<span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>d<span class="token punctuation">;</span>
Derive<span class="token operator">*</span> p3 <span class="token operator">=</span> <span class="token operator">&amp;</span>d<span class="token punctuation">;</span>
</code></pre> 
<p>以上是用了继承中基类对于派生类的<strong>向上转换（会进行类似切片操作，详见上文）</strong>，所以此时的指向为下图：<br> <img src="https://images2.imgbox.com/06/b6/yFQg9ye9_o.png" alt="image.png"><br> 此时的<code>p1</code>和<code>p3</code>指向的是同一块地址，<code>p2</code>指向的之后分配的继承了<code>Base2</code>的空间。</p> 
<blockquote> 
 <p><strong>正确答案为：</strong><code>p1 == p3 != p2</code></p> 
</blockquote> 
<h4><a id="_597"></a>菱形继承</h4> 
<p>菱形继承是多继承中的一种特殊情况，发生在一个子类通过两个不同的路径继承自同一个基类时，形成菱形结构。</p> 
<blockquote> 
 <p>这种继承方式会带来<strong>数据冗余</strong>和<strong>访问二义性</strong>的问题。</p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    string _name<span class="token punctuation">;</span> <span class="token comment">// 姓名</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token keyword">int</span> _num<span class="token punctuation">;</span> <span class="token comment">// 学号</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Teacher</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token keyword">int</span> _id<span class="token punctuation">;</span> <span class="token comment">// 职工编号</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Assistant</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">Teacher</span></span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    string _majorCourse<span class="token punctuation">;</span> <span class="token comment">// 主修课程</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    Assistant a<span class="token punctuation">;</span>
    a<span class="token punctuation">.</span>_name <span class="token operator">=</span> <span class="token string">"peter"</span><span class="token punctuation">;</span> <span class="token comment">// 编译报错：error C2385: 对“_name”的访问不明确</span>
    a<span class="token punctuation">.</span>Student<span class="token double-colon punctuation">::</span>_name <span class="token operator">=</span> <span class="token string">"xxx"</span><span class="token punctuation">;</span> <span class="token comment">// 需要显式指定访问哪个父类的成员</span>
    a<span class="token punctuation">.</span>Teacher<span class="token double-colon punctuation">::</span>_name <span class="token operator">=</span> <span class="token string">"yyy"</span><span class="token punctuation">;</span> <span class="token comment">// 但是数据冗余问题无法解决</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li><strong>数据冗余</strong>：在<code>Assistant</code>类中，由于<code>Student</code>和<code>Teacher</code>都继承了<code>Person</code>，所以<code>Assistant</code>中会有两份<code>Person</code>的拷贝。换句话说，<code>Assistant</code>类中有两份<code>_name</code>成员，这样会导致内存上的浪费。</li><li><strong>访问二义性</strong>：当你在<code>Assistant</code>类中访问<code>_name</code>时，编译器无法确定你想访问的是从<code>Student</code>继承过来的<code>_name</code>，还是从<code>Teacher</code>继承过来的<code>_name</code>，因此会报错。</li></ul> 
<pre><code class="prism language-cpp">a<span class="token punctuation">.</span>Student<span class="token double-colon punctuation">::</span>_name <span class="token operator">=</span> <span class="token string">"xxx"</span><span class="token punctuation">;</span>
a<span class="token punctuation">.</span>Teacher<span class="token double-colon punctuation">::</span>_name <span class="token operator">=</span> <span class="token string">"yyy"</span><span class="token punctuation">;</span>
</code></pre> 
<p>可以通过显式的指定访问的是哪个父类的成员，或者使用<strong>虚继承</strong>，即可解决当前问题。</p> 
<blockquote> 
 <p><strong>不推荐使用菱形继承</strong></p> 
</blockquote> 
<h3><a id="_642"></a>虚继承</h3> 
<p>虚继承（virtual inheritance）是C++中的一种特殊继承机制，用来解决多继承中的菱形继承问题，特别是避免数据冗余和访问二义性。<br> 在多继承中，如果一个子类通过不同的路径从同一个基类继承，那么就会形成菱形继承。菱形继承会导致子类中存在多个基类实例，从而产生数据冗余和访问二义性的问题。虚继承通过修改基类在继承链中的存储方式，使得即使存在多重继承，所有子类中<strong>只会存在一个基类的实例</strong>，从而避免数据冗余和访问二义性。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    string _name<span class="token punctuation">;</span> <span class="token comment">// 姓名</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 使用虚继承Person类</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">Person</span></span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token keyword">int</span> _num<span class="token punctuation">;</span> <span class="token comment">// 学号</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 使用虚继承Person类</span>
<span class="token keyword">class</span> <span class="token class-name">Teacher</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">Person</span></span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token keyword">int</span> _id<span class="token punctuation">;</span> <span class="token comment">// 职工编号</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Assistant</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">Teacher</span></span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    string _majorCourse<span class="token punctuation">;</span> <span class="token comment">// 主修课程</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 使用虚继承，可以解决数据冗余和二义性</span>
    Assistant a<span class="token punctuation">;</span>
    a<span class="token punctuation">.</span>_name <span class="token operator">=</span> <span class="token string">"peter"</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_675"></a>虚继承的原理</h4> 
<p>当一个类通过<code>virtual</code>关键字虚继承一个基类时，编译器确保在多继承链中该基类<strong>只会有一个实例</strong>。在上述示例中，<code>Student</code>和<code>Teacher</code>都虚继承自<code>Person</code>，因此在<code>Assistant</code>类中，<code>Person</code>的实例只会有一个。</p> 
<h4><a id="_677"></a>虚继承的内存分布</h4> 
<p>在普通继承中，每个子类都会在其对象中包含父类的成员。但在虚继承中，编译器通过在子类中存储一个指向基类的指针来避免冗余。这个指针指向了唯一的基类实例，确保整个继承体系中只存在一个基类实例。</p> 
<h4><a id="_679"></a>注意事项</h4> 
<ul><li><strong>构造函数调用顺序</strong>：因为虚继承之后只存在一个实例，所以当使用虚继承时，基类的构造函数在最派生类（如<code>Assistant</code>）的构造函数中被调用，而不是在虚继承的直接派生类（如<code>Student</code>或<code>Teacher</code>）中。派生类的构造函数负责初始化基类的那部分。</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Assistant</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">Teacher</span></span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Assistant</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> name<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Teacher</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>在这个例子中，由于<code>Person</code>是通过虚继承的，所以必须在<code>Assistant</code>的构造函数中显式地调用<code>Person</code>的构造函数来初始化<code>_name</code>。</p> 
<ul><li>虚继承的时候注意：进行虚继承的是那个产生数据冗余和二义性的公共基类的子类。</li></ul> 
<p><img src="https://images2.imgbox.com/38/c2/n17iGUb1_o.png" alt="image.png"></p> 
<p><img src="https://images2.imgbox.com/9f/1b/3zk4QiO1_o.png" alt=""></p> 
<h2><a id="_696"></a>继承和组合</h2> 
<p>继承（Inheritance）和组合（Composition）是面向对象编程中两种重要的代码复用手段。它们在实际开发中各有优势和适用场景。</p> 
<h3><a id="Inheritance_698"></a>继承（Inheritance）</h3> 
<p>继承是一种<strong>is-a</strong>关系，表示子类是父类的一种特殊类型。通过继承，子类可以复用父类的属性和方法。<br> <strong>特点：</strong></p> 
<ul><li><strong>代码复用</strong>：子类自动继承父类的所有成员变量和成员函数。</li><li><strong>多态性</strong>：子类可以重写父类的虚函数，提供不同的实现。</li><li><strong>强耦合</strong>：子类与父类之间<strong>有很强的依赖关系</strong>，父类的修改可能影响到所有子类。</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Car starts."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">BMW</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Car</span></span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">Drive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"BMW drives fast."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>在上面的代码中，<code>BMW</code>类继承了<code>Car</code>类，所以<code>BMW</code>类可以直接使用<code>Car</code>类中的<code>Start</code>方法。</p> 
<h3><a id="Composition_722"></a>组合（Composition）</h3> 
<p>组合是一种<strong>has-a</strong>关系，表示一个类拥有另一个类的实例。这种方式通过将一个对象作为另一个对象的成员变量来实现代码复用。<br> <strong>组合的特点：</strong></p> 
<ul><li><strong>松耦合</strong>：组合关系中的类是独立的，一个类的修改不会影响到其他类。</li><li><strong>黑箱复用</strong>：组合对象的内部实现对外部不可见，只暴露必要的接口。</li><li><strong>灵活性</strong>：通过组合，可以动态地创建更复杂的对象结构。</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Engine</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Engine starts."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>
    Engine engine<span class="token punctuation">;</span> <span class="token comment">// Car has an Engine</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        engine<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Car starts."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>在上面的代码中，<code>Car</code>类包含了一个<code>Engine</code>类的实例，<code>Car</code>类通过组合来复用<code>Engine</code>类的功能。</p> 
<h3><a id="_749"></a>继承与组合的比较</h3> 
<ul><li><strong>复用性</strong>：继承可以直接复用父类的实现，组合则通过使用已有类的实例来复用功能。</li><li><strong>耦合度</strong>：继承会导致子类与父类的紧密耦合，组合则保持类之间的独立性。</li><li><strong>可维护性</strong>：由于继承的强耦合性，父类的修改可能影响子类，从而降低了代码的可维护性。组合则更容易维护，因为它遵循单一职责原则，每个类只负责自己的部分。</li><li><strong>扩展性</strong>：组合更容易扩展，因为可以通过组合不同的类来创建新的功能，而继承则在层次结构上有更多的限制。</li></ul> 
<h3><a id="_756"></a>继承与组合的使用原则</h3> 
<ul><li><strong>优先使用组合</strong>：在设计类结构时，<strong>优先考虑使用组合</strong>，因为它可以减少耦合，提高代码的灵活性和可维护性。</li><li><strong>适当使用继承</strong>：当子类确实是父类的一种类型（即符合is-a关系）时，可以考虑使用继承。继承的优势在于实现多态性，但过度使用继承可能导致复杂的继承层次结构和高耦合。</li></ul> 
<h3><a id="_761"></a>实例分析</h3> 
<h4><a id="_1hasa__762"></a>示例 1：组合（has-a 关系）</h4> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Tire</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    string _brand <span class="token operator">=</span> <span class="token string">"Michelin"</span><span class="token punctuation">;</span> <span class="token comment">// 品牌</span>
    size_t _size <span class="token operator">=</span> <span class="token number">17</span><span class="token punctuation">;</span> <span class="token comment">// 尺寸</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    string _colour <span class="token operator">=</span> <span class="token string">"白色"</span><span class="token punctuation">;</span> <span class="token comment">// 颜色</span>
    string _num <span class="token operator">=</span> <span class="token string">"陕ABIT00"</span><span class="token punctuation">;</span> <span class="token comment">// 车牌号</span>
    Tire _t1<span class="token punctuation">,</span> _t2<span class="token punctuation">,</span> _t3<span class="token punctuation">,</span> _t4<span class="token punctuation">;</span> <span class="token comment">// 轮胎组合</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>在这里，<code>Car</code>类通过组合了四个<code>Tire</code>类的实例来实现车轮的功能，这就是一个典型的has-a关系。</p> 
<h4><a id="_2isa__779"></a>示例 2：继承（is-a 关系）</h4> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    string _colour <span class="token operator">=</span> <span class="token string">"白色"</span><span class="token punctuation">;</span> <span class="token comment">// 颜色</span>
    string _num <span class="token operator">=</span> <span class="token string">"陕ABIT00"</span><span class="token punctuation">;</span> <span class="token comment">// 车牌号</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">BMW</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Car</span></span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">Drive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"好开-操控"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Benz</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Car</span></span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">Drive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"好坐-舒适"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_798"></a>组合与继承的实际应用</h3> 
<ul><li><strong>继承</strong>主要用于需要复用父类的代码或实现多态性的时候。</li><li><strong>组合</strong>主要用于需要动态组合功能、减少类之间的耦合以及增强代码的灵活性时。</li></ul> 
<h3><a id="_803"></a>综合示例</h3> 
<p>在一些场景中，组合和继承可能会混合使用，例如在一个<code>stack</code>类中，既可以使用组合来包含一个<code>vector</code>对象，也可以通过继承来扩展<code>vector</code>类的功能。<br> **继承方式： **</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">stack</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">vector</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// stack继承自vector</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>**组合方式： **</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">stack</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> _v<span class="token punctuation">;</span> <span class="token comment">// 通过组合方式来包含一个vector对象</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>在实际设计时，建议优先考虑组合，这样可以保持类的封装性和独立性，从而提高代码的可维护性。<br> <img src="https://images2.imgbox.com/d6/b8/yvGJW24R_o.gif" alt=""><br> <img src="https://images2.imgbox.com/cd/99/gCNkgLvk_o.png" alt="image.png"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/33f88781dadcfad9759bfef4e8eff719/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java语言程序设计——篇十三（1）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3dff640293639c2fe2e647c4a981d186/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【海贼王航海日志：前端技术探索】CSS你了解多少？(三)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>