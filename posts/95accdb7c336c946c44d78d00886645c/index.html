<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>算法沉淀——动态规划之回文串问题（上）（leetcode真题剖析） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/95accdb7c336c946c44d78d00886645c/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="算法沉淀——动态规划之回文串问题（上）（leetcode真题剖析）">
  <meta property="og:description" content="算法沉淀——动态规划之回文串问题 01.回文子串02.最长回文子串03.分割回文串 IV04.分割回文串 II05.最长回文子序列06.让字符串成为回文串的最少插入次数 01.回文子串 题目链接：https://leetcode.cn/problems/palindromic-substrings/
给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。
回文字符串 是正着读和倒过来读一样的字符串。
子字符串 是字符串中的由连续字符组成的一个序列。
具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。
示例 1：
输入：s = &#34;abc&#34; 输出：3 解释：三个回文子串: &#34;a&#34;, &#34;b&#34;, &#34;c&#34; 示例 2：
输入：s = &#34;aaa&#34; 输出：6 解释：6个回文子串: &#34;a&#34;, &#34;a&#34;, &#34;a&#34;, &#34;aa&#34;, &#34;aa&#34;, &#34;aaa&#34; 提示：
1 &lt;= s.length &lt;= 1000s 由小写英文字母组成 思路
预处理回文信息： 创建一个 dp 表，其中 dp[i][j] 表示字符串 s 中子串 s[i:j&#43;1] 是否是回文串。
状态转移方程： 对于回文串，分析两头的元素：
如果 s[i] != s[j]，则不可能是回文串，dp[i][j] = 0；
如果
s[i] == s[j] ，则根据长度分三种情况讨论：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-02-28T20:25:25+08:00">
    <meta property="article:modified_time" content="2024-02-28T20:25:25+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">算法沉淀——动态规划之回文串问题（上）（leetcode真题剖析）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/6f/0e/b9STzADb_o.jpg" alt="在这里插入图片描述"></p> 
<p></p> 
<div class="toc"> 
 <h4>算法沉淀——动态规划之回文串问题</h4> 
 <ul><li><a href="#01_3" rel="nofollow">01.回文子串</a></li><li><a href="#02_83" rel="nofollow">02.最长回文子串</a></li><li><a href="#03_IV_138" rel="nofollow">03.分割回文串 IV</a></li><li><a href="#04_II_191" rel="nofollow">04.分割回文串 II</a></li><li><a href="#05_270" rel="nofollow">05.最长回文子序列</a></li><li><a href="#06_344" rel="nofollow">06.让字符串成为回文串的最少插入次数</a></li></ul> 
</div> 
<p></p> 
<h2><a id="01_3"></a>01.回文子串</h2> 
<p>题目链接：https://leetcode.cn/problems/palindromic-substrings/</p> 
<p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中 <strong>回文子串</strong> 的数目。</p> 
<p><strong>回文字符串</strong> 是正着读和倒过来读一样的字符串。</p> 
<p><strong>子字符串</strong> 是字符串中的由连续字符组成的一个序列。</p> 
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p> 
<p><strong>示例 1：</strong></p> 
<pre><code>输入：s = "abc"
输出：3
解释：三个回文子串: "a", "b", "c"
</code></pre> 
<p><strong>示例 2：</strong></p> 
<pre><code>输入：s = "aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
</code></pre> 
<p><strong>提示：</strong></p> 
<ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 由小写英文字母组成</li></ul> 
<p><strong>思路</strong></p> 
<ol><li> <p><strong>预处理回文信息：</strong> 创建一个 <code>dp</code> 表，其中 <code>dp[i][j]</code> 表示字符串 <code>s</code> 中子串 <code>s[i:j+1]</code> 是否是回文串。</p> </li><li> <p><strong>状态转移方程：</strong> 对于回文串，分析两头的元素：</p> 
  <ul><li> <p>如果 <code>s[i] != s[j]</code>，则不可能是回文串，<code>dp[i][j] = 0</code>；</p> </li><li> <p>如果</p> <pre><code>s[i] == s[j]
</code></pre> <p>，则根据长度分三种情况讨论：</p> 
    <ul><li>如果长度为 1，即 <code>i == j</code>，则一定是回文串，<code>dp[i][j] = true</code>；</li><li>如果长度为 2，即 <code>i + 1 == j</code>，则也一定是回文串，<code>dp[i][j] = true</code>；</li><li>如果长度大于 2，则需要看 <code>[i + 1, j - 1]</code> 区间的子串是否回文，<code>dp[i][j] = dp[i + 1][j - 1]</code>。</li></ul> </li></ul> </li><li> <p><strong>初始化：</strong> 由于状态转移方程已经考虑了各种情况，无需额外初始化。</p> </li><li> <p><strong>填表顺序：</strong> 根据状态转移方程，从下往上填写每一行。</p> </li><li> <p><strong>返回值：</strong> 根据状态表达和题目要求，返回 <code>dp</code> 表中 <code>true</code> 的个数。</p> </li></ol> 
<p><strong>代码</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">countSubstrings</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> n<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>j<span class="token operator">?</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> sum<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="02_83"></a>02.最长回文子串</h2> 
<p>题目链接：https://leetcode.cn/problems/longest-palindromic-substring/</p> 
<p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p> 
<p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p> 
<p><strong>示例 1：</strong></p> 
<pre><code>输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
</code></pre> 
<p><strong>示例 2：</strong></p> 
<pre><code>输入：s = "cbbd"
输出："bb"
</code></pre> 
<p><strong>提示：</strong></p> 
<ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由数字和英文字母组成</li></ul> 
<p><strong>思路</strong></p> 
<p>和上一题思路基本一致，但这里我们要返回字串，所以我们需要在原有算法上标记字串的开始位置和子串的长度。</p> 
<p><strong>代码</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    string <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> n<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span> len<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>begin<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">--</span>i<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>j<span class="token operator">?</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>j<span class="token operator">-</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&gt;</span>len<span class="token punctuation">)</span> len<span class="token operator">=</span>j<span class="token operator">-</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>begin<span class="token operator">=</span>i<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="03_IV_138"></a>03.分割回文串 IV</h2> 
<p>题目链接：https://leetcode.cn/problems/palindrome-partitioning-iv/</p> 
<p>给你一个字符串 <code>s</code> ，如果可以将它分割成三个 <strong>非空</strong> 回文子字符串，那么返回 <code>true</code> ，否则返回 <code>false</code> 。</p> 
<p>当一个字符串正着读和反着读是一模一样的，就称其为 <strong>回文字符串</strong> 。</p> 
<p><strong>示例 1：</strong></p> 
<pre><code>输入：s = "abcbdd"
输出：true
解释："abcbdd" = "a" + "bcb" + "dd"，三个子字符串都是回文的。
</code></pre> 
<p><strong>示例 2：</strong></p> 
<pre><code>输入：s = "bcbddxy"
输出：false
解释：s 没办法被分割成 3 个回文子字符串。
</code></pre> 
<p><strong>提示：</strong></p> 
<ul><li><code>3 &lt;= s.length &lt;= 2000</code></li><li><code>s</code> 只包含小写英文字母。</li></ul> 
<p><strong>思路</strong></p> 
<p>其实这里我们可以依照第一题的解法将所有的子串都进行统计，再遍历计算每个分割位置组成的3个子串是否都符合回文子串即可。</p> 
<p><strong>代码</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">bool</span> <span class="token function">checkPartitioning</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> n<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">--</span>i<span class="token punctuation">)</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>j<span class="token operator">?</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">;</span>
        
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">)</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>dp<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="04_II_191"></a>04.分割回文串 II</h2> 
<p>题目链接：https://leetcode.cn/problems/palindrome-partitioning-ii/</p> 
<p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是回文。</p> 
<p>返回符合要求的 <strong>最少分割次数</strong> 。</p> 
<p><strong>示例 1：</strong></p> 
<pre><code>输入：s = "aab"
输出：1
解释：只需一次分割就可将 s 分割成 ["aa","b"] 这样两个回文子串。
</code></pre> 
<p><strong>示例 2：</strong></p> 
<pre><code>输入：s = "a"
输出：0
</code></pre> 
<p><strong>示例 3：</strong></p> 
<pre><code>输入：s = "ab"
输出：1
</code></pre> 
<p><strong>提示：</strong></p> 
<ul><li><code>1 &lt;= s.length &lt;= 2000</code></li><li><code>s</code> 仅由小写英文字母组成</li></ul> 
<p><strong>思路</strong></p> 
<ol><li> <p><strong>状态表达：</strong> 以 <code>i</code> 位置为结尾，定义状态表达 <code>dp[i]</code> 表示字符串 <code>s</code> 中 <code>[0, i]</code> 区间上的字符串，最少分割的次数。</p> </li><li> <p><strong>状态转移方程：</strong> 通常考虑最后一个位置的信息。设 <code>0 &lt;= j &lt;= i</code>，那么可以根据 <code>[j, i]</code> 位置上的子串是否是回文串分成以下两类：</p> 
  <ul><li>如果 <code>[j, i]</code> 位置上的子串能够构成一个回文串，那么 <code>dp[i]</code> 就等于 <code>[0, j - 1]</code> 区间上最少回文串的个数 + 1，即 <code>dp[i] = dp[j - 1] + 1</code>；</li><li>如果 <code>[j, i]</code> 位置上的子串不能构成一个回文串，此时 <code>j</code> 位置就不用考虑。</li></ul> <p>由于求的是最小值，因此需要循环遍历 <code>j</code> 的取值，取最小值。</p> </li><li> <p><strong>优化：</strong> 在状态转移方程中，需要快速判断字符串中的子串是否回文。因此，可以先处理一个 <code>dp</code> 表，其中保存所有子串是否回文的信息。</p> </li><li> <p><strong>初始化：</strong> 在循环遍历 <code>j</code> 之前，处理 <code>j == 0</code> 的情况。此时，表示的区间是 <code>[0, i]</code>。如果 <code>[0, i]</code> 区间上的字符串已经是回文串了，最小的回文串就是 <code>1</code>，<code>j</code> 往后的值就不用遍历了。为防止在求 <code>min</code> 操作时，<code>0</code> 干扰结果，将表中的值初始化为「无穷大」。</p> </li><li> <p><strong>填表顺序：</strong> 从左往右填写。</p> </li><li> <p><strong>返回值：</strong> 根据状态表达，返回 <code>dp[n - 1]</code>。</p> </li></ol> 
<p><strong>代码</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">minCut</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> n<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;&gt;</span> <span class="token function">isp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">--</span>i<span class="token punctuation">)</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> isp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>j<span class="token operator">?</span>isp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">;</span>

        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>INT_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>isp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>
                    <span class="token keyword">if</span><span class="token punctuation">(</span>isp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="05_270"></a>05.最长回文子序列</h2> 
<p>题目链接：https://leetcode.cn/problems/longest-palindromic-subsequence/</p> 
<p>给你一个字符串 <code>s</code> ，找出其中最长的回文子序列，并返回该序列的长度。</p> 
<p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p> 
<p><strong>示例 1：</strong></p> 
<pre><code>输入：s = "bbbab"
输出：4
解释：一个可能的最长回文子序列为 "bbbb" 。
</code></pre> 
<p><strong>示例 2：</strong></p> 
<pre><code>输入：s = "cbbd"
输出：2
解释：一个可能的最长回文子序列为 "bb" 。 
</code></pre> 
<p><strong>提示：</strong></p> 
<ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由小写英文字母组成</li></ul> 
<p><strong>思路</strong></p> 
<ol><li> <p><strong>状态表达：</strong> 以 <code>i</code> 位置为结尾，定义状态表达 <code>dp[i][j]</code> 表示字符串 <code>s</code> 中 <code>[i, j]</code> 区间内的所有子序列中，最长的回文子序列的长度。</p> </li><li> <p><strong>状态转移方程：</strong> 回文子序列和回文子串的分析方式一般都是选择这段区域的「左右端点」的字符情况来分析。因为如果一个序列是回文串的话，「去掉首尾两个元素之后依旧是回文串」，「首尾加上两个相同的元素之后也依旧是回文串」。根据首尾元素的不同，分为以下两种情况：</p> 
  <ul><li>当 <code>s[i] == s[j]</code> 时，<code>[i, j]</code> 区间上的最长回文子序列，应该是 <code>[i + 1, j - 1]</code> 区间内的那个最长回文子序列首尾填上 <code>s[i]</code> 和 <code>s[j]</code>，此时 <code>dp[i][j] = dp[i + 1][j - 1] + 2</code>。</li><li>当 <code>s[i] != s[j]</code> 时，这两个元素就不能同时添加在一个回文串的左右，那么就应该让 <code>s[i]</code> 单独加在一个序列的左边，或者让 <code>s[j]</code> 单独放在一个序列的右边，看看这两种情况下的最大值： 
    <ul><li>单独加入 <code>s[i]</code> 后的区间在 <code>[i, j - 1]</code>，此时最长的回文序列的长度就是 <code>dp[i][j - 1]</code>；</li><li>单独加入 <code>s[j]</code> 后的区间在 <code>[i + 1, j]</code>，此时最长的回文序列的长度就是 <code>dp[i + 1][j]</code>；</li></ul> </li></ul> <p>取两者的最大值，于是 <code>dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])</code>。</p> </li><li> <p><strong>初始化：</strong> 需要处理两种边界情况：</p> 
  <ul><li>当 <code>i == j</code> 时，区间内只有一个字符，此时 <code>dp[i][j] = 1</code>；</li><li>当 <code>i + 1 == j</code> 时，区间内有两个字符，如果这两个字符相同，<code>dp[i][j] = 2</code>，否则 <code>dp[i][j] = 0</code>。</li></ul> <p>在填表的时候，可以同步处理第一种边界情况，对于第二种边界情况，<code>dp[i + 1][j - 1]</code> 的值为 <code>0</code>，不会影响最终的结果，因此可以不用考虑。</p> </li><li> <p><strong>填表顺序：</strong> 根据「状态转移」，<code>dp[i + 1]</code> 表示下一行的位置，<code>dp[j - 1]</code> 表示前一列的位置。因此填表顺序应该是「从下往上填写每一行」，「每一行从左往右」。</p> </li><li> <p><strong>返回值：</strong> 根据「状态表达」，返回 <code>[0, n -1]</code> 区域上的最长回文序列的长度，因此需要返回 <code>dp[0][n - 1]</code>。</p> </li></ol> 
<p><strong>代码</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">longestPalindromeSubseq</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> n<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="06_344"></a>06.让字符串成为回文串的最少插入次数</h2> 
<p>题目链接：https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/</p> 
<p>给你一个字符串 <code>s</code> ，每一次操作你都可以在字符串的任意位置插入任意字符。</p> 
<p>请你返回让 <code>s</code> 成为回文串的 <strong>最少操作次数</strong> 。</p> 
<p>「回文串」是正读和反读都相同的字符串。</p> 
<p><strong>示例 1：</strong></p> 
<pre><code>输入：s = "zzazz"
输出：0
解释：字符串 "zzazz" 已经是回文串了，所以不需要做任何插入操作。
</code></pre> 
<p><strong>示例 2：</strong></p> 
<pre><code>输入：s = "mbadm"
输出：2
解释：字符串可变为 "mbdadbm" 或者 "mdbabdm" 。
</code></pre> 
<p><strong>示例 3：</strong></p> 
<pre><code>输入：s = "leetcode"
输出：5
解释：插入 5 个字符后字符串变为 "leetcodocteel" 。
</code></pre> 
<p><strong>提示：</strong></p> 
<ul><li><code>1 &lt;= s.length &lt;= 500</code></li><li><code>s</code> 中所有字符都是小写字母。</li></ul> 
<p><strong>思路</strong></p> 
<ol><li><strong>状态表达：</strong> 以 <code>i</code> 位置为结尾，定义状态表达 <code>dp[i][j]</code> 表示字符串 <code>s</code> 中 <code>[i, j]</code> 区域成为回文子串的最少插入次数。</li><li><strong>状态转移方程：</strong> 回文子序列和回文子串的分析方式一般都是选择这段区域的「左右端点」的字符情况来分析。因为如果一个序列是回文串的话，「去掉首尾两个元素之后依旧是回文串」，「首尾加上两个相同的元素之后也依旧是回文串」。根据首尾元素的不同，可以分为以下两种情况： 
  <ul><li>当 <code>s[i] == s[j]</code> 时，<code>[i, j]</code> 区间内成为回文子串的最少插入次数，取决于 <code>[i + 1, j - 1]</code> 区间内成为回文子串的最少插入次数。若 <code>i &gt;= j - 1</code> 或 <code>i == j - 1</code> （ <code>[i + 1, j - 1]</code> 不构成合法区间），此时只有 1 ~ 2 个相同的字符， <code>[i, j]</code> 区间一定是回文子串，成为回文子串的最少插入次数是 0。此时 <code>dp[i][j] = i &gt;= j - 1 ? 0 : dp[i + 1][j - 1]</code>。</li><li>当 <code>s[i] != s[j]</code> 时，需要在区间的最右边或最左边插入一个字符，取决于 <code>[i + 1, j]</code> 或 <code>[i, j + 1]</code> 区间内成为回文子串的最少插入次数。此时 <code>dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1</code>。</li></ul> </li><li><strong>初始化：</strong> 根据「状态转移方程」，没有不能递推表达的值，无需初始化。</li><li><strong>填表顺序：</strong> 根据「状态转移」，<code>dp[i + 1]</code> 表示下一行的位置，<code>dp[j - 1]</code> 表示前一列的位置。因此填表顺序应该是「从下往上填写每一行」，「每一行从左往右」。</li><li><strong>返回值：</strong> 根据「状态表达」，返回 <code>[0, n - 1]</code> 区域上成为回文子串的最少插入次数，因此需要返回 <code>dp[0][n - 1]</code>。</li></ol> 
<p><strong>代码</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">minInsertions</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> n<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/eee97e4f33ffde45371391505eb87c25/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java初始化list并赋值怎么操作</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a1e29e0cbf6b2e8340101d00019ca3c6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java HotSpot(TM) 64-Bit Server VM warning_ Sharing is only supported for boot loader classes because</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>