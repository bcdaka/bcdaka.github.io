<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android：实现安卓小程序-记事本(备忘录)的开发 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/e2da4fd23ff869cad3cdb5947c5485c2/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Android：实现安卓小程序-记事本(备忘录)的开发">
  <meta property="og:description" content="| 编辑模式-1 | 编辑模式-2 |
| — | — |
| | |
同时可以注意到两者编辑模式略有不同，在编辑模式-1下，可以做到修改，删除，背景色的设置，闹铃的添加，在编辑模式-2下仅仅能做到修改和删除。
左滑Note条目左滑部分关键代码：
首先需要新建一个滑动view类
public class MyScrollView extends ScrollView {
private ScrollViewListener scrollViewListener = null;
public MyScrollView(Context context) {
super(context);
}
public MyScrollView(Context context, AttributeSet attrs,
int defStyle) {
super(context, attrs, defStyle);
}
public MyScrollView(Context context, AttributeSet attrs) {
super(context, attrs);
}
public void setOnScrollListener(ScrollViewListener scrollViewListener) {
this.scrollViewListener = scrollViewListener;
}
@Override
protected void onScrollChanged(int x, int y, int oldx, int oldy) {">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-05T00:53:11+08:00">
    <meta property="article:modified_time" content="2024-04-05T00:53:11+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android：实现安卓小程序-记事本(备忘录)的开发</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>| 编辑模式-1 | 编辑模式-2 |</p> 
<p>| — | — |</p> 
<p>| <img src="https://images2.imgbox.com/ad/24/2rcV7Rud_o.png" alt="在这里插入图片描述"> | <img src="https://images2.imgbox.com/2a/72/JHKSpQ3P_o.png" alt="在这里插入图片描述"> |</p> 
<p>同时可以注意到两者编辑模式略有不同，在编辑模式-1下，可以做到修改，删除，背景色的设置，闹铃的添加，在编辑模式-2下仅仅能做到修改和删除。</p> 
<p>左滑Note条目左滑部分关键代码：</p> 
<p>首先需要新建一个滑动view类</p> 
<p>public class MyScrollView extends ScrollView {<!-- --></p> 
<p>private ScrollViewListener scrollViewListener = null;</p> 
<p>public MyScrollView(Context context) {<!-- --></p> 
<p>super(context);</p> 
<p>}</p> 
<p>public MyScrollView(Context context, AttributeSet attrs,</p> 
<p>int defStyle) {<!-- --></p> 
<p>super(context, attrs, defStyle);</p> 
<p>}</p> 
<p>public MyScrollView(Context context, AttributeSet attrs) {<!-- --></p> 
<p>super(context, attrs);</p> 
<p>}</p> 
<p>public void setOnScrollListener(ScrollViewListener scrollViewListener) {<!-- --></p> 
<p>this.scrollViewListener = scrollViewListener;</p> 
<p>}</p> 
<p>@Override</p> 
<p>protected void onScrollChanged(int x, int y, int oldx, int oldy) {<!-- --></p> 
<p>super.onScrollChanged(x, y, oldx, oldy);</p> 
<p>if (scrollViewListener != null) {<!-- --></p> 
<p>if (oldy &lt; y &amp;&amp; ((y - oldy) &gt; 15)) {<!-- --></p> 
<p>scrollViewListener.onScroll(y - oldy);</p> 
<p>} else if (oldy &gt; y &amp;&amp; (oldy - y) &gt; 15) {<!-- --></p> 
<p>scrollViewListener.onScroll(y - oldy);</p> 
<p>}</p> 
<p>}</p> 
<p>}</p> 
<p>//这一部分参考了github某个开源项目</p> 
<p>public interface ScrollViewListener{//dy Y轴滑动距离</p> 
<p>void onScroll(int dy);</p> 
<p>}</p> 
<p>}</p> 
<p>设置完毕后在xml文件中即可设置应用：</p> 
<p>&lt;com.zc.memo.view.MyScrollView</p> 
<p>adroid:id=“@+id/sv_main”</p> 
<p>adroid:layout_width=“match_parent”</p> 
<p>adroid:layout_height=“wrap_content”</p> 
<p>adroid:background=“@drawable/border_bottom_null”&gt;</p> 
<p>&lt;LinearLayout</p> 
<p>adroid:layout_width=“match_parent”</p> 
<p>adroid:layout_height=“wrap_content”</p> 
<p>adroid:orientation=“vertical”&gt;</p> 
<p>&lt;com.baoyz.swipemenulistview.SwipeMenuListView</p> 
<p>adroid:id=“@+id/smlv_main”</p> 
<p>adroid:layout_width=“match_parent”</p> 
<p>adroid:layout_height=“match_parent”</p> 
<p>adroid:descendantFocusability=“blocksDescendants”</p> 
<p>adroid:divider=“@color/little_gray”</p> 
<p>adroid:dividerHeight=“1dp”</p> 
<p>adroid:background=“@null”</p> 
<p>/&gt;</p> 
<p>&lt;/com.zc.memo.view.MyScrollView&gt;</p> 
<p>接着在activity中，初始化滑动窗口及滑动窗口菜单。</p> 
<p>private void initView() {<!-- --></p> 
<p>data = new NoteManager(context).getNoteList();</p> 
<p>smlvMain.setAdapter(new NoteAdapter(context,data));</p> 
<p>smlvMain.setMenuCreator(new MySwipeMenuCreator(context));</p> 
<p>smlvMain.setSwipeDirection(SwipeMenuListView.DIRECTION_LEFT);</p> 
<p>new ListViewUtil().setListViewHeightBasedOnChildren(smlvMain);</p> 
<p>svMain.setOnScrollListener(new MyScrollView.ScrollViewListener() {<!-- --></p> 
<p>@Override</p> 
<p>public void onScroll(int dy) {<!-- --></p> 
<p>if (dy &gt; 0) {<!-- --></p> 
<p>//下滑</p> 
<p>showOrHideFab(false);</p> 
<p>} else if (dy &lt;= 0 ) {<!-- --></p> 
<p>//上滑</p> 
<p>showOrHideFab(true);</p> 
<p>}</p> 
<p>}</p> 
<p>});</p> 
<p>viewListener();</p> 
<p>emptyListCheck();</p> 
<p>}</p> 
<p>这里仅放上如何初始化滑动窗口的view，关于监听这个滑动窗口的逻辑代码在这里就不赘述了。</p> 
<p>接下来讲一讲自定义NoteAdapter适配器来展示即使条目，首先继承BaseAdapter实现一个抽象类MyBaseAdapter该类可读取List列表的数据。</p> 
<p>public abstract class MyBaseAdapter extends BaseAdapter {<!-- --></p> 
<p>Context context;</p> 
<p>List data;</p> 
<p>public MyBaseAdapter(Context context, List data) {<!-- --></p> 
<p>this.context = context;</p> 
<p>this.data = data;</p> 
<p>}</p> 
<p>@Override</p> 
<p>public Object getItem(int i) {<!-- --></p> 
<p>return null;</p> 
<p>}</p> 
<p>@Override</p> 
<p>public long getItemId(int i) {<!-- --></p> 
<p>return 0;</p> 
<p>}</p> 
<p>@Override</p> 
<p>public int getCount() {<!-- --></p> 
<p>if(data==null) return 0;</p> 
<p>return data.size();</p> 
<p>}</p> 
<p>}</p> 
<p>接着在编写NoteAdapter类继承上类，初始化view, 将Note条目的各项信息展示出来，其中还自定义了一个viewHolder类，方便对xml文件中的各项组件进行绑定编辑。</p> 
<p>public class NoteAdapter extends MyBaseAdapter {<!-- --></p> 
<p>public NoteAdapter(Context context, List data) {<!-- --></p> 
<p>super(context, data);</p> 
<p>}</p> 
<p>@Override</p> 
<p>public View getView(int i, View view, ViewGroup viewGroup) {<!-- --></p> 
<p>ViewHolder viewHolder;</p> 
<p>if(view==null){<!-- --></p> 
<p>viewHolder=new ViewHolder();</p> 
<p>LayoutInflater inflater = LayoutInflater.from(context);</p> 
<p>view = inflater.inflate(R.layout.item_main_list, viewGroup, false);</p> 
<p>viewHolder.tv_lv_month = (TextView) view.findViewById(R.id.tv_lv_month);</p> 
<p>viewHolder.tv_lv_day= (TextView) view.findViewById(R.id.tv_lv_day);</p> 
<p>viewHolder.tv_lv_title = (TextView) view.findViewById(R.id.tv_lv_title);</p> 
<p>viewHolder.tv_lv_content = (TextView) view.findViewById(R.id.tv_lv_content);</p> 
<p>viewHolder.layout = (LinearLayout) view.findViewById(R.id.Linelayout);</p> 
<p>view.setTag(viewHolder);</p> 
<p>}</p> 
<p>else{<!-- --></p> 
<p>viewHolder = (ViewHolder) view.getTag();</p> 
<p>}</p> 
<p>viewHolder.tv_lv_month.setText(data.get(i).getUpdate_date().split(“-”)[1]);</p> 
<p>viewHolder.tv_lv_day.setText(data.get(i).getUpdate_date().split(“-”)[2]);</p> 
<p>viewHolder.tv_lv_title.setText(data.get(i).getTitle());</p> 
<p>viewHolder.tv_lv_content.setText(data.get(i).getText());</p> 
<p>if(data.get(i).getBackground()!=null){<!-- --></p> 
<p>viewHolder.layout.setBackgroundColor(Color.parseColor(data.get(i).getBackground()));</p> 
<p>}</p> 
<p>return view;</p> 
<p>}</p> 
<p>class ViewHolder{<!-- --></p> 
<p>TextView tv_lv_month;</p> 
<p>TextView tv_lv_day;</p> 
<p>TextView tv_lv_title;</p> 
<p>TextView tv_lv_content;</p> 
<p>LinearLayout layout;</p> 
<p>}</p> 
<p>}</p> 
<p><a href="" rel="nofollow"></a>3.5 记事本的背景色设置</p> 
<hr> 
<p>进入到上述提到的编辑模式2中，也就是ContentActivity中，在其底部设置更改背景色功能。这里运用到了会话框的弹出AlertDialog。设置三种颜色。点击确认后，更改数据文件中相应记事条目Note的Background属性。接着进行调用onResume()；使其重新载入数据文件中的记事条目得到背景色的更改。功能截图如下：</p> 
<p>| 背景选项 | 设置成功 |</p> 
<p>| — | — |</p> 
<p>| <img src="https://images2.imgbox.com/00/3f/tpoHSnul_o.png" alt="在这里插入图片描述"> | <img src="https://images2.imgbox.com/09/a3/iZe6xNmg_o.png" alt="在这里插入图片描述"> |</p> 
<p>部分关键代码如下：</p> 
<p>ivSettings.setOnClickListener(new View.OnClickListener() {<!-- --></p> 
<p>@Override</p> 
<p>public void onClick(View v) {<!-- --></p> 
<p>AlertDialog.Builder builder = new AlertDialog.Builder(ContentActivity.this);</p> 
<p>builder.setIcon(R.drawable.fab_settings);</p> 
<p>builder.setTitle(“选择一个背景色”);</p> 
<p>// 指定下拉列表的显示数据</p> 
<p>final String[] colors = {“护眼色”, “薰衣淡紫”, “粉粉粉”};</p> 
<p>builder.setItems(colors, new DialogInterface.OnClickListener()</p> 
<p>{<!-- --></p> 
<p>@Override</p> 
<p>public void onClick(DialogInterface dialog, int which)</p> 
<p>{<!-- --></p> 
<p>Toast.makeText(ContentActivity.this, “选择的背景色为：” + colors[which], Toast.LENGTH_SHORT).show();</p> 
<p>switch (which){<!-- --></p> 
<p>case 0:</p> 
<p>new NoteManager(mContext).updateBackground(title,“#C7EDCC”);</p> 
<p>onResume();</p> 
<p>break;</p> 
<p>case 1:</p> 
<p>new NoteManager(mContext).updateBackground(title,“#E6E6FA”);</p> 
<p>onResume();</p> 
<p>break;</p> 
<p>case 2:</p> 
<p>new NoteManager(mContext).updateBackground(title,“#FC9D9A”);</p> 
<p>onResume();</p> 
<p>break;</p> 
<p>default:</p> 
<p>break;</p> 
<p>}</p> 
<p>}</p> 
<p>});</p> 
<p>builder.show();</p> 
<p>}</p> 
<p>});</p> 
<p><a href="" rel="nofollow"></a>3.6 记事本的闹铃功能</p> 
<hr> 
<p>该功能的实现思路为，为闹钟设置闹铃后，在该记事条目对应得ContentActvity的右上角会显示闹铃的时间，长按该闹铃时间戳则可删除该闹铃，同时闹铃到达指定时间后，会在程序中弹出提示框并且在手机通知栏也会有消息提醒。功能截图如下：</p> 
<p>| 设置闹钟 | 闹钟设置完成 | 通知栏响应 |</p> 
<p>| — | — | — |</p> 
<p>| <img src="https://images2.imgbox.com/6f/4c/uwy3z6k2_o.png" alt="在这里插入图片描述"> | <img src="https://images2.imgbox.com/10/64/LrnfI18l_o.png" alt="在这里插入图片描述"> | <img src="https://images2.imgbox.com/6c/5d/8Kr2DDa1_o.png" alt="在这里插入图片描述"> |</p> 
<p>首先是闹铃时间的设定，这里要对ContentActivity实现相应的设置日期时间的接口。</p> 
<p>public class ContentActivity extends AppCompatActivity</p> 
<p>implements DatePickerDialog.OnDateSetListener, TimePickerDialog.OnTimeSetListener{<!-- --></p> 
<p>@Override</p> 
<p>public void onDateSet(DatePicker view, int year, int monthOfYear, int dayOfMonth) {<!-- --></p> 
<p>alarm_year=year;</p> 
<p>alarm_month=monthOfYear+1;</p> 
<p>alarm_day=dayOfMonth;</p> 
<p>}</p> 
<p>@Override</p> 
<p>public void onTimeSet(TimePicker view, int hourOfDay, int minute) {<!-- --></p> 
<p>alarm_hour=hourOfDay;</p> 
<p>alarm_minute=minute;</p> 
<p>alarm=alarm_year+“/”+alarm_month+“/”+alarm_day+" “+alarm_hour+”:"+alarm_minute;</p> 
<p>av.setText(“Alert at “+alarm+”!”);</p> 
<p>av.setVisibility(View.VISIBLE);</p> 
<p>Log.d(“ContentActivity”,“alarm”+alarm);</p> 
<p>new NoteManager(mContext).updateAlarm(title,alarm);</p> 
<p>loadAlarm(alarm, title, 0);</p> 
<p>Toast.makeText(this,“Alarm will be on at “+alarm+” !”,Toast.LENGTH_LONG).show();</p> 
<p>}</p> 
<p>}</p> 
<p>接着就是开始设置闹铃：</p> 
<p>public void setAlarm(View v) {<!-- --></p> 
<p>if(alarm.length()&lt;=1) {<!-- --></p> 
<p>//if no alarm clock has been set up before</p> 
<p>//show the current time</p> 
<p>Calendar c=Calendar.getInstance();</p> 
<p>alarm_hour=c.get(Calendar.HOUR_OF_DAY);</p> 
<p>alarm_minute=c.get(Calendar.MINUTE);</p> 
<p>alarm_year=c.get(Calendar.YEAR);</p> 
<p>alarm_month=c.get(Calendar.MONTH)+1;</p> 
<p>alarm_day=c.get(Calendar.DAY_OF_MONTH);</p> 
<p>}</p> 
<p>else {<!-- --></p> 
<p>//show the alarm clock time which has been set up before</p> 
<p>int i=0, k=0;</p> 
<p>while(i&lt;alarm.length()&amp;&amp;alarm.charAt(i)!=‘/’) i++;</p> 
<p>alarm_year=Integer.parseInt(alarm.substring(k,i));</p> 
<p>k=i+1;i++;</p> 
<p>while(i&lt;alarm.length()&amp;&amp;alarm.charAt(i)!=‘/’) i++;</p> 
<p>alarm_month=Integer.parseInt(alarm.substring(k,i));</p> 
<p>k=i+1;i++;</p> 
<p>while(i&lt;alarm.length()&amp;&amp;alarm.charAt(i)!=’ ') i++;</p> 
<p>alarm_day=Integer.parseInt(alarm.substring(k,i));</p> 
<p>k=i+1;i++;</p> 
<p>while(i&lt;alarm.length()&amp;&amp;alarm.charAt(i)!=‘:’) i++;</p> 
<p>alarm_hour=Integer.parseInt(alarm.substring(k,i));</p> 
<p>k=i+1;i++;</p> 
<p>alarm_minute=Integer.parseInt(alarm.substring(k));</p> 
<p>}</p> 
<p>new TimePickerDialog(this,this,alarm_hour,alarm_minute,true).show();</p> 
<p>new DatePickerDialog(this,this,alarm_year,alarm_month-1,alarm_day).show();</p> 
<p>}</p> 
<p>同样的，监听该view，若被响应则调用onResume();</p> 
<p>长按删除闹铃功能这里就不再赘述了，接下来来详细讲解如何调用通知栏的通知功能。部分关键代码：</p> 
<p>private void loadAlarm(String alarm, String title, int days) {<!-- --></p> 
<p>int alarm_hour=0;</p> 
<p>int alarm_minute=0;</p> 
<p>int alarm_year=0;</p> 
<p>int alarm_month=0;</p> 
<p>int alarm_day=0;</p> 
<p>int i=0, k=0;</p> 
<p>while(i&lt;alarm.length()&amp;&amp;alarm.charAt(i)!=‘/’) i++;</p> 
<p>alarm_year=Integer.parseInt(alarm.substring(k,i));</p> 
<p>k=i+1;i++;</p> 
<p>while(i&lt;alarm.length()&amp;&amp;alarm.charAt(i)!=‘/’) i++;</p> 
<p>alarm_month=Integer.parseInt(alarm.substring(k,i));</p> 
<p>k=i+1;i++;</p> 
<p>while(i&lt;alarm.length()&amp;&amp;alarm.charAt(i)!=’ ') i++;</p> 
<p>alarm_day=Integer.parseInt(alarm.substring(k,i));</p> 
<p>k=i+1;i++;</p> 
<p>while(i&lt;alarm.length()&amp;&amp;alarm.charAt(i)!=‘:’) i++;</p> 
<p>alarm_hour=Integer.parseInt(alarm.substring(k,i));</p> 
<p>k=i+1;i++;</p> 
<p>alarm_minute=Integer.parseInt(alarm.substring(k));</p> 
<p>Intent intent = new Intent(ContentActivity.this, OneShotAlarm.class);</p> 
<p>intent.putExtra(“alarm_title”,title);</p> 
<p>PendingIntent sender = PendingIntent.getBroadcast(</p> 
<p>ContentActivity.this, 0, intent, 0);</p> 
<p>Calendar calendar = Calendar.getInstance();</p> 
<p>calendar.setTimeInMillis(System.currentTimeMillis());</p> 
<p>Calendar alarm_time = Calendar.getInstance();</p> 
<p>alarm_time.set(alarm_year,alarm_month-1,alarm_day,alarm_hour,alarm_minute);</p> 
<p>AlarmManager am = (AlarmManager) getSystemService(ALARM_SERVICE);</p> 
<p>am.set(AlarmManager.RTC_WAKEUP, alarm_time.getTimeInMillis(), sender);</p> 
<p>}</p> 
<p>在上述关键代码中，可以看到在loadAlarm函数中使用了Intent来传递闹铃时间的消息给OneShotAlarm类，且是再闹铃设置完成后，构建一个PendingIntent广播，通过AlarmManager在时间到达指定的闹铃事件后，发出广播，接收到广播的OneShotAlarm类做出回应，在通知栏显示通知。</p> 
<p>这里要先在AndroidManifest.xml设置广播接收器：</p> 
<p>&lt;receiver</p> 
<p>android:name=“.utils.OneShotAlarm”</p> 
<p>android:process=“:remote” /&gt;</p> 
<p>接下来让我们看看OneShortAlarm类，当OneShotAlarm收到广播后，则构建通知消息并在通知栏显示。同时该类中设置了通知消息显示的内容，有该记事本程序名，记事条目的标题，该记事创建时间戳以及记事内容。通过构造Notification类实现该消息。部分关键代码如下：</p> 
<p>public class OneShotAlarm extends BroadcastReceiver {<!-- --></p> 
<p>private String alarm_title;</p> 
<p>@Override</p> 
<p>public void onReceive(Context context, Intent intent) {<!-- --></p> 
<p>alarm_title=intent.getStringExtra(“alarm_title”);</p> 
<p>Toast.makeText(context,“Time UP!”,Toast.LENGTH_LONG).show();</p> 
<p>Vibrator vb =(Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);</p> 
<p>vb.vibrate(300);</p> 
<p>showNotice(context);</p> 
<p>}</p> 
<p>private void showNotice(Context context) {<!-- --></p> 
<p>Intent intent=new Intent(context,ContentActivity.class);</p> 
<p>Note record = new NoteManager(context).get(alarm_title);</p> 
<p>new NoteManager(context).deleteAlarm(alarm_title);</p> 
<p>PendingIntent pi=PendingIntent.getActivity(context,0,intent,PendingIntent.FLAG_UPDATE_CURRENT);</p> 
<p>NotificationManager manager=(NotificationManager) context.getSystemService(context.NOTIFICATION_SERVICE);</p> 
<p>Notification notification=new NotificationCompat.Builder(context)</p> 
<p>.setContentTitle(record.getCreate_date())</p> 
<p>.setContentText(record.getText())</p> 
<p>.setWhen(System.currentTimeMillis())</p> 
<p>.setSmallIcon(R.mipmap.ic_launcher)</p> 
<p>.setLargeIcon(BitmapFactory.decodeResource(context.getResources(),R.drawable.icon))</p> 
<p>.setContentIntent(pi)</p> 
<p>.setAutoCancel(true)</p> 
<p>//.setStyle(new NotificationCompat.BigTextStyle().bigText(record.getMainText()))</p> 
<p>.setLights(Color.GREEN,1000,1000)</p> 
<p>.build();</p> 
<p>manager.notify(0,notification);</p> 
<p>}</p> 
<p>}</p> 
<p><a href="" rel="nofollow"></a>3.7 高级搜索</p> 
<hr> 
<p>在早先就有了解到一些动态搜索框现成的源码，这里则使用了一些网上开源的搜索框控件的使用。</p> 
<p>首先需要添加第三方依赖，'com.quinny898.library.persistentsearch:library:1.1.0-SNAPSHOT’就可以使用了。该搜索框还支持语音输入识别，但这里因为在设计时并没有考虑语音识别功能，所以这里就弃用了该功能。</p> 
<p>附上功能截图：</p> 
<p><img src="https://images2.imgbox.com/fd/4f/vQpgdrsZ_o.png" alt="在这里插入图片描述"></p> 
<p>&lt;com.quinny898.library.persistentsearch.SearchBox</p> 
<p>android:layout_width=“wrap_content”</p> 
<p>android:id=“@+id/searchbox”</p> 
<p>android:layout_height=“wrap_content”/&gt;</p> 
<p>设置完成后，需要对显示搜索到的记事条目，内容，及搜索到的记事条目总和进行显示，这里布局设计如下：</p> 
<p>&lt;LinearLayout</p> 
<p>android:layout_width=“match_parent”</p> 
<p>android:layout_height=“wrap_content”</p> 
<p>android:orientation=“vertical”&gt;</p> 
<p>&lt;ListView</p> 
<p>android:id=“@+id/history_lis_search”</p> 
<p>android:layout_marginLeft=“20dp”</p> 
<p>android:layout_marginRight=“20dp”</p> 
<p>android:layout_marginBottom=“5dp”</p> 
<p>android:layout_width=“match_parent”</p> 
<p>android:layout_height=“wrap_content”</p> 
<p>android:background=“@drawable/border_bottom_null”&gt;</p> 
<p>&lt;ListView</p> 
<p>android:id=“@+id/content_lis_search”</p> 
<p>android:layout_marginLeft=“20dp”</p> 
<p>android:layout_marginRight=“20dp”</p> 
<p>android:layout_width=“match_parent”</p> 
<p>android:layout_height=“wrap_content”</p> 
<p>android:background=“@drawable/border_bottom_null”&gt;</p> 
<p>&lt;TextView</p> 
<p>android:id=“@+id/bottom_search”</p> 
<p>android:layout_width=“match_parent”</p> 
<p>android:layout_height=“wrap_content”</p> 
<p>android:layout_marginTop=“10dp”</p> 
<p>android:gravity=“center_horizontal” /&gt;</p> 
<p>接着则是代码的实现，实现该功能代码网上有很多现成的实例，这里实现起来并没有看起来的那么复杂，稍微学习后则可写出自己想要的代码：</p> 
<p>public class SearchActivity extends AppCompatActivity {<!-- --></p> 
<p>private Context mContext;</p> 
<p>private SearchBox sbSearch;</p> 
<p>private TextView tvBottom;</p> 
<p>//数据列表</p> 
<p>private List listSearch;</p> 
<p>//结果列表</p> 
<p>private List listResult;</p> 
<p>private ListView mSearchResult ;</p> 
<p>private SearchAdapter mResultAdapter ;</p> 
<p>private ListView mHistory ;</p> 
<p>private HistoryAdapter mHistoryAdapter;</p> 
<p>@Override</p> 
<p>protected void onCreate(Bundle savedInstanceState) {<!-- --></p> 
<p>super.onCreate(savedInstanceState);</p> 
<p>setContentView(R.layout.activity_search);</p> 
<p>mContext = this;</p> 
<p>bindViews();</p> 
<p>}</p> 
<p>@Override</p> 
<p>protected void onResume() {<!-- --></p> 
<p>super.onResume();</p> 
<p>initData();</p> 
<p>init();</p> 
<p>initSearchView();</p> 
<p>initHistory();</p> 
<p>updateBottom();</p> 
<p>}</p> 
<p>private void initData() {<!-- --></p> 
<p>//本地可供检索数据获取,每次resume就要重新渲染</p> 
<p>listSearch = new NoteManager(mContext).getNoteList();</p> 
<p>}</p> 
<p>private void bindViews() {<!-- --></p> 
<p>mSearchResult = (ListView) findViewById(R.id.content_lis_search);</p> 
<p>sbSearch = (SearchBox) findViewById(R.id.searchbox);</p> 
<p>tvBottom = (TextView) findViewById(R.id.bottom_search);</p> 
<p>mHistory = (ListView) findViewById(R.id.history_lis_search);</p> 
<p>}</p> 
<p>public void init(){<!-- --></p> 
<p>listResult = new ArrayList&lt;&gt;();</p> 
<p>mResultAdapter = new SearchAdapter(SearchActivity.this, listResult);</p> 
<p>mSearchResult.setAdapter(mResultAdapter);</p> 
<p>mSearchResult.setOnItemClickListener(new AdapterView.OnItemClickListener() {<!-- --></p> 
<p>@Override</p> 
<p>public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {<!-- --></p> 
<p>manageKeyBoard();</p> 
<p>NoteManager noteManager=new NoteManager(mContext);</p> 
<p>InputMethodManager imm = (InputMethodManager)getSystemService(Context.INPUT_METHOD_SERVICE);</p> 
<p>boolean isOpen = imm.isActive();</p> 
<p>if (isOpen) imm.hideSoftInputFromWindow(view.getWindowToken(), 0); //强制隐藏键盘</p> 
<p>noteManager.ItemClick(listResult.get(position));</p> 
<p>}</p> 
<p>});</p> 
<p>}</p> 
<p>private void initSearchView(){<!-- --></p> 
<p>sbSearch.enableVoiceRecognition(this);</p> 
<p>sbSearch.setMenuListener(new SearchBox.MenuListener(){<!-- --></p> 
<p>@Override</p> 
<p>public void onMenuClick() {<!-- --></p> 
<p>reBack();</p> 
<p>}</p> 
<p>});</p> 
<p>sbSearch.setSearchListener(new SearchBox.SearchListener(){<!-- --></p> 
<p>@Override</p> 
<p>public void onSearchOpened() {<!-- --></p> 
<p>//Use this to tint the screen</p> 
<p>}</p> 
<p>@Override</p> 
<p>public void onSearchClosed() {<!-- --></p> 
<p>//Use this to un-tint the screen</p> 
<p>}</p> 
<p>@Override</p> 
<p>public void onSearchTermChanged(String term) {<!-- --></p> 
<p>search(term);</p> 
<p>updateBottom();</p> 
<p>if(listResult.size()==0){<!-- --></p> 
<p>mHistory.setVisibility(View.VISIBLE);</p> 
<p>}else {<!-- --></p> 
<p>mHistory.setVisibility(View.GONE);</p> 
<p>}</p> 
<p>}</p> 
<p>@Override</p> 
<p>public void onSearch(String searchTerm) {<!-- --></p> 
<p>search(searchTerm);</p> 
<p>saveHistory(searchTerm);</p> 
<p>initHistory();</p> 
<p>updateBottom();</p> 
<p>}</p> 
<p>@Override</p> 
<p>public void onResultClick(SearchResult result) {<!-- --></p> 
<p>//React to a result being clicked</p> 
<p>}</p> 
<p>@Override</p> 
<p>public void onSearchCleared() {<!-- --></p> 
<p>//Called when the clear button is clicked</p> 
<p>}</p> 
<p>});</p> 
<p>}</p> 
<p>private void initHistory(){<!-- --></p> 
<p><strong>自我介绍一下，小编13年上海交大毕业，曾经在小公司待过，也去过华为、OPPO等大厂，18年进入阿里一直到现在。</strong></p> 
<p><strong>深知大多数初中级Android工程师，想要提升技能，往往是自己摸索成长或者是报班学习，但对于培训机构动则近万的学费，着实压力不小。自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！</strong></p> 
<p><strong>因此收集整理了一份《2024年Android移动开发全套学习资料》，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友，同时减轻大家的负担。</strong></p> 
<p><img src="https://images2.imgbox.com/1f/00/5rQ6rkwu_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/90/79/rGkJmc9c_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/dd/d8/2OU8m7Yo_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/14/d9/1lka3Qtl_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/fc/14/Zknqh08S_o.png" alt=""></p> 
<p><strong>既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，基本涵盖了95%以上Android开发知识点，真正体系化！</strong></p> 
<p><strong>由于文件比较大，这里只是将部分目录截图出来，每个节点里面都包含大厂面经、学习笔记、源码讲义、实战项目、讲解视频，并且会持续更新！</strong></p> 
<p><strong>如果你觉得这些内容对你有帮助，可以扫码获取！！（备注：Android）</strong></p> 
<img src="https://images2.imgbox.com/06/75/udODIl8V_o.jpg"> 
<h4><a id="_1167"></a>最后</h4> 
<p><strong>在这里我和身边一些朋友特意整理了一份快速进阶为Android高级工程师的系统且全面的学习资料。涵盖了Android初级——Android高级架构师进阶必备的一些学习技能。</strong></p> 
<p>附上：我们之前因为秋招收集的二十套一二线互联网公司Android面试真题（含BAT、小米、华为、美团、滴滴）和我自己整理Android复习笔记（包含Android基础知识点、Android扩展知识点、Android源码解析、设计模式汇总、Gradle知识点、常见算法题汇总。）</p> 
<p><img src="https://images2.imgbox.com/94/e8/3EylqMVu_o.png" alt=""></p> 
<h6><a id="Androidhttpsbbscsdnnettopics618165277_1175"></a><strong>《Android学习笔记总结+移动架构视频+大厂面试真题+项目实战源码》，<a href="https://bbs.csdn.net/topics/618165277">点击传送门即可获取！</a></strong></h6> 
<p>;</p> 
<p>}</p> 
<p>private void initHistory(){<!-- --></p> 
<p><strong>自我介绍一下，小编13年上海交大毕业，曾经在小公司待过，也去过华为、OPPO等大厂，18年进入阿里一直到现在。</strong></p> 
<p><strong>深知大多数初中级Android工程师，想要提升技能，往往是自己摸索成长或者是报班学习，但对于培训机构动则近万的学费，着实压力不小。自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！</strong></p> 
<p><strong>因此收集整理了一份《2024年Android移动开发全套学习资料》，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友，同时减轻大家的负担。</strong></p> 
<p>[外链图片转存中…(img-RpYoMScR-1712249549976)]</p> 
<p>[外链图片转存中…(img-HSOegwp0-1712249549976)]</p> 
<p>[外链图片转存中…(img-DxdfNQIz-1712249549977)]</p> 
<p>[外链图片转存中…(img-9mI6J3pY-1712249549977)]</p> 
<p>[外链图片转存中…(img-es5Efs4J-1712249549977)]</p> 
<p><strong>既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，基本涵盖了95%以上Android开发知识点，真正体系化！</strong></p> 
<p><strong>由于文件比较大，这里只是将部分目录截图出来，每个节点里面都包含大厂面经、学习笔记、源码讲义、实战项目、讲解视频，并且会持续更新！</strong></p> 
<p><strong>如果你觉得这些内容对你有帮助，可以扫码获取！！（备注：Android）</strong></p> 
<img src="https://images2.imgbox.com/ea/a7/OVnoNpa2_o.jpg"> 
<h4><a id="_1214"></a>最后</h4> 
<p><strong>在这里我和身边一些朋友特意整理了一份快速进阶为Android高级工程师的系统且全面的学习资料。涵盖了Android初级——Android高级架构师进阶必备的一些学习技能。</strong></p> 
<p>附上：我们之前因为秋招收集的二十套一二线互联网公司Android面试真题（含BAT、小米、华为、美团、滴滴）和我自己整理Android复习笔记（包含Android基础知识点、Android扩展知识点、Android源码解析、设计模式汇总、Gradle知识点、常见算法题汇总。）</p> 
<p>[外链图片转存中…(img-0cQZM71S-1712249549978)]</p> 
<h6><a id="Androidhttpsbbscsdnnettopics618165277_1222"></a><strong>《Android学习笔记总结+移动架构视频+大厂面试真题+项目实战源码》，<a href="https://bbs.csdn.net/topics/618165277">点击传送门即可获取！</a></strong></h6>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9e21c18dcd09db1188c662125d49f365/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【WPF应用34】WPF基本控件-Menu的详解与示例</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dbc5681c069c830411fa5bac6cf179a6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SQL实现模糊查询的四种方法总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>