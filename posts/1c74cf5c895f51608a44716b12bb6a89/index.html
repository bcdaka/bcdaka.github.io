<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ubuntu c&#43;&#43; http服务端event使用 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/1c74cf5c895f51608a44716b12bb6a89/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="ubuntu c&#43;&#43; http服务端event使用">
  <meta property="og:description" content="程序：
#ifndef PLATFROMCOMMUNICATION_H #define PLATFROMCOMMUNICATION_H #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;unistd.h&gt; #include &lt;curl/curl.h&gt; #include &lt;net/if.h&gt; #include &lt;sys/ioctl.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;string.h&gt; #include &lt;event.h&gt; #include &lt;event2/event.h&gt; #include &lt;event2/buffer.h&gt; #include &lt;event2/http.h&gt; #include &lt;event2/http_struct.h&gt; #include &lt;event2/http_compat.h&gt; #include &lt;event2/util.h&gt; #include &lt;jsoncpp/json/json.h&gt; #define ETH_NAME &#34;ens33&#34; #define MYHTTPD_SIGNATURE &#34;MoCarHttpd v0.1&#34; using namespace std; class RouteTasks{ public: RouteTasks(); void init(); private: static void login(struct evhttp_request *req, void *arg); string getIp(); int m_port; int m_timeout; }; #endif // PLATFROMCOMMUNICATION_H #include &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-30T08:25:43+08:00">
    <meta property="article:modified_time" content="2024-08-30T08:25:43+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ubuntu c&#43;&#43; http服务端event使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>程序：</p> 
<pre><code>#ifndef PLATFROMCOMMUNICATION_H
#define PLATFROMCOMMUNICATION_H

#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;unistd.h&gt;
#include &lt;curl/curl.h&gt;

#include &lt;net/if.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;string.h&gt;

#include &lt;event.h&gt;
#include &lt;event2/event.h&gt;
#include &lt;event2/buffer.h&gt;
#include &lt;event2/http.h&gt;
#include &lt;event2/http_struct.h&gt;
#include &lt;event2/http_compat.h&gt;
#include &lt;event2/util.h&gt;

#include &lt;jsoncpp/json/json.h&gt;

#define ETH_NAME "ens33"
#define MYHTTPD_SIGNATURE   "MoCarHttpd v0.1"

using namespace std;

class RouteTasks{
public:
    RouteTasks();

    void init();

private:

    static void login(struct evhttp_request *req, void *arg);

    string getIp();

    int m_port;
    int m_timeout;
};

#endif // PLATFROMCOMMUNICATION_H
</code></pre> 
<pre><code>#include "platfromcommunication.h"

RouteTasks::RouteTasks()
{
    m_port = 9000;
    m_timeout = 120;
}

void RouteTasks::init()
{
    //服务端
    //初始化event API
    event_init();

    //创建一个http server
    struct evhttp *httpd;

    httpd = evhttp_start(getIp().c_str(), m_port);

    evhttp_set_timeout(httpd, m_timeout);

    //也可以为特定的URI指定callback
    evhttp_set_cb(httpd, "/cgi-bin/entry.cgi/system/login", &amp;RouteTasks::login, NULL);

    //循环处理events
    event_dispatch();

    evhttp_free(httpd);
}

void RouteTasks::login(evhttp_request *req, void *arg)
{
    char request_data[4096] = {0};

    //获取POST方法的数据
    size_t post_size = EVBUFFER_LENGTH(req-&gt;input_buffer);
    char *post_data = (char *) EVBUFFER_DATA(req-&gt;input_buffer);
    memcpy(request_data, post_data, post_size);
    printf("got control_device_start_stop connection post_data = %s, len =%ld\n", post_data, post_size);

    //解析获得的数据
    string deviceCode;
    string ptz;

    Json::Value jvalue;
    Json::Reader jreader;
    jreader.parse(request_data, jvalue);
    deviceCode = jvalue["sUserName"].asString();
    ptz = jvalue["sPassword"].asString();
    cout&lt;&lt;"============================\n"&lt;&lt;"deviceCode: "&lt;&lt;deviceCode&lt;&lt;" ptz: "&lt;&lt;ptz&lt;&lt;"\n-------------------------\n"&lt;&lt;endl;

    //给前段回复一个响应结果
    Json::Value root;
    Json::FastWriter fastWriter;

    root["code"] = Json::Value("200");
    root["msg"] = Json::Value("成功");

    cout&lt;&lt;"return post"&lt;&lt;fastWriter.write(root)&lt;&lt;endl;

    /* 输出到客户端 */

    //HTTP header
    evhttp_add_header(req-&gt;output_headers, "Server", MYHTTPD_SIGNATURE);
    evhttp_add_header(req-&gt;output_headers, "Content-Type", "application/json; charset=UTF-8");
    evhttp_add_header(req-&gt;output_headers, "Connection", "close");

    //输出的内容
    struct evbuffer *buf;
    buf = evbuffer_new();
    evbuffer_add_printf(buf, "%s", fastWriter.write(root).c_str());

    //将封装好的evbuffer 发送给客户端
    evhttp_send_reply(req, HTTP_OK, "OK", buf);

    evbuffer_free(buf);
}

string RouteTasks::getIp()
{
    struct sockaddr_in sin;
    struct ifreq ifr;

    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if(sockfd == -1) {
        perror("socket error");
        return "";
    }

    strncpy(ifr.ifr_name, ETH_NAME, IFNAMSIZ);

    if(ioctl(sockfd, SIOCGIFADDR, &amp;ifr) == 0) {
        memcpy(&amp;sin, &amp;ifr.ifr_addr, sizeof (ifr.ifr_addr));
        cout&lt;&lt;ETH_NAME&lt;&lt;" ip : "&lt;&lt;inet_ntoa(sin.sin_addr)&lt;&lt;endl;
        return inet_ntoa(sin.sin_addr);
    }

    return "";
}
</code></pre> 
<pre><code>#include &lt;iostream&gt;
#include "platfromcommunication.h"

using namespace std;

//当向进程发出SIGTERM/SIGHUP/SIGINT/SIGQUIT的时候，终止event的事件侦听循环
void signal_handler(int sig) {
    switch (sig) {
        case SIGTERM:
        case SIGHUP:
        case SIGQUIT:
        case SIGINT:
            event_loopbreak();  //终止侦听event_dispatch()的事件侦听循环，执行之后的代码
            break;
    }
}


int main()
{
    cout&lt;&lt;"hello world"&lt;&lt;endl;

    signal(SIGHUP, signal_handler);
    signal(SIGTERM, signal_handler);
    signal(SIGINT, signal_handler);
    signal(SIGQUIT, signal_handler);

    RouteTasks rt;
    rt.init();

    while (1) {
        sleep(1);
    }

    return 0;
}
</code></pre> 
<p>编译： -levent</p> 
<p><span style="color:#fe2c24;">由于在ubuntu中https服务端event是阻塞式运行的，所以在正式项目中，可以将其放入线程中，这样不会阻塞程序运行，具体方式如下：上程序</span></p> 
<pre><code>#ifndef PLATFROMCOMMUNICATION_H
#define PLATFROMCOMMUNICATION_H

#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;unistd.h&gt;
#include &lt;curl/curl.h&gt;

#include &lt;net/if.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;string.h&gt;

#include &lt;event.h&gt;
#include &lt;event2/event.h&gt;
#include &lt;event2/buffer.h&gt;
#include &lt;event2/http.h&gt;
#include &lt;event2/http_struct.h&gt;
#include &lt;event2/http_compat.h&gt;
#include &lt;event2/util.h&gt;

#include &lt;jsoncpp/json/json.h&gt;
#include &lt;boost/thread.hpp&gt;

#define ETH_NAME "ens33"
#define MYHTTPD_SIGNATURE   "MoCarHttpd v0.1"

using namespace std;

class RouteTasks{
public:
    RouteTasks();
    ~RouteTasks();

    void init();

private:

    static void login(struct evhttp_request *req, void *arg);

    static void init_thread(void *arg);

    void init_sub();

    string getIp();

    int m_port;
    int m_timeout;

    //创建一个http server
    struct evhttp *httpd;
};

#endif // PLATFROMCOMMUNICATION_H
</code></pre> 
<pre><code>#include "platfromcommunication.h"

RouteTasks::RouteTasks()
{
    m_port = 7777;
    m_timeout = 120;

    //初始化event API
    event_init();
}

RouteTasks::~RouteTasks()
{
    evhttp_free(httpd);
}

void RouteTasks::init()
{
    boost::thread t(&amp;RouteTasks::init_thread, this);
}

void RouteTasks::login(evhttp_request *req, void *arg)
{
    char request_data[4096] = {0};

    //获取POST方法的数据
    size_t post_size = EVBUFFER_LENGTH(req-&gt;input_buffer);
    char *post_data = (char *) EVBUFFER_DATA(req-&gt;input_buffer);
    memcpy(request_data, post_data, post_size);
    printf("got control_device_start_stop connection post_data = %s, len =%ld\n", post_data, post_size);

    //解析获得的数据
    string deviceCode;
    string ptz;

    Json::Value jvalue;
    Json::Reader jreader;
    jreader.parse(request_data, jvalue);
    deviceCode = jvalue["sUserName"].asString();
    ptz = jvalue["sPassword"].asString();
    cout&lt;&lt;"============================\n"&lt;&lt;"deviceCode: "&lt;&lt;deviceCode&lt;&lt;" ptz: "&lt;&lt;ptz&lt;&lt;"\n-------------------------\n"&lt;&lt;endl;

    //给前段回复一个响应结果
    Json::Value root;
    Json::FastWriter fastWriter;

    root["code"] = Json::Value("200");
    root["msg"] = Json::Value("成功");

    cout&lt;&lt;"return post"&lt;&lt;fastWriter.write(root)&lt;&lt;endl;

    /* 输出到客户端 */

    //HTTP header
    evhttp_add_header(req-&gt;output_headers, "Server", MYHTTPD_SIGNATURE);
    evhttp_add_header(req-&gt;output_headers, "Content-Type", "application/json; charset=UTF-8");
    evhttp_add_header(req-&gt;output_headers, "Connection", "close");

    //输出的内容
    struct evbuffer *buf;
    buf = evbuffer_new();
    evbuffer_add_printf(buf, "%s", fastWriter.write(root).c_str());

    //将封装好的evbuffer 发送给客户端
    evhttp_send_reply(req, HTTP_OK, "OK", buf);

    evbuffer_free(buf);
}

void RouteTasks::init_thread(void *arg)
{
    RouteTasks* rt = (RouteTasks*)arg;

    rt-&gt;init_sub();
}

void RouteTasks::init_sub()
{
    //服务端
//    //初始化event API
//    event_init();

//    //创建一个http server
//    struct evhttp *httpd;

    httpd = evhttp_start(getIp().c_str(), m_port);

    evhttp_set_timeout(httpd, m_timeout);

    //也可以为特定的URI指定callback
    evhttp_set_cb(httpd, "/cgi-bin/entry.cgi/system/login", &amp;RouteTasks::login, NULL);

    //循环处理events
    event_dispatch();

//    evhttp_free(httpd);
}

string RouteTasks::getIp()
{
    struct sockaddr_in sin;
    struct ifreq ifr;

    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if(sockfd == -1) {
        perror("socket error");
        return "";
    }

    strncpy(ifr.ifr_name, ETH_NAME, IFNAMSIZ);

    if(ioctl(sockfd, SIOCGIFADDR, &amp;ifr) == 0) {
        memcpy(&amp;sin, &amp;ifr.ifr_addr, sizeof (ifr.ifr_addr));
        cout&lt;&lt;ETH_NAME&lt;&lt;" ip : "&lt;&lt;inet_ntoa(sin.sin_addr)&lt;&lt;endl;
        return inet_ntoa(sin.sin_addr);
    }

    return "";
}
</code></pre> 
<pre><code>#include &lt;iostream&gt;
#include "platfromcommunication.h"

using namespace std;

//当向进程发出SIGTERM/SIGHUP/SIGINT/SIGQUIT的时候，终止event的事件侦听循环
void signal_handler(int sig) {
    switch (sig) {
        case SIGTERM:
        case SIGHUP:
        case SIGQUIT:
        case SIGINT:
            event_loopbreak();  //终止侦听event_dispatch()的事件侦听循环，执行之后的代码
            break;
    }
}


int main()
{
    cout&lt;&lt;"hello world"&lt;&lt;endl;

    signal(SIGHUP, signal_handler);
    signal(SIGTERM, signal_handler);
    signal(SIGINT, signal_handler);
    signal(SIGQUIT, signal_handler);

    RouteTasks rt;
    rt.init();

    while (1) {
        sleep(1);
    }

    return 0;
}
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7e1fc078c2bc4a1f00246535625e1331/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">顶级域名服务器 - TLD服务器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ee7b63f36932b5b8431aeb8cd5aaa380/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java经典框架之MyBatis</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>