<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java 并发集合：阻塞队列集合介绍 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/01cd7a42a74ee97470d5359e490002e5/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java 并发集合：阻塞队列集合介绍">
  <meta property="og:description" content="大家好，我是栗筝i，这篇文章是我的 “栗筝i 的 Java 技术栈” 专栏的第 028 篇文章，在 “栗筝i 的 Java 技术栈” 这个专栏中我会持续为大家更新 Java 技术相关全套技术栈内容。专栏的主要目标是已经有一定 Java 开发经验，并希望进一步完善自己对整个 Java 技术体系来充实自己的技术栈的同学。与此同时，本专栏的所有文章，也都会准备充足的代码示例和完善的知识点梳理，因此也十分适合零基础的小白和要准备工作面试的同学学习。当然，我也会在必要的时候进行相关技术深度的技术解读，相信即使是拥有多年 Java 开发经验的从业者和大佬们也会有所收获并找到乐趣。
–
在多线程编程中，如何有效地进行线程间通信和协调是一个关键问题。Java 并发包中的阻塞队列集合（BlockingQueue）为开发者提供了强大的工具，能够简化线程同步与数据共享的复杂性。阻塞队列不仅能够在生产者和消费者之间进行线程安全的数据传递，还通过自动的阻塞和唤醒机制，帮助我们轻松实现高效的生产者-消费者模型。本篇文章将详细介绍 Java 中几种常用的阻塞队列集合，分析它们的特点、应用场景及实现原理，帮助您更好地理解并掌握这些并发工具。
文章目录 1、Java 阻塞队列的介绍1.1、Java 阻塞队列概述1.2、Java 阻塞队列接口1.3、Java 阻塞队列与非阻塞队列 2、Java 阻塞队列的具体实现2.1、数据结构2.2、插入操作2.3、获取操作 3、Java 阻塞队列知识点拓展3.1、ArrayBlockingQueue 和 LinkedBlockingQueue 之间的区别3.2、关于 SynchronousQueue 的介绍 1、Java 阻塞队列的介绍 1.1、Java 阻塞队列概述 Java 中的阻塞队列（BlockingQueue）是一种在多线程环境下用于线程安全的数据结构，它不仅提供了典型的队列操作（如插入和移除），还可以在队列为空或满时自动阻塞操作线程，直到队列状态允许操作的继续。阻塞队列通过阻塞和等待机制有效地协调生产者和消费者线程之间的操作，确保数据一致性和线程安全。
以下是其主要功能和应用场景：
线程间通信：阻塞队列在生产者-消费者模型中扮演了关键角色，它允许生产者线程和消费者线程之间进行线程安全的数据传递。具体表现为：
生产者线程：生产者线程将数据放入队列中。如果队列已满，生产者线程将被阻塞，直到队列有空闲空间。
消费者线程：消费者线程从队列中取出数据。如果队列为空，消费者线程将被阻塞，直到有数据可供消费。
流量控制：通过阻塞机制，阻塞队列可以有效地控制生产者和消费者的工作节奏，避免过载和资源浪费。当队列达到容量上限时，阻塞队列会自动阻止进一步的插入操作，直到有空间可用，从而避免过载和资源浪费。
简化并发编程：阻塞队列封装了复杂的同步机制，简化了多线程环境下的数据共享和线程协调，使得开发者可以专注于业务逻辑，而不必担心线程安全问题。
1.2、Java 阻塞队列接口 BlockingQueue 是 Java 并发包（java.util.concurrent）中的一个接口，继承自 Queue 接口。它提供了额外的阻塞操作，例如在队列为空时等待元素变得可用，或在队列已满时等待空间变得可用。
BlockingQueue 阻塞队列在 Java 中的主要实现有三个：
ArrayBlockingQueue： 基于数组实现的有界阻塞队列，必须指定固定容量，支持可选的公平性策略。LinkedBlockingQueue： 基于链表实现的阻塞队列，默认无界或指定容量，有较高的插入和删除性能。SynchronousQueue： 一个没有内部容量的队列，每个插入操作必须等待一个对应的删除操作，反之亦然，适用于直接交换数据的场景。 1.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-08T17:57:43+08:00">
    <meta property="article:modified_time" content="2024-08-08T17:57:43+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java 并发集合：阻塞队列集合介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>大家好，我是栗筝i，这篇文章是我的 “栗筝i 的 Java 技术栈” 专栏的第 028 篇文章，在 “栗筝i 的 Java 技术栈” 这个专栏中我会持续为大家更新 Java 技术相关全套技术栈内容。专栏的主要目标是已经有一定 Java 开发经验，并希望进一步完善自己对整个 Java 技术体系来充实自己的技术栈的同学。与此同时，本专栏的所有文章，也都会准备充足的代码示例和完善的知识点梳理，因此也十分适合零基础的小白和要准备工作面试的同学学习。当然，我也会在必要的时候进行相关技术深度的技术解读，相信即使是拥有多年 Java 开发经验的从业者和大佬们也会有所收获并找到乐趣。</p> 
 <p>–</p> 
 <p>在多线程编程中，如何有效地进行线程间通信和协调是一个关键问题。Java 并发包中的阻塞队列集合（BlockingQueue）为开发者提供了强大的工具，能够简化线程同步与数据共享的复杂性。阻塞队列不仅能够在生产者和消费者之间进行线程安全的数据传递，还通过自动的阻塞和唤醒机制，帮助我们轻松实现高效的生产者-消费者模型。本篇文章将详细介绍 Java 中几种常用的阻塞队列集合，分析它们的特点、应用场景及实现原理，帮助您更好地理解并掌握这些并发工具。</p> 
</blockquote> 
<hr> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><ul><li><a href="#1Java__14" rel="nofollow">1、Java 阻塞队列的介绍</a></li><li><ul><li><a href="#11Java__16" rel="nofollow">1.1、Java 阻塞队列概述</a></li><li><a href="#12Java__31" rel="nofollow">1.2、Java 阻塞队列接口</a></li><li><a href="#13Java__41" rel="nofollow">1.3、Java 阻塞队列与非阻塞队列</a></li></ul> 
    </li><li><a href="#2Java__62" rel="nofollow">2、Java 阻塞队列的具体实现</a></li><li><ul><li><a href="#21_66" rel="nofollow">2.1、数据结构</a></li><li><a href="#22_128" rel="nofollow">2.2、插入操作</a></li><li><a href="#23_228" rel="nofollow">2.3、获取操作</a></li></ul> 
    </li><li><a href="#3Java__341" rel="nofollow">3、Java 阻塞队列知识点拓展</a></li><li><ul><li><a href="#31ArrayBlockingQueue__LinkedBlockingQueue__343" rel="nofollow">3.1、ArrayBlockingQueue 和 LinkedBlockingQueue 之间的区别</a></li><li><a href="#32_SynchronousQueue__373" rel="nofollow">3.2、关于 SynchronousQueue 的介绍</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h4><a id="1Java__14"></a>1、Java 阻塞队列的介绍</h4> 
<h5><a id="11Java__16"></a>1.1、Java 阻塞队列概述</h5> 
<p>Java 中的阻塞队列（BlockingQueue）是一种在多线程环境下用于线程安全的数据结构，它不仅提供了典型的队列操作（如插入和移除），还可以在队列为空或满时自动阻塞操作线程，直到队列状态允许操作的继续。阻塞队列通过阻塞和等待机制有效地协调生产者和消费者线程之间的操作，确保数据一致性和线程安全。</p> 
<p>以下是其主要功能和应用场景：</p> 
<ul><li> <p><strong>线程间通信</strong>：阻塞队列在生产者-消费者模型中扮演了关键角色，它允许生产者线程和消费者线程之间进行线程安全的数据传递。具体表现为：</p> 
  <ul><li> <p>生产者线程：生产者线程将数据放入队列中。如果队列已满，生产者线程将被阻塞，直到队列有空闲空间。</p> </li><li> <p>消费者线程：消费者线程从队列中取出数据。如果队列为空，消费者线程将被阻塞，直到有数据可供消费。</p> </li></ul> </li><li> <p><strong>流量控制</strong>：通过阻塞机制，阻塞队列可以有效地控制生产者和消费者的工作节奏，避免过载和资源浪费。当队列达到容量上限时，阻塞队列会自动阻止进一步的插入操作，直到有空间可用，从而避免过载和资源浪费。</p> </li><li> <p><strong>简化并发编程</strong>：阻塞队列封装了复杂的同步机制，简化了多线程环境下的数据共享和线程协调，使得开发者可以专注于业务逻辑，而不必担心线程安全问题。</p> </li></ul> 
<h5><a id="12Java__31"></a>1.2、Java 阻塞队列接口</h5> 
<p><code>BlockingQueue</code> 是 Java 并发包（<code>java.util.concurrent</code>）中的一个接口，继承自 <code>Queue</code> 接口。它提供了额外的阻塞操作，例如在队列为空时等待元素变得可用，或在队列已满时等待空间变得可用。</p> 
<p><code>BlockingQueue</code> 阻塞队列在 Java 中的主要实现有三个：</p> 
<ol><li><code>ArrayBlockingQueue</code>： 基于数组实现的有界阻塞队列，必须指定固定容量，支持可选的公平性策略。</li><li><code>LinkedBlockingQueue</code>： 基于链表实现的阻塞队列，默认无界或指定容量，有较高的插入和删除性能。</li><li><code>SynchronousQueue</code>： 一个没有内部容量的队列，每个插入操作必须等待一个对应的删除操作，反之亦然，适用于直接交换数据的场景。</li></ol> 
<h5><a id="13Java__41"></a>1.3、Java 阻塞队列与非阻塞队列</h5> 
<p>阻塞队列和非阻塞队列的区别：</p> 
<p><strong>操作方式</strong>：</p> 
<ul><li>阻塞队列：阻塞队列在插入或移除操作无法立即执行时，线程会被阻塞，直到操作可以继续。例如，当队列已满时，插入操作会被阻塞；当队列为空时，移除操作会被阻塞。</li><li>非阻塞队列：非阻塞队列在插入或移除元素时不会阻塞线程。如果队列满了，插入操作可能会立即失败；如果队列为空，移除操作可能会立即返回空值或失败</li></ul> 
<p><strong>线程安全性</strong>：</p> 
<ul><li>阻塞队列：阻塞操作通常通过同步机制来实现，比如使用锁或条件变量。在 <code>ArrayBlockingQueue</code> 和 <code>LinkedBlockingQueue</code> 中，生产者线程会在队列满时进入等待状态，直到消费者线程移除元素，释放出空间。</li><li>非阻塞队列：非阻塞队列通常使用无锁算法（例如 CAS 操作）来实现线程安全，这样即使在高并发情况下，操作也不会造成线程阻塞。</li></ul> 
<p><strong>适用场景</strong>：</p> 
<ul><li>阻塞队列：生产者-消费者模式 – 在生产者和消费者线程之间传递数据，生产者插入数据到队列，消费者从队列中移除数据。阻塞队列可以有效地平衡生产者和消费者的速度，避免出现生产者过快导致队列溢出或消费者过慢导致队列空转的问题。</li><li>非阻塞队列：高并发场景 – 在高并发场景下，非阻塞队列由于避免了锁的使用，性能更高，更适合需要高吞吐量和低延迟的应用。</li></ul> 
<hr> 
<h4><a id="2Java__62"></a>2、Java 阻塞队列的具体实现</h4> 
<p>我们这里以 <code>ArrayBlockingQueue</code> 为例，来看 Java 对于阻塞队列的具体实现。</p> 
<h5><a id="21_66"></a>2.1、数据结构</h5> 
<p><code>ArrayBlockingQueue</code> 类使用一个数组 <code>items</code> 存储队列元素，并通过 <code>takeIndex</code> 和 <code>putIndex</code> 字段来跟踪下一个取出和放入元素的索引，同时用 <code>count</code> 记录当前队列中的元素数量。为了确保线程安全，<code>ArrayBlockingQueue</code> 使用 <code>ReentrantLock</code> 作为主要锁，配合 <code>Condition</code> 对象 <code>notEmpty</code> 和 <code>notFull</code> 分别用于管理线程在队列为空或已满时的等待和通知。<code>itrs</code> 字段用于维护当前活动的迭代器的状态，允许队列操作在进行元素添加或移除时保持迭代器的一致性。如果没有活动的迭代器，<code>itrs</code> 将为 <code>null</code>。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>
        <span class="token keyword">implements</span> <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> 
<span class="token punctuation">{<!-- --></span>

		<span class="token comment">// 省略其他方法和实现细节</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    <span class="token comment">/** 队列中的元素 */</span>
    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"serial"</span><span class="token punctuation">)</span> <span class="token comment">// 有条件序列化</span>
    <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> items<span class="token punctuation">;</span>

    <span class="token comment">/** 下一个 take、poll、peek 或 remove 操作的元素索引 */</span>
    <span class="token keyword">int</span> takeIndex<span class="token punctuation">;</span>

    <span class="token comment">/** 下一个 put、offer 或 add 操作的元素索引 */</span>
    <span class="token keyword">int</span> putIndex<span class="token punctuation">;</span>

    <span class="token comment">/** 队列中的元素数量 */</span>
    <span class="token keyword">int</span> count<span class="token punctuation">;</span>

    <span class="token comment">/*
     * 并发控制使用经典的双条件算法，
     * 这是任何教科书中都可以找到的。
     */</span>

    <span class="token comment">/** 保护所有访问的主要锁 */</span>
    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock<span class="token punctuation">;</span>

    <span class="token comment">/** 用于等待取元素的条件 */</span>
    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"serial"</span><span class="token punctuation">)</span>  <span class="token comment">// 实现 Condition 的类可能是可序列化的。</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Condition</span> notEmpty<span class="token punctuation">;</span>

    <span class="token comment">/** 用于等待放入元素的条件 */</span>
    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"serial"</span><span class="token punctuation">)</span>  <span class="token comment">// 实现 Condition 的类可能是可序列化的。</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Condition</span> notFull<span class="token punctuation">;</span>

    <span class="token comment">/**
     * 当前活动迭代器的共享状态，如果没有已知的迭代器，则为 null。
     * 允许队列操作更新迭代器状态。
     */</span>
    <span class="token keyword">transient</span> <span class="token class-name">Itrs</span> itrs<span class="token punctuation">;</span>
  
    <span class="token comment">// 省略其他方法和实现细节</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>关于 <code>Condition</code> ： <code>Condition</code> 是 Java 并发库中的一个接口，它提供了一种线程间通信机制，使得线程能够在特定条件下等待和通知。<code>Condition</code> 的主要作用是为线程提供等待和通知机制，以便协调和管理线程的执行顺序。</p> 
<p><code>Condition</code> 的主要功能：</p> 
<ul><li>等待（Wait）：线程可以在 <code>Condition</code> 上调用 <code>await()</code> 方法进入等待状态，直到其他线程发出通知（即 <code>signal()</code> 或 <code>signalAll()</code>）；<code>await()</code> 方法使当前线程释放持有的锁，并进入等待队列，直到条件满足或被中断。此时线程会自动重新获取锁。</li><li>通知（Signal）：通过 <code>Condition</code> 的 <code>signal()</code> 方法，线程可以通知一个等待在该 <code>Condition</code> 上的线程，使其从等待状态中恢复并重新获取锁；使用 <code>signalAll()</code> 方法可以通知所有在该 <code>Condition</code> 上等待的线程，唤醒它们。</li><li>超时等待：<code>await(long time, TimeUnit unit)</code> 方法允许线程在等待时指定超时时间。如果超时，线程会自动从等待状态恢复，并且不需要手动调用 <code>signal()</code>。</li></ul> 
<p><code>Condition</code> 和直接调用线程的方式相比：<code>Condition</code> 提供了更高级、更灵活的线程协调机制，能够与 <code>ReentrantLock</code> 配合使用，适合处理复杂的并发控制和条件等待需求。它支持多条件和超时等待等高级功能。</p> 
<h5><a id="22_128"></a>2.2、插入操作</h5> 
<p><code>ArrayBlockingQueue</code> 通过 <code>ReentrantLock</code> 和 <code>Condition</code> 实现线程安全的元素插入操作。<code>offer(E e)</code> 尝试将元素 <code>e</code> 插入队列，如果队列未满则成功插入，否则返回 <code>false</code>。<code>put(E e)</code> 在队列已满时阻塞线程直到有空间，并插入元素。<code>offer(E e, long timeout, TimeUnit unit)</code> 在指定超时时间内尝试插入元素，超时后返回 <code>false</code>。<code>enqueue(E e)</code> 将元素插入队列的尾部，更新索引，增加元素计数，并通知等待取元素的线程。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>
        <span class="token keyword">implements</span> <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> 
<span class="token punctuation">{<!-- --></span>

    <span class="token comment">// 省略其他方法和实现细节</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    <span class="token comment">/**
     * 尝试将指定元素插入队列的尾部，如果队列容量未满则立即成功插入，
     * 插入成功时返回 {@code true}，如果队列已满则返回 {@code false}。
     * 这个方法通常比 {@link #add} 方法更可取，因为后者在插入失败时会抛出异常。
     *
     * @throws NullPointerException 如果指定的元素为 null
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 检查元素是否为 null，如果为 null 抛出异常</span>
        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span> <span class="token comment">// 获取锁对象</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取锁</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment">// 如果队列已满</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 插入失败，返回 false</span>
            <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                <span class="token function">enqueue</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用 enqueue 方法插入元素</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 插入成功，返回 true</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 释放锁</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 将指定元素插入队列的尾部，如果队列已满则阻塞当前线程直到有空间可用。
     *
     * @throws InterruptedException {@inheritDoc}
     * @throws NullPointerException {@inheritDoc}
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 检查元素是否为 null，如果为 null 抛出异常</span>
        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span> <span class="token comment">// 获取锁对象</span>
        lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取锁，允许中断</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment">// 如果队列已满</span>
                notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等待直到队列有空间</span>
            <span class="token function">enqueue</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用 enqueue 方法插入元素</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 释放锁</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 将指定元素插入队列的尾部，如果队列已满，则在指定的等待时间内等待空间可用。
     *
     * @throws InterruptedException {@inheritDoc}
     * @throws NullPointerException {@inheritDoc}
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">,</span> <span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{<!-- --></span>

        <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 检查元素是否为 null，如果为 null 抛出异常</span>
        <span class="token keyword">long</span> nanos <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将超时时间转换为纳秒</span>
        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span> <span class="token comment">// 获取锁对象</span>
        lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取锁，允许中断</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 如果队列已满</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> <span class="token number">0L</span><span class="token punctuation">)</span> <span class="token comment">// 如果超时时间已过</span>
                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 返回 false 表示插入失败</span>
                nanos <span class="token operator">=</span> notFull<span class="token punctuation">.</span><span class="token function">awaitNanos</span><span class="token punctuation">(</span>nanos<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等待指定的时间，直到队列有空间</span>
            <span class="token punctuation">}</span>
            <span class="token function">enqueue</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用 enqueue 方法插入元素</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 插入成功，返回 true</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 释放锁</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 内部方法，将指定元素插入队列的尾部。
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// assert lock.isHeldByCurrentThread(); // 确保当前线程持有锁</span>
        <span class="token comment">// assert lock.getHoldCount() == 1; // 确保锁的持有计数为 1</span>
        <span class="token comment">// assert items[putIndex] == null; // 确保插入位置为空</span>
        <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> items <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">;</span> <span class="token comment">// 获取存储元素的数组</span>
        items<span class="token punctuation">[</span>putIndex<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span> <span class="token comment">// 将元素放入数组的指定位置</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>putIndex <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span> putIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 更新插入索引，若超出数组长度则重置为 0</span>
        count<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 增加队列中的元素数量</span>
        notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 唤醒等待取元素的线程</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 省略其他方法和实现细节</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

</code></pre> 
<h5><a id="23_228"></a>2.3、获取操作</h5> 
<p><code>ArrayBlockingQueue</code> 提供了多种获取元素的方法：<code>poll()</code> 尝试移除并返回队列头部的元素，如果队列为空则返回 <code>null</code>；<code>take()</code> 移除并返回队列头部的元素，如果队列为空则阻塞当前线程直到有元素可用；<code>poll(long timeout, TimeUnit unit)</code> 在指定的超时时间内尝试移除并返回头部元素，若超时则返回 <code>null</code>；<code>peek()</code> 返回队列头部的元素但不移除它，如果队列为空则返回 <code>null</code>。这些方法通过 <code>ReentrantLock</code> 和 <code>Condition</code> 实现线程安全的队列操作，确保在并发环境下对队列的正确访问和管理</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>
        <span class="token keyword">implements</span> <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> 
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 省略其他方法和实现细节</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    <span class="token comment">/**
     * 从队列中移除并返回头部元素，如果队列为空则返回 null。
     *
     * @return 队列头部元素；如果队列为空则返回 null。
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 从队列中移除并返回头部元素，如果队列为空则阻塞当前线程，直到有元素可用。
     *
     * @return 队列头部元素。
     * @throws InterruptedException 如果线程在等待时被中断。
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
        lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                notEmpty<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 队列为空时，等待有元素可用</span>
            <span class="token keyword">return</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 尝试从队列中移除并返回头部元素，在指定的超时时间内等待元素变得可用。
     *
     * @param timeout 等待的最大时间。
     * @param unit 时间单位。
     * @return 队列头部元素；如果在超时时间内未获得元素则返回 null。
     * @throws InterruptedException 如果线程在等待时被中断。
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">long</span> nanos <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将超时时间转换为纳秒</span>
        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
        lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> <span class="token number">0L</span><span class="token punctuation">)</span>
                    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 超时返回 null</span>
                nanos <span class="token operator">=</span> notEmpty<span class="token punctuation">.</span><span class="token function">awaitNanos</span><span class="token punctuation">(</span>nanos<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等待指定的时间</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 返回队列头部的元素，但不移除它。如果队列为空，则返回 null。
     *
     * @return 队列头部元素；如果队列为空则返回 null。
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token function">itemAt</span><span class="token punctuation">(</span>takeIndex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回队列头部的元素；如果队列为空则返回 null</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 从当前的取元素位置提取元素，更新位置，并发出信号。
     * 仅在持有锁的情况下调用。
     *
     * @return 提取的元素。
     */</span>
    <span class="token keyword">private</span> <span class="token class-name">E</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// assert lock.isHeldByCurrentThread();</span>
        <span class="token comment">// assert lock.getHoldCount() == 1;</span>
        <span class="token comment">// assert items[takeIndex] != null;</span>
        <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> items <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">;</span>
        <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>
        <span class="token class-name">E</span> e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> items<span class="token punctuation">[</span>takeIndex<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 获取并强制转换元素</span>
        items<span class="token punctuation">[</span>takeIndex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 清除元素位置</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>takeIndex <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span> takeIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 更新取出位置索引</span>
        count<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">// 减少队列中的元素数量</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>itrs <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            itrs<span class="token punctuation">.</span><span class="token function">elementDequeued</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 更新迭代器状态（如果存在）</span>
        notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 通知生产者线程队列有空间</span>
        <span class="token keyword">return</span> e<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 省略其他方法和实现细节</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

</code></pre> 
<hr> 
<h4><a id="3Java__341"></a>3、Java 阻塞队列知识点拓展</h4> 
<h5><a id="31ArrayBlockingQueue__LinkedBlockingQueue__343"></a>3.1、ArrayBlockingQueue 和 LinkedBlockingQueue 之间的区别</h5> 
<p><code>ArrayBlockingQueue</code> 和 <code>LinkedBlockingQueue</code> 是 Java 中的两种阻塞队列，它们在实现和使用场景上有显著的区别：</p> 
<p><strong>数据结构</strong>：</p> 
<ul><li> <p><code>ArrayBlockingQueue</code>：使用固定大小的数组实现；内部是一个环形缓冲区（Circular Buffer），容量在初始化时设定，不可动态调整。</p> </li><li> <p><code>LinkedBlockingQueue</code>：使用链表实现；内部是一个双端链表，容量可以在初始化时设定，默认最大容量为 <code>Integer.MAX_VALUE</code>，并且可以动态扩展。</p> </li></ul> 
<p><strong>存储特性</strong>：</p> 
<ul><li> <p><code>ArrayBlockingQueue</code>：内存占用固定，因为容量在创建时就已经确定；适合容量已知且稳定的场景。</p> </li><li> <p><code>LinkedBlockingQueue</code>：内存占用根据实际存储的元素数量动态变化；适合容量不确定或需要动态调整的场景。</p> </li></ul> 
<p><strong>性能</strong>：</p> 
<ul><li> <p><code>ArrayBlockingQueue</code>：插入和删除操作较为高效，因为是基于数组的索引操作；更好的缓存局部性，适合固定容量的高并发场景。</p> </li><li> <p><code>LinkedBlockingQueue</code>：插入和删除操作涉及链表节点的操作，可能稍慢；适合动态容量变化的场景，内存使用灵活。</p> </li></ul> 
<p><strong>使用场景</strong>：</p> 
<ul><li> <p><code>ArrayBlockingQueue</code>：用于容量固定的情况，如固定大小的线程池任务队列；内存占用稳定，性能预测性强。</p> </li><li> <p><code>LinkedBlockingQueue</code>：用于需要大容量或容量可变的情况，如任务缓存队列；内存使用灵活，适应变化的工作负载。</p> </li></ul> 
<p>总结：<code>ArrayBlockingQueue</code> 是基于固定大小数组的阻塞队列，适合固定容量的应用场景；而 <code>LinkedBlockingQueue</code> 是基于链表的阻塞队列，适合容量不确定的场景。二者在性能、内存占用和适用场景上各有特点。</p> 
<h5><a id="32_SynchronousQueue__373"></a>3.2、关于 SynchronousQueue 的介绍</h5> 
<p><code>SynchronousQueue</code> 是 Java 中的一种特殊的阻塞队列，其实现和行为与传统的阻塞队列有显著不同。以下是 <code>SynchronousQueue</code> 的大致实现和特点：</p> 
<p><strong>数据结构</strong>：<code>SynchronousQueue</code> 不使用任何内部存储结构来保存元素。即，它不持有任何实际的元素。每个插入操作必须等待一个线程来执行移除操作，反之亦然。即，插入和移除操作是直接配对的。</p> 
<p><strong>操作特性</strong>：</p> 
<ul><li> <p>插入操作 (<code>put()</code>、<code>offer()</code>)：当调用 <code>put()</code> 或 <code>offer()</code> 方法插入元素时，当前线程会被阻塞，直到另一个线程调用 <code>take()</code> 或 <code>poll()</code> 方法从队列中移除该元素。这种机制确保了每个插入操作都有一个对应的移除操作。</p> </li><li> <p>移除操作 (<code>take()</code>、<code>poll()</code>)：当调用 <code>take()</code> 或 <code>poll()</code> 方法移除元素时，当前线程会被阻塞，直到另一个线程调用 <code>put()</code> 或 <code>offer()</code> 方法将元素插入队列。这种机制确保了每个移除操作都有一个对应的插入操作。</p> </li></ul> 
<p><strong>线程交互</strong>：<code>SynchronousQueue</code> 实际上可以被视为一 “零容量” 队列，因为它不存储任何元素。插入和移除操作是完全同步的，必须在操作之间进行配对。</p> 
<p><strong>使用场景</strong>：常用于需要直接交换任务和线程的场景，如线程池的工作队列。线程池中的工作线程可以直接从队列中获取任务，而不需要额外的存储空间。</p> 
<p><strong>内部实现</strong>：<code>SynchronousQueue</code> 使用一组条件变量来实现线程间的配对机制。使用 <code>ReentrantLock</code> 和 <code>Condition</code> 对象来管理线程的等待和通知。</p> 
<p>总的来说，<code>SynchronousQueue</code> 是一种特殊的阻塞队列，不存储元素，所有的插入操作都需要有相应的移除操作配对。它用于需要直接交换数据或任务的场景，如线程池的工作队列，其实现基于条件变量来管理线程的同步操作。</p> 
<hr>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ff427c9c1fd592ea19ff827f1970a0c9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">FANUC发那科模块 A03B-0823-C003 I/0 EXT</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fc0173fbbb0e8f094deb30699b423c59/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">论文阅读:Efficient Core Maintenance in Large Bipartite Graphs | SIGMOD 2024</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>