<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;航海王：追寻罗杰的编程之路】一篇文章带你认识哈希 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/95a4a0e3cfc46d363419fcce98451fd5/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;航海王：追寻罗杰的编程之路】一篇文章带你认识哈希">
  <meta property="og:description" content="目录
1 -&gt; unordered系列关联式容器
1.1 -&gt; unordered_map
1.1.1 -&gt; unordered_map的文档介绍
1.1.2 -&gt; unordered_map的接口说明
1.2 -&gt; unordered_set
2 -&gt; 底层结构
2.1 -&gt; 哈希概念
2.2 -&gt; 哈希冲突
2.3 -&gt; 哈希函数
2.4 -&gt; 哈希冲突解决
2.4.1 -&gt; 闭散列
2.4.2 -&gt; 开散列
3 -&gt; 模拟实现
3.1 -&gt; 哈希表的改造
3.2 -&gt; unordered_map
3.3 -&gt; unordered_set
1 -&gt; unordered系列关联式容器 在C&#43;&#43;98中，STL提供了底层为红黑树结构的一系列关联式容器，在查询时效率可达到O(n)，即最差情况下需要比较红黑树的高度次，当树中的节点非常多时，查询效率也不理想。最好的查询是进行很少的比较次数就能将元素找到，因此在C&#43;&#43;11中，STL又提供了4个unordered系列的关联式容器，这四个容器与红黑树结构的关联式容器使用方式基本类似，只是其底层结构不同。
1.1 -&gt; unordered_map 1.1.1 -&gt; unordered_map的文档介绍 unordered_map文档说明 unordered_map是存储&lt;key，value&gt;键值对的关联式容器，其允许通过keys快速的索引到与其对应的value。在unordered_map中，键值通常用于唯一地标识元素，而映射值是一个对象，其内容与此键关联。键和映射值的类型可能不同。在内部unordered_map没有对&lt;key，value&gt;按照任何特定的顺序排序，为了能在常数范围内找到key所对应的value，unordered_map将相同的哈希值的键值对放在相同的桶中。unordered_map容器通过key访问单个元素要比map快，但它通常在遍历元素子集的范围迭代方面效率较低。unordered_map实现了直接访问操作符(operator[])，它允许使用key作为参数直接访问value。它的迭代器至少是前向迭代器。 1.1.2 -&gt; unordered_map的接口说明 1. unordered_map的构造
函数声明功能介绍unordered_map构造不同格式的unordered_map对象 2. unordered_map的容量">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-12T16:58:21+08:00">
    <meta property="article:modified_time" content="2024-07-12T16:58:21+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;航海王：追寻罗杰的编程之路】一篇文章带你认识哈希</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><span style="color:#98c091;"><strong>目录</strong></span></p> 
<p id="1%20-%3E%20unordered%E7%B3%BB%E5%88%97%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-toc" style="margin-left:0px;"><strong><a href="#1%20-%3E%20unordered%E7%B3%BB%E5%88%97%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8" rel="nofollow"><span style="color:#98c091;">1 -&gt; unordered系列关联式容器</span></a></strong></p> 
<p id="1.1%20-%3E%C2%A0unordered_map-toc" style="margin-left:40px;"><strong><a href="#1.1%20-%3E%C2%A0unordered_map" rel="nofollow"><span style="color:#98c091;">1.1 -&gt; unordered_map</span></a></strong></p> 
<p id="1.1.1%20-%3E%20unordered_map%E7%9A%84%E6%96%87%E6%A1%A3%E4%BB%8B%E7%BB%8D-toc" style="margin-left:80px;"><strong><a href="#1.1.1%20-%3E%20unordered_map%E7%9A%84%E6%96%87%E6%A1%A3%E4%BB%8B%E7%BB%8D" rel="nofollow"><span style="color:#98c091;">1.1.1 -&gt; unordered_map的文档介绍</span></a></strong></p> 
<p id="1.1.2%20-%3E%20unordered_map%E7%9A%84%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E-toc" style="margin-left:80px;"><strong><a href="#1.1.2%20-%3E%20unordered_map%E7%9A%84%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E" rel="nofollow"><span style="color:#98c091;">1.1.2 -&gt; unordered_map的接口说明</span></a></strong></p> 
<p id="1.2%20-%3E%C2%A0unordered_set-toc" style="margin-left:40px;"><strong><a href="#1.2%20-%3E%C2%A0unordered_set" rel="nofollow"><span style="color:#98c091;">1.2 -&gt; unordered_set</span></a></strong></p> 
<p id="2%20-%3E%20%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84-toc" style="margin-left:0px;"><strong><a href="#2%20-%3E%20%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84" rel="nofollow"><span style="color:#98c091;">2 -&gt; 底层结构</span></a></strong></p> 
<p id="2.1%20-%3E%20%E5%93%88%E5%B8%8C%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><strong><a href="#2.1%20-%3E%20%E5%93%88%E5%B8%8C%E6%A6%82%E5%BF%B5" rel="nofollow"><span style="color:#98c091;">2.1 -&gt; 哈希概念</span></a></strong></p> 
<p id="2.2%20-%3E%20%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81-toc" style="margin-left:40px;"><strong><a href="#2.2%20-%3E%20%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81" rel="nofollow"><span style="color:#98c091;">2.2 -&gt; 哈希冲突</span></a></strong></p> 
<p id="2.3%20-%3E%20%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><strong><a href="#2.3%20-%3E%20%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0" rel="nofollow"><span style="color:#98c091;">2.3 -&gt; 哈希函数</span></a></strong></p> 
<p id="2.4%20-%3E%20%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3-toc" style="margin-left:40px;"><strong><a href="#2.4%20-%3E%20%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3" rel="nofollow"><span style="color:#98c091;">2.4 -&gt; 哈希冲突解决</span></a></strong></p> 
<p id="2.4.1%20-%3E%20%E9%97%AD%E6%95%A3%E5%88%97-toc" style="margin-left:80px;"><strong><a href="#2.4.1%20-%3E%20%E9%97%AD%E6%95%A3%E5%88%97" rel="nofollow"><span style="color:#98c091;">2.4.1 -&gt; 闭散列</span></a></strong></p> 
<p id="2.4.2%20-%3E%C2%A0%E5%BC%80%E6%95%A3%E5%88%97-toc" style="margin-left:80px;"><strong><a href="#2.4.2%20-%3E%C2%A0%E5%BC%80%E6%95%A3%E5%88%97" rel="nofollow"><span style="color:#98c091;">2.4.2 -&gt; 开散列</span></a></strong></p> 
<p id="3%20-%3E%C2%A0%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><strong><a href="#3%20-%3E%C2%A0%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" rel="nofollow"><span style="color:#98c091;">3 -&gt; 模拟实现</span></a></strong></p> 
<p id="3.1%20-%3E%C2%A0%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E6%94%B9%E9%80%A0-toc" style="margin-left:40px;"><strong><a href="#3.1%20-%3E%C2%A0%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E6%94%B9%E9%80%A0" rel="nofollow"><span style="color:#98c091;">3.1 -&gt; 哈希表的改造</span></a></strong></p> 
<p id="3.2%20-%3E%20unordered_map-toc" style="margin-left:40px;"><strong><a href="#3.2%20-%3E%20unordered_map" rel="nofollow"><span style="color:#98c091;">3.2 -&gt; unordered_map</span></a></strong></p> 
<p id="3.3%20-%3E%20unordered_set-toc" style="margin-left:40px;"><strong><a href="#3.3%20-%3E%20unordered_set" rel="nofollow"><span style="color:#98c091;">3.3 -&gt; unordered_set</span></a></strong></p> 
<hr id="hr-toc"> 
<p class="img-center"><img alt="" height="535" src="https://images2.imgbox.com/d5/25/ONVIRetQ_o.png" width="552"></p> 
<h2 id="1%20-%3E%20unordered%E7%B3%BB%E5%88%97%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8">1 -&gt; unordered系列关联式容器</h2> 
<p><span style="color:#6eaad7;">在C++98中，STL提供了底层为红黑树结构的一系列关联式容器，在查询时效率可达到O(n)，即最差情况下需要比较红黑树的高度次，当树中的节点非常多时，查询效率也不理想。最好的查询是进行很少的比较次数就能将元素找到，因此在C++11中，STL又提供了4个unordered系列的关联式容器，这四个容器与红黑树结构的关联式容器使用方式基本类似，只是其底层结构不同。</span></p> 
<h3 id="1.1%20-%3E%C2%A0unordered_map" style="background-color:transparent;">1.1 -&gt; unordered_map</h3> 
<h4 id="1.1.1%20-%3E%20unordered_map%E7%9A%84%E6%96%87%E6%A1%A3%E4%BB%8B%E7%BB%8D">1.1.1 -&gt; unordered_map的文档介绍</h4> 
<p class="img-center"><img alt="" height="883" src="https://images2.imgbox.com/1b/b6/J7BGxch6_o.png" width="1200"></p> 
<p><a class="link-info" href="https://cplusplus.com/reference/unordered_map/unordered_map/?kw=unordered_map" rel="nofollow" title="unordered_map文档说明">unordered_map文档说明</a> </p> 
<ol><li><span style="color:#6eaad7;">unordered_map是存储&lt;key，value&gt;键值对的关联式容器，其允许通过keys快速的索引到与其对应的value。</span></li><li><span style="color:#6eaad7;">在unordered_map中，键值通常用于唯一地标识元素，而映射值是一个对象，其内容与此键关联。键和映射值的类型可能不同。</span></li><li><span style="color:#6eaad7;">在内部unordered_map没有对&lt;key，value&gt;按照任何特定的顺序排序，为了能在常数范围内找到key所对应的value，unordered_map将相同的哈希值的键值对放在相同的桶中。</span></li><li><span style="color:#6eaad7;">unordered_map容器通过key访问单个元素要比map快，但它通常在遍历元素子集的范围迭代方面效率较低。</span></li><li><span style="color:#6eaad7;">unordered_map实现了直接访问操作符(operator[])，它允许使用key作为参数直接访问value。</span></li><li><span style="color:#6eaad7;">它的迭代器至少是前向迭代器。</span></li></ol> 
<h4 id="1.1.2%20-%3E%20unordered_map%E7%9A%84%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E" style="background-color:transparent;">1.1.2 -&gt; unordered_map的接口说明</h4> 
<p><span style="color:#6eaad7;"><strong>1. unordered_map的构造</strong></span></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="text-align:center;width:182px;"><span style="color:#1a439c;"><strong>函数声明</strong></span></td><td style="text-align:center;width:316px;"><span style="color:#1a439c;"><strong>功能介绍</strong></span></td></tr><tr><td style="text-align:center;width:182px;"><span style="color:#1a439c;"><strong>unordered_map</strong></span></td><td style="text-align:center;width:316px;"><span style="color:#1a439c;"><strong>构造不同格式的unordered_map对象</strong></span></td></tr></tbody></table> 
<p><span style="color:#6eaad7;"><strong>2. unordered_map的容量</strong></span></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="text-align:center;"><span style="color:#1a439c;"><strong>函数声明</strong></span></td><td style="text-align:center;"><span style="color:#1a439c;"><strong>功能介绍</strong></span></td></tr><tr><td style="text-align:center;"><span style="color:#1a439c;"><strong>bool empty() const</strong></span></td><td style="text-align:center;"><span style="color:#1a439c;"><strong>检测unordered_map是否为空</strong></span></td></tr><tr><td style="text-align:center;"><span style="color:#1a439c;"><strong>size_t size() const</strong></span></td><td style="text-align:center;"><span style="color:#1a439c;"><strong>获取unordered_map的有效元素个数</strong></span></td></tr></tbody></table> 
<p><span style="color:#6eaad7;"><strong>3. unordered_map的迭代器</strong></span></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="text-align:center;"><span style="color:#1a439c;"><strong>函数声明</strong></span></td><td style="text-align:center;"><span style="color:#1a439c;"><strong>功能介绍</strong></span></td></tr><tr><td style="text-align:center;"><span style="color:#1a439c;"><strong>begin</strong></span></td><td style="text-align:center;"><span style="color:#1a439c;"><strong>返回unordered_map第一个元素的迭代器</strong></span></td></tr><tr><td style="text-align:center;"><span style="color:#1a439c;"><strong>end</strong></span></td><td style="text-align:center;"><span style="color:#1a439c;"><strong>返回unordered_map最后一个元素下一个位置的迭代器</strong></span></td></tr><tr><td style="text-align:center;"><span style="color:#1a439c;"><strong>cbegin</strong></span></td><td style="text-align:center;"><span style="color:#1a439c;"><strong>返回unordered_map第一个元素的const迭代器</strong></span></td></tr><tr><td style="text-align:center;"><span style="color:#1a439c;"><strong>cend</strong></span></td><td style="text-align:center;"><span style="color:#1a439c;"><strong>返回unordered_map最后一个元素下一个位置的const迭代器</strong></span></td></tr></tbody></table> 
<p><span style="color:#6eaad7;"><strong>4. unordered_map的元素访问</strong></span></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="text-align:center;"><span style="color:#1a439c;"><strong>函数声明</strong></span></td><td style="text-align:center;"><span style="color:#1a439c;"><strong>功能介绍</strong></span></td></tr><tr><td style="text-align:center;"><span style="color:#1a439c;"><strong>operator[]</strong></span></td><td style="text-align:center;"><span style="color:#1a439c;"><strong>返回与key对应的value，没有一个默认值</strong></span></td></tr></tbody></table> 
<p><span style="color:#6eaad7;">注意：该函数中实际调用哈希桶的插入操作，用参数key与V()构造一个默认值往底层哈希桶中插入，如果key不在哈希桶中，插入成功，返回V()，插入失败，说明key已经在哈希桶中，将key对应的value返回。</span> </p> 
<p><span style="color:#6eaad7;"><strong>5. unordered_map的查询</strong></span></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="text-align:center;"><span style="color:#1a439c;"><strong>函数声明</strong></span></td><td style="text-align:center;"><span style="color:#1a439c;"><strong>功能介绍</strong></span></td></tr><tr><td style="text-align:center;"><span style="color:#1a439c;"><strong>iterator find(const K&amp; key)</strong></span></td><td style="text-align:center;"><span style="color:#1a439c;"><strong>返回key在哈希桶中的位置</strong></span></td></tr><tr><td style="text-align:center;"><span style="color:#1a439c;"><strong>size_t count(const K&amp; key)</strong></span></td><td style="text-align:center;"><span style="color:#1a439c;"><strong>返回哈希桶中关键码为key的键值对的个数</strong></span></td></tr></tbody></table> 
<p><span style="color:#6eaad7;">注意：unordered_map中key是不能重复的，因此count函数的返回值最大为1。</span></p> 
<p><span style="color:#6eaad7;"><strong>6. unordered_map的修改操作</strong></span></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="text-align:center;"><span style="color:#1a439c;"><strong>函数声明</strong></span></td><td style="text-align:center;"><span style="color:#1a439c;"><strong>功能介绍</strong></span></td></tr><tr><td style="text-align:center;"><span style="color:#1a439c;"><strong>insert</strong></span></td><td style="text-align:center;"><span style="color:#1a439c;"><strong>向容器中插入键值对</strong></span></td></tr><tr><td style="text-align:center;"><span style="color:#1a439c;"><strong>erase</strong></span></td><td style="text-align:center;"><span style="color:#1a439c;"><strong>删除容器中的键值对</strong></span></td></tr><tr><td style="text-align:center;"><span style="color:#1a439c;"><strong>void clear()</strong></span></td><td style="text-align:center;"><span style="color:#1a439c;"><strong>清空容器中有效元素个数</strong></span></td></tr><tr><td style="text-align:center;"><span style="color:#1a439c;"><strong>void swap(unordered_map&amp;)</strong></span></td><td style="text-align:center;"><span style="color:#1a439c;"><strong>交换两个容器中的元素</strong></span></td></tr></tbody></table> 
<p><span style="color:#6eaad7;"><strong>7. unordered_map的桶操作</strong></span></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="text-align:center;"><span style="color:#1a439c;"><strong>函数声明</strong></span></td><td style="text-align:center;"><span style="color:#1a439c;"><strong>功能介绍</strong></span></td></tr><tr><td style="text-align:center;"><span style="color:#1a439c;"><strong>size_t bucket count() const</strong></span></td><td style="text-align:center;"><span style="color:#1a439c;"><strong>返回哈希桶中桶的总个数</strong></span></td></tr><tr><td style="text-align:center;"><span style="color:#1a439c;"><strong>size_t bucket size(size_t n) const</strong></span></td><td style="text-align:center;"><span style="color:#1a439c;"><strong>返回n号桶中有效元素的总个数</strong></span></td></tr><tr><td style="text-align:center;"><span style="color:#1a439c;"><strong>size_t bucket(const K&amp; key)</strong></span></td><td style="text-align:center;"><span style="color:#1a439c;"><strong>返回元素key所在的桶号</strong></span></td></tr></tbody></table> 
<h3 id="1.2%20-%3E%C2%A0unordered_set" style="background-color:transparent;">1.2 -&gt; unordered_set</h3> 
<p class="img-center"><img alt="" height="757" src="https://images2.imgbox.com/ce/18/n04kefiv_o.png" width="1200"></p> 
<p><a class="link-info" href="https://cplusplus.com/reference/unordered_set/unordered_set/?kw=unordered_set#google_vignette" rel="nofollow" title="unordered_set文档说明">unordered_set文档说明</a> </p> 
<h2 id="2%20-%3E%20%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84">2 -&gt; 底层结构</h2> 
<p><span style="color:#6eaad7;">unordered系列的关联式容器之所以效率比较高，是因为其底层使用了哈希结构。</span></p> 
<h3 id="2.1%20-%3E%20%E5%93%88%E5%B8%8C%E6%A6%82%E5%BF%B5" style="background-color:transparent;">2.1 -&gt; 哈希概念</h3> 
<p><span style="color:#6eaad7;"><strong>顺序结构以及平衡树</strong>中，元素关键码与其存储位置之间没有对应的关系，因此在<strong>查找一个元素时，必须要经过关键码的多次比较。顺序查找时间复杂度为O(N)，平衡树中为树的高度，即O(N)</strong>，搜索的效率取决于搜索过程中元素的比较次数。</span></p> 
<p><span style="color:#6eaad7;">理想的搜索方法：可以<strong>不经过任何比较，一次直接从表中得到要搜索的元素。如果构造一种存储结构，通过某种函数(hashFunc)使元素的存储位置与它的关键码之间能够建立——映射的关系，那么在查找时通过该函数可以很快找到该元素。</strong></span></p> 
<p><span style="color:#6eaad7;">当向该结构中：</span></p> 
<ul><li><span style="color:#6eaad7;"><strong>插入元素</strong></span></li></ul> 
<p><span style="color:#6eaad7;">根据待插入元素的关键码，以此函数计算出该元素的存储位置并按此位置进行存放。</span></p> 
<ul><li><span style="color:#6eaad7;"><strong>搜索元素</strong></span></li></ul> 
<p><span style="color:#6eaad7;">对元素的关键码进行同样的计算，把求得的函数值当作元素的存储位置，在结构中按此位置取元素比较，若关键码相等，则搜索成功。</span></p> 
<p><span style="color:#6eaad7;">该方式即为哈希(散列)方法，<strong>哈希方法中使用的转换函数称为哈希(散列)函数，构造出的结构称为哈希表(Hash Table)(或者称散列表)。</strong></span></p> 
<p><span style="color:#6eaad7;">例如：数据集合{1，7，6，4，5，9}；</span></p> 
<p><span style="color:#6eaad7;">哈希函数设置为：hash(key) = key % capacity；capacity为存储元素底层空间的总大小。</span></p> 
<p><img alt="" height="333" src="https://images2.imgbox.com/f7/bd/E4sbift1_o.png" width="1036"></p> 
<p><span style="color:#6eaad7;"><strong>用该方法进行搜索不必进行多次关键码的比较，因此搜索的速度比较快。 </strong></span></p> 
<h3 id="2.2%20-%3E%20%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81" style="background-color:transparent;">2.2 -&gt; 哈希冲突</h3> 
<p><span style="color:#6eaad7;"><strong>不同关键字通过相同哈希函数计算出相同的哈希地址，该种现象称为哈希冲突或哈希碰撞。</strong></span></p> 
<p><span style="color:#6eaad7;"><strong>把具有不同关键码而具有相同哈希地址的数据元素称为“同义词”。</strong></span></p> 
<h3 id="2.3%20-%3E%20%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0">2.3 -&gt; 哈希函数</h3> 
<p><span style="color:#6eaad7;">引起哈希冲突的一个原因可能是：<strong>哈希函数设计不够合理。</strong></span></p> 
<p><span style="color:#6eaad7;"><strong>哈希函数设计原则：</strong></span></p> 
<ul><li><span style="color:#6eaad7;">哈希函数的定义域必须包括需要存储的全部关键码，而如果散列表允许有m个地址时，其值域必须在0到m-1之间。</span></li><li><span style="color:#6eaad7;">哈希函数计算出来的地址能均匀分布在整个空间中。</span></li><li><span style="color:#6eaad7;">哈希函数应该比较简单。</span></li></ul> 
<p><span style="color:#6eaad7;"><strong>常见哈希函数</strong></span></p> 
<p><span style="color:#6eaad7;"><strong>1.  直接定址法--(常用)</strong></span></p> 
<p><span style="color:#6eaad7;"><strong>取关键字的某个线性函数为散列地址：Hash（Key）= A*Key + B。</strong></span></p> 
<p><span style="color:#6eaad7;"><strong>优点：简单、均匀。</strong></span></p> 
<p><span style="color:#6eaad7;"><strong>缺点：需要事先知道关键字的分布情况。</strong></span></p> 
<p><span style="color:#6eaad7;"><strong>缺点：需要事先知道关键字的分布情况。</strong></span></p> 
<p><span style="color:#6eaad7;"><strong>2.  除留余数法--(常用)</strong></span></p> 
<p><span style="color:#6eaad7;">设散列表中<strong>允许的地址数为m，取一个不大于m，但最接近或者等于m的质数p作为除数，按照哈希函数：Hash(key) = key% p(p&lt;=m),将关键码转换成哈希地址。</strong></span></p> 
<p><span style="color:#6eaad7;"><strong>3.  平方取中法</strong></span></p> 
<p><span style="color:#6eaad7;">假设关键字为1234，对它平方就是1522756，抽取中间的3位227作为哈希地址；再比如关键字为4321，对它平方就是18671041，抽取中间的3位671(或710)作为哈希地址。</span></p> 
<p><span style="color:#6eaad7;"><strong>平方取中法比较适合：不知道关键字的分布，而位数又不是很大的情况。</strong></span></p> 
<p><span style="color:#6eaad7;"><strong>4.  折叠法</strong></span></p> 
<p><span style="color:#6eaad7;">折叠法是将关键字从左到右分割成位数相等的几部分(最后一部分位数可以短些)，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。</span></p> 
<p><span style="color:#6eaad7;"><strong>折叠法适合事先不需要知道关键字的分布，适合关键字位数比较多的情况。</strong></span></p> 
<p><span style="color:#6eaad7;"><strong>5.  随机数法</strong></span></p> 
<p><span style="color:#6eaad7;">选择一个随机函数，取关键字的随机函数值为它的哈希地址，即H(key) = random(key),其中random为随机数函数。</span></p> 
<p><span style="color:#6eaad7;"><strong>通常应用于关键字长度不等时采用此法。</strong></span></p> 
<p><span style="color:#6eaad7;"><strong>6.  数学分析法</strong></span></p> 
<p><span style="color:#6eaad7;">设有n个d位数，每一位可能有r种不同的符号，这r种不同的符号在各位上出现的频率不一定<br> 相同，可能在某些位上分布比较均匀，每种符号出现的机会均等，在某些位上分布不均匀只<br> 有某几种符号经常出现。可根据散列表的大小，选择其中各种符号分布均匀的若干位作为散<br> 列地址。</span></p> 
<p><span style="color:#6eaad7;"><strong>数字分析法通常适合处理关键字位数比较大的情况，如果事先知道关键字的分布且关键字的若干位分布较均匀的情况。</strong></span></p> 
<p><span style="color:#ed7976;"><strong>注意：哈希函数设计的越精妙，产生哈希冲突的可能性就越低，但是无法避免哈希冲突。</strong></span></p> 
<h3 id="2.4%20-%3E%20%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3">2.4 -&gt; 哈希冲突解决</h3> 
<p><span style="color:#6eaad7;"><strong>解决哈希冲突</strong>两种常见的方法是：<strong>闭散列</strong>和<strong>开散列</strong>。</span></p> 
<h4 id="2.4.1%20-%3E%20%E9%97%AD%E6%95%A3%E5%88%97" style="background-color:transparent;">2.4.1 -&gt; 闭散列</h4> 
<p><span style="color:#6eaad7;"><strong>闭散列：也叫开放定址法，当发生哈希冲突时，如果哈希表未被装满，说明在哈希表中必然还有<br> 空位置，那么可以把key存放到冲突位置中的“下一个” 空位置中去。</strong></span></p> 
<p><span style="color:#6eaad7;"><strong>1. 线性探测</strong></span></p> 
<p><span style="color:#6eaad7;">比如2.1中的场景，现在需要插入元素44，先通过哈希函数计算哈希地址，hashAddr为4，因此44理论上应该插在该位置，但是该位置已经放了值为4的元素，即发生哈希冲突。</span></p> 
<p><span style="color:#6eaad7;"><strong>线性探测：从发生冲突的位置开始，依次向后探测，直到寻找到下一个空位置为止。</strong></span></p> 
<p><span style="color:#6eaad7;"><strong>插入：</strong></span></p> 
<ul><li><span style="color:#6eaad7;"><strong>通过哈希函数获取待插入元素在哈希表中的位置。</strong></span></li><li><span style="color:#6eaad7;"><strong>如果该位置中没有元素则直接插入新元素，如果该位置中有元素发生哈希冲突，使用线性探测找到下一个空位置，插入新元素。</strong></span></li></ul> 
<p class="img-center"><img alt="" height="264" src="https://images2.imgbox.com/99/30/aGww5rM5_o.png" width="847"></p> 
<p><strong><span style="color:#6eaad7;">删除：</span></strong></p> 
<p><span style="color:#6eaad7;"><strong>采用闭散列处理哈希冲突时，不能随便物理删除哈希表中已有的元素，若直接删除元素会影响其他元素的搜索</strong>。比如删除元素4，如果直接删除掉，44查找起来可能会受影响。因此<strong>线性探测采用标记的伪删除法来删除一个元素。</strong></span></p> 
<pre><code class="hljs">#define _CRT_SECURE_NO_WARNINGS 1

#include &lt;iostream&gt;
using namespace std;

// 哈希表每个空间给个标记
// EMPTY此位置空， EXIST此位置已经有元素， DELETE元素已经删除
enum State 
{ 
	EMPTY, EXIST, DELETE 
};</code></pre> 
<p><span style="color:#6eaad7;"><strong>线性探测实现： </strong></span></p> 
<pre><code class="hljs">#define _CRT_SECURE_NO_WARNINGS 1

#include &lt;iostream&gt;
using namespace std;

// 哈希表每个空间给个标记
// EMPTY此位置空， EXIST此位置已经有元素， DELETE元素已经删除
enum State 
{ 
	EMPTY, EXIST, DELETE 
};

// 注意：假如实现的哈希表中元素唯一，即key相同的元素不再进行插入
// 为了实现简单，此哈希表中我们将比较直接与元素绑定在一起
template&lt;class K, class V&gt;
class HashTable
{
	struct Elem
	{
		pair&lt;K, V&gt; _val;
		State _state;
	};

public:
	HashTable(size_t capacity = 3)
		: _ht(capacity), _size(0)
	{
		for (size_t i = 0; i &lt; capacity; ++i)
			_ht[i]._state = EMPTY;
	}

	bool Insert(const pair&lt;K, V&gt;&amp; val)
	{
		// 检测哈希表底层空间是否充足
		// _CheckCapacity();
		size_t hashAddr = HashFunc(key);

		// size_t startAddr = hashAddr;
		while (_ht[hashAddr]._state != EMPTY)
		{
			if (_ht[hashAddr]._state == EXIST &amp;&amp; _ht[hashAddr]._val.first
				== key)
				return false;

			hashAddr++;
			if (hashAddr == _ht.capacity())
				hashAddr = 0;
		/*
		// 转一圈也没有找到，注意：动态哈希表，该种情况可以不用考虑，哈希表中元
		素个数到达一定的数量，哈希冲突概率会增大，需要扩容来降低哈希冲突，
		因此哈希表中元素是不会存满的
			 if(hashAddr == startAddr)
			 	return false;
		*/
		}

		// 插入元素
		_ht[hashAddr]._state = EXIST;
		_ht[hashAddr]._val = val;
		_size++;

		return true;
	}

	int Find(const K&amp; key)
	{
		size_t hashAddr = HashFunc(key);
		while (_ht[hashAddr]._state != EMPTY)
		{
			if (_ht[hashAddr]._state == EXIST &amp;&amp; 
				_ht[hashAddr]._val.first == key)
				return hashAddr;

			hashAddr++;
		}

		return hashAddr;
	}
	bool Erase(const K &amp; key)
	{
		int index = Find(key);
		if (-1 != index)
		{
			_ht[index]._state = DELETE;
			_size++;

			return true;
		}

		return false;
	}

	size_t Size()const;
	bool Empty() const;
	void Swap(HashTable&lt;K, V, HF&gt;&amp;ht);

private:
	size_t HashFunc(const K &amp; key)
	{
		return key % _ht.capacity();
	}

private:
	vector&lt;Elem&gt; _ht;
	size_t _size;
};</code></pre> 
<p><span style="color:#6eaad7;"><strong>线性探测的优点：实现非常简单。</strong></span></p> 
<p><span style="color:#6eaad7;"><strong>线性探测的缺点：一旦发生哈希冲突，所有的冲突连在一起，容易产生数据“堆积”，即：不同关键码占据了可利用的空位置，使得寻找某关键码的位置需要多次比较，导致搜索效率降低。 </strong></span></p> 
<p><span style="color:#6eaad7;"><strong>2. 二次探测</strong></span></p> 
<p><span style="color:#6eaad7;">线性探测的缺陷是产生冲突的数据堆积在一块，这与其找下一个空位置有关系，因为找空位置的方式就是挨着往后逐个去找，因此二次探测为了避免该问题。</span></p> 
<p><img alt="" height="409" src="https://images2.imgbox.com/e0/8f/SWJWu2bR_o.png" width="1200"><span style="color:#6eaad7;">研究表明：<strong>当表的长度为质数且表装载因子a不超过0.5时，新的表项一定能够插入，而且任何一个位置都不会被探查两次。因此只要表中有一半的空位置，就不会存在表满的问题。在搜索时可以不考虑表装满的情况，但在插入时必须确保表的装载因子a不超过0.5</strong>，如果超出必须考虑增容。</span></p> 
<p><span style="color:#6eaad7;">因此：闭散列最大的缺陷就是空间利用率比较低，这也是哈希的缺陷。</span></p> 
<h4 id="2.4.2%20-%3E%C2%A0%E5%BC%80%E6%95%A3%E5%88%97" style="background-color:transparent;">2.4.2 -&gt; 开散列</h4> 
<p><span style="color:#6eaad7;"><strong>1. 开散列概念</strong></span></p> 
<p><span style="color:#6eaad7;"><strong>开散列法又叫链地址法(开链法)，首先对关键码集合用散列函数计算散列地址，具有相同地址的关键码归于同一子集合，每一个子集合称为一个桶，各个桶中的元素通过一个单链表链接起来，各链表的头结点存储在哈希表中。</strong></span></p> 
<p class="img-center"><img alt="" height="646" src="https://images2.imgbox.com/6d/83/kAzJZoHz_o.png" width="733"></p> 
<p class="img-center"><img alt="" height="654" src="https://images2.imgbox.com/df/53/AtJWnYkU_o.png" width="796"></p> 
<p><span style="color:#6eaad7;">从上图可以看出，<strong>开散列中每个桶中放的都是发生哈希冲突的元素。 </strong></span></p> 
<p><span style="color:#6eaad7;"><strong>2. 开散列实现 </strong></span></p> 
<pre><code class="hljs">#define _CRT_SECURE_NO_WARNINGS 1

#include &lt;iostream&gt;
using namespace std;

template&lt;class V&gt;
struct HashBucketNode
{
	HashBucketNode(const V&amp; data)
		: _pNext(nullptr), _data(data)
	{}
	HashBucketNode&lt;V&gt;* _pNext;
	V _data;
};

// 所实现的哈希桶中key是唯一的
template&lt;class V&gt;
class HashBucket
{
	typedef HashBucketNode&lt;V&gt; Node;
	typedef Node* PNode;

public:
	HashBucket(size_t capacity = 3) : _size(0)
	{
		_ht.resize(GetNextPrime(capacity), nullptr);
	}

	// 哈希桶中的元素不能重复
	PNode* Insert(const V&amp; data)
	{
		// 确认是否需要扩容。。。
		 // _CheckCapacity();

		// 1. 计算元素所在的桶号
		size_t bucketNo = HashFunc(data);

		// 2. 检测该元素是否在桶中
		PNode pCur = _ht[bucketNo];
		while (pCur)
		{
			if (pCur-&gt;_data == data)
				return pCur;

			pCur = pCur-&gt;_pNext;
		}

		// 3. 插入新元素
		pCur = new Node(data);
		pCur-&gt;_pNext = _ht[bucketNo];
		_ht[bucketNo] = pCur;
		_size++;

		return pCur;
	}

	// 删除哈希桶中为data的元素(data不会重复)，返回删除元素的下一个节点
	PNode* Erase(const V&amp; data)
	{
		size_t bucketNo = HashFunc(data);
		PNode pCur = _ht[bucketNo];
		PNode pPrev = nullptr, pRet = nullptr;

		while (pCur)
		{
			if (pCur-&gt;_data == data)
			{
				if (pCur == _ht[bucketNo])
					_ht[bucketNo] = pCur-&gt;_pNext;
				else
					pPrev-&gt;_pNext = pCur-&gt;_pNext;

				pRet = pCur-&gt;_pNext;
				delete pCur;
				_size--;

				return pRet;
			}
		}

		return nullptr;
	}

	PNode* Find(const V&amp; data);
	size_t Size()const;
	bool Empty()const;
	void Clear();
	bool BucketCount()const;
	void Swap(HashBucket&lt;V, HF&gt;&amp; ht;
	~HashBucket();

private:
	size_t HashFunc(const V&amp; data)
	{
		return data % _ht.capacity();
	}

private:
	vector&lt;PNode*&gt; _ht;
	size_t _size; // 哈希表中有效元素的个数
};</code></pre> 
<p><span style="color:#6eaad7;"><strong>3. 开散列增容</strong></span></p> 
<p><span style="color:#6eaad7;">桶的个数是一定的，随着元素的不断插入，每个桶中元素的个数不断增多，极端情况下，可能会导致一个桶中链表节点非常多，会影响的哈希表的性能，因此在一定条件下需要对哈希表进行增容，那该条件怎么确认呢？开散列最好的情况是：每个哈希桶中刚好挂一个节点，再继续插入元素时，每一次都会发生哈希冲突，因此，在元素个数刚好等于桶的个数时，可以给哈希表增容。 </span></p> 
<pre><code class="hljs">void _CheckCapacity()
	{
		size_t bucketCount = BucketCount();
		if (_size == bucketCount)
		{
			HashBucket&lt;V, HF&gt; newHt(bucketCount);
			for (size_t bucketIdx = 0; bucketIdx &lt; bucketCount; ++bucketIdx)
			{
				PNode pCur = _ht[bucketIdx];
				while (pCur)
				{
					// 将该节点从原哈希表中拆出来
					_ht[bucketIdx] = pCur-&gt;_pNext;

					// 将该节点插入到新哈希表中
					size_t bucketNo = newHt.HashFunc(pCur-&gt;_data);
					pCur-&gt;_pNext = newHt._ht[bucketNo];
					newHt._ht[bucketNo] = pCur;
					pCur = _ht[bucketIdx];
				}
			}

			newHt._size = _size;
			this-&gt;Swap(newHt);
		}
	}</code></pre> 
<p><span style="color:#6eaad7;"><strong>4. 开散列的思考</strong></span></p> 
<p><span style="color:#6eaad7;"><strong>（1）只能存储key为整形的元素，其他类型怎么解决？ </strong></span></p> 
<pre><code class="hljs">// 哈希函数采用处理余数法，被模的key必须要为整形才可以处理，此处提供将key转化为整形的方法
// 整形数据不需要转化
template&lt;class T&gt;
class DefHashF
{
public:
	size_t operator()(const T&amp; val)
	{
		return val;
	}
};

// key为字符串类型，需要将其转化为整形
class Str2Int
{
public:
	size_t operator()(const string&amp; s)
	{
		const char* str = s.c_str();
		unsigned int seed = 131; // 31 131 1313 13131 131313
		unsigned int hash = 0;
		while (*str)
		{
			hash = hash * seed + (*str++);
		}

		return (hash &amp; 0x7FFFFFFF);
	}
};

// 为了实现简单，此哈希表中我们将比较直接与元素绑定在一起
template&lt;class V, class HF&gt;
class HashBucket
{
	// ……
private:
	size_t HashFunc(const V&amp; data)
	{
		return HF()(data.first) % _ht.capacity();
	}
};</code></pre> 
<p><span style="color:#6eaad7;"><strong>（2）除留余数法，最好模一个素数，如何每次快速取一个类似两倍关系的素数？ </strong></span></p> 
<pre><code class="hljs">size_t GetNextPrime(size_t prime)
{
	const int PRIMECOUNT = 28;
	static const size_t primeList[PRIMECOUNT] =
	{
	53ul, 97ul, 193ul, 389ul, 769ul,
	1543ul, 3079ul, 6151ul, 12289ul, 24593ul,
	49157ul, 98317ul, 196613ul, 393241ul, 786433ul,
	1572869ul, 3145739ul, 6291469ul, 12582917ul,
   25165843ul,
	50331653ul, 100663319ul, 201326611ul, 402653189ul,
   805306457ul,
	1610612741ul, 3221225473ul, 4294967291ul
	};

	size_t i = 0;
	for (; i &lt; PRIMECOUNT; ++i)
	{
		if (primeList[i] &gt; prime)
			return primeList[i];
	}

	return primeList[i];
}</code></pre> 
<p><span style="color:#6eaad7;"><strong>5. 开散列与闭散列比较</strong></span></p> 
<p><span style="color:#6eaad7;"><strong>应用链地址法处理溢出，需要增设链接指针，似乎增加了存储开销。事实上：由于开地址法必须保持大量的空闲空间以确保搜索效率，如二次探查法要求装载因子a &lt;= 0.7，而表项所占空间又比指针大的多，所以使用链地址法反而比开地址法节省存储空间。</strong></span></p> 
<h2 id="3%20-%3E%C2%A0%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">3 -&gt; 模拟实现</h2> 
<h3 id="3.1%20-%3E%C2%A0%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E6%94%B9%E9%80%A0" style="background-color:transparent;">3.1 -&gt; 哈希表的改造</h3> 
<pre><code class="hljs">#pragma once

//HashFunc&lt;int&gt;
template&lt;class K&gt;
struct HashFunc
{
	size_t operator()(const K&amp; key)
	{
		return (size_t)key;
	}
};

//HashFunc&lt;string&gt;
template&lt;&gt;
struct HashFunc&lt;string&gt;
{
	size_t operator()(const string&amp; key)
	{
		// BKDR
		size_t hash = 0;
		for (auto e : key)
		{
			hash *= 31;
			hash += e;
		}

		//cout &lt;&lt; key &lt;&lt; ":" &lt;&lt; hash &lt;&lt; endl;
		return hash;
	}
};

namespace open_address
{
	enum Status
	{
		EMPTY,
		EXIST,
		DELETE
	};

	template&lt;class K, class V&gt;
	struct HashData
	{
		pair&lt;K, V&gt; _kv;
		Status _s;          //状态
	};

	//struct HashFuncString
	//{
	//	size_t operator()(const string&amp; key)
	//	{
	//		// BKDR
	//		size_t hash = 0;
	//		for (auto e : key)
	//		{
	//			hash *= 31;
	//			hash += e;
	//		}

	//		cout &lt;&lt; key &lt;&lt; ":" &lt;&lt; hash &lt;&lt; endl;
	//		return hash;
	//	}
	//};

	template&lt;class K, class V, class Hash = HashFunc&lt;K&gt;&gt;
	class HashTable
	{
	public:
		HashTable()
		{
			_tables.resize(10);
		}

		bool Insert(const pair&lt;K, V&gt;&amp; kv)
		{
			if (Find(kv.first))
				return false;

			// 负载因子0.7就扩容
			if (_n * 10 / _tables.size() == 7)
			{
				size_t newSize = _tables.size() * 2;
				HashTable&lt;K, V, Hash&gt; newHT;
				newHT._tables.resize(newSize);

				// 遍历旧表
				for (size_t i = 0; i &lt; _tables.size(); i++)
				{
					if (_tables[i]._s == EXIST)
					{
						newHT.Insert(_tables[i]._kv);
					}
				}

				_tables.swap(newHT._tables);
			}

			Hash hf;
			// 线性探测
			size_t hashi = hf(kv.first) % _tables.size();
			while (_tables[hashi]._s == EXIST)
			{
				hashi++;

				hashi %= _tables.size();
			}

			_tables[hashi]._kv = kv;
			_tables[hashi]._s = EXIST;
			++_n;

			return true;
		}

		HashData&lt;K, V&gt;* Find(const K&amp; key)
		{
			Hash hf;

			size_t hashi = hf(key) % _tables.size();
			while (_tables[hashi]._s != EMPTY)
			{
				if (_tables[hashi]._s == EXIST
					&amp;&amp; _tables[hashi]._kv.first == key)
				{
					return &amp;_tables[hashi];
				}

				hashi++;
				hashi %= _tables.size();
			}

			return NULL;
		}

		// 伪删除法
		bool Erase(const K&amp; key)
		{
			HashData&lt;K, V&gt;* ret = Find(key);
			if (ret)
			{
				ret-&gt;_s = DELETE;
				--_n;

				return true;
			}
			else
			{
				return false;
			}
		}

		void Print()
		{
			for (size_t i = 0; i &lt; _tables.size(); i++)
			{
				if (_tables[i]._s == EXIST)
				{
					//printf("[%d]-&gt;%d\n", i, _tables[i]._kv.first);
					cout &lt;&lt; "[" &lt;&lt; i &lt;&lt; "]-&gt;" &lt;&lt; _tables[i]._kv.first &lt;&lt; ":" &lt;&lt; _tables[i]._kv.second &lt;&lt; endl;
				}
				else if (_tables[i]._s == EMPTY)
				{
					printf("[%d]-&gt;\n", i);
				}
				else
				{
					printf("[%d]-&gt;D\n", i);
				}
			}

			cout &lt;&lt; endl;
		}

	private:
		vector&lt;HashData&lt;K, V&gt;&gt; _tables;
		size_t _n = 0; // 存储的关键字的个数
	};

	void TestHT1()
	{
		HashTable&lt;int, int&gt; ht;
		int a[] = { 4,14,24,34,5,7,1 };
		for (auto e : a)
		{
			ht.Insert(make_pair(e, e));
		}

		ht.Insert(make_pair(3, 3));
		ht.Insert(make_pair(3, 3));
		ht.Insert(make_pair(-3, -3));
		ht.Print();

		ht.Erase(3);
		ht.Print();

		if (ht.Find(3))
		{
			cout &lt;&lt; "3存在" &lt;&lt; endl;
		}
		else
		{
			cout &lt;&lt; "3不存在" &lt;&lt; endl;
		}

		ht.Insert(make_pair(3, 3));
		ht.Insert(make_pair(23, 3));
		ht.Print();
	}

	void TestHT2()
	{
		string arr[] = { "香蕉", "甜瓜","苹果", "西瓜", "苹果", "西瓜", "苹果", "苹果", "西瓜", "苹果", "香蕉", "苹果", "香蕉" };
		//HashTable&lt;string, int, HashFuncString&gt; ht;
		HashTable&lt;string, int&gt; ht;
		for (auto&amp; e : arr)
		{
			//auto ret = ht.Find(e);
			HashData&lt;string, int&gt;* ret = ht.Find(e);
			if (ret)
			{
				ret-&gt;_kv.second++;
			}
			else
			{
				ht.Insert(make_pair(e, 1));
			}
		}

		ht.Print();

		ht.Insert(make_pair("apple", 1));
		ht.Insert(make_pair("sort", 1));

		ht.Insert(make_pair("abc", 1));
		ht.Insert(make_pair("acb", 1));
		ht.Insert(make_pair("aad", 1));

		ht.Print();
	}
}

namespace hash_bucket
{
	template&lt;class T&gt;
	struct HashNode
	{
		HashNode&lt;T&gt;* _next;
		T _data;

		HashNode(const T&amp; data)
			:_data(data)
			, _next(nullptr)
		{}
	};

	// 前置声明
	template&lt;class K, class T, class KeyOfT, class Hash&gt;
	class HashTable;

	template&lt;class K, class T, class Ref, class Ptr, class KeyOfT, class Hash&gt;
	struct __HTIterator
	{
		typedef HashNode&lt;T&gt; Node;
		typedef __HTIterator&lt;K, T, Ref, Ptr, KeyOfT, Hash&gt; Self;
		Node* _node;
		const HashTable&lt;K, T, KeyOfT, Hash&gt;* _pht;

		// vector&lt;Node*&gt; * _ptb;

		size_t _hashi;

		__HTIterator(Node* node, HashTable&lt;K, T, KeyOfT, Hash&gt;* pht, size_t hashi)
			:_node(node)
			, _pht(pht)
			, _hashi(hashi)
		{}

		__HTIterator(Node* node, const HashTable&lt;K, T, KeyOfT, Hash&gt;* pht, size_t hashi)
			:_node(node)
			, _pht(pht)
			, _hashi(hashi)
		{}

		Self&amp; operator++()
		{
			if (_node-&gt;_next)
			{
				// 当前桶还有节点，走到下一个节点
				_node = _node-&gt;_next;
			}
			else
			{
				// 当前桶已经走完了，找下一个桶开始
				//KeyOfT kot;
				//Hash hf;
				//size_t hashi = hf(kot(_node-&gt;_data)) % _pht._tables.size();
				++_hashi;
				while (_hashi &lt; _pht-&gt;_tables.size())
				{
					if (_pht-&gt;_tables[_hashi])
					{
						_node = _pht-&gt;_tables[_hashi];
						break;
					}

					++_hashi;
				}

				if (_hashi == _pht-&gt;_tables.size())
				{
					_node = nullptr;
				}
			}

			return *this;
		}

		Ref operator*()
		{
			return _node-&gt;_data;
		}

		Ptr operator-&gt;()
		{
			return &amp;_node-&gt;_data;
		}

		bool operator!=(const Self&amp; s)
		{
			return _node != s._node;
		}
	};

	// unordered_set -&gt; Hashtable&lt;K, K&gt;
	// unordered_map -&gt; Hashtable&lt;K, pair&lt;K, V&gt;&gt;
	template&lt;class K, class T, class KeyOfT, class Hash&gt;
	class HashTable
	{
		typedef HashNode&lt;T&gt; Node;

		template&lt;class K, class T, class Ref, class Ptr, class KeyOfT, class Hash&gt;
		friend struct __HTIterator;

	public:
		typedef __HTIterator&lt;K, T, T&amp;, T*, KeyOfT, Hash&gt; iterator;
		typedef __HTIterator&lt;K, T, const T&amp;, const T*, KeyOfT, Hash&gt; const_iterator;

		iterator begin()
		{
			for (size_t i = 0; i &lt; _tables.size(); i++)
			{
				if (_tables[i])
				{
					return iterator(_tables[i], this, i);
				}
			}

			return end();
		}

		iterator end()
		{
			return iterator(nullptr, this, -1);
		}

		const_iterator begin() const
		{
			for (size_t i = 0; i &lt; _tables.size(); i++)
			{
				if (_tables[i])
				{
					return const_iterator(_tables[i], this, i);
				}
			}

			return end();
		}

		// this-&gt; const HashTable&lt;K, T, KeyOfT, Hash&gt;*
		const_iterator end() const
		{
			return const_iterator(nullptr, this, -1);
		}

		HashTable()
		{
			_tables.resize(10);
		}

		~HashTable()
		{
			for (size_t i = 0; i &lt; _tables.size(); i++)
			{
				Node* cur = _tables[i];
				while (cur)
				{
					Node* next = cur-&gt;_next;
					delete cur;
					cur = next;
				}
				_tables[i] = nullptr;
			}
		}

		pair&lt;iterator, bool&gt; Insert(const T&amp; data)
		{
			Hash hf;
			KeyOfT kot;

			iterator it = Find(kot(data));
			if (it != end())
				return make_pair(it, false);

			// 负载因子最大到1
			if (_n == _tables.size())
			{
				vector&lt;Node*&gt; newTables;
				newTables.resize(_tables.size() * 2, nullptr);
				// 遍历旧表
				for (size_t i = 0; i &lt; _tables.size(); i++)
				{
					Node* cur = _tables[i];
					while (cur)
					{
						Node* next = cur-&gt;_next;

						// 挪动到映射的新表
						size_t hashi = hf(kot(cur-&gt;_data)) % newTables.size();
						cur-&gt;_next = newTables[i];
						newTables[hashi] = cur;

						cur = next;
					}

					_tables[i] = nullptr;
				}

				_tables.swap(newTables);
			}

			size_t hashi = hf(kot(data)) % _tables.size();
			Node* newnode = new Node(data);

			// 头插
			newnode-&gt;_next = _tables[hashi];
			_tables[hashi] = newnode;
			++_n;

			return make_pair(iterator(newnode, this, hashi), true);
		}

		iterator Find(const K&amp; key)
		{
			Hash hf;
			KeyOfT kot;

			size_t hashi = hf(key) % _tables.size();
			Node* cur = _tables[hashi];
			while (cur)
			{
				if (kot(cur-&gt;_data) == key)
				{
					return iterator(cur, this, hashi);
				}

				cur = cur-&gt;_next;
			}

			return end();
		}

		bool Erase(const K&amp; key)
		{
			Hash hf;
			KeyOfT kot;

			size_t hashi = hf(key) % _tables.size();
			Node* prev = nullptr;
			Node* cur = _tables[hashi];
			while (cur)
			{
				if (kot(cur-&gt;_data) == key)
				{
					if (prev == nullptr)
					{
						_tables[hashi] = cur-&gt;_next;
					}
					else
					{
						prev-&gt;_next = cur-&gt;_next;
					}
					delete cur;

					return true;
				}

				prev = cur;
				cur = cur-&gt;_next;
			}

			return false;
		}

		void Some()
		{
			size_t bucketSize = 0;
			size_t maxBucketLen = 0;
			size_t sum = 0;
			double averageBucketLen = 0;

			for (size_t i = 0; i &lt; _tables.size(); i++)
			{
				Node* cur = _tables[i];
				if (cur)
				{
					++bucketSize;
				}

				size_t bucketLen = 0;
				while (cur)
				{
					++bucketLen;
					cur = cur-&gt;_next;
				}

				sum += bucketLen;
				if (bucketLen &gt; maxBucketLen)
				{
					maxBucketLen = bucketLen;
				}
			}

			averageBucketLen = (double)sum / (double)bucketSize;

			printf("all bucketSize:%d\n", _tables.size());
			printf("bucketSize:%d\n", bucketSize);
			printf("maxBucketLen:%d\n", maxBucketLen);
			printf("averageBucketLen:%lf\n\n", averageBucketLen);
		}

	private:
		vector&lt;Node*&gt; _tables;
		size_t _n = 0;
	};
}</code></pre> 
<h3 id="3.2%20-%3E%20unordered_map" style="background-color:transparent;">3.2 -&gt; unordered_map</h3> 
<pre><code class="hljs">#pragma once
#include"HashTable.h"

namespace fyd
{
	template&lt;class K, class V, class Hash = HashFunc&lt;K&gt;&gt;
	class unordered_map
	{
		struct MapKeyOfT
		{
			const K&amp; operator()(const pair&lt;K, V&gt;&amp; kv)
			{
				return kv.first;
			}
		};

	public:
		typedef typename hash_bucket::HashTable&lt;K, pair&lt;const K, V&gt;, MapKeyOfT, Hash&gt;::iterator iterator;

		iterator begin()
		{
			return _ht.begin();
		}

		iterator end()
		{
			return _ht.end();
		}

		pair&lt;iterator, bool&gt; insert(const pair&lt;K, V&gt;&amp; kv)
		{
			return _ht.Insert(kv);
		}

		V&amp; operator[](const K&amp; key)
		{
			pair&lt;iterator, bool&gt; ret = _ht.Insert(make_pair(key, V()));

			return ret.first-&gt;second;
		}

		const V&amp; operator[](const K&amp; key) const
		{
			pair&lt;iterator, bool&gt; ret = _ht.Insert(make_pair(key, V()));

			return ret.first-&gt;second;
		}

		iterator find(const K&amp; key)
		{
			return _ht.Find(key);
		}

		bool erase(const K&amp; key)
		{
			return _ht.Erase(key);
		}

	private:
		hash_bucket::HashTable&lt;K, pair&lt;const K, V&gt;, MapKeyOfT, Hash&gt; _ht;
	};

	void test_map()
	{
		unordered_map&lt;string, string&gt; dict;
		dict.insert(make_pair("sort", ""));
		dict.insert(make_pair("string", "ַ"));
		dict.insert(make_pair("insert", ""));

		for (auto&amp; kv : dict)
		{
			//kv.first += 'x';
			kv.second += 'x';

			cout &lt;&lt; kv.first &lt;&lt; ":" &lt;&lt; kv.second &lt;&lt; endl;
		}
		cout &lt;&lt; endl;

		string arr[] = { "㽶", "","ƻ", "", "ƻ", "", "ƻ", "ƻ", "", "ƻ", "㽶", "ƻ", "㽶" };
		unordered_map&lt;string, int&gt; count_map;
		for (auto&amp; e : arr)
		{
			count_map[e]++;
		}

		for (auto&amp; kv : count_map)
		{
			cout &lt;&lt; kv.first &lt;&lt; ":" &lt;&lt; kv.second &lt;&lt; endl;
		}
		cout &lt;&lt; endl;
	}
}
</code></pre> 
<h3 id="3.3%20-%3E%20unordered_set" style="background-color:transparent;">3.3 -&gt; unordered_set</h3> 
<pre><code class="hljs">#pragma once
#include"HashTable.h"

namespace fyd
{
	template&lt;class K, class Hash = HashFunc&lt;K&gt;&gt;
	class unordered_set
	{
		struct SetKeyOfT
		{
			const K&amp; operator()(const K&amp; key)
			{
				return key;
			}
		};
	public:
		typedef typename hash_bucket::HashTable&lt;K, K, SetKeyOfT, Hash&gt;::const_iterator iterator;
		typedef typename hash_bucket::HashTable&lt;K, K, SetKeyOfT, Hash&gt;::const_iterator const_iterator;

		/*iterator begin()
		{
			return _ht.begin();
		}

		iterator end()
		{
			return _ht.end();
		}*/

		const_iterator begin() const
		{
			return _ht.begin();
		}

		const_iterator end() const
		{
			return _ht.end();
		}

		pair&lt;const_iterator, bool&gt; insert(const K&amp; key)
		{
			auto ret = _ht.Insert(key);
			return pair&lt;const_iterator, bool&gt;(const_iterator(ret.first._node, ret.first._pht, ret.first._hashi), ret.second);
		}

		iterator find(const K&amp; key)
		{
			return _ht.Find(key);
		}

		bool erase(const K&amp; key)
		{
			return _ht.Erase(key);
		}
	private:
		hash_bucket::HashTable&lt;K, K, SetKeyOfT, Hash&gt; _ht;
	};

	void test_set()
	{
		unordered_set&lt;int&gt; us;
		us.insert(5);
		us.insert(15);
		us.insert(52);
		us.insert(3);

		unordered_set&lt;int&gt;::iterator it = us.begin();
		while (it != us.end())
		{
			//*it += 5;
			cout &lt;&lt; *it &lt;&lt; " ";
			++it;
		}
		cout &lt;&lt; endl;

		for (auto e : us)
		{
			cout &lt;&lt; e &lt;&lt; " ";
		}
		cout &lt;&lt; endl;
	}
}

</code></pre> 
<hr> 
<p></p> 
<p></p> 
<p style="text-align:center;"><strong><span style="color:#1c7331;">感谢各位大佬支持！！！</span></strong></p> 
<p style="text-align:center;"><strong><span style="color:#1c7331;">互三啦！！！</span></strong></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/93bb7985fe28ee559e402b528179ba65/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Quart 框架——来源于Flask的强大且灵活的异步Web框架】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e9e942647b3c3fc2907ffbc18e863f9a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">在Mac上一键安装Mysql（解决所有安装问题）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>