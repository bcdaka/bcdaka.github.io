<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】搜索二叉树 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/ed0d2668a2b00606b6feed8c0693e92b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】搜索二叉树">
  <meta property="og:description" content="二叉搜索树 二叉树的博客
在之前的数据结构的文章中已经基本对二叉树有一定的了解，二叉搜索树也是一种数据结构，下面将对二叉搜索树进行讲解。
二叉搜索树的概念 二叉搜索树又称为二叉排序树，它或者是一棵空树，或者是具有下面性质的二叉树：
若它的左子树不为空，则左子树上的所有节点的值都小于根节点的值。若它的右子树不为空，则右子树上的所有节点的值都大于根节点的值。它的左右子树也分别为二叉搜索树。 ​
​
​
二叉搜索树的特点是搜索数据比较快，最多高度次就可以找到所值，其高度最大就是O(N)
二叉搜索树的实现过程 基本框架 需要有一个struct的类（struct的类默认公开）来包含一个节点的所有特性，包括其可以指向左子树、右子树以及其包含的数据。然后使用class的类来对这棵二叉搜索树进行封装。 template&lt;class K&gt; struct BSTreeNode { BSTreeNode(const K&amp; key) :_left(nullptr) ,_right(nullptr) ,_key(key) {} BSTreeNode&lt;K&gt;* _left; BSTreeNode&lt;K&gt;* _right; K _key; }; template&lt;class K&gt; struct BSTree { typedef BSTreeNode&lt;K&gt; Node; public: private: Node* _root; }; 初始化二叉树： //初始化节点 BSTree() :_root(nullptr) {} 二叉搜索树的插入 插入过程：
当树为空的时候，直接新增节点，赋值给root指针。树不为空，按二叉搜索树的性质查找插入位置，插入新节点。 //插入数据 bool insert(const K&amp; key) { if (_root == nullptr) { _root = new Node(key); return true; } Node* cur = _root; Node* parent = nullptr; while (cur) { if (cur-&gt;_key &lt; key) { parent = cur; cur = cur-&gt;_right; } else if (cur-&gt;_key &gt; key) { parent = cur; cur = cur-&gt;_left; } else { return false; } } cur = new Node(key); if (cur-&gt;_key &gt; parent-&gt;_key) { parent-&gt;_right = cur; } else { parent-&gt;_left = cur; } return true; } 搜索二叉树的打印（使用中序遍历） 在这段代码中，使用_root作为参数传递给_InOrder函数，而不是直接在_InOrder函数中使用__root，主要是为了增加代码的灵活性和可复用性。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-24T12:42:40+08:00">
    <meta property="article:modified_time" content="2024-07-24T12:42:40+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】搜索二叉树</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>二叉搜索树</h2> 
<p><a class="link-info" href="https://blog.csdn.net/dab112/article/details/139188828" title="二叉树">二叉树</a>的博客</p> 
<p>在之前的数据结构的文章中已经基本对二叉树有一定的了解，二叉搜索树也是一种数据结构，下面将对二叉搜索树进行讲解。</p> 
<h3>二叉搜索树的概念</h3> 
<p>        二叉搜索树又称为二叉排序树，它或者是一棵空树，或者是具有下面性质的二叉树：</p> 
<ul><li>若它的左子树不为空，则左子树上的所有节点的值都小于根节点的值。</li><li>若它的右子树不为空，则右子树上的所有节点的值都大于根节点的值。</li><li>它的左右子树也分别为二叉搜索树。</li></ul> 
<p><img alt="" height="329" src="https://images2.imgbox.com/44/ab/1SGWsPxb_o.png" width="877">​</p> 
<p></p> 
<p><img alt="" height="435" src="https://images2.imgbox.com/80/38/NXJyibGt_o.png" width="464">​</p> 
<p></p> 
<p><img alt="" height="406" src="https://images2.imgbox.com/37/75/Q23qwfTQ_o.png" width="576">​</p> 
<p>二叉搜索树的特点是搜索数据比较快，最多高度次就可以找到所值，其高度最大就是O(N)</p> 
<h3>二叉搜索树的实现过程</h3> 
<p><img alt="" height="316" src="https://images2.imgbox.com/a1/6d/v0ASXSky_o.png" width="459"></p> 
<h4>基本框架</h4> 
<ul><li>需要有一个struct的类（struct的类默认公开）来包含一个节点的所有特性，包括其可以指向左子树、右子树以及其包含的数据。</li><li>然后使用class的类来对这棵二叉搜索树进行封装。</li></ul> 
<pre><code class="language-cpp">template&lt;class K&gt;
struct BSTreeNode
{
	BSTreeNode(const K&amp; key)
		:_left(nullptr)
		,_right(nullptr)
		,_key(key)
	{}

	BSTreeNode&lt;K&gt;* _left;
	BSTreeNode&lt;K&gt;* _right;
	K _key;
};

template&lt;class K&gt;
struct BSTree
{
	typedef BSTreeNode&lt;K&gt; Node;
public:

private:
	Node* _root;
};
</code></pre> 
<h4>初始化二叉树：</h4> 
<pre><code class="language-cpp">	//初始化节点
	BSTree()
		:_root(nullptr)
	{}</code></pre> 
<h4>二叉搜索树的插入</h4> 
<p>插入过程：</p> 
<ul><li>当树为空的时候，直接新增节点，赋值给root指针。</li><li>树不为空，按二叉搜索树的性质查找插入位置，插入新节点。</li></ul> 
<pre><code class="language-cpp">//插入数据
bool insert(const K&amp; key)
{
	if (_root == nullptr)
	{
		_root = new Node(key);
		return true;
	}
	Node* cur = _root;
	Node* parent = nullptr;
	while (cur)
	{
		if (cur-&gt;_key &lt; key)
		{
			parent = cur;
			cur = cur-&gt;_right;
		}
		else if (cur-&gt;_key &gt; key)
		{
			parent = cur;
			cur = cur-&gt;_left;
		}
		else
		{
			return false;
		}
	}
	cur = new Node(key);
	if (cur-&gt;_key &gt; parent-&gt;_key)
	{
		parent-&gt;_right = cur;
	}
	else
	{
		parent-&gt;_left = cur;
	}
	return true;
}</code></pre> 
<h4>搜索二叉树的打印（使用中序遍历）</h4> 
<p>        在这段代码中，使用_root作为参数传递给_InOrder函数，而不是直接在_InOrder函数中使用<code>_</code>_root，主要是为了增加代码的灵活性和可复用性。</p> 
<p>这样做的好处是，_InOrder函数可以处理不同的二叉树，而不仅仅局限于某个特定的二叉树对象。通过将二叉树的根节点作为参数传递给_InOrder函数，就可以对任意给定的二叉树进行中序遍历。</p> 
<p>如果直接在_InOrder函数中使用_root，那么_InOrder函数就只能操作类内部固定的_root成员变量所代表的二叉树。而通过参数传递的方式，可以在需要的时候将不同的二叉树根节点传递给_InOrder函数，使其能够对各种不同的二叉树进行操作，提高了函数的通用性。</p> 
<pre><code class="language-cpp">	//二叉树的升序打印
	void InOrder()
	{
		_InOrder(_root);
		cout &lt;&lt; endl;
	}
	void _InOrder(Node* root)
	{
		if (root == nullptr)
		{
			return;
		}
		_InOrder(root-&gt;_left);
		cout &lt;&lt; root-&gt;_key &lt;&lt; " ";
		_InOrder(root-&gt;_right);
	}</code></pre> 
<h4>二查搜索树的查找</h4> 
<ol><li>从根开始查找，如果比根小走左路，比根大走右路。</li><li>最多查找高度次，如果没找到则不存在。</li></ol> 
<h4>二叉搜索树的删除（难点）</h4> 
<p>        首先需要查找元素中是否在二叉搜索树中，如果不存在，则返回，否则要删除的节点可以分为下面四种情况：</p> 
<ol><li>要删除的节点无孩子节点。</li><li>要删除的节点只有左孩子节点。</li><li>要删除的节点只有右孩子节点。</li><li>要删除的节点有左、右孩子节点。</li></ol> 
<p>总结下来，实际中真正要删除的情况只有三种：</p> 
<ol><li> 删除该节点且使被删除节点的双亲结点指向被删除节点的左孩子节点——直接删除。</li><li>删除该节点且使被删除节点的双亲结点指向被删除节点的右孩子节点——直接删除。</li><li>在它的右子树中寻找中序下的第一个节点（数值最小）或者在它的左子树中寻找中序前的最后一个节点（数值最大），用它的值填补到被删除节点中，再来处理该节点的删除问题【替换法】。 </li></ol> 
<p>再进行缩减就是：</p> 
<ol><li>没有孩子或者只有一个孩子，进行托孤。</li><li>有俩个孩子进行替换。</li></ol> 
<p><img alt="" height="352" src="https://images2.imgbox.com/97/ac/7N3jvSta_o.png" width="906"></p> 
<pre><code class="language-cpp">	//搜索二叉树的删除
	bool Erase(const K&amp; key)
	{
		Node* cur = _root;
		Node* parent = nullptr;
		while (cur)
		{
			if (cur-&gt;_key &gt; key)
			{
				parent = cur;
				cur = cur-&gt;_left;
			}
			else if (cur-&gt;_key &lt; key)
			{
				parent = cur;
				cur = cur-&gt;_right;
			}
			else
			{
				if (cur-&gt;_left == nullptr)
				{
					if (cur == _root)
					{
						_root = cur-&gt;_right;
					}
					else
					{
						if (parent-&gt;_left == cur)
						{
							parent-&gt;_left = cur-&gt;_right;
						}
						else
						{
							parent-&gt;_right = cur-&gt;_right;
						}
					}
				}
				else if(cur-&gt;_right == nullptr)
				{
					if (cur == _root)
					{
						_root = cur-&gt;_left;
					}
					else
					{
						if (parent-&gt;_left == cur)
						{
							parent-&gt;_left = cur-&gt;_left;
						}
						else
						{
							parent-&gt;_right = cur-&gt;_left;
						}
					}
				}
				else
				{
					//替换法
					Node* LeftMax = _root-&gt;_left;
					Node* parent = _root;
					while (LeftMax-&gt;_right)
					{
						parent = LeftMax;
						LeftMax = LeftMax-&gt;_right;
					}
					swap(LeftMax-&gt;_key, cur-&gt;_key);

					if (parent-&gt;_left == LeftMax)
					{
						parent-&gt;_left = LeftMax-&gt;_left;
					}
					else
					{
						parent-&gt;_right = LeftMax-&gt;_left;
					}

					cur = LeftMax;
				}
				delete cur;
				return true;
			}
		}
		return false;
	}</code></pre> 
<p>分析该代码：</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/33/ff/vGMPoGnh_o.png" width="1200"></p> 
<h3></h3> 
<h3>二叉树的递归实现</h3> 
<p>在递归实现的过程中，唯一需要注意的地方是使用了指针引用，这是因为引用不能改变指向，但是在递归函数的过程中都会重新定义引用。</p> 
<h4>递归升序打印</h4> 
<pre><code class="language-cpp">	//二叉树的升序打印
	void InOrder()
	{
		_InOrder(_root);
		cout &lt;&lt; endl;
	}
private:
	void _InOrder(Node* root)
	{
		if (root == nullptr)
		{
			return;
		}
		_InOrder(root-&gt;_left);
		cout &lt;&lt; root-&gt;_key &lt;&lt; " ";
		_InOrder(root-&gt;_right);
	}</code></pre> 
<h4>递归查找</h4> 
<pre><code class="language-cpp">	//查找
	bool FindR(const K&amp; key)
	{
		return _FindR(_root, key);
	}
private:
	bool _FindR(Node* root, const K&amp; key)
	{
		if (root == nullptr)
		{
			return false;
		}

		if (root-&gt;_key &gt; key)
		{
			return _FindR(root-&gt;_left, key);
		}
		else if (root-&gt;_key &lt; key)
		{
			return _FindR(root-&gt;_right, key);
		}
		else
		{
			return true;
		}
	}</code></pre> 
<h4>递归插入</h4> 
<pre><code class="language-cpp">	//插入
	bool InsertR(const K&amp; key)
	{
		return _InsertR(_root, key);
	}
private:
	bool _InsertR(Node*&amp; root, const K&amp; key)
	{
		if (root == nullptr)
		{
			root = new Node(key);
			return true;
		}

		if (root-&gt;_key &gt; key)
		{
			return _InsertR(root-&gt;_left, key);
		}
		else if (root-&gt;_key &lt; key)
		{
			return _InsertR(root-&gt;_right, key);
		}
		else
		{
			return false;
		}
	}</code></pre> 
<h3>递归删除</h3> 
<pre><code class="language-cpp">	//删除
	bool EraseR(const K&amp; key)
	{
		return _EraseR(_root, key);
	}
private:
	bool _EraseR(Node*&amp; root, const K&amp; key)
	{
		if (root == nullptr)
		{
			return false;
		}

		if (root-&gt;_key &gt; key)
		{
			return _EraseR(root-&gt;_left, key);
		}
		else if(root-&gt;_key &lt; key)
		{
			return _EraseR(root-&gt;_right, key);
		}
		else
		{
			Node* del = root;
			if (root-&gt;_left == nullptr)
			{
				root = root-&gt;_right;
			}
			else if (root-&gt;_right == nullptr)
			{
				root = root-&gt;_left;
			}
			else
			{
				Node* MaxLeft = root-&gt;_left;
				while (MaxLeft-&gt;_right)
				{
					MaxLeft = MaxLeft-&gt;_right;
				}
				swap(root-&gt;_key, MaxLeft-&gt;_key);

				return _EraseR(root-&gt;_left, key);
			}
			delete del;
			return true;
		}
	}</code></pre> 
<h3>二叉树完整代码展示</h3> 
<pre><code class="language-cpp">#pragma once
#include&lt;iostream&gt;
using namespace std;

template&lt;class K&gt;
struct BSTreeNode
{
	BSTreeNode(const K&amp; key)
		:_left(nullptr)
		,_right(nullptr)
		,_key(key)
	{}

	BSTreeNode&lt;K&gt;* _left;
	BSTreeNode&lt;K&gt;* _right;
	K _key;
};

template&lt;class K&gt;
struct BSTree
{
	typedef BSTreeNode&lt;K&gt; Node;
public:
	//初始化节点
	BSTree()
		:_root(nullptr)
	{}
	//插入数据
	bool insert(const K&amp; key)
	{
		if (_root == nullptr)
		{
			_root = new Node(key);
			return true;
		}
		Node* cur = _root;
		Node* parent = nullptr;
		while (cur)
		{
			if (cur-&gt;_key &lt; key)
			{
				parent = cur;
				cur = cur-&gt;_right;
			}
			else if (cur-&gt;_key &gt; key)
			{
				parent = cur;
				cur = cur-&gt;_left;
			}
			else
			{
				return false;
			}
		}
		cur = new Node(key);
		if (cur-&gt;_key &gt; parent-&gt;_key)
		{
			parent-&gt;_right = cur;
		}
		else
		{
			parent-&gt;_left = cur;
		}
		return true;
	}

	//搜索二叉树的查找
	bool Find(const K&amp; key)
	{
		Node* cur = _root;
		while (cur)
		{
			if (cur-&gt;_key &gt; key)
			{
				cur = cur-&gt;_left;
			}
			else if (cur-&gt;_key &lt; key)
			{
				cur = cur-&gt;_right;
			}
			else
			{
				return true;
			}
		}
		return false;
	}

	//搜索二叉树的删除
	bool Erase(const K&amp; key)
	{
		Node* cur = _root;
		Node* parent = nullptr;
		while (cur)
		{
			if (cur-&gt;_key &gt; key)
			{
				parent = cur;
				cur = cur-&gt;_left;
			}
			else if (cur-&gt;_key &lt; key)
			{
				parent = cur;
				cur = cur-&gt;_right;
			}
			else
			{
				if (cur-&gt;_left == nullptr)
				{
					if (cur == _root)
					{
						_root = cur-&gt;_right;
					}
					else
					{
						if (parent-&gt;_left == cur)
						{
							parent-&gt;_left = cur-&gt;_right;
						}
						else
						{
							parent-&gt;_right = cur-&gt;_right;
						}
					}
				}
				else if(cur-&gt;_right == nullptr)
				{
					if (cur == _root)
					{
						_root = cur-&gt;_left;
					}
					else
					{
						if (parent-&gt;_left == cur)
						{
							parent-&gt;_left = cur-&gt;_left;
						}
						else
						{
							parent-&gt;_right = cur-&gt;_left;
						}
					}
				}
				else
				{
					//替换法
					Node* LeftMax = _root-&gt;_left;
					Node* parent = _root;
					while (LeftMax-&gt;_right)
					{
						parent = LeftMax;
						LeftMax = LeftMax-&gt;_right;
					}
					swap(LeftMax-&gt;_key, cur-&gt;_key);

					if (parent-&gt;_left == LeftMax)
					{
						parent-&gt;_left = LeftMax-&gt;_left;
					}
					else
					{
						parent-&gt;_right = LeftMax-&gt;_left;
					}

					cur = LeftMax;
				}
				delete cur;
				return true;
			}
		}
		return false;
	}

	//二叉树的升序打印
	void InOrder()
	{
		_InOrder(_root);
		cout &lt;&lt; endl;
	}
	//查找
	bool FindR(const K&amp; key)
	{
		return _FindR(_root, key);
	}
	//插入
	bool InsertR(const K&amp; key)
	{
		return _InsertR(_root, key);
	}
	//删除
	bool EraseR(const K&amp; key)
	{
		return _EraseR(_root, key);
	}
private:
	bool _EraseR(Node*&amp; root, const K&amp; key)
	{
		if (root == nullptr)
		{
			return false;
		}

		if (root-&gt;_key &gt; key)
		{
			return _EraseR(root-&gt;_left, key);
		}
		else if(root-&gt;_key &lt; key)
		{
			return _EraseR(root-&gt;_right, key);
		}
		else
		{
			Node* del = root;
			if (root-&gt;_left == nullptr)
			{
				root = root-&gt;_right;
			}
			else if (root-&gt;_right == nullptr)
			{
				root = root-&gt;_left;
			}
			else
			{
				Node* MaxLeft = root-&gt;_left;
				while (MaxLeft-&gt;_right)
				{
					MaxLeft = MaxLeft-&gt;_right;
				}
				swap(root-&gt;_key, MaxLeft-&gt;_key);

				return _EraseR(root-&gt;_left, key);
			}
			delete del;
			return true;
		}
	}

	bool _InsertR(Node*&amp; root, const K&amp; key)
	{
		if (root == nullptr)
		{
			root = new Node(key);
			return true;
		}

		if (root-&gt;_key &gt; key)
		{
			return _InsertR(root-&gt;_left, key);
		}
		else if (root-&gt;_key &lt; key)
		{
			return _InsertR(root-&gt;_right, key);
		}
		else
		{
			return false;
		}
	}

	bool _FindR(Node* root, const K&amp; key)
	{
		if (root == nullptr)
		{
			return false;
		}

		if (root-&gt;_key &gt; key)
		{
			return _FindR(root-&gt;_left, key);
		}
		else if (root-&gt;_key &lt; key)
		{
			return _FindR(root-&gt;_right, key);
		}
		else
		{
			return true;
		}
	}

	void _InOrder(Node* root)
	{
		if (root == nullptr)
		{
			return;
		}
		_InOrder(root-&gt;_left);
		cout &lt;&lt; root-&gt;_key &lt;&lt; " ";
		_InOrder(root-&gt;_right);
	}
	Node* _root;
};
</code></pre> 
<h3>二叉树的应用</h3> 
<p>1.K模型：K模型即只有key作为关键码，结构中只需要存储key即可，关键码即为需要搜索到的值。K模型可以快速判断在不在的场景，之前模拟实现的就是K模型。</p> 
<ul><li>应用1：门禁系统。</li><li>应用2：小区车辆出入系统（是否允许进入）。</li><li>应用3：判断单词是否正确。</li></ul> 
<p>2.KV模型：每一个关键码key，都会对应一个value的值，即&lt; key,value &gt;。KV模型可以通过一个值快速找到另外一个值。</p> 
<ul><li>应用1：手机号码查询快递。</li><li>应用2：商城车辆出入系统（记录实际）。</li><li>应用3：高铁实名制车票系统。</li><li>应用4：英汉词典的中英文对应关系。</li></ul> 
<p>KV模型代码展示：</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;

using namespace std;

namespace key_value
{
	template&lt;class K, class V&gt;
	struct BSTreeNode
	{
		BSTreeNode&lt;K, V&gt;* _left;
		BSTreeNode&lt;K, V&gt;* _right;
		K _key;
		V _value;

		BSTreeNode(const K&amp; key, const V&amp; value)
			:_left(nullptr)
			, _right(nullptr)
			, _key(key)
			, _value(value)
		{}
	};

	template&lt;class K, class V&gt;
	class BSTree
	{
		typedef BSTreeNode&lt;K, V&gt; Node;
	public:
		BSTree()
			:_root(nullptr)
		{}

		void InOrder()
		{
			_InOrder(_root);
			cout &lt;&lt; endl;
		}

		Node* FindR(const K&amp; key)
		{
			return _FindR(_root, key);
		}

		bool InsertR(const K&amp; key, const V&amp; value)
		{
			return _InsertR(_root, key, value);
		}

		bool EraseR(const K&amp; key)
		{
			return _EraseR(_root, key);
		}

	private:
		bool _EraseR(Node*&amp; root, const K&amp; key)
		{
			if (root == nullptr)
				return false;

			if (root-&gt;_key &lt; key)
			{
				return _EraseR(root-&gt;_right, key);
			}
			else if (root-&gt;_key &gt; key)
			{
				return _EraseR(root-&gt;_left, key);
			}
			else
			{
				Node* del = root;

				// 1、左为空
				// 2、右为空
				// 3、左右都不为空
				if (root-&gt;_left == nullptr)
				{
					root = root-&gt;_right;
				}
				else if (root-&gt;_right == nullptr)
				{
					root = root-&gt;_left;
				}
				else
				{
					Node* leftMax = root-&gt;_left;
					while (leftMax-&gt;_right)
					{
						leftMax = leftMax-&gt;_right;
					}

					swap(root-&gt;_key, leftMax-&gt;_key);

					return _EraseR(root-&gt;_left, key);
				}

				delete del;
				return true;
			}
		}

		bool _InsertR(Node*&amp; root, const K&amp; key, const V&amp; value)
		{
			if (root == nullptr)
			{
				root = new Node(key, value);
				return true;
			}

			if (root-&gt;_key &lt; key)
			{
				return _InsertR(root-&gt;_right, key, value);
			}
			else if (root-&gt;_key &gt; key)
			{
				return _InsertR(root-&gt;_left, key, value);
			}
			else
			{
				return false;
			}
		}

		Node* _FindR(Node* root, const K&amp; key)
		{
			if (root == nullptr)
				return nullptr;

			if (root-&gt;_key &lt; key)
			{
				return _FindR(root-&gt;_right, key);
			}
			else if (root-&gt;_key &gt; key)
			{
				return _FindR(root-&gt;_left, key);
			}
			else
			{
				return root;
			}
		}

		void _InOrder(Node* root)
		{
			if (root == NULL)
			{
				return;
			}

			_InOrder(root-&gt;_left);
			cout &lt;&lt; root-&gt;_key &lt;&lt; ":" &lt;&lt; root-&gt;_value &lt;&lt; endl;
			_InOrder(root-&gt;_right);
		}
	private:
		Node* _root;
	};

	void TestBSTree1()
	{
		//BSTree&lt;string, Date&gt; carTree;
		BSTree&lt;string, string&gt; dict;
		dict.InsertR("insert", "插入");
		dict.InsertR("sort", "排序");
		dict.InsertR("right", "右边");
		dict.InsertR("date", "日期");

		string str;
		while (cin &gt;&gt; str)
		{
			BSTreeNode&lt;string, string&gt;* ret = dict.FindR(str);
			if (ret)
			{
				cout &lt;&lt; ret-&gt;_value &lt;&lt; endl;
			}
			else
			{
				cout &lt;&lt; "无此单词" &lt;&lt; endl;
			}
		}
	}

	void TestBSTree2()
	{
		// 统计水果出现的次数
		string arr[] = { "西瓜", "西瓜", "苹果", "西瓜", "苹果", "苹果", "西瓜", "苹果", "香蕉", "苹果", "香蕉" };
		BSTree&lt;string, int&gt; countTree;
		for (auto&amp; str : arr)
		{
			auto ret = countTree.FindR(str);
			if (ret == nullptr)
			{
				countTree.InsertR(str, 1);
			}
			else
			{
				ret-&gt;_value++;
			}
		}

		countTree.InOrder();
	}
}</code></pre> 
<h3>二叉树的性能分析</h3> 
<p>插入和删除都必须先查找，查找效率代表了二叉搜索树的各个操作的性能。</p> 
<p>        对于n个节点的二叉搜索树，若是每一个元素查找的概率相等，则二叉搜索树平均查找长度是节点在二叉搜索树的深度的函数，即节点越深，则比较的次数越多。</p> 
<p>        但是如果同一组数据的插入次序不同，可能得到不同结构的二叉搜索树。</p> 
<p><img alt="" height="284" src="https://images2.imgbox.com/01/41/jmh6IySa_o.png" width="349"></p> 
<p>最优的情况是：二叉搜索树为完全二叉树（或者接近完全二叉树），其平均比较次数为：logN</p> 
<p></p> 
<p><img alt="" height="269" src="https://images2.imgbox.com/de/f0/hFYNwwzM_o.png" width="445"></p> 
<p>最差的情况是：二叉搜索树退化成单支树（或者类似单支），其平均的比较次数为N。</p> 
<p>        使用有序数组进行二分查找的时候，其缺点是插入与删除效率不高；</p> 
<p>        使用搜索二叉树进行二分查找的时候，其可以很好地利用其特性进行查找、插入、删除、排序等操作，但是搜索二叉树的唯一缺点就是下限无保障（一条光杆树）。</p> 
<p>        所以在后续的C++文章中会介绍AVL树、红黑树、B树来解决这个问题。</p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7de8ce4f2c3525d4c702f7c4687d2649/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">写作新潮流：这五款AI写作工具，让你的作品脱颖而出</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8ec6fde9ccdc84a81ddaf63f54e41bbb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Meta 刚刚发布 Llama 3.1 ：在 AI 战斗中向 OpenAI 发起了大规模挑战｜TodayAI</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>