<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C/C&#43;&#43;数据结构之链表题目答案与解析 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/5b86e48e55a061cf86685107a918d871/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C/C&#43;&#43;数据结构之链表题目答案与解析">
  <meta property="og:description" content="个人主页：点我进入主页
专栏分类：C语言初阶 C语言程序设计————KTV C语言小游戏 C语言进阶
C语言刷题 数据结构初阶
欢迎大家点赞，评论，收藏。
一起努力，一起奔赴大厂。
目录
1.前言 2.题目解析
2.1 移除链表元素
2.2反转链表
2.3链表的中间结点
2.4链表中倒数第k个结点
2.5合并两个有序链表
2.6链表分割
3.结语
1.前言 在前面我们讲解了一些关于链表的内容，其中还有一些关于链表的习题，今天我们主要对这些题目进行解析。
2.题目解析 2.1 移除链表元素 给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。
示例 1：
输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5] 示例 2：
输入：head = [], val = 1 输出：[] 示例 3：
输入：head = [7,7,7,7], val = 7 输出：[] 提示：
列表中的节点数目在范围 [0, 104] 内1 &lt;= Node.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-11-11T16:09:25+08:00">
    <meta property="article:modified_time" content="2023-11-11T16:09:25+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C/C&#43;&#43;数据结构之链表题目答案与解析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p id="%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5%EF%BC%9A%E7%82%B9%E6%88%91%E8%BF%9B%E5%85%A5%E4%B8%BB%E9%A1%B5"><a href="https://so.csdn.net/so/search?q=%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5&amp;spm=1001.2101.3001.7020" title="个人主页">个人主页</a>：<a href="https://blog.csdn.net/Infernal_Puppet?type=blog" title="点我进入主页">点我进入主页</a></p> 
 <p>专栏分类：<a href="https://blog.csdn.net/infernal_puppet/category_12416957.html" title="C语言初阶">C语言初阶</a>      <a href="https://blog.csdn.net/infernal_puppet/category_12416960.html" title="C语言程序设计————KTV">C语言程序设计————KTV</a>       <a href="https://blog.csdn.net/infernal_puppet/category_12416959.html" title="C语言小游戏">C语言小游戏</a><a href="https://blog.csdn.net/infernal_puppet/category_12423643.html" title="     C语言进阶">     C语言进阶</a></p> 
 <p><a href="https://blog.csdn.net/infernal_puppet/category_12425334.html" title="C语言刷题">C语言刷题</a>       <a href="https://blog.csdn.net/infernal_puppet/category_12485804.html" title="数据结构初阶">数据结构初阶</a></p> 
 <p>欢迎大家点赞，评论，收藏。</p> 
 <p>一起努力，一起奔赴大厂。</p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="1.%E5%89%8D%E8%A8%80%C2%A0-toc" style="margin-left:0px;"><a href="#1.%E5%89%8D%E8%A8%80%C2%A0" rel="nofollow">1.前言 </a></p> 
<p id="2.%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-toc" style="margin-left:0px;"><a href="#2.%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90" rel="nofollow">2.题目解析</a></p> 
<p id="2.1%C2%A0%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0-toc" style="margin-left:40px;"><a href="#2.1%C2%A0%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0" rel="nofollow">2.1 移除链表元素</a></p> 
<p id="2.2%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-toc" style="margin-left:40px;"><a href="#2.2%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8" rel="nofollow">2.2反转链表</a></p> 
<p id="2.3%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9-toc" style="margin-left:40px;"><a href="#2.3%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9" rel="nofollow">2.3链表的中间结点</a></p> 
<p id="2.4%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9-toc" style="margin-left:40px;"><a href="#2.4%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9" rel="nofollow">2.4链表中倒数第k个结点</a></p> 
<p id="2.5%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-toc" style="margin-left:40px;"><a href="#2.5%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8" rel="nofollow">2.5合并两个有序链表</a></p> 
<p id="2.6%E9%93%BE%E8%A1%A8%E5%88%86%E5%89%B2-toc" style="margin-left:40px;"><a href="#2.6%E9%93%BE%E8%A1%A8%E5%88%86%E5%89%B2" rel="nofollow">2.6链表分割</a></p> 
<p id="3.%E7%BB%93%E8%AF%AD-toc" style="margin-left:0px;"><a href="#3.%E7%BB%93%E8%AF%AD" rel="nofollow">3.结语</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1.%E5%89%8D%E8%A8%80%C2%A0">1.前言 </h2> 
<p>        在前面我们讲解了一些关于链表的内容，其中还有一些关于链表的习题，今天我们主要对这些题目进行解析。</p> 
<h2 id="2.%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90">2.题目解析</h2> 
<h3 id="2.1%C2%A0%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0" style="background-color:transparent;">2.1<a href="https://leetcode.cn/problems/remove-linked-list-elements/" rel="nofollow" title=" 移除链表元素"> 移除链表元素</a></h3> 
<p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p> 
<p></p> 
<p><strong>示例 1：</strong></p> 
<p></p> 
<p class="img-center"><img alt="" height="222" src="https://images2.imgbox.com/f6/11/MqazxiMw_o.jpg" width="782"></p> 
<pre><strong>输入：</strong>head = [1,2,6,3,4,5,6], val = 6
<strong>输出：</strong>[1,2,3,4,5]
</pre> 
<p><strong>示例 2：</strong></p> 
<pre><strong>输入：</strong>head = [], val = 1
<strong>输出：</strong>[]
</pre> 
<p><strong>示例 3：</strong></p> 
<pre><strong>输入：</strong>head = [7,7,7,7], val = 7
<strong>输出：</strong>[]
</pre> 
<p></p> 
<p><strong>提示：</strong></p> 
<ul><li>列表中的节点数目在范围 <code>[0, 104]</code> 内</li><li><code>1 &lt;= Node.val &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 50</code></li></ul> 
<pre><code class="language-cpp">struct ListNode* removeElements(struct ListNode* head, int val) {
    struct ListNode *phead=(struct ListNode*)malloc(sizeof(struct ListNode));
    phead-&gt;next=head;
    struct ListNode *p=phead;
    struct ListNode *q=phead-&gt;next;
    if(!q)
        return NULL;
    while(q)
    {
        if(q-&gt;val==val)
        {
            p-&gt;next=q-&gt;next;
            free(q);
            q=p-&gt;next;
        }
        else 
        {
            p=p-&gt;next;
            q=q-&gt;next;
        }
    }
    return phead-&gt;next;
}</code></pre> 
<blockquote> 
 <p>        在这里我们需要对链表看是不是空的，只有一个节点，有多个节点这些情况进行讨论，我们建立一个带头节点的节点，然后将这些连上，先判断是不是空，不是空两个指针，一个指向建立的头节点，另一个指向后一个节点，我们针对后面的节点进行判断，值相等进行去除 操作，最后返回头节点的下一个节点。</p> 
</blockquote> 
<h3 id="2.2%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8">2.2<a href="https://leetcode.cn/problems/reverse-linked-list/" rel="nofollow" title="反转链表">反转链表</a></h3> 
<p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p> 
<p></p> 
<p><strong>示例 1：</strong></p> 
<p class="img-center"><img alt="" height="222" src="https://images2.imgbox.com/5d/31/OqqrhbRN_o.jpg" width="542"></p> 
<pre><strong>输入：</strong>head = [1,2,3,4,5]
<strong>输出：</strong>[5,4,3,2,1]
</pre> 
<p><strong>示例 2：</strong></p> 
<p class="img-center"><img alt="" height="222" src="https://images2.imgbox.com/9f/8a/x6RgCBLA_o.jpg" width="182"></p> 
<pre><strong>输入：</strong>head = [1,2]
<strong>输出：</strong>[2,1]
</pre> 
<p><strong>示例 3：</strong></p> 
<pre><strong>输入：</strong>head = []
<strong>输出：</strong>[]
</pre> 
<p></p> 
<p><strong>提示：</strong></p> 
<ul><li>链表中节点的数目范围是 <code>[0, 5000]</code></li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul> 
<p></p> 
<pre><code class="language-cpp">struct ListNode* reverseList(struct ListNode* head) {
    struct ListNode *phead=(struct ListNode *)malloc(sizeof(struct ListNode));
    struct ListNode *p=head;
    phead-&gt;next=NULL;
    if(!p)
        return NULL;
    struct ListNode *q=p-&gt;next;
    while(p)
    {
        p-&gt;next=phead-&gt;next;
        phead-&gt;next=p;
        p=q;
        if(q)
            q=q-&gt;next;
    }
    return phead-&gt;next;
}</code></pre> 
<blockquote> 
 <p>        我们建立一个头节点，然后连起来，判断是不是为空，我们知道头插相当于将数据进行反转，所以我们可以将链表一次一次地拆下来，然后头插到头节点上，我们用两个指针，一个用来记录位置，一个用来进行拆地操作。</p> 
</blockquote> 
<h3 id="2.3%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9">2.3<a href="https://leetcode.cn/problems/middle-of-the-linked-list/" rel="nofollow" title="链表的中间结点">链表的中间结点</a></h3> 
<p>给你单链表的头结点 <code>head</code> ，请你找出并返回链表的中间结点。</p> 
<p>如果有两个中间结点，则返回第二个中间结点。</p> 
<p></p> 
<p><strong>示例 1：</strong></p> 
<p></p> 
<p class="img-center"><img alt="" height="65" src="https://images2.imgbox.com/69/a4/Hhz3eB6x_o.jpg" width="544"></p> 
<pre><strong>输入：</strong>head = [1,2,3,4,5]
<strong>输出：</strong>[3,4,5]
<strong>解释：</strong>链表只有一个中间结点，值为 3 。
</pre> 
<p><strong>示例 2：</strong></p> 
<p></p> 
<p class="img-center"><img alt="" height="65" src="https://images2.imgbox.com/3a/01/4hV3cVpK_o.jpg" width="664"></p> 
<pre><strong>输入：</strong>head = [1,2,3,4,5,6]
<strong>输出：</strong>[4,5,6]
<strong>解释：</strong>该链表有两个中间结点，值分别为 3 和 4 ，返回第二个结点。
</pre> 
<p></p> 
<p><strong>提示：</strong></p> 
<ul><li>链表的结点数范围是 <code>[1, 100]</code></li><li><code>1 &lt;= Node.val &lt;= 100</code></li></ul> 
<pre><code class="language-cpp">struct ListNode* middleNode(struct ListNode* head) {
    struct ListNode*fast=head,*slow=head;
    if(!fast)
        return NULL;
    while(fast&amp;&amp;fast-&gt;next)
    {
        fast=(fast-&gt;next)-&gt;next;
        slow=slow-&gt;next;
    }
    return slow;
}</code></pre> 
<blockquote> 
 <p>        我们先对链表进行判断是不是空链表，然后利用快慢指针进行操作，快指针每次走两步，满指针每次走一步，当快指针为空且快指针地下一个指针不为空就进行，知道出现这两个有一个为空才停止。</p> 
</blockquote> 
<h3 id="2.4%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9">2.4<a class="link-info" href="https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&amp;&amp;tqId=11167&amp;rp=2&amp;ru=/activity/oj&amp;qru=/ta/coding-interviews/question-ranking" rel="nofollow" title="链表中倒数第k个结点">链表中倒数第k个结点</a></h3> 
<p>输入一个链表，输出该链表中倒数第k个结点。</p> 
<p style="background-color:transparent;">示例1</p> 
<p>输入：</p> 
<pre>1,{1,2,3,4,5}</pre> 
<p>复制返回值：</p> 
<pre>{5}</pre> 
<pre><code class="language-cpp">struct ListNode* FindKthToTail(struct ListNode* pListHead, int k ) {
    // write code here
    struct ListNode * flast=pListHead;
    while(k--)
    {
        if(flast==NULL)
            return NULL;
        flast=flast-&gt;next;
    }
    struct ListNode *slow=pListHead;
    while(flast)
    {
        slow=slow-&gt;next;
        flast=flast-&gt;next;
    }
    return slow;
}</code></pre> 
<blockquote> 
 <p>        在这里我们同样用快慢指针，我们先让快指针走k步如果在k次中出现为空说明超出限制，返回空，快指针走k步后快慢指针一起走当快指针指向空此时地慢指针就是倒数第k个节点。</p> 
</blockquote> 
<h3 id="2.5%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8">2.5<a href="https://leetcode.cn/problems/merge-two-sorted-lists/" rel="nofollow" title="合并两个有序链表">合并两个有序链表</a></h3> 
<p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p> 
<p></p> 
<p><strong>示例 1：</strong></p> 
<p class="img-center"><img alt="" height="302" src="https://images2.imgbox.com/b3/00/zq8pqEpM_o.jpg" width="662"></p> 
<pre><strong>输入：</strong>l1 = [1,2,4], l2 = [1,3,4]
<strong>输出：</strong>[1,1,2,3,4,4]
</pre> 
<p><strong>示例 2：</strong></p> 
<pre><strong>输入：</strong>l1 = [], l2 = []
<strong>输出：</strong>[]
</pre> 
<p><strong>示例 3：</strong></p> 
<pre><strong>输入：</strong>l1 = [], l2 = [0]
<strong>输出：</strong>[0]
</pre> 
<p></p> 
<p><strong>提示：</strong></p> 
<ul><li>两个链表的节点数目范围是 <code>[0, 50]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li></ul> 
<pre><code class="language-cpp">struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) {
    struct ListNode*phead=(struct ListNode *)malloc(sizeof(struct ListNode));
    struct ListNode*s1=list1,*s2=list2,*cur=phead;
    while(s1&amp;&amp;s2)
    {
        if(s1-&gt;val&lt;=s2-&gt;val)
        {
            cur-&gt;next=s1;
            cur=cur-&gt;next;
            s1=s1-&gt;next;
            cur-&gt;next=NULL;
        }
        else
        {
            cur-&gt;next=s2;
            cur=cur-&gt;next;
            s2=s2-&gt;next;
            cur-&gt;next=NULL;
        }
    }
    if(!s1)
    {
        cur-&gt;next=s2;
    }
    else{
        cur-&gt;next=s1;
    }
    return phead-&gt;next;
}</code></pre> 
<blockquote> 
 <p>        在这里我们创建一个头节点，然后两个指针指向这两个链表，当这两个指针有一个为空时结束循环，循环里就是找到这两个指针地数据哪一个小，去连上头节点进行尾插，这两有一个为空时另外一个直接连上。</p> 
</blockquote> 
<h3 id="2.6%E9%93%BE%E8%A1%A8%E5%88%86%E5%89%B2">2.6<a class="link-info" href="https://www.nowcoder.com/practice/0e27e0b064de4eacac178676ef9c9d70?tpId=8&amp;&amp;tqId=11004&amp;rp=2&amp;ru=/activity/oj&amp;qru=/ta/cracking-the-coding-interview/question-ranking" rel="nofollow" title="链表分割">链表分割</a></h3> 
<p>现有一链表的头指针 ListNode* <strong>pHead</strong>，给一定值x，编写一段代码将所有小于x的结点排在其余结点之前，且不能改变原来的数据顺序，返回重新排列后的链表的头指针。</p> 
<pre><code class="language-cpp">class Partition {
public:
    ListNode* partition(ListNode* pHead, int x) {
        // write code here        
        ListNode *list1=(ListNode*)malloc(sizeof(ListNode));
        ListNode *list2=(ListNode*)malloc(sizeof(ListNode));
        ListNode*s1=list1,*s2=list2;
        list1-&gt;next=NULL;
        list2-&gt;next=NULL;
        ListNode*p=pHead;
        while(p)
        {
            if(p-&gt;val&lt;x)
            {
                s1-&gt;next=p;
                p=p-&gt;next;
                s1-&gt;next=NULL;
            }
            else 
            {
                s2-&gt;next=p;
                p=p-&gt;next;
                s2-&gt;next=NULL;
            }
        }
        s1-&gt;next=list2-&gt;next;
        free(list2);
    return list1-&gt;next;

}</code></pre> 
<blockquote> 
 <p>        我们创建两个头节点，然后将小于x的放在一个链表上，大于等于X的放在另一个链表，最后连起来。</p> 
</blockquote> 
<h2 id="3.%E7%BB%93%E8%AF%AD">3.结语</h2> 
<p>        数据结构的学习非常的重要，我们想要学习好数据结构需要我们多多的刷题，希望大家可以在平时多多刷题来提升自己，最后希望大家可以三连一下</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/20a9fc19d59d237583694749c2925bd8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【MybatisPlus】对数据库中datetime类型字段的处理（获取与格式处理）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d5034f9ef2c52f25e075bc4e93e82162/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Linux】Centos7 shell实现MySQL5.7 tar 一键安装</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>