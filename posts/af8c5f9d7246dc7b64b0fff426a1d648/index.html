<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】【版本1.3】【线性时代】——栈 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/af8c5f9d7246dc7b64b0fff426a1d648/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】【版本1.3】【线性时代】——栈">
  <meta property="og:description" content="快乐的流畅：个人主页 个人专栏：《算法神殿》《数据结构世界》《进击的C&#43;&#43;》 远方有一堆篝火，在为久候之人燃烧！ 文章目录 引言一、栈的概念二、栈的模拟实现2.1 定义2.2 初始化2.3 销毁2.4 压栈2.5 判空2.6 出栈2.7 获取栈顶元素2.8 获取栈的元素个数2.9 元素访问 三、栈的应用场景 引言 数据结构世界——栈（Stack）
一、栈的概念 栈，是一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端称为栈顶，另一端称为栈底。栈中的数据元素遵守后进先出LIFO（Last In First Out）的原则。
压栈：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶。
出栈：栈的删除操作叫做出栈。出数据也在栈顶。
二、栈的模拟实现 栈的实现一般可以使用数组或者链表实现，相对而言数组的结构实现更优一些。因为数组在尾上插入数据的代价比较小。
2.1 定义 typedef int STDataType; typedef struct Stack { STDataType* a; int top; int capacity; }ST; 当前元素个数用栈顶top来表示，是栈独有的表示方法 2.2 初始化 void STInit(ST* pst) { assert(pst); pst-&gt;a = NULL; pst-&gt;top = 0;//top指向栈顶元素的下一个位置 pst-&gt;capacity = 0; } 栈的初始化，top可以为0或-1，top为0，则指向栈顶元素的下一个位置，top为-1，则指向栈顶元素的位置这里选用top为0，因为后面写的适合方便理解 2.3 销毁 void STDestroy(ST* pst) { assert(pst); free(pst-&gt;a); pst-&gt;top = pst-&gt;capacity = 0; } 栈的销毁和顺序表一样，直接释放数组空间，将top和capacity置为0 2.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-20T09:24:01+08:00">
    <meta property="article:modified_time" content="2024-06-20T09:24:01+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】【版本1.3】【线性时代】——栈</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><br><img src="https://images2.imgbox.com/69/8d/lzropIHN_o.png" alt=""></p> 
<p><br></p> 
<center> 
 <font color="SteelBlue" size="5"><strong> 快乐的流畅：<a href="https://blog.csdn.net/2301_79188764?spm=1011.2415.3001.5343">个人主页</a></strong></font> 
</center> 
<p></p> 
<p><br></p> 
<center> 
 <font color="DarkGreen"><strong> 个人专栏：<a href="https://blog.csdn.net/2301_79188764/category_12622897.html">《算法神殿》</a><a href="https://blog.csdn.net/2301_79188764/category_12487455.html?spm=1001.2014.3001.5482">《数据结构世界》</a><a href="https://blog.csdn.net/2301_79188764/category_12516197.html?spm=1001.2014.3001.5482">《进击的C++》</a></strong></font> 
</center> 
<p></p> 
<center> 
 <font color="OrangeRed" size="4"><strong> 远方有一堆篝火，在为久候之人燃烧！</strong></font> 
</center> 
<hr> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_11" rel="nofollow">引言</a></li><li><a href="#_13" rel="nofollow">一、栈的概念</a></li><li><a href="#_22" rel="nofollow">二、栈的模拟实现</a></li><li><ul><li><a href="#21__26" rel="nofollow">2.1 定义</a></li><li><a href="#22__39" rel="nofollow">2.2 初始化</a></li><li><a href="#23__54" rel="nofollow">2.3 销毁</a></li><li><a href="#24__66" rel="nofollow">2.4 压栈</a></li><li><a href="#25__96" rel="nofollow">2.5 判空</a></li><li><a href="#26__107" rel="nofollow">2.6 出栈</a></li><li><a href="#27__120" rel="nofollow">2.7 获取栈顶元素</a></li><li><a href="#28__133" rel="nofollow">2.8 获取栈的元素个数</a></li><li><a href="#29__148" rel="nofollow">2.9 元素访问</a></li></ul> 
  </li><li><a href="#_178" rel="nofollow">三、栈的应用场景</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_11"></a>引言</h2> 
<p>数据结构世界——栈（Stack）</p> 
<h2><a id="_13"></a>一、栈的概念</h2> 
<p>栈，是一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行<strong>数据插入和删除操作的一端称为栈顶，另一端称为栈底</strong>。栈中的数据元素遵守<mark>后进先出LIFO</mark>（Last In First Out）的原则。</p> 
<p><img src="https://images2.imgbox.com/3f/cc/HsSilHIp_o.png" alt=""></p> 
<p><code>压栈</code>：栈的插入操作叫做进栈/压栈/入栈，<strong>入数据在栈顶</strong>。<br> <code>出栈</code>：栈的删除操作叫做出栈。<strong>出数据也在栈顶</strong>。</p> 
<p><img src="https://images2.imgbox.com/d6/41/t6zjL691_o.png" alt=""></p> 
<h2><a id="_22"></a>二、栈的模拟实现</h2> 
<p>栈的实现一般可以使用<code>数组</code>或者<code>链表</code>实现，相对而言数组的结构实现更优一些。因为数组在尾上插入数据的代价比较小。</p> 
<p><img src="https://images2.imgbox.com/b6/aa/mtWJFEp8_o.png" alt=""></p> 
<h3><a id="21__26"></a>2.1 定义</h3> 
<pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">int</span> STDataType<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Stack</span>
<span class="token punctuation">{<!-- --></span>
	STDataType<span class="token operator">*</span> a<span class="token punctuation">;</span>
	<span class="token keyword">int</span> top<span class="token punctuation">;</span>
	<span class="token keyword">int</span> capacity<span class="token punctuation">;</span>
<span class="token punctuation">}</span>ST<span class="token punctuation">;</span>
</code></pre> 
<ul><li>当前元素个数用栈顶top来表示，是栈独有的表示方法</li></ul> 
<h3><a id="22__39"></a>2.2 初始化</h3> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">STInit</span><span class="token punctuation">(</span>ST<span class="token operator">*</span> pst<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pst<span class="token punctuation">)</span><span class="token punctuation">;</span>

	pst<span class="token operator">-&gt;</span>a <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	pst<span class="token operator">-&gt;</span>top <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//top指向栈顶元素的下一个位置</span>
	pst<span class="token operator">-&gt;</span>capacity <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>栈的初始化，top可以为0或-1，top为0，则指向栈顶元素的下一个位置，top为-1，则指向栈顶元素的位置</li><li>这里选用top为0，因为后面写的适合方便理解</li></ul> 
<h3><a id="23__54"></a>2.3 销毁</h3> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">STDestroy</span><span class="token punctuation">(</span>ST<span class="token operator">*</span> pst<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pst<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">free</span><span class="token punctuation">(</span>pst<span class="token operator">-&gt;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	pst<span class="token operator">-&gt;</span>top <span class="token operator">=</span> pst<span class="token operator">-&gt;</span>capacity <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>栈的销毁和顺序表一样，直接释放数组空间，将top和capacity置为0</li></ul> 
<h3><a id="24__66"></a>2.4 压栈</h3> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">STPush</span><span class="token punctuation">(</span>ST<span class="token operator">*</span> pst<span class="token punctuation">,</span> STDataType x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pst<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>pst<span class="token operator">-&gt;</span>top <span class="token operator">==</span> pst<span class="token operator">-&gt;</span>capacity<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> newCapacity <span class="token operator">=</span> pst<span class="token operator">-&gt;</span>capacity <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">4</span> <span class="token operator">:</span> pst<span class="token operator">-&gt;</span>capacity <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
		STDataType<span class="token operator">*</span> tmp <span class="token operator">=</span> <span class="token punctuation">(</span>STDataType<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">realloc</span><span class="token punctuation">(</span>pst<span class="token operator">-&gt;</span>a<span class="token punctuation">,</span> newCapacity <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>STDataType<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token keyword">if</span> <span class="token punctuation">(</span>tmp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"realloc fail"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		pst<span class="token operator">-&gt;</span>a <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
		pst<span class="token operator">-&gt;</span>capacity <span class="token operator">=</span> newCapacity<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	pst<span class="token operator">-&gt;</span>a<span class="token punctuation">[</span>pst<span class="token operator">-&gt;</span>top<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>先判断是否需要扩容，因为这里只有压栈函数需要判断扩容，所以就不用专门再写一个扩容函数</li><li>初始容量为4，后续每次进行2倍扩容（这样扩容比较合理，不会太频繁，也不会太浪费）</li><li>再将元素压栈，top++</li></ul> 
<p>ps：<code>realloc</code>函数在pst为<code>NULL</code>时，充当<code>malloc</code>的作用，所以既可以为初始栈开辟空间，又可以扩容 。</p> 
<h3><a id="25__96"></a>2.5 判空</h3> 
<pre><code class="prism language-c">bool <span class="token function">STEmpty</span><span class="token punctuation">(</span>ST<span class="token operator">*</span> pst<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pst<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> pst<span class="token operator">-&gt;</span>top <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>如果top为0，则栈为空，返回真；反之，返回假</li></ul> 
<h3><a id="26__107"></a>2.6 出栈</h3> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">STPop</span><span class="token punctuation">(</span>ST<span class="token operator">*</span> pst<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pst<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">STEmpty</span><span class="token punctuation">(</span>pst<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	pst<span class="token operator">-&gt;</span>top<span class="token operator">--</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>先<code>assert</code>断言判断，栈是否为空，因为top不能减到负数</li><li>再将top- -，掩盖栈顶元素</li></ul> 
<h3><a id="27__120"></a>2.7 获取栈顶元素</h3> 
<pre><code class="prism language-c">STDataType <span class="token function">STTop</span><span class="token punctuation">(</span>ST<span class="token operator">*</span> pst<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pst<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">STEmpty</span><span class="token punctuation">(</span>pst<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> pst<span class="token operator">-&gt;</span>a<span class="token punctuation">[</span>pst<span class="token operator">-&gt;</span>top <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>先<code>assert</code>断言判断，栈是否为空，因为top不能减到负数</li><li>再返回栈顶元素，因为这里top指向的是栈顶元素的下一位，所以下标访问时top要减1</li></ul> 
<h3><a id="28__133"></a>2.8 获取栈的元素个数</h3> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">STSize</span><span class="token punctuation">(</span>ST<span class="token operator">*</span> pst<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pst<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> pst<span class="token operator">-&gt;</span>top<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>top指向的是栈顶元素的下一位，所以数值上就是栈的元素个数</li></ul> 
<hr> 
<p>这里很多函数实现都很简单，有些操作直接外部对结构体都可以直接实现，但最后还是写成函数封装，<mark>因为top的含义有多重，防止别人使用时误解</mark>，导致使用错误 。</p> 
<h3><a id="29__148"></a>2.9 元素访问</h3> 
<p>栈中元素访问（打印），不是用函数实现。<strong>因为它的特殊结构，决定了它的元素不能从任意位置访问</strong> ，必须符合<mark>后进先出</mark>原则才可以。</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">TestStack1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	ST st<span class="token punctuation">;</span>
	<span class="token comment">//初始化</span>
	<span class="token function">STInit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//压栈</span>
	<span class="token function">STPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">STPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token function">STTop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">STPop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">STPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">STPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">STPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//打印</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">STEmpty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token function">STTop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">STPop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//销毁</span>
	<span class="token function">STDestroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>通常用循环的方式进行访问，同时每访问一个元素，就将它弹出栈，在进行下一个元素的访问</li></ul> 
<h2><a id="_178"></a>三、栈的应用场景</h2> 
<ol><li> <p><strong>函数调用与返回</strong><br> 在程序执行过程中，函数调用和返回是栈结构的一个典型应用。当函数被调用时，其返回地址、局部变量等信息被压入调用栈中；当函数返回时，这些信息从调用栈中弹出并恢复程序的执行状态。</p> </li><li> <p><strong>浏览器的前进后退</strong><br> 在浏览器中浏览网页时，我们使用的前进和后退功能也是栈结构的一个应用。浏览器将用户访问过的网页地址保存在一个栈中，当用户点击后退按钮时，浏览器从栈顶弹出最近访问的网页地址并跳转到该网页；当用户点击前进按钮时，浏览器将之前弹出的网页地址重新压入栈中并跳转到该网页。</p> </li><li> <p><strong>表达式求值</strong><br> 在编译器和解释器中，表达式求值也是栈结构的一个重要应用。编译器和解释器将表达式转换为逆波兰表示法（Reverse Polish Notation, RPN），并使用栈来存储和操作操作数和操作符，从而实现表达式的求值。</p> </li></ol> 
<br> 
<p><img src="https://images2.imgbox.com/95/52/awsgQfVx_o.png" alt="" width="100" height="100"></p> 
<center> 
 <font color="SteelBlue" size="5"><strong> 真诚点赞，手有余香 </strong></font> 
</center> 
<br>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c23fec285eafea78cda4380ebd620350/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【一起学Rust】Rust学习方法及学习路线汇总（赠书：《Rust游戏开发实战》）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6f7bf16f7a813862c6ac7827a38bba77/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">适用于所有 Android 手机的 8 大 Android 解锁工具</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>