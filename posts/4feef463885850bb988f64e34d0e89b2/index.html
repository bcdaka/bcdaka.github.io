<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【链表】还不会用C&#43;&#43;实现链表？一文教会你各种链表的实现 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/4feef463885850bb988f64e34d0e89b2/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【链表】还不会用C&#43;&#43;实现链表？一文教会你各种链表的实现">
  <meta property="og:description" content="本文将用C&#43;&#43;语言来实现数据结构中的无头单链表，带头循环链表，以及带头循环双向链表等链表结构（带头单链表与后两种链表的结构相似，实现起来比后两种更简单，读者阅读完本文即可自行实现）
一、无头单链表的实现 无头单链表在头插时需要改变头指针的位置，具体代码实现如下：
//无头单链表 #include &lt;iostream&gt; #include &lt;assert.h&gt; using namespace std; template &lt;class T&gt; //先定义链表中的节点 struct SListNode { T data; SListNode* next; SListNode(T x) { this-&gt;data = x; this-&gt;next = nullptr; } }; template &lt;class T&gt; class SList { private: //链表初始化后链表中就有一个节点 SListNode&lt;T&gt;* head; public: SList(T x) { this-&gt;head = new SListNode&lt;T&gt;(x); } ~SList() { SListNode&lt;T&gt;* cur = head; while (cur) { SListNode&lt;T&gt;* next = cur-&gt;next; delete cur; cur = next; } } // 动态申请一个节点 SListNode&lt;T&gt;* BuySListNode(T x); // 单链表打印 void SListPrint(); // 单链表尾插 void SListPushBack(T x); // 单链表的头插 void SListPushFront(T x); // 单链表的尾删 void SListPopBack(); // 单链表头删 void SListPopFront(); // 单链表查找 SListNode&lt;T&gt;* SListFind(T x); // 单链表在pos位置之后插入x void SListInsertAfter(SListNode&lt;T&gt;* pos, T x); // 单链表删除pos位置之后的值 void SListEraseAfter(SListNode&lt;T&gt;* pos); }; template &lt;class T&gt; SListNode&lt;T&gt;* SList&lt;T&gt;:: BuySListNode(T x) { SListNode&lt;T&gt;* tmp = new SListNode&lt;T&gt;(x); tmp-&gt;next = nullptr; return tmp; } template &lt;class T&gt; void SList&lt;T&gt;::SListPrint() { SListNode&lt;T&gt;* cur =head; while (cur) { cout &lt;&lt; cur-&gt;data &lt;&lt; &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-09-26T23:33:21+08:00">
    <meta property="article:modified_time" content="2023-09-26T23:33:21+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【链表】还不会用C&#43;&#43;实现链表？一文教会你各种链表的实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>本文将用C++语言来实现数据结构中的无头单链表，带头循环链表，以及带头循环双向链表等链表结构（带头单链表与后两种链表的结构相似，实现起来比后两种更简单，读者阅读完本文即可自行实现）</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/3c/66/woQNzoi5_o.jpg"></p> 
<h2>一、无头单链表的实现</h2> 
<p>无头单链表在头插时需要改变头指针的位置，具体代码实现如下：</p> 
<pre><code class="language-cpp">//无头单链表

#include &lt;iostream&gt;
#include &lt;assert.h&gt;

using namespace std;

template &lt;class T&gt;

//先定义链表中的节点
struct SListNode
{
	T data;
	SListNode* next;

	SListNode(T x)
	{
		this-&gt;data = x;
		this-&gt;next = nullptr;
	}
};

template &lt;class T&gt;
class SList
{
private:
	//链表初始化后链表中就有一个节点
	SListNode&lt;T&gt;* head;
	
public:
	SList(T x)
	{
		this-&gt;head = new SListNode&lt;T&gt;(x);
	}

	~SList()
	{
		SListNode&lt;T&gt;* cur = head;
		while (cur)
		{
			SListNode&lt;T&gt;* next = cur-&gt;next;
			delete cur;
			cur = next;
		}
	}


	// 动态申请一个节点
	SListNode&lt;T&gt;* BuySListNode(T x);

	// 单链表打印
	void SListPrint();

	// 单链表尾插
	void SListPushBack(T x);

	// 单链表的头插
	void SListPushFront(T x);

	// 单链表的尾删
	void SListPopBack();

	// 单链表头删
	void SListPopFront();

	// 单链表查找
	SListNode&lt;T&gt;* SListFind(T x);

	// 单链表在pos位置之后插入x
	void SListInsertAfter(SListNode&lt;T&gt;* pos, T x);

	// 单链表删除pos位置之后的值
	void SListEraseAfter(SListNode&lt;T&gt;* pos);

};


template &lt;class T&gt;
SListNode&lt;T&gt;* SList&lt;T&gt;:: BuySListNode(T x)
{
	SListNode&lt;T&gt;* tmp = new SListNode&lt;T&gt;(x);
	tmp-&gt;next = nullptr;
	return tmp;
}

template &lt;class T&gt;
void SList&lt;T&gt;::SListPrint()
{
	SListNode&lt;T&gt;* cur =head;
	while (cur)
	{
		cout &lt;&lt; cur-&gt;data &lt;&lt; "-&gt;";
		cur = cur-&gt;next;
	}
	cout &lt;&lt; "NULL" &lt;&lt; endl;
}

template &lt;class T&gt;
void SList&lt;T&gt;::SListPushBack(T x)
{
	SListNode&lt;T&gt;* cur = head;

	while (cur-&gt;next)
	{
		cur = cur-&gt;next;
	}
	SListNode&lt;T&gt;* newnode = BuySListNode(x);
	cur-&gt;next = newnode;//连接
}
template &lt;class T&gt;
void SList&lt;T&gt;::SListPushFront(T x)
{
	SListNode&lt;T&gt;* newnode = BuySListNode(x);
	newnode-&gt;next = head;
	head = newnode;
}

template &lt;class T&gt;
void SList&lt;T&gt;::SListPopBack()
{
	assert(head);//头结点为空就不能继续删除了
	SListNode&lt;T&gt;* tail = head;
	//链表中只有一个节点就只能删除头结点
	if (tail-&gt;next == nullptr)
	{
		delete head;
	}
	else
	{
		while (tail-&gt;next-&gt;next != NULL)
		{
			tail = tail-&gt;next;
		}
		delete tail-&gt;next;
		tail-&gt;next = nullptr;
	}

}

template &lt;class T&gt;
void SList&lt;T&gt;::SListPopFront()
{
	assert(head);
	SListNode&lt;T&gt;* cur = head-&gt;next;
	delete head;
	head = cur;
}

template &lt;class T&gt;
SListNode&lt;T&gt;* SList&lt;T&gt;::SListFind(T x)
{
	assert(head);
	SListNode&lt;T&gt;* cur = head;
	while (cur)
	{
		if (cur-&gt;data == x)
		{
			return cur;
		}
		cur = cur-&gt;next;
	}
	return nullptr;
}

template &lt;class T&gt;
void SList&lt;T&gt;::SListInsertAfter(SListNode&lt;T&gt;* pos, T x)
{
	assert(pos);
	SListNode&lt;T&gt;* newnode = BuySListNode(x);
	newnode-&gt;next = pos-&gt;next;
	pos-&gt;next = newnode;
}


template &lt;class T&gt;
void SList&lt;T&gt;::SListEraseAfter(SListNode&lt;T&gt;* pos)
{
	assert(pos-&gt;next &amp;&amp; pos);
	SListNode&lt;T&gt;* cur = pos-&gt;next;
	pos-&gt;next = pos-&gt;next-&gt;next;
	delete cur;
}


int main()
{

	SList&lt;int&gt; cur(1);

	cur.SListPushBack(2);
	cur.SListPushBack(3);
	cur.SListPushBack(4);
	cur.SListPushBack(5);
	cur.SListPushBack(6);
	cur.SListPrint();

	cur.SListPopFront();
	cur.SListPrint();

	cur.SListPopBack();
	cur.SListPrint();

	SListNode&lt;int&gt;* p1 = cur.SListFind(2);
	cur.SListInsertAfter(p1, 20);
	cur.SListPrint();

	cur.SListEraseAfter(p1);
	cur.SListPrint();


	
	return 0;
}</code></pre> 
<h2>二、带头循环链表的实现</h2> 
<p>带头意味着链表中会一直存在着一个头结点，无论链表的插入还是删除都是对头结点后面的节点进行的操作。头插的节点也是直接连接在头结点的下一个结点，不会改变头结点。循环意味着尾节点的next指针指向头节点，就像是形成了一个环一样。</p> 
<p>具体实现代码如下：</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;assert.h&gt;

using namespace std;

template &lt;class T&gt;
struct Node
{
	T data;
	struct Node* next;
	Node()
	{
		this-&gt;data = 0;
		this-&gt;next = nullptr;
	}
	Node(T data)
	{
		this-&gt;data = data;
		this-&gt;next = nullptr;
	}
};

template &lt;class T&gt;
class SList
{
private:
	Node&lt;T&gt;* head;
	Node&lt;T&gt;* tail;
public:
	SList()
	{
		this-&gt;head = new Node&lt;T&gt;();
		this-&gt;tail = head;
	}

	~SList()
	{
		Node&lt;T&gt;* p = head;
		Node&lt;T&gt;* q = head;
		while (p != tail)
		{
			q = p-&gt;next;
			delete p;
			p = q;
		}
		delete tail;
	}

	
	// 动态申请一个节点
	Node&lt;T&gt;* BuySListNode(T x);

	// 单链表打印
	void SListPrint();

	// 单链表尾插
	void SListPushBack(T x);

	// 单链表的头插
	void SListPushFront(T x);

	// 单链表的尾删
	void SListPopBack();

	// 单链表头删
	void SListPopFront();

	// 单链表查找
	Node&lt;T&gt;* SListFind( T x);

	// 单链表在pos位置之后插入x
	void SListInsertAfter(Node&lt;T&gt;* pos, T x);

	// 单链表删除pos位置之后的值
	void SListEraseAfter(Node&lt;T&gt;* pos);

};

template &lt;class T&gt;
Node&lt;T&gt;* SList&lt;T&gt;::BuySListNode(T x)
{
	Node&lt;T&gt;* tmp = new Node&lt;T&gt;;
	tmp-&gt;data = x;
	tmp-&gt;next = nullptr;
	return tmp;
}

template &lt;class T&gt;
void SList&lt;T&gt;::SListPrint()
{
	assert(head-&gt;next);//保证头节点后还有结点才打印，不然报错
	Node&lt;T&gt;* cur = head-&gt;next;
	while (cur != head)
	{
		cout &lt;&lt; cur-&gt;data &lt;&lt; "-&gt;";
		cur = cur-&gt;next;
	}
	cout &lt;&lt; "NULL" &lt;&lt; endl;
}

template &lt;class T&gt;
void SList&lt;T&gt;::SListPushBack(T x)
{
	Node&lt;T&gt;* newnode = BuySListNode(x);
	tail-&gt;next = newnode;
	tail = newnode;
	tail-&gt;next = head;//尾节点的next指向头节点
}

template &lt;class T&gt;
void SList&lt;T&gt;::SListPushFront(T x)
{
	Node&lt;T&gt;* newnode = BuySListNode(x);
	if (head == tail)
	{
		head-&gt;next = newnode;
		tail = newnode;
		tail-&gt;next = head;
	}
	else
	{
		newnode-&gt;next = head-&gt;next;
		head-&gt;next = newnode;
	}
}

template &lt;class T&gt;
void SList&lt;T&gt;::SListPopBack()
{
	assert(head-&gt;next);
	Node&lt;T&gt;* cur = head;
	while (cur-&gt;next != tail)
	{
		cur = cur-&gt;next;
	}
	delete tail;
	tail = cur;
	tail-&gt;next = head;

}

template &lt;class T&gt;
void SList&lt;T&gt;::SListPopFront()
{
	assert(head-&gt;next);
	Node&lt;T&gt;* cur = head-&gt;next;

	if (head-&gt;next == tail)
	{
		delete tail;
		tail = head;
	}
	else
	{
		head-&gt;next = cur-&gt;next;
		delete cur;
	}
}

template &lt;class T&gt;
Node&lt;T&gt;* SList&lt;T&gt;::SListFind(T x)
{
	assert(head-&gt;next);
	Node&lt;T&gt;* cur = head-&gt;next;
	while (cur != head)
	{
		if (cur-&gt;data == x)
		{
			return cur;
		}
		cur = cur-&gt;next;
	}
	return nullptr;
}

template &lt;class T&gt;
void SList&lt;T&gt;::SListInsertAfter(Node&lt;T&gt;* pos, T x)
{
	assert(pos);
	if (pos-&gt;next == head)
	{
		SListPushBack(x);
	}
	else if(pos == head)
	{
		SListPushFront(x);
	}
	else
	{
		Node&lt;T&gt;* newnode = BuySListNode(x);
		newnode-&gt;next = pos-&gt;next;
		pos-&gt;next = newnode;
	}
}
template &lt;class T&gt;
void SList&lt;T&gt;::SListEraseAfter(Node&lt;T&gt;* pos)
{
	assert(pos);
	//尾节点后的头节点不能删
	if (pos-&gt;next == head)
	{
		exit(-1);
	}
	else if (pos == head)
	{
		SListPopFront();
	}
	else
	{
		Node&lt;T&gt;* cur = pos-&gt;next;
		pos-&gt;next = pos-&gt;next-&gt;next;
		delete cur;
	}
}


int main()
{

	SList&lt;int&gt; SL1;
	SL1.SListPushBack(1);
	SL1.SListPushBack(2);
	SL1.SListPushBack(3);
	SL1.SListPushBack(4);
	SL1.SListPushBack(5);
	SL1.SListPrint();

	SL1.SListPushFront(10);
	SL1.SListPrint();

	SL1.SListPopFront();
	SL1.SListPrint();

	SL1.SListPopBack();
	SL1.SListPrint();

	Node&lt;int&gt;* cur = SL1.SListFind(2);
	SL1.SListInsertAfter(cur, 20);
	SL1.SListPrint();

	SL1.SListEraseAfter(cur);
	SL1.SListPrint();

	return 0;
}</code></pre> 
<h2>三、带头双向循环链表的实现</h2> 
<p>具体实现思路与带头循环链表大同小异，只是在节点中需要增加一个指向前一个节点的指针。</p> 
<p>具体实现代码如下：</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;assert.h&gt;

using namespace std;

template &lt;class T&gt;
struct Node
{
	T data;
	struct Node* prev;//指向前一个节点的指针
	struct Node* next;
	Node()
	{
		this-&gt;data = 0;
		this-&gt;prev = nullptr;
		this-&gt;next = nullptr;
	}
	Node(T data)
	{
		this-&gt;data = data;
		this-&gt;prev = nullptr;
		this-&gt;next = nullptr;
	}
};

template &lt;class T&gt;
class SList
{
private:
	Node&lt;T&gt;* head;//头节点
	Node&lt;T&gt;* tail;//尾节点
public:
	SList()
	{
		this-&gt;head = new Node&lt;T&gt;();
		head-&gt;next = nullptr;
		head-&gt;prev = nullptr;
		this-&gt;tail = head;
	}

	~SList()
	{
		Node&lt;T&gt;* p = head;
		Node&lt;T&gt;* q = head;
		while (p != tail)
		{
			q = p-&gt;next;
			delete p;
			p = q;
		}
		delete tail;
	}

	Node&lt;T&gt;* getHead()
	{
		return this-&gt;head;
	}

	// 动态申请一个节点
	Node&lt;T&gt;* BuySListNode(T x);

	// 单链表打印
	void SListPrint();

	// 单链表尾插
	void SListPushBack(T x);

	// 单链表的头插
	void SListPushFront(T x);

	// 单链表的尾删
	void SListPopBack();

	// 单链表头删
	void SListPopFront();

	// 单链表查找
	Node&lt;T&gt;* SListFind(T x);

	// 单链表在pos位置之后插入x
	void SListInsertAfter(Node&lt;T&gt;* pos, T x);

	// 单链表删除pos位置之后的值
	void SListEraseAfter(Node&lt;T&gt;* pos);

};

template &lt;class T&gt;
Node&lt;T&gt;* SList&lt;T&gt;::BuySListNode(T x)
{
	Node&lt;T&gt;* tmp = new Node&lt;T&gt;;
	tmp-&gt;data = x;
	tmp-&gt;prev = nullptr;
	tmp-&gt;next = nullptr;
	return tmp;
}

template &lt;class T&gt;
void SList&lt;T&gt;::SListPrint()
{
	assert(head-&gt;next);
	Node&lt;T&gt;* cur = head-&gt;next;
	while (cur != head)
	{
		cout &lt;&lt; cur-&gt;data &lt;&lt; "&lt;-&gt;";
		cur = cur-&gt;next;
	}
	cout &lt;&lt; endl;
}

template &lt;class T&gt;
void SList&lt;T&gt;::SListPushBack(T x)
{
	Node&lt;T&gt;* newnode = BuySListNode(x);
	tail-&gt;next = newnode;
	newnode-&gt;prev = tail;
	tail = newnode;
	tail-&gt;next = head;
	head-&gt;prev = tail;
}

template &lt;class T&gt;
void SList&lt;T&gt;::SListPushFront(T x)
{
	Node&lt;T&gt;* newnode = BuySListNode(x);
	if (head == tail)//头节点后没有节点
	{
		head-&gt;next = newnode;
		newnode-&gt;prev = head;
		tail = newnode;
		tail-&gt;next = head;
		head-&gt;prev = tail;
	}
	else
	{
		newnode-&gt;next = head-&gt;next;
		newnode-&gt;prev = head;
		head-&gt;next = newnode;
	}
}

template &lt;class T&gt;
void SList&lt;T&gt;::SListPopBack()
{
	assert(head-&gt;next);

	Node&lt;T&gt;* cur = tail-&gt;prev;
	head-&gt;prev = tail-&gt;prev;
	delete tail;
	tail = cur;
	tail-&gt;next = head;
	
}


template &lt;class T&gt;
void SList&lt;T&gt;::SListPopFront()
{
	assert(head-&gt;next);//只剩头节点不删
	Node&lt;T&gt;* cur = head-&gt;next;

	if (head-&gt;next == tail)//头节点后只有一个节点
	{
		delete tail;
		tail = head;
		head-&gt;next = head;
		head-&gt;prev = head;
	}
	else
	{
		head-&gt;next = cur-&gt;next;
		cur-&gt;next-&gt;prev = head;
		delete cur;
	}
}

template &lt;class T&gt;
Node&lt;T&gt;* SList&lt;T&gt;::SListFind(T x)
{
	assert(head-&gt;next);
	Node&lt;T&gt;* cur = head-&gt;next;
	while (cur != head)
	{
		if (cur-&gt;data == x)
		{
			return cur;
		}
		cur = cur-&gt;next;
	}
	return nullptr;
}

template &lt;class T&gt;
void SList&lt;T&gt;::SListInsertAfter(Node&lt;T&gt;* pos, T x)
{
	assert(pos);
	if (pos-&gt;next == head)
	{
		SListPushBack(x);
	}
	else if (pos == head)
	{
		SListPushFront(x);
	}
	else
	{
		Node&lt;T&gt;* newnode = BuySListNode(x);
		newnode-&gt;next = pos-&gt;next;
		newnode-&gt;prev = pos;
		pos-&gt;next = newnode;
	}
}


template &lt;class T&gt;
void SList&lt;T&gt;::SListEraseAfter(Node&lt;T&gt;* pos)
{
	assert(pos);
	if (pos-&gt;next == head)//尾节点后的头节点不删
	{
		exit(-1);
	}
	else if (pos == head)
	{
		SListPopFront();
	}
	else
	{
		Node&lt;T&gt;* cur = pos-&gt;next;
		pos-&gt;next = pos-&gt;next-&gt;next;
		pos-&gt;next-&gt;prev = pos;
		delete cur;
	}
}


int main()
{
	//SListNode&lt;int&gt;* head = new SListNode&lt;int&gt;;

	SList&lt;int&gt; SL1;
	SL1.SListPushBack(1);
	SL1.SListPushBack(2);
	SL1.SListPushBack(3);
	SL1.SListPushBack(4);
	SL1.SListPushBack(5);
	SL1.SListPrint();

	SL1.SListPushFront(10);
	SL1.SListPrint();

	SL1.SListPopFront();
	SL1.SListPrint();

	SL1.SListPopBack();
	SL1.SListPrint();

	Node&lt;int&gt;* cur = SL1.SListFind(2);
	SL1.SListInsertAfter(cur, 20);
	SL1.SListPrint();

	SL1.SListEraseAfter(cur);
	SL1.SListPrint();

	return 0;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3e6aac0d6b69cd02f96c558e49fee5d3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android WebView 开发通过 chrome://inspect 调试页面设置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/807032d133299062c1a3dc7f8c10df2d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">IDEA运行第一个Java简单程序（新建项目到运行类）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>