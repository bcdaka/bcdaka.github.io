<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>路径规划 | 图解A*、Dijkstra、GBFS算法的异同(附C&#43;&#43;/Python/Matlab仿真) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/a9225649407fb57cf1a9cb0c97681360/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="路径规划 | 图解A*、Dijkstra、GBFS算法的异同(附C&#43;&#43;/Python/Matlab仿真)">
  <meta property="og:description" content="目录 0 专栏介绍1 栅格地图与邻域2 贪婪最佳优先搜索3 Dijkstra算法4 启发式A*搜索5 A*、Dijkstra、GBFS算法的异同6 算法仿真与实现6.1 算法流程6.2 ROS C&#43;&#43;实现6.3 Python实现6.4 Matlab实现 0 专栏介绍 🔥附C&#43;&#43;/Python/Matlab全套代码🔥课程设计、毕业设计、创新竞赛必备！详细介绍全局规划(图搜索、采样法、智能算法等)；局部规划(DWA、APF等)；曲线优化(贝塞尔曲线、B样条曲线等)。
🚀详情：图解自动驾驶中的运动规划(Motion Planning)，附几十种规划算法
1 栅格地图与邻域 搜索(Search)是指从初始状态(节点)出发寻找一组能达到目标的行动序列(或称问题的解)的过程。
在图搜索中，往往将环境简化为栅格地图(Grid Map)，易于刻画固定场景，同时也便于计算机控制系统进行信息处理。所谓栅格就是将连续地图用固定大小正方形方格进行离散化的单位。
在栅格地图中，常见的邻域(neighbor)模式如下所示，即
8邻域24邻域48邻域 栅格的邻域表示了从当前位置出发下一次搜索的集合，例如八邻域法中，当前栅格只能和周围的八个栅格相连形成局部路径。
下面是一个图搜索问题的例子，可以直观理解什么是搜索问题。
例1：在如下的栅格地图中，设绿色栅格为起点，红色栅格为终点，灰色栅格为障碍，白色栅格为可行点，问如何设计一条由栅格组成的连接起点、终点的路径，并尽可能使路径最短？
接下来，围绕这个问题展开阐述。
2 贪婪最佳优先搜索 一个朴素的想法是：每一次搜索时就找那些与终点最近的节点，这里衡量最近可以用多种度量方式——曼哈顿距离、欧式距离等。这种方法像一头狼贪婪地望着食物，迫切寻求最近的路径，因此称为贪婪最佳优先搜索(Greedy Best First Search, GBFS)。
假设采用八邻域法，在GBFS思想指导下，在起点的八邻域中就会选择最右侧的节点，如下所示。
循环地，直到如下所示的节点，因为邻域内有障碍，这些障碍节点不会被候选，所以此时离终点最近的就是下方的方格
依次类推直至终点
3 Dijkstra算法 Dijkstra算法走向了另一个极端，它完全不考虑扩展节点与终点的关系，而是定义了一个路径耗散函数 g ( n ) g(n) g(n)，从起点开始，机器人每走一个栅格就会产生一定的代价或耗散，因为Dijkstra算法希望路径最短，所以每次首选那些使路径耗散最小的节点。
依照Dijkstra算法的观点，从起点开始，其八个邻域节点都会被依次探索，因为它们离起点最近，接着再探索这些节点的子节点。
因此Dijkstra算法会遍历大量的节点，一圈圈地逼近终点
4 启发式A*搜索 A*算法是非常有效且常用的路径规划算法之一，其是结合Dijsktra算法与GBFS各自优势的启发式搜索算法，其搜索代价评估函数为
f ( n ) = g ( n ) &#43; h ( n ) f(n)=g(n)&#43;h(n) f(n)=g(n)&#43;h(n)">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-19T22:24:36+08:00">
    <meta property="article:modified_time" content="2024-05-19T22:24:36+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">路径规划 | 图解A*、Dijkstra、GBFS算法的异同(附C&#43;&#43;/Python/Matlab仿真)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#0__5" rel="nofollow">0 专栏介绍</a></li><li><a href="#1__12" rel="nofollow">1 栅格地图与邻域</a></li><li><a href="#2__37" rel="nofollow">2 贪婪最佳优先搜索</a></li><li><a href="#3_Dijkstra_52" rel="nofollow">3 Dijkstra算法</a></li><li><a href="#4_A_63" rel="nofollow">4 启发式A*搜索</a></li><li><a href="#5_ADijkstraGBFS_75" rel="nofollow">5 A*、Dijkstra、GBFS算法的异同</a></li><li><a href="#6__85" rel="nofollow">6 算法仿真与实现</a></li><li><ul><li><a href="#61__86" rel="nofollow">6.1 算法流程</a></li><li><a href="#62_ROS_C_90" rel="nofollow">6.2 ROS C++实现</a></li><li><a href="#63_Python_174" rel="nofollow">6.3 Python实现</a></li><li><a href="#64_Matlab_219" rel="nofollow">6.4 Matlab实现</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="0__5"></a>0 专栏介绍</h2> 
<p>🔥附C++/Python/Matlab全套代码🔥课程设计、毕业设计、创新竞赛必备！详细介绍全局规划(图搜索、采样法、智能算法等)；局部规划(DWA、APF等)；曲线优化(贝塞尔曲线、B样条曲线等)。</p> 
<p>🚀详情：<a href="https://mr-winter.blog.csdn.net/article/details/128738977" rel="nofollow">图解自动驾驶中的运动规划(Motion Planning)，附几十种规划算法</a></p> 
<hr color="#FFF" size='1"'> 
<h2><a id="1__12"></a>1 栅格地图与邻域</h2> 
<p><font color="#4a86e8"><strong>搜索(Search)</strong></font>是指从初始状态(节点)出发寻找一组能达到目标的行动序列(或称问题的解)的过程。</p> 
<p>在图搜索中，往往将环境简化为<font color="#4a86e8"><strong>栅格地图(Grid Map)</strong></font>，易于刻画固定场景，同时也便于计算机控制系统进行信息处理。所谓栅格就是将连续地图用固定大小正方形方格进行离散化的单位。</p> 
<p>在栅格地图中，常见的<font color="#4a86e8"><strong>邻域(neighbor)</strong></font>模式如下所示，即</p> 
<ul><li>8邻域</li><li>24邻域</li><li>48邻域</li></ul> 
<p>栅格的邻域表示了<font color="#f00"><strong>从当前位置出发下一次搜索的集合</strong></font>，例如八邻域法中，当前栅格只能和周围的八个栅格相连形成局部路径。</p> 
<p><img src="https://images2.imgbox.com/bd/e9/jyb31ffT_o.png" alt="在这里插入图片描述" width="650"></p> 
<p>下面是一个图搜索问题的例子，可以直观理解什么是搜索问题。</p> 
<blockquote> 
 <p><strong>例1</strong>：在如下的栅格地图中，设绿色栅格为起点，红色栅格为终点，灰色栅格为障碍，白色栅格为可行点，问如何设计一条由栅格组成的连接起点、终点的路径，并尽可能使路径最短？</p> 
</blockquote> 
<p>接下来，围绕这个问题展开阐述。</p> 
<p><img src="https://images2.imgbox.com/52/5c/CHXdjBlU_o.png" alt="在这里插入图片描述" width="650"></p> 
<h2><a id="2__37"></a>2 贪婪最佳优先搜索</h2> 
<p>一个朴素的想法是：<strong>每一次搜索时就找那些与终点最近的节点</strong>，这里衡量<font color="#f00"><strong>最近</strong></font>可以用多种度量方式——曼哈顿距离、欧式距离等。这种方法像一头狼贪婪地望着食物，迫切寻求最近的路径，因此称为<font color="#4a86e8"><strong>贪婪最佳优先搜索(Greedy Best First Search, GBFS)</strong></font>。</p> 
<p>假设采用八邻域法，在GBFS思想指导下，在起点的八邻域中就会选择最右侧的节点，如下所示。</p> 
<p><img src="https://images2.imgbox.com/78/68/vd0iePXo_o.png" alt="在这里插入图片描述" width="650"><br> 循环地，直到如下所示的节点，因为邻域内有障碍，这些障碍节点不会被候选，所以此时离终点最近的就是下方的方格</p> 
<p><img src="https://images2.imgbox.com/2e/8f/LMKIKizT_o.png" alt="在这里插入图片描述" width="650"></p> 
<p>依次类推直至终点</p> 
<h2><a id="3_Dijkstra_52"></a>3 Dijkstra算法</h2> 
<p><font color="#4a86e8"><strong>Dijkstra算法</strong></font>走向了另一个极端，它完全不考虑扩展节点与终点的关系，而是定义了一个<font color="#4a86e8"><strong>路径耗散函数<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           g 
          
         
           ( 
          
         
           n 
          
         
           ) 
          
         
        
          g(n) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></strong></font>，从起点开始，机器人每走一个栅格就会产生一定的代价或耗散，因为Dijkstra算法希望路径最短，所以每次首选那些使路径耗散最小的节点。</p> 
<p>依照Dijkstra算法的观点，从起点开始，其八个邻域节点都会被依次探索，因为它们离起点最近，接着再探索这些节点的子节点。</p> 
<p><img src="https://images2.imgbox.com/33/5f/9laPpt0S_o.png" alt="在这里插入图片描述" width="650"><br> 因此Dijkstra算法会遍历大量的节点，一圈圈地逼近终点</p> 
<p><img src="https://images2.imgbox.com/96/a0/m20FMTkS_o.png" alt="在这里插入图片描述" width="650"></p> 
<h2><a id="4_A_63"></a>4 启发式A*搜索</h2> 
<p><font color="#4a86e8"><strong>A*算法</strong></font>是非常有效且常用的路径规划算法之一，其是结合Dijsktra算法与GBFS各自优势的启发式搜索算法，其搜索代价评估函数为</p> 
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          f 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          = 
         
        
          g 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          + 
         
        
          h 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
       
         f(n)=g(n)+h(n) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></span></p> 
<p>其中<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         g 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
      
        g(n) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>代表路径耗散，是Dijsktra算法分量；<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         h 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
      
        h(n) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>代表下一个搜索节点与终点的距离，启发式地引导机器人朝着终点拓展，是GBFS算法分量。</p> 
<p><img src="https://images2.imgbox.com/46/40/PsJ5BsQ7_o.png" alt="在这里插入图片描述" width="650"><br> 兼具两个算法特点的A*算法既保持完备性，又在一定条件下体现出最优性，被广泛应用于路径规划中。</p> 
<h2><a id="5_ADijkstraGBFS_75"></a>5 A*、Dijkstra、GBFS算法的异同</h2> 
<p>特别地</p> 
<ul><li>当<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          g 
         
         
         
           ( 
          
         
           n 
          
         
           ) 
          
         
        
          = 
         
        
          0 
         
        
       
         g\left( n \right) =0 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathnormal">n</span><span class="mclose delimcenter" style="top: 0em;">)</span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">0</span></span></span></span></span>时，启发函数影响占据主导，A*算法退化为GBFS算法——完全不考虑状态空间本身的固有属性，不择手段地追求对目标的趋近，此时算法搜索效率将得到提升，但最优性无法保证；</li><li>当<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          h 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          = 
         
        
          0 
         
        
       
         h(n)=0 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">0</span></span></span></span></span>时，路径耗散函数影响占据主导，A*算法退化为Dijsktra算法——无先验信息搜索，此时算法搜索效率下降，但最优性上升。</li></ul> 
<p>三个算法的直观比较如下所示</p> 
<p><img src="https://images2.imgbox.com/78/26/2VCBpJSg_o.png" alt="在这里插入图片描述" width="650"></p> 
<h2><a id="6__85"></a>6 算法仿真与实现</h2> 
<h3><a id="61__86"></a>6.1 算法流程</h3> 
<p><img src="https://images2.imgbox.com/5a/01/FRTRS5Vp_o.png" alt="在这里插入图片描述" width="650"></p> 
<h3><a id="62_ROS_C_90"></a>6.2 ROS C++实现</h3> 
<p>核心代码如下</p> 
<pre><code class="prism language-cpp">std<span class="token double-colon punctuation">::</span>tuple<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>Node<span class="token operator">&gt;&gt;</span> <span class="token class-name">AStar</span><span class="token double-colon punctuation">::</span><span class="token function">plan</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span> costs<span class="token punctuation">,</span> <span class="token keyword">const</span> Node<span class="token operator">&amp;</span> start<span class="token punctuation">,</span>
                                                  <span class="token keyword">const</span> Node<span class="token operator">&amp;</span> goal<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>Node<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>expand<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// open list</span>
    std<span class="token double-colon punctuation">::</span>priority_queue<span class="token operator">&lt;</span>Node<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>Node<span class="token operator">&gt;</span><span class="token punctuation">,</span> compare_cost<span class="token operator">&gt;</span> open_list<span class="token punctuation">;</span>
    open_list<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// closed list</span>
    std<span class="token double-colon punctuation">::</span>unordered_set<span class="token operator">&lt;</span>Node<span class="token punctuation">,</span> NodeIdAsHash<span class="token punctuation">,</span> compare_coordinates<span class="token operator">&gt;</span> closed_list<span class="token punctuation">;</span>

    <span class="token comment">// expand list</span>
    expand<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    expand<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// get all possible motions</span>
    <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>Node<span class="token operator">&gt;</span> motion <span class="token operator">=</span> <span class="token function">getMotion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// main loop</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>open_list<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// pop current node from open list</span>
      Node current <span class="token operator">=</span> open_list<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      open_list<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      current<span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-&gt;</span><span class="token function">grid2Index</span><span class="token punctuation">(</span>current<span class="token punctuation">.</span>x<span class="token punctuation">,</span> current<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
      
      <span class="token comment">// current node do not exist in closed list</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>closed_list<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span> <span class="token operator">!=</span> closed_list<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">continue</span><span class="token punctuation">;</span>

      <span class="token comment">// goal found</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>current<span class="token operator">==</span>goal<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        closed_list<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-&gt;</span><span class="token function">_convertClosedListToPath</span><span class="token punctuation">(</span>closed_list<span class="token punctuation">,</span> start<span class="token punctuation">,</span> goal<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      <span class="token comment">// explore neighbor of current node</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> m <span class="token operator">:</span> motion<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        Node new_point <span class="token operator">=</span> current <span class="token operator">+</span> m<span class="token punctuation">;</span>

        <span class="token comment">// current node do not exist in closed list</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>closed_list<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>new_point<span class="token punctuation">)</span> <span class="token operator">!=</span> closed_list<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
          <span class="token keyword">continue</span><span class="token punctuation">;</span>

        <span class="token comment">// explore a new node</span>
        new_point<span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-&gt;</span><span class="token function">grid2Index</span><span class="token punctuation">(</span>new_point<span class="token punctuation">.</span>x<span class="token punctuation">,</span> new_point<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
        new_point<span class="token punctuation">.</span>pid <span class="token operator">=</span> current<span class="token punctuation">.</span>id<span class="token punctuation">;</span>

        <span class="token comment">// if using dijkstra implementation, do not consider heuristics cost</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token operator">-&gt;</span>is_dijkstra_<span class="token punctuation">)</span>
          new_point<span class="token punctuation">.</span>h_cost <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">sqrt</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">pow</span><span class="token punctuation">(</span>new_point<span class="token punctuation">.</span>x <span class="token operator">-</span> goal<span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
                              <span class="token operator">+</span> std<span class="token double-colon punctuation">::</span><span class="token function">pow</span><span class="token punctuation">(</span>new_point<span class="token punctuation">.</span>y <span class="token operator">-</span> goal<span class="token punctuation">.</span>y<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// if using GBFS implementation, only consider heuristics cost</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-&gt;</span>is_gbfs_<span class="token punctuation">)</span>
          new_point<span class="token punctuation">.</span>cost <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        
        <span class="token comment">// goal found</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>new_point<span class="token operator">==</span>goal<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          open_list<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>new_point<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// bext node hit the boundary or obstacle</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>new_point<span class="token punctuation">.</span>id <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> new_point<span class="token punctuation">.</span>id <span class="token operator">&gt;=</span> <span class="token keyword">this</span><span class="token operator">-&gt;</span>ns_ <span class="token operator">||</span> 
            costs<span class="token punctuation">[</span>new_point<span class="token punctuation">.</span>id<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> <span class="token keyword">this</span><span class="token operator">-&gt;</span>lethal_cost_ <span class="token operator">*</span> <span class="token keyword">this</span><span class="token operator">-&gt;</span>factor_<span class="token punctuation">)</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>

        open_list<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>new_point<span class="token punctuation">)</span><span class="token punctuation">;</span>
        expand<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>new_point<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      closed_list<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/0f/05/ZaSzpfZm_o.gif" alt="在这里插入图片描述" width="650"></p> 
<h3><a id="63_Python_174"></a>6.3 Python实现</h3> 
<p>核心代码如下</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">plan</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
     <span class="token comment"># OPEN set with priority and CLOSED set</span>
     OPEN <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
     heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>OPEN<span class="token punctuation">,</span> self<span class="token punctuation">.</span>start<span class="token punctuation">)</span>
     CLOSED <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

     <span class="token keyword">while</span> OPEN<span class="token punctuation">:</span>
         node <span class="token operator">=</span> heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>OPEN<span class="token punctuation">)</span>

         <span class="token comment"># exists in CLOSED set</span>
         <span class="token keyword">if</span> node <span class="token keyword">in</span> CLOSED<span class="token punctuation">:</span>
             <span class="token keyword">continue</span>

         <span class="token comment"># goal found</span>
         <span class="token keyword">if</span> node <span class="token operator">==</span> self<span class="token punctuation">.</span>goal<span class="token punctuation">:</span>
             CLOSED<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
             <span class="token keyword">return</span> self<span class="token punctuation">.</span>extractPath<span class="token punctuation">(</span>CLOSED<span class="token punctuation">)</span><span class="token punctuation">,</span> CLOSED

         <span class="token keyword">for</span> node_n <span class="token keyword">in</span> self<span class="token punctuation">.</span>getNeighbor<span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>                
             <span class="token comment"># exists in CLOSED set</span>
             <span class="token keyword">if</span> node_n <span class="token keyword">in</span> CLOSED<span class="token punctuation">:</span>
                 <span class="token keyword">continue</span>
             
             node_n<span class="token punctuation">.</span>parent <span class="token operator">=</span> node<span class="token punctuation">.</span>current
             node_n<span class="token punctuation">.</span>h <span class="token operator">=</span> self<span class="token punctuation">.</span>h<span class="token punctuation">(</span>node_n<span class="token punctuation">,</span> self<span class="token punctuation">.</span>goal<span class="token punctuation">)</span>

             <span class="token comment"># goal found</span>
             <span class="token keyword">if</span> node_n <span class="token operator">==</span> self<span class="token punctuation">.</span>goal<span class="token punctuation">:</span>
                 heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>OPEN<span class="token punctuation">,</span> node_n<span class="token punctuation">)</span>
                 <span class="token keyword">break</span>
             
             <span class="token comment"># update OPEN set</span>
             heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>OPEN<span class="token punctuation">,</span> node_n<span class="token punctuation">)</span>
         
         CLOSED<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
     <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/77/a2/WYAePVRP_o.png" alt="在这里插入图片描述" width="650"></p> 
<h3><a id="64_Matlab_219"></a>6.4 Matlab实现</h3> 
<p>核心代码如下</p> 
<pre><code class="prism language-matlab"><span class="token keyword">while</span> <span class="token operator">~</span><span class="token function">isempty</span><span class="token punctuation">(</span><span class="token function">OPEN</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment">% pop</span>
    f <span class="token operator">=</span> <span class="token function">OPEN</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">OPEN</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">[</span><span class="token operator">~</span><span class="token punctuation">,</span> index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cur_node <span class="token operator">=</span> <span class="token function">OPEN</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> <span class="token operator">:</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">OPEN</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> <span class="token operator">:</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
    
    <span class="token comment">% exists in CLOSED set</span>
    <span class="token keyword">if</span> <span class="token function">loc_list</span><span class="token punctuation">(</span>cur_node<span class="token punctuation">,</span> CLOSED<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">continue</span>
    <span class="token keyword">end</span>
    
    <span class="token comment">% goal found</span>
    <span class="token keyword">if</span> <span class="token function">cur_node</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">goal</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">cur_node</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">goal</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
        CLOSED <span class="token operator">=</span> <span class="token punctuation">[</span>cur_node<span class="token punctuation">;</span> CLOSED<span class="token punctuation">]</span><span class="token punctuation">;</span>
        flag <span class="token operator">=</span> true<span class="token punctuation">;</span>
        cost <span class="token operator">=</span> <span class="token function">cur_node</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span>
    <span class="token keyword">end</span>
    
    <span class="token comment">% explore neighbors</span>
    <span class="token keyword">for</span> <span class="token number">i</span><span class="token operator">=</span><span class="token number">1</span><span class="token operator">:</span>neighbor_num        
        node_n <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token function">cur_node</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">neighbor</span><span class="token punctuation">(</span><span class="token number">i</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">...</span>
                          <span class="token function">cur_node</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">neighbor</span><span class="token punctuation">(</span><span class="token number">i</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">...</span>
                          <span class="token function">cur_node</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">neighbor</span><span class="token punctuation">(</span><span class="token number">i</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">...</span>
                          <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">cur_node</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cur_node</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
                          <span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token function">node_n</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token function">node_n</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> goal<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">% exists in CLOSED set</span>
        <span class="token keyword">if</span> <span class="token function">loc_list</span><span class="token punctuation">(</span>cur_node<span class="token punctuation">,</span> CLOSED<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">continue</span>
        <span class="token keyword">end</span>
        
        <span class="token comment">% obstacle</span>
        <span class="token keyword">if</span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token function">node_n</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">node_n</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token keyword">end</span>
       
        <span class="token comment">% goal found</span>
        <span class="token keyword">if</span> <span class="token function">cur_node</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">goal</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">cur_node</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">goal</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
            CLOSED <span class="token operator">=</span> <span class="token punctuation">[</span>cur_node<span class="token punctuation">;</span> CLOSED<span class="token punctuation">]</span><span class="token punctuation">;</span>
            flag <span class="token operator">=</span> true<span class="token punctuation">;</span>
            cost <span class="token operator">=</span> <span class="token function">cur_node</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span>
        <span class="token keyword">end</span>
        
        <span class="token comment">% update expand zone</span>
        expand <span class="token operator">=</span> <span class="token punctuation">[</span>expand<span class="token punctuation">;</span> <span class="token function">node_n</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        
        <span class="token comment">% update OPEN set</span>
        OPEN <span class="token operator">=</span> <span class="token punctuation">[</span>OPEN<span class="token punctuation">;</span> node_n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">end</span>
    CLOSED <span class="token operator">=</span> <span class="token punctuation">[</span>cur_node<span class="token punctuation">;</span> CLOSED<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">end</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/7f/9c/yCPl0hTQ_o.png" alt="在这里插入图片描述" width="650"></p> 
<hr color="#FFF" size='1"'> 
<p>🔥 <strong>更多精彩专栏</strong>：</p> 
<ul><li><a href="https://blog.csdn.net/frigidwinter/category_11541346.html">《ROS从入门到精通》</a></li><li><a href="https://blog.csdn.net/frigidwinter/category_11909310.html">《Pytorch深度学习实战》</a></li><li><a href="https://blog.csdn.net/frigidwinter/category_10302228.html">《机器学习强基计划》</a></li><li><a href="https://blog.csdn.net/frigidwinter/category_11410243.html">《运动规划实战精讲》</a></li><li>…</li></ul> 
<br> 
<center>
  👇源码获取 · 技术交流 · 抱团学习 · 咨询分享 请联系👇 
</center>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fd76602b843542b5332280c68c852987/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【数据结构】排序（一）—— 希尔排序（思路演进版）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9d62d15a3d23fa1dc3d2df611c10bf4d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Autodesk AutoCAD 2025 Mac软件安装包下载CAD 2025 Mac安装教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>