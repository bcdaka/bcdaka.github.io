<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>基于扩展卡尔曼滤波的SOC估计（附MATLAB代码） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/5c2d5c5c3eb725e4476cdc0d856fb043/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="基于扩展卡尔曼滤波的SOC估计（附MATLAB代码）">
  <meta property="og:description" content="获取同款资料：2629471989 1.卡尔曼滤波原理 原理可以参考我之前学习的笔记，使用goodnote完成的。
我认为，对于公式的推导不需要做太多深入的了解，我之前也对公式进行推导的理解，但是没过几天就忘了，只需要掌握住那重要的5个步骤即可，能够熟练运用才是王道。
2.扩展卡尔曼滤波的MATLAB代码实现 下面介绍一下如何通过MATLAB，使用扩展卡尔曼滤波完成SOC的估计，我会将代码里面需要修改的地方进行讲解，当你辨识完参数要进行SOC估计时，只需要修改我所说的就能够实现。
2.1 电池参数的修改 Cn=18*3600;%电池容量，单位As delta_t=1;%采样时间 R1=-9.015*socc.^6&#43;20.64*socc.^5-15*socc.^4&#43;2.196*socc.^3&#43;1.747*socc.^2-0.7141*socc&#43;0.09635; R2=38.17*socc.^6-106.5*socc.^5&#43;115.7*socc.^4-61.8*socc.^3&#43;16.93*socc.^2-2.263*socc&#43;0.1285; C1=-6.037e&#43;06*socc.^6&#43;1.697e&#43;07*socc.^5-1.81e&#43;07*socc.^4&#43;9.097e&#43;06*socc.^3-2.189e&#43;06*socc.^2&#43;2.367e&#43;05*socc-7963; C2=1.82e&#43;08*socc.^6-4.243e&#43;08*socc.^5&#43;3.83e&#43;08*socc.^4-1.75e&#43;08*socc.^3&#43;4.456e&#43;07*socc.^2-5.862e&#43;06*socc&#43;3.205e&#43;05; ro=0.05;%电池内阻 Cn就是电池容量，你自己的电池容量是多少就写多少，18代表时间Ah，注意单位是Ah。
采样时间可以不用改，；
R1：就写拟合得到的R1与SOC的多项式，也可以是常数；
R2：就写拟合得到的R2与SOC的多项式，也可以是常数；
C1：就写拟合得到的C1与SOC的多项式，也可以是常数；
C2：就写拟合得到的C2与SOC的多项式，也可以是常数；
R0：就写拟合得到的R0与SOC的多项式，也可以是常数；
2.2 电流数据以及SOC-OCV曲线 i=I1; i(1)=0;%放电电流矩阵 fn=@(x) -189.5*x^6&#43;696.7*x^5-1007*x^4&#43;727.8*x^3-275.4*x^2&#43;51.63*x&#43;9.562;%拟合soc-ocv表达式 syms t1; g=fn(t1); g=matlabFunction(diff(g));%fn对soc的偏导 A=[1 0 0;0 rp1*cp1/(delta_t&#43;rp1*cp1) 0;0 0 rp2*cp2/(delta_t&#43;rp2*cp2)]; B=[-delta_t/Cn;delta_t*rp1/(delta_t&#43;rp1*cp1);delta_t*rp2/(delta_t&#43;rp2*cp2)];%A，B矩阵 t=0:delta_t:14000;%仿真序列时间 电流要导入自己的电流数据；
要注意仿真序列时间不要超过电流数据的长度；
3.扩展卡尔曼算法迭代 Xekf=zeros(size);%EKF下的状态变量 P0=eye(3);%协方差矩阵初值 Xekf(:,1)=[1;0;0];%EKF状态变量初值，可更改 for k=2:N Xn=A*Xekf(:,k-1)&#43;B*i(k);%计算先验估计 P1=A*P0*A&#39;&#43;Q;%更新协方差矩阵 dd=Xn(1)-Soc(k);%计算先验估计值与真值的差 Zm=g(Soc(k))*dd&#43;fn(Soc(k))-Xn(2)-Xn(3)-i(k)*ro;%计算观测值 H=[g(Xn(1)) 0 0];%雅克比矩阵计算 K=P1*H&#39;*inv(H*P1*H&#39;&#43;R);%计算卡尔曼增益 Xekf(:,k)=Xn&#43;K*(Uoc(k)-Zm);%更新状态 P0=(eye(3)-K*H)*P1;%更新协方差方程 end Socekf=zeros(1,N);%Ekf下的soc Uocekf=zeros(1,N);%Ekf下的端电压 Eekf=zeros(1,N);%EKF下的电池电压 for k=1:N Socekf(k)=Xekf(1,k); Eekf(k)=fn(Socekf(k)); Uocekf(k)=fn(Socekf(k))-i(k)*ro-Xekf(2,k)-Xekf(3,k); end%计算三个值 完整代码点赞评论关注后吗，私信我获取。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-02T10:39:20+08:00">
    <meta property="article:modified_time" content="2024-08-02T10:39:20+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">基于扩展卡尔曼滤波的SOC估计（附MATLAB代码）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="text-align:center;"><strong><span style="color:#fe2c24;">获取同款资料：2629471989</span></strong></h2> 
<p></p> 
<h2>1.卡尔曼滤波原理</h2> 
<p>原理可以参考我之前学习的笔记，使用goodnote完成的。</p> 
<p style="text-align:center;"><img alt="1a35d0bda64b411daa995c9e2d3b52cc.jpeg" src="https://images2.imgbox.com/ed/fa/YwbmrniW_o.jpg"></p> 
<p style="text-align:center;"> <img alt="36f32539a97d46e6a74389951a4b614e.png" src="https://images2.imgbox.com/46/5d/06mOVgOR_o.jpg"></p> 
<p style="text-align:center;"> <img alt="0b9d553f214143aab1db5dca7d205083.png" src="https://images2.imgbox.com/3b/51/ONQ5DomP_o.jpg"></p> 
<p style="text-align:center;"> <img alt="322de353403f4ee38117304d19859099.png" src="https://images2.imgbox.com/a3/63/QrEv7rC7_o.jpg"></p> 
<p style="text-align:center;"> <img alt="31f1c8ffdcec429ba0fa8e7179f683d3.png" src="https://images2.imgbox.com/4f/6d/78KMyb9x_o.jpg"></p> 
<p style="text-align:center;"> <img alt="c51e50adb9084eb2a31dc8b1a2cf9d0b.png" src="https://images2.imgbox.com/2f/0c/FazdByVh_o.jpg"></p> 
<p style="text-align:center;"> <img alt="349326f7390240118e1601036623021e.png" src="https://images2.imgbox.com/be/61/FTZ51krf_o.jpg"></p> 
<p> 我认为，对于公式的推导不需要做太多深入的了解，我之前也对公式进行推导的理解，但是没过几天就忘了，只需要掌握住那重要的5个步骤即可，能够熟练运用才是王道。</p> 
<h2>2.扩展卡尔曼滤波的MATLAB代码实现</h2> 
<p>下面介绍一下如何通过MATLAB，使用扩展卡尔曼滤波完成SOC的估计，我会将代码里面需要修改的地方进行讲解，当你辨识完参数要进行SOC估计时，只需要修改我所说的就能够实现。</p> 
<h3>2.1 电池参数的修改</h3> 
<pre><code class="language-python">Cn=18*3600;%电池容量，单位As
delta_t=1;%采样时间
R1=-9.015*socc.^6+20.64*socc.^5-15*socc.^4+2.196*socc.^3+1.747*socc.^2-0.7141*socc+0.09635;
R2=38.17*socc.^6-106.5*socc.^5+115.7*socc.^4-61.8*socc.^3+16.93*socc.^2-2.263*socc+0.1285;
C1=-6.037e+06*socc.^6+1.697e+07*socc.^5-1.81e+07*socc.^4+9.097e+06*socc.^3-2.189e+06*socc.^2+2.367e+05*socc-7963;
C2=1.82e+08*socc.^6-4.243e+08*socc.^5+3.83e+08*socc.^4-1.75e+08*socc.^3+4.456e+07*socc.^2-5.862e+06*socc+3.205e+05;
ro=0.05;%电池内阻
</code></pre> 
<p>Cn就是电池容量，你自己的电池容量是多少就写多少，18代表时间Ah，注意单位是Ah。</p> 
<p>采样时间可以不用改，；</p> 
<p>R1：就写拟合得到的R1与SOC的多项式，也可以是常数；</p> 
<p>R2：就写拟合得到的R2与SOC的多项式，也可以是常数；</p> 
<p>C1：就写拟合得到的C1与SOC的多项式，也可以是常数；</p> 
<p>C2：就写拟合得到的C2与SOC的多项式，也可以是常数；</p> 
<p>R0：就写拟合得到的R0与SOC的多项式，也可以是常数；</p> 
<h3>2.2 电流数据以及SOC-OCV曲线</h3> 
<pre><code class="language-bash">i=I1;
i(1)=0;%放电电流矩阵
fn=@(x) -189.5*x^6+696.7*x^5-1007*x^4+727.8*x^3-275.4*x^2+51.63*x+9.562;%拟合soc-ocv表达式
syms t1;
g=fn(t1);
g=matlabFunction(diff(g));%fn对soc的偏导
 
A=[1 0 0;0 rp1*cp1/(delta_t+rp1*cp1) 0;0 0 rp2*cp2/(delta_t+rp2*cp2)];
B=[-delta_t/Cn;delta_t*rp1/(delta_t+rp1*cp1);delta_t*rp2/(delta_t+rp2*cp2)];%A，B矩阵
t=0:delta_t:14000;%仿真序列时间</code></pre> 
<p>电流要导入自己的电流数据；</p> 
<p>要注意仿真序列时间不要超过电流数据的长度；</p> 
<h3>3.扩展卡尔曼算法迭代</h3> 
<pre><code class="language-bash">Xekf=zeros(size);%EKF下的状态变量
P0=eye(3);%协方差矩阵初值
Xekf(:,1)=[1;0;0];%EKF状态变量初值，可更改
 
for k=2:N
    Xn=A*Xekf(:,k-1)+B*i(k);%计算先验估计
    P1=A*P0*A'+Q;%更新协方差矩阵
    dd=Xn(1)-Soc(k);%计算先验估计值与真值的差
    Zm=g(Soc(k))*dd+fn(Soc(k))-Xn(2)-Xn(3)-i(k)*ro;%计算观测值
    H=[g(Xn(1)) 0 0];%雅克比矩阵计算
    K=P1*H'*inv(H*P1*H'+R);%计算卡尔曼增益
    Xekf(:,k)=Xn+K*(Uoc(k)-Zm);%更新状态
    P0=(eye(3)-K*H)*P1;%更新协方差方程
end
 
Socekf=zeros(1,N);%Ekf下的soc
Uocekf=zeros(1,N);%Ekf下的端电压
Eekf=zeros(1,N);%EKF下的电池电压
 
for k=1:N
    Socekf(k)=Xekf(1,k);
    Eekf(k)=fn(Socekf(k));
    Uocekf(k)=fn(Socekf(k))-i(k)*ro-Xekf(2,k)-Xekf(3,k);
end%计算三个值</code></pre> 
<p>完整代码点赞评论关注后吗，私信我获取。</p> 
<h2>3.结果验证</h2> 
<h3>3.1 端电压对比</h3> 
<p>真实端电压与估计出的端电压的对比图如下：红色的线是扩展卡尔曼滤波估算的端电压误差。</p> 
<p><img alt="009cc9ce85c24ac0947b6b1a8453a42a.png" src="https://images2.imgbox.com/e4/1c/eGjUuFKC_o.png"></p> 
<h3> 3.2 SOC对比</h3> 
<p>          真实SOC与估计出的SOC的对比图以及误差图如下：红色的线是扩展卡尔曼滤波估算的SOC。最大误差小于0.7%，具有较高精度。</p> 
<p><img alt="b14b32f562c84e5f977146113cced2d2.png" src="https://images2.imgbox.com/02/84/iVonrD7a_o.png"></p> 
<p></p> 
<p><img alt="141bea42afa142248d929445855bcadc.png" src="https://images2.imgbox.com/72/da/Ks6YaQJc_o.png"></p> 
<p>             这期就写到这里，下一期讲一下如何使用无迹卡尔曼滤波估计SOC以及如何在simulink中实现。拜拜。</p> 
<p>           还没完，刚入门电池管理SOC估计这块的福利来啦，下面是我硕博期间编写以及搜集到的有关SOC估计的程序、模型、电池测试数据共110多个文件，需要学习的小伙伴们找我拿呀！！！！</p> 
<p>硕博期间所有的程序代码，一共2个多g，可以给你指导，赠送半个小时的语音电话答疑。电池数据+辨识程序+各种卡尔曼滤波算法都在里面了，后续还会有新模型的更新。快速入门BMS软件。某鹅：2629471989</p> 
<p><img alt="" height="585" src="https://images2.imgbox.com/97/6f/F7lDcDfh_o.png" width="833"></p> 
<p><img alt="cdec4ed1ff0342ceaba98664042d50aa.png" src="https://images2.imgbox.com/fb/b2/HtKkBzzC_o.png"></p> 
<p><img alt="d9794fcb60d74bac8f71048cd1fddd26.png" src="https://images2.imgbox.com/d5/b6/4koOvAzq_o.png"></p> 
<p><img alt="f2aca6be4bce444dafec5b9319b4c8df.png" src="https://images2.imgbox.com/e1/6e/2h4fHp9X_o.png"></p> 
<p><img alt="5ce8a48ead684738b0a3c6a71cbd50af.png" src="https://images2.imgbox.com/4e/4a/nqYLtEAe_o.png"></p> 
<p><img alt="031c14ba625c4df4a6e74ef6edec8b1a.png" src="https://images2.imgbox.com/95/96/SVGpttvA_o.png"></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4bc6510005bdd50ad895ccbe6adc857b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">什么是接口？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2d772498708a6efd04be0693b4695639/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">第三届Apache Flink 极客挑战赛暨AAIG CUP比赛攻略_大浪813团队</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>