<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>大数据机器学习：常见模型评估指标 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b27c654fcf1dda4d758adc006cd48226/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="大数据机器学习：常见模型评估指标">
  <meta property="og:description" content="大数据机器学习：常见模型评估指标 一.模型评估综述 1.1 什么是模型评估 模型评估是指在机器学习中，对于一个具体方法输出的最终模型，使用一些指标和方法来评估它的泛化能力。这一步通常在模型训练和模型选择之后，正式部署模型之前进行。模型评估不针对模型本身，而是针对问题和数据，因此可以用来评价不同方法的模型的泛化能力，以此决定最终模型的选择。
1.2 评估类型 机器学习的基本任务大致分为三类，分别是分类(Classification)、回归(Regression)和聚类(Clustering)，在本文仅介绍分类的模型评估。
1.3 模型泛化能力 模型的泛化能力是机器学习的一个重要概念和指标。是指一个模型在训练集之外的未知数据上的表现能力，泛化能力强的模型能够正确学习到数据的普遍规律并将其运用到新的数据上从而做出准确的预测。
简单地说，当模型在训练样本上表现良好，并且能在新的数据样本上保持相同的表现，我们就可以说这个模型的泛化能力强。
1.4 过拟合与欠拟合 过拟合与欠拟合是机器学习中常见的两个概念，描述的是模型在训练数据和未知数据上表现的差异。下图中第一到第三的图分别是欠拟合、正好和过拟合三种状态。
1.4.1 过拟合 过拟合表现为在训练数据上表现优秀的那在新数据集上表现较差，通常是因为模型过于复杂，学习到了数据集中的细节和噪声而不是数据的真实分布，因而泛化能力差。
举个很经典的例子，当我们设计一个模型用于判断一个物品是否是树叶，而训练集中有几个样本的叶片边缘带有尖刺，模型作者希望他的模型能够符合贴近他的每一个样本，因而将带有“尖刺边缘”这一不是明显特征的特点纳入了参数中，这样一来，模型就能够完美贴合训练样本，但在应用时会发现模型容易钻牛角尖，会将不带尖刺边缘的样本排除，无法识别不带尖刺边缘的树叶，这就导致了模型的泛化能力差。
解决模型过拟合的问题，有以下几种方法：
增加数据量以提供更多信息，减少噪声的影响简化模型，减少模型参数的数量通过交叉验证评估模型的泛化能力 1.4.2欠拟合 欠拟合则与过拟合相反，由于模型过于简单，无法学习到数据的足够特征，无法正确捕捉数据的复杂性和变化，没有学习到数据的规律。这就导致模型不管是在训练样本还是未知样本上的表现都不佳。
常见的解决欠拟合的方法有：
增加模型的复杂度，如增加更多的特征或使用更复杂的模型收集更多的数据，提供更加丰富的信息给模型增加训练时间或者调整模型的超参数 二.常见的分类模型评估方式 2.1 混淆矩阵 混淆矩阵是分类模型巩固的一个重要工具，可以直观展示模型的预测结果和实际结果之间的关系，通常由以下四个部分构成：
真正类 (True Positives, TP): 模型正确地预测正类的数量。假负类 (False Negatives, FN): 模型错误地将正类预测为负类的数量。假正类 (False Positives, FP): 模型错误地将负类预测为正类的数量。真负类 (True Negatives, TN): 模型正确地预测负类的数量。 二元混淆矩阵格式如下：
分类器真实结果Positive（阳性）Negative（阴性）预测结果PositiveTPFPNegativeFNTN 多元分类矩阵格式如下：
分类器真实结果ABCD预测结果ATAFAFAFABFBTBFBFBCFCFCTCFCDFDFDFDTD 2.2 准确率（Accuracy） 准确率是指模型正确预测的样本总数占总样本总数的比例，其计算公式为：
[准确率 = \dfrac{TN&#43;TF}{TN&#43;FN&#43;TP&#43;FP} = \dfrac{T}{T&#43;F} ]
2.3 精确率(Precision) 精确率的概念比较容易与准确率的概念混淆，准确率的目标是所有样本，计算的是所有分类正确样本占总样本的多少，而精确率是指在所有被模型预测为正类的样本中，实际为正类的样本的比例，关注的是被模型分为此类的数据中有多少是正确的。
当我们使用精确率（下使用Precision代替）作为考量时，优点是不容易出现假正类，但是，当precision值过高时，容易出现模型偏向某一类别的情况，因为此时模型会倾向于预测多数类别而忽略了少数类别的预测。
举一个例子，假设在一个疾病诊断问题中，疾病发生的实际情况（正类）非常罕见。如果模型仅仅通过预测大多数人都是健康的（负类）来提高Precision，那么它可能会忽略真正的病例，因为这些病例在数据中占比很小。这样的模型虽然精确度高，但其实用性非常有限，因为它未能有效识别和预测少数但重要的正类样本。
在混淆矩阵中，这表现为某一行的T除以本行上所有数字的和，如下列表格标注了颜色的A行就是红色的TA值除以TA加FA的和。
预测/实际ABCDA(\color{red}{TA})(\color{green}{FA})(\color{green}{FA})(\color{green}{FA})BFBTBFBFBCFCFCTCFCDFDFDFDTD 其公式为：
[Precision = \dfrac{TP}{TP&#43;FP} ]">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-29T12:54:04+08:00">
    <meta property="article:modified_time" content="2024-04-29T12:54:04+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">大数据机器学习：常见模型评估指标</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>大数据机器学习：常见模型评估指标</h2> 
<h2><a id="_2"></a>一.模型评估综述</h2> 
<h3><a id="11__4"></a>1.1 什么是模型评估</h3> 
<p>模型评估是指在机器学习中，对于一个具体方法输出的最终模型，使用一些指标和方法来评估它的泛化能力。这一步通常在模型训练和模型选择之后，正式部署模型之前进行。模型评估不针对模型本身，而是针对问题和数据，因此可以用来评价不同方法的模型的泛化能力，以此决定最终模型的选择。</p> 
<h3><a id="12__8"></a>1.2 评估类型</h3> 
<p>机器学习的基本任务大致分为三类，分别是<em><strong>分类(Classification)</strong></em>、<em><strong>回归(Regression)<em><strong>和</strong></em>聚类(Clustering)</strong></em>，在本文仅介绍分类的模型评估。</p> 
<h3><a id="13__12"></a>1.3 模型泛化能力</h3> 
<p>模型的泛化能力是机器学习的一个重要概念和指标。是指一个模型在训练集之外的未知数据上的表现能力，泛化能力强的模型能够正确学习到数据的<em><strong>普遍规律</strong></em>并将其运用到<em><strong>新的数据</strong></em>上从而做出<em><strong>准确</strong></em>的预测。</p> 
<p>简单地说，当模型在训练样本上表现良好，并且能在新的数据样本上保持相同的表现，我们就可以说这个模型的泛化能力强。</p> 
<h3><a id="14__18"></a>1.4 过拟合与欠拟合</h3> 
<p>过拟合与欠拟合是机器学习中常见的两个概念，描述的是模型在训练数据和未知数据上表现的差异。下图中第一到第三的图分别是欠拟合、正好和过拟合三种状态。</p> 
<p><img src="https://images2.imgbox.com/92/82/0Vt4Fmik_o.jpg" alt="在这里插入图片描述"></p> 
<h4><a id="141__25"></a>1.4.1 过拟合</h4> 
<p>过拟合表现为在训练数据上表现优秀的那在新数据集上表现较差，通常是因为模型过于复杂，学习到了数据集中的细节和噪声而不是数据的真实分布，因而泛化能力差。</p> 
<p>举个很经典的例子，当我们设计一个模型用于判断一个物品是否是树叶，而训练集中有几个样本的叶片边缘带有尖刺，模型作者希望他的模型能够符合贴近他的每一个样本，因而将带有“尖刺边缘”这一不是明显特征的特点纳入了参数中，这样一来，模型就能够完美贴合训练样本，但在应用时会发现模型容易钻牛角尖，会将不带尖刺边缘的样本排除，无法识别不带尖刺边缘的树叶，这就导致了模型的泛化能力差。</p> 
<p>解决模型过拟合的问题，有以下几种方法：</p> 
<ul><li>增加数据量以提供更多信息，减少噪声的影响</li><li>简化模型，减少模型参数的数量</li><li>通过交叉验证评估模型的泛化能力</li></ul> 
<h4><a id="142_37"></a>1.4.2欠拟合</h4> 
<p>欠拟合则与过拟合相反，由于模型过于简单，无法学习到数据的足够特征，无法正确捕捉数据的复杂性和变化，没有学习到数据的规律。这就导致模型不管是在训练样本还是未知样本上的表现都不佳。</p> 
<p>常见的解决欠拟合的方法有：</p> 
<ul><li>增加模型的复杂度，如增加更多的特征或使用更复杂的模型</li><li>收集更多的数据，提供更加丰富的信息给模型</li><li>增加训练时间或者调整模型的超参数</li></ul> 
<h2><a id="_47"></a>二.常见的分类模型评估方式</h2> 
<h3><a id="21__49"></a>2.1 混淆矩阵</h3> 
<p>混淆矩阵是分类模型巩固的一个重要工具，可以直观展示模型的预测结果和实际结果之间的关系，通常由以下四个部分构成：</p> 
<ul><li><strong>真正类 (True Positives, TP)</strong>: 模型正确地预测正类的数量。</li><li><strong>假负类 (False Negatives, FN)</strong>: 模型错误地将正类预测为负类的数量。</li><li><strong>假正类 (False Positives, FP)</strong>: 模型错误地将负类预测为正类的数量。</li><li><strong>真负类 (True Negatives, TN)</strong>: 模型正确地预测负类的数量。</li></ul> 
<p>二元混淆矩阵格式如下：</p> 
<table><thead><tr><th>分类器</th><th>真实结果</th><th></th><th></th></tr></thead><tbody><tr><td>Positive（阳性）</td><td>Negative（阴性）</td><td></td><td></td></tr><tr><td>预测结果</td><td>Positive</td><td>TP</td><td>FP</td></tr><tr><td>Negative</td><td>FN</td><td>TN</td><td></td></tr></tbody></table> 
<p>多元分类矩阵格式如下：</p> 
<table><thead><tr><th>分类器</th><th>真实结果</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>A</td><td>B</td><td>C</td><td>D</td><td></td><td></td></tr><tr><td>预测结果</td><td>A</td><td>TA</td><td>FA</td><td>FA</td><td>FA</td></tr><tr><td>B</td><td>FB</td><td>TB</td><td>FB</td><td>FB</td><td></td></tr><tr><td>C</td><td>FC</td><td>FC</td><td>TC</td><td>FC</td><td></td></tr><tr><td>D</td><td>FD</td><td>FD</td><td>FD</td><td>TD</td><td></td></tr></tbody></table> 
<h3><a id="22_Accuracy_76"></a>2.2 准确率（Accuracy）</h3> 
<p>准确率是指模型正确预测的样本总数占总样本总数的比例，其计算公式为：</p> 
<p>[准确率 = \dfrac{TN+TF}{TN+FN+TP+FP} = \dfrac{T}{T+F} ]</p> 
<h3><a id="23_Precision_86"></a>2.3 精确率(Precision)</h3> 
<p>精确率的概念比较容易与准确率的概念混淆，准确率的目标是所有样本，计算的是所有分类正确样本占总样本的多少，而精确率是指在所有被模型预测为正类的样本中，实际为正类的样本的比例，关注的是被模型分为此类的数据中有多少是正确的。</p> 
<p>当我们使用<em><strong>精确率</strong></em>（下使用<em><strong>Precision</strong></em>代替）作为考量时，优点是不容易出现假正类，但是，当precision值过高时，容易出现模型偏向某一类别的情况，因为此时模型会倾向于预测多数类别而忽略了少数类别的预测。</p> 
<p>举一个例子，假设在一个疾病诊断问题中，疾病发生的实际情况（正类）非常罕见。如果模型仅仅通过预测大多数人都是健康的（负类）来提高Precision，那么它可能会忽略真正的病例，因为这些病例在数据中占比很小。这样的模型虽然精确度高，但其实用性非常有限，因为它未能有效识别和预测少数但重要的正类样本。</p> 
<p>在混淆矩阵中，这表现为<em><strong>某一行</strong></em>的T除以本行上所有数字的和，如下列表格标注了颜色的A行就是红色的TA值除以TA加FA的和。</p> 
<table><thead><tr><th>预测/实际</th><th>A</th><th>B</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>A</td><td>(\color{red}{TA})</td><td>(\color{green}{FA})</td><td>(\color{green}{FA})</td><td>(\color{green}{FA})</td></tr><tr><td>B</td><td>FB</td><td>TB</td><td>FB</td><td>FB</td></tr><tr><td>C</td><td>FC</td><td>FC</td><td>TC</td><td>FC</td></tr><tr><td>D</td><td>FD</td><td>FD</td><td>FD</td><td>TD</td></tr></tbody></table> 
<p>其公式为：</p> 
<p>[Precision = \dfrac{TP}{TP+FP} ]</p> 
<h3><a id="24_Recall_111"></a>2.4 召回率（Recall）</h3> 
<p>召回率（下使用<em><strong>Recall</strong></em>替代）衡量的是模型正确识别为正类的实例（真正类）占所有实际正类实例的比例。当recall值高时，模型会更容易捕捉到正类，但也会导致假正类出现的比例增加的情况。</p> 
<p>举个例子说明，假设我们有一个用于检测信用卡欺诈的模型，其中正类（欺诈）非常罕见。在10,000个交易中，可能只有100个是欺诈性的。如果我们只关注召回率，模型可能会被调整为将更多的交易标记为欺诈，以确保它不会错过那些真正的欺诈案例。例如，模型可能会将1,000个交易标记为欺诈，其中包括所有100个真正的欺诈案例和900个实际上是合法的交易。在这种情况下，召回率是100%，因为所有的欺诈交易都被正确地识别了。然而，这样做的代价是产生了很多假正类（False Positives）—那些被错误标记为欺诈的合法交易。这会导致很多不必要的麻烦，比如客户满意度下降和增加的客户服务成本。</p> 
<p>在混淆矩阵中，这表现为<em><strong>某一列</strong></em>中的T除以本列上左右数字的和，如下列表格,计算recall即红色字体的值除以红色和绿色字体的值的和,计算设计的数据包括正确分类的本类型样本的值和被错误分类至本类型的样本的值。</p> 
<table><thead><tr><th>预测/实际</th><th>A</th><th>B</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>A</td><td>(\color{red}{TA})</td><td>FA</td><td>FA</td><td>FA</td></tr><tr><td>B</td><td>(\color{green}{FB})</td><td>TB</td><td>FB</td><td>FB</td></tr><tr><td>C</td><td>(\color{green}{FC})</td><td>FC</td><td>TC</td><td>FC</td></tr><tr><td>D</td><td>(\color{green}{FD})</td><td>FD</td><td>FD</td><td>TD</td></tr></tbody></table> 
<p>其公式为：</p> 
<p>[Recall = \dfrac{TP}{TP+FN} ]</p> 
<h3><a id="25_F1score_134"></a>2.5 F1-score</h3> 
<p>正如上面所说的，当我们单独地使Precision值或者Recall值增高，都会使模型走向极端，因而我们引入了F1值，即Recall和Precision的<em><strong>调和平均数</strong></em>，，因为F1值综合考虑了Recall和Precision，因而其尤其适合在***数据不平衡（不同类别的样本数据量差异很大）***的情况时进行使用。当分数更高时，说明模型再识别少数类方面的能力更强，同时保持了较高的Recall和Precision平衡。其公式如下：</p> 
<p>[F1 = 2\times \dfrac{Precision\times Recall}{Percision+Recall} ]</p> 
<p>值得一提的是，这是在Recall和Precision的比重相同的同属情况下使用的，如果你认为其中某个值更加重要，你可以使用({\large F}_\beta)-score,其公式为：</p> 
<p>[{\large F}_\beta = (1+\beta ^2)\cdot \dfrac{Precision\cdot Recall}{(\beta^2\cdot Precision)+Recall} ]</p> 
<p>其中的(\beta)是Recall和Precision的比值，当$\beta $大于1时，该分数会给予Recall更高的权重。</p> 
<h3><a id="26_ROCAUC_154"></a>2.6 ROC曲线及AUC值</h3> 
<p>在二分类的过程中，我们通常会设置一个<em><strong>阈值</strong></em>（取值为0到1之间），大于阈值的会被归于正类，小于阈值的会被归为负类，当我们降低阈值时，样本会更容易地被归为正类，但也会更容易出现假正类，反之则更容易出现遗漏的情况，而随着阈值的变化，混淆矩阵也会出现变化，为了直观地体现这种变化，我们引入了ROC曲线。</p> 
<p>在ROC曲线中，x和y轴分别为<em><strong>假阳性率（TPR）<em><strong>和</strong></em>真阳性率（FPR）</strong></em>，其中，假阳性率表示在所有阴性（即Negative）样本中，被错误地预测为阳性（即Positive）的比例，计算公式为：</p> 
<p>[FPR = \dfrac{FP}{FP+TN} ]</p> 
<p>而真阳性率又称召回率，表示所有实际阳性样本被正确预测为阳性的比例，计算公式为：</p> 
<p>[TPR = \dfrac{TP}{TP+FN} ]</p> 
<p>通过ROC曲线，我们可以明确地直观地看出模型的好坏，为了模型准确率更高，我们自然而然地希望真阳性率更高而假阳性率更低，因此，当曲线越靠近左上角，我们会认定这条曲线所代表的模型判断准确率更高，如下图所示</p> 
<p><img src="https://images2.imgbox.com/d6/49/x1DCT5qy_o.jpg" alt="在这里插入图片描述"></p> 
<p>这是通过KNN算法和决策树算法对sklearn库内置的乳腺癌库进行训练预测的ROC曲线结果图，如图所示，由于代表KNN算法的折线更靠近左上角，因而我们可以说在这个数据集上，使用了KNN算法的模型表现更好。</p> 
<p>而***AUC(Area Under the Curve)***值就是指曲线下的面积，当AUC值越接近1，可说明模型的分类性能更好。如下图涂黄的部分就是该曲线的AUC值。</p> 
<p><img src="https://images2.imgbox.com/7f/c8/Dstvp4m7_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="27_PR_186"></a>2.7 PR曲线</h3> 
<p>PR曲线，即精确率-召回率曲线，它是以***召回率（Recall）***为x轴，***精确率（Precision）***为y轴的曲线，在机器学习中，尤其在再不平衡数据集中非常有用。</p> 
<p>当我们在改变模型的分类阈值时，TP、FP和FN等都会发生变化，从而导致Recall和Precision发生变化，PR曲线展示了这种变化关系，可以帮助我们理解模型在不同阈值下的性能表现。通常来说，曲线越靠近左上方，代表模型的表现越好。</p> 
<p>其AUC值同样是一个重要的性能指标，反映了模型在所有可能的分类阈值上的平均效果，当AUC值越大表示模型性能越好。</p> 
<p>如下图所示的是KNN算法和决策树算法对sklearn库内置的乳腺癌库进行训练预测的PR曲线的结果图：</p> 
<p><img src="https://images2.imgbox.com/cd/ef/ykB3OiSW_o.jpg" alt="在这里插入图片描述"></p> 
<h2><a id="_PRROC_199"></a>三. PR曲线和ROC曲线的特点及其代码实现</h2> 
<h3><a id="31_ROC_201"></a>3.1 ROC曲线的特点</h3> 
<ul><li>对于ROC曲线来说，由于衡量的是TPR和FPR，关注的是所有<em><strong>正样本中被正确分类</strong></em>的比例和所有<em><strong>负类样本中被错误分类</strong></em>的比例，因而其对于模型的<em><strong>考察更加全面</strong></em>。</li><li>对于<em><strong>阈值变化不敏感</strong></em>，具体来说，当阈值上升时，模型会更趋近于保守，TP和FN值会同时下降，也就导致了FPR和FDR的值同时下降，反之亦然。由于二者的变化趋势相同，因而曲线的形状会更加趋近于稳定而不会有太大的变化。这使得ROC曲线能够在不同数据集和情境下提供一致的性能评估。</li><li>在<em><strong>样本极度不平均</strong></em>的数据集下，ROC曲线可能会给出<em><strong>过于乐观</strong></em>的性能评估。当负样本基数远大于正样本且域值较小时，这时候判断较为宽松，TPR值较高，虽然FP也会随之增多，但由于负样本的基数大，FPR并不会有太大的变化，因此在这种极端的状态下，ROC曲线会给出过于乐观的性能评估而无法准确评判模型性能。</li><li><em><strong>简单直观</strong></em>，对于ROC曲线，能通过简单的肉眼观察确定模型的性能优劣，还能通过选择最靠近左上角点以判断最佳平衡点。</li></ul> 
<h3><a id="32_PR_208"></a>3.2 PR曲线的特点</h3> 
<ul><li><em><strong>阈值变化敏感</strong></em>，随着阈值降低，Recall会增高，但Precision可能会发生剧烈变化，反之亦然，因而说对阈值的变化，PR曲线比ROC曲线更加敏感。这使其比ROC曲线更适用于不平衡的数据集。</li><li>PR曲线更加关注***少数类（大部分时候是正类）***的预测，能够直观反映出模型对正类的预测准确性，即使是少量的预测改变也能在曲线上体现出来，有助于识别模型在预测正类方面的微小变化。</li><li>PR曲线不如ROC曲线那样直观易懂，该曲线的性能评估不仅仅依赖于曲线下的面积，还需要考虑曲线的形状和位置，虽然提供的信息比ROC曲线更多，但对于非专业人士来说，较难理解。</li><li>性能评估不全面，PR曲线没有考虑到<em><strong>所有的阈值</strong></em>。PR曲线的绘制不是按照阈值的变化绘制的，而是按照预测的概率进行排序，然后依据样本选择阈值，在该样本之前的都是正样本，之后的都是负样本，这意味着阈值的选择是基于模型对样本的预测概率而不是一个连续变化的值。可通过以下示例了解：</li></ul> 
<p>假设我们有一个数据集，其中包含5个样本，模型给出的预测概率如下：</p> 
<table><thead><tr><th>样本</th><th>实际类别</th><th>预测概率</th></tr></thead><tbody><tr><td>A</td><td>正</td><td>0.9</td></tr><tr><td>B</td><td>负</td><td>0.8</td></tr><tr><td>C</td><td>正</td><td>0.7</td></tr><tr><td>D</td><td>负</td><td>0.4</td></tr><tr><td>E</td><td>正</td><td>0.3</td></tr></tbody></table> 
<p>我们首先按预测概率对样本进行排序，得到顺序为A, B, C, D, E。</p> 
<p>现在，我们从最高概率的样本开始，逐个将样本标记为正例，并计算每次标记时的精确率和召回率。例如：</p> 
<ul><li>当我们选择样本A作为阈值时，只有A被标记为正例。此时，精确率是100%，因为我们正确地将一个正类样本标记为正类，召回率是33%，因为我们只找到了一个实际为正的样本。</li><li>接着，我们将阈值降低到样本B，现在A和B都被标记为正例。由于B实际上是负类，精确率下降到50%，而召回率仍然是33%，因为没有新的正类样本被找到。</li><li>我们继续这个过程，直到所有样本都被考虑过。</li></ul> 
<p>每次改变阈值时，我们都会得到一对新的精确率和召回率，这些点连起来就形成了PR曲线。这个过程中，阈值并不是一个连续变化的数值，而是基于模型对每个样本的预测概率。因此，PR曲线上的每个点都是由数据集中的具体样本决定的，而不是由一个连续的阈值范围决定的。这就是为什么说PR曲线考虑了所有的阈值，但它反映的是模型在这些具体阈值下的性能。</p> 
<h3><a id="33__235"></a>3.3 曲线的绘制代码实操</h3> 
<p>主要使用sklearn库中内置的算法和数据集进行实操</p> 
<pre><code class="prism language-python">解释<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>datasets <span class="token keyword">import</span> load_breast_cancer  <span class="token comment"># 导入乳腺癌数据集</span>
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> train_test_split  <span class="token comment"># 导入数据集分割工具</span>
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>neighbors <span class="token keyword">import</span> KNeighborsClassifier  <span class="token comment"># 导入K近邻分类器</span>
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>tree <span class="token keyword">import</span> DecisionTreeClassifier  <span class="token comment"># 导入决策树分类器</span>
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>metrics <span class="token keyword">import</span> roc_curve<span class="token punctuation">,</span> auc<span class="token punctuation">,</span> precision_recall_curve<span class="token punctuation">,</span> average_precision_score  <span class="token comment"># 导入性能评估工具</span>
<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt  <span class="token comment"># 导入绘图库</span>

<span class="token comment"># 加载乳腺癌数据集</span>
data <span class="token operator">=</span> load_breast_cancer<span class="token punctuation">(</span><span class="token punctuation">)</span>
X <span class="token operator">=</span> data<span class="token punctuation">.</span>data  <span class="token comment"># 特征数据</span>
y <span class="token operator">=</span> data<span class="token punctuation">.</span>target  <span class="token comment"># 标签数据</span>

<span class="token comment"># 将数据集分割为训练集和测试集</span>
X_train<span class="token punctuation">,</span> X_test<span class="token punctuation">,</span> y_train<span class="token punctuation">,</span> y_test <span class="token operator">=</span> train_test_split<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">,</span> test_size<span class="token operator">=</span><span class="token number">0.2</span><span class="token punctuation">)</span>  <span class="token comment"># 将训练集和测试集按8:2的比例拆分</span>

<span class="token comment"># 初始化并训练K近邻分类器</span>
knn_classifier <span class="token operator">=</span> KNeighborsClassifier<span class="token punctuation">(</span>n_neighbors<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>
knn_classifier<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span>

<span class="token comment"># 初始化并训练决策树分类器</span>
tree_classifier <span class="token operator">=</span> DecisionTreeClassifier<span class="token punctuation">(</span>random_state<span class="token operator">=</span><span class="token number">42</span><span class="token punctuation">)</span>
tree_classifier<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span>

<span class="token comment"># 预测测试集的概率</span>
y_scores_knn <span class="token operator">=</span> knn_classifier<span class="token punctuation">.</span>predict_proba<span class="token punctuation">(</span>X_test<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>
y_scores_tree <span class="token operator">=</span> tree_classifier<span class="token punctuation">.</span>predict_proba<span class="token punctuation">(</span>X_test<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>

<span class="token comment"># 计算KNN的ROC曲线和AUC值</span>
fpr_knn<span class="token punctuation">,</span> tpr_knn<span class="token punctuation">,</span> _ <span class="token operator">=</span> roc_curve<span class="token punctuation">(</span>y_test<span class="token punctuation">,</span> y_scores_knn<span class="token punctuation">)</span>
roc_auc_knn <span class="token operator">=</span> auc<span class="token punctuation">(</span>fpr_knn<span class="token punctuation">,</span> tpr_knn<span class="token punctuation">)</span>

<span class="token comment"># 计算决策树的ROC曲线和AUC值</span>
fpr_tree<span class="token punctuation">,</span> tpr_tree<span class="token punctuation">,</span> _ <span class="token operator">=</span> roc_curve<span class="token punctuation">(</span>y_test<span class="token punctuation">,</span> y_scores_tree<span class="token punctuation">)</span>
roc_auc_tree <span class="token operator">=</span> auc<span class="token punctuation">(</span>fpr_tree<span class="token punctuation">,</span> tpr_tree<span class="token punctuation">)</span>

<span class="token comment"># 计算KNN的精确度-召回率曲线和平均精确度</span>
precision_knn<span class="token punctuation">,</span> recall_knn<span class="token punctuation">,</span> _ <span class="token operator">=</span> precision_recall_curve<span class="token punctuation">(</span>y_test<span class="token punctuation">,</span> y_scores_knn<span class="token punctuation">)</span>
average_precision_knn <span class="token operator">=</span> average_precision_score<span class="token punctuation">(</span>y_test<span class="token punctuation">,</span> y_scores_knn<span class="token punctuation">)</span>

<span class="token comment"># 计算决策树的精确度-召回率曲线和平均精确度</span>
precision_tree<span class="token punctuation">,</span> recall_tree<span class="token punctuation">,</span> _ <span class="token operator">=</span> precision_recall_curve<span class="token punctuation">(</span>y_test<span class="token punctuation">,</span> y_scores_tree<span class="token punctuation">)</span>
average_precision_tree <span class="token operator">=</span> average_precision_score<span class="token punctuation">(</span>y_test<span class="token punctuation">,</span> y_scores_tree<span class="token punctuation">)</span>

<span class="token comment"># 绘制ROC曲线</span>
plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>fpr_knn<span class="token punctuation">,</span> tpr_knn<span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'darkorange'</span><span class="token punctuation">,</span> lw<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'KNN (AUC = %0.2f)'</span> <span class="token operator">%</span> roc_auc_knn<span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>fpr_tree<span class="token punctuation">,</span> tpr_tree<span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'green'</span><span class="token punctuation">,</span> lw<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'Decision Tree (AUC = %0.2f)'</span> <span class="token operator">%</span> roc_auc_tree<span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'navy'</span><span class="token punctuation">,</span> lw<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> linestyle<span class="token operator">=</span><span class="token string">'--'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>xlim<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>ylim<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.05</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'False Positive Rate'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'True Positive Rate'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'ROC Curve'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span>loc<span class="token operator">=</span><span class="token string">"lower right"</span><span class="token punctuation">)</span>

<span class="token comment"># 绘制精确度-召回率曲线</span>
plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>recall_knn<span class="token punctuation">,</span> precision_knn<span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'blue'</span><span class="token punctuation">,</span> lw<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'KNN (AP = %0.2f)'</span> <span class="token operator">%</span> average_precision_knn<span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>recall_tree<span class="token punctuation">,</span> precision_tree<span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'purple'</span><span class="token punctuation">,</span> lw<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'Decision Tree (AP = %0.2f)'</span> <span class="token operator">%</span> average_precision_tree<span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'Recall'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'Precision'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'P-R Curve'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span>loc<span class="token operator">=</span><span class="token string">"lower left"</span><span class="token punctuation">)</span>

plt<span class="token punctuation">.</span>tight_layout<span class="token punctuation">(</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<pre><code class="prism language-bash">NN <span class="token punctuation">(</span>AP <span class="token operator">=</span> %0.2f<span class="token punctuation">)</span><span class="token string">' % average_precision_knn)
plt.plot(recall_tree, precision_tree, color='</span>purple<span class="token string">', lw=2, label='</span>Decision Tree <span class="token punctuation">(</span>AP <span class="token operator">=</span> %0.2f<span class="token punctuation">)</span><span class="token string">' % average_precision_tree)
plt.xlabel('</span>Recall<span class="token string">')
plt.ylabel('</span>Precision<span class="token string">')
plt.title('</span>P-R Curve'<span class="token punctuation">)</span>
plt.legend<span class="token punctuation">(</span>loc<span class="token operator">=</span><span class="token string">"lower left"</span><span class="token punctuation">)</span>

plt.tight_layout<span class="token punctuation">(</span><span class="token punctuation">)</span>
plt.show<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>最终结果图如下：<br> <img src="https://images2.imgbox.com/ea/7f/L215m3j3_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/433a10195cc35a58a6807ca4e2b77bdd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【数据结构】：顺序表实战（通讯录）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2fcf59a29b3028af3cb19a9143c2dc4e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ROS2快速入门Python篇-版本梳理、环境搭建、源码架构介绍</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>