<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【算法专题】动态规划之路径问题 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/751b5ddeac3c814ab1df32b33f81eff4/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【算法专题】动态规划之路径问题">
  <meta property="og:description" content="动态规划2.0 动态规划 - - - 路径问题1. 不同路径2. 不同路径Ⅱ3. 珠宝的最高价值4. 下降路径最小和5. 最小路径和6. 地下城游戏 动态规划 - - - 路径问题 1. 不同路径 题目链接 -&gt; Leetcode -62.不同路径
Leetcode -62.不同路径
题目：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
问总共有多少条不同的路径？
示例 1：
输入：m = 3, n = 7
输出：28
示例 2：
输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
向右-&gt;向下-&gt;向下向下-&gt;向下-&gt;向右向下-&gt;向右-&gt;向下 示例 3：
输入：m = 7, n = 3
输出：28">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-01-24T09:09:46+08:00">
    <meta property="article:modified_time" content="2024-01-24T09:09:46+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【算法专题】动态规划之路径问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>动态规划2.0</h4> 
 <ul><li><a href="#_____2" rel="nofollow">动态规划 - - - 路径问题</a></li><li><ul><li><a href="#1__5" rel="nofollow">1. 不同路径</a></li><li><a href="#2__79" rel="nofollow">2. 不同路径Ⅱ</a></li><li><a href="#3__148" rel="nofollow">3. 珠宝的最高价值</a></li><li><a href="#4__202" rel="nofollow">4. 下降路径最小和</a></li><li><a href="#5__280" rel="nofollow">5. 最小路径和</a></li><li><a href="#6__343" rel="nofollow">6. 地下城游戏</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_____2"></a>动态规划 - - - 路径问题</h2> 
<h3><a id="1__5"></a>1. 不同路径</h3> 
<p><strong>题目链接</strong> -&gt; <a href="https://leetcode.cn/problems/unique-paths/" rel="nofollow">Leetcode -62.不同路径</a></p> 
<p>Leetcode -62.不同路径</p> 
<p>题目：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。<br> 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。<br> 问总共有多少条不同的路径？</p> 
<p>示例 1：<br> 输入：m = 3, n = 7<br> 输出：28</p> 
<p>示例 2：<br> 输入：m = 3, n = 2<br> 输出：3<br> 解释：<br> 从左上角开始，总共有 3 条路径可以到达右下角。</p> 
<ol><li>向右-&gt;向下-&gt;向下</li><li>向下-&gt;向下-&gt;向右</li><li>向下-&gt;向右-&gt;向下</li></ol> 
<p>示例 3：<br> 输入：m = 7, n = 3<br> 输出：28</p> 
<p>示例 4：<br> 输入：m = 3, n = 3<br> 输出：6</p> 
<p>提示：</p> 
<ul><li>1 &lt;= m, n &lt;= 100</li><li>题目数据保证答案小于等于 2 * 10^9</li></ul> 
<p><strong>思路：</strong></p> 
<ol><li><strong>状态表示：对于这种「路径类」的问题，我们的状态表示一般有两种形式：</strong><br> <strong>i. 从 [i, j] 位置出发，…；<br> ii. 从起始位置出发，到达 [i, j] 位置，…；<br> 我们选择第二种定义状态表示的方式：dp[i][j] 表示：走到 [i, j] 位置处，一共有多少种方式。</strong></li><li><strong>状态转移方程：分析一下，如果 dp[i][j] 表示到达 [i, j] 位置的方法数，那么到达 [i, j] 位置之前的一小步，有两种情况：<br> i. 从 [i, j] 位置的上方（ [i - 1, j] 的位置）向下走一步，转移到 [i, j] 位置；<br> ii. 从 [i, j] 位置的左方（ [i, j - 1] 的位置）向右走一步，转移到 [i, j] 位置。<br> 由于我们要求的是有多少种方法，因此状态转移方程就呼之欲出了： dp[i][j] = dp[i - 1][j] + dp[i][j - 1] 。</strong></li><li><strong>返回值：根据状态表示，我们要返回 dp[m][n] 的值。</strong></li></ol> 
<p>代码如下：</p> 
<pre><code>		class Solution {
		public:
		    int uniquePaths(int m, int n)
		    {
		        // 多开一行一列，可以直接在循环内初始化
		        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1));
		        dp[0][1] = 1;  // 为了后面填表的正确
		
		        // dp[i][j] 表示：⾛到 [i, j] 位置处，⼀共有多少种方式
		        for (int i = 1; i &lt;= m; i++)
		        {
		            for (int j = 1; j &lt;= n; j++)
		            {
		                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
		            }
		        }
		        return dp[m][n];
		    }
		};
</code></pre> 
<h3><a id="2__79"></a>2. 不同路径Ⅱ</h3> 
<p><strong>题目链接</strong> -&gt; <a href="https://leetcode.cn/problems/unique-paths-ii/" rel="nofollow">Leetcode -63.不同路径Ⅱ</a></p> 
<p>Leetcode -63.不同路径Ⅱ</p> 
<p>题目：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。<br> 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。<br> 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？<br> 网格中的障碍物和空位置分别用 1 和 0 来表示。</p> 
<p>示例 1：<br> 输入：obstacleGrid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]<br> 输出：2<br> 解释：3x3 网格的正中间有一个障碍物。<br> 从左上角到右下角一共有 2 条不同的路径：</p> 
<ol><li>向右-&gt;向右-&gt;向下-&gt;向下</li><li>向下-&gt;向下-&gt;向右-&gt;向右</li></ol> 
<p>示例 2：<br> 输入：obstacleGrid = [[0, 1], [0, 0]]<br> 输出：1</p> 
<p>提示：</p> 
<ul><li>m == obstacleGrid.length</li><li>n == obstacleGrid[i].length</li><li>1 &lt;= m, n &lt;= 100</li><li>obstacleGrid[i][j] 为 0 或 1</li></ul> 
<p><strong>思路：本题为不同路径的变型，只不过有些地方有「障碍物」，只要在「状态转移」上稍加修改就可解决。</strong></p> 
<ol><li><strong>状态表示：dp[i][j] 表示：走到 [i, j] 位置处，一共有多少种方式。</strong></li><li><strong>状态转移：简单分析一下。如果 dp[i][j] 表示到达 [i, j] 位置的方法数，那么到达 [i, j] 位置之前的一小步，有两种情况：<br> i. 从 [i, j] 位置的上方（ [i - 1, j] 的位置）向下走一步，转移到 [i, j] 位置；<br> ii. 从 [i, j] 位置的左方（ [i, j - 1] 的位置）向右走一步，转移到 [i, j] 位置。<br> 但是， [i - 1, j] 与 [i, j - 1] 位置都是可能有障碍的，此时从上面或者左边是不可能到达 [i, j] 位置的，也就是说，此时的方法数应该是 0；由此我们可以得出一个结论，只要这个位置上「有障碍物」，那么我们就不需要计算这个位置上的值，直接让它等于 0 即可。</strong></li><li><strong>返回值：根据状态表示，我们要返回的结果是 dp[m][n].</strong></li></ol> 
<p>代码如下：</p> 
<pre><code>		class Solution {
		public:
		    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid)
		    {
		        int m = obstacleGrid.size(), n = obstacleGrid[0].size();
		
		        // 多开一行一列方便初始化
		        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1));
		        dp[0][1] = 1; // 为了后面填表的正确
		
		        // dp[i][j] 表示：⾛到 [i, j] 位置处，⼀共有多少种方式
		        for (int i = 1; i &lt;= m; i++)
		        {
		            for (int j = 1; j &lt;= n; j++)
		            {
		                // 原矩阵中的位置不是障碍物
		                if (obstacleGrid[i - 1][j - 1] != 1)
		                {
		                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
		                }
		            }
		        }
		        return dp[m][n];
		    }
		};
</code></pre> 
<h3><a id="3__148"></a>3. 珠宝的最高价值</h3> 
<p><strong>题目链接</strong> -&gt; <a href="https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/" rel="nofollow">Leetcode -LCR 166.珠宝的最高价值</a></p> 
<p>Leetcode -LCR 166.珠宝的最高价值</p> 
<p>题目：现有一个记作二维矩阵 frame 的珠宝架，其中 frame[i][j] 为该位置珠宝的价值。拿取珠宝的规则为：</p> 
<p>只能从架子的左上角开始拿珠宝<br> 每次可以移动到右侧或下侧的相邻位置<br> 到达珠宝架子的右下角时，停止拿取<br> 注意：珠宝的价值都是大于 0 的。除非这个架子上没有任何珠宝，比如 frame = [[0]] 。</p> 
<p>示例 1:<br> 输入: frame = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]<br> 输出 : 12<br> 解释 : 路径 1→3→5→2→1 可以拿到最高价值的珠宝</p> 
<p>提示：</p> 
<ul><li>0 &lt; frame.length &lt;= 200</li><li>0 &lt; frame[0].length &lt;= 200</li></ul> 
<p><strong>思路：本题的思路与上题的思路差不多，状态转移方程为：dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] .</strong></p> 
<p>代码如下：</p> 
<pre><code>		class Solution {
		public:
		    int maxValue(vector&lt;vector&lt;int&gt;&gt;&amp; grid)
		    {
		        int m = grid.size(), n = grid[0].size();
		
		        // 多开一行一列方便初始化
		        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1));
		
		        // dp[i][j] 表示：⾛到 [i, j] 位置处，此时的最大价值
		        for (int i = 1; i &lt;= m; i++)
		        {
		            for (int j = 1; j &lt;= n; j++)
		            {
		                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1];
		            }
		        }
		
		        return dp[m][n];
		    }
		};
</code></pre> 
<h3><a id="4__202"></a>4. 下降路径最小和</h3> 
<p><strong>题目链接</strong> -&gt; <a href="https://leetcode.cn/problems/minimum-falling-path-sum/" rel="nofollow">Leetcode -931.下降路径最小和</a></p> 
<p>Leetcode -931.下降路径最小和</p> 
<p>题目：给你一个 n x n 的 方形 整数数组 matrix ，请你找出并返回通过 matrix 的下降路径 的 最小和 。</p> 
<p>下降路径 可以从第一行中的任何元素开始，并从每一行中选择一个元素。<br> 在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。<br> 具体来说，位置(row, col) 的下一个元素应当是(row + 1, col - 1)、(row + 1, col) 或者(row + 1, col + 1) 。</p> 
<p>示例 1：<br> 输入：matrix = [[2, 1, 3], [6, 5, 4], [7, 8, 9]]<br> 输出：13<br> 解释：如图所示，为和最小的两条下降路径<br> <img src="https://images2.imgbox.com/ba/45/QmewMC00_o.png" alt="在这里插入图片描述"></p> 
<p>示例 2：<br> 输入：matrix = [[-19, 57], [-40, -5]]<br> 输出： - 59<br> 解释：如图所示，为和最小的下降路径</p> 
<p><img src="https://images2.imgbox.com/c8/da/11Esyabi_o.png" alt="在这里插入图片描述"></p> 
<p>提示：</p> 
<ul><li>n == matrix.length == matrix[i].length</li><li>1 &lt;= n &lt;= 100</li><li>100 &lt;= matrix[i][j] &lt;= 100</li></ul> 
<p><strong>思路：</strong></p> 
<ol><li><strong>状态表示：dp[i][j] 表示：到达 [i, j] 位置时，所有下降路径中的最小和。</strong></li><li><strong>状态转移方程：对于普遍位置 [i, j] ，根据题意得，到达 [i, j] 位置可能有三种情况：</strong><br> <strong>i. 从正上方 [i - 1, j] 位置转移到 [i, j] 位置；<br> ii. 从左上方 [i - 1, j - 1] 位置转移到 [i, j] 位置；<br> iii. 从右上方 [i - 1, j + 1] 位置转移到 [i, j] 位置；<br> 我们要的是三种情况下的「最小值」，然后再加上矩阵在 [i, j] 位置的值。<br> 于是 dp[i][j] = min(dp[i - 1][j], min(dp[i - 1][j - 1], dp[i - 1][j + 1])) + matrix[i][j] 。</strong></li><li><strong>返回值：注意这里不是返回 dp[m][n] 的值；题目要求「只要到达最后一行」就行了，因此这里应该返回「 dp 表中最后一行的最小值」。</strong></li></ol> 
<p>代码如下：</p> 
<pre><code>		class Solution {
		public:
		    int minFallingPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; matrix)
		    {
		        int len = matrix.size();
		
		        // 多开一行，两列，因为dp[i][j]的值需要用到dp[i - 1][j], dp[i - 1][j - 1], dp[i - 1][j + 1]
		        vector&lt;vector&lt;int&gt;&gt; dp(len + 1, vector&lt;int&gt;(len + 2, INT_MAX));
		
		        // 初始化，为了后面填表的正确性
		        for (int i = 0; i &lt;= len; i++) dp[0][i] = 0;
		
		        // dp[i][j] 表示：到达 [i, j] 位置时，所有下降路径中的最小和
		        for (int i = 1; i &lt;= len; i++)
		        {
		            for (int j = 1; j &lt;= len; j++)
		            {
		                dp[i][j] = min(min(dp[i - 1][j], dp[i - 1][j - 1]), dp[i - 1][j + 1]) + matrix[i - 1][j - 1];
		            }
		        }
		
		        // 返回最后一行的最小值
		        int ret = INT_MAX;
		        for (int j = 0; j &lt;= len; j++) ret = min(ret, dp[len][j]);
		        return ret;
		    }
		};
</code></pre> 
<h3><a id="5__280"></a>5. 最小路径和</h3> 
<p><strong>题目链接</strong> -&gt; <a href="https://leetcode.cn/problems/minimum-path-sum/" rel="nofollow">Leetcode -64.最小路径和</a></p> 
<p>Leetcode -64.最小路径和</p> 
<p>题目：给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p> 
<p>说明：每次只能向下或者向右移动一步。</p> 
<p>示例 1：<br> 输入：grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]<br> 输出：7<br> 解释：因为路径 1→3→1→1→1 的总和最小。<br> <img src="https://images2.imgbox.com/57/38/bTYDF4uN_o.png" alt="在这里插入图片描述"></p> 
<p>示例 2：<br> 输入：grid = [[1, 2, 3], [4, 5, 6]]<br> 输出：12</p> 
<p>提示：</p> 
<ul><li>m == grid.length</li><li>n == grid[i].length</li><li>1 &lt;= m, n &lt;= 200</li><li>0 &lt;= grid[i][j] &lt;= 200</li></ul> 
<p><strong>思路：</strong></p> 
<ol><li><strong>状态表示：dp[i][j] 表示：到达 [i, j] 位置处，最小路径和是多少</strong></li><li><strong>状态转移：分析一下，如果 dp[i][j] 表示到达 [i, j] 位置处的最小路径和，那么到达[i, j] 位置之前的一小步，有两种情况：<br> i. 从 [i - 1, j] 向下走一步，转移到 [i, j] 位置；<br> ii. 从 [i, j - 1] 向右走一步，转移到 [i, j] 位置。<br> 由于到 [i, j] 位置两种情况，并且我们要找的是最小路径，因此只需要这两种情况下的最小值，再加上 [i, j] 位置上本身的值即可。也就是： dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]</strong></li><li><strong>返回值：根据状态表示，我们要返回的结果是 dp[m][n].</strong></li></ol> 
<p>代码如下：</p> 
<pre><code>		class Solution {
		public:
		    int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid)
		    {
		        int m = grid.size(), n = grid[0].size();
		
		        // dp[i][j] 表示：到达 [i, j] 位置处，最小路径和是多少
		        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, INT_MAX));
		
		        dp[0][1] = 0;
		        for (int i = 1; i &lt;= m; i++)
		        {
		            for (int j = 1; j &lt;= n; j++)
		            {
		                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1];
		            }
		        }
		
		        return dp[m][n];
		    }
		};
</code></pre> 
<h3><a id="6__343"></a>6. 地下城游戏</h3> 
<p><strong>题目链接</strong> -&gt; <a href="https://leetcode.cn/problems/dungeon-game/" rel="nofollow">Leetcode -174.地下城游戏</a></p> 
<p>Leetcode -174.地下城游戏</p> 
<p>题目：恶魔们抓住了公主并将她关在了地下城 dungeon 的 右下角 。地下城是由 m x n 个房间组成的二维网格。<br> 我们英勇的骑士最初被安置在 左上角 的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p> 
<p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p> 
<p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；<br> 其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。<br> 为了尽快解救公主，骑士决定每次只 向右 或 向下 移动一步。<br> 返回确保骑士能够拯救到公主所需的最低初始健康点数。<br> 注意：任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。</p> 
<p>示例 1：<br> 输入：dungeon = [[-2, -3, 3], [-5, -10, 1], [10, 30, -5]]<br> 输出：7<br> 解释：如果骑士遵循最佳路径：右-&gt;右-&gt;下-&gt;下 ，则骑士的初始健康点数至少为 7 。</p> 
<p>示例 2：<br> 输入：dungeon = [[0]]<br> 输出：1</p> 
<p>提示：</p> 
<ul><li>m == dungeon.length</li><li>n == dungeon[i].length</li><li>1 &lt;= m, n &lt;= 200</li><li>1000 &lt;= dungeon[i][j] &lt;= 1000</li></ul> 
<p><strong>思路：</strong></p> 
<ol><li><strong>状态表示：这道题如果我们定义成：从起点开始，到达 [i, j] 位置的时候，所需的最低初始健康点数。那么我们分析状态转移的时候会有一个问题：那就是我们当前的健康点数还会受到后面的路径的影响。也就是从上往下的状态转移不能很好地解决问题。<br> 这个时候我们要换一种状态表示：从 [i, j] 位置出发，到达终点时所需要的最低初始健康点数。这样我们在分析状态转移的时候，后续的最佳状态就已经知晓。综上所述，定义状态表示为：dp[i][j] 表示：从 [i, j] 位置出发，到达终点时所需的最低初始健康点数。</strong></li><li><strong>状态转移方程：对于 dp[i][j] ，从 [i, j] 位置出发，下一步会有两种选择（为了方便理解，设 dp[i][j] 的最终答案是 x ）：<br> i. 走到右边，然后走向终点；那么我们在 [i, j] 位置的最低健康点数加上这一个位置的消耗，应该要大于等于右边位置的最低健康点数，也就是： x + dungeon[i][j] &gt;= dp[i][j + 1] ；通过移项可得： x &gt;= dp[i][j + 1] - dungeon[i][j] 。因为我们要的是最小<br> 值，因此这种情况下的 x = dp[i][j + 1] - dungeon[i][j] ；<br> ii. 走到下边，然后走向终点；那么我们在 [i, j] 位置的最低健康点数加上这⼀个位置的消耗，应该要大于等于下边位置的最低健康点数，也就是： x + dungeon[i][j] &gt;= dp[i + 1][j] 。通过移项可得： x &gt;= dp[i + 1][j] - dungeon[i][j] 。因为我们要的是最小值，因此这种情况下的 x = dp[i + 1][j] - dungeon[i][j] ；</strong></li></ol> 
<ul><li><strong>综上所述，我们需要的是两种情况下的最小值，因此可得状态转移方程为：dp[i][j] = min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]</strong></li></ul> 
<p><strong>但是，如果当前位置的 dungeon[i][j] 是一个比较大的正数的话， dp[i][j] 的值可能变成 0 或者负数。也就是最低点数会小于 1 ，那么骑士就会死亡。因此我们求出来的 dp[i][j] 如果小于等于 0 的话，说明此时的最低初始值应该为 1 。处理这种情况仅需让 dp[i][j] 与 1 取一个最大值即可：dp[i][j] = max(1, dp[i][j])</strong></p> 
<ol start="3"><li> <p><strong>初始化：可以在最前面加上一个「辅助结点」，帮助我们初始化。使用这种技巧要注意两个点：<br> i. 辅助结点里面的值要「保证后续填表是正确的」；<br> ii. 「下标的映射关系」。<br> 在本题中，在 dp 表最后面添加一行，并且添加一列后，所有的值都先初始化为无穷大，然后让 dp[m][n - 1] = dp[m - 1][n] = 1 即可。</strong></p> </li><li> <p><strong>返回值：根据「状态表示」，我们需要返回 dp[0][0] 的值。</strong></p> </li></ol> 
<p>代码如下：</p> 
<pre><code>		class Solution {
		public:
		    int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon)
		    {
		        int m = dungeon.size(), n = dungeon[0].size();
		        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, INT_MAX));
		        dp[m][n - 1] = 1;
		
		        // 从右下角往回推
		        for (int i = m - 1; i &gt;= 0; i--)
		        {
		            for (int j = n - 1; j &gt;= 0; j--)
		            {
		                dp[i][j] = min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j];
		
		                // 如果减到负数，说明这里的血包很大，即使是负数到这里都可以，但是这是不符合常理的
		                // 所以需要将这里置成 1 即可
		                if (dp[i][j] &lt;= 0) dp[i][j] = 1;    
		            }
		        }
		
		        // 返回最初位置
		        return dp[0][0];
		    }
		};
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3804a6ee9781441d73397c72c4196297/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Windows11 Copilot助手开启教程(免费GPT-4)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d75e9242e67223098ebeec97e1a6eb90/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">windows安装mongodb</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>