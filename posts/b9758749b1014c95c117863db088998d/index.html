<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java中使用RabbitMQ(持续更新中) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b9758749b1014c95c117863db088998d/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java中使用RabbitMQ(持续更新中)">
  <meta property="og:description" content="一、安装 前言
RabbitMQ服务端代码是使用并发式语言Erlang编写的，安装Rabbit MQ的前提是安装Erlang （ https://www.erlang.org/downloads ）。同时，在安装RabbitMQ 时需要注意RabbitMQ 与Erlang的对应版本，防止安装过程中出错。一般情况下，版本均选择新版本不会有太大问题，但还是需要注意下。可以参考RabbitMQ 的社区，里面有介绍版本号及推荐的Erlang版本。
1.windows安装 需要安装Erlang和RabbitMQ两个东西
1.1 安装Erlang 1.1.1 下载 地址:https://www.erlang.org/downloads
1.1.2 安装 傻瓜式安装,双击下一步即可 (安装到没有中文的目录下)
1.1.3 配置环境变量 1.1.4 测试安装 Win&#43;R打开运行，输入cmd进入黑窗口。输入 erl，出来版本号即成功。
1.2 安装RabbitMQ 1.2.1 下载 地址:https://www.rabbitmq.com/download.html
1.2.2 安装 1.2.2.1 傻瓜式安装,双击下一步即可(安装在没有中文的目录)
打开命令行cd，输入RabbitMQ的sbin目录。
E:\Program Files\RabbitMQ Server\rabbitmq_server-3.7.4\sbin 然后输入以下命令进行安装
rabbitmq-plugins enable rabbitmq_management 验证rabbitmq是否安装成功
rabbitmqctl status 如果出现以下的图，说明安装是成功的，并且说明现在RabbitMQ Server已经启动了,运行正常
打开浏览器，地址栏输入mq访问地址，即可看到管理界面的登陆页
http://127.0.0.1:15672
输入用户名和密码，都为guest 进入主界面
1.2.3 安装可能遇到的问题 出现 Authentication failed (rejected by the remote node), please check the Erlang cookie
如果改完cookie没生效，重启一下电脑，清除cookie缓存，获取最新修改的cookie，即可解决该问题">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-01-03T17:19:11+08:00">
    <meta property="article:modified_time" content="2024-01-03T17:19:11+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java中使用RabbitMQ(持续更新中)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一、安装</h3> 
<p><strong><span style="color:#4da8ee;">前言</span></strong></p> 
<p>RabbitMQ服务端代码是使用并发式语言Erlang编写的，安装Rabbit MQ的前提是安装Erlang （ https://www.erlang.org/downloads ）。同时，在安装RabbitMQ 时需要注意RabbitMQ 与Erlang的对应版本，防止安装过程中出错。一般情况下，版本均选择新版本不会有太大问题，但还是需要注意下。可以参考RabbitMQ 的社区，里面有介绍版本号及推荐的Erlang版本。</p> 
<h4>1.windows安装</h4> 
<p><span style="color:#a2e043;">需要安装Erlang和RabbitMQ两个东西</span></p> 
<h5>1.1 安装Erlang</h5> 
<h6>1.1.1 下载</h6> 
<p><span style="color:#4da8ee;">地址:https://www.erlang.org/downloads</span></p> 
<p class="img-center"><img alt="" height="705" src="https://images2.imgbox.com/e2/b8/OzjQyVZ6_o.png" width="1200"></p> 
<h6> 1.1.2 安装</h6> 
<p>傻瓜式安装,双击下一步即可 (安装到没有中文的目录下)</p> 
<p class="img-center"><img alt="" height="33" src="https://images2.imgbox.com/7d/16/RmJKF7ls_o.png" width="581"></p> 
<h6> 1.1.3 配置环境变量</h6> 
<p class="img-center"><img alt="" height="183" src="https://images2.imgbox.com/07/5a/0HIFz5pq_o.png" width="653"></p> 
<p></p> 
<p class="img-center"><img alt="" height="563" src="https://images2.imgbox.com/c0/20/U72XpiGW_o.png" width="527"></p> 
<h6> 1.1.4 测试安装</h6> 
<p>Win+R打开运行，输入cmd进入黑窗口。输入 erl，出来版本号即成功。</p> 
<p class="img-center"><img alt="" height="420" src="https://images2.imgbox.com/81/94/KKWPTZqZ_o.png" width="847"></p> 
<h5> 1.2 安装RabbitMQ</h5> 
<h6>1.2.1 下载</h6> 
<p><span style="color:#4da8ee;">地址:<a href="https://www.rabbitmq.com/download.html" rel="nofollow" title="https://www.rabbitmq.com/download.html">https://www.rabbitmq.com/download.html</a></span></p> 
<p class="img-center"><img alt="" height="638" src="https://images2.imgbox.com/3d/4f/7mkcKfBj_o.png" width="982"></p> 
<h6> 1.2.2 安装</h6> 
<p>1.2.2.1 傻瓜式安装,双击下一步即可(安装在没有中文的目录)</p> 
<p class="img-center"><img alt="" height="31" src="https://images2.imgbox.com/d3/b4/eaLL0E2u_o.png" width="617"></p> 
<p> 打开命令行cd，输入RabbitMQ的sbin目录。</p> 
<pre><code>E:\Program Files\RabbitMQ Server\rabbitmq_server-3.7.4\sbin
</code></pre> 
<p> 然后输入以下命令进行安装</p> 
<pre><code>rabbitmq-plugins enable rabbitmq_management
</code></pre> 
<p class="img-center"><img alt="" height="256" src="https://images2.imgbox.com/28/b8/nR7B1pgh_o.png" width="854"></p> 
<p>验证rabbitmq是否安装成功</p> 
<pre><code>rabbitmqctl status
</code></pre> 
<p> 如果出现以下的图，说明安装是成功的，并且说明现在RabbitMQ Server已经启动了,运行正常</p> 
<p class="img-center"><img alt="" height="846" src="https://images2.imgbox.com/6e/8c/u9PqM6mc_o.png" width="830"></p> 
<p> 打开浏览器，地址栏输入mq访问地址，即可看到管理界面的登陆页</p> 
<p><a href="http://127.0.0.1:15672" rel="nofollow" title="http://127.0.0.1:15672">http://127.0.0.1:15672</a></p> 
<p> 输入用户名和密码，都为guest 进入主界面</p> 
<p class="img-center"><img alt="" height="246" src="https://images2.imgbox.com/7a/9a/RMw1gLBv_o.png" width="960"></p> 
<h6> 1.2.3 安装可能遇到的问题</h6> 
<p>出现 Authentication failed (rejected by the remote node), please check the Erlang cookie</p> 
<p><span style="color:#fe2c24;">如果改完cookie没生效，重启一下电脑，清除cookie缓存，获取最新修改的cookie，即可解决该问题</span></p> 
<p class="img-center"><img alt="" height="487" src="https://images2.imgbox.com/9d/25/Dp1G21BN_o.png" width="837"></p> 
<p><strong>解决办法：</strong></p> 
<p>比较下面两个文件夹下的.erlang.cookie文件内容，后来修改其中一个文件的内容，使两个文件内容一样。再次执行命令rabbitmqctl status，成功</p> 
<pre><code>C:\Windows\System32\config\systemprofile\.erlang.cookie
C:\User\{<!-- -->{电脑用户名}}\.erlang.cookie
</code></pre> 
<p class="img-center"><img alt="" height="640" src="https://images2.imgbox.com/2e/b4/mR6qNQr2_o.png" width="600"></p> 
<h3>二、使用</h3> 
<p><span style="color:#a2e043;"><strong>SpringAMQP</strong></span></p> 
<p>SpringAMQP是基于RabbitMQ封装的一套模板，并且还利用SpringBoot对其实现了自动装配，使用起来非常方便。</p> 
<p>优点:</p> 
<ul><li> <p>自动声明队列、交换机及其绑定关系</p> </li><li> <p>基于注解的监听器模式，异步接收消息</p> </li><li> <p>封装了RabbitTemplate工具，用于发送消息</p> </li></ul> 
<p><span style="color:#4da8ee;">下载RabbitMQ-demo : https://pan.baidu.com/s/1zEc6pXa7Vo8gPFHKgeVVHQ 密码1234</span></p> 
<p>导入后可以看到结构如下：</p> 
<p class="img-center"><img alt="" height="186" src="https://images2.imgbox.com/dd/3b/2CTMGYlH_o.png" width="452"></p> 
<h4>1.Basic Queue 简单队列模型(第一种模型)</h4> 
<p>在父工程mq-demo中引入依赖</p> 
<pre><code class="language-java">&lt;!--AMQP依赖，包含RabbitMQ--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre> 
<h5>1.1 消息发送</h5> 
<p>首先配置MQ地址，在publisher服务的application.yml中添加配置：注意修改为自己的mqip端口,账号密码</p> 
<pre><code class="language-java">spring:
  rabbitmq:
    host: 127.0.0.1 # 主机名
    port: 5672 # 端口
    virtual-host: / # 虚拟主机
    username: guest # 用户名
    password: guest # 密码</code></pre> 
<p>然后在publisher服务中编写测试类SpringAmqpTest，并利用RabbitTemplate实现消息发送：</p> 
<pre><code class="language-java">package cn.itcast.mq.spring;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

@RunWith(SpringRunner.class)
@SpringBootTest
public class SpringAmqpTest {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @Test
    public void testSimpleQueue() {
        // 队列名称
        String queueName = "simple.queue";
        // 消息
        String message = "hello, spring amqp!";
        // 发送消息
        rabbitTemplate.convertAndSend(queueName, message);
    }
}</code></pre> 
<h5>1.2 消息接收</h5> 
<p>首先配置MQ地址，在consumer服务的application.yml中添加配置：注意修改为自己的mqip端口,账号密码</p> 
<pre><code class="language-java">spring:
  rabbitmq:
    host: 127.0.0.1 # 主机名
    port: 5672 # 端口
    virtual-host: / # 虚拟主机
    username: guest # 用户名
    password: guest # 密码</code></pre> 
<p> 然后在consumer服务的<code>cn.mq.listener</code>包中新建一个类SpringRabbitListener，代码如下：</p> 
<pre><code class="language-java">package cn.mq.listener;

import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;

@Component
public class SpringRabbitListener {

    @RabbitListener(queues = "simple.queue")
    public void listenSimpleQueueMessage(String msg) throws InterruptedException {
        System.out.println("spring 消费者接收到消息：【" + msg + "】");
    }
}</code></pre> 
<p>启动consumer服务，然后在publisher服务中运行测试代码，发送MQ消息</p> 
<h4>2.WorkQueue(第二种模型)</h4> 
<p>Work queues，也被称为（Task queues），任务模型。简单来说就是让多个消费者绑定到一个队列，共同消费队列中的消息。</p> 
<p class="img-center"><img alt="" height="302" src="https://images2.imgbox.com/58/7f/b5HbJu9V_o.png" width="787"></p> 
<p>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。此时就可以使用work 模型，多个消费者共同处理消息处理，速度就能大大提高了。</p> 
<h5>2.1 消息发送</h5> 
<p>这次我们循环发送，模拟大量消息堆积现象。在publisher服务中的SpringAmqpTest类中添加一个测试方法：</p> 
<pre><code class="language-java">/**
     * workQueue
     * 向队列中不停发送消息，模拟消息堆积。
     */
@Test
public void testWorkQueue() throws InterruptedException {
    // 队列名称
    String queueName = "simple.queue";
    // 消息
    String message = "hello, message_";
    for (int i = 0; i &lt; 50; i++) {
        // 发送消息
        rabbitTemplate.convertAndSend(queueName, message + i);
        Thread.sleep(20);
    }
}</code></pre> 
<h5>2.2 消息接收</h5> 
<p>要模拟多个消费者绑定同一个队列，我们在consumer服务的SpringRabbitListener中添加2个新的方法：</p> 
<pre><code class="language-java">@RabbitListener(queues = "simple.queue")
public void listenWorkQueue1(String msg) throws InterruptedException {
    System.out.println("消费者1接收到消息：【" + msg + "】" + LocalTime.now());
    Thread.sleep(20);
}

@RabbitListener(queues = "simple.queue")
public void listenWorkQueue2(String msg) throws InterruptedException {
    System.err.println("消费者2........接收到消息：【" + msg + "】" + LocalTime.now());
    Thread.sleep(200);
}</code></pre> 
<h5>2.3 测试</h5> 
<p>启动ConsumerApplication后，在执行publisher服务中刚刚编写的发送测试方法testWorkQueue。可以看到消费者1很快完成了自己的25条消息。消费者2却在缓慢的处理自己的25条消息。也就是说消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。这样显然是有问题的。</p> 
<h5>2.4 能者多劳 </h5> 
<p>在spring中有一个简单的配置，可以解决这个问题。我们修改consumer(消费者)服务的application.yml文件，添加配置：</p> 
<pre><code class="language-java">spring:
  rabbitmq:
    listener:
      simple:
        prefetch: 1 # 每次每个消费者只能获取一条消息，处理完成才能获取下一个消息</code></pre> 
<h5>2.5 总结</h5> 
<p>Work模型的使用：</p> 
<ul><li> <p>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理</p> </li><li> <p>通过设置prefetch(预取)来控制消费者预取的消息数量</p> </li></ul> 
<h4>3.发布订阅 </h4> 
<p class="img-center"><img alt="" height="262" src="https://images2.imgbox.com/a4/71/o4YjQRO3_o.png" width="813"></p> 
<p>可以看到，在订阅模型中，多了一个exchange角色，而且过程略有变化：</p> 
<ul><li> <p>Publisher：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）</p> </li><li> <p>Exchange：交换机。一方面，<strong>接收生产者发送的消息</strong>。另一方面，知道如何<strong>处理消息</strong>，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有以下3种类型：</p> 
  <ul><li> <p>Fanout：广播，将消息交给所有绑定到交换机的队列</p> </li><li> <p>Direct：定向，把消息交给符合指定routing(路由) key 的队列</p> </li><li> <p>Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</p> </li></ul></li><li> <p>Consumer：消费者，与以前一样，订阅队列，没有变化</p> </li><li> <p>Queue：消息队列也与以前一样，接收消息、缓存消息。</p> </li></ul> 
<p><span style="color:#fe2c24;"> Exchange（交换机）只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</span></p> 
<h4>4 .Fanout(广播，将消息交给所有绑定到交换机的队列)(第三种模型)</h4> 
<p>anout，英文翻译是扇出，我觉得在MQ中叫广播更合适。</p> 
<p class="img-center"><img alt="" height="245" src="https://images2.imgbox.com/30/68/zbER6VQn_o.png" width="844"></p> 
<p>在广播模式下，消息发送流程是这样的：</p> 
<ul><li> <p>1）  可以有多个队列</p> </li><li> <p>2）  每个队列都要绑定到Exchange（交换机）</p> </li><li> <p>3）  生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定</p> </li><li> <p>4）  交换机把消息发送给绑定过的所有队列</p> </li><li> <p>5）  订阅队列的消费者都能拿到消息</p> </li></ul> 
<p>我们的计划是这样的：</p> 
<ul><li> <p>创建一个交换机 itcast.fanout，类型是Fanout</p> </li><li> <p>创建两个队列fanout.queue1和fanout.queue2，绑定到交换机itcast.fanout</p> </li></ul> 
<p> <img alt="" height="186" src="https://images2.imgbox.com/c3/4b/eRxPjrfk_o.png" width="827"></p> 
<h5> 4.1 声明队列和交换机</h5> 
<p>Spring提供了一个接口Exchange，来表示所有不同类型的交换机：</p> 
<p class="img-center"><img alt="" height="258" src="https://images2.imgbox.com/d6/5c/9Ij05neU_o.png" width="786"></p> 
<p> 在consumer中创建一个类，声明队列和交换机：</p> 
<pre><code class="language-java">package cn.itcast.mq.config;

import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.BindingBuilder;
import org.springframework.amqp.core.FanoutExchange;
import org.springframework.amqp.core.Queue;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class FanoutConfig {
    /**
     * 声明交换机
     * @return Fanout类型交换机
     */
    @Bean
    public FanoutExchange fanoutExchange(){
        return new FanoutExchange("mq.fanout");
        //			类型				名称
    }

    /**
     * 第1个队列
     */
    @Bean
    public Queue fanoutQueue1(){
        return new Queue("fanout.queue1");
    }

    /**
     * 绑定队列和交换机
     */
    @Bean
    public Binding bindingQueue1(Queue fanoutQueue1, FanoutExchange fanoutExchange){
        return BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);
    }

    /**
     * 第2个队列
     */
    @Bean
    public Queue fanoutQueue2(){
        return new Queue("fanout.queue2");
    }

    /**
     * 绑定队列和交换机
     */
    @Bean
    public Binding bindingQueue2(Queue fanoutQueue2, FanoutExchange fanoutExchange){
        return BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);
    }
}</code></pre> 
<h5>4.2 消息发送</h5> 
<p>在publisher服务的SpringAmqpTest类中添加测试方法：</p> 
<pre><code class="language-java">@Test
public void testFanoutExchange() {
    // 交换机名称
    String exchangeName = "mq.fanout";
    // 消息
    String message = "hello, everyone!";
    rabbitTemplate.convertAndSend(exchangeName, "", message);
}</code></pre> 
<h5>4.3 消息接收</h5> 
<p>在consumer服务的SpringRabbitListener中添加两个方法，作为消费者：</p> 
<pre><code class="language-java">@RabbitListener(queues = "fanout.queue1")
public void listenFanoutQueue1(String msg) {
    System.out.println("消费者1接收到Fanout消息：【" + msg + "】");
}

@RabbitListener(queues = "fanout.queue2")
public void listenFanoutQueue2(String msg) {
    System.out.println("消费者2接收到Fanout消息：【" + msg + "】");
}</code></pre> 
<h5>4.4 总结</h5> 
<p>交换机的作用是什么？</p> 
<ul><li> <p>接收publisher发送的消息</p> </li><li> <p>将消息按照规则路由到与之绑定的队列</p> </li><li> <p>不能缓存消息，路由失败，消息丢失</p> </li><li> <p>FanoutExchange的会将消息路由到每个绑定的队列</p> </li></ul> 
<p>声明队列、交换机、绑定关系的Bean是什么？</p> 
<ul><li> <p>Queue(创建队列)</p> </li><li> <p>FanoutExchange(创建广播类型交换机)</p> </li><li> <p>Binding(将以上队列绑定到交换机)</p> </li></ul> 
<h4> 5.Direct(路由，把消息交给符合指定routing(路由) key 的队列)</h4> 
<p>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。</p> 
<p class="img-center"><img alt="" height="253" src="https://images2.imgbox.com/5e/a6/IU2QqIaw_o.png" width="816"></p> 
<p> </p> 
<p>在Direct模型下：</p> 
<ul><li> <p>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<span style="color:#4da8ee;"><strong><code>RoutingKey</code></strong></span>（路由key）</p> </li><li> <p>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 <span style="color:#4da8ee;"><strong><code>RoutingKey</code></strong></span>。</p> </li><li> <p>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<span style="color:#4da8ee;"><strong><code>RoutingKey</code></strong></span>进行判断，只有队列的<span style="color:#4da8ee;"><strong><code>Routingkey</code></strong></span>与消息的<span style="color:#4da8ee;"><strong><code>Routingkey</code></strong></span>完全一致，才会接收到消息</p> </li></ul> 
<p>案例需求如下：</p> 
<ol><li> <p>利用@RabbitListener声明Exchange、Queue、RoutingKey</p> </li><li> <p>在consumer服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2</p> </li><li> <p>在publisher中编写测试方法，向itcast. direct发送消息</p> </li></ol> 
<p class="img-center"><img alt="" height="310" src="https://images2.imgbox.com/92/45/CTq20qlx_o.png" width="823"></p> 
<h5> 5.1 基于注解声明队列和交换机(注意交换机要指定type)</h5> 
<p>基于@Bean的方式声明队列和交换机比较麻烦，Spring还提供了基于注解方式来声明。在consumer的SpringRabbitListener中添加两个消费者，同时基于注解来声明队列和交换机：</p> 
<pre><code class="language-java">@RabbitListener(bindings = @QueueBinding(
    value = @Queue(name = "direct.queue1"),
    exchange = @Exchange(name = "itcast.direct", type = ExchangeTypes.DIRECT),
    key = {"red", "blue"}
))
public void listenDirectQueue1(String msg){
    System.out.println("消费者接收到direct.queue1的消息：【" + msg + "】");
}

@RabbitListener(bindings = @QueueBinding(
    value = @Queue(name = "direct.queue2"),
    exchange = @Exchange(name = "itcast.direct", type = ExchangeTypes.DIRECT),
    key = {"red", "yellow"}
))
public void listenDirectQueue2(String msg){
    System.out.println("消费者接收到direct.queue2的消息：【" + msg + "】");
}</code></pre> 
<h5>5.2 消息发送</h5> 
<p>在publisher服务的SpringAmqpTest类中添加测试方法：</p> 
<pre><code class="language-java">@Test
public void testSendDirectExchange() {
    // 交换机名称
    String exchangeName = "itcast.direct";
    // 消息
    String message = "红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！";
    // 发送消息
    rabbitTemplate.convertAndSend(exchangeName, "red", message);
}</code></pre> 
<h5>5.3 总结</h5> 
<p>描述下Direct交换机与Fanout交换机的差异？</p> 
<ul><li> <p>Fanout交换机将消息路由给每一个与之绑定的队列</p> </li><li> <p>Direct交换机根据RoutingKey判断路由要给哪个队列</p> </li><li> <p>如果多个队列具有相同的RoutingKey，则与Fanout功能类似</p> </li></ul> 
<p>基于@RabbitListener注解声明队列和交换机有哪些常见注解？</p> 
<ul><li> <p><a href="/Queue" rel="nofollow">@Queue </a></p> </li><li> <p><a href="/Exchange" rel="nofollow">@Exchange </a></p> </li></ul> 
<h4>6. Topic(通配符，把消息交给符合routing pattern（路由模式） 的队列)</h4> 
<h5>6.1 说明</h5> 
<p><strong><code>Topic</code></strong>类型的<strong><code>Exchange</code></strong>与<strong><code>Direct</code></strong>相比，都是可以根据<strong><code>RoutingKey</code></strong>把消息路由到不同的队列。只不过<strong><code>Topic</code></strong>类型<strong><code>Exchange</code></strong>可以让队列在绑定<strong><code>Routing key</code> </strong>的时候使用通配符！<strong><code>Routingkey</code></strong> 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： <strong><code>item.insert</code></strong></p> 
<p>通配符规则：</p> 
<p><code>#</code>：匹配一个或多个词</p> 
<p><code>*</code>：匹配不多不少恰好1个词</p> 
<p>举例：<code>item.#</code>：能够匹配<code>item.spu.insert</code> 或者 <code>item.spu</code></p> 
<p><code>item.*</code>：只能匹配<code>item.spu</code></p> 
<p>图示:</p> 
<p class="img-center"><img alt="" height="276" src="https://images2.imgbox.com/c0/8b/rDSppCFR_o.png" width="802"></p> 
<p> </p> 
<p>解释：</p> 
<ul><li> <p>Queue1：绑定的是<code>china.#</code> ，因此凡是以 <code>china.</code>开头的<code>routing key</code> 都会被匹配到。包括china.news和china.weather</p> </li><li> <p>Queue2：绑定的是<code>#.news</code> ，因此凡是以 <code>.news</code>结尾的 <code>routing key</code> 都会被匹配。包括china.news和japan.news</p> </li></ul> 
<p>实现思路如下：</p> 
<ol><li> <p>并利用@RabbitListener声明Exchange、Queue、RoutingKey</p> </li><li> <p>在consumer服务中，编写两个消费者方法，分别监听topic.queue1和topic.queue2</p> </li><li> <p>在publisher中编写测试方法，向itcast. topic发送消息</p> </li></ol> 
<p> </p> 
<p class="img-center"><img alt="" height="241" src="https://images2.imgbox.com/12/03/zXk4RD4X_o.png" width="875"></p> 
<h5>6.2 消息发送 </h5> 
<p> 在publisher服务的SpringAmqpTest类中添加测试方法：</p> 
<pre><code class="language-java">/**
     * topicExchange
     */
@Test
public void testSendTopicExchange() {
    // 交换机名称
    String exchangeName = "itcast.topic";
    // 消息
    String message = "喜报！孙悟空大战哥斯拉，胜!";
    // 发送消息
    rabbitTemplate.convertAndSend(exchangeName, "china.news", message);
}</code></pre> 
<h5>6.3 消息接收</h5> 
<p>在consumer服务的SpringRabbitListener中添加方法：</p> 
<pre><code class="language-java">@RabbitListener(bindings = @QueueBinding(
    value = @Queue(name = "topic.queue1"),
    exchange = @Exchange(name = "itcast.topic", type = ExchangeTypes.TOPIC),
    key = "china.#"
))
public void listenTopicQueue1(String msg){
    System.out.println("消费者接收到topic.queue1的消息：【" + msg + "】");
}

@RabbitListener(bindings = @QueueBinding(
    value = @Queue(name = "topic.queue2"),
    exchange = @Exchange(name = "itcast.topic", type = ExchangeTypes.TOPIC),
    key = "#.news"
))
public void listenTopicQueue2(String msg){
    System.out.println("消费者接收到topic.queue2的消息：【" + msg + "】");
}</code></pre> 
<h5>6.4 总结</h5> 
<p>描述下Direct交换机与Topic交换机的差异？</p> 
<ul><li> <p><strong>Topic交换机接收的消息RoutingKey必须是多个单词</strong>，以 <code>**.**</code> 分割</p> </li><li> <p>Topic交换机与队列绑定时的bindingKey可以指定通配符</p> </li><li> <p><code>#</code>：代表0个或多个词</p> </li><li> <p><code>*</code>：代表1个词</p> </li></ul> 
<h4>7.消息转换器 </h4> 
<p>之前说过，Spring会把你发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。</p> 
<p class="img-center"><img alt="" height="194" src="https://images2.imgbox.com/04/e9/J7pxRx0m_o.png" width="786"></p> 
<p> </p> 
<p>只不过，默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题：</p> 
<ul><li> <p>数据体积过大</p> </li><li> <p>有安全漏洞</p> </li><li> <p>可读性差</p> </li></ul> 
<p>我们来测试一下。</p> 
<h5>7.1 测试默认转换器</h5> 
<p>我们修改消息发送的代码，发送一个Map对象：</p> 
<pre><code class="language-java">@Test
public void testSendMap() throws InterruptedException {
    // 准备消息
    Map&lt;String,Object&gt; msg = new HashMap&lt;&gt;();
    msg.put("name", "Jack");
    msg.put("age", 21);
    // 发送消息
    rabbitTemplate.convertAndSend("simple.queue", msg);
}</code></pre> 
<p> 停止consumer服务发送消息后查看控制台：</p> 
<p class="img-center"><img alt="" height="211" src="https://images2.imgbox.com/90/c5/ZT1TEFhq_o.png" width="782"></p> 
<h5> 7.2 配置JSON转换器</h5> 
<p>显然，JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。</p> 
<p>在publisher服务中都引入依赖：</p> 
<pre><code class="language-java">&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;
    &lt;version&gt;2.9.10&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<p>配置消息转换器。</p> 
<p>在消息发送方启动类中添加一个Bean即可：</p> 
<pre><code class="language-java">@Bean
public MessageConverter jsonMessageConverter(){
    return new Jackson2JsonMessageConverter();
}</code></pre> 
<p> </p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8416c07e9276733ed44495040484a9cb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Go语言开发利器：几种主流IDE的优势与应用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4cca953ff5e0266578d15046c6362391/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java中的contains方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>