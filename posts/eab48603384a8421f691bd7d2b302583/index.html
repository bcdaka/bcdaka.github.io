<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>初始Java篇（JavaSE基础语法）（6）（继承和多态）（下） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/eab48603384a8421f691bd7d2b302583/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="初始Java篇（JavaSE基础语法）（6）（继承和多态）（下）">
  <meta property="og:description" content="找往期文章包括但不限于本期文章中不懂的知识点：
个人主页：我要学编程(ಥ_ಥ)-CSDN博客
所属专栏：JavaSE
多态篇
目录
多态的概念
实现多态的条件 必须在继承体系下实现向上转型：
子类必须对父类中的方法进行重写：
通过父类引用调用重写方法：
多态的优缺点：
避免在父类的构造方法中调用重写的方法
多态的概念 通俗来说，就是多种形态，具体点就是去完成某个行为时，当不同的对象去完成时会产生出不同 的状态。
例如：同样是吃早餐，这个人可能是吃包子，饺子；另外一个人却是吃面条。这就是不同的对象去完成同一件事情时所表现出来的状态不同。
实现多态的条件 既然了解了什么是多态，接下来要知道什么情况下可以实现多态。
要想实现多态得满足以下三个条件：
1. 必须在继承体系下实现向上转型。
2. 子类必须对父类中的方法进行重写。
3. 通过父类引用调用重写方法。
下面就来解释这三个条件。
必须在继承体系下实现向上转型： 就是指一个是子类，一个是父类，然后把子类对象给到父类的引用。 注意：这里的体系，说明不一定是要在直系继承关系下，可以是通过中间类间接继承。
例如：
向上转型：把子类对象给到父类的引用。
向下转型：将一个子类对象经过向上转型之后当成父类方法使用，再无法调用子类的方法，但有时候可能需要调用子类特有的 方法，此时：将父类引用再还原为子类对象（强制类型转换）即可，即向下转换。简单理解就是把父类对象给到子类的引用。
结合该图理解 向上转型的语法格式：父类类型 名称 = new 子类类型(); 向下转型的语法格式与其差不多。
向上（向下）转型的应用场景：直接赋值、作为方法的参数、作为方法的返回值。、
例如：
//向上转型 public class Test { public static void func1(Animal animal) { System.out.println(&#34;向上转型的场景之一：方法参数&#34;); } public static Animal func2() { System.out.println(&#34;向上转型的应用场景之一：方法的返回值&#34;); Dog dog = new Dog(&#34;大黄&#34;, 5); return dog; //return new Dog(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-03T14:15:16+08:00">
    <meta property="article:modified_time" content="2024-05-03T14:15:16+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">初始Java篇（JavaSE基础语法）（6）（继承和多态）（下）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>找往期文章包括但不限于本期文章中不懂的知识点：</p> 
<blockquote> 
 <p><strong>个人主页</strong>：<a href="https://blog.csdn.net/2301_80854132?type=blog" title="我要学编程(ಥ_ಥ)-CSDN博客">我要学编程(ಥ_ಥ)-CSDN博客</a></p> 
 <p><strong>所属专栏：</strong><a class="link-info" href="https://blog.csdn.net/2301_80854132/category_12607527.html" title="JavaSE">JavaSE</a></p> 
</blockquote> 
<p>                                                                         多态篇</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%A4%9A%E6%80%81%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#%E5%A4%9A%E6%80%81%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">多态的概念</a></p> 
<p id="%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81%E7%9A%84%E6%9D%A1%E4%BB%B6%C2%A0-toc" style="margin-left:0px;"><a href="#%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81%E7%9A%84%E6%9D%A1%E4%BB%B6%C2%A0" rel="nofollow">实现多态的条件 </a></p> 
<p id="%E5%BF%85%E9%A1%BB%E5%9C%A8%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E4%B8%8B%E5%AE%9E%E7%8E%B0%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E5%BF%85%E9%A1%BB%E5%9C%A8%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E4%B8%8B%E5%AE%9E%E7%8E%B0%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%EF%BC%9A" rel="nofollow">必须在继承体系下实现向上转型：</a></p> 
<p id="%E5%AD%90%E7%B1%BB%E5%BF%85%E9%A1%BB%E5%AF%B9%E7%88%B6%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E9%87%8D%E5%86%99%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E5%AD%90%E7%B1%BB%E5%BF%85%E9%A1%BB%E5%AF%B9%E7%88%B6%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E9%87%8D%E5%86%99%EF%BC%9A" rel="nofollow">子类必须对父类中的方法进行重写：</a></p> 
<p id="%E9%80%9A%E8%BF%87%E7%88%B6%E7%B1%BB%E5%BC%95%E7%94%A8%E8%B0%83%E7%94%A8%E9%87%8D%E5%86%99%E6%96%B9%E6%B3%95%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E9%80%9A%E8%BF%87%E7%88%B6%E7%B1%BB%E5%BC%95%E7%94%A8%E8%B0%83%E7%94%A8%E9%87%8D%E5%86%99%E6%96%B9%E6%B3%95%EF%BC%9A" rel="nofollow">通过父类引用调用重写方法：</a></p> 
<p id="%E5%A4%9A%E6%80%81%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%A4%9A%E6%80%81%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A" rel="nofollow">多态的优缺点：</a></p> 
<p id="%E9%81%BF%E5%85%8D%E5%9C%A8%E7%88%B6%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%AD%E8%B0%83%E7%94%A8%E9%87%8D%E5%86%99%E7%9A%84%E6%96%B9%E6%B3%95-toc" style="margin-left:0px;"><a href="#%E9%81%BF%E5%85%8D%E5%9C%A8%E7%88%B6%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%AD%E8%B0%83%E7%94%A8%E9%87%8D%E5%86%99%E7%9A%84%E6%96%B9%E6%B3%95" rel="nofollow">避免在父类的构造方法中调用重写的方法</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E5%A4%9A%E6%80%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span style="color:#fe2c24;">多态的概念</span></h2> 
<p>通俗来说，就是多种形态，具体点就是去完成某个行为时，当不同的对象去完成时会产生出不同 的状态。</p> 
<p>例如：同样是吃早餐，这个人可能是吃包子，饺子；另外一个人却是吃面条。这就是不同的对象去完成同一件事情时所表现出来的状态不同。</p> 
<h2 id="%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81%E7%9A%84%E6%9D%A1%E4%BB%B6%C2%A0"><span style="color:#fe2c24;">实现多态的条件</span> </h2> 
<p>既然了解了什么是多态，接下来要知道什么情况下可以实现多态。</p> 
<p>要想实现多态得满足以下三个条件：</p> 
<blockquote> 
 <p>1. 必须在继承体系下实现向上转型。</p> 
 <p>2. 子类必须对父类中的方法进行重写。</p> 
 <p>3. 通过父类引用调用重写方法。</p> 
</blockquote> 
<p>下面就来解释这三个条件。</p> 
<h3 id="%E5%BF%85%E9%A1%BB%E5%9C%A8%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E4%B8%8B%E5%AE%9E%E7%8E%B0%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%EF%BC%9A"><span style="color:#38d8f0;"><strong>必须在继承体系下实现向上转型</strong>：</span></h3> 
<p>就是指一个是子类，一个是父类，然后把子类对象给到父类的引用。 注意：这里的体系，说明不一定是要在直系继承关系下，可以是通过中间类间接继承。</p> 
<p>例如：<img alt="" height="334" src="https://images2.imgbox.com/eb/84/vovFyey7_o.png" width="1015"></p> 
<p>向上转型：把子类对象给到父类的引用。</p> 
<p>向下转型：将一个子类对象经过向上转型之后当成父类方法使用，再无法调用子类的方法，但有时候可能需要调用子类特有的 方法，此时：将父类引用再还原为子类对象（强制类型转换）即可，即向下转换。简单理解就是把父类对象给到子类的引用。</p> 
<p><img alt="" height="1000" src="https://images2.imgbox.com/cf/89/vmy1dBhp_o.png" width="1200">                                                        结合该图理解 </p> 
<p>向上转型的语法格式：父类类型  名称  =  new  子类类型();   向下转型的语法格式与其差不多。</p> 
<p>向上（向下）转型的应用场景：直接赋值、作为方法的参数、作为方法的返回值。、</p> 
<p>例如：</p> 
<pre><code class="language-cs">//向上转型
public class Test {
    public static void func1(Animal animal) {
        System.out.println("向上转型的场景之一：方法参数");
    }
    public static Animal func2() {
        System.out.println("向上转型的应用场景之一：方法的返回值");
        Dog dog = new Dog("大黄", 5);
        return dog;
        //return new Dog("大黄", 5);
        //上面两种写法都可以
    }
    public static void main(String[] args) {
        Animal animal = new Dog("大黄", 8);//直接赋值
        animal.eat();
        func1(new Dog("大黄", 5));//也可以先实例化一个对象，再传参
        func2();
    }
}</code></pre> 
<p>向上转型的优点：让代码实现更简单灵活。</p> 
<p>向上转型的缺陷：不能调用到子类特有的方法。 </p> 
<p>向下转型相较于向上转型而言很不安全，因为向下转型的基础是向上转型，再把父类对象给到子类引用，而子类可能不是只有一个，但是父类只有一个。</p> 
<p>例如：狗类对象经过向上转型给到父类引用，再把这个父类引用当成对象给到猫类引用，这时就会报错。因为不安全，这也就是为什么向下转型不安全？因为不确定是原来的子类。</p> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        //向上转型
        Animal animal = new Dog("大黄", 5);
        //再把父类引用给到子类引用
        Cat cat = animal;
    }
}</code></pre> 
<p><img alt="" height="67" src="https://images2.imgbox.com/3d/73/q3CKzc2k_o.png" width="1200"></p> 
<p>这时就只能通过强制类型转换达到我们的目的。</p> 
<p><img alt="" height="765" src="https://images2.imgbox.com/6d/d8/AUP5LnwX_o.png" width="1200"> 很遗憾的是：强制类型转换也是做不到的。 </p> 
<p>那怎么样才能实现向下转型呢？很简单，通过同类型子类来转换。</p> 
<p>例如：先把Dog类型进行向上转型给到animal引用，再把animal引用强制转换为Dog类型再向下转型给Dog引用。</p> 
<p><img alt="" height="750" src="https://images2.imgbox.com/ce/f4/2sFQ5ejY_o.png" width="1200"></p> 
<h3 id="%E5%AD%90%E7%B1%BB%E5%BF%85%E9%A1%BB%E5%AF%B9%E7%88%B6%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E9%87%8D%E5%86%99%EF%BC%9A"><span style="color:#38d8f0;"><strong>子类必须对父类中的方法进行重写</strong>：</span></h3> 
<p>首先，得了解什么是重写？</p> 
<p><span style="color:#ff9900;">重写（override）</span>：也称为覆盖，是子类对父类中非静态、非private修饰、非final修饰、非构造的方法进行重新编写。重写之后的方法与原来的方法相比：在参数列表、方法名、返回值都要一致。即外壳不变，核心重写。</p> 
<p>例如：<img alt="" height="802" src="https://images2.imgbox.com/9e/eb/eemIoDtu_o.png" width="949"></p> 
<p>注意：</p> 
<p>1. 当重写的方法返回值与原来的方法返回值构成父子（继承）关系时，这时返回值就可以不一样。这里的父子（继承）关系同样可以不是直系关系。</p> 
<p>例如：<img alt="" height="906" src="https://images2.imgbox.com/e4/10/NqmU4Jgm_o.png" width="1189"></p> 
<p>上面特殊情况这种在Java叫：协变类型。 </p> 
<p>2. 子类中的重写方法的访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类方法被public修饰，则子类中重写该方法就不能声明为 protected。</p> 
<p><img alt="" height="895" src="https://images2.imgbox.com/46/5f/TuuHhvCv_o.png" width="1141"></p> 
<p>3. 重写的方法, 可以使用 @Override 注解来显式指定。有了这个注解能帮我们进行一些合法性校验。例如不小心将方法名字拼写错了 (比如写成 aet), 那么此时编译器就会发现父类中没有 aet 方法，就会编译报错，提示无法构成重写。</p> 
<p><img alt="" height="993" src="https://images2.imgbox.com/2b/9b/AKGtkWGs_o.png" width="1200"></p> 
<p>这个重写和我们前面在学习方法的重载时有点类似。下面就来比较两者之间的区别。</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><caption>
   方法重写和方法重载的区别 
 </caption><tbody><tr><td>区别处</td><td>方法重写（override）</td><td>方法重载（overload）</td></tr><tr><td>参数列表</td><td>必须一样</td><td>必须不一样</td></tr><tr><td>返回值</td><td>除继承关系外，其余时都得一致</td><td>未规定（可以一样，可以不一样）</td></tr><tr><td>适用范围</td><td>存在继承关系的类中</td><td>所有类</td></tr><tr><td>目的性</td><td>实现多态性，子类可以根据自身需求对父类方法进行特定实现</td><td>提供多个功能相似但参数不同的方法，方便调用者根据不同情况选择合适的方法</td></tr></tbody></table> 
<p>简单理解：方法重载是一个类的不同表现,而方法重写是子类与父类的一种不同表现。</p> 
<blockquote> 
 <p>【重写的设计原则】 对于已经投入使用的类，尽量不要进行修改。最好的方式是：重新定义一个新的类，来重复利用其中共性的内容， 并且添加或者改动新的内容。</p> 
 <p>例如：若干年前的手机，只能打电话，发短信，来电显示只能显示号码，而今天的手机在来电显示的时候，不仅仅 可以显示号码，还可以显示头像，地区等。在这个过程当中，我们不应该在原来老的类上进行修改，因为原来的类，可能还在有用户使用，正确做法是：新建一个新手机的类，对来电显示这个方法重写就好了，这样就达到了我们当今的需求了。 </p> 
</blockquote> 
<p>第二点，我们刚刚也在代码中体会到了：何为子类必须对父类的方法进行重写。 </p> 
<h3 id="%E9%80%9A%E8%BF%87%E7%88%B6%E7%B1%BB%E5%BC%95%E7%94%A8%E8%B0%83%E7%94%A8%E9%87%8D%E5%86%99%E6%96%B9%E6%B3%95%EF%BC%9A"><span style="color:#38d8f0;"><strong>通过父类引用调用重写方法</strong>：</span></h3> 
<p><img alt="" height="332" src="https://images2.imgbox.com/43/32/mg95ayqR_o.png" width="1073"></p> 
<pre><code class="language-java">class Animal  {
    public String name;
    public int age;
    public void eat() {
        System.out.println(this.name+" 正在吃放！");
    }
}

class Dog extends Animal{
    @Override
    public void eat() {
        System.out.println(this.name+" 正在吃狗粮！");
    }
    public Dog(String name, int age) {
        super();
        this.name = name;
        this.age = age;
    }
}

public class Test {
    public static void main(String[] args) {
        Animal animal = new Dog("大黄", 8);
        animal.eat();
    }
}</code></pre> 
<p>上面三步完成之后，就会发生动态绑定。 而动态绑定是多态的基础。</p> 
<p><img alt="" height="473" src="https://images2.imgbox.com/0c/58/ACAzeXVp_o.png" width="1187"></p> 
<p>静态绑定：也称为前期绑定(早绑定)，即在编译时，根据用户所传递实参类型就确定了具体调用那个方法。典型代表方法重载。</p> 
<p>动态绑定：也称为后期绑定(晚绑定、运行时绑定)，即在编译时，不能确定方法的行为，需要等到程序运行时，才能够确定具体调用那个类的方法。典型代表多态。</p> 
<h2 id="%E5%A4%9A%E6%80%81%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A"><span style="color:#fe2c24;">多态的优缺点：</span></h2> 
<p><strong>1. 能够降低代码的 "圈复杂度", 避免使用大量的 if - else 。</strong></p> 
<blockquote> 
 <p>什么叫 "圈复杂度" ? 圈复杂度是一种描述一段代码复杂程度的方式。一段代码如果平铺直叙, 那么就比较简单容易理解。而如果有很多的条件分支或者循环语句, 就认为理解起来更复杂. 因此我们可以简单粗暴的计算一段代码中条件语句和循环语句出现的个数, 这个个数就称为 "圈复杂度"。如果一个方法的圈复杂度太高, 就需要考虑重构。不同公司对于代码的圈复杂度的规范不一样，一般不会超过 10 。</p> 
</blockquote> 
<p>例如：我们现在需要打印的不是一个形状了，而是多个形状。如果不基于多态，我们就只能通过if - else语句来进行打印。</p> 
<pre><code class="language-cs">//画一个圆
class Round {
    public void draw() {
        System.out.println("○");
    }
}

//画一个正方形
class Square {
    public void draw() {
        System.out.println("□");
    }
}

//画一个三角形
class Triangular {
    public void draw() {
        System.out.println("△");
    }
}


public class Test {
    public static void main(String[] args) {
        Round round = new Round();
        Square square = new Square();
        Triangular triangular = new Triangular();
        String[] shapes = {"round", "square", "triangular"};
        //开始判断需要画什么样的图形
        for (String shape:shapes) {
            if (shape.equals("round")) {
                round.draw();
            }else if (shape.equals("square")) {
                square.draw();;
            }else if (shape.equals("triangular")) {
                triangular.draw();
        }
    }
}
</code></pre> 
<p>在Java中，判断两个字符串是否相等，应该使用 <code>equals()</code> 方法。这个方法比较的是字符串的内容，即两个字符串所包含的字符序列是否完全相同。这里有一个简单的示例：</p> 
<pre><code class="language-cs">//语法格式：字符串1.equals(字符串2); —— 得到的结果是布尔类型
public class Test {
    public static void main(String[] args) {
        String str1 = "hello";
        String str2 = "hello";
        String str3 = "world";

        boolean areEqual = str1.equals(str2); //使用equals()方法比较字符串内容
        System.out.println("str1 和 str2 是否相等? " + areEqual);

        areEqual = str1.equals(str3); //比较str1和str3
        System.out.println("str1 和 str3 是否相等? " + areEqual);
    }
}</code></pre> 
<p>注意：使用 <code>==</code> 操作符是比较两个字符串对象的引用是否相同，而不是比较它们的值是否相等。因此，通常情况下不推荐使用 <code>==</code> 来比较字符串内容。只有在确保两个字符串引用指向同一对象时（例如，它们都是同一个字符串字面量的引用），使用 <code>==</code> 才能得出正确的结果。</p> 
<p>基于多态来打印图形。</p> 
<pre><code class="language-java">//画一个图形的父类
class Shape {
    public void draw() {
        System.out.println("画一个图形！");
    }
}

//画一个圆
class Round extends Shape{
    //重写父类方法
    @Override
    public void draw() {
        System.out.println("○");
    }
}

//画一个正方形
class Square extends Shape{
    //重写父类方法
    @Override
    public void draw() {
        System.out.println("□");
    }
}

//画一个三角形
class Triangular extends Shape{
    //重写父类方法
    @Override
    public void draw() {
        System.out.println("△");
    }
}

public class Test {
    public static void main(String[] args) {
        //向上转型
        Shape[] shapes = {new Round(), new Square(), new Triangular()};
        for (Shape shape : shapes) {
            shape.draw();//通过父类引用调用重写方法
        }
    }
}</code></pre> 
<p>这里的shape.draw();就相当于shapes[i].draw。也就是通过父类引用调用重写方法。</p> 
<p><strong>2. 可扩展能力更强 如果要新增一种新的形状, 使用多态的方式代码改动成本也比较低。</strong></p> 
<p>只需要新增一个类就可以了，而不使用多态的话，就得新增if-else语句来判断。</p> 
<p><strong>多态缺陷</strong>：代码的运行效率降低。</p> 
<p>1. 属性没有多态性 当父类和子类都有同名属性的时候，通过父类引用，只能引用父类自己的成员属性。</p> 
<p>2. 构造方法没有多态性。</p> 
<h2 id="%E9%81%BF%E5%85%8D%E5%9C%A8%E7%88%B6%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%AD%E8%B0%83%E7%94%A8%E9%87%8D%E5%86%99%E7%9A%84%E6%96%B9%E6%B3%95"><span style="color:#fe2c24;">避免在父类的构造方法中调用重写的方法</span></h2> 
<pre><code class="language-java">class A {
    public A() {
        //在父类的构造方法中调用被重写的方法会发生动态绑定
        func();
    }
    public void func() {
        System.out.println("这是父类A的方法");
    }
}

class B extends A {
    @Override
    public void func() {
        System.out.println("这是子类B的方法");
    }
}

public class Test {
    public static void main(String[] args) {
        B b = new B();
    }
}</code></pre> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/bf/c0/TGDryLVI_o.png" width="1200"></p> 
<p>通过前面的学习，我们已经知道了：在实例化子类对象时，先帮助父类执行构造方法。</p> 
<p>而在父类中的构造方法中，如果调用了被重写的方法，此时就会发生动态绑定。</p> 
<p> 注意：如果此时子类重写的方法中存在成员变量，这个成员变量不会被初始化成我们想要的值，但是会有默认值。因为在调用子类的重写方法时，父类的构造方法都没有完成，自然其他的都还没有进行的。</p> 
<p>可能有小伙伴有疑惑：哪里有通过父类引用调用被重写的方法？哪里有发生向上转型？</p> 
<p>至于提到的“哪里有通过父类引用调用被重写的方法”，这通常不是直接在构造方法上下文中讨论的，而是更普遍地出现在多态的应用场景中。但构造方法内部调用非静态、非私有、非final的方法时，实际上也间接体现了这一点，因为尽管直接调用看似是父类方法，但由于动态绑定，最终执行的是子类的方法体。这里的关键是理解，即使调用点在父类构造器内，实际的对象身份（即内存中的对象）已经是子类的实例。</p> 
<p>至于“哪里有发生向上转型”，向上转型是当你用父类的引用指向子类的对象时自然发生的现象。在构造方法调用的场景中，虽然没有直接的显式向上转型（比如 <code>Parent p = new Child();</code>），但实际上，<strong>当子类构造方法调用父类构造方法时，可以视为一种隐式的向上转型</strong>，因为父类构造器中的<code>this</code>引用在构造子类对象的上下文中代表了一个子类实例。在这个过程中，父类构造器内的代码通过这个<code>this</code>引用间接地操作了子类对象，而当它调用一个可被子类重写的方法时，就涉及到了动态绑定，这也是向上转型和动态绑定交互作用的一个体现。</p> 
<p>其实暂时就只要知道不要在父类的构造方法中调用被重写的方法就可以了。随着我们学习的深入就会理解了。</p> 
<p>好啦！本期初始Java篇（JavaSE基础语法）（6）（继承和多态）（下）的学习之旅就到此结束了！下一期我们再一起学习吧！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ae9a448f298ce5138af897f0e1fb0762/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SpringBoot @DS注解 和 DynamicDataSource自定义实现多数据源的2种实现方式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2a0052be8c11c61150339ad28e2b9c77/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">利用Knife4j注解实现Java生成接口文档</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>