<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java之多线程篇 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/717f95121aeefe52861c1bab36926a94/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="java之多线程篇">
  <meta property="og:description" content="一、基本概念 1.什么是线程？
线程就是，操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。简单理解就是：应用软件中互相独立，可以同时运行的功能
2.什么是多线程？
有了多线程，我们就可以让程序同时做多件事情
3.多线程的作用？
提高效率
4.线程的应用场景？
只要你想让多个事情同时运行就需要用到多线程
比如：软件中的耗时操作、所有的聊天软件、所有的服务器
二、并发和并行的概念 1.什么是并发？
并发就是，同一时刻，有多个指令在单个CPU上交替执行。
2.什么是并行？
并行就是，同一时刻，有多个指令在多个CPU上同时执行
3.电脑不是只有一个CPU么，这个多个CPU同时执行的并行究竟是什么？
其实，CPU在市面有很多类型如下
比如2核4线程的CPU，就可以同时运行4个线程的任务。
三、多线程的实现方式（3种） 1.继承Thread类的方式进行实现 用法：
1.定义一个类继承Thread类
2.这个类重写run方法
3.在main方法里面创建定义的类的对象
4.通过该对象的.start()方法启动线程
示例代码
public class ThreadDemo1 { public static void main(String[] args) { MyThread myThread1 = new MyThread(); MyThread myThread2 = new MyThread(); myThread1.setName(&#34;线程1&#34;); myThread2.setName(&#34;线程2&#34;); myThread1.start(); myThread2.start(); } } class MyThread extends Thread{ @Override public void run(){ for(int i=0;i&lt;100;i&#43;&#43;){ System.out.println(Thread.currentThread().getName()&#43;&#34; &#34;&#43;i); } } } 上面的两个线程的代码run方法是同时执行的，并不会等一个线程的循环走完。
注意：线程类开启后执行的是run方法的代码 2.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-06T23:58:07+08:00">
    <meta property="article:modified_time" content="2024-08-06T23:58:07+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java之多线程篇</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、基本概念</h2> 
<blockquote> 
 <p><strong>1.什么是线程？</strong></p> 
 <p>线程就是，操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。简单理解就是：应用软件中互相独立，可以同时运行的功能</p> 
 <p><strong>2.什么是多线程？</strong></p> 
 <p>有了多线程，我们就可以让程序同时做多件事情</p> 
 <p><strong>3.多线程的作用？</strong></p> 
 <p>提高效率</p> 
 <p><strong>4.线程的应用场景？</strong></p> 
 <p>只要你想让多个事情同时运行就需要用到多线程</p> 
 <p>比如：软件中的耗时操作、所有的聊天软件、所有的服务器</p> 
</blockquote> 
<h2 id="%E4%BA%8C%E3%80%81%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C%E7%9A%84%E6%A6%82%E5%BF%B5">二、并发和并行的概念</h2> 
<blockquote> 
 <p><strong>1.什么是并发？</strong></p> 
 <p>并发就是，同一时刻，有多个指令在单个CPU上交替执行。</p> 
 <p><strong>2.什么是并行？</strong></p> 
 <p>并行就是，同一时刻，有多个指令在多个CPU上同时执行</p> 
</blockquote> 
<blockquote> 
 <p><strong>3.电脑不是只有一个CPU么，这个多个CPU同时执行的并行究竟是什么？</strong></p> 
 <p>其实，CPU在市面有很多类型如下</p> 
 <p><img alt="" height="653" src="https://images2.imgbox.com/09/66/DkAZQ7ik_o.png" width="921"></p> 
 <p>比如2核4线程的CPU，就可以同时运行4个线程的任务。</p> 
</blockquote> 
<h2 id="%E4%B8%89%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%883%E7%A7%8D%EF%BC%89%C2%A0">三、多线程的实现方式（3种） </h2> 
<h3 id="1.%E7%BB%A7%E6%89%BFThread%E7%B1%BB%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%AE%9E%E7%8E%B0">1.继承Thread类的方式进行实现</h3> 
<blockquote> 
 <p><strong>用法：</strong></p> 
 <p><strong>1.定义一个类继承Thread类</strong></p> 
 <p><strong>2.这个类重写run方法</strong></p> 
 <p><strong>3.在main方法里面创建定义的类的对象</strong></p> 
 <p><strong>4.通过该对象的.start()方法启动线程</strong></p> 
</blockquote> 
<blockquote> 
 <p><strong>示例代码</strong></p> 
 <pre><code class="language-java">public class ThreadDemo1 {
    public static void main(String[] args) {
        MyThread myThread1 = new MyThread();
        MyThread myThread2 = new MyThread();
        myThread1.setName("线程1");
        myThread2.setName("线程2");
        myThread1.start();
        myThread2.start();
    }
}
class MyThread extends Thread{
    @Override
    public void run(){
        for(int i=0;i&lt;100;i++){
            System.out.println(Thread.currentThread().getName()+" "+i);
        }
    }
}</code></pre> 
 <p>上面的两个线程的代码run方法是同时执行的，并不会等一个线程的循环走完。</p> 
 <p><img alt="" height="210" src="https://images2.imgbox.com/2d/d9/1mNMCU1U_o.png" width="540"></p> 
 <p><span style="color:#fe2c24;">注意：</span>线程类开启后执行的是run方法的代码 </p> 
</blockquote> 
<h3 id="2.%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%AE%9E%E7%8E%B0">2.实现Runnable接口的方式进行实现</h3> 
<blockquote> 
 <p><strong>用法：</strong></p> 
 <p><strong>1.自己定义一个类实现Runnable接口</strong></p> 
 <p><strong>2.重写里面的run方法</strong></p> 
 <p><strong>3.在main方法创建自己的类的对象</strong></p> 
 <p><strong>4.将定义的类传递给Thread构造方法创建一个Thread类的对象，并开启线程</strong></p> 
</blockquote> 
<blockquote> 
 <p><strong>示例 </strong></p> 
 <pre><code class="language-java">public class ThreadDemo2 {
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        Thread thread1 = new Thread(myThread);
        Thread thread2 = new Thread(myThread);
        thread1.setName("线程1");
        thread2.setName("线程2");
        thread2.start();
        thread1.start();
    }
}
class MyThread implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i &lt; 100; i++) {
            System.out.println(Thread.currentThread().getName()+"--&gt;"+i);
        }
    }
}</code></pre> 
</blockquote> 
<h3 id="3.%E5%88%A9%E7%94%A8Callable%E6%8E%A5%E5%8F%A3%E5%92%8CFuture%E6%8E%A5%E5%8F%A3%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0" style="background-color:transparent;">3.利用Callable接口和Future接口方式实现</h3> 
<p>前面两种实现方式，run方法没有返回值，不知道线程实现的结果，现在这个第三种方法是有返回值的。</p> 
<blockquote> 
 <p><strong>用法：</strong></p> 
 <p><strong>1.创建一个类MyCallable实现callable接口</strong></p> 
 <p><strong>2.重写call（是有返回值的，表示多线程运行的结果）</strong></p> 
 <p><strong>3.创建MyCallable的对象（表示多线程要执行的任务）</strong></p> 
 <p><strong>4.传递MyCallable对象为参数创建FutureTask的对象（作用管理多线程运行的结果）</strong></p> 
 <p><strong>5.传递FutureTask对象为参数创建Thread类的对象，并启动（表示线程）</strong></p> 
</blockquote> 
<blockquote> 
 <p><strong> 示例</strong></p> 
 <pre><code class="language-java">public class ThreadDemo3 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        MyCallable mc = new MyCallable();
        FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(mc);
        Thread t = new Thread(ft);
        t.start();
        System.out.println(ft.get());
    }
}
class MyCallable implements Callable&lt;Integer&gt; {
    @Override
    public Integer call() throws Exception {
        int sum = 0;
        for (int i = 0; i &lt;= 100; i++) {
            sum += i;
        }
        return sum;
    }
}</code></pre> 
 <p>结果输出5050</p> 
</blockquote> 
<h3 id="4.%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83%C2%A0">4.三种方式的比较 </h3> 
<p><img alt="" height="319" src="https://images2.imgbox.com/5a/85/jxdGXMqi_o.png" width="1200"></p> 
<h2 id="%E5%9B%9B%E3%80%81Thread%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95">四、Thread类的常用成员方法</h2> 
<h3 id="1.%E4%B8%83%E4%B8%AA%E6%96%B9%E6%B3%95" style="background-color:transparent;">1.七个方法</h3> 
<p><img alt="" height="727" src="https://images2.imgbox.com/8d/2f/g30BELQc_o.png" width="1200"></p> 
<h3 id="2.%E5%89%8D%E5%9B%9B%E4%B8%AA%E7%BB%86%E8%8A%82">2.前四个细节</h3> 
<blockquote> 
 <p><strong>String getName()</strong></p> 
 <p><strong>void setName(String name)</strong></p> 
 <p>细节：</p> 
 <p>        1. 果我们没有给线程设置名字，线程也是有默认的名字的</p> 
 <p>                格式：Thread-X（X序号，从0开始的）</p> 
 <p>        2.如果我们要给线程设置名字，可以用set方法进行设置，也可以构造方法设置</p> 
 <p></p> 
 <p><strong>static Thread currentThread()</strong></p> 
 <p>细节：</p> 
 <p>        当JVM虚拟机启动之后，会自动的启动多条线程</p> 
 <p>        其中有一条线程就叫做main线程</p> 
 <p>        他的作用就是去调用main方法，并执行里面的代码</p> 
 <p>        在以前，我们写的所有的代码，其实都是运行在main线程当中</p> 
 <p></p> 
 <p><strong>static void sleep(long time)   </strong></p> 
 <p>细节：</p> 
 <p>        1.哪条线程执行到这个方法，那么哪条线程就会在这里停留对应的时间</p> 
 <p>        2.方法的参数：就表示睡眠的时间，单位毫秒</p> 
 <p>                1秒 = 1000毫秒</p> 
 <p>        3.时间到了之后，线程会自动的醒来，继续执行下面的其他代码</p> 
</blockquote> 
<h3 id="%C2%A03.%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7" style="background-color:transparent;"> 3.线程的优先级</h3> 
<h4 id="%EF%BC%881%EF%BC%89%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6" style="background-color:transparent;">（1）线程调度</h4> 
<blockquote> 
 <p><strong>抢占式调度：</strong>各条线程执行的顺序和时间是不确定的<span style="color:#fe2c24;">（随机）</span></p> 
 <p><strong>非抢占式调度：</strong>各条线程执行的顺序是轮流执行和执行时间是差不多的</p> 
 <p><u>java中是选取第一种抢占式调度</u></p> 
</blockquote> 
<h4 id="%EF%BC%882%EF%BC%89%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%881~10%EF%BC%89">（2）优先级（1~10）</h4> 
<blockquote> 
 <p>抢占式调度就要涉及到线程的优先级越大，执行的顺序越前</p> 
 <p><img alt="" height="84" src="https://images2.imgbox.com/4f/c9/Kem9KpTl_o.png" width="853"></p> 
 <p>于是可以通过Thread类的上面的两个成员方法来设置和获取线程的优先级</p> 
 <p>没有设置默认就是5</p> 
 <p><strong>注意：</strong>这里的优先级是指优先级大的线程<span style="color:#fe2c24;">先执行的概率比较大，而不是百分百，</span>比如说有两个一样的方法的线程，优先大的线程是有<strong>概率计较大</strong>的先执行完，但还是有<strong>小概率</strong>执行慢</p> 
</blockquote> 
<h3 id="%C2%A04.%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B" style="background-color:transparent;"> 4.守护线程</h3> 
<blockquote> 
 <p>当一个线程使用Thread类的etDaemon(boolean on)时，这个线程变成守护线程。</p> 
 <p><strong>细节：</strong></p> 
 <p>这个线程也可以叫做“备胎”线程，它将其他线程视为“女神”线程，当其他线程结束的时候，这个守护线程就会陆续结束，觉得自己没必要存在了，这就会可能导致守护线程的代码没有全部执行完。</p> 
</blockquote> 
<blockquote> 
 <p><strong>应用场景</strong></p> 
 <p><img alt="" height="415" src="https://images2.imgbox.com/19/04/WfBZJLAJ_o.png" width="1146"> 上面聊天的场景，两个人聊天开两个线程，一个聊天，一个传输文件，如果聊天线程关闭了，就没有传输文件的必要了，于是将传输文件的线程设置为守护线程。</p> 
</blockquote> 
<h3 id="%C2%A05.%E5%87%BA%E8%AE%A9%2F%E7%A4%BC%E8%AE%A9%E7%BA%BF%E7%A8%8B"> 5.出让/礼让线程</h3> 
<blockquote> 
 <p>在当前线程的工作不重要时，将CPU资源让位给其他线程，通过使用Thread类的<code>yield()</code>方法来将当前资源让位给其他同优先级线程</p> 
 <pre><code class="language-java">public static void main(String[] args) {
    Thread t1 = new Thread(() -&gt; {
        System.out.println("线程1开始运行！");
        for (int i = 0; i &lt; 50; i++) {
            if(i % 5 == 0) {
                System.out.println("让位！");
                Thread.yield();
            }
            System.out.println("1打印："+i);
        }
        System.out.println("线程1结束！");
    });
    Thread t2 = new Thread(() -&gt; {
        System.out.println("线程2开始运行！");
        for (int i = 0; i &lt; 50; i++) {
            System.out.println("2打印："+i);
        }
    });
    t1.start();
    t2.start();
}</code></pre> 
 <p>观察结果，我们发现，在让位之后，尽可能多的在执行线程2的内容。 </p> 
</blockquote> 
<h3 id="6.%E6%8F%92%E5%85%A5%E7%BA%BF%E7%A8%8B">6.插入线程</h3> 
<blockquote> 
 <p>当我们希望一个线程等待另一个线程执行完成后再继续进行，我们可以使用Thread类的<code>join()</code>方法来实现线程的插入。</p> 
 <pre><code class="language-java">public static void main(String[] args) {
    Thread t1 = new Thread(() -&gt; {
        System.out.println("线程1开始运行！");
        for (int i = 0; i &lt; 50; i++) {
            System.out.println("1打印："+i);
        }
        System.out.println("线程1结束！");
    });
    Thread t2 = new Thread(() -&gt; {
        System.out.println("线程2开始运行！");
        for (int i = 0; i &lt; 50; i++) {
            System.out.println("2打印："+i);
            if(i == 10){
                try {
                    System.out.println("线程1加入到此线程！");
                    t1.join();    //在i==10时，让线程1加入，先完成线程1的内容，再继续当前内容
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    });
    t1.start();
    t2.start();
}</code></pre> 
 <p>线程2执行一半，线程1加入，先完成线程1的内容，再继续线程2的内容 </p> 
</blockquote> 
<h2 id="%E4%BA%94%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">五、线程的生命周期</h2> 
<p><img alt="" height="652" src="https://images2.imgbox.com/38/8b/hmZplRMb_o.png" width="1200"></p> 
<h2 id="%C2%A0%E5%85%AD%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98" style="background-color:transparent;"> 六、线程的安全问题</h2> 
<h3 id="1.%E5%94%AE%E7%A5%A8%E4%BB%A3%E7%A0%81%E5%BC%95%E5%87%BA%E9%97%AE%E9%A2%98" style="background-color:transparent;">1.售票代码引出问题</h3> 
<blockquote> 
 <p>有100张票售卖，一共3个窗口在卖。</p> 
 <p>下面代码设置三个线程当作三个卖票的窗口，看看有什么问题</p> 
 <pre><code class="language-java">public class ThreadSafetyProblem {
    public static void main(String[] args) {
        MyThread1 myThread1 = new MyThread1();
        MyThread1 myThread2 = new MyThread1();
        MyThread1 myThread3 = new MyThread1();
        myThread1.setName("窗口1");
        myThread2.setName("窗口2");
        myThread3.setName("窗口3");
        myThread1.start();
        myThread2.start();
        myThread3.start();
    }
}
class MyThread1 extends Thread{
    //静态变量，几个线程共享
    private static int count = 0;
    public void run(){
        while(true){
            try {//这里只能try-catch丢给JVM，不能throws
                Thread.sleep(100);    //因为父类的run方法没有throws
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            if (count &lt; 100){
                System.out.println(Thread.currentThread().getName() + "正在卖第" + ++count+"张票");
            }else{
                break;
            }
        }
    }
}
</code></pre> 
 <p> </p> 
</blockquote> 
<h3 id="%C2%A02.%E8%B6%85%E5%8D%96%E5%92%8C%E9%87%8D%E5%A4%8D%E5%8D%96%E9%97%AE%E9%A2%98" style="background-color:transparent;"> 2.超卖和重复卖问题</h3> 
<p>运行后出现的问题结果如下图：</p> 
<blockquote> 
 <p>三个窗口在同时卖一张票，不合法！</p> 
 <p><img alt="" height="173" src="https://images2.imgbox.com/bf/4c/Kd1w0gDC_o.png" width="342"></p> 
</blockquote> 
<blockquote> 
 <p>超卖了，仅有100张票 </p> 
 <p><img alt="" height="84" src="https://images2.imgbox.com/0e/36/6iDAQPTu_o.png" width="306"> </p> 
</blockquote> 
<blockquote> 
 <p><strong>原因</strong></p> 
 <p><strong>线程的执行是有随机性的，cpu的执行权有可能被其他线程抢走。</strong></p> 
 <p><strong>线程1执行完票数的自增还没来得及打印的时候，线程2和线程3完成自增就会导致超卖和重复卖 </strong></p> 
</blockquote> 
<blockquote> 
 <p><strong>那么要怎么解决这个安全问题呢？下一个点就会讲到解决的方法之一——同步代码块。</strong></p> 
</blockquote> 
<h2 id="%C2%A0%E4%B8%83%E3%80%81%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97" style="background-color:transparent;"> 七、同步代码块</h2> 
<p><span style="color:#fe2c24;"><strong>同步代码块的意思就是，把操作共享数据的代码锁起来</strong></span></p> 
<h3 id="1.%E6%A0%BC%E5%BC%8F" style="background-color:transparent;"><strong>1.格式</strong></h3> 
<blockquote> 
 <p><strong>synchronized(锁){<!-- --></strong></p> 
 <p><strong>        操作共享数据的代码</strong></p> 
 <p><strong>}</strong></p> 
</blockquote> 
<blockquote> 
 <p><strong> 特点：</strong></p> 
 <p>        1.锁默认打开，有一个线程进去了，锁自动关闭</p> 
 <p>        2.里面的代码全部执行完毕，线程出来，锁自动打开</p> 
</blockquote> 
<h3 id="2.%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84%E5%94%AE%E7%A5%A8%E4%BB%A3%E7%A0%81%C2%A0">2.修改后的售票代码 </h3> 
<blockquote> 
 <pre><code class="language-java">class MyThread1 extends Thread{
    //静态变量，几个线程共享
    private static int count = 0;
    //锁对象，一定要是唯一的
    static Object obj = new Object();
    public void run(){
        while(true){
            //同步代码块
            synchronized (obj){
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                if (count &lt; 2000){
                    System.out.println(Thread.currentThread().getName() + "正在卖第" + ++count+"张票");
                }else {
                    break;
                }
            }
        }
    }
}</code></pre> 
 <p>运行后的结果，票正常售卖，从第一张卖到最后一张。 </p> 
</blockquote> 
<h3 id="3.%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98">3.细节问题</h3> 
<blockquote> 
 <p><strong>细节1：</strong>同步代码块不能放在while循环里面，因为放在外的话，一个线程拿到锁后就会必须把循环执行完，才会释放锁，这样的话一个线程就把票都卖完了。</p> 
 <p><strong>细节2：</strong>锁的对象必须是唯一的，修改后的代码的锁是一个Object对象，用static修饰后表示全局共享唯一的对象。也可以使用MyThread.class表示唯一的字节码文件对象</p> 
</blockquote> 
<h2 id="%E5%85%AB%E3%80%81%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%C2%A0">八、同步方法 </h2> 
<blockquote> 
 <p><strong>如果我们要锁的代码是整个方法，这个时候就要用到同步方法了</strong></p> 
 <p><strong>就是把synchronized关键字加到方法上</strong></p> 
</blockquote> 
<h3>1.格式</h3> 
<p> 修饰符  synchronized  返回值类型  方法名（方法参数）{….}</p> 
<h3 id="2.%E7%89%B9%E7%82%B9" style="background-color:transparent;">2.特点</h3> 
<blockquote> 
 <p><strong>特点1：</strong>同步方法是锁住方法里面所有的代码</p> 
 <p><strong>特点2：</strong>锁对象不能自己指定，如果方法是非静态的，锁对象就是方法所在类对象this</p> 
 <p>                                                 如果方法是静态的，锁对象就是当前类的字节码文件对象</p> 
</blockquote> 
<h3 id="3.%E4%BD%BF%E7%94%A8%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E8%A7%A3%E5%86%B3%E5%94%AE%E7%A5%A8%E9%97%AE%E9%A2%98%C2%A0">3.使用同步方法解决售票问题 </h3> 
<p><strong>示例代码</strong></p> 
<blockquote> 
 <p>这段代码与前面不同的是，这段代码是使用实现Runnable接口实现的多线程，只需要创建一个实现Runnable接口的javabean类的对象，所以票数这个变量的内存地址是唯一的，所以不用像上面的代码一样用static修饰票数count</p> 
 <p>注意：下面同步方法是非静态的，所以锁对象就是MyRunnable类的对象mr</p> 
</blockquote> 
<pre><code class="language-java">public class ThreadSafetyProblem {
    public static void main(String[] args) {
        MyRunnable mr = new MyRunnable();
        Thread myThread1 = new Thread(mr);
        Thread myThread2 = new Thread(mr);
        Thread myThread3 = new Thread(mr);
        myThread1.setName("窗口1");
        myThread2.setName("窗口2");
        myThread3.setName("窗口3");
        myThread1.start();
        myThread2.start();
        myThread3.start();
    }
}
class MyRunnable implements Runnable{
    int count = 0;
    public void run(){
        while(true){
            //同步代码块
            if (method()) break;
        }
    }
    //锁对象是this
    private synchronized boolean method() {
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            if (count &lt; 2000){
                System.out.println(Thread.currentThread().getName() + "正在卖第" + ++count+"张票");
            }else {
                return true;
            }
        return false;
    }
}
</code></pre> 
<h3 id="4.StringBuffer%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F">4.StringBuffer为什么是线程安全的？</h3> 
<blockquote> 
 <p><strong>虽然StringBuilder和StringBuffer的成员方法是一样的，但为什么之前建议在多线程的情况下使用StringBuffer？</strong></p> 
 <p><strong>这是由于StringBuffer的成员方法比较 StringBuilder多了一个Sychronized修饰词，保证了线程的安全，但是在单线程的情况下，还是使用StringBuilder好一些。</strong></p> 
</blockquote> 
<h2 id="%E4%B9%9D%E3%80%81Lock%E9%94%81">九、Lock锁</h2> 
<h3 id="%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0"><img alt="" height="728" src="https://images2.imgbox.com/21/83/B2FeEYfu_o.png" width="1170"> </h3> 
<h3 id="1.%E5%94%AE%E7%A5%A8%E4%BB%A3%E7%A0%81%E4%BD%BF%E7%94%A8%E6%89%8B%E5%8A%A8%E4%B8%8A%E9%94%81%C2%A0">1.售票代码使用手动上锁 </h3> 
<pre><code class="language-java">public class ThreadSafetyProblem {
    public static void main(String[] args) {
        MyThread1 myThread1 = new MyThread1();
        MyThread1 myThread2 = new MyThread1();
        MyThread1 myThread3 = new MyThread1();
        myThread1.setName("窗口1");
        myThread2.setName("窗口2");
        myThread3.setName("窗口3");
        myThread1.start();
        myThread2.start();
        myThread3.start();
    }
}
class MyThread1 extends Thread{
    //静态变量，几个线程共享
    private static int count = 0;
    //创建一个锁对象 用static修饰表示共享唯一
    Lock lock = new ReentrantLock();
    public void run(){
        while(true){
            lock.lock();
            try {
                Thread.sleep(10);
                if (count &lt; 2000){
                    System.out.println(Thread.currentThread().getName() + "正在卖第" + ++count+"张票");
                }else {
                    break;
                }
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            } finally {
                lock.unlock();
            }
        }
    }
}</code></pre> 
<h2 id="%E5%8D%81%E3%80%81%E6%AD%BB%E9%94%81">十、死锁</h2> 
<h3 id="1.%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">1.示例代码</h3> 
<blockquote> 
 <p>下面的代码用了锁的嵌套</p> 
 <pre><code class="language-java">public class MyThread extends Thread {
    static Object objA = new Object();
    static Object objB = new Object();
    @Override
    public void run() {
        //1.循环
        while (true) {
            if ("线程1".equals(getName())) {
                synchronized (objA) {
                    System.out.println("线程1拿到了A锁，准备拿B锁");//线程1卡在这里
                    synchronized (objB) {
                        System.out.println("线程1拿到了B锁，顺利执行完一轮");
                    }
                }
            } else if ("线程2".equals(getName())) {
                if ("线程2".equals(getName())) {
                    synchronized (objB) {
                        System.out.println("线程2拿到了B锁，准备拿A锁");//线程2卡在这里
                        synchronized (objA) {
                            System.out.println("线程2拿到了A锁，顺利执行完一轮");
                        }
                    }
                }
            }
        }
    }
}</code></pre> 
 <p><strong> 运行结果</strong></p> 
 <p><img alt="" height="205" src="https://images2.imgbox.com/11/f4/GpDmLgig_o.png" width="656"></p> 
 <p>显然两个线程都卡在第一层同步代码的锁那里，程序结束不了。</p> 
</blockquote> 
<h3 id="2.%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%C2%A0">2.如何解决 </h3> 
<blockquote> 
 <p>很简单，不要写锁或同步代码块的锁嵌套就行。</p> 
</blockquote> 
<h2 id="%E5%8D%81%E4%B8%80%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F" style="background-color:transparent;">十一、生产者和消费者模式</h2> 
<p>生产者消费者模式是一个十分经典的多线程协作的模式，就是要打破两个线程随机执行的规则，你一次我一次。</p> 
<h3 id="1.%E6%B5%81%E7%A8%8B%E6%A1%86%E5%9B%BE%EF%BC%88%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6%EF%BC%89" style="background-color:transparent;">1.流程框图（等待唤醒机制）</h3> 
<p><img alt="" height="732" src="https://images2.imgbox.com/1e/28/3WQ3sOYX_o.png" width="1200"></p> 
<h3 id="2.%E6%B6%89%E5%8F%8A%E7%9A%84%E6%96%B9%E6%B3%95" style="background-color:transparent;">2.涉及的方法</h3> 
<blockquote> 
 <p><img alt="" height="308" src="https://images2.imgbox.com/6b/0e/kCH8TYWa_o.png" width="1200"> 调用 <code>wait()</code> 方法的线程会释放它持有的锁，并进入等待状态，直到它被其他线程通过调用 <code>notify()</code> 或 <code>notifyAll()</code> 唤醒。</p> 
</blockquote> 
<h3 id="3.%E6%AD%A5%E9%AA%A4%C2%A0" style="background-color:transparent;">3.步骤 </h3> 
<p><strong>消费者和生产者的代码都按下面的步骤走：</strong></p> 
<blockquote> 
 <p>1.循环</p> 
 <p>2.同步代码块(给消费者或生产者上锁)</p> 
 <p>3.判断共享数据是否到了末尾（到了末尾）</p> 
 <p>4.判断共享数据是否到了末尾（没有到末尾，执行（消费者或生产者的）核心逻辑）</p> 
</blockquote> 
<h3 id="4.%20%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">4. 示例代码</h3> 
<h4 id="(1)%E6%A1%8C%E5%AD%90%E4%BB%A3%E7%A0%81">(1)桌子代码</h4> 
<pre><code class="language-java">public class Desk {
    /*
    桌子的作用：控制生产者和消费者的执行
     */
    // 判断桌子上有没有食物
    // 0 没有食物 生产者的线程执行
    // 1 有食物   消费者的线程执行
    //这里一般不用boolean类型，因为boolean类型只能是true或者false
    //如果有多条线程，int 可以表示多条线程的状态
    public static int foodFlat = 0;

    // 消费者现在所能吃食物的碗数
    public static int count = 10;

    //锁对象
    static Object lock = new Object();
}</code></pre> 
<h4 id="(2)%E6%B6%88%E8%B4%B9%E8%80%85%E4%BB%A3%E7%A0%81">(2)消费者代码</h4> 
<pre><code class="language-java">public class Foodie extends Thread {
    /*
    1.循环

    2.同步代码块(给消费者或生产者上锁)

    3.判断共享数据是否到了末尾（到了末尾）

    4.判断共享数据是否到了末尾（没有到末尾，执行（消费者或生产者的）核心逻辑）
     */
    public void run(){
        while(true){
            synchronized (Desk.lock){
                if (Desk.count == 0){//吃不下了，直接结束
                    break;
                }else {
                    //如果桌上没有食物
                    if (Desk.foodFlat == 0){
                        try {
                            //进入等待
                            Desk.lock.wait();
                        } catch (InterruptedException e) {
                            throw new RuntimeException(e);
                        }
                    }else {
                        //桌上有食物
                        Desk.foodFlat = 0;
                        Desk.count--;
                        System.out.println("消费者吃掉了一碗面条，还能吃"+Desk.count+"碗");
                        //通知唤醒厨师
                        Desk.lock.notify();
                    }
                }
            }
        }
    }
}</code></pre> 
<h4 id="(3)%E7%94%9F%E4%BA%A7%E8%80%85%E4%BB%A3%E7%A0%81">(3)生产者代码</h4> 
<pre><code class="language-java">public class Cook extends Thread {
    public void run(){
        while(true){
            synchronized (Desk.lock){
                //判断消费者是否吃饱了
                if (Desk.count==0){
                    //吃饱了就结束
                    break;
                }else {
                    //消费者还能吃
                    //判断桌子上还有食物么
                    //有食物就进入等待
                    if (Desk.foodFlat==1){
                        try {
                            Desk.lock.wait();
                        } catch (InterruptedException e) {
                            throw new RuntimeException(e);
                        }
                    }else {
                        //没食物
                        //厨师做一碗面条
                        Desk.foodFlat = 1;
                        System.out.println("厨师做了一碗面条");
                        //做好就唤醒消费者
                        Desk.lock.notify();
                    }
                }
            }
        }
    }

}</code></pre> 
<h4 id="(4)main%E6%96%B9%E6%B3%95">(4)main方法</h4> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        Desk desk = new Desk();
        Foodie foodie = new Foodie();
        Cook cook = new Cook();
        foodie.setName("吃货");
        cook.setName("厨师");
        foodie.start();
        cook.start();
    }
}</code></pre> 
<h4 id="%C2%A0(5)%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C" style="background-color:transparent;"> (5)执行结果</h4> 
<blockquote> 
 <p><img alt="" height="566" src="https://images2.imgbox.com/42/7b/sTzAst4S_o.png" width="631"></p> 
 <p>从运行结果可以看出来，消费者和生产者模式可以使多个线程不再随机而是按顺序的来执行。 </p> 
</blockquote> 
<h3 id="%C2%A05.%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6"> 5.阻塞队列实现唤醒机制</h3> 
<p><img alt="" height="817" src="https://images2.imgbox.com/e4/69/NFHYW5Eb_o.png" width="1173"></p> 
<h4 id="%C2%A0(1)%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95put%E5%92%8Ctake" style="background-color:transparent;"> (1)成员方法put和take</h4> 
<blockquote> 
 <p><strong>put方法底层原理</strong></p> 
 <p><strong>放入一个数据，put方法接收数据，先使当前线程获得锁（这个队列的），唤醒等待的线程，如果队列满了，当前线程进入等待，释放当前锁。</strong></p> 
 <p><img alt="" height="367" src="https://images2.imgbox.com/fd/bd/dsp6r4DP_o.png" width="685"></p> 
</blockquote> 
<blockquote> 
 <p><strong> take方法底层原理</strong></p> 
 <p><strong>take方法取出数据，先使当前线程获得锁（这个队列的），唤醒等待的线程，如果队列空的，当前线程进入等待，释放当前锁。</strong></p> 
 <p><img alt="" height="338" src="https://images2.imgbox.com/f1/0b/c9yGdA5g_o.png" width="629"></p> 
</blockquote> 
<h4 id="(2)%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" style="background-color:transparent;">(2)代码实现</h4> 
<p>用阻塞队列实现消费者和生产者的示例代码 </p> 
<blockquote> 
 <p><strong>消费者代码</strong></p> 
 <pre><code class="language-java">public class Foodie extends Thread {
    ArrayBlockingQueue&lt;String&gt; queue;
    public Foodie(ArrayBlockingQueue&lt;String&gt; queue)
    {
        this.queue = queue;
    }
    public void run() {
        while(true){
            try {
                queue.take();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println("吃货吃了一碗面条");
        }
    }
}
</code></pre> 
</blockquote> 
<blockquote> 
 <p><strong>生产者代码 </strong></p> 
 <pre><code class="language-java">public class Cook extends Thread{
    ArrayBlockingQueue&lt;String&gt; queue;
    public Cook(ArrayBlockingQueue&lt;String&gt; queue) {
        this.queue = queue;
    }
    public void run() {
        while(true){
            try {
                queue.put("一碗面");
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println("厨师做了一碗面条");
        }
    }
}</code></pre> 
</blockquote> 
<blockquote> 
 <p><strong>main方法 </strong></p> 
 <pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        ArrayBlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;&gt;(1);
        Foodie f = new Foodie(queue);
        Cook c = new Cook(queue);
        f.setName("吃货");
        c.setName("厨师");
        f.start();
        c.start();
    }
}</code></pre> 
</blockquote> 
<blockquote> 
 <p>运行结果</p> 
 <p><img alt="" height="194" src="https://images2.imgbox.com/89/af/VrTDoXix_o.png" width="565"> </p> 
 <p><strong>看到上面的结果有人会认为，厨师连续做了两碗面，是不是违反了模式了？</strong></p> 
 <p>其实不然，消费者和生产者两条线程还是一条一次轮流执行的，重复输出是因为输出的代码放在了锁的外面，所以两个线程是随机的，抢着输出的，厨师做了多少碗面和消费者吃了多少碗的数量还是一样的。厨师放一碗面到队列，吃货就拿一碗。</p> 
 <p><span style="color:#fe2c24;">注意：锁只在阻塞队列里面，即示例代码的put和take方法里面</span></p> 
</blockquote> 
<p> </p> 
<h2 id="%C2%A0%E5%8D%81%E4%BA%8C%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%846%E7%A7%8D%E7%8A%B6%E6%80%81"> 十二、线程的6种状态</h2> 
<p><img alt="" height="853" src="https://images2.imgbox.com/fb/bf/M8BLFtRB_o.png" width="1200"></p> 
<p> 严格的来说，线程有7种状态，但是线程在进入要运行阶段的时候，JVM直接将线程丢给操作系统，java就不管了。所以对于java来说，线程是有6种状态。如下，</p> 
<p><img alt="" height="728" src="https://images2.imgbox.com/2b/33/4JdRtYXl_o.png" width="1200"></p> 
<p> </p> 
<h2 id="%E5%8D%81%E4%B8%89%E3%80%81Demo%C2%A0">十三、Demo </h2> 
<h3 id="1.Demo1">1.Demo1</h3> 
<blockquote> 
 <p><strong>有100份礼品，两人同时发送，当剩下的礼品品小于10份分的时候则不再送出</strong></p> 
 <p><strong>利用多线程模拟该过程并将线程的名字和礼物的剩余数量打印出来</strong></p> 
 <pre><code class="language-java">public class MyRunnable implements Runnable{
    int count = 100;
    @Override
    public void run() {
        while (true) {
            synchronized (this) {
                if (count &lt; 10){
                    break;
                }else {
                    count--;
                    System.out.println(Thread.currentThread().getName() + "送出一份礼物，剩余" + count + "份礼物");
                }
            }
        }
    }
}
public class Test {
    public static void main(String[] args) {
        MyRunnable mr = new MyRunnable();
        Thread t1 = new Thread(mr);
        Thread t2 = new Thread(mr);
        t1.setName("小明");
        t2.setName("小红");
        t1.start();
        t2.start();
    }
}</code></pre> 
</blockquote> 
<h3 id="2.Demo2" style="background-color:transparent;">2.Demo2</h3> 
<blockquote> 
 <h3><img alt="" height="398" src="https://images2.imgbox.com/06/ab/nZTqgwFk_o.png" width="468"> </h3> 
 <pre><code class="language-java">public class MyRunnable implements Runnable{
    double money = 100;
    int count = 3;
    Random rnd = new Random();
    public void run(){
            synchronized (this) {
                if (count == 0){
                    System.out.println(Thread.currentThread().getName()+"没抢到");
                }else if (count == 1){
                    count--;
                    System.out.println(Thread.currentThread().getName()+"抢到了"+money+"元");
                    money = 0;
                }
                else {
                    double get = (rnd.nextDouble()*money);
                    System.out.println(Thread.currentThread().getName()+"抢到了"+get+"元");
                    money = money - get;
                    count--;
                }
            }
    }
}
public class Test {
    public static void main(String[] args) {
        MyRunnable mr = new MyRunnable();
        Thread t1 = new Thread(mr);
        Thread t2 = new Thread(mr);
        Thread t3 = new Thread(mr);
        Thread t4 = new Thread(mr);
        Thread t5 = new Thread(mr);
        t1.setName("玩家1");
        t2.setName("玩家2");
        t3.setName("玩家3");
        t4.setName("玩家4");
        t5.setName("玩家5");
        t1.start();
        t2.start();
        t3.start();
        t4.start();
        t5.start();
    }
}</code></pre> 
</blockquote> 
<h3 id="3.Demo3">3.Demo3</h3> 
<blockquote> 
 <p><img alt="" height="702" src="https://images2.imgbox.com/d5/e3/dT0Z4DkF_o.png" width="1014"></p> 
 <pre><code class="language-java">public class MyRunnable implements Runnable{
    //奖池
    ArrayList&lt;Integer&gt; list;
    public MyRunnable(ArrayList&lt;Integer&gt; list) {
        this.list = list;
    }
    @Override
    public void run() {
        while (true){
            synchronized (this) {
                if (list.isEmpty()){
                    break;
                }
                Collections.shuffle(list);
                System.out.println(Thread.currentThread().getName()+"又产生了一个"+list.get(0)+"元大奖");
                list.remove(0);
            }
            //在锁外面休眠一会，这样另外一个线程就先执行，输出会好看一点
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
public class Test {
    public static void main(String[] args) {
        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        Collections.addAll(list,10,5,20,50,100,200,500,800,2,80,300,700);
        MyRunnable mr = new MyRunnable(list);
        Thread t1 = new Thread(mr);
        Thread t2 = new Thread(mr);
        t1.setName("抽奖箱1");
        t2.setName("抽奖箱2");
        t1.start();
        t2.start();
    }
}</code></pre> 
</blockquote> 
<h3 id="4.Demo4%20%EF%BC%88%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BB%9F%E8%AE%A1%E5%B9%B6%E6%B1%82%E6%9C%80%E5%A4%A7%E5%80%BC%EF%BC%89" style="background-color:transparent;">4.Demo4 （多线程统计并求最大值）</h3> 
<blockquote> 
 <h3 id="%E2%80%8B%E7%BC%96%E8%BE%91" style="background-color:transparent;"><img alt="" height="393" src="https://images2.imgbox.com/2b/e8/pHJz4MZA_o.png" width="1091"></h3> 
 <pre><code class="language-java">public class MyRunnable implements Runnable{
    //奖池
    ArrayList&lt;Integer&gt; list;
    public MyRunnable(ArrayList&lt;Integer&gt; list) {
        this.list = list;
    }
    @Override
    public void run() {
        //定义一个集合，收集每一个抽奖箱每次中奖的金额
        ArrayList&lt;Integer&gt; moneys = new ArrayList&lt;&gt;();
        while (true){
            synchronized (this) {
                if (list.isEmpty()){
                    Collections.sort(moneys);
                    System.out.println("在此次抽奖过程中，"+Thread.currentThread().getName()
                            +"总共产生了"+moneys.size()+"个奖项");
                    String string = moneys.toString();
                    System.out.println("\t分别为:"+string.substring(1,string.length()-1)
                            +"最高奖项为"+moneys.get(moneys.size() - 1)
                            +",总计额为"+moneys.stream().mapToInt(Integer::intValue).sum());
                    break;
                }
                Collections.shuffle(list);
                moneys.add(list.get(0));
                list.remove(0);
            }
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
public class Test {
    public static void main(String[] args) {
        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        Collections.addAll(list,10,5,20,50,100,200,500,800,2,80,300,700);
        String name1 = "抽奖箱1";
        String name2 = "抽奖箱2";
        MyRunnable mr = new MyRunnable(list);
        Thread t1 = new Thread(mr);
        Thread t2 = new Thread(mr);
        t1.setName(name1);
        t2.setName(name2);
        t1.start();
        t2.start();
    }
}</code></pre> 
</blockquote> 
<h3 id="5.Demo5%EF%BC%88%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E6%AF%94%E8%BE%83%EF%BC%89" style="background-color:transparent;">5.Demo5（多线程之间的比较）</h3> 
<blockquote> 
 <p><img alt="" height="532" src="https://images2.imgbox.com/09/38/BPpcyQbU_o.png" width="1187"></p> 
 <p>由于这里要多线程之间进行比较，所以必须要有返回值，run方法没有返回值，所以使用第三种方法实现多线程，即实现Callable接口和Future接口 </p> 
 <pre><code class="language-java">public class MyCallable implements Callable&lt;Integer&gt; {
    //奖池
    ArrayList&lt;Integer&gt; list;
    public MyCallable(ArrayList&lt;Integer&gt; list) {
        this.list = list;
    }
    @Override
    public Integer call(){
        //定义一个集合，收集每一个抽奖箱每次中奖的金额
        ArrayList&lt;Integer&gt; moneys = new ArrayList&lt;&gt;();
        while (true){
            synchronized (this) {
                if (list.isEmpty()){
                    Collections.sort(moneys);
                    System.out.println("在此次抽奖过程中，"+Thread.currentThread().getName()
                            +"总共产生了"+moneys.size()+"个奖项");
                    String string = moneys.toString();
                    System.out.println("\t分别为:"+string.substring(1,string.length()-1)
                            +"最高奖项为"+moneys.get(moneys.size() - 1)
                            +",总计额为"+moneys.stream().mapToInt(Integer::intValue).sum());
                    break;
                }
                Collections.shuffle(list);
                moneys.add(list.get(0));
                list.remove(0);
            }
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
        return moneys.get(moneys.size() - 1);
    }
}
public class Test {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        Collections.addAll(list,10,5,20,50,100,200,500,800,2,80,300,700);
        String name1 = "抽奖箱1";
        String name2 = "抽奖箱2";
        MyCallable mc = new MyCallable(list);
        FutureTask&lt;Integer&gt; ft1 = new FutureTask&lt;&gt;(mc);
        FutureTask&lt;Integer&gt; ft2 = new FutureTask&lt;&gt;(mc);
        Thread t1 = new Thread(ft1,name1);
        Thread t2 = new Thread(ft2,name2);
        t1.start();
        t2.start();
        if (ft1.get()&gt;ft2.get()){
            System.out.println("在此次抽奖过程中,"+name1+"中产生了最大奖项，该奖项金额为"+ft1.get()+"元");
        }else {
            System.out.println("在此次抽奖过程中,"+name2+"中产生了最大奖项，该奖项金额为"+ft2.get()+"元");
        }
    }
}
</code></pre> 
</blockquote> 
<h2 id="%E5%8D%81%E5%9B%9B%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE%C2%A0">十四、多线程的内存图 </h2> 
<p><img alt="" height="824" src="https://images2.imgbox.com/fc/ec/ixe276Rz_o.png" width="1200"></p> 
<h2 id="%E5%8D%81%E4%BA%94%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0">十五、线程池</h2> 
<h3 id="%C2%A01.%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"> 1.核心原理</h3> 
<blockquote> 
 <p>（1）创建一个池子，池子中是空的</p> 
 <p>（2）提交任务时，池子会创建新的线程对象，任务执行完毕，线程归还给池子</p> 
 <p>        下回再次提交任务时，不需要创建新的线程，直接复用已有的线程即可</p> 
 <p>（3）但是如果提交任务时，池子中没有空闲线程，也无法创建新的线程，任务就会排队等待</p> 
</blockquote> 
<p><img alt="" height="220" src="https://images2.imgbox.com/41/a6/YgjoS4Up_o.png" width="1200"> </p> 
<h3 id="2.%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4">2.操作步骤</h3> 
<blockquote> 
 <p>（1）创建线程池对象</p> 
 <p>（2）提交任务(提交线程)</p> 
 <p>（3）任务都执行完毕后，关闭线程池</p> 
</blockquote> 
<p>注意：一般的服务器线程池是不会关闭的，比如王者游戏24小时都能玩</p> 
<p><img alt="" height="246" src="https://images2.imgbox.com/95/da/hLtvxUiW_o.png" width="899"></p> 
<p><img alt="" height="595" src="https://images2.imgbox.com/87/db/xSKTTi67_o.png" width="778"></p> 
<h3 id="3.%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0" style="background-color:transparent;">3.自定义线程池</h3> 
<p>把一个餐厅的运营的七大核心因素看作线程的参数</p> 
<p><img alt="" height="527" src="https://images2.imgbox.com/06/b6/i1zYNrzr_o.png" width="1200"></p> 
<p></p> 
<h4 id="(1)%E4%B8%A4%E7%A7%8D%E6%83%85%E5%86%B5%2B%E4%B8%89%E4%B8%AA%E4%B8%B4%E7%95%8C%E7%82%B9">(1)两种情况+三个临界点</h4> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>A.</strong></span>线程池的参数如下，提交的任务数小于3+3+3，因此不会触发任务过多解决方案，8个任务从核心线程开始放，然后放队伍，发现不够放了，于是找来临时工（临时线程）放多余的两个任务。</p> 
 <p>注意：任务并不是先放就先执行，比如下面任务7，8后放比在排队的4，5，6先走。</p> 
 <p><img alt="" height="754" src="https://images2.imgbox.com/04/c6/Lpv1DrMO_o.png" width="1200"></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>B.</strong></span>下面这种情况和上面不同的是，提交的任务数量超过了3+3+3，于是最后一个任务触发了任务拒绝策略。 其他和上面相同</p> 
 <p><img alt="" height="762" src="https://images2.imgbox.com/3c/50/fIfdDLPo_o.png" width="1200"></p> 
 <p> </p> 
</blockquote> 
<blockquote> 
 <p><strong>三个临界点 </strong></p> 
 <p><img alt="" height="308" src="https://images2.imgbox.com/0a/fe/pAnH0p28_o.png" width="1143"></p> 
</blockquote> 
<h4 id="%C2%A0(2)%E4%BB%BB%E5%8A%A1%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"> (2)任务拒绝策略</h4> 
<p><img alt="" height="370" src="https://images2.imgbox.com/eb/58/V8h4fbIk_o.png" width="1200"> </p> 
<h4 id="(3)%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%B1%A0">(3)创建一个线程池</h4> 
<blockquote> 
 <p>构造方法和参数如下</p> 
 <h4><img alt="" height="310" src="https://images2.imgbox.com/27/2b/JaGsWawI_o.png" width="906"></h4> 
</blockquote> 
<blockquote> 
 <p><img alt="" height="276" src="https://images2.imgbox.com/ea/a2/51Qd9xIg_o.png" width="875"></p> 
 <p>使用这个线程池就提交任务就行pool.submit(线程任务)</p> 
</blockquote> 
<h4 id="(4)%E6%9C%80%E5%A4%A7%E5%B9%B6%E8%A1%8C%E6%95%B0%C2%A0">(4)最大并行数 </h4> 
<blockquote> 
 <p>在多线程编程中，指同时运行的线程数量的上限。</p> 
 <p>下面代码可以获得java可用的处理器的数目，即可同时运行线程的最大数量</p> 
 <p><img alt="" height="222" src="https://images2.imgbox.com/c4/a7/8kfhBR6f_o.png" width="730"></p> 
</blockquote> 
<h4 id="(5)%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%9A%E5%A4%A7%E5%90%88%E9%80%82">(5)线程池多大合适</h4> 
<blockquote> 
 <h4><img alt="" height="692" src="https://images2.imgbox.com/b5/f0/ssiKiD17_o.png" width="1200"> </h4> 
 <p> cpu计算时间和等待时间可以通过插件thread dump计算统计</p> 
</blockquote> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p></p> 
<p>        </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/05cf75046705494ae47fc110cfcfde2e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java中的Set（如果想知道Java中有关Set的知识点，那么只看这一篇就足够了！）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c602a90abc53e2e010e3f129dc096f68/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于springboot&#43;vue&#43;uniapp的“口腔助手”小程序</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>