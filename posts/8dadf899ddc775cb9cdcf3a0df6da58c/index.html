<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java 中使用 sort() 方法排序：从基本原理到多种用法全面总结；sort()函数的使用 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/8dadf899ddc775cb9cdcf3a0df6da58c/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java 中使用 sort() 方法排序：从基本原理到多种用法全面总结；sort()函数的使用">
  <meta property="og:description" content="总结整理不易，如果对你有所帮助，不妨动手点个免费的赞哦，收藏关注不迷路[比心]~
目录
1. sort() 函数的基本原理
2. sort() 函数的用法
2.1 默认排序（升序）
2.2 局部排序
2.2 降序排序(逆序排序）
2.2.1 使用Collections.reverseOrder()方法进行逆序排序
2.2.2 使用Comparator.reversed()方法
2.2.3 匿名内部类
2.2.4 使用Lambda表达式进行逆序排序
2.3 自定义对象进行排序
2.4 Lambda 表达式简化Comparator的实现
2.4.1 基本的Lambda表达式
2.4.2 省略类型定义：
2.4.3 使用静态方法引用：
2.4.4 使用实例方法引用：
2.5 多级排序
2.6 并行排序
在 Java 编程中，sort() 函数是一个非常重要且常用的方法，用于对数组或集合进行排序操作。本文将深入探讨 sort() 函数的基本原理、以及其在实际应用中的多种用法。
1. sort() 函数的基本原理 Java中的sort()函数是一个高效的排序算法，其具体的实现原理取决于排序的数据类型和大小。在Java 7之前，Arrays类使用的是经典的快速排序算法。在Java 7及以后的版本中，Arrays类在排序小型数组时使用的是改进后的快速排序算法，而在排序大型数组时使用的是归并排序算法。
原理详情请看往期：http://t.csdnimg.cn/Lqw93
2. sort() 函数的用法 在 Java 中，sort() 函数可以用于对数组或集合进行排序，其用法略有不同。
2.1 默认排序（升序） 格式：
Arrays.sort(array); Collections.sort(list); 例：
//对整型数组进行排序 int[] array = {5, 2, 9, 1, 3}; Arrays.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-10T14:30:42+08:00">
    <meta property="article:modified_time" content="2024-03-10T14:30:42+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java 中使用 sort() 方法排序：从基本原理到多种用法全面总结；sort()函数的使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>总结整理不易，如果对你有所帮助，不妨动手点个免费的赞哦，收藏关注不迷路[比心]~</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%20sort()%20%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-toc" style="margin-left:0px;"><a href="#1.%20sort%28%29%20%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86" rel="nofollow">1. sort() 函数的基本原理</a></p> 
<p id="2.%20sort()%20%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95-toc" style="margin-left:0px;"><a href="#2.%20sort%28%29%20%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95" rel="nofollow">2. sort() 函数的用法</a></p> 
<p id="2.1%20%E9%BB%98%E8%AE%A4%E6%8E%92%E5%BA%8F%EF%BC%88%E5%8D%87%E5%BA%8F%EF%BC%89-toc" style="margin-left:40px;"><a href="#2.1%20%E9%BB%98%E8%AE%A4%E6%8E%92%E5%BA%8F%EF%BC%88%E5%8D%87%E5%BA%8F%EF%BC%89" rel="nofollow">2.1 默认排序（升序）</a></p> 
<p id="2.2%20%E5%B1%80%E9%83%A8%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#2.2%20%E5%B1%80%E9%83%A8%E6%8E%92%E5%BA%8F" rel="nofollow">2.2 局部排序</a></p> 
<p id="2.2%20%E5%80%92%E5%BA%8F%E6%8E%92%E5%BA%8F(%E9%80%86%E5%BA%8F%E6%8E%92%E5%BA%8F%EF%BC%89-toc" style="margin-left:40px;"><a href="#2.2%20%E5%80%92%E5%BA%8F%E6%8E%92%E5%BA%8F%28%E9%80%86%E5%BA%8F%E6%8E%92%E5%BA%8F%EF%BC%89" rel="nofollow">2.2 降序排序(逆序排序）</a></p> 
<p id="2.2.1%20%E4%BD%BF%E7%94%A8Collections.reverseOrder()%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E9%80%86%E5%BA%8F%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><a href="#2.2.1%20%E4%BD%BF%E7%94%A8Collections.reverseOrder%28%29%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E9%80%86%E5%BA%8F%E6%8E%92%E5%BA%8F" rel="nofollow">2.2.1 使用Collections.reverseOrder()方法进行逆序排序</a></p> 
<p id="2.2.2%E4%BD%BF%E7%94%A8Comparator.reversed()%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#2.2.2%E4%BD%BF%E7%94%A8Comparator.reversed%28%29%E6%96%B9%E6%B3%95" rel="nofollow">2.2.2 使用Comparator.reversed()方法</a></p> 
<p id="2.2.3%20%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB-toc" style="margin-left:80px;"><a href="#2.2.3%20%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB" rel="nofollow">2.2.3 匿名内部类</a></p> 
<p id="2.2.4%E4%BD%BF%E7%94%A8Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E9%80%86%E5%BA%8F%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><a href="#2.2.4%E4%BD%BF%E7%94%A8Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E9%80%86%E5%BA%8F%E6%8E%92%E5%BA%8F" rel="nofollow">2.2.4 使用Lambda表达式进行逆序排序</a></p> 
<p id="2.3%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#2.3%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F" rel="nofollow">2.3 自定义对象进行排序</a></p> 
<p id="2.4%20Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%80%E5%8C%96%E8%87%AA%E5%AE%9A%E4%B9%89%E6%AF%94%E8%BE%83%E5%99%A8-toc" style="margin-left:40px;"><a href="#2.4%20Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%80%E5%8C%96%E8%87%AA%E5%AE%9A%E4%B9%89%E6%AF%94%E8%BE%83%E5%99%A8" rel="nofollow">2.4 Lambda 表达式简化Comparator的实现</a></p> 
<p id="2.4.1%E5%9F%BA%E6%9C%AC%E7%9A%84Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F-toc" style="margin-left:80px;"><a href="#2.4.1%E5%9F%BA%E6%9C%AC%E7%9A%84Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F" rel="nofollow">2.4.1 基本的Lambda表达式</a></p> 
<p id="2.4.2%E7%9C%81%E7%95%A5%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%EF%BC%9A-toc" style="margin-left:80px;"><a href="#2.4.2%E7%9C%81%E7%95%A5%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%EF%BC%9A" rel="nofollow">2.4.2 省略类型定义：</a></p> 
<p id="2.4.3%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%9A-toc" style="margin-left:80px;"><a href="#2.4.3%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%9A" rel="nofollow">2.4.3 使用静态方法引用：</a></p> 
<p id="2.4.4%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%9A-toc" style="margin-left:80px;"><a href="#2.4.4%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%9A" rel="nofollow">2.4.4 使用实例方法引用：</a></p> 
<p id="2.5%E5%A4%9A%E7%BA%A7%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#2.5%E5%A4%9A%E7%BA%A7%E6%8E%92%E5%BA%8F" rel="nofollow">2.5 多级排序</a></p> 
<p id="2.5.%20%E5%B9%B6%E8%A1%8C%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#2.5.%20%E5%B9%B6%E8%A1%8C%E6%8E%92%E5%BA%8F" rel="nofollow">2.6 并行排序</a></p> 
<hr id="hr-toc"> 
<p></p> 
<hr> 
<p></p> 
<p>在 Java 编程中，sort() 函数是一个非常重要且常用的方法，用于对数组或集合进行排序操作。本文将深入探讨 sort() 函数的基本原理、以及其在实际应用中的多种用法。</p> 
<h2 id="1.%20sort()%20%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86">1. sort() 函数的基本原理</h2> 
<p>Java中的<code>sort()</code>函数是一个高效的排序算法，其具体的实现原理取决于排序的数据类型和大小。在Java 7之前，<code>Arrays</code>类使用的是经典的快速排序算法。在Java 7及以后的版本中，<code>Arrays</code>类在排序小型数组时使用的是改进后的快速排序算法，而在排序大型数组时使用的是归并排序算法。</p> 
<p>原理详情请看往期：<a href="http://t.csdnimg.cn/Lqw93" rel="nofollow" title="http://t.csdnimg.cn/Lqw93">http://t.csdnimg.cn/Lqw93</a></p> 
<h2 id="2.%20sort()%20%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95">2. sort() 函数的用法</h2> 
<p>在 Java 中，sort() 函数可以用于对数组或集合进行排序，其用法略有不同。</p> 
<h3 id="2.1%20%E9%BB%98%E8%AE%A4%E6%8E%92%E5%BA%8F%EF%BC%88%E5%8D%87%E5%BA%8F%EF%BC%89">2.1 默认排序（升序）</h3> 
<p>格式：</p> 
<pre><code>Arrays.sort(array);
Collections.sort(list);</code></pre> 
<p> 例：</p> 
<pre><code>//对整型数组进行排序
int[] array = {5, 2, 9, 1, 3};
Arrays.sort(array);
System.out.println(Arrays.toString(array)); //输出：[1, 2, 3, 5, 9]
​
//对字符串数组进行排序
String[] names = {"John", "Alice", "Bob", "David"};
Arrays.sort(names);
System.out.println(Arrays.toString(names)); //输出：[Alice, Bob, David, John]
​
// 对列表进行排序
List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
list.add(5);
list.add(2);
list.add(9);
list.add(1);
list.add(3);
Collections.sort(list);
System.out.println(list); // 输出：[1, 2, 3, 5, 9]</code></pre> 
<h3 id="2.2%20%E5%B1%80%E9%83%A8%E6%8E%92%E5%BA%8F">2.2 局部排序</h3> 
<p>格式：</p> 
<pre><code>Arrays.sort(数组名,start,end);//注意左闭右开！！！[start,end)</code></pre> 
<p>例： </p> 
<pre><code>int[] array = {5, 2, 9, 1, 3};
//对数组的一部分内容进行排序（索引从1到3，包括1不包括3）
Arrays.sort(array, 1, 3);
System.out.println(Arrays.toString(array)); //输出：[5, 1, 2, 9, 3]</code></pre> 
<h3 id="2.2%20%E5%80%92%E5%BA%8F%E6%8E%92%E5%BA%8F(%E9%80%86%E5%BA%8F%E6%8E%92%E5%BA%8F%EF%BC%89">2.2 降序排序(逆序排序）</h3> 
<p>有时我们需要对数组或集合进行倒序排序，可以通过自定义比较器实现：</p> 
<h4 id="2.2.1%20%E4%BD%BF%E7%94%A8Collections.reverseOrder()%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E9%80%86%E5%BA%8F%E6%8E%92%E5%BA%8F">2.2.1 使用Collections.reverseOrder()方法进行逆序排序</h4> 
<pre><code>//数组：
Integer[] arr = {3, 1, 4, 1, 5, 9};
Arrays.sort(arr, Collections.reverseOrder());// 输出：[9, 5, 4, 3, 1, 1]

Collections.sort(list, nameComparator.reversed());

//集合：
List&lt;Integer&gt; list = Arrays.asList(3, 1, 4, 1, 5, 9);
Collections.sort(list, Collections.reverseOrder());
System.out.println(list);  // 输出：[9, 5, 4, 3, 1, 1]</code></pre> 
<h4 id="2.2.2%E4%BD%BF%E7%94%A8Comparator.reversed()%E6%96%B9%E6%B3%95">2.2.2 使用<code>Comparator.reversed()</code>方法</h4> 
<pre><code>List&lt;Student&gt; list = Student.getStudentList();
Comparator&lt;Student&gt; nameComparator = (s1, s2) -&gt; s1.getName().compareTo(s2.getName());
Collections.sort(list, nameComparator.reversed());</code></pre> 
<h4 id="2.2.3%20%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB">2.2.3 匿名内部类</h4> 
<pre><code>Integer[] arr = {8, 9, 5, 2, 3, 6, 1, 0, 7, 4};
Arrays.sort(arr, new Comparator&lt;Integer&gt;() {
    @Override
    public int compare(Integer o1, Integer o2) {
        return o1 - o2;
    }
});</code></pre> 
<h4 id="2.2.4%E4%BD%BF%E7%94%A8Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E9%80%86%E5%BA%8F%E6%8E%92%E5%BA%8F">2.2.4 使用Lambda表达式进行逆序排序</h4> 
<pre><code>Integer[] arr = {9, 8, 7, 2, 3, 4, 1, 0, 6, 5};
Arrays.sort(arr, (o1, o2) -&gt; o2 - o1);</code></pre> 
<h3 id="2.3%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F">2.3 自定义对象进行排序</h3> 
<pre><code>//数组自定义对象排序
Person[] people = {new Person("Alice", 25), new Person("Bob", 20), new Person("Charlie", 30)};
Comparator&lt;Person&gt; byName = Comparator.comparing(Person::getName);//注：Person 类中需有getName()方法
Arrays.sort(people, byName); //按照姓名排序
​
// 集合自定义对象排序
List&lt;Person&gt; persons = new ArrayList&lt;&gt;();
persons.add(new Person("Alice", 25));
persons.add(new Person("Bob", 30));
persons.add(new Person("David", 20));
Comparator&lt;Person&gt; byName = Comparator.comparing(Person::getName);
Collections.sort(persons, byName); // 使用 Collections.sort() 对 List 进行排序

//匿名内部类
public static List&lt;People&gt; compareTest(List&lt;People&gt; arr) {
    Collections.sort(arr, new Comparator&lt;People&gt;() {
        public int compare(People p1, People p2) {
            int a = p1.age; //比较的是age
            int b = p2.age;
            return a &lt; b ? -1 : a == b ? 0 : 1; //当a&lt;b返回-1，a==b返回0，a&gt;b返回1
        }
    });
</code></pre> 
<h3 id="2.4%20Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%80%E5%8C%96%E8%87%AA%E5%AE%9A%E4%B9%89%E6%AF%94%E8%BE%83%E5%99%A8">2.4 Lambda 表达式简化Comparator的实现</h3> 
<p>自从 Java 8 引入了 Lambda 表达式，我们可以更加简洁地定义比较器：</p> 
<h4 id="2.4.1%E5%9F%BA%E6%9C%AC%E7%9A%84Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F">2.4.1 基本的Lambda表达式</h4> 
<pre><code>Comparator&lt;Developer&gt; byName = (Developer o1, Developer o2) -&gt; o1.getName().compareTo(o2.getName());</code></pre> 
<p>这里，我们创建了一个Comparator来比较两个Developer对象的名字。</p> 
<h4 id="2.4.2%E7%9C%81%E7%95%A5%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%EF%BC%9A">2.4.2 省略类型定义：</h4> 
<pre><code>humans.sort((h1, h2) -&gt; h1.getName().compareTo(h2.getName()));</code></pre> 
<p>在这个例子中，我们不需要指定h1和h2的类型，编译器会自动推断。</p> 
<h4 id="2.4.3%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%9A">2.4.3 使用静态方法引用：</h4> 
<pre><code>humans.sort(Human::compareByNameThenAge);</code></pre> 
<p>在这里我们使用了Human类的静态方法compareByNameThenAge作为Comparator。</p> 
<h4 id="2.4.4%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%9A">2.4.4 使用实例方法引用：</h4> 
<pre><code>Collections.sort(humans, Comparator.comparing(Human::getName));</code></pre> 
<h3 id="2.5%E5%A4%9A%E7%BA%A7%E6%8E%92%E5%BA%8F">2.5 多级排序</h3> 
<pre><code>List&lt;Developer&gt; listDevs = getDevelopers();
Comparator&lt;Developer&gt; comparator = Comparator.comparing(Developer::getAge)
                                              .thenComparing(Developer::getName);
listDevs.sort(comparator);</code></pre> 
<h3 id="2.5.%20%E5%B9%B6%E8%A1%8C%E6%8E%92%E5%BA%8F">2.6 并行排序</h3> 
<p>Java 8引入了并行排序。如果你有一个非常大的数组，你可以使用<code>Arrays.parallelSort()</code>方法进行排序。这个方法会利用多核处理器的优势，将数组分成多个部分，然后并行地对每个部分进行排序，最后再将结果合并起来。</p> 
<pre><code>//例1：
int[] arr = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5};
Arrays.parallelSort(arr);
System.out.println(Arrays.toString(arr));  // 输出：[1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]

//例2
List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
// 添加大量数据到列表中
list = list.parallelStream().sorted().collect(Collectors.toList());</code></pre> 
<p class="img-center"><img alt="" height="264" src="https://images2.imgbox.com/25/06/Q0Kox1ta_o.png" width="300"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ec070b528ce8cdb09622d886063d9011/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">NLP:spacy库安装与zh_core_web_sm配置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/610654229796c49e946c94d362bdc5fb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">前端文件流、切片下载和上传</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>