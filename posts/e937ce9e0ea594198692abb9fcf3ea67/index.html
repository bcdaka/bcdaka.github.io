<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>设计模式之观察者模式 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/e937ce9e0ea594198692abb9fcf3ea67/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="设计模式之观察者模式">
  <meta property="og:description" content="引言 在软件开发中，设计模式为我们提供了一种可重用的解决方案，用以解决常见的设计问题。观察者模式（Observer Pattern）是其中一种，它定义了一种一对多的依赖关系，使得一个对象状态的改变能够自动通知并更新其他依赖对象。这种模式在事件驱动系统中尤为常见，如 GUI 应用程序和实时数据处理系统。
观察者模式的定义 观察者模式，也称为发布-订阅模式（Publish-Subscribe Pattern），主要由以下几个核心组件组成：
Subject（主题）：
主题是被观察的对象，它维护了一个观察者列表，并提供方法以供观察者注册和取消注册。当主题的状态发生变化时，它会通知所有已注册的观察者。 Observer（观察者）：
观察者是需要对主题的变化做出反应的对象。每个观察者都实现了一个更新接口，当主题状态变化时，主题会调用观察者的更新方法。 组件和工作原理 观察者模式的关键在于松耦合。主题和观察者之间的依赖是最小化的，主题只需要知道观察者实现了一个特定的接口即可，不需要了解具体的观察者实现。以下是观察者模式的工作原理：
主题类（Subject）： class Subject: def __init__(self): self._observers = [] def attach(self, observer): self._observers.append(observer) def detach(self, observer): self._observers.remove(observer) def notify(self): for observer in self._observers: observer.update(self) # 主题状态的变化 def change_state(self, state): self._state = state self.notify() def get_state(self): return self._state 观察者接口（Observer）： class Observer: def update(self, subject): pass 具体观察者类（ConcreteObserver）： class ConcreteObserver(Observer): def update(self, subject): print(f&#34;Observer: Subject&#39;s state is now {subject.get_state()}&#34;) 代码示例 以下是一个简单的代码示例，展示了观察者模式的应用：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-08T11:45:14+08:00">
    <meta property="article:modified_time" content="2024-08-08T11:45:14+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">设计模式之观察者模式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h5><a id="_0"></a>引言</h5> 
<p>在软件开发中，设计模式为我们提供了一种可重用的解决方案，用以解决常见的设计问题。观察者模式（Observer Pattern）是其中一种，它定义了一种一对多的依赖关系，使得一个对象状态的改变能够自动通知并更新其他依赖对象。这种模式在事件驱动系统中尤为常见，如 GUI 应用程序和实时数据处理系统。</p> 
<h5><a id="_3"></a>观察者模式的定义</h5> 
<p>观察者模式，也称为发布-订阅模式（Publish-Subscribe Pattern），主要由以下几个核心组件组成：</p> 
<ol><li> <p><strong>Subject（主题）</strong>：</p> 
  <ul><li>主题是被观察的对象，它维护了一个观察者列表，并提供方法以供观察者注册和取消注册。当主题的状态发生变化时，它会通知所有已注册的观察者。</li></ul> </li><li> <p><strong>Observer（观察者）</strong>：</p> 
  <ul><li>观察者是需要对主题的变化做出反应的对象。每个观察者都实现了一个更新接口，当主题状态变化时，主题会调用观察者的更新方法。</li></ul> </li></ol> 
<h5><a id="_12"></a>组件和工作原理</h5> 
<p>观察者模式的关键在于松耦合。主题和观察者之间的依赖是最小化的，主题只需要知道观察者实现了一个特定的接口即可，不需要了解具体的观察者实现。以下是观察者模式的工作原理：</p> 
<ol><li><strong>主题类</strong>（Subject）：</li></ol> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Subject</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>_observers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

    <span class="token keyword">def</span> <span class="token function">attach</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> observer<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>_observers<span class="token punctuation">.</span>append<span class="token punctuation">(</span>observer<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">detach</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> observer<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>_observers<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>observer<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">notify</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> observer <span class="token keyword">in</span> self<span class="token punctuation">.</span>_observers<span class="token punctuation">:</span>
            observer<span class="token punctuation">.</span>update<span class="token punctuation">(</span>self<span class="token punctuation">)</span>

    <span class="token comment"># 主题状态的变化</span>
    <span class="token keyword">def</span> <span class="token function">change_state</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>_state <span class="token operator">=</span> state
        self<span class="token punctuation">.</span>notify<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">get_state</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>_state
</code></pre> 
<ol start="2"><li><strong>观察者接口</strong>（Observer）：</li></ol> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Observer</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">update</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> subject<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">pass</span>
</code></pre> 
<ol start="3"><li><strong>具体观察者类</strong>（ConcreteObserver）：</li></ol> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">ConcreteObserver</span><span class="token punctuation">(</span>Observer<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">update</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> subject<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Observer: Subject's state is now </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>subject<span class="token punctuation">.</span>get_state<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
</code></pre> 
<h5><a id="_54"></a>代码示例</h5> 
<p>以下是一个简单的代码示例，展示了观察者模式的应用：</p> 
<pre><code class="prism language-python"><span class="token comment"># 创建主题对象</span>
subject <span class="token operator">=</span> Subject<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 创建观察者对象</span>
observer1 <span class="token operator">=</span> ConcreteObserver<span class="token punctuation">(</span><span class="token punctuation">)</span>
observer2 <span class="token operator">=</span> ConcreteObserver<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 注册观察者</span>
subject<span class="token punctuation">.</span>attach<span class="token punctuation">(</span>observer1<span class="token punctuation">)</span>
subject<span class="token punctuation">.</span>attach<span class="token punctuation">(</span>observer2<span class="token punctuation">)</span>

<span class="token comment"># 改变主题的状态</span>
subject<span class="token punctuation">.</span>change_state<span class="token punctuation">(</span><span class="token string">"new state"</span><span class="token punctuation">)</span>
<span class="token comment"># 输出:</span>
<span class="token comment"># Observer: Subject's state is now new state</span>
<span class="token comment"># Observer: Subject's state is now new state</span>
</code></pre> 
<p>在这个示例中，当主题的状态发生变化时，所有注册的观察者都会收到通知并更新自身。</p> 
<h5><a id="_78"></a>优点</h5> 
<ol><li><strong>松耦合</strong>：主题和观察者之间的依赖关系是最小化的。主题不知道具体的观察者，只知道它们实现了更新接口。</li><li><strong>易于扩展</strong>：可以轻松添加新的观察者，而无需修改现有的主题代码。</li><li><strong>符合开闭原则</strong>：可以在不修改现有代码的情况下扩展系统的功能。</li></ol> 
<h5><a id="_83"></a>缺点</h5> 
<ol><li><strong>可能导致内存泄漏</strong>：如果观察者没有正确注销，可能会导致内存泄漏。</li><li><strong>通知的顺序不确定</strong>：多个观察者接收通知的顺序是不确定的，可能会导致一些问题。</li></ol> 
<h5><a id="_87"></a>实际应用</h5> 
<ol><li><strong>GUI 事件处理</strong>：在图形用户界面编程中，按钮点击、文本框变化等事件都可以通过观察者模式来处理。</li><li><strong>实时数据更新</strong>：在实时系统中，如股票市场、新闻推送等，观察者模式可以用来更新订阅者的数据。</li></ol> 
<h5><a id="_91"></a>结论</h5> 
<p>观察者模式是一种强大的设计模式，适用于需要一对多依赖关系的场景。它通过松耦合和易扩展性，提高了系统的灵活性和可维护性。掌握和应用观察者模式，可以使我们的代码更具弹性和适应性。</p> 
<p>通过本文的介绍，希望大家对观察者模式有了更深刻的理解，并能够在实际项目中有效地应用这一设计模式。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3ec01f0c3fc4a6532b4464ef7dabc3f9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">为啥https比http慢</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6e113ff0f98e9cd45aae09f749015479/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2024年最新MacBook苹果电脑安装JDK8、JDK11、JDK17、JDK22教程，配置环境变量 &#43; 快速切换JDK版本</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>