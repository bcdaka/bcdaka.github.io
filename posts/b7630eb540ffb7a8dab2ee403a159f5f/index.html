<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】二叉树的层序遍历（四） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b7630eb540ffb7a8dab2ee403a159f5f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】二叉树的层序遍历（四）">
  <meta property="og:description" content="目录
一，层序遍历概念
二，层序遍历的实现
1，层序遍历的实现思路
2，创建队列
Queue.h
Queue.c
3，创建二叉树
BTree.h
BTree.c
4，层序遍历的实现
一，层序遍历概念 层序遍历：除了先序遍历、中序遍历、后序遍历外，还可以对二叉树进行层序遍历；
设二叉树的根节点所在层数为1，层序遍历就是从所在二叉树的根节点出发，首先访问第一层的树根结点，然后从左到右访问第2层上的结点，接着是第三层的结点，以此类推，自上而下，自左至右逐层访问树的结点的过程就是层序遍历。
二，层序遍历的实现 1，层序遍历的实现思路 层序遍历：按照每一行从左到右对二叉树的各个结点进行访问
但是呢，对一层访问结束了该如何访问下一层呢？就拿上图举例，访问完（4）结点后该如何访问（3）结点呢？（4）结点中并没有（3）结点的信息；
算法思路：
可以借助一个队列，首先将二叉树的根结点入队，然后访问出队结点并出队，如果有左孩子结点，左孩子结点也入队；如果有右孩子结点，右孩子结点也入队。然后访问出队结点并出队，直到队列为空为止
过程演示： （1）入队列，访问队头结点（1），然后（1）出队列，此时（1）的左子树（2）右子树（4）相继入队列；此时队列： 头&lt;---- （2）（4） &lt;---尾
访问队头结点（2），然后（2）出队列，此时（2）的左子树（3）入队列，此时队列：（4）（3）
访问队头结点（4），然后（4）出队列，此时（4）的左子树（5）右子树（6）相继入队列；
此时队列：（3）（5）（6）
访问队头结点（3），然后（3）出队列，因为（3）没有左右子树，此时没有数据入队列，此时队列：（5）（6）
访问头结点（5），然后（5）出队列，此时队列：（6）
访问头结点（6），然后（6）出队列，此时队列：NULL，结束！
下面是另一棵二叉树的遍历来帮助我们理解；
2，创建队列 首先我们得创建一个队列，队列具体细节就不过多解释了，之前博客有专门的详细介绍过；
队列的性质：先进先出，也就是尾插，头删的单链表；
Queue.h #define _CRT_SECURE_NO_WARNINGS 1 #pragma once #include&lt;stdio.h&gt; #include&lt;assert.h&gt; #include&lt;stdlib.h&gt; #include&#34;BTree.h&#34; typedef BTNode* QDataType; //结点 typedef struct QListNode { struct QListNode* next; QDataType data; }QNode; // 队列 typedef struct Queue { QNode* front; // 队头 QNode* rear; //队尾 int size; }Queue; // 初始化队列 void QueueInit(Queue* q); // 队头入队列 void QueuePush(Queue* q, QDataType data); // 队尾出队列 void QueuePop(Queue* q); // 获取队列头部元素 QDataType QueueFront(Queue* q); // 获取队列队尾元素 QDataType QueueBack(Queue* q); // 获取队列中有效元素个数 int QueueSize(Queue* q); // 判空 int QueueEmpty(Queue* q); // 销毁队列 void QueueDestroy(Queue* q); Queue.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-09-16T17:20:53+08:00">
    <meta property="article:modified_time" content="2023-09-16T17:20:53+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】二叉树的层序遍历（四）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong> 目录</strong></p> 
<p id="%E4%B8%80%EF%BC%8C%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E6%A6%82%E5%BF%B5-toc"><a href="#%E4%B8%80%EF%BC%8C%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E6%A6%82%E5%BF%B5" rel="nofollow">一，层序遍历概念</a></p> 
<p id="%E4%BA%8C%EF%BC%8C%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E5%AE%9E%E7%8E%B0-toc"><a href="#%E4%BA%8C%EF%BC%8C%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">二，层序遍历的实现</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201%EF%BC%8C%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF-toc"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201%EF%BC%8C%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF" rel="nofollow">        1，层序遍历的实现思路</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02%EF%BC%8C%E5%88%9B%E5%BB%BA%E9%98%9F%E5%88%97-toc"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02%EF%BC%8C%E5%88%9B%E5%BB%BA%E9%98%9F%E5%88%97" rel="nofollow">        2，创建队列</a></p> 
<p id="Queue.h-toc"><a href="#Queue.h" rel="nofollow">        Queue.h</a></p> 
<p id="Queue.c-toc"><a href="#Queue.c" rel="nofollow">        Queue.c</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03%EF%BC%8C%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91-toc"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03%EF%BC%8C%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">        3，创建二叉树</a></p> 
<p id="BTree.h-toc"><a href="#BTree.h" rel="nofollow">        BTree.h</a></p> 
<p id="BTree.c-toc"><a href="#BTree.c" rel="nofollow">        BTree.c</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A04%EF%BC%8C%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E5%AE%9E%E7%8E%B0-toc"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A04%EF%BC%8C%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">        4，层序遍历的实现</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="%E4%B8%80%EF%BC%8C%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E6%A6%82%E5%BF%B5">一，层序遍历概念</h3> 
<blockquote> 
 <p><strong>层序遍历：除了先序遍历、中序遍历、后序遍历外，还可以对二叉树进行层序遍历；</strong></p> 
 <p><strong>设二叉树的根节点所在层数为1，层序遍历就是从所在二叉树的根节点出发，首先访问第一层的树根结点，然后从左到右访问第2层上的结点，接着是第三层的结点，以此类推，自上而下，自左至右逐层访问树的结点的过程就是层序遍历。</strong></p> 
</blockquote> 
<p><img alt="" height="733" src="https://images2.imgbox.com/75/85/80IkKWwp_o.png" width="1200"></p> 
<p></p> 
<h3 id="%E4%BA%8C%EF%BC%8C%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E5%AE%9E%E7%8E%B0">二，层序遍历的实现</h3> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201%EF%BC%8C%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF">        1，层序遍历的实现思路</h4> 
<blockquote> 
 <p><strong>层序遍历：按照每一行从左到右对二叉树的各个结点进行访问</strong></p> 
</blockquote> 
<p>但是呢，对一层访问结束了<strong>该如何访问下一层呢？</strong>就拿上图举例，<strong>访问完（4）结点后该如何访问（3）结点呢？（4）结点中并没有（3）结点的信息；</strong></p> 
<p><img alt="" height="733" src="https://images2.imgbox.com/c3/3f/aGGDBWcr_o.png" width="1200"></p> 
<p><strong>算法思路：</strong></p> 
<blockquote> 
 <p><strong>可以借助一个队列，首先将二叉树的根结点入队，然后访问出队结点并出队，如果有左孩子结点，左孩子结点也入队；如果有右孩子结点，右孩子结点也入队。然后访问出队结点并出队，直到队列为空为止</strong></p> 
</blockquote> 
<p>过程演示： </p> 
<p>（1）入队列，访问队头结点<strong>（1）</strong>，然后<strong>（1）</strong>出队列，此时<strong>（1）</strong>的左子树<strong>（2）</strong>右子树<strong>（4）</strong>相继入队列；<strong>此时队列： 头&lt;---- （2）（4）    &lt;---尾</strong></p> 
<p>访问队头结点<strong>（2）</strong>，然后<strong>（2）</strong>出队列，此时<strong>（2）</strong>的左子树<strong>（3）</strong>入队列，<strong>此时队列：（4）（3）</strong></p> 
<p>访问队头结点<strong>（4）</strong>，然后<strong>（4）</strong>出队列，此时<strong>（4）</strong>的左子树<strong>（5）</strong>右子树<strong>（6）</strong>相继入队列；</p> 
<p><strong>此时队列：（3）（5）（6）</strong></p> 
<p>访问队头结点<strong>（3）</strong>，然后<strong>（3）</strong>出队列，因为<strong>（3）</strong>没有左右子树，此时没有数据入队列，<strong>此时队列：（5）（6）</strong></p> 
<p>访问头结点<strong>（5）</strong>，然后<strong>（5</strong>）出队列，<strong>此时队列：（6）</strong></p> 
<p>访问头结点<strong>（6）</strong>，然后<strong>（6）</strong>出队列，<strong>此时队列：NULL，结束！</strong></p> 
<p></p> 
<p><strong>下面是另一棵二叉树的遍历来帮助我们理解；</strong></p> 
<p><img alt="" height="775" src="https://images2.imgbox.com/64/1d/2TMNIFRb_o.png" width="1200"></p> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02%EF%BC%8C%E5%88%9B%E5%BB%BA%E9%98%9F%E5%88%97">        2，创建队列</h4> 
<blockquote> 
 <p><strong>首先我们得创建一个队列，队列具体细节就不过多解释了，之前博客有专门的详细介绍过；</strong></p> 
 <p><strong>队列的性质：先进先出，也就是尾插，头删的单链表；</strong></p> 
</blockquote> 
<h4 id="Queue.h"><strong>        Queue.h</strong></h4> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1
#pragma once
#include&lt;stdio.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdlib.h&gt;
#include"BTree.h"

typedef BTNode* QDataType;
//结点
typedef struct QListNode
{
	struct QListNode* next;
	QDataType data;
}QNode;

// 队列
typedef struct Queue
{
	QNode* front; // 队头
	QNode* rear; //队尾
	int size;
}Queue;

// 初始化队列 
void QueueInit(Queue* q);
// 队头入队列 
void QueuePush(Queue* q, QDataType data);
// 队尾出队列 
void QueuePop(Queue* q);
// 获取队列头部元素 
QDataType QueueFront(Queue* q);
// 获取队列队尾元素 
QDataType QueueBack(Queue* q);
// 获取队列中有效元素个数 
int QueueSize(Queue* q);
// 判空
int QueueEmpty(Queue* q);
// 销毁队列 
void QueueDestroy(Queue* q);</code></pre> 
<h4 id="Queue.c">        Queue.c</h4> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1
#define _CRT_SECURE_NO_WARNINGS 1
#include"Queue.h"

// 初始化队列 
void QueueInit(Queue* q)
{
	assert(q);
	q-&gt;front = q-&gt;rear = NULL;
	q-&gt;size = 0;
}

// 队尾入队列 
void QueuePush(Queue* q, QDataType data)
{
	assert(q);
	QNode* newnode = (QNode*)malloc(sizeof(QNode));
	if (newnode == NULL)
	{
		perror("malloc");
		exit(-1);
	}
	newnode-&gt;next = NULL;
	newnode-&gt;data = data;
	if (q-&gt;front /*= q-&gt;rear*/ == NULL)//谨记判断不要用此等格式
	{
		q-&gt;front = q-&gt;rear = newnode;
	}
	else
	{
		q-&gt;rear-&gt;next = newnode;
		q-&gt;rear = newnode;
	}
	q-&gt;size++;
}
// 队头出队列 
void QueuePop(Queue* q)
{
	assert(q);
	assert(!QueueEmpty(q));
	if (q-&gt;front-&gt;next == NULL)
	{
		free(q-&gt;front);
		q-&gt;front = q-&gt;rear = NULL;
	}
	else
	{
		QNode* next = q-&gt;front-&gt;next;
		free(q-&gt;front);
		q-&gt;front = next;
	}
	q-&gt;size--;
}
// 获取队列头部元素 
QDataType QueueFront(Queue* q)
{
	assert(q);
	assert(!QueueEmpty(q));
	return q-&gt;front-&gt;data;
}
// 获取队列队尾元素 
QDataType QueueBack(Queue* q)
{
	assert(q);
	assert(!QueueEmpty(q));
	return q-&gt;rear-&gt;data;
}
// 获取队列中有效元素个数 
int QueueSize(Queue* q)
{
	assert(q);
	return q-&gt;size;
}
// 检测队列是否为空，如果为空返回非零结果，如果非空返回0 
int QueueEmpty(Queue* q)
{
	assert(q);
	return q-&gt;size == 0;
}
// 销毁队列 
void QueueDestroy(Queue* q)
{
	assert(q);

	QNode* cur = q-&gt;front;
	QNode* next = NULL;
	while (cur)
	{
		next = cur-&gt;next;
		free(cur);
		cur = next;
	}
	cur = NULL;
	q-&gt;rear = NULL;
}</code></pre> 
<p><strong>这队列已经构造完成了，我们还需要一棵二叉树；</strong></p> 
<p></p> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03%EF%BC%8C%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91">        3，创建二叉树</h4> 
<p><strong>二叉树之前我们也创建过，现在也不过多介绍了，直接上硬菜！</strong></p> 
<h4 id="BTree.h">        BTree.h</h4> 
<pre><code class="language-cpp">#pragma once
#include&lt;stdio.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdlib.h&gt;

typedef int BTDataType;
//二叉链
typedef struct BinaryTreeNode
{
	BTDataType data; // 当前结点值域	
	struct BinaryTreeNode* left; // 指向当前节点左孩子
	struct BinaryTreeNode* right; // 指向当前节点右孩子
}BTNode;

//动态创立新结点
BTNode* BuyNode(BTDataType x);
//创建二叉树
BTNode* GreatBTree();</code></pre> 
<h4 id="BTree.c">        BTree.c</h4> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1
#include"BTree.h"
#include"Queue.h"
//动态创立新结点
BTNode* BuyNode(BTDataType x)
{
	BTNode* newnode = (BTNode*)malloc(sizeof(BTNode));
	assert(newnode);
	newnode-&gt;data = x;
	newnode-&gt;left = NULL;
	newnode-&gt;right = NULL;
	return newnode;
}

//创建二叉树
BTNode* GreatBTree()
{
	BTNode* node1 = BuyNode(1);
	BTNode* node2 = BuyNode(2);
	BTNode* node3 = BuyNode(3);
	BTNode* node4 = BuyNode(4);
	BTNode* node5 = BuyNode(5);
	BTNode* node6 = BuyNode(6);

	node1-&gt;left = node2;
	node1-&gt;right = node4;
	node2-&gt;left = node3;
	node4-&gt;left = node5;
	node4-&gt;right = node6;

	return node1;
}</code></pre> 
<p>这个队列和二叉树的 <strong>.c文件</strong>都要包含彼此的头文件，将他们链接起来；</p> 
<p></p> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A04%EF%BC%8C%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E5%AE%9E%E7%8E%B0">        4，层序遍历的实现</h4> 
<p>按照之前的分析思路，以此构建代码；</p> 
<pre><code class="language-cpp">//层序遍历
void LevelOrder(BTNode* root)
{
	Queue q;
	// 初始化队列 
	QueueInit(&amp;q);
	// 队尾入队列 
	if (root)
	{
		QueuePush(&amp;q, root);
	}
	while (!QueueEmpty(&amp;q))
	{
		printf("%d ", QueueFront(&amp;q)-&gt;data);
		BTNode* cur = QueueFront(&amp;q);
		// 队头出队列
		QueuePop(&amp;q);
		if (cur-&gt;left)
		{
			QueuePush(&amp;q, cur-&gt;left);
		}
		if (cur-&gt;right)
		{
			QueuePush(&amp;q, cur-&gt;right);
		}
	}
}</code></pre> 
<pre><code class="language-cpp">int main()
{
	BTNode* root = GreatBTree();
	//层序遍历
	LevelOrder(root);
	return 0;
}</code></pre> 
<p><img alt="" height="391" src="https://images2.imgbox.com/26/e0/KNb0PVsl_o.png" width="1200"><strong> 确实是一层一层进行遍历的；</strong></p> 
<p><strong>之前的遍历都是递归实习的，而层序遍历是循环实现的，目前用c语言来实现的话因为没有队列的库，实现起来特别的繁琐，不过好理解，本身并不难，这就是层序遍历的实现；</strong></p> 
<p></p> 
<p><strong>第四阶段带大家了实现了层序遍历，后序会带大家刷一会经典题目来进行巩固；</strong></p> 
<p><strong>后面博主会陆续更新；</strong></p> 
<p><strong>如有不足之处欢迎来补充交流！</strong></p> 
<p><strong>完结。</strong></p> 
<hr> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0e5755bc2592a26347d24bdea385a64f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">前端——HTML中的常用标签详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5d8289a218f756ac99bdc5e0d96611c8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">02 java ---- Android 基础app开发</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>