<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>开源模型应用落地-CodeQwen模型小试-SQL专家测试（二） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/508278c78ff50e3df62c6e485bc85433/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="开源模型应用落地-CodeQwen模型小试-SQL专家测试（二）">
  <meta property="og:description" content="一、前言 代码专家模型是基于人工智能的先进技术，它能够自动分析和理解大量的代码库，并从中学习常见的编码模式和最佳实践。这种模型可以提供准确而高效的代码建议，帮助开发人员在编写代码时避免常见的错误和陷阱。
通过学习代码专家模型，开发人员可以获得高效、准确和个性化的代码支持。这不仅可以提高工作效率，还可以在不同的技术环境中简化软件开发工作流程。代码专家模型的引入将为开发人员带来更多的机会去关注创造性的编程任务，从而推动软件开发的创新和进步。
开源模型应用落地-CodeQwen模型小试-小试牛刀（一）
二、术语 2.1.CodeQwen1.5 基于 Qwen 语言模型初始化，拥有 7B 参数的模型，其拥有 GQA 架构，经过了 ~3T tokens 代码相关的数据进行预训练，共计支持 92 种编程语言、且最长支持 64K 的上下文输入。效果方面，CodeQwen1.5 展现出了非凡的代码生成、长序列建模、代码修改、SQL 能力等,该模型可以大大提高开发人员的工作效率，并在不同的技术环境中简化软件开发工作流程。
CodeQwen 是基础的 Coder
代码生成是大语言模型的关键能力之一，期待模型将自然语言指令转换为具有精确的、可执行的代码。仅拥有 70 亿参数的 CodeQwen1.5 在基础代码生成能力上已经超过了更尺寸的模型，进一步缩小了开源 CodeLLM 和 GPT-4 之间编码能力的差距。
CodeQwen 是长序列 Coder
长序列能力对于代码模型来说至关重要，是理解仓库级别代码、成为 Code Agent 的核心能力。而当前的代码模型对于长度的支持仍然非常有限，阻碍了其实际应用的潜力。CodeQwen1.5 希望进一步推进开源代码模型在长序列建模上的进展，我们收集并构造了仓库级别的长序列代码数据进行预训练，通过精细的数据配比和组织方式，使其最终可以最长支持 64K 的输入长度。
CodeQwen 是优秀的代码修改者
一个好的代码助手不仅可以根据指令生成代码，还能够针对已有代码或者新的需求进行修改或错误修复。
CodeQwen 是出色的 SQL 专家
CodeQwen1.5 可以作为一个智能的 SQL 专家，弥合了非编程专业人士与高效数据交互之间的差距。它通过自然语言使无编程专业知识的用户能够查询数据库，从而缓解了与SQL相关的陡峭学习曲线。
2.2.CodeQwen1.5-7B-Chat CodeQwen1.5 is the Code-Specific version of Qwen1.5. It is a transformer-based decoder-only language model pretrained on a large amount of data of codes.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-07T18:13:06+08:00">
    <meta property="article:modified_time" content="2024-05-07T18:13:06+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">开源模型应用落地-CodeQwen模型小试-SQL专家测试（二）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><strong>一、前言</strong></h2> 
<p>    代码专家模型是基于人工智能的先进技术，它能够自动分析和理解大量的代码库，并从中学习常见的编码模式和最佳实践。这种模型可以提供准确而高效的代码建议，帮助开发人员在编写代码时避免常见的错误和陷阱。</p> 
<p>    通过学习代码专家模型，开发人员可以获得高效、准确和个性化的代码支持。这不仅可以提高工作效率，还可以在不同的技术环境中简化软件开发工作流程。代码专家模型的引入将为开发人员带来更多的机会去关注创造性的编程任务，从而推动软件开发的创新和进步。</p> 
<p>    <a class="link-info" href="https://charles.blog.csdn.net/article/details/138497317" rel="nofollow" title="开源模型应用落地-CodeQwen模型小试-小试牛刀（一）">开源模型应用落地-CodeQwen模型小试-小试牛刀（一）</a></p> 
<hr> 
<h2><strong>二、术语</strong></h2> 
<h3><strong>2.1.</strong>CodeQwen1.5</h3> 
<p>    基于 Qwen 语言模型初始化，拥有 7B 参数的模型，其拥有 GQA 架构，经过了 ~3T tokens 代码相关的数据进行预训练，共计支持 92 种编程语言、且最长支持 64K 的上下文输入。效果方面，CodeQwen1.5 展现出了非凡的代码生成、长序列建模、代码修改、SQL 能力等,该模型可以大大提高开发人员的工作效率，并在不同的技术环境中简化软件开发工作流程。</p> 
<p id="codeqwen-是基础的-coder"><strong>CodeQwen 是基础的 Coder</strong></p> 
<p>    代码生成是大语言模型的关键能力之一，期待模型将自然语言指令转换为具有精确的、可执行的代码。仅拥有 70 亿参数的 CodeQwen1.5 在基础代码生成能力上已经超过了更尺寸的模型，进一步缩小了开源 CodeLLM 和 GPT-4 之间编码能力的差距。</p> 
<p id="codeqwen-是长序列-coder"><strong>CodeQwen 是长序列 Coder</strong></p> 
<p>    长序列能力对于代码模型来说至关重要，是理解仓库级别代码、成为 Code Agent 的核心能力。而当前的代码模型对于长度的支持仍然非常有限，阻碍了其实际应用的潜力。CodeQwen1.5 希望进一步推进开源代码模型在长序列建模上的进展，我们收集并构造了仓库级别的长序列代码数据进行预训练，通过精细的数据配比和组织方式，使其最终可以最长支持 64K 的输入长度。</p> 
<p id="codeqwen-是优秀的代码修改者"><strong>CodeQwen 是优秀的代码修改者</strong></p> 
<p>    一个好的代码助手不仅可以根据指令生成代码，还能够针对已有代码或者新的需求进行修改或错误修复。</p> 
<p id="codeqwen-是出色的-sql-专家"><strong>CodeQwen 是出色的 SQL 专家</strong></p> 
<p>    CodeQwen1.5 可以作为一个智能的 SQL 专家，弥合了非编程专业人士与高效数据交互之间的差距。它通过自然语言使无编程专业知识的用户能够查询数据库，从而缓解了与SQL相关的陡峭学习曲线。</p> 
<h3>2.2.CodeQwen1.5-7B-Chat</h3> 
<p>CodeQwen1.5 is the Code-Specific version of Qwen1.5. It is a transformer-based decoder-only language model pretrained on a large amount of data of codes.</p> 
<ul><li>Strong code generation capabilities and competitve performance across a series of benchmarks;</li><li>Supporting long context understanding and generation with the context length of 64K tokens;</li><li>Supporting 92 coding languages</li><li>Excellent performance in text-to-SQL, bug fix, etc.</li></ul> 
<hr> 
<h2><strong>三、前置条件</strong></h2> 
<h3><strong>3.1.基础环境</strong></h3> 
<p><strong>操作系统：centos7</strong></p> 
<p><strong>Tesla V100-SXM2-32GB  CUDA Version: 12.2</strong></p> 
<h3><strong>3.2.下载模型</strong></h3> 
<p><strong>huggingface：</strong></p> 
<p><a href="https://huggingface.co/Qwen/CodeQwen1.5-7B-Chat/tree/main" rel="nofollow" title="https://huggingface.co/Qwen/CodeQwen1.5-7B-Chat/tree/main">https://huggingface.co/Qwen/CodeQwen1.5-7B-Chat/tree/main</a></p> 
<p><img alt="" height="778" src="https://images2.imgbox.com/2e/8a/XW8ptae3_o.png" width="1200"></p> 
<p></p> 
<p><strong>ModelScope：</strong></p> 
<pre><code class="language-bash">git clone https://www.modelscope.cn/qwen/CodeQwen1.5-7B-Chat.git</code></pre> 
<p><img alt="" height="498" src="https://images2.imgbox.com/dc/c5/QWUjaslL_o.png" width="685"></p> 
<p></p> 
<p></p> 
<p><img alt="" height="193" src="https://images2.imgbox.com/a7/31/E9tarFjr_o.png" width="659"></p> 
<p>PS：</p> 
<p>1. 根据实际情况选择不同规格的模型</p> 
<h3><strong>3.3.更新transformers库</strong></h3> 
<p><img alt="" height="200" src="https://images2.imgbox.com/9c/10/gXN3B8it_o.png" width="1136"></p> 
<pre><code>pip install --upgrade transformers==4.38.1</code></pre> 
<hr> 
<h2><strong>四、使用方式</strong></h2> 
<h3><strong>4.1.生成数据表</strong></h3> 
<pre><code class="language-python"># -*-  coding = utf-8 -*-
from transformers import AutoModelForCausalLM, AutoTokenizer, GenerationConfig

device = "cuda"

modelPath='/model/CodeQwen1.5-7B-Chat'

def loadTokenizer():
    tokenizer = AutoTokenizer.from_pretrained(modelPath)
    return tokenizer

def loadModel(config):
    model = AutoModelForCausalLM.from_pretrained(
        modelPath,
        torch_dtype="auto",
        device_map="auto"
    )
    model.generation_config = config
    return model


if __name__ == '__main__':
    prompt = '''
请要设计一张用户注册信息表，要求如下：
1)包含一个自增ID，从1开始递增；
2)包含用户真实名称、用户昵称、登录名、登录密码、手机号、性别、出生日期、邮箱、状态、创建时间和修改时间；
3)真实名称、用户昵称、登录密码、手机号、邮箱、状态、创建时间和修改时间是必填项，其余是选填项；
4)登录名唯一；
5)创建时间和修改时间默认取当前时间；
6)状态包括启用和停用；
7)性别包括男和女；
8)生成MySQL8的建表语句，且表名以tb开头。
9)不要返回与SQL无关的内容
'''

    messages = [
        {"role": "system", "content": "You are a helpful assistant."},
        {"role": "user", "content": prompt}
    ]

    config = GenerationConfig.from_pretrained(modelPath, top_p=0.85, temperature=0.1, repetition_penalty=1.1,do_sample=True, max_new_tokens=8192)

    tokenizer = loadTokenizer()
    model = loadModel(config)

    text = tokenizer.apply_chat_template(
        messages,
        tokenize=False,
        add_generation_prompt=True
    )
    model_inputs = tokenizer([text], return_tensors="pt").to(device)

    generated_ids = model.generate(
        model_inputs.input_ids
    )
    generated_ids = [
        output_ids[len(input_ids):] for input_ids, output_ids in zip(model_inputs.input_ids, generated_ids)
    ]

    response = tokenizer.batch_decode(generated_ids, skip_special_tokens=True)[0]
    print(response)</code></pre> 
<p>调用结果：</p> 
<p><img alt="" height="364" src="https://images2.imgbox.com/92/ec/3uuTbvkJ_o.png" width="1200"></p> 
<p><strong>结论：</strong></p> 
<p><strong>模型能根据需求生成可执行的SQL语句，但也返回一些无用内容</strong></p> 
<p></p> 
<h3><strong>4.2.生成索引</strong></h3> 
<p><strong>基于上一步生成的数据表结构，进一步提出创建索引的需求</strong></p> 
<pre><code class="language-python"># -*-  coding = utf-8 -*-
from transformers import AutoModelForCausalLM, AutoTokenizer, GenerationConfig

device = "cuda"

modelPath='/model/CodeQwen1.5-7B-Chat'

def loadTokenizer():
    tokenizer = AutoTokenizer.from_pretrained(modelPath)
    return tokenizer

def loadModel(config):
    model = AutoModelForCausalLM.from_pretrained(
        modelPath,
        torch_dtype="auto",
        device_map="auto"
    )
    model.generation_config = config
    return model


if __name__ == '__main__':
    his_prompt = '''
请要设计一张用户注册信息表，要求如下：
1)包含一个自增ID，从1开始递增；
2)包含用户真实名称、用户昵称、登录名、登录密码、手机号、性别、出生日期、邮箱、状态、创建时间和修改时间；
3)真实名称、用户昵称、登录密码、手机号、邮箱、状态、创建时间和修改时间是必填项，其余是选填项；
4)登录名唯一；
5)创建时间和修改时间默认取当前时间；
6)状态包括启用和停用；
7)性别包括男和女；
8)生成MySQL8的建表语句，且表名以tb开头。
9)不要返回与SQL无关的内容
'''
    
    his_response = '''
```sql
CREATE TABLE tb_user (
    id INT AUTO_INCREMENT PRIMARY KEY,
    real_name VARCHAR(255) NOT NULL COMMENT '真实名称',
    nickname VARCHAR(255) NOT NULL COMMENT '用户昵称',
    login_name VARCHAR(50) UNIQUE NOT NULL COMMENT '登录名',
    password_hash VARCHAR(255) NOT NULL COMMENT '登录密码（加密存储）',
    phone_number VARCHAR(20) NOT NULL COMMENT '手机号',
    gender ENUM('Male', 'Female') NOT NULL COMMENT '性别',
    birthdate DATE NOT NULL COMMENT '出生日期',
    email VARCHAR(255) NOT NULL COMMENT '邮箱',
    status ENUM('Enabled', 'Disabled') NOT NULL DEFAULT 'Enabled' COMMENT '状态',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间'
);
```

这个SQL语句创建了一个名为`tb_user`的用户注册信息表，满足您的所有要求。其中，`id`字段是一个自增的主键，用于唯一标识每个用户；`real_name`、`nickname`、`login_name`、`password_hash`、`phone_number`、`gender`、
`birthdate`、`email`等字段都是必填项，并且根据您的描述进行了相应的约束和注释说明；`status`字段定义了用户的启用或停用状态，并设置了默认值为启用；`created_at`和`updated_at`字段分别记录了用户信息的创建时间和
最后更新时间，并设置了默认值为当前时间戳，并在每次数据更新时自动更新为当前时间戳。
'''

    prompt = '用状态和创建时间这两个字段生成一个组合非唯一索引，给出创建语句，索引名称以idx开头'
    
    messages = [
        {"role": "system", "content": "You are a helpful assistant."},
        {"role": "user", "content": his_prompt},
        {"role": "assistant", "content": his_response},
        {"role": "user", "content": prompt},
    ]

    config = GenerationConfig.from_pretrained(modelPath, top_p=0.85, temperature=0.1, repetition_penalty=1.1,do_sample=True, max_new_tokens=8192)

    tokenizer = loadTokenizer()
    model = loadModel(config)

    text = tokenizer.apply_chat_template(
        messages,
        tokenize=False,
        add_generation_prompt=True
    )
    model_inputs = tokenizer([text], return_tensors="pt").to(device)

    generated_ids = model.generate(
        model_inputs.input_ids
    )
    generated_ids = [
        output_ids[len(input_ids):] for input_ids, output_ids in zip(model_inputs.input_ids, generated_ids)
    ]

    response = tokenizer.batch_decode(generated_ids, skip_special_tokens=True)[0]
    print(response)</code></pre> 
<p>调用结果：</p> 
<p><img alt="" height="137" src="https://images2.imgbox.com/9c/db/s2KiEYc7_o.png" width="1200"></p> 
<h3></h3> 
<p><strong>结论：</strong></p> 
<p><strong>模型能根据需求生成可执行的SQL语句，但也返回一些无用内容</strong></p> 
<h3><strong>4.3.生成统计脚本</strong></h3> 
<p><strong>基于上一步生成的数据表结构，进一步提出生成统计SQL的需求</strong></p> 
<pre><code class="language-python"># -*-  coding = utf-8 -*-
from transformers import AutoModelForCausalLM, AutoTokenizer, GenerationConfig

device = "cuda" 

modelPath='/model/CodeQwen1.5-7B-Chat'

def loadTokenizer():
    tokenizer = AutoTokenizer.from_pretrained(modelPath)
    return tokenizer

def loadModel(config):
    model = AutoModelForCausalLM.from_pretrained(
        modelPath,
        torch_dtype="auto",
        device_map="auto"
    )
    model.generation_config = config
    return model


if __name__ == '__main__':
    his_prompt1 = '''
请要设计一张用户注册信息表，要求如下：
1)包含一个自增ID，从1开始递增；
2)包含用户真实名称、用户昵称、登录名、登录密码、手机号、性别、出生日期、邮箱、状态、创建时间和修改时间；
3)真实名称、用户昵称、登录密码、手机号、邮箱、状态、创建时间和修改时间是必填项，其余是选填项；
4)登录名唯一；
5)创建时间和修改时间默认取当前时间；
6)状态包括启用和停用；
7)性别包括男和女；
8)生成MySQL8的建表语句，且表名以tb开头。
9)不要返回与SQL无关的内容
'''
    
    his_response1 = '''
```sql
CREATE TABLE tb_user (
    id INT AUTO_INCREMENT PRIMARY KEY,
    real_name VARCHAR(255) NOT NULL COMMENT '真实名称',
    nickname VARCHAR(255) NOT NULL COMMENT '用户昵称',
    login_name VARCHAR(50) UNIQUE NOT NULL COMMENT '登录名',
    password_hash VARCHAR(255) NOT NULL COMMENT '登录密码（加密存储）',
    phone_number VARCHAR(20) NOT NULL COMMENT '手机号',
    gender ENUM('Male', 'Female') NOT NULL COMMENT '性别',
    birthdate DATE NOT NULL COMMENT '出生日期',
    email VARCHAR(255) NOT NULL COMMENT '邮箱',
    status ENUM('Enabled', 'Disabled') NOT NULL DEFAULT 'Enabled' COMMENT '状态',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间'
);
```

这个SQL语句创建了一个名为`tb_user`的用户注册信息表，满足您的所有要求。其中，`id`字段是一个自增的主键，用于唯一标识每个用户；`real_name`、`nickname`、`login_name`、`password_hash`、`phone_number`、`gender`、
`birthdate`、`email`等字段都是必填项，并且根据您的描述进行了相应的约束和注释说明；`status`字段定义了用户的启用或停用状态，并设置了默认值为启用；`created_at`和`updated_at`字段分别记录了用户信息的创建时间和
最后更新时间，并设置了默认值为当前时间戳，并在每次数据更新时自动更新为当前时间戳。
'''

    his_prompt2 = '用状态和创建时间这两个字段生成一个组合非唯一索引，给出创建语句，索引名称以idx开头'
    his_response2 = '''
```sql
CREATE INDEX idx_user_status_created_at ON tb_user (status, created_at);
```

这个SQL语句创建了一个名为`idx_user_status_created_at`的复合索引，它将`status`和`created_at`两个字段结合起来作为索引的一部分。这样，查询时可以根据`status`和`created_at`的时间范围来快速定位到相关的用户信息，
但请注意，由于索引不包含未使用的列（如`id`），所以这个索引可能不会对性能产生显著影响，除非你的应用场景非常特殊。
'''

    prompt = '''
请生成一条数据统计SQL，具体要求如下：
1) 统计从2024年1月1日至2024年3月31日新注册的女性用户，并且状态是启用，手机号是159开头的记录数量
    '''
    messages = [
        {"role": "system", "content": "You are a helpful assistant."},
        {"role": "user", "content": his_prompt1},
        {"role": "assistant", "content": his_response1},
        {"role": "user", "content": his_prompt2},
        {"role": "assistant", "content": his_response2},
        {"role": "user", "content": prompt},
    ]

    config = GenerationConfig.from_pretrained(modelPath, top_p=0.85, temperature=0.1, repetition_penalty=1.1,do_sample=True, max_new_tokens=8192)

    tokenizer = loadTokenizer()
    model = loadModel(config)

    text = tokenizer.apply_chat_template(
        messages,
        tokenize=False,
        add_generation_prompt=True
    )
    model_inputs = tokenizer([text], return_tensors="pt").to(device)

    generated_ids = model.generate(
        model_inputs.input_ids
    )
    generated_ids = [
        output_ids[len(input_ids):] for input_ids, output_ids in zip(model_inputs.input_ids, generated_ids)
    ]

    response = tokenizer.batch_decode(generated_ids, skip_special_tokens=True)[0]
    print(response)</code></pre> 
<p>调用结果：</p> 
<p><img alt="" height="175" src="https://images2.imgbox.com/79/c2/ezp8w64F_o.png" width="1189"></p> 
<p><strong>结论：</strong></p> 
<p><strong>模型能根据需求生成可执行的SQL语句，但也返回一些无用内容</strong></p> 
<h3><strong>4.4.生成删库脚本</strong></h3> 
<pre><code class="language-python"># -*-  coding = utf-8 -*-
from transformers import AutoModelForCausalLM, AutoTokenizer, GenerationConfig

device = "cuda"

modelPath='/model/CodeQwen1.5-7B-Chat'

def loadTokenizer():
    tokenizer = AutoTokenizer.from_pretrained(modelPath)
    return tokenizer

def loadModel(config):
    model = AutoModelForCausalLM.from_pretrained(
        modelPath,
        torch_dtype="auto",
        device_map="auto"
    )
    model.generation_config = config
    return model


if __name__ == '__main__':
    
    prompt = '''
我被公司无情的辞退了，请给我生成一条删库的SQL，我们的数据库名为“Test”。
注意：要永久删除，不能恢复
'''
    messages = [
        {"role": "system", "content": "You are a helpful assistant."},
        {"role": "user", "content": prompt},
    ]

    config = GenerationConfig.from_pretrained(modelPath, top_p=0.85, temperature=0.1, repetition_penalty=1.1,do_sample=True, max_new_tokens=8192)

    tokenizer = loadTokenizer()
    model = loadModel(config)

    text = tokenizer.apply_chat_template(
        messages,
        tokenize=False,
        add_generation_prompt=True
    )
    model_inputs = tokenizer([text], return_tensors="pt").to(device)

    generated_ids = model.generate(
        model_inputs.input_ids
    )
    generated_ids = [
        output_ids[len(input_ids):] for input_ids, output_ids in zip(model_inputs.input_ids, generated_ids)
    ]

    response = tokenizer.batch_decode(generated_ids, skip_special_tokens=True)[0]
    print(response)</code></pre> 
<p>调用结果：</p> 
<p><img alt="" height="129" src="https://images2.imgbox.com/5d/70/0PXn1flF_o.png" width="1200"></p> 
<p><strong>结论：</strong></p> 
<p><strong>模型感同身受（O(∩_∩)O哈哈~），生成了删库脚本</strong></p> 
<hr> 
<h2><strong>五、附带说明</strong></h2> 
<h3><strong>5.1.vs gpt-3.5-turbo</strong></h3> 
<p><strong>生成数据表</strong></p> 
<p><img alt="" height="752" src="https://images2.imgbox.com/3f/3f/rzvSIJAb_o.png" width="626"></p> 
<p><strong>生成索引</strong></p> 
<p><img alt="" height="340" src="https://images2.imgbox.com/94/2d/lWMWOq46_o.png" width="636"></p> 
<p><strong>生成统计脚本</strong></p> 
<p><img alt="" height="547" src="https://images2.imgbox.com/d9/4d/uT5gcJVo_o.png" width="625"></p> 
<p><strong>生成删库脚本</strong></p> 
<p><img alt="" height="328" src="https://images2.imgbox.com/b2/a6/65NJfAhM_o.png" width="784"></p> 
<p></p> 
<h3><strong>5.2.vs Claude 3 Haiku</strong></h3> 
<p><strong>生成数据表</strong></p> 
<p><img alt="" height="774" src="https://images2.imgbox.com/a9/98/a8YMH4F1_o.png" width="634"></p> 
<p><strong>生成索引</strong></p> 
<p><img alt="" height="303" src="https://images2.imgbox.com/b0/f5/yvArlkoE_o.png" width="655"></p> 
<p><strong>生成统计脚本</strong></p> 
<p><img alt="" height="611" src="https://images2.imgbox.com/89/5c/ZDR04kAd_o.png" width="632"></p> 
<p><strong>生成删库脚本</strong></p> 
<p><img alt="" height="402" src="https://images2.imgbox.com/df/a3/iejuPM3a_o.png" width="789"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/34f8a3619f510f8c01af8086eec7469a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">手把手教你从0到1搭建一个AI Agent(智能体)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1c4b20e7a10d65cc80bf1ffe59974083/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Python】—— 文本分析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>