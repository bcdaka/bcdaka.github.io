<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>贪心算法介绍（Greedy Algorithm） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/0b202958dc4493241254be8f4a816685/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="贪心算法介绍（Greedy Algorithm）">
  <meta property="og:description" content="贪心算法介绍（Greedy Algorithm） 1. 贪心算法概念简介 ​ 贪心算法Greedy Algorithm是一种在每一步选择中都采取当前状态下最优（或最有利）决策的算法策略，以期望通过这样的局部最优决策达到全局最优解。它适用于那些具有最优子结构的问题，即问题的最优解包含其子问题的最优解。贪心算法的关键在于它做出的选择是不可逆的，一旦选择了某个选项，就不会再回溯考虑其他选项。
通过示例来感受贪心算法的思想 有一堆不同大小的饼干，大小分别为 1, 3, 2, 4, 5。而面前有一群孩子，胃口也不一样。每个孩子的胃口代表了他们最小能接受的饼干大小，比如说，有的孩子最少要吃一个大小为 3 的饼干才能满足。
目标是尽可能多地满足孩子们的胃口。
饼干大小：3, 2, 1, 4, 5
孩子胃口：3, 2, 4
贪心算法的过程 排序：将饼干和孩子的胃口从小到大排序。
饼干：1, 2, 3, 4, 5孩子：2, 3, 4 逐步计算选择最小的满足：
第一个孩子胃口为 2，直接选择大小为 2 的饼干满足他。第二个孩子胃口为 3，直接选择大小为 3 的饼干满足他。第三个孩子胃口为 4，直接选择大小为 4 的饼干满足他。 结果：你成功地满足了 3 个孩子。贪心算法通过每一步都做出当前看起来最好的选择（用最小的饼干去满足最小的胃口），得出了一个不错的结果。
使用非贪心算法的思维来解决的方式
动态规划的过程（非贪心算法） 状态定义：
创建一个二维数组 dp[i][j]，表示用前 i 个饼干去满足前 j 个孩子能达到的最大满足数。 初始化：
dp[0][0] = 0 表示没有饼干和没有孩子时，满足的孩子数为 0。 状态转移：
当不使用当前饼干：dp[i][j] = dp[i-1][j]当使用当前饼干（前提是饼干大小满足孩子的胃口）：dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] &#43; 1) 逐步计算：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-14T17:08:23+08:00">
    <meta property="article:modified_time" content="2024-08-14T17:08:23+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">贪心算法介绍（Greedy Algorithm）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Greedy_Algorithm_0"></a>贪心算法介绍（Greedy Algorithm）</h2> 
<h3><a id="1__2"></a>1. 贪心算法概念简介</h3> 
<p>​ 贪心算法Greedy Algorithm是一种在每一步选择中都采取当前状态下最优（或最有利）决策的算法策略，以期望通过这样的局部最优决策达到全局最优解。它适用于那些具有最优子结构的问题，即问题的最优解包含其子问题的最优解。贪心算法的关键在于它做出的选择是不可逆的，一旦选择了某个选项，就不会再回溯考虑其他选项。</p> 
<ul><li>通过示例来感受贪心算法的思想</li></ul> 
<blockquote> 
 <p>有一堆不同大小的饼干，大小分别为 1, 3, 2, 4, 5。而面前有一群孩子，胃口也不一样。每个孩子的胃口代表了他们最小能接受的饼干大小，比如说，有的孩子最少要吃一个大小为 3 的饼干才能满足。</p> 
 <p>目标是尽可能多地满足孩子们的胃口。</p> 
 <p><strong>饼干大小</strong>：3, 2, 1, 4, 5</p> 
 <p><strong>孩子胃口</strong>：3, 2, 4</p> 
 <ul><li>贪心算法的过程</li></ul> 
 <ol><li> <p><strong>排序</strong>：将饼干和孩子的胃口从小到大排序。</p> 
   <ul><li>饼干：1, 2, 3, 4, 5</li><li>孩子：2, 3, 4</li></ul> </li><li> <p><strong>逐步计算选择最小的满足</strong>：</p> 
   <ul><li>第一个孩子胃口为 2，直接选择大小为 2 的饼干满足他。</li><li>第二个孩子胃口为 3，直接选择大小为 3 的饼干满足他。</li><li>第三个孩子胃口为 4，直接选择大小为 4 的饼干满足他。</li></ul> </li><li> <p><strong>结果</strong>：你成功地满足了 3 个孩子。贪心算法通过每一步都做出当前看起来最好的选择（用最小的饼干去满足最小的胃口），得出了一个不错的结果。</p> </li></ol> 
 <p>使用非贪心算法的思维来解决的方式</p> 
 <ul><li>动态规划的过程（非贪心算法）</li></ul> 
 <ol><li> <p><strong>状态定义</strong>：</p> 
   <ul><li>创建一个二维数组 <code>dp[i][j]</code>，表示用前 <code>i</code> 个饼干去满足前 <code>j</code> 个孩子能达到的最大满足数。</li></ul> </li><li> <p><strong>初始化</strong>：</p> 
   <ul><li><code>dp[0][0] = 0</code> 表示没有饼干和没有孩子时，满足的孩子数为 0。</li></ul> </li><li> <p><strong>状态转移</strong>：</p> 
   <ul><li><strong>当不使用当前饼干</strong>：<code>dp[i][j] = dp[i-1][j]</code></li><li><strong>当使用当前饼干</strong>（前提是饼干大小满足孩子的胃口）：<code>dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + 1)</code></li></ul> </li><li> <p><strong>逐步计算</strong>：</p> 
   <ul><li>用第一个饼干（大小为 1），不能满足任何孩子，所以 <code>dp[1][j] = 0</code> 对于所有 <code>j</code>。</li><li>用第二个饼干（大小为 2），可以满足第一个孩子，更新 <code>dp[2][1] = 1</code>。</li><li>用第三个饼干（大小为 3），可以满足第二个孩子，更新 <code>dp[3][2] = 2</code>。</li><li>用第四个饼干（大小为 4），可以满足第三个孩子，更新 <code>dp[4][3] = 3</code>。</li><li>用第五个饼干（大小为 5），没有其他孩子可以满足，但可以继续保持 <code>dp[5][3] = 3</code>。</li></ul> </li><li> <p><strong>结果</strong>：最终，<code>dp[5][3] = 3</code> 表示最多可以满足 3 个孩子。</p> </li></ol> 
 <ul><li> <p>对比分析</p> 
   <ul><li> <p><strong>贪心算法</strong>：</p> 
     <ul><li><strong>思路</strong>：每一步选择当前最优解，不考虑未来可能性。</li><li><strong>优点</strong>：计算速度快，适合简单或可以局部最优逼近全局最优的问题。</li><li><strong>结果</strong>：在这个例子中，贪心算法直接选择合适的饼干来满足每个孩子，最终结果为 3 个孩子满足。</li></ul> </li><li> <p><strong>动态规划</strong>：</p> 
     <ul><li><strong>思路</strong>：通过记录之前的计算结果，考虑所有可能的情况来构建全局最优解。</li><li><strong>优点</strong>：能够找到全局最优解，适合复杂问题。</li><li><strong>结果</strong>：动态规划考虑了所有可能的分配方式，得到了最大可能的 3 个孩子满足。</li></ul> </li></ul> </li></ul> 
 <p>虽然在这个例子中，贪心算法和动态规划的结果相同，但贪心算法只在局部做出最优选择，不保证全局最优。而动态规划通过全面分析，确保找到了全局最优解。动态规划的计算更复杂，但适用于需要全局最优解的问题。</p> 
</blockquote> 
<h3><a id="2__76"></a>2. 贪心算法的特点</h3> 
<ol><li> <p><strong>贪心选择性质</strong>：</p> 
  <ul><li>贪心算法在每一步都做出当前看起来最优的选择，而不考虑这个选择对未来步骤的影响。这种选择是基于问题的贪心选择性质，即问题具有这样的结构：局部最优选择可以导致全局最优解。</li></ul> </li><li> <p><strong>无回溯</strong>：</p> 
  <ul><li> <p>与动态规划等其他算法不同，贪心算法做出选择后不会回溯。这意味着一旦做出了一个贪心选择，算法就会继续前进，即使这个选择在后来看起来可能不是最佳选择。</p> 
    <blockquote> 
     <p>贪心算法的不回溯特性强调了算法的确定性和一次性，每次选择都是最终的，不依赖于未来的信息，也不考虑撤销或修改之前的选择。这种特性使得贪心算法在某些问题上非常高效，但在其他问题上可能需要更复杂的算法来确保找到全局最优解。</p> 
    </blockquote> </li></ul> </li><li> <p><strong>子问题局部最优</strong>：</p> 
  <ul><li>贪心算法通常用于具有最优子结构的问题，即一个问题的最优解包含其子问题的最优解。这种特性允许算法在构建解决方案的过程中，利用子问题的局部最优解。</li></ul> </li><li> <p><strong>简单高效</strong>：</p> 
  <ul><li>贪心算法通常易于理解和实现，因为它的决策过程直观且不需要复杂的优化过程。此外，由于贪心算法不需要存储所有可能的解决方案，因此它在空间复杂度上通常很低。</li></ul> </li><li> <p><strong>不保证全局最优</strong>：</p> 
  <ul><li>尽管贪心算法在某些问题上能够找到全局最优解，但它并不保证在所有情况下都能找到。这取决于问题本身是否满足贪心选择性质和最优子结构。</li></ul> </li></ol> 
<h3><a id="3__97"></a>3. 贪心算法的应用场景</h3> 
<ul><li><strong>物流优化</strong>：在物流配送中，使用贪心算法来规划最短或最快路径，例如快递员的包裹派送顺序，以减少行驶距离和时间 。</li></ul> 
<blockquote> 
 <p>贪心算法在物流优化中的应用主要体现在配送路径的选择上。其核心原理是每一步都选择当前状态下的最优决策，以期望最终得到全局的最优解。在物流配送系统中，这通常意味着选择最短或成本最低的配送路径，以达到节省时间和成本的目的。</p> 
 <p>具体来说，贪心算法在物流配送中的优化原理可以这样理解：假设一个快递员需要配送多个包裹到不同的地点，使用贪心算法，快递员会先选择最近的一个配送点进行配送，完成后再选择下一个最近的点，依此类推，直到所有的配送任务完成。这种方法简单快捷，能够快速得到一个近似的最优解，尽管这个解可能不是绝对最优的 。</p> 
</blockquote> 
<ul><li><strong>网络路由选择</strong>：在计算机网络中，通过贪心算法选择数据传输的最优路径，例如OSPF（开放最短路径优先）协议 。</li></ul> 
<blockquote> 
 <p>贪心算法在网络路由选择中的应用主要是基于其局部最优策略来实现快速决策。在网络路由选择中，贪心算法可以帮助路由器选择到目的地的最短路径或者成本最低的路径。其基本原理是，在每个决策点上，路由器会根据当前可用的信息，选择一条看似最优的路径，而不考虑这条路径对后续路由选择的影响 。</p> 
 <p>在实际的网络协议中，OSPF（Open Shortest Path First）是一个广泛应用的链路状态路由协议，它使用Dijkstra算法来计算最短路径树，从而确定到达每个目的地的最佳路径 。OSPF协议能够快速响应网络拓扑的变化，并且计算出的路由路径较为优化 。</p> 
 <p>贪心算法并不总是能够得到全局最优解。在某些情况下，例如在存在环路或者路径成本突然增加的场景下，贪心算法可能会陷入次优解。因此，在设计路由算法时，需要考虑网络的具体特点和需求，结合其他算法或机制来确保路由的稳定性和效率</p> 
</blockquote> 
<ul><li><strong>任务调度</strong>：在计算机系统中，贪心算法用于CPU任务调度，选择优先级最高或最早截止时间的任务先执行 。</li></ul> 
<blockquote> 
 <p>贪心算法在任务调度领域的应用原理是选择当前最优的任务进行执行，以期望通过局部最优选择累积达到全局的优化目标。这种策略通常涉及对任务列表按照特定标准（如最短执行时间、最晚截止时间或最高优先级）进行排序，然后依次考虑每个任务，根据当前资源状态和约束条件决定是否执行该任务。贪心算法的决策过程是即时的，不涉及对过去选择的回溯，这使得算法在很多情况下能够快速得到一个可行的解决方案，尽管这不一定是绝对最优的。</p> 
</blockquote> 
<ul><li><strong>数据压缩</strong>：霍夫曼编码是一种使用贪心算法的数据压缩技术，通过为频繁出现的字符分配较短的编码来优化存储空间 。</li></ul> 
<blockquote> 
 <p>贪心算法在数据压缩中的应用主要是通过霍夫曼编码（Huffman Coding）实现的。霍夫曼编码是一种非常有效的数据压缩技术，它利用了贪心算法来为数据中的每个字符分配一个变长的编码，其中出现频率高的字符被分配较短的编码，而出现频率低的字符被分配较长的编码，从而实现整体数据的压缩 。</p> 
 <p>霍夫曼编码的实现原理基于构建一棵霍夫曼树，这棵树是通过一个由字符出现频率决定的优先队列构建的。算法从队列中取出频率最小的两个节点，将它们合并为一个新节点，新节点的频率是这两个节点频率之和，这个过程不断重复，直到队列中只剩下一个节点，这个节点就是霍夫曼树的根节点 。</p> 
 <p>在构建霍夫曼树的过程中，树中的每个左节点对应一个’0’编码，每个右节点对应一个’1’编码。从根节点到叶节点的路径就形成了字符的霍夫曼编码。由于霍夫曼编码要求任何编码都不是其他编码的前缀，这样可以保证解码时不会出现歧义 。</p> 
 <p>使用霍夫曼编码进行数据压缩的过程可以显著减少数据的存储空间，压缩率通常在20%到90%之间，这取决于数据的特性。霍夫曼编码不仅考察了文本中不同字符的数量，还考虑了每个字符出现的频率，通过这种方式，霍夫曼编码实现了数据的有效压缩</p> 
</blockquote> 
<ul><li><strong>股票交易分析</strong>：在金融领域，贪心算法可以用来模拟股票买卖，选择最优的买入和卖出时机以最大化利润 。</li></ul> 
<blockquote> 
 <p>贪心算法在股票交易策略中的应用是利用局部最优决策来实现利润最大化。它通过跟踪股票价格变动，在价格低点买入并在高点卖出，以此累积利润。同时，算法会考虑交易成本如手续费，并适应市场规则，例如交易冷冻期和交易次数限制。贪心算法的实现简单高效，适合快速变化的股票市场，尽管它不保证全局最优，但通常能够获得接近最优的交易结果。</p> 
</blockquote> 
<ul><li><strong>广告投放</strong>：在广告行业，通过贪心算法优化广告投放策略，选择最有效的广告组合和展示顺序以吸引用户 。</li></ul> 
<blockquote> 
 <p>贪心算法在广告投放领域的应用主要体现在对广告展示机会的优化分配上。具体来说，广告系统需要在多个广告主的合约中做出选择，以确保每个广告主都能获得合约中规定的曝光量，同时还要考虑到曝光的时间分布，避免广告在短期内过度集中展示 。这种分配问题可以视为一个优化问题，其中贪心算法因其简单高效的特性而被广泛应用。</p> 
 <p>在广告投放中，贪心算法的一个典型应用是解决合约制广告的在线分配问题。这类问题通常涉及到大量的广告主合约和流量，算法需要在保证所有合约完成的同时，尽可能地满足广告主对曝光量和时间分布的要求。贪心算法通过在每次曝光机会出现时，选择当前最优的广告主进行展示，从而实现对广告流量的动态分配 。</p> 
 <p>贪心算法还可以用于处理广告投放中的其他优化问题，如广告位的分配、广告内容的个性化推荐等。在这些场景中，贪心算法通过在每一步选择中采取当前最优的决策，以达到整体的优化目标</p> 
</blockquote> 
<h3><a id="4__151"></a>4. 贪心算法的优缺点</h3> 
<ul><li><strong>优点</strong></li></ul> 
<ol><li><strong>简单高效</strong>：贪心算法通常易于理解和实现，执行速度快，不需要复杂的优化过程。</li><li><strong>快速得到解决方案</strong>：贪心算法能够迅速给出问题的解决方案，对于需要即时决策的问题特别有用。</li><li><strong>空间效率高</strong>：由于其决策过程不需要存储所有可能的解决方案，因此空间复杂度通常较低。</li><li><strong>适应性广</strong>：贪心算法可以应用于多种问题领域，如资源分配、路径选择、任务调度等。</li><li><strong>启发式方法</strong>：作为一种启发式算法，贪心算法用于快速找到一个可接受的解决方案，而不是总是寻找最优解。</li></ol> 
<ul><li><strong>缺点</strong></li></ul> 
<ol><li><strong>不保证全局最优</strong>：贪心算法在某些情况下可能无法得到全局最优解，特别是当问题不具有贪心选择性质时。</li><li><strong>依赖于问题结构</strong>：贪心算法的成功依赖于问题是否具有最优子结构，对于不具备这种结构的问题可能不适用。</li><li><strong>可能错过更优解</strong>：由于贪心算法的决策是不可逆的，一旦做出选择就不再回溯，可能会错过更优的解决方案。</li><li><strong>局限性</strong>：对于一些NP难问题，贪心算法可能只能得到局部最优解，而不是绝对最优解。</li><li><strong>需要问题证明</strong>：在使用贪心算法时，需要证明其正确性，这可能需要一些数学推理和证明工作。</li></ol> 
<h3><a id="5__171"></a>5. 贪心算法的实现步骤</h3> 
<ol><li> <p><strong>明确问题</strong>：</p> 
  <ul><li>确定你要解决的问题是什么，比如分配资源、选择任务、规划路径等。</li></ul> </li><li> <p><strong>理解贪心选择</strong>：</p> 
  <ul><li>找出问题中可以应用贪心选择的地方，即在每一步选择中都采取当前看起来最好的决策。</li></ul> </li><li> <p><strong>设定目标</strong>：</p> 
  <ul><li>确定你的“贪心目标”是什么，也就是你希望通过贪心选择达到什么样的效果，比如最小化成本、最大化利润等。</li></ul> </li><li> <p><strong>准备数据</strong>：</p> 
  <ul><li>收集并准备所有需要的数据，比如资源数量、任务列表、路径信息等。</li></ul> </li><li> <p><strong>排序或组织数据</strong>：</p> 
  <ul><li>根据你的目标，可能需要对数据进行排序或以某种方式组织，以便贪心选择可以更容易进行。</li></ul> </li><li> <p><strong>执行贪心策略</strong>：</p> 
  <ul><li>从第一步开始，每次都选择当前看起来最佳的选项。例如，如果你的目标是最小化成本，那么就选择成本最低的选项。</li></ul> </li><li> <p><strong>更新选择状态</strong>：</p> 
  <ul><li>每次做出选择后，更新当前的状态，这可能意味着从可用选项中移除已选择的选项，或者更新剩余资源的数量。</li></ul> </li><li> <p><strong>重复选择过程</strong>：</p> 
  <ul><li>继续执行贪心选择，直到所有的选项都被选择完，或者达到某个特定的条件。</li></ul> </li><li> <p><strong>检查结果</strong>：</p> 
  <ul><li>完成所有步骤后，检查你的结果是否满足问题的要求。</li></ul> </li><li> <p><strong>评估和调整</strong>：</p> 
  <ul><li>如果结果不是预期的，可能需要回到前面的步骤，调整你的贪心策略或选择标准。</li></ul> </li></ol> 
<p>举个例子，如果要用贪心算法来安排一天的工作，步骤可能是这样的：</p> 
<ul><li>确定你要完成的所有工作任务。</li><li>决定你的贪心目标，比如完成最多的任务或完成最重要的任务。</li><li>列出每个任务需要的时间和重要性。</li><li>根据任务的紧急程度或重要性对任务进行排序。</li><li>从列表的顶部开始，逐个选择任务，并安排到你的日程中。</li><li>每次选择后，更新你的日程表，直到所有任务都被安排或时间被填满。</li><li>最后，检查你的日程表，确保所有任务都已妥善安排。</li></ul> 
<h3><a id="6__214"></a>6. 贪心算法与其他算法的比较</h3> 
<table><thead><tr><th>特征/算法类型</th><th>贪心算法</th><th>分治算法</th><th>动态规划</th><th>回溯算法</th><th>其他算法（如分支限界法）</th></tr></thead><tbody><tr><td><strong>基本思想</strong></td><td>每一步都采取当前最优解</td><td>将原问题分解为子问题</td><td>解决子问题后合并结果</td><td>通过试错尝试所有可能</td><td>系统性搜索解空间，使用界限剪枝</td></tr><tr><td><strong>适用问题</strong></td><td>具有贪心选择性质和最优子结构的问题</td><td>具有最优子结构且子问题相互独立</td><td>具有重叠子问题且最优子结构</td><td>需要遍历所有可能解的问题</td><td>求解目标明确的最优化问题</td></tr><tr><td><strong>子问题结构</strong></td><td>只有一个子问题</td><td>子问题相互独立</td><td>子问题重叠，可能有多个解</td><td>所有可能的子问题组合</td><td>逐步细化问题的解空间</td></tr><tr><td><strong>求解策略</strong></td><td>先选择后解决问题</td><td>分解问题后递归求解</td><td>自底向上，先求解子问题</td><td>逐步构造解，剪枝无效选项</td><td>逐步搜索并剪枝非最优解</td></tr><tr><td><strong>时间效率</strong></td><td>高效，通常时间复杂度较低</td><td>高效，但可能需要重复计算</td><td>可能较高，但利用记忆化减少重复计算</td><td>可能较低，尤其是解空间大时</td><td>高效性取决于剪枝策略</td></tr><tr><td><strong>空间效率</strong></td><td>通常较低，不需要存储所有子问题</td><td>较低，递归调用可能增加空间消耗</td><td>可能较高，需要存储子问题解</td><td>较高，需要回溯所有路径</td><td>空间效率取决于界限剪枝的效果</td></tr><tr><td><strong>优点</strong></td><td>简洁高效，实现简单</td><td>适用于独立子问题，易于并行处理</td><td>能解决具有重叠子问题的复杂问题</td><td>能找到所有解，适用于组合问题</td><td>系统性搜索，避免无效搜索</td></tr><tr><td><strong>缺点</strong></td><td>可能无法得到全局最优解</td><td>对子问题的独立性要求较高</td><td>空间消耗大，状态空间可能很大</td><td>对于大规模问题效率较低</td><td>可能需要较多的计算资源进行剪枝</td></tr><tr><td><strong>典型应用</strong></td><td>货币找零、霍夫曼编码</td><td>快速排序、归并排序</td><td>背包问题、最短路径问题</td><td>数独游戏、八皇后问题</td><td>旅行商问题、车辆路径问题</td></tr></tbody></table> 
<h3><a id="7__229"></a>7. 贪心算法的示例演示</h3> 
<h4><a id="1_231"></a>示例1：分糖果问题</h4> 
<p><strong>简介</strong>：有一组孩子的胃口值 <code>g</code> 和一组糖果的大小 <code>s</code>，我们要尽量多的满足孩子。每个孩子只能拿到一个糖果，且只有当糖果的大小大于或等于孩子的胃口值时，孩子才能满足。</p> 
<p><strong>思维过程</strong>：</p> 
<ol><li><strong>目标</strong>：最大化能满足的孩子数量。</li><li><strong>贪心选择</strong>：每次优先满足胃口最小的孩子，因为大胃口的孩子可以用大糖果来满足，但小胃口的孩子需要较小的糖果。</li><li>步骤分析： 
  <ul><li>首先对孩子的胃口和糖果的大小进行排序，以便从最小的胃口和最小的糖果开始比较。</li><li>然后，逐一遍历糖果，尝试将糖果分给胃口最小的孩子。</li><li>如果糖果能够满足当前孩子，就给这个孩子糖果，并继续考虑下一个孩子。</li><li>最后，统计并返回能够满足的孩子数量。</li></ul> </li></ol> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">findContentChildren</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 对孩子的胃口和糖果大小进行排序</span>
    g<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>
    s<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment"># 用于统计能够满足的孩子数量</span>
    child_i <span class="token operator">=</span> <span class="token number">0</span>

    <span class="token comment"># 遍历每个糖果的大小</span>
    <span class="token keyword">for</span> size <span class="token keyword">in</span> s<span class="token punctuation">:</span>
        <span class="token comment"># 如果当前孩子的胃口能被满足</span>
        <span class="token keyword">if</span> child_i <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span> <span class="token keyword">and</span> size <span class="token operator">&gt;=</span> g<span class="token punctuation">[</span>child_i<span class="token punctuation">]</span><span class="token punctuation">:</span>
            child_i <span class="token operator">+=</span> <span class="token number">1</span>  <span class="token comment"># 孩子得到了糖果</span>

    <span class="token comment"># 返回能够满足的孩子数量</span>
    <span class="token keyword">return</span> child_i


<span class="token comment"># 测试</span>
g <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">666</span><span class="token punctuation">]</span>  <span class="token comment"># 孩子的胃口值</span>
s <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment"># 糖果的大小</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>findContentChildren<span class="token punctuation">(</span>g<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 输出: 2</span>
</code></pre> 
<blockquote> 
 <p>胃口 g = [1, 2, 5, 4, 3, 666] 排序 -&gt; [1, 2, 3, 4, 5, 666]</p> 
 <p>糖果 s = [1, 2, 1, 1] 排序 -&gt; [1, 1, 1, 2]</p> 
 <p>糖果s[1]-&gt;g[1] +1</p> 
 <p>糖果s[1 ,1] -&gt; g[2] +1</p> 
 <p>剩下糖果不满足于孩子的胃口值，通过贪心算法，我们总是优先满足胃口最小的孩子，这样能使得最多的孩子得到糖果</p> 
</blockquote> 
<h4><a id="2_282"></a>示例2：零钱兑换问题</h4> 
<p><strong>简介</strong>：给定一些硬币面值 <code>coins</code> 和一个目标金额 <code>amount</code>，找到能够凑成该金额的最少硬币数。</p> 
<p><strong>思维过程</strong>：</p> 
<ol><li><strong>目标</strong>：最小化使用的硬币数量。</li><li><strong>贪心选择</strong>：每次选择面值最大的硬币，这样可以尽快减少剩余的金额，减少所需的硬币数量。</li><li>步骤分析： 
  <ul><li>将硬币按面值从大到小排序，以便优先使用大面值的硬币。</li><li>依次从最大的硬币开始，计算该硬币可以使用多少次，减少目标金额。</li><li>剩余金额用更小面值的硬币继续凑。</li><li>最后，如果能完全凑成目标金额，就返回硬币数量；否则返回 -1。</li></ul> </li></ol> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">coinChange</span><span class="token punctuation">(</span>coins<span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 将硬币面值从大到小排序</span>
    coins<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>reverse<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    count <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># 统计使用的硬币数量</span>

    <span class="token comment"># 遍历每种面值的硬币</span>
    <span class="token keyword">for</span> coin <span class="token keyword">in</span> coins<span class="token punctuation">:</span>
        <span class="token keyword">if</span> amount <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>  <span class="token comment"># 如果金额已经为0，停止</span>
            <span class="token keyword">break</span>
        count <span class="token operator">+=</span> amount <span class="token operator">//</span> coin  <span class="token comment"># 使用最大面值硬币的最大数量</span>
        amount <span class="token operator">%=</span> coin  <span class="token comment"># 更新剩余金额</span>

    <span class="token comment"># 如果金额能够被完全兑换，返回硬币数量，否则返回-1</span>
    <span class="token keyword">return</span> count <span class="token keyword">if</span> amount <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span>


<span class="token comment"># 测试</span>
coins <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>  <span class="token comment"># 硬币面值</span>
amount <span class="token operator">=</span> <span class="token number">11</span>  <span class="token comment"># 目标金额</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>coinChange<span class="token punctuation">(</span>coins<span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 输出: 3</span>
</code></pre> 
<blockquote> 
 <p>通过每次选择最大的硬币，我们可以尽快减少目标金额，达到使用最少硬币的目的。</p> 
 <p>11-&gt;(5,5,1)</p> 
</blockquote> 
<h4><a id="3_325"></a>示例3：区间调度问题</h4> 
<p><strong>简介</strong>：给定一组时间区间 <code>intervals</code>，找出最多的互不重叠的区间数。例如，多个会议时间重叠的情况下，最多能够安排多少场不冲突的会议。</p> 
<p><strong>思维过程</strong>：</p> 
<ol><li><strong>目标</strong>：最大化选择的区间数量。</li><li><strong>贪心选择</strong>：每次选择结束时间最早且与前一个区间不重叠的区间，这样可以给后续的区间留出更多的时间。</li><li>步骤分析： 
  <ul><li>首先按区间的结束时间进行排序，以便优先考虑结束时间早的区间。</li><li>从第一个区间开始，选择它作为第一个非重叠区间，并记录它的结束时间。</li><li>依次考虑后续的区间，如果它的开始时间不早于前一个区间的结束时间，就选择这个区间，并更新结束时间。</li><li>最后，返回选择的区间数量。</li></ul> </li></ol> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">intervalSchedule</span><span class="token punctuation">(</span>intervals<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 根据区间的结束时间进行排序</span>
    intervals<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    count <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># 统计能够安排的区间数量</span>
    end <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span>  <span class="token comment"># 记录上一个选择的区间的结束时间</span>

    <span class="token comment"># 遍历所有区间</span>
    <span class="token keyword">for</span> interval <span class="token keyword">in</span> intervals<span class="token punctuation">:</span>
        <span class="token keyword">if</span> interval<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&gt;=</span> end<span class="token punctuation">:</span>  <span class="token comment"># 如果当前区间的开始时间大于等于上一个区间的结束时间</span>
            count <span class="token operator">+=</span> <span class="token number">1</span>  <span class="token comment"># 选择当前区间</span>
            end <span class="token operator">=</span> interval<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment"># 更新结束时间</span>

    <span class="token comment"># 返回能够安排的最大区间数量</span>
    <span class="token keyword">return</span> count


<span class="token comment"># 测试</span>
intervals <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># 时间区间</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>intervalSchedule<span class="token punctuation">(</span>intervals<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 输出: 2</span>
</code></pre> 
<blockquote> 
 <p>通过每次选择结束时间最早的区间，能够留下更多的时间给后面的区间，从而选择尽可能多的</p> 
 <p>[1, 3], [2, 4]区间重叠, [3, 5] -&gt; [1, 3], [3, 5] -&gt; 2</p> 
</blockquote> 
<h4><a id="4_367"></a>示例4：分配会议室问题</h4> 
<p><strong>简介</strong>：给定一组会议的开始和结束时间<code>intervals</code>，找出需要的最少会议室数量，以确保所有会议都能安排上。</p> 
<p><strong>思维过程</strong>：</p> 
<ol><li><strong>目标</strong>：最小化同时进行的会议数（即需要的会议室数）。</li><li><strong>贪心选择</strong>：每次安排一个会议时，检查最早结束的会议是否已经结束，如果结束了就可以复用该会议室，否则需要新开一个会议室。</li><li>步骤分析： 
  <ul><li>先将所有会议按开始时间排序。</li><li>使用一个最小堆来跟踪当前所有正在进行的会议的结束时间。</li><li>对于每个会议，如果它的开始时间不早于最早结束的会议的结束时间，则表示可以复用一个会议室，更新堆中的结束时间。</li><li>否则，需要新开一个会议室，将会议的结束时间加入堆中。</li><li>最后，堆的大小就是需要的最少会议室数量。</li></ul> </li></ol> 
<pre><code class="prism language-python"><span class="token keyword">import</span> heapq


<span class="token keyword">def</span> <span class="token function">minMeetingRooms</span><span class="token punctuation">(</span>intervals<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> intervals<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token number">0</span>

    <span class="token comment"># 根据会议的开始时间进行排序</span>
    intervals<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

    <span class="token comment"># 初始化一个最小堆，用于存储当前进行的会议的结束时间</span>
    heap <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>heap<span class="token punctuation">,</span> intervals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># 将第一个会议的结束时间加入堆中</span>

    <span class="token comment"># 遍历剩余的会议</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> intervals<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token comment"># 如果当前会议的开始时间大于等于堆顶的结束时间</span>
        <span class="token keyword">if</span> i<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&gt;=</span> heap<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
            heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>heap<span class="token punctuation">)</span>  <span class="token comment"># 移除堆顶的会议，因为它已经结束了</span>
        heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>heap<span class="token punctuation">,</span> i<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># 将当前会议的结束时间加入堆中</span>

    <span class="token comment"># 最后堆的大小就是需要的会议室数量</span>
    <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>heap<span class="token punctuation">)</span>


<span class="token comment"># 测试</span>
intervals <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">35</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># 会议时间区间</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>minMeetingRooms<span class="token punctuation">(</span>intervals<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 输出: 3</span>
</code></pre> 
<blockquote> 
 <p>使用最小堆动态管理会议的结束时间，通过贪心选择，及时释放已结束的会议室，确保所需的会议室数量最少。</p> 
</blockquote> 
<h4><a id="5_417"></a>示例5：最大子数组和问题</h4> 
<p><strong>简介</strong>：在一个整数数组 <code>nums</code> 中，找到和最大的连续子数组，并返回其最大和。</p> 
<p><strong>思维过程</strong>：</p> 
<ol><li><strong>目标</strong>：找到和最大的连续子数组。</li><li><strong>贪心选择</strong>：每次都判断是将当前元素加入到之前的子数组中，还是重新开始一个新的子数组，从而保证当前的子数组和尽可能大。</li><li>步骤分析： 
  <ul><li>初始化当前子数组和 <code>current_sum</code> 和最大子数组和 <code>max_sum</code> 为第一个元素。</li><li>从第二个元素开始，逐个判断： 
    <ul><li>当前元素是否比 <code>current_sum + 当前元素</code> 更大。如果是，则抛弃之前的子数组，重新开始；否则将当前元素加入到当前子数组中。</li></ul> </li><li>每次更新最大子数组和 <code>max_sum</code>。</li><li>最终返回最大子数组和。</li></ul> </li></ol> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>
    max_sum <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token comment"># 初始化最大和为数组的第一个元素</span>
    current_sum <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token comment"># 当前子数组的和</span>

    <span class="token comment"># 遍历数组的其余元素</span>
    <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token comment"># 如果当前子数组的和加上当前元素还不如当前元素本身大，就丢弃当前子数组，重新开始</span>
        current_sum <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> current_sum <span class="token operator">+</span> num<span class="token punctuation">)</span>
        <span class="token comment"># 更新最大和</span>
        max_sum <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>max_sum<span class="token punctuation">,</span> current_sum<span class="token punctuation">)</span>

    <span class="token comment"># 返回最大子数组和</span>
    <span class="token keyword">return</span> max_sum


<span class="token comment"># 测试</span>
nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>  <span class="token comment"># 输入数组</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>maxSubArray<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 输出: 6</span>
</code></pre> 
<blockquote> 
 <p>通过贪心策略，决定是否将当前元素加入到之前的子数组中，从而保证当前的子数组和尽可能大，最终找到全局最大子数组和。</p> 
</blockquote> 
<h3><a id="8__457"></a>8. 贪心算法的回顾总结</h3> 
<p>贪心算法是一种在每一步选择中都采取当前最优解的策略，以期望构建出全局最优解的算法。它的核心思想是“贪心选择性质”，即在每个决策点上，基于当前信息选择最有利的选项，从而希望通过这些局部最优决策累积成全局最优解。贪心算法的实现通常简单直接，易于编码，且执行效率高，这使得它在需要快速响应的大规模问题中非常有用。</p> 
<p>贪心算法的关键在于其贪心策略的选择，这通常涉及到对问题结构的深入理解。在某些问题中，贪心算法能够保证找到最优解，特别是当问题具有最优子结构和贪心选择性质时。然而，并非所有问题都适合使用贪心算法，有些情况下贪心算法可能只能得到局部最优解而非全局最优解。</p> 
<p>贪心算法的一个显著特点是其决策过程是单向的，不会回溯。这意味着一旦做出选择，算法不会重新考虑之前的决策，即使这些决策最终可能不是最佳选择。这种特性使得贪心算法在时间效率上具有优势，但同时也限制了它在某些需要全局考虑的问题上的适用性。</p> 
<p>贪心算法广泛应用于资源分配、路径规划、任务调度、数据压缩等领域。例如，在霍夫曼编码中用于数据压缩，在Dijkstra算法中用于寻找单源最短路径。尽管贪心算法在某些情况下可能需要结合其他算法来优化其策略，但其作为一种高效且直观的算法，仍然在算法设计和优化问题解决中占有重要地位。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e5849b6ba2f0af9da3d571c93459fdcc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MTF-SFR总结/探讨</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d969a0ac93796f5de7023a1c227941de/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">IOS 03 纯代码封装自定义View控件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>