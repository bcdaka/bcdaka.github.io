<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>模板进阶【C&#43;&#43;】 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/9b834a30f71275c5c4a39c999417c2c5/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="模板进阶【C&#43;&#43;】">
  <meta property="og:description" content="文章目录 模板的特殊化函数模板特化的作用 函数模板的的特殊化语法：函数模板特化的要求 类模板的特殊化类模板的特殊化的要求类模板的特殊化的语法全特化偏特化实例化部分模板参数对基本类模板（母板）的模板参数进行限制 非类型模板参数非类型模板参数的特点（注意点） 模板的特殊化 模板的特化是对已经存在的模板进行的特殊处理
通常情况下，使用模板可以实现一些与类型无关的代码，但对于一些特殊类型的可能会得到一些我们不想要的结果需要特殊处理
例如
写一个比较函数，如果是直接写成下图的函数模板，我们就只能按照规定好的大小比较方式进行比较
上图的比较虽然按照语法来说是正确的
但是如果我们想写一个当传入的参数的类型是int*的时候，比较的方式是指针解引用之后再比较的话，如果只有上图中的模板就做不到了
这个时候就可以对特殊化出一个模板，专门处理我们的特殊要求
可以看到，这样就完成了我们的对int*类型特殊处理的要求
函数模板特化的作用 作用很简单：
传入的具体类型如果拥有对应的特化模板函数，就会优先调用那个特化的模板函数
例如上面举例的比较大小的模板函数Greater，如果传给Greater的参数类型是int*，那就会优先调用int*特化的模板函数
因为函数模板特化的作用基本只有这个，所以其实函数模板的特化是有替代的，那就是普通的函数没错就是普通的函数，模板初阶【模板初阶【C&#43;&#43;】】中就说过，如果既有函数模板又有普通函数时，在传递参数都不会类型转换的情况下，编译器就会优先调用普通函数
例
所以其实函数模板的特化其实挺鸡肋的，因为直接写成普通函数还更好
因为它的语法限制比普通函数多在函数模板特化和普通函数共存时，甚至还会优先调用普通函数 但是类模板的特化就有用得多了
函数模板的的特殊化 语法： template&lt;&gt; 返回值 函数名&lt;具体类型，具体类型，……&gt;（参数表） { 函数体 } 例
具体类型就是要特殊处理的类型【特化类型】
函数模板特化的要求 因为模板的特化是对已经存在的模板进行的特殊处理
所以必须要先有一个基础的函数模板（母板），才能对这个模板进行特殊化关键字template后面的尖括号&lt;&gt;里面一定得是空的，这是语法规定，不是空的就报错
特化的模板函数的参数表: 必须要和基础的函数模板（母板）的参数完全相同
人话：写出来的特化的模板函数的参数表，与把特化类型传给基础的函数模板（母板）后实例化出来的模板函数的参数表一样
不然可能会出现很多奇怪的错误，此时要是实在解决不了，就直接实现成全局函数就行了
类模板的特殊化 类模板的特殊化的要求 因为：模板的特化是对已经存在的模板进行的特殊处理
和函数模板一样，必须要先有一个基础的类模板（母板），才能对这个类模板进行特殊化
类模板的特殊化的语法 template&lt;空 或者 模板参数，模板参数，……&gt; class 类名&lt;具体类型/加上限制的模板参数&gt; { 类体 } 全特化 全特化就是把基本类模板（母板）的模板参数全部实例化
例
全特化了之后，当传给类模板的参数和全特化的模板实例化的参数完全相同的时候，就会调用全特化的类模板实例化对象
如下图：
偏特化 偏特化分两种：
实例化部分模板参数 这样偏特化了之后，传给类模板的参数和偏特化的类模板部分实例化的参数完全相同的时候，就会调用偏特化的类模板进行实例化对象
例
如下图，当传给A类的模板参数，第一个是int时将会调研偏特化的类模板实例化对象
第一个模板参数不是int的时候，才会调用基本类模板（母板）进行实例化对象
对基本类模板（母板）的模板参数进行限制 不实例化基本类模板（母板）的模板参数，而是对它加上限制【加const，*{指针限制}，&amp;（引用限制）等】
这样偏特化了之后，传给类模板的参数和偏特化的限制的参数完全相同的时候，就会调用偏特化的类模板进行实例化对象
例">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-02T22:04:38+08:00">
    <meta property="article:modified_time" content="2024-08-02T22:04:38+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">模板进阶【C&#43;&#43;】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_3" rel="nofollow">模板的特殊化</a></li><li><ul><li><ul><li><a href="#_26" rel="nofollow">函数模板特化的作用</a></li></ul> 
   </li><li><a href="#_48" rel="nofollow">函数模板的的特殊化</a></li><li><ul><li><a href="#_50" rel="nofollow">语法：</a></li><li><a href="#_68" rel="nofollow">函数模板特化的要求</a></li></ul> 
   </li><li><a href="#_82" rel="nofollow">类模板的特殊化</a></li><li><ul><li><a href="#_84" rel="nofollow">类模板的特殊化的要求</a></li><li><a href="#_93" rel="nofollow">类模板的特殊化的语法</a></li><li><a href="#_106" rel="nofollow">全特化</a></li><li><a href="#_118" rel="nofollow">偏特化</a></li><li><ul><li><a href="#_120" rel="nofollow">实例化部分模板参数</a></li><li><a href="#_131" rel="nofollow">对基本类模板（母板）的模板参数进行限制</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#_147" rel="nofollow">非类型模板参数</a></li><li><ul><li><a href="#_160" rel="nofollow">非类型模板参数的特点（注意点）</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_3"></a>模板的特殊化</h2> 
<p><mark>模板的特化是对<code>已经存在的模板</code>进行的特殊处理</mark></p> 
<p>通常情况下，<mark>使用模板可以实现一些与类型无关的代码，但对于一些特殊类型的可能会得到一些我们不想要的结果</mark>需要特殊处理</p> 
<p>例如<br> 写一个比较函数，如果是直接写成下图的函数模板，我们就只能按照规定好的大小比较方式进行比较<br> <img src="https://images2.imgbox.com/82/f9/tpddguRm_o.png" alt="在这里插入图片描述"></p> 
<p>上图的比较虽然按照语法来说是正确的</p> 
<p>但是如果我们想写一个当传入的参数的类型是<code>int*</code>的时候，<mark>比较的方式是指针解引用之后再比较的话，如果只有上图中的模板就做不到了</mark></p> 
<p>这个时候就可以对特殊化出一个模板，专门处理我们的特殊要求<br> <img src="https://images2.imgbox.com/45/d6/zJtbtzzS_o.png" alt="在这里插入图片描述"><br> <mark>可以看到，这样就完成了我们的对int*类型特殊处理的要求</mark></p> 
<hr> 
<h4><a id="_26"></a>函数模板特化的作用</h4> 
<p>作用很简单：<br> <mark>传入的具体类型如果拥有对应的特化模板函数，就会<code>优先调用</code>那个特化的模板函数</mark></p> 
<p>例如上面举例的比较大小的模板函数<code>Greater</code>，如果传给<code>Greater</code>的参数类型是int*，那就会优先调用int*特化的模板函数</p> 
<p>因为函数模板特化的作用基本只有这个，所以其实函数模板的特化是有替代的，那就是<mark>普通的函数</mark>没错就是普通的函数，模板初阶【<a href="http://t.csdnimg.cn/vmk10" rel="nofollow">模板初阶【C++】</a>】中就说过，如果既有函数模板又有普通函数时，在<mark>传递参数都不会类型转换的情况下，编译器就会优先调用普通函数</mark></p> 
<p>例<br> <img src="https://images2.imgbox.com/e9/1d/VgMnSgkU_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e1/34/rjvSlcNe_o.png" alt="在这里插入图片描述"></p> 
<p>所以其实<mark>函数模板的特化其实挺鸡肋的</mark>，因为直接<mark>写成普通函数还<code>更好</code></mark></p> 
<ol><li>因为它的语法限制比普通函数多</li><li>在函数模板特化和普通函数共存时，甚至还会优先调用普通函数</li></ol> 
<p>但是类模板的特化就有用得多了</p> 
<hr> 
<h3><a id="_48"></a>函数模板的的特殊化</h3> 
<h4><a id="_50"></a>语法：</h4> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span>
返回值 函数名<span class="token operator">&lt;</span>具体类型，具体类型，……<span class="token operator">&gt;</span>（参数表）
<span class="token punctuation">{<!-- --></span>
    函数体
<span class="token punctuation">}</span>
</code></pre> 
<p>例<br> <img src="https://images2.imgbox.com/14/24/pHtkvAOy_o.png" alt="在这里插入图片描述"><br> <mark>具体类型就是要特殊处理的类型【特化类型】</mark></p> 
<hr> 
<h4><a id="_68"></a>函数模板特化的要求</h4> 
<ol><li>因为<mark>模板的特化是对<code>已经存在的模板</code>进行的特殊处理</mark><br> 所以必须要先有一个基础的函数模板（<code>母板</code>），才能对这个模板进行特殊化</li><li>关键字template后面的尖括号&lt;&gt;里面一定得是空的，这是<code>语法规定</code>，不是空的就报错<br> <img src="https://images2.imgbox.com/d7/fb/grUHI4qr_o.png" alt="在这里插入图片描述"></li><li>特化的模板函数的参数表: <mark><code>必须</code>要和基础的函数模板（母板）的参数<code>完全相同</code></mark><br> 人话：写出来的特化的模板函数的参数表，与把特化类型传给基础的函数模板（母板）后实例化出来的模板函数的参数表一样<br> 不然可能会出现很多奇怪的错误，此时要是实在解决不了，就直接实现成全局函数就行了<br> <img src="https://images2.imgbox.com/45/97/bo8irKK8_o.png" alt="在这里插入图片描述"></li></ol> 
<hr> 
<h3><a id="_82"></a>类模板的特殊化</h3> 
<h4><a id="_84"></a>类模板的特殊化的要求</h4> 
<p>因为：<mark>模板的特化是对<code>已经存在的模板</code>进行的特殊处理</mark></p> 
<p>和函数模板一样，必须要先有一个基础的类模板（<code>母板</code>），才能对这个类模板进行特殊化</p> 
<hr> 
<h4><a id="_93"></a>类模板的特殊化的语法</h4> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span>空 或者 模板参数，模板参数，……<span class="token operator">&gt;</span>
<span class="token keyword">class</span> 类名<span class="token operator">&lt;</span>具体类型<span class="token operator">/</span>加上限制的模板参数<span class="token operator">&gt;</span>
<span class="token punctuation">{<!-- --></span>
    类体
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h4><a id="_106"></a>全特化</h4> 
<p>全特化就是把基本类模板（母板）的模板参数<code>全部实例化</code><br> 例<br> <img src="https://images2.imgbox.com/43/75/lIvfHRQG_o.png" alt="在这里插入图片描述"><br> 全特化了之后，<mark>当传给类模板的参数和全特化的模板实例化的参数<code>完全相同</code>的时候，就会调用全特化的类模板实例化对象</mark></p> 
<p>如下图：<br> <img src="https://images2.imgbox.com/0d/3c/s1OXgUrD_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h4><a id="_118"></a>偏特化</h4> 
<p>偏特化分两种：</p> 
<h5><a id="_120"></a>实例化部分模板参数</h5> 
<p>这样偏特化了之后，<mark>传给类模板的参数和<code>偏特化</code>的类模板<code>部分实例化</code>的参数<code>完全相同</code>的时候，就会调用偏特化的类模板进行实例化对象</mark></p> 
<p>例<br> 如下图，当传给A类的模板参数，第一个是int时将会调研偏特化的类模板实例化对象<br> 第一个模板参数不是int的时候，才会调用基本类模板（母板）进行实例化对象<br> <img src="https://images2.imgbox.com/cd/b9/XSRRFJcV_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h5><a id="_131"></a>对基本类模板（母板）的模板参数进行限制</h5> 
<p>不实例化基本类模板（母板）的模板参数，而是对它加上限制【加<code>const</code>，<code>*{指针限制}</code>，<code>&amp;（引用限制）</code>等】</p> 
<p>这样偏特化了之后，<mark>传给类模板的参数和<code>偏特化</code>的<code>限制的</code>参数<code>完全相同</code>的时候，就会调用偏特化的类模板进行实例化对象</mark></p> 
<p>例</p> 
<p>如下图，偏特化加上的限制是<code>*{指针限制}</code>，所以如果传给类模板的模板参数<code>都是指针类型</code>的就会调用偏特化的类模板进行对象的实例化<br> 实例化c对象的时候传给类模板的模板参数都是指针类型，所以调用了偏特化的类模板<br> 实例化b对象的时候传给类模板的模板参数<code>只有第一个是指针类型</code>，并没有与<code>偏特化</code>的<code>限制的</code>参数<code>完全相同</code>，所以调用的还是基本类模板（母板）<br> <img src="https://images2.imgbox.com/25/8b/ZpXRIxKM_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h2><a id="_147"></a>非类型模板参数</h2> 
<p>非类型参数：<br> <mark>就是用一个<code>常量</code>作为类模板或者函数模板的一个参数，在模板中可将该参数当成常量来使用</mark></p> 
<p>例如：<br> 自己封装一个静态数组，此时就可以用非类型模板参数作为<code>静态数组的容量</code>大小<br> <img src="https://images2.imgbox.com/0e/66/LMSv4HFp_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h3><a id="_160"></a>非类型模板参数的特点（注意点）</h3> 
<ol><li> <p>C++20<code>以前</code>非类型模板参数的类型<code>只能是整型或者char类型</code></p> </li><li> <p>C++20<code>以后</code>非类型模板参数的类型<code>支持所有内置类型</code>，但<code>不能</code>是自定义类型</p> </li><li> <p>非类型模板参数<code>可以给</code>缺省值</p> </li><li> <p>因为非类型模板参数是常量，所以<mark>它接收的参数也必须是<code>常量</code>或者是<code>const修饰的变量</code></mark><br> 例<br> <img src="https://images2.imgbox.com/9e/f3/PBvz8v13_o.png" alt="在这里插入图片描述"><br> 传变量就会报错<br> <img src="https://images2.imgbox.com/ab/5f/YKSqBqkb_o.png" alt="在这里插入图片描述"></p> </li></ol> 
<hr>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2aca8c2f2ebc6f1f8f5b263c58ff633c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43;11深度剖析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/70ff578656b7af1618fb737006a918d5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">IDEA常用设置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>