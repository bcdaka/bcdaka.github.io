<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>前端常用算法（一）：防抖&#43;节流 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/2ac2dbda0474a735f2fec9abbe8670ad/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="前端常用算法（一）：防抖&#43;节流">
  <meta property="og:description" content="目录
第一章 防抖
1.1 防抖（debounce）简介
1.2 应用场景
1.3 实现思路
1.4 手撕防抖代码
第二章 节流
2.1 节流（throttle）简介
2.2 应用场景
2.3 实现思路
2.4 手撕节流代码（方法：时间戳和计时器）
2.5 时间戳与计时器实现的区别
第三章 总结
第一章 防抖 1.1 防抖（debounce）简介 场景：用户在一段时间频繁点击执行某个函数/事件，那么在这段时间，用户点击一次，计时器重新计时，当在这段时间内用户没有触发该函数/事件时，该函数/事件会在这段时间结束时执行，只执行最后一次。应用示例理解：回城被打断，玩家残血准备回城，需要3s回城成功，但是在这个3s的过程中，玩家又重新点击了回城，导致3s回城重新计算，再等3s。 1.2 应用场景 登录、发短信、发送post请求等按钮/事件避免用户点击太快，以致于发送了多次请求，需要防抖，最后一次发送请求即可；调整浏览器窗口大小时，resize 次数过于频繁，造成计算过多，此时需要一次到位，就用到了防抖；input输入框获取到value值不需要输入一个字符就获取一次，可以使用防抖，让其输入结束之后再获取其值文本编辑器实时保存，当无任何更改操作一秒后进行保存。…… 1.3 实现思路 1.4 手撕防抖代码 function debounce(func,delay) { // 定义一个定时器timer let timer = null return function() { const that = this const args = arguments // 防抖核心：每次触发事件计时器都会重新计时 clearTimeout(timer) timer = setTimeout(()=&gt;{ func.apply(that,args) },delay) } } 例子： 未调用防抖函数时：用户每在input输入/删除一个值，都会输出一个值；">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-11-28T23:24:16+08:00">
    <meta property="article:modified_time" content="2023-11-28T23:24:16+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">前端常用算法（一）：防抖&#43;节流</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E9%98%B2%E6%8A%96-toc" style="margin-left:0px;"><a href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E9%98%B2%E6%8A%96" rel="nofollow">第一章 防抖</a></p> 
<p id="1.1%20%E9%98%B2%E6%8A%96%EF%BC%88debounce%EF%BC%89%E7%AE%80%E4%BB%8B-toc" style="margin-left:40px;"><a href="#1.1%20%E9%98%B2%E6%8A%96%EF%BC%88debounce%EF%BC%89%E7%AE%80%E4%BB%8B" rel="nofollow">1.1 防抖（debounce）简介</a></p> 
<p id="1.2%20%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#1.2%20%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">1.2 应用场景</a></p> 
<p id="1.3%20%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF-toc" style="margin-left:40px;"><a href="#1.3%20%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF" rel="nofollow">1.3 实现思路</a></p> 
<p id="1.4%20%E6%89%8B%E6%92%95%E9%98%B2%E6%8A%96%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#1.4%20%E6%89%8B%E6%92%95%E9%98%B2%E6%8A%96%E4%BB%A3%E7%A0%81" rel="nofollow">1.4 手撕防抖代码</a></p> 
<p id="%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E8%8A%82%E6%B5%81-toc" style="margin-left:0px;"><a href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E8%8A%82%E6%B5%81" rel="nofollow">第二章 节流</a></p> 
<p id="2.1%20%E8%8A%82%E6%B5%81%EF%BC%88throttle%EF%BC%89%E7%AE%80%E4%BB%8B-toc" style="margin-left:40px;"><a href="#2.1%20%E8%8A%82%E6%B5%81%EF%BC%88throttle%EF%BC%89%E7%AE%80%E4%BB%8B" rel="nofollow">2.1 节流（throttle）简介</a></p> 
<p id="2.2%C2%A0%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#2.2%C2%A0%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">2.2 应用场景</a></p> 
<p id="2.3%C2%A0%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF-toc" style="margin-left:40px;"><a href="#2.3%C2%A0%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF" rel="nofollow">2.3 实现思路</a></p> 
<p id="2.4%20%E6%89%8B%E6%92%95%E8%8A%82%E6%B5%81%E4%BB%A3%E7%A0%81%EF%BC%88%E6%96%B9%E6%B3%95%EF%BC%9A%E6%97%B6%E9%97%B4%E6%88%B3%E5%92%8C%E8%AE%A1%E6%97%B6%E5%99%A8%EF%BC%89-toc" style="margin-left:40px;"><a href="#2.4%20%E6%89%8B%E6%92%95%E8%8A%82%E6%B5%81%E4%BB%A3%E7%A0%81%EF%BC%88%E6%96%B9%E6%B3%95%EF%BC%9A%E6%97%B6%E9%97%B4%E6%88%B3%E5%92%8C%E8%AE%A1%E6%97%B6%E5%99%A8%EF%BC%89" rel="nofollow">2.4 手撕节流代码（方法：时间戳和计时器）</a></p> 
<p id="2.5%20%E6%97%B6%E9%97%B4%E6%88%B3%E4%B8%8E%E8%AE%A1%E6%97%B6%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#2.5%20%E6%97%B6%E9%97%B4%E6%88%B3%E4%B8%8E%E8%AE%A1%E6%97%B6%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">2.5 时间戳与计时器实现的区别</a></p> 
<p id="%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%80%BB%E7%BB%93" rel="nofollow">第三章 总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E9%98%B2%E6%8A%96">第一章 防抖</h2> 
<h3 id="1.1%20%E9%98%B2%E6%8A%96%EF%BC%88debounce%EF%BC%89%E7%AE%80%E4%BB%8B">1.1 防抖（debounce）简介</h3> 
<ul><li><strong>场景：</strong>用户在<strong>一段时间频繁点击执行某个函数/事件，</strong>那么<strong>在这段时间，用户点击一次，<span style="color:#fe2c24;">计时器重新计时</span>，</strong>当在<strong>这段时间内用户没有触发该函数/事件时，该函数/事件会在<span style="color:#fe2c24;">这段时间结束时执行，只执行最后一次</span>。</strong></li><li><strong>应用示例理解：<span style="color:#fe2c24;">回城被打断</span>，玩家残血准备回城，需要3s回城成功，但是在这个3s的过程中，玩家又重新点击了回城，导致3s回城重新计算，再等3s。</strong></li></ul> 
<h3 id="1.2%20%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><strong>1.2 应用场景</strong></h3> 
<ul><li><span style="color:#fe2c24;"><strong>登录、发短信、发送post请求等按钮/事件</strong></span>避免用户点击太快，以致于发送了多次请求，需要防抖，最后一次发送请求即可；</li><li><span style="color:#fe2c24;"><strong>调整浏览器窗口大小</strong></span>时，resize 次数过于频繁，造成计算过多，此时需要一次到位，就用到了防抖；</li><li><strong><span style="color:#fe2c24;">input输入框获取到value值</span></strong>不需要输入一个字符就获取一次，可以使用防抖，让其输入结束之后再获取其值</li><li><span style="color:#fe2c24;"><strong>文本编辑器实时保存</strong></span>，当无任何更改操作一秒后进行保存。</li><li>……</li></ul> 
<h3 id="1.3%20%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><strong>1.3 实现思路</strong></h3> 
<p><img alt="" height="497" src="https://images2.imgbox.com/c8/03/qGIUgONY_o.png" width="406"></p> 
<h3 id="1.4%20%E6%89%8B%E6%92%95%E9%98%B2%E6%8A%96%E4%BB%A3%E7%A0%81"><strong>1.4 手撕防抖代码</strong></h3> 
<pre><code class="language-javascript">function debounce(func,delay) {
    // 定义一个定时器timer
    let timer = null
    return function() {
        const that = this
        const args = arguments
        // 防抖核心：每次触发事件计时器都会重新计时
        clearTimeout(timer)
        timer = setTimeout(()=&gt;{
            func.apply(that,args)
        },delay)
    }
}</code></pre> 
<ul><li>例子：</li></ul> 
<p>未调用防抖函数时：<strong>用户每在input输入/删除一个值，都会输出一个值；</strong></p> 
<pre><code class="language-html">    &lt;input type="text" id="input"&gt;

    &lt;script&gt;
        let inputDom = document.getElementById('input')
        //获取输入框的输入内容
        inputDom.oninput = function(){
          console.log('this.value',this.value)
        }
    &lt;/script&gt;</code></pre> 
<p> <img alt="" height="470" src="https://images2.imgbox.com/1d/5e/y85SMwy3_o.png" width="477"></p> 
<p></p> 
<p>调用防抖函数后：<strong>用户在input输入/删除一个值delay之后才，会输出一个值</strong></p> 
<pre><code class="language-javascript">    let inputDom = document.getElementById('input')
    //func 是执行函数，delay 是事件执行的延迟时间，毫秒
    function debounce(func,delay) {
        // 定义一个定时器timer
        let timer = null
        return function() {
            const that = this
            const args = arguments
            // 防抖核心：每次触发事件计时器都会重新计时
            clearTimeout(timer)
            timer = setTimeout(()=&gt;{
               func.apply(that,args)
            },delay)
        }
    }
    function handler() {
        console.log('this.value',this.value)
    }
    inputDom.addEventListener('input', debounce(handler, 1000))</code></pre> 
<p><img alt="" height="374" src="https://images2.imgbox.com/d2/c5/nKEgCx1Q_o.png" width="354"></p> 
<h2 id="%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E8%8A%82%E6%B5%81"><strong>第二章 节流</strong></h2> 
<h3 id="2.1%20%E8%8A%82%E6%B5%81%EF%BC%88throttle%EF%BC%89%E7%AE%80%E4%BB%8B"><strong>2.1 节流（</strong>throttle<strong>）简介</strong></h3> 
<ul><li><strong>场景</strong>：用户在<strong>一段时间频繁点击执行某个函数/事件，</strong>那么<strong>在这段时间，用户点击一次/多次（调用事件），都不会影响计时器执行，<span style="color:#fe2c24;">并且该函数/事件只执行一次。</span></strong></li><li><strong>应用示例理解：<span style="color:#fe2c24;">技能冷却中</span></strong><strong>，玩家在某种情况下使用了闪现这个技能，但是这个技能的冷却时间是120s,在这段时间里，玩家遇到危险，想要再使用闪现这个技能，频繁的点击它，但是并没用，闪现不会执行，计时器依然还在倒计时，等到120s倒计时为0才能再使用一次闪现的技能。</strong></li></ul> 
<h3 id="2.2%C2%A0%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">2.2 <strong>应用场景</strong></h3> 
<ul><li>窗口调整</li><li>页面滚动</li><li>抢购和疯狂点击</li><li>懒加载获取滚动条的位置</li><li>鼠标连续不断地触发某事件（如点击），只在规定时间内触发一次</li><li>……</li></ul> 
<h3 id="2.3%C2%A0%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF">2.3 <strong>实现思路</strong></h3> 
<p><img alt="" height="617" src="https://images2.imgbox.com/ff/1f/FJU0zdoS_o.png" width="797"></p> 
<h3 id="2.4%20%E6%89%8B%E6%92%95%E8%8A%82%E6%B5%81%E4%BB%A3%E7%A0%81%EF%BC%88%E6%96%B9%E6%B3%95%EF%BC%9A%E6%97%B6%E9%97%B4%E6%88%B3%E5%92%8C%E8%AE%A1%E6%97%B6%E5%99%A8%EF%BC%89"><strong>2.4 手撕节流代码（方法：时间戳和计时器）</strong></h3> 
<pre><code class="language-javascript">// ---------------------节流1:使用时间戳---------------------
//func 是事件处理程序，delay 是事件执行的延迟时间，单位：毫秒
function throttle (func, delay) {
    //定义初始时间(开始触发事件的时间)
    let start = 0;
    return function () {
        const that = this
        const args = arguments
        // 获取当前时间戳
        let cur =Date.now()
        // 时间间隔大于延迟时间则进入
        if (cur - start &gt;= delay) {
            //执行事件处理程序
            func.apply(that, args);
            //更新初始时间
            start = cur
        }
    }
}</code></pre> 
<pre><code class="language-javascript">// ---------------------节流2:使用定时器---------------------
//func 是事件处理程序，delay 是事件执行的延迟时间，单位：毫秒
function throttle(func, delay){
    // 自定义一个定时器
    var timer = null;
    return function(){
        var that = this;
        var args = arguments
        // timer为null表示可以发送请求了，否则还在请求中，不执行事件
        if(!timer){
            timer = setTimeout(function(){
                //执行事件处理程序
                func.call(that, args)
                //事件执行完后把定时器清除掉，下次触发事件的时候再设置
                timer = null;
            }, delay)
        }  
    }
}</code></pre> 
<ul><li> 例子：</li></ul> 
<p>未调用节流函数时，每点击一次按钮，都会执行一次函数调用：</p> 
<pre><code class="language-html">&lt;button id="button1"&gt;发送了节流请求&lt;/button&gt;</code></pre> 
<pre><code class="language-javascript">const button1Dom = document.getElementById('button1')
button1Dom.addEventListener('click',function(){
    console.log("节流：我发送了消息")
})</code></pre> 
<p><img alt="" height="366" src="https://images2.imgbox.com/47/fe/trsl8hKR_o.png" width="498"></p> 
<p> 使用节流函数之后，频繁的点击发送请求，它会在计时器结束之后再发，这段时间内点击发送一次请求之后，不会再发送请求：</p> 
<pre><code class="language-javascript">const button1Dom = document.getElementById('button1')
// ---------------------节流1:使用时间戳---------------------
//func 是事件处理程序，delay 是事件执行的延迟时间，单位：毫秒
function throttle (func, delay) {
    //定义初始时间(开始触发事件的时间)
    let start = 0;
    return function () {
        const that = this
        const args = arguments
        // 获取当前时间戳
        let cur =Date.now()
        // 时间间隔大于延迟时间则进入
        if (cur - start &gt;= delay) {
            //执行事件处理程序
            func.apply(that, args);
            //更新初始时间
            start = cur
        }
    }
}
// ---------------------节流2:使用定时器---------------------
//func 是事件处理程序，delay 是事件执行的延迟时间，单位：毫秒
// function throttle(func, delay){
//     // 自定义一个定时器
//     var timer = null;
//     return function(){
//         var that = this;
//         var args = arguments
//         // timer为null表示可以发送请求了，否则还在请求中，不执行事件
//         if(!timer){
//             timer = setTimeout(function(){
//                 //执行事件处理程序
//                 func.call(that, args)
//                 //事件执行完后把定时器清除掉，下次触发事件的时候再设置
//                 timer = null;
//             }, delay)
//         }  
//     }
// }
button1Dom.addEventListener('click',throttle(function(){
    console.log("节流：我发送了消息")
},1000))</code></pre> 
<p>频繁的点击，降低了发送的频率： </p> 
<p> <img alt="" height="358" src="https://images2.imgbox.com/66/97/JvSV2n1W_o.png" width="479"></p> 
<h3 id="2.5%20%E6%97%B6%E9%97%B4%E6%88%B3%E4%B8%8E%E8%AE%A1%E6%97%B6%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8C%BA%E5%88%AB">2.5 时间戳与计时器实现的区别</h3> 
<p>最明显的区别就是在频繁点击的时候，会发现使用<span style="color:#fe2c24;"><strong>时间戳实现</strong></span>的节流会<span style="color:#fe2c24;"><strong>在调用的时候马上执行</strong></span>，而使用<span style="color:#fe2c24;"><strong>计时器实现</strong></span>会在<span style="color:#fe2c24;"><strong>时间段结束时执行</strong></span></p> 
<h2 id="%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%80%BB%E7%BB%93">第三章 总结</h2> 
<ul><li>所谓防抖，就是指触发事件后，在 n 秒后函数才会执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间；节流，就是指连续触发事件，但是在 n 秒中只执行一次函数。</li><li>函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/db14e80e81c46d1a94939a7660d47517/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MPPT工作流程及算法和硬件的选择</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c121630de33feee121e3d79b9a6357f1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">贪心算法(c&#43;&#43;)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>