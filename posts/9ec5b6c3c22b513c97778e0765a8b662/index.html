<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JavaScript 继承百花齐放：从原型链到 ES6 类 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/9ec5b6c3c22b513c97778e0765a8b662/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="JavaScript 继承百花齐放：从原型链到 ES6 类">
  <meta property="og:description" content="前言
📫 大家好，我是南木元元，热爱技术和分享，欢迎大家交流，一起学习进步！
🍅 个人主页：南木元元
在 JavaScript 中，继承是一个重要的知识点，上篇文章中我们已经了解了原型和原型链的概念，本文就来介绍一下js中实现继承的几种方式。
目录
继承
实现继承的方法
1.原型链继承
2.借用构造函数继承
3.组合继承
4.原型式继承
5.寄生式继承
6.寄生组合式继承
7.class继承
结语
继承 继承，简单来讲就是让子类能够访问到父类的属性和方法，继承的主要作用就是实现代码的重用。
在JavaScript中，主要通过原型链来实现继承。我们重温一下构造函数、原型和实例的关系：
每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个指针指向原型。
实现继承的方法 1.原型链继承 原型链继承的基本思想：让子类构造函数的原型指向父类的实例。
function Parent () { this.name = &#39;kevin&#39;; } Parent.prototype.getName = function () { console.log(this.name); } function Child () {} //让子类原型指向父类实例 Child.prototype = new Parent(); var child1 = new Child(); console.log(child1.getName()) // kevin 缺点是引⽤类型的属性被所有实例共享，并且创建子类型实例时，不能向父类型传参。
2.借用构造函数继承 基本思想：在子类构造函数中调用父类构造函数，使用call将父对象的构造函数绑定在子对象上。
function Parent () { this.names = [&#39;kevin&#39;, &#39;daisy&#39;]; } function Child () { // 调用父类构造函数 Parent.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-04T16:18:10+08:00">
    <meta property="article:modified_time" content="2024-08-04T16:18:10+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JavaScript 继承百花齐放：从原型链到 ES6 类</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong> 前言</strong></p> 
<blockquote> 
 <p> 📫 大家好，我是南木元元，热爱技术和分享，欢迎大家交流，一起学习进步！</p> 
 <p> 🍅 <strong>个人主页：<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><a href="https://blog.csdn.net/weixin_43288600" title="南木元元">南木元元</a></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p> 
</blockquote> 
<p>在 JavaScript 中，继承是一个重要的知识点，<a class="link-info" href="http://t.csdnimg.cn/Gpolz" rel="nofollow" title="上篇文章中">上篇文章中</a>我们已经了解了原型和原型链的概念，本文就来介绍一下js中实现继承的几种方式。</p> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E7%BB%A7%E6%89%BF-toc" style="margin-left:0px;"><a href="#%E7%BB%A7%E6%89%BF" rel="nofollow">继承</a></p> 
<p id="%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95-toc" style="margin-left:0px;"><a href="#%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95" rel="nofollow">实现继承的方法</a></p> 
<p id="1.%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF-toc" style="margin-left:40px;"><a href="#1.%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF" rel="nofollow">1.原型链继承</a></p> 
<p id="2.%E5%80%9F%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF-toc" style="margin-left:40px;"><a href="#2.%E5%80%9F%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF" rel="nofollow">2.借用构造函数继承</a></p> 
<p id="3.%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF-toc" style="margin-left:40px;"><a href="#3.%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF" rel="nofollow">3.组合继承</a></p> 
<p id="4.%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF-toc" style="margin-left:40px;"><a href="#4.%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF" rel="nofollow">4.原型式继承</a></p> 
<p id="5.%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%A7%E6%89%BF-toc" style="margin-left:40px;"><a href="#5.%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%A7%E6%89%BF" rel="nofollow">5.寄生式继承</a></p> 
<p id="6.%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF-toc" style="margin-left:40px;"><a href="#6.%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF" rel="nofollow">6.寄生组合式继承</a></p> 
<p id="7.class%E7%BB%A7%E6%89%BF-toc" style="margin-left:40px;"><a href="#7.class%E7%BB%A7%E6%89%BF" rel="nofollow">7.class继承</a></p> 
<p id="%E7%BB%93%E8%AF%AD-toc" style="margin-left:0px;"><a href="#%E7%BB%93%E8%AF%AD" rel="nofollow">结语</a></p> 
<hr id="hr-toc"> 
<h2>继承</h2> 
<p>继承，简单来讲就是让子类能够访问到父类的属性和方法，继承的主要作用就是实现代码的重用。</p> 
<p>在JavaScript中，主要通过<strong>原型链</strong>来实现继承。我们重温一下构造函数、原型和实例的关系：</p> 
<p class="img-center"><img alt="" height="493" src="https://images2.imgbox.com/f5/5d/9ozZWvln_o.png" width="604"></p> 
<p>每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个指针指向原型。</p> 
<h2 id="%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95">实现继承的方法</h2> 
<h3 id="1.%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF">1.原型链继承</h3> 
<p>原型链继承的基本思想：让子类构造函数的原型指向父类的实例。</p> 
<pre><code class="language-javascript">function Parent () {
   this.name = 'kevin';
}
Parent.prototype.getName = function () {
   console.log(this.name);
}
function Child () {}

//让子类原型指向父类实例
Child.prototype = new Parent();
var child1 = new Child();
console.log(child1.getName()) // kevin</code></pre> 
<p>缺点是引⽤类型的属性被所有实例共享，并且创建子类型实例时，不能向父类型传参。</p> 
<h3 id="2.%E5%80%9F%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF">2.借用构造函数继承</h3> 
<p>基本思想：在子类构造函数中调用父类构造函数，使用call将父对象的构造函数绑定在子对象上。</p> 
<pre><code class="language-javascript">function Parent () {
  this.names = ['kevin', 'daisy'];
}
function Child () {
  // 调用父类构造函数
  Parent.call(this);
}

var child1 = new Child();
child1.names.push('yayu');
console.log(child1.names); // ["kevin", "daisy", "yayu"]
var child2 = new Child();
console.log(child2.names); // ["kevin", "daisy"]</code></pre> 
<p>解决了原型链继承不能传参问题和父类原型共享问题，但是无法实现函数方法的复用，方法都在构造函数中定义，每次创建实例都会创建一遍方法，方法本质上都变成了实例自己的方法，不是公共的方法。</p> 
<h3 id="3.%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF">3.组合继承</h3> 
<p>基本思想：将原型链和借用构造函数组合起来使用。使用原型链实现对原型方法的继承，通过借用构造函数的方式来实现属性的继承。</p> 
<pre><code class="language-javascript">function Parent (name) {
  this.name = name;
  this.colors = ['red', 'blue', 'green'];
}
Parent.prototype.getName = function () {
  console.log(this.name)
}
function Child (name, age) {
  Parent.call(this, name);
  this.age = age;
}

Child.prototype = new Parent();
Child.prototype.constructor = Child;
var child1 = new Child('kevin', '18');
child1.colors.push('black');
console.log(child1.name); // kevin
console.log(child1.age); // 18
console.log(child1.colors); // ["red", "blue", "green", "black"]
var child2 = new Child('daisy', '20');
console.log(child2.name); // daisy
console.log(child2.age); // 20
console.log(child2.colors); // ["red", "blue", "green"]</code></pre> 
<p>这种方式的优点：既实现了函数复用，又保证每个实例都有自己的属性。</p> 
<p>缺点：调用了两次父类的构造函数，造成了子类的原型中多了很多不必要的属性。</p> 
<h3 id="4.%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF">4.原型式继承</h3> 
<p>基本思想：基于已有的对象来创建新的对象。</p> 
<pre><code class="language-javascript">// 利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型
function createObj(o) {
   function F() {}
   F.prototype = o;
   return new F();
}
var person = {
  name: 'kevin',
  friends: ['daisy', 'kelly']
}
var person1 = createObj(person);
var person2 = createObj(person);
person1.name = 'person1';
console.log(person2.name); // kevin
person1.friends.push('taylor');
console.log(person2.friends); // ["daisy", "kelly", "taylor"]</code></pre> 
<p>缺点是引⽤类型的属性被所有实例共享。</p> 
<p>ES5中存在<strong><code>Object.create()</code></strong>的方法，能够代替上面的createObj方法。</p> 
<h3 id="5.%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%A7%E6%89%BF">5.寄生式继承</h3> 
<p>寄生式继承与原型式继承很接近，它的思想就是在原型式继承的基础上以某种方式增强对象，然后返回这个对象。</p> 
<pre><code class="language-javascript">function createObj (o) {
   let clone = Object.create(o);
   clone.sayName = function () {
       console.log("hi");
  }
   return clone;
}</code></pre> 
<h3 id="6.%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF">6.寄生组合式继承</h3> 
<p>组合继承的缺点就是调用了2次父构造方法。寄生组合式继承就是改造组合式继承，使用父类的原型的副本来作为子类的原型，这样就只调用一次父构造函数，避免了创建不必要的属性。</p> 
<pre><code class="language-javascript">function Parent (name) {
  this.name = name;
  this.colors = ['red', 'blue', 'green'];
}
Parent.prototype.getName = function () {
  console.log(this.name)
}
function Child (name, age) {
  Parent.call(this, name);
  this.age = age;
}
Child.prototype = Object.create(Parent.prototype);
Child.prototype.constructor = Child;//把子类的构造指向子类本身
var child1 = new Child('kevin', '18');
console.log(child1.colors);//[ 'red', 'blue', 'green' ]
console.log(child1.getName());//kevin</code></pre> 
<h3 id="7.class%E7%BB%A7%E6%89%BF">7.class继承</h3> 
<p>在 ES6 中，可以使用 class 去实现继承。使用 extends 表明继承自哪个父类，并且在子类构造函数中必须调用 super 。</p> 
<pre><code class="language-javascript">class Parent {
 constructor(name) {
   this.name = name;
}
 getName() {
   console.log(this.name);
}
}
class Child extends Parent {
 constructor(name, age) {
   super(name);
   //使用this之前必须先调用super()
   this.age = age;
}
}
// 测试
let child = new Child("kevin", 18);
console.log(child.name); // kevin
console.log(child.age); // 18
child.getName(); // kevin</code></pre> 
<p>注意：在 JS 中并不存在类， class 只是语法糖，本质还是函数。</p> 
<pre><code class="language-javascript">class Person {}
Person instanceof Function // true</code></pre> 
<p>class实现的继承本质上是<strong>寄生组合式继承</strong>。下面是使用babel将ES6代码编译成ES5后的代码：</p> 
<pre><code class="language-javascript">function _possibleConstructorReturn(self, call) {
    // ...
    return call &amp;&amp; (typeof call === 'object' || typeof call === 'function') ? call : self;
}

function _inherits(subClass, superClass) {
    // ...
    //看到没有
    subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, {
        constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}


var Parent = function Parent() {
    // 验证是否是 Parent 构造出来的 this
    _classCallCheck(this, Parent);
};

var Child = (function (_Parent) {
    _inherits(Child, _Parent);

    function Child() {
        _classCallCheck(this, Child);

        return _possibleConstructorReturn(this, (Child.__proto__ || Object.getPrototypeOf(Child)).apply(this, arguments));
    }

    return Child;
}(Parent));
</code></pre> 
<p>核心是_inherits函数，可以看到它采用的依然也是寄生组合继承方式。不过这里加了一个Object.setPrototypeOf(subClass, superClass)，这是用来干啥的呢？</p> 
<p>答案是用来继承父类的静态方法。这也是原来的继承方式疏忽掉的地方。</p> 
<ul><li>ES5 继承和 ES6 继承的区别</li></ul> 
<p>ES5 的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上 Parent.call(this) </p> 
<p>ES6 的继承不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。</p> 
<h2 id="%E7%BB%93%E8%AF%AD">结语</h2> 
<p>🔥如果此文对你有帮助的话，欢迎💗<span style="color:#fe2c24;"><strong>关注</strong></span>、👍<span style="color:#ff9900;"><strong>点赞</strong></span>、⭐<span style="color:#4da8ee;"><strong>收藏</strong></span>、✍️<span style="color:#9c8ec1;"><strong>评论</strong></span>，支持一下博主~ </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0dbbc16016793110dec9a99730dfbe5d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[数据集][目标检测]肾结石检测数据集VOC&#43;YOLO格式1299张1类别</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0d6b9c59c33b9fe64873a6ab506730ed/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【微服务】springboot 整合 SA-Token 使用详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>