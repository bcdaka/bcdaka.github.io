<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深入浅出：实现前端菜单权限控制的策略详解（结尾附vue3完整示例代码） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/47db29d3c6cd3e70c01b5e1ceb47efba/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="深入浅出：实现前端菜单权限控制的策略详解（结尾附vue3完整示例代码）">
  <meta property="og:description" content="引言
在构建企业级Web应用时，菜单权限控制很关键。前端层面实现菜单权限控制，确保系统安全性的同时提升用户体验。
@[一、权限模型和数据结构]
##一、权限模型和数据结构 1. 权限模型：常见的权限模型有基于角色的权限控制（RBAC，Role-Based Access Control），即用户通过角色与权限关联，角色再与具体的菜单项绑定。菜单结构一般采用树形结构，方便递归渲染与权限过滤。
2. 数据对接：前端通过与后端API交互，获取当前登录用户的角色及其所拥有的菜单权限数据。这部分数据通常包括菜单ID、名称、URL、父节点ID以及是否可见、是否可访问等权限标识。
3. 数据处理：拿到权限数据后，前端需要将其转换为易于操作的数据结构，例如数组或对象。可以按照菜单层级构建嵌套数组，便于递归生成菜单。
二、前端权限控制实现策略 1. 渲染前过滤
在渲染菜单组件前，根据用户权限数据对原始菜单数据进行筛选，去除无权限访问的菜单项。这是一种主动过滤的方式，可以减少无用DOM元素的生成，降低内存占用。
function filterMenusByPermission(menus, permissions) { return menus.filter(menu =&gt; permissions.includes(menu.id) &amp;&amp; menu.visible); } 2. 渲染时控制
在菜单组件的渲染函数内部，针对每个菜单项判断其权限属性，决定是否渲染。这种方式下，即使用户没有权限的菜单项也会被创建成DOM元素，但在最终呈现时会被隐藏。
function MenuItem({ menu }) { if (!menu.accessible) return null; // 权限不足，不渲染此菜单项 return &lt;div&gt;{menu.name}&lt;/div&gt;; } function MenuList({ menus }) { return ( &lt;ul&gt; {menus.map(menu =&gt; ( &lt;MenuItem key={menu.id} menu={menu} /&gt; ))} &lt;/ul&gt; ); } 3. 动态路由控制
在使用了路由系统的项目中，还可以结合路由配置实现权限控制。为每个路由配置对应的权限标识，然后在路由守卫（如Vue中的beforeEach钩子函数）中进行拦截和跳转处理。
router.beforeEach((to, from, next) =&gt; { const hasPermission = checkUserPermission(to.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-25T11:36:53+08:00">
    <meta property="article:modified_time" content="2024-03-25T11:36:53+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深入浅出：实现前端菜单权限控制的策略详解（结尾附vue3完整示例代码）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>引言</p> 
<p>在构建企业级Web应用时，菜单权限控制很关键。前端层面实现菜单权限控制，确保系统安全性的同时提升用户体验。</p> 
<p>@[一、权限模型和数据结构]</p> 
<h4>##一、权限模型和数据结构</h4> 
<p>1. 权限模型：常见的权限模型有基于角色的权限控制（RBAC，Role-Based Access Control），即用户通过角色与权限关联，角色再与具体的菜单项绑定。菜单结构一般采用树形结构，方便递归渲染与权限过滤。</p> 
<p>2. 数据对接：前端通过与后端API交互，获取当前登录用户的角色及其所拥有的菜单权限数据。这部分数据通常包括菜单ID、名称、URL、父节点ID以及是否可见、是否可访问等权限标识。</p> 
<p>3. 数据处理：拿到权限数据后，前端需要将其转换为易于操作的数据结构，例如数组或对象。可以按照菜单层级构建嵌套数组，便于递归生成菜单。</p> 
<h4>二、前端权限控制实现策略</h4> 
<p>1. 渲染前过滤</p> 
<p>在渲染菜单组件前，根据用户权限数据对原始菜单数据进行筛选，去除无权限访问的菜单项。这是一种主动过滤的方式，可以减少无用DOM元素的生成，降低内存占用。</p> 
<pre><code class="language-javascript">function filterMenusByPermission(menus, permissions) {
  return menus.filter(menu =&gt; permissions.includes(menu.id) &amp;&amp; menu.visible);
}</code></pre> 
<p>2. 渲染时控制</p> 
<p>在菜单组件的渲染函数内部，针对每个菜单项判断其权限属性，决定是否渲染。这种方式下，即使用户没有权限的菜单项也会被创建成DOM元素，但在最终呈现时会被隐藏。</p> 
<pre><code class="language-javascript">function MenuItem({ menu }) {
  if (!menu.accessible) return null; // 权限不足，不渲染此菜单项
  
  return &lt;div&gt;{menu.name}&lt;/div&gt;;
}

function MenuList({ menus }) {
  return (
    &lt;ul&gt;
      {menus.map(menu =&gt; (
        &lt;MenuItem key={menu.id} menu={menu} /&gt;
      ))}
    &lt;/ul&gt;
  );
}</code></pre> 
<p>3. 动态路由控制</p> 
<p>在使用了路由系统的项目中，还可以结合路由配置实现权限控制。为每个路由配置对应的权限标识，然后在路由守卫（如Vue中的beforeEach钩子函数）中进行拦截和跳转处理。</p> 
<pre><code class="language-javascript">router.beforeEach((to, from, next) =&gt; {
  const hasPermission = checkUserPermission(to.meta.permission); // 自定义校验函数
  
  if (hasPermission) {
    next();
  } else {
    next({ name: 'Unauthorized' }); // 无权限时重定向至未经授权页面
  }
});</code></pre> 
<h4>三、实时权限变更应对</h4> 
<p>考虑到权限可能在用户使用过程中动态变更，前端还需要监听权限变更事件，及时刷新菜单数据和路由控制。例如，可以通过WebSocket、EventBus或定期轮询等方式接收来自后端的权限更新通知。</p> 
<h4>四：示例-使用Vue3语法实现前端菜单权限控制</h4> 
<pre><code class="language-javascript">&lt;template&gt;
  &lt;ul class="menu-list"&gt;
    &lt;li v-for="menu in filteredMenus" :key="menu.id"&gt;
      &lt;router-link :to="menu.path"&gt;{<!-- -->{ menu.name }}&lt;/router-link&gt;
      &lt;ul v-if="menu.children"&gt;
        &lt;li v-for="child in menu.children" :key="child.id"&gt;
          &lt;router-link :to="child.path"&gt;{<!-- -->{ child.name }}&lt;/router-link&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref, computed, useRouter } from 'vue';
import { useStore } from '@/stores/index'; // 存在一个Vuex Store

// 从Vuex Store中获取用户权限和菜单数据
const store = useStore();
const userPermissions = ref&lt;string[]&gt;(store.getters.getUserPermissions);
const menuData = ref&lt;any[]&gt;(store.getters.getMenuData);

// 计算过滤后的菜单
const filteredMenus = computed(() =&gt; {
  return menuData.value.filter(menu =&gt; 
    userPermissions.value.some(permission =&gt; menu.permission.includes(permission)) &amp;&amp;
    menu.visible
  ).map(menu =&gt; ({
    ...menu,
    children: filterChildren(menu.children),
  }));
});

const filterChildren = (children: any[] = []) =&gt; {
  return children.filter(child =&gt;
    userPermissions.value.some(permission =&gt; child.permission.includes(permission)) &amp;&amp;
    child.visible
  );
};

// 动态路由控制
const router = useRouter();
router.beforeEach(async (to, from, next) =&gt; {
  const hasPermission = to.meta.permission?.some(permission =&gt;
    userPermissions.value.includes(permission)
  );

  if (hasPermission || !to.meta.permission?.length) {
    next();
  } else {
    next({ name: 'Unauthorized' });
  }
});
&lt;/script&gt;</code></pre> 
<p>首先，可以从Vuex Store中获取用户权限和菜单数据，并通过ref和computed来管理这些数据。接着，计算出用户有权限访问的菜单项，并在模板中进行渲染。</p> 
<p>同时，也可以利用Vue Router的beforeEach全局守卫实现了动态路由权限控制。在实际项目中，请确保userPermissions和menuData是从正确的地方获取的，可能是Vuex Store，也可能是API接口。</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cfa8d765c6662b6ac901bee7182adaa0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【MySQL】事务？隔离级别？锁？详解MySQL并发控制机制</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1868979ea1de92748b7352a824461a3f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【python】python小说数据抓取&#43;可视化（源码&#43;数据）【独一无二】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>