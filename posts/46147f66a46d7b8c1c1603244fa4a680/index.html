<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c＋＋初阶知识——string类详解 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/46147f66a46d7b8c1c1603244fa4a680/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="c＋＋初阶知识——string类详解">
  <meta property="og:description" content="目录
前言：
1.标准库中的string类
1.1 auto和范围for
auto
范围for
1.2 string类常用接口说明
1.string类对象的常见构造
1.3 string类对象的访问及遍历操作
1.4. string类对象的修改操作 1.5 string类非成员函数
2.string类的模拟实现 2.1 经典的string类问题 2.2 浅拷贝 2.3 深拷贝 2.4 string类实现 3.写时拷贝 前言： C语言中，字符串是以&#39;\0&#39;结尾的一些字符的集合，为了操作方便，C标准库中提供了一些str系列
的库函数，但是这些库函数与字符串是分离开的，不太符合OOP的思想，而且底层空间需要用户
自己管理，稍不留神可能还会越界访问。
1.标准库中的string类 在使用string类时，必须包含#include头文件以及using namespace std;
1.1 auto和范围for auto （1）在早期C/C&#43;&#43;中auto的含义是：使用auto修饰的变量，是具有自动存储器的局部变量，后来这个不重要了。C&#43;&#43;11中，标准委员会变废为宝赋予了auto全新的含义即：auto不再是一个存储类型指示符，而是作为一个新的类型指示符来指示编译器，auto声明的变量必须由编译器在编译时期
推导而得。
（2）用auto声明指针类型时，用auto和auto*没有任何区别，但用auto声明引用类型时则必须加&amp;
（3）当在同一行声明多个变量时，这些变量必须是相同的类型，否则编译器将会报错，因为编译器实际只对第一个类型进行推导，然后用推导出来的类型定义其他变量。
（4）auto不能作为函数的参数，可以做返回值，但是建议谨慎使用
（5）auto不能直接用来声明数组
#include &lt;map&gt; using namespace std; int main() { std::map&lt;std::string, std::string&gt; dict = { { &#34;apple&#34;, &#34;苹果&#34; },{ &#34;orange&#34;, &#34;橙子&#34; }, {&#34;pear&#34;,&#34;梨&#34;} }; // auto的用武之地 //std::map&lt;std::string, std::string&gt;::iterator it = dict.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-25T12:00:15+08:00">
    <meta property="article:modified_time" content="2024-07-25T12:00:15+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c＋＋初阶知识——string类详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h6 id="%C2%A0"> </h6> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%C2%A0-toc" style="margin-left:200px;"><a href="#%C2%A0" rel="nofollow"> </a></p> 
<p id="%E5%89%8D%E8%A8%80%EF%BC%9A-toc" style="margin-left:200px;"><a href="#%E5%89%8D%E8%A8%80%EF%BC%9A" rel="nofollow">前言：</a></p> 
<p id="1.%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84string%E7%B1%BB-toc" style="margin-left:0px;"><a href="#1.%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84string%E7%B1%BB" rel="nofollow">1.标准库中的string类</a></p> 
<p id="1.1%C2%A0auto%E5%92%8C%E8%8C%83%E5%9B%B4for-toc" style="margin-left:40px;"><a href="#1.1%C2%A0auto%E5%92%8C%E8%8C%83%E5%9B%B4for" rel="nofollow">1.1 auto和范围for</a></p> 
<p id="auto-toc" style="margin-left:80px;"><a href="#auto" rel="nofollow">auto</a></p> 
<p id="%C2%A0%E8%8C%83%E5%9B%B4for-toc" style="margin-left:80px;"><a href="#%C2%A0%E8%8C%83%E5%9B%B4for" rel="nofollow"> 范围for</a></p> 
<p id="1.2%20string%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E-toc" style="margin-left:40px;"><a href="#1.2%20string%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E" rel="nofollow">1.2 string类常用接口说明</a></p> 
<p id="1.string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E8%A7%81%E6%9E%84%E9%80%A0-toc" style="margin-left:40px;"><a href="#1.string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E8%A7%81%E6%9E%84%E9%80%A0" rel="nofollow">1.string类对象的常见构造</a></p> 
<p id="1.3%20string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%8F%8A%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#1.3%20string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%8F%8A%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C" rel="nofollow">1.3 string类对象的访问及遍历操作</a></p> 
<p id="1.4.%20string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C%C2%A0-toc" style="margin-left:40px;"><a href="#1.4.%20string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C%C2%A0" rel="nofollow">1.4. string类对象的修改操作 </a></p> 
<p id="%C2%A01.5%20string%E7%B1%BB%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%C2%A01.5%20string%E7%B1%BB%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0" rel="nofollow"> 1.5 string类非成员函数</a></p> 
<p id="2.string%E7%B1%BB%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%C2%A0-toc" style="margin-left:0px;"><a href="#2.string%E7%B1%BB%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%C2%A0" rel="nofollow">2.string类的模拟实现 </a></p> 
<p id="2.1%20%E7%BB%8F%E5%85%B8%E7%9A%84string%E7%B1%BB%E9%97%AE%E9%A2%98%C2%A0-toc" style="margin-left:40px;"><a href="#2.1%20%E7%BB%8F%E5%85%B8%E7%9A%84string%E7%B1%BB%E9%97%AE%E9%A2%98%C2%A0" rel="nofollow">2.1 经典的string类问题 </a></p> 
<p id="-toc" style="margin-left:40px;"></p> 
<p id="2.2%20%E6%B5%85%E6%8B%B7%E8%B4%9D%C2%A0-toc" style="margin-left:40px;"><a href="#2.2%20%E6%B5%85%E6%8B%B7%E8%B4%9D%C2%A0" rel="nofollow">2.2 浅拷贝 </a></p> 
<p id="2.3%20%E6%B7%B1%E6%8B%B7%E8%B4%9D%C2%A0-toc" style="margin-left:40px;"><a href="#2.3%20%E6%B7%B1%E6%8B%B7%E8%B4%9D%C2%A0" rel="nofollow">2.3 深拷贝 </a></p> 
<p id="2.4%20string%E7%B1%BB%E5%AE%9E%E7%8E%B0%C2%A0-toc" style="margin-left:40px;"><a href="#2.4%20string%E7%B1%BB%E5%AE%9E%E7%8E%B0%C2%A0" rel="nofollow">2.4 string类实现 </a></p> 
<p id="3.%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D%C2%A0-toc" style="margin-left:0px;"><a href="#3.%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D%C2%A0" rel="nofollow">3.写时拷贝 </a></p> 
<hr id="hr-toc"> 
<p></p> 
<h6 id="%E5%89%8D%E8%A8%80%EF%BC%9A">前言：</h6> 
<p>C语言中，字符串是以'\0'结尾的一些字符的集合，为了操作方便，C标准库中提供了一些str系列<br> 的库函数，但是这些库函数与字符串是分离开的，不太符合OOP的思想，而且底层空间需要用户<br> 自己管理，稍不留神可能还会越界访问。</p> 
<h2 id="1.%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84string%E7%B1%BB">1.标准库中的string类</h2> 
<blockquote> 
 <p><strong>在使用string类时，必须包含#include头文件以及using namespace std;</strong></p> 
</blockquote> 
<h3 id="1.1%C2%A0auto%E5%92%8C%E8%8C%83%E5%9B%B4for">1.1 auto和范围for</h3> 
<h4 id="auto">auto</h4> 
<p>（1）在早期C/C++中auto的含义是：<strong>使用auto修饰的变量，是具有自动存储器的局部变量</strong>，<strong>后来这个不重要了</strong>。C++11中，标准委员会变废为宝赋予了auto全新的含义即：<strong>auto不再是一个存储类型指示符，而是作为一个新的类型指示符来指示编译器</strong>，auto声明的变量<strong>必须由编译器在编译时期<br> 推导而得</strong>。</p> 
<p>（2）<strong>用auto声明指针类型时，用auto和auto*没有任何区别，但用auto声明引用类型时则必须加&amp;</strong></p> 
<p>（3）<strong>当在同一行声明多个变量时，这些变量必须是相同的类型，否则编译器将会报错，因为编译器实际只对第一个类型进行推导，然后用推导出来的类型定义其他变量</strong>。</p> 
<p>（4）<strong>auto不能作为函数的参数，可以做返回值，但是建议谨慎使用</strong></p> 
<p><strong>（5）auto不能直接用来声明数组</strong></p> 
<pre><code class="hljs">#include &lt;map&gt;
using namespace std;
int main()
{
std::map&lt;std::string, std::string&gt; dict = { { "apple", "苹果" },{ "orange",
"橙子" }, {"pear","梨"} };
// auto的用武之地
//std::map&lt;std::string, std::string&gt;::iterator it = dict.begin();
auto it = dict.begin();
while (it != dict.end())
{
cout &lt;&lt; it-&gt;first &lt;&lt; ":" &lt;&lt; it-&gt;second &lt;&lt; endl;
++it;
}
范围for
对于一个有范围的集合而言，由程序员来说明循环的范围是多余的，有时候还会容易犯错误。因此
C++11中引入了基于范围的for循环。for循环后的括号由冒号“ ：”分为两部分：第一部分是范围
内用于迭代的变量，第二部分则表示被迭代的范围，自动迭代，自动取数据，自动判断结束。
范围for可以作用到数组和容器对象上进行遍历
范围for的底层很简单，容器遍历实际就是替换为迭代器，这个从汇编层也可以看到。
2.3 string类的常用接口说明（注意下面我只讲解最常用的接口）
1. string类对象的常见构造
return 0;
}</code></pre> 
<h4 id="%C2%A0%E8%8C%83%E5%9B%B4for"> 范围for</h4> 
<p>(1)对于一个<strong>有范围的集合</strong>而言，由程序员来说明循环的范围是多余的，有时候还会容易犯错误。因此C++11中引入了基于范围的for循环。<strong>for循环后的括号由冒号“ ：”分为两部分：第一部分是范围内用于迭代的变量，第二部分则表示被迭代的范围</strong>，自动迭代，自动取数据，自动判断结束。</p> 
<p>(2)范围for可以作用到数组和容器对象上进行遍历</p> 
<p>(3)范围for的底层很简单，容器遍历实际就是替换为迭代器，这个从汇编层也可以看到。</p> 
<p>示例：</p> 
<pre><code class="hljs">#include&lt;iostream&gt;
#include &lt;string&gt;
#include &lt;map&gt;
using namespace std;
int main()
{
   int array[] = { 1, 2, 3, 4, 5 };
   // C++98的遍历
   for (int i = 0; i &lt; sizeof(array) / sizeof(array[0]); ++i)
  {
       array[i] *= 2;
  }
   for (int i = 0; i &lt; sizeof(array) / sizeof(array[0]); ++i)
  {
       cout &lt;&lt; array[i] &lt;&lt; endl;
  }
   // C++11的遍历
   for (auto&amp; e : array)
       e *= 2;
   for (auto e : array)
       cout &lt;&lt; e &lt;&lt; " " &lt;&lt; endl;
   string str("hello world");
   for (auto ch : str)
  {
       cout &lt;&lt; ch &lt;&lt; " ";
  }
   cout &lt;&lt; endl;
return 0;
}</code></pre> 
<h3 id="1.2%20string%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E">1.2 string类常用接口说明</h3> 
<h3 id="1.string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E8%A7%81%E6%9E%84%E9%80%A0">1.string类对象的常见构造</h3> 
<p><img alt="" height="559" src="https://images2.imgbox.com/a5/6f/EXorYtQg_o.png" width="962"></p> 
<p>注意：<br> 1. size()与length()方法底层实现原理完全相同，引入size()的原因是为了与其他容器的接<br> 口保持一致，一般情况下基本都是用size()。</p> 
<p><br> 2. clear()只是将string中有效字符清空，不改变底层空间大小。</p> 
<p><br> 3. resize(size_t n) 与 resize(size_t n, char c)都是将字符串中有效字符个数改变到n个，不<br> 同的是当字符个数增多时：resize(n)用0来填充多出的元素空间，resize(size_t n, char<br> c)用字符c来填充多出的元素空间。注意：resize在改变元素个数时，如果是将元素个数<br> 增多，可能会改变底层容量的大小，如果是将元素个数减少，底层空间总大小不变。</p> 
<p><br> 4. reserve(size_t res_arg=0)：为string预留空间，不改变有效元素个数，当reserve的参<br> 数小于string的底层空间总大小时，reserver不会改变容量大小。 </p> 
<h3 id="1.3%20string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%8F%8A%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C">1.3 string类对象的访问及遍历操作</h3> 
<p><img alt="" height="464" src="https://images2.imgbox.com/bf/8c/4KyF6WQN_o.png" width="923"></p> 
<h3 id="1.4.%20string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C%C2%A0">1.4. string类对象的修改操作 </h3> 
<p><img alt="" height="518" src="https://images2.imgbox.com/fb/46/RGekZSQE_o.png" width="924"></p> 
<p><strong>注意</strong>：<br> 1. 在string尾部追加字符时，s.push_back(c) / s.append(1, c) / s += 'c'三种的实现方式差<br> 不多，一般情况下string类的+=操作用的比较多，+=操作不仅可以连接单个字符，还可<br> 以连接字符串。</p> 
<p><br> 2. 对string操作时，如果能够大概预估到放多少字符，可以先通过reserve把空间预留<br> 好。 </p> 
<h3 id="%C2%A01.5%20string%E7%B1%BB%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"> <strong>1.5 string类非成员函数</strong></h3> 
<p><img alt="" height="407" src="https://images2.imgbox.com/04/f8/bIyy8a3D_o.png" width="924"></p> 
<h2 id="2.string%E7%B1%BB%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%C2%A0">2.string类的模拟实现 </h2> 
<h3 id="2.1%20%E7%BB%8F%E5%85%B8%E7%9A%84string%E7%B1%BB%E9%97%AE%E9%A2%98%C2%A0">2.1 经典的string类问题 </h3> 
<blockquote> 
 <p><strong>上面已经对string类进行了简单的介绍，大家只要能够正常使用即可。在面试中，面试官总喜欢让<br> 学生自己来模拟实现string类，最主要是实现string类的构造、拷贝构造、赋值运算符重载以及析<br> 构函数。大家看下以下string类的实现是否有问题？</strong></p> 
 <h3></h3> 
</blockquote> 
<pre><code class="hljs">// 为了和标准库区分，此处使用String
class String
{
public:
/*String()
:_str(new char[1])
{*_str = '\0';}
*/
//String(const char* str = "\0") 错误示范
//String(const char* str = nullptr) 错误示范
String(const char* str = "")
{
// 构造String类对象时，如果传递nullptr指针，可以认为程序非
if (nullptr == str)
{
assert(false);
return;
}
_str = new char[strlen(str) + 1];
strcpy(_str, str);
}
~String()
{
if (_str)
{
delete[] _str;
_str = nullptr;
}
}
private:
char* _str;
};
// 测试
void TestString()
{
String s1("hello bit!!!");
String s2(s1);
}</code></pre> 
<p><img alt="" height="544" src="https://images2.imgbox.com/7d/65/BlyDpHC2_o.png" width="1200"> </p> 
<blockquote> 
 <p><strong>说明：上述String类没有显式定义其拷贝构造函数与赋值运算符重载，此时编译器会合成默认<br> 的，当用s1构造s2时，编译器会调用默认的拷贝构造。最终导致的问题是，s1、s2共用同一块内存空间，在释放时同一块空间被释放多次而引起程序崩溃，这种拷贝方式，称为浅拷贝。 </strong></p> 
</blockquote> 
<h3 id="2.2%20%E6%B5%85%E6%8B%B7%E8%B4%9D%C2%A0">2.2 浅拷贝 </h3> 
<blockquote> 
 <p><strong>浅拷贝：也称位拷贝，编译器只是将对象中的值拷贝过来。如果对象中管理资源，最后就会导致<br> 多个对象共享同一份资源，当一个对象销毁时就会将该资源释放掉，而此时另一些对象不知道该<br> 资源已经被释放，以为还有效，所以当继续对资源进项操作时，就会发生发生了访问违规。</strong></p> 
</blockquote> 
<p>就像一个家庭中有两个孩子，但父母只买了一份玩具，两个孩子愿意一块玩，则万事大吉，万一<br> 不想分享就你争我夺，玩具损坏。</p> 
<p>所以可以采用深拷贝解决浅拷贝问题，即：每个对象都有一份独立的资源，不要和其他对象共享。父母给每个孩子都买一份玩具，各自玩各自的就不会有问题了。 </p> 
<p><img alt="" height="349" src="https://images2.imgbox.com/d0/7d/T2LDgEKO_o.png" width="521"></p> 
<h3 id="2.3%20%E6%B7%B1%E6%8B%B7%E8%B4%9D%C2%A0">2.3 深拷贝 </h3> 
<blockquote> 
 <p> 如果一个类中涉及到资源的管理，其拷贝构造函数、赋值运算符重载以及析构函数必须要显式给<br> 出。一般情况都是按照深拷贝方式提供。</p> 
 <p> </p> 
</blockquote> 
<p><img alt="" height="485" src="https://images2.imgbox.com/28/ac/IfvgUeuZ_o.png" width="802"> </p> 
<h3 id="2.4%20string%E7%B1%BB%E5%AE%9E%E7%8E%B0%C2%A0">2.4 string类实现 </h3> 
<p> 能否写好string反映出我们对类和对象知识的理解是否深刻，这一块知识如果理解得不够深刻，我们的c＋＋程序就会经常出现此类问题。为了方便管理，我们将string的实现分为3个文件是实现：</p> 
<p>string.h :</p> 
<pre><code class="hljs">#pragma once
#include&lt;iostream&gt;
#include&lt;assert.h&gt;
using namespace std;


namespace Myobject
{
	class string
	{
	public:
		typedef char* iterator;
		typedef const char* const_iterator;
		string&amp; operator+=(char ch);
		string&amp; operator+=(const char* str);
		void append(const char* str);
		void insert(size_t  pos, char ch);
		void insert(size_t  pos, const char* str);
		void erase(size_t pos, size_t len = npos);
		size_t find(char ch, size_t pos);
		size_t find(const char* str, size_t pos);
		string substr(size_t pos, size_t len);

		string&amp; operator=(const string&amp; s);

		string(const char* str = "")
		{
			_size = strlen(str);
			_capacity = _size;
			_str = new char[_capacity + 1];
			strcpy(_str, str);
		}

		string(const string&amp; s)
		{
			_str = new char[s._capacity + 1];
			strcpy(_str, s._str);
			_size = s._size;
			_capacity = s._capacity;
		}

		void test0_01();

		void reserve(size_t n);
		void push_back(char ch);

		/*string()
			:_str(new char[1] {'\0'})
			,_size(0)
			,_capacity(0)
		{}*/

		iterator begin()
		{
			return _str;
		}

		iterator end()
		{
			return _str + _size;
		}

		const_iterator begin() const
		{
			return _str;
		}

		const_iterator end() const
		{
			return _str + _size;
		}







		const char* c_str() const
		{
			return _str;
		}

		size_t size()
		{
			return _size;
		}

		size_t capacity()
		{
			return _capacity;
		}

		char&amp; operator[](size_t pos)
		{
			assert(pos &lt; _size);

			return _str[pos];
		}

		const	char&amp; operator[](size_t pos) const
		{
			assert(pos &lt; _size);

			return _str[pos];
		}


		~string()
		{
			delete[] _str;
			_str = nullptr;
			_size = _capacity = 0;


		}


	private:
		char* _str;
		size_t _size;
		size_t _capacity;
		static const size_t npos;
	};

	ostream&amp; operator&lt;&lt;(ostream&amp; out, const string&amp; s);
	istream&amp; operator&gt;&gt;(istream&amp; in, string&amp; s);
}
</code></pre> 
<p>string.cpp :</p> 
<pre><code class="hljs">#define _CRT_SECURE_NO_WARNINGS 1
#include"string.h"

namespace Myobject
{
	const size_t string::npos = -1;

	string string::substr(size_t pos, size_t len)
	{
		assert(pos &lt; _size);
		if (len &gt; _size - pos)
		{
			len = _size - pos;
		}

		string sub;
		sub.reserve(len);
		for (size_t i = 0; i &lt; len; i++)
		{
			sub += _str[pos + i];
		}
		return sub;
	}

	size_t string::find(char ch, size_t pos)
	{
		assert(pos &lt; _size);
		for (size_t i = 0; i &lt; _size; i++)
		{
			if (_str[i] == ch)
			{
				return i;
			}
		}
		return npos;

	}
	size_t string::find(const char* str, size_t pos)
	{
		assert(pos &lt; _size);
		const char* ptr = strstr(_str + pos, str);
		if (ptr == nullptr)
		{
			return npos;
		}
		else
		{
			return ptr - _str;
		}
	}
	void string::erase(size_t pos, size_t len)
	{
		assert(pos &lt; _size);
		if (len &gt;= _size - pos)
		{
			_str[pos] = '0';
			_size = pos;
		}
		else
		{
			for (size_t i = pos + len; i &lt; _size; i++)
			{
				_str[i - len] = _str[i];
			}
			_size -= len;
		}

	}

	void string::insert(size_t pos, char ch)
	{
		assert(pos &lt;= _size);
		if (_size == _capacity)
		{
			reserve(_capacity == 0 ? 4 : _capacity * 2);
		}
		size_t end = _size + 1;
		if (end &gt; pos)
		{
			_str[end] = _str[end - 1];
			end--;
		}
		_str[pos] = ch;
		_size++;
	}//插入单个字符

	void string::insert(size_t  pos, const char* str)
	{
		assert(pos &lt;= _size);
		size_t len = strlen(str);
		if (len + _size &gt; _capacity)
		{
			reserve(len + _size == 2 * _capacity ? len + _size : 2 * _capacity);
		}
		size_t end = _size + len;
		while (end - 2 &gt; pos)
		{
			_str[end] = _str[end - len];
			end--;
		}
		for (int i = 0; i &lt; len; i++)
		{
			_str[pos + i] = str[i];
		}
		_size += len;

	}

	void string::append(const char* str)
	{
		size_t len = strlen(str);
		if (len + _size &gt; _capacity)
		{
			reserve(len + _size == 2 * _capacity ? len + _size : 2 * _capacity);
		}
		strcpy(_str + _size, str);
		_size += len;
		//	_str[_size] = '\0';

	}

	string&amp; string::operator+=(const char* str)
	{
		append(str);
		return *this;
	}

	void string::reserve(size_t n)
	{
		if (n &gt; _capacity)
		{
			char* tmp = new char[n + 1];
			strcpy(tmp, _str);
			delete[] _str;
			_str = tmp;
			_capacity = n;
		}
	}//扩容
	void string::push_back(char ch)
	{
		if (_size == _capacity)
		{
			reserve(_capacity == 0 ? 4 : _capacity * 2);
		}
		_str[_size] = ch;
		_size++;
		_str[_size] = '\0';
	}//尾插

	string&amp; string::operator+=(char ch)
	{
		push_back(ch);
		return *this;
	}

	string&amp; string::operator=(const string&amp; s)
	{
		if (this != &amp;s)
		{
			delete[] _str;
			_str = new char[s._capacity + 1];
			strcpy(_str, s._str);
			_size = s._size;
			_capacity = s._capacity;
			return *this;
		}
	}

	ostream&amp; operator&lt;&lt;(ostream&amp; out, const string&amp; s)
	{
		for (auto ch : s)
		{
			out &lt;&lt; ch;
		}
		return out;
	}
	istream&amp; operator&gt;&gt;(istream&amp; in, string&amp; s)
	{
		char ch;
		ch = in.get();
		while (ch != ' ' &amp;&amp; ch != '\n')
		{
			s += ch;
			ch = in.get();
		}
		return in;
	}
}</code></pre> 
<p>test.cpp :</p> 
<pre><code class="hljs">#define _CRT_SECURE_NO_WARNINGS 1
#include"string.h"

namespace Myobject
{
	void test_01()
	{

		string s1;
		string s2("hello world");

		cout &lt;&lt; s1.c_str() &lt;&lt; endl;
		cout &lt;&lt; s2.c_str() &lt;&lt; endl;

		for (int i = 0; i &lt; s2.size(); i++)
		{
			s2[i] += 2;
		}
		cout &lt;&lt; s2.c_str() &lt;&lt; endl;

		s2 += 'A';
		s2 += 'B';

		string::iterator it = s2.begin();
		while (it != s2.end())
		{
			cout &lt;&lt; *it &lt;&lt; " ";
			it++;
		}
		cout &lt;&lt; endl;

		for (auto ch : s2)
		{
			cout &lt;&lt; ch &lt;&lt; " ";
		}
		cout &lt;&lt; endl;
		s2.insert(0, '$');
		for (auto ch : s2)
		{
			cout &lt;&lt; ch &lt;&lt; " ";
		}
		cout &lt;&lt; endl;
		s2.insert(8, "%%%%%%%");
		for (auto ch : s2)
		{
			cout &lt;&lt; ch &lt;&lt; " ";
		}
		cout &lt;&lt; endl;
		s2.erase(8, 100);
		for (auto ch : s2)
		{
			cout &lt;&lt; ch &lt;&lt; " ";
		}
		cout &lt;&lt; endl;
		/*s2.append("hehe");
		for (auto ch : s2)
		{
			cout &lt;&lt; ch &lt;&lt; " ";
		}
		s2 += "hello";
		for (auto ch : s2)
		{
			cout &lt;&lt; ch &lt;&lt; " ";
		}*/
	}
	void test02()
	{
		string s1("hello world");
		string s2 = s1.substr(6, 5);

		cout &lt;&lt; s2.c_str() &lt;&lt; endl;

		string s3("hello bit");
		s2 = s3;
		cout &lt;&lt; s1 &lt;&lt; endl;
		cout &lt;&lt; s2 &lt;&lt; endl;

		cin &gt;&gt; s1;
		cout &lt;&lt; s1 &lt;&lt; endl;

	}
}
int main()
{
	Myobject::test02();
	//Myobject::test_01();
	return 0;
}</code></pre> 
<h2 id="3.%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D%C2%A0">3.写时拷贝 </h2> 
<blockquote> 
 <p>写时拷贝就是一种拖延症，是在浅拷贝的基础之上增加了引用计数的方式来实现的。<br> 引用计数：用来记录资源使用者的个数。在构造时，将资源的计数给成1，每增加一个对象使用该<br> 资源，就给计数增加1，当某个对象被销毁时，先给该计数减1，然后再检查是否需要释放资源，<br> 如果计数为1，说明该对象时资源的最后一个使用者，将该资源释放；否则就不能释放，因为还有<br> 其他对象在使用该资源。</p> 
</blockquote> 
<p>本章完。 </p> 
<p> </p> 
<p> </p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/67c052d26edb6041532e833c0f456409/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【动态规划】力扣.213. 打家劫舍 II</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e9e9bdf685975544f323bca4e1a8ec2c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【ffmpeg命令入门】视频的旋转与翻转</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>