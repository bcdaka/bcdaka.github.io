<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】二叉树基础(带你详细了解二叉树） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/ec67fe3f0fb79f87eef090366edd9ac0/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】二叉树基础(带你详细了解二叉树）">
  <meta property="og:description" content="🌏个人博客主页：心.c
​
前言：最近学习了二叉树，和大家分享一下我的理解和感悟，希望对大家有所帮助，话不多说，开整！！！
🔥🔥🔥专题文章：二叉树
😽感谢大家的点赞👍收藏⭐️评论✍您的一键三连是我更新的动力 💓
目录
概念：
二叉树的结构：
图解：
结构体创建：
二叉树的分类：
满二叉树
完全二叉树：
平衡二叉树
二叉搜索树
二叉树遍历： 二叉树遍历方式：
递归遍历演示：
前序遍历：
中序遍历：
后续遍历：
迭代遍历演示（栈）：
前序遍历：
中序遍历：
后续遍历：
概念： 二叉树是一种每个节点最多有两个子节点的数据结构。通常，这两个子节点被称为左子节点和右子节点。
二叉树的结构： 图解： ​
结构体创建： // 二叉树节点结构体 struct TreeNode { int val; // 节点值 TreeNode* left; // 指向左子节点的指针 TreeNode* right; // 指向右子节点的指针 // 默认构造函数 TreeNode() : val(0), left(nullptr), right(nullptr) {} // 带值的构造函数 TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} // 带左右子节点的构造函数 TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {} }; 二叉树的分类： 满二叉树 每个节点都有0或2个子节点的二叉树。满二叉树的每一层都完全填满。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-09-01T17:25:57+08:00">
    <meta property="article:modified_time" content="2024-09-01T17:25:57+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】二叉树基础(带你详细了解二叉树）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p class="img-center"><img alt="" height="90" src="https://images2.imgbox.com/41/99/fRmnv3GZ_o.png" width="500"></p> 
<p style="text-align:center;">  🌏<strong>个人博客主页</strong>：<a href="https://mp.csdn.net/mp_blog/manage/article?spm=1001.2014.3001.5448" title="心.c">心.c</a></p> 
<div> 
 <p><img alt="" src="https://images2.imgbox.com/8b/e6/6w4eWBfS_o.gif">​</p> 
</div> 
<blockquote> 
 <p>前言：最近学习了二叉树，和大家分享一下我的理解和感悟，希望对大家有所帮助，话不多说，开整！！！</p> 
</blockquote> 
<p><strong>🔥<span style="color:#be191c;">🔥🔥专题文章：<a href="https://so.csdn.net/so/search?spm=1000.2115.3001.4498&amp;q=%E4%BA%8C%E5%8F%89%E6%A0%91&amp;t=&amp;u=" title="二叉树">二叉树</a></span></strong></p> 
<p><span style="color:#be191c;"><strong>😽感谢大家的点赞👍收藏⭐️评论✍您的一键三连是我更新的动力 💓</strong></span></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%C2%A0%E6%A6%82%E5%BF%B5%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0%E6%A6%82%E5%BF%B5%EF%BC%9A" rel="nofollow"> 概念：</a></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%9A" rel="nofollow">二叉树的结构：</a></p> 
<p id="%E5%9B%BE%E8%A7%A3%EF%BC%9A-toc" style="margin-left:120px;"><a href="#%E5%9B%BE%E8%A7%A3%EF%BC%9A" rel="nofollow">图解：</a></p> 
<p id="%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%9B%E5%BB%BA%EF%BC%9A-toc" style="margin-left:120px;"><a href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%9B%E5%BB%BA%EF%BC%9A" rel="nofollow">结构体创建：</a></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9A" rel="nofollow">二叉树的分类：</a></p> 
<p id="%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:120px;"><a href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">满二叉树</a></p> 
<p id="%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A-toc" style="margin-left:120px;"><a href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A" rel="nofollow">完全二叉树：</a></p> 
<p id="%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:120px;"><a href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">平衡二叉树</a></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-toc" style="margin-left:120px;"><a href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91" rel="nofollow">二叉搜索树</a></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%EF%BC%9A%C2%A0-toc" style="margin-left:80px;"><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%EF%BC%9A%C2%A0" rel="nofollow">二叉树遍历： </a></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%EF%BC%9A-toc" style="margin-left:120px;"><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%EF%BC%9A" rel="nofollow">二叉树遍历方式：</a></p> 
<p id="%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E6%BC%94%E7%A4%BA%EF%BC%9A-toc" style="margin-left:120px;"><a href="#%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E6%BC%94%E7%A4%BA%EF%BC%9A" rel="nofollow">递归遍历演示：</a></p> 
<p id="%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A-toc" style="margin-left:160px;"><a href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A" rel="nofollow">前序遍历：</a></p> 
<p id="%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A-toc" style="margin-left:160px;"><a href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A" rel="nofollow">中序遍历：</a></p> 
<p id="%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86%EF%BC%9A-toc" style="margin-left:160px;"><a href="#%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86%EF%BC%9A" rel="nofollow">后续遍历：</a></p> 
<p id="%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86%E6%BC%94%E7%A4%BA%EF%BC%88%E6%A0%88%EF%BC%89%EF%BC%9A-toc" style="margin-left:120px;"><a href="#%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86%E6%BC%94%E7%A4%BA%EF%BC%88%E6%A0%88%EF%BC%89%EF%BC%9A" rel="nofollow">迭代遍历演示（栈）：</a></p> 
<p id="%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A-toc" style="margin-left:160px;"><a href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A" rel="nofollow">前序遍历：</a></p> 
<p id="%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A-toc" style="margin-left:160px;"><a href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A" rel="nofollow">中序遍历：</a></p> 
<p id="%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86%EF%BC%9A-toc" style="margin-left:160px;"><a href="#%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86%EF%BC%9A" rel="nofollow">后续遍历：</a></p> 
<hr> 
<h4 id="%C2%A0%E6%A6%82%E5%BF%B5%EF%BC%9A"> <span style="color:#be191c;">概念：</span></h4> 
<blockquote> 
 <p><strong>二叉树是一种每个节点最多有两个子节点的数据结构。通常，这两个子节点被称为左子节点和右子节点。</strong></p> 
</blockquote> 
<h4 id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%9A"><span style="color:#ed7976;"><span style="background-color:#fef2f0;">二叉树的结构：</span></span></h4> 
<h5 id="%E5%9B%BE%E8%A7%A3%EF%BC%9A"><span style="color:#ed7976;">图解：</span></h5> 
<p><img alt="" height="309" src="https://images2.imgbox.com/3b/d7/bZ0XtnAu_o.png" width="683">​</p> 
<h5 id="%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%9B%E5%BB%BA%EF%BC%9A"><span style="color:#ed7976;">结构体创建：</span></h5> 
<div> 
 <pre><code class="language-cpp">// 二叉树节点结构体
struct TreeNode {
    int val;         // 节点值
    TreeNode* left;  // 指向左子节点的指针
    TreeNode* right; // 指向右子节点的指针

    // 默认构造函数
    TreeNode() : val(0), left(nullptr), right(nullptr) {}

    // 带值的构造函数
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}

    // 带左右子节点的构造函数
    TreeNode(int x, TreeNode* left, TreeNode* right)
        : val(x), left(left), right(right) {}
};</code></pre> 
</div> 
<h4 id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9A"><span style="color:#ed7976;"><span style="background-color:#fef2f0;">二叉树的分类：</span></span></h4> 
<h5 id="%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span style="color:#be191c;"><strong>满二叉树</strong></span></h5> 
<blockquote> 
 <p>每个节点都有0或2个子节点的二叉树。<strong>满二叉树的每一层都完全填满</strong>。</p> 
</blockquote> 
<p> <img alt="" height="251" src="https://images2.imgbox.com/7d/58/73xeo8FX_o.png" width="293"> </p> 
<h5 id="%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A"><span style="color:#be191c;"><strong>完全二叉树：</strong></span></h5> 
<blockquote> 
 <p> 一个二叉树，<strong>除了最底层外，每层的节点都被填满，且最底层的节点都靠左对齐。</strong></p> 
</blockquote> 
<p> <img alt="" height="272" src="https://images2.imgbox.com/a7/be/voHzUNBC_o.png" width="416"> </p> 
<h5 id="%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span style="color:#be191c;"><strong>平衡二叉树：</strong></span></h5> 
<blockquote> 
 <p> 一棵二叉树，<strong>任意节点的两个子树的高度差不超过1。</strong>常见的平衡二叉树包括 AVL 树和红黑树。</p> 
</blockquote> 
<p> <img alt="" height="258" src="https://images2.imgbox.com/f2/37/8x9xfKLE_o.png" width="523"> </p> 
<h5 id="%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span style="color:#be191c;"><strong>二叉搜索树：</strong></span></h5> 
<blockquote> 
 <p>一种特定类型的二叉树，<strong>每个节点的左子树的值都小于节点的值，而右子树的值都大于节点的值</strong>。这使得搜索、插入和删除操作都具有较高的效率</p> 
</blockquote> 
<p> <img alt="" height="259" src="https://images2.imgbox.com/88/a6/PIQBsZzT_o.png" width="416"> </p> 
<h4 id="%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%EF%BC%9A%C2%A0"><span style="color:#ed7976;"><span style="background-color:#fef2f0;">二叉树遍历： </span></span></h4> 
<h5 id="%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%EF%BC%9A">二叉树遍历方式：</h5> 
<h6 id="%C2%A0%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0"> <img alt="" height="290" src="https://images2.imgbox.com/42/99/c6WxZeiN_o.png" width="679"> </h6> 
<p><span style="color:#be191c;"><strong>前序遍历：</strong></span></p> 
<ul><li>先遍历中间节点</li><li>然后遍历左孩子</li><li>最后遍历右孩子</li></ul> 
<p><strong><span style="color:#be191c;">中序遍历：</span></strong></p> 
<ul><li>先遍历左孩子</li><li>再遍历中间节点</li><li>追回遍历右孩子</li></ul> 
<p><span style="color:#be191c;"><strong>后续遍历：</strong></span></p> 
<ul><li>先遍历左孩子</li><li>再遍历右孩子</li><li>最后遍历中间节点</li></ul> 
<p></p> 
<h5 id="%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E6%BC%94%E7%A4%BA%EF%BC%9A"><span style="color:#be191c;"><span style="background-color:#fef2f0;">递归遍历演示</span>：</span></h5> 
<p><strong>相关题目链接：</strong></p> 
<p><a class="link-info" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/" rel="nofollow" title="1.  前序遍历">1.  前序遍历</a></p> 
<p><a class="link-info" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/" rel="nofollow" title="2.  中序遍历">2.  中序遍历</a></p> 
<p><a class="link-info" href="https://leetcode.cn/problems/binary-tree-postorder-traversal/" rel="nofollow" title="3.  后序遍历">3.  后序遍历</a></p> 
<h6 id="%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A"><span style="color:#be191c;">前序遍历：</span></h6> 
<pre><code class="language-cpp">class Solution {
public:
    void postorder(TreeNode* root, vector&lt;int&gt;&amp; res) {
        if (!root) {
            return;
        }
        res.push_back(root-&gt;val);
        postorder(root-&gt;left, res);
        postorder(root-&gt;right, res);

    }
    vector&lt;int&gt; postorderTraversal(TreeNode* root) {
        vector&lt;int&gt; res;
        postorder(root, res);
        return res;
    }
};</code></pre> 
<h6 id="%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A"><span style="color:#be191c;">中序遍历：</span></h6> 
<pre><code class="language-cpp">class Solution {
public:
    void postorder(TreeNode* root, vector&lt;int&gt;&amp; res) {
        if (!root) {
            return;
        }
        postorder(root-&gt;left, res);
        res.push_back(root-&gt;val);
        postorder(root-&gt;right, res);

    }
    vector&lt;int&gt; postorderTraversal(TreeNode* root) {
        vector&lt;int&gt; res;
        postorder(root, res);
        return res;
    }
};</code></pre> 
<h6 id="%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86%EF%BC%9A"><span style="color:#be191c;">后续遍历：</span></h6> 
<pre><code class="language-cpp">class Solution {
public:
    void postorder(TreeNode* root, vector&lt;int&gt;&amp; res) {
        if (!root) {
            return;
        }
        postorder(root-&gt;left, res);
        postorder(root-&gt;right, res);
        res.push_back(root-&gt;val);
    }
    vector&lt;int&gt; postorderTraversal(TreeNode* root) {
        vector&lt;int&gt; res;
        postorder(root, res);
        return res;
    }
};</code></pre> 
<p></p> 
<h5 id="%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86%E6%BC%94%E7%A4%BA%EF%BC%88%E6%A0%88%EF%BC%89%EF%BC%9A"><span style="color:#be191c;"><span style="background-color:#fef2f0;">迭代遍历演示（栈）：</span></span></h5> 
<h6><strong><span style="color:#be191c;">前序遍历：</span></strong></h6> 
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; preorderTraversal(TreeNode* root) {
        stack&lt;TreeNode*&gt; stack;
        vector&lt;int&gt; result;
        if (root == nullptr)
            return result;
        stack.push(root);
        while (!stack.empty()) {
            root = stack.top();
            stack.pop();
            result.push_back(root-&gt;val);
            if (root-&gt;right) {
                stack.push(root-&gt;right);
            }
            if (root-&gt;left) {
                stack.push(root-&gt;left);
            }
        }
        return result;
    }
};</code></pre> 
<h6><span style="color:#be191c;">中序遍历：</span></h6> 
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; inorderTraversal(TreeNode* root) {
        vector&lt;int&gt; result;
        stack&lt;TreeNode*&gt; stack;
        TreeNode* cur = root;
        while (cur != nullptr || !stack.empty()) {
            if (cur != nullptr) {
                stack.push(cur);
                cur = cur-&gt;left;
            } else {
                cur = stack.top();
                stack.pop();
                result.push_back(cur-&gt;val);
                cur = cur-&gt;right;
            }
        }
        return result;
    }
};</code></pre> 
<h6><span style="color:#be191c;">后续遍历：</span></h6> 
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; postorderTraversal(TreeNode* root) {
        stack&lt;TreeNode*&gt; stack;
        vector&lt;int&gt; result;
        if (root == nullptr)
            return result;
        stack.push(root);
        while (!stack.empty()) {
            root = stack.top();
            stack.pop();
            result.push_back(root-&gt;val);
            if (root-&gt;left) {
                stack.push(root-&gt;left);
            }
            if (root-&gt;right) {
                stack.push(root-&gt;right);
            }
        }
        reverse(result.begin(), result.end());
        return result;
    }
};</code></pre> 
<p>这里就分享完了，感谢大家的观看</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c4013698aa921abcfcee0b10def424e5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">neural-admixture：基于AI的快速基因组聚类</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ec2b4e46f55ea69c3332c564ea9299e8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Node.js sqlite3事件深入解析：trace、profile、change、error、open</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>