<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>第十五届蓝桥杯省赛大学B组(c&#43;&#43;) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/49dd5b1ad5184a745abcbc1058913fcb/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="第十五届蓝桥杯省赛大学B组(c&#43;&#43;)">
  <meta property="og:description" content="很幸运拿了辽宁赛区的省一,进入6月1号的国赛啦...
这篇文章主要对第十五届省赛大学B组(C&#43;&#43;)进行一次完整的复盘,这次省赛==2道填空题&#43;6道编程题:
A.握手问题 把握手情景看成矩阵:
粉色部分是7个不能互相捂手的情况
由于每个人只能和其他人捂手, 所以黑色情况是不算的
1和2握手==2和1握手,就是只用算一半的对角矩阵
#include&lt;iostream&gt; using namespace std; int main(){ int a=0; for(int i=49;i;i--) a&#43;=i; int b=0; for(int i=6;i;i--) b&#43;=i; int ans=a-b; cout&lt;&lt;ans&lt;&lt;endl;//最后求得答案为1204 return 0; } B.小球反弹 这题考试的时候我是直接跳过的,到最后也没来得及看,看了估计也算不对,haha
整体思路是:
最终返回左上角时,小球走过的水平路程和垂直路程一定是343720和233333的偶数倍并且水平路程与垂直路程之比一定为15:17
对于后一个条件,很容易理解,因为两个方向上速度比是恒定的,接下来以极端情况简单说一下为什么只有到左上角小球走过的水平路程和垂直路程一定是343720和233333的偶数倍:
#include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; typedef long long ll; const int N=1e4; const ll X=343720; const ll Y=233333; int main(){ for(ll x=2;x&lt;=N;x&#43;=2){ for(ll y=2;y&lt;=N;y&#43;=2){ if (15*Y*y==17*X*x){ printf(&#34;%lf&#34;,sqrt((X*x)*(X*x)&#43;(Y*y)*(Y*y))); //结果是1100325199.770395 return 0; } } } } C.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-11T21:57:44+08:00">
    <meta property="article:modified_time" content="2024-05-11T21:57:44+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">第十五届蓝桥杯省赛大学B组(c&#43;&#43;)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>很幸运拿了辽宁赛区的省一,进入6月1号的国赛啦...</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b6/93/wEfztRZc_o.png"></p> 
<p>这篇文章主要对第十五届省赛大学B组(C++)进行一次完整的复盘,这次省赛==2道填空题+6道编程题:</p> 
<h2>A.握手问题</h2> 
<p><img alt="" height="833" src="https://images2.imgbox.com/0b/29/r5HOMy0k_o.png" width="984"></p> 
<p>把握手情景看成<span style="color:#fe2c24;"><strong>矩阵</strong></span>:</p> 
<p>粉色部分是7个不能互相捂手的情况</p> 
<p>由于每个人只能和其他人捂手, 所以黑色情况是不算的</p> 
<p>1和2握手==2和1握手,就是只用算一半的对角矩阵</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int main(){
    int a=0;
    for(int i=49;i;i--) a+=i;
    int b=0;
    for(int i=6;i;i--) b+=i;
    int ans=a-b;
    cout&lt;&lt;ans&lt;&lt;endl;//最后求得答案为1204 
    return 0;
}</code></pre> 
<h2 style="background-color:transparent;">B.小球反弹</h2> 
<p>这题考试的时候我是直接跳过的,到最后也没来得及看,看了估计也算不对,haha</p> 
<p>整体思路是:</p> 
<p>最终返回左上角时,小球走过的<strong><span style="color:#fe2c24;">水平路程和垂直路程一定是343720和233333的偶数倍</span></strong>并且<strong><span style="color:#fe2c24;">水平路程与垂直路程之比一定为15:17</span></strong></p> 
<p>对于后一个条件,很容易理解,因为两个方向上速度比是恒定的,接下来以<span style="color:#fe2c24;"><strong>极端情况</strong></span>简单说一下为什么只有到左上角小球走过的水平路程和垂直路程一定是343720和233333的偶数倍:</p> 
<p><img alt="" height="707" src="https://images2.imgbox.com/e3/80/K830K0Be_o.png" width="1088"></p> 
<p><img alt="" height="657" src="https://images2.imgbox.com/93/98/UPr22uTC_o.png" width="1086"></p> 
<p><img alt="" height="675" src="https://images2.imgbox.com/af/ae/sMy8YzKd_o.png" width="1031"></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cmath&gt;
using namespace std;
typedef long long ll;
const int N=1e4;
const ll X=343720;
const ll Y=233333;
int main(){
    for(ll x=2;x&lt;=N;x+=2){
        for(ll y=2;y&lt;=N;y+=2){
            if (15*Y*y==17*X*x){
                printf("%lf",sqrt((X*x)*(X*x)+(Y*y)*(Y*y)));
                //结果是1100325199.770395
                return 0;
            }
        }
    }
}</code></pre> 
<h2>C.好数</h2> 
<p>这题暴力枚举就能AC,数据不大,haha</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
typedef long long ll;
const int N=1e7+5;
ll ans;
bool check(int x){
    int flag=0;
    while(x&gt;0){
        int t=x%10;
        if(!flag){
            if(t%2==0) return false;
            else flag=1;
        }
        else{
            if(t%2!=0) return false;
            else flag=0;
        }
        x/=10;
    }
    return true;
}
int main(){
    int n;
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++) if(check(i)) ans++;
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}</code></pre> 
<p><img alt="" height="1180" src="https://images2.imgbox.com/03/8b/N02AfwYj_o.png" width="1200"></p> 
<h2>D.R格式</h2> 
<p>考试时候的代码:</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cmath&gt;
using namespace std;
typedef long long ll;
int main(){
    int n;
    double d;
    cin&gt;&gt;n&gt;&gt;d;
    ll a=(ll)pow(2,n);
    double ans=a*d;
    double res=(ll)ans+0.5;
    if(ans&gt;=res) cout&lt;&lt;(ll)ans+1&lt;&lt;endl;
    else cout&lt;&lt;(ll)ans&lt;&lt;endl;
    return 0;
}</code></pre> 
<p>混了一半的分数:</p> 
<p><img alt="" height="1189" src="https://images2.imgbox.com/0e/00/L60lsKVw_o.png" width="1200"></p> 
<p>高精度优化(AC): </p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;//reverse函数:前后翻转
#include&lt;cstring&gt;//to_string函数:数字常量转化为字符串
using namespace std;
typedef long long ll;
int n;string d;
string ans="1";
string add(string a,string b){
    string res;
    int la=a.size(),lb=b.size();
    int i=la-1,j=lb-1,jw=0;
    while(i&gt;=0||j&gt;=0){
        int sum=jw;
        if(i&gt;=0) sum+=a[i--]-'0';
        if(j&gt;=0) sum+=b[j--]-'0';
        jw=sum/10;
        res+=to_string(sum%10);
    }
    if(jw) res+=to_string(jw);
    reverse(res.begin(),res.end());
    return res;
}
string mul(string a,string b){
    string res="0";
    int la=a.size(),lb=b.size();
    for(int i=la-1;i&gt;=0;i--){
        int jw=0;
        string temp;
        for(int j=lb-1;j&gt;=0;j--){
            int sum=(a[i]-'0')*(b[j]-'0')+jw;
            jw=sum/10;
            temp+=to_string(sum%10);
        }
        if(jw) temp+=to_string(jw);
        reverse(temp.begin(),temp.end());
        for(int k=0;k&lt;la-1-i;k++) temp+="0";
        res=add(res,temp);
    }
    return res;
}
int main(){
    cin&gt;&gt;n&gt;&gt;d;
    while(n--) ans=mul(ans,"2");
    string newd="";int flag;
    for(int i=0;i&lt;d.size();i++){
        if(d[i]!='.') newd+=d[i];
        else flag=d.size()-i-1;
    }
    ans=mul(newd,ans);
    int key=ans.size()-flag;
    string s="";
    for(int i=0;i&lt;key;i++) s+=ans[i];
    if(ans[key]&gt;='5') s=add(s,"1");
    cout&lt;&lt;s;
    return 0;
}</code></pre> 
<h2>E.宝石组合</h2> 
<p>整体思路(当然考试时候我肯定是没想出来):</p> 
<pre><code class="language-cpp">由最小公倍数和最大公约数的性质
我们可以推出S的值就等于三个数的最大公约数gcd(h[a],h[b],h[c])
当三个数的最大公约数最大时,s最大,然后把包含此因子的三个最小数输出即可
//最大公约数
int gcd(int a,int b){
    return b==0?a:gcd(b,a%b);
}
//最小公倍数
int lcm(int a,int b){
    return a*b/gcd(a,b);
}</code></pre> 
<p>暴力:</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long ll;
const int N=1e5+5;
int n,h[N],ans[5],res[5],temp=0;
int gcd(int a,int b){
    return b==0?a:gcd(b,a%b);
}
int gcd3(int a,int b,int c){
    return gcd(gcd(a,b),c);
}
void dfs(int x,int startt) {
    if(x&gt;3){
        int y=gcd3(h[ans[1]],h[ans[2]],h[ans[3]]);
        if(y&gt;temp){
            res[1]=ans[1],res[2]=ans[2],res[3]=ans[3];
            temp=y;
        }
        return ;
    }
    for(int i=startt;i&lt;=n;i++){
        ans[x]=i;
        dfs(x+1,i+1);
        ans[x]=0;
    }
}
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++) cin&gt;&gt;h[i];
    dfs(1,1);
    h[1]=h[res[1]],h[2]=h[res[2]],h[3]=h[res[3]];
    sort(h+1,h+4);
    cout&lt;&lt;h[1]&lt;&lt;" "&lt;&lt;h[2]&lt;&lt;" "&lt;&lt;h[3]&lt;&lt;endl;
    return 0;
}</code></pre> 
<p><img alt="" height="1160" src="https://images2.imgbox.com/c6/41/7gz21sgg_o.png" width="1200"></p> 
<p>优化思路(AC):</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
using namespace std;
const int N=1e5+5;
int n,h[N];
vector&lt;int&gt;ans[N];
int main(){
    cin&gt;&gt;n;
    for(int i=0;i&lt;n;i++) cin&gt;&gt;h[i];
    sort(h,h+n);
    //遍历一遍把数放入其因子中
    for(int i=0;i&lt;n;i++){
        for(int j=1;j&lt;=sqrt(h[i]);j++){
            if(h[i]%j==0){
                ans[j].push_back(h[i]);
                if(h[i]/j!=j) ans[h[i]/j].push_back(h[i]);
            }
        }
    }
    //从最大的因子开始遍历,个数不低于3就可以输出
    for(int i=N-1;i&gt;=0;i--){
        if(ans[i].size()&gt;=3){
            cout&lt;&lt;ans[i][0];
            for(int j=1;j&lt;3;j++){
                cout&lt;&lt;" "&lt;&lt;ans[i][j];
            }
            break;
        }
    }
    return 0;
}</code></pre> 
<h2>F.数字接龙</h2> 
<p>这题考试时候没想明白如何判断路径是否交叉,就只会dfs出所有答案可能的情况,折腾将近一个小时还没解决,最后无奈提交了样例还有-1这个情况...</p> 
<p>实际上对于斜方向进行判断时,只需判断对于斜边的两个坐标是否被选中(AC):</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int n,k,a[15][15],endd=0;
bool flag[15][15];
int dx[8]={-1,-1,0,1,1,1,0,-1};
int dy[8]={0,1,1,1,0,-1,-1,-1};
string ans;
//寻找方向函数
int direction(int x,int y){
    if(a[x][y]==k-1) return 0;
    else return a[x][y]+1;
}
//回溯字符串函数
string delete_last(string s){
    if(s.size()==1) return "";//注意:大小为1时返回空
    string temp="";
    for(int i=0;i&lt;=s.size()-2;i++) temp+=s[i];
    return temp;
}
//核心函数dfs
void dfs(int x,int y){
    flag[x][y]=true;
    if(x==n&amp;&amp;y==n&amp;&amp;ans.size()==n*n-1){
        cout&lt;&lt;ans&lt;&lt;endl;
        //只要找到字典序最小的,找到后标记endd
        endd++;
        return ;
    }
    int dir=direction(x,y);
    for(int i=0;i&lt;=7;i++){
        int xx=x+dx[i],yy=y+dy[i];
        if(xx&gt;=1&amp;&amp;xx&lt;=n&amp;&amp;yy&gt;=1&amp;&amp;yy&lt;=n&amp;&amp;a[xx][yy]==dir&amp;&amp;flag[xx][yy]==false){
            //判断斜方向情况,i才是真正的方向,direction只是方向的值
            if(i==1&amp;&amp;flag[x-1][y]&amp;&amp;flag[x][y+1]) continue;
            else if(i==3&amp;&amp;flag[x][y+1]&amp;&amp;flag[x+1][y]) continue;
            else if(i==5&amp;&amp;flag[x+1][y]&amp;&amp;flag[x][y-1]) continue;
            else if(i==7&amp;&amp;flag[x-1][y]&amp;&amp;flag[x][y-1]) continue;
            else{
                flag[xx][yy]=true;
                ans+=to_string(i);
                dfs(xx,yy);
                //在回溯时,特判一下已经找到答案的情况
                if(endd) return ;
                //回溯
                flag[xx][yy]=false;
                ans=delete_last(ans);
            }
        }
    }
    return ;
}
int main(){
    cin&gt;&gt;n&gt;&gt;k;
    //注意:k的值不可能大于pow(n,2)
    if(k&gt;n*n){
        puts("-1");
        return 0;
    }
    for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) cin&gt;&gt;a[i][j];
    dfs(1,1);
    //利用endd标记是否成功dfs
    if(!endd) puts("-1");
    return 0;
}</code></pre> 
<h2>G.爬山</h2> 
<p>这题利用STL的<span style="color:#fe2c24;"><strong>优先队列</strong></span>进行模拟,考试时候魔法一和魔法二相同时候的情况没完善明确,因此下面这段代码肯定会<span style="color:#fe2c24;"><strong>有问题</strong></span>,但考完试我隐约记得while(m--)好像被我写成了while(n--),我真是个**:</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const int N=1e5+5;
int n,p,q,h[N];
ll ans;
priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt;pq;
int magic(int x){
    int a=sqrt(x);
    int b=x/2;
    if(a&gt;b) return 2;
    else if(a&lt;b) return 1;
    else return 0;
}
int main(){
    cin&gt;&gt;n&gt;&gt;p&gt;&gt;q;
    for(int i=1;i&lt;=n;i++){
        int x;
        cin&gt;&gt;x;
        pq.push(x);
    }
    int m=p+q;
    while(m--){
        int t=pq.top();
        pq.pop();
        if(p&gt;0&amp;&amp;q&gt;0){
            int tt=magic(t);
            if(tt==0){
                if(q&gt;p) pq.push(t/2),q--;
                else pq.push((int)sqrt(t)),p--;
            }
            else if(tt==1){
                pq.push((int)sqrt(t));
                p--;
            }
            else{
                pq.push(t/2);
                q--;
            }
        }
        else if(p&gt;0&amp;&amp;q&lt;=0){
            pq.push((int)sqrt(t)),p--;
        }
        else if(q&gt;0&amp;&amp;p&lt;=0){
            pq.push(t/2),q--;
        }
        else{
            break;
        }
    }
    while(pq.size()){
        ans+=pq.top();
        pq.pop();
    }
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}</code></pre> 
<p><img alt="" height="981" src="https://images2.imgbox.com/1a/55/gH9luRod_o.png" width="1200"></p> 
<p>HACK数据:</p> 
<pre><code class="language-cpp">2 1 1
49 48</code></pre> 
<h2 style="background-color:transparent;">H.拔河</h2> 
<p>这题考试时候直接理解错题目了(哭),以为每一人都要参加拔河,估计直接零蛋了haha</p> 
<p>所以做题时一定要认真把题目读清楚...</p> 
<p>暴力枚举两个连续区间的左右端点:</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
typedef long long ll;
const int N=1e3+5;
ll n,a[N],l1,r1,l2,r2,ans=1e18;//不开浪浪见祖宗...
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){//前缀和
        cin&gt;&gt;a[i];
        a[i]+=a[i-1];
    }
    for(int l1=1;l1&lt;=n;l1++){
        for(int r1=1;r1&lt;=n;r1++){
            for(int l2=1;l2&lt;=n;l2++){
                for(int r2=1;r2&lt;=n;r2++){
                    if(l1&lt;=r1&amp;&amp;r1&lt;l2&amp;&amp;l2&lt;=r2){
                        ll sum1=a[r1]-a[l1-1];
                        ll sum2=a[r2]-a[l2-1];
                        ans=min(ans,abs(sum2-sum1));
                    }
                }
            }
        }
    }
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}</code></pre> 
<p><img alt="" height="1089" src="https://images2.imgbox.com/3b/af/vgaHuAhR_o.png" width="1200"></p> 
<p>前缀和+multiset(AC): </p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;set&gt;
using namespace std;
typedef long long ll;
const int N=1e3+5;
ll n,a[N],ans=1e18;
multiset&lt;ll&gt;s;
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;a[i];
        a[i]+=a[i-1];
    }
    //利用multiset(有序并且可以重复)记录所有可能的区间
    for(int l=1;l&lt;=n;l++) for(int r=1;r&lt;=n;r++) if(r&gt;=l) s.insert(a[r]-a[l-1]);
    //枚举左区域的右端点
    for(int r=1;r&lt;n;r++){
        //删除以r为左端点的所有区间,因为接下来右区间是从r+1开始选择
        //如果保留之前的以r为左端点的右区间之和,会影响答案
        for(int i=r;i&lt;=n;i++) s.erase(s.find(a[i]-a[r-1]));
        //枚举左区间的左端点
        for(int l=1;l&lt;=r;l++){
            //计算左区间
            ll temp=a[r]-a[l-1];
            auto x=s.lower_bound(temp);
            //multiset.lower_bound(key)函数返回一个迭代器
            //返回第一个&gt;=key的元素
            //如果key&gt;容器max,则返回当前容器中最后一个元素的位置
            if(x!=s.end()){
                ans=min(ans,abs(*x-temp));//和temp右侧的*x更新ans
            }
            if(x!=s.begin()){
                x--;//先向左移动x
                ans=min(ans,abs(*x-temp));//和temp左侧的*x更新ans
            }
        }
    }
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0c09d8a40bfc13ed1872ccfdac008491/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java导出千万级大数据到CSV文件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d2588015d8d71e20ac43039bc49f4c15/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Llama 3大模型学习</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>