<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java中的Stack（栈）（如果想知道Java中有关Stack的知识点，那么只看这一篇就足够了！） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/7eeca5ea071de90f72ca5e4f0202b12e/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java中的Stack（栈）（如果想知道Java中有关Stack的知识点，那么只看这一篇就足够了！）">
  <meta property="og:description" content="前言：栈（Stack）是一种基础且重要的数据结构，以其后进先出（LIFO, Last In First Out）的特性广泛应用于计算机科学和编程中。
✨✨✨这里是秋刀鱼不做梦的BLOG
✨✨✨想要了解更多内容可以访问我的主页秋刀鱼不做梦-CSDN博客
先让我们看一下本文大致的讲解内容：
目录
1.栈的初识
2.栈的自我实现
（1）数组实现：
（2）链表实现
3.栈中常用API
4.栈的应用场景
5.总结
1.栈的初识 在开始学习使用栈之前，先让我们来了解一下什么是栈：
栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端称为栈顶，另一端称为栈底。栈中的数据元素遵守后进先出LIFO（Last In First Out）的原则。
栈的主要特性包括：
后进先出（LIFO）：最新压入栈的数据最先被弹出。栈顶操作：所有的插入（push）和删除（pop）操作都只能在栈顶进行。 如果使用我们日常生活中的案例来解释的话，就如同子弹弹夹，先装入的子弹后被打出，后装入的子弹，先被打出：
将其转换为编程语言图像（如图）：
其中：
——压栈：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶。 ——出栈：栈的删除操作叫做出栈。出数据在栈顶。
通过上述的讲解，这样我们就大致的了解了什么是栈（Stack）了！
2.栈的自我实现 学习完了什么是栈之后，然我们试试能不能使用已有的知识体系来实现栈，在Java中自我实现栈的方式大致有两种：使用数组实现与使用链表实现。
（1）数组实现： public class ArrayStack { public int[] stack; // 用于存储栈元素的数组 public int top; // 栈顶索引 public ArrayStack(int size) { stack = new int[size]; // 初始化数组大小 top = -1; // 初始化栈顶索引为-1，表示栈为空 } // 将元素压入栈顶 public void push(int value) { if (top == stack.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-15T10:21:14+08:00">
    <meta property="article:modified_time" content="2024-07-15T10:21:14+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java中的Stack（栈）（如果想知道Java中有关Stack的知识点，那么只看这一篇就足够了！）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>       <strong> 前言：栈（Stack）是一种基础且重要的数据结构，以其后进先出（LIFO, Last In First Out）的特性广泛应用于计算机科学和编程中。</strong></p> 
<hr> 
<blockquote> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e3/53/LTnubiw2_o.jpg"></p> 
 <p><strong>✨✨✨<span style="color:#ff9900;">这里是秋刀鱼不做梦的BLOG</span></strong></p> 
 <p><span style="color:#ff9900;"><strong>✨✨✨想要了解更多内容可以访问我的主页</strong></span><a href="https://blog.csdn.net/2302_80198073?type=blog" title="秋刀鱼不做梦-CSDN博客">秋刀鱼不做梦-CSDN博客</a></p> 
</blockquote> 
<p><span style="color:#a2e043;"><strong>先让我们看一下本文大致的讲解内容：</strong></span></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/bb/9b/HNXOh1ux_o.png"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E6%A0%88%E7%9A%84%E5%88%9D%E8%AF%86-toc" style="margin-left:0px;"><strong><a href="#1.%E6%A0%88%E7%9A%84%E5%88%9D%E8%AF%86" rel="nofollow">1.栈的初识</a></strong></p> 
<p id="2.%E6%A0%88%E7%9A%84%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><strong><a href="#2.%E6%A0%88%E7%9A%84%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B0" rel="nofollow">2.栈的自我实现</a></strong></p> 
<p id="%EF%BC%881%EF%BC%89%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc" style="margin-left:40px;"><strong><a href="#%EF%BC%881%EF%BC%89%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%EF%BC%9A" rel="nofollow">（1）数组实现：</a></strong></p> 
<p id="%EF%BC%882%EF%BC%89%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><strong><a href="#%EF%BC%882%EF%BC%89%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0" rel="nofollow">（2）链表实现</a></strong></p> 
<p id="3.%E6%A0%88%E4%B8%AD%E5%B8%B8%E7%94%A8API-toc" style="margin-left:0px;"><strong><a href="#3.%E6%A0%88%E4%B8%AD%E5%B8%B8%E7%94%A8API" rel="nofollow">3.栈中常用API</a></strong></p> 
<p id="4.%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:0px;"><strong><a href="#4.%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">4.栈的应用场景</a></strong></p> 
<p id="5.%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><strong><a href="#5.%E6%80%BB%E7%BB%93" rel="nofollow">5.总结</a></strong></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1.%E6%A0%88%E7%9A%84%E5%88%9D%E8%AF%86"><span style="color:#956fe7;">1.栈的初识</span></h2> 
<p>       <strong> 在开始学习使用栈之前，先让我们来了解一下什么是栈：</strong></p> 
<blockquote> 
 <p>      <span style="color:#ff9900;"><strong>  栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端称为栈顶，另一端称为栈底。栈中的数据元素遵守后进先出LIFO（Last In First Out）的原则。</strong></span></p> 
</blockquote> 
<p><span style="color:#ffd900;"><strong>栈的主要特性包括：</strong></span></p> 
<blockquote> 
 <ol><li><strong>后进先出（LIFO）</strong>：最新压入栈的数据最先被弹出。</li><li><strong>栈顶操作</strong>：所有的插入（push）和删除（pop）操作都只能在栈顶进行。</li></ol> 
</blockquote> 
<p><strong>        如果使用我们日常生活中的案例来解释的话，就如同子弹弹夹，先装入的子弹后被打出，后装入的子弹，先被打出：</strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b7/0c/DBbbnXGv_o.png"></p> 
<p><strong>将其转换为编程语言图像（如图）：</strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/17/4e/mYsPouJh_o.png"></p> 
<p><span style="color:#ffd900;"><strong>其中：</strong></span></p> 
<p>      <span style="color:#38d8f0;"> </span><strong><span style="color:#38d8f0;"> ——</span><span style="color:#38d8f0;">压栈：</span>栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶。 </strong></p> 
<p><strong>        <span style="color:#38d8f0;">——</span><span style="color:#38d8f0;">出栈：</span>栈的删除操作叫做出栈。出数据在栈顶。</strong></p> 
<p><strong>通过上述的讲解，这样我们就大致的了解了什么是栈（Stack）了！</strong></p> 
<p></p> 
<h2 id="2.%E6%A0%88%E7%9A%84%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B0"><span style="color:#956fe7;"><strong>2.</strong>栈的自我实现</span></h2> 
<p>      <strong>  学习完了什么是栈之后，然我们试试能不能使用已有的知识体系来实现栈，在Java中自我实现栈的方式大致有两种：使用<span style="color:#a2e043;">数组实现</span>与使用<span style="color:#a2e043;">链表实现</span>。</strong></p> 
<h3 id="%EF%BC%881%EF%BC%89%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span style="color:#4da8ee;"><strong>（1）数组实现：</strong></span></h3> 
<pre><code class="language-java">public class ArrayStack {
    public int[] stack; // 用于存储栈元素的数组
    public int top; // 栈顶索引

    public ArrayStack(int size) {
        stack = new int[size]; // 初始化数组大小
        top = -1; // 初始化栈顶索引为-1，表示栈为空
    }

    // 将元素压入栈顶
    public void push(int value) {
        if (top == stack.length - 1) {
            throw new StackOverflowError("Stack is full"); // 如果栈已满，抛出异常
        }
        stack[++top] = value; // 将元素压入栈顶，并更新栈顶索引
    }

    // 弹出栈顶元素
    public int pop() {
        if (top == -1) {
            throw new EmptyStackException(); // 如果栈为空，抛出异常
        }
        return stack[top--]; // 返回栈顶元素，并更新栈顶索引
    }

    // 返回栈顶元素但不弹出
    public int peek() {
        if (top == -1) {
            throw new EmptyStackException(); // 如果栈为空，抛出异常
        }
        return stack[top]; // 返回栈顶元素
    }

    // 检查栈是否为空
    public boolean isEmpty() {
        return top == -1; // 如果栈顶索引为-1，表示栈为空
    }
}
</code></pre> 
<p><span style="color:#38d8f0;"><strong>现在我们再回顾一下上述代码的逻辑：</strong></span></p> 
<p><strong>        1. 首先先定义了一个基于数组实现的栈类 <code>ArrayStack</code>。它包含一个用于存储栈元素的数组 <code>stack</code> 和一个指示栈顶位置的变量 <code>top</code>。<br>         2. 然后使用构造方法 <code>ArrayStack(int size)</code> 来初始化栈的大小，并将 <code>top</code> 设置为 -1。 </strong></p> 
<p><strong>        3. <code>push(int value)</code> 方法将元素压入栈顶，如果栈满则抛出 <code>StackOverflowError</code>。<code>pop()</code> 方法弹出栈顶元素，如果栈为空则抛出 <code>EmptyStackException</code>。<code>peek()</code> 方法返回栈顶元素但不弹出，如果栈为空则抛出 <code>EmptyStackException</code>。<code>isEmpty()</code> 方法检查栈是否为空。</strong></p> 
<p></p> 
<h3 id="%EF%BC%882%EF%BC%89%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0"><span style="color:#4da8ee;"><strong>（2）链表实现</strong></span></h3> 
<pre><code class="language-java">public class DoublyLinkedListStack {
    public Node head; // 链表头节点
    public Node tail; // 链表尾节点

    // 定义节点类
    private static class Node {
        int value; // 节点值
        Node next; // 指向下一个节点的指针
        Node prev; // 指向上一个节点的指针

        Node(int value) {
            this.value = value; // 初始化节点值
            this.next = null; // 初始化下一个节点指针为空
            this.prev = null; // 初始化前一个节点指针为空
        }
    }

    public DoublyLinkedListStack() {
        head = null; // 初始化头节点为空
        tail = null; // 初始化尾节点为空
    }

    // 将元素压入栈顶
    public void push(int value) {
        Node newNode = new Node(value); // 创建新节点
        if (tail == null) {
            head = tail = newNode; // 如果链表为空，头尾节点都指向新节点
        } else {
            tail.next = newNode; // 将新节点连接到链表尾部
            newNode.prev = tail; // 新节点的前驱指向当前尾节点
            tail = newNode; // 更新尾节点为新节点
        }
    }

    // 弹出栈顶元素
    public int pop() {
        if (tail == null) {
            throw new EmptyStackException(); // 如果栈为空，抛出异常
        }
        int value = tail.value; // 获取尾节点的值
        if (tail.prev == null) {
            head = tail = null; // 如果只有一个元素，清空链表
        } else {
            tail = tail.prev; // 更新尾节点为前驱节点
            tail.next = null; // 断开新尾节点的next指针
        }
        return value; // 返回弹出的值
    }

    // 返回栈顶元素但不弹出
    public int peek() {
        if (tail == null) {
            throw new EmptyStackException(); // 如果栈为空，抛出异常
        }
        return tail.value; // 返回尾节点的值
    }

    // 检查栈是否为空
    public boolean isEmpty() {
        return tail == null; // 如果尾节点为空，栈为空
    }
}
</code></pre> 
<p><span style="color:#38d8f0;"><strong>现在我们再回顾一下上述代码的逻辑：</strong></span></p> 
<p>        <strong>首先我们先定义了一个基于双向链表实现的栈类 <code>DoublyLinkedListStack</code>。它包含头节点和尾节点，使用内部的 <code>Node</code> 类表示每个节点。然后我们实现了一下主要的方法包括：</strong></p> 
<ul><li> <p><strong><code>push(int value)</code>：将新元素压入栈顶。</strong></p> </li><li> <p><strong><code>pop()</code>：弹出栈顶元素，如果栈为空则抛出异常。</strong></p> </li><li> <p><strong><code>peek()</code>：返回栈顶元素但不弹出，若栈为空则抛出异常。</strong></p> </li><li> <p><strong><code>isEmpty()</code>：检查栈是否为空，返回布尔值。</strong></p> </li></ul> 
<p><strong>这样我们就用现有的知识体现来实现了栈（Stack）了！</strong></p> 
<p></p> 
<h2 id="3.%E6%A0%88%E4%B8%AD%E5%B8%B8%E7%94%A8API"><span style="color:#956fe7;"><strong>3.</strong>栈中常用API</span></h2> 
<p>  <strong>      学习完了自我实现栈（Stack）之后，现在让我们看看Java中自带的Stack如何使用吧：</strong></p> 
<p><span style="color:#fe2c24;"><strong>栈中常用的方法主要包括以下几种：</strong></span></p> 
<blockquote> 
 <ol><li><span style="color:#ff9900;"><strong>push(E item)</strong>：将元素压入栈顶。</span></li><li><span style="color:#ff9900;"><strong>pop()</strong>：移除并返回栈顶元素。</span></li><li><span style="color:#ff9900;"><strong>peek()</strong>：返回栈顶元素但不移除。</span></li><li><span style="color:#ff9900;"><strong>isEmpty()</strong>：检查栈是否为空。</span></li></ol> 
</blockquote> 
<p><span style="color:#ffd900;"><strong>现在让我们使用一个实例来进行讲解：</strong></span></p> 
<pre><code class="language-java">import java.util.Stack;

public class StackExample {
    public static void main(String[] args) {
        //创建一个栈
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();

        // 压入栈顶
        stack.push(1);
        stack.push(2);
        stack.push(3);

        // 查看栈顶元素
        System.out.println("栈顶元素: " + stack.peek());

        // 弹出栈顶元素
        System.out.println("弹出栈顶元素: " + stack.pop());

        // 查看栈顶元素
        System.out.println("栈顶元素: " + stack.peek());

        // 检查栈是否为空
        System.out.println("栈是否为空: " + stack.isEmpty());
    }
}
</code></pre> 
<p><span style="color:#38d8f0;"><strong>——这样我们就大致的了解了在Java中如何去操作一个创建出来的栈了！</strong></span></p> 
<p></p> 
<h2 id="4.%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span style="color:#956fe7;"><strong>4.</strong>栈的应用场景</span></h2> 
<p>       <span style="color:#ff9900;"> <strong>学习完栈之后，读者可能会发出疑问，栈到底有什么用处呢？</strong><strong>栈在实际应用中有许多场景，下面列举几个典型的应用：</strong></span></p> 
<ol><li><strong>表达式求值</strong>：如中缀表达式转后缀表达式的计算。</li><li><strong>函数调用</strong>：栈用于保存函数调用过程中的局部变量和返回地址。</li><li><strong>括号匹配</strong>：用于检查括号是否成对匹配。</li><li><strong>浏览器的前进后退</strong>：使用栈保存历史页面，以便用户前进和后退。</li><li><strong>深度优先搜索（DFS）</strong>：在图或树的遍历中使用。</li></ol> 
<p>       <strong> 这里我们只举出第一个（表达式求值）来讲解（<span style="color:#fe2c24;">其他读者如果有兴趣进一步学习，可以自行查找学习！</span>）</strong></p> 
<p><span style="color:#ff9900;"><strong>表达式求值即为：中缀表达式转换为后缀表达式（也称逆波兰表达式），以下为百度的解释：</strong></span></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/8a/9a/MGK1Klqq_o.png"></p> 
<p><span style="color:#38d8f0;"><strong>其作用主要体现在以下几个方面：</strong></span></p> 
<ol><li> <p><strong>简化计算：后缀表达式不需要括号，操作符和操作数的顺序明确，计算时更简单。</strong></p> </li><li> <p><strong>便于计算机处理：计算机处理后缀表达式更高效，避免了运算优先级的复杂性。</strong></p> </li><li> <p><strong>支持堆栈算法：后缀表达式可以直接使用栈来进行求值，适合实现逆波兰表示法。</strong></p> </li><li> <p><strong>提高表达式解析速度：在编译器和解释器中，后缀表达式有助于快速解析和执行表达式。</strong></p> </li></ol> 
<p><span style="color:#ffd900;"><strong>了解完了什么是逆波兰表达式之后，我们使用一道例题来进行讲解：</strong></span></p> 
<p><strong>题目链接：-----&gt;</strong><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></p> 
<p><span style="color:#fe2c24;"><strong>解题的大致思路为：</strong></span></p> 
<pre><code class="language-java">import java.util.Stack;

public class PostfixEvaluation {
    public static int evaluate(String expression) {
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); // 创建一个栈用于存储操作数

        // 遍历后缀表达式中的每个字符
        for (char c : expression.toCharArray()) {
            if (Character.isDigit(c)) {
                // 如果是数字，将其压入栈中
                stack.push(c - '0');
            } else {
                // 如果是操作符，从栈中弹出两个操作数
                int b = stack.pop(); // 弹出栈顶元素作为右操作数
                int a = stack.pop(); // 弹出下一个元素作为左操作数
                
                // 根据操作符进行计算，并将结果压入栈中
                switch (c) {
                    case '+':
                        stack.push(a + b);
                        break;
                    case '-':
                        stack.push(a - b);
                        break;
                    case '*':
                        stack.push(a * b);
                        break;
                    case '/':
                        stack.push(a / b);
                        break;
                }
            }
        }
        return stack.pop(); // 返回栈顶元素，即最终结果
    }

    public static void main(String[] args) {
        String expression = "231*+9-"; // 后缀表达式示例
        System.out.println("后缀表达式求值结果: " + evaluate(expression)); // 输出结果
    }
}
</code></pre> 
<p><strong>这样我们就大致的理解了栈的用处了！</strong></p> 
<p></p> 
<h2 id="5.%E6%80%BB%E7%BB%93"><span style="color:#956fe7;">5.总结</span></h2> 
<p>      <strong>  栈是一种基础且重要的数据结构，它的后进先出特性在许多应用场景中发挥了重要作用。在Java中，栈可以通过数组和链表实现，<code>java.util.Stack</code>类也提供了现成的栈实现。</strong></p> 
<p><strong>        通过理解栈的基本概念和常用方法，以及掌握如何使用双向链表自我实现栈，我们可以在实际编程中更加灵活地运用这一数据结构。栈在表达式求值、函数调用、括号匹配、浏览器前进后退和深度优先搜索等方面都有广泛的应用，熟练掌握栈的使用将极大提高我们的编程能力。</strong></p> 
<p></p> 
<hr> 
<p style="text-align:center;"><span style="color:#38d8f0;"><strong>以上就是本篇文章的全部内容了~~~</strong></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/771799358f0e115a3f654d0187ea2765/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">《软件开发因 AIGC 而变：机遇、挑战与开发者的抉择》</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/86ff74b1c7c87dcd29efd385c998dc9b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">你也想做一个Elemen-ui吧！！！——Blueの前端路</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>