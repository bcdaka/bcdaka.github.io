<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【LeetCode力扣】86. 分隔链表 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/7bd8ad1ee77b1db4ae1294c49e84b5ff/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【LeetCode力扣】86. 分隔链表">
  <meta property="og:description" content="目录
1、题目介绍
2、解题思路
2.1、双链表双指针
2.2、代码描述
1、题目介绍 原题链接：86. 分隔链表 - 力扣（LeetCode）
示例 1：
输入：head = [1,4,3,2,5,2], x = 3
输出：[1,2,2,4,3,5]
示例 2：
输入：head = [2,1], x = 2
输出：[1,2]
提示：
链表中节点的数目在范围 [0, 200] 内-100 &lt;= Node.val &lt;= 100-200 &lt;= x &lt;= 200 2、解题思路 根据题意，考虑通过「新建两个链表」实现原链表分割，算法流程为：
新建两个链表 small 和 BigEqu ，分别用于链接小于标志数 x 的结点和大于等于标志数 x 的结点。遍历链表head并依次比较各节点值 head-&gt;val 和 x 的大小，若head-&gt;val &lt; x ,则将head指向的该结点添加到链表 small 最后面。若head-&gt;val &gt;= x，则将head指向的该结点添加到链表BigEqu最后面。遍历完成后，拼接 small 和 BigEqu 链表。最终判断头结点并返回。 2.1、双链表双指针 首先比较head-&gt;val与x，发现此时head-&gt;val小于x，因此放入small链表中，此时small的链头smallH和链尾smallT都指向结点1。head指向下一个结点。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-10-20T12:53:10+08:00">
    <meta property="article:modified_time" content="2023-10-20T12:53:10+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【LeetCode力扣】86. 分隔链表</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d3/6f/6MX7vTmA_o.png"> </p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1%E3%80%81%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><a href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D" rel="nofollow">1、题目介绍</a></p> 
<p id="2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-toc" style="margin-left:0px;"><a href="#2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF" rel="nofollow">2、解题思路</a></p> 
<p id="2.1%E3%80%81%E5%8F%8C%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88-toc" style="margin-left:40px;"><a href="#2.1%E3%80%81%E5%8F%8C%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88" rel="nofollow">2.1、双链表双指针</a></p> 
<p id="2.2%E3%80%81%E4%BB%A3%E7%A0%81%E6%8F%8F%E8%BF%B0-toc" style="margin-left:40px;"><a href="#2.2%E3%80%81%E4%BB%A3%E7%A0%81%E6%8F%8F%E8%BF%B0" rel="nofollow">2.2、代码描述</a></p> 
<p style="text-align:center;"><br><img alt="" src="https://images2.imgbox.com/a3/ee/YRbdb7eh_o.gif"></p> 
<p> </p> 
<h2 id="1%E3%80%81%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D" style="background-color:transparent;">1、题目介绍</h2> 
<p><strong>原题链接：</strong><a href="https://leetcode.cn/problems/partition-list/description/?envType=list&amp;envId=ixRuNo8f" rel="nofollow" title="86. 分隔链表 - 力扣（LeetCode）">86. 分隔链表 - 力扣（LeetCode）</a></p> 
<p><img alt="" height="264" src="https://images2.imgbox.com/76/51/7q5whhmw_o.png" width="1016"></p> 
<p> <strong>示例 1：</strong></p> 
<p class="img-center"><img alt="" height="222" src="https://images2.imgbox.com/18/24/cyIFO6Xn_o.png" width="662"></p> 
<blockquote> 
 <p><strong>输入：</strong>head = [1,4,3,2,5,2], x = 3</p> 
 <p><strong>输出：</strong>[1,2,2,4,3,5]</p> 
</blockquote> 
<p> <strong>示例 2：</strong></p> 
<blockquote> 
 <p><strong>输入：</strong>head = [2,1], x = 2</p> 
 <p><strong>输出：</strong>[1,2]</p> 
</blockquote> 
<p> <strong>提示：</strong></p> 
<blockquote> 
 <ul><li>链表中节点的数目在范围 [0, 200] 内</li><li>-100 &lt;= Node.val &lt;= 100</li><li>-200 &lt;= x &lt;= 200</li></ul> 
</blockquote> 
<h2 id="2%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF">2、解题思路</h2> 
<blockquote> 
 <p>根据题意，考虑通过「新建两个链表」实现原链表分割，算法流程为：</p> 
 <ol><li>新建两个链表<span style="background-color:#fbd4d0;"> </span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">small </span></span>和<span style="background-color:#fbd4d0;"> </span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">BigEqu </span></span>，分别用于链接小于标志数<span style="background-color:#fbd4d0;"> </span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">x</span></span><span style="background-color:#fbd4d0;"> </span>的结点和大于等于标志数<span style="color:#fe2c24;"><span style="background-color:#fbd4d0;"> x </span></span>的结点。</li><li>遍历链表head并依次比较各节点值<span style="color:#fe2c24;"><span style="background-color:#fbd4d0;"> head-&gt;val </span></span>和<span style="color:#fe2c24;"><span style="background-color:#fbd4d0;"> x </span></span>的大小，若<span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">head-&gt;val &lt; x </span></span>,则将head指向的该结点添加到链表<span style="color:#fe2c24;"><span style="background-color:#fbd4d0;"> small </span></span>最后面。若<span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">head-&gt;val &gt;= x</span></span>，则将head指向的该结点添加到链表<span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">BigEqu</span></span>最后面。</li><li>遍历完成后，拼接<span style="background-color:#fbd4d0;"> </span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">small </span></span>和<span style="background-color:#fbd4d0;"> </span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">BigEqu </span></span>链表。</li><li>最终判断头结点并返回。</li></ol> 
</blockquote> 
<p class="img-center"><img alt="" height="342" src="https://images2.imgbox.com/3d/cf/gMXDXgQU_o.png" width="533"></p> 
<h3 id="2.1%E3%80%81%E5%8F%8C%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88">2.1、双链表双指针</h3> 
<blockquote> 
 <p>首先比较head-&gt;val与x，发现此时head-&gt;val小于x，因此放入small链表中，此时small的链头<span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">smallH</span></span>和链尾<span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">smallT</span></span>都指向<span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">结点1</span></span>。head指向下一个结点。</p> 
</blockquote> 
<p class="img-center"><img alt="" height="367" src="https://images2.imgbox.com/4f/05/VxPo01bB_o.png" width="590"></p> 
<blockquote> 
 <p>继续比较head-&gt;val与x，发现此时head-&gt;val大于x，因此放入BigEqu链表中，此时BigEqu的链头<span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">BigEquH</span></span>和链尾<span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">BigEquT</span></span>都指向<span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">结点4</span></span>。head指向下一个结点。</p> 
</blockquote> 
<p class="img-center"><img alt="" height="383" src="https://images2.imgbox.com/87/37/fQo9vige_o.png" width="608"></p> 
<blockquote> 
 <p>继续比较head-&gt;val与x，发现此时head-&gt;val等于x，因此放入BigEqu链表中，此时BigEqu的链尾<span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">BigEquT</span></span>指向<span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">结点3</span></span>。head指向下一个结点。</p> 
</blockquote> 
<p class="img-center"><img alt="" height="447" src="https://images2.imgbox.com/8d/dc/SXcE2L6Z_o.png" width="570"></p> 
<blockquote> 
 <p>继续比较head-&gt;val与x，发现此时head-&gt;va小于x，因此放入small链表中，此时small的链尾<span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">smallT</span></span>指向<span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">结点2</span></span>。head指向下一个结点。</p> 
</blockquote> 
<p class="img-center"><img alt="" height="386" src="https://images2.imgbox.com/d7/54/ajNJ7HD5_o.png" width="514"></p> 
<blockquote> 
 <p>继续比较head-&gt;val与x，发现此时head-&gt;va大于x，因此放入BigEqu链表中，此时BigEqu的链尾<span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">BigEquT</span></span>指向<span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">结点5</span></span>。head指向下一个结点。</p> 
</blockquote> 
<p class="img-center"><img alt="" height="427" src="https://images2.imgbox.com/0d/4a/L5tH7t34_o.png" width="575"></p> 
<blockquote> 
 <p>继续比较head-&gt;val与x，发现此时head-&gt;va小于x，因此放入small链表中，此时small的链尾<span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">smallT</span></span>指向<span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">结点2</span></span>。head指向下一个结点，此时head为null，则停止循环。</p> 
</blockquote> 
<p class="img-center"><img alt="" height="443" src="https://images2.imgbox.com/0e/87/tqgHH7it_o.png" width="550"></p> 
<blockquote> 
 <p>此时以smallH为链头的链表就是<strong>小于标志数 x 的结点集</strong>，以BigEqu为链头的链表就是<strong>大于等于标志数 x 的结点集</strong>，只需要将small链表的链尾smallT的next指向BigEqu链表的链头，最后返回small的<span style="background-color:#fbd4d0;"> </span><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">链头smallT </span></span>即可。</p> 
</blockquote> 
<p class="img-center"><img alt="" height="326" src="https://images2.imgbox.com/c9/ab/6vnoa8q0_o.png" width="790"></p> 
<h3 id="2.2%E3%80%81%E4%BB%A3%E7%A0%81%E6%8F%8F%E8%BF%B0" style="background-color:transparent;">2.2、代码描述</h3> 
<blockquote> 
 <p>循环的过程都比较好理解，就是最后合并链表时需要考虑特殊情况，如果没有小于标志数的结点时，此时返回的链头就不是smallH了，而是BigEqu的链头<span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">BigEquH</span></span>。</p> 
</blockquote> 
<pre><code class="language-cpp">struct ListNode* partition(struct ListNode* head, int x){
    struct ListNode* smallH = NULL; //小于头
    struct ListNode* smallT = NULL; //小于尾
    struct ListNode* BigEquH = NULL; //大于等于头
    struct ListNode* BigEquT = NULL; //大于等于尾
    struct ListNode* next = NULL;
    //小于连一起，大于等于连一起
    while(head)
    {
        next = head-&gt;next;  //用next保存head的next，然后将head-&gt;置为空
        head-&gt;next = NULL; //确保此时的head的next置为空，不然可能会导致死循环报错
        if(head-&gt;val &lt; x)  //小于标志数
        {
            if(smallH == NULL)   //等于NULL表示第一次放入结点，
                                    //此时链头链尾都指向同一个结点
            {
                smallH = smallT = head;  
            }
            else    //small的链尾的next指向head
            {
                smallT-&gt;next = head;
                smallT = head;
            }
        }
        else  //大于等于标志数
        {
            if(BigEquH == NULL)  //同理
            {
                BigEquH = BigEquT = head;
            }
            else
            {
                BigEquT-&gt;next = head;
                BigEquT = head;
            }
        }
        head = next;   //head指向下一个结点
    }

    //判断是否可以尾接头
    if(smallT != NULL)  //当small链尾不为空，即small链表有结点时，
                        //才让small链尾连接BigEqu链头
    {
        smallT-&gt;next = BigEquH;
    }
    
    return smallH == NULL ? BigEquH : smallH;  //当small链表没有结点时，返回链头BigEquH，
                                                //否则返回链头smallH
}</code></pre> 
<p class="img-center"><img alt="" height="265" src="https://images2.imgbox.com/da/f0/Px1j9CGg_o.png" width="829"></p> 
<p>更多【LeetCode刷题】 推荐：</p> 
<p><a class="has-card" href="https://blog.csdn.net/zzzzzhxxx/article/details/133578735" title="【LeetCode力扣】LCR170 使用归并排序的思想解决逆序对问题（详细图解）_Hacynn的博客-CSDN博客"><span class="link-card-box"><span class="link-title">【LeetCode力扣】LCR170 使用归并排序的思想解决逆序对问题（详细图解）_Hacynn的博客-CSDN博客</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/cd/70/YVrEPrVC_o.png" alt="icon-default.png?t=N7T8">https://blog.csdn.net/zzzzzhxxx/article/details/133578735</span></span></a><a class="has-card" href="https://blog.csdn.net/zzzzzhxxx/article/details/133785886" title="【LeetCode力扣】75 快速排序的子过程partition（荷兰国旗问题）-CSDN博客"><span class="link-card-box"><span class="link-title">【LeetCode力扣】75 快速排序的子过程partition（荷兰国旗问题）-CSDN博客</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/5f/2f/DHRwsJzu_o.png" alt="icon-default.png?t=N7T8">https://blog.csdn.net/zzzzzhxxx/article/details/133785886</span></span></a><a class="has-card" href="https://blog.csdn.net/zzzzzhxxx/article/details/133827375" title="【LeetCode力扣】297. 二叉树的序列化与反序列化-CSDN博客"><span class="link-card-box"><span class="link-title">【LeetCode力扣】297. 二叉树的序列化与反序列化-CSDN博客</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/86/d2/2Qo5skcc_o.png" alt="icon-default.png?t=N7T8">https://blog.csdn.net/zzzzzhxxx/article/details/133827375</span></span></a></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/58/ee/IA6ArirR_o.gif"> </p> 
<p style="text-align:center;"><strong><span style="background-color:#a2e043;">如果觉得作者写的不错，求给博主一个大大的点赞支持一下，你们的支持是我更新的最大动力！</span></strong></p> 
<p style="text-align:center;"><strong><span style="background-color:#a2e043;">如果觉得作者写的不错，求给博主一个大大的点赞支持一下，你们的支持是我更新的最大动力！</span></strong></p> 
<p style="text-align:center;"><strong><span style="background-color:#a2e043;">如果觉得作者写的不错，求给博主一个大大的点赞支持一下，你们的支持是我更新的最大动力！</span></strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e1fd225d3c55d5206810bcedc4c4a8f0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【C&#43;&#43;】引用之带你“消除”C语言版数据结构教材的一些困惑（虽然是C&#43;&#43;的内容，但是强烈建议正在学习数据结构的同学点进来看看）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e221542dd8f5e8fbf4f86f7b7d8d07e9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【vue3】踩坑日记，vite与node版本对应（mac环境）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>