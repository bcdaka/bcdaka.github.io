<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ARP概述学习笔记 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/2b890d95cb95c01e0f6c041fda8073a2/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="ARP概述学习笔记">
  <meta property="og:description" content="1.了解数据链路层 数据链路层位于网络层和物理层之间，可以向网络层的IP、IPv6等协议提供服务。数据链路层的PDU（ProtocolDataUnit-协议数据单元）被称为Frame（帧），也可称为数据帧。
以太网（Ethernet）是最常见的数据链路层协议。
以太网通常封装的是MAC：
例如：以太网封装---实验PC1 ping PC2
（1）配置PC1和PC2。
（2）在R1路由器上配置PC1和PC2的网关信息。
（3）右击PC1的Ethernet0/0/1端口，点击“开始抓包”，接着在PC1上去ping PC2，抓取到的报文显示二层的以太网通过封装MAC进行下一步通信的。
但并不是所有的二层封装的是MAC。
例如：二层使用PPP协议通信
实验R1与R2通过配置PPP协议进行ping抓包分析
（1）配置R1和R2，并且在Serial 0/0/0接口上启用ppp协议。
（2）右击R1的Serial0/0/0接口，点击“开始抓包”，弹窗出来选择链路类型PPP，接着点击“确定”，回到R1上去ping R2，抓取到的报文显示二层为PPP协议而不是以太网，因此封装的内容也不是MAC。
2.以太网与MAC地址 2.1以太网的定义 （1）以太网是一种广播式数据链路层协议，支持多点接入。
（2）个人电脑的网络接口遵循的就是以太网标准。
（3）一般情况下，一个广播域对应着一个IP网段。
2.2以太网MAC地址 （1）MAC (Media Access Control)地址在网络中唯一标识一个网卡，每个网卡都需要且会有唯一的一个MAC地址。
（2）MAC用于在一个IP网段内，寻址找到具体的物理设备。
（3）工作在数据链路层的设备。例如以太网交换机，会维护一张MAC地址表，用于指导数据帧转发。
3.地址解析协议（ARP） ARP （Address Resolution Protocol）地址解析协议：
根据已知的IP地址解析获得其对应的MAC地址。
主机A知道主机B的IP地址，但是不知道主机B的MAC地址，如果想要和主机B进行通信，需要知道主机B的MAC地址，前提是主机A和主机B要在同一个网段，如果不在同一个网段的话，主机A就要找网关，请求到网关的MAC就可以了。
4.ARP实验 4.1通过Cisco Packet Tracer实验环境去模拟理解ARP的工作原理 （1）拓扑搭建
（2）配置PC0、PC1、PC2和PC3的网卡信息，设置的IP都在同一个网段内，因此不需要配置网关。
（3）配置完之后，通过PC0访问PC1，检查ping是否联通。
结果ping通了，ARP只有在第一次访问的时候才能产生，一旦得到了对方的MAC地址，它就会缓存在自己的本地ARP缓存表里面。下次要去访问PC1的时候就可以直接在缓存表里面找到PC1的MAC。
查看ARP缓存表可以使用命令arp -a
删除ARP缓存表信息可以使用命令arp -d
（4）通过模拟状态去查看ARP工作过程
接着让PC0访问PC2，PC2和PC0没有进行过通信，PC2的ARP缓存表默认是空的。
在PC0 ping PC2
把鼠标悬停在第一个报文上，可以看到是ICMP的报文
接着把鼠标悬停在第二报文上，可以看到是ARP的报文
Ping包为什么不能直接发出去？在同一网段的PC0和PC2通信，PC0知道PC2的IP地址，但是不知道PC2的MAC，所以需要先发送ARP报文去获得目标的目的MAC。
点击“播放按钮”，PC0会把报文发送到交换机上，到达交换机上，点击“暂停”。
点击交换机上的报文，可以看到这个是ARP的请求包，这个包最大的特点就是广播，它的目的MAC是全F。也就是说，会先发送一个ARP request。
因此，交换机会将这个包进行泛洪处理。点击“播放”，等报文到达PC1、PC2和PC3之后，点击“暂停”。泛洪后，PC1、PC2和PC3得到报文，PC1和PC3得到后会丢弃掉，PC2则会进行响应。
为什么PC2能响应呢？因为这个请求包里面，它指明了要192.168.1.3的MAC，所以不是192.168.1.3的MAC就会被丢弃。
PC2收到ARP请求报文之后，回复一个响应。点击PC2回到交换机的包，可以看到出站PDU详细信息回给PC0它的MAC信息。
PC0收到PC2发送回来的报文，就会缓存PC2的MAC地址。这个时候ping包就组建好了。
这样一来Ping包的二层目的MAC就封装了PC2的MAC，接着就行了ping
在ARP响应之后，就会缓存到对方的MAC
注意：ARP Request 报文是目的MAC为全F的广播报文。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-20T15:17:16+08:00">
    <meta property="article:modified_time" content="2024-07-20T15:17:16+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ARP概述学习笔记</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="margin-left:0px;"><strong>1.</strong><strong>了解数据链路层</strong></h2> 
<p style="margin-left:0;">数据链路层位于网络层和物理层之间，可以向网络层的IP、IPv6等协议提供服务。数据链路层的PDU（ProtocolDataUnit-协议数据单元）被称为Frame（帧），也可称为数据帧。</p> 
<p style="margin-left:0;"><span style="color:#FF0000;">以太网</span>（Ethernet）是最常见的<span style="color:#FF0000;">数据链路层协议</span>。</p> 
<p style="margin-left:0;"><img alt="" height="440" src="https://images2.imgbox.com/b7/25/7ZnAYsDv_o.png" width="1182"></p> 
<p style="margin-left:0;"><span style="color:#FF0000;">以太网通常封装的是MAC：</span></p> 
<p style="margin-left:0;">例如：以太网封装---实验PC1 ping PC2</p> 
<p style="margin-left:0;"><img alt="" height="546" src="https://images2.imgbox.com/63/9b/ty0iau7q_o.png" width="1025"></p> 
<p style="margin-left:0;">（1）配置PC1和PC2。</p> 
<p style="margin-left:0;"><img alt="" height="666" src="https://images2.imgbox.com/37/41/7gOgxIkH_o.png" width="976"></p> 
<p style="margin-left:0;"><img alt="" height="666" src="https://images2.imgbox.com/71/c4/8ix4XdgS_o.png" width="976"></p> 
<p style="margin-left:0;">（2）在R1路由器上配置PC1和PC2的网关信息。</p> 
<p style="margin-left:0;"><img alt="" height="676" src="https://images2.imgbox.com/46/7f/SRDtfjcS_o.png" width="920"></p> 
<p style="margin-left:0;">（3）右击PC1的Ethernet0/0/1端口，点击“开始抓包”，接着在PC1上去ping PC2，抓取到的报文显示二层的以太网通过封装MAC进行下一步通信的。</p> 
<p style="margin-left:0;"><img alt="" height="666" src="https://images2.imgbox.com/fe/3d/1PeiYU4X_o.png" width="976"></p> 
<p style="margin-left:0;"><img alt="" height="511" src="https://images2.imgbox.com/93/15/S0traCVK_o.png" width="1200"></p> 
<p style="margin-left:0;"><span style="color:#FF0000;">但并不是所有的二层封装的是MAC。</span></p> 
<p style="margin-left:0;">例如：二层使用PPP协议通信</p> 
<p style="margin-left:0;">实验R1与R2通过配置PPP协议进行ping抓包分析</p> 
<p style="margin-left:0;"><img alt="" height="472" src="https://images2.imgbox.com/eb/bf/YuzyTDdS_o.png" width="1014"></p> 
<p style="margin-left:0;">（1）配置R1和R2，并且在Serial 0/0/0接口上启用ppp协议。</p> 
<p style="margin-left:0;"><img alt="" height="349" src="https://images2.imgbox.com/e0/b0/vwoBmFWd_o.png" width="845"></p> 
<p style="margin-left:0;"><img alt="" height="324" src="https://images2.imgbox.com/8c/84/eYzcwVBA_o.png" width="826"></p> 
<p style="margin-left:0;"><img alt="" height="461" src="https://images2.imgbox.com/a3/af/RTUKwL7e_o.png" width="816"></p> 
<p style="margin-left:0;"><img alt="" height="464" src="https://images2.imgbox.com/45/90/tTpG0i7Y_o.png" width="814"></p> 
<p style="margin-left:0;">（2）右击R1的Serial0/0/0接口，点击“开始抓包”，弹窗出来选择链路类型PPP，接着点击“确定”，回到R1上去ping R2，抓取到的报文显示二层为PPP协议而不是以太网，因此封装的内容也不是MAC。</p> 
<p style="margin-left:0;"><img alt="" height="585" src="https://images2.imgbox.com/29/7e/LZwsGzEZ_o.png" width="1105"></p> 
<p style="margin-left:0;"><img alt="" height="306" src="https://images2.imgbox.com/f9/42/znzK4pug_o.png" width="804"></p> 
<p><img alt="" height="525" src="https://images2.imgbox.com/90/e8/sufqMMaV_o.png" width="1200"></p> 
<h2 style="margin-left:0px;"><strong>2.</strong><strong>以太网与MAC地址</strong></h2> 
<h3 style="margin-left:0px;">2.1以太网的定义</h3> 
<p style="margin-left:0;">（1）以太网是一种<span style="background-color:#FFFF00;"><span style="color:#FF0000;">广播式</span></span>数据链路层协议，支持<span style="background-color:#FFFF00;"><span style="color:#FF0000;">多点接入</span></span>。</p> 
<p style="margin-left:0;">（2）个人电脑的网络接口遵循的就是以太网标准。</p> 
<p style="margin-left:0;">（3）一般情况下，<span style="background-color:#FFFF00;"><span style="color:#FF0000;">一个广播域对应着一个IP网段</span></span>。</p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="357" src="https://images2.imgbox.com/3d/67/reXu1Jmm_o.png" width="597"></p> 
<p style="margin-left:0;"></p> 
<h3 style="margin-left:0px;">2.2以太网MAC地址</h3> 
<p style="margin-left:0;">（1）MAC (Media Access Control)地址在网络中<span style="background-color:#FFFF00;"><span style="color:#FF0000;">唯一标识一个网卡</span></span>，<span style="background-color:#FFFF00;"><span style="color:#FF0000;">每个网卡都需要且会有唯一的一个MAC地址</span></span>。</p> 
<p style="margin-left:0;">（2）<span style="background-color:#FFFF00;"><span style="color:#FF0000;">MAC</span></span><span style="background-color:#FFFF00;"><span style="color:#FF0000;">用于在一个IP网段内，寻址找到具体的物理设备。</span></span></p> 
<p style="margin-left:0;">（3）工作在数据链路层的设备。例如以太网交换机，会维护一张MAC地址表，用于指导数据帧转发。</p> 
<p style="margin-left:0;"><img alt="" height="337" src="https://images2.imgbox.com/5e/6a/iI7WJrff_o.png" width="706"></p> 
<h2 style="margin-left:0px;"><strong>3.</strong><strong>地址解析协议（ARP）</strong></h2> 
<p style="margin-left:0;">ARP （Address Resolution Protocol）地址解析协议：</p> 
<p style="margin-left:0;"><span style="background-color:#FFFF00;"><span style="color:#FF0000;">根据已知的IP地址解析获得其对应的MAC地址</span></span>。</p> 
<p style="margin-left:0;"><img alt="" height="351" src="https://images2.imgbox.com/45/46/quqrd6To_o.png" width="1200"></p> 
<p style="margin-left:0;">主机A知道主机B的IP地址，但是不知道主机B的MAC地址，如果想要和主机B进行通信，需要知道主机B的MAC地址，前提是主机A和主机B要在同一个网段，如果不在同一个网段的话，主机A就要找网关，请求到网关的MAC就可以了。</p> 
<p style="margin-left:0;"></p> 
<h2 style="margin-left:0px;"><strong>4.ARP</strong><strong>实验</strong></h2> 
<h3 style="margin-left:0px;">4.1通过Cisco Packet Tracer实验环境去模拟理解ARP的工作原理</h3> 
<p style="margin-left:0;">（1）拓扑搭建</p> 
<p style="margin-left:0;"><img alt="" height="601" src="https://images2.imgbox.com/d0/7a/PV6sh5HY_o.png" width="1100"></p> 
<p style="margin-left:0;">（2）配置PC0、PC1、PC2和PC3的网卡信息，设置的IP都在同一个网段内，因此不需要配置网关。</p> 
<p style="margin-left:0;"><img alt="" height="334" src="https://images2.imgbox.com/d4/a6/qR1U1qCH_o.png" width="871"></p> 
<p style="margin-left:0;"><img alt="" height="321" src="https://images2.imgbox.com/23/00/bACFfVIo_o.png" width="871"></p> 
<p style="margin-left:0;"><img alt="" height="321" src="https://images2.imgbox.com/55/24/HTkYFjZ1_o.png" width="865"></p> 
<p style="margin-left:0;"><img alt="" height="321" src="https://images2.imgbox.com/1a/ac/TvFb6WRF_o.png" width="867"></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">（3）配置完之后，通过PC0访问PC1，检查ping是否联通。</p> 
<p style="margin-left:0;"><img alt="" height="280" src="https://images2.imgbox.com/eb/aa/B3vxihnW_o.png" width="801"></p> 
<p style="margin-left:0;">结果ping通了，ARP只有在第一次访问的时候才能产生，一旦得到了对方的MAC地址，它就会缓存在自己的本地ARP缓存表里面。下次要去访问PC1的时候就可以直接在缓存表里面找到PC1的MAC。</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">查看ARP缓存表可以使用命令arp -a</p> 
<p style="margin-left:0;"><img alt="" height="152" src="https://images2.imgbox.com/23/b8/86dQagax_o.png" width="657"></p> 
<p style="margin-left:0;">删除ARP缓存表信息可以使用命令arp -d</p> 
<p style="margin-left:0;"><img alt="" height="207" src="https://images2.imgbox.com/16/58/dryjhmev_o.png" width="670"></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">（4）通过模拟状态去查看ARP工作过程</p> 
<p style="margin-left:0;"><img alt="" height="861" src="https://images2.imgbox.com/1c/52/Mgnl1DbE_o.png" width="959"></p> 
<p style="margin-left:0;">接着让PC0访问PC2，PC2和PC0没有进行过通信，PC2的ARP缓存表默认是空的。</p> 
<p style="margin-left:0;"><img alt="" height="269" src="https://images2.imgbox.com/a6/cb/GFEkJm1M_o.png" width="492"></p> 
<p style="margin-left:0;">在PC0 ping PC2</p> 
<p style="margin-left:0;">把鼠标悬停在第一个报文上，可以看到是ICMP的报文</p> 
<p style="margin-left:0;"><img alt="" height="536" src="https://images2.imgbox.com/96/f4/OTeq6872_o.png" width="834"></p> 
<p style="margin-left:0;">接着把鼠标悬停在第二报文上，可以看到是ARP的报文</p> 
<p style="margin-left:0;"><img alt="" height="512" src="https://images2.imgbox.com/67/29/XH4alQwZ_o.png" width="861"></p> 
<p style="margin-left:0;">Ping包为什么不能直接发出去？在同一网段的PC0和PC2通信，PC0知道PC2的IP地址，但是不知道PC2的MAC，所以需要先发送ARP报文去获得目标的目的MAC。</p> 
<p style="margin-left:0;">点击“播放按钮”，PC0会把报文发送到交换机上，到达交换机上，点击“暂停”。</p> 
<p style="margin-left:0;"><img alt="" height="771" src="https://images2.imgbox.com/fd/f1/Pk0VIW6b_o.png" width="1200"></p> 
<p style="margin-left:0;">点击交换机上的报文，可以看到这个是ARP的请求包，这个包最大的特点就是广播，它的目的MAC是全F。也就是说，会先发送一个ARP request。</p> 
<p style="margin-left:0;"><img alt="" height="674" src="https://images2.imgbox.com/d2/1b/p6TRuBWd_o.png" width="837"></p> 
<p style="margin-left:0;"><img alt="" height="649" src="https://images2.imgbox.com/f1/bf/qLOFl8eL_o.png" width="626"></p> 
<p style="margin-left:0;">因此，交换机会将这个包进行泛洪处理。点击“播放”，等报文到达PC1、PC2和PC3之后，点击“暂停”。泛洪后，PC1、PC2和PC3得到报文，PC1和PC3得到后会丢弃掉，PC2则会进行响应。</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><img alt="" height="730" src="https://images2.imgbox.com/e0/f7/kufnOzPg_o.png" width="994"></p> 
<p style="margin-left:0;">为什么PC2能响应呢？因为这个请求包里面，它指明了要192.168.1.3的MAC，所以不是192.168.1.3的MAC就会被丢弃。</p> 
<p style="margin-left:0;"><img alt="" height="642" src="https://images2.imgbox.com/ae/4b/Qppsjt0l_o.png" width="636"></p> 
<p style="margin-left:0;"><img alt="" height="642" src="https://images2.imgbox.com/8a/62/OgSNC42R_o.png" width="636"></p> 
<p style="margin-left:0;">PC2收到ARP请求报文之后，回复一个响应。点击PC2回到交换机的包，可以看到出站PDU详细信息回给PC0它的MAC信息。</p> 
<p style="margin-left:0;"><img alt="" height="745" src="https://images2.imgbox.com/51/19/fGuLRBFr_o.png" width="934"></p> 
<p style="margin-left:0;"><img alt="" height="642" src="https://images2.imgbox.com/3a/a0/tgUYhS4N_o.png" width="635"></p> 
<p style="margin-left:0;">PC0收到PC2发送回来的报文，就会缓存PC2的MAC地址。这个时候ping包就组建好了。</p> 
<p style="margin-left:0;"><img alt="" height="696" src="https://images2.imgbox.com/bd/8d/xEsBQGqw_o.png" width="890"></p> 
<p style="margin-left:0;"><img alt="" height="570" src="https://images2.imgbox.com/64/a2/nMane7fb_o.png" width="765"></p> 
<p style="margin-left:0;">这样一来Ping包的二层目的MAC就封装了PC2的MAC，接着就行了ping</p> 
<p style="margin-left:0;"><img alt="" height="622" src="https://images2.imgbox.com/54/38/6bJuWa15_o.png" width="632"></p> 
<p style="margin-left:0;"><img alt="" height="622" src="https://images2.imgbox.com/52/4e/BsGE1Kmi_o.png" width="636"></p> 
<p style="margin-left:0;"><img alt="" height="126" src="https://images2.imgbox.com/6e/21/TbSfoIOb_o.png" width="426"></p> 
<p style="margin-left:0;">在ARP响应之后，就会缓存到对方的MAC</p> 
<p style="margin-left:0;"><img alt="" height="571" src="https://images2.imgbox.com/2b/81/ouLpxCvl_o.png" width="671"></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><strong><span style="color:#FF0000;">注意：</span></strong><span style="background-color:#FFFF00;"><span style="color:#FF0000;">ARP Request </span></span><span style="background-color:#FFFF00;"><span style="color:#FF0000;">报文是目的MAC为全F的广播报文</span></span>。</p> 
<p style="margin-left:0;"><span style="background-color:#FFFF00;"><span style="color:#FF0000;">ARP Reply </span></span><span style="background-color:#FFFF00;"><span style="color:#FF0000;">报文是单播</span></span>。</p> 
<h3 style="margin-left:0px;">4.2 eNSP上模拟抓包分析ARP工作</h3> 
<p style="margin-left:0;">PC1访问PC2</p> 
<p style="margin-left:0;">（1）拓扑搭建</p> 
<p style="margin-left:0;"><img alt="" height="601" src="https://images2.imgbox.com/01/56/kvxjwoZM_o.png" width="1021"></p> 
<p style="margin-left:0;">（2）配置PC1、PC2和PC3</p> 
<p style="margin-left:0;"><img alt="" height="394" src="https://images2.imgbox.com/00/91/qhgpvdER_o.png" width="960"></p> 
<p style="margin-left:0;">（3）点击PC1的Ethernet0/0/1接口抓取报文</p> 
<p style="margin-left:0;"><img alt="" height="666" src="https://images2.imgbox.com/9e/a1/YZgF1IEO_o.png" width="976"></p> 
<p style="margin-left:0;">首先ARP会在目的MAC封装一个广播地址，到交换机进行泛洪，找192.168.1.2目的MAC。</p> 
<p style="margin-left:0;"><img alt="" height="794" src="https://images2.imgbox.com/5f/b1/GkPUrbu9_o.png" width="1199"></p> 
<p style="margin-left:0;">找到192.168.1.2的MAC之后，ARP回复一个单播的响应报文，PC1也就知道PC2的目的MAC，之后就可以建立ping联通。</p> 
<p style="margin-left:0;"><img alt="" height="776" src="https://images2.imgbox.com/24/b4/wXR2ZBDc_o.png" width="1200"></p> 
<p style="margin-left:0;"></p> 
<h2 style="margin-left:0px;"><strong>5.ARP</strong><strong>工作原理</strong></h2> 
<h3 style="margin-left:0px;">5.1在发送数据前，设备会先查找ARP缓存表。</h3> 
<p style="margin-left:0;">如果缓存表中存在对方设备的MAC地址，则直接采用该MAC地址来封装帧，然后将帧发送出去。如果缓存表中不存在相应信息，则通过ARP来获取。</p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="332" src="https://images2.imgbox.com/6a/87/jjpp92AR_o.png" width="519"></p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="426" src="https://images2.imgbox.com/8d/23/ih8t5Bx6_o.png" width="251"></p> 
<h3 style="margin-left:0px;">5.2主机1通过发送ARP Request报文来获取主机2的MAC地址。</h3> 
<p style="margin-left:0;"> 由于不知道目的MAC地址，因此ARP Request报文内的目的端MAC地址为0。</p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="402" src="https://images2.imgbox.com/ba/63/6885fA5D_o.png" width="569"></p> 
<p style="margin-left:0;">    </p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="445" src="https://images2.imgbox.com/46/c9/6kJx9UbK_o.png" width="269"></p> 
<h3 style="margin-left:0px;">5.3 ARP Request是广播数据帧，因此交换机收到后，会对该帧执行泛洪操作。</h3> 
<p style="margin-left:0;text-align:center;"><img alt="" height="300" src="https://images2.imgbox.com/15/20/BVwo2EnR_o.png" width="1075"></p> 
<h3 style="margin-left:0px;">5.4所有的主机接收到该ARP Request报文后，都会检 查它的目的端IP地址字段与自身的IP地址是否匹配。</h3> 
<p style="margin-left:0;"> 主机2发现IP地址匹配，则会将ARP报文中的发送 端MAC地址和发送端IP地址信息记录到自己的ARP 缓存表中。</p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="291" src="https://images2.imgbox.com/e3/b4/hSpNqLkz_o.png" width="486"></p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="465" src="https://images2.imgbox.com/f2/df/5NmSEPrT_o.png" width="282"></p> 
<h3 style="margin-left:0px;">5.5主机2通过发送ARP Reply报文来响应主机1的请求。</h3> 
<p style="margin-left:0;"> 此时主机2已知主机1的MAC地址，因此ARP Reply是 单播数据帧。</p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="496" src="https://images2.imgbox.com/35/7f/jTNli5aZ_o.png" width="514"></p> 
<p style="margin-left:0;"></p> 
<h3 style="margin-left:0px;">5.6交换机收到该单播数据帧后，会对该帧执行转发操作。</h3> 
<p style="margin-left:0;text-align:center;"><img alt="" height="259" src="https://images2.imgbox.com/70/24/DFxfk7B7_o.png" width="1047"></p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="420" src="https://images2.imgbox.com/7b/df/bhtxmPVH_o.png" width="234"></p> 
<h3 style="margin-left:0px;">5.7主机1收到ARP Reply以后，会检查ARP报文中目的端IP地址字段是否与自己的IP地址匹配。</h3> 
<p style="margin-left:0;">如果匹配，会将ARP报文中的发送端MAC地址和发送端IP地址信息记录到自己的ARP缓存表中。</p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="296" src="https://images2.imgbox.com/a3/fd/VveiL03W_o.png" width="482"></p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="427" src="https://images2.imgbox.com/77/e2/FAVeA6qa_o.png" width="257"></p> 
<h2 style="margin-left:0px;"><strong>6.</strong><strong>免费ARP</strong></h2> 
<p style="margin-left:0;">设备主动使用自己的IP地址作为目的IP地址发送ARP请求，此种方式称免费ARP。</p> 
<p style="margin-left:0;"><img alt="" height="507" src="https://images2.imgbox.com/ca/c9/uyBKNodb_o.png" width="1097"></p> 
<p style="margin-left:0;">更换主机IP也会产生免费ARP。</p> 
<p style="margin-left:0;">免费IP抓包实验</p> 
<p style="margin-left:0;">在这里我的笔记本是连接WIFi的把原来自动获取的地址改为固定的172.18.157.219，这时候需要打开wireshark,接着把固定的IP地址更改为自动获取变为原来的172.18.157.218，等待抓包一段时间，过滤出arp的报文即可抓取到免费的ARP报文。</p> 
<p style="margin-left:0;"><img alt="" height="671" src="https://images2.imgbox.com/9d/10/Hxz2GEkB_o.png" width="540"></p> 
<p style="margin-left:0;"><img alt="" height="307" src="https://images2.imgbox.com/56/f1/u6CJ73h0_o.png" width="1200"></p> 
<p style="margin-left:0;"><img alt="" height="386" src="https://images2.imgbox.com/84/76/XzpgauLw_o.png" width="1200"></p> 
<p style="margin-left:0;"><img alt="" height="851" src="https://images2.imgbox.com/5f/ab/1r93K0P0_o.png" width="1200"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c70279f442bb72b99d8c029dff394dde/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据结构----栈</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a4f9a56ee8ed528e1c3294bdc92b2dea/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Vue从零到实战</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>