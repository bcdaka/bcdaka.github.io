<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>AES加密的使用笔记（ECB和GCM加密模式-前端） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/dd444c19ccccd9884ddb7426daac82a5/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="AES加密的使用笔记（ECB和GCM加密模式-前端）">
  <meta property="og:description" content="AES加密的官方简介 AES是高级加密标准，在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，目前已经被全世界广泛使用，同时AES已经成为对称密钥加密中最流行的算法之一。AES支持三种长度的密钥：128位，192位，256位。
和后端做加密对接重点关注的点 确认加密方式， key（密钥长度必须为16,24,32位），iv值（用于增加加密算法安全性，使用随机数），工作模式，以及是16进制加密还是Base64的。确认以后可以让后端提供一个他加密后的密文，自己反向写一个解密方法，成功解出，然后再写一个对应的加密方式，将密文交给后端成功解除，即对应。 备注: 关于IV的官方说法， IV是初始化向量（initialization vector）的缩写，是在密码学中用于增强加密算法安全性的一种辅助参数。IV是一个固定长度的输入值，一般要求是随机数或拟随机数，使用随机数产生的初始化向量才能达到语义安全，并让攻击者难以对同一把密钥的密文进行破解。在区块加密中，使用了初始化向量的加密模式被称为区块加密模式。
关于加密模式的介绍很多，这里就不介绍了，主要记录自己用过的两种加密方法，并且附上对应的解密方法。
ECB模式 这里使用crypto-js插件。根据自己的项目情况，使用npm 或yarn等去下载依赖包，
npm下载命令格式 npm install 依赖包名称 yarn下载命令格式 yarn add 依赖包名称 加密方法如下，我的是vue项目
import CryptoJS from &#34;crypto-js/crypto-js&#34;; // 默认的 KEY 与 iv 使用AES-128-CBC加密模式，key需要为16位,key和iv可以相同 //ciphertext 16进制加密，不加此方法就是Base64加密 // AES加密 ：字符串 key 返回base64 export function Encrypt(word, keyStr, ivStr) { const KEY = CryptoJS.enc.Utf8.parse(&#34;密钥&#34;); //密钥 let key = KEY; if (keyStr) { key = CryptoJS.enc.Utf8.parse(keyStr); } let srcs = CryptoJS.enc.Utf8.parse(word); //密文 var encrypted = CryptoJS.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-12-11T16:42:12+08:00">
    <meta property="article:modified_time" content="2023-12-11T16:42:12+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">AES加密的使用笔记（ECB和GCM加密模式-前端）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="AES_0"></a>AES加密的官方简介</h2> 
<p>AES是高级加密标准，在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，目前已经被全世界广泛使用，同时AES已经成为对称密钥加密中最流行的算法之一。AES支持三种长度的密钥：128位，192位，256位。</p> 
<h2><a id="_3"></a>和后端做加密对接重点关注的点</h2> 
<ol><li>确认加密方式， key（密钥长度必须为16,24,32位），iv值（用于增加加密算法安全性，使用随机数），工作模式，以及是16进制加密还是Base64的。</li><li>确认以后可以让后端提供一个他加密后的密文，自己反向写一个解密方法，成功解出，然后再写一个对应的加密方式，将密文交给后端成功解除，即对应。</li></ol> 
<p>备注: 关于IV的官方说法， IV是初始化向量（initialization vector）的缩写，是在密码学中用于增强加密算法安全性的一种辅助参数。IV是一个固定长度的输入值，一般要求是随机数或拟随机数，使用随机数产生的初始化向量才能达到语义安全，并让攻击者难以对同一把密钥的密文进行破解。在区块加密中，使用了初始化向量的加密模式被称为区块加密模式。</p> 
<p>关于加密模式的介绍很多，这里就不介绍了，主要记录自己用过的两种加密方法，并且附上对应的解密方法。</p> 
<h3><a id="ECB_11"></a>ECB模式</h3> 
<p>这里使用crypto-js插件。根据自己的项目情况，使用npm 或yarn等去下载依赖包，</p> 
<h4><a id="npm_13"></a>npm下载命令格式</h4> 
<pre><code>npm install 依赖包名称
</code></pre> 
<h4><a id="yarn_18"></a>yarn下载命令格式</h4> 
<pre><code>yarn add 依赖包名称
</code></pre> 
<p>加密方法如下，我的是vue项目</p> 
<pre><code>import CryptoJS from "crypto-js/crypto-js";

// 默认的 KEY 与 iv 使用AES-128-CBC加密模式，key需要为16位,key和iv可以相同
//ciphertext 16进制加密，不加此方法就是Base64加密


// AES加密 ：字符串 key 返回base64
export function Encrypt(word, keyStr, ivStr) {
 const KEY = CryptoJS.enc.Utf8.parse("密钥");
  //密钥
  let key = KEY;
  if (keyStr) {
    key = CryptoJS.enc.Utf8.parse(keyStr);
  }

  let srcs = CryptoJS.enc.Utf8.parse(word);
  //密文
  var encrypted = CryptoJS.AES.encrypt(srcs, key, {
    mode: CryptoJS.mode.ECB,
    padding: CryptoJS.pad.Pkcs7
  });
  return CryptoJS.enc.Base64.stringify(encrypted.ciphertext);
}
</code></pre> 
<p>解密方法</p> 
<pre><code>export function Decrypt(word, keyStr,ivstr){
   const KEY = CryptoJS.enc.Utf8.parse("密钥");
   var base64  = CryptoJS.enc.Base64.parse(txt.replace(/\s+/g,""));
   var srcs = CryptoJS.enc.Base64.stringify(base64);
        var decryptedData = CryptoJS.AES.decrypt(srcs, KEY, {
         mode: CryptoJS.mode.ECB,
         padding: CryptoJS.pad.Pkcs7
      });
    return  decryptedData.toString(CryptoJS.enc.Utf8);
}
</code></pre> 
<h3><a id="GCM_65"></a>GCM模式</h3> 
<p>使用的是node-forge插件，下载方式和上面说的一样，就不介绍了，如果不确定的可以自行去npm或者yarn官网去搜</p> 
<p>加密算法</p> 
<pre><code>import forge from "node-forge";

const keyStr = "密钥"; //这里我用的是base64所以没有对密钥进行转换，直接赋值，如果是16进制需要转换一下。

export function Encrypt(word) {
  var iv = forge.random.getBytesSync(12); // 生成随机iv 12字节
  var cipher = forge.cipher.createCipher("AES-GCM", keyStr); // 生成AES-GCM模式的cipher对象 并传入密钥
  cipher.start({
    iv: iv
  });
  cipher.update(forge.util.createBuffer(forge.util.encodeUtf8(word)));
  cipher.finish();
  var encrypted = cipher.output;
  var tag = cipher.mode.tag;
  return window.btoa(iv + encrypted.data + tag.data);
}

</code></pre> 
<p>解密</p> 
<pre><code>const   KEY = "密钥"
export function Decrypt(word) {
  datamsg = window.atob(txt)
  const iv = datamsg.slice(0, 12)
  const tag = datamsg.slice(-16)
  const data = datamsg.slice(12, datamsg.length - 16)
  var decipher = forge.cipher.createDecipher('AES-GCM', KEY)
  decipher.start({
    iv: iv,
    tag: tag
  })
  decipher.update(forge.util.createBuffer(data))
  const pass = decipher.finish()
  return  decipher.output.toString()
}
</code></pre> 
<p>另外自己简单写了一个纯JS的加解密小工具，方便自测的时候套用各种加解密方式，代码如下，不是标准答案，需要根据自己的加密方式算法等去进行js部分的替换调整。</p> 
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
	&lt;title&gt;加密小工具&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;textarea name="jiami" rows="10" cols="40" id="content"&gt;&lt;/textarea&gt;
  &lt;br&gt;
  &lt;button onclick="jiami()"&gt;加密&lt;/button&gt;
  &lt;button onclick="jiemi()"&gt;解密&lt;/button&gt;
  &lt;p&gt;结果: &lt;label id='result'&gt;&lt;/label&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;script src="https://cdn.jsdelivr.net/npm/node-forge@1.0.0/dist/forge.min.js"&gt;&lt;/script&gt; //这里换成自己再用的加密方式的cdn，
&lt;script type="text/javascript"&gt;
	function jiami() {
		var txt = document.getElementById('content').value
		var KEY = "密钥"
		// var srcs = CryptoJS.enc.Utf8.parse(txt.replace(/\s+/g,""));
		var iv =  forge.random.getBytesSync(12)  // 生成随机iv 12字节
         var cipher  = forge.cipher.createCipher('AES-GCM', KEY); // 生成AES-GCM模式的cipher对象 并传入密钥
          cipher.start({
           iv: iv
        });
        cipher.update(forge.util.createBuffer(forge.util.encodeUtf8(txt)));
        cipher.finish();
        var encrypted = cipher.output;
        var tag = cipher.mode.tag;
       // return btoa(iv+encrypted.data+tag.data)
       document.getElementById('result').innerHTML = btoa(iv+encrypted.data+tag.data)
	};

	function jiemi(){
		var txt = document.getElementById('content').value
		var KEY = "密钥"
		 datamsg = window.atob(txt)
          const iv = datamsg.slice(0, 12)
          const tag = datamsg.slice(-16)
          const data = datamsg.slice(12, datamsg.length - 16)
          var decipher = forge.cipher.createDecipher('AES-GCM', KEY)
          decipher.start({
           iv: iv,
           tag: tag
       })
        decipher.update(forge.util.createBuffer(data))
        const pass = decipher.finish()
       if (pass) {
         document.getElementById('result').innerHTML =  decipher.output.toString()
        }

	}

&lt;/script&gt;
&lt;/html&gt;
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e927e32d32afe05897a7c069623c1e11/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android : Room 数据库的基本用法 —简单应用_一_入门</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fe3a168850762ed3144de28db20b8538/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">启动zookeeper报Error: JAVA_HOME is not set and java could not be found in PATH错误处理方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>