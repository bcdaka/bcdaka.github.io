<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;进阶:设计模式___适配器模式 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/5ebb6ea71afcbde91854e00120d78d4f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C&#43;&#43;进阶:设计模式___适配器模式">
  <meta property="og:description" content="前言 在C&#43;&#43;的基础语法的学习后,更进一步为应用场景多写代码.其中设计模式是有较大应用空间.
引入 原本在写容器中适配器类有关的帖子,发现适配模式需要先了解,于是试着先写篇和适配器模式相关的帖子
理解什么是适配器类,需要知道什么是适配器模式.适配器模式是设计模式的一种.笔者也准备开这个系列的专题,这里就当首个模式介绍.
从接口说起 接口和实现的关系如图所示 这个图可以看成一切设计模式的起源.各种设计模式都可以从本图中演化出来----当然实际操作起来会远远难于一张图(笔者的思维习惯是概念极简,就好像之前把程序看成只做了两件事:修改数据和映射数据到硬件一样).
接口是一种功能,一个需求;实现类是一种实现,多个实现类是多种实现.就好像变量代表所有能表示的常量.接口和实现的关系类似于变量和常量.接口是&#34;虚&#34;的,实现是&#34;实&#34;的.
举例:有个喝下午茶的需求,有中式下午茶,吃龟苓膏,喝凉茶;有西式下午茶,喝咖啡,吃蛋糕.用接口与实现表达出来.
/*接口与实现*/ #include&lt;iostream&gt; using namespace std; //抽象基类(接口)定义 class Abs_AfternoonTea { public: virtual void	eat() = 0;	//纯虚方法:功能需求 }; //中式下午茶定义 class ChineseTea :public Abs_AfternoonTea{ int room_number;	//餐厅房间号码 public: ChineseTea(int ro) :room_number(ro) {}; void Guiling_paste(){ cout &lt;&lt; &#34;吃龟苓膏&#34; &lt;&lt; endl; } void cold_tea(){cout&lt;&lt; &#34;喝凉茶&#34; &lt;&lt; endl;} //	int getRoomNumber() { return room_number; } void eat() { cout &lt;&lt; &#34;在&#34; &lt;&lt; room_number &lt;&lt; &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-03T22:56:52+08:00">
    <meta property="article:modified_time" content="2024-08-03T22:56:52+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;进阶:设计模式___适配器模式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>前言</h4> 
<p>     <br>          在C++的基础语法的学习后,更进一步为应用场景多写代码.其中设计模式是有较大应用空间.</p> 
<h4>引入</h4> 
<p>        原本在写容器中适配器类有关的帖子,发现适配模式需要先了解,于是试着先写篇和适配器模式相关的帖子</p> 
<p>         理解什么是适配器类,需要知道什么是<em><strong>适配器模式</strong></em>.适配器模式是设计模式的一种.笔者也准备开这个系列的专题,这里就当首个模式介绍.</p> 
<h4>从接口说起</h4> 
<p>        接口和实现的关系如图所示 </p> 
<h5> <img alt="" class="left" height="274" src="https://images2.imgbox.com/e2/6e/6BifAc6X_o.png" width="270"></h5> 
<p>         </p> 
<p>         </p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p>        这个图可以看成一切设计模式的起源.各种设计模式都可以从本图中演化出来----当然实际操作起来会远远难于一张图(笔者的思维习惯是概念极简,就好像之前把程序看成只做了两件事:修改数据和映射数据到硬件一样).</p> 
<p>        <strong>接口是一种功能,一个需求;实现类是一种实现,多个实现类是多种实现</strong>.就好像变量代表所有能表示的常量.接口和实现的关系类似于变量和常量.接口是"虚"的,实现是"实"的.</p> 
<p>        举例:有个喝下午茶的需求,有中式下午茶,吃龟苓膏,喝凉茶;有西式下午茶,喝咖啡,吃蛋糕.用接口与实现表达出来.</p> 
<pre><code class="hljs">/*接口与实现*/
#include&lt;iostream&gt;
using namespace std;

//抽象基类(接口)定义
class Abs_AfternoonTea {
public:
	virtual void	eat() = 0;	//纯虚方法:功能需求
};

//中式下午茶定义
class ChineseTea :public Abs_AfternoonTea{
	int room_number;			//餐厅房间号码
public:
	ChineseTea(int ro) :room_number(ro) {};
	void Guiling_paste(){ cout &lt;&lt; "吃龟苓膏" &lt;&lt; endl; }
	void cold_tea(){cout&lt;&lt; "喝凉茶" &lt;&lt; endl;}
//	int getRoomNumber() { return room_number; }
	void eat() { 
		cout &lt;&lt; "在" &lt;&lt; room_number &lt;&lt; "号房间享用下午茶:" &lt;&lt; endl;
		Guiling_paste();
		cold_tea();
	}
};

//西式下午茶定义
class WestTea :public Abs_AfternoonTea {
	int room_number;			//餐厅房间号码
public:
	WestTea(int ro) :room_number(ro) {};
	void coffee() { cout &lt;&lt; "喝咖啡" &lt;&lt; endl; }
	void cake() { cout &lt;&lt; "吃蛋糕" &lt;&lt; endl; }
	int getRoomNumber() { return room_number; }
	void eat() {
		cout &lt;&lt; "在" &lt;&lt; room_number &lt;&lt; "号房间享用下午茶:" &lt;&lt; endl;
		coffee();
		cake();
	}
};</code></pre> 
<p>        测试代码</p> 
<pre><code class="hljs">int main(void) {
	ChineseTea ct(3);
	Abs_AfternoonTea&amp; aat = ct;
	aat.eat();
}</code></pre> 
<p><strong>----</strong>这种方案的是接口和实现直接对接,没问题</p> 
<p>    回顾:需求:下午茶; 实现1:中式下午茶; 实现2:西式下午茶</p> 
<p>    现在喝下午茶的需求做一点改变:喝凉茶,吃蛋糕;(中式西式各占一个).如果再按"接口-实现"的方式来设计代码架构,就得再设计一个类MixTea,如下所示: </p> 
<pre><code class="hljs">//混合下午茶定义
class MixTea :public Abs_AfternoonTea {
	int room_number;			//餐厅房间号码
public:
	WestTea(int ro) :room_number(ro) {};
	void cold_tea() { cout &lt;&lt; "喝凉茶" &lt;&lt; endl; }
	void cake() { cout &lt;&lt; "吃蛋糕" &lt;&lt; endl; }
	void eat() {
		cout &lt;&lt; "在" &lt;&lt; room_number &lt;&lt; "号房间享用下午茶:" &lt;&lt; endl;
		cold_tea();
		cake();
	}
};</code></pre> 
<p>        测试代码:</p> 
<pre><code class="hljs">int main(void) {
	MixTea mt(3);
	Abs_AfternoonTea&amp; aat = mt;
	aat.eat();
}</code></pre> 
<p>       <u> 问题并没有完全解决</u>,如果下次的需求再改变:喝咖啡,吃龟苓膏.又得再设计一个类,依次类推.</p> 
<p>        所以得出结论:</p> 
<p>                <span style="color:#fe2c24;">接口-实现的直接架构是万能的,但扩展性不好</span></p> 
<p>        为了让接口更好地被实现,需要对现有代码修改.适配器登场.</p> 
<h4>适配器适应方案选择 </h4> 
<p>        适配器思路:接口由适配器实现(适配器类继承接口).<strong>适配器是一个间接类</strong>,具体怎么实现由他所包含的对象来决定. 现在把工作细化,每个工作配一个厨师(龟苓膏,凉茶,咖啡,蛋糕各自由一个厨师来做).下面是为适配器准备的类</p> 
<p>        <strong>接口和适配器类.h</strong></p> 
<pre><code class="hljs">/*适配器以下类定义*/
#include&lt;iostream&gt;
using namespace std;
/*定义厨师类及派生类*/
class Chef {											//厨师类
	string name;
public:
	Chef(const string&amp; na):name(na){}
	string getName() { return name; }					//获得名称
	virtual void make_food() {};						//虚方法,做食物
}; 

class Cake_division :public Chef {						//蛋糕师类
public:
	Cake_division(const string&amp; st) :Chef(st) {}
	void make_cake() { cout &lt;&lt; getName()&lt;&lt;"做蛋糕" &lt;&lt; endl; }
	virtual void make_food(){ make_cake(); }
};

class Barista :public Chef {							//咖啡师类
public:
	Barista(const string&amp; st) :Chef(st) {}
	void make_coffee() { cout &lt;&lt; getName() &lt;&lt; "冲咖啡" &lt;&lt; endl; }
	virtual void make_food() { make_coffee(); }
};

class Guilinggao_master :public Chef {					//龟苓膏师傅类
public:
	Guilinggao_master(const string&amp; st) :Chef(st){}
	void make_Guilinggao() { cout &lt;&lt; getName() &lt;&lt; "做龟苓膏" &lt;&lt; endl; }
	virtual void make_food() { make_Guilinggao(); }
};

class Herbal_tea_master :public Chef {					//凉茶师傅类
public:
	Herbal_tea_master(const string&amp; st) :Chef(st) {}
	void make_Herbal_tea() { cout &lt;&lt; getName() &lt;&lt; "做凉茶" &lt;&lt; endl; }
	virtual void make_food() { make_Herbal_tea(); }
};

/*以下为单组食物适配器定义的类*/
class SingleGroup {										//单组接口
	string name;
public:
	SingleGroup(const string&amp; st):name(st) {}
	virtual void eat() {};
};

class ChineseTeaGroup :public SingleGroup{				//中式下午茶类
	Guilinggao_master&amp; gm;
	Herbal_tea_master&amp; hm;
public:
	ChineseTeaGroup(Guilinggao_master&amp; g, Herbal_tea_master&amp; h, const string&amp; st):gm(g),hm(h), SingleGroup(st){}
	void eat() { gm.make_food(); hm.make_food(); }
};

class WestTeaGroup :public SingleGroup {				//西式下午茶类
	Cake_division&amp; cd;
	Barista&amp; ba;
public:
	WestTeaGroup(Cake_division&amp; c, Barista&amp; b, const string&amp; st):cd(c),ba(b),SingleGroup(st){}
	void eat() { cd.make_food(); ba.make_food(); }
};

/*以下为混合食物适配器定义的类*/
/*不想使用多重继承,用包含把厨师对象拿过来*/
class MixChineseTeaGroup {								//中式下午茶(混合)类
	string name;
public:
	MixChineseTeaGroup(const string&amp; st):name(st){}
	virtual void eat(){}
};

class MixGuilinggao:public MixChineseTeaGroup {			//龟苓膏(混合)类
	Guilinggao_master&amp; gm;
public:
	MixGuilinggao(Guilinggao_master&amp; g,const string&amp; st) :gm(g) ,MixChineseTeaGroup(st){}
	void eat() { gm.make_food();  }
};

class MixHerbal :public MixChineseTeaGroup {			//凉茶(混合)类
	Herbal_tea_master&amp; hm;;
public:
	MixHerbal(Herbal_tea_master&amp; h, const string&amp; st) :hm(h), MixChineseTeaGroup(st) {}
	void eat() { hm.make_food(); }
};

class MixChineseDouble :public MixChineseTeaGroup {		//中式下午茶两个一起类
	Guilinggao_master&amp; gm;
	Herbal_tea_master&amp; hm;
public:
	MixChineseDouble(Guilinggao_master&amp; g, Herbal_tea_master&amp; h, const string&amp; st) :gm(g), hm(h), MixChineseTeaGroup(st) {}
	void eat() { gm.make_food(); hm.make_food(); }
};


class MixWestTeaGruop {									//西式下午茶(混合)总类
	string name;
public:
	MixWestTeaGruop(const string&amp; st) :name(st) {}
	virtual void eat() {}
};

class MixCake :public MixWestTeaGruop {					//蛋糕类(混合)						
	Cake_division&amp; cn;
public:
	MixCake(Cake_division&amp; c, const string&amp; st):cn(c),MixWestTeaGruop(st){}
	void eat() { cn.make_food(); }
};

class MixBarista :public MixWestTeaGruop {				//咖啡类(混合)
	Barista&amp; ba;
public:
	MixBarista(Barista&amp; b, const string&amp; st) :ba(b), MixWestTeaGruop(st) {}
	void eat() { ba.make_food(); }
};

class MixWestDouble :public MixWestTeaGruop {			//西式下午茶两个一起类
	Cake_division&amp; cd;
	Barista&amp; ba;
public:
	MixWestDouble(Cake_division&amp; c, Barista&amp; b, const string&amp; st) :cd(c), ba(b), MixWestTeaGruop(st) {}
	void eat() { cd.make_food(); ba.make_food(); }
};</code></pre> 
<p> <strong>接口和适配器类.cpp</strong></p> 
<pre><code class="hljs">/*适配器及接口定义*/
#include&lt;iostream&gt;
#include&lt;string&gt;
#include"接口和适配器.h"
using namespace std;

//抽象基类(接口)定义
class Abs_AfternoonTea {
public:
	virtual void	eat() = 0;							//纯虚方法:功能需求
};

//单组适配器定义
class SingleGroup_Adapter :public Abs_AfternoonTea {
	SingleGroup&amp; sg;
public:
	SingleGroup_Adapter(SingleGroup&amp; s):sg(s){}
	virtual void eat() { sg.eat(); }
};

//混组适配器定义
class MixGroup_Adapter :public Abs_AfternoonTea {
	MixChineseTeaGroup&amp; mcg;
	MixWestTeaGruop&amp; mwg;
public:
	MixGroup_Adapter(MixChineseTeaGroup&amp; mc, MixWestTeaGruop&amp; mw):mcg(mc),mwg(mw){}
	virtual void eat() { mcg.eat(); mwg.eat(); }
};

//单点适配器定义
class SingleFood_Adapter :public Abs_AfternoonTea {
	Chef&amp; cf;
public:
	SingleFood_Adapter(Chef&amp; c):cf(c){}
	virtual void eat() { cf.make_food(); }
};</code></pre> 
<p>        <strong>测试代码</strong>        </p> 
<pre><code class="hljs">int main(void) {
	/*单吃蛋糕*/
	 Cake_division cd("小张");								//生成蛋糕师对象
//	 Chef&amp; cf = cd;											//厨师对象生成
	 SingleFood_Adapter sfa(cd);							//单点适配器对象生成
	 Abs_AfternoonTea&amp; aat = sfa;							//转向接口
	 aat.eat();
	 cout &lt;&lt; "===============分隔线============" &lt;&lt; endl;

	/*中式下午茶组*/
	 Guilinggao_master xw("小王");
	 Herbal_tea_master xl("小李");
	 ChineseTeaGroup cg(xw, xl,"中式下午茶");
	 SingleGroup&amp; sg = cg;
	 SingleGroup_Adapter sa = SingleGroup_Adapter(cg);		//单组适配器对象生成
	 Abs_AfternoonTea&amp; aat1 = sa;							//转向接口
	 aat1.eat();
	 cout &lt;&lt; "===============分隔线============" &lt;&lt; endl;

	 /*混合下午茶*/
	 MixChineseDouble md(xw, xl,"混合下午茶");
	 MixChineseTeaGroup&amp; mtg = md;
	 MixCake mc(cd, "xiaozhang");
	 MixWestTeaGruop&amp; mg = mc;
	 MixGroup_Adapter ma = MixGroup_Adapter(mtg, mg);		//混合适配器对象生成
	 Abs_AfternoonTea&amp; aat2 = ma;							//转向接口
	 aat2.eat();
}</code></pre> 
<p><strong>================================内容分割线================================ </strong></p> 
<p>         代码有打磨空间,一是能否去掉不相关的属性;二是引入客户指令---测试是自己写的条件,客户指令处理可以加进来</p> 
<p><strong>================================内容分割线================================ </strong></p> 
<h4>代码说明</h4> 
<p>        第一,看见密密麻麻的代码,为了一个小问题增加许多是否值得?</p> 
<p>                代码多,但是表达的意思并不是很多,只是看起来多而已.</p> 
<p>                值得不值得,这个得根据需求来.只要能满足客户需求就是值得的. </p> 
<p>        第二,可以实现哪些功能?</p> 
<p>                1.单个组合:西式下午茶--咖啡和蛋糕套餐  (或)</p> 
<p>                                   中式下午茶--龟苓膏和凉茶套餐</p> 
<p>                2.混合点餐:咖啡,蛋糕,龟苓膏,凉茶任选其二以上(单点不行)</p> 
<p>                3.单点:咖啡,蛋糕,龟苓膏,凉茶任选其一.</p> 
<p>         第三,为什么有感觉重复的类?</p> 
<p>                笔者暂时不会<u>多重继承</u>,也不知道多重继承是否适合.所以定义了多个类.测试可以的</p> 
<h4>关于适配器模式</h4> 
<p>        在接口--实现的过程中,加了适配器一层.适配器的作用简单描述就是<strong>继承接口,包含相关类</strong> </p> 
<p>        此外,<strong>适配器模式容易扩展</strong>.比如在此代码基础上,继续用适配器扩展,加入更多功能,也是很方便的. </p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/eece8476ce98d108dea93ea2606e9114/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python 编程实例1</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fb865e11b6e042f7685839ed08e66be1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">VSCode的介绍和详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>