<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C &#43;&#43;初阶：C&#43;&#43;入门级知识点 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/31266de849ecff0dc36e4c80bd9088d5/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C &#43;&#43;初阶：C&#43;&#43;入门级知识点">
  <meta property="og:description" content="目录
🌞0.前言
🚈1.C&#43;&#43;输入输出
🚈2.缺省参数
🚝2.1全缺省参数
🚝2.2半缺省参数
🚈3.函数重载
🚝3.1参数类型不同
🚝 3.2参数个数不同
🚝3.3参数类型顺序不同 ​编辑🚝 3.4为什么C&#43;&#43;支持，C语言不支持（底层）
🚈4.引用
🚝4.1引用特性
✈️4.1.1引用在定义时必须初始化
✈️4.1.2引用在定义时必须初始化 ✈️4.1.3.引用一旦引用一个实体，再不能引用其他实体
🚝4.2常引用
🚝4.3使用场景
🚝 4.4传引用和传值效率对比
🚝4.5加餐：不同变量的传值传引用经历了一个什么过程
✈️4.5.1传值
✈️4.5.2传引用
🚈5.内联函数
🚝5.1特性：
🚈6.auto
🚝6.1一些注意点
🚈7.for 🚈8.nullptr（空指针）
​编辑
💎9.结束语
🌞0.前言 言C&#43;&#43;之言，聊C&#43;&#43;之识，以C&#43;&#43;会友，共向远方。各位博友的各位你们好啊，这里是持续分享C&#43;&#43;知识的小赵同学，今天要分享的C&#43;&#43;知识是C&#43;&#43;入门知识点，在这一章，小赵将会向大家展开聊聊C&#43;&#43;入门知识点。✊
在上一章，我们算是初步入门了C&#43;&#43;的基础知识，知道了C&#43;&#43;中有命名空间，域等新东西的引入，那么这一章我们继续去学习C&#43;&#43;的一些基础知识。
🚈1.C&#43;&#43;输入输出 任何一门编程语言的最开始，一般都是从HELLO WORLD开始的，象征着这门语言的诞生，而每门语言的输出HELLO WORLD的方式也是不同的，正如C语言的printf(),python的print(),java的System.out.println()，我们C&#43;&#43;也有自己的输出方式就是cout，与之相对应的还有cin输入，这个输入输出和原本的C语言的scanf和printf有什么区别呢？
C&#43;&#43;写HELLO WORLD
在这里我们看到我们的C&#43;&#43;在输出的时候和C语言的输出是有着极大的不同的，不用像之前那样加括号，写这是什么类型便直接可以输出出来。与之相对应的输入也是如此。
C&#43;&#43;的输入输出
它都会在底层为大家展开。但这里我们也要写一下头文件，就和C语言一样，C&#43;&#43;的输入输出是在头文件的#include&lt;iostream&gt;里面的。同时C&#43;&#43;在输出方面引入了新的换行符。
C&#43;&#43;的换行endl
🚈2.缺省参数 相比较C语言，C&#43;&#43;做出的一大创新便是缺省参数的引入，什么叫缺省参数呢？缺省参数这个概念其实在函数中引入的。例如我们之前的函数。
int ADD(int a,int b) { return a &#43; b; } 这里我们要调用的话就必须手动输入两个值给a和b；
而缺省参数是什么，是即使你不输入值，我也可以运行。那这是怎么做到的呢？就是你先给他值。
这个给人的感觉就有点像替补的队员，主队员不再时候，这个时候我们的替补就可以上场了。（除了这个，我一个朋友的比方也很有意思，说这个就是备胎，现在的没有了就用备用的，也是蛮有意思的一个比方）。 缺省参数有两种，一种叫全缺省，一种叫半缺省。
🚝2.1全缺省参数 全缺省参数比较好理解就像我们上面的ADD函数一样每个值都有一个替补，随时准备上场。
int ADD(int a=1,int b=5)//全缺省参数 { return a&#43;b; } int main() { cout&lt;&lt;ADD(3, 5)&lt;&lt;endl;//输出3&#43;5 cout &lt;&lt; ADD(2) &lt;&lt; endl;//输出2&#43;5 cout&lt;&lt;ADD();//输出1&#43;5 } 在这里要注意的是 我们不能省略第一个参数的输入。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-19T12:44:29+08:00">
    <meta property="article:modified_time" content="2024-08-19T12:44:29+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C &#43;&#43;初阶：C&#43;&#43;入门级知识点</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="1080" src="https://images2.imgbox.com/8f/8e/GGANQaUC_o.png" width="1200"><img alt="" height="129" src="https://images2.imgbox.com/55/17/Pl12kjVZ_o.png" width="864"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%F0%9F%8D%BA0.%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%F0%9F%8D%BA0.%E5%89%8D%E8%A8%80" rel="nofollow">🌞0.前言</a></p> 
<p id="1.C%2B%2B%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA-toc" style="margin-left:0px;"><a href="#1.C%2B%2B%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA" rel="nofollow">🚈1.C++输入输出</a></p> 
<p id="2.%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0-toc" style="margin-left:0px;"><a href="#2.%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0" rel="nofollow">🚈2.缺省参数</a></p> 
<p id="2.1%E5%85%A8%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0-toc" style="margin-left:40px;"><a href="#2.1%E5%85%A8%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0" rel="nofollow">🚝2.1全缺省参数</a></p> 
<p id="2.2%E5%8D%8A%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0-toc" style="margin-left:40px;"><a href="#2.2%E5%8D%8A%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0" rel="nofollow">🚝2.2半缺省参数</a></p> 
<p id="3.%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD-toc" style="margin-left:0px;"><a href="#3.%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD" rel="nofollow">🚈3.函数重载</a></p> 
<p id="3.1%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%90%8C-toc" style="margin-left:40px;"><a href="#3.1%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%90%8C" rel="nofollow">🚝3.1参数类型不同</a></p> 
<p id="%C2%A03.2%E5%8F%82%E6%95%B0%E4%B8%AA%E6%95%B0%E4%B8%8D%E5%90%8C-toc" style="margin-left:40px;"><a href="#%C2%A03.2%E5%8F%82%E6%95%B0%E4%B8%AA%E6%95%B0%E4%B8%8D%E5%90%8C" rel="nofollow">🚝 3.2参数个数不同</a></p> 
<p id="3.3%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E9%A1%BA%E5%BA%8F%E4%B8%8D%E5%90%8C%C2%A0-toc" style="margin-left:40px;"><a href="#3.3%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E9%A1%BA%E5%BA%8F%E4%B8%8D%E5%90%8C%C2%A0" rel="nofollow">🚝3.3参数类型顺序不同 </a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%91%C2%A03.4%E4%B8%BA%E4%BB%80%E4%B9%88C%2B%2B%E6%94%AF%E6%8C%81%EF%BC%8CC%E8%AF%AD%E8%A8%80%E4%B8%8D%E6%94%AF%E6%8C%81%EF%BC%88%E5%BA%95%E5%B1%82%EF%BC%89-toc" style="margin-left:40px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%91%C2%A03.4%E4%B8%BA%E4%BB%80%E4%B9%88C%2B%2B%E6%94%AF%E6%8C%81%EF%BC%8CC%E8%AF%AD%E8%A8%80%E4%B8%8D%E6%94%AF%E6%8C%81%EF%BC%88%E5%BA%95%E5%B1%82%EF%BC%89" rel="nofollow">​编辑🚝 3.4为什么C++支持，C语言不支持（底层）</a></p> 
<p id="4.%E5%BC%95%E7%94%A8-toc" style="margin-left:0px;"><a href="#4.%E5%BC%95%E7%94%A8" rel="nofollow">🚈4.引用</a></p> 
<p id="%C2%A04.1%E5%BC%95%E7%94%A8%E7%89%B9%E6%80%A7-toc" style="margin-left:40px;"><a href="#%C2%A04.1%E5%BC%95%E7%94%A8%E7%89%B9%E6%80%A7" rel="nofollow"> 🚝4.1引用特性</a></p> 
<p id="4.1.1%E5%BC%95%E7%94%A8%E5%9C%A8%E5%AE%9A%E4%B9%89%E6%97%B6%E5%BF%85%E9%A1%BB%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:80px;"><a href="#4.1.1%E5%BC%95%E7%94%A8%E5%9C%A8%E5%AE%9A%E4%B9%89%E6%97%B6%E5%BF%85%E9%A1%BB%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">✈️4.1.1引用在定义时必须初始化</a></p> 
<p id="4.1.2%E5%BC%95%E7%94%A8%E5%9C%A8%E5%AE%9A%E4%B9%89%E6%97%B6%E5%BF%85%E9%A1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%C2%A0-toc" style="margin-left:80px;"><a href="#4.1.2%E5%BC%95%E7%94%A8%E5%9C%A8%E5%AE%9A%E4%B9%89%E6%97%B6%E5%BF%85%E9%A1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%C2%A0" rel="nofollow">✈️4.1.2引用在定义时必须初始化 </a></p> 
<p id="4.1.3.%E5%BC%95%E7%94%A8%E4%B8%80%E6%97%A6%E5%BC%95%E7%94%A8%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BD%93%EF%BC%8C%E5%86%8D%E4%B8%8D%E8%83%BD%E5%BC%95%E7%94%A8%E5%85%B6%E4%BB%96%E5%AE%9E%E4%BD%93-toc" style="margin-left:80px;"><a href="#4.1.3.%E5%BC%95%E7%94%A8%E4%B8%80%E6%97%A6%E5%BC%95%E7%94%A8%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BD%93%EF%BC%8C%E5%86%8D%E4%B8%8D%E8%83%BD%E5%BC%95%E7%94%A8%E5%85%B6%E4%BB%96%E5%AE%9E%E4%BD%93" rel="nofollow">✈️4.1.3.引用一旦引用一个实体，再不能引用其他实体</a></p> 
<p id="4.2%E5%B8%B8%E5%BC%95%E7%94%A8-toc" style="margin-left:40px;"><a href="#4.2%E5%B8%B8%E5%BC%95%E7%94%A8" rel="nofollow">🚝4.2常引用</a></p> 
<p id="4.3%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#4.3%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">🚝4.3使用场景</a></p> 
<p id="%C2%A04.4%E4%BC%A0%E5%BC%95%E7%94%A8%E5%92%8C%E4%BC%A0%E5%80%BC%E6%95%88%E7%8E%87%E5%AF%B9%E6%AF%94-toc" style="margin-left:40px;"><a href="#%C2%A04.4%E4%BC%A0%E5%BC%95%E7%94%A8%E5%92%8C%E4%BC%A0%E5%80%BC%E6%95%88%E7%8E%87%E5%AF%B9%E6%AF%94" rel="nofollow">🚝 4.4传引用和传值效率对比</a></p> 
<p id="4.5%E5%8A%A0%E9%A4%90%EF%BC%9A%E4%B8%8D%E5%90%8C%E5%8F%98%E9%87%8F%E7%9A%84%E4%BC%A0%E5%80%BC%E4%BC%A0%E5%BC%95%E7%94%A8%E7%BB%8F%E5%8E%86%E4%BA%86%E4%B8%80%E4%B8%AA%E4%BB%80%E4%B9%88%E8%BF%87%E7%A8%8B-toc" style="margin-left:40px;"><a href="#4.5%E5%8A%A0%E9%A4%90%EF%BC%9A%E4%B8%8D%E5%90%8C%E5%8F%98%E9%87%8F%E7%9A%84%E4%BC%A0%E5%80%BC%E4%BC%A0%E5%BC%95%E7%94%A8%E7%BB%8F%E5%8E%86%E4%BA%86%E4%B8%80%E4%B8%AA%E4%BB%80%E4%B9%88%E8%BF%87%E7%A8%8B" rel="nofollow">🚝4.5加餐：不同变量的传值传引用经历了一个什么过程</a></p> 
<p id="4.5.1%E4%BC%A0%E5%80%BC-toc" style="margin-left:80px;"><a href="#4.5.1%E4%BC%A0%E5%80%BC" rel="nofollow">✈️4.5.1传值</a></p> 
<p id="4.5.2%E4%BC%A0%E5%BC%95%E7%94%A8-toc" style="margin-left:80px;"><a href="#4.5.2%E4%BC%A0%E5%BC%95%E7%94%A8" rel="nofollow">✈️4.5.2传引用</a></p> 
<p id="5.%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#5.%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0" rel="nofollow">🚈5.内联函数</a></p> 
<p id="%C2%A05.1%E7%89%B9%E6%80%A7%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%C2%A05.1%E7%89%B9%E6%80%A7%EF%BC%9A" rel="nofollow"> 🚝5.1特性：</a></p> 
<p id="6.auto-toc" style="margin-left:0px;"><a href="#6.auto" rel="nofollow">🚈6.auto</a></p> 
<p id="%C2%A06.1%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E7%82%B9-toc" style="margin-left:40px;"><a href="#%C2%A06.1%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E7%82%B9" rel="nofollow">🚝6.1一些注意点</a></p> 
<p id="7.for%C2%A0-toc" style="margin-left:0px;"><a href="#7.for%C2%A0" rel="nofollow">🚈7.for </a></p> 
<p id="%C2%A08.nullptr%EF%BC%88%E7%A9%BA%E6%8C%87%E9%92%88%EF%BC%89-toc" style="margin-left:0px;"><a href="#%C2%A08.nullptr%EF%BC%88%E7%A9%BA%E6%8C%87%E9%92%88%EF%BC%89" rel="nofollow"> 🚈8.nullptr（空指针）</a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%91-toc" style="margin-left:0px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%91" rel="nofollow">​编辑</a></p> 
<p id="%F0%9F%92%8E9.%E7%BB%93%E6%9D%9F%E8%AF%AD-toc" style="margin-left:0px;"><a href="#%F0%9F%92%8E9.%E7%BB%93%E6%9D%9F%E8%AF%AD" rel="nofollow">💎9.结束语</a></p> 
<hr id="hr-toc"> 
<h2>🌞0.前言</h2> 
<p style="text-align:justify;">言C++之言，聊C++之识，以C++会友，共向远方。各位博友的各位你们好啊，这里是持续分享C++知识的小赵同学，今天要分享的C++知识是<strong>C++入门知识点</strong>，在这一章，小赵将会向大家展开聊聊<strong>C++入门知识点</strong>。✊</p> 
<p style="text-align:justify;">在上一章，我们算是初步入门了C++的基础知识，知道了C++中有命名空间，域等新东西的引入，那么这一章我们继续去学习C++的一些基础知识。</p> 
<h2 id="1.C%2B%2B%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><a href="https://blog.csdn.net/zcg3063126760/article/details/139378705?spm=1001.2014.3001.5502#t1" title="🚈">🚈</a>1.C++输入输出</h2> 
<p>任何一门编程语言的最开始，一般都是从HELLO WORLD开始的，象征着这门语言的诞生，而每门语言的输出HELLO WORLD的方式也是不同的，正如C语言的printf(),python的print(),java的System.out.println()，我们<strong><span style="color:#fe2c24;">C++也有自己的输出方式就是cout，与之相对应的还有cin输入</span></strong>，这个输入输出和原本的C语言的scanf和printf有什么区别呢？</p> 
<p style="text-align:center;">C++写HELLO WORLD</p> 
<p><img alt="" height="285" src="https://images2.imgbox.com/88/be/7kn98d2w_o.png" width="631"></p> 
<p>在这里我们看到我们的C++在输出的时候和C语言的输出是有着极大的不同的，不用像之前那样加括号，写这是什么类型便直接可以输出出来。与之相对应的输入也是如此。</p> 
<p style="text-align:center;">C++的输入输出</p> 
<p><img alt="" height="67" src="https://images2.imgbox.com/cb/48/O3T02f2m_o.png" width="334"></p> 
<p>它都会在底层为大家展开。但这里我们也要写一下头文件，就和C语言一样，C++的输入输出是在头文件的#include&lt;iostream&gt;里面的。同时C++在输出方面引入了新的换行符。</p> 
<p style="text-align:center;">C++的换行endl</p> 
<p><img alt="" height="145" src="https://images2.imgbox.com/0a/c7/K1a7YDa6_o.png" width="1000"></p> 
<h2 id="2.%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0"><a href="https://blog.csdn.net/zcg3063126760/article/details/139378705?spm=1001.2014.3001.5502#t1" title="🚈">🚈</a>2.缺省参数</h2> 
<p>相比较C语言，C++做出的一大创新便是缺省参数的引入，什么叫缺省参数呢？缺省参数这个概念其实在函数中引入的。例如我们之前的函数。</p> 
<pre><code class="language-cpp">int ADD(int a,int b)
{
	return a + b;
}</code></pre> 
<p>这里我们要调用的话就必须手动输入两个值给a和b；</p> 
<p> <img alt="" height="322" src="https://images2.imgbox.com/24/ba/0WFYHsHA_o.png" width="523"></p> 
<p>而缺省参数是什么，是即使你不输入值，我也可以运行。那这是怎么做到的呢？就是你先给他值。</p> 
<p><img alt="" height="336" src="https://images2.imgbox.com/77/8e/GbqVHpHr_o.png" width="538"></p> 
<p><span style="color:#4da8ee;"><strong><em>这个给人的感觉就有点像替补的队员，主队员不再时候，这个时候我们的替补就可以上场了。（除了这个，我一个朋友的比方也很有意思，说这个就是备胎，现在的没有了就用备用的，也是蛮有意思的一个比方）。 </em></strong></span></p> 
<p>缺省参数有两种，一种叫全缺省，一种叫半缺省。</p> 
<h3 id="2.1%E5%85%A8%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0" style="background-color:transparent;"><a href="https://blog.csdn.net/zcg3063126760/article/details/139378705?spm=1001.2014.3001.5502#t3" title="🚝">🚝</a>2.1全缺省参数</h3> 
<p>全缺省参数比较好理解就像我们上面的ADD函数一样<strong><span style="color:#fe2c24;">每个值都有一个替补，随时准备上场。</span></strong></p> 
<pre><code class="language-cpp">int ADD(int a=1,int b=5)//全缺省参数
{
	return a+b;
}
int main()
{
	cout&lt;&lt;ADD(3, 5)&lt;&lt;endl;//输出3+5
	cout &lt;&lt; ADD(2) &lt;&lt; endl;//输出2+5
	cout&lt;&lt;ADD();//输出1+5

}</code></pre> 
<p><img alt="" height="403" src="https://images2.imgbox.com/72/09/hDve0JE9_o.png" width="715"></p> 
<p>在这里要注意的是 我们不能省略第一个参数的输入。</p> 
<p><img alt="" height="403" src="https://images2.imgbox.com/d1/3a/QslcoSwx_o.png" width="531"></p> 
<p>这个就像是一种规定，非要说原因，我感觉就是前面加逗号这种写法总感觉怪怪的，你们呢？ </p> 
<h3 id="2.2%E5%8D%8A%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0" style="background-color:transparent;"><a href="https://blog.csdn.net/zcg3063126760/article/details/139378705?spm=1001.2014.3001.5502#t3" title="🚝">🚝</a>2.2半缺省参数</h3> 
<p>半缺省参数的半当然不是大家以为的一半的意思，<em><strong>它意思就是，有缺省参数，但不是全省参数， 所以只要一个缺省参数也可以叫半缺省参数。</strong></em></p> 
<p style="text-align:center;">半缺省参数</p> 
<pre><code class="language-cpp">int ADD(int a,int b=45)
{
	return a + b;
}
int main()
{
	cout &lt;&lt; ADD(3);
}</code></pre> 
<p><img alt="" height="324" src="https://images2.imgbox.com/cb/b2/OBBxkcOm_o.png" width="616"></p> 
<p>这里要注意的一点是我们在使用缺省参数函数时，<span style="color:#fe2c24;">无论是全缺省参数还是半缺省参数函数，给值都要从左向右给，不能跳着给。 （指不能用逗号跳着给值）</span></p> 
<p><img alt="" height="403" src="https://images2.imgbox.com/d1/02/pnpE6YID_o.png" width="531"></p> 
<p><u><em><strong><span style="color:#fe2c24;">所以我们在写缺省参数函数时候，往往都是从右边向左边写。</span></strong></em></u></p> 
<p><img alt="" height="475" src="https://images2.imgbox.com/9f/9d/uPlAOzoi_o.png" width="733"></p> 
<p>从左向右写则会报错，是不被允许的，同时也不能跳着给缺省参数。</p> 
<p><img alt="" height="487" src="https://images2.imgbox.com/fb/fc/J7NFn0fW_o.png" width="643"></p> 
<p>必须从右向左依次给。</p> 
<p><img alt="" height="637" src="https://images2.imgbox.com/aa/61/8k7243Da_o.png" width="705"></p> 
<p>缺省参数还有一个点是我们需要去注意的，就是函数的定义和函数声明不能同时有缺省参数，这里的主要原因可能也是为了防止冲突吧，比如你函数定义中的缺省参数和函数声明中的缺省参数如果给不一样的值，到底该用哪一个呢？ </p> 
<p><img alt="" height="457" src="https://images2.imgbox.com/75/ed/OiPamxVg_o.png" width="694"> 所以当我们的定义和函数分离时在这里一定一定要注意。</p> 
<h2 id="3.%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><a href="https://blog.csdn.net/zcg3063126760/article/details/139378705?spm=1001.2014.3001.5502#t1" title="🚈">🚈</a>3.函数重载</h2> 
<blockquote> 
 <p><strong><span style="color:#956fe7;"><em>函数重载：是函数的一种特殊情况，C++允许在同一作用域中声明几个功能类似的同名函数，这些同名函数的形参列表(参数个数 或 类型 或 类型顺序)不同，常用来处理实现功能类似数据类型 不同的问题。</em></span></strong></p> 
</blockquote> 
<p>根据上面函数重载的定义我们发现，函数重载其实就允许同名函数的诞生，但是中间又有一些小的规则，我们先来看第一种使用方式。</p> 
<h3 id="3.1%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%90%8C" style="background-color:transparent;"><a href="https://blog.csdn.net/zcg3063126760/article/details/139378705?spm=1001.2014.3001.5502#t3" title="🚝">🚝</a>3.1参数类型不同</h3> 
<p>我们在使用自己ADD函数的时候，常常有一个问题就是我们写的ADD函数只能针对某一种类型的相加，遇到别的类型相加就要取别的名字去解决，有木有什么办法可以解决呢？用函数重载就可以完美化解这个问题（后面还有一种化解方法叫模板，有兴趣的可以提前了解下）</p> 
<p style="text-align:center;">我们之前遇到的问题，只能对一种类型使用 </p> 
<p><img alt="" height="297" src="https://images2.imgbox.com/f5/23/Lh9oSBOf_o.png" width="575"></p> 
<p style="text-align:center;">使用函数重载 </p> 
<p style="text-align:center;"><img alt="" height="445" src="https://images2.imgbox.com/4c/94/NC610moT_o.png" width="886"></p> 
<h3 id="%C2%A03.2%E5%8F%82%E6%95%B0%E4%B8%AA%E6%95%B0%E4%B8%8D%E5%90%8C" style="background-color:transparent;"><a href="https://blog.csdn.net/zcg3063126760/article/details/139378705?spm=1001.2014.3001.5502#t3" title="🚝">🚝</a> 3.2参数个数不同</h3> 
<p> 第二种函数重载是函数参数不同进行重载</p> 
<pre><code class="language-cpp">int ADD(int a, int b)//针对两个参数相加
{
	return a + b;
}
int ADD(int a,int b, int c)//针对三个参数相加
{
	return a + b + c;
}
int main()
{
	cout &lt;&lt; ADD(3, 5);//调用两个参数相加
	cout &lt;&lt; ADD(3, 5,3);//调用三个参数相加
}</code></pre> 
<h3 id="3.3%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E9%A1%BA%E5%BA%8F%E4%B8%8D%E5%90%8C%C2%A0" style="background-color:transparent;"><a href="https://blog.csdn.net/zcg3063126760/article/details/139378705?spm=1001.2014.3001.5502#t3" title="🚝">🚝</a>3.3参数类型顺序不同 </h3> 
<p>第三种函数重载是参数类型顺序不同进行重载</p> 
<h3 id="%E2%80%8B%E7%BC%96%E8%BE%91%C2%A03.4%E4%B8%BA%E4%BB%80%E4%B9%88C%2B%2B%E6%94%AF%E6%8C%81%EF%BC%8CC%E8%AF%AD%E8%A8%80%E4%B8%8D%E6%94%AF%E6%8C%81%EF%BC%88%E5%BA%95%E5%B1%82%EF%BC%89" style="background-color:transparent;"><img alt="" height="511" src="https://images2.imgbox.com/82/e1/Pq6MiKqJ_o.png" width="745"><a href="https://blog.csdn.net/zcg3063126760/article/details/139378705?spm=1001.2014.3001.5502#t3" title="🚝">🚝</a> 3.4为什么C++支持，C语言不支持（底层）</h3> 
<p>为什么C++可以支持函数重载而C语言不能支持函数重载这样的操作，这一点其实主要由二者的编译器在对<span style="color:#fe2c24;"><u>函数名字的修饰是不一样的</u></span>。</p> 
<p>我们用gcc（C语言编译器）去编译我们的C语言，看C语言对函数修饰后的名字：</p> 
<p><img alt="" height="145" src="https://images2.imgbox.com/a7/fe/x4NTBvVa_o.png" width="424"></p> 
<p><img alt="" height="321" src="https://images2.imgbox.com/52/e2/0gyZeleh_o.png" width="945"></p> 
<p>我们明显发现它的修饰名字里面是没有里面的参数，只有名字 </p> 
<p>我们再看g++（C++编译器）去编译我们的代码时</p> 
<p><img alt="" height="166" src="https://images2.imgbox.com/55/08/1bddTQ6M_o.png" width="450"></p> 
<p><img alt="" height="304" src="https://images2.imgbox.com/be/88/Ld09hlzB_o.png" width="976"> 我们明显发现多了很多东西，我们看看到底多了什么，再编译一个</p> 
<p><img alt="" height="769" src="https://images2.imgbox.com/94/54/oYJutpPd_o.png" width="1200"></p> 
<p>通过编译我们发现，里面的函数名后面的有极大的可能就是我们的函数中的参数，所以通过这里的底层编译我们就发现了为什么我们的C++支持函数重载的原因了。</p> 
<p><span style="color:#fe2c24;"><em>同时我们也要注意一点：如果两个函数函数名和参数是一样的，返回值不同是不构成重载的，因为调用时编译器没办法区分。</em></span>（这里的原因就是我们编译器里面没有给返回值一个位置，但同时也有合理性，如果支持参数相同返回值不同，那调用的时候到底该调用有返回值的还是没返回值的，又或者返回值不同呢？）</p> 
<p>最后给大家分享：Windows下名字修饰规则可以帮助大家去看我们VS下的函数名字修饰规则（上面没用VS的主要原因也是这个确实不太容易看懂）</p> 
<p><img alt="" height="646" src="https://images2.imgbox.com/08/e3/00FInLw6_o.png" width="1143"></p> 
<p>VS2020编译器下的编译结果 </p> 
<p><img alt="" height="42" src="https://images2.imgbox.com/e1/07/h1GsMAql_o.png" width="715"></p> 
<h2 id="4.%E5%BC%95%E7%94%A8" style="background-color:transparent;"><a href="https://blog.csdn.net/zcg3063126760/article/details/139378705?spm=1001.2014.3001.5502#t1" title="🚈">🚈</a>4.引用</h2> 
<p>引用可以说是C++的一个极大的创新，基本解决了我们之前的指针问题，为什么这么说呢？我们来看看吧。</p> 
<blockquote> 
 <p><strong><span style="color:#956fe7;"><em>引用不是新定义一个变量，而是给已存在变量取了一个别名，编译器不会为引用变量开辟内存空 间，它和它引用的变量共用同一块内存空间。</em></span></strong></p> 
</blockquote> 
<p>关于这个定义，我学C++的好哥们立马就相当了一个相当不错的例子，他说他可以管他的对象叫小虞，也可以管她叫两岁，都是一个人。（好恶毒的狗粮，呜呜呜）这个可以说是一个很形象的例子，就是我给你一个别名，你可以是这个名字，也可以是名字都是你。</p> 
<p>下面看使用：</p> 
<blockquote> 
 <p><strong><span style="color:#956fe7;"><em>使用方法：类型&amp; 引用变量名(对象名) = 引用实体；</em></span></strong></p> 
</blockquote> 
<p> <img alt="" height="280" src="https://images2.imgbox.com/ff/80/V7oemHXS_o.png" width="466"></p> 
<p>如我们这个例子，我们只要对b++，其实就是对a++。</p> 
<h3 id="%C2%A04.1%E5%BC%95%E7%94%A8%E7%89%B9%E6%80%A7" style="background-color:transparent;"> <a href="https://blog.csdn.net/zcg3063126760/article/details/139378705?spm=1001.2014.3001.5502#t3" title="🚝">🚝</a>4.1引用特性</h3> 
<blockquote> 
 <p><strong><span style="color:#956fe7;"><em>引用特性一共有三条</em></span></strong></p> 
 <p><strong><span style="color:#956fe7;"><em>1. 引用在定义时必须初始化</em></span></strong></p> 
 <p><strong><span style="color:#956fe7;"><em>2. 一个变量可以有多个引用</em></span></strong></p> 
 <p><strong><span style="color:#956fe7;"><em>3. 引用一旦引用一个实体，再不能引用其他实体</em></span></strong></p> 
</blockquote> 
<h4 id="4.1.1%E5%BC%95%E7%94%A8%E5%9C%A8%E5%AE%9A%E4%B9%89%E6%97%B6%E5%BF%85%E9%A1%BB%E5%88%9D%E5%A7%8B%E5%8C%96" style="background-color:transparent;"><a href="https://blog.csdn.net/zcg3063126760/article/details/139378705?spm=1001.2014.3001.5502#t8" title="✈️">✈️</a>4.1.1引用在定义时必须初始化</h4> 
<p>引用时候必须初始化，就是告诉编译器你究竟是谁的别名，你总不能谁的别名都不是吧。 </p> 
<p><img alt="" height="267" src="https://images2.imgbox.com/0c/ef/cm2jjXcA_o.png" width="467"></p> 
<h4 id="4.1.2%E5%BC%95%E7%94%A8%E5%9C%A8%E5%AE%9A%E4%B9%89%E6%97%B6%E5%BF%85%E9%A1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%C2%A0"><a href="https://blog.csdn.net/zcg3063126760/article/details/139378705?spm=1001.2014.3001.5502#t8" title="✈️">✈️</a>4.1.2引用在定义时必须初始化 </h4> 
<p>你一个对象可以有多个名字，比如我们上面说的小虞，两岁，也可以再加个别名如小虞同学，多个别名。</p> 
<p> <img alt="" height="138" src="https://images2.imgbox.com/1a/c2/wGpcKVEn_o.png" width="241"></p> 
<h4 id="4.1.3.%E5%BC%95%E7%94%A8%E4%B8%80%E6%97%A6%E5%BC%95%E7%94%A8%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BD%93%EF%BC%8C%E5%86%8D%E4%B8%8D%E8%83%BD%E5%BC%95%E7%94%A8%E5%85%B6%E4%BB%96%E5%AE%9E%E4%BD%93"><a href="https://blog.csdn.net/zcg3063126760/article/details/139378705?spm=1001.2014.3001.5502#t8" title="✈️">✈️</a>4.1.3.引用一旦引用一个实体，再不能引用其他实体</h4> 
<p>你既然已经是这个的别名了，那你就不能再是别人的别名了，不然你使用的时候，到底加在哪个上面呢？</p> 
<p><img alt="" height="355" src="https://images2.imgbox.com/95/cb/mMPOetaI_o.png" width="412"></p> 
<h3 id="4.2%E5%B8%B8%E5%BC%95%E7%94%A8" style="background-color:transparent;"><a href="https://blog.csdn.net/zcg3063126760/article/details/139378705?spm=1001.2014.3001.5502#t3" title="🚝">🚝</a>4.2常引用</h3> 
<p>再开展常引用前，我们先回顾一下常量，<span style="color:#fe2c24;"><em>常量一般指的是不能被修改的值，比如我们的数字10，就是一个常量。我们也可以在一个变量前加个const使它具有常性，让它变成一个常量。</em></span></p> 
<p>为什么要说这个呢？因为我们的引用是不能去引用常量的，因为如果我们用引用去引用一个常量实际上是涉及权限的放大问题的，因为我们的引用其实是可以去改值，它对应的是变量。而如果要引用常量就只能用我们的常引用。</p> 
<pre><code class="language-cpp">int main()
{
	const int a=10;//一个具有常性的变量
	10;//常量
	//int&amp;b=a;会报错因为引用不能作为常引用的别名，不然就是权限的放大
	const int&amp; b = a;
	const int&amp; d = 10;
}</code></pre> 
<h3 id="4.3%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><a href="https://blog.csdn.net/zcg3063126760/article/details/139378705?spm=1001.2014.3001.5502#t3" title="🚝">🚝</a>4.3使用场景</h3> 
<p>那么我们的引用究竟为何说能代替大部分的指针呢？首先我们看一个例子。</p> 
<pre><code class="language-cpp">void swap(int* a, int* b)
{
	int tmp = *a;
	*a = *b;
	*b = tmp;
}</code></pre> 
<p>相信这样一个交换代码大家都写过，最开始也都头疼过这里要用指针。 </p> 
<p>但是如果我们这里用引用就可以很大程度避免这个问题了。</p> 
<p><img alt="" height="508" src="https://images2.imgbox.com/8e/f9/uYcf6ZlW_o.png" width="987"></p> 
<p>这样既可以大大加强我们代码的<span style="color:#fe2c24;">可读性</span>，方便我们理解，也可以让我们摆脱一大部分的指针问题。但是指针的学习一定还是必要的，因为底层和软件开发中很多还是要用到我们的指针的。</p> 
<p>除了大家在穿参的时候可以用引用在我们返回的时候也可以用引用返回；</p> 
<pre><code class="language-cpp">int&amp; Add(int a, int b)
{
    int c = a + b;
    return c;
}

int main()
{
    int&amp; ret = Add(1, 2);
    Add(3, 4);
    cout &lt;&lt; "Add(1, 2) is :"&lt;&lt; ret &lt;&lt;endl;
    return 0;
}</code></pre> 
<p>这里可能就有人看不懂了，为什么返回也可以用引用，因为按照函数栈帧这块空间其实不是被释放了，这里就给大家补充一下知识。</p> 
<p>而这里首先要补充的其实是我们引用的底层一直没和大家说，其实我们的引用底层还是指针，只不过它是对指针的封装，同时引用的别名和被引用的变量其实用的是一块空间，这样就能说明为什么指针如此神奇了。下面我们来解决上面的问题</p> 
<p><img alt="" height="741" src="https://images2.imgbox.com/db/06/XdjBXWWI_o.png" width="1200"> 从这里我们就发现了，就算函数释放了空间但其实那块空间的变量其实没变的，只是我现在没有了钥匙去打开这个空间，而引用就可以说是偷了一把钥匙。但是当我们第二次用这块空间的时候这个变量就会变了，这个我们在前面的指针里面也说过。</p> 
<blockquote> 
 <p>注意：如果函数返回时，出了函数作用域，如果返回对象还在(还没还给系统)，则可以使用 引用返回，如果已经还给系统了（被销毁），则必须使用传值返回。</p> 
</blockquote> 
<h3 id="%C2%A04.4%E4%BC%A0%E5%BC%95%E7%94%A8%E5%92%8C%E4%BC%A0%E5%80%BC%E6%95%88%E7%8E%87%E5%AF%B9%E6%AF%94" style="background-color:transparent;"><a href="https://blog.csdn.net/zcg3063126760/article/details/139378705?spm=1001.2014.3001.5502#t3" title="🚝">🚝</a> 4.4传引用和传值效率对比</h3> 
<p>在函数的时候，我们常常要传参，这时候我们可以试试用我们的传引用。为什么我们要试试传引用呢？相信我们都能猜出来，同样的参数，如果我传值其实是要拷贝一份传入，而传引用则是大家公用一块，哪个效率快一眼就能猜出来。（其实如果传普通的参数int等效率不会特别明显的提升，但如果你传一个二叉树，那就是天差地别了吧。）</p> 
<pre><code class="language-cpp">#include &lt;time.h&gt;

struct A{ int a[10000]; };//传入一个大的结构体

void TestFunc1(A a){}

void TestFunc2(A&amp; a){}

void TestRefAndValue()
{
 A a;
 // 以值作为函数参数

 size_t begin1 = clock();
 for (size_t i = 0; i &lt; 10000; ++i)
 TestFunc1(a);
 size_t end1 = clock();
 // 以引用作为函数参数

 size_t begin2 = clock();
 for (size_t i = 0; i &lt; 10000; ++i)
 TestFunc2(a);
 size_t end2 = clock();
 // 分别计算两个函数运行结束后的时间

 cout &lt;&lt; "TestFunc1(A)-time:" &lt;&lt; end1 - begin1 &lt;&lt; endl;
 cout &lt;&lt; "TestFunc2(A&amp;)-time:" &lt;&lt; end2 - begin2 &lt;&lt; endl;
}</code></pre> 
<p> <img alt="" height="649" src="https://images2.imgbox.com/71/15/jhnj1xgJ_o.png" width="1078"></p> 
<p> 通过代码的测试我们发现传引用是很快的，而传值就很慢。</p> 
<h3>🚝4.5引用和指针的区别</h3> 
<blockquote> 
 <p><strong><span style="color:#956fe7;"><em>在语法概念上引用就是一个别名，没有独立空间，和其引用实体共用同一块空间。</em></span></strong></p> 
 <p><strong><span style="color:#956fe7;"><em>在底层实现上实际是有空间的，因为引用是按照指针方式来实现的。</em></span></strong></p> 
</blockquote> 
<p> 这里为了向大家证明我说的是真的，我也是找到了底层的汇编代码：</p> 
<p><img alt="" height="298" src="https://images2.imgbox.com/63/a9/sVoSnLaS_o.png" width="824"></p> 
<p> 可以说通过汇编代码我们发现引用的底层确实是指针。</p> 
<p>虽然底层是指针但两者还是有一定的区别的：</p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong><em>引用和指针的不同点：</em></strong></span></p> 
 <p><span style="color:#fe2c24;"><strong><em>1. 引用概念上定义一个变量的别名，指针存储一个变量地址。</em></strong></span></p> 
 <p><span style="color:#fe2c24;"><strong><em>2. 引用在定义时必须初始化，指针没有要求</em></strong></span></p> 
 <p><span style="color:#fe2c24;"><strong><em>3. 引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何 一个同类型实体</em></strong></span></p> 
 <p><span style="color:#fe2c24;"><strong><em>4. 没有NULL引用，但有NULL指针</em></strong></span></p> 
 <p><span style="color:#fe2c24;"><strong><em>5. 在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32位平台下占4个字节)</em></strong></span></p> 
 <p><span style="color:#fe2c24;"><strong><em>6. 引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小</em></strong></span></p> 
 <p><span style="color:#fe2c24;"><strong><em>7. 有多级指针，但是没有多级引用</em></strong></span></p> 
 <p><span style="color:#fe2c24;"><strong><em>8. 访问实体方式不同，指针需要显式解引用，引用编译器自己处理</em></strong></span></p> 
 <p><span style="color:#fe2c24;"><strong><em>9. 引用比指针使用起来相对更安全（主要是指针可以自由访问地址）</em></strong></span></p> 
</blockquote> 
<h3 id="4.5%E5%8A%A0%E9%A4%90%EF%BC%9A%E4%B8%8D%E5%90%8C%E5%8F%98%E9%87%8F%E7%9A%84%E4%BC%A0%E5%80%BC%E4%BC%A0%E5%BC%95%E7%94%A8%E7%BB%8F%E5%8E%86%E4%BA%86%E4%B8%80%E4%B8%AA%E4%BB%80%E4%B9%88%E8%BF%87%E7%A8%8B" style="background-color:transparent;"><a href="https://blog.csdn.net/zcg3063126760/article/details/139378705?spm=1001.2014.3001.5502#t3" title="🚝">🚝</a>4.6加餐：不同变量的传值传引用经历了一个什么过程</h3> 
<h4 id="4.5.1%E4%BC%A0%E5%80%BC" style="background-color:transparent;"><a href="https://blog.csdn.net/zcg3063126760/article/details/139378705?spm=1001.2014.3001.5502#t8" title="✈️">✈️</a>4.6.1传值</h4> 
<p>先看这一段代码</p> 
<pre><code class="language-cpp">int a=5;
double b = a;</code></pre> 
<p>在这一段代码中我们把int类型的值赋给了b，但其实这个过程不是直接给给的而是这样：</p> 
<p> <img alt="" height="243" src="https://images2.imgbox.com/5f/c1/rWvtfAmN_o.png" width="296"></p> 
<p>而这里要给大家补充的一点就是临时对象是具有常性的，那么我们下面的引用就要注意了。</p> 
<h4 id="4.5.2%E4%BC%A0%E5%BC%95%E7%94%A8"><a href="https://blog.csdn.net/zcg3063126760/article/details/139378705?spm=1001.2014.3001.5502#t8" title="✈️">✈️</a>4.6.2传引用</h4> 
<p><img alt="" height="217" src="https://images2.imgbox.com/33/14/1g93Dwo7_o.png" width="862"></p> 
<p><img alt="" height="203" src="https://images2.imgbox.com/e8/1a/9yZa6qgp_o.png" width="427"></p> 
<p>这也正印证我们的说法引用的不是int a,而是a创建的double类型的临时对象。</p> 
<h2 id="5.%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0" style="background-color:transparent;"><a href="https://blog.csdn.net/zcg3063126760/article/details/139378705?spm=1001.2014.3001.5502#t1" title="🚈">🚈</a>5.内联函数</h2> 
<p> 内联函数其实是在对我们之前的宏定义的优化，之前我们的宏函数（如#define AREA(i) i*i）有好多好多的坑不知道大家是否还记得，各种替换演变出来各种坑，用着并不是特别好的体验，要加一堆括号。但是内联函数确可以解决宏函数的一些问题。但首先我们先来看一下宏有哪些优缺点。</p> 
<p><img alt="" height="349" src="https://images2.imgbox.com/d9/8b/y2wfJA4i_o.png" width="615"></p> 
<p>小赵想了想感觉 其实还有一点就是宏写函数的总感觉太长了，不太好弄。</p> 
<p>而内联函数则是优化了这些问题，你只需要在函数前面加一个inline就可以让函数转化为内联函数了，那转化成内联有哪些好处呢？首先是在编译阶段不用函数栈帧直接在调用的地方换了，其次也可以进行调试，增加了代码的安全性。</p> 
<p>就如这个原本是这样</p> 
<p><img alt="" height="238" src="https://images2.imgbox.com/b4/d1/ZVh3lue4_o.png" width="382"></p> 
<p>编译之后就可能是这样</p> 
<p><img alt="" height="159" src="https://images2.imgbox.com/02/e4/esphieSZ_o.png" width="187"></p> 
<h3 id="%C2%A05.1%E7%89%B9%E6%80%A7%EF%BC%9A" style="background-color:transparent;"> <a href="https://blog.csdn.net/zcg3063126760/article/details/139378705?spm=1001.2014.3001.5502#t3" title="🚝">🚝</a>5.1特性：</h3> 
<blockquote> 
 <p><strong><span style="color:#956fe7;"><em>1. inline是一种以空间换时间的做法，如果编译器将函数当成内联函数处理，在编译阶段，会 用函数体替换函数调用，缺陷：可能会使目标文件变大，优势：少了调用开销，提高程序运 行效率。</em></span></strong></p> 
 <p><strong><span style="color:#956fe7;"><em>2. inline对于编译器而言只是一个建议，不同编译器关于inline实现机制可能不同，一般建 议：将函数规模较小(即函数不是很长，具体没有准确的说法，取决于编译器内部实现)、不 是递归、且频繁调用的函数采用inline修饰，否则编译器会忽略inline特性。</em></span></strong></p> 
</blockquote> 
<p>这里需要注意的是像很多的递归代码内联函数是不会展开的空间太大。</p> 
<p>下图为 《C++prime》第五版关于inline的建议：</p> 
<p><img alt="" height="223" src="https://images2.imgbox.com/d3/ac/c7zjBYjX_o.png" width="1119"></p> 
<p>其次还要注意的是：inline不建议声明和定义分离，分离会导致链接错误。因为inline被展开，就没有函数地址 了，链接就会找不到。  </p> 
<h2 id="6.auto" style="background-color:transparent;"><a href="https://blog.csdn.net/zcg3063126760/article/details/139378705?spm=1001.2014.3001.5502#t1" title="🚈">🚈</a>6.auto</h2> 
<p>auto其实就是一个万能的类型主要用于接收复杂的返回值后面用，像我们现在接收的返回值大部分都很简单吗，像int并不长但是到了后面这个是很香的。</p> 
<pre><code class="language-cpp">int Add(int a, int b)
{
	return a + b;
}
int main()
{
	auto e = Add(3, 5);
	cout &lt;&lt; e;
}</code></pre> 
<p> <img alt="" height="273" src="https://images2.imgbox.com/c3/c8/yZY8Bu0d_o.png" width="540"></p> 
<p>注意</p> 
<blockquote> 
 <p><strong><span style="color:#956fe7;"><em>使用auto定义变量时必须对其进行初始化，在编译阶段编译器需要根据初始化表达式来推导auto的实际类型。因此auto并非是一种“类型”的声明，而是一个类型声明时的“占位符”，编译器在编 译期会将auto替换为变量实际的类型。</em></span></strong></p> 
</blockquote> 
<p>其实就是以前由我们做得工作交给编译器去推导。 </p> 
<h3 id="%C2%A06.1%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E7%82%B9" style="background-color:transparent;"><a href="https://blog.csdn.net/zcg3063126760/article/details/139378705?spm=1001.2014.3001.5502#t3" title="🚝">🚝</a>6.1一些注意点</h3> 
<p>1.auto可以表示指针类型，但是不能代表引用，引用还是得用auto&amp;(感觉这个也是怕有歧义，到底是传引用还是传值)</p> 
<p>2.不能一行定义多个变量</p> 
<pre><code class="language-cpp">auto c = 3, d = 4.0;  // 该行代码会编译失败，因为c和d的初始化表达式类型不同</code></pre> 
<p>这里的auto只会推导一次而且就就近，那么编译之后就当于int c=3,d=4.0这就会报错。</p> 
<p>3.auto也不能作为函数的参数去用，也不能用去定义数组。</p> 
<pre><code class="language-cpp">// 此处代码编译失败，auto不能作为形参类型，因为编译器无法对a的实际类型进行推导

void TestAuto(auto a)
{}
</code></pre> 
<pre><code class="language-cpp">void TestAuto()
{
    int a[] = {1,2,3};
    auto b[] = {4，5，6};//不允许会报错
}</code></pre> 
<p>其实我们大多数用auto主要是为了去接收一些复杂的类型,这个大家到后面就知道了。 </p> 
<h2 id="7.for%C2%A0" style="background-color:transparent;"><a href="https://blog.csdn.net/zcg3063126760/article/details/139378705?spm=1001.2014.3001.5502#t1" title="🚈">🚈</a>7.for </h2> 
<p>好了最爽的来了，C++11引入了for的全新用法，之前我们要遍历一个数组要这样</p> 
<pre><code class="language-cpp">int array[] = { 1, 2, 3, 4, 5 };
 for (int i = 0; i &lt; sizeof(array) / sizeof(array[0]); ++i)
     cout&lt;&lt;array[i];</code></pre> 
<p>但C++11引入新的用法后：</p> 
<pre><code class="language-cpp">	int array[] = { 1, 2, 3, 4, 5 };
	for (auto e : array)
	{
		cout &lt;&lt; e;
	}</code></pre> 
<p> 就可以遍历这个数组了。</p> 
<p>要改变值得话加个引用就好了。</p> 
<p><img alt="" height="286" src="https://images2.imgbox.com/d9/f5/ySskiuep_o.png" width="700"></p> 
<p> 其实它的底层还是我们第一个代码，一个一个取出来，只是我们对它进行了封装，那么这些活就交给了编译器。</p> 
<h2 id="%C2%A08.nullptr%EF%BC%88%E7%A9%BA%E6%8C%87%E9%92%88%EF%BC%89" style="background-color:transparent;"> <a href="https://blog.csdn.net/zcg3063126760/article/details/139378705?spm=1001.2014.3001.5502#t1" title="🚈">🚈</a>8.nullptr（空指针）</h2> 
<p> 为什么C++要引入新的空指针呢？以前的NULL用着不好吗？</p> 
<p>首先我们看一下C语言的底层对NULL的定义</p> 
<p><img alt="" height="253" src="https://images2.imgbox.com/b6/7d/JXEpQdpL_o.png" width="420"></p> 
<p> 可以看到，NULL可能被定义为字面常量0，或者被定义为无类型指针(void*)的常量。</p> 
<p>这就会导致下面的代码出现问题：</p> 
<pre><code class="language-cpp">void f(int)
{
 cout&lt;&lt;"f(int)"&lt;&lt;endl;
}
void f(int*)
{
 cout&lt;&lt;"f(int*)"&lt;&lt;endl;
}

int main()
{
 f(0);
 f(NULL);
 f((int*)NULL);
 return 0;
}</code></pre> 
<h2 id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="517" src="https://images2.imgbox.com/fb/94/KV3r5P7V_o.png" width="678"></h2> 
<p>这时候我们发现我们的NULL被当成数字0处理了。 </p> 
<p>而程序本意是想通过f(NULL)调用指针版本的f(int*)函数，但是由于NULL被定义成0，因此与程序的 初衷相悖。 在C++98中，字面常量0既可以是一个整形数字，也可以是无类型的指针(void*)常量，但是编译器 默认情况下将其看成是一个整形常量，如果要将其按照指针方式来使用，必须对其进行强转(void *)0。</p> 
<p>所以C++11就引入了新的空指针nullptr,这样就可以化解NULL带来的问题。这里推荐大家使用nullptr防止出现上面的问题等其他问题。同时nullptr的使用是不需要头文件的，它的全新的关键字。</p> 
<h2 id="%F0%9F%92%8E9.%E7%BB%93%E6%9D%9F%E8%AF%AD">💎9.结束语</h2> 
<p>好了小赵今天的分享就到这里了，如果大家有什么不明白的地方可以在小赵的下方留言哦，同时如果小赵的博客中有什么地方不对也希望得到大家的指点，谢谢各位家人们的支持。你们的支持是小赵创作的动力，加油。</p> 
<p><img alt="" height="1080" src="https://images2.imgbox.com/4b/e1/MHLOX42T_o.png" width="1200"></p> 
<p><span style="color:#fe2c24;"><strong>如果觉得文章对你有帮助的话，还请点赞，关注，收藏支持小赵，如有不足还请指点，方便小赵及时改正，感谢大家支持！！！</strong></span></p> 
<p><img alt="" height="1195" src="https://images2.imgbox.com/35/c9/uUs6eW7g_o.gif" width="1195"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5c9ba6948bf3979ae0fad84033703473/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">从【人工智能】到【计算机视觉】，【深度学习】引领的未来科技创新与变革</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2ec8232bd2282ef71d1721ed2be9f856/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">迪杰斯特拉(Dijkstra)算法（C/C&#43;&#43;)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>