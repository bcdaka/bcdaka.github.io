<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;】深度解析：用 C&#43;&#43; 模拟实现 string 类，探索其底层实现细节 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/84496011cbfdd81dbdd835fd85a4b1fb/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;】深度解析：用 C&#43;&#43; 模拟实现 string 类，探索其底层实现细节">
  <meta property="og:description" content="目录
了解string类
string的内存管理
VS下string的结构
​g&#43;&#43;下string的结构
string的模拟实现
string的构造函数
浅拷贝
深拷贝
string的遍历
重载 [] 下标访问
迭代器访问
reserve
resize
增删查改
push_back()
append和&#43;=
insert和erase
find
substr
swap 流插入和流提取
getline
string其他基本功能
⭐了解string类 1. 字符串是表示字符序列的类 2. 标准的字符串类提供了对此类对象的支持，其接口类似于标准字符容器的接口，但添加了专门用于操作单字节字符字符串的设计特性。 3. string 类是使用 char( 即作为它的字符类型，使用它的默认 char_traits 和分配器类型 ( 关于模板的更多信息，请参阅basic_string) 。 4. string 类是 basic_string 模板类的一个实例，它使用 char 来实例化 basic_string 模板类，并用 char_traits和allocator 作为 basic_string 的默认参数 ( 根于更多的模板信息请参考 basic_string) 。 5. 注意，这个类独立于所使用的编码来处理字节 : 如果用来处理多字节或变长字符 ( 如 UTF-8) 的序列，这个类的所有成员( 如长度或大小 ) 以及它的迭代器，将仍然按照字节 ( 而不是实际编码的字符 ) 来操作。 总结： 1.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-16T19:34:25+08:00">
    <meta property="article:modified_time" content="2024-05-16T19:34:25+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;】深度解析：用 C&#43;&#43; 模拟实现 string 类，探索其底层实现细节</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><img alt="" src="https://images2.imgbox.com/ed/fc/T2mf93bv_o.png"></h2> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%BA%86%E8%A7%A3string%E7%B1%BB-toc" style="margin-left:0px;"><a href="#%E4%BA%86%E8%A7%A3string%E7%B1%BB" rel="nofollow">了解string类</a></p> 
<p id="string%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-toc" style="margin-left:0px;"><a href="#string%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86" rel="nofollow">string的内存管理</a></p> 
<p id="VS%E4%B8%8Bstring%E7%9A%84%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#VS%E4%B8%8Bstring%E7%9A%84%E7%BB%93%E6%9E%84" rel="nofollow">VS下string的结构</a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%91g%2B%2B%E4%B8%8Bstring%E7%9A%84%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%91g%2B%2B%E4%B8%8Bstring%E7%9A%84%E7%BB%93%E6%9E%84" rel="nofollow">​g++下string的结构</a></p> 
<p id="%C2%A0string%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%C2%A0string%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" rel="nofollow"> string的模拟实现</a></p> 
<p id="string%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#string%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" rel="nofollow">string的构造函数</a></p> 
<p id="%C2%A0%E6%B5%85%E6%8B%B7%E8%B4%9D-toc" style="margin-left:80px;"><a href="#%C2%A0%E6%B5%85%E6%8B%B7%E8%B4%9D" rel="nofollow"> 浅拷贝</a></p> 
<p id="%E6%B7%B1%E6%8B%B7%E8%B4%9D-toc" style="margin-left:80px;"><a href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D" rel="nofollow">深拷贝</a></p> 
<p id="%C2%A0string%E7%9A%84%E9%81%8D%E5%8E%86-toc" style="margin-left:40px;"><a href="#%C2%A0string%E7%9A%84%E9%81%8D%E5%8E%86" rel="nofollow"> string的遍历</a></p> 
<p id="%E9%87%8D%E8%BD%BD%20%5B%5D%20%E4%B8%8B%E6%A0%87%E8%AE%BF%E9%97%AE-toc" style="margin-left:80px;"><a href="#%E9%87%8D%E8%BD%BD%20%5B%5D%20%E4%B8%8B%E6%A0%87%E8%AE%BF%E9%97%AE" rel="nofollow">重载 [] 下标访问</a></p> 
<p id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BF%E9%97%AE-toc" style="margin-left:80px;"><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BF%E9%97%AE" rel="nofollow">迭代器访问</a></p> 
<p id="reserve-toc" style="margin-left:40px;"><a href="#reserve" rel="nofollow">reserve</a></p> 
<p id="resize-toc" style="margin-left:40px;"><a href="#resize" rel="nofollow">resize</a></p> 
<p id="%C2%A0%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9-toc" style="margin-left:40px;"><a href="#%C2%A0%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9" rel="nofollow"> 增删查改</a></p> 
<p id="push_back()-toc" style="margin-left:80px;"><a href="#push_back%28%29" rel="nofollow">push_back()</a></p> 
<p id="append%E5%92%8C%2B%3D-toc" style="margin-left:80px;"><a href="#append%E5%92%8C%2B%3D" rel="nofollow">append和+=</a></p> 
<p id="%C2%A0insert%E5%92%8Cerase-toc" style="margin-left:80px;"><a href="#%C2%A0insert%E5%92%8Cerase" rel="nofollow"> insert和erase</a></p> 
<p id="find-toc" style="margin-left:80px;"><a href="#find" rel="nofollow">find</a></p> 
<p id="substr-toc" style="margin-left:80px;"><a href="#substr" rel="nofollow">substr</a></p> 
<p id="swap%C2%A0-toc" style="margin-left:40px;"><a href="#swap%C2%A0" rel="nofollow">swap </a></p> 
<p id="%C2%A0%E6%B5%81%E6%8F%92%E5%85%A5%E5%92%8C%E6%B5%81%E6%8F%90%E5%8F%96-toc" style="margin-left:40px;"><a href="#%C2%A0%E6%B5%81%E6%8F%92%E5%85%A5%E5%92%8C%E6%B5%81%E6%8F%90%E5%8F%96" rel="nofollow"> 流插入和流提取</a></p> 
<p id="getline-toc" style="margin-left:40px;"><a href="#getline" rel="nofollow">getline</a></p> 
<p id="string%E5%85%B6%E4%BB%96%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD-toc" style="margin-left:40px;"><a href="#string%E5%85%B6%E4%BB%96%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD" rel="nofollow">string其他基本功能</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E2%80%8B%E7%BC%96%E8%BE%91" style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f6/70/KnUnX5yf_o.gif"></h2> 
<h2 id="%E4%BA%86%E8%A7%A3string%E7%B1%BB">⭐了解string类</h2> 
<div> 
 <span style="color:#777777;">1. </span> 
 <span style="color:#777777;">字符串是表示字符序列的类 </span> 
</div> 
<div> 
 <span style="color:#777777;">2. </span> 
 <span style="color:#777777;">标准的字符串类提供了对此类对象的支持，其接口类似于标准字符容器的接口，但添加了专门用于操作单字节字符字符串的设计特性。 </span> 
</div> 
<div> 
 <span style="color:#777777;">3. string</span> 
 <span style="color:#777777;">类是使用</span> 
 <span style="color:#777777;">char(</span> 
 <span style="color:#777777;">即作为它的字符类型，使用它的默认</span> 
 <span style="color:#777777;">char_traits</span> 
 <span style="color:#777777;">和分配器类型</span> 
 <span style="color:#777777;">(</span> 
 <span style="color:#777777;">关于模板的更多信息，请参阅basic_string)</span> 
 <span style="color:#777777;">。 </span> 
</div> 
<div> 
 <span style="color:#777777;">4. string</span> 
 <span style="color:#777777;">类是</span> 
 <span style="color:#777777;">basic_string</span> 
 <span style="color:#777777;">模板类的一个实例，它使用</span> 
 <span style="color:#777777;">char</span> 
 <span style="color:#777777;">来实例化</span> 
 <span style="color:#777777;">basic_string</span> 
 <span style="color:#777777;">模板类，并用</span> 
 <span style="color:#777777;">char_traits和allocator</span> 
 <span style="color:#777777;">作为</span> 
 <span style="color:#777777;">basic_string</span> 
 <span style="color:#777777;">的默认参数</span> 
 <span style="color:#777777;">(</span> 
 <span style="color:#777777;">根于更多的模板信息请参考</span> 
 <span style="color:#777777;">basic_string)</span> 
 <span style="color:#777777;">。 </span> 
</div> 
<div> 
 <span style="color:#777777;">5. </span> 
 <span style="color:#777777;">注意，这个类独立于所使用的编码来处理字节</span> 
 <span style="color:#777777;">:</span> 
 <span style="color:#777777;">如果用来处理多字节或变长字符</span> 
 <span style="color:#777777;">(</span> 
 <span style="color:#777777;">如</span> 
 <span style="color:#777777;">UTF-8)</span> 
 <span style="color:#777777;">的序列，这个类的所有成员(</span> 
 <span style="color:#777777;">如长度或大小</span> 
 <span style="color:#777777;">)</span> 
 <span style="color:#777777;">以及它的迭代器，将仍然按照字节</span> 
 <span style="color:#777777;">(</span> 
 <span style="color:#777777;">而不是实际编码的字符</span> 
 <span style="color:#777777;">)</span> 
 <span style="color:#777777;">来操作。 </span> 
</div> 
<div> 
 <span style="color:#777777;">总结： </span> 
</div> 
<div> 
 <span style="color:#777777;">1. string</span> 
 <span style="color:#777777;">是表示字符串的字符串类 </span> 
</div> 
<div> 
 <span style="color:#777777;">2. </span> 
 <span style="color:#777777;">该类的接口与常规容器的接口基本相同，再添加了一些专门用来操作</span> 
 <span style="color:#777777;">string</span> 
 <span style="color:#777777;">的常规操作。</span> 
</div> 
<div> 
 <div> 
  <span style="color:#777777;">3. string</span> 
  <span style="color:#777777;">在底层实际是：</span> 
  <span style="color:#777777;">basic_string</span> 
  <span style="color:#777777;">模板类的别名，</span> 
  <span style="color:#777777;">typedef basic_string&lt;char, char_traits, allocator&gt; </span> 
 </div> 
 <div> 
  <span style="color:#777777;">string; </span> 
 </div> 
 <div> 
  <span style="color:#777777;">4. </span> 
  <span style="color:#777777;">不能操作多字节或者变长字符的序列。 </span> 
 </div> 
 <div> 
  <span style="color:#777777;">在</span> 
  <span style="color:#777777;"><strong>使用</strong></span> 
  <span style="color:#777777;"><strong>string</strong></span> 
  <span style="color:#777777;"><strong>类时，必须包含</strong></span> 
  <span style="color:#777777;"><strong>#include</strong></span> 
  <span style="color:#777777;"><strong>头文件以及</strong></span> 
  <span style="color:#777777;"><strong>using namespace std</strong></span> 
  <span style="color:#777777;">;</span> 
 </div> 
 <div></div> 
 <h2 id="string%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">⭐string的内存管理</h2> 
 <h3 id="VS%E4%B8%8Bstring%E7%9A%84%E7%BB%93%E6%9E%84">✨VS下string的结构</h3> 
 <div> 
  <span style="color:#fe2c24;"><strong><span style="background-color:#f3f3f4;">string总共占28个字节</span></strong></span> 
  <span style="color:#777777;">，内部结构稍微复杂一点，先是</span> 
  <span style="color:#777777;"><strong>有一个联合体，联合体用来定义</strong></span> 
  <span style="color:#777777;"><strong>string</strong></span> 
  <span style="color:#777777;"><strong>中字 </strong></span> 
 </div> 
 <div> 
  <span style="color:#777777;"><strong>符串的存储空间</strong></span> 
  <span style="color:#777777;">： </span> 
 </div> 
 <ul><li><span style="color:#777777;"><strong>当字符串长度小于</strong></span><span style="color:#777777;"><strong>16</strong></span><span style="color:#777777;"><strong>时，使用内部固定的字符数组来存放 </strong></span></li><li><span style="color:#777777;"><strong>当字符串长度大于等于</strong></span><span style="color:#777777;"><strong>16</strong></span><span style="color:#777777;"><strong>时，从堆上开辟空间</strong></span></li></ul> 
 <pre><code class="language-cpp">union _Bxty
{ // storage for small buffer or pointer to larger one
 value_type _Buf[_BUF_SIZE];
 pointer _Ptr;
 char _Alias[_BUF_SIZE]; // to permit aliasing
} _Bx;</code></pre> 
 <blockquote> 
  <ol><li><span style="color:#777777;">大多数情况下字符串的长度都小于</span><span style="color:#777777;">16，当</span><span style="color:#777777;">string</span><span style="color:#777777;">对象创建好之后，内部已经有了16</span><span style="color:#777777;">个字符数组的固定空间，不需要通过堆创建，效率高。 </span></li><li><span style="color:#777777;">还有</span><span style="color:#777777;"><strong>一个</strong></span><span style="color:#777777;"><strong>size_t</strong></span><span style="color:#777777;"><strong>字段保存字符串长度，一个</strong></span><span style="color:#777777;"><strong>size_t</strong></span><span style="color:#777777;"><strong>字段保存从堆上开辟空间总的容量 </strong></span></li><li><span style="color:#777777;">还</span><span style="color:#777777;"><strong>有一个指针</strong></span><span style="color:#777777;">做一些其他事情。 </span></li><li><span style="color:#777777;">故总共占</span><span style="color:#777777;">16+4+4+4=28</span><span style="color:#777777;">个字节。 </span></li></ol> 
 </blockquote> 
</div> 
<h3 id="%E2%80%8B%E7%BC%96%E8%BE%91g%2B%2B%E4%B8%8Bstring%E7%9A%84%E7%BB%93%E6%9E%84"><img alt="" height="596" src="https://images2.imgbox.com/16/96/g1EYVoGO_o.png" width="1200">✨g++下string的结构</h3> 
<div> 
 <span style="color:#777777;">g++</span> 
 <span style="color:#777777;">下，</span> 
 <span style="color:#777777;">string</span> 
 <span style="color:#777777;">是通过写时拷贝实现的，</span> 
 <span style="color:#fe2c24;"><strong><span style="background-color:#cccccc;">string对象总共占4个字节</span></strong></span> 
 <span style="color:#777777;">，内部只包含了一个指针，该指 </span> 
</div> 
<div> 
 <span style="color:#777777;">针将来指向一块堆空间，内部包含了如下字段： </span> 
</div> 
<ul><li><span style="color:#777777;">空间总大小 </span></li><li><span style="color:#777777;">字符串有效长度 </span></li><li><span style="color:#777777;">引用计数 </span></li><li><span style="color:#777777;">指向堆空间的指针，用来存储字符串。</span></li></ul> 
<pre><code class="language-cpp">struct _Rep_base
{
 size_type _M_length;
 size_type _M_capacity;
 _Atomic_word _M_refcount;
};</code></pre> 
<h2 id="%C2%A0string%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0"> ⭐string的模拟实现</h2> 
<pre><code class="language-cpp">private:
		char* _str = nullptr;
		size_t _size = 0;
		size_t _capacity = 0;</code></pre> 
<h3 id="string%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">✨string的构造函数</h3> 
<pre><code class="language-cpp">// 为了和标准库区分，此处使用String
class String
{
public:

 /*String()
 :_str(new char[1])
 {*_str = '\0';}
 */
 //String(const char* str = "\0") 错误示范
 //String(const char* str = nullptr) 错误示范
 String(const char* str = "")//默认包含 \0
 {
 // 构造String类对象时，如果传递nullptr指针，可以认为程序非法
 if (nullptr == str)
 {
 assert(false);
 return;
 }
 _str = new char[strlen(str) + 1];
 strcpy(_str, str);
 }
 ~String()
 {
 if (_str)
 {
 delete[] _str;
 _str = nullptr;
 }
 }
private:
 char* _str;
};
// 测试
void TestString()
{
 String s1("hello bit!!!");
 String s2(s1);
}</code></pre> 
<p> <img alt="" height="493" src="https://images2.imgbox.com/64/ee/0tPtjI1k_o.png" width="1147"></p> 
<div> 
 <span style="color:#777777;">上述</span> 
 <span style="color:#777777;"><strong>String</strong></span> 
 <span style="color:#777777;"><strong>类没有显式定义其拷贝构造函数与赋值运算符重载，此时编译器会合成默认的，当用</strong></span> 
 <span style="color:#777777;"><strong>s1</strong></span> 
 <span style="color:#777777;"><strong>构</strong></span> 
 <span style="color:#777777;"><strong>造</strong></span> 
 <span style="color:#777777;"><strong>s2</strong></span> 
 <span style="color:#777777;"><strong>时，编译器会调用默认的拷贝构造。最终导致的问题是，</strong></span> 
 <span style="color:#777777;"><strong>s1</strong></span> 
 <span style="color:#777777;"><strong>、</strong></span> 
 <span style="color:#777777;"><strong>s2</strong></span> 
 <span style="color:#777777;"><strong>共用同一块内存空间，在释放时同一块</strong></span> 
 <span style="color:#777777;"><strong>空间被释放多次而引起程序崩溃</strong></span> 
 <span style="color:#777777;">，这种拷贝方式，称为</span> 
 <span style="color:#38d8f0;"><span style="background-color:#f3f3f4;">浅拷贝</span></span> 
 <span style="color:#777777;">。 </span> 
</div> 
<h4 id="%C2%A0%E6%B5%85%E6%8B%B7%E8%B4%9D"> 📖浅拷贝</h4> 
<blockquote> 
 <div> 
  <span style="color:#777777;"><strong>浅拷贝：也称位拷贝，编译器只是将对象中的值拷贝过来</strong></span> 
  <span style="color:#777777;">。如果</span> 
  <span style="color:#777777;"><strong>对象中管理资源</strong></span> 
  <span style="color:#777777;">，最后就会</span> 
  <span style="color:#777777;"><strong>导致多个对象共 </strong></span> 
  <span style="color:#777777;"><strong>享同一份资源，当一个对象销毁时就会将该资源释放掉，而此时另一些对象不知道该资源已经被释放，以为 </strong></span> 
  <span style="color:#777777;"><strong>还有效，所以当继续对资源进项操作时，就会发生发生了访问违规。</strong></span> 
 </div> 
</blockquote> 
<div>
  举个例子，如果一个家庭里面有两个孩子，但是父母只给他们买了一个玩具，如果两个孩子都愿意玩这一个玩具，那就相安无事，否则就会鸡飞狗跳。 
</div> 
<div>
  要解决这个问题，就可以直接给他们一人买一个玩具，这样各自安逸。 
</div> 
<div>
  所以，要想解决浅拷贝的问题，可以使用深拷贝的方法， 
 <span style="color:#777777;"><strong>每个对象都有一份独立的资源，不要和其他对象共享</strong></span> 
 <span style="color:#777777;">。</span> 
</div> 
<h4 id="%E6%B7%B1%E6%8B%B7%E8%B4%9D">📖<span style="color:#777777;">深拷贝</span></h4> 
<div> 
 <span style="color:#777777;">如果一个类中涉及到资源的管理，其拷贝构造函数、赋值运算符重载以及析构函数必须要显式给出。一般情况都是按照深拷贝方式提供。 </span> 
</div> 
<div> 
 <img alt="" height="564" src="https://images2.imgbox.com/09/d0/o6x104VG_o.png" width="909"> 
</div> 
<p></p> 
<h3 id="%C2%A0string%E7%9A%84%E9%81%8D%E5%8E%86"> ✨string的遍历</h3> 
<h4 id="%E9%87%8D%E8%BD%BD%20%5B%5D%20%E4%B8%8B%E6%A0%87%E8%AE%BF%E9%97%AE">📖重载 [] 下标访问</h4> 
<pre><code class="language-cpp">char&amp; operator[](size_t pos)//可读可写
{
	assert(pos &lt; _size);
	return _str[pos];
}
//重载一个const
const char&amp; operator[](size_t pos) const//只读
{
	assert(pos &lt; _size);
	return _str[pos];
}</code></pre> 
<p>首先访问之前需要判断pos是否再合法访问之内，即小于等于size，然后直接返回字符串数组中对应的元素。由于存在const对象和非const对象，所以需要写两个重载版本。</p> 
<h4 id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BF%E9%97%AE">📖<strong>迭代器访问</strong></h4> 
<pre><code class="language-cpp">//迭代器
		typedef char* iterator;
		typedef const char* const_iterator;
		iterator begin()
		{
			return _str;
		}
		iterator end()
		{
			return _str + _size;
		}
		const_iterator begin()const
		{
			return _str;
		}
		const_iterator end()const
		{
			return _str + _size;
		}</code></pre> 
<p> 其实底层就是指针，所以直接返回对应的地址就可以了。</p> 
<h3 id="reserve">✨reserve</h3> 
<pre><code class="language-cpp">void reserve(size_t n)
{
	if (n &gt; _capacity)
	{
		char* tmp = new char[n+1];
		strcpy(tmp, _str);
		//释放旧空间，指向新空间
		delete[] _str;
		_str = tmp;
		//修改capacity，不用修改size
		_capacity = n;
	}
}</code></pre> 
<p>reserve是提前预留部分空间，它接收的空间大小不能比本来就有的容量小，如果n合法，则需要将原数组从旧空间移向一块更大的新空间，并释放掉旧空间。</p> 
<h3 id="resize">✨resize</h3> 
<pre><code class="language-cpp">void resize(size_t n,char ch='\0')
{
	if (n &lt;= _size)
	{
		_str[n] = '\0';
		_size = n;
	}
	else
	{
		reserve(n);
		for (int i = _size; i &lt; n; i++)
		{
			_str[i] = ch;
		}
		_str[n] = '\0';
		_size = n;
	}
}</code></pre> 
<p>resize是设置字符串的大小，如果n比字符串原来的大小小，则会发生截断；如果比原来的大小大，则会reserve一块n大小的空间。</p> 
<h3 id="%C2%A0%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9"> ✨增删查改</h3> 
<h4 id="push_back()">📖push_back()</h4> 
<pre><code class="language-cpp">void push_back(char ch)
{
	//扩容2倍
	if (_size == _capacity)
	{
		reserve(_capacity==0 ? 4 : 2 * _capacity);
	}
	_str[_size] = ch;
	_size++;
	_str[_size] = '\0';
}</code></pre> 
<p>直接尾插就可以，需要先判断空间是否足够，最后更新size的大小。</p> 
<h4 id="append%E5%92%8C%2B%3D">📖append和+=</h4> 
<pre><code class="language-cpp">void append(const char* str)
{
	//扩容
	//根据追加的字符串的长度扩容
	size_t len = strlen(str);
	if (_size + len &gt; _capacity)
	{
		reserve(_size + len);
	}
	strcpy(_str + _size, str);
	_size += len;
}
//  +=  
string&amp; operator+=(char ch)
{
	push_back(ch);
	return *this;
} 
string&amp; operator+=(const char* str)
{
	append(str);
	return *this;
}
string&amp; operator+=(const string s)
{
	append(s._str);
	return *this;
}</code></pre> 
<p>append和+=都是在字符串的尾部追加字符或者字符串，需要先判断容量是否足够，不够则需要扩容， 根据追加的字符串的长度扩容。</p> 
<h4 id="%C2%A0insert%E5%92%8Cerase"> 📖insert和erase</h4> 
<p>对于insert，0位置的插入可能产生问题，end是int类型，pos是size_t类型，end变成-1与pos比较时会发生整型提升，所以pos需要先进行强制类型转换；也可以使用另一种解决方法，将end的初始值赋值为size+1，每次使用这种方法后移字符串 _str[end] = _str[end - 1];，则end最后不会变成-1。</p> 
<pre><code class="language-cpp">//在pos之前插入
//插入字符
void insert(size_t pos,char ch)
{
	assert(pos &lt;= _size);
	if (_size == _capacity)
	{
		reserve(_capacity == 0 ? 4 : 2 * _capacity);
	}
	//int end = _size;
	0位置的插入可能产生问题，end变成-1与pos比较时会发生整型提升，所以pos需要先进行强制类型转换
	//while (end &gt;= (int)pos)
	//{
	//	_str[end+1] = _str[end];
	//	end--;
	//}
	//第二种解决方法
	int end = _size + 1;
	while (end &gt; pos)
	{
		_str[end] = _str[end - 1];
		end--;
	}
	_str[pos] = ch;
	_size++;
}
//在pos之前插入
//插入字符串
void insert(size_t pos,const char* str)
{
	assert(pos &lt;= _size);
	int len = strlen(str);
	if (_size +len &gt; _capacity)
	{
		reserve(_size + len+1);
	}
	//int end = _size;
	0位置的插入可能产生问题，end变成-1与pos比较时会发生整型提升，所以pos需要先进行强制类型转换
	//while (end &gt;= (int)pos)
	//{
	//	_str[end+1] = _str[end];
	//	end--;
	//}
	//第二种解决方法
	//在pos之前插入
	int end = _size + len;
	//pos 1 2 end
	while (end &gt; pos+len-1)
	{
		_str[end] = _str[end - len];
		end--;
	}
	strncpy(_str + pos,str,len);
	_size+=len;
}
//释放删除
void erase(size_t pos, size_t len = npos)
{
	assert(pos &lt; _size);
	// pos+len 存在溢出风险
	//if (len == npos || pos + len &gt;= _size)
	if (len == npos ||len &gt;= _size-pos)
	{
		_str[pos] = '\0';
		_size = pos;
	}
	else
	{
		strcpy(_str + pos, _str + pos + len);
		_size -= len;
	}
}</code></pre> 
<p>对于erase，需要根据传递的参数的大小来判断需要删除多少个字符。</p> 
<h4 id="find">📖find</h4> 
<pre><code class="language-cpp">//寻找匹配
size_t find(char ch,size_t pos = 0) const
{
	for (size_t i = pos; i &lt; _size; i++)
	{
		if (_str[i] == ch)
			return i;
	}
	return npos;
}
size_t find(const char* sub, size_t pos = 0) const
{
	assert(pos &lt;= _size);
	const char* p=strstr(_str+pos, sub);
	if (p)
	{
		return p - _str;
	}
	else
		return npos;
}</code></pre> 
<p>实现方法比较简单，就是普通的暴力查找。 </p> 
<h4 id="substr">📖substr</h4> 
<p>截取子串，需要注意len的大小。</p> 
<pre><code class="language-cpp">        string substr(size_t pos = 0, size_t len = npos)
		{
			string sub;
			if (len == npos|| len &gt;= _size - pos)
			{
				for (size_t i = pos; i &lt; _size; i++)
				{
					sub += _str[i];
				}
			}
			else
			{
				for (size_t i = pos; i &lt; pos + len; i++)
				{
					sub += _str[i];
				}
			}
			return sub;
		}</code></pre> 
<h3 id="swap%C2%A0">✨swap </h3> 
<p>众所周知，C++算法库里面存在swap这个函数模板，但是为什么string内部自己也有一个swap呢？</p> 
<p>如果用std::swap交换两个string对象，将会发生1次构造和2次赋值，也就是三次深拷贝；</p> 
<p><img alt="" height="536" src="https://images2.imgbox.com/6f/89/wYZJBCLU_o.png" width="782"></p> 
<p>而string内部的swap仅仅只交换成员，代价较小。</p> 
<pre><code class="language-cpp">//交换
void swap(string&amp; s)
{
	std::swap(_str, s._str);
	std::swap(_size, s._size);
	std::swap(_capacity, s._capacity);
}</code></pre> 
<p> 为了符合算法库里面swap的用法，可以再将swap重载成全局函数。</p> 
<pre><code class="language-cpp">	void swap(string&amp; x, string&amp; y)
	{
		x.swap(y);
	}</code></pre> 
<h3 id="%C2%A0%E6%B5%81%E6%8F%92%E5%85%A5%E5%92%8C%E6%B5%81%E6%8F%90%E5%8F%96">✨ 流插入和流提取</h3> 
<pre><code class="language-cpp">//重载成全局是为了调整顺序
	//流插入
	ostream&amp; operator&lt;&lt;(ostream&amp; out, const string&amp; s)
	{
		//这里不需要写成友元函数，因为不需要直接访问私有成员
		for (auto ch:s)
		{
			cout &lt;&lt; ch;
		}
		return out;
	}
	//流提取
	//C++ 流插入，流提取可以支持自定义类型使用
	istream&amp; operator&gt;&gt;(istream&amp; in, string&amp; s)
	{
		s.clear();
		char ch;
		char buff[128];
		//in &gt;&gt; ch;//默认把空格当作分隔符、换行，不读取
		ch = in.get();//C++中读取一个字符
		size_t i = 0;
		while (ch != ' ' &amp;&amp; ch != '\n')
		{
			buff[i++] = ch;
			if (i == 127)
			{
				buff[127] = '\0';
				s += buff;
				i = 0;
			}
			//s += ch;//重复+=，会重复扩容，消耗较大
			ch = in.get();
		}
		if (i &gt; 0)
		{
			buff[i] = '\0';
			s += buff;
		}
		return in;
	}</code></pre> 
<p>因为在这里不需要直接访问类的私有成员，所以流插入和流提取可以不用重载成string类的友元函数。</p> 
<p>对于流提取，如果频繁的尾插，会造成频繁扩容。而且C++的扩容和C语言的扩容不一样，C++使用new不能原地扩容，只能异地扩容，异地扩容就会导致新空间的开辟、数据的拷贝、旧空间释放。为了防止频繁扩容，我们可以创建一个可以存储128字节的数组，作为缓冲，如果数组满了，则将这个字符数组追加到s上，如果没慢，但是遇到空格或者换行了也需要追加。</p> 
<p>另外由于C++的标准输入流默认把空格和换行当作分隔符，不读取，所以这里要用in.get()来接收字符。</p> 
<h3 id="getline">✨getline</h3> 
<p>基本上可以直接复用流提取的代码。</p> 
<pre><code class="language-cpp">//读取空格
	istream&amp; getline(istream&amp; in, string&amp; s)
	{
		s.clear();
		char ch;
		//in &gt;&gt; ch;//默认把空格当作分隔符、换行，不读取
		ch = in.get();//C++中读取一个字符
		while ( ch != '\n')
		{
			s += ch;
			ch = in.get();
		}
		return in;
	}</code></pre> 
<h3 id="string%E5%85%B6%E4%BB%96%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD">✨string其他基本功能</h3> 
<pre><code class="language-cpp">        size_t size() const
		{
			return _size;
		}
		size_t capacity() const
		{
			return _capacity;
		}
        void clear()
		{
			_size = 0;
			_str[_size] = '\0';
		}
		</code></pre> 
<p>重载运算符，要写成全局的函数。</p> 
<pre><code class="language-cpp">bool operator==(const string&amp; a ,const string&amp; b)
	{
		int ret = strcmp(a.c_str(), b.c_str());
		return ret == 0;
	}
	bool operator&lt;(const string&amp; a, const string&amp; b)
	{
		int ret = strcmp(a.c_str(), b.c_str());
		return ret &lt; 0;
	}
	bool operator&lt;=(const string&amp; s1, const string&amp; s2)
	{
		return  (s1 &lt; s2) || (s1 == s2);
	}
	bool operator&gt;(const string&amp; s1, const string&amp; s2)
	{
		return  !(s1 &lt;= s2);
	}
	bool operator&gt;=(const string&amp; s1, const string&amp; s2)
	{
		return  !(s1 &lt; s2);
	}
	bool operator!=(const string&amp; s1, const string&amp; s2)
	{
		return  !(s1 == s2);
	}</code></pre> 
<p></p> 
<p>____________________</p> 
<p>⭐感谢你的阅读，希望本文能够对你有所帮助。如果你喜欢我的内容，记得点赞关注收藏我的博客，我会继续分享更多的内容。⭐</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5cffbed03a3af5217f8d34a0106c5a2f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">cyc大佬有地方写的不全，补充（redis篇）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3f1f41c7ec84287f2837c3fa0f8a07ad/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Tomcat与JDK各版本的兼容性</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>