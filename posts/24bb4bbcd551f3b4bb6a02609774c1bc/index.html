<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>访问控制之强制访问控制 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/24bb4bbcd551f3b4bb6a02609774c1bc/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="访问控制之强制访问控制">
  <meta property="og:description" content="目录
一、强制访问控制
二、多级安全思想
三、BLP模型
1.主客体安全属性
2.主体对客体的访问权限
3.安全访问规则
4.BLP模型中的可信主体
5.BLP模型的隐蔽通道问题
四、Biba模型
1.主客体安全属性
2.主体对客体的访问权限
3.安全访问规则
（1）非自主安全策略
（2）自主安全策略
4．Biba模型的不足之处
五、模块分析
1．强制访问控制与特洛伊木马防御
2．强制访问控制与自主访问控制的结合运用
3．BLP模型和Biba模型结合应用中存在的问题
一、强制访问控制 主体不能改变自身的或任何客体的安全属性，包括自己所拥有客体的安全属性；主体也不能将自己所拥有的客体访问权限，授予其他主体。在运行时，系统通过比较主、客体的安全属性，来决定是否允许主体以所请求方式来访问客体。而一旦系统判定某一主体不能访问某个客体时，那么任何人（包括客体的属主）也不能使他访问该客体。从某种意义上讲，这种访问控制是“强制”的。
二、多级安全思想 多级安全思想是军事安全策略的数学描述，是计算机能实现的形式主义。
军事安全策略的目的，是防止用户取得他不应该得到的密级较高的信息。在多级安全策略下，主、客体的安权属性一般都统称为安全级，它由两方面构成：
（1）保密级别：也叫敏感级别。例如，公开、秘密、机密和绝密等级别，在安全级中保密级别是线性排列的。例如：公开&lt;秘密&lt;机密&lt;绝密；
（2）范畴集：表示该安全级涉及的领域，如人事处、财务处等。范畴集是互相独立的和无须的，两个范畴集之间的关系是包含、被包含或无关。
主、客体的安全级通常写成保密级别后随一范畴集的形式。例如，{机密：人事处、财务处、科技处}。两个安全级之间的比较，是通过一种名为“支配”的偏序关系来进行的，具有以下几种情形：
（1）安全级1支配安全级2：即安全级1的级别不小于安全级2的级别，安全级1的范畴集包含安全级2的范畴集。
（2）安全级1等于安全级2：即安全级1的级别等于安全级2的级别，安全级1的范畴集包含安全级2的范畴集，同时安全级2的范畴集包含安全级1的范畴集。
（3）安全级1与安全级2无关：即安全级1的级别不包含安全级2的级别，同时安全级2的范畴集不包含安全级1的范畴集。
例如，如果一个文件的安全级是{机密：NATO，NUCLEAR}，用户的安全级为{绝密：NATO，NUCLEAR，CRYPTO}，则该用户可以阅读这个文件，他的安全级别高于文件，且他的安全范畴集涵盖了文件的安全范畴集。而如果用户的安全级为{绝密：NATO，CRYPTO}，则他不能阅读这个文件，因为其安全范畴集中少了NUCLEAR范畴。
三、BLP模型 BLP模型是Bell&amp;LaPadula模型的简称，主要用于解决面向保密性需求的访问控制问题，是第一个经过严格数学证明的安全模型。BLP模型给出了符合军事安全策略的计算机操作规则，属于强制访问控制模型。BLP模型是最常用、也是最有名的一个多级安全模型，已实际应用于许多安全操作系统、安全数据库等安全信息的开发之中。
1.主客体安全属性 在BLP模型中，主体和客体均被赋予了相应的安全级别L=（C，S），其中：表示安全等级，S是类别集。安全等级从高到低分为4级：绝密（TS）、机密（S）、秘密（C）和非密（U），这里记它们的关系为TS&gt;S&gt;C&gt;U。类别集依赖于应用环境，如它可由不同部门的标识组成。
对于两个安全级别L1=（C1，S1）与L2=（C2，S2），定义：
L1≥L2，当且仅当C1≥C2，S2⊆S1
L1&gt;L2，当且仅当C1&gt;C2，S2⊂S1
L1&lt;L2，当且仅当C1&lt;C2，S1⊂S2
L1≤L2，当且仅当C1≤C2，S1⊆S2
如果L1和L2的关系都不属于以上情况，则其不可比较。
在BLP模型中，客体的安全级别，反映了客体内容或功能的敏感性；主体的安全级别又称为许可授权，它反映了主体的最高安全级别，主体当前的安全级别不会高于其拥有的许可授权。
2.主体对客体的访问权限 在BLP模型中，主体对客体存在只读（Read Only）、添加（Append）、执行（Execute）和读写（Read-Write）四种访问权限。
3.安全访问规则 （1）符号约定
①三元组（s,o,m）表示主体s正以授权m访问访问客体o
②M表示访问矩阵，m=M（s，o）表示授权s以权限m访问客体o；
③f是主体或客体的安全级别函数，其定义为：
f:s∪o =&gt; L
（2）规则1：简单安全策略（Simple Security Property）
如果主体s对客体o有读写权限，则前者的安全级别一定不低于后者的安全级别。这一规则，可以形式化地表示为：Read or Write ∈ M（s，0）=&gt;f（s）≥f（o）
这常被称为“下读”原则。
（3）规则2：星策略（Star Property）
如果一个主体s对客体o有Append权限，则后者的安全级别一定不低于前者；如果s对o有 Write权限，则它们的安全级别一定相等；如果s对o有Read 权限，则后者的安全级别一定不高于前者。这个规则可以形式化地表示为
Append∈M（s，0）=&gt;f（s）≤f（o）">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-18T08:05:18+08:00">
    <meta property="article:modified_time" content="2024-07-18T08:05:18+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">访问控制之强制访问控制</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E5%BC%BA%E5%88%B6%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%BC%BA%E5%88%B6%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6" rel="nofollow">一、强制访问控制</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%A4%9A%E7%BA%A7%E5%AE%89%E5%85%A8%E6%80%9D%E6%83%B3-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%A4%9A%E7%BA%A7%E5%AE%89%E5%85%A8%E6%80%9D%E6%83%B3" rel="nofollow">二、多级安全思想</a></p> 
<p id="%E4%B8%89%E3%80%81BLP%E6%A8%A1%E5%9E%8B-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81BLP%E6%A8%A1%E5%9E%8B" rel="nofollow">三、BLP模型</a></p> 
<p id="1.%E4%B8%BB%E5%AE%A2%E4%BD%93%E5%AE%89%E5%85%A8%E5%B1%9E%E6%80%A7-toc" style="margin-left:40px;"><a href="#1.%E4%B8%BB%E5%AE%A2%E4%BD%93%E5%AE%89%E5%85%A8%E5%B1%9E%E6%80%A7" rel="nofollow">1.主客体安全属性</a></p> 
<p id="2.%E4%B8%BB%E4%BD%93%E5%AF%B9%E5%AE%A2%E4%BD%93%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90-toc" style="margin-left:40px;"><a href="#2.%E4%B8%BB%E4%BD%93%E5%AF%B9%E5%AE%A2%E4%BD%93%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90" rel="nofollow">2.主体对客体的访问权限</a></p> 
<p id="3.%E5%AE%89%E5%85%A8%E8%AE%BF%E9%97%AE%E8%A7%84%E5%88%99-toc" style="margin-left:40px;"><a href="#3.%E5%AE%89%E5%85%A8%E8%AE%BF%E9%97%AE%E8%A7%84%E5%88%99" rel="nofollow">3.安全访问规则</a></p> 
<p id="4.BLP%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%8F%AF%E4%BF%A1%E4%B8%BB%E4%BD%93-toc" style="margin-left:40px;"><a href="#4.BLP%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%8F%AF%E4%BF%A1%E4%B8%BB%E4%BD%93" rel="nofollow">4.BLP模型中的可信主体</a></p> 
<p id="5.BLP%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%9A%90%E8%94%BD%E9%80%9A%E9%81%93%E9%97%AE%E9%A2%98-toc" style="margin-left:40px;"><a href="#5.BLP%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%9A%90%E8%94%BD%E9%80%9A%E9%81%93%E9%97%AE%E9%A2%98" rel="nofollow">5.BLP模型的隐蔽通道问题</a></p> 
<p id="%E5%9B%9B%E3%80%81Biba%E6%A8%A1%E5%9E%8B-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81Biba%E6%A8%A1%E5%9E%8B" rel="nofollow">四、Biba模型</a></p> 
<p id="1.%E4%B8%BB%E5%AE%A2%E4%BD%93%E5%AE%89%E5%85%A8%E5%B1%9E%E6%80%A7-toc" style="margin-left:40px;"><a href="#1.%E4%B8%BB%E5%AE%A2%E4%BD%93%E5%AE%89%E5%85%A8%E5%B1%9E%E6%80%A7" rel="nofollow">1.主客体安全属性</a></p> 
<p id="2.%E4%B8%BB%E4%BD%93%E5%AF%B9%E5%AE%A2%E4%BD%93%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90-toc" style="margin-left:40px;"><a href="#2.%E4%B8%BB%E4%BD%93%E5%AF%B9%E5%AE%A2%E4%BD%93%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90" rel="nofollow">2.主体对客体的访问权限</a></p> 
<p id="3.%E5%AE%89%E5%85%A8%E8%AE%BF%E9%97%AE%E8%A7%84%E5%88%99-toc" style="margin-left:40px;"><a href="#3.%E5%AE%89%E5%85%A8%E8%AE%BF%E9%97%AE%E8%A7%84%E5%88%99" rel="nofollow">3.安全访问规则</a></p> 
<p id="%EF%BC%881%EF%BC%89%E9%9D%9E%E8%87%AA%E4%B8%BB%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E9%9D%9E%E8%87%AA%E4%B8%BB%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5" rel="nofollow">（1）非自主安全策略</a></p> 
<p id="%EF%BC%882%EF%BC%89%E8%87%AA%E4%B8%BB%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E8%87%AA%E4%B8%BB%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5" rel="nofollow">（2）自主安全策略</a></p> 
<p id="4%EF%BC%8EBiba%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%B8%8D%E8%B6%B3%E4%B9%8B%E5%A4%84-toc" style="margin-left:40px;"><a href="#4%EF%BC%8EBiba%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%B8%8D%E8%B6%B3%E4%B9%8B%E5%A4%84" rel="nofollow">4．Biba模型的不足之处</a></p> 
<p id="%E4%BA%94%E3%80%81%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90" rel="nofollow">五、模块分析</a></p> 
<p id="1%EF%BC%8E%E5%BC%BA%E5%88%B6%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%89%B9%E6%B4%9B%E4%BC%8A%E6%9C%A8%E9%A9%AC%E9%98%B2%E5%BE%A1-toc" style="margin-left:40px;"><a href="#1%EF%BC%8E%E5%BC%BA%E5%88%B6%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%89%B9%E6%B4%9B%E4%BC%8A%E6%9C%A8%E9%A9%AC%E9%98%B2%E5%BE%A1" rel="nofollow">1．强制访问控制与特洛伊木马防御</a></p> 
<p id="2%EF%BC%8E%E5%BC%BA%E5%88%B6%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E8%87%AA%E4%B8%BB%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%9A%84%E7%BB%93%E5%90%88%E8%BF%90%E7%94%A8-toc" style="margin-left:40px;"><a href="#2%EF%BC%8E%E5%BC%BA%E5%88%B6%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E8%87%AA%E4%B8%BB%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%9A%84%E7%BB%93%E5%90%88%E8%BF%90%E7%94%A8" rel="nofollow">2．强制访问控制与自主访问控制的结合运用</a></p> 
<p id="3%EF%BC%8EBLP%E6%A8%A1%E5%9E%8B%E5%92%8CBiba%E6%A8%A1%E5%9E%8B%E7%BB%93%E5%90%88%E5%BA%94%E7%94%A8%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98-toc" style="margin-left:40px;"><a href="#3%EF%BC%8EBLP%E6%A8%A1%E5%9E%8B%E5%92%8CBiba%E6%A8%A1%E5%9E%8B%E7%BB%93%E5%90%88%E5%BA%94%E7%94%A8%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98" rel="nofollow">3．BLP模型和Biba模型结合应用中存在的问题</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 style="margin-left:.0001pt;text-align:justify;">一、强制访问控制</h2> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">主体不能改变自身的或任何客体的安全属性，包括自己所拥有客体的安全属性；主体也不能将自己所拥有的客体访问权限，授予其他主体。在运行时，系统通过比较主、客体的安全属性，来决定是否允许主体以所请求方式来访问客体。而一旦系统判定某一主体不能访问某个客体时，那么任何人（包括客体的属主）也不能使他访问该客体。从某种意义上讲，这种访问控制是“强制”的。</p> 
</blockquote> 
<hr> 
<h2 id="%E4%BA%8C%E3%80%81%E5%A4%9A%E7%BA%A7%E5%AE%89%E5%85%A8%E6%80%9D%E6%83%B3" style="margin-left:.0001pt;text-align:justify;">二、多级安全思想</h2> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">多级安全思想是军事安全策略的数学描述，是计算机能实现的形式主义。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">军事安全策略的目的，是防止用户取得他不应该得到的密级较高的信息。在多级安全策略下，主、客体的安权属性一般都统称为安全级，它由两方面构成：</p> 
 <p style="margin-left:.0001pt;text-align:justify;">（1）保密级别：也叫敏感级别。例如，公开、秘密、机密和绝密等级别，在安全级中保密级别是线性排列的。例如：公开&lt;秘密&lt;机密&lt;绝密；</p> 
 <p style="margin-left:.0001pt;text-align:justify;">（2）范畴集：表示该安全级涉及的领域，如人事处、财务处等。范畴集是互相独立的和无须的，两个范畴集之间的关系是包含、被包含或无关。</p> 
</blockquote> 
<hr> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">主、客体的安全级通常写成保密级别后随一范畴集的形式。例如，{机密：人事处、财务处、科技处}。两个安全级之间的比较，是通过一种名为“支配”的偏序关系来进行的，具有以下几种情形：<br> （1）安全级1支配安全级2：即安全级1的级别不小于安全级2的级别，安全级1的范畴集包含安全级2的范畴集。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">（2）安全级1等于安全级2：即安全级1的级别等于安全级2的级别，安全级1的范畴集包含安全级2的范畴集，同时安全级2的范畴集包含安全级1的范畴集。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">（3）安全级1与安全级2无关：即安全级1的级别不包含安全级2的级别，同时安全级2的范畴集不包含安全级1的范畴集。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">例如，如果一个文件的安全级是{机密：NATO，NUCLEAR}，用户的安全级为{绝密：NATO，NUCLEAR，CRYPTO}，则该用户可以阅读这个文件，他的安全级别高于文件，且他的安全范畴集涵盖了文件的安全范畴集。而如果用户的安全级为{绝密：NATO，CRYPTO}，则他不能阅读这个文件，因为其安全范畴集中少了NUCLEAR范畴。</p> 
</blockquote> 
<hr> 
<h2 id="%E4%B8%89%E3%80%81BLP%E6%A8%A1%E5%9E%8B" style="margin-left:.0001pt;text-align:justify;">三、BLP模型</h2> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">BLP模型是Bell&amp;LaPadula模型的简称，主要用于解决面向保密性需求的访问控制问题，是第一个经过严格数学证明的安全模型。BLP模型给出了符合军事安全策略的计算机操作规则，属于强制访问控制模型。BLP模型是最常用、也是最有名的一个多级安全模型，已实际应用于许多安全操作系统、安全数据库等安全信息的开发之中。</p> 
</blockquote> 
<h3 id="1.%E4%B8%BB%E5%AE%A2%E4%BD%93%E5%AE%89%E5%85%A8%E5%B1%9E%E6%80%A7" style="margin-left:.0001pt;text-align:justify;">1.主客体安全属性</h3> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">在BLP模型中，主体和客体均被赋予了相应的安全级别L=（C，S），其中：表示安全等级，S是类别集。安全等级从高到低分为4级：绝密（TS）、机密（S）、秘密（C）和非密（U），这里记它们的关系为TS&gt;S&gt;C&gt;U。类别集依赖于应用环境，如它可由不同部门的标识组成。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">对于两个安全级别L1=（C1，S1）与L2=（C2，S2），定义：</p> 
 <p style="margin-left:.0001pt;text-align:justify;">L1≥L2，当且仅当C1≥C2，S2⊆S1</p> 
 <p style="margin-left:.0001pt;text-align:justify;">L1&gt;L2，当且仅当C1&gt;C2，S2⊂S1</p> 
 <p style="margin-left:.0001pt;text-align:justify;">L1&lt;L2，当且仅当C1&lt;C2，S1⊂S2</p> 
 <p style="margin-left:.0001pt;text-align:justify;">L1≤L2，当且仅当C1≤C2，S1⊆S2</p> 
 <p style="margin-left:.0001pt;text-align:justify;">如果L1和L2的关系都不属于以上情况，则其不可比较。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">在BLP模型中，客体的安全级别，反映了客体内容或功能的敏感性；主体的安全级别又称为许可授权，它反映了主体的最高安全级别，主体当前的安全级别不会高于其拥有的许可授权。</p> 
</blockquote> 
<h3 id="2.%E4%B8%BB%E4%BD%93%E5%AF%B9%E5%AE%A2%E4%BD%93%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90" style="margin-left:.0001pt;text-align:justify;">2.主体对客体的访问权限</h3> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">在BLP模型中，主体对客体存在只读（Read Only）、添加（Append）、执行（Execute）和读写（Read-Write）四种访问权限。</p> 
</blockquote> 
<h3 id="3.%E5%AE%89%E5%85%A8%E8%AE%BF%E9%97%AE%E8%A7%84%E5%88%99" style="margin-left:.0001pt;text-align:justify;">3.安全访问规则</h3> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>（1）符号约定</strong></p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">①三元组（s,o,m）表示主体s正以授权m访问访问客体o</p> 
 <p style="margin-left:.0001pt;text-align:justify;">②M表示访问矩阵，m=M（s，o）表示授权s以权限m访问客体o；</p> 
 <p style="margin-left:.0001pt;text-align:justify;">③f是主体或客体的安全级别函数，其定义为：</p> 
 <p style="margin-left:.0001pt;text-align:justify;">f:s∪o =&gt; L</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>（2）规则1：简单安全策略（Simple Security Property）</strong></p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">如果主体s对客体o有读写权限，则前者的安全级别一定不低于后者的安全级别。这一规则，可以形式化地表示为：Read or Write ∈ M（s，0）=&gt;f（s）≥f（o）</p> 
 <p style="margin-left:.0001pt;text-align:justify;">这常被称为“下读”原则。</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>（3）规则2：星策略（Star Property）</strong></p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">如果一个主体s对客体o有Append权限，则后者的安全级别一定不低于前者；如果s对o有 Write权限，则它们的安全级别一定相等；如果s对o有Read 权限，则后者的安全级别一定不高于前者。这个规则可以形式化地表示为</p> 
 <p style="margin-left:.0001pt;text-align:justify;">Append∈M（s，0）=&gt;f（s）≤f（o）</p> 
 <p style="margin-left:.0001pt;text-align:justify;">Write∈M（s，0）=&gt;f（s）=f（o）</p> 
 <p style="margin-left:.0001pt;text-align:justify;">Read∈M（s，0）=&gt;f（s）≥（o）</p> 
 <p style="margin-left:.0001pt;text-align:justify;">这常被称为“上写”原则。</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>（4）规则3：自主安全策略</strong></p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">当前正在执行的访问权限必须存在于访问矩阵M中。这个规则保证，主体对客体的权限也需要以自主授权为条件，它可以被形式化地表示为：（s，0，m）∈b =&gt;m∈M（s，0）</p> 
</blockquote> 
<h3 id="4.BLP%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%8F%AF%E4%BF%A1%E4%B8%BB%E4%BD%93" style="margin-left:.0001pt;text-align:justify;">4.BLP模型中的可信主体</h3> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">BLP模型在军事和商业界的安全操作系统、安全文件系统和安全数据库系统中均得到了广泛的应用和实践。但多数安全系统的实践表明，在系统中严格实施 BLP模型是不实际的。在真实的系统中，用户的某个操作可能会违背星策略，但并不会破坏系统的安全性。例如，一个用户可能要从一个机密性文件中摘取一节非机密性的内容，并将它应用到另一个非机密性的文件中，这种操作在严格实施星策略的系统中是被禁止的。因此，为了保证系统的可用性，BLP模型引人可信主体的概念，这类主体是可信的，它们可以违背星策略，但是不会违背系统的安全性。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">由于可信主体不受星策略约束，访问权限太大，不符合最小特权原则，所以在应用中，应对可信主体的操作权限和应用范围做进一步细化。例如，可以将操作系统的所有特权细分成一组细粒度的特权，这些特权分别组成若干个特权子集。再把这些特权子集赋予系统中的指定用户。这样，操作系统中就存在若干个特权用户，每一个特权用户都不能独自控制整个系统，这些特权用户共同完成系统的特权操作，且所有的特权用户操作都会被系统审计记录。</p> 
</blockquote> 
<h3 id="5.BLP%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%9A%90%E8%94%BD%E9%80%9A%E9%81%93%E9%97%AE%E9%A2%98" style="margin-left:.0001pt;text-align:justify;">5.BLP模型的隐蔽通道问题</h3> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">如果一个通信信道既不是设计用于通信的，也不是有意用于传递信息的，则称该通信信道为隐蔽通道。BLP模型允许“上写（write-up）””操作，而“上写”操作带来了潜在的隐蔽通道。下面举例分析。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">假定一个系统允许“上写”操作，系统中的文件data 的安全级支配进程B的安全级，即进程B对文件data有强制的写权限，但没有强制的读权限。根据BLP模型，进程B可以写打开、关用文件data。因此，每当进程B为写而打开文件data时，总返回一个表示文件已成功打开的标志信息。下面可以着到，这个标志信息就是一个隐蔽通道，利用它可以将信息从绝密区城传到公开区域。</p> 
</blockquote> 
<hr> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">下图给出了绝密级进程A与公开进程B，协作利用这个隐蔽通道传递敏感信息的过程：</p> 
 <p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/49/d7/jM6wztQR_o.jpg"></p> 
 <p style="margin-left:.0001pt;text-align:justify;">（1）进程A创建绝密信息文件data；</p> 
 <p style="margin-left:.0001pt;text-align:justify;">（2）进程B打开文件 control，并写入一个字节，内容为“0”或“1”。进程A一直监控文件control的长度，当它发现其变长时，则说明进程B已经做好了接收信息的准备，此时可以开始发送信息了。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">（3）进程A改变文件data的DAC访问模式。进程A与进程B双方约定，若允许进程B写 data 文件，则表示进程A发送了一个二进制比特“1”；否则，表示进程A发送了二进制比特“0”。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">（4）进程B试图以写方式打开文件data。若打开成功，则认为自己收到了比特位“1”；否则，认为自己收到了比特位“0”。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">（5）进程B每接收一个二进制比特信息，则将其写入文件control。进程A则通过检查文件 control的长度是否发生变化，确定信息传递是否正确。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">（6）反复执行以上的第2~5步动作，直到绝密信息全部从进程A传给进程B。</p> 
</blockquote> 
<hr> 
<h2 id="%E5%9B%9B%E3%80%81Biba%E6%A8%A1%E5%9E%8B" style="margin-left:.0001pt;text-align:justify;">四、Biba模型</h2> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">Biba模型是Biba等人于1977年提出，其目的是保护数据的完整性。它对数据读/写实施了专门的操作策略。Biba模型在定义主、客体安全级别的基础上，更明确地将访问策略划分为非自主策略和自主策略两类，对每类给出了多个策略。下面介绍Biba模型中的各个要素。</p> 
</blockquote> 
<h3 style="margin-left:.0001pt;text-align:justify;">1.主客体安全属性</h3> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">在Biba模型中，每个主体和客体都被分配一个完整性级别（IntegrityLevel）。类似于BLP模型，完整性级别用L=（C，S）表示，其中:C为完整性等级，S是类别集。但这里，完整性等级从高到低分为3级：关键级（Critical，C），非常重要（Very Important，VI）和重要（Important，I），它们的关系为C&gt;VI&gt;I。类别集的概念与BLP模型中的类似，如它也可由不同部门的标识组成。不同完整性级别之间的比较方法，与BLP模型中的安全级别的比较方法相同。</p> 
</blockquote> 
<h3 style="margin-left:.0001pt;text-align:justify;">2.主体对客体的访问权限</h3> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">在Biba模型中，主体对客体的主要访间方式有：修改（modify）、调用（invoke）和观察（observe）等，它们的含义如下：</p> 
 <p style="margin-left:.0001pt;text-align:justify;">（1）modify：向客体中写信息。类似其他模型的“写”访问方式。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">（2）invoke：invoke操作仅能用于主体，若两个主体间有invoke权限，则允许这两个主体相互通信。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">（3）observe：从客体中读信息，类似于其他模型中的“读”访同方式。</p> 
</blockquote> 
<h3 style="margin-left:.0001pt;text-align:justify;">3.安全访问规则</h3> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">Biba模型所定义的不是单个安全策略，而是一族安全策略。每种安全策略采用不同的访问规则来保证信息的完整性。Biba模型的安全策略可以分为两大类：非自主安全策略与自主安全策略。</p> 
</blockquote> 
<hr> 
<h4 id="%EF%BC%881%EF%BC%89%E9%9D%9E%E8%87%AA%E4%B8%BB%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5" style="margin-left:.0001pt;text-align:justify;"><strong>（1）非自主安全策略</strong></h4> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">非自主安全策略基于主体和客体各自的安全级别，确定主体对客体的访问方式。Biba模型中的非自主安全策略有五个：严格完整性策略、针对主体的下限标记策略、针对于客体的下限标记策略、下限标记完整性审计策略和环策略。</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>①严格完整性策略（Strict Integrity Policy）</strong></p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">·简单完整性条件（Simple Integrity Condition）：主体能够对客体进行observe访问，仅当客体的完整性级别支配主体的完整性级别。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">·完整性星规则（Integrity * -Property）：主体能够对客体进行modify访问，仅当主体的完整性级别支配客体的完整性级别。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">·调用规则（Invocation Property）：一个主体能够对另一个主体进行invoke访问，仅当第一个主体的完整性级别支配第二个主体的完整性级别。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">严格完整性策略可总结为两个基本规则：“不下读（No Read Down）”和“不上写（NoWrite Up）”。严格完整性策略防止信息从低完整性级别客体流向高完整性级别或不可比完整性级别，保证信息流仅是observe和modify访问的结果。</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>②针对主体的下限标记策略（Low Watermark Policy for Subjects）</strong></p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">·主体能够对任何客体进行observe访问。但是，当主体执行了对客体的observe操作之后，主体的完整性级别被置于执行访问之前，主体和客体的完整性级别中的较小者。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">·主体能够对客体进行modify访问，仅当此主体的完整性级别支配该客体的完整性级别。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">·一个主体能够对另一个主体进行invoke访问，仅当第一个主体的完整性级别支配第二个主体的完整性级别。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">针对主体的下限标记策略是动态的，因为主体在对具有较低或不可比的完整性级别的客体执行observe操作后，会降低本身的完整性级别。此策略的主要缺点是，对系统的访问可能要依赖提出访问要求的顺序。因为主体在对某些持有较低或不相容的完整性级别的客体执行observe操作后，会降低自身的完整性级别，这就有可能减少此主体可访问的客体集，使某些原来对主体说来是可以访回的客体，在执行observe操作后变成不可访问的。这样，在observe操作后执行的某些modify或invoke操作会由手相应的客体变成不可访向的而不能执行。</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>③针对于客体的下限标记策略（Low Watermark Policy for Objects）</strong></p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">·主体能够对客休进行observe访问，仅当客体的完整性级别支配主体的完整性级别。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">·主体能够对任何客休进行modify访问。但是，当主体执行了对客体的modify操作后，客休的完整性级别被置于执行访问前，主体和客体的完整性级别中的较小者。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">·一个主体能够对另一个主体进行invoke访问，仅当第一个主体的完整性级别亥配第二个主体的完整性级别。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">这一安全策略也是动态的，因为被modify的客体的完整性级别有可能改变。此策略的主要缺点，是允许不恰当的modify访问降低客体的完整性级别，而且信息由高完整性级别变为低完整性级别后也是不能恢复的。</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>④下限标记完整性审计策略（Low Watermark Integrity Audit Policy）</strong></p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">·主体能够对客体进行observe访问，仅当客体的完整性级别支配主体的完整性级别。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">·主体能够对任何客体进行modify访问。但是，如果主体modify了一个具有更高或不可比完整性级别的客体，该操作将被审计。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">·一个主体能够对另一个主体进行invoke访问，仅当第一个主体的完整性级别支配第二个主体的完整性级别。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">这一策略是针对客体的下限标记策略的一个变种。只是，在此策略中，客体的完整性级别是固定的。像前一个策略一样，这一策略并没有防止对信息的不恰当的modify，只是对这访问进行审计。</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>⑤环策略（Ring Policy）</strong></p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">·主体对具有任何完整性级别的客体均能进行observe访问。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">·主体能够对客体进行modify访问，仅当主体的完整性级别支配客体的完整性级别。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">·一个主体能够对另一个主体进行invoke访问，仅当第一个主体的完整性级别支配第二个主体的完整性级别。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">这一策略防止主体modify具有更高或不可比完整性级别的客体。然而，由于observe访同是非受限的，仍可能发生不恰当的modify操作。如一个具有高完整性级别的主体能够observe一个具有较低完整性级别的客体，然后modify具有自己安全级别的客体，这样信息就从低完整性级别流向高或不可比完整性级别。为了避免这种情况，主体在使用来自低完整性级别客体的数据时要十分小心。</p> 
</blockquote> 
<h4 id="%EF%BC%882%EF%BC%89%E8%87%AA%E4%B8%BB%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5" style="margin-left:.0001pt;text-align:justify;">（2）自主安全策略</h4> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">①访问控制表（Access Control List）：对每个客体分配一个访问控制列表，指明能够访问此客体的主体和每个主体能够对此客体执行的访问方式。客体的访问控制列表可以被对此客体持有modify访问权限的主体修改。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">②客体层次结构（Object Hierarchy）：模型将客体组织成层次结构，此层次结构是一棵带根的树。一个客体的先驱节点是从此客体节点到根的路径上的节点。若主体要访问客体，则必须拥有对此客体的所有先驱节点的observe访问权限。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">③环（Ring）：对每个主体分配一个权限属性，称为环。环用数值表示，环的值越小，表示其权限越高。此策略的访问规则如下：</p> 
 <p style="margin-left:.0001pt;text-align:justify;">·仅在环允许的范围内，主体才能对客体进行observe访问。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">·仅在环允许的范围内，主体才能对客体进行modify访问。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">·一个主体仅在环允许的范围内，能够对另一个具有更高权限的主体进行invoke访问。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">·主体能够对任何具有较低或相同权限的主体进行invoke访问。</p> 
</blockquote> 
<h3 id="4%EF%BC%8EBiba%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%B8%8D%E8%B6%B3%E4%B9%8B%E5%A4%84" style="margin-left:.0001pt;text-align:justify;">4．Biba模型的不足之处</h3> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">（1）完整标签确定的困难性。由于BLP机密性策略可以与政府分级机制完美结合，所以很容易确定机密性标签的分级和范畴，但是对于完整性的分级和分类一直没有相应的标准予以支持。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">（2）Biba模型的主要目的，是保护数据免受非授权用户的恶意修改，同时其认为内部完整性威胁应该通过程序验证来解决，但在该模型中并没有包括这个要求，因此Biba模型在有效保护数据一致性方面是不充分的。</p> 
</blockquote> 
<h2 id="%E4%BA%94%E3%80%81%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90" style="margin-left:.0001pt;text-align:justify;">五、模块分析</h2> 
<h3 id="1%EF%BC%8E%E5%BC%BA%E5%88%B6%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%89%B9%E6%B4%9B%E4%BC%8A%E6%9C%A8%E9%A9%AC%E9%98%B2%E5%BE%A1" style="margin-left:.0001pt;text-align:justify;">1．强制访问控制与特洛伊木马防御</h3> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">防止特洛伊木马侵入系统是极端困难的，如果不依赖于一些强制手段，想避免特洛伊木马的破坏是不可能的。解决特洛伊木马的一个有效方法是使用强制访问控制机制。在强制访问控制的情况下，对于违反强制访问控制的特洛伊木马，可以防止它取走信息。例如，在多级安全系统中，其特性能阻止正在机密安全级上运行的特洛伊木马进程把机密信息写入一个公开的文件里，因为用机密进程写入的每一信息的安全级必须至少是机密级的。例如，一个公司对系统中的信息指定强制存取范畴，只有该公司的雇员才可能进入这个范畴。如果它的一个雇员使用了特洛伊木马，他不可能将该公司的信息传递到这个范畴以外的地方去，但在这个范畴里，信息可以在各用户间自由传递。</p> 
</blockquote> 
<h3 id="2%EF%BC%8E%E5%BC%BA%E5%88%B6%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E8%87%AA%E4%B8%BB%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%9A%84%E7%BB%93%E5%90%88%E8%BF%90%E7%94%A8" style="margin-left:.0001pt;text-align:justify;">2．强制访问控制与自主访问控制的结合运用</h3> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">强制访问控制和自主访问控制是两种不同类型的存取控制机制，它们常结合起来使用。仅当主体能够同时通过自主访问控制和强制访问控制检查时，它才能访问一个客体。用户使用自主访问控制防止其他用户非法人侵自己的文件，强制访问控制则作为更强有力的安全保护方式，可以防止用户有意识地或因误操作而导致安全问题。</p> 
</blockquote> 
<h3 id="3%EF%BC%8EBLP%E6%A8%A1%E5%9E%8B%E5%92%8CBiba%E6%A8%A1%E5%9E%8B%E7%BB%93%E5%90%88%E5%BA%94%E7%94%A8%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98" style="margin-left:.0001pt;text-align:justify;">3．BLP模型和Biba模型结合应用中存在的问题</h3> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">由于许多应用的内在复杂性，在结合应用Biba模型和BLP模型时，人们不得不通过设置更多的范畴来满足这些复杂应用在机密性和完整性方面的需求，而这些不同性质的范畴在同时满足安全性和完整性目标方面是难以配合使用的，特别当保密性和完整性都受到充分的重视后，就很容易出现进程不能访问任何数据的局面。</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/81c740b53abaa0a8b5099db9bc4cc739/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python酷库之旅-第三方库Pandas(030)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fded1cf89eb73ba2bdb8621f5b9f0dcf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">阿里基于 Spring AI 发布新版本，真的牛！！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>