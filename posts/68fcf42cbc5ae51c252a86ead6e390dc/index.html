<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>RabbitMQ-如何保证消息不丢失 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/68fcf42cbc5ae51c252a86ead6e390dc/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="RabbitMQ-如何保证消息不丢失">
  <meta property="og:description" content="RabbitMQ常用于 异步发送，mysql，redis，es之间的数据同步 ，分布式事务，削峰填谷等.....
在微服务中，rabbitmq是我们经常用到的消息中间件。它能够异步的在各个业务之中进行消息的接受和发送，那么如何保证rabbitmq的消息不丢失就显得尤为重要。
首先要分析问题，我们就要明确rabbitmq在什么时候可能会出现消息丢失的情况呢？
我们直接说结果
RabbitMQ在每个阶段都有可能使消息发生丢失
我们在这里把他们简单归结为三个层面
层面一 ：生产者发送消息没有到达交换机或者没有到达绑定的队列。
层面二：RabbitMQ宕机可能导致的消息的丢失。
层面三：消费者宕机导致消息丢失。
层面一的解决方法常见的是
1.生产者确认机制
RabbitMQ提供了publisher confirm机制来避免消息发送到Mq的过程中丢失，消息发送到Mq以后，会返回一个结果给发送者，表示消息的发送成功。
情况一：发送成功 生产者正常发送消息到队列之后会返回一个publish-confirm ack 这个意思是告诉生产者已经接收到消息了。
情况二：发送失败 这里的发送失败有两种，一种是生产者发送到交换机失败 此时返回 publish-confirm nack 。第二种是生产者发送到队列失败 返回 publish-return ack。
开启生产者确认机制的代码如下 ，在生产者的配置文件中加入以下配置
spring: rabbitmq: publisher-confirm-type: correlated #开启生产者确认机制 publisher-returns: true 这里的
publisher-confirm-type:有三种模式可以选择： 第一种是none：代表关闭confirm机制
第二种是 simple：表示同步阻塞并等待mq的回执消息，即发送完消息后不能干其他的事情，只能等待mq的回执，很显然这样效率很低。
第三种是correlated：MQ异步回调方式返回回执消息，即生产者发送完消息后可以干其他的事情，直到接收到mq的回执。很明显这种效率要优于第二种。
配置return callback的代码如下，每个RabbitTemplate只能配置一个 代码如下
package com.itheima.publisher.com.it.heima.config; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.core.ReturnedMessage; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.beans.BeansException; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.ApplicationContext; import org.springframework.context.ApplicationContextAware; import org.springframework.context.annotation.Configuration; /** * @Auther: QuJingChuan * @Date: 2024/1/13 10:34 * @Description: */ @Slf4j @Configuration public class MqConfirmConfig implements ApplicationContextAware { @Autowired private RabbitTemplate rabbitTemplate; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { //配置回调 rabbitTemplate.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-01-25T12:30:45+08:00">
    <meta property="article:modified_time" content="2024-01-25T12:30:45+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">RabbitMQ-如何保证消息不丢失</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>RabbitMQ常用于 异步发送，mysql，redis，es之间的数据同步 ，分布式事务，削峰填谷等.....</p> 
<p>在微服务中，rabbitmq是我们经常用到的消息中间件。它能够异步的在各个业务之中进行消息的接受和发送，那么如何保证rabbitmq的消息不丢失就显得尤为重要。</p> 
<p>首先要分析问题，我们就要明确rabbitmq在什么时候可能会出现消息丢失的情况呢？</p> 
<p>我们直接说结果</p> 
<p><span style="color:#fe2c24;">RabbitMQ在每个阶段都有可能使消息发生丢失</span></p> 
<p><img alt="" height="350" src="https://images2.imgbox.com/ee/ff/JvZjomjF_o.png" width="1200"></p> 
<p>我们在这里把他们简单归结为三个层面</p> 
<p>层面一 ：生产者发送消息没有到达交换机或者没有到达绑定的队列。</p> 
<p>层面二：RabbitMQ宕机可能导致的消息的丢失。</p> 
<p>层面三：消费者宕机导致消息丢失。</p> 
<p></p> 
<p></p> 
<p>层面一的解决方法常见的是</p> 
<p>1.<span style="color:#fe2c24;">生产者确认机制</span></p> 
<p>RabbitMQ提供了publisher confirm机制来避免消息发送到Mq的过程中丢失，消息发送到Mq以后，会返回一个结果给发送者，表示消息的发送成功。</p> 
<p>情况一：<span style="color:#fe2c24;">发送成功 </span>生产者正常发送消息到队列之后会返回一个publish-confirm ack 这个意思是告诉生产者已经接收到消息了。</p> 
<p>情况二：<span style="color:#fe2c24;">发送失败 </span><span style="color:#0d0016;">这里的发送失败有两种，一种是生产者发送到交换机失败 此时返回 </span>publish-confirm nack  。第二种是生产者发送到队列失败 返回 publish-return ack。</p> 
<p><img alt="" height="400" src="https://images2.imgbox.com/30/09/Njxo1XE9_o.png" width="1200"></p> 
<p>开启生产者确认机制的代码如下 ，在生产者的配置文件中加入以下配置<br>  </p> 
<pre><code class="language-XML">spring:
  rabbitmq:
    publisher-confirm-type: correlated #开启生产者确认机制
    publisher-returns: true</code></pre> 
<p>这里的</p> 
<pre>publisher-confirm-type:有三种模式可以选择：</pre> 
<p><span style="color:#4da8ee;">第一种是none：代表关闭confirm机制</span></p> 
<p><span style="color:#4da8ee;">第二种是 simple：表示同步阻塞并等待mq的回执消息，即发送完消息后不能干其他的事情，只能等待mq的回执，很显然这样效率很低。</span></p> 
<p><span style="color:#4da8ee;">第三种是correlated：MQ异步回调方式返回回执消息，即生产者发送完消息后可以干其他的事情，直到接收到mq的回执。很明显这种效率要优于第二种。</span></p> 
<p>配置return callback的代码如下，每个RabbitTemplate只能配置一个 代码如下<br>  </p> 
<pre><code class="language-java">package com.itheima.publisher.com.it.heima.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.core.ReturnedMessage;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.annotation.Configuration;

/**
 * @Auther: QuJingChuan
 * @Date: 2024/1/13 10:34
 * @Description:
 */
@Slf4j
@Configuration
public class MqConfirmConfig implements ApplicationContextAware {
    @Autowired
    private RabbitTemplate rabbitTemplate;
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        //配置回调
        rabbitTemplate.setReturnsCallback(new RabbitTemplate.ReturnsCallback() {
            @Override
            public void returnedMessage(ReturnedMessage returnedMessage) {
                log.debug("收到消息return的callback,  {},{},{},{},{}",
                        returnedMessage.getExchange(),
                        returnedMessage.getRoutingKey(),
                        returnedMessage.getMessage(),
                        returnedMessage.getReplyCode(),
                        returnedMessage.getReplyText());
            }
        });
    }
}</code></pre> 
<p></p> 
<p>Confirm Callback需要每次发消息的时候都要配置（要制定发消息的id方便回执的时候直到是谁发的消息）这里写一个测试类方便大家看。</p> 
<pre><code class="language-java"> @Test
    void testConfirmCallback() throws InterruptedException {
        //创建cd 参数为每次发送消息的id
        CorrelationData correlationData = new CorrelationData(UUID.randomUUID().toString());
        //添加confirmCallBack
        correlationData.getFuture().addCallback(new ListenableFutureCallback&lt;CorrelationData.Confirm&gt;() {
            @Override
            public void onFailure(Throwable ex) {
                //这种情况一般是运行出现bug，一般不会发生。
                log.error("消息回调失败",ex);
            }

            @Override
            public void onSuccess(CorrelationData.Confirm result) {
                log.debug("收到confirm callback 回执");
                if (result.isAck()){
                    //消息发送成功
                    log.debug("消息发送成功收到ack");
                }else {
                    //消息发送失败
                    log.debug("消息发送失败收到nack，原因：{}",result.getReason());
                    //TODO 重发消息等业务
                }
            }
        });

        rabbitTemplate.convertAndSend("amqp.test","amqptest","hello qjc",correlationData);

        Thread.sleep(2000);
    }</code></pre> 
<p></p> 
<p>那么我们如何解决这个问题呢<br> 方案一：重发消息 </p> 
<p>方案二：记录日志</p> 
<p>方案三：保存到数据库中定时发送，发送成功后删除表中的数据。</p> 
<p>方案四：交给人工处理。</p> 
<p><span style="color:#fe2c24;">~生产者确认机制需要额外的网络和系统的资源开销，尽量不要使用。</span></p> 
<p><span style="color:#fe2c24;">~如果业务需要，那么无需开启publisher-return机制，因为一般路由失败都是自己业务的原因。</span></p> 
<p><span style="color:#fe2c24;">~对于nack消息可以有限次数的重试，依然失败则记录异常消息。</span></p> 
<p></p> 
<p>层面二的解决方法常见的是</p> 
<p>2.<span style="color:#fe2c24;">消息持久化</span></p> 
<p>由于mq是基于内存存储消息的，那么在mq服务宕机等一些情况下可能导致消息的丢失。同时内存空间有限，当消费者出现故障或者处理过慢，会导致消息积压，mq会对消息做迁移（page out 写入磁盘）从而引发mq阻塞。我们将消息存储在磁盘上就避免了这个问题。</p> 
<p>一 ：持久化交换机。</p> 
<p><img alt="" height="364" src="https://images2.imgbox.com/18/59/smSjuvrx_o.png" width="798"></p> 
<p>这里要选择Durable,因为Transient是临时交换机，当mq宕机后会消失。</p> 
<p>或</p> 
<p>代码展示<br>  </p> 
<pre><code class="language-java"> @Bean
    public DirectExchange simpleExchange(){
        //分别是三个参数 交换机名称 是否持久化 当没有队列绑定时是否自动删除
        return new DirectExchange("qjc.exchange",true,false);
    }</code></pre> 
<p>二 ：持久化队列。</p> 
<p><img alt="" height="397" src="https://images2.imgbox.com/a4/01/NIkYoxyz_o.png" width="990"></p> 
<p>这个与交换机类似，在此不做赘述。</p> 
<p>或</p> 
<p>代码展示</p> 
<pre><code class="language-java">@Bean
    public Queue simpleQueue(){
        //springamqp在使用QueueBuilder来创建队列的时候，默认就是持久化的
        return QueueBuilder.durable("qjc.queue").build();
    }</code></pre> 
<p>三 ：持久化消息。</p> 
<p><img alt="" height="538" src="https://images2.imgbox.com/1c/f7/zdPq5Bhg_o.png" width="1050"></p> 
<p>这里选择delivery mode 选择2 ,1是不持久的。</p> 
<p>或</p> 
<p>代码展示</p> 
<pre><code class="language-java"> Message message = MessageBuilder.withBody("hello".getBytes(StandardCharsets.UTF_8))
                .setDeliveryMode(MessageDeliveryMode.PERSISTENT)
                .build();</code></pre> 
<h5><span style="color:#0d0016;"><strong>如果不选择持久化队列，交换机，消息的话我们还有另一种方案</strong></span></h5> 
<p>Lazy Queue（惰性队列）</p> 
<p>惰性队列的特征如下</p> 
<p><span style="color:#fe2c24;">~接受到消息的时候直接存入磁盘而非内存（内存中只保留最近的消息）</span></p> 
<p><span style="color:#fe2c24;">~消费者需要消息的时候才会从磁盘中取出数据加载到内存</span></p> 
<p><span style="color:#fe2c24;">~支持数百万条的消息存储</span></p> 
<p><span style="color:#fe2c24;">在mq3.12版本后，所有的队列都是Lazy Queue模式，无法更改。</span></p> 
<p>如果各位小伙伴的版本低于3.12那我这里提供了两种方式创建惰性队列</p> 
<p><img alt="" height="307" src="https://images2.imgbox.com/ec/f5/abG4yyAA_o.png" width="1200"></p> 
<p>或</p> 
<p><img alt="" height="241" src="https://images2.imgbox.com/d2/78/FMAIoLYN_o.png" width="1126"></p> 
<p>或用注解声明</p> 
<pre><code class="language-java">    @RabbitListener(queuesToDeclare = @Queue(
            name = "lazy.queue",
            durable = "true",
            arguments = @Argument(name = "x-queue-mode",value = "lazy")
    ))
    public void listenLazyQueue(String msg){
        log.debug("接收到lazyqueue的消息" + msg);
    }</code></pre> 
<p></p> 
<p>3.<span style="color:#fe2c24;">消费者确认机制</span></p> 
<p>RabbitMQ支持消费者确认机制，即：当消费者处理消息后可以向mq发送ack回执，mq收到消息后会在队列中删除该消息。</p> 
<p><img alt="" height="402" src="https://images2.imgbox.com/15/29/9muPl7g4_o.png" width="1200"></p> 
<p>SpringAMQP已经实现了消息确认的功能，并且允许我们通过配置文件选择ack的处理方式，有三种方式。</p> 
<p><span style="color:#fe2c24;">- none: 不处理。即消息投递给消费者后立刻ack，消息会立刻从MQ删除。非常不安全，不建议使用  <br> - manual: 手动模式。需要自己在业务代码中调用api，发送ack或reject，存在业务入侵，但更灵活  <br> - auto: 自动模式。SpringAMQP利用AOP对我们的消息处理逻辑做了环绕增强，当业务正常执行时则自动返回ack.  <br> 当业务出现异常时，根据异常判断返回不同结果:  <br> - 如果是业务异常，会自动返回nack  <br> - 如果是消息处理或校验异常，自动返回reject</span></p> 
<p><span style="color:#0d0016;">注意我们需要再消费者的配置文件中加入参数</span></p> 
<p><img alt="" height="383" src="https://images2.imgbox.com/85/e3/IIBSoWwo_o.png" width="858"></p> 
<p>这就是mq保证消息不丢失的一些方式和解决方案。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0a5e1952571754502a2ccf9ba2fc2c0a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring Authorization Server入门 (十二) 实现授权码模式使用前后端分离的登录页面</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8e189542c9f4930bb9facfa8ef439680/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">无公网IP实现远程访问MongoDB文件数据库【内网穿透】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>