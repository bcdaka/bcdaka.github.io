<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>高级数据结构 ＜AVL树＞ - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/89a117916bb636c4d55a5377f2681e85/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="高级数据结构 ＜AVL树＞">
  <meta property="og:description" content="本文已收录至《数据结构(C/C&#43;&#43;语言)》专栏！
作者：ARMCSKGT 目录 前言正文AVL树的性质AVL树的定义AVL树的插入函数左单旋右单旋右左双旋左右双旋 检验AVL树的合法性关于AVL树 最后 前言 前面我们学习了二叉树，普通的二叉树没有任何特殊性质，所以后面我们又学习了二叉搜索树，这种有序的结构一定程度上优化了二叉树的性能，但是普通的二叉搜索树在特殊情况下，例如插入序列从大到小有序时，二叉搜索树会退化成类似于链表的单支数，此时性能变为O(n)，为了解决这个问题，科学家在二叉搜索树的基础上再次进行升级，而有了我们现在常见的 AVL树 和 红黑树 ，本节我们将介绍AVL树的基础性质。
正文 在介绍AVL树之前，如果你没有了解过 二叉搜索树 或 二叉树，请移步先了解前置知识！
本节介绍AVL树默认中序遍历为升序序列
AVL树的性质 二叉搜索树虽可以缩短查找的效率，但如果数据有序或接近有序二叉搜索树将退化为单支树，查找元素相当于在顺序表中搜索元素，效率低下。
因此，两位俄罗斯的数学家 G.M.Adelson-Velskii 和 E.M.Landis 在1962年发明了一种解决上述问题的方法：当向二叉搜索树中插入新结点后，如果能保证每个结点的左右子树高度之差的绝对值不超过1(需要对树中的结点进行调整)，即可降低树的高度，从而减少平均搜索长度。
简而言之，AVL树通过一个 平衡因子bf(右子树深度减去左子树深度) 来记录根节点左右子树深度的差，一般情况下，平衡因子只会有五种情况：
左子树比右子树深度高两层，此时平衡因子为 -2 ，此时需要对树进行旋转调整左子树比右子树深度高一层，此时平衡因子为 -1左子树与右子树深度相等，此时平衡因子为 0左子树比右子树深度低一层，此时平衡因子为 1左子树比右子树深度低两层，此时平衡因子为 2 ，此时需要对树进行旋转调整 综上，如果二叉搜索树具备以下性质，则为AVL树：
左右子树的高度之差（平衡因子）的绝对值不超过 1它的左右子树都是 AVL 树 AVL树结构（节点上的数字就是平衡因子）：
这颗树没有出现不平衡的情况，每个节点的平衡因子的绝对值不超过2。
这样看来，AVL树是一颗高度平衡的二叉搜索树，如果AVL树有N个节点，则AVL树的高度为 log ⁡ n \log_n logn​，此时找到任意节点的时间复杂度都是O( log ⁡ 2 N \log_2N log2​N)。
我们学习AVL树主要是研究其插入节点后如何保持平衡的思想！
AVL树的定义 AVL树在二叉树的基础上，增加了一个指针指向了父节点以及一个平衡因子，所以AVL树是三叉链结构！
节点定义代码：
#include &lt;iostream&gt; template&lt;class K,class V&gt; struct TreeNode { TreeNode&lt;K, V&gt;* _left; // 左子树 TreeNode&lt;K, V&gt;* _right;	// 右子树 TreeNode&lt;K, V&gt;* _parent; // 父节点 std::pair&lt;K, V&gt; _val; // 节点键值对(节点值) int _bf;	// 平衡因子 TreeNode() :_left (nullptr) ,_right (nullptr) ,_parent(nullptr) ,_val(pair&lt;K,V&gt;()) ,_bf(0) {} TreeNode(const pair&lt;K,V&gt;&amp; val) :_left (nullptr) , _right (nullptr) , _parent(nullptr) , _val(val) , _bf(0) {} TreeNode(const K&amp; key,const V&amp; val) :_left(nullptr) , _right(nullptr) , _parent(nullptr) , _val({key,val}) , _bf(0) {} }; AVL树的定义比较简单，只需要一个根节点_root记录即可。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-27T13:33:21+08:00">
    <meta property="article:modified_time" content="2024-03-27T13:33:21+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">高级数据结构 ＜AVL树＞</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p><img src="https://images2.imgbox.com/63/74/QrdFrI6p_o.jpg" alt="AVL树标题"><br> <br> <em></em></p> 
 <center> 
  <strong>本文已收录至《<a href="https://blog.csdn.net/m0_73446322/category_12100295.html">数据结构(C/C++语言)</a>》专栏！<br> 作者：<a href="https://blog.csdn.net/m0_73446322?spm=1011.2421.3001.5343">ARMCSKGT</a></strong> 
 </center> 
 <br> 
 <img src="https://images2.imgbox.com/0e/86/JAVDGrg9_o.gif" alt="CSDN"> 
 <p></p> 
</blockquote> 
<hr> 
<p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_8" rel="nofollow">前言</a></li><li><a href="#_12" rel="nofollow">正文</a></li><li><ul><li><a href="#AVL_15" rel="nofollow">AVL树的性质</a></li><li><a href="#AVL_46" rel="nofollow">AVL树的定义</a></li><li><a href="#AVL_118" rel="nofollow">AVL树的插入函数</a></li><li><ul><li><a href="#_225" rel="nofollow">左单旋</a></li><li><a href="#_291" rel="nofollow">右单旋</a></li><li><a href="#_349" rel="nofollow">右左双旋</a></li><li><a href="#_440" rel="nofollow">左右双旋</a></li></ul> 
   </li><li><a href="#AVL_535" rel="nofollow">检验AVL树的合法性</a></li><li><a href="#AVL_608" rel="nofollow">关于AVL树</a></li></ul> 
  </li><li><a href="#_625" rel="nofollow">最后</a></li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_8"></a>前言</h2> 
<p>前面我们学习了二叉树，普通的二叉树没有任何特殊性质，所以后面我们又学习了二叉搜索树，这种有序的结构一定程度上优化了二叉树的性能，但是普通的二叉搜索树在特殊情况下，例如插入序列从大到小有序时，二叉搜索树会退化成类似于链表的单支数，此时性能变为O(n)，为了解决这个问题，科学家在二叉搜索树的基础上再次进行升级，而有了我们现在常见的 <code>AVL树</code> 和 <code>红黑树</code> ，本节我们将介绍AVL树的基础性质。<br> <img src="https://images2.imgbox.com/2b/9b/UUzyzrwy_o.png" alt="AVL树配图"></p> 
<hr> 
<h2><a id="_12"></a>正文</h2> 
<p>在介绍AVL树之前，如果你没有了解过 <strong><a href="https://blog.csdn.net/m0_73446322/article/details/134784892">二叉搜索树</a></strong> 或 <strong><a href="https://blog.csdn.net/m0_73446322/article/details/128394450">二叉树</a></strong>，请移步先了解前置知识！<br> <code>本节介绍AVL树默认中序遍历为升序序列</code></p> 
<blockquote> 
 <h3><a id="AVL_15"></a>AVL树的性质</h3> 
 <hr> 
 <p>二叉搜索树虽可以缩短查找的效率，但如果数据有序或接近有序二叉搜索树将退化为单支树，查找元素相当于在顺序表中搜索元素，效率低下。<br> <br> 因此，两位俄罗斯的数学家 <strong>G.M.Adelson-Velskii</strong> 和 <strong>E.M.Landis</strong> 在1962年发明了一种解决上述问题的方法：<mark>当向二叉搜索树中插入新结点后，如果能保证每个结点的左右子树高度之差的绝对值不超过1(需要对树中的结点进行调整)，即可降低树的高度，从而减少平均搜索长度</mark>。<br> <br> 简而言之，AVL树通过一个 <strong>平衡因子bf(右子树深度减去左子树深度)</strong> 来记录根节点左右子树深度的差，一般情况下，平衡因子只会有五种情况：</p> 
 <ul><li>左子树比右子树深度高两层，此时平衡因子为 -2 ，此时需要对树进行旋转调整</li><li>左子树比右子树深度高一层，此时平衡因子为 -1</li><li>左子树与右子树深度相等，此时平衡因子为 0</li><li>左子树比右子树深度低一层，此时平衡因子为 1</li><li>左子树比右子树深度低两层，此时平衡因子为 2 ，此时需要对树进行旋转调整</li></ul> 
 <br> 
 <br> 
 <p>综上，如果二叉搜索树具备以下性质，则为AVL树：</p> 
 <ul><li>左右子树的高度之差（平衡因子）的绝对值不超过 1</li><li>它的左右子树都是 AVL 树</li></ul> 
 <br> 
 <p>AVL树结构（节点上的数字就是平衡因子）：<br> <img src="https://images2.imgbox.com/18/ac/06hfL5x0_o.png" alt=""><br> 这颗树没有出现不平衡的情况，每个节点的平衡因子的绝对值不超过2。<br> <br> <strong>这样看来，AVL树是一颗高度平衡的二叉搜索树，如果AVL树有N个节点，则AVL树的高度为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
           
            
            
              log 
             
            
              ⁡ 
             
            
           
             n 
            
           
          
         
           \log_n 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.9386em; vertical-align: -0.2441em;"></span><span class="mop"><span class="mop">lo<span style="margin-right: 0.0139em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.0573em;"><span class="" style="top: -2.4559em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2441em;"><span class=""></span></span></span></span></span></span></span></span></span></span>，此时找到任意节点的时间复杂度都是O(<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
           
            
            
              log 
             
            
              ⁡ 
             
            
           
             2 
            
           
          
            N 
           
          
         
           \log_2N 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.9386em; vertical-align: -0.2441em;"></span><span class="mop"><span class="mop">lo<span style="margin-right: 0.0139em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.207em;"><span class="" style="top: -2.4559em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2441em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span></span></span></span></span>)。</strong><br> <br> 我们学习AVL树主要是研究其插入节点后如何保持平衡的思想！</p> 
</blockquote> 
<hr> 
<blockquote> 
 <h3><a id="AVL_46"></a>AVL树的定义</h3> 
 <hr> 
 <p>AVL树在二叉树的基础上，增加了一个指针指向了父节点以及一个平衡因子，所以AVL树是三叉链结构！<br> <img src="https://images2.imgbox.com/88/1c/migCbsRA_o.png" alt=""><br> <strong>节点定义代码：</strong></p> 
 <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">K</span><span class="token punctuation">,</span><span class="token keyword">class</span> <span class="token class-name">V</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">TreeNode</span>
<span class="token punctuation">{<!-- --></span>
	TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span><span class="token operator">*</span>  _left<span class="token punctuation">;</span>     <span class="token comment">// 左子树</span>
	TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span><span class="token operator">*</span>  _right<span class="token punctuation">;</span>	<span class="token comment">// 右子树</span>
	TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span><span class="token operator">*</span>  _parent<span class="token punctuation">;</span>   <span class="token comment">// 父节点</span>
	std<span class="token double-colon punctuation">::</span>pair<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span>  _val<span class="token punctuation">;</span>      <span class="token comment">// 节点键值对(节点值)</span>
	<span class="token keyword">int</span>              _bf<span class="token punctuation">;</span>	    <span class="token comment">// 平衡因子</span>

	<span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_left</span>  <span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token punctuation">,</span><span class="token function">_right</span> <span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token punctuation">,</span><span class="token function">_parent</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token punctuation">,</span><span class="token function">_val</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">pair</span><span class="token generic class-name"><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">,</span><span class="token function">_bf</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

	<span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">const</span> pair<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">&gt;</span><span class="token operator">&amp;</span> val<span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_left</span>   <span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_right</span> <span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_parent</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_val</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_bf</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

	<span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">const</span> K<span class="token operator">&amp;</span> key<span class="token punctuation">,</span><span class="token keyword">const</span> V<span class="token operator">&amp;</span> val<span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_left</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_right</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_parent</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_val</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>key<span class="token punctuation">,</span>val<span class="token punctuation">}</span><span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_bf</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
 <br> 
 <p>AVL树的定义比较简单，只需要一个根节点_root记录即可。<br> 但是为了我们可以控制对比的函数，以便随我们指定的方式去插入，就像sort函数一样，可以通过仿函数控制升序和降序排序，所以我们还需要一个模板参数去作为比较函数！<br> <strong>AVL树定义：</strong></p> 
 <pre><code class="prism language-cpp"><span class="token comment">//仿函数控制比较方式</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token comment">//升序</span>
<span class="token keyword">struct</span> <span class="token class-name">less</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> left<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token comment">//降序</span>
<span class="token keyword">struct</span> <span class="token class-name">greater</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> left<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> left <span class="token operator">&gt;</span> right<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//AVL树定义 默认升序(按中序输出序列)</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">V</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Compare</span> <span class="token operator">=</span> less<span class="token operator">&lt;</span>K<span class="token operator">&gt;&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">AVLTree</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">typedef</span> std<span class="token double-colon punctuation">::</span>pair<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span> val_type<span class="token punctuation">;</span> <span class="token comment">//值类型</span>
	<span class="token keyword">typedef</span> TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span>  Node<span class="token punctuation">;</span>     <span class="token comment">//节点类型</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">AVLTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">_root</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_size</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	Node<span class="token operator">*</span>   _root<span class="token punctuation">;</span> <span class="token comment">//根节点</span>
	size_t  _size<span class="token punctuation">;</span> <span class="token comment">//节点数量</span>
	Compare _com<span class="token punctuation">;</span>  <span class="token comment">//比较函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
</blockquote> 
<hr> 
<blockquote> 
 <h3><a id="AVL_118"></a>AVL树的插入函数</h3> 
 <hr> 
 <p>在二叉搜索树的插入函数基础上，AVL树的插入操作还需要对父节点的平衡因子进行调节，并在失衡的根节点处进行旋转调整。</p> 
 <br> 
 <blockquote> 
  <p>AVL树插入流程：</p> 
  <ul><li>如果是第一次插入节点，直接赋值给 _root 作为根节点，_size+1。</li><li>将插入值的key与当前节点值传入 _com函数 中对比，当函数返回true时向左子树走，返回false时向右子树走，如果走到空则跳出准备插入，如果相等则返回当前节点值。</li><li>根据节点值与插入值key在_com函数中的对比结果，决定插入到父节点的左子树还是右子树。</li><li>调整父节点的平衡因子，如果出现失衡（平衡因子绝对值为2）则进行旋转，并依次向上继续调整祖父节点，直到当前父节点平衡因子为0或节点为树的根节点为止。</li><li>_size+1并返回插入结果。<br> </li></ul> 
 </blockquote> 
 <p>关于AVL树的返回值：AVL树返回值为 <strong>pair&lt;val_type,bool&gt;</strong>，当插入成功在返回节点值的同时并返回true，当插入失败(遇到相等值节点时)返回false。</p> 
 <br> 
 <p>插入函数代码：</p> 
 <pre><code class="prism language-cpp"><span class="token comment">//插入函数</span>
pair<span class="token operator">&lt;</span>val_type<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">&gt;</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">const</span> val_type<span class="token operator">&amp;</span> data<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//首次插入特殊处理</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">nullptr</span> <span class="token operator">==</span> _root<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		Node<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
		_root <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
		<span class="token operator">++</span>_size<span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span> data<span class="token punctuation">,</span><span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//寻找合适的插入位置</span>
	Node<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
	Node<span class="token operator">*</span> parent <span class="token operator">=</span> _root<span class="token punctuation">;</span>
	Node<span class="token operator">*</span> cur <span class="token operator">=</span> _root<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_com</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>first<span class="token punctuation">,</span> cur<span class="token operator">-&gt;</span>_val<span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment">// &lt;</span>
		<span class="token punctuation">{<!-- --></span>
			parent <span class="token operator">=</span> cur<span class="token punctuation">;</span>
			cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_com</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_val<span class="token punctuation">.</span>first<span class="token punctuation">,</span> data<span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// &gt;</span>
		<span class="token punctuation">{<!-- --></span>
			parent <span class="token operator">=</span> cur<span class="token punctuation">;</span>
			cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//找到相同值节点 返回false和节点值</span>
		<span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span> data<span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                 <span class="token comment">// ==</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//将新节点插入所寻找的父节点下</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_com</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>first<span class="token punctuation">,</span> parent<span class="token operator">-&gt;</span>_val<span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span> parent<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
	<span class="token keyword">else</span> parent<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
	newnode<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>
	cur <span class="token operator">=</span> newnode<span class="token punctuation">;</span>

	<span class="token keyword">while</span> <span class="token punctuation">(</span>parent<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//调整父节点平衡因子</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-&gt;</span>_left <span class="token operator">==</span> cur<span class="token punctuation">)</span> <span class="token operator">--</span><span class="token punctuation">(</span>parent<span class="token operator">-&gt;</span>_bf<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-&gt;</span>_right <span class="token operator">==</span> cur<span class="token punctuation">)</span> <span class="token operator">++</span><span class="token punctuation">(</span>parent<span class="token operator">-&gt;</span>_bf<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">//调整和旋转</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-&gt;</span>_bf <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> parent<span class="token operator">-&gt;</span>_bf <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			parent <span class="token operator">=</span> parent<span class="token operator">-&gt;</span>_parent<span class="token punctuation">;</span>
			cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_parent<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-&gt;</span>_bf <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token keyword">else</span> <span class="token comment">//开始调整和旋转</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-&gt;</span>_bf <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">2</span> <span class="token operator">&amp;&amp;</span> cur<span class="token operator">-&gt;</span>_bf <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">RotateR</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//右单旋</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-&gt;</span>_bf <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> cur<span class="token operator">-&gt;</span>_bf <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">RotateL</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//左单旋</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-&gt;</span>_bf <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">2</span> <span class="token operator">&amp;&amp;</span> cur<span class="token operator">-&gt;</span>_bf <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">RotateLR</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//左右旋</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-&gt;</span>_bf <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> cur<span class="token operator">-&gt;</span>_bf <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">RotateRL</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//右左旋</span>
			<span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span> <span class="token function">assert</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token operator">++</span>_size<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span> data<span class="token punctuation">,</span><span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
 <br> 
 <blockquote> 
  <p>关于节点调整流程：<br> <img src="https://images2.imgbox.com/ef/16/rSAkeXRl_o.png" alt=""><br> 关于旋转调整节点，我们接下来进行详细探究！</p> 
 </blockquote> 
   
 <blockquote> 
  <p>关于需要调整的情况，一共可以分为四大类：<br> <img src="https://images2.imgbox.com/33/11/XPiprOr6_o.png" alt="旋转"><br> 是否旋转，取决于parent和cur节点的平衡因子：</p> 
  <table><thead><tr><th>parent(父节点)平衡因子</th><th>cur(子节点)平衡因子</th><th>操作</th></tr></thead><tbody><tr><td>-2</td><td>-1</td><td>右单旋</td></tr><tr><td>2</td><td>1</td><td>左单旋</td></tr><tr><td>-2</td><td>1</td><td>左右双旋</td></tr><tr><td>2</td><td>-1</td><td>右左双旋</td></tr></tbody></table> 
 </blockquote> 
 <hr> 
 <h4><a id="_225"></a>左单旋</h4> 
 <p><strong>当根节点的右子树平衡因子为1的情况下，仍然向右子树中插入比右子树节点值大的节点，此时就会导致根节点平衡因子为2，右子树平衡因子为1，此时就需要左单旋。</strong><br> <img src="https://images2.imgbox.com/53/15/0S9lKW5v_o.png" alt="在这里插入图片描述"><br> 当我们向20节点的右子树中插入35时，35是该树中的最大节点，便会插入在最右节点，此时30节点的平衡因子变为1，25节点则变为2，需要对其进行左单旋。</p> 
 <br> 
 <p><strong>左单旋的函数代码：</strong></p> 
 <pre><code class="prism language-cpp"><span class="token comment">//左单旋</span>
<span class="token keyword">void</span> <span class="token function">RotateL</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> parent<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//parent右子节点</span>
	Node<span class="token operator">*</span> childR <span class="token operator">=</span> parent<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>
	<span class="token comment">//parent右子节点的左子节点</span>
	Node<span class="token operator">*</span> childRL <span class="token operator">=</span> childR<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>
	<span class="token comment">//parent右子节点的右子节点</span>
	Node<span class="token operator">*</span> childRR <span class="token operator">=</span> childR<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>
	<span class="token comment">//parent节点的父节点</span>
	Node<span class="token operator">*</span> pparent <span class="token operator">=</span> parent<span class="token operator">-&gt;</span>_parent<span class="token punctuation">;</span>

	<span class="token comment">//parent节点的右指向childR的左子树</span>
	parent<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> childRL<span class="token punctuation">;</span>
	<span class="token comment">//如果childRL节点存在 则链接与parent节点的关系 否则parent-&gt;_right指向空</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>childRL<span class="token punctuation">)</span> childRL<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>
	<span class="token comment">//将childR的左指向parent 构建链接关系</span>
	childR<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> parent<span class="token punctuation">;</span>
	parent<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> childR<span class="token punctuation">;</span>

	<span class="token comment">//与pparent构建链接关系 如果pparent为_root根节点 则设置_root</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>pparent <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		_root <span class="token operator">=</span> childR<span class="token punctuation">;</span>
		_root<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token comment">//否则查看原parent节点是pparent的左还是右子树 插入原parent位置</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>pparent<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> parent<span class="token punctuation">)</span> pparent<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> childR<span class="token punctuation">;</span>
		<span class="token keyword">else</span> pparent<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> childR<span class="token punctuation">;</span>

		childR<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> pparent<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//更新受影响节点的平衡因子</span>
	parent<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> childR<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
 <p>旋转过程简而言之就是更改节点的链接关系，使其深度降低！<br> <br> <strong>对于上面图中的树，我们根据左单旋进行调整：</strong><br> <img src="https://images2.imgbox.com/67/be/hgn3FGtv_o.png" alt="左单旋"><br> </p> 
 <blockquote> 
  <p>左单旋过程梳理：</p> 
  <ul><li>parent节点与childRL节点构建链接关系</li><li>childR节点的左子树置为parent，并相互构建链接关系</li><li>判断pparent是否为空，不为空则将childR与pparent构建链接关系</li><li>将parent节点与childR节点的平衡因子置为0</li></ul> 
  <br> 
  <p>注意：这里在构建链接关系时，一定要注意构建与父节点的关系，容易忘记；childRL节点可能为空，如果为空则不需要与其新父节点(parent)构建链接关系，需要if判断！</p> 
 </blockquote> 
 <br> 
 <hr> 
 <h4><a id="_291"></a>右单旋</h4> 
 <p><strong>当根节点的左子树平衡因子为-1的情况下，仍然向左子树中插入比左子树节点值小的节点，此时就会导致根节点平衡因子为-2，左子树平衡因子为-1，此时就需要右单旋。</strong><br> <img src="https://images2.imgbox.com/47/03/aGWVY6GN_o.png" alt="右单旋"><br> 右单旋与左单旋相似，只不过指针的调整方式不同。<br> 当节点3插入后，节点10的平衡因子(左右子树高度差为2)为-2，此时插入的节点位于左子树的左侧，此时需要右旋转。</p> 
 <br> 
 <p><strong>右单旋的函数代码：</strong></p> 
 <pre><code class="prism language-cpp"><span class="token comment">//右单旋</span>
<span class="token keyword">void</span> <span class="token function">RotateR</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> parent<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Node<span class="token operator">*</span> childL <span class="token operator">=</span> parent<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>
	Node<span class="token operator">*</span> childLL <span class="token operator">=</span> childL<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>
	Node<span class="token operator">*</span> childLR <span class="token operator">=</span> childL<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>
	Node<span class="token operator">*</span> pparent <span class="token operator">=</span> parent<span class="token operator">-&gt;</span>_parent<span class="token punctuation">;</span>

	parent<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> childLR<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>childLR<span class="token punctuation">)</span> childLR<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>
	childL<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> parent<span class="token punctuation">;</span>
	parent<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> childL<span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>pparent <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		_root <span class="token operator">=</span> childL<span class="token punctuation">;</span>
		_root<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>pparent<span class="token operator">-&gt;</span>_left <span class="token operator">==</span> parent<span class="token punctuation">)</span> pparent<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> childL<span class="token punctuation">;</span>
		<span class="token keyword">else</span> pparent<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> childL<span class="token punctuation">;</span>

		childL<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> pparent<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	parent<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> childL<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
 <br> 
 <p><strong>对于上面图中的树，我们根据右单旋进行调整：</strong><br> <img src="https://images2.imgbox.com/7c/b9/tBEtzSPZ_o.png" alt="右单旋"></p> 
 <br> 
 <blockquote> 
  <p>右单旋过程梳理：</p> 
  <ul><li>parent节点与childLR节点构建链接关系</li><li>childL节点的右子树置为parent，并相互构建链接关系</li><li>判断pparent是否为空，不为空则将childL与pparent构建链接关系</li><li>将parent节点与childL节点的平衡因子置为0</li></ul> 
  <br> 
  <p>注意：这里在构建链接关系时，一定要注意构建与父节点的关系，容易忘记；childLR节点可能为空，如果为空则不需要与其新父节点(parent)构建链接关系，需要if判断！</p> 
 </blockquote> 
 <hr> 
 <h4><a id="_349"></a>右左双旋</h4> 
 <p>当我们将值插入(高度差为1的树时)右子树右侧时会引发左单旋，当插入左子树左侧时会引发右单旋。<br> <br> 相反，如果将值插入右子树左侧或左子树右侧，则会引发双旋。<br> 如果插入的是右子树左侧，此时parent平衡因子为，那么单旋就不能解决问题了，此时需要右左双旋，<strong>详细解释就是先 <mark>进行右单旋 再进行左单旋</mark></strong>，这样才能降低高度。</p> 
 <br> 
 <p><strong>关于以下情况，就是需要进行右左双旋：</strong><br> <img src="https://images2.imgbox.com/33/5b/aAB3ZkdD_o.png" alt="右左双旋插入情况"></p> 
 <br> 
 <p><strong>右左双旋代码：</strong></p> 
 <pre><code class="prism language-cpp"><span class="token comment">//右左双旋</span>
<span class="token keyword">void</span> <span class="token function">RotateRL</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> parent<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Node<span class="token operator">*</span> childR  <span class="token operator">=</span> parent<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>
	Node<span class="token operator">*</span> childRL <span class="token operator">=</span> childR<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>
	<span class="token keyword">int</span> bf <span class="token operator">=</span> childRL<span class="token operator">-&gt;</span>_bf<span class="token punctuation">;</span>

	<span class="token function">RotateR</span><span class="token punctuation">(</span>childR<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">RotateL</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/*
			A
		B        C
			    D
			  E
	*/</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>bf <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		parent<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		childR<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		childRL<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">/*
			A
		B        C
			    D
			     E
	*/</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bf <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		parent<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
		childR<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		childRL<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">/*
		A
		    B
		  C
	*/</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bf <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		parent<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		childR<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		childRL<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//如果出现其他情况，则表示代码有问题，需要检查</span>
	<span class="token keyword">else</span> <span class="token function">assert</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
 <p><strong>关于右左双旋，可以结合下图理解(三列情况，对应三种不同的平衡因子调整)：</strong><br> <img src="https://images2.imgbox.com/01/d0/sXuWX2Dh_o.png" alt="右左双旋"></p> 
 <br> 
 <blockquote> 
  <p><strong>关于右左双旋的过程：</strong></p> 
  <ul><li>先确定parent和childR和childRL节点</li><li>对childR进行右单旋(将childRL变成childR的父节点)</li><li>对parent进行左单旋(再将childRL变成childR的父节点)</li><li>调整parent,childR和childRL节点的平衡因子(根据childRL节点平衡因子调整)</li></ul> 
 </blockquote> 
 <br> 
 <blockquote> 
  <p><strong>关于节点平衡因子的调整，从上图看出来，需要根据childRL节点来进行判断：</strong></p> 
  <ul><li>当childRL平衡因子为 <mark>0</mark> ：<code>parent</code>的平衡因子调整为<code>0</code>，<code>childR</code>的平衡因子调整为<code>0</code>，<code>childRL</code>平衡因子调整为<code>0</code>。</li><li>当childRL平衡因子为 <mark>-1</mark> ：<code>parent</code>的平衡因子调整为<code>0</code>，<code>childR</code>的平衡因子调整为<code>1</code>，<code>childRL</code>平衡因子调整为<code>0</code>。</li><li>当childRL平衡因子为 <mark>1</mark> ：<code>parent</code>的平衡因子调整为<code>-1</code>，<code>childR</code>的平衡因子调整为<code>0</code>，<code>childRL</code>平衡因子调整为<code>0</code>。</li></ul> 
 </blockquote> 
 <br> 
 <p>注意：右左双旋中，<strong>对childR进行右单旋转再对parent进行左单旋，这个顺序不能颠倒</strong>，且平衡因子的调整必须根据childRL平衡因子进行调整。</p> 
 <hr> 
 <h4><a id="_440"></a>左右双旋</h4> 
 <p>当节点插入到左子树的右侧时，此时parent平衡因子为-2且childR平衡因子为1，此时需要左右双旋，即需要 <strong>先进行左单旋，再进行右单旋</strong> 才能降低高度。</p> 
 <br> 
 <p><strong>关于以下插入情况，此时的树需要进行左右双旋：</strong><br> <img src="https://images2.imgbox.com/20/90/iomIwMGy_o.png" alt="左右双旋插入情况"></p> 
 <br> 
 <p><strong>左右双旋代码：</strong></p> 
 <pre><code class="prism language-cpp"><span class="token comment">//左右双旋</span>
<span class="token keyword">void</span> <span class="token function">RotateLR</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> parent<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Node<span class="token operator">*</span> childL  <span class="token operator">=</span> parent<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>
	Node<span class="token operator">*</span> childLR <span class="token operator">=</span> childL<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>
	<span class="token keyword">int</span> bf <span class="token operator">=</span> childLR<span class="token operator">-&gt;</span>_bf<span class="token punctuation">;</span>

	<span class="token function">RotateL</span><span class="token punctuation">(</span>childL<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">RotateR</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/*
				A
			B		C
		D		E
			  F
	*/</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>bf <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		childL<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		childLR<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		parent<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">/*
				A
			B		 C
		D	  E
			   F
	*/</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bf <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		childL<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
		childLR<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		parent<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">/*
	*	   A
	*	B
	*	  C
	*/</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bf <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		childL<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		childLR<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		parent<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//如果出现其他情况，则表示代码有问题，需要检查</span>
	<span class="token keyword">else</span> <span class="token function">assert</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
 <br> 
 <p><strong>关于右左双旋，可以结合下图理解(三列情况，对应三种不同的平衡因子调整)：</strong><br> <img src="https://images2.imgbox.com/c6/c3/dV5HeuDk_o.png" alt="左右双旋"></p> 
 <br> 
 <blockquote> 
  <p><strong>关于左右双旋的过程：</strong></p> 
  <ul><li>先确定parent和childL和childLR节点</li><li>对childL进行左单旋(将childLR变成childL的父节点)</li><li>对parent进行右单旋(再将childLR变成parent的父节点)</li><li>调整parent,childL和childLR节点的平衡因子(根据childLR节点平衡因子调整)</li></ul> 
 </blockquote> 
 <br> 
 <blockquote> 
  <p><strong>关于节点平衡因子的调整，从上图看出来，需要根据childRL节点来进行判断：</strong></p> 
  <ul><li>当childLR平衡因子为 <mark>0</mark> ：<code>parent</code>的平衡因子调整为<code>0</code>，<code>childL</code>的平衡因子调整为<code>0</code>，<code>childLR</code>平衡因子调整为<code>0</code>。</li><li>当childLR平衡因子为 <mark>-1</mark> ：<code>parent</code>的平衡因子调整为<code>1</code>，<code>childL</code>的平衡因子调整为<code>0</code>，<code>childLR</code>平衡因子调整为<code>0</code>。</li><li>当childLR平衡因子为 <mark>1</mark> ：<code>parent</code>的平衡因子调整为<code>0</code>，<code>childL</code>的平衡因子调整为<code>-1</code>，<code>childLR</code>平衡因子调整为<code>0</code>。</li></ul> 
 </blockquote> 
 <br> 
 <p>注意：左右双旋中，<strong>对childL进行右单旋转再对parent进行左单旋，这个顺序不能颠倒</strong>，且平衡因子的调整必须根据childLR平衡因子进行调整。</p> 
 <hr> 
 <center>
   AVL树主要值得学习的地方就在插入，学习其控制树的高度差的思想和旋转思想。 
 </center> 
</blockquote> 
<hr> 
<blockquote> 
 <h3><a id="AVL_535"></a>检验AVL树的合法性</h3> 
 <hr> 
 <p>检验AVL树是否合格（是否没有bug），还需要从其定义入手。</p> 
 <br> 
 <blockquote> 
  <p>空树是满足AVL树性质，且满足以下条件，则是AVL树：</p> 
  <ul><li>右子树减去左子树深度的绝对值不超过1</li><li>右子树减去左子树深度等于根节点平衡因子</li><li>每棵子树都满足该条件</li></ul> 
  <p>以上条件满足任意一个，就是AVL树。</p> 
 </blockquote> 
 <br> 
 <p>我们代码实现采用递归方式，在类中需要写一个递归函数再进行封装！</p> 
   
 <p>代码实现：</p> 
 <pre><code class="prism language-cpp"><span class="token comment">//检查AVL树合法性-调用函数</span>
<span class="token keyword">bool</span> <span class="token function">isAVL</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token function">_isAVL</span><span class="token punctuation">(</span>_root<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token comment">//获取AVL树高度-调用函数</span>
<span class="token keyword">int</span> <span class="token function">getHigh</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token function">_getHigh</span><span class="token punctuation">(</span>_root<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token comment">//检查AVL树合法性-执行函数</span>
<span class="token keyword">bool</span> <span class="token function">_isAVL</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> root<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token comment">//获取左右子树高度</span>
	<span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">_getHigh</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_left<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token function">_getHigh</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_right<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//如果右子树减左子树高度差的绝对值小于1 且差值与根的平衡因子相等 就继续检查子树</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">==</span> root<span class="token operator">-&gt;</span>_bf<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span> <span class="token operator">&amp;&amp;</span> <span class="token function">_isAVL</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">&gt;</span><span class="token function">_isAVL</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_right<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//获取树的深度-执行函数</span>
<span class="token keyword">int</span> <span class="token function">_getHigh</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> root<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">_getHigh</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_left<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token function">_getHigh</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_right<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> left <span class="token operator">&gt;</span> right <span class="token operator">?</span> left <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
 <br> 
 <p>测试代码：</p> 
 <pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
   <span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span>
   AVLTree<span class="token double-colon punctuation">::</span>AVLTree<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">&gt;</span> t<span class="token punctuation">;</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> t<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>i<span class="token punctuation">,</span>i<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isAVL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"合法"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
   <span class="token keyword">else</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"不合法"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
   cout <span class="token operator">&lt;&lt;</span> <span class="token string">"树高度："</span> <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span><span class="token function">getHigh</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
 <p><img src="https://images2.imgbox.com/ec/dd/G1PQDTMO_o.png" alt=""><br> 我们插入10001个节点，此时树合法且高度为14！<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            2 
           
          
            13 
           
          
         
           = 
          
         
           8192 
          
         
           ， 
          
          
          
            2 
           
          
            14 
           
          
         
           = 
          
         
           16384 
          
         
        
          2^{13}=8192 ，2^{14}=16384 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8641em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8641em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">13</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.8641em;"></span><span class="mord">8192</span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8641em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">14</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">16384</span></span></span></span></span></span><br> 通过对高度的平方运算，结果符合要求！</p> 
</blockquote> 
<hr> 
<blockquote> 
 <h3><a id="AVL_608"></a>关于AVL树</h3> 
 <hr> 
 <p>AVL树是一棵对身材要求及其严格的树，时时刻刻要求自己左右接近对称(左右高度差不超过1)。<br> </p> 
 <blockquote> 
  <p>AVL树的优缺点：</p> 
  <ul><li><strong>优点：</strong> 因为其严格的要求，当树中稍微出现退化趋势就会立刻被调整，所以对于AVL树的查询时间非常快，约为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            l 
           
          
            o 
           
           
           
             g 
            
           
             2 
            
           
          
            N 
           
          
         
           log_2N 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span></span></span></span></span>。</li><li><strong>缺点：</strong> 因为其严格的条件，导致AVL树在碰到有序序列时可能会频繁旋转调整，在删除情况下更是有可能一直调整到根节点，因为频繁旋转非常浪费性能，所以导致插入效率下降。</li></ul> 
 </blockquote> 
 <br> 
 <blockquote> 
  <p><strong>AVL树的使用场景：</strong><br> <br> AVL树严格的平衡条件，导致其查询效率极高，在<strong>不频繁增删的情况下</strong>，也就是<strong>静态树(只查只读)</strong> 的情况下，使用<strong>AVL树会的查询效率是极好的</strong>，但是在很多场景中，增删查改是并存的，此时我们不得不考虑摒弃一些查询时间去弥补插入删除的效率，也就是需要一棵与AVL树差不多，但是没有AVL树要求这么严格的二叉搜索树，这棵树就是<strong>红黑树</strong>，红黑树可以做的比AVL树调整次数少的情况下，性能差距不超过2倍，下一节我们将介绍红黑树！</p> 
 </blockquote> 
</blockquote> 
<hr> 
<h2><a id="_625"></a>最后</h2> 
<p><strong>AVL树的介绍到这里就差不多了，我们首先说明了二叉搜索树的缺点，引入AVL树对其进行强化，AVL树的复杂之处在于其旋转调整，所以我们通过AVL树的插入介绍旋转调整，至于删除操作相对于插入函数更加复杂，有兴趣的小伙伴可以了解，对于AVL树的基本性质就是这些了！</strong></p> 
<p><strong>本次 &lt;AVL树&gt; 就先介绍到这里啦，希望能够尽可能帮助到大家。</strong></p> 
<p><strong>如果文章中有瑕疵，还请各位大佬细心点评和留言，我将立即修补错误，谢谢！</strong></p> 
<p><strong>本节涉及代码：<a href="https://gitee.com/armcskgt/c-and---c-code-warehouse/tree/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E5%92%8C%E5%AE%9E%E7%8E%B0/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84STL/BinarySearchTree%E5%8F%8AAVL%E5%8F%8ARB/%E9%AB%98%E9%98%B6%E6%A0%91%E5%8D%9A%E5%AE%A2/AVL%E6%A0%91" rel="nofollow">AVL树博客代码</a></strong></p> 
<p><img src="https://images2.imgbox.com/fd/1b/RvAqj8oY_o.png" alt="博客结尾"></p> 
<blockquote> 
 <p><em></em></p> 
 <center> 
  <strong>🌟其他文章阅读推荐🌟<br> <a href="https://blog.csdn.net/m0_73446322/article/details/134784892">高级数据结构＜二叉搜索树＞</a><br> <a href="https://blog.csdn.net/m0_73446322/article/details/128394450">数据结构初级＜二叉树＞</a><br> <a href="https://blog.csdn.net/m0_73446322/article/details/131281127">C++ &lt;继承&gt;</a><br> <a href="https://blog.csdn.net/m0_73446322/article/details/131281150">C++ &lt;多态&gt;</a><br> <a href="https://blog.csdn.net/m0_73446322/article/details/131235312">C++ &lt;STL容器适配器&gt;</a><br> 🌹欢迎读者多多浏览多多支持!🌹</strong> 
 </center> 
 <p></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8dce0d004e72c6ca4f59d2d3869fb4eb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【深度学习】最强算法模型之：潜在狄利克雷分配(LDA)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c5260e0e41c8cea79859831965458fea/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ClickHouse10-ClickHouse中Kafka表引擎</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>