<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux：传输层(1) -- UDP协议 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/f303adbcb7a7909ea88aae547966c713/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Linux：传输层(1) -- UDP协议">
  <meta property="og:description" content="1. 端口号 同一台主机的不同端口号(Port)标记了主机上不同的进程，如下图所示：
在 TCP/IP 协议中 , 用 &#34; 源IP&#34;, &#34;源端口号&#34;, &#34;目的IP&#34;, &#34;目的端口号&#34;, &#34;协议号&#34; 这样一个五元组来标识一个通信 ( 可以通过netstat -n查看 ); 1.1 端口号划分 0 - 1023: 知名端口号, HTTP, FTP, SSH等这些广为使用的应用层协议, 他们的端口号都是固定的. 1024 - 65535: 操作系统动态分配的端口号. 客户端程序的端口号, 就是由操作系统从这个范围分配的 1.2 知名端口号 ssh服务器, 使用22端口 ftp服务器, 使用21端口 telnet服务器, 使用23端口 http服务器, 使用80端口 https服务器, 使用443执行下面的命令, 可以看到知名端口号：cat /etc/services 那么此时就会有 两个问题： 一个端口号是否能被多个进程bind？-- 默认情况下，一个端口号在同一时间不能被多个进程绑定到同一个IP地址，当然会有写特殊的处理。一个进程能否bind、多个端口号？-- 是可以的，一个进程可以创建多个套接字，每个套接字绑定到不同的端口上。 2. netstat netstat是一个用来查看网络状态的重要工具. 语法：netstat [选项] 功能：查看网络状态 常用选项： n 拒绝显示别名，能显示数字的全部转化成数字 l 仅列出有在 Listen (监听) 的服務状态 p 显示建立相关链接的程序名 t (tcp)仅显示tcp相关选项 u (udp)仅显示udp相关选项 a (all)显示所有选项，默认不显示LISTEN相关 pidof 在查看服务器的进程 id 时非常方便 .">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-24T10:17:23+08:00">
    <meta property="article:modified_time" content="2024-07-24T10:17:23+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux：传输层(1) -- UDP协议</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1. 端口号</h2> 
<p>        同一台主机的不同端口号(Port)标记了主机上不同的进程，如下图所示：</p> 
<p class="img-center"><img alt="" height="285" src="https://images2.imgbox.com/66/98/0ozvU2do_o.png" width="441"></p> 
<div> 
 <span style="color:#333333;">在</span> 
 <span style="color:#333333;">TCP/IP</span> 
 <span style="color:#333333;">协议中</span> 
 <span style="color:#333333;">, </span> 
 <span style="color:#333333;">用</span> 
 <span style="color:#333333;"> <strong>"</strong></span> 
 <strong><span style="color:#333333;">源</span><span style="color:#333333;">IP", "</span><span style="color:#333333;">源端口号</span><span style="color:#333333;">", "</span><span style="color:#333333;">目的</span><span style="color:#333333;">IP", "</span><span style="color:#333333;">目的端口号</span><span style="color:#333333;">", "</span><span style="color:#333333;">协议号</span><span style="color:#333333;">" </span></strong> 
 <span style="color:#333333;">这样一个五元组来标识一个通信</span> 
 <span style="color:#333333;">(</span> 
 <span style="color:#333333;">可以通过<strong>netstat -n</strong>查看</span> 
 <span style="color:#333333;">);</span> 
</div> 
<p> </p> 
<p class="img-center"><img alt="" height="453" src="https://images2.imgbox.com/77/28/3atRr8Px_o.png" width="550"></p> 
<h3>1.1 端口号划分</h3> 
<ul><li><span style="color:#0d0016;">0 - 1023: 知名端口号, HTTP, FTP, SSH等这些广为使用的应用层协议, 他们的端口号都是固定的. </span></li><li><span style="color:#0d0016;">1024 - 65535: 操作系统动态分配的端口号. 客户端程序的端口号, 就是由操作系统从这个范围分配的 </span></li></ul> 
<h3>1.2 知名端口号</h3> 
<ul><li><span style="color:#0d0016;">ssh服务器, 使用22端口 </span></li><li><span style="color:#0d0016;">ftp服务器, 使用21端口 </span></li><li><span style="color:#0d0016;">telnet服务器, 使用23端口 </span></li><li><span style="color:#0d0016;">http服务器, 使用80端口 </span></li><li><span style="color:#0d0016;">https服务器, 使用443</span></li><li><span style="color:#0d0016;">执行下面的命令, 可以看到知名端口号：<strong>cat /etc/services</strong></span></li></ul> 
<div>
  那么此时就会有 
 <strong>两个问题：</strong> 
</div> 
<ul><li><strong>一个端口号是否能被多个进程bind？-- 默认情况下，一个端口号在同一时间不能被多个进程绑定到同一个IP地址，当然会有写特殊的处理。</strong></li><li><strong>一个进程能否bind、多个端口号？-- 是可以的，一个进程可以创建多个套接字，每个套接字绑定到不同的端口上。</strong></li></ul> 
<h2>2. netstat</h2> 
<div> 
 <span style="color:#0d0016;">netstat是一个用来查看网络状态的重要工具. </span> 
</div> 
<div> 
 <span style="color:#0d0016;"><strong>语法</strong>：netstat [选项] </span> 
</div> 
<div> 
 <span style="color:#0d0016;"><strong>功能</strong>：查看网络状态</span> 
</div> 
<div> 
 <span style="color:#0d0016;"><strong>常用选项</strong>：</span> 
</div> 
<div> 
 <ul><li><span style="color:#0d0016;">n 拒绝显示别名，能显示数字的全部转化成数字 </span></li><li><span style="color:#0d0016;">l 仅列出有在 Listen (监听) 的服務状态 </span></li><li><span style="color:#0d0016;">p 显示建立相关链接的程序名 </span></li><li><span style="color:#0d0016;">t (tcp)仅显示tcp相关选项 </span></li><li><span style="color:#0d0016;">u (udp)仅显示udp相关选项 </span></li><li><span style="color:#0d0016;">a (all)显示所有选项，默认不显示LISTEN相关</span></li></ul> 
 <div> 
  <span style="color:#333333;"><strong>pidof </strong></span> 
 </div> 
 <div> 
  <span style="color:#333333;">在查看服务器的进程</span> 
  <span style="color:#333333;">id</span> 
  <span style="color:#333333;">时非常方便</span> 
  <span style="color:#333333;">. </span> 
 </div> 
 <div> 
  <span style="color:#333333;"><strong>语法</strong></span> 
  <span style="color:#333333;">：</span> 
  <span style="color:#333333;">pidof [</span> 
  <span style="color:#333333;">进程名</span> 
  <span style="color:#333333;">] </span> 
 </div> 
 <div> 
  <span style="color:#333333;"><strong>功能</strong></span> 
  <span style="color:#333333;">：通过进程名</span> 
  <span style="color:#333333;">, </span> 
  <span style="color:#333333;">查看进程</span> 
  <span style="color:#333333;">id </span> 
 </div> 
 <h2>3. UDP协议</h2> 
 <h3>3.1 格式</h3> 
 <p><img alt="" height="434" src="https://images2.imgbox.com/9d/51/KpqEQQjZ_o.png" width="1121"></p> 
</div> 
<ul><li> UDP采用固定长度的报头 -- 前8字节</li><li>16位UDP长度：表示整个数据报(报头+有效载荷)的长度</li><li>16位UDP校验和：发送前OS会按照算法计算出数据报的有效载荷并填充到报头中，在接收方接收到数据报以后，会以同样的算法计算校验和与包头中的对比，检验和不一致则直接丢弃</li></ul> 
<p><strong>对报头的理解：OS层面定制的一种协议，其实就是一种结构化的数据对象，如下所示(这里只是示例，并不代表真实的结构体也一定如此)：</strong></p> 
<pre><code class="language-cpp">//UDP头部，总长度8字节  
typedef struct _udp_hdr  
{  
    unsigned short src_port; //远端口号  
    unsigned short dst_port; //目的端口号  
    unsigned short uhl;      //udp头部长度  
    unsigned short chk_sum;  //16位udp检验和  
}udp_hdr;  </code></pre> 
<h3>3.2 UDP的特点</h3> 
<ul><li><span style="color:#0d0016;"><strong>无连接:</strong> 知道对端的IP和端口号就直接进行传输, 不需要建立连接; </span></li><li><span style="color:#0d0016;"><strong>不可靠:</strong> 没有确认机制, 没有重传机制; 如果因为网络故障该段无法发到对方, UDP协议层也不会给应用层返回任何错误信息; </span></li><li><span style="color:#0d0016;"><strong>面向数据报: </strong>不能够灵活的控制读写数据的次数和数量，</span><span style="color:#333333;">应用层交给</span><span style="color:#333333;">UDP</span><span style="color:#333333;">多长的报文</span><span style="color:#333333;">, UDP</span><span style="color:#333333;">原样发送</span><span style="color:#333333;">, </span><span style="color:#333333;">既不会拆分</span><span style="color:#333333;">, </span><span style="color:#333333;">也不会合并</span></li></ul> 
<h3><span style="color:#333333;">3.3 接受/发送缓冲区</span></h3> 
<p>我们在用的网络的IO接口并不是发送和接受和接口，实际上<strong>是一种拷贝的接口</strong>，将数据拷贝到缓冲区，再用OS决定何时发送和接收。</p> 
<p>调用read/recv时，实际上是从传输层协议的接收缓冲区中读取(拷贝)数据；调用write/send时，时间上是将数据经过封装拷贝到了传输层协议的发送缓冲区，此时应用层的任务就结束了，由OS将数据刷新到网络中。就像下面这个图一样：<img alt="" height="725" src="https://images2.imgbox.com/ad/aa/SloIx2h4_o.png" width="1200"></p> 
<p>传输层的UDP/TCP协议都是<strong>全双工的</strong>，发送/接收数据不使用相同的公共缓冲区，在发送数据的同时也可以接受别人发来的数据。 </p> 
<p><strong>注：</strong></p> 
<ul><li><strong>UDP是没有真正意义的发送给缓冲区的(</strong><span style="color:#0d0016;">调用sendto会直接交给内核, 由内核将数据传给网络层协议进行后续的传输动作</span><strong>)，它具有接收缓冲区。</strong></li><li> 
  <div> 
   <span style="color:#333333;">我们注意到</span> 
   <span style="color:#333333;">, UDP</span> 
   <span style="color:#333333;">协议首部中有一个</span> 
   <strong><span style="color:#333333;">16</span><span style="color:#333333;">位的最大长度</span></strong> 
   <span style="color:#333333;">. </span> 
   <span style="color:#333333;">也就是说一个</span> 
   <strong><span style="color:#333333;">UDP</span><span style="color:#333333;">能传输的数据最大长度是</span><span style="color:#333333;">64K(</span><span style="color:#333333;">包含</span><span style="color:#333333;">UDP 部</span></strong> 
   <span style="color:#333333;"><strong>)</strong>。然而64K</span> 
   <span style="color:#333333;">在当今的互联网环境下</span> 
   <span style="color:#333333;">, </span> 
   <span style="color:#333333;">是一个非常小的数字。</span> 
   <span style="color:#333333;">如果我们需要传输的数据<strong>超过64K</strong>, </span> 
   <span style="color:#333333;">就需要在应用层<strong>手动的分包</strong></span> 
   <span style="color:#333333;">, </span> 
   <span style="color:#333333;">多次发送</span> 
   <span style="color:#333333;">, </span> 
   <span style="color:#333333;">并在接收端<strong>手动拼装。</strong></span> 
  </div> </li></ul> 
<h3><span style="color:#333333;"><strong>3.4 基于UDP的应用层协议</strong></span></h3> 
<div> 
 <span style="color:#333333;"><strong>NFS: </strong>网络文件系统 、<strong>TFTP:</strong> 简单文件传输协议、<strong>DHCP: </strong>动态主机配置协议、<strong>BOOTP: </strong></span> 
 <span style="color:#333333;">启动协议</span> 
 <span style="color:#333333;">(</span> 
 <span style="color:#333333;">用于无盘设备启动)、<strong> DNS: </strong></span> 
 <span style="color:#333333;">域名解析协议</span> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/71f794350ff7004a2a319960d977cbeb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数字信号||快速傅里叶变换(FFT)（4）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8602384ac594d725d57c82a947399846/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JAVA用框架SpringAI实现人工智能（一）配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>