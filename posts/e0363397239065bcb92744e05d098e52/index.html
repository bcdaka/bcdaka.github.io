<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java 数据结构篇-实现单链表核心API - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/e0363397239065bcb92744e05d098e52/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java 数据结构篇-实现单链表核心API">
  <meta property="og:description" content="🔥博客主页： 小扳_-CSDN博客
❤感谢大家点赞👍收藏⭐评论✍ 文章目录
1.0 单链表的说明
2.0 单链表的创建
2.1 单链表 - 头插节点
2.2 单链表 - 遍历
2.2.1 使用简单的 for/while 循环
2.2.2 实现 forEach 方法
2.2.3 实现迭代器的方法
2.3 单链表 - 尾插节点
2.4 单链表 - 通过索引获取数据
2.5 单链表 - 通过索引插入数据
2.6 单链表 - 头删节点
2.7 单链表 - 根据节点来删除数据
3.0 实现单链表的完整代码
4.0 实现加 &#34;哨兵&#34; 的单链表 1.0 单链表的说明 单链表是一种数据结构。数据结构是指数据的组织、管理和存储的方式，而单链表是一种常见的线性数据结构，用于存储一系列具有相同类型的元素。它由一系列节点组成，每个节点包含一个数据元素和一个指向下一个节点的指针。单链表可以通过指针的方式实现元素的插入、删除和查找等操作。
2.0 单链表的创建 把单链表封装成一个类，面向对象编程的思路。类中需要的成员变量为头节点、节点，又可以把节点封装成一个类，为更好把节点类封装起来，将其设置为静态内部类。
代码如下：
public class SingleLists{ //头节点 private Node hand = null; //节点 private static class Node { //数据 private int data; //指向下一个节点 private Node next; public Node() { } } 注意的是，这些成员都不会对外访问的，所以需要把成员变为私有成员。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-11-06T11:44:52+08:00">
    <meta property="article:modified_time" content="2023-11-06T11:44:52+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java 数据结构篇-实现单链表核心API</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<blockquote> 
 <p><strong>🔥博客主页： <strong><a href="https://blog.csdn.net/Tingfeng__?spm=1000.2115.3001.5343" title="小扳_-CSDN博客">小扳_-CSDN博客</a></strong><br> ❤感谢大家点赞👍收藏⭐评论✍</strong>   </p> 
</blockquote> 
<p style="text-align:center;"><img alt="" height="436" src="https://images2.imgbox.com/c9/11/tzPKN5Tw_o.jpg" width="400"></p> 
<p style="text-align:center;"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/97/c2/qOMX7Tau_o.gif"></p> 
<p id="main-toc"><strong>文章目录</strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.0%20%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E8%AF%B4%E6%98%8E-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.0%20%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E8%AF%B4%E6%98%8E" rel="nofollow">        1.0 单链表的说明</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.0%20%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.0%20%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA" rel="nofollow">        2.0 单链表的创建</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.1%20%E5%8D%95%E9%93%BE%E8%A1%A8%20-%20%E5%A4%B4%E6%8F%92%E8%8A%82%E7%82%B9-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.1%20%E5%8D%95%E9%93%BE%E8%A1%A8%20-%20%E5%A4%B4%E6%8F%92%E8%8A%82%E7%82%B9" rel="nofollow">        2.1 单链表 - 头插节点</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.2%20%E5%8D%95%E9%93%BE%E8%A1%A8%20-%20%E9%81%8D%E5%8E%86-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.2%20%E5%8D%95%E9%93%BE%E8%A1%A8%20-%20%E9%81%8D%E5%8E%86" rel="nofollow">        2.2 单链表 - 遍历</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.2.1%C2%A0%E4%BD%BF%E7%94%A8%E7%AE%80%E5%8D%95%E7%9A%84%20for%2Fwhile%C2%A0%E5%BE%AA%E7%8E%AF-toc" style="margin-left:80px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.2.1%C2%A0%E4%BD%BF%E7%94%A8%E7%AE%80%E5%8D%95%E7%9A%84%20for%2Fwhile%C2%A0%E5%BE%AA%E7%8E%AF" rel="nofollow">        2.2.1 使用简单的 for/while 循环</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.2.2%20%E5%AE%9E%E7%8E%B0%20forEach%20%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.2.2%20%E5%AE%9E%E7%8E%B0%20forEach%20%E6%96%B9%E6%B3%95" rel="nofollow">        2.2.2 实现 forEach 方法</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.2.3%C2%A0%E5%AE%9E%E7%8E%B0%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.2.3%C2%A0%E5%AE%9E%E7%8E%B0%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E6%96%B9%E6%B3%95" rel="nofollow">        2.2.3 实现迭代器的方法</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.3%20%E5%8D%95%E9%93%BE%E8%A1%A8%20-%20%E5%B0%BE%E6%8F%92%E8%8A%82%E7%82%B9-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.3%20%E5%8D%95%E9%93%BE%E8%A1%A8%20-%20%E5%B0%BE%E6%8F%92%E8%8A%82%E7%82%B9" rel="nofollow">        2.3 单链表 - 尾插节点</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.4%20%E5%8D%95%E9%93%BE%E8%A1%A8%20-%20%E9%80%9A%E8%BF%87%E7%B4%A2%E5%BC%95%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.4%20%E5%8D%95%E9%93%BE%E8%A1%A8%20-%20%E9%80%9A%E8%BF%87%E7%B4%A2%E5%BC%95%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE" rel="nofollow">        2.4 单链表 - 通过索引获取数据</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.5%20%E5%8D%95%E9%93%BE%E8%A1%A8%20-%20%E9%80%9A%E8%BF%87%E7%B4%A2%E5%BC%95%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.5%20%E5%8D%95%E9%93%BE%E8%A1%A8%20-%20%E9%80%9A%E8%BF%87%E7%B4%A2%E5%BC%95%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE" rel="nofollow">        2.5 单链表 - 通过索引插入数据</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.6%20%E5%8D%95%E9%93%BE%E8%A1%A8%20-%20%E5%A4%B4%E5%88%A0%E8%8A%82%E7%82%B9-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.6%20%E5%8D%95%E9%93%BE%E8%A1%A8%20-%20%E5%A4%B4%E5%88%A0%E8%8A%82%E7%82%B9" rel="nofollow">        2.6 单链表 - 头删节点</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.7%20%E5%8D%95%E9%93%BE%E8%A1%A8%20-%20%E6%A0%B9%E6%8D%AE%E8%8A%82%E7%82%B9%E6%9D%A5%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.7%20%E5%8D%95%E9%93%BE%E8%A1%A8%20-%20%E6%A0%B9%E6%8D%AE%E8%8A%82%E7%82%B9%E6%9D%A5%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE" rel="nofollow">        2.7 单链表 - 根据节点来删除数据</a></strong></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03.0%20%E5%AE%9E%E7%8E%B0%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03.0%20%E5%AE%9E%E7%8E%B0%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" rel="nofollow">         3.0 实现单链表的完整代码</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.0%20%E5%AE%9E%E7%8E%B0%E5%8A%A0%20%22%E5%93%A8%E5%85%B5%22%20%E7%9A%84%E5%8D%95%E9%93%BE%E8%A1%A8%C2%A0-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.0%20%E5%AE%9E%E7%8E%B0%E5%8A%A0%20%22%E5%93%A8%E5%85%B5%22%20%E7%9A%84%E5%8D%95%E9%93%BE%E8%A1%A8%C2%A0" rel="nofollow">        4.0 实现加 "哨兵" 的单链表 </a></strong></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.0%20%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E8%AF%B4%E6%98%8E" style="background-color:transparent;">        1.0 单链表的说明</h2> 
<p>        <strong>单链表是一种数据结构。数据结构是指数据的组织、管理和存储的方式，而单链表是一种常见的线性数据结构，用于存储一系列具有相同类型的元素。它<span style="color:#fe2c24;">由一系列节点组成</span>，<span style="color:#fe2c24;">每个节点包含一个数据元素和一个指向下一个节点的指针</span>。单链表可以通过指针的方式实现元素的插入、删除和查找等操作。</strong></p> 
<p></p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.0%20%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA" style="background-color:transparent;">        2.0 单链表的创建</h2> 
<p>       <strong>把单链表封装成一个类，面向对象编程的思路。类中需要的成员变量为<span style="color:#fe2c24;">头节点</span>、<span style="color:#fe2c24;">节点</span>，又可以把节点封装成一个类，为更好把节点类封装起来，将其设置为<span style="color:#fe2c24;">静态内部类</span>。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">public class SingleLists{
    //头节点
    private Node hand = null;


    //节点
    private static class Node {
        //数据
        private int data;
        //指向下一个节点
        private Node next;

        public Node() {
        }

}</code></pre> 
 <p><strong>        注意的是，这些成员都不会对外访问的，所以需要把成员变为<span style="color:#fe2c24;">私有成员</span>。</strong></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.1%20%E5%8D%95%E9%93%BE%E8%A1%A8%20-%20%E5%A4%B4%E6%8F%92%E8%8A%82%E7%82%B9" style="background-color:transparent;">        2.1 单链表 - 头插节点</h3> 
<p>       <strong>顾名思义，就是在<span style="color:#fe2c24;">头节点处插入新的节点</span>，使其成为新的头节点。需要考虑两种情况，<span style="color:#fe2c24;">第一种情况，头节点为 null 时，直接就可以将创建出来的对象被 hand 引用了。第二种情况，头节点不为 null 时，需要将创建的对象的 next 引用指向 hand 的引用，而当前创建的对象就要被 hand 引用。</span></strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-javascript">    //实现头插节点
    public void addFirst(int data) {
/*        if (hand == null){
            hand = new Node(data,null);
        }else {
            hand = new Node(data,hand);
        }*/
        
        //对以上代码进行简化得以下代码：
        hand = new Node(data,hand);
        
    }</code></pre> 
 <p><strong>        需要注意的时，该 API 是对外访问。</strong></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.2%20%E5%8D%95%E9%93%BE%E8%A1%A8%20-%20%E9%81%8D%E5%8E%86" style="background-color:transparent;">        2.2 单链表 - 遍历</h3> 
<p>        <strong>实现遍历的方式有三种：</strong></p> 
<p><strong>        第一种方式，使用简单的 <span style="color:#fe2c24;">for/while</span> 循环。</strong></p> 
<p><strong>        第二种方式，实现 <span style="color:#fe2c24;">forEach</span> 方法。</strong></p> 
<p><strong>        第三种方式，实现<span style="color:#fe2c24;">迭代器</span>的方法。</strong></p> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.2.1%C2%A0%E4%BD%BF%E7%94%A8%E7%AE%80%E5%8D%95%E7%9A%84%20for%2Fwhile%C2%A0%E5%BE%AA%E7%8E%AF" style="background-color:transparent;">        2.2.1 使用简单的 for/while 循环</h4> 
<p>        <strong>一般 hand 是<span style="color:#fe2c24;">不会去移动或者去改变其引用</span>，则需要临时的变量 p 来指向 hand 的对象。循环的条件为 <span style="color:#fe2c24;">p != null</span>，每一次循环结束都需要 p 去移动到下一个节点处，<span style="color:#fe2c24;">p = p.next</span> 。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //遍历方式：打印方式
    public void myPrint(){
        if (hand == null){
            throw new RuntimeException("hand is null！！！！");
        }
        //第一种：
/*        Node p = hand;
        //用while来实现
        while (p != null){
            System.out.println(p.data);
            p = p.next;
        }*/
        //第二种：
        //用for来实现
        for (Node p = hand;p !=null;p = p.next){
            System.out.println(p.data);
        }
    }
</code></pre> 
 <p>        <strong>还需要注意，for 与 while 这两种的实现逻辑是一样的，假如 hand 的引用为空，则没必要去循环了，直接去抛出错误。</strong></p> 
</blockquote> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.2.2%20%E5%AE%9E%E7%8E%B0%20forEach%20%E6%96%B9%E6%B3%95" style="background-color:transparent;">        2.2.2 实现 forEach 方法</h4> 
<p>        <strong>对于 for/while 的遍历方法直接把 “方法写死了”，forEeach 方法是对 for/while 的方法进行了升级。参数为 <span style="color:#fe2c24;">Consumer&lt;Integer&gt; 内部类</span>，再重写<span style="color:#fe2c24;"> accept </span>方法。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //遍历方式:实现forEach，由于跟以下的代码有冲突，先改名为 myForEach。
    public void myForEach(Consumer&lt;Integer&gt; consumer){
        for (Node p = hand; p != null;p = p.next){
            consumer.accept(p.data);
        }
    }</code></pre> 
 <p><strong>具体调用该方法的使用：</strong></p> 
 <pre><code class="language-java">        singleLists.myForEach(new Consumer&lt;Integer&gt;() {
            @Override
            public void accept(Integer integer) {
                System.out.println(integer);
            }
        });</code></pre> 
 <p><strong>        这样对外获取的数据可以自由支配使用，不仅仅打印输出了。</strong></p> 
</blockquote> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.2.3%C2%A0%E5%AE%9E%E7%8E%B0%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E6%96%B9%E6%B3%95" style="background-color:transparent;">        2.2.3 实现迭代器的方法</h4> 
<p>        <strong>需要实现接口<span style="color:#fe2c24;"> Iterable&lt;Integer&gt;</span> ，该接口支持泛型，目前先实现整数类型的单链表。重写 <span style="color:#fe2c24;">hasNext()</span> 与 <span style="color:#fe2c24;">next() </span>方法。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //遍历方式：使用迭代器循环
    @Override
    public Iterator&lt;Integer&gt; iterator() {
        return new Iterator&lt;Integer&gt;() {
            Node p = hand;
            @Override
            public boolean hasNext() {
                return p != null;
            }

            @Override
            public Integer next() {
                int k = p.data;
                p = p.next;
                return k;
            }
        };
</code></pre> 
 <p>        <strong>重写完的 <span style="color:#fe2c24;">hasNext() </span>这个方法的作用：<span style="color:#fe2c24;">是判断当前 p 是否为 null ，如果是就停止遍历，结束了。反之继续遍历下去。</span></strong></p> 
 <p><strong>        重写之后的<span style="color:#fe2c24;"> next()</span> 方法的作用：<span style="color:#fe2c24;">做了两个动作，第一个动作就是获取当前的数据；第二个动作就是将 p 移向下一个节点。</span></strong></p> 
 <p></p> 
 <p><strong>具体调用该方法的使用：</strong></p> 
 <pre><code class="language-java">        for (Integer value:singleLists) {
            System.out.println(value);
        }</code></pre> 
 <p><strong>        同理，这个方式不仅仅只有打印输出了，自由支配使用。</strong></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.3%20%E5%8D%95%E9%93%BE%E8%A1%A8%20-%20%E5%B0%BE%E6%8F%92%E8%8A%82%E7%82%B9" style="background-color:transparent;">        2.3 单链表 - 尾插节点</h3> 
<p>        <strong>找最后的节点后面插入新的节点，如果只有头节点，需要不断的遍历，直到最后一个节点。遍历的条件为 <span style="color:#fe2c24;">p.next != null</span>，跟以上的条件需要区别开来，这里需要得到最后的节点，可不能 <span style="color:#fe2c24;">p !=null </span>一直下去，这样就会找不到最后的节点。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //尾插节点
    public void addLast(int data) {
        if (hand == null) {
            addFirst(data);
            return;
        }
        Node p = hand;
        while (p.next != null){
            p = p.next;
        }
        p.next = new Node(data,null);
    }</code></pre> 
 <p>       <strong> 需要注意的是，单独分开当 hand 为 null 时，因为 hand.next == null 了，但是对于hand 为 null 时也可以插入节点呀，所以 当 hand 为 null 时，可以调用头插节点的方法。</strong></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.4%20%E5%8D%95%E9%93%BE%E8%A1%A8%20-%20%E9%80%9A%E8%BF%87%E7%B4%A2%E5%BC%95%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE" style="background-color:transparent;">        2.4 单链表 - 通过索引获取数据</h3> 
<p>        <strong>单链表是不连续的，不用直接通过索引来访问节点去读取数据，因此，先独立设置一个方法，需设置一个 i 记数点，每一个遍历完<span style="color:#fe2c24;"> i++</span> ,直到<span style="color:#fe2c24;"> i == index </span>时，先返回该节点。再独立另一个方法，通过该节点来读取该数据。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //根据索引获取某个节点
    private Node findNode(int index) {
        int i = 0;
        for (Node p = hand ; p != null ; p = p.next,i++)
        {
            if (i == index) {
                return p;
            }
        }
        return null;
    }



    //根据索引得到对应的数据
    public int get(int index) {
        Node p = findNode(index);
        if (p == null){
            throw new RuntimeException("找不到该索引!!!");
        }
        return p.data;
    }</code></pre> 
 <p>        <strong>对于找不到的节点，需要抛出异常，需要注意的是，findNode 方法是不对外访问的，需要封装起来。</strong></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.5%20%E5%8D%95%E9%93%BE%E8%A1%A8%20-%20%E9%80%9A%E8%BF%87%E7%B4%A2%E5%BC%95%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE" style="background-color:transparent;">        2.5 单链表 - 通过索引插入数据</h3> 
<p>        <strong>先获取插入位置的前一个 <span style="color:#fe2c24;">prev</span> 节点，然后 <span style="color:#fe2c24;">prev.next</span> 去指向插入的节点的对象，插入节点的 <span style="color:#fe2c24;">next </span>去引用原先 <span style="color:#fe2c24;">prev.next</span> 的对象。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //根据索引插入数据
    public void insert(int index , int data){
        if (index == 0){
            addFirst(data);
        }
        Node prev = findNode(index - 1);
        if (prev == null){
            throw new RuntimeException("index is illegal");
        }
        prev.next =  new Node(data,prev.next);
    }</code></pre> 
 <p>        <strong> 需要注意的是，先判断插入点是否为头节点，如果是头节点，则调用头插的方法。再去判断其他情况通过<span style="color:#fe2c24;"> findNode() </span>方法是否得到 null，如果是，需要抛出异常。</strong></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.6%20%E5%8D%95%E9%93%BE%E8%A1%A8%20-%20%E5%A4%B4%E5%88%A0%E8%8A%82%E7%82%B9" style="background-color:transparent;">        2.6 单链表 - 头删节点</h3> 
<p>        <strong>顾名思义直接删除头节点，思路为： <span style="color:#fe2c24;">hand </span>这个引用需要指向 <span style="color:#fe2c24;">hand.next </span>，这就是删除了第一个节点，没用引用的对象，在 Java 中回自动回收的，不会占内存，这也就是删除了。</strong></p> 
<blockquote> 
 <p><img alt="" class="left" height="391" src="https://images2.imgbox.com/7e/04/l7YRcmdF_o.png" width="1200"></p> 
</blockquote> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //头删节点
    public void removeFirst() {
        if (hand == null){
            throw new RuntimeException("There are no nodes anymore");
        }
        hand = hand.next;
    }</code></pre> 
 <p><strong>        需要注意，删除前先判断 hand 是否为 null 。</strong></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.7%20%E5%8D%95%E9%93%BE%E8%A1%A8%20-%20%E6%A0%B9%E6%8D%AE%E8%8A%82%E7%82%B9%E6%9D%A5%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE" style="background-color:transparent;">        2.7 单链表 - 根据节点来删除数据</h3> 
<p>        <strong>先找到要删除节点的前一个 <span style="color:#fe2c24;">prev 节点</span>，然后再去找到 要删除的节点<span style="color:#fe2c24;"> move = prev.next</span> ，接着将<span style="color:#fe2c24;"> prev.next = move.next </span>即可。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //根据索引来删除节点
    public void remove(int index) {
        if (index == 0) {
            removeFirst();
            return;
        }
        Node prev = findNode(index - 1);
        if (prev == null){
            throw new RuntimeException("There are no nodes anymore");
        }
        Node move = prev.next;
        if (move == null) {
            throw new RuntimeException("There are no nodes anymore");
        }
        prev.next = move.next;
    }</code></pre> 
 <p>        <strong>在删除节点的时候需要先判断 <span style="color:#fe2c24;">index </span>是否为 <span style="color:#fe2c24;">0</span>，如果是，则调用头删的方法，再通过 <span style="color:#fe2c24;">findNode()</span> 方法来找到删除节点的前一个节点，如果得到的节点为 <span style="color:#fe2c24;">null</span>，则需要抛出异常，同样的如果得到的需要删除的节点为 <span style="color:#fe2c24;">null </span>，则需要抛出异常。</strong></p> 
</blockquote> 
<p> </p> 
<h2 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03.0%20%E5%AE%9E%E7%8E%B0%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" style="background-color:transparent;">         3.0 实现单链表的完整代码</h2> 
<blockquote> 
 <pre><code class="language-java">
import java.util.Iterator;
import java.util.function.Consumer;

//整体
public class SingleLists implements Iterable&lt;Integer&gt;{
    //头节点
    private Node hand = null;


    //节点
    private static class Node {
        //数据
        private int data;
        //指向下一个节点
        private Node next;

        public Node() {
        }

        public Node(int data, Node next) {
            this.data = data;
            this.next = next;
        }
    }

    //实现头插节点
    public void addFirst(int data) {
/*        if (hand == null){
            hand = new Node(data,null);
        }else {
            hand = new Node(data,hand);
        }*/

        //对以上代码进行简化得以下代码：
        hand = new Node(data,hand);

    }

    //遍历方式：打印方式
    public void myPrint(){
        if (hand == null){
            throw new RuntimeException("hand is null！！！！");
        }
        //第一种：
/*        Node p = hand;
        //用while来实现
        while (p != null){
            System.out.println(p.data);
            p = p.next;
        }*/
        //第二种：
        //用for来实现
        for (Node p = hand;p !=null;p = p.next){
            System.out.println(p.data);
        }
    }

    //遍历方式:实现forEach，由于跟以下的代码有冲突，先改名为 myForEach。
    public void myForEach(Consumer&lt;Integer&gt; consumer){
        for (Node p = hand; p != null;p = p.next){
            consumer.accept(p.data);
        }
    }

    //遍历方式：使用迭代器循环
    @Override
    public Iterator&lt;Integer&gt; iterator() {
        return new Iterator&lt;Integer&gt;() {
            Node p = hand;
            @Override
            public boolean hasNext() {
                return p != null;
            }

            @Override
            public Integer next() {
                int k = p.data;
                p = p.next;
                return k;
            }
        };
    }

    //尾插节点
    public void addLast(int data) {
        if (hand == null) {
            addFirst(data);
            return;
        }
        Node p = hand;
        while (p.next != null){
            p = p.next;
        }
        p.next = new Node(data,null);
    }

    //根据索引获取某个节点
    private Node findNode(int index) {
        int i = 0;
        for (Node p = hand ; p != null ; p = p.next,i++)
        {
            if (i == index) {
                return p;
            }
        }
        return null;
    }

    //根据索引得到对应的数据
    public int get(int index) {
        Node p = findNode(index);
        if (p == null){
            throw new RuntimeException("找不到该索引!!!");
        }
        return p.data;
    }

    //根据索引插入数据
    public void insert(int index , int data){
        if (index == 0){
            addFirst(data);
        }
        Node prev = findNode(index - 1);
        if (prev == null){
            throw new RuntimeException("index is illegal");
        }
        prev.next =  new Node(data,prev.next);
    }

    //头删节点
    public void removeFirst() {
        if (hand == null){
            throw new RuntimeException("There are no nodes anymore");
        }
        hand = hand.next;
    }

    //根据索引来删除节点
    public void remove(int index) {
        if (index == 0) {
            removeFirst();
            return;
        }
        Node prev = findNode(index - 1);
        if (prev == null){
            throw new RuntimeException("There are no nodes anymore");
        }
        Node move = prev.next;
        if (move == null) {
            throw new RuntimeException("There are no nodes anymore");
        }
        prev.next = move.next;
    }


}</code></pre> 
 <p></p> 
</blockquote> 
<p></p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.0%20%E5%AE%9E%E7%8E%B0%E5%8A%A0%20%22%E5%93%A8%E5%85%B5%22%20%E7%9A%84%E5%8D%95%E9%93%BE%E8%A1%A8%C2%A0" style="background-color:transparent;">        4.0 实现加 "哨兵" 的单链表 </h2> 
<p>       <strong> 哨兵是单链表中的一个特殊节点，它不在乎存储什么数据元素，只用于标记链表的开始或结束。在单链表中，通常有一个头节点作为链表的起始位置。而哨兵节点是在头节点之前或尾节点之后的一个额外节点，用于简化链表的操作。简单来说，就是 <span style="color:#fe2c24;">hand 不在为 null ,始终有节点，这么一来，就会节省了考虑 hand == null 的情况发生了</span>，写出来的代码更加简洁了。</strong></p> 
<p><strong>加 "哨兵" 的代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">import java.util.Iterator;
import java.util.function.Consumer;

//整体
public class SingleLists implements Iterable&lt;Integer&gt;{
    //头节点
    private final Node hand = new Node(0,null);


    //节点
    private static class Node {
        //数据
        private int data;
        //指向下一个节点
        private Node next;

        public Node() {
        }

        public Node(int data, Node next) {
            this.data = data;
            this.next = next;
        }
    }

    //实现头插节点
    public void addFirst(int data) {
        //对以上代码进行简化得以下代码：
        //hand.next = new Node(data,hand.next);
        insert(0,data);

    }

    //遍历方式：打印方式
    public void myPrint(){
        for (Node p = hand.next;p !=null;p = p.next){
            System.out.println(p.data);
        }
    }

    //遍历方式:实现forEach，由于跟以下的代码有冲突，先改名为 myForEach。
    public void myForEach(Consumer&lt;Integer&gt; consumer){
        for (Node p = hand.next; p != null;p = p.next){
            consumer.accept(p.data);
        }
    }

    //遍历方式：使用迭代器循环
    @Override
    public Iterator&lt;Integer&gt; iterator() {
        return new Iterator&lt;Integer&gt;() {
            Node p = hand.next;
            @Override
            public boolean hasNext() {
                return p != null;
            }

            @Override
            public Integer next() {
                int k = p.data;
                p = p.next;
                return k;
            }
        };
    }

    //尾插节点
    public void addLast(int data) {
        Node p = hand;
        while (p.next != null){
            p = p.next;
        }
        p.next = new Node(data,null);
    }

    //根据索引获取某个节点
    private Node findNode(int index) {
        int i = -1;
        for (Node p = hand ; p != null ; p = p.next,i++)
        {
            if (i == index) {
                return p;
            }
        }
        return null;
    }

    //根据索引得到对应的数据
    public int get(int index) {
        Node p = findNode(index);
        if (p == null){
            throw new RuntimeException("找不到该索引!!!");
        }
        return p.data;
    }

    //根据索引插入数据
    public void insert(int index , int data){
        Node prev = findNode(index - 1);
        if (prev == null){
            throw new RuntimeException("index is illegal");
        }
        prev.next =  new Node(data,prev.next);
    }

    //头删节点
    public void removeFirst() {
        //hand = hand.next;
        remove(0);
    }

    //根据索引来删除节点
    public void remove(int index) {
        Node prev = findNode(index - 1);
        if (prev == null){
            throw new RuntimeException("There are no nodes anymore");
        }
        Node move = prev.next;
        if (move == null) {
            throw new RuntimeException("There are no nodes anymore");
        }
        prev.next = move.next;
    }
}</code></pre> 
 <p>        <strong>需要注意的是，哨兵节点并不是必需的，可以根据具体的需求来决定是否使用哨兵节点。在某些情况下，如果链表的操作较为简单，不涉及插入和删除等复杂操作，可以不使用哨兵节点来简化代码。</strong></p> 
</blockquote> 
<p style="text-align:center;"> </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/79/05/rtXF6Bln_o.gif"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e41f4a7207140e48d8b3bb31e9ec39c6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">FastAPI 库（Python 的 Web 框架）基本使用指南（一）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fc47e6c6f464b1593d469cdea3a1b9a7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python Slice函数：数据处理利器详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>