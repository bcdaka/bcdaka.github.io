<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】AVL 树 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/026fceab6782fb6383924d709c7a520a/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】AVL 树">
  <meta property="og:description" content="文章目录 1. AVL 树的概念2. AVL 树节点的定义3. AVL 树的插入4. AVL 树的旋转5. AVL 树的验证6. AVL 树的删除7. AVL 树的性能 前面对 map / multimap / set / multiset 进行了简单的介绍【C&#43;&#43;】map &amp; set，在其文档介绍中发现，这几个容器有个共同点是：其底层都是按照二叉搜索树来实现的，但是二叉搜索树有其自身的缺陷，假如往树中插入的元素有序或者接近有序，二叉搜索树就会退化成单支树，时间复杂度会退化成 O(N)，因此 map、set 等关联式容器的底层结构是对二叉树进行了平衡处理，即采用平衡树来实现。
1. AVL 树的概念 二叉搜索树虽可以缩短查找的效率，但如果数据有序或者接近有序，二叉搜索树将退化为单支树，查找元素相当于在顺序表中搜索元素，效率低下。因此，两位俄罗斯的数学家 G.M.Adelson-Velskii 和 E.M.Landis 在 1962 年发明了一种解决上述问题的方法：当向二叉搜索树中插入新节点后，如果能保证每个节点的左右子树高度之差的绝对值不超过 1（需要对树中的节点进行调整），即可降低树的高度，从而减少平均搜索长度。
一棵 AVL 树或者是空树，或者是具有以下性质的二叉搜索树：
它的左右子树都是 AVL 树；左右子树高度之差（简称平衡因子）的绝对值不超过 1（-1 / 0 / 1）。 如果一棵二叉搜索树是高度平衡的，它就是 AVL 树。如果它有 n 个节点，其高度可保持在 O ( l o g 2 n ) O(log_2 n) O(log2​n)，搜索时间复杂度是 O ( l o g 2 n ) O(log_2 n) O(log2​n)。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-02T09:05:19+08:00">
    <meta property="article:modified_time" content="2024-04-02T09:05:19+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】AVL 树</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1_AVL__5" rel="nofollow">1. AVL 树的概念</a></li><li><a href="#2_AVL__16" rel="nofollow">2. AVL 树节点的定义</a></li><li><a href="#3_AVL__35" rel="nofollow">3. AVL 树的插入</a></li><li><a href="#4_AVL__101" rel="nofollow">4. AVL 树的旋转</a></li><li><a href="#5_AVL__219" rel="nofollow">5. AVL 树的验证</a></li><li><a href="#6_AVL__262" rel="nofollow">6. AVL 树的删除</a></li><li><a href="#7_AVL__265" rel="nofollow">7. AVL 树的性能</a></li></ul> 
</div> 
<br> 
<img src="https://images2.imgbox.com/b9/d4/S5bU90il_o.gif" alt="在这里插入图片描述"> 
<p></p> 
<p>前面对 map / multimap / set / multiset 进行了简单的介绍<a href="https://blog.csdn.net/m0_73156359/article/details/137058155?spm=1001.2014.3001.5501">【C++】map &amp; set</a>，在其文档介绍中发现，这几个容器有个共同点是：<strong>其底层都是按照二叉搜索树来实现的</strong>，但是二叉搜索树有其自身的缺陷，假如往树中插入的元素有序或者接近有序，二叉搜索树就会退化成单支树，时间复杂度会退化成 O(N)，因此 map、set 等关联式容器的底层结构是对二叉树进行了平衡处理，即采用平衡树来实现。</p> 
<h2><a id="1_AVL__5"></a>1. AVL 树的概念</h2> 
<p>二叉搜索树虽可以缩短查找的效率，但<strong>如果数据有序或者接近有序，二叉搜索树将退化为单支树，查找元素相当于在顺序表中搜索元素，效率低下</strong>。因此，两位俄罗斯的数学家 G.M.Adelson-Velskii 和 E.M.Landis 在 1962 年发明了一种解决上述问题的方法：<strong>当向二叉搜索树中插入新节点后，如果能保证每个节点的左右子树高度之差的绝对值不超过 1（需要对树中的节点进行调整）</strong>，即可降低树的高度，从而减少平均搜索长度。</p> 
<p>一棵 AVL 树或者是空树，或者是具有以下性质的二叉搜索树：</p> 
<ul><li><strong>它的左右子树都是 AVL 树；</strong></li><li><strong>左右子树高度之差（简称平衡因子）的绝对值不超过 1（-1 / 0 / 1）。</strong></li></ul> 
<p><img src="https://images2.imgbox.com/c5/8d/tVc1ENVP_o.png" alt="在这里插入图片描述"></p> 
<p><strong>如果一棵二叉搜索树是高度平衡的，它就是 AVL 树。如果它有 n 个节点，其高度可保持在 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          l 
         
        
          o 
         
         
         
           g 
          
         
           2 
          
         
        
          n 
         
        
          ) 
         
        
       
         O(log_2 n) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>，搜索时间复杂度是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          l 
         
        
          o 
         
         
         
           g 
          
         
           2 
          
         
        
          n 
         
        
          ) 
         
        
       
         O(log_2 n) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>。</strong></p> 
<h2><a id="2_AVL__16"></a>2. AVL 树节点的定义</h2> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">AVLTreeNode</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">AVLTreeNode</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> data<span class="token punctuation">)</span>
		<span class="token operator">:</span> <span class="token function">_pLeft</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_pRight</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_pParent</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_data</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_bf</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	
	AVLTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> _pLeft<span class="token punctuation">;</span>		<span class="token comment">// 该节点的左孩子</span>
	AVLTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> _pRight<span class="token punctuation">;</span> 	<span class="token comment">// 该节点的右孩子</span>
	AVLTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> _pParent<span class="token punctuation">;</span> 	<span class="token comment">// 该节点的双亲</span>
	T _data<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _bf<span class="token punctuation">;</span> 					<span class="token comment">// 该节点的平衡因子</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="3_AVL__35"></a>3. AVL 树的插入</h2> 
<p>AVL 树就是在二叉搜索树的基础上引入了平衡因子，因此 AVL 树也可以看成是二叉搜索树。那么 AVL 树的插入过程可以分为两步：</p> 
<ol><li><strong>按照二叉搜索树的方式插入新节点；</strong></li><li><strong>调整节点的平衡因子。</strong></li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token function">Insert</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> data<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 1. 先按照二叉搜索树的规则将节点插入到AVL树中</span>
	<span class="token comment">// ...</span>
	
	<span class="token comment">// 2. 新节点插入后，AVL树的平衡性可能会遭到破坏，此时就需要更新平衡因子，并检测是否破坏了AVL树的平衡性</span>
	
	<span class="token comment">/*
	pCur插入后，pParent的平衡因子一定需要调整，在插入之前，pParent
	的平衡因子分为三种情况：-1，0, 1, 分以下两种情况：
		1. 如果pCur插入到pParent的左侧，只需给pParent的平衡因子-1即可
		2. 如果pCur插入到pParent的右侧，只需给pParent的平衡因子+1即可

	此时：pParent的平衡因子可能有三种情况：0，正负1，正负2
		1. 如果pParent的平衡因子为0，说明插入之前pParent的平衡因子为正负1，插入后被调整
		   成0，此时满足AVL树的性质，插入成功
		2. 如果pParent的平衡因子为正负1，说明插入前pParent的平衡因子一定为0，插入后被更
		   新成正负1，此时以pParent为根的树的高度增加，需要继续向上更新
		3. 如果pParent的平衡因子为正负2，则pParent的平衡因子违反平衡树的性质，需要对其进
		   行旋转处理
	*/</span>

	<span class="token keyword">while</span> <span class="token punctuation">(</span>pParent<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 更新双亲的平衡因子</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>pCur <span class="token operator">==</span> pParent<span class="token operator">-&gt;</span>_pLeft<span class="token punctuation">)</span>
			pParent<span class="token operator">-&gt;</span>_bf<span class="token operator">--</span><span class="token punctuation">;</span>
		<span class="token keyword">else</span>
			pParent<span class="token operator">-&gt;</span>_bf<span class="token operator">++</span><span class="token punctuation">;</span>
			
		<span class="token comment">// 更新后检测双亲的平衡因子</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> pParent<span class="token operator">-&gt;</span>_bf<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">==</span> pParent<span class="token operator">-&gt;</span>_bf <span class="token operator">||</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">==</span> pParent<span class="token operator">-&gt;</span>_bf<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 插入前双亲的平衡因子是0，插入后双亲的平衡因为为1或者-1，说明以双亲为根的二叉树</span>
			<span class="token comment">// 的高度增加了一层，因此需要继续向上调整</span>
			pCur <span class="token operator">=</span> pParent<span class="token punctuation">;</span>
			pParent <span class="token operator">=</span> pCur<span class="token operator">-&gt;</span>_pParent<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 双亲的平衡因子为正负2，违反了AVL树的平衡性，需要对以pParent</span>
			<span class="token comment">// 为根的树进行旋转处理</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">==</span> pParent<span class="token operator">-&gt;</span>_bf<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token comment">// ...</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token comment">// ...</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="4_AVL__101"></a>4. AVL 树的旋转</h2> 
<p>如果在一棵原本是平衡的 AVL 树中插入一个新节点，可能造成不平衡，此时必须调整树的结构，使之平衡化。根据节点插入位置的不同，AVL 树的旋转分为四种：</p> 
<ol><li> <p><strong>新节点插入较高左子树的左侧 - 左左：右单旋</strong></p> <p><img src="https://images2.imgbox.com/f7/55/SMbxWCW4_o.png" alt="在这里插入图片描述"></p> <pre><code class="prism language-cpp"><span class="token comment">/*
	上图在插入前，AVL树是平衡的，新节点插入到30的左子树(注意：此处不是左孩子)中，30左
子树增加了一层，导致以60为根的二叉树不平衡，要让60平衡，只能将60左子树的高度减少一层，右子
树增加一层，即将左子树往上提，这样60转下来，因为60比30大，只能将其放在30的右子树，而如果30有
右子树，右子树根的值一定大于30，小于60，只能将其放在60的左子树，旋转完成后，更新节点
的平衡因子即可。在旋转过程中，有以下几种情况需要考虑：
	1. 30节点的右孩子可能存在，也可能不存在
	2. 60可能是根节点，也可能是子树
	   如果是根节点，旋转完成后，要更新根节点
	   如果是子树，可能是某个节点的左子树，也可能是右子树
*/</span>

<span class="token keyword">void</span> <span class="token function">_RotateR</span><span class="token punctuation">(</span>PNode pParent<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// pSubL: pParent的左孩子</span>
	<span class="token comment">// pSubLR: pParent左孩子的右孩子，注意：该</span>
	PNode pSubL <span class="token operator">=</span> pParent<span class="token operator">-&gt;</span>_pLeft<span class="token punctuation">;</span>
	PNode pSubLR <span class="token operator">=</span> pSubL<span class="token operator">-&gt;</span>_pRight<span class="token punctuation">;</span>
	
	<span class="token comment">// 旋转完成之后，30的右孩子作为双亲的左孩子</span>
	pParent<span class="token operator">-&gt;</span>_pLeft <span class="token operator">=</span> pSubLR<span class="token punctuation">;</span>
	<span class="token comment">// 如果30的左孩子的右孩子存在，更新亲双亲</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>pSubLR<span class="token punctuation">)</span>
		pSubLR<span class="token operator">-&gt;</span>_pParent <span class="token operator">=</span> pParent<span class="token punctuation">;</span>
		
	<span class="token comment">// 60 作为 30的右孩子</span>
	pSubL<span class="token operator">-&gt;</span>_pRight <span class="token operator">=</span> pParent<span class="token punctuation">;</span>
	
	<span class="token comment">// 因为60可能是棵子树，因此在更新其双亲前必须先保存60的双亲</span>
	PNode pPParent <span class="token operator">=</span> pParent<span class="token operator">-&gt;</span>_pParent<span class="token punctuation">;</span>
	
	<span class="token comment">// 更新60的双亲</span>
	pParent<span class="token operator">-&gt;</span>_pParent <span class="token operator">=</span> pSubL<span class="token punctuation">;</span>
	
	<span class="token comment">// 更新30的双亲</span>
	pSubL<span class="token operator">-&gt;</span>_pParent <span class="token operator">=</span> pPParent<span class="token punctuation">;</span>
	
	<span class="token comment">// 如果60是根节点，根新指向根节点的指针</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> pPParent<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		_pRoot <span class="token operator">=</span> pSubL<span class="token punctuation">;</span>
		pSubL<span class="token operator">-&gt;</span>_pParent <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 如果60是子树，可能是其双亲的左子树，也可能是右子树</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>pPParent<span class="token operator">-&gt;</span>_pLeft <span class="token operator">==</span> pParent<span class="token punctuation">)</span>
			pPParent<span class="token operator">-&gt;</span>_pLeft <span class="token operator">=</span> pSubL<span class="token punctuation">;</span>
		<span class="token keyword">else</span>
			pPParent<span class="token operator">-&gt;</span>_pRight <span class="token operator">=</span> pSubL<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token comment">// 根据调整后的结构更新部分节点的平衡因子</span>
	pParent<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> pSubL<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li><li> <p><strong>新节点插入较高右子树的右侧 - 右右：左单旋</strong></p> <p><img src="https://images2.imgbox.com/3c/5b/ZTly0GVg_o.png" alt="在这里插入图片描述"></p> <p>实现及情况考虑可参考右单旋。</p> </li><li> <p><strong>新节点插入较高左子树的右侧 - 左右：先左单旋再右单旋</strong></p> <p><img src="https://images2.imgbox.com/82/71/IMxlhLbn_o.png" alt="在这里插入图片描述"></p> <p>将双旋变成单旋后再旋转，即：<strong>先对 30 进行左单旋，然后再对 90 进行右单旋</strong>，旋转完成后再考虑平衡因子的更新。</p> <pre><code class="prism language-cpp"><span class="token comment">// 旋转之前，60的平衡因子可能是-1/0/1，旋转完成之后，根据情况对其他节点的平衡因子进行调整</span>
<span class="token keyword">void</span> <span class="token function">_RotateLR</span><span class="token punctuation">(</span>PNode pParent<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	PNode pSubL <span class="token operator">=</span> pParent<span class="token operator">-&gt;</span>_pLeft<span class="token punctuation">;</span>
	PNode pSubLR <span class="token operator">=</span> pSubL<span class="token operator">-&gt;</span>_pRight<span class="token punctuation">;</span>
	
	<span class="token comment">// 旋转之前，保存pSubLR的平衡因子，旋转完成之后，需要根据该平衡因子来调整其他节点的平衡因子</span>
	<span class="token keyword">int</span> bf <span class="token operator">=</span> pSubLR<span class="token operator">-&gt;</span>_bf<span class="token punctuation">;</span>
	
	<span class="token comment">// 先对30进行左单旋</span>
	<span class="token function">_RotateL</span><span class="token punctuation">(</span>pParent<span class="token operator">-&gt;</span>_pLeft<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">// 再对90进行右单旋</span>
	<span class="token function">_RotateR</span><span class="token punctuation">(</span>pParent<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">==</span> bf<span class="token punctuation">)</span>
		pSubL<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">==</span> bf<span class="token punctuation">)</span>
		pParent<span class="token operator">-&gt;</span>_bf <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li><li> <p><strong>新节点插入较高右子树的左侧 - 右左：先右单旋再左单旋</strong></p> <p><img src="https://images2.imgbox.com/46/ad/XoT0pOPB_o.png" alt="在这里插入图片描述"></p> <p>参考左右双旋。</p> </li></ol> 
<p>总结：</p> 
<p>假如以 pParent 为根的子树不平衡，即 pParent 的平衡因子为 2 或者 -2，分以下情况考虑：</p> 
<ol><li> <p>pParent 的平衡因子为 2，说明 pParent 的右子树高，设 pParent 的右子树的根为 pSubR：</p> 
  <ul><li>当 pSubR 的平衡因子为 1 时，执行左单旋；</li><li>当 pSubR 的平衡因子为 -1 时，执行右左双旋。</li></ul> </li><li> <p>pParent 的平衡因子为 -2，说明 pParent 的左子树高，设 pParent 的左子树的根为 pSubL：</p> 
  <ul><li>当 pSubL 的平衡因子为 -1 时，执行右单旋；</li><li>当 pSubL 的平衡因子为 1 时，执行左右双旋。</li></ul> </li></ol> 
<p>旋转完成后，原 pParent 为根的子树高度降低，已经平衡，不需要再向上更新。</p> 
<h2><a id="5_AVL__219"></a>5. AVL 树的验证</h2> 
<p>AVL 树是再二叉搜索树的基础上加入了平衡性的限制，因此要验证 AVL 树，可以分两步：</p> 
<ol><li> <p><strong>验证其为二叉搜索树</strong></p> <p>如果中序遍历可得到一个有序的序列，就说明为二叉搜索树。</p> </li><li> <p><strong>验证其为平衡树</strong></p> 
  <ul><li> <p>每个节点子树高度差的绝对值不超过 1（注意节点中如果没有平衡因子）；</p> </li><li> <p>节点的平衡因子是否计算正确。</p> <pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">_Height</span><span class="token punctuation">(</span>PNode pRoot<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">bool</span> <span class="token function">_IsBalanceTree</span><span class="token punctuation">(</span>PNode pRoot<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 空树也是AVL树</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">nullptr</span> <span class="token operator">==</span> pRoot<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	
	<span class="token comment">// 计算pRoot节点的平衡因子：即pRoot左右子树的高度差</span>
	<span class="token keyword">int</span> leftHeight <span class="token operator">=</span> <span class="token function">_Height</span><span class="token punctuation">(</span>pRoot<span class="token operator">-&gt;</span>_pLeft<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> rightHeight <span class="token operator">=</span> <span class="token function">_Height</span><span class="token punctuation">(</span>pRoot<span class="token operator">-&gt;</span>_pRight<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> diff <span class="token operator">=</span> rightHeight <span class="token operator">-</span> leftHeight<span class="token punctuation">;</span>
	
	<span class="token comment">// 如果计算出的平衡因子与pRoot的平衡因子不相等，或者pRoot平衡因子的绝对值超过1，则一定不是AVL树</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>diff <span class="token operator">!=</span> pRoot<span class="token operator">-&gt;</span>_bf <span class="token operator">||</span> <span class="token punctuation">(</span>diff <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">||</span> diff <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		
	<span class="token comment">// pRoot的左和右如果都是AVL树，则该树一定是AVL树</span>
	<span class="token keyword">return</span> <span class="token function">_IsBalanceTree</span><span class="token punctuation">(</span>pRoot<span class="token operator">-&gt;</span>_pLeft<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">_IsBalanceTree</span><span class="token punctuation">(</span>pRoot <span class="token operator">-&gt;</span> _pRight<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> </li><li> <p>验证用例</p> 
  <ul><li> <p>常规场景</p> <p>{ 16, 3, 7, 11, 9, 26, 18, 14, 15 }</p> </li><li> <p>特殊场景</p> <p>{ 4, 2, 6, 1, 3, 5, 15, 7, 16, 14 }</p> <p><img src="https://images2.imgbox.com/df/a4/FdpPbLBz_o.png" alt="在这里插入图片描述"></p> </li></ul> </li></ol> 
<h2><a id="6_AVL__262"></a>6. AVL 树的删除</h2> 
<p>因为 AVL 树也是二叉搜索树，可按照二叉搜索树的方式将节点删除，然后再更新平衡因子，只不过与删除不同的是，删除节点后的平衡因子更新，最差情况下一直要调整到根节点的位置。</p> 
<h2><a id="7_AVL__265"></a>7. AVL 树的性能</h2> 
<p>AVL 树是一棵绝对平衡的二叉搜索树，其要求每个节点的左右子树高度差的绝对值都不超过 1，这样可以保证查询时高效的时间复杂度，即 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         l 
        
       
         o 
        
        
        
          g 
         
        
          2 
         
        
       
         ( 
        
       
         N 
        
       
         ) 
        
       
      
        log_2 (N) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="mclose">)</span></span></span></span></span>。但是如果要对 AVL 树做一些结构修改的操作，性能非常低下，比如：插入时要维护其绝对平衡，旋转的次数比较多，更差的时在删除时，又可能一直要让旋转持续到根的位置。因此：如果需要一种查询高效且有序的数据结构，而且数据的个数为静态的（即不会改变），可以考虑 AVL 树，但一个结构经常修改，就不太适合。</p> 
<hr> 
<center>
  END 
</center>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0d1803018e7ebef873ec99bf62a1eb5c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring AI 使用本地 Ollama Embeddings</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8ef4bec419b1eb92c004c61aab2651c8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">《编程菜鸟学 Python 数据分析》让工作自动化起来！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>