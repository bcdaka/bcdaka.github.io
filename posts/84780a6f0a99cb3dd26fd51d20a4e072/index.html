<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>跨域&amp;解决方案 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/84780a6f0a99cb3dd26fd51d20a4e072/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="跨域&解决方案">
  <meta property="og:description" content="b站视频链接
跨域&amp;解决方案 浏览器的同源策略 同源策略概述 浏览器为确保资源安全，而遵循的一种策略
什么是源 源的组成部分
源=协议&#43;域名&#43;端口号
下面表格中，只有最后一行的两个源是同源
同源请求与非同源请求
总结：【所处源】与【目标源】不一致，就是【非同源】，又称【异源】或【跨域】
跨域会受到哪些限制 备注：在上述限制中，浏览器限制a ja x获取数据的限制是影响最的的一个，且实际开发中经常遇到
限制DOM访问 &lt;body&gt; &lt;button onclick=&#34;showDOM()&#34;&gt;showDOM&lt;/button&gt; &lt;!-- &lt;iframe id=&#34;framePage&#34; src=&#34;./demo.html&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt; --&gt; &lt;iframe id=&#34;framePage&#34; src=&#34;https://www.baidu.com&#34;&gt;&lt;/iframe&gt; &lt;/body&gt; &lt;script type=&#34;text/javascript&#34;&gt; function showDOM() { const framePage = document.getElementById(&#39;framePage&#39;) console.log(framePage.contentWindow.document) //同源的可以获取，非同源的无法获取 } &lt;/script&gt; 限制Cookie访问 &lt;body&gt; &lt;button onclick=&#34;showCookie()&#34;&gt;showCookie&lt;/button&gt; &lt;iframe id=&#34;framePage&#34; src=&#34;https://www.baidu.com&#34;&gt;&lt;/iframe&gt; &lt;/body&gt; &lt;script type=&#34;text/javascript&#34;&gt; function showCookie() { console.log(document.cookie) const framePage = document.getElementById(&#39;framePage&#39;) console.log(framePage.contentWindow.document.cookie) } &lt;/script&gt; 限制Ajax获取数据 &lt;body&gt; &lt;button onclick=&#34;getData()&#34;&gt;getData&lt;/button&gt; &lt;/body&gt; &lt;script type=&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-07T00:54:29+08:00">
    <meta property="article:modified_time" content="2024-08-07T00:54:29+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">跨域&amp;解决方案</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><a href="https://www.bilibili.com/video/BV1pT421k7yz/?spm_id_from=333.1007.tianma.8-2-28.click&amp;vd_source=3b8201a56fcc0537eaeb94b60148e7e4" rel="nofollow">b站视频链接</a></p> 
<h2><a id="_2"></a>跨域&amp;解决方案</h2> 
<h3><a id="_4"></a>浏览器的同源策略</h3> 
<h4><a id="_6"></a>同源策略概述</h4> 
<p>浏览器为确保资源安全，而遵循的一种策略</p> 
<h4><a id="_10"></a>什么是源</h4> 
<ol><li> <p>源的组成部分</p> <p>源=协议+域名+端口号</p> </li><li> <p>下面表格中，只有最后一行的两个源是同源</p> <p><img src="https://images2.imgbox.com/a9/1f/lbqsKYO4_o.png" alt="在这里插入图片描述"></p> </li><li> <p>同源请求与非同源请求</p> <p><img src="https://images2.imgbox.com/cf/4a/3glYVxE2_o.png" alt="在这里插入图片描述"></p> </li><li> <p>总结：【所处源】与【目标源】不一致，就是【非同源】，又称【异源】或【跨域】</p> </li></ol> 
<h3><a id="_28"></a>跨域会受到哪些限制</h3> 
<p><img src="https://images2.imgbox.com/97/87/IvVu78C6_o.png" alt="在这里插入图片描述"></p> 
<p>备注：在上述限制中，浏览器限制a ja x获取数据的限制是影响最的的一个，且实际开发中经常遇到</p> 
<h4><a id="DOM_37"></a>限制DOM访问</h4> 
<pre><code>&lt;body&gt;
    &lt;button onclick="showDOM()"&gt;showDOM&lt;/button&gt;

    &lt;!-- &lt;iframe id="framePage" src="./demo.html" frameborder="0"&gt;&lt;/iframe&gt; --&gt;
    &lt;iframe id="framePage" src="https://www.baidu.com"&gt;&lt;/iframe&gt;
  &lt;/body&gt;

  &lt;script type="text/javascript"&gt;
    function showDOM() {
      const framePage = document.getElementById('framePage')
      console.log(framePage.contentWindow.document) //同源的可以获取，非同源的无法获取
    }
  &lt;/script&gt;
</code></pre> 
<h4><a id="Cookie_57"></a>限制Cookie访问</h4> 
<pre><code>&lt;body&gt;
    &lt;button onclick="showCookie()"&gt;showCookie&lt;/button&gt;

    &lt;iframe id="framePage" src="https://www.baidu.com"&gt;&lt;/iframe&gt;
  &lt;/body&gt;

  &lt;script type="text/javascript"&gt;
    function showCookie() {
      console.log(document.cookie)
      const framePage = document.getElementById('framePage')
      console.log(framePage.contentWindow.document.cookie)
    }
  &lt;/script&gt;
</code></pre> 
<h4><a id="Ajax_77"></a>限制Ajax获取数据</h4> 
<pre><code>&lt;body&gt;
    &lt;button onclick="getData()"&gt;getData&lt;/button&gt;
  &lt;/body&gt;

  &lt;script type="text/javascript"&gt;
    async function getData() {
      const url = 'https://www.toutiao.com/hot-event/hot-board/?origin=toutiao_pc'
      let result = await fetch(url)
      let data = await result.json()
      console.log(data)
    }
  &lt;/script&gt;
</code></pre> 
<pre><code>Access to fetch at 'https://www.toutiao.com/hot-event/hot-board/?origin=toutiao_pc' from origin 'http://127.0.0.1:5500' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. If an opaque response serves your needs, set the request's mode to 'no-cors' to fetch the resource with CORS disabled.
</code></pre> 
<h3><a id="_100"></a>几个注意点</h3> 
<ol><li> <p>跨域限制仅存在浏览器端，服务端不存在跨域限制</p> </li><li> <p>即使跨域了，ajax请求也可以正常发出，但相应数据不会交给开发者</p> <p><img src="https://images2.imgbox.com/6d/15/JqDJo3Ry_o.png" alt="在这里插入图片描述"></p> </li><li> <p><code>link标签</code>、<code>script标签</code>、<code>img标签</code>等这些标签发出的请求也可能跨域，只不过浏览器对标签跨域不做严格限制，对开发几乎无影响</p> </li></ol> 
<h3><a id="CORSAjax_111"></a>CORS解决Ajax跨域方案</h3> 
<h4><a id="CORS_113"></a>CORS概述</h4> 
<p>CORS全称：<code>Cross-Origin Rresource Sharing(跨域资源共享)</code>，是用于控制浏览器校验跨域请求的一套规范，服务器依照CORS规范，添加特定响应头来控制浏览器校验，大致规则如下：</p> 
<ul><li>服务器明确表示拒绝跨域请求，或没有表示，则浏览器校验不通过</li><li>服务器明确表示允许跨域请求，则浏览器校验通过</li></ul> 
<p>备注：使用CORS解决跨域是最正统的方式，且要求服务器是“自己人”</p> 
<h4><a id="CORS_122"></a>CORS解决简单请求跨域</h4> 
<p>整体思路：服务器在给出响应时，通过添加<code>Access-Control-Allow-Origin</code>响应头，来明确表达允许某个源发起跨域请求，随后浏览器在校验时，直接通过</p> 
<p><img src="https://images2.imgbox.com/2c/c4/BUnvrWoC_o.png" alt="在这里插入图片描述"></p> 
<p>请求代码</p> 
<pre><code>&lt;body&gt;
	&lt;button onclick="getData()"&gt;getData&lt;/button&gt;
&lt;/body&gt;

&lt;script type="text/javascript"&gt;
  async function getData() {
    const url = 'http://127.0.0.1:8081/students'
    let result = await fetch(url)
    let data = await result.json()
    console.log(data)
  }
&lt;/script&gt;
</code></pre> 
<p>服务器代码（以express框架为例）</p> 
<pre><code>const express = require('express')
const app = express()

const students = [
  {
    id: 1,
    name: 'st1'
  },
  {
    id: 2,
    name: 'st2'
  },
  {
    id: 3,
    name: 'st3'
  }
]

app.get('/students', (req, res) =&gt; {
  res.setHeader('Access-Control-Allow-Origin', 'http://127.0.0.1:5500')
  res.send(students)
})

// 启动服务器
app.listen('8081', () =&gt; {
  console.log(`Server is running at http://127.0.0.1:8081`)
})
</code></pre> 
<h4><a id="_186"></a>简单请求与复杂请求</h4> 
<p>CORS会把请求分为两类，分别是 简单请求、复杂请求<br> <img src="https://images2.imgbox.com/e9/1f/7UnIwHAL_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/8a/42/Qdes8lt8_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="CORS_192"></a>CORS解决复杂请求跨域</h4> 
<ol><li> <p>第一步：服务器先通过浏览器的预检请求，服务器需要返回如下响应头</p> <p><img src="https://images2.imgbox.com/b0/e7/XH2O17Rb_o.png" alt="在这里插入图片描述"></p> <p><img src="https://images2.imgbox.com/f6/81/JS4YKK4H_o.png" alt="在这里插入图片描述"></p> </li><li> <p>第二步：处理实际的跨域请求（与处理简单请求跨域的方式相同）</p> <p>请求代码：</p> <pre><code>&lt;body&gt;
	&lt;button onclick="getData()"&gt;getData&lt;/button&gt;
&lt;/body&gt;

&lt;script type="text/javascript"&gt;
  async function getData() {
    const url = 'http://127.0.0.1:8081/students'
    let result = await fetch(url, {
      method: 'GET',
      headers: {
        name: 'ym',
        age: 120
      }
    })
    let data = await result.json()
    console.log(data)
  }
&lt;/script&gt;
</code></pre> <p>服务端代码：</p> <pre><code>const express = require('express')
const app = express()

const students = [
  {
    id: 1,
    name: 'st1'
  },
  {
    id: 2,
    name: 'st2'
  },
  {
    id: 3,
    name: 'st3'
  }
]
app.options('/students', (req, res) =&gt; {
  res.setHeader('Access-Control-Allow-Origin', 'http://127.0.0.1:5500')
  res.setHeader('Access-Control-Allow-Method', 'GET')
  res.setHeader('Access-Control-Allow-Headers', 'name,age')
  res.setHeader('Access-Control-Max-Age', 7200)
  res.send()
})
app.get('/students', (req, res) =&gt; {
  res.setHeader('Access-Control-Allow-Origin', 'http://127.0.0.1:5500')
  res.send(students)
})

// 启动服务器
app.listen('8081', () =&gt; {
  console.log(`Server is running at http://127.0.0.1:8081`)
})

</code></pre> </li></ol> 
<h4><a id="cors_268"></a>借助cors库快速完成配置</h4> 
<p>上述的配置需要自己配置响应头，或者需要自己手动封装中间件，借助cors库，可以更方便完成配置</p> 
<ol><li> <p>安装cors</p> <pre><code>npm i cors
</code></pre> </li><li> <p>简单配置cors</p> <pre><code>app.use(cors())
</code></pre> </li><li> <p>完整配置cors</p> <pre><code>const corOptions = {
  origin: 'http://127.0.0.1:5500', //允许的源
  methods: ['get', 'post', 'put', 'delete', 'head', 'options'], //允许的方法
  allowHeaders: ['name', 'age'], //允许的自定义头
  exposedHeaders: ['age'], //要暴露的响应头
  optionsSuccessStatus: 200 //预检请求成功的状态码
}
app.use(cors(corOptions))
</code></pre> </li></ol> 
<h3><a id="JSONP_299"></a>JSONP解决跨域问题</h3> 
<ol><li> <p>JSONP概述：JSONP是利用script标签可以跨域加载脚本，且不受严格限制的特性，可以说是程序员智慧的结晶，早期一些浏览器不支持CORS的时候，可以靠JSONP解决跨域</p> </li><li> <p>基本流程</p> 
  <ol><li>客户端创建一个script标签，并将其src属性设置为包含跨域请求的url。同时准备一个回调函数，这个回调函数用于处理返回的数据</li><li>服务端接收到请求后，将数据封装在回调函数中并返回</li><li>客户端的回调函数被调用，数据以参数的形式传入回调函数</li></ol> </li><li> <p>图示</p> <p><img src="https://images2.imgbox.com/fe/13/jXFOCo08_o.png" alt="在这里插入图片描述"></p> </li><li> <p>代码示例</p> <pre><code>&lt;body&gt;
	&lt;button onclick="getData()"&gt;getData&lt;/button&gt;
&lt;/body&gt;

&lt;script type="text/javascript"&gt;
  function test(data) {
  	console.log(data)
  }
  function getData() {
    const script = document.createElement('script')
    script.src = 'http://127.0.0.1:8081/students?callback=test'
    document.body.appendChild(script)

    script.onload = () =&gt; {
    	script.remove()
    }
  }
&lt;/script&gt;
</code></pre> <pre><code>app.get('/students', (req, res) =&gt; {
  const { callback } = req.query
  res.send(`${callback}(${JSON.stringify(students)})`)
})
</code></pre> </li><li> <p>jQuery封装的jsonp</p> <pre><code>&lt;script src="http://libs.baidu.com/jquery/2.0.0/jquery.min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript"&gt;
  $.getJSON('http://127.0.0.1:8081/students?callback=?', data =&gt; {
  	console.log(data)
  })
&lt;/script&gt;
</code></pre> </li></ol> 
<h3><a id="_358"></a>配置代理解决跨域</h3> 
<h4><a id="_360"></a>自己配置代理服务器</h4> 
<p>借助<code>http-proxy-middleware</code></p> 
<h4><a id="ngin_x_364"></a>使用ngin x搭建代理服务器</h4> 
<h4><a id="_366"></a>借助脚手架搭建服务器</h4>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c602a90abc53e2e010e3f129dc096f68/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于springboot&#43;vue&#43;uniapp的“口腔助手”小程序</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b4113d3923bf36f2b241d12ad7a3b4d4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JavaEE: wait(等待) / notify (通知)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>