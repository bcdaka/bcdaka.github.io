<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>查找——散列表（哈希表）的查找 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/0da936ab097e90d8aeaedf5523743dc9/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="查找——散列表（哈希表）的查找">
  <meta property="og:description" content="前面的文章介绍了线性表及树表的查找算法：
查找的基本概念，线性表的顺序查找
线性表的折半查找与分块查找
查找——树表之二叉排序树
查找—树表之平衡二叉树
这篇文章则介绍散列表（即哈希表）的查找方法。
一，哈希表的构造 基本概念 •优点：查找速度极快O(1),查找效率与元素个数n无关。
例1：
若将学生信息按如下方式存入计算机，如：
将2001011810201的所有信息存入V[01]单元；
将2001011810202的所有信息存入V[02]单元；
……
将2001011810231的所有信息存入V[31]单元 查找2001011810216的信息，可直接访问V[16]！
例2：
数据元素序列(14，23，39，9，25，11)，若规定每个元素k的存储地址H（k）＝k，请画出存储结构图。
如何进行哈希表的查找？
根据哈希函数H（k）＝k
查找key=9,则访问H(9)=9号地址，若内容为9则成功； 若查不到，则返回一个特殊值，如空指针或空记录 我们需要知道以下概念： 哈希方法(杂凑法)
选取某个函数，依该函数按关键字计算元素的存储位置，并按此存放；
查找时，由同一个函数对给定值k计算地址，将k与地址单元中元素关键码进行比，确定查找是否成功。
哈希函数(杂凑函数)：哈希方法中使用的转换函数。
哈希表(杂凑表)：按上述思想构造的表。
冲 突：不同的关键码映射到同一个哈希地址 。key1 ！=key2，但H(key1)=H(key2)
同义词：具有相同函数值的两个关键字。
具体什么是冲突呢？我们来看一个例子：
冲突是不可避免的，那么我们如何才能减少冲突？
（1）构造好的哈希函数
（2）制定一个好的解决冲突方案
构造好的哈希函数 (a)所选函数尽可能简单，以便提高转换速度;
(b)所选函数对关键码计算出的地址，应在散列地址集中致均匀分布，以减少空间浪费。
构造好的哈希函数，我们需要考虑以下因素：
根据元素集合的特性构造
要求一：地址空间尽量小
要求二：均匀
则有以下方法：
1.直接定址法 2.数字分析法 3.平方取中法 4.折叠法 5.除留余数法 6.随机数法 1. 直接定址法 Hash(key) = a·key &#43; b (a、b为常数)
优点：以关键码key的某个线性函数值为哈希地址，不会产生冲突。
缺点：要占用连续地址空间，空间效率低。 例： {100，300，500，700，800，900}，哈希函数Hash(key)=key/100
2.除留余数法 Hash(key)=key mod p (p是一个整数)
通过计算出散列表中元素除以7得到的余数作为存储地址的位置">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-23T23:46:04+08:00">
    <meta property="article:modified_time" content="2024-07-23T23:46:04+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">查找——散列表（哈希表）的查找</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>前面的文章介绍了线性表及树表的查找算法：</p> 
<p><a class="link-info" href="http://t.csdnimg.cn/sP0vR" rel="nofollow" title="查找的基本概念，线性表的顺序查找">查找的基本概念，线性表的顺序查找</a></p> 
<p><a class="link-info" href="http://t.csdnimg.cn/4Q9Gw" rel="nofollow" title="线性表的折半查找与分块查找">线性表的折半查找与分块查找</a></p> 
<p><a class="link-info" href="http://t.csdnimg.cn/kd2Wa" rel="nofollow" title="查找——树表之二叉排序树">查找——树表之二叉排序树</a></p> 
<p><a class="link-info" href="http://t.csdnimg.cn/WiTRj" rel="nofollow" title="查找—树表之平衡二叉树">查找—树表之平衡二叉树</a></p> 
<p>这篇文章则介绍散列表（即哈希表）的查找方法。</p> 
<h2>一，哈希表的构造</h2> 
<h4>基本概念</h4> 
<p class="img-center"><img alt="" height="145" src="https://images2.imgbox.com/13/fb/kkK4Bz1K_o.png" width="466"></p> 
<p>•<span style="color:#3333cc;">优点：</span><span style="color:#000000;">查找速度极快</span><span style="color:#ff3300;">O(1),</span><span style="color:#000000;">查找效率与元素个数</span><span style="color:#000000;">n</span><span style="color:#000000;">无关。</span></p> 
<p>例1：</p> 
<p style="margin-left:.63in;text-align:left;"><span style="color:#000000;">若将学生信息按如下方式存入计算机，如：</span></p> 
<p style="margin-left:.63in;text-align:left;"><span style="color:#000000;">将</span><span style="color:#000000;">20010118102</span><span style="color:#ff33cc;">01</span><span style="color:#000000;">的所有信息存入</span><span style="color:#000000;">V[</span><span style="color:#000000;">01</span><span style="color:#000000;">]</span><span style="color:#000000;">单元；</span></p> 
<p style="margin-left:.63in;text-align:left;"><span style="color:#000000;">将</span><span style="color:#000000;">20010118102</span><span style="color:#ff33cc;">02</span><span style="color:#000000;">的所有信息存入</span><span style="color:#000000;">V[</span><span style="color:#000000;">02</span><span style="color:#000000;">]</span><span style="color:#000000;">单元；</span></p> 
<p style="margin-left:.63in;text-align:left;"><span style="color:#000000;">……</span></p> 
<p><span style="color:#000000;">              将20010118102</span><span style="color:#ff33cc;">31</span><span style="color:#000000;">的所有信息存入</span><span style="color:#000000;">V[31]</span><span style="color:#000000;">单元</span> </p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#000000;">查找</span><span style="color:#000000;">20010118102</span><span style="color:#ff3300;">16</span><span style="color:#000000;">的信息，可直接访问</span><span style="color:#ff3300;">V[16]</span><span style="color:#ff33cc;">！</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#0d0016;">例2：</span></p> 
<p style="margin-left:0in;text-align:justify;"><span style="color:#000000;">        数据元素序列(14</span><span style="color:#000000;">，</span><span style="color:#000000;">23</span><span style="color:#000000;">，</span><span style="color:#000000;">39</span><span style="color:#000000;">，</span><span style="color:#000000;">9</span><span style="color:#000000;">，</span><span style="color:#000000;">25</span><span style="color:#000000;">，</span><span style="color:#000000;">11)</span><span style="color:#000000;">，若规定每个元素</span><span style="color:#000000;">k</span><span style="color:#000000;">的存储地址</span><span style="color:#000000;">H</span><span style="color:#000000;">（</span><span style="color:#000000;">k</span><span style="color:#000000;">）＝</span><span style="color:#000000;">k</span><span style="color:#000000;">，请画出存储结构图。</span></p> 
<p class="img-center"><img alt="" height="74" src="https://images2.imgbox.com/f4/09/dNUg92dO_o.png" width="534"></p> 
<p>如何进行哈希表的查找？</p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#000000;">        根据哈希函数</span><span style="color:#ff3300;">H</span><span style="color:#ff3300;">（</span><span style="color:#ff3300;">k</span><span style="color:#ff3300;">）＝</span><span style="color:#ff3300;">k</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#000000;">        查找key=9,</span><span style="color:#000000;">则访问</span><span style="color:#000000;">H(9)=9</span><span style="color:#000000;">号地址，若内容为</span><span style="color:#000000;">9</span><span style="color:#000000;">则成功；</span> </p> 
<p><span style="color:#000000;">        若查不到，则返回一个特殊值，如空指针或空记录</span> </p> 
<p>我们需要知道以下概念： </p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#3333cc;">哈希方法</span><span style="color:#3333cc;">(</span><span style="color:#3333cc;">杂凑法</span><span style="color:#3333cc;">)</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#000000;">选取某个</span><span style="color:#ff3300;">函数</span><span style="color:#000000;">，依该函数按关键字计算元素的存储位置，并按此存放；</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#000000;">查找时，由同一个函数对给定值</span><span style="color:#000000;">k</span><span style="color:#000000;">计算地址，</span><span style="color:#ff3300;">将</span><span style="color:#ff3300;">k</span><span style="color:#ff3300;">与地址单元中元素关键码进行比</span><span style="color:#000000;">，确定查找是否成功。</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#3333cc;">哈希函数</span><span style="color:#3333cc;">(</span><span style="color:#3333cc;">杂凑函数</span><span style="color:#3333cc;">)</span><span style="color:#3333cc;">：</span><span style="color:#000000;">哈希方法中使用的</span><span style="color:#ff3300;">转换函数</span><span style="color:#000000;">。</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#0000ff;">哈希表</span><span style="color:#0000ff;">(</span><span style="color:#0000ff;">杂凑表</span><span style="color:#0000ff;">)</span><span style="color:#0000ff;">：</span><span style="color:#000000;">按上述思想构造的表。</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#0000ff;">冲 突：</span><span style="color:#ff3300;">不同的关键码映射到同一个哈希地址 </span><span style="color:#000000;">。key1</span> ！=<span style="color:#000000;">key2</span><span style="color:#000000;">，</span><span style="color:#000000;">但</span><span style="color:#000000;">H(key1)=H(key2)</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#0000ff;">同义词：</span><span style="color:#000000;">具有</span><span style="color:#ff3300;">相同函数值</span><span style="color:#000000;">的两个关键字。</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#000000;">具体什么是冲突呢？我们来看一个例子：</span></p> 
<p class="img-center"><img alt="" height="259" src="https://images2.imgbox.com/a1/c2/MSMVdHjV_o.png" width="520"></p> 
<p>冲突是不可避免的，那么我们如何才能减少冲突？</p> 
<p>（1）构造好的哈希函数</p> 
<p>（2）制定一个好的解决冲突方案</p> 
<p></p> 
<h4 style="margin-left:0in;text-align:left;"><span style="color:#000000;">构造好的哈希函数</span></h4> 
<p style="margin-left:0in;text-align:left;"><span style="color:#000000;">        (a)所选函数尽可能简单，以便提高转换速度;</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#000000;">        (b)所选函数对关键码计算出的地址，应在散列地址集中致均匀分布，以减少空间浪费。</span></p> 
<p style="margin-left:0in;text-align:left;">构造好的哈希函数，我们需要考虑以下因素：</p> 
<p class="img-center"><img alt="" height="73" src="https://images2.imgbox.com/69/b1/Vomfyxo1_o.png" width="556"></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#000000;">根据元素集合的特性构造</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#ff3300;">　要求一：地址空间尽量小</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#ff3300;">　要求二：均匀</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#0d0016;">则有以下方法：</span></p> 
<p style="margin-left:0in;text-align:left;">1.<span style="color:#ff0000;">直接定址法 </span>  2.<span style="color:#000000;">数字分析法  </span>3.<span style="color:#000000;">平方取中法  </span>4.<span style="color:#000000;">折叠法  </span>5.<span style="color:#ff3300;">除留余数法  </span>6.<span style="color:#000000;">随机数法 </span></p> 
<p style="margin-left:0in;text-align:left;"></p> 
<h5>1. 直接定址法</h5> 
<p style="margin-left:.94in;text-align:justify;"><span style="color:#ff3300;">Hash(key) = </span><span style="color:#ff3300;">a·key</span><span style="color:#ff3300;"> + b    (a</span><span style="color:#ff3300;">、</span><span style="color:#ff3300;">b</span><span style="color:#ff3300;">为常数</span><span style="color:#ff3300;">)</span></p> 
<p>优点：<span style="color:#000000;">以关键码</span><span style="color:#000000;">key</span><span style="color:#000000;">的某个线性函数值为哈希地址，不会产生冲突。</span></p> 
<p><span style="color:#000000;">缺点：要占用连续地址空间，空间效率低。 </span></p> 
<p><span style="color:#000000;">例：</span><span style="color:#ff0000;"> </span><span style="color:#000000;">{100</span><span style="color:#000000;">，</span><span style="color:#000000;">300</span><span style="color:#000000;">，</span><span style="color:#000000;">500</span><span style="color:#000000;">，</span><span style="color:#000000;">700</span><span style="color:#000000;">，</span><span style="color:#000000;">800</span><span style="color:#000000;">，</span><span style="color:#000000;">900}</span><span style="color:#000000;">，哈希函数Hash(key)=key/100</span></p> 
<p class="img-center"><img alt="" height="82" src="https://images2.imgbox.com/f9/1d/D37rYmPz_o.png" width="450"></p> 
<h5> 2.除留余数法</h5> 
<p style="margin-left:0in;text-align:center;"><span style="color:#ff3300;">Hash(key)=key  mod  p    (p</span><span style="color:#ff3300;">是一个整数</span><span style="color:#ff3300;">)</span></p> 
<p></p> 
<p class="img-center"><img alt="" height="198" src="https://images2.imgbox.com/88/a1/G07Jnhmv_o.png" width="370"></p> 
<p class="img-center"><img alt="" height="106" src="https://images2.imgbox.com/18/32/2drD20Mo_o.png" width="527"></p> 
<p>通过计算出散列表中元素除以7得到的余数作为存储地址的位置</p> 
<p class="img-center"><img alt="" height="107" src="https://images2.imgbox.com/e7/7e/RqNCikq6_o.png" width="556"></p> 
<p>如果两个数的余数一样时，就出现了冲突，那么如何处理冲突呢？</p> 
<h4>处理冲突的两种方法：</h4> 
<h5>1.开放地址法（开地址法）</h5> 
<p><span style="color:#0000ff;">        基本思想：</span><span style="color:#000000;">有冲突时就去</span><span style="color:#ff3300;">寻找下一个空</span><span style="color:#000000;">的哈希地址，只要哈希表足够大，空的哈希地址总能找到，并将数据元素存入。 </span></p> 
<h6>A.线性探测法</h6> 
<p style="margin-left:0in;text-align:center;"><span style="color:#fe2c24;">Hi=(Hash(key)+di) mod m       ( 1≤i &lt; m )</span></p> 
<p style="margin-left:0in;text-align:center;"><span style="color:#fe2c24;">其中：m为哈希表长度</span></p> 
<p style="margin-left:0in;text-align:center;"><span style="color:#fe2c24;">di 为增量序列 1，2，…m-1，且di=i</span></p> 
<p><span style="color:#0d0016;">一旦冲突，就找下一个空地址存入旦冲突，就找下一个空地址存入 </span></p> 
<p><span style="color:#0d0016;">例：</span></p> 
<p><span style="color:#000000;">关键码集为 {47</span><span style="color:#000000;">，</span><span style="color:#000000;">7</span><span style="color:#000000;">，</span><span style="color:#000000;">29</span><span style="color:#000000;">，</span><span style="color:#000000;">11</span><span style="color:#000000;">，</span><span style="color:#000000;">16</span><span style="color:#000000;">，</span><span style="color:#000000;">92</span><span style="color:#000000;">，</span><span style="color:#000000;">22</span><span style="color:#000000;">，</span><span style="color:#000000;">8</span><span style="color:#000000;">，</span><span style="color:#000000;">3}</span><span style="color:#000000;">，</span></p> 
<p style="margin-left:0in;text-align:justify;"><span style="color:#ff0000;">设：</span><span style="color:#000000;">哈希表表长为</span><span style="color:#000000;">m=11</span><span style="color:#000000;">；</span></p> 
<p style="margin-left:0in;text-align:justify;"><span style="color:#000000;">        哈希函数为Hash(key)=key mod 11    </span></p> 
<p class="img-center"><img alt="" height="101" src="https://images2.imgbox.com/00/5e/Q4TePyMX_o.png" width="500"></p> 
<p>我们可以得到用线性探测法处理冲突的过程： </p> 
<p class="img-center"><img alt="" height="146" src="https://images2.imgbox.com/31/04/7VcUDWq4_o.png" width="500"></p> 
<p> 线性探测法的优点：<span style="color:#000000;">只要哈希表未被填满，保证能找到一个空地址单元存放有冲突的元素。</span></p> 
<p><span style="color:#000000;">                       缺点：可能使第</span><span style="color:#000000;">i</span><span style="color:#000000;">个哈希地址的同义词存入第</span><span style="color:#000000;">i+1</span><span style="color:#000000;">个地址，这样本应存入第i+1个哈希地址的元素变成了第i+2个哈希地址的同义词，</span><span style="color:#000000;">……</span><span style="color:#000000;">，产生“聚集”现象，降低查找效率。</span></p> 
<p><span style="color:#000000;">为了解决这种现象，我们引入了另一种方法处理冲突：</span></p> 
<h6><span style="color:#000000;">B</span><span style="color:#000000;">.二次探测法</span></h6> 
<p style="margin-left:0in;text-align:center;"><span style="color:#fe2c24;">Hi=(Hash(key)±di) mod m</span></p> 
<p style="margin-left:0in;text-align:center;"><span style="color:#fe2c24;">其中：m为哈希表长度，m要求是某个4k+3的质数；</span></p> 
<p style="margin-left:0in;text-align:center;"><span style="color:#fe2c24;">      di为增量序列 12，-12，22，-22，…，q2</span></p> 
<p>例:</p> 
<p style="margin-left:0in;text-align:justify;"><span style="color:#000000;">关键码集为 </span><span style="color:#000000;">{47</span><span style="color:#000000;">，</span><span style="color:#000000;">7</span><span style="color:#000000;">，</span><span style="color:#000000;">29</span><span style="color:#000000;">，</span><span style="color:#000000;">11</span><span style="color:#000000;">，</span><span style="color:#000000;">16</span><span style="color:#000000;">，</span><span style="color:#000000;">92</span><span style="color:#000000;">，</span><span style="color:#000000;">22</span><span style="color:#000000;">，</span><span style="color:#000000;">8</span><span style="color:#000000;">，</span><span style="color:#000000;">3}</span><span style="color:#000000;">，</span></p> 
<p style="margin-left:0in;text-align:justify;"><span style="color:#ff0000;">设：    </span><span style="color:#000000;">哈希函数为</span><span style="color:#000000;">Hash(key)=key mod 11    </span></p> 
<p class="img-center"><img alt="" height="126" src="https://images2.imgbox.com/e5/5d/CKSCpIM7_o.png" width="500"></p> 
<p style="margin-left:0in;text-align:justify;"><span style="color:#000000;">Hash(3)=3</span><span style="color:#000000;">，哈希地址冲突，由</span></p> 
<p style="margin-left:0in;text-align:justify;"><span style="color:#000000;">H</span><span style="color:#000000;">1</span><span style="color:#000000;">=(Hash(3)+1*1</span><span style="color:#000000;">) mod 11=4</span><span style="color:#000000;">，仍然冲突；</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#000000;">H</span><span style="color:#000000;">2</span><span style="color:#000000;">=(Hash(3)</span><span style="color:#ff0000;">+（-1)*(-1)</span><span style="color:#000000;">) mod 11=</span><span style="color:#ff0000;">2</span><span style="color:#000000;">，找到空的哈希地址，存入。 </span></p> 
<h6> C.伪随机探测法</h6> 
<p style="margin-left:0in;text-align:center;"><span style="color:#000000;">H</span><span style="color:#000000;">i</span><span style="color:#000000;">=(Hash(key)+d</span><span style="color:#000000;">i</span><span style="color:#000000;">) mod m</span><span style="color:#000000;">       ( 1≤i &lt; m )</span></p> 
<p style="margin-left:0in;text-align:center;"><span style="color:#000000;">其中：</span><span style="color:#000000;">m</span><span style="color:#000000;">为哈希表长度</span></p> 
<p style="margin-left:0in;text-align:center;"><span style="color:#000000;">d</span><span style="color:#000000;">i</span> <span style="color:#000000;">为随机数</span></p> 
<h5> <span style="color:#0d0016;">2.链地址法（拉链法）</span></h5> 
<p style="margin-left:0in;text-align:left;"><span style="color:#0000ff;">基本思想：</span><span style="color:#000000;">相同哈希地址的记录链成一单链表，</span><span style="color:#ff3300;">m</span><span style="color:#ff3300;">个哈希地址就设</span><span style="color:#ff3300;">m</span><span style="color:#ff3300;">个单链表</span><span style="color:#000000;">，然后用用一个数组将</span><span style="color:#000000;">m</span><span style="color:#000000;">个单链表的表头指针存储起来，形成一个动态的结构。</span></p> 
<p class="img-center"><img alt="" height="481" src="https://images2.imgbox.com/f4/5e/Uuq8Lkra_o.png" width="1000"></p> 
<p><span style="color:#0d0016;">链地址法建立哈希表步骤 ：</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#000000;">step1 </span><span style="color:#000000;">取数据元素的关键字</span><span style="color:#000000;">key</span><span style="color:#000000;">，计算其哈希地址。若该地址对应的链表为空，则将该元素插入此链表；否则执行</span><span style="color:#000000;">step2</span><span style="color:#000000;">解决冲突。 </span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#000000;">step2 </span><span style="color:#000000;">根据选择的冲突处理方法，计算关键字</span><span style="color:#000000;">key</span><span style="color:#000000;">的下一个存储地址。若该地址对应的链表为不为空，则利用链表的前插法或后插法将该元素插入此链表。</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#000000;">链地址法的优点：</span></p> 
<p style="margin-left:0in;text-align:justify;"><span style="color:#000000;">同义词不会冲突，无“聚集”现象</span></p> 
<p style="margin-left:0in;text-align:justify;"><span style="color:#000000;">链表上结点空间动态申请，更适合于表长不确定的情况</span></p> 
<h2 style="margin-left:0in;text-align:justify;"><span style="color:#000000;">二，哈希表的查找</span></h2> 
<p class="img-center"><img alt="" height="555" src="https://images2.imgbox.com/7e/f2/VVJzYGiF_o.png" width="800"></p> 
<p style="margin-left:0in;text-align:left;">例：</p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#000000;">已知一组关键字</span><span style="color:#000000;">(19,14,23,1,68,20,84,27,55,11,10,79)</span></p> 
<p style="margin-left:0in;text-align:left;">  <span style="color:#000000;">哈希函数为：</span><span style="color:#000000;">H(key)=key MOD 13, </span><span style="color:#000000;">哈希表长为</span><span style="color:#000000;">m=16</span><span style="color:#000000;">，</span></p> 
<p style="margin-left:0in;text-align:left;">  <span style="color:#000000;">设每个记录的查找概率相等</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#0000ff;">(1)  </span><span style="color:#0000ff;">用线性探测再散列处理冲突，即</span><span style="color:#0000ff;">Hi=(H(key)+di) MOD m</span></p> 
<p class="img-center"><img alt="" height="503" src="https://images2.imgbox.com/2e/68/4d0uHszc_o.png" width="1200"></p> 
<p><span style="color:#ff3300;">ASL=(1*6+2+3*3+4+9)/12=2.5</span></p> 
<p><span style="color:#0000ff;">(2)  </span><span style="color:#0000ff;">用链地址法处理冲突</span></p> 
<p><span style="color:#000000;">关键字</span><span style="color:#000000;">(19,14,23,1,68,20,84,27,55,11,10,79)</span></p> 
<p class="img-center"><img alt="" height="374" src="https://images2.imgbox.com/84/8b/DqU41buC_o.png" width="500"></p> 
<p><span style="color:#ff3300;"><strong>ASL=(1*6+2*4+3+4)/12=1.75</strong></span></p> 
<p><span style="color:#0d0016;"><strong>对于这个例子，我们思考是用无序表查找还是有序表折半查找？ASL又如何？</strong></span></p> 
<p>从哈希表的查找效率分析</p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#000000;">使用平均查找长度</span><span style="color:#ff3300;">ASL</span><span style="color:#ff3300;">来衡量查找算法，</span><span style="color:#ff3300;">ASL</span><span style="color:#ff3300;">取决于</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#0000ff;">哈希函数</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#0000ff;">处理冲突的方法</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#0000ff;">哈希表的装填因子</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#000000;"><strong>a</strong></span> <span style="color:#000000;">越大，表中记录数越多，说明表装得越满，发生冲突的可能性就越大，查找时比较次数就越多。</span></p> 
<p class="img-center"><img alt="" height="75" src="https://images2.imgbox.com/1a/3f/W7eqwhs9_o.png" width="300"></p> 
<p class="img-center"><img alt="" height="264" src="https://images2.imgbox.com/27/89/GjIFEA3u_o.png" width="500"></p> 
<p></p> 
<p>我们可以得到以下结论：</p> 
<p><span style="color:#000000;">哈希表技术具有很好的平均性能，优于传统技术</span> </p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#000000;">链地址法优于开地址法</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#000000;">除留余数法优于其它哈希函数</span></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c066c85205ba51e373cd976844a0e172/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【数据结构】二叉树——顺序结构——堆及其实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1fb0dd0c8f718b21e3a3b2d42ee866a4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">图——图的遍历（DFS与BFS算法详解）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>