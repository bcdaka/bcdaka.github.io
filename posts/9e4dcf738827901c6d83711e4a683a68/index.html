<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2023年最新JavaScript 基础面试题（62题&amp;附答案） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/9e4dcf738827901c6d83711e4a683a68/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="2023年最新JavaScript 基础面试题（62题&附答案）">
  <meta property="og:description" content="目录
1. 介绍 JavaScript 的基本数据类型?
2. 浅谈 JavaScript 中变量和函数声明的提升?
3. 什么是闭包，闭包有什么特性？
4. 说说对闭包的理解和闭包的作用
5. 说说 This 对象的理解
6. 事件模型的理解
7. new 操作符具体干了什么?
8. 说说栈和堆的理解，以及它们的区别?
9. JS 数组和对象的遍历方式，以及几种方式的比较
10. map 与 forEach 的区别
11. 谈一谈箭头函数与普通函数的区别?
12. JavaScript 定义类的 4 种方法
13. JavaScript 实现继承的 3 种方法
14. 对原生 Javascript 了解程度
15. Js 动画与 CSS 动画区别及相应实现
16. 谈一谈你理解的函数式编程
17. 说说你对作用域链的理解
18. JavaScript 原型，原型链 ? 有什么特点？
19. 说说什么是事件代理?
20. 说说 ajax 原理?
21. 说说如何解决跨域问题?">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-07-25T22:21:25+08:00">
    <meta property="article:modified_time" content="2023-07-25T22:21:25+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2023年最新JavaScript 基础面试题（62题&amp;附答案）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="main-toc-toc" style="margin-left:40px;"><a href="#main-toc" rel="nofollow">1. 介绍 JavaScript 的基本数据类型?</a></p> 
<p id="2.%20%E6%B5%85%E8%B0%88%20JavaScript%20%E4%B8%AD%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E7%9A%84%E6%8F%90%E5%8D%87%3F-toc" style="margin-left:40px;"><a href="#2.%20%E6%B5%85%E8%B0%88%20JavaScript%20%E4%B8%AD%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E7%9A%84%E6%8F%90%E5%8D%87%3F" rel="nofollow">2. 浅谈 JavaScript 中变量和函数声明的提升?</a></p> 
<p id="3.%20%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%EF%BC%8C%E9%97%AD%E5%8C%85%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E6%80%A7%EF%BC%9F-toc" style="margin-left:40px;"><a href="#3.%20%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%EF%BC%8C%E9%97%AD%E5%8C%85%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E6%80%A7%EF%BC%9F" rel="nofollow">3. 什么是闭包，闭包有什么特性？</a></p> 
<p id="4.%20%E8%AF%B4%E8%AF%B4%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E9%97%AD%E5%8C%85%E7%9A%84%E4%BD%9C%E7%94%A8-toc" style="margin-left:40px;"><a href="#4.%20%E8%AF%B4%E8%AF%B4%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E9%97%AD%E5%8C%85%E7%9A%84%E4%BD%9C%E7%94%A8" rel="nofollow">4. 说说对闭包的理解和闭包的作用</a></p> 
<p id="5.%20%E8%AF%B4%E8%AF%B4%20This%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3-toc" style="margin-left:40px;"><a href="#5.%20%E8%AF%B4%E8%AF%B4%20This%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3" rel="nofollow">5. 说说 This 对象的理解</a></p> 
<p id="6.%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3W3C%20%E4%B8%AD%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%8F%91%E7%94%9F%E7%BB%8F%E5%8E%86%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5-toc" style="margin-left:40px;"><a href="#6.%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3W3C%20%E4%B8%AD%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%8F%91%E7%94%9F%E7%BB%8F%E5%8E%86%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5" rel="nofollow">6. 事件模型的理解</a></p> 
<p id="7.%20new%20%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%3F-toc" style="margin-left:40px;"><a href="#7.%20new%20%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%3F" rel="nofollow">7. new 操作符具体干了什么?</a></p> 
<p id="8.%20%E8%AF%B4%E8%AF%B4%E6%A0%88%E5%92%8C%E5%A0%86%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB%3F-toc" style="margin-left:40px;"><a href="#8.%20%E8%AF%B4%E8%AF%B4%E6%A0%88%E5%92%8C%E5%A0%86%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB%3F" rel="nofollow">8. 说说栈和堆的理解，以及它们的区别?</a></p> 
<p id="9.%20JS%20%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83-toc" style="margin-left:40px;"><a href="#9.%20JS%20%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83" rel="nofollow">9. JS 数组和对象的遍历方式，以及几种方式的比较</a></p> 
<p id="10.%20map%20%E4%B8%8E%20forEach%20%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#10.%20map%20%E4%B8%8E%20forEach%20%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">10. map 与 forEach 的区别</a></p> 
<p id="11.%20%E8%B0%88%E4%B8%80%E8%B0%88%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%3F-toc" style="margin-left:40px;"><a href="#11.%20%E8%B0%88%E4%B8%80%E8%B0%88%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%3F" rel="nofollow">11. 谈一谈箭头函数与普通函数的区别?</a></p> 
<p id="12.%20JavaScript%20%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%204%20%E7%A7%8D%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#12.%20JavaScript%20%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%204%20%E7%A7%8D%E6%96%B9%E6%B3%95" rel="nofollow">12. JavaScript 定义类的 4 种方法</a></p> 
<p id="13.%20JavaScript%20%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%203%20%E7%A7%8D%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#13.%20JavaScript%20%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%203%20%E7%A7%8D%E6%96%B9%E6%B3%95" rel="nofollow">13. JavaScript 实现继承的 3 种方法</a></p> 
<p id="14.%20%E5%AF%B9%E5%8E%9F%E7%94%9F%20Javascript%20%E4%BA%86%E8%A7%A3%E7%A8%8B%E5%BA%A6-toc" style="margin-left:40px;"><a href="#14.%20%E5%AF%B9%E5%8E%9F%E7%94%9F%20Javascript%20%E4%BA%86%E8%A7%A3%E7%A8%8B%E5%BA%A6" rel="nofollow">14. 对原生 Javascript 了解程度</a></p> 
<p id="15.%20Js%20%E5%8A%A8%E7%94%BB%E4%B8%8E%20CSS%20%E5%8A%A8%E7%94%BB%E5%8C%BA%E5%88%AB%E5%8F%8A%E7%9B%B8%E5%BA%94%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#15.%20Js%20%E5%8A%A8%E7%94%BB%E4%B8%8E%20CSS%20%E5%8A%A8%E7%94%BB%E5%8C%BA%E5%88%AB%E5%8F%8A%E7%9B%B8%E5%BA%94%E5%AE%9E%E7%8E%B0" rel="nofollow">15. Js 动画与 CSS 动画区别及相应实现</a></p> 
<p id="16.%20%E8%B0%88%E4%B8%80%E8%B0%88%E4%BD%A0%E7%90%86%E8%A7%A3%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-toc" style="margin-left:40px;"><a href="#16.%20%E8%B0%88%E4%B8%80%E8%B0%88%E4%BD%A0%E7%90%86%E8%A7%A3%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B" rel="nofollow">16. 谈一谈你理解的函数式编程</a></p> 
<p id="17.%20%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E7%9A%84%E7%90%86%E8%A7%A3-toc" style="margin-left:40px;"><a href="#17.%20%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E7%9A%84%E7%90%86%E8%A7%A3" rel="nofollow">17. 说说你对作用域链的理解</a></p> 
<p id="18.%20JavaScript%20%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%20%3F%20%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F-toc" style="margin-left:40px;"><a href="#18.%20JavaScript%20%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%20%3F%20%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F" rel="nofollow">18. JavaScript 原型，原型链 ? 有什么特点？</a></p> 
<p id="19.%20%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%3F-toc" style="margin-left:40px;"><a href="#19.%20%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%3F" rel="nofollow">19. 说说什么是事件代理?</a></p> 
<p id="20.%20%E8%AF%B4%E8%AF%B4%20ajax%20%E5%8E%9F%E7%90%86%3F-toc" style="margin-left:40px;"><a href="#20.%20%E8%AF%B4%E8%AF%B4%20ajax%20%E5%8E%9F%E7%90%86%3F" rel="nofollow">20. 说说 ajax 原理?</a></p> 
<p id="21.%20%E8%AF%B4%E8%AF%B4%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%3F-toc" style="margin-left:40px;"><a href="#21.%20%E8%AF%B4%E8%AF%B4%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%3F" rel="nofollow">21. 说说如何解决跨域问题?</a></p> 
<p id="22.%20%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%20JS%20%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%3F-toc" style="margin-left:40px;"><a href="#22.%20%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%20JS%20%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%3F" rel="nofollow">22. 异步加载 JS 的方式有哪些?</a></p> 
<p id="23.%20%E9%82%A3%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%BC%9A%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%3F-toc" style="margin-left:40px;"><a href="#23.%20%E9%82%A3%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%BC%9A%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%3F" rel="nofollow">23. 那些操作会造成内存泄漏?</a></p> 
<p id="24.%20%E4%BB%8B%E7%BB%8D%20JS%20%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%3F-toc" style="margin-left:40px;"><a href="#24.%20%E4%BB%8B%E7%BB%8D%20JS%20%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%3F" rel="nofollow">24. 介绍 JS 有哪些内置对象?</a></p> 
<p id="25.%20%E8%AF%B4%E5%87%A0%E6%9D%A1%E5%86%99%20JavaScript%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E8%8C%83-toc" style="margin-left:40px;"><a href="#25.%20%E8%AF%B4%E5%87%A0%E6%9D%A1%E5%86%99%20JavaScript%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E8%8C%83" rel="nofollow">25. 说几条写 JavaScript 的基本规范</a></p> 
<p id="26.%20eval%20%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%3F-toc" style="margin-left:40px;"><a href="#26.%20eval%20%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%3F" rel="nofollow">26. eval 是做什么的?</a></p> 
<p id="27.%20null%20%E5%92%8C%20undefined%20%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#27.%20null%20%E5%92%8C%20undefined%20%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">27. null 和 undefined 的区别</a></p> 
<p id="28.%20%E8%AF%B4%E8%AF%B4%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB%3F-toc" style="margin-left:40px;"><a href="#28.%20%E8%AF%B4%E8%AF%B4%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB%3F" rel="nofollow">28. 说说同步和异步的区别?</a></p> 
<p id="29.%20defer%20%E5%92%8C%20async%20%3F-toc" style="margin-left:40px;"><a href="#29.%20defer%20%E5%92%8C%20async%20%3F" rel="nofollow">29. defer 和 async ?</a></p> 
<p id="30.%20%5B%221%22%2C%20%222%22%2C%20%223%22%5D.map(parseInt)%20%E7%AD%94%E6%A1%88%E6%98%AF%E5%A4%9A%E5%B0%91%3F-toc" style="margin-left:40px;"><a href="#30.%20%5B%221%22%2C%20%222%22%2C%20%223%22%5D.map%28parseInt%29%20%E7%AD%94%E6%A1%88%E6%98%AF%E5%A4%9A%E5%B0%91%3F" rel="nofollow">30. ["1", "2", "3"].map(parseInt) 答案是多少?</a></p> 
<p id="31.%20use%20strict%20%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E4%BD%9C%E7%94%A8%3F-toc" style="margin-left:40px;"><a href="#31.%20use%20strict%20%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E4%BD%9C%E7%94%A8%3F" rel="nofollow">31. use strict 的理解和作用?</a></p> 
<p id="32.%20%E8%AF%B4%E8%AF%B4%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%99%90%E5%88%B6%3F-toc" style="margin-left:40px;"><a href="#32.%20%E8%AF%B4%E8%AF%B4%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%99%90%E5%88%B6%3F" rel="nofollow">32. 说说严格模式的限制?</a></p> 
<p id="33.%20%E8%AF%B4%E8%AF%B4%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%99%90%E5%88%B6%3F-toc" style="margin-left:40px;"><a href="#33.%20%E8%AF%B4%E8%AF%B4%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%99%90%E5%88%B6%3F" rel="nofollow">33. 说说严格模式的限制?</a></p> 
<p id="34.%20%E8%AF%B4%E8%AF%B4%20JSON%20%E7%9A%84%E4%BA%86%E8%A7%A3%3F-toc" style="margin-left:40px;"><a href="#34.%20%E8%AF%B4%E8%AF%B4%20JSON%20%E7%9A%84%E4%BA%86%E8%A7%A3%3F" rel="nofollow">34. 说说 JSON 的了解?</a></p> 
<p id="35.%20%E8%AF%B4%E8%AF%B4%20JS%20%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%3F-toc" style="margin-left:40px;"><a href="#35.%20%E8%AF%B4%E8%AF%B4%20JS%20%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%3F" rel="nofollow">35. 说说 JS 延迟加载的方式有哪些?</a></p> 
<p id="36.%20%E8%AF%B4%E8%AF%B4%20attribute%20%E5%92%8C%20property%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%3F-toc" style="margin-left:40px;"><a href="#36.%20%E8%AF%B4%E8%AF%B4%20attribute%20%E5%92%8C%20property%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%3F" rel="nofollow">36. 说说 attribute 和 property 的区别是什么?</a></p> 
<p id="37.%20%E8%AF%B4%E8%AF%B4%20let%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%3F-toc" style="margin-left:40px;"><a href="#37.%20%E8%AF%B4%E8%AF%B4%20let%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%3F" rel="nofollow">37. 说说 let 的区别是什么?</a></p> 
<p id="38.%20%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%20JS%20%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%3F-toc" style="margin-left:40px;"><a href="#38.%20%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%20JS%20%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%3F" rel="nofollow">38. 如何通过 JS 判断一个数组?</a></p> 
<p id="38.%20%E8%AF%B4%E8%AF%B4%20let%E3%80%81var%20%E3%80%81%20const%20%E7%9A%84%E7%90%86%E8%A7%A3-toc" style="margin-left:40px;"><a href="#38.%20%E8%AF%B4%E8%AF%B4%20let%E3%80%81var%20%E3%80%81%20const%20%E7%9A%84%E7%90%86%E8%A7%A3" rel="nofollow">38. 说说 let、var 、 const 的理解</a></p> 
<p id="39.%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#39.%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">39. 正则表达式的使用</a></p> 
<p id="40.%20Javascript%20%E4%B8%AD%20callee%20%E5%92%8C%20caller%20%E7%9A%84%E4%BD%9C%E7%94%A8-toc" style="margin-left:40px;"><a href="#40.%20Javascript%20%E4%B8%AD%20callee%20%E5%92%8C%20caller%20%E7%9A%84%E4%BD%9C%E7%94%A8" rel="nofollow">40. Javascript 中 callee 和 caller 的作用</a></p> 
<p id="41.%20%E8%AF%B4%E8%AF%B4%20window.onload%20%E5%92%8C%24(document).ready%20%E7%9A%84%E5%8C%BA%E5%88%AB%3F-toc" style="margin-left:40px;"><a href="#41.%20%E8%AF%B4%E8%AF%B4%20window.onload%20%E5%92%8C%24%28document%29.ready%20%E7%9A%84%E5%8C%BA%E5%88%AB%3F" rel="nofollow">41. 说说 window.onload 和$(document).ready 的区别?</a></p> 
<p id="42.%20Javascript%20%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB-toc" style="margin-left:40px;"><a href="#42.%20Javascript%20%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB" rel="nofollow">42. Javascript 数组去重方法汇总</a></p> 
<p id="43.%20%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98-toc" style="margin-left:40px;"><a href="#43.%20%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98" rel="nofollow">43. 浏览器缓存</a></p> 
<p id="44.%20%E9%98%B2%E6%8A%96%2F%E8%8A%82%E6%B5%81%E7%9A%84%E7%90%86%E8%A7%A3-toc" style="margin-left:40px;"><a href="#44.%20%E9%98%B2%E6%8A%96%2F%E8%8A%82%E6%B5%81%E7%9A%84%E7%90%86%E8%A7%A3" rel="nofollow">44. 防抖/节流的理解</a></p> 
<p id="45.%20JavaScript%20%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87-toc" style="margin-left:40px;"><a href="#45.%20JavaScript%20%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87" rel="nofollow">45. JavaScript 变量提升</a></p> 
<p id="46.%20%E5%AE%9E%E7%8E%B0%20Storage%EF%BC%8C%E4%BD%BF%E5%BE%97%E8%AF%A5%E5%AF%B9%E8%B1%A1%E4%B8%BA%E5%8D%95%E4%BE%8B%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><a href="#46.%20%E5%AE%9E%E7%8E%B0%20Storage%EF%BC%8C%E4%BD%BF%E5%BE%97%E8%AF%A5%E5%AF%B9%E8%B1%A1%E4%B8%BA%E5%8D%95%E4%BE%8B%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F" rel="nofollow">46. 实现 Storage，使得该对象为单例，以及使用方式</a></p> 
<p id="47.%20%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%9A%84%E7%90%86%E8%A7%A3-toc" style="margin-left:40px;"><a href="#47.%20%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%9A%84%E7%90%86%E8%A7%A3" rel="nofollow">47. 说说你对事件流的理解</a></p> 
<p id="48.%20%E8%AF%B4%E8%AF%B4%E4%BB%8E%E8%BE%93%E5%85%A5%20URL%20%E5%88%B0%E7%9C%8B%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8F%91%E7%94%9F%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B-toc" style="margin-left:40px;"><a href="#48.%20%E8%AF%B4%E8%AF%B4%E4%BB%8E%E8%BE%93%E5%85%A5%20URL%20%E5%88%B0%E7%9C%8B%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8F%91%E7%94%9F%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B" rel="nofollow">48. 说说从输入 URL 到看到页面发生的全过程</a></p> 
<p id="49.%20%E5%81%9A%E4%B8%80%E4%B8%AA%20Dialog%20%E7%BB%84%E4%BB%B6%EF%BC%8C%E8%AF%B4%E8%AF%B4%E4%BD%A0%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%80%9D%E8%B7%AF%3F%E5%AE%83%E5%BA%94%E8%AF%A5%E6%9C%89%E4%BB%80%E4%B9%88%E5%8A%9F%E8%83%BD%3F-toc" style="margin-left:40px;"><a href="#49.%20%E5%81%9A%E4%B8%80%E4%B8%AA%20Dialog%20%E7%BB%84%E4%BB%B6%EF%BC%8C%E8%AF%B4%E8%AF%B4%E4%BD%A0%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%80%9D%E8%B7%AF%3F%E5%AE%83%E5%BA%94%E8%AF%A5%E6%9C%89%E4%BB%80%E4%B9%88%E5%8A%9F%E8%83%BD%3F" rel="nofollow">49. 做一个 Dialog 组件，说说你设计的思路?它应该有什么功能?</a></p> 
<p id="50.%20%E8%AF%B4%E8%AF%B4%20ajax%E3%80%81fetch%E3%80%81axios%20%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#50.%20%E8%AF%B4%E8%AF%B4%20ajax%E3%80%81fetch%E3%80%81axios%20%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">50. 说说 ajax、fetch、axios 之间的区别</a></p> 
<p id="50.%20%E8%AF%B4%E8%AF%B4%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F-toc" style="margin-left:40px;"><a href="#50.%20%E8%AF%B4%E8%AF%B4%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F" rel="nofollow">50. 说说内存泄漏</a></p> 
<p id="51.%20JavaScript%20%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6-toc" style="margin-left:40px;"><a href="#51.%20JavaScript%20%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6" rel="nofollow">51. JavaScript 自定义事件</a></p> 
<p id="52.%20JavaScript%20%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%3F-toc" style="margin-left:40px;"><a href="#52.%20JavaScript%20%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%3F" rel="nofollow">52. JavaScript 数组排序的几种方式?</a></p> 
<p id="53.%20JavaScript%20%E6%95%B0%E7%BB%84%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%8E%BB%E9%87%8D%E6%96%B9%E6%B3%95%3F-toc" style="margin-left:40px;"><a href="#53.%20JavaScript%20%E6%95%B0%E7%BB%84%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%8E%BB%E9%87%8D%E6%96%B9%E6%B3%95%3F" rel="nofollow">53. JavaScript 数组一行代码去重方法?</a></p> 
<p id="54.%20JavaScript%20%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%B8%BA%E6%95%B0%E7%BB%84%3F-toc" style="margin-left:40px;"><a href="#54.%20JavaScript%20%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%B8%BA%E6%95%B0%E7%BB%84%3F" rel="nofollow">54. JavaScript 如何判断一个对象是否为数组?</a></p> 
<p id="55.%20script%20%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F%3F-toc" style="margin-left:40px;"><a href="#55.%20script%20%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F%3F" rel="nofollow">55. script 引入方式?</a></p> 
<p id="56.%20%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%3F-toc" style="margin-left:40px;"><a href="#56.%20%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%3F" rel="nofollow">56. 变量对象?</a></p> 
<p id="57.%20babel%20%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%3F-toc" style="margin-left:40px;"><a href="#57.%20babel%20%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%3F" rel="nofollow">57. babel 编译原理?</a></p> 
<p id="58.%20%E6%95%B0%E7%BB%84(array)%3F-toc" style="margin-left:40px;"><a href="#58.%20%E6%95%B0%E7%BB%84%28array%29%3F" rel="nofollow">58. 数组(array)?</a></p> 
<p id="59.%20%E8%AF%B4%E5%87%A0%E6%9D%A1%E5%86%99%20JavaScript%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E8%8C%83%3F-toc" style="margin-left:40px;"><a href="#59.%20%E8%AF%B4%E5%87%A0%E6%9D%A1%E5%86%99%20JavaScript%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E8%8C%83%3F" rel="nofollow">59. 说几条写 JavaScript 的基本规范?</a></p> 
<p id="60.%20JavaScript%20%E6%9C%89%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%3F-toc" style="margin-left:40px;"><a href="#60.%20JavaScript%20%E6%9C%89%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%3F" rel="nofollow">60. JavaScript 有几种类型的值?</a></p> 
<p id="61.%20JavaScript%20%E6%9C%89%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%3F-toc" style="margin-left:40px;"><a href="#61.%20JavaScript%20%E6%9C%89%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%3F" rel="nofollow">61. JavaScript 有几种类型的值?</a></p> 
<p id="62.%20JavaScript%20%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%3F-toc" style="margin-left:40px;"><a href="#62.%20JavaScript%20%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%3F" rel="nofollow">62. JavaScript 深浅拷贝?</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3><strong>1. 介绍 JavaScript 的基本数据类型?</strong></h3> 
<ul><li>基本数据类型: Number、String、Boolean、Null、Undefined</li><li>object 是 Javascript 中所有对象的父对象。</li><li>数据封装类对象： object 、 Array 、 Boolean 、 Number 和 String 。</li><li>其他对象： Function 、 Arguments 、 Math 、 Date 、 Error 和 RegExp 。</li><li>其他 数据类型 ： Symbol</li></ul> 
<h3 id="2.%20%E6%B5%85%E8%B0%88%20JavaScript%20%E4%B8%AD%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E7%9A%84%E6%8F%90%E5%8D%87%3F"><strong>2. 浅谈 JavaScript 中变量和函数声明的提升?</strong></h3> 
<ul><li> <p id="%E5%9C%A8%20JavaScript%20%E4%B8%AD%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E%E4%BC%9A%E6%8F%90%E5%8D%87%E5%88%B0%E6%9C%80%E9%A1%B6%E9%83%A8%E6%89%A7%E8%A1%8C">在 JavaScript 中变量和函数的声明会提升到最顶部执行</p> </li><li>函数的提升高于变量的提升。</li><li>函数内部如果用 var 声明了相同名称的外部变量，函数将不再向上寻找。</li><li>匿名函数不会提升。</li><li>不同&lt;script&gt;块中的函数互不影响</li></ul> 
<h3 id="3.%20%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%EF%BC%8C%E9%97%AD%E5%8C%85%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E6%80%A7%EF%BC%9F"><strong>3. 什么是闭包，闭包有什么特性？</strong></h3> 
<ul><li> <p id="%E9%97%AD%E5%8C%85%E5%B0%B1%E6%98%AF%E8%83%BD%E5%A4%9F%E8%AF%BB%E5%8F%96%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%87%BD%E6%95%B0">闭包就是能够读取其他函数内部变量的函数</p> </li><li>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域</li><li>闭包的特性：</li></ul> 
<ol><li>函数内再嵌套函数</li><li>内部函数可以引用外层的参数和变量</li><li>参数和变量不会被垃圾回收机制回收</li></ol> 
<h3 id="4.%20%E8%AF%B4%E8%AF%B4%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E9%97%AD%E5%8C%85%E7%9A%84%E4%BD%9C%E7%94%A8"><strong>4. 说说对闭包的理解和闭包的作用</strong></h3> 
<ul><li>使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在 js 中，函数即闭包，只有函数才会产生作用域的概念</li><li>闭包 的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中</li><li>闭包的另一个用处，是封装对象的私有属性和私有方法</li></ul> 
<ol><li>好处：能够实现封装和缓存等</li><li>坏处：就是消耗内存、不正当使用会造成内存溢出的问题</li><li>使用闭包的注意点</li></ol> 
<ul><li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否</li><li>则会造成网页的性能问题，在 IE 中可能导致内存泄露</li><li>解决方法是，在退出函数之前，将不使用的局部变量全部删除</li></ul> 
<h3 id="5.%20%E8%AF%B4%E8%AF%B4%20This%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3"><strong>5. 说说 This 对象的理解</strong></h3> 
<ul><li>this 总是指向函数的直接调用者（而非间接调用者）</li><li>如果有 new 关键字， this 指向 new 出来的那个对象</li><li>在事件中， this 指向触发这个事件的对象，特殊的是， IE 中的 attachEvent 中的 this 总是</li><li>指向全局对象 Window</li></ul> 
<h3 id="6.%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3W3C%20%E4%B8%AD%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%8F%91%E7%94%9F%E7%BB%8F%E5%8E%86%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5"><strong>6. 事件模型的理解</strong></h3> 
<ul><li>W3C 中定义事件的发生经历三个阶段</li><li>捕获阶段（ capturing ）</li><li>目标阶段（ targetin ）</li><li>冒泡阶段（ bubbling ）</li><li>冒泡型事件：当你使用事件冒泡时，子级元素先触发，父级元素后触发</li><li>捕获型事件：当你使用事件捕获时，父级元素先触发，子级元素后触发</li><li>DOM 事件流：同时支持两种事件模型：捕获型事件和冒泡型事件</li><li>阻止冒泡：在 W3c 中，使用 stopPropagation() 方法；在 IE 下设置 cancelBubble = true</li><li>阻止捕获：阻止事件的默认行为，例如 click - &lt;a&gt; 后的跳转。在 W3c 中，使用</li><li>preventDefault() 方法，在 IE 下设置 window.event.returnValue = false</li></ul> 
<h3 id="7.%20new%20%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%3F"><strong>7. new 操作符具体干了什么?</strong></h3> 
<ul><li> <p id="%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%A9%BA%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%B9%B6%E4%B8%94%20this%20%E5%8F%98%E9%87%8F%E5%BC%95%E7%94%A8%E8%AF%A5%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%90%8C%E6%97%B6%E8%BF%98%E7%BB%A7%E6%89%BF%E4%BA%86%E8%AF%A5%E5%87%BD%E6%95%B0%E7%9A%84%E5%8E%9F%E5%9E%8B">创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型</p> </li><li>属性和方法被加入到 this 引用的对象中</li><li>新创建的对象由 this 所引用，并且最后隐式的返回 this</li></ul> 
<h3 id="8.%20%E8%AF%B4%E8%AF%B4%E6%A0%88%E5%92%8C%E5%A0%86%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB%3F"><strong>8. 说说栈和堆的理解，以及它们的区别?</strong></h3> 
<ul><li>栈内存: 栈内存首先是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for 循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命周期都很短</li><li>堆内存: 存储的是数组和对象（其实数组就是对象），凡是 new 建立的都是在堆中，堆中存放的都是实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也没有消失，还可以用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾，Java 有垃圾回收机制不定时的收取</li><li>栈和堆的区别:</li></ul> 
<ol><li>栈内存存储的是局部变量而堆内存存储的是实体</li><li>栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制</li><li>不定时的回收</li></ol> 
<h3 id="9.%20JS%20%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83"><strong>9. JS 数组和对象的遍历方式，以及几种方式的比较</strong></h3> 
<ul><li>for in 循环</li><li>for 循环</li><li>forEach 循环</li><li>这里的 forEach 回调中两个参数分别为 value ， index</li><li>forEach 无法遍历对象</li><li>IE 不支持该方法； Firefox 和 chrome 支持</li><li>forEach 无法使用 break ， continue 跳出循环，且使用 return 是跳过本次循环</li><li>for-in 需要分析出 array 的每个属性，这个操作性能开销很大。用在 key 已知的数组上是常不划算。所以尽量不要用 for-in ，除非你不清楚要处理哪些属性，例如 JSON 对象这样情况</li><li>for 循环每进行一次，就要检查一下数组长度。读取属性（数组长度）要比读局部变量慢，尤其是当 array 里存放的都是 DOM 元素，因为每次读取都会扫描一遍页面上的选择器相关元素，速度会大大降低</li></ul> 
<h3 id="10.%20map%20%E4%B8%8E%20forEach%20%E7%9A%84%E5%8C%BA%E5%88%AB"><strong>10. map 与 forEach 的区别</strong></h3> 
<ul><li>forEach 方法，是最基本的方法，就是遍历与循环，默认有 3 个传参：分别是遍历的数组内容 item 、数组索引 index 、和当前遍历数组 Array</li><li>map 方法，基本用法与 forEach 一致，但是不同的，它会返回一个新的数组，所以 callback需要有 return 值，如果没有，会返回 undefined</li></ul> 
<h3 id="11.%20%E8%B0%88%E4%B8%80%E8%B0%88%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%3F"><strong>11. 谈一谈箭头函数与普通函数的区别?</strong></h3> 
<ul><li>函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象</li><li>不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误</li><li>不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 Rest 参数代替</li><li>不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数</li></ul> 
<h3 id="12.%20JavaScript%20%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%204%20%E7%A7%8D%E6%96%B9%E6%B3%95"><strong>12. JavaScript 定义类的 4 种方法</strong></h3> 
<ul><li>工厂方法：</li></ul> 
<pre><code class="language-javascript">function creatPerson(name, age) {
    var obj = new Object();
    obj.name = name;
    obj.age = age;
    obj.sayName = function () {
        window.alert(this.name);
    };
    return obj;
}</code></pre> 
<p></p> 
<ul><li>构造函数方法：</li></ul> 
<pre><code class="language-javascript">function Person(name, age) {
    this.name = name;
    this.age = age;
    this.sayName = function () {
        window.alert(this.name);
    };
}</code></pre> 
<p></p> 
<ul><li>原型方法：</li></ul> 
<pre><code class="language-javascript">function Person() { }
Person.prototype = {
    constructor: Person,
    name: "Ning",
    age: "23",
    sayName: function () {
        window.alert(this.name);
    }
};</code></pre> 
<ul><li>组合使用构造函数和原型方法：</li></ul> 
<pre><code class="language-javascript">function Person(name, age) {
    this.name = name;
    this.age = age;
}
Person.prototype = {
    constructor: Person,
    sayName: function () {
        window.alert(this.name);
    }
};</code></pre> 
<h3 id="13.%20JavaScript%20%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%203%20%E7%A7%8D%E6%96%B9%E6%B3%95"><br><strong>13. JavaScript 实现继承的 3 种方法</strong></h3> 
<ul><li>借用构造函数法：</li></ul> 
<pre><code class="language-javascript">function SuperType(name) {
    this.name = name;
    this.sayName = function () {
        window.alert(this.name);
    };
}
function SubType(name, age) {
    SuperType.call(this, name); //在这里借用了父类的构造函数
    this.age = age;
}</code></pre> 
<ul><li>对象冒充：</li></ul> 
<pre><code class="language-javascript">function SuperType(name) {
    this.name = name;
    this.sayName = function () {
        window.alert(this.name);
    };
}
function SubType(name, age) {
    this.supertype = SuperType; //在这里使用了对象冒充
    this.supertype(name);
    this.age = age;
}</code></pre> 
<p></p> 
<ul><li>组合继承</li></ul> 
<pre><code class="language-javascript">function SuperType(name) {
    this.name = name;
}

SuperType.prototype = {
    sayName: function () {
        window.alert(this.name);
    }
};

function SubType(name, age) {
    SuperType.call(this, name); //在这里继承属性
    this.age = age;
}
SubType.prototype = new SuperType(); //这里继承方法</code></pre> 
<h3 id="14.%20%E5%AF%B9%E5%8E%9F%E7%94%9F%20Javascript%20%E4%BA%86%E8%A7%A3%E7%A8%8B%E5%BA%A6"><br><strong>14. 对原生 Javascript 了解程度</strong></h3> 
<ul><li>数据类型、运算、对象、Function、继承、闭包、作用域、原型链、事件、 RegExp 、 JSON 、Ajax 、 DOM 、 BOM 、内存泄漏、跨域、异步装载、模板引擎、前端 MVC 、路由、模块化、Canvas 、 ECMAScript。</li></ul> 
<h3 id="15.%20Js%20%E5%8A%A8%E7%94%BB%E4%B8%8E%20CSS%20%E5%8A%A8%E7%94%BB%E5%8C%BA%E5%88%AB%E5%8F%8A%E7%9B%B8%E5%BA%94%E5%AE%9E%E7%8E%B0"><strong>15. Js 动画与 CSS 动画区别及相应实现</strong></h3> 
<ul><li>CSS3 的动画的优点</li></ul> 
<ol><li>在性能上会稍微好一些，浏览器会对 CSS3 的动画做一些优化</li><li>代码相对简单</li></ol> 
<ul><li>缺点</li></ul> 
<ol><li>在动画控制上不够灵活</li><li>兼容性不好</li><li>JavaScript 的动画正好弥补了这两个缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容 IE6 ，并且功能强大。对于一些复杂控制的动画，使用 javascript 会比较靠谱。而在实现一些小的交互动效的时候，就多考虑考虑 CSS 吧</li></ol> 
<h3 id="16.%20%E8%B0%88%E4%B8%80%E8%B0%88%E4%BD%A0%E7%90%86%E8%A7%A3%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><strong>16. 谈一谈你理解的函数式编程</strong></h3> 
<ul><li>简单说，"函数式编程"是一种"编程范式"（programming paradigm），也就是如何编写程序的方法论</li><li>它具有以下特性：闭包和高阶函数、惰性计算、递归、函数是"第一等公民"、只用"表达式"</li></ul> 
<h3 id="17.%20%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E7%9A%84%E7%90%86%E8%A7%A3"><strong>17. 说说你对作用域链的理解</strong></h3> 
<ul><li>作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到 window 对象即被终止，作用域链向下访问变量是不被允许的</li><li>作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期</li></ul> 
<h3 id="18.%20JavaScript%20%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%20%3F%20%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><strong>18. JavaScript 原型，原型链 ? 有什么特点？</strong></h3> 
<ul><li>每个对象都在其内部初始化一个属性，就是 prototype (原型)，当我们访问一个对象的属性时如果这个对象内部不存在这个属性，那么他就会去 prototype 里找这个属性，这个prototype 又会有自己的 prototype ，于是就这样一直找下去，也就是我们平时所说的原型链的概念</li><li>关系： instance.constructor.prototype = instance.__proto__</li><li>JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。</li><li>当我们修改原型时，与之相关的对象也会继承这一改变</li><li>当我们需要一个属性的时， Javascript 引擎会先看当前对象中是否有这个属性，如果没有的就会查找他的 Prototype 对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象</li></ul> 
<h3 id="19.%20%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%3F"><strong>19. 说说什么是事件代理?</strong></h3> 
<ul><li>事件代理（ Event Delegation ），又称之为事件委托。是 JavaScript 中常用绑定事件的常技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是 DOM 元素的事件冒泡。使用事件代理的好处是可以提高性能。</li><li>可以大量节省内存占用，减少事件注册，比如在 table 上代理所有 td 的 click 事件就非常棒。</li><li>可以实现当新增子对象时无需再次对其绑定。</li></ul> 
<h3 id="20.%20%E8%AF%B4%E8%AF%B4%20ajax%20%E5%8E%9F%E7%90%86%3F"><strong>20. 说说 ajax 原理?</strong></h3> 
<ul><li>Ajax 的原理简单来说是在用户和服务器之间加了—个中间层( AJAX 引擎)，由 XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用 javascrip t 来操作 DOM 而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据。</li><li>Ajax 的过程只涉及 JavaScript 、 XMLHttpRequest 和 DOM 。 XMLHttpRequest 是 ajax 的核心机制。</li><li><strong>Ajax 的优点:</strong></li></ul> 
<ol><li>通过异步模式，提升了用户体验</li><li>优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用</li><li>Ajax 在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载</li><li>Ajax 可以实现动态不刷新（局部刷新）</li></ol> 
<ul><li><strong>Ajax 的缺点:</strong></li></ul> 
<ol><li>安全问题 AJAX 暴露了与服务器交互的细节</li><li>对搜索引擎的支持比较弱</li><li>不容易调试</li></ol> 
<ul><li><strong>Ajax 的请求:</strong></li></ul> 
<pre><code class="language-javascript">/** 创建连接 **/
var xhr = null;
xhr = new XMLHttpRequest()
/** 2. 连接服务器 **/
xhr.open('get', url, true)
/** 3. 发送请求 **/
xhr.send(null);
/** 4. 接受请求 **/
xhr.onreadystatechange = function () {
    if (xhr.readyState == 4) {
        if (xhr.status == 200) {
            success(xhr.responseText);
        } else {
            /** false **/
            fail &amp;&amp; fail(xhr.status);
        }
    }
}</code></pre> 
<h3 id="21.%20%E8%AF%B4%E8%AF%B4%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%3F"><br><strong>21. 说说如何解决跨域问题?</strong></h3> 
<ul><li>首先了解下浏览器的同源策略 同源策略 / SOP （ Same origin policy ） 是一种约定，由Netscape 公司 1995 年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 XSS 、 CSFR 等攻击。所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。</li><li>通过 jsonp 跨域</li><li>document.domain + iframe 跨域</li><li>nginx 代理跨域</li><li>nodejs 中间件代理跨域</li><li>后端在头部信息里面设置安全域名解决跨域</li></ul> 
<h3 id="22.%20%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%20JS%20%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%3F"><strong>22. 异步加载 JS 的方式有哪些?</strong></h3> 
<ol><li>defer，只支持 IE</li><li>async ：</li><li>创建 script ，插入到 DOM 中，加载完毕后 callBack</li><li>/** 异步加载地图 **/</li></ol> 
<pre><code class="language-javascript">/** 异步加载地图 **/
export default function MapLoader() {
    return new Promise((resolve, reject) =&gt; {
        if (window.AMap) {
            resolve(window.AMap)
        } else {
            var script = document.createElement('script')
            script.type = 'text/javascript'
            script.async = true
            script.src = ''
            script.onerror = reject
            document.head.appendChild(script)
        }
        window.initAMap = () =&gt; {
            resolve(window.AMap)
        }
    })
}</code></pre> 
<h3 id="23.%20%E9%82%A3%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%BC%9A%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%3F"><br><strong>23. 那些操作会造成内存泄漏?</strong></h3> 
<ul><li>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在</li><li>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏</li><li>闭包使用不当</li></ul> 
<h3 id="24.%20%E4%BB%8B%E7%BB%8D%20JS%20%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%3F"><strong>24. 介绍 JS 有哪些内置对象?</strong></h3> 
<ol><li>Object 是 JavaScript 中所有对象的父对象</li><li>数据封装类对象 Object 、 Array 、 Boolean 、 Number 和 String</li><li>其他对象： Function 、 Arguments 、 Math 、 Date 、 RegExp 、 Error</li></ol> 
<h3 id="25.%20%E8%AF%B4%E5%87%A0%E6%9D%A1%E5%86%99%20JavaScript%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E8%8C%83"><strong>25. 说几条写 JavaScript 的基本规范</strong></h3> 
<ul><li>不要在同一行声明多个变量</li><li>请使用 ===/!== 来比较 true/false 或者数值</li><li>使用对象字面量替代 new Array 这种形式</li><li>不要使用全局函数</li><li>Switch 语句必须带有 default 分支</li><li>If 语句必须使用大括号</li><li>for-in 循环中的变量 应该使用 var 关键字明确限定作用域，从而避免作用域污</li></ul> 
<h3 id="26.%20eval%20%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%3F"><strong>26. eval 是做什么的?</strong></h3> 
<ul><li>它的功能是把对应的字符串解析成 JS 代码并运行</li><li>应该避免使用 eval ，不安全，非常耗性能（ 2 次，一次解析成 js 语句，一次执行）</li><li>由 JSON 字符串转换为 JSON 对象的时候可以用 eval，var obj =eval('('+ str +')')</li></ul> 
<h3 id="27.%20null%20%E5%92%8C%20undefined%20%E7%9A%84%E5%8C%BA%E5%88%AB"><strong>27. null 和 undefined 的区别</strong></h3> 
<ul><li>undefined 表示不存在这个值。</li><li>undefined 是一个表示"无"的原始值或者说表示"缺少值"，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined</li><li>例如变量被声明了，但没有赋值时，就等于 undefined</li><li>null 表示一个对象被定义了，值为“空值”</li><li>null 是一个对象(空对象, 没有任何属性和方法)</li><li>例如作为函数的参数，表示该函数的参数不是对象；</li><li>在验证 null 时，一定要使用 === ，因为 == 无法分别 null 和 undefined</li></ul> 
<h3 id="28.%20%E8%AF%B4%E8%AF%B4%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB%3F"><strong>28. 说说同步和异步的区别?</strong></h3> 
<ul><li><strong>同步：</strong>浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作</li><li><strong>异步：</strong>浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容</li></ul> 
<h3 id="29.%20defer%20%E5%92%8C%20async%20%3F"><strong>29. defer 和 async ?</strong></h3> 
<ul><li>defer 并行加载 js 文件，会按照页面上 script 标签的顺序执行</li><li>async 并行加载 js 文件，下载完成立即执行，不会按照页面上 script 标签的顺序执行</li></ul> 
<h3 id="30.%20%5B%221%22%2C%20%222%22%2C%20%223%22%5D.map(parseInt)%20%E7%AD%94%E6%A1%88%E6%98%AF%E5%A4%9A%E5%B0%91%3F"><strong>30. ["1", "2", "3"].map(parseInt) 答案是多少?</strong></h3> 
<ul><li>[1, NaN, NaN] 因为 parseInt 需要两个参数 (val, radix) ，其中 radix 表示解时用的基数。</li><li>map 传了 3 个 (element, index, array) ，对应的 radix 不合法导致解析失败。</li></ul> 
<h3 id="31.%20use%20strict%20%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E4%BD%9C%E7%94%A8%3F"><strong>31. use strict 的理解和作用?</strong></h3> 
<ul><li>use strict 是一种 ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,使 JS 编码更加规范化的模式,消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为</li></ul> 
<h3 id="32.%20%E8%AF%B4%E8%AF%B4%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%99%90%E5%88%B6%3F"><strong>32. 说说严格模式的限制?</strong></h3> 
<ul><li>变量必须声明后再使用</li><li>函数的参数不能有同名属性，否则报错</li><li>不能使用 with 语句</li><li>禁止 this 指向全局对象</li></ul> 
<h3 id="33.%20%E8%AF%B4%E8%AF%B4%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%99%90%E5%88%B6%3F"><strong>33. 说说严格模式的限制?</strong></h3> 
<ul><li>新增模板字符串（为 JavaScript 提供了简单的字符串插值功能）</li><li>箭头函数</li><li>for-of （用来遍历数据—例如数组中的值。）</li><li>arguments 对象可被不定参数和默认参数完美代替。</li><li>ES6 将 Promise 对象纳入规范，提供了原生的 Promise 对象。</li><li>增加了 let 和 const 命令，用来声明变量。</li><li>增加了块级作用域。</li><li>let 命令实际上就增加了块级作用域。</li><li>还有就是引入 module 模块的概念</li></ul> 
<h3 id="34.%20%E8%AF%B4%E8%AF%B4%20JSON%20%E7%9A%84%E4%BA%86%E8%A7%A3%3F"><strong>34. 说说 JSON 的了解?</strong></h3> 
<ul><li>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式</li><li>它是基于 JavaScript 的一个子集。数据格式简单, 易于读写, 占用带宽小</li><li>JSON 字符串转换为 JSON 对象:</li></ul> 
<pre><code class="language-javascript">var obj =eval('('+ str +')');
var obj = str.parseJSON();
var obj = JSON.parse(str);
JSON 对象转换为 JSON 字符串：</code></pre> 
<ul><li>JSON 对象转换为 JSON 字符串：</li></ul> 
<pre><code class="language-javascript">var last=obj.toJSONString();
var last=JSON.stringify(obj);</code></pre> 
<h3 id="35.%20%E8%AF%B4%E8%AF%B4%20JS%20%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%3F"><br><strong>35. 说说 JS 延迟加载的方式有哪些?</strong></h3> 
<ul><li> defer 和 async 、动态创建 DOM 方式（用得最多）、按需异步载入 js</li></ul> 
<h3 id="36.%20%E8%AF%B4%E8%AF%B4%20attribute%20%E5%92%8C%20property%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%3F"><strong>36. 说说 attribute 和 property 的区别是什么?</strong></h3> 
<ul><li> attribute 是 dom 元素在文档中作为 html 标签拥有的属性；</li><li>property 就是 dom 元素在 js 中作为对象拥有的属性。</li><li> 对于 html 的标准属性来说， attribute 和 property 是同步的，是会自动更新的</li><li> 但是对于自定义的属性来说，他们是不同步的</li></ul> 
<h3 id="37.%20%E8%AF%B4%E8%AF%B4%20let%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%3F"><strong>37. 说说 let 的区别是什么?</strong></h3> 
<ul><li> let 命令不存在变量提升，如果在 let 前使用，会导致报错</li><li> 如果块区中存在 let 和 const 命令，就会形成封闭作用域</li><li>不允许重复声明，因此，不能在函数内部重新声明参数</li></ul> 
<h3 id="38.%20%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%20JS%20%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%3F"><strong>38. 如何通过 JS 判断一个数组?</strong></h3> 
<ul><li><strong>instanceof 方法:</strong></li><li>instanceof 运算符是用来测试一个对象是否在其原型链原型构造函数的属性</li></ul> 
<pre><code class="language-javascript">var arr = []; js
arr instanceof Array; // true</code></pre> 
<ul><li><strong>constructor 方法:</strong></li><li>constructor 属性返回对创建此对象的数组函数的引用，就是返回对象相对应的构造函数</li></ul> 
<pre><code class="language-javascript">var arr = []; js
arr.constructor == Array; //true</code></pre> 
<ul><li><strong>ES5 新增方法 isArray()</strong></li></ul> 
<pre><code class="language-javascript">var a = new Array(123); js
var b = new Date();
console.log(Array.isArray(a)); //true
console.log(Array.isArray(b)); //false</code></pre> 
<h3 id="38.%20%E8%AF%B4%E8%AF%B4%20let%E3%80%81var%20%E3%80%81%20const%20%E7%9A%84%E7%90%86%E8%A7%A3"><br><strong>38. 说说 let、var 、 const 的理解</strong></h3> 
<p></p> 
<ul><li><strong>let ：</strong></li><li>允许你声明一个作用域被限制在块级中的变量、语句或者表达式</li><li>let 绑定不受变量提升的约束，这意味着 let 声明不会被提升到当前</li><li>该变量处于从块开始到初始化处理的“暂存死区”</li><li><strong>var ：</strong></li><li>声明变量的作用域限制在其声明位置的上下文中，而非声明变量总是全局的</li><li>由于变量声明（以及其他声明）总是在任意代码执行之前处理的，所以在代码中的任意位置声明变量总是等效于在代码开头声明</li><li><strong>const ：</strong></li><li>声明创建一个值的只读引用 (即指针)</li><li>基本数据当值发生改变时，那么其对应的指针也将发生改变，故造成 const 申明基本数据类型时</li><li>再将其值改变时，将会造成报错， 例如 const a = 3 ; a = 5 时 将会报错</li><li>但是如果是复合类型时，如果只改变复合类型的其中某个 Value 项时， 将还是正常使用</li></ul> 
<h3 id="39.%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8"><strong>39. 正则表达式的使用</strong></h3> 
<ul><li>当使用 RegExp() 构造函数的时候，不仅需要转义引号（即 \ ”表示”），并且还需要双反斜杠（即 \\ 表示一个 \ ）。使用正则表达字面量的效率更高</li></ul> 
<h3 id="40.%20Javascript%20%E4%B8%AD%20callee%20%E5%92%8C%20caller%20%E7%9A%84%E4%BD%9C%E7%94%A8"><strong>40. Javascript 中 callee 和 caller 的作用</strong></h3> 
<ul><li>caller 是返回一个对函数的引用，该函数调用了当前函数；</li><li>callee 是返回正在被执行的 function 函数，也就是所指定的 function 对象的正文</li></ul> 
<h3 id="41.%20%E8%AF%B4%E8%AF%B4%20window.onload%20%E5%92%8C%24(document).ready%20%E7%9A%84%E5%8C%BA%E5%88%AB%3F"><strong>41. 说说 window.onload 和$(document).ready 的区别?</strong></h3> 
<ul><li>window.onload() 方法是必须等到页面内包括图片的所有元素加载完毕后才能执行</li><li>$(document).ready() 是 DOM 结构绘制完毕后就执行，不必等到加载完毕</li><li>浏览器的兼容性</li></ul> 
<pre><code class="language-javascript">function ready(fn) {
    if (document.addEventListener) { //标准浏览器
        document.addEventListener('DOMContentLoaded', function () {
            //注销事件, 避免反复触发
            document.removeEventListener('DOMContentLoaded', arguments.callee, fa)
 fn(); //执行函数
        }, false);
    } else if (document.attachEvent) { //IE
        document.attachEvent('onreadystatechange', function () {
            if (document.readyState == 'complete') {
                document.detachEvent('onreadystatechange', arguments.callee);
                fn(); //函数执行
            }
        });
    }
};</code></pre> 
<h3 id="42.%20Javascript%20%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB"><br><strong>42. Javascript 数组去重方法汇总</strong></h3> 
<p></p> 
<ul><li>利用 for 嵌套 for，然后 splice 去重（ES5 中最常用）</li></ul> 
<pre><code class="language-javascript">function unique(arr) {
    for (var i = 0; i &lt; arr.length; i++) {
        for (var j = i + 1; j &lt; arr.length; j++) {
            if (arr[i] == arr[j]) { //第一个等同于第二个，splice 方法删除第二个
                arr.splice(j, 1);
                j--;
            }
        }
    }
    return arr;
}
var arr = [1, 1, 'true', 'true', true, true, 15, false, undefined, undefined, null]
console.log(unique(arr))</code></pre> 
<p></p> 
<ul><li>利用 ES6 Set 去重（ES6 中最常用）</li></ul> 
<pre><code class="language-javascript">function unique(arr) {
    return Array.from(new Set(arr))
}
var arr = [1, 1, 'true', 'true', true, true, 15, undefined, undefined, null]
console.log(unique(arr))</code></pre> 
<p></p> 
<ul><li>利用 indexOf 去重</li></ul> 
<pre><code class="language-javascript">function unique(arr) {
    if (!Array.isArray(arr)) {
        console.log('type error!')
        return
    }
    var array = [];
    for (var i = 0; i &lt; arr.length; i++) {
        if (array.indexOf(arr[i]) === -1) {
            array.push(arr[i])
        }
    }
    return array;
}
var arr = [1, 1, 'true', 'true', true, true, 15, undefined, undefined, null]
console.log(unique(arr))</code></pre> 
<p></p> 
<ul><li>利用 sort()去重</li></ul> 
<pre><code class="language-javascript">function unique(arr) {
    if (!Array.isArray(arr)) {
        console.log('type error!')
        return;
    }
    arr = arr.sort()
    var arrry = [arr[0]];
    for (var i = 1; i &lt; arr.length; i++) {
        if (arr[i] !== arr[i - 1]) {
            arrry.push(arr[i]);
        }
    }
    return arrry;
}
var arr = [1, 1, 'true', 'true', true, true, 15, undefined, undefined, null]
console.log(unique(arr))</code></pre> 
<p></p> 
<ul><li>利用对象的属性不能相同的特点进行去重</li></ul> 
<pre><code class="language-javascript">function unique(arr) {
    if (!Array.isArray(arr)) {
        console.log('type error!')
        return
    }
    var arrry = [];
    var obj = {};
    for (var i = 0; i &lt; arr.length; i++) {
        if (!obj[arr[i]]) {
            arrry.push(arr[i])
            obj[arr[i]] = 1
        } else {
            obj[arr[i]]++
        }
    }
    return arrry;
}
var arr = [1, 1, 'true', 'true', true, true, 15, undefined, undefined, null]
console.log(unique(arr))</code></pre> 
<p></p> 
<ul><li>利用 includes 去重</li></ul> 
<pre><code class="language-javascript">function unique(arr) {
    if (!Array.isArray(arr)) {
        console.log('type error!')
        return
    }
    var array = [];
    for (var i = 0; i &lt; arr.length; i++) {
        if (!array.includes(arr[i])) {//includes 检测数组是否有某个值
            array.push(arr[i]);
        }
    }
    return array
}
var arr = [1, 1, 'true', 'true', true, true, 15, undefined, undefined, null]
console.log(unique(arr))</code></pre> 
<h3 id="43.%20%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98"><br><strong>43. 浏览器缓存</strong></h3> 
<ul><li>览器缓存分为强缓存和协商缓存，当客户端请求某个资源时，获取缓存的流程如下</li><li>先根据这个资源的一些 http header 判断它是否命中强缓存，如果命中，则直接从本地获取</li><li>缓存资源，不会发请求到服务器。</li><li>强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些 request header 验证这个资源是否命中协商缓存，称为 http 再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取源。</li><li>强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源； 区别是，强缓存不对发送请求到服务器，但协商缓存会。</li><li>当协商缓存也没命中时，服务器就会将资源发送回客户端。</li><li>当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存。</li><li>当 f5 刷新网页时，跳过强缓存，但是会检查协商缓存。</li><li>强缓存</li><li>Expires 该字段是 http1.0 时的规范，值为一个绝对时间的 GMT 格式的时间字串，代表缓存资源的过期时间</li><li>Cache-Control:max-age 该字段是 http1.1 的规范，强缓存利用其 max-age 值来判缓存资</li><li>源的最大生命周期，它的值单位为秒</li><li>协商缓存</li><li>Last-Modified 值为资源最后更新时间，随服务器 response 返回</li><li>If-Modified-Since 通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存</li><li>ETag 表示资源内容的唯一标识，随服务器 response 返回</li><li>If-None-Match 服务器通过比较请求头部的 If-None-Match 与当前资源的 ETag 是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存</li></ul> 
<h3 id="44.%20%E9%98%B2%E6%8A%96%2F%E8%8A%82%E6%B5%81%E7%9A%84%E7%90%86%E8%A7%A3"><strong>44. 防抖/节流的理解</strong></h3> 
<p></p> 
<ul><li><strong>防抖: </strong>在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作。可以通过函数防抖动来实现</li><li>开始一个定时器，只要我定时器还在，不管你怎么点击都不会执行回调函数。一旦定时器结束并设置为 null，就可以再次点击了</li><li>对于延时执行函数来说的实现：每次调用防抖动函数都会判断本次调用和之前的时间间隔，如果小于需要的时间间隔，就会重新创建一个定时器，并且定时器的延时为设定时间减去之前的时间间隔。一旦时间到了，就会执行相应的回调函数</li><li>整体函数实现如下:</li></ul> 
<pre><code class="language-javascript">// *使用 underscore 的源码来解释防抖动
// *underscore 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行
// * @param { function} func 回调函数
// * @param { number } wait 表示时间窗口的间隔
// * @param { boolean } immediate 设置为 ture 时，是否立即调用函数
// * @return { function} 返回客户调用函数

_.debounce = function (func, wait, immediate) {
    var timeout, args, context, timestamp, result;
    var later = function () {
        // 现在和上一次时间戳比较
        var last = _.now() - timestamp;
        // 如果当前间隔时间少于设定时间且大于 0 就重新设置定时器
        if (last &lt; wait &amp;&amp; last &gt;= 0) {
            timeout = setTimeout(later, wait - last);
        } else {
            // 否则的话就是时间到了执行回调函数
            timeout = null;
            if (!immediate) {
                result = func.apply(context, args);
                if (!timeout) context = args = null;
            }
        }
    };
    return function () {
        context = this;
        args = arguments;
        // 获得时间戳
        timestamp = _.now();
        // 如果定时器不存在且立即执行函数
        var callNow = immediate &amp;&amp; !timeout;
        // 如果定时器不存在就创建一个
        if (!timeout) timeout = setTimeout(later, wait);
        if (callNow) {
            // 如果需要立即执行函数的话 通过 apply 执行
            result = func.apply(context, args);
            context = args = null;
        }
        return result;
    };
};</code></pre> 
<p></p> 
<ul><li><strong>节流: </strong>防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行</li></ul> 
<pre><code class="language-javascript">/*** underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / wait
 * @param {function} func 回调函数
 * @param {number} wait 表示时间窗口的间隔
 * @param {object} options 如果想忽略开始函数的的调用，传入{leading: false}。
 * 如果想忽略结尾函数的调用，传入{trailing: false}
 * 两者不能共存，否则函数不能执行
 * @return {function} 返回客户调用函数*/

_.throttle = function (func, wait, options) {
    var context, args, result; var timeout = null;
    var previous = 0;
    // 如果 options 没传则设为空对象 if (!options) options = {}; // 定时器回调函数
    var later = function () {
        // 如果设置了 leading，就将 previous 设为 0 // 用于下面函数的第一个 if 判断
        previous = options.leading === false ? 0 : _.now();
        result = func.apply(context, args);
        if (!timeout) context = args = null;
    };
    return function () {
        var now = _.now();
        // 首次进入前者肯定为 true
        // 如果需要第一次不执行函数
        // 就将上次时间戳设为当前的
        // 这样在接下来计算 remaining 的值时会大于 0
        if (!previous &amp;&amp; options.leading === false) previous = now;
        // 计算剩余时间
        var remaining = wait - (now - previous);
        context = this;
        args = arguments;
        // 如果当前调用已经大于上次调用时间 + wait
        // 如果设置了 trailing，只会进入这个条件
        // 如果没有设置 leading，那么第一次会进入这个条件
        // 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了
        // 其实还是会进入的，因为定时器的延时
        // 并不是准确的时间，很可能你设置了 2 秒
        // 但是他需要 2.2 秒才触发，这时候就会进入这个条件
        if (remaining &lt;= 0 || remaining &gt; wait) {
            // 如果存在定时器就清理掉否则会调用二次回调
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            previous = now;
            result = func.apply(context, args);
            if (!timeout) context = args = null;
        } else if (!timeout &amp;&amp; options.trailing !== false) {
            // 判断是否设置了定时器和 trailing
            // 没有的话就开启一个定时器
            // 并且不能不能同时设置 leading 和 trailing
            timeout = setTimeout(later, remaining);
        }
        return result;
    };
};</code></pre> 
<h3 id="45.%20JavaScript%20%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><br><strong>45. JavaScript 变量提升</strong></h3> 
<ul><li>节当执行 JS 代码时，会生成执行环境，只要代码不是写在函数中的，就是在全局执行环境中，函数中的代码会产生函数执行环境，只此两种执行环境。</li><li>因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于大家理解。但是更准确的解释应该是：在生成执行环境时，会有两个阶段。第一个阶段是创建的阶段，JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为 undefined ，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用。</li></ul> 
<h3 id="46.%20%E5%AE%9E%E7%8E%B0%20Storage%EF%BC%8C%E4%BD%BF%E5%BE%97%E8%AF%A5%E5%AF%B9%E8%B1%A1%E4%B8%BA%E5%8D%95%E4%BE%8B%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><strong>46. 实现 Storage，使得该对象为单例，以及使用方式</strong></h3> 
<pre><code class="language-javascript">var instance = null;
class Storage {
    static getInstance() {
        if (!instance) {
            instance = new Storage();
        }
        return instance;
    }
    setItem = (key, value) =&gt; localStorage.setItem(key, value),
    getItem = key =&gt; localStorage.getItem(key)
}</code></pre> 
<h3 id="47.%20%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%9A%84%E7%90%86%E8%A7%A3"><br><strong>47. 说说你对事件流的理解</strong></h3> 
<ul><li>事件流分为两种，捕获事件流和冒泡事件流</li><li>捕获事件流从根节点开始执行，一直往子节点查找执行，直到查找执行到目标节点</li><li>冒泡事件流从目标节点开始执行，一直往父节点冒泡查找执行，直到查到到根节点</li></ul> 
<h3 id="48.%20%E8%AF%B4%E8%AF%B4%E4%BB%8E%E8%BE%93%E5%85%A5%20URL%20%E5%88%B0%E7%9C%8B%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8F%91%E7%94%9F%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B"><strong>48. 说说从输入 URL 到看到页面发生的全过程</strong></h3> 
<ul><li>首先浏览器主进程接管，开了一个下载线程。</li><li>然后进行 HTTP 请求（DNS 查询、IP 寻址等等），中间会有三次捂手，等待响应，开始下载响应报文。</li><li>将下载完的内容转交给 Renderer 进程管理。</li><li>Renderer 进程开始解析 css rule tree 和 dom tree，这两个过程是并行的，所以一般我会把link 标签放在页面顶部。</li><li>解析绘制过程中，当浏览器遇到 link 标签或者 script、img 等标签，浏览器会去下载这些内容，遇到时候缓存的使用缓存，不适用缓存的重新下载资源。</li><li>css rule tree 和 dom tree 生成完了之后，开始合成 render tree，这个时候浏览器会进行layout，开始计算每一个节点的位置，然后进行绘制。</li><li>绘制结束后，关闭 TCP 连接，过程有四次挥手</li></ul> 
<h3 id="49.%20%E5%81%9A%E4%B8%80%E4%B8%AA%20Dialog%20%E7%BB%84%E4%BB%B6%EF%BC%8C%E8%AF%B4%E8%AF%B4%E4%BD%A0%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%80%9D%E8%B7%AF%3F%E5%AE%83%E5%BA%94%E8%AF%A5%E6%9C%89%E4%BB%80%E4%B9%88%E5%8A%9F%E8%83%BD%3F"><strong>49. 做一个 Dialog 组件，说说你设计的思路?它应该有什么功能?</strong></h3> 
<ul><li>该组件需要提供 hook 指定渲染位置，默认渲染在 body 下面。</li><li>然后改组件可以指定外层样式，如宽度等</li><li>组件外层还需要一层 mask 来遮住底层内容，点击 mask 可以执行传进来的 onCancel 函数关闭 Dialog 。</li><li>另外组件是可控的，需要外层传入 visible 表示是否可见。</li><li>然后 Dialog 可能需要自定义头 head 和底部 footer ，默认有头部和底部，底部有一个确认按钮和取消按钮，确认按钮会执行外部传进来的 onOk 事件，然后取消按钮会执行外部传进来的 onCancel 事件。</li><li>当组件的 visible 为 true 时候，设置 body 的 overflow 为 hidden ，隐藏 body 的滚动条，反之显示滚动条。</li><li>组件高度可能大于页面高度，组件内部需要滚动条。</li><li>只有组件的 visible 有变化且为 ture 时候，才重渲染组件内的所有内容</li></ul> 
<h3 id="50.%20%E8%AF%B4%E8%AF%B4%20ajax%E3%80%81fetch%E3%80%81axios%20%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><strong>50. 说说 ajax、fetch、axios 之间的区别</strong></h3> 
<ul><li><strong>Ajax 请求</strong></li><li>本身是针对 MVC 的编程,不符合现在前端 MVVM 的浪潮</li><li>基于原生的 XHR 开发， XHR 本身的架构不清晰，已经有了 fetch 的替代方案</li><li>JQuery 整个项目太大，单纯使用 ajax 却要引入整个 JQuery 非常的不合理（采取个性化打包的方案又不能享受 CDN 服务）</li></ul> 
<pre><code class="language-javascript">$.ajax({
    type: 'POST',
    url: url,
    data: data,
    dataType: dataType,
    success: function () { },
    error: function () { }
});</code></pre> 
<ul><li><strong>fetch 请求</strong></li><li>fetcht 只对网络请求报错，对 400 ， 500 都当做成功的请求，需要封装去处理</li><li>fetch 默认不会带 cookie ，需要添加配置项</li><li>fetch 不支持 abort ，不支持超时控制，使用 setTimeout 及 Promise.reject 的实的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费</li><li>fetch 没有办法原生监测请求的进度，而 XHR 可以</li></ul> 
<pre><code class="language-javascript">try {
    js
    let response = await fetch(url);
    let data = response.json();
    console.log(data);
} catch (e) {
    console.log("Oops, error", e);
}</code></pre> 
<ul><li><strong>axios 请求</strong></li><li>从浏览器中创建 XMLHttpRequest</li><li>从 node.js 发出 http 请求</li><li>支持 Promise API</li><li>拦截请求和响应</li><li>转换请求和响应数据</li><li>取消请求</li><li>自动转换 JSON 数据</li><li>客户端支持防止 CSRF/XSRF</li></ul> 
<pre><code class="language-javascript">axios({
    method: 'post',
    url: '/user/12345',
    data: {
        firstName: 'Fred',
        lastName: 'Flintstone'
    }
}).then(function (response) {
    console.log(response);
}).catch(function (error) {
    console.log(error);
});</code></pre> 
<h3 id="50.%20%E8%AF%B4%E8%AF%B4%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><br><strong>50. 说说内存泄漏</strong></h3> 
<ul><li>定义：程序中己动态分配的堆内存由于某种原因程序未释放或无法释放引发的各种问题。</li><li>Javascript 中可能出现的内存泄漏情况：结果：变慢，崩溃，延迟大等</li><li>Javascript 中可能出现的内存泄漏原因：</li><li>全局变量</li><li>dom 清空时，还存在引用</li><li>ie 中使用闭包</li><li>定时器未清除</li><li>子元素存在引起的内存泄露</li></ul> 
<h3 id="51.%20JavaScript%20%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6"><strong>51. JavaScript 自定义事件</strong></h3> 
<ul><li>document.createEvent()</li><li>event.initEvent()</li><li>element.dispatchEvent()</li></ul> 
<pre><code class="language-javascript">window.onload = function () {
    var demo = document.getElementById("demo");
    demo.addEvent("test", function () { console.log("handler1") });
    demo.addEvent("test", function () { console.log("handler2") });
    demo.onclick = function () {
        this.triggerEvent("test");
    }
}

Element.prototype.addEvent = function (en, fn) {
    this.pools = this.pools || {};
    if (en in this.pools) {
        this.pools[en].push(fn);
    } else {
        this.pools[en] = [];
        this.pools[en].push(fn);
    }
}

Element.prototype.triggerEvent = function (en) {
    if (en in this.pools) {
        var fns = this.pools[en];
        for (var i = 0, il = fns.length; i &lt; il; i++) {
            fns[i]();
        }
    } else { return; }
}
</code></pre> 
<h3 id="52.%20JavaScript%20%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%3F"><br><strong>52. JavaScript 数组排序的几种方式?</strong></h3> 
<ul><li>冒泡排序：每次比较相邻的两个数，如果后一个比前一个小，换位置</li></ul> 
<pre><code class="language-javascript">var arr = [3, 1, 4, 6, 5, 7, 2]; js
function bubbleSort(arr) {
    for (var i = 0; i &lt; arr.length - 1; i++) {
        for (var j = 0; j &lt; arr.length - i - 1; j++) {
            if (arr[j + 1] &lt; arr[j]) {
                var temp;
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
    return arr;
}
console.log(bubbleSort(arr));</code></pre> 
<p></p> 
<ul><li>快速排序：采用二分法，取出中间数，数组每次和中间数比较，小的放到左边，大的放到右边</li></ul> 
<pre><code class="language-javascript">    var arr = [3, 1, 4, 6, 5, 7, 2]; js
function quickSort(arr) {
    if (arr.length == 0) {
        return []; // 返回空数组
    }
    var cIndex = Math.floor(arr.length / 2);
    var c = arr.splice(cIndex, 1);
    var l = [];
    var r = [];
    for (var i = 0; i &lt; arr.length; i++) {
        if (arr[i] &lt; c) {
            l.push(arr[i]);
        } else {
            r.push(arr[i]);
        }
    }
    return quickSort(l).concat(c, quickSort(r));
}
console.log(quickSort(arr));</code></pre> 
<h3 id="53.%20JavaScript%20%E6%95%B0%E7%BB%84%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%8E%BB%E9%87%8D%E6%96%B9%E6%B3%95%3F"><strong>53. JavaScript 数组一行代码去重方法?</strong></h3> 
<ul><li> Set 方法去重:</li></ul> 
<pre><code class="language-javascript">var arr = [1, 2, 3, 4, 2, 1, 23, 543, 3]
Array.prototype.uniq = function () {
    return [...new Set(this)];
}
console.log(arr.uniq())
//  或者 console.log([...new Set(arr)])</code></pre> 
<h3 id="54.%20JavaScript%20%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%B8%BA%E6%95%B0%E7%BB%84%3F"><br><strong>54. JavaScript 如何判断一个对象是否为数组?</strong></h3> 
<pre><code class="language-javascript">function isArray(arg) {
    if (typeof arg === 'object') {
        return Object.prototype.toString.call(arg) === '[object Array]';
    }
    return false;
}</code></pre> 
<h3 id="55.%20script%20%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F%3F"><br><strong>55. script 引入方式?</strong></h3> 
<ul><li>html 静态 &lt;script&gt; 引入</li><li>js 动态插入 &lt;script&gt;</li><li>&lt;script defer&gt; : 异步加载，元素解析完成后执行</li><li>&lt;script async&gt; : 异步加载，但执行时会阻塞元素渲染</li></ul> 
<h3 id="56.%20%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%3F"><strong>56. 变量对象?</strong></h3> 
<ul><li>变量对象，是执行上下文中的一部分，可以抽象为一种 数据作用域，其实也可以理解为就是一个简单的对象，它存储着该执行上下文中的所有 变量和函数声明(不包含函数表达式)。</li><li>活动对象 ( AO ): 当变量对象所处的上下文为 active EC 时，称为活动对象。</li></ul> 
<h3 id="57.%20babel%20%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%3F"><strong>57. babel 编译原理?</strong></h3> 
<ul><li>babylon 将 ES6/ES7 代码解析成 AST</li><li>babel-traverse 对 AST 进行遍历转译，得到新的 AST</li><li>新 AST 通过 babel-generator 转换成 ES5</li></ul> 
<h3 id="58.%20%E6%95%B0%E7%BB%84(array)%3F"><strong>58. 数组(array)?</strong></h3> 
<ul><li>map : 遍历数组，返回回调返回值组成的新数组</li><li>forEach : 无法 break ，可以用 try/catch 中 throw new Error 来停止</li><li>filter : 过滤</li><li>some : 有一项返回 true ，则整体为 true</li><li>every : 有一项返回 false ，则整体为 false</li><li>join : 通过指定连接符生成字符串</li><li>push / pop : 末尾推入和弹出，改变原数组， 返回推入/弹出项</li><li>unshift / shift : 头部推入和弹出，改变原数组，返回操作项</li><li>sort(fn) / reverse : 排序与反转，改变原数组</li><li>concat : 连接数组，不影响原数组， 浅拷贝</li><li>slice(start, end) : 返回截断后的新数组，不改变原数组</li><li>splice(start,number,value...) : 返回删除元素组成的数组， value 为插入项，改变原数组</li><li>indexOf / lastIndexOf(value, fromIndex) : 查找数组项，返回对应的下标</li><li>reduce / reduceRight(fn(prev, cur) ， defaultPrev) : 两两执行， prev 为上次化简函数的return 值， cur 为当前值(从第二项开始)</li></ul> 
<h3 id="59.%20%E8%AF%B4%E5%87%A0%E6%9D%A1%E5%86%99%20JavaScript%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E8%8C%83%3F"><strong>59. 说几条写 JavaScript 的基本规范?</strong></h3> 
<ul><li>不要在同一行声明多个变量</li><li>请使用 ===/!== 来比较 true/false 或者数值</li><li>使用对象字面量替代 new Array 这种形式</li><li>不要使用全局函数</li><li>Switch 语句必须带有 default 分支</li><li>If 语句必须使用大括号</li><li>for-in 循环中的变量 应该使用 var 关键字明确限定作用域，从而避免作用域污</li></ul> 
<h3 id="60.%20JavaScript%20%E6%9C%89%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%3F"><strong>60. JavaScript 有几种类型的值?</strong></h3> 
<ul><li>栈：原始数据类型（ Undefined ， Null ， Boolean ， Number 、 String ）</li><li>堆：引用数据类型（对象、数组和函数）</li><li>两种类型的区别是：存储位置不同；</li><li>原始数据类型直接存储在栈( stack )中的简单数据段，占据空间小、大小固定，属于被频</li><li>繁使用数据，所以放入栈中存储；</li><li>引用数据类型存储在堆( heap )中的对象,占据空间大、大小不固定,如果存储在栈中，将会</li><li>影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地</li><li>址。当解释器寻找引用值时，会首先检索其</li><li>在栈中的地址，取得地址后从堆中获得实体</li></ul> 
<h3 id="61.%20JavaScript%20%E6%9C%89%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%3F"><strong>61. JavaScript 有几种类型的值?</strong></h3> 
<ul><li>addEventListener() 是符合 W3C 规范的标准方法; attachEvent() 是 IE 低版本的非标准方法</li><li>addEventListener() 支持事件冒泡和事件捕获; - 而 attachEvent() 只支持事件冒泡</li><li>addEventListener() 的第一个参数中,事件类型不需要添加 on ; attachEvent() 需要添 'on'</li><li>如果为同一个元素绑定多个事件, addEventListener() 会按照事件绑定的顺序依次执行，ttachEvent() 会按照事件绑定的顺序倒序执行</li></ul> 
<h3 id="62.%20JavaScript%20%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%3F"><strong>62. JavaScript 深浅拷贝?</strong></h3> 
<ul><li><strong>浅拷贝</strong></li><li>Object.assign</li><li>或者展开运算符</li><li><strong>深拷贝</strong></li><li>可以通过 JSON.parse(JSON.stringify(object)) 来解决</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/19d1b7823e36d60320b9a5880fc1c335/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">（三）InfluxDB入门（借助Web UI）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e89c9d37fe5bff37f6f4464351022e84/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Tomcat 的使用（图文教学）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>