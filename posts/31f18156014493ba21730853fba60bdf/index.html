<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vue 前端读取Excel文件并解析 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/31f18156014493ba21730853fba60bdf/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="vue 前端读取Excel文件并解析">
  <meta property="og:description" content="前端读取Excel文件并解析 前端如何解释Excel呢 平时项目中对于Excel的导入解析是很常见的功能，一般都是放在后端执行；但是也有特殊的情况，偶尔也有要求说前端执行解析，判空，校验等，最后组装成后端接口想要的数据结构。
前端如何解释Excel呢 因为我使用插件执行的 you know
安装插件 npm install xlsx@0.14.1 // 0.14.1 是我使用的版本 还有个nanoid npm i nanoid 此处我没有使用安装的这个 而是使用 自定的代码如下：
// index.js const createId = () =&gt; { return ( Number(Math.random().toString().substr(2, 7) &#43; Date.now()).toString(36) &#43; Date.now() ) } export { createId as default, createId } 安装已经完成了 当然 依然 you know import XLSX from &#39;xlsx&#39; import nanoid from &#39;xxxx/xxx/index&#39; 报一丝 差点忘记了 template &lt;el-upload class=&#34;upload&#34; action=&#34;&#34; :auto-upload=&#34;false&#34; :show-file-list=&#34;false&#34; :multiple=&#34;false&#34; :on-change=&#34;(file, fileList) =&gt; importTemp(file, fileList)&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-30T14:27:22+08:00">
    <meta property="article:modified_time" content="2024-04-30T14:27:22+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vue 前端读取Excel文件并解析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>前端读取Excel文件并解析</h4> 
 <ul><li><ul><li><a href="#Excel_4" rel="nofollow">前端如何解释Excel呢</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<p>平时项目中对于Excel的导入解析是很常见的功能，一般都是放在后端执行；但是也有特殊的情况，偶尔也有要求说前端执行解析，判空，校验等，最后组装成后端接口想要的数据结构。</p> 
<h3><a id="Excel_4"></a>前端如何解释Excel呢</h3> 
<p>因为我使用插件执行的 you know</p> 
<ul><li>安装插件</li></ul> 
<pre><code>npm install xlsx@0.14.1   // 0.14.1 是我使用的版本
</code></pre> 
<ul><li>还有个nanoid</li></ul> 
<pre><code>npm i nanoid 
</code></pre> 
<p>此处我没有使用安装的这个 而是使用 自定的代码如下：</p> 
<pre><code>// index.js
const createId =  () =&gt; {
  return (
    Number(Math.random().toString().substr(2, 7) + Date.now()).toString(36) +
    Date.now()
  )
}
export {
  createId as default,
  createId
}
</code></pre> 
<ul><li>安装已经完成了 当然 依然 you know</li></ul> 
<pre><code>import XLSX from 'xlsx'
import nanoid from 'xxxx/xxx/index'
</code></pre> 
<ul><li>报一丝 差点忘记了 template</li></ul> 
<pre><code>&lt;el-upload class="upload" action="" :auto-upload="false" :show-file-list="false" :multiple="false" :on-change="(file, fileList) =&gt; importTemp(file, fileList)"&gt;
          &lt;el-button v-permission="'are you ok'" type="primary" size="small" plain class="flex" &gt;you know the name of the custom button&lt;/el-button&gt;
        &lt;/el-upload&gt;
</code></pre> 
<ul><li>finally</li></ul> 
<pre><code>methods: {
	importTemp(file, fileList) {
      const fileReader = new FileReader()
      fileReader.onload = ev =&gt; {
        try {
          const data = ev.target.result
          const workbook = XLSX.read(data, {
            type: 'binary'
          })
          const sheet = Object.keys(workbook.Sheets)[1] // 我是用的是第二个
          const json = XLSX.utils.sheet_to_json(workbook.Sheets[sheet]) // 
          const worksheet = workbook.Sheets[sheet]
          const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 })
          if (!jsonData.length) return
          const headers = jsonData[0]
          if (!headers.length) return
          const colorParam = headers.find(i =&gt; /xxx/.test(i))
          const transtypeParam = headers.find(i =&gt; /xxx/.test(i))
          const operationTypeParam = headers.find(i =&gt; /xxx/.test(i))
          const systemCodeParam = headers.find(i =&gt; /xxx/.test(i))
          const platCodeParam = headers.find(i =&gt; /xxx/.test(i))
          const truckingBillNoParam = headers.find(i =&gt; /xxx/.test(i))
          const delivyPlanTypeParam = headers.find(i =&gt; /xxx/.test(i))
          const targetObj = {}
          const nameMap = { // 定义必填的字段
            systemCode: systemCodeParam,
            platCode: platCodeParam,
            operationType: operationTypeParam,
            truckingBillNo: truckingBillNoParam,
            transType: transtypeParam,
            vehicleNumber: '车牌号',
            carColor: colorParam,
            driverName: '司机姓名',
            idcard: '司机身份证号',
            driverPhone: '司机手机号',
            clientCompanyCode: 'xxx',
            clientCompanyName: 'xxx名称',
            // messageBatchNo: 'xxx批次号',
            // detailsCounts: '明细条数',
            billId: 'xxx',
            billDependId: 'xxx',
            factoryBillId: 'xxx',
            delivyPlanType: delivyPlanTypeParam
          }
          for (let [idx, el] of json.entries()) {
            let tempObj = {
            }
            for (const key of Object.keys(nameMap)) {
              const value = el[nameMap[key]]
              if (!value &amp;&amp; value !== 0) {
                this.$message.warning(`第${idx + 2}行，字段: ${nameMap[key]} 为必填值`)
                return
              }
              tempObj[key] = value
            }
            tempObj = {
              ...tempObj,
              queueId: el['车辆排队号']
            }
            if (targetObj[tempObj.truckingBillNo]) {
              targetObj[tempObj.truckingBillNo].push(tempObj)
            } else {
              targetObj[tempObj.truckingBillNo] = [tempObj]
            }
          }
          const targetList = Object.keys(targetObj).map((key, i) =&gt; {
            const mainitem = targetObj[key][0]
            const target = {}
            Object.keys(mainitem).map(key =&gt; {
              if (!['qqq', 'xxxx', 'ssss', 'wwww'].includes(key)) {
                const val = (mainitem[key] + '').replace(/\s/gi, '')
                target[key] = ['null', 'undefined'].includes(val) ? '' : val // 判空下
              }
            })
            target.details = targetObj[key].map(item =&gt; {
              return {
                billId: item.qqq,
                billDependId: item.xxxx,
                factoryBillId: item.ssss,
                delivyPlanType: item.wwww
              }
            })
            target.detailsCounts = target.details.length
            target.messageBatchNo = nanoid() + i
            return target
          })

          // 后台请求接口
          import({ // 你自己的哦
            importDataList: targetList
          }).then(res =&gt; {
            const { msg, status } = res
            if (status) {
              this.$message.success('发送成功')
            } else {
              this.$message.error(msg ?? '操作失败')
            }
          })
        } catch (e) {
          console.log(e, 'error')
        }
      }
      fileReader.readAsBinaryString(file.raw)
    }
}
</code></pre> 
<ul><li>catch<br> <img src="https://images2.imgbox.com/06/7d/rn9eZTnu_o.png" alt="我的附件类型"><br> 双人行也有我师焉：<a href="https://blog.csdn.net/han_start/article/details/120008045">哎呦不错哦</a></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a4f93dfccaaa89767ad8475a6f070117/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">IIS上部署Asp.net core Webapi</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9c7df4bfa3b3e2934518b06af7c6f80f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">深入Rust标准库：必备的Rust语言高级指南</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>