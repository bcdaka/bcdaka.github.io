<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>花几千上万学习Java，真没必要！（三十五） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/1e49e2cd8876cf6669642ce1546097da/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="花几千上万学习Java，真没必要！（三十五）">
  <meta property="og:description" content="1、Map：
Map接口的基本且常用的操作，用于管理键值对集合。
V put(K key, V value)
作用：向映射中添加一个键值对。
参数：K key 是键的类型，V value 是与键关联的值。
返回值：如果映射以前包含该键的映射关系，则返回旧值（即替换前的值）。如果映射不包含该键的映射关系，则返回null。
键是唯一的，如果尝试添加一个已经存在的键，则旧值将被新值替换。
V remove(Object key)
作用：从映射中移除与指定键相关联的键值对。
参数：Object key 是要移除的键。
返回值：如果映射包含该键的映射关系，则返回与该键相关联的值；如果不包含，则返回null。
void clear()
作用：从映射中移除所有键值对。
参数：无。
返回值：无。
调用此方法后，映射将为空。
boolean containsKey(Object key)
作用：判断映射中是否包含指定的键。
参数：Object key 是要检查的键。
返回值：如果映射包含该键的映射关系，则返回true；否则返回false。
boolean containsValue(Object value)
作用：判断映射中是否包含指定的值。
参数：Object value 是要检查的值。
返回值：如果映射包含至少一个键值对，其值等于value，则返回true；否则返回false。
此方法可能需要遍历映射中的所有键值对以查找值，因此效率较低。
boolean isEmpty()
作用：判断映射是否为空。
参数：无。
返回值：如果映射不包含任何键值对，则返回true；否则返回false。
int size()
作用：返回映射中键值对的数量。
参数：无。
返回值：映射中键值对的数量。
遍历方式1：
遍历方式2： 测试代码1： package maptest.com; import java.util.HashMap; import java.util.Map; //put(K key, V value)：将指定的值与此映射中的指定键关联（可选操作）。如果此映射以前包含该键的映射，则替换旧值（和键关联的旧值，如果有的话）。 //get(Object key)：返回指定键所映射的值；如果此映射不包含该键的映射，则返回null。 //remove(Object key)：如果存在一个键的映射，则将其从此映射中移除（可选操作）。 //containsKey(Object key)：如果此映射包含指定键的映射，则返回true。 //containsValue(Object value)：如果此映射将一个或多个键映射到指定值，则返回true。 public class HashMapDemo { public static void main(String[] args) { // 创建HashMap实例 Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); // 使用put方法添加键值对 map.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-30T20:50:32+08:00">
    <meta property="article:modified_time" content="2024-07-30T20:50:32+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">花几千上万学习Java，真没必要！（三十五）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1、Map：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/07/fe/NBCqnIwr_o.png"></p> 
<p> </p> 
<p>Map接口的基本且常用的操作，用于管理键值对集合。</p> 
<p>V put(K key, V value)<br> 作用：向映射中添加一个键值对。<br> 参数：K key 是键的类型，V value 是与键关联的值。<br> 返回值：如果映射以前包含该键的映射关系，则返回旧值（即替换前的值）。如果映射不包含该键的映射关系，则返回null。<br> 键是唯一的，如果尝试添加一个已经存在的键，则旧值将被新值替换。<br> V remove(Object key)<br> 作用：从映射中移除与指定键相关联的键值对。<br> 参数：Object key 是要移除的键。<br> 返回值：如果映射包含该键的映射关系，则返回与该键相关联的值；如果不包含，则返回null。<br> void clear()<br> 作用：从映射中移除所有键值对。<br> 参数：无。<br> 返回值：无。<br> 调用此方法后，映射将为空。<br> boolean containsKey(Object key)<br> 作用：判断映射中是否包含指定的键。<br> 参数：Object key 是要检查的键。<br> 返回值：如果映射包含该键的映射关系，则返回true；否则返回false。<br> boolean containsValue(Object value)<br> 作用：判断映射中是否包含指定的值。<br> 参数：Object value 是要检查的值。<br> 返回值：如果映射包含至少一个键值对，其值等于value，则返回true；否则返回false。<br> 此方法可能需要遍历映射中的所有键值对以查找值，因此效率较低。<br> boolean isEmpty()<br> 作用：判断映射是否为空。<br> 参数：无。<br> 返回值：如果映射不包含任何键值对，则返回true；否则返回false。<br> int size()<br> 作用：返回映射中键值对的数量。<br> 参数：无。<br> 返回值：映射中键值对的数量。</p> 
<p>遍历方式1：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ca/93/q75utk60_o.png"></p> 
<p>遍历方式2： </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/90/6f/UYIUlACv_o.png"> </p> 
<p>测试代码1： </p> 
<pre><code class="language-java">package maptest.com;
import java.util.HashMap;  
import java.util.Map;  
//put(K key, V value)：将指定的值与此映射中的指定键关联（可选操作）。如果此映射以前包含该键的映射，则替换旧值（和键关联的旧值，如果有的话）。
//get(Object key)：返回指定键所映射的值；如果此映射不包含该键的映射，则返回null。
//remove(Object key)：如果存在一个键的映射，则将其从此映射中移除（可选操作）。
//containsKey(Object key)：如果此映射包含指定键的映射，则返回true。
//containsValue(Object value)：如果此映射将一个或多个键映射到指定值，则返回true。   
public class HashMapDemo {  
    public static void main(String[] args) {  
        // 创建HashMap实例  
        Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();  
  
        // 使用put方法添加键值对  
        map.put("Apple", 100);  
        map.put("Banana", 200);  
        map.put("Cherry", 150);  
        map.put("Date", 120);  
        map.put("Elderberry", 180);  
        map.put("Fig", 90); 
        // containsKey方法检查键是否存在  
        System.out.println("Contains Key 'Apple': " + map.containsKey("Apple"));  
  
        // containsValue方法检查值是否存在  
        System.out.println("Contains Value 150: " + map.containsValue(150));  
  
        // isEmpty方法检查Map是否为空  
        System.out.println("Is Map empty? " + map.isEmpty());  
  
        // size方法获取Map的大小  
        System.out.println("Size of Map: " + map.size());  
  
        // remove方法移除键值对  
        Integer removedValue = map.remove("Banana");  
        System.out.println("Removed Value for 'Banana': " + removedValue);  
  
        // 再次检查Map的大小  
        System.out.println("Size of Map after removed: " + map.size());  
  
        // 清空Map  
        map.clear();  
  
        // 再次检查Map是否为空  
        System.out.println("Is Map empty after clear? " + map.isEmpty());  
  
        // 访问一个已被移除的键  
        System.out.println("Value for 'Banana' after clear: " + map.get("Banana")); // 返回null  
    }  
}</code></pre> 
<p>运行结果如下：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d0/8b/anaVj2Kw_o.png"> </p> 
<p>测试代码2：</p> 
<pre><code class="language-java">package maptest.com;
import java.util.HashMap;  
import java.util.Map;
import java.util.Objects;  
//equals()方法，使用Objects.equals()比较name和color，以确保null值也能被正确处理。
//hashCode()方法，使用Objects.hash()生成基于name和color的哈希码。
//确保当两个Cloth对象相等时，它们的哈希码也相同。
//添加与已存在键（基于equals()方法）相同的键时，HashMap会覆盖该键对应的值。
//添加一个与第一个Cloth对象（T-Shirt, White）相同的对象，并改变其价格。
//由于重写了equals()和hashCode()方法，HashMap认为这两个对象是相同的，因此更新价格。
//实际上每次都在创建新的Cloth对象实例。
//实际应用中应该重用相同的对象实例避免不必要的对象创建和内存占用。
class Cloth {  
    private String name;  
    private String color;  
  
    public Cloth(String name, String color) {  
        this.name = name;  
        this.color = color;  
    }    
  
    @Override  
    public boolean equals(Object o) {  
        if (this == o) return true;  
        if (o == null || getClass() != o.getClass()) return false;  
        Cloth cloth = (Cloth) o;  
        return Objects.equals(name, cloth.name) &amp;&amp;  
               Objects.equals(color, cloth.color);  
    }  
  
    @Override  
    public int hashCode() {  
        return Objects.hash(name, color);  
    }  
  
    @Override  
    public String toString() {  
        return "Cloth{" +  
               "name='" + name + '\'' +  
               ", color='" + color + '\'' +  
               '}';  
    }  
}  
  
public class TestMap {  
    public static void main(String[] args) {  
        Map&lt;Cloth, Double&gt; clothesMap = new HashMap&lt;&gt;();  
  
        // 添加元素  
        clothesMap.put(new Cloth("T-Shirt", "White"), 10.0);  
        clothesMap.put(new Cloth("Jeans", "Blue"), 20.0);  
  
        // 添加与第一个对象相同的衣服（基于name和color），会覆盖第一个对象的价格  
        clothesMap.put(new Cloth("T-Shirt", "White"), 15.0); // 创建一个新的Cloth对象，但基于equals和hashCode方法，被视为与第一个相同。 
  
        // 遍历HashMap  
        for (Map.Entry&lt;Cloth, Double&gt; entry : clothesMap.entrySet()) {  
            System.out.println(entry.getKey() + ": $" + entry.getValue());  
        }  
    }  
}</code></pre> 
<p>运行结果如下：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/83/cb/FFALPg2m_o.png"> </p> 
<p>测试代码3：</p> 
<pre><code class="language-java">package maptest.com;
import java.util.HashMap;  
import java.util.Map;  
// 珠宝首饰类  
class Jewelry {  
    private String name; // 珠宝名称  
    private double price; // 珠宝价格  
  
    public Jewelry(String name, double price) {  
        this.name = name;  
        this.price = price;  
    }  

    public void setName(String name) {
		this.name = name;
	}

	public void setPrice(double price) {
		this.price = price;
	}

	public String getName() {  
        return name;  
    }  
  
    public double getPrice() {  
        return price;  
    }  
  
    @Override  
    public String toString() {  
        return "Jewelry{" +  
               "name='" + name + '\'' +  
               ", price=" + price +  
               '}';  
    }  
}  
  
public class JewelryMapDemo {  
    public static void main(String[] args) {  
        // 使用HashMap存储Jewelry对象，使用String作为key（实际可使用更复杂的唯一标识符）  
        Map&lt;String, Jewelry&gt; jewelryMap = new HashMap&lt;&gt;();  
        jewelryMap.put("Diamond Ring", new Jewelry("Diamond Ring", 5000.0));  
        jewelryMap.put("Gold Necklace", new Jewelry("Gold Necklace", 2000.0));  
        jewelryMap.put("Silver Bracelet", new Jewelry("Silver Bracelet", 300.0));  
        jewelryMap.put("Bracelet", new Jewelry("SilvBracelet", 300.0)); 
        // 1. entrySet()遍历  
        System.out.println("Using entrySet():");  
        for (Map.Entry&lt;String, Jewelry&gt; entry : jewelryMap.entrySet()) {  
            System.out.println(entry.getKey() + ": " + entry.getValue());  
        }  
  
        // 2. keySet()遍历  
        System.out.println("\nUsing keySet():");  
        for (String key : jewelryMap.keySet()) {  
            Jewelry jewelry = jewelryMap.get(key);  
            System.out.println(key + ": " + jewelry);  
        }  
  
        // 3. values()遍历  
        System.out.println("\nUsing values():");  
        for (Jewelry jewelry : jewelryMap.values()) {  
            System.out.println(jewelry);  
        }  
  
        // 4. forEach()方法  
        System.out.println("\nUsing forEach():");  
        jewelryMap.forEach((key, value) -&gt; System.out.println(key + ": " + value));  
  
        // 5. entrySet().stream()  
        System.out.println("\nUsing entrySet().stream():");  
        jewelryMap.entrySet().stream()  
                .forEach(entry -&gt; System.out.println(entry.getKey() + ": " + entry.getValue()));  
    }  
}</code></pre> 
<p>运行结果如下：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/5e/79/bBzsvlU8_o.png"></p> 
<p>测试代码4：</p> 
<pre><code class="language-java">package maptest.com;
import java.util.HashMap;  
import java.util.Map;  
import java.util.Set;  
import java.util.Collection;  
  
public class MapWithFlowersExample {  
    public static void main(String[] args) {  
        // 创建HashMap实例，花名作为键，受欢迎程度整数作为值  
        Map&lt;String, Integer&gt; flowerMap = new HashMap&lt;&gt;();  
        flowerMap.put("Rose", 10);  
        flowerMap.put("Tulip", 20);  
        flowerMap.put("Lily", 15);  
        flowerMap.put("Chrysanthemum", 5);  
        flowerMap.put("Sunflower", 30);  
  
        // get方法根据键获取值  
        Integer value = flowerMap.get("Tulip");  
        System.out.println("Value for 'Tulip': " + value);  
  
        // keySet方法获取所有键的集合  
        Set&lt;String&gt; keys = flowerMap.keySet();  
        System.out.println("Keys: " + keys);  
  
        // values方法获取所有值的集合  
        Collection&lt;Integer&gt; values = flowerMap.values();  
        System.out.println("Values: " + values);  
  
        // entrySet方法获取所有键值对对象的集合  
        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = flowerMap.entrySet();  
        for (Map.Entry&lt;String, Integer&gt; entry : entries) {  
            System.out.println("Key = " + entry.getKey() + ", Value = " + entry.getValue());  
        }  
  
        // 查找并打印最受欢迎的花（值最大的那个）  
        String mostPopularFlower = null;  
        int maxValue = Integer.MIN_VALUE;  
        for (Map.Entry&lt;String, Integer&gt; entry : entries) {  
            if (entry.getValue() &gt; maxValue) {  
                maxValue = entry.getValue();  
                mostPopularFlower = entry.getKey();  
            }  
        }  
        System.out.println("Most popular flower: " + mostPopularFlower + " with value " + maxValue);  
    }  
}</code></pre> 
<p>运行结果如下：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/0c/ff/8vhngbU8_o.png"> </p> 
<p>2、 LinkedHashMap：</p> 
<pre><code class="language-java">package maptest.com;
import java.util.LinkedHashMap;  
import java.util.Map;  
  
public class LinkedHashMapBagExample {  
    public static void main(String[] args) {  
        // 创建一个 LinkedHashMap 实例，用于存储女士包包。 
        Map&lt;String, String&gt; bags = new LinkedHashMap&lt;&gt;();  
  
        // 向 LinkedHashMap 添加包包  
        bags.put("Clutch Bag", "A small, elegant bag for formal events.");  
        bags.put("Tote Bag", "A large, casual bag with two handles.");  
        bags.put("Shoulder Bag", "A medium-sized bag with a shoulder strap.");  
  
        // 遍历 LinkedHashMap，并打印每个包包及其描述  
        System.out.println("Bags (insertion order):");  
        for (Map.Entry&lt;String, String&gt; entry : bags.entrySet()) {  
            System.out.println(entry.getKey() + ": " + entry.getValue());  
        }  
  
        // 创建一个带有LRU缓存特性的LinkedHashMap  
        // 设置accessOrder为true，并通过重写removeEldestEntry限制大小  
        Map&lt;String, String&gt; lruBags = new LinkedHashMap&lt;String, String&gt;(16, 0.75f, true) {  
            protected boolean removeEldestEntry(Map.Entry&lt;String, String&gt; eldest) {  
                return size() &gt; 3; // 只保留最近的3个包包  
            }  
        };  
  
        // 向 LRU 缓存中添加包包  
        lruBags.put("Backpack", "A versatile bag with straps over both shoulders.");  
        lruBags.put("Satchel Bag", "A structured, often leather, bag with a handle.");  
        lruBags.put("Crossbody Bag", "A small bag worn across the body with a single strap.");  
        lruBags.put("Hobo Bag", "A large, slouchy bag with a long shoulder strap."); // 这将触发removeEldestEntry  
  
        // 遍历 LRU 缓存中的包包  
        System.out.println("\nLRU Bags (access order with LRU cache):");  
        for (Map.Entry&lt;String, String&gt; entry : lruBags.entrySet()) {  
            System.out.println(entry.getKey() + ": " + entry.getValue());  
        }  
  
        // 访问一个包包，以改变其访问顺序  
        lruBags.get("Satchel Bag");  
  
        // 添加一个新的包包。 
        lruBags.put("Messenger Bag", "A bag with a long strap worn across the body.");  
  
        // 再次遍历 LRU 缓存中的包包，查看变化  
        System.out.println("\nLRU Bags after access and insertion:");  
        for (Map.Entry&lt;String, String&gt; entry : lruBags.entrySet()) {  
            System.out.println(entry.getKey() + ": " + entry.getValue());  
        }  
    }  
}</code></pre> 
<p>运行结果如下;</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/0c/5b/nlD1c57T_o.png"> </p> 
<p> </p> 
<p>3、集合嵌套之ArrayList嵌套HashMap：</p> 
<p>测试代码：</p> 
<pre><code class="language-java">package maptest.com;
import java.util.ArrayList;  
import java.util.HashMap;  
import java.util.List;  
import java.util.Map;  
  
public class NestedHashMapExample {  
    public static void main(String[] args) {  
        // 创建ArrayList存储HashMap  
        List&lt;Map&lt;String, String&gt;&gt; list = new ArrayList&lt;&gt;();  
  
        // 创建第一个HashMap并添加到列表中  
        Map&lt;String, String&gt; map1 = new HashMap&lt;&gt;();  
        map1.put("key1", "value1");  
        map1.put("key2", "value2");  
        list.add(map1);  
  
        // 创建第二个HashMap并添加到列表中  
        Map&lt;String, String&gt; map2 = new HashMap&lt;&gt;();  
        map2.put("keyA", "valueA");  
        map2.put("keyB", "valueB");  
        list.add(map2);  
  
        // 外层循环遍历ArrayList，并打印每个HashMap的内容  
        for (Map&lt;String, String&gt; map : list) {  
            System.out.println("HashMap:");  
            //内层循环遍历每个HashMap中的每个键值对，并打印出来。
            for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) {  
                System.out.println("  " + entry.getKey() + ": " + entry.getValue());  
            }  
        }  
    }  
}</code></pre> 
<p> 运行结果如下：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ed/81/9Nsmvvqv_o.png"></p> 
<p>4、集合嵌套之HashMap嵌套ArrayList：</p> 
<p>测试代码：</p> 
<pre><code class="language-java">package maptest.com;
import java.util.ArrayList;  
import java.util.HashMap;  

public class NestedArrayListExample {
    public static void main(String[] args) {
        HashMap&lt;String, ArrayList&lt;String&gt;&gt; nestedMap = new HashMap&lt;&gt;();

        ArrayList&lt;String&gt; list1 = new ArrayList&lt;&gt;();
        list1.add("Value1 - List1");
        list1.add("Value2 - List1");

        ArrayList&lt;String&gt; list2 = new ArrayList&lt;&gt;();
        list2.add("Value1 - List2");
        list2.add("Value2 - List2");

        nestedMap.put("Key1", list1);
        nestedMap.put("Key2", list2);

        //增强for循环遍历nestedMap中所有的键，nestedMap.keySet()返回键的集合。
        for (String key : nestedMap.keySet()) {
        	//打印遍历到的键。
            System.out.println("Key: " + key);
            //通过当前key从nestedMap中获取对应的值，即一个ArrayList。
            ArrayList&lt;String&gt; list = nestedMap.get(key);
            //遍历当前键对应的ArrayList中的所有值。
            for (String value : list) {
            	//打印遍历到的值。
                System.out.println("Value: " + value);
            }
        }
    }
}</code></pre> 
<p>运行结果如下：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ab/ce/zouO1A3N_o.png"> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/69d09b1a88f6b94541773e9fff62b6a4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【排序算法（二）】——冒泡排序、快速排序和归并排序—＞深层解析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5563d39d75c00d41654ae88640831188/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Mooncake：LLM服务的KVCache为中心分解架构</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>