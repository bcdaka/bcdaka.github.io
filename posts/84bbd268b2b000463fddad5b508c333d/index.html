<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【JAVA】异常 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/84bbd268b2b000463fddad5b508c333d/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【JAVA】异常">
  <meta property="og:description" content="作者主页：paper jie 的博客
本文作者：大家好，我是paper jie，感谢你阅读本文，欢迎一建三连哦。
本文录入于《JAVASE语法系列》专栏，本专栏是针对于大学生，编程小白精心打造的。笔者用重金(时间和精力)打造，将javaSE基础知识一网打尽，希望可以帮到读者们哦。
其他专栏：《JAVA》《算法详解》《C语言》等
目录
什么是异常
异常的体系结构
异常的分类
编译时异常
运行时异常
异常的处理
防御式编程
异常的抛出
异常的捕获
异常声明 throws
try - catch捕获并异常
finally
异常的处理流程
自定义类
什么是异常 在java中，将程序执行过程中发生不正常行为称为异常。比如我们写代码经常遇到的：
算数异常
int a = 10 / 0; 数组越界异常
int[] arr = {1,2,3,4,5}; System.out.println(arr[10]); 空指针异常
int[] arr = null; System.out.println(arr.length); 我们可以发现，java中不同的类型的异常有对应的类来描述。
异常的体系结构 异常种类有很多种，为了对这些异常可以比较好的管理起来，Java内部维护了一个异常的体系结构：
Throwable：异常体系的顶层，还有派生出的两个类，Error和Execption
Error：是java虚拟机JVM无法解决的严重问题，比如：JVM中的内部错误，资源耗尽等。典型代表：StackOverflowErrow和OutofMemoryError，一但发生了程序就会崩溃，没有办法解决。
Execption：异常产生后程序员可以通过代码进行处理，让程序继续运行。
异常的分类 异常可以在编译期间发生，也可以在运行时发生，根据发生的不同时机，可以分为：
编译时异常 在程序编译期间发生的异常，称为编译时异常，也可以叫受查异常
class person { String name; int age; @Override protected Object clone() { return super.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-09-14T10:43:08+08:00">
    <meta property="article:modified_time" content="2023-09-14T10:43:08+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【JAVA】异常</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><strong><span style="color:#4da8ee;">作者主页：<a href="https://blog.csdn.net/paperjie?spm=1011.2124.3001.5343" title="paper jie 的博客">paper jie 的博客</a></span></strong></p> 
 <p><span style="color:#4da8ee;"><strong>本文作者：大家好，我是paper jie，感谢你阅读本文，欢迎一建三连哦。</strong></span></p> 
 <p><span style="color:#4da8ee;"><strong>本文录入于《JAVASE语法系列》专栏，本专栏是针对于大学生，编程小白精心打造的。笔者用重金(时间和精力)打造，将javaSE基础知识一网打尽，希望可以帮到读者们哦。</strong></span></p> 
 <p><span style="color:#4da8ee;"><strong>其他专栏：《JAVA》《算法详解》《C语言》等</strong></span></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%82%E5%B8%B8-toc" style="margin-left:0px;"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%82%E5%B8%B8" rel="nofollow">什么是异常</a></p> 
<p id="%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-toc" style="margin-left:0px;"><a href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84" rel="nofollow">异常的体系结构</a></p> 
<p id="%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB-toc" style="margin-left:0px;"><a href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB" rel="nofollow">异常的分类</a></p> 
<p id="%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8-toc" style="margin-left:40px;"><a href="#%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8" rel="nofollow">编译时异常</a></p> 
<p id="%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8-toc" style="margin-left:40px;"><a href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8" rel="nofollow">运行时异常</a></p> 
<p id="%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86-toc" style="margin-left:0px;"><a href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86" rel="nofollow">异常的处理</a></p> 
<p id="%E9%98%B2%E5%BE%A1%E5%BC%8F%E7%BC%96%E7%A8%8B-toc" style="margin-left:40px;"><a href="#%E9%98%B2%E5%BE%A1%E5%BC%8F%E7%BC%96%E7%A8%8B" rel="nofollow">防御式编程</a></p> 
<p id="%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8A%9B%E5%87%BA-toc" style="margin-left:40px;"><a href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8A%9B%E5%87%BA" rel="nofollow">异常的抛出</a></p> 
<p id="%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8D%95%E8%8E%B7-toc" style="margin-left:40px;"><a href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8D%95%E8%8E%B7" rel="nofollow">异常的捕获</a></p> 
<p id="%E5%BC%82%E5%B8%B8%E5%A3%B0%E6%98%8E%20throws-toc" style="margin-left:80px;"><a href="#%E5%BC%82%E5%B8%B8%E5%A3%B0%E6%98%8E%20throws" rel="nofollow">异常声明 throws</a></p> 
<p id="try%20-%20catch%E6%8D%95%E8%8E%B7%E5%B9%B6%E5%BC%82%E5%B8%B8-toc" style="margin-left:80px;"><a href="#try%20-%20catch%E6%8D%95%E8%8E%B7%E5%B9%B6%E5%BC%82%E5%B8%B8" rel="nofollow">try - catch捕获并异常</a></p> 
<p id="finally-toc" style="margin-left:80px;"><a href="#finally" rel="nofollow">finally</a></p> 
<p id="%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B-toc" style="margin-left:40px;"><a href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B" rel="nofollow">异常的处理流程</a></p> 
<p id="%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB-toc" style="margin-left:0px;"><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB" rel="nofollow">自定义类</a></p> 
<hr id="hr-toc"> 
<h2 style="background-color:transparent;">什么是异常</h2> 
<p>在java中，将程序执行过程中发生不正常行为称为异常。比如我们写代码经常遇到的：</p> 
<p><strong>算数异常</strong></p> 
<pre><code class="language-java">int a = 10 / 0;</code></pre> 
<p><img alt="" height="64" src="https://images2.imgbox.com/29/aa/OafZ0kNR_o.png" width="856"></p> 
<p><strong>数组越界异常</strong></p> 
<pre><code class="language-java">int[] arr = {1,2,3,4,5};
System.out.println(arr[10]);</code></pre> 
<p><img alt="" height="94" src="https://images2.imgbox.com/e1/37/xXHFTqLj_o.png" width="889"></p> 
<p><strong>空指针异常</strong></p> 
<pre><code class="language-java"> int[] arr = null;
 System.out.println(arr.length);</code></pre> 
<p><img alt="" height="86" src="https://images2.imgbox.com/d5/77/HkDiUNbw_o.png" width="802"></p> 
<p><strong>我们可以发现，java中不同的类型的异常有对应的类来描述。</strong></p> 
<h2 id="%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">异常的体系结构</h2> 
<p>异常种类有很多种，为了对这些异常可以比较好的管理起来，Java内部维护了一个异常的体系结构：</p> 
<p><span style="color:#956fe7;"><strong>Throwable：异常体系的顶层，还有派生出的两个类，Error和Execption</strong></span></p> 
<p><span style="color:#956fe7;"><strong>Error：是java虚拟机JVM无法解决的严重问题，比如：JVM中的内部错误，资源耗尽等。典型代表：StackOverflowErrow和OutofMemoryError，一但发生了程序就会崩溃，没有办法解决。</strong></span></p> 
<p><span style="color:#956fe7;"><strong>Execption：异常产生后程序员可以通过代码进行处理，让程序继续运行。</strong></span></p> 
<p><img alt="" height="657" src="https://images2.imgbox.com/12/a2/t87qc9HF_o.png" width="320"></p> 
<h2 id="%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB">异常的分类</h2> 
<p>异常可以在编译期间发生，也可以在运行时发生，根据发生的不同时机，可以分为：</p> 
<h3 id="%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8">编译时异常</h3> 
<p><span style="color:#ed7976;">在程序编译期间发生的异常，称为编译时异常，也可以叫受查异常</span></p> 
<pre><code class="language-java">class person {
    String name;
    int age;

    @Override
    protected Object clone() {
        return super.clone();
    }
}</code></pre> 
<p><img alt="" height="221" src="https://images2.imgbox.com/4f/35/UbhSomAy_o.png" width="1200"></p> 
<h3 id="%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8">运行时异常</h3> 
<p><span style="color:#ed7976;">在程序期间发生的异常，称为运行时异常，也可以叫为非受查异常</span></p> 
<p>RunTimeExecption和它的子类对应的异常，都是运行时异常。比如：NullPointerException、<br> ArrayIndexOutOfBoundsException、ArithmeticException</p> 
<p>注意：这里编译的时候的语法错误可不能叫做异常。<strong>运行时异常是指程序已经通过编译得到class文件，在JVM执行的过程中出现的错误。</strong></p> 
<h2 id="%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86">异常的处理</h2> 
<h3 id="%E9%98%B2%E5%BE%A1%E5%BC%8F%E7%BC%96%E7%A8%8B">防御式编程</h3> 
<p>错误的代码是时常会出现的，在出现问题的时候我们要让程序出现问题的时候及时通知程序猿。处理方式一般有两种：</p> 
<p><span style="color:#956fe7;"><strong>事前防御型，即在操作之前就做好充分的检查</strong></span></p> 
<pre><code class="language-java">    public static void main(String[] args) {
        boolean ret = false;
        ret = 登陆游戏();
        if (!ret) {
            处理登陆游戏错误;
            return;
        } 
        ret = 开始匹配();
        if (!ret) {
            处理匹配错误;
            return;
        } 
        ret = 游戏确认();
        if (!ret) {
            处理游戏确认错误;
            return;
        } 
        ret = 选择英雄();
        if (!ret) {
            处理选择英雄错误;
            return;
        } 
        ret = 载入游戏画面();
        if (!ret) {
            处理载入游戏错误;
            return;
        }
......
    }</code></pre> 
<p>这种方式还是存在比较大的缺陷，正常的流程和处理错误的流程代码都在一起，让代码整体看起来比较混乱。</p> 
<p><span style="color:#956fe7;"><strong>事后认错型，先操作，遇到问题再处理</strong></span></p> 
<pre><code class="language-java">    try {
        登陆游戏();
        开始匹配();
        游戏确认();
        选择英雄();
        载入游戏画面();
...
    } catch (登陆游戏异常) {
        处理登陆游戏异常;
    } catch (开始匹配异常) {
        处理开始匹配异常;
    } catch (游戏确认异常) {
        处理游戏确认异常;
    } catch (选择英雄异常) {
        处理选择英雄异常;
    } catch (载入游戏画面异常) {
        处理载入游戏画面异常;
    }
......</code></pre> 
<p>它的优势就是可以将正常的流程和错误流程分开，让程序猿更加关注正常流程，代码更清晰，更容易理解代码，异常处理的核心思想就是EAFP</p> 
<p><strong>在java中，处理异常主要有5个关键字：throw，throws，try，catch，final，throws</strong></p> 
<h3 id="%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8A%9B%E5%87%BA">异常的抛出</h3> 
<p>在编写程序的时候，如果程序出现了问题，就需要把程序的问题和错误信息告诉调用者。在java中，可以借助关键字throw，抛出一个指定的异常对象，将错误信息告知给调用者。</p> 
<p>使用方式：</p> 
<pre><code class="language-java">thow new xxxExcption("异常的原因");</code></pre> 
<p>举个栗子：实现一个获取数组的任意位置元素的方法</p> 
<pre><code class="language-java">    public static int getelment(int[] array, int index) {
        if(null == array) {
            throw new NullPointerException("空指针异常");
        }
        if(index &lt; 0 || index &gt;= array.length) {
            throw new ArrayIndexOutOfBoundsException("越界异常");
        }
        return array[index];
    }

    public static void main(String[] args) {
        int[] array = {1,2,3,4,5,6,7,8};
        getelment(array, 10);
    }</code></pre> 
<p><img alt="" height="165" src="https://images2.imgbox.com/6c/7c/n71LaQbb_o.png" width="939"></p> 
<p><span style="color:#ed7976;"><strong>注意：</strong></span></p> 
<p><span style="color:#ed7976;"><strong>throw必须在方法体中使用</strong></span></p> 
<p><span style="color:#ed7976;"><strong>抛出的对象必须是Exception或者Exception的子类</strong></span></p> 
<p><span style="color:#ed7976;"><strong>如果抛出的是RuntimeException或者RuntimeException的子类，则可以不用处理，直接交给JVM来处理</strong></span></p> 
<p><span style="color:#ed7976;"><strong>如果抛出的是编译时异常，用户必须处理，否则无法通过编译</strong></span></p> 
<p><span style="color:#ed7976;"><strong>异常一旦抛出，后面的代码就不会执行了</strong></span></p> 
<h3 id="%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8D%95%E8%8E%B7">异常的捕获</h3> 
<p><span style="color:#fe2c24;"><strong>异常的捕获，也就是异常的具体处理方式</strong></span>，主要有两种：异常声明throws和try - catch捕获处理</p> 
<h4 id="%E5%BC%82%E5%B8%B8%E5%A3%B0%E6%98%8E%20throws">异常声明 throws</h4> 
<p>throws在方法声明时参数列表的后面，当方法中抛出编译时异常，用户不想处理该异常，可以借助throws将异常抛给方法的调用者来处理。<span style="color:#956fe7;"><strong>即当前方法不处理异常，提醒方法的调用者来处理异常</strong></span></p> 
<p>使用形式：</p> 
<pre><code class="language-java">修饰符 返回值类型 方法名(参数列表) throws 异常类型1，异常类型2...{

}</code></pre> 
<p>举个栗子：加载指定文件congfig.ini</p> 
<pre><code class="language-java">public class Config {
    File file;
    /*
    FileNotFoundException : 编译时异常，表明文件不存在
    此处不处理，也没有能力处理，应该将错误信息报告给调用者，让调用者检查文件名字是否给错误了
    */
    public void OpenConfig(String filename) throws FileNotFoundException{
        if(filename.equals("config.ini")){
            throw new FileNotFoundException("配置文件名字不对");
        }
        // 打开文件
    }
    public void readConfig(){
    }
}</code></pre> 
<p><span style="color:#956fe7;"><strong>注意：<br> throws必须在方法的参数列表之后</strong></span></p> 
<p><span style="color:#956fe7;"><strong>声明的异常必须是Exception或者Exception的子类</strong></span></p> 
<p><span style="color:#956fe7;"><strong>方法内部出现多个异常，throws之后必须跟多个异常类型，之间用逗号隔开，如果异常具有父子关系，可以直接声明父类。</strong></span></p> 
<pre><code class="language-java">class Config {
    File file;
    // public void OpenConfig(String filename) throws IOException,FileNotFoundException{
// FileNotFoundException 继承自 IOException
    public void OpenConfig(String filename) throws IOException {
        if(filename.endsWith(".ini")){
            throw new IOException("文件不是.ini文件");
        } if(
                filename.equals("config.ini")){
            throw new FileNotFoundException("配置文件名字不对");
        } // 打开文件
    }
    public void readConfig(){
    }
}</code></pre> 
<p>调用声明抛出异常的方法时，调用者必须对该异常进行处理，或者继续使用throws抛出</p> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        Config config = new Config();
        config.OpenConfig(".ini");
    }</code></pre> 
<p>有两种方法：</p> 
<p>继续用throws抛出</p> 
<p><img alt="" height="253" src="https://images2.imgbox.com/1d/9e/7MfsMpBZ_o.png" width="1200"></p> 
<p>用try - catch处理</p> 
<p><img alt="" height="247" src="https://images2.imgbox.com/c1/b9/ZohpSPe5_o.png" width="1023"></p> 
<h4 id="try%20-%20catch%E6%8D%95%E8%8E%B7%E5%B9%B6%E5%BC%82%E5%B8%B8">try - catch捕获并异常</h4> 
<p>throws对异常并没有真正的处理，而是将异常报告告诉给调用者，让调用者来处理。如果真正要对异常处理，就要使用try - catch</p> 
<p>使用形式：</p> 
<pre><code class="language-java">try{
// 将可能出现异常的代码放在这里
}catch(要捕获的异常类型 e){
// 如果try中的代码抛出异常了，此处catch捕获时异常类型与try中抛出的异常类型一致时，或者是try中抛出异常的基类
时，就会被捕获到
// 对异常就可以正常处理，处理完成后，跳出try-catch结构，继续执行后序代码
}[catch(异常类型 e){
// 对异常进行处理
}finally{
// 此处代码一定会被执行到
}]
// 后序代码
// 当异常被捕获到时，异常就被处理了，这里的后序代码一定会执行
// 如果捕获了，由于捕获时类型不对，那就没有捕获到，这里的代码就不会被执行</code></pre> 
<p>举个栗子：读取配置文件，如果配置文件名字不是指定名字，抛出异常，调用者进行异常处理</p> 
<pre><code class="language-java">class Config {
    File file;
    public void openConfig(String filename) throws FileNotFoundException{
        if(!filename.equals("config.ini")){
            throw new FileNotFoundException("配置文件名字不对");
        } // 打开文件
    }
    public void readConfig(){
    }
    public static void main(String[] args) {
        Config config = new Config();
        try {
            config.openConfig("config.txt");
            System.out.println("文件打开成功");
        } catch (IOException e) {
// 异常的处理方式
//System.out.println(e.getMessage()); // 只打印异常信息
//System.out.println(e); // 打印异常类型：异常信息
            e.printStackTrace(); // 打印信息最全面
        } // 一旦异常被捕获处理了，此处的代码会执行
        System.out.println("异常如果被处理了，这里的代码也可以执行");
    }
}</code></pre> 
<p><strong>异常的处理方式</strong></p> 
<p>异常的种类有很多, 我们要根据不同的业务场景来决定.</p> 
<p>对于比较严重的问题(例如和算钱相关的场景), 应该让程序直接崩溃, 防止造成更严重的后果</p> 
<p>对于不太严重的问题(大多数场景), 可以记录错误日志, 并通过监控报警程序及时通知程序猿</p> 
<p>对于可能会恢复的问题(和网络相关的场景), 可以尝试进行重试.</p> 
<p>在我们当前的代码中采取的是经过简化的第二种方式. 我们记录的错误日志是出现异常的方法调用信息, 能很快速的让我们找到出现异常的位置. 以后在实际工作中我们会采取更完备的方式来记录异常信息. </p> 
<p><span style="color:#ed7976;"><strong>注意：</strong></span></p> 
<p><span style="color:#ed7976;"><strong>try快内抛出异常位置之后的代码将不会被执行</strong></span></p> 
<p><span style="color:#ed7976;"><strong>如果抛出异常类型与catch时异常类型不匹配，也就不会处理，继续向外抛，直到JVM收到后中断系统</strong></span></p> 
<p><span style="color:#ed7976;"><strong>try中可能会抛出多个不同的异常对象，则必须用多个catch来捕获</strong></span></p> 
<pre><code class="language-java">public static void main(String[] args) {
int[] arr = {1, 2, 3};
try {
System.out.println("before");
// arr = null;
System.out.println(arr[100]);
System.out.println("after");
} catch (ArrayIndexOutOfBoundsException e) {
System.out.println("这是个数组下标越界异常");
e.printStackTrace();
} catch (NullPointerException e) {
System.out.println("这是个空指针异常");
e.printStackTrace();
} S
ystem.out.println("after try catch");
}</code></pre> 
<p><span style="color:#ed7976;"><strong>如果多个异常的处理方法一样，也可以这样写：</strong></span></p> 
<pre><code class="language-java">catch (ArrayIndexOutOfBoundsException | NullPointerException e) {
...
}</code></pre> 
<p><span style="color:#ed7976;"><strong>如果异常之间具有父子关系，一定要子类在前，父类在后，否则语法错误：</strong></span></p> 
<pre><code class="language-java">    public static void main(String[] args) {
        int[] arr = {1, 2, 3};
        try {
            System.out.println("before");
            arr = null;
            System.out.println(arr[100]);
            System.out.println("after");
        } catch (NullPointerException e) { // Exception可以捕获到所有异常
            e.printStackTrace();
        }catch (Exception e){ // 永远都捕获执行到
            e.printStackTrace();
        } System.out.println("after try catch");
    }</code></pre> 
<p><span style="color:#ed7976;"><strong>一个catch可以捕获所有的异常，但是没有必要</strong></span></p> 
<p><span style="color:#ed7976;"><strong>catch进行类型匹配的时候，不光会匹配相同类型的异常对象，还会捕捉目标异常类型的子类对象</strong></span></p> 
<h4 id="finally">finally</h4> 
<p>在写程序的时候<strong>，有一些代码就是不论程序是否发生异常，都需要执行，比如程序中打开的资源，在程序正常，异常退出时必须对资源进行回收。</strong>又因为异常会导致程序的跳转，一些代码执行不到，finally就是用来解决这个问题的。</p> 
<p>使用形式：</p> 
<pre><code class="language-java">语法格式：
try{
// 可能会发生异常的代码
}catch(异常类型 e){
// 对捕获到的异常进行处理
}finally{
// 此处的语句无论是否发生异常，都会被执行到
} 

// 如果没有抛出异常，或者异常被捕获处理了，这里的代码也会执行</code></pre> 
<pre><code class="language-java">public static void main(String[] args) {
try{
int[] arr = {1,2,3};
arr[100] = 10;
arr[0] = 10;
}catch (ArrayIndexOutOfBoundsException e){
System.out.println(e);
}finally {
System.out.println("finally中的代码一定会执行");
} S
ystem.out.println("如果没有抛出异常，或者异常被处理了，try-catch后的代码也会执行");
}</code></pre> 
<p><strong>finally的作用</strong></p> 
<pre><code class="language-java">class TestFinally {
    public static int getData(){
        Scanner sc = null;
        try{
            sc = new Scanner(System.in);
            int data = sc.nextInt();
            return data;
        }catch (InputMismatchException e){
            e.printStackTrace();
        }finally {
            System.out.println("finally中代码");
        } System.out.println("try-catch-finally之后代码");
        if(null != sc){
            sc.close();
        }
        return 0;
    }
    public static void main(String[] args) {
        int data = getData();
        System.out.println(data);
    }
} // 正常输入时程序运行结果：
                    /*100
                    finally中代码
                    100*/</code></pre> 
<p>通过这个代码，可以发现如果正常输入，成功后接到输入就返回了，后面的close就没有被执行，输入流没有被释放，造成资源泄露。而finally会被执行，就可以将close写在finally中，就不会造成资源泄露了。</p> 
<p><span style="color:#956fe7;"><strong>注意：finally中的代码一定会被执行，因此可以在finally中进行一些资源清理的扫尾工作。</strong></span></p> 
<h3 id="%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B">异常的处理流程</h3> 
<p>什么是调用栈：</p> 
<p>方法之间是存在相互调用关系的，这种关系我们可以用“调用栈”来描述。在JVM中有一块内存空间称为“虚拟机栈”专门存储方法之间的调用关系。当代码出现异常的时候，我们就可以使用e.printStackTrace();的方式来查看出现异常的调用栈。</p> 
<p>当方法中没有合适的处理异常的方式时，就会延调用栈向上传递</p> 
<pre><code class="language-java">public static void main(String[] args) {
try {
func();
} catch (ArrayIndexOutOfBoundsException e) {
e.printStackTrace();
} System.out.println("after try catch");
}
public static void func() {
int[] arr = {1, 2, 3};
System.out.println(arr[100]);
}</code></pre> 
<p>如果向上传递都没有合适的方法处理异常，就会交给JVM处理，程序就会异常终止。</p> 
<pre><code class="language-java">public static void main(String[] args) {
func();
System.out.println("after try catch");
}
public static void func() {
int[] arr = {1, 2, 3};
System.out.println(arr[100]);
} // 执行结果
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 100
at demo02.Test.func(Test.java:14)
at demo02.Test.main(Test.java:8)</code></pre> 
<p>程序异常终止，没有执行最后一行的打印</p> 
<p>异常处理的流程：</p> 
<p>程序先执行try中的代码</p> 
<p>如果try中的代码出现异常，就会结束try中的代码，看和catch中的异常类型是否匹配</p> 
<p>如果找到匹配的异常类型，就会执行catch中的代码</p> 
<p>如果没有找到，就会将异常向上传递到上层调用者</p> 
<p>无论是否找到匹配的异常类型，都会执行finally</p> 
<p>如果上层调用者也没有处理异常，就继续向上传递</p> 
<p>一直到main方法也没有合适的代码处理异常，就会交给JVM来进行处理此时程序就会异常终止</p> 
<h2 id="%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB">自定义类</h2> 
<p>java中的异常类并不能完全满足我们日常开发中遇到的一些异常，此时就需要我们维护符合实际情况的异常结构</p> 
<p>举个栗子：登陆功能</p> 
<pre><code class="language-java">class LogIn {
    private String userName = "admin";
    private String password = "123456";
    public static void loginInfo(String userName, String password) {
        if (!userName.equals(userName)) {
        } if
        (!password.equals(password)) {
        } System.out.println("登陆成功");
    }
    public static void main(String[] args) {
        loginInfo("admin", "123456");
    }
}</code></pre> 
<p>我们发现这里我们就需要两个异常，这时我们可以基于已有的异常类进行拓展，创建与我们业务相关的异常类</p> 
<p>方式：</p> 
<p><span style="color:#ed7976;"><strong>自定义异常类，然后继承Exception或者RunTimeException</strong></span></p> 
<p><span style="color:#ed7976;"><strong>实现一个带有String类型参数的构造方法，作用就是告诉出现异常的原因</strong></span></p> 
<p>代码实现；</p> 
<pre><code class="language-java">class LogIn {
    private static String Name = "admin";
    private static String word = "123456";
    public static void loginInfo(String userName, String password) throws UernameException,PasswordException {
        if (!userName.equals(Name)) {
            throw new UernameException("用户名错误");
        }
        if(!password.equals(password)) {
            throw new PasswordException("密码错误");
        }
        System.out.println("登陆成功");
    }
    public static void main(String[] args) {
        try {
            loginInfo("adin", "1236");

        }catch(UernameException | PasswordException e) {
            e.printStackTrace();
        }
    }
}</code></pre> 
<p><span style="color:#956fe7;"><strong>注意：</strong></span></p> 
<p><span style="color:#956fe7;"><strong>自定义异常通常会继承Exception或者RunTimeException</strong></span></p> 
<p><span style="color:#956fe7;"><strong>继承的Exception是编译时异常</strong></span></p> 
<p><span style="color:#956fe7;"><strong>RunTimeException是运行时异常</strong></span></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4408233c8aede8f2e08371ee5ea625b4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决明明环境变量没问题,启动idea还是报错The environment variable JAVA HOME</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/35d3555bac7cccb41f89a1bdc7fe98ab/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Java从入门到精通】这也许就是Java火热的原因吧！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>