<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】树-堆的详解 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/62e7d3be6e0e4f2ce0ed657f9474b7b9/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】树-堆的详解">
  <meta property="og:description" content="目录
1.树的概念
树的相关概念：
结点的度：
叶结点或终端结点：
非终端结点或分支结点：
双亲结点或父结点：
孩子结点或子结点：
兄弟结点：
树的度：
结点的层次：
树的高度或深度：
堂兄弟结点：
结点的祖先：
子孙：
森林：
二叉树的概念
堆的概念
大堆，小堆概念 堆的实现
堆的底层逻辑：动态数组 初始化和销毁 堆的插入 堆的删除 堆的判空和取堆的顶数据
整体代码及测试： 1.树的概念 在学习了解堆之前，我们需要来了解树，堆是树中的一种特殊情况。 可能我们听到树这个名字时，脑海中就会不由自主的浮现一颗树的形状，树作为数据结构的一环，它的，模型就像是一颗倒着的树一样的结构，每个节点存放着我们需要的数据，示例图如下：
树的相关概念： 结点的度： 如图所示，节点的度指的就是该节点所连接的其他节点个数，图中A节点的度为6，B节点的度为3 叶结点或终端结点： 叶结点或终端结点又称作叶子，就像一颗树上的叶子一样，后续没有枝干延升了，树中的叶子节点指的就是那些度为0的节点。
非终端结点或分支结点： 指的就是那些度不为0的节点
双亲结点或父结点： 如图，A为父亲的话，那么B,C,D,E,F,G都是它的孩子
孩子结点或子结点： 指的就是B,C,D,E,F,G
兄弟结点： 树的度： 以树中节点度中的最大一个为树的度，如图树中A节点的度最大为6，那么树的度就是为6
结点的层次： 从根开始定义起，根为第1层，根的子结点为第2层，以此类推
树的高度或深度： 树中结点的最大层次； 如上图：树的高度为4
堂兄弟结点： 双亲在同一层的结点互为堂兄弟；如上图：H、I互为兄弟结点
结点的祖先： 从根到该结点所经分支上的所有结点；如上图：A是所有结点的祖先
子孙： 以某结点为根的子树中任一结点都称为该结点的子孙。如上图：所有结点都是A的子孙
森林： 由m（m&gt;0）棵互不相交的树的集合称为森林
二叉树的概念 二叉树是树中特殊的一种，它的每一个父亲节点的孩子都不会超过两个。
二叉树不存在度大于2的结点二叉树的子树有左右之分，次序不能颠倒，因此二叉树是有序树 以下又是二叉树的各种情况： 满二叉树：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是 ，则它就是满二叉树。完全二叉树：完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。 要注意的是满二叉树是一种特殊的完全二叉树。 堆的概念 堆就属于满二叉树或者完全二叉树的一种，堆的底层实现可以通过顺序存储或者链式存储，本次我们实现的是顺序存储。那么一个堆在底层的顺序存储又是什么样子的呢，看下图。
通过上图我们又可以了解如何使用每一个父亲节点去计算孩子节点：
左child = parent * 2 &#43; 1 右child = parent * 2 &#43; 2 通过孩子计算父亲节点：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-19T20:21:03+08:00">
    <meta property="article:modified_time" content="2024-05-19T20:21:03+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】树-堆的详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#1.%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">1.树的概念</a></p> 
<p id="%E6%A0%91%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E6%A0%91%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%EF%BC%9A" rel="nofollow">树的相关概念：</a></p> 
<p id="%E7%BB%93%E7%82%B9%E7%9A%84%E5%BA%A6%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E7%BB%93%E7%82%B9%E7%9A%84%E5%BA%A6%EF%BC%9A" rel="nofollow">结点的度：</a></p> 
<p id="%E5%8F%B6%E7%BB%93%E7%82%B9%E6%88%96%E7%BB%88%E7%AB%AF%E7%BB%93%E7%82%B9%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%8F%B6%E7%BB%93%E7%82%B9%E6%88%96%E7%BB%88%E7%AB%AF%E7%BB%93%E7%82%B9%EF%BC%9A" rel="nofollow">叶结点或终端结点：</a></p> 
<p id="%E9%9D%9E%E7%BB%88%E7%AB%AF%E7%BB%93%E7%82%B9%E6%88%96%E5%88%86%E6%94%AF%E7%BB%93%E7%82%B9%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E9%9D%9E%E7%BB%88%E7%AB%AF%E7%BB%93%E7%82%B9%E6%88%96%E5%88%86%E6%94%AF%E7%BB%93%E7%82%B9%EF%BC%9A" rel="nofollow">非终端结点或分支结点：</a></p> 
<p id="%E5%8F%8C%E4%BA%B2%E7%BB%93%E7%82%B9%E6%88%96%E7%88%B6%E7%BB%93%E7%82%B9%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%8F%8C%E4%BA%B2%E7%BB%93%E7%82%B9%E6%88%96%E7%88%B6%E7%BB%93%E7%82%B9%EF%BC%9A" rel="nofollow">双亲结点或父结点：</a></p> 
<p id="%E5%AD%A9%E5%AD%90%E7%BB%93%E7%82%B9%E6%88%96%E5%AD%90%E7%BB%93%E7%82%B9%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%AD%A9%E5%AD%90%E7%BB%93%E7%82%B9%E6%88%96%E5%AD%90%E7%BB%93%E7%82%B9%EF%BC%9A" rel="nofollow">孩子结点或子结点：</a></p> 
<p id="%E5%85%84%E5%BC%9F%E7%BB%93%E7%82%B9%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%85%84%E5%BC%9F%E7%BB%93%E7%82%B9%EF%BC%9A" rel="nofollow">兄弟结点：</a></p> 
<p id="%E6%A0%91%E7%9A%84%E5%BA%A6%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E6%A0%91%E7%9A%84%E5%BA%A6%EF%BC%9A" rel="nofollow">树的度：</a></p> 
<p id="%E7%BB%93%E7%82%B9%E7%9A%84%E5%B1%82%E6%AC%A1%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E7%BB%93%E7%82%B9%E7%9A%84%E5%B1%82%E6%AC%A1%EF%BC%9A" rel="nofollow">结点的层次：</a></p> 
<p id="%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6%E6%88%96%E6%B7%B1%E5%BA%A6%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6%E6%88%96%E6%B7%B1%E5%BA%A6%EF%BC%9A" rel="nofollow">树的高度或深度：</a></p> 
<p id="%E5%A0%82%E5%85%84%E5%BC%9F%E7%BB%93%E7%82%B9%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%A0%82%E5%85%84%E5%BC%9F%E7%BB%93%E7%82%B9%EF%BC%9A" rel="nofollow">堂兄弟结点：</a></p> 
<p id="%E7%BB%93%E7%82%B9%E7%9A%84%E7%A5%96%E5%85%88%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E7%BB%93%E7%82%B9%E7%9A%84%E7%A5%96%E5%85%88%EF%BC%9A" rel="nofollow">结点的祖先：</a></p> 
<p id="%E5%AD%90%E5%AD%99%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%AD%90%E5%AD%99%EF%BC%9A" rel="nofollow">子孙：</a></p> 
<p id="%E6%A3%AE%E6%9E%97%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E6%A3%AE%E6%9E%97%EF%BC%9A" rel="nofollow">森林：</a></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">二叉树的概念</a></p> 
<p id="%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">堆的概念</a></p> 
<p id="%E5%A4%A7%E5%A0%86%EF%BC%8C%E5%B0%8F%E5%A0%86%E6%A6%82%E5%BF%B5%C2%A0-toc" style="margin-left:40px;"><a href="#%E5%A4%A7%E5%A0%86%EF%BC%8C%E5%B0%8F%E5%A0%86%E6%A6%82%E5%BF%B5%C2%A0" rel="nofollow">大堆，小堆概念 </a></p> 
<p id="%C2%A0%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%C2%A0%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow"> 堆的实现</a></p> 
<p id="%E5%A0%86%E7%9A%84%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%EF%BC%9A%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%C2%A0-toc" style="margin-left:40px;"><a href="#%E5%A0%86%E7%9A%84%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%EF%BC%9A%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%C2%A0" rel="nofollow">堆的底层逻辑：动态数组 </a></p> 
<p id="%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81%C2%A0-toc" style="margin-left:40px;"><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81%C2%A0" rel="nofollow">初始化和销毁 </a></p> 
<p id="%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5%C2%A0-toc" style="margin-left:40px;"><a href="#%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5%C2%A0" rel="nofollow">堆的插入 </a></p> 
<p id="%E5%A0%86%E7%9A%84%E5%88%A0%E9%99%A4%C2%A0-toc" style="margin-left:40px;"><a href="#%E5%A0%86%E7%9A%84%E5%88%A0%E9%99%A4%C2%A0" rel="nofollow">堆的删除 </a></p> 
<p id="%E5%A0%86%E7%9A%84%E5%88%A4%E7%A9%BA%E5%92%8C%E5%8F%96%E5%A0%86%E7%9A%84%E9%A1%B6%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#%E5%A0%86%E7%9A%84%E5%88%A4%E7%A9%BA%E5%92%8C%E5%8F%96%E5%A0%86%E7%9A%84%E9%A1%B6%E6%95%B0%E6%8D%AE" rel="nofollow">堆的判空和取堆的顶数据</a></p> 
<p id="%E6%95%B4%E4%BD%93%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%B5%8B%E8%AF%95%EF%BC%9A%C2%A0-toc" style="margin-left:0px;"><a href="#%E6%95%B4%E4%BD%93%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%B5%8B%E8%AF%95%EF%BC%9A%C2%A0" rel="nofollow">整体代码及测试： </a></p> 
<p id="%C2%A0-toc" style="margin-left:0px;"><a href="#%C2%A0" rel="nofollow"> </a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1.%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5"><span style="color:#ff9900;"><strong>1.树的概念</strong></span></h2> 
<p><strong>在学习了解堆之前，我们需要来了解树，堆是树中的一种特殊情况。 </strong></p> 
<p><span style="color:#0d0016;">可能我们听到树这个名字时，脑海中就会不由自主的浮现一颗树的形状，树作为数据结构的一环，它的，模型就像是一颗倒着的树一样的结构，每个节点存放着我们需要的数据，示例图如下：</span></p> 
<p><img alt="" height="1013" src="https://images2.imgbox.com/b4/7e/G8yt8x0f_o.png" width="1200"></p> 
<p><img alt="" height="465" src="https://images2.imgbox.com/ca/fa/ntFtY8O6_o.png" width="631"></p> 
<h3 id="%E6%A0%91%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%EF%BC%9A"><span style="color:#a2e043;">树的相关概念：</span></h3> 
<h4 id="%E7%BB%93%E7%82%B9%E7%9A%84%E5%BA%A6%EF%BC%9A">结点的度：</h4> 
<p><img alt="" height="572" src="https://images2.imgbox.com/69/83/rZMJkzag_o.png" width="1045"></p> 
<p><span style="color:#fe2c24;"><strong>如图所示，节点的度指的就是该节点所连接的其他节点个数，图中A节点的度为6，B节点的度为3 </strong></span></p> 
<h4 id="%E5%8F%B6%E7%BB%93%E7%82%B9%E6%88%96%E7%BB%88%E7%AB%AF%E7%BB%93%E7%82%B9%EF%BC%9A">叶结点或终端结点：</h4> 
<p><img alt="" height="612" src="https://images2.imgbox.com/b5/8d/CDyndZjX_o.png" width="1084"></p> 
<p> <span style="color:#fe2c24;"><strong>叶结点或终端结点又称作叶子，就像一颗树上的叶子一样，后续没有枝干延升了，树中的叶子节点指的就是那些度为0的节点。</strong></span></p> 
<h4 id="%E9%9D%9E%E7%BB%88%E7%AB%AF%E7%BB%93%E7%82%B9%E6%88%96%E5%88%86%E6%94%AF%E7%BB%93%E7%82%B9%EF%BC%9A"><br> 非终端结点或分支结点：</h4> 
<p><img alt="" height="615" src="https://images2.imgbox.com/fd/88/6OCFOeSM_o.png" width="1030"></p> 
<p><span style="color:#fe2c24;"><strong>指的就是那些度不为0的节点</strong></span></p> 
<h4 id="%E5%8F%8C%E4%BA%B2%E7%BB%93%E7%82%B9%E6%88%96%E7%88%B6%E7%BB%93%E7%82%B9%EF%BC%9A"><br> 双亲结点或父结点：</h4> 
<p><img alt="" height="599" src="https://images2.imgbox.com/7d/f6/6lZZ7Aoi_o.png" width="1020"></p> 
<p><span style="color:#fe2c24;"><strong>如图，A为父亲的话，那么B,C,D,E,F,G都是它的孩子</strong></span></p> 
<h4 id="%E5%AD%A9%E5%AD%90%E7%BB%93%E7%82%B9%E6%88%96%E5%AD%90%E7%BB%93%E7%82%B9%EF%BC%9A"><br> 孩子结点或子结点：</h4> 
<p><img alt="" height="599" src="https://images2.imgbox.com/9f/aa/dNwRupI3_o.png" width="1020"></p> 
<p><span style="color:#fe2c24;"><strong>指的就是B,C,D,E,F,G</strong></span></p> 
<h4 id="%E5%85%84%E5%BC%9F%E7%BB%93%E7%82%B9%EF%BC%9A"><br> 兄弟结点：</h4> 
<p><img alt="" height="638" src="https://images2.imgbox.com/de/67/jUXfOxzF_o.png" width="1200"></p> 
<h4 id="%E6%A0%91%E7%9A%84%E5%BA%A6%EF%BC%9A"><br> 树的度：</h4> 
<p><img alt="" height="572" src="https://images2.imgbox.com/35/f4/0OrXUepa_o.png" width="1045"></p> 
<p><span style="color:#fe2c24;"><strong>以树中节点度中的最大一个为树的度，如图树中A节点的度最大为6，那么树的度就是为6</strong></span></p> 
<h4 id="%E7%BB%93%E7%82%B9%E7%9A%84%E5%B1%82%E6%AC%A1%EF%BC%9A"><br> 结点的层次：</h4> 
<p><img alt="" height="629" src="https://images2.imgbox.com/ac/f5/OyLJGGml_o.png" width="1200"></p> 
<p><span style="color:#fe2c24;"><strong>从根开始定义起，根为第1层，根的子结点为第2层，以此类推</strong></span></p> 
<h4 id="%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6%E6%88%96%E6%B7%B1%E5%BA%A6%EF%BC%9A"><br> 树的高度或深度：</h4> 
<p><img alt="" height="629" src="https://images2.imgbox.com/c5/b8/XHw9jLEa_o.png" width="1200"></p> 
<p><span style="color:#fe2c24;"><strong> 树中结点的最大层次； 如上图：树的高度为4</strong></span></p> 
<h4 id="%E5%A0%82%E5%85%84%E5%BC%9F%E7%BB%93%E7%82%B9%EF%BC%9A"><br> 堂兄弟结点：</h4> 
<p><img alt="" height="564" src="https://images2.imgbox.com/e7/f3/M8X4z21S_o.png" width="967"></p> 
<p><span style="color:#fe2c24;"><strong>双亲在同一层的结点互为堂兄弟；如上图：H、I互为兄弟结点</strong></span></p> 
<h4 id="%E7%BB%93%E7%82%B9%E7%9A%84%E7%A5%96%E5%85%88%EF%BC%9A"><br> 结点的祖先：</h4> 
<p><img alt="" height="607" src="https://images2.imgbox.com/50/75/xKjqD1i4_o.png" width="1001"><span style="color:#fe2c24;"><strong>从根到该结点所经分支上的所有结点；如上图：A是所有结点的祖先</strong></span><br>  </p> 
<h4 id="%E5%AD%90%E5%AD%99%EF%BC%9A"><br> 子孙：</h4> 
<p><img alt="" height="607" src="https://images2.imgbox.com/28/c3/0usB2JA0_o.png" width="1001"></p> 
<p><span style="color:#fe2c24;"><strong>以某结点为根的子树中任一结点都称为该结点的子孙。如上图：所有结点都是A的子孙</strong></span></p> 
<h4 id="%E6%A3%AE%E6%9E%97%EF%BC%9A"><br> 森林：</h4> 
<p><img alt="" height="986" src="https://images2.imgbox.com/15/b0/23hbgH1q_o.png" width="1200"></p> 
<p><span style="color:#fe2c24;"><strong>由m（m&gt;0）棵互不相交的树的集合称为森林</strong></span><br>  </p> 
<h2 id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5"><span style="color:#ff9900;"><strong>二叉树的概念</strong></span></h2> 
<p> <span style="color:#0d0016;"><strong>二叉树是树中特殊的一种，它的每一个父亲节点的孩子都不会超过两个。</strong></span></p> 
<p><img alt="" height="414" src="https://images2.imgbox.com/7a/f8/y9knNro3_o.png" width="861"></p> 
<ul><li> 二叉树不存在度大于2的结点</li><li>二叉树的子树有左右之分，次序不能颠倒，因此二叉树是有序树</li></ul> 
<p>以下又是二叉树的各种情况： </p> 
<p><img alt="" height="263" src="https://images2.imgbox.com/10/fb/961c5RLG_o.png" width="813"> <img alt="" height="605" src="https://images2.imgbox.com/35/8e/0OCF7R3C_o.png" width="720"></p> 
<ul><li><strong>满二叉树：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是 ，则它就是满二叉树。</strong></li><li><strong>完全二叉树：完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。 要注意的是满二叉树是一种特殊的完全二叉树。</strong></li></ul> 
<p><img alt="" height="392" src="https://images2.imgbox.com/39/7d/x7Pt9Dyi_o.png" width="1117"></p> 
<h2 id="%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5"><span style="color:#ff9900;"><strong>堆的概念</strong></span></h2> 
<p><span style="color:#0d0016;"><strong>堆就属于满二叉树或者完全二叉树的一种，堆的底层实现可以通过顺序存储或者链式存储，本次我们实现的是顺序存储。那么一个堆在底层的顺序存储又是什么样子的呢，看下图。</strong></span></p> 
<p><img alt="" height="883" src="https://images2.imgbox.com/3c/2b/G3o20YnV_o.png" width="1137"> <span style="color:#0d0016;"><strong>通过上图我们又可以了解如何使用每一个父亲节点去计算孩子节点：</strong></span></p> 
<ul><li><strong>左child = parent * 2 + 1  </strong></li><li><strong>右child = parent * 2 + 2</strong></li></ul> 
<p> <span style="color:#0d0016;"><strong>通过孩子计算父亲节点：</strong></span></p> 
<ul><li><strong>parent = (child - 1) /2</strong></li></ul> 
<h3 id="%E5%A4%A7%E5%A0%86%EF%BC%8C%E5%B0%8F%E5%A0%86%E6%A6%82%E5%BF%B5%C2%A0"><span style="color:#a2e043;"><strong>大堆，小堆概念 </strong></span></h3> 
<p><img alt="" height="953" src="https://images2.imgbox.com/13/43/31DXjNiW_o.png" width="1200"></p> 
<ul><li><strong>大堆：所有的父亲节点的数据都&gt;=孩子节点</strong></li><li><strong>小堆：所有的父亲节点的数据都&lt;=孩子节点 </strong></li></ul> 
<h2 id="%C2%A0%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0"> <span style="color:#ff9900;"><strong>堆的实现</strong></span></h2> 
<h3 id="%E5%A0%86%E7%9A%84%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%EF%BC%9A%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%C2%A0"><span style="color:#a2e043;">堆的底层逻辑：动态数组 </span></h3> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdlib.h&gt;

// 类型定义
typedef int HPDataTpye;

typedef struct Heap
{
	// 动态数组
	HPDataTpye* a;
	// 元素个数
	int size;
	// 空间容量
	int capacity;
}Heap;</code></pre> 
<p><span style="color:#fe2c24;"><strong>其实操作堆的底层就是对动态数组的操作，我们只需按照堆的方式进行设计即可。 </strong></span></p> 
<p><strong>以下是我们会实现的接口功能： </strong></p> 
<pre><code class="language-cpp">// 函数声明

// 堆的初始化
void HeapInit(Heap* php);

// 堆的销毁
void HeapDestory(Heap* php);

// 堆的插入
void HeapPush(Heap* php, HPDataTpye x);

// 堆的删除
void HeapPop(Heap* php);

// 堆的判空
bool HeapEmpty(Heap* php);

// 取堆的顶数据
HPDataTpye HeapTop(Heap* php);</code></pre> 
<h3 id="%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81%C2%A0"><span style="color:#a2e043;"><strong>初始化和销毁 </strong></span></h3> 
<pre><code class="language-cpp">// 堆的初始化
void HeapInit(Heap* php)
{
	// 判空
	assert(php);

	// 初始化
	php-&gt;a = NULL;
	php-&gt;size = php-&gt;capacity = 0;

}

// 堆的销毁
void HeapDestory(Heap* php)
{
	// 判空
	assert(php);

	// 释放空间
	free(php-&gt;a);
	php-&gt;a = NULL;
	php-&gt;size = php-&gt;capacity = 0;

}</code></pre> 
<h3 id="%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5%C2%A0"><span style="color:#a2e043;"><strong>堆的插入 </strong></span></h3> 
<p> <strong>这边我们先实现一个大堆的案例：</strong></p> 
<p><strong>首先我们在插入堆的情况可能有以下三种情况： </strong></p> 
<p> <img alt="" height="691" src="https://images2.imgbox.com/35/b9/TXGzOO7G_o.png" width="1200"></p> 
<p> <img alt="" height="673" src="https://images2.imgbox.com/e1/67/m6x9vwUp_o.png" width="1200"></p> 
<p>如果插入的数据是图一的情况，我们直接不用管理了，插入之后还是一个大堆，但是如果是图二或者图三的情况，我们就需要对堆进行一个调整，将它调整为大堆的情况。</p> 
<p>首先我们需要计算出最后插入数据的父亲节点，让后进行比较，如果刚插入的孩子节点大我们就进行交换，简单点说就是谁大谁当爹，然后通过这样不断的调整，直到插入的孩子到顶，或者中途有父亲节点比它大才结束。</p> 
<p>以下是图形过程：</p> 
<p><img alt="" height="725" src="https://images2.imgbox.com/47/89/BCodpH24_o.png" width="1200"></p> 
<p>代码实现： </p> 
<pre><code class="language-cpp">// 向上调整
void AdjustUp(HPDataTpye* a, int child)
{
	// 算父亲节点
	int parent = (child - 1) / 2;

	// 循环向上排序
	while (child &gt; 0)
	{
		if (a[child] &gt; a[parent])
		{
			// 交换
			Swap(&amp;a[child], &amp;a[parent]);
			// 把父亲赋值给孩子
			child = parent;
			parent = (child - 1) / 2;
		}
		else {
			break;
		}
	}
}

// 堆的插入
void HeapPush(Heap* php, HPDataTpye x)
{
	// 判空
	assert(php);

	// 判断空间是否满
	if (php-&gt;size == php-&gt;capacity)
	{
		// 看原来的空间容量是否为0，为0分配4个空间，不为0空间*2
		int newcapacity = php-&gt;capacity == 0 ? 4 : php-&gt;capacity * 2;
		// 分配动态空间
		HPDataTpye* tmp = (HPDataTpye*)realloc(php-&gt;a, newcapacity * sizeof(HPDataTpye));
		if (NULL == tmp)
		{
			perror("malloc fail");
			return;
		}

		php-&gt;a = tmp;
		php-&gt;capacity = newcapacity;
	}

	// 插入
	php-&gt;a[php-&gt;size - 1] = x;
	php-&gt;size++;

	// 向上调整
	AdjustUp(php-&gt;a, php-&gt;size-1);
}</code></pre> 
<p> <strong>测试一下：</strong></p> 
<pre><code class="language-cpp">void HeapText01()
{
	Heap h;
	// 初始化
	HeapInit(&amp;h);

	int arr[] = { 4,2,8,1,5,6,9,7};
	for (int i = 0; i &lt; sizeof(arr) / sizeof(int); i++)
	{
		HeapPush(&amp;h, arr[i]);
	}

	// 销毁
	HeapDestory(&amp;h);
}


int main()
{
	HeapText01();
	return 0;
}</code></pre> 
<p> <img alt="" height="697" src="https://images2.imgbox.com/c8/0e/2ySPYWta_o.png" width="605"></p> 
<p>那么实现小堆模型呢，其实很简单，我们只需要将判定大小的条件改一下即可 </p> 
<pre><code class="language-cpp">// 向上调整
void AdjustUp(HPDataTpye* a, int child)
{
	// 算父亲节点
	int parent = (child - 1) / 2;

	// 循环向上排序
	while (child &gt; 0)
	{
		if (a[child] &lt; a[parent])
		{
			// 交换
			Swap(&amp;a[child], &amp;a[parent]);
			// 把父亲赋值给孩子
			child = parent;
			parent = (child - 1) / 2;
		}
		else {
			break;
		}
	}
}</code></pre> 
<p><img alt="" height="43" src="https://images2.imgbox.com/19/b1/FY4J7sfh_o.png" width="1200"></p> 
<h3 id="%E5%A0%86%E7%9A%84%E5%88%A0%E9%99%A4%C2%A0"><span style="color:#a2e043;"><strong>堆的删除 </strong></span></h3> 
<p> <img alt="" height="523" src="https://images2.imgbox.com/ab/c5/vZb55una_o.png" width="1200"></p> 
<pre><code class="language-cpp">// 向下调整
void AdjustDown(HPDataTpye* a, int n, int parent)
{
	int child = parent * 2 + 1;
	
	while (child &lt; n)
	{
        if (child + 1 &lt; n &amp;&amp; a[child] &lt; a[child + 1])
	    {
		    child++;
	    }
		if (a[child] &gt; a[parent])
		{
			// 交换
			Swap(&amp;a[child], &amp;a[parent]);
			parent = child;
			child = parent * 2 + 1;
		}
		else {
			break;
		}
	}
}

// 堆的删除
void HeapPop(Heap* php)
{
	// 判空
	assert(php);
	assert(php-&gt;size &gt; 0);

	// 交换
	Swap(&amp;php-&gt;a[0], &amp;php-&gt;a[php-&gt;size - 1]);
	php-&gt;size--;

	// 向下调整
	AdjustDown(php-&gt;a, php-&gt;size, 0);
}</code></pre> 
<h3 id="%E5%A0%86%E7%9A%84%E5%88%A4%E7%A9%BA%E5%92%8C%E5%8F%96%E5%A0%86%E7%9A%84%E9%A1%B6%E6%95%B0%E6%8D%AE" style="background-color:transparent;"><span style="color:#a2e043;"><strong>堆的判空和取堆的顶数据</strong></span></h3> 
<pre><code class="language-cpp">// 堆的判空
bool HeapEmpty(Heap* php)
{
	// 判空
	assert(php);
	
	return php-&gt;size == 0;
}

// 取堆的顶数据
HPDataTpye HeapTop(Heap* php)
{
	// 判空
	assert(php);

	return php-&gt;a[0];
}</code></pre> 
<h2><span style="color:#ff9900;"><strong>时间复杂度计算 </strong></span></h2> 
<p><span style="color:#0d0016;"><strong>以下图片是向上调整和向下调整的时间复杂度计算：</strong></span></p> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/0b/bf/6Rs11srh_o.png"></p> 
<h2 id="%E6%95%B4%E4%BD%93%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%B5%8B%E8%AF%95%EF%BC%9A%C2%A0" style="background-color:transparent;"><span style="color:#ff9900;"><strong>整体代码及测试： </strong></span></h2> 
<pre><code class="language-cpp">#pragma once
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdlib.h&gt;

// 类型定义
typedef int HPDataTpye;

typedef struct Heap
{
	// 动态数组
	HPDataTpye* a;
	// 元素个数
	int size;
	// 空间容量
	int capacity;
}Heap;


// 函数声明

// 堆的初始化
void HeapInit(Heap* php);

// 堆的销毁
void HeapDestory(Heap* php);

// 堆的插入
void HeapPush(Heap* php, HPDataTpye x);

// 堆的删除
void HeapPop(Heap* php);

// 堆的判空
bool HeapEmpty(Heap* php);

// 取堆的顶数据
HPDataTpye HeapTop(Heap* php);</code></pre> 
<pre><code class="language-cpp">#include "Heap.h"


// 堆的初始化
void HeapInit(Heap* php)
{
	// 判空
	assert(php);

	// 初始化
	php-&gt;a = NULL;
	php-&gt;size = php-&gt;capacity = 0;

}

// 堆的销毁
void HeapDestory(Heap* php)
{
	// 判空
	assert(php);

	// 释放空间
	free(php-&gt;a);
	php-&gt;a = NULL;
	php-&gt;size = php-&gt;capacity = 0;

}

// 交换
void Swap(HPDataTpye* p1, HPDataTpye* p2)
{
	HPDataTpye tmp = *p1;
	*p1 = *p2;
	*p2 = tmp;
}

// 向上调整
void AdjustUp(HPDataTpye* a, int child)
{
	// 算父亲节点
	int parent = (child - 1) / 2;

	// 循环向上排序
	while (child &gt; 0)
	{
		if (a[child] &gt; a[parent])
		{
			// 交换
			Swap(&amp;a[child], &amp;a[parent]);
			// 把父亲赋值给孩子
			child = parent;
			parent = (child - 1) / 2;
		}
		else {
			break;
		}
	}
}

// 堆的插入
void HeapPush(Heap* php, HPDataTpye x)
{
	// 判空
	assert(php);

	// 判断空间是否满
	if (php-&gt;size == php-&gt;capacity)
	{
		// 看原来的空间容量是否为0，为0分配4个空间，不为0空间*2
		int newcapacity = php-&gt;capacity == 0 ? 4 : php-&gt;capacity * 2;
		// 分配动态空间
		HPDataTpye* tmp = (HPDataTpye*)realloc(php-&gt;a, newcapacity * sizeof(HPDataTpye));
		if (NULL == tmp)
		{
			perror("malloc fail");
			return;
		}

		php-&gt;a = tmp;
		php-&gt;capacity = newcapacity;
	}

	// 插入
	php-&gt;a[php-&gt;size] = x;
	php-&gt;size++;

	// 向上调整
	AdjustUp(php-&gt;a, php-&gt;size - 1);
}

// 向下调整
void AdjustDown(HPDataTpye* a, int n, int parent)
{
	int child = parent * 2 + 1;
	
	while (child &lt; n)
	{
		if ((child + 1) &lt; n &amp;&amp; a[child + 1] &gt; a[child])
		{
			++child;
		}

		if (a[child] &gt; a[parent])
		{
			// 交换
			Swap(&amp;a[child], &amp;a[parent]);
			parent = child;
			child = parent * 2 + 1;
		}
		else {
			break;
		}
	}
}

// 堆的删除
void HeapPop(Heap* php)
{
	// 判空
	assert(php);
	assert(php-&gt;size &gt; 0);

	// 交换
	Swap(&amp;php-&gt;a[0], &amp;php-&gt;a[php-&gt;size - 1]);
	php-&gt;size--;

	// 向下调整
	AdjustDown(php-&gt;a, php-&gt;size, 0);
}


// 堆的判空
bool HeapEmpty(Heap* php)
{
	// 判空
	assert(php);
	
	return php-&gt;size == 0;
}

// 取堆的顶数据
HPDataTpye HeapTop(Heap* php)
{
	// 判空
	assert(php);
	assert(php-&gt;size &gt; 0);

	return php-&gt;a[0];
}</code></pre> 
<pre><code class="language-cpp">#include "Heap.h"

void HeapText()
{
	Heap h1;
	// 初始化
	HeapInit(&amp;h1);

	int arr[] = { 4,2,8,1,5,6,9,7};
	for (int i = 0; i &lt; sizeof(arr) / sizeof(int); i++)
	{
		HeapPush(&amp;h1, arr[i]);
	}

	int i = 0;
	while (!HeapEmpty(&amp;h1))
	{
		printf("%d ", HeapTop(&amp;h1));
		//arr[i++] = HeapTop(&amp;h1);
		HeapPop(&amp;h1);
	}
	printf("\n");

	 //计算前十最富有的人
	/*int k = 0;
	scanf_s("%d", &amp;k);
	while (k--)
	{
		printf("%d ", HeapTop(&amp;h1));
		HeapPop(&amp;h1);
	}*/


	// 销毁
	HeapDestory(&amp;h1);
}




int main()
{
	HeapText();
	return 0;
}</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<h2 id="%C2%A0"><span style="color:#ff9900;"><strong> </strong></span></h2> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7557b5c02dabc7ac1e3fac2308c8f54b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">初始Java篇（JavaSE基础语法）（8）认识String类（下）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2801a817dbe6df2465c5cb5b20a94fe1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据中台-大数据技术之一文说清如何选择Spark和Flink</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>