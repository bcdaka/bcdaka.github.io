<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java 面试题：String、StringBuffer、StringBuilder 有什么区别？ - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/2e02e2c64378603d8263e10535c1aaea/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java 面试题：String、StringBuffer、StringBuilder 有什么区别？">
  <meta property="og:description" content="几乎所有的应用开发都离不开操作字符串，理解字符串的设计和实现以及相关工具如拼接类的使用，对写出高质量代码是非常有帮助的。关于这个问题，我前面的回答是一个通常的概要性回答，至少你要知道 String 是 Immutable 的，字符串操作不当可能会产生大量临时字符串，以及线程安全方面的区别。
文章目录 1、面试问题2、问题分析3、典型回答4、问题深入5、问题拓展5.1、拓展问题：请解释 StringBuffer 是如何实现线程安全的？5.2、拓展问题：在什么情况下你会选择使用 StringBuilder 而不是 StringBuffer？5.3、拓展问题：描述一下字符串常量池（String Pool）的工作原理。它是如何影响字符串实例的？5.3.1、工作原理5.3.2、如何影响字符串实例5.3.3、示例 5.4、拓展问题：String 的 intern() 方法在性能优化中起什么作用？它是如何工作的？5.4.1、`intern()` 方法的作用5.4.2、`intern()` 方法的工作原理5.4.3、示例代码5.4.4、性能优化场景5.4.5、注意事项 5.5、拓展问题：你能解释 Java 在处理字符串拼接时如何优化性能吗？尤其是在 Java 9 以后的版本。5.5.1、Java 9 之前的优化5.5.2、Java 9 及以后的优化5.5.3、具体性能优化的优势 1、面试问题 今天的面试问题：String、StringBuffer、StringBuilder 有什么区别？
2、问题分析 这个面试题主要考察了以下几个关键点：
对 Java 字符串管理的理解：面试题首先测试你是否了解 Java 中字符串的基本概念，包括 String、StringBuffer 和 StringBuilder 的用途和基本工作原理；
不可变性和可变性的理解：通过这个问题，面试官希望看到你是否理解不可变（Immutable）和可变（Mutable）对象的区别，以及这些特性如何影响性能和线程安全；
线程安全的知识：问题中提到的 StringBuffer 和 StringBuilder 的区别，特别是在线程安全方面，考察你是否理解多线程环境下的数据安全和性能问题；
性能考虑：通过对比 String、StringBuffer 和 StringBuilder，面试官想测试你是否能够根据不同的使用场景选择最合适的工具，以优化性能。这涉及到你是否能够在实际编程中做出合理的性能权衡；
Java API 的熟悉程度：知道这三个类的具体方法和使用场景可以显示出你对 Java 标准库的熟悉程度，这对于 Java 开发者是非常基础的要求。
总体来说，这个问题不仅考察了技术细节，还考察了面试者在面对具体编程问题时的决策能力，特别是在性能优化和线程安全之间做出权衡的能力。这些都是任何希望在 Java 开发领域内成长的开发者必须掌握的关键技能。
3、典型回答 首先，String 是 Java 语言中非常基础和重要的类，它提供了构造和管理字符串的各种基本逻辑。String 对象一旦创建，其值就不能被改变，这种特性称为不可变性（Immutable）。由于它是 final 类，无法被继承，所有的属性也是 final 的。这种不可变性使得 String 对象在多线程环境中可以安全地使用，但是它也意味着像字符串拼接这样的操作会生成许多临时的中间对象，从而可能影响性能。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-30T09:41:52+08:00">
    <meta property="article:modified_time" content="2024-05-30T09:41:52+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java 面试题：String、StringBuffer、StringBuilder 有什么区别？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>几乎所有的应用开发都离不开操作字符串，理解字符串的设计和实现以及相关工具如拼接类的使用，对写出高质量代码是非常有帮助的。关于这个问题，我前面的回答是一个通常的概要性回答，至少你要知道 String 是 Immutable 的，字符串操作不当可能会产生大量临时字符串，以及线程安全方面的区别。</p> 
</blockquote> 
<hr> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><ul><li><a href="#1_8" rel="nofollow">1、面试问题</a></li><li><a href="#2_14" rel="nofollow">2、问题分析</a></li><li><a href="#3_32" rel="nofollow">3、典型回答</a></li><li><a href="#4_44" rel="nofollow">4、问题深入</a></li><li><a href="#5_54" rel="nofollow">5、问题拓展</a></li><li><ul><li><a href="#51_StringBuffer__56" rel="nofollow">5.1、拓展问题：请解释 StringBuffer 是如何实现线程安全的？</a></li><li><a href="#52_StringBuilder__StringBuffer_94" rel="nofollow">5.2、拓展问题：在什么情况下你会选择使用 StringBuilder 而不是 StringBuffer？</a></li><li><a href="#53String_Pool_110" rel="nofollow">5.3、拓展问题：描述一下字符串常量池（String Pool）的工作原理。它是如何影响字符串实例的？</a></li><li><ul><li><a href="#531_114" rel="nofollow">5.3.1、工作原理</a></li><li><a href="#532_126" rel="nofollow">5.3.2、如何影响字符串实例</a></li><li><a href="#533_148" rel="nofollow">5.3.3、示例</a></li></ul> 
     </li><li><a href="#54String__intern__173" rel="nofollow">5.4、拓展问题：String 的 intern() 方法在性能优化中起什么作用？它是如何工作的？</a></li><li><ul><li><a href="#541intern__177" rel="nofollow">5.4.1、`intern()` 方法的作用</a></li><li><a href="#542intern__183" rel="nofollow">5.4.2、`intern()` 方法的工作原理</a></li><li><a href="#543_191" rel="nofollow">5.4.3、示例代码</a></li><li><a href="#544_219" rel="nofollow">5.4.4、性能优化场景</a></li><li><a href="#545_225" rel="nofollow">5.4.5、注意事项</a></li></ul> 
     </li><li><a href="#55_Java__Java_9__233" rel="nofollow">5.5、拓展问题：你能解释 Java 在处理字符串拼接时如何优化性能吗？尤其是在 Java 9 以后的版本。</a></li><li><ul><li><a href="#551Java_9__237" rel="nofollow">5.5.1、Java 9 之前的优化</a></li><li><a href="#552Java_9__270" rel="nofollow">5.5.2、Java 9 及以后的优化</a></li><li><a href="#553_282" rel="nofollow">5.5.3、具体性能优化的优势</a></li></ul> 
    </li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h4><a id="1_8"></a>1、面试问题</h4> 
<p>今天的面试问题：String、StringBuffer、StringBuilder 有什么区别？</p> 
<hr> 
<h4><a id="2_14"></a>2、问题分析</h4> 
<p>这个面试题主要考察了以下几个关键点：</p> 
<ol><li> <p>对 Java 字符串管理的理解：面试题首先测试你是否了解 Java 中字符串的基本概念，包括 String、StringBuffer 和 StringBuilder 的用途和基本工作原理；</p> </li><li> <p>不可变性和可变性的理解：通过这个问题，面试官希望看到你是否理解不可变（Immutable）和可变（Mutable）对象的区别，以及这些特性如何影响性能和线程安全；</p> </li><li> <p>线程安全的知识：问题中提到的 StringBuffer 和 StringBuilder 的区别，特别是在线程安全方面，考察你是否理解多线程环境下的数据安全和性能问题；</p> </li><li> <p>性能考虑：通过对比 String、StringBuffer 和 StringBuilder，面试官想测试你是否能够根据不同的使用场景选择最合适的工具，以优化性能。这涉及到你是否能够在实际编程中做出合理的性能权衡；</p> </li><li> <p>Java API 的熟悉程度：知道这三个类的具体方法和使用场景可以显示出你对 Java 标准库的熟悉程度，这对于 Java 开发者是非常基础的要求。</p> </li></ol> 
<p>总体来说，这个问题不仅考察了技术细节，还考察了面试者在面对具体编程问题时的决策能力，特别是在性能优化和线程安全之间做出权衡的能力。这些都是任何希望在 Java 开发领域内成长的开发者必须掌握的关键技能。</p> 
<hr> 
<h4><a id="3_32"></a>3、典型回答</h4> 
<p>首先，String 是 Java 语言中非常基础和重要的类，它提供了构造和管理字符串的各种基本逻辑。String 对象一旦创建，其值就不能被改变，这种特性称为不可变性（Immutable）。由于它是 final 类，无法被继承，所有的属性也是 final 的。这种不可变性使得 String 对象在多线程环境中可以安全地使用，但是它也意味着像字符串拼接这样的操作会生成许多临时的中间对象，从而可能影响性能。</p> 
<p>其次，为了优化性能问题，尤其是在字符串频繁修改的场景下，Java 提供了 StringBuffer 类。StringBuffer 允许字符串的可变性，并且支持诸如 append 和 insert 等方法来修改字符串。最关键的是，StringBuffer 是线程安全的，它内部通过同步机制来保证多线程操作的一致性。但这也意味着每次操作可能涉及到锁机制，带来额外的性能开销。</p> 
<p>最后，考虑到线程安全带来的性能代价，在 Java 1.5 中引入了 StringBuilder 类。StringBuilder 在功能上与 StringBuffer 类似，提供了相同的接口，但是它不是线程安全的。这种设计选择减少了线程同步带来的开销，使得 StringBuilder 成为在单线程环境中进行字符串操作的首选，尤其是在性能敏感的应用场景中。</p> 
<p>总的来说，String、StringBuffer 和 StringBuilder 三者主要在不可变性和线程安全性方面有所区别，String 不可变，StringBuffer 可变，安全，但性能开销相对高，StringBuilder 可变，不安全，新性能开销相对低。至于选择使用哪一个取决于具体的应用场景和性能需求。</p> 
<hr> 
<h4><a id="4_44"></a>4、问题深入</h4> 
<p>如果继续深入，面试官可以从各种不同的角度考察，比如可以：</p> 
<ul><li>基本的线程安全设计与实现，比如：①、请解释 StringBuffer 是如何实现线程安全的？②、在哪些情况下应优先考虑使用 StringBuffer 而非 StringBuilder ？；</li><li>JVM 对象缓存机制的理解，比如：①、描述一下字符串常量池（String Pool）的工作原理。它是如何影响字符串实例的？②、String 的 intern() 方法在性能优化中起什么作用？它是如何工作的？</li><li>JVM 优化 Java 代码的技巧，比如：你能解释 Java 在处理字符串拼接时如何优化性能吗？尤其是在 Java 9 以后的版本。</li></ul> 
<hr> 
<h4><a id="5_54"></a>5、问题拓展</h4> 
<h5><a id="51_StringBuffer__56"></a>5.1、拓展问题：请解释 StringBuffer 是如何实现线程安全的？</h5> 
<p><code>StringBuffer</code> 通过在其方法上使用同步机制来实现线程安全。这意味着每个 <code>StringBuffer</code> 方法在执行时都会自动获取相应的锁，从而确保在多线程环境中对同一个 <code>StringBuffer</code> 实例进行操作时，不会发生数据竞争或数据不一致的问题。</p> 
<p>以下是具体实现线程安全的几个方面：</p> 
<p>方法级同步：</p> 
<ul><li><code>StringBuffer</code> 的大部分方法，比如 <code>append()</code>、<code>insert()</code>、<code>delete()</code> 等，都使用了 <code>synchronized</code> 关键字进行方法级别的同步。这确保了同一时刻只有一个线程可以执行这些方法，从而保证了线程安全。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token class-name">StringBuffer</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// Implementation details</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>对象锁机制：</p> 
<ul><li><code>StringBuffer</code> 的同步机制是基于对象锁的。当一个线程调用一个同步方法时，它会获取该 <code>StringBuffer</code> 实例的锁，其他线程在尝试调用任何同步方法时都必须等待，直到锁被释放。这种机制有效防止了并发修改导致的数据不一致问题。</li></ul> 
<p>性能影响：</p> 
<ul><li>虽然这种同步机制确保了线程安全，但也带来了性能开销。每次方法调用都需要获取和释放锁，这在高并发环境下可能会导致线程阻塞和性能下降。</li></ul> 
<p>例如，以下是 <code>StringBuffer</code> 中一个 <code>append</code> 方法的实现，它通过 <code>synchronized</code> 关键字确保了方法的线程安全：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token class-name">StringBuffer</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    toStringCache <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在这个方法中，<code>synchronized</code> 确保了在方法执行期间，其他线程无法同时执行任何其他同步方法，从而保证了字符串拼接操作的线程安全性。</p> 
<p>通过这种方法级同步和对象锁机制，<code>StringBuffer</code> 实现了线程安全，确保在多线程环境中对字符串的修改是安全的。</p> 
<h5><a id="52_StringBuilder__StringBuffer_94"></a>5.2、拓展问题：在什么情况下你会选择使用 StringBuilder 而不是 StringBuffer？</h5> 
<p>选择使用 <code>StringBuilder</code> 而不是 <code>StringBuffer</code> 主要考虑以下几个方面：</p> 
<ol><li> <p>单线程环境：当你确定字符串操作发生在单线程环境中时，使用 <code>StringBuilder</code> 是更佳的选择。因为 <code>StringBuilder</code> 没有实现同步措施，它避免了 <code>StringBuffer</code> 因线程安全而带来的性能开销。</p> </li><li> <p>性能敏感的应用：在需要高性能的情况下，特别是处理大量字符串拼接或修改的场景，<code>StringBuilder</code> 通常提供比 <code>StringBuffer</code> 更好的性能。因为 <code>StringBuilder</code> 不进行线程同步，它的操作通常比 <code>StringBuffer</code> 更快。</p> </li><li> <p>资源优化：在资源受限的应用中（如移动设备或嵌入式系统），优化每一点性能都很重要。在这些情况下，优先选择 <code>StringBuilder</code> 可以减少因线程同步而产生的额外资源消耗。</p> </li><li> <p>短暂的字符串操作：对于生命周期较短的字符串操作，如在一个方法内部进行字符串构建和操作，使用 <code>StringBuilder</code> 可以更快地完成任务，同时避免了线程安全的额外开销。</p> </li><li> <p>兼容性和维护性：如果你的代码库已经在其他部分广泛使用了 <code>StringBuilder</code>，为了保持一致性和减少学习成本，继续使用 <code>StringBuilder</code> 是合适的。</p> </li></ol> 
<p>总之，除非有特定的线程安全需求，否则在大多数情况下，<code>StringBuilder</code> 是处理字符串的首选，因为它提供了较好的性能和资源使用效率。</p> 
<h5><a id="53String_Pool_110"></a>5.3、拓展问题：描述一下字符串常量池（String Pool）的工作原理。它是如何影响字符串实例的？</h5> 
<p>字符串常量池（String Pool）是 Java 中用于存储字符串字面值的一种特殊内存区域。它的主要目的是为了节省内存和提高性能。以下是字符串常量池的工作原理和它如何影响字符串实例的具体描述：</p> 
<h6><a id="531_114"></a>5.3.1、工作原理</h6> 
<ol><li> <p>字符串字面值的存储：</p> 
  <ul><li>当一个字符串字面值被创建时，如 <code>String str = "Hello";</code>，JVM 会先检查字符串常量池中是否已经存在一个值为 <code>"Hello"</code> 的字符串。</li><li>如果常量池中已经存在这个字符串，JVM 不会创建新的字符串对象，而是直接返回常量池中的引用。这意味着相同的字符串字面值在内存中只会存储一次。</li></ul> </li><li> <p>字符串的 <code>intern()</code> 方法：</p> 
  <ul><li>可以显式地将一个字符串添加到常量池中，使用 <code>intern()</code> 方法。例如：<code>String str = new String("Hello").intern();</code></li><li><code>intern()</code> 方法会检查常量池中是否存在一个值等于该字符串对象的字符串。如果存在，则返回池中的字符串引用；如果不存在，则将该字符串添加到常量池中，并返回该字符串的引用。</li></ul> </li><li> <p>编译时的优化：编译器会自动将所有字符串字面值添加到常量池中。这意味着在编译时，字符串字面值就已经在常量池中，运行时直接使用。</p> </li></ol> 
<h6><a id="532_126"></a>5.3.2、如何影响字符串实例</h6> 
<ol><li> <p>内存使用效率：由于常量池中相同的字符串字面值只存储一次，因此它减少了内存的使用。这在应用程序中频繁使用相同字符串时尤其有效。</p> </li><li> <p>字符串比较的优化：通过使用常量池，字符串字面值可以用 <code>==</code> 进行比较，而不是 <code>equals()</code>。因为常量池中的相同字符串字面值是同一个对象，比较它们的引用就足够了。例如：</p> <pre><code class="prism language-java"><span class="token class-name">String</span> str1 <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> str2 <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 true</span>
</code></pre> </li><li> <p>性能提升：由于常量池的存在，JVM 在处理字符串字面值时不需要频繁地创建新对象，从而提高了性能。这对于需要大量字符串操作的应用程序尤其重要。</p> </li><li> <p>避免内存浪费：如果不使用常量池，每次创建一个相同的字符串字面值都会产生一个新的对象，导致内存浪费。例如：</p> <pre><code class="prism language-java"><span class="token class-name">String</span> str1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> str2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 false</span>
</code></pre> </li></ol> 
<h6><a id="533_148"></a>5.3.3、示例</h6> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StringPoolExample</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">String</span> str1 <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> str2 <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span>
        
        <span class="token comment">// str1 和 str2 都指向常量池中的同一个字符串</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 true</span>
        
        <span class="token class-name">String</span> str3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> str4 <span class="token operator">=</span> str3<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// str3 是一个新的字符串对象，str4 指向常量池中的字符串</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str3 <span class="token operator">==</span> str4<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 false</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str4<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 true</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在这个例子中，<code>str1</code> 和 <code>str2</code> 都指向常量池中的同一个字符串，而 <code>str3</code> 是通过 <code>new</code> 关键字创建的新对象，它不在常量池中。通过调用 <code>str3.intern()</code>，<code>str4</code> 指向常量池中的字符串。因此，<code>str1 == str4</code> 输出 <code>true</code>，而 <code>str3 == str4</code> 输出 <code>false</code>。</p> 
<p>通过理解字符串常量池的工作原理，开发者可以更有效地管理和优化 Java 应用程序中的字符串操作。</p> 
<h5><a id="54String__intern__173"></a>5.4、拓展问题：String 的 intern() 方法在性能优化中起什么作用？它是如何工作的？</h5> 
<p><code>String</code> 的 <code>intern()</code> 方法在性能优化中起着重要作用，尤其是在涉及大量重复字符串的应用中。以下是 <code>intern()</code> 方法的作用及其工作原理：</p> 
<h6><a id="541intern__177"></a>5.4.1、<code>intern()</code> 方法的作用</h6> 
<ol><li> <p>内存节省：<code>intern()</code> 方法通过确保相同内容的字符串只存储一次来减少内存使用。当一个字符串被 <code>intern()</code> 方法调用时，JVM 会检查字符串常量池中是否已经存在具有相同内容的字符串。如果存在，它将返回常量池中的字符串引用；如果不存在，它将把该字符串添加到常量池中，并返回这个新的引用；</p> </li><li> <p>加快字符串比较：使用 <code>intern()</code> 方法可以使得字符串比较操作更高效。因为字符串常量池中的相同内容字符串共享相同的引用，可以通过 <code>==</code> 进行比较，而不需要使用 <code>equals()</code> 方法。这在频繁比较字符串的场景下可以显著提高性能。</p> </li></ol> 
<h6><a id="542intern__183"></a>5.4.2、<code>intern()</code> 方法的工作原理</h6> 
<ol><li> <p>检查常量池：当调用 <code>intern()</code> 方法时，JVM 首先检查字符串常量池中是否已经存在一个与当前字符串内容相同的字符串。</p> </li><li> <p><strong>返回引用</strong>：</p> 
  <ul><li>如果常量池中存在相同内容的字符串，<code>intern()</code> 方法返回常量池中该字符串的引用；</li><li>如果常量池中不存在相同内容的字符串，JVM 将该字符串添加到常量池中，并返回这个新的引用。</li></ul> </li></ol> 
<h6><a id="543_191"></a>5.4.3、示例代码</h6> 
<p>以下是一个示例代码，演示了 <code>intern()</code> 方法的使用及其效果：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StringInternExample</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">String</span> str1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> str2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// str1 和 str2 是两个不同的对象</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 false</span>

        <span class="token comment">// 调用 intern() 方法，将 str1 的引用放入常量池</span>
        <span class="token class-name">String</span> str3 <span class="token operator">=</span> str1<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 调用 intern() 方法，将 str2 的引用放入常量池</span>
        <span class="token class-name">String</span> str4 <span class="token operator">=</span> str2<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// str3 和 str4 都指向常量池中的同一个字符串</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str3 <span class="token operator">==</span> str4<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 true</span>

        <span class="token comment">// str3 和 "Hello" 字面值指向同一个对象</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str3 <span class="token operator">==</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 true</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h6><a id="544_219"></a>5.4.4、性能优化场景</h6> 
<ol><li> <p>大量重复字符串的应用：在处理大量重复字符串的应用中，使用 <code>intern()</code> 方法可以显著减少内存消耗。例如，在大型日志处理系统或文本处理系统中，经常会遇到相同的字符串内容，这时使用 <code>intern()</code> 方法可以节省大量内存。</p> </li><li> <p>高效字符串比较：在需要频繁比较字符串的场景中，通过 <code>intern()</code> 方法确保相同内容的字符串引用相同，可以通过 <code>==</code> 进行快速比较，而不是 <code>equals()</code> 方法。这对于性能要求高的应用来说是一个重要的优化点。</p> </li></ol> 
<h6><a id="545_225"></a>5.4.5、注意事项</h6> 
<ol><li> <p>过度使用：虽然 <code>intern()</code> 方法可以优化内存和性能，但过度使用可能会导致字符串常量池变得非常大，从而引发内存问题。因此，应根据具体情况合理使用 <code>intern()</code> 方法；</p> </li><li> <p>JVM 实现差异：不同的 JVM 实现对字符串常量池的管理可能有所不同，因此在使用 <code>intern()</code> 方法进行性能优化时，需要考虑具体的 JVM 实现和版本。</p> </li></ol> 
<p>通过合理使用 <code>intern()</code> 方法，开发者可以在特定场景下显著优化 Java 应用程序的内存使用和性能。</p> 
<h5><a id="55_Java__Java_9__233"></a>5.5、拓展问题：你能解释 Java 在处理字符串拼接时如何优化性能吗？尤其是在 Java 9 以后的版本。</h5> 
<p>Java 在处理字符串拼接时，为了优化性能，采取了一些有效的策略，特别是在 Java 9 以后，引入了更多优化。以下是这些优化的详细解释：</p> 
<h6><a id="551Java_9__237"></a>5.5.1、Java 9 之前的优化</h6> 
<ol><li> <p>编译期优化：在 Java 9 之前，编译器对字符串拼接做了优化。对于简单的字符串常量拼接，编译器会在编译期进行优化，将其直接替换为一个单独的字符串常量。例如：</p> <pre><code class="prism language-java"><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">"Hello, "</span> <span class="token operator">+</span> <span class="token string">"world!"</span><span class="token punctuation">;</span>
</code></pre> <p>这行代码在编译期会被优化成：</p> <pre><code class="prism language-java"><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">"Hello, world!"</span><span class="token punctuation">;</span>
</code></pre> </li><li> <p>使用 <code>StringBuilder</code> 进行拼接：对于包含变量的字符串拼接，Java 编译器会自动将拼接操作转换为使用 <code>StringBuilder</code> 进行的拼接操作。例如：</p> <pre><code class="prism language-java"><span class="token class-name">String</span> str1 <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> str2 <span class="token operator">=</span> <span class="token string">"world"</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> result <span class="token operator">=</span> str1 <span class="token operator">+</span> <span class="token string">", "</span> <span class="token operator">+</span> str2 <span class="token operator">+</span> <span class="token string">"!"</span><span class="token punctuation">;</span>
</code></pre> <p>在编译后的字节码中，上述代码会被转换为：</p> <pre><code class="prism language-java"><span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span>
sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">", "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span>
sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> result <span class="token operator">=</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> </li></ol> 
<h6><a id="552Java_9__270"></a>5.5.2、Java 9 及以后的优化</h6> 
<p>在 Java 9 以后，JVM 引入了基于 <code>invokedynamic</code> 指令的字符串拼接优化，进一步提升了性能。</p> 
<ol><li> <p><strong><code>invokedynamic</code> 指令</strong>：Java 9 引入了 <code>invokedynamic</code> 指令来优化字符串拼接。编译器在处理字符串拼接时，会生成一个调用 <code>invokedynamic</code> 指令的字节码，而不是直接使用 <code>StringBuilder</code>。<code>invokedynamic</code> 指令在运行时决定最佳的拼接策略。</p> </li><li> <p><code>java.lang.invoke.StringConcatFactory</code>：<code>StringConcatFactory</code> 是一个用来处理 <code>invokedynamic</code> 指令的工厂类。它会根据上下文动态选择最佳的拼接策略。常用的策略包括：</p> 
  <ul><li><code>StringBuilder</code> 拼接：适用于大多数拼接场景。</li><li><code>StringConcatFactory</code> 的 <code>MethodHandle</code> 拼接：适用于某些复杂场景，进一步优化性能。</li></ul> </li><li> <p>性能提升：动态选择拼接策略使得 JVM 能够在运行时选择最优的拼接方法，从而提升性能。例如，对于小字符串或常量拼接，可能会选择更轻量级的方法，而对于复杂的拼接则可能继续使用 <code>StringBuilder</code>。</p> </li></ol> 
<h6><a id="553_282"></a>5.5.3、具体性能优化的优势</h6> 
<ol><li> <p>减少中间对象：通过动态拼接策略，减少了中间对象的创建，降低了内存使用和 GC 压力。</p> </li><li> <p>运行时优化：<code>invokedynamic</code> 指令允许 JVM 在运行时根据实际使用情况选择最佳策略，提高了代码的执行效率。</p> </li><li> <p>更高的灵活性：使用 <code>invokedynamic</code> 提供了更高的灵活性，允许未来的 JVM 优化进一步提升性能，而不需要改变应用代码。</p> </li></ol> 
<p>总的来说，Java 在处理字符串拼接时，通过编译期和运行时的多重优化策略，不断提升性能。特别是在 Java 9 以后，引入了 <code>invokedynamic</code> 指令和 <code>StringConcatFactory</code>，使得字符串拼接更加高效和灵活。这些优化使得 Java 开发者在处理字符串操作时，可以更加专注于业务逻辑，而无需担心底层性能问题。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/75aec0e019b18e80914a27cc65c515de/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用sqoop将mysql数据导入到hive中</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/14028cffe261689e6f0377cd048e3b15/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AI | LLaMA-Factory 一个好用的微调工具</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>