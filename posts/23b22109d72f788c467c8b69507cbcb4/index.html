<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【JAVAEE学习】探究Java中多线程的使用和重点及考点 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/23b22109d72f788c467c8b69507cbcb4/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【JAVAEE学习】探究Java中多线程的使用和重点及考点">
  <meta property="og:description" content="˃͈꒵˂͈꒱ write in front ꒰˃͈꒵˂͈꒱
ʕ̯•͡˔•̯᷅ʔ大家好，我是xiaoxie.希望你看完之后,有不足之处请多多谅解，让我们一起共同进步૮₍❀ᴗ͈ . ᴗ͈ აxiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客
本文由xiaoxieʕ̯•͡˔•̯᷅ʔ 原创 CSDN 如需转载还请通知˶⍤⃝˶​
个人主页：xiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客
系列专栏:xiaoxie的JAVAEE学习系列专栏——CSDN博客●&#39;ᴗ&#39;σσணღ
我的目标:&#34;团团等我💪( ◡̀_◡́ ҂)&#34; ( ⸝⸝⸝›ᴥ‹⸝⸝⸝ )欢迎各位→点赞👍 &#43; 收藏⭐️ &#43; 留言📝​&#43;关注（互三必回）!
目录
​编辑一.线程
1.什么是线程
2.进程和线程的区别
1.在这里先解释一下最基础的定义
2.举个我们日常生活中的小例子
3.线程和进程的区别以及线程相比于进程的优点:(这个面试中也算是比较高频的问题)
二.编写多线程代码
1.定义线程类
1.说明
2.通过实现Runnadle接口创建线程
3.针对方法1使用匿名内部类
4.针对方法2使用匿名内部类
5.使用 lambda表达式
三.Thread类
1.构造方法
2.其他的方法
1.获取Id getid()
​编辑 2.获取名称 getName()
3.获取状态 getState()
4.是否为后台线程 isDaemon()
​编辑 5.是否存活 isAlive()
6.是否被中断 isInterrupted()
一.线程 1.什么是线程 线程（Thread）是程序中执行的最小单元，是操作系统能线程是计算机科学中的基本概念，指的是在同一进程中执行的单一执行流。线程是操作系统能够进行运算调度的最小单位。在多线程编程中，多个线程可以同时执行，共享进程的资源，但每个线程有自己的执行流程和栈空间。线程的引入可以提高程序的并发性和响应性，允许程序在同一时间处理多个任务。
在计算机系统中，线程是由操作系统调度和管理的，可以实现不同线程之间的切换和协同工作。线程之间可以共享进程的资源，如内存空间、文件描述符等，但也需要注意线程之间的同步和互斥，以避免竞态条件和数据不一致问题。
在编程中，线程可以用来实现并发编程，允许程序同时执行多个任务，提高程序的性能和效率。常见的多线程编程模型包括线程池、生产者-消费者模型等
2.进程和线程的区别 这个先解释一下线程和进程的区别,这个两个词虽然看起来相差不大,但意思却相差很大,当对于初学者来说还是比较容易混淆的
1.在这里先解释一下最基础的定义 进程：在计算机操作系统中，进程是对运行中程序的一个抽象，它是系统进行资源分配和调度的基本单位。每个进程都有自己独立的地址空间，包含了程序代码、数据、打开的文件描述符等资源。当一个程序开始执行时，操作系统会为其创建一个新的进程，使得程序可以占用系统资源并独立运行。
线程：线程是进程内的一个执行路径，也是CPU调度的最小单位。一个进程中可以有一个或多个线程(每个进程都有最基本的主线程)，这些线程共享进程的相同地址空间（包括代码、全局变量等资源）。每个线程都维护有自己的程序计数器、寄存器集合和栈，这样它们就可以在进程的上下文中并发执行各自的任务。相较于进程，线程之间的切换成本更低，而且由于资源共享的特性，线程间的通信和同步更为简便。
2.举个我们日常生活中的小例子 用日常生活的例子来解释进程和线程的区别：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-29T13:57:29+08:00">
    <meta property="article:modified_time" content="2024-03-29T13:57:29+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【JAVAEE学习】探究Java中多线程的使用和重点及考点</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>˃͈꒵˂͈꒱ write in front ꒰˃͈꒵˂͈꒱<br> ʕ̯•͡˔•̯᷅ʔ大家好，我是xiaoxie.希望你看完之后,有不足之处请多多谅解，让我们一起共同进步૮₍❀ᴗ͈ . ᴗ͈ ა<a href="https://blog.csdn.net/xiaoxie8023?spm=1000.2115.3001.5343" title="xiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客">xiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客</a><br> 本文由xiaoxieʕ̯•͡˔•̯᷅ʔ 原创 CSDN 如需转载还请通知˶⍤⃝˶<a href="https://blog.csdn.net/xiaoxie8023/category_12621168.html" title="​">​</a><br><a href="https://so.csdn.net/so/search?q=%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5&amp;spm=1001.2101.3001.7020" title="个人主页">个人主页</a>：<a href="https://blog.csdn.net/xiaoxie8023/article/details/134417887?spm=1001.2014.3001.5501" title="xiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客">xiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客</a></p> 
 <p>系列专栏:<a href="https://blog.csdn.net/xiaoxie8023/category_12621168.html" title="xiaoxie的JAVAEE学习系列专栏——CSDN博客●'ᴗ'σσணღ">xiaoxie的JAVAEE学习系列专栏——CSDN博客●'ᴗ'σσணღ</a><br><span style="color:#fe2c24;"><strong>我的目标:"团团等我💪( ◡̀_◡́ ҂)" </strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>( ⸝⸝⸝›ᴥ‹⸝⸝⸝ )欢迎各位→点赞👍 + 收藏⭐️ + 留言📝​+关注（互三必回）!</strong></span></p> 
</blockquote> 
<p></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%91%E4%B8%80.%E7%BA%BF%E7%A8%8B-toc" style="margin-left:0px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%91%E4%B8%80.%E7%BA%BF%E7%A8%8B" rel="nofollow">​编辑一.线程</a></p> 
<p id="%C2%A0%201.%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B-toc" style="margin-left:40px;"><a href="#%C2%A0%201.%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B" rel="nofollow">  1.什么是线程</a></p> 
<p id="2.%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#2.%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">2.进程和线程的区别</a></p> 
<p id="1.%E5%9C%A8%E8%BF%99%E9%87%8C%E5%85%88%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E6%9C%80%E5%9F%BA%E7%A1%80%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:80px;"><a href="#1.%E5%9C%A8%E8%BF%99%E9%87%8C%E5%85%88%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E6%9C%80%E5%9F%BA%E7%A1%80%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">1.在这里先解释一下最基础的定义</a></p> 
<p id="2.%E4%B8%BE%E4%B8%AA%E6%88%91%E4%BB%AC%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E5%B0%8F%E4%BE%8B%E5%AD%90-toc" style="margin-left:80px;"><a href="#2.%E4%B8%BE%E4%B8%AA%E6%88%91%E4%BB%AC%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E5%B0%8F%E4%BE%8B%E5%AD%90" rel="nofollow">2.举个我们日常生活中的小例子</a></p> 
<p id="3.%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E6%AF%94%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9%3A(%E8%BF%99%E4%B8%AA%E9%9D%A2%E8%AF%95%E4%B8%AD%E4%B9%9F%E7%AE%97%E6%98%AF%E6%AF%94%E8%BE%83%E9%AB%98%E9%A2%91%E7%9A%84%E9%97%AE%E9%A2%98)-toc" style="margin-left:80px;"><a href="#3.%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E6%AF%94%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9%3A%28%E8%BF%99%E4%B8%AA%E9%9D%A2%E8%AF%95%E4%B8%AD%E4%B9%9F%E7%AE%97%E6%98%AF%E6%AF%94%E8%BE%83%E9%AB%98%E9%A2%91%E7%9A%84%E9%97%AE%E9%A2%98%29" rel="nofollow">3.线程和进程的区别以及线程相比于进程的优点:(这个面试中也算是比较高频的问题)</a></p> 
<p id="%E4%BA%8C.%E7%BC%96%E5%86%99%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BB%A3%E7%A0%81-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.%E7%BC%96%E5%86%99%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BB%A3%E7%A0%81" rel="nofollow">二.编写多线程代码</a></p> 
<p id="1.%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E7%B1%BB-toc" style="margin-left:40px;"><a href="#1.%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E7%B1%BB" rel="nofollow">1.定义线程类</a></p> 
<p id="1.%E8%AF%B4%E6%98%8E-toc" style="margin-left:80px;"><a href="#1.%E8%AF%B4%E6%98%8E" rel="nofollow">1.说明</a></p> 
<p id="2.%E9%80%9A%E8%BF%87%E5%AE%9E%E7%8E%B0Runnadle%E6%8E%A5%E5%8F%A3%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B-toc" style="margin-left:40px;"><a href="#2.%E9%80%9A%E8%BF%87%E5%AE%9E%E7%8E%B0Runnadle%E6%8E%A5%E5%8F%A3%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B" rel="nofollow">2.通过实现Runnadle接口创建线程</a></p> 
<p id="3.%E9%92%88%E5%AF%B9%E6%96%B9%E6%B3%951%E4%BD%BF%E7%94%A8%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB-toc" style="margin-left:40px;"><a href="#3.%E9%92%88%E5%AF%B9%E6%96%B9%E6%B3%951%E4%BD%BF%E7%94%A8%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB" rel="nofollow">3.针对方法1使用匿名内部类</a></p> 
<p id="%C2%A04.%E9%92%88%E5%AF%B9%E6%96%B9%E6%B3%952%E4%BD%BF%E7%94%A8%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB-toc" style="margin-left:40px;"><a href="#%C2%A04.%E9%92%88%E5%AF%B9%E6%96%B9%E6%B3%952%E4%BD%BF%E7%94%A8%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB" rel="nofollow"> 4.针对方法2使用匿名内部类</a></p> 
<p id="5.%E4%BD%BF%E7%94%A8%20lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F-toc" style="margin-left:40px;"><a href="#5.%E4%BD%BF%E7%94%A8%20lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F" rel="nofollow">5.使用 lambda表达式</a></p> 
<p id="%E4%B8%89.Thread%E7%B1%BB-toc" style="margin-left:0px;"><a href="#%E4%B8%89.Thread%E7%B1%BB" rel="nofollow">三.Thread类</a></p> 
<p id="1.%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#1.%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95" rel="nofollow">1.构造方法</a></p> 
<p id="2.%E5%85%B6%E4%BB%96%E7%9A%84%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#2.%E5%85%B6%E4%BB%96%E7%9A%84%E6%96%B9%E6%B3%95" rel="nofollow">2.其他的方法</a></p> 
<p id="1.%E8%8E%B7%E5%8F%96Id%20getid()-toc" style="margin-left:80px;"><a href="#1.%E8%8E%B7%E5%8F%96Id%20getid%28%29" rel="nofollow">1.获取Id getid()</a></p> 
<p id="%C2%A0%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0%C2%A02.%E8%8E%B7%E5%8F%96%E5%90%8D%E7%A7%B0%20getName()-toc" style="margin-left:80px;"><a href="#%C2%A0%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0%C2%A02.%E8%8E%B7%E5%8F%96%E5%90%8D%E7%A7%B0%20getName%28%29" rel="nofollow"> ​编辑  2.获取名称 getName()</a></p> 
<p id="3.%E8%8E%B7%E5%8F%96%E7%8A%B6%E6%80%81%20getState()-toc" style="margin-left:80px;"><a href="#3.%E8%8E%B7%E5%8F%96%E7%8A%B6%E6%80%81%20getState%28%29" rel="nofollow">3.获取状态 getState()</a></p> 
<p id="4.%E6%98%AF%E5%90%A6%E4%B8%BA%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B%20isDaemon()-toc" style="margin-left:80px;"><a href="#4.%E6%98%AF%E5%90%A6%E4%B8%BA%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B%20isDaemon%28%29" rel="nofollow">4.是否为后台线程 isDaemon()</a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%91%C2%A05.%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB%20isAlive()-toc" style="margin-left:80px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%91%C2%A05.%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB%20isAlive%28%29" rel="nofollow">​编辑 5.是否存活 isAlive()</a></p> 
<p id="6.%E6%98%AF%E5%90%A6%E8%A2%AB%E4%B8%AD%E6%96%AD%20isInterrupted()-toc" style="margin-left:80px;"><a href="#6.%E6%98%AF%E5%90%A6%E8%A2%AB%E4%B8%AD%E6%96%AD%20isInterrupted%28%29" rel="nofollow">6.是否被中断 isInterrupted()</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E2%80%8B%E7%BC%96%E8%BE%91%E4%B8%80.%E7%BA%BF%E7%A8%8B"><img alt="" height="1200" src="https://images2.imgbox.com/76/40/9gtciQPC_o.png" width="1200">一.线程</h2> 
<h3 id="%C2%A0%201.%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B">  1.什么是线程</h3> 
<p><span style="color:#fe2c24;"><strong>线程（Thread）</strong></span>是程序中执行的最小单元，是操作系统能线程是计算机科学中的基本概念，指的是在同一进程中执行的单一执行流。线程是操作系统能够进行运算调度的最小单位。在<strong><span style="color:#fe2c24;">多线程编程</span></strong>中，多个线程可以同时执行，共享进程的资源，但每个线程有自己的执行流程和栈空间。线程的引入可以提高程序的并发性和响应性，允许程序在同一时间处理多个任务。</p> 
<p>在计算机系统中，线程是由<strong><span style="color:#fe2c24;">操作系统调度和管理</span></strong>的，可以实现不同线程之间的切换和协同工作。线程之间可以共享进程的资源，如内存空间、文件描述符等，但也需要注意线程之间的同步和互斥，以避免竞态条件和数据不一致问题。</p> 
<p>在编程中，线程可以用来实现并发编程，允许程序同时执行多个任务，提高程序的性能和效率。常见的多线程编程模型包括线程池、生产者-消费者模型等</p> 
<h3 id="2.%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB">2.进程和线程的区别</h3> 
<p><span style="color:#fe2c24;"><strong>这个先解释一下线程和进程的区别,这个两个词虽然看起来相差不大,但意思却相差很大,当对于初学者来说还是比较容易混淆的</strong></span></p> 
<h4 id="1.%E5%9C%A8%E8%BF%99%E9%87%8C%E5%85%88%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E6%9C%80%E5%9F%BA%E7%A1%80%E7%9A%84%E5%AE%9A%E4%B9%89"><strong>1.在这里先解释一下最基础的定义</strong></h4> 
<p><strong>    进程</strong>：在计算机操作系统中，进程是对运行中程序的一个抽象，它是<span style="color:#fe2c24;"><strong>系统进行资源分配和调度的基本单位</strong></span>。每个进程都有<span style="color:#fe2c24;"><strong>自己独立的地址空间</strong></span>，包含了程序代码、数据、打开的文件描述符等资源。当一个<span style="color:#fe2c24;"><strong>程序开始执行</strong></span>时，操作系统会为其创建一个新的进程，使得<span style="color:#fe2c24;"><strong>程序可以占用系统资源并独立运行</strong></span>。</p> 
<p><strong>     线程</strong>：线程是<span style="color:#fe2c24;"><strong>进程内的一个执行路径</strong></span>，也是<span style="color:#fe2c24;"><strong>CPU调度的最小单位</strong></span>。<span style="color:#fe2c24;"><strong>一个进程中可以有一个或多个线程(每个进程都有最基本的主线程)</strong></span>，这些线程共<span style="color:#fe2c24;"><strong>享进程的相同地址空间</strong></span>（包括代码、全局变量等资源）。每个线程都维护有自己的程序计数器、寄存器集合和栈，这样它们就可以在进程的上下文中并发执行各自的任务。相较于进程，线程之间的切换成本更低，而且由于<span style="color:#fe2c24;"><strong>资源共享</strong></span>的特性，线程间的通信和同步更为简便。</p> 
<h4 id="2.%E4%B8%BE%E4%B8%AA%E6%88%91%E4%BB%AC%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E5%B0%8F%E4%BE%8B%E5%AD%90">2.举个我们日常生活中的小例子</h4> 
<p>用日常生活的例子来解释进程和线程的区别：</p> 
<p><strong>进程比喻</strong>： 想象一个餐厅，每个餐厅就是一个进程，它有自己独立的厨房（资源）、服务员（线程）、菜单（程序）、餐桌（内存空间）和客户账单（数据）。如果有两家不同的餐厅（两个进程），它们各自运营，拥有各自的食材和设备，互不影响，也不能直接共享对方的东西。</p> 
<p><strong>线程比喻</strong>： 回到同一个餐厅内，如果餐厅有多个服务员（线程），他们共享餐厅的所有资源（如厨房、菜单等），并且能在同一餐厅的不同区域同时服务多个顾客。比如，一个服务员负责点菜（处理请求），另一个负责上菜（执行任务），还有一个负责结账（清理资源）。虽然他们在同一片工作区（地址空间）内同时活动，但会通过合理的协调（例如，加锁机制）来避免冲突。</p> 
<p>总结来说，在这个比喻中：</p> 
<ul><li><strong>进程</strong>就像是独立运作的餐厅，每个餐厅有一套完整的设施和人员；</li><li><strong>线程</strong>则是同一餐厅内的不同服务员，他们共享餐厅资源并在其中执行各自的任务，可以同时服务于不同的顾客，实现并发操作。</li></ul> 
<h4 id="3.%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E6%AF%94%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9%3A(%E8%BF%99%E4%B8%AA%E9%9D%A2%E8%AF%95%E4%B8%AD%E4%B9%9F%E7%AE%97%E6%98%AF%E6%AF%94%E8%BE%83%E9%AB%98%E9%A2%91%E7%9A%84%E9%97%AE%E9%A2%98)"><strong>3.线程和进程的区别以及线程相比于进程的优点:(这个面试中也算是比较高频的问题)</strong></h4> 
<p></p> 
<ol><li> <p><strong>资源分配</strong>：</p> 
  <ul><li><strong>进程</strong>：进程是操作系统进行<strong><span style="color:#fe2c24;">资源分配和保护的基本单位</span></strong>，每个进程都有独立的内存空间，其中包括代码段、数据段、堆和栈。这意味着不同进程之间无法直接访问彼此的内存空间，从而保证了进程间的隔离性。</li><li><strong>线程</strong>：线程是<span style="color:#fe2c24;"><strong>进程内部的执行实体</strong></span>，是<strong><span style="color:#fe2c24;">系统调度和分配CPU的基本单位</span></strong>。同一进程内的所有线程共享相同的地址空间（包括全局变量、文件描述符等资源），也就是说，线程间可以直接读写同一进程内的内存，无需通过IPC（进程间通信）机制。</li></ul></li><li> <p><strong>创建和切换开销</strong>：</p> 
  <ul><li><strong>进程</strong>：<strong><span style="color:#fe2c24;">创建新进程需要分配独立的地址空间和其他相关资源</span></strong>，因此开销较大。进程间的切换除了保存和恢复CPU上下文外，还可能涉及虚拟内存、页表等映射的切换，开销相对较高。</li><li><strong>线程</strong>：<span style="color:#fe2c24;"><strong>创建线程的成本比进程低得多，因为它不需要额外分配地址空间</strong></span>。线程间的切换只需要保存和恢复少量寄存器状态（如程序计数器、栈指针等），因此线程切换的开销较小。</li></ul></li><li> <p><strong>并发性和并行性</strong>：</p> 
  <ul><li><strong>进程</strong>：进程提供了并发执行的能力，即在单个处理器上通过时间片轮转实现看似同时运行的效果，而在多处理器环境下，则可以真正地并行执行不同的进程。</li><li><strong>线程</strong>：线程提供了更加细粒度的并发执行，一个进程中的多个线程可以在单个处理器上通过时间片轮转并发执行，也可以在多核处理器上真正并行执行。</li></ul></li><li> <p><strong>通信与同步</strong>：</p> 
  <ul><li><strong>进程</strong>：进程间的通信通常需要使用<strong><span style="color:#fe2c24;">IPC</span></strong>机制，如管道、信号量、消息队列、共享内存等。</li><li><strong>线程</strong>：由于同一进程内的线程<span style="color:#fe2c24;"><strong>共享内存空间</strong></span>，它们之间的通信和同步可以通过更简单的机制实现，如锁、条件变量等。</li></ul></li><li> <p><strong>管理复杂性</strong>：</p> 
  <ul><li><strong>进程</strong>：进程管理相对复杂，需要考虑资源的独立性和安全性。</li><li><strong>线程</strong>：线程管理更加灵活，但由于线程间的<span style="color:#fe2c24;"><strong>资源共享特性</strong></span>，可能导致<span style="color:#fe2c24;"><strong>竞态条件</strong></span>和<span style="color:#fe2c24;"><strong>死锁</strong></span>等(<span style="color:#fe2c24;"><strong>涉及到线程安全问题</strong></span>)问题，因此线程同步和互斥问题较为复杂。</li></ul></li></ol> 
<p>综上所述，进程是操作系统中资源分配和保护的基本边界，而线程则是提供<span style="color:#fe2c24;"><strong>更高效并发执行</strong></span>能力的基础，并且在线程之间更容易共享信息和协同工作。</p> 
<h2 id="%E4%BA%8C.%E7%BC%96%E5%86%99%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BB%A3%E7%A0%81">二.编写多线程代码</h2> 
<h3 id="1.%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E7%B1%BB">1.定义线程类</h3> 
<pre><code class="language-java">class MyThread extends Thread {
    @Override
    public void run() {
        while (true) {
            System.out.println("hello Thread");
            try {
                Thread.sleep(1000);//使线程休眠
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
public class Demo1 {

    }
    public static void main(String[] args)  {
        Thread thread = new MyThread();
        thread.start();//创建线程
        while (true) {
            System.out.println("hello main");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre> 
<p><strong>运行结果:</strong></p> 
<p><img alt="" height="432" src="https://images2.imgbox.com/30/4d/59Wr4Wg4_o.png" width="776"> 我们可以看到<span style="color:#fe2c24;"><strong>主线程和Thread线程在</strong></span><strong>交替打印各自的信息</strong>需要注意的是，实际运行时，由于线程调度机制，线程间的执行并不是严格按照交替顺序进行的，而是随机交错的。</p> 
<p><strong>同时我们还可以通过命令行的方式查看线程运行的状态</strong></p> 
<p><strong>WIN + R 后输入cmd打开命令行后输入<span style="color:#fe2c24;">jconsole</span></strong></p> 
<p><img alt="" height="868" src="https://images2.imgbox.com/f4/6d/yVliZ7X5_o.png" width="1200"></p> 
<p><strong>点击我们刚才创建好的线程 </strong></p> 
<p><img alt="" height="286" src="https://images2.imgbox.com/0c/de/MNFidFJG_o.png" width="798"> 看到这里提醒<span style="color:#fe2c24;"><strong>不安全连接</strong></span>我们不用理会直接点击</p> 
<p><img alt="" height="530" src="https://images2.imgbox.com/4a/ce/OD2dm457_o.png" width="838"></p> 
<p> <strong>此时我们就清楚的看见线程的状态以及其它信息</strong><img alt="" height="1200" src="https://images2.imgbox.com/e4/1b/N34G7KvL_o.png" width="1200"></p> 
<h4 id="1.%E8%AF%B4%E6%98%8E">1.说明</h4> 
<p>我们可以看到如果使单线程运行的化,此时陷入了死循环,应该无限循环不断地输出"hello Thread",但就是因为多线程操作并发操作程序实现了两个并发执行的线程：<strong>主线程和<code>MyThread</code>子线程</strong>。这两个线程交替打印各自的信息，同时还可以发现,打印时并不是严格按照交替顺序进行,而是随机交错但由于<span style="color:#fe2c24;"><strong>线程调度的不确定性</strong></span>，(<strong><span style="color:#fe2c24;">抢占执行</span></strong>)实际输出的结果可能会出现交错现象，比如连续输出多次"hello Thread"后再输出几次"hello main"，或者是反过来的情况，这就是线程随机交错的现象。</p> 
<p>同时在这里解释一下</p> 
<p> 1.首先定义了一个名为<strong><code>MyThread</code>的类</strong>，该类继承自<strong><code>java.lang.Thread</code></strong>。在<code>MyThread</code>类中重写了<strong><span style="color:#fe2c24;"><code>run()</code>方法</span></strong>，这个方法是线程需要执行的任务主体。在<code>run()</code>方法内部，有一个无限循环不断地输出"hello Thread"，并且每次循环之间让当前线程睡眠1秒通过<strong><code><span style="color:#fe2c24;">Thread.sleep(1000)</span></code></strong>实现并且实现这个方法需要<span style="color:#fe2c24;"><strong>抛异常</strong></span>。</p> 
<p>2.创建线程实例：在<code>main</code>方法中，创建了<code>MyThread</code>类的一个实例<code>thread</code>。启动线程：调用<span style="color:#fe2c24;"><strong><code>thread.start()</code></strong></span>方法来启动线程。这会让JVM找到这个线程对象的<code>run()</code>方法，并在一个新的线程上下文中执行它</p> 
<p> <strong>为什么要调用<span style="color:#fe2c24;">thread.start() </span> (这一点很重要)</strong></p> 
<p></p> 
<p>在Java中，当你想要启动一个新的线程去执行特定任务时，你需要调用<strong><span style="color:#fe2c24;"><code>Thread</code>对象的<code>start()</code>方法</span></strong>。这是因为<code>start()</code>方法的作用是让<strong><span style="color:#fe2c24;">JVM</span></strong>创建一个新的线程，并在这个新线程中调用你之前重写的<span style="color:#0d0016;"><strong><code>run()</code>方法</strong></span>。</p> 
<p>具体来说：</p> 
<ul><li>当你创建一个<code>Thread</code>对象实例时，只是在内存中<strong>构建了一个表示线程的对象</strong>，并没有真正开启一个新的执行流。</li><li>而当你调用<strong><code>start()</code>方法时，Java虚拟机会为此线程分配必要的系统资源（如内存），并在某个时刻将该线程放入可执行线程队列等待调度。</strong></li><li>线程调度器会选择合适的时机将该线程从就绪状态转为运行状态，这时<code>run()</code>方法才会在新创建的线程上下文中执行。</li></ul> 
<p>因此，如果你直接调用<strong><code>run()</code>方法而不是<code>start()</code>方法，那么代码将在当前线程（通常是主线程）中同步执行，而非异步在新的线程中执行，也就失去了多线程的意义。</strong></p> 
<h3 id="2.%E9%80%9A%E8%BF%87%E5%AE%9E%E7%8E%B0Runnadle%E6%8E%A5%E5%8F%A3%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><strong>2.通过实现Runnadle接口创建线程</strong></h3> 
<pre><code class="language-java">class MyRunnable implements Runnable {
    @Override
    public void run() {
        while (true) {
            System.out.println();
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
public class Demo2 {
    public static void main(String[] args)  {
        Thread t = new Thread(new MyThread());
        t.start();
        while (true) {
            System.out.println("hello main");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}</code></pre> 
<p> <strong>定义Runnable接口的实现类：<code>MyRunnable</code>类实现了<code>java.lang.Runnable</code>接口，并在其内部重写了<code>run()</code>方法。这个<code>run()</code>方法同样是线程需要执行的任务主体，这里也是一个无限循环，每秒输出一行空白字符，并在每次循环间使当前线程睡眠1秒。</strong></p> 
<p><strong>输出结果和第一种方法同样</strong><span style="color:#fe2c24;"><strong>主线程和Thread线程在</strong></span><strong>交替打印各自的信息,同样不是</strong>严格按照交替顺序进行的，而是<strong>随机交错</strong>的</p> 
<p> <img alt="" height="562" src="https://images2.imgbox.com/1a/71/L3MsnNVJ_o.png" width="1072"> </p> 
<h3 id="3.%E9%92%88%E5%AF%B9%E6%96%B9%E6%B3%951%E4%BD%BF%E7%94%A8%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB">3.针对方法1使用匿名内部类</h3> 
<pre><code class="language-java">public class Demo3 {
    public static void main(String[] args) {
        Thread t = new Thread() {
            @Override
            public void run() {
                while (true) {
                    System.out.println("hello thread");
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        };

        t.start();
        while (true) {
            System.out.println("hello main");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

}
</code></pre> 
<p><strong>就是针对方法1的一个变种方法,结果都一样,都是实现了多线程</strong></p> 
<p> <img alt="" height="482" src="https://images2.imgbox.com/62/68/OqHILzvY_o.png" width="940"> </p> 
<h3 id="%C2%A04.%E9%92%88%E5%AF%B9%E6%96%B9%E6%B3%952%E4%BD%BF%E7%94%A8%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"> 4.针对方法2使用匿名内部类</h3> 
<pre><code class="language-java">public class Demo4 {
    public static void main(String[] args) throws InterruptedException {
        Thread t = new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) {
                    System.out.println("hello thread");
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                }
            }
        });
        t.start();
        while (true) {
            System.out.println("hello main");
            Thread.sleep(1000);
        }

    }
}</code></pre> 
<p> <strong>就是针对方法2的一个变种方法,结果都一样,都是实现了多线程</strong></p> 
<p> <img alt="" height="434" src="https://images2.imgbox.com/68/6f/kz1HUD4G_o.png" width="870"> </p> 
<h3 id="5.%E4%BD%BF%E7%94%A8%20lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F">5.使用 lambda表达式</h3> 
<pre><code class="language-java">public class Demo5 {
    public static void main(String[] args) throws InterruptedException {
        Thread t = new Thread(()-&gt;{
           while (true) {
               System.out.println("hello Thread");
               try {
                   Thread.sleep(1000);
               } catch (InterruptedException e) {
                   throw new RuntimeException(e);
               }
           }
        });
        t.start();
        while (true) {
            System.out.println("hello main");
            Thread.sleep(1000);
        }
    }
}
</code></pre> 
<p></p> 
<p>Lambda表达式是Java 8及其后续版本引入的一种简洁的函数式编程风格的特性，用于创建匿名函数或闭包。Lambda表达式使得开发者能够更加方便地处理函数式接口（即只有一个抽象方法的接口），无需显式声明新的类来实现这些接口。</p> 
<p>基本结构： Lambda表达式的通用格式如下：</p> 
<p>Java</p> 
<pre><code class="language-java">1(parameters) -&gt; {body}</code></pre> 
<ul><li> <p>参数部分（parameters）：可以为空，也可以包含零个或多个参数。每个参数都有一个类型或可以通过类型推断得出。如果只有一个参数，可以省略小括号；如果有多个参数，则需用逗号分隔。</p> </li><li> <p>箭头符号（-&gt;）：标志着参数列表的结束和函数体的开始。</p> </li><li> <p>函数体（body）：可以是一个表达式或一个代码块。如果函数体只包含一条表达式且能隐式转换为方法的返回类型，可以省略大括号；否则，需要使用大括号包围多条语句形成代码块。</p> </li></ul> 
<p> 结果如下:</p> 
<p> <img alt="" height="516" src="https://images2.imgbox.com/6d/b8/RGJOoHRV_o.png" width="720"> </p> 
<p><strong>这5种方法博主这里建议大家不说你都会写,(当然这5种方法多写几遍,应该差不多就可以掌握了)但你至少都得看的懂,并且熟练掌握几种.其实这5种方法本质上就是</strong></p> 
<p><strong>1.把线程具体要实现的业务写出来即(重写run()方法)</strong></p> 
<p><strong>2.通过调用start()方法创建/启动线程.</strong></p> 
<h2 id="%E4%B8%89.Thread%E7%B1%BB"><strong>三.Thread类</strong></h2> 
<h3 id="1.%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><strong>1.构造方法</strong></h3> 
<p>T​​​​hread(String name)这里可以为你创建的线程,命名以便在后续这个名字对于理解和追踪多线程应用程序中的各个线程很有帮助，尤其是在调试和日志记录的过程中。</p> 
<pre><code class="language-java">public class Demo23 {
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(()-&gt; {
            while (true) {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                System.out.println("hello Thread");
            }
        },"text1");
        t1.start();
        while (true) {
            Thread.sleep(1000);
            System.out.println("hello main");
        }
    }
}
</code></pre> 
<p>通过命令行输入<span style="color:#fe2c24;"><strong>jconsole</strong></span><span style="color:#0d0016;"><strong>打开Java的监视控制台</strong>就可以查看到,此时我们创建的线程的状态,非常</span>便于识别和管理各个线程特别是在后期我们创建很多线程时,优势就体现出来了</p> 
<p> <img alt="" height="354" src="https://images2.imgbox.com/ca/06/eLTSMuHg_o.png" width="1200"> </p> 
<h3 id="2.%E5%85%B6%E4%BB%96%E7%9A%84%E6%96%B9%E6%B3%95">2.其他的方法</h3> 
<h4 id="1.%E8%8E%B7%E5%8F%96Id%20getid()">1.获取Id getid()</h4> 
<pre><code class="language-java">public class Demo23 {
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(()-&gt; {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                System.out.println("hello thread");

        },"text1");
        t1.start();
        System.out.println(t1.getId());//获取线程的ID
        Thread.sleep(1000);
        System.out.println("hello main");

    }
}</code></pre> 
<p>结果为:</p> 
<h4 id="%C2%A0%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0%C2%A02.%E8%8E%B7%E5%8F%96%E5%90%8D%E7%A7%B0%20getName()"> <img alt="" height="238" src="https://images2.imgbox.com/e4/5c/R2nXUMIz_o.png" width="940">  2.获取名称 getName()</h4> 
<h4 id="3.%E8%8E%B7%E5%8F%96%E7%8A%B6%E6%80%81%20getState()">3.获取状态 getState()</h4> 
<h4 id="4.%E6%98%AF%E5%90%A6%E4%B8%BA%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B%20isDaemon()">4.是否为后台线程 isDaemon()</h4> 
<p>这里我们介绍一下后台线程和前台线程的区别</p> 
<ol><li> <p><strong>前台线程（Foreground Thread）</strong>：</p> 
  <ul><li>常指那些负责处理用户交互、执行主业务逻辑或执行关键服务的线程，这类线程通常决定了整个应用程序的生命周期。例如，GUI应用程序的事件循环线程就是一个典型的前台线程，只要这个线程还在运行，应用程序就不会退出。另外，Web服务器中的请求处理线程也是前台线程，它们必须保持活跃以响应客户端请求。</li></ul></li><li> <p><strong>后台线程（Background Thread）</strong>：</p> 
  <ul><li>也称为守护线程（Daemon Thread）。在Java中，通过调用 <code>Thread.setDaemon(true)</code> 方法可以将一个线程设置为守护线程。守护线程主要用于执行支持性的任务，比如清理工作、资源监控、定时任务等。当所有的非守护线程（也就是所谓的前台线程）都结束后，即使还有守护线程在运行，Java虚拟机也会退出。也就是说，守护线程依赖于非守护线程的存在，非守护线程全部结束后，守护线程也随之结束，不再单独维持应用程序的运行。</li></ul></li></ol> 
<p>总结来说，前台线程与应用程序的主要功能和生命周期紧密相关，而后台线程则更多是服务于前台线程，不直接影响应用程序的关闭与否</p> 
<p><strong>为了通俗易懂点博主这里举个小例子</strong></p> 
<ol><li> <p><strong>前台线程（重要主线任务）</strong>：</p> 
  <ul><li>假设你正在厨房做饭（这是你的主要任务，类似于前台线程），你正在炒菜（主业务流程），这个过程中你需要不断地翻炒、调味等操作（前台线程的工作）。如果不做这些，饭就无法完成，这就是至关重要的前台任务。</li></ul></li><li> <p><strong>后台线程（辅助支持任务）</strong></p> 
  <ul><li>同时，厨房里的洗碗机正在运行清洗餐具（这是一个后台守护任务，类似于后台线程）。虽然洗碗很重要，但如果炒菜任务完成了（所有非守护线程结束），你可以离开厨房，即使洗碗机还没洗完（后台线程仍在运行），你也不会留在那里等待它结束。洗碗机就是在后台默默地支持你的主要烹饪任务。</li></ul></li></ol> 
<p>通过这个例子，可以看出前台线程（炒菜）主导着整个活动的进程和结束，而后台线程（洗碗机）虽然重要，但它的运行并不影响整个活动（做饭）的基本结束条件。在计算机程序中，后台线程往往用来处理一些辅助性、长期运行或维护性的工作，而不直接影响程序的主流程和退出。</p> 
<p><strong>再通过具体的代码例子来说明后台线程和前台线程</strong></p> 
<p><strong>这个属于两个都是前台线程的情况</strong></p> 
<pre><code class="language-java">public class Demo25 {
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(()-&gt;{
           for(int i = 0; i &lt;5;i++) {
               try {
                   Thread.sleep(1000);
               } catch (InterruptedException e) {
                   throw new RuntimeException(e);
               }
               System.out.println("hello Thread");
           }
            System.out.println("t1结束");
        });
        t1.start();
        for (int i = 0;i &lt; 3;i++) {
            Thread.sleep(1000);
            System.out.println("hello main");
        }
        System.out.println("main结束");
    }
}
</code></pre> 
<p> <img alt="" height="480" src="https://images2.imgbox.com/a9/d7/UBl7YFzy_o.png" width="670"></p> 
<p>可以看到,<strong>main线程</strong>以及结束了,可是<strong>t1线程</strong>没有结束,此时进程就没有结束,<span style="color:#fe2c24;">直到t1结束后,进程才结束,这就是只有所有前台线程结束后,进程才结束</span></p> 
<p><strong><span style="color:#0d0016;">我们现在把t1线程设置为后台线程再看看结果如何</span></strong></p> 
<p><strong><span style="color:#0d0016;">这里要注意在创建线程之前(在start()方法之前),就要先设置好,否则此操作无效</span></strong></p> 
<pre><code class="language-java">public class Demo25 {
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(()-&gt;{
           for(int i = 0; i &lt;5;i++) {
               try {
                   Thread.sleep(1000);
               } catch (InterruptedException e) {
                   throw new RuntimeException(e);
               }
               System.out.println("hello Thread");
           }
            System.out.println("t1结束");
        });
        t1.setDaemon(true);//要在线程创建前,将线程设置为后台线程
        t1.start();
        for (int i = 0;i &lt; 3;i++) {
            Thread.sleep(1000);
            System.out.println("hello main");
        }
        System.out.println("main结束");
    }
}
</code></pre> 
<p><img alt="" height="464" src="https://images2.imgbox.com/b1/06/ehJ6jG4E_o.png" width="620"></p> 
<p>此时,main线程为前台线程,t1为后台线程,我们可以看到只要main线程结束了,无论t1是否结束,进程都结束了.以及如果t1结束,但前台线程main线程没有结束,进程也不会结束</p> 
<pre><code class="language-java">public class Demo25 {
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(()-&gt;{
           for(int i = 0; i &lt;3;i++) {
               try {
                   Thread.sleep(1000);
               } catch (InterruptedException e) {
                   throw new RuntimeException(e);
               }
               System.out.println("hello Thread");
           }
            System.out.println("t1结束");
        });
        t1.setDaemon(true);//要在线程创建前,将线程设置为后台线程
        t1.start();
        for (int i = 0;i &lt; 5;i++) {
            Thread.sleep(1000);
            System.out.println("hello main");
        }
        System.out.println("main结束");
    }
}
</code></pre> 
<h4 id="%E2%80%8B%E7%BC%96%E8%BE%91%C2%A05.%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB%20isAlive()"><img alt="" height="514" src="https://images2.imgbox.com/de/6f/N1F0yJ22_o.png" width="782"> 5.是否存活 isAlive()</h4> 
<p>它用于检查一个线程是否仍然存活，即线程是否已经开始执行且还没有结束。</p> 
<h4 id="6.%E6%98%AF%E5%90%A6%E8%A2%AB%E4%B8%AD%E6%96%AD%20isInterrupted()">6.是否被中断 isInterrupted()</h4> 
<p><code>isInterrupted()</code> 是Java中 <code>Thread</code> 类的一个方法，用于检查线程是否已被中断。中断是一种协作机制，允许一个线程通知另一个线程应该停止当前正在执行的操作。</p> 
<p>语法如下：</p> 
<p>Java</p> 
<pre><code>1boolean isInterrupted()</code></pre> 
<p>这个方法会返回一个布尔值：</p> 
<ul><li>如果线程已被中断（调用了 <code>interrupt()</code> 方法），则返回 <code>true</code>；</li><li>如果线程未被中断，则返回 <code>false</code>。</li></ul> 
<p>需要注意的是，调用 <code>isInterrupted()</code> 方法并不会清除中断状态。如果希望在检查中断状态的同时清除此状态，可以使用静态方法 <code>Thread.interrupted()</code>。</p> 
<p>举例说明：</p> 
<p>Java</p> 
<pre><code>1Thread thread = new Thread(() -&gt; {
2    while (!Thread.currentThread().isInterrupted()) {
3        // 执行任务...
4    }
5});
6
7thread.start();
8
9// 在某个时刻，决定中断线程
10thread.interrupt();
11
12// 另一线程或同一线程中的代码可以通过isInterrupted()检查中断状态
13if (thread.isInterrupted()) {
14    System.out.println("线程已被中断");
15}</code></pre> 
<p>在上面的代码中，线程在执行任务时会周期性检查自身的中断状态，一旦发现被中断，就会退出循环，从而达到协作式中断的目的</p> 
<p><strong>同时需要注意的是,只能起到提醒作用,并不可以真正的中断,这能该线程自己中断自己</strong></p> 
<p>例如，线程可能在循环、等待IO操作、或者在调用 <code>sleep()</code>、<code>wait()</code>、<code>join()</code> 等方法时被中断。在这些情况下，被中断的线程通常会抛出一个 <code>InterruptedException</code> 异常，然后可以根据程序的需求选择恢复执行、清理资源后退出，或者直接结束线程。</p> 
<p>总的来说，<code>interrupt()</code> 方法和 <code>isInterrupted()</code> 方法提供了线程间的通信手段，允许一个线程请求另一个线程停止其当前的操作，但具体的中断逻辑需要由被中断线程自行实现，体现了Java中线程中断的协作性和灵活性。</p> 
<p><strong>以上就是博主关于Java多线程学习的一点点部分,后续还有很多内容,例如重点的:线程安全问题</strong></p> 
<p><strong>这里就不过多的赘述了,如果感兴趣的话,可以关注博主.查看线程安全的解释</strong></p> 
<p style="text-align:center;"><strong><img alt="" src="https://images2.imgbox.com/eb/49/EOVKGSAl_o.gif"></strong></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c2d234885154eeeac3bd064a6cf0c35c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于Spring Boot 3 &#43; Spring Security6 &#43; JWT &#43; Redis实现登录、token身份认证</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/729e0b32ccf0f4e69ee7a719ef80631e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">VSCode中6个AI顶级插件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>