<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>扫雷-C语言 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/084cae817d6a2a156b602fb4ad79f455/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="扫雷-C语言">
  <meta property="og:description" content="一、前言： 众所周知，扫雷是一款大众类的益智小游戏，它的游戏目标是在最短的时间内根据点击格子出现的数字找出所有非雷格子，同时避免踩雷，踩到一个雷即全盘皆输。
今天，我们的目的就是通过C语言来实现一个简单扫雷游戏。
主要操作有:
1.初始化棋盘；
2.打印棋盘；
3.统计周围雷的个数；
4.排雷；
5.判断输赢；
我这里是通过三个文件：源文件（Test.c）源文件（Game.c）头文件（Game.h）来实现的它们分别有各自的分工：
1.源文件-Test.c：主要用于调用定义的函数来实现扫雷操作。
2.源文件-Game.c:主要用于定义头文件-Game.h声明的函数。
3.头文件-Game.h:主要用于声明所需要的操作的函数。
二、头文件-Game.h: 2.1-目的： 这里我们需要的操作是声明所需要的头文件，将所需要的操作声明成一个函数并在源文件-Game.c中定义所声明的函数。
2.2-代码： #pragma once #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #define ROW 9 #define COL 9 #define ROWS 11 #define COLS 11 #define COUNT 10 //选单 void menu();	//扫雷游戏 //用于整理函数，实现扫雷所有操作 void game(); //初始化棋盘 void InitBoard(char board[ROWS][COLS],int rows,int cols,char tem); //打印棋盘 void PrintBoard(char board[ROWS][COLS], int row, int col); //布置雷 void SetBoard(char board[ROWS][COLS], int row, int col); //排除雷 void FindBoard(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col); //统计周围雷的个数 int get_mine_count(char mine[ROWS][COLS],int x,int y);	//判断是否获胜 int If_win(int win); 三、源文件-Game.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-24T21:03:53+08:00">
    <meta property="article:modified_time" content="2024-07-24T21:03:53+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">扫雷-C语言</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="background-color:transparent;">一、前言：</h2> 
<p>        众所周知，扫雷是一款大众类的益智小游戏，它的游戏目标是在最短的时间内根据点击格子出现的数字找出所有非雷格子，同时避免踩雷，踩到一个雷即全盘皆输。</p> 
<p>        今天，我们的目的就是通过C语言来实现一个简单扫雷游戏。</p> 
<p><strong>主要操作有:</strong></p> 
<p>1.初始化棋盘；</p> 
<p>2.打印棋盘；</p> 
<p>3.统计周围雷的个数；</p> 
<p>4.排雷；</p> 
<p>5.判断输赢；</p> 
<p>        我这里是通过三个文件：<strong><span style="color:#fe2c24;">源文件（Test.c）源文件（Game.c）头文件（Game.h）</span></strong>来实现的它们分别有各自的分工：</p> 
<p>1.<strong>源文件-Test.c：</strong>主要用于调用定义的函数来实现扫雷操作。</p> 
<p>2.<strong>源文件-Game.c:</strong>主要用于定义头文件-Game.h声明的函数。</p> 
<p>3.<strong>头文件-Game.h:</strong>主要用于声明所需要的操作的函数。</p> 
<h2>二、头文件-Game.h:</h2> 
<h3>2.1-目的：</h3> 
<p>        这里我们需要的操作是声明所需要的头文件，将所需要的操作声明成一个函数并在<strong>源文件-Game.c</strong>中定义所声明的函数。</p> 
<h3>2.2-代码：</h3> 
<pre><code class="language-cpp">#pragma once

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

#define ROW 9
#define COL  9

#define ROWS 11
#define COLS  11
#define COUNT 10

//选单
void menu();		

//扫雷游戏
//用于整理函数，实现扫雷所有操作
void game();

//初始化棋盘
void InitBoard(char board[ROWS][COLS],int rows,int cols,char tem);

//打印棋盘
void PrintBoard(char board[ROWS][COLS], int row, int col);

//布置雷
void SetBoard(char board[ROWS][COLS], int row, int col);

//排除雷
void FindBoard(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col);

//统计周围雷的个数
int get_mine_count(char mine[ROWS][COLS],int x,int y);		

//判断是否获胜
int If_win(int win);</code></pre> 
<h2>三、源文件-Game.c:</h2> 
<h3>3.1-目的：</h3> 
<p>        将上述<strong>头文件-Game.h</strong>中所声明的操作函数通过自我实现给定义了。</p> 
<h3>3.2-操作函数的定义：</h3> 
<h4> 3.2.1-选单:</h4> 
<h5>目的：</h5> 
<p>        为了使函数操作在执行时更美观，更便于用户使用。</p> 
<h5>代码：</h5> 
<pre><code class="language-cpp">//设置选单
void menu()
{
	printf("*************************************\n");
	printf("**********      1.play      *********\n");
	printf("**********      0.exit      *********\n");
	printf("*************************************\n");
}</code></pre> 
<h5>效果图： </h5> 
<p><img alt="" height="158" src="https://images2.imgbox.com/f0/64/5trtG5Wx_o.png" width="472"></p> 
<h4>3.2.2-初始化棋盘:</h4> 
<h5>目的：</h5> 
<p>        将定义的二维数组给初始化，便于用户在打印时观察以及后续的操作。</p> 
<h5>代码：</h5> 
<pre><code class="language-cpp">//初始化棋盘
void	InitBoard(char board[ROWS][COLS], int rows, int cols, char tem)
{
	for (int i = 0; i &lt; rows; i++)
	{
		for (int j = 0; j &lt; cols; j++)
		{
			board[i][j] = tem;
		}
	}
}</code></pre> 
<h5> 效果图： </h5> 
<p>我们可以在初始化后打印来检查初始化是否成功。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c3/24/y7Rq5Suj_o.png"></p> 
<h4>3.2.3-打印棋盘:</h4> 
<h5>目的： </h5> 
<p>        打印扫雷棋盘，便于自我检查自我定义的函数，以及用户进行扫雷时的操作及观看。</p> 
<h5>代码：</h5> 
<pre><code class="language-cpp">//打印棋盘
void PrintBoard(char board[ROWS][COLS], int row, int col)
{
	printf("----------------扫雷------------------\n");
	for (int j = 0; j &lt;= col; j++)
	{
		printf(" %d ",j);
	}
	printf("\n");
	for (int i = 1; i &lt;= row; i++)
	{
		printf(" %d ",i);
		for (int j = 1; j &lt;= col; j++)
		{
			printf(" %c ", board[i][j]);
		}
		printf("\n");
	}
	printf("----------------扫雷------------------\n");
}</code></pre> 
<h5>效果图：</h5> 
<p><img alt="" src="https://images2.imgbox.com/05/28/o0tbqPWu_o.png"></p> 
<h4> 3.2.4-布置雷:</h4> 
<h5>目的：</h5> 
<p>        在二维数组中随机生成雷，来便于后续的扫雷操作。</p> 
<h5>代码：</h5> 
<pre><code class="language-cpp">//在布雷数组中布置雷
void SetBoard(char board[ROWS][COLS], int row, int col)
{
	int count = COUNT;
	while (count)
	{
		int x = rand() % col + 1;
		int y = rand() % row + 1;
		if (board[x][y] == '0')
		{
			board[x][y] = '1';
			count--;
		}
	}
}</code></pre> 
<h5>效果图：</h5> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/12/98/Sp0HwLKd_o.png"></p> 
<h4> 3.2.5-进行排雷：</h4> 
<h5>目的：</h5> 
<p>        用户进行扫雷游戏。<span style="color:#fe2c24;">注意：这里需判断是否将没雷的位置全部点出，如果全部点出则需要提示用户获胜，并且如果用户输入的坐标已经排过一次雷了我们还需提示用户。</span></p> 
<h5>代码：</h5> 
<pre><code class="language-cpp">//在排雷数组中排雷
void FindBoard(char mine[ROWS][COLS],char show[ROWS][COLS], int row, int col)
{
	int x, y;
	int win = 0;
	while (1)
	{
		printf("请输入坐标：");
		scanf("%d %d", &amp;x, &amp;y);
		if (show[x][y] != '*')
		{
			printf("该坐标已被排查过！\n");
			continue;
		}
		if (mine[x][y] == '1')
		{
			printf("很遗憾，你被炸死了！\n");
			PrintBoard(mine, ROW, COL);			   //打印布雷数组
			break;
		}
		if (mine[x][y] == '0')
		{
			int num = get_mine_count(mine, x, y);
			show[x][y] = num + '0';
			win++;
			//判断是否获胜
			if (If_win(win))
			{
				printf("恭喜你赢了！\n");
				PrintBoard(show, ROW, COL);			   //打印排雷数组
				return;
			}
			PrintBoard(show, ROW, COL);			   //打印排雷数组
		}

	}
}</code></pre> 
<h5>效果图： </h5> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/1e/58/zG94zkkj_o.png"></p> 
<h4>3.2.6-统计周围雷的个数：</h4> 
<h5 style="background-color:transparent;">目的：</h5> 
<p>        统计输入坐标格子周围8个位置中雷的总数，以便于用户进行排雷操作。</p> 
<h5>代码：</h5> 
<pre><code class="language-cpp">//统计周围雷的个数
int get_mine_count(char mine[ROWS][COLS], int x, int y)
{
	int count = 0;
	if (mine[x - 1][y - 1] == '1')
	{
		count++;
	}
	if (mine[x - 1][y] == '1')
	{
		count++;
	}
	if (mine[x - 1][y + 1] == '1')
	{
		count++;
	}
	if (mine[x][y - 1] == '1')
	{
		count++;
	}
	if (mine[x][y + 1] == '1')
	{
		count++;
	}
	if (mine[x + 1][y - 1] == '1')
	{
		count++;
	}
	if (mine[x + 1][y] == '1')
	{
		count++;
	}
	if (mine[x + 1][y + 1] == '1')
	{
		count++;
	}
	return count;
}</code></pre> 
<h5>效果图：</h5> 
<h5> <img alt="" height="316" src="https://images2.imgbox.com/f3/e2/YugAYzBD_o.png" width="528"></h5> 
<h4>3.2.7-判断是否获胜：</h4> 
<h5>目的：</h5> 
<p>       如果排除位置个数与总数-雷的个数相同则说明用户获胜，我们需要判断用户是否获胜并提示用户。</p> 
<h5>代码：</h5> 
<pre><code class="language-cpp">//判断是否获胜
int If_win(int win)
{
	if (win == (ROW * COL - COUNT))
	{
		return 1;
	}
	return 0;
}</code></pre> 
<h2>四、源文件-Test.c:</h2> 
<h3 style="background-color:transparent;">4.1-目的：</h3> 
<p>        主要用于调用定义的函数通过分工来实现扫雷操作，并定义扫雷时所需要的两个数组。</p> 
<h3>4.2-思路：</h3> 
<p>        首先，我们需要知道扫雷需要通过两个二维数组来实现，一个用于布置雷，一个用于进行排雷游戏。接着，我们需要对定义的两个二维数组进行初始化，便于后继的操作以及用户的观察。在初始化后我们也可以通过自我定义的打印函数来检查初始化是否正确。然后，在完成上述操作后，我们需要对布雷数组进行随机布置雷。最后，我们进行排雷操作，从而实现扫雷游戏。</p> 
<h3>4.3-代码：</h3> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1

#include "Game.h"


void game()
{
	char mine[ROWS][COLS] = { 0 };			//布雷的二维数组
	char show[ROWS][COLS] = { 0 };			//排雷的二维数组

	InitBoard(mine, ROWS, COLS, '0');		//初始化布雷数组
	//PrintBoard(mine, ROW, COL);			   //打印布雷数组
	
	InitBoard(show, ROWS, COLS, '*');		初始化排雷数组
	PrintBoard(show, ROW, COL);			   //打印排雷数组
	
	SetBoard(mine, ROW, COL);			   //布置雷
	//PrintBoard(mine, ROW, COL);			   //打印布雷数组

	FindBoard(mine, show, ROW, COL);			   //排雷
}

int main()
{
	srand((unsigned int)time(NULL));
	int intput=1;
	do
	{
		menu();
		printf("请选择选项:&gt;");
		scanf("%d", &amp;intput);

		switch (intput)
		{
		case 1:
		{
			game();
			break;
		}
		case 0:
		{
			printf("退出游戏！");
			break;
		}
		default:
		{
			printf("选择错误，重新选择！");
			break;
		}
		}
	} while (intput);

	return 0;
}</code></pre> 
<h2>五、结语：</h2> 
<p>        <span style="color:#511b78;">上述内容，即是我个人<strong>对扫雷游戏-C语言</strong>的个人见解以及自我实现。若有大佬发现哪里有问题可以私信或评论指教一下我这个小萌新。非常感谢各位uu们的点赞，关注，收藏，我会更加努力的学习编程语言，还望各位多多关照，让我们一起进步吧！</span></p> 
<p style="text-align:center;"><span style="color:#511b78;"><img alt="" src="https://images2.imgbox.com/a8/85/vsl3BzP4_o.png"></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7f557af66395dd9dfcec12ed8b0161bb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">091、Python 写Excel文件（使用openpyxl库）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/10209430ad6e105d50b5a6587519425a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">{Spring Boot 原理篇} Spring Boot自动装配原理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>