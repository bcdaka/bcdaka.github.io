<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;高阶】：智能指针的全面解析 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/aad666c9184c6d52d3e81402dda34ce2/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;高阶】：智能指针的全面解析">
  <meta property="og:description" content="✨ 落絮无声春堕泪，行云有影月含羞 🌏
📃个人主页：island1314
🔥个人专栏：C&#43;&#43;学习
🚀 欢迎关注：👍点赞 👂🏽留言 😍收藏 💞 💞 💞
目录
1.引言
1.1 动态内存与智能指针
🌸1.1.1 动态内存
🌸1.1.2 智能指针
1.2 智能指针的重要性
1.3 像指针一样使用
1.4 支持智能指针对象拷贝
2. C&#43;&#43;标准库的智能指针
2.1 auto_ptr
🌈2.1.1 基本概念
🌈2.1.2 基本用法
2.2 unique_ptr
✨2.2.1 基本概念
✨2.2.2 基本用法
2.3 shared_ptr
🎈2.3.1 基本概念
🎈2.3.2 基本用法
🎈2.3.3 注意事项
2.4 weak_ptr
🧩2.4.1 基本概念
🧩2.4.2 基本用法
🧩2.4.3 对循环引用的解决
🧩2.4.4 与shared_ptr的关系
3. 智能指针的实现
3.1 auto_ptr模拟实现
3.2 unique_ptr模拟实现
3.3 shared_ptr模拟实现
3.4 weak_ptr模拟实现
📖总结">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-08T09:55:36+08:00">
    <meta property="article:modified_time" content="2024-08-08T09:55:36+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;高阶】：智能指针的全面解析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p><img alt="" height="540" src="https://images2.imgbox.com/57/13/8h5bp26z_o.jpg" width="960"></p> 
<p>✨                                      <span style="color:#4da8ee;">  <strong>  落絮无声春堕泪，行云有影月含羞 </strong></span>    🌏</p> 
<p>📃<a href="https://so.csdn.net/so/search?q=%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5&amp;spm=1001.2101.3001.7020" title="个人主页">个人主页</a>：<a href="https://blog.csdn.net/island1314?spm=1011.2266.3001.5343" title="island1314">island1314</a></p> 
<p>🔥个人专栏：<a href="https://blog.csdn.net/island1314/category_12622912.html" title="C++学习">C++学习</a></p> 
<p>🚀 欢迎关注：👍点赞 👂🏽留言 😍收藏  💞 💞 💞</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/19/63/Vg33cEA0_o.gif"></p> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E5%BC%95%E8%A8%80-toc" style="margin-left:40px;"><a href="#1.%E5%BC%95%E8%A8%80" rel="nofollow">1.引言</a></p> 
<p id="%C2%A01.1%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-toc" style="margin-left:80px;"><a href="#%C2%A01.1%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88" rel="nofollow"> 1.1 动态内存与智能指针</a></p> 
<p id="1.1.1%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98-toc" style="margin-left:120px;"><a href="#1.1.1%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98" rel="nofollow">🌸1.1.1 动态内存</a></p> 
<p id="1.1.2%C2%A0%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-toc" style="margin-left:120px;"><a href="#1.1.2%C2%A0%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88" rel="nofollow">🌸1.1.2 智能指针</a></p> 
<p id="1.2%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7-toc" style="margin-left:80px;"><a href="#1.2%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7" rel="nofollow">1.2 智能指针的重要性</a></p> 
<p id="1.3%20%E5%83%8F%E6%8C%87%E9%92%88%E4%B8%80%E6%A0%B7%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#1.3%20%E5%83%8F%E6%8C%87%E9%92%88%E4%B8%80%E6%A0%B7%E4%BD%BF%E7%94%A8" rel="nofollow">1.3 像指针一样使用</a></p> 
<p id="1.4%C2%A0%E6%94%AF%E6%8C%81%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D-toc" style="margin-left:80px;"><a href="#1.4%C2%A0%E6%94%AF%E6%8C%81%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D" rel="nofollow">1.4 支持智能指针对象拷贝</a></p> 
<p id="2.%20C%2B%2B%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-toc" style="margin-left:40px;"><a href="#2.%20C%2B%2B%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88" rel="nofollow">2. C++标准库的智能指针</a></p> 
<p id="2.1%20auto_ptr-toc" style="margin-left:80px;"><a href="#2.1%20auto_ptr" rel="nofollow">2.1 auto_ptr</a></p> 
<p id="2.1.1%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:120px;"><a href="#2.1.1%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">🌈2.1.1 基本概念</a></p> 
<p id="2.1.2%C2%A0%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-toc" style="margin-left:120px;"><a href="#2.1.2%C2%A0%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95" rel="nofollow">🌈2.1.2 基本用法</a></p> 
<p id="2.2%C2%A0unique_ptr-toc" style="margin-left:80px;"><a href="#2.2%C2%A0unique_ptr" rel="nofollow">2.2 unique_ptr</a></p> 
<p id="2.2.1%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:120px;"><a href="#2.2.1%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">✨2.2.1 基本概念</a></p> 
<p id="2.2.1%20%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-toc" style="margin-left:120px;"><a href="#2.2.1%20%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95" rel="nofollow">✨2.2.2 基本用法</a></p> 
<p id="2.3%C2%A0shared_ptr-toc" style="margin-left:80px;"><a href="#2.3%C2%A0shared_ptr" rel="nofollow">2.3 shared_ptr</a></p> 
<p id="2.3.1%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%8E%9F%E7%90%86-toc" style="margin-left:120px;"><a href="#2.3.1%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%8E%9F%E7%90%86" rel="nofollow">🎈2.3.1 基本概念</a></p> 
<p id="2.3.2%20%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-toc" style="margin-left:120px;"><a href="#2.3.2%20%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95" rel="nofollow">🎈2.3.2 基本用法</a></p> 
<p id="2.3.3%20%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-toc" style="margin-left:120px;"><a href="#2.3.3%20%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" rel="nofollow">🎈2.3.3 注意事项</a></p> 
<p id="2.4%C2%A0weak_ptr-toc" style="margin-left:80px;"><a href="#2.4%C2%A0weak_ptr" rel="nofollow">2.4 weak_ptr</a></p> 
<p id="2.4.1%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:120px;"><a href="#2.4.1%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">🧩2.4.1 基本概念</a></p> 
<p id="2.4.2%20%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-toc" style="margin-left:120px;"><a href="#2.4.2%20%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95" rel="nofollow">🧩2.4.2 基本用法</a></p> 
<p id="2.4.3%20%E5%AF%B9%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E7%9A%84%E8%A7%A3%E5%86%B3-toc" style="margin-left:120px;"><a href="#2.4.3%20%E5%AF%B9%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E7%9A%84%E8%A7%A3%E5%86%B3" rel="nofollow">🧩2.4.3 对循环引用的解决</a></p> 
<p id="2.4.4%20%E4%B8%8Eshared_ptr%E7%9A%84%E5%85%B3%E7%B3%BB-toc" style="margin-left:120px;"><a href="#2.4.4%20%E4%B8%8Eshared_ptr%E7%9A%84%E5%85%B3%E7%B3%BB" rel="nofollow">🧩2.4.4 与shared_ptr的关系</a></p> 
<p id="3.%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#3.%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">3. 智能指针的实现</a></p> 
<p id="3.1%20auto_ptr%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#3.1%20auto_ptr%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" rel="nofollow">3.1 auto_ptr模拟实现</a></p> 
<p id="3.2%C2%A0unique_ptr%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#3.2%C2%A0unique_ptr%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" rel="nofollow">3.2 unique_ptr模拟实现</a></p> 
<p id="3.3%C2%A0shared_ptr%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#3.3%C2%A0shared_ptr%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" rel="nofollow">3.3 shared_ptr模拟实现</a></p> 
<p id="3.4%C2%A0weak_ptr%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#3.4%C2%A0weak_ptr%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" rel="nofollow">3.4 weak_ptr模拟实现</a></p> 
<p id="%F0%9F%93%96%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#%F0%9F%93%96%E6%80%BB%E7%BB%93" rel="nofollow">📖总结</a></p> 
<p></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="1.%E5%BC%95%E8%A8%80">1.引言</h3> 
<blockquote> 
 <p><strong><span style="color:#956fe7;">到目前为止，我们编写的程序中所使用的对象都有着严格定义的生存期：</span></strong></p> 
 <ul><li>全局对象：程序启动时分配，在程序结束时销毁。</li><li>局部对象：当我们进入其定义所在的程序块时被创建，在离开块时销毁。</li><li>局部static对象：在第一次使用前分配，在程序结束时销毁。</li></ul> 
 <p><strong><span style="color:#956fe7;">我们的程序到目前为止只使用过静态内存或栈内存：</span></strong></p> 
 <ul><li>静态内存：保存局部static对象、类static数据成员以及定义在任何函数之外的变量。</li><li>栈内存：保存定义在函数内的非static对象。分配在静态或栈内存中的对象由编译器自动创建和销毁。对于栈对象，仅在其定义的程序块运行时才存在；static对象在使用之前分配，在程序结束时销毁。</li></ul> 
</blockquote> 
<p>  📒除了静态内存和栈内存，每个程序还拥有一个<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98%E6%B1%A0&amp;spm=1001.2101.3001.7020" title="内存池">内存池</a>。这部分内存被称作自由空间（free store）或堆（heap）。程序用堆来存储动态分配（dynamically allocate）的对象。动态对象的生存期由程序来控制，也就是说，当动态对象不再使用时，我们的代码必须显式地销毁它们。</p> 
<p></p> 
<h4 id="%C2%A01.1%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"> 1.1 动态内存与<a href="https://so.csdn.net/so/search?q=%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88&amp;spm=1001.2101.3001.7020" title="智能指针">智能指针</a></h4> 
<h5 id="1.1.1%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98">🌸1.1.1 动态内存</h5> 
<p>  📒除了局部和static对象外，C++还支持动态分配对象。动态分配的对象的生存期与它们在哪里创建是无关的，只有当显式地被释放时，这些对象才会销毁。动态对象的正确释放是编程中极其容易出错的地方。为了更安全地使用动态对象，C++标准库定义了两个智能指针类型来管理动态分配的对象。当一个对象应该被释放时，指向它的智能指针可以确保自动地释放它。</p> 
<blockquote> 
 <ul><li>new：在动态内存中为对象分配空间并返回一个指向该对象的指针，我们可以选择对对象进行初始化；</li><li>delete：在受一个动态对象的指针，销毁该对象，并释放与之关联的内存。</li></ul> 
</blockquote> 
<p>但是动态内存的使用很容易出问题；</p> 
<blockquote> 
 <ul><li>内存泄漏：有时我们会忘记释放内存，在这种情况下就会产生<strong>内存泄漏</strong>；</li><li>非法指针：有时在尚有指针引用内存的情况下我们就释放了它，在这种情况下就会产生<strong>引用非法内存的指针</strong>。</li></ul> 
</blockquote> 
<p>  📒C++11为了更容易（同时也更安全）地使用动态内存，新的标准库提供了智能指针（smart pointer）类型来管理动态对象。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。具体说明如下：</p> 
<h5 id="1.1.2%C2%A0%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88">🌸<strong>1.1.2 智能指针</strong></h5> 
<blockquote> 
 <p>        从比较简单的层面来看，智能指针是<span style="color:#956fe7;"> </span><strong><span style="color:#956fe7;">RAII(Resource Acquisition Is Initialization，资源获取即初始化) </span></strong>机制对普通指针进行的一层封装，利用对象生命周期来控制程序资源（如内存、文件句柄、网络连接、互斥量等等）的简单技术。这样使得智能指针的行为动作像一个指针，本质上却是一个对象，这样可以方便管理一个对象的生命周期。</p> 
 <ul><li><strong>智能指针本身： </strong>智能指针是一个类模板的实例，通常作为局部变量存在于栈区（Stack）。当函数返回或者局部变量超出其作用域时，栈区的内存会被自动释放。</li><li><strong>智能指针管理的对象： </strong>智能指针通常用来管理在堆区（Heap）上分配的内存。这是通过调用如new操作符来完成的。堆区的内存会一直存在，直到显式地释放它（<strong>使用delete操作符</strong>）或者<strong>当程序结束时才会被系统回收</strong>。</li></ul> 
 <p><span style="color:#fe2c24;">其实质如下：</span></p> 
 <ul><li> 由于C++中<strong>没有垃圾回收机制</strong>，必须<strong>自己释放掉分配的内存</strong>，否则就会造成<a class="link-info" href="https://so.csdn.net/so/search?spm=1001.2014.3001.4498&amp;q=%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2&amp;t=&amp;u=" title="内存泄露">内存泄露</a>。比如<strong>对于普通的new或者malloc分配空间，需要及时的释放空间，否则容易造成内存泄漏，导致堆区空间不足。但是，随着代码量的增多，很容易忘记释放空间，</strong>解决这个问题最有效的方法是使用<strong>智能指针（smart pointer），其会自动释放。省去手动管理内存</strong>。</li><li>智能指针是存储指向动态分配（堆）对象指针的类，用于生存期的控制，能够确保在离开指针所在作用域时，自动地销毁动态分配的对象，防止内存泄露。智能指针的核心实现技术是<strong><span style="color:#fe2c24;">引用计数</span></strong>，<strong>每使用它一次，内部引用计数加1，计数器的大小等于指向对象的智能指针的数量，每析构一次内部的引用计数减1，减为0时，删除所指向的堆内存</strong>。</li></ul> 
 <p>注意：智能指针的头文件为<span style="color:#be191c;"><strong>&lt;memory&gt;</strong></span></p> 
</blockquote> 
<h4 id="1.2%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7">1.2 智能指针的重要性</h4> 
<p>  📒在C++编程中，<a class="link-info" href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86&amp;spm=1001.2101.3001.7020" title="内存管理">内存管理</a>一直是一个不可或缺的话题。传统的C++程序员依赖<strong>new</strong>和<strong>delete</strong>（新建和删除）来手动管理内存，但是由于new和delete<strong>不能自动管理资源</strong>也<strong>不支持自定义删除器</strong>，导致使用该方式容易导致<a class="link-info" href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F&amp;spm=1001.2101.3001.7020" title="内存泄漏">内存泄漏</a>或是双重释放等问题。这就是智能指针（Smart Pointers）登场的原因。</p> 
<blockquote> 
 <p>在对象构造时获取资源，接着控制对资源的访问使之在对象的生命周期内始终保持有效。</p> 
 <p>在对象析构的时候释放资源。借此，我们实际上把管理一份资源的责任托管给了一个对象。</p> 
 <p>这种做法有两大好处：</p> 
 <ul><li>不需要显式地释放资源。</li><li>采用这种方式，对象所需的资源在其生命期内始终保持有效</li></ul> 
</blockquote> 
<p>  📒智能指针不仅仅是一个指针，它是一个对象，拥有生命周期<strong><span style="color:#1c7892;">（Lifetime）</span></strong>。当智能指针的生命周期结束时，它会自动释放所拥有的资源。这种自动管理机制极大地减少了程序员的负担，也降低了出错的可能性。</p> 
<blockquote> 
 <p><strong><span style="color:#956fe7;">“The best code is no code at all.”</span></strong> - <strong>Jeff Atwood</strong></p> 
</blockquote> 
<p>这句话在这里非常合适。【越少的代码用于管理内存，越少的地方会出错。】智能指针就是这样一种工具，让你能更专注于业务逻辑而非内存管理。</p> 
<h4 id="1.3%20%E5%83%8F%E6%8C%87%E9%92%88%E4%B8%80%E6%A0%B7%E4%BD%BF%E7%94%A8" style="margin-left:0px;">1.3 像指针一样使用</h4> 
<p><strong>下面将用一个自定义智能指针SmartPtr为例：</strong></p> 
<pre><code class="language-cpp">​// 模板
template&lt;class T&gt;
class SmartPtr {
public:
	SmartPtr(T* ptr = nullptr) //当智能指针未初始化时，赋予nullptr缺省值
		: _ptr(ptr)
	{}
	~SmartPtr(){
		if (_ptr)
			delete _ptr;
	}
	T&amp; operator*() { return *_ptr; }
	T* operator-&gt;() { return _ptr; }
private:
	T* _ptr;
};
int main()
{
    SmartPtr&lt;int&gt; p(new int(1));
    cout &lt;&lt; *p &lt;&lt; endl;
    return 0;
}
</code></pre> 
<p>其中重载了<strong><code>*</code>和<code>-&gt;</code></strong>运算符，使得使用这个类就像使用指针一样。<strong>智能指针是一个模板类，以能够管理任何类型的指针引用的内存</strong>，如果<strong>模板参数</strong>是一个有<strong>公有成员的类，那么还能使用<code>-&gt;</code>访问其成员。</strong></p> 
<h4 id="1.4%C2%A0%E6%94%AF%E6%8C%81%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D">1.4 支持智能指针对象拷贝</h4> 
<p>上面实现的智能指针<code>SmartPtr</code>是极不完善的，如果想实现拷贝构造和拷贝赋值：</p> 
<pre><code class="language-cpp">int main(){	
	SmartPtr&lt;int&gt; ap1(new int(1));
	SmartPtr&lt;int&gt; ap2(ap1); //拷贝构造

	SmartPtr&lt;int&gt; ap3(new int(2));
    SmartPtr&lt;int&gt; ap4(new int(2));
    ap4 = ap3; // 拷贝赋值

	return 0;
}</code></pre> 
<p>错误（Clion）：</p> 
<blockquote> 
 <p>malloc: *** error for object 0x600003c84030: pointer being freed was not allocated</p> 
</blockquote> 
<blockquote> 
 <p><strong>造成程序崩溃的原因：</strong>是在这个类中没有实现拷贝构造函数和拷贝赋值函数，而编译器默认生成的全都是对内置类型的浅拷贝（值拷贝）：相当于ap1和ap2、ap3和ap4共同管理同一块空间。当出了ap1的作用域后，调用析构函数，释放空间，ap2再次调用析构函数时导致这块已经被释放的空间再次被释放。ap3和ap4同理。 </p> 
</blockquote> 
<p><span style="color:#fe2c24;">要解决浅拷贝造成的二次析构问题，就必须要去实现深拷贝的拷贝构造函数和拷贝赋值函数吗？</span></p> 
<blockquote> 
 <p><span style="color:#0d0016;">答案是不用的，智能指针的功能需求是模拟指针的使用，本质是帮指针托管资源，那么指针的拷贝或赋值操作就相当于两个指针指向同一块内存空间。资源管理权转移，通过不负责任的拷贝，会导致被拷贝对象悬空。虽然资源能得到释放，但是会造成垂悬指针。智能指针将内存资源的管理和对象的生命周期绑定在一起，如果只是像上面一样简单地满足RAII，那么一定会发生二次析构的问题，因为创建的智能指针对象一定会调用析构函数，且不论程序是否正常结束。</span></p> 
 <ul><li> <p>程序正常结束：对象出了作用域调用析构函数；</p> </li><li> <p>程序不正常结束：例如抛异常，跳转到catch块相当于跳转到另一个函数的栈帧中，也相当于出了作用域，依然调用析构函数。</p> </li></ul> 
</blockquote> 
<p>后面以标准库中（C++98）智能指针<strong><code>auto_ptr</code></strong>为例。</p> 
<p></p> 
<h3 id="2.%20C%2B%2B%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88">2. C++标准库的智能指针</h3> 
<blockquote> 
 <p>在c++中，智能指针一共定义了4种：<br><strong>auto_ptr、unique_ptr、shared_ptr 和 weak_ptr。</strong></p> 
 <p></p> 
 <p>📝其中，auto_ptr 在 C++11已被摒弃，在C++17中已经移除不可用。</p> 
 <p>📙虽然auto_ptr有很多问题，但是也没有取消，因为可能有人在用，因此后面弄了一个</p> 
 <p><a class="link-info" href="https://baike.baidu.com/item/boost/69144?fromModule=lemma_search-box" rel="nofollow" title="Boost库">Boost库</a>，属于C++扩展库（第三方库），不属于C++标准库（C++标准库是写了头文件就能用）</p> 
 <p><span style="color:#0d0016;"><strong>注意：本文主要讲的就是后面的 三种智能指针。</strong></span></p> 
</blockquote> 
<p><img alt="" height="342" src="https://images2.imgbox.com/b6/92/TNS0D50U_o.png" width="1200"></p> 
<blockquote> 
 <p></p> 
</blockquote> 
<table border="1" cellpadding="1" cellspacing="1" style="width:650px;"><tbody><tr><th style="text-align:center;">智能指针</th><th style="text-align:center;">类型</th></tr><tr><td style="text-align:center;">unique_ptr</td><td style="text-align:center;">独占的智能指针，该指针独占对象的所有权，每个对象智能有一个该指针</td></tr><tr><td style="text-align:center;">shared_ptr</td><td style="text-align:center;">共享的智能指针，多个共享指针可以指向同一个对象</td></tr><tr><td style="text-align:center;">weak_ptr</td><td style="text-align:center;">弱引用的智能指针，该指针是对象的一个非拥有性引用，不共享指针，不能操作资源，用来指向一个shared_ptr，主要用来避免shared_ptr<strong>循环引用</strong>导致的内存泄露</td></tr></tbody></table> 
<p>为了方便我们对下面智能之类的理解，我们定义如下的类</p> 
<pre><code class="language-cpp">// Date类
struct Date{
	int _year;
	int _month;
	int _day;

	Date (int year = 1, int month = 1, int day = 1)
		: _year(year)
		, _month(month)
		, _day(day)
	{}

	~Date() {
		cout &lt;&lt; "~Date()" &lt;&lt; endl;
	}
};
//指定删除器模板
template&lt;class T&gt;
class DeleteArray{
public:
	void operator()(T* ptr){
		delete[] ptr;
	}
};
//文件删除的模板
class Fclose{
public:
	void operator()(FILE* ptr){
		cout &lt;&lt; "fclose:" &lt;&lt; ptr &lt;&lt; endl;
		fclose(ptr);
	}
};
//Test类
class Test
{
public:
	Test() : _num(0)
	{
		cout &lt;&lt; "Test() 构造成功..." &lt;&lt; endl;
	}
	Test(int x) : _num(0)
	{
		cout &lt;&lt; "Test(int x) 构造成功, x = " &lt;&lt; x &lt;&lt; endl;
	}
	Test(string str) : _num(0)
	{
		cout &lt;&lt; "Test(string str) 构造成功, str = " &lt;&lt; str &lt;&lt; endl;
	}
	~Test()
	{
		cout &lt;&lt; "~Test() 析构成功..." &lt;&lt; endl;
	}
	void setValue(int v)
	{
		this-&gt;_num = v;
	}
	void print()
	{
		cout &lt;&lt; "_num: " &lt;&lt; this-&gt;_num &lt;&lt; endl;
	}
private:
	int _num;
};

</code></pre> 
<hr> 
<h4 id="2.1%20auto_ptr">2.1 auto_ptr</h4> 
<h5 id="2.1.1%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">🌈2.1.1 基本概念</h5> 
<p>为了解决上面1.4 里面的问题，由于出现多次析构问题的本质是同一块内存空间被多个对象通过管理，因此如果将资源的管理权只交给一个对象，就不会出现多次析构问题。</p> 
<p><img alt="" height="461" src="https://images2.imgbox.com/03/da/d3ijESeD_o.png" width="1200"></p> 
<h5 id="2.1.2%C2%A0%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95" style="margin-left:0px;">🌈<span style="color:#0d0016;"><span style="background-color:#ffffff;">2.1.2 基本用法</span></span></h5> 
<pre><code class="language-cpp">int main(){	
	auto_ptr&lt;Date&gt; ap1(new Date);
	//拷贝时，管理权限转移，被拷贝悬空
	auto_ptr&lt;Date&gt; ap2(ap1);
	//下面这样会使程序会崩，因为auto_ptr的拷贝是管理权转移，这样就会导致ap1空了
	ap1-&gt;_year++;

	return 0;
}</code></pre> 
<blockquote> 
 <p>然而，将一个对象对资源的管理权转移后，就意味着这个对象再对资源访问是一个非法操作，程序会因此崩溃。如果让不熟悉auto_ptr原理的人使用，因为<strong>拷贝操作</strong>而造成非法指针或内存泄漏是有可能的<strong>（拷贝悬空）</strong>，而这也是致命的错误，因此许多公司<strong>明文规定禁止auto_ptr的使用</strong>，<strong>进而由C++11的unique_ptr和shared_ptr取代</strong>。</p> 
</blockquote> 
<hr> 
<h4 id="2.2%C2%A0unique_ptr">2.2 unique_ptr</h4> 
<h5 id="2.2.1%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">✨2.2.1 基本概念</h5> 
<p>出现多次析构问题的本质是同一块内存空间被多个对象通过管理，如果将资源的管理权只交给一个对象，就不会出现多次析构问题。</p> 
<p>C++98的auto_ptr因为拷贝和赋值操作而造成内存泄漏和悬垂指针的问题而饱受诟病，C++11引入的unique_ptr则粗暴地砍掉了它的拷贝和赋值功能。这通过C++11引入的关键字<span style="color:#fe2c24;">delete</span>的新功能实现。</p> 
<p><span style="color:#fe2c24;">在C++11之前，可以通过将构造函数和拷贝赋值函数私有声明实现。</span></p> 
<p></p> 
<blockquote> 
 <p>🌞它实现对对象的独占所有权语义。这意味着一个unique_ptr在任何时候都指向一个对象，而且这个对象只能由一个unique_ptr拥有。当unique_ptr被销毁（例如离开其作用域）时，它所指向的对象也会被自动删除。</p> 
</blockquote> 
<h5 id="2.2.1%20%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">✨2.2.2 基本用法</h5> 
<p><strong><span style="color:#4da8ee;">样例1：（初概）</span></strong></p> 
<pre><code class="language-cpp">int main() {
	unique_ptr&lt;Date&gt; up1(new Date);
	//不支持拷贝
	//unique_ptr&lt;Date&gt; up2(up1);
	
	//unique_ptr&lt;Date&gt; up2(new Date[6]); //error，因为类型不匹配，由于我们是用new []构造的，那么就要用delete[]去销毁
	//定制删除器解决上述问题
	unique_ptr&lt;Date, DeleteArray&lt;Date&gt;&gt; up2(new Date[6]); //用定制的删除器
	//unique_ptr&lt;Date[]&gt; up2(new Date[5]);
	unique_ptr&lt;FILE, Fclose&gt; up3(fopen("test.cpp", "r"));

	return 0;
}</code></pre> 
<h4></h4> 
<p><img alt="" height="238" src="https://images2.imgbox.com/b8/d3/zCuQJNLG_o.png" width="934"></p> 
<p><span style="color:#4da8ee;"><strong>样例2：（详细）</strong></span></p> 
<blockquote> 
 <p><strong>1. 初始化</strong></p> 
 <ul><li>std::unique_ptr是一个独占型的智能指针，它不允许其他的智能指针共享其内部的指针，可以通过它的构造函数初始化一个独占智能指针对象，但是不允许通过赋值将一个unique_ptr赋值给另一个unique_ptr。</li></ul> 
 <p><strong> 2. 指定删除器</strong></p> 
 <ul><li> unique_ptr指定删除器和shared_ptr指定删除器是有区别的，unique_ptr指定删除器的时候需要确定删除器的类型，所以不能像shared_ptr那样直接指定删除器</li></ul> 
</blockquote> 
<pre><code class="language-cpp">int main()
{
	/*--------------------------  一，初始化智能指针unique_ptr  ------------------------------*/
	// 1.通过构造函数初始化
	unique_ptr&lt;int&gt; up1(new int(3));

	//unique_ptr&lt;int&gt; up = up1;  // 编译错误，不能复制

	// 2.通过移动函数初始化
	unique_ptr&lt;int&gt; up2 = move(up1); // 现在up2独占资源，up1变为空

	// 3.通过reset,释放资源并将指针置为空，然后再初始化
	up1.reset(new int(7));
	
	//对比reset，release会释放资源的所有权但不删除，返回原始指针
	up1.release();

	/*--------------------------  二，unique_ptr的使用  ------------------------------*/
	//1.方法一
	unique_ptr&lt;Test&gt; up3(new Test(666));
	Test* pt = up3.get();
	pt-&gt;setValue(6);
	pt-&gt;print();

	//2.方法二
	up3-&gt;setValue(777);
	up3-&gt;print();

	/*------------------------------------  三，指定删除器  -----------------------------------*/
	1.函数指针类型
	//using ptrFunc = void(*)(Test*);
	//unique_ptr&lt;Test, ptrFunc&gt; up4(new Test("hello"), [](Test* t) {
	//    cout &lt;&lt; "-----------------------" &lt;&lt; endl;
	//    delete t;
	//    });

	//2.仿函数类型（利用可调用对象包装器）
	unique_ptr&lt;Test, function&lt;void(Test*)&gt;&gt; up4(new Test("hello"), [](Test* t) {
		cout &lt;&lt; "-----------------------" &lt;&lt; endl;
		delete t;
		});

	/*---------- 四，独占(共享)的智能指针可以管理数组类型的地址，能够自动释放 ---------*/
	unique_ptr&lt;Test[]&gt; up5(new Test[3]);

	//在c++11中shared_ptr不支持下面的写法，c++11以后才支持的
	shared_ptr&lt;Test[]&gt; up6(new Test[3]);

	return 0;
}</code></pre> 
<p><img alt="" height="558" src="https://images2.imgbox.com/35/0f/GiUvGAc3_o.png" width="1017"></p> 
<hr> 
<h4 id="2.3%C2%A0shared_ptr"><strong>2.3 shared_ptr</strong></h4> 
<h5 id="2.3.1%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%8E%9F%E7%90%86">🎈<strong>2.3.1 基本概念</strong></h5> 
<blockquote> 
 <p>🌙shared_ptr是C++11的智能指针，通过引用计数的方式解决智能指针的拷贝问题。</p> 
 <p>🌙每个被管理的资源有<strong>有一个对应的引用计数</strong>，这个引用计数记录当前有多少对象在管理这块资源。</p> 
 <p>🌙每<strong>新增加一个对象管理这块资源则对该资源的引用计数++，</strong>当<strong>一个对象不在管理这块资源或对象析构时那么该资源对应的引用计数 – –，</strong>当一个资源的<strong>引用计数为0时那么就说明已经没有对象在管理这块资源了，这时候就可以进行释放了。</strong></p> 
 <p>引用计数的方式能够支持多个对象一起管理一个资源，也就支持智能指针的拷贝，只有当资源的引用计数减为0时才会释放，保证了同一个资源不会被多次释放：</p> 
 <p>🌙实现了对象的共享所有权语义。多个shared_ptr可以指向同一个对象，并且每个shared_ptr持有一个引用计数。当最后一个指向某个对象的shared_ptr被销毁或重置时，该对</p> 
 <p>象才会被删除。</p> 
</blockquote> 
<h5 id="2.3.2%20%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">🎈2.3.2 基本用法</h5> 
<p><strong><span style="color:#4da8ee;">样例1：（初概）</span></strong></p> 
<pre><code class="language-cpp">int main() {
	//vector&lt;shared_ptr&lt;Date&gt;&gt; v;
	shared_ptr&lt;Date&gt; sp1(new Date);
	shared_ptr&lt;Date&gt; sp2(sp1);
	shared_ptr&lt;Date&gt; sp3(sp2);

	cout &lt;&lt; sp1.use_count() &lt;&lt; endl; //查看其引用计数
	
	//定制删除器
	shared_ptr &lt;Date[]&gt; sp4(new Date[5]);
	//shared_ptr&lt;FILE, Fclose&gt; up5(fopen("test.cpp", "r")); //不支持传这个模板参数
	shared_ptr&lt;FILE&gt; up5(fopen("test.cpp", "r"), Fclose());

	shared_ptr&lt;Date&gt; sp6 = make_shared&lt;Date&gt;(2024, 8, 5);
	shared_ptr&lt;int&gt; sp7((int*)malloc(40), [](int* ptr)
		{
			cout &lt;&lt; "free：" &lt;&lt; ptr &lt;&lt; endl;
			free(ptr);
		});

	return 0;
}</code></pre> 
<p><img alt="" height="192" src="https://images2.imgbox.com/ea/94/RrxXdtPy_o.png" width="378"></p> 
<blockquote> 
 <p><strong>1. 初始化</strong></p> 
 <ul><li>共享智能指针是指多个智能指针可以同时管理同一块有效的内存，共享智能指针shared_ptr 是一个模板类，如果要进行初始化有三种方式：通过构造函数、std::<a href="https://so.csdn.net/so/search?q=make_shared&amp;spm=1001.2101.3001.7020" title="make_shared">make_shared</a>辅助函数以及reset方法。共享智能指针对象初始化完毕之后就指向了要管理的那块堆内存，如果想要查看当前有多少个智能指针同时管理着这块内存可以使用共享智能指针提供的一个成员函数use_count</li></ul> 
 <p>shared_ptr通过一个指针保持对一个对象的共享所有权。多个shared_ptr对象可以拥有同一个对象。当以下情况之一发生时，对象被销毁并释放其内存：</p> 
 <ul><li>拥有该对象的最后一个shared_ptr被销毁；</li><li>通过reset()函数将shared_ptr赋值为另一个指针。</li></ul> 
 <p><span style="color:#0d0016;"><strong>2. 获取原始指针</strong></span></p> 
 <ul><li> <p></p> <p><span style="color:#0d0016;">对应基础数据类型来说，通过操作智能指针和操作智能指针管理的内存效果是一样的，可以直接完成数据的读写。但是如果共享智能指针管理的是一个对象，那么就需要取出原始内存的地址再操作，可以调用共享智能指针类提供的get()方法得到原始地址</span></p> <p></p> </li></ul> 
 <p><strong> 3. 指定删除器</strong></p> 
 <ul><li>  当智能指针管理的内存对应的引用计数变为0的时候，这块内存就会被智能指针析构掉了。另外，我们在初始化智能指针的时候也可以自己指定删除动作，这个删除操作对应的函数被称之为删除器，这个删除器函数本质是一个回调函数，我们只需要进行实现，其调用是由智能指针完成的。</li></ul> 
 <p><strong>4. 引用计数</strong></p> 
 <ul><li>auto_ptr转移资源后造成内存泄漏和悬垂指针的主要原因就是每个auto_ptr智能指针对象管理的资源是各自独立的，非此即彼。shared_ptr共享同一个资源，内存资源只在最后一个智能指针解除引用时释放，这样就不会造成资源被单方面地接管造成的问题。</li><li>引用计数使得一个空间可以被多个对象管理，当引用计数为0时，说明已经没有智能指针管理这块内存空间了，此时才能释放资源，弥补了auto_ptr的缺陷。要知道引用计数的值，只需要调用shared_ptr的成员函数use_count()即可。</li></ul> 
 <p><img alt="" height="730" src="https://images2.imgbox.com/54/29/mr4IGLAh_o.png" width="1200"></p> 
</blockquote> 
<p><span style="color:#4da8ee;"><strong>样例2：（详细）</strong></span></p> 
<pre><code class="language-cpp">int main()
{
	/*----------------------------  一，初始化智能指针shared_ptr  ------------------------------*/
	// 1.通过构造函数初始化
	shared_ptr&lt;int&gt; sp1(new int(3));
	cout &lt;&lt; "sp1管理的内存引用计数：" &lt;&lt; sp1.use_count() &lt;&lt; endl;

	// 2.通过移动和拷贝构造函数初始化
	shared_ptr&lt;int&gt; sp2 = move(sp1);
	cout &lt;&lt; "sp1管理的内存引用计数：" &lt;&lt; sp1.use_count() &lt;&lt; endl;
	cout &lt;&lt; "sp2管理的内存引用计数：" &lt;&lt; sp2.use_count() &lt;&lt; endl;

	shared_ptr&lt;int&gt; sp3 = sp2; //赋值
	cout &lt;&lt; "sp2管理的内存引用计数: " &lt;&lt; sp2.use_count() &lt;&lt; endl;
	cout &lt;&lt; "sp3管理的内存引用计数: " &lt;&lt; sp3.use_count() &lt;&lt; endl;

	// 3.通过 std::make_shared初始化
	shared_ptr&lt;int&gt; sp4 = make_shared&lt;int&gt;(8);
	shared_ptr&lt;Test&gt; sp5 = make_shared&lt;Test&gt;(7);
	shared_ptr&lt;Test&gt; sp6 = make_shared&lt;Test&gt;("Love Life");

	// 4.通过reset初始化
	sp6.reset();//重置sp6, ps6的引用基数为0
	cout &lt;&lt; "sp6管理的内存引用计数: " &lt;&lt; sp6.use_count() &lt;&lt; endl;

	sp5.reset(new Test("hello")); //重置了指针的指向对象，原来的对象已经释放
	cout &lt;&lt; "sp5管理的内存引用计数: " &lt;&lt; sp5.use_count() &lt;&lt; endl;

	cout &lt;&lt; endl &lt;&lt; endl;

	/*-----------------------------  二，共享智能指针shared_ptr的使用  ------------------------------*/
	// 1.方法一
	Test* t = sp5.get();
	t-&gt;setValue(1000);
	t-&gt;print();

	// 2.方法二
	sp5-&gt;setValue(7777);
	sp5-&gt;print();

	cout &lt;&lt; endl &lt;&lt; endl;

	///*------------------------------  三，指定删除器  -----------------------------------*/
	 // 1.简单举例
	shared_ptr&lt;Test&gt; ppp(new Test(100), [](Test* t) {
		//释放内存
		cout &lt;&lt; "Test对象的内存被释放了......." &lt;&lt; endl;
		delete t;
		});
	printf("----------------------------------------------------------------------\n");

	 2.如果是数组类型的地址，就需要自己写指定删除器，否则内存无法全部释放
	//	//shared_ptr&lt;Test&gt; p1(new Test[5], [](Test* t) {
	//	//    delete[]t;
	//	//    });

	3.也可以使用c++给我们提供的 默认删除器函数（函数模板）
	shared_ptr&lt;Test&gt; p2(new Test[3], default_delete&lt;Test[]&gt;());

	4.c++11以后可以这样写 也可以自动释放内存
	shared_ptr&lt;Test[]&gt; p3(new Test[3]);

	return 0;
}</code></pre> 
<p><img alt="" height="797" src="https://images2.imgbox.com/39/7c/9xJQ6ahS_o.png" width="1200"></p> 
<p> 此外我们还可以封装一个函数模板make_shared_array方法来让shared_ptr支持数组：</p> 
<pre><code class="language-cpp">template &lt;typename T&gt;
shared_ptr&lt;T&gt; make_share_array(size_t size)
{
	//返回匿名对象
	return shared_ptr&lt;T&gt;(new T[size], default_delete&lt;T[]&gt;());
}

int main()
{
	shared_ptr&lt;int&gt; ptr1 = make_share_array&lt;int&gt;(10);
	cout &lt;&lt; ptr1.use_count() &lt;&lt; endl;

	shared_ptr&lt;string&gt; ptr2 = make_share_array&lt;string&gt;(7);
	cout &lt;&lt; ptr2.use_count() &lt;&lt; endl;
}</code></pre> 
<h5 id="2.3.3%20%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">🎈2.3.3 注意事项</h5> 
<blockquote> 
 <p>        shared_ptr中的引用计数是存放在堆区，因为这样可以让所有指向同一个对象的shared_ptr。如果<strong>引用计数在栈区</strong>，那么<strong>当一个shared_ptr改变指向或者离开作用域时</strong>，就<strong>无法通知其他shared_ptr更新引用计数</strong>了。因此，<strong>引用计数也不能是静态成员，每个类型实例化的智能指针对象时共用静态成员，这会导致管理相同资源的对象和管理不同资源的对象共用同一个引用计数。</strong></p> 
 <p>由于在堆区的引用计数和同一类型的智能指针是绑定在一起的，当智能指针释放资源时，也需要释放引用计数占用的内存。</p> 
</blockquote> 
<hr> 
<h4 id="2.4%C2%A0weak_ptr">2.4 weak_ptr</h4> 
<h5 id="2.4.1%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">🧩2.4.1 基本概念</h5> 
<blockquote> 
 <p>⭐弱引用智能指针std::weak_ptr可以看做是shared_ptr的助手，是对shared_ptr所管理对象的一个非拥有性引用，它不管理shared_ptr内部的指针。std::weak_ptr没有重载操作符*和-&gt;，因为它<strong>不共享指针，不能操作资源</strong>，所以它的构造<strong>不会增加引用计数</strong>，<strong>析构也不会减少引用计数。</strong>最后一个指向对象的shared_ptr被销毁时，无论是否还有weak_ptr指向该对象，对象都会被删除。它的主要作用就是作为一个旁观者监视shared_ptr中管理的资源是否存在，<strong>解决shared_ptr可能导致的循环引用问题</strong>。</p> 
 <p>在这部分利用率局部变量的特性，C++的局部变量存在栈中，当变量的生命周期结束后，那栈会自动释放空间。而智能指针同样为局部变量，存在栈中。</p> 
</blockquote> 
<h5 id="2.4.2%20%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">🧩2.4.2 基本用法</h5> 
<p><strong><span style="color:#4da8ee;">样例1：（初概）</span></strong></p> 
<pre><code class="language-cpp">// ———————— weadk_ptr ——————————
int main()
{
	// weak_ptr不支持管理资源，不支持RAII
	//std::weak_ptr&lt;Date&gt; wp1(new Date);

	weak_ptr&lt;Date&gt; wp;
	shared_ptr&lt;Date&gt; sp; //保证不过期
	{
		shared_ptr&lt;Date&gt; n1(new Date);
		wp = n1;
		cout &lt;&lt; wp.expired() &lt;&lt; endl;
		n1-&gt;_day++;
		//sp = wp.lock();

	}
	// 出了作用域就失效了
	cout &lt;&lt; wp.expired() &lt;&lt; endl;

}</code></pre> 
<p><img alt="" height="105" src="https://images2.imgbox.com/1d/ad/YR2WC4Hs_o.png" width="656"></p> 
<p><span style="color:#4da8ee;"><strong>样例2：（详细）</strong></span></p> 
<blockquote> 
 <p>std::weak_ptr底层与std::shared_ptr共享相同的引用计数机制，但不会增加计数。</p> 
</blockquote> 
<pre><code class="language-cpp">
int main()
{
	/*----------------------------  一，初始化智能指针weak_ptr  ------------------------------*/
    // weak_ptr不支持管理资源，不支持RAII
	shared_ptr&lt;int&gt; sp(new int(2));

	weak_ptr&lt;int&gt; wp1;; //构造了一个空weak_ptr对象
	weak_ptr&lt;int&gt; wp2(wp1); //通过一个空weak_ptr对象构造了另一个空weak_ptr对象
	weak_ptr&lt;int&gt; wp3(sp); //通过一个shared_ptr对象构造了一个可用的weak_ptr实例对象

	weak_ptr&lt;int&gt; wp4; 
	wp4 = sp; //通过一个shared_ptr对象构造了一个可用的weak_ptr实例对象（这是一个隐式类型转换）

	weak_ptr&lt;int&gt; wp5;
	wp5 = wp3; //通过一个weak_ptr对象构造了一个可用的weak_ptr实例对象

	/*----------------------------  二，weak_ptr常用函数  ------------------------------*/
	
	// 1.通过调用weak_ptr类提供的use_count()方法可以获得当前共享该资源的shared_ptr数量
	cout &lt;&lt; "wp1管理的shared_ptr内存引用计数：" &lt;&lt; wp1.use_count() &lt;&lt; endl;
	cout &lt;&lt; "wp2管理的shared_ptr内存引用计数：" &lt;&lt; wp2.use_count() &lt;&lt; endl;
	cout &lt;&lt; "wp3管理的shared_ptr内存引用计数：" &lt;&lt; wp3.use_count() &lt;&lt; endl;

	cout &lt;&lt; "wp4管理的shared_ptr内存引用计数：" &lt;&lt; wp4.use_count() &lt;&lt; endl;
	cout &lt;&lt; "wp5管理的shared_ptr内存引用计数：" &lt;&lt; wp5.use_count() &lt;&lt; endl;

	cout &lt;&lt; endl &lt;&lt; endl;

	// 2.通过调用std::weak_ptr类提供的expired()方法来判断
	//判断指针所指的内存空间是否被释放掉 / 指针是否为空 / 是否还有shared_ptr指针指向weak_ptr指向的内存空间
	shared_ptr&lt;int&gt; sp2 = make_shared&lt;int&gt;(10);
	weak_ptr&lt;int&gt; wp6(sp2); // shared_ptr初始化weak_ptr  
	sp2.reset(new int); // 此时，已没有一个shared_ptr指针指向weak_ptr指向的内存区域  
	cout &lt;&lt; "是否已没有shared_ptr指针指向该内存区域：" &lt;&lt; wp6.expired() &lt;&lt; endl;
	shared_ptr&lt;int&gt; sp22 = nullptr;
	weak_ptr&lt;int&gt; wp7(sp22);
	cout &lt;&lt; "weak_ptr指针是否为空：" &lt;&lt; wp7.expired() &lt;&lt; endl;

	// 3.通过调用weak_ptr类提供的lock()方法来获取管理所监测资源的shared_ptr对象,返回一个shared_ptr，增加引用计数
	shared_ptr&lt;int&gt; sp3 = wp3.lock(); // 利用返回的shared_ptr初始化  
	cout &lt;&lt; "share_ptr的初始化为：" &lt;&lt;*sp3 &lt;&lt; endl;
	cout &lt;&lt; "wp3管理的shared_ptr内存引用计数：" &lt;&lt; wp3.use_count() &lt;&lt; endl;

	return 0;
}</code></pre> 
<h5 id="2.4.3%20%E5%AF%B9%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E7%9A%84%E8%A7%A3%E5%86%B3">🧩2.4.3 对循环引用的解决</h5> 
<p>假如存在这样的一个结构体</p> 
<pre><code class="language-cpp">struct ListNode{
	int _data;
	shared_ptr&lt;ListNode&gt; _next;
	shared_ptr&lt;ListNode&gt; _prev;
	//用weak_ptr就可以避免内存泄露
	//weak_ptr&lt;ListNode&gt; _next;
	//weak_ptr&lt;ListNode&gt; _prev;
	~ListNode()
	{
		cout &lt;&lt; "~ListNode()" &lt;&lt; endl;
	}
};</code></pre> 
<p> 情况一：当我们在shaed_ptr的正常情况下未出现内存泄露</p> 
<pre><code class="language-cpp">int main()
{
	// 下面这就是循环引用 --&gt; 内存泄露
	std::shared_ptr&lt;ListNode&gt; n1(new ListNode);
	std::shared_ptr&lt;ListNode&gt; n2(new ListNode);

	n1-&gt;_next = n2;
	//n2-&gt;_prev = n1; //互相指向，就会出现内存泄露

	cout &lt;&lt; n1.use_count() &lt;&lt; endl;
	cout &lt;&lt; n2.use_count() &lt;&lt; endl;

	return 0;
}</code></pre> 
<p><img alt="" height="227" src="https://images2.imgbox.com/f4/13/EHQm7X8x_o.png" width="1200"></p> 
<p><img alt="" height="139" src="https://images2.imgbox.com/13/7a/u9ov0YLM_o.png" width="1032"></p> 
<p>情况二：当我们增加一句<strong>n2-&gt;_prev = n1;</strong> 到函数中，此时就出现了互相指向，导致了<strong>内存泄露</strong></p> 
<p><img alt="" height="387" src="https://images2.imgbox.com/6e/6b/RRNAxfXX_o.png" width="1200"></p> 
<p></p> 
<p><img alt="" height="121" src="https://images2.imgbox.com/39/5b/SvN3yUR8_o.png" width="1200"></p> 
<p>情况三：造成问题的本质是引用计数永不为0，那么只要将其中一个智能指针改为weak_ptr即可：</p> 
<p><img alt="" height="129" src="https://images2.imgbox.com/47/2c/kPdaJOgN_o.png" width="899"></p> 
<h5 id="2.4.4%20%E4%B8%8Eshared_ptr%E7%9A%84%E5%85%B3%E7%B3%BB">🧩2.4.4 与shared_ptr的关系</h5> 
<p>🌸由上面可知：<strong>weak_ptr</strong>是为了配合<strong>shared_ptr</strong>而引入的一种智能指针，它指向一个由<strong>shared_ptr</strong>管理的对象而不影响所指对象的生命周期。也就是将一个<strong>weak_ptr绑定到一个shared_ptr</strong>不会改变shared_ptr的引用计数。</p> 
<p>🌸它只可以从一个<strong> shared_ptr</strong> 或另一个 <strong>weak_ptr </strong>对象构造，它的<strong>构造和析构不会引起引用记数的增加或减少。弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存。</strong></p> 
<blockquote> 
 <p>也就是说，weak_ptr是为了弥补shared_ptr循环引用而生的，它没有RAII的特性，不直接管理资源，只是shared_ptr的跟班，这也是weak_ptr支持使用shared_ptr构造的原因。</p> 
 <p>在使用上，weak_ptr支持指针所有的操作。它不是一个功能型的智能指针，而是辅助型，它的使命是解决shared_ptr造成的循环引用问题。</p> 
</blockquote> 
<p>🌸与 shared_ptr 不同，weak_ptr 不能直接访问所指向的对象。要访问对象，需要先调用 lock() 方法将其转换为 shared_ptr。如果所指向的对象已经被销毁，则 lock() 方法返回空指针。</p> 
<p></p> 
<h3 id="3.%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%9E%E7%8E%B0">3. 智能指针的实现</h3> 
<p><strong>📚</strong>看完前面其智能指针的实现，相信大家对智能指针也有个大概的了解了，下面我们来实现部分的智能指针吧，如unique_ptr、shared_ptr、weak_ptr.</p> 
<blockquote> 
 <p>智能指针的实现，必须解决下面三个问题：</p> 
 <ul><li>RAII，将资源交给对象的生命周期管理，即构造对象时开始获取（管理）资源，析构对象时释放资源；</li><li>像真正的指针一样使用；</li><li>支持智能指针对象的拷贝。</li></ul> 
 <p>其中最容易实现的是像指针一样使用，只要重载使用指针的运算符即可。其次是实现RAII，最后是智能指针对象的拷贝。</p> 
</blockquote> 
<h4 id="3.1%20auto_ptr%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">3.1 auto_ptr模拟实现</h4> 
<p>auto_ptr的实现原理：管理权转移的思想</p> 
<blockquote> 
 <ul><li> <p><strong>析构函数：</strong>需要对它管理的指针判空，只有指针非空时才能对其进行释放资源操作，释放资源以后对其置空。</p> </li><li> <p><strong>拷贝构造函数：</strong>用传入对象管理的内存资源来构造当前对象，并将传入对象管理资源的指针置空。</p> </li><li> <p><strong>拷贝赋值函数：</strong>先将当前对象管理的资源释放，然后再接管传入对象管理的资源，最后将传入对象管理资源的指针置空。</p> </li></ul> 
</blockquote> 
<pre><code class="language-cpp">namespace qian {
	template&lt;class T&gt;
	class auto_ptr
	{
	public:
		auto_ptr(T* ptr)
			:_ptr(ptr)
		{}
		auto_ptr(auto_ptr&lt;T&gt;&amp; sp)
			:_ptr(sp._ptr)
		{
			// 管理权转移
			sp._ptr = nullptr;
		}
		auto_ptr&lt;T&gt;&amp; operator=(auto_ptr&lt;T&gt;&amp; ap)
		{
			// 检测是否为自己给自己赋值
			if (this != &amp;ap)
			{
				// 释放当前对象中资源
				if (_ptr)
					delete _ptr;
				// 转移ap中资源到当前对象中
				_ptr = ap._ptr;
				ap._ptr = NULL;
			}
			return *this;
		}
		~auto_ptr()
		{
			if (_ptr)
			{
				cout &lt;&lt; "delete:" &lt;&lt; _ptr &lt;&lt; endl;
				delete _ptr;
			}
		}
		// 像指针一样使用
		T&amp; operator*()
		{
			return *_ptr;
		}
		T* operator-&gt;()
		{
			return _ptr;
		}
	private:
		T* _ptr;
	};</code></pre> 
<h4 id="3.2%C2%A0unique_ptr%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">3.2 unique_ptr模拟实现</h4> 
<p>模拟实现的过程：去除auto_ptr中拷贝和赋值的函数。</p> 
<p><strong>📚注意：</strong>C++98中，delete的意思是不让编译器自动生成默认函数，而C++11为了实现这个智能指针，赋予delete一个新功能：不允许调用，因此我们在下面的拷贝和赋值中用到了<span style="color:#ff9900;"><strong>delete</strong></span>。</p> 
<pre><code class="language-cpp">namespace qian
{
    template&lt;class T&gt;
    class unique_ptr
    {
    public:
        unique_ptr(T* ptr = nullptr)
                :_ptr(ptr)
        {}
        ~unique_ptr()
        {
            if (_ptr != nullptr)
            {
                cout &lt;&lt; "delete:" &lt;&lt; _ptr &lt;&lt; endl;
                delete _ptr;
                _ptr = nullptr;
            }
        }
        unique_ptr(auto_ptr&lt;T&gt;&amp; ap) = delete;
        unique_ptr&amp; operator=(auto_ptr&lt;T&gt;&amp; ap) = delete;

        T&amp; operator*()
        {
            return *_ptr;
        }
        T* operator-&gt;()
        {
            return _ptr;
        }
    private:
        T* _ptr;
    };
}
int main()
{
    qian::unique_ptr&lt;int&gt; up1(new int);
    qian::unique_ptr&lt;int&gt; up2(new int);
    up2 = up1; // error

    return 0;
}
</code></pre> 
<h4 id="3.3%C2%A0shared_ptr%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">3.3 shared_ptr模拟实现</h4> 
<blockquote> 
 <ul><li>增加count成员变量，表示引用计数；</li><li>构造函数：当获取到资源则设置count=1，表示当前只有一个智能指针对象管理此资源；</li><li>拷贝构造函数：将传入的智能指针对象中的count++，表示新增了一个管理者；</li><li>拷贝赋值函数：将本智能指针的count--，表示解除对当前资源的引用，然后再将传入的智能</li><li>指针对象中的count++，表示管理新的资源；</li><li>析构函数：count--，表示解除对当前管理资源的引用，如果count=0则释放资源；</li><li>重载*和-&gt;运算符，使shared_ptr对象具有指针一样的行为。</li></ul> 
 <p><span style="color:#fe2c24;">其中，operator = 的重载需要注意两个问题：</span></p> 
 <ul><li>内存泄漏：赋值时要把自己的引用计数给对方，赋值代表对方要共同接管自己管理的资源，所以对方的引用计数也要 - 1；</li><li>自我赋值：本质也会造成内存泄漏，自我赋值后资源的管理权并未发生变化，但是引用计数却 + 1了，到真正最后一个对象时，引用计数仍不为0（如果自我赋值1次，那就是1），造成资源不能释放，内存泄漏。</li></ul> 
</blockquote> 
<pre><code class="language-cpp">namespace qian 
{
    template&lt;class T&gt;
    class shared_ptr
    {
    public:
        shared_ptr(T* ptr = nullptr)
            :_ptr(ptr)
            , _pcount(new int(1))
        {}
        ~shared_ptr()
        {
            if (--(*_pcount) == 0)
            {
                if (_ptr != nullptr)
                {
                    cout &lt;&lt; "delete:" &lt;&lt; _ptr &lt;&lt; endl;
                    delete _ptr;
                    _ptr = nullptr;
                }
                delete _pcount;
                _pcount = nullptr;
            }
        }
        shared_ptr(shared_ptr&lt;T&gt;&amp; sp)
            :_ptr(sp._ptr)
            , _pcount(sp._pcount)
        {
            (*_pcount)++;
        }
        shared_ptr&lt;T&gt;&amp; operator=(shared_ptr&lt;T&gt;&amp; sp)
        {
            if (_ptr != sp._ptr)       // 管理同一资源的智能指针赋值无意义
            {
                if (--(*_pcount) == 0) // 将管理的资源的引用计数-1
                {
                    cout &lt;&lt; "delete:" &lt;&lt; _ptr &lt;&lt; endl;
                    delete _ptr;
                    delete _pcount;
                }
                _ptr = sp._ptr;       // 与传入的智能指针共享资源
                _pcount = sp._pcount; // 将自己的引用计数和传入的智能指针同步
                (*_pcount)++;         // 引用计数+1,表示自己是新增的管理者
            }
            return *this;
        }
        // 获取引用计数
        int use_count()
        {
            return *_pcount;
        }
        T&amp; operator*()
        {
            return *_ptr;
        }
        T* operator-&gt;()
        {
            return _ptr;
        }
    private:
        T* _ptr;
        int* _pcount; // 引用计数
    };
}


int main(){
    qian::shared_ptr&lt;int&gt; sp1(new int(1));
    cout &lt;&lt; sp1.use_count() &lt;&lt; endl;
    qian::shared_ptr&lt;int&gt; sp2(sp1);
    cout &lt;&lt; sp1.use_count() &lt;&lt; endl;
    cout &lt;&lt; sp2.use_count() &lt;&lt; endl;

    qian::shared_ptr&lt;int&gt; sp3(new int(0));
    cout &lt;&lt; sp3.use_count() &lt;&lt; endl;

    qian::shared_ptr&lt;int&gt; sp4(new int(2));
    sp3 = sp4;
    cout &lt;&lt; sp3.use_count() &lt;&lt; endl;
    cout &lt;&lt; sp4.use_count() &lt;&lt; endl;

    return 0;
}
</code></pre> 
<h4 id="3.4%C2%A0weak_ptr%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">3.4 weak_ptr模拟实现</h4> 
<blockquote> 
 <ul><li>构造函数：无参构造</li><li>拷贝构造：支持参数是shared_ptr类型和本身类型构造，同时接管shared_ptr管理的资源，但不增加引用计数</li><li>拷贝赋值：同上。智能指针一般有<code>get()</code>接口，所以返回指针时可以调用</li><li>像指针一样</li></ul> 
</blockquote> 
<pre><code class="language-cpp">namespace qian
{
    template&lt;class T&gt;
    class weak_ptr
    {
    public:
        weak_ptr()
            :_ptr(nullptr)
        {}
        weak_ptr(const shared_ptr&lt;T&gt;&amp; sp)
            :_ptr(sp.get()) //sp的get接口在share_pr中已实现，如上
        {}
        weak_ptr&amp; operator=(const shared_ptr&lt;T&gt;&amp; sp)
        {
            //_ptr = sp._shared_ptr;
            _ptr = sp.get();
            return *this;
        }
        T&amp; operator*()
        {
            return *_ptr;
        }
        T* operator-&gt;()
        {
            return _ptr;
        }
    private:
        T* _ptr;
    };
}
</code></pre> 
<h3></h3> 
<hr> 
<h3 id="%F0%9F%93%96%E6%80%BB%E7%BB%93">📖总结</h3> 
<blockquote> 
 <p>以上就是智能指针的全部内容啦，后面我会单独出一篇关于自定义删除器的博客，敬请期待咯！！！</p> 
 <p>💞 💞 💞<strong>那么本篇到此就结束，希望我的这篇博客可以给你提供有益的参考和启示，感谢大家支持！！！祝大家天天开心。</strong></p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/88/6b/1SzDjTDe_o.gif"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b28057106774deb25e2e51be51a780a6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">什么是云原生？（二）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/73a25758de1d2e37234008e498d2645f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">决策树算法:原理及实例应用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>