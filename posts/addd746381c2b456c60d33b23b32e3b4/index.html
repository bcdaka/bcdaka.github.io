<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【OAuth2系列】集成微信小程序登录到 Spring Security OAuth 2.0 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/addd746381c2b456c60d33b23b32e3b4/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【OAuth2系列】集成微信小程序登录到 Spring Security OAuth 2.0">
  <meta property="og:description" content="作者：后端小肥肠
创作不易，未经允许严禁转载。
姊妹篇：
【Spring Security系列】权限之旅：SpringSecurity小程序登录深度探索_spring security 微信小程序登录-CSDN博客
目录
1. 前言
2. 总体登录流程
3. 数据表设计
3.1. sys_user表
3.2. user_auth表
3.3. 表关系
4. OAuth2 扩展实现小程序登录
4.1 OAuth2登录涉及到的重要组件讲解
4.2 微信小程序自定义登录
5. 结语
1. 前言 随着微信小程序在国内的广泛应用，越来越多的企业希望将微信小程序登录功能集成到他们的系统中，以提供更便捷的用户体验。Spring Security OAuth 2.0 是一个强大的框架，可以帮助我们实现这一需求。本文将详细介绍如何在 Spring Security OAuth 2.0 中扩展支持微信小程序登录，通过自定义授权方式实现无缝登录。
2. 总体登录流程 后端小肥肠 上述流程图描述了小程序集成OAuth2获取Token登录步骤及日常携带token访问接口步骤：
登录步骤：
1. 获取用户基本信息
在小程序端，调用 wx.getUserProfile() 方法来获取用户的基本信息。这一步通常是在用户同意授权后进行的，用于获取用户的头像、昵称等基本资料。
2. 获取登录凭证
通过调用 wx.login() 方法，小程序端可以获取到一个 loginCode，这是一个临时登录凭证，用于后续的认证请求。
3. 获取手机号凭证
调用 getPhoneNumber 方法，小程序端可以获取到一个 phoneCode，这是一个用于获取用户手机号的临时凭证。
4. 发送登录请求
小程序端将 loginCode 和 phoneCode 一起发送给开发者服务器。开发者服务器接收到这些凭证后，开始处理登录请求。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-22T09:22:15+08:00">
    <meta property="article:modified_time" content="2024-07-22T09:22:15+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【OAuth2系列】集成微信小程序登录到 Spring Security OAuth 2.0</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><span style="color:#4da8ee;"><strong>作者：后端小肥肠</strong></span></p> 
 <p>创作不易，未经允许严禁转载。</p> 
 <p></p> 
 <p>姊妹篇：</p> 
 <p><a href="https://blog.csdn.net/c18213590220/article/details/139088604" title="【Spring Security系列】权限之旅：SpringSecurity小程序登录深度探索_spring security 微信小程序登录-CSDN博客">【Spring Security系列】权限之旅：SpringSecurity小程序登录深度探索_spring security 微信小程序登录-CSDN博客</a></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%20%E5%89%8D%E8%A8%80-toc" style="margin-left:40px;"><a href="#1.%20%E5%89%8D%E8%A8%80" rel="nofollow">1. 前言</a></p> 
<p id="article-title-toc" style="margin-left:40px;"><a href="#article-title" rel="nofollow">2. 总体登录流程</a></p> 
<p id="3.%20%E6%95%B0%E6%8D%AE%E8%A1%A8%E8%AE%BE%E8%AE%A1-toc" style="margin-left:40px;"><a href="#3.%20%E6%95%B0%E6%8D%AE%E8%A1%A8%E8%AE%BE%E8%AE%A1" rel="nofollow">3. 数据表设计</a></p> 
<p id="3.1.%20sys_user%E8%A1%A8-toc" style="margin-left:80px;"><a href="#3.1.%20sys_user%E8%A1%A8" rel="nofollow">3.1. sys_user表</a></p> 
<p id="3.2.%20user_auth%E8%A1%A8-toc" style="margin-left:80px;"><a href="#3.2.%20user_auth%E8%A1%A8" rel="nofollow">3.2. user_auth表</a></p> 
<p id="3.3.%20%E8%A1%A8%E5%85%B3%E7%B3%BB-toc" style="margin-left:80px;"><a href="#3.3.%20%E8%A1%A8%E5%85%B3%E7%B3%BB" rel="nofollow">3.3. 表关系</a></p> 
<p id="4.%20OAuth2%20%E6%89%A9%E5%B1%95%E5%AE%9E%E7%8E%B0%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95-toc" style="margin-left:40px;"><a href="#4.%20OAuth2%20%E6%89%A9%E5%B1%95%E5%AE%9E%E7%8E%B0%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95" rel="nofollow">4. OAuth2 扩展实现小程序登录</a></p> 
<p id="%C2%A04.1%20OAuth2%E7%99%BB%E5%BD%95%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E8%AE%B2%E8%A7%A3-toc" style="margin-left:80px;"><a href="#%C2%A04.1%20OAuth2%E7%99%BB%E5%BD%95%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E8%AE%B2%E8%A7%A3" rel="nofollow"> 4.1 OAuth2登录涉及到的重要组件讲解</a></p> 
<p id="4.2%20%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BB%E5%BD%95-toc" style="margin-left:80px;"><a href="#4.2%20%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BB%E5%BD%95" rel="nofollow">4.2 微信小程序自定义登录</a></p> 
<p id="%C2%A05.%20%E7%BB%93%E8%AF%AD-toc" style="margin-left:40px;"><a href="#%C2%A05.%20%E7%BB%93%E8%AF%AD" rel="nofollow"> 5. 结语</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="1.%20%E5%89%8D%E8%A8%80">1. 前言</h3> 
<p>随着微信小程序在国内的广泛应用，越来越多的企业希望将微信小程序登录功能集成到他们的系统中，以提供更便捷的用户体验。Spring Security OAuth 2.0 是一个强大的框架，可以帮助我们实现这一需求。本文将详细介绍如何在 Spring Security OAuth 2.0 中扩展支持微信小程序登录，通过自定义授权方式实现无缝登录。</p> 
<h3 id="article-title">2. 总体登录流程</h3> 
<p></p> 
<div class="img-center"> 
 <figure class="image"> 
  <img alt="微信登录绑定drawio-第 2 页.drawio.png" height="1125" src="https://images2.imgbox.com/b3/77/w8L2IBTu_o.png" width="525"> 
  <figcaption>
                                                                                                                    后端小肥肠 
  </figcaption> 
 </figure> 
</div> 
<p>上述流程图描述了小程序集成OAuth2获取Token登录步骤及日常携带token访问接口步骤：</p> 
<p><strong><span style="color:#956fe7;">登录步骤：</span></strong></p> 
<p>1. 获取用户基本信息</p> 
<p>在小程序端，调用 <code>wx.getUserProfile()</code> 方法来获取用户的基本信息。这一步通常是在用户同意授权后进行的，用于获取用户的头像、昵称等基本资料。</p> 
<p class="img-center"><img alt="" height="312" src="https://images2.imgbox.com/c5/4f/mXSyQLMW_o.png" width="401"></p> 
<p>2. 获取登录凭证</p> 
<p>通过调用 <code>wx.login()</code> 方法，小程序端可以获取到一个 <code>loginCode</code>，这是一个临时登录凭证，用于后续的认证请求。</p> 
<p>3. 获取手机号凭证</p> 
<p>调用 <code>getPhoneNumber</code> 方法，小程序端可以获取到一个 <code>phoneCode</code>，这是一个用于获取用户手机号的临时凭证。</p> 
<p class="img-center"><img alt="" height="284" src="https://images2.imgbox.com/bf/6f/I94icLWo_o.png" width="397"></p> 
<p>4. 发送登录请求</p> 
<p>小程序端将 <code>loginCode</code> 和 <code>phoneCode</code> 一起发送给开发者服务器。开发者服务器接收到这些凭证后，开始处理登录请求。</p> 
<p>5. 调用微信接口获取 OpenID</p> 
<p>开发者服务器使用 <code>appid</code> 和 <code>appsecret</code> 以及 <code>loginCode</code> 调用微信的登录凭证校验接口（<code>https://api.weixin.qq.com/sns/jscode2session</code>），微信返回 <code>session_key</code> 和 <code>openid</code> 等信息。</p> 
<p>6. 检查 OpenID</p> 
<p>开发者服务器查询本地的 <code>user_auth</code> 表，检查是否存在对应的 <code>openid</code>。如果 <code>openid</code> 已经存在，说明用户已经注册过，直接进行登录操作。</p> 
<p>7. 获取 AccessToken</p> 
<p>如果 <code>openid</code> 不存在，开发者服务器需要调用微信的接口获取 <code>access_token</code>（<code>https://api.weixin.qq.com/cgi-bin/token</code>）。</p> 
<p>8. 获取用户手机号</p> 
<p>使用获取到的 <code>access_token</code> 和 <code>phoneCode</code>，开发者服务器调用微信接口（<code>https://api.weixin.qq.com/wxa/business/getuserphonenumber</code>）来获取用户的手机号。</p> 
<p>9. 用户注册或绑定</p> 
<p>开发者服务器将获取到的手机号与 <code>user</code> 表中的数据进行比对。如果存在匹配的手机号，则在 <code>user_auth</code> 表中新增一条记录，将 <code>openid</code> 绑定到用户账户上。如果不存在匹配的手机号，则创建一个新的用户账户，并将 <code>openid</code> 与该新账户绑定。</p> 
<p>10. 自定义登录状态</p> 
<p>开发者服务器根据用户的注册或绑定结果，创建并返回一个自定义的 OAuth2 登录状态（<code>OAuth2Authentication</code> 对象），并生成相应的 Token。</p> 
<p>11. 返回 Token 和用户基本信息</p> 
<p>开发者服务器将生成的 Token 和用户的基本信息返回给小程序端。</p> 
<p><span style="color:#956fe7;"><strong>携带token访问接口步骤：</strong></span></p> 
<p>1. 业务请求</p> 
<p>小程序端在后续的业务请求中，将 Token 放在请求头中发送给开发者服务器。</p> 
<p>2. 验证登录状态</p> 
<p>开发者服务器在接收到业务请求后，验证请求头中的 Token 以确认用户的登录状态，并处理相应的业务逻辑。</p> 
<p>3. 返回业务数据</p> 
<p>验证通过后，开发者服务器返回相应的业务数据给小程序端，完成整个流程。</p> 
<p>通过以上步骤，实现了微信小程序与 OAuth2 的无缝集成，确保了用户的便捷登录和系统的安全性。</p> 
<h3 id="3.%20%E6%95%B0%E6%8D%AE%E8%A1%A8%E8%AE%BE%E8%AE%A1"><br> 3. 数据表设计</h3> 
<h4 id="3.1.%20sys_user%E8%A1%A8">3.1. sys_user表</h4> 
<pre><code class="language-java">CREATE TABLE "public"."sys_user" (
  "id" "pg_catalog"."varchar" COLLATE "pg_catalog"."default" NOT NULL,
  "username" "pg_catalog"."varchar" COLLATE "pg_catalog"."default" NOT NULL,
  "password" "pg_catalog"."varchar" COLLATE "pg_catalog"."default",
  "is_enabled" "pg_catalog"."int4",
  "mobile" "pg_catalog"."varchar" COLLATE "pg_catalog"."default",
  "create_time" "pg_catalog"."timestamp",
  "update_time" "pg_catalog"."timestamp",
  "version" "pg_catalog"."int4" DEFAULT 1,
  "department_id" "pg_catalog"."varchar" COLLATE "pg_catalog"."default",
  "name" "pg_catalog"."varchar" COLLATE "pg_catalog"."default" NOT NULL,
  "image_url" "pg_catalog"."varchar" COLLATE "pg_catalog"."default",
  CONSTRAINT "sys_user_intranet_pkey" PRIMARY KEY ("id")
)
;


COMMENT ON COLUMN "public"."sys_user"."id" IS '用户 ID';

COMMENT ON COLUMN "public"."sys_user"."username" IS '用户名';

COMMENT ON COLUMN "public"."sys_user"."password" IS '密码，加密存储, admin/1234';

COMMENT ON COLUMN "public"."sys_user"."is_enabled" IS '帐户是否可用(1 可用，0 删除用户)';

COMMENT ON COLUMN "public"."sys_user"."mobile" IS '注册手机号';

COMMENT ON COLUMN "public"."sys_user"."create_time" IS '创建时间';

COMMENT ON COLUMN "public"."sys_user"."update_time" IS '更新时间';

COMMENT ON COLUMN "public"."sys_user"."version" IS '乐观锁';

COMMENT ON COLUMN "public"."sys_user"."name" IS '真实姓名';

COMMENT ON TABLE "public"."sys_user" IS '用户信息表';</code></pre> 
<h4 id="3.2.%20user_auth%E8%A1%A8">3.2. user_auth表</h4> 
<pre><code class="language-java">CREATE TABLE "public"."sys_user_auth" (
  "id" "pg_catalog"."varchar" COLLATE "pg_catalog"."default" NOT NULL,
  "user_id" "pg_catalog"."varchar" COLLATE "pg_catalog"."default" NOT NULL,
  "identity_type" "pg_catalog"."varchar" COLLATE "pg_catalog"."default" NOT NULL,
  "identifier" "pg_catalog"."varchar" COLLATE "pg_catalog"."default",
  "credential" "pg_catalog"."varchar" COLLATE "pg_catalog"."default",
  "log_time" "pg_catalog"."timestamp",
  "is_phone_verified" "pg_catalog"."int2",
  "is_email_verified" "pg_catalog"."int2",
  CONSTRAINT "sys_user_auth_pkey" PRIMARY KEY ("id"),
  CONSTRAINT "user_auth_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."sys_user" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION
)
;
</code></pre> 
<p> 上表中的identifier字段为小程序登录时的openId：</p> 
<p><img alt="" height="217" src="https://images2.imgbox.com/af/6a/TkzAE8KN_o.png" width="1200"></p> 
<h4 id="3.3.%20%E8%A1%A8%E5%85%B3%E7%B3%BB">3.3. 表关系</h4> 
<h4 id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="589" src="https://images2.imgbox.com/6c/b2/vTppdpkG_o.png" width="1200"></h4> 
<p><strong><span style="color:#956fe7;">在上图中可看出sys_user表的id与sys_user_auth中的user_id为逻辑外键的关系。 </span></strong></p> 
<h3 id="4.%20OAuth2%20%E6%89%A9%E5%B1%95%E5%AE%9E%E7%8E%B0%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95"><br> 4. OAuth2 扩展实现小程序登录</h3> 
<h4 id="%C2%A04.1%20OAuth2%E7%99%BB%E5%BD%95%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E8%AE%B2%E8%A7%A3"> <br> 4.1 OAuth2登录涉及到的重要组件讲解</h4> 
<p>1. TokenEndpoint</p> 
<p>Token请求的入口是 <code>TokenEndpoint</code>。客户端通过 <code>/oauth/token</code> 发送请求来获取访问令牌。</p> 
<p><img alt="" height="627" src="https://images2.imgbox.com/52/57/pSa2xjHG_o.png" width="1200"></p> 
<p>2. ClientDetailsService</p> 
<p><code>ClientDetailsService</code> 负责加载客户端的详细信息。<code>InMemoryClientDetailsService</code> 是一种典型的实现方式，它从内存中加载客户端详细信息，但也可以使用其他实现，例如从数据库加载数据的 <code>JdbcClientDetailsService</code>。</p> 
<p><img alt="" height="449" src="https://images2.imgbox.com/4d/e7/pxQe7xCm_o.png" width="1200"></p> 
<p>3. TokenRequest</p> 
<p>加载客户端详细信息后，会创建一个 <code>TokenRequest</code> 对象，该对象包含关于客户端请求令牌的信息，例如客户端ID、授权类型、范围等。</p> 
<p><img alt="" height="652" src="https://images2.imgbox.com/cf/72/8FQn3jlL_o.png" width="1200"></p> 
<p>4. TokenGranter</p> 
<p><code>TokenGranter</code> 接口定义了授予令牌的机制。<code>CompositeTokenGranter</code> 是一种典型的实现，根据授权类型（例如授权码、密码、客户端凭证等）委派给其他 <code>TokenGranter</code> 实现。</p> 
<p><img alt="" height="436" src="https://images2.imgbox.com/67/01/k0ME0ZUZ_o.png" width="1200"></p> 
<p>5. OAuth2Request</p> 
<p><code>OAuth2Request</code> 代表客户端发起的OAuth2请求。该对象封装了客户端请求的所有参数。</p> 
<p>6. Authentication</p> 
<p>认证过程验证客户端凭据以及其他必要的认证步骤（例如，如果是密码授权类型，还需要验证用户的凭据）。</p> 
<p>7. OAuth2Authentication</p> 
<p><code>OAuth2Authentication</code> 对象将 <code>OAuth2Request</code> 与认证的主体（用户详细信息或客户端详细信息）结合起来。这个对象用于创建访问令牌。</p> 
<p>8. AuthorizationServerTokenServices</p> 
<p><code>AuthorizationServerTokenServices</code> 接口定义了发放令牌的操作。<code>DefaultTokenServices</code> 是一种典型的实现，处理令牌的创建和持久化。</p> 
<p><img alt="" height="616" src="https://images2.imgbox.com/6f/4f/evLY1BqL_o.png" width="1200"></p> 
<p>9. TokenStore 和 TokenEnhancer</p> 
<p><code>TokenStore</code> 接口定义了如何存储和检索令牌（例如，内存、数据库、JWT等）。<code>TokenEnhancer</code> 允许在令牌发放之前添加额外的信息。</p> 
<p>10. OAuth2AccessToken</p> 
<p>这个令牌包含访问令牌本身，以及其他信息如过期时间、刷新令牌、范围等。</p> 
<p></p> 
<p></p> 
<h4 id="4.2%20%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BB%E5%BD%95">4.2 微信小程序自定义登录</h4> 
<p id="ue1264788">OAuth2默认授权方式为5种（授权码模式、简化模式、密码模式、客户端凭据模式和刷新令牌模式），不包含小程序登录，需要编写自定义授权代码，拓展AbstractTokenGranter，步骤如下：</p> 
<p id="u830e3abf">1.在原有的五种授权模式上新增WechatTokenGranter，集成自AbstractTokenGranter：</p> 
<pre><code class="language-java">package com.geoscene.ynbackoauth2server.oauth2.granter;

/**
 * @version 1.0
 * @description: TODO
 * @author: xfc
 * @date 2022-10-10 15:12
 */

import com.geoscene.ynbackoauth2server.oauth2.authentication.WechatAuthenticationToken;
import org.springframework.security.authentication.AbstractAuthenticationToken;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.core.Authentication;
import org.springframework.security.oauth2.common.exceptions.InvalidGrantException;
import org.springframework.security.oauth2.provider.*;
import org.springframework.security.oauth2.provider.token.AbstractTokenGranter;
import org.springframework.security.oauth2.provider.token.AuthorizationServerTokenServices;
import java.util.LinkedHashMap;
import java.util.Map;


public class WechatTokenGranter extends AbstractTokenGranter {

    // 自定义授权方式为 wechat
    private static final String GRANT_TYPE = "wechat";

    private final AuthenticationManager authenticationManager;

    public WechatTokenGranter(AuthenticationManager authenticationManager,
                              AuthorizationServerTokenServices tokenServices, ClientDetailsService clientDetailsService, OAuth2RequestFactory requestFactory) {
        this(authenticationManager, tokenServices, clientDetailsService, requestFactory, GRANT_TYPE);
    }

    protected WechatTokenGranter(AuthenticationManager authenticationManager, AuthorizationServerTokenServices tokenServices,
                                 ClientDetailsService clientDetailsService, OAuth2RequestFactory requestFactory, String grantType) {
        super(tokenServices, clientDetailsService, requestFactory, grantType);
        this.authenticationManager = authenticationManager;
    }

    @Override
    protected OAuth2Authentication getOAuth2Authentication(ClientDetails client, TokenRequest tokenRequest) {

        Map&lt;String, String&gt; parameters = new LinkedHashMap(tokenRequest.getRequestParameters());
        String loginCode = parameters.get("loginCode");
        String phoneCode=parameters.get("phoneCode");
//        String encryptedData = parameters.get("encryptedData");
//        String iv = parameters.get("iv");

        // 移除后续无用参数
        parameters.remove("loginCode");
        parameters.remove("phoneCode");
//        parameters.remove("encryptedData");
//        parameters.remove("iv");

        Authentication userAuth = new WechatAuthenticationToken(loginCode,phoneCode); // 未认证状态
        ((AbstractAuthenticationToken) userAuth).setDetails(parameters);

        try {
            userAuth = this.authenticationManager.authenticate(userAuth); // 认证中
        } catch (Exception e) {
            throw new InvalidGrantException(e.getMessage());
        }

        if (userAuth != null &amp;&amp; userAuth.isAuthenticated()) { // 认证成功
            OAuth2Request storedOAuth2Request = this.getRequestFactory().createOAuth2Request(client, tokenRequest);
            return new OAuth2Authentication(storedOAuth2Request, userAuth);
        } else { // 认证失败
            throw new InvalidGrantException("Could not authenticate code: " + loginCode);
        }
    }
}</code></pre> 
<p><code>WechatTokenGranter</code> 类通过自定义的授权类型 "wechat" 实现了微信小程序登录的认证流程。它扩展了 <code>AbstractTokenGranter</code>，并通过重写 <code>getOAuth2Authentication</code> 方法来处理微信特有的认证逻辑。该类确保了在微信小程序登录过程中，能够正确处理 <code>loginCode</code> 和 <code>phoneCode</code>，并通过 <code>authenticationManager</code> 进行认证，最终返回 OAuth2 的认证结果。 </p> 
<p id="ub523c075">2.新增WechatAuthenticationProvider用于验证WechatAuthenticationToken：</p> 
<pre><code class="language-java">package com.geoscene.ynbackoauth2server.oauth2.authentication;

/**
 * @version 1.0
 * @description: TODO
 * @author: xfc
 * @date 2022-10-10 15:30
 */

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.baomidou.mybatisplus.core.toolkit.StringUtils;
import com.geoscene.ynbackapi.entities.SysUser;
import com.geoscene.ynbackapi.feign.IFeignSystemController;
import com.geoscene.ynbackapi.req.AddUserAuthReq;
import com.geoscene.ynbackoauth2server.oauth2.config.WechatConfig;
import com.geoscene.ynbackoauth2server.oauth2.service.JwtUser;
import com.geoscene.ynbackoauth2server.oauth2.service.WeChatService;
import com.geoscene.ynbackoauth2server.web.utils.RedisUtils;
import com.geoscene.ynbackoauth2server.web.utils.RestTemplateUtil;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpEntity;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.AuthenticationServiceException;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.AuthorityUtils;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

import java.util.*;

@Slf4j
@Component
public class WechatAuthenticationProvider implements AuthenticationProvider {

    @Autowired
    private RedisUtils redisUtils;

    @Autowired
    private WechatConfig wechatConfig;

    @Autowired
    private WeChatService weChatService;

    @Autowired
    RestTemplate restTemplate;

    @Autowired
    IFeignSystemController feignSystemController;


    @Override
    @SneakyThrows
    public Authentication authenticate(Authentication authentication) {

        WechatAuthenticationToken wechatAuthenticationToken = (WechatAuthenticationToken) authentication;
        String loginCode = wechatAuthenticationToken.getPrincipal().toString();
        log.info("loginCode为:{}",loginCode);
        String phoneCode=wechatAuthenticationToken.getPhoneCode().toString();
        log.info("phoneCode为：{}",phoneCode);
        //获取openId
        JwtUser jwtUser=null;
        String url = "https://api.weixin.qq.com/sns/jscode2session?appid={appid}&amp;secret={secret}&amp;js_code={code}&amp;grant_type=authorization_code";
        Map&lt;String, String&gt; requestMap = new HashMap&lt;&gt;();
        requestMap.put("appid", wechatConfig.getAppid());
        requestMap.put("secret", wechatConfig.getSecret());
        requestMap.put("code", loginCode);
        ResponseEntity&lt;String&gt; responseEntity = restTemplate.getForEntity(url, String.class,requestMap);
        JSONObject jsonObject= JSONObject.parseObject(responseEntity.getBody());
        log.info(JSONObject.toJSONString(jsonObject));
        String openId=jsonObject.getString("openid");
        if(StringUtils.isBlank(openId)) {
            throw new BadCredentialsException("weChat get openId error");
        }
        if(feignSystemController.getuserAuthCountByIdentifier(openId)&gt;0){
             jwtUser = (JwtUser) weChatService.getUserByOpenId(openId);
             return getauthenticationToken(jwtUser,jwtUser.getAuthorities());
        }
        //获取手机号第一步，获取accessToken
        String accessTokenUrl="https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid={appid}&amp;secret={secret}";
        Map&lt;String, String&gt; accessTokenRequestMap = new HashMap&lt;&gt;();
        accessTokenRequestMap.put("appid", wechatConfig.getAppid());
        accessTokenRequestMap.put("secret", wechatConfig.getSecret());
        ResponseEntity&lt;String&gt;  accessTokenResponseEntity = restTemplate.getForEntity(accessTokenUrl, String.class,accessTokenRequestMap);
        JSONObject  accessTokenJsonObject= JSONObject.parseObject(accessTokenResponseEntity.getBody());
        log.info(JSONObject.toJSONString(accessTokenJsonObject));
        String  accessToken=accessTokenJsonObject.getString("access_token");
        if(StringUtils.isBlank(accessToken)) {
            throw new BadCredentialsException("weChat get accessToken error");
        }
        //获取手机号第二部，远程请求获取手机号
        String pohoneUrl="https://api.weixin.qq.com/wxa/business/getuserphonenumber?access_token="+accessToken+"";
        JSONObject phoneJson=new JSONObject();
        phoneJson.put("code",phoneCode);
        String resPhoneStr= RestTemplateUtil.postForJson(pohoneUrl,phoneJson,restTemplate);
        log.info(resPhoneStr);
        JSONObject resPhonJson=JSON.parseObject(resPhoneStr);
        JSONObject phoneInfo=resPhonJson.getJSONObject("phone_info");
        String mobile=phoneInfo.getString("phoneNumber");
        if(StringUtils.isBlank(mobile)){
            throw new BadCredentialsException("Wechat get mobile error");
        }
        jwtUser= (JwtUser) weChatService.getUserByMobile(mobile);
        feignSystemController.saveUserAuth(new AddUserAuthReq(jwtUser.getUid(),"wechat",openId));
        return getauthenticationToken(jwtUser,jwtUser.getAuthorities());

    }

    @Override
    public boolean supports(Class&lt;?&gt; authentication) {
        return WechatAuthenticationToken.class.isAssignableFrom(authentication);
    }
    public WechatAuthenticationToken getauthenticationToken(Object principal, Collection&lt;? extends GrantedAuthority&gt; authorities){
        WechatAuthenticationToken authenticationToken=new WechatAuthenticationToken(principal,authorities);
        LinkedHashMap&lt;Object, Object&gt; linkedHashMap = new LinkedHashMap&lt;&gt;();
        linkedHashMap.put("principal", authenticationToken.getPrincipal());
        authenticationToken.setDetails(linkedHashMap);
        return authenticationToken;
    }
}</code></pre> 
<p><span style="color:#956fe7;"><strong>代码讲解：</strong></span> </p> 
<p id="ua15de465">1. 根据前端传入的code，结合appid和secret，远程调用<a href="https://api.weixin.qq.com/sns/jscode2session?appid=%7Bappid%7D&amp;secret=%7Bsecret%7D&amp;js_code=%7Bcode%7D&amp;grant_type=authorization_code" rel="nofollow" title="https://api.weixin.qq.com/sns/jscode2session?appid={appid}&amp;secret={secret}&amp;js_code={code}&amp;grant_type=authorization_code">https://api.weixin.qq.com/sns/jscode2session?appid={appid}&amp;secret={secret}&amp;js_code={code}&amp;grant_type=authorization_code</a>获取openId；</p> 
<p id="u8224f4d1">2.根据获取的openId查看user_auth表中identifier是否有对应openId，有直接登录返回token，没有则调用获取手机号接口；</p> 
<p id="u77872621">3.根据appid和secret调用<a href="https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=%7Bappid%7D&amp;secret=%7Bsecret%7D" rel="nofollow" title="https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid={appid}&amp;secret={secret}">https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid={appid}&amp;secret={secret}</a>获取accessToken；</p> 
<p id="u14b3cdef">4.根据前端传来的code（与获取openId的code不同）结合accessToken调用<a href="https://api.weixin.qq.com/wxa/business/getuserphonenumber" rel="nofollow" title="https://api.weixin.qq.com/wxa/business/getuserphonenumber">https://api.weixin.qq.com/wxa/business/getuserphonenumber</a>获取手机号；</p> 
<p id="u9bdfdd91">5.将获取的手机号与user表中手机号进行对比，存在则在user_auth表中新增一条数据，并返回token；</p> 
<p id="u416bdf28">6.不存在手机号则在user表中新增一条数据，用户名为手机号，权限为普通用户，同时在user_auth，user_role中新增一条记录，并登录返回token；</p> 
<h3 id="%C2%A05.%20%E7%BB%93%E8%AF%AD"> 5. 结语</h3> 
<p>通过本文的介绍，我们成功地在 Spring Security OAuth 2.0 中实现了微信小程序的登录扩展。通过自定义授权器和验证器，我们能够处理微信小程序特有的登录流程，确保用户能够安全、便捷地通过小程序登录到我们的系统中。这不仅提升了用户体验，也增强了系统的安全性和灵活性。如果你在实际操作中遇到任何问题或有更好的建议，欢迎交流与探讨。</p> 
<p><img alt="" height="383" src="https://images2.imgbox.com/49/c4/LHKb4IWd_o.jpg" width="900"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1cf91e6aae47c5b78ddab4fb71b94d02/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">LLama Factory微调模型全流程，与peft库调用训练的adapter</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bc7bc27a3975be987e34d0315f7f6be2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">大数据-42 Redis 功能扩展 发布/订阅模式 事务相关的内容 Redis弱事务</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>