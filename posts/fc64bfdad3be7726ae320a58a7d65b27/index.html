<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Redis】集群 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/fc64bfdad3be7726ae320a58a7d65b27/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【Redis】集群">
  <meta property="og:description" content="文章目录 一、集群是什么？二、 Redis集群分布式存储为什么redis集群的最大槽数是16384（不太懂）redis的集群主节点数量基本不可能超过1000个 三、 配置集群（三主三从）3.1 配置config文件3.2 启动六台redis3.2 通过redis-cli命令为6台机器构建集群关系3.3 任意连接一个作为切入点（集群只需要连一个），并检验集群状态 四、 扩展 以下是本篇文章正文内容
一、集群是什么？ 由于数据量过大，单个Master复制集难以承担，因此需要对多个复制集进行集群，形成水平扩展每个复制集只负责存储整个数据集的一部分，这就是Redis的集群，其作用是提供在多个Redis节点间共享数据的程序集。 Redis集群是一个提供在多个Redis节点间共享数据的程序集
Redis集群可以支持多个Master Redis集群支持多个Master，每个Master又可以挂载多个Slave读写分离支持海量数据的高可用支持海量数据的读写存储操作由于Cluster自带Sentinel的故障转移机制，内置了高可用的支持，无需再去使用哨兵功能客户端和Redis的节点连接，不再需要连接集群中所有节点，只需连接集群中的任意一个可用节点即可槽位slot负责分配到各个物理服务节点，由对应的集群来负责维护节点、插槽和数据之间的关系redis集群不保证强一致性，这意味着在特定的条件下，Redis集群可能会丢掉一些被系统收到的写入请求命令 二、 Redis集群分布式存储 槽位
集群的密钥空间被分成16384个槽，有效地设置了16384个主节点的集群大小上限(但是，建议的最大节点大小约为1000个节点)。
Redis集群投有使用一致性hash，而是引入了哈希槽的概念.
Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽。
集群的每个节点（master）负责一部分hash槽。
比如，有一个集群有三个节点：
分片
使用Redis集群时我们会将存储的数据分散到多台redis机器上，这称为分片。简言之，集群中的每个Redis实例都被认为是整个数据的一个分片。
如何找到给定key的分片：为了找到给定key的分片，我们对key进行CRC16(key)算法处理并通过对总分片数量取模。然后，使用确定性哈希函数，这意味着给定的key将多次始终映射到同一个分片，我们可以推断将来读取特定key的位置。
Redis集群分布式存储有大概有3种解决方法
哈希取余分区
hash(key) % N个机器台数，计算出哈希值，用来决定数据映射到哪一个节点上。
优点：
简单粗暴，直接有效，只需要预估好数据规划节点例如3台、8台、10台，就能保证一段时间的数据支撑。使用Hash算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求（并维护这些请求的信息），起到负载均衡&#43;分而治之的作用。 缺点：
直接规划好节点，进行扩容或者缩容会很麻烦，不管扩还是缩，每次数据变动会导致节点有变动，映射关系都要重新计算，在服务器个数固定不变时没有问题。如果需要弹性扩容或故障停机的情况下，原来的取模公式就会发生变化，Hash(key)/3会变成Hash(key) /?。此时地址经过取余运算的结果将发生很大变化，根据公式获取的服务器也会变得不可控。 一致性哈希算法分区
为了解决分布式缓存数据变动和映射问题，某个机器宕机了，分母数量改变了，自然取余数不行了。
目的是当服务器个数发生变动时，尽量减少影响客户端到服务器的映射关系
算法步骤：
哈希槽分区
哈希槽实质就是一个数组，数组[0,2^14 -1]形成hash slot空间。 解决均匀分配的问题，在数据和节点之间又加入了一层，把这层称为哈希槽（slot），用于管理数据和节点之间的关系（即解决映射问题），现在就相当于节点上放的是槽，槽里放的是数据。
一个集群只能有16384个槽，编号0-16383（0-2^14-1）。这些槽会分配给集群中的所有主节点，分配策略没有要求。
接下来就需要对key求哈希值，然后对16384取模，余数是几key就落入对应的槽里。集群会记录节点和槽的对应关系。
HASH_SLOT = CRC16(key) mod 16384。
以槽为单位移动数据，因为槽的数目是固定的，处理起来比较容易，这样数据移动问题就解决了。
写入的总体流程：当需要在 Redis 集群中放置一个 key-value时，redis先对key使用crc16算法算出一个结果然后用结果对16384求余数[ CRC16(key) % 16384]，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，也就是映射到某个节点上。
为什么redis集群的最大槽数是16384（不太懂） Redis集群并没有使用一致性hash而是引入了哈希槽的概念。Redis 集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-16T20:31:12+08:00">
    <meta property="article:modified_time" content="2024-07-16T20:31:12+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Redis】集群</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_5" rel="nofollow">一、集群是什么？</a></li><li><a href="#_Redis_20" rel="nofollow">二、 Redis集群分布式存储</a></li><li><ul><li><a href="#redis16384_70" rel="nofollow">为什么redis集群的最大槽数是16384（不太懂）</a></li><li><a href="#redis1000_74" rel="nofollow">redis的集群主节点数量基本不可能超过1000个</a></li></ul> 
  </li><li><a href="#__77" rel="nofollow">三、 配置集群（三主三从）</a></li><li><ul><li><a href="#31_config_84" rel="nofollow">3.1 配置config文件</a></li><li><a href="#32_redis_229" rel="nofollow">3.2 启动六台redis</a></li><li><a href="#32_rediscli6_237" rel="nofollow">3.2 通过redis-cli命令为6台机器构建集群关系</a></li><li><a href="#33__243" rel="nofollow">3.3 任意连接一个作为切入点（集群只需要连一个），并检验集群状态</a></li></ul> 
  </li><li><a href="#__275" rel="nofollow">四、 扩展</a></li></ul> 
</div> 
<p></p> 
<hr> 
<p><code>以下是本篇文章正文内容</code></p> 
<h2><a id="_5"></a>一、集群是什么？</h2> 
<ul><li><strong>由于数据量过大</strong>，单个Master复制集难以承担，因此需要对多个复制集进行集群，形成<strong>水平扩展每</strong>个复制集只负责存储整个数据集的一部分，这就是Redis的集群，其作用是提供在多个Redis节点间共享数据的程序集。</li></ul> 
<blockquote> 
 <p>Redis集群是一个提供在多个Redis节点间共享数据的<strong>程序集</strong></p> 
</blockquote> 
<ul><li>Redis集群可以支持<strong>多个Master</strong></li></ul> 
<p><img src="https://images2.imgbox.com/2b/b0/HcLIT0Uf_o.png" alt="在这里插入图片描述"></p> 
<ul><li>Redis集群支持多个Master，每个Master又可以挂载多个Slave</li><li>读写分离</li><li>支持海量数据的高可用</li><li>支持海量数据的<strong>读写</strong>存储操作</li><li>由于Cluster自带Sentinel的故障转移机制，内置了高可用的支持，<strong>无需再去使用哨兵功能</strong></li><li>客户端和Redis的节点连接，不再需要连接集群中所有节点，只需连接集群中的任意一个可用节点即可</li><li>槽位slot负责分配到各个物理服务节点，由对应的集群来负责维护节点、插槽和数据之间的关系</li><li>redis集群<strong>不保证强一致性</strong>，这意味着在特定的条件下，Redis集群可能会丢掉一些被系统收到的写入请求命令</li></ul> 
<h2><a id="_Redis_20"></a>二、 Redis集群分布式存储</h2> 
<p><strong>槽位</strong><br> 集群的密钥空间被分成16384个槽，有效地设置了16384个主节点的集群大小上限(但是，<strong>建议的最大节点大小约为1000个节点</strong>)。<br> Redis集群投有使用一致性hash，而是引入了哈希槽的概念.<br> Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽。<br> 集群的每个节点（master）负责一部分hash槽。</p> 
<blockquote> 
 <p>比如，有一个集群有三个节点：<br> <img src="https://images2.imgbox.com/4d/d3/fUSaMwXR_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p><strong>分片</strong><br> 使用Redis集群时我们会将存储的数据分散到多台redis机器上，这称为分片。简言之，集群中的每个Redis实例都被认为是整个数据的一个分片。</p> 
<p>如何找到给定key的分片：为了找到给定key的分片，我们对key进行CRC16(key)算法处理并通过对总分片数量取模。然后，<strong>使用确定性哈希函数</strong>，这意味着给定的key将多次始终映射到同一个分片，我们可以推断将来读取特定key的位置。</p> 
<p>Redis集群分布式存储有大概有3种解决方法</p> 
<p><strong>哈希取余分区</strong><br> <img src="https://images2.imgbox.com/de/3b/WT0dSOy3_o.png" alt="在这里插入图片描述" width="400"><br> <code>hash(key) % N个机器台数</code>，计算出哈希值，用来决定数据映射到哪一个节点上。<br> <strong>优点：</strong></p> 
<ul><li>简单粗暴，直接有效，只需要预估好数据规划节点例如3台、8台、10台，就能保证一段时间的数据支撑。使用Hash算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求（并维护这些请求的信息），<strong>起到负载均衡+分而治之的作用</strong>。</li></ul> 
<p><strong>缺点：</strong></p> 
<ul><li>直接规划好节点，进行扩容或者缩容会很麻烦，不管扩还是缩，每次数据变动会导致节点有变动，映射关系都要重新计算，在服务器个数固定不变时没有问题。</li><li>如果需要弹性扩容或故障停机的情况下，原来的取模公式就会发生变化，<code>Hash(key)/3</code>会变成<code>Hash(key) /?</code>。</li><li>此时地址经过取余运算的结果将发生很大变化，根据公式获取的服务器也会变得不可控。</li></ul> 
<p><strong>一致性哈希算法分区</strong></p> 
<blockquote> 
 <p>为了解决分布式缓存数据变动和映射问题，某个机器宕机了，分母数量改变了，自然取余数不行了。<br> 目的是当服务器个数发生变动时，尽量减少影响客户端到服务器的映射关系</p> 
</blockquote> 
<p>算法步骤：</p> 
<p><strong>哈希槽分区</strong></p> 
<ul><li>哈希槽实质就是一个<strong>数组</strong>，数组[0,2^14 -1]形成hash slot空间。</li></ul> 
<blockquote> 
 <p>解决均匀分配的问题，在数据和节点之间又加入了一层，把这层称为哈希槽（slot），<strong>用于管理数据和节点之间的关系</strong>（即解决映射问题），现在就相当于节点上放的是槽，槽里放的是数据。<br> <img src="https://images2.imgbox.com/d1/db/DPxFxPwO_o.png" alt="在这里插入图片描述"><br> 一个集群只能有16384个槽，编号0-16383（0-2^14-1）。这些槽会分配给集群中的所有主节点，分配策略没有要求。</p> 
</blockquote> 
<p>接下来就需要对key求哈希值，然后对16384取模，余数是几key就落入对应的槽里。集群会记录节点和槽的对应关系。<br> <code>HASH_SLOT = CRC16(key) mod 16384</code>。<br> 以槽为单位移动数据，因为槽的数目是固定的，处理起来比较容易，这样数据移动问题就解决了。</p> 
<p>写入的总体流程：当需要在 Redis 集群中放置一个 key-value时，redis先对key使用crc16算法算出一个结果然后用结果对16384求余数<code>[ CRC16(key) % 16384]</code>，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，也就是映射到某个节点上。</p> 
<h3><a id="redis16384_70"></a>为什么redis集群的最大槽数是16384（不太懂）</h3> 
<p>Redis集群并没有使用一致性hash而是引入了哈希槽的概念。Redis 集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。</p> 
<p>正常的心跳数据包带有节点的完整配置，可以用幂等方式用旧的节点替换旧节点，以便更新旧的配置。这意味着它们包含原始节点的插槽配置，该节点使用2k的空间和16k的插槽，但是会使用8k的空间（使用65k的插槽）。同时，由于其他设计折衷，Redis集群不太可能扩展到1000个以上的主节点。因此16k处于正确的范围内，以确保每个主机具有足够的插槽，最多可容纳1000个矩阵，但数量足够少，可以轻松地将插槽配置作为原始位图传播。请注意，在小型群集中，位图将难以压缩，因为当N较小时，位图将设置的slot / N位占设置位的很大百分比。</p> 
<h3><a id="redis1000_74"></a>redis的集群主节点数量基本不可能超过1000个</h3> 
<p>集群节点越多，心跳包的消息体内携带的数据越多。如果节点过1000个，也会导致网络拥堵。因此redis作者不建议redis cluster节点数量超过1000个。 那么，对于节点数在1000以内的redis cluster集群，16384个槽位够用了。没有必要拓展到65536个。</p> 
<h2><a id="__77"></a>三、 配置集群（三主三从）</h2> 
<blockquote> 
 <p>Redis集群为什么<strong>至少需要三个master节点</strong>？<br> 因为新master的选举需要大于半数的集群master节点同意才能选举成功，如果只有两个master节点，当其中一个挂了，是达不到选举新master的条件的。</p> 
</blockquote> 
<blockquote> 
 <p>Redis集群为什么推荐节点数为奇数？<br> 奇数个master节点可以在满足选举该条件的基础上节省一个节点，比如三个master节点和四个master节点的集群相比，大家如果都挂了一个master节点都能选举新master节点，如果都挂了两个master节点都没法选举新master节点了，所以奇数的master节点更多的是从节省机器资源角度出发说的。</p> 
</blockquote> 
<h3><a id="31_config_84"></a>3.1 配置config文件</h3> 
<p>本案例的配置是在一台虚拟机的6个端口分别配置了6个redis服务器<br> <img src="https://images2.imgbox.com/09/75/pi57RHyR_o.png" alt="集群配置" width="550"></p> 
<ul><li>端口 6381</li></ul> 
<pre><code class="prism language-powershell">vim <span class="token operator">/</span>myredis/cluster/redisCluster6381<span class="token punctuation">.</span>conf
</code></pre> 
<pre><code class="prism language-powershell">bind 0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0
daemonize yes
protected-mode no
port 6381
logfile <span class="token string">"/myredis/cluster/cluster6381.log"</span>
pidfile <span class="token operator">/</span>myredis/cluster6381<span class="token punctuation">.</span>pid
<span class="token function">dir</span> <span class="token operator">/</span>myredis/cluster
dbfilename dump6381<span class="token punctuation">.</span>rdb
appendonly yes
appendfilename <span class="token string">"appendonly6381.aof"</span>
requirepass 123456
masterauth 123456
 
cluster-enabled yes
cluster-config-file nodes-6381<span class="token punctuation">.</span>conf
cluster-node-timeout 5000
</code></pre> 
<ul><li>端口 6382</li></ul> 
<pre><code class="prism language-powershell">vim <span class="token operator">/</span>myredis/cluster/redisCluster6382<span class="token punctuation">.</span>conf
</code></pre> 
<pre><code class="prism language-powershell">bind 0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0
daemonize yes
protected-mode no
port 6382
logfile <span class="token string">"/myredis/cluster/cluster6382.log"</span>
pidfile <span class="token operator">/</span>myredis/cluster6382<span class="token punctuation">.</span>pid
<span class="token function">dir</span> <span class="token operator">/</span>myredis/cluster
dbfilename dump6382<span class="token punctuation">.</span>rdb
appendonly yes
appendfilename <span class="token string">"appendonly6382.aof"</span>
requirepass 123456
masterauth 123456
 
cluster-enabled yes
cluster-config-file nodes-6382<span class="token punctuation">.</span>conf
cluster-node-timeout 5000
</code></pre> 
<ul><li>端口 6383</li></ul> 
<pre><code class="prism language-powershell">vim <span class="token operator">/</span>myredis/cluster/redisCluster6383<span class="token punctuation">.</span>conf
</code></pre> 
<pre><code class="prism language-powershell">bind 0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0
daemonize yes
protected-mode no
port 6383
logfile <span class="token string">"/myredis/cluster/cluster6383.log"</span>
pidfile <span class="token operator">/</span>myredis/cluster6383<span class="token punctuation">.</span>pid
<span class="token function">dir</span> <span class="token operator">/</span>myredis/cluster
dbfilename dump6383<span class="token punctuation">.</span>rdb
appendonly yes
appendfilename <span class="token string">"appendonly6383.aof"</span>
requirepass 123456
masterauth 123456

cluster-enabled yes
cluster-config-file nodes-6383<span class="token punctuation">.</span>conf
cluster-node-timeout 5000
</code></pre> 
<ul><li>端口 6384</li></ul> 
<pre><code class="prism language-powershell">vim <span class="token operator">/</span>myredis/cluster/redisCluster6384<span class="token punctuation">.</span>conf
</code></pre> 
<pre><code class="prism language-powershell">bind 0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0
daemonize yes
protected-mode no
port 6384
logfile <span class="token string">"/myredis/cluster/cluster6384.log"</span>
pidfile <span class="token operator">/</span>myredis/cluster6384<span class="token punctuation">.</span>pid
<span class="token function">dir</span> <span class="token operator">/</span>myredis/cluster
dbfilename dump6384<span class="token punctuation">.</span>rdb
appendonly yes
appendfilename <span class="token string">"appendonly6384.aof"</span>
requirepass 123456
masterauth 123456
 
cluster-enabled yes
cluster-config-file nodes-6384<span class="token punctuation">.</span>conf
cluster-node-timeout 5000
</code></pre> 
<ul><li>端口 6385</li></ul> 
<pre><code class="prism language-powershell">vim <span class="token operator">/</span>myredis/cluster/redisCluster6385<span class="token punctuation">.</span>conf
</code></pre> 
<pre><code class="prism language-powershell">bind 0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0
daemonize yes
protected-mode no
port 6385
logfile <span class="token string">"/myredis/cluster/cluster6385.log"</span>
pidfile <span class="token operator">/</span>myredis/cluster6385<span class="token punctuation">.</span>pid
<span class="token function">dir</span> <span class="token operator">/</span>myredis/cluster
dbfilename dump6385<span class="token punctuation">.</span>rdb
appendonly yes
appendfilename <span class="token string">"appendonly6385.aof"</span>
requirepass 123456
masterauth 123456
 
cluster-enabled yes
cluster-config-file nodes-6385<span class="token punctuation">.</span>conf
cluster-node-timeout 5000

</code></pre> 
<ul><li>端口 6386</li></ul> 
<pre><code class="prism language-powershell">vim <span class="token operator">/</span>myredis/cluster/redisCluster6386<span class="token punctuation">.</span>conf
</code></pre> 
<pre><code class="prism language-powershell">bind 0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0
daemonize yes
protected-mode no
port 6386
logfile <span class="token string">"/myredis/cluster/cluster6386.log"</span>
pidfile <span class="token operator">/</span>myredis/cluster6386<span class="token punctuation">.</span>pid
<span class="token function">dir</span> <span class="token operator">/</span>myredis/cluster
dbfilename dump6386<span class="token punctuation">.</span>rdb
appendonly yes
appendfilename <span class="token string">"appendonly6386.aof"</span>
requirepass 123456
masterauth 123456
 
cluster-enabled yes
cluster-config-file nodes-6386<span class="token punctuation">.</span>conf
cluster-node-timeout 5000
</code></pre> 
<h3><a id="32_redis_229"></a>3.2 启动六台redis</h3> 
<pre><code class="prism language-powershell">redis-server <span class="token operator">/</span>myredis/cluster/redisCluter6381<span class="token punctuation">.</span>conf 
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
redis-server <span class="token operator">/</span>myredis/cluster/redisCluter6386<span class="token punctuation">.</span>conf 

</code></pre> 
<h3><a id="32_rediscli6_237"></a>3.2 通过redis-cli命令为6台机器构建集群关系</h3> 
<pre><code class="prism language-powershell">redis-<span class="token function">cli</span> <span class="token operator">-</span>a 123456 <span class="token operator">--</span>cluster create <span class="token operator">--</span>cluster-replicas 1 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>88<span class="token punctuation">.</span>130:6381 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>88<span class="token punctuation">.</span>130:6382 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>88<span class="token punctuation">.</span>130:6383 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>88<span class="token punctuation">.</span>130:6384 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>88<span class="token punctuation">.</span>130:6385 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>88<span class="token punctuation">.</span>130:6386
</code></pre> 
<ul><li>-cluster-replicas 1 表示为每个master创建一个slave节点</li></ul> 
<h3><a id="33__243"></a>3.3 任意连接一个作为切入点（集群只需要连一个），并检验集群状态</h3> 
<ul><li>连接6381端口</li></ul> 
<pre><code class="prism language-powershell">redis-<span class="token function">cli</span> <span class="token operator">-</span>a 123456 <span class="token operator">-</span>p 6381 <span class="token operator">-</span>c     <span class="token operator">/</span><span class="token operator">/</span> <span class="token operator">-</span>c表示集群 不加的话不是按照集群启动的，对于在别的机器上的key，会报错
</code></pre> 
<p>不加 -c 启动 ，在存值时，可能会报错，原因是在计算槽位时，可能是在别的master下管理的槽位<br> 下图中的槽位是在6384端口，所以需要在6384端口的redis进行set操作<br> <img src="https://images2.imgbox.com/7d/7f/lXpfmAsc_o.png" alt="在这里插入图片描述"><br> 加上<code>-c</code>之后，会进行自动重定向<br> <img src="https://images2.imgbox.com/f2/52/AjXsBfxj_o.png" alt="在这里插入图片描述"></p> 
<ul><li>查看集群主从关系</li></ul> 
<pre><code class="prism language-powershell">cluster nodes       <span class="token operator">/</span><span class="token operator">/</span> 查看集群的主从关系
</code></pre> 
<p><img src="https://images2.imgbox.com/45/2f/6xOSCbrt_o.png" alt="在这里插入图片描述"></p> 
<ul><li>查看集群信息</li></ul> 
<pre><code class="prism language-powershell"> cluster info       <span class="token operator">/</span><span class="token operator">/</span> 查看集群信息     
</code></pre> 
<ul><li>查看某个key该属于对应的槽位值</li></ul> 
<pre><code class="prism language-powershell">CLUSTER KEYSLOT key  <span class="token operator">/</span><span class="token operator">/</span>查询key所在的槽位值
</code></pre> 
<p><img src="https://images2.imgbox.com/c6/fa/ZKWTxrtV_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="__275"></a>四、 扩展</h2> 
<ul><li>不在同一个slot槽位下的键值无法使用mset.mget等多键操作</li></ul> 
<p>可以通过<code>{}</code>来定义同一个组的概念，使key中内相同内容的键值对放到一个slot槽位去，对照下图类似k1k2k3都映射为x，<br> <img src="https://images2.imgbox.com/07/ca/Kydw3bWs_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>集群是否完整才能对外提供服务</strong></li></ul> 
<p>在配置文件中有以下代码</p> 
<pre><code class="prism language-powershell">cluster-require-full-coverage
</code></pre> 
<p>默认YES，现在集群架构是3主3从的redis cluster由3个master平分16384个slot，每个master的小集群负责1/3的slot，对应一部分数据。<br> cluster-require-full-coverage:默认值 yes，即需要集群完整性，方可对外提供服务通常情况，如果这3个小集群中，任何一个（1主1从）挂了，你这个集群对外可提供的数据只有2/3了，整个集群是不完整的，<br> redis 默认在这种情况下，是不会对外提供服务的。</p> 
<p>如果你的诉求是，集群不完整的话也需要对外提供服务，需要将该参数设置为no ，这样的话你挂了的那个小集群是不行了，但是其他的小集群仍然可以对外提供服务。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7298df8827914dc6a953f829eeea995a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">“初探Java：新手指南与实践之旅“</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0f5f688dd81bc7ef0b4cd72de47f860e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spark学习之SparkSQL</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>