<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构 | 哈希表】一文了解哈希表(散列表) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/7229746d08bb57292d22946c33793a48/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构 | 哈希表】一文了解哈希表(散列表)">
  <meta property="og:description" content="😁博客主页😁：🚀https://blog.csdn.net/wkd_007🚀
🤑博客内容🤑：🍭嵌入式开发、Linux、C语言、C&#43;&#43;、数据结构、音视频🍭
🤣本文内容🤣：🍭介绍哈希表 🍭
😎金句分享😎：🍭你不能选择最好的，但最好的会来选择你——泰戈尔🍭
⏰发布时间⏰： 2024-07-24 14:48:55
本文未经允许，不得转发！！！
目录 🎄一、概述🎄二、键值对(key-value pair)🎄三、哈希函数🎄四、哈希冲突(哈希碰撞)✨4.1 开发地址法✨4.2 链地址法 🎄五、哈希表的使用🎄六、总结 🎄一、概述 在学习过的简单数据结构当中，
数组的特点：访问(寻址)速度较快的、但插入、删除操作较慢；
链表的特点：访问(寻址)速度较慢的、但插入、删除操作很快；
所以，有些大牛就想着能不能结合这数组、链表的优点，造出一个 访问(寻址)速度较快的、插入、删除操作也很快 的数据结构，后面就造出来一个 哈希表。
哈希表（Hash Table）：也叫做散列表。是根据关键码值（Key Value）直接进行访问的数据结构。
哈希表存储的都是键值对（Key-Value），即一个关键字对应一个内容，给出关键字就可以在哈希表中找到对应内容。
哈希表的工作过程：哈希表通过键值对的 关键字(key) 和 哈希函数 计算出对应的一个位置，通常是数组下标，然后把整个 键值对(代码中叫Entry)存放到这个位置，以加快查找的速度。如果多个 关键字(key) 得到同一位置就会产生 哈希冲突，需要通过一个方法去解决。
这里面有好几个概念，会在后面的内容去介绍。
🎄二、键值对(key-value pair) 键值对(key-value pair)：就是一个关键字(key)对应一个值(value)的组合，要求每个键值对的 关键字(key) 不能重复。下面表格就是一些键值对。
KeyValuexia虾za匝zai栽zan赞zang脏 在代码里可以使用下面结构体去表现一个键值对：
struct table_entry{ const char* key; void *value; } 哈希表是存储 键值对 的，那它是怎样存储的呢？
哈希表要求每个键值对的 关键字(key) 不能重复，然后通过键值对的 关键字(key) 来定位每个键值对存放的位置，这个位置就是 哈希地址，而将 关键字(key) 映射成 哈希地址 的函数就是 哈希函数。
在哈希表中，会把 键值对(key-value) 的key称为键值。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-24T14:48:57+08:00">
    <meta property="article:modified_time" content="2024-07-24T14:48:57+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构 | 哈希表】一文了解哈希表(散列表)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p><font face="楷体" color="red" size="4">😁博客主页😁：🚀<a href="https://blog.csdn.net/wkd_007">https://blog.csdn.net/wkd_007</a>🚀</font><br> <font face="楷体" color="green" size="4">🤑博客内容🤑：🍭嵌入式开发、Linux、C语言、C++、数据结构、音视频🍭</font><br> <font face="楷体" color="blue" size="4">🤣本文内容🤣：🍭介绍哈希表 🍭</font><br> <font face="楷体" color="#ffb300" size="4">😎金句分享😎：🍭你不能选择最好的，但最好的会来选择你——泰戈尔🍭</font><br> <font face="楷体" color="#06BEFF" size="4">⏰发布时间⏰： 2024-07-24 14:48:55</font></p> 
</blockquote> 
<p><font color="red" size="6" face="楷体">本文未经允许，不得转发！！！</font></p> 
<p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_14" rel="nofollow">🎄一、概述</a></li><li><a href="#keyvalue_pair_30" rel="nofollow">🎄二、键值对(key-value pair)</a></li><li><a href="#_59" rel="nofollow">🎄三、哈希函数</a></li><li><a href="#_90" rel="nofollow">🎄四、哈希冲突(哈希碰撞)</a></li><li><ul><li><a href="#41__95" rel="nofollow">✨4.1 开发地址法</a></li><li><a href="#42__104" rel="nofollow">✨4.2 链地址法</a></li></ul> 
  </li><li><a href="#_124" rel="nofollow">🎄五、哈希表的使用</a></li><li><a href="#_138" rel="nofollow">🎄六、总结</a></li></ul> 
</div> 
<p></p> 
<hr> 
<p><img src="https://images2.imgbox.com/87/43/HRj9amR4_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/ae/68/fTKvnHlm_o.gif" alt="在这里插入图片描述" height="40"></p> 
<h2><a id="_14"></a>🎄一、概述</h2> 
<p>在学习过的简单数据结构当中，<br> 数组的特点：<strong>访问(寻址)速度较快的</strong>、但插入、删除操作较慢；<br> 链表的特点：访问(寻址)速度较慢的、但<strong>插入、删除操作很快</strong>；<br> 所以，有些大牛就想着能不能结合这数组、链表的优点，造出一个 <strong>访问(寻址)速度较快的、插入、删除操作也很快</strong> 的数据结构，后面就造出来一个 哈希表。</p> 
<blockquote> 
 <p>哈希表（Hash Table）：也叫做散列表。是根据关键码值（Key Value）直接进行访问的数据结构。</p> 
</blockquote> 
<p>哈希表存储的都是<code>键值对（Key-Value）</code>，即一个关键字对应一个内容，给出关键字就可以在哈希表中找到对应内容。</p> 
<p>哈希表的工作过程：哈希表通过键值对的 <strong>关键字(key)</strong> 和 <strong>哈希函数</strong> 计算出对应的一个位置，通常是<strong>数组下标</strong>，然后把整个 <strong>键值对</strong>(代码中叫Entry)存放到这个位置，以加快查找的速度。如果多个 <strong>关键字(key)</strong> 得到同一位置就会产生 <strong>哈希冲突</strong>，需要通过一个方法去解决。</p> 
<p>这里面有好几个概念，会在后面的内容去介绍。</p> 
<hr> 
<p><img src="https://images2.imgbox.com/9a/8c/cZL4y22w_o.gif" alt="在这里插入图片描述" height="40"></p> 
<h2><a id="keyvalue_pair_30"></a>🎄二、键值对(key-value pair)</h2> 
<blockquote> 
 <p><strong>键值对(key-value pair)</strong>：就是一个关键字(key)对应一个值(value)的组合，要求每个键值对的 <strong>关键字(key)</strong> 不能重复。下面表格就是一些键值对。</p> 
</blockquote> 
<table><thead><tr><th>Key</th><th>Value</th></tr></thead><tbody><tr><td>xia</td><td>虾</td></tr><tr><td>za</td><td>匝</td></tr><tr><td>zai</td><td>栽</td></tr><tr><td>zan</td><td>赞</td></tr><tr><td>zang</td><td>脏</td></tr></tbody></table> 
<p>在代码里可以使用下面结构体去表现一个键值对：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">table_entry</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> key<span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token operator">*</span>value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>哈希表是存储 键值对 的，那它是怎样存储的呢？<br> 哈希表要求每个键值对的 <strong>关键字(key)</strong> 不能重复，然后通过键值对的 <strong>关键字(key)</strong> 来定位每个键值对存放的位置，这个位置就是 <strong>哈希地址</strong>，而将 <strong>关键字(key)</strong> 映射成 <strong>哈希地址</strong> 的函数就是 <strong>哈希函数</strong>。</p> 
<p>在哈希表中，会把 <strong>键值对(key-value)</strong> 的key称为键值。</p> 
<hr> 
<p><img src="https://images2.imgbox.com/70/f4/RPq9Ery5_o.gif" alt="在这里插入图片描述" height="40"></p> 
<h2><a id="_59"></a>🎄三、哈希函数</h2> 
<blockquote> 
 <p><strong>哈希函数（Hash Function）</strong>：也叫散列函数，将哈希表中元素的关键键值(key)映射为元素存储位置(哈希地址)的函数。</p> 
</blockquote> 
<p>哈希函数是哈希表中最重要的部分。一般来说，哈希函数会满足以下几个条件：</p> 
<ul><li>哈希函数应该易于计算，并且尽量使计算出来的索引值均匀分布。</li><li>哈希函数计算得到的哈希值是一个固定长度的输出值。</li><li>计算出来的哈希地址不同，则传入键值(key)肯定不同；<pre><code>Hash(key1) != Hash(key2)，则 key1 != key2。
</code></pre> </li><li>如果 Hash(key1) 等于 Hash(key2)，那么 key1、key2 可能相等，也可能不相等（会发生哈希冲突）</li></ul> 
<p>在哈希表的应用中，最常见的2种键值类型是：字符串、数字。而其他键值类型还可以是是字符串类型、浮点数类型、大整数类型，甚至还有可能是几种类型的组合。设计哈希函数时，要根据键值类型的特点去设计，一般会先将键值转成整型再去计算，因为最终计算出来的一般是一个数组下标(Index)。</p> 
<p>常见的哈希函数方法有：直接定址法、除留余数法、平方取中法、基数转换法、数字分析法、折叠法、随机数法、乘积法、点积法等。</p> 
<p>假设我们把上个小节的键值对存到一个哈希表，并通过哈希函数计算出哈希地址，如下表：</p> 
<table><thead><tr><th>Key</th><th>Value</th><th>哈希地址(Index)</th></tr></thead><tbody><tr><td>xia</td><td>虾</td><td>517</td></tr><tr><td>za</td><td>匝</td><td>597</td></tr><tr><td>zai</td><td>栽</td><td>597</td></tr><tr><td>zan</td><td>赞</td><td>599</td></tr><tr><td>zang</td><td>脏</td><td>600</td></tr></tbody></table> 
<p>就像上面表格一样，哈希函数有时就将两个不同的键值计算出同一个哈希地址，这就造成了哈希冲突(哈希碰撞)</p> 
<hr> 
<p><img src="https://images2.imgbox.com/47/70/1wCQuRQN_o.gif" alt="在这里插入图片描述" height="40"></p> 
<h2><a id="_90"></a>🎄四、哈希冲突(哈希碰撞)</h2> 
<blockquote> 
 <p><strong>哈希冲突（Hash Collision）</strong>：不同的关键字通过同一个哈希函数可能得到同一哈希地址，即 key1 ≠ key2，而 Hash(key1) = Hash(key2)，这种现象称为哈希冲突。</p> 
</blockquote> 
<p>理想状态下，是每个key通过哈希函数都计算出不同的哈希地址，这样直接将键值对存入即可。但实际使用中一般都会出现哈希冲突的，这时就需要处理哈希冲突。处理哈希冲突的方法一般有两种：开放地址法、链地址法。</p> 
<h3><a id="41__95"></a>✨4.1 开发地址法</h3> 
<blockquote> 
 <p>开放地址法（Open Addressing）：指的是将哈希表中的 <strong>空地址</strong> 向处理冲突开放。当哈希表未满时，处理冲突时需要尝试另外的单元，直到找到空的单元为止。</p> 
</blockquote> 
<p>开放地址法主要有三种实现：</p> 
<ul><li>线性探测（Linear Probing）：发生冲突时，依次检查下一个地址，直到找到空闲位置。</li><li>二次探测（Quadratic Probing）：冲突时，以二次函数的方式探查空闲位置。</li><li>双重哈希（Double Hashing）：使用两个哈希函数，当发生冲突时，使用第二个哈希函数计算新的探查位置。</li></ul> 
<h3><a id="42__104"></a>✨4.2 链地址法</h3> 
<blockquote> 
 <p>链地址法（Chaining）：将具有相同哈希地址的元素（或记录）存储在同一个线性链表中。</p> 
</blockquote> 
<p>链地址法是一种更加常用的哈希冲突解决方法。相比于开放地址法，链地址法更加简单。</p> 
<p>具体的做法是当哈希地址的位置是空的话，就直接将 键值对 存入该位置；如果不为空，就将 键值对 存到该地址的链表中，所以在代码实现时，会在键值对所在结构体中加一个next指针，用于实现链表。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">TableEntry</span> <span class="token punctuation">{<!-- --></span>
    TableEntry<span class="token operator">*</span> fNext<span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token keyword">const</span><span class="token operator">*</span> key<span class="token punctuation">;</span>
    <span class="token keyword">void</span><span class="token operator">*</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/9a/9b/MD0JOTuF_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p><img src="https://images2.imgbox.com/91/f0/89uxJtcd_o.gif" alt="在这里插入图片描述" height="40"></p> 
<h2><a id="_124"></a>🎄五、哈希表的使用</h2> 
<p>虽然上面说了那么多的概念，但只是使用哈希表并不需要知道这些。如果是要看别人实现哈希表的代码，则必须要清楚上面的那些概念，这里再总结一下：</p> 
<blockquote> 
 <ul><li>1、键值对（Key-Value Pair）：是一种数据结构的表示形式，其中“键（Key）”是用于标识和查找数据的唯一标识符，“值（Value）”则是与该键相关联的数据。例如，在字典中，单词（键）与其释义（值）就构成了键值对。</li><li>2、哈希函数（Hash Function）：是一种将输入（通常是键）转换为固定长度输出（称为哈希值）的函数。哈希函数的设计目标是使得不同的输入尽可能产生不同的输出，并且输出分布均匀。</li><li>3、哈希值（Hash Value）：通过哈希函数对输入（键）进行计算得到的固定长度的数值。</li><li>4、哈希地址（Hash Address）：哈希值所对应的存储位置。通常，哈希表会根据哈希值来确定数据在内存中的存储位置。</li><li>5、哈希冲突（Hash Collision）：当两个或多个不同的键通过哈希函数计算得到相同的哈希值时，就发生了哈希冲突。这可能导致这些键对应的元素需要存储在同一个哈希地址，从而引发数据存储和检索的问题。</li></ul> 
</blockquote> 
<p>如果只是使用哈希表的话，只需要知道哈希表提供了哪些操作即可。哈希表至少会提供三个操作：插入、删除、查询。我们只需要知道怎样插入键值对、怎样删除、怎样查询就差不多了。</p> 
<hr> 
<p><img src="https://images2.imgbox.com/d7/43/O5lLRrwU_o.gif" alt="在这里插入图片描述" height="40"></p> 
<h2><a id="_138"></a>🎄六、总结</h2> 
<p>👉本文介绍哈希表实现过程中的重要概念：键值对、键值、哈希函数、哈希冲突、处理哈希冲突等，看完后可以对哈希表有一定的了解。</p> 
<p><img src="https://images2.imgbox.com/69/37/uRhKUs9f_o.gif" alt="在这里插入图片描述"><br> 如果文章有帮助的话，点赞👍、收藏⭐，支持一波，谢谢 😁😁😁</p> 
<p>参考：<br> https://blog.csdn.net/zy_dreamer/article/details/131036258<br> https://blog.csdn.net/sinat_33921105/article/details/103344078<br> https://blog.csdn.net/m0_65781965/article/details/136987203</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/807ff88dc3af876df9e550a38c77097e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">kotlin基础知识点</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0a41da94c1ceedb04a135dff8e6d3696/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">代码随想录算法训练营第22天-leetcode-二叉树08：669. 修剪二叉搜索树；108.将有序数组转换为二叉搜索树；538.把二叉搜索树转换为累加树</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>