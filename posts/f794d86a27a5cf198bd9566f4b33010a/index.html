<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深入理解数据结构第五弹——排序（2）——快速排序 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/f794d86a27a5cf198bd9566f4b33010a/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="深入理解数据结构第五弹——排序（2）——快速排序">
  <meta property="og:description" content="排序（1）：深入了解数据结构第四弹——排序（1）——插入排序和希尔排序-CSDN博客
前言：
在前面我们已经讲过了几种排序方式，他们的效率有快有慢，今天我们来学习一种非常高效的排序方式——快速排序
目录
一、快速排序的思想
二、快速排序的递归实现
2.1 霍尔法
2.2 挖坑法
2.3 前后指针法
三、快排的非递归实现
四、完整代码示例
五、总结
一、快速排序的思想 快速排序是一种常用的排序算法，属于比较排序的一种。它的基本思想是先选取一个基准数据，经过一趟排序，让比它小的分为一部分，比它大的分为另一部分，然后再对这两部分继续这种操作，直到他们有序
快速排序的具体步骤如下：
选择一个基准元素（通常是待排序数组的第一个元素、最后一个元素或者中间元素）。将比基准元素小的元素放在基准元素的左边，比基准元素大的元素放在基准元素的右边，这一步称为分区操作。对基准元素左右两部分分别递归地进行快速排序。 比如这样一组数据{ 4,7,1,9,3,6,5,8,3,2,0 }
1、首先我们先选择一个基准元素（我们以最左边的元素为基准元素为例）
2、对剩下的元素进行排序，比基准元素小的排在左边，比基准元素大的排在右边
3、对小的部分和大的部分重复上面两部操作，最后我们就可以得到一个有序的数组
这一步就可以清楚的看到其实快排的这种思想很像二叉树，所以很容易通过类似二叉树递归的那种思想来解决
二、快速排序的递归实现
快排的实现其实是很有意思的，在上面我们已经讲了快排的思想，其实就是不断的重复分区操作的过程，所以我们就可以设计一个递归来实现这种，同时，由于每一步都要进行分区，所以我们可以封装一个分区排序函数（PartSort函数）在前，重复这个过程
void QuickSort(int* a, int begin,int end) { if (begin &gt;= end) { return; } int keyi = PartSort3(a, begin, end); QuickSort(a, begin, keyi - 1); QuickSort(a, keyi &#43; 1, end); } 其中参数a是数组指针，begin是传入数组的首元素位置，end是传入元素尾元素位置，过程图如下：
快排函数的主体就是上面那几步，接下来，我们重点讲解一下快排分区排序函数（PartSort函数）该如何实现，这一步也是非常有趣的，目前我们有三种方法来实现这个函数的功能：
1、霍尔排序
2、挖坑法
3、前后指针法
2.1 霍尔法 霍尔法是霍尔大佬（就是快排的发明者）自己刚开始用的排序方法，但是由于这种分部排序方法需要注意到的点太多，所以后来才又有了后面两种排序方法，现在我们先来学习一下霍尔大佬的这种方法
霍尔排序其实就是严格按照我们上面讲的快排的那种思想进行的，就是先选一个基准数，然后对后面数进行大致的判断，让比基准数小的位于基准数左侧，比基准数大的位于基准数右侧
霍尔实现这个过程的方法就是先选取最左边的元素作为基准元素，然后记录剩下元素左右位置，然后让左边向右移动，当遇到一个比基准元素大的数就停下来，右边向左移动，遇到一个小于基准元素的数停下来，然后让左右这两个数交换">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-13T21:03:21+08:00">
    <meta property="article:modified_time" content="2024-04-13T21:03:21+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深入理解数据结构第五弹——排序（2）——快速排序</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>排序（1）：</strong><a href="https://blog.csdn.net/2301_80220607/article/details/137565797?spm=1001.2014.3001.5502" title="深入了解数据结构第四弹——排序（1）——插入排序和希尔排序-CSDN博客">深入了解数据结构第四弹——排序（1）——插入排序和希尔排序-CSDN博客</a></p> 
<p><strong>前言：</strong></p> 
<blockquote> 
 <p>在前面我们已经讲过了几种排序方式，他们的效率有快有慢，今天我们来学习一种非常高效的排序方式——快速排序</p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%9D%E6%83%B3-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%9D%E6%83%B3" rel="nofollow">一、快速排序的思想</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">二、快速排序的递归实现</a></p> 
<p id="2.1%20%E9%9C%8D%E5%B0%94%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><a href="#2.1%20%E9%9C%8D%E5%B0%94%E6%8E%92%E5%BA%8F" rel="nofollow">2.1 霍尔法</a></p> 
<p id="2.2%20%E6%8C%96%E5%9D%91%E6%B3%95-toc" style="margin-left:80px;"><a href="#2.2%20%E6%8C%96%E5%9D%91%E6%B3%95" rel="nofollow">2.2 挖坑法</a></p> 
<p id="2.3%20%E5%89%8D%E5%90%8E%E6%8C%87%E9%92%88%E6%B3%95-toc" style="margin-left:80px;"><a href="#2.3%20%E5%89%8D%E5%90%8E%E6%8C%87%E9%92%88%E6%B3%95" rel="nofollow">2.3 前后指针法</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%BF%AB%E6%8E%92%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81%E5%BF%AB%E6%8E%92%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0" rel="nofollow">三、快排的非递归实现</a></p> 
<p id="-toc" style="margin-left:40px;"></p> 
<p id="%E5%9B%9B%E3%80%81%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-toc" style="margin-left:40px;"><a href="#%E5%9B%9B%E3%80%81%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B" rel="nofollow">四、完整代码示例</a></p> 
<p id="%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93" rel="nofollow">五、总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p></p> 
<h3 id="%E4%B8%80%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%9D%E6%83%B3">一、快速排序的思想</h3> 
<blockquote> 
 <p>快速排序是一种常用的排序算法，属于比较排序的一种。它的基本思想是先选取一个基准数据，经过一趟排序，让比它小的分为一部分，比它大的分为另一部分，然后再对这两部分继续这种操作，直到他们有序</p> 
</blockquote> 
<p><span style="color:#fe2c24;"><strong>快速排序的具体步骤如下：</strong></span></p> 
<blockquote> 
 <ol><li>选择一个基准元素（通常是待排序数组的第一个元素、最后一个元素或者中间元素）。</li><li>将比基准元素小的元素放在基准元素的左边，比基准元素大的元素放在基准元素的右边，这一步称为分区操作。</li><li>对基准元素左右两部分分别递归地进行快速排序。</li></ol> 
</blockquote> 
<p>比如这样一组数据<strong><span style="color:#fe2c24;">{ 4,7,1,9,3,6,5,8,3,2,0 }</span></strong></p> 
<blockquote> 
 <p>1、首先我们先选择一个基准元素（我们以最左边的元素为基准元素为例）</p> 
</blockquote> 
<p><img alt="" height="160" src="https://images2.imgbox.com/9d/22/5bGud7Mo_o.png" width="366"></p> 
<blockquote> 
 <p>2、对剩下的元素进行排序，比基准元素小的排在左边，比基准元素大的排在右边</p> 
</blockquote> 
<p><img alt="" height="400" src="https://images2.imgbox.com/b2/2b/8GcN1DOs_o.png" width="497"></p> 
<blockquote> 
 <p>3、对小的部分和大的部分重复上面两部操作，最后我们就可以得到一个有序的数组</p> 
</blockquote> 
<p><img alt="" height="548" src="https://images2.imgbox.com/bb/bc/jjWk0Os8_o.png" width="770"></p> 
<p><span style="background-color:#ffd900;">这一步就可以清楚的看到其实快排的这种思想很像二叉树，所以很容易通过类似二叉树递归的那种思想来解决</span></p> 
<h3 id="%E4%BA%8C%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0">二、快速排序的递归实现<br>  </h3> 
<p>快排的实现其实是很有意思的，在上面我们已经讲了快排的思想，其实就是不断的重复分区操作的过程，所以我们就可以设计一个递归来实现这种，同时，由于每一步都要进行分区，所以我们可以封装一个<span style="color:#fe2c24;"><strong>分区排序函数（PartSort函数）</strong></span>在前，重复这个过程</p> 
<pre><code class="language-cpp">void QuickSort(int* a, int begin,int end)
{
	if (begin &gt;= end)
	{
		return;
	}
	int keyi = PartSort3(a, begin, end);
	QuickSort(a, begin, keyi - 1);
	QuickSort(a, keyi + 1, end);
}
</code></pre> 
<p>其中<span style="background-color:#ffd900;">参数a</span>是数组指针，<span style="background-color:#ffd900;">begin</span>是传入数组的首元素位置，<span style="background-color:#ffd900;">end</span>是传入元素尾元素位置，过程图如下：<img alt="" height="648" src="https://images2.imgbox.com/23/b7/oqtf65Fo_o.png" width="1200"></p> 
<p>快排函数的主体就是上面那几步，接下来，我们重点讲解一下快排<span style="color:#fe2c24;"><strong>分区排序函数（PartSort函数）</strong></span>该如何实现，这一步也是非常有趣的，目前我们有三种方法来实现这个函数的功能：</p> 
<blockquote> 
 <p>      1、霍尔排序</p> 
 <p>      2、挖坑法</p> 
 <p>      3、前后指针法</p> 
</blockquote> 
<h4 id="2.1%20%E9%9C%8D%E5%B0%94%E6%8E%92%E5%BA%8F">2.1 霍尔法</h4> 
<blockquote> 
 <p>霍尔法是霍尔大佬（就是快排的发明者）自己刚开始用的排序方法，但是由于这种分部排序方法需要注意到的点太多，所以后来才又有了后面两种排序方法，现在我们先来学习一下霍尔大佬的这种方法</p> 
 <p>霍尔排序其实就是严格按照我们上面讲的快排的那种思想进行的，就是先选一个基准数，然后对后面数进行大致的判断，让比基准数小的位于基准数左侧，比基准数大的位于基准数右侧</p> 
</blockquote> 
<p>霍尔实现这个过程的方法就是<strong>先选取最左边的元素作为基准元素，然后记录剩下元素左右位置，然后让左边向右移动，当遇到一个比基准元素大的数就停下来，右边向左移动，遇到一个小于基准元素的数停下来，然后让左右这两个数交换</strong></p> 
<p><img alt="" height="512" src="https://images2.imgbox.com/ad/30/SYQLnl8S_o.png" width="1065"></p> 
<blockquote> 
 <p>然后再讲左右两部分分开再进行类似的操作</p> 
</blockquote> 
<p><img alt="" height="537" src="https://images2.imgbox.com/81/18/R6j2UayW_o.png" width="726"></p> 
<blockquote> 
 <p>由图可见这是一种类似二叉树的操作，所以非常适合用递归来解决，具体代码如下：</p> 
</blockquote> 
<pre><code class="language-cpp">int GetMid(int* a, int left, int right)
{
	int mid = (left + right) / 2;
	if (a[left] &gt; a[mid])
	{
		if (a[right] &gt; a[left])
			return left;
		else if (a[right] &lt; a[mid])
			return mid;
		else
			return right;
	}
	else
	{
		if (a[right] &lt; a[left])
			return left;
		else if (a[right] &gt; a[mid])
			return mid;
		else
			return right;
	}
}
//1、hero 霍尔排序
//[left,right]
int PartSort(int* a, int left, int right)
{
	int mid = GetMid(a, left, right);
	Swap(&amp;a[mid], &amp;a[left]);
	int keyi = left;
	while (left &lt; right)
	{
		while (left &lt; right &amp;&amp; a[left] &lt;= a[keyi])
		{
			left++;
		}
		while (left &lt; right &amp;&amp; a[right] &gt;= a[keyi])
		{
			right--;
		}
		Swap(&amp;a[left], &amp;a[right]);
	}
	Swap(&amp;a[left], &amp;a[keyi]);
	return left;
}
</code></pre> 
<p>但前面我们也已经提到过了，霍尔排序有一些细节是一定要处理到位的，就比如</p> 
<blockquote> 
 <p><strong>1、如果取左边数为基准元素，右边就要先开始移动（right - -），反之就左边先开始移动，否则就容易可能会出现溢出的现象</strong></p> 
 <p><strong>2、要注意当左右移动到的那个元素等于基准元素时是要跳过的，同时最后left==right时要将这个元素与基准元素交换</strong></p> 
 <p><strong>3、如果对于一个较为有序的函数，比如<span style="color:#fe2c24;">{1,2,4,5,7,3,9,8}</span>,快排的效率其实是偏低的，因为我们刚开始选的基准元素基本没啥作用，所以我们选择的基准元素要尽可能贴近中间值，所以就有了上述代码中的<span style="color:#fe2c24;">GetMid函数</span></strong><br>  </p> 
</blockquote> 
<h4 id="2.2%20%E6%8C%96%E5%9D%91%E6%B3%95">2.2 挖坑法</h4> 
<p>鉴于霍尔法注意事项太多，且霍尔法较难理解，后面又有大佬总结出挖坑法这一思路相同，但更形象更容易理解的方法</p> 
<p><strong><span style="background-color:#ffd900;">挖坑法的思路如下：</span></strong></p> 
<blockquote> 
 <p>先以左边元素为基准元素，然后将这个元素挖出，将这个位置理想化成一个坑，然后再从右边向左边移动，找到一个小于基准数的数后将它放入坑中，将这个位置作为新的坑，再从左边往右边去，找到一个大于基准数字的数，填入坑中，将这个位置作为新坑，直到最后将基准数字放入最后的坑中</p> 
</blockquote> 
<p><img alt="" height="611" src="https://images2.imgbox.com/25/da/EepMUrqh_o.png" width="1120"></p> 
<blockquote> 
 <p>挖坑法的思路要比霍尔法，简单很多，实现如下：</p> 
</blockquote> 
<pre><code class="language-cpp">//2、挖坑法
int PartSort2(int* a,int left,int right)
{
	int mid = GetMid(a, left, right);
	Swap(&amp;a[mid], &amp;a[left]);
	int key = a[left];
	int hole = left;
	while (left &lt; right)
	{
		while (left &lt; right &amp;&amp; a[right] &gt;= key)
		{
			right--;
		}
		a[hole] = a[right];
		hole = right;
		while (left&lt;right &amp;&amp; a[left]&lt;=key)
		{
			left++;
		}
		a[hole] = a[left];
		hole = left;
	}
	a[hole] = key;
	return left;
}
</code></pre> 
<h4 id="2.3%20%E5%89%8D%E5%90%8E%E6%8C%87%E9%92%88%E6%B3%95">2.3 前后指针法</h4> 
<p>前后指针法是一个更容易理解的很不错的方法，体现了后人的智慧</p> 
<p><strong>前后指针法的思路如下：</strong></p> 
<blockquote> 
 <p>首先先将最左边元素作为基准元素，然后定义一个prev表示后指针，定义一个cur表示前指针，cur=prev+1，然后让前指针先走，当遇到一个小于基准元素的数时停下来，然后让后指针走一步，然后交换这两个数据，直到前指针把所有数据走完</p> 
</blockquote> 
<p><img alt="" height="518" src="https://images2.imgbox.com/f1/b7/FOXI3mDc_o.png" width="1030"></p> 
<p>实现上述过程的代码：</p> 
<pre><code class="language-cpp">//3、前后指针法
int PartSort3(int* a, int left, int right)
{
	int mid = GetMid(a, left, right);
	Swap(&amp;a[mid], &amp;a[left]);
	int prev = left;
	int cur = prev + 1;
	int keyi = left;
	while (cur &lt;= right)
	{
		if (a[cur] &lt; a[keyi])
		{
			prev++;
			Swap(&amp;a[prev], &amp;a[cur]);
		}
		cur++;
	}
	Swap(&amp;a[prev], &amp;a[keyi]);
	return prev;
}
</code></pre> 
<h3 id="%E4%B8%89%E3%80%81%E5%BF%AB%E6%8E%92%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0">三、快排的非递归实现</h3> 
<p>这个由于篇幅问题，留在下一章进行讲解（其实是本人累了.......坐在这写一下午了，呜呜呜呜呜........)，这个明天写，嘿嘿</p> 
<h3></h3> 
<h3 id="%E5%9B%9B%E3%80%81%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B">四、完整代码示例</h3> 
<blockquote> 
 <p>上面我们就已经把快排的几种分部处理的方法和思想讲的很清楚了，接下来，我们就通过一个完整的代码实例来感受快排的魅力所在</p> 
</blockquote> 
<p><span style="color:#fe2c24;"><strong>对数组{ 4,7,1,9,3,6,5,8,3,2,0 }进行快排</strong></span></p> 
<p>Seqlish.h</p> 
<pre><code class="language-cpp">//快速排序
void QuickSort(int* a, int begin, int end);
</code></pre> 
<p>Seqlish.c</p> 
<pre><code class="language-cpp">//快速排序
void PrintArray(int* a, int n)
{
	for (int i = 0; i &lt; n; i++)
	{
		printf("%d ", a[i]);
	}
	printf("\n");
}
void Swap(int* e1, int* e2)
{
	int tmp = *e1;
	*e1 = *e2;
	*e2 = tmp;
}
int GetMid(int* a, int left, int right)
{
	int mid = (left + right) / 2;
	if (a[left] &gt; a[mid])
	{
		if (a[right] &gt; a[left])
			return left;
		else if (a[right] &lt; a[mid])
			return mid;
		else
			return right;
	}
	else
	{
		if (a[right] &lt; a[left])
			return left;
		else if (a[right] &gt; a[mid])
			return mid;
		else
			return right;
	}
}
//1、hero 霍尔排序
//[left,right]
int PartSort(int* a, int left, int right)
{
	int mid = GetMid(a, left, right);
	Swap(&amp;a[mid], &amp;a[left]);
	int keyi = left;
	while (left &lt; right)
	{
		while (left &lt; right &amp;&amp; a[left] &lt;= a[keyi])
		{
			left++;
		}
		while (left &lt; right &amp;&amp; a[right] &gt;= a[keyi])
		{
			right--;
		}
		Swap(&amp;a[left], &amp;a[right]);
	}
	Swap(&amp;a[left], &amp;a[keyi]);
	return left;
}
//2、挖坑法
int PartSort2(int* a,int left,int right)
{
	int mid = GetMid(a, left, right);
	Swap(&amp;a[mid], &amp;a[left]);
	int key = a[left];
	int hole = left;
	while (left &lt; right)
	{
		while (left &lt; right &amp;&amp; a[right] &gt;= key)
		{
			right--;
		}
		a[hole] = a[right];
		hole = right;
		while (left&lt;right &amp;&amp; a[left]&lt;=key)
		{
			left++;
		}
		a[hole] = a[left];
		hole = left;
	}
	a[hole] = key;
	return left;
}
//3、前后指针法
int PartSort3(int* a, int left, int right)
{
	int mid = GetMid(a, left, right);
	Swap(&amp;a[mid], &amp;a[left]);
	int prev = left;
	int cur = prev + 1;
	int keyi = left;
	while (cur &lt;= right)
	{
		if (a[cur] &lt; a[keyi])
		{
			prev++;
			Swap(&amp;a[prev], &amp;a[cur]);
		}
		cur++;
	}
	Swap(&amp;a[prev], &amp;a[keyi]);
	return prev;
}
//递归的快速排序
void QuickSort(int* a, int begin,int end)
{
	if (begin &gt;= end)
	{
		return;
	}
	int keyi = PartSort3(a, begin, end);
	QuickSort(a, begin, keyi - 1);
	QuickSort(a, keyi + 1, end);
}
</code></pre> 
<p>test.c</p> 
<pre><code class="language-cpp">//测试快速排序
void TestQuick()
{
	int a[] = { 4,7,1,9,3,6,5,8,3,2,0 };
	PrintArray(a, sizeof(a) / sizeof(a[0]));
	//QuickSort(a, 0, sizeof(a) / sizeof(a[0]) - 1);      //递归快排
	QuickSortNonR(a, 0, sizeof(a) / sizeof(a[0]) - 1);    //非递归快排

	PrintArray(a, sizeof(a) / sizeof(a[0]));
}

int main()
{
	TestQuick();
	return 0;
}
</code></pre> 
<p>运行结果如下：</p> 
<p><img alt="" height="253" src="https://images2.imgbox.com/48/6b/BlLO8YuI_o.png" width="981"></p> 
<h3 id="%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93">五、总结</h3> 
<p>总之，快排的思路是有点类似二叉树的，所以适合用递归来解决，当然，用非递归同样能处理，这里我们留下了一个尾巴，等下次解决，上面提到的这些内容，如果有不理解的地方欢迎私信与我交流或者在评论区中指出</p> 
<p><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">谢谢各位大佬观看，创作不易，还请各位大佬点赞支持一下！！！</span></strong></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ee668324c5197960166fd5dac225cc9f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java 8（ jdk1.8u321）安装教程（超详细）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/18d08ccc088c3acaa5800ff0bc7892e0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">QT之QWebEngineView详细介绍</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>