<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python酷库之旅-比翼双飞情侣库(15) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/47b088de00723d596ec05c594a7c91f6/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Python酷库之旅-比翼双飞情侣库(15)">
  <meta property="og:description" content="目录
一、xlrd库的由来
二、xlrd库优缺点
1、优点
1-1、支持多种Excel文件格式
1-2、高效性
1-3、开源性
1-4、简单易用
1-5、良好的兼容性
2、缺点
2-1、对.xlsx格式支持有限
2-2、功能相对单一
2-3、更新和维护频率低
2-4、依赖外部资源
三、xlrd库的版本说明
1、xlrd 1.2.0版本
2、xlrd 2.0.1版本
3、xlrd3(非官方名称)
四、如何学好xlrd库？
1、获取xlrd库的属性和方法
2、获取xlrd库的帮助信息
3、实战案例
3-144、判断工作表内是否有公式
3-145、判断某单元格区域是否为数组公式区域
3-146、判断工作表内是否有数组公式
3-147、判断单元格的计算公式是否引用了其他工作表数据
3-148、判断单元格的计算公式是否引用了其他工作簿数据
3-149、判断某单元格是否为合并单元格区域的一部分
3-150、获取单元格区域内的值
3-151、获取单元格内的前缀字符
3-152、判断单元格内的数字是否为文本字符
3-153、获取单元格的格式
3-154、获取单元格的字体(Font)对象
3-155、获取单元格的内部(Interior)对象
3-156、获取单元格的边框(Borders)对象
3-157、获取单元格边框线的状态
3-158、获取单元格的样式(Style)对象
3-159、获取单元格的条件格式
3-160、获取单元格的输入规则(有效性设置)
3-161、获取单元格的超链接
3-162、获取单元格的批注信息
3-163、获取单元格的大小(行高和列宽)
3-164、获取单元格的坐标
五、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、博客个人主页
在Excel中，通常所说的“情侣键”并非官方术语，而是对某些常用且经常成对出现的快捷键的一种形象化的称呼。其中，最为人熟知和广泛使用的“情侣键”是“Ctrl&#43;C”和“Ctrl&#43;V”。
1、Ctrl&#43;C：这个快捷键的作用是“拷贝”或“复制”。当你在Excel中选中某个单元格、一行、一列或整个工作表的内容后，按下Ctrl&#43;C键，这些内容就会被复制到计算机的剪贴板中，等待下一步的粘贴操作。
2、Ctrl&#43;V：这个快捷键的作用是“粘贴”。在你按下Ctrl&#43;C键将内容复制到剪贴板后，可以通过按下Ctrl&#43;V键将这些内容粘贴到Excel中的另一个位置，这两个操作经常是连续进行的，因此Ctrl&#43;C和Ctrl&#43;V就像一对“情侣”，总是成对出现。
除了这对常见的“情侣键”外，Excel中还有许多其他的快捷键可以帮助用户更高效地完成各种操作。然而，这些快捷键通常并没有像Ctrl&#43;C和Ctrl&#43;V那样形成特定的“情侣”关系。
然而，今天我不再展开介绍“情侣键”，而是要重点推介Python中的“情侣库”，即xlrd和xlwt两个第三方库。
一、xlrd库的由来 xlrd库是一种用于在Python中读取Excel文件的库，它的名称中的&#34;xl&#34;代表Excel，&#34;rd&#34;代表读取，其开发者是John Machin(注：库名字符拆分诠释，只是一种猜测)。
xlrd最初是在2005年开始开发的，是基于Python的开源项目(下载：xlrd库官网下载)。
由于Excel文件在数据处理和分析中的重要性，xlrd库填补了Python在处理Excel文件方面的空白，使得用户可以方便地在Python环境中读取Excel文件的内容，并进行进一步的数据操作和分析。
二、xlrd库优缺点 1、优点 1-1、支持多种Excel文件格式 xlrd库支持多种Excel文件格式，包括`.xls`和`.xlsx`(在旧版本中)，这使得无论数据存储在哪种格式的Excel文件中，用户都可以使用xlrd库来读取。
1-2、高效性 xlrd库使用C语言编写，因此其性能非常高，即使面对非常大的Excel文件，xlrd也可以快速地读取其中的数据。
1-3、开源性 xlrd是完全开源的，可以在GitHub等平台上找到其源代码，这使得任何人都可以根据自己的需求对其进行修改和扩展。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-19T08:00:00+08:00">
    <meta property="article:modified_time" content="2024-06-19T08:00:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python酷库之旅-比翼双飞情侣库(15)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong><span style="color:#1a439c;">目录</span></strong></p> 
<p id="%E4%B8%80%E3%80%81xlrd%E5%BA%93%E7%9A%84%E7%94%B1%E6%9D%A5-toc" style="margin-left:80px;"><strong><a href="#%E4%B8%80%E3%80%81xlrd%E5%BA%93%E7%9A%84%E7%94%B1%E6%9D%A5" rel="nofollow"><span style="color:#1a439c;">一、xlrd库的由来</span></a></strong></p> 
<p id="%E4%BA%8C%E3%80%81xlrd%E5%BA%93%E4%BC%98%E7%BC%BA%E7%82%B9-toc" style="margin-left:80px;"><strong><a href="#%E4%BA%8C%E3%80%81xlrd%E5%BA%93%E4%BC%98%E7%BC%BA%E7%82%B9" rel="nofollow"><span style="color:#1a439c;">二、xlrd库优缺点</span></a></strong></p> 
<p id="1%E3%80%81%E4%BC%98%E7%82%B9-toc" style="margin-left:120px;"><strong><a href="#1%E3%80%81%E4%BC%98%E7%82%B9" rel="nofollow"><span style="color:#1a439c;">1、优点</span></a></strong></p> 
<p id="1-1%E3%80%81%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8DExcel%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-toc" style="margin-left:160px;"><strong><a href="#1-1%E3%80%81%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8DExcel%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F" rel="nofollow"><span style="color:#1a439c;">1-1、支持多种Excel文件格式</span></a></strong></p> 
<p id="1-2%E3%80%81%E9%AB%98%E6%95%88%E6%80%A7-toc" style="margin-left:160px;"><strong><a href="#1-2%E3%80%81%E9%AB%98%E6%95%88%E6%80%A7" rel="nofollow"><span style="color:#1a439c;">1-2、高效性</span></a></strong></p> 
<p id="1-3%E3%80%81%E5%BC%80%E6%BA%90%E6%80%A7-toc" style="margin-left:160px;"><strong><a href="#1-3%E3%80%81%E5%BC%80%E6%BA%90%E6%80%A7" rel="nofollow"><span style="color:#1a439c;">1-3、开源性</span></a></strong></p> 
<p id="1-4%E3%80%81%E7%AE%80%E5%8D%95%E6%98%93%E7%94%A8-toc" style="margin-left:160px;"><strong><a href="#1-4%E3%80%81%E7%AE%80%E5%8D%95%E6%98%93%E7%94%A8" rel="nofollow"><span style="color:#1a439c;">1-4、简单易用</span></a></strong></p> 
<p id="1-5%E3%80%81%E8%89%AF%E5%A5%BD%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7-toc" style="margin-left:160px;"><strong><a href="#1-5%E3%80%81%E8%89%AF%E5%A5%BD%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7" rel="nofollow"><span style="color:#1a439c;">1-5、良好的兼容性</span></a></strong></p> 
<p id="2%E3%80%81%E7%BC%BA%E7%82%B9-toc" style="margin-left:120px;"><strong><a href="#2%E3%80%81%E7%BC%BA%E7%82%B9" rel="nofollow"><span style="color:#1a439c;">2、缺点</span></a></strong></p> 
<p id="2-1%E3%80%81%E5%AF%B9.xlsx%E6%A0%BC%E5%BC%8F%E6%94%AF%E6%8C%81%E6%9C%89%E9%99%90-toc" style="margin-left:160px;"><strong><a href="#2-1%E3%80%81%E5%AF%B9.xlsx%E6%A0%BC%E5%BC%8F%E6%94%AF%E6%8C%81%E6%9C%89%E9%99%90" rel="nofollow"><span style="color:#1a439c;">2-1、对.xlsx格式支持有限</span></a></strong></p> 
<p id="2-2%E3%80%81%E5%8A%9F%E8%83%BD%E7%9B%B8%E5%AF%B9%E5%8D%95%E4%B8%80-toc" style="margin-left:160px;"><strong><a href="#2-2%E3%80%81%E5%8A%9F%E8%83%BD%E7%9B%B8%E5%AF%B9%E5%8D%95%E4%B8%80" rel="nofollow"><span style="color:#1a439c;">2-2、功能相对单一</span></a></strong></p> 
<p id="2-3%E3%80%81%E6%9B%B4%E6%96%B0%E5%92%8C%E7%BB%B4%E6%8A%A4%E9%A2%91%E7%8E%87-toc" style="margin-left:160px;"><strong><a href="#2-3%E3%80%81%E6%9B%B4%E6%96%B0%E5%92%8C%E7%BB%B4%E6%8A%A4%E9%A2%91%E7%8E%87" rel="nofollow"><span style="color:#1a439c;">2-3、更新和维护频率低</span></a></strong></p> 
<p id="2-4%E3%80%81%E4%BE%9D%E8%B5%96%E5%A4%96%E9%83%A8%E8%B5%84%E6%BA%90-toc" style="margin-left:160px;"><strong><a href="#2-4%E3%80%81%E4%BE%9D%E8%B5%96%E5%A4%96%E9%83%A8%E8%B5%84%E6%BA%90" rel="nofollow"><span style="color:#1a439c;">2-4、依赖外部资源</span></a></strong></p> 
<p id="%E4%B8%89%E3%80%81xlrd%E5%BA%93%E7%9A%84%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E-toc" style="margin-left:80px;"><strong><a href="#%E4%B8%89%E3%80%81xlrd%E5%BA%93%E7%9A%84%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E" rel="nofollow"><span style="color:#1a439c;">三、xlrd库的版本说明</span></a></strong></p> 
<p id="1%E3%80%81xlrd%201.2.0%E7%89%88%E6%9C%AC-toc" style="margin-left:120px;"><strong><a href="#1%E3%80%81xlrd%201.2.0%E7%89%88%E6%9C%AC" rel="nofollow"><span style="color:#1a439c;">1、xlrd 1.2.0版本</span></a></strong></p> 
<p id="2%E3%80%81xlrd%202.0.1%E7%89%88%E6%9C%AC-toc" style="margin-left:120px;"><strong><a href="#2%E3%80%81xlrd%202.0.1%E7%89%88%E6%9C%AC" rel="nofollow"><span style="color:#1a439c;">2、xlrd 2.0.1版本</span></a></strong></p> 
<p id="3%E3%80%81xlrd3(%E9%9D%9E%E5%AE%98%E6%96%B9%E5%90%8D%E7%A7%B0)-toc" style="margin-left:120px;"><strong><a href="#3%E3%80%81xlrd3%28%E9%9D%9E%E5%AE%98%E6%96%B9%E5%90%8D%E7%A7%B0%29" rel="nofollow"><span style="color:#1a439c;">3、xlrd3(非官方名称)</span></a></strong></p> 
<p id="%E5%9B%9B%E3%80%81%E5%A6%82%E4%BD%95%E5%AD%A6%E5%A5%BDxlrd%E5%BA%93%EF%BC%9F-toc" style="margin-left:80px;"><strong><a href="#%E5%9B%9B%E3%80%81%E5%A6%82%E4%BD%95%E5%AD%A6%E5%A5%BDxlrd%E5%BA%93%EF%BC%9F" rel="nofollow"><span style="color:#1a439c;">四、如何学好xlrd库？</span></a></strong></p> 
<p id="1%E3%80%81%E8%8E%B7%E5%8F%96xlrd%E5%BA%93%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95-toc" style="margin-left:120px;"><strong><a href="#1%E3%80%81%E8%8E%B7%E5%8F%96xlrd%E5%BA%93%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">1、获取xlrd库的属性和方法</span></a></strong></p> 
<p id="2%E3%80%81%E8%8E%B7%E5%8F%96xlrd%E5%BA%93%E7%9A%84%E5%B8%AE%E5%8A%A9%E4%BF%A1%E6%81%AF-toc" style="margin-left:120px;"><strong><a href="#2%E3%80%81%E8%8E%B7%E5%8F%96xlrd%E5%BA%93%E7%9A%84%E5%B8%AE%E5%8A%A9%E4%BF%A1%E6%81%AF" rel="nofollow"><span style="color:#1a439c;">2、获取xlrd库的帮助信息</span></a></strong></p> 
<p id="3%E3%80%81%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B-toc" style="margin-left:120px;"><strong><a href="#3%E3%80%81%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B" rel="nofollow"><span style="color:#1a439c;">3、实战案例</span></a></strong></p> 
<p id="3-121%E3%80%81%E5%BC%95%E7%94%A8%E8%BE%93%E5%85%A5%E4%BA%86%E6%9F%90%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%80%E6%9C%89%E5%8D%95%E5%85%83%E6%A0%BC-toc" style="margin-left:160px;"><strong><a href="#3-121%E3%80%81%E5%BC%95%E7%94%A8%E8%BE%93%E5%85%A5%E4%BA%86%E6%9F%90%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%80%E6%9C%89%E5%8D%95%E5%85%83%E6%A0%BC" rel="nofollow"><span style="color:#1a439c;">3-144、判断工作表内是否有公式</span></a></strong></p> 
<p id="3-145%E3%80%81%E5%88%A4%E6%96%AD%E6%9F%90%E5%8D%95%E5%85%83%E6%A0%BC%E5%8C%BA%E5%9F%9F%E6%98%AF%E5%90%A6%E4%B8%BA%E6%95%B0%E7%BB%84%E5%85%AC%E5%BC%8F%E5%8C%BA%E5%9F%9F-toc" style="margin-left:160px;"><strong><a href="#3-145%E3%80%81%E5%88%A4%E6%96%AD%E6%9F%90%E5%8D%95%E5%85%83%E6%A0%BC%E5%8C%BA%E5%9F%9F%E6%98%AF%E5%90%A6%E4%B8%BA%E6%95%B0%E7%BB%84%E5%85%AC%E5%BC%8F%E5%8C%BA%E5%9F%9F" rel="nofollow"><span style="color:#1a439c;">3-145、判断某单元格区域是否为数组公式区域</span></a></strong></p> 
<p id="3-146%E3%80%81%E5%88%A4%E6%96%AD%E5%B7%A5%E4%BD%9C%E8%A1%A8%E5%86%85%E6%98%AF%E5%90%A6%E6%9C%89%E6%95%B0%E7%BB%84%E5%85%AC%E5%BC%8F-toc" style="margin-left:160px;"><strong><a href="#3-146%E3%80%81%E5%88%A4%E6%96%AD%E5%B7%A5%E4%BD%9C%E8%A1%A8%E5%86%85%E6%98%AF%E5%90%A6%E6%9C%89%E6%95%B0%E7%BB%84%E5%85%AC%E5%BC%8F" rel="nofollow"><span style="color:#1a439c;">3-146、判断工作表内是否有数组公式</span></a></strong></p> 
<p id="3-147%E3%80%81%E5%88%A4%E6%96%AD%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F%E6%98%AF%E5%90%A6%E5%BC%95%E7%94%A8%E4%BA%86%E5%85%B6%E4%BB%96%E5%B7%A5%E4%BD%9C%E8%A1%A8%E6%95%B0%E6%8D%AE-toc" style="margin-left:160px;"><strong><a href="#3-147%E3%80%81%E5%88%A4%E6%96%AD%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F%E6%98%AF%E5%90%A6%E5%BC%95%E7%94%A8%E4%BA%86%E5%85%B6%E4%BB%96%E5%B7%A5%E4%BD%9C%E8%A1%A8%E6%95%B0%E6%8D%AE" rel="nofollow"><span style="color:#1a439c;">3-147、判断单元格的计算公式是否引用了其他工作表数据</span></a></strong></p> 
<p id="3-148%E3%80%81%E5%88%A4%E6%96%AD%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F%E6%98%AF%E5%90%A6%E5%BC%95%E7%94%A8%E4%BA%86%E5%85%B6%E4%BB%96%E5%B7%A5%E4%BD%9C%E7%B0%BF%E6%95%B0%E6%8D%AE-toc" style="margin-left:160px;"><strong><a href="#3-148%E3%80%81%E5%88%A4%E6%96%AD%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F%E6%98%AF%E5%90%A6%E5%BC%95%E7%94%A8%E4%BA%86%E5%85%B6%E4%BB%96%E5%B7%A5%E4%BD%9C%E7%B0%BF%E6%95%B0%E6%8D%AE" rel="nofollow"><span style="color:#1a439c;">3-148、判断单元格的计算公式是否引用了其他工作簿数据</span></a></strong></p> 
<p id="3-149%E3%80%81%E5%88%A4%E6%96%AD%E6%9F%90%E5%8D%95%E5%85%83%E6%A0%BC%E6%98%AF%E5%90%A6%E4%B8%BA%E5%90%88%E5%B9%B6%E5%8D%95%E5%85%83%E6%A0%BC%E5%8C%BA%E5%9F%9F%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86-toc" style="margin-left:160px;"><strong><a href="#3-149%E3%80%81%E5%88%A4%E6%96%AD%E6%9F%90%E5%8D%95%E5%85%83%E6%A0%BC%E6%98%AF%E5%90%A6%E4%B8%BA%E5%90%88%E5%B9%B6%E5%8D%95%E5%85%83%E6%A0%BC%E5%8C%BA%E5%9F%9F%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86" rel="nofollow"><span style="color:#1a439c;">3-149、判断某单元格是否为合并单元格区域的一部分</span></a></strong></p> 
<p id="3-150%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E5%8C%BA%E5%9F%9F%E5%86%85%E7%9A%84%E5%80%BC-toc" style="margin-left:160px;"><strong><a href="#3-150%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E5%8C%BA%E5%9F%9F%E5%86%85%E7%9A%84%E5%80%BC" rel="nofollow"><span style="color:#1a439c;">3-150、获取单元格区域内的值</span></a></strong></p> 
<p id="3-151%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E5%86%85%E7%9A%84%E5%89%8D%E7%BC%80%E5%AD%97%E7%AC%A6-toc" style="margin-left:160px;"><strong><a href="#3-151%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E5%86%85%E7%9A%84%E5%89%8D%E7%BC%80%E5%AD%97%E7%AC%A6" rel="nofollow"><span style="color:#1a439c;">3-151、获取单元格内的前缀字符</span></a></strong></p> 
<p id="3-152%E3%80%81%E5%88%A4%E6%96%AD%E5%8D%95%E5%85%83%E6%A0%BC%E5%86%85%E7%9A%84%E6%95%B0%E5%AD%97%E6%98%AF%E5%90%A6%E4%B8%BA%E6%96%87%E6%9C%AC%E5%AD%97%E7%AC%A6-toc" style="margin-left:160px;"><strong><a href="#3-152%E3%80%81%E5%88%A4%E6%96%AD%E5%8D%95%E5%85%83%E6%A0%BC%E5%86%85%E7%9A%84%E6%95%B0%E5%AD%97%E6%98%AF%E5%90%A6%E4%B8%BA%E6%96%87%E6%9C%AC%E5%AD%97%E7%AC%A6" rel="nofollow"><span style="color:#1a439c;">3-152、判断单元格内的数字是否为文本字符</span></a></strong></p> 
<p id="3-153%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%A0%BC%E5%BC%8F-toc" style="margin-left:160px;"><strong><a href="#3-153%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%A0%BC%E5%BC%8F" rel="nofollow"><span style="color:#1a439c;">3-153、获取单元格的格式</span></a></strong></p> 
<p id="3-154%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E5%AD%97%E4%BD%93(Font)%E5%AF%B9%E8%B1%A1-toc" style="margin-left:160px;"><strong><a href="#3-154%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E5%AD%97%E4%BD%93%28Font%29%E5%AF%B9%E8%B1%A1" rel="nofollow"><span style="color:#1a439c;">3-154、获取单元格的字体(Font)对象</span></a></strong></p> 
<p id="3-155%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E5%86%85%E9%83%A8(Interior)%E5%AF%B9%E8%B1%A1-toc" style="margin-left:160px;"><strong><a href="#3-155%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E5%86%85%E9%83%A8%28Interior%29%E5%AF%B9%E8%B1%A1" rel="nofollow"><span style="color:#1a439c;">3-155、获取单元格的内部(Interior)对象</span></a></strong></p> 
<p id="3-156%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E8%BE%B9%E6%A1%86(Borders)%E5%AF%B9%E8%B1%A1-toc" style="margin-left:160px;"><strong><a href="#3-156%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E8%BE%B9%E6%A1%86%28Borders%29%E5%AF%B9%E8%B1%A1" rel="nofollow"><span style="color:#1a439c;">3-156、获取单元格的边框(Borders)对象</span></a></strong></p> 
<p id="3-157%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E8%BE%B9%E6%A1%86%E7%BA%BF%E7%9A%84%E7%8A%B6%E6%80%81-toc" style="margin-left:160px;"><strong><a href="#3-157%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E8%BE%B9%E6%A1%86%E7%BA%BF%E7%9A%84%E7%8A%B6%E6%80%81" rel="nofollow"><span style="color:#1a439c;">3-157、获取单元格边框线的状态</span></a></strong></p> 
<p id="3-158%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%A0%B7%E5%BC%8F(Style)%E5%AF%B9%E8%B1%A1-toc" style="margin-left:160px;"><strong><a href="#3-158%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%A0%B7%E5%BC%8F%28Style%29%E5%AF%B9%E8%B1%A1" rel="nofollow"><span style="color:#1a439c;">3-158、获取单元格的样式(Style)对象</span></a></strong></p> 
<p id="3-159%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%9D%A1%E4%BB%B6%E6%A0%BC%E5%BC%8F-toc" style="margin-left:160px;"><strong><a href="#3-159%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%9D%A1%E4%BB%B6%E6%A0%BC%E5%BC%8F" rel="nofollow"><span style="color:#1a439c;">3-159、获取单元格的条件格式</span></a></strong></p> 
<p id="3-160%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E8%BE%93%E5%85%A5%E8%A7%84%E5%88%99(%E6%9C%89%E6%95%88%E6%80%A7%E8%AE%BE%E7%BD%AE)-toc" style="margin-left:160px;"><strong><a href="#3-160%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E8%BE%93%E5%85%A5%E8%A7%84%E5%88%99%28%E6%9C%89%E6%95%88%E6%80%A7%E8%AE%BE%E7%BD%AE%29" rel="nofollow"><span style="color:#1a439c;">3-160、获取单元格的输入规则(有效性设置)</span></a></strong></p> 
<p id="3-161%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E8%B6%85%E9%93%BE%E6%8E%A5-toc" style="margin-left:160px;"><strong><a href="#3-161%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E8%B6%85%E9%93%BE%E6%8E%A5" rel="nofollow"><span style="color:#1a439c;">3-161、获取单元格的超链接</span></a></strong></p> 
<p id="3-162%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%89%B9%E6%B3%A8%E4%BF%A1%E6%81%AF-toc" style="margin-left:160px;"><strong><a href="#3-162%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%89%B9%E6%B3%A8%E4%BF%A1%E6%81%AF" rel="nofollow"><span style="color:#1a439c;">3-162、获取单元格的批注信息</span></a></strong></p> 
<p id="3-163%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E5%A4%A7%E5%B0%8F(%E8%A1%8C%E9%AB%98%E5%92%8C%E5%88%97%E5%AE%BD)-toc" style="margin-left:160px;"><strong><a href="#3-163%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E5%A4%A7%E5%B0%8F%28%E8%A1%8C%E9%AB%98%E5%92%8C%E5%88%97%E5%AE%BD%29" rel="nofollow"><span style="color:#1a439c;">3-163、获取单元格的大小(行高和列宽)</span></a></strong></p> 
<p id="3-164%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E5%9D%90%E6%A0%87-toc" style="margin-left:160px;"><strong><a href="#3-164%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E5%9D%90%E6%A0%87" rel="nofollow"><span style="color:#1a439c;">3-164、获取单元格的坐标</span></a></strong></p> 
<p id="%E4%BA%94%E3%80%81%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB-toc" style="margin-left:80px;"><strong><a href="#%E4%BA%94%E3%80%81%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB" rel="nofollow"><span style="color:#1a439c;">五、推荐阅读</span></a></strong></p> 
<p id="1%E3%80%81-toc" style="margin-left:120px;"><strong><a href="#1%E3%80%81" rel="nofollow"><span style="color:#1a439c;">1、Python筑基之旅</span></a></strong></p> 
<p id="2%E3%80%81-toc" style="margin-left:120px;"><strong><a href="#2%E3%80%81" rel="nofollow"><span style="color:#1a439c;">2、Python函数之旅</span></a></strong></p> 
<p id="3%E3%80%81-toc" style="margin-left:120px;"><strong><a href="#3%E3%80%81" rel="nofollow"><span style="color:#1a439c;">3、Python算法之旅</span></a></strong></p> 
<p id="4%E3%80%81-toc" style="margin-left:120px;"><strong><a href="#4%E3%80%81" rel="nofollow"><span style="color:#1a439c;">4、Python魔法之旅</span></a></strong></p> 
<p id="5%E3%80%81%C2%A0-toc" style="margin-left:120px;"><strong><a href="#5%E3%80%81%C2%A0" rel="nofollow"><span style="color:#1a439c;">5、博客个人主页</span></a></strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/41/e3/xDEA9svz_o.gif"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e2/3f/Hy5qTLw2_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/2d/a6/xzGbflsG_o.gif"></p> 
<p>        在Excel中，通常所说的“<span style="color:#956fe7;"><strong>情侣键</strong></span>”并非官方术语，而是对某些常用且经常成对出现的快捷键的一种形象化的称呼。其中，最为人熟知和广泛使用的“情侣键”是“<span style="color:#fe2c24;"><strong>Ctrl+C</strong></span>”和“<span style="color:#fe2c24;"><strong>Ctrl+V</strong></span>”。</p> 
<p><span style="color:#fe2c24;"><strong>1、Ctrl+C：</strong></span>这个快捷键的作用是“<span style="color:#fe2c24;"><strong>拷贝</strong></span>”或“<span style="color:#fe2c24;"><strong>复制</strong></span>”。当你在Excel中选中某个单元格、一行、一列或整个工作表的内容后，按下Ctrl+C键，这些内容就会被复制到计算机的剪贴板中，等待下一步的粘贴操作。<br><span style="color:#fe2c24;"><strong>2、Ctrl+V：</strong></span>这个快捷键的作用是“<span style="color:#fe2c24;"><strong>粘贴</strong></span>”。在你按下Ctrl+C键将内容复制到剪贴板后，可以通过按下Ctrl+V键将这些内容粘贴到Excel中的另一个位置，这两个操作经常是连续进行的，因此Ctrl+C和Ctrl+V就像一对“情侣”，总是成对出现。</p> 
<p>        除了这对常见的“情侣键”外，Excel中还有许多其他的快捷键可以帮助用户更高效地完成各种操作。然而，这些快捷键通常并没有像Ctrl+C和Ctrl+V那样形成特定的“情侣”关系。</p> 
<p>        然而，今天我不再展开介绍“<span style="color:#956fe7;"><strong>情侣键</strong></span>”，而是要重点推介Python中的“<span style="color:#956fe7;"><strong>情侣库</strong></span>”，即<span style="color:#956fe7;"><strong>xlrd和xlwt</strong></span>两个第三方库。</p> 
<h4 id="%E4%B8%80%E3%80%81xlrd%E5%BA%93%E7%9A%84%E7%94%B1%E6%9D%A5">一、xlrd库的由来</h4> 
<p>        <span style="color:#fe2c24;"><strong>xlrd库</strong></span>是一种用于在Python中<span style="color:#fe2c24;"><strong>读取Excel文件的库</strong></span>，它的名称中的"<span style="color:#fe2c24;"><strong>xl</strong>"</span>代表<span style="color:#fe2c24;"><strong>Excel</strong></span>，"<span style="color:#fe2c24;"><strong>rd</strong></span>"代表<span style="color:#fe2c24;"><strong>读取</strong></span>，其开发者是<span style="color:#956fe7;"><strong>John Machin</strong></span>(注：<span style="color:#1a439c;"><strong>库名字符拆分诠释，只是一种猜测</strong></span>)。</p> 
<p>        xlrd最初是在<span style="color:#fe2c24;"><strong>2005年</strong></span>开始开发的，是基于Python的<span style="color:#fe2c24;"><strong>开源项目</strong></span>(下载：<a href="https://www.python-excel.org/" rel="nofollow" title="xlrd库官网下载">xlrd库官网下载</a>)。</p> 
<p>        由于Excel文件在数据处理和分析中的重要性，<span style="color:#fe2c24;"><strong>xlrd库填补了Python在处理Excel文件方面的空白，</strong></span>使得用户可以方便地在Python环境中读取Excel文件的内容，并进行进一步的数据操作和分析。</p> 
<h4 id="%E4%BA%8C%E3%80%81xlrd%E5%BA%93%E4%BC%98%E7%BC%BA%E7%82%B9">二、xlrd库<span style="color:#1c7331;">优</span><span style="color:#fe2c24;">缺</span>点</h4> 
<h5 id="1%E3%80%81%E4%BC%98%E7%82%B9"><span style="color:#1c7331;">1、优点</span></h5> 
<h6 id="1-1%E3%80%81%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8DExcel%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span style="color:#1c7331;">1-1、支持多种Excel文件格式</span></h6> 
<p>        xlrd库支持多种Excel文件格式，包括`.xls`和`.xlsx`(在旧版本中)，这使得无论数据存储在哪种格式的Excel文件中，用户都可以使用xlrd库来读取。</p> 
<h6 id="1-2%E3%80%81%E9%AB%98%E6%95%88%E6%80%A7"><br><span style="color:#1c7331;">1-2、高效性</span></h6> 
<p>        xlrd库使用C语言编写，因此其性能非常高，即使面对非常大的Excel文件，xlrd也可以快速地读取其中的数据。</p> 
<h6 id="1-3%E3%80%81%E5%BC%80%E6%BA%90%E6%80%A7"><br><span style="color:#1c7331;">1-3、开源性</span></h6> 
<p>        xlrd是完全开源的，可以在GitHub等平台上找到其源代码，这使得任何人都可以根据自己的需求对其进行修改和扩展。</p> 
<h6 id="1-4%E3%80%81%E7%AE%80%E5%8D%95%E6%98%93%E7%94%A8"><br><span style="color:#1c7331;">1-4、简单易用</span></h6> 
<p>        xlrd提供了简单直接的API来获取单元格数据、行列数等，使得从Excel文件中读取数据变得简单而高效。</p> 
<h6 id="1-5%E3%80%81%E8%89%AF%E5%A5%BD%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7"><br><span style="color:#1c7331;">1-5、良好的兼容性</span></h6> 
<p>        xlrd库适配多种Python版本，包括Python 2.7(不包括3.0-3.3)或Python 3.4及以上版本，这为用户提供了广泛的兼容性选择。</p> 
<h5 id="2%E3%80%81%E7%BC%BA%E7%82%B9"><span style="color:#fe2c24;"><strong>2、缺点</strong></span></h5> 
<h6 id="2-1%E3%80%81%E5%AF%B9.xlsx%E6%A0%BC%E5%BC%8F%E6%94%AF%E6%8C%81%E6%9C%89%E9%99%90"><span style="color:#fe2c24;">2-1、对.xlsx格式支持有限</span></h6> 
<p>        在xlrd 1.2.0之后的版本中(大约从2020年开始)，xlrd库不再支持`.xlsx`文件格式，这限制了xlrd在新版Excel文件(主要是`.xlsx`格式)上的应用。</p> 
<h6 id="2-2%E3%80%81%E5%8A%9F%E8%83%BD%E7%9B%B8%E5%AF%B9%E5%8D%95%E4%B8%80"><br><span style="color:#fe2c24;">2-2、功能相对单一</span></h6> 
<p>        xlrd库主要专注于从Excel文件中读取数据，而不提供写入或修改Excel文件的功能，这使得在处理需要写入或修改Excel文件的任务时，用户需要结合其他库(如`openpyxl`或`xlwt`)使用。</p> 
<h6 id="2-3%E3%80%81%E6%9B%B4%E6%96%B0%E5%92%8C%E7%BB%B4%E6%8A%A4%E9%A2%91%E7%8E%87"><br><span style="color:#fe2c24;">2-3、更新和维护频率低</span></h6> 
<p>        由于xlrd库主要关注于读取Excel文件的功能，并且随着`.xlsx`格式的普及，其使用范围逐渐缩小，因此，xlrd库的更新和维护频率可能相对较低。</p> 
<h6 id="2-4%E3%80%81%E4%BE%9D%E8%B5%96%E5%A4%96%E9%83%A8%E8%B5%84%E6%BA%90"><br><span style="color:#fe2c24;">2-4、依赖外部资源</span></h6> 
<p>        在某些情况下，xlrd库可能需要依赖外部资源或库来完全发挥其功能，这可能会增加用户在使用xlrd库时的复杂性和不确定性。</p> 
<p>        总之，xlrd库在读取Excel文件方面具有高效、开源和简单易用等优点，但在对`.xlsx`格式的支持、功能单一以及更新和维护频率等方面存在一些缺点，用户在选择使用xlrd库时需要根据自己的需求进行权衡和选择。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/6d/a9/DWZKEiSy_o.png"></p> 
<h4 id="%E4%B8%89%E3%80%81xlrd%E5%BA%93%E7%9A%84%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E">三、xlrd库的版本说明</h4> 
<p>        xlrd库适配的Python版本根据库的不同版本而有所不同。以下是针对几个主要版本的说明：</p> 
<h5 id="1%E3%80%81xlrd%201.2.0%E7%89%88%E6%9C%AC"><span style="color:#fe2c24;"><strong>1、xlrd 1.2.0版本</strong></span></h5> 
<p>1-1、适配<span style="color:#1c7331;"><strong>Python&gt;=2.7</strong></span>(<span style="color:#fe2c24;"><strong>不包括3.0-3.3</strong></span>)或<span style="color:#1c7331;"><strong>Python&gt;=3.4</strong></span>。<br> 1-2、该版本<span style="color:#1c7331;"><strong>支持xlsx文件格式</strong></span>，并且是一个广泛使用的版本，因为它能够处理小到中等大小的Excel文件，并且具有较好的性能表现。</p> 
<h5 id="2%E3%80%81xlrd%202.0.1%E7%89%88%E6%9C%AC"><span style="color:#fe2c24;"><strong>2、xlrd 2.0.1版本</strong></span></h5> 
<p>2-1、适配<span style="color:#1c7331;"><strong>Python&gt;=2.7</strong></span>(<span style="color:#fe2c24;"><strong>不包括3.0-3.5</strong></span>)或<span style="color:#1c7331;"><strong>Python&gt;=3.6</strong></span>。<br> 2-2、该版本<span style="color:#fe2c24;"><strong>不再支持xlsx文件格式</strong>，</span><span style="color:#1c7331;"><strong>仅支持旧版的xls文件格式</strong></span>，因为在xlrd 2.0版本之后，xlrd移除了对xlsx格式的支持。</p> 
<h5 id="3%E3%80%81xlrd3(%E9%9D%9E%E5%AE%98%E6%96%B9%E5%90%8D%E7%A7%B0)"><span style="color:#fe2c24;"><strong>3、xlrd3</strong></span><span style="color:#956fe7;"><strong>(非官方名称)</strong></span></h5> 
<p>        xlrd3是xlrd的开源扩展库，提供了对xlsx文件格式的支持，然而，请注意，xlrd3并不是xlrd的官方名称(下载：<a href="https://github.com/Dragon2fly/xlrd3" title="GitHub - Dragon2fly/xlrd3">GitHub - Dragon2fly/xlrd3</a>)。</p> 
<h4 id="%E5%9B%9B%E3%80%81%E5%A6%82%E4%BD%95%E5%AD%A6%E5%A5%BDxlrd%E5%BA%93%EF%BC%9F">四、如何学好xlrd库？</h4> 
<h5 id="1%E3%80%81%E8%8E%B7%E5%8F%96xlrd%E5%BA%93%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95">1、获取xlrd库的属性和方法</h5> 
<p>        用print()和dir()两个函数获取xlrd库所有属性和方法的列表</p> 
<pre><code class="language-python"># ['Book', 'FILE_FORMAT_DESCRIPTIONS', 'FMLA_TYPE_ARRAY', 'FMLA_TYPE_CELL', 'FMLA_TYPE_COND_FMT', 'FMLA_TYPE_DATA_VAL',
# 'FMLA_TYPE_NAME', 'FMLA_TYPE_SHARED', 'Operand', 'PEEK_SIZE', 'Ref3D', 'XLDateError', 'XLRDError', 'XLS_SIGNATURE',
# 'XL_CELL_BLANK', 'XL_CELL_BOOLEAN', 'XL_CELL_DATE', 'XL_CELL_EMPTY', 'XL_CELL_ERROR', 'XL_CELL_NUMBER', 'XL_CELL_TEXT', 'ZIP_SIGNATURE', 
# '__VERSION__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', 
# '__spec__', '__version__', 
# 'biff_text_from_num', 'biffh', 'book', 'cellname', 'cellnameabs', 'colname', 'compdoc', 'count_records', 'decompile_formula', 
# 'dump', 'dump_formula', 'empty_cell', 'error_text_from_code', 'evaluate_name_formula', 'formatting', 'formula', 'info', 
# 'inspect_format', 'oBOOL', 'oERR', 'oNUM', 'oREF', 'oREL', 'oSTRG', 'oUNK', 'okind_dict', 'open_workbook', 'open_workbook_xls', 
# 'os', 'pprint', 'rangename3d', 'rangename3drel', 'sheet', 'sys', 'timemachine', 'xldate', 'xldate_as_datetime', 'xldate_as_tuple', 'zipfile']</code></pre> 
<h5 id="2%E3%80%81%E8%8E%B7%E5%8F%96xlrd%E5%BA%93%E7%9A%84%E5%B8%AE%E5%8A%A9%E4%BF%A1%E6%81%AF">2、获取xlrd库的帮助信息</h5> 
<p>        用help()函数获取xlrd库的帮助信息</p> 
<pre><code class="language-python">Help on package xlrd:

NAME
    xlrd

DESCRIPTION
    # Copyright (c) 2005-2012 Stephen John Machin, Lingfo Pty Ltd
    # This module is part of the xlrd package, which is released under a
    # BSD-style licence.

PACKAGE CONTENTS
    biffh
    book
    compdoc
    formatting
    formula
    info
    sheet
    timemachine
    xldate

FUNCTIONS
    count_records(filename, outfile=&lt;_io.TextIOWrapper name='&lt;stdout&gt;' mode='w' encoding='utf-8'&gt;)
        For debugging and analysis: summarise the file's BIFF records.
        ie: produce a sorted file of ``(record_name, count)``.
        
        :param filename: The path to the file to be summarised.
        :param outfile: An open file, to which the summary is written.
    
    dump(filename, outfile=&lt;_io.TextIOWrapper name='&lt;stdout&gt;' mode='w' encoding='utf-8'&gt;, unnumbered=False)
        For debugging: dump an XLS file's BIFF records in char &amp; hex.
        
        :param filename: The path to the file to be dumped.
        :param outfile: An open file, to which the dump is written.
        :param unnumbered: If true, omit offsets (for meaningful diffs).
    
    inspect_format(path=None, content=None)
        Inspect the content at the supplied path or the :class:`bytes` content provided
        and return the file's type as a :class:`str`, or ``None`` if it cannot
        be determined.
        
        :param path:
          A :class:`string &lt;str&gt;` path containing the content to inspect.
          ``~`` will be expanded.
        
        :param content:
          The :class:`bytes` content to inspect.
        
        :returns:
           A :class:`str`, or ``None`` if the format cannot be determined.
           The return value can always be looked up in :data:`FILE_FORMAT_DESCRIPTIONS`
           to return a human-readable description of the format found.
    
    open_workbook(filename=None, logfile=&lt;_io.TextIOWrapper name='&lt;stdout&gt;' mode='w' encoding='utf-8'&gt;, verbosity=0, use_mmap=True, file_contents=None, encoding_override=None, formatting_info=False, on_demand=False, ragged_rows=False, ignore_workbook_corruption=False)
        Open a spreadsheet file for data extraction.
        
        :param filename: The path to the spreadsheet file to be opened.
        
        :param logfile: An open file to which messages and diagnostics are written.
        
        :param verbosity: Increases the volume of trace material written to the
                          logfile.
        
        :param use_mmap:
        
          Whether to use the mmap module is determined heuristically.
          Use this arg to override the result.
        
          Current heuristic: mmap is used if it exists.
        
        :param file_contents:
        
          A string or an :class:`mmap.mmap` object or some other behave-alike
          object. If ``file_contents`` is supplied, ``filename`` will not be used,
          except (possibly) in messages.
        
        :param encoding_override:
        
          Used to overcome missing or bad codepage information
          in older-version files. See :doc:`unicode`.
        
        :param formatting_info:
        
          The default is ``False``, which saves memory.
          In this case, "Blank" cells, which are those with their own formatting
          information but no data, are treated as empty by ignoring the file's
          ``BLANK`` and ``MULBLANK`` records.
          This cuts off any bottom or right "margin" of rows of empty or blank
          cells.
          Only :meth:`~xlrd.sheet.Sheet.cell_value` and
          :meth:`~xlrd.sheet.Sheet.cell_type` are available.
        
          When ``True``, formatting information will be read from the spreadsheet
          file. This provides all cells, including empty and blank cells.
          Formatting information is available for each cell.
        
          Note that this will raise a NotImplementedError when used with an
          xlsx file.
        
        :param on_demand:
        
          Governs whether sheets are all loaded initially or when demanded
          by the caller. See :doc:`on_demand`.
        
        :param ragged_rows:
        
          The default of ``False`` means all rows are padded out with empty cells so
          that all rows have the same size as found in
          :attr:`~xlrd.sheet.Sheet.ncols`.
        
          ``True`` means that there are no empty cells at the ends of rows.
          This can result in substantial memory savings if rows are of widely
          varying sizes. See also the :meth:`~xlrd.sheet.Sheet.row_len` method.
        
        
        :param ignore_workbook_corruption:
        
          This option allows to read corrupted workbooks.
          When ``False`` you may face CompDocError: Workbook corruption.
          When ``True`` that exception will be ignored.
        
        :returns: An instance of the :class:`~xlrd.book.Book` class.

DATA
    FILE_FORMAT_DESCRIPTIONS = {'xls': 'Excel xls', 'xlsb': 'Excel 2007 xl...
    FMLA_TYPE_ARRAY = 4
    FMLA_TYPE_CELL = 1
    FMLA_TYPE_COND_FMT = 8
    FMLA_TYPE_DATA_VAL = 16
    FMLA_TYPE_NAME = 32
    FMLA_TYPE_SHARED = 2
    PEEK_SIZE = 8
    XLS_SIGNATURE = b'\xd0\xcf\x11\xe0\xa1\xb1\x1a\xe1'
    XL_CELL_BLANK = 6
    XL_CELL_BOOLEAN = 4
    XL_CELL_DATE = 3
    XL_CELL_EMPTY = 0
    XL_CELL_ERROR = 5
    XL_CELL_NUMBER = 2
    XL_CELL_TEXT = 1
    ZIP_SIGNATURE = b'PK\x03\x04'
    __VERSION__ = '2.0.1'
    biff_text_from_num = {0: '(not BIFF)', 20: '2.0', 21: '2.1', 30: '3', ...
    empty_cell = empty:''
    error_text_from_code = {0: '#NULL!', 7: '#DIV/0!', 15: '#VALUE!', 23: ...
    oBOOL = 3
    oERR = 4
    oNUM = 2
    oREF = -1
    oREL = -2
    oSTRG = 1
    oUNK = 0
    okind_dict = {-2: 'oREL', -1: 'oREF', 0: 'oUNK', 1: 'oSTRG', 2: 'oNUM'...

VERSION
    2.0.1

FILE
    e:\python_workspace\pythonproject\lib\site-packages\xlrd\__init__.py</code></pre> 
<h5 id="3%E3%80%81%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B">3、实战案例</h5> 
<h6 id="3-121%E3%80%81%E5%BC%95%E7%94%A8%E8%BE%93%E5%85%A5%E4%BA%86%E6%9F%90%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%80%E6%9C%89%E5%8D%95%E5%85%83%E6%A0%BC"><span style="color:#fe2c24;">3-144、判断工作表内是否有公式</span></h6> 
<pre><code class="language-python">略，xlrd库不支持此功能，需要借助其他库实现</code></pre> 
<h6 id="3-145%E3%80%81%E5%88%A4%E6%96%AD%E6%9F%90%E5%8D%95%E5%85%83%E6%A0%BC%E5%8C%BA%E5%9F%9F%E6%98%AF%E5%90%A6%E4%B8%BA%E6%95%B0%E7%BB%84%E5%85%AC%E5%BC%8F%E5%8C%BA%E5%9F%9F"><span style="color:#fe2c24;">3-145、判断某单元格区域是否为数组公式区域</span></h6> 
<pre><code class="language-python">略，xlrd库不支持此功能，需要借助其他库实现</code></pre> 
<h6 id="3-146%E3%80%81%E5%88%A4%E6%96%AD%E5%B7%A5%E4%BD%9C%E8%A1%A8%E5%86%85%E6%98%AF%E5%90%A6%E6%9C%89%E6%95%B0%E7%BB%84%E5%85%AC%E5%BC%8F"><span style="color:#fe2c24;">3-146、判断工作表内是否有数组公式</span></h6> 
<pre><code class="language-python">略，xlrd库不支持此功能，需要借助其他库实现</code></pre> 
<h6 id="3-147%E3%80%81%E5%88%A4%E6%96%AD%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F%E6%98%AF%E5%90%A6%E5%BC%95%E7%94%A8%E4%BA%86%E5%85%B6%E4%BB%96%E5%B7%A5%E4%BD%9C%E8%A1%A8%E6%95%B0%E6%8D%AE"><span style="color:#fe2c24;">3-147、判断单元格的计算公式是否引用了其他工作表数据</span></h6> 
<pre><code class="language-python">略，xlrd库不支持此功能，需要借助其他库实现</code></pre> 
<h6 id="3-148%E3%80%81%E5%88%A4%E6%96%AD%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F%E6%98%AF%E5%90%A6%E5%BC%95%E7%94%A8%E4%BA%86%E5%85%B6%E4%BB%96%E5%B7%A5%E4%BD%9C%E7%B0%BF%E6%95%B0%E6%8D%AE"><span style="color:#fe2c24;">3-148、判断单元格的计算公式是否引用了其他工作簿数据</span></h6> 
<pre><code class="language-python">略，xlrd库不支持此功能，需要借助其他库实现</code></pre> 
<h6 id="3-149%E3%80%81%E5%88%A4%E6%96%AD%E6%9F%90%E5%8D%95%E5%85%83%E6%A0%BC%E6%98%AF%E5%90%A6%E4%B8%BA%E5%90%88%E5%B9%B6%E5%8D%95%E5%85%83%E6%A0%BC%E5%8C%BA%E5%9F%9F%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86"><span style="color:#fe2c24;">3-149、判断某单元格是否为合并单元格区域的一部分</span></h6> 
<pre><code class="language-python"># 149、判断某单元格是否为合并单元格区域的一部分
import xlrd
# 打开 Excel 文件
workbook = xlrd.open_workbook(r'E:\360Downloads\test.xls')
# 选择工作表
sheet = workbook.sheet_by_index(0)  # 或者使用 sheet_by_name('test1')
# 获取合并单元格区域列表
merged_cells = sheet.merged_cells
# 假设我们要检查的单元格是 (row_num, col_num)
row_num = 1
col_num = 2
# 遍历所有合并单元格区域
for (start_row, start_col), (end_row, end_col) in merged_cells:
    # 检查单元格是否在合并区域内
    if start_row &lt;= row_num &lt;= end_row and start_col &lt;= col_num &lt;= end_col:
        print(f"单元格 ({row_num},{col_num}) 是合并单元格区域的一部分。")
        break
else:
    print(f"单元格 ({row_num},{col_num}) 不是合并单元格区域的一部分!")</code></pre> 
<h6 id="3-150%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E5%8C%BA%E5%9F%9F%E5%86%85%E7%9A%84%E5%80%BC"><span style="color:#fe2c24;">3-150、获取单元格区域内的值</span></h6> 
<pre><code class="language-python"># 150、获取单元格区域内的值，并使其矩阵化
import xlrd
# 打开Excel文件
workbook = xlrd.open_workbook(r'E:\360Downloads\test.xls')
# 选择要读取的工作表
sheet = workbook.sheet_by_name('test1')
# 定义要读取的单元格区域（例如A1到C3）
start_row = 0
end_row = 2
start_col = 0
end_col = 2
# 读取单元格区域的值
cell_values = []
for row in range(start_row, end_row + 1):
    row_cells = []
    for col in range(start_col, end_col + 1):
        cell_value = sheet.cell_value(row, col)
        row_cells.append(cell_value)
    cell_values.append(row_cells)
# 输出单元格区域的矩阵化值
for row in cell_values:
    print(row)</code></pre> 
<h6 id="3-151%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E5%86%85%E7%9A%84%E5%89%8D%E7%BC%80%E5%AD%97%E7%AC%A6"><span style="color:#fe2c24;">3-151、获取单元格内的前缀字符</span></h6> 
<pre><code class="language-python">略，xlrd库不支持此功能，需要借助其他库实现</code></pre> 
<h6 id="3-152%E3%80%81%E5%88%A4%E6%96%AD%E5%8D%95%E5%85%83%E6%A0%BC%E5%86%85%E7%9A%84%E6%95%B0%E5%AD%97%E6%98%AF%E5%90%A6%E4%B8%BA%E6%96%87%E6%9C%AC%E5%AD%97%E7%AC%A6"><span style="color:#fe2c24;">3-152、判断单元格内的数字是否为文本字符</span></h6> 
<pre><code class="language-python"># 152、判断单元格内的数字是否为文本字符
import xlrd
# 打开 Excel 文件
workbook = xlrd.open_workbook(r'E:\360Downloads\test.xls')
# 选择工作表
sheet = workbook.sheet_by_index(0)  # 或使用 sheet_by_name('Sheet1')
# 假设我们要检查的单元格是 A1
cell_value = sheet.cell_value(0, 0)  # 行索引从 0 开始，列索引也从 0 开始
# 检查单元格值是否为字符串，并且只包含数字字符
if isinstance(cell_value, str) and cell_value.isdigit():
    print("单元格 A1 中的数字是作为文本字符读取的。")
else:
    print("单元格 A1 中的数字不是作为文本字符读取的!")</code></pre> 
<h6 id="3-153%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%A0%BC%E5%BC%8F"><span style="color:#fe2c24;">3-153、获取单元格的格式</span></h6> 
<pre><code class="language-python"># 153、获取单元格的格式
import xlrd
# 打开 Excel 文件，设置 formatting_info 参数为 True
workbook = xlrd.open_workbook(r'E:\360Downloads\test.xls', formatting_info=True)
sheet = workbook.sheet_by_name('test1')
# 选择要获取格式的单元格
row_index = 0
col_index = 0
# 获取单元格对象
cell = sheet.cell(row_index, col_index)
# 获取格式索引
xf_index = cell.xf_index
# 获取格式对象
xf = workbook.xf_list[xf_index]
# 获取格式的属性
font = workbook.font_list[xf.font_index]
background = xf.background  # 直接从 xf 获取背景对象
alignment = xf.alignment  # 直接从 xf 获取对齐方式对象
# 打印格式信息
print(f"字体颜色: {font.colour_index}")
print(f"背景颜色: {background.pattern_colour_index}")
print(f"水平对齐方式: {alignment.hor_align}")
print(f"垂直对齐方式: {alignment.vert_align}")</code></pre> 
<h6 id="3-154%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E5%AD%97%E4%BD%93(Font)%E5%AF%B9%E8%B1%A1"><span style="color:#fe2c24;">3-154、获取单元格的字体(Font)对象</span></h6> 
<pre><code class="language-python"># 154、获取单元格的字体(Font)对象
import xlrd
# 打开Excel文件
workbook = xlrd.open_workbook(r'E:\360Downloads\test.xls', formatting_info=True)
# 选择工作表
sheet = workbook.sheet_by_index(0)
# 获取特定单元格的内容
cell = sheet.cell(0, 0)  # 获取第一个单元格 (A1)
# 获取单元格的格式索引
xf_index = cell.xf_index  # 获取格式索引
cell_xf = workbook.xf_list[xf_index]  # 从格式列表中获取格式对象
# 获取字体信息
font = workbook.font_list[cell_xf.font_index]
# 输出字体信息
print(f'字体名称: {font.name}')
print(f'字体大小: {font.height / 20}')  # 字体大小单位是twips，需除以20
print(f'是否加粗: {font.bold}')
print(f'是否斜体: {font.italic}')
print(f'字体颜色: #{font.colour_index:02X}')
# 输出：
# 字体名称: 微软雅黑
# 字体大小: 9.0
# 是否加粗: 0
# 是否斜体: 0
# 字体颜色: #08</code></pre> 
<h6 id="3-155%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E5%86%85%E9%83%A8(Interior)%E5%AF%B9%E8%B1%A1"><span style="color:#fe2c24;">3-155、获取单元格的内部(Interior)对象</span></h6> 
<pre><code class="language-python"># 155、获取单元格的内部(Interior)对象
import xlrd
# 打开现有的 Excel 文件
workbook = xlrd.open_workbook(r'E:\360Downloads\test.xls', formatting_info=True)
# 获取第一个工作表
sheet = workbook.sheet_by_index(0)
# 获取单元格内容
cell_value = sheet.cell(0, 0).value
print('单元格内容:', cell_value)
# 获取单元格的字体颜色（仅限于 .xls 文件）
cell_xf_index = sheet.cell_xf_index(0, 0)
cell_xf = workbook.xf_list[cell_xf_index]
font_index = cell_xf.font_index
font = workbook.font_list[font_index]
print('字体颜色:', font.colour_index)</code></pre> 
<h6 id="3-156%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E8%BE%B9%E6%A1%86(Borders)%E5%AF%B9%E8%B1%A1"><span style="color:#fe2c24;">3-156、获取单元格的边框(Borders)对象</span></h6> 
<pre><code class="language-python"># 156、获取单元格的边框(Borders)对象
import xlrd
# 打开现有的 Excel 文件
workbook = xlrd.open_workbook(r'E:\360Downloads\test.xls', formatting_info=True)
# 获取第一个工作表
sheet = workbook.sheet_by_index(0)
# 获取单元格的 XF 索引
cell_xf_index = sheet.cell_xf_index(0, 0)
cell_xf = workbook.xf_list[cell_xf_index]
# 获取单元格边框信息
border = cell_xf.border
print(f"左边框: {border.left_line_style}")
print(f"右边框: {border.right_line_style}")
print(f"上边框: {border.top_line_style}")
print(f"下边框: {border.bottom_line_style}")</code></pre> 
<h6 id="3-157%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E8%BE%B9%E6%A1%86%E7%BA%BF%E7%9A%84%E7%8A%B6%E6%80%81"><span style="color:#fe2c24;">3-157、获取单元格边框线的状态</span></h6> 
<pre><code class="language-python"># 157、获取单元格边框线的状态
import xlrd
# 打开现有的 Excel 文件
workbook = xlrd.open_workbook(r'E:\360Downloads\test.xls', formatting_info=True)
# 获取第一个工作表
sheet = workbook.sheet_by_index(0)
# 获取单元格的 XF 索引
cell_xf_index = sheet.cell_xf_index(0, 0)
cell_xf = workbook.xf_list[cell_xf_index]
# 获取单元格边框信息
border = cell_xf.border
print(f"左边框: {border.left_line_style}")
print(f"右边框: {border.right_line_style}")
print(f"上边框: {border.top_line_style}")
print(f"下边框: {border.bottom_line_style}")</code></pre> 
<h6 id="3-158%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%A0%B7%E5%BC%8F(Style)%E5%AF%B9%E8%B1%A1"><span style="color:#fe2c24;">3-158、获取单元格的样式(Style)对象</span></h6> 
<pre><code class="language-python"># 158、获取单元格的样式(Style)对象
import xlrd
# 打开Excel工作簿
workbook = xlrd.open_workbook(r'E:\360Downloads\test.xls', formatting_info=True)
# 获取第一个工作表
sheet = workbook.sheet_by_index(0)
# 获取指定单元格，例如第一行第一列的单元格
row, col = 0, 0
cell = sheet.cell(row, col)
# 获取该单元格的样式索引
xf_index = cell.xf_index
# 从工作簿中获取样式对象
cell_style = workbook.xf_list[xf_index]
# 获取单元格的字体样式
font = workbook.font_list[cell_style.font_index]
# 打印字体相关信息
print('Font Name:', font.name)
print('Bold:', font.bold)
print('Italic:', font.italic)
print('Underline:', font.underline_type)
# 获取单元格的背景填充信息
background = cell_style.background
# 打印背景颜色信息
print('Background Color:', background.pattern_colour_index)
print('Foreground Color:', background.pattern_colour_index)</code></pre> 
<h6 id="3-159%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%9D%A1%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span style="color:#fe2c24;">3-159、获取单元格的条件格式</span></h6> 
<pre><code class="language-python">略，xlrd库不支持此功能，需要借助其他库实现</code></pre> 
<h6 id="3-160%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E8%BE%93%E5%85%A5%E8%A7%84%E5%88%99(%E6%9C%89%E6%95%88%E6%80%A7%E8%AE%BE%E7%BD%AE)"><span style="color:#fe2c24;">3-160、获取单元格的输入规则(有效性设置)</span></h6> 
<pre><code class="language-python">略，xlrd库不支持此功能，需要借助其他库实现</code></pre> 
<h6 id="3-161%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E8%B6%85%E9%93%BE%E6%8E%A5"><span style="color:#fe2c24;">3-161、获取单元格的超链接</span></h6> 
<pre><code class="language-python">略，xlrd库不支持此功能，需要借助其他库实现</code></pre> 
<h6 id="3-162%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%89%B9%E6%B3%A8%E4%BF%A1%E6%81%AF"><span style="color:#fe2c24;">3-162、获取单元格的批注信息</span></h6> 
<pre><code class="language-python"># 162、获取单元格的批注信息
import xlrd
# 打开Excel工作簿
workbook = xlrd.open_workbook(r'E:\360Downloads\test.xls', formatting_info=True)
# 获取第一个工作表
sheet = workbook.sheet_by_index(0)
# 获取批注信息
for row_idx in range(sheet.nrows):
    for col_idx in range(sheet.ncols):
        cell = sheet.cell(row_idx, col_idx)
        comment = sheet.cell_note_map.get((row_idx, col_idx))
        if comment:
            print(f"Cell ({row_idx}, {col_idx}) Comment: {comment.text}") # 输出：Cell (0, 0) Comment: Hello,Python!</code></pre> 
<h6 id="3-163%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E5%A4%A7%E5%B0%8F(%E8%A1%8C%E9%AB%98%E5%92%8C%E5%88%97%E5%AE%BD)"><span style="color:#fe2c24;">3-163、获取单元格的大小(行高和列宽)</span></h6> 
<pre><code class="language-python"># 163、获取单元格的大小(行高和列宽)
import xlrd
# 打开Excel文件
workbook = xlrd.open_workbook(r'E:\360Downloads\test.xls', formatting_info=True)  # xlrd 仅支持 .xls 文件格式
# 选择工作表
sheet = workbook.sheet_by_index(0)
# 获取所有列宽
column_widths = sheet.colinfo_map
for col_index, col_info in column_widths.items():
    print(f"列 {col_index} 的宽度: {col_info.width / 256}")
# 获取所有行高
row_heights = sheet.rowinfo_map
for row_index, row_info in row_heights.items():
    print(f"行 {row_index} 的高度: {row_info.height / 20}")</code></pre> 
<h6 id="3-164%E3%80%81%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E5%9D%90%E6%A0%87"><span style="color:#fe2c24;">3-164、获取单元格的坐标</span></h6> 
<pre><code class="language-python"># 164、获取单元格的坐标
import xlrd
# 打开Excel文件
workbook = xlrd.open_workbook(r'E:\360Downloads\test.xls', formatting_info=True)  # xlrd 仅支持 .xls 文件格式
# 选择工作表
sheet = workbook.sheet_by_index(0)
# 获取工作表的行数和列数
num_rows = sheet.nrows
num_cols = sheet.ncols
# 遍历每个单元格并打印其坐标和内容
for row_idx in range(num_rows):
    for col_idx in range(num_cols):
        cell_value = sheet.cell_value(row_idx, col_idx)
        print(f"单元格({row_idx}, {col_idx})的内容是: {cell_value}")</code></pre> 
<h4 id="%E4%BA%94%E3%80%81%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB">五、推荐阅读</h4> 
<h5 id="1%E3%80%81">1、<a href="https://myelsa1024.blog.csdn.net/article/details/139241094?spm=1001.2014.3001.5502" rel="nofollow" title="Python筑基之旅">Python筑基之旅</a></h5> 
<h5 id="2%E3%80%81">2、<a href="https://myelsa1024.blog.csdn.net/article/details/138916144?spm=1001.2014.3001.5502" rel="nofollow" title="Python函数之旅">Python函数之旅</a></h5> 
<h5 id="3%E3%80%81">3、<a href="https://blog.csdn.net/ygb_1024/article/details/136889623?spm=1001.2014.3001.5501" title="Python算法之旅">Python算法之旅</a></h5> 
<h5 id="4%E3%80%81">4、<a href="https://myelsa1024.blog.csdn.net/article/details/139555733" rel="nofollow" title="Python魔法之旅">Python魔法之旅</a></h5> 
<h5 id="5%E3%80%81%C2%A0">5、<a href="https://blog.csdn.net/ygb_1024?spm=1010.2135.3001.5421" title="博客个人主页">博客个人主页</a></h5>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/915807d928b111b3c3661f76d6810058/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">前端冲刺必备指南</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/70c36e06530fc02e7839b7c61d1c30f7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">“上帝的归上帝，凯撒的归凯撒”：劳动学说界定AIGC著作权及其方法论</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>