<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43; 之 string类的模拟实现 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/39a65234c3c5cce70c2c83e6c5e5e635/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C&#43;&#43; 之 string类的模拟实现">
  <meta property="og:description" content="这学习我有三不学
昨天不学，因为昨天是个过去
明天不学，因为明天还是个未知数
今天不学，因为我们要活在当下，我就是玩嘿嘿~
–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀-正文开始-❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–
目录
一、string类的模拟实现
1.成员函数(Member functions)
1.1 构造函数(constructor)
1.2 析构函数(destructor)
1.3 赋值拷贝函数(operator=)
2.迭代器(iterators)
3.容量(Capacity)
4.元素访问(Element access)
5.调节器(Modifiers)
6.字符操作(String operation)
7.成员常量(Member constant)npos实现
8.非成员函数重载(Non-member function overload)
二、完结撒❀
前言：
模拟string类的实现对于我们学习认识string类会有更加深刻的理解，还没学过string类的老铁建议可以先看学习一下我的上一篇博客讲解：C&#43;&#43; 之 string类 详细讲解，再来进行模拟实现。
一、string类的模拟实现 在上篇博客中讲解了string类的常用接口，这篇博客带大家模拟实现一下string类的一些常用接口。
string类查阅文档
我们根据上面文档所规划的接口分类为大家进行部分模拟实现，大家可以先简单看一下上面文档。
1.成员函数(Member functions) 1.1 构造函数(constructor) ● 无参构造函数 string() 实现：
string() //:_str(nullptr) :_str(new char[1])//不能赋空指针，因为直接c_str会出错 , _size(0) , _capacity(0) { _str[0] = &#39;\0&#39;; } ● 有参(字符串)构造函数 string(const char* str = &#34;&#34;) 实现：
//string(const char* str = nullptr)错 //string(const char* str = &#39;\0&#39;)错 string(const char* str = &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-26T14:33:44+08:00">
    <meta property="article:modified_time" content="2024-04-26T14:33:44+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43; 之 string类的模拟实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="149" src="https://images2.imgbox.com/e5/c7/EuNHnvlV_o.png" width="148"></h2> 
<p>这学习我有三不学</p> 
<p>昨天不学，因为昨天是个过去</p> 
<p>明天不学，因为明天还是个未知数</p> 
<p>今天不学，因为我们要活在当下，我就是玩嘿嘿~</p> 
<p>–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀-正文开始-❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81string%E7%B1%BB%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81string%E7%B1%BB%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" rel="nofollow">一、string类的模拟实现</a></p> 
<p id="1.%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0(Member%20functions)-toc" style="margin-left:40px;"><a href="#1.%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%28Member%20functions%29" rel="nofollow">1.成员函数(Member functions)</a></p> 
<p id="1.1%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0(constructor)-toc" style="margin-left:80px;"><a href="#1.1%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%28constructor%29" rel="nofollow">1.1 构造函数(constructor)</a></p> 
<p id="1.2%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0(destructor)-toc" style="margin-left:80px;"><a href="#1.2%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%28destructor%29" rel="nofollow">1.2 析构函数(destructor)</a></p> 
<p id="1.3%20%E8%B5%8B%E5%80%BC%E6%8B%B7%E8%B4%9D%E5%87%BD%E6%95%B0(operator%3D)-toc" style="margin-left:80px;"><a href="#1.3%20%E8%B5%8B%E5%80%BC%E6%8B%B7%E8%B4%9D%E5%87%BD%E6%95%B0%28operator%3D%29" rel="nofollow">1.3 赋值拷贝函数(operator=)</a></p> 
<p id="2.%E8%BF%AD%E4%BB%A3%E5%99%A8(iterators)-toc" style="margin-left:40px;"><a href="#2.%E8%BF%AD%E4%BB%A3%E5%99%A8%28iterators%29" rel="nofollow">2.迭代器(iterators)</a></p> 
<p id="3.%E5%AE%B9%E9%87%8F(Capacity)-toc" style="margin-left:40px;"><a href="#3.%E5%AE%B9%E9%87%8F%28Capacity%29" rel="nofollow">3.容量(Capacity)</a></p> 
<p id="4.%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE(Element%20access)-toc" style="margin-left:40px;"><a href="#4.%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE%28Element%20access%29" rel="nofollow">4.元素访问(Element access)</a></p> 
<p id="5.%E8%B0%83%E8%8A%82%E5%99%A8(Modifiers)-toc" style="margin-left:40px;"><a href="#5.%E8%B0%83%E8%8A%82%E5%99%A8%28Modifiers%29" rel="nofollow">5.调节器(Modifiers)</a></p> 
<p id="6.%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C(String%20operation)-toc" style="margin-left:40px;"><a href="#6.%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C%28String%20operation%29" rel="nofollow">6.字符操作(String operation)</a></p> 
<p id="7.%E6%88%90%E5%91%98%E5%B8%B8%E9%87%8F(Member%20constant)npos%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#7.%E6%88%90%E5%91%98%E5%B8%B8%E9%87%8F%28Member%20constant%29npos%E5%AE%9E%E7%8E%B0" rel="nofollow">7.成员常量(Member constant)npos实现</a></p> 
<p id="8.%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD(Non-member%20function%20overload)-toc" style="margin-left:40px;"><a href="#8.%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%28Non-member%20function%20overload%29" rel="nofollow">8.非成员函数重载(Non-member function overload)</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%AE%8C%E7%BB%93%E6%92%92%E2%9D%80-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%AE%8C%E7%BB%93%E6%92%92%E2%9D%80" rel="nofollow">二、完结撒❀</a></p> 
<hr id="hr-toc"> 
<p>前言：</p> 
<p>模拟string类的实现对于我们学习认识string类会有更加深刻的理解，还没学过string类的老铁建议可以先看学习一下我的上一篇博客讲解：<a class="link-info" href="https://blog.csdn.net/foodsx/article/details/138187900" title="C++ 之 string类 详细讲解">C++ 之 string类 详细讲解</a>，再来进行模拟实现。</p> 
<p></p> 
<h2>一、string类的模拟实现</h2> 
<p>在上篇博客中讲解了string类的常用接口，这篇博客带大家模拟实现一下string类的一些常用接口。</p> 
<p><a class="link-info" href="https://legacy.cplusplus.com/reference/string/string/?kw=string" rel="nofollow" title="string类查阅文档">string类查阅文档</a></p> 
<p>我们根据上面文档所规划的接口分类为大家进行部分模拟实现，大家可以先简单看一下上面文档。</p> 
<h3 id="1.%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0(Member%20functions)">1.成员函数(Member functions)</h3> 
<h4 id="1.1%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0(constructor)">1.1 构造函数(constructor)</h4> 
<p><strong>● 无参构造函数 string() 实现：</strong></p> 
<pre><code class="language-cpp">string()
	//:_str(nullptr)
	:_str(new char[1])//不能赋空指针，因为直接c_str会出错
	, _size(0)
	, _capacity(0)
{
	_str[0] = '\0';
}</code></pre> 
<p>● <strong>有参(字符串)构造函数 string(const char* str = "")</strong> <strong>实现：</strong></p> 
<pre><code class="language-cpp">//string(const char* str = nullptr)错
//string(const char* str = '\0')错
string(const char* str = "")//常量字符串默认结尾含有\0
//该构造函数可以替代上面无参构造函数
	:_size(strlen(str))
{
	_capacity = _size;
	_str = new char[_capacity + 1];
	strcpy(_str, str);
}</code></pre> 
<p><strong>● 拷贝构造函数</strong> <strong>string (const string&amp; s) 实现：</strong><br>  </p> 
<pre><code class="language-cpp">//s2(s1)
string (const string&amp; s)
{
	_str = new char[s._capacity+1];//完成深拷贝，+1 存放\0使用
	strcpy(_str, s._str);
	_size = s._size;
	_capacity = s._capacity;
}</code></pre> 
<h4 id="1.2%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0(destructor)"><strong>1.2 析构函数(destructor)</strong></h4> 
<h4 id="%E2%97%8F%20~string()%E5%AE%9E%E7%8E%B0%EF%BC%9A">● ~string()<strong>实现：</strong></h4> 
<pre><code class="language-cpp">~string()
{
	delete[] _str;
	_str = nullptr;
	_size = _capacity = 0;
}</code></pre> 
<h4 id="1.3%20%E8%B5%8B%E5%80%BC%E6%8B%B7%E8%B4%9D%E5%87%BD%E6%95%B0(operator%3D)"><strong>1.3 赋值拷贝函数(operator=)</strong></h4> 
<h4 id="%E2%97%8F%20operator%3D%E5%AE%9E%E7%8E%B0%EF%BC%9A"><strong>● operator=实现：</strong></h4> 
<pre><code class="language-cpp">	//s2 = s1
	string&amp; operator=(const string&amp; s)
	{
		char* tmp = new char[s._capacity + 1];//多开辟的1个空间用来存储\0
		strcpy(tmp, s._str);
		delete[] _str;
		_str = tmp;
		_size = s._size;
		_capacity = s._capacity;

		return *this;//支持连续赋值
	}</code></pre> 
<h3 id="2.%E8%BF%AD%E4%BB%A3%E5%99%A8(iterators)"><strong>2.迭代器(iterators)</strong></h3> 
<p><strong>● begin实现：</strong></p> 
<p>在string类中迭代器中begin表示的就是字符串的首地址的指针，但并不是所有迭代器都是由指针来实现的。</p> 
<p>这里使用迭代器的对象有两种，一种是const修饰的，一种是const没有修饰的，所以begin实现应有const修饰，和const不修饰两种：</p> 
<pre><code class="language-cpp">typedef char* iterator;
typedef const char* const_iterator;

iterator begin()
{
	return _str;
}

const_iterator begin() const
{
	return _str;
}</code></pre> 
<p><strong>● end实现：</strong></p> 
<p><strong>同理，end实现也一样：</strong></p> 
<pre><code class="language-cpp">typedef char* iterator;
typedef const char* const_iterator;

iterator end()
{
	return _str + _size;
}

const_iterator end() const
{
	return _str + _size;
}</code></pre> 
<p>这里可以再说一下，范围for的实现也是基于迭代器begin和end所实现的，大家可以在汇编代码中就可以看到。</p> 
<p>而对于const修饰的对象和const没有修饰的对象分别对应使用的范围for其内部实现也是const修饰的begin，end和const没有修饰的begin，end两种范围for。</p> 
<h3 id="3.%E5%AE%B9%E9%87%8F(Capacity)"><strong>3.容量(Capacity)</strong></h3> 
<p><strong>● size实现：</strong></p> 
<pre><code class="language-cpp">size_t size() const
{
	return _size;
}</code></pre> 
<p><strong>● capacity实现：</strong></p> 
<pre><code class="language-cpp">size_t capacity() const
{
	return _capacity;
}</code></pre> 
<p><strong>● resize实现：<br> 由于resize函数的实现可能需要对数组进行扩容，所以我们先实现一下reserve函数：</strong></p> 
<pre><code class="language-cpp">void reserve(size_t n)
{
	if (n &gt; _capacity)
	{
		char* tmp = new char[n+1];//多开1个位置给\0
		strcpy(tmp, _str);
		delete[] _str;//!!!
		_str = tmp;

		_capacity = n;
	}
}</code></pre> 
<p>注意：reserve只有在n大于当前有效空间是才会进行开辟，当n小于当前有效空间不会进行任何操作。</p> 
<p><strong>resize实现：</strong></p> 
<pre><code class="language-cpp">void resize(size n,const char* c)
{
    if(n&gt;_size)
    {
        reserve(n);
        for(size i=size; i&lt;n;i++)
        {
            _str[i] = c;
        }
        _str[n] = '\0';
        _size = n;
    }
    else
    {
        _str[n] = '\0'; 
        _size = n;
    }
}</code></pre> 
<p><strong>● clear实现：</strong></p> 
<p>注意：clear只是清楚当前所存数据，而不是销毁空间</p> 
<pre><code class="language-cpp">void clear()
{
	_size = 0;
	_str[0] = '\0';
}</code></pre> 
<h3 id="4.%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE(Element%20access)"><strong>4.元素访问(Element access)</strong></h3> 
<h3 id="%E2%97%8F%20operator%5B%5D%E5%AE%9E%E7%8E%B0%EF%BC%9A"><strong>● operator[]实现：</strong></h3> 
<p><strong>operator[]的实现功能就是访问string类里面字符串的字符所以实现并不复杂：</strong><br>  </p> 
<pre><code class="language-cpp">char&amp; operator[](size_t pos)
{
	assert(pos &lt; _size);

	return _str[pos];
}

const char&amp; operator[](size_t pos) const
{
	assert(pos &lt; _size);

	return _str[pos];
}</code></pre> 
<h3 id="5.%E8%B0%83%E8%8A%82%E5%99%A8(Modifiers)">5.调节器(Modifiers)</h3> 
<p><strong>● insert实现：</strong></p> 
<p>插入字符或字符串那么肯定会涉及到空间不够是否需要扩容的问题，解决了之后剩下的就是将插入位置之后的字符串向后移动插入字符或字符串大小的位置，为要插入的字符或字符串流出插入空间，之后再将字符或字符串插入即可：</p> 
<pre><code class="language-cpp">void insert(size_t pos, char ch)
{
	assert(pos &lt;= _size);

	if (_size == _capacity)
	{
		//扩容。。。reserve
		reserve(_capacity == 0 ? 4 : _capacity * 2);
	}

	//后移字符串方案1
	//int end = _size;
	//while (end &gt;= (int)pos)//!!!一个运算符两边操作数类型不同的时候发生类型提升（范围小的像范围大的提升 这里有符号向无符号提升）
	//{
	//	_str[end + 1] = _str[end];
	//	--end;
	//}

	//后移字符串方案2
	size_t end = _size + 1;
	while (end &gt; pos)
	{
		_str[end] = _str[end - 1];
		--end;
	}
	_str[pos] = ch;
	_size++;
}

void insert(size_t pos, const char* str)
{
	assert(pos &lt;= _size);

	size_t len = strlen(str);
	if (_size + len &gt; _capacity)
	{
		reserve(_size + len);
	}

	size_t end = _size + len;
	while (pos &lt; end - len + 1)
	{
		_str[end] = _str[end - len];
		--end;
	}

	strncpy(_str + pos, str, len);
	_size += len;
}</code></pre> 
<p><strong>● append实现：</strong><br> 既然已经实现了insert，那么我们直接赋用insert实现append，push_back,operator+=即可：</p> 
<pre><code class="language-cpp">	void append(const char* str)
	{
		//size_t len = strlen(str);
		//if (len + _size &gt; _capacity)
		//{
		//	//扩容。。。
		//	reserve(_size + len);
		//}

		//strcpy(_str + _size, str);
		//_size += len;

		insert(_size, str);
	}</code></pre> 
<p><strong>● push_back实现：</strong></p> 
<pre><code class="language-cpp">void push_back(const char ch)
{
	//if (_size == _capacity)
	//{
	//	//扩容。。。reserve
	//	reserve(_capacity == 0 ? 4 : _capacity * 2);
	//}

	//_str[_size] = ch;
	//_str[_size + 1] = '\0';
	//++_size;

	insert(_size, ch);
}</code></pre> 
<p><strong>● operator+=实现：</strong><br>  </p> 
<pre><code class="language-cpp">string&amp; operator+=(const char ch)
{
	push_back(ch);
	return *this;
}

string&amp; operator+=(const char* str)
{
	append(str);
	return *this;
}</code></pre> 
<p><strong>● erase实现：</strong></p> 
<p><strong>当len要清除的字符长度大于等于总字符长度减去pos起始位置时就要将pos起始位置后面的字符全都清除，即_str[pos] = '\0'即可。</strong></p> 
<pre><code class="language-cpp">	void erase(size_t pos = 0, size_t len = npos)
	{
		assert(pos &lt; _size);
		
			if (pos == npos || pos &gt;= _size - len)
			{
				_str[pos] = '\0';
				_size = pos;
			}
			else
			{
				strcpy(_str + pos, _str + pos + len);
				_size -= len;
			}
	}</code></pre> 
<h3 id="6.%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C(String%20operation)"><strong>6.字符操作(String operation)</strong></h3> 
<p><strong>● c_str实现：</strong></p> 
<pre><code class="language-cpp">const char* c_str() const
{
	return _str;
}</code></pre> 
<p><strong>● find实现：</strong></p> 
<pre><code class="language-cpp">size_t find(const char c, size_t pos = 0) const
{
	assert(pos &lt; _size);

	//从pos位置开始遍历字符串
	for (size_t i = pos; i &lt; _size; i++)
	{
		if (_str[i] == c)
		{
			return i;
		}
	}
	return npos;
}

size_t find(const char* sub, size_t pos = 0) const
{
	assert(pos &lt; _size);

	const char* p = strstr(_str+pos, sub);
	if (p)
	{
		return p - _str;//指针-指针为两指针之间的距离
	}
	return npos;
}</code></pre> 
<p><strong>● substr实现：</strong></p> 
<p><br> 与erase分析相似，当要截取的len长度的字符大于等于总字符长度_size减起始位置pos时，就要将pos后面的字符全部截取进行返回：</p> 
<pre><code class="language-cpp">	string substr(size_t pos = 0, size_t len = npos) const
	{
		string sub;
		if (len &gt;= _size - pos)
		{
			for (size_t i = pos; i &lt; _size; i++)
			{
				sub += _str[i];
			}
		}
		else
		{
			for (size_t i = pos; i &lt; pos + len; i++)
			{
				sub += _str[i];
			}
		}
		return sub;
	}</code></pre> 
<h3 id="7.%E6%88%90%E5%91%98%E5%B8%B8%E9%87%8F(Member%20constant)npos%E5%AE%9E%E7%8E%B0%EF%BC%9A">7.成员常量(Member constant)npos实现：</h3> 
<p>在标准库中，npos为静态全局变量，在npos文档中就有说明，其值应为size_t类型的-1。</p> 
<pre><code class="language-cpp">private:
	char* _str = nullptr;
	size_t _size = 0;
	size_t _capacity = 0;

	public:
		static size_t npos;//类内声明
};

size_t string::npos = -1;//类外定义</code></pre> 
<h3 id="8.%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD(Non-member%20function%20overload)">8.非成员函数重载(Non-member function overload)</h3> 
<p><strong>● swap实现：</strong></p> 
<p><br><strong>在C++库中是有swap函数的，我们可以直接调用使用，但是对于自定义类型来说就比如string类，其直接调用库中的swap函数进行交换的话会调用3次拷贝构造+1次析构(库中的swap实现方式是创建一个新的临时变量tmp进行两个值的交换)，这样消耗会很大，所以对于自定义类型我们不推荐直接调用库里面的swap函数。</strong></p> 
<p><strong>那么我们该如何实现swap函数呢？我们可以直接对自定义类型里面的内置成员变量进行交换即可满足两者自定义类型的交换，将swap函数定义为非成员函数是因为要满足swap(s1,s2);交换的格式。</strong></p> 
<p>内部成员函数：</p> 
<pre><code class="language-cpp">	void swap(string&amp; s)
	{
		std::swap(_str, s._str);
		std::swap(_size, s._size);
		std::swap(_capacity, s._capacity);
	}</code></pre> 
<p>非成员函数(全局函数)：</p> 
<pre><code class="language-cpp">void swap(string&amp; s1, string&amp; s2)
{
	s1.swap(s2);//直接调用成员函数即可
}</code></pre> 
<p><strong>● operator&lt;&lt;实现：</strong></p> 
<pre><code class="language-cpp">ostream&amp; operator&lt;&lt;(ostream&amp; out, const string&amp; s)
{
	for (auto ch : s)
	{
		out &lt;&lt; ch;
	}
	return out;//实现连续打印
}</code></pre> 
<p><strong>● operator&gt;&gt;实现：</strong></p> 
<pre><code class="language-cpp">istream&amp; operator&gt;&gt;(istream&amp; in, string&amp; s)
{
	s.clear();//输入变量值之前需要将变量原先所存的值给清除
	char ch;
	ch = in.get();//可以获取空格' ',cin不支持获取空格

	while (ch != ' ' &amp;&amp; ch != '\n')
	{
		s += ch;
		ch = in.get();
	}

	return in;//实现连续赋值
}</code></pre> 
<p><strong>● getline实现：</strong></p> 
<pre><code class="language-cpp">istream&amp; getline(istream&amp; in, string&amp; s)
{
	s.clear();

	char c;
	c = in.get();
	//栈区开辟空间，栈区开辟空间比堆区开辟空间高
	char ch[128];//提高效率
	size_t i = 0;

	while (c != '\n')
	{
		ch[i++] = c;

		if (i == 127)
		{
			ch[127] = '\0';
			s += ch;
			i = 0;
		}
        c = in.get();
	}

	if (i &gt; 0)
	{
		ch[i] = '\0';
		s += ch;
	}
	return in;
}</code></pre> 
<p>上面所实现的都是string类的常用的一些接口，其他一些没有实现的大家感兴趣的话可以查阅其他资料自行模拟实现一下</p> 
<h2 id="%E4%BA%8C%E3%80%81%E5%AE%8C%E7%BB%93%E6%92%92%E2%9D%80">二、完结撒❀</h2> 
<p>如果以上内容对你有帮助不妨点赞支持一下，以后还会分享更多编程知识，我们一起进步。<br> 最后我想讲的是，据说点赞的都能找到漂亮女朋友❤</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/46/93/dfh3x0em_o.gif"></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f1429978048d317f6b96cb45485dfa70/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">达梦(DM) SQL日期操作及分析函数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/25add73d9514cf5e666e53718a7d5cca/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">人工智能训练师报条件、含金量、适配岗位全方位解读</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>