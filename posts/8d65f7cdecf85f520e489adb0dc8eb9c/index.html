<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>iOS 经典全部面试题（上），2024前端高级面试题总结 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/8d65f7cdecf85f520e489adb0dc8eb9c/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="iOS 经典全部面试题（上），2024前端高级面试题总结">
  <meta property="og:description" content="先自我介绍一下，小编浙江大学毕业，去过华为、字节跳动等大厂，目前阿里P7
深知大多数程序员，想要提升技能，往往是自己摸索成长，但自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《2024年最新Web前端全套学习资料》，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友。
既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，涵盖了95%以上前端开发知识点，真正体系化！
由于文件比较多，这里只是将部分目录截图出来，全套包含大厂面经、学习笔记、源码讲义、实战项目、大纲路线、讲解视频，并且后续会持续更新
如果你需要这些资料，可以添加V获取：vip1024c （备注前端）
正文 weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。 而 assign 的“设置方法”只会执行针对“纯量类型” (scalar type，例如 CGFloat 或 NSlnteger 等)的简单赋值操作。
assign 可以用非 OC 对象,而 weak 必须用于 OC 对象
3. 怎么用 copy 关键字？ 用途：
NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；
block 也经常使用 copy 关键字，具体原因见官方文档：Objects Use Properties to Keep Track of Blocks：
block 使用 copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.在 ARC 中写不写都行：对于 block 使用 copy 还是 strong 效果是一样的，但写上 copy 也无伤大雅，还能时刻提醒我们：编译器自动对 block 进行了 copy 操作。如果不写 copy ，该类的调用者有可能会忘记或者根本不知道“编译器会自动对 block 进行了 copy 操作”，他们有可能会在调用之前自行拷贝属性值。这种操作多余而低效。你也许会感觉我这种做法有些怪异，不需要写依然写。如果你这样想，其实是你“日用而不知”，你平时开发中是经常在用我说的这种做法的，比如下面的属性不写copy也行，但是你会选择写还是不写呢？">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-14T01:54:37+08:00">
    <meta property="article:modified_time" content="2024-04-14T01:54:37+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">iOS 经典全部面试题（上），2024前端高级面试题总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>先自我介绍一下，小编浙江大学毕业，去过华为、字节跳动等大厂，目前阿里P7</strong></p> 
<p><strong>深知大多数程序员，想要提升技能，往往是自己摸索成长，但自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！</strong></p> 
<p><strong>因此收集整理了一份《2024年最新Web前端全套学习资料》，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友。</strong><br> <img src="https://images2.imgbox.com/60/e7/at926rAg_o.jpg" alt="img"><br> <img src="https://images2.imgbox.com/92/03/jUot7oAo_o.png" alt="img"><br> <img src="https://images2.imgbox.com/ee/9a/umAZsq5t_o.png" alt="img"><br> <img src="https://images2.imgbox.com/0b/48/NGsRI1Kx_o.png" alt="img"><br> <img src="https://images2.imgbox.com/a2/40/s4zwbdQf_o.png" alt="img"><br> <img src="https://images2.imgbox.com/32/a3/oOQk8Vqn_o.png" alt="img"></p> 
<p><strong>既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，涵盖了95%以上前端开发知识点，真正体系化！</strong></p> 
<p><strong>由于文件比较多，这里只是将部分目录截图出来，全套包含大厂面经、学习笔记、源码讲义、实战项目、大纲路线、讲解视频，并且后续会持续更新</strong></p> 
<p><strong>如果你需要这些资料，可以添加V获取：vip1024c （备注前端）</strong><br> <img src="https://images2.imgbox.com/85/bd/IQgjhix8_o.png" alt="img"></p> 
<h4><a id="_19"></a>正文</h4> 
<ol><li> <p><code>weak</code> 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。 而 <code>assign</code> 的“设置方法”只会执行针对“纯量类型” (scalar type，例如 CGFloat 或 NSlnteger 等)的简单赋值操作。</p> </li><li> <p>assign 可以用非 OC 对象,而 weak 必须用于 OC 对象</p> </li></ol> 
<h4><a id="_3__copy__34"></a><a href="" rel="nofollow"></a>3. 怎么用 copy 关键字？</h4> 
<p>用途：</p> 
<ol><li> <p>NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；</p> </li><li> <p>block 也经常使用 copy 关键字，具体原因见<a href="" rel="nofollow">官方文档：Objects Use Properties to Keep Track of Blocks</a>：</p> </li></ol> 
<p>block 使用 copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.在 ARC 中写不写都行：对于 block 使用 copy 还是 strong 效果是一样的，但写上 copy 也无伤大雅，还能时刻提醒我们：编译器自动对 block 进行了 copy 操作。如果不写 copy ，该类的调用者有可能会忘记或者根本不知道“编译器会自动对 block 进行了 copy 操作”，他们有可能会在调用之前自行拷贝属性值。这种操作多余而低效。你也许会感觉我这种做法有些怪异，不需要写依然写。如果你这样想，其实是你“日用而不知”，你平时开发中是经常在用我说的这种做法的，比如下面的属性不写copy也行，但是你会选择写还是不写呢？</p> 
<p>@property (nonatomic, copy) NSString *userId;</p> 
<ul><li>(instancetype)initWithUserId:(NSString *)userId {<!-- --></li></ul> 
<p>self = [super init];</p> 
<p>if (!self) {<!-- --></p> 
<p>return nil;</p> 
<p>}</p> 
<p>_userId = [userId copy];</p> 
<p>return self;</p> 
<p>}</p> 
<p><a href="https://camo.githubusercontent.com/8a5fa34435801cc4c2715d8880f3abd45be6a6c5/687474703a2f2f692e696d6775722e636f6d2f566c564b6c384c2e706e67" rel="nofollow"><img src="https://images2.imgbox.com/17/c1/mLB5nVj8_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></a></p> 
<p>下面做下解释： copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。 当属性类型为 NSString 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。</p> 
<blockquote> 
 <p>用 <code>@property</code> 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</p> 
</blockquote> 
<p>该问题在下文中也有论述：用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</p> 
<h4><a id="_4_%C2%A0property_copy_NSMutableArray_array_96"></a><a href="" rel="nofollow"></a>4. 这个写法会出什么问题： <code>@property (copy) NSMutableArray *array;</code></h4> 
<p>两个问题：1、添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃.因为 copy 就是复制一个不可变 NSArray 的对象；2、使用了 atomic 属性会严重影响性能 ；</p> 
<p>第1条的相关原因在下文中有论述***《用@property声明的NSString（或NSArray，NSDictionary）经常使用 copy 关键字，为什么？如果改用strong关键字，可能造成什么问题？》*** 以及上文***《怎么用 copy 关键字？》***也有论述。</p> 
<p>比如下面的代码就会发生崩溃</p> 
<p>// .h文件</p> 
<p>// http://weibo.com/luohanchenyilong/</p> 
<p>// https://github.com/ChenYilong</p> 
<p>// 下面的代码就会发生崩溃</p> 
<p>@property (nonatomic, copy) NSMutableArray *mutableArray;</p> 
<p>// .m文件</p> 
<p>// http://weibo.com/luohanchenyilong/</p> 
<p>// https://github.com/ChenYilong</p> 
<p>// 下面的代码就会发生崩溃</p> 
<p>NSMutableArray *array = [NSMutableArray arrayWithObjects:@1,@2,nil];</p> 
<p>self.mutableArray = array;</p> 
<p>[self.mutableArray removeObjectAtIndex:0];</p> 
<p>接下来就会奔溃：</p> 
<p>-[__NSArrayI removeObjectAtIndex:]: unrecognized selector sent to instance 0x7fcd1bc30460</p> 
<p>第2条原因，如下：</p> 
<blockquote> 
 <p>该属性使用了同步锁，会在创建时生成一些额外的代码用于帮助编写多线程程序，这会带来性能问题，通过声明 nonatomic 可以节省这些虽然很小但是不必要额外开销。</p> 
</blockquote> 
<p>在默认情况下，由编译器所合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不使用同步锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备 nonatomic 特质，那它就是“原子的”(atomic))。</p> 
<p>在iOS开发中，你会发现，几乎所有属性都声明为 nonatomic。</p> 
<p>一般情况下并不要求属性必须是“原子的”，因为这并不能保证“线程安全” ( thread safety)，若要实现“线程安全”的操作，还需采用更为深层的锁定机制才行。例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为 atomic，也还是会读到不同的属性值。</p> 
<p>因此，开发iOS程序时一般都会使用 nonatomic 属性。但是在开发 Mac OS X 程序时，使用 atomic 属性通常都不会有性能瓶颈。</p> 
<h4><a id="_5__copy__copy__setter_188"></a><a href="" rel="nofollow"></a>5. 如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</h4> 
<blockquote> 
 <p>若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 <code>NSCopying</code> 与 <code>NSMutableCopying</code> 协议。</p> 
</blockquote> 
<p>具体步骤：</p> 
<ol><li> <p>需声明该类遵从 NSCopying 协议</p> </li><li> <p>实现 NSCopying 协议。该协议只有一个方法:</p> </li></ol> 
<ul><li>(id)copyWithZone:(NSZone *)zone;</li></ul> 
<p>注意：一提到让自己的类用 copy 修饰符，我们总是想覆写copy方法，其实真正需要实现的却是 “copyWithZone” 方法。</p> 
<p>以第一题的代码为例：</p> 
<p>// .h文件</p> 
<p>// http://weibo.com/luohanchenyilong/</p> 
<p>// https://github.com/ChenYilong</p> 
<p>// 修改完的代码</p> 
<p>typedef NS_ENUM(NSInteger, CYLSex) {<!-- --></p> 
<p>CYLSexMan,</p> 
<p>CYLSexWoman</p> 
<p>};</p> 
<p>@interface CYLUser : NSObject</p> 
<p>@property (nonatomic, readonly, copy) NSString *name;</p> 
<p>@property (nonatomic, readonly, assign) NSUInteger age;</p> 
<p>@property (nonatomic, readonly, assign) CYLSex sex;</p> 
<ul><li>(instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;</li></ul> 
<ul><li>(instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;</li></ul> 
<p>@end</p> 
<p>然后实现协议中规定的方法：</p> 
<ul><li>(id)copyWithZone:(NSZone *)zone {<!-- --></li></ul> 
<p>CYLUser *copy = [[[self class] allocWithZone:zone]</p> 
<p>initWithName:_name</p> 
<p>age:_age</p> 
<p>sex:_sex];</p> 
<p>return copy;</p> 
<p>}</p> 
<p>但在实际的项目中，不可能这么简单，遇到更复杂一点，比如类对象中的数据结构可能并未在初始化方法中设置好，需要另行设置。举个例子，假如 CYLUser 中含有一个数组，与其他 CYLUser 对象建立或解除朋友关系的那些方法都需要操作这个数组。那么在这种情况下，你得把这个包含朋友对象的数组也一并拷贝过来。下面列出了实现此功能所需的全部代码:</p> 
<p>// .h文件</p> 
<p>// http://weibo.com/luohanchenyilong/</p> 
<p>// https://github.com/ChenYilong</p> 
<p>// 以第一题《风格纠错题》里的代码为例</p> 
<p>typedef NS_ENUM(NSInteger, CYLSex) {<!-- --></p> 
<p>CYLSexMan,</p> 
<p>CYLSexWoman</p> 
<p>};</p> 
<p>@interface CYLUser : NSObject</p> 
<p>@property (nonatomic, readonly, copy) NSString *name;</p> 
<p>@property (nonatomic, readonly, assign) NSUInteger age;</p> 
<p>@property (nonatomic, readonly, assign) CYLSex sex;</p> 
<ul><li>(instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;</li></ul> 
<ul><li>(instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;</li></ul> 
<ul><li> <p>(void)addFriend:(CYLUser *)user;</p> </li><li> <p>(void)removeFriend:(CYLUser *)user;</p> </li></ul> 
<p>@end</p> 
<p>// .m文件</p> 
<p>// .m文件</p> 
<p>// http://weibo.com/luohanchenyilong/</p> 
<p>// https://github.com/ChenYilong</p> 
<p>//</p> 
<p>@implementation CYLUser {<!-- --></p> 
<p>NSMutableSet *_friends;</p> 
<p>}</p> 
<ul><li>(void)setName:(NSString *)name {<!-- --></li></ul> 
<p>_name = [name copy];</p> 
<p>}</p> 
<ul><li>(instancetype)initWithName:(NSString *)name</li></ul> 
<p>age:(NSUInteger)age</p> 
<p>sex:(CYLSex)sex {<!-- --></p> 
<p>if(self = [super init]) {<!-- --></p> 
<p>_name = [name copy];</p> 
<p>_age = age;</p> 
<p>_sex = sex;</p> 
<p>_friends = [[NSMutableSet alloc] init];</p> 
<p>}</p> 
<p>return self;</p> 
<p>}</p> 
<ul><li>(void)addFriend:(CYLUser *)user {<!-- --></li></ul> 
<p>[_friends addObject:user];</p> 
<p>}</p> 
<ul><li>(void)removeFriend:(CYLUser *)user {<!-- --></li></ul> 
<p>[_friends removeObject:user];</p> 
<p>}</p> 
<ul><li>(id)copyWithZone:(NSZone *)zone {<!-- --></li></ul> 
<p>CYLUser *copy = [[[self class] allocWithZone:zone]</p> 
<p>initWithName:_name</p> 
<p>age:_age</p> 
<p>sex:_sex];</p> 
<p>copy-&gt;_friends = [_friends mutableCopy];</p> 
<p>return copy;</p> 
<p>}</p> 
<ul><li>(id)deepCopy {<!-- --></li></ul> 
<p>CYLUser *copy = [[[self class] alloc]</p> 
<p>initWithName:_name</p> 
<p>age:_age</p> 
<p>sex:_sex];</p> 
<p>copy-&gt;_friends = [[NSMutableSet alloc] initWithSet:_friends</p> 
<p>copyItems:YES];</p> 
<p>return copy;</p> 
<p>}</p> 
<p>@end</p> 
<p>以上做法能满足基本的需求，但是也有缺陷：</p> 
<blockquote> 
 <p>如果你所写的对象需要深拷贝，那么可考虑新增一个专门执行深拷贝的方法。</p> 
</blockquote> 
<p>【注：深浅拷贝的概念，在下文中有介绍，详见下文的：***用@property声明的 NSString（或NSArray，NSDictionary）经常使用 copy 关键字，为什么？如果改用 strong 关键字，可能造成什么问题？***】</p> 
<p>在例子中，存放朋友对象的 set 是用 “copyWithZone:” 方法来拷贝的，这种浅拷贝方式不会逐个复制 set 中的元素。若需要深拷贝的话，则可像下面这样，编写一个专供深拷贝所用的方法:</p> 
<ul><li>(id)deepCopy {<!-- --></li></ul> 
<p>CYLUser *copy = [[[self class] alloc]</p> 
<p>initWithName:_name</p> 
<p>age:_age</p> 
<p>sex:_sex];</p> 
<p>copy-&gt;_friends = [[NSMutableSet alloc] initWithSet:_friends</p> 
<p>copyItems:YES];</p> 
<p>return copy;</p> 
<p>}</p> 
<p>至于***如何重写带 copy 关键字的 setter***这个问题，</p> 
<p>如果抛开本例来回答的话，如下：</p> 
<ul><li>(void)setName:(NSString *)name {<!-- --></li></ul> 
<p>//[_name release];</p> 
<p>_name = [name copy];</p> 
<p>}</p> 
<p>不过也有争议，有人说“苹果如果像下面这样干，是不是效率会高一些？”</p> 
<ul><li>(void)setName:(NSString *)name {<!-- --></li></ul> 
<p>if (_name != name) {<!-- --></p> 
<p>//[_name release];//MRC</p> 
<p>_name = [name copy];</p> 
<p>}</p> 
<p>}</p> 
<p>这样真得高效吗？不见得！这种写法“看上去很美、很合理”，但在实际开发中，它更像下图里的做法：</p> 
<p><a href="https://camo.githubusercontent.com/c1f8d683aac8a7e2c853aee261b7879d9de317eb/687474703a2f2f692e696d6775722e636f6d2f557756396f536e2e6a706567" rel="nofollow"><img src="https://images2.imgbox.com/37/8c/uO6hJcQy_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></a></p> 
<p>克强总理这样评价你的代码风格：</p> 
<p><a href="https://camo.githubusercontent.com/0340c76bb7a97a27838f105905638a5ae4222e14/687474703a2f2f692e696d6775722e636f6d2f4e37374c6b69632e706e67" rel="nofollow"><img src="https://images2.imgbox.com/c3/24/bStINMYM_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></a></p> 
<p>我和总理的意见基本一致：</p> 
<blockquote> 
 <p>老百姓 copy 一下，咋就这么难？</p> 
</blockquote> 
<p>你可能会说：</p> 
<p>之所以在这里做<code>if判断</code> 这个操作：是因为一个 if 可能避免一个耗时的copy，还是很划算的。 (在刚刚讲的：《如何让自己的类用 copy 修饰符？》里的那种复杂的copy，我们可以称之为 “耗时的copy”，但是对 NSString 的 copy 还称不上。)</p> 
<p>但是你有没有考虑过代价：</p> 
<blockquote> 
 <p>你每次调用 <code>setX:</code> 都会做 if 判断，这会让 <code>setX:</code> 变慢，如果你在 <code>setX:</code>写了一串复杂的 <code>if+elseif+elseif+...</code> 判断，将会更慢。</p> 
</blockquote> 
<p>要回答“哪个效率会高一些？”这个问题，不能脱离实际开发，就算 copy 操作十分耗时，if 判断也不见得一定会更快，除非你把一个“ @property他当前的值 ”赋给了他自己，代码看起来就像：</p> 
<p>[a setX:x1];</p> 
<p>[a setX:x1]; //你确定你要这么干？与其在setter中判断，为什么不把代码写好？</p> 
<p>或者</p> 
<p>[a setX:[a x]]; //队友咆哮道：你在干嘛？！！</p> 
<blockquote> 
 <p>不要在 setter 里进行像 <code>if(_obj != newObj)</code> 这样的判断。（该观点参考链接： <a href="" rel="nofollow">How To Write Cocoa Object Setters： Principle 3: Only Optimize After You Measure</a> ）</p> 
</blockquote> 
<p>什么情况会在 copy setter 里做 if 判断？ 例如，车速可能就有最高速的限制，车速也不可能出现负值，如果车子的最高速为300，则 setter 的方法就要改写成这样：</p> 
<p>-(void)setSpeed:(int)_speed{<!-- --></p> 
<p>if(_speed &lt; 0) speed = 0;</p> 
<p>if(_speed &gt; 300) speed = 300;</p> 
<p>_speed = speed;</p> 
<p>}</p> 
<p>回到这个题目，如果单单就上文的代码而言，我们不需要也不能重写 name 的 setter ：由于是 name 是只读属性，所以编译器不会为其创建对应的“设置方法”，用初始化方法设置好属性值之后，就不能再改变了。（ 在本例中，之所以还要声明属性的“内存管理语义”–copy，是因为：如果不写 copy，该类的调用者就不知道初始化方法里会拷贝这些属性，他们有可能会在调用初始化方法之前自行拷贝属性值。这种操作多余而低效）。</p> 
<p>那如何确保 name 被 copy？在初始化方法(initializer)中做：</p> 
<ul><li>(instancetype)initWithName:(NSString *)name</li></ul> 
<p>age:(NSUInteger)age</p> 
<p>sex:(CYLSex)sex {<!-- --></p> 
<p>if(self = [super init]) {<!-- --></p> 
<p>_name = [name copy];</p> 
<p>_age = age;</p> 
<p>_sex = sex;</p> 
<p>_friends = [[NSMutableSet alloc] init];</p> 
<p>}</p> 
<p>return self;</p> 
<p>}</p> 
<h4><a id="_6_property_ivargettersetter__678"></a><a href="" rel="nofollow"></a>6. @property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</h4> 
<p>@property 的本质是什么？</p> 
<blockquote> 
 <p>@property = ivar + getter + setter;</p> 
</blockquote> 
<p>下面解释下：</p> 
<blockquote> 
 <p>“属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。</p> 
</blockquote> 
<p>“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。这个概念已经定型，并且经由“属性”这一特性而成为 <code>Objective-C 2.0</code> 的一部分。 而在正规的 Objective-C 编码风格中，存取方法有着严格的命名规范。 正因为有了这种严格的命名规范，所以 Objective-C 这门语言才能根据名称自动创建出存取方法。其实也可以把属性当做一种关键字，其表示:</p> 
<blockquote> 
 <p>编译器会自动写出一套存取方法，用以访问给定类型中具有给定名称的变量。 所以你也可以这么说：</p> 
</blockquote> 
<blockquote> 
 <p>@property = getter + setter;</p> 
</blockquote> 
<p>例如下面这个类：</p> 
<p>@interface Person : NSObject</p> 
<p>@property NSString *firstName;</p> 
<p>@property NSString *lastName;</p> 
<p>@end</p> 
<p>上述代码写出来的类与下面这种写法等效：</p> 
<p>@interface Person : NSObject</p> 
<ul><li> <p>(NSString *)firstName;</p> </li><li> <p>(void)setFirstName:(NSString *)firstName;</p> </li><li> <p>(NSString *)lastName;</p> </li><li> <p>(void)setLastName:(NSString *)lastName;</p> </li></ul> 
<p>@end</p> 
<p>更新：</p> 
<p>property在runtime中是<code>objc_property_t</code>定义如下:</p> 
<p>typedef struct objc_property *objc_property_t;</p> 
<p>而<code>objc_property</code>是一个结构体，包括name和attributes，定义如下：</p> 
<p>struct property_t {<!-- --></p> 
<p>const char *name;</p> 
<p>const char *attributes;</p> 
<p>};</p> 
<p>而attributes本质是<code>objc_property_attribute_t</code>，定义了property的一些属性，定义如下：</p> 
<p>/// Defines a property attribute</p> 
<p>typedef struct {<!-- --></p> 
<p>const char *name; /**&lt; The name of the attribute */</p> 
<p>const char *value; /**&lt; The value of the attribute (usually empty) */</p> 
<p>} objc_property_attribute_t;</p> 
<p>而attributes的具体内容是什么呢？其实，包括：类型，原子性，内存语义和对应的实例变量。</p> 
<p>例如：我们定义一个string的property<code>@property (nonatomic, copy) NSString *string;</code>，通过 <code>property_getAttributes(property)</code>获取到attributes并打印出来之后的结果为<code>T@"NSString",C,N,V_string</code></p> 
<p>其中T就代表类型，可参阅<a href="" rel="nofollow">Type Encodings</a>，C就代表Copy，N代表nonatomic，V就代表对于的实例变量。</p> 
<p>ivar、getter、setter 是如何生成并添加到这个类中的?</p> 
<blockquote> 
 <p>“自动合成”( autosynthesis)</p> 
</blockquote> 
<p>完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。需要强调的是，这个过程由编译 器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。在前例中，会生成两个实例变量，其名称分别为 <code>_firstName</code> 与 <code>_lastName</code>。也可以在类的实现代码里通过<code>@synthesize</code> 语法来指定实例变量的名字.</p> 
<p>@implementation Person</p> 
<p>@synthesize firstName = _myFirstName;</p> 
<p>@synthesize lastName = _myLastName;</p> 
<p>@end</p> 
<p>我为了搞清属性是怎么实现的,曾经反编译过相关的代码,他大致生成了五个东西</p> 
<ol><li> <p><code>OBJC_IVAR_$类名$属性名称</code> ：该属性的“偏移量” (offset)，这个偏移量是“硬编码” (hardcode)，表示该变量距离存放对象的内存区域的起始地址有多远。</p> </li><li> <p>setter 与 getter 方法对应的实现函数</p> </li><li> <p><code>ivar_list</code> ：成员变量列表</p> </li><li> <p><code>method_list</code> ：方法列表</p> </li><li> <p><code>prop_list</code> ：属性列表</p> </li></ol> 
<p>也就是说我们每次在增加一个属性,系统都会在 <code>ivar_list</code> 中添加一个成员变量的描述,在 <code>method_list</code> 中增加 setter 与 getter 方法的描述,在属性列表中增加一个属性的描述,然后计算该属性在对象中的偏移量,然后给出 setter 与 getter 方法对应的实现,在 setter 方法中从偏移量的位置开始赋值,在 getter 方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转.</p> 
<h4><a id="_7_protocol__category__property_862"></a><a href="" rel="nofollow"></a>7. @protocol 和 category 中如何使用 @property</h4> 
<ol><li> <p>在 protocol 中使用 property 只会生成 setter 和 getter 方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性</p> </li><li> <p>category 使用 @property 也是只会生成 setter 和 getter 方法的声明,如果我们真的需要给 category 增加属性的实现,需要借助于运行时的两个函数：</p> </li><li> <p><code>objc_setAssociatedObject</code></p> </li><li> <p><code>objc_getAssociatedObject</code></p> </li></ol> 
<h4><a id="_8_runtime__weak__884"></a><a href="" rel="nofollow"></a>8. runtime 如何实现 weak 属性</h4> 
<p>要实现 weak 属性，首先要搞清楚 weak 属性的特点：</p> 
<blockquote> 
 <p>weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同 assign 类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。</p> 
</blockquote> 
<p>那么 runtime 如何实现 weak 变量的自动置nil？</p> 
<blockquote> 
 <p>runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。</p> 
</blockquote> 
<p>（注：在下文的《使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？》里给出的“对象的内存销毁时间表”也提到<code>__weak</code>引用的解除时间。）</p> 
<p>先看下 runtime 里源码的实现：</p> 
<p>/**</p> 
<ul><li> <p>The internal structure stored in the weak references table.</p> </li><li> <p>It maintains and stores</p> </li><li> <p>a hash set of weak references pointing to an object.</p> </li><li> <p>If out_of_line==0, the set is instead a small inline array.</p> </li></ul> 
<p>*/</p> 
<p>#define WEAK_INLINE_COUNT 4</p> 
<p>struct weak_entry_t {<!-- --></p> 
<p>DisguisedPtr&lt;objc_object&gt; referent;</p> 
<p>union {<!-- --></p> 
<p>struct {<!-- --></p> 
<p>weak_referrer_t *referrers;</p> 
<p>uintptr_t out_of_line : 1;</p> 
<p>uintptr_t num_refs : PTR_MINUS_1;</p> 
<p>uintptr_t mask;</p> 
<p>uintptr_t max_hash_displacement;</p> 
<p>};</p> 
<p>struct {<!-- --></p> 
<p>// out_of_line=0 is LSB of one of these (don’t care which)</p> 
<p>weak_referrer_t inline_referrers[WEAK_INLINE_COUNT];</p> 
<p>};</p> 
<p>};</p> 
<p>};</p> 
<p>/**</p> 
<ul><li> <p>The global weak references table. Stores object ids as keys,</p> </li><li> <p>and weak_entry_t structs as their values.</p> </li></ul> 
<p>*/</p> 
<p>struct weak_table_t {<!-- --></p> 
<p>weak_entry_t *weak_entries;</p> 
<p>size_t num_entries;</p> 
<p>uintptr_t mask;</p> 
<p>uintptr_t max_hash_displacement;</p> 
<p>};</p> 
<p>具体完整实现参照 <a href="" rel="nofollow">objc/objc-weak.h</a> 。</p> 
<p>我们可以设计一个函数（伪代码）来表示上述机制：</p> 
<p><code>objc_storeWeak(&amp;a, b)</code>函数：</p> 
<p><code>objc_storeWeak</code>函数把第二个参数–赋值对象（b）的内存地址作为键值key，将第一个参数–weak修饰的属性变量（a）的内存地址（&amp;a）作为value，注册到 weak 表中。如果第二个参数（b）为0（nil），那么把变量（a）的内存地址（&amp;a）从weak表中删除，</p> 
<p>你可以把<code>objc_storeWeak(&amp;a, b)</code>理解为：<code>objc_storeWeak(value, key)</code>，并且当key变nil，将value置nil。</p> 
<p>在b非nil时，a和b指向同一个内存地址，在b变nil时，a变nil。此时向a发送消息不会崩溃：在Objective-C中向nil发送消息是安全的。</p> 
<p>而如果a是由 assign 修饰的，则： 在 b 非 nil 时，a 和 b 指向同一个内存地址，在 b 变 nil 时，a 还是指向该内存地址，变野指针。此时向 a 发送消息极易崩溃。</p> 
<p>下面我们将基于<code>objc_storeWeak(&amp;a, b)</code>函数，使用伪代码模拟“runtime如何实现weak属性”：</p> 
<p>// 使用伪代码模拟：runtime如何实现weak属性</p> 
<p>// http://weibo.com/luohanchenyilong/</p> 
<p>// https://github.com/ChenYilong</p> 
<p>id obj1;</p> 
<p>objc_initWeak(&amp;obj1, obj);</p> 
<p>/<em>obj引用计数变为0，变量作用域结束</em>/</p> 
<p>objc_destroyWeak(&amp;obj1);</p> 
<p>下面对用到的两个方法<code>objc_initWeak</code>和<code>objc_destroyWeak</code>做下解释：</p> 
<p>总体说来，作用是： 通过<code>objc_initWeak</code>函数初始化“附有weak修饰符的变量（obj1）”，在变量作用域结束时通过<code>objc_destoryWeak</code>函数释放该变量（obj1）。</p> 
<p>下面分别介绍下方法的内部实现：</p> 
<p><code>objc_initWeak</code>函数的实现是这样的：在将“附有weak修饰符的变量（obj1）”初始化为0（nil）后，会将“赋值对象”（obj）作为参数，调用<code>objc_storeWeak</code>函数。</p> 
<p>obj1 = 0；</p> 
<p>obj_storeWeak(&amp;obj1, obj);</p> 
<p>也就是说：</p> 
<blockquote> 
 <p>weak 修饰的指针默认值是 nil （在Objective-C中向nil发送消息是安全的）</p> 
</blockquote> 
<p>然后<code>obj_destroyWeak</code>函数将0（nil）作为参数，调用<code>objc_storeWeak</code>函数。</p> 
<p><code>objc_storeWeak(&amp;obj1, 0);</code></p> 
<p>前面的源代码与下列源代码相同。</p> 
<p>// 使用伪代码模拟：runtime如何实现weak属性</p> 
<p>// http://weibo.com/luohanchenyilong/</p> 
<p>// https://github.com/ChenYilong</p> 
<p>id obj1;</p> 
<p>obj1 = 0;</p> 
<p>objc_storeWeak(&amp;obj1, obj);</p> 
<p>/* … obj的引用计数变为0，被置nil … */</p> 
<p>objc_storeWeak(&amp;obj1, 0);</p> 
<p><code>objc_storeWeak</code> 函数把第二个参数–赋值对象（obj）的内存地址作为键值，将第一个参数–weak修饰的属性变量（obj1）的内存地址注册到 weak 表中。如果第二个参数（obj）为0（nil），那么把变量（obj1）的地址从 weak 表中删除，在后面的相关一题会详解。</p> 
<p>使用伪代码是为了方便理解，下面我们“真枪实弹”地实现下：</p> 
<blockquote> 
 <p>如何让不使用weak修饰的@property，拥有weak的效果。</p> 
</blockquote> 
<p>我们从setter方法入手：</p> 
<p>（注意以下的 <code>cyl_runAtDealloc</code> 方法实现仅仅用于模拟原理，如果想用于项目中，还需要考虑更复杂的场景，想在实际项目使用的话，可以使用我写的一个小库，可以使用 CocoaPods 在项目中使用： <a href="" rel="nofollow">CYLDeallocBlockExecutor</a> ）</p> 
<ul><li>(void)setObject:(NSObject *)object</li></ul> 
<p>{<!-- --></p> 
<p>objc_setAssociatedObject(self, “object”, object, OBJC_ASSOCIATION_ASSIGN);</p> 
<p>[object cyl_runAtDealloc:^{<!-- --></p> 
<p>_object = nil;</p> 
<p>}];</p> 
<p>}</p> 
<p>也就是有两个步骤：</p> 
<ol><li>在setter方法中做如下设置：</li></ol> 
<p>objc_setAssociatedObject(self, “object”, object, OBJC_ASSOCIATION_ASSIGN);</p> 
<ol start="2"><li>在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。做到这点，同样要借助 runtime：</li></ol> 
<p>//要销毁的目标对象</p> 
<p>id objectToBeDeallocated;</p> 
<p>//可以理解为一个“事件”：当上面的目标对象销毁时，同时要发生的“事件”。</p> 
<p>id objectWeWantToBeReleasedWhenThatHappens;</p> 
<p>objc_setAssociatedObject(objectToBeDeallocted,</p> 
<p>someUniqueKey,</p> 
<p>objectWeWantToBeReleasedWhenThatHappens,</p> 
<p>OBJC_ASSOCIATION_RETAIN);</p> 
<p>知道了思路，我们就开始实现 <code>cyl_runAtDealloc</code> 方法，实现过程分两部分：</p> 
<p>第一部分：创建一个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助 block 执行“事件”。</p> 
<p>// .h文件</p> 
<p>// .h文件</p> 
<p>// http://weibo.com/luohanchenyilong/</p> 
<p>// https://github.com/ChenYilong</p> 
<p>// 这个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助block执行“事件”。</p> 
<p>typedef void (^voidBlock)(void);</p> 
<p>@interface CYLBlockExecutor : NSObject</p> 
<ul><li>(id)initWithBlock:(voidBlock)block;</li></ul> 
<p>@end</p> 
<p>// .m文件</p> 
<p>// .m文件</p> 
<p>// http://weibo.com/luohanchenyilong/</p> 
<p>// https://github.com/ChenYilong</p> 
<p>// 这个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助block执行“事件”。</p> 
<p>#import “CYLBlockExecutor.h”</p> 
<p>@interface CYLBlockExecutor() {<!-- --></p> 
<p>voidBlock _block;</p> 
<p>}</p> 
<p>@implementation CYLBlockExecutor</p> 
<ul><li>(id)initWithBlock:(voidBlock)aBlock</li></ul> 
<p>{<!-- --></p> 
<p>self = [super init];</p> 
<p>if (self) {<!-- --></p> 
<p>_block = [aBlock copy];</p> 
<p>}</p> 
<p>return self;</p> 
<p>}</p> 
<ul><li>(void)dealloc</li></ul> 
<p>{<!-- --></p> 
<p>_block ? _block() : nil;</p> 
<p>}</p> 
<p>@end</p> 
<p>第二部分：核心代码：利用runtime实现<code>cyl_runAtDealloc</code>方法</p> 
<p>// CYLNSObject+RunAtDealloc.h文件</p> 
<p>// http://weibo.com/luohanchenyilong/</p> 
<p>// https://github.com/ChenYilong</p> 
<p>// 利用runtime实现cyl_runAtDealloc方法</p> 
<p>#import “CYLBlockExecutor.h”</p> 
<p>const void *runAtDeallocBlockKey = &amp;runAtDeallocBlockKey;</p> 
<p>@interface NSObject (CYLRunAtDealloc)</p> 
<ul><li>(void)cyl_runAtDealloc:(voidBlock)block;</li></ul> 
<p>@end</p> 
<p>// CYLNSObject+RunAtDealloc.m文件</p> 
<p>// http://weibo.com/luohanchenyilong/</p> 
<p>// https://github.com/ChenYilong</p> 
<p>// 利用runtime实现cyl_runAtDealloc方法</p> 
<p>#import “CYLNSObject+RunAtDealloc.h”</p> 
<p>#import “CYLBlockExecutor.h”</p> 
<p>@implementation NSObject (CYLRunAtDealloc)</p> 
<ul><li>(void)cyl_runAtDealloc:(voidBlock)block</li></ul> 
<p>{<!-- --></p> 
<p>if (block) {<!-- --></p> 
<p>CYLBlockExecutor *executor = [[CYLBlockExecutor alloc] initWithBlock:block];</p> 
<p>objc_setAssociatedObject(self,</p> 
<p>runAtDeallocBlockKey,</p> 
<p>executor,</p> 
<p>OBJC_ASSOCIATION_RETAIN);</p> 
<p>}</p> 
<p>}</p> 
<p>@end</p> 
<p>使用方法： 导入</p> 
<p>#import “CYLNSObject+RunAtDealloc.h”</p> 
<p>然后就可以使用了：</p> 
<p>NSObject *foo = [[NSObject alloc] init];</p> 
<p>[foo cyl_runAtDealloc:^{<!-- --></p> 
<p>NSLog(@“正在释放foo!”);</p> 
<p>}];</p> 
<p>如果对 <code>cyl_runAtDealloc</code> 的实现原理有兴趣，可以看下我写的一个小库，可以使用 CocoaPods 在项目中使用： <a href="" rel="nofollow">CYLDeallocBlockExecutor</a></p> 
<p>参考博文： <a href="" rel="nofollow">Fun With the Objective-C Runtime: Run Code at Deallocation of Any Object</a></p> 
<h4><a id="_9_property_property__1430"></a><a href="" rel="nofollow"></a>9. @property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？</h4> 
<p>属性可以拥有的特质分为四类:</p> 
<ol><li>原子性— <code>nonatomic</code> 特质</li></ol> 
<p>在默认情况下，由编译器合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不使用自旋锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备 nonatomic 特质，那它就是“原子的” ( atomic) )，但是仍然可以在属性特质中写明这一点，编译器不会报错。若是自己定义存取方法，那么就应该遵从与属性特质相符的原子性。</p> 
<ol start="2"><li> <p>读/写权限—<code>readwrite(读写)</code>、<code>readonly (只读)</code></p> </li><li> <p>内存管理语义—<code>assign</code>、<code>strong</code>、 <code>weak</code>、<code>unsafe_unretained</code>、<code>copy</code></p> </li><li> <p>方法名—<code>getter=&lt;name&gt;</code> 、<code>setter=&lt;name&gt;</code></p> </li></ol> 
<p><code>getter=&lt;name&gt;</code>的样式：</p> 
<p>@property (nonatomic, getter=isOn) BOOL on;</p> 
<p>~（ `setter=`这种不常用，也不推荐使用。故不在这里给出写法。）~</p> 
<p><code>setter=&lt;name&gt;</code>一般用在特殊的情境下，比如：</p> 
<p>在数据反序列化、转模型的过程中，服务器返回的字段如果以 <code>init</code> 开头，所以你需要定义一个 <code>init</code> 开头的属性，但默认生成的 <code>setter</code> 与 <code>getter</code> 方法也会以 <code>init</code> 开头，而编译器会把所有以 <code>init</code> 开头的方法当成初始化方法，而初始化方法只能返回 self 类型，因此编译器会报错。</p> 
<p>这时你就可以使用下面的方式来避免编译器报错：</p> 
<p>@property(nonatomic, strong, getter=p_initBy, setter=setP_initBy:)NSString *initBy;</p> 
<p>另外也可以用关键字进行特殊说明，来避免编译器报错：</p> 
<p>@property(nonatomic, readwrite, copy, null_resettable) NSString *initBy;</p> 
<ul><li>(NSString *)initBy <strong>attribute</strong>((objc_method_family(none)));</li></ul> 
<ol start="3"><li>不常用的：<code>nonnull</code>,<code>null_resettable</code>,<code>nullable</code></li></ol> 
<p>注意：很多人会认为如果属性具备 nonatomic 特质，则不使用 “同步锁”。其实在属性设置方法中使用的是自旋锁，自旋锁相关代码如下：</p> 
<p>static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)</p> 
<p>{<!-- --></p> 
<p>if (offset == 0) {<!-- --></p> 
<p>object_setClass(self, newValue);</p> 
<p>return;</p> 
<p>}</p> 
<p>id oldValue;</p> 
<p>id <em>slot = (id</em>) ((char*)self + offset);</p> 
<p>if (copy) {<!-- --></p> 
<p>newValue = [newValue copyWithZone:nil];</p> 
<p>} else if (mutableCopy) {<!-- --></p> 
<p>newValue = [newValue mutableCopyWithZone:nil];</p> 
<p>} else {<!-- --></p> 
<p>if (*slot == newValue) return;</p> 
<p>newValue = objc_retain(newValue);</p> 
<p>}</p> 
<p>if (!atomic) {<!-- --></p> 
<p>oldValue = *slot;</p> 
<p>*slot = newValue;</p> 
<p>} else {<!-- --></p> 
<p>spinlock_t&amp; slotlock = PropertyLocks[slot];</p> 
<p>slotlock.lock();</p> 
<p>oldValue = *slot;</p> 
<p>*slot = newValue;</p> 
<p>slotlock.unlock();</p> 
<p>}</p> 
<p>objc_release(oldValue);</p> 
<p>}</p> 
<p>void objc_setProperty(id self, SEL _cmd, ptrdiff_t offset, id newValue, BOOL atomic, signed char shouldCopy)</p> 
<p>{<!-- --></p> 
<p>bool copy = (shouldCopy &amp;&amp; shouldCopy != MUTABLE_COPY);</p> 
<p>bool mutableCopy = (shouldCopy == MUTABLE_COPY);</p> 
<p>reallySetProperty(self, _cmd, newValue, offset, atomic, copy, mutableCopy);</p> 
<p>}</p> 
<h4><a id="_10_weakdeallocnil_1604"></a><a href="" rel="nofollow"></a>10. weak属性需要在dealloc中置nil么？</h4> 
<p>不需要。</p> 
<blockquote> 
 <p>在ARC环境无论是强指针还是弱指针都无需在 dealloc 设置为 nil ， ARC 会自动帮我们处理</p> 
</blockquote> 
<p>即便是编译器不帮我们做这些，weak也不需要在 dealloc 中置nil：</p> 
<p>正如上文的：runtime 如何实现 weak 属性 中提到的：</p> 
<p>我们模拟下 weak 的 setter 方法，应该如下：</p> 
<ul><li>(void)setObject:(NSObject *)object</li></ul> 
<p>{<!-- --></p> 
<p>objc_setAssociatedObject(self, “object”, object, OBJC_ASSOCIATION_ASSIGN);</p> 
<p>[object cyl_runAtDealloc:^{<!-- --></p> 
<p>_object = nil;</p> 
<p>}];</p> 
<p>}</p> 
<p>如果对 <code>cyl_runAtDealloc</code> 的实现原理有兴趣，可以看下我写的一个小库，可以使用 CocoaPods 在项目中使用： <a href="" rel="nofollow">CYLDeallocBlockExecutor</a></p> 
<p>也即:</p> 
<blockquote> 
 <p>在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。</p> 
</blockquote> 
<h4><a id="_11_synthesizedynamic_1660"></a><a href="" rel="nofollow"></a>11. @synthesize和@dynamic分别有什么作用？</h4> 
<ol><li> <p>@property有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 @synthesize和 @dynamic都没写，那么默认的就是<code>@syntheszie var = _var;</code></p> </li><li> <p>@synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法。</p> </li><li> <p>@dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。（当然对于 readonly 的属性只需提供 getter 即可）。假如一个属性被声明为 @dynamic var，然后你没有提供 @setter方法和 @getter 方法，编译的时候没问题，但是当程序运行到 <code>instance.var = someVar</code>，由于缺 setter 方法会导致程序崩溃；或者当运行到 <code>someVar = var</code> 时，由于缺 getter 方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。</p> </li></ol> 
<h4><a id="_12_ARC_1672"></a><a href="" rel="nofollow"></a>12. ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？</h4> 
<ol><li>对应基本数据类型默认关键字是</li></ol> 
<p>atomic,readwrite,assign 2. 对于普通的 Objective-C 对象</p> 
<p>atomic,readwrite,strong</p> 
<p>参考链接：</p> 
<ol><li> <p><a href="" rel="nofollow">Objective-C ARC: strong vs retain and weak vs assign</a></p> </li><li> <p><a href="" rel="nofollow">Variable property attributes or Modifiers in iOS</a></p> </li></ol> 
<h4><a id="_13_propertyNSStringNSArrayNSDictionarycopystrong_1702"></a><a href="" rel="nofollow"></a>13. 用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</h4> 
<ol><li> <p>因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本.</p> </li><li> <p>如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性.</p> </li></ol> 
<p>copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。 当属性类型为 NSString 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。</p> 
<p>举例说明：</p> 
<p>定义一个以 strong 修饰的 array：</p> 
<p>@property (nonatomic ,readwrite, strong) NSArray *array;</p> 
<p>然后进行下面的操作：</p> 
<p>NSArray *array = @[ @1, @2, @3, @4 ];</p> 
<p>NSMutableArray *mutableArray = [NSMutableArray arrayWithArray:array];</p> 
<p>self.array = mutableArray;</p> 
<p>[mutableArray removeAllObjects];;</p> 
<p>NSLog(@“%@”,self.array);</p> 
<p>[mutableArray addObjectsFromArray:array];</p> 
<p>self.array = [mutableArray copy];</p> 
<p>[mutableArray removeAllObjects];;</p> 
<p>NSLog(@“%@”,self.array);</p> 
<p>打印结果如下所示：</p> 
<p>2015-09-27 19:10:32.523 CYLArrayCopyDmo[10681:713670] (</p> 
<p>)</p> 
<p>2015-09-27 19:10:32.524 CYLArrayCopyDmo[10681:713670] (</p> 
<p>1,</p> 
<p>2,</p> 
<p>3,</p> 
<p>4</p> 
<p>)</p> 
<p>（详见仓库内附录的 Demo。）</p> 
<p>为了理解这种做法，首先要知道，两种情况：</p> 
<ol><li> <p>对非集合类对象的 copy 与 mutableCopy 操作；</p> </li><li> <p>对集合类对象的 copy 与 mutableCopy 操作。</p> </li></ol> 
<h5><a id="_1_copy_1804"></a><a href="" rel="nofollow"></a>1. 对非集合类对象的copy操作：</h5> 
<p>在非集合类对象中：对 immutable 对象进行 copy 操作，是指针复制，mutableCopy 操作时内容复制；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。用代码简单表示如下：</p> 
<ul><li> <p>[immutableObject copy] // 浅复制</p> </li><li> <p>[immutableObject mutableCopy] //深复制</p> </li><li> <p>[mutableObject copy] //深复制</p> </li><li> <p>[mutableObject mutableCopy] //深复制</p> </li></ul> 
<p>比如以下代码：</p> 
<p>NSMutableString *string = [NSMutableString stringWithString:@“origin”];//copy</p> 
<p>NSString *stringCopy = [string copy];</p> 
<p>查看内存，会发现 string、stringCopy 内存地址都不一样，说明此时都是做内容拷贝、深拷贝。即使你进行如下操作：</p> 
<p>[string appendString:@“origion!”]</p> 
<p>stringCopy 的值也不会因此改变，但是如果不使用 copy，stringCopy 的值就会被改变。 集合类对象以此类推。 所以，</p> 
<blockquote> 
 <p>用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</p> 
</blockquote> 
<h5><a id="_2copymutableCopy_1856"></a><a href="" rel="nofollow"></a>2、集合类对象的copy与mutableCopy</h5> 
<p>集合类对象是指 NSArray、NSDictionary、NSSet … 之类的对象。下面先看集合类immutable对象使用 copy 和 mutableCopy 的一个例子：</p> 
<p>NSArray *array = @[@[@“a”, @“b”], @[@“c”, @“d”]];</p> 
<p>NSArray *copyArray = [array copy];</p> 
<p>NSMutableArray *mCopyArray = [array mutableCopy];</p> 
<p>查看内容，可以看到 copyArray 和 array 的地址是一样的，而 mCopyArray 和 array 的地址是不同的。说明 copy 操作进行了指针拷贝，mutableCopy 进行了内容拷贝。但需要强调的是：此处的内容拷贝，仅仅是拷贝 array 这个对象，array 集合内部的元素仍然是指针拷贝。这和上面的非集合 immutable 对象的拷贝还是挺相似的，那么mutable对象的拷贝会不会类似呢？我们继续往下，看 mutable 对象拷贝的例子：</p> 
<p>NSMutableArray *array = [NSMutableArray arrayWithObjects:[NSMutableString stringWithString:@“a”],@“b”,@“c”,nil];</p> 
<p>NSArray *copyArray = [array copy];</p> 
<p>NSMutableArray *mCopyArray = [array mutableCopy];</p> 
<h4><a id="_1890"></a>最后</h4> 
<p>你要问前端开发难不难，我就得说计算机领域里常说的一句话，这句话就是『<strong>难的不会，会的不难</strong>』，对于不熟悉某领域技术的人来说，因为不了解所以产生神秘感，神秘感就会让人感觉很难，也就是『难的不会』；当学会这项技术之后，知道什么什么技术能做到什么做不到，只是做起来花多少时间的问题而已，没啥难的，所以就是『会的不难』。</p> 
<p><strong>我特地针对初学者整理一套前端学习资料</strong></p> 
<p><img src="https://images2.imgbox.com/6c/06/lavkyHMo_o.png" alt="前端路线图"></p> 
<p><img src="https://images2.imgbox.com/92/81/C3xnHwT6_o.png" alt="vue.js的36个技巧"></p> 
<p><strong>网上学习资料一大堆，但如果学到的知识不成体系，遇到问题时只是浅尝辄止，不再深入研究，那么很难做到真正的技术提升。</strong></p> 
<p><strong>需要这份系统化的资料的朋友，可以添加V获取：vip1024c （备注前端）</strong><br> <img src="https://images2.imgbox.com/e2/b8/4f6LjnRL_o.png" alt="img"></p> 
<p><strong>一个人可以走的很快，但一群人才能走的更远！不论你是正从事IT行业的老鸟或是对IT行业感兴趣的新人，都欢迎加入我们的的圈子（技术交流、学习资源、职场吐槽、大厂内推、面试辅导），让我们一起学习成长！</strong></p> 
<ul><li> <p>[mutableObject copy] //深复制</p> </li><li> <p>[mutableObject mutableCopy] //深复制</p> </li></ul> 
<p>比如以下代码：</p> 
<p>NSMutableString *string = [NSMutableString stringWithString:@“origin”];//copy</p> 
<p>NSString *stringCopy = [string copy];</p> 
<p>查看内存，会发现 string、stringCopy 内存地址都不一样，说明此时都是做内容拷贝、深拷贝。即使你进行如下操作：</p> 
<p>[string appendString:@“origion!”]</p> 
<p>stringCopy 的值也不会因此改变，但是如果不使用 copy，stringCopy 的值就会被改变。 集合类对象以此类推。 所以，</p> 
<blockquote> 
 <p>用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</p> 
</blockquote> 
<h5><a id="_2copymutableCopy_1949"></a><a href="" rel="nofollow"></a>2、集合类对象的copy与mutableCopy</h5> 
<p>集合类对象是指 NSArray、NSDictionary、NSSet … 之类的对象。下面先看集合类immutable对象使用 copy 和 mutableCopy 的一个例子：</p> 
<p>NSArray *array = @[@[@“a”, @“b”], @[@“c”, @“d”]];</p> 
<p>NSArray *copyArray = [array copy];</p> 
<p>NSMutableArray *mCopyArray = [array mutableCopy];</p> 
<p>查看内容，可以看到 copyArray 和 array 的地址是一样的，而 mCopyArray 和 array 的地址是不同的。说明 copy 操作进行了指针拷贝，mutableCopy 进行了内容拷贝。但需要强调的是：此处的内容拷贝，仅仅是拷贝 array 这个对象，array 集合内部的元素仍然是指针拷贝。这和上面的非集合 immutable 对象的拷贝还是挺相似的，那么mutable对象的拷贝会不会类似呢？我们继续往下，看 mutable 对象拷贝的例子：</p> 
<p>NSMutableArray *array = [NSMutableArray arrayWithObjects:[NSMutableString stringWithString:@“a”],@“b”,@“c”,nil];</p> 
<p>NSArray *copyArray = [array copy];</p> 
<p>NSMutableArray *mCopyArray = [array mutableCopy];</p> 
<h4><a id="_1983"></a>最后</h4> 
<p>你要问前端开发难不难，我就得说计算机领域里常说的一句话，这句话就是『<strong>难的不会，会的不难</strong>』，对于不熟悉某领域技术的人来说，因为不了解所以产生神秘感，神秘感就会让人感觉很难，也就是『难的不会』；当学会这项技术之后，知道什么什么技术能做到什么做不到，只是做起来花多少时间的问题而已，没啥难的，所以就是『会的不难』。</p> 
<p><strong>我特地针对初学者整理一套前端学习资料</strong></p> 
<p>[外链图片转存中…(img-B5taAbGh-1713030858099)]</p> 
<p>[外链图片转存中…(img-x5KA0Mky-1713030858099)]</p> 
<p><strong>网上学习资料一大堆，但如果学到的知识不成体系，遇到问题时只是浅尝辄止，不再深入研究，那么很难做到真正的技术提升。</strong></p> 
<p><strong>需要这份系统化的资料的朋友，可以添加V获取：vip1024c （备注前端）</strong><br> [外链图片转存中…(img-P6hxwOCF-1713030858100)]</p> 
<p><strong>一个人可以走的很快，但一群人才能走的更远！不论你是正从事IT行业的老鸟或是对IT行业感兴趣的新人，都欢迎加入我们的的圈子（技术交流、学习资源、职场吐槽、大厂内推、面试辅导），让我们一起学习成长！</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7c124e286a5947ec40669bc2c0e11e1a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">plsql developer 一键格式化sql/美化sql</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d2f760a9e4387f93722a85d173011a0f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">文心一言指令词宝典之职场效率篇</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>