<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>前端从零搭建自己的脚手架 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/4ec789f7a9216121cdec0d80425e496c/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="前端从零搭建自己的脚手架">
  <meta property="og:description" content="目录
一、什么是脚手架
二、项目的创建
1、包管理工具
2、初始化
3、构建项目的基本结构
4、引入react
5、引入typescript
6、webpack配置
7、文件别名
8、引入less、sass、stylus
三、webpack构建速度优化
1、webpack进度条
2、构建耗时
3、开启持久化存储缓存：
4、开启多线程loader
四、webpack构建产物优化
1、bundle体积分析工具
2、样式提取
3、tree-shaking清理未引用的js
4、tree-shaking清理未引用的css
5、资源懒加载
6、资源预加载
7、gzip压缩
总结：
一、什么是脚手架 Webpack脚手架是一个工具，用于快速搭建基于Webpack的项目结构。它通常包括了一些预设的配置和插件，以便用户可以快速开始一个新的项目，而不必从头开始配置Webpack。这些脚手架可以帮助开发人员自动处理诸如打包、代码转译、资源管理等繁琐的任务，从而让他们更专注于项目的逻辑实现。
二、项目的创建 1、包管理工具 npm（Node Package Manager）是 Node.js 的默认包管理器，可以用于安装、更新和删除 JavaScript 包。
yarn 是另一个流行的包管理器，由 Facebook 开发。它旨在解决 npm 的一些限制和一些性能安全问题，并且通常比 npm 更快速、稳定。
pnpm 是另一个包管理器，它通过重用文件系统硬链接以及共享依赖来显著减少磁盘空间占用。相比于传统的 npm 和 yarn，pnpm 在安装包时只保存一个拷贝，因此在大型项目中能够节省大量的磁盘空间。
此次项目中我们使用pnpm。
相关资料：pnpm基本使用
2、初始化 新建一个文件夹，然后在根目录打开终端并输入以下命令：
pnpm - v # 初始化 package . json 文件 pnpm init 初始化后会在根目录生成一个package.json 文件：
package.json文件在Webpack中扮演了重要的角色。它用于描述项目的依赖项信息和定义的依赖项，并且可以利用package.json中的脚本命令来执行构建任务。
3、构建项目的基本结构 ├── build | ├── webpack.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-12-23T17:02:05+08:00">
    <meta property="article:modified_time" content="2023-12-23T17:02:05+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">前端从零搭建自己的脚手架</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%89%8B%E6%9E%B6-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%89%8B%E6%9E%B6" rel="nofollow">一、什么是脚手架</a></p> 
<p id="%E4%BA%8C%E3%80%81%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%88%9B%E5%BB%BA-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%88%9B%E5%BB%BA" rel="nofollow">二、项目的创建</a></p> 
<p id="1%E3%80%81%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7" rel="nofollow">1、包管理工具</a></p> 
<p id="2%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">2、初始化</a></p> 
<p id="3%E3%80%81%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84" rel="nofollow">3、构建项目的基本结构</a></p> 
<p id="4%E3%80%81%E5%BC%95%E5%85%A5react-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E5%BC%95%E5%85%A5react" rel="nofollow">4、引入react</a></p> 
<p id="5%E3%80%81%E5%BC%95%E5%85%A5typescript-toc" style="margin-left:40px;"><a href="#5%E3%80%81%E5%BC%95%E5%85%A5typescript" rel="nofollow">5、引入typescript</a></p> 
<p id="6%E3%80%81webpack%E9%85%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#6%E3%80%81webpack%E9%85%8D%E7%BD%AE" rel="nofollow">6、webpack配置</a></p> 
<p id="7%E3%80%81%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D-toc" style="margin-left:40px;"><a href="#7%E3%80%81%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D" rel="nofollow">7、文件别名</a></p> 
<p id="8%E3%80%81%E5%BC%95%E5%85%A5less%E3%80%81sass%E3%80%81stylus-toc" style="margin-left:40px;"><a href="#8%E3%80%81%E5%BC%95%E5%85%A5less%E3%80%81sass%E3%80%81stylus" rel="nofollow">8、引入less、sass、stylus</a></p> 
<p id="%E4%B8%89%E3%80%81webpack%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81webpack%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96" rel="nofollow">三、webpack构建速度优化</a></p> 
<p id="1%E3%80%81webpack%E8%BF%9B%E5%BA%A6%E6%9D%A1-toc" style="margin-left:40px;"><a href="#1%E3%80%81webpack%E8%BF%9B%E5%BA%A6%E6%9D%A1" rel="nofollow">1、webpack进度条</a></p> 
<p id="2%E3%80%81%E6%9E%84%E5%BB%BA%E8%80%97%E6%97%B6-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E6%9E%84%E5%BB%BA%E8%80%97%E6%97%B6" rel="nofollow">2、构建耗时</a></p> 
<p id="3%E3%80%81%E5%BC%80%E5%90%AF%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8%E7%BC%93%E5%AD%98%EF%BC%9A-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E5%BC%80%E5%90%AF%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8%E7%BC%93%E5%AD%98%EF%BC%9A" rel="nofollow">3、开启持久化存储缓存：</a></p> 
<p id="4%E3%80%81%E5%BC%80%E5%90%AF%E5%A4%9A%E7%BA%BF%E7%A8%8Bloader-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E5%BC%80%E5%90%AF%E5%A4%9A%E7%BA%BF%E7%A8%8Bloader" rel="nofollow">4、开启多线程loader</a></p> 
<p id="%E5%9B%9B%E3%80%81webpack%E6%9E%84%E5%BB%BA%E4%BA%A7%E7%89%A9%E4%BC%98%E5%8C%96-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81webpack%E6%9E%84%E5%BB%BA%E4%BA%A7%E7%89%A9%E4%BC%98%E5%8C%96" rel="nofollow">四、webpack构建产物优化</a></p> 
<p id="1%E3%80%81bundle%E4%BD%93%E7%A7%AF%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7-toc" style="margin-left:40px;"><a href="#1%E3%80%81bundle%E4%BD%93%E7%A7%AF%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7" rel="nofollow">1、bundle体积分析工具</a></p> 
<p id="2%E3%80%81%E6%A0%B7%E5%BC%8F%E6%8F%90%E5%8F%96-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E6%A0%B7%E5%BC%8F%E6%8F%90%E5%8F%96" rel="nofollow">2、样式提取</a></p> 
<p id="3%E3%80%81tree-shaking%E6%B8%85%E7%90%86%E6%9C%AA%E5%BC%95%E7%94%A8%E7%9A%84js-toc" style="margin-left:40px;"><a href="#3%E3%80%81tree-shaking%E6%B8%85%E7%90%86%E6%9C%AA%E5%BC%95%E7%94%A8%E7%9A%84js" rel="nofollow">3、tree-shaking清理未引用的js</a></p> 
<p id="4%E3%80%81tree-shaking%E6%B8%85%E7%90%86%E6%9C%AA%E5%BC%95%E7%94%A8%E7%9A%84css-toc" style="margin-left:40px;"><a href="#4%E3%80%81tree-shaking%E6%B8%85%E7%90%86%E6%9C%AA%E5%BC%95%E7%94%A8%E7%9A%84css" rel="nofollow">4、tree-shaking清理未引用的css</a></p> 
<p id="5%E3%80%81%E8%B5%84%E6%BA%90%E6%87%92%E5%8A%A0%E8%BD%BD-toc" style="margin-left:40px;"><a href="#5%E3%80%81%E8%B5%84%E6%BA%90%E6%87%92%E5%8A%A0%E8%BD%BD" rel="nofollow">5、资源懒加载</a></p> 
<p id="6%E3%80%81%E8%B5%84%E6%BA%90%E9%A2%84%E5%8A%A0%E8%BD%BD-toc" style="margin-left:40px;"><a href="#6%E3%80%81%E8%B5%84%E6%BA%90%E9%A2%84%E5%8A%A0%E8%BD%BD" rel="nofollow">6、资源预加载</a></p> 
<p id="7%E3%80%81gzip%E5%8E%8B%E7%BC%A9-toc" style="margin-left:40px;"><a href="#7%E3%80%81gzip%E5%8E%8B%E7%BC%A9" rel="nofollow">7、gzip压缩</a></p> 
<p id="%E6%80%BB%E7%BB%93%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93%EF%BC%9A" rel="nofollow">总结：</a></p> 
<hr id="hr-toc"> 
<h2>一、什么是脚手架</h2> 
<p>        Webpack脚手架是一个工具，用于快速搭建基于Webpack的项目结构。它通常包括了一些预设的配置和插件，以便用户可以快速开始一个新的项目，而不必从头开始配置Webpack。这些脚手架可以帮助开发人员自动处理诸如打包、代码转译、资源管理等繁琐的任务，从而让他们更专注于项目的逻辑实现。</p> 
<h2 id="%E4%BA%8C%E3%80%81%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%88%9B%E5%BB%BA">二、项目的创建</h2> 
<h3 id="1%E3%80%81%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7">1、包管理工具</h3> 
<ul><li> <p><strong>npm</strong>（Node Package Manager）是 Node.js 的默认包管理器，可以用于安装、更新和删除 JavaScript 包。</p> </li><li> <p><strong>yarn</strong> 是另一个流行的包管理器，由 Facebook 开发。它旨在解决 npm 的一些限制和一些性能安全问题，并且通常比 npm 更快速、稳定。</p> </li><li> <p><strong>pnpm</strong> 是另一个包管理器，它通过重用文件系统硬链接以及共享依赖来显著减少磁盘空间占用。相比于传统的 npm 和 yarn，pnpm 在安装包时只保存一个拷贝，因此在大型项目中能够节省大量的磁盘空间。</p> </li></ul> 
<p>此次项目中我们使用pnpm。</p> 
<p><span style="color:#333333;">相关资料：</span><a class="link-info" href="https://pnpm.io/zh/cli/install" rel="nofollow" title="pnpm基本使用">pnpm基本使用</a></p> 
<h3 id="2%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96">2、初始化</h3> 
<p>新建一个文件夹，然后在根目录打开终端并输入以下命令：</p> 
<blockquote> 
 <div> 
  <span style="color:#000000;">pnpm </span> 
  <span style="color:#981a1a;">-</span> 
  <span style="color:#000000;">v </span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#333333;"># </span> 
  <span style="color:#000000;">初始化</span> 
  <span style="color:#000000;">package</span> 
  <span style="color:#333333;">.</span> 
  <span style="color:#000000;">json</span> 
  <span style="color:#000000;">文件 </span> 
 </div> 
 <div> 
  <span style="color:#000000;">pnpm init</span> 
 </div> 
</blockquote> 
<p>初始化后会在根目录生成一个<span style="color:#333333;"><span style="background-color:#f9eda6;">package.json</span> </span><span style="color:#333333;">文件：</span></p> 
<p><span style="color:#333333;"><span style="background-color:#cccccc;">package.json</span></span><span style="background-color:#cccccc;">文件在Webpack中扮演了重要的角色。它用于描述项目的依赖项信息和</span><span style="background-color:#cccccc;">定义的依赖项，并且可以利用</span><span style="color:#333333;"><span style="background-color:#cccccc;">package.json</span></span><span style="background-color:#cccccc;">中的脚本命令来执行构建任务。</span></p> 
<p><img alt="" height="302" src="https://images2.imgbox.com/32/29/uS762D0y_o.png" width="709"></p> 
<h3 id="3%E3%80%81%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84">3、构建项目的基本结构</h3> 
<pre><code>├── build
| ├── webpack.base.ts # 公共配置
| ├── webpack.dev.ts # 开发环境配置
| └── webpack.prod.ts # 打包环境配置
├── public
│ └── index.html # html模板
├── src
| ├── App.tsx
| ├── App.css
│ └── index.tsx # react应用入口页面
└── package.json</code></pre> 
<p>index.html先添加一个节点：</p> 
<pre><code class="language-html">&lt;body&gt;
    &lt;!-- 容器节点 --&gt;
    &lt;div id="root"&gt;&lt;/div&gt;
&lt;/body&gt;</code></pre> 
<h3 id="4%E3%80%81%E5%BC%95%E5%85%A5react">4、引入react</h3> 
<p>我们先简单了解一下什么是react：</p> 
<p>        React 是一个用于构建用户界面的 <span style="background-color:#ffd900;">JS 库</span>。它通过组件化的方式让开发者可以轻松地构建交互式的用户界面。React 使用虚拟 DOM 技术，这使得页面在更新时能够更加高效地进行渲染。通过使用 <span style="background-color:#ffd900;">JSX 语法</span>，React 允许开发者<span style="background-color:#ffd900;">将 HTML 结构和 JavaScript 代码结合</span>起来。</p> 
<p>安装react依赖：</p> 
<blockquote> 
 <div> 
  <span style="color:#000000;">pnpm i react react</span> 
  <span style="color:#981a1a;">-</span> 
  <span style="color:#000000;">dom </span> 
 </div> 
 <div> 
  <span style="color:#333333;"># </span> 
  <span style="color:#000000;">声明依赖 </span> 
 </div> 
 <div> 
  <span style="color:#000000;">pnpm i </span> 
  <span style="color:#981a1a;">@</span> 
  <span style="color:#000000;">types</span> 
  <span style="color:#981a1a;">/</span> 
  <span style="color:#000000;">react </span> 
  <span style="color:#981a1a;">@</span> 
  <span style="color:#000000;">types</span> 
  <span style="color:#981a1a;">/</span> 
  <span style="color:#000000;">react</span> 
  <span style="color:#981a1a;">-</span> 
  <span style="color:#000000;">dom </span> 
  <span style="color:#981a1a;">-</span> 
  <span style="color:#000000;">D </span> 
 </div> 
</blockquote> 
<p>在src/index.tsx中编写入口文件：</p> 
<pre><code class="language-javascript">import React from 'react';
import { createRoot } from 'react-dom/client';
import App from './App';
const root = document.querySelector('#root')
if(root) {
    createRoot(root).render(&lt;App /&gt;)
}</code></pre> 
<p>在App.css写一个简单的样式：</p> 
<pre><code class="language-css">h2 {
    color:red;
}</code></pre> 
<p>以及App.tsx</p> 
<pre><code class="language-javascript">import React from 'react'
import './App.css'
function App() {
    return &lt;h2&gt;你好，蒙面大婶&lt;/h2&gt;
}
export default App</code></pre> 
<h3 id="5%E3%80%81%E5%BC%95%E5%85%A5typescript">5、引入typescript</h3> 
<p>简单了解一下什么是typescript（ts）：</p> 
<p>        TypeScript是一种由微软开发的开源编程语言。TypeScript通过添加静态类型、接口、类和其他高级结构来扩展JavaScript，从而使得在大型项目中更易于维护和阅读。它最终会被编译成纯粹的JavaScript，可以在任何支持JavaScript的地方运行。TypeScript的主要优势之一是提供了更强大的工具和功能，以帮助程序员在开发过程中尽早发现和修复错误。</p> 
<p>在终端输入以下命令安装ts:</p> 
<blockquote> 
 <div> 
  <span style="color:#000000;">pnpm i typescript </span> 
  <span style="color:#981a1a;">-</span> 
  <span style="color:#000000;">D </span> 
 </div> 
 <div> 
  <span style="color:#000000;">pnpm i babel</span> 
  <span style="color:#981a1a;">-</span> 
  <span style="color:#000000;">loader ts</span> 
  <span style="color:#981a1a;">-</span> 
  <span style="color:#000000;">node </span> 
  <span style="color:#981a1a;">@</span> 
  <span style="color:#000000;">babel</span> 
  <span style="color:#981a1a;">/</span> 
  <span style="color:#000000;">core </span> 
  <span style="color:#981a1a;">@</span> 
  <span style="color:#000000;">babel</span> 
  <span style="color:#981a1a;">/</span> 
  <span style="color:#000000;">preset</span> 
  <span style="color:#981a1a;">-</span> 
  <span style="color:#000000;">react </span> 
  <span style="color:#981a1a;">@</span> 
  <span style="color:#000000;">babel</span> 
  <span style="color:#981a1a;">/</span> 
  <span style="color:#000000;">preset-typescript </span> 
  <span style="color:#981a1a;">@</span> 
  <span style="color:#000000;">babel</span> 
  <span style="color:#981a1a;">/</span> 
  <span style="color:#000000;">preset</span> 
  <span style="color:#981a1a;">-</span> 
  <span style="color:#000000;">env core</span> 
  <span style="color:#981a1a;">-</span> 
  <span style="color:#000000;">js </span> 
  <span style="color:#981a1a;">-</span> 
  <span style="color:#000000;">D </span> 
 </div> 
</blockquote> 
<div> 
 <span style="color:#333333;">初始化 </span> 
 <span style="color:#333333;">tsconfig.json </span> 
 <span style="color:#333333;">：</span> 
</div> 
<div></div> 
<blockquote> 
 <div> 
  <span style="color:#000000;">npx tsc </span> 
  <span style="color:#981a1a;">--</span> 
  <span style="color:#000000;">init </span> 
 </div> 
</blockquote> 
<h3 id="6%E3%80%81webpack%E9%85%8D%E7%BD%AE">6、webpack配置</h3> 
<p>简单了解一下什么是webpack：</p> 
<p>        webpack 是一个流行的开源前端模块打包工具，它通过将各种静态资源（如JavaScript、CSS、HTML、图片等）视为模块以及其它的一 些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并基于这些模块生成优化后的静态文件（通常是一个或多bundle）。这些bundle可以被浏览器直接使用，从而提高网页的加载速度和运行效率。</p> 
<p>在终端输入以下命令安装依赖：</p> 
<blockquote> 
 <div> 
  <span style="color:#000000;">pnpm i webpack webpack</span> 
  <span style="color:#981a1a;">-</span> 
  <span style="color:#000000;">cli </span> 
  <span style="color:#981a1a;">-</span> 
  <span style="color:#000000;">D </span> 
 </div> 
 <div> 
  <span style="color:#000000;">pnpm i </span> 
  <span style="color:#981a1a;">@</span> 
  <span style="color:#000000;">types</span> 
  <span style="color:#981a1a;">/</span> 
  <span style="color:#000000;">node </span> 
  <span style="color:#981a1a;">-</span> 
  <span style="color:#000000;">D</span> 
 </div> 
</blockquote> 
<p>因为需要引入css文件，所以还需要安装相关的loader：</p> 
<blockquote> 
 <div> 
  <span style="color:#000000;">pnpm i style</span> 
  <span style="color:#981a1a;">-</span> 
  <span style="color:#000000;">loader css</span> 
  <span style="color:#981a1a;">-</span> 
  <span style="color:#000000;">loader html</span> 
  <span style="color:#981a1a;">-</span> 
  <span style="color:#000000;">webpack</span> 
  <span style="color:#981a1a;">-</span> 
  <span style="color:#000000;">plugin </span> 
  <span style="color:#981a1a;">-</span> 
  <span style="color:#000000;">D </span> 
 </div> 
</blockquote> 
<p>loader：在Webpack中，loader是用于转换非JavaScript文件（如CSS、图片、字体等）为模块的工具。</p> 
<p>配置webpack.base.ts:</p> 
<pre><code class="language-javascript">import { Configuration } from "webpack";
import HtmlWebpackPlugin from "html-webpack-plugin";
const path = require("path");
const baseConfig: Configuration = {
    entry: path.join(__dirname, "../src/index.tsx"), // 入口文件
    // 打包出口文件
    output: {
        filename: "static/js/[name].js", // 每个输出js的名称
        path: path.join(__dirname, "../dist"), // 打包结果输出路径
        clean: true, // webpack4需要配置clean-webpack-plugin来删除dist文件,webpack5内置了
        publicPath: "/", // 打包后文件的公共前缀路径
    },
    // loader 配置
    module: {
        rules: [
            {
                test: /.(ts|tsx)$/, // 匹配.ts, tsx文件
                use: "babel-loader"
            },
            {
                test: /.css$/, //匹配 css 文件
                use: ["style-loader", "css-loader"],
            },
        ],
    },
    resolve: {
        extensions: [".tsx", ".ts", ".jsx", ".js"],
    },
    // plugins
    plugins: [
        new HtmlWebpackPlugin({
            // 复制 'index.html' 文件，并自动引入打包输出的所有资源（js/css）
            template: path.join(__dirname, "../public/index.html"),
            // 压缩html资源
            minify: {
                collapseWhitespace: true, //去空格
                removeComments: true, // 去注释
            },
        }),
    ],
};
export default baseConfig;
</code></pre> 
<div> 
 <span style="color:#333333;">在根目录新建 babel.config.js ，并输入以下内容：</span> 
</div> 
<div></div> 
<pre><code class="language-javascript">module.exports = {
    // 执行顺序由右往左,所以先处理ts,再处理jsx,最后再试一下babel转换为低版本语法
    presets: [
        [
            "@babel/preset-env",
            {
                targets: { browsers: ["&gt; 1%", "last 2 versions", "not ie &lt;= 8"] },
                useBuiltIns: "usage", // 根据配置的浏览器兼容,以及代码中使用到的api进行引入polyfill按需添加
                corejs: 3, // 配置使用core-js使用的版本
                loose: true,
            },
        ],
        // 如果您使用的是 Babel 和 React 17，您可能需要将 "runtime": "automatic" 添加到配置中。
        // 否则可能会出现错误：Uncaught ReferenceError: React is not defined
        ["@babel/preset-react", { runtime: "automatic" }],
        "@babel/preset-typescript",
    ],
};</code></pre> 
<div> 
 <span style="color:#333333;">我们需要通过 </span> 
 <span style="color:#333333;">webpack-dev-server </span> 
 <span style="color:#333333;">来启动项目，所以需要安装相关的依赖：</span> 
</div> 
<div></div> 
<blockquote> 
 <div> 
  <span style="color:#333333;">pnpm i webpack-dev-server webpack-merge </span> 
  <span style="color:#0000cc;">-D </span> 
 </div> 
</blockquote> 
<p>并配置<span style="color:#333333;">webpack.dev.ts </span>：</p> 
<pre><code class="language-javascript">import path from "path";
import { merge } from "webpack-merge";
import { Configuration as WebpackConfiguration } from "webpack";
import { Configuration as WebpackDevServerConfiguration } from "webpack-dev-server";
import baseConfig from "./webpack.base";
interface Configuration extends WebpackConfiguration {
    devServer?: WebpackDevServerConfiguration;
}
const host = "127.0.0.1";
const port = "8082";
// 合并公共配置,并添加开发环境配置
const devConfig: Configuration = merge(baseConfig, {
    mode: "development", // 开发模式,打包更加快速,省了代码优化步骤
    devtool: "eval-cheap-module-source-map",
    devServer: {
        host,
        port,
        open: true, // 是否自动打开
        compress: false, // gzip压缩,开发环境不开启，提升热更新速度
        hot: true, // 开启热更新
        historyApiFallback: true, // 解决history路由404问题
        setupExitSignals: true, // 允许在 SIGINT 和 SIGTERM 信号时关闭开发服务器和退出
        进程。
        static: {
            directory: path.join(__dirname, "../public"), // 托管静态资源public文件夹
        },
        headers: { "Access-Control-Allow-Origin": "*" }, // HTTP响应头设置，允许任何
        来源进行跨域请求
    },
});
export default devConfig;</code></pre> 
<p>在tsconfig.json中加入一行"jsx":"react-jsx",这样就不需要在tsx文件中手动引入react：</p> 
<pre><code class="language-javascript">{
    "compilerOptions": {
        "jsx": "react-jsx" 
    },
    "include": ["./src"]
}</code></pre> 
<div> 
 <span style="color:#333333;">在 </span> 
 <span style="color:#333333;">package.json </span> 
 <span style="color:#333333;">中添加启动脚本： </span> 
</div> 
<pre><code class="language-javascript">"scripts": {
    "dev": "webpack serve -c build/webpack.dev.ts"
},</code></pre> 
<p>最后在终端运行pnpm dev启动项目，出现以下结果说明运行成功。</p> 
<p><img alt="" height="769" src="https://images2.imgbox.com/14/05/lI47C0pB_o.png" width="913"></p> 
<p>配置<span style="color:#333333;">webpack.prod.ts：</span></p> 
<pre><code class="language-javascript">import { Configuration } from "webpack";
import { merge } from "webpack-merge";
import baseConfig from "./webpack.base";
const prodConfig: Configuration = merge(baseConfig, {
  mode: "production", // 生产模式,会开启tree-shaking和压缩代码,以及其他优化
});
export default prodConfig;</code></pre> 
<div> 
 <span style="color:#333333;">在 </span> 
 <span style="color:#333333;">package.json 中添加</span>脚本命令来执行构建任务 
 <span style="color:#333333;">：</span> 
</div> 
<pre><code class="language-javascript">"scripts": {
    "build": "webpack -c build/webpack.prod.ts"
},</code></pre> 
<p>然后运行pnpm build命令，就是使用名为"webpack.prod.ts"的配置文件来进行生产环境下的构建。Webpack会根据该配置文件对项目进行打包和优化，生成用于生产环境部署的文件。</p> 
<p>运行后会在根目录生成一个dist文件夹，就是打包、压缩或编译后的文件，如（HTML、CSS、JavaScript文件），用于部署到生产环境。</p> 
<p><img alt="" height="116" src="https://images2.imgbox.com/fa/c3/yjlAZH5N_o.png" width="302"></p> 
<p>copy静态资源：</p> 
<div> 
 <span style="color:#333333;">一般 </span> 
 <span style="color:#333333;">public 文件夹会放一些静态资源（如图片、 </span> 
 <span style="color:#333333;">css </span> 
 <span style="color:#333333;">、 </span> 
 <span style="color:#333333;">js </span> 
 <span style="color:#333333;">文件）,可以直接根据绝对路径引入，需要</span> 
 <span style="color:#333333;">安装依赖： </span> 
</div> 
<blockquote> 
 <div> 
  <span style="color:#000000;">pnpm i copy</span> 
  <span style="color:#981a1a;">-</span> 
  <span style="color:#000000;">webpack</span> 
  <span style="color:#981a1a;">-</span> 
  <span style="color:#000000;">plugin </span> 
  <span style="color:#981a1a;">-</span> 
  <span style="color:#000000;">D</span> 
 </div> 
</blockquote> 
<p>修改<span style="color:#333333;">webpack.base.ts </span><span style="color:#333333;">： </span></p> 
<pre><code class="language-javascript">const baseConfig: Configuration = {
    // ...
    plugins: [
    new HtmlWebpackPlugin({
      title: "webpack5-react-ts",
      filename: "index.html",
      // 复制 'index.html' 文件，并自动引入打包输出的所有资源（js/css）
      template: path.join(__dirname, "../public/index.html"),
      inject: true, // 自动注入静态资源
      hash: true,
      cache: false,
      // 压缩html资源
      minify: {
        removeAttributeQuotes: true,
        collapseWhitespace: true, //去空格
        removeComments: true, // 去注释
        minifyJS: true, // 在脚本元素和事件属性中缩小JavaScript(使用UglifyJS)
        minifyCSS: true, // 缩小CSS样式元素和样式属性
      },
    }),
  ],
};</code></pre> 
<div> 
 <span style="color:#333333;">打包配置文件 webpack.prod.ts 中新增 </span> 
 <span style="color:#333333;">copy </span> 
 <span style="color:#333333;">插件配置：</span> 
</div> 
<pre><code class="language-javascript">import { Configuration } from "webpack";
import { merge } from "webpack-merge";
import baseConfig from "./webpack.base";
import path from "path";
import CopyPlugin from "copy-webpack-plugin";
const prodConfig: Configuration = merge(baseConfig, {
    mode: "production", // 生产模式,会开启tree-shaking和压缩代码,以及其他优化
    plugins: [
        new CopyPlugin({
            patterns: [
                {
                    from: path.resolve(__dirname, "../public"), // 复制public下文件
                    to: path.resolve(__dirname, "../dist"), // 复制到dist目录中
                    filter: (source) =&gt; !source.includes("index.html"), // 忽略index.html
                },
            ],
        }),
    ],
});
export default prodConfig;
</code></pre> 
<div> 
 <span style="color:#333333;">在 </span> 
 <span style="color:#333333;">public </span> 
 <span style="color:#333333;">中新增一个名为 </span> 
 <span style="color:#333333;">favicon.ico </span> 
 <span style="color:#333333;">图标文件，在 </span> 
 <span style="color:#333333;">index.html </span> 
 <span style="color:#333333;">中引入： </span> 
</div> 
<div></div> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;!-- 绝对路径引入图标文件 --&gt;
    &lt;link data-n-head="ssr" rel="icon" type="image/x-icon" href="/favicon.ico"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;webpack5-react-ts&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- 容器节点 --&gt;
    &lt;div id="root"&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<div> 
 <span style="color:#333333;">在终端执行</span> 
 <span style="color:#333333;">pnpm build命令</span> 
 <span style="color:#333333;">，就可以看到 </span> 
 <span style="color:#333333;">public </span> 
 <span style="color:#333333;">下的 </span> 
 <span style="color:#333333;">favicon.ico </span> 
 <span style="color:#333333;">图标文件被复制到 </span> 
 <span style="color:#333333;">dist </span> 
 <span style="color:#333333;">文件中 </span> 
</div> 
<div> 
 <span style="color:#333333;">，再运行pnpm dev命令就好了。</span> 
</div> 
<p><img alt="" height="178" src="https://images2.imgbox.com/e4/a2/OM6dtYai_o.png" width="518"></p> 
<p></p> 
<h3 id="7%E3%80%81%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D">7、文件别名</h3> 
<div> 
 <span style="color:#333333;">配置 </span> 
 <span style="color:#333333;">webpack.base.ts </span> 
 <span style="color:#333333;">：</span> 
</div> 
<div> 
 <pre><code class="language-javascript">resolve: {
    extensions: [".ts", ".tsx", ".js", ".jsx", ".less", ".css"],
    // 别名需要配置两个地方，这里和 tsconfig.json
    alias: {
        "@": path.join(__dirname, "../src")
    },
},</code></pre> 
 <p>配置<span style="color:#333333;">tsconfig.json：</span></p> 
 <pre><code class="language-javascript">{
    "compilerOptions": {
        // ...
        "baseUrl": ".",
        "paths": {
        "@/*": ["src/*"]
        },
    },
}</code></pre> 
 <h3 id="8%E3%80%81%E5%BC%95%E5%85%A5less%E3%80%81sass%E3%80%81stylus">8、引入less、sass、stylus</h3> 
 <div></div> 
</div> 
<p>        在Webpack中，Less、Sass和Stylus是CSS预处理器，它们允许开发人员使用类似编程语言的语法来编写样式表，并将其转换为浏览器可识别的标准CSS。</p> 
<p>在终端输入以下命令安装依赖：</p> 
<blockquote> 
 <div> 
  <span style="color:#000000;">pnpm i less less</span> 
  <span style="color:#981a1a;">-</span> 
  <span style="color:#000000;">loader sass</span> 
  <span style="color:#981a1a;">-</span> 
  <span style="color:#000000;">loader sass stylus stylus</span> 
  <span style="color:#981a1a;">-</span> 
  <span style="color:#000000;">loader </span> 
  <span style="color:#981a1a;">-</span> 
  <span style="color:#000000;">D</span> 
 </div> 
</blockquote> 
<div> 
 <span style="color:#333333;">在 </span> 
 <span style="color:#333333;">webpack.base.ts </span> 
 <span style="color:#333333;">添加相关的 </span> 
 <span style="color:#333333;">loader </span> 
 <span style="color:#333333;">：</span> 
</div> 
<div> 
 <pre><code class="language-javascript">const cssRegex = /\.css$/;
const sassRegex = /\.(scss|sass)$/;
const lessRegex = /\.less$/;
const stylRegex = /\.styl$/;

const styleLoadersArray = [
    "style-loader",
    {
        loader: "css-loader",
        options: {
            modules: {
                localIdentName: "[path][name]__[local]--[hash:5]",
            },
        },
    },
];
const baseConfig: Configuration = {
    // ...
    module: {
        rules: [
            // ...
            {
                test: lessRegex,
                use: [
                    ...styleLoadersArray,
                    {
                        loader: 'less-loader',
                        options: {
                            lessOptions: {
                                // 如果要在less中写js的语法，需要加这一配置
                                javascriptEnabled: true
                            }
                        }
                    }
                ]
            },
            {
                test: sassRegex,
                use: [
                    ...styleLoadersArray,
                    {
                        loader: 'sass-loader',
                        options: {
                            implementation: require('sass') // 使用dart-sass代替node-sass
                        }
                    }
                ]
            },
            {
                test: stylRegex,
                use: [
                    ...styleLoadersArray,
                    'stylus-loader'
                ]
            }
        ]
    }
}</code></pre> 
 <h2 id="%E4%B8%89%E3%80%81webpack%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96">三、webpack构建速度优化</h2> 
 <h3 id="1%E3%80%81webpack%E8%BF%9B%E5%BA%A6%E6%9D%A1">1、webpack进度条</h3> 
 <p>        webpack进度条以图形方式显示项目运行情况，使我们可以清晰地了解项目的运行程度。</p> 
 <p>首先安装依赖：</p> 
 <blockquote> 
  <div> 
   <span style="color:#333333;">pnpm i webpackbar </span> 
   <span style="color:#0000cc;">-D </span> 
  </div> 
 </blockquote> 
</div> 
<div> 
 <span style="color:#333333;">webpack.base.ts </span> 
 <span style="color:#333333;">中引入：</span> 
</div> 
<div></div> 
<pre><code class="language-javascript">// ...
import WebpackBar from 'webpackbar';
// ...
const baseConfig: Configuration = {
    // ...
    // plugins 的配置
    plugins: [
    // ...
        new WebpackBar({
            color: "#85d", // 默认green，进度条颜色支持HEX
            basic: false, // 默认true，启用一个简单的日志报告器
            profile:false, // 默认false，启用探查器。
        })
    ],
};
export default baseConfig;</code></pre> 
<p>在运行后，终端的输出为：</p> 
<p><img alt="" height="246" src="https://images2.imgbox.com/6c/58/7Oe3TKIZ_o.png" width="736"></p> 
<h3 id="2%E3%80%81%E6%9E%84%E5%BB%BA%E8%80%97%E6%97%B6">2、构建耗时</h3> 
<p>可以清楚的看到每个步骤的花费时长，安装依赖：</p> 
<blockquote> 
 <div> 
  <span style="color:#333333;">pnpm i speed-measure-webpack-plugin </span> 
  <span style="color:#0000cc;">-D </span> 
 </div> 
</blockquote> 
<div></div> 
<div> 
 <span style="color:#333333;">在build中新建webpack.analy.ts：</span> 
</div> 
<div></div> 
<pre><code class="language-javascript">import { Configuration } from "webpack";
import prodConfig from "./webpack.prod"; // 引入打包配置
import { merge } from "webpack-merge"; // 引入合并webpack配置方法
const SpeedMeasurePlugin = require("speed-measure-webpack-plugin"); // 引入webpack打包速度分析插件;
const smp = new SpeedMeasurePlugin(); // 实例化分析插件
// 使用smp.wrap方法,把生产环境配置传进去,由于后面可能会加分析配置,所以先留出合并空位
const analyConfig: Configuration = smp.wrap(merge(prodConfig, {}));
export default analyConfig;</code></pre> 
<div> 
 <span style="color:#333333;">修改 </span> 
 <span style="color:#333333;">package.json </span> 
 <span style="color:#333333;">添加启动 </span> 
 <span style="color:#333333;">webpack </span> 
 <span style="color:#333333;">打包分析脚本命令，在 </span> 
 <span style="color:#333333;">scripts </span> 
 <span style="color:#333333;">新增： </span> 
</div> 
<div></div> 
<pre><code class="language-javascript">"scripts": {
    "build:analy": "cross-env NODE_ENV=production BASE_ENV=production webpack -c build/webpack.analy.ts"
}</code></pre> 
<p>在终端<span style="color:#333333;">执行 </span><span style="color:#333333;">pnpm build:analy。</span></p> 
<h3 id="3%E3%80%81%E5%BC%80%E5%90%AF%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8%E7%BC%93%E5%AD%98%EF%BC%9A">3、开启持久化存储缓存：</h3> 
<div> 
 <span style="color:#333333;">        通过对 文件做哈希对比来验证文件前后是否一致，如果一致则采用上一次的缓存，可以极大地节省时间。</span> 
</div> 
<div>
  修改webpack.base.ts: 
</div> 
<div> 
 <pre><code class="language-javascript">module.exports = {
    // ...
    cache: {
        type: 'filesystem', // 使用文件缓存
    },
}</code></pre> 
 <h3 id="4%E3%80%81%E5%BC%80%E5%90%AF%E5%A4%9A%E7%BA%BF%E7%A8%8Bloader">4、开启多线程loader</h3> 
 <p>        多线程loader是一种可以并行加载多个资源或数据的系统或程序组件。它利用多线程技术，允许同时从不同来源加载数据，以提高整体加载速度和性能。</p> 
</div> 
<p>安装依赖：</p> 
<blockquote> 
 <div> 
  <span style="color:#333333;">pnpm i thread-loader -D</span> 
 </div> 
</blockquote> 
<div> 
 <span style="color:#333333;">修改 </span> 
 <span style="color:#333333;">webpack.base.ts </span>： 
</div> 
<div> 
 <pre><code class="language-javascript">module: {
    rules: [
        {
            test: /\.(ts|tsx)$/, // 匹配ts和tsx文件
            use: [
            {
                loader: 'thread-loader',
                options: {
                wokers: 4 // 进程数
                }
            },
            'babel-loader']
        }，
    ]
}</code></pre> 
 <h2 id="%E5%9B%9B%E3%80%81webpack%E6%9E%84%E5%BB%BA%E4%BA%A7%E7%89%A9%E4%BC%98%E5%8C%96">四、webpack构建产物优化</h2> 
 <h3 id="1%E3%80%81bundle%E4%BD%93%E7%A7%AF%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7">1、bundle体积分析工具</h3> 
 <p>        bundle体积分析工具是一个用于可视化显示 bundle 结构和大小的工具。它可以帮我们查看 JavaScript 和其他资源文件在 bundle 中的大小、依赖关系等信息。</p> 
 <p>安装依赖：</p> 
 <blockquote> 
  <div> 
   <span style="color:#333333;">pnpm i webpack-bundle-analyzer </span> 
   <span style="color:#0000cc;">-D </span> 
  </div> 
 </blockquote> 
</div> 
<p><span style="color:#333333;">修改 </span><span style="color:#333333;">webpack.analy.ts </span><span style="color:#333333;">：</span></p> 
<pre><code class="language-javascript">import { Configuration } from "webpack";
import { merge } from "webpack-merge";
import prodConfig from "./webpack.prod";
const SpeedMeasurePlugin = require("speed-measure-webpack-plugin");
const { BundleAnalyzerPlugin } = require("webpack-bundle-analyzer");
// 引入webpack打包速度分析插件
const smp = new SpeedMeasurePlugin();
// 使用smp.wrap方法,把生产环境配置传进去,由于后面可能会加分析配置,所以先留出合并空位
const analyConfig: Configuration = smp.wrap(merge(prodConfig, {
plugins: [
new BundleAnalyzerPlugin() // 配置分析打包结果插件
]
}))
export default analyConfig;</code></pre> 
<h3 id="2%E3%80%81%E6%A0%B7%E5%BC%8F%E6%8F%90%E5%8F%96">2、样式提取</h3> 
<p>安装依赖：</p> 
<blockquote> 
 <div> 
  <span style="color:#333333;">pnpm i mini-css-extract-plugin </span> 
  <span style="color:#0000cc;">-D</span> 
 </div> 
</blockquote> 
<div> 
 <span style="color:#333333;">修改 </span> 
 <span style="color:#333333;">webpack.base.ts：</span> 
</div> 
<div> 
 <pre><code class="language-javascript">const MiniCssExtractPlugin = require('mini-css-extract-plugin')
const isDev = process.env.NODE_ENV === 'development' // 是否是开发模式
const styleLoadersArray = [
    isDev ? "style-loader" : MiniCssExtractPlugin.loader, // 开发环境使用stylelooader,打包模式抽离css
    {
        loader: "css-loader",
        options: {
            modules: {
                localIdentName: "[path][name]__[local]--[hash:5]",
            },
        },
    },
    'postcss-loader'
];</code></pre> 
 <p><span style="color:#333333;">修改 </span><span style="color:#333333;">webpack.prod.ts：</span></p> 
</div> 
<pre><code class="language-javascript">const MiniCssExtractPlugin = require('mini-css-extract-plugin')
const prodConfig: Configuration = merge(baseConfig, {
    // ...
    plugins: [
        // ...
        new MiniCssExtractPlugin({
            filename: 'static/css/[name].css' // 抽离css的输出目录和名称
        }),
        ],
    });
export default prodConfig;</code></pre> 
<p>完成以上步骤后，Webpack会把样式从JavaScript bundle中提取出来，并生成单独的CSS文件。</p> 
<p><img alt="" height="152" src="https://images2.imgbox.com/cb/88/rsiM2vPl_o.png" width="373"></p> 
<h3 id="3%E3%80%81tree-shaking%E6%B8%85%E7%90%86%E6%9C%AA%E5%BC%95%E7%94%A8%E7%9A%84js">3、tree-shaking清理未引用的js</h3> 
<p>        tree-shaking <span style="color:#333333;">的字面意思是树摇，伴随着摇树这个动作，树上的枯枝败叶都会被摇下来。</span>是指通过静态代码分析来识别和删除 JavaScript 中未被使用的未引用代码（通常是未被导入或调用的代码）。这种优化技术有助于减小最终打包后的文件大小，因为它能够消除那些未被使用的模块、变量、函数或方法。</p> 
<div> 
 <span style="color:#333333;">在 </span> 
 <span style="color:#333333;">src/components </span> 
 <span style="color:#333333;">目录下新增 </span> 
 <span style="color:#333333;">Demo1.tsx </span> 
 <span style="color:#333333;">、 </span> 
 <span style="color:#333333;">Demo2.tsx </span> 
 <span style="color:#333333;">两个组件：</span> 
</div> 
<div></div> 
<p><span style="color:#333333;">Demo1.tsx：</span></p> 
<pre><code class="language-javascript">import React from "react";
function Demo1() {
    return &lt;h3&gt;我是Demo1组件&lt;/h3&gt;
}
export default Demo1</code></pre> 
<p><span style="color:#333333;">Demo2.tsx：</span></p> 
<pre><code class="language-javascript">import React from "react";
function Demo2() {
    return &lt;h3&gt;我是Demo2组件&lt;/h3&gt;
}
export default Demo2</code></pre> 
<div> 
 <span style="color:#333333;">在 </span> 
 <span style="color:#333333;">src/components </span> 
 <span style="color:#333333;">目录下新增 </span> 
 <span style="color:#333333;">index.ts </span> 
 <span style="color:#333333;">： </span> 
</div> 
<pre><code class="language-javascript">export { default as Demo1 } from './Demo1'
export { default as Demo2 } from './Demo2'</code></pre> 
<div> 
 <span style="color:#333333;">在 </span> 
 <span style="color:#333333;">App.tsx </span> 
 <span style="color:#333333;">中引入两个组件，但只使用 </span> 
 <span style="color:#333333;">Demo1 </span> 
 <span style="color:#333333;">组件：</span> 
</div> 
<pre><code class="language-javascript">import { Demo1, Demo2 } from '@/components'
    function App() {
        return &lt;&gt;
        &lt;Demo1 /&gt;
    &lt;/&gt;
}
export default App</code></pre> 
<p>执行程序，<span style="color:#333333;">在 main.js </span><span style="color:#333333;">中</span><span style="color:#333333;">只搜索到了 </span><span style="color:#333333;">Demo1 </span><span style="color:#333333;">，</span><span style="color:#333333;">Demo2 </span><span style="color:#333333;">就被 </span><span style="color:#333333;">tree-shaking 删除掉了。</span></p> 
<h3 id="4%E3%80%81tree-shaking%E6%B8%85%E7%90%86%E6%9C%AA%E5%BC%95%E7%94%A8%E7%9A%84css">4、tree-shaking清理未引用的css</h3> 
<p>和清除JS类似，这个树摇会清除掉不需要的css样式，安装依赖：</p> 
<blockquote> 
 <div> 
  <span style="color:#333333;">pnpm i purgecss-webpack-plugin glob-all </span> 
  <span style="color:#0000cc;">-D </span> 
 </div> 
</blockquote> 
<div> 
 <span style="color:#333333;">修改 </span> 
 <span style="color:#333333;">webpack.prod.ts </span> 
 <span style="color:#333333;">： </span> 
</div> 
<pre><code class="language-javascript">import MiniCssExtractPlugin from 'mini-css-extract-plugin'
const globAll = require('glob-all')
const { PurgeCSSPlugin } = require('purgecss-webpack-plugin')
const prodConfig: Configuration = merge(baseConfig, {
    // ...
    plugins: [
        // 抽离css插件
        new MiniCssExtractPlugin({
            filename: 'static/css/[name].[contenthash:8].css'
        }),
        new PurgeCSSPlugin({
            paths: globAll.sync(
                [`${path.join(__dirname, '../src')}/**/*`, path.join(__dirname,
                    '../public/index.html')],
                {
                    nodir: true
                }
            ),
            // 用 only 来指定 purgecss-webpack-plugin 的入口
            only: ["dist"],
            safelist: {
                standard: [/^ant-/] // 过滤以ant-开头的类名，哪怕没用到也不删除
            }
        }),
    ]
})</code></pre> 
<h3 id="5%E3%80%81%E8%B5%84%E6%BA%90%E6%87%92%E5%8A%A0%E8%BD%BD">5、资源懒加载</h3> 
<p>        资源懒加载指的是将某些模块或资源延迟加载到应用程序。资源懒加载的作用主要在于提高应用程序的性能、减少加载时间，并允许按需加载模块和其他资源，从而提升用户体验。</p> 
<div> 
 <span style="color:#333333;">新建 </span> 
 <span style="color:#333333;">src/components/LazyDemo.tsx </span> 
 <span style="color:#333333;">： </span> 
</div> 
<div> 
 <pre><code class="language-javascript">import React from "react";
function LazyDemo() {
    return &lt;h3&gt;我是懒加载组件组件&lt;/h3&gt;
}
export default LazyDemo</code></pre> 
 <div> 
  <span style="color:#333333;">修改 </span> 
  <span style="color:#333333;">App.tsx </span> 
  <span style="color:#333333;">： </span> 
 </div> 
 <div></div> 
</div> 
<pre><code class="language-javascript">import React, { lazy, Suspense, useState } from 'react'
const LazyDemo = lazy(() =&gt; import('@/components/LazyDemo')) // 使用import语法配合react的Lazy动态引入资源
function App() {
    const [show, setShow] = useState(false)
    // 点击事件中动态引入css, 设置show为true
    const handleOnClick = () =&gt; {
        import('@/App.css')
        setShow(true)
    }
    return (
        &lt;&gt;
            &lt;h2 onClick={handleOnClick}&gt;展示&lt;/h2&gt;
            {/* show为true时加载LazyDemo组件 */}
            {show &amp;&amp; &lt;Suspense fallback={null}&gt;&lt;LazyDemo /&gt;&lt;/Suspense&gt;}
        &lt;/&gt;
    )
}
export default App</code></pre> 
<div> 
 <span style="color:#333333;">点击展示时，才会加载 </span> 
 <span style="color:#333333;">app.css </span> 
 <span style="color:#333333;">和 </span> 
 <span style="color:#333333;">LazyDemo </span> 
 <span style="color:#333333;">的资源。</span> 
</div> 
<div> 
 <img alt="" height="551" src="https://images2.imgbox.com/09/09/gShDm0Ls_o.png" width="894"> 
</div> 
<h3 id="6%E3%80%81%E8%B5%84%E6%BA%90%E9%A2%84%E5%8A%A0%E8%BD%BD">6、资源预加载</h3> 
<p>        预加载可以确保关键资源在用户需要时已经存在，从而加快页面响应速度，对于一些异步加载的内容，可以在页面加载完成之前预先获取，以便在需要时立即使用。</p> 
<div> 
 <div> 
  <span style="color:#333333;">在 </span> 
  <span style="color:#333333;">src/components </span> 
  <span style="color:#333333;">目录下新建 </span> 
  <span style="color:#333333;">PreloadDemo.tsx </span> 
  <span style="color:#333333;">、 </span> 
  <span style="color:#333333;">PreFetchDemo.tsx </span> 
  <span style="color:#333333;">：</span> 
 </div> 
</div> 
<pre><code class="language-javascript">// src/components/PreFetchDemo.tsx
import React from "react";
function PreFetchDemo() {
    return &lt;h3&gt;我是PreFetchDemo组件&lt;/h3&gt;
}
export default PreFetchDemo</code></pre> 
<div> 
 <div> 
  <span style="color:#333333;">在 </span> 
  <span style="color:#333333;">import </span> 
  <span style="color:#333333;">引入动态资源时使用 webpack </span> 
  <span style="color:#333333;">的魔法注释，</span> 
  <span style="color:#333333;">修改 App.tsx </span> 
  <span style="color:#333333;">：</span> 
 </div> 
</div> 
<pre><code class="language-javascript">import React, { lazy, Suspense, useState } from 'react'
// prefetch
const PreFetchDemo = lazy(() =&gt; import(
    /* webpackChunkName: "PreFetchDemo" */
    /*webpackPrefetch: true*/
    '@/components/PreFetchDemo'
))
function App() {
    const [show, setShow] = useState(false)
    const onClick = () =&gt; {
        setShow(true)
    }
    return (
        &lt;&gt;
            &lt;h2 onClick={onClick}&gt;展示&lt;/h2&gt;
            {/* show为true时加载组件 */}
            {show &amp;&amp; (
                &lt;&gt;
                    &lt;Suspense fallback={null}&gt;&lt;PreloadDemo /&gt;&lt;/Suspense&gt;
                    &lt;Suspense fallback={null}&gt;&lt;PreFetchDemo /&gt;&lt;/Suspense&gt;
                &lt;/&gt;
            )}
        &lt;/&gt;
    )
}
export default App</code></pre> 
<p>运行后点击展示</p> 
<p><img alt="" height="551" src="https://images2.imgbox.com/72/23/HRY0PQR6_o.png" width="894"></p> 
<h3 id="7%E3%80%81gzip%E5%8E%8B%E7%BC%A9">7、gzip压缩</h3> 
<p>        webpack构建过程中可以自动对文件进行gzip压缩，从而减小文件大小，提高页面加载速度。</p> 
<p>安装依赖：</p> 
<blockquote> 
 <div> 
  <span style="color:#333333;">pnpm i compression-webpack-plugin </span> 
  <span style="color:#0000cc;">-D </span> 
 </div> 
</blockquote> 
<div> 
 <span style="color:#333333;">修改 </span> 
 <span style="color:#333333;">webpack.prod.ts </span> 
 <span style="color:#333333;">： </span> 
</div> 
<pre><code class="language-javascript">const glob = require('glob')
const CompressionPlugin = require('compression-webpack-plugin')
module.exports = {
    // ...
    plugins: [
    // ...
        new CompressionPlugin({
            test: /.(js|css)$/, // 只生成css,js压缩文件
            filename: '[path][base].gz', // 文件命名
            algorithm: 'gzip', // 压缩格式,默认是gzip
            threshold: 10240, // 只有大小大于该值的资源会被处理。默认值是 10k
            minRatio: 0.8 // 压缩率,默认值是 0.8
        })
    ]
}</code></pre> 
<p>运行程序后，在JS的目录下回生成一个.gz结尾的文件。</p> 
<p><img alt="" height="268" src="https://images2.imgbox.com/69/c0/qZLZ7NI5_o.png" width="365"></p> 
<h2 id="%E6%80%BB%E7%BB%93%EF%BC%9A">总结：</h2> 
<p>        最后，一个基本的脚手架就搭建完成了。当然本文也有许多不完善的地方，后续我会不断完善优化该项目，希望可以通过本文让您对webpack工具有一个更加深入和全面的认识，以便于应对以后项目中配置更改。如果您发现本文中有错误的地方，欢迎评论以便及时更正！！！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/24a6a57548beb678b5ae880f67a9e78a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">OCR--基于Tesseract详细教程（python）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/96ffdd9f88a2cf68f45efceac3dff01f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">语音情感识别基本原理及应用场景-python（课设报告）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>