<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;进阶】深入STL之list：模拟实现深入理解List与迭代器 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/8af3c88dcd77190f569873f042804e54/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;进阶】深入STL之list：模拟实现深入理解List与迭代器">
  <meta property="og:description" content="📝个人主页🌹：Eternity._
⏩收录专栏⏪：C&#43;&#43; “ 登神长阶 ”
🤡往期回顾🤡：初步了解 list
🌹🌹期待您的关注 🌹🌹
❀STL之list 📒1. list的基本结构📕2. list的模拟实现🌈构造函数🌞析构函数🌙拷贝构造函数⭐赋值运算符重载 📚3. list的迭代器🍂迭代器的基本结构🍁迭代器的运算符重载🌸list的迭代器 📙4. list的const迭代器🎩方法一🎈方法二 📜5. 统一的方式访问STL容器中的元素📔6. list与vector的对比📖7. 总结补充💧补充：insert和erase的模拟实现🔥总结 在软件开发中，数据结构和算法的选择与实现是每一个开发者都必须面对的问题。标准模板库（STL）为我们提供了一系列高效且通用的数据结构和算法模板，极大地简化了C&#43;&#43;编程中的许多常见任务。然而，了解这些数据结构和算法背后的实现原理，不仅有助于我们更深入地理解STL，还能提升我们的编程能力和解决问题的能力。
前言： 在STL中，list是一种双向链表，它支持在序列的任何位置进行快速插入和删除操作。与此同时，迭代器是STL中非常重要的一个概念，它使得我们能够以统一的方式遍历和访问STL容器中的元素。在深入了解STL的过程中，模拟实现list和迭代器无疑是一个极有价值的学习过程。
本节我们将从基本的链表结构开始，逐步构建出完整的list类，并实现相应的迭代器类。
📒1. list的基本结构 list是一个个带头双向循环链表，这意味着每个元素（通常称为节点）都有两个指针：一个指向前一个元素，另一个指向后一个元素，因此我们需要单独再定义一个类来表示节点结构，每个节点再串联起来构成list
节点定义（示例）：
template&lt;class T&gt; struct list_node { T _data; list_node&lt;T&gt;* _next; list_node&lt;T&gt;* _prev; list_node(const T&amp; x = T()) :_data(x) ,_next(nullptr) ,_prev(nullptr) {} }; 而在构建list时，我们成员变量只需要一个头节点。
list定义（示例）：
template&lt;class T&gt; struct list { typedef list_node&lt;T&gt; Node; public: // 构造函数等可能的其他成员函数... private: Node* _head; }; 📕2. list的模拟实现 注意：关于erase和insert这两个函数的模拟我们依然作为补充放在末尾">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-08T10:00:00+08:00">
    <meta property="article:modified_time" content="2024-06-08T10:00:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;进阶】深入STL之list：模拟实现深入理解List与迭代器</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>📝个人主页🌹：<a href="https://blog.csdn.net/EterNity_TiMe_?type=blog">Eternity._</a><br> ⏩收录专栏⏪：<a href="http://t.csdnimg.cn/rM7cw" rel="nofollow">C++ “ 登神长阶 ”</a><br> 🤡往期回顾🤡：<a href="http://t.csdnimg.cn/Jn2vg" rel="nofollow">初步了解 list</a><br> 🌹🌹期待您的关注 🌹🌹</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/c1/37/3ILWpNp3_o.gif" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/93/15/Ym1b3UX2_o.gif" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/7e/aa/Zuqnto3j_o.gif" alt="在这里插入图片描述"><br> </p> 
<div class="toc"> 
 <h4>❀STL之list</h4> 
 <ul><li><a href="#1_list_20" rel="nofollow">📒1. list的基本结构</a></li><li><a href="#2_list_56" rel="nofollow">📕2. list的模拟实现</a></li><li><ul><li><a href="#_58" rel="nofollow">🌈构造函数</a></li><li><a href="#_78" rel="nofollow">🌞析构函数</a></li><li><a href="#_104" rel="nofollow">🌙拷贝构造函数</a></li><li><a href="#_121" rel="nofollow">⭐赋值运算符重载</a></li></ul> 
  </li><li><a href="#3_list_152" rel="nofollow">📚3. list的迭代器</a></li><li><ul><li><a href="#_155" rel="nofollow">🍂迭代器的基本结构</a></li><li><a href="#_173" rel="nofollow">🍁迭代器的运算符重载</a></li><li><a href="#list_231" rel="nofollow">🌸list的迭代器</a></li></ul> 
  </li><li><a href="#4_listconst_259" rel="nofollow">📙4. list的const迭代器</a></li><li><ul><li><a href="#_262" rel="nofollow">🎩方法一</a></li><li><a href="#_291" rel="nofollow">🎈方法二</a></li></ul> 
  </li><li><a href="#5_STL_357" rel="nofollow">📜5. 统一的方式访问STL容器中的元素</a></li><li><a href="#6_listvector_416" rel="nofollow">📔6. list与vector的对比</a></li><li><a href="#7__428" rel="nofollow">📖7. 总结补充</a></li><li><ul><li><a href="#inserterase_429" rel="nofollow">💧补充：insert和erase的模拟实现</a></li><li><a href="#_479" rel="nofollow">🔥总结</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<blockquote> 
 <p>在软件开发中，<strong>数据结构和算法的选择与实现是每一个开发者都必须面对的问题</strong>。标准模板库（STL）为我们提供了一系列高效且通用的数据结构和算法模板，极大地简化了C++编程中的许多常见任务。然而，<strong>了解这些数据结构和算法背后的实现原理，不仅有助于我们更深入地理解STL，还能提升我们的编程能力和解决问题的能力</strong>。</p> 
</blockquote> 
<p><strong>前言：</strong> 在STL中，<strong>list是一种双向链表，它支持在序列的任何位置进行快速插入和删除操作</strong>。与此同时，<strong>迭代器是STL中非常重要的一个概念，它使得我们能够以统一的方式遍历和访问STL容器中的元素</strong>。在深入了解STL的过程中，模拟实现list和迭代器无疑是一个极有价值的学习过程。</p> 
<blockquote> 
 <p><strong>本节我们将从基本的链表结构开始，逐步构建出完整的list类，并实现相应的迭代器类。</strong></p> 
</blockquote> 
<hr> 
<h2><a id="1_list_20"></a>📒1. list的基本结构</h2> 
<p><img src="https://images2.imgbox.com/b1/a2/GPqAHN7E_o.png" alt="在这里插入图片描述"><br> <strong>list是一个个带头双向循环链表，这意味着每个元素（通常称为节点）都有两个指针：一个指向前一个元素，另一个指向后一个元素，因此我们需要单独再定义一个类来表示节点结构，每个节点再串联起来构成list</strong></p> 
<p><strong>节点定义（示例）：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">list_node</span>
<span class="token punctuation">{<!-- --></span>
	T _data<span class="token punctuation">;</span>
	list_node<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> _next<span class="token punctuation">;</span>
	list_node<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> _prev<span class="token punctuation">;</span>

	<span class="token function">list_node</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x <span class="token operator">=</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_data</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
		<span class="token punctuation">,</span><span class="token function">_next</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token punctuation">,</span><span class="token function">_prev</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>而在构建list时，我们成员变量只需要一个头节点。</strong></p> 
<p><strong>list定义（示例）：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">list</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">typedef</span> list_node<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> Node<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token comment">// 构造函数等可能的其他成员函数... </span>
<span class="token keyword">private</span><span class="token operator">:</span>
	Node<span class="token operator">*</span> _head<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<hr> 
<h2><a id="2_list_56"></a>📕2. list的模拟实现</h2> 
<blockquote> 
 <p><strong>注意：关于<code>erase</code>和<code>insert</code>这两个函数的模拟我们依然作为补充放在末尾</strong></p> 
</blockquote> 
<h3><a id="_58"></a>🌈构造函数</h3> 
<p><strong>在拥有一个list我们只需要将它的头节点初始化一下</strong></p> 
<p><strong>list构造（示例）：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">empty_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	_head <span class="token operator">=</span> <span class="token keyword">new</span> Node<span class="token punctuation">;</span>
	_head<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> _head<span class="token punctuation">;</span>
	_head<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> _head<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 无参构造</span>
<span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">empty_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h3><a id="_78"></a>🌞析构函数</h3> 
<p>关于析构函数，我们需要的是将所有节点一 一释放就ok啦!</p> 
<p><strong>在模拟析构函数之前，不得不先介绍一下<code>clear</code>这个函数，因为<code>clear</code>可以删除出头节点以外的所有节点，我们可以利用这一点帮助我们优化析构函数</strong></p> 
<p><strong>list析构（示例）：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 依次清除节点</span>
	itetator it <span class="token operator">=</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 稍后会提到迭代器的模拟</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>it <span class="token operator">!=</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		it <span class="token operator">=</span> <span class="token function">erase</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>	
<span class="token punctuation">}</span>

<span class="token operator">~</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除出头节点以外的所有节点</span>
	<span class="token keyword">delete</span> _head<span class="token punctuation">;</span> <span class="token comment">// 单独删除一下头节点</span>
	_head <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h3><a id="_104"></a>🌙拷贝构造函数</h3> 
<p>在学习list时，我们发现list不会因为空间不够而需要扩容，因此在使用模拟list时，不用考虑是否会发生<code>浅拷贝</code></p> 
<p><strong>list拷贝构造函数（示例）：</strong></p> 
<pre><code class="prism language-cpp"><span class="token comment">//list(const list&lt;T&gt;&amp; lt)</span>
<span class="token function">list</span><span class="token punctuation">(</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lt<span class="token punctuation">)</span> <span class="token comment">// 还未实现const迭代器，先使用常规的</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">empty_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> lt<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">push_back</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// push_back的实现其实是复用insert，文末有补充</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h3><a id="_121"></a>⭐赋值运算符重载</h3> 
<p>这里我们以让后传统写法和现代写法两种方法</p> 
<p><strong>list赋值运算符重载（示例）：</strong></p> 
<pre><code class="prism language-cpp"><span class="token comment">// 传统写法</span>
list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lt<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 先将原来的list清空</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> lt<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">push_back</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 现代写法</span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> tmp<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>_head<span class="token punctuation">,</span> tmp<span class="token punctuation">.</span>_head<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> lt<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">swap</span><span class="token punctuation">(</span>lt<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>在介绍完list基本的结构后，让我们来看看今天的重点：迭代器</strong></p> 
<hr> 
<h2><a id="3_list_152"></a>📚3. list的迭代器</h2> 
<p><strong>在我们模拟实现<code>string</code>，<code>vector</code>时，我们认为迭代器就是一个原生指针，但是在<code>list</code>中迭代器底层不是简单的指针，因此我们要独立定义一个新的类</strong></p> 
<hr> 
<h3><a id="_155"></a>🍂迭代器的基本结构</h3> 
<p><strong>迭代器定义（示例）：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">__list_iterator</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">typedef</span> list_node<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> Node<span class="token punctuation">;</span>
	<span class="token keyword">typedef</span> __list_iterator<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> self<span class="token punctuation">;</span>
	Node<span class="token operator">*</span> _node<span class="token punctuation">;</span>
	
	<span class="token comment">// 构造函数</span>
	<span class="token function">__list_iterator</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> node<span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_node</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>我们将迭代器单独写作一个类，能解决更多的问题，以及避免其他麻烦</strong></p> 
<hr> 
<h3><a id="_173"></a>🍁迭代器的运算符重载</h3> 
<p><strong>因为这些函数和前面差不太多，我们简单看看代码，带过了</strong></p> 
<p><strong>代码（示例）：</strong></p> 
<pre><code class="prism language-cpp">self<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 前置++</span>
<span class="token punctuation">{<!-- --></span>
	_node <span class="token operator">=</span> _node<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

self<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 前置--</span>
<span class="token punctuation">{<!-- --></span>
	_node <span class="token operator">=</span> _node<span class="token operator">-&gt;</span>_prev<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

self <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token comment">// 后置++</span>
<span class="token punctuation">{<!-- --></span>
	self <span class="token function">tmp</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	_node <span class="token operator">=</span> _node<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

self <span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token comment">// 后置--</span>
<span class="token punctuation">{<!-- --></span>
	self <span class="token function">tmp</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	_node <span class="token operator">=</span> _node<span class="token operator">-&gt;</span>_prev<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">!=</span><span class="token punctuation">(</span><span class="token keyword">const</span> self<span class="token operator">&amp;</span> tmp<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> _node <span class="token operator">!=</span> tmp<span class="token punctuation">.</span>_node<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>

<span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">-=</span><span class="token punctuation">(</span><span class="token keyword">const</span> self<span class="token operator">&amp;</span> tmp<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> _node <span class="token operator">-=</span> tmp<span class="token punctuation">.</span>_node<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>而今天着重要强调以下两个运算符重载，因为<code>const</code>和<code>非const</code>下这两个是有区别的：</strong></p> 
<pre><code class="prism language-cpp"><span class="token comment">//可读写</span>
T<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> _node<span class="token operator">-&gt;</span>_data<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//可读写</span>
T<span class="token operator">*</span> <span class="token keyword">operator</span><span class="token operator">-&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>_node<span class="token operator">-&gt;</span>_data<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// it.operator-&gt;()-&gt; 编译器帮我们省略了一个箭头-&gt;  it-&gt;</span>
</code></pre> 
<p>在定义完迭代器类之后，我们可以实现<code>begin()</code>和<code>end()</code>来实现<code>list</code>的<code>范围for</code></p> 
<hr> 
<h3><a id="list_231"></a>🌸list的迭代器</h3> 
<p><strong>迭代器代码（示例）：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">list</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">typedef</span> list_node<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> Node<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">typedef</span> __list_iterator<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> iterator<span class="token punctuation">;</span>
	
	iterator <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//return iterator(_head-&gt;_next); // 匿名对象</span>
		<span class="token keyword">return</span> _head<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	iterator <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//return iterator(_head); // 匿名对象</span>
		<span class="token keyword">return</span> _head<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	Node<span class="token operator">*</span> _head<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p>当然我们这里还没有实现<code>const迭代器</code>很多需要调用<code>const对象</code>的函数还无法使用，那么接下来让我们来模拟实现<code>const迭代器</code>，见证新的神奇</p> 
</blockquote> 
<hr> 
<h2><a id="4_listconst_259"></a>📙4. list的const迭代器</h2> 
<blockquote> 
 <p>关于这个list的const迭代器其实有两种写法，常规的写法就是在定义一个新的<code>const迭代器</code>的类，虽然这样可以解决问题，但是会造成代码的冗余，让操作繁琐。而另一种方法就是在原有的迭代器类上进行修改，让它能具有两个迭代器都能使用的特点</p> 
</blockquote> 
<h3><a id="_262"></a>🎩方法一</h3> 
<p><strong>const迭代器实现（示例）：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">__list_const_iterator</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">typedef</span> list_node<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> Node<span class="token punctuation">;</span>
	<span class="token keyword">typedef</span> __list_const_iterator<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> self<span class="token punctuation">;</span>
	Node<span class="token operator">*</span> _node<span class="token punctuation">;</span>
	
	<span class="token comment">// 构造函数</span>
	<span class="token function">__list_const_iterator</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> node<span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_node</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

	<span class="token comment">//可读不可写</span>
	<span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> _node<span class="token operator">-&gt;</span>_data<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//可读不可写</span>
	<span class="token keyword">const</span> T<span class="token operator">*</span> <span class="token keyword">operator</span><span class="token operator">-&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token operator">&amp;</span>_node<span class="token operator">-&gt;</span>_data<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 可能的其他成员函数... </span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_291"></a>🎈方法二</h3> 
<p><strong>如果我们将这两个差异的内容单独表示出来归于模板中，因为在<code>const与非const之间</code>，无非就是<code>T&amp;，T*上能否读写的区别</code>，不影响其他的函数实现，因此我们可以在模板上加上两个参数</strong></p> 
<table><thead><tr><th>模板参数</th><th>实例化类型</th></tr></thead><tbody><tr><td>Ref</td><td>T&amp;，(const 变量时) const T&amp;</td></tr><tr><td>Ptr</td><td>T*，(const 变量时) const T*</td></tr></tbody></table> 
<p><strong>const迭代器实现（示例）：</strong></p> 
<pre><code class="prism language-cpp"><span class="token comment">// 用一个模板来解决 const与非const</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Ref</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Ptr</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">__list_iterator</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">typedef</span> list_node<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> Node<span class="token punctuation">;</span>
	<span class="token comment">// 会实例化成最匹配的</span>
	<span class="token keyword">typedef</span> __list_iterator<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Ref<span class="token punctuation">,</span> Ptr<span class="token operator">&gt;</span> self<span class="token punctuation">;</span>
	Node<span class="token operator">*</span> _node<span class="token punctuation">;</span>
	
	<span class="token comment">// 构造函数</span>
	<span class="token function">__list_iterator</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> node<span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_node</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	
	Ref <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> _node<span class="token operator">-&gt;</span>_data<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	Ptr <span class="token keyword">operator</span><span class="token operator">-&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token operator">&amp;</span>_node<span class="token operator">-&gt;</span>_data<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 可能的其他成员函数... </span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">list</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">typedef</span> list_node<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> Node<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">typedef</span> __list_iterator<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> T<span class="token operator">&amp;</span><span class="token punctuation">,</span> T<span class="token operator">*</span><span class="token operator">&gt;</span> iterator<span class="token punctuation">;</span>
	<span class="token keyword">typedef</span> __list_const_iterator<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">*</span><span class="token operator">&gt;</span>  const_iterator<span class="token punctuation">;</span>
	
	iterator <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> _head<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	iterator <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> _head<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	const_iterator <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> _head<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	const_iterator <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> _head<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	Node<span class="token operator">*</span> _head<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>关于list的模拟实现我们就讲到这里，让我看看如何以统一的方式遍历和访问STL容器中的元素</strong></p> 
<hr> 
<h2><a id="5_STL_357"></a>📜5. 统一的方式访问STL容器中的元素</h2> 
<p><strong>在完成对list的模拟实现后，我们试着用来遍历和访问list中的元素</strong></p> 
<p><strong>代码实现（示例）：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">print_list</span><span class="token punctuation">(</span><span class="token keyword">const</span> list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> lt<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// list&lt;T&gt;没有实例化话，就并不能去遍历寻找</span>
	<span class="token comment">// 编译器不知道 list&lt;T&gt;::const_iterator 是内嵌类型，还是静态成员变量</span>
	list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>const_iterator it <span class="token operator">=</span> lt<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> lt<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
		<span class="token operator">++</span>it<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">test_list</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> lt<span class="token punctuation">;</span>
	lt<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	lt<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">print_list</span><span class="token punctuation">(</span>lt<span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<p><strong>编译器不知道 list::const_iterator 是内嵌类型，还是静态成员变量，但是如果实例化成<code>int</code>后，有需要一个成员是<code>string</code>的列表这时我们有犯难了，这时我们就要用到<code>typename</code>，<code>typename</code> 就是告诉编译器，这是一个类型，等list实例化之后再去取</strong></p> 
<p><strong>代码实现（示例）：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">print_list</span><span class="token punctuation">(</span><span class="token keyword">const</span> list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lt<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token comment">// typename 就是告诉编译器，这是一个类型，等list实例化之后再去取</span>
	<span class="token keyword">typename</span> <span class="token class-name">list</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>const_iterator it <span class="token operator">=</span> lt<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<p><strong>但是更离谱的来了，这时又有人要求我们打印<code>vector</code>的值，容器都换了我们该怎么办呢？这时模板的作用又双体现出来了，这也体现了模板的本质，让我们能省的活交给编译器完成</strong></p> 
<p><strong>代码实现（示例）：</strong></p> 
<pre><code class="prism language-cpp"><span class="token comment">// 这里直接搞了一个Container来适配容器</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Container</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">print_container</span><span class="token punctuation">(</span><span class="token keyword">const</span> Container<span class="token operator">&amp;</span> con<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">typename</span>  <span class="token class-name">Container</span><span class="token double-colon punctuation">::</span>const_iterator it <span class="token operator">=</span> con<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> con<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
		<span class="token operator">++</span>it<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>它使得我们能够以统一的方式遍历和访问STL容器中的元素</strong></p> 
<hr> 
<h2><a id="6_listvector_416"></a>📔6. list与vector的对比</h2> 
<p><strong>我们可以发现list与之前学的竟然有那么多的差异，我们结合上节学的<code>vector</code>来分析一下它们的差异：<code>vector</code>与<code>list</code>都是STL中非常重要的序列式容器，由于两个容器的底层结构不同，导致其特性以及应用场景不同</strong></p> 
<table><thead><tr><th></th><th>vector</th><th>list</th></tr></thead><tbody><tr><td>底 层 结 构</td><td>动态顺序表，一段连续空间</td><td>带头结点的双向循环链表</td></tr><tr><td>随 机 访 问</td><td>支持随机访问，访问某个元素效率O(1)</td><td>不支持随机访问，访问某个元素效率O(N)</td></tr><tr><td>插 入 和 删 除</td><td>任意位置插入和删除效率低，需要搬移元素，时间复杂度为O(N)，插入时有可能需要增容，</td><td>任意位置插入和删除效率高，不需要搬移元素，时间复杂度为O(1)</td></tr><tr><td>空 间 利 用 率</td><td>底层为连续空间，不容易造成内存碎片，空间利用率高，缓存利用率高</td><td>底层节点动态开辟，小节点容易造成内存碎片，空间利用率低，缓存利用率低</td></tr><tr><td>迭 代 器</td><td>插入删除时触发条件会导致迭代器失效</td><td>删除元素时，只会导致当前迭代器失效，其他迭代器不受影响</td></tr><tr><td>使 用 场 景</td><td>需要高效存储，支持随机访问，不关心插入删除效率</td><td>大量插入和删除操作，不关心随机访问</td></tr></tbody></table> 
<hr> 
<h2><a id="7__428"></a>📖7. 总结补充</h2> 
<h3><a id="inserterase_429"></a>💧补充：insert和erase的模拟实现</h3> 
<p><strong>代码实现（示例）：</strong></p> 
<pre><code class="prism language-cpp"><span class="token comment">// insert会返回插入位置的一个迭代器</span>
iterator <span class="token function">insert</span><span class="token punctuation">(</span>iterator pos<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Node<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
	Node<span class="token operator">*</span> cur <span class="token operator">=</span> pos<span class="token punctuation">.</span>_node<span class="token punctuation">;</span>
	Node<span class="token operator">*</span> prev <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_prev<span class="token punctuation">;</span>

	prev<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
	newnode<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>

	cur<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
	newnode<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> cur<span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token function">iterator</span><span class="token punctuation">(</span>newnode<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 匿名对象</span>
<span class="token punctuation">}</span>
<span class="token comment">// erase会返回删除位置的next节点的迭代器</span>
iterator <span class="token function">erase</span><span class="token punctuation">(</span>iterator pos<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Node<span class="token operator">*</span> cur <span class="token operator">=</span> pos<span class="token punctuation">.</span>_node<span class="token punctuation">;</span>
	Node<span class="token operator">*</span> prev <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_prev<span class="token punctuation">;</span>
	Node<span class="token operator">*</span> next <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
			
	<span class="token keyword">delete</span> cur<span class="token punctuation">;</span>
	prev<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> next<span class="token operator">-&gt;</span>_prev<span class="token punctuation">;</span>
	next<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> prev<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token function">iterator</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 匿名对象</span>
<span class="token punctuation">}</span>
<span class="token comment">// erase和insert的复用</span>
<span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token comment">// 尾插</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">push_front</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token comment">// 头插</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 尾删</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">erase</span><span class="token punctuation">(</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 头删</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">erase</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h3><a id="_479"></a>🔥总结</h3> 
<p>通过本次对STL中list和迭代器模拟实现的探索，我们深入了解了双向链表的基本结构、操作原理以及迭代器在遍历和访问链表元素中的重要作用。<strong>模拟实现的过程不仅让我们对STL中的list容器有了更深刻的理解，也锻炼了我们的编程能力和解决问题的能力</strong></p> 
<blockquote> 
 <ul><li><strong>在模拟实现的过程中，我们学习了如何设计并实现一个双向链表结构，包括节点的定义、链表的插入、删除和遍历等操作。同时，我们也掌握了迭代器的基本概念和实现方法，理解了如何通过迭代器来统一访问和遍历不同的容器类型。</strong></li></ul> 
</blockquote> 
<blockquote> 
 <ul><li><strong>模拟实现STL中的list和迭代器是一个既有趣又富有挑战性的过程。它让我们更加深入地理解了数据结构和算法的基本原理，也为我们日后在实际项目中高效应用STL容器打下了坚实的基础。</strong></li></ul> 
</blockquote> 
<p><strong>最后，感谢大家的耐心阅读和学习。希望本次介绍能够为大家在STL学习和编程实践中提供一些帮助和启示。在未来的学习和工作中，让我们继续深入探索STL的奥秘，不断提升自己的编程能力和解决问题的能力</strong><br> <img src="https://images2.imgbox.com/2e/5c/CTXZbfZL_o.gif" alt="在这里插入图片描述"></p> 
<p><strong>谢谢大家支持本篇到这里就结束了，祝大家天天开心！</strong><br> <img src="https://images2.imgbox.com/01/10/yLj9TKKl_o.gif" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/12838936752d0841728a61498ae4b21f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">探秘大数据的宇宙 —— bigdata-hub项目深度剖析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/55d3930e9ec904a56f97aa85f374049a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【CVE-2024-4577】PHP CGI 远程代码执行漏洞</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>