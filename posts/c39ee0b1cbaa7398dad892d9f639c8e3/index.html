<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>“深入探讨Java中的对象拷贝：浅拷贝与深拷贝的差异与应用“ - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/c39ee0b1cbaa7398dad892d9f639c8e3/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="“深入探讨Java中的对象拷贝：浅拷贝与深拷贝的差异与应用“">
  <meta property="og:description" content="前言：在Java编程中，深拷贝（Deep Copy）与浅拷贝（Shallow Copy）是两个非常重要的概念。它们涉及到对象在内存中的复制方式，对于理解对象的引用、内存管理以及数据安全都至关重要。
✨✨✨这里是秋刀鱼不做梦的BLOG
✨✨✨想要了解更多内容可以访问我的主页秋刀鱼不做梦-CSDN博客
先让我们看一下本文的大致内容：
目录
1.深拷贝与浅拷贝的概念
（1）浅拷贝
（2）深拷贝
2.浅拷贝的实现
3.深拷贝的实现
4.深浅拷贝的作用
浅拷贝的作用：
深拷贝的作用：
1.深拷贝与浅拷贝的概念 ——在了解Java中是如何实现对象的深浅拷贝之前，我们需要先了解一下什么是深拷贝、浅拷贝：
（1）浅拷贝 在浅拷贝中，只复制对象本身，而不复制对象引用的内容。这意味着，如果对象中包含了引用类型的成员变量，那么这些成员变量的引用将会被复制，但是它们仍然指向相同的内存地址。因此，对于引用类型成员变量的修改会影响到原始对象和拷贝对象。
（2）深拷贝 与浅拷贝不同，深拷贝会递归地复制对象及其所有引用的对象，直到所有对象都被复制到一个新的内存地址上。这样，原始对象和拷贝对象完全独立，彼此的修改不会相互影响。
嗯嗯嗯......感觉看了和没看没什么区别，还是不太能理解到底什么是Java中的深浅拷贝，那么我们使用一个生活中的案例来解释一下：
浅拷贝的情景：
——如果你选择了浅拷贝，那么你会简单地把整个礼物篮进行复制，然后送给你的朋友。在这种情况下，你的朋友会得到一个看起来一模一样的礼物篮。然而，当你的朋友拆开礼物篮，他们发现里面的食品和饰品并没有改变，他们是和你的礼物篮里的相同的食品和饰品。
深拷贝的情景：
——相比之下，如果你选择了深拷贝，那么你会仔细地把礼物篮里的每一样东西都复制一份，然后把这些复制品装进一个新的礼物篮里，送给你的朋友。在这种情况下，你的朋友得到的是一个全新的礼物篮，里面的食品和饰品和你的礼物篮里的完全一样。但是，现在他们拥有的是独立于你的礼物篮的新的食品和饰品。
不知道上面的生活案例有没有使你更好的理解Java中的深浅拷贝，如果还是没有，那么直接往下看即可！
大致的了解了什么是Java中的深浅拷贝之后，那么我们又该如何使用代码去实现它们呢？
2.浅拷贝的实现 在Java中，实现浅拷贝通常使用clone()方法。该方法会创建一个新对象，并将原始对象的所有字段值复制到新对象中。但是需要注意的是，对于引用类型的成员变量，仍然是浅拷贝，即复制的是引用而不是对象本身。
下面是在Java中实现浅拷贝的详细步骤：
1.实现Cloneable接口：
class MyClass implements Cloneable { // 类的定义 } 2.重写clone()方法并调用super.clone()：
class MyClass implements Cloneable { // 类的定义 @Override public Object clone() throws CloneNotSupportedException { return super.clone(); } } 3.在使用时捕获CloneNotSupportedException异常：
try { MyClass copy = (MyClass) original.clone(); } catch (CloneNotSupportedException e) { e.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-06T13:57:22+08:00">
    <meta property="article:modified_time" content="2024-06-06T13:57:22+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">“深入探讨Java中的对象拷贝：浅拷贝与深拷贝的差异与应用“</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>        前言：在Java编程中，深拷贝（Deep Copy）与浅拷贝（Shallow Copy）是两个非常重要的概念。它们涉及到对象在内存中的复制方式，对于理解对象的引用、内存管理以及数据安全都至关重要。</strong></p> 
<hr> 
<blockquote> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a4/01/z7EKOoLq_o.jpg"></p> 
 <p><span style="color:#ff9900;"><strong>✨✨✨这里是秋刀鱼不做梦的BLOG</strong></span></p> 
 <p><span style="color:#ff9900;"><strong>✨✨✨想要了解更多内容可以访问我的主页</strong></span><a href="https://blog.csdn.net/2302_80198073?type=blog" title="秋刀鱼不做梦-CSDN博客">秋刀鱼不做梦-CSDN博客</a></p> 
</blockquote> 
<p><span style="color:#a2e043;"><strong>先让我们看一下本文的大致内容：</strong></span></p> 
<p style="text-align:center;"><span style="color:#a2e043;"><strong><img alt="" src="https://images2.imgbox.com/69/bf/8pkyxx85_o.png"></strong></span></p> 
<p></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><strong><a href="#1.%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">1.深拷贝与浅拷贝的概念</a></strong></p> 
<p id="%EF%BC%881%EF%BC%89%E6%B5%85%E6%8B%B7%E8%B4%9D-toc" style="margin-left:80px;"><strong><a href="#%EF%BC%881%EF%BC%89%E6%B5%85%E6%8B%B7%E8%B4%9D" rel="nofollow">（1）浅拷贝</a></strong></p> 
<p id="%EF%BC%882%EF%BC%89%E6%B7%B1%E6%8B%B7%E8%B4%9D-toc" style="margin-left:80px;"><strong><a href="#%EF%BC%882%EF%BC%89%E6%B7%B1%E6%8B%B7%E8%B4%9D" rel="nofollow">（2）深拷贝</a></strong></p> 
<p id="2.%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><strong><a href="#2.%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">2.浅拷贝的实现</a></strong></p> 
<p id="3.%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><strong><a href="#3.%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">3.深拷贝的实现</a></strong></p> 
<p id="4.%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%BD%9C%E7%94%A8-toc" style="margin-left:0px;"><strong><a href="#4.%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%BD%9C%E7%94%A8" rel="nofollow">4.深浅拷贝的作用</a></strong></p> 
<p id="%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9A-toc" style="margin-left:40px;"><strong><a href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9A" rel="nofollow">浅拷贝的作用：</a></strong></p> 
<p id="%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9A-toc" style="margin-left:40px;"><strong><a href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9A" rel="nofollow">深拷贝的作用：</a></strong></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1.%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E6%A6%82%E5%BF%B5"><span style="color:#956fe7;">1.深拷贝与浅拷贝的概念</span></h2> 
<p>        <strong>——在了解Java中是如何实现对象的深浅拷贝之前，我们需要先了解一下什么是深拷贝、浅拷贝：</strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b0/d5/hvZJCLfP_o.jpg"></p> 
<h4 id="%EF%BC%881%EF%BC%89%E6%B5%85%E6%8B%B7%E8%B4%9D"><span style="color:#ffd900;">（1）浅拷贝</span></h4> 
<blockquote> 
 <p><span style="color:#ff9900;"><strong>        </strong></span><span style="color:#ff9900;"><strong>在浅拷贝中，只复制对象本身，而不复制对象引用的内容。这意味着，如果对象中包含了引用类型的成员变量，那么这些成员变量的引用将会被复制，但是它们仍然指向相同的内存地址。因此，对于引用类型成员变量的修改会影响到原始对象和拷贝对象。</strong></span></p> 
</blockquote> 
<h4 id="%EF%BC%882%EF%BC%89%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span style="color:#ffd900;"><strong>（2）深拷贝</strong></span></h4> 
<blockquote> 
 <p>      <span style="color:#ff9900;"><strong>  与浅拷贝不同，深拷贝会递归地复制对象及其所有引用的对象，直到所有对象都被复制到一个新的内存地址上。这样，原始对象和拷贝对象完全独立，彼此的修改不会相互影响。</strong></span></p> 
</blockquote> 
<p><strong>        嗯嗯嗯......感觉看了和没看没什么区别，还是不太能理解到底什么是Java中的深浅拷贝，那么我们使用一个生活中的案例来解释一下：</strong></p> 
<p><span style="color:#38d8f0;"><u><em><strong>浅拷贝的情景：</strong></em></u></span></p> 
<p>        ——如果你选择了浅拷贝，那么你会简单地把整个礼物篮进行复制，然后送给你的朋友。在这种情况下，你的朋友会得到一个看起来一模一样的礼物篮。然而，当你的朋友拆开礼物篮，他们发现里面的食品和饰品并没有改变，他们是和你的礼物篮里的相同的食品和饰品。</p> 
<p></p> 
<p><span style="color:#38d8f0;"><u><em><strong>深拷贝的情景：</strong></em></u></span></p> 
<p>        ——相比之下，如果你选择了深拷贝，那么你会仔细地把礼物篮里的每一样东西都复制一份，然后把这些复制品装进一个新的礼物篮里，送给你的朋友。在这种情况下，你的朋友得到的是一个全新的礼物篮，里面的食品和饰品和你的礼物篮里的完全一样。但是，现在他们拥有的是独立于你的礼物篮的新的食品和饰品。</p> 
<p><span style="color:#a2e043;"><strong>不知道上面的生活案例有没有使你更好的理解Java中的深浅拷贝，如果还是没有，那么直接往下看即可！</strong></span></p> 
<p></p> 
<p><strong>大致的了解了什么是Java中的深浅拷贝之后，那么我们又该如何使用代码去实现它们呢？</strong></p> 
<p></p> 
<h2 id="2.%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AE%9E%E7%8E%B0"><span style="color:#956fe7;">2.浅拷贝的实现</span></h2> 
<p>       <strong> 在Java中，实现浅拷贝通常使用<code>clone()</code>方法。该方法会创建一个新对象，并将原始对象的所有字段值复制到新对象中。但是需要注意的是，对于引用类型的成员变量，仍然是浅拷贝，即复制的是引用而不是对象本身。</strong></p> 
<p></p> 
<p>        <strong><span style="color:#ffd900;">下面是在Java中实现浅拷贝的详细步骤：</span></strong></p> 
<p><span style="color:#38d8f0;"><strong>1.实现<code>Cloneable</code>接口：</strong></span></p> 
<pre><code class="language-java">class MyClass implements Cloneable {
    // 类的定义
}
</code></pre> 
<p><span style="color:#38d8f0;"><strong> 2.重写<code>clone()</code>方法并调用<code>super.clone()</code>：</strong></span></p> 
<pre><code class="language-java">class MyClass implements Cloneable {
    // 类的定义

    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
</code></pre> 
<p><span style="color:#38d8f0;"><strong>3.在使用时捕获<code>CloneNotSupportedException</code>异常：</strong></span></p> 
<pre><code class="language-java">try {
    MyClass copy = (MyClass) original.clone();
} catch (CloneNotSupportedException e) {
    e.printStackTrace();
}
</code></pre> 
<p><span style="color:#38d8f0;"><strong>4.强制转换：由于<code>clone()</code>方法返回的是<code>Object</code>类型，因此在使用时需要进行类型转换。</strong></span></p> 
<pre><code class="language-java">try {
    MyClass copy = (MyClass) original.clone();
} catch (CloneNotSupportedException e) {
    e.printStackTrace();
}
</code></pre> 
<p><strong>       </strong></p> 
<p><strong>       <span style="color:#ff9900;">  这就是实现Java中浅拷贝的四步实现流程，相信你仔细的读完上边的代码之后，对Java中浅拷贝的实现流程已经有了初步的理解了，现在让我们使用一个完整的案例，来实现一下Java中的浅拷贝：</span></strong><span style="color:#ff9900;">    </span></p> 
<pre><code class="language-java">class Person implements Cloneable {
    private String name;
    private Address address;

    public Person(String name, Address address) {
        this.name = name;
        this.address = address;
    }

    // Getter and setter 方法

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}

class Address {
    private String city;
    
    public Address(String city) {
        this.city = city;
    }

    // Getter and setter 方法
}

public class ShallowCopyExample {
    public static void main(String[] args) {
        Address address = new Address("New York");
        Person person1 = new Person("Alice", address);

        try {
            Person person2 = (Person) person1.clone();
            // 输出: true
            System.out.println(person1.getAddress() == person2.getAddress()); 
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre> 
<p><span style="color:#fe2c24;"><strong>以上代码演示了一个浅拷贝的例子。让我来解释一下它的执行过程和输出：</strong></span></p> 
<blockquote> 
 <ol><li> <p>首先，我们定义了两个类：<code>Person</code>和<code>Address</code>。<code>Person</code>类有一个<code>name</code>属性和一个<code>address</code>属性，而<code>Address</code>类只有一个<code>city</code>属性。</p> </li><li> <p>在<code>ShallowCopyExample</code>类的<code>main</code>方法中，我们创建了一个<code>Address</code>对象，表示Alice的地址是"New York"。然后，我们创建了一个<code>Person</code>对象<code>person1</code>，传入了名字"Alice"和上面创建的<code>Address</code>对象。</p> </li><li> <p>接着，我们调用<code>person1.clone()</code>方法进行浅拷贝。由于<code>Person</code>类实现了<code>Cloneable</code>接口并重写了<code>clone()</code>方法，因此它支持克隆操作。在<code>clone()</code>方法内部，我们调用了<code>super.clone()</code>来复制<code>Person</code>对象本身，但是对于<code>address</code>属性，只是复制了其引用，而没有对<code>Address</code>对象进行深度复制。</p> </li><li> <p>输出语句<code>System.out.println(person1.getAddress() == person2.getAddress());</code>比较了<code>person1</code>和<code>person2</code>的<code>address</code>属性是否是同一个对象。由于浅拷贝只是复制了引用，所以<code>person1</code>和<code>person2</code>的<code>address</code>属性指向的是同一个<code>Address</code>对象，因此输出结果为<code>true</code>。</p> </li></ol> 
</blockquote> 
<p><strong>这样我们就大致的了解了在Java中如何去实现对象的浅拷贝了。</strong></p> 
<p></p> 
<h2 id="3.%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AE%9E%E7%8E%B0"><span style="color:#956fe7;"><strong>3.</strong>深拷贝的实现</span></h2> 
<p><strong>        在Java中实现深拷贝相对于浅拷贝来说更为复杂，因为需要确保对象及其引用的所有对象都被复制到新的内存地址上。</strong></p> 
<p><span style="color:#ffd900;"><strong>        </strong></span><span style="color:#ffd900;"><strong>下面是在Java中实现深拷贝的详细流程：</strong></span></p> 
<p><span style="color:#38d8f0;"><strong>1.实现<code>Cloneable</code>接口：同样，为了使用<code>clone()</code>方法，需要确保类实现了<code>Cloneable</code>接口。</strong></span></p> 
<pre><code class="language-java">class MyClass implements Cloneable {
    // 类的定义
}
</code></pre> 
<p><span style="color:#38d8f0;"><strong>2.重写<code>clone()</code>方法：在重写的<code>clone()</code>方法中，除了调用<code>super.clone()</code>来复制对象本身之外，还需要递归地复制所有引用的对象。</strong></span></p> 
<pre><code class="language-java">class MyClass implements Cloneable {
    private AnotherClass anotherObject;

    public MyClass(AnotherClass anotherObject) {
        this.anotherObject = anotherObject;
    }

    // Getter and setter 方法

    @Override
    public Object clone() throws CloneNotSupportedException {
        MyClass clonedObject = (MyClass) super.clone();
        // 对引用类型的成员变量进行深度复制
        clonedObject.anotherObject = (AnotherClass) anotherObject.clone();
        return clonedObject;
    }
}
</code></pre> 
<p><span style="color:#38d8f0;"><strong>3.在引用类型的类中同样实现深拷贝：如果类中有成员变量是引用类型，那么需要在该引用类型的类中同样实现深拷贝。</strong></span></p> 
<pre><code class="language-java">class AnotherClass implements Cloneable {
    // 类的定义

    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
</code></pre> 
<p><span style="color:#38d8f0;"><strong>4.调用<code>clone()</code>方法：现在可以调用<code>clone()</code>方法来获取深拷贝的对象。</strong></span></p> 
<pre><code class="language-java">public class DeepCopyExample {
    public static void main(String[] args) {
        AnotherClass anotherObject = new AnotherClass();
        MyClass original = new MyClass(anotherObject);
        MyClass deepCopy = null;

        try {
            deepCopy = (MyClass) original.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre> 
<p></p> 
<p><strong><span style="color:#ff9900;">        </span><span style="color:#ff9900;">这就是实现Java中深拷贝的四步实现流程，当然，现在让我们使用一个完整的案例，来实现一下Java中的深拷贝：</span></strong><span style="color:#ff9900;">    </span></p> 
<pre><code class="language-java">class Person implements Cloneable {
    private String name;
    private Address address;

    public Person(String name, Address address) {
        this.name = name;
        this.address = address;
    }

    // Getter and setter 方法

    @Override
    protected Object clone() throws CloneNotSupportedException {
        Person clonedPerson = (Person) super.clone();
        clonedPerson.address = (Address) this.address.clone();
        return clonedPerson;
    }
}

class Address implements Cloneable {
    private String city;
    
    public Address(String city) {
        this.city = city;
    }

    // Getter and setter 方法

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}

public class DeepCopyExample {
    public static void main(String[] args) {
        Address address = new Address("New York");
        Person person1 = new Person("Alice", address);

        try {
            Person person2 = (Person) person1.clone();
            // 输出: false
            System.out.println(person1.getAddress() == person2.getAddress()); 
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre> 
<p><span style="color:#fe2c24;"><strong>让我解释一下代码的主要部分：</strong></span></p> 
<blockquote> 
 <ol><li> <p><code>Person</code> 类和 <code>Address</code> 类都实现了 <code>Cloneable</code> 接口，这是为了表明它们可以被克隆。</p> </li><li> <p>在 <code>Person</code> 类中，有一个私有字段 <code>address</code>，类型为 <code>Address</code>。<code>Person</code> 类的构造函数用于初始化这个字段。</p> </li><li> <p><code>Person</code> 类的 <code>clone()</code> 方法首先调用了 <code>super.clone()</code>，这会复制 <code>Person</code> 对象本身。然后，它对 <code>address</code> 字段进行了深拷贝，即创建了一个新的 <code>Address</code> 对象，并将其赋值给 <code>clonedPerson</code> 的 <code>address</code> 字段。</p> </li><li> <p><code>Address</code> 类中的 <code>clone()</code> 方法也是调用了 <code>super.clone()</code>，实现了浅拷贝，因为 <code>Address</code> 类只有一个字段，且该字段为不可变类型。</p> </li><li> <p>在 <code>main()</code> 方法中，首先创建了一个 <code>Address</code> 对象和一个 <code>Person</code> 对象。然后，通过调用 <code>clone()</code> 方法，创建了一个新的 <code>Person</code> 对象 <code>person2</code>，其中包含了新的 <code>Address</code> 对象。</p> </li><li> <p>最后，通过比较 <code>person1</code> 和 <code>person2</code> 的地址字段，可以看到它们不相同，这表明在克隆过程中进行了深拷贝。</p> </li></ol> 
</blockquote> 
<p><strong>这样我们就大致的了解了在Java中如何去实现对象的深拷贝了。</strong></p> 
<p></p> 
<h2 id="4.%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%BD%9C%E7%94%A8"><span style="color:#956fe7;"><strong>4.</strong>深浅拷贝的作用</span></h2> 
<p>        <span style="color:#ffd900;"><strong>了解完了Java中的深浅拷贝之后，那么其有什么用呢？</strong></span></p> 
<h3 id="%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9A"><span style="color:#4da8ee;">浅拷贝的作用：</span></h3> 
<blockquote> 
 <ol><li> <p><strong>节省内存空间：浅拷贝只复制对象本身，不会复制对象引用的内容，因此在某些情况下可以节省内存空间。</strong></p> </li><li> <p><strong>提高对象创建速度：由于浅拷贝只复制对象本身，因此复制过程相对较快。</strong></p> </li><li> <p><strong>适用于不包含引用类型成员变量的对象：如果对象中的成员变量都是基本数据类型或者不需要被复制的对象，那么浅拷贝是一个简单有效的复制方式。</strong></p> </li></ol> 
</blockquote> 
<h3 id="%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9A"><span style="color:#4da8ee;">深拷贝的作用：</span></h3> 
<blockquote> 
 <ol><li> <p><strong>确保对象的独立性：深拷贝会递归地复制对象及其引用的所有对象，从而确保复制后的对象与原始对象完全独立，对复制对象的修改不会影响原始对象。</strong></p> </li><li> <p><strong>数据安全性：在多线程环境下，深拷贝可以确保对象的数据安全性，因为每个线程都可以操作独立的对象，而不会相互影响。</strong></p> </li><li> <p><strong>避免对象共享的副作用：在某些情况下，对象的共享可能会导致意外的副作用，深拷贝可以避免这种情况的发生，保证数据的一致性和可靠性。</strong></p> </li><li> <p><strong>适用于包含引用类型成员变量的对象：如果对象中包含了引用类型的成员变量，并且需要复制所有引用的对象，那么深拷贝是更合适的选择。</strong></p> </li></ol> 
</blockquote> 
<p><strong><span style="color:#a2e043;">        总的来说，浅拷贝适用于简单对象的复制，可以提高性能和节省内存空间，而深拷贝则适用于需要确保对象独立性和数据安全性的情况，尤其是当对象包含引用类型成员变量时。</span></strong></p> 
<p></p> 
<hr> 
<p style="text-align:center;"><span style="color:#38d8f0;"><strong>以上就是本篇文章的全部内容了~~~</strong></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2239713b6330b93442b688fd17ed67a7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android: Null extracted folder for artifact: ResolvedArtifact(xxx 项目编译失败</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/38b8f8547990d7a9607552248e83783f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android基础-AndroidManifest.xml详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>