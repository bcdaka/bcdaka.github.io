<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>新手勇闯LVS - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/3f69dcb12a863a45e8d0eda2871c210b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="新手勇闯LVS">
  <meta property="og:description" content="LVS的原理 LVS是Linux virtual server的缩写，为linux虚拟服务器，是一个虚拟的服务器集群系统。LVS简单工作原理为用户请求LVS VIP，LVS根据转发方式和算法，将请求转发给后端服务器，后端服务器接收到请求，返回给用户。对于用户来说，看不到Web后端具体的应用。
一：LVS 的集群结构和特点 1.1 LVS结构 LVS（Linux Virtual Server）是一种开源的负载均衡解决方案，它的三层结构主要包括前端、中间层和后端。
前端(Load Balancer)：通常部署在服务器集群的外部，负责接收客户端的请求。前端可以是一个IP地址和端口的组合，它将接收到的所有请求分发给后端的服务器群组。
中间件(Pool Manager)：也称为调度器或代理，它隐藏了后端的实际服务器信息，并根据某种策略（如轮询、最少连接数等）动态地选择并分配请求给其中的一个或一组服务器。这是LVS的核心组件，实现了负载均衡功能。
后端(Server Group)：由一组实际处理服务的服务器组成。它们可能是物理机，也可以是虚拟机，或者是通过网络连接的远程服务器。后端服务器不需要直接暴露给客户端，它们只与中间件交互。
1.2 LVS的术语 DS：Director Server。指的是前端负载均衡器节点
RS：Real Server。后端真实的工作服务器
VIP：向外部直接面向用户请求，作为用户请求的目标的IP地址
DIP：Director Server IP，主要用于和内部主机通讯的IP地址
RIP：Real Server IP，后端服务器的IP地址
CIP：Client IP，访问客户端的IP地址
1.3 LVS的集群与分布 1.3.1 系统性能扩展方式 Scale UP：向上扩展,增强
Scale Out：向外扩展,增加设备，调度分配问题，Cluster
1.3.2 集群cluster Cluster: 集群是为了解决某个特定问题将堕胎计算机组合起来形成的单个系统
Cluster常见的三种类型：
LB：LoadBalancing（负载均衡）由多个主机组成，每个主机只承担一部分访问
HA：High Availiablity（高可用）SPOF（single Point Of failure） MTBF:Mean Time Between Failure 平均无故障时间，正常时间 MTTR:Mean Time To Restoration（ repair）平均恢复前时间，故障时间 A=MTBF/（MTBF&#43;MTTR） (0,1)：99%, 99.5%, 99.9%, 99.99%, 99.999% SLA：Service level agreement（服务等级协议）是在一定开销下为保障服务的性能和可用性，服 务提供商与用户间定义的一种双方认可的协定。通常这个开销是驱动提供服务质量的主要因素。在 常规的领域中，总是设定所谓的三个9，四个9来进行表示，当没有达到这种水平的时候，就会有一 些列的惩罚措施，而运维，最主要的目标就是达成这种服务水平。 停机时间又分为两种，一种是计划内停机时间，一种是计划外停机时间，而运维则主要关注计划外 停机时间">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-10T21:09:41+08:00">
    <meta property="article:modified_time" content="2024-08-10T21:09:41+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">新手勇闯LVS</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="LVS%E7%9A%84%E5%8E%9F%E7%90%86">LVS的原理</h2> 
<p>        LVS是Linux virtual server的缩写，为linux虚拟服务器，是一个虚拟的服务器集群系统。LVS简单工作原理为用户请求LVS VIP，LVS根据转发方式和算法，将请求转发给后端服务器，后端服务器接收到请求，返回给用户。对于用户来说，看不到Web后端具体的应用。</p> 
<h2 id="%E4%B8%80%EF%BC%9ALVS%20%E7%9A%84%E9%9B%86%E7%BE%A4%E7%BB%93%E6%9E%84%E5%92%8C%E7%89%B9%E7%82%B9">一：LVS 的集群结构和特点</h2> 
<h3 id="1.1%C2%A0%20LVS%E7%BB%93%E6%9E%84">1.1  LVS结构</h3> 
<p>LVS（Linux Virtual Server）是一种开源的负载均衡解决方案，它的三层结构主要包括前端、中间层和后端。</p> 
<ol><li> <p><strong>前端(Load Balancer)</strong>：通常部署在服务器集群的外部，负责接收客户端的请求。前端可以是一个IP地址和端口的组合，它将接收到的所有请求分发给后端的服务器群组。</p> </li><li> <p><strong>中间件(Pool Manager)</strong>：也称为调度器或代理，它隐藏了后端的实际服务器信息，并根据某种策略（如轮询、最少连接数等）动态地选择并分配请求给其中的一个或一组服务器。这是LVS的核心组件，实现了负载均衡功能。</p> </li><li> <p><strong>后端(Server Group)</strong>：由一组实际处理服务的服务器组成。它们可能是物理机，也可以是虚拟机，或者是通过网络连接的远程服务器。后端服务器不需要直接暴露给客户端，它们只与中间件交互。</p> </li></ol> 
<h3 id="1.2%C2%A0%20LVS%E7%9A%84%E6%9C%AF%E8%AF%AD">1.2  LVS的术语</h3> 
<blockquote> 
 <p>  DS：Director Server。指的是前端负载均衡器节点<br>   RS：Real Server。后端真实的工作服务器<br>   VIP：向外部直接面向用户请求，作为用户请求的目标的IP地址<br>   DIP：Director Server IP，主要用于和内部主机通讯的IP地址<br>   RIP：Real Server IP，后端服务器的IP地址<br>   CIP：Client IP，访问客户端的IP地址</p> 
</blockquote> 
<h3 id="1.3%C2%A0%20LVS%E7%9A%84%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%B8%83">1.3  LVS的集群与分布</h3> 
<h4 id="1.3.1%20%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E6%89%A9%E5%B1%95%E6%96%B9%E5%BC%8F">1.3.1 系统性能扩展方式</h4> 
<blockquote> 
 <p>Scale UP：向上扩展,增强</p> 
 <p>Scale Out：向外扩展,增加设备，调度分配问题，Cluster</p> 
</blockquote> 
<h4 id="1.3.2%20%E9%9B%86%E7%BE%A4cluster">1.3.2 集群cluster</h4> 
<blockquote> 
 <p>Cluster: 集群是为了解决某个特定问题将堕胎计算机组合起来形成的单个系统</p> 
 <p>Cluster常见的三种类型：</p> 
 <p>     LB：LoadBalancing（负载均衡）由多个主机组成，每个主机只承担一部分访问</p> 
 <p>     HA：High Availiablity（高可用）SPOF（single Point Of failure） MTBF:Mean Time Between Failure 平均无故障时间，正常时间 MTTR:Mean Time To Restoration（ repair）平均恢复前时间，故障时间 A=MTBF/（MTBF+MTTR） (0,1)：99%, 99.5%, 99.9%, 99.99%, 99.999% SLA：Service level agreement（服务等级协议）是在一定开销下为保障服务的性能和可用性，服 务提供商与用户间定义的一种双方认可的协定。通常这个开销是驱动提供服务质量的主要因素。在 常规的领域中，总是设定所谓的三个9，四个9来进行表示，当没有达到这种水平的时候，就会有一 些列的惩罚措施，而运维，最主要的目标就是达成这种服务水平。 停机时间又分为两种，一种是计划内停机时间，一种是计划外停机时间，而运维则主要关注计划外 停机时间</p> 
 <p>   HPC：High-performance computing（高性能计算，国家战略资源，不在课程范围内）</p> 
</blockquote> 
<h4 id="1.3.3%20%E5%88%86%E5%B8%83%E5%BC%8F">1.3.3 分布式</h4> 
<blockquote> 
 <p>分布式存储:Ceph，GlusterFs，FastDFS，MogileFs</p> 
 <p>分布式计算:hadoop，Spark</p> 
 <p>分布式常见应用</p> 
 <p>分布式应用-服务按照功能拆分，使用微服务</p> 
 <p>分布式静态资源--静态资源放在不同的存储集群上</p> 
 <p>分布式数据和存储--使用key-value缓存系统</p> 
 <p>分布式计算--对特殊业务使用分布式计算，比如Hadoop集群</p> 
</blockquote> 
<h2 id="1.4%20%E5%8D%81%E7%A7%8DLVS%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">1.4 十种LVS的调度算法</h2> 
<blockquote> 
 <p>1. 轮叫调度 rr<br> 均等地对待每一台服务器，不管服务器上的实际连接数和系统负载</p> 
 <p>2. 加权轮叫 wrr<br> 调度器可以自动问询真实服务器的负载情况，并动态调整权值</p> 
 <p>3. 最少链接 lc<br> 动态地将网络请求调度到已建立的连接数最少的服务器上<br> 如果集群真实的服务器具有相近的系统性能，采用该算法可以较好的实现负载均衡</p> 
 <p>4. 加权最少链接 wlc<br> 调度器可以自动问询真实服务器的负载情况，并动态调整权值<br> 带权重的谁不干活就给谁分配，机器配置好的权重高</p> 
 <p>5. 基于局部性的最少连接调度算法 lblc<br> 这个算法是请求数据包的目标 IP 地址的一种调度算法，该算法先根据请求的目标 IP 地址寻找最近的该目标 IP 地址所有使用的服务器，如果这台服务器依然可用，并且有能力处理该请求，调度器会尽量选择相同的服务器，否则会继续选择其它可行的服务器</p> 
 <p>6. 复杂的基于局部性最少的连接算法 lblcr<br> 记录的不是要给目标 IP 与一台服务器之间的连接记录，它会维护一个目标 IP 到一组服务器之间的映射关系，防止单点服务器负载过高。</p> 
 <p>7. 目标地址散列调度算法 dh<br> 该算法是根据目标 IP 地址通过散列函数将目标 IP 与服务器建立映射关系，出现服务器不可用或负载过高的情况下，发往该目标 IP 的请求会固定发给该服务器。</p> 
 <p>8. 源地址散列调度算法 sh<br> 与目标地址散列调度算法类似，但它是根据源地址散列算法进行静态分配固定的服务器资源。</p> 
 <p>9. 最少期望延迟 sed<br> 不考虑非活动链接，谁的权重大，优先选择权重大的服务器来接收请求，但权重大的机器会比较忙</p> 
 <p>10. 永不排队 nq<br> 无需队列，如果有realserver的连接数为0就直接分配过去</p> 
</blockquote> 
<h2 id="%E4%BA%8C%20LVS-NAT%E7%BB%93%E6%9E%84">二 LVS-NAT结构</h2> 
<h3 id="2.1%20lvs-nat%E5%8E%9F%E7%90%86%E5%9B%BE">2.1 lvs-nat原理图</h3> 
<p><img alt="" height="496" src="https://images2.imgbox.com/ab/8e/aBD0r6u9_o.png" width="891"></p> 
<h3 id="2.2%20lvs-nat%E5%8E%9F%E7%90%86">2.2 lvs-nat原理</h3> 
<p>用户请求LVS到达director，director将请求的报文的目的IP改为RIP，同时将报文的目标端口也改为realserver的相应端口，最后将报文发送到realserver上，realserver将数据返回给director，director再把数据发送给用户</p> 
<blockquote> 
 <p>1.客户端发送访问请求，请求数据包中含有请求来源（cip），访问目标地址（VIP）访问目标端口 （9000port）</p> 
 <p>2.VS服务器接收到访问请求做DNAT把请求数据包中的目的地由VIP换成RS的RIP和相应端口 3.RS1相应请求，发送响应数据包，包中的相应保温为数据来源（RIP1）响应目标（CIP）相应端口 （9000port）</p> 
 <p>4.VS服务器接收到响应数据包，改变包中的数据来源（RIP1--&gt;VIP）,响应目标端口（9000--&gt;80）</p> 
 <p>5.VS服务器把修改过报文的响应数据包回传给客户端</p> 
 <p>6.lvs的NAT模式接收和返回客户端数据包时都要经过lvs的调度机，所以lvs的调度机容易阻塞</p> 
</blockquote> 
<h3 id="2.3%20lvs-nat%E7%89%B9%E6%80%A7">2.3 lvs-nat特性</h3> 
<blockquote> 
 <ul><li>NAT模式修改的是目的ip，直接走的是switch不需要修改mac地址，所以VIP和RIP不需要在同一个网段内</li><li>NAT的包的进出都需要经过LVS，所以LVS可能会成为一个系统的瓶颈问题</li></ul> 
</blockquote> 
<h2 id="%E4%B8%89%EF%BC%9ALVS-TUN%E6%A8%A1%E5%BC%8F">三：LVS-TUN模式</h2> 
<h3 id="3.1%20lvs-tun%E5%8E%9F%E7%90%86%E5%9B%BE">3.1 lvs-tun原理图</h3> 
<p><img alt="" height="509" src="https://images2.imgbox.com/ac/7c/xImDzXpt_o.png" width="903"></p> 
<h3 id="3.2%20lvs-tun%E5%8E%9F%E7%90%86">3.2 lvs-tun原理</h3> 
<p>用户请求LVS到达director，director通过IP-TUN加密技术将请求报文的包封装到一个新的IP包里面，目的IP为VIP(不变)，然后director将报文发送到realserver，realserver基于IP-TUN解密，然后解析出来包的目的为VIP，检测网卡是否绑定了VIP，绑定了就处理这个包，如果在同一个网段，将请求直接返回给用户，否则通过网关返回给用户；如果没有绑定VIP就直接丢掉这个包</p> 
<h3 id="3.3%20lvs-tun%E7%89%B9%E6%80%A7">3.3 lvs-tun特性</h3> 
<blockquote> 
 <p>1.DIP, VIP, RIP都应该是公网地址</p> 
 <p>2.RS的网关一般不能指向DIP</p> 
 <p>.请求报文要经由Director，但响应不能经由Director</p> 
 <p>4.不支持端口映射</p> 
 <p>5.RS的OS须支持隧道功能</p> 
</blockquote> 
<h2 id="%E5%9B%9B%20LVS-FULLNAT%E6%A8%A1%E5%BC%8F">四 LVS-FULLNAT模式</h2> 
<h3 id="4.1%20lvs-fullnat%E5%8E%9F%E7%90%86%E5%9B%BE">4.1 lvs-fullnat原理图</h3> 
<p><img alt="" height="447" src="https://images2.imgbox.com/29/68/ck83hRJq_o.png" width="976"></p> 
<h3 id="4.2%20lvs-fullnat%20%E7%89%B9%E6%80%A7">4.2 lvs-fullnat 特性</h3> 
<blockquote> 
 <p>fullnat：通过同时修改请求报文的源IP地址和目标IP地址进行转发</p> 
 <p>CIP --&gt; DIP</p> 
 <p>VIP --&gt; RIP</p> 
 <p>1.VIP是公网地址，RIP和DIP是私网地址，且通常不在同一IP网络；因此，RIP的网关一般不会指向DIP</p> 
 <p>2.RS收到的请求报文源地址是DIP，因此，只需响应给DIP；但Director还要将其发往Client</p> 
 <p>3.请求和响应报文都经由Director</p> 
 <p>4.支持端口映射</p> 
</blockquote> 
<h2 id="%E4%BA%94%20LVS-DR%E6%A8%A1%E5%BC%8F">五 LVS-DR模式</h2> 
<p>DR：Direct Routing，直接路由，LVS默认模式,应用最广泛,通过为请求报文重新封装一个MAC首部进行 转发，源MAC是DIP所在的接口的MAC，目标MAC是某挑选出的RS的RIP所在接口的MAC地址；源 IP/PORT，以及目标IP/PORT均保持不变</p> 
<h3 id="5.1%20lvs-dr%E5%8E%9F%E7%90%86%E5%9B%BE">5.1 lvs-dr原理图</h3> 
<p><img alt="" height="509" src="https://images2.imgbox.com/8f/94/EG6mRlIL_o.png" width="906"></p> 
<h3 id="5.2%20dr%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86">5.2 dr模式原理</h3> 
<blockquote> 
 <p>1.客户端发送数据帧给vs调度主机帧中内容为客户端IP+客户端的MAC+VIP+VIP的MAC</p> 
 <p>2.VS调度主机接收到数据帧后把帧中的VIP的MAC该为RS1的MAC，此时帧中的数据为客户端IP+客户端 的MAC+VIP+RS1的MAC</p> 
 <p>3.RS1得到2中的数据包做出响应回传数据包，数据包中的内容为VIP+RS1的MAC+客户端IP+客户端IP的 MAC</p> 
</blockquote> 
<h3 id="5.3%20dr%E6%A8%A1%E5%BC%8F%E7%89%B9%E6%80%A7">5.3 dr模式特性</h3> 
<blockquote> 
 <p>1.Director和各RS都配置有VIP</p> 
 <p>2.确保前端路由器将目标IP为VIP的请求报文发往Director</p> 
 <p>3.在前端网关做静态绑定VIP和Director的MAC地址 在RS上使用arptables工具 在RS上修改内核参数以限制arp通告及应答级别</p> 
 <p>4.RS的RIP可以使用私网地址，也可以是公网地址；RIP与DIP在同一IP网络；</p> 
 <p>5.RIP的网关不能指向DIP，以确保响应报文不会经由Director</p> 
 <p>6.RS和Director要在同一个物理网络</p> 
 <p>7.请求报文要经由Director，但响应报文不经由Director，而由RS直接发往Client</p> 
 <p>8.不支持端口映射（端口不能修败） </p> 
 <p>9.RS可使用大多数OS系统</p> 
</blockquote> 
<h2 id="%E5%85%AD%20%E5%9B%9B%E7%A7%8D%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83">六 四种模式的比较</h2> 
<blockquote> 
 <p>一：是否需要VIP和realserver在同一网段<br> DR模式因为只修改包的MAC地址，需要通过ARP广播找到realserver，所以VIP和realserver必须在同一个网段，也就是说DR模式需要先确认这个IP是否只能挂在这个LVS下面；其他模式因为都会修改目的地址为realserver的IP地址，所以不需要在同一个网段内<br> 二：是否需要在realserver上绑定VIP<br> realserver在收到包之后会判断目的地址是否是自己的IP<br> DR模式的目的地址没有修改，还是VIP，所以需要在realserver上绑定VIP<br> IP TUN模式值是对包重新包装了一层，realserver解析后的包的IP仍然是VIP，所以也需要在realserver上绑定VIP</p> 
 <p>三：四种模式的性能比较<br> DR模式、IP TUN模式都是在包进入的时候经过LVS，在包返回的时候直接返回给client；所以二者的性能比NAT高<br> 但TUN模式更加复杂，所以性能不如DR<br> FULLNAT模式不仅更换目的IP还更换了源IP，所以性能比NAT下降10%</p> 
 <p>性能比较：DR&gt;TUN&gt;NAT&gt;FULLNAT</p> 
</blockquote> 
<h2 style="background-color:transparent;">七 实验部分</h2> 
<h3>7.1 lvs-nat模式原理</h3> 
<h4> 7.1.1 实验准备</h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>主机</td><td>IP</td><td>VIP</td><td>角色</td></tr><tr><td>lvs</td><td>192.168.0.100</td><td>172.25.254.vs</td><td>vs</td></tr><tr><td> <p>web1</p> </td><td>192.168.0.10，GW 192.168.0.100</td><td>null</td><td>rs</td></tr><tr><td> <p>web2</p> </td><td>192.168.0.20，GW 192.168.0.100</td><td>null</td><td>rs</td></tr><tr><td>client</td><td>172.25.254.200</td><td></td><td>测试机</td></tr></tbody></table> 
<h4>7.1.2 配置命令</h4> 
<p>开启内核路由功能</p> 
<p><img alt="" height="140" src="https://images2.imgbox.com/9c/04/rj6IsGsU_o.png" width="540"></p> 
<p>在web1和web2开启httpd服务</p> 
<blockquote> 
 <p>[root@webserver2 ~]# dnf install httpd<br> [root@webserver1 ~]# dnf install httpd</p> 
</blockquote> 
<blockquote> 
 <p>[root@webserver1 ~]# echo webserver1 - 192.168.0.10 &gt; /var/www/html/index.html</p> 
 <p>[root@webserver2 ~]# echo webserver2 - 192.168.0.20 &gt; /var/www/html/index.html</p> 
 <p>重启httpd服务</p> 
 <p>[root@webserver1 ~]# systemctl enable  --now httpd</p> 
</blockquote> 
<p>在lvs上安装ipvsadm</p> 
<blockquote> 
 <p>[root@lvs ~]# dnf install ipsvadm</p> 
</blockquote> 
<p>增加调度策略</p> 
<p><img alt="" height="157" src="https://images2.imgbox.com/43/fd/VevLls6m_o.png" width="496"></p> 
<p>测试</p> 
<p><img alt="" height="179" src="https://images2.imgbox.com/63/8e/AmGXbnUO_o.png" width="487"></p> 
<p>修改为权重调用</p> 
<p><img alt="" height="190" src="https://images2.imgbox.com/21/71/dMKINqCq_o.png" width="536"></p> 
<p><img alt="" height="169" src="https://images2.imgbox.com/5e/2e/TVAjS2am_o.png" width="485"></p> 
<h3>7.2 lvs-dr模式的实现</h3> 
<h4>7.2.1 实验准备</h4> 
<p>在nat基础上修改</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>主机名</td><td>IP</td><td>VIP</td><td>角色</td></tr><tr><td>lvs</td><td>192.168.0.50 </td><td>172.25.254.100</td><td>vs</td></tr><tr><td>route</td><td>NAT-eth0:172.25.254.100，仅主机 eth1:192.168.0.100</td><td></td><td></td></tr><tr><td>web1</td><td>192.168.0.10，GW 192.168.0.100</td><td>null</td><td>rs</td></tr><tr><td>web2</td><td>192.168.0.10，GW 192.168.0.100 </td><td>null</td><td>rs</td></tr><tr><td>client</td><td>172.25.254.200 </td><td></td><td>测试机</td></tr></tbody></table> 
<h4>7.2.2 配置命令</h4> 
<p>在route设置内核路由</p> 
<p><img alt="" height="79" src="https://images2.imgbox.com/6d/cb/kZADDFZv_o.png" width="334"></p> 
<p>在lvs和web1，web2设定vip</p> 
<blockquote> 
 <p>[root@lvs ~]# ip a a dev lo 192.168.0.200/32</p> 
 <p>[root@webserver1 ~]# ip a a dev lo 192.168.0.200/32</p> 
 <p>[root@webserver2 ~]# ip a a dev lo 192.168.0.200/32</p> 
</blockquote> 
<p>在web1-2解决响应问题</p> 
<p><img alt="" height="125" src="https://images2.imgbox.com/db/4c/XufzYRfH_o.png" width="1029"></p> 
<p><img alt="" height="163" src="https://images2.imgbox.com/64/52/v9im5QUa_o.png" width="1034"></p> 
<p>在lvs上配置策略</p> 
<p><img alt="" height="184" src="https://images2.imgbox.com/6b/62/ggMieBkf_o.png" width="593"></p> 
<p>测试</p> 
<p><img alt="" height="378" src="https://images2.imgbox.com/c3/3c/5Q7sAqUU_o.png" width="444"></p> 
<h3>7.3 火墙mark标记解决调度问题</h3> 
<h4>7.3.1 实验环境基于DR模式</h4> 
<h4>7.3.2 实验配置</h4> 
<p>在web1-2上安装mod_ssl并重启httpd</p> 
<blockquote> 
 <p>[root@webserver1 ~]# yum install mod_ssl -y</p> 
 <p>[root@webserver1 ~]# systemctl restart httpd<br> [root@webserver2 ~]# yum install mod_ssl -y</p> 
 <p>[root@webserver2 ~]# systemctl restart httpd</p> 
</blockquote> 
<p>设置端口标签</p> 
<p><img alt="" height="186" src="https://images2.imgbox.com/36/2b/iTcahqrw_o.png" width="1200"></p> 
<p>在lvs设置调度策略</p> 
<p><img alt="" height="191" src="https://images2.imgbox.com/28/51/zjx4RLnP_o.png" width="577"></p> 
<p>测试</p> 
<p><img alt="" height="258" src="https://images2.imgbox.com/0e/2f/u9SXPzbd_o.png" width="898"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9cad3718c0e2759e01216e295edcfe29/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java入门基础16：集合框架1（Collection集合体系、List、Set）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5389e0f5c3cf1511e87ee93e13c7c33f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spring之最基础的创建与Bean的存储与获取（还有Maven加载jar包报错的解决方法）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>