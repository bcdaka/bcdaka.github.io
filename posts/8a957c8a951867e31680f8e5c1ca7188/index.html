<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构之通过“ 队列 ”实现的“ 栈 ”功能。 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/8a957c8a951867e31680f8e5c1ca7188/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构之通过“ 队列 ”实现的“ 栈 ”功能。">
  <meta property="og:description" content="🌹个人主页🌹：喜欢草莓熊的bear
🌹专栏🌹：数据结构
前言 本节内容是利用“ 队列 ”先进先出的特点 实现 “ 栈 ” 先进后出。
一、题目 1.1 题目描述： 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。
实现 MyStack 类：
void push(int x) 将元素 x 压入栈顶。int pop() 移除并返回栈顶元素。int top() 返回栈顶元素。boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。 注意：
你只能使用队列的标准操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。 示例：
输入： [&#34;MyStack&#34;, &#34;push&#34;, &#34;push&#34;, &#34;top&#34;, &#34;pop&#34;, &#34;empty&#34;] [[], [1], [2], [], [], []] 输出： [null, null, null, 2, 2, false] 解释： MyStack myStack = new MyStack(); myStack.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-14T23:12:14+08:00">
    <meta property="article:modified_time" content="2024-07-14T23:12:14+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构之通过“ 队列 ”实现的“ 栈 ”功能。</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"><img alt="" height="316" src="https://images2.imgbox.com/2d/8c/SQoUSqYq_o.jpg" width="234"></p> 
<p>                           <span style="color:#956fe7;">🌹<strong>个人主页🌹</strong>：<a class="link-info" href="https://blog.csdn.net/2302_80867815?spm=1010.2135.3001.5421" title="喜欢草莓熊的bear">喜欢草莓熊的bear</a></span></p> 
<p><span style="color:#956fe7;">                           🌹<strong>专栏🌹：<a class="link-info" href="https://blog.csdn.net/2302_80867815/category_12682237.html?spm=1001.2014.3001.5482" title="数据结构">数据结构</a></strong></span></p> 
<p></p> 
<p id="main-toc" style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a0/e5/1430C4Py_o.gif"></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E5%89%8D%E8%A8%80">前言</h2> 
<blockquote> 
 <p>本节内容是利用“ 队列 ”先进先出的特点 实现 “ 栈 ” 先进后出。</p> 
</blockquote> 
<h2 id="%E4%B8%80%E3%80%81"><a id="pandas_16"></a>一、题目</h2> 
<p><img alt="" height="776" src="https://images2.imgbox.com/aa/b4/QQQWtYCh_o.png" width="1200"></p> 
<h3> 1.1 题目描述：</h3> 
<p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）。</p> 
<blockquote> 
 <p>实现 <code>MyStack</code> 类：</p> 
 <ul><li><code>void push(int x)</code> 将元素 x 压入栈顶。</li><li><code>int pop()</code> 移除并返回栈顶元素。</li><li><code>int top()</code> 返回栈顶元素。</li><li><code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul> 
 <p><strong>注意：</strong></p> 
 <ul><li>你只能使用队列的标准操作 —— 也就是 <code>push to back</code>、<code>peek/pop from front</code>、<code>size</code> 和 <code>is empty</code> 这些操作。</li><li>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li></ul> 
</blockquote> 
<p>示例：</p> 
<blockquote> 
 <pre><strong>输入：</strong>
["MyStack", "push", "push", "top", "pop", "empty"]
[[], [1], [2], [], [], []]
<strong>输出：</strong>
[null, null, null, 2, 2, false]

<strong>解释：</strong>
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top(); // 返回 2
myStack.pop(); // 返回 2
myStack.empty(); // 返回 False</pre> 
</blockquote> 
<p><strong>提示：</strong></p> 
<ul><li><code>1 &lt;= x &lt;= 9</code></li><li>最多调用<code>100</code> 次 <code>push</code>、<code>pop</code>、<code>top</code> 和 <code>empty</code></li><li>每次调用 <code>pop</code> 和 <code>top</code> 都保证栈不为空</li></ul> 
<h3> 1.2 分析题目</h3> 
<p>我们要通过队列实现栈，怎么实现呢？我们发现一个队列无论如何都无法实现栈的功能，所以我们就尝试创建两个队列来试试。分别为 empty（为空的队列） 、 noempty（不为空的队列）。我们把noempty的数据导入到empty的数据里面，也就是在两个队列里面进行数据倒换。文字比较抽象，所以接下来看图帮助理解。</p> 
<p><img alt="" height="637" src="https://images2.imgbox.com/b8/62/8ADqZvQb_o.png" width="1200"></p> 
<h2> 二、模拟“ 栈 ”实现的功能</h2> 
<h3>2.1 MyStack* myStackCreate()//初始化</h3> 
<p>根据我们之前对题目的分析可以知道我们要创建两个队列，所以我们就在结构体里面定义两个队列。</p> 
<pre><code class="language-cpp">typedef struct //匿名结构体
{
    Queue s1;//创建两个队列
    Queue s2;

} MyStack;</code></pre> 
<p> 再对里面的结构体的队列进行初始化！，因为我们前面写的队列是基于单链表完成，要动态开辟空间。所以要malloc一下。具体操作如下：</p> 
<pre><code class="language-cpp">MyStack* myStackCreate()//初始化
{
    MyStack* pst = (MyStack* )malloc(sizeof(MyStack));
    if(pst==NULL)
    {
        perror("malloc fail");
        return -1;
    }
    QueueInit(&amp;(pst-&gt;s1));
    QueueInit(&amp;(pst-&gt;s2));

    return pst;
}</code></pre> 
<h3>2.2 myStackPush(MyStack* obj, int x)//插入数据</h3> 
<p>我们要进行插入数据，就要想明白。我们要实现栈的特点 “  后进先出  ”。我们这里插入数据任何一个队列中都是一样的。所以我们分为，当两个队列都是空时，进行随便插入。如果一个队列有数据那就在这个有数据的队列进行继续插入。代码很简单，要理解为什么这样插入。</p> 
<pre><code class="language-cpp">void myStackPush(MyStack* obj, int x)//插入数据
{
    if(!QueueEmpty(&amp;(obj-&gt;s1)))
    {
        QueuePush(&amp;(obj-&gt;s1),x);//如果s1里面有数据就继续进行数据插入
    }
    else
    {
        QueuePush(&amp;(obj-&gt;s2),x);//如果是s1为空那么就向s2里面插入数据
    }

}</code></pre> 
<h3>2.3 myStackPop(MyStack* obj)//删除并且返回栈定元素</h3> 
<p>我们这里要实现删除栈顶元素并返回栈顶元素。我们这里采用了之前用到过的假设法，我们把<span style="color:#fe2c24;"><strong>不为空</strong></span>的队列里面数据倒换到为<span style="color:#fe2c24;"><strong>空的队列，这样我们就只需要把不为空里面的数据进行pop（删除）就可以了，因为还要返回栈顶元素  so 我们要把最后一个数据储存后进行pop在返回栈顶元素。</strong></span></p> 
<p><strong><span style="color:#956fe7;">千万注意要把不为空里面数据pop！！</span></strong></p> 
<pre><code class="language-cpp">int myStackPop(MyStack* obj)//删除并且返回栈定元素
{
    //假设法
    MyStack* empty = &amp;(obj-&gt;s1);
    MyStack* nonempty = &amp;(obj-&gt;s2);
    if(!QueueEmpty(&amp;(obj-&gt;s1)))
    {
        empty = &amp;(obj-&gt;s2);
        nonempty = &amp;(obj-&gt;s1);
    }
    while(QueueSize(nonempty) &gt; 1 )
    {
        QueuePush(empty,QueueFront(nonempty));
        QueuePop(nonempty);
    }
    int ret = QueueFront(nonempty);
     QueuePop(nonempty);

     return ret;
}</code></pre> 
<h3>2.4 myStackTop(MyStack* obj) //获取栈顶元素</h3> 
<p>获取栈顶元素就很简单了，直接返回队列的最后一个数据就可以了。在这之前我们判一下空，不然一个空队列里面都没有数据怎么返回栈顶元素。</p> 
<pre><code class="language-cpp">int myStackTop(MyStack* obj) //获取栈顶元素
{
    if(!QueueEmpty(&amp;obj-&gt;s1))
    {
        return QueueBack(&amp;obj-&gt;s1);
    }
    else
    {
        return QueueBack(&amp;obj-&gt;s2);
    }
}</code></pre> 
<h3>2.5 myStackEmpty(MyStack* obj) //判空</h3> 
<p><span style="color:#956fe7;"><strong>因为判空用到的地方比较多建议早点写他！  </strong></span>很简单我们把两个队列与一下在返回就可以了。</p> 
<pre><code class="language-cpp">return QueueEmpty(&amp;obj-&gt;s1) &amp;&amp; QueueEmpty(&amp;obj-&gt;s2);</code></pre> 
<h3>2.6 myStackFree(MyStack* obj) //销毁</h3> 
<p>销毁我们要小心一点，因为我们不仅仅动态申请了Mystack的空间，我们还动态申请了队列的空间。所以两个队列也要进行销毁。我们直接调用我们之前写的队列销毁函数后，进行free操作。</p> 
<p>还要进行置为空指针。</p> 
<pre><code class="language-cpp">void myStackFree(MyStack* obj) //销毁
{
    QueueDestory(&amp;obj-&gt;s1);
    QueueDestory(&amp;obj-&gt;s2);

    free(obj);
    obj=NULL;
}</code></pre> 
<h2>三、代码展示</h2> 
<pre><code class="language-cpp">typedef int QDataType;

typedef struct QueueNode
{
	struct QueueNode* next;
	QDataType val;
}QNode;

typedef struct Queue 
{
	 QNode* phead;
	 QNode* ptail;
	 int size;
}Queue;

void QueueInit(Queue* pq)
{
	assert(pq);
	pq-&gt;phead = pq-&gt;ptail = NULL;
	pq-&gt;size = 0;
}

void QueueDestory(Queue* pq)
{
	assert(pq);

	QNode* pur = pq-&gt;phead;

	while (pur)
	{
		QNode* cur = pur-&gt;next;
		free(pur);
		pur = cur;
	}

	pq-&gt;phead = pq-&gt;ptail = NULL;
	pq-&gt;size = 0;
}

void QueuePush(Queue* pq, QDataType x)
{
	assert(pq);
	QNode* Newnode = (QNode*)malloc(sizeof(QNode));
	if (Newnode == NULL)
	{
		perror("malloc fail");
		return;
	}
	Newnode-&gt;next = NULL;
	Newnode-&gt;val = x;

	if (pq-&gt;phead==NULL)//空链表
	{
		pq-&gt;phead = pq-&gt;ptail = Newnode;
	}
	else
	{
		pq-&gt;ptail-&gt;next = Newnode;
		pq-&gt;ptail = Newnode;
	}
	pq-&gt;size++;//用来计数
}

void QueuePop(Queue* pq)
{
	assert(pq);
	assert(pq-&gt;phead);

	if (pq-&gt;phead == pq-&gt;ptail)//只有一个节点
	{
		free(pq-&gt;phead);
		pq-&gt;phead = pq-&gt;ptail = NULL;
	}
	else//多个节点
	{
		QNode* tmp = pq-&gt;phead-&gt;next;
		free(pq-&gt;phead);
		pq-&gt;phead = tmp;
	}
	pq-&gt;size--;
}

QDataType QueueFront(Queue* pq)
{
	assert(pq);
	assert(pq-&gt;phead);

	return pq-&gt;phead-&gt;val;
}

QDataType QueueBack(Queue* pq)
{
	assert(pq);
	assert(pq-&gt;ptail);

	return pq-&gt;ptail-&gt;val;
}

int QueueSize(Queue* pq)
{
	assert(pq);

	return pq-&gt;size;
}

bool QueueEmpty(Queue* pq)
{
	assert(pq);

	return pq-&gt;size == 0;
}

typedef struct //匿名结构体
{
    Queue s1;//创建两个队列
    Queue s2;

} MyStack;


MyStack* myStackCreate()//初始化
{
    MyStack* pst = (MyStack* )malloc(sizeof(MyStack));
    if(pst==NULL)
    {
        perror("malloc fail");
        return -1;
    }
    QueueInit(&amp;(pst-&gt;s1));
    QueueInit(&amp;(pst-&gt;s2));

    return pst;
}

void myStackPush(MyStack* obj, int x)//插入数据
{
    if(!QueueEmpty(&amp;(obj-&gt;s1)))
    {
        QueuePush(&amp;(obj-&gt;s1),x);
    }
    else
    {
        QueuePush(&amp;(obj-&gt;s2),x);
    }

}

int myStackPop(MyStack* obj)//删除并且返回栈定元素
{
    //假设法
    MyStack* empty = &amp;(obj-&gt;s1);
    MyStack* nonempty = &amp;(obj-&gt;s2);
    if(!QueueEmpty(&amp;(obj-&gt;s1)))
    {
        empty = &amp;(obj-&gt;s2);
        nonempty = &amp;(obj-&gt;s1);
    }
    while(QueueSize(nonempty) &gt; 1 )
    {
        QueuePush(empty,QueueFront(nonempty));
        QueuePop(nonempty);
    }
    int ret = QueueFront(nonempty);
     QueuePop(nonempty);

     return ret;
}

int myStackTop(MyStack* obj) //获取栈顶元素
{
    if(!QueueEmpty(&amp;obj-&gt;s1))
    {
        return QueueBack(&amp;obj-&gt;s1);
    }
    else
    {
        return QueueBack(&amp;obj-&gt;s2);
    }
}

bool myStackEmpty(MyStack* obj) //判空
{
    return QueueEmpty(&amp;obj-&gt;s1) &amp;&amp; QueueEmpty(&amp;obj-&gt;s2);
}

void myStackFree(MyStack* obj) //销毁
{
    QueueDestory(&amp;obj-&gt;s1);
    QueueDestory(&amp;obj-&gt;s2);

    free(obj);
    obj=NULL;
}</code></pre> 
<hr> 
<h2 id="%E6%80%BB%E7%BB%93"><a id="_45"></a>总结</h2> 
<blockquote> 
 <p>我们这里的代码都是基于队列来实现的，我们要掌握这个倒换数据思路来解题。好了谢谢大家的观看！！下期见ヾ(•ω•`)o</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c51bcfde826a852cc40e4965246dac98/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[UTCTF2020]babymips</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a7b67ec8e13b10ababfc7eca69777183/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43;中链表的底层迭代器实现</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>