<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言：数据结构(单链表) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b46345cd3b8f1838b44ac2ef07e22eb7/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C语言：数据结构(单链表)">
  <meta property="og:description" content="目录 1. 链表的概念及结构2. 实现单链表3. 链表的分类 1. 链表的概念及结构 概念：链表是一种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针链接次序实现的。
链表的结构跟火车车厢相似，淡季时车次的车厢会相应减少，旺季时车次的车厢会额外增加几节。只需要将火车里的某节车厢去掉/加上，不会影响其他车厢，每节厢车都是独立存在的。
车厢是独立存在的，且每节车厢都有车门。想象一下这样的场景，假设每节车厢的车门都是锁上的状态，需要不同的钥匙才能解锁，每次只能携带一把钥匙的情况下如何从车头走到车尾？
最简单的做法：每节车厢⾥都放一把下一节车厢的钥匙。
在链表里，每节“车厢”是什么样的呢？
与顺序表不同的是，链表里的每节“⻋厢”都是独立申请下来的空间，我们称之为“结点/节点”。
节点的组成主要有两个部分：当前节点要保存的数据和保存下一个节点的地址（指针变量）。
图中指针变量plist保存的是第⼀个节点的地址，我们称plist此时指向第⼀个节点，如果我们希望plist指向第⼆个节点时，只需要修改plist保存的内容为0x0012FFA0。
为什么还需要指针变量来保存下一个节点的位置？
链表中每个节点都是独立申请的（即需要插入数据时才去申请一块节点的空间），我们需要通过指针变量来保存下一个节点位置才能从当前节点找到下一个节点。
结合前⾯学到的结构体知识，我们可以给出每个节点对应的结构体代码：
假设当前保存的节点为整型：
struct SListNode { int data; //节点数据 struct SListNode* next; //指针变量⽤保存下⼀个节点的地址 }; 当我们想要保存一个整型数据时，实际是向操作系统申请了一块内存，这个内存不仅要保存整型数据，也需要保存下一个节点的地址（当下一个节点为空时保存的地址为空）。
当我们想要从第一个节点走到最后一个节点时，只需要在前一个节点拿上下一个节点的地址（下一个节点的钥匙）就可以了。
给定的链表结构中，如何实现节点从头到尾的打印？
思考：当我们想保存的数据类型为字符型、浮点型或者其他自定义的类型时，该如何修改？
链式结构在逻辑上是连续的，在物理结构上不一定连续节点一般是从堆上申请的从堆上申请来的空间，是按照一定策略分配出来的，每次申请的空间可能连续，可能不连续 我们可以这样来改善一下代码：
typedef int SLdatatype;//类型重定义 struct SListNode { SLdatatype data; //节点数据 struct SListNode* next; //指针变量⽤保存下⼀个节点的地址 }; 这样一来，如果后续涉及到要存储其他的类型的时候，代码量又比较多的时候，就不需要一个一个的去修改存储的类型了，只需要将typedef后面的类型一键替换就可以了。嘿嘿，是不是很巧妙呀😎
2. 实现单链表 SList.h
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;assert.h&gt; //定义节点结构 typedef int sldatatype; typedef struct SListnode { sldatatype data;//数据 struct SList* next;//指向下一个节点的指针 }Sltnode; //尾插 void Sltpushback(Sltnode** phead, sldatatype x); //打印节点 void Sltprint(Sltnode* phead); //头插 void SltpushFront(Sltnode** pphead, sldatatype x); //尾删 void SltPopBack(Sltnode** pphead); //头删 void SltPopFront(Sltnode** pphead); //查找节点 Sltnode* SltFind(Sltnode* phead, sldatatype x); //指定位置前插入 void SltInsert(Sltnode** pphead, Sltnode* find, sldatatype x); //指定位置后插入 void SltInsertafter(Sltnode* pos, sldatatype x); //删除pos节点 void SltErase(Sltnode** pphead, Sltnode* pos); //删除pos之后的节点 void SltEraseAfer(Sltnode* pos); //销毁链表 void ListDestroy(Sltnode** pphead); SList.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-22T22:21:55+08:00">
    <meta property="article:modified_time" content="2024-04-22T22:21:55+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言：数据结构(单链表)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#1__1" rel="nofollow">1. 链表的概念及结构</a></li><li><a href="#2__45" rel="nofollow">2. 实现单链表</a></li><li><a href="#3__320" rel="nofollow">3. 链表的分类</a></li></ul> 
</div> 
<p></p> 
<h2><a id="1__1"></a>1. 链表的概念及结构</h2> 
<blockquote> 
 <p>概念：链表是一种<strong>物理存储结构上非连续</strong>、非顺序的存储结构，数据元素的<strong>逻辑顺序</strong>是通过链表的<strong>指针链接</strong>次序实现的。<br> <img src="https://images2.imgbox.com/b8/b1/KkA2rmcI_o.png" alt="在这里插入图片描述"><br> 链表的结构跟火车车厢相似，淡季时车次的车厢会相应减少，旺季时车次的车厢会额外增加几节。只需要将火车里的某节车厢去掉/加上，不会影响其他车厢，每节厢车都是独立存在的。<br> 车厢是独立存在的，且每节车厢都有车门。想象一下这样的场景，假设每节车厢的车门都是锁上的状态，需要不同的钥匙才能解锁，每次只能携带一把钥匙的情况下如何从车头走到车尾？<br> 最简单的做法：每节车厢⾥都放一把下一节车厢的钥匙。</p> 
</blockquote> 
<p>在链表里，每节“车厢”是什么样的呢？<br> <img src="https://images2.imgbox.com/e2/59/abGCIrxD_o.png" alt="在这里插入图片描述"><br> 与顺序表不同的是，链表里的每节“⻋厢”都是独立申请下来的空间，我们称之为“结点/节点”。<br> 节点的组成主要有两个部分：<mark>当前节点要保存的数据和保存下一个节点的地址（指针变量）</mark>。<br> 图中指针变量<code>plist</code>保存的是第⼀个节点的地址，我们称<code>plist</code>此时指向第⼀个节点，如果我们希望<code>plist</code>指向第⼆个节点时，只需要修改<code>plist</code>保存的内容为<code>0x0012FFA0</code>。<br> 为什么还需要指针变量来保存下一个节点的位置？<br> 链表中每个节点都是独立申请的（即需要插入数据时才去申请一块节点的空间），我们需要通过指针变量来保存下一个节点位置才能从当前节点找到下一个节点。<br> 结合前⾯学到的结构体知识，我们可以给出每个节点对应的结构体代码：<br> 假设当前保存的节点为整型：</p> 
<pre><code class="prism language-c"><span class="token keyword">struct</span> <span class="token class-name">SListNode</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> data<span class="token punctuation">;</span> <span class="token comment">//节点数据</span>
	<span class="token keyword">struct</span> <span class="token class-name">SListNode</span><span class="token operator">*</span> next<span class="token punctuation">;</span> <span class="token comment">//指针变量⽤保存下⼀个节点的地址</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>当我们想要保存一个整型数据时，实际是向操作系统申请了一块内存，这个内存不仅要保存整型数据，也需要保存下一个节点的地址（当下一个节点为空时保存的地址为空）。<br> 当我们想要从第一个节点走到最后一个节点时，只需要在前一个节点拿上下一个节点的地址（下一个节点的钥匙）就可以了。<br> 给定的链表结构中，如何实现节点从头到尾的打印？<br> <img src="https://images2.imgbox.com/91/54/7DlbC07f_o.png" alt="在这里插入图片描述"><br> 思考：当我们想保存的数据类型为字符型、浮点型或者其他自定义的类型时，该如何修改？</p> 
<ul><li>链式结构在逻辑上是连续的，在物理结构上不一定连续</li><li>节点一般是从堆上申请的</li><li>从堆上申请来的空间，是按照一定策略分配出来的，每次申请的空间可能连续，可能不连续</li></ul> 
<p>我们可以这样来改善一下代码：</p> 
<pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">int</span> SLdatatype<span class="token punctuation">;</span><span class="token comment">//类型重定义</span>
<span class="token keyword">struct</span> <span class="token class-name">SListNode</span>
<span class="token punctuation">{<!-- --></span>
	SLdatatype data<span class="token punctuation">;</span> <span class="token comment">//节点数据</span>
	<span class="token keyword">struct</span> <span class="token class-name">SListNode</span><span class="token operator">*</span> next<span class="token punctuation">;</span> <span class="token comment">//指针变量⽤保存下⼀个节点的地址</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>这样一来，如果后续涉及到要存储其他的类型的时候，代码量又比较多的时候，就不需要一个一个的去修改存储的类型了，只需要将<code>typedef</code>后面的类型一键替换就可以了。嘿嘿，是不是很巧妙呀😎</p> 
<h2><a id="2__45"></a>2. 实现单链表</h2> 
<p><strong><code>SList.h</code></strong></p> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
//定义节点结构
typedef int sldatatype;
typedef struct SListnode
{
	sldatatype data;//数据
	struct SList* next;//指向下一个节点的指针
}Sltnode;
//尾插
void Sltpushback(Sltnode** phead, sldatatype x);
//打印节点
void Sltprint(Sltnode* phead);
//头插
void SltpushFront(Sltnode** pphead, sldatatype x);
//尾删
void SltPopBack(Sltnode** pphead);
//头删
void SltPopFront(Sltnode** pphead);
//查找节点
Sltnode* SltFind(Sltnode* phead, sldatatype x);
//指定位置前插入
void SltInsert(Sltnode** pphead, Sltnode* find, sldatatype x);
//指定位置后插入
void SltInsertafter(Sltnode* pos, sldatatype x);
//删除pos节点
void SltErase(Sltnode** pphead, Sltnode* pos);
//删除pos之后的节点
void SltEraseAfer(Sltnode* pos);
//销毁链表
void ListDestroy(Sltnode** pphead);
</code></pre> 
<p><strong><code>SList.c</code></strong></p> 
<pre><code>#define _CRT_SECURE_NO_WARNINGS
#include "SList.h"
//创建一个节点
Sltnode* SltBuynode(sldatatype x)
{
	Sltnode* newnode = (Sltnode*)malloc(sizeof(Sltnode));
	if (newnode == NULL)
	{
		perror("malloc fail!");
		exit(1);
	}
	newnode-&gt;data = x;
	newnode-&gt;next = NULL;
	return newnode;
}
//尾插
void Sltpushback(Sltnode** pphead, sldatatype x)
{
	assert(pphead);
	//pphead就是指向第一个节点的指针
	//空链表和非空链表两种情况
	Sltnode* newnode = SltBuynode(x);
	if (*pphead == NULL)
	{
		*pphead = newnode;
	}
	else
	{
		//找尾
		Sltnode* ptail = *pphead;
		while (ptail-&gt;next)
		{
			ptail = ptail-&gt;next;
		}
		//此时ptail指向的就是尾节点
		ptail-&gt;next = newnode;
	}
}
//打印节点
void Sltprint(Sltnode* phead)
{
	while (phead != NULL)
	{
		printf("%d-&gt;", phead-&gt;data);
		phead = phead-&gt;next;
	}
	printf("NULL\n");
}
//头插
void SltpushFront(Sltnode** pphead, sldatatype x)
{
	assert(pphead);
	Sltnode* newnode = SltBuynode(x);
	newnode-&gt;next = *pphead;
	*pphead = newnode;
}
//尾删
void SltPopBack(Sltnode** pphead)
{
	//链表不能为空
	assert(pphead &amp;&amp; *pphead);
	//链表只有一个节点
	if ((*pphead)-&gt;next = NULL)//-&gt;的优先级高于*
	{
		free(*pphead);
		*pphead = NULL;
	}
	else
	{
		//链表有多个节点
		Sltnode* prev = *pphead;
		Sltnode* ptail = *pphead;
		while (ptail-&gt;next != NULL)
		{
			prev = ptail;
			ptail = ptail-&gt;next;
		}
		free(ptail);
		ptail = NULL;
		prev-&gt;next = NULL;
	}
}
//头删
void SltPopFront(Sltnode** pphead)
{
	//不能传空指针且链表不能为空
	assert(pphead &amp;&amp; *pphead);
	Sltnode* next = (*pphead)-&gt;next;//-&gt;优先级高于*
	free(*pphead);
	*pphead = next;
}
//查找节点
Sltnode* SltFind(Sltnode* phead, sldatatype x)
{
	while (phead)//等价于phead != NULL
	{
		if (phead-&gt;data == x)
		{
			return phead;
		}
		phead = phead-&gt;next;
	}
	//phead==NULL 
	return NULL;
}
//在指定位置之前插入数据
void SltInsert(Sltnode** pphead, Sltnode* pos, sldatatype x)
{
	assert(pphead &amp;&amp; *pphead);
	assert(pos);
	Sltnode* newnode = SltBuynode(x);
	//当pos为头节点时，说明是头插
	if (pos == *pphead)
	{
		SltpushFront(pphead, x);
	}
	//pos不为头节点
	else
	{
		//找pos前一个节点
		Sltnode* prev = *pphead;
		while (prev-&gt;next != pos)
		{
			prev = prev-&gt;next;
		}
		//prev -&gt; newnode -&gt; pos
		newnode-&gt;next = pos;
		prev-&gt;next = newnode;
	}
}
//在指定位置之后插入数据
void SltInsertafter(Sltnode* pos, sldatatype x)
{
	assert(pos);
	Sltnode* newnode = SltBuynode(x);
	//pos -&gt; newnode -&gt; pos-&gt;next
	newnode-&gt;next = pos-&gt;next;
	pos-&gt;next = newnode;
}
//删除pos节点
void SltErase(Sltnode** pphead, Sltnode* pos)
{
	assert(pphead &amp;&amp; *pphead &amp;&amp; pos);
	//pos是头节点
	if (pos == *pphead)
	{
		//头删
		SltPopFront(pphead);
	}
	else
	{
		//pos不是头节点
		Sltnode* prev = *pphead;
		while (prev-&gt;next != pos)
		{
			prev = prev-&gt;next;
		}
		prev-&gt;next = pos-&gt;next;
		free(pos);
		pos = NULL;
	}
}
//删除pos之后的节点
void SltEraseAfer(Sltnode* pos)
{
	assert(pos &amp;&amp; pos-&gt;next);
	Sltnode* Del = pos-&gt;next;
	pos-&gt;next = Del-&gt;next;
	free(Del);
	Del = NULL;
}
//销毁链表
void ListDestroy(Sltnode** pphead)
{
	assert(pphead &amp;&amp; *pphead);
	while (*pphead)
	{
		Sltnode* pcur = (*pphead)-&gt;next;
		free(*pphead);
		*pphead = pcur;
	}
	*pphead = NULL;
}
</code></pre> 
<p><strong><code>text.c</code></strong></p> 
<pre><code>#define _CRT_SECURE_NO_WARNINGS
#include "SList.h"
void SListTest()
{
	Sltnode* plist = NULL;
	//测试尾插
	Sltpushback(&amp;plist, 1);
	Sltpushback(&amp;plist, 2);
	Sltprint(plist);
	//SLpushback(NULL,5);
	//测试打印节点
	//Sltprint(plist);
	//测试头插
	//SltpushFront(&amp;plist, 6);
	//Sltprint(plist);
	//测试尾删
	//SltPopBack(&amp;plist);
	//Sltprint(plist);
	//测试头删
	//SltPopFront(&amp;plist);
	//Sltprint(plist);
	//测试查找节点
	//Sltnode* find = SltFind(plist, 3);
	//if (find)
	//	printf("找到了!\n");
	//else
	//	printf("没有找到!\n");
	//测试指定位置前插入
	//SltInsert(&amp;plist, find, 7);
	//Sltprint(plist);
	//测试指定位置后插入
	//SltInsertafter(find,8);
	//Sltprint(plist);
	//测试删除pos节点
	//SltErase(&amp;plist, find);
	//Sltprint(plist);
	//测试删除pos之后的节点
	//SltEraseAfer(find);
	//Sltprint(plist);
	//测试销毁链表
	ListDestroy(&amp;plist);
	Sltprint(plist);
}
int main()
{
	SListTest();
	return 0;
}
</code></pre> 
<h2><a id="3__320"></a>3. 链表的分类</h2> 
<p>链表的结构非常多样，以下情况组合起来就有8种（2x2x2）链表结构：<br> <img src="https://images2.imgbox.com/b5/55/Z7myGeTg_o.png" alt="在这里插入图片描述"><br> 链表说明：</p> 
<ol><li>单向或者双向<br> <img src="https://images2.imgbox.com/79/5b/f84kB7Ct_o.png" alt="在这里插入图片描述"></li><li>带头或者不带头<br> <img src="https://images2.imgbox.com/51/19/q25rveeu_o.png" alt="在这里插入图片描述"></li><li>循环或者不循环<br> <img src="https://images2.imgbox.com/b7/0d/8Qfd2WDs_o.png" alt="在这里插入图片描述"><br> 虽然有这么多的链表的结构，但是我们实际中最常用还是两种结构：<mark><strong>单链表</strong> 和 <strong>双向带头循环链表</strong></mark>。</li></ol> 
<blockquote> 
 <ol><li>无头单向非循环链表：结构简单，一般不会单独用来存数据。实际中更多是作为其他数据结<br> 构的子结构，如哈希桶、图的邻接表等等。另外这种结构在笔试⾯试中出现很多。</li><li>带头双向循环链表：结构最复杂，一般用在单独存储数据。实际中使用的链表数据结构，都<br> 是带头双向循环链表。另外这个结构虽然结构复杂，但是使用代码实现以后会发现结构会带<br> 来很多优势，实现反而简单了，后面等我们双向链表代码实现完就知道了。</li></ol> 
</blockquote> 
<hr> 
<p>下期会讲解双向链表的概念和结构以及双向链表代码的实现哟！如果对你有所帮助，别忘了给博主点个小小的赞和关注哟，谢谢宝子们！😽</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/886820a39ad1288a5bf3ce05bba11df4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MyBatisPlus详解(三)lambdaQuery、lambdaUpdate、批量新增、代码生成、Db静态工具、逻辑删除</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4da6230ea231eec7a609ff621e5424bd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Midjourney基础操作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>