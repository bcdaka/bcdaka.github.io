<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>算法沉淀——动态规划之完全背包问题（leetcode真题剖析） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/9c6a1572196720429cb571678affd2e3/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="算法沉淀——动态规划之完全背包问题（leetcode真题剖析）">
  <meta property="og:description" content="算法沉淀——动态规划之完全背包问题 01.【模板】完全背包02.零钱兑换03.零钱兑换 II04.完全平方数 完全背包问题是背包问题的一种变体，与01背包问题不同，它允许你对每种物品进行多次选择。具体来说，给定一个固定容量的背包，一组物品，每个物品有重量和价值，目标是找到在背包容量范围内，使得背包中的物品总价值最大的组合。 相较于01背包问题，完全背包问题允许对每个物品进行多次选择，即每个物品都有无限件可用。
动态规划解法：
定义状态： 通常使用二维数组dp[i][j]表示在前i个物品中，背包容量为j时的最大总价值。
状态转移方程： 考虑第i个物品，可以选择放入背包或者不放入。如果选择放入，那么总价值为dp[i][j-weight[i]] &#43; value[i]，即前i个物品的总价值加上当前物品的价值。如果选择不放入，那么总价值为dp[i-1][j]，即前i-1个物品的总价值。因此，状态转移方程为：
dp[i][j] = max(dp[i-1][j], dp[i][j-weight[i]] &#43; value[i]) 其中，dp[i-1][j]表示不放入第i个物品，dp[i][j-weight[i]] &#43; value[i]表示放入第i个物品。
初始条件： 当i=0时，表示前0个物品，总价值为0；当j=0时，表示背包容量为0，总价值也为0。
遍历顺序： 外层循环遍历物品，内层循环遍历背包容量。
返回结果： 最终结果存储在dp[N][W]中，其中N为物品数量，W为背包容量。
例子：
假设有如下物品：
物品1：重量=2，价值=3 物品2：重量=3，价值=4 物品3：重量=4，价值=5 背包容量为W=8，我们要求解在这个条件下的最大总价值。
按照上述动态规划解法，构建状态转移表如下：
重量/价值 0 1 2 3 4 5 6 7 8 ---------------------------------------------- 物品0 0 0 0 0 0 0 0 0 0 物品1 0 0 3 6 9 12 15 18 21 物品2 0 0 3 6 9 12 15 18 21 物品3 0 0 3 6 9 12 15 18 21 因此，最终结果为dp[3][8] = 21，表示在背包容量为8的情况下，最大总价值为21。这意味着最优解是选择物品1，物品2和物品3各两件放入背包。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-04T22:46:21+08:00">
    <meta property="article:modified_time" content="2024-03-04T22:46:21+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">算法沉淀——动态规划之完全背包问题（leetcode真题剖析）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/e6/58/K9dy8dFk_o.jpg" alt="在这里插入图片描述"></p> 
<p></p> 
<div class="toc"> 
 <h4>算法沉淀——动态规划之完全背包问题</h4> 
 <ul><li><a href="#01_50" rel="nofollow">01.【模板】完全背包</a></li><li><a href="#02_226" rel="nofollow">02.零钱兑换</a></li><li><a href="#03_II_302" rel="nofollow">03.零钱兑换 II</a></li><li><a href="#04_383" rel="nofollow">04.完全平方数</a></li></ul> 
</div> 
<br> 完全背包问题是背包问题的一种变体，与01背包问题不同，它允许你对每种物品进行多次选择。具体来说，给定一个固定容量的背包，一组物品，每个物品有重量和价值，目标是找到在背包容量范围内，使得背包中的物品总价值最大的组合。 
<p></p> 
<p>相较于01背包问题，完全背包问题允许对每个物品进行多次选择，即每个物品都有无限件可用。</p> 
<p><strong>动态规划解法</strong>：</p> 
<ol><li> <p><strong>定义状态：</strong> 通常使用二维数组<code>dp[i][j]</code>表示在前<code>i</code>个物品中，背包容量为<code>j</code>时的最大总价值。</p> </li><li> <p><strong>状态转移方程：</strong> 考虑第<code>i</code>个物品，可以选择放入背包或者不放入。如果选择放入，那么总价值为<code>dp[i][j-weight[i]] + value[i]</code>，即前<code>i</code>个物品的总价值加上当前物品的价值。如果选择不放入，那么总价值为<code>dp[i-1][j]</code>，即前<code>i-1</code>个物品的总价值。因此，状态转移方程为：</p> <pre><code class="prism language-cpp">dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>weight<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> value<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre> <p>其中，<code>dp[i-1][j]</code>表示不放入第<code>i</code>个物品，<code>dp[i][j-weight[i]] + value[i]</code>表示放入第<code>i</code>个物品。</p> </li><li> <p><strong>初始条件：</strong> 当<code>i=0</code>时，表示前0个物品，总价值为0；当<code>j=0</code>时，表示背包容量为0，总价值也为0。</p> </li><li> <p><strong>遍历顺序：</strong> 外层循环遍历物品，内层循环遍历背包容量。</p> </li><li> <p><strong>返回结果：</strong> 最终结果存储在<code>dp[N][W]</code>中，其中<code>N</code>为物品数量，<code>W</code>为背包容量。</p> </li></ol> 
<p><strong>例子</strong>：</p> 
<p>假设有如下物品：</p> 
<pre><code>物品1：重量=2，价值=3
物品2：重量=3，价值=4
物品3：重量=4，价值=5
</code></pre> 
<p>背包容量为<code>W=8</code>，我们要求解在这个条件下的最大总价值。</p> 
<p>按照上述动态规划解法，构建状态转移表如下：</p> 
<pre><code>重量/价值      0   1   2   3   4   5   6   7   8
  ----------------------------------------------
  物品0        0   0   0   0   0   0   0   0   0
  物品1        0   0   3   6   9   12  15  18  21
  物品2        0   0   3   6   9   12  15  18  21
  物品3        0   0   3   6   9   12  15  18  21
</code></pre> 
<p>因此，最终结果为<code>dp[3][8] = 21</code>，表示在背包容量为8的情况下，最大总价值为21。这意味着最优解是选择物品1，物品2和物品3各两件放入背包。</p> 
<h2><a id="01_50"></a>01.【模板】完全背包</h2> 
<p>题目链接：https://www.nowcoder.com/practice/237ae40ea1e84d8980c1d5666d1c53bc?tpId=230&amp;tqId=2032575&amp;ru=/exam/oj&amp;qru=/ta/dynamic-programming/question-ranking&amp;sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D196</p> 
<p><strong>描述</strong></p> 
<p>你有一个背包，最多能容纳的体积是V。</p> 
<p>现在有n种物品，每种物品有任意多个，第i种物品的体积为vi,价值为wi。</p> 
<p>（1）求这个背包至多能装多大价值的物品？</p> 
<p>（2）若背包恰好装满，求至多能装多大价值的物品？</p> 
<p><strong>输入描述</strong>：</p> 
<p>第一行两个整数n和V，表示物品个数和背包体积。</p> 
<p>接下来n行，每行两个vi和wi表示第i种物品的体积和价值。</p> 
<p><code>1≤n,V≤1000</code></p> 
<p><strong>输出描述</strong>：</p> 
<p>输出有两行，第一行输出第一问的答案，第二行输出第二问的答案，如果无解请输出0。</p> 
<p><strong>示例1</strong></p> 
<p>输入：</p> 
<pre><code>2 6
5 10
3 1
</code></pre> 
<p>输出：</p> 
<pre><code>10
2
</code></pre> 
<p><strong>示例2</strong></p> 
<p>输入：</p> 
<pre><code>3 8
3 10
9 1
10 1
</code></pre> 
<p>输出：</p> 
<pre><code>20
0
</code></pre> 
<p>说明：</p> 
<pre><code>无法恰好装满背包。
</code></pre> 
<p><strong>示例3</strong></p> 
<p>输入：</p> 
<pre><code>6 13
13 189
17 360
19 870
14 184
6 298
16 242
</code></pre> 
<p>输出：</p> 
<pre><code>596
189
</code></pre> 
<p>说明：</p> 
<pre><code>可以装5号物品2个，达到最大价值298*2=596，若要求恰好装满，只能装1个1号物品，价值为189.
</code></pre> 
<p><strong>思路</strong></p> 
<p><strong>第一问：</strong></p> 
<ol><li><strong>状态表示：</strong> 
  <ul><li><code>dp[i][j]</code> 表示从前 <code>i</code> 个物品中挑选，总体积不超过 <code>j</code>，所有选法中能挑选出的最大价值。</li></ul> </li><li><strong>状态转移方程：</strong> 
  <ul><li>根据最后一步的状况，分情况讨论： 
    <ul><li>选 <code>0</code> 个第 <code>i</code> 个物品：相当于去前 <code>i - 1</code> 个物品中挑选，总体积不超过 <code>j</code>，最大价值为 <code>dp[i - 1][j]</code>。</li><li>选 <code>1</code> 个第 <code>i</code> 个物品：相当于去前 <code>i - 1</code> 个物品中挑选，总体积不超过 <code>j - v[i]</code>。此时最大价值为 <code>dp[i - 1][j - v[i]] + w[i]</code>。</li></ul> </li><li>综上，状态转移方程为：<code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i])</code>。</li></ul> </li><li><strong>初始化：</strong> 
  <ul><li>多加一行，将第一行初始化为 <code>0</code>，因为什么也不选时，满足体积不小于 <code>j</code> 的情况，此时价值为 <code>0</code>。</li></ul> </li><li><strong>填表顺序：</strong> 
  <ul><li>从上往下填表。</li></ul> </li><li><strong>返回值：</strong> 
  <ul><li>根据状态表示，返回 <code>dp[n][V]</code>。</li></ul> </li></ol> 
<p><strong>第二问：</strong></p> 
<ol><li><strong>状态表示：</strong> 
  <ul><li><code>dp[i][j]</code> 表示从前 <code>i</code> 个物品中挑选，总体积正好等于 <code>j</code>，所有选法中能挑选出来的最大价值。</li></ul> </li><li><strong>状态转移方程：</strong> 
  <ul><li><code>dp[i][j] = max(dp[i - 1][j], dp[i][j - v[i]] + w[i])</code>。</li><li>在使用 <code>dp[i][j - v[i]]</code> 时，需要判断 <code>j &gt;= v[i]</code> 且 <code>dp[i][j - v[i]]</code> 表示的状态是否存在，即 <code>dp[i][j - v[i]] != -1</code>。</li></ul> </li><li><strong>初始化：</strong> 
  <ul><li>多加一行，将第一个格子设置为 <code>0</code>，因为正好能凑齐体积为 <code>0</code> 的背包；但是第一行后面的格子都设置为 <code>-1</code>，因为没有物品，无法满足体积大于 <code>0</code> 的情况。</li></ul> </li><li><strong>填表顺序：</strong> 
  <ul><li>从上往下填表。</li></ul> </li><li><strong>返回值：</strong> 
  <ul><li>由于最后可能凑不成体积为 <code>V</code> 的情况，因此返回之前需要特判一下。</li></ul> </li></ol> 
<p><strong>空间优化：</strong></p> 
<p>对于背包问题，一般都可以使用「滚动数组」来进行空间上的优化，即减少状态表示的维度。</p> 
<p>在 01 背包问题中，优化的结果为：</p> 
<ol><li>删掉所有的横坐标。</li><li>修改一下 <code>j</code> 的遍历顺序。</li></ol> 
<p>这样的优化是因为在计算 <code>dp[i][j]</code> 时，只依赖于上一行 <code>dp[i-1][j]</code> 和 <code>dp[i-1][j-v[i]]</code>，而 <code>dp[i-1][j-v[i]]</code> 在当前行的计算过程中已经被更新过，因此不需要保留整个二维数组。</p> 
<p><strong>代码</strong></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token keyword">int</span> N<span class="token operator">=</span><span class="token number">1002</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span>V<span class="token punctuation">,</span>v<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>w<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> dp<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    cin<span class="token operator">&gt;&gt;</span>n<span class="token operator">&gt;&gt;</span>V<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> cin<span class="token operator">&gt;&gt;</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&gt;&gt;</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>V<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">&gt;=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    cout<span class="token operator">&lt;&lt;</span>dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>

    <span class="token function">memset</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span> dp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>V<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>V<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">&gt;=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> 
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">?</span><span class="token number">0</span><span class="token operator">:</span>dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="02_226"></a>02.零钱兑换</h2> 
<p>题目链接：https://leetcode.cn/problems/coin-change/</p> 
<p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p> 
<p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p> 
<p>你可以认为每种硬币的数量是无限的。</p> 
<p><strong>示例 1：</strong></p> 
<pre><code>输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
</code></pre> 
<p><strong>示例 2：</strong></p> 
<pre><code>输入：coins = [2], amount = 3
输出：-1
</code></pre> 
<p><strong>示例 3：</strong></p> 
<pre><code>输入：coins = [1], amount = 0
输出：0
</code></pre> 
<p><strong>提示：</strong></p> 
<ul><li><code>1 &lt;= coins.length &lt;= 12</code></li><li><code>1 &lt;= coins[i] &lt;= 231 - 1</code></li><li><code>0 &lt;= amount &lt;= 104</code></li></ul> 
<p><strong>思路</strong></p> 
<ol><li><strong>状态表示：</strong> 
  <ul><li><code>dp[i][j]</code> 表示从前 <code>i</code> 个硬币中挑选，总和正好等于 <code>j</code>，所有选法中最少的硬币个数。</li></ul> </li><li><strong>状态转移方程：</strong> 
  <ul><li>在完全背包问题中，每个硬币可以选无限个，因此需要分多种情况讨论： 
    <ul><li>选 <code>0</code> 个第 <code>i</code> 个硬币：相当于去前 <code>i - 1</code> 个硬币中挑选，总和正好等于 <code>j</code>。此时最少的硬币个数为 <code>dp[i - 1][j]</code>。</li><li>选 <code>1</code> 个第 <code>i</code> 个硬币：相当于去前 <code>i - 1</code> 个硬币中挑选，总和正好等于 <code>j - coins[i]</code>。因为挑选了一个第 <code>i</code> 个硬币，此时最少的硬币个数为 <code>dp[i][j - coins[i]] + 1</code>。</li></ul> </li><li>综上，状态转移方程为：<code>dp[i][j] = min(dp[i - 1][j], dp[i][j - coins[i]] + 1)</code>。</li></ul> </li><li><strong>初始化：</strong> 
  <ul><li>初始化第一行，将第一个位置设置为 <code>0</code>，因为正好能凑齐总和为 <code>0</code> 的硬币；其余位置设置为无穷大。</li></ul> </li><li><strong>填表顺序：</strong> 
  <ul><li>从上往下填表。</li></ul> </li><li><strong>返回值：</strong> 
  <ul><li>根据状态表示，返回 <code>dp[n][V]</code>。但要特判一下，因为有可能凑不到。</li></ul> </li></ol> 
<p><strong>代码</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> INF<span class="token operator">=</span><span class="token number">0x3f3f3f3f</span><span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">coinChange</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> n<span class="token operator">=</span>coins<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>amount<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>amount<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>INF<span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>amount<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">&gt;=</span>coins<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>coins<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token operator">&gt;=</span>INF<span class="token operator">?</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">:</span>dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="03_II_302"></a>03.零钱兑换 II</h2> 
<p>题目链接：https://leetcode.cn/problems/coin-change-ii/</p> 
<p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p> 
<p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p> 
<p>假设每一种面额的硬币有无限个。</p> 
<p>题目数据保证结果符合 32 位带符号整数。</p> 
<p><strong>示例 1：</strong></p> 
<pre><code>输入：amount = 5, coins = [1, 2, 5]
输出：4
解释：有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
</code></pre> 
<p><strong>示例 2：</strong></p> 
<pre><code>输入：amount = 3, coins = [2]
输出：0
解释：只用面额 2 的硬币不能凑成总金额 3 。
</code></pre> 
<p><strong>示例 3：</strong></p> 
<pre><code>输入：amount = 10, coins = [10] 
输出：1
</code></pre> 
<p><strong>提示：</strong></p> 
<ul><li><code>1 &lt;= coins.length &lt;= 300</code></li><li><code>1 &lt;= coins[i] &lt;= 5000</code></li><li><code>coins</code> 中的所有值 <strong>互不相同</strong></li><li><code>0 &lt;= amount &lt;= 5000</code></li></ul> 
<p><strong>思路</strong></p> 
<ol><li><strong>状态表示：</strong> 
  <ul><li><code>dp[i][j]</code> 表示从前 <code>i</code> 个硬币中挑选，总和正好等于 <code>j</code>，一共有多少种选法。</li></ul> </li><li><strong>状态转移方程：</strong> 
  <ul><li>在完全背包问题中，每个硬币可以选无限个，因此需要分多种情况讨论： 
    <ul><li>选 <code>0</code> 个第 <code>i</code> 个硬币：相当于去前 <code>i - 1</code> 个硬币中挑选，总和正好等于 <code>j</code>。此时的选法数为 <code>dp[i - 1][j]</code>。</li><li>选 <code>1</code> 个第 <code>i</code> 个硬币：相当于去前 <code>i - 1</code> 个硬币中挑选，总和正好等于 <code>j - coins[i]</code>。因为挑选了一个第 <code>i</code> 个硬币，此时的选法数为 <code>dp[i][j - coins[i]] + 1</code>。</li></ul> </li><li>综上，状态转移方程为：<code>dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i]] + 1</code>。</li></ul> </li><li><strong>初始化：</strong> 
  <ul><li>初始化第一行，表示没有物品，总和正好为 <code>0</code> 的情况。只有一种情况，即 <code>dp[0][0] = 1</code>；其余位置都为 <code>0</code> 种情况。</li></ul> </li><li><strong>填表顺序：</strong> 
  <ul><li>从上往下填表。</li></ul> </li><li><strong>返回值：</strong> 
  <ul><li>根据状态表示，返回 <code>dp[n][V]</code>。</li></ul> </li></ol> 
<p><strong>代码</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">change</span><span class="token punctuation">(</span><span class="token keyword">int</span> amount<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> n<span class="token operator">=</span>coins<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>amount<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>amount<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">&gt;=</span>coins<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>coins<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="04_383"></a>04.完全平方数</h2> 
<p>题目链接：https://leetcode.cn/problems/perfect-squares/</p> 
<p>给你一个整数 <code>n</code> ，返回 <em>和为 <code>n</code> 的完全平方数的最少数量</em> 。</p> 
<p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p> 
<p><strong>示例 1：</strong></p> 
<pre><code>输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
</code></pre> 
<p><strong>示例 2：</strong></p> 
<pre><code>输入：n = 13
输出：2
解释：13 = 4 + 9 
</code></pre> 
<p><strong>提示：</strong></p> 
<ul><li><code>1 &lt;= n &lt;= 104</code></li></ul> 
<p><strong>思路</strong></p> 
<ol><li> <p><strong>状态表示：</strong></p> 
  <ul><li>在这个问题中，状态表示我们需要找到使得和为 <code>n</code> 的最少完全平方数的数量。因此，我们可以定义状态 <code>dp[i][j]</code>，其中 <code>i</code> 表示使用前 <code>i</code> 个完全平方数，<code>j</code> 表示目标和为 <code>j</code>。<code>dp[i][j]</code> 的值表示使用前 <code>i</code> 个完全平方数达到和为 <code>j</code> 时的最小数量。</li></ul> </li><li> <p><strong>状态转移方程：</strong></p> 
  <ul><li> <p>根据问题的特点，我们可以得到状态转移方程：</p> <p><code>dp[i][j]=min(dp[i][j],dp[i][j-i*i]+1);</code></p> <p>其中，<code>i*i</code>表示第 <code>i</code> 个完全平方数。</p> </li></ul> </li><li> <p><strong>初始化：</strong></p> 
  <ul><li>在初始化阶段，我们需要初始化第一行和第一列的值。对于第一行，因为使用零个完全平方数就能达到和为 <code>0</code>，所以 <code>dp[0][0] = 0</code>。对于其余的 <code>dp[0][j]</code>，由于没有完全平方数可用，我们设为一个较大的值（代表不可能达到这个和）。对于第一列，因为使用任何完全平方数都可以达到和为 <code>0</code>，所以 <code>dp[i][0] = 0</code>。</li></ul> </li><li> <p><strong>填表顺序：</strong></p> 
  <ul><li>遍历顺序通常是根据状态转移方程中的依赖关系来确定的。在这里，我们可以先遍历使用的完全平方数 <code>i</code>，然后遍历目标和 <code>j</code>。</li></ul> </li><li> <p><strong>返回值：</strong></p> 
  <ul><li>返回结果是在最后一行 <code>dp[m][n]</code> 中，其中 <code>m</code> 表示完全平方数的个数，<code>n</code> 表示目标和。</li></ul> </li></ol> 
<p><strong>代码</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> INF<span class="token operator">=</span><span class="token number">0x3f3f3f3f</span><span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">numSquares</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> m<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">sqrt</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>INF<span class="token punctuation">;</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">&gt;=</span>i<span class="token operator">*</span>i<span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>i<span class="token operator">*</span>i<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f869a01997f24b768b26ec29aae6449d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">算法沉淀——动态规划之01背包问题（leetcode真题剖析）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/aab24828a8af2814308a9e33243f05e6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Django自学】Django入门：如何使用django开发一个web项目（非常详细）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>