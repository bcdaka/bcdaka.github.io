<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python for循环中的引用传递和值传递 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/faa145d997b9d99ff3d09acdc4a79a12/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Python for循环中的引用传递和值传递">
  <meta property="og:description" content="先上代码：
a = [[1],[2],[3]] b = [[4,5],[6,7],[7,8]] for i,j in zip(a,b): print(i,j) i = [9] #i[0] = 8 j[:2]=[1,2] print(i, j) print(a) print(b) 运行的结果：
[1] [4, 5] [9] [1, 2] [2] [6, 7] [9] [1, 2] [3] [7, 8] [9] [1, 2] [[1], [2], [3]] [[1, 2], [1, 2], [1, 2]] 可以看到修改i的值不会造成数组a的值的修改，而修改j的值会造成数组b的值的修改，这是为什么呢？
引用传递和值传递 引用传递(Pass by Reference) 在引用传递中,函数接收的是变量的地址,也就是对象的引用。
当你把一个可变对象(如列表、字典等)传递给函数时,函数内部对该对象的修改会影响到原始的对象。
这是因为函数接收的是对象的引用,而不是对象的副本。
示例:
def modify_list(lst): lst[0] = &#39;changed&#39; my_list = [1, 2, 3] modify_list(my_list) print(my_list) # 输出 [&#39;changed&#39;, 2, 3] 值传递(Pass by Value) 在值传递中,函数接收的是变量的值的副本。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-18T20:34:08+08:00">
    <meta property="article:modified_time" content="2024-06-18T20:34:08+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python for循环中的引用传递和值传递</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>先上代码：</p> 
<pre><code class="language-python">a = [[1],[2],[3]]
b = [[4,5],[6,7],[7,8]]
for i,j in zip(a,b):
    print(i,j)
    i = [9]
    #i[0] = 8
    j[:2]=[1,2]
    print(i, j)
print(a)
print(b)</code></pre> 
<p>运行的结果：</p> 
<pre><code class="language-python">[1] [4, 5]
[9] [1, 2]
[2] [6, 7]
[9] [1, 2]
[3] [7, 8]
[9] [1, 2]
[[1], [2], [3]]
[[1, 2], [1, 2], [1, 2]]</code></pre> 
<p>可以看到修改i的值不会造成数组a的值的修改，而修改j的值会造成数组b的值的修改，这是为什么呢？</p> 
<h2>引用传递和值传递</h2> 
<h3>引用传递(Pass by Reference)</h3> 
<p>在引用传递中,函数接收的是变量的地址,也就是对象的引用。<br> 当你把一个可变对象(如列表、字典等)传递给函数时,函数内部对该对象的修改会影响到原始的对象。<br> 这是因为函数接收的是对象的引用,而不是对象的副本。<br> 示例:</p> 
<pre><code class="language-python">  def modify_list(lst):
      lst[0] = 'changed'

  my_list = [1, 2, 3]
  modify_list(my_list)
  print(my_list)  # 输出 ['changed', 2, 3]</code></pre> 
<h3>值传递(Pass by Value)</h3> 
<p>在值传递中,函数接收的是变量的值的副本。<br> 当你把一个不可变对象(如整数、字符串等)传递给函数时,函数内部对该变量的修改不会影响到原始的变量。<br> 这是因为函数接收的是变量的值的副本,而不是变量本身。<br> 示例:</p> 
<pre><code class="language-python">  def modify_int(x):
      x = 'changed'

  my_int = 10
  modify_int(my_int)
  print(my_int)  # 输出 10</code></pre> 
<p>总的来说,在 Python 中,变量的赋值行为遵循以下规则:<br> 对于可变对象,变量存储的是对象的引用,即引用传递。<br> 对于不可变对象,变量存储的是对象的值,即值传递。</p> 
<p></p> 
<p>对一开始的问题做出简化</p> 
<pre><code class="language-python">a = [[1],[2],[3]]
b = [[4,5],[6,7],[7,8]]
c = a
c[0]=[8]
print(a)</code></pre> 
<p>这个c按理说是a的一个副本，但是为什么对c修改会对a造成影响呢？</p> 
<p></p> 
<p>当我们执行 c = a时,c 并不是 a 的副本,而是指向了 a 中同样的列表对象。也就是说,a 和 c 指向的是同一块内存地址。</p> 
<p>然后当我们执行 c[0] = [8] 时,我们是在修改 c 指向的那个列表的第一个元素。但是由于 a 和 c 指向的是同一个列表对象,所以这个修改同时也影响到了 a。</p> 
<p>这就是为什么打印 a 的结果会变成 [[8], [2], [3]]。</p> 
<p>如果你想创建 a的副本,而不是让 c 指向同一个列表对象,可以使用以下方式:</p> 
<pre><code class="language-python">a = [[1], [2], [3]]
b = [[4, 5], [6, 7], [7, 8]]
c = a[:]  # 或者 c=copy.copy(a) 或 c = copy.deepcopy(a)
c[0] = [8]
print(a)  # 输出 [[1], [2], [3]]
print(c)  # 输出 [[8], [2], [3]]
</code></pre> 
<p></p> 
<p>在最开始的问题中</p> 
<pre><code class="language-python">a = [[1],[2],[3]]
b = [[4,5],[6,7],[7,8]]
for i,j in zip(a,b):
    print(i,j)
    i = [9]            #这个是值传递
    #i[0] = 8          #这个是引用传递  
    j[:2]=[1,2]        #这个是引用传递
    print(i, j)
print(a)
print(b)</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2a5b753e4a2ca91942056ad1fe9f3b49/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">计算机网络（谢希仁第六版）| 课后习题与答案 | 物理层 | 题目知识点详细分析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fde80f559709da6e51f597b058767bc0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【向量检索】之向量数据库Milvus,Faiss详解及应用案例</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>