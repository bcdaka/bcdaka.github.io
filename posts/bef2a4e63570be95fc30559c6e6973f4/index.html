<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>LINUX高性能服务器框架 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/bef2a4e63570be95fc30559c6e6973f4/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="LINUX高性能服务器框架">
  <meta property="og:description" content="1.服务器模型：
1). C/S模型
：
此模型就是一个服务器能给多个客户端提供服务，但所以资源都被服务端所占有，客户端想要获取只能通过请求连接服务端去获取。由于客户端的请求访问是异步的，所以需要一个手段进行此类事件的监听，比如SELECT或者是EPOLL，可以只监听服务器套接字，将客户端的客户需求交给子进程去处理，也可以进行同时监听，将连接对面的套接字加入，进行一起监听。
2).P2P模式
此模型放弃了以服务器为中心的观点，改为每个电脑的地位相同，既可以作为客户端，也可以作为服务端。
2.服务器大致框架：
不同差别服务器，其差别一般都于逻辑处理，但大体框架是一样的，如下图：
3.io模型：
I/O模型一般有如下几种：
阻塞I/O：即当客户端发起连接以后，服务端成功连接，但是服务/客户端因为某些原因无法立刻执行，从而被操作系统挂起，直到有消息或者要处理时，才会从等待队列中唤醒。可能被阻塞的I/O有accept(),connect(),send(),recv()等等。
非阻塞I/O：此类不会一直等待，比如可以设置一段事件进行等待，事件发生就立即进行返回。
同步/异步 I/O
4：两种高效的I/O模型：
1.): reactor模型（同步模型）：
如上图：就绪事件准备好之后插入就绪队列，然后唤醒请求队列进行不同的工作状态进行工作。
以同步I/O模拟proactor模式
注意如此，用同步I/O来模拟异步I/O时，发生读事件，将数据进行封装然后储存在队列中，然后注册写事件就绪，而写事件则是队列取出进行回馈返回。
5.高效的并发模式（主要运用线程池）：
1).半同步半异步：
半同步半异步指的就是同步用来处理用户逻辑，异步用来处理I/O事件：
但是上述模型有缺点：
8-11改良后的半同步/半异步模式，每个工作线程都可以通过epoll_wait()。来监听多个SOCKET进行服务。
2).领导/追逐者模式：读者能力有限，请自行 查阅资料
6.优先状态机，用来处理单元之间的逻辑问题：比如先处理什么，再处理什么，接着处理什么。
想象一个如下有限状态机：
下面是利用上述原理进行的分析HTTP请求的状态机。
#include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;assert.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;errno.h&gt; #include &lt;string.h&gt; #include &lt;fcntl.h&gt; #define BUFFER_SIZE 4096 enum CHECK_STATE { CHECK_STATE_REQUESTLINE = 0, CHECK_STATE_HEADER, CHECK_STATE_CONTENT }; enum LINE_STATUS { LINE_OK = 0, LINE_BAD, LINE_OPEN }; enum HTTP_CODE { NO_REQUEST, GET_REQUEST, BAD_REQUEST, FORBIDDEN_REQUEST, INTERNAL_ERROR, CLOSED_CONNECTION }; static const char* szret[] = { &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-24T00:15:46+08:00">
    <meta property="article:modified_time" content="2024-07-24T00:15:46+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">LINUX高性能服务器框架</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p>1.服务器模型：</p> 
<p>1). C/S模型</p> 
<p style="text-align:center;"> ：<img alt="" height="314" src="https://images2.imgbox.com/e9/e7/f2eJQ9rZ_o.png" width="308"></p> 
<p><br>   此模型就是一个服务器能给多个客户端提供服务，但所以资源都被服务端所占有，客户端想要获取只能通过请求连接服务端去获取。由于客户端的请求访问是异步的，所以需要一个手段进行此类事件的监听，比如SELECT或者是EPOLL，可以只监听服务器套接字，将客户端的客户需求交给子进程去处理，也可以进行同时监听，将连接对面的套接字加入，进行一起监听。</p> 
<p style="text-align:center;"><img alt="" height="346" src="https://images2.imgbox.com/ae/d9/ZUrtUBmv_o.png" width="366"></p> 
<p>2).P2P模式</p> 
<p> 此模型放弃了以服务器为中心的观点，改为每个电脑的地位相同，既可以作为客户端，也可以作为服务端。</p> 
<p style="text-align:center;"> <img alt="" height="264" src="https://images2.imgbox.com/18/e4/V8Y7iDiA_o.png" width="570"></p> 
<p>2.服务器大致框架：</p> 
<p>不同差别服务器，其差别一般都于逻辑处理，但大体框架是一样的，如下图：</p> 
<p class="img-center"><img alt="" height="184" src="https://images2.imgbox.com/36/f3/YulmKdKl_o.png" width="425"></p> 
<p><img alt="" height="383" src="https://images2.imgbox.com/d1/c5/yJ0JDFJ0_o.png" width="667"></p> 
<p>3.io模型：</p> 
<p>I/O模型一般有如下几种：</p> 
<p>阻塞I/O：即当客户端发起连接以后，服务端成功连接，但是服务/客户端因为某些原因无法立刻执行，从而被操作系统挂起，直到有消息或者要处理时，才会从等待队列中唤醒。可能被阻塞的I/O有accept(),connect(),send(),recv()等等。</p> 
<p></p> 
<p>非阻塞I/O：此类不会一直等待，比如可以设置一段事件进行等待，事件发生就立即进行返回。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/45/4e/f2KGVFqt_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/d5/30/5ZpUZDrE_o.png"></p> 
<p>同步/异步 I/O</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/09/cc/68IuYaUl_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/52/f7/o8navJt5_o.png"></p> 
<p></p> 
<p></p> 
<p>4：两种高效的I/O模型：</p> 
<p>1.): reactor模型（同步模型）：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f9/93/zEuFFDVC_o.png"></p> 
<p>如上图：就绪事件准备好之后插入就绪队列，然后唤醒请求队列进行不同的工作状态进行工作。</p> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/67/23/TBk7CaCh_o.png"></p> 
<p style="text-align:center;">以同步I/O模拟proactor模式</p> 
<p><img alt="" src="https://images2.imgbox.com/7a/c1/PpzlLYhg_o.png"></p> 
<p>注意如此，用同步I/O来模拟异步I/O时，发生读事件，将数据进行封装然后储存在队列中，然后注册写事件就绪，而写事件则是队列取出进行回馈返回。</p> 
<p>5.高效的并发模式（主要运用线程池）：<br> 1).半同步半异步：</p> 
<p style="text-align:center;"><img alt="" height="342" src="https://images2.imgbox.com/25/b7/G80yUbHx_o.png" width="454"></p> 
<p style="text-align:center;">半同步半异步指的就是同步用来处理用户逻辑，异步用来处理I/O事件：</p> 
<p><img alt="" src="https://images2.imgbox.com/12/af/NGY0adt4_o.png"></p> 
<p>但是上述模型有缺点：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/1d/c7/1U8iBUsC_o.png"></p> 
<p>8-11改良后的半同步/半异步模式，每个工作线程都可以通过epoll_wait()。来监听多个SOCKET进行服务。</p> 
<p>2).领导/追逐者模式：读者能力有限，请自行 查阅资料</p> 
<p>6.优先状态机，用来处理单元之间的逻辑问题：比如先处理什么，再处理什么，接着处理什么。</p> 
<p>想象一个如下有限状态机：</p> 
<p style="text-align:center;"><img alt="" height="115" src="https://images2.imgbox.com/e7/94/rYAobIGK_o.png" width="636"></p> 
<p style="text-align:center;">下面是利用上述原理进行的分析HTTP请求的状态机。</p> 
<pre><code class="language-cpp">#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;fcntl.h&gt;

#define BUFFER_SIZE 4096
enum CHECK_STATE { CHECK_STATE_REQUESTLINE = 0, CHECK_STATE_HEADER, CHECK_STATE_CONTENT };
enum LINE_STATUS { LINE_OK = 0, LINE_BAD, LINE_OPEN };
enum HTTP_CODE { NO_REQUEST, GET_REQUEST, BAD_REQUEST, FORBIDDEN_REQUEST, INTERNAL_ERROR, CLOSED_CONNECTION };
static const char* szret[] = { "I get a correct result\n", "Something wrong\n" };

LINE_STATUS parse_line( char* buffer, int&amp; checked_index, int&amp; read_index )
{
    char temp;
    for ( ; checked_index &lt; read_index; ++checked_index )
    {
        temp = buffer[ checked_index ];
        if ( temp == '\r' )
        {
            if ( ( checked_index + 1 ) == read_index )//对面传来一行数据 这“一行”数据 可能是属于HTTP头部的一部分 还没到"\n",这里判断是read_index是消息行末尾的后一个字节，checked_index已经读到对面发过来末尾了
            {
                return LINE_OPEN;
            }
            else if ( buffer[ checked_index + 1 ] == '\n' )
            {
                buffer[ checked_index++ ] = '\0';
                buffer[ checked_index++ ] = '\0';
                return LINE_OK;
            }
            return LINE_BAD;
        }
        else if( temp == '\n' )
        {
            if( ( checked_index &gt; 1 ) &amp;&amp;  buffer[ checked_index - 1 ] == '\r' )
            {
                buffer[ checked_index-1 ] = '\0';
                buffer[ checked_index++ ] = '\0';
                return LINE_OK;
            }
            return LINE_BAD;
        }
    }
    return LINE_OPEN;
}

HTTP_CODE parse_requestline( char* szTemp, CHECK_STATE&amp; checkstate )
{
    char* szURL = strpbrk( szTemp, " \t" );
    if ( ! szURL )
    {
        return BAD_REQUEST;
    }
    *szURL++ = '\0';

    char* szMethod = szTemp;
    if ( strcasecmp( szMethod, "GET" ) == 0 )
    {
        printf( "The request method is GET\n" );
    }
    else
    {
        return BAD_REQUEST;
    }

    szURL += strspn( szURL, " \t" );
    char* szVersion = strpbrk( szURL, " \t" );
    if ( ! szVersion )
    {
        return BAD_REQUEST;
    }
    *szVersion++ = '\0';
    szVersion += strspn( szVersion, " \t" );
    if ( strcasecmp( szVersion, "HTTP/1.1" ) != 0 )
    {
        return BAD_REQUEST;
    }

    if ( strncasecmp( szURL, "http://", 7 ) == 0 )
    {
        szURL += 7;
        szURL = strchr( szURL, '/' );
    }

    if ( ! szURL || szURL[ 0 ] != '/' )
    {
        return BAD_REQUEST;
    }

    //URLDecode( szURL );
    printf( "The request URL is: %s\n", szURL );
    checkstate = CHECK_STATE_HEADER;
    return NO_REQUEST;
}

HTTP_CODE parse_headers( char* szTemp )
{
    if ( szTemp[ 0 ] == '\0' )
    {
        return GET_REQUEST;
    }
    else if ( strncasecmp( szTemp, "Host:", 5 ) == 0 )
    {
        szTemp += 5;
        szTemp += strspn( szTemp, " \t" );
        printf( "the request host is: %s\n", szTemp );
    }
    else
    {
        printf( "I can not handle this header\n" );
    }

    return NO_REQUEST;
}

HTTP_CODE parse_content( char* buffer, int&amp; checked_index, CHECK_STATE&amp; checkstate, int&amp; read_index, int&amp; start_line )
{
    LINE_STATUS linestatus = LINE_OK;
    HTTP_CODE retcode = NO_REQUEST;
    while( ( linestatus = parse_line( buffer, checked_index, read_index ) ) == LINE_OK )
    {
        char* szTemp = buffer + start_line;
        start_line = checked_index;//连续两次++ 
        switch ( checkstate )
        {
            case CHECK_STATE_REQUESTLINE:
            {
                retcode = parse_requestline( szTemp, checkstate );
                if ( retcode == BAD_REQUEST )
                {
                    return BAD_REQUEST;
                }
                break;
            }
            case CHECK_STATE_HEADER:
            {
                retcode = parse_headers( szTemp );
                if ( retcode == BAD_REQUEST )
                {
                    return BAD_REQUEST;
                }
                else if ( retcode == GET_REQUEST )
                {
                    return GET_REQUEST;
                }
                break;
            }
            default:
            {
                return INTERNAL_ERROR;
            }
        }
    }
    if( linestatus == LINE_OPEN )
    {
        return NO_REQUEST;
    }
    else
    {
        return BAD_REQUEST;
    }
}

int main( int argc, char* argv[] )
{
    if( argc &lt;= 2 )
    {
        printf( "usage: %s ip_address port_number\n", basename( argv[0] ) );
        return 1;
    }
    const char* ip = argv[1];
    int port = atoi( argv[2] );
    
    struct sockaddr_in address;
    bzero( &amp;address, sizeof( address ) );
    address.sin_family = AF_INET;
    inet_pton( AF_INET, ip, &amp;address.sin_addr );
    address.sin_port = htons( port );
    
    int listenfd = socket( PF_INET, SOCK_STREAM, 0 );
    assert( listenfd &gt;= 0 );
    
    int ret = bind( listenfd, ( struct sockaddr* )&amp;address, sizeof( address ) );
    assert( ret != -1 );
    
    ret = listen( listenfd, 5 );
    assert( ret != -1 );
    
    struct sockaddr_in client_address;
    socklen_t client_addrlength = sizeof( client_address );
    int fd = accept( listenfd, ( struct sockaddr* )&amp;client_address, &amp;client_addrlength );
    if( fd &lt; 0 )
    {
        printf( "errno is: %d\n", errno );
    }
    else
    {
        char buffer[ BUFFER_SIZE ];
        memset( buffer, '\0', BUFFER_SIZE );
        int data_read = 0;
        int read_index = 0;
        int checked_index = 0;
        int start_line = 0;
        CHECK_STATE checkstate = CHECK_STATE_REQUESTLINE;
        while( 1 )
        {
            data_read = recv( fd, buffer + read_index, BUFFER_SIZE - read_index, 0 );
            if ( data_read == -1 )
            {
                printf( "reading failed\n" );
                break;
            }
            else if ( data_read == 0 )
            {
                printf( "remote client has closed the connection\n" );
                break;
            }
    
            read_index += data_read;
            HTTP_CODE result = parse_content( buffer, checked_index, checkstate, read_index, start_line );
            if( result == NO_REQUEST )
            {
                continue;
            }
            else if( result == GET_REQUEST )
            {
                send( fd, szret[0], strlen( szret[0] ), 0 );
                break;
            }
            else
            {
                send( fd, szret[1], strlen( szret[1] ), 0 );
                break;
            }
        }
        close( fd );
    }
    
    close( listenfd );
    return 0;
}</code></pre> 
<p>只需注意一点的是通过while循环不断读取请求，根据读取数据进行请求行和消息头的寻找和分析。</p> 
<p></p> 
<p>下面是简单的，通过epoll_wait()调用的有限状态机（四种情况）和recator模型，将监听到的事件分为读写事件的简单服务端，代码如下：</p> 
<pre><code class="language-cpp">//recator
#include &lt;sys/socket.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/epoll.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;iostream&gt;
#include &lt;netinet/in.h&gt;
#include &lt;assert.h&gt;

const int MAX_EVENT=1000;
const int MAX_BUFSIZE=1024;
const int clinetnum=99999;
int epollfd=0;
struct clinet_data;

typedef int(*REPLAY_LETTER)(int,clinet_data*);
void epollset(int,int);
void clintset(clinet_data*,int);

struct clinet_data{
    int fd;
    char bufread[MAX_BUFSIZE];
    char bufwrite[MAX_BUFSIZE];
    int readend;
    int writeend;
    REPLAY_LETTER readevent;
    REPLAY_LETTER writevent;
    REPLAY_LETTER closeevent;
    clinet_data():fd(0),readend(0),writeend(0){};
};

clinet_data* dataset=new clinet_data[clinetnum];

 void closeevent(int sockfd){
  close(sockfd);
  std::cout&lt;&lt;"close sockfd :"&lt;&lt;sockfd&lt;&lt;std::endl;
}
void epoll_event_change(int sockfd,int mode){
    switch (mode){
    
      case 1:
      {
        epoll_ctl(epollfd,EPOLL_CTL_DEL,sockfd,NULL);
        break;
      }
      case 2:
      {
        epoll_event ee;
        ee.data.fd=sockfd;
        ee.events=EPOLLOUT;
        epoll_ctl(sockfd,EPOLL_CTL_MOD,sockfd,&amp;ee);
       break;
      }
      case 3:
      {
          epoll_event ee;
        ee.data.fd=sockfd;
        ee.events=EPOLLIN;
        epoll_ctl(sockfd,EPOLL_CTL_MOD,sockfd,&amp;ee);  
        break;
      }
       case 4:
       {
                struct sockaddr_in addr;
                socklen_t size=sizeof(addr);
                int connect=accept(sockfd,(struct sockaddr*)&amp;addr,&amp;size);
                epollset(epollfd,connect);
                clintset(dataset,connect);
                break;
       }
      default:
      break;
    }
}
int readevent(int sockfd,clinet_data* dataset){
    //size&lt;MAX_BUFFSIZE,事件改为写 然后发送回去

    int size=recv(sockfd,dataset[sockfd].bufread,MAX_BUFSIZE-1,0);
    dataset[sockfd].readend=size;
    dataset[sockfd].writeend=0;
      if(size==0){//对面关闭
        memset(dataset[sockfd].bufread,'\0',MAX_BUFSIZE);
        std::cout&lt;&lt;"nodata,over"&lt;&lt;std::endl;
        closeevent(sockfd);
        dataset[sockfd].fd=0;
        epoll_event_change(sockfd,1);
        return 0;
    }else{
    std::cout&lt;&lt;"recv data  :"&lt;&lt;dataset[sockfd].bufread&lt;&lt;std::endl;
    memcpy(dataset[sockfd].bufwrite,dataset[sockfd].bufread,size);
    memset(dataset[sockfd].bufread,'\0',MAX_BUFSIZE);
    epoll_event_change(sockfd,2);
    }
    return size;
}

int writeevent(int sockfd,clinet_data* dataset){
    dataset[sockfd].writeend=dataset[sockfd].readend;
    dataset[sockfd].readend=0;
    int count=send(sockfd,dataset[sockfd].bufwrite,dataset[sockfd].writeend,0);
    epoll_event_change(sockfd,3);
    return count;
}

void  clintset(clinet_data* con,int fd){
    con[fd].readevent=readevent;
    con[fd].writevent=writeevent;
    con[fd].fd=fd;
}

int setsocknoblock(int fd){
int old=fcntl(fd,F_GETFL);
int newfd=old|O_NONBLOCK;
fcntl(old,F_SETFL,newfd);
return old;
}

void epollset(int epollfd,int fd){
    epoll_event even;
    even.data.fd=fd;
    even.events=EPOLLET|EPOLLIN;
    epoll_ctl(epollfd,EPOLL_CTL_ADD,fd,&amp;even);
    setsocknoblock(fd);
}

int main(int argc,char* argv[]){

    if(argc&lt;2){
        std::cout&lt;&lt;"not enough"&lt;&lt;std::endl;
        exit(1);
    }
    int ret=0;
     struct sockaddr_in address;
      epoll_event events[MAX_EVENT]; 
    memset(&amp;address,0,sizeof(address));
    address.sin_family=AF_INET;
    address.sin_addr.s_addr=inet_addr("127.0.0.1");
    address.sin_port=htons(atoi(argv[1]));
    int severfd=socket(PF_INET,SOCK_STREAM,0);
    assert(severfd&gt;=0);

    epollfd=epoll_create(5);
    epollset(epollfd,severfd);
    
    ret=bind(severfd,(struct sockaddr*)&amp;address,sizeof(address));
    assert(ret&gt;=0);

    ret=listen(severfd,5);
    assert(ret&gt;=0);
    clinet_data* dataset=new clinet_data[clinetnum];
    while(1){
      int numm=epoll_wait(epollfd,events,MAX_EVENT-1,5*1000);
      if(numm==0){
        std::cout&lt;&lt;"timeout"&lt;&lt;std::endl;
      }else if(numm&lt;0){
      std::cout&lt;&lt;"epoll_wait error"&lt;&lt;std::endl;
      exit(1);
      }else{
        for(int i=0;i&lt;numm;i++){
            int fd=events[i].data.fd;
            if(events[i].events&amp;EPOLLIN){
                if(fd==severfd){
                epoll_event_change(fd,4);
                }else{
                     readevent(fd,dataset);
                }
            }
            else if(events[i].events&amp;EPOLLOUT){
                writeevent(fd,dataset);
            }
        }
      }
}
delete [] dataset;
close(severfd);
return 0;
}

</code></pre> 
<p></p> 
<p>结合客户端代码(输入Q后，客户端断开自行测试：（作者已经测试过了，没有问题）。</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;sys/socket.h&gt;
#include&lt;string.h&gt;
#include&lt;unistd.h&gt;
#include&lt;arpa/inet.h&gt;
const int a=1024;
using namespace std;
int main(int argc,char* argv[]){
    char message[a];
struct sockaddr_in times;
if(argc!=3){
    cout&lt;&lt;"error()"&lt;&lt;endl;
    exit(1);
}
int cilsock;
int str_len;
cilsock=socket(PF_INET,SOCK_STREAM,0);
if(cilsock==-1){
    cout&lt;&lt;"socket()error"&lt;&lt;endl;
}
memset(&amp;times,0,sizeof(times));
times.sin_family=AF_INET;
times.sin_addr.s_addr=inet_addr(argv[1]);
times.sin_port=htons(atoi(argv[2]));
if(connect(cilsock,(struct sockaddr *)&amp;times,sizeof(times))==-1){
cout&lt;&lt;"connext()error()"&lt;&lt;endl;
}else{
puts("connect........");
}
 
while(1){
    fputs("input message",stdout);
    fgets(message,a,stdin);
 
    if(!strcmp(message,"q/n")||!strcmp(message,"Q/n"))
    break;
 
    write(cilsock,message,strlen(message));
    str_len=read(cilsock,message,a-1);
    message[str_len]=0;
    cout&lt;&lt;message&lt;&lt;endl;
}
close(cilsock);
return 0;
 
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/49e4e6419cd31ef3bb4c8d4df8f4da75/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring从入门到精通 01</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3716300ac946602ffa55fddaff24d1d7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">NPOI 导出列太多或者数据太多爆内存</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>