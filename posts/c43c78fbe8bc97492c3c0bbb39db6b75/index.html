<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;进阶学习】第六弹——set和map——体会用C&#43;&#43;来构建二叉搜索树 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/c43c78fbe8bc97492c3c0bbb39db6b75/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;进阶学习】第六弹——set和map——体会用C&#43;&#43;来构建二叉搜索树">
  <meta property="og:description" content="set和map基础：【C&#43;&#43;进阶学习】第五弹——二叉搜索树——二叉树进阶及set和map的铺垫-CSDN博客
前言：
在上篇的学习中，我们已经学习了如何使用C语言来实现二叉搜索树，在C&#43;&#43;中，我们是有现成的封装好的类模板来实现二叉搜索树的——set和map,这也是我们今天要讲的重点
目录
一、容器
二、set和multiset
一、set与multiset概述
二、set与multiset的基本操作
三、高级特性
四、set与multiset的选择
三、map和multimap
1. map与multimap的区别
2. map与multimap的使用场景
3. 基本操作
4. 注意事项
5. 示例代码
四、总结
一、容器 在前面，我们经常提到容器这个东西，比如stack、queue等许多类模板都称之为容器，其实今天要讲的set和map也是容器的一种，容器这个东西我会在下一章进行单独讲解，有兴趣的可以关注一下
二、set和multiset 在C&#43;&#43;标准模板库（STL）中，set和multiset是两种关联容器，它们在处理有序集合数据时非常有用。
一、set与multiset概述 set 是一种关联容器，它存储唯一（不重复）的元素，并且这些元素会根据特定的排序规则自动排序。set内部通常采用红黑树实现，保证了元素的对数时间复杂度的插入、删除和查找操作。
multiset 与set类似，但它允许存储重复的元素。multiset同样基于红黑树实现，其操作的时间复杂度特性与set相同。
二、set与multiset的基本操作 在使用set或multiset之前，需要包含相应的头文件：
#include &lt;set&gt; #include &lt;multiset&gt; 以下是一些基本操作：
构造函数： set&lt;T&gt; s; // 默认构造函数 multiset&lt;T&gt; ms; // 默认构造函数 // 可以通过比较函数和分配器进行自定义构造 插入元素： s.insert(key); // set插入元素 ms.insert(key); // multiset插入元素 insert 方法用于向set或multiset中添加元素，如果插入成功，set 的insert方法返回pair&lt;iterator, bool&gt;（这个东西后面会讲），其中bool指示是否插入成功。multiset 的insert方法返回指向插入元素的迭代器。 删除元素： s.erase(key); // 删除特定元素（set） ms.erase(key); // 删除特定元素（multiset） // 删除操作在multiset中会删除所有匹配的元素 查找元素： auto it = s.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-12T22:49:10+08:00">
    <meta property="article:modified_time" content="2024-07-12T22:49:10+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;进阶学习】第六弹——set和map——体会用C&#43;&#43;来构建二叉搜索树</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>set和map基础：</strong><a href="https://blog.csdn.net/2301_80220607/article/details/140137075?spm=1001.2014.3001.5502" title="【C++进阶学习】第五弹——二叉搜索树——二叉树进阶及set和map的铺垫-CSDN博客">【C++进阶学习】第五弹——二叉搜索树——二叉树进阶及set和map的铺垫-CSDN博客</a></p> 
<p><strong>前言：</strong></p> 
<blockquote> 
 <p>在上篇的学习中，我们已经学习了如何使用C语言来实现二叉搜索树，在C++中，我们是有现成的封装好的类模板来实现二叉搜索树的——set和map,这也是我们今天要讲的重点</p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E4%B8%80%E3%80%81%E5%AE%B9%E5%99%A8-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%AE%B9%E5%99%A8" rel="nofollow">一、容器</a></p> 
<p id="%E4%BA%8C%E3%80%81set%E5%92%8Cmultiset-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81set%E5%92%8Cmultiset" rel="nofollow">二、set和multiset</a></p> 
<p id="%E4%B8%80%E3%80%81set%E4%B8%8Emultiset%E6%A6%82%E8%BF%B0-toc" style="margin-left:80px;"><a href="#%E4%B8%80%E3%80%81set%E4%B8%8Emultiset%E6%A6%82%E8%BF%B0" rel="nofollow">一、set与multiset概述</a></p> 
<p id="%E4%BA%8C%E3%80%81set%E4%B8%8Emultiset%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-toc" style="margin-left:80px;"><a href="#%E4%BA%8C%E3%80%81set%E4%B8%8Emultiset%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C" rel="nofollow">二、set与multiset的基本操作</a></p> 
<p id="%E4%B8%89%E3%80%81%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-toc" style="margin-left:80px;"><a href="#%E4%B8%89%E3%80%81%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7" rel="nofollow">三、高级特性</a></p> 
<p id="%E5%9B%9B%E3%80%81set%E4%B8%8Emultiset%E7%9A%84%E9%80%89%E6%8B%A9-toc" style="margin-left:80px;"><a href="#%E5%9B%9B%E3%80%81set%E4%B8%8Emultiset%E7%9A%84%E9%80%89%E6%8B%A9" rel="nofollow">四、set与multiset的选择</a></p> 
<p id="%E4%B8%89%E3%80%81map%E5%92%8Cmultimap-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81map%E5%92%8Cmultimap" rel="nofollow">三、map和multimap</a></p> 
<p id="1.%C2%A0map%E4%B8%8Emultimap%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#1.%C2%A0map%E4%B8%8Emultimap%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">1. map与multimap的区别</a></p> 
<p id="2.%C2%A0map%E4%B8%8Emultimap%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:80px;"><a href="#2.%C2%A0map%E4%B8%8Emultimap%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">2. map与multimap的使用场景</a></p> 
<p id="3.%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-toc" style="margin-left:80px;"><a href="#3.%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C" rel="nofollow">3. 基本操作</a></p> 
<p id="4.%20%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-toc" style="margin-left:80px;"><a href="#4.%20%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" rel="nofollow">4. 注意事项</a></p> 
<p id="5.%20%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#5.%20%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81" rel="nofollow">5. 示例代码</a></p> 
<p id="%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93" rel="nofollow">四、总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E5%AE%B9%E5%99%A8">一、容器</h2> 
<blockquote> 
 <p>在前面，我们经常提到容器这个东西，比如stack、queue等许多类模板都称之为容器，其实今天要讲的set和map也是容器的一种，容器这个东西我会在下一章进行单独讲解，有兴趣的可以关注一下</p> 
</blockquote> 
<h2 id="%E4%BA%8C%E3%80%81set%E5%92%8Cmultiset">二、set和multiset</h2> 
<p>在C++标准模板库（STL）中，<span style="color:#fe2c24;"><strong>set</strong></span>和<span style="color:#fe2c24;"><strong>multiset</strong></span>是两种关联容器，它们在处理有序集合数据时非常有用。</p> 
<h4 id="%E4%B8%80%E3%80%81set%E4%B8%8Emultiset%E6%A6%82%E8%BF%B0">一、set与multiset概述</h4> 
<blockquote> 
 <p><strong>set</strong> 是一种关联容器，它存储唯一（不重复）的元素，并且这些元素会根据特定的排序规则自动排序。set内部通常采用红黑树实现，保证了元素的对数时间复杂度的插入、删除和查找操作。</p> 
 <p><img alt="" height="153" src="https://images2.imgbox.com/45/01/lLDv00Y2_o.png" width="1200"></p> 
 <p><strong>multiset</strong> 与set类似，但它允许存储重复的元素。multiset同样基于红黑树实现，其操作的时间复杂度特性与set相同。</p> 
</blockquote> 
<h4 id="%E4%BA%8C%E3%80%81set%E4%B8%8Emultiset%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">二、set与multiset的基本操作</h4> 
<p><strong><span style="background-color:#ffd900;">在使用set或multiset之前，需要包含相应的头文件：</span></strong></p> 
<pre><code class="language-cpp">#include &lt;set&gt;
#include &lt;multiset&gt;</code></pre> 
<p><strong>以下是一些基本操作：</strong></p> 
<ol><li><strong>构造函数</strong>：</li></ol> 
<pre><code class="language-cpp">set&lt;T&gt; s; // 默认构造函数
multiset&lt;T&gt; ms; // 默认构造函数
// 可以通过比较函数和分配器进行自定义构造</code></pre> 
<ol><li><strong>插入元素</strong>：</li></ol> 
<pre><code class="language-cpp">s.insert(key); // set插入元素
ms.insert(key); // multiset插入元素</code></pre> 
<blockquote> 
 <ul><li><strong><code><span style="background-color:#ffd900;">insert</span></code></strong> 方法用于向set或multiset中添加元素，如果插入成功，<strong><code><span style="background-color:#ffd900;">set</span></code></strong> 的<strong><code><span style="background-color:#ffd900;">insert</span></code></strong>方法返回<strong><span style="color:#0d0016;"><code><span style="background-color:#ffd900;">pair&lt;iterator, bool&gt;（这个东西后面会讲）</span></code></span></strong>，其中<strong><code><span style="background-color:#ffd900;">bool</span></code></strong>指示是否插入成功。</li><li><strong><code><span style="background-color:#ff9900;">multiset</span></code></strong> 的<strong><code><span style="background-color:#ff9900;">insert</span></code></strong>方法返回指向插入元素的迭代器。</li></ul> 
</blockquote> 
<ol><li><strong>删除元素</strong>：</li></ol> 
<pre><code class="language-cpp">s.erase(key); // 删除特定元素（set）
ms.erase(key); // 删除特定元素（multiset）
// 删除操作在multiset中会删除所有匹配的元素</code></pre> 
<ol><li><strong>查找元素</strong>：</li></ol> 
<pre><code class="language-cpp">auto it = s.find(key); // 查找元素（set）
auto it = ms.find(key); // 查找元素（multiset）
// find返回指向元素的迭代器，如果未找到则返回end()</code></pre> 
<ol><li><strong>统计元素个数</strong>：</li></ol> 
<pre><code class="language-cpp">s.count(key); // set中元素个数（总是1或0）
ms.count(key); // multiset中元素个数（可能是大于0的整数）</code></pre> 
<ol><li><strong>大小和容量</strong>：</li></ol> 
<pre><code class="language-cpp">s.size(); // 返回元素数量
ms.size(); // 返回元素数量
s.empty(); // 判断是否为空
ms.empty(); // 判断是否为空</code></pre> 
<h4 id="%E4%B8%89%E3%80%81%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7">三、高级特性</h4> 
<ol><li><strong>迭代器</strong>：</li></ol> 
<blockquote> 
 <p>set和multiset都提供迭代器，支持前向和后向遍历。</p> 
</blockquote> 
<pre><code class="language-cpp">for (auto it = s.begin(); it != s.end(); ++it) {
    // 遍历set中的元素
}</code></pre> 
<ol><li><strong>排序规则</strong>：</li></ol> 
<blockquote> 
 <p>默认情况下，set和multiset使用小于操作符<code>&lt;</code>进行排序，但可以通过自定义比较函数来改变排序规则。</p> 
</blockquote> 
<pre><code class="language-cpp">struct CustomCompare {
    bool operator()(const T&amp; a, const T&amp; b) const {
        // 自定义比较逻辑
    }
};
set&lt;T, CustomCompare&gt; s; // 使用自定义比较函数
multiset&lt;T, CustomCompare&gt; ms; // 使用自定义比较函数</code></pre> 
<ol><li><strong>性能考虑</strong>：</li></ol> 
<blockquote> 
 <p>由于set和multiset基于二叉搜索树实现，它们的插入、删除和查找操作通常具有O(log n)的时间复杂度。</p> 
</blockquote> 
<h4 id="%E5%9B%9B%E3%80%81set%E4%B8%8Emultiset%E7%9A%84%E9%80%89%E6%8B%A9">四、set与multiset的选择</h4> 
<blockquote> 
 <p>选择使用set还是multiset取决于是否需要存储重复元素。如果需要存储唯一的元素集合，则应该使用set。如果允许集合中存在重复元素，那么应该选择multiset。</p> 
</blockquote> 
<h2 id="%E4%B8%89%E3%80%81map%E5%92%8Cmultimap">三、map和multimap</h2> 
<p>在C++的STL（标准模板库）中，<strong><code><span style="background-color:#ffd900;">map</span></code></strong>和<strong><code><span style="background-color:#ffd900;">multimap</span></code></strong>是两种关联容器，它们用于存储键值对。这些容器使用红黑树作为底层数据结构，以确保高效的插入、查找和删除操作。</p> 
<h4 id="1.%C2%A0map%E4%B8%8Emultimap%E7%9A%84%E5%8C%BA%E5%88%AB">1. <code>map</code>与<code>multimap</code>的区别</h4> 
<blockquote> 
 <ul><li><strong>唯一性</strong>：<code>map</code>存储的是唯一键值对，即每个键只能对应一个值。而<code>multimap</code>允许相同的键对应多个值，提供了一种更灵活的数据存储方式。</li><li><strong>排序</strong>：两者都按照键的自然顺序进行排序，通常为升序。可以通过自定义比较函数来改变排序规则。</li></ul> 
</blockquote> 
<h4 id="2.%C2%A0map%E4%B8%8Emultimap%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">2. <code>map</code>与<code>multimap</code>的使用场景</h4> 
<blockquote> 
 <ul><li><strong><code>map</code></strong>通常用于需要确保键的唯一性且需要对键进行排序的场景。例如，统计不同类别的数据数量、实现字典等。</li><li><strong><code>multimap</code></strong>则适用于需要处理多个值与相同键关联的场景，如记录用户在不同时间段的登录记录。</li></ul> 
</blockquote> 
<h4 id="3.%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">3. 基本操作</h4> 
<p>下面这些操作与上面set和multiset的操作基本一致，就不再写了</p> 
<blockquote> 
 <ul><li><strong>构造与初始化</strong>：可以通过构造函数直接初始化<code>map</code>或<code>multimap</code>，也可以使用<code>std::make_map</code>或<code>std::make_multimap</code>辅助函数。自定义排序可以通过传递比较函数来实现。</li><li><strong>插入与删除</strong>：使用<code>insert</code>方法插入键值对，<code>erase</code>方法删除键值对。<code>erase</code>方法还可以用于删除指定范围内的元素。</li><li><strong>查找</strong>：<code>find</code>方法用于查找键值对，返回指向匹配元素的迭代器；<code>lower_bound</code>和<code>upper_bound</code>方法用于查找键的范围，适用于处理多个相同键的值。</li></ul> 
</blockquote> 
<h4 id="4.%20%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">4. 注意事项</h4> 
<blockquote> 
 <ul><li><strong>迭代器的失效</strong>：删除元素后，所有指向被删除元素的迭代器都会失效。在迭代时，需要确保迭代器的有效性。</li><li><strong>键的类型</strong>：键的类型必须支持比较操作，通常需要有定义的比较运算符或提供一个比较函数。</li><li><strong>性能</strong>：插入、查找和删除操作的时间复杂度为O(log n)，基于红黑树的高效性。</li><li><strong>值类型</strong>：值的类型可以是任何类型，但通常选择有意义的数据类型，如整型、浮点型或字符串等。</li></ul> 
</blockquote> 
<h4 id="5.%20%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">5. 示例代码</h4> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;
using namespace std;

int main() {
    // 使用map存储唯一键值对
   map&lt;string, int&gt; fruitCounts = {
        {"apple", 10},
        {"banana", 15},
        {"cherry", 5}
    };

    // 使用multimap存储多个值与相同键关联
    multimap&lt;string, int&gt; logins = 
    {
        {"Alice", 1001},
        {"Bob", 2001},
        {"Alice", 1003}
    };

    // 查找和打印map中的元素
    auto it = fruitCounts.find("banana");
    if (it != fruitCounts.end()) {
        cout &lt;&lt; "Found banana: " &lt;&lt; it-&gt;second &lt;&lt; endl;
    }

    // 查找和打印multimap中的元素
    auto range = logins.equal_range("Alice");
    for (auto it = range.first; it != range.second; ++it) {
        cout &lt;&lt; "Login for Alice: " &lt;&lt; it-&gt;second &lt;&lt; endl;
    }

    return 0;
}</code></pre> 
<p><strong>运行结果：</strong></p> 
<p><img alt="" height="290" src="https://images2.imgbox.com/77/32/xsbhXvF7_o.png" width="757"></p> 
<h2 id="%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93">四、总结</h2> 
<blockquote> 
 <p>以上就是C++中set和map的全部内容，其实底层逻辑就是二叉搜索树或者准确来说叫红黑树，其中有一些小的知识点会在下一节再提一下</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/3a/04/1J0W7mzI_o.jpg"></p> 
<p><strong><span style="background-color:#ffd900;">感谢各位大佬观看，创作不易，还请各位大佬点赞支持一下！！！</span></strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/41cfa969e32b95f9d4b43a427161daae/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python数据分析-Excel和 Text 文件的读写操作</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/46afaebb1bc0bc42ef9f43e22a0437f6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AI绘画系统课程：从基础入门到商业应用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>