<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/179bb5d1f09b6b28aa5cf1cf79e59b40/" rel="bookmark">
			Android Studio开发（一） 构建项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、项目创建测试 1.1 前言 Android Studio 是由 Google 推出的官方集成开发环境（IDE），专门用于开发 Android 应用程序。
基于 IntelliJ IDEA: Android Studio 是基于 JetBrains 的 IntelliJ IDEA 开发的，提供了丰富的功能和插件支持，使开发 Android 应用更加高效和便捷。
功能丰富: Android Studio 提供了许多功能丰富的工具，如代码编辑器、调试器、布局编辑器、性能分析工具等，帮助开发者快速构建高质量的 Android 应用。
Gradle 构建系统: Android Studio 使用 Gradle 作为构建系统，使项目配置和构建更加灵活和可控，可以方便地管理依赖关系、资源文件等。
模拟器和调试器: Android Studio 集成了 Android 模拟器和调试器，开发者可以方便地在模拟器或真机上调试和测试应用程序。
布局编辑器: Android Studio 提供了强大的布局编辑器，支持可视化设计界面和 XML 布局文件的编辑，帮助开发者快速构建用户界面。
版本控制: Android Studio 集成了版本控制系统，如 Git，使团队协作开发更加方便，可以轻松管理代码版本和协作开发。
1.2 新建项目 选择file--&gt;New--&gt;New Project进行项目创建，选用Empty Activity：
选择编程语言和兼容的最低安卓版本后点击finish即可：
创建完成后的项目如图所示：
1.3 运行项目 在如图所示的位置点击下拉选择Device Manager：
进行虚拟设备创建，首先选择设备的外观信息：
然后选择虚拟设备的Android版本，并进行下载：
最后选择设备名称和屏幕的放置形式：
点击运行按钮可以查看新建工程的运行效果：
展示运行界面：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/179bb5d1f09b6b28aa5cf1cf79e59b40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/148e19a81c2e9ed2c25c6cf7b4493f13/" rel="bookmark">
			【Sql Server】C#通过拼接代码的方式组合添加sql语句，会出现那些情况，参数化的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到《小5讲堂》，大家好，我是全栈小5。
这是《Sql Server》系列文章，每篇文章将以博主理解的角度展开讲解，
特别是针对知识点的概念进行叙说，大部分文章将会对这些概念进行实际例子验证，以此达到加深对知识点的理解和掌握。
温馨提示：博主能力有限，理解水平有限，若有不对之处望指正！
目录 前言语句报错报错原因参数优化ADO.NET安装包链接模式参数化作用文章推荐 前言 博主写的很多博客分享，都是来源于实际开发和学习过程中遇到的一些细节问题，
因此通过文章的方式记录下来，这不仅可以边写边总结边边理解，这样也能加深印象。
本篇文章是讲，为什么要用参数化来生成sql语句？通过创建测试项目一起探索吧！
语句报错 没有进行参数化传递值，通过纯拼接方式组合的sql语句，是有可能存在一些sql语句不规范，
从而导致一些报错，比如：博主本次sql语句报错就是因为sql语句存在参数值本身还有逗号，
逗号在sql语句里又是特殊符号。
上图报错提示，在张三附近有语法错误，这个时候如果不是具体分析sql语句，但从错误提示是看不出什么原因。
在这里插入代码片 报错原因 通过调试和查看sql语句，观察可以看到，在赋值时，如果粗心大意的话，是很容易多写了一次单引号
参数优化 基于上面错误，如果赋值确实需要带上单引号进行查询，那么就需要通过参数化的方式。
添加一条记录测试，具体创建表可以在文章后面查看相关链接
declare @agent_name nvarchar(50) set @agent_name='''张三''' insert into test_name(city_name,area_name,agent_name) values('深圳市','龙岗区',@agent_name) 从下图可以看到，使用参数化可以传递单引号值，也不会引发sql语句报错
ADO.NET 在 C# 的 ADO.NET 中，以下是一些基本的类及其主要作用：
1.SqlConnection
用于建立与 SQL Server 数据库的连接。
2.SqlCommand
用于执行 SQL 语句或存储过程，并返回受影响的行数、结果集或标量值。
3.SqlDataAdapter
用于从数据库中读取数据，并填充到 DataSet 或 DataTable 中。
可以直接执行sql语句，如果没有where条件或者参数化时
4.DataSet
本身不包含数据，但是可以包含一个或多个 DataTable ，以及它们之间的关系。
5.DataTable
表示内存中的表格，包含多个 DataRow，一行表示一条记录，包含多个列（字段）。
6.DataRow
表示 DataTable 中的一行数据，通过列名或索引访问数据。
安装包 和十年前VS开发工具相比，现在VS版本越来越智能化，会自动识别进行包的安装，非常方便和高效。
链接模式 C# ADO.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/148e19a81c2e9ed2c25c6cf7b4493f13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9efe0073de947d563bcc6f65ffbabfdd/" rel="bookmark">
			idealTree:ftp-server-web: sill idealTree buildDeps卡住了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、错误 问题描述：在windows中执行npm install 卡在idealTree:ftp-server-web: sill idealTree buildDeps 2、解决方法 查看镜像源：
npm config get registry 打印返回
https://registry.npm.taobao.org/ 更换镜像源
npm config set registry https://registry.npmmirror.com 再次查看
npm config get registry 打印返回
https://registry.npmmirror.com/ 再次执行npm install 问题解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90e04808769492590f0240c8d7363758/" rel="bookmark">
			SQL server 数据库log日志过大，占用内存大解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工作中遇到服务器内存爆红，自己查看发现是数据库的log日志文件过大，占内存有180g之多，找了挺多，还是直接删除log文件这种方便快捷
一、当时先是看了一下SQL server各个数据库的log所占内存大小，本来考虑用压缩，但发现所占内存已经99%了，压缩不了了
DBCC SQLPERF (LOGSPACE)
可以通过这个查看数据库各个log日志的内存占用
二 、先分类数据库，最好先完整备份数据库，点击需要删除log的数据库，选择数据库——右键——任务——分离，如下图：
三、将日志文件和数据文件复制粘贴到另外一个文件夹或者改名以防万一。删除链接，如下图
四、现在就可以去数据库对应的文件夹中把log文件删掉了
可以右击数据库点击属性查看文件的所在对应位置
五、附加数据库
六、选择需要恢复的对应数据库的文件数据，添加上去，显示log文件找不到，点击日志然后点击下面删掉就好，系统会自动生成新的log文件，最后点击确定附加成功
ps:由于不方便展示数据库，就在网上找的别人的图片，但方法都是实践操作过的，没有问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d302099aa7e3c3b12814d99df2b01c77/" rel="bookmark">
			SpringCloud-RabbitMQ消息模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文深入介绍了RabbitMQ消息模型，涵盖了基本消息队列、工作消息队列、广播、路由和主题等五种常见消息模型。每种模型都具有独特的特点和适用场景，为开发者提供了灵活而强大的消息传递工具。通过这些模型，RabbitMQ实现了解耦、异步通信以及高效的消息路由，为分布式系统的开发和部署提供了可靠的基础。阅读本文，读者将深入了解RabbitMQ不同消息模型的应用场景和使用方法，为构建可靠的消息传递系统提供了有益的指导。
一、RabbitMQ消息模型介绍 RabbitMQ 是一种高度可扩展的消息代理，其消息模型基于 AMQP（Advanced Message Queuing Protocol）协议，提供了灵活可靠的消息传递机制。
以下是 RabbitMQ 的核心消息模型组成部分：
组成部分功能生产者 (Producer)生产者负责产生和发送消息到 RabbitMQ 服务器。
将消息发布到特定的交换机（Exchange）。交换机 (Exchange)交换机是消息的分发中心，接收生产者发送的消息，并将其路由到一个或多个队列。RabbitMQ 提供不同类型的交换机，如直连交换机（direct）、主题交换机（topic）、扇出交换机（fanout）、头交换机（headers）等，以满足不同的路由需求。队列 (Queue)队列是消息的存储地点，消息在队列中等待被消费。
消息按照一定的规则存储在队列中，等待消费者订阅并处理。绑定 (Binding)绑定定义了交换机如何将消息路由到特定的队列。
绑定规则由消费者在订阅队列时指定，确保消息按照预期的方式路由。消费者 (Consumer)消费者订阅一个或多个队列，接收并处理队列中的消息。消费者从队列中获取消息，完成相应的业务逻辑，然后应答（acknowledge）消息。路由键 (Routing Key)路由键是消息从生产者到达交换机时的附加信息，用于指导消息路由到特定的队列。路由键的值与交换机类型和绑定规则相关。 RabbitMQ 的消息模型允许灵活的消息路由和传递，提供了高度可靠性和可伸缩性。生产者通过交换机将消息发送到队列，而消费者则订阅队列并处理消息。这种模型使得系统能够实现解耦、异步通信，同时确保消息在分布式环境中的可靠传递。
二、RabbitMQ常见消息模型 MQ（消息队列）在应用中有多种常见的消息模型，其中包括以下五种：
1、基本消息队列 基本消息队（Basic Queue） 列是最简单的消息传递模型。在这个模型中，生产者发送包含简单信息如 "Hello World!" 的消息到队列，而消费者则接收并处理这些消息。这种模型适用于简单的场景，如需要一对一通信的情况。
示意图：
2、工作消息队列 工作消息队列（Work Queue）用于在多个工作者（消费者）之间分发任务。生产者将任务发送到队列，多个工作者可以并发地处理这些任务。这种模型有效地实现了任务的分发和并行处理。
示意图：
3、发布订阅 发布订阅（Publish/Subscribe） 模型采用广播方式，生产者将消息发送到交换机，多个队列通过订阅交换机接收消息，实现一对多的消息传递。
根据交换机类型不同，发布订阅模型又分为三种：
① 广播交换机（Fanout Exchange） 广播交换机（Fanout Exchange）是一种简单而强大的消息传递模型。当生产者发送消息到Fanout Exchange时，该交换机会将消息广播到所有与之绑定的队列，无论它们的路由键是什么。这使得多个队列能够同时接收相同的消息，实现了一对多的消息传递
示意图：
② 直连交换机（Direct Exchange） 直连交换机（Direct Exchange）通过使用指定的路由键，将消息传递到与之匹配的队列。这种模型适用于需要将消息精确路由到特定队列的场景。生产者发送消息时，可以指定一个或多个路由键，而队列在绑定交换机时也需要指定相应的路由键，从而实现精准的消息路由。
示意图：
③ 主题交换机（Topic） 主题交换机（Topic Exchange）允许消息的路由键与队列的绑定模式进行模糊匹配，从而实现更灵活的消息订阅和路由。路由键可以使用通配符（和#），其中星号()代表一个单词，井号(#)代表零个或多个单词。这种模型使得队列能够订阅符合特定模式的消息，而不仅仅是固定的路由键。
示意图：
这五种消息模型展示了RabbitMQ在不同场景下的应用，为开发者提供了多样的选择，以满足各种消息传递需求。 三、RabbitMQ消息模型总结 RabbitMQ作为高度可扩展的消息代理，其消息模型基于AMQP协议，提供了强大的消息传递机制。核心组成部分包括生产者、交换机、队列、绑定和消费者等。消息模型允许实现灵活的消息路由和传递，提供了高度可靠性和可伸缩性。通过交换机将消息发送到队列，消费者订阅队列并处理消息，实现了解耦、异步通信，确保消息在分布式环境中的可靠传递。 ​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0e9bf9f2ec9335516a3d9bbb41f1f6b/" rel="bookmark">
			【C语言】Leetcode 206.反转链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主主页：17_Kevin-CSDN博客
收录专栏：《Leetcode》
题目 解决思路 思路一：翻转链表 struct ListNode* reverseList(struct ListNode* head) { if(head == NULL) { return NULL; } struct ListNode* n1 = NULL,*n2 = head,*n3 = n2 -&gt; next; while(n2 != NULL) { n2 -&gt; next = n1; n1 = n2; n2 = n3; if(n3 != NULL) { n3 = n2 -&gt; next; } } return n1; } 我们定义三个节点的指针n1，n2，n3.分别指向NULL，head，head -&gt; next。这样我们通过三个指针来临时存放各个节点，以此为基础来重新将各个节点进行链接。之后通过while循环使指针向后移动，逐一将n2位置的节点断开与n1之前的链接，再由n2指向n1进行链接。
过程如下图：
思路二：头插法 struct ListNode* reverseList(struct ListNode* head) { struct ListNode *cur = head; struct ListNode *newhead = NULL; while(cur) { struct ListNode *next = cur -&gt; next; cur -&gt; next = newhead; newhead = cur; cur = next; } return newhead; } 首先我们定义了两个结构体指针，cur和newhead，用cur来指向当前的节点，从head开始；用newhead指向一个NULL，newhead将作为后面链接新链表的表头。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0e9bf9f2ec9335516a3d9bbb41f1f6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cea7efd0fd60d0a005e246166b4475e/" rel="bookmark">
			手把手安装部署Redis（Windows和Mac）图文详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言 一、Windos版本
1、下载：
2、安装
3、测试（启动）
第一种打开启动方式：（进入文件夹打开）
第二种打开启动方式：（cmd窗口打开）
4、连接Redis
二、Mac版本
1、下载：
2、安装
3、测试（启动）
第一种打开启动方式：（进入文件夹打开）
第二种打开启动方式：（cmd窗口打开）
4、连接Redis
前言 Redis是一款开源的内存数据结构存储系统，它支持键值对的存储和多种数据结构，如字符串、列表、哈希表和集合等。Redis具有高性能、高可用性和可扩展性等特点，被广泛应用于缓存、​​​​​​​消息队列和分布式锁等场景。
一、Windos版本 1、下载： 下载地址https://www.123pan.com/s/8EpMjv-MTjBv.html
我们演示下载的是“压缩包版本”两个都是一样的。
2、安装 将下载的压缩包解压到指定的文件夹中，如：D:\Redis，内容如下：
上述图片中，按照顺序依次打开
3、测试（启动） 第一种打开启动方式：（进入文件夹打开） 第二种打开启动方式：（cmd窗口打开） 直接在Redis目录路径处输入cmd回车也可以进入命令窗口
输入如下命令，即可启动redis redis-server.exe redis.windows.conf 4、连接Redis 上述图片中提到的，序号2，redis-cli.exe命令来打开Redis客户端：
直接输入下面代码：ping ping 返回 PONG 即表示连接成功了 （切记这2个都不要关闭了，保持后台运行）
同理，在cmd中也是可以连接的，方法同启动redis是一样的。 二、Mac版本 1、下载： 与windows不同的是，Redis官网是可以直接下载Mac版本的
Redis官网下载地址https://redis.io/download/
2、安装 对于不同的操作系统，安装Redis的步骤可能会有所不同。我是用CentOS系统为例，介绍如何安装
1. 解压安装包：使用以下命令解压下载的Redis安装包：
sudo tar -xzf redis-6.0.5.tar.gz -C /mydata/redis 2. 进入解压后的目录：使用以下命令进入解压后的目录：
cd /mydata/redis/redis-6.0.5/ 3. 编译Redis：使用以下命令编译Redis：
sudo make 4. 安装Redis：使用以下命令将编译后的Redis安装到系统中：
sudo make install 5. 配置Redis：使用以下命令创建一个符号链接，将默认的Redis配置文件连接到/mydata/redis目录下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cea7efd0fd60d0a005e246166b4475e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b64250012427d19401149e9055edc8ea/" rel="bookmark">
			python详细安装教程3.9.0,python详细安装教程3.8.5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，给大家分享一下python详细安装教程3.9.0，很多人还不知道这一点。下面详细解释一下。现在让我们来看看！
Source code download: 本文相关源码
前言 工欲善其事必先利其器，在使用Python开发程序之前，在计算机上搭建Python开发环境是必不可少的环节，目前Python最新稳定版本是3.11.1，且支持到2027年，如下图所示
本文手把手带你从0 到1搭建Python最新版3.11.1开发环境，堪称保姆级教程，快快收藏啦~
【----帮助Python学习，以下所有学习资料文末免费领！----】
Python解释器安装 我的电脑是Win10系统，我就以Win10举例~
我们可以直接去Python官网下载相应操作系统的安装包：
需要注意3.11.1要求windows必须是win7以上才行，推荐大家使用win10或win11！
Windows安装步骤 1、windows版的Python安装包是exe文件，上面是默认安装，安装到C盘。我们选择下面自定义安装，这里记得选中“Add python.exe to Path”，可以避免人工再去配置环境变量
2、这里不用管，直接Next
3、选择安装路径
4、安静等待安装，等待过程无聊的话就去上个厕所~
5、然后如果弹出下面这个框，点击“Disable path length limit”的按钮，然后点击close关闭python笑脸编程代码。“Disable path length limit”是指，禁用系统的Path长度自动限制，能给我们避免很多的麻烦。禁用路径长度限制更改计算机配置，以允许包括Python在内的程序绕过260个字符的“最大路径”限制。这是说明你电脑对Python的一些限制，点击它然后确定权限就可以了
6、Win + R 快速打开cmd，输入python --version可以验证是否正确安装
环境变量配置（非必要） 1、如果忘了选中“Add python.exe to Path”，可能这里无法正确执行python命令，需要手动添加环境变量
2、右键我的电脑，点击属性
3、点击高级系统设置，出现下图，选择环境变量
4、找到系统变量里面的Path，编辑它，将python解释器所在路径粘贴到最后面，再加个分号，至此环境变量配置完成，再打开命令行输入python即可看到正确的显示。
MacOS安装步骤 macOS的安装步骤与Windows类似，其Python安装包是pkg文件，下载下来一直点双击即可完成安装。
macOS默认已经带了Python开发环境，一般是Python2.7版本，因为这个版本是Python2应用最广泛的版本，有点像JDK8。
Python支持多版本共存，所以我们可以不用管原始版本，记得添加PATH环境变量哟~
Linux安装步骤 Linux版的Python安装程序与上述2种操作系统安装步骤有些差异，由于Linux发行版特别多，所以官网上Linux的Python是以源码形式发布的，需要我们使用GCC编译和安装
1、安装依赖包、下载Python3.11.1
# 安装python依赖 yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel gcc make # 下载安装包 wget https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b64250012427d19401149e9055edc8ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/544f87e3805bbb374fab866ef8f38dd7/" rel="bookmark">
			程序员利器（一）：【Mos】针对Mac的鼠标滚动平滑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 我的雷蛇无线鼠标搭配Mac使用时，滚轮有回滚现象，但没有那么严重。
起初我以为是鼠标又坏了，买了还不到1年，还好在保质期内。
我想着在家里的Window电脑上再检测一下，结果用Win的工具检测，鼠标滚动一切正常。
后来无意中发现这个开源小工具，可以让Mac上的鼠标滚动更加平滑，就像在用触控板一样。使用之后，鼠标滚动确实更丝滑了，最主要的是之前的滚轮回滚现象没有了。
Mos 官网链接如下：
MOS | A lightweight tool used to smooth scrolling and set scroll direction independently for your mouse on MacOS
一个用于在 MacOS 上平滑你的鼠标滚动效果或单独设置滚动方向的小工具, 让你的滚轮爽如触控板
开源地址如下：
GitHub - Caldis/Mos: 一个用于在 macOS 上平滑你的鼠标滚动效果或单独设置滚动方向的小工具, 让你的滚轮爽如触控板 | A lightweight tool used to smooth scrolling and set scroll direction independently for your mouse on macOS
现在, 完全掌控你的鼠标 Mos 可以分离你的触控板与鼠标的滚动事件, 皆因与此, 鼠标的滚动方向再也不受触控板所限. 同时, Mos 还可以为你的鼠标提供平滑滚动, 不管你是 Windows 用户, 亦或是 MacOS 用户, 均可切换自如 滚动, 从未如此顺手 经过 Mos 独特的插值算法处理后, 您的鼠标滚动将会变得前所未有的顺滑 所有应用, 尽在管理之下 Mos 可以独立管理每个应用程序的滚动行为.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/544f87e3805bbb374fab866ef8f38dd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3faf30028b031354f20df42cbcc3fa01/" rel="bookmark">
			基于FastAPI构造一个AI模型部署应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 fastapi是目前一个比较流行的python web框架，在大模型日益流行的今天，其云端部署和应用大多数都是基于fastapi框架。所以掌握和理解fastapi框架基本代码和用法尤显重要。
需要注意的是，fastapi主要是通过app对象提供了web服务端的实现代码，对于一个完整应用来说，还需要uvicorn组件来启动web服务，如果想要可视化UI的话，可以考虑使用streamlit前端。
代码 大家可以基于下面这个简单代码例子(参考GitHub - markthink/streamlit-fastapi-model，稍有修改)来加深理解。一共三个python源文件: segmentation.py(获取pytorch deeplabv3模型和推理该模型实现图像分割), ui.py(基于streamlit构造webUI供用户来选择图片并显示结果)和server.py(基于fastapi编写服务端函数来响应前端UI发来的/segmentation消息)。
segmentation.py:
import io, torch from PIL import Image from torchvision import transforms def get_segmentator(): model = torch.hub.load('pytorch/vision:v0.10.0', 'deeplabv3_mobilenet_v3_large', pretrained=True) model.eval() return model def get_segments(model, binary_image, max_size=512): input_image = Image.open(io.BytesIO(binary_image)).convert("RGB") width, height = input_image.size resize_factor = min(max_size/width,max_size/height) resize_image = input_image.resize((int(input_image.width * resize_factor),int(input_image.height*resize_factor))) preprocess = transforms.Compose( [ transforms.ToTensor(), transforms.Normalize(mean=[0.485,0.456,0.406],std=[0.229,0.224,0.225]) ] ) input_tensor = preprocess(resize_image) input_batch = input_tensor.unsqueeze(0) with torch.no_grad(): output = model(input_batch)['out'][0] output_predictions = output.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3faf30028b031354f20df42cbcc3fa01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f306ad1a8c8d410588dd3f2c2e24f09/" rel="bookmark">
			数据结构——常见简答题汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、绪论
2、线性表
3、栈、队列和数组
4、串 5、树与二叉树
6、图
7、查找
8、排序
1、绪论 什么是数据结构？
数据结构是相互之间存在一种或多种特定关系的数据元素的集合。数据结构包括三个方面：逻辑结构、存储结构、数据的运算。
逻辑结构有：集合（数据元素除属于“同一个集合”外，别无其他关系）；
线性结构（数据元素之间只存在一对一的关系）；
树形结构（数据元素之间存在一对多的关系）；
图状结构或网状结构（数据元素之间存在多对多的关系）。
存储结构有：顺序存储、链式存储、索引存储、散列存储。
四种存储结构的优缺点是什么?
顺序存储：
优点：可以实现随机存取，每个元素占用最少的存储空间；
缺点：只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片。
链式存储：
优点：不会出现碎片现象，能充分利用所有存储单元；
缺点：每个元素因存储指针而占用额外的存储空间，且只能实现顺序存取。
索引存储：
优点：检索速度快；
缺点：附加的索引表额外占用存储空间。另外，增加和删除数据时也要修改索引表，
因而会花费较多的时间。
散列存储：
优点：检索、增加和删除结点的操作都很快；
缺点：若散列函数不好，则可能出现存储单元的冲突，而解决冲突会增加时间和空间的开销。
算法的基本概念？
算法（Algorithm）是对特定问题求解步骤的一种描述。
算法的五个特性：
有穷性、确定性、可行性、输入、输出。
“好”算法应达到以下目标：
正确性、可读性、健壮性、高效率与低存储量需求。 时间复杂度的计算？
点击跳转到时间复杂度的计算
常见的渐近时间复杂度为
O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O()&lt;O()&lt;O()&lt;O(n!)&lt;O()
2、线性表 顺序表在插入或删除时一般需要移动元素，如果想不移动多个元素就实现插入和删除，应该如何处理？
插入元素时，直接将新元素插入在第n+1个位置；删除第i个元素时，将第n个元素补到第i个位置。
请简要说明线性表的顺序存储结构和链式存储结构在数据插入、数据删除、数据查找、存储空间占用等方面的优缺点。
顺序表在插入和删除时需要移动很多数据，时间耗费高；而链式存储不需要移动数据，时间耗费低。
顺序表分配空间的大小不好确定，要根据经验；而链式存储时按照需要分配，不会浪费空间。
顺序表查找元素时，支持用下标查找，时间耗费低；链式存储方式查找时只能从前往后顺序进行查找和比较，时间耗费高。
链式存储结构中，头指针和头结点之间的区分？引入头结点有什么优点呢？
不管带不带头结点，头指针都始终指向链表的第一个结点，而头结点是带头结点的链表中的第一个结点，结点内通常不存储信息。
引入头结点后，可以带来两个优点：
①由于第一个数据结点的位置被存放在头结点的指针域中，因此在链表的第一个位置上的操作和在表的其他位置上的操作一致，无须进行特殊处理。
②无论链表是否为空，其头指针都是指向头结点的非空指针（空表中头结点的指针域为空），因此空表和非空表的处理也就得到了统一。
循环双链表的判空条件是什么？
当循环双链表为空表时，head-&gt;next=head 并且 head-&gt;prior=head;
3、栈、队列和数组 说明线性表、栈和队列的异同点？
相同点：
都是线性结构，都是逻辑结构的概念。都可以用顺序存储和链式存储。
不同点：
①运算规则不同，线性表支持随机存取。栈只允许在一端进行插入、删除运算，因而是后进先出（LIFO)。队列是只允许一端进行插入，另一端进行删除运算，因而是先进先出（FIFO)。
②用途不同，栈用于子程调用和保护现场。队列用于多道作业处理、指令寄存及其他运算等。
栈初始化是栈顶指针S.top==-1，栈空和栈满的条件是什么？
栈空：S.top==-1
栈满：S.top==MaxSize-1
共享栈两个栈顶指针都指向栈顶元素，第一种情况top0=-1时0号栈为空，top1=MaxSize时1号栈为空。第二种情况top0=0时0号栈为空，top1=MaxSize-1时1号栈为空。判满条件分别是什么？ 判满条件：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f306ad1a8c8d410588dd3f2c2e24f09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/693793e0fb5507767cbd607de61d5020/" rel="bookmark">
			Android Studio如何修改JDK版本和获知使用的Java版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是JDK和Java版本？
首先，让我们简单了解一下什么是JDK和Java版本。JDK（Java Development Kit）是Java开发工具包的缩写，它包含了Java的运行环境（JRE）和开发工具，用于开发Java应用程序。而Java版本是指Java编程语言的不同版本，每个版本都会有一些新的特性和改进。
Android Studio中如何修改JDK版本？
在Android Studio中，我们可以通过以下步骤来修改JDK版本：
1. 打开Android Studio，点击菜单栏中的“File” -&gt; “Project Structure”。
2. 在弹出的窗口中，选择“SDK Location”选项卡。
3. 在该选项卡中，找到“JDK location”一栏，点击旁边的“…”按钮。
4. 在弹出的窗口中，选择新的JDK路径，然后点击“OK”保存设置。
5. 重新启动Android Studio，使修改生效。
通过以上步骤，我们就可以轻松地修改Android Studio中使用的JDK版本，以便更好地适配我们的开发需求。
如何获知当前使用的Java版本？
在Android Studio中，我们可以通过以下方式来查看当前使用的Java版本：
1. 打开Android Studio，在菜单栏中选择“Help” -&gt; “About”。
2. 在弹出的对话框中，可以看到“About Android Studio”页面上列出了当前使用的Java版本信息。
通过查看这些信息，我们可以清楚地了解当前Android Studio所使用的Java版本，以便我们进行相应的调整和优化。
为什么要关注JDK版本和Java版本？
关注JDK版本和Java版本的选择是非常重要的，因为不同的版本可能会有不同的特性和兼容性。选择合适的JDK版本可以帮助我们更好地开发和调试Android应用，提高开发效率和代码质量。同时，了解当前使用的Java版本可以帮助我们及时更新和优化开发环境，保持应用的稳定性和性能。总的来说，掌握如何修改JDK版本和获知当前使用的Java版本是Android开发者必备的技能之一。通过本文的介绍，希望能够帮助大家更好地理解和应用这些知识，提升自己在Android应用开发领域的能力和水平。如果有任何问题或建议，欢迎在评论区留言，我们一起学习进步！感谢大家的阅读，我们下期再见！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d31b97b20006a7119fdb14a029ff98b5/" rel="bookmark">
			python做小游戏代码可复制,python做小游戏代码300行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章给大家谈谈用python做一个小游戏代码，以及python简单小游戏代码200行，希望对各位有所帮助，不要忘了收藏本站喔。
哈喽铁子们
表弟最近在学Python，总是跟我抱怨很枯燥无味，其实，他有没有认真想过，可能是自己学习姿势不对？
比方说，可以通过打游戏来学编程！
今天给大家分享100个Python小游戏，一定要收藏！
1、简易飞机大战 飞机大战相信大家都玩过吧，非常简单有意思的游戏，咱们通过Python给它复刻出来，回味童年。
素材文件
全部源码：
import sys import cfg import pygame from modules import * '''游戏界面''' def GamingInterface(num_player, screen): # 初始化 pygame.mixer.music.load(cfg.SOUNDPATHS['Cool Space Music']) pygame.mixer.music.set_volume(0.4) pygame.mixer.music.play(-1) explosion_sound = pygame.mixer.Sound(cfg.SOUNDPATHS['boom']) fire_sound = pygame.mixer.Sound(cfg.SOUNDPATHS['shot']) font = pygame.font.Font(cfg.FONTPATH, 20) # 游戏背景图 bg_imgs = [cfg.IMAGEPATHS['bg_big'], cfg.IMAGEPATHS['seamless_space'], cfg.IMAGEPATHS['space3']] bg_move_dis = 0 bg_1 = pygame.image.load(bg_imgs[0]).convert() bg_2 = pygame.image.load(bg_imgs[1]).convert() bg_3 = pygame.image.load(bg_imgs[2]).convert() # 玩家, 子弹和小行星精灵组 player_group = pygame.sprite.Group() bullet_group = pygame.sprite.Group() asteroid_group = pygame.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d31b97b20006a7119fdb14a029ff98b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74c6c95c6e7ea961abb319dbc669f7f3/" rel="bookmark">
			【python】python二手房数据抓取分析可视化（源码）【独一无二】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👉博__主👈：米码收割机
👉技__能👈：C++/Python语言
👉公众号👈：测试开发自动化【获取源码+商业合作】
👉荣__誉👈：阿里云博客专家博主、51CTO技术博主
👉专__注👈：专注主流机器人、人工智能等相关领域的开发、测试技术。
python二手房数据抓取分析可视化（源码） 目录 python二手房数据抓取分析可视化（源码）一、功能描述二、数据抓取展示三、数据可视化分析部分代码展示 一、功能描述 代码是一个爬虫程序，旨在抓取链家网站 上的二手房数据，并进行数据处理和可视化展示。
爬取数据：使用requests库向链家网站发送HTTP请求，获取网页的HTML内容，然后使用lxml库解析HTML，提取出房屋的标题、价格、地段、面积和户型等信息。
数据存储：将爬取的房屋数据存储到CSV文件中，方便后续的数据处理和分析。
数据清洗：对爬取的数据进行清洗，去除空格行和不规范的数据，并将清洗后的数据写回CSV文件。
数据统计与可视化：
价格区间统计柱状图：将房屋价格分组到不同的价格区间，并统计每个价格区间的房屋数量，然后使用matplotlib库绘制柱状图进行可视化展示。面积筛选：筛选出面积大于100平方米的房屋，并将结果保存到新的CSV文件中。区域房屋数量统计：统计各个区域的房屋数量，并使用柱状图和饼图进行可视化展示，以便比较各个区域的房屋数量占比。 通过这些功能，用户可以快速获取链家网站上的二手房数据，并进行数据分析和可视化，帮助他们更好地了解房屋市场的情况和趋势。
👇👇👇 关注公众号，回复 “链家爬虫” 获取源码👇👇👇
二、数据抓取展示 存储内容如下：
👇👇👇 关注公众号，回复 “链家爬虫” 获取源码👇👇👇
三、数据可视化分析 价格区间分析
👇👇👇 关注公众号，回复 “链家爬虫” 获取源码👇👇👇
各区域房屋数量对比分析
各区房屋数量占比
👇👇👇 关注公众号，回复 “链家爬虫” 获取源码👇👇👇
部分代码展示 import requests import matplotlib.pyplot as plt import pandas as pd plt.rcParams['font.sans-serif'] = ['SimHei'] def write_csv(csv_file_path): with open('data.csv', 'a+', newline='') as csvfile: csv_writer = csv.writer(csvfile) csv_writer.writerow(csv_file_path) # 爬虫部分代码（略...）👇👇👇 关注公众号，回复 “链家爬虫” 获取源码👇👇👇 # 爬虫部分代码（略.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74c6c95c6e7ea961abb319dbc669f7f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aab24828a8af2814308a9e33243f05e6/" rel="bookmark">
			【Django自学】Django入门：如何使用django开发一个web项目（非常详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测试机器：windows11 x64
python版本：3.11
一、安装Django 安装步骤非常简单，使用pip安装就行
pip install django 安装完成之后，python的 Scripts 文件夹下，会多一个 django-admin.exe (管理创建django项目的工具)。Lib文件夹下site-packages下，会出现django源码。
使用下面的命令可以查看django版本号。
python -m django --version 显示：
5.0.1 二、创建与开发web项目 这里记录两种创建方式，一种是命令行方式创建，一种是通过pycharm方式创建。
1.1 通过命令行方式 打开终端，进入到项目将要放在的目录下，执行创建项目命令：
django-admin startproject 自定义的项目名称 如果提示没有这个命令，有可能是没有配置环境变量，将django-admin的存放路径加入系统变量就可以了。
1.2 通过pycharm创建项目 打开pycharm，左上角“文件”，“新建项目”，左侧：Django—配置项目位置、python解析器—创建
最顶上的【名称】与【位置】是项目名称与项目的存放位置。一定要确定好使用的python版本，尤其是当你的的电脑里存在多个python脚本时，一定要选择你安装django的那个python版本。如果电脑里只有一个python版本，就不需要改动。在下面就是添加模板文件，和【APP】名称，点击【创建】完成创建。 记住下面红框内两个文件夹名字，之后会用到，注意区分。
创建完成后，可以看到创建了很多文件，这些都是django项目的必备文件。这里简单放上，官方的解释
最外层的 mysite/ 根目录只是你项目的容器， 根目录名称对 Django 没有影响，你可以将它重命名为任何你喜欢的名称。
manage.py: 一个让你用各种方式管理 Django 项目的命令行工具。你可以阅读 django-admin 和 manage.py 获取所有 manage.py 的细节。里面一层的 mysite/ 目录包含你的项目，它是一个纯 Python 包。它的名字就是当你引用它内部任何东西时需要用到的 Python 包名。 (比如 mysite.urls).mysite/init.py：一个空文件，告诉 Python 这个目录应该被认为是一个 Python 包。如果你是 Python 初学者，阅读官方文档中的 更多关于包的知识。mysite/settings.py：Django 项目的配置文件。如果你想知道这个文件是如何工作的，请查看 Django 配置 了解细节。mysite/urls.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aab24828a8af2814308a9e33243f05e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c6a1572196720429cb571678affd2e3/" rel="bookmark">
			算法沉淀——动态规划之完全背包问题（leetcode真题剖析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法沉淀——动态规划之完全背包问题 01.【模板】完全背包02.零钱兑换03.零钱兑换 II04.完全平方数 完全背包问题是背包问题的一种变体，与01背包问题不同，它允许你对每种物品进行多次选择。具体来说，给定一个固定容量的背包，一组物品，每个物品有重量和价值，目标是找到在背包容量范围内，使得背包中的物品总价值最大的组合。 相较于01背包问题，完全背包问题允许对每个物品进行多次选择，即每个物品都有无限件可用。
动态规划解法：
定义状态： 通常使用二维数组dp[i][j]表示在前i个物品中，背包容量为j时的最大总价值。
状态转移方程： 考虑第i个物品，可以选择放入背包或者不放入。如果选择放入，那么总价值为dp[i][j-weight[i]] + value[i]，即前i个物品的总价值加上当前物品的价值。如果选择不放入，那么总价值为dp[i-1][j]，即前i-1个物品的总价值。因此，状态转移方程为：
dp[i][j] = max(dp[i-1][j], dp[i][j-weight[i]] + value[i]) 其中，dp[i-1][j]表示不放入第i个物品，dp[i][j-weight[i]] + value[i]表示放入第i个物品。
初始条件： 当i=0时，表示前0个物品，总价值为0；当j=0时，表示背包容量为0，总价值也为0。
遍历顺序： 外层循环遍历物品，内层循环遍历背包容量。
返回结果： 最终结果存储在dp[N][W]中，其中N为物品数量，W为背包容量。
例子：
假设有如下物品：
物品1：重量=2，价值=3 物品2：重量=3，价值=4 物品3：重量=4，价值=5 背包容量为W=8，我们要求解在这个条件下的最大总价值。
按照上述动态规划解法，构建状态转移表如下：
重量/价值 0 1 2 3 4 5 6 7 8 ---------------------------------------------- 物品0 0 0 0 0 0 0 0 0 0 物品1 0 0 3 6 9 12 15 18 21 物品2 0 0 3 6 9 12 15 18 21 物品3 0 0 3 6 9 12 15 18 21 因此，最终结果为dp[3][8] = 21，表示在背包容量为8的情况下，最大总价值为21。这意味着最优解是选择物品1，物品2和物品3各两件放入背包。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c6a1572196720429cb571678affd2e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f869a01997f24b768b26ec29aae6449d/" rel="bookmark">
			算法沉淀——动态规划之01背包问题（leetcode真题剖析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法沉淀——动态规划之01背包问题 01.【模板】01背包02.分割等和子集03.目标和04.最后一块石头的重量 II 01背包问题是一类经典的动态规划问题，通常描述为：有一个固定容量的背包，以及一组物品，每件物品都有重量和价值，目标是找到在背包容量范围内，使得背包中的物品总价值最大的组合。 具体来说，问题的输入包括：
一个固定容量的背包（通常表示为一个整数W）。一组物品，每个物品有两个属性：重量（通常表示为一个整数weight）和价值（通常表示为一个整数value）。求解的目标是找到一种放置物品的方式，使得放入背包的物品的总重量不超过背包容量，并且总价值最大。 这个问题的特点是，对于每件物品，你只能选择将其放入背包一次（0-1，因此称为“01背包”），或者不放入背包。不能将物品切割成更小的部分放入背包，要么整个物品放入背包，要么不放入。
动态规划解法：
定义状态： 通常使用二维数组dp[i][j]表示在前i个物品中，背包容量为j时的最大总价值。
状态转移方程： 考虑第i个物品，可以选择放入背包或者不放入。如果选择放入，那么总价值为dp[i-1][j-weight[i]] + value[i]，即前i-1个物品的总价值加上当前物品的价值。如果选择不放入，那么总价值为dp[i-1][j]，即前i-1个物品的总价值。因此，状态转移方程为：
dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i]) 其中，dp[i-1][j]表示不放入第i个物品，dp[i-1][j-weight[i]] + value[i]表示放入第i个物品。
初始条件： 当i=0时，表示前0个物品，总价值为0；当j=0时，表示背包容量为0，总价值也为0。
遍历顺序： 外层循环遍历物品，内层循环遍历背包容量。
返回结果： 最终结果存储在dp[N][W]中，其中N为物品数量，W为背包容量。
例子：
假设有如下物品：
Copy code解释物品1：重量=2，价值=3 物品2：重量=3，价值=4 物品3：重量=4，价值=5 物品4：重量=5，价值=6 背包容量为W=8，我们要求解在这个条件下的最大总价值。
按照上述动态规划解法，构建状态转移表如下：
luaCopy code解释 重量/价值 0 1 2 3 4 5 6 7 8 ---------------------------------------------- 物品0 0 0 0 0 0 0 0 0 0 物品1 0 0 3 3 3 3 3 3 3 物品2 0 0 3 4 4 7 7 7 10 物品3 0 0 3 4 4 7 8 8 11 物品4 0 0 3 4 4 7 8 9 11 因此，最终结果为dp[4][8] = 11，表示在背包容量为8的情况下，最大总价值为11。这意味着最优解是选择物品2和物品4放入背包。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f869a01997f24b768b26ec29aae6449d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13dd64f6c05603f908e7b3349f81fe0e/" rel="bookmark">
			微信开发者工具下载及小程序项目的创建与调试（完整图文教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. 微信开发者工具下载2. 创建小程序项目3.文件目录结构介绍3.1 主体文件3.2 页面文件3.3 公共文件3.4 渲染模式3.4.1 Skyline 渲染模式3.4.2 WebView 渲染模式3.4.3 切换渲染模式 4.新建页面4.1 第一种方法4.2 第二种方法 5.小程序基础库5.1 调试基础库 6.小程序调试6.1 模拟器6.2 调试器6.3 编译6.4 预览6.5 真机调试6.6 清缓存 总结引用资料最后 前言 每每有工具下载相关博客必有一句话：工欲善其事，必先利其器。
承接上文，本文将介绍微信开发者工具下载及小程序项目结构与工具的详细讲解，使得更容易能够在这个平台上创造出优秀的小程序产品。
1. 微信开发者工具下载 前往开发者工具下载页面,根据自己的操作系统下载对应的安装包进行安装，有关开发者工具更详细的介绍可以查看 。
微信开发者工具是微信官方推出的一款强大的开发辅助工具。它极大地简化了微信小程序的开发流程，包括代码的编写、查看、编辑，以及小程序的预览和发布等操作。为了满足不同开发者的需求，微信开发者工具提供了三个版本，每个版本都有其特定的用途和目标用户：
稳定版（推荐）
特点：如其名，稳定版的最大特点是稳定性高。它通过了广泛的测试，确保了在正式发布之前各项功能都能稳定运行。预发布版
特点：预发布版通常包含了即将推出的新特性，这些特性已经通过了内部测试，稳定性较好，但仍可能存在一些未知的问题。开发版
特点：开发版的更新频率最高，它主要用于快速修复已知缺陷和上线新的小特性。由于重点在于快速迭代，稳定性相对较差。 注意事项:微信开发者工具必须联网使用!
安装过程十分简单，省略不必要的赘述。
安装后打开微信开发者工具，使用微信扫码登录即可。
2. 创建小程序项目 打开微信开发者工具，左侧选择小程序，点击+号即可新建项目。
弹出新页面，填写项目相关信息（建议使用空目录下创建）与申请的AppID（AppID不懂可看上一篇文章），点击确认。
完成创建。
视图=&gt;外观,可把视图调整到右侧。
设置=&gt;编译器设置，可调整代码行高与间距。
3.文件目录结构介绍 使用过其他框架的同学们都知道，学习新框架了解其中目录结构是必不可少的。
在微信小程序开发中，一个完整的项目架构被明确地分为两大部分：主体文件（全局文件）和页面文件。这种划分有助于开发者更加系统地组织代码和资源，确保小程序的开发既高效又易于管理。
3.1 主体文件 这些文件必须被放置在项目的根目录下，以确保小程序在启动时能够正确地加载和解析它们。主体文件主要由以下三个部分组成：
app.js：这是小程序的入口文件。它的主要作用是初始化小程序实例，并提供一个全局的方法和属性。在app.js中，开发者可以设置全局数据和处理全局事件，如小程序启动、前台显示、后台隐藏等。app.json：这是小程序的全局配置文件。它用于对小程序进行全局性的设置，包括窗口表现、页面路径、网络超时时间、底部 tab 等。app.json中的配置项会影响到小程序的多个方面，因此是控制小程序行为的关键文件。app.wxss：这是小程序的全局样式文件。与Web开发中的CSS文件相似，app.wxss允许开发者定义全局的样式规则，这些规则将应用于小程序内的所有页面。通过使用app.wxss，开发者可以确保小程序具有一致的视觉风格，同时也可以减少页面文件中样式的重复定义。
注意事项:主体文件的名字必须是 app，app.js 和 app.json 文件是必须的!
3.2 页面文件 页面文件 是每个页面所需的文件，小程序页面文件都存放在 pages 目录下，一个页面一个文件夹。
每个页面由四个文件构成，这些文件仅对当前页面有效，它们协同工作，描述了页面的结构、样式、逻辑和配置：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13dd64f6c05603f908e7b3349f81fe0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f709bc2d15cf5a061f3cd73694ee3a4e/" rel="bookmark">
			Java - List排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		List排序方法
主要有三种方法（按推荐度排序）：
JDK8的streamComparator#compare()Comparable#compareTo() 法1：list的sort() package com.example.a; import java.util.ArrayList; import java.util.Comparator; import java.util.List; class User{ private Integer score; private Integer age; public User(Integer score, Integer age){ super(); this.score = score; this.age = age; } public Integer getScore() { return score; } public void setScore(Integer score) { this.score = score; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } } public class Demo { public static void main(String[] args) { List&lt;User&gt; users = new ArrayList&lt;&gt;(); users.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f709bc2d15cf5a061f3cd73694ee3a4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e61ecd15b1d6902b7951015ce8af3f6/" rel="bookmark">
			一个强大的 VS Code 的AI代码插件：Fitten Code
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AI 代码助手有 GitHub Copilot，一直想用，但是要爬梯子，还要收费。
一款国产AI写代码神器 Fitten Code，满足了我对AI写代码的幻想。它在功能上基本和 GitHub Copilot 差不多。
重要是的是，免费，免费，完全免费！啊啊啊啊啊~~~~
官网：免费好用的AI编程助手 - Fitten Code
Fitten Code 是一个由国内非十科技自研代码大模型驱动的 AI 代码助手。它支持多种语言，包括 Python、JavaScript、TypeScript、Java、C、C++ 等。使用 Fitten Code，你可以自动进行代码补全，并可以在 Visual Studio Code 侧边栏内生成代码、生成注释、编辑代码、解释代码、生成测试、查找错误等。
能自动补全代码不说，还能根据注释生成代码。如下图所示：
它在 VScode 、JetBrain 上面都可以免费安装插件。微信扫码登录后，就可以直接用了。
赶紧用起来吧~
-------题外话-----
我写这个博文真的很纠结，要是我的学生用这个糊弄我怎么办？？？
阿西吧~
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/486/">«</a>
	<span class="pagination__item pagination__item--current">487/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/488/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>