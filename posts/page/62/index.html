<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77f1f34a6d454d43b5180ff6472403ab/" rel="bookmark">
			JUC（java.util.concurrent）的常见类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 ​前言
Callable和Future
Callable
Future
使用Callable和FutureTask
ReentrantLock
ReentrantLock和synchronized的区别
如何选择使用哪个锁？
原子类
线程池
Semaphore（信号量）
CountDownLatch
相关面试题
1.线程同步的方式有哪些？
2.为什么有了synchronized还需要JUC下的lock？
3.AtomicInteger 的实现原理是什么？
4) 信号量听说过么？之前都用在过哪些场景下？
5. 解释⼀下ThreadPoolExecutor构造⽅法的参数的含义
前言 在前面我们已经学习java.util.concurrent包（实现多线程并发编程常用的包）中的一些操作，例如线程池、阻塞队列等，那么本篇我们就来学习一下JUC中几种其他常见的类。
Callable和Future Callable Callable是一个泛型接口，只有一个方法 call().用于创建可以返回结果的任务，与Runnable不同，Callable可以返回一个结果，并且可以抛出异常，需要依赖FutureTask类来获取返回结果。
我们查看Callable的接口定义：
在使用Callable接口的时候，我们需要将我们的任务需求编写到call()方法中。
示例：现在要计算从1加到1000的和
class Demo1 { public static void main(String[] args) throws ExecutionException, InterruptedException { Callable&lt;Integer&gt; call = new Callable&lt;Integer&gt;() { @Override public Integer call() throws Exception { int sum = 0; for (int i = 0; i &lt;= 1000; i++) { sum += i; } return sum; } }; } } 在这个代码中，我们实现了从1加到1000的和的计算，当在完成计算之后，会返回一个Integer类型的数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77f1f34a6d454d43b5180ff6472403ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/514ea46ca2e94557cd1b2fadfc1f6c29/" rel="bookmark">
			大数据知识图谱之深度学习：基于BERT&#43;LSTM&#43;CRF深度学习识别模型医疗知识图谱问答可视化系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 大数据知识图谱之深度学习：基于BERT+LSTM+CRF深度学习识别模型医疗知识图谱问答可视化系统一、项目概述二、系统实现基本流程三、项目工具所用的版本号四、所需要软件的安装和使用五、开发技术简介Django技术介绍Neo4j数据库Bootstrap4框架Echarts简介Navicat Premium 15简介Layui简介Python语言介绍MySQL数据库深度学习 六、核心理论贪心算法Aho-Corasick算法BERT（Bidirectional Encoder Representations from Transformers）长短时记忆网络（Long Short-Term Memory，LSTM）条件随机场（Conditional Random Field，CRF）命名实体识别实体对齐语义知识库问答 七、系统实现八、结语 大数据知识图谱之深度学习：基于BERT+LSTM+CRF深度学习识别模型医疗知识图谱问答可视化系统 一、项目概述 知识图谱是将知识连接起来形成的一个网络。由节点和边组成，节点是实体，边是两个实体的关系，节点和边都可以有属性。知识图谱除了可以查询实体的属性外，还可以很方便的从一个实体通过遍历关系的方式找到相关的实体及属性信息。
BERT是一种基于Transformer 架构的预训练语言模型，能够捕捉双向上下文信息。BERT 模型在大规模语料上进行预训练，然后可以通过微调来适应特定任务,BERT 可用于处理输入文本，提取丰富的语义信息。它可以用于文本的编码和表征学习，以便更好地理解医学问答中的问题和回答。LSTM 是一种递归神经网络（RNN）的变体，专门设计用于处理序列数据。它通过使用门控机制来捕捉长期依赖关系，适用于处理时间序列和自然语言等序列数据。 LSTM 可以用于处理医学文本中的序列信息，例如病历、症状描述等。它有助于保留文本中的上下文信息，提高模型对长文本的理解能力。CRF 是一种用于标注序列数据的统计建模方法。在序列标注任务中，CRF 能够考虑标签之间的依赖关系，从而更好地捕捉序列结构。 在医学文本中，CRF 可以用于命名实体识别（NER）任务，例如识别疾病、药物、实验室结果等实体。通过引入CRF层，可以提高标签之间的一致性和整体序列标注的准确性。
基于BERT+LSTM+CRF深度学习识别模型医疗知识图谱问答可视化系统通过构建医疗领域的知识图谱来实现计算机的深度学习，并且能够实现自动问答的功能。本次的内容研究主要是通过以Python技术来对医疗相关内容进行数据的爬取，通过爬取足量的数据来进行知识图谱的的搭建，基于Python语言通过echarts、Neo4j来实现知识图谱的可视化。通过智慧问答的方式构建出以BERT+LSTM+CRF的深度学习识别模型，从而完成对医疗问句主体的识别，构建出数据集以及实现文本的训练。通过Django来进行web网页的开发，通过面向用户的网页端开发使用来满足用户医疗问答的需要。
二、系统实现基本流程 配置好所需要的环境（jdk1.8,neo4j,pycharm,python等）爬取所需要的医学数据，获取所需基本的医疗数据。对医疗数据进行数据清洗处理。关系抽取定义与实体识别等。基于BERT+LSTM+CRF深度学习知识图谱建模。数据可视化、深度学习问答、问句分析可视化、知识图谱可视化等。知识问句分析管理、系统用户管理等功能完善做出一个完整的基于BERT+LSTM+CRF深度学习识别模型医疗知识图谱问答可视化系统。 三、项目工具所用的版本号 Neo4j版本：Neo4j Desktop1.5.6或者neo4j-community-3.1.0都可以;
neo4j里面医疗系统数据库版本：3.1.0;
Pycharm版本：2021.2.1;
JDK版本：jdk1.8.0_211;
MongoDB版本：MongoDB-windows-x86_64-5.0.14;
Django版本:3.2.8
四、所需要软件的安装和使用 (一)安装JAVA
1.下载java安装包：
官网下载链接：https://www.oracle.com/java/technologies/javase-downloads.html
配置的话这里不再过多描述，之前写过详细的JDK配置，可以看一下
附链接：
JDK的环境配置（超级详细教程）
neo4j数据库所用的是neo4j-community-3.1.0版本，目录参数信息如下：
五、开发技术简介 Django技术介绍 Django是一个开放源代码的Web应用框架，由Python写成。采用了MVC的软件设计模式，即模型M，视图V和控制器C。Django 框架的核心组件有：
用于创建模型的对象关系映射
为最终用户设计的完美管理界面
一流的 URL 设计
设计者友好的模板语言
缓存系统。
在Django中，控制器接受用户输入的部分由框架自行处理，所以 Django 里更关注的是模型（Model）、模板(Template)和视图（Views），称为 MTV模式。它们各自的职责如下：
层次模型（Model），即数据存取层模板(Template)，即表现层视图（View），即业务逻辑层 模型（Model），即数据存取层 处理与数据相关的所有事务： 如何存取、如何验证有效性、包含哪些行为以及数据之间的关系等。
模板(Template)，即表现层 处理与表现相关的决定： 如何在页面或其他类型文档中进行显示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/514ea46ca2e94557cd1b2fadfc1f6c29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abf7383e6ff5d4b7aad9adc463ee14a4/" rel="bookmark">
			【语义通信】灵（Genie）——6G的第四维元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 6G 不仅包含 5G 涉及的人类社会、信息空间、 物理世界（人、机、物）这 3 个核心元素，还第四维元素—灵（Genie）。Genie存在于虚拟世界体系，虚拟世界体系包括（VPS, VBS, VSS），不需要人工参与即可实现通信和决策制定。
“灵”指的是一种高级的触觉互联网架构，其中包括虚拟现实（Virtual Reality）、可穿戴技术（Wearables Technology）、触觉机器人（Tactile Robots）、物联网（Internet of Things）等技术的融合。这些技术通过5G网络、云计算（Cloud Computing）、高性能计算（High Performance Computing）和机器智能（Machine Intelligence）进行连接和协同工作，形成一个“人-机集体”（Human-Robot Collective）。
“灵” 可以理解为一种远程操控的虚拟化身（Tactile Avatar），用户通过虚拟现实设备或其他可穿戴设备控制机器人或其他物联网设备，在全球范围内实时互动和执行任务。这种技术将允许用户在物理上不在场的情况下，通过这些虚拟化身与远程环境或设备进行触觉互动，仿佛他们亲自参与其中。
6G通信技术预计将引入“灵”作为一个具有智能的通信实体，这一概念旨在打破传统的通信和控制范式，通过增加“意识”的元素来丰富和提升网络的功能性和互动性。
例如，在通信系统中，为了实现 “人 - 机 - 物 - 灵” 四类通信对象之间会产生大量不同形态的数据，打破了传统的经典通信系统，各种对象之间的通信不再仅仅是传输比特数据，而是借助其 “智能” 特性实现以 “达意” 为目标的语义通信。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf5c1056a154a7873cdc8f32a14b61f0/" rel="bookmark">
			论文笔记：YOLOv8-QSD 自动驾驶场景小目标检测算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 YOLOv8-QSD网络是一种新型的无锚点驾驶场景检测网络，建立在YOLOv8的基础上，在保证检测精度的同时保持效率。该网络的骨干网采用结构重参数化技术来转换基于多样化分支块 （DBB） 的模型。
为了准确检测小目标，它集成了不同尺度的特征，并在骨干之后实现了基于双向特征金字塔网络（BiFPN）的特征金字塔。
此外，还提出了一个动态头部(DyHead)，包含了尺度感知、空间感知和任务感知的注意力机制，以进一步优化特征提取和分类过程。为了解决驾驶场景中远程检测（商业车辆需要更大的视野）的挑战，该文引入新的查询模型（Q-block）和管道结构以解决长距离检测挑战。
测试结果表明，该算法在大规模小目标检测数据集（SODA-A）上的性能无论在速度还是准确率上都优于YOLOv8。 准确率达64.5%，计算量降低7.1 GFLOPs。
YOLOv8与YOLOv8-QSD网络图对比 算法 难点 由于小对象的像素尺寸较小，想要从小目标中提取准确、全面的特征尤为重要。在复杂环境中，从重叠对象中提取特征要求更高，往往导致跨算法的小目标检测精度降低。
目标检测中对于小物体的检测精度较低以及计算量较大的问题。
QueryDet
为解决 级联特征金字塔检测中检测小物体的困难 提出了QueryDet
最常见和最有效的方法包括使用高分辨率的图像或特征图。然而，这两种方法都有很高的计算成本，这与图像和特征图的大小成比例，特别是在一个结构化的特征金字塔中。
neck缺陷
原始的YOLOv8网络采用PAFPN作为neck网络，通过双向聚合来自底部和顶部路径的特征来融合低级别和高级别信息，从而有效地缩短了信息路径。然而，在像素级别的分辨率下，直接将p3层与目标层进行融合并不能充分满足定位信息的要求，并且直接融合p2层会显著增加参数数量。
解决方法 YOLOv8-QSD利用DBB骨干进行鲁棒特征提取，在检测颈部细化特征金字塔结构，集成Q-block和Dy-head模块，T替换损失函数，提高整体目标检测能力
neck 以大规模特征图为重点，引入了Bi-PAN-FPN 的思想，以改进YOLOv8的特征融合方法。这一改进增强了模型检测小物体的能力，提高了多尺度特征融合的可能性和效率，并导致增强了特征工程。YOLOv8特征融合方法的增强无缝集成了浅层和深度信息，在网络特征提取过程中实现了更彻底的信息保存，从而解决了定位不准确和后续检测缺失引起的问题。
（a）FPN. (b) PAN. (c) YOLOv8（PAFPN）(d) YOLOv8-QSD.
在(a)中，FPN构建了一个自上而下的特征金字塔，在不同层次的特征图之间添加横向连接，以更好地利用低层次特征中包含的高频细节，从而形成一个包含多尺度信息的特征金字塔。
在(b)中，金字塔注意网络（PAN）在编码器和解码器之间整合了路径聚合模块，以聚合不同尺度的特征，生成具有多个分辨率的特征图。这种层次特征金字塔结构利用了不同尺度的特征，提高了语义分割的准确性。
在(c)中，YOLOv8结合了SPP和PAN，提高了目标检测的准确性和效率。
在(d)中，是YOLOv8-QSD采用的特征融合方法。对于p2层中的特征，我们首先应用一个带有查询机制的q-block来获得与小目标相关的粗糙特征映射。随后，利用自稀疏融合操作（F-fusion）将特征集成到目标特征层中。该方法改善小目标的的检测速度和精度对齐，同时显著减少了模型的参数计数。同时，串联模式是一种自适应的空间融合操作。使用这种显式查询机制可以检测到类似于p2层的特征，而不需要只依赖于p2层本身。这种实质性的增强显著地提高了模型的准确性，同时保持了其实时性能。
左边的输入由处理过的细粒度特征图组成，而右边的输入表示通过粗查询获得的关键值的子集。基于粗查询，这些关键值表示得分较高的区域，它们更有可能包含小目标。通过查询模块进行处理后，从细粒度的特征映射中提取这些区域。然后，对这些区域进行了高分辨率的检测，从而提高了检测性能。
PyHead 表示在特征映射的不同层次上执行的动态头部操作。它包含注意机制和动态卷积，用来处理统一对象模型中的尺度意识、空间意识和任务意识。其目的是提高探测器对小物体相关特征的灵敏度。
引入了一个动态的Query-aware稀疏注意力机制，以过滤掉不相关的键值对，从而提高了模型的检测能力，特别是对于小目标。（将定位不佳的层重新输入网络，以提高小目标的定位精度）。它补充了各模块中降采样时丢失的信息，确保了在特征提取过程中对上下文信息进行了更全面的保存。
尺度感知注意机制强调动态多尺度融合的语义权重。利用硬s型函数，在保持计算效率的同时引入非线性。线性函数f（·）采用卷积层进行逼近，使模型能够根据语义信息自适应地调整注意力权重。这种注意机制旨在在特征融合过程中实现尺度感知，使模型能够有效地捕获不同尺度下的特征，并在目标检测过程中做出明智的决策。利用语义权值增加了对相关特征的敏感性，并提高了检测性能，特别是对于不同尺度的对象。
DBB DBB模块利用了两个重要的卷积特性：同质性和可加性。根据同质性原理，
C2f-DBB体系结构是一种将C2f模块与DBB相结合的模型配置。在这个结构中，瓶颈模块中原来的conv操作被替换为DBB。C2f-DBB体系结构的设计目标是保持模型的轻量级，同时提高其对长距离和低像素分辨率的小物体的检测性能。通过将C2f模块和DBB相结合，我们的目标是生成更全面的特征表示，提高模型的通用性，从而在高速公路上商用车的长距离小物体检测方面具有优越的性能。DBB模块增强了模型的通用化性，从而增强了其鲁棒性，同时增加了参数的数量。这种自适应使模型更容易地部署在边缘设备上，从而放大其实时性能，同时轻量化。
将YOLOv8中的C2f模块替换为建议的C2f-DBB模块。通过叠加模块并连续融合每个小模块，产生了一种新的网络结构。这增加了结构的整体深度，以更低的计算成本实现了更高的分辨率，并捕获了更多的上下文信息。
损失函数 下图突出了小物体位移的极端敏感性。
通过结合NWD的分布测量能力和wise-IoU（适合于SOD的IoU）的定位能力，改善了NWD的损失。这种协同改进通过在精确评估目标分布和精确定位小物体之间取得平衡，确保了对小物体的有效目标检测。提高模型对小物体的敏感性，同时减少假阳性预测，最小化不同物体大小之间的敏感性差异
大多数真实的小目标并不严格遵守一个矩形的形状，因此经常包含在边界框内的上下文像素。提出了一种将边界盒建模为二维高斯分布的合适方法，以更准确地描述边界盒内不同像素之间的权重分布。在该模型中，边界框的中心像素的权重最大（焦点损失），像素的重要性随着它们远离中心的移动而降低。这种建模方法有效地降低了小物体对iou的敏感性，增加模型对小物体的敏感度并降低假阳性预测的数量，提高对小目标的检测能力，显著减少网络推理的计算负荷。
实验 使用两个交通场景下的目标检测的数据集——SODA-D和VisDrone。
其中，SODA-D包含24828张高质量的交通图像，涵盖了九个不同的类别，并且对小物体进行了细致的注释。而VisDrone则是一个专门用于无人机拍摄的图像数据集，包含了10209张静态图像，共有十个不同的物体类别。
这两个数据集都强调了对于小物体的检测能力，并且在不同光照、遮挡等复杂情况下都有一定的挑战性。这些数据集可以被用来评估目标检测算法的性能表现。
YOLOv8-QSD的检测结果及基线方法
第一行是YOLOv8-QSD模型进行的检测的结果，第二行是基线方法的结果。（分别是白天和夜晚，长焦与短焦的检测）
表一列出了YOLOv8-QSD与VisDrone数据集上的基线算法之间的检测精度的比较
表二列出了YOLOv8-QSD与SODA数据集上的基线算法之间的检测精度的比较
表三给出了SODA数据集上的其他算法与YOLOv8-QSD之间的比较
可以很好的看出YOLOv8-QSD的优势
总结 创新点
将C2f改为C2f-DBB网络，用于检测驾驶场景中的远处小物体。其是在训练过程中采用多分支结构，在推理过程中采用单分支结构。DBB通过不同尺度和复杂度的分支组合，能够从多个角度和层次学习特征，从而丰富了特征空间。这种多样化的学习能够帮助模型更好地捕捉到输入数据的复杂结构，提高模型的表达能力。
其次，还引入了一个名为Q-block的新模块来优化小物体的BIFPN，并提高了在驾驶场景中检测远处小物体的性能。
提出了DyHead，包含了尺度感知、空间感知和任务感知的注意力机制，以进一步优化特征提取和分类过程。为了解决驾驶场景中远程检测的挑战，该文引入新的Q-block和管道结构以解决长距离检测挑战。最后改善损失函数降低iou对小目标的敏感。
实验结果表明，所提出的YOLOv8-QSD网络优于其他针对远处小目标设计的检测网络，同时实现了显著的轻量级特性。
改进方向
要求更高清晰度的图像才能产生最佳结果，以及在遇到抖动场景时需要增强其鲁棒性。
进一步简化q块结构，并增加显式补偿模块，改善模型对抖动的鲁棒性。
探索当前基于NMS的处理的替代解决方案，例如考虑一种类似于detr的方法来减少后处理阶段的推理损失。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf5c1056a154a7873cdc8f32a14b61f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39cc534bf82c340c5942a6c91a2d2581/" rel="bookmark">
			杂谈c语言——4.结构体和联合体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两者最大的区别在于内存利用
1.struct &amp;&amp; union 一、结构体struct
各成员各自拥有自己的内存，各自使用互不干涉，同时存在的，遵循内存对齐原则。一个struct变量的总长度等于所有成员的长度之和。
二、联合体union
各成员共用一块内存空间，并且同时只有一个成员可以得到这块内存的使用权(对该内存的读写)，各变量共用一个内存首地址。因而，联合体比结构体更节约内存。一个union变量的总长度至少能容纳最大的成员变量，而且要满足是所有成员变量类型大小的整数倍。不允许对联合体变量名U2直接赋值或其他操作。
1.对比struct和union占用内存大小
#include&lt;stdio.h&gt; //结构体 struct u //u表示结构体类型名 { char a; //a表示结构体成员名 int b; short c; }U1; //U1表示结构体变量名 //访问该结构体内部成员时可以采用U1.a=1;其中"点"表示结构体成员运算符 //联合体 union u1 //u1表示联合体类型名 { char a; //a表示联合体成员名 int b; short c; }U2; //U2表示联合体变量名 //访问该联合体内部成员时可以采用U2.a=1;其中"点"表示联合体成员运算符 //主函数 int main(){ printf("%d\n",sizeof(U1)); printf("%d\n",sizeof(U2)); return 0; } /*程序运行结果是： 12 4*/ 1.1 联合体的特点 联合的成员是共⽤同⼀块内存空间的，这样⼀个联合变量的⼤⼩，⾄少是最⼤成员的⼤⼩（因为联合 ⾄少得有能⼒保存最⼤的那个成员）。
//代码1 #include &lt;stdio.h&gt; //联合类型的声明 union Un { char c; int i; }; int main() { //联合变量的定义 union Un un = {0}; // 下⾯输出的结果是⼀样的吗？ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39cc534bf82c340c5942a6c91a2d2581/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cdda8c70e7faf9287c7f2ace80829a3/" rel="bookmark">
			大数据机器学习算法岗位分析推荐：基于Python的招聘大数据爬虫可视化分析推荐系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 大数据推荐算法招聘数据分析：基于Python招聘大数据爬虫数据可视化分析推荐系统一、项目概述二、项目说明三、研究意义四、系统总体架构设计总体框架技术架构 五、部分模块核心代码六、数据采集模块七、数据管理模块八、部分数据展示九、项目截图系统用户登录系统控制台首页招聘岗位薪资待遇可视化分析招聘岗位学历要求数据可视化分析招聘职位关键字可视化分析岗位数据不同维度参数数据检索系统招聘数据爬虫调度求职意向分析机器学习协同过滤算法职位推荐招聘岗位求职投递信息 十、结语 大数据推荐算法招聘数据分析：基于Python招聘大数据爬虫数据可视化分析推荐系统 一、项目概述 系统涵盖了多个关键功能，包括使用selenium库进行数据爬取、爬虫调度、以及在前端页面上选择不同的城市、爬取页数和职位关键字进行数据爬取。此外，系统还包括数据管理和可视化功能，能够对薪资待遇、学历分布和职位关键字进行可视化分析。为了进一步提升系统的智能化，使用了机器学习算法中的协同过滤来实现selenium功能。具体而言，该功能支持用户设置求职意向，并根据用户的需求为其推荐相关职位，并将推荐结果展示在求职列表中。在后台管理方面，系统提供了用户设置和管理功能，方便用户自定义各项参数以及管理已爬取的数据。需要注意的是，系统主要针对猎聘网进行数据爬取。通过本次毕设的研究和开发，旨在构建一个功能完善、易用且具有实际应用价值的招聘数据爬虫可视化分析推荐系统。通过该系统，用户能够灵活地进行数据爬取，并通过可视化分析洞察行业动态。机器学习算法的应用则为用户提供了个性化的职位推荐，让求职过程更加高效和精准。
二、项目说明 随着互联网的快速发展，招聘行业正经历着数字化转型的进程。在线招聘平台成为求职者和招聘企业之间联系的重要桥梁。然而，现有的招聘数据常常分散在不同的网站和平台中，手动收集和整理这些数据变得非常耗时且容易出错。因此，开发一种高效、自动化的招聘数据爬虫可视化分析推荐系统对于提升招聘过程的效率和准确性具有重要意义。
本研究旨在基于Python构建招聘数据爬虫可视化分析推荐系统，其中包含了selenium爬虫和爬虫调度等核心功能。通过使用Python中的selenium库，们能够自动获取并爬取猎聘网等主要招聘网站上的数据。爬虫调度模块允许用户在前端页面选择不同的城市、爬取页数和职位关键字，从而实现灵活的数据爬取。除了数据爬取，系统还提供了数据管理功能，确保爬取到的数据的完整性和一致性。另外，系统还支持数据可视化功能，包括薪资待遇、学历分布和职位关键字的可视化分析。通过这些功能，用户可以更直观地了解招聘市场的薪资水平，不同学历的需求趋势以及职位关键字的热门程度，从而做出更明智的职业规划和求职决策。本研究还引入了机器学习算法中的协同过滤技术，以提供个性化的职位推荐服务。用户可以设置自己的求职意向，系统将根据用户的需求以及历史数据分析，为其推荐最相关的职位，并将这些推荐结果展示在求职列表中。这种职位推荐技术将大大提高求职者的匹配度和成功率，为他们节省时间和精力。
三、研究意义 该系统将通过整合爬虫技术和数据分析方法，实现对招聘信息的自动化获取、清洗和分析，为求职者提供更加准确、全面的职业发展支持。此外，系统中的机器学习算法还将根据用户的个人需求和行为习惯，为其提供个性化的职位推荐，有助于提升求职匹配度和成功率。因此，本研究的意义在于为求职者提供更加便捷、智能的求职服务，促进社会经济的健康发展。
四、系统总体架构设计 总体框架 技术架构 五、部分模块核心代码 # 计算相似度 def similarity(job1_id, job2_id): job1_set = models.SendList.objects.filter(job=job1_id) # job1的投递用户数 job1_sum = job1_set.count() # job2的打分用户数 job2_sum = models.SendList.objects.filter(job=job2_id).count() # 两者的交集 common = models.SendList.objects.filter(user__in=Subquery(job1_set.values('user')), job=job2_id).values('user').count() # 没有人投递当前职位 if job1_sum == 0 or job2_sum == 0: return 0 similar_value = common / sqrt(job1_sum * job2_sum) # 余弦计算相似度 return similar_value # 协同过滤推荐算法 def recommend_by_item_id(user_id, k=9): jobs_id = models.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cdda8c70e7faf9287c7f2ace80829a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8730ded4fa41f720a32d1221a7155718/" rel="bookmark">
			Django框架中的：QueryDict（处理url参数）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 QueryDictQueryDict的参数特性urlencode方法 QueryDict QueryDict 是 Django 框架中用来处理 URL 查询字符串的一种数据结构。它用于表示 Web 请求中的查询字符串（即 URL 中 ? 后面的部分） print(type(request.GET)) # &lt;class 'django.http.request.QueryDict'&gt; QueryDict的参数特性 默认QueryDict不允许被修改 _mutable=False
request.GET._mutable = True
设置值
request.GET.setlist(“name”,[123]) # name=123
request.GET.setlist(“name”,[123,32]) # name=123&amp;name=32
调用urlencode方法，可以与原来url中的参数拼接
paramString = request.GET.urlencode()
print(paramString) “filter=wupeiqi&amp;age=19&amp;name=123”
import copy query_dict = copy.deepcopy(request.GET) query_dict._mutable = True query_dict.setlist('page', [1]) paramString = query_dict.urlencode() # "...&amp;page=1" query_dict._mutable = True query_dict.setlist('page', [2]) paramString = query_dict.urlencode() # "...&amp;&amp;page=2" request.GET._mutable = True request.GET.setlist('page', [3]) paramString = request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8730ded4fa41f720a32d1221a7155718/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ab8fc09479e384b781f36d681adc933/" rel="bookmark">
			ubuntu中设置开机自动运行的（sudo）指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu版本：22.04.4
在Ubuntu中设置开机自动运行某一条（需要sudo权限的）指令，我们可以通过编辑系统的启动脚本来实现：
创建一个新的启动脚本：创建一个新的脚本文件，并将其放置在 /etc/init.d/ 目录下。这个目录下的脚本会在系统启动时自动运行。
编写脚本内容：在脚本文件中输入希望在启动时运行的命令。假设想在启动时运行 sudo some_command，可以这样写：
#!/bin/sh ### BEGIN INIT INFO # Provides: my_startup_script # Required-Start: $local_fs $network $remote_fs # Required-Stop: $local_fs $network $remote_fs # Default-Start: 2 3 4 5 # Default-Stop: 0 1 6 # Short-Description: My startup script # Description: This script runs a command at startup. ### END INIT INFO case "$1" in start) echo "Starting my_startup_script" sudo some_command ;; stop) echo "Stopping my_startup_script" ;; restart) echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ab8fc09479e384b781f36d681adc933/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c33650ad70dd6abc14796bc4b756efe0/" rel="bookmark">
			【C&#43;&#43;】—— 类与对象（四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【C++】—— 类与对象（四） 6、赋值运算符重载6.1、运算符重载6.1.1、基础知识6.1.2、调用方法6.1.3、前置++ 与 后置++ 的重载6.1.4、注意事项6.1.5、&lt;&lt; 和 &gt;&gt; 运算符重载6.1.5.1、&lt;&lt; 和 &gt;&gt; 基础6.1.5.2、日期类 operator&lt;&lt; 的实现6.1.5.2.1、类型不匹配问题6.1.5.2.2、连续赋值问题 6.1.5.3、日期类 operator&gt;&gt; 的实现 6.1.6、总结 6.2、赋值运算符重载5.2.1、赋值运算符重载的特点6.2.1、赋值运算符重载进阶6.2.2、赋值重载拷贝与拷贝构造 7、日期类的完整实现7.1、Date.h7.2、Date.cpp 6、赋值运算符重载 6.1、运算符重载 6.1.1、基础知识 像+、— 、% 、&gt; 等运算符，只对内置有效，但对于自定义类型又该怎么办呢？
就拿 D a t e Date Date类 来说，日期与日期如何比较大小呢？简单地只使用一个 &gt;/&lt; 肯定是无法完成任务的。
解决上述问题，就需要用到 运算符重载
运算符重载的基本特点：
当运算符被用于类类型对象时，C++ 允许我们通过运算符重载的形式制定新的含义。C++ 规定类类型对象使用运算符时，必须转换成调用对应运算符重载，若没有对应的运算符重载，则会编译报错
运算符重载是具有特殊名字的函数，它的名字是由 o p e r a t o r operator operator 和后面要定义的运算符共同构成。和其他函数一样，它也有返回类型和参数列表以及函数体
重载运算符函数的参数个数和该运算符作用的运算对象一样多。一元运算符有一个参数，二元运算符有两个参数，二元运算符的左侧运算对象向传给第一个参数，右测运算对象传给第二个参数
如果一个重载运算符函数是成员函数，则它的第一个运算对象默认传给隐式的 t h i s this this指针，因此运算符重在作为成员函数是，参数比运算对象少一个。 我们先写一个运算符重载函数来判断两个日期是否相等
class Date { public: Date(int year = 2024, int month = 1, int day = 1) { _year = year; _month = month; _day = day; } private: int _year; int _month; int _day; }; bool operator==(const Date&amp; d1, const Date&amp; d2) { return d1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c33650ad70dd6abc14796bc4b756efe0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b122934de8e2969c599f46d6b47bcf0/" rel="bookmark">
			大数据-76 Kafka 高级特性 稳定性-消费重复 生产者、Broker、消费者 导致的重复消费问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点一下关注吧！！！非常感谢！！持续更新！！！ 目前已经更新到了： Hadoop（已更完）HDFS（已更完）MapReduce（已更完）Hive（已更完）Flume（已更完）Sqoop（已更完）Zookeeper（已更完）HBase（已更完）Redis （已更完）Kafka（正在更新…） 章节内容 上节我们完成了如下内容：
Kafka 一致性保证LogAndOffset(LEO)HightWatermark(HW)Leader和Follower何时更新 LEOLeader和Follower何时更新 HW 基本介绍 消息重复和丢失是Kafka中很常见的问题，主要发生在以下三个阶段：
生产者阶段Broke阶段消费者阶段 生产者阶段丢失 出现场景 生产者发送消息没有收到正确Broke的响应，导致生产者重试。
生产者发送出一条消息，Broker落盘以后因为网络等种种原因发送端得到一个发送失败的响应或者网络中断，然后生产者收到一个可恢复的Exception重试消息导致消息重复。
重试过程 上图说明：
new KafkaProducer()创建一个后台线程KafkaThread扫描RecordAccumulator中是否有消息调用KafkaProducer.send()发送消息，实际上只是把消息保存到RecordAccumulator中后台线程KafkaThread扫描到RecordAccumulator中有消息后，将消息发送到Kafka集群如果发送成功，那么返回成功如果发送失败，判断是否重试，如果不允许重试则失败。允许重试则再保存到RecordAccumulator中，等待后台线程KafkaThread扫描再次发送 可恢复异常 异常是 RetriableException类型 或者 TransactionManager允许重试，RetriableException类集成关系如下：
消息顺序问题 如果设置max.in.flight.requests.per.connection大于1（默认5，单个连接上发送的未确认的请求的最大数量，表示上一个发出的请求没有确认下一个请求又发出去了）。大于1可能会改变记录的顺序，因为如果将两个Batch发送到单个分区，第一个batch处理失败并重试，但是第二个batch处理成功，那么第二个batch处理中的记录可能先出现被消费掉。如果设置max.in.flight.requests.per.connection等于1，则可能会影响吞吐量，可以解决单个生产者发送顺序问题，如果多个生产者，生产者1先发送一个请求，生产者2后发送请求，此时生产者1返回可恢复异常，且重试成功，此时虽然1先发送，但是2是先被消费的。 解决方案 幂等性 启动Kafka幂等性：
enable.idempotence=trueack=allretries&gt;=1 ack=0且不重试 可能会丢失消息，适用于吞吐量指标重要性高于数据丢失，比如：日志采集。
生产者-Broker阶段丢失 出现场景 ack=0且不重试 生产者发送消息完，不管结果了，如果发送失败也就丢失了
ack=1, Leader宕机 生产者发送完消息，只等待Leader写入成功就返回了，Leader分区丢失了，此时Follower没来得及同步，消息丢失。
unclean.leader.election.enable配置为true 允许选举ISR以外的副本作为Leader，会导致数据丢失，默认为False。生产者发送异步消息，只等待Leader写入成功就返回，Leader分区丢失，此时ISR中就没有Follower，Leader从OSR中选举，因为OSR中本来就落后于Leader，造成了消息的丢失。
解决方案 禁用unclean选举 ACK=ALL ack=all 或者 -1tries &gt; 1unclean.leader.election.enable = false
生产者发送完消息后，等待Follower同步完再返回，如果异常则重试。副本的数量可能影响吞吐量，不超过5个，一般是3个。
不允许unclean的Leader参与选举。 min.insync.replicas &gt; 1 当生产者acks设置all（或-1）时，min.insync.replicas &gt; 1。指定确认消息写成功需要的最小副本数量。达不到这个最小值，生产者将引发一个异常。（可能是NotEnoughReplicas，可能是NotEnoughReplicasAfterAppend）。
当一起使用时，min.insync.replicas和ack允许执行更大的持久性保证。一个典型的场景是创建一个复制因子为3的主题，设置min.insync复制到2个，用all配置发送。将确保如果大多数副本没有收到写操作，则生产者将引发异常。
失败的offset单独记录 生产者发送消息，会自动重试，遇到不可能恢复异常会跳出。这是可以捕获异常记录到数据库或者缓存，进行单独的处理。
消费者数据重复场景 出现场景 数据消费完没有及时的提交offset到Broker。
消费消息端在消费过程中挂掉没有及时的提交offset到Broker，另一个消费端启动之后拿到之前的offset记录开始消费，由于offset的滞后性可能会导致启动的客户端有少量的重复消费。
解决方案 取消自动提交 每次消费完或者程序退出时手动提交，这可能也没法保证一条重复。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b122934de8e2969c599f46d6b47bcf0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e270be4cac88ca564bfb9cefebb3935/" rel="bookmark">
			AI大模型额外学习一：斯坦福AI西部世界小镇笔记（包括部署和源码分析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、简单介绍1）项目代码介绍2）重新播放模拟3）适当修改分叉模拟 二、部署斯坦福小镇Demo1）准备工作2）解决遇到的bug3）启动服务器和前端 三、源码剖析1）主题顺序 四、总结分析1）缺点2）太吾绘卷是怎么做的(根据年龄去驱动)3）一些思考 github链接
一、简单介绍 ①背景介绍
This repository accompanies our research paper titled “Generative Agents: Interactive Simulacra of Human Behavior.” It contains our core simulation module for generative agents—computational agents that simulate believable human behaviors—and their game environment.
②总体逻辑
让小镇的NPC自由交流、开party、生活有条不紊
③总结：
Ai会感知周边环境，并将视野里发生的事件记录下来，加入自己的记忆流。之后，不论是Ai计划要做的事，还是对外界的反应，都会受到这个记忆的影响，并依靠ChatGPT进行决策，最后决策的事件也会加入记忆流，形成新的记忆。让NPC具备记忆系统，并依靠大语言模型来帮助NPC做出行动决策
https://github.com/joonspk-research/generative_agents/tree/main
https://www.zhihu.com/question/425708656
https://github.com/joonspk-research/generative_agents/tree/main
https://github.com/search?q=generative-agents&amp;type=repositories
1）项目代码介绍 ①项目有后端服务器backend_server和前端服务器frontend_server
②storage会保存程序运行的记录信息
2）重新播放模拟 打开浏览器，输入
http://localhost:8000/replay/&lt;simulation-name&gt;/&lt;starting-time_step&gt; 3）适当修改分叉模拟 这里的模拟是Isabella，scratch.json里面包括人物性格描述、居住地点、生活方式等，
spatial_memory.json里面还有房间布局等等
二、部署斯坦福小镇Demo 1）准备工作 ①安装aneconda
②下载仓库代码
git clone https://github.com/joonspk-research/generative_agents.git cd generative_agents ③用vscode打开generative_agents目录
④在reverie目录的backend_server下载创建文件utils.py文件，填入以下内容
# Copy and paste your OpenAI API Keyopenai_api_key ="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e270be4cac88ca564bfb9cefebb3935/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51fa12c81218b858d9293f2d979c1b78/" rel="bookmark">
			贪心算法总结（3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、最长回文串 409. 最长回文串 - 力扣（LeetCode）
class Solution { public: int longestPalindrome(string s) { int hash[127]={0}; for(char&amp;ch:s) ++hash[ch]; int ret=0; for(int&amp;x:hash) ret+=x/2*2; //技巧1 利用向下取整 return ret&lt;s.size()?ret+1:ret; } }; 二、增减字符串匹配 942. 增减字符串匹配 - 力扣（LeetCode）
class Solution { public: vector&lt;int&gt; diStringMatch(string s) { //如果是升 就把最小的放进去 如果是降 就把最大的放进去 int left=0,right=s.size(); vector&lt;int&gt; ret; ret.reserve(s.size()+1); for(auto&amp;ch:s) if(ch=='I') ret.emplace_back(left++); else ret.emplace_back(right--); ret.emplace_back(left); return ret; } }; 三、重构字符串 767. 重构字符串 - 力扣（LeetCode）
class Solution { public: string reorganizeString(string s) { int hash[26]={0}; int n=s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51fa12c81218b858d9293f2d979c1b78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee72a6bb254beb449398d0e5a6464229/" rel="bookmark">
			后端Web开发之Maven
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.java项目构建工具maven介绍 Maven是apache旗下的一个开源项目。Apache软件基金会，成立于1999年7月，是目前世界上最大的最受欢迎的开源（源代码开放）软件基金会也是一一个专门为支持开源项目而生的非盈利性组织。
apache开源项目网址: Welcome to The Apache Software Foundation!
maven功能：
使用maven生成的项目结构都是统一的，因此不管使用哪款开发软件，都可以将maven工程直接导入。
在IDEA中，右侧maven提供了指令用于编译、打包等功能，指令完成后会存放在target目录下，这些指令是跨平台的。
大体结构：
pom.xml中配置的一小段信息来描述maven工程。dependency中分别是当前依赖归属的组织，模块名称和版本。这三项信息就叫做坐标。添加坐标后，maven就会自动的从仓库中查找这个依赖，实际上坐标就是查找的路径：ch/qos/logback/log-classic/1.2.11
查找顺序：本地--远程（若存在的话）--中央
2.安装配置 安装步骤如下，配置阿里云私服是为了提高下载速度，因为中央仓库是放在国外的
3.依赖配置 如果没有提示依赖的信息，可以去中央仓库（https://mvnrepository.com/）查找这个依赖，里面有这个依赖的坐标信息直接复制粘贴就行了。 4.依赖传递 我们只引入了第一个依赖，后面两个依赖是自动引入的。这就是依赖传递
A依赖B，B依赖C，那么C也会传递到A中。绿色框的是直接依赖，黄色框是间接依赖。
如果不需要间接依赖，可以通过标签exclusion去断开依赖，并且不需要指定版本
5.依赖范围 6.生命周期 生命周期中有若干个阶段，一般只关注以下五个阶段。在同一生命周期中，后面的阶段基于前面的阶段，也就是运行后面（比如install）阶段时，compile--package都会运行。
maven是一个插件执行框架，当点击这些阶段时，实际上是运行了Plugins中的这些插件去完成了对应的工作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb1f17a4647a3d75927cc5f2f15fa265/" rel="bookmark">
			UE基础 —— 编辑器界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 菜单栏 UE中每个编辑器都有一个菜单栏，部分菜单会出现在所有编辑器窗口中，如File、Window、Help，其他则是其编辑器特有的；
主工具栏 UE中部分最常用的工具和命令的快捷方式；
1，保存按钮（ctrl+s），保存当前关卡；2，模式选择，用于在不同模式间切换，以编辑关卡中的内容；3，内容快捷方式，用于添加和打开关卡中常见内容类型； Create，快速添加常见资产到关卡，及访问Place Actors面板；Blueprints，创建和访问蓝图；Cinematics，创建关卡序列或主序列过场动画；4，播放模式控制，用于运行游戏的快捷方式按钮（Play, Skip, Stop, Eject）；5，平台菜单，用于配置、准备项目并将其部署到不同的平台，如台式机、台式设备或主机；6，设置，包含用于编辑器、关卡视口、及游戏行为的各种设置； 关卡视口 显示当前打开的关卡内容，打开项目时，默认关卡会在关卡视口中打开；可在此查看和编辑关卡内容；通常有两种显示方式：
Perspective，3D视图，可从不同角度查看；Ortographic，2D视图，沿着一个主轴俯视； 内容浏览器 内容浏览器是文件浏览器窗口，可显示项目中包含的所有资产、蓝图、及其他文件；可浏览内容、将资产拖拽到关卡、在项目间迁移资产等；
大纲 大纲面板显示关卡中的所有内容（层级），可最多打开四个不同的大纲界面，每个大纲的布局和过滤都可以不一样；
点击眼睛按钮，快速隐藏或显示actor；右击actor，访问context menu；创建、移动、删除内容文件夹； 细节面板 在关卡视口中选择一个actor后，细节面板即会显示影响actor的设置和属性；
底部工具栏 Outout Log，输出日志，在程序运行时输出有用的信息；Command Console，控制台命令，输入命令即可触发特定的行为； 输入help，可在浏览器中查看控制台变量和命令； 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3815991328464e248f1133c76e73ef8/" rel="bookmark">
			华为OD机试（C卷&#43;D卷）2024真题目录 Python、C&#43;&#43;、Java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 声明 本专栏内所有博客均有两项内容组成：
题目描述、输入描述、输出描述、用例、备注题目解析、算法源码 其中：
第1项内容均收集自互联网，如若此项（第1项）内容侵犯了原著者的合法权益，可联系我进行删除。
第2项内容如无特殊说明或标注，均为本人原创，任何个人或组织，在未征得本人同意时，禁止复制盗用。
真题目录 正在以每天5-10题的速度完善题集，欢迎关注收藏！共同进步！
100分题已全部补齐，如有欠缺的题可以评论区告知，会尽快补齐。
开始收费，前期有折扣，可以早点订阅会比较省钱，预计8-15左右能补完200分的题集，补完全部会稍微提价。
有的100分题也会出现在200分题里，比较随机，所以会出现100分题比200分题难的情况。
2024 C卷&amp;D卷 100分 序号题目考点C++JAVApython1字符串序列判定/最后一个有效字符双指针点击跳转C++点击跳转Java点击跳转Python2山脉的个数/攀登者1简单逻辑分析点击跳转C++点击跳转Java点击跳转Python3用连续自然数之和来表达整数等差公式点击跳转C++点击跳转Java点击跳转Python4内存冷热标记多条件排序点击跳转C++点击跳转Java点击跳转Python5剩余银饰的重量优先队列点击跳转C++点击跳转Java点击跳转Python6密码输入检测数据结构–栈点击跳转C++点击跳转Java点击跳转Python7分配土地简单几何点击跳转C++点击跳转Java点击跳转Python8学生排名/智能成绩表条件排序点击跳转C++点击跳转Java点击跳转Python9转盘寿司简单模拟点击跳转C++点击跳转Java点击跳转Python10开源项目热榜、开源项目热度榜单多条件排序点击跳转C++点击跳转Java点击跳转Python12机器人搬砖二分法点击跳转C++点击跳转Java点击跳转Python13虚拟理财游戏枚举点击跳转C++点击跳转Java点击跳转Python14游戏分组枚举/回溯点击跳转C++点击跳转Java点击跳转Python15围棋的气分析模拟点击跳转C++点击跳转Java点击跳转Python16万能字符单词拼写、掌握的单词个数逻辑分析点击跳转C++点击跳转Java点击跳转Python17小明找位置二分法点击跳转C++点击跳转Java点击跳转Python18分割均衡字符串贪心法点击跳转C++点击跳转Java点击跳转Python19小华最多能得到多少克黄金、小华地图寻宝简单搜索点击跳转C++点击跳转Java点击跳转Python20数的分解简单数学点击跳转C++点击跳转Java点击跳转Python21执行任务赚获取最多积分优先队列点击跳转C++点击跳转Java点击跳转Python22计算三叉搜索树的高度数据结构-树点击跳转C++点击跳转Java点击跳转Python23API集群负载统计字符串处理+集合处理点击跳转C++点击跳转Java点击跳转Python24最多购买宝石数目双指针点击跳转C++点击跳转Java点击跳转Python25最大坐标值、小明的幸运数简单模拟点击跳转C++点击跳转Java点击跳转Python26悄悄话树的层遍历点击跳转C++点击跳转Java点击跳转Python27CPU算力分配逻辑分析点击跳转C++点击跳转Java点击跳转Python28分披萨记忆化搜索点击跳转C++点击跳转Java点击跳转Python29机场航班调度程序字符串操作排序点击跳转C++点击跳转Java点击跳转Python30生成哈夫曼树构建哈夫曼树+树遍历点击跳转C++点击跳转Java点击跳转Python31密码解密字符串操作点击跳转C++点击跳转Java点击跳转Python32园区参观路径动态规划点击跳转C++点击跳转Java点击跳转Python33求幸存数之和数组操作点击跳转C++点击跳转Java点击跳转Python34会议室占用时间区间问题点击跳转C++点击跳转Java点击跳转Python35手机App防沉迷系统逻辑分析点击跳转C++点击跳转Java点击跳转Python36小朋友来自多少小区贪心算法点击跳转C++点击跳转Java点击跳转Python37精准核酸检测并查集点击跳转C++点击跳转Java点击跳转Python38多段线数据压缩逻辑分析点击跳转C++点击跳转Java点击跳转Python39测试用例执行计划多条件排序点击跳转C++点击跳转Java点击跳转Python40查找众数及中位数逻辑分析点击跳转C++点击跳转Java点击跳转Python41最长的指定瑕疵度的元音子串双指针点击跳转C++点击跳转Java点击跳转Python42整数对最小和逻辑分析点击跳转C++点击跳转Java点击跳转Python43找出作弊的人排序点击跳转C++点击跳转Java点击跳转Python44最长子字符串的长度/字符成环找偶数O逻辑分析点击跳转C++点击跳转Java点击跳转Python45找座位逻辑分析点击跳转C++点击跳转Java点击跳转Python46找朋友栈点击跳转C++点击跳转Java点击跳转Python49求满足条件的最长子串的长度滑动窗口点击跳转C++点击跳转Java点击跳转Python51机器人仓库搬砖二分法点击跳转C++点击跳转Java点击跳转Python52出租车计费 、靠谱的车简单数学点击跳转C++点击跳转Java点击跳转Python53寻找最富裕的小家庭逻辑分析点击跳转C++点击跳转Java点击跳转Python54考勤信息逻辑分析点击跳转C++点击跳转Java点击跳转Python55寻找身高相近的小朋友逻辑分析点击跳转C++点击跳转Java点击跳转Python56字符串摘要逻辑分析点击跳转C++点击跳转Java点击跳转Python57整型数组按个位值排序/最低位排序排序点击跳转C++点击跳转Java点击跳转Python58数组去重和排序排序题点击跳转C++点击跳转Java点击跳转Python59按身高和体重排队排序题点击跳转C++点击跳转Java点击跳转Python60字符串变换最小字符串排序题点击跳转C++点击跳转Java点击跳转Python61GPU 调度/执行时长逻辑分析点击跳转C++点击跳转Java点击跳转Python62最大N个数与最小N个数的和逻辑分析点击跳转C++点击跳转Java点击跳转Python64素数之积/RSA加密算法数学点击跳转C++点击跳转Java点击跳转Python65来自异国的客人/幸运数字数学点击跳转C++点击跳转Java点击跳转Python66英文输入法字符串操作点击跳转C++点击跳转Java点击跳转Python67字符串筛选排序字符串操作点击跳转C++点击跳转Java点击跳转Python68拼接URL字符串操作点击跳转C++点击跳转Java点击跳转Python69最少停车数/停车场车辆统计逻辑分析点击跳转C++点击跳转Java点击跳转Python70求最多可以派出多少支团队双指针点击跳转C++点击跳转Java点击跳转Python71寻找连续区间/数组连续和动态规划点击跳转C++点击跳转Java点击跳转Python72字符串分割转换字符串操作点击跳转C++点击跳转Java点击跳转Python73连续字母长度字符串操作点击跳转C++点击跳转Java点击跳转Python74火星文计算栈点击跳转C++点击跳转Java点击跳转Python75虚拟游戏理财栈点击跳转C++点击跳转Java点击跳转Python76绘图机器逻辑分析点击跳转C++点击跳转Java点击跳转Python78求字符串中所有整数的最小和字符串+逻辑分析点击跳转C++点击跳转Java点击跳转Python79贪吃的猴子前缀和点击跳转C++点击跳转Java点击跳转Python80灰度图存储逻辑分析点击跳转C++点击跳转Java点击跳转Python81螺旋数字矩阵模拟点击跳转C++点击跳转Java点击跳转Python82堆内存申请逻辑分析点击跳转C++点击跳转Java点击跳转Python83单行道汽车通行时间逻辑分析点击跳转C++点击跳转Java点击跳转Python84火星文计算2栈点击跳转C++点击跳转Java点击跳转Python85解密犯罪时间逻辑分析点击跳转C++点击跳转Java点击跳转Python 2024 C卷&amp;D卷 200分 序号题目考点C++JAVApython1构成指定长度字符串的个数/字符串拼接全排列去重点击跳转C++点击跳转Java点击跳转Python2查找接口成功率最优时间段前缀和点击跳转C++点击跳转Java点击跳转Python3可以组成网络的服务器搜索点击跳转C++点击跳转Java点击跳转Python4MELON的难题动态规划点击跳转C++点击跳转Java点击跳转Python6数据单元的变量替换逻辑分析点击跳转C++点击跳转Java点击跳转Python7最多几个直角三角形枚举点击跳转C++点击跳转Java点击跳转Python8欢乐的周末DFS点击跳转C++点击跳转Java点击跳转Python9城市聚集度/找城市并查集点击跳转C++点击跳转Java点击跳转Python10找最小数栈点击跳转C++点击跳转Java点击跳转Python11找单词DFS点击跳转C++点击跳转Java点击跳转Python12跳马BFS点击跳转C++点击跳转Java点击跳转Python13项目排期二分法+回溯点击跳转C++点击跳转Java点击跳转Python14分月饼递归点击跳转C++点击跳转Java点击跳转Python15考古学家考古问题DFS点击跳转C++点击跳转Java点击跳转Python16分解连续正整数组合/分解正整数数学点击跳转C++点击跳转Java点击跳转Python17数据最节约的备份方法贪心算法点击跳转C++点击跳转Java点击跳转Python18会议室占用时间段区间问题19文本统计分析模拟20结队编程暴力21高效货运暴力22快递员的烦恼DFS23电脑病毒感染图论24员工派遣二分25根据IP查找城市逻辑分析26部门人力分配二分27数字游戏位运算/数学28模拟目录管理功能模拟29亲子游戏BFS30两个字符串间的最短路径问题动态规划31Wonderland动态规划32寻找最优的路测线路BFS335G网络建设最小生成树34连续出牌数量DFS35伐木工动态规划36最优结果的a数组数量排列组合37符号运算栈38图像物体的边界模拟39贪心歌手贪心算法40最小矩阵宽度逻辑分析41反射计数数学42文件缓存系统LFU43攀登者2逻辑分析44信道分配逻辑分析45中文分词模拟器树结构46查找一个有向网络的头节点和尾节点图论47最长子字符串的长度(二)滑动窗口48篮球游戏队列49矩阵匹配二分法 + 二分图最大匹配50最大社交距离逻辑分析51可以处理的最大任务数优先队列52特殊的加密算法DFS53二叉树计算树54推荐多样性逻辑分析55启动多任务排序图论56抢7游戏动态规划57小朋友分组最少调整次数58路口最短时间问题最短路问题变形 + dijkstra59石头剪刀布游戏逻辑分析60爱吃蟠桃的孙悟空二分法61田忌赛马回溯算法 / 排列问题62音乐小说内容重复识别并查集 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dc1ba7e76ccd49e7dae93661d29a319/" rel="bookmark">
			二叉树的遍历问题—广度优先实现(从代码理解算法)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题的引入 本文主要对二叉树的广度优先搜索代码实现做一个梳理，加深自己对算法的理解，也供大家参考学习。
我们以最大路径问题为例来说明二叉树的广度优先遍历的实现。
LeetCode 104. 二叉树的最大深度
给定一个二叉树 root ，返回其最大深度。
二叉树的最大深度是指从根节点到最远叶子节点的最长路径上的节点数。
二叉树的广度优先遍历的解释 先解释一下广度优先遍历在做什么。对于二叉树而言，广度优先搜索(Breadth-First Search, BFS)其实就是二叉树的层序遍历(Level Order Traversal)。层序遍历的过程简单地说就是我们先取出二叉树的第一层全部节点(3)，然后再取出第二层全部节点(9，20)，然后是第三层(15，7)，这样不断地做下去实现对整个二叉树的遍历。
对于这道题而言，我们使用广度优先搜索对二叉树进行遍历，在遍历过程中记录路径最大长度即可。
代码需要的基础知识罗列 题目给出的数据结构，树的定义
public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } 解题用到的代码知识
队列(queue)：一种先进先出(FIFO, First-In-First-Out)的数据结构，可以看成一个排队模型， 排队时排在最后面，出队时最前面的人先离开，因此有先进先出，后进后出 **Java中的队列** Java集合框架中提供了Queue接口，用于实现队列，Java中队列的主要实现类有ArrayDeque, LinkedList, PriorityQueue 在这里使用LinkedList实现，LinkedList 类实现了 List 和 Deque 接口 它可以作为双向链表使用，也可以作为队列使用。LinkedList 提供了对列表两端的操作支持，这意味着可以在列表的头部或尾部高效地插入和删除元素。 **代码中要使用的方法**: 向队列增加元素的方法：offer() 移除队列元素的方法poll() 算法解析 直接上代码再解释
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dc1ba7e76ccd49e7dae93661d29a319/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5559cb7935c7b9d12530831005abf174/" rel="bookmark">
			动手实践生成式人工智能GAI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于台湾大学李宏毅教授的Introduction to Generative AI 2024 Spring课程，总结
生成式人工智能GAI实践任务。参考资源包括课程的课件、视频和实践任务的代码。
Introduction to Generative AI 2024 Spring
也感谢B站Up主搬运的视频
李宏毅2024春《生成式人工智能导论》_哔哩哔哩_bilibili
本文介绍LLM微调、学习人类偏好和微调稳定扩散模型三个关键实践内容，每个实践内容包括主要目标、理论知识及参考文献、训练数据、测试数据、调整超参数的方法、模型评价方法。
1 LLM微调 目标 基于预训练模型训练出完成某一特定任务的模型。
理论基础 温度调节、Top-K截断和Nucleus采样（也称为Top-p截断）是大型语言模型（LLM）的常用生成策略技术，用于调整生成文本的多样性和连贯性。
温度调节（Temperature Scaling）：通过一个温度参数来平滑或锐化概率分布。温度较高时，概率分布更加平坦，生成的文本更加多样；温度较低时，概率分布更加尖锐，生成的文本更加确定。Top-K截断（Top-K Truncation）：在生成下一个token时，只考虑概率最高的K个tokens，其他的tokens被设置为0概率，不会被选中。Nucleus采样（Top-p Sampling）：选择累积概率超过某个阈值p的最小集合，然后从这个集合中采样下一个token。这样可以在保持多样性的同时，避免选择极低概率的token。 训练数据 instruction
input
output
数据条数：1040
测试数据 instruction
input
调整超参数 Temperature：设定生产回复的随机度，值越小生成的回复越稳定Top-k：增加生成回复的多样性和避免生成重复的词Top-p：抽样的概率阈值，用于控制生成回复的多样性max_length：生成回复的最大长度 评价方法 可以用大语言模型助教来评价格式和内容。需要准备包含评价标准和步骤的提示语。
2 学习人类偏好 目标 根据人类期望调整LLM的输出。
理论基础 RLHF Reinforcement Learning from Human Feedback参考https://openai.com/index/instruction-following/
Huggingface introduction to RLHF: https://huggingface.co/blog/rlhf https://huggingface.co/blog/trl-peft RLHF需要训练一个Reward Model评估 LLM 输出的答案，学习哪种反应更好（更类似于人类的偏好），然后用强化学习微调LLM。RLHF的弱点是需要训练额外的Reward Model，强化学习训练非常不稳定，很难调整超参数。
DPO Direct Preference Optimization 直接提供两种不同的回答，一种是首选回答，另一种是非首选回答
LLM 直接从回答中学习偏好，而不需要明确的奖励模型。
参考文档 Direct Preference Optimization: Your Language Model is Secretly a Reward Model
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5559cb7935c7b9d12530831005abf174/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45757765c45557b881d0f44b0f38f349/" rel="bookmark">
			C语言之“ 分支和循环 ” （2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌹个人主页🌹：喜欢草莓熊的bear
🌹专栏🌹：C语言基础
目录
前言
一、switch语句
1.1 if语句和switch语句的对比
1.2 switch语句中的break
1.3 switch语句中的default
1.4 switch语句中的case和default的顺序问题
二、while循环
2.1 if 和 while 的对比
2.2 while语句的执行流程
2.3 while循环的实践
三、for循环
3.1 语法形式
3.2 for循环的执行流程
3.3 for循环的实践
3.4 while循环和for循环的对比
四、do while循环
4.1 语法形式
4.2 do while循环的执行流程
4.3 do while循环的实例
五、break 和 continue 语句
5.1 while循环中的break 和 continue
break举例：
continue举例：
5.2 for循环中的break 和 continue
break举例：
continue举例：
5.3 do while循环中的break 和 continue
六、go to语句
总结
前言 接着上期写的，本期内容包含：switch语句、for循环、while循环、do while循环、break和continue、goto语句这些。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45757765c45557b881d0f44b0f38f349/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5574fe632aac5fd3f6b5f5061cca5d8/" rel="bookmark">
			【MySQL】数据基本的增删改查操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新增数据（Create） 在MySQL中，增加数据的操作主要使用 INSERT 语句。下面我们将分为两部分：单行数据插入和多行数据插入。
一、单行数据插入 全列插入： 当你要插入一行数据到表中并且要提供所有列的值时，可以使用如下语法：示例： 假设我们有一个名为 students 的表，它有三个列：id、name 和 age。
INSERT INTO students (id, name, age) VALUES (1, 'Alice', 20); 2.指定列插入： 如果你只想插入部分列的值，没提供的列将会使用默认值或者 NULL。示例： 在 students 表中仅插入 name 和 age，假设 id 列自动递增。
INSERT INTO students (name, age) VALUES ('Bob', 22); 二、多行数据插入 指定列插入： 可以在一次操作中插入多行数据，且只指定想插入的列。示例： 向 students 表中插入多名学生的 name 和 age。
INSERT INTO students (name, age) VALUES ('Charlie', 19), ('David', 21), ('Eva', 20); 查询数据（Retrieve） 在MySQL中，查询数据的操作主要使用 SELECT 语句。下面将详细描述各类查询方式，包括全列查询、指定列查询、条件过滤等。
一、全列查询 当你需要从一个表中检索所有列的数据时，可以使用 * 通配符。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5574fe632aac5fd3f6b5f5061cca5d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc9b580d0b249a5a53c84efb2fa66b55/" rel="bookmark">
			2024年6月 青少年等级考试机器人实操真题六级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		202406 青少年等级考试机器人实操真题六级
一、实操考题
主题：电位器随动直流电机转动
器件：ESP32主控、码盘、光电对管、按键模块、直流电机驱动模块、TT马达。以上模块也可以采用分立器件结合面包板进行搭建。
任务要求：
通过电位器控制直流电机的转动范围和转动方向。具体任务要求如下：
(1)装置通电前，先将电位器旋转至一端的端部。此时电位器的位置为初始位置。装置通电启动后，TT马达处于静止状态；
(2)点击按键，TT马达开始自检。自检方式为：马达顺时针转动90度后停止，然后逆时针旋转180度后停止，再顺时针旋转90度后停止。自检完毕，装置进入工作状态；
(3)通电后，缓慢将电位器从初始位置旋转至另外一端，在电位器旋转的同时，TT马达同步从当前位置旋转一圈回到初始位置；
(4)当电位器从另一端反向旋转回到初始位置时，TT马达反向旋转一圈回到初始位置；
(5)当电位器处于中间位置正向或反向旋转时，TT马达同步正转或反转；
(6)允许由于码盘误差导致TT马达转动位置偏差；
(7)程序采用Arduino C/C++代码编写，不得使用外部库调用；
(8)未作规定处可自行处理，无明显与事实违背即可。
说明：请考生在考试结束前，按照如下要求提交相关文件。
(1)将程序放在一个文件夹中，压缩为1个“rar或zip”格式文件，并命名为：DJKS6_身份证号，大小5M以下；
(2)将程序文件通过“上传附件”按钮进行上传；
(3)程序编写过程中不得打开其它示例程序，如发现，实操成绩按照0分处理。
=============================================
答案和更多内容请查看网站：【试卷中心 -- 机器人技术 五级/六级】
网站链接 青少年软件编程历年真题模拟题实时更新
================================================
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/61/">«</a>
	<span class="pagination__item pagination__item--current">62/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/63/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>