<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c792d28abe24d7855514851a24b3c38a/" rel="bookmark">
			巨详细Java JDK环境配置（Mac 版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇最详细保姆级教程Mac OS上安装JDK以及配置环境细化每个步骤过程认真看完。
一、下载JDK安装包 1.1 移步oracle官网下载对应Mac OS版本JDK安装包 官网下载链接：
Java Downloads | Oracle
1.2 下滑页面，点击macOS 1.2 M系列芯片的选择 Arm 64 DMG installer 1.3 intel系列的选择 X64 DMG installer 二、install JDK （安装JDK） 2.1 下载完成后双击进行安装，跟着提示依次点击下一步即可完成安装。 2.2 安装完成后测试一下是否正确完成安装，打开终端输入：java -version （提示图片信息显示正确） 三、查询JDK安装路径 3.2 安装完成后我们需要查看所在的路径，在终端输入命令：/usr/libexec/java_home -V（最后一行即为路径复制备用，后面需要用到） 3.3 配置Java JDK环境变量 3.1 在终端输入：ls -a 3.2 查看一下是否有.bash_profile文件该文件用于配置环境（如有此文件则跳过） 3.3 若没有则需要新建.bash_profile文件，在终端输入命令：touch .bash_profile 3.4 新建好文件之后使用命令打开，在终端输入命令：open -e .bash_profile 此命令是打开文件 3.5 在文件里输入以下的代码： JAVA_HOME=这里输入您前面复制的路径 PATH=$JAVA_HOME/bin:$PATH:. CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:. export JAVA_HOME export PATH export CLASSPATH 3.5 如图并保存即可（跳3.1步同学，不需要新建文件同学，打开.bash_profile文件后可能会发现里面并不是空白的，是有了一些代码的。不要慌张，无视那些代码，换行后直接粘贴并保存我们的代码即可。） 4、使配置生效 4.1 重新打开终端输入命令：source .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c792d28abe24d7855514851a24b3c38a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b022102646f243477ce51f657f950c1/" rel="bookmark">
			idea如何根据路径快速在项目中快速打卡该页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在idea项目中使用快捷键shift根据路径快速找到该文件并打卡
双击shift(连续按两下shift) -粘贴文件路径-鼠标左键点击选中跳转的路径 自动进入该路径页面
例如：我的实例路径为src/views/user/govType.vue 输入src/views/user/govType或加vue后缀src/views/user/govType.vue或src/views/user/govType vue或省略父级/user/govType都行哈，看你喜欢，看你方便。
你也可以加后缀方便找文件类型
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74037a19dc54968b30b2cd3628d73f04/" rel="bookmark">
			Mysql间隙锁死锁避免最佳实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近写代码的时候听说，批量操作提高死锁的概率，但是心里又想，为什么没看到任何一款数据库相关的中间价禁止或者提醒批量操作？心里想肯定是因为一起其他操作的不当导致的死锁问题。进行了一些思考，希望可以帮助到大家
Mysql死锁的根本原因 死锁诞生的四个必要条件，这个是理论的基础，这个就不讲了，看下最常见也是开发中最容易导致的死锁问题。
很多大厂为了提高性能，会把RR隔离级别改为RC隔离级别，取消了间隙锁，提高性能的同时也大大避免了死锁的概率。
而RR相比RC隔离级别，主要就是间隙锁这个玩意儿，解决当前读时（每次获取最新的数据，而不是快照）的幻读问题，当然并没有完全解决，这个自己去探究，和本文关系不大。
1.为什么说高并发大厂改为RC隔离级别，速度就提高了，死锁概率也大大降低了？
2.对于大多数公司，并没有极高的并发，就是采用RR隔离级别，应该怎么做，才能减少因间隙锁导致的死锁问题呢？
到这里就有答案了：大多数mysql遇到的死锁都是因为RR隔离级别，需要通过间隙锁，解决幻读问题，开发人员又没充分的理解间隙锁何时会加，怎么避免不必要的加间隙锁，而导致的死锁问题；
Mysql何时会加间隙锁？ 想要避免因间隙锁死锁导致的问题，首先，要弄清究竟什么时候会加间隙锁？
对于delete 、 update、select xxx for update带有加锁性质的语句，会加间隙锁。至于怎么加？为什么加间隙锁就死锁了，听我慢慢讲。
1.如果这些语句没走索引，网上我看很多文章都说，不走索引，就会加表锁。。。这纯属于瞎扯。
这是因为加next-lock临键锁，没走索引，发生了全表扫描，整个表都加上了锁，整个表的间隙都加上了间隙锁，也就是整个表加了临键锁（间隙锁+记录锁）
2.如果走了索引：会因为这个情况加锁，而且死锁：（这是通用的间隙锁死锁原因）：
间隙锁是并不是互斥的，事务1给一段范围加了间隙锁，事务2也可以给这段范围加间隙锁，互斥的是插入意向锁和间隙锁互斥，正常来说就是：事务1加了间隙锁，事务2插入的时候会生成一个插入意向锁，这样就避免了幻读问题。
不正常的时候就是事务1加了间隙锁，事务2在同样的范围也加了间隙锁，进行操作的时候，两个事务就会死锁了，比如事务1插入，被事务2的间隙锁阻塞，事务2插入，被事务1的间隙锁插入。
死锁例子：事务1执行加了间隙锁 事务2执行加了间隙锁
事务1插入记录（阻塞）
事务2插入记录（阻塞） 死锁发生了。
这样的例子很多。
比如：
（1） 表的数据有 1。 2 3。
事务1，删除4，加临键锁(3,正无穷] 事务2，删除5，加临键锁（3，正无穷]
事务1。insert。 4（阻塞）
事务1。insert。 4（阻塞）
(2) 加锁读：1，2，3
事务1。select 4 for update 加临键锁(3,正无穷] 事务2， select 5 for update 加临键锁(3,正无穷] 事务1。insert。 4（阻塞） 事务1。insert。 4（阻塞）
(3)更新同上
（4）（5）（6）
这里只是间隙锁死锁，insert可以换成是其他操作，delete。update可以探究下是否会阻塞死锁。
大致的加锁就是这样。
可以看到上面的例子，大多是对于不存在的操作进行改变，不存在，就一定会加间隙锁。
如何避免间隙锁死锁？ 暴力就是有大厂类似需求的，不用RR,就不会有间隙锁死锁。（不推荐，大多数公司用不了）
通过上面的分析：
避免死锁死锁有这些最佳实践
1.删除、更新之前，先判断在不在，不在的数据，进行删除更新，虽然不会报错（返回0rows）但是。操作一定会加间隙锁。开发人员要避免这种情况
2.尽量通过主键操作，先查出主键，再进行删、改操作，就只会加行锁，不会加间隙锁
3.一定要保证这些加锁的语句走了索引，不走索引的话，会导致整个表加锁，整个表的间隙也加锁，是很多next-lock锁，而不是表锁！
4.仅仅真的涉及幻读问题的时候，才让间隙锁去发挥他的作用，比如selet for update，语句需要的时候，大多数场景用不到间隙锁，就开发的时候避免掉这些间隙锁，也就是尽量遵循上面1 2 3逻辑。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74037a19dc54968b30b2cd3628d73f04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c13285f0d42044ecbbe842768a0f58b2/" rel="bookmark">
			【经典算法】LeetCode 392 判断子序列(Java/C/Python3/Go实现含注释说明,Easy)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者主页： 🔗进朱者赤的博客
精选专栏：🔗经典算法
作者简介：阿里非典型程序员一枚 ，记录在大厂的打怪升级之路。 一起学习Java、大数据、数据结构算法（公众号同名）
❤️觉得文章还不错的话欢迎大家点赞👍➕收藏⭐️➕评论，💬支持博主，记得点个大大的关注，持续更新🤞
————————————————
目录 题目描述思路及实现方式一：双指针法思路代码实现Java版本C语言版本Python3版本Golang版本 复杂度分析复杂度分析 相似题目 标签（题目类型）：双指针，字符串 题目描述 给定字符串 s 和 t，判断 s 是否为 t 的子序列。
你可以认为，如果 s 可以通过将 t 中的一些字符（也可以不删除）而不改变其余字符的相对位置来获得，那么 s 就是 t 的一个子序列。
原题：LeetCode 392
思路及实现 方式一：双指针法 思路 通过两个指针分别指向 s 和 t 的开头，然后逐个比较字符，如果相等则两个指针都向后移动一位，如果不等则只移动 t 的指针，直到 s 的指针指向末尾，则说明 s 是 t 的子序列。
代码实现 Java版本 public boolean isSubsequence(String s, String t) { int i = 0, j = 0; while (i &lt; s.length() &amp;&amp; j &lt; t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c13285f0d42044ecbbe842768a0f58b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f439f5a07ad81141013ef2ff7ace20ef/" rel="bookmark">
			【wiki知识库】05.分类管理实现--前端Vue模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📝个人主页：哈__
期待您的关注 目录
一、🔥今日目标
二、🌏前端部分的改造
2.1 新增一个tool.ts 2.2 新增admin-categoty.vue
2.3 添加新的路由规则
2.4 添加the-welcome.vue
2.5 修改HomeView.vue
三、❗注意
一、🔥今日目标 【wiki知识库】04.SpringBoot后端实现电子书的增删改查以及前端界面的展示-CSDN博客
上回带大家把电子书管理的模块做了出来，能够实现电子书的添加、修改和删除功能了，今天带着大家把分类的接口实现一下。下方我添加了一个分类管理的组件，展示我们当前的所有分类，你可以看到这个分类页面还是一个树形结构的。
除了分类管理，我们的首页也变动了一下。首页的导航栏加载的是我们已经有的分类，同时还加上了一个欢迎页面。
二、🌏前端部分的改造 2.1 新增一个tool.ts 在util包下建立一个tool.ts文件，这个文件是我们的工具文件，之前的代码可能也用到过了，我忘记给大家了。
export class Tool { /** * 空校验 null或""都返回true */ public static isEmpty(obj: any) { if ((typeof obj === 'string')) { return !obj || obj.replace(/\s+/g, "") === "" } else { return (!obj || JSON.stringify(obj) === "{}" || obj.length === 0); } } /** * 非空校验 */ public static isNotEmpty(obj: any) { return !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f439f5a07ad81141013ef2ff7ace20ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbae3bee9f9abf54d52eb3642486efb7/" rel="bookmark">
			AIGC简介：如何利用人工智能进行内容生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、引言二、AIGC的定义与技术原理1. 定义说明2. 关键技术3. 技术原理 三、AIGC的主要应用领域1. 文本内容生成2. 图像和视频生成3. 音频内容的创建4. 数据分析与报告 四、实施AIGC的步骤和方法1. 定义项目目标2. 数据准备与处理3. 选择合适的工具和技术4. 模型训练与测试5. 集成与部署6. 持续优化与维护 五、成功案例研究1. 案例一：自动生成体育新闻报道2. 案例二：个性化营销邮件的生成3. 案例三：艺术作品的生成 六、未来趋势与挑战1. 技术进步2. 应用扩展3. 挑战4. 社会影响 七、结语 AIGC简介：如何利用人工智能进行内容生成
一、引言 在信息技术飞速发展的今天，人工智能（AI）已经从科幻幻想变为我们日常生活中的实用工具。特别是人工智能生成内容（AIGC）技术的发展，正在革命性地改变我们获取和消费信息的方式。无论是自动编写新闻报道、生成个性化的营销文案，还是设计图像和视频，AIGC的应用都显示出无限的可能性和潜力。
本文将深入探讨AIGC技术的背景和发展历程，解释它是如何工作的，以及它如何被用来高效地生成各种类型的内容。我们还将讨论AIGC技术的最新应用，探索它如何帮助各行各业的组织提升生产力，并创造出前所未有的价值。
二、AIGC的定义与技术原理 1. 定义说明 AIGC概念：人工智能生成内容（Artificial Intelligence Generated Content, AIGC）指的是利用人工智能技术自动创建文本、图像、视频等内容的过程。作用理解：AIGC通过模仿人类的创作过程，能够自主产生新颖且相关的内容丰富多样化的媒体形式。 2. 关键技术 自然语言处理（NLP）：NLP技术使计算机能够理解和生成自然语言，它是实现文本内容自动生成的关键技术。机器学习：通过训练算法模型识别数据模式，机器学习可以预测并生成新的相关内容，不断优化生成质量。深度学习：深度学习框架，如神经网络，用于图像和音频处理，能够捕捉复杂的特征并进行高质量的内容生成。 3. 技术原理 数据输入与处理：首先，需要向AI系统提供大量高质量的数据输入。这些数据被预处理和清洗，以便于AI系统更好地理解和使用。模型训练：利用这些数据，AI模型经过训练学习创作内容的规律和技巧。例如，在文本生成中，模型学习词汇搭配、句子结构和叙事风格。内容生成：训练完成后，AI系统就可以根据新的输入（如一个标题或一个图像描述）生成新的内容。内容生成是一个迭代优化的过程，系统不断地调整和优化输出，直到满足用户的特定需求。 三、AIGC的主要应用领域 1. 文本内容生成 新闻报道：AI可以自动编写简单的新闻报道，如体育赛事结果或财务报告。营销文案：生成个性化的营销邮件或社交媒体内容，针对不同用户的兴趣和行为定制。教育内容：创建个性化的学习材料或测验，适应学生的学习进度和能力。 2. 图像和视频生成 设计与艺术：AI可用于生成设计图案、艺术作品或布局建议，辅助创意过程。视频制作：自动生成视频剪辑，如将一系列图片和视频片段组合成连贯的视频，或基于文本脚本生成视频内容。虚拟角色与场景：在电影和视频游戏中生成虚拟角色、面部表情和场景。 3. 音频内容的创建 音乐创作：AI程序可以创作音乐，产生旋律和和声，甚至模仿特定艺术家的风格。语音生成：用于生成虚拟助手的语音回应，或在音频书中模拟不同的讲话风格和情感。 4. 数据分析与报告 数据摘要：自动分析大量数据，提炼关键信息并生成易于理解的摘要。业务报告：基于公司数据自动生成业务性能报告，提供洞察和建议。 四、实施AIGC的步骤和方法 1. 定义项目目标 明确目的：确定你希望通过AIGC实现什么目标，比如提高内容生成效率、创新产品设计等。设定范围：界定项目的范围，决定哪些任务由AI处理，哪些仍需人工参与。 2. 数据准备与处理 收集数据：根据项目需求收集足够的训练数据，数据质量直接影响模型的效果。数据处理：进行数据清洗和预处理，包括去除无关数据、格式化、标注等，确保数据的一致性和可用性。 3. 选择合适的工具和技术 选择AI框架：根据项目需求选择合适的AI技术和框架，如自然语言处理、生成对抗网络（GAN）等。开发或使用现成的模型：决定是自主开发模型还是使用现成的预训练模型，并进行必要的调整和优化。 4. 模型训练与测试 训练模型：使用准备好的数据对模型进行训练，通过多次迭代优化模型性能。测试与评估：在独立数据集上测试模型的表现，评估其准确性、可靠性和有效性，确保模型达到预期效果。 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbae3bee9f9abf54d52eb3642486efb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ded458a062c8c060157f26b256d671ff/" rel="bookmark">
			【数据结构】链式二叉树详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人主页~
链式二叉树基本内容~
链式二叉树详解 1、通过前序遍历的数组来构建二叉树2、二叉树的销毁3、二叉树节点个数4、二叉树叶子节点个数5、二叉树第k层节点个数6、二叉树查找7、前序遍历8、中序遍历9、后序遍历10、层序遍历与检查二叉树是否为完全二叉树Queue.hQueue.c层序遍历代码完全二叉树判断 整个链式二叉树以递归定义为主，需要详细了解递归的相关概念：递归定义在第六条
最需要记住的是：递归定义中的return是退出到上一级，而不是整个程序
1、通过前序遍历的数组来构建二叉树 BTNode* BinaryTreeCreate(BTDataType* a,int n, int* pi) { if (*pi &gt;= n || a[*pi] == '#') { // 如果到达数组末尾或遇到#，则返回NULL (*pi)++;//移动到下一个数据 return NULL; } BTNode* node = BuyNode(a[*pi]); (*pi)++; // 移动到下一个数据 node-&gt;left = BinaryTreeCreate(a, n, pi); // 递归创建左子树 node-&gt;right = BinaryTreeCreate(a, n, pi); // 递归创建右子树 return node; } 建树过程（部分过程省略）：
2、二叉树的销毁 二叉树销毁是不能够从第一层开始销毁的，这样我们不能销毁所有的节点，从叶节点开始销毁，递归释放，才能销毁二叉树所有节点
void BinaryTreeDestory(BTNode* root) { if (root == NULL) return; BinaryTreeDestory(root-&gt;left);//找到底层左节点 BinaryTreeDestory(root-&gt;right);//找完左节点找右节点 free(root); } 找到D的左子结点，是#返回，再找D的右节点，是#返回，然后释放掉D节点，此时B的root-&gt;left结束，进行root-&gt;right，以此类推，这样会从最底下的叶节点开始将所有节点释放
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ded458a062c8c060157f26b256d671ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d08e64d0e9eb8aa575ed6f616321278c/" rel="bookmark">
			SQL入门教程：从零开始掌握数据库查询语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL入门教程：从零开始掌握数据库查询语言
在数字化时代，数据无处不在。从简单的用户注册信息到复杂的商业交易数据，数据库成为了存储、检索和管理这些数据的关键工具。而SQL（结构化查询语言）则是与数据库交互的通用语言。本教程旨在帮助初学者从零开始学习SQL，逐步掌握数据库查询的基本操作。
一、什么是SQL？
SQL（Structured Query Language）是一种用于管理关系型数据库的编程语言。它允许用户通过编写SQL语句来查询、更新和管理数据库中的数据。SQL语句由一系列的命令和子句组成，这些命令和子句告诉数据库应该执行什么操作。
二、SQL基础
数据类型
数值型（如INT, FLOAT, DECIMAL）字符型（如CHAR, VARCHAR）日期型（如DATE, TIMESTAMP）其他类型（如BLOB, TEXT等） 创建数据库
CREATE DATABASE mydatabase; 选择数据库
USE mydatabase; 创建表
CREATE TABLE employees ( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(50), age INT, salary DECIMAL(10, 2) ); 插入数据
INSERT INTO employees (name, age, salary) VALUES ('Alice', 30, 5000.00); 查询数据
查询所有员工信息SELECT * FROM employees; 查询指定列的数据SELECT name, age FROM employees; 更新数据
UPDATE employees SET salary = 5500.00 WHERE name = 'Alice'; 删除数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d08e64d0e9eb8aa575ed6f616321278c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a29422087e794b145221a30c96206bf9/" rel="bookmark">
			Python正则表达式：深度解析URL匹配与操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python正则表达式：深度解析URL匹配与操作
在Python编程中，正则表达式（Regular Expression，简称regex或regexp）是一种强大的文本处理工具，它可以帮助我们快速匹配、查找、替换复杂的文本模式。在处理URL（统一资源定位符）时，正则表达式同样发挥着不可替代的作用。本文将深入探讨如何使用Python的正则表达式库（re模块）来解析和操作URL。
四个方面：URL的基本结构与正则表达式匹配
首先，我们需要了解URL的基本结构。一个典型的URL包括协议（如http://或https://）、域名、路径、查询参数等部分。正则表达式可以通过特定的模式来匹配这些部分。例如，我们可以使用正则表达式来提取URL中的域名或路径。
五个方面：Python re模块的基本用法
Python的re模块提供了丰富的函数和方法来执行正则表达式的匹配和替换操作。这些函数包括re.match()、re.search()、re.findall()等，它们分别用于匹配字符串的开头、搜索整个字符串以及查找所有匹配项。此外，re模块还支持编译正则表达式对象，以便多次使用。
六个方面：高级正则表达式技巧在URL处理中的应用
在处理URL时，我们可能需要使用到一些高级的正则表达式技巧。例如，我们可以使用非贪婪匹配来提取URL中的特定部分；使用命名捕获组来更方便地访问匹配结果；以及使用正则表达式的断言功能来确保匹配符合特定条件。
七个方面：实战演练：解析URL并提取关键信息
最后，我们将通过一个实战演练来展示如何使用Python的正则表达式库来解析URL并提取关键信息。我们将编写一个Python脚本，该脚本能够接收一个URL作为输入，并使用正则表达式提取出协议、域名、路径以及查询参数等关键信息。
通过本文的学习，我们不仅可以了解Python正则表达式在URL处理中的应用，还可以掌握一些高级的正则表达式技巧。这些技巧不仅可以帮助我们更好地处理URL，还可以应用于其他文本处理任务中，提高我们的编程效率和准确性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5446170024513a69f29c705702aa5c1/" rel="bookmark">
			智能语音电销机器人可以做哪些事情？ai语音机器人系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		智能语音电销机器人软件的出现，给很多企业都带来了福利，尤其是电销企业，不仅工作效率提升了，成本降低了，还能实现智能化管理客户的出现，给很多企业都带来了福利，尤其是电销企业，不仅工作效率提升了，成本降低了，还能实现智能化管理客户，那智能电销机器人可以做哪些事情呢？我们一起来看看
智能语音电销机器人具有多项功能和能力，可以进行以下事情：
呼叫客户：智能语音电销机器人可以自动拨打电话，呼叫客户进行销售、市场推广或客服等活动。
客户调查：机器人可以进行客户调查，采集客户反馈和信息，帮助企业更好地了解客户需求和满意度。
销售推广：机器人可以根据预设脚本进行销售推广，向客户介绍产品或服务，促成销售交易。
客户服务：机器人可以回答常见问题、提供帮助和支持，解决客户问题，提升客户满意度。
预约安排：机器人可以协助客户预约约会、服务或产品演示等安排工作。
信息确认：机器人可以验证客户信息，确认订单、预订或其他交易细节。
语音识别：机器人能够识别语音指令和对话内容，根据客户反馈做出相应回应。
数据分析：机器人可以自动记录和分析通话数据，生成报表和分析结果，帮助企业优化销售策略和提升效率。
总的来说，智能语音电销机器人可以代替人工进行电话销售、客户服务和市场调研等工作，提高工作效率、降低成本，并为企业提供更好的客户体验，系统问题欢迎微博主一起交流学习。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4384ecd2bfeb573921c82dd1d893d1b/" rel="bookmark">
			【C语言】结构体类型的数组和指针（干货满满，建议收藏！！！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		结构体数组 前言1、结构体类型数组的定义与初始化1.1结构体数组的定义1.2结构体数组初始化 2、结构体数组的应用3、结构体指针指向结构体数组 这篇文章将讲述结构体类型的数组的定义、初始化、应用和结构体指针的使用。还会扩展scanf_s函数相关知识。
前言 一个结构体变量中可以存放一组有关联的数据(如一个学生的学号、姓名、性别、成绩、地址等数据)。如果有 20个学生的数据需要处理，应该用数组，但是普通的数组显然不能处理怎么复杂的问题，这时就需要结构体类型的数组了。结构体数组与数值型数组的不同之处在于每个数组元素都是一个结构体类型的数据，结构体数组的每个元素都包含了结构体中的每个成员。
结构体基本知识：https://editor.csdn.net/md/?articleId=139336546
1、结构体类型数组的定义与初始化 1.1结构体数组的定义 方式一：struct 结构体类型名 数组名[数组大小];
//结构体声明 struct Student { char id[20];//学号 char name[10]; int age; float score; }; int main() { struct Student class1[20];//定义结构体数组，表示班级1有20个学生 return 0; } 方式二：在声明结构体时定义一个结构体数组
struct Student { char id[20];//学号 char name[10]; int age; float score; }class1[20]; int main() { return 0; } 1.2结构体数组初始化 方式：struct Student class1[20] = { 初始值列表 };
如：struct Student class1[2] = { "20242356","小敏",18,88.9,"20242345","小鹤",19,85.9 };
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4384ecd2bfeb573921c82dd1d893d1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f644b08cb65c4f5281f13329e1cfd26/" rel="bookmark">
			图解PHP &amp; MySQL：服务器端Web开发入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💂 个人网站:【 摸鱼游戏】【神级代码资源网站】【工具大全】🤟 一站式轻松构建小程序、Web网站、移动应用：👉注册地址🤟 基于Web端打造的：👉轻量化工具创作平台💅 想寻找共同学习交流，摸鱼划水的小伙伴，请点击【全栈技术交流群】 引言 PHP 和 MySQL 是 Web 开发中的黄金组合，PHP 负责服务器端脚本处理，MySQL 负责数据库管理。本篇文章将介绍如何使用 PHP 和 MySQL 创建一个简单的Web应用，包括设置开发环境、连接数据库、进行CRUD操作（创建、读取、更新、删除）等。
开发环境设置 安装 XAMPP/WAMP/MAMP：这些集成环境包含了Apache服务器、PHP和MySQL。
XAMPP 下载WAMP 下载MAMP 下载 启动 Apache 和 MySQL：安装后，打开控制面板，启动 Apache 和 MySQL 服务。
创建数据库和表 使用 phpMyAdmin 或 MySQL 命令行创建一个数据库和表。
CREATE DATABASE myapp; USE myapp; CREATE TABLE users ( id INT AUTO_INCREMENT PRIMARY KEY, username VARCHAR(50) NOT NULL, email VARCHAR(100) NOT NULL, password VARCHAR(255) NOT NULL, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ); PHP 项目结构 创建项目文件夹，结构如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f644b08cb65c4f5281f13329e1cfd26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef105ce91d11df24b34fa4c9cd3a8996/" rel="bookmark">
			AIGC专栏11——EasyAnimateV2结构详解与Lora训练 最大支持768x768 144帧视频生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AIGC专栏11——EasyAnimateV2结构详解与Lora训练 最大支持768x768 144帧视频生成 学习前言源码下载地址EasyAnimate V2简介技术储备Diffusion Transformer (DiT)Motion ModuleU-VITLora 算法细节算法组成视频VAE视频DIT 数据处理视频分割视频筛选视频描述 模型训练视频VAE视频DIT EasyAnimate V2的Lora训练数据集准备训练sh文件修改开始训练训练结果预测 学习前言 研究了好长时间的文生视频，EasyAnimate到了V2版本，我们将vae修改成了magvit，同时支持图片和视频的训练与预测，另外还引入了U-vit提高训练的稳定性并加快收敛。
现在EasyAnimate最大支持768x768 144帧的视频生成，FPS为24，最长6秒。本文主要进行EasyAnimateV2的算法详解，并且介绍一下如何通过EasyAnimate训练自己的Lora。
源码下载地址 https://github.com/aigc-apps/EasyAnimate
感谢大家的关注。
EasyAnimate V2简介 技术储备 Diffusion Transformer (DiT) DiT基于扩散模型，所以不免包含不断去噪的过程，如果是图生图的话，还有不断加噪的过程，此时离不开DDPM那张老图，如下：
DiT相比于DDPM，使用了更快的采样器，也使用了更大的分辨率，与Stable Diffusion一样使用了隐空间的扩散，但可能更偏研究性质一些，没有使用非常大的数据集进行预训练，只使用了imagenet进行预训练。
与Stable Diffusion不同的是，DiT的网络结构完全由Transformer组成，没有Unet中大量的上下采样，结构更为简单清晰。
在EasyAnimate中，我们将Motion Module网格化后引入到DIT中，借助DIT的强大生成能力，生成视频效果也还不错。
Motion Module AnimateDiff是一个可以对文生图模型进行动画处理的实用框架，其内部设计的Motion Module无需进行特定模型调整，即可一次性为大多数现有的个性化文本转图像模型提供动画化能力。
EasyAnimate参考AnimateDiff使用Motion Module保证视频的连续性。
Motion Module只关注特征点在时间轴上的特征信息，以提炼出合理的运动先验，在AnimateDiff中只更新了运动模块的参数，所以Motion Module是一个可插入的结构，可以用在不同的微调backbone中。
在EasyAnimate中，为了更好的生成效果，我们将backbone连同motion module一起finetune，同时联合图片和视频一起finetune。在一个pipeline中即实现了图片的生成，也实现了视频的生成。
U-VIT 在训练过程中，我们发现纯DIT结构在训练视频时不算稳定，经常存在损失突然上升的情况，并且由于视频的特征层较大，拟合速度较慢。
参考U-vit，我们将跳连接结构引入到EasyAnimate当中，通过引入浅层特征进一步优化深层特征，并且我们0初始化了一个全连接层给每一个跳连接结构，使其可以作为一个可插入模块应用到之前已经训练的还不错的DIT中。
Lora 由《LoRA: Low-Rank Adaptation of Large Language Models》 提出的一种基于低秩矩阵的对大参数模型进行少量参数微调训练的方法，广泛引用在各种大模型的下游使用中。
EasyAnimate有良好的拓展性，我们可以对文生图模型训练Lora后应用到文生视频模型中。
算法细节 算法组成 我们使用了PixArt-alpha作为基础模型，并在此基础上引入额外的运动模块（motion module）来将DiT模型从2D图像生成扩展到3D视频生成上来。其框架图如下：
下图概述了EasyAnimate的管道。它包括Text Encoder、Video VAE（视频编码器和视频解码器）和Diffusion Transformer（DiT）。T5 Encoder用作文本编码器。其他组件将在以下部分中详细说明。
视频VAE 在早期的研究中，基于图像的VAE已被广泛用于视频帧的编码和解码，如AnimateDiff、ModelScope2V和OpenSora。在Stable Dif fusion使用VAE实现将每个视频帧编码为单独的潜在特征，从而将帧的空间维度显著缩小到宽度和高度的八分之一。但这种编码技术忽略了时间信息，将视频降级为静态图像表示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef105ce91d11df24b34fa4c9cd3a8996/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c533aa53dbc30f4ed2a3b36c5f87b42/" rel="bookmark">
			【人工智能】第六部分：ChatGPT的进一步发展和研究方向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人不走空 🌈个人主页：人不走空 💖系列专栏：算法专题 ⏰诗词歌赋：斯是陋室，惟吾德馨 目录
🌈个人主页：人不走空 💖系列专栏：算法专题
⏰诗词歌赋：斯是陋室，惟吾德馨
6.1 多模态模型的发展
6.1.1 现状和挑战
6.1.2 研究方向
6.2 增强的自适应能力
6.2.1 现状和挑战
6.2.2 研究方向
6.3 提高模型的安全性和伦理性
6.3.1 现状和挑战
6.3.2 研究方向
6.4 个性化服务和人机协作
6.4.1 现状和挑战
6.4.2 研究方向
6.5 降低计算成本和提高效率
6.5.1 现状和挑战
6.5.2 研究方向
6.6 社会责任和监管框架
6.6.1 现状和挑战
6.6.2 研究方向
作者其他作品：
在探讨了ChatGPT的技术实现、实际应用案例和未来发展方向后，接下来我们将深入探讨一些具体的进一步发展和研究方向，这些方向可能会塑造未来几年内的ChatGPT及其相关技术。
6.1 多模态模型的发展 6.1.1 现状和挑战 目前的ChatGPT主要处理文本数据，而人类的交流往往是多模态的，包含了文本、语音、图像、视频等多种信息。多模态模型的发展旨在使得语言模型能够理解和生成更加丰富的多模态内容。
挑战：
数据融合：如何高效地融合不同模态的数据，使模型能够在多模态数据之间建立关联。不同模态的数据结构和特征差异大，融合过程中需要解决数据对齐和信息互补的问题。计算资源：处理多模态数据需要更多的计算资源和更复杂的模型架构。尤其是在联合处理高维的图像和视频数据时，计算和存储需求显著增加。训练数据：需要大规模且标注精确的多模态数据集进行训练，这对数据采集和标注提出了更高的要求。多模态数据集的构建不仅需要收集不同模态的数据，还需要确保这些数据之间的关联性和一致性。 6.1.2 研究方向 融合架构：研究如何将Transformer架构扩展到多模态数据，使其能够同时处理文本、图像和音频。例如，Vision Transformer (ViT)已经展示了在图像处理中的潜力，可以与GPT架构结合。未来的研究可以探索如何在统一的框架下处理和融合不同模态的数据，提高模型对多模态信息的理解和生成能力。
联合预训练：开发能够在多模态数据上进行联合预训练的模型，学习不同模态之间的关联和交互方式。例如，OpenAI的CLIP模型已经展示了联合图像和文本预训练的成功案例。通过在多模态数据上进行联合预训练，模型可以更好地理解图像、文本和音频之间的关系，从而在多模态任务中表现出色。
多模态对话系统：开发能够处理包含文本、语音、图像等多种模态的对话系统，提高人机交互的自然度和效率。例如，结合图像识别技术，使得对话系统能够回答与图像相关的问题。未来的多模态对话系统可以集成语音识别、图像识别和自然语言处理技术，实现更加自然和智能的交互体验。
6.2 增强的自适应能力 6.2.1 现状和挑战 现有的ChatGPT模型在训练后，其能力基本固定，很难在新的环境中进行自我调整。增强模型的自适应能力，使其能够在不断变化的环境中自动优化和改进，是未来的重要研究方向。
挑战：
在线学习：如何让模型在新数据到来时能够快速适应，而不需要重新训练整个模型。这涉及到如何高效地整合新数据，同时保持模型性能的一致性。记忆机制：开发有效的记忆机制，使模型能够记住过去的交互和知识，并在适当的时候调用这些记忆。这种机制需要高效且灵活，能够应对多种类型的信息和任务需求。防止灾难性遗忘：在进行在线学习时，如何避免模型遗忘之前学到的知识。灾难性遗忘是深度学习模型在增量学习过程中面临的一个重大问题，需要有效的解决方案来保持模型的长久性能。 6.2.2 研究方向 增量学习：研究增量学习算法，使模型能够在不影响已有知识的情况下，逐步学习新知识。例如，基于Elastic Weight Consolidation (EWC)的增量学习方法。这种方法通过增加对重要参数的约束，防止在新任务学习过程中遗忘之前的知识。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c533aa53dbc30f4ed2a3b36c5f87b42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2acce4c94caec8350562e10fe1eafb1d/" rel="bookmark">
			凡尔码搭建设备巡检系统数字化管理平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、搭建过程概述
利用凡尔码搭建设备巡检的数字化管理平台，首先需要对凡尔码平台有深入的了解，明确其提供的核心功能和特性，以及如何在设备巡检领域发挥其优势。接着，通过系统规划、组件配置、数据录入和表单创建等步骤，逐步搭建起符合设备巡检需求的数字化管理平台。
二、具体搭建步骤
1、系统规划：
明确设备巡检的目标和需求，如提高巡检效率、降低管理成本、确保设备安全稳定运行等。
根据目标和需求，规划数字化管理平台的功能模块、数据流程和信息安全等方面。
2.组件配置：
在凡尔码平台上选择并配置所需的组件模块，如二维码管理、巡检表单、权限管理等。
配置系统平台的安全性和稳定性，确保平台能够稳定可靠地运行。
3、设备信息录入：
通过凡尔码平台为每个设备生成独一无二的二维码，并将设备的基本信息、负责人、操作规范等关键数据录入系统。
将二维码与设备信息进行关联，实现设备信息的电子化管理和快速查询。
4、创建巡检表单：
在凡尔码后台根据设备巡检的具体要求，灵活创建巡检表单。
表单可以包含文字记录、照片、视频、定位等多种元素，以全面记录巡检情况。
5、权限绑定与记录管理：
通过微信公众号或小程序绑定，方便消息通知和任务通知。
设置合适的权限管理，确保不同用户只能访问和操作其被授权的内容。
记录巡检的详细过程和数据，并支持数据汇总导出或打印。
三、优势特点
提高巡检效率：通过数字化管理平台，巡检人员可以实时查看设备信息和巡检要求，快速完成巡检任务。
降低管理成本：无需纸质资料和硬件设备，降低了巡检的物料和人力成本。
确保设备安全稳定运行：实时定位和多种记录方式，有效防止假检和漏检，及时发现并处理设备问题。
数据分析与决策支持：数字化管理平台可以对巡检数据进行统计和分析，为管理层提供决策支持。
通过以上步骤和要点，设备巡检利用凡尔码搭建数字化管理平台可以实现设备信息的电子化管理、巡检过程的数字化记录以及数据的统计与分析等功能，从而提高巡检效率、降低管理成本并确保设备的安全稳定运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1496057e48db03b04e5fa4860ee6078b/" rel="bookmark">
			【机器学习】GBDT (Gradient Boosting Decision Tree) 深入解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈个人主页: 鑫宝Code
🔥热门专栏: 闲话杂谈｜ 炫酷HTML | JavaScript基础 ​💫个人格言: "如无必要，勿增实体" 文章目录 GBDT (Gradient Boosting Decision Tree) 深入解析引言一、GBDT基础理论1.1 梯度提升算法简介1.2 决策树基础 二、GBDT算法流程2.1 初始化与迭代2.2 损失函数与梯度 三、关键参数与调优3.1 参数解释3.2 调优策略 四、GBDT的应用与挑战4.1 应用场景4.2 面临的挑战 五、优化与进阶技术5.1 LightGBM与XGBoost5.2 特征重要性5.3 高维稀疏数据处理 结语 GBDT (Gradient Boosting Decision Tree) 深入解析 引言 GBDT，全称为Gradient Boosting Decision Tree，即梯度提升决策树，是机器学习领域中一种高效且强大的集成学习方法。它通过迭代地添加决策树以逐步降低预测误差，从而在各种任务中，尤其是回归和分类问题上表现出色。本文将深入浅出地介绍GBDT的基本原理、算法流程、关键参数调整策略以及其在实际应用中的表现与优化技巧。
一、GBDT基础理论 1.1 梯度提升算法简介 梯度提升是一种迭代的机器学习算法，其核心思想是利用前一个模型的残差（即真实值与预测值之差）作为当前模型的学习目标，通过不断添加弱学习器（通常是决策树），逐步降低训练数据的损失函数值，直至达到预设的停止条件。
1.2 决策树基础 决策树是GBDT中最常用的弱学习器。它通过一系列if-then规则对数据进行分割，每个内部节点表示一个特征上的测试，每个分支代表一个测试结果，而叶节点则存储一个预测值。决策树的构建过程包括特征选择、节点分裂等步骤，旨在最大化信息增益或基尼不纯度等分裂标准。
二、GBDT算法流程 2.1 初始化与迭代 初始化：首先，GBDT会用一个简单的模型（如常数模型）对所有样本做出初始预测。迭代过程： 计算残差：基于当前模型的预测结果，计算每个样本的真实标签与预测值之间的梯度（对于回归问题通常是真实值减去预测值；对于分类问题，则使用损失函数的负梯度）。拟合决策树：将这些残差作为新的目标变量，训练一个决策树来拟合这些残差。决策树的深度和节点数决定了模型的复杂度。更新预测：将新训练的决策树加入到模型中，更新每个样本的预测值为原预测值加上新决策树的输出。重复上述过程，直到达到预设的迭代次数或满足停止条件。 2.2 损失函数与梯度 GBDT的核心在于如何有效地利用梯度信息指导决策树的生成。不同的任务（如平方损失对应回归，对数损失对应二分类）会有不同的损失函数，其梯度直接指导了模型如何针对当前错误进行修正。
下面是一个使用Python语言及sklearn库实现的简单GBDT（Gradient Boosting Decision Tree）示例代码。这个例子展示的是如何使用GBDT进行一个基本的回归任务。
首先，请确保你的环境中安装了scikit-learn库。如果未安装，可以通过pip命令安装：
pip install scikit-learn 然后，你可以使用以下代码来训练一个GBDT模型：
# 导入必要的库 from sklearn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1496057e48db03b04e5fa4860ee6078b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d22c2e823b8160c4d0b149ab9f6d12d6/" rel="bookmark">
			前端处理流式数据(SSE服务)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 将数据用流的方式返回给客户端,这种技术需求在传统的管理项目中不多见,但是在媒体或者有实时消息等功能上就会用到,这个知识点对于前端还是很重要的。
即时你不写服务端,但是服务端如果给你这样的接口,你也得知道怎么去使用联调。
nodejs实现简单的SSE服务 SSE服务(Server-Sent Events),是一种服务器向客户端推送实时更新的机制模式。
const express = require('express'); const app = express(); const port = 8002; let strArr = [ '所有人,都得死!', '犯我德邦者,虽远必诛!', '吾所成之事,不可逆也!', '一点寒芒先到,随后枪出如龙!', '我的剑就是你的剑!', '刀下生,刀下死!' ] let setTask = null app.get('/events', (req, res) =&gt; { res.setHeader('Content-Type', 'text/event-stream;charset=utf-8'); res.setHeader('Cache-Control', 'no-cache'); res.setHeader('Connection', 'keep-alive'); let num = 0 setTask = setInterval(()=&gt;{ res.write(`data:${strArr[num]}\n\n`) num++ if(num &gt; 5){ res.write(`data:end\n\n`) res.end() // res.closed() clearInterval(setTask) setTask = null } },1000) }); app.listen(port, () =&gt; { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d22c2e823b8160c4d0b149ab9f6d12d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/430d99df276f1f1331f2870dba6b0248/" rel="bookmark">
			Spring-core-MethodParameter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MethodParameter这个类用于方法参数的抽象，例如下面这个方法，我们就可以说test方法包含了3个MethodParameter实例，一个是入参aa，一个是入参bb，还有一个是String类型的返回值
public class AController { public String test(int aa, String bb){ return aa + "_" + bb; } } 如果想创建int a对应的MethodParameter，则应该像下面这样写
public static void main(String[] args) throws Exception { Method method = AController.class.getMethod("test", int.class, String.class); MethodParameter mp = new MethodParameter(method,0); // 此处随便设置一个ParameterNameDiscovery，这样getParameterName的时候能得到正确的name // 可参考源码，它判断了一下这个discovery是不是null，如果不是null，才通过反射取name mp.initParameterNameDiscovery(new DefaultParameterNameDiscoverer()); System.out.println(mp.getParameterName()); } 本文就到这里，比较简单，主要是阐述MethodParameter这个类它代表的是什么，在spring core的模块中，比较常用，尤其是在spring web中，解析controller参数的时候，更常用了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fec733230b8210af0c5b1d0c58c407a6/" rel="bookmark">
			游泳预约报名小程序开发源码案例模板之前端功能介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 越来越多游泳馆使用线上预约报名管理系统，以此来提升游泳馆预约的便捷性以及管理的效率。馆客多小程序是一款实用、便捷的线上运动服务平台，可以让用户轻松预订游泳馆场地并享受自助线上服务，同时也减轻了游泳馆运营压力，提高游泳馆营收能力。
游泳预约报名小程序系统-运行环境
开发语言：PHP
数据库：MySQL
系统架构：TP
后端：SpringBoot
前端：Vue
游泳预约报名小程序开发前端功能介绍：
用户端（小程序）登录登录1.对接微信授权接口登录，手机号授权
2.登录状态缓存首页界面展示1.门店信息：门店列表 门店主页 主图 详情页 门店的产品（课程报名，体验课预约）教练列表 教练详情
轮播图轮播滚动展示
搜索框
2.课程展示：展示课程列表，点击后可查看课程详情
3.门店列表：展示门店列表，支持导航（门店二级分类筛选，比如篮球馆，羽毛球馆等等）
我要入驻（填写表单 字段后台自定义编辑 后台会收到对应的文本信息）
在线客服
报名入口（选择门店，选择课程(游泳课/体验课）填写报名信息，支付购买）
会员入口 购买会员卡
课程1.课程详情：课程轮播图、课程基础信息、课程图文详情介绍、课程评价列表（课程完结后台上传对应的视频或者图文展示在前端）
2.立即购买：填写基础信息后支付 购买成功
3.课程可以到对应门店去线下核销
4.销售可以代用户下单，代下单需要填写 手机号作为 微信识别标识，下单后用户使用该手机号登录，可以同步课程数据
5.可以预约体验课（下单支付生成核销码到对应门店核销）团购团购价1.销售有改价的权限（销售可以发起团购生成团购链接，客户只需要按照团购的费用支付就可以）商品分类（体育用品）分类列表1.按照后台配置的分类展示商品分类列表，二级分类的商品展示；
2.商品列表：根据所选择的分类展示商品列表，商品列表展示模式切换
3.搜索：支持搜索，可进行商品搜索、排序（价格、销量、新品）、
4.分类广告图（后台可配）商品详情1.商品轮播图、商品信息、商品推荐、商品活动、评论列表、功能（加入购物车、立即购买、收藏、联系客服）
2.商品视频:商品主图、详情页可添加视频，现在支持本地视频上传商品规格1.商品可设置单规格/多规格，每个规格有单独的库存、价格（原价/会员价)、成本价等商品收藏1.可收藏商品，收藏商品可删除商品评价1.用户确认收货后可评价商品，后台可以对评论进行回复，负面评价可删除；可添加虚拟评论购物车购物车1.展示添加到购物车的商品，按展示商品，根据账户做缓存
2.可以对商品进行数量的增减，商品删除
3.展示支付价格，勾选全选下单下单1.确认下单商品详细信息、价格
2.确认配送地址，配送地址管理
3.支付：对接微信支付
5.确认下单方式（自提/配送）：用户线上下单，可选择自提或者配送，需要支付，支付后去线下门店取货我的订单订单列表1.订单列表：展示订单列表信息：商品、金额、数量、状态、下单日期
2.订单状态：待支付、代发货/待核销，已完成，售后订单
3.操作：确认完成我的我的1.个人基础信息展示，个人信息修改：头像、姓名
2.平台电话-一键拨打
3.在线客服：对接微信客服
4.关于我们
5.平台协议
6.我的订单
7.我的地址：收货地址管理
8.加入会员（会员权益享受会员价 按照消费金额赠送积分） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/066c0b330f6cfb8761c3f7ab1c992c83/" rel="bookmark">
			手撸 串口交互命令行 及 AT应用层协议解析框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在嵌入式系统开发中，命令行接口（CLI）和AT命令解析是常见的需求。CLI提供了方便的调试接口，而AT命令则常用于模块间的通信控制。本文将介绍如何手动实现一个串口交互的命令行及AT应用层协议解析框架，适用于FreeRTOS系统。
流程图：
这个回调函数 HAL_UART_RxCpltCallback 是用于处理 UART（通用异步收发传输器）接收到的数据。在接收数据的过程中会首先对接收到的字符进行判断，并且判断接收缓冲区是否还有空间，如果已满，则调用 ProcessReceivedFrame 处理数据，并在每次接受满之后重启UART中断。
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) { // 用于检查当前触发中断的 UART 实例是否是我们期望处理的那个实例 xPort。 if (huart-&gt;Instance == xPort.Instance) { // 如果这是接收到的第一个字节，清空接收缓冲区 if (rx_index == 0) { //如果当前接收到的数据是本次接收的第一个字节（rx_index 为 0）， //则将接收缓冲区清空。 memset(rx_buffer, '\0', xPort_RX_BUFFER_SIZE); } // 如果接收到回车符 '\r'，目前没有处理逻辑 if (received_char == '\r') // || cRxedChar == '\r' { // 这里可以添加处理回车符的逻辑 } // 如果接收到换行符 '\n' else if (received_char == '\n') // || cRxedChar == '\r' { if (rx_index !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/066c0b330f6cfb8761c3f7ab1c992c83/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/304/">«</a>
	<span class="pagination__item pagination__item--current">305/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/306/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>