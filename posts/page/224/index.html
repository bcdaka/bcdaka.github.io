<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c7651577873ff6a233faa17f364fa94/" rel="bookmark">
			00. 这里整理了最全的爬虫框架（Java &#43; Python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、前言
2、什么是网络爬虫
3、常见的爬虫框架
3.1、java框架
3.1.1、WebMagic
3.1.2、Jsoup
3.1.3、HttpClient
3.1.4、Crawler4j
3.1.5、HtmlUnit
3.1.6、Selenium
3.2、Python框架
3.2.1、Scrapy
3.2.2、BeautifulSoup + Requests
3.2.3、Selenium
3.2.4、PyQuery
3.2.5、PySpider
3.2.6、Portia
3.2.7、Newspaper
3.2.8、Crawley
3.2.9、Grab
3.2.10、Python-goose
3.2.11、Cola
4、爬虫策略
1、前言 网络爬虫技术在信息时代的大数据时代中变得越来越重要。它是一种从互联网上获取数据的技术，被广泛应用于搜索引擎、数据挖掘、商业情报等领域。
2、什么是网络爬虫 网络爬虫（英语：web crawler），也叫网络蜘蛛（spider），是一种用来自动浏览万维网的网络机器人。其目的一般为编纂网络索引。通常网络爬虫是一种自动化程序或脚本，专门用于在互联网上浏览和抓取网页信息。网络爬虫的主要目的是从网络上的不同网站、页面或资源中搜集数据。它是搜索引擎、数据挖掘、内容聚合和其他信息检索任务的关键组成部分。
网络爬虫的工作方式类似于人类在互联网上浏览网页的过程，但是它能够以更快的速度、更大的规模和更一致的方式执行这些任务。网络爬虫的基本流程包括：
发送请求：爬虫向目标网站发送HTTP请求，请求特定的网页或资源。获取网页内容：爬虫接收到服务器的响应，获取网页的HTML或其他相关内容。解析网页：爬虫使用解析器（如HTML解析器）分析网页的结构，提取需要的信息。存储数据： 爬虫将提取的数据存储到本地数据库、文件或其他存储介质中。遍历链接：爬虫可能会继续遍历网页中的链接，递归抓取更多的页面。 虽然网络爬虫在信息检索和数据分析中具有重要作用，但需要注意合法使用，遵循网站的爬取规则，以及尊重隐私和版权等法律和伦理规定。
3、常见的爬虫框架 爬虫框架是一种用于开发网络爬虫（Web Crawler）的工具或软件框架。网络爬虫是一类程序，用于自动地浏览互联网，并收集、提取感兴趣的信息。爬虫框架提供了一系列的工具和功能，简化了爬虫的开发过程，加速了数据采集的效率。这里汇总了一些常见的Java类爬虫框架和Python类爬虫框架。
3.1、java框架 3.1.1、WebMagic WebMagic是一款基于Java的开源爬虫框架，支持注解和设计模式，简化了爬取任务的实现。官网地址：Introduction · WebMagic Documents
WebMagic的总体架构：
以下是一个简单的WebMagic示例：
import us.codecraft.webmagic.Page; import us.codecraft.webmagic.Site; import us.codecraft.webmagic.Spider; import us.codecraft.webmagic.processor.PageProcessor; public class MySpider implements PageProcessor { private Site site = Site.me().setRetryTimes(3).setSleepTime(1000); @Override public void process(Page page) { // 爬虫逻辑，提取页面内容等 } @Override public Site getSite() { return site; } public static void main(String[] args) { Spider.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c7651577873ff6a233faa17f364fa94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac21c86f6c1527fdd947a0a9869f7653/" rel="bookmark">
			mac app应用程序如何自定义图标, 更换.app为自己喜欢的图标或者图片 详细图文讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在mac系统中，我们可以对任何的app应用程序更换或者自定义图标， 这个图标可以是拥有的app的图标，或者是你自己制作的 x.icns 图标 或者是 任意的图片， 建议大小512x512 。 自定义图标方法如下：
1. 更换为已有app的图标 首先找到你需要的图标的app应用， 然后右键 显示简介 在弹窗中点击左上角的 图标 ， 然后 command +c 复制这个图标
接着选择你要替换图标的app应用， 然后右键 --&gt; 显示简介 , 同样也是选中左上角的图标， 然后 command + v 即可将当前应用的图标替换为刚刚复制的其他应用的图标
接着 command +v 即可替换图标
2. 更换为自定义的incs图标 或者是图片 首先 拷贝你需要的图标或者图片 ， 直接选择图片 右键 拷贝即可
选择要替换图标的app应用--&gt;显示简介 --&gt; 选中左上角的图标 然后comand +v 即可成功替换当前应用的图标为刚刚复制的图片或者icns图标。
总结： mac 系统中，我们要自定义app的图标非常的简单，就是直接选择app后右键 --&gt;显示简介 --&gt; 选择左上角的图标， 然后 command +c 复制图标， command +v 直接替换图标， 这里的图标可以是任意的图片， 其他应用的图标， 或者你自己制作的icns图标。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d836108259e5c6ce93ba2de242523a2a/" rel="bookmark">
			新一代人工智能赋能教育——职称继续教育答题答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新一代人工智能赋能教育 姓名：学员
我的成绩：100 分
开始时间：2024-06-27 09:00:08
交卷时间：2024-06-27 09:02:49
答题用时：00:02:39
已做1次 [查看考试记录]
单选题 1、下面对人工智能是通用目的战略技术（General purpose technologies ）描述不正确的是（ ）（50 分）
A．通用目的技术是使能技术(enabling technology)，但不是完整的最终解决方案。
B．人工智能犹如历史上蒸气机、电力、计算机和互联网等发明创造，是一种通用使能技术，正深刻地以史无前例速度改变人类社会和经济发展。
C．人工智能天然具备推动学科交叉的潜力，其与不同学科专业知识结合，形成AI+X的新研究格局。
D．人工智能是通用目的技术，因此就是解决方案的全部，与其他技术没有任何联系
我的答案：D
得分：50分
2、人工智能两落三起的主要原因是（ ）（50 分）
A．政府的支持力度不够大。
B．人工智能研究学者过少。
C．人工智能未能解决现实生活中问题，仅能解决玩具类问题。
D．人工智能的国际交流较少。
我的答案：C
得分：50分
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/309caa8c9ef21cf218f9e83028553b82/" rel="bookmark">
			未来可能会被淘汰的编程语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多时候
爱情是在一些经不起考验的
瞬间完全就消失了
技术的进步，会带来新的技术，也会伴随着旧的技术的淘汰，再加上AI的兴起以及对编程语言使用方式的影响，我们需要关注哪些语言将在未来继续流行，哪些会被淘汰。
从近30年的编程语言排行来说，Python、Java 和 JavaScript ，c++多功能编程语言持续主导编程世界。
上图是近10年的排行变化，可以看出 JS、Python 和 Java 始终位于前五名，稳得一批。
下面就来说说在未来大概率会消失的编程语言。
第一个，R语言
R 语言过去几年是数据分析领域的一个明星语言，和Python搭配着搞数据分析。如今Python已经逐渐侵蚀了R语言的地盘。
可以看看R语言的排名，20到30的语言基本在企业中应用的比较少了。
第二个，Visual basic
这个语言来自微软1991年发布的，在2020年微软自己宣布停止开发VB了，其淘汰只是时间问题。
VB的图标很像visual studio的图标，因为vs最早就是用vb开发的，但是2000年左右就被vb .net替代了，但2种语言都没击起什么浪花。
微软目前能打的语言也就c#了。
第三个，Fortran
Fortran已经是60多岁的语言了。相信很多人最近听过它也是因为它进了排行榜前十。
它主要用于工程计算，很接近数学公式的自然描述，虽然今年突然冲进了前十，但是很可能会被更专业的AI代替。
第四个，Perl
Perl语言绝对是早期编程语言的优秀代表，很多后来的语言都多多少少受到它的影响。
其实Perl的衰落几年前就开始了，一直是稳步下降，又是被脚本之王的Python夺去了所剩无几的光辉。
第五个，Ruby
Ruby是1999年发布的，它的巅峰时期是在2004到2010年，主要是Ruby on Rails带火了Ruby语言。
主要原因是运行速度太难，太灵活了以至于很容易出bug，逐渐被JavaScript、Go和Python比了下去。
第六个，Objective-C
Objective-C与Apple的关系类似于二郎神和哮天犬，从1996年到2016年，它是开发macOS，IOS，OSX操作系统的男一号。
但是随着苹果公司在2814年发布Swift，宣布它成为苹果所有操作系统的新王地位之后，很多开发者开始顺时代学习Swift。甚至之前还有歌手王力宏也开始学习Swift的新闻带火了Swift。
最后
其实和人一样，跟不上时代发展的的语言注定会被人们遗忘在角落里。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e94880dce3f11c7d30afbf03529c7e4/" rel="bookmark">
			SpringMVC 请求参数接收
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
请求
传递单个参数
基本类型参数传递
未传递参数
传递参数类型不匹配
传递多个参数
传递对象
后端参数重命名
传递数组
传递集合
传递JSON数据
JSON是什么
JSON的优点
传递JSON对象
获取URL中的参数
文件上传
在浏览器与程序进行交互时，主要分为三个阶段：
1. 建立连接：将用户（浏览器）和 Java 程序连接起来，也就是访问一个地址能够调用到 Spring程序
2. 请求：用户请求时会携带一些参数，在程序中要想办法获取到参数，因此请求这部分主要是获取参数的功能
3. 响应：在执行了业务逻辑之后，要将程序执行的结果返回给客户，也就是响应 在本篇文章中，我们来学习请求（获取参数 ）这部分内容
请求 访问不同的路径，就是发送不同的请求，在发送请求时，可能会带一些参数，因此学习 Spring 的请求，主要就是学习 如何传递参数到后端 以及 后端如何接收参数
在本篇文章中，为了更方便学习，则不采用前端传递参数，而是使用 浏览器 和 postman 来模拟
传递单个参数 接收单个参数时，直接用方法中的参数即可：
@RequestMapping("/user") @RestController public class UserController { @RequestMapping(value = "/login") public String login(String name) { return "接收到用户名: " + name; } } 使用 浏览器发送请求：127.0.0.1:8080/user/login?name=zhangsan
后端程序正确拿到 name 参数的值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e94880dce3f11c7d30afbf03529c7e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a156443c7dd73aa11d6c16927166c65/" rel="bookmark">
			【机器学习】K-means&#43;&#43;: 一种改进的聚类算法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈个人主页: 鑫宝Code
🔥热门专栏: 闲话杂谈｜ 炫酷HTML | JavaScript基础 ​💫个人格言: "如无必要，勿增实体" 文章目录 K-means++: 一种改进的聚类算法详解引言1. K-means算法回顾1.1 基本概念1.2 局限性 2. K-means++算法介绍2.1 初始质心选择策略2.2 算法优势 3. K-means++算法实现步骤3.1 准备工作3.2 初始化质心3.3 迭代优化3.4 结果评估 4. 实际应用案例4.1 数据降维4.2 客户细分4.3 文档分类 5. 总结 K-means++: 一种改进的聚类算法详解 引言 在数据分析与机器学习领域，聚类算法作为无监督学习的重要组成部分，被广泛应用于数据分组、模式识别和数据挖掘等场景。其中，K-means算法以其简单直观和高效的特点，成为最常用的聚类方法之一。然而，经典K-means算法在初始聚类中心的选择上存在随机性，可能导致算法陷入局部最优解。为解决这一问题，2007年，David Arthur 和 Sergei Vassilvitskii 提出了K-means++算法，它通过一种智能化的初始化策略显著提高了聚类质量。本文将深入探讨K-means++算法的原理、优势、实现步骤以及实际应用案例，旨在为读者提供一个全面且易于理解的K-means++算法指南。
1. K-means算法回顾 1.1 基本概念 K-means算法的目标是将数据集划分为K个簇（clusters），每个簇由距离其质心（centroid）最近的数据点组成。算法迭代执行以下两个步骤直至收敛：
分配步骤：将每个数据点分配给最近的质心。更新步骤：重新计算每个簇的质心，即该簇所有点的均值。 1.2 局限性 对初始质心敏感：随机选择的初始质心可能导致算法陷入局部最优解。不适合处理不规则形状的簇：倾向于形成球形或凸形簇。难以处理大小和密度变化较大的簇。 2. K-means++算法介绍 2.1 初始质心选择策略 K-means++算法的核心改进在于其初始化过程，具体步骤如下：
从数据集中随机选择第一个质心。对于每个数据点x，计算其到已选择的所有质心的最短距离D(x)。选择一个新的数据点作为下一个质心，选择的概率与D(x)成正比，即概率P(x) = D(x) / ΣD(x)。重复步骤2和3，直到选择了K个质心。 这种选择策略确保了质心之间的分散性，从而提高了聚类效果。
2.2 算法优势 减少局部最优解的风险：更大概率选择相距较远的初始质心，提高聚类质量。理论保证：K-means++能够给出接近最优解的界，即与最优聚类方案的距离平方误差最多是理论最小值的8倍。效率：虽然初始化复杂度有所增加，但整体算法依然保持高效，尤其是对于大规模数据集。 3. K-means++算法实现步骤 3.1 准备工作 确定K值：根据实际需求预先设定簇的数量。数据预处理：标准化或归一化数据，以消除量纲影响。 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a156443c7dd73aa11d6c16927166c65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65f0bf840f79d693c939d07eb6a615fc/" rel="bookmark">
			VUE JS 将html转成pdf 例子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Vue.js中生成PDF文件，可以使用html2canvas和jspdf库。
安装依赖库 npm install html2canvas jspdf 在Vue组件中使用 &lt;template&gt; &lt;div&gt; &lt;button @click="generatePDF"&gt;生成PDF&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import html2canvas from 'html2canvas'; import jsPDF from 'jspdf'; export default { methods: { generatePDF() { const element = document.body; // 或者任何你想转换为PDF的DOM元素 html2canvas(element).then((canvas) =&gt; { const imgData = canvas.toDataURL('image/png'); const pdf = new jsPDF({ orientation: 'portrait', unit: 'px', format: 'a4', }); const imgProps= pdf.getImageProperties(imgData); const pdfWidth = pdf.internal.pageSize.getWidth(); const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width; pdf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65f0bf840f79d693c939d07eb6a615fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06d1cc0833df5e9abd015318769bdc95/" rel="bookmark">
			计算机必背单词——数据库性能相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这些都是我认为程序员需要掌握的单词，就算有些英文你不熟悉，但是对应的中文至少了解什么意思。
看完这个系列，希望你第一能认识更多单词，第二是拓宽自己的知识面，哪个概念不懂就自己去主动了解。
Optimizer Hints: 优化器提示
Full Table Scan: 全表扫描
Covering Index: 覆盖索引
B-Tree Index: B树索引
Hash Index: 哈希索引
Spatial Index: 空间索引
Index Merge: 索引合并
Partial Index: 部分索引
Bitmap Index: 位图索引
Query Refactoring: 查询重构
Stored Procedure: 存储过程
Trigger: 触发器
Views: 视图
Batch Processing: 批处理
Cardinality: 基数
Data Skew: 数据偏斜
Table Statistics: 表统计信息
Cost-Based Optimizer (CBO): 基于成本的优化器
Rule-Based Optimizer (RBO): 基于规则的优化器
Connection Pooling: 连接池
Prepared Statements: 预处理语句
Column Store: 列存储
Database Sharding: 数据库分片
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06d1cc0833df5e9abd015318769bdc95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09f59adab3f0bae85522fe89a427adba/" rel="bookmark">
			速盾：ddos高防ip是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DDoS攻击是一种通过向目标网络发送大量的无效请求，以致其无法正常运作的攻击方式。这种攻击方式广泛应用于各种网络服务，如网站、服务器、游戏等。由于DDoS攻击可以导致被攻击的网络瘫痪，因此许多组织和个人都开始关注网络安全，并采取了各种措施，其中之一就是使用DDoS高防IP。
DDoS高防IP是一种特殊的IP地址，具有强大的抗DDoS攻击功能。它通过网络流量清洗和分流技术，可以有效地过滤掉恶意流量，确保网络服务的正常运行。与普通的IP地址相比，DDoS高防IP可以提供更高的带宽和更强大的防护能力，能够承受更大规模的DDoS攻击。
使用DDoS高防IP可以带来许多好处。首先，它可以保护网络服务免受DDoS攻击的影响。通过过滤掉恶意流量，DDoS高防IP可以确保正常用户的请求正常访问目标网络，同时阻止恶意攻击者的访问。其次，DDoS高防IP可以提供更高的带宽，确保网络服务在面对大规模的DDoS攻击时依然能够正常运行。此外，DDoS高防IP还可以提供实时的攻击监控和报警功能，让网络管理员及时了解网络安全状况，并采取相应的措施进行应对。
DDoS高防IP的技术原理主要包括流量过滤和分流。流量过滤通过识别和过滤恶意流量，以确保正常用户的请求正常通过，同时阻止恶意攻击者的访问。流量分流则通过将流量分散到多个服务器上，以减轻单个服务器的负载压力，并确保网络服务的正常运行。这些技术可以通过硬件设备或云服务来实现，具体取决于组织的需求和预算。
在选择DDoS高防IP时，组织需要考虑一些关键因素。首先是带宽和防护能力。带宽决定了网络服务的传输速度和响应时间，而防护能力决定了DDoS攻击所能承受的规模。组织需要根据自身的业务需求来选择合适的带宽和防护能力。其次是性能和稳定性。DDoS高防IP需要能够处理大量的网络流量，并保持稳定的运行。组织需要选择性能强大和稳定可靠的DDoS高防IP供应商。最后是价格。DDoS高防IP的成本因供应商和配置而异，组织需要根据自身的财务情况和预算来选择合适的产品。
总结起来，DDoS高防IP是一种提供强大抗DDoS攻击功能的IP地址。它通过流量过滤和分流等技术，可以保护网络服务免受DDoS攻击的影响，同时提供更高的带宽和更强大的防护能力。选择合适的DDoS高防IP需要考虑带宽和防护能力、性能和稳定性以及价格等因素。使用DDoS高防IP可以帮助组织提高网络安全性，确保网络服务的正常运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/501a05ebcdba5cc7583f436fef6a4a90/" rel="bookmark">
			数据结构--栈与队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.栈
1.1栈的概念及结构
1.2栈的实现
2.队列
2.1队列的概念及结构
2.2队列的实现
3.栈和队列经典题目
1.括号匹配问题
2. 用队列实现栈
1.栈 1.1栈的概念及结构 栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。 进行数据插入和删除操作的一端 称为 栈顶 ，另一端称为 栈底 。 栈中的数据元素遵守后进先出 LIFO （ Last In First Out ）的原则。 压栈 ：栈的插入操作叫做进栈 / 压栈 / 入栈， 入数据在栈顶 。 出栈 ：栈的删除操作叫做出栈。 出数据也在栈顶 。 1.2栈的实现 栈的实现一般可以使用 数组或者链表实现 ，相对而言数组的结构实现更优一些。因为数组在尾上插入数据的代价比较小。 #include"Queue.h" //初始化 void QueueInit(Queue* pq) { assert(pq); pq-&gt;phead = NULL; pq-&gt;ptail = NULL; pq-&gt;size = 0; } //销毁 void QueueDestroy(Queue* pq) { assert(pq); QNode* cur = pq-&gt;phead; while (cur) { QNode* next = cur-&gt;next; free(cur); cur = next; } pq-&gt;phead = pq-&gt;ptail = NULL; pq-&gt;size = 0; } // 队尾插入 void QueuePush(Queue* pq, QDataType x) { assert(pq); QNode* newnode = (QNode*)malloc(sizeof(QNode)); if (newnode == NULL) { perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/501a05ebcdba5cc7583f436fef6a4a90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83faeb6588631c6b52b8209e3868615b/" rel="bookmark">
			设计模式原则——接口隔离原则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设计模式原则 设计模式示例代码库地址： https://gitee.com/Jasonpupil/designPatterns
接口隔离原则 要求程序员尽量将臃肿庞大的接口拆分为更小的和更具体的接口，让接口中只包含客户感兴趣的方法接口隔离原则的目标是降低类或模块之间的耦合度，提高代码的可维护性、可扩展性和可测试性。通过使用多个专门的接口，我们可以避免类或模块之间出现不必要的依赖关系，减少对无用接口的实现或调用，从而降低了修改和维护的成本。 模式场景：学校管理系统，不同角色的功能 接口隔离原则替换前：定义一个角色接口，包含几个功能：成绩查询、成绩上传和教师管理，所有角色都实现了这个接口，但是不同角色的权限不同，只能使用对应权限的功能，比如：学生只能成绩查询，而老师就可以成绩查询和成绩上传。如果都实现同一个接口，还需要进行每个功能进行隔离比较麻烦。接口隔离原则替换后：把角色功能接口根据每个功能进行拆分，角色类实现对应权限的功能接口，这样就简化了角色类里实现功能隔离。 接口隔离原则替换前示例代码：功能没有具体实现，主要看逻辑是怎么样 角色功能接口： /** * @Description: 角色接口 * @Author: pupil * @Date: 2024/06/26 下午 11:29 */ public interface Role { /** * 成绩查询 * @param userId 学生id * @return */ String scoreInquiry(long userId); /** * 成绩上传 * @param userId 学生id * @param grades 成绩 */ void gradeUpload(long userId, Map&lt;String,Double&gt; grades); /** * 教师管理 * @param teacherId 教师id */ void teacherManagement(long teacherId); } 校长类： /** * @Description: 校长，功能没有具体实现 * @Author: pupil * @Date: 2024/06/26 下午 11:30 */ public class Principal implements Role { private Logger logger = LoggerFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83faeb6588631c6b52b8209e3868615b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2a11ee77bf27979a01a482f78aaf44d/" rel="bookmark">
			操作符详解（上） (C语言)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作符详解（上） 一. 进制转换1. 二进制2. 二进制的转换 二. 原码 补码 反码三. 操作符的分类四. 结构成员访问操作符1. 结构体的声明2. 结构体成员访问操作符 一. 进制转换 1. 二进制 在学习操作符之前，我们先了解一些2进制、8进制、10进制等的问题，我们在平时的学习中经常听到关于进制转换的问题，其实就是数字的表达形式不同，比如我们将数字15用不同的进制表示出来：
(另外16进制前面加的是0x，8进制前面加的是0)
我们重点介绍一下二进制：
首先我们还是得从10进制讲起，其实10进制是我们⽣活中经常使用的，我们已经形成了很多尝试：
• 10进制中满10进1
• 10进制的数字每一位都是0~9的数字组成
其实二进制也是一样的
• 2进制中满2进1
• 2进制的数字每⼀位都是0~1的数字组成
那么1101 就是二进制的数字了。
2. 二进制的转换 (1) 2进制转8进制：比如15的二进制是1111，那么换成8进制就是利用15除以8看每次的余数和商，那么8进制就是17，其实8进制的每⼀位是有权重的，8进制的数字从右向左是个位、⼗位、百位…，分别每⼀位的权重是80、81、82…那么15也就是80 *7+81 *1，这就是15从二进制转成了8进制。
(2) 10进制转2进制：道理是一样的，10进制的每⼀位是有权重的，10进制的数字从右向左是个位、⼗位、百位…，分别每⼀位的权重是 100 , 101 , 102…比如123用10进制表示就是123，而转为2进制：
二. 原码 补码 反码 当我们掌握了2进制等的转换，我们就要了解一下计算机中对于整数的三种表现形式，即整数的原码、补码、反码。有符号整数的三种表示方法均有符号位和数值位两部分，2进制序列中，最高位的1位是被当做符号位，剩余的都是数值位。
符号位都是用0表示“正”，用1表示“负”。(一个整型是由四个字节组成，一个字节占8个bit位，所以一共由32个bit组成)
正整数的原、反、补码都相同。
负整数的三种表示方法各不相同。
原码：直接将数值按照正负数的形式翻译成二进制得到的就是原码。
反码：将原码的符号位不变，其他位依次按位取反就可以得到反码。
补码：反码+1就得到补码。
补码得到原码也是可以使用：取反，+1的操作。
比如：15的原码补码反码是00000000000000000000000000001111
而 -15的原码是10000000000000000000000000001111，反码11111111111111111111111111110000(符号位不变，其他位按位取反)，补码是11111111111111111111111111110001(末尾加1，得2进1,反码加1就是补码)
对于整形来说：数据存放内存中其实存放的是补码。为什么呢？
在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统⼀处理；同时，加法和减法也可以统⼀处理（CPU只有加法器）此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。
三. 操作符的分类 (1) 移位操作符：&lt;&lt;左移操作符 --------- &gt;&gt;右移操作符，注意移位操作符只能适用于整数！并且移动的是二进制位中的补码。
下面展示一些 内联代码片。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2a11ee77bf27979a01a482f78aaf44d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95e490f737ac47b3c4c558c500dd1103/" rel="bookmark">
			【Python datetime模块精讲】：时间旅行者的日志，精准操控日期与时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、datetime模块简介二、常用类和方法三、date类四、time类五、datetime类六、timedelta类七、常用的函数和属性八、代码及其演示 前言 Python的datetime模块提供了日期和时间的类，用于处理日期和时间的算术运算。这个模块包括date、time、datetime和timedelta等类，以及tzinfo接口和timezone类。date类用于表示年、月、日，而time类表示时间。datetime类结合了日期和时间，提供了一个单一的日期时间对象。timedelta类用于表示两个日期或时间之间的差异。此外，tzinfo接口允许用户定义时区信息，而timezone类提供了时区的实现。datetime模块广泛用于需要日期和时间计算的应用程序，如日志记录、调度和数据时间戳。它的强大功能和灵活性使其成为Python标准库中不可或缺的一部分。
一、datetime模块简介 datetime模块是Python标准库中处理日期和时间的常用模块之一。它提供了日期和时间的表示、比较和运算方法，以及常见的格式化和解析函数。
二、常用类和方法 # datetime模块提供了许多有用的类和方法，下面是其中一些常用的： # 导入datetime模块 import datetime 类或方法描述datetime.date表示一个具体的日期，包括年份、月份和日数datetime.time表示一个具体的时间，包括小时、分钟、秒和微秒datetime.datetime表示一个具体的日期和时间，包括日期和时间的所有信息datetime.timedelta表示两个日期或时间之间的差距datetime.datetime.today() / datetime.datetime.now()返回表示当前日期和时间的对象datetime.datetime.fromtimestamp(ts)将时间戳转换为datetime对象datetime.datetime.strftime(format) / datetime.datetime.strptime(date_string, format)将datetime对象格式化为字符串，或将字符串解析为datetime对象 时间格式化符号
格式描述注释%Y年2021%y年21%m月%d日%H时24小时制（晚上九点：21:00）%I时12小时制（晚上九点：9:00）%M分%S秒%p上午AM 下午 PM 三、date类 # date类表示一个具体的日期，其中包括以下属性： 属性描述year年份month月份day日数weekday()返回星期几（0表示星期一，6表示星期日）isoweekday()返回ISO规定的星期几（1表示星期一，7表示星期日）isocalendar()返回一个元组，其中包含年份、周数和星期几strftime(format)将date对象格式化为字符串 # 创建一个date对象: d = datetime.date(year, month, day) d = datetime.date(2023, 5, 11) year属性表示日期对象的年份month属性表示日期对象的月份day属性表示日期对象的日数isoweekday()方法返回ISO规定的星期几，其中1表示星期一，7表示星期日。weekday()方法返回星期几，其中0表示星期一，6表示星期日。isocalendar()方法返回一个元组，其中包含年份、周数和星期几。 import datetime d = datetime.date(2023, 5, 11) print(d.year) # 2023 print(d.month) # 5 print(d.day) # 11 print(d.isoweekday()) # 4 print(d.weekday()) # 3 print(d.isocalendar()) # (2023, 19, 4) strftime()方法将date对象格式化为字符串。format参数是一个格式化字符串，其中包含特定的代码，代表日期和时间的不同部分。
import datetime d = datetime.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95e490f737ac47b3c4c558c500dd1103/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91b15b56a5ffeb41095b7f7d7008dfe6/" rel="bookmark">
			刷题——二叉树的后续遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：双指针法
void postorder(TreeNode* root, vector&lt;int&gt;&amp;res) { if(root == NULL) return; postorder(root-&gt;left,res); postorder(root-&gt;right,res); res.push_back(root-&gt;val); } vector&lt;int&gt; postorderTraversal(TreeNode* root) { // write code here vector&lt;int&gt;res; postorder(root, res); return res; } 方法二：入栈出栈法
vector&lt;int&gt; postorderTraversal(TreeNode* root) { vector&lt;int&gt; res; stack&lt;TreeNode*&gt; s; TreeNode* prev = nullptr; // 用于跟踪上一个访问的节点 while (root != nullptr || !s.empty()) { while (root != nullptr) { s.push(root); root = root-&gt;left; // 先尽可能遍历到最左边 } root = s.top(); // 获取当前栈顶元素（最深的未完全访问的节点） // 检查是否可以访问当前节点（即其右子树已访问或无右子树） if (root-&gt;right == nullptr || root-&gt;right == prev) { res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91b15b56a5ffeb41095b7f7d7008dfe6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee0ef54db0e84d1113ccdc3fc43f10d1/" rel="bookmark">
			【软件工具】在Java语言中如何使用 Kafka 消费者（KafkaConsumer）来消费消息及如何用idea实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java语言中如何使用 Kafka 消费者（KafkaConsumer）来消费消息及如何用idea实现 一、在Java语言中如何使用 Kafka 消费者（KafkaConsumer）来消费消息1. 引入 Kafka 客户端依赖2. 创建 KafkaConsumer 配置3. 创建 KafkaConsumer 实例4. 订阅主题（Topic）5. 消息消费循环6. 处理异常和关闭消费者完整示例注意事项 二、如何在IDEA 中实现1. 创建 Maven 项目2. 添加 Kafka 依赖3. 创建 KafkaConsumer 应用程序4. 配置 Kafka 服务器地址和主题5. 运行 KafkaConsumer 应用程序6. 检查消费日志 一、在Java语言中如何使用 Kafka 消费者（KafkaConsumer）来消费消息 在Java语言中使用 Kafka 消费者（KafkaConsumer）来消费消息是非常常见的场景，特别是在分布式系统和实时数据处理中。下面详细介绍如何编写和配置 Kafka 消费者的基本步骤：
1. 引入 Kafka 客户端依赖 首先，确保项目中引入了 Kafka 客户端依赖，例如 Maven 的依赖配置如下：
&lt;dependency&gt; &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt; &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt; &lt;version&gt;2.8.1&lt;/version&gt; &lt;!-- 替换为当前最新版本 --&gt; &lt;/dependency&gt; 2. 创建 KafkaConsumer 配置 KafkaConsumer 需要配置 Kafka 的连接信息和消费者的属性。通常，你需要指定以下配置：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee0ef54db0e84d1113ccdc3fc43f10d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf9bbea22be1132ead57777adcfb8907/" rel="bookmark">
			Android Studio中HAXM安装失败的解决方案（HAXM installation failed）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 错误示例Hyper-VWindows SandboxWindows Hypervisor Platform（Windows 虚拟化监控程序平台） 出现原因解决方法虚拟机平台方案一方案二方案三 错误示例 表明HAXM (Hardware Accelerated Execution Manager)安装失败了。HAXM是一个硬件辅助虚拟化引擎,用于加速Android模拟器的性能。
C:\Users\33546\AppData\Local\Temp\haxm_install-20240626_2210.log：表示错误日志，具体情况可以查看日志，私聊博主。
比如下方错误日志，表示当前处理器（CPU）不支持 Intel 的虚拟化技术，查询当前CPU是否支持，如果支持，采取方案三即可！
Hyper-V Hyper-V 是 Microsoft 提供的虚拟化平台，允许用户在 Windows 上创建和管理虚拟机。它支持多种操作系统，并提供虚拟机间的隔离、资源分配和网络虚拟化功能，适用于开发、测试和服务器托管等需要多个操作系统环境的场景。
Windows Sandbox Windows Sandbox 是一种轻量级的桌面环境，允许用户在隔离的临时环境中运行不受信任的软件。每次启动时都会创建一个全新的环境，关闭后所有更改都会被丢弃，适用于快速测试可疑软件或运行不受信任程序的场景，确保主机系统的安全。
Windows Hypervisor Platform（Windows 虚拟化监控程序平台） Windows Hypervisor Platform (WHP) 是 Windows 操作系统中的一个组件，提供了虚拟化的基础设施，使得第三方虚拟机管理软件可以利用 Windows 的虚拟化功能。主要特点包括：
虚拟化接口：提供一组 API，使第三方虚拟机管理器（如 VirtualBox 和 VMware）能够在Windows 上运行，并利用 Hyper-V 的虚拟化功能。硬件加速：利用硬件虚拟化技术（如 Intel VT-x 和 AMD-V）来提高虚拟化性能。兼容性：支持各种第三方虚拟化解决方案，增加了 Windows 平台的灵活性。 出现原因 CPU不支持硬件虚拟化技术(Intel VT-x)，无法解决与其他虚拟化软件(如Hyper-V, VMware)冲突系统驱动程序过时或损坏，更新驱动即可之前的HAXM安装未完全卸载 解决方法 虚拟机平台 虚拟机平台 (Virtual Machine Platform) 是 Windows 中的一个可选功能，用于支持虚拟化应用程序。为虚拟机提供底层支持。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf9bbea22be1132ead57777adcfb8907/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e623ed45e1ef70f233615eb7d2a2ec6/" rel="bookmark">
			python数据可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Matplotlib二、Pyplot模块2.1、Pyplot介绍2.2、Pyplot优势与劣势2.3、Pyplot的使用 三、Pyplot示例3.1、绘制周期正弦曲线3.2、虚线绘制正弦曲线3.3、同时绘制正弦曲线和余弦曲线3.4、在图形中使用文字3.5、绘制线形图3.6、在一个坐标中绘制三条曲线3.7、绘制散点图3.8、绘制直方图3.9、绘制饼图 matplotlib
一、Matplotlib Matplotlib是一个用于创建静态、动态和交互式图表的Python绘图库。它的设计初衷是模仿MATLAB的绘图功能，但使用Python语言实现，因此也获得了与Python良好的集成性。作为Python中最受欢迎的数据可视化工具之一，它广泛应用于科学计算、数据分析等领域，为开发者和研究者提供了丰富多样的图表类型与高度定制的绘图选项。
Matplotlib能够支持跨平台运行，其底层主要使用Tkinter进行GUI渲染，而绘图功能则依赖于NumPy与Pandas等科学计算库。这样的设计不仅提高了数据处理的效率，也使得其在Python的生态系统中无缝集成。
Matplotlib具备非常丰富的图表类型支持，如线图、散点图、柱状图、饼图、等高线图以及3D图形等，几乎涵盖了所有常见的图表需求。它甚至支持绘制图形动画，这使得在展示复杂数据时序变化或者动态系统模拟时变得更加生动与直观。
Matplotlib非常易于学习和使用，其设计哲学是提供简洁的API，使得即使是初学者也能快速上手。通过简单的函数调用，用户就可以完成从数据到图表的转换，而不需要深入了解绘图的细节。同时，它的灵活性主要体现在对图表的高度定制能力上，包括修改图表的颜色、标签、图例、坐标轴等属性，可以满足各种专业出版或者高质量视觉展示的需求。
无论是在商业分析、科学研究还是教育讲授中，数据可视化均显示出其不可替代的重要性。例如，企业在进行市场分析时，可以通过Matplotlib绘制的销售趋势图来辅助决策；科研人员在进行实验数据分析时，可以使用散点图或折线图来揭示变量之间的关系；教师在讲解统计数据时，也可以通过柱状图来直观展示数据分布。
除了丰富的图表类型和高度定制性外，Matplotlib还提供了对绘图样式的控制。用户可以加载不同的风格包（stylesheets），或自定义风格包，以适应不同的视觉需求。同时，Matplotlib社区提供了大量的插件和工具，用以增强其功能，比如与IPython、Jupyter Notebook的集成，可以方便地进行交互式绘图和即时展示。
二、Pyplot模块 2.1、Pyplot介绍 Pyplot是Matplotlib中用于创建二维图形的模块。
Pyplot模块提供了类似于MATLAB的绘图API，使得用户能够方便地绘制2D图表。该模块包含了一系列的绘图函数，每个函数都能对当前的图像进行修改，比如添加标记、生成新的图像以及创建新的绘图区域等。用户可以通过简单的导入和设置操作来使用这些功能。
Pyplot非常适合于需要进行数据可视化的各种场景，例如科学计算、数据分析、商业报表等。它的优势在于使用简便且功能强大，支持多种图表类型，如线图、散点图、条形图、直方图和饼图等。
2.2、Pyplot优势与劣势 易用性 优点：Pyplot提供了简单易用的API，使得用户可以轻松地创建各种类型的图表，如线图、散点图、柱状图、饼图等。通过简单地导入并使用不同的函数，比如plot()、scatter()等，即使是初学者也能迅速上手。劣势：尽管pyplot相对易用，但对于初学者来说，其语法仍然较为复杂，需要花费一定时间来学习和掌握。对于需要快速创建简单图表的用户来说，可能会觉得有些繁琐。 定制性 优点：Pyplot提供了丰富的参数设置和样式定制选项，用户可以根据自己的需求对图表进行个性化定制。这包括颜色、标记、线条样式、标题、标签、轴线、刻度和图例等各种元素的调整，从而可以创建出非常精美的图表。劣势：尽管可定制性强，但Pyplot的某些默认设置（如刻度、标签等）可能不符合用户的实际需求，需要手动进行调整。有时，默认样式也可能看起来不够美观，需要进一步定制才能达到预期效果。 兼容性 优点：Pyplot支持多种操作系统和绘图环境（如Jupyter Notebook、PyCharm等），并且能与其他常用的科学计算库（如Numpy、Pandas等）无缝集成。这种兼容性使得用户可以在各种平台上方便地使用Pyplot进行数据可视化。劣势：虽然支持多种环境，但在某些特定环境下可能会出现兼容性问题，这需要用户具备一定的技术背景来解决。 交互性 优点：Pyplot提供一定的交互功能，比如鼠标指针悬停提示、拖动和缩放等，这些功能使得数据分析变得更加方便和快捷。劣势：相比于一些专门的交互式可视化工具，Pyplot的交互性有限，不支持复杂的交互式可视化操作，如通过鼠标交互来控制图表的展示。 扩展性 优点：Pyplot作为Matplotlib的一部分，具有良好的可扩展性。用户可以自定义插件、主题、样式和色彩等，以满足特定的数据可视化需求。同时，Matplotlib社区活跃，不断地推出新的版本和更新，帮助用户及时了解最新技术和优化。劣势：虽然可扩展性良好，但对于普通用户来说，编写自定义插件或修改底层代码可能需要一定的编程知识和经验。 性能 优点：Pyplot能够处理中等规模数据集的可视化需求，并且支持跨平台运行，可以在Windows、Linux和Mac等多个平台上运行。劣势：当处理大型数据集时，Pyplot的绘图速度相对较慢，可能需要等待较长时间才能完成。对于需要实时数据可视化的应用场景，它也不直接支持动态更新和展示数据。 支持性 优点：Pyplot拥有庞大的用户社区和开发者社区，用户可以从社区中获得大量的帮助和支持。同时，网络上有大量的文档和教程可供学习，这对于新手来说尤为宝贵。劣势：尽管社区活跃且资源丰富，但Pyplot的官方文档在某些时候可能不够全面，并且可能会令人困惑。对于某些特定问题，用户可能需要依靠社区论坛或Stack Overflow等第三方平台来获取解决方案。 实用性 优点：Pyplot支持多种输出格式，包括PNG、PDF、SVG、EPS等，方便用户将图表嵌入到文档中或者在网页上展示。劣势：尽管支持多种输出格式，但在特定应用场景下，比如需要高质量印刷品或者特定分辨率的图像时，可能需要额外的调整和设置。 2.3、Pyplot的使用 安装和导入库 安装Matplotlib：首先需要在你的Python环境中安装Matplotlib库，可以通过pip进行安装，命令为pip install matplotlib。
导入Pyplot模块：在Python脚本或者Jupyter notebook中，导入matplotlib.pyplot模块，并为其设置别名plt，这样便于后续调用。导入语句通常是import matplotlib.pyplot as plt。
C:\Users\yuanl&gt;pip install matplotlib import matplotlib print(matplotlib.__version__) D:\pythonLED\python.exe E:/pythonProject/1.py 3.9.0 准备数据 定义数据：根据所需绘制的图表类型，准备对应的数据。例如，对于线图，需要x轴和y轴的数据点；对于散点图，则需要两组数据的坐标点。可以使用列表或NumPy数组来存储这些数据。 绘制图表 选择绘图函数：根据需求选择合适的绘图函数。例如，使用plt.plot()绘制线图，plt.scatter()绘制散点图，plt.bar()绘制柱状图等。绘制简单示例：一个简单而常见的例子是绘制一条直线。首先定义x和y的值，然后使用plt.plot()将它们绘制出来。 import matplotlib.pyplot as plt import numpy as np # 定义数据 x = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e623ed45e1ef70f233615eb7d2a2ec6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/105778f9068ed473850ab6d4776aea33/" rel="bookmark">
			v0.9.6 开源跨平台个人知识管理工具 TidGi-Desktop
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这个信息爆炸的时代，知识管理变得尤为重要。太记(TidGi)，一款基于太微(TiddlyWiki)的知识管理桌面应用，正是为了满足人们对信息整理、知识管理和个人隐私保护的需求而设计的。它不仅能够帮助用户高效地管理和整理信息，还能够自动进行Git云备份，甚至可以部署为个人博客。
软件下载方式在链接底部：V0.9.6 开源跨平台个人知识管理工具 TidGi-Desktop
太记的用户界面简洁直观，易于上手。它支持多种自定义设置，满足个性化需求。无论是学生、教师还是研究人员，都能在太记中找到合适的工具来管理他们的知识库。
核心功能 太记的核心功能之一是其自动备份机制，它使用Git作为备份管理器，确保用户的数据安全。用户可以选择不同的存储服务提供商，例如Github、本地模式或者将来可能支持的Gitlab和码云。此外，太记还提供了本地化的AI功能，以及Git备份同步等高级特
隐私保护：太记强调个人隐私，所有数据都存储在本地，用户完全拥有数据所有权。
自动化备份：通过Git实现自动云备份，确保数据的安全性和可恢复性。
博客部署：支持将笔记部署为个人博客，分享知识和见解。
REST API连接：可与Anki等应用通过REST API连接，实现数据同步和共享。
优势 太记的技术优势在于其对NodeJS wiki的优化支持。使用NodeJS wiki，用户可以拥有独立的tiddler文件，这些文件可以手工修改，也可以通过其他程序进行编辑，如使用装有VSCode-TW5-Syntax插件的VSCode。太记还可以轻松地将wiki文件夹自动备份到Github上，利用Electron技术，太记在TiddlyWiki中集成了fs、git等NodeJS功能，大大扩展了其可扩展性和hackability
结语 太记（TidGi）作为一款个人知识管理工具，以其开源、免费、用户数据自主可控的特点，以及强大的自动备份和同步功能，正在获得越来越多知识工作者的青睐。随着不断的更新和社区的参与，太记有望成为知识管理领域的佼佼者。如果你正在寻找一款能够提升个人生产力和知识管理效率的工具，太记绝对值得一试。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96123719ac32b5a1536b49fcebf3f609/" rel="bookmark">
			【Java】Java序列化和反序列化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人不走空 🌈个人主页：人不走空 💖系列专栏：算法专题 ⏰诗词歌赋：斯是陋室，惟吾德馨 # Java中的序列化和反序列化 在Java中，序列化是将对象的状态写入字节流的机制。它主要用于Hibernate、RMI、JPA、EJB和JMS技术中。
反序列化是序列化的逆操作，即将字节流转换为对象。序列化和反序列化过程是平台无关的，这意味着您可以在一个平台上对对象进行序列化，在另一个平台上进行反序列化。
为了序列化对象，我们调用ObjectOutputStream类的writeObject()方法，而为了反序列化，则调用ObjectInputStream类的readObject()方法。
我们必须实现Serializable接口才能序列化对象。
# Java序列化的优点 它主要用于在网络上传输对象的状态（即称为marshalling）。
java.io.Serializable接口 Serializable是一个标记接口（没有数据成员和方法）。它用于“标记”Java类，以便这些类的对象可以获得某种能力。Cloneable和Remote也是标记接口。
Serializable接口必须由需要持久化其对象的类实现。
String类和所有包装类默认实现了java.io.Serializable接口。
让我们看下面给出的例子：
Student.java
import java.io.Serializable; public class Student implements Serializable{ int id; String name; public Student(int id, String name) { this.id = id; this.name = name; } } 在上面的示例中，Student类实现Serializable接口。现在它的对象可以转换为流。主类的实现显示在下一个代码中。
专属福利 👉点击领取：Java资料合集！650G！
ObjectOutputStream类 ObjectOutputStream类用于将基本数据类型和Java对象写入OutputStream。只有支持java.io.Serializable接口的对象才能写入流中。
构造函数
重要方法
MethodDescription 1) public final void writeObject(Object obj) throws IOException {}
它将指定的对象写入 ObjectOutputStream。
2) public void flush() throws IOException {}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96123719ac32b5a1536b49fcebf3f609/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86869959913d0e0e2df8351268ca113f/" rel="bookmark">
			自动任务、系统工具、文件工具、PDF工具、OCR图文识别、文字处理、电子表格，30&#43;超实用功能，牛的一批！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		千峰办公助手是由吾爱大佬自制的绿色软件，集成了自动任务、系统工具、文件工具、PDF工具、OCR图文识别、文字处理、电子表格七个模块30余项实用功能。大佬开发的目的非常简单，就是解决常见办公痛点，把机械重复的的操作还给机器，实现解放双手的轻松、高效办公。
软件下载方式在链接底部:30+超实用功能，牛的一批！
软件的界面非常直观，一眼就能找到自己想要的功能，去繁就简，没有花里胡哨，留下的只有强大的功能。在快节奏的工作环境中，效率至关重要。千峰办公助手，一款集多种实用功能于一体的绿色软件，可以简化日常工作流程，让机械性任务自动化。
软件的功能介绍 二、自动任务模块 自动任务模块是千峰办公助手的核心功能之一。它允许用户零代码、零脚本地录制键盘和鼠标动作，实现无限重复运行。这一功能特别适合处理那些重复性高、机械化的任务，如数据录入、表格填写等，极大地提升了工作效率。
三、OCR图片文字识别 OCR（Optical Character Recognition，光学字符识别）技术是现代办公中不可或缺的一部分。千峰办公助手的OCR模块支持多种识别方式，包括文件识别、截图识别、剪贴板识别，以及表格的识别。用户可以轻松地将图片中的文字转换为可编辑的文本，甚至支持批量识别和结果导出到Excel，极大地方便了文档处理和数据整理。
四、电子表格处理 电子表格是办公中常用的工具之一。千峰办公助手提供了丰富的电子表格处理功能，如单表拆分、多表合并、数据对比和提取等。这些功能可以帮助用户快速处理复杂的数据，提高数据处理的效率和准确性。
五、文字处理与PDF工具 除了电子表格，千峰办公助手还提供了强大的文字处理功能，如Word文档合并、数据批量写入Excel等。此外，PDF工具模块支持PDF文档的批量处理，包括嵌入图片、提取文字等，满足了用户对PDF文档处理的多样化需求。
六、批量功能 软件支持对文件进行批量重命名，包括按照条形码进行重命名，以及将文件夹内的文件按照指定的数量分批转移到指定文件夹。具备图片批量处理工具，可以压缩图片体积、缩放尺寸、进行批量裁剪和格式转换
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/223/">«</a>
	<span class="pagination__item pagination__item--current">224/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/225/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>