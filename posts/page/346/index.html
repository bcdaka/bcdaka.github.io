<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b50fac7e0bf2890a2edb61a91e8bc38/" rel="bookmark">
			C&#43;&#43;第十九弹---string模拟实现(下)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨个人主页： 熬夜学编程的小林
💗系列专栏： 【C语言详解】 【数据结构详解】【C++详解】
目录
1、修改操作
2、迭代器操作
3、字符串操作 4、非成员函数重载操作
总结
1、修改操作 1、string&amp; operator+= (const char* s);
//尾部插入字符串s
2、string&amp; operator+= (char c);
//尾部插入字符c
3、void push_back (char c);
//尾部插入字符c
4、string&amp; append (const char* s);
//尾部插入(追加)字符串s
5、void insert(size_t pos, char ch);
//在pos位置插入字符c
6、void insert(size_t pos, const char* str);
//在pos位置插入字符串str
7、void erase(size_t pos, size_t len = npos);
//从pos位置删除n个字符
8、void swap(string&amp; s);
//把字符串数据进行交换
void push_back(char c) { // 扩容 容量为0则固定为4 其他则*2 if (_size == _capacity) { reserve(_capacity == 0 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b50fac7e0bf2890a2edb61a91e8bc38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9144f92489f82a7836791190994a3be3/" rel="bookmark">
			SpringBoot项目报错解决：“Error starting ApplicationContext. To display the conditions report re-run ...”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目报错：Error starting ApplicationContext. To display the condition evaluation report re-run your application with 'debug' enabled. 2024-05-23T11:57:46.443+08:00 ERROR 17152 --- [ main] o.s.boot.SpringApplication : Application run failed
这个错误信息表明 Spring Boot 应用程序在启动过程中遇到了问题。ApplicationContext 是 Spring 框架的核心组件，负责管理 bean 的生命周期以及它们之间的依赖关系。当 ApplicationContext 无法成功启动时，通常意味着应用程序中有配置问题或者存在某些组件初始化失败。
错误信息的最后部分提到了 "Application run failed"，这是 Spring Boot 应用启动失败的直接指示。为了进一步诊断问题，可以按照错误信息中的提示，通过启用调试模式来显示条件评估报告。这可以通过在运行应用程序时设置 debug 属性来实现，例如：
java -jar your-application.jar --debug 这将输出更详细的日志信息，有助于识别导致 ApplicationContext 启动失败的具体原因。可能的原因包括但不限于：
配置错误：可能是 application.properties 或 application.yml 文件中的配置项有误。依赖冲突：项目依赖的库之间可能存在版本冲突。Bean 初始化异常：某个 Bean 的初始化过程中抛出了异常。数据源连接问题：如果应用程序依赖于数据库，可能是数据库连接配置不正确或数据库服务不可用。环境问题：应用程序所需的环境变量或系统属性未正确设置。 要解决这个问题，你可以采取以下步骤：
查看日志：检查应用程序的日志文件，特别是堆栈跟踪信息，以确定哪个组件或配置导致了问题。启用调试模式：如上所述，启用调试模式以获取更多详细信息。检查配置：仔细检查所有配置文件，确保没有拼写错误或其他配置问题。更新依赖：如果怀疑是依赖冲突，尝试更新或锁定依赖的版本。单元测试：编写单元测试来隔离和测试可能导致问题的组件。逐步注释代码：如果问题难以定位，尝试逐步注释掉部分代码，以缩小问题范围。 而我运行代码报这个错的原因是：yml配置文件写错导致的
之后该了就可以正常跑了
所以像我这种小白遇到这类问题可以重新写一下yml文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/586841c0aa2e35b45784220a998242da/" rel="bookmark">
			深入MongoDB监控：全面解析命令、实用示例与最佳实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在现代数据库管理中，监控是确保数据库系统高效运行的关键。MongoDB 提供了多种监控工具和命令，帮助管理员实时监控数据库性能、诊断问题并优化系统。本文将详细介绍 MongoDB 的监控机制，包括基本语法、常用命令、示例、应用场景、注意事项和总结。
基本语法 MongoDB 提供了多种方式进行数据库监控，包括命令行工具、MongoDB 自带的监控命令以及第三方监控解决方案。
常用监控命令 db.stats()：获取数据库的统计信息。db.serverStatus()：获取服务器的状态信息。db.currentOp()：显示当前运行的操作。db.collection.stats()：获取集合的统计信息。 常用命令 db.stats() db.stats() 提供当前数据库的统计信息，如数据大小、索引大小等。
db.stats() db.serverStatus() db.serverStatus() 提供 MongoDB 服务器的状态信息，包括内存使用情况、连接数、Opcounters等。
db.serverStatus() db.currentOp() db.currentOp() 显示当前正在运行的操作，可以用于查看当前活跃的查询和写操作。
db.currentOp() db.collection.stats() db.collection.stats() 提供指定集合的统计信息，包括文档数量、集合大小、索引大小等。
db.collection.stats() 示例代码 获取数据库统计信息 use mydatabase printjson(db.stats()) 获取服务器状态信息 printjson(db.serverStatus()) 查看当前运行的操作 printjson(db.currentOp()) 获取集合统计信息 use mydatabase printjson(db.mycollection.stats()) 应用场景详解 1. 性能监控 通过定期监控数据库和集合的统计信息，管理员可以了解数据库的运行状态，及时发现和解决性能问题。
详细说明：性能监控可以帮助管理员发现数据库的性能瓶颈，如慢查询、过多的锁等待等。通过分析 db.serverStatus() 和 db.currentOp() 输出的信息，可以找出影响数据库性能的问题。
示例代码：
// 定期获取数据库和集合的统计信息 setInterval(function() { printjson(db.stats()); printjson(db.serverStatus()); printjson(db.currentOp()); printjson(db.mycollection.stats()); }, 60000); // 每分钟执行一次 2. 资源使用监控 监控服务器的资源使用情况，如内存、CPU、磁盘等，以确保数据库系统稳定运行。
详细说明：通过 db.serverStatus() 可以获取 MongoDB 服务器的资源使用情况，包括内存使用、连接数、缓存使用等信息。定期监控这些信息，可以帮助管理员及时发现和解决资源使用问题，避免系统崩溃。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/586841c0aa2e35b45784220a998242da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7caa53ef2c3fe82d52baed68e920a37/" rel="bookmark">
			数据结构第八弹---队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		队列 1、队列的概念和结构2、队列的实现2.1、头文件包含和结构定义2.2、初始化2.3、销毁2.4、判断是否为空2.5、入队2.6、出队2.7、获取队头数据2.8、获取队尾数据2.9、获取有效数据个数 3、代码汇总总结 1、队列的概念和结构 队列：只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性
表，队列具有先进先出FIFO(First In First Out) 的原则。
入队列：进行插入操作的一端称为队尾
出队列：进行删除操作的一端称为队头。
如何实现队列？
队列是一种一端插入一端删除的数据结构，所以最好的实现方式是头删尾插效率高或者头插尾删效率高。
1.数组实现：尾插和尾删效率较高，但是头插和头删效率低，因此不太适合。
2.单链表实现：头删尾插效率较高，链表头删，链表尾插。
前面单链表提到尾插之前需要找到尾结点，为什么此处又说尾插效率高呢？
因为我们可以在定义结构的时候创建一个记录尾结点的变量，这样我们每次尾插的时候就不需要找尾结点了。
3.双向链表实现：头插头删尾插尾删效率都较高，可以实现队列。
双向链表头插头删尾插尾删效率都较高，为什么此处不直接使用双向链表实现呢？
因为单链表就能很好的实现一个队列，而双向链表相较与单链表会多开辟一个结点，在空间方面会有更多的消耗，所以一般不推荐使用双向链表实现队列。
2、队列的实现 经过上述的分析，我们推荐使用单链表实现队列，那么接下来就由博主来实现一下队列。
首先创建一个工程。(下图为vs 2022)
Queue.h（队列的类型定义、接口函数声明、引用的头文件）
Queue.c（队列接口函数的实现）
test.c （主函数、测试顺序表各个接口功能）
2.1、头文件包含和结构定义 以下是实现队列可能用到的头文件。
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;assert.h&gt; #include&lt;stdbool.h&gt; 以下是博主创建的队列结构，可以根据自己的喜好创建喔。
建议：创建结构时最好能通俗易懂，最好不用拼音创建。
typedef int QDataType; typedef struct QueueNode { struct QueueNode* next; //存放下一个结点指针 QDataType data; //存放数据 }QueueNode; typedef struct Queue { QueueNode* head;//头结点 QueueNode* tail;//尾结点 }Queue; 2.2、初始化 链表的结构是通过动态开辟的空间，可以先不初始化。但是队列的结构是在栈区开辟的，为了防止越界访问，需要先初始化为NULL。
void QueueInit(Queue* pq) { assert(pq);//防止空指针传入 pq-&gt;head = pq-&gt;tail = NULL;//初始化为空指针，防止野指针问题 } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7caa53ef2c3fe82d52baed68e920a37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a03327b6b5b1946fad974dedf412ce68/" rel="bookmark">
			【Python】 统计字符串中字符出现次数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本原理 在Python中，统计一个字符串中某个字符出现的次数是一个常见的任务。这可以通过多种方法实现，包括使用内置函数、循环结构、字典等。在本篇文章中，我们将探讨几种不同的方法来完成这个任务，并提供示例代码。
代码示例 示例1：使用循环和计数器 这是最基础的方法，通过遍历字符串中的每个字符，并使用一个计数器来记录特定字符的出现次数。
def count_char(s, char): count = 0 for c in s: if c == char: count += 1 return count # 示例运行 string = "hello world" character = "l" print(f"The character '{character}' appears {count_char(string, character)} times in the string.") 示例2：使用字典 这种方法使用字典来统计每个字符的出现次数，然后返回特定字符的计数。
def count_char_dict(s, char): char_dict = {} for c in s: if c in char_dict: char_dict[c] += 1 else: char_dict[c] = 1 return char_dict.get(char, 0) # 示例运行 string = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a03327b6b5b1946fad974dedf412ce68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2ccfa1adbd00b860691ac4ada9bb50e/" rel="bookmark">
			【Python】 如何向现有的DataFrame添加新列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本原理 在Python中，使用Pandas库可以非常方便地处理数据。DataFrame是Pandas库中用于存储表格数据的主要数据结构，类似于Excel中的表格。有时候，我们可能需要向现有的DataFrame中添加新的列。这可以通过多种方式实现，包括使用现有列的值、创建全为零或全为一的列、或者直接添加一个由特定值组成的列。
代码示例 示例1：使用现有列的值创建新列 假设我们有一个DataFrame，现在我们想基于现有的列来创建一个新列。例如，我们有一个名为df的DataFrame，其中包含A和B两列，我们想创建一个新的列C，其值为A列和B列的和。
import pandas as pd # 创建一个示例DataFrame df = pd.DataFrame({ 'A': [1, 2, 3], 'B': [4, 5, 6] }) # 创建新列C，值为A列和B列的和 df['C'] = df['A'] + df['B'] print(df) 示例2：添加一个全为零的列 如果我们想添加一个新列，其所有值都初始化为零，可以这样做：
# 添加一个全为零的新列D df['D'] = 0 print(df) 示例3：添加一个全为特定值的列 有时候，我们可能需要添加一个新列，其所有值都是一个特定的值，例如一个常量或者一个特定的字符串。
# 添加一个全为特定值的新列E df['E'] = 'constant_value' print(df) 示例4：使用apply函数添加新列 我们也可以使用apply函数来对DataFrame的每一行应用一个函数，从而创建一个新列。
# 使用apply函数添加新列F，该列是A列和B列的乘积 df['F'] = df.apply(lambda row: row['A'] * row['B'], axis=1) print(df) 注意事项 数据类型一致性：在添加新列时，确保新列的数据类型与DataFrame中其他列的数据类型兼容。索引对齐：当基于现有列创建新列时，确保所有行的索引对齐，以避免产生NaN值。内存使用：添加大量列或大型数据集时，要注意内存的使用情况。性能考虑：对于大型DataFrame，添加新列可能需要一些时间，特别是当使用复杂的函数或操作时。 结论 向DataFrame添加新列是数据处理中常见的操作。Pandas提供了多种灵活的方法来实现这一功能。理解这些方法并根据具体需求选择合适的方式，可以大大提高数据处理的效率和灵活性。通过实践和探索，我们可以更好地掌握Pandas库的强大功能，从而更加高效地处理和分析数据。
&gt;
&gt; 【痕迹】QQ+微信朋友圈和聊天记录分析工具1.0.4 （1）纯Python语言实现，使用Flask后端，本地分析，不上传个人数据。
&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2ccfa1adbd00b860691ac4ada9bb50e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c10fd792cdeaa173d56fd20c5ebcf461/" rel="bookmark">
			使用 Stable Diffusion 实现一键换衣保姆级教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：安装 Segment Anything
启动 Stable Diffusion (以下简称：SD)
打开 SD WebUI 面板
如下图切换到：扩展Tab页 -&gt;可下载-&gt;取消本地化、已安装选项，点击：“加载扩展列表” 按钮以刷新
搜索框输入：sd-webui-segment-anything，点击后面的安装按钮
注意：由于我已安装，所以搜索出的状态是已安装，对于已安装的，请直接跳转到第二步后继续
安装完成后，切换到：扩展Tab页 -&gt;已安装，查看是否有 sd-webui-segment-anything
5.1.如有，则点击 应用更改并退出 按钮，等待重启完成
5.2.如没有，则 重复第3/4步骤
SD 重启完成后，切换到：图生图Tab页，下拉到页面最底端，查看是否有 Segment Anything
6.1、如果有 Segment Anything，则说明 Segment Anything 已安装成功
6.2、如果没有 Segment Anything，则说明上述步骤中有地方出错了，请查看 SD 窗口日志，查找具体出错原因或重新执行上述步骤
第二步：下载 Segment Anything model
至此，才成功一半，因为还没有下载 Segment Anything 所需模型，没有模型是无法进行图像分离的
注意：由于我已下载模型，因此此处有模型（对于已有模型的，请直接跳转到第三步后继续），而未下载模型时，此处为空
Segment Anything 模型下载
2.1.访问 sd-webui-segment-anything
**2.2.**拉到中间位置或直接使用 Ctrl+f搜索 sam_hq_vit，其中1/2两者下载其一即可，当然，占用空间越大效果越好，如果空间足够建议下载1（2.57G）
下载完成后，将下载好的.pth文件拷贝到 extensions\sd-webui-segment-anything\models\sam 目录下
拷贝完成后，点击如下图所示的刷新按钮，即可看到刚下载的模型已出现在模型列表中
第三步：上传图片，制作蒙版
上传图片（点击选择需要上传的图片或直接拖拽图片）
上传完成后，点击鼠标左键选择需要保留的位置（黑点表示），点击鼠标右键选择不需要保留的位置（红点表示），之后再点击 预览分离结果
等待一会后会出现预览效果，查看是否有符合预期的结果
3.1.有符合预期的结果，请直接跳到第四步后继续
3.2.没有符合预期的结果，重新执行2步骤，即重新点选位置，直到有符合预期的结果为止
第四步：确认预览并发送到重绘
选择最满意的一张（0代表第一列，1代表第二列，2代表第三列）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c10fd792cdeaa173d56fd20c5ebcf461/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74a0b7dd55deaa056bf8e6b92e8db99c/" rel="bookmark">
			C# 实现腾讯云 IM 常用 REST API 之消息管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
关于腾讯 IM REST API 开发前准备
范例运行环境
常用消息管理API
发送单聊消息
批量发送单聊消息
删除指定用户发送的消息
小结
关于腾讯 IM REST API REST API 是腾讯即时通信 IM 提供给服务端的一组 HTTP 后台管理接口，如消息管理、群组管理、用户管理、会话管理等等。REST API 接口较为原始，管理能力强大。另外，为了安全性，REST API 仅提供 HTTPS 接口，本文将主要介绍常用的消息管理API。
开发前准备 (1）开发前需要申请 SDK 开发者 ID 及密钥，如何获取请参照如下链接：
腾讯IM即时通信控制台
(2）调用 REST API 之前，需要生成 UserSig ，UserSig 是用户登录即时通信 IM 的密码，其本质是对 UserID 等信息加密后得到的密文，如何生成 UserSig 请参照我的文章《C# 生成腾讯云 IM 之 TLSSigAPIv2 UserSig》，通过 TLSSigAPIv2 类进行创建，请参考如下代码：
string SDKAppId="申请的SDKAppID"; string SDKAppIdSecret="申请的SDKAppIdSecret"; string AppAdminId="IM平台超级管理员UserID"; TLSSigAPIv2 sig = new TLSSigAPIv2(int.Parse(SDKAppId),SDKAppIdSecret); string _sig = sig.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74a0b7dd55deaa056bf8e6b92e8db99c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27c1b6c392ec9ae810f918c63e0b3327/" rel="bookmark">
			C# 实现腾讯云 IM 常用 REST API 之群组管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
关于腾讯 IM REST API 开发前准备
范例运行环境
常用群组管理API
创建群组
增加群成员
修改群基础资料
修改群成员资料
获取被禁言群成员列表
解散群组
小结
关于腾讯 IM REST API REST API 是腾讯即时通信 IM 提供给服务端的一组 HTTP 后台管理接口，如消息管理、群组管理、用户管理、会话管理等等。REST API 接口较为原始，管理能力强大。另外，为了安全性，REST API 仅提供 HTTPS 接口，本文将主要介绍常用的群组管理API。
开发前准备 (1）开发前需要申请 SDK 开发者 ID 及密钥，如何获取请参照如下链接：
腾讯IM即时通信控制台
(2）调用 REST API 之前，需要生成 UserSig ，UserSig 是用户登录即时通信 IM 的密码，其本质是对 UserID 等信息加密后得到的密文，如何生成 UserSig 请参照我的文章《C# 生成腾讯云 IM 之 TLSSigAPIv2 UserSig》，通过 TLSSigAPIv2 类进行创建，请参考如下代码：
string SDKAppId="申请的SDKAppID"; string SDKAppIdSecret="申请的SDKAppIdSecret"; string AppAdminId="IM平台超级管理员UserID"; TLSSigAPIv2 sig = new TLSSigAPIv2(int.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27c1b6c392ec9ae810f918c63e0b3327/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7470dd9ada4bd53b405a7ddcf46f75e/" rel="bookmark">
			【vs2022】安装copilot和reshaper
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 直接安装新版vs 17.10 自带集成的copilot支持安装resharper 可以跳过市场里的reshper安装好后依然可以直接使用vs。 resharper 2024.1.2 市场里还是i老版本：
copilot 不兼容,这个是之前市场安装的版本 官方建议用vs intall 安装 安裝 GitHub Copilot GitHub.Copilot.Vsix.1.181.0.1.vsix 不兼容 vs install 说安装了啊 先卸载copilot吧 17.10 里copilot 是默认的 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4240fa518d732ab923dc81d8427e7be/" rel="bookmark">
			java.lang.NumberFormatException-For input string-“”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java.lang.NumberFormatException: For input string: ""这个异常通常发生在尝试将一个空字符串（“”）转换为数值类型（如int, double等）时。Java在遇到不能直接转换为数字的字符串时会抛出这个异常，而空字符串显然不是一个有效的数值表示形式。
解决方案： 检查输入源：首先，确定为什么会有空字符串作为转换的输入。这可能是用户直接输入、从文件读取或从数据库查询结果中得到的。确保数据来源有效且非空。
增加空值检查：在尝试转换之前，添加条件判断来检查字符串是否为空或仅包含空白字符。例如：
String input = ...; // 输入的字符串 if (input != null &amp;&amp; !input.trim().isEmpty()) { try { int number = Integer.parseInt(input); // 成功转换后的操作... } catch (NumberFormatException e) { // 处理非数字字符串的情况 } } else { // 处理空字符串或只含空白字符的情况 } 提供默认值：在确认输入为空或无效时，你可以选择提供一个默认值而不是直接抛出异常。
int number; try { number = Integer.parseInt(input != null ? input.trim() : "0"); // 使用"0"作为默认值 } catch (NumberFormatException e) { number = 0; // 或者在这里再次设置默认值 } 使用Optional类：在Java 8及以上版本中，可以使用Optional来优雅地处理可能为null或空的情况。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4240fa518d732ab923dc81d8427e7be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4f6fd0805d73aee6643686c29ba0811/" rel="bookmark">
			Windows环境安装配置nodejs详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows下安装及配置Node.js环境 Windows下安装Node.js一、Node.js是什么？二、npm是什么三、环境搭建四、环境配置五、测试六、配置淘宝镜像 Windows下安装Node.js 一、Node.js是什么？ Node.js是一个基于Chrome V8引擎的[JavaScript运行环境]。 Node.js使用了一个事件驱动、非阻塞式I/O 的模型。
Node.js是一个让JavaScript运行在服务端的开发平台，它让JavaScript成为与PHP、Python、Perl、Ruby等服务端语言平起平坐的脚本语言 。
总的来说就是：nodeJS是JavaScript脚本语言的运行环境。
二、npm是什么 npm其实是Node.js的包管理工具（package manager），相当于后台的maven。
为啥我们需要一个包管理工具呢？因为我们在Node.js上开发时，会用到很多别人写的JavaScript代码。 如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生：大家都把自己开发的模块打包后放到npm官网上，如果要使用， 直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。 更重要的是，如果我们要使用模块A，而模块A又依赖于模块B，模块B又依赖于模块X和模块Y， npm可以根据依赖关系，把所有依赖的包都下载下来并管理起来。否则，靠我们自己手动管理，肯定既麻烦又容易出错。
三、环境搭建 下载安装包
官网地址：https://nodejs.org/en/download/package-manager
如果不想使用命令行安装，也可选择下载预构建的安装文件，如下图，选择对应你系统的Node.js版本，这里我选择的是Windows系统、64位
Tips：如果想下载指定版本，点击下图所示位置，即可选择自己想要的版本下载。也可直接打开此链接https://nodejs.org/dist/
安装
2.1 双击安装包
2.2 点击下一步
2.3 选中I accept the terms in the License Agreement，点击下一步
2.4 选择安装路径，路径不要包含中文，点击下一步
2.5 点击下一步
2.6 点击下一步
2.7 点击install安装
2.8 如果系统有提示“你要允许此应用对你的设备进行更改吗？”，选择是。
2.9 如下图效果就是安装成功
2.10 测试是否安装成功，按下【win+R】键，输入cmd，打开cmd命令窗口，分别输入以下两行命令，成功显示版本说明安装成功 显示node.js版本：node -v 显示npm版本： npm -v 四、环境配置 找到安装的目录，在安装目录下新建两个文件夹【node_global】和【node_cache】创建完毕后，使用管理员身份打开cmd命令窗口，输入下面两行运行；运行后无报错就是成功 npm config set prefix "你的安装路径\node_global" npm config set cache "你的安装路径\node_cache" 注：【你的安装路径】这五个字要替换
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4f6fd0805d73aee6643686c29ba0811/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/057bb6da6d7ff0f10163cbe75eda4ba5/" rel="bookmark">
			Stable Diffusion最好用的高清修复插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虽说大部分N家显卡都能跑得起来Stable Diffusion，但想要画尺寸更大、更清晰的图片，需要更大的显存。
以12G显存的3060为例，2048大概是单张尺寸的上限，如果画更大的尺寸，大概率会爆显存。
大多数情况下，都是画512小尺寸的图，生成效果不错的，再进行后续处理。
各AI绘画爱好者最常用的功能，是高分辨率修复(Hires. fix)，这个功能选中后，会弹出多个算法的选择，哪个更好呢？
目前最好用的放大算法，是 4x-UltraSharp ，没有之一。
先简单介绍下几个常见算法的原理和区别，再做个实图对比，最后放下载链接（4x-UltraSharp不在webui的默认配置里，需要手工下载安装）。
一、常见放大算法
1、Latent：是一种基于 VAE 模型的图像增强算法,通过将原始图像编码成潜在向量,并对其进行随机采样和重构,从而增强图像的质量、对比度和清晰度。一般情况下，这个算法就能得到不错的效果，和4x-UltraSharp、R-ESRGAN等相比，显存消耗比较小，但效果不是最优。
2、Lanczos：将对称矩阵通过正交相似变换变成对称三对角矩阵的算法（鸡肋，通常不用）。
3、ESRGAN：Enhanced Super-Resolution Generative Adversarial Networks （增强超分生成对抗网络）
是对SRGAN关键部分网络结构、对抗损失、感知损失的增强。从这里开始就不是单纯的图像算法，进入人工智能的领域了。实测确实增加了很多看上去很真实的纹理，但是有时又会把一张图片弄得全是锯齿或怪异的纹理。可能对待处理的图片类型有要求。
4、4x-UltraSharp：基于ESRGAN做了优化模型，更适合常见的图片格式。真人模型最佳选择。
5、ESRGAN 4x（Real ESRGAN）：完全使用纯合成数据去尽量贴近真实数据，然后去对现实生活中数据进行超分的一个方法。这个算法来自于腾讯贡献，点个赞。
6、R-ESRGAN 4x+：基于Real ESRGAN的优化模型，针对照片效果不错。
7、R-ESRGAN 4x+ Anime6B：基于Real ESRGAN的优化模型，二次元最佳，如果你的模型是动漫类的，该选项是最佳选择。
8、R-ESRGAN General 4xV3：基于Real ESRGAN的优化模型，体积小，计算快，效果差。
9、SwinIR_4x：使用Swin Transformer思想，采用一个长距离连接,将低频信息直接传输给重建模块,可以帮助深度特征提取模块专注于高频信息,稳定训练。
10、LDSR：Latent Diffusion Super Resolution（潜在扩散超分辨率模型）
Stable Diffusion最基础的算法模型，但速度比较慢。
因为webui版本的不同，可能内置了其他的放大算法，但基本都不如上述这些好用（尤其推荐4、7两个算法）。
二、实际对比
先生成一张原图。
模型：xxmix9realistic_v30.civitai
提示词：
best quality, (mature:1.3),perfect face, beautiful face,western, sharp focus, solo,beautiful woman,sexy,shiny skin,Navy blouse, beige shorts, soft light,cinematic lighting, sunny, dusk, outdoor,depth of field,shidudou,red_dress, 负面提示词：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/057bb6da6d7ff0f10163cbe75eda4ba5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c0727b072c256f8c203103535374007/" rel="bookmark">
			【JAVA】Java如何连接消费Kafka
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、函数解释二、代码实现三、总结 前言 在现代数据驱动的世界中，实时数据流处理已经成为许多应用的核心部分。Apache Kafka是一个分布式流处理平台，被广泛用于实时数据流处理、日志聚合和实时分析。在这篇博客中，我们将探讨如何使用Java来连接并消费Kafka的消息。
一、函数解释 在Java中，我们主要通过KafkaConsumer类来消费Kafka的消息。以下是一些主要的函数和配置：
KafkaConsumer： 这是Kafka消费者的主要类，我们使用它来创建消费者实例。
subscribe： 这个函数用于订阅一个或多个主题。
poll： 这个函数用于轮询新的消息。
Properties： 这是Java的一个类，我们用它来设置连接Kafka的配置，比如服务器地址、消费者组ID、反序列化类等。
二、代码实现 以下是一个基本的Java消费Kafka消息的例子：
import org.apache.kafka.clients.consumer.ConsumerRecord; import org.apache.kafka.clients.consumer.ConsumerRecords; import org.apache.kafka.clients.consumer.KafkaConsumer; import java.util.Arrays; import java.util.Properties; public class MyKafkaConsumer { public static void main(String[] args) { Properties props = new Properties(); props.put("bootstrap.servers", "localhost:9092"); props.put("group.id", "test"); props.put("enable.auto.commit", "true"); props.put("auto.commit.interval.ms", "1000"); props.put("key.deserializer", "org.apache.kafka.common.serialization.StringDeserializer"); props.put("value.deserializer", "org.apache.kafka.common.serialization.StringDeserializer"); KafkaConsumer&lt;String, String&gt; consumer = new KafkaConsumer&lt;&gt;(props); consumer.subscribe(Arrays.asList("my-topic")); while (true) { ConsumerRecords&lt;String, String&gt; records = consumer.poll(100); for (ConsumerRecord&lt;String, String&gt; record : records) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c0727b072c256f8c203103535374007/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a71c410714174ba3d67bbb65006dacce/" rel="bookmark">
			二百三十七、Hive——DWS层生成每个清洗字段的异常情况记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、目的 在Hive中对每种业务数据的清洗字段的异常数据进行记录
例如这张图，上面是原始数据，下面是每台雷达每天的异常字段的记录
二、实施步骤 （一）建表 create table if not exists dws_data_clean_record_queue( data_type int comment '1:转向比,2:统计,3:评价,4:区域,5:过车,6:静态排队,7:动态排队,8:轨迹,9:事件数据,10:事件资源', device_no string comment '设备编号', create_time timestamp comment '创建时间', field_name string comment '字段名', field_value string comment '字段值' ) comment '静态排队数据清洗记录表' partitioned by (day string) stored as orc ; （二）SQL 1、运行比较简单，但代码比较难 with t3 as( select device_no, case when device_no is null then CONCAT('device_no:','null') END AS device_no_value, create_time, case when lane_no &lt; 0 or lane_no &gt;255 then CONCAT('lane_no:', CAST(lane_no AS STRING)) END AS lane_no_value, case when queue_len &lt; 0 or queue_len &gt; 500 then CONCAT('queue_len:', CAST(queue_len AS STRING)) END AS queue_len_value, case when queue_head &lt; 0 or queue_head &gt; 500 then CONCAT('queue_head:', CAST(queue_head AS STRING)) END AS queue_head_value, case when queue_tail &lt; 0 or queue_tail &gt; 500 then CONCAT('queue_tail:', CAST(queue_tail AS STRING)) END AS queue_tail_value, case when queue_count &lt; 0 or queue_count &gt; 100 then CONCAT('queue_count:', CAST(queue_count AS STRING)) END AS queue_count_value, concat_ws(',', case when device_no is null then CONCAT('device_no:','null') end , case when lane_no &lt; 0 or lane_no &gt;255 then CONCAT('lane_no:', CAST(lane_no AS STRING)) END , case when queue_len &lt; 0 or queue_len &gt; 500 then CONCAT('queue_len:', CAST(queue_len AS STRING)) END, case when queue_head &lt; 0 or queue_head &gt; 500 then CONCAT('queue_head:', CAST(queue_head AS STRING)) END, case when queue_tail &lt; 0 or queue_tail &gt; 500 then CONCAT('queue_tail:', CAST(queue_tail AS STRING)) END, case when queue_count &lt; 0 or queue_count &gt; 100 then CONCAT('queue_count:', CAST(queue_count AS STRING)) END ) AS kv_pairs , day from (select t1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a71c410714174ba3d67bbb65006dacce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19632903a1b955da20909a9ab46bfb51/" rel="bookmark">
			10款国内可用的AI工具分享，每一款都能让你工作效率翻倍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你觉得国内最好用的AI软件有哪些？
小白如何一分钱不花快速入门AI，有很多人反映我提到的部分软件需要魔法上网才能使用，那么现在我就来说一下国内能使用的且是我心目中认为最好用的10款AI软件，排名根据我个人的喜好程度、使用频率和效率提升程度得出。
第10名：佐糖|picwish.cn 佐糖是一款简单易用的AI在线图片处理工具，包括一键抠图、一键移除多余物体，模糊照片变清晰、黑白照片上色、改变背景、无损放大等都是使用频率非常高的功能，且用户体验非常方便，能够极大的提高你处理图片的效率。
第9名：通义听悟 通义听悟是阿里云推出的一款智能会议记录工具，它能够将会议上的发言实时转录成文字，并支持多种语言翻译，或者将上传的语音文件转成文字版会议记录，并区分发言人，语言从此以后再也不会是你们的沟通障碍，记录也再也不会成为你的工作负担。
第8名:：Gamma Gamma是一个专注于PPT制作的AI工具，只需要一句话就能生成一整个PPT，或者将你编辑好的大纲或文字内容一键转成PPT，又或者将你已经做完的丑丑的PPT一键变漂亮，以后你再也不需要熬夜写PPT了。
第7名，Magic Todo| goblin.tools Magic Todo| goblin.tools是一款智能任务分解工具，当你想做某件事情，或者领导给你布置了某项工作，你就可以拿起这款工具点一下，它能将一个复杂的任务自动分解成若干个可操作的小步骤来助你达成目标。如果你不知道分解出来的某一步具体该怎么做，那就再点一下，它会继续为你生成更细的任务即划。从此，你不需要再思考某项任务该如何完成，只需要按顺序执行它为你分解出来的动作即可。
第6名：度加 度加是百度推出的AI视频剪辑工具，Sora还没有开放，Pika和Runway只能生成几秒钟的视频，虽然他们的质量和自由度更高，但需要频繁的修改提示词，并把无数个几秒钟的短片拼接成一个完整的视频，这依然是一个工作量很大的事。而杜家则走了另外一条路线，它能一键为你生成视频文案，并自动为你匹配版权视频素材，还能自动为你添加字幕并配音，如果需要，甚至还能给你配一个数字人来口播。如果你对视频质量要求不那么高，那么用度加从一个创意开始到拥有一条可发布的视频只需要几分钟，你的创作效率会大幅提高。
第5名：通义万象 通义万象是阿里云旗下的文生图工具，只需要一句话就能生成高质量的图片，虽然自由度未必有Midjourney那么高，但一些风格的成片质量一点也不比Midjourney或Dalle3逊色。它的优点是免费、快速、国内可用，且提示词用中文说就可以了，绘画风格还可自由选择，这些都进一步降低了文生图的门槛。换句话说，现在你只要会说话、会打字，你就是一个艺术家。
第4名：秘塔AI搜索|metaso.cn
秘塔AI搜索是一款新型的搜索工具，区别于百度、谷歌这种需要自己在搜索结果中寻找答案的传统搜索引擎，它能自动屏蔽广告信息，并对所有的搜索结果进行分析与整理，然后再自动合并成一个答案，并重新组织语言为你讲述。从此，从开始搜索到拿到结果，你只需要一次点击，所有中间步骤全部消失。
第3名：扣子 这个是字节跳动推出的一款AIbot开发平台，你不需要动编程，也可以在这个平台上搭建出许多个只服务于你自己或开放给别人使用的机器人，例如写标题机器人、视频总结机器人、占卜占星机器人、SWOT分析机器人等等。平台上也有很多别人开发好的bot，随时等候你的差遣。它相当于是国内版的GPTS，虽然使用的模型没有它的海外版Coze那么强，有时会感觉笨笨的，但胜在国内可用，且和国内平台的适配性更好。例如。可以将调教好的机器人发布到微信公众号，让你的公众号瞬间拥有相关的AI能力，未来甚至还能把你训练好的机器人打包成产品，对外付费使用。
第2名：NotionAI| notion.so Notion AI内置与Notion中，它的内核适ChatGpt, 所以能像使用GPT一样来使用它。例如写一个提纲，让他来帮你写完整篇文章，框选一段文字，让他来帮你改变语气以及提升文案水平，或帮你翻译成其他任何语言，打开一篇文章，让他为你总结全文，甚至对几十上百篇文章开启一键总结。你还可以自定义Prompt，让他按一定的规则为你取标题，将文案改成小红书风格，提炼出20个相关的标签等等。这些对他来说都是轻而易举的是相比于ChatGpt, 他不需要来回切换软件，不需要魔法上网，直接在软件内就可以使用，相当的方便，这还不是最牛的，最牛的是他能将你所有的笔记作为知识库。当你询问他某个问题时，他能根据已有的笔记内容来进行回答。换句话说，你拥有的知识库越大，质量越高，记录的笔记越多，Notion AI的思考能力就越强，你保存下来的文章再也不会在收藏夹里吃灰了。每一篇记录在案的内容都会成为他能力的一部分，它能真正意义上成为你的第二大脑。
第一名：KimiChat KimiChat作为全球首款支持20万字输入的大语言模型，属于类ChatGpt产品。不过别看它看上去和ChatGPT很类似，但他能处理的文本更长，而“长”便意味着能做许多ChatGpt或Notion AI做不到的事，例如直接把Word PDF Excel PPT等文件，甚至一整本电子书丢给他，让他帮你总结。20万字的长度几乎很少有文件能难倒它。如果有遇到不理解、不清楚的地方，直接问它就行。有了它，我几乎再也没自己读过文件了，只有想确认某些细节时，才会打开原文件来核对。因为能处理的文本更长了，所以他有更强的上下文记忆能力，我试着用它来创作小说，在推演了几十遍剧情之后，他依然记得某个最初的设定，让我震惊不已，每次对话他都拥有惊人的一致性。另外，我自己使用下来，感觉他对文案的梳理总结能力、预测、思考、创新能力以及对中文的理解与驾驭能力比Chat GPT更强，更适合国内用户使用，且现在还是免费的，它已经成为我每天打开频率最高的AI工具了。
OK, 以上就是我心目中国内能用的10大AI软件，你用过其中的哪款软件呢？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0b1b5e3d54cdefe303d4e9b15f3b76b/" rel="bookmark">
			FastJSON2 ＞ FastJSON 好在何处
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FastJSON 是一种广泛使用的 JSON 解析库，其高性能和简单易用的特点受到开发者的喜爱。然而，随着应用场景的复杂化和安全要求的提高，FastJSON 逐渐暴露出一些问题。为了解决这些问题并进一步提升性能和安全性，阿里巴巴推出了 FastJSON2。本文将详细探讨 FastJSON2 相比 FastJSON 的主要优势和改进。
引入依赖 &lt;dependency&gt; &lt;groupId&gt;com.alibaba.fastjson2&lt;/groupId&gt; &lt;artifactId&gt;fastjson2&lt;/artifactId&gt; &lt;version&gt;2.0.50&lt;/version&gt; &lt;/dependency&gt; 优势在何处？增强了哪些方面？ 1.性能提升 FastJSON2 在性能上进行了多方面的优化，使其在序列化和反序列化操作中表现更加出色。
2.序列化性能 FastJSON2 通过优化序列化算法和数据结构，提高了序列化的效率。例如，它减少了不必要的对象创建和复制操作，从而降低了 CPU 和内存的开销。
// FastJSON2 序列化示例 String jsonString = JSON.toJSONString(object); 3.反序列化性能 反序列化性能的提升主要体现在解析速度和内存使用效率上。FastJSON2 对解析器进行了重构，使其能够更快速地处理大规模 JSON 数据。
// FastJSON2 反序列化示例 MyClass object = JSON.parseObject(jsonString, MyClass.class); 4.安全性增强 FastJSON2 在安全性方面做了显著改进，特别是针对之前版本中暴露的一些安全漏洞进行了修复。
5.黑名单机制 为了防止反序列化漏洞，FastJSON2 引入了更严格的黑名单机制，默认禁止了某些危险类型的反序列化操作。
6.类型检测 FastJSON2 增强了类型检测机制，可以更好地防止恶意数据的注入，确保数据解析的安全性。
7.功能改进 FastJSON2引入了一些新的功能特性，使其在处理JSON数据时更加灵活和强大。
8.JSONPath 支持 FastJSON2对JSONPath的支持更加全面和高效，允许开发者使用JSONPath 表达式方便地访问和操作JSON数据。
// JSONPath 示例 Object value = JSONPath.eval(jsonObject, "$.store.book[0].title"); 9.日期和时间处理 FastJSON2改进了对日期和时间的处理，提供了更多的配置选项和更好的性能，支持多种日期格式和时区处理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0b1b5e3d54cdefe303d4e9b15f3b76b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/815cf51382ce60679d7201b9e5acdae0/" rel="bookmark">
			Docker构造Mysql容器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此文章适用于服务器安装好Docker和Windows安装Mysql基础下进行。
如果你的Linux没有装好Docker，请查阅：Linux安装Docker及基本使用。
如果本地Windows没有安装Mysql的话，晚上搜个教程看一下。
目录 拉Mysql镜像：
查看镜像：
创建mysql数据卷目录(记得查看)：
构建Mysql容器：
查看container运行状态：
这里记得打开服务器的3306端口：
本地DOS连接数据库：
进入安装mysql的bin目录下：
在上面这个路径输入cmd：
它就会弹出一个DOS终端：
检查mysql是否安装好：
配Win11的Mysql环境变量：
复制MySQL的bin目录路径：
搜索并打开环境变量配置：
进入环境变量，双击空白的地方，粘贴刚刚复制的路径后：
三连确认：
检查：
可视化软件连接数据库：
Navicat测试连接：
连接成功：
拉Mysql镜像： docker pull mysql:latest 查看镜像： docker images 创建mysql数据卷目录(记得查看)： mkdir -p /data/mysql 构建Mysql容器： docker run -d \ --name mysql \ -v /data/mysql:/var/lib/mysql \ -e MYSQL_ROOT_PASSWORD=123456 \ -p 3306:3306 \ mysql:latest 查看container运行状态： 这里记得打开服务器的3306端口： 本地DOS连接数据库： mysql -h 124.222.88.57 -u root -p 如果显示：'mysql' 不是内部或外部命令，也不是可运行的程序或批处理文件。
这个问题是由于本地没有安装mysql或者环境变量没有配置好所导致的。
进入安装mysql的bin目录下： 在上面这个路径输入cmd： 它就会弹出一个DOS终端： 检查mysql是否安装好： mysql --version 如果出了版本号，就证明mysql已经安装完成，只是环境变量未设置好全局。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/815cf51382ce60679d7201b9e5acdae0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6c845b0cccfa395710fbc126f39dc8a/" rel="bookmark">
			探索高效流处理：Streamiz.Kafka.NET —— .NET版Apache Kafka流处理库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		探索高效流处理：Streamiz.Kafka.NET —— .NET版Apache Kafka流处理库 项目简介 Streamiz.Kafka.NET是一个专为.NET开发者设计的流处理库，它提供了与Apache Kafka的无缝集成，帮助您构建可扩展且实时的数据流应用。这个开源项目的目标是提供一个易于使用、功能强大的框架，让.NET开发人员能够充分利用Kafka的强大功能。
技术分析 Streamiz.Kafka.NET基于Java版本的Kafka Streams，并对其进行.NET平台的移植和优化。库内包含了状态处理器、RocksDB存储支持、窗口操作（如跳跃窗口、翻滚窗口）以及多类型数据序列化选项（如Avro、Protobuf、JSON）。此外，它还支持KStream-KStream、KStream-KTable、KTable-KTable等各类JOIN操作，并提供了Transformer和Processor API，便于自定义复杂的业务逻辑。
应用场景 Streamiz.Kafka.NET适用于各种实时数据处理场景，包括但不限于：
实时数据分析：实时监控和分析系统日志、用户行为数据。数据整合：将来自多个源的数据合并到单一视图中。实时ETL（提取、转换、加载）：从多种来源捕获数据，进行清洗和转换，然后加载到其他系统或数据库中。消息路由：基于内容或元数据，智能路由消息到不同的目的地。跨服务通信：在微服务架构中实现可靠的消息传递。 项目特点 跨平台兼容性: 支持.NET Framework和.NET Core，可以在Windows、Linux和macOS上运行。丰富的API: 提供与Kafka Streams相似的接口，使得Java开发者可以轻松迁移至.NET环境。内置序列化器: 包括Avro、Protobuf和JSON的支持，简化了数据交换的复杂性。集成Schema Registry: 对于Avro和其他序列化的支持，通过Confluent Schema Registry进行版本管理和反序列化。强大监控: 通过Prometheus和OpenTelemetry提供度量标准，方便对应用程序性能进行监控和调试。高质量保证: 代码覆盖率高，可靠性、安全性和可维护性强，严格遵循编码最佳实践。 为了更好地体验Streamiz.Kafka.NET，您可以直接利用Gitpod预配置的开发环境进行尝试。只需点击上方的“Open in Gitpod”按钮，就可以快速启动一个开发环境并开始编写流处理程序。
要了解更多详细信息，访问项目文档：https://lgouellec.github.io/kafka-streams-dotnet/
为了参与社区讨论和获取最新动态，请加入我们的Discord聊天室：https://discord.gg/J7Jtxum
安装Streamiz.Kafka.NET库，只需在您的项目中执行以下命令：
dotnet add package Streamiz.Kafka.Net 立即行动，探索Streamiz.Kafka.NET带给.NET世界的数据流处理新可能！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10e6e5b0dd65fa382e38748a9047b389/" rel="bookmark">
			RustRover非商业用途可免费使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RustRover是JetBrains推出的一款全新的专门针对Rust语言的集成开发环境(IDE)。它于2024年5月正式发布,加入了JetBrains现有的IDE产品系列。
新的许可模式
RustRover采用了一种新的双重许可模式:
免费的个人非商业许可
付费的商业许可
如果你是个人用户,只将RustRover用于非商业目的,那么可以免费使用。但如果要将其用于商业用途,则需要购买商业许可,与JetBrains其他产品类似。
为了降低成本,JetBrains删减了一些较少使用的功能。不过,这些功能仍可通过付费或免费插件的形式添加,以满足不同需求。
这是JetBrains首次采用这种许可模式,旨在让用户可以免费使用IDE进行非商业开发。目前这种模式基于用户诚信声明,JetBrains可能会根据实际情况进行调整。
值得注意的是,使用非商业许可时,用户无法选择不收集匿名使用统计数据,这与JetBrains的早期访问计划和隐私政策保持一致。
相比其他通用IDE具有以下主要优势:
专注于Rust生态系统
完全专注于Rust语言及其生态系统,提供针对性的优化和支持。
与Rust工具链(Cargo、Rustup等)深度集成,无缝支持Rust工作流。
为Rust Web应用开发提供专门的支持,如HTTP客户端、数据库访问等。
功能丰富且性能优异
提供智能代码补全、重构、快速修复等强大的代码辅助功能。
内置调试器、测试运行器、性能分析等工具,提高开发效率。
基于JetBrains优秀的IDE架构,确保高性能和流畅的用户体验。
与JetBrains生态系统融合
可作为IntelliJ IDEA Ultimate和CLion的插件使用。与JetBrains其他IDE产品保持一致的用户界面和操作体验。支持Git、GitHub等版本控制系统集成。 用户体验：
1、他们试图在发布前删除一些功能，以便将其免费。例如，在发布前几周，他们删除了 Prisma 支持。可能是为了推动人们走向 IntelliJ Ultimate。
2、他们删除了 JS / TypeScript 支持，现在仅在 Ultimate 版本中提供，这使得使用后端 Rust Web 服务器或 Tauri 或 Dioxus 之类的项目工作变得非常烦人。
3、我最初想使用 vscode 或其他较小的编辑器，如 zed 或 sublime text，但我一直回到 rust Rover，因为它在窗口底部有精美的测试集成，并且能够轻松编辑如何运行各种目标的配置（ shell 中目标之前或之后的命令等）。
continue 和 Clippy 扩展在 rust Rover 中也能很好地工作，尽管我没有看到它们比在 vscode 中工作得更好。
4、我们必须感谢 jetbrain 的免费版，也许故意限制免费版本让你习惯该产品。
5、在工作中，通过 phpstorm，我获得了对 vue 的 js 支持以及除 php 支持之外的其他内容。然而，rustrover 不再支持 js 生态系统，就像几周前的 beta 版本一样。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10e6e5b0dd65fa382e38748a9047b389/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/345/">«</a>
	<span class="pagination__item pagination__item--current">346/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/347/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>