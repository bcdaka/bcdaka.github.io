<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9d24e88e68c87c798f7afe651c5de9a/" rel="bookmark">
			Windows10如何关闭Edge浏览器的Copilot
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Windows10更新后，打开Edge浏览器，无论复制什么内容，都会弹出Copilot人工智能插件，非常令人反感，网上搜索的关闭方法都非常麻烦，比如：组策略和注册表。自己摸索得出最简便有效的关闭方法。
1、复制网页中的内容，自动出现Copilot插件，点击弹出窗口。
2、点击菜单图标，选择“通知和引用设置”。
3、关闭“显示Copilot”开关，然后点击“重启浏览器生效”。
4、重启后可以看到Copilot的确被关闭了。
5、但此时打开CSDN写文章，依然会弹出重写的提示框。问题没有被彻底解决，说明没有找到根源。经过摸索后成功找到问题症结。
6、设置——&gt;语言，关闭“在 Web 上使用撰写(AI 书写)”。不需要重启浏览器你就可以看到新变化，不会再有Copilot的提示框了。
让无数人从黑暗走向光明的四本书，你的命运可能由此改变：
《了凡四训》在线阅读白话文《寿康宝鉴》在线阅读白话文《阴律无情》在线阅读白话文《欲海回狂》在线阅读白话文 电子书百度网盘下载链接 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8068facc4f9812552b654b68ca8c9460/" rel="bookmark">
			大数据——大数据架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一：大数据应用场景 1.离线批处理
数据量比较大，延迟比较高
2.实时检索
实时检索中的hbase按key值检索较快，因为其存储是顺序存储，但是对value的检索就相对较慢。
数据量大，实时查询数据，不能对数据做大量修改
3.实时处理
通过flume收集数据，存放到kafka中，然后我们可以通过flink或者spark中的structedstreaming来进行处理，处理后的数据我们不放入数据库中，而是放入redis（缓冲器），这样可以提高应用对数据的读取速度 。
4.融合数仓
高斯DB
二.大数据架构概述 大数据架构是关于大数据平台系统整体结构与组件的抽象和全局描述，用于指导大数据平台系统各个方面的设计和实施。
一个典型的大数据平台系统架构应包括以下层次:
数据平台层(数据采集、数据处理、数据分析)数据服务层(开放接口、开放流程、开放服务);6数据应用层(针对企业业务特点的数据应用)数据管理层(应用管理、系统管理)。 数据平台层 数据平台层 是大数据体系中最基础和最根本的部分。数据平台层一般包含三个层次。
数据采集层:包括传统的ETL离线采集、实时采集等。
数据处理层:根据数据处理场景要求不同，对采集回来的数据进行一些规范化的预处理。常用处理 方式可以分为Hadoop离线处理、实时流处理等。
数据分析层:包括传统的数据挖掘和进一步的机器学习、深度学习等。
数据服务层 数据服务层是基于数据平台层，以开放接口、开放流程为基础，采用基于云计算的大数据存储和处理架构、分布式数据挖掘算法和基于互联网的大数据存储、处理和挖掘大数据服务模式。
构建基于服务的大数据分析模式，提供大数据处理和分析的服务功能。
基于互联网和云计算的大数据存储、处理和挖掘的数据中心系统架构，提供多用户、多任务的大数据分析服务。
数据应用层 数据应用层 是各个企业根据自身的具体业务及应用所规划和实施的大数据应用和服务。主要将大数据应用到行业领域，实现基于行业的应用。
根据企业的特点不同划分不同类别的应用，比如针对运营商，对内有精准营销、客服投诉、基站分析等，对外有基于位置的客流、基于标签的广告应用等等。
主流的应用层面的技术包括大数据统计、分析、挖掘、展现等等。
数据管理层 数据管理层包括应用管理和系统管理。
应用管理主要是从数据设计、开发到数据销毁的全生命周期管理，建立数据标准、质量规则和安全策略等，从而实现从事前管理、事中控制和事后稽核、审计的全方位的数据质量管理，元数据管理和安全管理。
系统管理主要是将大数据平台纳入统一的云管理平台管理，云管理平台包括支持一键部署、增量部署的可视化运维工具、面向多租户的计算资源管控体系(多租户管理、安全管理、资源管理、负载管理、配额管理以及计量管理)和完善的用户权限管理体系，提供企业级的大数据平台运维管理能力支撑。
三.主流大数据架构 大数据基础架构主要为了解决传统BI中在处理大数据时的性能等问题，提供满足日常数据分析和数据处理的能力
大数据流式架构数据全程以流的形式处理，适用于预警、监控、对数据有实时处理要求的场景。
大数据Lambda架构充分利用和整合批处理和流处理各自强项的数据处理架构。其包含了三层:批次处理，实时处理和响应查询的服务层。
大数据Kappa架构在Lambda的基础上进行了优化，将实时和流处理部分进行了合并。将数据通道以消息队列进行替代。Kappa以流处理为主，但是数据却在数据湖层面进行了存储。
大数据统一架构对Lambda进行了改造，在流处理层新增了机器学习层。适用于有大量数据分析需求，同时对机器学习有需求或者规划的场景。
四.大数据基础架构 企业传统的数据分析的业务需求没有发生变化，但是因为数据量增加、性能等问题导致系统无法正常使用，需要进行升级改造。数据分析需求依旧以BI场景为主，引入大数据基础架构 (Hadoop)，使用分布式计算框架和批处理技术提升数据的分析和处理能力。
大数据流式架构 大数据流式架构在大数据基础架构上，去掉批处理部分，从而更专注处理流式数据。流数据是一组顺序、大量、快速、连续到达的数据序列。应用于网络监控、传感器网络、航空航天、气象测控和金融服务等领域。流式架构在数据接入端没有了ETL，转而替换为数据通道。经过流处理加工后的数据，以消息的形式直接推送给了消费者，满足了用户对数据的实效性需求。 大数据Lambda架构 Lambda架构是大数据系统里面举足轻重的架构，大多数架构基本都是Lambda架构或者基于其变种的架构。Lambda架构很好的兼顾了实时处理和离线处理，几乎覆盖了大多数的数据分析和需求处理。可以很好地满足同时存在实时和离线需求的场景。Lambda架构将数据通道分为两个分支：实时流和离线。实时流类似流式架构，保障了其实时性，而离线则以批处理方式为主，保障了最终一致性。 大数据Kappa架构 Kappa架构在Lambda架构的基础上进行了优化，将实时部分和流部分进行了合并，将数据通道以消息队列进行替代，依旧以流处理为主，但是数据却在数据湖层面进行了存储。消息队列(Message Queue)是分布式系统中的重要功能，主要解决应用耦合、异步处理等问题。常用的消息处理方案有 Kafka、RabbitMQ 和ActiveMQ。 大数据统一架构 大数据统一架构将机器学习和数据处理进一步整合。从核心上来说，统一架构依然以Lambda为主，只是对其进行了优化和改造，重点是在流处理层新增了数据服务层（数据挖掘，机器学习等）。数据在经过数据通道进入数据湖后，新增了模型训练部分，并且将其在流式层进行使用。同时流式层不单使用模型，也包含着对模型的持续训练。 五.大数据架构在大数据中的重要性 1.好的大数据架构需要围绕着企业的业务进行设计，而不是单单围绕着技术架构。业务是核心，而技术是业务的支持，好的大数据架构能满足业务的持续发展。
2.大数据架构决定了—个大数据系统的主体结构、宏观特性和具有的基本功能以及特性。
3.好的大数据架构可扩展性强，可维护性高，能为企业未来的业务发展提供数据支撑 。
4.在数据处理技术分布式演进趋势中，Hadoop成为开放的事实标准。但其生态圈庞大复杂，使用合适的架构及其组件尤为重要。
5.大数据架构作为系统协调者角色提供系统必须满足的整体要求，包括政策、治理、架构、资源和业务需求，以及为确保系统符合这些需求而进行的监控和审计活动。
系统协调者定义和整合所需的数据应用活动到运行的垂直系统中。系统协调者的功能是配置和管理大数据架构的其他组件，来执行一个或多个工作负载。系统协调者通常会涉及到更多具体角色，由一个或多个角色扮演者管理和协调大数据系统的运行。这些角色扮演者可以是人，软件或二者的结合。 6.大数据架构作为数据提供者角色为大数据系统提供可用的数据。
在一个大数据系统中，数据提供者的活动通常包括采集数据、持久化数据、对敏感信息进行转换和清洗。作为数据提供者创建数据源的元数据及访问策略、访问控制、通过软件的可编程接口实现推或拉式的数据访问、发布数据可用及访问方法的信息等。大数据架构通常需要为各种数据源（原始数据或由其它系统预先转换的数据）创建一个抽象的数据源，通过不同的接口提供发现和访问数据功能。 7.大数据架构作为大数据应用提供者在数据的生命周期中执行一系列操作，以满足系统协调者建立的系统要求及安全和隐私要求。
大数据应用提供者通过把大数据框架中的一般性资源和服务能力相结合，把业务逻辑和功能封装成架构组件，构造出特定的大数据应用系统。大数据架构作为大数据应用程序提供者可以是单个实例，也可以是一组更细粒度大数据应用提供者实例的集合，集合中的每个实例执行数据生命周期中的不同活动。每个大数据应用提供者的活动可能是由系统协调者、数据提供者或数据消费者调用的一般服务，如Web服务器、文件服务器、一个或多个应用程序的集合或组合。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a6c95dd593314a158605200ca72246b/" rel="bookmark">
			字符函数和字符串函数（1）＜C语言＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在C语言编写程序时，常常需要完成对字符和字符串的处理，为了快捷、方便处理字符和字符串，C语言内置了一些字符函数和字符串函数，所以下文将要介绍一些字符和字符串函数，如：头文件&lt;ctype.h&gt;包含的一些字符分类函数：islower()、isdigit()、isupper()、isalpha()等，头文件&lt;string.h&gt;包含的strlen()、strcpy()、strcat()、strcmp()、strncpy()、strncat()、strncmp()等。
目录
前言
头文件
头文件
strlen()函数
函数参数及其返回类型:
作用：
注意点：
模拟实现：
strcpy()函数
函数参数及其返回类型:
作用：
注意点：
模拟实现：
strcat()函数
函数参数及其返回类型:
作用：
注意点：
模拟实现：
strcmp()函数
函数参数及其返回类型:
作用：
注意点：
模拟实现：
头文件&lt;ctype.h&gt; &lt;ctype.h&gt;下的所有函数传入参数和返回类型一般都是一样的，例如islower()函数。
int islower(int c) 字符分类函数的传入参数是一个字符或它的Ascii码值，返回值是一个零表示假，非零表示真。
常见的字符分类函数：
islower()——判断是否为小写字母
isupper()——判断是否为大写字母
isdigit()——判断是否为‘0’到‘9’的数字字符
isalpha()——判断是否为字母（包括大小写）
例如，使用islower()函数判断是否为小写，完成大小写转换：
//大写转小写lower函数 #include&lt;ctype.h&gt;//包含头文件&lt;ctype.h&gt; #include&lt;stdio.h&gt; int main() { char arr[20] = "hello world!"; int i = 0; while (arr[i]) { if (islower(arr[i])) {//使用islower()函数完成判断 arr[i] -= 32;//小写字母Ascii值－32得到大写字母 } i++; } printf("%s", arr); return 0; } 运行结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a6c95dd593314a158605200ca72246b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/685edf82dc93a4a4e3d708dc9be1ca07/" rel="bookmark">
			Android Studio每次新建项目，就会重新下载.gradle文件 【完美解决办法】不用暂停下载，不用每次设置Gradle user home
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Android Studio中每次新建项目都会下载gradle文件，网上有的教程是暂停下载，然后去setting里面手动修改Gradle user home的路径，然后点击Sync来解决每次新建项目时都会下载gradle文件的问题。但是这样每次新建项目的时候都要去进行一些无关的操作，关键这些操作还是重复且机械的，对于程序员来说最受不了的就是进行重复无意义的工作了。于是在项目文件夹下的Gradle Scripts栏里，找到了这个配置文件 打开一看
凭借本人灵敏的嗅觉，一看就第一行就觉得有那味儿了，没错，就是系统环境变量。尝试着在系统环境变量里加入了这样一项
解决方法 配置电脑环境变量，点击新建。输入
GRADLE_USER_HOME
变量值是你安装gradle的路径。
新建项目…
结果你猜怎么着，还真解决了！新建新项目也不会再去下载什么gradle了。
ps：如果你本地文件夹里没有你当前使用的gradle版本，Android Studio也是会去下载的，不过也就下载一次，下次就不会下载了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b4ae6bc51918828cb0c81c8ba97a33e/" rel="bookmark">
			Java String 类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java String 类 字符串广泛应用 在 Java 编程中，在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。
创建字符串
创建字符串最简单的方式如下:
String str = “Runoob”;
在代码中遇到字符串常量时，这里的值是 “Runoob”，编译器会使用该值创建一个 String 对象。
和其它对象一样，可以使用关键字和构造方法来创建 String 对象。
用构造函数创建字符串：
String str2=new String(“Runoob”);
String 创建的字符串存储在公共池中，而 new 创建的字符串对象在堆上：
String s1 = “Runoob”; // String 直接创建
String s2 = “Runoob”; // String 直接创建
String s3 = s1; // 相同引用
String s4 = new String(“Runoob”); // String 对象创建
String s5 = new String(“Runoob”); // String 对象创建
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b4ae6bc51918828cb0c81c8ba97a33e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6c081c4ee3dba78982a023454e2219c/" rel="bookmark">
			用 LLama-Factory 训练和微调 LLama3，打造你的专属 AI 模型！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用 LLama-Factory 训练和微调 LLama3，打造你的专属 AI 模型！ 文章目录 用 LLama-Factory 训练和微调 LLama3，打造你的专属 AI 模型！什么是模型微调？为什么使用 LLama-Factory？ LLAMABOARD：LLAMAFACTORY 的统一界面使用 Paperspace 微调 LLama 3结论参考资料 在这篇文章中，我们将了解如何使用 Llama Index 微调 Llama3。更棒的是，你只需几个简单的步骤和几行代码就可以实现这一点。 在低成本云 GPU 上构建和扩展 AI 模型。
本文将探索于 2024 年 3 月 21 日发布的 Llama Factory，并了解如何微调 Llama 3。为了我们的任务，我们将使用 NVIDIA A4000 GPU，这被认为是最强大的单槽 GPU 之一，能够无缝集成到各种工作站设置中。
利用 NVIDIA Ampere 架构，RTX A4000 集成了 48 个第二代 RT 核心，192 个第三代 Tensor 核心和 6144 个 CUDA 核心及配备有 ECC 的 16GB 图形内存；确保创新项目的计算精度和可靠性。
直到最近，微调大语言模型还是一个复杂的任务，主要由机器学习和 AI 专家处理。然而，随着人工智能领域的不断发展，这一观念正在迅速改变。新工具如 Llama Factory 正在出现，使得微调过程更加便捷和高效。此外，现在还可以使用 DPO、ORPO、PPO 和 SFT 等技术进行微调和模型优化。此外，你现在可以高效地训练和微调 Llama、Mistral、Falcon 等模型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6c081c4ee3dba78982a023454e2219c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2192327ac4278dd5d53712512d81547b/" rel="bookmark">
			idea 创建web项目以及添加数据库连接(mysql)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前文：笔者在idea上学习遇到诸多困难，记录一下，方便后来的人
1.新建
2.右键
3.右键.idea新建Directory命名为lib
4.找到web下的WEB_INF，右键WEB_INF，右键创建新的Directory命名为classes
5.点击Project Structure
6.如下图，选择为刚才新建的classes目录
两个都选classes，最后点击apply
7.把tomcat下的lib文件下的jsp.api和servlet,以及官网下载的mysql包都放在刚创建好的code文件下的.idea的子文件不断寻找到lib，然后放在其下
8.右键刚刚添加进来的jsp-api.jar，然后选择add as library,三个依次照做
9.点击右边的add configuration,找到Tomcat server 选择local
再点击右下角感叹号的Fix,再次点击apply,再点击ok
10.右键src,选择Package,
输入com.javaBean，回车键
再右键com.javaBean新建BookUtils
package com.javaBean; import java.sql.Connection; import java.sql.DriverManager; import java.sql.SQLException; public class BookUtils { private static final String URL = "jdbc:mysql://127.0.0.1:3306/book"; //将book替换为自己的数据库，后面的root和密码也换为你自己的 private static final String USER = "root"; private static final String PASSWORD = "123456"; public static Connection getConnection() { Connection conn = null; try { Class.forName("com.mysql.cj.jdbc.Driver"); conn = DriverManager.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2192327ac4278dd5d53712512d81547b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e55b70ad31c7a5e7492081cc8c5e6924/" rel="bookmark">
			数据结构--双向链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、链表的分类 链表的结构⾮常多样，以下情况组合起来就有8种（2 x 2 x 2）链表结构：
带头：指的是链表中有哨兵位节点，该节点不存储任何有效数据，属于无效节点，通过这个无效节点当头节点 让我们某些方面使用会有一些优势
双向：有两个指针分别指向前一个节点和后一个节点，可以从两个方向遍历，从前往后从后往前。
循环：尾节点不在指向NULL而是指向头节点。
我们实际中最常⽤的两种结构： 单链表 和 双向带头循环链表
1. ⽆头单向⾮循环链表：结构简单，⼀般不会单独⽤来存数据。实际中更多是作为其他数据结 构的⼦结构，如哈希桶、图的邻接表等等。另外这种结构在笔试⾯试中出现很多。
2. 带头双向循环链表：结构最复杂，⼀般⽤在单独存储数据。实际中使⽤的链表数据结构，都 是带头双向循环链表。另外这个结构虽然结构复杂，但是使⽤代码实现以后会发现结构会带 来很多优势，实现反⽽简单了，后⾯我们代码实现了就知道了。
我们上篇博客讲了单链表，它其实就是不带头单向不循环（简称：单链表）
那么本节博客讲双链表，带头双向循环（简称 ：双向链表）
二、双向链表的结构 双向链表节点中有两个指针prev和next，分别指向其前驱指针和后继指针。
链表节点的组成：数据+指向下一个节点的指针+指向前一个节点的指针。
注意：这⾥的“带头”跟前⾯我们说的“头节点”是两个概念，实际前⾯的在单链表阶段称呼不严 谨，带头链表⾥的头节点，实际为“哨兵位”，哨兵位节点不存储任何有效元素，只是站在这⾥“放哨 的” “哨兵位”存在的意义： 遍历循环链表避免死循环。
三、双向链表的基本操作 老规矩依旧三个文件，一个头文件，两个源文件
我们要在双向链表实现以下操作：
1.定义双向链表
2.初始化双向链表
3.尾插
4.头插
5.尾删
6.头删
7.指定位置之后插入数据
8.删除节点
9.打印
10.查找
11.销毁
1.定义双向链表 typedef int LTDataType; typedef struct ListNode { LTDataType date; struct ListNode* next; struct ListNode* prev; }LTNode; date用来存储数据 ，next指针保存下个节点，prev指针保存前一个节点。
2.各个函数的声明 #pragma once #include &lt;stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e55b70ad31c7a5e7492081cc8c5e6924/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/874f1333230ff74984276892ccb8c6f2/" rel="bookmark">
			Android Studio 国内高速下载安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有个需求要编一个 Android app，需要下载 Android Studio，结果国外的网站直接访问不了，找了半天，才找到其国内中文网站，记录一下，也省的大家费劲到处找。
一、下载 Jellyfish： 用于开发 Android 应用的官方集成开发环境 (IDE)，中文网站，目前版本是 Jellyfish：
下载迅速（我试了一下，大约 10MB/s）。
下载 Android Studio 和应用工具 - Android 开发者 | Android Developers
二、下载其他版本： 还找到一个过往版本下载，也是在国内的网站，但是英文的：
我试了一下，下载 Arctic Fox，速度也是贼快。
Android Studio Arctic Fox | 2020.3.1 Patch 4 December 8, 2021
三、安装： 直接运行下载的 exe 文件，安装即可。
也可以选择特定的 SDK 版本：
这个下载也比较快：
四、国内源替换： 在下载过程中，如果发现下载某个文件很慢，可以切换到国内源，手动下载。
Gradle sync failed: Could not install Gradle distribution from 'https://services.gradle.org/distributions/gradle-7.0.2-bin.zip'. (25 m 21 s 19 ms) 国内 gradle 版本快速下载通道： 将：https://services.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/874f1333230ff74984276892ccb8c6f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd8a608608839324b169f8a8a8850348/" rel="bookmark">
			数据结构堆排序（c语言版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.堆排序的概念 1.堆的思想 堆排序是一种常见的排序算法。它的基本思想是:
将待排序序列构建成一个大顶堆。大顶堆的特点是根节点的值大于或等于其左右子节点的值。
交换根节点(即当前最大值)与末尾元素。
减小堆的规模，重新调整结构，使其满足堆定义，然后再次交换根节点与当前末尾元素。
反复执行步骤2和步骤3，直到整个序列有序。
2.堆的实现步骤 具体实现步骤如下:
建立大顶堆:从最后一个非叶子节点开始调整，向上直到根节点。交换堆顶元素(即当前最大值)与末尾元素,并减小堆的规模。重新调整堆,使其满足堆定义。重复步骤2和步骤3,直到整个序列有序。 堆排序的时间复杂度为O(nlogn)。空间复杂度为O(1),因为它在原数组上进行排序,不需要额外的内存空间。
堆排序的优势是能够在一个数组上就地完成排序,不需要额外的空间。缺点是对于小规模的数据,不如简单的插入排序和冒泡排序快。
3.堆的优点 优点:
时间复杂度为O(nlogn),是比较高效的排序算法之一。在原数组上进行排序,不需要额外的内存空间,即空间复杂度为O(1)。相比于其他基于比较的排序算法,如快速排序和归并排序,堆排序能够避免最坏情况下的性能下降。堆排序算法的关键操作是堆的构建和堆的调整,可以利用堆这种数据结构的性质来快速完成排序。堆排序算法的实现相对简单,容易编码实现。 4.堆的缺点 缺点:
对于小规模的数据,堆排序并不一定是最优选择,因为相比于简单的插入排序和冒泡排序,堆排序有较大的常数时间因子。堆排序算法不是原地排序,需要利用原始数组的空间来存储中间结果。在某些情况下,堆排序的性能可能不如其他算法,如快速排序和归并排序。这取决于输入数据的特点。堆排序算法需要利用堆这种特殊的数据结构,对程序员的要求相对较高,实现起来也相对复杂一些。 二.堆排序的功能 堆排序的主要功能是对一个给定的数组进行升序或降序排序。具体来说,堆排序有以下几个主要功能:
1.构建大顶堆或小顶堆 堆排序算法首先需要将输入数组构建成一个大顶堆或小顶堆。大顶堆的根节点是数组中的最大值,左右子节点都小于根节点。小顶堆的根节点是数组中的最小值,左右子节点都大于根节点。构建堆的过程使用"heapify"操作,从最后一个非叶子节点开始,逐级向上调整节点位置,直到根节点满足堆的性质。这一步保证了数组中的元素满足堆的特性,为后续的排序奠定基础。 2.排序 在构建好堆之后,堆排序会进行反复的交换和调整操作。首先将堆顶元素(即最大值或最小值)与堆的最后一个元素交换位置。然后对新的根节点进行调整,使其满足堆的性质,成为一个新的有效堆。通过不断重复这样的交换和调整过程,可以将最大值或最小值逐步放置到数组的后部,达到排序的目的。这一步通过不断"弹出"堆顶元素并调整堆,最终实现了整个数组的排序。 3.支持原位排序 堆排序是一种原地排序算法,不需要额外的内存空间来辅助排序。算法直接在原数组上进行操作,交换和调整元素位置,不需要申请新的数组空间。这使得堆排序的空间复杂度非常低,仅需O(1)的额外空间开销。原地排序的特性使得堆排序可以高效地处理大规模数据,不会受到内存限制的影响。 4.时间复杂度优秀 堆排序的时间复杂度为O(nlogn),其中n是输入数组的大小。这是一个非常优秀的时间复杂度,使堆排序成为高效的通用排序算法之一。无论数据规模大小,堆排序的时间复杂度都保持稳定,不会随数据规模的增加而急剧增长。 5.适用于大规模数据 由于时间复杂度优秀,堆排序特别适用于排序大规模数据集。相比于一些时间复杂度为O(n^2)的排序算法,堆排序可以更高效地处理海量数据。这使得堆排序在处理大型数据库、大文件排序等场景下具有很强的优势和应用价值。 三.堆排序的代码实现 1.构建大顶堆 heapify(arr, n, i) 函数用于构建大顶堆。它从最后一个非叶子节点开始,向上调整整个堆。
heapify(int arr[], int n, int i) 函数:
该函数用于调整以 i 为根节点的子树,使其满足大顶堆的性质。首先找到根节点、左子节点和右子节点中的最大值的下标 largest。如果最大值不是根节点,则将根节点与最大值交换,并递归地调整子树。 void heap_sort(int arr[], int n) { // 构建大顶堆 for (int i = n / 2 - 1; i &gt;= 0; i--) heapify(arr, n, i); // 交换堆顶元素与末尾元素, 并重新调整堆 for (int i = n - 1; i &gt; 0; i--) { int temp = arr[0]; arr[0] = arr[i]; arr[i] = temp; heapify(arr, i, 0); } } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd8a608608839324b169f8a8a8850348/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e899c6506d75c7ecd2d325066546bbf/" rel="bookmark">
			ollama &#43; fastgpt搭建本地私有AI大模型智能体工作流（AI Agent Flow）-- windows环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先我们来探究下为什么要设计大模型+工作流 一、大模型+工作流的优势主要有四点： 1. 降低任务门槛：工作流可以将复杂任务分解成多个小任务，降低每个任务的复杂度，从而减少对提示词和大模型推理能力的依赖。这样可以提升大模型处理复杂任务的性能和容错能力。
2. 提升任务效率：工作流可以实现自动化处理，减少重复劳动和纠正。只需提供必要元素，工作流就可以直接输出结果，提高效率和稳定性。
3. 提高任务的一致性：工作流可以确保任务的执行是一致的，减少人为错误和偏差，提高任务的可靠性和质量。
4. 实现任务的可重复性：工作流可以实现任务的可重复性，减少重复劳动和开发时间，提高开发效率和生产力。
好了接下来我们开始正式实践。
二、安装docker desktop + wsl2 dockerdesktop下载地址：Docker Desktop: The #1 Containerization Tool for Developers | Docker
安装步骤就省略咯，可以百度。
推荐博客：0基础基于最新WSL2的Window Docker安装及搭建内网穿透保姆级教程_wsl 镜像网络-CSDN博客
三、安装ollama 1、安装ollama 下载ollama官方windows安装程序，下载后直接双击应用程序安装。
地址：Ollama
安装完成后进行更换ollama的存储位置
（设置环境变量--不明白就百度一下windows设置环境变量，这里就不过多讲解。）：
设置完成后重启电脑。
2、下载模型 ollama官网顶部Models，进入模型列表界面。
复制完成后进入cmd，并开始下载模型，将复制的模型 粘贴并回车。
上图为拉取进度，完成后会自动进行编译，然后本地cmd方式即可进行对话。
经过以上步骤本地大模型llama3以安装完成，接下来我们通过dockerdesktop进行搭建fastgpt。
四、安装部署Fastgpt 1、部署fastgpt到dockerdesktop Fastgpt开源项目地址：https://github.com/labring/FastGPT
Fastgpt官方docker模式部署地址：Docker Compose 快速部署 | FastGPT
方法如下：
启动 dockerdesktop。
依次执行下面命令，创建 FastGPT 文件并复制docker-compose.yml和config.json的内容并创建两个一模一样的文件，执行完后目录下会有 2 个文件。
文件创建好并拷贝出git上对应的两个文件内容，并cmd进入当前文件夹执行代码：docker-compose up -d
然后等待安装完成（由于我电脑已经完成安装，就不演示了）。完成后dockerdesktop会显示如下信息：
文件夹内容：
dockerdesktop内容：
2、启动并配置one api模型： 访问本地部署好的one api：http://localhost:3001/channel
初始化的 用户名:root 密码：123456
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e899c6506d75c7ecd2d325066546bbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0059054d831dcec72ec5a33fae9627d/" rel="bookmark">
			继承详解——C&#43;&#43;深度学习解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 ： 本节内容是讲解面向对象中三大特性之一的继承。 继承是面向对象程序设计中代码复用的一种重要手段。 通过继承， 我们就可以在原本的代码上进行扩展， 而不是重新写一段代码， 让代码变得冗余。 同时， 继承也体现了面向对象程序设计的层次结构，不同于我们以前经常见到的函数的复用， 继承是层次上的复用， 也可以说是类层次的复用。
注：本节讲述的是c++里面的继承， 适合正在学习c++的友友们进行观看。
目录
一.什么是继承
1.1继承体系
1.2定义格式
1.3继承方式
二、继承的作用域问题
三、继承的切片问题
四、派生类的默认成员函数
4.1派生类的构造函数：
4.2派生类的析构函数
4.3派生类的拷贝构造函数
4.4派生类的赋值重载
五、继承与友元
六、继承与静态成员
七、菱形继承和菱形虚拟继承
一.什么是继承 1.1继承体系 在继承体系中， 被继承的那个类叫做基类或者父类， 继承来的那个类叫做派生类或者子类
我们通过一个具体的实例来看一下继承是怎么实现类的复用的：
定义一个继承体系：
#include&lt;iostream&gt; using namespace std; #include&lt;vector&gt; #include&lt;string&gt; //基类 class Person { public: //构造函数 Person(const string name, const string sex) :_name(name) ,_sex(sex) {} //打印接口 void Print() { cout &lt;&lt; "姓名" &lt;&lt; _name &lt;&lt; " 性别:" &lt;&lt; _sex &lt;&lt; endl; } private: string _name; //姓名 string _sex; //性别 }; //学生类， 子类 class Student : public Person //继承的写法就是 ：+ 继承方式 + 继承的基类 { public: Student(string name, string sex, int num) :Person(name, sex) //初始化列表调用基类的构造函数方式 ,_num(num) {} private: int _num; //学号 }; //教师类， 子类 class Teacher : public Person //继承的写法就是 ：+ 继承方式 + 继承的基类 { public: Teacher(string name, string sex, int wages) :Person(name, sex) //初始化列表调用基类的构造函数方式 ,_wages(wages) {} private: int _wages; //工资 }; 在这个继承体系里面， 虽然Student和Teacher表面上只定义了_num 或者_wages。但是，Student和Teacher都继承了Person类。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0059054d831dcec72ec5a33fae9627d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba2cb0678b4479baa72369ce93c62e8a/" rel="bookmark">
			如何使用 GPT 4o API 实现视觉、文本、图像等功能？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何使用 GPT 4o API 实现视觉、文本、图像等功能？ 引言 在积累了大量关于搜索引擎的炒作之后，OpenAI 发布了 ChatGPT-4o，这是其受到广泛好评的 ChatGPT-4 模型的升级版，并成为其旗舰产品 ChatGPT 的核心。这个改进版本在速度和性能上有显著提升，在文本、视觉和音频处理方面提供了增强的能力。这款创新模型将在包括 Free、Plus 和 Team 在内的各种 ChatGPT 计划中可用，并将集成到多个 API 中，例如 Chat Completions、Assistants 和 Batch。如果你想访问 GPT 4o API 来生成和处理视觉、文本等内容，那么这篇文章适合你。
目录 什么是 GPT-4o？ GPT-4o 是 OpenAI 最新和最强大的 AI 模型。这不仅仅是 AI 聊天机器人领域的又一步，而是一个具有突破性功能的飞跃，称为 多模态能力。
这意味着：传统上，像以前版本的 GPT 这样的语言模型主要集中在理解和响应文本。GPT-4o 打破了这一模式，成为真正的多模态模型。它可以无缝处理来自不同格式的信息，包括：
文本： 这是其核心优势，允许 GPT-4o 进行对话、回答问题，以及生成诗歌或代码等创作性文本格式。
音频： 想象一下，播放一首歌给 GPT-4o，让它分析音乐、描述激发的情感，甚至写出受其启发的歌词！GPT-4o 可以理解口语，包括语调和潜在的背景噪音。
视觉： 给 GPT-4o 看一张图片，它可以分析内容、描述场景，甚至根据图像讲述一个故事。这为图像分类或为视频生成字幕等应用开辟了新天地。
这种多模态能力使 GPT-4o 能够更加清晰地理解世界。它能掌握超越文字字面意思的沟通细节。以下是这些优点的分解：
更自然的对话： 通过理解音频中的语调和图像上下文，GPT-4o 能进行更自然且有吸引力的对话。它能体会到人类沟通中的微妙之处。
增强的信息处理： 想象一下分析包含文本、音频录音和图像的数据集。GPT-4o 能从所有这些格式中提取洞见，从而对信息有更全面的理解。
新的应用： 可能性是无限的！GPT-4o 可以用于创建更好理解你需求的 AI 助手，开发结合文本和多媒体元素的教育工具，甚至通过基于不同输入生成创意内容来推动艺术表达的界限。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba2cb0678b4479baa72369ce93c62e8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd5588ba8277b4e893d08ed5e1d8679e/" rel="bookmark">
			【C&#43;&#43;】string模拟实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥个人主页： Forcible Bug Maker
🔥专栏： STL || C++
目录 前言🔥string类的接口函数🔥string类的模拟实现==swap交换====默认成员函数====迭代器====获取容量和内容信息====reserve预留空间====尾插字符和字符串====字符或字符串的插入和删除====find查找====比大小运算符重载====获取子串====清除clear====流插入和流提取====常量成员npos== 结语 前言 本篇博客主要内容：实现string类的基本功能。
string使用很快就讲完了，但是光会用string还不够，在面试中，面试官总喜欢让我们自己来模拟实现string类，包括string类的构造、拷贝构造、赋值运算符重载以及析构函数等等内容。所以，我认为string类的自实现还是有必要讲一下的。
🔥string类的接口函数 我们本次并不会将string类的所有接口函数逐一讲解，讲一些常用的和重点的。本次string的实现分成了两个文件，一份是string.h，一份string.cpp。
看看string.h的内容：
# define _CRT_SECURE_NO_WARNINGS 1 #pragma once #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cassert&gt; using std::cout; using std::cin; using std::endl; namespace ForcibleBugMaker { class string { public: // 交换，非成员函数 friend void swap(string&amp; s1, string s2); // 定义迭代器 typedef char* iterator; typedef const char* const_iterator; //迭代器获取 iterator begin(); iterator end(); const_iterator begin() const; const_iterator end() const; // string默认成员函数 string(const char* str = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd5588ba8277b4e893d08ed5e1d8679e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f2ee6c9605a2e8d6b5aede5d89641c6/" rel="bookmark">
			【机器学习聚类算法实战-4】机器学习聚类算法之k-均值聚类、分层聚类算法、凝聚聚类和谱聚类实例分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎩 欢迎来到技术探索的奇幻世界👨‍💻
📜 个人主页：@一伦明悦-CSDN博客
✍🏻 作者简介： C++软件开发、Python机器学习爱好者
🗣️ 互动与支持：💬评论 👍🏻点赞 📂收藏 👀关注+
如果文章有所帮助，欢迎留下您宝贵的评论，点赞加收藏支持我，点击关注，一起进步！
目录
前言 正文
01-基于凝聚聚类算法的二维数字嵌入上的各种凝聚聚类 02-基于K-means聚类算法对鸢尾花数据集进行聚类 03-基于光谱聚类算法在图像分割中的应用实例 04-基于硬币图像的结构化区域分层聚类演示 前言 在机器学习中，聚类算法是一类重要的无监督学习方法，用于将数据集中的样本分成具有相似特征的组或簇。本篇博客将深入探讨四种常用的聚类算法：k-均值聚类、分层聚类算法、凝聚聚类和谱聚类。通过详细的代码示例和可视化分析，我们将理解每种算法的原理、优缺点以及适用场景。通过本文的阅读，读者将能够更好地选择并理解如何应用适合自己数据集的聚类算法，从而更有效地进行数据分析和挖掘。
正文 01-基于凝聚聚类算法的二维数字嵌入上的各种凝聚聚类 这个例子向我们展示的是聚集性聚类的“rich getting richer”的行为，这种行为往往会造成不均匀的聚类大小。这种行为对于平均链接策略来说是非常明显的，它最终产生了几个单点簇，而在单个链接中，我们得到了一个单一的中心簇，所有其他的簇都是从边缘的噪声点中提取出来的。
下面是具体代码：这段代码展示了如何使用层次聚类（Hierarchical Clustering）方法对手写数字数据集（digits dataset）进行聚类，并将不同链接方式（linkage methods）的聚类结果可视化。
导入必要的库：time：用于计算代码运行时间。numpy：用于数值计算。scipy.ndimage：用于图像处理。matplotlib.pyplot：用于绘图。sklearn.manifold：用于降维。sklearn.datasets：用于加载数据集。sklearn.cluster.AgglomerativeClustering：用于进行层次聚类。
加载数据集：使用datasets.load_digits()加载手写数字数据集，返回特征矩阵X和标签y。
定义nudge_images函数：该函数用于微调图像，以增加数据集的多样性。对每张图像进行微小的平移操作。
定义plot_clustering函数：用于绘制聚类结果的散点图。将降维后的数据X_red映射到二维空间，并根据聚类标签labels给不同类别的点上色。
降维：使用manifold.SpectralEmbedding对数据进行降维，减少特征维度到2维，以便可视化。
循环遍历不同的链接方式：对于每一种链接方式（ward、average、complete、single）：将图像保存为.png文件。 调用plot_clustering函数绘制聚类结果的散点图。记录聚类运行时间。使用AgglomerativeClustering进行层次聚类，指定聚类数量为10。
from time import time import numpy as np from scipy import ndimage from matplotlib import pyplot as plt from sklearn import manifold, datasets from sklearn.cluster import AgglomerativeClustering X, y = datasets.load_digits(return_X_y=True) n_samples, n_features = X.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f2ee6c9605a2e8d6b5aede5d89641c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c557d8a378b6d70055a798889a339de/" rel="bookmark">
			Ubuntu系统下部署大语言模型：Ollama和OpenWebUI实现各大模型的人工智能自由
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前在window下安装过 Ollama和OpenWebUI搭建本地的人工智能web项目（可以看我之前写的文章），无奈电脑硬件配置太低，用qwen32b就很卡，卡出PPT了，于是又找了一台机器安装linux系统，在linux系统下测试一下速度能否可以快一些。
系统硬件介绍 Ubuntu 22.04.4 LTS
CPU: i5-10400F
内存：32G
硬盘： 512G SSD
显卡： NVIDIA GeForce GTX 1060 6GB
内网IP: 192.168.1.21
下载 Ollama 访问下载： https://ollama.com/
安装Ollama 方法1、命令行下载安装(耗时长) 安装命令：
$ sudo apt install curl $ curl -fsSL https://ollama.com/install.sh | sh 缺点： 国内网络环境要等很久
方法2 , 手动下载安装 1、手动下载 https://ollama.com/install.sh 这个文件
$ sudo mkdir ollama cd ollama $ sudo wget https://ollama.com/install.sh 2、注释掉下载部分 curl xxxx 手动下载ollama-linux-{ARCH}
$ sudo vim install.sh 修改文件： status "Downloading ollama..." #curl --fail --show-error --location --progress-bar -o $TEMP_DIR/ollama "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c557d8a378b6d70055a798889a339de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f70073e95e9fe255a10b47f5c1f6924f/" rel="bookmark">
			探索 api.maynor1024.live：一站式 AI 服务平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《探索 MaynorAI：一站式 AI 服务平台》
在当今数字化时代，人工智能（Artificial Intelligence，简称 AI）正逐渐改变着我们的生活和工作方式。而在这个领域中，MaynorAI 作为一家提供 AI 接口聚合管理服务的平台，引起了我的浓厚兴趣。通过对 https://api.maynor1024.live/ 的阅读和探索，我将为大家带来一篇关于 MaynorAI 的技术博客。
MaynorAI 平台的主要目标是为用户提供一站式接入各种 AI 服务的便利。无论你是需要进行自然语言处理、图像识别、语音合成还是其他 AI 任务，MaynorAI 都能满足你的需求。这一平台整合了多种 AI 技术和资源，为用户提供了丰富的选择和灵活性。
首先，MaynorAI 平台的价格优势非常明显。用户只需支付 3 元人民币，即可购买 1 美刀的额度。相比其他 AI 服务提供商，MaynorAI 的价格更为亲民，使得更多人能够享受到 AI 技术带来的便利和价值。
其次，MaynorAI 平台的稳定性和可靠性令人印象深刻。作为顶级 API 中转品牌，MaynorAI 确保了 100%使用官方企业高速渠道，非低价普通或逆向渠道。这意味着用户可以享受到高质量、稳定可靠的 AI 服务，而无需担心服务中断或质量问题。
MaynorAI 平台还提供了无忧风控解决方案，帮助用户解决了所有的「风控」问题。无需再承担额度过期或封号风险，也无需为账号注册、IP 受限、付款困难、账单无法支付等烦恼而担忧。这为用户提供了一个稳定、可靠的使用环境，让他们能够专注于 AI 应用的开发和创新。
在性能方面，MaynorAI 平台表现出色。它提供了卓越的并发处理能力，超高并发不限速，并且具有超强自研能力。基于渠道 RPM 和 TPM 的智能负载均衡算法，MaynorAI 能够快速响应并处理大量请求，大幅降低失败率和重试率。这对于需要处理大量数据和高并发请求的 AI 应用来说，是一个非常重要的优势。
此外，MaynorAI 平台还进行了资源高效整合，极大降低了接入成本与使用难度。通过企业账号资源整合和全球中继专线优化，MaynorAI 为用户提供了更经济、更高效的解决方案。用户无需再担心接入成本过高或使用难度过大的问题，能够轻松地将 AI 技术应用到自己的业务中。
MaynorAI 平台支持多种模型，包括 OpenAI 官方所有模型以及其他市面上常见的模型。这使得用户能够根据自己的需求和偏好选择适合的模型进行开发和应用。无论是聊天机器人、绘图工具还是读图软件，MaynorAI 都能提供相应的支持。
最后，MaynorAI 平台的客户服务团队以客户至上为原则，为用户提供专业的技术保障。用户在使用过程中遇到任何疑问或建议，都能在 24 小时内得到回复和解决。这种及时、专业的客户服务为用户提供了更好的使用体验。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f70073e95e9fe255a10b47f5c1f6924f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/421cc74a35be63fe614c235201ceaee8/" rel="bookmark">
			Appium iOS UI自动化之环境搭建（Xcode15，iOS17，真机）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、准备Xcode二、安装Appium1.Appium1和Appium22.安装appium-doctor3.安装Appium的driver4.安装Appium-inspector5.安装WebDriverAgent的前期准备第一步：把WebDriverAgent的bundleId改成你自己的第二步：给WebDriveragent签名第三步：给WebDriverAgentLib也签名第四步：被测手机开启开发者模式 6.安装WebDriverAgent第一种，带自动签名的安装第二种，使用预安装的wda第一，在xcode中的DerivedData文件夹中，删除掉Frameworks文件夹中以XC开头的文件。第二，用xcrun命令安装这个app（其实就是wda） 7.设置desired_capabilities，启动Appium-inspector 参考资料 前言 盼了好几年，公司终于让我开始着手UI自动化的事情了，然后配了两部iOS17.2.1的手机。然后我发现光是搭建环境这一步，就变得跟几年前书里学习的内容有点不一样了。所以把这段时间搭环境及如何实现用例的事情都写一下，希望能帮助到其他人。
一、准备Xcode 因为配备的iOS17.2.1的设备，所以必须使用xcode15及以上版本才能在设备中安装WebDriverAgent，而电脑系统必须在14及以上才能安装xcode15。而我的电脑是2017年产的，不支持升级到14的系统，所以目前Mac系统是13.6.6。我特地查询了一下支持xcode版本的mac系统：
可以看到macOS13.6.6，最新可以安装Xcode15.2的版本，于是下载，安装。
下载链接中的xcode是xip结尾的压缩包，用xip命令解压到Applications文件夹里，就可以直接使用了。xip命令可以参照这篇文章 https://www.jianshu.com/p/0b372a4e18f2。
二、安装Appium 1.Appium1和Appium2 跟Appium1.x版本不一样的是，Appium2是用命令行的方式启动，所以如果想要查看元素，他们提供了一个专门的工具appium-inspector。
如果mac系统里安装的nodejs的话，那么执行命令即可安装Appium：
npm i --location=global appium 安装完毕之后输入命令启动Appium：
appium 如果看到以上信息，就说明Appium是安装成功了，截图中显示的plugins这些目前暂时是没有的，后续的文章会继续讲解怎么安装，以及有什么用。
2.安装appium-doctor 然后为了保证Appium的各种依赖也是齐全的，需要安装Appium doctor来检查依赖等：
npm install @appium/doctor --location=global 安装完毕之后执行doctor检查下安装情况：
appium-doctor --ios 只要基本需要的依赖安装好了，那么就可以使用Appium了，如果需要其他什么特殊功能，后面再来安装对应的依赖和插件就好。
3.安装Appium的driver 据说以前的版本，Appium是自带了driver的，但是2.5版本，要使用什么driver就必须自己安装，比如我们要操作iOS，需要安装XCUITest的driver：
appium driver install xcuitest XCTest和XCUITest是苹果系统自己的UITest框架，Appium的原理是通过XCUITest的driver去驱动XCUITest，以实现自动化的目的，以后有空可以聊聊iOS的XCUITest如何写。
4.安装Appium-inspector 为了可以查看设备中元素，需要安装Appium-inspector，点击这里进入官网下载。
安装完毕之后打开inspector，可以发现和以前Appium1.X版本的样子差不多：
提示：安装中如何报错提示开发者没有被信任之类的，需要在mac的设置中去设置
5.安装WebDriverAgent的前期准备 市面上搜索WebDriverAgent，会有很多各种资料，最终，目前Appium2.5版本的情况是，Appium中自带了这个WebDriverAgent的源码，且启动appium-inspector时，会自动使用Appium中的WebDriverAgent，所以不需要单独去下载WebDriveragent。
在保证安装了xcode和XCUITest的driver的情况下，执行命令：
appium driver run xcuitest open-wda xcode会自动启动，且同时打开Appium里WebDriverAgent的源码。
第一步：把WebDriverAgent的bundleId改成你自己的 如截图里的选中样子，最终⑥就是需要你修改的bundleId，默认是com.facebook.WebDirverAgentRunner，但是必须要改掉，所以我改成了我的域名。
第二步：给WebDriveragent签名 把上图的④，切换到标签“Signing and Capacities”：
勾选“Automatically manage signing”，同时在Team那个地方选择自己的个人免费账号的Personal Team。
第三步：给WebDriverAgentLib也签名 说实话这步我不晓得是不是多余的，反正看过很多文章，有的要，有的不要，我懒得去纠结了，安排。
将第二步图中的①，切换到第一个WebDriverAgentLib，然后重复同样的签名操作，那么签名就完成了。
因为这个WebDriverAgent是安装到设备中的，所以我们只签名iOS相关的，macOS，或者tvOS这些是多余的，不用管。
第四步：被测手机开启开发者模式 手机连接到mac电脑，进入设置页，拉到列表最底部，看到“开发者”，点击进入，勾选选项“启用UI自动化”，然后会重启设备。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/421cc74a35be63fe614c235201ceaee8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da51bf7dd9cb25dfe967f2668c170f12/" rel="bookmark">
			滴滴三面 | Go后端研发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		狠狠的被鞭打了快两个小时… 注意我写的题解不一定是对的，如果你认为有其他答案欢迎评论区留言
bg：23届 211本 社招
1. 自我介绍 2. 讲一个项目的点，因为用到了中间件平台的数据同步，于是开始鞭打数据同步。。 3. 如果同步的时候，插入了新数据怎么处理？ 看我们业务对数据实时性的要求
如果实时性要求不高，可以设置定时任务，T+1小时、T+30分钟进行同步或者统一处理如果实时性要求高，我们可以监听binlog进行消费，不过要做好幂等性方面的工作，防止重复消费 4. binlog有什么用？ binlog是存储mysql的数据变更，我们可以通过监听binlog知道数据库发生了哪些变更，通常可以使用binlog进行数据同步、数据备份以及主从复制等等…
6. binlog的数据格式有哪些？ binlog日志有三种数据格式
STATEMENT：每一条修改数据的原声 SQL 语句都会被记录到 binlog 中。但有动态函数的问题，比如你用了 uuid 或者 now 这些函数，那么就会导致主库上执行的结果并不是从库执行的结果，这种随时在变的函数就会导致复制前后的数据不一致。ROW：记录行数据最终被修改成什么样了，不会出现 STATEMENT 下动态函数的问题。但 ROW 的缺点是每行数据的变化结果都会被记录，比如执行UPDATE user_user SET a = 1 WHERE id &gt; 100 语句，那么有多少行数据产生了变化，日志就会记录多少，这会使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句而已；MIXED：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式 7. 如何监听binlog？ 一般有两种方案：
基于 canal 中间件进行监听binlog基于flinkcdc监听binlog 其实这两种区别不大，业内常用的是flinkcdc来监听。原理就是模拟主从复制，将自身模拟程一个slave节点，向master节点发送dump协议，当master节点收到dump协议请求之后，就开始推送binlog到slave。
8. mysql dump 之后需要进行什么处理？ 一般接受到的是byte流数据，我们需要解析 binary log 对象才能拿到正在的变更后的数据。那么在接收到主服务器上的 dump 数据后，会根据数据的类型（SQL 查询语句或 Binlog）来进行处理，如果是STATEMENT格式就直接执行sql，如果是ROW格式就直接记录数据。（不确定是不是这样）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da51bf7dd9cb25dfe967f2668c170f12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4806d56dd29d94df580fa6d326cb5ff/" rel="bookmark">
			基于springboot&#43;vue&#43;Mysql的数码论坛系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发语言：Java框架：springbootJDK版本：JDK1.8服务器：tomcat7数据库：mysql 5.7（一定要5.7版本）数据库工具：Navicat11开发软件：eclipse/myeclipse/ideaMaven包：Maven3.3.9 系统展示
系统首页
数码板块界面
数码评价界面
数码论坛界面
个人中心
管理员登录
管理员功能界面
用户管理
数码板块管理
数码评价管理
数码论坛管理
用户后台管理
摘要
数码论坛系统能够通过互联网得到广泛的、全面的宣传，让尽可能多的用户了解和熟知数码论坛系统的便捷高效，不仅为用户提供了服务，而且也推广了自己，让更多的用户了解自己。对于数码论坛而言，若拥有自己的系统，通过系统得到更好的管理，同时提升了形象。
本系统设计的现状和趋势，从需求、结构、数据库等方面的设计到系统的实现，分别为管理员和用户的实现。论文的内容从系统的设计、描述、实现、分析、测试方面来表明开发的过程。本系统根据现实情况来选择一种可行的开发方案，借助java编程语言和MySQL数据库等实现系统的全部功能，接下来对系统进行测试，测试系统是否有漏洞和测试用户权限来完善系统，最终系统完成达到相关标准。
研究背景
21世纪，我国早在上世纪就已普及互联网信息，互联网对人们生活中带来了无限的便利。像大部分的企事业单位都有自己的系统，由从今传统的管理模式向互联网发展，如今开发自己的系统是理所当然的。那么开发数码论坛系统意义和用处有哪些呢？
1.首先提升形象：这是每个企事业单位建设系统的目的之一。当今的网络信息年代，连一个操作系统都不从有过，将会跟不上时代的步伐。
2.加强数码论坛服务：数码论坛行业性质要求您定期提供资料给管理员，或者随时接受用户的建议。如果用户需要，可以通过系统进行管理。
3.同时一个好的系统能将数码论坛的信息管理手段提上一个新的台阶。系统内容可以随时更新，这点对于现代数码论坛来说是很重要，但传统的管理方式都无法做到的。数码论坛系统就可以每天更新，随时向您反映数码论坛的最新情况。
数码论坛系统能够通过互联网得到广泛的、全面的宣传，让尽可能多的用户了解和熟知数码论坛系统的便捷高效，不仅为用户提供了服务，而且也推广了自己，让更多的用户了解数码论坛。
关键技术
SpringBoot是一个全新开源的轻量级框架。基于Spring4.0设计，其不仅继承了Spring框架原来有的优秀特性，而且还通过简化配置文件来进一步简化了Spring应用的整个搭建以及开发过程。另外在原本的Spring中由于随着项目的扩大导入的jar包数量越来越大，随之出现了jar包版本之间的兼容性问题，而此时SpringBoot通过集成大量的框架使得依赖包的版本冲突，以及引用的不稳定性问题得到了很好的解决。
JAVA语言是目前软件市场上应用最广泛的语言开发程序。可以在多种平台上运用的，兼容性比较强，适应市面上大多数操作系统，不会出现乱码的现像，其扩展性和维护性都更好，具有分析问题和解决问题的能力，是面向过程的程序设计方便我们编写的代码更强壮。
Vue是一款流行的开源JavaScript框架，用于构建用户界面和单页面应用程序。Vue的核心库只关注视图层，易于上手并且可以与其他库或现有项目轻松整合。
MYSQL数据库运行速度快，安全性能也很高，而且对使用的平台没有任何的限制，所以被广泛应运到系统的开发中。MySQL是一个开源和多线程的关系管理数据库系统，MySQL是开放源代码的数据库，具有跨平台性。
B/S（浏览器/服务器）结构是目前主流的网络化的结构模式，它能够把系统核心功能集中在服务器上面，可以帮助系统开发人员简化操作，便于维护和使用。
系统分析
对系统的可行性分析以及对所有功能需求进行详细的分析，来查看该系统是否具有开发的可能。 系统设计
功能模块设计和数据库设计这两部分内容都有专门的表格和图片表示。
系统实现
数码论坛系统，在系统首页可以查看首页、数码板块、数码评价、数码论坛、畅聊板块、新闻资讯、个人中心、后台管理等内容，并进行详细操作。
管理员登录系统后，可以对首页、个人中心、用户管理、分类管理、数码板块管理、数码评价管理、数码论坛管理、畅聊板块管理、系统管理等功能进行相应的操作管理。用户登录进入数码论坛系统后台可以对首页、个人中心、数码评价管理、数码论坛管理、畅聊板块管理等功能进行相应操作。
系统测试
系统测试是软件开发过程中最后一步，但也是不可或缺的重要的一步，没有人可以保证一次性编写完成的系统不会出错，而系统测试就是将自己开发的系统成为成品前的最后一步。在测试过程中需要进行严谨细致的测试，要尽可能全面地在不同情况下运行该系统，排除一切出现错误的可能。
系统测试不仅仅是发现系统潜在的BUG或错误，而更为重要的是为用户提供一个良好的体验和安全可使用的产品服务。而通过发现错误或潜在的问题，将有助于提升产品的竞争力，这也是软件测试的其中的重要目的之一。
软件测试的方法有好几种，但目前主要采用的是包括以功能为主要测试方向的黑盒测试以及以逻辑为主要测试方向的白盒测试，这是两种不同的测试方法，针对的测试侧重点不同，本课题根据实际需求情况，选择以功能为主要的黑盒测试方法，同时测试是要遵循一定的规则来执行的，一个测试要执行其执行的依据一般是由测试用例来规定的，而测试用例一般是依据需求或说明书来综合制定的，测试在硬件出厂前是十分重要的一个过程，本课题由于时间和精力的关系，选择以实现的功能作为测试要点来进行测试。
结论
通过完成该数码论坛系统和本论文的撰写让我更加明白了软件开发过程中软件工程思想的重要性。在项目的前期由于对需求分析做的不够谨慎和明确，导致了后面在设计甚至编码时候造成了许多不必要的麻烦。由此在今后的学习和工作开发之中必须要牢牢把握住软件工程的设计思想和方法，这样可以进一步保证项目开发的健壮性和准确性。
本系统所实现的是一个数码论坛系统，该系统严格按照需求分析制作相关模块，并利用所学知识尽力完成，但是本人由于学识浅薄，无法真正做到让该程序可以投入市场使用，仅仅简单实现部分功能，希望日后还能改善。
（可运行源码+sql文件+文档）
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/354/">«</a>
	<span class="pagination__item pagination__item--current">355/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/356/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>