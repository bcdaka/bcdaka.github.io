<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b4fe36085bb63db68581ed4dcd5cfff/" rel="bookmark">
			Windows环境部署AI智能聊天应用LobeChat并实现远程对话实操流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
​编辑
前言
1. LobeChat对我们有哪些帮助?
2. 本地安装LobeChat
3. 如何使用LobeChat工具
4. 安装Cpolar内网穿透
5. 实现公网访问LobeChat
6. 固定LobeChat公网地址
前言 作者简介： 懒大王敲代码，计算机专业应届生
今天给大家聊聊Windows环境部署AI智能聊天应用LobeChat并实现远程对话实操流程,希望大家能觉得实用！欢迎大家点赞 👍 收藏 ⭐ 加关注哦！💖💖 个人主页：
懒大王敲代码-CSDN博客https://blog.csdn.net/weixin_58070962?type=blog
其他专栏：
技术分享专栏http://t.csdnimg.cn/LVrbCjava专栏http://t.csdnimg.cn/bw2Thubantu与C语言学习专栏http://t.csdnimg.cn/A8yIivue3项目实战专栏http://t.csdnimg.cn/vP2no内网穿透专栏http://t.csdnimg.cn/GJZJA懒大王闲谈专栏http://t.csdnimg.cn/KxzqY
本文主要介绍如何在Windows系统电脑本地部署LobeChat，一款高颜值的开源AI大模型智能应用，并结合cpolar内网穿透工具发布至公网轻松实现多人远程访问使用体验智能聊天服务。
在当今数字化时代，人工智能技术正日益融入我们的日常生活。开源项目如 ChatGPT/LLMs 等的出现，为开发者提供了强大的聊天应用与开发框架，让人工智能变得更加普及和可定制。
其中，Lobe Chat 作为一款开源、现代化设计的聊天应用，具有许多令人青睐的特点和功能。
在 LobeChat 中将你的 AI 团队汇聚一处：根据个性化需求灵活定制智能助手功能，解决问题，提升生产, 探索未来工作模式
1. LobeChat对我们有哪些帮助? 官网地址：LobeHub - LobeChat：个人 LLM 效能工具，超越 ChatGPT / OLLaMA 使用体验
GitHub地址：跳转中...
功能介绍：
模型视觉识别
LobeChat 已经支持 OpenAI 的 gpt-4-vision、Google Gemini Pro vision、智谱 GLM-4 Vision 等具有视觉识别能力的大语言模型，这使得 LobeChat 具备了多模态交互的能力。用户可以轻松上传图片或者拖拽图片到对话框中，助手将能够识别图片内容，并在此基础上进行智能对话，构建更智能、更多元化的聊天场景。
TTS &amp; STT 语音会话
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b4fe36085bb63db68581ed4dcd5cfff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01c96383d35d6143d8c48f8034d7d73a/" rel="bookmark">
			Linux学习笔记：Linux基础知识汇总（个人复习版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用命令： 1、ls -a：显示所有文件（包括隐藏文件），简洁版
-l：显示所有文件，详细版
-R：显示所有文件以及子目录下文件，简洁版
可以搭配使用。
2、netstat -i：读出网卡收发包及出错包的统计
-s：读出各主要协议的统计
netstat -nap | grep 9999 查看端口9999是什么进程在使用
kill 4106 杀死进程
3、nslookup 查看DNS服务器是什么，把域名解析成IP地址，得到IP地址
4、打包压缩 -c 打包
-x 解包
5、解压缩 xzf——.tar.gz
xjf——.tar.bz2
6、用户加入用户组 方法一：
方法二：
或者这样也行：
7、su和sudo sudo比如：user3来执行命令
8、查看网络情况 ←其实就是看路由表
mtr：比traceroute显示得更加详细
telnet：检查对方端口是否畅通（如：80端口）
9、 sync 将数据同步写入硬盘中的指令，在关机之前输入，可以多输几次。
10、查看磁盘分区信息 使用df命令，如df -h，查看磁盘分区的挂载点、空间使用情况。-h 以更易读的方式显示。
原文链接：df命令 – 显示磁盘空间使用量情况 – Linux命令大全(手册)
使用fdisk -l查看分区挂载情况，或者查看/etc/mtab文件，然后找到最接近的挂载点信息。
使用lsblk命令，查看系统的磁盘设备使用情况。
配置服务器： 一、配置DNS服务器： 1、/etc/named.conf主配置文件
2、/var/named/x.cn.zone正向配置文件
3、/var/named/100.168.192.arpa反向解析文件
4、rndc reload
二、配置FTP服务器 1、安装vsftpd服务器
2、systemctl start vsftpd.service
3、确认安全级别允许FTP进入 或 干脆停止iptables防火墙服务
4、编辑/etc/vsftpd/vsftpd.conf
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01c96383d35d6143d8c48f8034d7d73a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ac56d2c00261900c516ef8557a581c5/" rel="bookmark">
			Spring Boot相关知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单介绍一下Spring？有什么缺点？ Spring为企业级Java开发提供了一种相对简单的方法，通过依赖注入和面向切面编程，用简单的Java对象实现了EJB的功能。
缺点：虽然Spring的组件代码是轻量级的，但他的配置却是重量级的（需要大量xml配置），除此之外，相关库的依赖、版本冲突也非常常见。
为什么要有Spring Boot？ Spring Boot旨在简化Spring的开发。
什么是Spring Boot Staters？ Spring Boot Staters是一系列依赖关系的集合，因为它的存在，项目的依赖关系对我们来说变得更加简单了。
Spring Boot支持哪些内嵌Servlet容器？ 1.Tomcat 9.0
2.Jetty 9.4
3.Undertow 2.0
@SpringBootApplication注解 @SpringBootApplication是@Configuration、@EnableAutoConfiguration、@ComponentScan注解的集合。
@Configuration：允许在上下文注册额外的Bean或导入其他配置类
@ComponentScan：扫描被@Component注解的bean，注解默认会扫描该类所在的包下所有的类
@EnableAutoConfiguration：启动SpringBoot的自动配置机制
开发RESTful Web服务常用的注解有哪些? Spring Bean相关:
@Autowired : 自动导入对象到类中，被注入进的类同样要被Spring容器管理。
@RestController : @RestControl1er注解是@Controller和@ ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直接填入HTTP响应体中,是REST风格的控制器。
@Component : 通用的注解，可标注任意类为Spring 组件。如果一个Bean不知道属于哪个层，可以使用@Component注解标注。
@Repository : 对应持久层即Dao层,主要用于数据库相关操作。
@Service :对应服务层，主要涉及一些每杂的逻辑，需要用到Dao层。
@Controller : 对应Spring MVC控制层，主要用于接受用户请求并调用Service层返回数据给前端页面。
常见的HTTP请求类型:
@Get Mapping :GET 请求
@PostMapping : POST 请求
@PutMapping : PUT请求
@DeleteMapping : DELETE 请求
前后端传值：
@RequestParam 获取查询参数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ac56d2c00261900c516ef8557a581c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95ca3ce3cbdfe54ab69694ab94bb157b/" rel="bookmark">
			SD创始团队黑马的Flux真的那强吗？SD Flux与华为ultrapixel大PK！群雄逐鹿！“百模”并起，王者之战~！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 小南还是没忍住，看大家都在试玩Flux，真的有那么震撼么？小南手痒痒也体验下吧。今天主要简单介绍下Flux以及ComfyUI的安装，重点是和我们“遥遥领先”的华为开源的ultrapixel进行下对比。没有对比就没有伤害！
大家应该对Flux也有了初步了解，但小南还是先简单介绍下。
基本介绍：
简单看了下官方介绍，Flux 是迄今为止最大的 SOTA 开源文本到图像模型，这个没毛病，确实是迄今为止最大的！
FLUX.1 [schnell]拥有 120 亿个参数的整流转换器，能够根据文本描述生成图像。
FLUX.1从模型架构上看，它和之前的SD3有很多相似之处，它们都是基于FlowingMatching调度的模型，通过引入T5来增强prompt的依从性。两者较显著的区别在于：FLUX.1引入了一种叫DoubleStreamBlock的结构，具体来说在前几层layer中，采用了txt和img embedding独立过各自的transformer块，然后再拼到一起过统一的transformer块，有人推测这是为了进一步对齐图像和文本特征，但是这部分还没有更具体的技术报告。
主要功能：
增强的图像质量：
以更高分辨率生成令人惊叹的视觉效果。
先进的人体解剖和逼真度：实现高度逼真和解剖精确的图像。
改进的及时性：根据输入获取更准确、更相关的图像。
卓越的速度：受益于 Flux Schnell 的速度和效率，是高要求应用的理想选择。
**FLUX.1三种型号：**FLUX.1 [schnell],FLUX.1 [dev],FLUX.1 [pro]
版本
链接
License
说明FLUX.1 [schnell]https://modelscope.cn/models/AI-ModelScope/FLUX.1-schnell
apache-2.0
开源且拥有非商业许可，供社区在此基础上进行构建FLUX.1 [dev]https://modelscope.cn/models/AI-ModelScope/FLUX.1-devFLUX.1-dev Non-Commercial License
基础模型的精简版，4步出图，运行速度提高了 10 倍。FLUX.1 [pro]https://replicate.com/black-forest-labs/flux-pro
闭源版本官方闭源仅可通过API访问 ComfyUI安装：
更新ComfyUI到最新版本
下载所需模型
FLUX UNET模型下载 schnell版本：
Dev版本：
建议下载fp8，小南觉得毕竟日常大家的显存都很少有超过20G以上的。fp8模型也可以在lib上下载，有人已经上传上去了，老徐也就不传了。
模型下载后存放到目录ComfyUI/models/unet/ 下。
T5文本编码模型x下载 如果你没有clip_l.safetensors 也可以一并下载，下载后存放到ComfyUI/models/clip/ 目录。
VAE模型ae.sft
ae.sft 下载后存放到ComfyUI/models/vae/目录
3.导入基本工作流
工作流可以采用导入官方图片的形式也可以直接下载相关工作流文件导入。
所有的AI设计工具，模型和插件，都已经整理好了，👇获取~
好了以上准备工作准备完成之后基本上就可以玩起来了！
如果你不想本地操作那么麻烦，也可以使用在线体验。在线体验链接：
https://huggingface.co/spaces/black-forest-labs/FLUX.1-schnell
1.写实人物：
**提示词：**A close-up portrait of a sex chinese woman with flawless skin, vibrant red lipstick, and wavy brown hair, wearing a white dress，wear sunglasses，sun helmet， and standing in beach，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95ca3ce3cbdfe54ab69694ab94bb157b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b5016972187fc120c3ba500a3564953/" rel="bookmark">
			vue3-print-nb 表格打印分页，第一页有空白的情况出现解决方法（两种：一种原生，一种基于element表格）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种：基于element表格分页
&lt;template&gt; &lt;!-- element分组打印 --&gt; &lt;div class="hello"&gt; &lt;button v-print="printContent"&gt;打印&lt;/button&gt; &lt;div id="printDiv"&gt; &lt;p&gt;工资统计表&lt;/p&gt; &lt;p&gt; &lt;span&gt;单据日期：2024-08-04 00：00：00&lt;/span&gt; &lt;span&gt;年份：2024&lt;/span&gt; &lt;span&gt;月份：8月份&lt;/span&gt; &lt;span&gt;项目: 山东远大新能源科技有限公司&lt;/span&gt; &lt;/p&gt; &lt;div v-for="(item, index) in tableData" :key="`${index}`"&gt; &lt;el-table :data="item.tableData" stripe style="width: 100%"&gt; &lt;el-table-column prop="code" label="序号" width="180" /&gt; &lt;el-table-column prop="name" label="姓名" width="180" /&gt; &lt;el-table-column prop="key1" label="日工考勤" /&gt; &lt;el-table-column prop="key2" label="日工工资" /&gt; &lt;el-table-column prop="key3" label="承包考勤" /&gt; &lt;el-table-column prop="key4" label="承包工资" /&gt; &lt;el-table-column prop="key5" label="回程路费" /&gt; &lt;el-table-column prop="key6" label="应扣项" /&gt; &lt;el-table-column prop="key7" label="借款" /&gt; &lt;el-table-column prop="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b5016972187fc120c3ba500a3564953/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5543c96fa1e09bbd1472f1de7ad17fa5/" rel="bookmark">
			IAP程序升级 与 电脑BIOS 的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IAP (In-Application Programming) 程序升级 IAP程序升级是一种技术，允许设备在运行过程中更新其自身的固件或软件，而不需要外部工具或设备的介入。这种技术特别适用于嵌入式系统和物联网（IoT）设备。其主要由三部分构成，分别是bootloader，固件分区，通信接口。Bootloader负责检测和加载正确的固件分区，以及管理固件更新过程。固件分区通常包括主固件区、备用固件区等，用于存储当前运行的固件和新版本固件。通信接口用于接收新固件数据，例如通过串口、USB、以太网等。
电脑BIOS (Basic Input/Output System) 百度百科解释（bios_百度百科 (baidu.com)）：
BIOS是英文"Basic Input Output System"的缩略词，直译过来后中文名称就是"基本输入输出系统"。在IBM PC兼容系统上，是一种业界标准的固件接口。 [1]BIOS这个字眼是在1975年第一次由CP/M操作系统中出现。 [2]BIOS是个人电脑启动时加载的第一个软件。
其实，它是一组固化到计算机内主板上一个ROM芯片上的程序，它保存着计算机最重要的基本输入输出的程序、开机后自检程序和系统自启动程序，它可从CMOS中读写系统设置的具体信息。 其主要功能是为计算机提供最底层的、最直接的硬件设置和控制。此外，BIOS还向作业系统提供一些系统参数。系统硬件的变化是由BIOS隐藏，程序使用BIOS功能而不是直接控制硬件。现代作业系统会忽略BIOS提供的抽象层并直接控制硬件组件。当今，此系统已成为一些病毒木马的目标。一旦此系统被破坏，其后果不堪设想。
二者关系 IAP程序升级和BIOS更新虽然在应用场景和固件性质上有明显的区别，但它们都属于固件更新的范畴。IAP程序升级更侧重于嵌入式设备的自我更新能力，而BIOS更新则是针对个人电脑和服务器系统的固件更新。两者在更新流程和技术原理上有一些相似之处，但也各有特点。
不论是嵌入式设备中带有微控制器（MCU）的设备，还是家用笔记本电脑中带有中央处理器（CPU）的设备，二者在组成方式上都需要软件和硬件的紧密配合。原始生产的闪存（Flash）并不包含任何程序，因此如果我们想要在其上编写代码，面临的首要问题是如何将程序写入到Flash中。
许多人可能认为直接下载或烧录代码是理所当然的事情，但实际上，我们需要一段引导程序（Bootloader）来帮助我们将程序下载到Flash中。在很多情况下，大多数芯片在出厂时就已经内置了这部分引导程序，所以我们才能够自然而然地在芯片上编写我们的代码。
引导程序（Bootloader）是一种特殊的程序，它负责启动过程以及检测和加载正确的固件分区。在嵌入式系统中，Bootloader通常负责固件更新，而在家用笔记本电脑中，BIOS或UEFI则承担了类似的职责。刚出厂的Flash芯片通常是空白的，不包含任何程序代码，为了将程序写入Flash，我们通常需要通过串口、USB、以太网等通信接口将新固件数据传输到设备上。许多现代芯片在出厂时就已经预装了一段Bootloader程序，使得用户可以直接通过简单的命令行工具或图形界面工具来更新固件。对于一些支持IAP（In-Application Programming）的设备，Bootloader还能够帮助设备自我更新，即在设备运行过程中更新其固件或软件。
例如，一个基于STM32微控制器的物联网设备，其Bootloader可以内置在芯片中，允许用户通过串口或USB接口上传新的固件。一台笔记本电脑的BIOS可以被更新以支持新的硬件特性或修复已知的问题。
无论是嵌入式设备还是家用笔记本电脑，它们都需要引导程序的帮助来完成程序或固件的初始加载和后续更新。引导程序在出厂时往往已经内置在设备中，这使得用户能够轻松地进行固件更新而不必深入了解底层细节。对于支持IAP的设备，引导程序还能够实现自我更新的能力，进一步简化了维护过程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c778eb3cd5e218b11de02d7f62369028/" rel="bookmark">
			【数据结构】哈希表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.前言 我们前面学习了二叉搜索树的相关操作、Map和Set的使用，今天继续跟大家分享数据结构中的哈希表相关知识，让我们一起进入数据结构的世界，探索哈希表的奥秘！
2.哈希表 2.1概念 顺序结构以及平衡树中，元素关键码与其存储位置之间没有对应的关系，因此在查找一个元素时，必须要经过关键码的多次比较。顺序查找时间复杂度为O(N)，平衡树中为树的高度，即O(log₂N)，搜索的效率取决于搜索过程中元素的比较次数。 理想的搜索方法：可以不经过任何比较，一次直接从表中得到要搜索的元素。 如果构造一种存储结构，通过某种函数(hashFunc)使元素的存储位置与它的关键码之间能够建立一一映射的关系，那么在查找时通过该函数可以很快找到该元素。 当向该结构中： 插入元素 根据待插入元素的关键码，以此函数计算出该元素的存储位置并按此位置进行存放。
搜索元素 对元素的关键码进行同样的计算，把求得的函数值当做元素的存储位置，在结构中按此位置取元素比较，若关键码相等，则搜索成功。 该方式即为哈希 ( 散列 ) 方法， 哈希方法中使用的转换函数称为哈希 ( 散列 ) 函数，构造出来的结构称为哈希表 (Hash Table)( 或者称散列表 ) 例如：数据集合 {1 ， 7 ， 6 ， 4 ， 5 ， 9} ； 哈希函数设置为： hash(key) = key % capacity ; capacity 为存储元素底层空间总的大小。 用该方法进行搜索不必进行多次关键码的比较，因此搜索的速度比较快。
2.2冲突-概念 对于两个数据元素的关键字 ki 和 k(j)，有ki != kj，但有：Hash(ki) == Hash(kj)，即：不同关键字通过相同哈希函数计算出相同的哈希地址，该现象称为哈希冲突或哈希碰撞。
因此我们把具有不同关键码而具有相同哈希地址的数据元素称为“同义词”。
2.3冲突-避免 我们需要明确一点，由于我们哈希表底层数组的容量往往是小于实际要存储的关键字的数量的，这就导致一个问题， 冲突的发生是必然的 ，但我们能做的应该是尽量的 降低冲突率 。 2.3.1哈希函数设计 引起哈希冲突的一个原因可能是：哈希函数设计不够合理。哈希函数设计原则：
哈希函数的定义域必须包括需要存储的全部关键码，而如果散列表允许有m个地址时，其值域必须在0到m-1之间。哈希函数计算出来的地址能均匀分布在整个空间中 哈希函数应该比较简单。 常见哈希函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c778eb3cd5e218b11de02d7f62369028/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2411e5ef551ccb0c716d4ed23ba417c9/" rel="bookmark">
			Spring Boot实战：拦截器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.拦截器快速入门 1.1了解拦截器 什么是拦截器：
概念 ：拦截器是Spring框架提供的核⼼功能之⼀, 主要⽤来拦截⽤⼾的请求, 在指定⽅法前后, 根据业务需要执⾏预先设定的代码。 也就是说, 允许开发⼈员提前预定义⼀些逻辑, 在⽤⼾的请求响应前后执⾏. 也可以在⽤⼾请求前阻⽌其执⾏. 在拦截器当中，开发⼈员可以在应⽤程序中做⼀些通⽤性的操作, ⽐如通过拦截器来拦截前端发来的请求, 判断Session中是否有登录⽤⼾的信息. 如果有就可以放⾏, 如果没有就进⾏拦截. 想象一下你去一个需要门禁的办公楼，拦截器就像是那个门禁系统。当你（请求）想要进入办公楼（访问某个资源）时，门禁系统（拦截器）会先检查你是否符合条件（比如是否持有有效的门禁卡或是否已经通过身份验证）。如果符合条件，门禁系统会放行，让你进入办公楼；如果不符合条件，门禁系统会阻止你进入，并可能要求你进行其他操作（比如登记或联系相关人员）。
在SpringBoot中，拦截器就是这样一种机制，它可以在请求到达控制器之前或之后“拦截”请求，并根据预定义的规则对请求进行处理。
拦截器在SpringBoot中主要有以下几个作用：
身份验证和权限控制： 就像门禁系统检查门禁卡一样，拦截器可以检查用户的身份验证状态和权限。例如，当用户尝试访问一个需要登录才能查看的页面时，拦截器会检查用户是否已经登录。如果用户未登录，拦截器可以重定向用户到登录页面或返回错误信息。日志记录： 拦截器可以在请求到达控制器之前或之后记录日志信息。这对于监控和调试应用程序非常有用，因为它可以帮助你了解请求是如何被处理的，以及处理过程中发生了哪些事情。请求预处理和响应后处理： 在请求到达控制器之前，拦截器可以对请求进行预处理，比如修改请求参数、设置请求头等。在控制器处理完请求并生成响应后，拦截器还可以对响应进行后处理，比如修改响应头、添加额外的数据到响应中等。异常处理： 拦截器还可以捕获并处理请求处理过程中发生的异常。例如，如果控制器在处理请求时抛出了异常，拦截器可以捕获这个异常，并根据异常类型进行相应的处理，比如返回自定义的错误页面或错误信息。 1.2拦截器的基本使用
拦截器的使⽤步骤分为两步： 定义拦截器 注册配置拦截器 1.⾃定义拦截器：实现HandlerInterceptor接⼝，并重写其所有⽅法
@Slf4j @Component public class LoginInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { log.info("LoginInterceptor ⽬标⽅法执⾏前执⾏.."); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2411e5ef551ccb0c716d4ed23ba417c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6b94482fc7d2c59fcf181d663441fb9/" rel="bookmark">
			基于C#调用文心一言大模型制作桌面软件(可改装接口)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 开发前的准备账号注册应用创建应用接入 开始开发创建项目设计界面使用 AK，SK 生成鉴权签名窗体代码 百度智能云千帆大模型平台什么是百度智能云千帆大模型平台模型更新记录 开发前的准备 账号注册 访问百度智能云平台，通过百度账号登录或手机号验证。
点此跳转百度智能云平台
应用创建 登录成功后看到的是一个控制台总览的页面，在页面上方文本框搜索千帆大模型，点击跳转。
应用接入 左侧点击应用接入，并在该页完成应用创建。
在应用配置这一项，可以勾选全部服务。
这里保留好API Key 和 Secret Key两个凭证，后面开发的时候用得上。
开始开发 创建项目 通过vs创建Windows窗体应用。
设计界面 在form界面，打开工具箱，这里用默认的控件就可以实现。
label、textBox、button、richTextBox。
使用 AK，SK 生成鉴权签名 通过NuGet包管理器安装RestSharp包，我这里的版本是106.2.0，该包用于发送https请求。
/** * 使用 AK，SK 生成鉴权签名（Access Token） * @return 鉴权签名信息（Access Token） */ public static string GetAccessToken(string API_KEY,string SECRET_KEY) { var url = "https://aip.baidubce.com/oauth/2.0/token"; var client = new RestClient(url); client.Timeout = -1; var request = new RestRequest(Method.POST); request.AddParameter("grant_type", "client_credentials"); request.AddParameter("client_id", API_KEY); request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6b94482fc7d2c59fcf181d663441fb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e6a70d4983a06ec87846524cb1f00ed/" rel="bookmark">
			【Git企业级开发实战指南②】分支管理、远程操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、分支管理1.1理解分支1.2创建分支1.3切换分支1.4合并分支1.5删除分支1.6合并冲突1.7 分支管理策略1.7.1分支策略 1.8bug分支1.9删除临时分支 二、远程操作2.1理解分布式版本控制系统2.2 远程仓库2.2.1 新建远程仓库2.2.2 克隆远程仓库2.2.3向远端仓库推送2.2.4拉取远端仓库 2.3配置Git 2.4 命令配置别名🍀小结🍀 🎉博客主页：.小智
🎉欢迎关注：👍点赞🙌收藏✍️留言
🎉系列专栏：Git企业级开发教程
🎉代码仓库：小智的代码仓库
一、分支管理 1.1理解分支 想象你正在写一本书，这本书的每一页都代表着你项目的一个版本。在Git中，每当你创建一个分支，实际上就是在书中创建了一本副本，你可以在副本中进行任何修改，而主版本则保持原样。
假设你的书的主版本（分支）是master，表示当前的最终版本。现在，你需要写一个新的章节，但你不确定这个章节是否会被最终采纳。为了安全起见，你创建了一个名为feature-chapter的新分支。
在feature-chapter分支上，你可以尽情地写你的新章节，而不用担心影响到主版本（master分支）。你可以随意增删改这个章节的内容，直到你满意为止。
如果你在写作过程中发现有一些错别字需要更正，你可以在feature-chapter分支上进行修改，而不会影响到master分支的内容。这就好比在新分支中进行修正，不影响到书的主体内容。
当你完成了新章节的写作，并且对其内容进行了完善，你可以将feature-chapter分支合并回master分支。这就好比将你的新写作整合到书的主体中，使得所有读者都可以看到你的最新内容。
最后，一旦新章节被整合到了master分支中，你可以删除feature-chapter分支，因为它的使命已经完成了。这就好比在完成编辑后将草稿丢弃或者存档，因为它的内容已经被整合到了正式版本中。
通过这个例子能够帮助理解Git中分支的概念：它允许你在不影响到主要项目版本的情况下进行并行开发和测试，确保你的修改在准备好之后再与主要项目整合。
主分支（通常是master）是项目的主要时间线。HEAD是指向当前所在分支的指针，它可以让你知道当前在哪个分支上工作。
每次提交，master都会向后移动一步、这样，不断随着我们的提交，master分支的线也越来越长，而HEAD只要一直指向master分支即可指向当前分支。 1.2创建分支 Git支持我们查看或创建别的分支，我们可以自己创建一个dev分支：
ubuntu@xiaozhi:~/Desktop/gitcode$ git branch	#查看当前本地所有分支 * master ubuntu@xiaozhi:~/Desktop/gitcode$ git branch dev #创建新的分支 dev ubuntu@xiaozhi:~/Desktop/gitcode$ git branch dev * master 创建好分支之后*表示当前HEAD指向的是master分支。
ubuntu@xiaozhi:~/Desktop/gitcode$ ls .git/refs/heads/ dev master ubuntu@xiaozhi:~/Desktop/gitcode$ cat .git/refs/heads/* 5c846bddb4d0afc3372d2de7a0b03dd490457b76 5c846bddb4d0afc3372d2de7a0b03dd490457b76 ubuntu@xiaozhi:~/Desktop/gitcode$ cat .git/HEAD ref: refs/heads/master 两个分支指向同一个修改，但是HEAD还是指向的master分支。
画图总结：
1.3切换分支 可以使用git checkout命令来切换当前分支
ubuntu@xiaozhi:~/Desktop/gitcode$ git checkout dev #切换到dev 切换到分支 'dev' ubuntu@xiaozhi:~/Desktop/gitcode$ git branch #查看当前分支 * dev master ubuntu@xiaozhi:~/Desktop/gitcode$ cat .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e6a70d4983a06ec87846524cb1f00ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88a14281821d495c961ee26550f574ef/" rel="bookmark">
			笔记本CPU天梯图（2024年8月），含AMD/骁龙等新CPU
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址（高清无水印原图/持续更新/含榜单出处链接）： 2024年8月笔记本CPU天梯图
2024年8月笔记本CPU天梯图 2024年8月5日更新日志：常规更新Cinebench R23、PassMark笔记本CPU天梯图，新增Geekbench 6.2单核多核天梯图（Notebookcheck ）；移除鲁大师天梯图。
----------手动分割线----------
2024年7月17日更新日志：常见的快科技，超能网咱们就不再赘述，有需要直接度娘搜。咱们来分享点更专业的，如Cinebench R23以及PassMark性能测试。当然，娱乐大师笔记本CPU天梯图放在最后出场。
Ps：由于太多出站链接有可能被ban，以下榜单出处链接请至原文地址处查看。
PPs：以下榜单只含笔记本/移动设备，完整版CPU天梯榜请看：2024年8月CPU天梯图，多标准多渠道CPU性能榜单
Cinebench R23 2024年8月笔记本CPU天梯图 Ps：该榜单非完整版且排序依据为单核跑分（包含HX370、365、骁龙 X Elite）；如需完整版或以其它依据排序请访问原地址。
榜单出处链接（原图/快速查找/比较）请至文章顶部原文地址访问
PassMark 2024年8月笔记本CPU性能天梯图 Ps：CPU Mark排行榜比较直观，包含HX370、365、骁龙 X Elite，但同样由于篇幅原因并非完整版，完整版请至末尾链接处访问。
榜单出处链接（原图/快速查找/比较）请至文章顶部原文地址访问
Geekbench 6.2 2024年8月CPU单核多核天梯图 Ps：由国外知名硬件媒体Notebookcheck整理发布的笔记本CPU排名，这里仅选择了GB6.2选项作为参考（包含HX370、365、骁龙 X Elite）。
榜单出处链接（原图/快速查找/比较）请至文章顶部原文地址访问
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f017472bb923511f7f91846c591d515e/" rel="bookmark">
			＜数据集＞灭火器识别数据集＜目标检测＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据集格式：VOC+YOLO格式
图片数量：3262张
标注数量(xml文件个数)：3262
标注数量(txt文件个数)：3262
标注类别数：1
标注类别名称：['extinguisher']
使用标注工具：labelImg
标注规则：对类别进行画水平矩形框
图片示例：
标注示例：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ac5b1b88547a7d8a751650fb5332b3c/" rel="bookmark">
			遗传算法与深度学习实战——生命模拟及其应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遗传算法与深度学习实战——生命模拟及其应用 0. 前言1. 康威生命游戏1.1 康威生命游戏的规则1.2 实现康威生命游戏1.3 空间生命和智能体模拟 2. 实现生命模拟3. 生命模拟应用小结系列链接 0. 前言 生命模拟是进化计算的一个特定子集，模拟了自然界中所观察到的自然过程，例如粒子或鸟群的聚集方式。生命模拟只是用来探索和优化问题的模拟形式之一，还有很多其他形式的模拟，可以更好地建模各种过程，但它们都源于康威生命游戏 (Conway’s Game of Life)。在本节中，我们将介绍生命模拟的基本概念，并使用 Python 实现康威生命游戏。
1. 康威生命游戏 生命游戏是由约翰·霍顿·康威 (John Horton Conway) 于 1970 年开发的一种简单的细胞自动机；这个“游戏”被认为是计算机模拟的起源。虽然模拟的规则很简单，但它的确能够得到优雅的图案和表现形式。
1.1 康威生命游戏的规则 康威生命游戏之所以优雅，归结于用于模拟细胞生命的规则的简洁性。使用以下四个简单的规则模拟细胞的生命周期：
任何活细胞如果周围少于两个存活邻居，则会死亡(因为人口稀少)任何活细胞如果周围有两个或三个存活邻居，则会存活到下一代任何活细胞如果周围有多于三个存活邻居，则会死亡(因为人口过剩)任何死细胞如果周围恰好有三个存活邻居，则会变成一个活细胞(因为繁殖) 1.2 实现康威生命游戏 使用 Python 实现康威生命游戏：
import glob import io import base64 from IPython.display import HTML from IPython import display as ipythondisplay import matplotlib.pyplot as plt def show_video(): mp4list = glob.glob('*.mp4') if len(mp4list) &gt; 0: mp4 = mp4list[0] video = io.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ac5b1b88547a7d8a751650fb5332b3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf8176cd63f6fc7ae5fd51fde3caa6c1/" rel="bookmark">
			二次注入（2018网鼎杯comment）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、2018网鼎杯comment
1.二次注入概念：
2.进入靶机：
4. Burp Suite暴力破解
5.对文件进行恢复，查看源码
6.二次注入
7.成功拿到flag
一、2018网鼎杯comment 该题主要考察二次注入
1.二次注入概念： 攻击者构造恶意的数据并存储在数据库后，恶意数据被读取并进入到SQL查询语句所导致的注入。防御者可能在用户输入恶意数据时对其中的特殊字符进行了转义处理，但在恶意数据插入到数据库时被处理的数据又被还原并存储在数据库中，当Web程序调用存储在数据库中的恶意数据并执行SQL查询时，就发生了SQL二次注入。即输入恶意的数据库查询语句时会被转义，但在数据库调用读取语句时又被还原导致语句执行。
进入网站：BUUCTF在线评测
搜索comment
2.进入靶机： 4. Burp Suite暴力破解 点击发布，会出现登陆界面
此时密码后三位被隐藏，我们可以使用Burp Suite中的Intruder模块进行暴力破解 根据长度判断后三位正确密码为666，得到密码后返回登陆界面，进入靶机。 5.对文件进行恢复，查看源码 通过对目录进行扫描，发现存在git泄露，通过githacker工具将文件恢复一下，得到源码。
//write_do.php
&lt;?php
include "mysql.php";
session_start();
if($_SESSION['login'] != 'yes'){
header("Location: ./login.php");
die();
}
if(isset($_GET['do'])){
switch ($_GET['do'])
{
case 'write':
$category = addslashes($_POST['category']);
$title = addslashes($_POST['title']);
$content = addslashes($_POST['content']);
$sql = "insert into board
set category = '$category',
title = '$title',
content = '$content'";
$result = mysql_query($sql);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf8176cd63f6fc7ae5fd51fde3caa6c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa414861daaa91d830ed97b30dd361bb/" rel="bookmark">
			手撕数据结构之二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.树 树的基本概念与结构 树是⼀种⾮线性的数据结构，它是由 n（n&gt;=0） 个有限结点组成⼀个具有层次关系的集合。把它叫做树是因为它看起来像⼀棵倒挂的树，也就是说它是根朝上，⽽叶朝下的。
• 有⼀个特殊的结点，称为根结点，根结点没有前驱结点。
• 除根结点外，其余结点被分成 M(M&gt;0) 个互不相交的集合 T1、T2、……、Tm ，其中每⼀个集合Ti(1 &lt;= i &lt;= m) ⼜是⼀棵结构与树类似的⼦树。每棵⼦树的根结点有且只有⼀个前驱，可以有 0 个或多个后继。因此，树是递归定义的。
下面的A就是根节点，没有前驱节点的
非树形结构：
• ⼦树是不相交的（如果存在相交就是图了，图以后得课程会有讲解）
• 除了根节点外，每个节点有且仅有一个父节点
• 一棵N个节点的数有N-1条边
树相关术语 2.二叉树 •⽗结点/双亲结点：若⼀个结点含有⼦结点，则这个结点称为其⼦结点的⽗结点； 如上图：A是B的⽗结点
•⼦结点/孩⼦结点：⼀个结点含有的⼦树的根结点称为该结点的⼦结点； 如上图：B是A的孩⼦结点•结点的度：⼀个结点有⼏个孩⼦，他的度就是多少；⽐如A的度为6，F的度为2，K的度为0
•树的度：⼀棵树中，最⼤的结点的度称为树的度； 如上图：树的度为 6
•叶⼦结点/终端结点：度为 0 的结点称为叶结点； 如上图： B、C、H、I… 等结点为叶结点
•分⽀结点/⾮终端结点：度不为 0 的结点； 如上图： D、E、F、G… 等结点为分⽀结点
•兄弟结点：具有相同⽗结点的结点互称为兄弟结点(亲兄弟)； 如上图： B、C 是兄弟结点
•结点的层次：从根开始定义起，根为第 1 层，根的⼦结点为第 2 层，以此类推；
•树的⾼度或深度：树中结点的最⼤层次； 如上图：树的⾼度为 4
•结点的祖先：从根到该结点所经分⽀上的所有结点；如上图： A 是所有结点的祖先
•路径：⼀条从树中任意节点出发，沿⽗节点-⼦节点连接，达到任意节点的序列；⽐如A到Q的路径为： A-E-J-Q；H到Q的路径H-D-A-E-J-Q
•⼦孙：以某结点为根的⼦树中任⼀结点都称为该结点的⼦孙。如上图：所有结点都是A的⼦孙
•森林：由 m（m&gt;0） 棵互不相交的树的集合称为森林；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa414861daaa91d830ed97b30dd361bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06cea2e52641cb0a202717f0f61990d9/" rel="bookmark">
			“5G&#43;Windows”推动全场景数字化升级：美格智能5G智能模组SRM930成功运行Windows 11系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作系统作为连接用户与数字世界的桥梁，在数字化迅速发展的时代扮演着至关重要的角色，智能设备与操作系统的协同工作，成为推动现代生活和商业效率的关键力量。其中，Windows系统以其广泛的应用基础和强大的兼容性成为全球最广泛使用的操作系统之一，为无数用户提供了高效、便捷的工作与生活体验。
近期，美格智能研发团队在5G智能模组SRM930上成功运行Windows 11系统，实现Android、Linux、Windows三大系统的全面覆盖，帮助更多智能终端客户快速迭代产品，覆盖更加全面的智能终端应用场景。
从移动办公到远程协作，从车载系统到智能穿戴，“5G+Windows”的强势组合将带来全新的生产方式和生活方式，推动各领域数字化转型升级。
SRM930系列模组基于高通5G SoC QCM6490平台开发。搭载8核KryO CPU，Adreno 635 GPU，综合AI算力超过12 Tops，在多任务场景下拥有出色表现；采用先进的6nm制造工艺，先进的制程带来了更低的功耗，适用于各类户外和移动场景；在通信方面支持5G NR SUb-6GhZ，DL4x4 MIMO SA/NSA mode and UL 1 x1 MIMO SA mode，2X2 MIMO Wi-Fi 6E，支持5G独立组网和非独立组网，可覆盖全球主流运营商的网络频段。
凭借性能上的卓越表现与Windows 11系统强大的处理能力，SRM930能够快速处理大量的计算任务，为用户提供更加丰富、多样化，更加流畅、高效的使用体验。预计在2024年底，QCM6490 Windows IoT软件计划将支持5G，敬请期待。
此外，SRM930同步支持双屏异显，拥有出色的高清视频处理能力，最高支持4K@30fps视频编码或4K@60fps视频解码，集成L1+L5 GNSS 双频定位，满足不同环境下快速、精准定位的需求。可广泛应用于5G视频记录仪、智能POS收银机、物流终端、视频监控、智能信息采集设备、智能手持终端等领域。
无论是在复杂的工业现场，还是在需要快速响应的商业环境中，SRM930都能提供稳定可靠的服务。此外，SRM930的紧凑设计和灵活的接口选项搭配Windows 11系统良好的拓展性和功能接口，使其能够轻松快速地集成到各种设备中，帮助智能终端客户快速迭代产品、开发新品，满足不同客户的需求。
如在工业平板电脑领域，SRM930能够满足产品在通信能力、边缘计算能力以及产品功能定制等多方面的需求，节约开发时间和成本；同时，Windows系统更加直观便捷的操作方式和更加全面的安全防护，能够大幅降低产品的使用门槛，提升数据安全，帮助快速抢占市场。
随着社会数字化升级的不断推进，5G智能模组的重要性愈发凸显，“5G+Windows”的强势组合将在智能制造、智慧城市建设、自动驾驶、远程医疗等众多领域发挥更加关键的作用，将成为推动社会进步和创新的重要力量。
未来，美格智能将不断加强技术创新，竭尽全力为客户提供更加高速、稳定、大容量且更加智能的产品及解决方案，我们期待与所有伙伴一起，探索5G智能模组的无限可能，共同开启万物互联的新篇章。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a88532e71cec786c5d18a4667151e599/" rel="bookmark">
			Django、Flask和FastAPI的优缺点与适用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Django特点与适用场景： 简介 Django是一个全功能的Web框架，提供了大量内置功能，如ORM（对象关系映射）、认证系统、管理后台等。
优缺点 优点 全功能性： 内置了许多功能，适合开发大型应用。
ORM支持： 提供强大的ORM系统，简化数据库操作。
自带管理后台： 内置了强大的管理后台，方便管理数据。
缺点 较大的学习曲线： 对初学者来说，Django的学习曲线相对较大。
灵活性较低： 由于内置功能较多，可能在一些定制化需求上灵活性较低。
适用场景 适用于大型项目，尤其是需要快速开发和内置功能的企业级应用。
Flask的特点与适用场景： 简介 Flask是一个轻量级的Web框架，提供了基本的工具，并允许开发者选择适合自己项目的扩展。
优缺点 优点 轻量级： 框架本身轻量，但支持使用扩展构建复杂的应用。
灵活性： 提供更大的灵活性，开发者可以根据项目需求选择使用的组件
缺点 缺少一些内置功能： 相对于Django，一些功能需要通过扩展实现。
适用于中小型项目： 对于大型企业级应用，可能需要更多的手动配置。
适用场景 适用于中小型项目，对灵活性和扩展性有较高要求的应用。
FastAPI的特点与适用场景： 简介 FastAPI是一个现代、快速（通过使用Starlette和Pydantic）的Web框架，专注于快速构建API。
优缺点 优点 性能卓越： 基于Starlette和Pydantic，具有出色的性能。
自动文档生成： 自动生成交互式API文档，提高开发效率。
异步支持： 支持异步请求处理，适用于高并发场景。
缺点 相对年轻： 相对于Django和Flask，FastAPI相对年轻，生态系统可能不如另两者成熟。
适用场景 适用于构建API，特别是对性能和异步处理有要求的应用场景，如高并发的实时应用。
项目如何选择 项目规模 大型项目： Django提供了完整的功能集，适合大型应用的快速开发。
中小型项目： Flask和FastAPI灵活轻巧，适用于中小型项目。
学习曲线 初学者： Flask相对较易上手，适合初学者入门。
经验丰富者： Django和FastAPI提供了更多高级特性，适合有经验的开发者。
生态系统 生态系统成熟： Django的生态系统最为成熟，Flask次之，FastAPI相对年轻。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdbced16af99e7c59894297e018f7d3a/" rel="bookmark">
			Map缓存token
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Map缓存Token 记录过期时间
public String getToken() { AccessTokenSingleton atsl = AccessTokenSingleton.getInstance(); Map&lt;String, String&gt; map = atsl.getMap(); String accessToken = map.get("access_token"); String time = map.get("time"); Long nowDate = new Date().getTime(); if (null != accessToken &amp;&amp; null != time &amp;&amp; nowDate - Long.parseLong(time) &lt; 7200000) { log.error("look time：" + time + "; [北森] access_token" + accessToken); // 从缓存中读取accessToken数据 return accessToken; } else { System.out.println("到期"); // 获取token String tokenUrl = "https://get/token"; Map&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;(); params.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdbced16af99e7c59894297e018f7d3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0bc2b443ffaf434e662e6d4886ef6fb/" rel="bookmark">
			Go语言log库学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 日志记录Testing 日志记录 log库：https://go-zh.org/pkg/log/
syslog:https://go-zh.org/pkg/log/syslog/
基本的日志功能：支持日志消息的输出，包括通过log.Print、log.Printf、log.Println等函数记录普通日志，以及通过log.Fatal、log.Fatalf、log.Fatalln、log.Panic、log.Panicf、log.Panicln等函数在记录日志后执行特定操作（如程序终止或panic）。日志输出位置：默认情况下，log包的日志输出位置是标准错误输出（stderr）。但可以通过log.SetOutput函数将日志输出重定向到其他位置，如文件或自定义的日志处理器。日志格式和前缀：支持自定义日志消息的前缀和时间格式。通过log.SetPrefix函数可以设置日志消息的前缀，通过log.SetFlags函数可以设置时间格式，如日期、时间、微秒级时间、文件名和行号等。并发安全：log包本身是并发安全的，可以在多个goroutine中安全地使用。 func main() { file, err := os.OpenFile("app.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666) if err != nil { log.Fatal(err) } defer file.Close() // 输出到文件 log.SetOutput(file) log.Println("This is a log message written to a file") // 自定义格式 log.SetPrefix("INFO: ") log.SetFlags(log.Ldate | log.Ltime | log.Lshortfile) log.Println("This is a log message with custom prefix and flags") } // 不支持同时输出到文件且输出到控制台 // 所以可以这样做： package main import ( "log" "os" ) // 测试log同时写入控制台和文件 func multiLogger(fileLogger, stdLogger *log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0bc2b443ffaf434e662e6d4886ef6fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ce6d416138825e5a721c0e0f70fe65b/" rel="bookmark">
			.NET Core 中使用异步编程和队列RabbitMQ及错误处理机制处理电子邮件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 .NET Core 中处理电子邮件，可以使用类似的技术和库来发送和接收电子邮件。以下是一些高效处理电子邮件的解决方案和最佳实践，适用于 .NET Core 环境：
目录
1. 使用 SMTP 发送电子邮件
2. 使用 MailKit 发送和接收电子邮件
3. 异步处理电子邮件
4. 处理大型邮件队列
5. 错误处理和重试机制
6. 总结
1. 使用 SMTP 发送电子邮件 .NET Core 中，可以使用 System.Net.Mail 命名空间中的 SmtpClient 类来发送电子邮件。
首先，确保项目文件（.csproj）中包含对 System.Net.Mail 的引用：
&lt;ItemGroup&gt; &lt;PackageReference Include="System.Net.Mail" Version="4.7.0" /&gt; &lt;/ItemGroup&gt; 然后，可以使用以下代码发送电子邮件：
using System.Net; using System.Net.Mail; using System.Threading.Tasks; public async Task SendEmailAsync(string to, string subject, string body) { var fromAddress = new MailAddress("your-email@example.com", "Your Name"); var toAddress = new MailAddress(to); const string fromPassword = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ce6d416138825e5a721c0e0f70fe65b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/75/">«</a>
	<span class="pagination__item pagination__item--current">76/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/77/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>