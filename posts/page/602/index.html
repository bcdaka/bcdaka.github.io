<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11fc0bb771ba19d37c92766aa9c2cfda/" rel="bookmark">
			前端遇到302处理方式以及设置第三方Cookie研究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端遇到302处理方式以及设置第三方Cookie研究 1、如何解决后端302重定向问题 背景：由于认证中心网关检测到用户是未登录态情况下的话，会将用户重定向到认证中心的登录页。 ​ 此时，假如是使用Oauth2协议，登录成功后，前端需要带着登录成功的信息（jwt），访问/Oauth2/1/authorize接口，此时该接口将会重定向回redirect_uri的地址，这个时候的重点在于如何访问/Oauth2/1/authorize接口。
我们列举一下几种请求方式：
AjaxFetchLocation.hrefForm表单Nvigator.sendBeacon 技术特点是否可用Ajax（XMLHttpRequest ）不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容，捕获不到302状态码，并且假如后端响应头的Location返回的路径与Ajax的Referer不一致的话，会产生跨域报错。×Fetch针对 302 的情况，其实 fetch 有个特殊的配置叫 redirect，可以捕获302的部分内容。但是非常可惜的是，目前 response 的内容非常有限，仅能捕获到该接口访问是否存在302，捕获不到302的具体跳转路径，并且也不能跟随跳转。×Location.href浏览器地址直接跳转接口，默认采用Get请求，不存在跨域问题，浏览器也可以直接跟随后端产生的302重定向。√Form表单通过刷新整个页面进行访问请求，可使用Get/Post方法，也可以跟随后端进行的302跳转，缺点是需要新建一个表单，操作比较复杂。√Nvigator.sendBeaconnavigator.sendBeacon() 方法可用于通过 HTTP POST 将少量数据异步传输到 Web 服务器。同时避免了用传统技术（如：XMLHttpRequest）发送分析数据的一些问题。缺点是仅支持POST请求，以及是异步操作，也不跟随后端302。√ 根据以上方式做一个测试：
我们做一个302重定向的接口，重定向的路径是分别为http://localhost:3000/login和https://www.baidu.com,客户端的域名为localhost,情况如下图：
假如采用常用的Ajax，例如Axios或者Fetch,前端代码以及效果如下：
1、Axios：当点击按钮时候，调用/redirectTo接口，后端返回302重定向，此时我们可以看到，重定向后的地址并不是按照预期在浏览器上跳转，而是重新用XHR请求重定向之后的地址，此时由于接口请求头的Referer为localhost:3000与RequestURL:https:www.baidu.com存在跨域问题，故报错。 那假如后端返回重定向的地址不存在跨域问题呢（此时和客户端同域）？ ​ 此时虽然不存在跨域问题了，但是重定向后的地址因为是使用XHR访问的，然而你客户端并没有开启Servlet等服务，故接口会返回404NotFound。
综上所述，使用Ajax处理302是行不通的。 2、采用Fetch,网上对于fetch众说纷纭，经测试，fetch也不能跟随302跳转页面，会将请求后的报文体返回回来。 3、使用Location.href，无论重定向后的地址是否跨域，均可以成功重定向。 4、使用form表单做302跳转，也是可以成功的，但是需要创建一个虚拟节点，处理起来较为复杂。 5、Nvigator.sendBeacon,由于该方法必须采用Post，故更改一下后端代码。虽然使用该方法没有跨域问题，但是由于是异步方法，并不会让浏览器跟随302操作。 总结：使用Location.href直接访问接口 ​ 上述五种方式，Ajax和Fetch皆是异步请求，不能跟随浏览器302的操作，并且还获取不到接口返回的Location等信息，所以不采用。Form表单可以使用，功能也较为全面，但是实现方式较为复杂，且Form表单通常用于表单内容提交，与场景语义不符，故Pass**。Location.href的方式即以Get请求直接使用浏览器访问该接口，参数携带方便，也能跟随重定向操作，故采用。**
附上代码：
import serviceInstance from "../../services"; // const res = serviceInstance({ // url: "/redirectTo", //不用引入，直接在api后面接接口 // method: "get", // data: {}, // }); // console.log(res); function Home() { const setRedirect = () =&gt; { const res = serviceInstance({ url: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11fc0bb771ba19d37c92766aa9c2cfda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58f324272df285eb121a164f6f6ea89e/" rel="bookmark">
			【数据结构与算法】 - 双向链表 - 详细实现思路及代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、概述二、双向链表三、双向链表实现步骤📌3.1 C语言定义双向链表结点📌3.2 双向链表初始化📌3.3 双向链表插入数据📌3.4 双向链表删除数据📌3.5 双向链表查找数据📌3.6 双向链表的销毁 四、双向链表完整代码 一、概述 前几篇文章介绍了怎样去实现单链表、单循环链表，这篇文章主要介绍双向链表以及实现双向链表的步骤，最后提供我自己根据理解实现双向链表的C语言代码。跟着后面实现思路看下去，应该可以看懂代码，看懂代码后，就对双向链表有了比较抽象的理解了，最后自己再动手写一个双向链表，就基本理解这个东西了。
二、双向链表 双向链表：在单链表的每个结点中，再设置一个指向其前驱结点的指针域。
下图是 单链表：
下图是 双向链表：
双向链表的特点：
双向链表可以反向访问到链表的结点，因为它有指向前一个结点的指针prior；带有头结点的双向链表，为空链表时，头结点的两个指针域都指向NULL。
带有头结点的双向链表，为非空链表时，
头结点的前驱指针域指向NULL，后驱指针域指向第一个结点；
最后一个结点的前驱指针域指向前一个结点，后驱指针域指向NULL；
其他结点的前驱指针域指向前一个结点，后驱指针域指向后一个结点；
三、双向链表实现步骤 从上面知道了双向链表的相关概念和一些特点，接下来开始实现双向链表，这里使用带有头结点的双向链表进行讲解，从初始化双向链表、插入数据、删除数据、查找数据、销毁双向链表5个操作进行说明，需要注意的是，双向链表的插入、删除操作需要改变两个指针域；其他操作基本和单链表一致。
📌3.1 C语言定义双向链表结点 为了和前几篇文章的链表做比较，双向链表结构体也尽量定义相似的。
typedef int ElemType; typedef struct _DoubleListNode { ElemType data; struct _DoubleListNode *prior;	// 前驱指针 struct _DoubleListNode *next;	// 后驱指针 }DoubleListNode; typedef DoubleListNode* DoubleLinkList; 📌3.2 双向链表初始化 因为带有头结点，初始化时就需要分配一个头结点的内存空间，且头指针会一直指向头结点。
双向链表初始化算法思路如下：
1、分配一个结点的存储空间作为头结点，并将头指针指向头结点； 2、让头结点的 prior指针 和 next指针 都指向NULL，头结点的数据填一个无效值； 3、将头指针返回给函数调用者。 C语言实现代码如下：
DoubleLinkList ListInit() { DoubleLinkList list = (DoubleLinkList)malloc(sizeof(DoubleListNode)); list-&gt;prior = NULL; list-&gt;next = NULL; list-&gt;data = -1; return list; } 📌3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58f324272df285eb121a164f6f6ea89e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71bcff95ed7b2249d19c26dd82866d10/" rel="bookmark">
			【Python脚本】Python自动大麦网抢票，准点原价秒杀演唱会门票，拒绝黄牛交易！从我做起！！！1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、分析购票过程二、Selenium 模拟浏览器操作三、逆向工程：抢票接口总结 前言 你是否错过了周杰伦的票，最近又没抢到五月天的票，不要太难过，今晚有张学友的票，后天还有张杰的票，加油哦！
Python配套案例源码、资料点击领取福利 为了帮助你在激烈的抢票竞争中获得更大的成功机会，本文将介绍抢票软件的实现原理以及我所了解的一些抢票方式。但是，请不要过度将希望寄托于抢票软件，它有时也不灵，经过我的验证，即使你用到了抢票软件，也不一定能抢到票。
票务平台会经常调整反爬策略打击爬虫行为，如果希望抢票软件保持较高的成功率，是需要开发者针对票务平台的打击策略作出逻辑调整，这个成本是很高的，所以你能随手获得的抢票软件很大概率是抢不到票的或者说是不安全的。
在调研过程发现一个有意思的点 “黄牛的票从来不是抢来的”。相关规定，面向市场公开销售的营业性演出门票数量，不得低于核准观众数量的70%。 而剩下的那 30%，即非公开销售的票，则是黄牛票的主要来源，也叫渠道票。这里面涉及主办方对热门票和冷门票的售票策略，黄牛在这链条中扮演着重要的角色，只要演唱会门票的二级市场不会消失，黄牛就永远不会消失，对于市场本身来说，愿意花更多钱买黄牛票的人，一定是更有需求的人，黄牛不过是市场调节的人格化。
一、分析购票过程 现在无论是买火车票、飞机票、演唱会票基本都是使用电子支付网上购票，之后得到一张电子票凭证，进场前打印纸质票或者闸机核销票据二维码进场，那么我们从用户角度看下，一次完整的购票过程是什么样。
用户的购票流程：
首先用户登录 票务 APP 搜索爱豆的门票，点击查看门票详情，然后选择场次和票档。等待抢票倒计时，才能进入到下一个页面；倒计时结束后，开抢按钮被点亮，用户进入下一步选择观演人，确认信息后选择付款方式提交订单；如果手速足够快、运气足够好，抢到了票就会唤起所选的支付方式 APP 提示付款；如果没有抢到则会提示拥堵，跳转到票档选择页面。 下面，我将这个图补充一下，思考下哪些步骤是用户可以提高出票成功率的关键时间节点：
很显然，用户在倒计时之前看不到的页面就是竞争手速的关键时机，当这个开抢按钮被倒计时点亮的一瞬间，要以最快的速度点击到达隐藏页面，然后选中观演人，通常使用默认的支付方式，最后提交订单。一旦订单被提交成功，就说明锁定了席位抢到了票。如果用户在规定的时间内未付款，该席位会重新流入票池，捡漏的人就可以抢到。
到这里，我们知道了购票流程和提高抢票成功率的突破口，人的手速肯定没有机器快，接下来介绍下两种常用的技术抢票方案。
二、Selenium 模拟浏览器操作 在使用 Chrome 浏览器，用户可以使用鼠标滑动、按键点击以及键盘输入，作为信号输入设备向浏览器传达指令，浏览器收到指令后执行渲染。
这里提到的 Selenium WebDriver 是对浏览器提供的原生 API 进行封装，使用这套 API 可以操控浏览器的开启、关闭，打开网页，操作界面元素，控制 Cookie。简单说就是，可以通过写代码的方式来自动实现用户鼠标和键盘信号的输入。这么一来，可以做的事就非常多了。
下面是一个简单脚本，它首先打开 chrome 浏览器输入 google 的网址，等待 5 秒，浏览器网页打开后，找到输入框输入 ”ChromeDriver“，然后模拟点击搜索按钮，就能看到浏览器上搜索的结果。
import time from selenium import webdriver from selenium.webdriver.common.by import By browser.get("https://www.google.com") time.sleep(5) # 查找元素 search_box = browser.find_element(By.NAME, 'q') # 模拟按键输入 search_box.send_keys('ChromeDriver') # 搜索框模拟回车 search_box.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71bcff95ed7b2249d19c26dd82866d10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/034122ab094f2dcd615afe3ad2539dc1/" rel="bookmark">
			java web 开发——第七章MVC模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言7.1、MVC模式介绍7.2、JSP中的MVC模式7.3、模型的生命周期与视图更新7.3.1、request bean7.3.2、session bean7.3.3、application bean 7.4、简单示例 前言 本章将介绍 MVC 模式,MVC 模式的核心思想是将“模型关视图”和“控制器?进行有效组合。掌握该模式对于设计合理的 Web 应用以及学习使用某些流行的 Web 框架,如 Spring、Struts 等,有着十分重要的意义。
7.1、MVC模式介绍 模型-视图-控制器(Model-View-Controller) , 简称为 MVC。MVC 已经成为软件设计者必须熟练使用的开发模式。
MVC 是一种通过三部分构造一个软件或组件的理想办法。
★ 模型(model) : 用于存储数据的对象 。
★ 视图(view) : 回控制器提交所需数据、显示模型中的数据。
★ 控制器(controller) : 负责具体的业务逻辑操作,即控制需根据视图提出的要求对数据做出(商业)处理,将有关结果存储到模型中,并负责让模型和视图进行必要的交互,当模型中的数据变化时,让视图更新显示。
从面回对象的角度看,MVC 开发模式可以使程序容易维护 ,也更容易扩展。在设计程序时,可以将某个对象看作”模型“ ,然后为“模型“提供恰当的显示组件,即“视图”。在 MVC 模式中”视图“”模型“和”控制器”之间是松耦合结构 ,便于系统的维护和扩展。
7.2、JSP中的MVC模式 在 JSP 中,MVC 模式的实现如图 7. 2 所示,具体实现如下 :
★ 模型(Model) : 一个或多个 JavaBean 对象 ,用于存储数据。JavaBean 主要提供简单的setXxx 方法和 getXxx 方法,在这些方法中不涉及对数据的具体处理细节,以便增强模型的通用性。
★ 视图(View) : 一个或多个 JSP 页面,其作用是各控制需提交必要的数据和显示数据。JSP 页面可以使用 HTML 标记、JavaBean 标记以及Java 程序片或 Java 表达式来显示数据。视图的主要工作就是显示数据 ,对数据的逻辑操作由控制器负责。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/034122ab094f2dcd615afe3ad2539dc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da845ca8d9d230e1e589b90082f2d682/" rel="bookmark">
			【已解决】mac电脑终于卸载掉了这个“微信键盘”输入法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有一天我被微信的输入法广告吸引了，导致我下载安装了微信键盘，在使用一段时间后，感觉这个输入法就是个翔，害我花不少时间翻页找字，降低了我的效率，
所以我决定卸载它，干掉它~
but，我的mac电脑不像windows那样下载方便，找半天都不知道怎么卸载，于是我查询各种资料帖子，终于下载删除了
1、首先 打开键盘设置： 2、选中微信键盘，将微信键盘从输入法中移除 3、在活动监视器里搜索到微信键盘任务 并把他强制停止掉 这一步如果不强制停止，就会无法删除掉，因为无法删除正在运行的程序，就会出现下面这个异常：
4、杀掉后台进程，再进入到微信键盘文件内右键 WeType 移到废纸篓 打开finder ， 按住 sheft + command + G 输入：/Library/Input Methods 回车
选中WeType ，右键选择 移到废纸篓 即可~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b802bca3cc437e8987f49c1955516e2/" rel="bookmark">
			基于Python guI的多人聊天室的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于Python guI的多人聊天室的设计与实现 摘要 现在，即时聊天系统已成为 Internet 上的主要交流工具，并且涌现出大量的AP和平台。这些AP和平台都拥有更加完善的交换机制，使得人们可以更加便捷地进行沟通和交换信息。
广域网的聊天系统多重多样，知名的软件主要有 Facebook、腾讯 QQ 等。局域网聊天通信软件也有很多，最著名的应该是飞秋。为了学习和应用 Windows 网络通信编程，我们学习了相关知识，为了应用实践，使用网络通信中的 TCP 和 UDP 编程，实现了多人在线聊天系统。
这个项目旨在提供一个便捷的、高效的社交空间，它利用python的tkinter、threading、soket等多线程库，可以轻松地建立起一个多种社交模式，既可以进行群组交流，也可以进行个人私信，甚至可以发布表情包。该项目由两个部件组成：一个是服务器，负责处理所有的数据。另一个是通讯设备，负责处理所有的文件。两个部件都使用Tcp协议来实现互联互通。
关键词 多人聊天室；Soket；tcp；python
目录
1、引言
1.1 背景和意义
1.2 系统要实现的功能
1.2.1 用户登录
1.2.2 群发消息
1.2.3 一对一聊天
1.2.4 发送表情
2、系统结构
2.1 系统结构图
2.2 系统实现原理
2.2.1服务器端实现原理
2.2.2 客户端实现原理
2.3 系统技术分析
2.3.1 tkinter 图形用户界面库
2.3.2 threading 多线程
2.3.3 socket 网络编程
3、实现代码
3.1服务器端代码
3.1.1确定全局变量
3.1.2实现多线程接收数据
3.1.3处理接收到的数据
3.1.4将在线用户存入online列表并返回
3.1.5删除用户
3.1.6发送消息
3.1.7 主函数
3.2 客户端代码
3.2.1确定全局变量
3.2.2登录窗口实现
3.2.4 创建聊天窗口
3.2.5 发送数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b802bca3cc437e8987f49c1955516e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed098a45ed48ea3948d011edca16d7d2/" rel="bookmark">
			判断一个数据是否为 JSON 数据与使用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		判断一个数据是否为 JSON 数据，可以通过以下几个步骤：
首先，判断该数据是否为字符串类型。因为 JSON 数据通常是以字符串形式传输的。
然后，使用 try...catch 语句尝试将该字符串解析为 JSON 数据。如果解析成功，则说明该数据为 JSON 数据；否则，说明该数据不是 JSON 数据。
例如，下面的代码演示了如何判断一个字符串是否为 JSON 数据：
const jsonString = '{"name": "John", "age": 30, "isMarried": false}'; try { const data = JSON.parse(jsonString); console.log('该数据为 JSON 数据'); } catch (error) { console.log('该数据不是 JSON 数据'); } 需要注意的是，如果要判断一个对象或数组是否为 JSON 数据，首先需要将它转换为 JSON 字符串，然后再按照上述步骤进行判断。例如，下面的代码演示了如何判断一个对象是否为 JSON 数据：
const data = { name: 'John', age: 30, isMarried: false }; try { const jsonString = JSON.stringify(data); const jsonData = JSON.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed098a45ed48ea3948d011edca16d7d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8661570c66a1ced796183aef98148ecc/" rel="bookmark">
			【云计算】HBase表操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、shell创建二、操作 前言 HBase是一个分布式、可扩展的、非关系型的NoSQL数据库。它是建立在Hadoop HDFS上的一个开源的数据库管理系统。HBase的设计目标是提供高可靠性、高可扩展性、高性能、高延迟、高容错性和高可用性。
HBase是一种面向列的数据库，可以处理海量的结构化和半结构化数据。它可以存储大量的数据，并能够快速索引和检索数据，适用于需要高速在线访问大量数据的应用程序。
在HBase中，数据按照表格的形式进行存储，类似于关系型数据库中的表。每个表格都具有一个行键和多个列族。行键是一个唯一标识符，用于在表格中定位一行数据。列族是相关列的集合，每个列族都由一个标识符和多个列组成。
HBase具有众多的特性，包括高可用性、自动分片、支持多版本数据、支持复杂的数据类型、支持MapReduce计算等。它还具有良好的扩展性，可以根据需要添加新的节点来扩展集群的规模，以满足更高的数据处理需求。
总的来说，HBase是一个高性能、高可扩展性的NoSQL数据库，适用于需要处理大量结构化和半结构化数据的分布式应用程序。它可以通过灵活的数据模型和支持复杂数据类型的功能，帮助开发人员快速构建可扩展的应用程序。
一、shell创建 Hbase命令：
进入shell： hbase shell 使用help "COMMAND"命令获取特定命令的帮助信息，例如help "get"将显示关于get命令的帮助信息（注意需要使用引号）。 命令分组：命令被分组管理。使用help "COMMAND_GROUP"命令获取特定命令组的帮助信息，例如help "general"将显示关于general命令组的帮助信息。 常见的命令组包括：general、ddl、namespace、dml、tools、replication、snapshots、configuration、quotas、security、procedures、visibility labels、rsgroup和storefiletracker。 你可以执行各种命令来进行表的操作、数据的增删改查、配置管理、权限管理等。 HBase Shell提供了一些常用命令示例： create：创建表。 disable：禁用表。 enable：启用表。 describe：显示表的结构和属性。 get：获取指定行的数据。 put：插入或更新数据。 scan：扫描表中的数据。 delete：删除指定行或列的数据。 list：列出所有表或命名空间。 alter：修改表的结构或属性。 count：统计表中的行数。 二、操作 创建命名空间类似于Mysql中的数据库：create_namespace
创建ns1，ns2命名空间 hbase:005:0&gt; create_namespace 'ns1' Took 0.2768 seconds hbase:006:0&gt; create_namespace 'ns2' Took 0.1402 seconds 查看一下创建的命令空间列表：list_namespace
这里的default，hbase是hbase自带的命名空间
hbase:008:0&gt; list_namespace NAMESPACE default hbase ns1 ns2 4 row(s) Took 0.0132 seconds #正则方式查看以ns开头命名空间 hbase:009:0&gt; list_namespace "ns*" NAMESPACE ns1 ns2 2 row(s) Took 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8661570c66a1ced796183aef98148ecc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d15464c3befa23394be22bbc5a0d04c/" rel="bookmark">
			Java GUI实现简易百词斩功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在期末实训用java写的百词斩,虽然功能不太全面,但修修改改,缝缝补补,也是自己花费很多时间来尽量让代码写的完美,如果代码有不完美的地方,请大家在下面多多留言
package 百词斩; //导入需要用到的Java类库 import java.awt.event.*; import java.util.*; import javax.swing.*; import java.awt.*; import java.io.*; public class Bczh extends JFrame implements ActionListener { /** * */ // 定义所有的单词列表ArrayList ArrayList&lt;String&gt; totalWords = new ArrayList&lt;String&gt;(); // 定义用来测试的单词列表ArrayList ArrayList&lt;String&gt; testWords = new ArrayList&lt;String&gt;(); //定义历史记录 ArrayList&lt;String&gt; historyWords = new ArrayList&lt;String&gt;(); JLabel scoreLabel = new JLabel(); //定义标签用来显示答对单词数 JLabel wordLabel = new JLabel(); //定义标签用来显示正在测试的单词 JLabel historyLabel = new JLabel();// 定义标签用来显示历史单词 ButtonGroup group = new ButtonGroup();//定义单选按钮框 JRadioButton rb1 = new JRadioButton();//定义选项一单选按钮 JRadioButton rb2 = new JRadioButton();//定义选项二单选按钮 JRadioButton rb3 = new JRadioButton();//定义选项三单选按钮 JRadioButton rb4 = new JRadioButton();//定义选项四单选按钮 JLabel answerLabel = new JLabel(); //定义标签显示正确答案 // 定义“继续”和“结束”按钮 JButton continueButton = new JButton("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d15464c3befa23394be22bbc5a0d04c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d931cef4c8c057999c7ca2c7f45abf52/" rel="bookmark">
			解决问题： java.net.ConnectException: Connection refused: connect
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 使用hive连接三方工具datagrip的时候出现错误：
Could not open client transport with JDBC Uri: jdbc:hive2://hadoop:10000: java.net.ConnectException: Connection refused: connect
解决过程： 首先通过查阅网上资料，排除了以下原因：
1、防火墙
2、Hadoop中hdfs、yarn的启动
3、开启metastore和hiveServer2服务
然后去看了hive的日志：
Caused by: org.apache.hadoop.ipc.RemoteException: Cannot create directory /tmp/hive/root/239df2e3-f39e-46b7-8f17-38dc7da2d793. Name node is in safe mode.
The reported blocks 501 needs additional 8 blocks to reach the threshold 0.9990 of total blocks 510.
The minimum number of live datanodes is not required. Safe mode will be turned off automatically once the thresholds have been reached.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d931cef4c8c057999c7ca2c7f45abf52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fce11eb6e93a07c75285bdb7fe1c27a/" rel="bookmark">
			springboot期末复习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、填空题
Spring Boot Maven 项目的依赖配置文件是:pom.xml，默认的视图模板文件夹 是:resources/templates。Spring Boot 项目中的@Controller 注解完成的功能是:实现 MVC 控制器, @GetMapping 注解的功能是:响应 GET 请求。SSE 的含义是服务器发送事件, WebSocket 是一种在单个 TCP 连接上进行全 双工通讯的技术。REST 的含义是:表现出状态转移。@CrossOrigin 注解的作用是:跨域配置。Spring Boot 项目的打包命令是:mvn package,两种打包发布方式分别是: jar、war。Spring Boot 项 目 中 若 采集表单 参数，应 在 响应函数 的 参数中使用 @RequestParam 注解，若采集客户端发送的 JSON 数据，应采用@RequestBody 注解.多对一实体映射对应的注解是:@ManyToOne,一对一实体映射对应的注解 是:@OneToOne。互联网 IP 地址的作用是用于区分联网的计算机设备，端口号的作用是用于标识计算机的应用程序, Http 服务器的默认端口号是: 80, Spring Boot 应用程序的 默认端口号是:8080。如果要配置 Spring Boot 应用程序的端口号为 9000, 则应 修改应用程序配置文件 application.properties,添加配置语句: server.port=9000。Spring Boot MVC 应用程序默认的静态页面文件夹是: resources/public 或 resources/static, Spring Boot Maven 项目的依赖配置文件是: pom.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fce11eb6e93a07c75285bdb7fe1c27a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30b54d52aa50a606f117e8bc0256d1f9/" rel="bookmark">
			HbuilderX如何连接微信开发者小程序（保姆级教程）：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在官网下载HbuilderX：HBuilderX-高效极客技巧 (dcloud.io)
2、下载微信开发者工具，最好是选择稳定版微信开发者工具下载地址与更新日志 | 微信开放文档 (qq.com)
3、打卡HbuilderX，选择文件—新建—项目
模板默认第一个
4、打开微信开发者工具，选择自己需求，小程序就选小程序，后面是改不了的。
5、设置里打开安全设，把服务端口打开。
6、在HbuilderX里面
点击 运行 -&gt; 运行到小程序模拟器，点击 微信开发者工具 模拟器即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/598e823b7f588e862071d26d833ed6c3/" rel="bookmark">
			Python（Tk）登录界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
什么是tk，python里的tk是什么，能干什么？
Tkinter模块("Tk 接口")是Python的标准Tk GUI工具包的接口.
Tk和Tkinter可以在大多数的Unix平台下使用,同样可以应用在Windows和Macintosh系统里.Tk8.0的后续版本可以通过ttk实现本地窗口风格,并良好地运行在绝大多数平台中。
简单就是一个简单的界面制作，学习这里可以快速学期其他的界面比如说Qt5
这里我们来使用tkinter库来制作一个登录界面
首先我们先制作一个窗口
这里就是一个窗体的代码，运行查看效果
可以可以，下面我们就来制作一下他的按钮的功能，先是登录按钮的功能
这里我是设置可以登录三次，三次失败后就直接把窗体给退出，就是程序结束。
前提我们要有一个账号和密码存放的文件 这里我们就定义一个read1函数来获取账号密码等数据 这里我们就把登录按钮制作好了，下面我们来制作注册按钮的功能
这里我使用的是把窗口变成透明色，这样我们的用户就看不到登录窗口了
而后我们再写一个函数来实现注册功能
而后我们运行代码
最后我们实现一下返回功能就好了
这样我就使用python完成了登录界面的制作
下面是我的代码
# 先导入tkinter， sys， re库 from tkinter import * from tkinter import messagebox as msgbox import sys import re # 这里定义一个Tking类 class Tking(object): # 初始化 def __init__(self): self.win = Tk() self.count = 3 # 定义函数来获取数据内容 def read1(self): with open('zhanghao.txt', 'r')as f: file = f.read() return file # 定义函数来实现“登录”按钮的功能 def js(self): # 调用函数获取账号信息 data = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/598e823b7f588e862071d26d833ed6c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfa069f9f6303ddc6390f18cca1b6395/" rel="bookmark">
			Whisper与ChatGPT联手，轻松实现音频转录文本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、Whisper简介
二、Whisper可用的模型和语言
三、开源 Whisper 本地转录
3.1、安装pytube库
3.2、下载音频MP4文件
3.3、安装 Whisper 库
四、在线 Whisper API 转录
4.1、Whisper API 接口调用
4.2、使用Prompt参数优化
4.3、其它参数介绍
4.4、转录过程翻译功能
4.5、分割音频处理大文件
4.6、基于ChatGPT对内容进行总结
五、总结
六、资源推荐
前言 前一阵给大家介绍的主题更多的集中在AI编程和LLMs的一些应用实战方面，ChatGPT我们都知道最强大的还是它底层应用的文本语言模型GPT系列，原来我们对于机器学习、深度学习领域想要实现一些相对智能化的小功能，不管是学习成本、人力成本都很大，而且对没有AI方面的经验和数据基础一般门槛都会比较高，现在我们通过GPT来实现这方面的需求相对来说就非常简单了，而且达到的效果也会更好。
今天我们来进入一个新的主题，那就是语音识别，虽然ChatGPT功能很强大，但只能接受文本输入，IOS版本虽然提供了语音输入功能，但因为种种限制，没条件的人很难享受到。 而在现实生活中，我们其实有很多场景下都不方便停下来打字，很多内容比如像YouTube视频、播客音频也没有文字版，所以这个时候，我们就需要一个能够将语音内容转换成文本的能力。
作为目前 AI 界的领导者，OpenAI 自然也不会放过这个需求。他们不仅发表了一个通用的语音识别模型 Whisper，还把对应的代码开源了。在今年的 1 月份，他们也在 API 里提供了对应的语音识别服务。那么今天，我们就一起来看看 Whisper 这个语音识别的模型可以怎么用。
一、Whisper简介 Whisper 是 OpenAI 的一种自动最先进的语音识别系统，它已经接受了 680,000 小时从网络收集的多语言和多任务监督数据的训练。这个庞大而多样化的数据集提高了对口音、背景噪音和技术语言的鲁棒性。此外，它还支持多种语言的转录，以及将这些语言翻译成英语。与 DALLE-2 和 GPT-3 不同，Whisper 是一种免费的开源模型。OpenAI 发布了模型和代码，作为构建利用语音识别的有用应用程序的基础。
Whisper的优势是开源免费、支持多语种（包括中文），根据不同的场景需求有不同模型可供选择，最终的效果比市面上很多音频转文字的效果都要好。 Transformer 序列到序列模型针对各种语音处理任务进行训练，包括多语言语音识别、语音翻译、口语识别和语音活动检测。这些任务共同表示为由解码器预测的一系列标记，允许单个模型取代传统语音处理管道的多个阶段。多任务训练格式使用一组特殊标记作为任务说明符或分类目标。
二、Whisper可用的模型和语言 Whisper提供了五种型号尺寸，其中四种为纯英文版本，提供速度和准确性的权衡。以下是可用型号的名称及其大致的内存要求和相对速度。
纯英语应用程序的模型往往性能更好，尤其是对于 tiny.en 和 base.en 模型。我们观察到 small.en 和 medium.en 模型的差异变得不那么明显。
Whisper 的性能因语言而异。下图显示了使用该模型的 Fleurs 数据集按语言的 WER（单词错误率）细分large-v2（数字越小，性能越好）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfa069f9f6303ddc6390f18cca1b6395/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9d24460b59436cf8c1fd6af9e1ee503/" rel="bookmark">
			Android :app:processDebugResources 错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现
Could not create task ‘:app:processDebugResources’.
Cannot use @TaskAction annotation on method IncrementalTask.taskAction$gradle_core() because interface org.gradle.api.tasks.incremental.IncrementalTaskInputs is not a valid parameter to an action method.
出现这个的原因是 我从最新版的android studio 换成了一个旧版本的Android studio
解决方法:
修改 gradle/wrapper/gradle-wrapper.properties
里的
distributionUrl=https://services.gradle.org/distributions/gradle-8.0-bin.zip
我这里修改的是为
distributionUrl=https://services.gradle.org/distributions/gradle-7.3.3-bin.zip
我解决这个问题的思路是 从一个正常能Gradle sync的项目中 拷贝这些配置内容到不能正常 sync的项目中
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f5c6895f15ca3673f991e73da2dbfd1/" rel="bookmark">
			【JVM 监控工具】性能诊断--JProfiler的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 背景一、Java 性能诊断工具简介二、简单命令行工具三、图形化综合诊断工具JVisualvmJProfilerJConsole 四、分布式应用性能诊断五、IDEA中设置JProfilerJProfiler是什么功能安装使用生成快照配置VM运行程序 背景 性能诊断是软件工程师在日常工作中需要经常面对和解决的问题，在用户体验至上的今天，解决好应用的性能问题能带来非常大的收益。Java 作为最流行的编程语言之一，其应用性能诊断一直受到业界广泛关注。可能造成 Java 应用出现性能问题的因素非常多，例如线程控制、磁盘读写、数据库访问、网络I/O、垃圾收集等。想要了定位这些问题，一款优秀的性能诊断工具必不可少。本文将介绍 Java 性能诊断过程中的常用工具，并重点介绍其中的优秀代表 JProfiler 的基本原理和最佳实践（本文所做的调研基于jprofiler10.1.4）。
一、Java 性能诊断工具简介 在 Java 的世界里，有许多诊断工具可供选择，既包括像 jmap、jstat 这样的简单命令行工具，又包括 JVisualvm、JProfiler 等图形化综合诊断工具，同时还有 SkyWalking、ARMS 这样的针对分布式应用的性能监控系统。下面分别对其进行介绍。
二、简单命令行工具 JDK 内置了许多命令行工具，它们可用来获取目标 JVM 不同方面、不同层次的信息。
jinfo - 用于实时查看和调整目标 JVM 的各项参数。jstack - 用于获取目标 Java 进程内的线程堆栈信息，可用来检测死锁、定位死循环等。jmap - 用于获取目标 Java 进程的内存相关信息，包括 Java 堆各区域的使用情况、堆中对象的统计信息、类加载信息等。jstat - 一款轻量级多功能监控工具，可用于获取目标 Java 进程的类加载、JIT 编译、垃圾收集、内存使用等信息。jcmd - 相比 jstat 功能更为全面的工具，可用于获取目标 Java 进程的性能统计、JFR、内存使用、垃圾收集、线程堆栈、JVM 运行时间等信息。 三、图形化综合诊断工具 使用上述命令行工具或组合能帮您获取目标 Java 应用性能相关的基础信息，但它们存在下列局限：
无法获取方法级别的分析数据，如方法间的调用关系、各方法的调用次数和调用时间等（这对定位应用性能瓶颈至关重要）。要求用户登录到目标 Java 应用所在的宿主机上，使用起来不是很方便。分析数据通过终端输出，结果展示不够直观。 下面介绍几款图形化的综合性能诊断工具。
JVisualvm JVisualvm 是 JDK 内置的可视化性能诊断工具，它通过 JMX、jstatd、Attach API 等方式获取目标 JVM 的分析数据，包括 CPU 使用率、内存使用量、线程堆栈信息等。此外，它还能直观地展示 Java 堆中各对象的数量和大小、各 Java 方法的调用次数和执行时间等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f5c6895f15ca3673f991e73da2dbfd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4fe45a2819e21d5ff6c8f3732ec4c44/" rel="bookmark">
			使用vue3简单实现WebSocket通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WebSocket是一种在客户端和服务器之间进行双向通信的网络协议。它通过建立持久性的、全双工的连接，允许服务器主动向客户端发送数据，而不需要客户端显式地发送请求。 关于WebSocket通信的简单介绍：
握手阶段：在建立WebSocket连接之前，客户端需要发送一个HTTP请求到服务器，请求升级为WebSocket协议。这个过程称为握手（Handshake）。如果服务器支持WebSocket协议，它将返回带有特定标头的HTTP响应，表示握手成功。建立连接：客户端收到服务器的握手响应后，会重新建立连接。此时，连接将从HTTP协议切换到WebSocket协议，并保持打开状态。这样就建立了可持续的双向通信通道。数据传输：一旦WebSocket连接建立，客户端和服务器可以开始互相发送消息。客户端和服务器都可以通过发送文本或二进制数据来通信。消息可以是简单的字符串，也可以是复杂的数据结构，如JSON对象等。断开连接：当需要关闭WebSocket连接时，客户端或服务器可以主动发送一个关闭帧来断开连接。收到关闭帧的一方会结束连接并发送回应帧，完成连接的关闭。 WebSocket通信具有以下特点：
实时性：由于WebSocket使用长连接，可以实时地将数据推送到客户端，而不需要显式地发送请求。这使得它非常适合需要快速、实时响应的应用程序。双向通信：WebSocket允许客户端和服务器之间双向传输消息。这意味着服务器可以主动向客户端推送数据，而不仅限于响应客户端的请求。较低的开销：相比于传统的轮询方式（每隔一段时间发送请求），WebSocket连接具有较低的开销。一旦建立连接，它只需要发送少量的数据头部信息，并且在保持连接时可以重复使用该连接。跨平台支持：WebSocket协议是一种标准化的协议，被广泛支持和应用于不同的平台和编程语言中。 通过使用WebSocket，开发人员可以实现实时通信、聊天应用、多人游戏、股票行情等需要及时交互和更新的应用程序。
1.相关代码如下： ①创建src/utils/websocket.ts文件
import { ElMessage } from 'element-plus' import store from '../store' let websocket: WebSocket | null = null; // 用于存储实例化后websocket let rec: any; // 断线重连后，延迟5秒重新创建WebSocket连接 rec用来存储延迟请求的代码 // 创建websocket function creatWebSocket(wsUrl: string) { console.log("websocket=================="); // 判断当前浏览器是否支持WebSocket if ("WebSocket" in window) { console.log("当前浏览器支持 WebSocket"); } else if ("MozWebSocket" in window) { console.log("当前浏览器支持 MozWebSocket"); } else { console.log("当前浏览器不支持 WebSocket"); } try { initWebSocket(wsUrl); // 初始化websocket连接 } catch (e) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4fe45a2819e21d5ff6c8f3732ec4c44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f126369f442c94aa6f1e84faad86fd88/" rel="bookmark">
			Windows窗体学这一篇就够了(C#控件讲解)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Form窗体
1.1窗体的创建和删除
1、添加窗体
2、删除窗体
3、多窗体的使用
1.2、窗体属性
1.2.1更换窗体图标
1.2.2隐藏窗体的标题栏(FormBorderStyle属性)
1.2.3控制窗体的显示位置(StartPosition属性)
1.2.4窗体背景图片的设置
1.2.5窗体的显示与隐藏
1.3窗体的事件
1.3.1单击事件(Click)
1.3.2加载事件(Load)
1.3.3关闭事件(FormClosing)
补、为何关闭了窗口了但下次启动时却显示还在运行
二、MDI窗体
2.1设置MDI窗体
2.1.1设置父窗体
2.1.2设置子窗体
2.2排列MDI子窗体
三、窗体控件
1.1控件的概述
1.2控件的相关操作
2.1文本控件
2.1.1Label控件
2.1.2Button控件
2.1.3TextBox控件
2.1.4RichTextBox控件
超链接样式
richTextBox文本框设置
3.1选择类控件
3.1.1ComboBox控件
添加元素：分为手动和代码添加。
设置下拉样式(DropDownStyle)
3.1.2CheckBox控件
3.1.3RadioButton单选按钮
1、判断单选按钮是否被选中
2、响应单选按钮选中状态更改事件
3、单选按钮分组
3.1.4NumericUpDown控件
1、最大值/最小值设置
2、获取NumericUpDown控件中显示的数值
3、设置NumericUpDown控件中数值的显示方式
3.1.5ListBox控件
1、在ListBox控件中添加和移除项
2、创建总显示滚动条的列表控件
3、在ListBox控件中选择多项
4.1分组控件
4.1.1Panel控件
4.1.2GroupBox控件
​编辑
4.1.3TabControl控件
1、选项卡图片显示样式
2、鼠标移入时弹出提示信息
​编辑
3、将选项卡显示为按钮样式
4、在选项卡中添加控件
5.1菜单、工具栏和状态栏控件
5.1.1MenuStrip控件
5.1.2弹出式菜单(ContextMenuStrip)
5.1.3ToolStrip控件 （工具栏）
5.1.4StatusStrip控件(状态栏)
6.1.1ImageList控件（图片集）
1、ImageList控件代码添加图片
2、在ImageList控件中通过代码移除图片
7.1PictureBox控件(图片展示)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f126369f442c94aa6f1e84faad86fd88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2c967f925287e58ff1a6dcc83f24961/" rel="bookmark">
			【课程设计】Java 计算器实现（源码 &#43; 详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎈 作者：Linux猿
🎈 简介：CSDN博客专家🏆，华为云享专家🏆，Linux、C/C++、云计算、物联网、面试、刷题、算法尽管咨询我，关注我，有问题私聊！
🎈 关注专栏：C/C++/Java课程设计100例 优质好文持续更新中……🚀🚀🚀
🎈 欢迎小伙伴们点赞👍、收藏⭐、留言💬
目录
一、需求分析
二、设计思路
2.1 界面设计
2.2 表达式算法
三、代码实现
「Java 计算器」是非常适合刚学习 Java 用来练手的基础项目，即可以巩固 Java 基础，也可以学习表达式算法，本篇文章来讲解下基于 Java 的「计算器」实现。
在正式讲解之前，先来看下实现效果，如下所示。
图1 Java 计算器界面 一、需求分析 功能需求如下所示：
（1）实现算术加法、减法、乘法、除法的基本运算；
（2）支持括号‘（’ 和 ‘）’操作；
（3）支持删除操作；
（4）支持清除操作；
（5）支持小数操作；
（6）支持错误检查；
二、设计思路 功能设计主要包括两部分：界面设计和表达式算法，下面分别来介绍下。
2.1 界面设计 通过继承 JFrame 类实现界面的布局，主要分为两部分，一个是表达式输入框，另一个是表达式输入需要的按钮。
其中，表达式需要的按钮包括："C", "(", ")", "/", "7", "8", "9", "*", "4", "5", "6", "-", "1", "2", "3", "+", "0", ".", "DEL", "="。
其中，C 按钮表示清空输入框，DEL 按钮表示删除输入框中的最后一个字符，= 按钮表示计算输入框中的表达式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2c967f925287e58ff1a6dcc83f24961/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03d1c498adbc689508dcfb03bc50c56f/" rel="bookmark">
			java Web实现用户登录功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、纯JSP方式实现用户登录功能（一）实现思路1、创建Web项目2、创建登录页面3、创建登录处理页面4、创建登录成功页面5、创建登录失败页面6、编辑项目首页 （三）测试结果 二、JSP+Servlet方式实现用户登录功能（一）实现思路（二）实现步骤1、创建Web项目2、创建登录页面3、创建登录处理程序4、创建登录成功页面5、创建登录失败页面6、编辑项目首页 （三）测试结果 三、JSP+Servlet+DB方式实现用户登录功能（一）实现思路（二）实现步骤1、创建数据库2、创建用户表3、创建Web项目4、创建用户实体类5、添加数据库驱动程序6、创建数据库连接管理工具类7、创建用户数据访问类8、测试用户数据访问类 四、采用MVC模式实现用户注册功能1、创建Web项目2、创建内容 一、纯JSP方式实现用户登录功能 （一）实现思路 登录页面login.jsp，输入用户名和密码后，跳转到登录处理页面doLogin.jsp进行业务逻辑处理，登录成功，跳转到登录成功页面success.jsp，否则跳转到登录失败页面failure.jsp。
（二）实现步骤
1、创建Web项目 创建Java Enterprise项目，添加Web Application功能
设置项目名与保存位置
单击【Finish】按钮
在项目结构窗口里修改Artifact名 - LoginDemo01
编辑服务器配置，重新部署项目
2、创建登录页面 登录页面 - login.jsp
原代码 &lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;用户登录&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3 style="text-align: center"&gt;用户登录&lt;/h3&gt; &lt;form action="doLogin.jsp" method="post"&gt; &lt;table border="1" cellpadding="10" style="margin: 0px auto"&gt; &lt;tr&gt; &lt;td align="center"&gt;账号&lt;/td&gt; &lt;td&gt;&lt;input type="text" name="username"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align="center"&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input type="password" name="password"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr align="center"&gt; &lt;td colspan="2"&gt; &lt;input type="submit" value="登录"/&gt; &lt;input type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03d1c498adbc689508dcfb03bc50c56f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/601/">«</a>
	<span class="pagination__item pagination__item--current">602/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/603/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>