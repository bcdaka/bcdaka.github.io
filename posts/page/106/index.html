<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e9915a36f561d2a1acec1b4eb4a8ac8/" rel="bookmark">
			微服务安全——OAuth2.1详解、授权码模式、SpringAuthorizationServer实战、SSO单点登录、Gateway整合OAuth2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Spring Authorization Server介绍OAuth2.0协议介绍角色OAuth2.0协议的运行流程应用场景授权模式详解客户端模式密码模式授权码模式简化模式token刷新模式 OAuth 2.1 协议介绍授权码模式+PKCE扩展设备授权码模式拓展授权模式 OpenID Connect 1.0协议Spring Authorization Server 实战认证/授权服务器搭建搭建授权码模式测试刷新令牌测试客户端模式测试 oauth2客户端搭建说明搭建客户端客户端测试 oauth2资源服务器搭建说明搭建资源服务器资源服务器测试自定义异常处理类 基于数据库存储改造授权服务器客户端注册信息存储改造用户信息存储改造测试 SSO单点登录实战实现思路授权服务器搭建订单服务搭建商品服务搭建单点登录测试 微服务网关整合Oauth2安全认证实战实现思路配置授权服务器网关接入OAuth2资源服务器配置测试 Spring Authorization Server介绍 Spring Authorization Server 是一个框架，它提供了 OAuth 2.1 和 OpenID Connect 1.0 规范以及其他相关规范的实现。
它建立在 Spring Security 之上，为构建 OpenID Connect 1.0 身份提供者和 OAuth2 授权服务器产品提供了一个安全、轻量级和可定制的基础。
说白了，Spring Authorization Server 就是一个认证（授权）服务器。
官方主页：https://spring.io/projects/spring-authorization-server
因为随着网络和设备的发展，原先的 OAuth 2.0 已经不能满足现今的需求了，OAuth 社区对 OAuth 2.0 中的几种授权模式进行了取舍和优化，并增加一些新的特性， 于是推出了 OAuth 2.1
而原先的 Spring Security OAuth 2.0 使用的是 OAuth 2.0 协议，为满足新的变化，Spring Security 团队重新写了一套叫 Spring Authorization Server 的认证授权框架来替换原先的 Spring Security OAuth 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e9915a36f561d2a1acec1b4eb4a8ac8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c79bdcd125fba3c8f131abd94b762fc/" rel="bookmark">
			[练习]如何使用递归算法？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎥 个人主页：Dikz12🔥个人专栏：算法(Java)📕格言：吾愚多不敏，而愿加学欢迎大家👍点赞✍评论⭐收藏 目录
1. 递归概述
2.汉诺塔问题 题目描述​编辑
题解 代码实现 3.合并两个有序链表
题目描述 题解 代码实现 4.反转链表
题目描述 题解 ​编辑 代码实现
5.Pow(x, n)
题目描述 题解 代码实现 1. 递归概述 1. 什么是递归？
简单来说，就是函数自己调用自己的情况.
2. 为什么用递归？
本质上：主问题 --&gt; 相同的子问题； 子问题 --&gt; 相同的子问题.
3. 如何理解递归？ 1.递归展开的细节图.（不用有强迫症，每道题都展开，就得不偿失了）
2. 二叉树的题目.
3.宏观看待递归的过程
不要在意递归的展开图把递归当作一个黑盒相信这个黑盒一定能完成这歌任务. 4.如何写好一个递归？ 1.先找到相同的子问题！ ---&gt; 函数头的设计
2. 只关心某一个子问题是如何解决的. ----&gt; 函数体书写
3. 注意一下递归函数的出口即可. 2.汉诺塔问题 题目描述 题解 可以被解释为： 1 . 对于规模为 n 的问题，我们需要将 A 柱上的 n 个盘⼦移动到C柱上。 2. 规模为 n 的问题可以被拆分为规模为 n-1 的⼦问题： 将 A 柱上的上⾯ n-1 个盘⼦移动到B柱上。 将 A 柱上的最⼤盘⼦移动到 C 柱上，然后将 B 柱上的 n-1 个盘⼦移动到C柱上。 当问题的规模变为 n=1 时，即只有⼀个盘⼦时，我们可以直接将其从 A 柱移动到 C 柱。 综上从宏观的角度分析：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c79bdcd125fba3c8f131abd94b762fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8e1274e022e8817f7e7c145579dfbe3/" rel="bookmark">
			2024年河北省研究生数学建模竞赛A题循环立体投送问题研究思路代码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024年河北省研究生数学建模题目分析
2024河北省研究生数学建模竞赛ABCD题完整成品论文和全部问题的解题代码更新如下↓↓↓↓
https://www.yuque.com/u42168770/qv6z0d/hvqwcxdvez0o2gwe
四个题目需要使用的主要模型和算法：
A题：线性规划和整数规划、启发式算法（遗传算法、模拟退火）、多目标优化、动态规划、贪心算法、约束满足问题（CSP）求解
B题：能源系统动态建模、时间序列分析（ARIMA、SARIMA）、机器学习算法（LSTM、GRU、SVR）、数值天气预报（NWP）模型、模型预测控制（MPC）、蒙特卡洛模拟
C题：RANSAC算法、深度学习模型（PointNet、PointNet++、VoxelNet、SECOND）、2D语义分割网络（U-Net、DeepLab）、半监督学习算法、自监督学习、主动学习、图卷积网络（GCN）
D题：自然语言处理技术（词嵌入、BERT）、强化学习（DQN、策略梯度）、机器学习分类器（SVM、随机森林）、层次分析法（AHP）、主题模型（LDA）、时间序列分析（ARIMA）、社会网络分析、深度学习模型（CNN、RNN）
难度排序（从难到易）：
C题：室外三维点云数据分割识别，涉及复杂的3D数据处理和深度学习技术，需要处理大规模、高维度的点云数据，包含半监督学习等高级机器学习任务
B题：海岛多能互补耦合能量管理及控制研究，需要建立复杂的多能源系统动态模型，涉及多种可再生能源的预测和协同优化，要求设计智能能源管理策略
D题：基于人工智能的新型储能专利信息检索分析研究，需要处理大规模文本数据，涉及多个人工智能技术的综合应用，要求对专利分析和产业分析有深入理解
A题：循环立体投送问题研究，主要涉及运筹学和优化理论，问题结构相对清晰，约束条件明确，可以使用经典的数学规划和优化方法
C题因为涉及最新的3D点云处理技术和复杂的机器学习任务，相对较难。A题虽然也很复杂，但因为问题结构较为传统，可以用相对成熟的方法解决。
下面是河北省研究生数学建模A题的部分建模文档和代码：
问题一模型的建立与求解 思路分析 2024河北省研究生数学建模竞赛A题问题一要求我们估算执行某建制单位274个作战班和17类装备的投送任务所需的载具（直升机和气垫艇）以及母舰的最少需求量。这是一个典型的资源分配和容量规划问题，涉及多种类型的装备、人员和载具，需要考虑各种约束条件和优化目标。在进行详细分析之前，我们需要充分理解问题的复杂性和各个要素之间的关系。
首先，我们需要考虑待投送的人员和装备的特性。274个作战班代表了大量的人力资源，每个作战班有不同的人数和装备要求。17类装备则代表了多样化的物资，每种装备都有其独特的尺寸、重量和数量。这些因素直接影响到载具的选择和装载方案。我们需要仔细分析每种装备的参数，包括重量、长度、宽度以及相应的调整系数，以确保准确计算它们在载具和母舰上的实际占用空间。
其次，我们需要深入理解载具（直升机和气垫艇）的特性和限制。每种载具都有其独特的载重能力、空间限制和操作要求。例如，直升机更适合快速、轻量级的投送任务，而气垫艇则更适合大型、重型装备的运输。我们需要考虑载具的数量如何影响整体投送效率，以及如何在不同类型的载具之间分配任务以实现最佳的资源利用。
再次，母舰作为整个投送系统的基础，其容量和性能直接影响到整个任务的执行效果。我们需要考虑母舰的装载能力、可容纳的载具数量以及各种区域的空间限制。特别是，我们需要注意W1型和W2型母舰之间的差异，以及如何最优化地利用这两种类型的母舰。
最后，我们需要考虑整个投送过程的动态性和连续性。虽然问题一并未直接要求考虑投送顺序和编波要求，但在估算最少需求量时，我们仍然需要考虑到整个投送过程的可行性和效率。这涉及到如何在多次往返中最大化载具的利用率，以及如何在保证投送任务完成的前提下minimizing总体资源需求。
基于以上分析，我们可以构建一个综合考虑多种因素的优化模型。这个模型需要平衡多个目标，包括minimizing载具和母舰的数量、maximizing载具的利用率、确保所有人员和装备都能被成功投送等。我们可以使用混合整数线性规划（Mixed Integer Linear Programming，MILP）作为基本框架，结合一些启发式算法来处理问题的复杂性和非线性特征。
在模型中，我们需要定义决策变量来表示每种类型载具和母舰的数量，以及它们如何分配给不同的人员和装备。我们还需要建立一系列约束条件，包括载重限制、空间限制、装载要求等。目标函数可以设定为minimizing总体资源需求，即载具和母舰的加权总和。
考虑到问题的规模和复杂性，我们需要采用一些简化假设和近似方法。例如，我们可以假设每种类型的装备可以被均匀地分配到不同的载具上，而不是考虑每件装备的具体位置。我们也可以使用一些启发式规则来指导载具和母舰的分配，例如优先使用大型载具运输重型装备，使用小型载具运输轻型装备和人员。
在求解过程中，我们可以采用分阶段的方法。首先，我们可以使用一个简化的模型来获得初始解，然后逐步增加约束条件和复杂性，使用局部搜索或元启发式算法来改进解。我们还可以考虑使用场景分析或敏感性分析来评估不同参数设置对最终结果的影响。
通过这种综合的方法，我们可以得到一个既考虑了问题的复杂性，又具有实际可操作性的解决方案。这个方案不仅能够提供载具和母舰的最少需求量估算，还能为后续的详细规划和优化提供有价值的洞察。
多维资源优化配置模型建立 基于上述思路分析，我们可以构建一个多维资源优化配置模型来解决问题一。这个模型旨在综合考虑人员、装备、载具和母舰之间的复杂关系，以实现资源的最优配置。该模型的核心思想是将整个投送任务视为一个多阶段、多目标的优化问题，通过合理分配和调度各种资源，实现总体投送效率的maximizing和资源需求的minimizing。
首先，我们需要定义决策变量。让 x i x_i xi​表示第i种类型载具（包括不同型号的直升机和气垫艇）的数量， y j y_j yj​表示第j种类型母舰的数量。我们还需要引入辅助变量 z i j k z_{ijk} zijk​来表示第i种载具在第j种母舰上运载第k种人员或装备的数量。
接下来，我们需要建立目标函数。考虑到问题要求minimizing载具和母舰的需求量，我们可以将目标函数设定为：
Minimize F = ∑ i w i x i + ∑ j v j y j \text{Minimize} \quad F = \sum_{i} w_i x_i + \sum_{j} v_j y_j MinimizeF=i∑​wi​xi​+j∑​vj​yj​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8e1274e022e8817f7e7c145579dfbe3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8df6788ea893ead746ef0d8d1f05a8c3/" rel="bookmark">
			easyExcel 3.x以上版本导入数据后，再把错误信息导出，外加自定义RGB背景色、行高、宽度等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		easyExcel 3.x以上版本导入数据后，再把错误信息导出，外加自定义RGB背景色
背景 由于项目中用的easypoi导入的数据量大了，会导致OOM的问题，所以要求更换为easyExcel框架做导入。话不多说，这里只做一个导入的示例，还有把遇到的一些问题列出来，大家根据业务需要随机应变。文章参考了其他大佬写的博客，这里把参考的大佬博客列出来：
官方文档：https://easyexcel.opensource.alibaba.com/docs/3.0.x
https://blog.csdn.net/qq_36978700/article/details/123425954
https://blog.csdn.net/qq_29834241/article/details/133786536
https://blog.csdn.net/wjs_007/article/details/135118539
https://www.cnblogs.com/mike-mei/p/17732227.html
引入依赖 //我的项目用的是gradle implementation ('com.alibaba:easyexcel:3.0.5') //maven &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;3.0.5&lt;/version&gt; &lt;/dependency&gt; //可能会用到alibaba的fastjson implementation 'com.alibaba:fastjson:1.2.83' Controller代码 @PostMapping("/import") public JSONResult importExcel(@RequestParam(name = "file") MultipartFile file, HttpServletResponse response) { try { //实现easyExcel的解析对象 DemoDataListener demoDataListener = new DemoDataListener(); //读取excel文件 EasyExcel.read(file.getInputStream(), DemoData.class, demoDataListener).sheet().doRead(); List&lt;Map&lt;String, Object&gt;&gt; failDataList = demoDataListener.getFailDataList(); //导出错误数据 export(dataList(failDataList), response); } catch (Exception e) { log.error("导入配置异常", e); } return JSONResult.ok("成功"); } private void export(List&lt;DemoData&gt; dataList,HttpServletResponse response) { // 头的策略 WriteCellStyle headWriteCellStyle = new WriteCellStyle(); // 背景设置为红色 headWriteCellStyle.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8df6788ea893ead746ef0d8d1f05a8c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b7b731c0cc5af40cd31f24162d4cf31/" rel="bookmark">
			golang设置远程调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 目标机器构建安装dlv
https://github.com/go-delve/delve
go build之后将编译号的dlv命令路径添加到PATH里
2. 目标机器下载源代码并且运行dlv
dlv debug --headless --listen=:2345 --api-version=2 --accept-multiclient
3.本机添加go remote
4. 设置断点即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4b58a19cfbb730a90c7dde769e1bc18/" rel="bookmark">
			LLaMA-Factory：手把手教你从零微调大模型！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 随着人工智能技术的飞速发展，大型语言模型（LLM）在自然语言处理（NLP）领域扮演着越来越重要的角色。然而，预训练的模型往往需要针对特定任务进行微调，以提高其在特定领域的性能。LLaMA-Factory作为一个高效、易用的微调工具，为广大开发者提供了极大的便利。本文将详细介绍如何使用LLaMA-Factory从零开始微调大模型，帮助读者快速掌握这一技术。
一、模型微调讲解 1、什么是模型微调？ 在深度学习领域，模型微调通常指的是在预训练模型的基础上进行的进一步训练。预训练模型是在大量数据上训练得到的，它已经学习到了语言的基本规律和丰富的特征表示。然而，这些模型可能并不直接适用于特定的任务或领域，因为它们可能缺乏对特定领域知识的理解和适应性。
模型微调通过在特定任务的数据集上继续训练预训练模型来进行，使得模型能够学习到与任务相关的特定特征和知识。这个过程通常涉及到模型权重的微幅调整，而不是从头开始训练一个全新的模型。
2、微调的过程 微调过程主要包括以下几个步骤：
1)数据准备：收集和准备特定任务的数据集。
2)模型选择：选择一个预训练模型作为基础模型。
3)迁移学习：在新数据集上继续训练模型，同时保留预训练模型的知识。
4)参数调整：根据需要调整模型的参数，如学习率、批大小等。
5)模型评估：在验证集上评估模型的性能，并根据反馈进行调整。
3、微调的优势 微调技术带来了多方面的优势：
资源效率：相比于从头开始训练模型，微调可以显著减少所需的数据量和计算资源。
快速部署：微调可以快速适应新任务，加速模型的部署过程。
性能提升：针对特定任务的微调可以提高模型的准确性和鲁棒性。
领域适应性：微调可以帮助模型更好地理解和适应特定领域的语言特点。
通过微调，可以使得预训练模型在这些任务上取得更好的性能，更好地满足实际应用的需求。
二、LLaMA-Factory讲解 LLaMA-Factory是一个开源的模型微调框架，致力于简化大型语言模型的定制过程。它集成了多种训练策略和监控工具，提供了命令行和WebUI等多种交互方式，大幅降低了模型微调的技术门槛。
1、核心功能 多模型兼容：支持包括LLama、Mistral、Falcon在内的多种大型语言模型。训练方法多样：涵盖全参数微调及LoRA等先进的微调技术。用户界面友好：LLama Board提供了一个直观的Web界面，使用户能够轻松调整模型设置。监控工具集成：与TensorBoard等工具集成，便于监控和分析训练过程。 2、LLaMA-Factory特点 易用性：简化了机器学习算法的复杂性，通过图形界面即可控制模型微调。微调效率：支持DPO、ORPO、PPO和SFT等技术，提升了模型微调的效率和效果。参数调整灵活性：用户可根据需求轻松调整模型参数，如dropout率、epochs等。多语言支持：界面支持英语、俄语和中文，面向全球用户提供服务。 3、使用场景 LLaMA-Factory适用于广泛的NLP任务，包括但不限于：
文本分类：实现情感分析、主题识别等功能。序列标注：如NER、词性标注等任务。文本生成：自动生成文本摘要、对话等。机器翻译：优化特定语言对的翻译质量。 LLaMA-Factory通过其强大的功能和易用性，助力用户在自然语言处理领域快速实现模型的定制和优化。
三、安装LLaMA Factory 在本章节中，我们将指导您如何安装和设置LLaMA Factory，一个用于微调大型语言模型的工具。请按照以下步骤操作，以确保您能够顺利地使用LLaMA Factory。
1、准备工作 首先，确保您的开发环境中已经安装了Python3.9或更高版本。这可以通过Python的官方网站下载安装，或者使用包管理器进行安装。
1）显卡选择
24 GB显存的A10：建议使用至少这个规格的实例，或者更高规格的实例以满足可能更大的计算需求。
2）镜像选择：
PyTorch深度学习框架版本为2.1.2。Python 3.10、CUDA 11.2（cu121），CUDA是NVIDIA提供的用于通用并行计算的编程模型和API。、Ubuntu 22.04 LTS（长期支持版本）操作系统。
2、获取LLaMA-Factory 打开您的终端或命令行界面，然后执行以下命令来克隆LLaMA-Factory的代码仓库到本地：
git clone --depth 1 https://github.com/hiyouga/LLaMA-Factory.git 这将创建一个名为LLaMA-Factory的文件夹，包含所有必要的代码和文件。
3、安装依赖 在安装LLaMA-Factory之前，您需要确保安装了所有必要的依赖。进入克隆的仓库目录，然后执行以下命令来安装依赖：
cd LLaMA-Factory pip install -e .[metrics] 这个命令将安装LLaMA-Factory及其所有必需的附加组件，用于模型的评估和分析。
4、卸载可能冲突的包 如果在安装过程中与其他库发生冲突，您可能需要先卸载这些库。例如，如果vllm库与LLaMA-Factory不兼容，可以使用以下命令卸载：
pip uninstall -y vllm 5、LLaMA-Factory版本检查 安装完成后，您可以通过运行以下命令来检查LLaMA-Factory是否正确安装以及其版本号：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4b58a19cfbb730a90c7dde769e1bc18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/915b8d7c37c9ee189792f056dba586c6/" rel="bookmark">
			masscan 端口扫描——（Golang 简单使用总结）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前言 最近要做一个扫描 ip 端口的功能
扫描的工具有很多，但是如何做到短时间扫描大量的 ip 是个相对困难的事情。
市场上比较出名的工具有 masscan和nmap
masscan 支持异步扫描，对多线程的利用很好，同时仅仅支持 syn 半开扫描，这让 masscan 对端口进行粗糙扫描的性能达到了非常高的地步
半开扫描是指发送一个 SYN 包（SYN-SENT 状态），等待目标主机回复 SYN+ACK 包（SYN-RECEIVED 状态），然后发送一个 RST 包（ESTABLISHED 状态），以终止连接。半开扫描的优点是速度快，因为它只需要发送一个 SYN 包和一个 RST 包，而不需要完成整个三次握手过程。缺点是容易被一些防火墙和 IDS/IPS 检测到，因为它不是一个完整的连接过程
缺点就是结果比较模糊，无法知道是否是被防火墙 ban 掉的端口
那么用 mmsacn 作为第一层的预处理是很好用的
2. masscan 的安装 准备 (这里不提倡使用yum，yum的版本比较低 )
git 工具c 编译环境 克隆、编译 git clone https://github.com/robertdavidgraham/masscan cd masscan make 安装 make install 测试是否安装 masscan --version 3. masscan 的简单使用 masscan 的主要关乎性能的参数有两个
选项意义/ --rate发送包的速率，和扫描端口速度正相关/ --wait发送完包等待时间，和性能负相关，不过时间越久可以扫到的端口就可以越多 实际上，masscan 扫描速度非常快， masscan rate 1000 扫描一个 C 段（256 个 IP 地址）的主机，需要约 3-5 秒钟的时间，一般来说不用担心 masscan 性能不足的问题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/915b8d7c37c9ee189792f056dba586c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d5c7a846a979bc50646b828ef4079f5/" rel="bookmark">
			AI论文阅读笔记 | Timer: Generative Pre-trained Transformers Are Large Time Series Models(ICML 2024)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本信息 题目：Timer: Generative Pre-trained Transformers Are Large Time Series Models会议：ICML 2024原文：https://arxiv.org/abs/2402.02368源码：​​​​​​​https://github.com/thuml/Timer 二、基本内容 1、解决什么问题 虽然深度学习对时间序列的分析做出了显著的贡献，但在数据稀缺的真实世界场景中，深度模型可能会遇到性能瓶颈，而这些瓶颈可能由于当前基准测试中小模型的性能饱和而被掩盖。现有的小模型缺乏大模型所展示的少样本泛化（few-shot generalization）、可扩展性（scalability）和任务通用性（task generality）。 2、怎么解决 构建了统一的时间序列数据集 （Unified Time Series Dataset ——UTSD） 本文建立了筛选高质量数据和堆叠的时间序列语料库的层次标准，通过对公开的时间序列数据集进行聚合，并对聚合后的数据进行协同处理，构建了具有层次化能力的统一时间序列数据集（UTSD)如图所示。包含7个域，10亿个时间点（UTSD-12G）,涵盖了时间序列分析的典型场景。
数据集链接：https://huggingface.co/datasets/thuml/UTSD
训练策略——单序列序列（S3）格式 采用生成式预训练方法，将单序列序列（S3）作为不同时间序列的标准语句，如下图所示。不同于自然语言 ，序列的幅度、频率、平稳性、数据集的变量数、序列长度等差异使得构造统一的时间序列并非易事。本文提出将异构时间序列转换为单序列序列（S3），保留了具有统一上下文长度的序列变化模式。模型观察了不同时间段、不同数据集的序列，增加了预训练的难度，使模型更关注时间变化。S3不需要时间对齐，这适用于广泛的单变量和不规则时间序列。
采用生成式的预训练目标 采用了GPT风格的生成式预训练目标，通过预测下一个时间点来进行预训练。将时间序列的预测、插补和异常检测转化为一个统一的生成式任务，允许模型学习时间序列的生成过程，从而在下游任务中展现出更好的泛化能力。 Timer（a large-scale pre-trained Time Series Transformer）的提出 基于以上几点，论文提出了Timer，采用与大语言模型类似的解码器结构，具备灵活的上下文长度和自回归生成能力。在多个数据集和多种任务中表现出色。
3、取得了什么效果 1、时间序列预测 数据集：ETT、ECL、Traffic、Weather、PEMS
SOTA: iTransformer （ICLR 2024）
实验：在不同的数据稀缺性（100%，75%，50%，25%，20%.......1%）下 ,对比了从头开始训练的Timer（虚线)和在UTSD（USTD-12G）上预训练后的Timer（实线）的性能。
结果：
Timer的性能受数据量减少的影响小于基线，随着数据数量的下降，Timer的性能均超过基线，且预训练之后的模型表现比从头训练的好。
2、 插补 数据集：ETT、ECL、Traffic、Weather、PEMS
baseline: TimesNet （ICLR 2023）
实验：在数据稀缺度为5%，20%，100%的情况下，Timer在44个插补任务中表现分别优于TimesNet100%，86.4%，56.8%。
对于预训练的有效性，以插补错误减少率来表示促进作用，其中，预训练在下游样本只有5%的情况下始终产生积极影响。
3、 异常检测 数据集：UCR Anomaly Archive(包含250个时间序列数据集)
baseline: TimesNet （ICLR 2023）、Anomaly Transformer（ICLR 2022）
实验：首先在训练集上训练一个预测模型，并计算预测序列和真实值之间的MSE。将置信度高于α的分段标记为异常的潜在位置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d5c7a846a979bc50646b828ef4079f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ecaabf3f597d4939cff6d3e82d49f8f/" rel="bookmark">
			A*(star)算法原理讲解以及程序实现(基于Python)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A*搜索算法原理及其程序实现 去我的个人博客观看，观感更佳哦，😙😙
运行环境推荐 anaconda3，集成了常用的用于科学计算的包，以及对应的Python解释器(本例使用的解释器版本为3.9.12)编辑器：VScode 摘要 本文将以迷宫探索最优路径为例，讲解A *搜索算法原理及其程序实现。
在原理讲解部分，首先从为什么要使用A *搜索算法和A *搜索算法的全局最优逻辑出发，讲解A *算法的原理。其次对A *的行动函数g(n)和启发函数h(n)的细节进行了讲解说明，并补充了启发函数的选择对于A *算法的影响。
在程序实现部分，首先从程序流程框图出发，解释A *算法的流程。其次按函数的类划分并讲解主要代码，接着展示程序的运行结果，最后对A *算法进行总结分析。
原理讲解 为什么要使用A*搜索算法？ 搜索算法的核心是从起点出发，找到一条到达目标的最优（路径最短/成本最低/两者兼具）的路径。
根据不同需求，我们通常会选择：广度优先搜索（BFS）、Dijkstra算法（统一成本搜索）和贪婪优先搜索之一，下面我们逐个分析其优劣。
广度优先算法：不考虑每一步的移动成本，不断拓展边界，直到边界到达目标点，通常耗费大量时间。
Dijkstra算法：以BFS为基础，只考虑每一点的总移动成本，没有解决BFS耗费大量时间的问题。
贪婪优先搜索：只考虑到达终点的估计距离，能较快寻找到目标，但是无法保证路线全局最优。
A*搜索算法：以BSF为基础，综合考虑了总移动成本和到达终点的估计距离，巧妙地叠加了Dijkstra算法的成本最低和贪婪优先搜索的速度最优，具有更好的性能。
下面是A * 算法的核心公式：
f ( n ) = g ( n ) + h ( n ) f(n)=g(n)+h(n) f(n)=g(n)+h(n)
说明：f(n)是总的预期成本，g(n)是当前点到起点的总移动成本，h(n)是当前点到目标点的预期代价 A *搜索算法的全局最优逻辑 首先，对于搜索算法来说，想要减少搜索的时间，那就必须要在搜索最优路径时搜索尽量少的点，最好搜索的全部节点恰好就是我们的全局最优路径。但显然，像贪婪优先搜索那样，只考虑当前点到目标点的预期距离的话，往往只能寻找到局部最优。
换句话说，贪婪优先算法只考虑单一的：当前点到目标点的估计距离，这显然不足以作为全局最优的参考指标。但是它赋予了程序有目的地前往终点方向的能力
而我们知道，BFS、Dijkstra实质上是对所有节点进行遍历，其中后者是对前者的优化，保证了起点到每一个中间点都是成本最优的选择。
那我们结合一下Dijkstra（保障当前点对起点是成本最优的）和贪婪优先搜索（保障当前点到终点的方向是最优的）
就可以构建一个新的参考指标：用于保证每一次从当前点选择下一个节点的时候都是全局最优的。
对行动函数 g(n) 的细节说明（可以简单理解g是小兵） 在A *算法中对于g(n)，也就是从起点到当前点的总移动代价（沉没成本），如果我们只考虑上下左右四个方向的话，并不需要额外考虑每一步行动的代价（因为每一步都是相同的），但是如果我们从上下左右和四个边角都能被行动，那我们就需要考虑走斜边和直上直下的代价差异。
本样例中，所有的节点都是正方形，从而可知走斜边与直上直下的代价比值应为
2 : 1 \sqrt2:1 2 ​:1
我们为了方便计算，取1.4：1作为走斜边和直上直下的代价比值
对启发函数 h(n) 的讲解（可以简单理解h是领导） 在A *算法中对于h(n)，也就是对当前点到目标点的预期代价估计通常采用“距离”作为度量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ecaabf3f597d4939cff6d3e82d49f8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7a4bab354b8ed6b4bb30dd72b00e421/" rel="bookmark">
			Ruby、Python、Java 开发者必备：Codigger之软件项目体检
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在编程的广阔天地里，Ruby、Python 和 Java 开发者们各自凭借着独特的语言特性，构建着精彩纷呈的应用世界。然而，无论使用哪种语言，确保项目的高质量始终是至关重要的目标。而 Codigger 项目体检则成为了实现这一目标的得力助手，它能巧妙地适应不同语言的开发特点和需求。
对于 Ruby 开发者来说，动态性和灵活性是 Ruby 语言的魅力所在，但也容易导致一些难以察觉的运行时错误。Codigger之软件项目体检Software Project HealthCheck能够深入分析 Ruby 代码中的动态特性，检测可能出现的类型不一致、未定义变量等问题。通过精准的代码审查，帮助 Ruby 开发者提前发现并解决这些潜在的隐患，确保程序在复杂的运行环境中稳定运行。
Python 以其简洁易懂的语法和丰富的库而备受喜爱。然而，Python 开发者在追求高效开发的同时，可能会忽略一些代码规范和性能方面的细节。Codigger之软件项目体检针对 Python 语言的特点，重点检查代码的风格一致性，比如缩进、空格使用等。同时，还能对代码中的循环结构、函数调用等进行性能分析，提出优化建议，让 Python 项目在保持简洁的同时，拥有更出色的性能。
Java 作为一种强类型、面向对象的语言，其代码结构和设计模式至关重要。Codigger之软件项目体检为 Java 开发者提供了全面的类结构分析、继承关系检查以及对象使用合理性评估。它能够发现过度复杂的类层次结构、未充分封装的成员变量等问题，引导 Java 开发者遵循最佳的设计原则，从而提升代码的可维护性和可扩展性。
那么，如何利用项目体检来提升不同语言项目的质量呢？
首先，开发者们需要定期进行全面的代码体检。将项目代码导入Codigger之软件项目体检工具，获取详细的报告。对于报告中指出的问题，要认真分析其根源，并制定切实可行的改进计划。
其次，要将项目体检融入到开发流程中。在每个开发阶段结束后，及时进行体检，确保新添加的代码不会引入新的问题。
最后，团队成员之间可以共同探讨体检报告中的问题，分享经验和最佳实践。通过集体的智慧，不断优化项目代码，提升整体质量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a02805cd5108777f9b43adc2ea76a9a0/" rel="bookmark">
			SpringBoot详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概览与Spring的区别创建SpringBoot项目SpringBoot常用注解SpringBoot自动配置@SpringBootConfiguration@EnableAutoConfiguration SpringBoot配置管理SpringBoot嵌入式服务器SpringBoot测试 概览 SpringBoot是由Pivotal团队提供的全新框架，其设计目的是用来简化Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。SpringBoot提供了一种新的编程范式，可以更加快速便捷地开发Spring项目，在开发过程当中可以专注于应用程序本身的功能开发，而无需在Spring配置上花太大的工夫。
SpringBoot基于Sring4进行设计，继承了原有Spring框架的优秀基因。SpringBoot准确的说并不是一个框架，而是一些类库的集合。maven或者gradle项目导入相应依赖即可使用 SpringBoot，而无需自行管理这些类库的版本。
特点：
自动配置：SpringBoot提供自动配置功能，根据项目的依赖和环境自动设置 Spring应用程序，减少了手动配置的复杂度。启动器：SpringBoot提供“启动器”依赖集合，如 spring-boot-starter-web，简化了项目的依赖管理。嵌入式服务器：SpringBoot支持嵌入式服务器，如Tomcat、Jetty和Undertow，使得应用程序可以独立运行，无需外部Web服务器。生产级别的特性：SpringBoot具备生产级别的功能，包括健康检查、应用监控、日志管理等。Actuator 模块可以轻松监控和管理应用程序。无配置的约定：SpringBoot遵循“无配置”的原则，使用合理的默认值和约定，减少需要编写的配置代码。快速开发：SpringBoot的项目结构和默认配置帮助开发者快速启动新项目。内置工具和插件支持开发、测试和部署。 与Spring的区别 Spring和SpringBoot的最主要区别在于配置和启动的复杂性。
Spring和SpringBoot的主要区别在于配置和启动的复杂性。Spring框架需要大量的手动配置，包括XML配置文件或Java配置类，配置过程较为繁琐且易出错。此外，Spring应用程序通常需要部署到外部的Web服务器，并需要额外的步骤来启动和运行。
相比之下，SpringBoot提供了自动配置功能，可以根据项目的依赖自动设置应用程序，极大地简化了配置工作。它还支持嵌入式服务器，使得应用程序能够独立运行，无需外部 Web 服务器，且可以通过java -jar命令直接启动。这些特点使得SpringBoot更加适合快速开发和部署应用程序。
创建SpringBoot项目 在IDEA中使用Spring Initializr快速创建一个SpringBoot项目。
选择所需的依赖
SpringBoot项目通常包括以下几个主要部分：
在src/main/resources目录下创建application.properties或application.yml文件来配置应用程序。示例配置如下：
主应用类通常位于项目的根包，并使用@SpringBootApplication注解。
创建一个Controller处理HTTP请求并返回响应。使用@RestController注解定义控制器，使用@RequestMapping或@GetMapping处理请求。
在IDE中运行，右击主应用类并选择“Run”。
通过浏览器输入http://localhost:8081/api/hello 测试。
SpringBoot常用注解 在SpringBoot开发中，常用的注解简化了配置和开发流程。
@SpringBootApplication：标注在启动类上，它综合了@Configuration、@EnableAutoConfiguration和@ComponentScan注解，用于自动配置和组件扫描。@SpringBootApplication public class MyApplication { public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); } } @RestController：是一个组合注解，结合了@Controller和@ResponseBody。用于定义控制器类，并将返回的对象自动转换为JSON或XML格式，简化了RESTful API的开发。@RestController @RequestMapping("/api") public class MyController { @GetMapping("/hello") public String sayHello() { return "Hello, World!"; } } @Controller：用于定义一个SpringMVC 控制器类，它的主要目的是处理Web请求并返回视图，如JSP、Thymeleaf模板等。@Controller public class MyController { @GetMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a02805cd5108777f9b43adc2ea76a9a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a39a13721fdd8788d40cbdd318e9500/" rel="bookmark">
			Go-Zero 数据库实战：配置、建模与业务逻辑一体化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在之前的几篇文章中，我们深入学习了Go-Zero框架的实战应用，包括模板定制化、API定义、抽奖算法设计等内容。本文将继续探索Go-Zero框架的实践技巧，并介绍一些与数据库操作相关的主题。
在现代应用程序开发中，对数据库的操作是非常常见且重要的一部分。Go-Zero框架提供了强大的数据库支持，使得我们可以轻松地进行数据库访问和操作。本文将重点介绍如何使用Go-Zero框架进行数据库的增删改查（CRUD）操作，并提供详细的示例代码和解释。
在本文中，我们将使用MySQL数据库作为示例，并结合Go-Zero框架的相关组件，如数据模型（Model）、事务处理、连接池等，来展示数据库操作的最佳实践。无论你是初学者还是有一定经验的开发者，本文都将为你提供有用的信息和技巧，帮助你更好地理解和应用Go-Zero框架中的数据库操作。
在阅读本文之前，请确保你已经按照前几篇文章中的说明进行了必要的准备工作，包括安装所需的工具和设置项目环境。同时，本文假设你已经具备一定的数据库基础知识，如表的创建、数据的插入和查询等。
通过学习本文，你将掌握以下内容：
如何配置和初始化数据库连接；如何使用Go-Zero框架的Model组件进行数据表的创建和映射；如何进行常见的CRUD操作，包括数据的插入、查询、更新和删除；如何处理数据库事务；实现用户注册业务逻辑。 我们鼓励你跟随示例代码，动手实践，并根据自己的需求进行定制和扩展。无论是为了学习Go-Zero的数据库操作，还是为了解决具体的业务问题，本文都将为你提供实用的指导和技巧。
祝你阅读愉快，并从中获得所需的知识和灵感！
实战前准备 本次实战我们是建立在（六）Go-Zero实战之docker开发环境部署 基础之上，如果没有学习过，可以点击跳转学习，然后再看本文哦！
本次实战采用的是docker部署，请提前准备好相关环境，关于docker环境的搭建在（六）Go-Zero实战之docker开发环境部署 中也有讲解，不了解小伙伴建议先行实战docker环境搭建哦！
目录结构说明 在app下面我们将会新建一个服务comment，表示晒单评论服务，deploy/sql存放的是我们的建表语句，相关语句将会在接下来的讲解中给大家。 实战 配置docker组件 在docker-commpose-env.yml中添加如下配置mysql mysql: image: mysql/mysql-server:8.0.28 container_name: mysql environment: # 时区上海 - Time zone Shanghai (Change if needed) TZ: Asia/Shanghai # root 密码 - root password MYSQL_ROOT_PASSWORD: xxxxxx #这里填上mysql的密码 ports: - 33069:3306 volumes: # 数据挂载 - Data mounting - ./data/mysql/data:/var/lib/mysql # 日志 command: # 将mysql8.0默认密码策略 修改为 原先 策略 (mysql8.0对其默认策略做了更改 会导致密码无法匹配) # Modify the Mysql 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a39a13721fdd8788d40cbdd318e9500/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad3720921ef5106a42a7bdc29c2a3345/" rel="bookmark">
			EasyExcel 初使用—— Java 实现读取 Excel 功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在我们项目的开发中啊，前端有时候会传送 Excel 文件给后端（Java）去解析，那我们作为后端该如何实现对 Excel 文件的解析和数据读取呢？说到这我就不得不推荐 EasyExcel 了！
EasyExcel 介绍 引用下官方对于 EasyExcel 介绍：EasyExcel是一个基于Java的、快速、简洁、解决大文件内存溢出的Excel处理工具。他能让你在不用考虑性能、内存的等因素的情况下，快速完成Excel的读、写等功能。
官方网址：EasyExcel官方文档 - 基于Java的Excel处理工具 | Easy Excel
快速上手 EasyExcel 前置工作 先创建一个 Spring Boot 工程，并在 pom.xml 文件添加 EasyExcel 和 Lombok 依赖。
&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;3.1.1&lt;/version&gt; &lt;/dependency&gt; 知道表头 如果我们知道 Excel 数据的表头，即每列数据的类型包括有多少列时就可以用此方法读取 Excel 文件数据。
我们以下图数据为例，对改 Excel 中的数据进行获取和处理。
方法一： 首先我们创建一个名为 ExcelData 的 Java 对象，共有两个属性，分别是 date（日期列数据）和 useNum（用户列数据），每个属性对应 Excel 每列某一行中的数据。那么很显而易见，每一行的数据就是一个 ExcelData 对象，所有行的数据合起来就是一个泛型为 ExcelData 的 ExcelData 的集合。
@Data public class ExcelData implements Serializable { /** * 对应表格的日期列 */ private String date; /** * 对应表格的用户数列 */ private Integer userNum; } 随后编写一个测试类，并在其中编写测试方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad3720921ef5106a42a7bdc29c2a3345/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e815b0ec94a7d0834a9f7d029044030/" rel="bookmark">
			使用Vue3构建一个图像画廊，支持图片上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在现代网页开发中，图像画廊一直是一个受欢迎的功能。它不仅可以展示图片，还能为用户提供友好的互动体验。在这篇文章中，我们将使用Vue3构建一个简单的图像画廊，并实现图片上传功能。我们将使用Vue3的Composition API，特别是setup语法糖，使我们的代码更加简洁和易于维护。
项目准备 在开始之前，我们需要一个基本的Vue3项目。你可以使用Vue CLI或者直接使用Vite快速创建一个新的Vue3项目。以下是使用Vite创建Vue3项目的步骤：
npm create vite@latest my-image-gallery --template vue cd my-image-gallery npm install 启动项目后，在浏览器中访问 http://localhost:3000，你将看到一个空白页面。
设计画廊组件 我们的画廊将包括三个主要部分：
图片上传区图片预览区图片画廊展示区 我们来创建一个名为 ImageGallery.vue 的组件，在该组件中实现上述功能。
创建 ImageGallery.vue 在 src/components 目录下，创建一个新的文件 ImageGallery.vue，并添加以下代码：
&lt;template&gt; &lt;div class="image-gallery"&gt; &lt;h1&gt;图像画廊&lt;/h1&gt; &lt;div&gt; &lt;input type="file" @change="onFileChange" accept="image/*" multiple /&gt; &lt;/div&gt; &lt;div class="preview-container"&gt; &lt;h2&gt;预览&lt;/h2&gt; &lt;div class="image-preview" v-if="images.length &gt; 0"&gt; &lt;img v-for="(image, index) in images" :key="index" :src="image" alt="Image Preview" /&gt; &lt;/div&gt; &lt;p v-else&gt;没有图像可预览&lt;/p&gt; &lt;/div&gt; &lt;div class="gallery"&gt; &lt;h2&gt;画廊展示&lt;/h2&gt; &lt;div class="image-gallery-display"&gt; &lt;img v-for="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e815b0ec94a7d0834a9f7d029044030/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83b54223eb6f1d171f2a824b049472b8/" rel="bookmark">
			引入pytorch 报错 Error loading\\Lib\\site-packages\\torch\\lib\\fbgemm.dll\ or one of its dependences
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在引入pytorch模块时，出现了Error loading “c:\Users\Noor\anaconda3\envs\DL\Lib\site-packages\torch\lib\fbgemm.dll” or one of its dependencies.
解决方案如下：
方案1：参照https://blog.csdn.net/cwr888/article/details/139095439 提供的方法重新进行了安装（未生效）
方案2：下载Dependencies
下载地址：https://github.com/lucasg/Dependencies/tree/v1.11.1
下载完成并解压，启动DependenciesGui.exe
找到报错的dll的位置，在DependenciesGui.exe中的file→open打开dll的位置，我出现的问题如下
缺少libomp140.x86_64.dll。解决方法：在https://www.dllme.com/dll/files/libomp140_x86_64#google_vignette 下载某一个版本的dll文件，放到C:\Windows\System32中。
问题解决！
如果是缺少vcomp140.dll文件可以参考https://blog.csdn.net/Changxing_J/article/details/140489278
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a95f1188829a0b406cc7dc52da7fb640/" rel="bookmark">
			2024河北省研究生数学建模竞赛C题室外三维点云数据分割识别思路代码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024年河北省研究生数学建模题目分析
四个题目需要使用的主要模型和算法：
A题：线性规划和整数规划、启发式算法（遗传算法、模拟退火）、多目标优化、动态规划、贪心算法、约束满足问题（CSP）求解
B题：能源系统动态建模、时间序列分析（ARIMA、SARIMA）、机器学习算法（LSTM、GRU、SVR）、数值天气预报（NWP）模型、模型预测控制（MPC）、蒙特卡洛模拟
C题：RANSAC算法、深度学习模型（PointNet、PointNet++、VoxelNet、SECOND）、2D语义分割网络（U-Net、DeepLab）、半监督学习算法、自监督学习、主动学习、图卷积网络（GCN）
D题：自然语言处理技术（词嵌入、BERT）、强化学习（DQN、策略梯度）、机器学习分类器（SVM、随机森林）、层次分析法（AHP）、主题模型（LDA）、时间序列分析（ARIMA）、社会网络分析、深度学习模型（CNN、RNN）
难度排序（从难到易）：
C题：室外三维点云数据分割识别，涉及复杂的3D数据处理和深度学习技术，需要处理大规模、高维度的点云数据，包含半监督学习等高级机器学习任务
B题：海岛多能互补耦合能量管理及控制研究，需要建立复杂的多能源系统动态模型，涉及多种可再生能源的预测和协同优化，要求设计智能能源管理策略
D题：基于人工智能的新型储能专利信息检索分析研究，需要处理大规模文本数据，涉及多个人工智能技术的综合应用，要求对专利分析和产业分析有深入理解
A题：循环立体投送问题研究，主要涉及运筹学和优化理论，问题结构相对清晰，约束条件明确，可以使用经典的数学规划和优化方法
C题因为涉及最新的3D点云处理技术和复杂的机器学习任务，相对较难。A题虽然也很复杂，但因为问题结构较为传统，可以用相对成熟的方法解决。
2024河北省研究生数学建模竞赛ABCD题完整成品论文和全部问题的解题代码更新如下↓↓↓↓
https://www.yuque.com/u42168770/qv6z0d/hvqwcxdvez0o2gwe
下面是2024河北省研究生数学建模C题的部分建模文档和代码：
问题一模型的建立与求解 C题模型的建立与求解 问题一模型的建立与求解 思路分析 2024河北省研究生数学建模C题问题一要求我们研究三维点云数据中地面点和非地面点的分割算法模型。这是一个典型的点云分割问题，在自动驾驶、环境监测和城市建模等领域具有广泛的应用。地面点分割是点云处理的基础步骤，其准确性直接影响后续的物体识别和场景理解。在进行详细分析之前，我们需要充分理解问题的复杂性和挑战。
首先，我们需要认识到室外三维点云数据的特性。室外场景通常包含复杂的地形变化，如平地、斜坡、台阶等，这使得简单的平面拟合方法不够准确。同时，点云数据往往包含噪声和异常点，这需要我们的算法具有良好的鲁棒性。此外，地面上存在各种物体，如植被、车辆等，这些物体与地面连接，增加了分割的难度。
其次，我们需要考虑算法的效率问题。点云数据通常包含大量的点，直接处理所有点会导致计算复杂度过高。因此，我们需要设计能够高效处理大规模数据的算法，需要采用降采样、空间划分等技术来提高效率。
再次，我们需要考虑算法的适应性和泛化能力。理想的算法应该能够适应不同类型的地形和场景，而不需要大量的参数调整。这需要我们引入一些自适应的机制或学习的方法。
基于以上分析，我们可以考虑构建一个多阶段的地面分割模型。这个模型可以包括以下几个关键步骤：1) 数据预处理，包括降采样和异常点去除；2) 初始地面估计，可以使用基于高度的方法或平面拟合方法；3) 地面细化，使用更复杂的模型来处理非平坦地形；4) 后处理，如连通性分析和平滑处理。
在模型设计中，我们可以结合多种技术，如RANSAC（随机抽样一致）算法用于初始平面估计，多项式拟合用于处理非平坦地形，以及基于图的方法用于局部一致性优化。同时，我们可以考虑引入机器学习方法，如支持向量机（SVM）或随机森林，来学习区分地面点和非地面点的特征。
考虑到问题的规模和复杂性，我们需要采用一些并行计算或分布式处理的技术来提高算法的效率。例如，我们可以使用八叉树结构来组织点云数据，并在不同的空间区域并行执行分割算法。
在算法实现过程中，我们需要注意一些实际问题，如参数的选择和调整。我们可以设计一种自适应的参数选择机制，根据点云的特性自动调整算法参数。同时，我们还需要考虑算法的鲁棒性，设计合适的异常处理机制来应对复杂的实际场景。
多尺度自适应地面分割模型建立 基于上述思路分析，我们提出一个针对2024河北省研究生数学建模C题的多尺度自适应地面分割模型来解决三维点云数据中地面点和非地面点的分割问题。这个模型结合了几何分析、机器学习和图优化等多种技术，能够有效地处理复杂的室外场景。
首先，我们定义点云数据集为P = {p_i | i = 1, …, N}，其中p_i = (x_i, y_i, z_i)表示第i个点的三维坐标。我们的目标是为每个点p_i分配一个标签l_i ∈ {0, 1}，其中0表示非地面点，1表示地面点。
模型的核心思想是通过多个尺度的分析来逐步细化地面分割结果。在每个尺度上，我们使用不同的特征和模型来描述地面。具体来说，模型包括以下几个主要组成部分：
数据预处理：
在这个阶段，我们首先对点云数据进行降采样，以减少计算复杂度。我们使用体素网格滤波算法，将点云划分为大小为r的立方体网格，并用每个网格中点的平均值来表示该网格。降采样后的点云可表示为:
P ′ = { p j ′ ∣ j = 1 , . . . , M } , M ≤ N P' = \{p'_j | j = 1, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a95f1188829a0b406cc7dc52da7fb640/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ff2782c5ec8513f501f02644d0f5864/" rel="bookmark">
			在本地部署Ollama服务接口附加OpenWebUI做测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Ollama在本地部署一个类似openai的API做开发和测试 1、准备一个旧电脑 因为配置要求不高，五年前的电脑都能使用，装一块旧显卡，显存大一点的最好有8G。实在没显卡也没关系，电脑内存大也能运行，无非运行的慢一些不影响开发测试。在电脑上安装centos stream 9 服务器带界面版，装上显卡驱动，没有显卡的只装系统就行了。配置好能上网（本篇不用科学上网）。
2、安装ollama 随便一个目录下，执行如下命令：
# curl -fsSL https://ollama.com/install.sh | sh
显示如下：表示安装成功
&gt;&gt;&gt; Downloading ollama...
######################################################################## 100.0%##O#-# &gt;&gt;&gt; Installing ollama to /usr/local/bin...
&gt;&gt;&gt; Creating ollama user...
&gt;&gt;&gt; Adding ollama user to render group...
&gt;&gt;&gt; Adding ollama user to video group...
&gt;&gt;&gt; Adding current user to ollama group...
&gt;&gt;&gt; Creating ollama systemd service...
&gt;&gt;&gt; Enabling and starting ollama service...
Created symlink /etc/systemd/system/default.target.wants/ollama.service → /etc/systemd/system/ollama.service.
&gt;&gt;&gt; NVIDIA GPU installed.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ff2782c5ec8513f501f02644d0f5864/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1cf8cfd18cb37292ca0e1ed7a29f184/" rel="bookmark">
			【算法/训练】：前缀和&amp;&amp;差分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨ 海压竹枝低复举，风吹山角晦还明 🌏 📃个人主页：island1314
🔥个人专栏：算法训练
🚀 欢迎关注：👍点赞 👂🏽留言 😍收藏 💞 💞 💞
目录
目录
🚀 前言：
1. 校门外的树
2. 值周
3. [CQOI2009]中位数图
4. [HNOI2003]激光炸弹
5. 二分
6. 货仓选址
🚀 前言： 前面我们已经通过 【算法/学习】前缀和&amp;&amp;差分-CSDN博客 学习了前缀和&amp;&amp;差分的效相关知识，现在我们开始进行相关题目的练习吧
1. 校门外的树 思路：给[0, n]的数组都标记为1，然后输出m行范围，[l, r]都标记为0。
AC代码如下：
#include &lt;iostream&gt; using namespace std; const int N = 1e5 + 10; int a[N]; int main() { int n, m; cin&gt;&gt;n&gt;&gt;m; for(int i = 0; i &lt;= n; i++) a[i] = 1; int l, r; for(int i = 1; i &lt;= m; i++) { cin&gt;&gt;l&gt;&gt;r; for(int j = l; j &lt;= r; j++) a[j] = 0; } int cnt = 0; for(int i = 0; i &lt;= n; i++) { if(a[i] == 1) cnt++; } cout&lt;&lt;cnt&lt;&lt;endl; return 0; } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1cf8cfd18cb37292ca0e1ed7a29f184/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0b675228b46707d34ee1ccf32f0f1b3/" rel="bookmark">
			Lua 类管理器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Lua 类管理器 -- ***** Class Manager 类管理*****‘ local ClassManager = {} local this = ClassManager function ClassManager.Class(className, ...) print('ClassManager::Class') --print(className) -- 构建类 local cls = {__className = className} --print(cls) -- 父类集合 local supers = {...} for _, super in pairs(supers) do -- 获取父类的类型 local superType = type(super) --print(superType) assert(superType == nil or superType == 'table' or superType == 'function', string.format("class() - create class \"%s\" with invalid super class type \"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0b675228b46707d34ee1ccf32f0f1b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30282c3ba95b9ff1ad9de3c45482e5f6/" rel="bookmark">
			深入理解SQL中的INNER JOIN操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍了INNER JOIN的定义、使用场景、计算方法及与其他JOIN的比较。INNER JOIN是关系数据库中常用的操作，用于返回两个表中匹配的行，只有在连接条件满足时才返回数据。本文详细解释了INNER JOIN的语法及其在一对多、多对多关系中的应用，通过示例展示其结果集行数的计算方法。此外，文中还比较了INNER JOIN与LEFT JOIN、RIGHT JOIN、FULL JOIN和CROSS JOIN的异同，帮助读者理解不同类型的JOIN在实际查询中的应用场景。通过本文，读者能够掌握INNER JOIN的核心概念和技术细节，提高SQL查询和数据处理的效率。
一、InnerJoin 的定义和概念 在关系数据库中，JOIN操作用于在两个或多个表之间基于某些条件进行连接。INNER JOIN是最常见的JOIN类型之一，它仅返回两个表中匹配的行。了解INNER JOIN的定义和概念对于正确使用和优化SQL查询至关重要。
什么是INNER JOIN？ INNER JOIN用于返回两个表中基于指定条件匹配的行。换句话说，只有当连接条件满足时，才会返回行。如果没有匹配的行，则不会在结果集中包含这些行。
INNER JOIN的语法 标准SQL语法中，INNER JOIN的基本形式如下：
SELECT column_name(s) FROM table1 INNER JOIN table2 ON table1.column_name = table2.column_name; 在这个语法中，table1和table2是要连接的两个表，column_name(s)是要选择的列，ON子句指定了连接条件。
INNER JOIN的使用场景 INNER JOIN广泛应用于各种场景，包括：
数据分析：从多个相关表中检索数据进行分析。数据聚合：结合多个表的数据进行汇总和统计。报告生成：生成基于多表数据的报告。数据验证：验证多个表之间的关系和数据一致性。 通过理解INNER JOIN的定义和概念，可以更有效地应用它来解决实际问题。
二、InnerJoin 关联结果的计算方法 在实际应用中，INNER JOIN的结果集行数取决于连接表之间的关系类型和匹配条件。为了准确计算INNER JOIN的返回行数，我们需要深入了解以下几种情况：
一对多关系和多对多关系 在关系数据库中，一对多关系和多对多关系是两种常见的表关系类型。INNER JOIN在这两种关系中的行为有所不同，但可以通过理解它们的本质来统一计算方法。
一对多关系 在一对多关系中，一个表中的每一行可以与另一个表中的多行相关联。INNER JOIN在一对多关系中的行为主要取决于子表中的匹配行数。
假设：
表 A 具有 m 行。表 B 具有 n 行。表 A 中的每一行可能在表 B 中匹配零行、一行或多行。 如果表 A 中的每一行在表 B 中平均匹配 k 行（k 可以是 0），那么INNER JOIN返回的总行数为 m * k。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30282c3ba95b9ff1ad9de3c45482e5f6/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/105/">«</a>
	<span class="pagination__item pagination__item--current">106/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/107/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>