<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5e63087c6cc42ba2c2e54b19a877311/" rel="bookmark">
			这是啥设计模式-组合模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		召回链路一般都是使用多路召回，例如文本召回，向量召回，KV召回等等。
1. 面向接口编程，而非实现 还是那句话，客户端并怎么不关心召回策略的具体实现，他只关心接口。通过这个接口它可以得到自己想要的召回结果。
class Recall { public: explicit Recall(const std::string&amp; name) : m_name(name) {} virtual ~Recall() = default; virtual void recall(int depth) const = 0; private: std::string m_name; }; 我们定义一个召回策略的接口，后续所有策略都继承这个接口，其中m_name是策略的名称，recall是召回函数。
2. 实现接口 // 文本召回 class InvertRecall : public Recall { public: explicit InvertRecall(const std::string&amp; name) : Recall(name) {} void recall(int depth) const override { std::cout &lt;&lt; std::string(depth, ' ') &lt;&lt; "-" &lt;&lt; name &lt;&lt; std::endl; } }; // 向量召回 class VectorRecall : public Recall { public: explicit VectorRecall(const std::string&amp; name) : Recall(name) {} void recall(int depth) const override { std::cout &lt;&lt; std::string(depth, ' ') &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5e63087c6cc42ba2c2e54b19a877311/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6148bba44b78497a83c9395a92a703ea/" rel="bookmark">
			【Docker】Docker Compose（容器编排）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是 Docker Compose docker-compose 是 Docker 官方的开源项目，使用 python 编写，实现上调用了 Docker 服务的 API 进行容器管理及编排，其官方定义为定义和运行多个 Docker 容器的应用。
docker-compose 中有两个非常重要的概念：
服务（service）：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。项目（project）：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义，整个 docker-compose.yml 定义一个项目。 Compose 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。
通过 compose 可以方便的管理多个服务。
二、生活案例 docker compose 就像航母一样，有舰载机、防空导弹，舰载机、导弹就是一个个容器。
三、为什么要 Docker Compose Docker 是一个轻量化的应用程序，Docker 官方推荐每个 Docker 容器中只运行一个进程。如果一个应用需要涉及到 MySQL、nginx 等环境， 那么就需要分别为应用、数据库和 nginx 创建单独的 docker 容器，然后再分别启动容器。
如果构建好 Docker 之后，每次启动应用都至少需要 docker run 三次或者写一些脚本来实现，这样会比较繁琐。另外，这些 docker 容器都是分散独立的，也不方便镜像管理。
既然这些 docker 容器都是为了同一个应用服务，就应该把它们放到一起，这就引出了 docker-compose 来解决这类型的问题。 四、Docker Compose 的安装 安装 docker 的时候，我已经安装了 docker-compose，安装的组件包名称为 docker-compose-plugin。
检查安装是否成功：
五、Docker Compose 的功能 1、使用步骤 Compose 使用的步骤： 使用 docker-compose.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6148bba44b78497a83c9395a92a703ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/225005f2ef5296cbdbd4badcad2b9046/" rel="bookmark">
			Eureka高可用性配置：如何实现Eureka集群与故障转移
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Eureka高可用性配置：如何实现Eureka集群与故障转移 引言 在微服务架构中，服务发现是一个核心组件，它帮助各个微服务在运行时找到彼此。Eureka是Netflix开发的一个用于服务发现的工具，它提供了服务注册与发现的功能。在生产环境中，确保Eureka的高可用性至关重要，这样可以保证服务发现的稳定性和可靠性。本文将详细介绍如何配置Eureka集群，以实现高可用性和故障转移，包括集群配置、故障转移机制以及最佳实践。
1. Eureka简介 Eureka是一个基于REST的服务发现平台，主要包括两个组件：
Eureka Server：服务注册中心，负责接收和存储服务实例的注册信息。Eureka Client：服务提供者或消费者，向Eureka Server注册自己的信息，并从Eureka Server中获取其他服务的信息。 Eureka的高可用性配置可以提高系统的容错能力，避免单点故障（SPOF），确保服务发现的持续可用性。
2. Eureka高可用性设计 2.1 集群配置 Eureka集群的核心设计思想是通过部署多个Eureka Server实例来实现高可用性。集群中的Eureka Server实例会相互同步服务注册信息，从而避免因单个实例故障而导致服务发现失败。实现Eureka集群的步骤如下：
2.1.1 配置Eureka Server 在每个Eureka Server实例的配置文件中，需要指定Eureka集群的其他实例。以下是一个基于Spring Boot的Eureka Server配置示例：
# application.yml eureka: client: fetch-registry: false register-with-eureka: false service-url: defaultZone: http://localhost:8761/eureka/,http://localhost:8762/eureka/,http://localhost:8763/eureka/ server: enable-self-preservation: true eviction-interval-timer-in-ms: 60000 在这个配置中，defaultZone属性指定了Eureka Server集群的地址列表。每个Eureka Server实例都会向这个地址列表中的其他实例同步其服务注册信息。
2.1.2 启动多个Eureka Server实例 为了实现高可用性，必须启动多个Eureka Server实例。可以使用不同的端口来启动这些实例，并确保它们能够相互通信。以下是一个启动多个Eureka Server实例的示例命令：
# 启动第一个Eureka Server实例 java -jar eureka-server.jar --server.port=8761 --eureka.client.service-url.defaultZone=http://localhost:8762/eureka/,http://localhost:8763/eureka/ # 启动第二个Eureka Server实例 java -jar eureka-server.jar --server.port=8762 --eureka.client.service-url.defaultZone=http://localhost:8761/eureka/,http://localhost:8763/eureka/ # 启动第三个Eureka Server实例 java -jar eureka-server.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/225005f2ef5296cbdbd4badcad2b9046/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b96ca5acd34b442d1f411018eec5e0d/" rel="bookmark">
			人工智能助手通过RAG消除幻觉以及图片的智能重绘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为期三天的NVIDIA AI-AGENT夏季训练营结束了。过程紧张而充实，收获满满。
废话不多少，直接上干货。
NVIDIA AI-AGENT夏季训练营 项目名称：AI-AGENT夏季训练营 — RAG智能对话机器人
报告日期：2024年8月18日
项目负责人：贺振华
01 项目概述： 本项目旨在使用NVIDIA的NIM人工智能平台，针对特定应用场景中的文本检索和图像处理需求，进行RAG智能对话机器人的搭建和实践。项目通过先进的自然语言处理技术增强文字的检索能力，使用户能够更快速、准确地找到所需信息。同时，利用调用大模型API对图片进行微调重绘，提升视觉呈现效果，增强用户体验。项目的亮点在于其创新性地结合了文本和图像处理功能，为用户提供一站式解决方案。可能的应用场景包括数字图书馆、在线媒体平台和企业内部文档管理等，有助于提高工作效率和信息获取的精确度。
02 技术方案 模型选择： 文字的检索增强（RAG）采用microsoft/phi-3-small-128k-instruct；进阶版RAG采用的mistralai/mixtral-8x7b-instruct-v0.1；图片的智能重绘采用的microsoft/phi-3-vision-128k-instruct和meta/llama-3.1-405b-instruct。
数据的构建： 数据构建过程：在文字的RAG中，数据为txt的文本数据，通过python程序代码对数据进行简单的数据清洗，随后处理到faiss vectorstore 并将其保存到磁盘备用。
向量化处理方法：通过NVIDIA Embeddings工具类调用NIM中的"ai-embed-qa-4"向量化模型。随后使用microsoft/phi-3-small-128k-instruct模型，结合"ai-embed-qa-4"向量化模型，基于本地存储的数据，进行文本数据的RAG功能实现。
功能整合（进阶版RAG必填）： 通过多模态模型microsoft/phi-3-vision-128k-instruct ，对图片进行识别，将编码后的图像按照格式给到Microsoft Phi 3 vision , 利用其强大能力解析图片中的数据。随后，使用 LangChain 构建多模态智能体，整体的工作流程为：接收图片 -&gt; 分析数据 -&gt; 修改数据 -&gt; 生成绘制图片的代码 -&gt; 执行代码 -&gt; 展示结果。然后，结合microsoft/phi-3-vision-128k-instruct模型和meta/llama-3.1-405b-instruct模型，通过Gradio构建的前端UI，进行结果的呈现。
03 实施步骤： 1. 环境搭建： 下面依次描述需要配置的环境，软件，插件等。此步骤非常重要，耗时最长。
安装Miniconda。我使用的是：清华大学镜像，地址https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/选择Miniconda版本。由于python至少需要3.8以上版本，所以大家需要注意Miniconda的版本。安装Miniconda。本人在安装时的踩的一个坑是安装目录里不能有空格或中文等字符，否则后续配置环境时不断的报错。Miniconda安装好后，打开终端。创建python 3.8虚拟环境。 conda create --name ai_endpoint python=3.8 通过Anaconda Powershell Miniconda终端进入虚拟环境。 conda activate ai_endpoint 安装nvidia_ai_endpoint工具 pip install langchain-nvidia-ai-endpoints 安装Jupyter Lab pip install jupyterlab 安装langchain_core pip install langchain 安装matplotlib pip install matplotlib 安装Numpy pip install numpy 安装CPU版本的faiss pip install faiss-cpu==1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b96ca5acd34b442d1f411018eec5e0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/122742f7961d340346aa088ae734efe5/" rel="bookmark">
			【微服务】springboot 整合表达式计算引擎 Aviator 使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言
二、表达式计算框架概述
2.1 规则引擎
2.1.1 什么是规则引擎
2.1.2 规则引擎用途
2.1.3 规则引擎使用场景
2.2 表达式计算框架
2.2.1 表达式计算框架定义
2.2.2 表达式计算框架特点
2.2.3 表达式计算框架应用场景
2.3 表达式计算框架与规则引擎异同点
2.3.1 相同点
2.3.2 不同点
三、表达式计算框架 Google Aviator介绍
3.1 Google Aviator概述
3.1.1 Aviator是什么
3.1.2 Aviator特点
3.2 Google Aviator 优势和应用场景
四、Google Aviator使用
4.1 Aviator常用运算符操作
4.1.1 入门示例
4.1.2 算术运算符
4.1.3 比较运算符
4.1.4 逻辑操作符
4.1.5 运算符操作补充
4.2 Aviator内置函数使用
4.2.1 随机数函数
4.2.2 数值比较函数
4.2.3 强制类型转换
4.2.4 数值类型判断
4.2.5 常用的字符串函数
4.2.6 常用数学函数
4.2.7 集合操作函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/122742f7961d340346aa088ae734efe5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38c5b4d27e3926b063e3257324ff2cb3/" rel="bookmark">
			Apache HTTP Server 的安装与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概要 1. 环境
(1) Rocky Linux 9.3
二、安装与配置 1. 安装
(1) 安装
sudo dnf install httpd -y (2) 服务
sudo systemctl start httpd sudo systemctl enable httpd systemctl status httpd (3) 防火墙
sudo firewall-cmd --add-service={http,https} --permanent sudo firewall-cmd --reload 2. SSL
(1) 安装SSL模块
sudo dnf install mod_ssl -y 安装完成之后会在/etc/httpd/conf.d目录下出现一个文件ssl.conf。
(2) 为域名设置SSL/TLS
假设我们需要为www.example.com设置SSL/TLS:
a. 创建证书目录
sudo mkdir /etc/httpd/certs b. 准备证书
OpenSSL 系列2 — 应用
i. CA证书；
ii. 域名证书；
iii. 域名证书密钥；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38c5b4d27e3926b063e3257324ff2cb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/721cbd3f7fcb0c0e70b10ca70162e52a/" rel="bookmark">
			rabbitmq镜像集群搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用到的ip地址
ip地址端口192.168.101.65（主）15672192.168.101.7515672192.168.101.8515672 安装erlang和rabbitmq 安装
安装三个包
yum install esl-erlang_23.0-1_centos_7_amd64.rpm -y
yum install esl-erlang-compat-18.1-1.noarch.rpm -y
rpm -ivh rabbitmq-server-3.8.9-1.el7.noarch.rpm
启动rabbitmq和web插件
rabbitmq启动失败 [root@rabbitmq01 rabbitmq]# journalctl -xe 8月 17 14:02:03 rabbitmq01 rabbitmq-server[27206]: {{shutdown, 8月 17 14:02:03 rabbitmq01 rabbitmq-server[27206]: 14:02:03.632 [error] {failed_to_start_child,auth, 8月 17 14:02:03 rabbitmq01 rabbitmq-server[27206]: 14:02:03.632 [error] {"Error when reading /var/lib/rabbitmq/.erlang.cookie: eacces", 8月 17 14:02:03 rabbitmq01 rabbitmq-server[27206]: {failed_to_start_child,auth, 8月 17 14:02:03 rabbitmq01 rabbitmq-server[27206]: {"Error when reading /var/lib/rabbitmq/.erlang.cookie: eacces", 8月 17 14:02:03 rabbitmq01 rabbitmq-server[27206]: [{auth,init_cookie,0,[{file,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/721cbd3f7fcb0c0e70b10ca70162e52a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8d635a5084dbf7aaf1889a6d05d2f18/" rel="bookmark">
			SQL - 引入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数据库相关概念 数据库：存储数据的仓库，对数据有组织的进行存储 数据库管理系统：操纵和管理数据库的大型软件 SQL：操作关系型数据库的编程语言，定义了一套操作关系型数据库统一标准关系型数据库 概念： 建立在关系模型基础上，由多张相互连接的二维表组成的数据库，本质上就是说这类数据库有多张表，通过关系彼此关联。 特点： 使用表存储数据，格式同一，便于维护，使用SQL语言操作，标准统一，使用方便。MySQL 安装和配置 关于MySQL 安装和配置，寻找资料自行查找。 我们可以通过MySQL客户端连接数据库管理系统(DBMS)，然后通过DBMS操作数据库。 我们可以使用MySQL工作台，MySQL提供的命令行工具，系统自带的命令行工具，对数据库进行操作。SQL SQL语句特点： SQL语句不区分大小写，以分号结尾。 空格，缩进，tab和回车等是没有作用的，只是增强语句的可读性。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c54cfae4083b723a11137324dab91efc/" rel="bookmark">
			利用亚马逊云科技Bedrock和LangChain开发AI驱动数据分析平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目简介： 小李哥将继续每天介绍一个基于亚马逊云科技AWS云计算平台的全球前沿AI技术解决方案，帮助大家快速了解国际上最热门的云计算平台亚马逊云科技AWS AI最佳实践，并应用到自己的日常工作里。
本次介绍的是如何在亚马逊云科技上SageMaker上利用LangChain框架开发代码调用Amazon Titan大语言模型，基于业务数据库Schema、用户问题以及提示词模板生成LLM链，调用大模型托管服务Amazon Bedrock上的AI大语言模型，生成业务所需的SQL查询语句并利用SQL链查询数据并生成用户问题的答案。本架构设计全部采用了云原生Serverless架构，提供可扩展和安全的AI解决方案。本方案的解决方案架构图如下：
方案所需基础知识 什么是 Amazon Bedrock？ Amazon Bedrock 是亚马逊云科技推出的一项生成式 AI 服务，旨在帮助开发者轻松访问和部署各种强大的基础模型（Foundation Models），如文本生成、对话生成、图像生成等。通过 Amazon Bedrock，开发者可以快速构建、定制和扩展 AI 应用程序，而无需从零开始训练模型。这种服务使得利用大规模预训练模型变得更加简便和高效，适用于各种行业的 AI 应用场景。
什么是 Amazon SageMaker？ Amazon SageMaker 是亚马逊云科技提供的一站式机器学习服务，帮助开发者和数据科学家轻松构建、训练和部署机器学习模型。SageMaker 提供了全面的工具，从数据准备、模型训练到部署和监控，覆盖了机器学习项目的全生命周期。通过 SageMaker，用户可以加速机器学习模型的开发和上线，并确保模型在生产环境中的稳定性和性能。
什么是 Amazon Glue？ Amazon Glue 是亚马逊云科技的一项完全托管的数据集成服务，用于发现、准备和组合数据，以实现更快的数据分析。Glue 提供了数据提取、转换和加载（ETL）的功能，支持自动数据爬网、元数据管理和数据清理。它使得企业能够轻松将数据从多个源系统整合到数据湖或数据仓库中，为后续的分析和报告提供干净、统一的数据集。
利用大模型生成 SQL 语句的应用场景 自助式数据查询： 利用大模型生成 SQL 语句，使非技术用户能够通过自然语言输入查询需求，自动生成相应的 SQL 语句进行数据库查询。这大大降低了数据访问的技术门槛，帮助用户快速获取所需的数据。
复杂查询自动化： 在需要构建复杂查询时，开发者可以通过描述性语言让大模型生成 SQL 语句，避免手动编写长而复杂的查询代码。这不仅提高了开发效率，还减少了语法错误的可能性。
数据分析支持： 分析师可以利用大模型生成 SQL 语句，根据业务问题自动生成分析查询，快速获取洞察，支持数据驱动的决策过程。
动态报告生成： 在报表生成系统中，用户可以通过自然语言描述需要的报告内容，大模型将生成对应的 SQL 语句并自动提取数据，生成实时报告。这种应用使得报告生成更加灵活和高效
本方案包括的内容 1.申请Amazon Bedrock上的Amazon Titan大模型访问权限。 2.运行Amazon Glue数据提取服务，将数据库的Schema导入到Amazon Glue Data Catalog 3.根据Data Catalog利用LangChain生成一个动态提示词模板 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c54cfae4083b723a11137324dab91efc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/247435006db832d4df4db6ee13519b29/" rel="bookmark">
			“双指针”算法上篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		『 你 的 名 字 』高帧4K动漫素材，无水印，需要自取！
题目： 一· 移动零 1.题目链接：移动零 2. 分析 解法一：暴力求解
就是新开一个数组，大小与原数组大小一致，只要不是数字0就进行写入，若是数字0，统计出现的
次数，最后把所有非0元素写入之后，在写入0元素。
对于一些没有思路的，老铁，刚刚看到此题，或许都会这样
但是，题目要求空间复杂度必须是O（N），所以这个想法就 “pass ” 掉了。
解法二：双指针算法
3. 原理 双指针：注意这里可不是真正意义上的指针：int*,char* ,float* …… 而是指向元素的下标
cur 指针：指向当前要扫描的元素
dest指针：指向已经被扫描过的元素
初始位置：dest = 0； cur = 0 （表示从左向右依次进行判断是否为数字0）
cur 指向元素为0，则++cur
cur 指向元素非0，交换 cur，dest对应位置的元素，同时++cur，++dest
这里建议，咱还是先根据自己的理解，来编写程序，看看自己上手能力咋样哈~~~
4.OJ代码 class Solution { public: void moveZeroes(vector&lt;int&gt;&amp; nums) { int dest = 0,cur = 0; int n = nums.size(); for(;cur &lt; n;++cur) { if(nums[cur] ) { swap(nums[dest++],nums[cur]); } } } }; 二· 复写零 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/247435006db832d4df4db6ee13519b29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e7fb72304a9cbcfa41e9d84d7d14bc1/" rel="bookmark">
			c_cpp_properties.json、launch.json、 tasks.json
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Visual Studio Code 中，c_cpp_properties.json、launch.json 和 tasks.json 是三个重要的配置文件，它们的作用如下：
c_cpp_properties.json：
这个文件用于配置 C/C++ 扩展的 IntelliSense、编译器路径和包括路径等。它帮助 VS Code 理解你的 C/C++ 项目，使代码补全、语法检查和错误检测更加准确。常见的配置项包括： includePath：指定头文件的路径。defines：定义预处理器宏。compilerPath：指定编译器的路径。intelliSenseMode：指定 IntelliSense 模式，通常与所使用的编译器相关。 launch.json：
这个文件用于配置调试器的启动选项。它定义了调试会话的设置，比如程序的启动方式、调试器的参数、环境变量等。常见的配置项包括： program：指定要调试的可执行文件的路径。args：传递给程序的命令行参数。env：设置环境变量。preLaunchTask：在调试前执行的任务，比如编译程序。 tasks.json：
这个文件用于配置自动化任务。你可以定义编译、构建、清理项目等任务。tasks.json 文件允许你在 VS Code 中轻松运行这些任务，而不需要手动在终端中输入命令。常见的配置项包括： label：任务的名称，用于引用该任务。type：任务的类型，比如 shell 或 process。command：要执行的命令。args：传递给命令的参数。 这些文件共同帮助你在 VS Code 中更好地管理、编译和调试你的项目。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c07c19468ea77bd06a946f5ee32ca829/" rel="bookmark">
			Java中的经典排序算法：插入排序、希尔排序、选择排序、堆排序与冒泡排序（如果想知道Java中有关插入排序、希尔排序、选择排序、堆排序与冒泡排序的知识点，那么只看这一篇就足够了！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：排序算法是计算机科学中的基础问题之一，它在数据处理、搜索算法以及各种优化问题中占有重要地位，本文将详细介绍几种经典的排序算法：插入排序、选择排序、堆排序和冒泡排序。
✨✨✨这里是秋刀鱼不做梦的BLOG
✨✨✨想要了解更多内容可以访问我的主页秋刀鱼不做梦-CSDN博客
先让我们看一下本文大致的讲解内容：
对于每个排序算法，我们都会从算法简介、其原理与步骤、代码实现、时间复杂度分析、空间复杂度分析与该排序算法的应用场景这几个方面来进行讲解。
目录
1.插入排序（InsertSort）
（1）算法简介
（2）原理与步骤
（3）Java代码实现
（4）时间复杂度 + 空间复杂度分析
（5）应用场景
2.希尔排序（Shell Sort）
（1）算法简介
（2）算法步骤
（3）代码实现
（4）时间复杂度 + 空间复杂度分析
（5）应用场景
3.选择排序（Selection Sort）
（1）算法简介
（2）算法步骤
（3）代码实现
（4）时间复杂度 + 空间复杂度分析
（5）应用场景
4.堆排序（Heap Sort）
（1）算法简介
（2）算法步骤
（3）代码实现
（4）时间复杂度 + 空间复杂度分析
（5）应用场景
5.冒泡排序（Bubble Sort）
（1）算法简介
（2）算法步骤
（3）代码实现
（4）时间复杂度 + 空间复杂度分析
（5）应用场景
1.插入排序（InsertSort） （1）算法简介 在开始学习插入排序算法之前，先让我们来看一下该算法的概念：
——插入排序是一种简单直观的排序算法，通常用于对少量元素的排序。其基本思想是构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
（2）原理与步骤 了解了插入排序算法的概念之后，让我们看一下实现该排序算法的几个核心步骤：
从第一个元素开始，该元素可以认为已经被排序。
取出下一个元素，在已经排序的元素序列中从后向前扫描。
如果已排序的元素大于新元素，将该元素向右移动。
重复步骤3，直到找到已排序的元素小于或等于新元素的位置。
将新元素插入到该位置中。
重复步骤2~5。
读者可以根据上述的描述先简要的了解一些插入排序的核心思路，接下来让我们使用代码来进行对其的实现。
（3）Java代码实现 现在我们使用代码来实现一下插入排序算法：
public class InsertionSort { public void insertSort(int[] array) { for (int i = 1; i &lt; array.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c07c19468ea77bd06a946f5ee32ca829/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5233ba70efca2ba6e88bbae6343c7510/" rel="bookmark">
			DOM Clobbring个人理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
toString
One Level
Two Level
Three Level
More
Dom Clobbering：就是⼀种将 HTML 代码注⼊⻚⾯中以操纵 DOM 并最终更改⻚⾯上 JavaScript ⾏为的技术
DOM Clobbering中的操作也是根据JavaScript行为的层级来分为一层、两层、三层和更多
toString 我们通过以下代码进行fuzz去获取可以通过toString方法将转换成字符串的标签。这些标签的属性值是能够控制的，因此我们也就不再是获取无用的标签了，而是变成了获取到我们想要的字符串
Object.getOwnPropertyNames(window) .filter(p =&gt; p.match(/Element$/)) .map(p =&gt; window[p]) .filter(p =&gt; p &amp;&amp; p.prototype &amp;&amp; p.prototype.toString !== Object.prototype.toString) 这段代码主要是对 window 对象的属性进行一系列操作：
Object.getOwnPropertyNames(window) 获取 window 对象的所有自身属性的名称。然后通过 filter 方法筛选出名称以 Element$ 结尾的属性。接着通过 map 方法将这些属性对应的值提取出来。最后再通过 filter 方法进一步筛选出那些值存在且有原型且原型的 toString 方法不同于 Object.prototype.toString 的元素。 我们得到了两种标签对象：HTMLAreaElement（&lt;area&gt;）&amp;HTMLAnchorElement（&lt;a&gt;），这两个标签对象，我们都可以利用href属性来进行字符串转换
One Level 当JavaScript的行为只有一层时，只需要简单的使用id或name属性来定义该名称，即可在JavaScript进行执行时对该变量覆盖，如
Two Level 当JavaScript的行为为两层时，需要两层嵌套才能覆盖
需要注意：内外层使用id还是name，需要取决标签之间的层级关系
在双id属性的情况下，可以使用以下来嵌套双层标签：
form-&gt;buttonform-&gt;fieldsetform-&gt;imageform-&gt;imgform-&gt;inputform-&gt;objectform-&gt;output var log=[]; var html = ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5233ba70efca2ba6e88bbae6343c7510/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dee7e0e3f252a9ad3d9c9fb162f495c/" rel="bookmark">
			Ruby在嵌入式系统：轻量级语言的灵活应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标题：Ruby在嵌入式系统：轻量级语言的灵活应用 摘要 在嵌入式系统开发领域，编程语言的选择至关重要，它直接影响到系统的性能、内存占用以及开发效率。Ruby，作为一种灵活且富有表现力的语言，其在嵌入式系统中的应用并不常见，但这并不意味着它没有一席之地。本文将探讨Ruby及其轻量级实现mruby在嵌入式系统开发中的适用性，以及如何利用其特性来简化开发流程。
一、嵌入式系统开发概述 嵌入式系统开发通常要求代码高效且资源占用低。传统的选择往往是C或C++，但随着技术的发展，一些高级语言也开始在嵌入式领域露头角。Ruby语言以其优雅的语法和丰富的库支持，为开发带来便利，但其资源消耗相对较高 。
二、Ruby在嵌入式系统中的挑战 Ruby语言本身的资源消耗是其在嵌入式系统开发中面临的主要挑战。在资源受限的设备上，内存和处理能力的限制要求编程语言必须足够轻量级。然而，Ruby的动态特性和丰富的标准库使其在资源受限的环境中难以施展 。
三、mruby：Ruby的轻量级实现 mruby是为嵌入式环境设计的Ruby实现，它通过编译时类型检查、字节码执行、轻量级内存管理、模块化设计以及提供C API，实现了小型、快速且易于集成的特点。这些特性使得mruby非常适合用于物联网设备、移动应用或游戏引擎等嵌入式场景 。
四、mruby在嵌入式系统开发中的应用 mruby可以作为嵌入式系统中的脚本语言，用于实现动态功能和灵活的数据处理。例如，在物联网设备中，mruby可以用来编写传感器数据的处理逻辑，或者在游戏开发中，利用mruby编写游戏角色的行为和交互逻辑。
五、实际代码示例 以下是使用mruby编写的简单示例，展示如何在嵌入式系统中处理传感器数据：
# 定义一个处理传感器数据的类 class SensorDataProcessor def initialize(sensor) @sensor = sensor end def process(data) # 这里可以添加数据处理逻辑 processed_data = data * 2 # 示例：简单地将数据翻倍 puts "Processed data: #{processed_data}" end end # 假设有一个传感器对象 sensor = ... # 传感器对象初始化 # 创建处理器实例并处理数据 processor = SensorDataProcessor.new(sensor) processor.process(10) # 输出：Processed data: 20 六、结论 虽然Ruby本身可能不是嵌入式系统开发的首要选择，但其轻量级实现mruby提供了一种新的可能性。通过mruby，开发者可以在保持代码简洁和易于维护的同时，充分利用Ruby语言的优势，为嵌入式系统带来灵活而高效的开发体验。
本文详细探讨了Ruby及其轻量级实现mruby在嵌入式系统开发中的应用，包括其挑战、优势和实际代码示例，为开发者在选择编程语言时提供了新的视角和思路。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff07477b35bd45f0e6ff6e32dff9f27b/" rel="bookmark">
			构建艺术：Ruby中RESTful API的精粹实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标题：构建艺术：Ruby中RESTful API的精粹实践 在当今的软件开发领域，RESTful API已成为构建网络应用和服务的基石。Ruby，以其优雅的语法和强大的框架，为实现RESTful API提供了得天独厚的优势。本文将深入探讨如何在Ruby中构建RESTful API，从理论到实践，从框架选择到代码实现，带你一步步领略RESTful API的构建艺术。
引言：RESTful API的重要性 RESTful API是一种基于HTTP协议的网络服务接口，它使用标准的HTTP方法来实现资源的创建、检索、更新和删除。这种设计哲学强调了无状态性、可缓存性以及统一接口，使得API易于理解和使用。
1. RESTful设计原则 在开始编码之前，理解RESTful设计的六大原则是至关重要的：
统一接口：每个资源都有一个统一的接口。资源导向：API操作基于资源。无状态性：每个请求从客户端到服务器必须包含所有必要的信息。可缓存性：响应必须明确标识是否可以被缓存。分层系统：客户端不应该知道它正在与之交互的服务器之上或之下的任何层。代码的可执行性（可选）：服务器有能力向客户端提供执行代码的机制。 2. 选择Ruby框架 Ruby社区提供了多个用于构建RESTful API的框架，其中最流行的是Ruby on Rails。Rails遵循MVC（模型-视图-控制器）架构模式，为RESTful API的实现提供了强大的支持。
3. Rails中的RESTful资源 在Rails中，你可以使用resources方法在config/routes.rb文件中定义RESTful路由。
# config/routes.rb Rails.application.routes.draw do resources :users end 这将自动为UsersController中的所有标准RESTful操作生成路由。
4. 控制器与动作 在Rails中，控制器负责处理业务逻辑。对于每个资源，你通常需要实现以下动作：
index：列出所有资源。show：显示单个资源。create：创建新资源。update：更新现有资源。destroy：删除资源。 # app/controllers/users_controller.rb class UsersController &lt; ApplicationController before_action :set_user, only: [:show, :update, :destroy] def index @users = User.all render json: @users end def show render json: @user end def create @user = User.new(user_params) if @user.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff07477b35bd45f0e6ff6e32dff9f27b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de486354d64d2953e43226a62e7dcc7b/" rel="bookmark">
			运营商三要素-手机三要素-运营商三要素验证-运营商实名认证-手机三要素实名校验核验接口API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		手机三要素实名校验核验接口API是一种重要的技术工具，它主要用于验证用户的姓名、身份证号码和手机号是否一致，从而确保用户身份的真实性和一致性。以下是对该接口API的详细解析：
一、接口定义与功能 手机三要素实名校验核验接口API，是一种通过输入用户的姓名、身份证号码和手机号这三项信息，来实时校验这三项信息是否匹配的接口。该接口通常由合法授权的第三方API接口平台提供，如快证API等。其主要功能包括：
验证用户提交的姓名、身份证号和手机号是否一致。检查手机号是否有效、是否实名。检查身份证是否有效等。 二、使用场景 手机三要素实名校验核验接口API广泛应用于多个领域，包括但不限于：
互联网贷款：在贷款申请过程中，验证借款人的身份信息，降低欺诈风险。网络实名证明：在需要用户实名认证的场景中，如社交媒体、论坛等，验证用户身份。在线教育：学生注册时验证身份信息，确保学员信息的真实性。银行账户安全：在开户、转账等操作中验证用户身份，保障资金安全。电子商务：在用户注册、购买商品时进行身份验证，防止虚假交易。大数据风控：在风控系统中，对用户身份进行核验，评估潜在风险。 三、接口调用流程 手机三要素实名校验核验接口API的调用流程通常包括以下几个步骤：
发起HTTP请求：客户端（如应用程序、网站等）向API接口发送包含用户姓名、身份证号和手机号的HTTP请求。服务器处理请求：API接口平台接收到请求后，调用运营商数据库或相关数据源进行信息核验。返回响应：服务器处理完请求后，将核验结果（包括认证状态、认证结果、错误码和错误信息等）以HTTP响应的形式返回给客户端。 四、接口优势 手机三要素实名校验核验接口API具有以下优势：
数据全面：核验数据库覆盖移动、联通、电信三大运营商，能够确保证数据查询的精准性与广泛性。实时更新：接口能够对接三大运营商实时数据，数据实时更新，保证数据的及时性。高效便捷：API接口设计简单，易于集成到现有的系统和应用中，提高验证效率。灵活计费：通常按查询次数收费，一查一费，查询成功才会收取费用，灵活性强，可以有效节约成本。 五、注意事项 在使用手机三要素实名校验核验接口API时，需要注意以下几点：
合法合规：确保接口的使用符合相关法律法规要求，如《网络安全法》、《个人信息保护法》等。数据保护：在传输和存储用户信息时，采取必要的安全措施，防止数据泄露和滥用。用户体验：合理设计验证流程，减少用户等待时间，提升用户体验。 综上所述，手机三要素实名校验核验接口API是一种高效、便捷、安全的身份验证工具，在多个领域具有广泛的应用前景。
六、实现流程 Java代码
//代码地址 https://market.aliyun.com/apimarket/detail/cmapi00066757?spm=5176.730005.result.52.552035246NU2Hn#sku=yuncode6075700003 public static void main(String[] args) { String host = "https://kzmobilev2.market.alicloudapi.com"; String path = "/api/mobile_three/check"; String method = "POST"; String appcode = "你自己的AppCode"; Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;(); //最后在header中的格式(中间是英文空格)为Authorization:APPCODE 83359fd73fe94948385f570e3c139105 headers.put("Authorization", "APPCODE " + appcode); //根据API的要求，定义相对应的Content-Type headers.put("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8"); Map&lt;String, String&gt; querys = new HashMap&lt;String, String&gt;(); Map&lt;String, String&gt; bodys = new HashMap&lt;String, String&gt;(); bodys.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de486354d64d2953e43226a62e7dcc7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f41106565f83837d5c96a4aef1c2549/" rel="bookmark">
			djnago之序列化器的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Django 的序列化器（Serializers）是 Django REST framework（DRF）中的一个核心组件，用于将复杂的数据类型（如 Django 模型实例）转换为 JSON、XML 或其他内容类型，反之亦然。序列化器不仅可以序列化和反序列化数据，还可以进行数据验证和处理。
基本用法 1. 定义模型 定义一些 Django 模型：
# models.py from django.db import models class Author(models.Model): name = models.CharField(max_length=100) class Book(models.Model): title = models.CharField(max_length=100) author = models.ForeignKey(Author, related_name='books', on_delete=models.CASCADE) 2. 定义序列化器 定义序列化器：
# serializers.py from rest_framework import serializers from .models import Author, Book class AuthorSerializer(serializers.ModelSerializer): class Meta: model = Author fields = ['id', 'name'] class BookSerializer(serializers.ModelSerializer): author = AuthorSerializer() # 嵌套序列化器 class Meta: model = Book fields = ['id', 'title', 'author'] model 和 fields 的用法 model 属性指定了这个序列化器对应的 Django 模型。DRF 会根据这个模型自动生成相应的序列化器字段。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f41106565f83837d5c96a4aef1c2549/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae7630ccba5b97312142428c142b6fa9/" rel="bookmark">
			在Windows下安装配置Python 3.12.5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、下载Python二、安装Python三、验证Python验证Python环境验证pip更新pip安装包 四、配置环境变量(可选) 一、下载Python 下载地址
或者使用直链下载
二、安装Python 打开下载好的安装包，这里选择自定义安装，同时勾选以管理员安装与添加到环境变量
这里默认选择，点击下一步，也可按照自己的需求选择
这里修改安装路径后安装，其他可以默认
等待安装进度跑完，点击关闭
三、验证Python 验证Python环境 Win + R 输入
cdm 点击确实
输入
python --version 回车，若出现版本号则安装成功
验证pip 输入
pip --version 回车，可以显示pip的版本和位置
更新pip 输入
pip install --upgrade pip 回车即可更新pip，如同这样说明已经是最新版了
安装包 输入
pip install &lt;包名&gt; 即可安装软件包，这里以selenium举例
pip install selenium 如果加上-i https://pypi.tuna.tsinghua.edu.cn/simple使用清华源下载会更快
安装成功
可以使用
pip show selenium 来查看包的版本
安装成功
四、配置环境变量(可选) 例如用selenium做自动化测速需要在python安装目录放浏览器驱动，就需要环境变量
win+r输
sysdm.cpl 确定
点击高级
即可打开环境变量
在系统变量里找到Path打开
添加Python的安装目录与安装目录\Scripts
完成后点击确定退出
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8ea4a424b2e5ed28148d4437fed2482/" rel="bookmark">
			Redis中String数据类型常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 基本操作
（1）新增 / 修改 数据
（2）获取数据
（3）删除数据
2. 计数与长度
（1）自增值（当值为数字时）
（2）自减值（当值为数字时）
（3）增加指定值
（4）减少指定值
（5）获取字符串的长度
3. 设置和获取部分值
（1）设置部分字符串
（2）获取部分字符串
（3）用新值覆盖部分字符串
4. 其他
（1）将值从字符串追加到现有值
（2）获取或设置值（仅在键不存在时设置）
SETNX key value
（3）设置键的值并返回旧值
5. 过期与持久化
（1）设置过期时间
（2）查看剩余过期时间
1. 基本操作 （1）新增 / 修改 数据 SET key value
（2）获取数据 GET key
（3）删除数据 DEL key
2. 计数与长度 （1）自增值（当值为数字时） INCR key
（2）自减值（当值为数字时） DECR key
（3）增加指定值 INCRBY key increment
（4）减少指定值 DECRBY key decrement
（5）获取字符串的长度 STRLEN key
3. 设置和获取部分值 （1）设置部分字符串 SET range_key value EXPIRE time
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8ea4a424b2e5ed28148d4437fed2482/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/179c1fb14aead36b93971ea486bd068a/" rel="bookmark">
			【Spark集群部署系列二】Spark StandAlone模式介绍和搭建以及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Spark集群部署系列一】Spark local模式介绍和搭建以及使用（内含Linux安装Anaconda)http://t.csdnimg.cn/0xmky
简介 注意:请先部署好Hadoop集群 在部署spark集群前，请部署好Hadoop集群，jdk8【当然Hadoop集群需要运行在jdk上】，需要注意hadoop，spark的版本，考虑兼容问题。比如hadoop3.0以上的才兼容spark3.0以上的。
下面是Hadoop集群部署的链接，个人笔记，已经成功部署两次了，实时更新，分【一】【二】两部分，需要的自己看。不懂欢迎问，看到了解答。(链接失效的话请参考个人主页)
hadoop集群部署【一】HDFS集群http://t.csdnimg.cn/g6w1u
hadoop集群部署【二】YARN,MapReduce集群http://t.csdnimg.cn/O7sVz
搭建准备工作(每一台机器都要)： 注意：如果之前配置过Spark local模式（参考最开始链接），那么只需要在没有安装过anaconda的机器进行搭建准备工作。
安装Anaconda 需要python环境,上传Anaconda，找到放置的位置，切换到该目录下。
安装Anaconda(我的是Anaconda3-2021.05-Linux-x86_64.sh 版本python3.8）
tip:我没有试过分发，所以我不知道分发有没有问题，知道的可以说一下，但是不建议大家用，毕竟安装后要初始化anaconda
sh ./Anaconda3-2021.05-Linux-x86_64.sh 接下来步骤
然后一直空格，出现[yes|no] 就回答yes,懂?
出现这样的就填你要把anaconda安装到哪里。（路径）
完成后结果（退出终端，重新进来）
更改conda国内源 vim ~/.condarc # 如果以前没有该文件，新建的，里面没有东西很正常 channels: - defaults show_channel_urls: true default_channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2 custom_channels: conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud 终端输入 python 创建spark运行的虚拟环境 conda create -n pyspark python=3.8 切换虚拟环境 conda activate pyspark tip:输入python 版本变化很正常
Spark StandAlone部署 上传解压spark 如果之前配置过Spark local模式，那么下面的步骤看情况处理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/179c1fb14aead36b93971ea486bd068a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/39/">«</a>
	<span class="pagination__item pagination__item--current">40/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/41/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>