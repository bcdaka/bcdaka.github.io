<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44ec14b16226a4960627cdbc83fc521d/" rel="bookmark">
			前端异步(async)解决方案(所有方案)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**缺点:**整个程序都要变成事件驱动型，运行流程会变得不清晰。
事件鉴定方法:
(1).onclick方法:
element.οnclick=function(){
//处理函数
}
优点：写法兼容到主流浏览器。
缺点：当同一个element元素绑定多个事件时，只有最后一个事件会被添加。
例如:
element.οnclick=handler1;
element.οnclick=handler2;
element.οnclick=handler3;
上诉只有handler3会被添加执行，所以我们使用另外一种方法添加事件。（2）attachEvent和addEvenListener方法
(2).attachEvent和addEvenListener方法:
//IE:attachEvent（IE下的事件监听）
elment.attachEvent(“onclick”,handler1);
elment.attachEvent(“onclick”,handler2);
elment.attachEvent(“onclick”,handler3);
上述三个方法执行顺序：3-2-1；
//标准addEventListener（标准下的监听）
elment.addEvenListener(“click”,handler1,false);
elment.addEvenListener(“click”,handler2,false);
elment.addEvenListener(“click”,handler3,false);&gt;
执行顺序：1-2-3；
PS：该方法的第三个参数是冒泡获取(useCapture)，是一个布尔值：当为false时表示由里向外(事件冒泡)，true表示由外向里(事件捕获)。
document.getElementById(“id1”).addEventListener(“click”,function(){
console.log(‘id1’);
},false);
document.getElementById(“id2”).addEventListener(“click”,function({
console.log(‘id2’);
},false);
//点击id=id2的div，先在console中输出，先输出id2，在输出id1
document.getElementById(“id1”).addEventListener(“click”,function({
console.log(‘id1’);
},false);
document.getElementById(“id2”).addEventListener(“click”,function({
console.log(‘id2’);
},true);
//点击id=id2的div，先在console中输出，先输出id1，在输出id2
(3).DOM方法addEventListener()和removeListenner():
addEventListenner()和removeListenner()表示用来分配和删除事件的函数。这两种方法都需要三种参数，分别为：string（事件名称），要触发事件的函数function，指定事件的处理函数的时期或者阶段（boolean）。例子见（2）
(4).通用的时间添加方法:
on:function(elment,type,handler){
//添加事件
return element.attachEvent？elment.attachEvent(“on”+type,handler):elment.addEventListener(type,handler,false);
}
事件冒泡和事件捕获的区别,可以参考:
二.工具方案 工具方案大致分为以下5个:
Promise
gengerator函数
async await
node.js中 nextTick setImmidate
第三方库 async.js
下面针对每一个做详细说明应用:
1.Promise(重点)
(1).Promise的含义和发展:
含义:Promise 对象用于一个异步操作的最终完成（或失败）及其结果值的表示。简单点说，它就是用于处理异步操作的，异步处理成功了就执行成功的操作，异步处理失败了就捕获错误或者停止后续操作。
发展:Promise 是异步编程的一种解决方案，比传统的解决方案–回调函数和事件－－更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了语法，原生提供了Promise
(2).它的一般形式:
new Promise(
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44ec14b16226a4960627cdbc83fc521d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc19cba1371b629de125daa77bc07a11/" rel="bookmark">
			国内唯一！阿里云荣膺MongoDB “2024年度DBaaS认证合作伙伴奖”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近日，在MongoDB用户大会纽约站上，阿里云荣膺MongoDB“2024年度DBaaS认证合作伙伴奖”。这是阿里云连续第五年斩获 MongoDB 合作伙伴奖项，也是唯一获此殊荣的中国云厂商。
MongoDB是当今全球最受开发者欢迎的非关系型数据库。凭借灵活的模式和丰富的文档结构，MongoDB帮助企业客户及百万开发者们使用丰富的数据结构快速开发应用，多快好省地构建现代应用程序。
阿里云是国内唯一一家率先发布MongoDB新版本的云服务厂商。基于阿里云的云原生环境，客户可以更好体验到MongoDB数据库的崭新能力和性能，进而实现业务的快速迭代、开发，降低开销、增加效率。
自2019年阿里云与MongoDB达成战略合作伙伴关系以来，阿里云数据库MongoDB版已广泛应用于互联网、游戏、汽车出行、零售、金融等行业，累计为数万家客户提供MongoDB云数据库服务，MongoDB也取得了国内营收增长8倍的里程碑式成绩，目前阿里云已经成为MongoDB在中国最大的云服务提供商。
MongoDB全球合作伙伴高级副总裁Alan Chhabra表示，阿里云始终如一地提供优秀的云服务，集成最新的 MongoDB产品功能，为中国各行各业提供强大、可扩展且安全的数据库解决方案。通过提供新的 MongoDB云服务，阿里云致力于本地化产品和服务以满足中国市场的新需求，进一步印证了阿里云领先的 DBaaS 提供商的地位。
阿里云数据库负责人李飞飞也表示，与MongoDB合作的四年是非常甜蜜的四年，“阿里云不仅仅是单纯的OEM MongoDB数据内核，更多是把MongoDB能力和阿里云云原生的环境紧密结合起来。通过使用具有阿里云特色的MongoDB数据库，客户们能够实现业务的快速迭代、开发、降低开销、增加效率。”
2023年，阿里云与MongoDB续签了战略合作协议，双方致力于将 MongoDB的最新产品成果与阿里云企业级服务相结合，深耕国内市场，携手技术创新，打造最佳实践。
在今年的用户大会，MongoDB上也宣布推出一项新的云合作伙伴认证计划，该计划名为“Certified by MongoDB DBaaS”（数据库即服务），旨在为云基础设施合作伙伴提供最新MongoDB产品特性的访问权限，并允许他们向自己的客户提供一流的托管数据库服务，包括全文搜索、向量搜索和行业领先的数据加密等功能。
阿里云NoSQL数据库产品线负责人张为表示，在当今AI应用飞速发展的时代，MongoDB与仅存储向量数据的附加解决方案不同，其向量搜索能力通过与原有的高性能和可扩展的主数据库紧密集成，客户能够安全地在整个数据库中充分利用生成式 AI 和专有数据，以更少的代码开发和运营开销来更快地实现业务价值。
不远的将来，阿里云作为MongoDB 重要的云合作伙伴之一，也将能够在阿里云MongoDB 托管服务中提供向量搜索和全文搜索能力，客户将可以第一时间在阿里云MongoDB 使用该能力来构建高级搜索和生成式AI应用程序。
MongoDB总裁兼首席执行官Dev Ittycheria及MongoDB 全球合作伙伴高级副总裁Alan Chhabra共同向阿里云NoSQL数据库产品线负责人张为授予“MongoDB 2024年度DBaaS认证合作伙伴”奖项
关于阿里云MongoDB
MongoDB是一种基于文档的NoSQL数据库,为开发者提供了高性能、高可用性和易用性的灵活且高效的数据存储解决方案。在当今快速发展的软件开发领域,开发者需要一个能够快速适应变化、处理大量数据并且易于扩展的数据库解决方案。
在阿里云平台上运行的MongoDB最新版本,具有灵活的部署架构,能够满足不同的业务场景,还提供了变更实例配置功能,方便您快速应对业务变化,同时在服务可用性、数据可靠性、安全性、运维成本等方面也具有很大的优势,结合阿里云原生的数据分析功能,可助力企业从运营中获得更多的业务洞见,满足了客户的广泛需求。
阿里云作为在中国首发最新版本MongoDB服务的云厂商,一直持续保持先发优势,向开发者提供及时、丰富、完整的生态产品与服务。新的增强功能在提升团队工作效率的同时,还能确保始终一致的开发者体验,降低数据基础设施的复杂性,更好地满足下一代应用程序的需求。
👉点击访问 MongoDB中文官网
👉立即免费试用 MongoDB Atlas
☎️需要支持？欢迎联系我们：400-8662988
✅欢迎关注MongoDB微信订阅号（MongoDB-China），及时获取最新资讯。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05928717e6766736f903b4be79098330/" rel="bookmark">
			SpringAI通过Ollama连接大语言模型通义千问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着大语言模型发展越来越成熟，Apache开源组织也出了自己的SpringAI开源工程
Spring AI项目旨在简化包含人工智能功能的应用程序的开发，避免不必要的复杂性。
该项目从著名的 Python 项目（例如 LangChain 和 LlamaIndex）中汲取灵感，但 Spring AI 并不是这些项目的直接移植。
支持所有主要模型，例如 OpenAI、Ollama、Azure OpenAI、Amazon Bedrock、Huggingface、Google VertextAI、Mistral AI。
支持的模型类型包括“聊天”和“文本到图像”，还有更多模型类型正在开发中。
支持所有主要矢量数据库提供商，例如 Apache Cassandra、Azure 矢量搜索、Chroma、Milvus、Neo4j、PostgreSQL/PGVector、PineCone、Qdrant、Redis 和 Weaviate
本博文分两部分，ollama环境搭建，SpringAI连接通义千问（源代码放在文章最后，可以下载）
说明：本代码使用jdk版本为17
先看效果：
一、ollama环境搭建 可以参考这篇文章的中的第三部分 【三、LLM语言模型搭建】，搭建是一样的，在此就不重复了
FastGTP环境搭建，可直接使用在项目上
二、SpringAI连接通义千问 1、配置文件，如下 上代码
server: port: 8080 spring: application: name: ai ai: ollama: base-url: http://192.168.1.200:11434 chat: enabled: true options: model: qwen:0.5b 2、java连接关键代码
String systemPrompt = "{prompt}"; SystemPromptTemplate systemPromptTemplate = new SystemPromptTemplate(systemPrompt); String userPrompt = message; Message userMessage = new UserMessage(userPrompt); Message systemMessage = systemPromptTemplate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05928717e6766736f903b4be79098330/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48d2cdc0f665d49b59f6ed99dd597103/" rel="bookmark">
			彻底解决 `ModuleNotFoundError: No module named ‘MySQLdb‘` 这个错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： python项目启动时报错，但是mysql相关的驱动都已经安装，mysqlclient、pymysql等
File "/Users/yomi/opt/anaconda3/envs/ticketproject/lib/python3.11/site-packages/sqlalchemy/dialects/mysql/mysqldb.py", line 152, in import_dbapi return __import__("MySQLdb") ^^^^^^^^^^^^^^^^^^^^^ ModuleNotFoundError: No module named 'MySQLdb' 原因分析： 提示：确认你不是在尝试安装 `MySQLdb`，这个库只兼容 Python 2。 -对于 Python 3，选择 `mysqlclient` 或 `PyMySQL` 作为替代。它们都是与 `MySQLdb` 类似，但兼容 Python 3 的库
解决方案： 提示：在终端中激活你的虚拟环境（如果你使用的是虚拟环境）
使用 `pip` 安装 `mysqlclient` 或 `PyMySQL`：
pip install mysqlclient pip install pymysql 如果你使用的是 `PyMySQL`，而你的代码中存在 `import MySQLdb` 语句，需要将它替换为：
import pymysql
pymysql.install_as_MySQLdb()
这样可以在未修改大量现有代码的情况下，确保它们可以使用 `PyMySQL` 作为 `MySQLdb` 的替代。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8645d8b57e5f14f3c397ab2b27db3fee/" rel="bookmark">
			链表OJ--下
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、链表分割二、环形链表I三、环形链表II四、链表的回文结构五、随机链表的复制 前言 一、链表分割 牛客网CM11：链表分割- - -点击此处传送
题解：
思路图：
代码：
二、环形链表I 力扣141：环形链表- - -点击此处传送
思路图:
扩展问题：
代码：
bool hasCycle(struct ListNode *head) { struct ListNode*fast=head,*slow=head; while(fast &amp;&amp; fast-&gt;next) { //slow走一步 slow=slow-&gt;next; //fast走两步 fast=fast-&gt;next-&gt;next; //若相等（相遇）则有环，返回true并退出程序 if(fast==slow) { return true; } } //否则无环 return false; } 三、环形链表II 力扣142：环形链表II- - -点击此处传送
题解：
思路图：
代码：
struct ListNode *detectCycle(struct ListNode *head) { struct ListNode*fast=head; struct ListNode*slow=head; while(fast &amp;&amp; fast-&gt;next) { slow=slow-&gt;next; fast=fast-&gt;next-&gt;next; if(fast==slow) { struct ListNode*meet=slow; while(head !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8645d8b57e5f14f3c397ab2b27db3fee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64ccbf13c351ed53511e92589c969f83/" rel="bookmark">
			Java中启动jar包命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、windows环境 在cmd命令窗口，执行java -jar ***.jar即可启动java程序。按下ctrl+c或直接关闭cmd命令窗口，当前程序都会退出。
windows环境下javaw启动命令代表后台运行，关闭cmd命令窗口仍然运行，在任务管理器可以看到相关服务，如
javaw -jar ***.jar 2、linux环境 java程序启动命令，执行java -jar ***.jar即可启动java程序。按下ctrl+c或直接关闭终端，当前程序都会退出。
在命令的结尾添加“&amp;”，“&amp;”表示该程序可以在后台执行，如
java -jar ***.jar &amp; 但是当窗口关闭时，程序也会中止运行，在命令的最前面加上nohup，这样当终端关闭时，程序就会不挂断运行，如
nohup java -jar ***.jar &amp; 当前程序的打印日志会被写入到当前目录的nohup.out文件中，可以修改写入指定的文件中，如
nohup java -jar ***.jar &gt; log.out &amp; 当前程序的打印日志就会被写入当前目录下log.out文件中，当不想写入日志，可以将日志重定向到/dev/null中，/dev/null代表linux的空设备文件，所有往这个文件里面写入的内容都会丢失，如
nohup java -jar ***.jar &gt; /dev/null &amp; 当只输出错误信息到日志，标准输出不写入日志，直接丢弃，如
nohup java -jar ***.jar &gt; /dev/null 2&gt;error.log &amp; 当标准输出重定向到/dev/null中，然后错误信息输出重定向到标准输出，则错误信息也被定向到了/dev/null中，错误输出同样也被丢弃，如
nohup java -jar ***.jar &gt; /dev/null 2&gt;&amp;1 &amp; 当标准输出重定向到log.out中，然后错误信息输出重定向到标准输出，则错误信息也被定向到了log.out中，如
nohup java -jar ***.jar &gt; log.out 2&gt;&amp;1 &amp; 当需要停止java程序时，通过如下命令找到PID，并根据PID终止进程，如下
ps -ef | grep ***.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64ccbf13c351ed53511e92589c969f83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e1566c2e2f03a13f95d22d7916dad53/" rel="bookmark">
			【Java之新手基础必备】面向对象（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📚博客主页：Zhui_Yi_
🔍：上期回顾：二叉树
❤️感谢大家点赞👍🏻收藏⭐评论✍🏻，您的三连就是我持续更新的动力❤️
🎇追当今朝天骄，忆顾往昔豪杰。
文章目录 前言一、面向对象思想1.引入2.面向过程和面向对象概述①面向过程②面向对象I概述II特点III开发IV设计V特征 代码示例面向过程面向对象 二、类与对象1.类的定义2.对象的创建与使用3.对象的内存图①一个对象的内存图②2个对象的内存图③三个对象的内存图 4.局部变量与成员变量的不同5.形式参数的问题6.匿名对象 三、封装1.定义2.引入3.private关键字4.应用快捷键应用 5.this关键字注意事项 6.toString方法 四、构造方法1.注意事项2.格式3.举例 五、访问控制权限介绍举例示例缺省protectedprivate 总结 总结 前言 又见面喽，本篇文章会给大家带来以下内容：面向对象思想、类与对象及其使用对象的内存图、成员变量和局部变量的区别、匿名对象、封装(private)、this关键字、构造方法。
一、面向对象思想 1.引入 我们想一下我们在做数组的时候，当有多个数组都需要遍历时，我们可以将遍历的代码封装到方法中，需要遍历时，就调用相应的方法即可，提高代码的复用性。但是如果我们要再增添一些功能的时候，比如获取最值，数值逆序等，同样需要将这些功能封装到相应的方法中。但是这样继续封装会发现方法越来越多，于是就想能不能将这些方法继续进行封装呢？
当然有了，通过前面的讲解我们知道类是可以存放方法的，所以，我们就考虑使用类封装来这多个方法，将来再做数组的操作时，不用去找具体的方法，先找到这个类，然后使用这个类中的方法。
2.面向过程和面向对象概述 ①面向过程 我们在前面写程序的时候，我们需要一步一步去实现，而具体的每一步都需要我们去实现和操作，这其实是面向过程开发，即：
就是面向着具体的每一个步骤和过程，把每一个步骤和过程完成，然后由这些功能方法相互调用，完成需求。
②面向对象 I概述 那么当我们随着需求的更改，功能的增多，发现需要面对每一个步骤很麻烦了，那我们能不能把这些步骤和功能在进行封装，封装时根据不同的功能，进行不同的封装，功能类似的封装在一起。这就是面向对象的思想：
其概述为
面向对象是基于面向过程的编程思想
II特点 是一种更符合我们思想习惯的思想
可以将复杂的事情简单化
将我们从执行者变成了指挥者
III开发 就是不断的创建对象，使用对象，指挥对象做事情
IV设计 其实就是在管理和维护对象之间的关系。
V特征 封装(encapsulation)继承(inheritance)多态(polymorphism) 关于各个特征的概念我们会分开详细的讲，在这里不过多阐述。
代码示例 这里以把大象装进冰箱为例：
把大象装进冰箱分三步：打卡冰箱门，把大象装进去，关闭冰箱门。
面向过程 面向过程就是分布用函数实现，代码如下：
public class FaceToProcess { public static void main(String[] args) { open(); in(); close(); } public static void open(){ System.out.println("打开冰箱门"); } public static void close(){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e1566c2e2f03a13f95d22d7916dad53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/725d7596245a750c108b1b8b8c26f65c/" rel="bookmark">
			学习Spring Boot的必读之书《深入浅出 Spring Boot 2.x》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Java 后端开发领域，功能强大的 Spring 开源框架不仅是首选，也是事实上的标准。但由于 Spring 存在配置烦琐、部署不易、依赖管理困难等问题，因此基于 Spring 的快速开发框架 Spring Boot 应运而生，它能大大简化 Spring 应用程序的配置和部署过程。
2018 年，Spring Boot 推出 2.x 版本，随即成为 Java 开发首选框架。教大家如何使用该框架的《深入浅出 Spring Boot 2.x》也在同年出版，当时就赢得诸多 Java 程序员的好评，也帮助他们在工作中成功应用 Spring Boot。
来自豆瓣的读者好评
Spring Boot 采用“约定优于配置”的规则，大部分情况下，依赖它提供的 starter就可以使用默认的约定，然后通过属性文件减少大量的代码，使开发更为简单。
2022 年，Spring Boot 3.x 推出，它相比 Spring Boot 2.x 有了数项重大改进，使得 Java 后端开发更适应当前技术潮流。所以，在《深入浅出 Spring Boot 2.x》原书基础上，作者对内容进行了重磅升级，时隔六年之后推出了《深入浅出 Spring Boot 3.x》。
▼点击下方，即可购书
新书仍然保持了前作由浅入深的技术风格，从一个最简单的项目起步，讲解了全注解下的 Spring IoC 和 Spring AOP、数据库编程、数据库事务、NoSQL 数据库技术、Spring MVC、REST 风格、Spring Cloud 微服务开发等内容。
我们先来了解一下Spring Boot 3.x 究竟为 Java 开发带来了哪些革新。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/725d7596245a750c108b1b8b8c26f65c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2f289d716b6075c1649bc875ab925bd/" rel="bookmark">
			快速将短信从 Android 传输到 iPhone [支持 iPhone 15]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		短信中包含有关工作和生活的重要信息，因此当我们拿到新手机时，它们不会丢失。今天，我们要讨论的是如何将短信从Android快速传输到iPhone，包括最新的iPhone 15。在Android和iOS操作系统之间，我们可以轻松地将短信从Android传输到iPhone吗？尝试一下本文中的3种方法，你就能解决这个问题了。
第 1 部分：使用 SMS Backup+ 将短信从 Android 传输到 iPhone 15 短信备份+可以轻松地将短信从Android传输到iPhone，它会自动备份Android手机上的短信，以及彩信、通话记录。它将通过 Gmail 和 Google 日历导出备份文件。 SMS Backup+ 是一款免费开源软件，供用户使用。但有用户表示，Google和Gmail更改设置后，无法很好地备份。不管怎样，你可以尝试一下。
有关如何使用 SMS Backup+ 将短信从 Android 传输到 iPhone 的指南： 步骤1.下载并安装短信备份+
- 首先，您需要在Android手机上下载并安装SMS Backup+ 。然后使用您的 Gmail 帐户登录 Gmail，然后点击右上角的“设置”按钮。
- 选择“转发和 POP/IMAP ”选项卡。除了“ IMAP 访问”选项外，请点击“启用 IMAP ”和“保存更改”图标。
步骤 2. 将应用程序连接到 Google 帐户
然后启动应用程序并单击“连接”选项将您的 Google 帐户添加到应用程序。点击 Android 手机上的“备份”图标，应用程序会快速将您的短信备份到 Gmail。
步骤 3. 在 iPhone 上下载短信
- 在您的iPhone上，请登录Gmail，您将在“收件箱”中看到来自Android手机的备份邮件。单击邮件，您可以阅读短信。
- 并且您可以将邮件中的图片等文件下载到您的iPhone上。
第 2 部分：通过 Move to iOS 将消息从 Android 传输到 iPhone 15 换到iOS适合新买iPhone的用户，因为这个软件在使用时会默认删除iPhone上的数据。因此，如果您想将消息从 Android 传输到新 iPhone，您可以选择“移至 iOS”应用程序。它可以在短时间内将短信、相机胶卷、联系人、书签等从 Android 传输到 iPhone。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2f289d716b6075c1649bc875ab925bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f1f41c7ec84287f2837c3fa0f8a07ad/" rel="bookmark">
			Tomcat与JDK各版本的兼容性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Tomcat和JDK之间的兼容性通常取决于Tomcat的版本和JDK的版本。以下是Tomcat和JDK之间的一些常见版本兼容性概述：
Tomcat 7： 兼容JDK 1.6、JDK 1.7 和 JDK 1.8。Tomcat 7是基于Java EE 6规范构建的，而JDK 1.6、1.7和1.8都提供了对Java EE 6规范的良好支持。Tomcat 8： 官方文档推荐使用JDK 1.7或JDK 1.8。Tomcat 8.0开始支持Servlet 3.1规范，并且与JDK 1.7和JDK 1.8兼容良好。Tomcat 8.5对JDK 1.8的支持更为完善，并且也支持一些JDK 9的特性（但并非完全兼容）。Tomcat 9： 需要JDK 1.8或更高版本。Tomcat 9基于Java EE 8（现在是Jakarta EE 8）规范，并完全支持Servlet 4.0。虽然JDK 9和JDK 10在某些情况下也可以工作，但Tomcat 9官方推荐使用JDK 1.8或更新的LTS（长期支持）版本，如JDK 11或更高。Tomcat 10： 需要JDK 11或更高版本。Tomcat 10是基于Jakarta EE 9规范构建的，这是Java EE规范迁移到Eclipse基金会后的新版本。Tomcat 10要求至少JDK 11，因为它使用了JDK 11中引入的新特性。Tomcat 11： 需要JDK 11或更高版本。Tomcat 11与Tomcat 10类似，也是基于Jakarta EE规范构建的，并且需要JDK 11或更新的版本来运行。JDK 版本： 从JDK 11开始，Oracle改变了JDK的发布和支持策略，引入了新的长期支持（LTS）版本。JDK 11、17（及未来的LTS版本）是Oracle提供的官方长期支持版本，这些版本会获得更长时间的更新和安全补丁。JDK 8是一个广泛使用的LTS版本，但在2025年之后，Oracle将不再提供免费的公共更新。因此，尽管许多应用程序和服务器（包括Tomcat 7和8）仍在使用JDK 8，但建议升级到更新的JDK版本以获得更好的性能、安全性和支持。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84496011cbfdd81dbdd835fd85a4b1fb/" rel="bookmark">
			【C&#43;&#43;】深度解析：用 C&#43;&#43; 模拟实现 string 类，探索其底层实现细节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
了解string类
string的内存管理
VS下string的结构
​g++下string的结构
string的模拟实现
string的构造函数
浅拷贝
深拷贝
string的遍历
重载 [] 下标访问
迭代器访问
reserve
resize
增删查改
push_back()
append和+=
insert和erase
find
substr
swap 流插入和流提取
getline
string其他基本功能
⭐了解string类 1. 字符串是表示字符序列的类 2. 标准的字符串类提供了对此类对象的支持，其接口类似于标准字符容器的接口，但添加了专门用于操作单字节字符字符串的设计特性。 3. string 类是使用 char( 即作为它的字符类型，使用它的默认 char_traits 和分配器类型 ( 关于模板的更多信息，请参阅basic_string) 。 4. string 类是 basic_string 模板类的一个实例，它使用 char 来实例化 basic_string 模板类，并用 char_traits和allocator 作为 basic_string 的默认参数 ( 根于更多的模板信息请参考 basic_string) 。 5. 注意，这个类独立于所使用的编码来处理字节 : 如果用来处理多字节或变长字符 ( 如 UTF-8) 的序列，这个类的所有成员( 如长度或大小 ) 以及它的迭代器，将仍然按照字节 ( 而不是实际编码的字符 ) 来操作。 总结： 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84496011cbfdd81dbdd835fd85a4b1fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cffbed03a3af5217f8d34a0106c5a2f/" rel="bookmark">
			cyc大佬有地方写的不全，补充（redis篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.redis的数据淘汰策略
当redis内存数据大小达到一定的大小时，就会施行数据淘汰策略，主要有六种策略
2.数据库和缓存的数据一致性
2.1 mySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据
根据数据淘汰策略，先算一下这20W的数据大概占多少内存，然后设置redis的内存，启用从所有数据集中挑选最近最少使用的淘汰策略
2.2 redis缓存和mysql数据库同步
3.Redis持久化
1.RDB持久化（redis默认方式）
将某个时间点的所有数据都存在硬盘中，如果发生故障将丢失最后一次创建快照的数据
触发RDB快照的条件：在指定的时间间隔内，执行指定次数的写操作
2.AOF持久化
所执行的每一条指令，都会记录到appendonly.aof文件中，redis会按照策略将指令存入硬盘中。当redis重启的时候会根据日志文件的内容将写指令从前到后执行一次完成数据恢复的功能
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30ae85662b66e66da5da91352fd43ab2/" rel="bookmark">
			抓住AIGC行业的未来：现在正是进入的最佳时机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 引言一、AIGC行业前景1、技术成熟与应用普及1.1深度学习1.2自然语言处理1.3生成对抗网络 2、商业机会与创新平台2.1内容创作2.2个性化推荐 3、未来展望与个人发展3.1技术人员的发展机会3.2非技术人员的发展机会 二、市场需求1、行业应用需求2、人才市场需求 三、入门指南四、挑战与机遇五、个人选择与规划结语 引言 在当今信息爆炸和技术迅猛发展的时代，人工智能和生成内容（AIGC）行业正迅速崛起，成为创新和创业的新热点。AIGC技术正在改变我们获取、处理和创造信息的方式，无论是在新闻、娱乐还是教育领域。如果你对技术和创新充满热情，那么现在正是进入AIGC行业的最好时机。
一、AIGC行业前景 1、技术成熟与应用普及 AIGC行业目前正处于一个历史性的增长期。这个增长得益于其核心技术——深度学习、自然语言处理和生成对抗网络——的不断成熟，这些技术已经从实验室研究转变为实际应用。随着技术的不断发展和优化，AIGC正在为内容创作、个性化推荐和用户体验优化等领域带来革命性的变化。
1.1深度学习 深度学习是AIGC技术的核心之一，它通过构建多层神经网络来模拟人脑的工作方式，从而实现对复杂数据的分析和理解。以下是一个简单的伪代码样例，展示了如何使用深度学习进行图像分类：
import tensorflow as tf from tensorflow.keras import layers # 构建模型 model = tf.keras.Sequential([ layers.Conv2D(32, (3, 3), activation='relu', input_shape=(28, 28, 1)), layers.MaxPooling2D((2, 2)), layers.Flatten(), layers.Dense(64, activation='relu'), layers.Dense(10, activation='softmax') ]) # 编译模型 model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy']) # 训练模型 model.fit(train_images, train_labels, epochs=5) # 评估模型 test_loss, test_acc = model.evaluate(test_images, test_labels) print('Test accuracy:', test_acc) 1.2自然语言处理 自然语言处理是AIGC技术的另一个重要组成部分，它使得机器能够理解和处理人类语言。以下是一个简单的伪代码样例，展示了如何使用自然语言处理进行文本分类：
import tensorflow as tf from tensorflow.keras import layers # 构建模型 model = tf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30ae85662b66e66da5da91352fd43ab2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc5d8ffab241dc137324102d3034de20/" rel="bookmark">
			AIGC：一个值得探索的新蓝海？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
AIGC的概念
AIGC的发展历程
AIGC的发展现状及应用
AIGC行业的发展前景与技术趋势
行业的潜力与市场需求
竞争情况与行业挑战
结论
AIGC的概念
AIGC（Artificial Intelligence Generated Content）—— 生成式人工智能，是指基于生成对抗网络、大型预训练模型等人工智能的技术方法，通过已有数据的学习和识别，以适当的泛化能力生成相关内容的技术。 (——百度百科)
人工智能算法生成的各种形式的内容，包括文字、图像、音频、视频等。这些内容通常是通过机器学习、深度学习等技术生成的，而非由人类直接创作。AIGC在各种领域都有应用，例如自然语言处理领域的文章写作、图像生成领域的艺术创作、音频合成领域的音乐创作等。
AIGC的发展历程 人工智能生成内容（AIGC）的发展历程可以追溯到几十年前的早期实验和研究，但其真正开始引起人们广泛关注并在各个领域得到应用是近年来的事情。以下是AIGC发展的主要里程碑：
（参考：中国信息通信研究院） 早期实验和研究（20世纪中叶至21世纪初）：
20世纪50年代，计算机科学家开始尝试使用计算机生成文字和音乐等内容，虽然结果并不理想。20世纪70年代至80年代，随着计算机硬件和算法的进步，一些基于规则和模板的系统出现，可以生成简单的文本和图像。 统计语言模型时代（21世纪初至2010年代）：
21世纪初，随着统计语言模型（如n-gram模型）和机器翻译技术的发展，计算机开始能够生成更为复杂的文本内容。2000年代中期至2010年代初期，随着深度学习技术的兴起，循环神经网络（RNN）和长短期记忆网络（LSTM）等模型被广泛应用于自然语言处理领域，使得计算机生成的文本更加流畅和连贯。 深度学习时代（2010年代至今）：
2010年代初期至中期，深度学习技术（尤其是生成对抗网络GAN）的快速发展，为AIGC带来了前所未有的进步。2017年，OpenAI发布了GPT（Generative Pre-trained Transformer）模型，该模型基于Transformer架构，可以生成高质量的文本内容，并且在各个领域展现了出色的表现。2019年，OpenAI发布了GPT-2模型，该模型具有史无前例的规模和生成能力，引发了广泛的讨论和关注。 应用领域的拓展（2010年代至今）：
2010年代后期至今，AIGC开始在各个领域得到广泛应用，包括媒体与娱乐、商业与营销、教育与科研等。在媒体与娱乐领域，AIGC被用于自动写作新闻、创作音乐、生成艺术作品等。在商业与营销领域，AIGC被用于生成营销内容、设计产品、提供客户服务等。在教育与科研领域，AIGC被用于自动生成教学材料、辅助学习和研究等。 AIGC的发展现状及应用 人工智能生成内容（AIGC）的发展现状处于快速发展的阶段，各个领域都在积极探索和应用这项技术，先来说说AIGC当下的发展状况。
语言生成模型的进步： 最近几年，随着深度学习技术的发展，语言生成模型取得了巨大进步。OpenAI的GPT系列以及其他类似的模型在自然语言生成方面取得了突破，能够生成高质量、连贯的文本内容。广泛应用于多个领域： AIGC技术已经被广泛应用于多个领域，包括媒体与娱乐、商业与营销、教育与科研等。在媒体与娱乐领域，AIGC被用于自动写作新闻、创作音乐、生成艺术作品等。在商业与营销领域，AIGC被用于生成营销内容、设计产品、提供客户服务等。在教育与科研领域，AIGC被用于自动生成教学材料、辅助学习和研究等。面临的挑战和问题： 尽管AIGC技术取得了巨大进步，但仍然面临一些挑战和问题。例如，AIGC生成的内容可能存在知识不准确、逻辑不连贯、风格不统一等问题，需要不断改进和优化。此外，AIGC还可能带来一些伦理和法律问题，如内容原创性、版权问题等，需要加以解决。研究和发展方向： 未来，AIGC技术的研究和发展方向包括但不限于模型的进一步优化和扩展、多模态内容生成、个性化内容生成、内容真实性和可信度的提升、伦理和法律框架的建立等。 另外AIGC的涵盖了各个领域，从媒体与娱乐到商业与营销，再到教育与科研，都有广泛的应用。
媒体与娱乐：
自动写作新闻： AIGC技术被用于自动生成新闻稿件，可以根据实时数据和事件情况生成新闻报道，提高新闻生产的效率和速度。创作音乐和歌词： AIGC可以生成音乐和歌词，帮助音乐制作人和创作者快速产生原创作品或灵感。电影剧本和剧情生成： AIGC技术可以用于生成电影剧本和剧情，辅助编剧和导演进行创作和策划。 商业与营销：
营销内容生成： AIGC可以用于生成营销内容，如广告语、产品描述、社交媒体帖子等，帮助企业提升品牌形象和销售效果。产品设计和定制： AIGC可以生成产品设计方案和定制化产品建议，帮助企业满足客户个性化需求。客户服务和沟通： AIGC可以用于生成客户服务回复和沟通内容，提高客户满意度和服务效率。 教育与科研：
教学材料和课程内容生成： AIGC可以用于自动生成教学材料和课程内容，帮助教育者快速制作教学资源。辅助学习和智能导学： AIGC可以生成个性化学习内容和智能导学系统，根据学生的学习需求和水平提供定制化的学习资源和建议。研究文献和论文撰写： AIGC可以用于生成研究文献和论文的摘要、引言、结论等部分，辅助研究人员进行文献调研和论文撰写。 AIGC行业的发展前景与技术趋势 AIGC行业的核心在于使用人工智能技术自动生成各种内容，包括文本、图像、视频和音频等。这一技术的发展受益于近年来机器学习、尤其是深度学习技术的突破。通过训练大型神经网络模型，AIGC技术能够理解和模拟人类语言和视觉艺术的复杂模式，从而创造出符合人类审美和语义连贯性的内容。
发展前景：
应用场景拓展： AIGC技术将会在更多的领域得到应用，涵盖媒体与娱乐、商业与营销、教育与科研等各个方面。随着应用场景的不断拓展，AIGC技术将有更多的机会发挥作用，并且催生出新的商业模式和创新产品。个性化内容生成： 未来的AIGC技术将会更加注重个性化和定制化内容的生成，能够根据用户的偏好、需求和行为习惯，生成更加个性化、符合用户口味的内容。这将为用户提供更加个性化的体验，提升用户满意度和忠诚度。自动化内容生产： AIGC技术的发展将推动内容生产的自动化和智能化。未来，很多传统的内容生产过程可能会被AIGC技术所取代，从而提高生产效率、降低成本，并且释放人力资源用于更加创造性的工作。 技术趋势：
模型规模的增大： 随着硬件计算能力的提升和算法的改进，未来AIGC模型的规模将会不断增大，模型的参数量和训练数据规模将会更大，从而提高生成内容的质量和多样性。多模态生成： 未来的AIGC技术可能会向多模态生成方向发展，不仅可以生成文字内容，还可以同时生成图像、音频、视频等多种形式的内容，从而实现更加丰富的信息表达。个性化生成： 随着个性化推荐和定制化服务的需求增加，未来的AIGC技术可能会朝向个性化生成的方向发展，根据用户的偏好和需求生成定制化的内容。 行业的潜力与市场需求 人工智能生成内容（AIGC）行业具有巨大的潜力和市场需求，主要体现在以下几个方面：
内容生产效率提升： AIGC技术能够大幅提升内容生产的效率，减少人力成本和时间成本。在媒体、广告、电商等行业，快速产出高质量的内容对于吸引用户和推动销售至关重要，因此这些行业对于AIGC技术有着强烈的需求。个性化内容定制： 随着消费者需求的个性化和多样化，企业需要能够提供定制化的内容来吸引用户。AIGC技术能够根据用户的偏好和行为习惯生成个性化的内容，满足用户的需求，因此在内容定制方面有着广阔的市场需求。新媒体和社交媒体内容： 随着新媒体和社交媒体的快速发展，对于各类内容的需求日益增加。AIGC技术能够快速生成适合在社交媒体上分享的内容，吸引用户关注和互动，因此在这一领域有着巨大的市场潜力。教育和培训内容： 随着在线教育和远程培训的普及，对于教育和培训内容的需求也在不断增加。AIGC技术能够生成丰富多样的教学材料和课程内容，帮助教育机构和企业提供更加有效的教育和培训服务，因此在这一领域有着巨大的市场需求。智能客服和虚拟助手： 随着人工智能技术的发展，智能客服和虚拟助手在各行各业的应用越来越广泛。AIGC技术能够生成自然语言对话，提供智能化的客户服务和咨询，因此在智能客服和虚拟助手领域也有着巨大的市场潜力。 当前，随着数字化和信息化的深入发展，企业和个人对于高质量、高效率内容的需求不断增长。AIGC技术正成为满足这一需求的关键工具。例如，自动化的内容生成可以帮助媒体行业解决新闻报道速度慢的问题，而个性化的教育内容生成则能提供更符合学习者需求的学习材料。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc5d8ffab241dc137324102d3034de20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/151ad9d4374aa2ca05d76702fd92eaf8/" rel="bookmark">
			alertmanager 配置钉钉告警以及模板（prometheus-webhook-dingtalk）基于 kube-prometheus
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		alertmanager 的 receive 并不直接支持钉钉的 url，要部署插件容器 prometheus-webhook-dingtalk
并且有个需要注意的地方是，当 receives 为钉钉时 (webhook_configs)，它的告警模板不是在 alertmanager 的配置文件中指定的，而是在钉钉插件 prometheus-webhook-dingtalk 中指定的。
编写 prometheus-webhook-dingtalk 配置文件和模板 vim dingtalk-configmap.yaml，这里记的替换你的钉钉 url token。
apiVersion: v1 kind: ConfigMap metadata: name: prometheus-webhook-dingtalk-config namespace: monitoring data: config.yml: |- templates: - /etc/prometheus-webhook-dingtalk/default.tmpl targets: webhook1: url: https://oapi.dingtalk.com/robot/send?access_token=xxxxxxxxxxxx #修改为钉钉机器人的webhook message: text: '{{ template "default.tmpl" . }}' default.tmpl: | {{ define "default.tmpl" }} {{- if gt (len .Alerts.Firing) 0 -}} {{- range $index, $alert := .Alerts -}} ============ = **&lt;font color='#FF0000'&gt;告警&lt;/font&gt;** = ============= #红色字体 **告警名称:** {{ $alert.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/151ad9d4374aa2ca05d76702fd92eaf8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72800970741213014c0aa2aada3ebc67/" rel="bookmark">
			Java 创建事件(Event)、事件监听器(EventListener)、事件发布(publishEvent)详解和相关demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java中，你可以使用事件（Event）、事件监听器（EventListener）和事件发布（publishEvent）来实现事件驱动的编程模型。下面我将简要介绍一下它们的基本概念：
事件（Event）：事件是在软件应用程序中发生的某种事情，可以是用户交互、系统状态变化等。事件通常用一个类来表示，这个类包含了描述事件的相关信息。例如，如果你正在构建一个图形用户界面（GUI）应用程序，那么鼠标点击、键盘输入等就可以作为事件。
事件发布（publishEvent）：事件发布指的是在事件发生时通知所有注册的监听器，并调用相应的处理方法。事件发布者负责管理监听器的注册和通知。
事件监听器（EventListener）：事件监听器是一个接口，包含了处理特定类型事件的方法。当事件发生时，监听器会被通知并调用相应的处理方法。在Java中，通常需要自定义事件监听器来处理自定义的事件类型。
实现步骤 ： ApplicationEventPublisher 是 Spring Framework 中用于发布事件的接口。publishEvent 方法是其主要方法之一，用于发布事件给注册的监听器。当你调用 publishEvent 方法时，Spring 会将事件传递给所有注册的监听器，这些监听器可以在事件发生时执行特定的逻辑。
通常，你可以通过以下步骤来使用 ApplicationEventPublisher 的 publishEvent 方法：
实现一个事件类，通常是继承自 Spring 的 ApplicationEvent 类。在你的应用程序中注册一个或多个监听器，这些监听器会监听特定类型的事件。当某个条件被满足时，创建该事件的实例，并通过 ApplicationEventPublisher 的 publishEvent 方法发布该事件。 这样，所有注册的监听器都将收到该事件，并且可以执行相应的逻辑。
1、事件对象（Event） 事件对象是包含了事件相关信息的类，用于在事件源和事件监听器之间传递数据。必须继承ApplicationEvent。
package com.yan.project.event; import org.springframework.context.ApplicationEvent; /** * @description: 事件对象（Event） * * @create: 2024-05-16 15:27 **/ public class MyEvent extends ApplicationEvent { private EventVo eventVo; public MyEvent(Object source, EventVo eventVo) { super(source); this.eventVo = eventVo; } public EventVo getEventVo() { return eventVo; } } 小技巧： idea中可以点击如图小按钮，自动跳转至监听事件中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72800970741213014c0aa2aada3ebc67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a97d0aed42c7306855f72d09e793056/" rel="bookmark">
			初始Java篇（JavaSE基础语法）（8）认识String类（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		找往期文章包括但不限于本期文章中不懂的知识点：
个人主页：我要学编程(ಥ_ಥ)-CSDN博客
所属专栏：JavaSE
目录
常用操作String的方法
字符串构造
String对象的比较
equals方法——比较对象的内容
compareTo——比较的是字符串大小
compareToIgnoreCase——忽略大小写的比较
字符串查找 字符串的转化
数值和字符串转化
大小写转换
字符串转数组 格式化
字符串替换 字符串拆分
简单介绍：在C语言中已经涉及到字符串了，但是在C语言中要表示字符串只能使用字符数组或者字符指针，可以使用标准库提供的字符串系列函数完成大部分操作，但是这种将数据和操作数据方法分离开的方式不符合面相对象的思想，而字符串应用又非常广泛，因此Java语言专门提供了String类。
常用操作String的方法 字符串构造 String类提供的构造方式非常多，常用的就以下三种：
方式一：直接赋值。
String s1 = "Hello"; 方式二：使用创建对象的方法。
String s2 = new String("Hello"); 方式三：在方法二的基础上，传入字符数组作为参数。 char[] ch = {'H','e','l','l','o'}; String s3 = new String(ch); 示例： 上面三种构造情况，用专业术语总结就是：使用常量串构造，new Sting对象，使用字符数组进行构造。
注意：
1. 我们在前面简单学习了一下String类，它是一个引用数据类型，内部存储的是一个地址，而不是字符串本身。
2. String类的字符串常量是储存在一个名为value的字符数组中的。
3. Java中" "（双引号）里的内容都被认作是String类型对象。简单理解就是字符串。
String对象的比较 下面我们就来深入理解为什么==比较的不是String对象的内容？
public class Test { public static void main(String[] args) { String s1 = new String("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a97d0aed42c7306855f72d09e793056/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bc6721ca0826f0b42a5d4b695a032cd/" rel="bookmark">
			MySQL三种打开方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL提供了一个命令行客户端。
点击开始菜单，找到 MySQL 8.0 Command Line Client
在弹出的窗口中，输入 root 用户的密码，按下回车
出现此界面表示MySQL 连接成功，可以正常使用了
方式二：文件目录下连接
=============================================================================
进入MySQL的默认安装目录 C:\Program Files\MySQL\MySQL Server 8.0\bin ，这个目录下有一个叫 mysql 的文件，这个文件用来连接MySQL的客户端。
在此目录的地址栏中输入 cmd 后 按回车键，在当前目录打开命令提示符
输入以下命令连接MySQL客户端
mysql -uroot -proot
出现此界面表示MySQL 连接成功
上述指令中，mysql指令本质上是调用了 mysql.exe 这个程序，这个程序存放在bin目录下，这也就意味着，我们需要进入 bin 目录，才能使用 mysql 这个指令连接MySQL客户端，这种方式比较麻烦，使用的也比较少。
我们可以通过配置环境变量，使 mysql.exe 可以在任何目录下都可以被调用，也就是使用第三种方式连接MySQL客户端。
方式三：命令行连接
===========================================================================
使用Windows系统自带的命令行（cmd）连接MySQL，这也是学习阶段常用的连接方式。
首先我们需要配置环境变量，右键计算机，选择属性。
系统窗口中选择左侧高级系统属性
系统属性窗口中，选择右下角环境变量
环境变量窗口中，选中下方的 Path 变量，点击编辑。
在编辑环境变量窗口中，点击右侧的新建，在下侧出现的输入框中写入 MySQL的bin目录路径，点击确认。
MySQL的默认安装路径在C盘下：C:\Program Files\MySQL\MySQL Server 8.0\bin，如果你的路径不是默认路径则需要修改成你的安装路径。
后续窗口依次点击确认即可，到这里，环境变量配置完毕，可以在任意位置调用mysql指令了。
点击开始菜单，输入 cmd，打开命令提示符
在命令提示符（任意目录）中输入连接指令。
MySQL的连接指令格式如下：
mysql [-h 127.0.0.1] [-p 3306] -u 用户名 -p 密码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bc6721ca0826f0b42a5d4b695a032cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a2d10c6dabec740339d0285645977e3/" rel="bookmark">
			Appium 华为鸿蒙系统ADB无线调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.获取鸿蒙设备信息platformName和platformVersion
# 在前置参数中 # platformName 就直接填写 Android # platformVersion 先便填写一个版本(10、11、12先随便填写一个版本)，然后去执行脚本 # 然后查看报错(如果没报错，那就恭喜你，你随便懵的版本号是对的)。入下图，红色箭头所对应的就是你鸿蒙系统对应的Android版本(我的对应的就是 Android 10)，直接将 platformVersion 改成对应的就行 如果你说第一次在鸿蒙系统上执行脚本，在手机上会自动弹出一下几个程序的安装，请点击确认，这是在安装脚本驱动程序。
Appium Settings io.appium.uiautomator2.server io.appium.uiautomator2.server.test 2.设置usb调试
第一步，设置你的鸿蒙手机：
设置 &gt; 系统和更新 &gt; 开发人员选项 &gt; 勾选：USB 调试 和 "仅充电"模式下允许ADB调试。
注意：请务必勾选 "仅充电"模式下允许ADB调试 否则进行无线调试，只能一直插着usb进行调试。
第二步，adb连接鸿蒙手机:
1. 电脑usb插上鸿蒙手机，弹出框中确认进行usb调试，添加信任。
打开电脑终端，输入：adb devices
如上图，表示usb调试连接成功
2. 打开一个端口用于连接无线调试。
终端输入：adb tcpip 5555。
5555 为端口号，也可是其他的，但是注意不要被占用。
如上图表示开启成功。
3. 查询你手机的ip地址
保证你电脑和鸿蒙手机在同一个wiffi下(同局域网下)；
步骤：在设置中找到你的WLAN你的无线网络管理，找到你正连接的无线网络并点击，查看详细信息，详细信息里面有ip。
4. 无线连接手机
终端输入： adb connect 192.168.x.xxxx:5555
192.168.x.xxxx就是你查到的手机ip地址；5555就是你电脑刚才开启的端口号
上图就表示连接成功。
也可以进行一下验证，在终端输入：adb devices
断开无线连接：adb disconnect 192.168.x.xxx:555
断开所有连接：adb disconnect
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a2d10c6dabec740339d0285645977e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72e933645d9bdcee8377cf82063fcd53/" rel="bookmark">
			Python中的Faker库：生成Mock数据的利器（文末有场景举例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Faker库是Python中一个强大的Mock数据生成库，可以帮助开发者快速生成各种Mock数据，从而简化开发和测试过程。在开发项目中，我们经常需要生成一些虚拟数据，如虚拟用户、订单、地址等。为了简化这个过程，Python提供了Faker库，一个强大的Mock数据生成器。本文将详细介绍Faker库的用法、作用以及代码示例，帮助你更好地在项目中运用Faker。
一、Faker库简介
Faker是Python的一个第三方库，用于生成虚拟数据。它支持全球各地的地名、职业、性别等数据生成。Faker库的核心功能是通过强大的生成算法，随机生成真实世界中的类似数据。Faker库广泛应用于数据测试、数据清洗和数据填充等领域。
二、Faker库的安装
Faker库的安装非常简单，只需使用pip命令即可：
pip install Faker 三、Faker内置测试数据的用法
from faker import Faker from collections import OrderedDict # fake = Faker(["en_US", "zh_CN", "ja_JP"]) fake = Faker(["zh_CN"]) # print(fake.name()) # print(fake['en-US'].name()) # print(fake.company()) # 1、使用？#自定义规则，随机生成字符串 print(fake.bothify()) # 默认生成字符串格式： 05 RW print(fake.bothify(text="666????####", letters='我们的家')) # letters的字符串随机给text的？使用，##默认数字代替，格式如： 我我的我4777 # 2、使用^自定义规则，随机生成16进制字符串 print(fake.hexify(text='MAC Address: ^^:^^:^^:^^:^^:^^', upper=True)) # MAC Address: CD:18:FC:9F:B6:49 # 3、随机生成 i18n 语言的代码 print(fake.language_code()) # yo # 4、使用？自定义规则，随机生成ASCII字符串 print(fake.lexify(text='Random Identifier: ??????????', letters='我ABCDE')) # Random Identifier: CBC我DD我ABE # 5、随机生成 i18n 区域设置 print(fake.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72e933645d9bdcee8377cf82063fcd53/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/358/">«</a>
	<span class="pagination__item pagination__item--current">359/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/360/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>