<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49f6e331f5766fb8afb87b6799e52f5a/" rel="bookmark">
			Android Studio中使用Git——结合GitLab
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		5 Android Studio中使用Git
======================
5.1 将项目上传到GitLab 本地已创建好的项目为Blure_background_demo
5.1.1 配置忽略文件
Android Studio创建项目后会自动生成.gitignore文件，这个文件可以用来忽略那些不用加入到仓库的文件。项目根目录下与module目录下都会生成该文件，如下：
一般情况下我们只需要将项目根目录下的/.idea/workspace.xml与/.idea/libraries改成.idea即可，其他没有特殊要求就用默认的。如下：
修改前：
修改后：
5.1.2 初始化本地Git仓库
点击Android Studio顶部菜单栏上的VCS–&gt;Import into Version Control–&gt;Create Git Repository，如图：
然后选择需要初始化的项目根目录，如图：
初始化之后发现文件名由原来的白色变成了红色，这表示文件已经被git跟踪了，但是并没有添加到仓库中。如图：
5.1.3 将本地Git仓库已与远程仓库进行关联
打开项目文件夹，在该文件夹中打开Git Bash。输入如下命令后就代表本地Git仓库已与远程仓库进行关联了。
git remote add origin git@gitlab.com:XXXXXXX/blure_background_demo.git
命令的来源如下
操作的具体步骤如下:
1.进入下面的目录，右键—Git Bash Here
2.然后在命令窗口输入下面的命令
其中git@gitlab.com:XXXXXX/blure_background_demo.git为我们项目的远程地址，可以到我们前面创建项目中复制，参考上面的命令来源。
5.1.4 添加文件
选中项目的根目录，点击Android Studio顶部菜单栏上的VCS–&gt;Git–&gt;Add…，如下图：
添加文件后发现文件名由原来的红色变成了绿色，说明已经将文件添加进仓库了。如下图：
5.1.5 提交文件
每次提交前需要先更新项目，原因是如果是多人合作的项目，需要先将远程仓库中他人提交的最新代码更新到本地仓库。然后选中Merge，点击OK，如果本地代码与远程代码有冲突就会弹出冲突提示，根据需求Merge即可，如图：
Update后就可以提交文件了，选中项目的根目录，点击Android Studio顶部菜单栏上的VCS–&gt;Git–&gt;Commit Directory…，如图：
然后会弹出如下提交框，这里可以选择你要提交的文件和填写提交信息，如图：
提交文件后发现文件名由原来的绿色又变成了最开始的白色，说明已经将文件提交上仓库了。如图：
5.1.6 将提交的文件推送到远程仓库
选中项目的根目录，点击Android Studio顶部菜单栏上的VCS–&gt;Git–&gt;Push…，如下图：
点击Push后，就可以在GitLab上看到刚刚推送的内容了。如下图：
5.2 从GitLab上clone项目 首先到GitLab上复制项目的地址，如图：
然后点击Android Studio顶部菜单栏上的VCS–&gt;Checkout from Version Control–&gt;Git ，如图：
最后填写相应的信息即可，如下图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49f6e331f5766fb8afb87b6799e52f5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a457661e913ff9155dbfb0f764f7fd1e/" rel="bookmark">
			Linux网络配置（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux网络配置大全 Linux网络配置一.网络地址配置网络地址查看–ifconfig使用网络配置命令设置网络接口参数-ifconfig禁用(临时)或者重新激活网卡设置虚拟网络接口 修改网络配置文件网络接口配置文件 IP命令详解OPTIONS选项OBJECT对象 ip link 二、获取和修改主机名hostname查看主机名临时修改主机名永久修改主机名 三、Route命令观察路由表信息输出详解添加路由删除路由添加、删除默认网关记录 四、netstat命令命令介绍命令选项 五、获取socket统计信息-ss语法选项 六、测试网络连接pingtcppingtraceroute命令（路由跟踪） 七、域名解析-nslookup主服务器配置文件 八、本地主机映射配置映射关系 Linux网络配置 一.网络地址配置 网络地址查看–ifconfig 命令格式：ifconfig 或 ifconfig +网卡名
ifconfig [DEVICE] ##查看网络信息
​ 第一部分的第一行显示网卡状态信息。
eth0表示第一块网卡。
UP代表网卡开启状态。
RUNNING代表网卡的网线被接上。
MULTICAST表示支持组播。
第二行显示网卡的网络信息。
inet（IP地址）
broadcast（广播地址）
netmask（掩码地址）
RX表示接收数据包的情况，TX表示发送数据包的情况。
lo表示主机的回环网卡，是一种特殊的网络接口，不与任何实际设备连接，而是完全由软件实现。与回环地址（127.0.0.0/8 或 ::1/128）不同，回环网卡对系统显示为一块硬件。任何发送到该网卡上的数据都将立刻被同一网卡接收到。
使用网络配置命令 在Linux主机中，手工修改网络配置有两种最基本的方法：
1 临时配置：使用命令调整网络参数
(1)简单、快速，可直接修改运行中的网络参数
(2)一般只适合在调试网络的过程中使用
(3) 系统重启以后，所做的修改将会失效
2 固定设置：通过配置文件修改网络参数
(1) 修改各项网络参数的配置文件
(2)适合对服务器设置固定参数时使用
(3) 需要重载网络服务或者重启以后才会生效
(4) 相对而言复杂一点，但相当于“永久配置”
设置网络接口参数-ifconfig ifconfig DEVICE IP netmask NETMASK ##设置ip地址 ifconfig eth0 192.168.168.1/24 禁用(临时)或者重新激活网卡 ifconfig 网络接口 up ifconfig 网络接口 down 设置虚拟网络接口 在对服务器进行调试的过程中，有时需临时在同一个网卡上使用一个新的IP地址，但又不能覆盖原有IP地址而导致服务程序不可用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a457661e913ff9155dbfb0f764f7fd1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59a2f28aa30f0a51d536cc31f37d8cc8/" rel="bookmark">
			Android Studio 打包APK（详细版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		① 自定义Apk名字 ② 增加构建类型
③ 增加版本名
④ 增加日期时间
总结
前言
===============================================================
做Android开发肯定对APK不陌生，你现在Android手机上所有的应用都是apk，只不过分为系统自带和第三方。
正文
===============================================================
Android打包APK在开发中是必不可少的一个环节，相信你可能已经会了，或者在别的博客中看到过了，但是其实还有一些细节是你所不知道的。
一、新建项目
本着实践的态度，新建一个GenerateAPK项目。
创建完成之后，你可以运行一下，运行在真机或者虚拟机都可以。
二、生成Debug和Release包
当你看到这个页面的时候，这个APK就已经安装在这个模拟器上面了，而这个APK就是debug版本的，但是它是运行时生成的，不是打包生成的。
怎么查看这个APK呢？
把当前项目切换成Project，然后找到build文件夹。只要你的项目运行了，就会生成这个文件夹，然后你可以通过下图
此时你可以将这个app-debug.apk复制，然后通过QQ发送到你自己的手机上，然后你在手机上下载上下载试着安装一下，你看能不能行。
当然是不行的，只有release版本的APK才能安装在自己的手机上。
从这个图片上来看，你已经看到不能安装的原因了。
通过签名jks来试试，点击导航栏的Build→Generate Signed Bundle / APK…
Next
这里需要一个商店的key，因为没有，所以创建一个新的，点击Create new…
首先指明生成的jks文件的路径，点击这个文件夹图标。
我个人习惯放在D盘的APK目录下，然后命名jks的名称为GenerateAPK，
然后点击OK。
然后输入这个jks和别名的一些相关信息，上方的商店密码和别名密码可以设置为一样的，这样便于记忆，只不过安全系数就降低了。我上面设置的是123456，信息都设置好了之后，点击OK。
如果出现这个弹窗，你可以不用担心，点击OK。
这里勾选上记住密码。
选择release，下面两个都勾选上，然后点击Finish。
当你看到屏幕的右下角出现这个提示时，说明你的APK已经生成了，你可以在你的app下看到多了一个release的文件夹，里面就是app-release.apk包，下面你可以复制发到手机上，然后下载，手机上是可以安装的。
手机上安装成功。
下面通过秘钥jks来生成debug包试试看。
点击Finish。
把这个发到你的手机上。你会发现也是可以安装的，这是为什么呢？
那个这种方式生成的包在实际开发中起到什么作用呢？
在实际开发中，如果是自己测试，那么通过就直接用usb安装在手机上，此时就是文中第一种情况。
而如果当项目要上线或者上应用市场时，就需要用jks来生成release包上传到应用市场上。
实际开发中还有一点就是你的应用自己自己测试的并不是很到位，因此产品和测试会需要让你打包给他们做进一步测试，此时你可以给通过jks生成的debug包，也可以给release包，但是通常是debug包。
我想现在你已经明白了这些包的含义了。
三、打包的细节优化
从上面的操作中，你已经知道了一些内容，而在基本的开发中也是会用到的，而为了更好区别不同的包名，常用会给apk进行一个重命名，让你一眼就知道这个apk是哪个项目的。
① 自定义Apk名字 修改app下的build.gradle
// 自定义打包名称
android.applicationVariants.all { variant -&gt;
variant.outputs.all {
outputFileName = “GenerateAPK.apk”
}
}
添加位置如下图所示，在android{}闭包中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59a2f28aa30f0a51d536cc31f37d8cc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cf677ee4f3f94e334a25f068b2ecd2c/" rel="bookmark">
			人工智能大语言模型微调技术：SFT 监督微调、LoRA 微调方法、P-tuning v2 微调方法、Freeze 监督微调方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人工智能大语言模型微调技术：SFT 监督微调、LoRA 微调方法、P-tuning v2 微调方法、Freeze 监督微调方法 1.SFT 监督微调 1.1 SFT 监督微调基本概念 SFT（Supervised Fine-Tuning）监督微调是指在源数据集上预训练一个神经网络模型，即源模型。然后创建一个新的神经网络模型，即目标模型。目标模型复制了源模型上除了输出层外的所有模型设计及其参数。这些模型参数包含了源数据集上学习到的知识，且这些知识同样适用于目标数据集。源模型的输出层与源数据集的标签紧密相关，因此在目标模型中不予采用。微调时，为目标模型添加一个输出大小为目标数据集类别个数的输出层，并随机初始化该层的模型参数。在目标数据集上训练目标模型时，将从头训练到输出层，其余层的参数都基于源模型的参数微调得到。
1.2 监督微调的步骤 具体来说，监督式微调包括以下几个步骤：
预训练： 首先在一个大规模的数据集上训练一个深度学习模型，例如使用自监督学习或者无监督学习算法进行预训练；微调： 使用目标任务的训练集对预训练模型进行微调。通常，只有预训练模型中的一部分层被微调，例如只微调模型的最后几层或者某些中间层。在微调过程中，通过反向传播算法对模型进行优化，使得模型在目标任务上表现更好；评估： 使用目标任务的测试集对微调后的模型进行评估，得到模型在目标任务上的性能指标。 1.3 监督微调的特点 监督式微调能够利用预训练模型的参数和结构，避免从头开始训练模型，从而加速模型的训练过程，并且能够提高模型在目标任务上的表现。监督式微调在计算机视觉、自然语言处理等领域中得到了广泛应用。然而监督也存在一些缺点。首先，需要大量的标注数据用于目标任务的微调，如果标注数据不足，可能会导致微调后的模型表现不佳。其次，由于预训练模型的参数和结构对微调后的模型性能有很大影响，因此选择合适的预训练模型也很重要。
1.4 常见案例 样例 1 在计算机视觉中，低层的网络主要学习图像的边缘或色斑，中层的网络主要学习物体的局部和纹理，高层的网络识别抽象的语义，如下图所示。因此，可以把一个神经网络分成两块：
低层的网络进行特征抽取，将原始信息变成容易被后面任务使用的特征；
输出层的网络进行具体任务的预测。输出层因为涉及到具体任务没办法在不同任务中复用，但是低层的网络是具有通用型的，可以应用到其他任务上。
下图表示的是将预训练模型的前 L-1 层的参数复制到微调模型，而微调模型的输出层参数随机初始化。在训练过程中，通过设置很小的学习率，从而达到微调的目的。
样例 2
BERT 模型是 Google AI 研究院提出的一种预训练模型，通过预训练 + 微调的方式于多个 NLP 下游任务达到当时最先进水平，如实体识别、文本匹配、阅读理解等。与样例 1 一样，BERT 模型微调时，将预训练好的模型参数复制到微调模型，而输出层参数随机初始化。
1.5 SFT 监督微调的主流方法 随着技术的发展，涌现出越来越多的大语言模型，且模型参数越来越多，比如 GPT3 已经达到 1750 亿的参数量，传统的监督微调方法已经不再能适用现阶段的大语言模型。为了解决微调参数量太多的问题，同时也要保证微调效果，急需研发出参数高效的微调方法（Parameter Efficient Fine Tuning, PEFT）。目前，已经涌现出不少参数高效的微调方法，其中主流的方法包括：
LoRAP-tuning v2Freeze 2. LoRA 微调方法 2.1 LoRA 微调方法的基本概念 LoRA（Low-Rank Adaptation of Large Language Models），直译为大语言模型的低阶自适应。LoRA 的基本原理是冻结预训练好的模型权重参数，在冻结原模型参数的情况下，通过往模型中加入额外的网络层，并只训练这些新增的网络层参数。由于这些新增参数数量较少，这样不仅 finetune 的成本显著下降，还能获得和全模型参数参与微调类似的效果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cf677ee4f3f94e334a25f068b2ecd2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63883a9be396d6b6eb8896bee20253a1/" rel="bookmark">
			Kafka学习之：mac 上安装 kafka
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Brew 安装1. xcode-select --install2. brew install kafka Docker 安装1. 构建 docker-compose.ymldocker 文件解析zookeeperkafka 2. 通过 docker 构建容器并对外提供服务 MAC 本机 Kafka 启动（使用 默认设置）检测 kafka 是否正确启动方法1: 使用lsof命令方法 2：使用Kafka命令行工具 server.properties 一览 Brew 安装 打开终端 1. xcode-select --install 首先要安装这个东西，否则安不了 kafkaxcode-select --install 安装完成后，你可能需要同意Xcode和相关工具的许可协议。这可以通过以下命令完成：sudo xcodebuild -license 2. brew install kafka 安装 kafkabrew install kafka Docker 安装 如果你已经安装了Docker，可以使用Docker来运行Kafka和ZooKeeper。 1. 构建 docker-compose.yml 在终端中创建一个docker-compose.yml文件，内容如下： version: '2' services: zookeeper: image: wurstmeister/zookeeper ports: - "2181:2181" kafka: image: wurstmeister/kafka ports: - "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63883a9be396d6b6eb8896bee20253a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c6f4b34190a0b49823ad0ab1748796f/" rel="bookmark">
			Web Components（web组件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 web Components的概念和使用使用自定义元素自定义元素类型实现自定义元素注册自定义元素自定义元素的回调函数使用自定义元素添加自定义元素的属性变化自定义元素示例 使用影子Dom影子Dom的原理示意图创建一个影子Domjs隔离css隔离影子Dom和自定义元素补充： 影子根ShadowRoot的相关属性和方法 使用html模板template标签实现自定义元素slots插槽实现自定义元素补充：插槽slot身上的属性和方法 Web Component即web组件，允许创建可重用的定制元素（它们的功能封装在你的代码之外）。就是 组件的功能。 web Components的概念和使用 web Components 可以创建封装了指定功能的定制元素，创建完成之后你可以在任何你喜欢的地方重用。
webComponents的三大组成部分：
自定义元素：定义元素及其行为影子Dom：将封装的“影子”DOM 树附加到元素并控制其关联的功能。使用这种方式保持元素的功能私有，不用担心与文档的其他部分发生冲突。html 模板：&lt;template&gt; 和 &lt;slot&gt; 元素可以作为标记模板 使用自定义元素 自定义元素即由 Web 开发人员自行定义 HTML 元素，扩展浏览器中可用的元素集。
自定义元素类型 有两种类型：
自定义内置元素：继承自标准的 HTML 元素：例如 HTMLImageElement 或 HTMLParagraphElement。它们的实现定义了标准元素的行为。无需从头开始实现行为。独立自定义元素：继承自 HTML 元素基类 HTMLElement。必须从头开始实现它们的行为。 实现自定义元素 自定义元素作为一个类来实现。
在类的构造函数中：
可以设置初始状态和默认值，注册事件监听器，创建一个影子根（shadow root）；
不应检查元素的属性或子元素，也不应添加新的属性或子元素
自定义内置元素实现格式 class WordCount extends HTMLParagraphElement { constructor() { super(); } // 此处编写元素功能 } 独立自定义元素实现格式 class PopupInfo extends HTMLElement { constructor() { super(); } // 此处编写元素功能 } 注册自定义元素 Window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c6f4b34190a0b49823ad0ab1748796f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5559e333a60a1d1b10e798e8a507c5e2/" rel="bookmark">
			uniapp-打包IOS的APP流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打包前所需配置 在manifest文件内配置
1. APP图标 2. 启动界面 有三种启动界面配置
第一种是 HBuilderX 官方给的通用启动界面，页面单一，屏幕中间就一个圆框图标
第二种是自定义的启动图，无法通过AppStore的审核
第三种是自定义storyboard启动界面，可以通过xml构建出一个启动界面，这个方案适合在实际开发中使用
第三种方案 自定义storyboard启动界面的制作方法写在了另外一个文章内
链接：
3. App模块配置 oauth 登录鉴权 此处的苹果登录也要勾选上，未勾选打包的时候会提示
ios平台通用链接生成方法
官方参考文档：uni-app官网 (dcloud.net.cn)
payment 支付 ios平台通用链接生成方法与上面的登录一样
4. 权限配置 配置这些权限需要描述，描述信息如图所示
IOS打包 1. 创建证书 官方参考文档：iOS证书(.p12)和描述文件(.mobileprovision)申请 - DCloud问答
没有MAC系统的，参考这个文档：打包ios应用所需的证书和证书profile文件的创建方法
首先第一步，先需要一个csr文件（可以在香蕉云编-app打包上架工具类平台去生成）
生成一个crs 文件后，下载到电脑上保存
拿着这个文件去苹果开发者中心https://appstoreconnect.apple.com/，去生成P12文件和profile证书文件，profile文件的后缀为 mobileprovision
证书有两种格式，一种是开发环境，一种是生产环境，后者能过AppStore审核 2.HBuilderX内App打包 在HBuilder X 内 选中文件 点击发行 ==&gt; 云打包
选择 IOS ipa包
输入 APPID
勾选 支持iapd
输入生成证书时设置的密码
选择证书profile证书和P12文件(生成的证书文件有两种，一种是开发环境的，一种是生产环境，开发环境是在手机测试时使用的，提交到AppStore内通过不了，生产环境的证书才能通过)
传统打包(ios只能传统打包)
3.打包完成 点击打包后，会提交云端开始打包，一般两三分钟就打包完成
完成后，会生成一个下载地址，点击链接进行下载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f81760916dbb630393058c4aabaa81e9/" rel="bookmark">
			在IDEA中配置Node.js
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在IDEA中配置Node.js 前提安装了安装Node.exe
1.在file-&gt;setting-&gt;plugins中查找node.js 2.去languages &amp; frameworks中的node.js and NPM中指明之前安装的node.exe和npm
3.设置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f46f58bc8c4b50b539314f0893bbf0c5/" rel="bookmark">
			C语言结合体和枚举的魅力展现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
✨✨欢迎👍👍点赞☕️☕️收藏✍✍评论
个人主页：秋邱’博客
所属栏目：人工智能
（感谢您的光临，您的光临蓬荜生辉）
引言:
前面我们已经讲了结构体的声明，自引用，内存对齐等,详细见《掌握C语言结构体，开启编程新世界》。有需要的可以回看。
今天我们讲的是枚举和结合体，这两个跟结构体很相像但也是还是有差别的。
1.0 联合体 //代码1 #include&lt;stdio.h&gt; struct U { char a; int b; }; int main() { printf("%zd", sizeof(struct U)); return 0; } //代码2 union U { char a; int b; }; int main() { printf("%zd", sizeof(union U)); return 0; } 打印结果：
代码1
8
代码2
4
为何这两个的打印结果不相同呢，这就是我们与结构体很相似的联合体。
顾名思义，联合体是一种特殊的数据类型，可以存储不同类型的数据，但同一时刻只能存储其中一种类型的数据。
我们先来看看结构体和联合体的区别
结构体联合体structunion多个成员多个成员每个成员都有自己独立的空间所有成员共用一块内存空间 1.1 联合体声明 联合体的定义格式如下：
union 类型名 { 成员1 成员2 }变量; 联合体和结构体的声明很相似，这里我们就简单的举一个例子。
#include&lt;stdio.h&gt; union U { char a; int num; }; int main() { union U p1 = { 0 }; p1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f46f58bc8c4b50b539314f0893bbf0c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b2d20023d0b2c3cd0a46211eacd6d61/" rel="bookmark">
			开发者必知VScode中的顶级AI插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Visual Studio Code（VSCode）中有6个顶级的AI插件，它们利用人工智能的强大功能来提升编码体验和效率。以下是这些插件的详细介绍：
GitHub Copilot 描述：GitHub Copilot是由GitHub和OpenAI共同开发的AI结对程序员。它能够根据公共代码存储库的广泛数据集，为整行或代码块提供即时建议。特点：无缝集成到VSCode中，通过自然语言提示和上下文生成代码片段，加速编码过程。 TabNine 描述：TabNine是一个AI驱动的代码完成工具，它根据上下文和编码模式为下一行代码提供强大的预测。特点：支持多种编程语言，提供准确、直观的代码建议，提高编码速度和效率。 Codemium 描述：Codemium是一款旨在提高VSCode工作效率的人工智能驱动的代码完成工具。特点：分析代码库并提供智能建议，支持多种编程语言和框架，适应编码风格和偏好。 Visual Studio IntelliCode 描述：IntelliCode提供基于流行编码模式和实践的AI辅助代码完成。特点：从代码库和社区中学习，提供个性化建议，帮助减少错误并加速编码。 Bito 描述：Bito是一款人工智能驱动的代码分析和优化工具，可以直接在VSCode中进行代码性能、安全性和可维护性的分析。特点：利用强大的AI算法识别潜在问题并优化代码。 BlackBox 描述：BlackBox通过AI支持的代码自动完成和代码聊天来编写和审查代码。特点：与AI无缝集成到现有工作流程中，增强编码体验。 这些AI插件通过提供智能代码补全、高级代码分析、安全加密和个性化编码建议等功能，极大地提升了VSCode用户的编码体验。无论是专业的开发者还是初学者，这些工具都能帮助他们提高生产力和效率，拥抱编码的未来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37b49849c6f05ca9d645b4a9b559d6c3/" rel="bookmark">
			mac-gradle的安装和配置，掌握这些知识点再也不怕面试通不过
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		open -e .bash_profile
在.bash_profile文件中输入 GRADLE_HOME=//Users/sunshine/Documents/software/gradle/gradle-7.3.3
export GRADLE_HOME
export PATH= P A T H : PATH: PATH:GRADLE_HOME/bin
保存文件，让配置的环境变量生效 source ~/.bash_profile
到这里我们就在mac上安装上gradle,接下来我们验证一下是否安装成功
3.查看gradle的版本
gradle -version
自我介绍一下，小编13年上海交大毕业，曾经在小公司待过，也去过华为、OPPO等大厂，18年进入阿里一直到现在。
深知大多数Java工程师，想要提升技能，往往是自己摸索成长或者是报班学习，但对于培训机构动则几千的学费，着实压力不小。自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《2024年Java开发全套学习资料》，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友，同时减轻大家的负担。
既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，基本涵盖了95%以上Java开发知识点，真正体系化！
由于文件比较大，这里只是将部分目录大纲截图出来，每个节点里面都包含大厂面经、学习笔记、源码讲义、实战项目、讲解视频，并且后续会持续更新
如果你觉得这些内容对你有帮助，可以添加V获取：vip1024b （备注Java）
Java核心架构进阶知识点 面试成功其实都是必然发生的事情，因为在此之前我做足了充分的准备工作，不单单是纯粹的刷题，更多的还会去刷一些Java核心架构进阶知识点，比如：JVM、高并发、多线程、缓存、Spring相关、分布式、微服务、RPC、网络、设计模式、MQ、Redis、MySQL、设计模式、负载均衡、算法、数据结构、kafka、ZK、集群等。而这些也全被整理浓缩到了一份pdf——《Java核心架构进阶知识点整理》，全部都是精华中的精华，本着共赢的心态，好东西自然也是要分享的
内容颇多，篇幅却有限，这就不在过多的介绍了，大家可根据以上截图自行脑补
7770272)]
[外链图片转存中…(img-nQDr52lo-1711707770272)]
内容颇多，篇幅却有限，这就不在过多的介绍了，大家可根据以上截图自行脑补
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ac0f213965ec83b350ab56385b4e902/" rel="bookmark">
			头歌｜HDFS实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1关：HDFS基础命令实战 start-dfs.sh vi stu01.txt #vi#按i键进入编辑模式，左下角出现--INSERT--字符后，输入以下内容 234 5678 Hadoop #vi#按ESC 键，左下角--INSERT--字符消失后，在英文输入状态下输入 :wq ，回车保存退出文件。 hdfs dfs -mkdir /user/stu02 hdfs dfs -put stu01.txt /user/stu02 第2关：HDFS高级命令实战 start-dfs.sh vi stu01_2.txt #vi#按 i 进入编辑模式，输入内容 hadoop hive #vi#然后按 esc 键，再同时按下 shift 和冒号键，输入 wq，保存退出 hdfs dfs -mkdir /user/stu01/ hdfs dfs -moveFromLocal stu01_2.txt /user/stu01/ vi stu01.txt #vi#按i键进入编辑模式，左下角出现--INSERT--字符后，输入以下内容 234 5678 Hadoop #vi#按ESC 键，左下角--INSERT--字符消失后，在英文输入状态下输入 :wq ，回车保存退出文件。 hdfs dfs -appendToFile stu01.txt /user/stu01/stu01_2.txt hdfs dfs -get /user/stu01/stu01_2.txt . 第3关：使用JAVA API读取HDFS的数据 URI uri=URI.create("hdfs://localhost:9000/user/hadoop/task.txt"); Configuration config=new Configuration(); FileSystem fs =FileSystem get(uri, config); InputStream in=null; try{ in=fs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ac0f213965ec83b350ab56385b4e902/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/def50b1bc73261caa2f6b27aab7df296/" rel="bookmark">
			Hadoop之Ha高可用搭建教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、Hadoop集群HA高可用概述二、集群规模三、配置zookeeper集群1.解压zookeeper安装包2.设置环境变量3.配置zoo.cfg配置文件4.分发到其他节点5.修改myid 配置文件6.启动并查看zookeeper状态 四、配置HA高可用1.解压hadoop安装包2.添加环境变量3.修改配置文件4.分发配置文件5.1启动JournalNode5.2安装自动转移机制包6.1初始化namenode6.2格式化zookeeper7.1启动集群7.2查看进程最终实现效果 五、常见问题六、故障转移检测七、HA启动脚本七、总结 前言 随着大数据技术的不断发展，Hadoop作为开源的大数据处理框架，已经广泛应用于各种场景中。然而，在大型生产环境中，Hadoop集群的稳定性和可用性显得尤为重要。为了保障Hadoop集群的高可用性（HA），我们需要采用一系列的技术和策略。本文将重点介绍Hadoop集群的HA高可用方案。
一、Hadoop集群HA高可用概述 Hadoop集群的HA高可用主要指的是在集群中的关键组件出现故障时，能够自动切换到其他节点继续提供服务，从而确保整个集群的稳定运行。
二、集群规模 Hadoop HA高可用集群规划 - 三节点（master, slave1, slave2）
组件masterslave1slave2描述HadoopNameNode主节点备节点无主备部署，共享存储同步元数据SecondaryNameNode主节点无无辅助NameNode，定期合并fsimage和edits logResourceManager主节点备节点无主备部署，实现资源管理和任务调度DataNode有有有存储实际数据，参与数据块的读写操作NodeManager有有有负责管理容器生命周期，与ResourceManager通信 三、配置zookeeper集群 1.解压zookeeper安装包 tar -zxvf zookeeper-3.4.6.tar.gz -C /usr/local/src 2.设置环境变量 位置：vi /.bash_profile
添加环境变量
export ZK_HOME=/usr/local/src/zookeeper export PATH=$PATH:$ZK_HOME/bin 3.配置zoo.cfg配置文件 先创建存放ZK的数据文件和配置文件的zkdata目录mkdir zkdata
配置zoo.cfg文件，在文件中添加下面内容
dataDir=/usr/local/src/zookeeper/zkdata server.1=master:2888:3888 server.2=slave1:2888:3888 server.3=slave2:2888:3888 4.分发到其他节点 scp -r zookeeper/ root@slave2:/usr/local/src 5.修改myid 配置文件 在zkdata目录中创建myid并修改
echo 1&gt;myid (master) echo 2&gt;myid	(slave1) echo 3&gt;myid (slave2) —master
—slave1
—slave2
6.启动并查看zookeeper状态 位置：cd /usr/local/src/zookeeper/bin
启动：./zkServer.sh start
状态：./zkServer.sh status
----master
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/def50b1bc73261caa2f6b27aab7df296/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf3c348dbaaf1259b525a866903343af/" rel="bookmark">
			python中的deque详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 摘要示例1：基本使用示例2：使用maxlen限制队列长度示例3：使用deque实现滑动窗口算法示例 4: 使用 deque 实现旋转数组示例 5: 使用 deque 实现最大/最小栈示例 6: 使用 deque 实现广度优先搜索（BFS） 摘要 deque（双端队列）是Python标准库collections模块中的一个类，它支持从两端快速添加和删除元素。deque为固定大小或者可变大小的队列提供了线程安全的实现，并且它比使用列表（list）来实现相同的功能更为高效。
deque的主要特点和操作包括：
快速从两端添加和删除元素：deque在两端添加和删除元素的时间复杂度都是O(1)，而列表在列表头部添加或删除元素的时间复杂度是O(n)。线程安全：deque的实例可以在多线程环境中安全使用，而不需要额外的锁定。可选的最大长度：可以通过maxlen参数来限制deque的最大长度。当deque已满时，添加新元素会导致最早添加的元素被自动移除。 下面是deque的一些详细示例：
示例1：基本使用 from collections import deque # 创建一个空的deque d = deque() # 从右侧添加元素 d.append('a') d.append('b') print(d) # 输出：deque(['a', 'b']) # 从左侧添加元素 d.appendleft('c') print(d) # 输出：deque(['c', 'a', 'b']) # 从右侧移除元素 right_item = d.pop() print(right_item) # 输出：'b' print(d) # 输出：deque(['c', 'a']) # 从左侧移除元素 left_item = d.popleft() print(left_item) # 输出：'c' print(d) # 输出：deque(['a']) 示例2：使用maxlen限制队列长度 from collections import deque # 创建一个最大长度为3的deque d = deque(maxlen=3) # 添加元素 d.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf3c348dbaaf1259b525a866903343af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82c5e6b1b13809cd3d9777ecf76a0af1/" rel="bookmark">
			PyFluent使用笔记——fluent和python结合使用，提高效率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PyFluent使用笔记（第三部分是我认为最实用的部分） xiaoqiang_2
于 2023-11-30 19:58:05 发布
阅读量1.5k
收藏 22
点赞数24
分类专栏： Python工程应用 文章标签： python
版权
​编辑Python工程应用专栏收录该内容
1 篇文章0 订阅
订阅专栏
一、PyFluent简介 PyFluent是ansys公司在2022年新推出的功能，顾名思义就是fluent软件的Python模块，可以使用Python代码直接调用fluent并可以完成fluent的所有功能，包括fluent meshing画网格、fluent求解以及后处理。本质上PyFluent将fluent作为一个Python中的一个流体求解器，与numpy、scipy这些数据处理模块类似。PyFluent最大的优势在于其接入了强大的Python生态，可以使用Python其他功能强大的模块来拓展fluent的功能。
ansys官方的介绍可观看B站视频：PyFluent：解锁Fluent在Python生态系统中的无限潜力_哔哩哔哩_bilibili
注意：只有ansys2022R2及以上版本才支持pyfluent。
fluent各种语言的对比（截图自上述官方介绍视频）
二、PyFluent使用 现在网上关于PyFluent的使用相关的资料还比较少，能找到的比较有用的资料整理如下：
关于PyFluent模块的安装在下边的链接里有详细介绍，这里就不讲了。
2.1相关文章 pyFluent｜常用的代码片段-析模界 (topcfd.cn)关于PyFluent的安装以及可能遇到的问题，这篇文章讲的很详细，需要可以参考：pyfluent使用记录（1）：安装测试-CSDN博客这篇文章讲的很详细，从PyFluent的简介到使用都有关于Python_fluent_fluent python_愿天堂没有C＋＋的博客-CSDN博客 2.2B站视频 B站有一些关于PyFluent的教程视频，直接搜索PyFluent就可以看到。下面两个是我认为比较有用的。
B站的官方案例演示视频：pyfluent实操案例_哔哩哔哩_bilibili（这个很有用），其源代码在Github开源：GitHub - leigq/pyfluent: 基于pyfluent的全流程应用案例（以2D naca0012为例）B站“新时代仿真人”中的ansys官方教程：1.Intro to PyFluent - Lesson 1_哔哩哔哩_bilibili，一共7个视频。 三、PyFluent使用经验 关于PyFluent代码究竟应该怎么写，仅观看上边的视频以及文章还是不够的，因为不知道其中很多方法以及函数的参数，也就没办法灵活的操作。
不过在ansys官方教程中演示了一种非常简单的方法。
首先在fluent控制台，唤醒TUI命令，然后输入 (api-start-python-journal "pyfluent_test3.py")这条命令，fluent就会在文件夹中创建一个Python脚本，名称就是上边输入的命令双引号部分，我这里是pyfluent_test3.py。然后就直接像往常一样在fluent控制台使用TUI命令进行参数设置，fluent会记录你的所有设置操作并在刚刚创建的Python文件中生成每一步操作对应的Python代码，然后就可以直接将需要的操作对应的代码复制过来用。结束的时候，输入(api-stop-python-journal)即可结束录制。 以上这种方法可以参考B站ansys官方教程3：4.PyFluent Journaling and APIs - Lesson 3_哔哩哔哩_bilibili
这种方法理解起来也很简单，其本质就是fluent一直都有的录制TUI脚本的功能，只不过在这里是将对应的脚本改成了Python代码。
没用过控制台TUI操作的小白也不用慌，TUI操作挺简单的，可以找一个case多试几次，就知道每一个命令大概是什么意思了。
输入命令开始录制：
用TUI操作录制完成之后的代码：
文章知识点与官方知识档案匹配，可进一步学习相关知识
Python入门技能树首页概览406486 人正在系统学习中
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a163a189212446b7481045b123a539b9/" rel="bookmark">
			java将文件转成流文件返回给前端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境：jdk1.8，springboot2.5.3,项目端口号：9100
1.待转换的文件 一、路径 二、文件内容 2.controller中代码 package com.example.pdf.controller; import com.example.pdf.service.GetFileStreamService; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import javax.annotation.Resource; import javax.servlet.http.HttpServletResponse; /** * @author * @date 2024/3/29 16:28 * @describe */ @RestController @RequestMapping(value = "test") public class GetFileStreamController { @Resource private GetFileStreamService getFileStreamService; /** * 获取文件流 */ @GetMapping("getFileStream") public void getFileStream(HttpServletResponse response) { getFileStreamService.getFileStream(response); } } 3.service中代码 package com.example.pdf.service; import javax.servlet.http.HttpServletResponse; /** * @author * @date 2024/3/29 16:30 * @describe */ public interface GetFileStreamService { /** * 获取文件流 * @param response */ void getFileStream(HttpServletResponse response); } 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a163a189212446b7481045b123a539b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c7e7d7242291fd4b3d0edcbd0aff965/" rel="bookmark">
			值得收藏！2024年人工智能顶级会议投稿信息汇总（计算机视觉领域）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机视觉是人工智能领域的重要分支。它融合了图像处理、模式识别、机器学习和人工智能等多个领域的技术，旨在让计算机具备类似甚至超越人类视觉系统的能力。本文将精选介绍计算机视觉领域内的重要会议，包括会议主题、稿件提交的截止日期、会议的时间与地点等关键信息，帮助读者深入了解该领域的最新发展。接着，将这些信息汇总至一张表格中，使得研究人员和实践者可以快速地获取并理解相关会议的细节，便于规划投稿或参会。所有会议的图片信息均直接来源于其官方网站。需要注意的是，由于会议详情可能会调整，具体信息可能发生变动。因此，我们建议准备投稿或参与会议的读者，以各会议官方网站公布的最新信息为准。本文作者为李杨，审校为许东舟和邱雪。
一、会议介绍 1.1 ICCV（计算机视觉国际大会） 会议时间/地点：2025年12月14日至20日，中国，深圳
截稿时间：待定
录用通知时间：待定
会议官网：https://iccv2025shenzhen.gitee.io/
计算机视觉国际大会（International Conference on Computer Vision，ICCV）每两年举办一次，是计算机视觉领域内最重要的国际学术会议之一。会议内容涵盖计算机视觉的各个方面，包括图像处理、模式识别、机器学习在视觉中的应用、三维场景重建、物体检测与识别、动作和事件的捕捉、人脸识别、虚拟现实以及增强现实等研究方向。此外，会议还关注这些领域内的新技术、新算法、系统实现及其在工业、医疗和日常生活中的应用。
1.2 CVPR（IEEE国际计算机视觉与模式识别会议） 会议时间/地点：2024年6月17至21日，美国，西雅图
截稿时间：2023年11月18日
录用通知时间： 2024年2月27日
会议官网：https://cvpr.thecvf.com/Conferences/2024
IEEE国际计算机视觉与模式识别会议（IEEE Conference on Computer Vision and Pattern Recognition，CVPR），每年举办一次，是全球计算机视觉和模式识别领域内最重要的学术会议之一。会议内容覆盖图像识别、机器学习、深度学习、三维视觉、运动和跟踪分析、人脸识别技术等前沿领域，并深入探讨这些技术在自动驾驶、医疗影像分析、智能监控等实际应用场景中的应用。CVPR以其高质量的论文、广泛的国际参与和对新技术的深刻洞察而闻名，是学者和研究人员展示研究成果、交流创新思想、探索合作机会的重要平台。
1.3 SIGGRAPH（国际计算机图形与交互技术会议） 会议时间/地点：2024年7月28日至8月，美国，科罗拉多州
截稿时间：2024年4月9日
录用通知时间：2024年5月初
会议官网：https://s2024.siggraph.org/
国际计算机图形与交互技术会议（Special Interest Group for Computer GRAPHICS，SIGGRAPH）每年举办一次，是计算机图形和交互技术领域内全球最为知名和权威的学术及展示平台。会议囊括了从理论研究到实际应用的全方位内容，涵盖三维图形渲染、动画技术、虚拟现实、增强现实、用户界面设计、视觉效果以及实时图形处理等多个方面。此外，SIGGRAPH还关注新兴技术对艺术创作、影视制作、游戏开发等领域的影响和应用。
1.4 ACM MM（ACM国际多媒体会议） 会议时间/地点：2024年10月28日至11月1日，澳大利亚，墨尔本
截稿时间：2024年6月17日
录用通知时间：2024年7月15日
会议官网：https://2024.acmmm.org/
ACM国际多媒体会议（ACM International Conference on Multimedia，ACM MM）每年举办一次，聚焦于多媒体技术和应用的广泛领域，是多媒体研究和创新的国际顶级会议之一。会议内容涵盖图像、视频处理、多媒体内容分析、多媒体系统和平台、增强现实与虚拟现实、多媒体交互、社交媒体分析、以及多媒体在教育、医疗、娱乐等领域的应用。ACM MM以其丰富的议题、跨学科的研究内容及高质量的论文和展示而闻名，吸引了全球众多学者、研究人员、行业专家和技术开发者。
1.5 IEEE VIS（IEEE可视化会议） 会议时间/地点：2024年10月28日至11月1日，美国，佛罗里达州
截稿时间：2024年3月31日
录用通知时间：2024年7月15日
会议官网：https://ieeevis.org/year/2024/welcome
IEEE可视化会议（IEEE Visualization Conference，IEEE VIS）每年举办一次，是全球领先的专注于数据可视化的学术会议。该会议集中讨论通过可视化技术来理解和解释大规模数据集的最新方法，包括科学可视化、信息可视化、视觉分析等领域的研究成果。IEEE VIS致力于展示如何利用可视化技术帮助人们在各种复杂数据环境中做出决策、发现模式和洞察趋势。会议内容不仅涉及基础研究，还包括可视化技术的应用、系统实现及其在科学研究、工程、医疗、金融和公共服务等多个领域的实际应用案例。
1.6 VR（虚拟现实技术会议） 会议时间/地点：2024年3月16日至21日，美国，佛罗里达州
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c7e7d7242291fd4b3d0edcbd0aff965/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5940f21c731576bee67fc9e08083eb54/" rel="bookmark">
			文心一言 VS 讯飞星火 VS chatgpt （225）-- 算法导论16.3 7题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		七、推广赫夫曼算法，使之能生成三进制的码字(即码字由符号0、1、2组成)，并证明你的算法能生成最优三进制码。如果要写代码，请用go语言。 文心一言： 推广赫夫曼算法以生成三进制码字需要对算法进行一定的修改，确保在每一步选择频率最低的三个节点进行合并，并生成对应的三进制码。以下是推广赫夫曼算法的Go语言实现，并附带证明其能生成最优三进制码的思路。
首先，我们需要定义赫夫曼树节点的数据结构，并实现一个优先队列来管理这些节点。
package main import ( "container/heap" "fmt" ) // HuffmanTreeNode represents a node in the Huffman tree. type HuffmanTreeNode struct { symbol rune // Symbol for leaf nodes, 0 for internal nodes. freq float64 // Frequency of the symbol. left, mid, right *HuffmanTreeNode // Child nodes. } // HuffmanPriorityQueue implements heap.Interface and holds HuffmanTreeNode pointers. type HuffmanPriorityQueue []*HuffmanTreeNode func (pq HuffmanPriorityQueue) Len() int { return len(pq) } func (pq HuffmanPriorityQueue) Less(i, j int) bool { return pq[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5940f21c731576bee67fc9e08083eb54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c5a1fd2b041c5d1f446925479c94fe8/" rel="bookmark">
			Android 开发 OCR Tesseract4Android图片文字识别 巨详细全部代码教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面是整个详解步骤过程 效果图一、OCR的含义二、前提准备二、使用步骤详情1、将 JitPack 存储库添加到存储库末尾的项目根文件2、将依赖项添加到应用模块文件3、数据文件下载路径4、详情代码案例Demo如下：Main.xmlMain.java 效果图 流程：获取assets中的图片显示到页面，点击提取图片内的文字
一、OCR的含义 ocr是Optical Character Recognition（光学字符识别）是指电子设备（例如扫描仪或数码相机）检查纸上打印的字符，通过检测暗、亮的模式确定其形状，然后用字符识别方法将形状翻译成计算机文字的过程
二、前提准备 官网奉上
注意：
1、 Android 4.1 （API 16） 或更高版本
2、JDK版本是Java 17 Java 17获取
下载后把项目的JKD 换成Java 17,如下图：
二、使用步骤详情 1、将 JitPack 存储库添加到存储库末尾的项目根文件 allprojects { repositories { ... maven { url 'https://jitpack.io' } } } 根据自己studio位置添加，我的是新版的studio是如下图位置
2、将依赖项添加到应用模块文件 dependencies { // To use Standard variant: implementation 'cz.adaptech.tesseract4android:tesseract4android:4.7.0' } 这里我们使用的是单线程依赖 3、数据文件下载路径 数据文件下载路径或者直接下载中文数据包中文数据包
数据包下载下来放到assets文件夹下，cs.png是随便找的一张图片，测试用的
4、详情代码案例Demo如下： Main.xml &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c5a1fd2b041c5d1f446925479c94fe8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d42d54ab6dabae4d412867675ee4063/" rel="bookmark">
			大模型与数据分析：探索Text-to-SQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当今大模型如此火热，作为一名数据同学，持续在关注LLM是如何应用在数据分析中的，也关注到很多公司推出了AI数智助手的产品，比如火山引擎数智平台VeDI—AI助手、 Kyligence Copilot AI数智助理、ThoughtSpot等，通过接入人工智能大模型，提升数据处理和查询分析的效率。智能数据分析助手，采用对话式分析技术，每个普通人都可以与数据进行随时随地的实时交互，根据用户的使用反馈，不断学习，自我迭代找到答案，并在团队内分享对数据的见解。
简单分析一下数据分析的发展阶段：第一阶段，以静态报表为主，传统BI和静态报表基本上都是面向开发部门的，业务部门提出需求之后，由开发根据报表工具开发出固定的报表，然后业务部门查看报表结果。第二阶段，敏捷BI自助式分析，在业务部门提出需求之后，数据分析可以基于敏捷BI的工具帮助业务部门快速获取所需的数据，帮助他们获得所需要的结果。第三阶段，不管是基于大模型的AskBI还是增强分析，都是直接面向业务的，其理念是业务部门直接使用对话式BI工具能够解决问题，获得所需的数据结果。这一过程无需像之前那样依赖开发部门开发报表，或者数据分析师基于敏捷BI再提供数据结果，而是直接由业务部门推进落地。
整体方案
通过多家数AI数智助手调研，实现智能数据分析的核心有：一是以指标为中心，二是大模型。其中也分享出了如何把指标平台+AI技术落地方案，提出了：人人用数=AI Copilot + 指标体系 + 合理成本的关键技术观点。
指标体系给到我们的是一个通用的数据语言，当我们每一个人都用数据来沟通时，我们遇到的第一个障碍一定是缺乏通用的语言。就像普通话让13 亿中国人能够自由沟通，数据的解释权有一个标准一致的口径也是非常重要的，是数据共享和协作的前提。
指标数据最理想的使用场景就是，想要就有，数据准确，可视化展示。用户期望能够随时查看自己想要的业务指标数据，绝大多数人都有自己的使用指标的渠道和方法，但是需要用户熟悉系统的操作、数据内容可能会根据需求提前预设好，如果是需要指标的话，就依赖支持者的时间了，或者需要排期开发。虽然每个人都各显其通能够拿到数据，但于用户体验来说，还是需要有操作和时间成本。
智能化的指标应用可以大幅提高数据指标的用户体验和效率。我们希望的场景是，用户对着手机：“告诉我昨天的DAU、用户留存、销售额”，系统就能快速的反馈给用户这三个指标的结果，并且是准确的。
指标的加工处理到使用中间有很多过程，从数据沉淀-&gt;数仓加工-&gt;口径定义-&gt;报表-&gt;系统-&gt;用户，中间流程最直接的方式就是自然语言直接对接到数据。
▐ 通用方案 通用做法是基于指标要素生产出指标的模型（提前预算好所有的可能），通过NLP技术，将自然语言转译成SQL，直接读取指标模型，大概的技术思路如下：
▐ 基于大模型 目标：通过大模型技术，打造用户在灵活搜索指标的时候能够快速反馈给用户正确的指标体验。
核心聚焦：
让系统尽可能的去理解自然语言，并准确的把它转换成可执行的SQL。
尽最大的可能覆盖用户的灵活需求，提高指标要素组合的成指标的组合数量。
基于LLM生成准确可执行SQL的关键思路：把指标管理模型的定义、指标要素等元数据信息送给LLM当作prompt进行指标搜索与生成。
Text-to-SQL
Text-to-SQL（简写为T2S，或者是Text2SQL），顾名思义就是把文本转化为SQL语言，更学术一点的定义是：把数据库领域下的自然语言（Natural Language，简写为NL）问题，转化为在关系型数据库中可以执行的结构化查询语言（Structured Query Language，简写为SQL）。
▐ Text-to-SQL是什么 Text-to-SQL任务相对正式的定义：在给定关系型数据库（或表）的前提下，由用户的提问生成相应的SQL查询语句。下图是spider数据集的样例，问题：有哪些系的教师平均工资高于总体平均值，请返回这些系的名字以及他们的平均工资。可以看到该问题对应的SQL语句是很复杂的，并且有嵌套关系。
▐ 数据集 常见的数据集有GenQuery、Scholar、WikiSQL、Spider、Spider-SYN、Spider-DK、Spider-SSP、CSpider、SQUALL、DuSQL、ATIS、SparC、CHASE等。
数据集的分类有单领域和交叉领域；有单轮对话和多轮对话；有简单问题和复杂问题；有中文语言和英文语言；有单张表和多张表等。重点介绍两个数据集：WikiSQL、Spider。
WikiSQL WikiSQL数据集是目前规模最大的Text-to-SQL数据集，由2017年美国的Salesforce公司提出，场景来源于Wikipedia，属于单领域。数据标注采用外包。
包含了80654个自然语言问题，77840个SQL语句。
包含了26521张数据库表，1个数据库只有1张表。
预测的SQL语句形式比较简单，基本为一个SQL主句加上0-3个WHERE子句条件限制构成，如下图所示：
Spider Spider数据集是多数据库、多表、单轮查询的Text-to-SQL数据集，也是业界公认难度最大的大规模跨领域评测榜单，由2018年耶鲁大学提出，由11名耶鲁大学学生标注。
10181个自然语言问题，5693个SQL语句。
涉及138个不同领域的200多个数据库。
难易程度分为：简单、中等、困难、特别困难。如下图所示
Spider数据集论文地址：https://arxiv.org/pdf/1809.08887.pdf。
CSpider是西湖大学在EMNLP2019上提出了一个中文text-to-sql的数据集，主要是选择Spider作为源数据集进行了问题的翻译，并利用SyntaxSQLNet作为基线系统进行了测试，同时探索了在中文上产生的一些额外的挑战，包括中文问题对英文数据库的对应问题(question-to-DBmapping)、中文的分词问题以及一些其他的语言现象。
▐ 评估指标 目前广泛使用的是执行准确率（Execution Accuracy，简称EX）和逻辑形式准确率（WxactMatch，简称EM）。
执行准确率 定义：计算SQL执行结果正确的数量在数据集中的比例。
缺点：存在高估的可能。因为一个完全不同的非标准的SQL可能查出于与标准SQL相同的结果（例如，空结果），这时也会判为正确。
举个例子：假如有个学生表，我们想要查询学生表中年龄等于19的学生姓名，就如“SELECT sname FROM Student where age = 19”所示，通过数据库执行标准SQL后得到结果为null；此时Text-to-SQL模型预测的SQL为“SELECT sname FROM Student where age = 20”，通过数据库执行后也得到结果为null。虽然预测的SQL跟标注的SQL不一致，但是结果是一样的，根据执行准确率指标来比较，那么就认为模型预测是正确的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d42d54ab6dabae4d412867675ee4063/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/449/">«</a>
	<span class="pagination__item pagination__item--current">450/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/451/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>