<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d807c6f034dcf4260f7318691fa18746/" rel="bookmark">
			容器内压力测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用tpcc对自身服务器做压力测试 概念： TPCC（Transaction Processing Performance Council-C Benchmark）是一个用于评估数据库系统在线事务处理（OLTP）性能的基准测试。它模拟了一个复杂的分布式数据库环境，包括多种事务类型，如新订单、支付、订单状态查询、发货和库存水平查询等。以下是对TPCC测试结果的一般性分析和解读，但请注意，具体的测试结果会根据测试环境、硬件配置、数据库系统等因素而有所不同。
TPCC测试结果的主要指标
事务吞吐量（Transactions Per Minute, TPM）：
这是衡量数据库系统处理事务能力的关键指标，表示系统每分钟能够完成的事务数量。
高吞吐量表明系统能够高效地处理大量并发事务。
响应时间（Response Time）：
表示系统处理单个事务所需的时间。
通常关注90%或99%的事务的响应时间，即90%或99%的事务都能在多少时间内完成。
较短的响应时间意味着系统能够更快地响应用户请求。
事务成功率：
表示成功完成的事务占总事务数的比例。
高成功率表明系统稳定运行，错误率低。
测试结果分析
在TPCC测试结果中，通常会包含以下几个关键部分：
热身阶段（Ramp-Up Time）：测试开始前的准备阶段，用于预热系统，确保系统达到稳定状态。
测量阶段：实际测试阶段，系统按照预定的负载运行，并收集各项性能指标。
结果输出：测试完成后，系统输出详细的测试结果，包括吞吐量、响应时间、事务成功率等。
示例解读
以参考文章中的示例输出为例（请注意，由于示例数据较为陈旧，且具体格式可能因工具版本和配置而异，以下解读仅为示例）：
20, trx: 1365, 95%: 149.731, 99%: 192.421, max_rt: 375.631
20：表示测试开始后的第20秒。
trx: 1365：表示在这20秒内，系统成功处理了1365个事务（吞吐量的一部分）。
95%: 149.731：表示95%的事务的响应时间为149.731毫秒。
99%: 192.421：表示99%的事务的响应时间为192.421毫秒。
max_rt: 375.631：表示在这段时间内，最长的事务响应时间为375.631毫秒。
注意事项
解读测试结果时，需要结合测试环境的具体情况，如硬件配置、网络状况、数据库配置等。
不同的数据库系统在同一测试环境下可能表现出不同的性能。
测试结果可能受到多种因素的影响，如并发用户数、事务类型分布、数据库索引设计等。
结论
TPCC测试结果提供了关于数据库系统在线事务处理性能的重要信息，但解读这些结果时需要考虑多种因素。为了获得更准确的评估，建议在多个测试环境下进行多次测试，并综合考虑各项性能指标。
安装： 将tpcc-mysql-src.tgz文件传到家目录下
tar xf tpcc-mysql-src.tgz解压
cd /home/tpcc-mysql/src进入文件夹
yum install make gcc mysql-devel -y消除依赖关系
make安装
建立容器： docker run -d -p 3309:3306 --name psl-1 --cpu-shares 500 -m 500000000 --network changsha -e MYSQL_ROOT_PASSWORD='123456' mysql:5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d807c6f034dcf4260f7318691fa18746/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c7c6c53f9d742cf3118765f8d3fac47/" rel="bookmark">
			Tomcat 部署及优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tomcat概述
自2017年11月编程语言排行榜Java 占比13%,高居榜首，Tomcat 也一度成为Java 开发人员的首选。其开源、占用系统资源少、跨平台等特性深受广大程序员喜爱。
Tomcat核心组件
Tomcat由一系列的组件构成，其中核心的组件有三个。
Web 容器：完成Web 服务器的功能。
Servlet容器：名字为catalina,用于处理Servlet 代码。
JSP 容器：用于将JSP 动态网页翻译成Servlet代码。
Tomcat请求处理
用户在浏览器中输入网址localhost:8080/test/index jsp,请求被发送到本机端口8080,被在那里监听的Coyote HTTP/1.1 Connector获得；Connector 把该请求交给它所在的Service 的Engine (Container) 来处理，并等待Engine 的回应：Engine获得请求localhost/test/indexjsp, 匹配所有的虚拟主机Host;Engine匹配到名为localhost的Host (即使匹配不到也把请求交给该Host 处理，因为该Host被定义为该Engine的默认主机),名为localhost的 Host 获得请求 /testindexjsp,匹配它所拥有的所有Context。Host匹配到路径为/test的 Context (如果匹配不到就把该请求交给路径名为“”的Context去处理);path="/test"的Context 获得请求/indexjsp, 在它的mapping table 中寻找出对应的Servlet。Context 匹配到URL Pattern为*jsp的Servlet,对应于JspServlet类；
构造HttpServletRequest对象和 HttpServletResponse 对象，作为参数调用JspServlet的doGet()或doPost() ,执行业务逻辑、数据存储等；Context 把执行完之后的HttpServletResponse 对象返回给Host;Host 把 HttpServletResponse 对象返回给Engine;Engine 把HttpServletResponse对象返回Connector;Connector 把 HttpServletResponse对象返回给客户Browser。
下载并安装JDK
下载完安装包后，将其上传到服务器/root目录下，执行安装命令。
[root@localhost ~]#rpm -ivhjdk-8u171-linux-X64.rpm
查看版本号
安装启动Tomcat
1.安装Tomcat服务
2. 优 化Tomcat 服务启动时间
3.Tomcat目录结构
conf目录：用于存放Tomcat服务器的各种配置文件，比较常用的是server.xml、context.xml 、tomcat-users.xml 、web.xml四个文件。
bin 目录：用于存放启动和关闭Tomcat的脚本文件，比较常用的是catalina.sh、startup.sh、shutdown.sh三个文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c7c6c53f9d742cf3118765f8d3fac47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6792b5d455fb33cc0bbded0ec67dc57/" rel="bookmark">
			ML.Net 学习之使用经过训练的模型进行预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是ML.Net：（学习文档上摘的一段：ML.NET 文档 - 教程和 API 参考 | Microsoft Learn 【学习入口】）
它使你能够在联机或脱机场景中将机器学习添加到 .NET 应用程序中。 借助此功能，可以使用应用程序的可用数据进行自动预测。 机器学习应用程序利用数据中的模式来进行预测，而不需要进行显式编程。
ML.NET 的核心是机器学习模型 。 该模型指定将输入数据转换为预测所需的步骤。 借助 ML.NET，可以通过指定算法来训练自定义模型，也可以导入预训练的 TensorFlow 和 ONNX 模型。
拥有模型后，可以将其添加到应用程序中进行预测。
说明：我已经用.cli工具生成好模型了，现在需要用训练模型生成预测数据。我需要用多线程的方式来预测，查看文档后大概有以下几种预测方式
（1）单一预测，使用PredictionEngine
//定义的输入数据的类
ModelInput inputData = new ModelInput()
{
Stock_cd = @"s_600803",
Stock_subject = @"油气开采;甲醇;蜱虫;天然气;并购重组;沪港通概念;油价上调;海藻炼油;融资融券;转融券标的",
Stock_block = @"994392,992046",
Stati_date = @"2013/1/14",
IsNewStock = @"否",
Stock_capital = 9857851F,
Price = 11.922F,
Volume = 14950900F,
Orders = -1043.7F,
Transaction = -3330F,
};
//Create MLContext
MLContext mlContext = new MLContext();
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6792b5d455fb33cc0bbded0ec67dc57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/895e1c9853d43af2460102ad02b64da3/" rel="bookmark">
			Unity项目android下的环境配置及打包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity项目android下的环境配置及打包 要为 Android 构建和运行应用程序，必须安装 Unity Android Build Support 平台模块。还需要安装 Android 软件开发工具包（SDK）和原生开发工具包（NDK）才能在 Android 设备上构建和运行代码。默认情况下，Unity 会安装基于 OpenJDK 的 Java 开发工具包。
内容来自：休闲社交游戏-淘金城堡课程
课程地址：Unity中文课堂 https://learn.u3d.cn/tutorial/xiu-xian-she-jiao-you-xi-tao-jin-cheng-bao
作者公众号
第一种方法，使用Unity安装包进行环境配置 安装unity时在添加模块时，如下选择
第二种方法，安装android studio和jdk，然后配置unity 我们通过我们当前使用的unity编辑器的版本进行配置
通过Unity的菜单 “Help -&gt; Unity Manul” ，查看 Platform development-&gt;Android-&gt;Getting started with Android-&gt;Android environment setup
因为我用的Unity版本是2022.3，所以选择的版本如下
再查询的Gradle的版本
科普一下Gradle的概念：Gradle是一个构建系统，它自动化了许多构建过程，并防止了许多常见的构建错误。Unity在所有Android构建中都使用Gradle。您可以在Unity中构建输出包（.apk、.aab），也可以从Unity导出Gradle项目，然后使用Android Studio等外部工具进行构建。
Platform development-&gt;Android-&gt;Introducing Android-&gt;Gradle for Android
1 如上图，我们需要下载JDK11 下载地址为：https://www.oracle.com/java/technologies/downloads/#java11-windows
安装，默认安装到C盘即可
2 android studio下载并安装 下载地址：
下载 Android Studio 和应用工具 - Android 开发者 | Android Developers
安装过程也比较简单，跟着默认步骤即可
1）下载Android SDK 打开android studio，如下打开
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/895e1c9853d43af2460102ad02b64da3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bf807fcf4d29d0b8d5ca43825c1add6/" rel="bookmark">
			【详细的springboot自动装载原理】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.默认提供的核心配置模块 springboot提供了 spring-boot-autoconfigure模块，该模块为springboot自动配置的核心模块，它初始化好了很多我们平时需要的配置类，那么有了这些配置类就能生效了吗？得需要一个东西在启动的时候去把它加载进容器里。
2.启动配置类注解 @SpringBootApplication @SpringBootApplication 打开该注解
@Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class} ), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class} )} ) public @interface SpringBootApplication { 该注解是个复合注解，包含了
@SpringBootConfiguration @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Configuration public @interface SpringBootConfiguration { } 这个注解触发了自动配置的过程。它实际上导入了 AutoConfigurationImportSelector 类，这个类负责决定哪些自动配置类应该被添加到应用上下文中。
这是一个复合注解，它包含了 @Configuration 注解，意味着当前类是一个配置类，可以包含一个或多个 @Bean 方法来定义组件。
@EnableAutoConfiguration @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @AutoConfigurationPackage @Import({AutoConfigurationImportSelector.class}) public @interface EnableAutoConfiguration { String ENABLED_OVERRIDE_PROPERTY = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bf807fcf4d29d0b8d5ca43825c1add6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a98389544b4374fb754680d7dfc4a647/" rel="bookmark">
			接口测试之测试原则、测试用例、测试流程详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍅 点击文末小卡片 ，免费获取软件测试全套资料，资料在手，涨薪更快
一、接口的介绍 软件测试中，常说的接口有两种：图形用户接口（GUI，人与程序的接口）、应用程序编程接口（API）。
接口（API）是系统与系统之间，模块与模块之间或者服务与服务之间相互调用的入口。它的本质：其实就是一种约定，在开发前期，我们约定接口会接收什么数据；在处理完成后，它又会返回什么数据。
开发岗位分为前端和后端，他们相互配合完成工作，会协商接口的定义方法。一般后端定义接口，前端调用接口。前后端分离是web应用开发的发展趋势，优势有：
后端不用精通前端技术，只专注与数据的处理，对外提供API即可。前端的专业性越来越强，通过API获取数据，并专注与页面设计。前后端分离可扩大接口的应用范围，开发接口即可应用到web应用上，也可应用到app上。 接口的分类：HTTP接口、Web Service接口、RESTful接口。
二、接口测试的定义、必要性/优点、原理 1、接口测试的定义：
接口测试是测试系统组件间接口的一种测试。接口测试主要用于检测外部系统与系统之间以及内部各个子系统之间的交互点。测试的重点是要检查数据的交换，传递和控制管理过程，以及系统间的相互逻辑依赖关系等。（--百度百科）
接口测试，其实就是验证接口内部处理逻辑是否正确；我们既要保证单接口的正确性，也要保证接口的业务逻辑正确性，主要体现在两方面：
输入正确的测试数据，验证接口正常处理后返回的结果是否正确（数据结构&amp;数据内容）输入异常的测试数据，验证接口能否正确处理异常数据并返回特定提示，是否合理，是否健壮 接口测试目的：测试接口的正确性和稳定性（持续集成是接口测试的核心）
2、接口测试的必要性/优点：
开展接口测试可以及早发现问题，有效降低测试成本
接口一般较UI相对稳定，更利于进行自动化和持续集成
特别适用于高复杂性的平台，可以带来高效的缺陷监测和质量监督能力（平台越复杂，系统越庞大，接口测试的效果越明显：提高测试效率，提升用户体验，降低研发成本）
PS：以保证系统的正确和稳定为核心，以持续集成为手段，提高测试效率，提升用户体验，降低产品研发成本。（持续集成是接口测试的低成本、高收益的根源，是接口测试的灵魂。没有持续集成接口测试带来工作量会成指数增长！）
3、接口测试的原理：
测试借助工具模拟客户端向服务器发送请求报文，服务器接收请求报文后对相应的报文做处理并向客户端返回应答，工具模拟客户端接收应答，然后测试人员检查应答是否准确。
三、接口测试的范围、原则、重难点 1、接口测试的范围：
（1）需要测试的接口：
随着系统的复杂性越来越高，接口越来越多，覆盖所有接口是很困难的事。通常主要测试最外层的两类接口：数据进入系统接口（调用外部系统的参数为本系统使用）和数据流出系统的接口（验证系统处理后的数据是否正常）。
（2）被测接口需要测试的方面：
关注被测接口的功能是否实现，性能是否达标，安全性是否满足。重点关注数据的交换、传递、处理次数、以及控制管理过程。可参考下面用例设计中的接口测试点。
2、编写和执行测试时的原则：
不同的接口参数覆盖不同的业务场景；在后台构造合适的数据来满足接口的测试用例；根据接口的返回值，断言其是否返回期望结果，并查看数据库验证；测试用例涉及多个步骤的，应对涉及的步骤都验证删除测试过程中产生的结果，确保每个用例执行前都是一个清洁的环境 3、接口测试的重难点：
动态变量参数化接口依赖及中间变量问题异步接口结果验证问题相应参数及嵌套很多的验证问题接口测试框架的稳定性问题资源清理问题多接口场景测试 四、接口测试的用例设计 接口测试对象主要为接口，但随着系统复杂度越来越高，接口越来越多，完全覆盖是一件很困难的事情，且实际过程中任意接口的变动都可能导致我们接口测试用例不可用。
1、接口测试点参考：
2、接口用例设计优先级
优先级--&gt;针对所有接口：
暴露在外面的接口，因为通常该接口会给第三方调用；供系统内部调用的核心功能接口；供系统内部调用非核心功能接口； 优先级--&gt;针对单个接口：
正向用例优先测试，逆向（异常）用例次之 (通常情况，非绝对)；
是否满足前提条件 &gt; 是否携带默认参值参数 &gt; 参数是否必填 &gt; 参数之间是否存在关联 &gt; 参数数据类型限制 &gt; 参数数据类型自身的数据范围值限制
是否满足前提条件：有些接口需要满足前置条件，才可成功获取数据。常见的，需要登陆 Token。逆向用例：针对是否满足前置条件 (假设为 n 个条件)，设计 0~n 条用例；是否携带默认值参数：设计 1 条正向用例，带默认值的参数都不填写、不传参，必填参数都填写正确且存在的 “常规” 值，非必填参数不填写、不传参；业务规则、功能需求：根据实际情况结合接口参数说明，可能需要设计 n 条正向用例和逆向用例参数是否必填：针对每个必填参数，都设计 1 条参数值为空的逆向用例参数之间是否存在关联：有些参数彼此之间存在相互制约的关系。逆向用例：根据实际情况，可能需要设计 0~n 条用例参数数据类型限制：针对每个参数都设计 1 条参数值类型不符的逆向用例参数数据类型自身的数据范围值限制：针对所有参数，设计 1 条每个参数的参数值在数据范围内为最大值的正向用例；针对每个参数 (假设 n 个)，设计 n 条每个参数的参数值都超出数据范围最大值的逆向用例；针对每个参数 (假设 n 个)，设计 n 条每个参数的参数值都小于数据范围最小值的逆向用例 以上几个方面考虑全的话，基本可以做到如下几个方面的覆盖：主流程测试用例：正常的主流程功能校验；分支流测试用例：正常的分支流功能校验。异常流测试用例：异常容错校验
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a98389544b4374fb754680d7dfc4a647/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fd0fb217b7d227a08998bea69f8611b/" rel="bookmark">
			如何解决Windows系统目录权限问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言1. 为什么会出现权限问题2. 修改文件权限的步骤2.1 确定目标文件2.2 右键属性设置2.3 更改所有者2.4 修改权限2.5 确认修改 3. 替换文件3.1 拷贝新的文件3.2 验证替换结果 结语 前言 在Windows系统中，时常需要往C盘系统目录下拷贝或者替换文件。然而，直接进行这些操作时，常常会遇到权限问题，导致操作失败。本文将详细介绍解决这一问题的方法，通过修改系统目录下文件的权限来实现文件的替换或拷贝。
1. 为什么会出现权限问题 Windows系统为了保证系统的安全性，对C盘的系统目录进行了严格的权限控制。默认情况下，只有管理员用户对这些目录具有完全控制权限，普通用户则受限。因此，当我们尝试在这些目录下进行文件操作时，如果没有相应的权限，就会遇到权限不足的报错。
2. 修改文件权限的步骤 2.1 确定目标文件 假设我们需要升级OpenSSH，这就需要下载最新版本的ssh文件并替换系统目录下的旧版本文件。在这种情况下，首先需要找到目标文件，例如C:\Windows\System32\OpenSSH\ssh.exe。
2.2 右键属性设置 右键点击目标文件，选择“属性”。在弹出的属性窗口中，切换到“安全”选项卡。点击“高级”按钮，进入高级安全设置窗口。
2.3 更改所有者 在高级安全设置窗口中，点击“更改”按钮修改所有者。输入当前用户的用户名，点击“检查名称”确保用户名正确，然后点击“确定”。返回高级安全设置窗口，勾选“替换子容器和对象的所有者”选项。点击“应用”并确认更改。
2.4 修改权限 在高级安全设置窗口中，找到当前用户或Users组，点击“编辑”。在权限窗口中，勾选“完全控制”选项，确保当前用户或Users组拥有所有权限。点击“确定”并保存设置。
2.5 确认修改 返回属性窗口，确保当前用户或Users组的权限已经修改为完全控制。点击“确定”关闭属性窗口。
3. 替换文件 3.1 拷贝新的文件 完成权限修改后，即可将新的ssh文件拷贝到系统目录下，替换旧版本文件。在此过程中，不会再遇到权限问题，可以顺利完成文件的替换操作。
3.2 验证替换结果 替换完成后，可以通过运行ssh命令来验证新版本文件是否正常工作。如果一切正常，则说明文件替换成功。
结语 通过上述步骤，我们可以顺利解决在Windows系统目录下拷贝或替换文件时遇到的权限问题。这不仅提高了工作效率，也确保了系统的安全性。希望这篇文章对你有所帮助，能够在实际操作中顺利进行文件的替换和拷贝。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23d995e015695e2ff89b4827bb0ce41a/" rel="bookmark">
			【数据结构】树和二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.前言
2.树
2.1树的概念
2.2树中的重要概念
2.3树的表示形式
2.4树的应用
3.二叉树
3.1概念
3.2两种特殊的二叉树
3.3二叉树的性质
3.4二叉树的存储
3.5二叉树的遍历方式
3.5.1创建二叉树
3.5.2二叉树的遍历
3.6二叉树的基本操作
4.总结
1.前言 二叉树是数据结构中比较难的数据结构之一，树在计算机中的应用也是非常广泛，例如文件系统、数据库查询、图形处理等。树结构的优点是：可以用来表示关系，可以用来存储和查询大量数据，可以用来实现文件管理和数据库管理等功能。接下来，让我们一起去认识并学习树和二叉树！
2.树 2.1树的概念 树是一种 非线性 的数据结构，它是由 n （ n&gt;=0 ）个有限结点组成一个具有层次关系的集合。 把它叫做树是因为它看 起来像一棵 倒挂的树，也就是说它是根朝上，而叶朝下的 。它具有以下的特点： 有一个特殊的结点，称为 根结点，根结点没有前驱结点 ； 除根结点外，其余结点被分成 M(M &gt; 0) 个互不相交的集合 T1 、 T2 、 ...... 、 Tm ，其中每一个集合 Ti (1 &lt;= i &lt;= m) 又是一棵与树类似的子树。每 棵子树的根结点有且只有一个前驱 ，可以有 0 个或多个后继； 树是 递归 定义的。 注意：树形结构中，子树之间不能有交集，否则就不是树形结构 。 2.2树中的重要概念 结点的度：一个结点含有子树的个数称为该结点的度； 如上图：A的度为6。树的度：一棵树中，所有结点度的最大值称为树的度； 如上图：树的度为6。叶子结点或终端结点：度为0的结点称为叶结点； 如上图：B、C、H、I...等节点为叶结点。双亲结点或父结点：若一个结点含有子结点，则这个结点称为其子结点的父结点； 如上图：A是B的父结点。孩子结点或子结点：一个结点含有的子树的根结点称为该结点的子结点； 如上图：B是A的孩子结点。根结点：一棵树中，没有双亲结点的结点；如上图：A。结点的层次：从根开始定义起，根为第1层，根的子结点为第2层，以此类推。树的高度或深度：树中结点的最大层次； 如上图：树的高度为4。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23d995e015695e2ff89b4827bb0ce41a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ddb0234fcaaa295938a9b039495eb4c/" rel="bookmark">
			Linux中tomcat下载教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.安装tomcat 1.安装 EPEL 仓库：
sudo yum install epel-release 2.安装 Tomcat：
sudo yum install tomcat 3.启动 Tomcat 服务：
sudo systemctl start tomcat 4.启用 Tomcat 服务开机启动：
sudo systemctl enable tomcat 5.检查 Tomcat 服务状态：
sudo systemctl status tomcat 出现以下字样即为启动成功
安装的 Tomcat 在以下目录：
配置文件：/etc/tomcat/主目录：/usr/share/tomcat/日志文件：/var/log/tomcat/启动脚本：/etc/init.d/tomcat 或 systemctl start tomcat 其中主要文件夹就是/usr/share/tomcat/
tomcat相关命令
启动tomcat：systemctl start tomcat
停止tomcat服务：systemctl stop tomcat
重启tomcat：systemctl restart tomcat
开机启动：systemctl enable tomcat
查看tomcat状态：systemctl status tomcat
二.安装Tomcat Manager App 只安装tomcat是打不开管理控制台的,我们需要安装Manager App,继续输入
yum install tomcat-webapps tomcat-admin-webapps 完成下载
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ddb0234fcaaa295938a9b039495eb4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/022e0d84035419783fb374fc31cbbb02/" rel="bookmark">
			.Net 8 控制台程序部署(Linux篇)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在无流量Linux环境下部署.NET8开发的控制台程序 写在前面准备远程访问安装环境程序部署1.下载并导入2.解压并配置3.发布程序4.创建Systemd服务单元文件5.启用并启动服务 写在结尾 写在前面 好久没更新文章了，今天给大家带来的是在在无流量的Linux工控机上部署.Net8开发的控制台程序，并将其作为一个后台服务持续运行。废话不多说，直接进入正题。
准备 今天的教学还是需要一点成本的，首先你得拥有一台Linux工控机，我用的是Debian，你也可以用其他的，如果遇到了文章内容之外的问题，欢迎讨论。其次你要完成一个在.net8环境下开发的控制台程序，这对各位来说应该是比较简单。
远程访问 既然我们要在linux系统上部署我们的程序，那第一步肯定是远程访问linux系统，这里我使用的是xshell7和xftp7（虽然一直提示我升级）。
这里关于怎么远程访问到linux系统我就不赘述了，比如配置IP，确定root账号密码等相关的资料网上应该是很多的。
安装环境 我这边安装的是.Net8 sdk，两个原因：1是我确实会有在linux系统上直接编译代码的需求，所以如果只安装CLR是不能满足我的使用需求的。2是我CLR安装一直出问题😂，没办法直接安装sdk了。
环境安装步骤如下
程序部署 1.下载并导入 在微软官网查看自己的linux版本是否被支持，然后根据你的操作系统下载对应的sdk二进制文件，这里我下载的是Arm32的二进制文件。
然后使用xshell配套的工具xftp来将这个文件移动到linux工控机上合适的位置，建议是/usr/share/dotnet(如果不存在就自己创建一个)。
2.解压并配置 首先解压到指定位置
sudo tar -C /usr/share/dotnet -xzf dotnet-sdk-8.0.303-linux-arm.tar.gz
注意，这里可以直接执行这条命令的条件是，你当前的位置在该二进制文件的目录
然后创建软连接
sudo ln -s /usr/share/dotnet/dotnet /usr/bin/
创建软连接类似于配置环境变量。
最后验证安装的sdk版本
dotnet --version
3.发布程序 右键项目，右键菜单中有一个发布菜单，点击发布他会出现一个发布导航界面，只要按照他的引导将项目发布到publish文件夹中就可以了，然后使用xftp工具将这个publish文件移动到工控机上合适的位置。我暂时将这个文件移动到/usr/share/program/
4.创建Systemd服务单元文件 创建一个名为myconsoleapp.service的文件在/etc/systemd/system目录下，具体指令如下
sudo nano /etc/systemd/system/myconsoleapp.service
该指令会创建该文件并进入编辑窗口。输入
[Unit]
Description=My Console Application Service
After=network.target
[Service]
User=root
WorkingDirectory=/usr/share/program/publish
ExecStart=/usr/share/dotnet/dotnet /usr/share/program/publish/LocalEMS.Cmd.dll
Restart=no
RestartSec=10
KillSignal=SIGINT
TimeoutStopSec=5
Environment=ASPNETCORE_ENVIRONMENT=Production
Environment=DOTNET_PRINT_TELEMETRY_INFO=false
[Install]
WantedBy=multi-user.target
上述配置具体解释如下
[Unit]
这部分包含了描述服务的元数据。
Description: 服务的描述，这里是"My Console Application Service"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/022e0d84035419783fb374fc31cbbb02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b029e6612d208acf5387c62232ff937/" rel="bookmark">
			mysql常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、链接数据库 mysql -u your_username -p 2、显示所有数据库 SHOW DATABASES; 3、选择数据库 USE your_database; 4、列出数据库中所有表 SHOW TABLES; 5、退出mysql exit; 6、创建数据库 CREATE DATABASE 数据库名; 7、删除数据库 DROP DATABASE &lt;database_name&gt;; -- 直接删除数据库，不检查是否存在 或 DROP DATABASE [IF EXISTS] &lt;database_name&gt;; 8、创建数据表 CREATE TABLE table_name ( column1 datatype, column2 datatype, ... ); -- 示例 CREATE TABLE users ( id INT AUTO_INCREMENT PRIMARY KEY, username VARCHAR(50) NOT NULL, email VARCHAR(100) NOT NULL, birthdate DATE, is_active BOOLEAN DEFAULT TRUE ); -- id: 用户 id，整数类型，自增长，作为主键。 -- username: 用户名，变长字符串，不允许为空。 -- email: 用户邮箱，变长字符串，不允许为空。 -- birthdate: 用户的生日，日期类型。 -- is_active: 用户是否已经激活，布尔类型，默认值为 true。 9、删除数据表 DROP TABLE table_name ; -- 直接删除表，不检查是否存在 或 DROP TABLE [IF EXISTS] table_name; 10、插入数据 INSERT INTO table_name (column1, column2, column3, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b029e6612d208acf5387c62232ff937/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce466d3230ea61b125f415a980045dc3/" rel="bookmark">
			pycharm安装教程-PyCharm安装破解步骤【MAC版】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pycharm安装教程-PyCharm2023安装破解步骤【MAC版】 破解安装安装包获取 今天来给大家分享 Mac 系统安装 PyCharm，附带资源 破解安装，
PyCharm 相关就不叙述了，直接开始安装！
破解安装 打开下载的安装包 PyCharm2023.dmg，包含 4 个文件直接按图中把安装包拖动过去
启动台 应用程序出现这个，直接点击打开
确定打开
进入界面后，不用操作，直接退出即可
打开文稿，直接拖动 ja-netfilter 到文稿中
打开 应用程序，找到 PyCharm.app ,右键-点击 -&gt; 显示包内容
依次点击文件夹 -&gt; Contents -&gt; bin右键编辑 pycharm.vmoptions
替换成自己的用户名，粘贴到 pycharm.vmoptions 底部 -javaagent:/Users/自己的电脑用户名/Documents/ja-netfilter/ja-netfilter.jar --add-opens=java.base/jdk.internal.org.objectweb.asm=ALL-UNNAMED --add-opens=java.base/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED 直接去 - 系统设置 - 用户与群组 - 查看用户名
打开 PyCharm，粘贴 注册码
点击 create project 就可以开始使用了
安装包获取 链接：https://pan.quark.cn/s/8ba04c515487
提取码：9TZa
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bb61f848c4e9c89d5f08fb56b40f587/" rel="bookmark">
			从图解看算法：如何在生活中发现它们的踪迹【文末送书】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、算法的基本概念二、算法在日常生活中的应用三、常见算法图解四、算法的未来发展人人都离不开的算法——图解算法应用【文末送书】 在现代社会中，算法无处不在。无论是你用来搜索信息的引擎，还是你用来推荐电影的应用，算法都在背后发挥着重要作用。虽然算法听起来有些复杂，但它们实际上是我们日常生活中不可或缺的部分。本文将通过图解的方式，帮助你更好地理解算法的应用。
一、算法的基本概念 算法是解决问题的一系列步骤或规则。它可以是非常简单的，比如加法运算；也可以是非常复杂的，比如机器学习中的深度学习算法。算法的核心在于其系统化的步骤，可以帮助我们有效地解决各种问题。
二、算法在日常生活中的应用 搜索引擎
搜索引擎如Google或Bing使用复杂的算法来快速找到最相关的网页。当你输入一个查询时，搜索引擎会利用其排名算法来确定哪些网页最符合你的要求。
推荐系统
推荐系统被广泛应用于电商和流媒体平台（如Amazon和Netflix）。这些系统利用算法分析你的历史行为和偏好，以推荐你可能感兴趣的商品或内容。
导航和地图服务
导航应用（如Google Maps或百度地图）使用路径搜索算法来计算最短或最快的行驶路线。它们会考虑交通状况、道路限制等因素。图示如下：
三、常见算法图解 排序算法
排序算法是最基本的算法之一，它用于将一组数据按照特定顺序排列。常见的排序算法包括冒泡排序、选择排序和快速排序。
搜索算法
搜索算法用于在数据集中查找特定的值。线性搜索和二分搜索是最常见的搜索算法。
四、算法的未来发展 随着技术的进步，算法也在不断发展。例如，人工智能和机器学习领域中的算法正在不断提升，能够处理更复杂的数据和任务。未来，我们可能会看到更多基于算法的创新应用，例如智能家居系统、自适应学习平台等。
算法不仅是计算机科学的核心，也是我们日常生活的重要组成部分。通过理解和应用算法，我们可以更好地利用技术、提高效率并解决问题。希望本文通过图解的方式，能够帮助你更直观地理解算法的应用及其重要性。
人人都离不开的算法——图解算法应用【文末送书】 购书链接：
JD：https://item.jd.com/13368139.html
当当：http://product.dangdang.com/29471604.html
无论你是否愿意，我们早已生活在一个被算法包围的世界。
没有算法加持，我们将寸步难行。
1、通俗易懂
耳熟能详的生活场景+幽默风趣的行文插画，
将晦涩、专业的算法应用深入浅出地呈现给大家。
2、技术科普
5 大核心领域：公共、商业、工业、医疗、金融。
18个算法应用：反诈、热线派单、智能推荐、库存监控、健康监测、胞诊断、产品缺陷检测、金融风控/核保……
全面认知我们当前所处的世界
3、贴近时代、贴近生活
所有算法均来自当前数字化生活中
千万人每天都在使用的应用实践
与大家的衣食住行、工作生活、生老病死息息相关
4、启发思考
算法是如何在各行各业中发挥作用并渗透到人们生活中的？算法背后的运行机制是什么，它的工作成效如何？
大数据杀熟、算法黑箱、算法偏见、信息茧房……我们该如何面对这些日益不受控制的技术？
你是否发现，购物、短视频、资讯等平台背后的智能推荐算法，不断分析着你的购物偏好和浏览习惯；价格算法时刻计算调整着你能购买到的商品价位；导航算法、网约车平台算法和无人驾驶汽车算法等等，时刻影响着我们的出行……
无论是否愿意，我们的生活已被算法包围。为了帮助大家全面认知我们当前所身处的世界，消弭技术发展过快带来的困扰与隐忧，《人人都离不开的算法——图解算法应用》一方面从人工智能算法的五大核心应用领域—公共、商业、医疗、工业、金融的典型场景出发，以通俗化、故事化和漫画化的具体事例，深入解读算法是如何在各行各业具体发挥作用和对日常生活的影响；另一方面，将从算法的责任监管和立法治理等角度，阐述算法开发与应用者们应该如何守好伦理底线，让科技向善而行。
《人人都离不开的算法——图解算法应用》脉络清晰，图文并茂，无论你是工作中会接触到算法应用的从业人员，还是对算法应用感到好奇的小白，本书都有助于你打开视野，看到算法在实际应用中的波澜壮阔。
精彩书摘
诈骗层出不穷，算法如何筑起“防火墙”？
和朋友聚会的间隙，你有没有拿起手机后发现一条内容为“尊敬的XXX您好，恭喜您中奖了！请点击以下链接领取奖品！”的短信？
昏昏欲睡的清晨，你有没有被急促的电话铃声惊醒，看一眼手机屏幕却发现是来自几内亚的奇怪号码？
为避免大家因接听一通电话或点击一则短信中的链接便白白损失巨额钱财，我们机智负责的智慧公安闪亮登场！
近年来，各地公安部门引入“智慧公安”，帮助公安部门“出任务”。“智慧公安”最亮眼的功绩之一，就是开发出越来越智能的防范电信诈骗系统（即“反诈系统”），从源头建立起无辜群众和电信诈骗犯之间的屏障。其实，打造“训练有素”的反诈系统需要三步。
第一步，运用特征算法，为大量呼出号码“打标签”。
通过多频率单号短时呼叫、超长通话、呼叫连续的企业通信行为模式来判断呼出号码所属企业“是否有诈骗风险”。打个比方，如果某一号码在5分钟内呼出了300通电话，或者某一通电话长达300分钟，甚至呼出每通电话间隔不超过2分钟，那么，反诈系统就会将其标记为“有诈骗嫌疑的号码”。
第二步，运用语义分析系统训练反诈系统的“诈骗敏感度”。
如果只根据反诈系统对通话数据的智能判断便笼统地为号码贴上好或坏的标签，也存在误判的可能。因此，反诈系统还会运用语义分析工具对大量通话文本进行语义分析，将通话文本拆解为由关键字、关键词构成的“文本单元”，找出其中的敏感关键字，标记此类关键字，再由人工识别来修正系统的判断结果，以提高对于违规号码的检测效率和准确性。
最后一步，精准标记违规号码。
如果某一企业的呼出通话中涉及到人名、地名、身份证号、卡号、公检法、礼品等“敏感词”，触发了敏锐的反诈系统，呼出号码所在企业则有可能被停机、停号，还可能被上报给运营商，被添加到“呼出黑名单”中，这也是我们在接到陌生来电时会被提示“该号码被多人标记为诈骗骚扰”的来源。
反诈系统通过在呼出阶段提醒接听方此通电话存在“嫌疑”，为接听方筑起心理防线，提醒其留意潜在风险。
总而言之，智慧公安通过“运用算法将大量数据‘标签化’-引入多种系统提升算法准确性-将‘危险信号’及时传递给人民群众”三个步骤完成保护人民群众生命财产安全这一艰巨任务。
数据显示，仅2021年1-4月短短三个月，某省共破获电信网络诈骗案件1.18万起，采取刑事强制措施8771人，挽回经济损失8.8亿元，足以见得智慧公安的“功力”。
此外，近年来某省警方紧扣大数据、算法等信息技术发展智慧公安系统，开发建设全省警情大数据应用服务平台。平台按秒全项汇聚全省72个110接警区接处警数据，实现对全省警情数据的实时监测、多维展示和深度应用。警情大数据平台建成后，每个接警区产生的新110接处警信息，都会实时汇聚至全省警情数据库，确保省市县三级公安机关都能在第一时间获取相关数据信息，达到“实时监测治安态势一网掌控，深度研判警情资源全警应用”的目的。
有了算法加持的智慧公安帮忙，警察叔叔再也不用“大海捞针”式地寻找诈骗分子，公安部门运转效率大大提升。相信在不远的未来，越来越多的公安部门将会借助算法装备上“三头六臂”，筑起保障人民群众生命财产安全的屏障。
诈骗层出不穷，算法如何筑起“防火墙”？
和朋友聚会的间隙，你有没有拿起手机后发现一条内容为“尊敬的XXX您好，恭喜您中奖了！请点击以下链接领取奖品！”的短信？
昏昏欲睡的清晨，你有没有被急促的电话铃声惊醒，看一眼手机屏幕却发现是来自几内亚的奇怪号码？
为避免大家因接听一通电话或点击一则短信中的链接便白白损失巨额钱财，我们机智负责的智慧公安闪亮登场！
近年来，各地公安部门引入“智慧公安”，帮助公安部门“出任务”。“智慧公安”最亮眼的功绩之一，就是开发出越来越智能的防范电信诈骗系统（即“反诈系统”），从源头建立起无辜群众和电信诈骗犯之间的屏障。其实，打造“训练有素”的反诈系统需要三步。
第一步，运用特征算法，为大量呼出号码“打标签”。
通过多频率单号短时呼叫、超长通话、呼叫连续的企业通信行为模式来判断呼出号码所属企业“是否有诈骗风险”。打个比方，如果某一号码在5分钟内呼出了300通电话，或者某一通电话长达300分钟，甚至呼出每通电话间隔不超过2分钟，那么，反诈系统就会将其标记为“有诈骗嫌疑的号码”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bb61f848c4e9c89d5f08fb56b40f587/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c6dc862804053e75f61890053234c25/" rel="bookmark">
			使用Springboot &#43; netty 打造聊天服务（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、创建Springboot工程1.1、项目创建1.2、环境配置1.2.1、检查settings.xml1.2.2、检查本地仓库 1.3、项目结构配置1.3.1、配置JDK 1.4、添加依赖 2、构造NettyWebsocketServer2.1、创建一个 Netty 服务器配置类2.2、添加自定义handler 3、使用ApiFox调试3.1、启动服务3.2、添加Apifox WebSocket接口3.3、客户端发送数据3.4、Debug调试数据3.5、客户端结果3.6、改造服务端代码 4、总结 1、创建Springboot工程 在Idea里创建Springboot工程，Language选择Java，Type选择Maven，Project SDK 选择Java8。
1.1、项目创建 成功创建项目，Sringboot版本 2.7.6，Java版本8。
1.2、环境配置 检查Maven配置，主要检查settings.xml和本地Maven仓库
1.2.1、检查settings.xml 在settings.xml里配置上阿里云镜像
&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; 1.2.2、检查本地仓库 Maven版本3.6.3，在Maven文件夹下创建了res文件夹，做为Java工程的Maven本地仓库地址，此文件通常都在500MB以上，随着本地项目数而递增。
1.3、项目结构配置 打开【Project Structure】
1.3.1、配置JDK 修改SDK、Language level等配置。
1.4、添加依赖 上述操作都是打基础，搭架子和配置环境，下一步我们需要加载netty 的相关依赖包。
在 pom.xml 文件中添加 Netty 和 Spring Boot 相关的依赖：
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;4.1.68.Final&lt;/version&gt; &lt;!-- 请根据需要选择合适的版本 --&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、构造NettyWebsocketServer 2.1、创建一个 Netty 服务器配置类 import io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c6dc862804053e75f61890053234c25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6469a697524ea8523195d6c002c566a/" rel="bookmark">
			word转pdf图变得模糊（解决）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 日常小记 目录问题解决方案 结语 目录 问题 word转pdf图变得模糊后图变得不清晰
解决方案 首先在ppt中进行画图其次复制该图的所有元素直接复制到word，在粘贴中选中选择性粘贴，增强性图形即可解决！！！ 其余方案
可以试试将图片换成emf格式
结语 遇事不决 可问春风春风不语 即随本心我若本心能定 怎会遇事不决 春风亦有春风愁 不劳春风为我忧。自此春风盈满袖，只为一解平安愁 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3774260a96146a85e051d9718273b5a3/" rel="bookmark">
			spark 广播变量broadcast
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 broadcast使用如下图，可以看到创建broadcast是val barr1 = sc.broadcast(arr1)，使用broadcast是barr1.value
创建broadcast是使用的broadcastManager。
BroadcastManager cachedValues变量是map结构，key是broadcastId，强引用，GC的时候不会回收，value是broadcast值，弱引用，GC的时候会进行回收。
创建新的broadcast值是生成新的broadcastId，再调用broadcastFactory的方法。
TorrentBroadcastFactory 创建新的broadcast值，就是生成了TorrentBroadcast对象。
TorrentBroadcast _value是一个缓存，但是是软引用，会被GC回收。
numBlocks是broadcast写入block对应的数量，调用了writeBlocks将obj写入block。
writeBlocks 这个方法是在driver端运行的。首先将value缓存到driver的本地（MEMORY_AND_DISK），在driver运行的task可以直接读取这个值。再将value序列化、压缩后分块（默认4M），将分好的块也缓存下来（MEMORY_AND_DISK_SER），但是tellMaster=true，意思是将缓存结果通知给blockManagerMaster。
value 在task中获取broadcast值，使用value方法。
value方法是调用的getValue方法
getValue 优先从TorrentBroadcast对象的缓存_value中获取。如果取不到就调用readBroadcastBlock方法获取，得到的结果缓存到_value中。
readBroadcastBlock 先根据broadcastId从broadcastManager的cache中获取，如果获取不到就先读取本地block来获取值，返回的值缓存到broadcastManager的cache。
本地没获取到，就调用readBlocks从远端获取（driver或者其它executor）。获取到的结果缓存到本地block，同时缓存到broadcastManager的cache中
readBlocks broadcast是分块进行存储的，所以也是分块进行获取。
根据pieceId优先从本地进行读取，如果没有值的话，就调用getRemoteBytes从远端进行读取，得到的piece值缓存到本地，并通知给blockManagerMaster，方便别的executor来获取。最后返回放有所有piece结果的blocks。
broadcast存储 分成两部分进行存储。整体存储是提供给运行在本地的task来直接获取，分piece存储是为了提供给远端task获取。
如果只有整体存储没有分块存储的话，一开始broadcast值只在driver端存储。task启动后，对应的executor都会从driver读取，这样就会有driver的io瓶颈。加上分块存储后，一开始broadcast值只在driver端存储，executor向driver请求piece（请求piece的顺序是打乱的），请求数据量不大，而且executor获取到piece后也会缓存到本地，提供给别的executor来请求，这样就将driver的压力分散到各个executor。
如果只有分块存储没有整体存储的话，本地读取也要按照piece读取再合并，效率比较低，因为一个executor上会运行很多task任务。其实我觉得去掉整体存储影响不大，因为广播变量值在内存还有两层缓存。
读取broadcast 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96979782c5af99947af043eb081a79d5/" rel="bookmark">
			前端大文件分片下载解决方案（看这一篇就够了）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概要整体架构流程具体实现一，分片下载之本地储存（localForage）前言：二，本地数据获取（获取下载列表）二，操作JS1，下载进度监听2，文件下载状态控制3，分片下载 二，VUE页面 小结 概要 本文从前端方面出发实现浏览器下载大文件的功能。不考虑网络异常、关闭网页等原因造成传输中断的情况。分片下载采用串行方式（并行下载需要对切片计算hash，比对hash，丢失重传，合并chunks的时候需要按顺序合并等，很麻烦。对传输速度有追求的，并且在带宽允许的情况下可以做并行分片下载）
整体架构流程 1， 使用分片下载： 将大文件分割成多个小块进行下载，可以降低内存占用和网络传输中断的风险。这样可以避免一次性下载整个大文件造成的性能问题。
2， 断点续传： 实现断点续传功能，即在下载中途中断后，可以从已下载的部分继续下载，而不需要重新下载整个文件。
3， 进度条显示： 在页面上展示下载进度，让用户清晰地看到文件下载的进度。如果一次全部下载可以从process中直接拿到参数计算得出（很精细），如果是分片下载，也是计算已下载的和总大小，只不过已下载的会成片成片的增加（不是很精细）。
4， 取消下载和暂停下载功能： 提供取消下载和暂停下载的按钮，让用户可以根据需要中止或暂停下载过程。
5， 合并文件： 下载完成后，将所有分片文件合并成一个完整的文件。
具体实现 一，分片下载之本地储存（localForage） 前言： 浏览器的安全策略禁止网页（JS）直接访问和操作用户计算机上的文件系统。
在分片下载过程中，每个下载的文件块（chunk）都需要在客户端进行缓存或存储，方便实现断点续传功能，同时也方便后续将这些文件块合并成完整的文件。这些文件块可以暂时保存在内存中或者存储在客户端的本地存储（如 IndexedDB、LocalStorage 等）中。
使用封装，直接上代码：
import axios from 'axios'; import ElementUI from 'element-ui' import Vue from 'vue' import localForage from 'localforage' import streamSaver from 'streamsaver'; import store from "@/store/index" /** * localforage–是一个高效而强大的离线存储方案。 * 它封装了IndexedDB, WebSQL, or localStorage，并且提供了一个简化的类似localStorage的API。 * 在默认情况下会优先采用使用IndexDB、WebSQL、localStorage进行后台存储， * 即浏览器不支持IndexDB时尝试采用WebSQL，既不支持IndexDB又不支持WebSQL时采用 * localStorage来进行存储。 * */ /** * @description 创建数据库实例，创建并返回一个 localForage 的新实例。每个实例对象都有独立的数据库，而不会影响到其他实例 * @param {Object} dataBase 数据库名 * @return {Object} storeName 实例（仓库实例） */ function createInstance(dataBase){ return localForage.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96979782c5af99947af043eb081a79d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2b1b37f31f356cdc6cf389c657aa59c/" rel="bookmark">
			Mistral联合英伟达开源12B小模型：碾压Llama 3，单张4090可跑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小模型，成为本周的AI爆点。
与动辄上千亿参数的大模型相比，小模型的优势是显而易见的:它们不仅计算成本更低，训练和部署也更为便捷，可以满足计算资源受限、数据安全级别较高的各类场景。因此，在大笔投入大模型训练之余，像 OpenAI、谷歌等科技巨头也在积极训练好用的小模型。先是HuggingFace推出了小模型SmoLLM；OpenAI直接杀入小模型战场，发布了GPT-4o mini。
GPT-4o mini发布同天，欧洲最强AI初创公司Mistral立马发布旗下最新最强小模型——Mistral NeMo。这个小模型由 Mistral AI 和英伟达联合打造，参数量为120亿（12B），上下文窗口为128k。这是一款寻求在不依赖大量云资源的情况下实施 AI 解决方案的企业的强大工具。
卓越性能 Mistral NeMo支持128K上下文，能够更加连贯、准确地处理广泛且复杂的信息，确保输出与上下文相关。
与同等参数规模模型相比，它的推理、世界知识和编码准确性都处于领先地位。
下表结果所示，除了在MMLU基准上，Mistral NeMo不如Gemma 2 9B。但在多轮对话、数学、常识推理、世界知识和编码等基准中，超越了Gemma 2 9B和Llama 3 8B。
Mistral在Apache2.0许可证下发布了预训练的基本检查点和指令微调检查点，允许商用。
Mistral NeMo 经过量化感知训练，可在不损失任何性能的情况下进行 FP8推理。
此外，模型使用FP8数据格式进行模型推理，这可以减少内存大小并加快部署速度，而不会降低准确性。这意味着，模型可以流畅丝滑地学习任务，并更有效地处理不同的场景，使其成为企业的理想选择。
这种格式可以在任何地方轻松部署，各种应用程序都能灵活使用。因此，模型可以在几分钟内，部署到任何地方，免去等待和设备限制的烦恼。
Mistral NeMo瞄准企业用户的使用，采用属于NVIDIA AI Enterprise一部分的企业级软件，具有专用功能分支、严格的验证流程以及企业级安全性的支持。开放模型许可证也允许企业将Mistral NeMo无缝集成到商业应用程序中。
Mistral NeMo NIM专为安装在单个NVIDIA L40S、NVIDIA GeForce RTX 4090或NVIDIA RTX 4500 GPU的内存上而设计，高效率低成本，并且保障安全性和隐私性。也就是说，单个英伟达L40S，一块GPU就可跑了。
先进模型 Mistral AI和英伟达各自擅长的领域结合，优化了Mistral NeMo的训练和推理。模型利用Mistral AI的专业知识进行训练，尤其是在多语言、代码和多轮内容方面，受益于英伟达全堆栈的加速训练。它专为实现最佳性能而设计，利用高效的模型并行技术、可扩展性以及与Megatron-LM的混合精度。该模型使用NVIDIA NeMo的一部分Megatron-LM进行训练，在DGX Cloud上配备3,072个H100 80GB Tensor Core GPU，由NVIDIA AI架构组成，包括加速计算、网络结构和软件，以提高训练效率。
民主化 AI：面向大众的多语言模型 Mistral NeMo模型专为全球多语言应用程序而设计。它受过函数调用训练，拥有一个大型上下文窗口，在英语、法语、德语、西班牙语、意大利语、葡萄牙语、中文、日语、韩语、阿拉伯语和印地语方面表现尤为突出。可以说，这是将前沿人工智能模型带到全世界不同语言使用者手中的重要一步。下图是Mistral NeMo 在多语言基准测试中的表现：
Tekken：更高效的分词器 Mistral NeMo使用基于Tiktoken的全新分词器——Tekken，该分词器已针对100多种语言进行训练，并且比以前的Mistral模型中使用的SentencePiece分词器更有效地压缩自然语言文本和源代码。具体而言，在压缩源代码、中文、意大利语、法语、德语、西班牙语和俄语方面的效率提高了约30%；在压缩韩语和阿拉伯语方面的效率也分别提高了2倍和3倍。与Llama 3分词器相比，Tekken在压缩大约85%的所有语言的文本方面表现更为出色。
指令微调 Mistral NeMO 经历了高级微调和调整阶段。与 Mistral 7B 相比，它在遵循精确指令、推理、处理多轮对话和生成代码方面表现得更好。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2b1b37f31f356cdc6cf389c657aa59c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4c9d014c28f7c056383ddd204914a53/" rel="bookmark">
			【机器学习】机器学习解决的问题特点、机器学习学的是什么、怎么学、如何构建高效机器学习模型的策略、机器学习的分类以及机器学习、模式识别、数据挖掘和人工智能的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 机器学习是人工智能的一个重要分支，主要解决的是如何通过算法让机器从数据中自动学习规律和知识，以完成特定任务或解决特定问题。
文章目录 引言一、机器学习解决的是什么样的问题1.2 数据驱动的预测问题1.3 数据理解与挖掘1.4 优化与决策问题1.5 异常检测与风险评估1.6 总结1.7 原因 二、机器学习学的是什么2.1 **数据表示**2.2 **特征提取**2.3 **算法理解**2.4 **模型评估**2.5 **优化技巧**2.6 **实践经验** 三、怎么学机器学习3.1 **理论学习**3.2 **编程实践**3.3 **项目经验**3.4 **持续更新** 四、构建高效机器学习模型的策略4.1 **数据预处理**4.2. **特征工程**4.3. **模型选择**4.4. **超参数调优**4.5. **集成学习** 五、机器学习的分类5.1 按输入空间5.2 按输出空间5.3 按数据标签5.4 按学习策略 六、机器学习、模式识别、数据挖掘和人工智能的区别6.1 人工智能 (Artificial Intelligence, AI)6.2 机器学习 (Machine Learning, ML)6.3 模式识别 (Pattern Recognition)6.4 数据挖掘 (Data Mining)6.5 联系6.6 区别 七、总结（思维导图） 一、机器学习解决的是什么样的问题 机器学习解决的是可以通过数据分析和模式识别来优化决策或预测的问题
1.2 数据驱动的预测问题 分类问题： 邮件是否为垃圾邮件？图像中是否包含某种特定的对象？信用卡交易是否为欺诈行为？ 回归问题： 根据房屋的特征预测房价。根据历史数据预测股票价格。根据病人的医疗记录预测疾病的发展。 时间序列预测： 预测未来的天气情况。预测产品的销售量。预测能源消耗。 1.3 数据理解与挖掘 聚类问题： 将客户分为不同的群体以便进行市场细分。在基因数据中发现不同的表达模式。 降维问题： 从高维数据中提取主要特征以便简化模型。通过PCA或其他降维技术减少数据集的维度。 关联规则学习： 在超市交易数据中发现经常一起购买的商品。分析网页浏览记录以发现用户的兴趣关联。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4c9d014c28f7c056383ddd204914a53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f7fb4d11e94d642e5574480aa34c39f/" rel="bookmark">
			【C&#43;&#43;】位图和布隆过滤器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前面的学习中，我们已经对哈希有了一定的了解。如果还有不认识哈希的可以移步
【C++】哈希表-CSDN博客https://blog.csdn.net/Eristic0618/article/details/140054885?spm=1001.2014.3001.5501今天我们来介绍两个基于哈希思想的数据结构——位图和布隆过滤器
一、位图 位图和哈希的直接定址法很相似，我们先来看一道面试题
有40亿个未排序的不重复的无符号整数，如何快速判断一个数是否在这40亿个数中？
方法1：遍历，时间复杂度为O(N)
方法2：排序后二分查找，时间复杂度为O(N*logN)
这两个方法的时间复杂度看上去都还能接受，但是我们不能用这两个办法，为什么？
限制我们的其实不是时间，而是空间。40亿个整型需要的空间高达14.9G，我们的内存根本开不出这么大的连续空间
如果用红黑树、哈希表，需要的空间那就更多了
因此，我们需要一个空间友好型的结构来解决这个问题，而位图可以完美解决我们的需求。
1.1 概念 我们可以把位图理解为一个位（bit）组成的数组，每个位置只有0或1
实际上位图的确是一个类型为int的数组，不过我们可以把一个int拆分为32个bit位（int类型大小为4字节，也就是32bit）。拆分过后，相同大小的位图能够存储的信息就比数组多了很多。
1.2 思想 例如上面的面试题，首先我们要知道无符号整数的范围为0~4294967295，40亿个无符号整数就分布在这个范围区间内。因此我们不能只开40亿个位的位图，而是要开4294967295个位的位图。
此时有两种情况：一个数在这40亿个数所在的集合中、一个数不在这40亿个数所在的集合中。
我们用这个数在位图中对应的位来判断其状态，如果为0说明不在，为1说明在
位图开好后，我们只需要将存在的数所在的位从0置为1，在查找的时候就可以快速的确定某个数是否包含在这40亿个数所在的集合中。例如整数4在这个集合，那我们就把位图的第5位（第1位对应数字0）从0置为1。
用这种方法，我们所需要的空间就大大减少了，4294967295个bit换算后只有约0.5G的大小。
1.3 实现 了解了位图的概念和思想后，接下来就是如何实现位图了。
前面提到过，我们可以用一个int类型的数组来实现位图，1个int就是32bit
接下来挡在我们面前的唯一阻碍，就是各种位运算操作了（其实并不复杂）
（1）数与位图的映射 要对位图进行操作，首先我们得先找到某个数x在位图中对应的位置
一个int是32bit，所以我们用 i = x / 32 就可以找到这个数对应数组的第 i+1 个整型（下标为 i ）
找到了对应的整型后，我们用 j = x % 32 就可以找到这个数对应该整型的第 j 个bit
例如我们要找34在位图中对应的位置，34 / 32 == 1，即对应数组下标为1处的整型
34 % 32 == 2，即对应该整型的第2位
（2）将0变为1 成功找到了一个数在位图中对应的位置后，我们要知道如何把该位置的0变为1
我们可以使用按位或的特性：有1则为1。例如：
所以要将某个位置的0变为1，我们只需要找到该位置所属的整型，然后用一个"其他位置全为0、该位置为1"的二进制数来按位或这个整型即可
如何得到这个"其他位置全为0、该位置为1"的二进制数呢？通过移位操作即可，例如：
（32位太长了，这里只写出前8位） 需要注意，大端机和小端机中高位和低位在地址中的位置可能不同，但按位左移一定是向高位移动，按位右移一定是向低位移动
前面我们已经知道了该位置是整型中的第 j 位，所以只需要左移 j 位即可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f7fb4d11e94d642e5574480aa34c39f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/126/">«</a>
	<span class="pagination__item pagination__item--current">127/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/128/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>