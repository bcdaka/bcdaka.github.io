<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c43c78fbe8bc97492c3c0bbb39db6b75/" rel="bookmark">
			【C&#43;&#43;进阶学习】第六弹——set和map——体会用C&#43;&#43;来构建二叉搜索树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		set和map基础：【C++进阶学习】第五弹——二叉搜索树——二叉树进阶及set和map的铺垫-CSDN博客
前言：
在上篇的学习中，我们已经学习了如何使用C语言来实现二叉搜索树，在C++中，我们是有现成的封装好的类模板来实现二叉搜索树的——set和map,这也是我们今天要讲的重点
目录
一、容器
二、set和multiset
一、set与multiset概述
二、set与multiset的基本操作
三、高级特性
四、set与multiset的选择
三、map和multimap
1. map与multimap的区别
2. map与multimap的使用场景
3. 基本操作
4. 注意事项
5. 示例代码
四、总结
一、容器 在前面，我们经常提到容器这个东西，比如stack、queue等许多类模板都称之为容器，其实今天要讲的set和map也是容器的一种，容器这个东西我会在下一章进行单独讲解，有兴趣的可以关注一下
二、set和multiset 在C++标准模板库（STL）中，set和multiset是两种关联容器，它们在处理有序集合数据时非常有用。
一、set与multiset概述 set 是一种关联容器，它存储唯一（不重复）的元素，并且这些元素会根据特定的排序规则自动排序。set内部通常采用红黑树实现，保证了元素的对数时间复杂度的插入、删除和查找操作。
multiset 与set类似，但它允许存储重复的元素。multiset同样基于红黑树实现，其操作的时间复杂度特性与set相同。
二、set与multiset的基本操作 在使用set或multiset之前，需要包含相应的头文件：
#include &lt;set&gt; #include &lt;multiset&gt; 以下是一些基本操作：
构造函数： set&lt;T&gt; s; // 默认构造函数 multiset&lt;T&gt; ms; // 默认构造函数 // 可以通过比较函数和分配器进行自定义构造 插入元素： s.insert(key); // set插入元素 ms.insert(key); // multiset插入元素 insert 方法用于向set或multiset中添加元素，如果插入成功，set 的insert方法返回pair&lt;iterator, bool&gt;（这个东西后面会讲），其中bool指示是否插入成功。multiset 的insert方法返回指向插入元素的迭代器。 删除元素： s.erase(key); // 删除特定元素（set） ms.erase(key); // 删除特定元素（multiset） // 删除操作在multiset中会删除所有匹配的元素 查找元素： auto it = s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c43c78fbe8bc97492c3c0bbb39db6b75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41cfa969e32b95f9d4b43a427161daae/" rel="bookmark">
			Python数据分析-Excel和 Text 文件的读写操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Excel和 Text 文件的读写操作 1. Text 文件读写包 import sys print(sys.argv[0]) print(__file__) print(sys.path[0]) q=open(sys.path[0] + "\out.txt","w",encoding='utf-8') q.write('这个是测试一下') q.close() print('done') open 语句可以打开的创建text 文件，存在文件即打开，不存在即创建
注：如文件已存在，使用 open 语句会覆盖原文件生成新文件
1.1 open函数 函数语法：open(name[, mode[, buffering]])
name : 一个包含了你要访问的文件名称的字符串值。mode : mode 决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读®。buffering : 如果 buffering 的值被设为 0，就不会有寄存。如果 buffering 的值取 1，访问文件时会寄存行。如果将 buffering 的值设为大于 1 的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。 例：执行循环生成文本文件
import os import sys print(sys.argv[0]) print(__file__) print(sys.path[0]) fq=open(sys.path[0] + "\out1.txt","w",encoding='utf-8') for i in range(1,1000): fq.write('哈哈'+ str(i)+'\n') fq.close print('done') 2. excel 读写 两个主要的包：openpyxl 和 xlsxwriter
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41cfa969e32b95f9d4b43a427161daae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fe2b4f9d98f66b27a0391202f6700f2/" rel="bookmark">
			【人工智能】Transformers之Pipeline（一）：音频分类（audio-classification）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​​​​​​​
目录
一、引言 二、音频分类（audio-classification）
2.1 概述
2.2 技术原理
2.2.1 Wav2vec 2.0模型
2.2.1 HuBERT模型
2.3 pipeline参数
2.3.1 pipeline对象实例化参数
2.3.2 pipeline对象使用参数 2.4 pipeline实战
2.4.1 指令识别（默认模型）
2.4.2 情感识别
2.5 模型排名
三、总结
一、引言 pipeline（管道）是huggingface transformers库中一种极简方式使用大模型推理的抽象，将所有大模型分为音频（Audio）、计算机视觉（Computer vision）、自然语言处理（NLP）、多模态（Multimodal）等4大类，28小类任务（tasks）。共计覆盖32万个模型
今天介绍Audio音频的第一篇，音频分类（audio-classification），在huggingface库内共有2500个音频分类模型。
二、音频分类（audio-classification） 2.1 概述 音频分类，顾名思义就是将音频打标签或分配类别的任务。主要应用场景有语音情绪分类、语音命令分类、说话人分类、音乐风格判别、语言判别等。
2.2 技术原理 音频分类，主要思想就是将音频的音谱切分成25ms-60ms的片段，通过CNN等卷积神经网络模型提取特征并进行embedding化，基于transformer与文本类别对齐训练。下面介绍2个代表模型：
2.2.1 Wav2vec 2.0模型 Wav2vec 2.0是 Meta在2020年发表的无监督语音预训练模型。它的核心思想是通过向量量化（Vector Quantization，VQ）构造自建监督训练目标，对输入做大量掩码后利用对比学习损失函数进行训练。模型结构如图，基于卷积网络（Convoluational Neural Network，CNN）的特征提取器将原始音频编码为帧特征序列，通过 VQ 模块把每帧特征转变为离散特征 Q，并作为自监督目标。同时，帧特征序列做掩码操作后进入 Transformer [5] 模型得到上下文表示 C。最后通过对比学习损失函数，拉近掩码位置的上下文表示与对应的离散特征 q 的距离，即正样本对。
2.2.1 HuBERT模型 HuBERT是Meta在2021年发表的模型，模型结构类似 Wav2vec 2.0，不同的是训练方法。Wav2vec 2.0 是在训练时将语音特征离散化作为自监督目标，而 HuBERT 则通过在 MFCC 特征或 HuBERT 特征上做 K-means 聚类，得到训练目标。HuBERT 模型采用迭代训练的方式，BASE 模型第一次迭代在 MFCC 特征上做聚类，第二次迭代在第一次迭代得到的 HuBERT 模型的中间层特征上做聚类，LARGE 和 XLARGE 模型则用 BASE 模型的第二次迭代模型提取特征做聚类。从原始论文实验结果来看，HuBERT 模型效果要优于 Wav2vec 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fe2b4f9d98f66b27a0391202f6700f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad30903fba05c08653d9928b40900f2a/" rel="bookmark">
			M3U8工作原理以及key解密视频流详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、M3U8是什么？二、HLS—M3U8的工作原理1.分段视频流2.生成播放列表3.客户端请求和解析4.片段下载和播放 三、.m3u8文件内部是什么样的？四、简单介绍下AES-128算法五、拿到KEY后如何去解密？1.手动解密.ts文件2.前人栽树，后人乘凉3.为什么有的key拿不到？有的能拿到但解密失败？ 前言 之前随手写了一篇文章 某网课平台m3u8 key解密算法分析以及python实现
没想到有那么多的朋友关注，在这里感谢大家的支持。
最近收到不少私信都是关于m3u8解密的问题，沟通的时候发现有很多人对基本概念不是很解。这篇文章将带领大家详细了解下m3u8相关的一些基础知识，希望对大家有所帮助。
废话不多说，下面开始进入正题。
一、M3U8是什么？ 有人说m3u8是一种视频格式，m3u8解密就是去解密m3u8。这种说法是错误的。
m3u8文件是指UTF-8编码格式的M3U文件，它实际上是一个包含多个URL的文本文件，每个URL指向一个音频或视频片段。这些片段可以是分段的，使得流媒体可以按需传输，从而实现自适应码率。m3u8文件通常用于流媒体传输，是HTTP Live Streaming（HLS）技术的一部分（HTTP LiveStreaming）是一种由苹果公司开发的流媒体传输协议，用于在互联网上实时传输音频和视频内容。它的主要特点是将整个视频流切分成短小的ts片段，并使用m3u8播放列表文件指示这些片段的顺序和位置。
不难看出，m3u8其实就是一个播放列表索引文件。
二、HLS—M3U8的工作原理 1.分段视频流 首先，视频流会被分成很多个小的.ts格式的片段。
2.生成播放列表 服务器或生成一个.m3u8文件，其中包含了所有的.ts片段的URL。
3.客户端请求和解析 客户端（浏览器）获取到.m3u8文件后，会解析其中的信息，包括每个.ts片段的持续时间、序列号、以及对应的URL。
4.片段下载和播放 客户端根据解析得到的信息，开始下载第一个.ts片段。通常，客户端会同时下载几个片段来提高播放的流畅性和缓冲性能。
当第一个.ts片段下载完毕后，客户端会开始播放这个片段。同时，客户端会继续下载后续的.ts片段，以确保连续的播放体验。
三、.m3u8文件内部是什么样的？ 当我们使用文本编辑器打开.m3u8文件后，里面可能是这样的：
#EXTM3U #EXT-X-VERSION:3 #EXT-X-TARGETDURATION:10 #EXT-X-MEDIA-SEQUENCE:0 #EXTINF:10.000, http://example.com/video/segment0.ts #EXTINF:10.000, http://example.com/video/segment1.ts #EXTINF:10.000, http://example.com/video/segment2.ts #EXTINF:10.000, http://example.com/video/segment999.ts #EXT-X-ENDLIST 也可能是这样的：
#EXTM3U #EXT-X-VERSION:3 #EXT-X-TARGETDURATION:10 #EXT-X-MEDIA-SEQUENCE:0 #EXT-X-KEY:METHOD=AES-128,URI="https://example.com/keyfile",IV=0x1234567890abcdef1234567890abcdef #EXTINF:10.000, http://example.com/video/segment0.ts #EXTINF:10.000, http://example.com/video/segment1.ts #EXTINF:10.000, http://example.com/video/segment2.ts #EXTINF:10.000, http://example.com/video/segment999.ts #EXT-X-ENDLIST 很明显后者多了一行
#EXT-X-KEY:METHOD=AES-128,URI="https://example.com/enc.key",IV=0x1234567890abcdef1234567890abcdef 其实，它就表示这个.m3u8文件里的视频流片段被加密了。大概意思是：
使用AES-128算法加密，KEY被存放在https://example.com/enc.key里 ，IV是0x7d5f0881be55ce4a3f2b8d811de877db
四、简单介绍下AES-128算法 AES-128是一种加密算法，存在很多种模式如：ECB、CBC、CTR等。
在加密视频流里常见的就是CBC模式，这个模式的特征是使用KEY（密钥）和IV（初始化向量）去加密数据。通常KEY和IV的长度都是128比特（bit）也就是16字节（byte）。
例如：我们使用AES-128-CBC算法加密 hello csdn 这句话。首先我们需要自行设置一组key和iv。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad30903fba05c08653d9928b40900f2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5133cc08c481c4f2cbccf7c2b0a32bc5/" rel="bookmark">
			数据结构第一关---- 复杂度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初阶数据结构第一关---- 复杂度 什么是数据结构？ 我们之前已经学习过数组相关的概念，这里举个例子：
int a=10; //我们需要定义1000个整型变量数组 int arr[1000]; //如果我们要进行更改的话，可以这样做 int arr[i]=100; 同理，数据结构就是对数据进行管理。
概念：数据结构(Data Structure)是计算机存储、组织数据的⽅式，指相互之间存在⼀种或多种特定关系的数 据元素的集合。没有⼀种单⼀的数据结构对所有⽤途都有⽤，所以我们要学各式各样的数据结构， 如：线性表、树、图、哈希等
算法的概念：算法(Algorithm):就是定义良好的计算过程，他取⼀个或⼀组的值为输⼊，并产⽣出⼀个或⼀组值作为 输出。简单来说算法就是⼀系列的计算步骤，⽤来将输⼊数据转化成输出结果。
数据结构好比是一个收纳整齐的容器，算法好比是取得想要东西的统筹方法，所以说数据结构和算法不分家
引入一个例子：如何衡量算法好坏 轮换数组 给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。
示例 1:
输入: nums = [1,2,3,4,5,6,7], k = 3 输出: [5,6,7,1,2,3,4] 解释: 向右轮转 1 步: [7,1,2,3,4,5,6] 向右轮转 2 步: [6,7,1,2,3,4,5] 向右轮转 3 步: [5,6,7,1,2,3,4] 示例 2:
输入：nums = [-1,-100,3,99], k = 2 输出：[3,99,-1,-100] 解释: 向右轮转 1 步: [99,-1,-100,3] 向右轮转 2 步: [3,99,-1,-100] 思路：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5133cc08c481c4f2cbccf7c2b0a32bc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc84557a8fb58ef1ba69468a4254edcc/" rel="bookmark">
			Bugku---web---速度要快
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目出处：首页 - Bugku CTF
✨打开链接，看到如下界面！！！
✨没有什么想法后直接抓包！！！
✨看到Cookie，像是一串加密的字符串，下面进行解密！！！发现不是一个加密字符串，所以查询cookie这个关键字的作用后发现！！！
Cookie: 这是一个HTTP头字段的名称，用于在客户端（如浏览器）和服务器之间传递小块数据。这些数据通常用于识别用户、跟踪会话或存储用户首选项。PHPSESSID: 这是Cookie的名称。在PHP中，当您开始一个会话（使用session_start()函数）时，PHP通常会设置一个名为PHPSESSID的Cookie（除非您更改了默认的会话名称）。这个Cookie的值（在这里是pqhqpqo2eblephf91j7vk83203）是一个会话标识符，用于唯一地标识一个会话。pqhqpqo2eblephf91j7vk83203: 这是PHPSESSID Cookie的值，是一个随机生成的字符串。这个值用于在服务器上识别特定的用户会话。当用户在多个页面之间导航时，浏览器会发送这个Cookie，以便服务器能够识别用户并恢复他们的会话状态（例如，他们登录的用户名、购物车中的物品等）。 ✨将此消息发送给服务器查看所给的响应是什么！！！
✨发现里面有flag，但是是一种编码形式，下面是解密过程！！！
✨结果不是正确答案，再试着解码一次！！！
✨还是不行，回头看看！！！
✨说到一段英语，大概是要提交你的margin值，根据前面所写的步骤，margin的值显然就是你解码后得到的数字！！！
✨关键来了，快速给系统给定margin的值还是没有任何结果，只能换一种解题思路了，写python脚本，将其逼出原形！！！
✨这是python脚本，运行后即可得到flag的值！！！（下面我展示的网址是又一次打开的环境，故与前述略有不同，但无影响）
import requests //导出requestes模块 import base64 //导出base64模块进行解码 url="http://114.67.175.224:13636" //将url这个变量定义成我们要访问我网址 s=requests.session() //导出session模块并赋值给s；因为网页是动态的 r1=s.get(url) //用session模块想url定义的这个网站发出一个get请求，并且赋值给r1 decoded_flag = base64.b64decode(r1.headers['flag']).decode('utf-8') flag1= decoded_flag.split(":")[1] //base64对r1响应头中的flag进行解码并且赋值给flag1 flag2= base64.b64decode(flag1) //因为解码没有彻底所以对flag1进行二次解码；并且赋值给flag2 data={'margin':flag2} //就是把解好码的flag2定义给margin；再将整体赋值给data r2=s.post(url,data=data) //通过session向url定义的网站进行post请求，上传刚刚定义好的data print(r2.text) //然后输出r2的网页显示内容 ✨这是第二种python运行脚本的方法，但是两者差不多，我认为第二种更为简便！！！
# 导入requests库和base64库 import requests import base64 # 定义目标URL url = "http://114.67.175.224:11910" # 创建一个requests.Session对象，用于保持会话状态 req = requests.Session() # 使用Session对象的get方法向URL发起GET请求，并将响应存储在res变量中 res = req.get(url) # 从响应头中获取名为'flag'的值，该值是一个经过两次base64编码的字符串 encoded_flag = res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc84557a8fb58ef1ba69468a4254edcc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dee763f6942448f611b7f289184fd792/" rel="bookmark">
			【C&#43;&#43;】哈希表的模拟实现及 unordered_set 和 unorderded_map 的封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、哈希表的模拟实现1.1 哈希表的改造1.1.1 模板参数列表的改造1.1.2 增加迭代器操作 1.2 哈希表的模拟实现1.2.1 哈希表中仿函数的实现1.2.2 哈希表中节点类的实现1.2.3 哈希表中迭代器类的实现1.2.4 哈希表中构造函数、析构函数和 Clear() 函数的实现1.2.5 哈希表中Swap 和 Size 函数的实现1.2.6 哈希表中 begin 和 end 函数的实现1.2.7 哈希表中 Find 函数的实现1.2.8 哈希表中 Insert 和 Erase 函数的实现1.2.9 哈希表的整体实现 二、unordered_set的实现及测试三、unordered_map的实现及测试结尾 前言 上一篇文章中讲到了哈希的概念和STL中关于哈希容器的使用，并且在后面对开散列进行了模拟实现，那么在这一篇文章中在开散列的基础上进行改造成哈希表，并且在哈希表的基础上封装 unordered_set 和 unordered_map。
一、哈希表的模拟实现 1.1 哈希表的改造 1.1.1 模板参数列表的改造 K：表示关键码类型
T：不同容器V的类型不同，如果是unordered_map，K代表一个键值对，如果是unordered_set，T 为 K。
KOfT： 因为V的类型不同，通过value取key的方式就不同，详细见
unordered_map/set的实现
HF: 哈希函数仿函数对象类型，哈希函数使用除留余数法，需要将Key转换为整形数字才能取模
template&lt;class K, class T , class KOfT , class HF&gt; class hash_table; 1.1.2 增加迭代器操作 // 前置声明，否则后面的__HTIterator找不到hash_table template&lt;class K, class T, class KOfT, class HF&gt; class hash_table; template&lt;class K, class T , class Ref, class Ptr, class KOfT, class HF&gt; struct __HTIterator { typedef HashNode&lt;T&gt; Node; typedef __HTIterator&lt;K, T, Ref , Ptr , KOfT, HF&gt; self; // 成员变量 Node* _node; // 由于const迭代器中const修饰this // 所以这里需要加const，否则会导致权限放大 // 编译无法通过的情况 const hash_table&lt;K, T, KOfT, HF&gt;* _pht; // size_t hashi; // 构造函数 __HTIterator(Node* node, hash_table&lt;K, T, KOfT, HF&gt;* pht , size_t i) :_node(node) ,_pht(pht) ,hashi(i) {} // 构造函数 __HTIterator(Node* node, const hash_table&lt;K, T, KOfT, HF&gt;* pht, size_t i) :_node(node) , _pht(pht) , hashi(i) {} self&amp; operator++() { if (_node-&gt;_next) { // 若当前桶其他节点没有走完 // 那么继续走下一个节点 _node = _node-&gt;_next; } else { // 若当前桶的所有节点都已经走完 // 那么继续向下一个桶不为空的桶走 hashi++; while (hashi &lt; _pht-&gt;_table.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dee763f6942448f611b7f289184fd792/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab5cb70f28fa381face8b3f2ee173f80/" rel="bookmark">
			【微信小程序知识点】转发功能的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转发功能，主要帮助用户更流畅地与好友分享内容与服务。
想实现转发功能，有两种方式：
1.页面js文件必须声明onShareAppMessage事件监听函数，并自定义转发内容。只有定义了此事件处理函数，右上角菜单才会显示“转发”按钮。
2.通过给button组件设置属性open-type="share",可以在用户点击按钮后触发Page.onShareAppMessage事件监听函数。
（1）cate.js
Page({ // 监听页面按钮的转发以及右上角转发按钮 onShareAppMessage() { return { title: "这是一个非常神奇的页面~~~", path: "/pages/cate/cate", imageUrl: "../../assets/useryuxin.jpg", }; }, }); （2）cate.wxml
&lt;button open-type="share"&gt;转发&lt;/button&gt; （3）cate.wxss
button { margin-top: 200rpx; } 效果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83b795a58f549919e2227f082a08215e/" rel="bookmark">
			JavaWeb（四：Ajax与Json）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Ajax 1.定义 Ajax（Asynchronous JavaScript And XML）：异步的 JavaScript 和 XML
AJAX 不是新的编程语言，指的是⼀种交互方式：异步加载。
客户端和服务器的数据交互更新在局部页面的技术，不需要刷新整个页面 --&gt; 局部刷新。
优点：
① 局部刷新，效率更高
② 用户体验更好
2.原理 3.基于 jQuery 的 AJAX 语法 $.ajax({
属性，
})
常用的属性参数：
url请求的后端服务地址type请求方式，默认 getdata请求所携带的参数dataType服务器返回的数据类型：text / jsonsuccess请求成功的回调函数error请求失败的回调函数complete请求完成的回调函数（无论成功或者失败，都会调用） &lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input id="text" type="text"/&gt;&lt;br/&gt; &lt;input id="btn" type="button" value="提交"/&gt; &lt;script type="text/javascript"&gt; $(function () { var btn = $("#btn"); btn.click(function () { $.ajax({ url: '/test', type: 'post', data: 'id=1', dataType: 'text', success: function (data) { var text = $("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83b795a58f549919e2227f082a08215e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2369b7a05ebfc8b9a0d8fa25663b8721/" rel="bookmark">
			【Hadoop集群搭建】完全分布式 Hadoop 安装部署及测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 集群安装配置完整过程 a) 3 台客户机（关闭防火墙、设置好IP、主机名、时钟同步等信息在之前发布的博客有）
1
2
3
虚拟机
Hadoop100
Hadoop101
Hadoop100
主机名
Hadoop100
Hadoop101
Hadoop100
IP地址
192.168.9.10
192.168.9.11
192.168.9.10
Hdfs
NameNode
DataNode
DataNode
SecondaryNameNode
DataNode
yarn
NodeManager
ResourceManager
NodeManager
NodeManager
b) 分别安装 JDK 并配置环境变量 c) 安装 Hadoop 并配置环境变量 d) 配置 SSH 免密钥通信 e) 配置集群 f) 群起集群并测试 建议先配置xsync集群分发脚本！！这样只需要在一台虚拟机修改，之后通过脚本分发给另外两台虚拟机即可。
参考我写的另一篇博客：
【Hadoop集群搭建】xsync集群分发脚本-CSDN博客
————————————————
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 原文链接：https://blog.csdn.net/m0_67830223/article/details/139803036
2. 配置 SSH 免密钥通信 ssh 基本用法，输入以下命令测试（注意使用自己配置的主机名和 IP 地址）
​​​​​​​ssh 192.168.9.10 SSH 免密钥配置具体步骤 步骤 1：进入.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2369b7a05ebfc8b9a0d8fa25663b8721/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65d35a44e85e4f448f044d2b08093a85/" rel="bookmark">
			你也想做一个Element-ui吧！！！——Blueの前端路（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言：
父子组件
button组件
使用vue脚手架初始化一个项目
如何封装，注册和使用一个组件
main.js中将组件设置为全局
使用
此组件我们所需实现的内容
type
父组件组件传递type属性
子组件接收负组件传递的数据
通过绑定类名的方法动态控制样式
设置不同类型的样式
plain属性
父组件组件传递plain值
子组件接收负组件传递的数据，同样进行props校验，并且设置默认值为false
通过绑定类名的方法动态控制样式，由于plain类型是布尔值，所以在类型中我们使用对象的形式来控制样式
设置不同类型的样式，由于plain类型是以对象的形式在类中定义的，所以使用获取属性的方法定义样式
round
父组件传递round值
子组件获取属性值:
round样式
子组件设置该选择器
circle
button组件中使用字体图标
第一步： 在main.js中引入字体图标
第二步：父组件传递图标名，子组件接收并且放到图标中
父组件传值：
子组件接收：
使用接收到的字体图标。在没有传入icon时隐藏标签，在slot插槽没有传入值时，不显示标签
设置icon配套样式，使图标和文字之间有一定间隔
button组件中的点击事件
组件中的定义点击事件：
定义一个点击事件，这个点击事件的作用是调用父组件中的点击事件，并且回调
父组件在使用时定义自己的点击事件，其本质是子组件中的点击事件触发父组件中的点击事件。
结尾
前言： 又到了暑假了，俺最近想做一个属于自己的组件库类似Element-ui这样的东东，奈何本人也是一名新手，没有那么强的前端功力，所俺就边学边记录自己的学习过程，将自己的笔记和所遇到的问题写成csdn的文章，一是为了分享笔记，让更多朋友们能够轻松学习，二是在写笔记的途中，也可以总结提高。以下是我所观看的视频：
http://【VUE进阶-从0到1搭建UI组件库（1-3）】https://www.bilibili.com/video/BV1nJ411V75n?p=7&amp;vd_source=bb412cc25ca27e171f8e17085daad038
父子组件 父组件：为你所写的页面，该页面需要引入其他组件所以为父组件
子组件：你所写的能够被引用到其他页面的东东
button组件 使用vue脚手架初始化一个项目 使用vue created one-ui，创建一个名为one-ui的项目。
按照自己的习惯设置脚手架风格，这里不多做介绍。
脚手架搭建完毕后，将App.vue文件下的自带内容清理一下，为后续开发做准备。
如何封装，注册和使用一个组件 在componet下创建一个button.vue的文件，放置button组件代码。创建一个组建的button组件，，并且指定name为WssButton（按照自己想法来取名）。 &lt;template&gt; &lt;button class="wss-button"&gt; 按钮组件 &lt;/button&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'WsButton' } &lt;/script&gt; &lt;style lang="scss"&gt; &lt;/style&gt; main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65d35a44e85e4f448f044d2b08093a85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eea91ca94474f54fb22370f2c1548123/" rel="bookmark">
			6-7 宠物领养开发及相关代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		6-7 宠物领养开发及相关代码（react+区块链实战） 来到ant-design https://ant.design/index-cn https://ant.design/components/layout-cn/
来到布局
选择一个简单的布局即可
会显示出所有的相关界面的代码
根据对应界面的代码在我们的react项目woniu-pet-shop中的App.js中进行更改
如下
刷新页面的效果如下
页面的基本雏形如下
要做宠物的领养，就要将宠物的数组拿出来
在前面下载的petshop改名为truffle中放在了react项目下的src下的petsjson
这是宠物的术语名字图片
在区块链中写图片非常昂贵，大部分情况下在区块链中写id或者一些出生时间关键数据
将宠物的json直接引入
然后在项目中的render中的content直接引入
Pets类似数组，在init初始化时就有加一下东西
将truffle下的src下的狗的图片复制出来
放在react项目下的public下的images中
使用ant中的栅格系统，使用页面整个横向布局
可以将前面引入的Jason数组渲染出来
所有宠物名打印出来了
接下来将其图片也打印出来
在App.css中加入图片的宽度使其看起
现在好看多了
总共16个宠物，看起来和谐多了
重点低下逻辑，显示名字后要有领养按钮，不一定存在的，如刚才第一个，第2个已经领养过了，应显示已被领养
//判断当前宠物是否被领养(是否当前的领养地址为初始地址) isActive(i){ return this.state.adopters[i] == this.initAddress } 若未被领养，显示领养的按钮，若已领养就显示被领养的字样
基本功能已经完成再加入按钮的事件即可，以及加入class center使其居中，type样式为蓝色的
如下
在css中加入居中的样式
核心就是如何编写智能合约，测试合约，如何web端和智能合约交互
App.js所有代码如下
import React from 'react' import Web3 from 'web3' import TruffleContract from 'truffle-contract' import AdoptionJson from './truffle/build/contracts/Adoption.json'	//引入前面智能合约编译好得到的json文件 import { Button } from 'antd' import { Layout, Menu, Breadcrumb } from 'antd' import { Row, Col } from 'antd' import '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eea91ca94474f54fb22370f2c1548123/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a06c788f0ca5ead3ba1b90c356c07c35/" rel="bookmark">
			C&#43;&#43; --＞ 类和对象(二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在前面简单的介绍了OOP，什么是类，在类中的this指针。接下来就深入理解类和对象。
默认成员函数 默认构造函数：用于在创建对象时初始化对象的成员变量。默认拷贝构造函数：用于使用已存在的对象来初始化新创建的对象。默认析构函数：在对象生命周期结束时执行清理操作，通常是删除动态分配的资源。默认重载赋值运算符：用于将一个对象的值赋给另一个已存在的对象。默认移动构造函数（C++11及以后版本）：用于将资源从一个对象转移到另一个对象，而不是复制这些资源。默认重载移动赋值操作符（C++11及以后版本）：用于将一个对象的资源移动到另一个已存在的对象 ​ 接下来就依次介绍默认成员函数
一、构造函数 构造函数的特性 构造函数类似于初始化函数，在写Stack时候，首先需要初始化Stack。
构造函数并不是开辟空间创建对象，而是初始化
函数名与类名相同无返回值对象实例化时编译器自动调用构造函数构造函数可以重载 class Date { public: //构造函数 Date()	//无参构造函数 { } Date(int year , int month , int day ) //带参构造函数 { _year = year; _month = month; _day = day; } void Print() { cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl; } private: int _year; int _month; int _day; }; int main() { Date d0;//调用无参数构造 初始化的值是随机值 Date d1(2024, 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a06c788f0ca5ead3ba1b90c356c07c35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01485598978658a65702eb1ffa20c78d/" rel="bookmark">
			SpringBoot统一功能处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、统一数据返回格式
测试
二、存在问题
解决方案
案例代码修改
三、统一功能的优点
四、统一异常处理
五、案例代码（图书管理系统）
1、login.html
2、book_update.html
3、book_add.html
4、book_list.html
六、总结
上一篇博客使用了拦截器，强制登录案例做了两步：1、通过Session来判断用户是否登录；2、如果未登录，对后端返回数据进行封装，告知前端处理的结果。
但是因为刚开始的图书管理系统的接口返回的不是Result类，我们现在想把后端接口返回的类型都改成Result，那么就可以使用SpringBoot的第二个统一功能处理。
一、统一数据返回格式 统一的数据返回格式使用 @ControllerAdvice 和 实现ResponseBodyAdvice接口 的方式实现，@ControllerAdvice 表示控制器通知类。
添加类 ResponseAdvice，实现 ResponseBodyAdvice 接口，并在类上添加 @ControllerAdvice 注解，代码如下：
@ControllerAdvice public class ResponseAdvice implements ResponseBodyAdvice { @Override public boolean supports(MethodParameter returnType, Class converterType) { return true; } @Override public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) { return Result.success(body); } } supports() 方法：判断是否要执行 beforeBodyWrite 方法。true 为执行，false为不执行。通过该方法可以选择哪些类或哪些方法的 response 要进行处理，其他的不进行处理。如图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01485598978658a65702eb1ffa20c78d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/756c91b774e6b4277ae062049cf44ecb/" rel="bookmark">
			【uniApp】实现列表下拉触底加载更多功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;scroll-view :style="'height:' + scrollViewH + 'px;'" scroll-y="true" @scrolltolower="onReachLower"&gt; &lt;uni-collapse ref="collapse" v-model="value" v-for="el in listData" :key="el.id"&gt; &lt;uni-collapse-item :title="el.stationname" titleBorder="none"&gt; &lt;view class="info-content" @click="showInfo(el)"&gt; &lt;p&gt;{{el.warntime}} &amp;nbsp;&amp;nbsp;{{el.warninfo}}&lt;/p&gt; &lt;/view&gt;	&lt;/uni-collapse-item&gt; &lt;/uni-collapse&gt; &lt;uni-load-more v-if="showLoadMore" :status="loadStatus" :content-text="contentText"&gt;&lt;/uni-load-more&gt; &lt;/scroll-view&gt; export default { data() { return { params: { pageNum: 1, // 页码 pageSize: 10 // 条数 }, listData: [], // 当前页列表数据 // 下拉加载 allListCount: 0, // 列表总数 allListData: [], // 列表所有数据 scrollViewH: 0, // 列表滚动区域 showLoadMore: false, loadStatus: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/756c91b774e6b4277ae062049cf44ecb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9e942647b3c3fc2907ffbc18e863f9a/" rel="bookmark">
			在Mac上一键安装Mysql（解决所有安装问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重点强调安装mysql成功的关键在于安装的版本不能是最新！！
目录 一：下载mysql数据库安装部分到此结束 二：配置mysql数据库三：启动mysql数据库四：各类奇葩问题总结 一：下载mysql数据库 1.进入MySQL官方网站，点击跳转到官网，按下图顺序点击进入下载页面。
2.进入Downloads页面后，下滑页面选择MySQL Community （GPL） Downloads »
3.进入页面后，点击MySQL Community Server
4.按照图片选择对应的版本(8.0)、系统(macOS)和处理器(ARM)
特别注意不要下载最新版本，后期配置会出现不可控的问题（如端口号为0，密码不对等问题）， 下载8.2.0的即可
6.点击No thanks, just start my download.进行下载
7.打开安装包，一直点击继续无脑安装，在Configuration安装页面中选择第一种设置密码方式，并点击Next
8.在进入下一个页面后，设置Mysql登录密码,之后点击Finnish完成安装
9.打开系统偏好设置，点击Mysql出现此画面则证明安装成功
安装部分到此结束 二：配置mysql数据库 1.首先在我们的设备上找到终端并打开,输入 vim ~/.bash_profile(注意vim后面的空格)，输入完成后点击回车键(Enther)
2.点击回车键后会出现此画面，此时按下键盘上的“ e ”键进行编写,输入 export PATH=$PATH:/usr/local/mysql/bin
3.按下Esc键，输入 :wq (“ ： ”也要输入)，按下回车键进行保存
4.输入 source ~/.bash_profile 使此文本生效 (注意source后面的空格)，按下回车
注意：后期出现mysql commond not fond 都需要再次执行这一句话
5.此时输入 mysql --version 可以查看Mysql安装的版本，此时环境配置完成
三：启动mysql数据库 输入 mysql -u root -p 启动mysql，输入安装时的密码，出现此页面代表成功
至此成功启动
四：各类奇葩问题 出现：ERROR 1045 (28000): Access denied for user ‘root‘@‘localhost‘ (using password: YES) 说明出现了密码错误问题，但是密码确实没输错，参考这篇博客解决 点击跳转Mac下Mysql端口为0的问题 点击跳转无法卸载Mysql ，博客参考 点击跳转 总结 本期教程到此结束，欢迎各位大佬斧正🧍‍♂️，如有问题请评论留言，感谢大家支持🙏
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95a4a0e3cfc46d363419fcce98451fd5/" rel="bookmark">
			【C&#43;&#43;航海王：追寻罗杰的编程之路】一篇文章带你认识哈希
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 -&gt; unordered系列关联式容器
1.1 -&gt; unordered_map
1.1.1 -&gt; unordered_map的文档介绍
1.1.2 -&gt; unordered_map的接口说明
1.2 -&gt; unordered_set
2 -&gt; 底层结构
2.1 -&gt; 哈希概念
2.2 -&gt; 哈希冲突
2.3 -&gt; 哈希函数
2.4 -&gt; 哈希冲突解决
2.4.1 -&gt; 闭散列
2.4.2 -&gt; 开散列
3 -&gt; 模拟实现
3.1 -&gt; 哈希表的改造
3.2 -&gt; unordered_map
3.3 -&gt; unordered_set
1 -&gt; unordered系列关联式容器 在C++98中，STL提供了底层为红黑树结构的一系列关联式容器，在查询时效率可达到O(n)，即最差情况下需要比较红黑树的高度次，当树中的节点非常多时，查询效率也不理想。最好的查询是进行很少的比较次数就能将元素找到，因此在C++11中，STL又提供了4个unordered系列的关联式容器，这四个容器与红黑树结构的关联式容器使用方式基本类似，只是其底层结构不同。
1.1 -&gt; unordered_map 1.1.1 -&gt; unordered_map的文档介绍 unordered_map文档说明 unordered_map是存储&lt;key，value&gt;键值对的关联式容器，其允许通过keys快速的索引到与其对应的value。在unordered_map中，键值通常用于唯一地标识元素，而映射值是一个对象，其内容与此键关联。键和映射值的类型可能不同。在内部unordered_map没有对&lt;key，value&gt;按照任何特定的顺序排序，为了能在常数范围内找到key所对应的value，unordered_map将相同的哈希值的键值对放在相同的桶中。unordered_map容器通过key访问单个元素要比map快，但它通常在遍历元素子集的范围迭代方面效率较低。unordered_map实现了直接访问操作符(operator[])，它允许使用key作为参数直接访问value。它的迭代器至少是前向迭代器。 1.1.2 -&gt; unordered_map的接口说明 1. unordered_map的构造
函数声明功能介绍unordered_map构造不同格式的unordered_map对象 2. unordered_map的容量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95a4a0e3cfc46d363419fcce98451fd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93bb7985fe28ee559e402b528179ba65/" rel="bookmark">
			【Quart 框架——来源于Flask的强大且灵活的异步Web框架】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、Quart简介1-1、简介1-2、与flask的区别 二、快速开始2-1、安装2-2、基本用法 三、核心功能3-1、异步路由3-2、WebSockets 支持3-3、中间件3-4、蓝图 (Blueprints) 四、部署4-1、使用uvicorn部署4-2、使用hypercorn部署 五、案例分析总结 前言 Quart 是一个基于 Python 的异步 Web 框架，灵感来自 Flask。它结合了 Flask 的易用性和成熟度，并添加了对 Python 异步特性的支持。 一、Quart简介 1-1、简介 Quart 是一个基于 Python 的异步 Web 框架，灵感来自 Flask。它结合了 Flask 的易用性和成熟度，并添加了对 Python 异步特性的支持。使用Quart你可以：
渲染和提供HTML模板构建Json API服务WebScoket流式请求、响应。 Quart 旨在提供一个类似于 Flask 的简单且灵活的 Web 框架，同时支持 Python 的异步功能（async 和 await）。这使得 Quart 能够处理高并发和异步 I/O 操作，适用于需要处理大量并发连接的应用程序，如实时 Web 应用和微服务。
1-2、与flask的区别 异步支持：Quart 的最大特点是对异步操作的支持，而 Flask 主要是同步的。WebSockets：Quart 内置对 WebSockets 的支持，而 Flask 需要使用 Flask-SocketIO 扩展。路由定义：Quart 的路由定义和 Flask 基本一致，但 Quart 的路由处理函数可以是异步的。 二、快速开始 2-1、安装 安装： python的版本必须大于3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93bb7985fe28ee559e402b528179ba65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1071f8c730b2d606e64cc41eef6bb4d/" rel="bookmark">
			IDEA 中的调试方式(以 java 为例)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 IDEA 中的调试方式(以 java 为例)1. 基本介绍2. 断点调试的快捷键2.1 设置断点并启动调试2.3 快捷键 IDEA 中的调试方式(以 java 为例) 在开发中查找错误的时候，我们可以用断点调试，一步一步的看源码执行的过程，从而发现错误所在。
重要提示： 在断点调试过程中，是以对象的运行状态来执行的。
1. 基本介绍 断点调试是指在程序的某一行设置一个断点，调试的时候，程序运行到这一行就会停住，然后我们可以一步一步的往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，并停下。进行分析，从而找出Bug 的位置。断点调试是程序员必须要掌握的技能。断点调试也可以让我们查看 java 源代码的运行过程，通过阅读 java 的源码，也可以提高我们的 java 水平。 2. 断点调试的快捷键 2.1 设置断点并启动调试 首先，我们来设置断点，在代码左边的行号附近点击鼠标左键,出现一个红色的圆点，说明断点设置完成。
第二步，启动调试。在代码空处，单击鼠标右键，选择下图的 Dbug,即开始了调试。
在底部出现调试界面：
2.3 快捷键 F7 ： 跳入方法内Alt + shift + F7 ： 强制进入方法内 在有些时候，我们单独按 F7 可能无法进入 java 的源码之中，有2种解决方式：
使用 Alt + shift + F7 ： 强制进入方法内。在 settings 中设置，按如下步骤： 取消勾选，java.* 和 javax.*，然后点击 Apply 应用。
shift + F8 ： 跳出方法F8 ： 逐行执行代码F9 : 执行到下一个断点 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff9e3795375802b8b2650b423ba6636b/" rel="bookmark">
			Objective-C 自定义渐变色Slider
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前情概要二、具体实现 一、前情概要 系统提供UISlider，但在开发过程中经常需要自定义，本次需求内容是实现一个拥有渐变色的滑动条，且渐变色随着手指touch的位置不同改变区域，类似如下
可以使用CAGradientLayer实现渐变效果，但是发现手指滑动的快时会有不跟手的情况。我们可以重写左侧有渐变色的UIView的drawRect: 方法来绘制渐变色
二、具体实现 左侧的渐变色UIView
HLProgressView.h
@interface HLProgressView : UIView @property (nonatomic, assign) CGSize viewSize; @end HLProgressView.m
@implementation HLProgressView - (instancetype)initWithFrame:(CGRect)frame{ self = [super initWithFrame:frame]; if (self) { } return self; } - (void)setViewSize:(CGSize)viewSize { _viewSize = viewSize; self.frame = CGRectMake(0, 0, viewSize.width, viewSize.height); // setNeedsDisplay会自动调用drawRect方法 [self setNeedsDisplay]; } - (void)drawRect:(CGRect)rect { CGSize size = self.bounds.size; // 获取图形上下文对象CGContextRef CGContextRef context = UIGraphicsGetCurrentContext(); // 创建一个颜色空间 CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); // 设置的颜色 每四个元素表示一种颜色，值的范围0~1，分别表示R、G、B、透明度 CGFloat colors[] = { 55.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff9e3795375802b8b2650b423ba6636b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/161/">«</a>
	<span class="pagination__item pagination__item--current">162/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/163/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>