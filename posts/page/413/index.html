<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae1a15915dda6e4f9c15f58f64fc7063/" rel="bookmark">
			AI绘画工具Stable Diffusion，手把手教你快速制作角色三视图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“ 本文介绍SD生成三视图的几种方法：提示词直接输出、三视图LoRa微调和OpenPose控制骨架，其中openpose出图最稳定。三视图是电商模特和游戏角色作图的必备技能。让我们尽快掌握此商业变现能力……”
之前给大家安利过SD跟MJ最大不同之处，就是控图能力。
SD利用插件controlnet可实现精准出图，这是实现稳定变现的基础。
今天给大家介绍另外一种模型，叫做openpose，字面理解跟姿势有关。
下面给大家先看看一个成品图：
01、工具准备 工欲善其事必先利其器，首先准备好stable diffusion webui和插件
02、案例讲解 打开stable diffusion webui文生图
主模型选择： deliberate_v3.safetensors
LoRa模型选择： CharTurnerBeta
下载地址： https://civitai.com/models/7252?modelVersionId=8527 （如无法下载请看文末扫描获取）
Controlnet模型选择openpose：control_v11p_sd15_openose
尺寸参数选择： 宽880高512，其他参数默认。
直接输入提示词：
(white background:1.5),A photographic style character turnaround of a an 1800’s flamboyant pirate captain with a big feather in his hat and a peg leg. Parrot, eyepatch, mustache, grin, highly detailed face. Multiple views of the same character in the same outfit,``lora:mw_charturn3:0.4 charturnbetalora
未开启controlnet之前生成的三视图：
打开controlnet界面，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae1a15915dda6e4f9c15f58f64fc7063/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5222c0d59f4a64f467fadd2a4e05435a/" rel="bookmark">
			AI绘画Stable Diffusion，手把手教你反推提示词
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“ AI绘画，学会生成卡通人物的工具后，通过一些高级提示词，就能生成质量不错的图片，掌握个人快速变现能力……”
经常在小红书或其他公众号上看到别人家的图片内容很高级，等自己去写提示词又提笔忘字。
不是因为你英文不好，主要是没有具体概念。有没有工具可以一键获取别人的提示词？
有，今天给大家分享一个反推提示词插件，手把手教你如何写出高级提示词又不费力。
图1、别人家的图片
01、工具准备 打开SDW扩展界面，点击从网址安装，输入WD1.4标签器的插件地址，点击install进行安装。
可关注上方“郑在创新”公众号，回复关键字“常用插件”，可获得一些常用插件地址。
图2、SDW的扩展界面
SDW的具体安装可看我往期入门教程-AI绘画工具Stable Diffusion 新手入门教程，附安装包
02、案例讲解 安装完插件后，打开SDW界面，点击WD1.4标签器，上传别人家的图片，点击反推。
图3、WD1.4标签器的界面
1 girl, solo, bag, shirt, hair bun, perfect hand,Five fingers,white shirt, earrings, jewelry, sunglasses,` `double bun, holding bag, short sleeves, blurry background,` `black hair, skirt, blurry, parted lips, brown hair,` `cowboy shot, black pants, lips, pants, black skirt, black bag
推出提示词后，点击发送到文生图，自动切换到文生图界面，调整相关参数，反向提示词，采用下方通用提示词，点击生成。
(worst quality, low quality:2), NSFW,monochrome, zombie,overexposure, watermark,text,bad anatomy,bad hand,((extra hands)),extra fingers,too many fingers,fused fingers,bad arm,distorted arm,extra arms,fused arms,extra legs,missing leg,disembodied leg,extra nipples,` `detached arm, liquid hand,inverted hand,disembodied limb,` `oversized head,extra body,extra navel,easynegative,(hair between eyes),sketch, duplicate, ugly, huge eyes, text, logo, worst face, (bad and mutated hands:1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5222c0d59f4a64f467fadd2a4e05435a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f84827f1de1efa47102ec0ac354416e9/" rel="bookmark">
			《管理世界》|【数据复现】人工智能如何提升企业生产效率？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间跨度：2007-2022年
区域范围：上市公司
注:参考本篇论文的做法，在收集上市公司的样本数据时，进行了如下处理：
剔除了金融行业公司剔除了信息传输、软件和信息技术服务业以及科学研究和技术服务行业剔除当年处于 ST 和*ST 状 态的样本 指标说明：
本文选取的变量如以下数据指标体系所示：
注：在本数据集中，非常规高技能劳动力表示为上市公司的研发人员占公司总体员工的比重（%），常规低技能劳动力则表示为100%-非常规高技能劳动力。本数据集将收集到的四个季度的托宾Q的值取算数平均后，做为了企业价值的替代变量。
本数据在收集过程中，研发人员占企业总员工人数数据并不完整，所以非常规高技能劳动力与常规低技能劳动力数据在部分企业和年份存在缺失。
此外，本数据集在进行上市公司年报以及MD&amp;A中人工智能词频分析时，选取的人工智能词典也列示如下。
变量名称
变量符号
变量描述
全要素生产率
TFP
根据奥利和帕克斯(1996)的方法计算
年报人工智能关键词词频
Lnwords
上市公司年报中人工智能关键词数量加1,取自然对数
年报中MD&amp;A部分人工智
能关键词词频
Lnwords_MD&amp;A
上市公司年报中MD&amp;A部分人工智能关键词数量加1,取自然对数
人工智能专利数量
Lnpatent
上市公司当年申请的人工智能专利数量加1,取自然对数
常规低技能劳动力
Routine
上市公司生产、业务、市场和财务人员数量，除以企业员工人数
非常规高技能劳动力
Non_routine
上市公司技术和研发人员数量，除以企业员工人数
企业价值
Tobinq
企业市场价值/(资产总计-无形资产净额-商誉净额)
公司规模
Size
公司员工总数，取自然对数
公司年龄
Age
公司成立年龄，取自然对数
资产负债率
Leverage
总负债/总资产
成长性
Growth
销售收入增长率，取自然对数
董事会规模
BoardSize
董事会人数，取自然对数
两职合一
Dual
董事长与总经理两职合一时取1,否则取0
股权集中度
Top1
第一大股东持股比例
技术创新
Lnallpats
企业申请专利总数加1,取自然对数
下载链接：
参考资料（免费）：https://download.csdn.net/download/li514006030/89155160
复现数据：https://download.csdn.net/download/li514006030/89155162
回归代码：https://download.csdn.net/download/li514006030/89155161
人工智能词典：
年份
股票代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f84827f1de1efa47102ec0ac354416e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef940a1f9c2f60859b2f529e11c90424/" rel="bookmark">
			大厂嵌入式面试常考八股文及算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.内存映射的原理 将一块内存空间映射到不同的进程空间中
2.define和const的区别 1.define 是预处理指令，用于创建符号常量。const 是 C 和 C++ 的关键字，用于创建具有常量值的变量，本质是只读变量。
2.define 在预处理阶段执行。const 在编译阶段执行。
3.define 没有类型检查，仅进行文本替换。const 有类型检查，可以与变量类型关联。
3.数组和链表的区别 1.数组内存连续，链表内存不连续。
2.数组访问速度比链表快
3.链表增加删除操作比数组快
4.指针和引用的区别 1.指针：指针是一个变量，保存着内存地址。引用：引用是已存在变量的别名，没有自己的内存地址。
2.指针可以具有空值(NULL)，引用不能为空，必须在初始化时指向一个有效的对象。
3.可以修改指针的指向，可以将指针重新赋值为另一个地址。一旦引用被初始化，它始终指向同一个对象，不可更改。
4.指针需要额外的内存空间来存储地址值。引用不需要额外的内存空间，因为它是对已存在变量的别名。
5.解释一下QT的信号与槽 信号与槽是一种用于实现对象之间通信和事件处理的机制。
6.IIC为什么要加上拉电阻，为什么使用开漏输出 上拉电阻 1.当IIC总线在空闲状态，SDA和SCL需要处于高电平状态。
2.开漏输出无法输出高电平，使用上拉电阻可以完成高低电平之间的转换。
开漏输出 1.假如使用推挽输出可能导致器件的烧毁
2.实现线与功能
7.MQTT的通信过程 1.创建客户端
2.指定IP地址和端口号
3.进行连接
4.发布主题或者订阅主题
5.数据传输
6.断开连接
8.在Linux中怎么实现同步 1.互斥锁
2.信号量
3.条件变量
9.TCP和UDP的应用场景 1.TCP：文件传输、电子邮件、网页浏览。
2.UDP：实时音视频传输、在线游戏、实时监控。
10.什么是野指针，什么情况会产生野指针 什么是野指针 1.指向已被释放或无效的内存地址的指针是野指针。
什么情况下产生野指针 1.内存释放后未置空指针
int *ptr = (int*)malloc(sizeof(int)); free(ptr); *ptr = 10; // 这里ptr成为了野指针
2.返回局部变量的指针
int* getIntPointer() {
int num = 5;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef940a1f9c2f60859b2f529e11c90424/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fc56e638df4768a6a2af8b44317a531/" rel="bookmark">
			MacOS系统安装Docker（非常详细）从零基础入门到精通，看完这一篇就够了_mac安装docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先自我介绍一下，小编浙江大学毕业，去过华为、字节跳动等大厂，目前阿里P7
深知大多数程序员，想要提升技能，往往是自己摸索成长，但自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《2024年最新Golang全套学习资料》，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友。
既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，涵盖了95%以上Go语言开发知识点，真正体系化！
由于文件比较多，这里只是将部分目录截图出来，全套包含大厂面经、学习笔记、源码讲义、实战项目、大纲路线、讲解视频，并且后续会持续更新
如果你需要这些资料，可以添加V获取：vip1024b （备注go）
正文 安装后我们在应用程序中找到它
我们打开Docker应用程序后，会有一些选择配置，我们按照如下配置即可。
这里我们选择 Accept
选择默认配置就行，Docker 会自动设置一些大多数开发人员必要的配置。
这里我们跳过就好。
运行Docker 在应用程序中找到 Docker 程序图标，点击以启动 Docker ，启动之后我们会发现右上角工具栏中多了一个小鲸鱼的图片，这个就是 Docker 啦~ 真的好可爱~
Docker 桌面应用程序打开后，就是首页的学习中心界面。
通过 小鲸鱼 中的 About Docker Desktop 可以查看 Docker 的版本
可以看到版本是 Docker version 24.0.2
我们换一种姿势查看！通过 docker --version 命令，也可以查看 Docker 的版本
docker --version
Docker version 24.0.2, build cb74dfc
通过 docker info 命令 可以查看 Docker Client 端和 Server 端信息。
Client 端显示包括 Docker 版本，当前的上下文，调试模式等。
Server 部分显示了 Docker 守护进程的信息，包括当前运行的容器数量、镜像数量等
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fc56e638df4768a6a2af8b44317a531/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ac28431a11befd8efa827967298d4ba/" rel="bookmark">
			AI绘画Stable Diffusion， 如何利用SD垫图实现照片风格转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“ 小红书上有很多用AI做卡通头像的，大概思路是你拍一张个人照片发给博主，博主利用midjourney的垫图功能转换成卡通形象，一张收取一定费用……”
今天给大家分享，利用Stable Diffusion（以下简称SD）的垫图功能，实现真人照片风格转换。
虽然SD用起来没有midjourney体验好，但是软件免费，而且可控性好，因此就选它了。
01、工具准备 准备好SD webui工具，contronet版本要在V1.140以上，也可以直接升级到最新版本V1.440。
具体controlnet安装请看文末扫描获取
contronet等插件升级，依次点击SDwebui界面上的扩展，已安装，检查更新，出现升级检查进度条，然后勾选最新版本，如下图。
我们利用contronet控制类型IP-Adapter来垫图，提前下载对应模型，放入stable-diffusion-webui\models\ControlNet目录。
02、案例讲解 2.1 书写提示词，描述你想要的内容
模型这里选择的是大模型xxmix9realistic_v40，没有使用lora模型，
在文生图界面，第一个输入框，输入以下正向提示词，也就是你想要的内容描述：
masterpiece,best quality,hyper quality,8k,insane details,intricate details,hyperdetailed,high detail,ultra detailed,
大师级，最好画质，高品质，8K，疯狂的细节，复杂的细节，超详细的，高细节，超细节
Realistic, RAW photo, dslr, soft lighting, film grain,Fuji film XT3, Screen Space Refraction, high detailed skin, natural skin texture,cartoon,
真实感，RAW照片，dslr，柔和照明，胶片颗粒，富士胶片XT3，屏幕空间折射，高细节皮肤，自然皮肤纹理，卡通，
eye facing lens，鱼眼镜头
1 girl,solo,Grape Purple long curly hair,light proof,gentle smile,silver gray background,
1个女孩，独自，葡萄紫长卷发，耐光，温柔的微笑，银灰色背景，
第二个输入框，输入以下负向提示词，也就是你不想在AI生成图片中看到的内容，画人物一般都是通用的提示词。
NSFW, nude, naked, porn, (worst quality, low quality:1.4), deformed iris, deformed pupils, (deformed，distorted, disfigured:1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ac28431a11befd8efa827967298d4ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97772c95b27215a69c93ffe8e9bd5aa3/" rel="bookmark">
			AI摄影教程，使用Stable Diffusion进行真人照片转动漫
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 “ 相信我们很多人在看过动漫/动画后，都想看一看二次元世界中的自己长什么样子，那今天就以客户照片为例，说说我们如何用 Stable Diffusion，让 AI 帮我们将真实照片转成一个绝美二次元美男子……”
客户原图是这样的，希望做个安静的二次元美男子，让我们今天一起见证下~~
01、工具准备 本期教程需要用到controlnet的一个控制类型IP Adapter，利用该控制类型的风格转绘功能，实现真人照片转动漫。
需要提前下载两个模型：一个是动漫主模型，一个是VAE外挂放大模型，模型下载请看文末扫描获取
另外还需一个SD插件WD1.4tigger，用来把照片的提示词反推出来，插件下载请看文末扫描获取
02、案例讲解 工具安装好，准备开干。
1 反推提示词。
2 选择图片，自动反推提示词，发送到图生图。
3 选择动漫主模型CrispMix_v10Cucumber，
4 选择要转动漫的真人照片
5 设置重绘参数
采样器选DPM++2M Karras，迭代步数20，点击三角尺会自动获取原图尺寸，提示词引导系数设置4，重绘幅度0.4
6 打开controlnet的第一个单元，勾选启动和完美像素，选择控制类型IP-Adapter，预处理器和模型选择相关的。
7 点击生成按钮，搞定。
我们一起看下最终成品效果咋样，
这是原图
转动漫后
这里为了保证原图相似度，重绘幅度调的是0.4，跟原图比较像，你想让AI发挥下，可以调高重绘幅度到0.7（值越大越不像），如下图。
开头客户图片，重绘幅度0.4是这样的
这是重绘幅度0.7的
当然，提示词引导系数值大小，也会影响最终效果，本案例都是基于CFG scale值是4抽的图，你可以尝试下值越大，效果的变化如何。
当你看到此处，恭喜你，已经掌握了目前真人转动漫的最快方法。
写在最后 感兴趣的小伙伴，赠送全套AIGC学习资料，包含AI绘画、AI人工智能等前沿科技教程和软件工具，具体看这里。
AIGC技术的未来发展前景广阔，随着人工智能技术的不断发展，AIGC技术也将不断提高。未来，AIGC技术将在游戏和计算领域得到更广泛的应用，使游戏和计算系统具有更高效、更智能、更灵活的特性。同时，AIGC技术也将与人工智能技术紧密结合，在更多的领域得到广泛应用，对程序员来说影响至关重要。未来，AIGC技术将继续得到提高，同时也将与人工智能技术紧密结合，在更多的领域得到广泛应用。
一、AIGC所有方向的学习路线
AIGC所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照下面的知识点去找对应的学习资源，保证自己学得较为全面。
二、AIGC必备工具
工具都帮大家整理好了，安装就可直接上手！
三、最新AIGC学习笔记
当我学到一定基础，有自己的理解能力的时候，会去阅读一些前辈整理的书籍或者手写的笔记资料，这些笔记详细记载了他们对一些技术点的理解，这些理解是比较独到，可以学到不一样的思路。
四、AIGC视频教程合集
观看全面零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
五、实战案例
纸上得来终觉浅，要学会跟着视频一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
若有侵权，请联系删除 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e9e8de8d6040e0f8b9477960503917c/" rel="bookmark">
			Linux安装RabbitMQ_linux下rabbitmq默认安装目录(1)，2024年最新下血本买的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先自我介绍一下，小编浙江大学毕业，去过华为、字节跳动等大厂，目前阿里P7
深知大多数程序员，想要提升技能，往往是自己摸索成长，但自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《2024年最新软件测试全套学习资料》，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友。
既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，涵盖了95%以上软件测试知识点，真正体系化！
由于文件比较多，这里只是将部分目录截图出来，全套包含大厂面经、学习笔记、源码讲义、实战项目、大纲路线、讲解视频，并且后续会持续更新
如果你需要这些资料，可以添加V获取：vip1024b （备注软件测试）
正文 安装rpm包
rpm -ivh erlang-18.3-1.el7.centos.x86_64.rpmrpm -ivh socat-1.7.3.2-5.el7.lux.x86_64.rpm 验证erlang是否安装成功
输入 erl
出现如下图所示，则说明erlang安装成功
erlang安装成功
2.下载并安装rabbitmq rpm -ivh rabbitmq-server-3.6.6-1.el7.noarch.rpm 到此步，rabbitmq安装成功。安装目录在
cd /usr/lib/rabbitmq
rabbitmq安装目录
rabbitmq安装bin目录
3.修改配置文件允许远程访问 rabbitmq.config 注意：未修改配置文件rabbitmq.config时，能进入如下所示的界面，但登录不上的原因时。那你就需要在 /etc/rabbitmq/ 文件夹下面加一个 rabbitmq.config配置文件。
rabbitmq登录可视化界面
cd /etc/rabbitmq/
vi rabbitmq.config
加入这一段代码到rabbitmq.config
[{rabbit, [{loopback_users, []}]}].
重启rabbitmq
sudo /sbin/service rabbitmq-server start # 启动服务
sudo /sbin/service rabbitmq-server status # 查看服务状态
sudo /sbin/service rabbitmq-server stop # 停止服务
再到浏览器登录，登录成功
rabbitmq登录成功
4.rabbitmq基本操作命令 sudo chkconfig rabbitmq-server on # 添加开机启动RabbitMQ服务
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e9e8de8d6040e0f8b9477960503917c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a55eedf8ea247f47fa9655b6d0a9c18/" rel="bookmark">
			二叉树详解(深度优先遍历、前序，中序，后序、广度优先遍历、二叉树所有节点的个数、叶节点的个数)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、树概念及结构(了解) 1.1树的概念 1.2树的表示 二、二叉树概念及结构 2.1概念 2.2现实中的二叉树：
2.3数据结构中的二叉树：
2.4特殊的二叉树： 2.5 二叉树的存储结构 2.51 顺序存储： 2.5.2 链式存储：
三、二叉树性质相关选择题练习 四、二叉树的实现
4.1头文件：
4.2Test.c
4.3前序，中序，后序(深度优先遍历)
4.4二叉树所有节点的个数
​编辑
4.5叶节点的个数
4.6层序遍历(广度优先遍历，使用队列)
一、树概念及结构(了解) 1.1树的概念 树是一种非线性的数据结构，它是由n（n&gt;=0）个有限结点组成一个具有层次关系的集合。把它
叫做树是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。
有一个特殊的结点，称为根结点，根节点没有前驱结点除根节点外，其余结点被分成M(M&gt;0)个互不相交的集合T1、T2、……、Tm，其中每一个集合Ti(1&lt;= i &lt;= m)又是一棵结构与树类似的子树。每棵子树的根结点有且只有一个前驱，可以有0个或多个后继，因此，树是递归定义的。
节点的度：一个节点含有的子树的个数称为该节点的度； 如下图：A的为6
叶节点或终端节点：度为0的节点称为叶节点； 如上图：B、C、H、I...等节点为叶节点
非终端节点或分支节点：度不为0的节点； 如上图：D、E、F、G...等节点为分支节点
双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点； 如上图：A是B 的父节点
孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点； 如上图：B是A的孩子节 点
兄弟节点：具有相同父节点的节点互称为兄弟节点； 如上图：B、C是兄弟节点
树的度：一棵树中，最大的节点的度称为树的度； 如上图：树的度为6
节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；
树的高度或深度：树中节点的最大层次； 如上图：树的高度为4
关于树的高度，还有一种看法，就是把高度从0开始看，此时树的高度为3。
节点的祖先：从根到该节点所经分支上的所有节点；如上图：A是所有节点的祖先
子孙：以某节点为根的子树中任一节点都称为该节点的子孙。如上图：所有节点都是A的子孙
森林：由m（m&gt;0）棵互不相交的多颗树的集合称为森林；（数据结构中的学习并查集本质就是 一个森林）
1.2树的表示 树结构相对线性表就比较复杂了，要存储表示起来就比较麻烦了，实际中树有很多种表示方式，如：双亲表示法，孩子表示法、孩子兄弟表示法等等。我们这里就简单的了解其中最常用的孩子兄弟表示法。
typedef int DataType;
struct Node
{
struct Node* _firstChild1; // 第一个孩子结点
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a55eedf8ea247f47fa9655b6d0a9c18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33fdb97d66bfb6f6590cd0e58ddce7b3/" rel="bookmark">
			SpringBoot和Axios数据的传递和接收-Restful完全版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、基础知识铺垫Axios使用HTTP请求方式数据传输方式SpringBoot获取数据的方式 二、基础传递代码示例（一）Path Variables（二）Get、Delete@RequestParam@ModelAttribute （三）Post、Put、Patch@RequestBody 三、稍微复杂一点的传递（一）数组（二）GET/POST复合型 四、特殊数据（一）文件（二）Cookies 一、基础知识铺垫 Axios使用 使用axios发送请求，一般有三个最常用的属性。
属性含义url请求的端点 URL。methodHTTP 请求方法（如 get, post, put, delete, patch 等）。params / data如果 method 是 get 或 delete，使用 params 来传递 URL 查询参数。如果是 post, put, patch，则使用 data 传递请求体数据。通常是一个对象 {}。 HTTP请求方式 Restful风格定义了多种请求方式。
方式简介常用场景GET请求指定的资源。通常用来获取或查询资源。读取或查询资源，如获取用户列表或特定用户的详细信息。POST向指定资源提交数据，请求服务器进行处理（如创建或修改）。数据包含在请求体中。创建新资源（如新用户、新帖子），或提交用户数据表单。PUT用请求体中的数据替换目标资源的所有当前表示。更新现有资源的全部内容，如编辑用户的完整个人信息。PATCH对资源应用部分修改。更新资源的一部分，如修改用户的邮箱地址或密码。DELETE删除指定的资源。删除资源，如删除用户账户或帖子。 数据传输方式 方式介绍URL路径参数（Path Variables）通过 URL 的路径部分传递数据。在 Spring Boot 中使用 @PathVariable 注解获取。适用于 RESTful 风格的 API，例如获取特定资源的详情。查询参数（Query Parameters）通过 URL 的查询字符串（?key=value 形式）传递数据。在 Spring Boot 中使用 @RequestParam 注解获取。适用于 GET 和 DELETE 请求。请求体（Request Body）通过 HTTP 请求的 body 部分传递数据。在 Spring Boot 中使用 @RequestBody 注解获取。适用于 POST , PUT 和 PATCH请求，发送复杂的数据结构。 SpringBoot获取数据的方式 需要提及的是，单单从“获取数据”的角度，我们可以把Delete和Get归为一类，把Put、Patch、Post归为一类。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33fdb97d66bfb6f6590cd0e58ddce7b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba08b66a13d3655255d5d542a23b0bd8/" rel="bookmark">
			使用Java&#43;Qwen&#43;SearXNG构建本地AI搜索问答
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景介绍 前段时间，我们使用SerpAPI+Qwen实现了网络搜索问答（参考：https://blog.csdn.net/weixin_44455388/article/details/137340000?spm=1001.2014.3001.5501），拓展大模型的网络搜索能力，但存在一个问题就是SerpAPI每月只能使用100次的免费调用。
前两天在GitHub上看到一个名叫FreeAskInternet的框架（参考：https://blog.csdn.net/weixin_44455388/article/details/137683895?spm=1001.2014.3001.5501），调用SearXNG搜索(本地运行)在多个搜索引擎上进行搜索，可以实现完全免费、私人和本地运行的搜索聚合器。
作为一个Java程序员，博主借鉴FreeAskInternet的思路，使用Java+Qwen+SearXNG构建了本地AI搜索问答，相比原来使用SerpAPI，使用上将不受限制。
SearXNG介绍 SearXNG 是一个免费的互联网元搜索引擎，它聚合了来自各种搜索服务和数据库的结果，但摆脱了隐私追踪 —— 用户行为既不会被引擎跟踪也不会被分析。
我们可以选择搭建一个自己的搜索引擎，也可以网络找一个可以使用的站点。SearXNG的搭建也非常简单，可以采用docker进行部署，这里我就不详细展开了，大家感兴趣的可以自行去搜索教程。我这里是找的国内可用的站点。
实现思路 整体思路与FreeAskInternet框架相似：
首先是后台调用SearXNG搜索(本地运行)在多个搜索引擎上进行搜索。抓取搜索结果链接内容并传递给LLM，让LLM根据该内容作为参考回答用户问题。将答案以流式传输。 SearXNG提供了查询API，参考：Search API — SearXNG Documentation (2024.4.13+1746eecf2)
代码实现 构建SearXAPI对象，实现查询方法： /** * 搜索 * @param question * @return */ public String search(String question) { OkHttpClient client = new OkHttpClient.Builder() .connectTimeout(60, TimeUnit.SECONDS) .writeTimeout(60, TimeUnit.SECONDS) .readTimeout(60, TimeUnit.SECONDS) .build(); Request request = new Request.Builder() //format设置为html需要采用正则匹配中文，可以根据站点的支持情况设置为json .url(url+"?q=" + question + "&amp;format=html") .addHeader("User-Agent","Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba08b66a13d3655255d5d542a23b0bd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b3d8fa705fdb37160bfbd372d5471da/" rel="bookmark">
			AI绘画Stable DIffusion教程 | 如何利用 Stable Diffusion webui 将图片变得更清晰？全方位对比4种放大方法！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是程序员晓晓
1、引言 “高分放大”（有时候也叫“超分放大”或“高清修复”）描述了在确保图像清晰度的前提下提升图片分辨率的过程。例如，将一张512 x 512的图片放大四倍，得到的就是2048 x 2048分辨率的图片，这个过程不仅放大了图片尺寸，也丰富了图像细节以保持图像清晰度。
在SD webui中，直接生成一张2048 x 2048分辨率的图片由于模型底层机制的限制而变得极其困难。这主要有以下3个原因：
1、显存限制： 与512 x 512相比，2048 x 2048的像素点数量增长16倍，生成图片所需的内存也随之增长16倍。基本上，运行SD webui会占用约3G的显存，处理512 x 512分辨率的图像，显存使用将增加约1G。因此，若要直接生成2048x2048的图片，需要约20G的显存，而当前主流显卡通常只配备8G甚至4G的内存，无法支撑生成高分辨率图片。
2、时间限制： 随着显存使用的增加，生成时间也会以指数级别增长，达到正常时间的16倍！
3、模型限制： 用于训练模型的图片分辨率最高为768 x 768，直接生成过高分辨率的图片可能会导致模型产生重复元素的图片，如重复的人物或头部等。
因此，若想获取一张高分辨率的图片，通常需要进行以下步骤：
1、生成一张低分辨率的图片，例如512 x 512、768 x 512、或512 x 768。
2、然后选择合适的方法放大图片。
下面正式开始介绍本期的内容。
2、插件下载和安装 想要使用高分放大功能，需要借助一些插件的帮助。如果你打算按照这个教程进行操作，那么我建议你安装以下插件。每种插件都提供了三种安装方法，请根据需要自行选择。
1、Ultimate SD Upscale 插件安装
Ultimate SD upscale（终极SD放大） 与 SD webui 内置的放大插件类似，只是 Ultimate SD Upscale 插件提供了更多高级选项。
安装该插件的方法有以下3种。
其中第1种和第2种需要魔法，第3种国内网络即可完成
1）通过SD webui 内部安装
①　打开SD webui，点击 extensions（插件），点击 install from URL（从网址安装）
②　在第一行框内输入：https://github.com/Coyote-A/ultimate-upscale-for-automatic1111 （注意需要科学上网）
③　点击 install（安装）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b3d8fa705fdb37160bfbd372d5471da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/874bb492c0baf7077e5301d6634725b8/" rel="bookmark">
			Mac 设置环境变量的位置、查看和添加PATH环境变量，2024年最新阿里面试官手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先自我介绍一下，小编浙江大学毕业，去过华为、字节跳动等大厂，目前阿里P7
深知大多数程序员，想要提升技能，往往是自己摸索成长，但自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《2024年最新Web前端全套学习资料》，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友。
既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，涵盖了95%以上前端开发知识点，真正体系化！
由于文件比较多，这里只是将部分目录截图出来，全套包含大厂面经、学习笔记、源码讲义、实战项目、大纲路线、讲解视频，并且后续会持续更新
如果你需要这些资料，可以添加V获取：vip1024c （备注前端）
正文 2./etc/bashrc （一般在这个文件中添加系统级环境变量）
全局（公有）配置，bash shell执行时，不管是何种方式，都会读取此文件。
3.~/.bash_profile （一般在这个文件中添加用户级环境变量）
每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!
MAC 修改host文件
-------------------------------------------------------
sudo vi /etc/hosts
linux下查看和添加PATH环境变量
==============================================
PATH的格式为：
-------------------------------------------------------
PATH=$PATH::::------: ，中间用冒号隔开。
添加PATH环境变量：
-------------------------------------------------------
[root@localhost u-boot-sh4]#export PATH=/opt/STM/STLinux-2.3/devkit/sh4/bin:$PATH
查看PATH环境变量：
-------------------------------------------------------
[root@localhost u-boot-sh4]#echo $PATH
/usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin
操作示例：
-------------------------------------------------------
通过编辑 启动文件 来改PATH，
# vim /etc/profile
在文档最后，添加:
export PATH=“/opt/STM/STLinux-2.3/devkit/sh4/bin:$PATH”
保存，退出。
最后 整理面试题，不是让大家去只刷面试题，而是熟悉目前实际面试中常见的考察方式和知识点，做到心中有数，也可以用来自查及完善知识体系。
《前端基础面试题》，《前端校招面试题精编解析大全》，《前端面试题宝典》，《前端面试题：常用算法》
网上学习资料一大堆，但如果学到的知识不成体系，遇到问题时只是浅尝辄止，不再深入研究，那么很难做到真正的技术提升。
需要这份系统化的资料的朋友，可以添加V获取：vip1024c （备注前端）
一个人可以走的很快，但一群人才能走的更远！不论你是正从事IT行业的老鸟或是对IT行业感兴趣的新人，都欢迎加入我们的的圈子（技术交流、学习资源、职场吐槽、大厂内推、面试辅导），让我们一起学习成长！
[外链图片转存中…(img-PLtuaXQ4-1713323679410)]
一个人可以走的很快，但一群人才能走的更远！不论你是正从事IT行业的老鸟或是对IT行业感兴趣的新人，都欢迎加入我们的的圈子（技术交流、学习资源、职场吐槽、大厂内推、面试辅导），让我们一起学习成长！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc75ea9312f2d7a9aaafd202ae09e664/" rel="bookmark">
			Stable Diffusion教程|图生图局部重绘实战详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		局部重绘是Stable Diffusion模型在图像生成应用中的一个核心特性，它赋予用户针对图像特定部分进行再创作的能力，以此实现丰富多彩的视觉表达与创新效果。通过启用局部重绘功能，AI绘画的创新潜力与操作灵活性得到显著提升，使得用户能够在广阔的创意疆域内随心所欲地试验与实践各类图像编辑与生成任务，尽情释放想象力。
文末扫码可获取AI绘画学习资料~
目录
1 局部重绘
2 涂鸦重绘
3 上传重绘蒙版
4 批量重绘
一、局部重绘
功能介绍
SD和其他AI绘画Midjourney最大的区别就是可控，局部重绘功能就是增加这种可控性，它能够针对图像的局部按需重绘，从而实现更加细致和图像的编辑。
实战技巧 1【用局部重绘换脸】
step 1 选择一个写实大模型“麦橘写实”，进入到“图生图”页面，切换到“局部重绘”，上传一张大头照 512*512。
模型下载地址：https://www.liblib.art/modelinfo/bced6d7ec1460ac7b923fc5bc95c4540
模型存放目录：
…\novelai-webui-aki-v3\models\Stable-diffusion
step 2 使用涂抹工具，可以把脸部全部涂抹上（如果你看过之前的教程，可以安装插件，快捷键调整笔触和图片大小，涂抹得更加精确）
step 3 选择采样器和生成批次2，其他设置默认不变，提示词也不用写，除非你要描述脸部特征，直接生成。
（换成了一胖一瘦两张脸，刘海也变了，但边缘处不太完美，下巴脖颈处有很大的痕迹）
小技巧1：蒙版模糊设置
让重绘的边缘模糊，类似ps里面的羽化功能，能更好的融合重绘内容和原图的过渡区域，默认值4，可以根据情况不断尝试。参数范围0~64，分别测试了20、30、40、50，到了40以上下巴被修复。
实战技巧 2【换主体-换背景】
蒙版模式：重绘蒙版内容，换主体，用上面换脸的方式涂抹小狗，然后提示词“a cat”生成即可。
注意：这时候蒙版模糊要小，不然会保留一些狗的轮廓，我这里设置5。
重绘蒙版内容-狗变猫
蒙版模式：重绘非蒙版内容，换背景，提示词“forest”
重绘非蒙版内容-换背景
实战技巧 3【无中生有】
蒙版蒙住的内容：是对蒙版重绘的初始画面设置
填充 原图 潜变量噪声 潜变量数字零 重绘幅度0.02 的不同效果
原图（微调）：在原来图像上重绘，适合微调图像布局。
填充（大改）：将重绘区模糊效果，让AI重新降噪生成图像。
潜变量数值零（大改）：与填充类似，生成一个色调相似的纯色在重绘。
潜变量噪声（无中生有）：铺马赛克并重新降噪生成图像，产生变化很大，从而无中生有。
其他设置：
重绘区域：全图和仅蒙版，通常选“全图”，不然过渡区容易衔接不好，除非重绘区域极小。
仅蒙版区域下边缘预留像素：和蒙版模糊道理类似，值约高AI会参考周边的像素进行重绘，我这里设置的100，大家可自行尝试，值不同生成的内容会不同。
**二、**涂鸦重绘
功能介绍
绘图（涂鸦）+提示词，比局部重绘控制更精准一些，我们可以自由的创作和定制图像，比如：根据涂鸦形状设计产品，或给人物加上饰品、戴上眼镜、换衣服、换发型等
实战技巧
【戴眼镜】
setp1 切换到“绘图”，选择一个颜色，涂一个眼睛的形状，提示词“red glasses”，点击生成。
setp2 涂鸦区域比较糙，可以调大重绘幅度，让AI自由发挥，我这里是0.75，值越大，除了涂鸦的部分，其他部分也发生了更大变化。
戴上红眼镜
【染个发】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc75ea9312f2d7a9aaafd202ae09e664/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3deb4237c0098cf5117863c9ff8a84e/" rel="bookmark">
			[Android]修改应用包名、名称、版本号、Icon、启动页以及环境判断和打包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.修改包名 在Android Studio中更改项目的包名涉及几个步骤：
打开项目结构:
在Android Studio中，确保您处于Android视图模式（在左侧面板顶部有一个下拉菜单可以选择）。
重命名包名:
在项目视图中，找到您的包名（例如com.gamin.learndemo），右键点击它。
选择Refactor &gt; Rename。
在弹出的对话框中，点击Rename Package而不是Rename Directory。
输入新的包名（例如com.gamin.new），然后点击Refactor。
Android Studio会显示一个预览窗口，展示所有更改，确认无误后点击Do Refactor。
更新build.gradle文件:
找到app模块下的build.gradle文件。
修改applicationId为新的包名（com.gamin.new）。
点击Sync Now提示来同步您的项目。
更新清单文件:
打开AndroidManifest.xml文件。
如果有，确保package属性反映了新的包名。
检查代码中的任何硬编码引用:
使用全局搜索（Ctrl + Shift + F）来查找项目中任何硬编码的旧包名引用，并将其更新为新的包名。
清理和重建项目:
在Build菜单中选择Clean Project。
然后选择Rebuild Project。
请注意，如果您的应用程序已经发布到了Google Play，更改包名将意味着您将无法上传更新到现有的应用列表，因为包名是应用在Google Play上的唯一标识符。如果这是您的情况，您需要以新包名发布一个新的应用，并可能需要通知您的用户进行迁移。
2.修改应用名称 在 Android Studio 中，你可以通过修改 `AndroidManifest.xml` 文件或 `res/values/strings.xml` 文件来更改 Android 项目的应用程序名称（APP名称）。
通过修改 `AndroidManifest.xml` 在 `AndroidManifest.xml` 文件中，你可以找到 `&lt;application&gt;` 元素的 `android:label` 属性，该属性定义了应用程序的显示名称。
&lt;application android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:theme="@style/AppTheme"&gt; &lt;!-- ... --&gt; &lt;/application&gt; 在上面的例子中，`@string/app_name` 引用了 `res/values/strings.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3deb4237c0098cf5117863c9ff8a84e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a3a60cb19b28c8fa5b4520d6bbbec40/" rel="bookmark">
			推荐几个精致的web UI框架及常用前端UI框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4.FrozeUI
Frozen UI是一个开源的简单易用，轻量快捷的移动端UI框架。基于手Q样式规范，选取最常用的组件，做成手Q公用离线包减少请求，升级方式友好，文档完善，目前全面应用在腾讯手Q增值业务中。
官网地址：http://frozenui.github.io/
5.uiKit
uiKit是一款轻量级、模块化的前端框架，可快速构建强大的web前端界面。
官网地址：http://www.getuikit.net/
6.H-ui
H-ui是轻量级前端框架，简单免费，兼容性好，适用于中国网站。
官网地址：http://www.h-ui.net/
7.Weui
weUI 是一套同微信原生视觉体验一致的基础样式库，由微信官方设计团队为微信 Web 开发量身设计，可以令用户的使用感知更加统一。包含button、cell、dialog、 progress、 toast、article、actionsheet、icon等各式元素。
官网地址：https://github.com/weui/weui
8.layui
Layui 诞生于2016年金秋，是一款带着浓烈情怀的国产前端UI框架，她追求极简，又不失丰盈的内在，说她是史上最轻量的结晶，似乎并不为过。一切都源自于她对原生态的执着，对前端社区的那些噪杂声音的过滤，以及她本身的精心雕琢。
官网地址：http://www.layui.com/
9.YDUI Touch
YDUI Touch 专为移动端打造，在技术实现、交互设计上兼容主流移动设备，保证代码轻、性能高;使用 Flex 技术，灵活自如地对齐、收缩、扩展元素，轻松搞定移动页面布局;实现强大的屏幕适配布局，等比例适配所有屏幕。什么？用得不开心？轻松切换 px;自定义Javascript组件、Less文件、Less变量，定制一份属于自己的YDUI;
官网地址：http://www.ydui.org/
10、后台UI开发框架 MuseUI
一款基于bootstrap风格，兼容于主流浏览器（包括IE6）的后端UI开发组件。
官方网站：http://git.oschina.net/muse/museui
以下是常用前端UI框架快速开发web项目
1.DWZ 国产的jQuery UI富客户端框架
框架地址：http://jui.org/
2.jQuery LingerUI 国产前端框架
框架地址：http://www.ligerui.com/
3.JQuery EasyUI 帮助你快速构建web应用的前端框架
框架中文地址：http://www.jeasyui.net/
框架英文地址：http://www.jeasyui.com/
4.bootstrap 这个就不多说了，目前应用最为广泛的UI框架，组件样式都非常丰富
框架地址：http://www.bootcss.com/
5.BUI 感觉做的还是不错
自我介绍一下，小编13年上海交大毕业，曾经在小公司待过，也去过华为、OPPO等大厂，18年进入阿里一直到现在。
深知大多数前端工程师，想要提升技能，往往是自己摸索成长或者是报班学习，但对于培训机构动则几千的学费，着实压力不小。自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《2024年Web前端开发全套学习资料》，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友，同时减轻大家的负担。
既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，基本涵盖了95%以上前端开发知识点，真正体系化！
由于文件比较大，这里只是将部分目录截图出来，每个节点里面都包含大厂面经、学习笔记、源码讲义、实战项目、讲解视频，并且会持续更新！
如果你觉得这些内容对你有帮助，可以扫码获取！！（备注：前端）
最后 一个好的心态和一个坚持的心很重要，很多冲着高薪的人想学习前端，但是能学到最后的没有几个，遇到困难就放弃了，这种人到处都是，就是因为有的东西难，所以他的回报才很大，我们评判一个前端开发者是什么水平，就是他解决问题的能力有多强。
分享一些简单的前端面试题以及学习路线给大家，狂戳这里即可获取
才很大，我们评判一个前端开发者是什么水平，就是他解决问题的能力有多强。
分享一些简单的前端面试题以及学习路线给大家，狂戳这里即可获取
[外链图片转存中…(img-VbPnVuua-1713320744120)]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/329156fba2ce041b8f5da3fa74cdc8bc/" rel="bookmark">
			Vue-Audio-Recorder：前端录音神器，轻松集成音频录制功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue-Audio-Recorder：前端录音神器，轻松集成音频录制功能 项目地址:https://gitcode.com/grishkovelli/vue-audio-recorder
在Web开发中，用户体验是至关重要的，而实时交互功能如语音记录，为用户提供更直观便捷的沟通方式。Vue-Audio-Recorder就是这样一款专为Vue.js开发者打造的开源组件，它可以帮助你在项目中快速实现高质量的音频录制功能。
项目简介 Vue-Audio-Recorder 是一个轻量级且易于使用的Vue插件，它基于Web Audio API和MediaStream Recording API，让你能够在浏览器环境中无缝地录制和处理音频文件。该项目提供了一套完整的UI组件，包括开始/暂停/停止录音按钮、实时预览音轨等，满足基本的录音需求。
技术分析 Web Audio API：这是一个JavaScript API，用于处理和播放音频。Vue-Audio-Recorder利用这一API进行音频流的处理，可以控制录音质量、添加效果等。MediaStream Recording API：它允许我们捕获并记录媒体流，如来自用户的摄像头或麦克风。在这个项目中，正是这一API实现了音频数据的实时记录，并将其转化为可存储的文件。 应用场景 Vue-Audio-Recorder可以广泛应用于各种需要音频输入的Web应用：
在线教育平台，让学生上传口语作业或教师进行在线评测。即时通讯工具，支持语音消息发送。表情包制作工具，让用户录制个性化的语音说明。问卷调查，提供语音反馈选项。翻译服务，支持语音输入的翻译请求。 特点与优势 易用性：封装良好，通过简单的配置即可在项目中集成，提供丰富的API和事件接口。跨平台兼容：支持大部分现代浏览器，包括Chrome, Firefox, Safari 和 Edge。自定义UI：组件样式可自定义，适应不同设计风格的需求。实时预览：录音过程中可实时显示音轨，提升用户体验。多格式输出：支持WAV和MP3两种常见的音频格式，满足不同的存储和传输要求。 结语 Vue-Audio-Recorder以其简单易用和强大的功能，为Vue开发者提供了便利的音频录制解决方案。如果你正在寻找一种在Web应用中添加录音功能的方法，那么这个项目绝对值得你尝试。现在就去探索吧，让Web应用的声音更加丰富多彩！
项目地址:https://gitcode.com/grishkovelli/vue-audio-recorder
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7ef31c0bb881a0f0bba85bed0839fd5/" rel="bookmark">
			Magnet Player：一款基于Web的磁力链媒体播放器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Magnet Player：一款基于Web的磁力链媒体播放器 是一个创新的开源项目，它允许用户直接在浏览器中播放磁力链（Magnet URI）内容，无需下载或安装任何桌面应用程序。这个项目的独特之处在于它结合了现代Web技术，为用户提供了便捷、安全且跨平台的在线媒体播放体验。
技术分析 WebTorrent技术：Magnet Player 利用了 WebTorrent 库，这是一个纯JavaScript实现的BitTorrent客户端，可以完全在浏览器环境中运行。这意味着你可以通过WebRTC进行P2P文件传输，减少了服务器带宽的压力，并实现了快速的内容分发。
HTML5多媒体支持：项目依赖于HTML5的&lt;video&gt;元素，使其能够直接在网页上播放视频文件，无需借助Flash或其他插件。
前端框架与库：该项目采用了现代化的前端框架和库，如Vue.js，用于构建用户界面，提供响应式设计和良好的用户体验。
安全性：由于所有处理都在浏览器端完成，用户的隐私得到保护，因为数据不需要经过服务端。
功能用途 直接播放磁力链：只需输入或粘贴磁力链，即可立即开始播放，无需等待整个文件下载完成。跨平台：由于其Web基础，Magnet Player 可以在任何支持现代浏览器的操作系统上运行，包括Windows、MacOS、Linux等。离线观看：一旦内容开始下载，即使断开网络连接，也能继续播放已缓冲的部分。简单易用：直观的用户界面使得任何人都能轻松操作。 特点 轻量级：Magnet Player 不需要额外安装，只需在支持的浏览器中打开即可。可扩展性：作为开源项目，开发者可以自定义和扩展功能，满足个性化需求。隐私保护：仅用户自己的设备处理磁力链内容，不涉及第三方服务器，保证了数据隐私。实时更新：由于是Web应用，新功能和改进会自动推送给用户，无需手动升级。 推广使用 Magnet Player 的出现打破了传统媒体播放的方式，尤其适合那些喜欢在线观看或者不愿在本地存储大量文件的用户。如果你经常使用磁力链分享或获取媒体资源，那么尝试一下Magnet Player，享受更自由、更高效的播放体验吧！
通过点击上方的图标，立刻访问Magnet Player的源码仓库，了解更多信息，或是直接在GitCode上预览和使用此项目。让我们一起探索这个由Web技术驱动的新媒体世界！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a14a090fa393fca487cb1d48bb3812b7/" rel="bookmark">
			Flutter第十弹 ScrollView滚动组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目标：
1）滚动组件的特性？
2）有哪些常用的滚动组件？
一、基础滚动组件 Flutter有许多内置的小部件可以自动滚动，还提供了各种小部件，您可以自定义这些小部件来创建特定的滚动行为。
1.1 Scrollbar组件 滚动条的基本构成
滑块：显示滚动了多少？
轨道：滚动条滑动的轨道。可以直接拖拽滚动到轨道位置。
子组件：对应可以滚动的子组件。
child属性 可滚动属性的组件，例如ListView
Scrollbar(child: ListView.builder( itemCount: 20, itemBuilder: (c, i) -&gt; MyItem(i), )), controller属性 滚动控制器，为空的话默认使用PrimaryScrollController启动滚动条。
thumbVisibility属性 滑块是否可见，布尔值，默认不可见。
trackVisibility属性 轨道是否可见，布尔值，
如果轨迹可见性与滚动条的素材状态有关，
使用全局[ScrollbarThemeData.trackVisibility]或覆盖
子树的主题数据。
thickness属性 滚动条厚度。
radius属性 滚动条滑块圆角半径。
如果为null，则默认值取决于平台。在[TargetPlatform.android]上，
半径应用于滚动条拇指。在[TargetPlatform.iOS]上，
使用[CupertinoScrollbar.defaultRadius]。其余平台的默认[半径.圆形]为8.0像素。
notificationPredicate属性 [ScrollNotification]的谓词，用于自定义小部件
听取孩子的通知。？？？
scrollbarOrientation属性 滚动条的方向，水平滚动条，竖直滚动条。参见ScrollbarOrientation，
包括
left: 左侧滚动条right: 右侧滚动条top：顶部滚动条bottom: 底部滚动条 1.2 SingleChildScrollView组件 通常SingleChildScrollView只应在期望的内容不会超过屏幕太多时使用，这是因为SingleChildScrollView不支持基于Sliver的延迟实例化模式，所以如果预计视口可能包含超出屏幕尺寸太多的内容时使用SingleChildScrollView将会导致性能差的问题，此时应该使用一些支持Sliver延迟加载的可滚动组件，如ListView。
当需要构建比较长的页面时，如果直接使用SingleChildScrollView，会将整个页面的内容一次性渲染到内存中，这可能会导致内存用过高，影响应用的性能和体验。
SingleChildScrollView继承StatelessWidget。
scrollDirection属性 滚动方向，默认Axis.vertical
Axis.vertical：竖直方向Axis.horizontal水平方向 padding属性 内边距
reverse属性 是否反向滚动
primary属性 controller属性 primary为true时此项必须为空（null）.可用于控制此滚动的位置的对象视图滚动。
[ScrollController]有多种用途。
它可以用来控制初始滚动位置（请参见[ScrollController.initialScrollOffset]）它可用于控制滚动视图是否应自动保存并恢复其在[PageStorage]中的滚动位置[ScrollController.kipScrollOffset]）它可以用来读取当前滚动位置（请参阅[ScrollController.offset]），或更改它（请参阅[ScrollController.animateTo]）。 import 'package:flutter/material.dart'; void main() { runApp(MyApp()); } class MyApp extends StatelessWidget { final controller = ScrollController(); @override Widget build(BuildContext context) { return MaterialApp( home: Scaffold( appBar: AppBar( title: Text('SingleChildScrollView Demo - Controller'), ), body: SingleChildScrollView( controller: controller, // 设置控制器 child: Column( children: List.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a14a090fa393fca487cb1d48bb3812b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d28eecc8e6ba19b489fd55190bbc06ad/" rel="bookmark">
			dfs和bfs算法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DFS（深度优先搜索）和BFS（广度优先搜索）是两种用于遍历或搜索树或图的算法。它们的主要区别在于访问节点的顺序。
深度优先搜索（DFS） 深度优先搜索是一种用于遍历或搜索树或图的算法。这个算法会尽可能深地搜索树的分支。当节点v的所在边都已被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。
DFS的实现通常使用递归或栈。对于每一个节点，我们首先检查它是否已经被访问过。如果没有，我们就标记它为已访问，并递归地访问它的所有未访问的邻居。
DFS的一个主要应用是寻找图的连通分量，或者在树中查找路径。
广度优先搜索（BFS） 广度优先搜索是另一种用于遍历或搜索树或图的算法。这个算法从根节点（或任意一个节点）开始，探索最近的节点。如果所有邻居节点都已被访问过，搜索将回溯到发现当前节点的节点。这个过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。
BFS的实现通常使用队列。对于每一个节点，我们首先检查它是否已经被访问过。如果没有，我们就标记它为已访问，并将其所有未访问的邻居添加到队列中。然后，我们从队列中取出一个节点并重复这个过程。
BFS的一个主要应用是找到图中从源节点到目标节点的最短路径。
DFS和BFS的工作原理、实现细节以及它们在实际问题中的应用。 深度优先搜索（DFS） 工作原理：
DFS是一种用于遍历或搜索树或图的算法。它从起始节点开始，首先访问该节点，然后递归地访问其中一个未访问过的邻居节点，直到到达一个没有未访问邻居的节点为止。此时，DFS回溯到前一个节点，并继续访问其他未访问的邻居节点。这个过程一直持续到所有可达的节点都被访问为止。
实现细节：
DFS通常使用递归或栈来实现。在递归实现中，对于每个节点，我们检查它是否已经被访问过。如果没有，我们将其标记为已访问，并递归地访问其所有未访问的邻居节点。在栈实现中，我们使用一个栈来保存待访问的节点。每次从栈中弹出一个节点，并访问它的所有未访问的邻居节点，将这些邻居节点压入栈中。
应用：
DFS常用于解决图论中的连通性问题、寻找路径或循环、拓扑排序等。在树形结构中，DFS也常用于查找特定路径或解决迷宫问题。
广度优先搜索（BFS） 工作原理：
BFS从起始节点开始，首先访问该节点，然后访问所有相邻的未访问节点。接着，对每个相邻节点，再访问它们的未访问邻居节点，以此类推。BFS按照层次顺序逐层访问节点，直到所有可达的节点都被访问为止。
实现细节：
BFS通常使用队列来实现。我们首先将起始节点放入队列中。然后，在每次迭代中，我们从队列中取出一个节点，并访问它。接着，我们将该节点的所有未访问邻居节点放入队列中。这个过程一直持续到队列为空，即所有可达的节点都被访问为止。
应用：
BFS常用于寻找图中最短路径问题（例如，从起点到终点的最短路径）、查找特定层级的节点、网络爬虫等。在二叉树中，BFS也常用于进行层次遍历。
DFS与BFS的比较 空间复杂度：
DFS的空间复杂度取决于递归深度或栈的大小，而BFS的空间复杂度则取决于队列的大小，通常与节点的数量相关。
时间复杂度：
对于连通图，DFS和BFS的时间复杂度都是O(V+E)，其中V是节点数，E是边数。但对于非连通图，DFS可能需要多次遍历才能访问所有节点，而BFS通常只需要一次遍历。
应用场景：
DFS更适合于深度优先的搜索问题，如寻找路径、解决迷宫问题等。BFS更适合于广度优先的搜索问题，如寻找最短路径、层次遍历等。
DFS和BFS的变种、优化策略以及它们在实际应用中的其他考虑因素。 DFS的变种和优化 迭代DFS：
虽然DFS通常使用递归实现，但也可以使用迭代的方式结合栈来实现。迭代DFS可以避免递归可能带来的栈溢出问题，并且在某些情况下可能更加高效。
回溯：
在DFS中，当某个节点的所有邻居都被访问过或不可达时，我们需要回溯到上一个节点。这通常通过维护一个表示当前搜索路径的数据结构来实现，如路径栈或父节点数组。
剪枝：
在某些问题中，我们可以提前终止对某个分支的搜索，即剪枝，以减少不必要的计算。例如，在求解最短路径问题时，如果我们已经找到了一个比当前路径更短的路径，就可以停止对当前路径的搜索。
BFS的变种和优化 双向BFS：
在求解最短路径问题时，双向BFS从起始节点和目标节点同时开始搜索，当两个搜索过程相遇时即找到最短路径。这种方法可以显著减少搜索空间，特别是在图较稀疏或节点较多时。
带权重的BFS：
对于带权重的图，我们可以使用优先队列（如最小堆）来实现带权重的BFS。这样，在每次迭代中，我们总是先访问权重最小的节点，从而找到最短路径。这种方法常用于求解带权重的最短路径问题，如Dijkstra算法。
DFS和BFS在实际应用中的考虑 图的表示：
在实现DFS和BFS时，我们需要选择一种合适的方式来表示图。常用的表示方法包括邻接矩阵和邻接表。邻接矩阵适用于稠密图，而邻接表则更适用于稀疏图。
连通性：
在处理非连通图时，DFS和BFS可能需要多次遍历才能访问所有节点。因此，在实际应用中，我们通常需要判断图是否连通，并相应地调整算法。
空间和时间复杂度：
DFS和BFS的空间复杂度通常与图的规模相关。DFS的空间复杂度主要由递归深度或栈的大小决定，而BFS的空间复杂度则主要由队列的大小决定。在时间复杂度方面，DFS和BFS通常具有相似的性能，但在某些特定情况下，如稀疏图或带权重的图，它们的表现可能有所不同。
高级话题和扩展 DFS的高级应用 强连通分量：在图中，如果两个顶点间存在互相到达的路径，则称这两个顶点是强连通的。一个最大强连通子图称为强连通分量。DFS可以用来找到图中的强连通分量。
拓扑排序：对于有向无环图（DAG），拓扑排序是对DAG的顶点进行线性排序，使得对每一条有向边(u, v)，均有u（在排序记录中）比v先出现。DFS是实现拓扑排序的常用算法。
周期检测：在图的遍历中，DFS可以用来检测图中是否存在周期或环。如果在DFS过程中，我们访问了一个已经被访问过的节点，并且这个节点不是当前节点的父节点，那么图中就存在周期。
BFS的高级应用 最短路径问题：BFS通常用于求解无权图中的单源最短路径问题。然而，通过结合优先队列（如Dijkstra算法）或动态规划（如Floyd-Warshall算法），BFS的思想也可以用于解决带权图中的最短路径问题。
层次遍历：在树或图中，BFS可以用来进行层次遍历。这在处理如二叉树、n叉树等数据结构时非常有用。
优化和考虑因素 启发式搜索：在DFS和BFS的基础上，我们可以引入启发式信息来指导搜索方向，从而加速搜索过程。这种结合了启发式信息的搜索算法通常称为启发式搜索，如A*搜索算法。
记忆化搜索：对于重复搜索的问题，我们可以使用记忆化搜索来避免重复计算。通过保存已经计算过的结果，当再次遇到相同的问题时，我们可以直接返回保存的结果，从而提高搜索效率。
图的数据结构优化：选择合适的数据结构来表示图可以显著提高DFS和BFS的性能。例如，对于稀疏图，使用邻接表通常比使用邻接矩阵更加高效。
并行化：对于大规模的图数据，我们可以考虑使用并行化技术来加速DFS和BFS的执行。通过将图划分为多个子图，并在不同的处理器或线程上并行处理这些子图，我们可以显著减少总的执行时间。
实际应用案例 DFS和BFS在许多领域都有广泛的应用，包括但不限于：
网络爬虫：在网页搜索中，BFS常用于广度优先地遍历网页链接，以获取与查询相关的页面。路径规划：在地理信息系统（GIS）中，DFS和BFS可以用于寻找从起点到终点的最短路径或可行路径。社交网络分析：在社交网络中，DFS和BFS可以用来分析用户的连接关系、社区发现等。游戏AI：在棋类游戏或迷宫游戏中，DFS和BFS可以用来搜索可能的走法或路径，以实现游戏AI的决策功能。 总结 DFS和BFS是两种基础且强大的图遍历算法，它们在解决各种实际问题时发挥着重要作用。通过了解它们的原理、实现细节以及变种和优化策略，我们可以更加灵活地运用这些算法来解决实际问题。同时，在选择使用DFS还是BFS时，我们需要根据问题的特点、图的性质以及时间和空间复杂度的要求来进行权衡和选择。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/412/">«</a>
	<span class="pagination__item pagination__item--current">413/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/414/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>