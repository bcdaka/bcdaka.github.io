<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a4467c2874ff63c75e52e29d202eb73/" rel="bookmark">
			EMQX Platform &amp; Snowflake：构建可再生分布式能源的智慧未来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 可再生能源如风力和太阳能发电，具有低成本和环保的特性，是未来能源供应的主要方向。然而，这类发电方式存在供应分散、设备数量多、地区分布广等特点。再加上不同地区的季节和天气变化，不确定性极大。
随着社会用电需求的持续增加，如何合理调配电力成为保障供需平衡和最大化新能源发电效益的关键。
本文将介绍如何采用 EMQX 企业版和 Snowflake，帮助用户在复杂的电力供应链中，实现发电设备数据的采集、存储和分析。通过这一集成，准确预测发电容量，从而实现高效的运营。
场景介绍 太阳能和风力发电量的预测依赖地理位置、历史的气候信息、运行信息系和发电量数据。本文我们使用 MQTT 客户端工具 MQTTX CLI 的 simulate 命令，配合模拟脚本生成多个太阳能和风力发电站 MQTT 状态数据采集上报与客户端（虚拟电站）。
虚拟电站将连接到 EMQX 上，周期性生成模拟数据，并向指定 MQTT 主题发布自身状态数据；EMQX 在接收到消息后，使用内置的规则引擎和数据集成功能，将其存储到 Snowflake 中；Snowflake 保存数据后，在其平台上进行数据分析。 典型的数据格式如下：
字段名数据类型说明idSTRING唯一标识符，用于标识每条数据记录citySTRING城市名，用于标识数据的来源城市modelSTRING设备型号，用于标识数据对应的设备型号regionIDSTRING区域编号，用于标识设备所在的区域编号typeSTRING设备类型，值为 “Wind” 或 “Solar”ratedPowerFLOAT设备的额定功率，单位为千瓦 (kW)timestampTIMESTAMP数据记录的时间戳，表示数据生成的具体时间powerOutputFLOAT实时输出功率，单位为千瓦 (kW)windSpeedFLOAT风速，仅对风力发电设备有效，单位为米/秒 (m/s)solarRadiationFLOAT光照强度，仅对太阳能发电设备有效，单位为瓦特每平方米 (W/m²)rotationSpeedFLOAT转速，仅对风力发电设备有效，单位为每分钟转数 (RPM) 对应的数据示例如下：
{ "id": "6b50f69c-9c9b-48e7-ae9d-849e6e5e5dd5", "city": "San Francisco", "model": "Solar-Model-A1", "regionID": "01", "type": "Solar", "ratedPower": 15.5, "timestamp": "2024-07-10T12:34:56Z", "powerOutput": 12.3, "windSpeed": null, "solarRadiation": 720, "rotationSpeed": null } 安装 EMQX 企业版 EMQX 企业版是一款企业级 MQTT 物联网接入平台，能够提供高可靠、高性能的物联网实时数据接入，并实现数据的处理和集成。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a4467c2874ff63c75e52e29d202eb73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7922e0c0df1c0b00b011cc98b14483e/" rel="bookmark">
			2024年8月13日（lvs NAT脚本 RS脚本 ds脚本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lvs-nat模式的优点配置简单,缺点是请求和响应都必须经过ds,容易称为性能瓶颈
希望有这样的模式,请求的时候使用input链进行负载均衡,响应的时候就不要经过ds,直接由rs响应给客户端
在nat模式的时候,请求vip,接收vip的响应
构想 请求vip,接受rip响应,这是不允许lvs-dr模式
NAT脚本 # ds脚本 #!/bin/bash #配置网卡 echo TYPE="Ethernet" &gt;&gt; /etc/sysconfig/network- scripts/ifcfg-ens36 echo BOOTPROTO="none" &gt;&gt; /etc/sysconfig/network- scripts/ifcfg-ens36 read -p "router name:" router_name echo NAME='"$rount_name"' &gt;&gt; /etc/sysconfig/network- scripts/ifcfg-ens36 uuidkey=$( uuidgen ) echo UUID='"$uuidkey"' &gt;&gt; /etc/sysconfig/network- scripts/ifcfg-ens36 &gt;&gt; /etc/sysconfig/network- scripts/ifcfg-ens36 echo DEVICE='"$rount_name"' &gt;&gt; /etc/sysconfig/network- scripts/ifcfg-ens36 echo ONBOOT="yes" &gt;&gt; /etc/sysconfig/network-scripts/ifcfg- ens36 echo IPADDR=192.168.10.100 &gt;&gt; /etc/sysconfig/network- scripts/ifcfg-ens36 systemctl restart network #安装ipvsadm yum list installed|grep ipvsadm if[ $? -ne 0 ];then yum -y install ipvsadm fi #配置规则 read -p "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7922e0c0df1c0b00b011cc98b14483e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a06f94daea1e6ad0c5fbe1ecba9ca32/" rel="bookmark">
			【数据结构】详细介绍线性表中的顺序表，带你复盘实现细节，附上顺序表编程练习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一. 线性表
二. 顺序表 1. 静态顺序表与动态顺序表
2. 动态顺序表的接口实现 2.1 顺序表初始化 2.2 判断是否需要扩容 2.3 顺序表指定位置插入
2.4 顺序表头插
2.5 顺序表尾插
2.6 顺序表指定位置删除
2.7 顺序表头删
2.8 顺序表尾删
2.9 顺序表查找
2.10 顺序表修改 2.11 顺序表销毁
2.12 顺序表打印
3. 顺序表的缺点
4. 顺序表编程练习题 4.1 移除元素
4.2 删除有序数组中的重复项
4.3 合并两个有序数组
一. 线性表 1. 线性表(linear list)是n个具有相同特性的数据元素的有限序列。
2. 线性表是一种在实际中广泛使用的数据结构，常见的线性表：顺序表、链表、栈、队列、字符串...
3. 线性表在逻辑上是线性结构，也就说是连续的一条直线。但是在物理结构上并不一定是连续的，线性表在物理上存储时，通常以数组和链式结构的形式存储。
二. 顺序表 1. 静态顺序表与动态顺序表 1. 顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般情况下采用数组存储，在数组上完成数据的增删查改。
2. 顺序表一般可以分为：
静态顺序表：使用定长数组存储元素。
#define N 10 typedef int SLDataType; typedef struct SeqList { SLDataType array[N]; //定长数组 size_t size; //有效数据个数 }SeqList; 动态顺序表：使用动态开辟的数组存储。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a06f94daea1e6ad0c5fbe1ecba9ca32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf21ebcc2a6fd578b349ae30ebf64e49/" rel="bookmark">
			2024最新版Node.js下载安装及环境配置教程（手把手教你）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、进入官网地址下载安装包 Node.js 中文网
选择对应的版本，我是windows64
2、下载成功后，安装程序 点击next
修改路径，这里建议修改，修改完成点击next
这里我选择默认安装，点击next
不选中，点击next
点击install进行安装
点击finish
3、测试安装是否成功 win+r 打开运行窗口 输入cmd
输入：node -v // 显示node.js版本
npm -v // 显示npm版本
这样说明安装成功
4、配置环境 找到刚才安装的文件夹，新建两个文件夹
【node_global】和【node_cache】
创建完毕后，复制刚刚创建的【node_global】和【node_cache】文件夹路径在cmd命令分别输入以下两条命令，注意不要两条命令的文件路径不要搞混了。
注：可以打开所创建的文件夹，把鼠标放在箭头指向的位置选择复制。
使用管理员身份打开cmd命令窗口（打开方法见下方Tips），输入以下命令（下面的路径是我创建的文件夹所在的路径，需要复制你们自己创建的路径哦）
(1)npm config set prefix “你的路径\node_global” （复制刚刚所创建的“node_global”文件夹路径）
npm config set prefix "D:\zhuanye\nodejs\node_global"
(2)npm config set cache “你的路径\node_cache” （复制刚刚所创建的“node_cache”文件夹路径）
npm config set cache "D:\zhuanye\nodejs\node_cache"
检查是否配置正确
(3)配置环境变量
系统变量中，点击新建
变量名：NODE_PATH
变量值：D:\zhuanye\nodejs\node_global\node_modules
编辑【用户变量】中的【Path】
将默认的 C 盘下【 AppData\Roaming\npm 】修改成 【node_global】的路径，点击【确定】
在【系统变量】中选择【Path】点击【编辑】后点击新建【%NODE_PATH%】，随后一直点击【确定】直到关闭所有窗口即可。
5、测试 配置完成后，全局安装一个最常用的 express 模块进行测试（使用管理员方式打开cmd）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf21ebcc2a6fd578b349ae30ebf64e49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93dedb0cfea689b13250a25c010d7942/" rel="bookmark">
			EasyRecovery17官方最新版本下载！新功能介绍，数据恢复从未如此简单！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在csdn上，有超过138万篇关于“误删”的笔记。 在这些笔记中，有人因为误删聊天记录而错过爱情、因为误删工作文件而丢掉工作，还有人因为误删照片而失去珍贵的回忆…… 这些故事听起来都很扎心。毕竟在这个数字化时代，我们每个人都是数据的生产者与消费者。
数据丢失的风险也如影随形：硬盘损坏、电脑被偷、误删文件、感染病毒、手机丢失、意外断电…… 一旦数据丢失，后果不堪设想。 不过好在，只要数据没有被新数据覆盖，就有恢复的可能。今天，就为大家介绍一款专业的数据恢复工具——EasyRecovery 17中文版本。 它是一款功能强大的数据恢复软件，支持多种存储介质的数据恢复，包括硬盘、移动硬盘、U盘、光盘、数码相机、手机等设备。无论是误删除、误格式化还是分区丢失，EasyRecovery都能帮您找回丢失的文件。
「EasyRecovery免费无需激活版绿色版」最新版夸克网盘获取链接：先保存以防失效
https://pan.quark.cn/s/00347f5d6b0e
EasyRecovery-mac最新官方版本下载:
https://wm.makeding.com/iclk/?zoneid=50201
EasyRecovery-win最新官方版本下载:
https://wm.makeding.com/iclk/?zoneid=50200
接下来，就让我们一起来看看EasyRecovery 17中文版本的具体功能吧！ 一、全面兼容各类存储设备 EasyRecovery 17中文版本支持从各种存储媒介中恢复数据。 这包括但不限于计算机硬盘、移动硬盘、U盘、SD卡、CF卡、MMC卡、SM卡、记忆棒、XD卡、光盘、软驱等设备。 这意味着，无论您的数据存储在哪种设备上，只要该设备能够被计算机识别并读取，EasyRecovery就能帮助您进行数据恢复。
二、深度扫描与智能过滤 EasyRecovery 17中文版本具备强大的深度扫描能力。 它能够深入到存储设备的底层，对丢失的数据进行全面扫描和检索。 它还提供了智能化的过滤功能，可以根据文件类型、日期、大小等多种条件对扫描结果进行过滤，帮助用户快速定位目标文件。
三、支持多种恢复场景 EasyRecovery 17中文版本针对不同类型的数据丢失场景提供了定制化的解决方案。 无论是因误删除、误格式化、分区丢失、病毒攻击等原因导致的文件丢失，都能通过相应的恢复模式进行恢复。 例如，对于误删除的文件，可以选择“误删除恢复”模式进行恢复；对于误格式化的磁盘，可以选择“误格式化恢复”模式进行恢复。这种针对性的解决方案，大大提高了数据恢复的成功率。
四、安全可靠且易于操作 EasyRecovery 17中文版本非常注重用户的数据安全。 在恢复过程中，它不会对原始数据造成任何破坏或覆盖。 它的操作界面也非常友好，即使是初次使用的用户也能轻松上手。
五、支持预览和选择性恢复 在恢复过程中，EasyRecovery 17中文版本还支持对扫描结果进行预览。用户可以查看文件的缩略图、文件名等信息，确认是否是自己需要恢复的文件。 它还支持选择性恢复，即用户可以根据自己的需求选择部分文件进行恢复。这不仅提高了恢复效率，也避免了不必要的空间浪费。
六、灵活的保存选项 在恢复完成后，EasyRecovery 17中文版本为用户提供了灵活的保存选项。 用户可以选择将恢复出的文件保存到任意位置，包括原位置或其他安全的位置。同时，它还支持直接将恢复出的文件刻录到光盘上，方便用户进行备份和存储。
七、强大的兼容性和稳定性 EasyRecovery 17中文版本具有强大的兼容性和稳定性。 它支持各种操作系统和文件系统，包括Windows、Mac和Linux等。同时，它还具备出色的稳定性和可靠性，能够在各种复杂环境下稳定运行并成功恢复数据。
八、专业级的数据恢复服务 除了提供强大的数据恢复功能外，EasyRecovery 17中文版本还提供专业级的数据恢复服务。如果用户在使用过程中遇到困难或问题，可以联系其专业的客服团队获取帮助和支持。
九、终身更新与维护 购买EasyRecovery 17中文版本后，用户将享受终身的产品更新和维护服务。这意味着您可以一直使用最新版本的软件并获得最新的技术支持和服务。 十、实惠的价格与优惠活动 EasyRecovery 17中文版本的价格非常实惠且具有竞争力。同时还会不定期开展各种优惠活动和折扣促销活动，为用户提供更超值的购物体验。
无论你是因为手滑误删了重要文件，还是因为病毒攻击导致数据丢失，都可以尝试使用EasyRecovery 17中文版本来解决问题。 再强调一下，虽然数据恢复软件可以帮助我们找回丢失的数据，但最重要的还是要做好数据备份工作，避免因数据丢失而带来的损失和麻烦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/defa99e75cd6beb217ad000007dddb55/" rel="bookmark">
			【Qt】布局管理器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		界面中各元素排列有序往往会更加的美观，Qt Designer虽然通过拖拽的方式添加控件简便了开发，但手动界面编排还是较为麻烦，为此Qt提供了布局管理器
布局管理器用于管理和安排窗口控件(widgets)，帮助确保界面在不同平台和窗口尺寸下保持一致和合理的布局。布局管理器负责调整和定位窗口部件，以便它们在窗口大小变化时能适应不同的布局需求
QBoxLayout QBoxLayout 是矩形布局管理器，其管理的界面范围是一个矩形。Qt将其封装，形成了QVBoxLayout (垂直布局管理器) 和 QHBoxLayout (水平布局管理器) QVBoxLayout 垂直布局 QVBoxLayout 是垂直布局管理器，用于将窗口部件垂直排列。其按照添加顺序依次排列窗口控件，直到空间不足为止。
核心属性
属性说明layoutLeftMargin左侧边距layoutRightMargin右侧边距layoutTopMargin上方边距layoutBottomMargin下方边距layoutSpacing相邻元素之间的间距 核心方法
方法说明addWidget(QWidget *widget, int stretch = 0, Qt::Alignment alignment = Qt::Alignment())将控件添加到布局管理器中，第一个参数是控件指针，第二个参数是拉伸系数(后续讲解)addSpacerItem(QSpacerItem *spacerItem)在布局管理器中添加一个可调整大小的空白控件(QSpacerItem)，可设置最小尺寸、最大尺寸和伸展系数。在其构造函数指定相关系数addSpacing(int size)添加固定大小的空白间隔，指定一个整数作为参数，表示在布局中插入的像素间隔addStretch(int stretch = 0) 添加一个伸展因子，可以理解为一个占位符，会根据布局中其他窗口控件的大小，自动调整器大小以填充可用空间
参数表示伸展因子的大小
addStruct(int size) 添加一个固定大小的占位控件
与addSpacing类似，但addStruct创建的不是一个真正的控件，而是一次固定大小的占位
addLayout(QLayout *layout)布局管理器嵌套布局管理器insertWidget(int index, QWidget *widget, int stretch = 0, Qt::Alignment alignment = Qt::Alignment())上述方法都有insert系列，多了第一个参数index，表示插入的下标，若index = 0，则插入后的widget为第0个insert ........ 布局管理器只用于界面布局，所以没有提供信号
代码示例：使用垂直布局管理器规范三个按钮
编写widget.cpp，在构造函数中初始化相应控件
Widget::Widget(QWidget *parent) : QWidget(parent) , ui(new Ui::Widget) { ui-&gt;setupUi(this); QVBoxLayout *layout = new QVBoxLayout(); QPushButton *button1 = new QPushButton("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/defa99e75cd6beb217ad000007dddb55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ef5d02551491545d553bd5c1520bb84/" rel="bookmark">
			【区块链&#43;食品安全】湖南省食品行业联合会：溯链中国—基于区块链的食品安全可信追溯平台 | FISCO BCOS应用案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		食品安全追溯体系的建设，能够切实加强食品安全监管，确保人民群众饮食安全和身体健康，是创建食品安全城市必不可少的一部分。然而，中心化存储、信息孤岛、窜货是传统溯源行业最大痛点。区块链技术的快速发展， 使得防伪溯源流程不可篡改，各方的可信数据协作成为可能。
平台以区块链技术为主导，结合物联网、人工智能、 大数据、智能防伪等前沿技术，使品牌厂商不仅在生产过程中保持信息的透明不可篡改，更能够在流通过程中做到真正的防伪可溯源。通过区块链平台系统，食品从生产源 头即可进行监控，在生产、运输、进口、销售各环节逐层监管产品流向，有效降低造假、售假带来的损害和损失， 全面提升企业品牌价值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7489a613860331ba1f1f552b1e4ea2e/" rel="bookmark">
			bert-base-chinese模型的完整训练、推理和一些思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 使用google-bert/bert-base-chinese模型进行中文文本分类任务，使用THUCNews中文数据集进行训练，训练完成后，可以导出模型，进行预测。
项目详细介绍和数据下载 数据集下载地址
Github完整代码
现记录训练过程中的一些感悟 1、训练时遇到的两个核心参数warmup_steps和weight_decay 代码片段如下
需要弄明白一些基础概念
epoch：指模型在训练过程中遍历完整个训练数据集一次。
step：指模型在训练过程中处理完一个batch的数据并完成一次梯度更新。
batch_size： 指在一次step中模型用于训练的数据量。
假设 训练数据集有 n 个样本，每个epoch的step计算方式
s t e p = n b a t c h _ s i z e step = \frac{n}{batch\_size} step=batch_sizen​
训练过程的总步数为
s t e p s = s t e p × n u m _ t r a i n _ e p o c h s steps = step \times num\_train\_epochs steps=step×num_train_epochs
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7489a613860331ba1f1f552b1e4ea2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/947d9cfb279bb601524244badb531b6f/" rel="bookmark">
			EasyExcel-高性能的 Java Excel 处理库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EasyExcel 是阿里巴巴开发的一个高性能的 Java Excel 处理库，主要用于处理大规模的 Excel 文件。它特别注重性能，优化了内存消耗，适合处理大数据量的 Excel 文件，避免了传统 Excel 库在处理大文件时的性能瓶颈。
主要功能 高性能：
流式读取：支持基于流的读取方式（SAX 解析），减少内存消耗，适合处理大数据量的 Excel 文件。高效写入：通过逐行写入的方式，优化写入性能，避免将所有数据一次性加载到内存中。 简化操作：
提供了简洁的 API，用于读取和写入 Excel 文件，减少了繁琐的配置和操作步骤。 支持多种格式：
支持 .xlsx 文件格式（即 Excel 2007 及更高版本），不支持 .xls 文件格式（即 Excel 2003 及以下版本）。 主要类和方法 1. EasyExcel EasyExcel 类是库的核心类，提供了静态方法用于创建读取器和写入器。它的常用方法包括：
读取 Excel 文件：
EasyExcel.read(String fileName, Class&lt;?&gt; pojoClass, ReadListener&lt;?&gt; readListener) fileName：Excel 文件的路径。pojoClass：映射 Excel 数据的 POJO 类。readListener：用于接收读取的数据的监听器。示例：
EasyExcel.read("file.xlsx", MyClass.class, new PageReadListener&lt;MyClass&gt;(dataList -&gt; { for (MyClass data : dataList) { System.out.println(data); } })).sheet().doRead(); 写入 Excel 文件：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/947d9cfb279bb601524244badb531b6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4b08dfc44ed89ed4fcb9a5a724286cf/" rel="bookmark">
			基于Boosting的四种机器算法的简单运用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Boosting是一种集成学习算法，其核心思想是通过组合多个弱学习器来构建一个强学习器。本文包含 AdaBoost、Gradient Boosting Decision Tree（GBDT）、XGBoost、LightGBM 四种机器学习算法，主要给出示例代码以及模型参数，旨在快速的上手相应算法。
目录
一、 AdaBoost
1、AdaBoostClassifier（分类）
2、AdaBoostRegressor（回归）
二、GBDT
1、GradientBoostingClassifier（分类）
2、GradientBoostingRegressor（回归）
三、XGBoost
1、XGBClassifier（分类）
2、XGBRegressor（回归）
四、LightGBM 1、LGBMClassifier（分类）
2、LGBMRegressor （回归）
总结 一、 AdaBoost AdaBoost（Adaptive Boosting，自适应增强）算法是一种集成学习技术，通过结合多个弱分类器来构建一个强分类器。
AdaBoost 的核心思想是通过修正数据的权重来训练一系列的弱学习器,由这些弱学习器的预测结果进行加权求和, 得到我们最终的预测结果。
1、AdaBoostClassifier（分类） 官方链接：AdaBoostClassifier — scikit-learn 1.5.1 documentation
class sklearn.ensemble.AdaBoostClassifier
示例代码：
from sklearn.ensemble import AdaBoostClassifier from sklearn.tree import DecisionTreeClassifier from sklearn.datasets import load_iris from sklearn.model_selection import train_test_split from sklearn.metrics import classification_report # 加载数据集 iris = load_iris() X, y = iris.data, iris.target # 划分训练集和测试集 X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4b08dfc44ed89ed4fcb9a5a724286cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf4c77c52434c1a8be6b298ed8b19bd8/" rel="bookmark">
			SSM基于web的火车订票系统设计s5088 座位预定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本系统（程序+源码+数据库+调试部署+开发环境）带论文文档1万字以上，文末可获取，系统界面在最后面。
系统程序文件列表 系统内容：用户,票务信息
开题报告内容 一、选题背景与意义
随着互联网的普及和铁路运输业的发展，传统的火车订票方式已难以满足旅客日益增长的需求。传统的订票方式存在效率低下、信息不准确、票源紧张等问题。因此，开发一个基于SSM（Spring、Spring MVC、MyBatis）框架的Web火车订票系统显得尤为重要。该系统能够实时更新票务信息，提供便捷的订票服务，减少人工操作，提高订票效率，并增强用户体验。同时，该系统还有助于铁路运输企业优化运力配置，提高经营效益，推动行业的绿色发展。
二、研究内容
本研究旨在设计并实现一个功能完善、性能稳定、操作便捷的基于SSM框架的Web火车订票系统（S5088）。系统主要包括用户管理、票务信息管理、订单处理等功能模块。用户管理模块支持用户的注册、登录、个人信息管理等功能；票务信息管理模块实现火车时刻表、余票信息、票价的实时更新和查询；订单处理模块支持用户在线订票、退票、改签等操作，并确保订单处理的准确性和高效性。
三、研究方法与技术路线
本系统采用SSM框架进行开发，其中Spring负责业务对象的管理和业务逻辑的实现，Spring MVC处理Web层的请求分发，MyBatis作为数据持久层框架，负责与数据库的交互。同时，采用MySQL作为关系型数据库管理系统，存储应用数据。系统采用分层架构设计思想，将系统划分为表示层、业务逻辑层和数据访问层，以提高系统的可维护性和可扩展性。
四、预期成果
通过本项目的实施，预期能够开发出一个功能完善、性能稳定、操作便捷的Web火车订票系统（S5088），满足广大旅客的出行需求，提升铁路运输服务的质量和效率。同时，该系统将具备良好的可扩展性和安全性，能够应对高峰期的大量并发请求，保护用户数据的隐私和安全。
五、进度安排
本项目计划分为需求分析、系统设计、系统开发、系统测试与优化等阶段进行，预计在规定时间内完成所有工作，并达到预期的成果。
以上为基于SSM框架的Web火车订票系统（S5088）的开题报告，希望各位评审老师给予指导和支持。
进度安排： 序号
时间要求
应完成的内容（任务）提要
1
2024年12月27日－2025年02月25日
选题、调研、搜集资料
2
2025年02月27日－2025年03月03日
论证、开题
3
2025年03月06日－2025年03月17日
用户需求分析与系统设计
4
2025年04月01日－2025年04月22日
毕业设计系统功能实现及设计过程总结与文档整理
5
2025年04月24日－2025年04月28日
中期检查
6
2025年05月02日－2025年05月20日
系统功能进一步完善
7
2025年05月22日－2025年06月26日
毕业论文初稿完成、并修改
8
2025年05月29日－2025年06月02日
论文查重、定稿、打印
9
2025年06月05日－2025年06月09日
软件验收、准备答辩
10
2025年06月12日－2025年06月16日
答辩
参考文献： [1]王方.信息化教务管理系统设计与实现[J].信息记录材料,2021,22(02):223-225.DOI:10.16009/j.cnki.cn13-1295/tq.2021.02.148.
[2]胡彬.高校教务管理系统信息化建设研究[J].教育信息化论坛,2021(06):67-68.
[3]常佳宁.基于Web的教务系统设计开发[J].中国科技信息,2021(13):80-81.
[4]魏然.探讨高校教务管理系统信息化研究与应用[J].中国多媒体与网络教学学报(上旬刊),2021(07):7-9.
[5]卢春华,卢新华,何嘉琪.中学教务系统的设计[J].信息技术与信息化,2021(08):206-208.
[6]周淑燕.南京交院顶点教务管理系统建设缺陷及对策研究[J].科技视界,2021(25):167-169.DOI:10.19694/j.cnki.issn2095-2457.2021.25.75.
[7]陈懿炜.远程教育中的通用教务系统分析[J].集成电路应用,2021,38(09):258-259.DOI:10.19339/j.issn.1674-2583.2021.09.127.
[8]王璐.基于UML的教务管理系统建模与分析[J].信息记录材料,2021,22(11):243-245.DOI:10.16009/j.cnki.cn13-1295/tq.2021.11.114.
[9]冯王美子.信息化技术在教务管理系统中的应用[J].电子技术,2021,50(11):256-257.
[10]惠晓萍.高职院校教务管理系统的应用问题及对策[J].现代职业教育,2021(49):202-203.
[11]沈镱武.教务管理系统在高校的现状分析研究[J].电脑知识与技术,2022,18(14):125-126.DOI:10.14004/j.cnki.ckt.2022.0873.
[12]臧淑龙. 高中教务管理系统的设计与实现[D].南昌大学,2022.DOI:10.27232/d.cnki.gnchu.2022.002835.
[13]陈杰志,钟雪梅.教务网络管理系统优化方案的研究与实践[J].黑龙江科学,2022,13(15):75-76+79.
[14]Berdimuratovna Kenjebayeva Klara,Cairns R.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf4c77c52434c1a8be6b298ed8b19bd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45ee45c0e165d19cdd283363364d203b/" rel="bookmark">
			【数据结构】算法复杂度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
正文开始
1. 数据结构前⾔ 1.1 数据结构 数据结构(Data Structure)是计算机存储、组织数据的⽅式，指相互之间存在⼀种或多种特定关系的数据元素的集合。没有⼀种单⼀的数据结构对所有⽤途都有⽤，所以我们要学各式各样的数据结构， 如：线性表、树、图、哈希等 1.2 算法 算法(Algorithm):就是定义良好的计算过程，他取⼀个或⼀组的值为输⼊，并产⽣出⼀个或⼀组值作为输出。简单来说算法就是⼀系列的计算步骤，⽤来将输⼊数据转化成输出结果。 如何学好数据结构和算法 2. 算法效率 算法效率是指算法解决问题所需的时间或空间资源。 常用的衡量算法效率的指标有时间复杂度和空间复杂度。 2.1 复杂度的概念 算法在编写成可执⾏程序后，运⾏时需要耗费时间资源和空间(内存)资源 。因此衡量⼀个算法的好 坏，⼀般是从时间和空间两个维度来衡量的，即时间复杂度和空间复杂度。 时间复杂度主要衡量⼀个算法的运⾏快慢，⽽空间复杂度主要衡量⼀个算法运⾏所需要的额外空间。 在计算机发展的早期，计算机的存储容量很⼩。所以对空间复杂度很是在乎。但是经过计算机⾏业的迅速发展，计算机的存储容量已经达到了很⾼的程度。所以我们如今已经不需要再特别关注⼀个算法的空间复杂度。 2.2 复杂度的重要性 复杂度是评估算法或程序性能的重要指标。它衡量了算法在处理输入数据时所需的时间和空间资源。复杂度越低，意味着算法执行所需的资源越少，效率越高。 复杂度的重要性体现在以下几个方面：
时间效率：在大数据量下，算法的执行时间可能会成倍增长。通过比较不同算法的复杂度，可以选择更高效的算法，缩短程序的运行时间。
空间效率：算法的空间复杂度决定了它在内存中所需的资源。随着数据量的增长，算法的空间消耗也会相应增加。通过选择空间复杂度较低的算法，可以最大限度地节省内存资源。
可维护性：复杂度较低的算法往往更易于理解和维护。它们通常具有更少的代码行数和更少的嵌套结构，使得程序的逻辑更加清晰，易于调试和修改。
可拓展性：复杂度较低的算法在处理大规模问题时更具有扩展性。通过优化算法的复杂度，可以使其在处理更大规模的数据时仍能保持较高的效率。
综上所述，复杂度的重要性在于它对算法或程序的性能评估和优化提供了指导。通过对复杂度的分析，可以选择更高效的算法，提高程序的执行效率，并在处理大规模问题时提供良好的扩展性和可维护性。
3. 时间复杂度 定义：在计算机科学中，算法的时间复杂度是⼀个函数式T(N)，它定量描述了该算法的运⾏时间。时间复杂度是衡量程序的时间效率，那么为什么不去计算程序的运⾏时间呢？ 1. 因为程序运⾏时间和编译环境和运⾏机器的配置都有关系，⽐如同⼀个算法程序，⽤⼀个⽼编译 器进⾏编译和新编译器编译，在同样机器下运⾏时间不同。 2. 同⼀个算法程序，⽤⼀个⽼低配置机器和新⾼配置机器，运⾏时间也不同。 3. 并且时间只能程序写好后测试，不能写程序前通过理论思想计算评估。 那么算法的时间复杂度是⼀个函数式T(N)到底是什么呢？这个T(N)函数式计算了程序的执⾏次数。通过c语⾔编译链接章节学习，我们知道算法程序被编译后⽣成⼆进制指令，程序运⾏，就是cpu执⾏这些编译好的指令。那么我们通过程序代码或者理论思想计算出程序的执⾏次数的函数式T(N)，假每句指令执⾏时间基本⼀样(实际中有差别，但是微乎其微)，那么执⾏次数和运⾏时间就是等⽐正相关，这样也脱离了具体的编译运⾏环境。执⾏次数就可以代表程序时间效率的优劣。⽐如解决⼀个问题的算法a程序T(N) = N，算法b程序T(N) = N^2，那么算法a的效率⼀定优于算法b。 案例： // 请计算⼀下Func1中++count语句总共执⾏了多少 次？ void Func1(int N) { int count = 0; for (int i = 0; i &lt; N ; ++ i) { for (int j = 0; j &lt; N ; ++ j) { ++count; } } for (int k = 0; k &lt; 2 * N ; ++ k) { ++count; } int M = 10; while (M--) { ++count; } } Func1 执⾏的基本操作次数： T ( N ) = N 2 + 2 ∗ N + 10 • N = 10 T(N) = 130 • N = 100 T(N) = 10210 • N = 1000 T(N) = 1002010 通过对N取值分析，对结果影响最⼤的⼀项是 N 2 实际中我们计算时间复杂度时，计算的也不是程序的精确的执⾏次数，精确执⾏次数计算起来还是很⿇烦的(不同的⼀句程序代码，编译出的指令条数都是不⼀样的)，计算出精确的执⾏次数意义也不⼤，因为我们计算时间复杂度只是想⽐较算法程序的增⻓量级，也就是当N不断变⼤时T(N)的差别，上⾯我们已经看到了当N不断变⼤时常数和低阶项对结果的影响很⼩，所以我们只需要计算程序能代表增⻓量级的⼤概执⾏次数，复杂度的表⽰通常使⽤⼤O的渐进表⽰法。 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45ee45c0e165d19cdd283363364d203b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5657d88551a3b090dbb076f67dddc7b/" rel="bookmark">
			38-PCB布局实战实战及优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.先对布局好的器件进行锁定 1.根据模块化布局
2.电容尽量靠近ic附近，可以起到很好的滤波效果
3.复位按键尽量摆在容易按键的地方，比如周围
。。。。
最后进行对齐
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fef8d352259aaaee0b2b851b2407ed5/" rel="bookmark">
			C&#43;&#43;入门基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.C++的第一个程序
2.命名空间 2.1namespace的价值
2.2namespace的定义
2.3命名空间的使用
3.C++中的输入和输出
4.缺省参数
5.函数重载
6.引用
6.1引用的概念和定义
6.2引用的特性
6.3引用的使用
6.4const引用
6.5指针和引用的关系
7.inline
8.nullptr
1.C++的第一个程序 首先说明，C++兼容C语言绝大多数的语法，所以C语言实现的代码在C++的编译器中绝大部分也能运行，C++中需要把定义文件代码后缀改为.cpp，vs编译器看到是.cpp就会调⽤C++编译器编译，linux下要⽤g++编译，不再是gcc。
C语言版本的hello world
// test.c #include&lt;stdio.h&gt; int main() { printf("hello world\n"); return 0; } C++版本的hello world
// test.cpp #include&lt;iostream&gt; using namespace std; int main() { cout &lt;&lt; "hello world\n" &lt;&lt; endl; return 0; } 2.命名空间 2.1namespace的价值 在C/C++中，变量、函数和后⾯要学到的类都是⼤量存在的，这些变量、函数和类的名称将都存在于全局作⽤域中，可能会导致很多冲突。使⽤命名空间的⽬的是对标识符的名称进⾏本地化，以避免命名冲突或名字污染，namespace关键字的出现就是针对这种问题的。
#include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; namespace xiaoc { int rand = 10; } int main() { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fef8d352259aaaee0b2b851b2407ed5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8af4d20eb4b35f8ecb738575f8e231f3/" rel="bookmark">
			GD32替换STM32的型号对应选型方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： GD32是国产厂商兆易创新研发的一系列32位单片机，与STM32具有高度兼容性。近年来，得益于其更具竞争力的价格优势以及部分厂商面临的制裁问题，GD32作为STM32替代品的使用比例逐年上升。
由于GD32与STM32的高度兼容性，许多工程师选择使用STM32的库函数来开发GD32项目。确保为所用GD32型号选用恰当的STM32型号库，是实现有效开发的前提。
选择STM32型号库时，应依据GD32与STM32在引脚数、FLASH容量、RAM大小等硬件资源的对应关系进行。本文指导如何通过STM32CubeMx工具选择与GD32兼容的STM32型号，旨在为开发者提供参考。
STM32与GD32的命名规则 从STM32/GD32的型号名称上可以了解到单片机的的硬件资源
1.STM32命名规则：
2.GD32命名规则：
GD32的命名规则与STM32类似
替换选型步骤： 1.假设在GD32官网，针对硬件资源需求，您选择了基于Cortex-M4内核的GD32F407VET6芯片。
GD32官网选型链接：https://www.gigadevice.com.cn/product/mcu/
2.可以利用STM32CubeMx工具来辅助选择与GD32F407VET6硬件资源相似的STM32型号。在CubeMx中，根据核心类型（Core）、封装尺寸(Package)、Flash容量和RAM大小等关键参数进行筛选，最终确定STM32F407VE×和STM32F417VE×型号作为兼容选项。这两个STM32型号的库文件与GD32F407VET6芯片开发兼容。
其中STM32F417VE×型号特别包含了HWcrypto硬件加密库，为需要加密功能的开发者提供了额外选择。
参考博客： https://www.pcbcopy.com/2018/jishu_0827/1994.html
https://blog.csdn.net/Yin_w/article/details/129603984
https://blog.csdn.net/ST_Liam/article/details/108922753
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a456bd4b86792cdd5688f41af6a769e0/" rel="bookmark">
			37-交互式模块化布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.垂直分割 2.先关闭所有飞线 n-&gt;隐藏连接-&gt;全部
3.按照原理图进行模块划分 4.划分结束后，打开飞线 5.设置class 退出高亮状态：shift+c
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/253202b1c47924e04383208d97182068/" rel="bookmark">
			Dbeaver连接达梦数据库教程（图文版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本章教程，主要介绍如何用Dbeaver连接国产达梦数据库。
达梦数据库Docker部署教程参考：https://yang-roc.blog.csdn.net/article/details/141158807
一、Dbeaver安装包下载 下载Dbeaver：https://dbeaver.io/
在这里就不演示安装过程了，安装过程很简单，下载之后，默认安装即可。
二、准备达梦数据库驱动包 通过百度网盘分享的文件：达梦数据库
链接：https://pan.baidu.com/s/1Kad1rjUgfUr5HS5CZDFnPA?pwd=ecau 提取码：ecau
–来自百度网盘超级会员V1的分享
官网下载：https://eco.dameng.com/document/dm/zh-cn/app-dev/java-hibernate-frame.html
三、自定义连接配置 1、打开驱动管理器 2、创建新驱动 驱动名称达梦数据库类名dm.jdbc.driver.DmDriverURL模板jdbc:dm://{host}:{port}默认端口5236 3、编辑驱动 导入刚才下载的达梦数据库驱动包。选中驱动，执行找到类，然后确定
四、创建连接 在左侧空白处，右键创建连接
选择我们刚才自定义的驱动名称
五、填写数据库连接信息 到这里，我们就成功的用Dbeaver连接上了我们的达梦数据库。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27d9dd0d20d498ba77611d468453d3e0/" rel="bookmark">
			这 2 个 GitHub 项目，YYDS!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01
🧠 构建你的第二大脑：SuperMemory
在这个信息爆炸的时代，我们每天都在互联网上浏览和保存大量的信息，但往往这些宝贵的数据就像被扔进了黑洞，再也没有被回顾和利用。
SuperMemory 开源项目应运而生，旨在解决这一问题，帮助你构建一个属于自己的第二大脑。
🌟 项目简介
SuperMemory 通过一个 Chrome 插件来导入推文、保存网站和内容。这个项目被设计成一个类似于 ChatGPT 的工具，但它专注于你的书签和个人知识库。
🌈 核心功能
SuperMemory 基于的技术栈包括但不限于 Nextjs 14、Next Auth、Drizzle ORM、Cloudflare D1 数据库、TailwindCSS、React 等。项目由 turborepo 管理，分为三个主要模块：web UI、Chrome 扩展和 AI 后端。
使用 SuperMemory 开源项目你能够轻松捕捉和保存想法，导入、组织并在需要时重新出现书签，存储和管理你认为有用的的信息。
导入和利用你保存的推文，快速找到任何保存的信息，使用带有 AI 辅助的Markdown编辑器进行内容创作，还能和这个知识库进行对话，并且开源可以本地部署。
🔗开源地址
开源地址：https://github.com/supermemoryai/supermemory SuperMemory 不仅仅是一个工具，它是一个全新的个人知识管理方式。欢迎大家踊跃贡献代码，共同打造能够提升每个人信息处理能力的强大工具。
02
📂 跨平台文件管理的好用工具
刚刚推荐的项目是个人想法、浏览知识的管理。Spacedrive 是一个开源的跨平台针对个人文件的管理，由 Rust 编写，支持虚拟分布式文件系统（VDFS），目前在 GitHub 上已经获得了 30k 的 Star 。
Spacedrive 的动机源于对我们数据控制的需求。不再依赖 iCloud 这样的云服务。我们的数据是我们的资产，不应该让操作系统成为壁垒。
🚀 核心功能
Spacedrive旨在为用户提供一个安全、便捷、高效的文件管理解决方案，简洁直观，易于操作，支持拖放上传下载。提供充足的存储空间，支持文件实时更新，确保多设备间同步；快速定位文件，节省时间；
支持团队共享，设置权限，保障文件安全，提高工作效率；智能分类文件，减轻手动整理负担；查看、比较、恢复文件历史版本；采用高级加密技术，确保数据安全。
开源地址：https://github.com/spacedriveapp/spacedrive Spacedrive 不仅仅是一个文件管理器，它是你数字生活的私人助理，帮助你以一种安全、直观且开源的方式管理你的数字世界。随着项目的不断发展，相信 Spacedrive 将成为不错的跨平台文件管理工具。
长按扫描二维码 关注逛逛 GitHub
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2937b126dcfb453e1cad5b5b93890a4e/" rel="bookmark">
			人工智能算法，图像识别技术；基于大语言模型的跨境商品识别与问答系统；图像识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
一 .研究背景
二,大语言模型介绍
三,数据采集与预处理 商品识别算法
四. 跨境商品问答系统设计
五.需要源码联系
一 .研究背景 在当今全球化的背景下，跨境电商行业迅速发展，为消费者提供了更广泛的购物选择和更便利的购物方式。然而，随着跨境电商平台上商品种类的不断增加和信息量的快速增长，消费者在面对海量跨境商品时往往难以准确识别和选择符合自身需求的产品，导致购物体验的不便与低效。
传统的商品搜索引擎虽然能够帮助消费者查找特定商品，但存在着信息匹配度低、搜索结果不精准、无法回答用户具体问题等问题。因此，开发一种能够更好地帮助消费者识别和选择跨境商品的系统变得尤为重要[1]。
随着大数据和人工智能技术的快速发展，大语言模型作为一种新兴的自然语言处理技术，日益受到学术界和产业界的关注。大语言模型具有强大的语义理解和生成能力，可以根据上下文信息生成连贯的语言表达，被广泛应用于文本生成、机器翻译、对话系统等领域。因此，结合大语言模型的能力，利用其对跨境商品信息进行准确建模和表达，开发出一种跨境商品识别与问答系统，可以有效提高消费者的购物体验并增强购物决策的准确性。
基于以上背景，本论文旨在借助大语言模型技术，通过构建一个强大的跨境商品识别与问答系统，帮助消费者更快速地识别和选择符合需求的跨境商品，提升购物体验，提供更加智能和个性化的购物建议，进一步推动跨境电商行业的发展。通过本研究，将探索大语言模型在跨境电商领域的应用前景，挖掘其在商品识别与问答系统中的优势和潜力，为相关领域的研究和实践提供新的思路与方法。
二,大语言模型介绍 大语言模型是近年来自然语言处理领域的突破性技术之一，具有强大的文本生成和理解能力。它采用深度学习算法，通过大规模文本数据的训练，学习到语言的潜在规律和语义信息，实现对自然语言文本进行模型化和处理。
目前，BERT（Bidirectional Encoder Representations from Transformers）和GPT（Generative Pre-trained Transformer）是最为知名且常见的大语言模型代表。BERT模型基于Transformer架构，通过双向上下文表示学习，能够同时考虑前后文信息，有效提升对文本的理解和生成能力。GPT模型则是一个基于Transformer架构的单向生成式模型，通过自回归方式逐词预测生成文本，能够生成流畅自然的文本。
大语言模型在自然语言处理任务中发挥着重要作用，具有以下几个显著特点上下文理解能力： 大语言模型能够通过学习上下文信息，准确理解和推断文本内容，从而在生成和理解文本时更加准确和连贯。
迁移学习能力： 大语言模型通过在大规模数据上进行预训练，可以学习到通用的语言规律和语义信息，便于在不同任务上进行迁移学习，实现更快速的模型优化和应用。
多样化应用能力： 大语言模型可以广泛应用于文本生成、机器翻译、语义理解、问答系统等各种自然语言处理任务，为多种应用场景提供强大支持。灵活性和可扩展性： 大语言模型的模型结构和参数设置相对灵活，可以根据任务需要进行调整和扩展，同时由于其模块化设计，易于将新领域的信息整合进模型中。
在具体应用方面，基于大语言模型的跨境商品识别与问答系统可以利用其强大的文本理解和生成能力，帮助消费者更准确地理解和查询跨境商品信息。通过模型对海量商品描述和用户问题进行处理和匹配，系统能够快速找到满足用户需求的商品，并提供专业、精准的答案，为用户购物决策提供有力支持。
总的来说，大语言模型作为一种前沿技朧，为自然语言处理领域带来了革命性的进展，其在跨境商品识别及问答系统中的应用，将为电商行业带来更智能、高效的服务，提升用户体验，推动整个行业的发展。
三,数据采集与预处理 商品识别算法 基于大语言模型的跨境商品识别算法包括以下关键步骤：数据准备首先，收集跨境商品数据，包括商品标题、描述、价格等信息。使用自然语言处理技术对文本数据进行清洗、分词、去除停用词等预处理操作，将文本数据转换为模型可输入的格式。构建词嵌入在模型训练之前，需要构建商品标题和描述的词嵌入表示。可以使用预训练的词嵌入模型（如Word2Vec、GloVe）或者通过大规模文本数据集训练自定义的词向量模型。
构建大语言模型基于Transformer架构的大语言模型（如BERT、GPT）用于理解商品标题和描述的语义信息。将商品标题和描述输入到大语言模型中，通过多层自注意力机制和前馈神经网络学习文本之间的语义关系。
训练模型在识别阶段，需要训练一个分类模型，例如基于BERT的文本分类器或相似度计算模型。将已标记的跨境商品数据集输入到模型中进行监督学习，优化模型参数以实现准确的商品分类和识别。特征提取与分类 在识别阶段，通过大语言模型提取商品标题和描述的语义特征。可以使用模型的最后一层隐藏状态或者通过特征提取接口获取文本的表示，然后使用这些特征进行商品分类或相似度计算。模型应用 将训练好的商品识别模型应用于实际场景中，用户输入商品问题后，系统利用大语言模型理解用户意图，并通过训练好的模型识别和推荐相关的跨境商品。
基于大语言模型的跨境商品识别算法能够充分利用文本数据的语义信息，提高商品分类的准确性和推荐的质量。通过不断优化模型结构和训练数据，可以使系统在实际应用中具有更强大的商品识别能力，并为用户提供更智能、高效的商品查询和问答服务。
四. 跨境商品问答系统设计 本系统采用B/S结构(Browser/Server,浏览器/服务器结构)和基于Web服务两种模式，是一个适用于Internet环境下的模型结构。系统工作原理图如图
系统的工作流程包括以下一些关键环节：
(1)用户注册。在每一个用户使用该系统之前需要注册，系统会将用户输入的信息记录到用户模型中。
(2)用户登陆。用户输入用户名和密码后，系统验证是否正确并决定用户是否能进入进行求职招聘。
(3)问题搜索。用户在搜索框中输入要搜索的关键字进行搜索，当用户输入多关键字的时候要用“空格”隔开。系统将根据用户的输入对关键字进行拆分和对相关内容搜索。
(4)问题发表。用户单击我要提问，在弹出的网站中输入问题，进行发表问题，问了进一步将问题阐释清楚积分达到100（含）分以上的用户在发表问题的时候可以附加一张不超过50Kb的JPG格式图片。提问一次将花费积分5
(5)问题回答。用户单击我要回答，在弹出的网站可以选择自己想要回答的问题，回答问题一次将增加积分5，如果回答的问题被提问者采纳为最佳问题将获得5分的奖励。
(6)用户信息管理。其中包括对用户信息的查询和修改，系统会根据修改后的用户信息重新自动合成网页内容。
(7)后台管理。管理员通过后台可以对用户、问题及答案进行管理。可以将不合法的信息和恶意用户进行删除 。
五.系统展示
输入账号密码，点击登录按钮，数据库读账号密码进行对比，验证正确则登录成功，验证不正确则登录失败可以看图
查看商品信息，可以加入购物车可以看图
点击选择文件上传相关图形，在下面可以输入相关问题对改图像进行描述可以看图
代码展示 五.需要源码联系 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3309063cd9add6d5fe3eff4d16c4de7/" rel="bookmark">
			【C&#43;&#43;类和对象（中）】—— 我与C&#43;&#43;的不解之缘（四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 接下来进行类和对象中的学习，了解类和对象的默认成员函数
一、类和对象默认成员函数 默认成员函数就是用户没有显示实现，编译器会自动生成的成员函数。
一个类，我们不显示实现的情况下，编译器就会默认生成一下留个默认成员函数。
这里前4个（构造函数、析构函数、拷贝构造和赋值重载）是重难点。
C++11以后还会增加两个默认成员函数，移动构造和移动赋值。
默认成员函数十分重要，从以下两个方面去深入了解：
我们不写时，编译器默认生成的函数行为是什么，是否满足我们的需求编译器默认生成的函数不满足我们的需求，我们需要直接实现，那么如何自己实现呢？ 1.1、构造函数 构造函数，是特殊的成员函数；这里需要注意，虽然名字叫做构造函数，但是构造函数的主要任务不是开辟空间创建对象（我们经常使用的局部对象是栈帧创建时，空间就已经开辟 好了），而是对象实例化时初始化对象。
这里构造函数本质上是替代实现的Stack和Data类中所写的 Init 函数，构造函数自动调用这一特点就完美替代了 Init 函数。
1.1.1、构造函数的特点 构造函数的特点如下：
1、函数名和类名相同。
2、无返回值（返回值不需要写，void也不需要）。
3、对象实例化时系统会自动调用对应的构造函数。
4、构造函数可以重载
5、如果类没有显示定义构造函数，C++编译器会自动生成一个无参的默认构造函数；如果显示写了构造函数，编译器就不会再生成。
6、无参构造函数、全缺省构造函数、我们不写时编译器默认生成的构造函数，这三个都叫做默认构造函数。
7、我们不写，编译器默认生成的构造函数，对内置类型成员变量的初始化没有要求（是否初始看编译器）；对于自定义类型成员变量，要求调用这个成员函数的默认构造函数初始化（如果这个成员变量没有默认构造函数，就会报错（这里要初始化这个成员变量，需要使用初始化列表来解决，后面会学习到））。
1.1.2、构造函数 这里来看一下构造函数的前几个特点。
首先就是，构造函数的函数名和类名相同而且无返回值（不需要写返回值）
class Data { public: Data() { _year = 1; _month = 1; _day = 1; } private: int _year; int _month; int _day; }; 这里Data类里面的Data函数就是显示实现的构造函数（显示实现了构造函数，编译器就不会默认生成）；
再来看，构造函数可以重载，我们就可以这样写：
class Data { public: Data() { _year = 1; _month = 1; _day = 1; } Data(int year, int month, int day) { _year = year; _month = month; _day = day; } private: int _year; int _month; int _day; }; 这里两个构造函数就形成了重载，再创建对象时，不给参数就会调用第一个构造函数，给参数就会调用第二个参数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3309063cd9add6d5fe3eff4d16c4de7/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/52/">«</a>
	<span class="pagination__item pagination__item--current">53/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/54/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>