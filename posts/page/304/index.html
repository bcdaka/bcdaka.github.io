<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f8324e8d491fcfd557bc4dfaad01e34/" rel="bookmark">
			Mac下删除系统自带输入法ABC，正解！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景说明 MacOS 在 14.2 以下的系统存在中文输入法 BUG，会造成系统卡顿，出现彩虹圆圈。如果为了解决这个问题，有两种方法：
升级到最新的 14.5 系统使用第三方输入法
在使用第三方输入法的时候，会发现系统自带的 ABC 输入法无法删除，在网上看过部分教程但是最后都不好用，主要是忽略了一点。 关键点在于在 com. apple. HIToolbox. Plist 删除 Item 的方法是对的，但是很多人会遇到一个问题，删除之后，Item 马上就又回来了，导致一直无法删除成功。
现在详细的说一下删除方法：
二、关闭系统完整性保护 SIP 重启电脑，M 系列芯片长按开机键即可进入。点击顶部菜单栏中的终端输入命令关闭 SIP 机制：csrutil disable如弹出以下信息则表示禁用成功：Successfully disabled System Integrity Protection. Please restart the machine for the changes to take effect.再次重启即可 详细可看他人图文。
三、找到 com. apple. HIToolbox. plist 文件 提前准备好 Xcode（可以在 app store 下载）或者 PlistEdit Pro (网上自行下载)在终端输入以下命令：sudo open ~/Library/Preferences/ 会弹出访达，找到文件 com. Apple. HIToolbox. Plist 打开。 3. 具体操作如图？，根据自己的文件位置找到其中 KeyboardLayout Name 为 ABC 的那一列，将整列 item 删掉，然后 command + S 保存 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f8324e8d491fcfd557bc4dfaad01e34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1d615346e22ae209e019132fca46f45/" rel="bookmark">
			Android Studio 中文汉化教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 中文语言包 一般jetbrains系列软件都可以使用“中文语言包”进行汉化，语言包如下图所示：
然而，Android Studio的Marketplace并没有类似的中文语言包（如下图），经过查阅相关资料发现需要去jetbrains的插件官网里面下载相关插件才能使用。
2. 下载语言包 Android Studio没有官方的中文语言包，但可以用IntelliJ的代替，插件官网地址如下：
https://plugins.jetbrains.com/plugin/13710-chinese-simplified-language-pack----/versions
由于最新的Android Studio是23年3月版，所以我这里下载的IntelliJ IDEA Ultimate的23年版中文语言包，版本号：233.199，兼容性范围：2023.3 — 2023.3.6。如果上面的插件下载地址打不开，可以直接点击下面的下载链接：
https://plugins.jetbrains.com/plugin/download?rel=true&amp;updateId=449758
3. 导入语言包 打开Android Studio，Configure → Plugins → Install plugins from disk → 选中你下载的语言包压缩包：
然后重启Android Studio，汉化完成！
学术会议征稿 想要了解国内主办的覆盖学科最全最广的学术会议，请前往AiScholar会议官网：https://www.ais.cn/如有意愿参会或投稿，可以找我获取邀请码，享受参会、投稿优惠，优先审核 创作不易，麻烦点点赞和关注咯！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7828677865f6edd928ae4f6dc6691dc9/" rel="bookmark">
			mysql 添加索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数据库索引 1、索引（index）的概念 （1）是一个排序的数据结构，帮助mysql快速查询、更新数据库表中的数据
（2）无须对整个表进行扫描，通过物理地址就可以找到所需数据
（3）为了提高表的搜索效率而对某些字段的值建立的数据结构；并不是所有字段都需要创建索引
2、索引的作用 （1）优点
①当数据量很大或查询涉及多个表时，使用索引，可以大大地提高数据查询速度，降低数据库的IO成本；
②通过索引对数据进行排序，可以降低数据库的排序成本，降低CPU的消耗；
③通过创建唯一性索引保证数据表数据的唯一性；
④可以加快表与表之间的连接
（2）缺点
①增加了数据库的存储空间
②降低了表的更新速度，插入和修改数据时花费更多的时间
3、索引的分类 （1）从物理存储的角度来划分：
①聚簇索引：索引顺序按照数据的物理位置，检索多行数据速度更快
②非聚簇索引：索引顺序不是按照数据的物理位置，检索单行数据的速度更快
（2）从逻辑的角度来划分
普通索引、唯一索引、主键索引、组合索引和全文索引
4、索引的添加与使用 （1）添加索引：通过某一个字段或某些字段添加
（2）索引使用：索引创建完成后无需调用，当数据库进行数据查询的时候，会自动使用索引
二、索引的分类 1、普通索引（可以有多个，对应MUL） （1）最基本的索引类型，不要求索引列的值唯一性
（2）创建普通索引的方式
直接创建 create index 索引名称 on 表名(字段名称(字段长度)); #字段长度可添加 修改表的方式创建 alter table 表名 add index 索引名称 (字段名称(字段长度)); 创建表时创建 create table 表名（字段1,字段2,字段3,primary key(字段名称),index 索引名称(字段名称(字段长度)); 示例
[root@localhost ~]# mysql -uroot -p #登录mysql mysql&gt; create database auth; #创建auth库 mysql&gt; use auth; #进入auth库 mysql&gt; create table auth.users(id int(10) not null, 创建users表，建立id字段，数据类型int，不为空 -&gt; name char(20) not null, -&gt; age varchar(10) default '', -&gt; primary key(id)); mysql&gt; desc users; #查看表结构，存在3个字段 mysql&gt; insert into users values('1','zhangsan','20'); mysql&gt; insert into users values('2','lisi','23'); mysql&gt; insert into users values('3','wangwu','26'); #字段下分别添加内容 mysql&gt; select * from users; #查看表中数据 直接创建方法 mysql&gt; create index index_age on auth.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7828677865f6edd928ae4f6dc6691dc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ffb471173e9c4262f8fecca99ae463a/" rel="bookmark">
			高效数据处理的前沿：【C&#43;&#43;】、【Redis】、【人工智能】与【大数据】的深度整合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.为什么选择 C++ 和 Redis？
2.人工智能与大数据的背景
1.大数据的挑战
2.人工智能的需求
3.C++ 与 Redis 的完美结合
1.安装 Redis 和 Redis C++ 客户端
2.连接 Redis 并进行数据操作
高级数据操作
列表操作
哈希操作
4.与大数据和人工智能结合
5.实际应用案例分析
案例一：实时推荐系统
案例二：实时监控系统
进一步优化与扩展
性能优化
功能扩展
6.总结
在现代软件开发中，C++、人工智能、Redis和大数据已经成为不可或缺的技术元素。C++以其高性能和灵活性著称，广泛应用于系统编程和高性能计算。人工智能正在改变我们的生活方式，从自动驾驶汽车到智能助手，其应用无处不在。Redis作为一种内存数据结构存储，被广泛用于缓存、消息队列和实时数据处理。大数据技术则在处理和分析大量数据方面发挥着关键作用。
1.为什么选择 C++ 和 Redis？ C++ 作为一门高性能的编程语言，广泛应用于系统编程和大规模数据处理。它的主要优势在于：
性能：C++ 提供了对硬件的直接控制，能够实现高度优化的代码，特别是在需要高性能计算的场景下。资源管理：通过 RAII（Resource Acquisition Is Initialization）等技术，C++ 能够高效地管理资源，避免内存泄漏等问题。灵活性：C++ 支持面向对象编程、泛型编程和函数式编程，能够根据不同的需求选择最合适的编程范式。 Redis 是一个开源的内存数据结构存储系统，支持丰富的数据结构，如字符串、哈希、列表、集合等，常用于缓存、消息队列等场景。它的优势在于：
高性能：Redis 通过将数据存储在内存中，实现了极高的读写速度，适用于需要快速访问的数据。多种数据结构：支持字符串、哈希、列表、集合、有序集合等多种数据结构，能够满足不同的应用需求。简单易用：提供简单的命令行接口和丰富的客户端库，便于开发和维护。 将 C++ 与 Redis 结合，可以充分发挥两者的优势，实现高效的数据处理。
2.人工智能与大数据的背景 随着数据量的爆炸性增长，人工智能（AI）和大数据技术成为了处理和分析这些数据的关键手段。AI 依赖于大量数据进行训练和推理，而大数据技术则提供了存储和处理这些数据的工具。通过 C++ 和 Redis，我们可以构建高性能的系统来满足 AI 和大数据的需求。
1.大数据的挑战 在大数据时代，数据的规模、速度和多样性给传统的数据处理方法带来了巨大的挑战。主要挑战包括：
数据存储和管理：如何高效地存储和管理海量数据是一个关键问题。传统的关系型数据库在面对大规模数据时往往表现不佳。数据处理速度：在需要实时处理的数据场景中，高效的数据处理速度至关重要。数据分析和挖掘：如何从海量数据中提取有价值的信息，进行有效的分析和挖掘，是大数据技术的核心。 2.人工智能的需求 人工智能技术的核心在于算法和数据。随着深度学习和机器学习技术的发展，AI 对数据的需求越来越高。主要需求包括：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ffb471173e9c4262f8fecca99ae463a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6736fc63f5b6f9d154b766e80a9296ea/" rel="bookmark">
			【一步一步了解Java系列】：重磅多态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看到这句话的时候证明：此刻你我都在努力
加油陌生人
个人主页：Gu Gu Study
专栏：一步一步了解Java
喜欢的一句话： 常常会回顾努力的自己，所以要为自己的努力留下足迹
喜欢的话可以点个赞谢谢了。
作者：小闭
何为多态 在Java中，多态（Polymorphism）是一种允许不同类的对象对同一消息做出响应的能力，即同一个接口可以被不同的实例以不同的方式实现。多态性是面向对象编程的一个核心概念，它使得代码更加灵活和可扩展。
多态性主要通过以下几种方式实现：
方法重载（Overloading）：这是编译时多态的一个例子。方法重载允许同一个类中有多个同名方法，只要它们的参数列表不同（参数的类型、数量或顺序不同）。方法重写（Overriding）：这是运行时多态的一个例子。当子类继承父类时，子类可以重写父类的方法。如果子类对象调用了一个被重写的方法，将执行子类中的方法实现，而不是父类中的实现。接口实现：一个类可以实现一个或多个接口，接口定义了一组方法规范，具体的实现类必须提供这些方法的具体实现。不同的实现类可以以不同的方式实现同一个接口中定义的方法。抽象类：抽象类可以包含抽象方法，这些方法没有具体的实现，必须由继承抽象类的子类来实现。这也是一种多态的体现，因为不同的子类可以提供不同的实现。 多态的使用可以带来以下好处：
代码复用：通过继承和接口实现，可以减少代码的重复编写。扩展性：通过多态，可以在不修改现有代码的情况下，引入新的类和对象。灵活性：多态允许程序在运行时动态地绑定方法调用，使得程序更加灵活。 多态是Java中实现开闭原则（对扩展开放，对修改封闭）的关键机制之一，它允许程序更容易适应变化，同时保持代码的稳定性和可维护性。
多态实现的条件：
必须在继承体系下子类必须要对父类中方法进行重写通过父类的引用调用重写的方法 总的来说：多态即是不同对象，不同的的态度。
方法重载的多态 方法重载在前面其实已经说过了，下面是一个方法重载多态的情况：
public class Cat { String type="猫咪"; public void eat(){ System.out.println(type+"吃猫粮"); } public void eat(int n){ System.out.println(type+"吃"+n+"两猫粮"); } } class Test{ public static void main(String[] args) { Cat cat=new Cat(); cat.eat(); cat.eat(1); } } 上面我们对方法进行重载，然后传参不同时，同一个方法却呈现不同的打印方式即（不同的形态）。
方法重写的多态 我们先要认识，何为重写：
在Java中，重写（Overriding）是指子类提供一个特定的实现，覆盖从父类继承来的方法的实现。这是运行时多态的一个体现，意味着在程序运行时，会根据对象的实际类型来调用相应的方法。
要实现方法重写，需要满足以下条件：
方法名、参数列表和返回类型：子类重写的方法必须具有与父类被重写方法相同的方法名、参数列表和返回类型。如果返回类型不同，则不是重写，而是重载（Overloading）。访问权限：子类重写的方法不能具有比父类更严格的访问权限。例如，如果父类中的方法是public的，子类重写的方法也必须是public或protected，但不能是private。非静态方法：重写必须发生在非静态方法上。静态方法（Static methods）不能被重写。非最终方法：如果父类中的方法是final的，则不能被重写。 下面是一个简单的示例，展示如何在Java中重写方法：
class Animal { public void sound() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6736fc63f5b6f9d154b766e80a9296ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70451bb5100500be0db029e51051bd5e/" rel="bookmark">
			完美解决 mysql 报错ERROR 1524 (HY000): Plugin ‘mysql_native_password‘ is not loaded
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 错误描述错误原因解决步骤 跟着我下面的步骤走，解决你的问题，如果解决不了 私信我来给你解决 错误描述 执行ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '123456';报错ERROR 1524 (HY000): Plugin 'mysql_native_password' is not loaded 原因如下
错误原因 这个错误主要由以下几个原因造成：
插件未安装：MySQL的auth_socket插件可能没有被安装。这个插件允许用户通过操作系统的socket来进行身份验证，而不是使用密码。配置问题：MySQL配置文件（my.cnf或my.ini）中可能没有正确配置auth_socket插件。权限问题：即使插件已安装，但MySQL服务器的运行用户可能没有足够的权限来加载该插件。 解决步骤 确认插件是否已安装
首先，你需要确认auth_socket插件是否已经安装在你的MySQL服务器上。可以通过登录到MySQL服务器并执行以下SQL查询来检查：
SHOW PLUGINS; 在结果中查找auth_socket或unix_socket（插件名称可能根据MySQL版本而异）。
我是没有找到 所以就安装吧
安装或启用插件
如果auth_socket插件未显示在已安装的插件列表中，你需要安装或启用它。可以通过以下SQL命令来安装：
进入到你的mysql容器中执行
INSTALL PLUGIN auth_socket SONAME 'auth_socket.so'; 更改用户的认证方法
如果你已确认插件已安装并且想使用它，确保你的MySQL用户配置为使用该插件进行认证。你可以使用以下SQL命令更改用户的认证方法：
ALTER USER 'root'@'%' IDENTIFIED WITH auth_socket;ALTER USER 'your_username'@'localhost' IDENTIFIED WITH auth_socket; 替换root为你的实际用户名
然后我们在重新执行ALTER USER 'root'@'%' IDENTIFIED WITH auth_socket BY '123456';
注意这个地方不是mysql_native_password 而是auth_socket 因为咱创建的就是auth_socket
OK 完事！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6691557adc4a1ebbdf5c5d00115a7de/" rel="bookmark">
			C语言——内存函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在之前我们已经学习了字符的相关函数，例如strcpy；strcat等，但如果我们要实现除字符类型外的数据时，这些函数就无法使用了，这时就要用到c语言中的内存函数了，内存函数就可以实现对整型；结构体类型等数据的处理了，接下来就一起来了解这些函数的作用以及使用方法吧！
1.memcpy 1.1memcpy的作用以及使用 首先来了解memcpy的作用是拷贝内存块，将源空间的内存拷贝num字节到目标空间内存当中，且在拷贝过程中能指定想要拷贝的字节个数，因此在该函数的参数有三个，第一个参数是目标空间的起始址，第二个是源空间的起始地址，最后一个参数是想要拷贝的字节数
同时该函数的返回值是目标空间的起始地址
注：
• 这个函数在遇到 '\0' 的时候并不会停下来。
• 如果source和destination有任何的重叠，复制的结果都是未定义的。
#include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { int arr1[] = { 1,2,3,4,5,6,7,8,9,10 }; int arr2[10] = { 0 }; memcpy(arr2, arr1, 20); int i = 0; for (i = 0; i &lt; 10; i++) { printf("%d ", arr2[i]); } return 0; } 例如以上代码中就是将arr1中的前面20个字节拷贝到arr2中，也就是将arr1中的前5个元素拷贝到arr2中
但注意memcpy无法实现在同一块内存空间内两个重叠空间的之间拷贝，例如在以上arr1中就无法将内存中的1 2 3 4 5拷贝到3 4 5 6 7，要实现这种情况的拷贝就要使用到memmove再下文中会讲解到
1.2memcpy的模拟实现 以下的模拟实现有什么错误的地方吗？
void* my_memcpy(void* dest, const void* src,size_t num) { assert(dest &amp;&amp; src); void* str = dest; while (num--) { *((char*)dest) = *((char*)src); ((char*)dest)++ ; ((char*)src)++ ; } return str; } 以上的代码在运行时程序是会报错的，原因是dest和src原来的类型是void*，是不能进行解引用的，而且在进行强制类型转换为char*后也只能进行一次转换，后置++这次就不可使用了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6691557adc4a1ebbdf5c5d00115a7de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4299a51d3b11d86faf49364b9e35c1ba/" rel="bookmark">
			逐步掌握最佳Ai Agents框架-AutoGen 九 RAG应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在最近的几篇文章里，我们使用AutoGen实现了一些Demo。这篇文章，我们将使用AutoGen来完成RAG应用开发。
RAG应用 RAG全称"Retrieval-Augmented Generation",即检索增强生成，它是自然语言处理中的一项技术。这种模型结合了检索式（retrieval-based）和生成式（generative）两种组件，以生成更准确、更相关的回答。
在之前我们的基于文档的聊天机器人的例子，就是RAG的一种应用。在本系列的逐步掌握最佳Ai Agents框架-AutoGen 五 与LangChain手拉手 - 掘金 (juejin.cn)，我们将文档读取、向量化和存储工作交给了LangChain, AutoGen以agent with function calls 的方式调用LangChain封装好的函数。AutoGen在最近版本里，新增了RetriveChat，可以减少对LangChain的依赖。那么，我们一起来看下AutoGen如何独立完成RAG应用开发。
RetrievalAgent 让我们来看下，官方文档对Retrieval-Augmented Generation (RAG) Applications with AutoGen | AutoGen (microsoft.github.io)的介绍。
从上图可以看出，AutoGen提供了Retrieval-augmented User Proxy 和Retrieval-augmented Assistant两个agent。
现在就让我们开干。
实战 文档 之前的RAG项目中我们用到的是Uniswap的白皮书，这个项目里，我们换成了arxiv.org/pdf/2308.00…, 这是一份rag和向量技术在医疗教育中的相关研究文章。让我们在notebook里把它下载到当前项目中。
python 复制代码!wget -o rag.pdf https://arxiv.org/pdf/2308.00479.pdf 安装库 python 复制代码%pip install pyautogen[retrievechat] langchain "chromadb&lt;0.4.15" -q 这次安装pyautogen,多加了retrieveChat功能包的声明。我们依然安装了langchain, 在这里主要使用它的splitter功能，当然autogen也是提供了。最后我们安装了指定版本的chromadb 向量数据库，存储文档embedding。
配置autogen config_list css复制代码import autogen # 大家可以使用gpt-4 或其它，我这里用的是3.5, 还能用。 config_list = [ { 'model': 'gpt-3.5-turbo', 'api_key': '' }] llm_config={ "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4299a51d3b11d86faf49364b9e35c1ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6669bdb2a3e54c7fbadace93a1df475/" rel="bookmark">
			【wiki知识库】05.分类管理模块--后端SpringBoot模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📝个人主页：哈__
期待您的关注 目录
一、🔥今日目标
二、☀SpringBoot代码修改
1.使用逆向工程生成Category表结构
2. 新增CategoryQueryParam
3.新增CategorySaveParam
4.新增CategotyQueryVo
三、🤖新增分类管理的相关接口
1. /category/all
2./category/save
3./category/delete
1.我们删除的是一个二级分类
2.我们删除的是一个一级分类
一、🔥今日目标 【wiki知识库】05.分类管理实现--前端Vue模块-CSDN博客
上一篇文章我把分类模块的前端部分给大家展示出来了，这篇文章主要是为了配合上一篇，其实这一篇文章应该先写到前边，然后在发前端的部分。文章的主要内容是把分类管理的后端接口写出来。
二、☀SpringBoot代码修改 不知道你是否还记得我们电子书模块后端接口书写的流程，【wiki知识库】02.wiki知识库SpringBoot后端的准备-CSDN博客，在这篇文章当中我是用逆向工程生成了Ebook的一些项目结构，现在我们需要Category模块。我们的第一步还是使用逆向工程。
1.使用逆向工程生成Category表结构 在我们util包下的 MybatisGenerator类中修改下方的代码，把我们的表换成category，然后运行代码。
2. 新增CategoryQueryParam package com.my.hawiki.param; import lombok.Data; import lombok.EqualsAndHashCode; @EqualsAndHashCode(callSuper = true) @Data public class CategoryQueryParam extends PageParam { } 3.新增CategorySaveParam package com.my.hawiki.param; import lombok.Data; import javax.validation.constraints.NotNull; @Data public class CategorySaveParam { private Long id; private Long parent; @NotNull(message = "【名称】不能为空") private String name; @NotNull(message = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6669bdb2a3e54c7fbadace93a1df475/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4184857f2b241f8793e95515eecc999d/" rel="bookmark">
			RPA机器人的技术挑战与解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RPA在企业转型过程中彰显出巨大的潜力，每年为企业节省大量人力以及运营成本，从而实现企业经营的降本提质增效。但要成功部署和实施RPA，需要专业人员、流程和技术的精心组合。企业管理者需要根据自己的实际需求，选择一个稳定可靠、易于使用和管理的RPA平台，以应对RPA机器人实施过程中面临的技术挑战。
金智维作为企业级RPA专家，十余年来为万千行业提供了高效的数字员工解决方案，以下金智维将探讨RPA机器人在实施和操作过程中可能面临的技术挑战，并提供相应的解决方案。
1.安全性和合规性 RPA技术应用于企业的各个领域，但在项目执行过程中，RPA机器人经常需要访问和处理敏感数据，因此其安全性和合规性就成了优先考虑的对象。
【解决方案】
使用强大的数据加密技术，实施访问控制和身份验证，确保数据的保密性。确保RPA解决方案遵循所有相关的数据保护和隐私法规，并定期进行安全审计。
2.异常处理 RPA机器人从设计、实施、部署到上线运行都需要关注其运行稳定性，这就十分考验RPA机器人在面对异常情况和突发情况时的处理能力，如错误消息、系统崩溃等，这是验证RPA机器人稳定运行的关键。
【解决方案】
开发健全的异常处理机制，包括自动化的错误恢复和报警系统，以确保机器人能够适应不同情况。
3.扩展性 随着业务的增长，RPA系统需要具备足够的扩展性，以便快速适应后续新的业务需求，进一步扩充其他功能而无需重复部署。
【解决方案】
选择高性能的RPA平台，并进行系统性能优化。确保RPA系统能够支持多类型用户访问和权限控制，并支持组件的高度复用，轻松应对业务量扩展后的高负载情况。
4.监控与管理 有效的RPA监控和管理能够确保项目实施时的稳定、高效和合规，便于及时发现故障和问题，以优化性能，最大化生产力，并减少潜在风险。因此，部署前考察RPA机器人的监控性能成为关键的一点。
【解决方案】
使用监控工具和仪表板来实时跟踪RPA机器人的性能和运行状态，最大化资源利用率。建立自动化的机器人管理流程，包括版本控制和日志记录。定期检查RPA机器人的效率和性能，及时识别潜在的瓶颈并进行优化。
5.系统集成 RPA机器人需要与多个现有系统和应用程序集成，这可能会导致复杂的系统架构，出现安全性隐患，且可能会应对系统的不稳定性问题。
【解决方案】
使用API和集成工具来简化系统集成过程；实施严格的安全策略和访问控制措施，使用加密和身份验证来保护数据；确保与IT团队密切合作，以确保系统的完整性和稳定性。
6.智能决策 RPA机器人需要能够做出智能决策，而不仅仅是按照预定规则执行任务。在这个过程中，要杜绝不完整、不准确的数据导致RPA决策失误，也要确保RPA机器人能够快速适应变化的环境和数据。
【解决方案】
整合人工智能和机器学习技术，使RPA机器人能够正确分析数据并做出智能决策。提供培训和支持，以确保机器人能够适应新的情境和需求。
7.连续改进 随着企业的发展壮大，业务流程增多，相关应用程序更加复杂化，RPA系统需要不断改进和优化，以适应市场和业务变化，确保RPA能够持续为企业带来价值。
【解决方案】
建立持续改进的流程，包括对RPA流程的定期审查和优化，对RPA机器人的代码和流程进行版本控制，以跟踪变化，维护历史记录；积极收集RPA机器人执行的数据，并设置反馈机制，以发现潜在的改进机会，不断改善机器人的性能和效率。
8.培训和技能发展 为了有效发挥RPA机器人的最大价值，应确保每位员工掌握RPA工具和技术，有效应用在工作中，提高生产力和效率。
【解决方案】
提供员工培训，帮助他们掌握RPA技术和工具，鼓励员工不断学习和提高技能，以适应新的工作环境。
为适应激烈的市场竞争和不断变化的业务需求，选择一个稳定可靠、功能强大的RPA平台对企业发展来说十分关键。金智维作为国内率先推出的具有自主知识产权的企业级RPA平台，多年来以安全、高效、稳定、易扩展、易维护和易使用等特点，获得业界客户的高度认可和广泛应用，已成为万千企业数字化转型有效的技术平台和优先选择。未来，金智维将继续锚定关键核心技术攻关创新，为千行万业提供更加成熟高效的数字员工解决方案，为企业数字化转型再添新动力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e48a2ae066e79fcb4d12fa8748125044/" rel="bookmark">
			直播美颜工具解析：美颜SDK核心技术与性能优化方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章，小编将深入解析直播美颜SDK的核心技术及其性能优化方法，以期为开发者提供有价值的参考。
一、美颜SDK核心技术
1.实时人脸检测与识别
美颜SDK的核心技术之一是实时人脸检测与识别。这项技术基于深度学习算法，能够快速、准确地识别人脸特征点。
2.图像增强技术
美颜SDK这些算法通过调整图像的对比度、亮度和色彩饱和度，提升视频画面的整体质量。
3.滤镜效果
滤镜效果的实现依赖于图像处理技术，通过应用不同的色彩映射和混合模式，给直播画面增添多样化的视觉效果。滤镜不仅能够增强画面的艺术感，还能根据不同场景需求，调节视频的氛围，满足用户个性化的需求。
4.美形塑造
美形塑造功能涉及到对五官的优化处理，例如瘦脸、大眼、高鼻梁等。这项技术通过对人脸特征点的智能识别与变形，保持面部整体比例的协调性，实现自然的美形效果。
5.AR效果
近年来，AR技术在美颜SDK中得到广泛应用。通过增强现实技术，SDK可以在用户面部叠加虚拟的装饰元素，如动态贴纸、3D妆容等，增加直播的趣味性和互动性。
二、美颜SDK性能优化方法
1.算法优化
通过使用更高效的数学模型和算法结构，如卷积神经网络（CNN）和深度神经网络（DNN），可以显著提升人脸检测与图像处理的速度。
2.硬件加速
通过将复杂的计算任务分配到GPU进行并行处理，能够在保证高质量美颜效果的同时，显著降低CPU的负载，提升整体系统的响应速度。
3.缓存技术
在直播过程中，使用缓存技术可以有效减少数据处理的时间。通过对常用的数据进行缓存，避免重复计算，可以显著提高美颜效果的实时性和流畅性。
4.多线程处理
合理利用多线程技术，将不同的美颜处理任务分配到不同的线程中并行执行，可以有效提升系统的处理能力和响应速度。例如，将人脸检测、图像增强和滤镜效果分别交给不同的线程处理，从而实现各个环节的同步高效执行。
5.数据压缩
在保证画质的前提下，采用高效的数据压缩算法，减少图像数据的传输和存储空间，可以显著降低系统的资源消耗。尤其是在网络带宽有限的情况下，数据压缩技术对于提升直播的流畅度和稳定性至关重要。
三、结语
直播美颜工具的核心技术与性能优化方法是确保用户在直播过程中拥有最佳体验的关键。通过不断提升人脸检测与识别的准确性、优化图像增强算法、合理利用硬件加速和缓存技术，开发者可以打造出性能优异、效果逼真的美颜SDK。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c61015955a01815e66d917d9664e0a23/" rel="bookmark">
			SQL入门教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL入门教程 1、SQL基础概念2、创建和删除数据库3、创建和删除表4、数据类型5、插入数据6、查询数据7、更新数据8、删除数据9、排序和分组10、连接表11、SQL约束12、SQL函数 1、SQL基础概念 数据库（Database）：存储有组织的数据的容器。
表（Table）：数据库中的数据存储在表中，表由行和列组成。
行（Row）：表中的数据是按行存储的，每一行代表一个记录。
列（Column）：表中的列代表数据的属性，每一列有一个名称和数据类型。
SQL语句：用于执行数据库操作的语言指令，如SELECT、INSERT、UPDATE等。
2、创建和删除数据库 创建数据库 CREATE DATABASE database_name; 删除数据库 DROP DATABASE database_name; 3、创建和删除表 创建表 CREATE TABLE table_name ( column1 datatype, column2 datatype, column3 datatype, ... ); 删除表 DROP TABLE table_name; 4、数据类型 SQL支持多种数据类型，以下是一些常见的数据类型：
INT：整数 VARCHAR：字符串 DATE：日期 DECIMAL：小数 BOOLEAN：布尔值 5、插入数据 INSERT INTO table_name (column1, column2, column3, ...) VALUES (value1, value2, value3, ...); 6、查询数据 查询所有列 SELECT * FROM table_name; 查询特定列 SELECT column1, column2 FROM table_name; 带条件的查询 SELECT * FROM table_name WHERE condition; 7、更新数据 UPDATE table_name SET column1 = value1, column2 = value2, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c61015955a01815e66d917d9664e0a23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e84be2fd31e809414a44eef3485454b/" rel="bookmark">
			Spring boot项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. Spring boot 安装地址 https://start.spring.io/
二. 选择 三. idea配置 找到下载的文件解压缩，打开pom.xml(选择从idea打开)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f05029d77e8d3e3c2bc873f10ccf0b88/" rel="bookmark">
			前缀树的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前缀树的实现 何谓前缀树？实现前缀树节点的选择插入查找查找前缀完整代码 何谓前缀树？ 前缀树（字典树），使用树状的数据结构存储一个字典的所有单词。前缀树是一个多叉树，一个节点可能有多个子节点，除根结点外，每个节点代表字符串中的一个字符。字符串在前缀树中不一定终止于叶子节点，比如 ‘app’。如果前缀树路径到达某个节点时表示了一个完整的字符串，那么这个节点应有特殊的标识。一个存储字符串 “apple” “apply” “app” “huw” “oppo” “xiao” “mi” 的前缀树如图：
实现前缀树 实现一个前缀树 Trie ，它有下列操作：
函数 insert ，在前缀树中添加一个字符串函数 search，查找字符串，如果前缀树中包含该字符串则返回 true，否则返回 false。函数 startWith，查找字符串前缀。 节点的选择 子节点容器可以选择使用哈希表或数组。
在字符集大小固定且较小的情况下，数组可以提供紧凑的存储，没有额外的哈希表开销。数组可以保持元素有序性以及空间效率比较高。哈希表比较灵活。 真实的结构：
class TrieNode { public: std::unordered_map&lt;char, TrieNode*&gt; children; bool id_end_of_word; TrieNode() : is_end_of_word(false) {} }; 插入 void insert(const std::string&amp; word) { TrieNode* node = root; for (char ch : word) { if (node-&gt;children.find(ch) == node-&gt;children.end()) { node-&gt;children[ch] = new TrieNode(); } node = node-&gt;children[ch]; } node-&gt;isEndOfWord = true; } 查找 bool search(const std::string&amp; word) { TrieNode* node = root; for (const auto&amp; ch : word) { if (node-&gt;children.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f05029d77e8d3e3c2bc873f10ccf0b88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc1e2964e874f6eb626b0d8c9c294c7b/" rel="bookmark">
			实战：Zig 编写高性能 Web 服务（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.1 编写 HTTP server 我们从python -m http.server 8000启动得到灵感，先确定好目标：
编写一个HTTP/1.1 http serverzig version 0.12.0 使用zig init搭建项目的前置工作你先自行搭建好，不会的翻看前面铺垫的章节熟悉zig的项目结构。
关键文件build.zig:
const std = @import("std"); // Although this function looks imperative, note that its job is to // declaratively construct a build graph that will be executed by an external // runner. pub fn build(b: *std.Build) void { // Standard target options allows the person running `zig build` to choose // what target to build for.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc1e2964e874f6eb626b0d8c9c294c7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d426204bb02efcad17413d459103d4f/" rel="bookmark">
			踩坑：Unity导出WebGL发布到手机上竖屏时强制显示横屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		具体的适配问题 公司的项目需要将游戏导出WebGL 发布到Web平台 本以为是个很简单的事情 谁知道却被个横竖屏适配搞的头晕 毕竟只有大学浅浅的学了下HTML这门语言 出来工作后基本上都是在跟C# Lua打交道 言归正传 看看具体问题吧
游戏如果从横屏进入 基本上不会有什么适配问题
但是现在人大多数手机都是开着 锁定屏幕方向 这就导致大部分人其实是以竖屏进入游戏的
像这样：
这样显然是不符合用户体验的 要用户先把屏幕锁定关了 在旋转成横屏 这一操作在游戏引流里都可以直接劝退一波用户了
解决方案 理论方案 理论上解决很简单 只需在index里进入时判断手机方向并监听手机旋转事件
&lt;script&gt; var orientation = window.orientation; if(orientation == 180 || orientation == 0 || orientation == -180){ //竖屏 }else{ //横屏 orientation = 90 或者 orientation = -90 } window.onorientationchange = function () { //监听手机旋转事件 if(orientation == 180 || orientation == 0 || orientation == -180){ //竖屏 旋转-90度 }else{ //横屏 旋转90度 } }; &lt;/script&gt; 改变
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d426204bb02efcad17413d459103d4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a39eb477a958ba19dd583d2f9a2fa4a9/" rel="bookmark">
			Windows下使用netty的SelfSignedCertificate进行SSL加密通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用netty的时候，经常需要对通信进行SSL加密，这就需要相关的证书和秘钥；
当我们在自己的开发环境中进行测试的时候，有一个非常简单的方法来创建证书和私钥文件，netty提供了SelfSignedCertificate类。
SelfSignedCertificate ssc = new SelfSignedCertificate(); 只需要这样一行代码，Netty就会帮我们自动生成自签名的证书和私钥。
生成的证书和私钥文件在Windows下的Temp目录：
C:\Users\xxx\AppData\Local\Temp 文件名前缀为：keyutil_example.com_
一般为：
C:\Users\xxx\AppData\Local\Temp\keyutil_example.com_13784598500529759262.crt
C:\Users\xxx\AppData\Local\Temp\keyutil_example.com_9168231614251199235.key
PS: 自动生成的证书和私钥会在程序结束后自动删除，当然也可以调用ssc.delete()进行手动删除。
下面记录下，使用SelfSignedCertificate的过程中的一些问题：
1. 代码执行过程中，报错：
Exception in thread "main" java.security.cert.CertificateException: No provider succeeded to generate a self-signed certificate. See debug log for the root cause. at io.netty.handler.ssl.util.SelfSignedCertificate.&lt;init&gt;(SelfSignedCertificate.java:157) at io.netty.handler.ssl.util.SelfSignedCertificate.&lt;init&gt;(SelfSignedCertificate.java:110) at io.netty.handler.ssl.util.SelfSignedCertificate.&lt;init&gt;(SelfSignedCertificate.java:88) at io.netty.handler.ssl.util.SelfSignedCertificate.&lt;init&gt;(SelfSignedCertificate.java:79) at com.freddy.netty.n12_securechat.SecureChatServer.main(SecureChatServer.java:25) Caused by: java.lang.NoClassDefFoundError: org/bouncycastle/jce/provider/BouncyCastleProvider at io.netty.handler.ssl.util.SelfSignedCertificate.&lt;init&gt;(SelfSignedCertificate.java:154) ... 4 more Caused by: java.lang.ClassNotFoundException: org.bouncycastle.jce.provider.BouncyCastleProvider at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:641) at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188) at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520) ... 5 more SelfSignedCertificate会自动将证书文件和私钥文件生成在系统的temp文件夹中，所以这个类在生产环境中是不推荐使用的。默认情况下该类会使用OpenJDK's X.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a39eb477a958ba19dd583d2f9a2fa4a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35feff184058f6b503e139e06d13069b/" rel="bookmark">
			IDEA的使用配置Maven(及selenium&#43;webdriver的下载配置)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 下载maven 1. maven官网下载链接 2.​​安装第二行第一列的zip压缩包 ​​​​​​​​
二. 配置环境变量 1.新建环境变量 2.在系统变量Path环境变量中添加%Maven_HOME%\bin 三.验证环境变量是否配置成功 win+r &gt;cmd&gt;mvn -v 如果出现Maven的版本信息，则配置成功
四.配置本地仓库存储 1.新建文件名 mvn-repository 2.配置setting.xml文件,conf&gt;settings.xml idea中打开，在标签下修改url
五.换源 Maven默认访问国外服务器下载包，速度很慢。配置阿里云镜像下载包会比较快。
打开conf目录下的settings.xml文件，在标签下添加标签
六.idea配置maven 1. 2. 七.新建maven项目 quickstart是一般工程
webapp是web工程 看需求选择
八. 做软测需要配置selenium+webdriver 1. webdriver最新下载地址 选择与谷歌浏览器相适应的版本进行下载！
2.环境配置 path中添加路径
3. 环境验证 输入chrome driver --version，出现版本信息，则安装成功
4. 下载 selenium官网地址 5. pom.xml中添加selenium的依赖 下面代码放于&lt;dependencies 和 /dependencies&gt;标签中
&lt;dependency&gt; &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt; &lt;artifactId&gt;selenium-java&lt;/artifactId&gt; &lt;version&gt;4.21.0&lt;/version&gt;//根据自己的selenium版本填写 &lt;/dependency&gt; 6. pom.xml依赖飘红处理方法 手动导入jar包方法：
file&gt;project structure&gt;libraries
导入jar包
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9e9b6afd76cbdfe80585a896d99e83b/" rel="bookmark">
			关于网页自动化工具DrissionPage进行爬虫的使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一. 简介二. 使用1. 安装方式2. 基本用法3. 模式4. 元素交互4. SessionPage5. 运行JS6. 结语 一. 简介 最近在学python的过程中，发现了一个好用的爬虫库DrissionPage —— 一个基于 python 的网页自动化工具。据具官方文档（官方网址：https://drissionpage.cn/）介绍：
它既能控制浏览器，也能收发数据包，还能把两者合而为一。可兼顾浏览器自动化的便利性和 requests 的高效率。它功能强大，内置无数人性化设计和便捷功能。它的语法简洁而优雅，代码量少，对新手友好。 笔者在用的过程中发现还不错，语法简洁方便，可无配置运行。就写一篇文章分享一下这个工具的使用方法。
二. 使用 1. 安装方式 开始之前，我们要先安装一个这个库，注意：Python版本要在3.6及以上，我们使用pip安装，安装命令：
pip install DrissionPage 升级最新稳定版本版本使用：
pip install DrissionPage --upgrade 或者指定版本安装：
pip install DrissionPage==4.0.0b17 2. 基本用法 在我们的Python文件中导入DrissionPage库，写一个最简单的demo，我们来爬取百度的热搜榜单。
我们先来观察一下百度首页的页面结构，我们可以看到这些热搜都用到了title-content-title类，那我们就可以使用这个类名来获取信息。
from DrissionPage import ChromiumPage # 创建ChromiumPage对象时会在指定端口启动浏览器，或接管该端口已有浏览器。 # 默认情况下，程序使用 9222 端口 page = ChromiumPage() # 只传入一个url就行，后面那些参数都有默认值 page.get('https://www.baidu.com',retry=99, show_errmsg=True, timeout=10) # 这里我们通过类名获取元素 lists = page.eles('.title-content-title') for i in lists: print(i.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9e9b6afd76cbdfe80585a896d99e83b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80ce1a67ca19751838138c1ecf3f6b5b/" rel="bookmark">
			使用Nginx正向代理让内网主机通过外网主机访问互联网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
环境概述
流程说明
在外网服务器上安装部署nginx 安装前准备
下载nginx
编译安装nginx
开始配置正向代理
创建systemd服务单元文件，用于管理Nginx服务的启动、停止和重新加载
启动nginx
代理服务器本地验证
内网服务器验证
将代理地址添加到环境变量中直接使用
环境概述 在企业网络环境中，通常会存在内网与外网的隔离，内网机器无法直接访问外部Internet。而外网机器具有访问互联网的能力。为了让内网机器能够通过外网机器访问互联网，我们可以配置Nginx正向代理来实现。
（代理服务器为linux系统，Windows系统中nginx中默认不包含proxy_connect模块，Windows编译proxy_connect模块比较麻烦，可以使用CCProxy代理软件实现，参考外网主机使用CCProxy代理使内网主机上网）
内网主机：172.211.216.242 (无法直接访问外部Internet)外网主机：192.168.0.97 (可以访问Internet，并充当代理服务器)前置条件：内网主机和外网主机虽然不是在同一网段，但是可以互相访问，正向代理的端口需要互通，这里用的8080 流程说明 内网服务器发送请求：内网服务器通过HTTP或HTTPS发送请求到外网代理服务器的8080端口。
代理服务器接收请求：外网代理服务器接收到请求后，根据请求的协议（HTTP或HTTPS）使用proxy_pass将请求转发到目标互联网服务器。
互联网服务器处理请求：目标互联网服务器接收到请求后处理并生成响应。
代理服务器返回响应：互联网服务器将响应发送回外网代理服务器，然后代理服务器将响应转发回内网服务器。
代理流程： A[内网主机 172.211.216.242] -- 请求 --&gt; B[Nginx代理 192.168.0.97:8080] B -- 转发请求 --&gt; C[目标服务器] C -- 返回响应 --&gt; B B -- 返回响应 --&gt; A +----------------------+ +------------------------+ +---------------------+ | 内网服务器 | | 外网代理服务器 | | 互联网服务器 | | 172.211.216.242 | --------&gt; | 192.168.0.97:8080 | --------&gt; | www.example.com | | | | | | | | 发送HTTP/HTTPS请求 | | 接收并转发请求 | | 处理请求并返回响应 | +----------------------+ +------------------------+ +---------------------+ ^ | | | v | +----------------------&lt;----------------+-----------------------&lt;--------------+ 在外网服务器上安装部署nginx 安装前准备 由于Nginx默认不支持HTTPS代理，我们需要额外添加模块。使用的模块是ngx_http_proxy_connect_module。使用模块前需请确保模块和Nginx版本匹配。如图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80ce1a67ca19751838138c1ecf3f6b5b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/303/">«</a>
	<span class="pagination__item pagination__item--current">304/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/305/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>