<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dae72f1efc6d3a08a3bfb48cacaca782/" rel="bookmark">
			RabbitMQ之消费者批量消费
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么要用消费端批量消费？
在一些业务场景下，我们希望使用 Consumer 批量消费消息，提高消费速度。可以通过对 SimpleRabbitListenerContainerFactory 进行配置实现批量消费能力
==========================&gt;配置类 @Configuration public class ConsumerConfiguration { @Resource ConnectionFactory connectionFactory; @Resource SimpleRabbitListenerContainerFactoryConfigurer configurer; /** * 配置一个批量消费的 SimpleRabbitListenerContainerFactory */ @Bean(name = "consumer10BatchContainerFactory") public SimpleRabbitListenerContainerFactory consumer10BatchContainerFactory() { SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory(); configurer.configure(factory, connectionFactory); // 这里是重点 配置消费者的监听器是批量消费消息的类型 factory.setBatchListener(true); // 一批十个 factory.setBatchSize(1000); // 等待时间 毫秒 , 这里其实是单个消息的等待时间 指的是单个消息的等待时间 // 也就是说极端情况下，你会等待 BatchSize * ReceiveTimeout 的时间才会收到消息 factory.setReceiveTimeout(10 * 1000L); factory.setConsumerBatchEnabled(true); return factory; } } ====================》生产者 @Component public class Producer10 { @Resource RabbitTemplate rabbitTemplate; public void sendSingle(String id, String routingKey) { Message10 message = new Message10(); message.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dae72f1efc6d3a08a3bfb48cacaca782/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/859c477b4c1e491aa9e939a48a85d9e2/" rel="bookmark">
			前端之实现大文件上传的解决方案———断点续传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 断点续传是一种网络数据传输方式，允许从中断的地方恢复下载或上传操作，而不是从头开始。这对于大文件传输尤其有用，因为它可以节省时间并减少网络资源的浪费。在前端开发中，实现大文件的断点续传可以提升用户体验，尤其是在网络不稳定或速度较慢的情况下。
场景 用户上传大文件至服务器，如视频、图片集合或大型文档。用户下载服务器上的大文件，如高清视频、大型软件安装包。网络不稳定导致传输中断，用户希望从中断处继续传输。 原理 断点续传的基本原理是将大文件分割成多个小块，然后分别传输这些小块。每个小块都有自己的编号，客户端和服务器端都记录已成功传输的块。如果传输过程中断，客户端可以从最后成功传输的块之后继续传输，而不是从头开始。
实现方案 文件分片：将大文件分割成多个小块。并行上传：为了提高上传速度，可以同时上传多个小块。校验和记录：每个文件块传输前后都需要进行校验，确保数据的完整性，同时记录已上传的块。请求恢复：在传输中断后，客户端向服务器请求恢复中断的传输。服务器支持：服务器需要能够理解客户端的恢复请求，并提供未完成传输的文件块。 示例代码说明 以下是使用JavaScript实现大文件断点续传的一个简单示例：
// 假设我们有一个文件对象 let file = document.getElementById('fileInput').files[0]; // 分割文件 const chunkSize = 2 * 1024 * 1024; // 2MB let chunks = [], currentChunk = 0, totalChunks = 0; for (let i = 0; i &lt; file.size; i += chunkSize) { chunks.push(file.slice(i, i + chunkSize)); totalChunks++; } // 上传函数 function uploadNextChunk() { if (currentChunk &gt;= totalChunks) return; const chunk = chunks[currentChunk]; const formData = new FormData(); formData.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/859c477b4c1e491aa9e939a48a85d9e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/465e0e798b7dd7f1737ad2015047f6e1/" rel="bookmark">
			【Rust】——使用Drop Trait 运行清理代码和Rc＜T＞ 引用计数智能指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💻博主现有专栏：
C51单片机（STC89C516），c语言，c++，离散数学，算法设计与分析，数据结构，Python，Java基础，MySQL，linux，基于HTML5的网页设计及应用，Rust（官方文档重点总结），jQuery，前端vue.js，Javaweb开发，Python机器学习等
🥏主页链接：
Y小夜-CSDN博客
目录
🎯使用Drop Trait 运行清理代码
🎃通过std::mem::drop提早丢弃值
🎯Rc 引用计数智能指针
🎃使用Rc共享数据
🎃克隆Rc会增加引用计数
🎯使用Drop Trait 运行清理代码 对于智能指针模式来说第二个重要的 trait 是 Drop，其允许我们在值要离开作用域时执行一些代码。可以为任何类型提供 Drop trait 的实现，同时所指定的代码被用于释放类似于文件或网络连接的资源。
我们在智能指针上下文中讨论 Drop 是因为其功能几乎总是用于实现智能指针。
在其他一些语言中的某些类型，我们不得不记住在每次使用完那些类型的智能指针实例后调用清理内存或资源的代码。如果忘记的话，运行代码的系统可能会因为负荷过重而崩溃。在 Rust 中，可以指定每当值离开作用域时被执行的代码，编译器会自动插入这些代码。于是我们就不需要在程序中到处编写在实例结束时清理这些变量的代码 —— 而且还不会泄漏资源。
指定在值离开作用域时应该执行的代码的方式是实现 Drop trait。Drop trait 要求实现一个叫做 drop 的方法，它获取一个 self 的可变引用。为了能够看出 Rust 何时调用 drop，让我们暂时使用 println! 语句实现 drop。
struct CustomSmartPointer { data: String, } impl Drop for CustomSmartPointer { fn drop(&amp;mut self) { println!("Dropping CustomSmartPointer with data `{}`!", self.data); } } fn main() { let c = CustomSmartPointer { data: String::from("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/465e0e798b7dd7f1737ad2015047f6e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f993715445005d63f420e85d10dabf93/" rel="bookmark">
			Elasticsearch：理解近似最近邻 (ANN) 算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：来自 Elastic Elastic Platform Team
如果你是在互联网出现之前长大的，你会记得找到新喜好并不总是那么容易。我们是在无意中听到收音机里的新乐队时发现他们的，是因为忘了换频道偶然看到一个新电视节目的，也是几乎完全依据游戏封面的图片来找到新喜欢的视频游戏的。
如今，情况大为不同。Spotify 会向我推荐符合我的口味的艺术家，Netflix 会突出显示它知道我们会喜欢的电影和电视节目，Xbox 知道我们接下来可能想玩什么。这些推荐系统让我们更容易找到我们实际在寻找的东西，它们由最近邻（nearest neighbor - NN）算法驱动。NN 算法查看它可用的广泛信息海洋，并识别与你喜欢的东西或你正在寻找的东西最接近的东西。
但 NN 算法有一个固有的缺陷。如果它们分析的数据量太大，遍历每一个选项将永无止境。这尤其是问题，因为这些数据源每年都在变得越来越大。这就是近似最近邻（ANN）接过NN的接力棒并改变游戏规则的地方。
在本文中，我们将讨论关于 ANN 的以下关键主题：
ANN 的定义 ANN 的工作原理何时使用 ANN 搜索ANN 在向量搜索中的重要性各种类型的 ANN 算法 近似最近邻解释 近似最近邻（approximate nearest neighbor - ANN）是一种算法，它在数据集中找到一个非常接近给定查询点的数据点，但不一定是绝对最接近的一个。一个最近邻（NN）算法通过对所有数据进行详尽搜索来找到完美匹配，而近似最近邻（ANN）算法则会接受一个足够接近的匹配。
这听起来可能不是最好的解决方案，但实际上它是实现快速相似性搜索的关键。ANN 利用智能的快捷方式和数据结构来高效地遍历搜索空间。因此，它可以在大大减少时间和资源的情况下，识别出足够接近的数据点，在大多数实际场景中都是有用的。
基本上，这是一种权衡。如果你绝对需要找到最佳匹配，你可以通过 NN 来实现，但这会牺牲速度和性能。但是，如果你可以容忍精度的微小下降，ANN 几乎总是一个更好的解决方案。
近似最近邻（ANN）算法的 工作原理的第一部分是降维，其目标是将高维数据集转化为低维数据集。其目的是使预测模型任务比分析所有数据更简单、更高效。
这些算法基于数学概念的度量空间，其中数据点存在并且它们之间的距离被定义。这些距离必须遵循特定的规则（非负性、恒等性、对称性、三角不等式），常见的函数如欧几里得距离或余弦相似度用于计算它们。
为了更好地理解这一点，想象一下你在度假，正在寻找你租的别墅。与其逐一检查每栋建筑（高维），你可以使用地图，将问题简化为二维（低维）。（这是一个故意简化的例子。降维并不是 ANN 算法改善效率的唯一方法。）
ANN 算法还利用称为索引的巧妙数据结构来提高效率。通过将数据预处理成这些索引，ANN 可以更快地遍历搜索空间。可以将这些想象成街道标志，帮助你在地图上找到你的位置，更快地到达度假别墅。
何时使用近似最近邻搜索 在数据科学的快速发展世界中，效率至上。虽然找到真正最近的邻居（精确最近邻搜索）具有价值，但它常常需要较大的计算成本，正如我们已经讨论过的。这就是近似最近邻（ANN）搜索发光发热的地方，它提供了一个有吸引力的折衷方案：闪电般的速度与高但非绝对的准确性。
但是，确切地说，你应该在什么情况下选择 ANN 而不是其他搜索方法呢？
精确最近邻搜索可能很慢，但当精确度是你的首要任务或你正在使用小数据集时，它是最佳选择。k-nearest neighbors（kNN）位于 NN 和 ANN 之间，它在保持高准确性的同时提供更快的结果。但是，在决定k的值时可能难以准确把握，它也难以处理高维数据。
ANN 的速度和效率结合其高（但非绝对的）准确性，使其在许多情况下非常完美：
大数据集：当处理百万甚至十亿级的数据点时，精确 NN 的详尽性质变得缓慢。ANN 在浏览庞大的数据景观中表现出色，迅速提供结果。高维数据：随着维度的增加，精确 NN 的计算量激增。ANN 的降维技术有效地缩小了搜索空间并提高了复杂数据（如图像或文本）的效率。实时应用：需要即时结果吗？推荐系统、欺诈检测和异常检测依赖于实时洞察。ANN 的速度使其非常适合这些场景。可接受的近似：如果你的应用可以容忍结果中的轻微不准确，ANN 的速度变得非常宝贵。例如，在图像搜索中，找到视觉上相似的图像 —— 而不是绝对最接近的一个 —— 可能就足够了。 ANN 在向量搜索中的重要性 向量搜索涉及将数据编码为密集向量，捕捉复杂的关系和嵌入式含义。这使得它非常适合搜索图像、文本和用户偏好等内容，而传统的基于关键词的搜索往往表现不佳。但是，维度诅咒也同样适用于这里。因为随着代表这些向量的维度数量增加，传统的搜索方法也会遇到困难，变得缓慢且低效。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f993715445005d63f420e85d10dabf93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dd9841f70b26742c1c94cb32ae64acd/" rel="bookmark">
			RabbitMQ之顺序消费
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是顺序消费
例如：业务上产生者发送三条消息， 分别是对同一条数据的增加、修改、删除操作， 如果没有保证顺序消费，执行顺序可能变成删除、修改、增加，这就乱了。
如何保证顺序性
一般我们讨论如何保证消息的顺序性，会从下面三个方面考虑
1：发送消息的顺序
2：队列中消息的顺序
3：消费消息的顺序
发送消息的顺序
消息发送端的顺序，大部分业务不做要求，谁先发消息无所谓，如果遇到业务一定要发送消息也确保顺序，那意味着，只能全局加锁一个个的操作，一个个的发消息，不能并发发送消息。
队列中消息的顺序
RabbitMQ 中，消息最终会保存在队列中，在同一个队列中，消息是顺序的，先进先出原则，这个由 RabbitMQ 保证，通常也不需要开发关心。
不同队列 中的消息顺序，是没有保证的，例如：进地铁站的时候，排了三个队伍，不同队伍之间的，不能确保谁先进站。
消费消息的顺序
我们说如何保证消息顺序性，通常说的就是消费者消费消息的顺序，在多个消费者消费同一个消息队列的场景，通常是无法保证消息顺序的，
虽然消息队列的消息是顺序的，但是多个消费者并发消费消息，获取的消息的速度、执行业务逻辑的速度快慢、执行异常等等原因都会导致消息顺序不一致。
例如：消息A、B、C按顺序进入队列，消费者A1拿到消息A、消费者B1拿到消息B, 结果消费者B执行速度快，就跑完了，又或者消费者A1挂了，都会导致消息顺序不一致。
解决消费顺序的问题， 通常就是一个队列只有一个消费者 , 这样就可以一个个消息按顺序处理， 缺点就是并发能力下降了，无法并发消费消息，这是个取舍问题。
如果业务又要顺序消费，又要增加并发，通常思路就是开启多个队列，业务根据规则将消息分发到不同的队列，通过增加队列的数量来提高并发度，例如：电商订单场景，只需要保证同一个用户的订单消息的顺序性就行，不同用户之间没有关系，所以只要让同一个用户的订单消息进入同一个队列就行，其他用户的订单消息，可以进入不同的队列。 以下为代码设计过程实现
首先我们必须保证只有一个消费者 那么问题就来了，我们的项目一般是多副本的，如何保证只有一个副本在消费呢
这时就会用到消费者 单活模式 x-single-active-consumer
使用下述配置实现
private Queue creatQueue(String name){ // 创建一个 单活模式 队列 HashMap&lt;String, Object&gt; args=new HashMap&lt;&gt;(); args.put("x-single-active-consumer",true); return new Queue(name,true,false,false,args); } 创建之后，我们可以在控制台看到 消费者的激活状态
=======================&gt;配置类 @Configuration @SuppressWarnings("all") public class DirectExchangeConfiguration { @Bean public Queue queue15_0() { return creatQueue(Message15.QUEUE_0); } @Bean public Queue queue15_1() { return creatQueue(Message15.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8dd9841f70b26742c1c94cb32ae64acd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5af815f6ad28bd4bf7d0731ea0defb4/" rel="bookmark">
			关于PostgreSQL的20道面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 请解释PostgreSQL中的事务（Transaction）以及它的ACID属性。 PostgreSQL中的事务具有ACID属性，确保了数据库操作的可靠性和数据一致性。
以下是ACID各个属性的具体含义及举例说明：
原子性（Atomicity）：事务是最小的执行单位，其中的每个操作要么全部成功，要么全部失败。如果在事务中有任何操作失败，那么整个事务都会被回滚，数据库将返回到事务开始前的状态。例如，在银行转账操作中，如果用户A向用户B转账，这个过程包括从A的账户扣除金额和向B的账户增加相同金额两个步骤。原子性保证了这两个步骤要么都发生，要么都不发生，不会出现只扣款而不增款的情况。一致性（Consistency）：事务完成后，数据库中的所有数据都必须保持一致的状态。一致性确保了数据库在事务执行前后都处于有效和一致的状态。例如，如果数据库中有一个规则是账户余额不能为负，那么即使执行了转账操作，系统也会确保这个规则在事务完成后仍然被遵守。隔离性（Isolation）：隔离性保证了事务之间的独立性，即一个事务的执行不受其他并发执行的事务的影响。PostgreSQL通过MVCC（多版本并发控制）机制来实现读写操作的非阻塞性，提高了系统的并发性能。例如，当多个用户同时查询同一个数据时，每个用户都能看到一致的数据视图，而不会因为其他用户的写操作而受到影响。持久性（Durability）：一旦事务被提交，它对数据库所做的修改就是永久性的。即使在系统故障或其他异常情况下，这些更改也不会丢失。例如，当用户完成转账并提交事务后，即使数据库系统崩溃，当系统恢复后，转账的结果仍然有效，不会丢失。 总的来说，ACID属性是关系型数据库管理系统中事务管理的基础，它们共同工作以确保数据库操作的正确性和数据的完整性。
2. 请解释PostgreSQL中的数据类型，例如：INTEGER、VARCHAR、DATE等。 PostgreSQL 支持多种数据类型，以满足不同数据存储和处理的需求。以下是一些常见的数据类型及其说明：
整数类型：用于存储整数值，包括integer、bigint等。例如，integer适用于一般大小的整数，而bigint适用于非常大的整数。字符类型：用于存储字符串数据，包括char(n)（固定长度的字符串）和varchar(n)（可变长度的字符串）。例如，varchar(100)可以存储最多100个字符的字符串。日期/时间类型：用于存储日期和时间信息，包括date、time、timestamp等。例如，date用于存储日期，而timestamp用于存储日期和时间。浮点数类型：用于存储小数值，包括real和double precision。例如，double precision可用于存储双精度浮点数。布尔类型：用于存储布尔值（真或假），使用boolean类型。二进制数据类型：用于存储二进制数据，如bytea类型用于存储字节数组。JSON类型：用于存储JSON格式的数据，包括json和jsonb类型，后者提供了更好的性能和存储效率。几何类型：用于存储地理空间数据，如point、line、polygon等。文本搜索类型：用于全文搜索，如tsvector和tsquery。金额类型：用于存储货币值，如money类型。枚举类型：允许用户定义一组值的集合，用于存储特定的数据集合。任意精度类型：用于存储任意精度的数字，如numeric(p,s)，其中p是精度，s是标度。序列类型：用于自动生成唯一标识符，如serial类型，它是一个4字节的整数。 这些数据类型为开发者提供了丰富的选项，以高效地存储和管理不同类型的数据。在实际应用中，选择合适的数据类型对于优化数据库性能和存储效率至关重要。
3. 请解释PostgreSQL中的索引（Index）以及它的作用。 PostgreSQL中的索引是一种数据库对象，用于提高查询性能。它的作用可以概括为以下几点：
提高查询速度：索引可以加速对数据的查找过程，因为它是指向表数据的指针，类似书的目录。当你在数据库中搜索特定的数据时，索引可以帮助你快速定位到所需的数据行，而不必扫描整个表。减少磁盘I/O操作：通过使用索引，可以减少读取表中不必要的数据行，从而减少磁盘I/O操作，这对于性能尤其重要。支持多种查询操作：B-tree索引（默认的索引类型）适合处理等值查询、范围查询以及排序和分组等操作。它支持的操作包括&lt;、&lt;=、=、&gt;、&gt;=以及这些操作的组合，如BETWEEN AND，以及在索引列上的IS NULL或IS NOT NULL。 以下是一个简单的示例，说明如何在PostgreSQL中创建和使用索引：
假设我们有一个名为employees的表，其中包含员工的信息，如下所示：
CREATE TABLE employees ( id SERIAL PRIMARY KEY, first_name VARCHAR(50), last_name VARCHAR(50), department VARCHAR(50), salary DECIMAL(10, 2) ); 为了提高查询性能，我们可以在salary列上创建一个索引，这样当执行涉及工资的查询时，数据库可以更快地找到结果：
CREATE INDEX idx_employees_salary ON employees(salary); 现在，当我们执行如下查询时：
SELECT * FROM employees WHERE salary &gt; 50000; 查询优化器会使用我们创建的idx_employees_salary索引来加速查找过程，因为它是一个范围查询，这正是B-tree索引擅长处理的类型。
需要注意的是，虽然索引可以提高查询性能，但它也会占用额外的存储空间，并且在插入、更新或删除数据时，索引本身也需要被维护，这可能会导致写操作的性能略有下降。因此，在决定是否创建索引时，需要权衡读操作的性能提升和写操作的成本。
4. 请解释PostgreSQL中的主键（Primary Key）和外键（Foreign Key）。 PostgreSQL中的主键（Primary Key）是用于唯一标识表中每一行记录的一列或一组列，而外键（Foreign Key）则是用于建立两个表之间关系的约束，它引用另一个表的主键列。
具体来说，主键具有以下特点：
唯一性：主键的值在表中必须是唯一的，不能有重复。非空性：主键列不允许存储空值（NULL）。 例如，如果我们有一个用户表（users），可以为用户ID（user_id）设置主键，以确保每个用户都有一个唯一的标识符。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5af815f6ad28bd4bf7d0731ea0defb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1ef9f6d206eccb57de32eed0a5423e2/" rel="bookmark">
			Android - 微信低版本登录提示版本过低
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天搞个特殊的，据说是微信低版本可以设置透明头像，简单总结一下操作步骤。
这类的最好不要在自己的手机上测试，本次使用的是PC模拟设备来的
雷电模拟器（模拟Android设备）
NP管理器_3.1.1.apk
com.tencent.mm_1570e359-7.0.9.apk（7.0.9版本的微信）
weixin8048android2580_0x28003036_arm64.apk（新版本的微信）
1、环境准备 首先官网下载雷电模拟器，安装 NP管理器_3.1.1.apk 打开 NP管理器，注册后登录
将新旧微信apk推送到模拟器中，路径最好是 storage/emulated/0，因为 NP管理器默认打开的路径就是这个
C:\Users\lichang&gt;adb devices
List of devices attached
127.0.0.1:5555 device
emulator-5554 device
C:\Users\lichang&gt;adb -s emulator-5554 push C:\Users\lichang\Desktop\wechat\com.tencent.mm_1570e359-7.0.9.apk storage/emulated/0
C:\Users\lichang\Desktop\wechat\com.tencent.mm_1570e359-7.0.9.a...1 file pushed, 0 skipped. 25.9 MB/s (132870309 bytes in 4.886s)
刷新NP管理器界面，应该如下图所示：
2、获取新旧微信的特征码 首先查看新版本的特征码
继续打开 AndroidManifest.xml 右上角选项中选择 搜索 输入 CLIENT_VERSION ，然后保存 value 的值
相同的方法查看旧的微信apk，获取旧微信的特征码
3、替换旧版本的特征码 查看 com.tencent.mm_1570e359-7.0.9.apk 点击 classes.dex -&gt; 打开方式选择 Dex编辑Plus ，然后全选
然后检索旧的特征码的位置，接下来我们将其替换为新的即可。
替换的输入框输入新的特征码，然后保存。我这里是替换了两个位置
然后返回保存编译 4、签名 修改之后需要对apk进行签名，然后就可以安装使用了。
仅作个人学习使用哈
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/043eb3ebb9c32bd8c3f05f1b2daaa8e3/" rel="bookmark">
			2024年最新Mac版本 - 2024最新版Intellij IDEA 新手开发环境安装使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、开发工具下载
二、安装过程（包括激活）
三、使用IDEA 创建JavaWEB项目教程
四、其他设置及2020版新特性
一、开发工具下载 Intellij IEDA下载地址：https://www.jetbrains.com/idea/download/#section=mac
**IEDA分为两个版本 ：**旗舰版（Ultimate）、社区版本（Community）
**区别：**旗舰版功能齐全，但是收费（30天试用期） 。社区版免费，功能不全。
**本教程安装使用旗舰版：**如图点击下载
2.JDK下载地址：https://www.oracle.com/java/technologies/javase-jdk8-downloads.html(修改 JDK8中的数字,可以下载对应的版本) 根据自己电脑下载对应的JDK版本
3. Tomcat服务器：https://tomcat.apache.org/download-90.cgi
本案例使用Tomcat9.0.34版本
二、安装过程 双击下载好的安装文件 将开发软件拖拽至"Applications"中 选择是否：导入IntelliJ IDEA设置（默认选择不导入设置） 设置主题 根据个人喜好选择、黑色显得比较炫酷一点，下方有两个选择（默认是选择的是黑色）
Skip Remaining and Set Defaults：跳过剩余部分，设置默认值
Next: Launcher Script：下一个:启动脚本
点击【Next: Launcher Script】- 下一页:启动脚本
​ 默认黑色主题
定制比较有个人特色的设置（直接忽略） 点击【Next: Default plugins】- 下一个:默认插件
设置IEDA插件 设置IEDA中的各种插件，可以进行自定义设置、支持不同的开发或快速开发的一些插件。这里不做介绍，后续也可以通过界面菜单设置功能中进行设置。
IDEA插件官网下载地址：https://plugins.jetbrains.com/idea
点击【Next: Featured plugins】
点击【Start using Intellij IDEA】 - 开始使用Intellij IDEA 旗舰版IEDA激活 Activate Intellij IDEA - 激活Intellij IEDA
Evaluate for free - 免费试用/评估 30天试用期
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/043eb3ebb9c32bd8c3f05f1b2daaa8e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a076333db1cec5ca42663e97dcd26f39/" rel="bookmark">
			2024年Python最新Python二级考试试题汇总（史上最全）_计算机二级python真题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		表达式 1001 == 0x3e7 的结果是：
A
false
B
False
C
true
D
True
正确答案： B
以下选项，不是Python保留字的选项是：
A
del
B
pass
C
not
D
string
正确答案： D表达式 eval(‘500/10’) 的结果是：
A
‘500/10’
B
500/10
C
50
D
50.0
正确答案： D 表达式 type(eval(‘45’)) 的结果是：
A
&lt;class ‘float’&gt;
B
&lt;class ‘str’&gt;
C
None
D
&lt;class ‘int’&gt;
正确答案： D 表达式 divmod(20,3) 的结果是：
A
6, 2
B
6
C
2
D
(6, 2)
正确答案： D以下关于字符串类型的操作的描述，错误的是：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a076333db1cec5ca42663e97dcd26f39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/319567f7f05af61b2724966eda27a0ee/" rel="bookmark">
			在AndroidStudio创建Flutter项目并运行到模拟器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Flutter简介 Flutter是Google开源的构建用户界面（UI）工具包，帮助开发者通过一套代码库高效构建多平台精美应用，支持移动、Web、桌面和嵌入式平台。Flutter 开源、免费，拥有宽松的开源协议，适合商业项目。
官网：
Flutter中文网 官网
2.安装AndroidStudio并下载Flutter插件 AndroidStudio安装方法可以参考这篇文章：2023最新版Android studio安装入门教程（非常详细）从零基础入门到精通，看完这一篇就够了-CSDN博客
我的安装AndroidSDK地址保存在D:\PubData\Android\SDK。如下图所示：
在AndroidStudio开发工具中File&gt;Settings&gt;Plugins中搜索Flutter安装。第一次安装Flutter会提示安装Dart插件，点击Install按钮。最后重启IDE使插件生效。
查看到安装好了Flutter和Dart。 3.Flutter SDK安装 官网地址：
Archive | Flutter
根据自己的环境下载最新稳定版本（Stable channel），当前最新版是3.19.6 。
下载完成后，解压到某一位置，D:\PubData\flutter_windows_3.19.2-stable
4.设置环境变量 设置系统环境变量：
添加用户环境变量的Path：
设置完成后，在cmd命令行执行flutter doctor来检查flutter环境是否正常。如果有问题会显示红色的X，根据具体情况自行解决，再进行检查。如下图中的X问题的解决方法：
4.1问题1—缺少安装插件 cmdline-tools component is missing 描述：
[!] Android toolchain - develop for Android devices (Android SDK version 34.0.0)
X cmdline-tools component is missing
Run `path/to/sdkmanager --install "cmdline-tools;latest"`
See https://developer.android.com/studio/command-line for more details.
解决办法：根据路径Settings&gt;Languages&amp;frameworks&gt;SDK Tools&gt;Android SDK Command-line Tools(latest)勾选点Apply按钮安装。
4.2问题2Android license status unknown. 描述：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/319567f7f05af61b2724966eda27a0ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0174c5a98aec0b7af9376b4f1b74690f/" rel="bookmark">
			GitHub Copilot Workspace：欢迎进入原生Copilot开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每周跟踪AI热点新闻动向和震撼发展 想要探索生成式人工智能的前沿进展吗？订阅我们的简报，深入解析最新的技术突破、实际应用案例和未来的趋势。与全球数同行一同，从行业内部的深度分析和实用指南中受益。不要错过这个机会，成为AI领域的领跑者。点击订阅，与未来同行！ 订阅：https://rengongzhineng.io/
过去两年里，生成性AI作为开发环境中的一项工具，从根本上改变了开发者的工作场景。2022年，我们推出了GitHub Copilot，这是一种在编辑器中的自动完成配对编程工具，提升了高达55%的开发者生产力。如今，Copilot已成为最广泛使用的AI开发工具。到了2023年，我们又推出了GitHub Copilot Chat——解锁了在编码、调试和测试中使用自然语言的能力——允许开发者实时与代码对话。
在去年GitHub Universe的早期展示后，今天，我们正重新想象开发者体验的本质，推出了GitHub Copilot Workspace的技术预览版：一个原生支持Copilot的开发环境。在Copilot Workspace中，开发者现在可以用自然语言进行头脑风暴、计划、构建、测试和运行代码。这种新的以任务为中心的体验，从头到尾利用不同的Copilot驱动代理，同时让开发者完全控制整个过程。
Copilot Workspace代表了一种全新的、使用自然语言构建软件的方式，它专门设计来提供（而非替代）开发者的创造力，使开发更快、更简单。通过Copilot Workspace，我们将赋予经验丰富的开发者作为系统思考者的能力，并大幅降低进入软件构建领域的门槛。
欢迎来到新开发环境的第一天。以下是它的工作方式：
一切从任务开始……
从一个任务开始。从GitHub问题、拉取请求或仓库打开GitHub Copilot Workspace。（octoacademy仓库中的问题截图。）
对开发者来说，进入门槛几乎总是从开始就设置了障碍。想想你在一个大项目、功能请求或甚至是报告错误的第一步时常常遇到的障碍，仅仅因为你不知道如何开始。GitHub Copilot Workspace就在起点处迎接开发者：一个GitHub仓库或GitHub问题。通过利用Copilot代理作为第二大脑，开发者从一开始就有了AI的帮助。
…Workspace构建完整计划
从你的任务进展到一个规范，概述你希望用Copilot Workspace实现的目标。步骤是可编辑的，使你能够对想法进行迭代。
从那里开始，Copilot Workspace提供了一个一步步的计划来解决问题，这些计划基于对代码库、问题回复等的深入理解。它提供了你需要的一切来验证计划，并以自然语言的形式测试代码。
而且完全可以编辑……
然后调整你的行动计划，添加步骤和一般注释。计划实施后，你可以查看PR差异视图并根据需要进行编辑。
GitHub Copilot Workspace提出的所有内容——从计划到代码——都是完全可编辑的，允许你迭代直到对前路充满信心。你保留了所有的自主权，而Copilot Workspace减轻了你的认知负担。一旦你对代码感到满意，你可以使用集成的终端来运行单元测试、构建和适当的检查。一旦你对计划感到满意，你可以直接在Copilot Workspace中运行你的代码，跳入底层的GitHub Codespace，并调整所有代码更改直到你对最终结果感到满意。你还可以通过链接即时与你的团队共享工作区，以便他们可以查看你的工作甚至尝试他们自己的迭代。
然后剩下的就是提交你的拉取请求，运行你的GitHub Actions，进行安全代码扫描，并请求你的团队成员进行人工代码审查。最棒的是，他们可以利用你的Copilot Workspace来看到你是如何从想法到代码的。
另外：GitHub Copilot Workspace也支持移动设备
而且因为灵感随时可能到来，GitHub Copilot Workspace被设计为可以在任何设备上使用——无论是在桌面、笔记本电脑上，还是在外出时，都能实现真正的开发环境。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a813f53d7d35141d21c8bf6455962e35/" rel="bookmark">
			C&#43;&#43;必修：类与对象(二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨✨ 欢迎大家来到贝蒂大讲堂✨✨
🎈🎈养成好习惯，先赞后看哦~🎈🎈
所属专栏：C++学习
贝蒂的主页：Betty’s blog
1. 构造函数 1.1. 定义 构造函数是一个特殊的成员函数，名字与类名相同, 创建类类型对象时由编译器自动调用，以保证每个数据成员都有 一个合适的初始值，并且在对象整个生命周期内只调用一次。其特点如下：
函数名与类名相同。无返回值。对象实例化时编译器自动调用对应的构造函数。构造函数可以重载。 下面是一个日期类的构造函数
class Date { public: Date(int year, int month, int day) { _year = year; _month = month; _day = day; } void Print() { cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl; } private: int _year; int _month; int _day; }; int main() { Date d1(1,1,1);//自动调用 d1.Print(); return 0; } 构造函数的功能就相当于我们之前书写的初始化函数，但由于其自动调用的特性，大大提升了代码的容错率。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a813f53d7d35141d21c8bf6455962e35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c3fbdca6e573e0459b55b9711819c84/" rel="bookmark">
			Android之SQLite数据库及SQLiteStudio工具的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		db.execSQL(“insert into student(id, name, age, grade) values(?, ?, ?, ?, ?)”, new Object[]{1230001, “张三”, 17, 75});
执行删除操作，调用SQLiteDatabase中的execSQL()方法，第一个参数时sql语句，第二个参数时sql语句中占位符参数的值，数组顺序与占位符对应
db.execSQL(“delete from Student where name = ?”, new Object[]{“李华”});
执行更新操作，调用SQLiteDatabase中的execSQL()方法，参数为sql语句
db.execSQL(“update student set id = 1111111 where name=‘张三’”);
执行查询操作，调用SQLiteDatabase中的rawQuery()方法，第一个参数时sql语句，第二个参数为null
db.rawQuery(“select * from student”, null);
（四）SQLite数据的可视化
=========================================================================
1.下载SQLiteStudio
点击这里
直接下载后打开，傻瓜式安装
2.添加插件
打开SQLiteStudio，点击菜单栏中的Tools-&gt;open cofiguration dialog，选中Plugins（插件），选中Android SQLite，点击OK
3.添加包
插件添加完成后，再点击Tools-&gt;Get Android connector Jar File，导出jar包放入项目中的libs文件夹。
4.连接
在SQLiteStudio中连接手机上项目的数据库，在菜单栏中选择Database-&gt;Add a database
运行程序，SQLiteStudio可调试数据库的数据
（五）运行效果
=================================================================
主页面：
点击创建数据库，Log打印日志
点击插入数据（SQLiteStudio中显示数据）
点击删除数据：（SQLiteStudio显示数据和Android中Log打印日志）
更新数据：（SQLiteStudio显示数据和AndroidStudio中Log打印日志）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c3fbdca6e573e0459b55b9711819c84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e5f1dd0fff7142e5033a174f491206e/" rel="bookmark">
			医疗AI的一大步: Google Med-Gemini
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人工智能技术在医疗领域的应用一直备受瞩目。近年来,随着自然语言处理和计算机视觉的快速发展,智能医疗系统的能力不断提升,在辅助诊断、预测疾病风险、优化治疗方案等方面展现出巨大潜力。作为这一领域的领军企业之一,Google推出了Med-Gemini系列模型,为医疗AI技术的发展树立了新的里程碑。
Med-Gemini模型建立在谷歌此前发布的Gemini大型多模态模型之上。Gemini通过在海量文本、图像、视音频等跨模态数据上的预训练,具备了惊人的语言理解和生成能力。在此基础上,Med-Gemini针对医疗场景进行了进一步的调校和优化,旨在为医疗决策提供更专业、更精准的支持。
本文将从技术架构、基准测试和潜在应用等角度,深入剖析Med-Gemini系列模型的创新之处。通过客观呈现其在多个任务上的出色表现,展望这一突破性进展对未来智能医疗的深远影响,并讨论在实际部署过程中可能面临的挑战。
https://arxiv.org/pdf/2404.18416
研究方法
Med-Gemini系列模型的开发流程可分为三个主要阶段:模型微调、多模态理解和长文本处理。
在模型微调阶段,研究团队采用了自训练(self-training)和搜索工具使用(tool use)相结合的策略,以提升模型在医学推理任务上的表现。通过在大规模医学问答数据如MedQA上微调,并引入外部搜索结果作为额外线索,Med-Gemini显著强化了处理复杂病例时的分析和决策能力。同时,研究人员设计了一种基于不确定性的搜索机制,使模型能主动查阅资料以弥补知识盲区,进一步提高了输出的可靠性。
对于多模态理解,团队在Med-Gemini的基础上融合了领域特定的编码器,以适应医学影像、病理切片等特殊数据类型。借助庞大的跨模态医疗数据集,模型学会了从视觉信息中准确提取关键诊断线索,并与文本、语音等其他模态的信息进行整合,形成更全面的临床认知。
在长文本处理方面,Med-Gemini通过编码器和注意力机制的优化,实现了对数万字量级医疗记录的高效编码和理解。模型能够在海量病历数据中准确定位关键信息,总结患者的病史、主诉、检查和用药情况等,并支持医疗人员进行纵向追踪分析,及早发现疾病风险因素。
模型评估
为全面评估Med-Gemini的性能,研究团队在14项权威医疗基准测试中对其进行了严格的考核,涵盖医学知识、临床推理、基因组学、医学影像等诸多领域。
在备受瞩目的MedQA测验中,Med-Gemini凭借独特的不确定性引导搜索机制,以91.1%的准确率刷新了纪录,比此前最好的Med-PaLM 2模型高出4.6个百分点。为进一步验证结果的可靠性,研究人员邀请临床专家对MedQA测试集进行了仔细核查,剔除了部分存在错误或歧义的试题,确保性能提升的确切性。
除MedQA外,Med-Gemini在新英格兰医学杂志案例讨论(NEJM CPC)、基因分析(GeneTuring)等复杂任务上亦有亮眼表现,充分展现了其在医学推理方面的优势。而在涉及影像、心电图等多模态数据的测试中,Med-Gemini的表现同样出类拔萃。例如在7项健康医疗类的视觉问答任务上,其平均优于GPT-4V模型44.5%。
长文本处理能力是Med-Gemini的另一大亮点。它在医疗记录的关键信息检索(MIMIC-III)以及医学教学视频问答(MedVidQA)等需分析海量文本的任务中均取得了最佳成绩,凭借情境学习能力超越了此前专门构建的系统,彰显了该模型在实际应用场景下的潜力。
实验结果
Med-Gemini在一系列基准测试中的优异表现,为其在真实医疗场景中的应用奠定了坚实基础。为进一步评估其实用价值,研究团队设计了医学文本摘要、转诊信撰写、医学术语简化等任务,并与人类专家的表现进行对比。
结果显示,在自动生成病历摘要方面,Med-Gemini的输出在临床可用性上达到甚至超越了人类医生的水准。根据临床医生的评估,模型生成的摘要在准确性、覆盖面、简洁性等方面皆优于人工撰写的样本。这一发现意味着Med-Gemini有望显著减轻医护人员的文书负担,为其腾出更多时间专注于患者沟通和临床诊疗。
在转诊信的自动生成任务中,Med-Gemini的表现同样出色。经盲评,83%的受试医生认为模型撰写的转诊信总体优于或等同于人类专家。这预示着该系统在未来有望作为智能助手,协助医生高效地完成常见的写作任务,提升沟通效率。
Med-Gemini在多模态对话和长文本处理领域的潜力同样引人注目。研究人员通过真实样本展示了模型在皮肤病理和放射诊断中的应用前景。借助多模态理解和医学知识图谱,该系统能够引导患者提供症状细节和相关检查,并给出专业的初步判断。虽尚不能完全取代医生,但这一功能或可作为前置筛查和分诊的有力辅助。
在生物医学研究领域,Med-Gemini展现出从海量文献中提炼关键信息,加速基因型-表型关联分析的能力。通过长文本处理技术,它成功地总结了大量关于FTO基因与肥胖症关系的研究发现,将具说服力的实验证据以简明扼要的方式呈现给使用者。这一案例表明,Med-Gemini有望成为生物医学研究人员的得力助手,帮助他们及时掌握最新进展,聚焦关键科学问题。
综合以上实验结果,我们可以合理预期,Med-Gemini在未来智能医疗体系中将扮演日益重要的角色。它不仅能够为临床诊疗提供更精准的决策支持,还可显著提升医患沟通和跨专科协作的效率。随着技术的不断成熟和完善,这一突破性的AI系统有望为医疗服务带来全方位的变革。
结论
Med-Gemini系列模型在医疗AI领域的突破性进展,为智能医疗系统的发展开启了崭新的篇章。借助海量医学知识和多模态数据的训练,这一全新的AI架构展现出惊人的医学理解和推理能力。它不仅在权威基准测试中取得了领先业界的成绩,更在面向真实世界的任务中初步证明了其实用价值。
然而,医疗领域事关人命,对AI系统的安全性和可靠性有着极高的要求。尽管Med-Gemini在实验环境下表现出色,其真正投入临床应用仍需经过长期、严格的验证。相关技术在落地过程中可能面临资料品质参差、隐私保护、法律监管等诸多挑战。这就要求技术团队与医疗机构、政策制定者等多方通力合作,在确保患者利益的前提下稳妥推进。
Med-Gemini的发布彰显了Google在智能医疗领域的雄心和实力。作为该领域的技术领军者,谷歌充分利用了自身在自然语言处理、知识图谱等方面的优势,构建了一个全方位的医疗AI平台。可以预见,随着Med-Gemini的不断迭代升级,它必将与其他先进医疗系统一道,为人类健康事业做出更多贡献。
我们有理由相信,随着人工智能技术的日益成熟,智能医疗将不再是遥不可及的愿景,而是切实惠及大众的现实。在这一进程中,以Med-Gemini为代表的尖端AI系统将扮演关键的推动者和赋能者角色。它们与人类医护工作者优势互补、协同作业,必将开创医疗服务的崭新局面,让更多患者以更低成本获得更优质的健康照护。这无疑将是智能科技造福人类的又一重大里程碑。
不过,任何新技术的发展和应用都不可能一蹴而就。在憧憬智能医疗美好前景的同时,吾人亦需保持理性和警惕。AI系统毕竟是基于数据和机器学习算法构建的,其判断并非绝对无误,在复杂多变的临床场景中可能面临知识盲区和推理谬误。因此,如何建立人机协同的长效机制,发挥各自所长、抑制彼此局限,是智能医疗走向成熟亟需攻克的难题。
此外,AI技术在医疗领域的应用还可能引发一系列伦理难题。机器偏见、隐私保护、责任归属等问题若处理不当,则可能加剧健康照护的不平等,侵犯患者的合法权益,甚至动摇社会对医疗系统的信任根基。这就需要技术团队自始至终将伦理考量融入系统设计之中,并与各界利益相关者保持坦诚沟通,在公众监督下稳步推进。
总而言之,Med-Gemini的问世标志着智能医疗迈出了坚实的一大步。它为医疗AI技术在真实世界中的应用探索了诸多可能,为广大患者带来了新的希望。展望未来,随着更多类似系统的成熟和完善,人工智能必将深刻重塑医疗服务的方方面面,让优质医疗触手可及。在这一过程中,科技工作者与医疗工作者将携手并肩,以"智"造福人类健康,共同开创智能医疗的崭新时代。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6296179f466feb0fe2c400730cd1bf72/" rel="bookmark">
			Java之类和对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一面向对象的初步认知 1.什么是面向对象 Java是一门纯面向对象的语言(Object Oriented Program，简称OOP)，在面向对象的世界里，一切皆为对象。面向对象是解决问题的一种思想，主要依靠对象之间的交互完成一件事情。用面向对象的思想来涉及程序，更符合人们对事物的认知，对于大型程序的设计、扩展以及维护都非常友好。 2.面向对象与面向过程 以面向过程方式来进行处理，就关注洗衣服的过程，洗衣机是怎么来洗衣服，如何来甩干的等细节。以面向对象方式来进行处理，就不关注洗衣服的过程，只需要将衣服放进洗衣机，倒入洗衣粉，启动开关即可，通过对象之间的交互来完成的。
二、类定义和使用 面相对象程序设计关注的是对象，而对象是现实生活中的实体，比如：洗衣机。但是洗衣机计算机并不认识，需要开发人员告诉给计算机什么是洗衣机。 上图左侧就是对洗衣机简单的描述，该过程称为对洗衣机对象(实体)进行抽象(对一个复杂事物的重新认知)，但是这些简化的抽象结果计算机也不能识别，开发人员可以采用某种面相对象的编程言来进行描述，比如：Java语言。
1.简单认识类 类是用来对一个实体(对象)来进行描述的，主要描述该实体(对象)具有哪些属性(外观尺寸等)，哪些功能(用来干啥)，描述完成后计算机就可以识别了。 比如：洗衣机，它是一个品牌，在Java中可以将其看成是一个类别。 属性：产品品牌，型号，产品重量，外观尺寸，颜色... 功能：洗衣，烘干、定时.... 2.类的定义格式 在java中定义类时需要用到class关键字，具体语法如下
// 创建类
class ClassName{
field; // 字段(属性) 或者 成员变量
method; // 行为 或者 成员方法
}
class为定义类的关键字，ClassName为类的名字，{}中为类的主体。 接下来为洗衣机定义一个类 class WashMachine{ public String brand; // 品牌 public String type; // 型号 public double weight; // 重量 public double length; // 长 public double width; // 宽 public double height; // 高 public String color; // 颜色 public void washClothes(){ // 洗衣服 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6296179f466feb0fe2c400730cd1bf72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8971d6fbd6719febbeaa8428df9832e6/" rel="bookmark">
			【送书福利-第四十四期】《 深入Rust标准库》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编辑推荐 适读人群 ：资深程序员，准备深入学习RUST，已经对RUST有一定经验的程序员
本书是Rust操作系统编程指南，深入浅出地介绍了Rust语言的核心奥秘
本书由具有20年系统级程序架构及开发经验的专家领衔撰写
本书对Rust的标准库代码进行了深入分析，适合具有一定Rust经验的程序员阅读
内容简介 本书深入分析了Rust标准库的源代码，并厘清了分析Rust标准库源代码的脉络。全书共14章。第1章对Rust标准库体系进行了概述性介绍；第2章分析了Rust的一些独特性；第3～8章分析了CORE库与ALLOC库，这两个库可用于编写操作系统内核与用户态应用程序；第9～13章分析了STD库，STD库仅用于编写用户态应用程序；第14章对异步编程进行了简单分析。
本书试图以标准库的源代码为基础分析Rust的一些最本质的内容，从而加快程序员掌握Rust的进程。Rust标准库也是Rust编码技巧、程序设计、架构设计的“结晶”，因此，本书大量篇幅集中在对这些内容的分析上。
作者简介 任成珺
拥有超过20年的系统级程序架构及开发经验，至今仍活跃在开发一线。
王晓娜
博士，任职于中国兵器工业集团公司北方科技信息研究所，善于深入浅出地解读艰深技术。
韩龙
硕士，任职于中信银行，从事多年IT基础设施及云服务规划与设计。
精彩书评 专家好评
探索Rust编程语言的深层奥秘，洞悉其标准库的精妙设计，是每位追求卓越的Rust开发者的必由之路。本书正是这样一本引领你深入Rust核心的佳作。它不仅细致剖析了标准库的每个角落，还深入探讨了背后的设计理念和语言哲学。无论你是Rust的初学者，还是希望提升自己到更高境界的资深开发者，本书都将为你的Rust之旅提供宝贵的指引和深刻的洞见。让我们一起跟随作者任成珺的步伐，揭开Rust标准库的神秘面纱，掌握这门现代编程语言的精髓，释放你的创造力，构建更安全、更高效的软件。
秦华松 云合智网（上海）技术有限公司 OTT部门研发经理
这是一本细致且深入的编程图书。从标准库着手是深入学习RUST语言的巧妙路径，也一定会对用RUST语言开展实际工作产生巨大的成效。总之这是一本能体现作者25年功力的编程佳作。
郑展伟 北京百卓网络技术有限公司 CTO
一接触RUST语言，我就被其在高性能下保证内存安全、高度抽象的能力所折服，产生了在产品开发上尽快引入的迫切感。我在深入了解Rust语言的过程中，正巧遇到任成珺在社区分享《深入Rust标准库：必备的Rust语言高级指南》，这本书以架构师的视角深入解读了Rust标准库的源代码。这本书最难得的是，作者摆脱了晦涩的技术语言，以深厚的洞察力，对Rust标准库进行深入探究，并做了细致清晰的解读，娓娓道来。本书在对Rust标准库进行系统性阐述的同时对关键细节也不吝笔墨。通过本书，读者可以进一步了解Rust标准库的精妙设计。本书是一本难得的Rust编程学习的图书，值得每一位Rust程序员阅读。
常志民 北京华信傲天网络技术有限公司 研发负责人
购书链接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb99c146f41c735774f308c906e67405/" rel="bookmark">
			快速体验 Spring Cloud Alibaba AI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快速体验 Spring Cloud Alibaba AI Spring AI 旨在简化包含人工智能相关功能的应用程序的开发，避免不必要的复杂性。
Spring AI 的核心是提供抽象，作为开发 AI 应用程序的基础。这些抽象有多种实现方式，只需极少的代码改动即可轻松实现各个大模型之间的切换。
Spring AI 提供以下功能：
支持所有主要模型提供商，例如 OpenAI、Microsoft、Amazon、Google 和 Huggingface。支持的模型类型包括“聊天”和“文本到图像”，还有更多模型类型正在开发中。跨 AI 提供商的可移植 API，用于聊天和嵌入模型。支持同步和流 API 选项。还支持下拉访问模型特定功能。AI 模型输出到 POJO 的映射。支持所有主要矢量数据库提供商，例如 Azure 矢量搜索、Chroma、Milvus、Neo4j、PostgreSQL/PGVector、PineCone、Qdrant、Redis 和 Weaviate跨 Vector Store 提供商的可移植 API，包括同样可移植的新颖的类似 SQL 的元数据过滤器 API。函数调用AI 模型和向量存储的 Spring Boot 自动配置和启动器。数据工程的 ETL 框架 Spring Cloud Alibaba AI Spring Cloud Alibaba AI （以下简称 SCA AI）基于 Spring AI 0.8.1 版本完成通义系列大模型的接入。
DashScope灵积模型服务建立在 模型即服务（Model-as-a-Service，MaaS）的理念基础之上，围绕AI各领域模型，通过标准化的API提供包括模型推理、模型微调训练在内的多种模型服务。。
SCA AI 目前支持的模型主要有：对话、文生图、文生语音，更多功能特性正在适配中。
快速体验 创建 SCA AI 应用 在 pom.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb99c146f41c735774f308c906e67405/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e68199ba3bcd7954e9a3250a3eab269/" rel="bookmark">
			SQL 基础 | BETWEEN 的常见用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在SQL中，BETWEEN是一个操作符，用于选取介于两个值之间的数据。
它包含这两个边界值。BETWEEN操作符常用于WHERE子句中，以便选取某个范围内的值。
以下是BETWEEN的一些常见用法：
选取介于两个值之间的值： 使用 BETWEEN来选取列中的值，这些值大于或等于一个边界值，同时小于或等于另一个边界值。 SELECT column_name(s)
FROM table_name
WHERE column_name BETWEEN value1 AND value2;
例如，选取products表中价格介于10.00和20.00之间的所有产品：
SELECT *
FROM products
WHERE price BETWEEN 10.00 AND 20.00;
选取日期范围内的记录： BETWEEN也常用于选取特定日期范围内的记录。 SELECT *
FROM orders
WHERE order_date BETWEEN '2024-01-01' AND '2024-01-31';
这将返回1月份的所有订单。
**使用 NOT BETWEEN**： NOT BETWEEN操作符与 BETWEEN相反，它选取不在这个范围内的值。 SELECT *
FROM table_name
WHERE column_name NOT BETWEEN value1 AND value2;
例如，选取employees表中工资不在5000到10000之间的员工：
SELECT *
FROM employees
WHERE salary NOT BETWEEN 5000 AND 10000;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e68199ba3bcd7954e9a3250a3eab269/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f393addcafea4407eea9f2ce70721ff2/" rel="bookmark">
			【LeetCode】LeetCode 547. 省份数量（Java版 什么是并查集）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📝个人主页：哈__
期待您的关注 目录
一、题目描述
二、思路讲解 三、优化find方法
一、题目描述 有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。
省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。
给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。
返回矩阵中 省份 的数量。
二、思路讲解 这是一道有关图的算法题目，题目当中给出了这样的描述：共有n个城市，其中的一些彼此相连，一些没有连接，如果a与b相连并且b与c相连，那么a与c也相连，这不就是连通性嘛。在看看这道题让求的是什么，求的是省份的数量，而一个省份内的地点之间都是连通的，题目让我们返回省份的值。我们的目标就是把每一个地区分到一个省份当中。
在这里我要给大家先讲解一种概念“并查集”。
什么是并查集？在我看来就是将图中的结点进行分类的操作，“并”就是将两个结点分类到一起，“查”就是查找结点到底是属于哪个类的。
这样子的描述不够清晰，我引入这样的一个例子。
我在以前看电视剧的时候，总是会有双方交战的场景，我当时就在想，他们的双方是如何分清谁是谁的，难道不会打错人吗？青青草原的绿草已经被羊羊们吃光了，羊羊们为了争夺资源开始了内战，在某一天喜羊羊带领着“喜门”大军去占领一片新的草原，沸羊羊带领着“沸门”大军也去争夺这片草原。两军在小路交叉口遇见。
这次对决的双方羊数很多，假定羊都是白色的，无法区分，我们强制在两只羊交战之前都要自报家门，如果这两只羊是一个阵营的那么就不交战，那么该如何自报家门呢？乐羊羊问道：“你是哪一个阵营的，你阵营的首领是谁”。哈羊羊说道：“我是喜门的，我的首领是谁我忘了，不过我知道我的上层是谁，让我问问我的上层首领是谁”。于是哈羊羊问了他的上层，他的上层又问了上层，最后通知到了喜羊羊这里，喜羊羊又往下通报确认哈羊羊的身份，最后乐羊羊确认了哈羊羊的身份，并且把哈羊羊当作是自己人。
喜羊羊和沸羊羊大战一场，突然一条情报传入到他们的耳中：“报告门主，美门门主美羊羊被灰太狼抓走了，请求支援！”喜羊羊和沸羊羊一听，立感不妙，现在不是内战的时候，要去救援美羊羊，为了防止内战，于是两羊商量，决定选出一羊作为另一只羊的上层，这样喜门和沸门就完成了合并过程，双方的羊在交战前再次询问上层的时候，都会是喜羊羊或者沸羊羊。
这就是一个简单的“查”和“并”的过程。并查集的关键就是这两个过程。
定义以下的find函数。p是一个数组，用于记录每一只羊的上层是谁。当一只羊的上层就是自己的时候，那这只羊就是门派老大。find函数用一句话来解释，就是查找一只羊的老大是谁。
int find(int x){ while(p[x] != x){ x = p[x]; } return x; } 定义以下的join函数，用于将两个元素归为一类。 也就是把两只羊归为一个阵营。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f393addcafea4407eea9f2ce70721ff2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/500d67f105f3390ba9fd67dd6d7449ac/" rel="bookmark">
			SQL Server使用教程_初学者必备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、编写的目的 很多刚接触 SQL Server 的人，在安装完后都会有一个疑问，我怎么去使用 SQL Server 呢？
这篇文章就是为初学者量身定制的，让你从初学到入门，分分钟掌握 SQL Server。
二、启动SQL server服务的常用方法 1.方法一：使用cmd命令启动 SQL server服务 步骤：
（1）使用Windows搜索功能，输入cmd,如下图所示：
（2）选择命令提示符，鼠标右击，选择“以管理员身份运行”（注意：一定要“以管理员身份运行”，否则启动SQL Server服务会失败！）如下图：
（3）输入以下的代码：
net start mssqlserver 输入代码之后按回车键，会自动启动 SQL Server 服务，等待几秒后提示“服务已经启动成功”如下图所示：
此时显示 SQL Server服务已经启动成功，SQL Server服务启动之后，可以打开 Microsoft SQL Server Management Studio 正常使用了。
第三章节会介绍在哪里打开 SQL Server Management Studio 。
说明： 如果启动时，遇到发生系统错误，拒绝访问的提示，原因可能是因为没有“以管理员身份运行”命令提示符，重新执行（2）和（3）步骤。
2.方法二：使用 SQL Server 配置管理器启动 SQL Server服务 步骤：
（1）使用Windows搜索功能，输入SQL Server，如下图所示：
（2）输入后，会有SQL Server 配置管理器或SQL Server XXX 配置管理器显示（SQL Server 版本不同，显示也不同，只要是配置管理器就行） ，选中SQL Server 配置管理器“以管理员身份运行”，如下图：
（3）点击“以管理员身份运行”后，会打开 SQL Server 配置管理器 窗口，如下图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/500d67f105f3390ba9fd67dd6d7449ac/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/387/">«</a>
	<span class="pagination__item pagination__item--current">388/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/389/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>