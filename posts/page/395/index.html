<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1753e45664c8c3c82504e9f08aa5c922/" rel="bookmark">
			Hadoop介绍：什么是Hadoop？了解Hadoop的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、认识Hadoop框架 Hadoop是一个提供分布式存储和计算的开源软件框架，使用Java语言编写，具有高扩展性、高容错性、无共享和高可用（HA）等特点，非常适合处理海量数据。它基于Google发布的MapReduce论文实现，并且应用了函数式编程的思想。
Hadoop框架主要包括HDFS（Hadoop Distributed File System，Hadoop分布式文件系统）、MapReduce、YARN（Yet Another Resource Negotiator，另一种资源协调者）等模块。其中，HDFS是Hadoop集群中最根本的文件系统，提供了高扩展、高容错、机架感知数据存储等特性，可以非常方便的部署在机器上面。MapReduce是Hadoop的分布式计算框架，它将数据处理分成两个阶段，即Map阶段和Reduce阶段。在Map阶段，数据会被分成多个小的数据块，然后由不同的Map任务并行处理；在Reduce阶段，中间结果会被分组，并且由不同的Reduce任务并行处理，生成最终的输出结果。YARN则负责为Hadoop作业分配和管理资源。
Hadoop的工作原理主要依赖HDFS和MapReduce。HDFS将大文件分割成多个块，并存储在不同的计算节点上，以提高数据的可靠性和容错性。MapReduce则将数据处理分成Map阶段和Reduce阶段，通过并行处理来加快数据处理的速度。
Hadoop的优点包括：
高容错性：数据自动保存多个副本，并通过增加副本的形式提高容错性，当某个副本丢失时，它可以自动恢复。适合处理大数据：能够处理数据规模达到GB、TB、甚至PB级别的数据，以及百万规模以上的文件数量。可构建在廉价机器上：通过多副本机制提高可靠性。 然而，Hadoop也存在一些缺点，例如不适合低延时数据访问，无法高效地对大量小文件进行存储等。
总的来说，Hadoop是一个功能强大的分布式计算和存储框架，可以应用于各种大数据处理场景，如数据分析、数据挖掘、机器学习等。
二、了解Hadoop的核心组件 Hadoop的核心组件主要包括Hadoop Common、HDFS（Hadoop Distributed File System，Hadoop分布式文件系统）、MapReduce以及YARN（Yet Another Resource Negotiator，另一种资源协调者）。
Hadoop的核心组件主要包括Hadoop Common、HDFS（Hadoop Distributed File System，Hadoop分布式文件系统）、MapReduce以及YARN（Yet Another Resource Negotiator，另一种资源协调者）。
1.Hadoop Common： 这是Hadoop项目的基础，提供了许多支持其他Hadoop模块的工具和库。包括文件系统（FileSystem）的抽象定义、RPC（远程过程调用）框架以及序列化机制等。Hadoop Common还包含Hadoop集群配置相关的API和工具，如配置文件管理、日志记录等。 2.HDFS（Hadoop Distributed File System）： HDFS是Hadoop的分布式文件系统，用于存储和管理大规模数据集。它设计用来在廉价硬件上运行，并提供高吞吐量的数据访问。HDFS将数据分成块（block）并分散存储在集群中的多个节点上，同时维护多个副本以提高容错性。它提供了一个与本地文件系统类似的接口，使得用户可以像操作本地文件一样操作HDFS上的文件。 3.MapReduce： MapReduce是Hadoop的分布式计算框架，用于处理大规模数据集。它将数据处理任务划分为Map阶段和Reduce阶段，并在集群中的多个节点上并行执行这些任务。在Map阶段，输入数据被分割成小块并分配给集群中的节点进行并行处理，生成中间结果；在Reduce阶段，这些中间结果被汇总并生成最终输出。MapReduce模型简化了并行编程，使得开发者能够专注于业务逻辑而不是底层细节。 4.YARN（Yet Another Resource Negotiator）： YARN是Hadoop的资源管理系统，负责为应用程序分配和管理集群资源。它将资源管理和作业调度/监控功能分离，使得Hadoop集群能够同时运行多种不同的计算框架（如MapReduce、Spark等）。YARN包括ResourceManager、NodeManager、ApplicationMaster等组件，它们共同协作以有效地利用集群资源并执行用户提交的作业。 这些核心组件共同构成了Hadoop的基础架构，使得Hadoop能够处理大规模数据集并提供高效、可靠的分布式计算和存储服务。同时，Hadoop还提供了丰富的API和工具，使得开发者能够轻松地构建和部署基于Hadoop的应用程序。
三、了解Hadoop生态系统 Hadoop生态系统是一个庞大且复杂的集合，它包含了多个组件，每个组件都有其独特的功能和角色，共同构成了大数据处理和分析的完整框架。
首先，Hadoop分布式文件系统（HDFS）是整个Hadoop体系的基础，负责数据的存储与管理。HDFS将数据分散存储在多个节点上，提供高可靠性和可扩展性，确保数据的持久性和安全性。
其次，MapReduce是一种分布式计算模型，用于处理大规模数据集。它将任务划分为多个小任务，并在集群中的节点上并行执行，最后合并结果。这种并行计算的方式能够显著提高数据处理的速度和效率。
YARN（Yet Another Resource Negotiator）是Hadoop生态系统中的资源管理器，负责管理和调度集群中的资源。它允许多个应用程序同时运行在集群上，并根据需要动态分配资源，提高了资源的利用率和系统的灵活性。
此外，Hadoop生态系统还包括其他重要组件，如Hive、Pig、ZooKeeper、Flume等。Hive是一个数据仓库工具，提供了类似于SQL的查询语言，方便用户进行数据分析。Pig是一个数据流语言和运行环境，用于处理和分析大规模数据集。ZooKeeper是一个分布式协调服务，用于实现分布式应用程序的协调和管理。Flume则是一个分布式、可靠和高可扩展性的日志收集和聚合系统。
这些组件在Hadoop生态系统中相互协作，形成了一个完整的大数据处理和分析平台。用户可以根据具体需求选择适合的组件和工具，构建自己的大数据应用程序。
总的来说，Hadoop生态系统是一个功能强大、灵活多变的大数据处理框架，它能够帮助企业和组织有效地管理和分析大规模数据集，从而发现其中的价值和洞察。随着技术的不断发展，Hadoop生态系统也在不断演进和完善，为用户提供更加高效、可靠和便捷的大数据解决方案。
四、了解Hadoop应用场景 Hadoop是一个开源的分布式计算框架，具有处理海量数据的能力，因此在许多领域都有广泛的应用。以下是一些Hadoop的主要应用场景：
日志分析：Hadoop可以处理和分析大量的日志数据，通过对日志数据进行聚合、过滤和统计，帮助企业了解用户行为、系统性能等信息，从而优化业务和决策。数据仓库和数据湖：Hadoop可以用作数据仓库和数据湖，帮助企业存储和处理包括交易数据、客户数据、市场数据等在内的大规模数据，同时支持数据分析和查询。风险管理：金融机构需要对风险进行实时监控和管理，Hadoop可以帮助金融机构管理和分析大规模的数据，以满足监管要求。社交网络分析：Hadoop可以分析和挖掘社交网络中的关系和模式，帮助企业了解用户的社交行为和兴趣。物联网数据处理：Hadoop可以用于处理和分析物联网设备生成的大量数据，帮助企业监控和管理物联网系统。病人监测与医疗数据处理：Hadoop的分布式计算和存储能力可以轻松应对大规模的病人监测数据，帮助医生及时了解病人的健康状况。同时，Hadoop还可以用于病历数据的归类和关联，为医生提供更全面的患者信息，从而辅助医生做出更准确的诊断和治疗决策。电商领域的数据驱动的营销和销售：Hadoop可以帮助电商平台更好地挖掘数据价值，提高营销和销售效果。 此外，Hadoop还在农业、智慧城市、版权保护等多个领域有着广泛的应用。总的来说，Hadoop适用于需要处理大规模数据、需要高性能计算和需要分布式处理的场景。
需要注意的是，虽然Hadoop具有强大的数据处理能力，但在实际应用中也需要根据具体的业务需求和场景来选择合适的工具和配置，以达到最佳的处理效果。同时，对于大数据的处理和分析，也需要结合其他技术和方法，如机器学习、数据挖掘等，以提供更全面和深入的分析结果。
小结： Hadoop是一个开源的分布式计算框架，专为处理和分析大规模数据集而设计。其核心组件包括Hadoop Common、HDFS（分布式文件系统）、MapReduce（分布式计算模型）以及YARN（资源管理器）。这些组件共同协作，使得Hadoop能够高效、可靠地处理海量数据。
Hadoop的应用场景非常广泛，包括日志分析、数据仓库与数据湖、风险管理、社交网络分析、物联网数据处理以及医疗和电商等多个领域。其强大的分布式计算和存储能力使得企业能够更好地挖掘数据价值，优化业务决策，提高运营效率。
此外，Hadoop生态系统还包含了许多其他工具和组件，如Hive、Pig、ZooKeeper、Flume等，它们提供了更丰富的数据处理和分析功能，进一步增强了Hadoop的灵活性和可扩展性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1753e45664c8c3c82504e9f08aa5c922/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8673d2a8d0aba912742d07097a6e5724/" rel="bookmark">
			‘java‘ 不是内部或外部命令，也不是可运行的程序 或批处理文件_java‘ 不是内部或外部命令,也不是可运行的程序 或批处理文件。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.‘java’ 不是内部或外部命令，也不是可运行的程序 或批处理文件。
出现这种情况一般来说是没有配置环境变量或者是没有配置好
（1）找到安装java的位置 (每个人的不一样 自己看看）
（2）进入控制面板==》系统与安全==》系统==》高级设置–》环境变量
2.开始配置
（1）系统变量中新建
变量名：JAVA_HOME 变量值：C:\Program Files\Java\jdk1.8.0_161（就是一开始安装Java的路径 这个是我的）
变量名：Path 变量值：.;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin（注意前面的.; 一定要）
变量名：CLASSPATH 变量值：.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar（注意前面的.; 一定要）
3.都配置完了之后，最重要的一步，重启cmd，解决了给我小伙伴点个赞
在cmd中 输入指令java 如下图 便是成功了
此时 输入命令javac也可以
最近有些小伙伴还是没能成功的
可能是这步操作有的显示不一样【变量名：Path 变量值：.;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin（注意前面的.; 一定要）】
改成下面这样就可以啦
转载请注明 谢谢
老铁们可以扫码看看，里面有海量头像任意下载
最后 Python崛起并且风靡，因为优点多、应用领域广、被大牛们认可。学习 Python 门槛很低，但它的晋级路线很多，通过它你能进入机器学习、数据挖掘、大数据，CS等更加高级的领域。Python可以做网络应用，可以做科学计算，数据分析，可以做网络爬虫，可以做机器学习、自然语言处理、可以写游戏、可以做桌面应用…Python可以做的很多，你需要学好基础，再选择明确的方向。这里给大家分享一份全套的 Python 学习资料，给那些想学习 Python 的小伙伴们一点帮助！
👉Python所有方向的学习路线👈 Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
👉Python必备开发工具👈 工欲善其事必先利其器。学习Python常用的开发软件都在这里了，给大家节省了很多时间。
👉Python全套学习视频👈 我们在看视频学习的时候，不能光动眼动脑不动手，比较科学的学习方法是在理解之后运用它们，这时候练手项目就很适合了。
👉实战案例👈 学python就与学数学一样，是不能只看书不做题的，直接看步骤和答案会让人误以为自己全都掌握了，但是碰到生题的时候还是会一筹莫展。
因此在学习python的过程中一定要记得多动手写代码，教程只需要看一两遍即可。
👉大厂面试真题👈 我们学习Python必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
需要这份系统化学习资料的朋友，可以戳这里无偿获取
一个人可以走的很快，但一群人才能走的更远！不论你是正从事IT行业的老鸟或是对IT行业感兴趣的新人，都欢迎加入我们的的圈子（技术交流、学习资源、职场吐槽、大厂内推、面试辅导），让我们一起学习成长！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf5d7c28e31cba186cf41100321587b6/" rel="bookmark">
			openWebUI&#43;ollama&amp;windows&#43;不用docker&#43;webLite本地安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		openWebUI &amp; ollama &amp; windows &amp; 不用docker &amp; webLite 本地安装 总结一下安装教程 10核CPU16G内存 两个web框架都可以，先说简单的 ollama-webui-lite(https://github.com/ollama-webui/ollama-webui-lite) 轻量级，只使用nodejs
先装 https://ollama.com/download
新建文件夹 E:\Proj\olloamaModsSav ，cmd进入该目录 ollama run llama3，那么就会直接下载该模型到该目录下，在blobs目录里面会出现这种文件
完了之后就会在cmd里可以进行问答，使用
部署这个webui 需要nodejs安装，（有个坑，c盘根目录需要一个package.json，可以通过命令初始化，如下）装完之后
{ "name": "system32", "version": "1.0.0", "description": "", "main": "index.js", "scripts": { "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" }, "keywords": [], "author": "", "license": "ISC" } 1. 部署WebUI（web-lite）（复制于 超越GPT-3.5!Llama3个人电脑本地部署教程 (ddhigh.com) ） 打开终端，执行以下命令部署WebUI：
git clone https://github.com/ollama-webui/ollama-webui-lite.git cd ollama-webui-lite npm install npm run dev
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf5d7c28e31cba186cf41100321587b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44ff9a8f701d9e388eee270a9d160a6a/" rel="bookmark">
			释放Stable Diffusion 无限可能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在整理大语言模型的系列内容，Stable Diffusion 是我下一篇博客的主题。关注 Stable Diffusion，是因为它是目前最受欢迎和影响力最大的多模态生成模型之一。Stable Diffusion 于 2022 年 8 月发布，主要用于根据文本的描述产生详细图像，当然它也可以应用于其他任务，比如内补绘制、外补绘制，以及在提示词指导下，对现有图形进行风格化或转变。Stable Diffusion 模型版本正在快速迭代，开源生态也在逐步扩展，对行业生产力带来了巨大的变革。如今出现了很多的开源软件，通过调用 Stable Diffusion 来支持各种功能，并提供简洁的用户界面以方便设计师和爱好者使用。然而 Stable Diffusion 的大规模部署不是一件简单的事情，需要考虑多种因素：
亚马逊云科技开发者社区为开发者们提供全球的开发技术资源。这里有技术文档、开发案例、技术专栏、培训视频、活动与竞赛等。帮助中国开发者对接世界最前沿技术，观点，和项目，并将中国优秀开发者或技术推荐给全球云社区。如果你还没有关注/收藏，看到这里请一定不要匆匆划过，点这里让它成为你的技术宝库！
个性化和可扩展性：Stable Diffusion 生态广泛，仅广泛使用的基础模型就有 1.5 ，XL 和 2 三个版本。同时大量的插件和附加模型（如 LoRA ，ControlNet 等）可被附加到基础模型上。还可针对特定工作场景（如人像生成）进行精细化调优。这些模型和插件也都在不断迭代。在大规模部署时，针对不同的工作场景可以使用不同的模型进行模型推理，这对整个系统可扩展性要求很高。 推理速度：Stable Diffusion 的基础模型是在亚马逊云计算服务上使用 256 个 NVIDIA A100 GPU 训练，共花费 15 万个 GPU 小时，成本为 60 万美元。而这只是基础模型，对于调用基础模型并加载个性化数据进行推理的应用场景来说，需要使用加速计算芯片（如 NVIDIA GPU 或亚马逊云科技的 Inferentia 芯片）来提升单任务推理速度，降低用户等待时间，提升用户体验。
弹性伸缩：在多种业务场景中，使用者的请求有较大的不确定性。从平衡成本的角度出发，需要考虑在请求较多时快速增加推理实例数量以应对请求，而在请求较少时降低实例数量以降低成本。
上图是一个常见的大语言模型在容器集群上的部署方式，这种部署方式存在以下问题：
所有请求都是同步的。由于模型推理相对比较耗时，每个请求耗时可达几十秒，甚至几分钟。这不仅要求客户与后端之间的网络绝对稳定，在流量突增且没有限流手段时，甚至会导致系统雪崩。
常见的自动扩容策略是基于 CPU 或 GPU 利用率的指标跟踪，无法直观反应系统负载，且触发时间长，无法应对突增请求。但如果为了避免冷启动而保留大量的空闲容量，则资源在低谷期大量闲置，空置成本高昂。
在弹性伸缩拉起新实例后，还需要加载 Stable Diffusion 运行时和模型才能对外提供服务。Stable Diffusion 运行时的容器镜像普遍在 10 GB 以上，新实例下载镜像和解压耗费的时间过长，导致冷启动时间过长，大大影响使用者的体验。
Stable Diffusion 模型通常使用存放在块存储或文件存储中，每次加载模型时候拉取性能受限，成本也较高。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44ff9a8f701d9e388eee270a9d160a6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e004dc736efa9cfb0da458e483435592/" rel="bookmark">
			LLaMA-Factory参数的解答（命令，单卡，预训练）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面这个写过，但觉得写的不是很好，这次是参考命令运行脚本，讲解各个参数含义。后续尽可能会更新，可以关注一下专栏！！
*这是个人写的参数解读，我并非该领域的人如果那个大佬看到有参数解读不对或者有补充的请请反馈！谢谢（后续该文章可能会持续更新） *
LLaMA-Factory项目的地址：https://github.com/hiyouga/LLaMA-Factory/blob/main/README_zh.md
在LLaMA-Factory项目中，单显卡可以用命令或web页面训练，多显卡只能用用命令的方式，此文章以命令和单显卡为主讲解*（我就一个菜鸡，目前只掌握了单显卡，也是多显卡买不起） *
命令运行的脚本地址：https://github.com/hiyouga/LLaMA-Factory/blob/main/examples/README_zh.md
下面是预训练运行脚本的解读
预训练的简单解释 “预训练”这个训练模式，其实就是先在大量的通用数据上训练模型，让它学到一些基础的知识和处理能力，然后再用特定的较小数据集来进行进一步训练，使模型更适应特定的任务。这个过程有点像人先上小学到大学学习通识教育，然后再通过专业课程或者工作经验来精专某个领域。
使用情况 预训练模式特别适用于以下几种情况：
数据稀缺：对于一些特定任务，可能没有足够的标注数据来从头开始训练一个复杂的模型
这时，可以利用预训练模型作为起点，它已经学习了大量的通用知识，能够更好地处理数据稀缺的情况。提高效率：从预训练模型开始，可以显著减少训练时间和计算资源，因为模型已经有了一个很好的知识基础。提升性能：在许多任务中，预训练模型通常能达到比从零开始训练更好的性能，尤其是在自然语言处理和图像识别领域。 优点 效率高：使用预训练模型可以节省大量的训练时间和计算资源。性能好：预训练模型通常能提供更好的泛化能力，尤其是在数据较少的情况下。灵活性强：预训练模型可以适用于多种不同的任务，只需要针对特定任务进行少量的调整和微调。 缺点 可能存在过拟合问题：如果微调的数据很少，模型可能会过度适应这些数据，导致泛化能力下降。迁移学习的局限性：预训练模型是在特定的数据集上训练的，可能会带有这些数据集的偏见，迁移到完全不同的任务时可能效果不佳。资源消耗：虽然预训练模型可以节省训练时间，但是预训练一个模型本身需要大量的数据和计算资源。 命令解读 CUDA_VISIBLE_DEVICES=0 python …/…/src/train_bash.py CUDA_VISIBLE_DEVICES=0：
这是一个环境变量设置，用于指定哪些GPU设备可被CUDA应用程序（如基于TensorFlow或PyTorch的深度学习训练脚本）使用。
CUDA_VISIBLE_DEVICES=0 表示只有编号为0的GPU设备可被使用。如果有多个GPU，可以设置为 CUDA_VISIBLE_DEVICES=0,1,2 来使用编号为0、1、2的GPU。
这个设置对于在多GPU环境中管理资源非常有用，尤其是当多个用户或多个进程需要独立使用特定GPU时。
stage pt 指定训练阶段为预训练（pre-training）。
do_train 启动训练过程。
model_name_or_path meta-llama/Llama-2-7b-hf 指定模型名称或路径。
到时候根据自己项目部署修改这部分meta-llama/Llama-2-7b-hf
dataset c4_demo 使用的数据集名称。（数据集就自己研究吧，如果不忙也会写先挖个坑）
根据自己需求修改这部分c4_demo的数据集名字
dataset_dir …/…/data 数据集的存储目录。
finetuning_type lora 使用LoRA（Low-Rank Adaptation）作为微调类型。
其他参数 ​ 1.Full：这种方式就是从头到尾完全训练一个模型。想象一下，你有一块白纸，你要在上面画出一幅完整的画作，这就是Full Training。你从零开始，逐步训练模型，直到它能够完成你想要的任务。
​ 2.Freeze：这种方式有点像是在一幅半完成的画上继续作画。在模型中，有些部分（通常是模型的初级部分，如输入层或底层特征提取部分）是已经训练好的，这部分会被“冻结”，不再在训练过程中更新。你只更新模型的其他部分，这样可以节省训练时间和资源。
​ 3.LoRA：这是一种比较新的技术，全称是“Low-Rank Adaptation”。可以理解为一种轻量级的模型调整方式。它主要是在模型的某些核心部分插入小的、低秩的矩阵，通过调整这些小矩阵来实现对整个模型的微调。这种方法不需要对原始模型的大部分参数进行重训练，从而可以在不牺牲太多性能的情况下，快速适应新的任务或数据。
​ 4.QLoRA：这是在LoRA的基础上进一步发展的一种方法。它使用量化技术（也就是用更少的比特来表示每个数字），来进一步减少模型调整过程中需要的计算资源和存储空间。这样做可以使得模型更加高效，尤其是在资源有限的设备上运行时。
lora_target q_proj,v_proj ​ 指定LoRA调整的目标层，这里是q_proj和v_proj。
​ 在使用LoRA（Low-Rank Adaptation，低秩适应）技术进行模型微调时，我们通常会选择模型中的特定层（或部分）进行调整。这些层被称为“目标层”。
​ 具体来说：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e004dc736efa9cfb0da458e483435592/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c2c1cb793bff45c0f5b077a309b297b/" rel="bookmark">
			Flask项目部署到阿里云服务器（全网最清晰简单完整部署），linux命令和脚本文件 nginx安装到服务器等每一步清晰记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、获取免费阿里云服务器
二、远程控制阿里云服务器
三、安装nginx（web服务器）
1. 更新系统软件包：
2. 安装EPEL存储库
3. 安装Nginx
4. 启动Nginx服务并设置开机自启
5. 验证Nginx安装
四、安装python虚拟环境
1.检查系统是否已安装Python3及其pip3:
2. 创建Python虚拟环境
3. 激活虚拟环境：
4. 安装项目所需Python包
5. 退出虚拟环境
五、导入项目文件
1. 确保虚拟环境已激活
2. 配置nginx
3. 确保flask项目中入口文件host='0.0.0.0'
4. 将本地flask项目文件（包括源代码、配置文件、静态资源等）复制到虚拟环境所在的目录下
5. 在虚拟环境中安装Gumicorn
一、获取免费阿里云服务器 没有服务器的话可以在阿里云获取免费服务器
阿里云-计算，为了无法计算的价值
二、远程控制阿里云服务器 本文使用的XShell7
三、安装nginx（web服务器） 在部署flask项目时候，因为flask是一个轻量级的Python Web框架，其本身并不包含一个成熟的Web服务器组件，而是依赖于内置的简易服务器（werkzeug）
1. 更新系统软件包： sudo yum update 2. 安装EPEL存储库 sudo yum install epel-release 3. 安装Nginx sudo yum install nginx 4. 启动Nginx服务并设置开机自启 sudo systemctl start nginx 为了让Nginx在系统启动时自动运行，执行：
sudo systemctl enable nginx 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c2c1cb793bff45c0f5b077a309b297b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/440e74d2ba5a5b4c5d5dd24bf21c7e29/" rel="bookmark">
			linux安装kafka3.5.2、kafka可视化管理工具kafka-ui-lite
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 Apache Kafka是用Scala语言开发的。Scala是一种运行在Java虚拟机（JVM）上的多范式编程语言，它结合了面向对象编程和函数式编程的特性。
由于Scala能够与Java很好地集成，并且能够充分利用Java生态系统的优势，因此被广泛用于构建高性能、可扩展的分布式系统，
其中包括Apache Kafka这样的流式数据平台。 Scala语言的特性使得Kafka在性能和开发效率上都能取得良好的平衡。
Kafka消息中间件是由Apache软件基金会开发和维护的开源流式数据平台。它最初是为LinkedIn开发的，后来成为了一个独立的项目。
Kafka旨在处理大规模的实时数据流，具有高吞吐量、持久性、可扩展性和容错性等特点。
Kafka的核心概念包括：
消息（Message）：Kafka通过主题（Topic）来组织消息。消息可以是任何形式的数据，通常是键值对的形式。主题（Topic）：主题是消息的逻辑分类，每条消息都属于一个主题。生产者将消息发布到特定的主题，而消费者则从感兴趣的主题订阅消息。生产者（Producer）：生产者负责将消息发布到Kafka的主题中。消费者（Consumer）：消费者订阅一个或多个主题，并从中接收消息。代理（Broker）：Kafka集群由多个代理组成，每个代理都是一个独立的Kafka服务器节点，负责存储和处理消息。分区（Partition）：每个主题可以分为一个或多个分区，每个分区是有序的消息序列。分区使得Kafka可以水平扩展，并允许消息并行处理。复制（Replication）：Kafka通过复制机制确保数据的持久性和容错性。每个分区可以配置多个副本，其中一个是领导者（Leader），
其余是追随者（Follower）。领导者负责处理读写请求，而追随者则复制领导者的数据以提供容错性。ZooKeeper：ZooKeeper是Kafka用于集群管理和协调的关键组件。它负责管理Kafka集群的状态、配置信息和领导者选举等任务。 Kafka被广泛应用于实时数据管道、日志聚合、事件驱动架构等场景，其高性能和可靠性使其成为许多企业的首选消息中间件解决方案之一。
二、安装JDK 安装适合自己系统的jdk
yum install -y java-1.8.0-openjdk.x86_64 #这里要注意自己的系统架构 验证jdk是否安装成功，使用如下命令，如果正常输出Java版本信息，则安装成功。
java -version 三、安装Kafka 1. 下载Kafka安装包 下载地址：https://kafka.apache.org/downloads
如果只是使用的话，下载二进制文件就行，不用选择source,在这里我选择下载kafka_2.13-3.5.2.tgz，scala版本为2.13，kafka版本为3.5.2。
2. 上传到服务器，并解压到指定目录。 tar -zxvf kafka_2.13-3.5.2.tgz -C /elitel/app/kafka_2.13-3.5.2 3. 创建目录用于存放数据 mkdir -p /elitel/app/kafka_2.13-3.5.2/data mkdir -p /elitel/app/kafka_2.13-3.5.2/data/kafka mkdir -p /elitel/app/kafka_2.13-3.5.2/data/zk 4. 修改配置文件 修改kafka的配置文件，修改如下：
vim /elitel/app/kafka_2.13-3.5.2/config/server.properties # 代理节点id,不能重复，我们这里不配置集群，就默认为0就行 broker.id=0 # kafka数据目录，日志目录也在这个目录下 log.dirs=/elitel/app/kafka_2.13-3.5.2/data/kafka # 监听主机地址以及端口 listeners=PLAINTEXT://本机ip:9092 # 配置zk地址 zookeeper.connect=127.0.0.1:2181 修改zookeeper的配置文件，修改如下：
vim /elitel/app/kafka_2.13-3.5.2/config/zookeeper.properties # 配置zk数据目录,日志目录也在这个目录下 dataDir=/elitel/app/kafka_2.13-3.5.2/data/zk # 配置zk端口 clientPort=2181 # 一个客户端能够连接到同一个服务器上的最大连接数，根据IP来区分。如果设置为0，表示没有任何限制。设置该值一方面是为了防止DoS攻击。 maxClientCnxns=100 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/440e74d2ba5a5b4c5d5dd24bf21c7e29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25669ff6cbe55096ce0180164410f57f/" rel="bookmark">
			关于使用Java语言编写打地鼠游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用Java语言书写打地鼠游戏 关于游戏的介绍《打地鼠游戏》Java代码的实现PlayMouse.javaStartGame.javaMusicPlay.javaMusicPlayTest.java 游戏所需图片运行效果结言 关于游戏的介绍 打地鼠游戏是一款非常受欢迎的敏捷类游戏，它的基本规则简单易懂，同时又充满了挑战性和趣味性。
在游戏中，玩家通常需要在一个方形区域内，面对多个地洞，这些地洞中会不定时地冒出地鼠。玩家的主要任务就是在地鼠冒出头来的短时间内，用工具（如锤子）迅速而准确地击打它们。成功打中地鼠，玩家就能获得相应的分数。
玩者可以自己设置游戏的难度，地鼠的出现频率和速度都会加快，这就要求玩家不仅要有快速的反应能力，还需要有良好的手眼协调能力和预判能力。
打地鼠游戏不仅锻炼了玩家的反应速度和手眼协调能力，同时也考验了他们的注意力和耐心。因此，无论是孩子还是成年人，都能在这款游戏中找到属于自己的乐趣和挑战。
《打地鼠游戏》Java代码的实现 PlayMouse.java package com.briup.game; import java.awt.BorderLayout; import java.awt.Cursor; import java.awt.GridLayout; import java.awt.Image; import java.awt.Point; import java.awt.Toolkit; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.MouseAdapter; import java.awt.event.MouseEvent; import java.io.File; import java.net.MalformedURLException; import java.util.Random; import javax.swing.ImageIcon; import javax.swing.JButton; import javax.swing.JComboBox; import javax.swing.JFrame; import javax.swing.JLabel; import javax.swing.JPanel; import javax.swing.Timer; /** * 打地鼠 1.布局 2.功能 * */ public class PlayMouse implements ActionListener { // 构建容器 private JFrame jFrame; // 构建面板northJpanel centerJpanel private JPanel northJPanel, centerJPanel; // 构建六个标签，分别用来显示等级，分数，时间，音效 private JLabel leveLabel, timeLabel, timeVaLabel, centerJLabel, cenVaLabel, musicLabel; // 构建下拉框，分别用来显示等级、音效 private JComboBox&lt;String&gt; jComboBox, musicBox; // 构建开始按钮 private JButton jButton; // 构建按钮组，保存十六个按钮 private JButton[] btsButtons; // 构建时间定时器、老鼠定时器 private Timer timer, mouseTimer; // 构建老鼠、老鼠洞图片 private ImageIcon holeiImage, mouseImgIcon; // 记录上一次老鼠出现的位置 private int last; // 设置游戏等级 初级：900毫秒 中级：600毫秒 高级：100毫秒 private int level; // 记录老鼠是否加过分 flase:新老鼠 ，没加过分 true：旧老鼠 private boolean flag; 鼠标的形状 private Cursor cursor, cursor2; // 文件对象 private File file; // 背景音乐对象 private MusicPlay play; // 游戏暂停按钮 private JButton pauseButton; private boolean isPaused; // 构建游戏继续按钮 private JButton resumeButton; // 初始化JFrame public PlayMouse() { // 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25669ff6cbe55096ce0180164410f57f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a62973eb60230cd2b286298190c261c9/" rel="bookmark">
			Atlas Vector Search：借助语义搜索和 AI 针对任何类型的数据构建智能应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Atlas Vector Search已正式上线！
Vector Search（向量搜索）现在支持生产工作负载，开发者可以继续构建由语义搜索和生成式人工智能驱动的智能应用，同时通过 Search Node（搜索节点）优化资源消耗并提高性能。
这一刻终于到来：人工智能已触手可及。曾经，数据科学与机器学习是高深莫测的领域，仅为企业内部的专业人士所掌握；然而如今，这些技术的神秘面纱已被揭开，现已向世界各地的创造者敞开了大门。
但若想深入挖掘这些新兴工具的巨大潜能，开发者需要一个可信赖、可灵活组合、精巧高效的数据平台作为基础。同时，这些新能力的效果好坏，取决于它们能够获取的数据或“基本事实”的质量。
因此，我们为 MongoDB Atlas 开发者数据平台增加了一项新的功能，让开发者的数据释放出无限可能，助力 AI 应用的发展——MongoDB 隆重推出全新的 Vector Search 功能，它能够适应各种形式的数据需求，让我们的合作伙伴享受这些惊人新功能带来的好处。
向量搜索的原理和优势 Vector Search 是一种基于语义或数据含义，而不是基于数据本身来查询数据的功能。这种功能的实现原理是，把任何形式的数据转换成数字向量，再用高级算法进行相互比较。
第一步是获取源数据，可以是文本、音频、图像或视频数据源，并使用“编码模型”将其转换为“向量”或“嵌入”。得益于人工智能的最新进展，这些向量现在能够将低维数据投影到包含更多数据上下文的高维空间，从而更准确地理解数据的含义。
一旦数据转换成数字表示，就可以使用“近似最近邻”算法查找相似的值，这种算法可以让查询非常快速地找到具有相似向量的数据。用户可以使用自然语言进行查询，例如：“推荐一些悲伤的电影”，或“找一些类似……的图片”。这项功能解锁了全新的可能性。
点击观看这两支视频，帮助你更好地了解Vector Search：
向量搜索：数据查询的未来｜语义搜索
3分钟了解MongoDB Atlas向量搜索
MongoDB Atlas平台已原生内置向量搜索！ MongoDB Atlas 已原生内置此功能，开发者无需复制和转换数据、无需学习新的技术栈和语法，也无需管理一整套新的基础设施。借助 MongoDB 的 Atlas Vector Search，开发者可以在一个经过实战考验的出色平台中利用这些强大的新功能，以前所未有的速度构建应用。
有效使用 AI 和 Vector Search 所面临的许多挑战，都源于保证应用数据安全所涉及到的复杂性。这些繁琐的任务会降低开发效率，并让应用的构建、调试和维护变得更加困难。MongoDB 消除了所有这些挑战，同时将 Vector Search 的强大能力整合到平台中，无论面对什么样的工作负载，该平台都能灵活地纵向和横向扩展，轻松应对。
最后，如果没有安全性和可用性的保证，这一切都毫无意义。MongoDB 致力于提供安全的数据管理解决方案，通过冗余和自动故障转移保证高可用性，让应用始终稳定运行。
MongoDB.local 伦敦见面会发布的新功能 在 .Local 伦敦见面会上，我们很高兴地宣布推出专门的Vector Search 聚合阶段，它可以通过 $vectorSearch 调用。这个新的聚合阶段引入了一些新概念，增加了新的能力，使得 Vector Search 比以往任何时候都更容易使用。
借助 $vectorSearch，开发者还可以通过 MQL 语法使用预过滤器（如 g t e 、 gte、 gte、eq 等），以在遍历索引时过滤掉一些文档，从而获得一致的结果和更高性能。任何了解 MongoDB 的开发者都能够轻松使用此过滤功能！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a62973eb60230cd2b286298190c261c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59ea90d40731b1d675dfde634ac9b2c2/" rel="bookmark">
			Spring Boot携手OAuth2.0，轻松实现微信扫码登录！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者介绍：✌️大厂全栈码农|毕设实战开发，专注于大学生项目实战开发、讲解和毕业答疑辅导。
推荐订阅精彩专栏 👇🏻 避免错过下次更新
Springboot项目精选实战案例
更多项目：CSDN主页YAML墨韵
学如逆水行舟，不进则退。学习如赶路，不能慢一步。
WechatAccountConfig 微信开放平台：微信扫码登录功能
官方文档：微信扫码登录功能
1、授权流程说明 微信OAuth2.0授权登录让微信用户使用微信身份安全登录第三方应用或网站，在微信用户授权登录已接入微信OAuth2.0的第三方应用后，第三方可以获取到用户的接口调用凭证（access_token），通过access_token可以进行微信开放平台授权关系接口调用，从而可实现获取微信用户基本开放信息和帮助用户实现基础开放功能等。微信OAuth2.0授权登录目前支持authorization_code模式，适用于拥有server端的应用授权。该模式整体流程为：
① 第三方发起微信授权登录请求，微信用户允许授权第三方应用后，微信会拉起应用或重定向到第三方网站，并且带上授权临时票据code参数；
② 通过code参数加上AppID和AppSecret等，通过API换取access_token；
③ 通过access_token进行接口调用，获取用户基本数据资源或帮助用户实现基本操作。
第一步：请求CODE 第三方使用网站应用授权登录前请注意已获取相应网页授权作用域（scope=snsapi_login），则可以通过在PC端打开以下链接：https://open.weixin.qq.com/connect/qrconnect?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect
返回说明 用户允许授权后，将会重定向到redirect_uri的网址上，并且带上code和state参数
redirect_uri?code=CODE&amp;state=STATE 若用户禁止授权，则重定向后不会带上code参数，仅会带上state参数
redirect_uri?state=STATE 例如：登录一号店网站应用 https://passport.yhd.com/wechat/login.do 打开后，一号店会生成state参数，跳转到 https://open.weixin.qq.com/connect/qrconnect?appid=wxbdc5610cc59c1631&amp;redirect_uri=
https%3A%2F%2Fpassport.yhd.com%2Fwechat%2Fcallback.do&amp;response_type=code&amp;
scope=snsapi_login&amp;state=3d6be0a4035d839573b04816624a415e#wechat_redirect 微信用户使用微信扫描二维码并且确认登录后，PC端会跳转到 https://passport.yhd.com/wechat/callback.do?code=CODE&amp;state=3d6be0a4035d839573b04816624a415e
第二步：通过code获取access_token 通过code获取access_token
https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code
返回说明 正确的返回：
{ "access_token":"ACCESS_TOKEN", "expires_in":7200, "refresh_token":"REFRESH_TOKEN", "openid":"OPENID", "scope":"SCOPE", "unionid": "o6_bmasdasdsad6_2sgVt7hMZOPfL" } 错误返回样例：
{"errcode":40029,"errmsg":"invalid code"} 1、Appsecret 是应用接口使用密钥，泄漏后将可能导致应用数据泄漏、应用的用户数据泄漏等高风险后果；存储在客户端，极有可能被恶意窃取（如反编译获取Appsecret）；
2、access_token 为用户授权第三方应用发起接口调用的凭证（相当于用户登录态），存储在客户端，可能出现恶意获取access_token 后导致的用户数据泄漏、用户微信相关接口功能被恶意发起等行为；
3、refresh_token 为用户授权第三方应用的长效凭证，仅用于刷新access_token，但泄漏后相当于access_token 泄漏，风险同上。
建议将secret、用户数据（如access_token）放在App云端服务器，由云端中转接口调用请求
第三步：通过access_token调用接口 获取access_token后，进行接口调用，有以下前提：
1. access_token有效且未超时； 2. 微信用户已授权给第三方应用帐号相应接口作用域（scope）。 对于接口作用域（scope），能调用的接口有以下：
2、授权流程代码 因为微信开放平台的AppiD和APPSecret和微信公众平台的AppiD和AppSecret都是不同的，因此需要配置一下：
# 开放平台 wechat.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59ea90d40731b1d675dfde634ac9b2c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e266901ebd816fd81090c77edcb1e2e/" rel="bookmark">
			stable diffusion常用的模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Checkpoint模型 1.1、二次元模型 可以搭配负面提示词优化EasyNegative使用
1.1.1 counterfeitV30_v30.safetensors C站地址：https://civitai.com/models/4468/counterfeit-v30
模型下载：下载3.0版本
(masterpiece, best quality),1girl with long white hair sitting in a field of green plants and flowers, her hand under her chin, warm lighting, white dress, blurry foreground Negative prompt: EasyNegativeV2 Steps: 25, ENSD: 31337, Size: 512x1024, Seed: 1293666383, Model: CF5_Counterfeit-V3.0_fix_fix_fix, Sampler: DPM++ 2M Karras, CFG scale: 10, Clip skip: 2, Model hash: db6cd0a62d, Hires upscale: 2, Hires upscaler: R-ESRGAN 4x+ Anime6B, Denoising strength: 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e266901ebd816fd81090c77edcb1e2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cb0e0cff51b99ab95994367b3d8338b/" rel="bookmark">
			vue实现录音并转文字功能，包括PC端web，手机端web
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue实现录音并转文字功能，包括PC端，手机端和企业微信自建应用端 不止vue，不限技术栈，vue2、vue3、react、.net以及原生js均可实现。
原理 浏览器实现录音并转文字最快捷的方法是通过Web Speech API来实现，这是浏览器内置示例的api方法，可以直接调用，无需引入任何依赖包，唯一需要注意的是浏览器的兼容性，具体可查看官方文档
链接: Web Speech API
实现过程 &lt;template&gt; &lt;button @click="toggleSpeechRecognition "&gt;{{ isSpeaking?'开始':'停止' }}录音&lt;/button&gt; &lt;span&gt;{{ prompt }}&lt;/span&gt; &lt;/template&gt; &lt;script setup lang="ts"&gt; import { ref } from 'vue' //测试语音识别 const prompt = ref('') const isSpeaking = ref(false); let recognition: any = null; let finalResult = ''; // 保存最终结果的变量 let interimResult = ''; // 保存中间结果的变量 const toggleSpeechRecognition = () =&gt; { if (!recognition) { recognition = new webkitSpeechRecognition(); recognition.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cb0e0cff51b99ab95994367b3d8338b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbcb5e6f9403c8742c65f6947af706d2/" rel="bookmark">
			【NPC的白话文谈：Android开发{毕设}】：Android Studio 安装中出现的问题（一）：Could not install Gradle distribution（解决下载失败问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：本系列文章仅是为了记录毕设项目开发中出现的问题记录！
博主背景：C/C++ 开发方向 { 已收获中大厂 offer }毕设项目技术栈：Java + Android 开发 { 小丑 } 系列文章：【NPC的白话文谈：Android 开发 { 毕设 } 】
问题概述 为完成毕设开发项目，不可避免的需要安装 Android Studio ！而在初次安装中出现如下问题：
ERROR: Could not install Gradle distribution from 'https://services.gradle.org/distributions/gradle-x.x.x-all.zip'. 问题分析 直白的说，首次启动 Android Studio 或 构建项目，Gradle 是一个必须品！
如上问题：出现的原因就是因为 Gradle 需要下载，但是由于其本身属于外网内容，因此下载会非常慢，甚至由于网络问题，而中断导致无法下载，最终的结果就是如上提示！
（由于是初次接触 Android Studio 并不清除项目构建和编译的逻辑，如上解释就是一个直白的表述）
解决办法 注：此处仅提供博主的解决办法 { 可能是众多解决办法中的一种 }
具体步骤如下：
步骤一：点击报错提示中的下载地址！ 既然在编辑器中下载慢，我们可以直接访问该资源地址，直接下载离线版本！离线版本下载地址：Gradle Distributions步骤二：关闭 Android Studio，找到本机安装 Gradle 的目录！ 一般路径如下：C:\Users\[your user name]\.gradle\wrapper\dists\在以上目录下会有一个此前初次下载失败所创建的 gradle-x.x-bin 或 gradle-x.x-all，双击进入其中！进入后会有一个由数字和字母组成的文件夹，再次进入！进入后，将下载好的离线包（.zip 压缩包 {不用解压} ），粘贴在该目录下！步骤三：启动 Android Studio 到此，就基本是等待即可，编辑器会自动检查你的离线包，然后开始解析和加载/下载其他资源。 补充：2024/4/26 补充点一：离线版本对应问题 注意：在解决办法中的步骤二，我们提及 { 在以上目录下会有一个此前初次下载失败所创建的 gradle-x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbcb5e6f9403c8742c65f6947af706d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a904d36f1220dd38ec59661138641f3/" rel="bookmark">
			android studio ADB无线调试，android与华为鸿蒙系统，鸿蒙系统提示cannot connect to 192.168.1.101:5555: 由于目标计算机积极拒绝，无法连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、普通安卓无线调试
1.手机打开开发者模式，打开无线调试，或者直接手机设置里面搜索无线调试打开
2.保证手机wifi和电脑wifi是同一个网段
3.电脑端输入adb连接命令：adb connect 192.168.0.117:38205，查询命令：adb devices
如何没有配置全局adb，看android studio这里
二、鸿蒙系统无线wifi调试，直接adb connect 手机ip:端口会报错cannot connect to 192.168.0.115:5555: 由于目标计算机积极拒绝，无法连接。 (10061)
1.保证手机wifi和电脑WiFi在同一个网段
2.第一次需要用数据线连接手机，打开usb调试，仅充电模式下允许ADB调试
3.在终端输入adb devices查看usb调试是否连接成功
4.输入adb tcpip 5555，切换到wifi无线连接，端口号可以任意指定
5.输入 adb connect 192.168.0.115:5555，连接手机ip和上面指定的端口，成功后就可以拔掉USB数据线了
6.断开连接
adb disconnect 手机ip //断开指定IP
adb disconnect //断开所有
7.第二次连接的时候无需数据线了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25add73d9514cf5e666e53718a7d5cca/" rel="bookmark">
			人工智能训练师报条件、含金量、适配岗位全方位解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2020年，人工智能训练师正式成为新职业并纳入国家职业分类目录。国标中对人工智能训练师的职业定义为：使用智能训练软件，在人工智能产品实际使用过程中进行数据库管理、算法参数设置、人机交互设计、性能测试跟踪及其他辅助作业的人员。
人工智能训练师是做什么的？
简单来说，他们就是那些用智能训练软件，来管理数据库、设置算法参数、设计人机交互、跟踪性能测试等等，帮助人工智能产品更好地运作的人。
《人工智能训练师》证书介绍
《人工智能训练师》是一项由人力资源和社会保障部正式备案的职业技能认证项目。经备案的用人单位和社会培训评价组织在各自的职业（工种）领域内，遵循国家职业技能标准与备案的评价规范，对从业者进行专业技能等级鉴定。对于成功通过认定的人员，将授予相应的职业技能等级证书，作为其专业技能水平的权威证明。
《人工智能训练师》职业技能等级划分为五级制，自五级至一级，逐级递进。此职业技能等级证书系国家权威认证，全国范围内通用，无需定期审核，一经颁发，终身有效。证书采用一证一码制度，可通过国家官方网站——人力资源社会保障部技能鉴定中心全国联网查询系统进行真伪验证。
《人工智能训练师》证书含金量
01积分入户：
根据《广州市人民政府办公厅关于印发广州市积分制入户管理办法的通知》（穗府办规〔2023〕1号）文件规定，取得人工智能训练师职业技能等级证书有助于积分入户。其他城市入户积分管理办法以当地政策为准
02职称评定：
根据广东省有关规定，取得职业技能等级证书可助评职称
03知识体系：
掌握人工智能知识体系，更好使用人工智能软件与接口
04升职加薪：
持本证书，可有效增加升职加薪概率
05项目招投标：
科技等项目招投标的人员需求
06提升竞争力：
可提升个人职场竞争力
07国家补贴：
根据《广东省职业技能培训补贴（指导）标准目录》（2023年度），人工智能训练师等级证书可按相应等级申领补贴。
《人工智能训练师》证书含金量报考条件
五级
1. 年满16周岁，拟从事本职业或相关职业工作
四级
1. 累计从事本职业或相关职业工作满5年
2. 取得本专业或相关专业的技工院校或中等及以上职业院校、专科及以上普通高等学样毕业证书（含在读应届毕业生）
三级
1. 累计从事本职业或相关职业工作满10年
2. 取得本专业或相关专业的技工院校高级工班及以上毕业证书（含在读应届毕业生）
3. 取得本职业四级职业资格证书，并取得高等职业学校、专科及以上普通高等学校本专业或相关专业毕业证书（含在读应届毕业生）
二级
1. 取得本职业或相关职业三级职业技能等级证书后，累计从事本职业或相关工作满5年
一级
1. 取得本职业或相关职业二级职业技能等级证书后，累计从事本职业或相关工作满5年
《人工智能训练师》适配岗位
1、人工智能训练师五级（初级）
主要负责数据采集、数据标注以及智能系统运维等相关工作。可胜任的职位：数据标注员、数据采集员
2、人工智能训练师四级（中级）
主要负责数据管理、质量控制、处理、标注与审核，以及智能系统的运维等工作。可胜任的职位：
数据标注工程师、数据审核员
3、人工智能训练师三级（高级）
专注于业务流程的设计与分析，致力于人工智能算法的训练与测试，同时涵盖智能系统产品的设计工作。可胜任的职位：
(1)人工智能产品经理、人工智能售前工程师
(2)人工智能项目管理
(3)初级人工智能算法工程师
4、人工智能训练师二级（技师）
主要聚焦于业务流程的策划与剖析，致力于人工智能算法的培育与检验，并深入参与智能系统产品的创新设计工作。可胜任的职位：
(1)人工智能高级产品经理、人工智能方案工程师
(2)中级人工智能算法工程师
5、人工智能训练师一级（高级技师）
专注于将AI技术与各行业及业务场景紧密结合，推动创新实践。在业务架构和流程设计方面具备丰富的经验，致力于人工智能算法的训练、测试和优化工作，以实现算法的产品化应用。同时，还擅长智能产品应用解决方案的设计与实施推广，为客户提供全面的培训和指导服务。可胜任的职位：
(1)人工智能高级产品经理
(2)人工智能架构工程师
(3)首席技术官（CTO）、高级人工智能算法工程师
《人工智能训练师》证书查询真伪
经认定合格人员，按照国家人力资源和社会保障部统一的编码规则和“职业技能等级证书”规范样式要求，由广东泰迪智能科技股份有限公司印制并颁发职业等级证书。
职业技能等级证书信息实行技能人才评价证书全国联网查询：http://zscx.osta.org.cn/
详细了解具体内容可到泰迪智能科技官网咨询了解更多~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39a65234c3c5cce70c2c83e6c5e5e635/" rel="bookmark">
			C&#43;&#43; 之 string类的模拟实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这学习我有三不学
昨天不学，因为昨天是个过去
明天不学，因为明天还是个未知数
今天不学，因为我们要活在当下，我就是玩嘿嘿~
–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀-正文开始-❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–❀–
目录
一、string类的模拟实现
1.成员函数(Member functions)
1.1 构造函数(constructor)
1.2 析构函数(destructor)
1.3 赋值拷贝函数(operator=)
2.迭代器(iterators)
3.容量(Capacity)
4.元素访问(Element access)
5.调节器(Modifiers)
6.字符操作(String operation)
7.成员常量(Member constant)npos实现
8.非成员函数重载(Non-member function overload)
二、完结撒❀
前言：
模拟string类的实现对于我们学习认识string类会有更加深刻的理解，还没学过string类的老铁建议可以先看学习一下我的上一篇博客讲解：C++ 之 string类 详细讲解，再来进行模拟实现。
一、string类的模拟实现 在上篇博客中讲解了string类的常用接口，这篇博客带大家模拟实现一下string类的一些常用接口。
string类查阅文档
我们根据上面文档所规划的接口分类为大家进行部分模拟实现，大家可以先简单看一下上面文档。
1.成员函数(Member functions) 1.1 构造函数(constructor) ● 无参构造函数 string() 实现：
string() //:_str(nullptr) :_str(new char[1])//不能赋空指针，因为直接c_str会出错 , _size(0) , _capacity(0) { _str[0] = '\0'; } ● 有参(字符串)构造函数 string(const char* str = "") 实现：
//string(const char* str = nullptr)错 //string(const char* str = '\0')错 string(const char* str = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39a65234c3c5cce70c2c83e6c5e5e635/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1429978048d317f6b96cb45485dfa70/" rel="bookmark">
			达梦(DM) SQL日期操作及分析函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		达梦DM SQL日期操作及分析函数 日期操作SYSDATEEXTRACT判断一年是否为闰年周的计算确定某月内第一个和最后一个周末某天的日期确定指定年份季度的开始日期和结束日期补充范围内丢失的值按照给定的时间单位查找使用日期的特殊部分比较记录 范围处理分析函数定位连续值的范围查找同一分区中行之间的差定位连续范围的起始点 本文主要讲述DM 数据库中如何实现各种日期相关的运算以及如何利用分析函数 lead() over() 进行范围问题的处理。
日期操作 SYSDATE 使用 trunc() 函数获得某个日期对应的月初时间
SELECT ename,hiredate AS 入职日期,TRUNC (hiredate, 'mm') AS 月初 FROM employee WHERE ROWNUM &lt;= 1; 获取具体时间的时分秒、年月日、月初、周初、年初等
SELECT hiredate, TO_NUMBER (TO_CHAR (hiredate, 'hh24')) 时, TO_NUMBER (TO_CHAR (hiredate, 'mi')) 分, TO_NUMBER (TO_CHAR (hiredate, 'ss')) 秒, TO_NUMBER (TO_CHAR (hiredate, 'dd')) 日, TO_NUMBER (TO_CHAR (hiredate, 'mm')) 月, TO_NUMBER (TO_CHAR (hiredate, 'yyyy')) 年, TO_NUMBER (TO_CHAR (hiredate, 'ddd')) 年内第几天, TRUNC (hiredate, 'dd') 一天之始, TRUNC (hiredate, 'day') 周初, TRUNC (hiredate, 'mm') 月初, LAST_DAY (hiredate) 月末, ADD_MONTHS (TRUNC (hiredate, 'mm'), 1) 下月初, TRUNC (hiredate, 'yy') 年初, TO_CHAR (hiredate, 'day') 周几, TO_CHAR (hiredate, 'month') 月份 FROM (SELECT hiredate FROM employee WHERE ROWNUM &lt;= 1); EXTRACT EXTRACT 函数可以提取时间字段中的年、月、日、时、分、秒，返回的值为 NUMBER 类型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1429978048d317f6b96cb45485dfa70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0882b78f390af47bced3fca005a0c2d/" rel="bookmark">
			基于Hadoop的电商数据分析系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于Hadoop的电商数据分析系统设计与实现 Design and Implementation of E-commerce Data Analysis System based on Hadoop
完整下载链接:基于Hadoop的电商数据分析系统设计与实现
文章目录 基于Hadoop的电商数据分析系统设计与实现摘要第一章 绪论1.1 研究背景1.2 研究目的与意义1.3 现有研究综述 第二章 Hadoop技术介绍2.1 Hadoop概述2.2 Hadoop生态系统2.3 Hadoop数据处理模型 第三章 电商数据分析需求分析3.1 电商数据来源3.2 电商数据分析需求概述3.3 电商数据分析系统功能需求 第四章 电商数据采集与存储4.1 电商数据采集方法4.2 数据预处理与清洗 第五章 电商数据分析与可视化5.1 数据分析算法与模型5.2 数据可视化技术 第六章 系统实现与评估6.1 系统设计与实现6.2 实验与结果分析6.3 系统性能评估 摘要 本文基于Hadoop的电商数据分析系统设计与实现。随着电商行业的快速发展，海量的电商数据成为了企业决策的重要资源。如何高效地处理和分析这些数据成为了一个紧迫的问题。本文从需求分析开始，对电商数据分析系统的功能和性能进行了详细的研究和设计。在系统设计中，采用了Hadoop作为底层的分布式计算框架，结合MapReduce的思想，实现了数据的分布式存储和处理。同时，为了提供更加灵活和高效的数据分析功能，本系统还引入了Hive和Pig等工具，通过对数据进行抽象和高层次的处理，提供了基于SQL的查询和数据分析能力。在系统实现过程中，本文详细介绍了Hadoop的安装和配置，以及Hive和Pig的使用方法。最后，通过对真实的电商数据进行测试，验证了系统设计的有效性和性能优势。实验结果表明，基于Hadoop的电商数据分析系统能够快速、准确地进行多维度的数据分析，为企业决策提供了强有力的支持。本文的研究和实现对于电商行业的数据分析具有重要的参考价值，为广大企业提供了一种新的数据分析解决方案。
第一章 绪论 1.1 研究背景 1.2 研究目的与意义 1.3 现有研究综述 第二章 Hadoop技术介绍 2.1 Hadoop概述 2.2 Hadoop生态系统 2.3 Hadoop数据处理模型 第三章 电商数据分析需求分析 3.1 电商数据来源 3.2 电商数据分析需求概述 3.3 电商数据分析系统功能需求 第四章 电商数据采集与存储 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0882b78f390af47bced3fca005a0c2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ea9f50cdeac165ec2f25de409376efb/" rel="bookmark">
			Spring Boot集成Spring AI实现快速接入openAI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是Spring AI？ Spring AI API 涵盖了广泛的功能。每个主要功能都在其专门的部分中进行了详细介绍。为了提供概述，可以使用以下关键功能：
跨 AI 提供商的可移植 API，用于聊天、文本到图像和嵌入模型。支持同步和流 API 选项。还支持下拉访问模型特定功能。我们支持 OpenAI、Microsoft、Amazon、Google、Huggingface 等公司的 AI 模型。
跨 Vector Store 提供商的可移植 API，包括同样可移植的新颖的类似 SQL 的元数据过滤器 API。支持 8 个矢量数据库。
函数调用。Spring AI 使 AI 模型可以轻松调用 POJO java.util.Function 对象。
AI 模型和向量存储的 Spring Boot 自动配置和启动器。
数据工程的 ETL 框架。这为将数据加载到矢量数据库提供了基础，有助于实现检索增强生成模式，使您能够将数据引入 AI 模型以纳入其响应中。
Chat Completion API 聊天 API 使开发人员能够将人工智能支持的聊天功能集成到他们的应用程序中。它利用预先训练的语言模型，例如 GPT（生成式预训练变压器），以自然语言对用户输入生成类似人类的响应。
API 通常通过向 AI 模型发送提示或部分对话来工作，然后 AI 模型根据其训练数据和对自然语言模式的理解生成对话的完成或延续。然后，完成的响应将返回到应用程序，应用程序可以将其呈现给用户或将其用于进一步处理。
Spring AI Chat Completion API 被设计为一个简单且可移植的接口，用于与各种 AI 模型交互，允许开发人员以最少的代码更改在不同模型之间切换。这种设计符合 Spring 的模块化和可互换性理念。
此外，在输入封装 Prompt 和输出处理 ChatResponse 等配套类的帮助下，聊天完成 API 统一了与 AI 模型的通信。它管理请求准备和响应解析的复杂性，提供直接且简化的 API 交互。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ea9f50cdeac165ec2f25de409376efb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f545c270c04caed71810835811be1a6/" rel="bookmark">
			JDBC查询大数据时怎么防止内存溢出-流式查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.前言2.流式查询介绍3.使用流式查询3.1不开启流式查询的内存占用情况3.2开启流式查询的内存占用情况 4.开启流式查询的注意点 1.前言 在使用 JDBC 查询大数据时，由于 JDBC 默认将整个结果集加载到内存中，当查询结果集过大时，很容易导致 JVM 内存溢出的问题。
解决办法通常是使用分页查询，但是分页查询越往后要遍历的行数越多，效率越低。除非能够添加索引条件，但这又提高了业务逻辑的复杂度。
2.流式查询介绍 JDBC的流式查询就是在使用ResultSet对象获取查询结果集的时候，不是把结果集一次性全部加载到内存中，而是分批次读取数据。
在jdbc客户端和mysql服务端建立tcp连接后，mysql以包的形式返回数据。在查询大数据的情况下，需要分多个包发送给客户端，而流式查询就是一次读取一个包的数据（通常情况下如此），所以查询的数据大小与MySQL一次发送的包大小息息相关。可以通过MySQL的配置max_allowed_packet设置包大小上限。
3.使用流式查询 java需要引入jdbc的依赖。
3.1不开启流式查询的内存占用情况 测试代码如下：
private static void testFetch() throws SQLException { Connection c = DriverManager.getConnection("jdbc:mysql://localhost:3306/db1", "zhuzi", "123456"); Statement s = c.createStatement(); //查询1000w条数据 ResultSet rs = s.executeQuery("select * from gg limit 10000000"); while (rs.next()) { //执行处理数据的逻辑 } //休眠100s，方便查看内存情况 try { Thread.sleep(100000); } catch (InterruptedException e) { e.printStackTrace(); } rs.close(); s.close(); c.close(); } 使用jconsole工具查看内存使用情况，如下图所示。
可以看到，大约占用了1.5GB的内存，并且内存曲线很平稳，这说明数据是一次性全部加载到内存中的。
3.2开启流式查询的内存占用情况 测试代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f545c270c04caed71810835811be1a6/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/394/">«</a>
	<span class="pagination__item pagination__item--current">395/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/396/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>