<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3681f70476ba0490d9fd07f8a5e497dc/" rel="bookmark">
			计算机基础学习有多重要？学哪些？如何学？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机基础是我们计算机生涯的开始，而对大学生来说，基础是一方面，更重要的是应对面试。这样说吧，校招：计算机基础占90%，专业知识占10%，社招：计算机基础占20%，专业知识占80%。而且校招是进入大厂最好的机会，他不需要你专业知识，只需要你把计算机基础学好。对于程序员来说，计算机基础就相当于打地基，而专业知识相当于装修，地基不稳，后面怎么修都是没用的。
先罗列一下我心目中的TOP5：
1、计算机组成原理；
2、计算机操作系统；
3、计算机编译原理；
4、数据结构与算法；
5、计算机网络。
如果你想成为一个基础扎实的CSer，其他课就算不在TOP5里面你还得学，比如数电/模电；编译原理、数据库等。
话不多说，直接上干货。
计算机编译原理 编译原理的学习和实践通常基于对计算机编译过程、计算机基本工作原理，甚至一定的数学知识有一定积累，这些知识分别分布并用在了编译原理的不同阶段，没有这些基本知识的积累，很快就会在某个阶段由于功底不够而无法再继续后面的学习。
推荐课程：《编译原理（哈工大）》，陈鄞老师的PPT做的非常认真，讲的也很通俗易懂，思路清晰，这个是我目前为止觉得讲的最直观简洁的了，全程没有一句废话，认真听会有很大的收获。
编程语言 零基础入门推荐中国大学MOOC的（浙江大学）翁凯老师的《程序设计与C语言入门、进阶》，跟着视频走，视频写一遍代码你写三遍，第二天早中晚复习一遍，学完之后找相应的习题，比如谭浩强的课后习题，自己做，做不出来找答案。
计算机操作系统 无论你学习什么编程语言，都避免不了和操作系统打交道。如果不懂操作系统，你在未来学习编程语言的高级特效，涉及到线程、进程调度、内存分配时都会一头雾水。所以只有学会了操作系统，我们才能够更好的学习其他语言和基础。
推荐课程：1：《2020南京大学：操作系统设级与实现-蒋岩炎》，南大的课，质量真的硬，蒋岩炎老师讲的真的好，每一节视频都比较长，一次当完贼爽，老师把晦涩的东西讲的非常通俗易懂，豁然开朗。:2：操作系统（哈工大李治军老师），整体看了一遍，个人觉得这是很不错的操作系统课程了。这门课的前几讲设及OS启动，之后的内容，如多进程、信号量、内存管理等都讲的很好。
计算机网络 计算机网络的相关知识在工作时使用的频率还是挺多的，毕竟所谓的考工程师总是在处理API相关的业务。
推荐课程：1：《计算机网络微课堂》《阿婆主湖科大学教书匠》，他讲的计算机网络十分通俗易懂，重点的地方讲的十分细致，并且还有一些配套实验。2：韩立刚老师《计算机网络》，韩立刚老师所讲的计算机网络视频内容比较多，但是讲解的通俗易懂，并且老师讲课的经验也十分的丰富。
计算机组成原理 计算机组成原理这门课，很好的向我们阐述了计算机是如何工作的，比如女生咨询你电脑问题的时候，答案就藏在这门课程里面。
推荐书籍：《深入理解计算机系统》，这本书不仅仅包含了计算机硬件的相关知识，同时还包含了包括操作系统、计算机网络等相关知识。
推荐课程：《计算机组成原理-哈工大刘宏伟》。刘宏伟老师主讲，他的课不仅适合考研人，也非常适合初学者，初学者也听得懂。建议1.5倍速使用。
数据结构与算法 相信无论是已经毕业的同学，还是正在学校学习的同学，都或多或少的被数据结构与算法这门课给折磨过。数据结构与算法这门课开篇就讲了一个非常重要的概念，程序=数据结构+算法。对于初学者可能还不能完全的理解这句话，不过对于已经工作两三年的同学，相信对这句话是深信不疑的。
推荐课程：1、《郝斌：数据结构入门》，我个人觉得他讲的非常好，郝斌老师的思路是以初学者的思路来思考的，非常适合小白。2、《数据结构》浙江大学陈越姥姥的课，简单易懂。插树和列表说的多，但是对于图太少，后面概念解释多，程序少，对于新手不友好。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/352a6a61fa731a98508a25dbba1271cd/" rel="bookmark">
			如何下载和安装SQLynx数据库管理工具? （MySQL作为测试数据库）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 官网下载
2. 安装软件
3. 启动SQLynx软件
4. 开始使用
5. 执行第一条SQL语句
6. 总结
SQLynx是一款先进的Web SQL集成开发环境（IDE），专为数据库管理、查询和数据分析设计。作为一个基于浏览器的工具（同时也支持桌面版），SQLynx提供了高度便捷的跨平台访问和协作功能，使得用户能够随时随地连接和管理数据库。
1. 官网下载 a. 首先进入官网www.sqlynx.com的页面，如下图所示:
b. 如果已经有用户信息，直接登录，如里没有，需要先注册用户，在右上角有相关的操作。
c. 点击软件下载，选择SQLynx的Tab，如图所示：
然后选择相应的版本下载，此处我用的是mac的系统（Windows基本也一样，此处选择的是个人版，无JDK进行下载）。
2. 安装软件 a. 针对Mac的系统参照dmg的软件执行就可以了（安全上需要选择通过）
b. 针对Windows的系统解压后，找到SQLynx的图标直接执行就可以了，无需安装。（需要注意操作系统是否已经在JDK1.8版本或以上版本，如果有就使用不含JDK的版本，如果没有需要下载含JDK的版本）。
3. 启动SQLynx软件 SQLynx的个人版默认是支持桌面客户端和Web同时访问的。
a. 启动客户端界面：首次登录用户名为maicong，密码可以自行设定，会自动创建第一个用户（个人版本只有一个用户）。
b. 也可以启动浏览器的页面：默认端口为18888，后续可以根据需要自行修改：
4. 开始使用 正常访问后，数据源列表是空的，如下是已经添加了一些数据源的页面，用户可以根据自己的需要添加数据源并进行数据的操作。
5. 执行第一条SQL语句 以MySQL为例，在数据库的名称上右键后新建查询就可以打开相应的查询页面。
如下执行SQL语句：
select * from users 执行结果如图下所示，后续可以正常做数据库的管理和开发工作。
6. 总结 此文主要是介绍SQLynx从官网访问、下载到安装使用的基础过程。在使用的过程中如果遇到相应的问题，可以在SQLynx的官网上找到相应的地方咨询。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/349e3dcef38ac491e3b203e7c383fb7d/" rel="bookmark">
			【一步一步了解Java系列】：认识异常类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看到这句话的时候证明：此刻你我都在努力
加油陌生人
个人主页：Gu Gu Study
专栏：一步一步了解Java
喜欢的一句话： 常常会回顾努力的自己，所以要为自己的努力留下足迹
喜欢的话可以点个赞谢谢了。
作者：小闭
异常类的概念及其层次结构 Java中存在异常类，那么何为异常类呢？那么我们必须先了解一下它的概念：Java异常处理是Java语言中非常重要的一部分，它允许程序在遇到错误时能够优雅地处理问题而不是直接崩溃。Java异常类主要分为两大类：检查型异常（Checked Exceptions）和非检查型异常（Unchecked Exceptions）。
检查型异常/编译时异常（Checked Exceptions）： 这些异常通常是由于编程错误导致的，比如FileNotFoundException或SQLException。它们必须在方法签名中声明抛出，或者在方法内部被处理（通常是通过try-catch块）。在运行前编译器就已经报出警告了： 非检查型异常/运行时异常（Unchecked Exceptions）： 这些异常通常是由于运行时错误导致的，比如NullPointerException或ArithmeticException。它们不需要在方法签名中声明，也不强制要求必须被捕获处理。如图在运行前编译器是不会提示错误的： Java中的异常就像我们生活中人生病一样，我们的程序也会生病，我们可以把计算机的病就叫做“异常”。
那么下面就给大家解析一下其层次结构：
Java异常类的层次结构从__java.lang__包中的__Throwable__类开始，它有两个主要的子类：Exception__和__Error。
Throwable： Java异常类的根类。有两个重要的子类：Exception和Error。 Exception： 表示程序本身可以处理的异常情况。进一步分为IOException、SQLException等。 RuntimeException： Exception的一个子类，表示在Java程序运行时发生的异常。包括NullPointerException、IndexOutOfBoundsException等。 Error： 表示JVM无法处理的错误，比如OutOfMemoryError或StackOverflowError。通常不需要程序去捕获这些错误 有关处理异常的关键词 在Java中处理异常我们有这么几个常用的关键词 ：throw、try、catch、finally、throws。
** throw 抛出异常 ** 如下是一个简单的异常抛出，我们在一个方法中要执行一条语句时，如果其可能会发生异常，如：null，分母为0，数组访问越界，我们都可以自己抛出异常，如下为一个空指针异常
package demo1; public class Test { public static void testExceptinon(int[] arr){ if(arr==null){ throw new ArithmeticException(); } } public static void main(String[] args) { int[] arr=null; testExceptinon(arr); } } 所谓抛出异常其实就是抛出一个Exception或Exception的子类。
注意事项：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/349e3dcef38ac491e3b203e7c383fb7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c615af6feb6748d5d6a450b1468c8954/" rel="bookmark">
			Java 接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇学习接口，并区分接口与抽象类两者之间的异同点。上篇已经讲解了抽象类，有需要的小伙伴可以点链接康康
https://blog.csdn.net/m0_73107796/article/details/139863674
目录
1、 什么是接口
2、 接口定义格式
3、 接口的使用
4、接口特性
5、抽象类与接口的区别 1、 什么是接口 我们知道，Java不支持多重继承（一个类不支持继承多个类），但是，通过接口实现了比多重继承更强的功能。Java通过接口便处于不同层次的类甚至互不相关的类可以具有相同的行为·。
2、 接口定义格式 语法如下：
public interface 接口名称 {
// 抽象方法
public abstract void method1(); // public abstract 是固定搭配，可以不写
public void method2();
abstract void method3();
void method4();
// 注意：在接口中上述写法都是抽象方法，更推荐方式4，代码更简洁
}
小提示:
1. 创建接口时, 接口的命名一般以大写字母 I 开头.
2. 接口的命名一般使用 "形容词" 词性的单词.
3. 阿里编码规范中约定, 接口中的方法和属性不要加任何修饰符号, 保持代码的简洁性.
3、 接口的使用 接口不能直接使用，必须要一个“实现类”来实现“该接口”,并实现接口中的所有抽象方法。
public class 类名称 implements 接口名称 {
成员变量；
抽象方法；
}
注意：子类和父类之间是extends 继承关系，类与接口之间是 implements 实现关系。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c615af6feb6748d5d6a450b1468c8954/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0461d216200ea7a77636f653103c76f/" rel="bookmark">
			为什么在2024年应该使用AVIF而不是JPEG、WebP、PNG和GIF
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AVIF是一种新兴的文件格式，本文撰写时它已经在Microsoft Edge中获得了支持，从而实现了显著的浏览器支持。
我们已经不再处于技术的黑暗时代，大多数大型网站平台通常支持最新版本的浏览器及其一年前的版本。你可以开始使用AVIF，并在2024年底之前使用WebP作为回退格式（在此之前回退格式是必要的）。
这意味着什么？ 你现在可以主要使用AVIF作为栅格图像的默认格式，因为它基本上取代了许多常见的JPEG用法。
为什么选择AVIF而不是JPEG和WebP？ 压缩效率：比JPEG和WebP等格式具有更高的压缩比，同时保留高图像质量。
色深：支持8位、10位、12位和16位等广泛的色深。
广色域和HDR支持：AVIF支持广泛的颜色范围和高动态范围（HDR），使图像更生动逼真，非常适合需要精确颜色和细节的应用，如专业摄影和媒体内容。
有损和无损压缩：AVIF的无损压缩效果远优于压缩的位图和PNG。
透明通道支持：类似于PNG，可以存储半透明图像，但压缩效果更好。
基于AV1：AV1是一种由开放媒体联盟开发的免版税编解码器，基于Google的VP9编码。这意味着它将广泛采用，并且相比其他新兴图像格式更少争议。
主流浏览器和广泛平台支持。
减少带宽和更快的加载时间：更小的文件意味着用户加载速度更快。
缺点 计算密集型压缩：通常，AVIF压缩比旧的图像格式如JPEG更具计算密集性，但它通常实现了更高效的压缩效果。
有多小？ 开放媒体联盟非常兴奋地声称：
“图像可以比相似视觉质量的JPEG小多达十倍。”
此外，
“AVIF可以实现40%到90%的压缩。”
我们已经使用AVIF大约4年了，根据经验，压缩的大多数图像大约是等效质量JPEG输出图像大小的60%。这仍然令人惊叹。
因此，AVIF涵盖了除以下情况之外的大多数图像场景：
矢量图：SVG和SVG图像很好地涵盖了这一点。
矢量动画：同样，SVG在这里表现也不错，尽管在渲染质量方面还有提升空间。
后端编码/解码 如果在你的首选后端语言中找不到支持AVIF的软件库，可以封装libavif，官方的AOMedia编码器/解码器。或者，如果你有勇气，可以将其转换为本地支持。
GitHub - AOMediaCodec/libavif: libavif - 用于编码和解码.avif文件的库
以下是我在GitHub上发现的一些库：
Node.js: https://github.com/lovell/sharp
PHP: https://github.com/flyimg/flyimg
Go: https://github.com/webp-sh/webp_server_go
何时不使用AVIF 这真的取决于图像的动态和复杂性，但通常：
无损矢量/非真实动画：这取决于具体情况（唉）。
在某些“罕见”情况下，当比较质量/压缩比时，WebP甚至JPEG可能胜过AVIF。
作为经验法则，AVIF在优化写实图像方面通常表现突出。个人认为它在其他图像如图表和矢量艺术中也相当占优势。
支持旧版浏览器 想象一下，有人刚从长假回来，还没有更新他们的浏览器。
如果你想在本文撰写时开始使用AVIF，请使用srcset或 &lt;picture&gt;&lt;source&gt;，以AVIF为主，回退到旧的图像格式如WebP或JPEG。
如果从本文写作时起Edge已经更新了3个或更多版本，你就可以只使用src。
动画 动画AVIF示例:https://colinbendell.github.io/webperf/animated-gif-decode/avif.html
虽然这略微超出了本文的范围，但正如所提到的，AVIF可以像APNG一样用于动画。
这两种格式都远优于GIF，你应该考虑它们作为替代品，因为它们有完整的浏览器支持，而GIF作为一种旧的动画图像格式，其压缩效果较差。
话虽如此，在电子邮件支持方面要谨慎，因为那也是一个旧的、糟糕的系统，可能不会一致地支持这些新格式，请务必检查。
结论 尽量避免比较图像格式和压缩结果的优劣。事实上，所有的无损编解码器都有代价；这是一个权衡问题。
你可能不喜欢特定图像伪影的样式，但如果这意味着某人在火车上或在延迟较差的情况下可以更快地加载你的网站，作为开发者你也需要做出妥协。
最终目标是在合理范围内向用户提供尽可能小的负载，无论哪种格式被证明更优化。
在我看来，新图像格式只是构建更好产品、提高用户体验的工具，而不是竞争偏好的问题。
最后：
vue2与vue3技巧合集
VueUse源码解读
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0dcd13f5ac5a2c6848f2c80943d9a21/" rel="bookmark">
			查询Kafka生产者是否连接到Kafka服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人名片
🎓作者简介：java领域优质创作者
🌐个人主页：码农阿豪
📞工作室：新空间代码工作室（提供各种软件服务）
💌个人邮箱：[2435024119@qq.com]
📱个人微信：15279484656
🌐个人导航网站：www.forff.top
💡座右铭：总有人要赢。为什么不能是我呢？
专栏导航： 码农阿豪系列专栏导航
面试专栏：收集了java相关高频面试题，面试实战总结🍻🎉🖥️
Spring5系列专栏：整理了Spring5重要知识点与实战演练，有案例可直接使用🚀🔧💻
Redis专栏：Redis从零到一学习分享，经验总结，案例实战💐📝💡
全栈系列专栏：海纳百川有容乃大，可能你想要的东西里面都有🤸🌱🚀
要查询Kafka生产者是否连接到Kafka服务，可以通过以下几种方法：
目录 1. 查看生产者日志2. 使用Kafka工具查看生产者活动使用kafka-consumer-groups工具使用kafka-topics工具 3. 使用JMX监控4. 检查Kafka Broker的连接数5. 编写生产者代码进行连接测试6. 使用Kafka管理工具 1. 查看生产者日志 生产者通常会记录它的活动日志，包括连接尝试和连接成功或失败的消息。在生产者应用的日志中搜索连接相关的信息。
2. 使用Kafka工具查看生产者活动 使用Kafka命令行工具或管理工具查看主题的活动情况：
使用kafka-consumer-groups工具 如果生产者正在生产消息，消费者组也会有活动。你可以查看消费者组的偏移量变化。
kafka-consumer-groups.sh --bootstrap-server &lt;kafka-broker&gt;:&lt;port&gt; --describe --group &lt;consumer-group&gt; 使用kafka-topics工具 查看主题的描述信息，检查分区的消息偏移量是否在增加。
kafka-topics.sh --bootstrap-server &lt;kafka-broker&gt;:&lt;port&gt; --describe --topic &lt;your-topic&gt; 3. 使用JMX监控 Kafka生产者和Broker都支持通过JMX（Java Management Extensions）暴露各种监控指标。你可以通过以下步骤查看连接情况：
启动Kafka时启用JMX监控：
export KAFKA_JMX_OPTS="-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=9999 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false" 使用JMX工具（如JConsole或VisualVM）连接到JMX端口，查看生产者的连接指标。
4. 检查Kafka Broker的连接数 通过Kafka Broker的JMX监控，可以查看当前活跃的连接数。检查是否有来自生产者的连接。
5. 编写生产者代码进行连接测试 编写一个简单的生产者程序，发送测试消息并捕获异常以验证连接情况。
import org.apache.kafka.clients.producer.KafkaProducer; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0dcd13f5ac5a2c6848f2c80943d9a21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16ad255de0e657c98d243ccf7d27a38f/" rel="bookmark">
			20240622 每日AI必读资讯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🤖力压GPT-4o！新王Claude 3.5 Sonnet来了，直接免费可用
- 新模型在推理、知识和编码能力评估方面超越了以前的版本和竞争对手GPT 4o模型，同时其运行速度是Claude 3 Opus的两倍。
- 该模型可在http://Claude.ai和Claude iOS应用上免费使用。
- Claude 3.5 Sonnet的定价为每百万输入tokens 3美元和每百万输出tokens 15美元，具有200K tokens的上下文窗口。其性价比高，适合中高端应用场景。
- Claude 3.5 Sonnet引入的一种新特性：Artifacts，让用户更方便地与AI生成的内容互动。
🔗 https://blink.csdn.net/details/1737574
📂Generative AI Handbook：一本人工智能学习手册
- 手册分为九个主要部分，包含了从基础知识到最新技术的全面内容，通过系统化的学习路径，帮助读者理解和应用AI技术。
- 无论是想要学习如何使用现有的AI工具，还是希望深入研究AI的原理，能提供有价值的指导。
🔗传送门：https://genai-handbook.github.io
🔍 知网宣布推出CNKI AI学术研究助手4.0
- AI学术研究助手4.0版本结合AI大模型技术和高质量数据，提升文献检索、研读和学术创作效率。
- 新增功能包括可控生成、文献扩展、学者检索、全文翻译和学术拓展服务，满足用户个性化需求。
- 突出升级是问答式增强检索和学者检索服务，提供更精确的答案和详细学者信息。
🔗 AI学术研究助手-中国知网
🛠️Florence-2：微软全新开源视觉模型 - 能够执行超过10种不同的视觉任务，包括图像字幕生成、对象检测、图像区域关联和分割等。
- 不仅能描述图片的内容，还能识别图片中的物体，并指出这些物体的位置。
- Florence-2 系列包括 Florence-2-base 和 Florence-2-large，参数分别为 0.23 亿和 0.77 亿。
- 可以运行在各种资源受限的移动端设备上。
- Florence-2 采用统一的、基于提示的表示方式来处理各种视觉任务。
- 通过简单的文本提示，模型可以生成所需的文本形式结果，无论是图片描述、目标检测、视觉定位还是图像分割。
🔗 微软 Azure AI 团队新作 | Florence-2: 解锁视觉新境界，万能感知引领未来！-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a580f68bf6d946aac0d5ebbe3f609fa/" rel="bookmark">
			探索AI前沿：本地部署GPT-4o，打造专属智能助手！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、获取API_key
2、开始调用
3、openai连接异常
4、解决方法：
5、调用GPT-4o
1、获取API_key 这里就不多赘述了，大家可以参考下面这篇博客
怎么获取OpenAI的api-key【人工智能】https://blog.csdn.net/qq_51625007/article/details/137632747
2、开始调用 有了第一步的API_key，就可以直接调用GPT-4o，不说废话，直接上代码
import base64 from PIL import Image import os import io from openai import OpenAI from dotenv import load_dotenv load_dotenv('.env') # 这一步很关键 import os os.environ["http_proxy"] = "http://localhost:51121" os.environ["https_proxy"] = "http://localhost:51121" client = OpenAI(api_key='sk-xxxxxxxxxx') def encode_image(image): buffered = io.BytesIO() image.save(buffered, format=image.format) return base64.b64encode(buffered.getvalue()).decode('utf-8') def extract_image(query, image_file=None): messages = [{"role": "user", "content": [{"type": "text", "text": query}]}] if image_file is not None: image = Image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a580f68bf6d946aac0d5ebbe3f609fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a26c48c7ecc9ac573f3388c312d519c5/" rel="bookmark">
			设计模式3-分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设计模式-分类 模式的分类从目的来分创建型模式（Creational Patterns）结构型模式（Structural Patterns） 从范围来分类模式（Class Patterns）对象模式（Object Patterns）类模式和对象模式的区别 从封装变化角度对模式分类组件协作单一职责对象创建对象性能接口隔离状态变化数据结构行为变化领域问题 模式的分类 从目的来分 设计模式（Design Patterns）是一种解决特定问题的通用解决方案，通常分为以下三类：
创建型模式（Creational Patterns）：
主要关注对象的创建过程，旨在将对象的创建过程与使用过程分离，以提高代码的灵活性和可维护性。 结构型模式（Structural Patterns）：
主要关注类和对象的组合，旨在通过不同的方式将类或对象组合在一起，以形成更大的结构，从而解决设计中的一些问题。 行为型模式（Behavioral Patterns）：
主要关注类和对象之间的交互，旨在通过合理安排类和对象之间的职责和通信方式，来提高系统的灵活性和可扩展性。 创建型模式（Creational Patterns） 工厂方法模式（Factory Method）：
定义一个接口用于创建对象，但由子类决定实例化哪一个类。使得一个类的实例化延迟到其子类。 class Product { public: virtual void use() = 0; }; class ConcreteProductA : public Product { public: void use() override { // Implementation for Product A } }; class ConcreteProductB : public Product { public: void use() override { // Implementation for Product B } }; class Creator { public: virtual Product* createProduct() = 0; }; class ConcreteCreatorA : public Creator { public: Product* createProduct() override { return new ConcreteProductA(); } }; class ConcreteCreatorB : public Creator { public: Product* createProduct() override { return new ConcreteProductB(); } }; 抽象工厂模式（Abstract Factory）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a26c48c7ecc9ac573f3388c312d519c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0cb79bd48c63452885106ce17433447/" rel="bookmark">
			蓝桥杯 经典算法题 合并排序数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目：
题解：
leetcode上也有这道题一模一样。和归并排序的小过程基本一模一样，只不过因为题目要求只能将arr2中元素合并到arr1中，一种可行的方法是按元素从大到小，顺序从每个序列尾部开始操作，第一填的位置是arr1的尾部，第一个判断的是arr1中有元素的尾部和arr2中有元素的尾部，和归并一模一样的过程构造出一个单调的数组。
#include &lt;bits/stdc++.h&gt; using namespace std; int main(){ int a,b; cin&gt;&gt;a&gt;&gt;b; vector&lt;int&gt;arr1(a),arr2(a-b); for(int i=0;i&lt;b;i++)cin&gt;&gt;arr1[i]; for(int i=0;i&lt;a-b;i++)cin&gt;&gt;arr2[i]; int x=b-1,y=a-b-1,k=a-1; while(x&gt;=0||y&gt;=0){ if(y&lt;0||(x&gt;=0&amp;&amp;arr1[x]&gt;=arr2[y])){ arr1[k--]=arr1[x--]; }else { arr1[k--]=arr2[y--]; } } for(auto x:arr1){ cout&lt;&lt;x&lt;&lt;" "; } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af3774318e758808f1933584c7016a40/" rel="bookmark">
			【面试干货】 Java 中的 HashSet 底层实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【面试干货】 Java 中的 HashSet 底层实现 1、HashSet 的底层实现2、 HashSet 的特点3、 总结 💖The Begin💖点点关注，收藏不迷路💖 HashSet 是 Java 集合框架中的一个重要成员，它提供了不存储重复元素的集合。但是，你有没有好奇过 HashSet 是如何实现这一特性的呢？本文将带你深入了解 HashSet 的底层实现机制。
1、HashSet 的底层实现 HashSet 的实现是基于 HashMap 的。当我们创建一个 HashSet 对象时，实际上是在背后初始化了一个 HashMap 对象。
但是，HashSet 和 HashMap 的使用方式并不完全相同，这是因为 HashSet 隐藏了 HashMap 的某些复杂性，只暴露了简单的集合操作接口。
HashSet 不允许值重复，这是如何实现的呢？ 关键在于 HashSet 是如何存储其元素的。在 HashSet 中，元素是作为 HashMap 的 key 存储的，而 HashMap 的 value 则是一个固定的对象（在 Java 8 及以后的版本中，这个固定的对象通常是一个名为 PRESENT 的静态常量对象）。
示例：
package com.mypackage; import java.util.HashMap; import java.util.Map; public class MyHashSet&lt;E&gt; { // 使用 HashMap 存储元素，这里将 key 视为 HashSet 中的元素 private Map&lt;E, Object&gt; map; // 静态常量，模拟 HashSet 中的 PRESENT private static final Object PRESENT = new Object(); // 构造函数，初始化 HashMap public MyHashSet() { map = new HashMap&lt;&gt;(); } // 添加元素到 HashSet 中 public boolean add(E e) { // 如果 put 方法返回 null，表示该 key 尚未在 HashMap 中存在 return map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af3774318e758808f1933584c7016a40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ce2886a20a57231b3a7c76727da0866/" rel="bookmark">
			Unity踩坑记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.
如果同时在父物体和子物体上挂载BoxCollider，那么当使用：
private void OnTriggerEnter2D(Collider2D collision) { if (collision.CompareTag("CardGroup")) { _intersectCardGroups.Add(collision.GetComponent&lt;CardGroup&gt;()); } } 来判断CardGroup相交时碰到了子物体的碰撞体，那么父物体也会调用OnTriggerEnter2D方法。
总的来说就是当子物体的碰撞体被碰撞时，父物体的脚本如果有OnTriggerEnter2D方法，那么它就会被调用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd3a8d20e67950498d630e18dfe47bfd/" rel="bookmark">
			数据结构【二叉树】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 我们在前面学习了使用数组来实现二叉树，但是数组实现二叉树仅适用于完全二叉树（非完全二叉树会有空间浪费），所以我们本章讲解的是链式二叉树，但由于学习二叉树的操作需要有一颗树，才能学习相关的基本操作，由于这只是开头，为了降低学习的成本，所以我们手动的来创建一颗普通的二叉树，等到本文的后面，再讲解真正的创建
二叉树的基本结构 typedef int BTDataType; typedef struct BinaryTreeNode { BTDataType _data; struct BinaryTreeNode* _left; struct BinaryTreeNode* _right; }BTNode; 创建新结点 BTNode*BuyNode(BTDataType x) { BTNode* Node = (BTNode*)malloc(sizeof(BTNode)); if (Node == NULL) { perror("malloc fail:"); exit(1); } Node-&gt;_data = x; Node-&gt;_left = Node-&gt;_right = NULL; } 创造树 BTNode* CreateBinaryTree() { BTNode* node1 = BuyNode(1); BTNode* node2 = BuyNode(2); BTNode* node3 = BuyNode(3); BTNode* node4 = BuyNode(4); BTNode* node5 = BuyNode(5); BTNode* node6 = BuyNode(6); BTNode* node7 = BuyNode(7); BTNode* node8 = BuyNode(8); node1-&gt;_left = node2; node2-&gt;_left = node3; node3-&gt;_right = node4; node1-&gt;_right = node5; node5-&gt;_right = node6; node6-&gt;_left = node7; node6-&gt;_right = node8; return node1; } int main() { BTNode* root = CreateBinaryTree(); return 0; } 最后效果如图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd3a8d20e67950498d630e18dfe47bfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/205e5752cc9777f4a018a43e01d81b26/" rel="bookmark">
			人工智能--搭建人工神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到 Papicatch的博客
文章目录
🍉引言
🍉神经元与感知器
🍈神经元（Neuron） 🍈感知器
🍉损失函数与梯度下降算法
🍈损失函数
🍈梯度下降算法
🍉多层感知器与神经网络
🍈多层感知器（MLP）
🍈激活函数
🍈反向传播算法
🍉实例
🍈手工搭建神经网络
🍉总结
🍉引言 人工神经网络（Artificial Neural Networks, ANN）是一种受生物神经系统启发的计算模型，能够学习和执行复杂的非线性映射任务。本文将深入探讨神经元、感知器、损失函数、梯度下降算法、多层感知器（MLP）、激活函数、反向传播算法，并通过实例展示如何手工搭建一个神经网络。
🍉神经元与感知器 🍈神经元（Neuron） 神经元是神经网络的基本单元，模仿生物神经元的结构和功能。它接收来自其他神经元或外部输入的信号，通过加权求和和激活函数转换后输出结果。
一个简单的神经元模型如下：
其中，𝑥𝑖xi​ 是输入信号，𝑤𝑖wi​ 是对应的权重，𝑏b 是偏置项，𝜎σ 是激活函数，如 sigmoid、ReLU 等。
🍈感知器 感知器模型结构：
🍈感知器实现and函数 逻辑运算and的真值表
x1 x2
y（and运行结果）0（假）0（假）0（假）0（假）1（真）0（假）1（真）0（假）0（假）1（真）1（真）1（真） 🍈代码实现 # 定义AND运算的函数 def AND(a, b): return a &amp; b # 真值表的输入组合 inputs = [ (0, 0), (0, 1), (1, 0), (1, 1) ] # 打印真值表 print("A | B | A AND B"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/205e5752cc9777f4a018a43e01d81b26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/537b98db32cf8f072fabe851f02e3612/" rel="bookmark">
			信息学奥赛初赛天天练-31-CSP-J2022基础题-指针、数组、链表、进制转换、深度优先搜索、广度优先搜索、双栈实现队列应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PDF文档公众号回复关键字:20240621
2022 CSP-J 选择题
单项选择题（共15题，每题2分，共计30分：每题有且仅有一个正确选项）
3.运行以下代码片段的行为是 ( )
int x = 101; int y = 201; int * p =&amp;x; int * q =&amp;y; p=q; A. 将x的值赋为 201
B. 将y的值赋为101
C. 将q指向x的地址
D. 将p指向y的地址
4.链表和数组的区别包括( )
A. 数组不能排序，链表可以
B. 链表比数组能存储更多的信息
C. 数组大小固定，链表大小可动态调整
D. 以上均正确
10.以下对数据结构的表述不恰当的一项为 ( )
A. 图的深度优先遍历算法常使用的数据结构为栈
B. 栈的访问原则为后进先出，队列的访问原则为先进先出
C. 队列常常被用于广度优先搜索
D. 栈与队列存在本质不同，无法用栈实现队列
13.八进制数32.1对应的十进制数是
A. 24.125
B. 24.250
C. 26.125
D. 26.250
15.以下对递归方法的描述中，正确的是( )
A. 递归是允许使用多组参数调用函数的编程技术
B. 递归是通过调用自身求解问题的编程技术
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/537b98db32cf8f072fabe851f02e3612/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dbd67004bb71a78511e18eed69995b3/" rel="bookmark">
			【C&#43;&#43; | 重载运算符】一文弄懂C&#43;&#43;运算符重载，怎样声明、定义运算符，重载为友元函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		😁博客主页😁：🚀https://blog.csdn.net/wkd_007🚀
🤑博客内容🤑：🍭嵌入式开发、Linux、C语言、C++、数据结构、音视频🍭
⏰发布时间⏰：2024-06-21 22:14:42
本文未经允许，不得转发！！！
目录 🎄一、为什么需要重载运算符🎄二、怎样声明、定义重载运算符函数✨2.1 重载运算符的限制✨2.2 重载运算符定义✨2.3 例子-重载赋值运算符 🎄三、重载为友元函数🎄四、总结 🎄一、为什么需要重载运算符 正常情况下，C++ 的运算符( +、-、*、/ 等)只能用于对基本类型的常量或变量进行运算，而不能用于类对象之间的运算。
类的对象直接的运算虽然可以通过成员函数或全局函数去实现，如date.Add(1)，但这样的写法有时不易理解。
C++的提供了 重载运算符 的特性，允许将一些常见的运算符根据自定义类型的需要去重新定义，尽量让对象之间的运算可以像基本类型的运算一样简单、好理解。
运算符重载的目的是使得 C++ 中的运算符也能够用来操作对象。
下面例子演示了CDate类对象 使用 Add函数与 重载运算符operator+ 的运算结果：
// g++ 19_operatorAdd.cpp #include &lt;iostream&gt; using namespace std; class CDate { public: CDate(int year, int mon, int day);	// 构造函数声明 CDate(const CDate&amp; date);	// 拷贝构造函数声明 CDate Add(int day);	// Add成员函数声明 CDate operator+(int day);	// 加号运算符声明 void show() { cout &lt;&lt; "Date: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dbd67004bb71a78511e18eed69995b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60d51cf8e6eb681b2af84cb74ca63f28/" rel="bookmark">
			【Mac 从 0 到 1 保姆级配置教程 04】 - 手把手教你安装配置 zsh 和 oh my zsh，一看就会！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. zsh 是什么 zsh 是一个 Shell 解释器，全称 Z Shell，它的目标是想做大家使用的最后一个 Shell。
有些同学分不清终端和 Shell 的区别？甚至有时候会把这两个概念混为一谈，但你要清楚它们不是一个东西。
这里说的终端是一个软件，比如自带的终端和 iterm2，还有 tabby、alacrity、wezterm 等等终端软件。Shell 是命令解释器，你输入一个 ls 给 Shell，它给你返回当前目录下所有的文件和文件夹，这就是 shell 干的事。 说到 Shell，最经典的 Shell 是 bash，登录任何一个服务器都能看到 bash，而 Mac 自带的终端 Shell 就是 zsh，zsh，zsh 比 bash 功能更加强大、可定制化能力也更多。
下面我们就开始安装和配置 zsh，让你的终端更加好用！
官网：https://www.zsh.org/
2. 安装 zsh 通常这一步是可以跳过的，因为 Mac 默认会自带这个 Shell。
运行 zsh --version如果可以显示版本号，说明你已经安装了 zsh，否则通过 bew 安装即可。
brew install zsh 同时通过 echo $SHELL可以查看当前终端默认使用的 shell。
3. 安装 oh my zsh oh my zsh 是一套优秀的 zsh 配置，带有一些默认配置、插件和主题，支持定制话，只需简单的配置就能开箱即用，而且在 GitHub 上也是优秀的开源项目，已有 170K Star，如果觉得好用可以点个 Star。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60d51cf8e6eb681b2af84cb74ca63f28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/165dc3293e82a4d5d77fed61fb68903e/" rel="bookmark">
			MySQL数据库初体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库简介
使用数据库的必要性
使用数据库可以高效且条理分明地存储数据，使人们能够更加迅速、方便地管理数据数据库具有以下特点。
可以结构化存储大量的数据信息，方便用户进行有效的检索和访问。
可以有效地保持数据信息的一致性、完整性，降低数据几余。
可以满足应用的共享和安全方面的要求。
数据库的基本概念
数据
描述事物的符号记录称为数据(Data)。数字、文字、图形、图像、声音、档案记录等都是数据。
在数据库中,数据是以“记录”的形式按照统一的格式进行存储的,而不是杂乱无章的。相同格式和类型的数据统一存放在一起，而不会把“人”和“书”混在一起存储。这样，数据的存储就能够井然有序。
数据库和数据库表不同的记录组织在一起，就形成了数据库(Database，DB)的“表”(Table)。也可以说，表是用来存储具体数据的它是以一定的组织方式存储的相互有关的数据集合。例如，关系数据库的表由记录组成,记录由字段组成,字段由字符或数字组成。它可以供各种用户共享,具有最小冗余度和较高的数据独立性，它是统一管理的相关数据的集合。
数据库管理系统和数据库系统
数据库的建立和维护功能:包括建立数据库的结构和数据的录入与转换、数据库的转储与恢复、数据库的重组与性能监视等功能。
数据定义功能:包括定义全局数据结构、局部逻辑数据结构、存储结构、保密模式及信息格式等功能。保证存储在数据库中的数据正确、有效和相容，以防止不合语义的错误数据被输入或输出。
数据操纵功能:包括数据查询统计和数据更新两个方面。
数据库的运行管理功能:这是数据库管理系统的核心部分，包括并发控制、存取控制、数据库内部维护等功能。
通信功能:DBMS 与其他软件系统之间的通信,如 Access 能与其他 Office 组件进行数据交换。
经典数据模型
数据是现实世界中“量”的抽象，而数据模型(Data Mode1)是数据特征的抽象。在数据库系统中，数据模型是它的核心与基础。数据模型表现为数据的结构、定义在其上的操作及约束条件。它从概念层次上描述了系统的静态特征、动态特征和约束条件，为数据库系统的信息表示与操作提供了一个抽象框架。
在 DBMS 的发展过程中，出现了网状模型、层次模型和关系模型三种经典的数据模型。由于受限于数学基础、编程技术和硬件条件，最初出现的层次模型和网状模型与关系模型相比，在用户接口的上、中层部分更易于实现。所以，这在很长一段时间阻碍了关系模型的发展。
网状模型
数据结构
在网状模型中,数据记录组织成图的形式,使用“数据结构图”进行抽象的分析和表示。
关系数据库的基本概念
关系数据库系统是基于关系模型的数据库系统，是关系模型应用到数据库领域的实例化。它的基本概念来自于关系模型。
关系数据库的基本结构
关系数据库使用的存储结构是多个二维表格,即反映事物及其联系的数据描述是以平面表格形式体现的。
数据表通常是一个由行和列组成的二维表,每一个数据表分别说明数据库中某一特定的方面或部分的对象及其属性。
数据表中的行通常叫做记录或者元组，它代表众多具有相同属性的对象中的一个
数据表中的列通常叫做字段或者属性，它代表相应数据库中存储对象的共有属性。
主键与外键
(1)主键
数据表中的每行记录都必须是唯一的,而不允许出现完全相同的记录,通过定义主键(主关键字，Primary Key)可以保证记录(实体)的唯一性。
键，即关键字，它是关系模型中一个非常重要的元素。
主键唯一标识表中的行数据，一个主键值对应一行数据。主键由一个或多个字段组成,其值具有唯一性，不允许取空值(NULL)。一个表只能有一个主键。
关系数据库的基本概念
关系数据库系统是基于关系模型的数据库系统，是关系模型应用到数据库领域的实例化。它的基本概念来自于关系模型。
1.关系数据库的基本结构
关系数据库使用的存储结构是多个二维表格,即反映事物及其联系的数据描述是以平面表格形式体现的。
在每个二维表中，每一行称为一条记录，用来描述一个对象的信息:每一列称为一个字段，用来描述对象的一个属性。数据表与数据库之间存在相应的关联，这些关联用来查询相关的数据。
数据表通常是一个由行和列组成的二维表,每一个数据表分别说明数据库中某一特定的方面或部分的对象及其属性。
数据表中的行通常叫做记录或者元组，它代表众多具有相同属性的对象中的一个数据表中的列通常叫做字段或者属性，它代表相应数据库中存储对象的共有属性。
主键与外键
(1)主键
数据表中的每行记录都必须是唯一的,而不允许出现完全相同的记录,通过定义主键(主关键字，Primary Key)可以保证记录(实体)的唯一性。
键，即关键字，它是关系模型中一个非常重要的元素。
主键唯一标识表中的行数据，一个主键值对应一行数据。主键由一个或多个字段组成,其值具有唯一性，不允许取空值(NULL)。一个表只能有一个主键
数据完整性规则
为了维护数据库中的数据与现实世界的一致性,关系数据库的数据与更新操作必须遵守下列四类完整性规则。
实体完整性规则
实体完整性规则要求关系中的元组在主键的属性上不能有空值。如果出现空值，那么主键值就起不到唯一标识元组的作用。
域完整性规则
域完整性也称列完整性，指定一个数据集对某一个列是否有效或确定是否允许空值。
引用完整性规则
如果两个表之间相互关联，那么引用完整性规则要求不允许引用不存在的元组。
用户定义的完整性规则
用户定义的完整性规则是针对某一具体数据的约束条件，由应用环境决定。它反映某具体应用所涉及的数据必须满足的语义要求
2MySQL服务基础
MySQL 是一个真正的多线程、多用户的 SQL 数据库服务，凭借其高性能、高可靠和易于使用的特性，成为服务器领域中最受欢迎的开源数据库系统。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/165dc3293e82a4d5d77fed61fb68903e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61c50ac8d6778ccb6e1479da808be40a/" rel="bookmark">
			自研地面站！自主开源无人飞行系统 Prometheus V2 版重大升级详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自主开源无人飞行系统 Prometheus V2 相对于 Prometheus V1 在多方面做了重大的升级，今天我们将聊聊 Prometheus V2 的地面站升级。
地面站的重大提升 熟悉 Prometheus 的小伙伴们可能知道，V1 版本是没有专门的地面站的。而在 Prometheus V2 中，我们推出了阿木实验室自研的地面站。那么，这个自研地面站到底有哪些独特之处和优势呢？让我们一起来了解一下。
自研地面站！自主开源无人飞行系统 Prometheus V2 版重大升级详解
图形化界面 Prometheus V2 地面站基于 Qt 开发，提供了一个直观的人机交互界面，大大简化了无人机的操作和使用。它支持单机控制、集群控制、吊舱控制、视觉控制操作以及实时数据反馈，适用于真实飞行环境和仿真系统，帮助用户快速上手并实现精准控制和自主飞行。
数据的可视化展示 Prometheus V2 地面站的主界面清晰地显示了无人机的各种信息，包括控制状态、控制器、飞行模式、保护触发和电量等。在主页的右上角，还能实时监控无人机的位置、速度、姿态、期望位置和期望速度。这些数据以前需要通过远程连接机载电脑查看，而现在只需在地面站上轻松查看，大大提升了使用便利性和飞行安全性。
一键启动与断开 在 V1 中，起飞和断开操作需要通过终端输入代码，而在 V2 中，只需点击地面站上的“起飞”按钮即可完成起飞操作，简化了流程。同样，运行完 demo 后，通过点击“断开”按钮即可关闭所有程序窗口，无需手动一个个关闭，大大提高了操作的便利性。
安全检查与地图功能 地面站自动运行安全检查，并通过红绿两色快速反馈无人机的安全状态。我们还在地面站中增加了平面地图和三维地图功能，满足不同飞行条件下的需求。用户无需再输入命令行调用程序，即可在地面站上直接查看飞行轨迹和路径规划。
视频推拉流 以前查看视频流需要使用 Nomachine 远程连接机载电脑，而现在可以直接在地面站中查看，大大简化了操作流程。
后续发展展望 未来，我们计划适配 MAVLINK 协议与飞控进行交互，并融合 QGC 的功能，使地面站能够完成无人机自主飞行的所有操作。此外，我们将提升平台兼容性，覆盖更多的操作系统和硬件平台，如 MacOS、iOS 和 Android 等。
如何体验 Prometheus V2 地面站？ 我们还准备了免费试用的【简易版地面站】软件包，欢迎大家在评论区留言获取下载链接。
如需了解更多关于 Prometheus V2地面站的详细使用手册，请访问下方链接。感谢大家的支持，我们下期见！
Prometheus地面站 - Prometheus使用手册
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/011fc68244d80df7139abf5e000a4f36/" rel="bookmark">
			如何将现有系统逐步优化成微服务设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 基础服务改造核心步骤准备阶段实施阶段 基础服务设计 本文诞生于学习架构实践专栏后的深思以及总结，结合公司之前“大泥球”的架构风格，改造服务设计的思维。 改造公司系统服务主要原因：1、代码类似“屎山”，牵一发而动全身，维护成本高，且迭代慢；2、业务数据均存放在一个数据库中，几百张数据表，也是在业务代码中随意Join关联表； 基础服务改造 核心思想：梳理业务功能、划分业务领域、构建微服务、逐步剥离、平滑替换；
其中需要业务团队频繁对接以及沟通成本极高，但是也是归还历史技术债，就是一个字：撸起袖子，加油干~哈哈哈
公司也是有N条业务线，具体不阐述，但是业务线之间相互独立，背后对应的是同一个数据库，如图
这种规划现状带来的问题：
业务系统功能重复建设：功能重复，也意味着多个系统中散布着相似甚至相同的数据逻辑。由于这些数据逻辑的高度耦合，对数据库表字段的任何升级处理都会影响相关业务，违反开闭原则，导致系统的整体稳定性和可维护性受到严重影响。这种情况造成了“牵一发而动全身”的局面，难以进行灵活的功能扩展和系统优化。
数据库可用性差：若存在慢查询，导致资源阻塞，严重影响系统的可用性，甚至可能导致服务不可用。这种情况不仅影响用户体验，还可能对业务造成重大损失。其次，多系统同时访问数据库，数据库的连接数也会造成不够用，连接失败；
核心步骤 准备阶段：为微服务改造做好前期的准备工作，包括圈表、收集SQL 和 SQL 拆分。实施阶段：实际落地微服务，包括微服务开发、服务接入和数据库独立。 准备阶段 一、圈表
1.划分服务边界：
1.1:确定微服务具体包含哪些表，即服务的数据模型；
2.拆分原则：
2.1:保证既容易拆分数据库，又可以控制服务粒度，也让业务功能内聚；
2.2:符合服务边界的表，且与其他业务表关联不大；表的数量不多，保持在十几张左右；
2.3:毕竟基于现有系统改造，避免引起太多变化，减少对业务系统的影响，故先不对数据库的表结构调整，可以考虑放入后期服务升级的版本中处理；
为什么服务改造要从数据库表出发，而不是从功能入手呢？？？
从现有数据库表出发，比业务功能要清晰明了，更加直观；确定哪些表，进而大致确定服务应该具备哪些功能；从表出发，可以保证服务包含的是完整的业务功能表结构，降低表拆分得复杂度，避免一个表的一部分字段属于A服务，而另一部分字段属于B服务的情况； 二、收集SQL
服务开发团队负责提供一个标准化的 Excel 模板，各业务系统开发团队负责收集具体的 SQL;分配职责，确定人员的工作边界，不然会产生中台服务接口功能定义不清晰的问题。模板应包括以下字段：
SQL 语句：具体的 SQL 查询语句。
业务场景：SQL 语句所对应的业务场景说明。
访问频率：SQL 语句的访问频率（高、中、低）。
表名：涉及的数据库表名。针对以上SQL 语句封装成服务接口，提供给业务系统使用； 三、拆分SQL
因为收集的SQL语言不可能仅限于当前服务的数据库，也会产生于其他服务的数据库产生关联；故需要要求各个业务团队先进行拆分，保证最后提供给服务开发团队的 SQL，只包含访问当前服务数据库的相关表;通过SQL拆分，保证历史系统拆分新服务时，与其他数据库表的直接联系，降低耦合关系；其次，SQL拆分，一定会涉及各个业务系统的改造，故也需要各个业务团队的配合和支撑；最后，等待新微服务构建完成后，业务系统接入微服务，则完成现有SQL的替换； 实施阶段 四、构建微服务
主要包括接口设计、代码开发、功能测试等步骤；
依据梳理的SQL，对接口做一定的通用化设计，避免为每个 SQL定制一个单独的接口，以此保证服务的复用能力。第一版的服务主要是做好接口设计，聚焦业务功能，以保证服务能够落地，业务系统能够顺利对接为目标。持续迭代服务，内部做技术性优化，保证对外提供的服务接口不变； 五、接入微服务
经过功能和性能验证后，业务系统可以直接接入新服务接口；由各个业务开发团队逐步接入，替换原来的 SQL 语句；接入新服务的难度不大，但需要耗费比较多的时间，故需要公司各个层次的人员相互配合与支撑； 六、数据库独立
当服务接入完成，所有的 SQL 语句都被替换后，业务系统是通过服务来访问数据库的；将原业务系统的数据相关表迁移到新服务对应的独立水库；将原来的直连数据，演变为通过新服务访问数据库；服务和数据库独立，从物理层面，切断业务团队对这些表的依赖，也是趋向企业数字化改革的一步；要避免业务系统还有遗漏的 SQL 语句，避免它们还在直接访问库存的表。我们可以在迁库前，通过代码扫描做好相应的检查工作。 基础服务设计 上part了解到如何将服务逐步改造成微服务，那么如何打造一个合理的微服务呢？？？请看下文
关于基础服务设计的核心思想，也需要保证业务上的复用性，故需要把各个基础服务封装成高度复用的共享服务。
首先要明确一个思想：技术的核心价值是为业务服务，故开发中我们除了技术之外的事情，就是了解、学习、分析业务领域；否则如果对业务了解不深入，则会导致服务设计不足（兼容很多服务版本设计）或者导致过度设计（浪费资源，实现一堆不可用的功能）；
如何设计微服务呢？？？
核心：服务边界的划分和功能的抽象设计；
一、清晰的服务边界划分
作为基础服务，不主动调用其他服务，保证基础服务职责单一；作为基础服务，不负责与第三方系统的集成； 二、服务内部抽象设计
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/011fc68244d80df7139abf5e000a4f36/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/239/">«</a>
	<span class="pagination__item pagination__item--current">240/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/241/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>