<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/445fb490c743a80bccc9ae1b8865b74b/" rel="bookmark">
			头哥数据库实战答案及解析(1-1 到 1-5)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1-1 初识MySQL 第一关：创建数据库 编程要求
在右侧命令行中连接MySQL，并创建一个名为MyDb的数据库。
连接数据库的用户名为：root，密码为：123123。
分析
-- 连接到MySQL mysql -u root -p 123123 -h 127.0.0.1 -- 创建数据库 create database MyDb; 第二关：创建表 编程要求
在右侧命令行中操作，创建数据库TestDb，在TestDb下创建表t_emp，表结构如下：
-
分析
mysql -uroot -p123123 -h127.0.0.1 create database TestDb; use TestDb create table t_emp( id int, name varchar(32), deptId int, salary float ); 第三关：使用主键约束 编程要求
在数据库MyDb中，创建两张表t_user1，t_user2，表结构如下，请为两张表分别创建主键约束，t_user1 的主键为 userId,t_user2 的主键为联合主键，将字段 name 和 phone 作为t_user2 的联合主键。
t_user1
-
t_user2
-
分析 主键的创建方式有两种，在数据类型的后面加上 primary key 或者在表定义的最后加上 primary key(…)，复合主键的定义就是采用这种方式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/445fb490c743a80bccc9ae1b8865b74b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28e0875d3ea6407c277f248632a6b446/" rel="bookmark">
			java Map集合里面取键和值的四种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Map的keySet()方法获取键集合，再使用forEach循环遍历键集合，通过Map的get()方法获取对应的值。例如： Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put("apple", 1); map.put("banana", 2); map.put("orange", 3); // 获取键集合，遍历键集合，通过get()方法获取对应的值 Set&lt;String&gt; keySet = map.keySet(); for (String key : keySet) { Integer value = map.get(key); System.out.println("key：" + key + "，value：" + value); } 使用Map的values()方法获取值集合，再使用forEach循环遍历值集合。例如： Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put("apple", 1); map.put("banana", 2); map.put("orange", 3); // 获取值集合，遍历值集合 Collection&lt;Integer&gt; values = map.values(); for (Integer value : values) { System.out.println("value：" + value); } 使用Map的entrySet()方法获取键值对集合，再使用forEach循环遍历键值对集合，通过Entry的getKey()方法获取键，通过Entry的getValue()方法获取值。例如： Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28e0875d3ea6407c277f248632a6b446/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c867882975ca8dd757e9a3495731bba/" rel="bookmark">
			【排序算法】堆排序详解与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、堆排序的思想 堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。它是通过堆（若不清楚什么是堆，可以看我前面的文章，有详细阐述）来进行选择数据，通过向下调整算法，从第一个非叶子结点开始在局部先创建出大堆（或小堆），然后父亲结点不断往上走，直到整棵树都建成一个堆。 需要注意的是排升序要建大堆，排降序建小堆。（ 然后不断交换根节点和最后一个节点的值，交换完后节点的数目减1（因为最后一个节点已经是它应该在的位置了，不用再参与建堆），再从根节点向下建堆（除最后一个节点其它节点又会建成一个堆） ） 。 然后重复红色括号中的过程，堆排序就完成了。 二、堆排序的图解 下图以建大堆为例排一个升序序列
三、堆排序的实现 3.1向下调整算法的实现 实现堆排序最重要的就是实现向下调整算法。以下是向下调整算法的代码以及解释
//这里以建大堆为例 void AdjustDown(int* a, int n, int root) { int child = root * 2 + 1;//找到根节点的左孩子 while (child &lt; n)//判断左孩子是否出界 { if (child + 1 &lt; n &amp;&amp; a[child + 1] &gt; a[child]) //child + 1 &lt; n判断右孩子是否出界， //a[child + 1] &gt; a[child]判断左右孩子的大小，取左右孩子中大的那一个 child++; if (a[child] &gt; a[root])//入过孩子的值比父亲的值大，就交换孩子和父亲的位置 Swap(&amp;a[child], &amp;a[root]); else//如果孩子的值不比父亲的值大，就证明大堆已经建好了（因为此时父亲的左右子树都是大堆）， //直接break跳出循环。 break; //没有break来到这里就顺着子树继续往下走 root = child; child = root * 2 + 1; } } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c867882975ca8dd757e9a3495731bba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/418ce5afab707df03525ebc6834f52a0/" rel="bookmark">
			jar 命令启动java 指定配置文件路径 jar如何启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以使用以下命令来启动一个包含配置文件的jar包：
java -jar yourJarFile.jar --spring.config.location=file:/path/to/your/config/file/application.properties 其中，yourJarFile.jar是你的jar文件名，--spring.config.location指定了配置文件的路径。将/path/to/your/config/file/application.properties替换为你的配置文件的实际路径。
如果你的jar包没有使用Spring Boot框架，则需要使用合适的参数来指定配置文件路径。例如：
java -jar yourJarFile.jar -Dconfig.file=/path/to/your/config/file/application.properties 其中，-Dconfig.file参数指定了配置文件的路径。同样，将/path/to/your/config/file/application.properties替换为你的配置文件的实际路径。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bceca4b52c8a753f07d04c61f54f077/" rel="bookmark">
			玩转stable-diffusion之xformers安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、xformers是SD的加速模块，没有他可以继续运行，可以正常生成图片。只是xformers可以帮助提升图片的生成速度。
2、安装完SD后，启动出现xformers未安装的情况
No module 'xformers'. Proceeding without it. 可以单独pip 安装xformers模块，命令：
pip install xformer 3、注意这里的版本，如果安装的版本不对，会卸载你的原安装正常的pytorch版本，导致你的环境变得无法使用。比如我安装的torch-2.0.1+cu118，对应的是xformer0.0.19等都是错误的，导致需要重新卸载，重新安装。
torch-2.0.1+cu118，对应的是xformer0.0.20
可以直接使用 pip install xformer 或pip install xformer-0.0.20
4、如果出现因安装xformers而卸载已经安装好的torch，可以先直接卸载torch和xformers，再运行webui-user.bat 脚本（直接运行webui-user.bat，不要带参数）重新安装torch
1）卸载命令：pip uninstall torch xformers
2）重新安装torch 命令：.\webui-user.bat，
3）再重新安装pip install xformer-0.0.20
5、修改webui-user.bat的参数，使其xformers参数启动生效：
set COMMANDLINE_ARGS=--xformers xformers的git地址如下，网上有其他方式根据源码安装的，也可以作为参考：
https://github.com/facebookresearch/xformers
6、针对显存不高的电脑，xformers没什么明显的提升，所以只是自己的电脑学学玩玩，不安装xformers也无所谓。比如我的显存4G，一张图片70秒左右，安不安装xformers都还是70秒左右，没有明显的差别。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8451888fde23d404b45d6cd2e23d83e/" rel="bookmark">
			mac m1打开word或excel显示VB运行时错误53，怎么解决这个问题，亲测有效！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mac m1打开word或excel或ppt时显示VB运行时错误53，每次都要点击多次，才能结束，用起来非常不方便，很麻烦，那么怎么解决这个问题呢，为大家献上，亲测有效！
如上图
非常简单
选择工具
找到模板加载项
如下图
点进去哈
接下来进入到以下画面
把这个linkcreation.dotm取消勾选
右下角还有个确定啊，不要忘了点，这样就OK啦
如果以上方案还不能解决，献上我的终极方案
1.删除不兼容的文件，打开访达-前往 /Users/用户名/Library/Group Containers/UBF8T346G9.Office/User Content.localized/Startup.localized
也就是以上位置
依次删除启动目录下三个文件夹的文件，如下图所示，已删除
2.重启 Word Excel 或者PPT
然后选择工具 - 模板和加载项
删除后 再重启Word打开文件 就没有烦人的弹窗了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1322ee74fef278e7eed96db2d6d02ffa/" rel="bookmark">
			人工智能驱动的古彝文识别：保护和传承古彝文文化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🤵‍♂️ 个人主页：@艾派森的个人主页
✍🏻作者简介：Python学习者
🐋 希望大家多多支持，我们一起进步！😄
如果文章对你有帮助的话，
欢迎评论 💬点赞👍🏻 收藏 📂加关注+
目录
引言
一、古彝文的背景
1.1古彝文的起源和发展
1.2古彝文的文化和历史价值
1.3古彝文古籍的保护现状
二、古彝文识别的重难点
三、古彝文保护新思路
3.1智能文字识别领域领头羊
3.2古彝文的解决方案 3.3实际应用
四、总结
引言 在人类历史的长河中，古彝文作为中国古代少数民族彝族的文字，承载着丰富的文化、历史和哲学信息，具有极高的研究价值。然而，由于古彝文传承的复杂性和文字使用的局限性，古彝文古籍的保护和识别面临着重大的挑战。合合信息凭借其卓越的智能文字识别技术和智能图像处理技术，为古彝文保护和识别提供了全新的解决方案。在本文中，我们将探讨合合信息在古彝文方面的研究成果，揭开其技术背后的神秘面纱。
一、古彝文的背景 1.1古彝文的起源和发展 古彝文是彝族先民创造的古老文字，有多种起源和发展观点。一些人认为古彝文与宗教有关，用于记录和传播宗教信仰和仪式；另一些人主张古彝文是彝族先民根据自然和社会启示所创；还有一些人认为古彝文为记录和传播本民族的历史、文化和传统而创。关于古彝文的起源，有汉代、唐代和明代等不同说法，显示其复杂性和多样性。总之，古彝文源于彝族先民的生产生活实践，并发展与历史，是彝族及中国的重要文化和历史载体。
古彝文字义
鱼
鸟
月
马
首
古彝文字
1.2古彝文的文化和历史价值 古彝文是彝族文化和历史的载体，记录了彝族人民多个方面的历史。通过古彝文，我们可以了解彝族人民的生产、生活、文化、宗教、政治等方面的历史，对于研究彝族文化和历史具有重要的学术价值。古彝文也是中国南方少数民族的文字之一，具有独特的地方特色和文化内涵，是中国多元文化和语言的重要代表之一。通过古彝文，我们可以增强文化自信和国家认同感。
1.3古彝文古籍的保护现状 联合国教科文组织自上世纪80年代就逐步认识到,随着全球化的变迁,无形文化比有形文化显得更加脆弱。因此,在1989年通过的《关于保护传统和民间文化的建议案》的基础上,又于1998年制定了《教科文组织宣布人类口头和非物质遗产代表作条例》,强化了对非物质口头文化遗产的关注和保护。我国在不断加大对非物质文化遗产保护力度的同时,也正在加紧制定非物质文化遗产保护法。
二、古彝文识别的重难点 古彝文识别的重难点主要包括以下几个方面：
古彝文的字符集和字体非常庞大且复杂，不同地域和不同时代的古彝文存在差异，这给字符识别和文本识别带来了很大的挑战。古彝文没有标准的书写规范，不同的人有不同的书写风格和习惯，这使得文本识别和机器学习变得更加困难。古彝文古籍的保存状况不好，很多古籍存在残缺、污渍、笔墨污染、模糊、印章噪声干扰等问题，这给文本修复和识别带来了很大的困难。古彝文古籍的排版风格不统一，不同地域和不同时代的古彝文古籍存在差异，这给文本定位和识别带来了很大的挑战。古彝文古籍中存在手写体，不同的人有不同的手写风格，这使得手写体识别变得更加困难。古彝文古籍中存在多语种混合的情况，例如彝文和汉文混合使用，这给文本识别和机器学习带来了更大的挑战。 三、古彝文保护新思路 3.1智能文字识别领域领头羊 合合信息以智能文字识别技术为核心，这一技术包括智能图像处理、深度学习驱动的复杂场景文字识别以及自然语言处理（NLP）三大关键组成部分。智能图像处理技术用于精确矫正文档图像，克服曲面、阴影和摩尔纹等问题，以便更好地进行文字信息提取和识别。
过去三年，合合信息的智能文字识别技术表现突出，赢得16项国际人工智能竞赛冠军，在顶级会议上发表学术成果。此外，他们获得了中国图象图形学学会科技进步奖二等奖。合合信息在古文字识别领域有丰富经验，在世界人工智能大会上展示了智能文字识别技术在甲骨文和西周钟鼎文中的应用，受到央视、人民日报、新华社等媒体广泛关注。
3.2古彝文的解决方案 版式多样化： 彝文古籍的排版风格多种多样，字符间距和行距不一致，这给文字定位带来挑战。智能文字识别技术，如合合信息，通过多年的研究和应用，成功解决了复杂版式的识别和结构化理解问题，为古彝文识别提供了技术支持。
手写识别难题： 不同的彝文写者具有不同的手写风格，因此需要大量的数据库来建立识别模型。然而，古彝文缺乏公开的数据集，而且通晓此种文字的人越来越少，标注工作变得困难。引入AI技术来构建模型，填补数据不足的问题至关重要。
图像质量问题： 古彝文古籍经历了时间的洗礼，图像质量可能受到页面残缺、霉斑污渍等问题的影响。彝文的保存环境更为恶劣，文本可能出现墨色深浅不一、字符间距和行距大小不一的情况。合合信息的智能文字识别技术可以通过图像增强来提高文字识别的效率和准确性。
异体字众多： 古彝文中每个字有多种异体写法，导致字符数高达87000余个，比康熙字典还多。此外，彝文古籍还存在“同音字混用”的现象，这增加了识别的难度。合合信息的智能文字识别技术有助于应对识别中的“理解和认知”层面的挑战。
3.3实际应用 作为世界上最古老的文字之一，古彝文是中华文明地图上神秘而耀眼的印记。合合信息联合上海大学、华南理工大学团队针对现有的西南彝志、云贵一带古彝文字符开展统一编码，并于近期发布了业内首个古彝文基础编码数据库（简称“数据库”）。
据悉，数据库包含上千个古彜文基础编码，通过API数据接口等形式，该数据库有望帮助高校研究人员、文化工作者、兴趣爱好者等人群快速找到古彝文在字典中的读音、汉语释义、用法，如同“大字典”一般，帮助人们降低古彝文书籍、文献阅读的门槛，以数字化手段助力传统文化保护、创新之路。
研究古彝文字集，有助于理解尚未被翻译成汉文、用字尚未规范化的古籍，更深层、透彻地作用于传统文化保护，同时通过建立古彝文数据库，填补当前国内外研究的空白。合合信息与华南理工大学共同成立文档图像分析识别与理解联合实验室，联合上海大学社会学院，共同解决数据库建设中的学术性、技术性难点。合合信息在古籍识别上主要应用的是智能高清滤镜技术，该功能可智能检测图像中存在的问题，自动判定图像优化方式，实现模糊、阴暗、手指等干扰因素全处理。
原古籍图片：
扫描全能王智能高清滤镜功能处理及检测识别结果：
原古籍图片：
扫描全能王智能高清滤镜功能处理及检测识别结果：
原古籍图片：
扫描全能王智能高清滤镜功能处理及检测识别结果：
识别效果这么好，也是因为智能高清滤镜中的智能扫描引擎支撑其落地，引擎主要包括图像感知、优化场景化决策两个部分：
1. 图像感知：通识性的图像处理——在这个阶段，应用程序使用深度学习模型来识别和理解图像的内容。通过深度学习模型，应用可以感知到图像中的光照、阴影、颜色和倾斜角度等。
2. 场景化决策：根据图像感知的结果，进行通识性、场景化的判断，扫描全能王能够智能地决策如何优化图像。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1322ee74fef278e7eed96db2d6d02ffa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2e5135d64888a414392f66b86a3ab0f/" rel="bookmark">
			解决问题：Android Studio启动不了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、启动不了之前的操作：
build报错的提示的都是乱码，于是网上搜了下，去菜单Help &gt; Edit Custom VM options
此时AS打开了AS安装目录下bin/studio64.exe.vmoptions 这个文件
根据网上说法在里边加一句
-Dfile.encoding=UTF-8 即可，于是加了，结果AS闪退。
再也启动不了，重启电脑后也不行，重新安装也不行。
看来有时不要轻信网上操作。怎么解决乱码问题，看第4步。
2、解决办法
C:\Users\yourUserName\AppData\Roaming\Google
删掉这个文件夹下的 AndroidStudio2022.3之类的文件夹即可
3、可能的原因
studio64.exe.vmoptions是个只读文件，在AS里打开后，可能因为没有权限，只看到一行
# custom Android Studio VM options, see https://developer.android.com/studio/intro/studio-config.html 实际上用editplus打开看有很多行 在AS里添加编码那行配置时，由于AS没权限，它自己也没处理没权限的情况，就崩溃了。
4、乱码问题解决
将bin/studio64.exe.vmoptions 这个文件复制出来，在外面修改好后，复制到bin/下，windows会提示用管理员身份复制，确定即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f594599f6f6ebec3384d474db260645a/" rel="bookmark">
			Xcode15下载iOS17一直中断解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、问题描述 目前的 xcode 15 安装时，跟以前有个差别：以往的 xcode 安装时自带了 ide、sdk 等工具包，安装后即可开始开发，而最新的包则被分开成了不同的包，这里以 ios 开发包为例：Xcode_15.xip 和 iOS_17_Simulator_Runtime.dmg
正常下载或更新好Xcode之后，Xcode会提示你下载iOS17，众所周知，Xcode传统艺能是下载到一半提示你网络问题，且只能重头下载，甚是折磨。
2、解决办法 可以使用命令行的方式解决，具体步骤如下
首先在官网下载 iOS_17_Simulator_Runtime.dmg ，正常下载好之后是在Downloads文件夹
其次，下载好之后打开终端键入命令，注意路径
sudo xcode-select -s /Applications/Xcode.app xcodebuild -runFirstLaunch xcrun simctl runtime add "~/Downloads/iOS_17_Simulator_Runtime.dmg" 最后打开Xcode就已经安装完成了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43901fd78e11eab7e7a360c9a1fae2ae/" rel="bookmark">
			好奇喵 | Tor浏览器——访问.onion网址，揭开Dark Web的神秘面纱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在之前的博客中：
1.Surface Web —＞ Deep Web —＞ Dark Web，我们解释了表层网络、深层网络等的相关概念；
2.Tor浏览器——层层剥开洋葱，我们阐述了Tor的历史和基本工作原理；
3.Tor浏览器——如何拥有一颗洋葱并使用，我们介绍了Tor的下载和使用；
本篇博客揭开.onion后缀网址的面纱，以及dark web的神秘面纱。其实dark web 就像黑市一样，卖各种东西，比如假的驾照，身份证啥的。。。
Tor浏览器——访问.onion网址，揭开Dark Web的神秘面纱 什么是.onion网址 .onion是一个用于在Tor网络上寻址特殊用途的顶级域后缀。这种后缀不属于实际的域名，也并未收录于域名根区中。但只要安装了正确的代理软件，如类似于浏览器的网络软件，即可通过Tor服务器发送特定的请求来访问.onion地址。使用这种技术可以使得信息提供商与用户难以被中间经过的网络主机或外界用户所追踪。——百度百科
通俗来讲，如果你访问的网址后缀是.onion，那么你访问的其实就是Dark Web
其他正经的后缀
1.国际域名，后缀名是.com、.net和.org，国际最广泛流行的通用域名格式，经典标识，全球通用。.com一般用于商业性的机构或公司，.net一般用于从事Internet相关的网络服务的机构或公司，.org一般用于非盈利的组织、团体。当然，这些域名任何人都可注册。
2.国内域名，后缀名是.cn、.com.cn和.net.cn，.CN 域名是由我国管理的顶级国家域名(ccTLD)，属于顶级域名。当前选择注册cn域名的企业越来越多，超越.com在全球具有最大的市场。其主要特点是：
3.org：这是非营利组织的顶级域名后缀，代表组织。.org后缀适用于各类非盈利组织、慈善机构、社会团体等。当我们希望获取公益项目、参与志愿者活动或寻找慈善捐助渠道时，.org后缀的网站是我们信任的来源。
4.edu：这是教育机构的顶级域名后缀，代表教育。.edu后缀适用于学校、大学、教育机构等提供教育服务的网站。当我们需要查询学校信息、报名参加课程或获取学术资源时，.edu后缀的网站是我们学习的重要平台。
5.gov：这是政府机构的顶级域名后缀，代表政府。.gov后缀适用于政府部门、政府机构和公共服务机构的网站。当我们需要获取政府政策、办理行政事务或寻找公共服务资源时，.gov后缀的网站是我们获取官方信息的重要渠道。
v2版本和v3版本的洋葱服务 如果洋葱服务是 16 个字符的字符串（V2 格式），请注意该类型地址已弃用。
怎样知道我用的是 v2 还是 v3 版洋葱服务？
可以通过 56 个字符的长度来识别洋葱地址 v3 版，例如，e.g. Tor Project v2 版的地址是：
http://expyuzz4wqqyqhjn.onion/，
Tor Project v3 版的地址是：
http://2gzyxa5ihm7nsggfxnu52rck2vv4rvmdlkiu3zzui5du4xyclen53wid.onion/
2020 年 9 月，Tor 开始提醒洋葱服务管理员和客户端， 0.4.6 版本将弃用并淘汰 v2。 2021 年 6 月，Tor 浏览器开始提醒用户。
在 2021 年 7 月，0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43901fd78e11eab7e7a360c9a1fae2ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2baaefc1947f4b9decff0b759bc2e76/" rel="bookmark">
			【排序算法】一文教你从零学会希尔排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、插入排序的基本思想 希尔排序是插入排序的一种，在介绍希尔排序之前，先介绍一下插入排序的思想。插入排序就是把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列 。与扑克牌的插入的类似。 二、直接插入排序 直接插入排序是实现希尔排序的基础，本人的理解其实希尔排序就是直接插入排序的升级版本，我们先介绍和实现以下直接插入排序，为实现希尔排序打下基础。
2.1思想 当插入第i(i&gt;=1)个元素时，前面的array[0],array[1],…,array[i-1]已经排好序，此时用array[i]的排序码与array[i-1],array[i-2],…的排序码顺序进行比较，找到插入位置即将array[i]插入，原来位置上的元素顺序后移
2.2代码实现与解释 void InsertSort(int* a, int n) { for (int i = 0; i &lt; n - 1; i++) { int endi = i; int tmp = a[endi + 1]; while (endi &gt;= 0) { if (a[endi] &gt; tmp) { a[endi + 1] = a[endi]; } else break; endi--; } a[endi + 1] = tmp; } } 代码中的a是传进来的整形数组，n是数组元素的个数。我以下面这个例子来更加形象地解释一下上面的代码。假设要将5,4,3,2,1这个数组调整为升序，n为5，数组的下标分别为0,1,2,3,4。
for循环的第一趟循环，为的就是让数组的前两个数有序。第一趟i=0，endi=i=0,tmp=a[1]=4（tmp的作用就是保存要插入前面序列的那个数的值）,a[endi]（第一个数）比tmp（第二个数的值）大，将 a[endi]的值赋给a[endi + 1]（相当于往后挪了，空出位置可以让tmp的值插入）。如果a[endi] &gt; tmp这个条件不成立，就证明tmp（要插入数字的值）大于等于前面序列的值，也就不用往前插入了，直接break。endi不断减减，比tmp大的数就不断往后挪一格，最后endi+1这个位置就是tmp这个值应该去的位置。（就第一趟排序而言，endi本身为0，减减后变为-1，endi+1==0正好是tmp要在的位置）。之后endi不断往后挪，endi后面的一个数不断往前插入。n个数要走n-1趟，所以for循环中的条件是i&lt;n-1。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2baaefc1947f4b9decff0b759bc2e76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a28c34ea5af06bbccf006a3463161f0/" rel="bookmark">
			mac安装暴雪战网卡在45%的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 最近网上刷到一些星际争霸的视频。随后去暴雪官网看了一下，发现星际争霸竟然有mac版本，而且还是重制版。
情怀发作之下~ 安装了一波。中间遇到了一些问题，记录下。
注册了战网账号，下载战网的时候，发现会一直卡在45%进度上。
问题 随后在 /Users/Shared/Battle.net/Agent/Agent.8445/Logs 目录中找到日志，发现http://cn.patch.battlenet.com.cn:1119/agent/versions?nocache=3994009104 一直在链接超时。
应该是安装战网时，更新文件是走的cn.patch.battlenet.com.cn，域名解析到了澳大利亚223.252.234.30，该链路问题导致的。
上网找到了一篇文章，macOS 战网安装卡进度条 解决 ， 发现是修改host文件，让cn.patch.battlenet.com.cn请求重定向到117.52.35.40上。查了下该ip，是暴雪在韩国的服务器。应该近期该ip都是有效的。可以放心使用。
解决 强制退出战网安装程序
打开终端执行如下命令：
sudo rm -rf /Users/Shared/Battle.net rm -rf ~/Library/Preferences/com.blizzard* rm -rf ~/Library/Preferences/net.battle* sudo vi /etc/hosts 添加一条 117.52.35.40 cn.patch.battlenet.com.cn
不会用vim的话，上网查下使用方法吧。也可以用其他编辑器打开编辑。
重新安装，成功
同时也免去了使用加速器的过程。网上有一些加速器推广的解决方案，也可以避免安装加速器来解决了。非常简单~
参考 macOS 战网安装卡进度条 解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40305ced65c4dd11b6a8827b1d6e78e9/" rel="bookmark">
			【Java 进阶篇】JDBC数据库连接池Druid详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java应用程序中，与数据库进行交互是一个常见的任务。为了更有效地管理数据库连接并提高性能，数据库连接池是一种常见的解决方案。Druid是一个流行的JDBC数据库连接池，它具有丰富的功能和高性能。本博客将详细介绍Druid连接池，包括它的优点、配置、使用方法以及示例代码。
1. 什么是数据库连接池？ 数据库连接池是一个存储数据库连接的缓冲区，用于重复使用这些连接，以避免在每次请求时都创建新的数据库连接。连接到数据库的过程是相对耗时的，因此连接池可以显著提高应用程序的性能。它们还有助于防止应用程序超负荷地创建太多数据库连接，从而减轻数据库服务器的负担。
2. 为什么选择Druid连接池？ Druid是一个开源的、高性能的数据库连接池，它在很多方面超越了其他连接池。以下是一些选择Druid的原因：
监控和统计：Druid提供了丰富的监控和统计功能，您可以了解连接池的使用情况、SQL执行情况等。这有助于识别性能问题和优化SQL查询。
防SQL注入：Druid内置了防SQL注入的功能，可以有效地防止潜在的安全风险。
高性能：Druid经过精心优化，具有出色的性能。它支持连接池预热，可以在应用程序启动时提前创建一些连接，以减少第一个请求的延迟。
丰富的配置选项：Druid允许您通过配置文件或编程方式进行高度自定义，以满足各种需求。
3. 配置Druid连接池 要在Java应用程序中使用Druid连接池，首先需要添加Druid的依赖。如果使用Maven，可以在pom.xml中添加以下依赖：
&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.6&lt;/version&gt; &lt;!-- 使用最新版本 --&gt; &lt;/dependency&gt; 接下来，您需要配置Druid连接池。配置可以通过Java代码或属性文件进行。以下是一个基本的Druid配置示例：
import com.alibaba.druid.pool.DruidDataSource; import java.sql.Connection; import java.sql.SQLException; public class DruidConfig { public static void main(String[] args) throws SQLException { // 创建Druid数据源 DruidDataSource dataSource = new DruidDataSource(); // 设置数据库连接信息 dataSource.setUrl("jdbc:mysql://localhost:3306/mydatabase"); dataSource.setUsername("root"); dataSource.setPassword("password"); // 配置连接池参数 dataSource.setInitialSize(5); // 初始化连接数 dataSource.setMaxActive(20); // 最大连接数 dataSource.setMinIdle(5); // 最小空闲连接数 // 获取数据库连接 Connection connection = dataSource.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40305ced65c4dd11b6a8827b1d6e78e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49c298d48b8275db2bf25cfd05b5a42e/" rel="bookmark">
			深入了解 RabbitMQ：高性能消息中间件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 引言：一、RabbitMQ 介绍二、核心概念三、工作原理四、应用场景五、案例实战 引言： 在现代分布式系统中，消息队列成为了实现系统间异步通信、削峰填谷以及解耦组件的重要工具。而RabbitMQ作为一个高效可靠的消息队列解决方案，已经成为许多企业广泛采用的选择。本文将介绍RabbitMQ的基本概念、主要特性以及常见应用场景。
一、RabbitMQ 介绍 RabbitMQ 是一个开源的高性能、可扩展、消息中间件（Message Broker），实现了 Advanced Message Queuing Protocol（AMQP）协议，可以帮助不同应用程序之间进行通信和数据交换。
RabbitMQ 是由 Erlang 开发的，支持多种编程语言，包括 Java、Python、Ruby、PHP、C# 等。它的核心思想是将发送者（producer）与接收者（consumer）完全解耦，实现异步处理和低耦合度的系统架构。
RabbitMQ 的设计思想可以总结为：
可靠性：RabbitMQ 实现了多种机制来保证消息的可靠传输，如消息确认、事务等。灵活性：RabbitMQ 支持多种路由规则，可以根据需求定制不同的路由策略。插件化：RabbitMQ 提供了多种插件，如管理插件、监控插件等，方便用户进行扩展和监控。可扩展性：RabbitMQ 支持多种集群模式，可以方便地扩展到多个节点上进&gt;- 行负载均衡、高可靠等操作。
总之，RabbitMQ 是一款强大的消息中间件，它可以帮助开发人员轻松地构建分布式系统，并实现高效、可靠的消息传输。。 二、核心概念 Producer（消息生产者）：负责发送消息到消息队列。
Queue（消息队列）：用于存储消息的缓冲区，降低消息的发送和接收的时间差。
Consumer（消息消费者）：从消息队列获取消息并进行处理。
Exchange（交换机）：接收来自生产者的消息，并根据一定的规则将消息路由到一个或多个队列。
Binding（绑定）：用于将交换机和队列绑定在一起，确定消息的路由规则。
三、工作原理 RabbitMQ 的工作原理非常简单，它主要由以下几个部分组成：
生产者（producer）将消息发布到一个队列中。消费者（consumer）订阅一个或多个队列 ，并开始接收消息。RabbitMQ 服务器会将消息逐一发送给订阅了该队列的所有消费者。对于每个消息，服务器会将其发送给一个订阅了相应队列的消费者。
一旦消费者处理完消息，RabbitMQ 服务器就会从队列中移除该消息。在 RabbitMQ 中，生产者和消费者之间通过交换机（exchange）进行通信。如果一个生产者向 RabbitMQ 发送一条消息，它首先会将该消息发送到一个交换机。交换机会根据不同的路由规则将消息发送到对应的队列中，然后由订阅了这个队列的消费者进行处理。 在 RabbitMQ 中，交换机有四种类型：Direct、Fanout、Topic 和 Headers。每种交换机类型都有不同的路由规则，可以更好地满足不同应用场景的需求。
四、应用场景 异步任务处理：将耗时的任务放入消息队列，异步处理，提高系统的响应速度。
系统解耦：通过消息队列，系统之间解耦，实现松耦合的架构，方便扩展和维护。
数据同步：通过消息队列实现不同系统之间的数据同步，确保数据的一致性。
削峰填谷：通过消息队列，可以控制系统的并发压力，防止服务过载。
日志收集：将日志信息发送到消息队列，实现集中式的日志管理和统计分析。
总结：
RabbitMQ作为一个高效可靠的消息队列解决方案，在分布式系统中发挥着重要的作用。通过其丰富的特性和灵活的应用场景，我们可以构建出稳定、可靠且高性能的分布式系统。希望本文对您理解RabbitMQ的基础概念和应用有所帮助。
五、案例实战 安装 RabbitMQ。 RabbitMQ 可以通过官方网站下载并安装，也可以通过包管理器进行安装。
1.访问 RabbitMQ 官方网站：https://www.rabbitmq.com/install-windows.html。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49c298d48b8275db2bf25cfd05b5a42e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3416ff4c6b3359868afaa2fae03e327a/" rel="bookmark">
			深入理解BPE、WordPiece、Unigram分词算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 前言1.1 word-level分词1.2 char-level分词1.3 为什么要有subword-level分词？ 2. 子词分词2.1 BPE2.1.1 学习流程2.1.2 分词流程2.1.3 从零实现BPE2.1.4 解码流程 2.2 WordPiece2.2.1 学习流程2.2.2 分词流程2.2.3 从零实现WordPiece2.2.4 解码流程 2.3 Unigram2.3.1 学习流程2.3.2 分词流程2.3.3 从零实现Unigram2.3.4 解码流程 3. 三种分词方法的比较Ref 1. 前言 NLP任务中最重要的一个环节就是分词。分词器（Tokenizer）在整个任务流程中扮演的角色如下
即给定一段文本，分词器会将其分割成一个个token，这些token会根据vocab转化成对应的ID以作为模型的输入。
完整的分词流程包含以下四个步骤
标准化阶段（Normalization）：先将原始文本（raw text）做一个预处理，例如去掉Unicode字符的重音（é 变成 e），将所有字母全部转化成小写字母（E 变成 e）等。这一步可以理解为数据清洗；预分词阶段（Pre-tokenization）：进行一遍粗略的分词，例如基于空格&amp;标点的分词，即word-level。注意预分词结果的粒度必须大于最终分词结果的粒度；模型阶段（Model）：在预分词的语料上进行训练（注意分词器的训练和模型的训练是两个概念！模型的训练是通过梯度下降来降低loss，具有随机性，而分词器的训练是一个统计过程，最终的结果是确定性的）；后处理阶段（Postprocessor）：添加一些特殊的token，例如BERT中的 [CLS] 和 [SEP]。 分词的粒度主要有三种：word-level、char-level和subword-level，对于前两种粒度，则不需要经历第三阶段（模型阶段）。
本文将主要聚焦于第三阶段，但在此之前，先让我们回顾一下word-level和char-level分词。
1.1 word-level分词 word-level分词的一个直观出发点是基于空格分词，即对字符串调用 split() 方法
text = "Don't you love 🤗 Transformers? We sure do." print(text.split()) # ["Don't", 'you', 'love', '🤗', 'Transformers?', 'We', 'sure', 'do.'] 但这个结果不是最优的，因为 Transformers?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3416ff4c6b3359868afaa2fae03e327a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dce18f70746b13550d071fabf54ef53/" rel="bookmark">
			【C语言】堆排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、堆排序思想二、向上调整建堆排序三、向下调整建堆排序四、总结 对于什么是堆，堆的概念分类以及堆的向上和向下两种调整算法可见： 堆的创建 一、堆排序思想 int a[] = { 2,3,5,7,4,6 }; 对于这样一个数组来说，要想要用堆排序对它进行排序，首先要做的就是用数组里的数据建立一个堆，大堆和小堆都可以，只有是一个堆才能使用堆排序。
那么应该建大堆还是小堆呢，例如对于这个数组要排升序，如果建立小堆的话
建成小堆后找出了最小的元素，要找到次小的就需要把剩下的元素看作堆，但剩下的元素不一定是堆，需要重新建堆，代价比较大。
更好的方法是升序建立大堆，堆顶和最后一个元素交换，最后一个最大的元素就已经有序，对剩下数据进行向下调整，就能找出第二大的，以此就能将数组排好序。
总结一下堆排序的思想就是：
1、根据要排什么序建大堆或小堆，此时堆顶端的元素就是最值
2、将顶端元素和末尾元素交换，此时末尾元素就是有序的，剩下的还有n-1个元素
3、将剩下的n-1个元素再次构建成堆，然后将堆顶端元素与第n-1个元素互换，反复执行便可得到有序数组
升序：建大堆
降序：建小堆
二、向上调整建堆排序 使用向上调整算法建堆的堆排序
例如：将数组a用堆排序按从小到大排列（升序）
首先，利用向上调整算法建大堆，此方法可参考堆的创建
向上调整算法的前提条件是：前面的元素是堆
对于单个结点来说既可以看作一个大堆，所以便可以通过向上调整算法依次对数组元素进行调整，那进行调整的元素前就一定是堆，满足条件
创建好的大堆如下：
将堆的顶端元素7和末尾元素2进行交换，对除7外剩下的元素进行向下调整重新构建大堆
此时7已经是有序的，将元素6和元素3进行交换，对除6、7外剩下元素进行向下调整重新构建大堆
此时6、7已经有序，将元素5和元素2进行交换，对除5、6、7外剩下元素进行向下调整重新构建大堆
此时5、6、7已经有序，将元素4和元素2进行交换，此时数组已经有序
排序完数组a变为
用向上调整算法建堆的升序的堆排序代码如下：
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;stdbool.h&gt; typedef int HPDataType; //交换结点的函数 void Swap(HPDataType* p1, HPDataType* p2) { HPDataType tmp = *p1; *p1 = *p2; *p2 = tmp; } //向上调整算法(大堆) void AdjustUp(HPDataType* a, int child) { //找出双亲的下标 int parent = (child - 1) / 2; while (child&gt;0) { //孩子结点比双亲大则交换 if (a[child] &gt; a[parent]) { Swap(&amp;a[child], &amp;a[parent]); child = parent; parent = (child - 1) / 2; } else { break; } } } //向下调整算法(大堆) void AdjustDown(HPDataType* a, int n, int parent) { //先默认左孩子是较大的 int child = parent * 2 + 1; while (child &lt; n) { //找出左右孩子中较大的 if (child + 1 &lt; n &amp;&amp; a[child + 1] &gt; a[child]) { child++; } //孩子节点更小则交换 if (a[child] &gt; a[parent]) { Swap(&amp;a[child], &amp;a[parent]); parent = child; child = parent * 2 + 1; } else { break; } } } //排序 void HeapSort(int* a, int n) { //向上调整建堆 for (int i = 1; i &lt; n; i++) { AdjustUp(a, i); } //最尾端数据下标为总数减一 int end = n - 1; while (end &gt; 0) { Swap(&amp;a[0], &amp;a[end]); //对剩余元素进行向下调整 AdjustDown(a, end, 0); end--; } } int main() { int a[] = { 2,3,5,7,4,6 }; HeapSort(a, sizeof(a) / sizeof(int)); for (int i = 0; i &lt; sizeof(a) / sizeof(int); i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dce18f70746b13550d071fabf54ef53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e32e67dc1d8f567c8a7749a2d4857036/" rel="bookmark">
			2023年（24届）计算机保研推免经历（保研边缘人）| （吉大AI、华师cs、东南、浙软）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 写下这篇博客的原因在于自己保研期间刷了很多很多的经验贴，听很多学长学姐讲述了自己的经历，感觉收获颇丰。所以希望能将自己的经历也分享下去，如果以后的学弟学妹能获得一点点帮助，那就再好不过了。
保研基础知识（黑话） 名词含义rkrank,指排名，分为裸绩排名（纯绩点排名）和综合排名（加分过后的最终保研排名），裸绩排名分为前5学期和前6学期，一般哪个高用哪个。title学校头衔：四非、双非、211、985comcommittee, 强com即学院的权力大，弱com即导师的权力大。弱com学校可以通过联系老师捞人入营或者直接给offer。强com则必须通过学院的考核。bar门槛，即初筛进入学校夏令营或者预推免的下限oqover-qualified,对报名院校来说过于优秀，审核老师认为你肯定不会来，故直接在初筛筛掉。wlwating list，指候补名单。鸽人/被鸽鸽人指主动放弃院校offer或者导师的名额。被鸽则相反，由院校或者导师放弃你的录取资格。鸽穿最终填报志愿时，院校的候补名单中所有人都能被录取。套磁touch，指通过邮件联系导师，并获得弱com院校的推荐入营资格或者老师的口头offer。官回官方回复，指套磁联系后，导师给的比较礼貌但没有任何价值的回复。强组资源和产出都很丰富的研究生课题组push指导师所在课题组科研节奏十分紧凑，可能科研压力会比较大（多见强组）羊导放羊的导师，一般不管学生干啥，允许实习APassistant professor，助理教授，一般是非升即走制度下的职位，具有招收博士的资格，一般为年轻老师。绿群全国最大的计算机保研交流群，消息灵通，互帮互助，群号605176069（一定要加！可以获得很多一手信息）研控导师评价网站，可以在网站上看到很多导师的风评和评价。海王参加很多夏令营或预推免并手握很多offer。 保研形势评价 23年保研，是多年线上保研后，线下保研的第一年。由于受到多种因素的冲击，今年保研难度极大幅度地增长。也让我这种底层保研边缘人举步维艰。
23年保研形势变化有以下特点：
大量学校的bar不减反增：由于线上变为了线下，院校的入营人数也随之减少。并且保研计算机的人数也在逐年增多。由于前几年的保研形势比较糟糕，仍然有很多大佬继续当海王。于是导致学校的bar的上升（难度增长的主要原因）。普通保外推免名额变化较大：虽然2023年总体来说高校推免率仍有增加，但部分高校的一些推免名额变为了强制保内的专项推免名额（国优计划和工程硕博计划），普通保外推免名额反而降低。比如今年我们专业普通保外率从22%降低到17%，总体推免率反而从22%增加到25%强基计划占用接收名额： 部分院校的强基计划可以跨保到计算机，占用了院校的接收名额，且院校的接收名额基本没有提升。（次要原因）机试变得尤其重要： 恢复线下后，基本上80%以上的学校都设立了机试，甚至很多学校机试成绩就决定了是否能获得offer(复旦cs机试占比30%,北航cs机试占比1/3，川大cs考核甚至只有机试)，较强的机试能力可以占据较大的优势。 个人基本信息 学校：cqu专业：软件工程第四轮学科评估：B+排名：16%，真底层保研边缘人竞赛/荣誉：美赛M奖科研：一篇关于信息熵的在投ccf-c类论文。实践项目：大学生科研训练计划（srtp）、一项机器学习的竞赛项目和一项深度学习的课程设计项目。六级：555机试：0基础（之前从来没刷过题） 最终去向： 浙江大学软件学院
可以看到，我的背景是一点优势也没有，科研论文并没有发表，项目也比较水，机试还是0基础，最致命的是我的低rank，让我在初筛就被很多学校拒之门外。按照去年学长学姐的去向，我这个成绩就只能留本校了。但我也没有灰心，而是积极准备，尽我一切所能去争取更好的学校。
我是一名偏就业型的选手，如果没得选，也能接受科研向。目标是冲title和城市（北上广深），专硕学硕都可，学硕当然更好，直博坚决不考虑。怀着这样的目标，我进行了我的推免之旅。
夏令营经历 5月~6月期间，我复习了408中除了计组的其他三门课程，然后简单地看了一下机试，刷了一些代码随想录的题目。在期间，我尝试联系了一些电科的老师，但均为已读不回。结果今年电科从弱com变为了强com,而且夏令营卡rank10%,基于以上情况，我也最终在夏令营放弃了电科。
从6月开始，我开始了自己的夏令营之旅。迫于计算机保研的艰难形势以及自己毫无优势的背景，我不得已进行了海投，但最终也是收获惨淡，情况不容乐观。
整个夏令营期间，我获得了三个offer，以下是整个夏令营的情况表（有专硕报专硕，没有专硕报学硕，没有报过直博）。
学校学院是否入营结果复旦大学类脑否（图一乐）浙江大学软件学院是海王营，不给offer，入了之后没管了南京大学计算机学院否中科大先研院否西安交大 计算机学院 是宣讲营，自己找团队考核后给offer，入了之后没管了哈工深计算机学院否中山大学网安学院否国防科技大学计算机学院是（rank前25%都入了）排名很低，之后放弃天津大学智算学部是（报名的都入了，但需通过机试初筛）机试初筛没过南开大学软件学院否武汉大学 计算机学院否（西南地区的cqu,scu,uestc一个没进，且whu有极强的本校保护）华东师范大学计算机学院是offer(和老师双选）华东师范大学软件学院否（只要第一志愿）东南大学软件学院是offer北邮计算机学院是寄四川大学计算机学院否（每个学校只要两个人）中科院计算机网络信息中心是获得华师offer后，中途放弃考核吉林大学计算机学院否吉林大学软件学院否（被jlu二杀，差点把我整自闭了）吉林大学AI学院是offer 复旦大学类脑 复旦夏令营只能填报一个志愿，出于想捡漏的想法报了类脑。事实证明我还是想多了（笑）。据说fdu所有与计算机有关的学院的平均bar为专业rank1或者强科研前3%。
今年fducs的夏令营的机试首次开始算分，并占比30%。有能力进fducs夏令营的人一定要多多练习机试。
浙江大学软件学院 浙软年年夏令营海王营，今年也不例外。在填报志愿时，会让你选择一个团队。然后在入营后会进入相关团队的钉钉群，并要做一个月左右的项目，如果坚持下来认真做就是优营。但优营不给offer,只保证必定能过预推免初筛。由于当时我在准备其他学校的考核，遂放弃。
中科大先研院 中科大是纯弱com，基本上是必须要拿到老师的推荐才能够入营，所以套磁显得尤为重要。先研院是偏工程向的学院，可以在企业进行约两年的实习，很适合我。所以我也就报名了先研院，但我在报名后，联系了很多计算机的老师，均已读不回，最后也没能拿到推荐，无法入营。
西安交通大学计算机学院 西交cs今年改为了宣讲营，进行宣讲后，给了各个团队的联系方式，需要自己进行联系然后进行实验室考核。我因为在准备其他学校的考核，入营了就没管了。
中山网安 出于想捡漏的心理报了网安，后来发现是战略选择错误：有rank比我低的同学入了中山se，所以se的bar应该是最低的, 但se也筛oq：同学rank5%未入。
今年中山cs的bar约为专业rank10%, 但专业有一位17%无科研的同学也入了，据说是可以向中山cs的教务limei 求情，让她放你进去。如果想去中山cs，背景又不够的可以试一试。并且中山cs年年鸽穿，今年又鸽穿了，只要敢等基本都能去。
国防科技大学计算机学院 国防科大计院对我们学校点击就送（rank前25%），最后入营了800人左右。在7月中旬左右，计院组织了一场线下宣讲会，抽签选出了200人，让他们去参加线下宣讲，且包食宿、包火车票。我没有抽中，故没有去到线下宣讲。
8月中旬左右，计院进行了线上考核，考核方式是思想道德考核+面试考核。具体方式是通过腾讯会议进行问答面试。对面没有开摄像头，我也不知道具体有多少面试官。
首先是思想道德考核，思想道德考核基本没人会不合格，但我犯了一个致命的错误：老师问我以后想不想投身于国防事业，我回答说不确定，逗的老师都笑了。可能这个错误也是我排名很低的一个原因。
然后是第二天的面试考核，面试内容为：
2min英文自我介绍。用英文介绍一下你的家乡。你想做的研究方向是？（llm）介绍一下你做了哪些项目。这个竞赛项目具体做了哪些工作？课程设计做了哪些工作？对llm的认识？（回答的不好，太浅层了） 这次面试问的非常水，仅仅是对项目的工作进行了提问，也不进行深究。结果我准备的项目内容和专业课知识基本都没用上。总体来说，老师对我并不是特别感兴趣，对我的项目也不太了解。所以面完我就知道大概凉了。
结果：排名约450/700，完全凉完了。之后要求提交体检材料，我没有提交，相当于放弃了递补。
天津大学智算学部 天大纯海王营，报名的所有人都入了，但需要在6月底进行一次线上机试初筛来决定最终入营人选。
机试比较正规：要求双机位，且需要全程录屏并发送到指定邮箱。机试一共5道题目，只给了一部分的小数据来进行测试，难度比较低，但考察的比较全面。我当时只刷过极少的力扣题，对ACM输入模式完全不熟悉，最后也是一题未解，拿了0分（很尴尬），未过初筛。
最后好像是做出三道左右，且通过后续的大数据测试即可通过初筛，通过后，自己选择团队参加团队考核。
南开软件 南开se是强com，但可联系导师拿到入营推荐。我在报名后联系了多位导师，除了一位坑导进行了官回，其余均已读不回。最后也是未能入营。
华东师范大学计算机学院 华师计院软院都在上海市中心，实习非常方便，所以华师也是我夏令营的梦校之一。
华师cs今年的考核流程略微有些复杂：听完宣讲后，学生首先需要填写志向导师，然后进行机试和志向导师对应团队的面试。并进行综合排名。志向导师根据综合排名决定是否与学生达成双选，并要求学生进行相关实习任务，学生完成任务后才最终获得offer。
华师cs的优营率很高：62/87，基本是入营即优营。
在报名华师cs后，我在知乎上了解到华师cs是弱com,需要导师进行推荐入营。而华师官方则没有明说这个推荐入营的情况。由此可见，保研中信息搜集能力十分重要。
于是，我联系了华师cs的多位老师，终于在报名结束后的一天（6月22日左右），有一位导师主动添加我微信。并约了一个时间进行面试，面试内容主要有：
对深度学习是否了解，用过什么模型？（不太了解，没进行相关实践）你对什么研究方向感兴趣？（LLM）但是你没有任何有关研究方向的实践是吧？（苦笑）PCA；协方差矩阵的特征值可以为负数吗？谱聚类（没回答出来）项目相关。研究方向的一个相关开放性思考问题。 由于当时我对深度学习几乎是0基础。所以老师在问完第一个问题之后态度就不太好了，甚至明确说明更倾向于有基础的学生。在提问项目相关问题时，也多次不耐烦地打断了我。问完问题之后，老师向我讲述了一下华师cs的考核流程，便结束了面试。
这是第一次正式的面试，面试体验非常糟糕，可以说是完全的压力面。不过我也从中明白了自己的很多不足，也在后续时间对自己的不足进行了弥补。
面试完成之后，我听从室友的建议，向老师请求推荐我进行入营。老师没有给出明确答复。我当时比较灰心，以为跟华师无缘了（当时已被华师se拒绝入营）。结果第二天，老师给我说可以推荐我入营，我当时十分高兴，也向老师表示了感激之情。
之后，我也成功进入了华师cs夏令营，并收到了邮件。
按照规划，我在7月10日听了宣讲，并且按要求填写了当时给我推荐的导师，并被划分到对应团队进行面试。
在7月10日晚上，我进行了机试，机试一共6道题，难度为力扣的1easy2mid3hard, 我最后得分 150/600。 （实在太菜了hhh，有道题目还是前段时间练习过的原题，没做出来）而在机试之前，我向教务老师询问过机试的占比，回答是仅做参考。所以我当时也没有特别灰心。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e32e67dc1d8f567c8a7749a2d4857036/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec5b2e06ac7443d12023ed6da31da179/" rel="bookmark">
			flutter开发实战-webview插件flutter_inappwebview使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		flutter开发实战-webview插件flutter_inappwebview使用
在开发过程中，经常遇到需要使用WebView，Webview需要调用原生的插件来实现。常见的flutter的webview插件是webview_flutter，flutter_inappwebview。之前整理了一下webview_flutter，查看https://blog.csdn.net/gloryFlow/article/details/131683122
这里我们使用flutter_inappwebview来加载网页。
一、引入flutter_inappwebview 使用flutter_inappwebview，需要在pubspec.yaml引入插件。
# 浏览器 flutter_inappwebview: 5.4.3+7 二、使用flutter_inappwebview 使用flutter_inappwebview插件前，我们先看下flutter_inappwebview提供的webview的属性
WebView( {this.windowId, this.onWebViewCreated, this.onLoadStart, this.onLoadStop, this.onLoadError, this.onLoadHttpError, this.onProgressChanged, this.onConsoleMessage, this.shouldOverrideUrlLoading, this.onLoadResource, this.onScrollChanged, @Deprecated('Use `onDownloadStartRequest` instead') this.onDownloadStart, this.onDownloadStartRequest, this.onLoadResourceCustomScheme, this.onCreateWindow, this.onCloseWindow, this.onJsAlert, this.onJsConfirm, this.onJsPrompt, this.onReceivedHttpAuthRequest, this.onReceivedServerTrustAuthRequest, this.onReceivedClientCertRequest, this.onFindResultReceived, this.shouldInterceptAjaxRequest, this.onAjaxReadyStateChange, this.onAjaxProgress, this.shouldInterceptFetchRequest, this.onUpdateVisitedHistory, this.onPrint, this.onLongPressHitTestResult, this.onEnterFullscreen, this.onExitFullscreen, this.onPageCommitVisible, this.onTitleChanged, this.onWindowFocus, this.onWindowBlur, this.onOverScrolled, this.onZoomScaleChanged, this.androidOnSafeBrowsingHit, this.androidOnPermissionRequest, this.androidOnGeolocationPermissionsShowPrompt, this.androidOnGeolocationPermissionsHidePrompt, this.androidShouldInterceptRequest, this.androidOnRenderProcessGone, this.androidOnRenderProcessResponsive, this.androidOnRenderProcessUnresponsive, this.androidOnFormResubmission, @Deprecated('Use `onZoomScaleChanged` instead') this.androidOnScaleChanged, this.androidOnReceivedIcon, this.androidOnReceivedTouchIconUrl, this.androidOnJsBeforeUnload, this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec5b2e06ac7443d12023ed6da31da179/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/581012db508e4e482730a6cca28467d2/" rel="bookmark">
			【数据结构】排序之插入排序和选择排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥博客主页：小王又困了
📚系列专栏：数据结构
🌟人之为学，不日近则日退
❤️感谢大家点赞👍收藏⭐评论✍️
目录
一、排序的概念及其分类
📒1.1排序的概念
📒1.2排序的分类
二、插入排序
📒2.1直接插入排序
🎀2.1.1直接插入排序的思想
🎀2.1.2排序步骤 🎀2.1.3代码实现 🎀2.1.4直接插入排序的特点
📒2.2希尔排序
🎀2.2.1希尔排序法的基本思想
🎀2.2.2排序步骤 🎀2.2.3代码实现 🎀2.2.4希尔排序的特点
三、选择排序
📒3.1直接选择排序
🎀3.1.1直接选择排序的思想
🎀3.1.2排序步骤 🎀3.1.3代码实现
🎀3.1.4直接选择排序的特点
📒3.2堆排序
🎀3.2.1堆排序的思想
🎀3.2.2排序步骤
🎀3.2.3代码实现
🎀3.2.4堆排序的特点
🗒️前言：
排序是我们数据结构学习中很重要的章节，我们在生活中买东西都会挑选更好的，点外卖会选评分高的等等，这些都需要用到排序。接下来我们将会学习常见的排序算法。
一、排序的概念及其分类 📒1.1排序的概念 排序：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。
稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次 序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排 序算法是稳定的；否则称为不稳定的。
内部排序：数据元素全部放在内存中的排序。
外部排序：数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。
📒1.2排序的分类 二、插入排序 📒2.1直接插入排序 🎀2.1.1直接插入排序的思想 把待排序的数据按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的数据插入完为止，得到一个新的有序序列 。 实际中我们玩扑克牌时，就用了插入排序的思想。
注意：数组中除了第一个元素（默认有序），其余所有元素都看作待插入数据。 🎀2.1.2排序步骤 将有序数据的最后一个元素的下标记为 end，则第一个待插入元素的下标为 end+1，记作 tmp将 tmp 与有序数据从后向前依次比较如果 tmp &lt; a[end]，就将 a[end] 向后移动，end--，再去找下一位进行比较直到 tmp &gt; a[end] 或者 end &lt; 0，将 tmp 插入到 end+1 的位置重复步骤，就可以实现排序 🎀2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/581012db508e4e482730a6cca28467d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f850b81a1a2890d545dd74142a7ab45/" rel="bookmark">
			javascript简易计算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.计算器界面图
二.计算器功能
三.代码实现
3.1HTML部分代码
3.2css部分代码
3.3js部分代码
四.功能测试
一.计算器界面图 二.计算器功能 该计算器是一个简易的计算器，可以进行基本的数学运算，包括加、减、乘、除、括号和小数运算。具体实现如下：
用户可以在输入框中输入数字、运算符和括号，使用按钮输入或者键盘输入均可。用户可以使用计算功能，将输入框中的表达式计算出结果，并将结果显示在输入框中。计算结果将被添加到历史记录中，用户可以查看历史记录并删除不需要的记录。用户可以清除输入框中的内容或删除最后一个字符。用户可以在键盘上按下回车键进行计算。 三.代码实现 3.1HTML部分代码 &lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;简易计算器&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!-- 计算器容器 --&gt;
&lt;div class="calculator"&gt;
&lt;h1&gt;简易计算器&lt;/h1&gt;
&lt;!-- 输入框 --&gt;
&lt;div class="input-field"&gt;
&lt;input type="text" id="expression" readonly&gt;
&lt;button class="delete-button" οnclick="deleteLastCharacter()"&gt;⌫&lt;/button&gt;
&lt;/div&gt;
&lt;!-- 按钮容器 --&gt;
&lt;div class="button-container"&gt;
&lt;button οnclick="addCharacter('7')"&gt;7&lt;/button&gt;
&lt;button οnclick="addCharacter('8')"&gt;8&lt;/button&gt;
&lt;button οnclick="addCharacter('9')"&gt;9&lt;/button&gt;
&lt;button οnclick="addCharacter('/')"&gt;/&lt;/button&gt;
&lt;button οnclick="addCharacter('4')"&gt;4&lt;/button&gt;
&lt;button οnclick="addCharacter('5')"&gt;5&lt;/button&gt;
&lt;button οnclick="addCharacter('6')"&gt;6&lt;/button&gt;
&lt;button οnclick="addCharacter('*')"&gt;*&lt;/button&gt;
&lt;button οnclick="addCharacter('1')"&gt;1&lt;/button&gt;
&lt;button οnclick="addCharacter('2')"&gt;2&lt;/button&gt;
&lt;button οnclick="addCharacter('3')"&gt;3&lt;/button&gt;
&lt;button οnclick="addCharacter('-')"&gt;-&lt;/button&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f850b81a1a2890d545dd74142a7ab45/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/579/">«</a>
	<span class="pagination__item pagination__item--current">580/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/581/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>