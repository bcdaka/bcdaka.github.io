<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d540c2d22fee9be8133297be5358f145/" rel="bookmark">
			【持续集成_06课_Jenkins高级pipeline应用】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、创建项目选择pipeline的风格 它主要是以脚本（它自己的语言）的方式进行运行，一般由运维去做的事情，作为测试而言。了解即可。
--- 体现形式全部通过脚本去实现： 执行之前（拉取代码） 执行（执行代码） 执行之后（生成报告） 1、创建pipeline风格的项目 2、输入脚本
脚本示例 3、保存完然后执行 4、 可以查看阶段视图 视图里打印的日志
扩展： 修改--执行下面的脚本 pipeline { //在任何可用的代理节点上运行 agent any stages { // 具体的构建步骤 // 第一步操作 stage('Hello1') { steps { // 具体的操作，具体的脚本 echo 'Hello World' } } // 第二步操作 stage('Hello2') { steps { // 具体的操作，具体的脚本 echo 'Hello World' } } } } 执行效果 二、了解Pipeline的语法 1、流水线语法 2、通过片段生成器来生成执行命令 生成脚本
3、查看语法结构 4、进行生成 查看自动生成的脚本
将生成的脚本配置到流水线
windows电脑对应的脚本
5） 然后把生成的脚本配置在这里 6）配置完保存执行 7）配置allure报告的命令 将命令配置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53e72cc4153e26898fdca0cbad7de577/" rel="bookmark">
			AIGC专栏13——ComfyUI 插件编写细节解析-以EasyAnimateV3为例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AIGC专栏13——ComfyUI 插件编写细节解析-以EasyAnimateV3为例 学习前言什么是ComfyUI相关地址汇总ComfyUIEasyAnimateV3 节点例子复杂例子-以EasyAnimateV3为例节点文件必要库的导入载入模型节点定义Image to Video节点定义节点名称映射 __init__.py文件插件导入comfyUI 学习前言 最近在给EasyAnimateV3写ComfyUI的工作流，以方便别人测试。学习了ComfyUI的基本操作，也看了一下别人是怎么写的，自己也折腾了一下。
什么是ComfyUI 在人工智能艺术创作的领域里，Stable Diffusion 凭借其开放源代码的特性，吸引了众多开发者与艺术家的目光，并且因为强大的社区支持而展现出强大的影响力。
Stable Diffusion 的两大主流创作平台分别是 Stable Diffusion WebUI 与 ComfyUI。前者以其即装即用的便捷性、丰富的基础功能及广泛的社区插件支持，成为了新手的理想选择。而ComfyUI则更注重算法细节，主要特点是 结合了 工作流和节点，达成更高级别的自动化，使得创作流程更易于复现与传播。不过，这也意味着较高的学习曲线，要求用户对 Stable Diffusion 及其扩展功能有深入理解，动手实践能力亦需达到一定水准。
着眼于未来的工业化生产与效率提升，ComfyUI 显现出更为广阔的潜力与前景。
相关地址汇总 ComfyUI https://github.com/comfyanonymous/ComfyUI
EasyAnimateV3 https://github.com/aigc-apps/EasyAnimate
感谢大家的关注。
节点例子 插件其实本质上是一个个节点，在ComfyUI中，一个节点对应一个类，本文先以ExampleNode为例进行解析，如下所示：
ExampleNode有几个方法，必要是的__init__，INPUT_TYPES和一个FUNCTION 对应的函数。
__init__是python类的通用方法，非必须有内容，所以我们可以先pass。INPUT_TYPES是ComfyUI必须要有的一个方法，需要放在classmethod装饰器下面，在INPUT_TYPES我们可以指定required和optional代表参数是必要的或者可选的。 required和optional均为一个字典，字典的key是这个参数的名称，key对应的value是这个参数的类别，这个类别既可以自定义，也可以用一些通用的，常见通用类别有IMAGE、INT、FLOAT等，具体的设置方法如下的代码所示。FUNCTION对应的函数代表该节点执行的函数，这个函数一般是自定义的，如下所示的example_func，做的工作就是将所有的像素点除以2后+1。 除此之外还需要设置几个变量名：
FUNCTION = "example_func"对应了FUNCTION的函数名RETURN_TYPES = ("IMAGE",)代表这个节点返回的内容类别，常见通用类别有IMAGE、INT、FLOAT等RETURN_NAMES = ("image_output_demo",)代表在UI上显示的节点返回的名称。CATEGORY = "Example"代表这个节点的种类。 class ExampleNode:、 def __init__(self): pass @classmethod def INPUT_TYPES(s): return { "required": { "image_demo": ("IMAGE",), "int_demo": ("INT", { "default": 0, # 默认值 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53e72cc4153e26898fdca0cbad7de577/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6aa79f8f27e7844648a554209e3d9e6/" rel="bookmark">
			如何使用IPython的并行计算能力处理大数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 引言IPython概述 什么是IPythonIPython的特点 并行计算简介 什么是并行计算并行计算的优势 IPython的并行计算功能 IPython.parallel模块IPython并行架构 IPython的安装与配置 安装IPython配置并行环境 IPython并行计算的基础 任务分发与负载均衡核心概念：Client、View、Engine 使用IPython进行并行计算 创建并行客户端使用DirectView和LoadBalancedView并行执行函数 实践案例：处理大数据 数据准备并行计算示例性能优化技巧 高级应用 异步并行任务并行计算中的数据共享故障处理与重启策略 总结 1. 引言 在现代数据科学和大数据处理领域，并行计算是提高计算效率和处理能力的重要技术手段。IPython作为一个强大的交互式计算环境，不仅提供了丰富的工具和库来进行数据分析和可视化，还具备强大的并行计算能力。本文将详细介绍如何使用IPython的并行计算功能来处理大数据，并提供实际操作和优化技巧，帮助初学者快速上手。
2. IPython概述 什么是IPython IPython（Interactive Python）是一个增强型的Python交互式解释器，提供了强大的交互式计算和数据分析功能。它支持语法高亮、自动补全、内联图形显示等特性，是科学计算和数据分析的利器。
IPython的特点 增强的交互式环境：支持语法高亮、自动补全和内联图形显示。强大的魔术命令：提供了一系列便捷的命令，用于系统操作、调试和性能分析。并行计算支持：通过IPython.parallel模块，轻松实现分布式计算。 3. 并行计算简介 什么是并行计算 并行计算是一种计算模型，通过同时执行多个计算任务来提高计算速度和效率。并行计算可以在单个多核处理器上进行，也可以在分布式系统中跨多台机器进行。
并行计算的优势 提高计算速度：多个任务并行执行，显著减少计算时间。扩展处理能力：利用多核处理器和分布式系统，处理更大规模的数据和更复杂的计算任务。提高资源利用率：充分利用系统的计算资源，提高整体效率。 4. IPython的并行计算功能 IPython.parallel模块 IPython.parallel模块是IPython中用于并行计算的核心模块，提供了一套简单而灵活的并行计算接口。通过该模块，用户可以方便地启动并管理多个计算引擎，分发和调度任务。
IPython并行架构 IPython的并行计算架构包括三个核心组件：
Client：客户端，用于提交和管理并行任务。Engine：计算引擎，实际执行并行任务的进程。Scheduler：调度器，负责将任务分发到各个引擎。 5. IPython的安装与配置 安装IPython 安装IPython可以使用pip或conda，具体命令如下：
pip install ipython pip install ipyparallel 或者使用conda：
conda install ipython conda install ipyparallel 配置并行环境 安装完成后，需要配置并行计算环境。首先，生成默认配置文件：
ipython profile create ipython profile create --parallel 然后，启动IPython并行集群：
ipcluster start --n=4 其中，--n=4表示启动4个计算引擎。可以根据需要调整引擎数量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6aa79f8f27e7844648a554209e3d9e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3ed40dec8ce9f8437781d28bceae4fe/" rel="bookmark">
			如何使用Gunicorn配置SSL/TLS加密Web服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何使用Gunicorn配置SSL/TLS加密Web服务 目录 简介SSL/TLS的基本概念 SSL与TLS的区别为什么需要SSL/TLS Gunicorn的简介与安装 什么是Gunicorn安装Gunicorn 生成SSL/TLS证书 自签名证书从受信任的证书颁发机构获取证书 配置Gunicorn使用SSL/TLS 配置文件的使用命令行参数配置 验证SSL/TLS配置 使用浏览器验证使用命令行工具验证 最佳实践与常见问题 安全配置建议常见问题排查 总结 简介 在现代Web服务中，确保数据传输的安全性是至关重要的。SSL（Secure Sockets Layer）和TLS（Transport Layer Security）是用于加密网络通信的协议，能够有效地保护数据传输的安全性。Gunicorn（Green Unicorn）是一个Python WSGI HTTP服务器，广泛用于部署Python Web应用。本文将详细介绍如何在Gunicorn中配置SSL/TLS，加密Web服务以确保数据安全。
SSL/TLS的基本概念 SSL与TLS的区别 SSL和TLS都是用于加密网络通信的协议。SSL是最早开发的加密协议，TLS是SSL的继任者，更加安全和高效。虽然TLS已经取代了SSL，但“SSL”这个术语仍被广泛使用，常常泛指SSL和TLS协议。
为什么需要SSL/TLS 数据加密：防止数据在传输过程中被窃听。数据完整性：确保数据在传输过程中不被篡改。身份验证：确保通信双方的身份真实可信。 Gunicorn的简介与安装 什么是Gunicorn Gunicorn（Green Unicorn）是一个基于Python编写的WSGI HTTP服务器，广泛用于部署Django、Flask等Python Web应用。它简单易用，性能良好，支持多种工作模式和灵活的配置。
安装Gunicorn 在开始配置之前，首先需要安装Gunicorn。可以使用pip进行安装：
pip install gunicorn 安装完成后，可以通过运行以下命令验证安装是否成功：
gunicorn --version 生成SSL/TLS证书 为了使用SSL/TLS加密Web服务，需要一个SSL/TLS证书。证书可以自签名生成，也可以从受信任的证书颁发机构获取。
自签名证书 自签名证书适用于开发和测试环境。使用openssl可以轻松生成自签名证书。
生成私钥： openssl genpkey -algorithm RSA -out private.key 生成证书签名请求（CSR）： openssl req -new -key private.key -out cert.csr 使用私钥和CSR生成自签名证书： openssl x509 -req -days 365 -in cert.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3ed40dec8ce9f8437781d28bceae4fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28a8ae64834e8adc0bbc779cea4f2b6c/" rel="bookmark">
			Redis 的强大之处：为何它成为开发者的首选？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Redis 的强大之处：为何它成为开发者的首选？ 1. 速度极快2. 数据类型多样3. 事务支持4. 特性丰富5、总结 💖The Begin💖点点关注，收藏不迷路💖 Redis，作为开源的内存数据结构存储系统，以其独特优势成为数据处理的得力助手。以下是Redis的几大优势：
1. 速度极快 Redis将数据存储在内存中，类似于HashMap，实现了O(1)的查找和操作时间复杂度，极大提升了数据处理速度。
2. 数据类型多样 支持string、list、set、sorted set、hash等多种数据类型，满足不同复杂场景下的数据存储需求。
3. 事务支持 确保操作的原子性，即一组命令要么全部执行，要么全部不执行，保障数据一致性。
4. 特性丰富 不仅限于缓存，还支持消息队列、过期自动删除等功能，扩展性强。
5、总结 Redis以其高效、灵活和丰富的特性，成为现代应用架构中不可或缺的一部分。无论是提升响应速度、处理复杂数据关系，还是保障数据一致性，Redis都是你的理想选择。
💖The End💖点点关注，收藏不迷路💖 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b3bd3f4f790ed9cbc6c51fa8d6e6b24/" rel="bookmark">
			Redis vs Memcache：哪个更适合你的应用？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Redis vs Memcache：哪个更适合你的应用？ 1、存储与持久化2、数据类型支持3、性能与底层机制4、Value值大小限制5、数据备份与容灾6、总结 💖The Begin💖点点关注，收藏不迷路💖 在缓存技术的选择中，Redis和Memcache是两大备受关注的选项。以下是对它们主要差异的简明对比：
1、存储与持久化 Memcache：
全内存存储，断电即数据丢失。不支持数据持久化，数据仅限于内存生命周期内有效。 Redis：
内存+硬盘存储，兼顾速度与数据安全。支持RDB和AOF两种持久化方式，确保数据不丢失。 2、数据类型支持 Memcache：
仅支持简单的字符串（key-value）类型。 Redis：
支持丰富的数据结构，包括字符串、列表（List）、集合（Set）、有序集合（ZSet）、哈希表（Hash）等。 3、性能与底层机制 Memcache：
基于文本的简单协议，性能良好但功能相对单一。 Redis：
自建VM机制，减少系统调用开销，优化性能。在处理复杂数据结构和大规模并发访问时表现更佳。 4、Value值大小限制 Memcache：
Value值大小一般不超过1MB。 Redis：
Value值大小限制较为宽松，最大可达1GB，适合存储大型数据对象。 5、数据备份与容灾 Memcache：
不支持数据备份，主节点宕机可能导致数据丢失。 Redis：
支持主从复制模式，自动将数据从主节点同步到从节点。实现数据的高可用性和容灾能力。 6、总结 Redis：更适合需要复杂数据结构、数据持久化、高性能读写和数据备份的应用场景。Memcache：则适用于简单的键值存储需求，部署和使用更为轻量级。 💖The End💖点点关注，收藏不迷路💖 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fd4492528f70abd4ca1bdf04435dd91/" rel="bookmark">
			《数据结构：C语言实现单链表》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、单链表1、概念与结构2、结点3、链表的性质 二、实现单链表1、创建单链表的结构体2、头部数据插入3、尾插数据4、头删和尾删数据5、查找数据6、在任意位置之前增加数据7、删除结点8、删除结点之后的结点9、在结点之后插入数据10、销毁链表 三、代码SListNode.hSListNode.c 一、单链表 1、概念与结构 概念：链表是⼀种物理存储结构上⾮连续、⾮顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。
2、结点 单链表与顺序表不同的是，链表的每个空间是独立申请的，称为一个结点。
结点的组成主要由两个部分：当前结点要保存数据和下一个结点的地址（指针变量）。 所以在动态申请空间时使用malloc函数开辟空间就可以了。
3、链表的性质 1、链式机构在逻辑上是连续的，在物理结构上不⼀定连续2、结点⼀般是从堆上申请的3、从堆上申请来的空间，是按照⼀定策略分配出来的，每次申请的空间可能连续，可能不连续 假设当前保存的结点为整形的结构体代码：
struct SListNode { int data; //结点数据 struct SListNode* next; //指针变量⽤保存下⼀个结点的地址 }; 当我们想要保存⼀个整型数据时，实际是向操作系统申请了⼀块内存，这个内存不仅要保存整型数据，也需要保存下⼀个结点的地址（当下⼀个结点为空时保存的地址为空）。
当我们想要从第⼀个结点⾛到最后⼀个结点时，只需要在当前结点拿上下⼀个结点的地址就可以了。
二、实现单链表 1、创建单链表的结构体 创建一个名为SListNode.h的头文件
向SListNode.h输入如下代码：
用typedef 给要存储的数据重命名，也给单链表结构体重命名一个简单的名字SLTNode
2、头部数据插入 创建一个test.c文件用来测试程序
创建一个SListNode.c文件完成函数的定义
把函数声明放置在SListNode.h的头文件中
在test.c文件中进行主函数调用test1()函数进行测试，在test1()中创建一个单链表结构体变量,前提包含了#include"SListNode.h"，完成创建。
test.c:
传址调用，通过地址可以完成形参改变实参
SListNode.h:
传参是一级指针的地址用二级指针接收
SListNode.c:
先断言,保存数据申请空间，在创建一个开辟空间的函数，在开辟空间把要保存的数据传过去保存，空间不连续用malloc开辟
再完成一个打印数据的函数
不是通用的，现在打印的是整形数据
测试成功
3、尾插数据 要考虑两种情况，在一个数据都没有时第一个节点就是首尾结点。
在有数据的情况下，要找到最后一个结点，最后一个结点存放的指针指向的地址为NULL，把这个节点的指针指向为新结点。
4、头删和尾删数据 头删：
尾删：
5、查找数据 使用方法：
查找功能可以返回动态内存的空间，方便我们去在任意位置之前增删，结合使用。
6、在任意位置之前增加数据 test测试：
在数据为5的结点前面插入新结点，要传三个值，第一个是首结点，第二个要在哪个结点之前插入结点，第三个插入的数据值。
代码实现：
思路在开辟新结点，需要用首结点找到插入结点之前的结点，让之前结点指向新结点，新结点指向被插入的结点。
特殊情况在被插入数据结点是首结点时，前面没有结点，直接调用头插。
7、删除结点 同样是用查询找到被删数据的结点在进行调用函数删除。
8、删除结点之后的结点 9、在结点之后插入数据 10、销毁链表 三、代码 SListNode.h #pragma once #include&lt;stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fd4492528f70abd4ca1bdf04435dd91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed99fa26773a6945064ee016e2211b65/" rel="bookmark">
			【C&#43;&#43;】：继承[下篇](友元&amp;&amp;静态成员&amp;&amp;菱形继承&amp;&amp;菱形虚拟继承)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一，继承与友元二，继承与静态成员三，复杂的菱形继承及菱形虚拟继承四，继承的总结和反思 点击跳转上一篇文章： 【C++】：继承(定义&amp;&amp;赋值兼容转换&amp;&amp;作用域&amp;&amp;派生类的默认成员函数) 一，继承与友元 友元关系不能继承，也就是说基类友元不能访问子类私有和保护成员 。
二，继承与静态成员 基类定义了static静态成员，则整个继承体系里面只有一个这样的成员。无论派生出多少个子类，都只有一个static成员实例 。
class Person { public: Person() { ++_count; } protected: string _name; // 姓名 public: static int _count; // 统计人的个数。 }; int Person::_count = 0; class Student : public Person { protected: int _stuNum; // 学号 }; int main() { Person p; Student s; cout &lt;&lt; &amp;Person::_count &lt;&lt; endl; cout &lt;&lt; &amp;Student::_count &lt;&lt; endl; return 0; } 在上述代码中，此时Student和Person里面的_count是同一个，静态变量_count存在静态区,不是单独的存在各个对象里，是属于整个继承体系了。
三，复杂的菱形继承及菱形虚拟继承 1.单继承：一个子类只有一个直接父类时称这个继承关系为单继承。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed99fa26773a6945064ee016e2211b65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a7b57aed44e9e32042e55fa4d10a33c/" rel="bookmark">
			Java Reactive Streams Backpressure mechanisms
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OverView Backpressure mechanism is a critical concept in Reactive Streams, used to manage the rate difference between data producers and consumers, ensuring system resources are not excessively consumed. By controlling the flow of data, backpressure prevents consumers from being overwhelmed by data, thereby ensuring system stability and efficiency. Here is a detailed explanation of the backpressure mechanism
Core Idea of Backpressure Mechanism In asynchronous data processing systems, producers and consumers often have different processing speeds.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a7b57aed44e9e32042e55fa4d10a33c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94881bfdc65e636a14f4521f06e7d8c6/" rel="bookmark">
			合合信息“大模型加速器”亮相2024世界人工智能大会
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 📑引言一、大模型发展的挑战数据稀缺问题 二、大模型“加速器”解决方案概述文档解析引擎的特征 三、文档解析引擎的优势3.1 高速处理能力3.2 智能理解文档结构3.3 多种数据类型支持3.4 高精度数据提取3.5 应用广泛，适应性强 四、复杂图表解析4.1 图表解析能力4.2 图表解析的应用实例 五、acge模型的导航作用六、与行业巨头合作6.1 合作探索技术新范式6.2 助力大模型接轨“专业课” 七、个人感言 📑引言 2024年7月4日世界人工智能大会在上海隆重举行。当前，中国大模型技术的迅猛发展引发了“百模大战”，成为业界关注的焦点。如何在信息的海洋中帮助大模型找到航向，如何在数据稀缺的环境中找到高质量的“水源”，这些问题引发了广泛讨论。合合信息在本次大会上展示了其最新的大模型“加速器”解决方案，针对这些挑战提供了前沿技术支持。
一、大模型发展的挑战 数据稀缺问题 当前，大模型的数据集主要以英文为主，中文语料占比较低。这一情况使得中文大模型的发展面临语料短缺的问题，难以满足高质量训练的需求。此外，复杂文档元素（如无线表、跨页表格、复杂公式等）的处理也成为大模型语料处理中的一大难题。
二、大模型“加速器”解决方案概述 合合信息的大模型“加速器”旨在优化大模型在训练和应用过程中的数据处理效率和准确性，为模型提供高质量的“燃料”，从而加速大模型的发展和应用。
文档解析引擎的特征 文档解析引擎主要解决书籍、论文、研报等文档的版面解析问题。它能够突破传统方法的限制，迅速而准确地处理各种复杂文档格式，为大模型提供结构化的数据输入。
高效解析速度：文档解析引擎可以在1.5秒内解析百页长的文档，涵盖文本、表格、图像等非结构化数据。智能还原阅读顺序：引擎能够智能还原文档的阅读顺序，确保数据处理的正确性和连贯性。多种数据类型支持：支持文本、表格、图像等多种数据类型的解析，能够处理复杂的文档结构。 三、文档解析引擎的优势 3.1 高速处理能力 合合信息的文档解析引擎以其卓越的处理速度独树一帜。它能够在1.5秒内解析百页长的文档，无论是文本、表格，还是图像数据，这一引擎都能高效处理，极大地提升了大模型的训练效率。
3.2 智能理解文档结构 不仅速度快，合合信息的文档解析引擎还具备智能理解文档结构的能力。它能够还原文档的阅读顺序，确保大模型在预训练、开发和应用过程中，能够准确理解和处理输入数据。这种智能理解文档结构的能力，对于处理含有复杂表格、跨页数据以及混合图像的文档尤为重要。
3.3 多种数据类型支持 合合信息的文档解析引擎不仅能处理纯文本，还支持对表格、图像等多种数据类型的解析。它能够处理复杂的文档结构，为大模型提供多维度的训练数据。
3.4 高精度数据提取 合合信息的文档解析引擎在数据提取精度上也表现卓越。它能够从复杂文档中高精度提取关键数据，确保数据的完整性和准确性。
3.5 应用广泛，适应性强 合合信息的文档解析引擎适用于多个行业领域，包括金融、医学、法律、媒体等。
四、复杂图表解析 在金融报表、行业报告等高知识密度的文档中，图表数据往往是关键信息的集中体现。合合信息的文档解析引擎具备卓越的图表解析能力，能够准确还原表格和图表的内容，为大模型提供高质量的结构化数据输入。
4.1 图表解析能力 合合信息的文档解析引擎在图表解析方面展现了出色的能力。它不仅能够解析常见的柱状图、折线图、饼图、雷达图等图表，还能将其内容转化为大模型能理解的Markdown格式。
深度洞察图表内容：解析引擎能够对研报、论文等文档中的复杂图表进行精准还原。例如，在金融行业的年报中，复杂的财务数据和趋势图表通过解析引擎的处理，可以转换成结构化的数据，为大模型的分析和预测提供准确的基础。高效学习理解：大模型通过解析引擎获取图表的原始结构化数据，能够高效学习和理解商业研报和学术论文中的逻辑。这提升了大模型的语言理解、数据处理和知识推理分析的效率和准确性。 4.2 图表解析的应用实例 金融行业：在金融报表中，合合信息的解析引擎能够准确还原各种财务数据图表，为大模型的财务分析提供可靠的数据支持。通过对财务数据的深度解析，模型可以进行更精准的财务预测和风险评估。科研领域：在科研报告和论文中，复杂的实验数据和统计图表通过解析引擎的处理，能够被大模型有效理解和学习。这使得大模型在科学研究中的应用更加广泛和深入，能够更好地辅助科研人员进行数据分析和结论验证。市场分析：市场分析报告中大量的市场趋势图表和数据，通过文档解析引擎，可以快速转化为模型能理解的结构化数据，帮助企业更准确地进行市场预测和策略制定。 五、acge模型的导航作用 acge模型通过对大量中文文本数据的深入学习，有效提取文本特征，为大模型提供精准的导航支持，减少“幻觉”发生，提升回答问题的准确性和针对性。
高效文本特征提取
acge模型能够从海量文本中提取高质量的特征，帮助大模型快速定位重要信息，在分类和聚类任务中表现出色。模型不仅能够高效处理信息检索和分类任务，还通过持续学习机制，克服了传统神经网络的遗忘问题，为各行各业的大模型智能化升级提供强大的推动力。
六、与行业巨头合作 6.1 合作探索技术新范式 在表格内容还原、复杂样本处理、多语言文档识别等方面，合合信息的大模型“加速器”具备高准确性和稳定性，为多个行业提供了高效、准确的文档解析服务。合合信息与百川智能等行业巨头携手，穿透双栏、多栏、表格、图片等复杂的版式，从金融、社科等多领域文档图像中快速提取关键信息，精准回答用户的专业问题。
6.2 助力大模型接轨“专业课” 合合信息智能创新事业部总经理唐琪提到，目前，大模型“加速器”已被多家大模型厂商应用于金融、医学、财经、媒体等多领域的文档解析中，助力大模型更顺利地接轨“专业课”。“加速器”不仅是一套技术工具，更是推动行业专业知识管理革新、提升业务效率的重要基石。未来，合合信息的大模型“加速器”将继续陪伴更多行业级知识库的建立，让大模型的服务润泽社会各个角落，实现“智能触手可及”。
七、个人感言 合合信息的“大模型加速器”在2024世界人工智能大会上的亮相，展示了其在文档解析和文本向量化领域的前沿技术，真的人眼前一亮。通过提供高效的文档解析引擎和acge文本向量化模型，合合信息为大模型的发展注入了新的动力。我相信在未来，合合信息会继续致力于技术创新，将为各行业提供高效、精准的智能化解决方案，推动大模型技术在各个领域的应用和发展。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f841e48913caef50a92f136bdc1af7e/" rel="bookmark">
			未来已来？国内11家AI大模型盘点（附体验网址）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		名人说：莫道桑榆晚，为霞尚满天。——刘禹锡（刘梦得，诗豪）
创作者：Code_流苏(CSDN)（一个喜欢古诗词和编程的Coder😊）
目录 1、阿里云——通义千问2、科大讯飞——星火大模型3、百度——文心一言4、字节跳动——豆包5、智谱华章——智谱清言6、华为云——盘古7、百川智能——百川大模型8、腾讯——混元9、商汤——商量SenseChat10、MiniMax——abab611、月之暗面——Kimi 很高兴你打开了这篇博客，更多好用的AIGC工具，请关注我与专栏《实用软件与高效工具》，内容持续更新中…
大家好，今天我们来盘点一下国内主流的11个AI大模型，看看它们各自的特点和体验网址。
使用方法：只需要在输入框中输入你想问的问题、想知道的信息等，即可快速上手使用。
1、阿里云——通义千问 网址：https://tongyi.aliyun.com/
简介：阿里达摩院推出的大模型，拥有千亿参数，可用于智能问答、知识检索、文案创作等场景。
演示：写一首赞美春天的诗歌
2、科大讯飞——星火大模型 网址：https://xinghuo.xfyun.cn/desk
简介：科大讯飞推出的AI大模型，支持对话、写作、编程等功能，还能提供语音交互方式。
演示：鲁迅和周树人有什么区别？
3、百度——文心一言 网址：https://yiyan.baidu.com/welcome
简介：百度推出的知识增强型对话语言模型，千亿级参数量，在知识问答、创意生成等任务上表现出色。
演示：使用python获取excel中sheet的样式
4、字节跳动——豆包 网址：https://www.doubao.com/
简介：字节跳动为创作者打造的AI助手，支持视频脚本撰写、文案生成、营销策划等，大大提高创作效率。
演示：简要讲一下三体第一部的故事
5、智谱华章——智谱清言 网址：https://chatglm.cn/main/alltoolsdetail
简介：智谱华章自研的AI大模型，融合海量知识，可用于商业分析、决策辅助、客户服务等领域。
演示：什么是压岁钱？压岁钱的由来
6、华为云——盘古 网址：https://pangu.huaweicloud.com/
简介：华为诺亚方舟实验室研发的大模型，在中英文理解、多轮对话、常识推理等方面有优异表现。
目前仅对企业用户申请开放，尚未开启公测，大家如果在公司就职，可以去申请体验一下。
7、百川智能——百川大模型 网址：https://www.baichuan-ai.com/chat
简介：前搜狗公司CEO王小川创立，发布了Baichuan-7B、Baichuan-13B两款开源可免费商用的中文大模型，且在多个权威评测榜单均名列前茅，下载量突破百万。
演示：写一部科幻主题的小说，寻求建议
8、腾讯——混元 网址：https://hunyuan.tencent.com/bot/chat
简介：腾讯AI Lab自研的大规模预训练生成语言模型，擅长开放域聊天、内容创作、知识问答等。
演示：列举登山必备品并制成表格
9、商汤——商量SenseChat 网址：https://sensechat.sensetime.com/
简介：商汤科技推出的多模态对话交互平台，利用视觉、语言等技术，提供沉浸式人机交互体验。
演示：母亲节祝福短信
10、MiniMax——abab6 网址：https://minimax.chat/
简介：MiniMax打造的实验性AI伙伴，拥有强大的对话能力和广泛的知识储备，适合开放性探索和创意激发。
演示：帮我写一下关于春天的文案
这一个大模型相比于前面的使用稍有不同，偏向于定制助手，不过也是在框中输入信息获取回答。
11、月之暗面——Kimi 网址：https://kimi.moonshot.cn//
简介：最近爆火的一款AI大模型，处理长文本很强，特长生，联网搜索能力也不错。
演示：夏天天气很热，该怎么避暑？
以上就是国内目前主流AI大模型的简要介绍，它们各具特色，在不同领域发挥着重要作用。随着人工智能的不断发展，相信未来会有更多优秀的大模型涌现，为我们的生活和工作带来更多便利和惊喜，让我们共同期待AI技术的进一步突破和应用！
很感谢你能看到这里，如果你有哪些值得推荐的AI模型，欢迎在评论区分享你正在使用的AIGC！
创作者：Code_流苏(CSDN)（一个喜欢古诗词和编程的Coder😊）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8a33538326dd49363c1e9e33ecabfd7/" rel="bookmark">
			[安洵杯 2019]easy_web1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		知识点：
1.base64加解密
2.md5加解密
3.md5碰撞绕过强类型比较
4.Linux命令绕过
进入页面发现url地址中存在 img参数和一个cmd参数，img参数看上去像是base64编码，可以去尝试一下解码.
进行了两次base64解密得到3535352e706e67看着像16进制那么在进行一次十六进制字符串转换得到555.png,像是文件读取漏洞.
我们可以尝试读取index.php的内容,对index.php进行一次16进制转换在进行2次base64加密
最终得到结果为TmprMlpUWTBOalUzT0RKbE56QTJPRGN3
开始构造payload
http://2f95244f-7628-48a4-ba7d-3dc585b47cfd.node5.buuoj.cn:81/index.php?img=TmprMlpUWTBOalUzT0RKbE56QTJPRGN3&amp;cmd= PD9waHAKZXJyb3JfcmVwb3J0aW5nKEVfQUxMIHx8IH4gRV9OT1RJQ0UpOwpoZWFkZXIoJ2NvbnRlbnQtdHlwZTp0ZXh0L2h0bWw7Y2hhcnNldD11dGYtOCcpOwokY21kID0gJF9HRVRbJ2NtZCddOwppZiAoIWlzc2V0KCRfR0VUWydpbWcnXSkgfHwgIWlzc2V0KCRfR0VUWydjbWQnXSkpIAogICAgaGVhZGVyKCdSZWZyZXNoOjA7dXJsPS4vaW5kZXgucGhwP2ltZz1UWHBWZWs1VVRURk5iVlV6VFVSYWJFNXFZejAmY21kPScpOwokZmlsZSA9IGhleDJiaW4oYmFzZTY0X2RlY29kZShiYXNlNjRfZGVjb2RlKCRfR0VUWydpbWcnXSkpKTsKCiRmaWxlID0gcHJlZ19yZXBsYWNlKCIvW15hLXpBLVowLTkuXSsvIiwgIiIsICRmaWxlKTsKaWYgKHByZWdfbWF0Y2goIi9mbGFnL2kiLCAkZmlsZSkpIHsKICAgIGVjaG8gJzxpbWcgc3JjID0iLi9jdGYzLmpwZWciPic7CiAgICBkaWUoInhpeGnvvZ4gbm8gZmxhZyIpOwp9IGVsc2UgewogICAgJHR4dCA9IGJhc2U2NF9lbmNvZGUoZmlsZV9nZXRfY29udGVudHMoJGZpbGUpKTsKICAgIGVjaG8gIjxpbWcgc3JjPSdkYXRhOmltYWdlL2dpZjtiYXNlNjQsIiAuICR0eHQgLiAiJz48L2ltZz4iOwogICAgZWNobyAiPGJyPiI7Cn0KZWNobyAkY21kOwplY2hvICI8YnI+IjsKaWYgKHByZWdfbWF0Y2goIi9sc3xiYXNofHRhY3xubHxtb3JlfGxlc3N8aGVhZHx3Z2V0fHRhaWx8dml8Y2F0fG9kfGdyZXB8c2VkfGJ6bW9yZXxiemxlc3N8cGNyZXxwYXN0ZXxkaWZmfGZpbGV8ZWNob3xzaHxcJ3xcInxcYHw7fCx8XCp8XD98XFx8XFxcXHxcbnxcdHxccnxceEEwfFx7fFx9fFwofFwpfFwmW15cZF18QHxcfHxcXCR8XFt8XF18e3x9fFwofFwpfC18PHw+L2kiLCAkY21kKSkgewogICAgZWNobygiZm9yYmlkIH4iKTsKICAgIGVjaG8gIjxicj4iOwp9IGVsc2UgewogICAgaWYgKChzdHJpbmcpJF9QT1NUWydhJ10gIT09IChzdHJpbmcpJF9QT1NUWydiJ10gJiYgbWQ1KCRfUE9TVFsnYSddKSA9PT0gbWQ1KCRfUE9TVFsnYiddKSkgewogICAgICAgIGVjaG8gYCRjbWRgOwogICAgfSBlbHNlIHsKICAgICAgICBlY2hvICgibWQ1IGlzIGZ1bm55IH4iKTsKICAgIH0KfQoKPz4KPGh0bWw+CjxzdHlsZT4KICBib2R5ewogICBiYWNrZ3JvdW5kOnVybCguL2JqLnBuZykgIG5vLXJlcGVhdCBjZW50ZXIgY2VudGVyOwogICBiYWNrZ3JvdW5kLXNpemU6Y292ZXI7CiAgIGJhY2tncm91bmQtYXR0YWNobWVudDpmaXhlZDsKICAgYmFja2dyb3VuZC1jb2xvcjojQ0NDQ0NDOwp9Cjwvc3R5bGU+Cjxib2R5Pgo8L2JvZHk+CjwvaHRtbD4= 将读取到的内容进行base64解码~
&lt;?php // 开启错误报告，但忽略E_NOTICE级别的错误 error_reporting(E_ALL || ~E_NOTICE); // 设置内容类型为HTML，并指定字符集为UTF-8 header('content-type:text/html;charset=utf-8'); // 从GET请求中获取cmd参数 $cmd = $_GET['cmd']; // 检查是否同时设置了img和cmd参数，如果没有，则重定向回index.php并附带默认的img和空的cmd参数 if (!isset($_GET['img']) || !isset($_GET['cmd'])) { header('Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd='); exit; // 加上exit防止后续代码执行 } // 对GET请求中的img参数进行两次base64解码，然后hex2bin转换 $file = hex2bin(base64_decode(base64_decode($_GET['img']))); // 使用正则表达式清理$file变量，只保留字母、数字和小数点 $file = preg_replace("/[^a-zA-Z0-9.]+/", "", $file); // 检查清理后的$file变量是否包含'flag'字符串，如果包含，则显示一张图片并终止执行 if (preg_match("/flag/i", $file)) { echo '&lt;img src ="./ctf3.jpeg"&gt;'; die("xixiï½ no flag"); } else { // 读取$file指向的文件内容，将其base64编码，并嵌入到HTML中以图片形式显示 // 注意：这里假设文件是GIF格式，但实际上可能不是，这可能导致浏览器无法正确显示图片 $txt = base64_encode(file_get_contents($file)); echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8a33538326dd49363c1e9e33ecabfd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf32eb00e49b68550d3a24169111f740/" rel="bookmark">
			Laravel生成二维码图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Laravel生成二维码图片 composer下载组件 https://github.com/SimpleSoftwareIO/simple-qrcode/tree/develop/docs/zh-cn
composer require simplesoftwareio/simple-qrcode "~2" namespace App\Http\Controllers; use SimpleSoftwareIO\QrCode\Facades\QrCode; class HomeController extends Controller { public function hello(){ return "laravel7"; } public function generatePicture() { $res= QrCode::format('png')-&gt;margin(1)-&gt;size(399)-&gt;color(40,40,40)-&gt;generate('Make me a QrCode!'); return response()-&gt;make($res)-&gt;header('Content-Type','image/png'); } } Route::get('home/generatePicture','HomeController@generatePicture'); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cfaadbf901090ff88614802cbe220ac/" rel="bookmark">
			实用机器学习（快速入门）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 因为需要机器学习的助力，所以（浅浅）进修了一下。现在什么东西和AI结合一下感觉就好发文章了；我看了好多学习视频，发现机器学习实际上是数学，并不是常规的去学习代码什么的（虽然代码也很简单），而是去学习原理。这其实并不合我的学习方法，所以我歪门邪道了一下，先实用，再搞原理（这样就比原先快了许多）
这里我比较推荐的唯一的一本书籍是统计学习方法（因为这本书我大概可以看懂，其他方面的书籍都不太适合纯新手）
线性模型（感知机） 直接上代码，通过代码来上手机器学习
import time import numpy as np import matplotlib.pyplot as plt from sklearn.model_selection import train_test_split from sklearn.linear_model import LinearRegression from sklearn.metrics import mean_squared_error # 使用numpy库，随机创建一个数据集 np.random.seed(int(time.time())) x = 2 * np.random.rand(100, 1) y = 4 + 3 * x + np.random.rand(100, 1) # 将数据集进行划分，分为训练集、测试集 X_train, X_test, y_train, y_test = train_test_split(x, y, test_size=0.2,random_state=42) # 创建线性模型，并开始拟合数据（即训练） lin_reg = LinearRegression() lin_reg.fit(X_train, y_train) print("lin_reg.coef_ ",lin_reg.coef_) # 决策函数的系数 print("lin_reg.intercept_ ", lin_reg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cfaadbf901090ff88614802cbe220ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48665ea06f628c456dadba8c23187cf1/" rel="bookmark">
			前端练习小项目——方向感应名片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：在学习完HTML和CSS之后，我们就可以开始做一些小项目了，本篇文章所讲的小项目为——方向感应名片
✨✨✨这里是秋刀鱼不做梦的BLOG
✨✨✨想要了解更多内容可以访问我的主页秋刀鱼不做梦-CSDN博客
在开始学习之前，先让我们看一下最终效果：
那么我们如何去实现这样的小案例呢？在下文中我们对每一段重要的代码都进行了解释，读者可以根据注释对代码进行理解。
1.HTML代码 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;fish&lt;/title&gt; &lt;!-- 设置页面标题为fish --&gt; &lt;link rel="stylesheet" href="./test.css"&gt; &lt;!-- 引入外部CSS样式表 --&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="shell"&gt; &lt;!-- 外层容器 --&gt; &lt;div class="box"&gt; &lt;!-- 盒子容器 --&gt; &lt;div class="images"&gt; &lt;!-- 图片容器 --&gt; &lt;img src="./item1.jpg"&gt; &lt;!-- 显示item1.jpg图片 --&gt; &lt;/div&gt; &lt;div class="content"&gt; &lt;!-- 内容容器 --&gt; &lt;h2&gt;ZeenChin&lt;/h2&gt; &lt;!-- 标题为ZeenChin --&gt; &lt;p&gt;The style in the painting integrates temptation, fantasy and strangeness &lt;/p&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48665ea06f628c456dadba8c23187cf1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e9015d648f5d3acd461361f13c1c675/" rel="bookmark">
			【Django&#43;Vue3 线上教育平台项目实战】构建高效线上教育平台之首页模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、导航功能实现a.效果图：b.后端代码c.前端代码 二、轮播图功能实现a.效果图b.后端代码c.前端代码 三、标签栏功能实现a.效果图b.后端代码c.前端代码 四、侧边栏功能实现1.整体效果图2.侧边栏功能实现a.效果图b.后端代码c.前端代码 3.侧边栏展示分类及课程信息功能实现a.效果图b.后端代码c.前端代码 五、分类课程推荐（楼层设计）功能实现a.效果图b.后端代码c.前端代码 前言 在当今数字化教育浪潮中，构建一个高效且用户友好的线上教育平台至关重要。本博客将指导您使用Django作为后端框架，结合Vue 3的强大前端能力，快速搭建平台首页的核心功能，包括导航栏、轮播图、侧边栏、标签栏及分类课程推荐。我们将探讨前后端数据交互、Vue组件化开发等关键技术，轻松构建出既美观又实用的线上教育平台。
最终实现效果图如下：
一、导航功能实现 a.效果图： b.后端代码 导航表模型类：
class NavigationModel(BaseModel): name = models.CharField(max_length=100) url = models.CharField(max_length=100) is_url = models.BooleanField(default=False) def __str__(self): return self.name class Meta: verbose_name = '导航表' verbose_name_plural = '导航表' db_table = 'navigation' 导航表序列化器：
class NavigationSerializer(serializers.ModelSerializer): class Meta: model = NavigationModel fields = ('id','name','url','is_url') # fields = '__all__' 获取所有头部导航栏信息:
class NavigationView(APIView): def get(self, request): nav_list = NavigationModel.objects.all() ser = NavigationSerializer(nav_list, many=True) return Response({"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e9015d648f5d3acd461361f13c1c675/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/656328096529561edefd92eb7fa1be96/" rel="bookmark">
			【香橙派】Orange pi AIpro开发板评测，看小白如何从0到1快速入门，以及亲测手写数字识别模型训练与推理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为业界首款基于昇腾深度研发的AI开发板，Orange Pi AIpro无论在外观上、性能上还是技术服务支持上都非常优秀。
接口丰富，扩展能力强。支持Ubuntu、openEuler操作系统，满足大多数AI算法原型验证、推理应用开发的需求。
目录 开发板介绍亮点顶层视图底层试图 开发板使用准备配件相关资料启动设置烧录镜像上电连接wifi查看IPSSH连接可视化界面 体验AI应用登录juypter lab运行文字识别样例 手写数字识别模型训练&amp;推理样例介绍样例下载执行准备模型训练在线推理 测评感受使用香橙派开发板体会AI应用数据训练体会 总结 开发板介绍 亮点 作为业界首款基于昇腾深度研发的AI开发板，Orange Pi AIpro无论在外观上、性能上还是技术服务支持上都非常优秀。采用昇腾AI技术路线，集成图形处理器，拥有8GB/16GB LPDDR4X，可以外接32GB/64GB/128GB/256GB eMMC模块，支持双4K高清输出，8/20 TOPS AI算力。
其丰富的接口更是赋予了Orange Pi AIpro强大的可拓展性。包括两个HDMI输出、GPIO接口、Type-C电源接口、支持SATA/NVMe SSD 2280的M.2插槽、TF插槽、千兆网口、两个USB3.0、一个USB Type-C 3.0、一个Micro USB、两个MIPI摄像头、一个MIPI屏等，预留电池接口。
在操作系统方面，Orange Pi AIpro支持Ubuntu、openEuler操作系统，满足大多数AI算法原型验证、推理应用开发的需求，可广泛适用于AI边缘计算、深度视觉学习及视频流AI分析、视频图像分析、自然语言处理、智能小车、机械臂、人工智能、无人机、云计算、AR/VR、智能安防、智能家居等领域，覆盖 AIoT各个行业。
顶层视图 底层试图 开发板使用 准备配件 对于首次使用的小白来说，一开始可能没有那么多配件，TF卡、TF读卡器、散热器、HDMI显示器连接线、串口测试线等。
相关资料 博主是一名硬件小白，虽然有接触过几次，但都是一些皮毛。
非常感谢香橙派平台提供的这次机会，并且用户手册讲解的非常详细，帮了很大的忙。
开发板资料下载页面的链接如下所示：
http://www.orangepi.cn/html/hardWare/computerAndMicrocontrollers/service-and-support/Orange-Pi-AIpro.html
启动设置 TF卡启动设置，两个按钮都拨到右边。
开发板背面也有指示，非常方便
烧录镜像 博主是在windows操作系统环境下进行的操作
1、电脑读卡
把 TF 卡插入读卡器，再把读卡器插入电脑
2、balenaEtcher烧录
balenaEtcher：https://www.balena.io/etcher/
烧录中（第一次接触难免有些小激动，很快就可以开启我的硬件之旅），烧录过程大概二十分钟左右
烧录镜像校验和验证，验证大概也是十来分钟（可跳过此步骤）
3、推荐烧录工具
推荐一个比较好用的烧录工具，无需验证，如果上一步骤无法烧录或者验证成功，可以使用下面这个。
地址：https://ascend-repo.obs.cn-east-2.myhuaweicloud.com/Atlas%20200I%20DK%20A2/DevKit/tools/latest/Ascend-devkit-imager_latest_win-x86_64.exe
上电 完成上面烧录步骤，就可以上电，开机启动。
由于最近回老家了，还好镇上都有读卡器、HDMI数据线等配件。
没有条件就创造条件，显示器就用电视机凑合着用。
果然没让我失望，顺利显示出了OrangePI系统界面，这入门体验棒极了。
这个开发板可以理解为一个主机，就像一个台式电脑主机一样，也可以接鼠标、键盘和显示器。
TF卡就是一个硬盘，可以在上面安装操作系统。
连接wifi 成功启动OrangePI后，默认是没有联网的，支持wifi无线联网。
查看IP 完成wifi联网后，即可查看到当前开发板所在局域网IP，目的是通过XShell进行SSH远程连接登录。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/656328096529561edefd92eb7fa1be96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6aba13864fdff4edc80a65dada514b26/" rel="bookmark">
			用 Kotlin 编写四则运算计算器：从零开始的简单教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人不走空 🌈个人主页：人不走空 💖系列专栏：算法专题 ⏰诗词歌赋：斯是陋室，惟吾德馨 目录
🌈个人主页：人不走空 💖系列专栏：算法专题
⏰诗词歌赋：斯是陋室，惟吾德馨
为什么选择 Kotlin？
需求分析 📝
实现步骤 🚀
1. 设置输入循环
2. 输入第一个数字
3. 输入运算符
4. 输入第二个数字
5. 执行计算并显示结果
完整代码 🌟
小结 ✨
作者其他作品：
在现代编程中，掌握一门编程语言的基础知识至关重要。今天我们将通过一个简单的项目——编写一个四则运算计算器，来学习和实践 Kotlin 语言的基础。这个项目不仅适合初学者，还可以帮助你巩固对 Kotlin 基本语法的理解。准备好了吗？让我们开始吧！
为什么选择 Kotlin？ Kotlin 是一种现代、简洁且强大的编程语言，兼容 Java，并在 Android 开发中广泛使用。其简洁的语法和丰富的功能使得它成为开发各种应用程序的理想选择。从简单的计算器程序入手，可以帮助你快速上手 Kotlin。
需求分析 📝 我们要实现的计算器需要具备以下功能：
提示用户输入第一个数字。提示用户输入运算符（+、-、*、/）。提示用户输入第二个数字。根据用户输入的运算符，进行相应的四则运算。显示计算结果。 实现步骤 🚀 让我们一步一步来实现这个计算器。
1. 设置输入循环 首先，我们需要一个循环来不断接受用户的输入，这样用户可以进行多次计算。
fun main() { while (true) { // 后续代码将在这里编写 } } 2. 输入第一个数字 提示用户输入第一个数字，并将其转换为 Double 类型。如果输入无效，提示重新输入。
print("请输入第一个数字: ") val num1 = readLine()?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6aba13864fdff4edc80a65dada514b26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b4e8919b52dd9fd69e25c13179e55e4/" rel="bookmark">
			Spring Boot中的 6 种API请求参数读取方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Spring Boot开发API的时候，读取请求参数是服务端编码中最基本的一项操作，Spring Boot中也提供了多种机制来满足不同的API设计要求。
接下来，就通过本文，为大家总结6种常用的请求参数读取方式。如果你发现自己知道的不到6种，那么赶紧来查漏补缺一下。如果你知道的不止6种，那么告诉大家，一起互相学习一下吧～
@RequestParam 这是最最最最最最常用的一个了吧，用来加载URL中?之后的参数。
比如：这个请求/user?name=didispace 就可以如下面这样，使用@RequestParam来加载URL中的name参数
@GetMapping("/user") @ResponseBody() public User findUserByName(@RequestParam("name") String name){ return userRepo.findByName(name); } @PathVariable 这是RESTful风格API中常用的注解，用来加载URL路径中的参数
比如：这个请求/user/1 就可以如下面这样，使用@PathVariable来加载URL中的id参数
@GetMapping("/user/{id}") @ResponseBody() public User findUserById(@PathVariable("id") String id){ return userRepo.findById(id); } @MatrixVariable 这个我们用的并不是很多，但一些国外系统有提供这类API参数，这种API的参数通过;分割。
比如：这个请求/books/reviews;isbn=1234;topN=5; 就可以如下面这样，使用@MatrixVariable来加载URL中用;分割的参数
@GetMapping("/books/reviews") @ResponseBody() public List&lt;BookReview&gt; getBookReviews( @MatrixVariable String isbn, @MatrixVariable Integer topN) { return bookReviewsLogic.getTopNReviewsByIsbn(isbn, topN); } @RequestBody 这也是最常用的一个注解，用来加载POST/PUT请求的复杂请求体（也叫：payload）。比如，客户端需要提交一个复杂数据的时候，就要将这些数据放到请求体中，然后服务端用@RequestBody来加载请求体中的数据
@PostMapping("/add") public boolean addAccounts(@RequestBody List&lt;Account&gt; accounts) throws SQLException { accounts.stream().forEach(a -&gt; { a.setCreatedOn(Timestamp.from(Instant.now())); a.setLastLogin(Timestamp.from(Instant.now())); }); return notificationLogic.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b4e8919b52dd9fd69e25c13179e55e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8500f6dc5dd4631b07a8d98d486f1189/" rel="bookmark">
			SQL Server 创建用户并授权
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建用户前需要有一个数据库，创建数据库命令如下：
CREATE DATABASE [数据库名称];
CREATE DATABASE database1; 一、创建登录用户 方式1：SQL命令 命令格式：CREATE LOGIN [用户名] WITH PASSWORD = '密码';
例如，创建登录用户名sa1，密码123456 的用户，命令如下：
CREATE LOGIN [sa1] WITH PASSWORD = '123456' 方式2：使用SSMS创建 选择管理员账户--【安全性】--【登录名】--右键--【新建登录名】
二、数据库中创建用户 方式1：SQL命令 命令格式：USE [数据库名称];
CREATE USER [用户名] FOR LOGIN [用户名];
例如，在数据库BLSH中创建用户sa1，命令如下：
USE BLSH CREATE USER sa1 方式2：使用SSMS创建 选择要创建用户的数据库--【安全性】--【用户】--右键--【新建用户】
例如，在数据库test中创建用户sa1，操作如下：
三、给用户授权 方式1：SQL命令 使用 GRANT 命令来授予相应的权限，使用REVOKE命令来撤销相应的权限
授权对表的 SELECT, INSERT, UPDATE 和 DELETE 权限格式：
USE [数据库名称];
GRANT [权限] ON [表名] TO [用户名];
-- 授权对表的 SELECT, INSERT, UPDATE 和 DELETE 权限 GRANT SELECT, INSERT, UPDATE, DELETE ON dt_users TO sa1; -- 对存储过程授予执行权限 GRANT EXECUTE ON YourStoredProcedure TO sa1; -- 撤销对表的 SELECT, INSERT, UPDATE 和 DELETE 权限 REVOKE SELECT, INSERT, UPDATE, DELETE ON dt_users FROM sa1; -- 撤销对存储过程的执行权限 REVOKE EXECUTE ON YourStoredProcedure FROM sa1; -- 撤销创建表的权限 REVOKE CREATE TABLE FROM sa1; -- 撤销创建视图的权限 REVOKE CREATE VIEW FROM sa1; -- 撤销连接数据库的权限 REVOKE CONNECT FROM sa1; -- 查询用户当前权限 SELECT * FROM sys.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8500f6dc5dd4631b07a8d98d486f1189/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/159/">«</a>
	<span class="pagination__item pagination__item--current">160/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/161/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>