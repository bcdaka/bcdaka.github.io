<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34cb2c986f43ba427cbc68f05067f9d2/" rel="bookmark">
			电影类平台如何选择服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电影类平台如何选择服务器
1、数据存储
电影网站对服务器的要求是比较高的，对存储空间的需求特别大，所以在服务器选择上首先要确保足够大的存储空间。另外，当你的网站内容特别多时，内存不够用，可以选择增加内存，这一服务大多数服务商也都是提供的。
2、数据处理
针对电影网站而言，会耗费很多系统资源，其中就包括内存。像是普通规模的电影网站，所必须的内存大约是8G上下，但要是流量比较大的话，就需要16G及以上的内存。另外再选择较好的CPU，比如 E5系列，才能保证较好的运算性能，确保能够处理高并发数据。
3、带宽
电影网站是非常耗流量的，所以充足的带宽就显得尤为重要。现阶段，就一般的电影网站而言，独享100M带宽就足够了，若是网站规模较大，就建议选择不限流量的服务器，以保证用户稳定的访问速度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bceb3da9239b47f4467ac19589f806d/" rel="bookmark">
			【昇腾AI创新大赛集训营南京站学习笔记】-Ascend算子开发课程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昇腾AI创新大赛训练营
14:00-14:30 基础知识-理论课
一、CANN 、达芬奇架构和算子
1.AI Core逻辑架构
达芬奇架构包含三部分：
1）计算类：矩阵计算单元（两个矩阵扔进去相乘）、向量计算单元、标量计算单元
2）控制类：整个计算过程提供了指令控制
3）存储类： 存储单元和数据通路构成了存储系统
AI core是昇腾AI处理器的核心
计算单元包括Vector计算单元、Cube计算单元等
2.计算单元
包含:
1)Scalar计算单元
2）Cube计算单元
异步指令流、同步信号流、计算数据流
数据从AI core并行计算有六条流水线
3.什么是算子-算子在神经网络中的定义
算子对应数学含义：
1）一个函数空间到另一个函数空间的映射，比如微分算子，不定积分算子
常见算子，Relu算子，Sigmoid算子
（计算机不能精确表达根号二，因为精度不够）
算子基本概念-总览
● 算子名称 用于标志网络中的某个算子- Conv1，Conv2
● 算子类型
● 数据容器
4.张量
Tensor用于存储算子输入数据和输出数据的容器，TensorDesc是对输入数据与输出数据的描述。
tensor的shape：（4，20，20，3）
长宽都是20，4张图片，像素点由红、绿、蓝三颜色组成，即数据排布格式
深度学习中，多维数据通过多维数组存储，比如卷积网络中特征图（Feature Map）通常用四维张量来表示
遍历一般是高维到低维进行的
基本概念-轴
轴（Axis):代表张量中维度的下标
shape是（5，6),axis=0表示张量中的第一维
二、实践（昇腾Ascend C快速入门）
指导：
更改ip地址：
远程登陆
实验截图：
1.连接板子
2.查看网络连接：
3.检查ip地址是否修改成功：
4.连接Mobaterm
14:30-16:00 矢量计算-理论课
1.什么是Ascend C算子
什么场景需要开发自定义算子？
一般场景下无需自己开发算子，但若是以下场景，开发者需要考虑自定义算子开发
推理场景，将第三方框架模型使用ATC工具转换为适用昇腾适配器
Device模块
Device负责指定计算运行的真实设备，包含aclrtSetDevice、arlrtResetDevice、aclrtGetDevice、aclrtGetRunMode等众多运行时接口用于进行device管理。
2.如何编写核函数
核函数是Ascend C算子设备侧的一种扩展
编写：使用变量类型限定符
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bceb3da9239b47f4467ac19589f806d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2a0e195c38d3eaade81226ed0e78ee8/" rel="bookmark">
			javascript鼠标跟随星星动画特效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鼠标跟随星星动画特效https://www.bootstrapmb.com/item/14781 创建一个鼠标跟随的星星动画特效在JavaScript中通常涉及到HTML、CSS和JavaScript的结合。以下是一个简单的步骤说明和示例代码，用于创建一个基本的鼠标跟随星星动画：
HTML (index.html) html&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;鼠标跟随星星动画&lt;/title&gt; &lt;link rel="stylesheet" href="styles.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="stars-container"&gt; &lt;!-- 星星将在这里动态生成 --&gt; &lt;/div&gt; &lt;script src="script.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; CSS (styles.css) css#stars-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; pointer-events: none; /* 防止星星阻止鼠标事件 */ } .star { position: absolute; width: 20px; height: 20px; background: yellow; border-radius: 50%; opacity: 0.5; transition: opacity 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2a0e195c38d3eaade81226ed0e78ee8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94b9babb8ddd1112422c40e041273a88/" rel="bookmark">
			Ubuntu20.04版本升级openssh9.8p1方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述： 8.5p1 和 9.7p1 之间的openssh版本漏洞可能会导致linux系统以root身份进行RCE，所以需安装最新版本
二、解决方法： 将当前openssh版本升级到最新的版本即openssh-9.8p1版本，OpenSSL大版本升级且OpenSSH有新稳定版本，建议升级OpenSSL同时也升级OpenSSH
1.安装编译依赖包 apt install gcc make zlib1g-dev libpam0g-dev libkrb5-dev libedit-dev -y 2.先升级openssl,再升级openssh ubuntu20.04 默认openssl版本：OpenSSL 1.1.1f
ssh的版本为：OpenSSH_8.2p1
3.下载OpenSSL 访问openssl官网：[ Downloads ] - /source/index.htmlhttps://www.openssl.org/source/找到最新版本通过wget下载
wget https://www.openssl.org/source/openssl-3.0.13.tar.gz 注意：由于OpenSSL 1.1.x版本已停止维护，ubuntu20.04.x系统建议都使用目前长期支持版
cd /usr/local/src/ tar -zxf openssl-3.0.13.tar.gz cd openssl-3.0.13 ./config shared --prefix=/usr/local/openssl --openssldir=/usr/local/openssl 进行编译和安装
make&amp;&amp;make install 运行一段时间等编译安装完成，完成后执行echo $?显示是否执行成功。
备份原来的openssl
mv /usr/bin/openssl /usr/bin/openssl.bak ln -s /usr/local/openssl/bin/openssl /usr/bin/openssl 将openssl 的lib 库添加到系统(‘/usr/local/openssl/lib64’ 单引号)
#openssl 1.x.x版本是: /usr/local/openssl/lib/ 路径 #echo '/usr/local/openssl/lib' &gt; /etc/ld.so.conf.d/openssl.conf echo '/usr/local/openssl/lib64' &gt; /etc/ld.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94b9babb8ddd1112422c40e041273a88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef612917e76e7d99ddf233c9eff148db/" rel="bookmark">
			数据结构----算法复杂度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.数据结构前言 数据是杂乱无章的，我们要借助结构将数据管理起来
1.1 数据结构 数据结构(Data Structure)是计算机存储、组织数据的⽅式，指相互之间存在⼀种或多种特定关系的数
据元素的集合。没有⼀种单⼀的数据结构对所有⽤途都有⽤，所以我们要学各式各样的数据结构，
如：线性表、树、图、哈希等
1.2 算法 算法(Algorithm):就是定义良好的计算过程，他取⼀个或⼀组的值为输⼊，并产⽣出⼀个或⼀组值作为输出。简单来说算法就是⼀系列的计算步骤，⽤来将输⼊数据转化成输出结果。
好的算法能帮助我们更好的管理数据
数据结构是一种载体存储数据
算法是一种方法，管理数据
数据结构与算法不分家
学好数据结构可以提升面试和笔试
评估算法的好坏我们从复杂度进行评估
2.算法效率 /*给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。 示例 1: 输入: nums = [1,2,3,4,5,6,7], k = 3 输出: [5,6,7,1,2,3,4] 解释: 向右轮转 1 步: [7,1,2,3,4,5,6] 向右轮转 2 步: [6,7,1,2,3,4,5] 向右轮转 3 步: [5,6,7,1,2,3,4] 示例 2: 输入：nums = [-1,-100,3,99], k = 2 输出：[3,99,-1,-100] 解释: 向右轮转 1 步: [99,-1,-100,3] 向右轮转 2 步: [3,99,-1,-100] 提示： 1 &lt;= nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef612917e76e7d99ddf233c9eff148db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf41c64422e0c3b95c5f5515e9f7fffd/" rel="bookmark">
			【JavaEE初阶】线程的概念及创建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
📕 前言
📕 认识线程（Thread）
🚩 概念
😊线程是什么
🙂 为啥要有线程
😭 进程和线程的区别（面试题重点）
🤭 Java的线程和操作系统线程的关系
🚩 第⼀个多线程程序
🙂 使用 jconsole 命令观察线程
📕 创建线程
🚩方法一：继承 Thread 类
🚩 方法2：实现 Runnable 接口 🚩方法3：其他变形
📕 前言 当前的CPU都是多核心CPU，需要通过一些特定的编程技巧，把要完成的任务，拆解成多个部分，并且分别让他们在不同的cpu上运行，否则多核心cpu就形同虚设了，把这种编程称为"并发编程"，代指了并行 + 并发。
📕 认识线程（Thread） 线程thread，也成为"轻量级进程",创建销毁开销更小
🚩 概念 😊线程是什么 一个线程就是一个 “执行流”. 每个线程之间都可以按照顺序执行自己的代码. 多个线程之间 “同时” 执行着多份代码
例如：
一家公司要去银行办理业务，既要进行财务转账，又要进行福利发放，还得进行缴社保。
如果只有张三一个会计就会忙不过来，耗费的时间特别长。为了让业务更快的办理好，张三又找来两位同事李四、王五一起来帮助他，三个人分别负责一个事情，分别申请一个号码进行排队，自此就有了三个执行流共同完成任务，但本质上他们都是为了办理一家公司的业务。
此时，我们就把这种情况称为多线程，将一个大任务分解成不同小任务，交给不同执行流就分别排队执行。其中李四、王五都是张三叫来的，所以张三一般被称为主线程（Main Thread）
结论：
线程是系统调度执行的基本单位！！！
进程是系统资源分配的基本单位！！！
所有上节课谈到的"进程调度"一系列内容，更准确的说都是"线程调度".
上节课谈到的可视为都是"只包含一个线程的进程"
🙂 为啥要有线程 首先, “并发编程” 成为 “刚需”
单核 CPU 的发展遇到了瓶颈. 要想提高算力, 就需要多核 CPU. 而并发编程能更充分利用多核 CPU
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf41c64422e0c3b95c5f5515e9f7fffd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd4e99aca6c4aa0f3a2301af110cb019/" rel="bookmark">
			Elasticsearch：Golang ECS 日志记录 - Logrus
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ECS 记录器是你最喜欢的日志库的格式化程序/编码器插件。它们可让你轻松地将日志格式化为与 ECS 兼容的 JSON。
编码器以 JSON 格式记录，内部依赖于默认的 logrus.JSONFormatter。它还处理 ECS 错误格式的错误字段记录。
默认情况下，会添加以下字段：
{ "log.level": "info", "@timestamp": "2020-09-13T10:48:03.000Z", "message":" some logging info", "ecs.version": "1.6.0" } 安装 将包添加到你的 go.mod 文件中：
module zerolog-logging require go.elastic.co/ecslogrus master 我们使用如下的命令来下载包：
配置 设置默认记录器。例如：
log := logrus.New() log.SetFormatter(&amp;ecslogrus.Formatter{}) 示例 使用结构化日志记录 logrus_structrued.go package main import ( "errors" "github.com/sirupsen/logrus" "go.elastic.co/ecslogrus" ) func main() { log := logrus.New() log.SetFormatter(&amp;ecslogrus.Formatter{}) // Add custom fields. log.WithError(errors.New("boom!")).WithField("custom", "foo").Info("hello") } 我们使用如下的命令来运行应用：
go run logrus_structrued.go $ go run logrus_structrued.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd4e99aca6c4aa0f3a2301af110cb019/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b7413378d113c04e867d03ae9998390/" rel="bookmark">
			Vue2（vue-amap） 最新高德地图获取坐标与地址信息＋搜索功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果
第一步:首先我们先去高德地图开放平台申请一个Key
第二步:
需要安装地图插件
npm install vue-amap --save 第三步:
// 引入vue-amap import VueAMap from 'vue-amap' Vue.use(VueAMap) VueAMap.initAMapApiLoader({ key: '你的Key', // key plugin: [ 'AMap.Geolocation', //定位空间，用来获取和展示用户主机所在的经纬度位置 ' AMap.Autocomplete ', //输入提示插件 ' AMap.PlaceSearch ', //POI搜索插件 ' AMap.Scale ', //右下角缩略图插件，比例尺 ' AMap.OverView ', //地图鹰眼插件 ' AMap.ToolBar ', //地图工具条 ' AMap.MapType ', //类别切换空间，实现默认图层与卫星图，实施交通层之间切换的控制 ' AMap.PolyEditor ', //编辑 折线多边形 ' AMap.CircleEditor ', "AMap.Geocoder", //地图编码 'AMap.AMapManager', 'AMap.Marker' ], // 高德 sdk 版本，默认为 1.4.4 v: '1.4.4', uiVersion: '1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b7413378d113c04e867d03ae9998390/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/291ba5c77e1076d41b122be296213697/" rel="bookmark">
			Vuex数据持久化实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版本：vue 3.4.29 vuex4.1.0
1. 出现的问题 当我使用 vuex 作为状态管理组件来存储用户的一些信息之后，发现从/login 页面跳转到/home 界面后拿不到vuex信息。
之后查阅资料了解，当切换路由后，vue 会重新渲染，而vuex 也会重新初始化，之前的状态就会全部丢失。因此需要对vuex 中的数据进行持久化。
以下展示了两种持久化方案：
2. 基于window监听的持久化方案 由于页面刷新后会导致vuex 重新初始化，因此可以通过监听页面刷新事件来持久化数据。对应的事件就是beforeunload。之后再在初始化的时候恢复数据即可。
在App.vue 的script 标签中编译一下代码即可实现：
&lt;script setup&gt; import {useStore} from 'vuex' const store = useStore() // 恢复 if(localStorage.getItem("store")){ store.replaceState(Object.assign({}, store.state, JSON.parse(localStorage.getItem("store")))) } // 存储 window.addEventListener("beforeunload", () =&gt; { localStorage.setItem("store", JSON.stringify(store.state)) }) &lt;/script&gt; 3. 基于Vuex 插件的持久化方案 Vuex 官方提供了plugins 插件的选项，这个选项暴露出每次mutation 的钩子，可以让用户在每次 store 初始化和每次mutation 之后插入一些功能代码。因此可以作为持久化的实现方式。
Vuex 插件就是一个函数，它接受store 作为唯一参数
const myPlugin = (store) =&gt; { // 当 store 初始化后调用 store.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/291ba5c77e1076d41b122be296213697/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fa1c66cf76c4210ee690e5559b64fe0/" rel="bookmark">
			蓝桥杯 2024 年第十五届省赛真题 —— 最大异或结点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 最大异或结点1. 问题描述2. 输入格式3. 输出格式4. 样例输入5. 样例输出6. 样例说明7. 评测用例规模与约定 2. 解题思路1. 解题思路2. AC_Code 1. 最大异或结点 1. 问题描述 小蓝有一棵树,树中包含 N N N 个结点，编号为 0 , 1 , 2 , ⋯ , N − 1 0,1,2,\cdots, N - 1 0,1,2,⋯,N−1，其中每个结点上都有一个整数 X i X_{i} Xi​。他可以从树中任意选择两个不直接相连的结点 a 、 b a\text{、}b a、b 并获得分数 X a ⊕ X b X_{a} \oplus X_{b} Xa​⊕Xb​，其中 ⊕ \oplus ⊕ 表示按位异或操作。
请问小蓝可以获得的最大分数是多少?
2. 输入格式 输入的第一行包含一个整数 N N N，表示有 N N N 个结点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fa1c66cf76c4210ee690e5559b64fe0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c5ddc3bddee58216bd2b60aa03907ae/" rel="bookmark">
			高效工作流：用Mermaid绘制你的专属流程图；如何在Vue3中导入mermaid绘制流程图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
高效工作流：用Mermaid绘制你的专属流程图
一、流程图的使用场景
1.1、流程图flowChart
1.2、使用场景
二、如何使用mermaid画出优雅的流程图
2.1、流程图添加图名
2.2、定义图类型与方向
2.3、节点形状定义
2.3.1、规定语法
2.3.2、不同节点案例
2.4、节点连线
2.5、子图与多流程图互操作
2.5.1、多流程图且相互影响
2.5.2、子图的方向
2.6、定义节点类
三、Vue3中如何导入mermaid
3.1、下载并安装mermaid组件
3.2、导入并初始化mermaid流程图
四、mermaid绘制流程图的优缺点
五、总结
如果您希望直接访问Vue3导入mermaid的代码，可以直接访问：三、Vue3中如何引入mermaid
高效工作流：用Mermaid绘制你的专属流程图 一、流程图的使用场景 1.1、流程图flowChart 流程图是对某一个问题的定义、分析或解法的图形表示，图中用各种符号来表示操作、数据、流向以及装置等。使用图形表示算法的思路是一种极好的方法，因为千言万语不如一张图。通常用于计算机科学、业务流程设计、工程等领域。
电灯修理思路流程图
1.2、使用场景 流程图使用场景非常广泛，如软件开发、项目管理、工作流程、科学研究、制造和生产等。
二、如何使用mermaid画出优雅的流程图 2.1、流程图添加图名 在最上方添加如下内容：
--- title: Your flow chart title --- 例：
--- title: test model --- flowchart LR A[input] --&gt; B[peocess] B --&gt; C[output1] B --&gt; D[output2] 2.2、定义图类型与方向 flowchart代表定义为流程图，流程图的方向定义在flowchart旁边，支持四种方向，分别是top、bottom、left和right的缩写，比如LR就是从左到右。还有TB（TD：top to down）、BT（DT不行）、LR、RL。
例：
--- title: test model --- flowchart TB %% flowchart BT %% flowchart LR %% flowchart RL A[input] --&gt; B[peocess] B --&gt; C[output1] B --&gt; D[output2] 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c5ddc3bddee58216bd2b60aa03907ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e15e92d8879b26d91103d7f5e8ae3f0/" rel="bookmark">
			数据分析：微生物数据的荟萃分析框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 Meta-analysis of fecal metagenomes reveals global microbial signatures that are specific for colorectal cancer提供了一种荟萃分析的框架，它主要基于常用的Wilcoxon rank-sum test和Blocked Wilcoxon rank-sum test 方法计算显著性，再使用分位数计算分组间的倍数变化，最后通过AUC判断物种的区分分组的能力。最后通过热图和森林图展示筛选到的在不同研究和荟萃分析均有差异的物种。
该框架可用于同类型的微生物荟萃分析。
加载R包 #| warning: false #| message: false library(tidyverse) library(readr) library(coin) library(pROC) library(RColorBrewer) library(cowplot) # rm(list = ls()) options(stringsAsFactors = F) options(future.globals.maxSize = 1000 * 1024^2) 导入数据 数据下载百度云盘链接: https://pan.baidu.com/s/1VS6S8p5s20vwZ6FyILYoaQ
提取码: g4y3
物种表达谱数据
样本分组信息
#| warning: false #| message: false feat.all &lt;- read.table("./data/meta-CRC-2019/feat_rel_crc.tsv", sep='\t', header=TRUE, stringsAsFactors = FALSE, check.names = FALSE, quote='') %&gt;% as.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e15e92d8879b26d91103d7f5e8ae3f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e44683f47918219dd8a5129026d5a67/" rel="bookmark">
			ubuntu24.04 LTS配置java&#43;maven&#43;tomcat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、对java+maven+tomcat三个安装包解压 root@server:/opt# ls apache-maven-3.5.4 apache-maven-3.5.4-bin.tar.gz apache-tomcat-9.0.71 apache-tomcat-9.0.71.tar.gz jdk1.8.0_211 jdk-8u211-linux-x64.tar.gz 2、环境变量配置 root@server:/opt# vi /etc/profile #java export JAVA_HOME=/opt/jdk1.8.0_211 export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib export PATH=${JAVA_HOME}/bin:${PATH} #maven export MAVEN_HOME=/opt/apache-maven-3.5.4 export PATH=$MAVEN_HOME/bin:$PATH #tomcat export TOMCAT_HOME=/opt/apache-tomcat-9.0.71 export CATALINA_HOME=/opt/apache-tomcat-9.0.71 root@server:/opt# source /etc/profile root@server:/opt# java -version root@server:/opt# mvn -v 3、对tomcat的启动和关闭脚本的JAVA_HOME和JRE_HOME设置 vi /opt/apache-tomcat-9.0.71/bin/setclasspath.sh #在脚本的最上面添加 export JAVA_HOME=/opt/jdk1.8.0_211 export JRE_HOME=${JAVA_HOME}/jre 4、设置tomcat开机自启 #将tomcat目录下/bin中的catalina.sh拷贝到/etc/init.d下，并重命名为tomcat cp /opt/apache-tomcat-9.0.71/bin/catalina.sh /etc/init.d/ mv /etc/init.d/catalina.sh /etc/init.d/tomcat vi /etc/init.d/tomcat #在文件开始位置加入以下内容 CATALINA_HOME=/opt/apache-tomcat-9.0.71 JAVA_HOME=/opt/jdk1.8.0_211 #添加到开机自动服务 update-rc.d -f tomcat defaults 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e7756344a6eeb050cbb17adfd7ca444/" rel="bookmark">
			ubuntu在命令行输出里查找内容，dmesg
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 直接执行查看日志指令会出来很多页。dmesg为开机日志信息。记录了开机时硬件的过程
sudo dmesg 执行结果： 可以用竖号“|”，在前一条命令返回的内容进行查找。下图为查找bluetooth sudo dmesg |grep -i bluetooth 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e977fab9d1d4b725faf261a2a693c972/" rel="bookmark">
			go--本地下载包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、安装 Go 工具链：确保已经安装 Go。可以从 Go 的官方网站 下载并安装适合你操作系统的版本。
2、设置 Go 工作区：配置你的 GOPATH 环境变量。通常情况下，可以在 ~/.bashrc、~/.zshrc 或者 ~/.profile文件中添加以下行：
export GOPATH=$HOME/go export PATH=$PATH:$GOPATH/bin 然后在终端中运行 source ~/.bashrc 或者 source ~/.zshrc 使更改生效。
3、在终端运行以下命令：
go get -u package_name 4、验证下载：下载完成后，你可以验证包是否已正确下载。在终端中运行：
ls $GOPATH/src/golang.org/x/tour/tree 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f2525b788138d053080f5e126c502ae/" rel="bookmark">
			服务器选择租用还是托管？托管和租用哪个比较划算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在构建或扩展IT基础设施时，服务器作为关键组件，其选择方式——租用或托管，直接关系到企业的运营成本、灵活性、安全性及长期发展战略。本文将从技术、经济、安全等多个维度，深入解析这两种方案的优缺点，并探讨在何种情况下哪种方式更为划算。
服务器租用的详细分析 技术优势 即时可用性与灵活性：租用服务器，尤其是云服务，允许用户快速部署和扩展资源。用户可以根据业务需求即时调整计算资源、存储和带宽，无需等待硬件采购和部署周期。高度可扩展性：云服务提供商通常提供弹性伸缩功能，允许用户在需求高峰时自动增加资源，在需求低谷时减少资源，以节省成本。集成服务与支持：许多云服务提供商提供丰富的API和服务集成，如数据库、缓存、消息队列等，方便用户构建复杂的应用程序。 经济性 低初始投资：用户无需购买昂贵的硬件设备，只需支付使用费用，降低了初期资金压力。成本可预测性：云服务通常采用按需付费或订阅模式，用户可以根据实际使用情况预估成本，避免不必要的开支。 安全性与合规性 多层安全防护：云服务提供商通常会投入大量资源来保障数据中心的物理和网络安全，提供多层防护机制。合规性支持：大型云服务提供商通常符合多种行业标准和法规要求，如ISO 27001、HIPAA、GDPR等，有助于企业满足合规性需求。 服务器托管的详细分析 技术优势 完全控制权：用户拥有并管理自己的硬件设备，可以自由选择操作系统、软件配置和硬件升级。定制化部署：用户可以根据业务需求定制服务器配置，包括处理器、内存、存储和网络带宽等。高性能网络：托管服务商通常提供高质量的网络连接，确保数据传输的稳定性和速度。 经济性 长期成本效益：虽然初期投资较大，但长期来看，随着硬件成本的摊销，托管服务的总成本可能低于持续租用费用。避免租赁陷阱：一些云服务合同可能存在隐藏的长期费用或复杂的定价结构，而托管服务则更加透明。 安全性与合规性 物理安全：托管服务商负责数据中心的物理安全，包括门禁控制、监控摄像头和物理防护措施。数据隐私：用户完全掌控自己的数据，无需担心云服务提供商的数据隐私政策可能带来的风险。 成本效益分析 短期与长期成本 短期：租用服务器（尤其是云服务）通常具有更低的初始成本，适合资金紧张或业务快速变化的场景。长期：托管服务在长期内可能更具成本效益，尤其是当企业拥有稳定的业务需求和较高的硬件利用率时。 风险评估 技术风险：租用服务器可能面临技术依赖性和供应商锁定风险，而托管服务则要求企业具备更强的IT运维能力。市场风险：云服务市场竞争激烈，价格波动较大，可能影响企业的成本预算。 决策建议 明确业务需求：根据企业的业务需求、规模和发展阶段，选择最适合的服务器方案。评估成本效益：综合考虑短期和长期成本，以及潜在的风险因素，做出合理的成本效益分析。考虑技术能力和资源：评估企业自身的技术能力和资源投入，确保所选方案能够得到有效的管理和利用。咨询专家意见：在做出决策前，咨询IT专家或服务商的意见，以获取更全面的信息和建议。 服务器租用和托管各有其优势和适用场景。企业在选择时应根据自身情况综合考虑多个因素，以确保选择出最适合自己的方案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1b34f428a262b74e775aa80fe8585cb/" rel="bookmark">
			无需抠图！AI绘画直接文本生成透明底图层，设计师必看的ComfyUI透明图层生成工作流教程！（附插件模型）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是画画的小强
AI 绘画自出现以来一直都在不断发展完善，实现了很多我们在实际应用中迫切需要的功能，比如生成正确的手指、指定的姿势、准确的文本内容等。上周，又一个重磅新功能在开源的 SD 生态内实现了——直接通过文本直接生成透明底图像和图层！这将为 AI 绘画和设计领域带来了新的可能性，使图像形式更多样，也能给设计师带来更多便利。
今天我们就一起来了解实现这一新功能的技术 LayerDiffusion，以及如何在 ComfyUI 中利用 LayerDiffusion 生成透明底图片。
一、 LayerDiffusion 简介 LayerDiffusion 是由 @ lllyasviel （没错就是那个开发出 Controlnet、Fooocus 和 SD WebUI Forge 的大神）最新推出的一种透明图像生成技术，它的核心所在是“潜在透明度”，即将 Alpha 通道整合到预训练模型的潜在结构中，使模型能够生成带有透明度的图。
官方给出的演示案例效果非常好，不仅可以生成一般物体，而且对于玻璃、发光这种透明/半透明的对象，以及头发丝这种精细的内容，生成的效果依旧完美。本文章封面图的卷发女生就是我直接用 LayerDiffusion 生成的，极大提升了出图效率，而且真正做到了“毫无抠图痕迹”，再也不用担心有白边了。
除了直接生成透明底图像，LayerDiffusion 还支持生成分层图像。包括根据一个透明底图像生成完美融合的背景，并将该背景提取为完整独立的图层；以及根据背景图像+提示词生成前景主体，并将该主体提取为透明底图层。
目前 SD WebUI Forge 和 ComfyUI 已经支持 LayerDiffusion 的透明底功能，并且在未来还将支持通过图像生成透明底图像，下面为大家介绍如何在这 2 款工具中实现对应的功能。
在 ComfyUI 中使用 LayerDiffusion ① 安装插件
ComfyUI-layerdiffuse 插件 git 网址： https://github.com/huchenlei/ComfyUI-layerdiffuse.git
（如无法下载，请扫描免费获取 Layerdiffuse 插件安装包哦）
首先将 ComfyUI 更新到最新版本。然后安装 layerdiffuse 插件，可以用过 manager 安装，也可以进入根目录的 custom_nodes 文件夹中，通过 git clone 命令安装；安装成功后，进入 ComfyUI-layerdiffuse 根目录，打开终端命令，运行 pip install -r requirements.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1b34f428a262b74e775aa80fe8585cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10e5ec0603fe03ea7ccdcbfcea3262ed/" rel="bookmark">
			【自然语言处理（NLP）】基本概念和应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自然语言处理（NLP）：基本概念和应用 目录 引言自然语言处理的基本概念 词法分析句法分析语义分析上下文分析 自然语言处理的关键技术 词嵌入序列到序列模型注意力机制和Transformer预训练语言模型 自然语言处理的应用 文本分类情感分析机器翻译问答系统对话系统 自然语言处理的发展趋势结论 引言 自然语言处理（NLP）是人工智能的重要分支，旨在实现计算机对人类语言的理解、生成和交互。随着计算能力的提升和深度学习技术的发展，NLP在近年来取得了显著进展，并在多个领域实现了广泛应用。本文将介绍NLP的基本概念、关键技术及其应用，并探讨其未来的发展趋势。
自然语言处理的基本概念 词法分析 词法分析是自然语言处理的第一步，主要任务是将输入的文本分解成基本的词汇单元。常见的词法分析任务包括分词、词性标注和命名实体识别等。分词是将文本划分成独立的词汇，词性标注是为每个词汇标注其语法属性，而命名实体识别则是识别出文本中的实体（如人名、地名、组织名等）。
句法分析 句法分析旨在分析文本的语法结构，确定词汇之间的依存关系和句子的树状结构。句法分析通常包括短语结构分析和依存句法分析。短语结构分析将句子分解成短语层次结构，而依存句法分析则明确各个词汇之间的依存关系。
语义分析 语义分析是理解文本意义的关键步骤，主要任务是解析词汇和句子的含义。语义分析包括词义消歧、语义角色标注和语义依存分析等。词义消歧是确定多义词在具体上下文中的正确含义，语义角色标注是识别句子中的谓词和其相关的语义角色，而语义依存分析则进一步明确词汇之间的语义关系。
上下文分析 上下文分析是理解文本全局意义和语境的重要步骤，包括共指消解、语境建模和篇章结构分析等。共指消解是识别文本中不同表达方式指代的相同实体，语境建模是捕捉文本的全局语义信息，而篇章结构分析则是解析文本的段落和章节结构。
自然语言处理的关键技术 词嵌入 词嵌入是将词汇表示为低维向量的技术，使计算机能够处理和计算词汇的语义信息。常见的词嵌入方法包括Word2Vec、GloVe和FastText等。词嵌入通过捕捉词汇的上下文信息，生成语义相似的词汇向量，有助于提高NLP模型的性能。
序列到序列模型 序列到序列（Seq2Seq）模型是处理输入和输出都是序列的任务的常用方法。Seq2Seq模型通常由编码器和解码器组成，编码器将输入序列编码成固定长度的上下文向量，解码器根据上下文向量生成输出序列。Seq2Seq模型在机器翻译、文本生成和语音识别等任务中表现出色。
注意力机制和Transformer 注意力机制是提高Seq2Seq模型性能的重要技术，通过为每个输出词汇分配不同的权重，捕捉输入序列中的关键信息。Transformer模型是基于注意力机制的深度学习模型，通过自注意力机制和多头注意力机制实现高效的并行计算。Transformer在NLP任务中取得了显著成果，如BERT、GPT和T5等预训练模型。
预训练语言模型 预训练语言模型是NLP领域的重要突破，通过在大规模文本数据上进行预训练，捕捉广泛的语言知识，再进行微调以适应具体任务。BERT、GPT和T5是常见的预训练语言模型，它们在多个NLP任务上达到了前所未有的性能。
自然语言处理的应用 文本分类 文本分类是将文本分配到预定义类别的任务，常用于垃圾邮件过滤、新闻分类和情感分析等。常见的文本分类方法包括朴素贝叶斯、支持向量机（SVM）和深度学习模型（如LSTM和BERT）等。
情感分析 情感分析是识别文本中的情感倾向，如正面、负面和中性情感。情感分析广泛应用于社交媒体监控、市场情报和用户反馈分析等领域。基于词嵌入和深度学习的情感分析方法，如CNN、LSTM和BERT，显著提高了情感分析的准确性。
机器翻译 机器翻译是将一种语言的文本自动翻译成另一种语言的任务。传统的统计机器翻译方法已逐渐被基于Seq2Seq和Transformer的神经机器翻译（NMT）方法所取代。谷歌翻译和DeepL翻译等应用都采用了先进的NMT技术，提供高质量的翻译服务。
问答系统 问答系统是自动回答用户提问的系统，广泛应用于智能客服、在线教育和信息检索等领域。问答系统通常分为基于检索的问答系统和生成式问答系统。基于检索的问答系统从预定义的知识库中检索答案，而生成式问答系统则通过Seq2Seq模型生成答案。
对话系统 对话系统是实现人与计算机自然语言交互的系统，分为任务导向型对话系统和开放域对话系统。任务导向型对话系统专注于特定任务，如订餐、预定机票等，而开放域对话系统则能够进行广泛的话题交谈。GPT-3等大型预训练语言模型在对话系统中表现出色，推动了智能助手的发展。
自然语言处理的发展趋势 大规模预训练模型：大规模预训练模型，如GPT-3、BERT和T5，已经在多个NLP任务中取得了显著成果。未来，随着计算能力和数据规模的进一步提升，预训练模型将继续推动NLP的发展。跨模态学习：跨模态学习结合文本、图像和语音等多种模态信息，提高模型的综合理解和生成能力。在语音识别、图像描述和多模态搜索等任务中，跨模态学习将发挥重要作用。小样本学习和迁移学习：小样本学习和迁移学习能够在少量数据的条件下，快速适应新任务，提高NLP模型的适应性和泛化能力。解释性和透明性：随着NLP应用的广泛普及，提高模型的解释性和透明性显得尤为重要。可解释的NLP模型将增强其在关键领域的应用可信度和安全性。隐私保护和安全性：在数据隐私和安全性日益重要的今天，开发保护用户隐私的NLP技术，如联邦学习和差分隐私，将是未来的重要研究方向。 结论 自然语言处理作为人工智能的重要分支，已经在多个领域取得了显著进展。通过对其基本概念、关键技术和应用的介绍，本文希望读者能够对NLP有一个全面的认识。随着技术的发展，自然语言处理将继续推动人工智能的进步，带来更多创新和变革。
通过对自然语言处理基础知识的全面介绍，希望读者能够理解其关键概念和应用，并能够应用这些知识在实际项目中。自然语言处理的未来充满希望，我们期待着更多的技术突破和应用创新。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01d05b0c1bccba292349781e77c35538/" rel="bookmark">
			rabbitmq集群和负载均衡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.集群 当单台RabbitMQ服务器无法满足消息的吞吐量及安全性要求时，需要搭建RabbitMQ集群
# 关闭RabbitMQ服务 rabbitmqctl stop 重新设置服务
# 设置服务一 RABBITMQ_NODE_PORT=5673 RABBITMQ_NODENAME=rabbit1 rabbitmq-server start -detached ​ ​ # 设置服务二 RABBITMQ_NODE_PORT=5674 RABBITMQ_SERVER_START_ARGS="-rabbitmq_management listener [{port,15674}]" RABBITMQ_NODENAME=rabbit2 rabbitmq-server start -detached ​ ​ # 关闭服务2 rabbitmqctl -n rabbit2 stop_app # 重新设置服务2 rabbitmqctl -n rabbit2 re # 将服务2加入服务1中 rabbitmqctl -n rabbit2 join_cluster rabbit1@localhost # 启动服务2 rabbitmqctl -n rabbit2 start_app 集群虽然搭建成功
但是队列只保存在了一个节点中，如果该节点故障，则会丢失整个集群信息
此时我们需要引入镜像队列机制，它可以将队列消息复制到集群中的其他节点上
在控制台上切换到ADMIN界面，新增一个policy
definition新增ha-mode=all
保存即可
2.负载均衡 无论生产者还是消费者，只能链接一个rabbitmq节点，如果只链接一个节点，就会造成单个节点压力过大。此时就需要haproxy负载工具
yum -y install haproxy vim /etc/haproxy/haproxy.cfg # 以下为添加内容 listen rabbitmq_cluster # 对外暴露端口 bind 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01d05b0c1bccba292349781e77c35538/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c85ffcfeeac2801e5a8b275a44a352fe/" rel="bookmark">
			C&#43;&#43;前言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 什么是C++2. C++发展史3. C++的重要性3.1 语言的使用广泛度3.2 在工作领域 4. 如何学习C++4.1 别人怎么学？4.2 自己怎么学 1. 什么是C++ C语言是结构化和模块化的语言，适合处理较小规模的程序。对于复杂的问题，规模较大的程序，需要高度的抽象和建模时，C语言则不合适。为了解决软件危机， 20世纪80年代， 计算机界提出了OOP(objectoriented programming：面向对象)思想，支持面向对象的程序设计语言应运而生。
1982年，Bjarne Stroustrup博士在C语言的基础上引入并扩充了面向对象的概念，发明了一种新的程序语言。为了表达该语言与C语言的渊源关系，命名为C++。因此：C++是基于C语言而产生的，它既可以进行C语言的过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行面向对象的程序设计。
2. C++发展史 1979年，贝尔实验室的本贾尼等人试图分析unix内核的时候，试图将内核模块化，于是在C语言的基础上进行扩展，增加了类的机制，完成了一个可以运行的预处理程序，称之为C with classes。
语言的发展就像是练功打怪升级一样，也是逐步递进，由浅入深的过程。我们先来看下C++的历史版本。
C++还在不断的向后发展。但是：现在公司主流使用还是C++98和C++11，所有大家不用追求最新，重点将
C++98和C++11掌握好，等工作后，随着对C++理解不断加深，有时间可以去琢磨下更新的特性。
3. C++的重要性 3.1 语言的使用广泛度 下图数据来自TIOBE编程语言社区2024年1月排行榜，在30多年的发展中，C/C++几乎一致稳居前3。
TIOBE 编程语言社区排行榜是编程语言流行趋势的一个指标，每月更新，这份排行榜排名基于互联网上有经验的程序员、 课程和第三方厂商的数量。排名使用著名的搜索引擎（诸如 Google、MSN、Yahoo!、Wikipedia、YouTube 以及 Baidu 等）进行计算。 注意：排名不能说明那个语言好，那个不好，每门编程语言都有适应自己的应用场景。
3.2 在工作领域 1. 操作系统以及大型系统软件开发
所有操作系统几乎都是C/C++写的，许多大型软件背后几乎都是C++写的，比如：Photoshop、
Office、JVM(Java虚拟机)等，究其原因还是性能高，可以直接操控硬件。
2. 服务器端开发
后台开发：主要侧重于业务逻辑的处理，即对于前端请求后端给出对应的响应，现在主流采用java，但内卷化比较严重，大厂可能会有C++后台开发，主要做一些基础组件，中间件、缓存、分布式存储等。
服务器端开发比后台开发跟广泛，包含后台开发，一般对实时性要求比较高的，比如游戏服务器、流媒体服务器、网络通讯等都采用C++开发的。
3. 游戏开发
PC平台几乎所有的游戏都是C++写的，比如：魔兽世界、传奇、CS、跑跑卡丁车等，市面上相当多的游戏引擎都是基于C++开发的，比如：Cocos2d、虚幻4、DirectX等。三维游戏领域计算量非常庞大，底层的数学全都是矩阵变换，想要画面精美、内容丰富、游戏实时性搞，这些高难度需求无疑只能选C++语言。比较知名厂商：腾讯、网易、完美世界、巨人网络等。
4. 嵌入式和物联网领域
嵌入式：就是把具有计算能力的主控板嵌入到机器装置或者电子装置的内部，能够控制这些装置。比如：智能手环、摄像头、扫地机器人、智能音响等。
谈到嵌入式开发，大家最能想到的就是单片机开发(即在8位、16位或者32位单片机产品或者裸机上进行的开发)，嵌入式开发除了单片机开发以外，还包含在soc片上、系统层面、驱动层面以及应用、中间件层面的开发。
常见的岗位有：嵌入式开发工程师、驱动开发工程师、系统开发工程师、Linux开发工程师、固件开发工程师等。
知名的一些厂商，比如：以华为、vivo、oppo、小米为代表的手机厂；以紫光展锐、乐鑫为代表的芯片厂；以大疆、海康威视、大华、CVTE等具有自己终端业务厂商；以及海尔、海信、格力等传统家电行业。
随着5G的普及，物联网(即万物互联，)也成为了一种新兴势力，比如：阿里lot、腾讯lot、京东、百度、美团等都有硬件相关的事业部。
5. 数字图像处理
数字图像处理中涉及到大量数学矩阵方面的运算，对CPU算力要求比较高，主要的图像处理算法库和开源库等都是C/C++写的，比如：OpenCV、OpenGL等，大名鼎鼎的Photoshop就是C++写的。
6. 人工智能
一提到人工智能，大家首先想到的就是python，认为学习人工智能就要学习python，这个是误区，python中库比较丰富，使用python可以快速搭建神经网络、填入参数导入数据就可以开始训练模型了。但人工智能背后深度学习算法等核心还是用C++写的。
7. 分布式应用
近年来移动互联网的兴起，各应用数据量业务量不断攀升；后端架构要不断提高性能和并发能力才能应对大信息时代的来临。在分布式领域，好些分布式框架、文件系统、中间组件等都是C++开发的。对分布式计算影响极大的Hadoop生态的几个重量级组件：HDFS、zookeeper、HBase等，也都是基于Google用C++实现的GFS、Chubby、BigTable。包括分布式计算框架MapReduce也是Google先用C++实现了一套，之后才有开源的java版本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c85ffcfeeac2801e5a8b275a44a352fe/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/121/">«</a>
	<span class="pagination__item pagination__item--current">122/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/123/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>