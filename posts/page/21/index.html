<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5da86ce5019831a7fda343542d89c285/" rel="bookmark">
			SOA通信中间件介绍（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、通信中间件 在软件定义汽车中，应用程序之间的跨进程或跨核通信是一个需要解决的问题。模块化架构为开发人员提供了便利，但也引入了对通信中间件的需求。
在没有使用通信中间件的情况下，开发人员需要自己定义数据的格式、发送方和接收方。然而，使用基于服务/数据的发布和订阅模式（如SOME/IP和DDS），开发人员只需要明确需要什么样的数据以及数据应该传递到哪里，而无需关注数据的发送方和发送方式。
以数据为中心是相对于传统的以消息为中心而言的，其本质区别在于通信中间件知道存储了什么数据并能够控制如何共享这些数据。对于传统的以消息为中心的中间件，程序员必须为发送消息编写代码，而对于以数据为中心的中间件，程序员只需为如何共享数据编写代码，然后可以直接共享数据值。
通信中间件可以采用点对点、消息队列和发布/订阅三种工作模式，SOME/IP和DDS都采用了发布/订阅模式。
在发布/订阅模型中，发布者和订阅者通过主题进行关联，双方不需要知道对方在何处，也不需要同时在线。这实现了通信双方在时间、空间和数据通信上的多维松耦合。
此外，与面向信号的CAN相比，DDS和SOME/IP都是面向服务的通信协议。两者的区别在于面向信号的数据传输始终循环发送，而面向服务的通信方式不同，只有在客户端请求或服务器通知特定订阅者时，才在客户端-服务器配置中交换数据。这确保了永远不会浪费带宽，并且仅在需要的时间和地点进行数据通信/交换。因此，面向服务的通信协议可以大大减少网络负载，提高通信效率。
在软件定义汽车时代，车内的所有可调用功能都被视为服务，并提供不同类型的调用接口，这些接口可以按以下方式分类：
1、API接口：提供各类函数的调用接口，使应用程序能够调用系统内部的功能实现函数。应用程序可以通过调用相关的API接口来提供和使用功能服务。
2、文件方式：以配置文件或设备文件的形式提供系统内部的调用能力。这些文件可以通过配置自动生成，包含有效的配置信息，并且可以在运行环境中被特定的程序读取和识别，实现特定的服务。
3、系统原生服务：操作系统和基础类库提供的可操作能力，包括对系统CPU和内存的监测、应用程序的监控、系统资源的划分等。此外，还可以调用C++、boost等基础类库。
4、IPC接口：各种IPC机制提供系统内进程间的调用能力，包括使用套接字（socket）、共享内存等进程间通信方式，以及使用特定的跨核通信方式如IPCF。
5、协议栈接口：通过网络协议栈提供跨平台的调用能力，包括SOME/IP、DDS、MQTT、HTTP等网络协议的调度服务、接口封装和协议转换等。
尽管在互联网领域中SOA（面向服务的架构）已经被应用了很长时间，但在汽车行业中，它算是相对较新的概念。在Adaptive AutoSAR框架中，通信管理模块包括进程间通信和网络协议栈。
鉴于汽车应用场景和通信需求的特殊性，许多互联网的SOA技术并不能直接应用于汽车领域。一般来说，SOA通信中间件系统的各个层面需要满足以下要求：
1、本地服务和远程服务之间的通信应该使用统一的接口描述语言（IDL）定义的文件作为契约。IDL是一种中立的接口描述语言，与具体的操作系统和编程语言无关。
2、SOA框架的底层核心功能应具备以下特点：服务发现、消息序列化、内部事件/消息处理和传输功能。应用程序、服务和操作系统之间可以通过标准的通信协议或服务接口相互通信或访问，特别是要满足传感数据的大数据吞吐传输需求。必须支持典型的车内通信协议，如SOME/IP协议、DDS规范等。服务发现功能应具备访问控制功能，以防止未经授权的用户进行窃听和侵入；传输功能应具备数据加密和签名等功能，以确保通信数据的安全性。
在未来，汽车将与更多的基础设施进行连接，为了实现与它们的连接，将需要使用不同的通信协议。
汽车SOA 通信架构
HTTP、MQTT、SOME/IP和DDS等协议都用于实现SOA架构中的通信，只是在不同的场景下承担不同的责任。例如，SOME/IP协议用于车内节点之间的服务通信，而HTTP和MQTT用于与互联网模块进行通信。尽管它们在实现机制上有些许差异，但它们可以相互切换使用。
MQTT、DDS、AMQP、REST和CoAP等协议都已被广泛应用，并且每种协议都至少有10种不同的代码实现。它们都宣称支持实时的发布/订阅物联网协议。然而，在具体的系统架构设计中，需要考虑实际场景中的通信需求，并选择适合的协议。各种协议的特点如表所示。
二、SOME/IP 介绍 2011年，宝马设计并提出了SOME/IP（Scalable Service-oriented Middleware over IP）协议。SOME/IP采用服务器-客户端的服务通信模式，并且具备高度可扩展性。SOME/IP协议是一种应用层协议，运行在TCP/UDP传输协议之上（车载以太网第四层以上）。它作为以太网通信的中间件，实现应用层与IP层之间的数据交互，使其不依赖于操作系统，并且兼容AUTOSAR和非AUTOSAR平台。因此，SOME/IP可以独立于硬件平台、操作系统和编程语言。
SOME/IP 协议架构
SOME/IP具备满足车用需求的特性，主要包括以下几个方面：基于服务的通信方式，占用空间小，与AUTOSAR兼容（其他中间件不具备兼容性），可伸缩性（适用于小型和大型平台），以及兼容性（可适用于车辆使用的各种操作系统，如AUTOSAR、OSEK、QNX和Linux）。
SOME/IP支持AUTOSAR CP、AUTOSAR AP以及非AUTOSAR平台之间的通信交互。宝马设计SOME/IP协议后，它被AUTOSAR纳入正式标准，并随着CP规范的发布而被广泛应用于车载以太网，因此可以说是AUTOSAR CP推动了SOME/IP的广泛使用。
在AUTOSAR架构中，SOME/IP-SD模块位于AUTOSAR BSW Mode Manager模块（BswM）和AUTOSAR Socket Adaptor模块（SoAd）之间。BswM模块提供了通用模式请求和服务请求之间的连接，而SoAd模块处理以太网堆栈和SD模块之间的服务请求。通过配置SoAd中的Socket Connection表，可以接收其他ECU的SD模块发送的单播和多播报文。
借助SOME/IP协议的高度平台扩展性，可以实现不同平台之间的数据交互，而统一的SOME/IP通信机制是不同平台通信的前提。为了在不同软件平台上运行SOME/IP，实现整车以太网上的SOA架构通信机制，AP规范中也同步引入了SOME/IP，因此在AUTOSAR系统中，CP和AP之间实现SOME/IP通信相对容易。
为了促进非AUTOSAR软件平台与车内CP和APECU之间的交互，GENIVI系统同样开发了一套开源的vSOME/IP软件源码，以便与CP/AP进行交互。然而，由于vSOME/IP是开源的，性能可能略有差异，因此需要统一的规范进行约束，以进行深度的二次开发。目前，全球最大的商用SOME/IP产品供应商是Vector，而开源版的vSOME/IP由GENIVI协会维护。
来源：《智能汽车：新一代技术与应用》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6e1af4fa8574075fffca0fa476697fa/" rel="bookmark">
			鸿蒙三层架构，鸿蒙模块依赖、鸿蒙依赖模块，鸿蒙hap、鸿蒙hsp、鸿蒙har
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、产品定制层、基础特性层、公共能力层 1.1、产品定制层：product 应用的入口，
1.2、基础特性层：feature 业务：首页、我的
1.3、公共能力层：common 方法能力复用
​​​​​​​一次开发，多段部署 3层架构的包，可以是har包，也可以是hsp包 har静态共享包 不支持依赖循环、A模块依赖B模块，B模块依赖A模块
不支持依赖传递，即：A模块依赖B模块，B模块依赖C模块
可以发三方库，
hsp动态共享包 多个hap/hsp共用的代码和资源放在一个HSP中，可以提高代码、资源的可重用性，只需要一份hsp包，减少了app的空间 不能发三方库
hsp拷贝一份，har会拷贝多份 二、项目中，使用三层架构步骤： 2.1、新建3个目录：product、features、common 2.2、分别在common中，新建1个模块，且选择hsp包，模块名可以命名为：basic 2.3、分别在features中，新建1个模块，且选择hsp包，模块名可以命名为：home、mine、login 2.4、product入口，汽车端，平板端，把默认的entry文件夹，移到该目录下，并重命名为：phone； 如果要在此目录新建平板端的项目，需要新建模块，并且选择hap包，因为只有hap才有页面
调出运行配置，将 deploy multi hap =&gt; deploy multi hap packages 勾上，并且下拉出来的选框，都勾上 三、模块之间依赖 在common中，想新建一个head的公共组件，phone模块想依赖这个组件，分2步 3.1、在common =&gt; index 文件中，先要导出head组件: export *from './src/main/ets/components/Head' 注意：Head要有export关键字 3.2、在phone =&gt; oh-package.json5文件中，设置依赖： 依赖前：
{ "name": "phone", "version": "1.0.0", "description": "Please describe the basic information.", "main": "Index.ets", "author": "", "license": "Apache-2.0", "packageType": "InterfaceHar", "dependencies": { } } 依赖后：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6e1af4fa8574075fffca0fa476697fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50bc23a7daf3f66c501f479eb41e5de5/" rel="bookmark">
			ssm基于微信小程序的食堂窗口自助点餐系统源码调试讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 环境搭建 JDK 1.8：确保您的系统已安装JDK 1.8，并配置好环境变量。JDK 1.8 是目前很多Java项目仍在使用的稳定版本，适用于SSM框架。Tomcat 7：安装并配置Tomcat 7作为您的Web服务器。Tomcat 7 支持Servlet 3.0和JSP 2.2，对于大多数SSM项目来说足够了。MySQL 5.7：安装MySQL 5.7数据库，并创建相应的数据库和表结构。MySQL 5.7 提供了更好的性能、安全性和新功能。Navicat 11：使用Navicat 11作为数据库管理工具，方便数据库的设计、管理和维护。开发软件：Eclipse、MyEclipse 或 IntelliJ IDEA 都是很好的选择，它们支持Maven并可以方便地集成SSM框架。Maven 3.3.9：确保Maven已安装并配置好环境变量，用于项目的依赖管理和构建。 2. SSM框架 Spring：负责应用的上下文管理和依赖注入。Spring MVC：作为MVC框架，处理HTTP请求和响应。MyBatis：数据持久层框架，用于映射SQL语句和Java对象。 3. 项目结构 典型的SSM项目结构包括src/main/java（Java源代码）、src/main/resources（配置文件和资源文件）、src/test/java（测试代码）等。配置文件可能包括applicationContext.xml（Spring配置文件）、mybatis-config.xml（MyBatis配置文件）、web.xml（Web应用部署描述符）等。 4. 访问路径 您的后台管理页面访问路径为localhost:8080/项目名称/admin/dist/index.html，这意呀着您可能需要在Tomcat中部署一个Web应用，该应用内部包含静态文件或通过Spring MVC控制器转发到静态资源。 5. 管理员账号 管理员账号abo和密码abo应配置在Spring Security或自定义的权限管理模块中，确保系统安全。 Android混合开发（uniapp） 1. 环境搭建 HBuilder X：安装HBuilder X作为开发环境，它支持uniapp框架的开发、调试和打包。uniapp：一种使用Vue.js开发所有前端应用的框架，可以编译到iOS、Android、H5、以及各种小程序等多个平台。 2. 开发模式 混合开发：uniapp允许您使用HTML、CSS和JavaScript等前端技术来开发应用，然后通过原生壳（如DCloud提供的DCloud UniApp SDK）进行打包，实现接近原生应用的性能。 3. 交互与后端 您的uniapp应用可以通过AJAX、Fetch API等方式与SSM框架的Java Web应用进行数据交互，获取或提交数据。确保您的Web服务接口是RESTful的，方便前端调用。 4. 调试与发布 在HBuilder X中，您可以直接进行真机调试，查看应用在不同设备上的表现。打包发布时，可以选择生成iOS的IPA包或Android的APK包，并上传到相应的应用商店。 通过上述说明，您应该对如何使用SSM框架开发Java Web应用和如何使用uniapp进行Android混合开发有了更清晰的了解。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbe58fd4f6292b499f4c683ea1dc0f0e/" rel="bookmark">
			【一起学Rust | 框架篇 | Tauri2.0框架】rust和前端的相互调用（前端调用rust）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. 前端调用rust（command）1. 在后端定义一个`command`2. 注册`command`3. 前端调用`command` 2. 前端调用rust（event）4. command完整实例 前言 本期将继续接着上一期，继续探索tauri中rust和前端的相互调用，上一期我们介绍了rust调用前端，这一期我们继续探索前端调用rust。
首先还是回忆一下上周tauri的前后端通信示意图
从该图片我们可以清晰的看出来，tauri的前端和rust后端通信是通过事件机制来实现的，在上期中，我介绍了事件机制的基础，以及如何通过rust的工具来调用前端的方法，也就是触发前端监听的事件。
这张图是双向的，也就是说前端也可以触发rust监听的事件，这样前端也可以调用rust的方法，这也是本期的主要内容。
除此以外，tauri官方推荐的前端调用rust后端的主要方法是通过command来调用，因此，如果你要做的东西比较简单，那么更建议使用command来调用，因为command的调用方式更简单，更符合前端开发者的习惯，而且选择合适的使用场景的能力对于一个开发人员来说也是非常重要的。
从图上可以看出，tauri的command其实与fetch api是非常相似的，都是请求、响应的模式，但其实这个机制是使用json-rpc来实现的（这些都是官方写的），不过这个不需要深究，除非你是老专家。我们只需要知道怎么用的，置于原理那是后面的事情，如果tauri可以活到那个时候的话。
以上是tauri使用command来与rust后端通信的流程图。其中一些转换方法tauri已经为我们实现了，当你理解了这张图，在使用command时就会非常简单。
Because this mechanism uses a JSON-RPC like protocol under the hood to serialize requests and responses, all arguments and return data must be serializable to JSON.
注意：本文内容均可在官方文档中找到对应内容： https://v2.tauri.app/concept/inter-process-communication/
1. 前端调用rust（command） 为了更加方便的描述tauri是如何从前端调用rust的，我先写一个流程，然后以这个流程来逐步实现该功能。
在rust后端定义一个command注册command前端调用command 1. 在后端定义一个command 在rust中，command的定义非常简单，只需要在src-tauri/src/main.rs中定义一个函数，并使用tauri::command!宏来标记该函数为command即可，就像程序自带的command，greet就是这么做的（学习就是在看例子）。
#[tauri::command] fn greet(name: &amp;str) -&gt; String { format!("Hello, {}! You've been greeted from Rust!", name) } 在这个greet的例子中，可以看到，name是需要传入的参数，然后返回一个格式化的字符串。（不写分号等于返回，不需要写return）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbe58fd4f6292b499f4c683ea1dc0f0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e7e6b420fe42b666c52433f1892d52e/" rel="bookmark">
			如何使用GPT画出带中文的图和表？-已解决GPT画图表出现乱码的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		众所周知，GPT的中文库有点问题，要求他画带中文的图或表存在中文的时候，就会出现乱码或者方框。
可以发现，GPT的中文库有问题，那么该如何解决这个问题呢？
直接在promote的时候上传你需要它使用的字体，这个字体能支持中文即可
我使用的这个字体的下载链接：NotoSeriSC字体下载链接
其它支持中文的字体也是可以的，比如微软雅黑等
比如：
虽然带中文的画图还是不够美观，不支持带中文的艺术字。
这个给图片加中文字的好像只有4o能用，GPT4.0好像还是做不到。
大家如果有更好的方法，欢迎在评论区补充
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/433f957509f06acb133fb4b9a046760e/" rel="bookmark">
			10、Flink 动态表之更新和追加查询详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 更新和追加查询 虽然这两个示例查询看起来非常相似（都计算分组计数聚合），但它们在一个重要方面不同：
第一个查询更新先前输出的结果，即定义结果表的 changelog 流包含 INSERT 和 UPDATE 操作。第二个查询只附加到结果表，即结果表的 changelog 流只包含 INSERT 操作。 一个查询是产生一个只追加的表还是一个更新的表区别：
产生更新更改的查询通常必须维护更多的状态。将 append-only 的表转换为流与将已更新的表转换为流是不同的 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3fb28b185c79b4d236ca8192c76fa98/" rel="bookmark">
			大数据-104 Spark Streaming Kafka Offset Scala实现Redis管理Offset并更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点一下关注吧！！！非常感谢！！持续更新！！！ 目前已经更新到了： Hadoop（已更完）HDFS（已更完）MapReduce（已更完）Hive（已更完）Flume（已更完）Sqoop（已更完）Zookeeper（已更完）HBase（已更完）Redis （已更完）Kafka（已更完）Spark（正在更新！） 章节内容 上节完成了如下的内容：
Spark Streaming Kafka自定义管理Offset Scala代码实现
Offset 管理 Spark Streaming 集成Kafka，允许从Kafka中读取一个或者多个Topic的数据，一个Kafka Topic包含一个或者多个分区，每个分区中的消息顺序存储，并使用offset来标记消息位置，开发者可以在Spark Streaming应用中通过offset来控制数据的读取位置。
Offsets 管理对于保证流式应用在整个生命周期中数据的连贯性是非常重要的，如果在应用停止或者报错退出之前将Offset持久化保存，该消息就会丢失，那么Spark Streaming就没有办法从上次停止或保存的位置继续消费Kafka中的消息。
Spark Streaming 与 Kafka 的集成 Spark Streaming 可以通过 KafkaUtils.createDirectStream 直接与 Kafka 集成。这种方式不会依赖于 ZooKeeper，而是直接从 Kafka 分区中读取数据。
在这种直接方式下，Spark Streaming 依赖 Kafka 的 API 来管理和存储消费者偏移量（Offsets），默认情况下偏移量保存在 Kafka 自身的 __consumer_offsets 主题中。
使用 Redis 管理 Offsets Redis 作为一个高效的内存数据库，常用于存储 Spark Streaming 中的 Kafka 偏移量。
通过手动管理偏移量，你可以在每批次数据处理后，将当前批次的 Kafka 偏移量存储到 Redis 中。这样，在应用程序重新启动时，可以从 Redis 中读取最后处理的偏移量，从而从正确的位置继续消费 Kafka 数据。
实现步骤 从 Redis 获取偏移量 应用启动时，从 Redis 中读取上次处理的偏移量，并从这些偏移量开始消费 Kafka 数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3fb28b185c79b4d236ca8192c76fa98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5d970dc58d56072334570dc1d1b6d0a/" rel="bookmark">
			智能新时代：探索【人工智能】、【机器学习】与【深度学习】的前沿技术与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 引言
1.1 人工智能的概念与历史
1.2 机器学习与深度学习的演进
1.3 计算机视觉的崛起与应用场景
2. 人工智能基础
2.1 什么是人工智能？
2.2 人工智能的分类
2.3 人工智能的现实应用
3. 机器学习
3.1 机器学习的定义与基本原理
3.2 机器学习的主要类型
3.3 常用的机器学习算法
4. 深度学习
4.1 深度学习的背景与发展
4.2 人工神经网络的基础
4.3 常见的深度学习模型
4.4 深度学习的训练与优化
5. 算法
5.1 什么是算法？
5.2 算法的重要性
5.3 常见的算法类型
5.4 机器学习中的算法选择与比较
5.5 算法复杂度与优化
6. 计算机视觉
6.1 计算机视觉的定义与重要性
6.2 计算机视觉的主要任务
6.3 深度学习在计算机视觉中的应用
6.4 计算机视觉中的挑战
总结
前几天偶然发现了一个超棒的人工智能学习网站，内容通俗易懂，讲解风趣幽默，简直让人欲罢不能。忍不住分享给大家，点击这里立刻跳转，开启你的AI学习之旅吧！
前言 – 人工智能教程https://www.captainbed.cn/lzx
1. 引言 1.1 人工智能的概念与历史 人工智能（AI）是模拟人类智能的技术和理论的集合。它的历史可以追溯到1950年代，当时计算机科学家开始探索如何通过计算机来执行通常需要人类智能的任务。最初的AI研究集中在符号逻辑和规则系统上，例如专家系统，后来随着统计学和概率论的进步，机器学习成为了AI的主要方法。今天，AI已经发展到能够通过深度学习模型处理海量数据并执行复杂任务，如语音识别、自然语言处理和图像分析。
1.2 机器学习与深度学习的演进 机器学习是人工智能的一个分支，它让计算机通过数据来学习和改进。早期的机器学习算法，如线性回归和决策树，依赖于统计模型和简单规则。随着计算能力的增强和大数据的普及，深度学习模型通过多层神经网络大幅提升了机器的学习能力。深度学习在图像处理、语音识别、自动驾驶等领域展现了强大的性能，推动了AI的广泛应用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5d970dc58d56072334570dc1d1b6d0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fdabc9fadd36279d739816edd755b82/" rel="bookmark">
			C_04_数组学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一维数组 步骤
1,声明
语法:
extern 数据类型 数组名[长度]; 注意:
可有可无长度此时可以忽略不写 2,定义与初始化
系统自动初始化 # 数据类型 数组名[长度]; ​ 注意:
​ 全局变量数组中的值为0
​ 局部变量数组中的值为随机数
​ 不建议使用
部分初始化 # 数据类型 数组名[长度] = {值1,值2,值3,....}; ​ 注意:
​ 此时值的个数小于长度
​ 将值从下标0的位置开始依次存储到数组中,剩余位置用0填充
​ 特殊情况:将数组中所有数据制0
全部初始化 数据类型 数组名[长度] = {值1,值2,值3,....}; ​ 注意:
​ 此时值的个数等于长度,将值从下标0的位置开始依次存储到数组中
​ 此时长度可以忽略不写
间隔初始化 数据类型 数组名[长度] = {[下标] = 值,[下标] = 值,...}; ​ 注意:
​ 将指定位置的元素修改为指定的值
​ 不建议使用
​ 注意:不能将一个数组赋值给另一个数组
3,使用
​ 取值
# 数组名[下标] ​ 存值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fdabc9fadd36279d739816edd755b82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caca3a727c2b29b2dc1244a55709f783/" rel="bookmark">
			深入探索【Hadoop】生态系统：Hive、Pig、HBase及更多关键组件（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🐇明明跟你说过：个人主页
🏅个人专栏：《大数据前沿：技术与应用并进》🏅
🔖行路有良友，便是天堂🔖
目录
一、引言
1、什么是Hadoop
2、Hadoop生态系统的构成概览
二、HBase：分布式NoSQL数据库
1、什么是HBase
2、HBase架构解析：Region、RegionServer、Zookeeper的角色
3、HBase API与操作方式
4、HBase应用场景
三、Hadoop生态系统中的其他重要组件
1、Sqoop：数据在Hadoop与传统数据库间的传输工具
2、Spark
一、引言 1、什么是Hadoop Hadoop 是一个开源的分布式计算框架，用于处理大规模数据集。它由 Apache 软件基金会开发，主要包括以下两个核心组件：
Hadoop 分布式文件系统 (HDFS)：这是一个分布式文件系统，设计用于在集群中的多台机器上存储海量数据。它将数据分割成块，并将每个块复制到多个节点，以确保数据的可靠性和容错性。MapReduce：这是一个计算模型，用于并行处理大规模数据集。它将数据处理任务分解为两个主要阶段：Map 阶段（将输入数据转换为键值对）和 Reduce 阶段（将键值对合并为最终结果）。 Hadoop 还包括其他组件，如 Hadoop YARN（用于资源管理和调度）和 Hadoop Common（提供支持其他 Hadoop 模块的工具和库）。Hadoop 的设计允许它在廉价的硬件上运行，具有高容错性和扩展性，适合处理大规模的数据分析任务。
2、Hadoop生态系统的构成概览 1. 核心组件
Hadoop 分布式文件系统 (HDFS)：负责分布式存储，提供高吞吐量的数据访问。MapReduce：用于分布式数据处理，包含 Map 和 Reduce 两个阶段。YARN (Yet Another Resource Negotiator)：负责集群资源管理和任务调度。 2. 数据存储与管理
HBase：一个 NoSQL 分布式数据库，适用于处理大规模结构化和半结构化数据。Hive：基于 SQL 的数据仓库工具，允许通过 SQL 查询大数据，并将查询转换为 MapReduce 任务。Pig：一个高级数据流语言（Pig Latin），用于编写复杂的数据转换任务，最终由 MapReduce 处理。Avro：一种数据序列化框架，用于存储和交换数据结构。Parquet：列式存储格式，优化了 Hadoop 中的大规模数据分析。 3. 数据处理与分析
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/caca3a727c2b29b2dc1244a55709f783/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f2324c5a8ac5d54a099129c5c7a16a9/" rel="bookmark">
			牛客笔试训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		牛客.过桥 在函数
public static int n; public static int[]arr=new int[2001]; public static int bfs(){ int left=1; int right=1; int ret=0; while(left&lt;=right){ ret++; int r=right; for(int i=left;i&lt;=right;i++){ r=Math.max(r,arr[i]+i); if(r&gt;=n){ return ret; } } left=right+1; right=r; } return -1; } public static void main(String[]args){ Scanner in=new Scanner(System.in); n=in.nextInt(); for(int i=1;i&lt;=n;i++){ arr[i]=in.nextInt(); } System.out.println(bfs()); } 不在函数中，
import java.util.*; public class Main{ public static void main(String[]args){ Scanner in=new Scanner(System.in); int n=in.nextInt(); int[]a=new int[n+1]; for(int i=1;i&lt;=n;i++){ a[i]=in.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f2324c5a8ac5d54a099129c5c7a16a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ec620becc4404ad88186c36f7a2b35c/" rel="bookmark">
			大数据计算-SQL优化手段(CBO)-以Flink为例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 背景理论知识示例结果展示结果解释 背景 大数据计算中，SQL生成的执行计划第一轮会经过固定规则的优化，第二轮会根据原计划，生成多条结合成本的的执行计划，根据cost 进行排序，选出最优的执行计划。
理论知识 原始计划如左图，
有三种执行方案
方案1，scan表1，scan表2，然后hash ，再join
方案2，scan表1，scan表2，然后broadcast 表1 ，再join
方案2，scan表1，scan表2，然后broadcast 表2 ，再join
从成本(只看行数)来看，如果表aa_user 行数远小于bb_order ,那 方案2得出来的成本就是最优的。
下面是示意图
示例 aa_user 的表行数远小于bb_order
public static void main(String[] args) { EnvironmentSettings settings = EnvironmentSettings.inBatchMode(); TableEnvironment tableEnvironment = TableEnvironment.create(settings); Schema schema = Schema.newBuilder().column("count", DataTypes.INT()).column("word", DataTypes.STRING()).build(); Schema schema1 = Schema.newBuilder().column("id", DataTypes.INT()).column("name", DataTypes.STRING()).build(); tableEnvironment.createTemporaryTable("aa_user", TableDescriptor.forConnector("filesystem").schema(schema) .option("path","/Users/xx/IdeaProjects/flink-demo/data/order.csv").format("csv").build()); tableEnvironment.createTemporaryTable("bb_order", TableDescriptor.forConnector("filesystem").schema(schema1) .option("path","/Users/xx/IdeaProjects/flink-demo/data/user.csv").format("csv").build()); // tableEnvironment.executeSql("select * from aa_user").print(); //tableEnvironment.executeSql("select * from aa_user inner join bb_order on `aa_user`.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ec620becc4404ad88186c36f7a2b35c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99444f30275a97b7f255373e8991c414/" rel="bookmark">
			网络安全-安全渗透简介和安全渗透环境准备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. 安全渗透简介1.1 什么是安全渗透？1.2 安全渗透所需的工具1.3 渗透测试流程 2. 使用 Kali Linux 进行安全渗透2.1 下载ISO镜像2.2 下载VMware Workstaion软件2.3 Kali Linux简介2.4 准备Kali Linux环境2.5 Kali Linux初始配置2.6 VIM鼠标右键无法粘贴处理2.7 更换镜像源2.8 更新和升级软件2.9 安装小企鹅中文输入法 前言 who：本文主要写给想了解渗透测试，并搭建环境做实战练习的技术爱好者。
what：主要介绍了安全渗透的概念和使用Kali Linux进行安全渗透。
when：文档创建时间：2024年8月26日
where：作者-松鼠会吃榛子 版本-v1
why：希望读者了解渗透测试，掌握渗透测试环境的搭建。
1. 安全渗透简介 1.1 什么是安全渗透？ 安全渗透测试是一种评估计算机网络系统安全性的方法，它通过模拟恶意黑客的行为来发现并评估系统的弱点、技术缺陷或漏洞。渗透测试的目标是找出潜在的安全问题，以便在实际攻击发生前修复它们。
渗透测试与其他评估方法不同：
通常的评估方法是根据已知信息资源或其他被评估对象，去发现所有相关的安全问题。
渗透测试是根据已知可利用的安全漏洞，去发现是否存在相应的信息资源。相比较而言，通常评估方法对评估结果更具有全面性，而渗透测试更注重安全漏洞的严重性。
透测试有黑盒、白盒、灰盒三种测试方法。
黑盒测试：测试人员不知道任何关于系统的内部信息，模拟外部攻击者。
白盒测试：测试人员拥有系统的内部信息，模拟内部攻击者。
灰盒测试：测试人员拥有部分内部信息，介于黑盒和白盒之间。
渗透测试通常具有两个显著特点：
渗透测试是一个渐进的且逐步深入的过程。渗透测试是选择不影响业务系统正常运行的攻击方法进行的测试。 1.2 安全渗透所需的工具 渗透测试需要一系列工具来辅助完成不同阶段的任务。
splintunhidescrubpscanexaminerhtflawfindersrmdriftnetratsnwipebinwalkddrescuefirstaidkit-guiscalpelgpartedxmountpdfcracktestdiskdc3ddwipeforemostafftoolssafecopysectool-guiscanmemhfsutilsunhidesleuthkitcmospwdexaminermacchangersecuirty-menussrmngrepnc6nwipentfs-3gmcfirstaidkit-guintfsprogsscreennet-snmppcapdiffopenvas-scannerhexeditnetsedrkhunterirssidnstoplabreapowertopsslstripnebulamuttbonesitripwirenanoproxychainsprelude-lmlvim-enhancedprewikkaiftopwgetprelude-managerscamperyum-utilspicviz-guiiptraf-ngmcabbertelnetiperffirstaidkit-plugin-allonensshnethogsvnstatdnstraceruperfaircrack-ngchkrootkitnloadairsnortaidentopkismetpadstrafshowweplabcowpattywavemon 这里只列了一部分工具。渗透测试所需的工具可以在各种Linux操作系统中找到，然后手动安装这些工具。由于工具繁杂，安装这些工具，会变成一个浩大的工程。为了方便用户进行渗透方面的工作，有人将所有的工具都预装在一个Linux系统。其中，典型的操作系统就是本书所使用的Kali Linux。
1.3 渗透测试流程 安全渗透测试一般遵循以下步骤：
规划：确定目标范围、规则和测试时间表。信息收集：收集关于目标的信息，包括公开信息和网络拓扑。漏洞扫描：使用自动化工具寻找潜在的漏洞。漏洞利用：尝试利用发现的漏洞获得系统访问权限。权限提升：一旦获得初步访问权限，尝试获得更高的权限。数据提取：收集敏感数据作为测试的结果。报告编写：记录发现的问题和建议的补救措施。 2. 使用 Kali Linux 进行安全渗透 2.1 下载ISO镜像 官网下载地址:
我使用的镜像： https://cdimage.kali.org/kali-2024.2/kali-linux-2024.2-installer-amd64.iso
2.2 下载VMware Workstaion软件 Sign In (broadcom.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99444f30275a97b7f255373e8991c414/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65c69eafe63bbf65b42c5193f6fe7e68/" rel="bookmark">
			企业产品网络安全日志8月26日-威胁感知建设，三方漏洞升级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在做威胁事件感知的建设工作 其中工作之一是打通AWS DNS Firewall 与 Security Hub。当发生威胁事件时，Security Hub能接收到情报通知。
两者不能直通，需要使用lambda进行触发。
三方依赖组件漏洞升级 三方依赖组件漏洞升级，无论对于哪个公司都是一个挑战性的事情。逐步升级也是对现有产品的一个负责。
我们和开发对漏洞做了划分列表，基本上分为了三类：
1 明确有风险的
2 当前方法未触发风险，但未来可能触发的
3 内网保护的组件
就可以按照这个方向逐步升级或规避。
今天跟部分基础服务开发进行深入沟通，了解了当前升级的挑战，特别是对稳定性的影响。值得思考。
一味的升级，其实在没有架构师规划的情况下，实际并不可控。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ad2aa7128c35d389e57a6d2c7d9737a/" rel="bookmark">
			【初阶数据结构】时间复杂度和空间复杂度（超有趣&#43;超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 作为一位程序员，一颗强有力的好胜心和对知识充满渴望的眼神是必不可少的。如果你还拥有一头秀发，那更是程序员界中的佼佼者（开玩笑）😊。
那假如有一天，保罗作为一名程序员，要与他的好朋友罗宾比较算法的优劣，然而罗宾是一位氪金玩家，电脑的配置出奇的高。此时，保罗写了一个快速排序的算法，而罗宾写了一个冒泡排序的算法。它们两个各自用同一组测试案例在自己的电脑跑，不出所料，罗宾的电脑先完成了任务。
难道这代表罗宾的算法比保罗的算法好吗？本文就是来探讨：如何判断一个算法的好坏。
车速很快，别忘了系安全带哦！
1. 算法效率 如果仅凭完成任务的速度，保罗肯定是不服气的。因为罗宾是个氪金玩家，他的电脑性能远远高于保罗的。
1.1 如何衡量一个算法的好坏 如何衡量一个算法的好坏，是代码量越少还是执行的速度越快来决定呢？
看一下斐波那契数列：
int Fib(int n) { if(n &lt; 3) { return 1; } return Fib(n-1) + Fib(n-2); } 斐波那契数列的递归代码十分简洁，当时它真的好吗？那应该如何衡量其好坏呢？
大胆尝试：大家可以试试给上述形参传入一个50，看看你们的电脑多久能运行出结果。
1.2 算法的复杂度 算法的编写可执行程序后，运行时需要耗费一定的时间资源和空间(内存)资源。因此衡量一个算法的好坏，一般是从时间和空间两个维度来衡量，也就是时间复杂度和空间复杂度。
时间复杂度主要是衡量一个算法的运行快慢，而空间复杂度主是衡量一个算法在运行时所需要的额外空间。
那罗宾的运行算法的效率很快啊，那能不能说罗宾的算法时间复杂度要比保罗算法的时间复杂要低呢？时间复杂度又是如何计算的呢？
2. 时间复杂度 2.1 时间复杂度的定义 时间复杂度的定义：在计算机科学中，算法的是时间复杂度是一个函数（这里的函数是指数学的那个函数），它定量的描述了一个算法的运行时间。
一个算法执行所耗费的时间，从理论上来讲，是不可能算得出来的，只有把你的程序放在电脑上跑起来，才能知道。但是每个算法都要进行上机测试，这样太麻烦了，而且我们每个算法都需要上机测试吗？所以这样就诞生出了时间复杂度的分析方法。
时间算法复杂度的分析方法(重点)：一个算法所花费的时间与其中语句的执行次数成正比，算法中的基本操作的执行次数，为算法的时间复杂度。 也就是说，只要我们能够找到某条语句与问题规模N的函数关系，就能够算出该算法的时间复杂度。
下面给大家一个例子，感受时间复杂度的计算：
// 请计算一下Func1中++count语句总共执行了多少次？ void Func1(int N) { int count = 0; for (int i = 0; i &lt; N ; ++ i) { for (int j = 0; j &lt; N ; ++ j) { ++count; } } //这里执行了N*N次 for (int k = 0; k &lt; 2 * N ; ++ k) { ++count; }//这里执行了2N次 int M = 10; while (M--) { ++count; }//这里执行了10次 printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ad2aa7128c35d389e57a6d2c7d9737a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8f2bdba5974b0aadab9eac371ff67fa/" rel="bookmark">
			【问题解决】Jenkins的Pipeline无法正常后台启动Jar包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题描述排查Jenkins日志启动流水线观察Jar包启动情况初步推测问题问题原因：Jenkins进程管理机制问题解决：改写启动Jar包命令参考文章 问题描述 执行Jenkins的Pipeline，执行结果显示为成功，但是Java程序没有成功启动
排查Jenkins日志 日志中执行的启动Jar包命令为
nohup java -jar /root/jenkins/workspace/Jenkins-Learning-0.0.4-SNAPSHOT.jar Pipeline中配置的启动Jar包命令为
"nohup java -jar ${TARGET_DIR}/${jarName} &gt; ${TARGET_DIR}/mylog.log 2&gt;&amp;1 &amp;" 启动流水线观察Jar包启动情况 [root@jh-centos7 workspace]# jps 8823 war 9945 Jps [root@jh-centos7 workspace]# jps 8823 war 9979 Jenkins-Learning-0.0.4-SNAPSHOT.jar 9966 Jps [root@jh-centos7 workspace]# jps 8823 war 9979 -- process information unavailable 9997 Jps 从上述可以看到，流水线在执行过程中是有一瞬间启动了Jar包的，但是之后进程又消失了
初步推测问题 Pipeline中设置的命令与真正执行时的命令不同，主要区别在于是否有后台启动标识"&amp;"
问题原因：Jenkins进程管理机制 Jenkins的进程管理机制：ProcessTreeKiller。Jenkins会在构建任务结束时，关闭构建任务本身的进程和在构建任务进程中启动的其他进程。
问题解决：改写启动Jar包命令 JENKINS_NODE_COOKIE=dontKillMe nohup java -jar ${TARGET_DIR}/${jarName} &gt; ${TARGET_DIR}/mylog.log 2&gt;&amp;1 &amp; 参考文章 https://blog.csdn.net/weixin_43767360/article/details/131980955
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19d3bc4b5af2eb752fc878db1552812d/" rel="bookmark">
			CRUD的最佳实践，联动前后端，包含微信小程序，API，HTML等(二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CRUD老生常谈，但是我搜索了一圈，发觉几乎是着重在后端，也就是API部分！
无外乎2个思路
1.归总的接口，比如一个接口，实现不同表的CRUD
2.基于各自的表，使用代码生成器实现CRUD
个人来说是推荐2，虽然代码多了，其实结构更加清晰，而且！而且！后端对安全尤为重要！！！
啥？你说前端就不安全了？？？
前端！那不叫安全，那叫用户体验，体验懂否？
后端！那才是安全关口！重要的门户！！！！
如果使用1的方式，你会发觉到后续代码越来越臃肿，各种判断，到最后就像上了重庆的立交桥转个不停！
上次我们说到小程序的页面表单的动态化，先看下本次的要点
既然是系统，那肯定也少不了后台管理端的了，这里我使用的是原生的HTML，如果你喜欢那个VUE，其实可以按照这个思想自己实现！
##！！！VUE是前端点歪了技能树的产物！！！##
WebApi新增 距离上次的一发布后，后端接口我做了如下的调整！在WebApi中
/// &lt;summary&gt; /// 读取AddDto的数据模型 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; [HttpGet] public PasteBuilderHelper.VoloModelInfo ReadAddModel() { var _model = PasteBuilderHelper.ReadModelProperty&lt;WebsiteNoticeAddDto&gt;(new WebsiteNoticeAddDto()); return _model; } /// &lt;summary&gt; /// 读取UpdateDto的数据模型 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; [HttpGet] public async Task&lt;PasteBuilderHelper.VoloModelInfo&gt; ReadUpdateModel(int id) { var _info = await _dbContext.WebsiteNotice.Where(x =&gt; x.Id == id).AsNoTracking().FirstOrDefaultAsync(); if (_info != null &amp;&amp; _info != default) { var dto = ObjectMapper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19d3bc4b5af2eb752fc878db1552812d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d607d09fc40cff7caccb6fbecdcbd47/" rel="bookmark">
			渗透测试工程师面试题总结(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.拿到一个待检测的站，你觉得应该先做什么？
2.mysql 的网站注入，5.0 以上和 5.0 以下有什么区别？
3.在渗透过程中，收集目标站注册人邮箱对我们有什么价值？
4.判断出网站的 CMS 对渗透有什么意义？
5.一个成熟并且相对安全的 CMS，渗透时扫目录的意义？
6.常见的网站服务器容器?
7.mysql 注入点，用工具对目标站直接写入一句话，需要哪些条件？
8.目前已知哪些版本的容器有解析漏洞，具体举例?
9.如何手工快速判断目标站是 windows 还是 linux 服务器？
10.为何一个 mysql 数据库的站，只有一个 80 端口开放？
11.3389 无法连接的几种情况?
12.如何突破注入时字符被转义？
13.在某后台新闻编辑界面看到编辑器，应该先做什么？
14.拿到一个 webshell 发现网站根目录下有.htaccess 文件，我们能做什么？
15.注入漏洞只能查账号密码？
16.安全狗会追踪变量，从而发现出是一句话木马吗？
17.access 扫出后缀为 asp 的数据库文件，访问乱码。如何实现到本地利用?
18.提权时选择可读写目录，为何尽量不用带空格的目录？
19.某服务器有站点 A,B 为何在 A 的后台添加 test 用户，访问 B 的后台。发现也添加上了 test 用户？
20.注入时可以不使用 and 或 or 或 xor，直接 order by 开始注入吗？
21:某个防注入系统，在注入时会提示：统检测到你有非法注入的行为。已记录 您的 ip xx.xx.xx.xx 时间:2016:01-23 提交页面:test.asp?id=15 提交内容:and 1=1 如何利用这个防注入系统拿 shell？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d607d09fc40cff7caccb6fbecdcbd47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6c9fb6667b1e037d128cc40299ccfcc/" rel="bookmark">
			Vue开发者工具安装详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎大家订阅【Vue2+Vue3】入门到实践 专栏，开启你的 Vue 学习之旅！
文章目录 前言一、下载二、安装三、调试 前言 Vue 是一个框架，也是一个生态，其功能覆盖了大部分前端开发常见的需求。本文详细讲解了 Vue 开发者工具的安装。
一、下载 下载网址：https://chrome.zzzmh.cn/index
二、安装 三、调试 在 vscode 运行一个简单的 Vue 程序：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Vue基础&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;h1&gt;{{ message }}&lt;/h1&gt; &lt;/div&gt; &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt; &lt;script&gt; var app = new Vue({ el:"#app", data:{ message:" 你好 Vue! " } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 鼠标右键点“检查”
打开 Vue 开发者工具，即可查看修改数据，进行调试。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6c9fb6667b1e037d128cc40299ccfcc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/158f9fb42031b83999b839795fd299ac/" rel="bookmark">
			2024.8.26 Python，最大子数和与动态规划，最小路径和，分割回文串，字典序排数，最长重复子数组（动态规划）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.最大子数和 接上周的文章：
给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。子数组是数组中的一个连续部分。
示例 1：
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
示例 2：
输入：nums = [1]
输出：1
示例 3：
输入：nums = [5,4,-1,7,8]
输出：23
方法一：
class Solution: def maxSubArray(self,nums:List[int])-&gt;int: tmp=nums[0]	#当前当下的列表和	n=len(nums) res=tmp	#结果 for i in range(1,n): if tmp+nums[i]&gt;nums[i]:	#tmp对nums[i]是有利的，那么就留下tmp res=max(res,tmp+nums[i])	#max的对象是nums[i]+tmp还有res，为什么不需要加tmp是因为判断结束后就已经决定拓展了，res里存了之前的tmp，假如nums[i]是个复数，那么res就胜出了 tmp+=nums[i]	#列表加进nums[i] else:	#说明tmp该丢了	res=max(res,tmp+nums[i],tmp,nums[i])	#在场的各位都最后做一次对比吧最后的波纹了 tmp=nums[i]	#丢了重开 return res 代码逻辑：
这个题为什么不用tmp+nums[i]&gt;tmp来判断，反而是用tmp + nums[i] &gt; nums[i]：
tmp+nums[i]&gt;tmp这个条件只是简单判断加入当前元素是否能让和变大，但它忽略了一个重要情况：如果 nums[i] 本身比 tmp + nums[i] 更大（即当前元素自身的值已经大于累加之前的和），我们就应该重新开始新的子数组，而不是继续扩展之前的子数组。也就是说，添加这个判断的目的不是为了决定要不要nums[i]而是现在要不要tmp也就是说是保留还是新建，是生存还是毁灭问题，tmp如果加了nums[i]比nums[i]还小，那么tmp就该丢了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/158f9fb42031b83999b839795fd299ac/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/20/">«</a>
	<span class="pagination__item pagination__item--current">21/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/22/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>