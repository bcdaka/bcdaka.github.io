<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bebff05e741529a58897f302679e39e/" rel="bookmark">
			利用MongoDB构建现代支付系统｜附《利用AI在支付领域的优势》报告下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MongoDB 支付 通过实时整合和分析任何格式的数据
来丰富支付体验
为消费者提供增值服务和功能
丰富的支付体验 接受并丰富任何支付数据类型 使用灵活的文档数据模型实时整合和处理任何支付数据类型。JSON 文档（与 MongoDB 使用的数据格式相同）是支付数据的标准，包括 SWIFT 4和5、Open Banking API 和 BIAN。
不间断的安全性 通过分布式容错和自动数据恢复功能消除停机和中断。通过与现有实践集成的行业领先的加密、访问控制和数据保护协议来保护客户数据。
API 驱动的支付解决方案 利用结合了第三方最佳产品的组合支付系统，保持竞争力并降低总体拥有成本。通过适用于不同数据格式或结构的灵活数据模型，使开放 API 生态系统中的数据流成为可能。
基于MongoDB构建的现代支付系统 行业领导者选择 MongoDB 作为其始终在线、始终安全、始终可用的支付平台的支柱。
数据丰富 提升原始数据集的价值，使其成为更全面的信息集合，从而实现更多用途。
开放银行 协调您的开放 API生态系统，通过满足任何需求的灵活数据模型，使银行、第三方和消费者之间的数据流动成为可能。
了解您的客户(KYC) 统一从后端支付处理到客户交互的数据，并提供洞察，以创建无缝、互联和个性化的客户旅程。
移动应用程序 启动和扩展始终不间断的安全移动应用程序，将第三方服务与API集成，并加快审批时间以满足客户期望。
欺诈检测 通过应用程序驱动的分析提高识别欺诈的见解速度。与 AI/ML平台集成，实现实时、预测性的欺诈预防。
安全性与合规性 持续备份、跨地区高可用性以及详细的审核日志，让银行可以实时追踪操作。
即时扩展 支付系统必须随着业务和监管要求的发展而扩展。根据需求自动扩大或缩小规模，优化使用率和成本。
确保高可用性 MongoDB Atlas 提供当今支付平台所需的多云原生可扩展性和高可用性。
在任何地方运行 将数据部署在本地或100多个具有多云环境的区域，享受可靠性、安全性和灵活性并支持合规性。
拥抱实时分析 就地实时分析支付数据，无需ETL或重复。 提高见解速度，提升效率。
保护您的数据 通过分层安全方法(包括客户端字段级加密)，MongoDB Atlas 支持遵守主要安全标准。
支持合规 嵌入式TTL索引以及在线存档和数据湖，简化了监管合规性。
客户案例 Cards2.0计划 富国银行消费贷款执行副总裁/CIO Nadeem Kayani
“MongoDB 每天处理超过 20 TB的数据，并支持80多个微服务。我们目前正在使用操作数据存储（ODS）来运行奖励和忠诚度计划。
🔗点击阅读客户案例：Wells Fargo借助MongoDB推出下一代银行卡支付平台
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bebff05e741529a58897f302679e39e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2237552855ff45c571ba70c09dde0175/" rel="bookmark">
			【轮询负载均衡规则算法设计题】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目描述 给定n台主机（编号1~n）和某批数据包，数据包格式为（抵达主机时刻，负载量）。这里数据每个时刻最多只有1条数据到达。负载量表示该主机处理此数据包总耗时。请计算轮询负载均衡规则下，哪些主机负载最高（即处理数据的负载量总和），升序输出主机编号。
二、说明 轮询负载均衡规则：如果3台主机均空闲，分配方案为1，2，3，1，2…。如果某主机繁忙，则跳过该主机；如果某条数据到达时所有主机均繁忙，则丢弃这条数据。
三、举例 输入
3
1 15
2 10
12 10
5 10
6 10
30 15
32 10
输出
1 3
四、算法 public int[] findHighestHost(int serverNum, Message[] messages) { Arrays.sort(messages, Comparator.comparingInt(m -&gt; m.time)); // times[i]表示第i台主机，下次可处理请求的时刻 int[] times = new int[serverNum]; // 初始值设置为1 Arrays.fill(times, 1); // load[i]表示第i台主机的负载值 int[] loads = new int[serverNum]; // 轮询主机索引，从第1台主机开始 int start = 0; for (Message message : messages) { boolean flag = false; int j = 0; for (int i = 0; i &lt; serverNum; i++) { j = (start + i) % serverNum; if (times[j] &lt;= message.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2237552855ff45c571ba70c09dde0175/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0aef8959d95e06282f7a76bcc3cd3465/" rel="bookmark">
			WebGL 绘制正五边形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		还是大剑师兰特：曾是美国某知名大学计算机专业研究生，现为航空航海领域高级前端工程师；CSDN知名博主，GIS领域优质创作者，深耕openlayers、leaflet、mapbox、cesium，canvas，webgl，echarts等技术开发，欢迎加底部微信（gis-dajianshi），一起交流。
No.内容链接1Openlayers 【入门教程】 - 【源代码+示例300+】 2Leaflet 【入门教程】 - 【源代码+图文示例 150+】 3Cesium 【入门教程】 - 【源代码+图文示例200+】 4MapboxGL【入门教程】 - 【源代码+图文示例150+】 5前端就业宝典 【面试题+详细答案 1000+】 文章目录 使用WebGL绘制正五边形涉及到定义五边形的顶点坐标，并使用这些坐标来渲染形状。以下是使用WebGL绘制正五边形的示例代码：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;WebGL Pentagon&lt;/title&gt; &lt;style&gt; body { margin: 0; } canvas { width: 100%; height: 100%; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id="myCanvas" width="500" height="500"&gt;&lt;/canvas&gt; &lt;script&gt; var canvas = document.getElementById('myCanvas'); var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl'); if (!gl) { alert('WebGL not supported.'); return; } // 设置画布大小 gl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0aef8959d95e06282f7a76bcc3cd3465/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e12c83475788bd1ea54d7d48e95009f0/" rel="bookmark">
			阿里云ECS上搭建Hadoop分布式环境（会更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Java的安装 使用命令行工具安装（需要公网ip为60.205.163.33的实例提前启动nginx服务）
# 使用wget命令从指定的IP地址下载JDK安装包到/home/jdk目录 # -P 参数用于指定下载文件的保存路径，这里是 /home/jdk # 请注意，如果IP地址发生变化，需要相应地更新命令中的IP地址部分 wget http://60.205.163.33/download/jdk/jdk-8u261-linux-x64.tar.gz -P /home/jdk 1.3 解压jdk、配置、检验 step1：在云实例中创建一个存放jdk解压后的目录，
mkdir -p /opt/jdk1.8.0 step2：将 jre-8u261-linux-x64.tar.gz 解压到 /opt/jdk1.8.0 目录下
#将文件 jdk-8u261-linux-x64.tar.gz 从 /home/jdk/ 目录解压到 /opt/jdk1.8.0 目录 tar -zxvf /home/jdk/jdk-8u261-linux-x64.tar.gz -C /opt/jdk1.8.0 step3：勾选上显示/隐藏实例菜单栏：
step4：
检验是否解压成功：左侧查看 /opt/jdk1.8.0 目录，是否和图片中的目录一致。
step5：修改环境变量
vim /etc/profile 在profile文件中添加以下内容：（第一行路径需根据自己的存放路径修改）
# 设置环境变量 JAVA_HOME 指向 JDK 的安装路径 # 这里假设 JDK 安装在 /opt/jdk1.8.0/jdk1.8.0_261 export JAVA_HOME=/opt/jdk1.8.0/jdk1.8.0_261 # 设置环境变量 JRE_HOME 指向 JAVA_HOME 下的 jre 目录 # 这通常是 JDK 的一部分，包含 Java 运行时环境 export JRE_HOME=$JAVA_HOME/jre # 设置 CLASSPATH 环境变量，它告诉 Java 程序在哪里查找类和库 # .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e12c83475788bd1ea54d7d48e95009f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b42fa5deb600d0478553e518a01fffbd/" rel="bookmark">
			力扣每日一题 6/11 暴力搜索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博客主页：誓则盟约系列专栏：IT竞赛 专栏关注博主，后期持续更新系列文章如果有错误感谢请大家批评指出，及时修改感谢大家点赞👍收藏⭐评论✍ 419.甲板上的战舰[中等] 题目： 给你一个大小为 m x n 的矩阵 board 表示甲板，其中，每个单元格可以是一艘战舰 'X' 或者是一个空位 '.' ，返回在甲板 board 上放置的 战舰 的数量。
战舰 只能水平或者垂直放置在 board 上。换句话说，战舰只能按 1 x k（1 行，k 列）或 k x 1（k 行，1 列）的形状建造，其中 k 可以是任意大小。两艘战舰之间至少有一个水平或垂直的空位分隔 （即没有相邻的战舰）。
输入：board = [["X",".",".","X"],[".",".",".","X"],[".",".",".","X"]] 输出：2 示例 2：
输入：board = [["."]] 输出：0 提示：
m == board.lengthn == board[i].length1 &lt;= m, n &lt;= 200board[i][j] 是 '.' 或 'X' 题目分析： 这道题可能题目有点表达不清晰，会让人误以为只有在第1行的某个列和第1列的某行才能算数，其实并不是这个意思。他的意思是每个战舰都要和周围的分开，当他们相连接的时候是被看做一个战舰的，只有被隔开的两个战舰才被认为是两个战舰，然后搜查一共有多少艘战舰。
最本质的思路就是暴力搜索，遍历一遍看看有几个符合题意的X，统计并返回即可。以下是代码实现：
class Solution: def countBattleships(self, board: List[List[str]]) -&gt; int: a1,a2,res=len(board),len(board[0]),0 # a1是行 a2是列 res是战舰总数 for i in range(a1): for j in range(a2): if (j==0 and board[i][j]=='X' and ((i&gt;0 and board[i-1][j]!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b42fa5deb600d0478553e518a01fffbd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dae01d3d1302a1716279440904e9bb1/" rel="bookmark">
			【机器学习】GPT-4中的机器学习如何塑造人类与AI的新对话
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🚀时空传送门 🔍引言📕GPT-4概述🌹机器学习在GPT-4中的应用🚆文本生成与摘要🎈文献综述与知识图谱构建🚲情感分析与文本分类🚀搜索引擎优化💴智能客服与虚拟助手🌂语言翻译🍀文本生成与写作辅助⭐教育领域🌠多模态处理🐒性能优化与模型升级 ☀ 机器学习在GPT-4发展中的挑战与机遇 🔍引言 随着人工智能技术的飞速发展，自然语言处理（NLP）领域迎来了新的里程碑——GPT-4。GPT-4以其巨大的参数量、卓越的语言生成能力和多模态处理能力，成为当前NLP领域最热门的模型之一。本文将详细探讨机器学习在GPT-4中的应。
📕GPT-4概述 GPT-4是OpenAI推出的第四代生成式预训练Transformer模型，具有数万亿级别的参数量。它采用多层Transformer架构，能够捕捉语言中的细微差别和复杂结构，生成流畅连贯的文本。此外，GPT-4还引入了多模态处理能力，能够处理文本、图像、音频等多种数据类型，为NLP、计算机视觉和语音识别等多个领域带来了新的可能性。
🌹机器学习在GPT-4中的应用 🚆文本生成与摘要 GPT-4具有强大的文本生成能力，可以应用于各种文本生成任务，如文章创作、新闻报道、邮件编写等。此外，GPT-4还可以用于文本摘要任务，通过机器学习算法对文本进行自动分析和总结，提取关键信息并生成简洁的摘要。
代码示例（Python）：
import openai openai.api_key = "YOUR_API_KEY" prompt = "请写一篇关于机器学习在GPT-4中应用的文章。" response = openai.Completion.create(engine="text-davinci-003", prompt=prompt, max_tokens=100) print(response.choices[0].text) 🎈文献综述与知识图谱构建 GPT-4可以应用于文献综述任务，通过机器学习算法对大量文献进行自动分析、归纳和总结，帮助研究人员快速了解某个领域的研究现状和发展趋势。此外，GPT-4还可以用于知识图谱构建任务，通过从文本中提取实体、关系等信息，构建出结构化的知识图谱，为智能问答、推荐系统等应用提供支撑。
代码示例（Python，这里仅展示文献检索部分，实际构建知识图谱需要更复杂的处理流程）：
# 使用GPT-4插件ScholarAI进行文献检索（假设有相应的插件或API） # 此处仅为示意，实际使用时需要调用相应的API或插件 search_term = "机器学习在GPT-4中的应用" result = scholar_ai.search(search_term, num_results=10) for item in result: print(f"标题: {item['title']}") print(f"作者: {item['authors']}") print(f"摘要: {item['abstract']}") print("\n") 🚲情感分析与文本分类 GPT-4可以应用于情感分析和文本分类任务。通过机器学习算法对文本进行情感倾向分析或类别划分，可以为企业或政府提供舆情监控、产品评价等服务。例如，可以使用GPT-4对社交媒体上的用户评论进行情感分析，了解用户对某个产品或事件的态度和看法。
代码示例（Python，这里使用简化的方法，实际应用中可能需要更复杂的模型和算法）：
# 假设已经有一个训练好的情感分析模型（如BERT、RoBERTa等） # 以下代码仅为示意，实际使用时需要加载模型并进行预测 from transformers import BertTokenizer, BertForSequenceClassification import torch tokenizer = BertTokenizer.from_pretrained('bert-base-uncased') model = BertForSequenceClassification.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8dae01d3d1302a1716279440904e9bb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51bf71c048b49122ce36bdc9cc65d8b7/" rel="bookmark">
			spark学习总结第2天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 1- Spark词频统计案例加强-hdfs读写（掌握）2- Spark on Yarn 环境—验证案例（操作）3- spark-submit命令（了解）4- PySpark程序与Spark交互流程（掌握）5- 常见面试题（掌握） 文章目录 系列文章目录前言一、1- Spark词频统计案例加强-hdfs读写（掌握）1、读写HDFS代码详解： 2、链式编程实现代码详解： 3、对结果排序代码详细实现： 4、案例相关算子小结5、PySpark的异常排查流程6、代码模板设置 二、Spark On Yarn环境配置（操作）1、Spark On Yarn的本质2、环境启动相关指令2.1启动sparkonyarn 3、提交应用验证环境（掌握）4、如何查看日志5、Spark On Yarn两种部署方式（掌握） 三、spark-submit命令（了解）四、PySpark程序与Spark交互流程（掌握）1、client_Spark集群2、cluster_Spark集群3、client on Yarn集群4、cluster on Yarn集群 五、常见面试题1.请列举常见的RDD算子,以及对应功能2.请列举常见的spark_submit参数,以及对应功能3.请表述下spark中核心概念4.请表述下cluster on yarn集群的执行流程 前言 本文主要介绍了，
一：
1.spark读写hdfs案例
2.spark链式编程
3.spark排序案例
二:环境验证
验证spark on yarn 环境
三：pyspark程序与spark交互流程
四:整理面试题
1.请列举常见的RDD算子,以及对应功能
2.请列举常见的spark_submit参数,以及对应功能
3.请表述下spark中核心概念
4.请表述下cluster on yarn集群的执行流程
一、1- Spark词频统计案例加强-hdfs读写（掌握） 1、读写HDFS 1- 启动Hadoop集群 start-all.sh 2- 验证Hadoop集群是否运行正常 jps 访问 http://node1:9870 http://node1:8088 3- 上传文件到HDFS 准备一个content.txt文件，内容如下 hello hello spark hello heima spark 接着将content.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51bf71c048b49122ce36bdc9cc65d8b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08fe71f5aa7d5a64fec1cc8929146ad7/" rel="bookmark">
			Mac电脑-后端开发通用配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MacOS文件系统（文件夹介绍） 1. 文件系统目录结构 Mac OS X 的文件系统采用了类 Unix 的文件系统结构，主要采用了树形目录结构。目录结构如下
/Applications 目录：存放所有的应用程序。
/Library 目录：存放各种系统级别的库文件，如启动项、驱动程序等。
/System 目录：存放系统级别的文件，如核心驱动程序等。
/Users 目录：存放所有用户的个人文件，以及用户的配置和设置等。
/Volumes 目录：存放所有挂载的存储设备和卷。
另外，还有一些其他的目录和文件，例如：
/bin 和 /sbin 目录：存放系统基本命令和维护程序。
/etc 目录：存放系统配置文件和脚本。
/tmp 目录：存放临时文件。
/usr 目录：存放 Unix 系统下的用户可执行文件、库文件和文档等文件。
/var 目录：存放运行时文件和日志文件。
注：来自chat gpt
2. /usr介绍 简介：存放系统和用户级别的应用程序和文件。这个文件系统很大，因为通常程序都安装在这里。子文件夹： /usr/bin: 存放系统命令和一些基本的应用程序，如ls、cp 等。/usr/local: 存放本地自编译的软件程序，一般是一些第三方的软件，如Apache、MySQL 等。/usr/include: 存放头文件，这些头文件用于开发软件时使用。/usr/lib: 存放系统库文件，这些库文件用于编译运行各种程序。/usr/src: 存放源代码，这里存放的是 Unix 操作系统和一些软件的源代码。/usr/sbin: 存放系统管理员使用的管理性命令，如shutdown、reboot等。/usr/share: 存放系统资源文件，包括一些共享的数据和文档。 接触最多的两个目录： 系统命令：默认路径在/usr/bin 目录下用户命令：默认路径在／usr／local／bin 目录下 Mac系统打开隐藏目录
这些目录对用户不可见，可以打开Finder，使用【command+shift+G】，搜索这个路径 vim 1. 简介 简介：文本编辑器（程序开发工具），从vi发展过来。
学习参考：https://www.runoob.com/linux/linux-vim.html
2. 打开vi编辑器的命令 使用vi ~/.xx命令会打开一个 vi 编辑器，并显示主目录下的所有隐藏文件列表。然后使用 vi 编辑器对这些文件进行编辑和修改。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08fe71f5aa7d5a64fec1cc8929146ad7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4148ffde0c534ad61fa09c9b1ae1cfd8/" rel="bookmark">
			【数据结构】初识数据结构之复杂度与链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【数据结构】初识数据结构之复杂度与链表 🔥个人主页：大白的编程日记
🔥专栏：C语言学习之路
文章目录 【数据结构】初识数据结构之复杂度与链表前言一.数据结构和算法1.1数据结构1.2算法1.3数据结构和算法的重要性 二.时间与空间复杂度2.1算法效率2.2算法的复杂度2.3时间复杂度的概念2.4大O的渐进表示法2.5时间复杂度计算举例 三.空间复杂度四.链表4.1链表的概念及结构4.2链表的分类4.3单链表的实现 后言 前言 哈喽，各位小伙伴大家好！今天我们开启全新的篇章，数据结构。简单来说数据结构就是数据在内存中的管理。今天给大家带来的是数据结构中的复杂度和链表的知识。话不多说，咱们进入正题！向大厂冲锋！
一.数据结构和算法 1.1数据结构 数据结构(Data Structure)是计算机存储、组织数据的方式，指相互之间存在一种或多种特定关系的 数据元素的集合。
1.2算法 算法(Algorithm):就是定义良好的计算过程，他取一个或一组的值为输入，并产生出一个或一组值作为
输出。简单来说算法就是一系列的计算步骤，用来将输入数据转化成输出结果。
1.3数据结构和算法的重要性 目前校园招聘笔试一般采用Online Judge形式， 一般都是20-30道选择题+2道编程题，或者3-4道编程题。
2020奇安信秋招C/C++
美团2021校招笔试
网易2021校招笔试C++开发工程师
可以看出，现在公司对学生代码能力的要求是越来越高了，大厂笔试中几乎全是算法题而且难度大，中小长的笔试中才会有算法题。算法不仅笔试中考察，面试中面试官基本都会让现场写代码。而算法能力短期内无法快速提高了，至少需要持续半年以上算法训练积累，否则真正校招时笔试会很艰难，因此算法要早早准备。
二.时间与空间复杂度 2.1算法效率 如何衡量一个算法的好坏呢？比如对于以下斐波那契数列：
long long Fib(int N) { if(N &lt; 3) return 1; return Fib(N-1) + Fib(N-2); } 斐波那契数列的递归实现方式非常简洁，但简洁一定好吗？那该如何衡量其好与坏呢？这就涉及到算法的复杂度了。
2.2算法的复杂度 复杂度分为空间复杂度和时间复杂度。算法在编写成可执行程序后，运行时需要耗费时间资源和空间(内存)资源 。
因此衡量一个算法的好坏，一般是从时间和空间两个维度来衡量的，即时间复杂度和空间复杂度。
时间复杂度
时间复杂度主要衡量一个算法的运行快慢
空间复杂度
空间复杂度主要衡量一个算法运行所需要的额外空间。
在计算机发展的早期，计算机的存储容量很小。所以对空间复杂度很是在乎。但是经过计算机行业的迅速发展，计算机的存储容量已经达到了很高的程度。所以我们如今已经不需要再特别关注一个算法的空间复杂度。所以我们现在更关注算法的时间复杂度。
复杂度在校招中的考察 2.3时间复杂度的概念 时间复杂度的定义：在计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。一
个算法执行所耗费的时间，从理论上说，是不能算出来的，只有你把你的程序放在机器上跑起来，才能知道。但是我们需要每个算法都上机测试吗？是可以都上机测试，但是这很麻烦，所以才有了时间复杂度这个分析方式。一个算法所花费的时间与其中语句的执行次数成正比例，算法中的基本操作的执行次数，为算法的时间复杂度。
运行时间衡量
为啥不用运行时间衡量。因为算法运行的环境不同，跑出来的时间性能自然不同。我的电脑性能更好，相同因素下，表现的性能自然更好，但是我们衡量的是代码本身。 即：找到某条基本语句与问题规模N之间的数学表达式，就是算出了该算法的时间复杂度。
// 请计算一下Func1中++count语句总共执行了多少次？ void Func1(int N) { int count = 0; for (int i = 0; i &lt; N ; ++ i) { for (int j = 0; j &lt; N ; ++ j) { ++count; } } for (int k = 0; k &lt; 2 * N ; ++ k) { ++count; } int M = 10; while (M--) { ++count; } 我们计算出来的函数就是：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4148ffde0c534ad61fa09c9b1ae1cfd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd5cd81f4be165ea01d5714bf0a6897b/" rel="bookmark">
			Java 期末复习 习题集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 😭 血泪教训❌ 代码补全题❌ 阅读程序写结果 💝 阅读程序✅ 数据类型✅ equals✅ 类✅ 静态变量和成员变量✅ 多态✅ 继承✅ 数组✅ 字符串✅ HashTable✅ 文件读写✅ IO流 💝 程序补全✅ 对象操作✅ 文件读写✅ 内部类 ⭐✅ 匿名内部类 ⭐ 🐒博士练习题💖 单选题💖 填空题（期末不考此题型）💖 判断题💖 程序阅读题1. 读代码写结果2. 读代码写结果3. 读代码写结果4. 读代码写结果5. 读代码写结果 📖 试卷一一、选择题二、判断题 📖 试卷二一、选择题二、判断题 📖 试卷三一、选择题二、判断题 📖 试卷四一、选择题二、判断题 📖 试卷五一、选择题 📚不进🧠二、面向对象编程📙 面向对象特征📙 静态变量和成员变量📙 访问权限修饰符 三、继承📙 子类继承父类方法重写注意事项📙 final 关键字 四、多态📙 多态成员访问特点📙 重写和重载📙 抽象类的特点📙 抽象类的成员特点 五、接口和内部类📙 接口特点📙 接口成员特点📙 抽象类和接口的区别📙 内部类📙 匿名内部类 六、设计模式📙 单例设计模式 ⭐✨ 枚举实现✨ 饿汉式单例✨ 懒汉式单例 📙 简单工厂模式📙 工厂方法模式📙 抽象工厂模式📙 适配器模式 七、GUI编程📙 布局管理器📙 流布局管理器📙 事件响应的三大要素📙 事件响应的步骤📙 AWT概述📙 Swing概述📙 文本控件 八、集合📙 泛型通配符📙 Map 接口概述 九、异常处理📙 异常体系📙 编译型异常 和 运行时异常📙 throws 和 throw📙 finally 十、文件与IO流📙 IO 流基本类十一、多线程📙 线程的生命周期📙 线程状态转换图 十二、网络编程📙 网络模型📙 网络通信三要素📙 UDP 和 TCP📙 Socket 套接字📙 UDP 传输📙 TCP 传输 十三、类加载器与反射📙 类加载流程📙 类加载器📙 反射📙 反射获取构造方法📙 反射获取成员变量📙 反射获取成员方法📙 动态代理 十四、数据库编程📙 SQL 语句📙 JDBC📙 获取数据库连接📙 PrepareStatement 😭 血泪教训 真题如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd5cd81f4be165ea01d5714bf0a6897b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22738d4fe74e9bb7580f7cfa6807478c/" rel="bookmark">
			php实现一个简单的MySQL分页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、案例演示： 二、php 代码 &lt;?php $servername = "localhost"; // MySQL服务器名称或IP地址 $username = "root"; // MySQL用户名 $password = "123456"; // MySQL密码 $dbname = "test"; // 要连接的数据库名称 $port = "3307"; // 要连接的数据库名称 // 创建连接 $dbc = new mysqli($servername, $username, $password, $dbname, $port); // 检查连接是否成功 if ($dbc-&gt;connect_error) { die("连接失败: " . $dbc-&gt;connect_error); } ?&gt; &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;分页&lt;/title&gt; &lt;link rel="stylesheet" href="./css/bootstrap.min.css"&gt; &lt;script src="./js/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="./js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;style&gt; body { width: 100%; overflow: hidden; background: url("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22738d4fe74e9bb7580f7cfa6807478c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a50319e687168fe9e23d03b1231d1aa/" rel="bookmark">
			CB5309高集成国产2.4 GHz射频前端放大器功放芯片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 什么是射频前端？CB5309简介芯片特性 什么是射频前端？ 射频前端是射频收发器和天线之间的一系列组件，主要包括功率放大器(PA)、天线开关(Switch)、滤波器(Filter)、双工器(Duplexer和Diplexer)和低噪声放大器(LNA)等，对射频信号进行过滤和放大。
其中：
1、功率放大器(PA)用于实现发射通道的射频信号放大；
2、天线开关(Switch)用于实现射频信号接收与发射的切换、不同频段间的切换；
3、滤波器(Filter)用于保留特定频段内的信号，而将特定频段外的信号滤除；
4、双工器(Duplexer和Diplexer)用于将发射和接收信号的隔离，保证接收和发射在共用同一天线的情况下能正常工作；
5、低噪声放大器(LNA)用于实现接收通道的射频信号放大。
CB5309简介 CB5309是高度集成的2.4 GHz 前端模块 （FEM），内部集成了2.4 GHz单刀双掷（SPDT）发射/接收 （T/R）开关、带旁路的2.4 GHz低噪声放大器 （LNA）和2.4 GHz 功率放大器 （PA）用于大功率802.11ac应用和系统。
LNA和PA禁用功能可确保关闭模式下的低泄漏电流。包括一个集成的功率检测器，以提供
系统内的闭环功率控制。
CB5309主要应用在网通路由器WIFI模式下，802.11AC模式下最大可提供22dBm的输出功率和-35的 EVM.也可以应用于2.4G的非标双模对讲机上，在1M带宽的低速率模式下，可以最高提供29dBm的功率输出，在天线设计良好的条件下，可以最远传输1~2KM距离。
CB5309结构框图：
芯片特性 • 集成高性能2.4Ghz PA，带旁路的LNA和收发开关
• 完全匹配的输入和输出
• 集成功率检测器和定向耦合器
• 发射增益：28.5dB
• 接收增益：14dB
• 发射功率： +22.5 dBm @ 1.8% EVM, VHT40, MCS9, 5 V
• 发射功率：+23.5 dBm @3% EVM, HT40, MCS7,5 V
• 封装尺寸：QFN24 3*5mm (MSL3)
私我获取选型参考、技术资料及支持~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4c5ed2584b642bc9562d0a7e89eb14d/" rel="bookmark">
			Mac M1：通过docker安装RocketMQ、RocketMQ-Dashboard
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0. 引言 最近本地启动以前docker安装的rocketmq发现报错了，因为是从老mac迁移过来的，发现支持的芯片还是amd的，于是重新在docker下安装rocketmq，并记录下步骤，方便大家后续参考。
1. 步骤 1、先下载项目源码
git clone https://github.com/apache/rocketmq-docker.git 2、在官方项目rocketmq-docker中已经说明了docker安装rocketmq的步骤，因此我们只需要根据官方的提示执行即可
2、生成镜像
# 进入刚才下载的源码文件夹，然后进入image-build路径 cd image-build # 这里RMQ-VERSION换成你想要安装的版本，比如我这里是4.8.0 sh build-image.sh 4.8.0 BASE-IMAGE 3、因为是arm芯片，执行这一步会报如下错误：
ERROR: failed to solve: eclipse-temurin:8-jdk-alpine: no match for platform in manifest 其原因就是因为这里编译时官方指定的jdk版本是x86的，也就是amd芯片的，很明显和arm芯片不符合，在github中也有该问题的详细解释和解决之法：https://github.com/apache/rocketmq-docker/issues/89
具体的原因大家有兴趣可以详细查看，这里我们直接讲解决的办法，就是在编译的时候，执行系统为centos，让其选择安装为适配了arm的jdk，指令如下：
sh build-image.sh 4.8.0 centos 这里耐心等待下载完成
4、下载完成后，执行docker image可以查看镜像，如下最新的一个就是我们刚刚编译的镜像，我这里底下的就是之前amd架构的镜像，已经不能适用
5、接下来我们继续编译rocketmq管理后台的镜像，当然如果你不需要可以跳过这步，早期版本管理后台是在rocketmq项目中的rocketmq-console模块，现在已经单独提取出来，叫rocketmq-dashboard项目。项目地址：https://github.com/apache/rocketmq-dashboard
该项目简介中也告诉我们docker的安装方法了，但官方编译的镜像也是基于amd版的jdk的，需要我们单独编译
6、下载源码到本地
git clone https://github.com/apache/rocketmq-dashboard.git 7、修改项目src/main/docker下的Dockerfile文件，将其中的java调整为支持arm芯片的版本openjdk:8
#FROM java:8 FROM openjdk:8 VOLUME /tmp ADD rocketmq-dashboard-*.jar rocketmq-dashboard.jar RUN sh -c 'touch /rocketmq-dashboard.jar' ENV JAVA_OPTS="" ENTRYPOINT [ "sh", "-c", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4c5ed2584b642bc9562d0a7e89eb14d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15fffdf11c2449b97d6a1ec404505468/" rel="bookmark">
			新手怎么使用GitHub?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GitHub新手使用指南，涵盖了从注册、创建仓库、版本控制基本操作到SSH密钥配置等关键步骤：
第一步：注册与登录 访问GitHub官方网站：https://github.com。点击页面右上角的"sign up"按钮开始注册账号。输入有效的电子邮件地址，设置用户名和密码，按照提示完成验证步骤。 第二步：创建仓库 登录后，点击右上角的"+“号，然后选择"New repository”。在新建仓库界面填写相关信息： Repository name（仓库名）：给你的项目起个名字。Description（描述）：简短介绍你的项目内容。Public/Private（公开/私有）：选择是否公开你的代码。Initialize this repository with（初始化仓库）：可以选择立即添加README文件等初始内容。Add .gitignore：选择适用你项目的.gitignore模板，用于忽略不需要版本控制的文件。Choose a license（选择许可证）：为你的项目选择合适的开源许可证。 第三步：版本控制操作 克隆已有仓库到本地 找到你想要克隆的仓库，点击"Code"按钮获取仓库的HTTPS或SSH地址。使用终端（如Git Bash）在本地电脑相应目录下执行：git clone [仓库地址] 创建、切换和合并分支 创建新分支：git checkout -b [新分支名] 切换分支：git checkout [分支名] 将分支内容合并到主分支（如master）：git checkout master git merge [分支名] 提交更改 添加文件变动到暂存区：git add . 或者针对单个文件：git add [文件名] 提交更改并附带说明：git commit -m "本次提交的说明信息" 将本地分支的更改推送到GitHub远程仓库：git push origin [分支名] 如果是主分支（通常是master或main），则直接：git push origin master 第四步：配置SSH密钥 在本地生成SSH密钥：
ssh-keygen -t rsa -b 4096 -C "你的邮箱@example.com" 一路回车，会在默认路径下生成一对公钥和私钥文件。
查看并复制公钥内容：
cat ~/.ssh/id_rsa.pub 复制显示的公钥文本。
在GitHub个人设置（Settings）中找到"SSH and GPG keys"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15fffdf11c2449b97d6a1ec404505468/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/940d15ed080f07e00af3f06872fd500a/" rel="bookmark">
			鸿蒙&#43;flutter 干货来咯！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好多人在纯撸鸿蒙，极少公司走鸿蒙+flutter的路线，你们想走这个路线的，我给你们趟坑了我做的时候是24年3月份，那会好多库 不支持，让给官方提供了一下我的项目里面的库，后来他们填完，基本一半 不支持，如今6月份了，适配的差不多了，flutter_flutter 也升级了，对应鸿蒙api12的 flutter版本也已经升级了。
如何在MacOS 上使用 Flutter 构建鸿蒙App
1、相关库主要是2个 Flutter 3.7.12 https://gitee.com/openharmony-sig/flutter_flutter
flutter 引擎 https://gitee.com/openharmony-sig/flutter_engine
2、环境相关配置 如何在MacOS 上使用 Flutter 构建鸿蒙App
看这个靠谱mac配置环境变量
如何windos上使用flutter 构建鸿蒙app
可以看看windos配置环境变量 （没验证哈，博主用的mac）
3、最后mac的配置表如下 open ~/.zshrc 打开配置页面
下面是我的flutter +鸿蒙相关的 配置信息
export NVM_DIR="$HOME/.nvm" [ -s "$NVM_DIR/nvm.sh" ] &amp;&amp; \. "$NVM_DIR/nvm.sh" # This loads nvm [ -s "$NVM_DIR/bash_completion" ] &amp;&amp; \. "$NVM_DIR/bash_completion" # This loads nvm bash_completion # HomeBrew export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles export PATH="/usr/local/bin:$PATH" export PATH="/usr/local/sbin:$PATH" eval "$(/opt/homebrew/bin/brew shellenv)" # HomeBrew END #JAVA export PATH="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/940d15ed080f07e00af3f06872fd500a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/053a8f8e7328f74242119095c27b6236/" rel="bookmark">
			前端mock数据 —— 使用Apifox mock页面所需数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端mock数据 —— 使用Apifox 一、使用教程二、本地请求Apifox所mock的接口 一、使用教程 在首页进行新建项目：
新建项目名称：
新建接口：
创建json：
请求方法： GET。URL： api/basis。响应类型： json，响应内容： 导入后端json响应：
点击快捷请求自动创建mock：
设置mock规则：
请求成功： 可点击发送 -&gt; 返回成功的响应
二、本地请求Apifox所mock的接口 使用postman请求mock接口：
说明：postman请求成功则说明该接口能在前端页面中进行调用
前端页面中调用mock接口： // request.ts // 是自己mock的数据'http://127.0.0.1:4523/m2/4073666-0-default/150678222'; // mock接口及返回的参数 export function list(params?: any): Promise&lt;resultVO&gt; { return request.get('http://127.0.0.1:4523/m2/4073666-0-default/150678222', { params, }); } // 页面调用界面 &lt;template&gt; &lt;div :request="request"&gt;&lt;/div&gt; &lt;/template&gt; &lt;script lang="ts"&gt; import { defineComponent } from 'vue'; import { list } from '@/services/Basis'; export default defineComponent({ name: 'Basis', components: { }, setup() { function request() { // 注意：不能直接使用.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/053a8f8e7328f74242119095c27b6236/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cc31f37e56310e8039cbfffa05f688a/" rel="bookmark">
			uni-app 小程序：显示图片并且点击图片展示大图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果如图所示：
在页面显示一张图片，然后点击该张图片后显示大图。点击大图就可以关闭大图。
实现的主要代码如下：
&lt;image :src="imgpath" mode="aspectFill" @click="imgPreview(imgArr)"&gt;&lt;/image&gt;
其中imgpath为图片路径，imgArr为图片路径组成的数组。
图片预览的方法如下：
imgPreview(url) {
uni.previewImage({
indicator: "none",
loop: false,
urls: url,
})
},
以上方法就是小程序实现点击小图查看大图的方法了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/149c1c3a7c8f21c470f1030a28bdef03/" rel="bookmark">
			MyBatis-PageHelper 源码解说
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		归档 GitHub: MyBatis-PageHelper-源码解说 总说明 源码仓库： https://github.com/pagehelper/Mybatis-PageHelper克隆：git clone https://github.com/pagehelper/Mybatis-PageHelper.git切分支（tag）：git checkout masterJDK: 17 单元测试 参考：com.github.pagehelper.test.reasonable.PageTest @Test public void testMapperWithStartPage() { SqlSession sqlSession = MybatisReasonableHelper.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); try { // PageHelper.startPage(20, 50); // 超出总页数时，会自动改为查询最后一页 PageHelper.startPage(4, 50); // 开启分页，ref: sign_m_110 List&lt;User&gt; list = userMapper.selectAll(); // 分页拦截，ref: sign_m_210 PageInfo&lt;User&gt; page = new PageInfo&lt;User&gt;(list); } } hsqldb\mybatis-config-reasonable.xml &lt;configuration&gt; &lt;plugins&gt; &lt;plugin interceptor="com.github.pagehelper.PageInterceptor"&gt; &lt;property name="reasonable" value="true"/&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/configuration&gt; UserMapper.xml &lt;mapper namespace="com.github.pagehelper.mapper.UserMapper"&gt; &lt;select id="selectAll" resultType="User"&gt; select * from user order by id -- comment &lt;/select&gt; &lt;/mapper&gt; 原理 开启分页 com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/149c1c3a7c8f21c470f1030a28bdef03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8be3fa3107065f943fa99ef44c3f4b0/" rel="bookmark">
			云原生化有什么特点？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		云原生化，作为一种先进的构建和管理应用程序的方式，不仅代表着技术的革新，更是云计算时代下的必然产物。其核心目标在于充分发掘并发挥云计算平台的各项优势，使应用程序在性能、弹性、可靠性和安全性等方面达到前所未有的高度。
它具有以下几个特点：
1、微服务架构： 云原生化倡导使用微服务架构来构建应用程序。将应用程序拆分为多个小型、独立且可独立部署的服务，每个服务专注于解决特定的业务功能。这样可以提高应用程序的可扩展性、灵活性和可维护性。
2、容器化部署： 云原生应用程序通常使用容器技术(如Docker)进行部署。通过将应用程序及其依赖打包为容器镜像，可以实现跨平台、可移植和一致的部署。容器化还提供了隔离性和资源利用率的优势，使应用程序能够更高效地运行。
3、动态编排和自动化管理： 云原生化强调使用自动化工具和平台来进行应用程序的动态编排和管理。通过使用容器编排工具(如Kubernetes)，可以自动化地管理容器的部署、伸缩、升级和监控等操作。这样可以提高应用程序的弹性和可靠性，并减少人工操作的复杂性。
4、弹性伸缩： 云原生化允许应用程序根据负载情况进行弹性伸缩。通过自动化的容器编排和服务发现，可以根据实际需求动态地添加或移除容器实例，以适应不同的负载变化。这样可以提高应用程序的性能和资源利用率。
5、持续交付和部署： 云原生化倡导使用持续集成和持续交付的方法来实现应用程序的快速交付和部署。通过自动化的构建、测试和部署流程，可以快速、可靠地将应用程序更新推送到生产环境，减少发布的风险和时间成本。
云原生化的特点使得应用程序能够更好地适应云环境的特性，提高开发和运维的效率，同时也能够更好地满足现代应用程序对弹性、可靠性和可扩展性的要求。
​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d348e316cbd51d170a03a54aa1f925a/" rel="bookmark">
			Flink作业执行之 1.DataStream和Transformation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flink作业执行之 1.DataStream和Transformation 1. 滥觞 在使用Flink完成业务功能之余，有必要了解下我们的任务是如何跑起来的。知其然，知其所以然。
既然重点是学习应用程序如何跑起来，那么应用程序的内容不重要，越简单越好。
WordCount示例作为学习数据引擎时hello word程序，再合适不过。接下来便以任务执行顺序为线索开启对源码逐步学习。
public class WordCount { public static void main(String[] args) throws Exception { // 初始化执行环境 Configuration configuration = new Configuration(); configuration.setString("rest.port", "9091"); StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironmentWithWebUI(configuration); env.setParallelism(1); // 业务逻辑转换 DataStream&lt;String&gt; text = env.fromCollection(Arrays.asList("zhangsan", "lisi", "wangwu", "zhangsan")).name("zl-source"); DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; counts = text.map(row -&gt; Tuple2.of(row, 1)) .returns(Types.TUPLE(Types.STRING, Types.INT)) .keyBy(value -&gt; value.f0) .sum(1) .name("counter"); counts.print().name("print-sink"); // 执行应用程序 env.execute("WordCount"); } } 为了使示例代码足够纯粹（直接复制粘贴后即可跑起来的那种），因此在示例中直接使用List数据作为Source。
最后，计划将自己学习的过程以系列文档的形式作为记录。同时作为自己学习过程的记录，可能存在错误或片面理解，欢迎一起讨论。
2. 头疼的“角色” 在学习源码或查阅资料的同时，以下单词（但不限于）一定会频繁出现，它们或者直接对应flink源码中的接口、类名，或者是一些概念名称。初次看到难免让人抓狂。现在先对这些单词混个脸熟。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d348e316cbd51d170a03a54aa1f925a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/266/">«</a>
	<span class="pagination__item pagination__item--current">267/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/268/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>