<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1faf64fad1565380a73febb59e800b96/" rel="bookmark">
			C&#43;&#43;——探索智能指针的设计原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言: RAII是资源获得即初始化， 是一种利用对象生命周期来控制程序资源地手段。 智能指针是在对象构造时获取资源， 并且在对象的声明周期内控制资源， 最后在对象析构的时候释放资源。注意， 本篇文章参考——C++ 智能指针 - 全部用法详解-CSDN博客
看完博主的文章的友友们， 可以去看一下该篇文章， 该作者写的比博主通俗易懂。
目录
为什么需要智能指针
智能指针
auto_ptr
auto_ptr的用法:
auto_ptr的模拟实现:
unique_ptr
unique_ptr的用法
unique_ptr的模拟实现
shared_ptr
shared_ptr的用法
shared_ptr的模拟实现（v1版本）
weak_ptr
weak_ptr的用法:
weak_ptr的模拟实现
shared_ptr中的定制删除器
智能指针坑点 为什么需要智能指针 首先我们来看一下这一个简单的程序:
void func() { int* p = new int; } int main() { func(); return 0; } 在这个程序里面， func中定义了一个指向堆区一块空间的p。 但是当出了作用域后， p指针就被销毁了， 但是p指针指向的空间没有被销毁，这个时候就发生了内存泄漏。
另外一种情况就是我们虽然手动释放了内存， 但是中途发生了异常， 程序发生跳转， 手动释放内存被截胡了。 也会导致发生内存泄漏。
void test() { int* ptr = new int; if (1) { throw "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1faf64fad1565380a73febb59e800b96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/177a793a336fee1807882260fe11402e/" rel="bookmark">
			【融合ChatGPT等AI模型】Python-GEE遥感云大数据分析、管理与可视化及多领域案例应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着航空、航天、近地空间遥感平台的持续发展，遥感技术近年来取得显著进步。遥感数据的空间、时间、光谱分辨率及数据量均大幅提升，呈现出大数据特征。这为相关研究带来了新机遇，但同时也带来巨大挑战。传统的工作站和服务器已无法满足大区域、多尺度海量遥感数据处理需求。
为解决此问题，全球涌现出多个地球科学数据在线可视化计算和分析云平台，如谷歌Earth Engine（GEE）、航天宏图PIE Engine和阿里AI Earth等。其中，Earth Engine功能最为强大，能存取和同步MODIS、Landsat、Sentinel等卫星影像及NCEP等气象再分析数据集，并依托全球上百万台超级服务器提供强大运算能力。目前，该平台包含1000余个公共数据集，每月新增约2 PB数据，总容量超过100PB。与传统的处理影像工具（例如ENVI）相比，Earth Engine在处理海量遥感数据方面具有显著优势，提供了丰富的计算资源和巨大的云存储能力，节省大量数据下载和预处理时间。它代表了遥感数据计算、分析和可视化领域的世界前沿水平，堪称遥感领域的革命性进展。
第一章、理论基础
1、Earth Engine平台及应用、主要数据资源介绍
2、Earth Engine遥感云重要概念、数据类型与对象等
3、JavaScript与Python遥感云编程比较与选择
4、Python基础（语法、数据类型与程序控制结构、函数及类与对象等）
5、常用Python软件包（（pandas、numpy、os等）介绍及基本功能演示（Excel/csv数据文件读取与数据处理、目录操作等）
6、JavaScript和Python遥感云API差异，学习方法及资源推荐
7、ChatGPT、文心一言等AI自然语言模型介绍及其遥感领域中的应用
第二章、开发环境搭建
1、本地端与云端Python遥感云开发环境介绍
2、本地端开发环境搭建
1）Anaconda安装，pip/conda软件包安装方法和虚拟环境创建等；
2）earthengine-api、geemap等必备软件包安装；
3）遥感云本地端授权管理；
4）Jupyter Notebook/Visual Studio Code安装及运行调试。 3、云端Colab开发环境搭建
4、geemap介绍及常用功能演示
5、ChatGPT、文心一言帐号申请与主要功能演示，如遥感知识解答、数据分析处理代码生成、方案框架咨询等。
第三章、遥感大数据处理基础与AI大模型交互
1、遥感云平台影像数据分析处理流程介绍：介绍遥感云平台影像数据分析处理流程的基本框架，包括数据获取、数据预处理、算法开发、可视化等。
2、要素和影像等对象显示和属性字段探索：介绍如何在遥感云平台上显示和探索要素和影像等对象的属性字段，包括如何选择要素和影像对象、查看属性信息、筛选数据等。
3、影像/要素集的时间、空间和属性过滤方法：介绍如何对影像/要素集进行时间、空间和属性过滤，包括如何选择时间段、地理区域和属性条件，以实现更精确的数据分析。
4、波段运算、条件运算、植被指数计算、裁剪和镶嵌等：介绍如何在遥感云平台上进行波段运算、条件运算、植被指数计算、裁剪和镶嵌等操作，以实现更深入的数据分析。
5、Landsat/Sentinel-2等常用光学影像去云：介绍如何在遥感云平台上使用不同方法去除Landsat/Sentinel-2等常用光学影像中的云，以提高影像数据质量。
6、影像与要素集的迭代循环：介绍如何使用遥感云平台的迭代循环功能对影像和要素集进行批量处理，以提高数据分析效率。
7、影像数据整合（Reducer）：介绍如何使用遥感云平台的Reducer功能将多个影像数据整合成一个数据集，以方便后续数据分析。
8、邻域分析与空间统计：介绍如何在遥感云平台上进行邻域分析和空间统计，以获取更深入的空间信息。
9、常见错误与代码优化：介绍遥感云平台数据分析过程中常见的错误和如何进行代码优化，以提高数据分析效率和精度。
10、Python遥感云数据分析专属包构建：介绍如何使用Python在遥感云平台上构建数据分析专属包，以方便多次使用和分享分析代码。
第四章、典型案例操作实践与AI大模型交互
11、机器学习分类算法案例：本案例联合Landsat等长时间序列影像和机器学习算法展示国家尺度的基本遥感分类过程。具体内容包括研究区影像统计、空间分层随机抽样、样本随机切分、时间序列影像预处理和合成、机器学习算法应用、分类后处理和精度评估等方面。
12、决策树森林分类算法案例：本案例联合L波段雷达和Landsat光学时间序列影像，使用决策树分类算法提取指定地区2007-2020年度森林分布图，并与JAXA年度森林产品进行空间比较。案例涉及多源数据联合使用、决策树分类算法构建、阈值动态优化、分类结果空间分析等方面。
13、洪涝灾害监测案例：本案例基于Sentinel-1 C波段雷达等影像，对省级尺度的特大暴雨灾害进行监测。案例内容包括Sentinel-1 C影像处理、多种水体识别算法构建、影像差异分析以及结果可视化等方面。。
14、干旱遥感监测案例：本案例使用40年历史的卫星遥感降雨数据产品如CHIRPS来监测省级尺度的特大干旱情况。案例内容包括气象数据基本处理、年和月尺度数据整合、长期平均值LPA/偏差计算，以及数据结果可视化等方面。
15、物候特征分析案例：本案例基于Landsat和MODIS等时间序列影像，通过植被指数变化分析典型地表植被多年的物候差异（样点尺度）和大尺度（如中国）的物候空间变化特征。案例内容包括时间序列影像合成、影像平滑（Smoothing）与间隙填充（Gap-filling）、结果可视化等方面。
16、森林植被健康状态监测案例：本案例利用20年的MODIS植被指数，对选定区域的森林进行长期监测，并分析森林植被的绿化或褐变情况。涉及影像的连接和合成、趋势分析、空间统计以及可视化等方法。
17、生态环境质量动态监测案例：该案例使用RSEI遥感生态指数和Landsat系列影像，对选定城市的生态状况进行快速监测。主要涉及的技术包括植被指数的计算、地表温度的提取、数据的归一化、主成分PCA分析、RSEI生态指数的构建以及结果的可视化等。
第五章、输入输出及数据资产高效管理与AI大模型交互
1. 本地数据与云端交互：介绍如何将本地端csv、kml、矢量和栅格数据与云端数据相互转换，并讲解数据导出的方法。
2. 服务器端数据批量下载：包括直接本地下载、影像集批量下载，以及如何快速下载大尺度和长时间序列数据产品，例如全球森林产品和20年的MODIS数据产品等。。
3. 本地端数据上传与属性设置：包括earthengine命令使用，介绍如何上传少量本地端矢量与栅格数据并设置属性（小文件），以及如何批量上传数据并自动设置属性，还将介绍如何使用快速上传技巧上传超大影像文件，例如国产高分影像。
4、个人数据资产管理：介绍如何使用Python和earthengine命令行来管理个人数据资产，包括创建、删除、移动、重命名等操作，同时还会讲解如何批量取消上传/下载任务。
第六章、云端数据论文出版级可视化与AI大模型交互
1. Python可视化及主要软件包简介：介绍matplotlib和seaborn可视化程序包，讲解基本图形概念、图形构成以及快速绘制常用图形等内容。
2. 研究区地形及样地分布图绘制：结合本地或云端矢量文件、云端地形数据等，绘制研究区示意图。涉及绘图流程、中文显示、配色美化等内容，还会介绍cpt-city精美调色板palette在线下载与本地端应用等。
3. 研究区域影像覆盖统计和绘图：对指定区域的Landsat和Sentinel等系列影像的覆盖数量、无云影像覆盖情况进行统计，绘制区域影像统计图或像元级无云影像覆盖专题图。
4. 样本光谱特征与物候特征等分析绘图：快速绘制不同类型样地的光谱和物候特征，动态下载并整合样点过去30年缩略图（thumbnails）和植被指数时间序列等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/177a793a336fee1807882260fe11402e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15ffed261e6adf8b9ddfe34d8436eb32/" rel="bookmark">
			安装ant-design-vue的报错集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		20240629vue版本：4.x vue/cli5.x运行项目报错error Replace `xxx` with `··xxx·` prettier/prettier 解决办法_replace `路路路路路路路路` with `路路路路`-CSDN博客
Ant Design 使用出现 Error_ Can‘t resolve ‘_antd_dist_antd.css‘-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04a940cccbcde097b61822b71942bffb/" rel="bookmark">
			探索 Electron：将 Web 技术带入桌面应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Electron是一个开源的桌面应用程序开发框架，它允许开发者使用Web技术（如 HTML、CSS 和 JavaScript）构建跨平台的桌面应用程序，它的出现极大地简化了桌面应用程序的开发流程，让更多的开发者能够利用已有的 Web 开发技能来构建功能强大且跨平台的应用程序，这对于提升开发效率和应用程序的快速交付具有重要意义。
目录
初识Electron
项目工程搭建
加载本地文件
完善窗口行为
配置自动重启
主进程与渲染进程
进程通信
打包应用
初识Electron Electron是一个由GitHub及众多贡献者组成的活跃社区共同维护的开源项目，其兼容Mac、Windows和Linux，可以构建出三个平台的应用程序，这里给出其 官网 和 中文网 ，如下：
像我们平常耳熟能详的vscode就是使用electron来进行开发的，当然还要一些我们常用的工具都是采用electron进行开发，包括我们目前使用的最新版的腾讯QQ，也是采用了electron框架技术实现多端跨平台运行，可以说electron算是一个生态完善、功能齐全、系统简便的框架了。
对于创建常见的桌面GUI工具有以下各种框架，这里简单说一下各种框架之间的优缺点：
名称语言优点缺点QTC++跨平台、性能好、生态好依赖多，程序包大PyQTPython底层集成度高、易上手授权问题WPFC#类库丰富、扩展灵活只支持Windows，程序包大WinFormC#性能好、组件丰富、易上手只支持windows，UI差SwingJava基于AWT，组件丰富性能差，UI一般NW.jsJS跨平台性好，界面美观底层交互差、性能差，包大ElectronJS相比NW发展更好底层交互差、性能差，包大CEFC++性能好，灵活集成，UI美观占用资源多，包大 技术是为业务服务的，选择合适的最重要，如下对框架进行一个概述：
1）底层依赖+调用：CEF、QT、Swing
2）UI美观：Electron（NW.js）、PyQT
3）跨平台：Swing（JAVA）、PyQT（Python、C++）、Electron（前端）
Electron技术架构：Electron的核心组成主要有以下三个部分组成，这里对这三个部分进行简述：
Chromium：渲染引擎，负责显示HTML、CSS和JS内容，提供了现代浏览器的功能
Node.js：后端引擎，提供访问本地文件系统和操作系统功能的能力
Native apis：操作系统或平台提供的原生应用程序接口(API)用于与硬件和系统功能进行交互
Electron说明：它其实就是一个实时的框架，将chromium和node.js整合一个运行环境当中，它允许我们使用web技术来构建桌面应用程序，并可以调用一些api来对不同操作环境下的系统进行相应操作，最终实现一个跨平台并且兼容性极好的桌面应用。
Electron工作流程：Electron开发桌面端应用是如何完成整体的工作呢？这里做一个简单的概述，从下图所示可以看出，桌面应用其实就是运行在不同操作系统上的一款软件，当前我们要讨论的就是在底层系统运行上层发生的一些行为：
具体流程包括初始化项目、创建基本文件结构、编写主进程脚本和前端页面、配置package.json以及启动和调试应用，主进程可以看做是 package.json 中 main 属性对应的文件，一个应用只会有一个主进程，只有主进程可以进行GUI的API操作；渲染进程中Windows展示的界面通过渲染进程表现，一个应用可以有多个渲染进程：
项目工程搭建 接下来我们开始搭建electron项目了，首先我们先打开electron官网，对于新手来说直接阅读官网是一个比较不错的选择，这里我们点击官网的快速入门，往下滑动找到我们想要的信息。
第一步：首先我们先查阅一下自身电脑有无安装node环境，没有的话请参考我之前的文章进行安装：地址 ，安装最新稳定版本的node即可：
第二步：通过 npm init 命令去初始化包，这里就不先直接上框架讲解了，下一篇文章在说，初始化包命令直接一路回车即可：
第三步：接下来我们就需要开始安装electron相关包了，命令如下，安装完成之后配置一下start：
npm install --save-dev electron 第四步：在根目录创建main.js文件用作electron的入口文件，然后编写相应的基础代码，如下：
// app应用；BrowserWindow 窗口 const { app, BrowserWindow } = require('electron') // 当app准备完毕，创建窗口 app.on('ready', () =&gt; { new BrowserWindow({ // 窗口的配置 width: 800, height: 600 }) }) 接下来直接终端执行 npm start 命令，直接运行项目，如下可以看到桌面应用已经启动了，其自带一些桌面的菜单和相关基础按钮：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04a940cccbcde097b61822b71942bffb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40f89fe2e97afc2bfd6c3db0e14a1ea5/" rel="bookmark">
			Day6: 344.反转字符串 541. 反转字符串II 卡码网：54.替换数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目344. 反转字符串 - 力扣（LeetCode） void reverseString(vector&lt;char&gt;&amp; s) { int len = s.size(); int left = 0; int right = len - 1; while (left &lt;= right) { swap(s[left++], s[right--]); } return; } 题目541. 反转字符串 II - 力扣（LeetCode） class Solution { public: void reversek(string&amp; s, int left, int right) { reverse(s.begin() + left, s.begin() + right); } string reverseStr(string s, int k) { //反转前k的函数 int i = 0; int len = s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40f89fe2e97afc2bfd6c3db0e14a1ea5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e22043a38717d980e59cd2a79bcc25c1/" rel="bookmark">
			在 MATLAB 中显示 3D 图像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. 曲面图 (Surface Plot)2. 网格图 (Mesh Plot)3. 散点图 (Scatter Plot)4. 等值线图 (Contour Plot) 前言 提示：这里可以添加本文要记录的大概内容：
项目需要：
提示：以下是本篇文章正文内容，下面案例可供参考
在 MATLAB 中，你可以使用多种函数来显示 3D 图像，包括曲面图（surface plots）、散点图（scatter plots）、等值线图（contour plots）和网格图（mesh plots）等。以下是一些基本的示例，说明如何在 MATLAB 中创建和显示 3D 图像。
1. 曲面图 (Surface Plot) % 创建数据 [X,Y] = meshgrid(-10:0.5:10, -10:0.5:10); Z = sin(sqrt(X.^2 + Y.^2))./sqrt(X.^2 + Y.^2 + eps); % 显示曲面图 surf(X, Y, Z); % 添加标题和轴标签 title('Surface Plot'); xlabel('X-axis'); ylabel('Y-axis'); zlabel('Z-axis'); % 视角设置 view(3); % 设置 3D 视角 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e22043a38717d980e59cd2a79bcc25c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4f420d557d0135914be9cb4cd35baab/" rel="bookmark">
			PySide(PyQt)在图像上画线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、按鼠标左键任意画线 import sys from PySide6.QtWidgets import QApplication, QLabel, QVBoxLayout, QWidget from PySide6.QtGui import QPainter, QPixmap, QMouseEvent, QColor, QPen from PySide6.QtCore import Qt, QPoint class PaintLabel(QLabel): def __init__(self, parent=None): super(PaintLabel, self).__init__(parent) self.setFixedSize(500, 500) self.pixmap = QPixmap(500, 500) # 创建图像 self.pixmap.fill(QColor('#000000')) # 设为黑色 self.setPixmap(self.pixmap) # 设置图像 self.drawing = False self.last_point = QPoint() def mousePressEvent(self, event: QMouseEvent): if event.button() == Qt.LeftButton: self.drawing = True self.last_point = event.position() def mouseMoveEvent(self, event: QMouseEvent): if event.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4f420d557d0135914be9cb4cd35baab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba95f923eecc43d01c4f8d4f8b1e4954/" rel="bookmark">
			Obsidan插件开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 Obidian 开发 Obsidian 基于 Electron 框架开发，其前端主要使用了 HTML、CSS 和 JavaScript，而后端使用了 Node.js。Node.js 是基于 Chrome V8 引擎的 JavaScript 运行环境，使 JavaScript 能在服务器端运行。
在开发 Obsidian 插件时，将涉及 JavaScript 和 Node.js 的相关知识。如：使用 Node.js 提供的模块和 API 来进行文件操作、访问系统资源、处理网络请求等。
2 开发环境 我的开发环境为：VSCode + Node Docker+ Copilot。这样既不影响我的宿主机环境，开发也比较舒服，还可以利用辅助编码工具。
如果想开发 Obsidian 插件，就需要安装 Node.js 环境。Node.js 提供了 JavaScript 运行环境和许多内置模块；同时，安装 Node.js 也会安装 npm，用来管理插件项目的依赖项。
因为之前安装过 node 镜像，这次就直接使用了：
$ docker run --name obdev --rm -v /exports:/exports -it node:16-alpine sh $ npm -v # 8.19.4 3 最简单示例 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba95f923eecc43d01c4f8d4f8b1e4954/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8a82b0903b7d51f268714657c9247a6/" rel="bookmark">
			【C&#43;&#43;】哈希表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、unordered系列关联式容器
二、哈希
2.1 概念
2.2 哈希冲突
2.3 哈希函数
（1）直接定址法
（2）除留余数法
（3）平方取中法
（4）折叠法
（5）随机数法
（6）数学分析法
三、哈希冲突解决方案
3.1 闭散列
3.1.1 线性探测
（1）处理不同类型的key
（2）插入元素
（3）删除元素
（4）扩容
（5）总结
3.1.2 线性探测模拟实现闭散列
3.1.3 二次探测
3.2 开散列
3.2.1 概念 3.2.2 模拟实现开散列
四、模拟实现哈希表和Unordered系列关联式容器
4.1 HashTable.h
4.2 Unordered_Set.h
4.3 Unordered_Map.h
一、unordered系列关联式容器 在C++的STL库中，除了底层为红黑树结构的map和set，还有底层为哈希表的unordered_map和unordered_set
由于红黑树的性质，我们遍历map和set会得到一个有序的序列
而顾名思义，我们遍历unordered_map和unordered_set得到的是一个无序的序列。这两个容器的使用方式与map和set类似，只是底层结构不同，这里就不对二者的使用方式做详细介绍了
二、哈希 2.1 概念 在顺序结构以及平衡树中，元素的key和其存储的位置之间没有关联，因此在查找某个元素时需要经过多次对key的比较。所以搜索的效率取决于搜索过程中的比较次数。在依靠比较的排序算法中，其排序效率也取决于排序过程中元素的比较次数。
是否有一种方法能够不经过任何比较，就能直接知道要查找的元素位置，从而在O(1)的时间复杂度内得到要查找的元素呢？
我们可以构造一种存储结构，通过某种函数能够使元素的存储位置和它的key之间建立一个映射关系，那么在查找该元素时就能直接通过key得到它的存储位置。
这种方法就是哈希（Hash），又称为散列。哈希是一个广义的算法，也可以认为是一种思想
哈希算法中使用的将元素的存储位置和key建立映射的函数称为哈希函数或散列函数，构造出的结构称为哈希表（Hash Table）或散列表。
以26个英文字母为例，我们可以用一个大小为26的数组来存储它们，将每一个下标都与一个字母建立映射关系，例如0为a，1为b。这种线性的映射关系适用于key的范围小且连续的情况，称为直接定址法，在后面会介绍。
又例如计数排序，就是对哈希直接定址法的变形应用。将每个元素与其存储的位置建立映射关系，然后统计这个元素出现的次数。
2.2 哈希冲突 有时，key的范围较大且过于分散，如果此时还使用直接定址法，就会导致空间的浪费。
例如：
此时我们可以使用除留余数法，将key除以一个不大于散列表长度的数，将所得的余数作为映射的哈希地址
将key除以散列表的长度，就使一个范围大且分散的集合存储到一个较小的散列表中了
但是此时出现了一个问题：有不同的值映射到相同的位置上了
这就是哈希冲突（哈希碰撞），即不同的key通过哈希函数计算出了相同的哈希地址，我们把key不同但哈希地址相同的元素称为同义词
2.3 哈希函数 哈希函数是一种建立映射关系的方法，我们使用某种特定的方法处理key得到相对应的哈希地址
常见的哈希函数有：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8a82b0903b7d51f268714657c9247a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd78c19cf9af5480f8142a9f9bcef07a/" rel="bookmark">
			C&#43;&#43;算法与数据结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刷题建议步骤 求职硬通货：一，好的学历，这个要下血本。本科，可以考研，读研。专科，可以专升本，再考研，读研，二，软考，一年考两次，有些科目考一次。考完再找工作的时间成本太高。三，刷题。四，项目经验，理论最重要，但这东西无法量化，主观性太强。
一，学校学习、网课学习、自学一门语言。
二，考过计算机二级或把试题刷熟练。
三，https://zerotrac.github.io/leetcode_problem_rating/#/ 按难道分从低到高把力扣1700分以下的题刷一遍。早期（800题）没有收集难度分，不刷。注意：如果题目涉及到大学数学和算法，请换种容易理解的解法。没有容易理解的解法，则忽略此题。这样的题几乎不存在。孤立的知识点，难学，易忘，学起来的效率低得惊人。
四，按知识点把力扣1700到2000分的题刷一遍。比如：依次刷 前缀和1700到2000分的题目，二分查找1700到2000分的题目 ⋯ \cdots ⋯. 可以参考各网站大家的题单，我的题单基本上是2000分以上的，计划2024年7月1号开始做1700分的题解。
五，按知识点刷2000到2300分的题。
六，按知识点刷洛谷的题，这一步我还要摸索。
以我在新三版公司的经验，实习生大约要1400分，新手正式员工大约1700分。那刷更高的分数有什么意义呢？
一，在小公司当头目，大约需要2000分。算法只是要求之一，而且非主要要求。
二，进大公司，大约需要2100分。算法只是要求之一，而且非主要要求。
三，当算法工程师。
四，爱好。就像刷怪那样。
专科生30岁是个坎，本科生37岁是个坎。如果没把握过，建议刷到2100分。这样主考官至少原意和你谈谈。
力扣对新人非常友好：一，直接告诉那个测试用例有问题。二，不需要处理输入输出。
力扣不适合老人：周赛第一题到第三题，难度分跨度大约400分，周赛第四题（困难）难度分跨度大约1200分。难度分相差400分，很难做出来。难度分相差200，能做出来，但花的时间太多。周赛时，无法得分；学习时，效率太低。
五大算法 五大算法：分治、动态规划、贪心、回溯、分支界限法。
分治和动态规划都是将问题拆分成若干子问题，分治的子问题往往是相互独立的，动态规划的子问题往往相互依赖。回溯法往往求所有解，而分支限界法往往求任意一个解或最优解。回溯法往往是深度优先，分治界限法往往是广度优先或最优优先。
基本 数组
字符串
排序
矩阵
模拟
枚举
字符串匹配
桶排序
计数排序
基数排序
树上启发式合并
括号 数学表达式
字符串 Z 函数（扩展 KMP）
较难理解的字符串查找算法KMP
前后缀分解。
回文： 中心扩展 马拉车
贡献法
分组：
【状态机dp 状态压缩 分组】1994. 好子集的数目
【动态规划】【前缀和】【分组】2338. 统计理想数组的数目
算法 动态规划汇总
背包问题汇总
贪心(证明方法：反证法、数学归纳、临项交换、范围缩放、决策包容性） 反悔贪心
深度优先搜索汇总
C++BFS算法
二分查找算法合集
折半处理
广度优先搜索
回溯
递归
分治
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd78c19cf9af5480f8142a9f9bcef07a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6df7412de669eb938cd24c7697d9e68/" rel="bookmark">
			nginx和CDN应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.代理的工作机制
2.代理服务器的概念
3.代理服务器的作用
4.常见的缓存代理应用
5.nginx缓存代理部署
5.1 yum安装三台nginx
5.2 准备测试界面
5.3 设置nginx缓存服务器配置
5.4 网页测试
6.CDN概念及作用
6.1 CDN的工作过程
6.2 CDN是如何获取内容？
1.代理的工作机制 （1）代替客户机向网站请求数据，从而可以隐藏用户的真实IP地址。
（2）将获得的网页数据（静态Web元素）保存到缓存中并发送给客户机，以便下次请求相同的数据时快速响应。
2.代理服务器的概念 代理服务器是一个位于客户端和原始（资源）服务器之间的服务器，为了从原始服务器取得内容，客户端向代理服务器发送一个请求并指定目标原始服务器，然后代理服务器向原始服务器转交请求并将获得的内容返回给客户端。
缓存代理对于Web至关重要，尤其对于大型高负载Web站点。缓存可作为性能优化的一个重要手段，可以极大减轻后端服务器的负载。通常对于静态资源，即较少经常更新的资源，如图片，css或js等进行缓存，从而在每次刷新浏览器的时候，不用重新请求，而是从缓存里面读取，这样就可以减轻服务器的压力。
3.代理服务器的作用 资源获取：代替客户端实现从原始服务器的资源获取；
加速访问：代理服务器可能离原始服务器更近，从而起到一定的加速作用；
缓存作用：代理服务器保存从原始服务器所获取的资源，从而实现客户端快速的获取；
隐藏真实地址：代理服务器代替客户端去获取原始服务器资源，从而隐藏客户端真实信息。
4.常见的缓存代理应用 本地实现：squid、nginx、varnish
云环境远端实现：CDN
数据库缓存代理：Redis、Memcached
CDN在云场景中 使用比较多 大量广泛使用
Squid和varnish 传统应用 用得不多
性能上Squid和varnish比较好 但是nginx的管理更加方便
5.nginx缓存代理部署 准备三台服务器：192.168.9.114；192.168.9.115；192.168.9.116
5.1 yum安装三台nginx 所有虚拟机
初始化操作 systemctl disable --now firewalld setenforce 0 vim /etc/selinux/config SELINUX=disabled cd /etc/yum.repos.d 将nginx.repo拖入各服务器 yum install -y nginx systemctl enable --now nginx 5.2 准备测试界面 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6df7412de669eb938cd24c7697d9e68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/764cca1e28d088cfa12873eb603ff415/" rel="bookmark">
			【全球首个开源AI数字人】DUIX数字人-打造你的AI伴侣！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 引言1.1 数字人技术的发展背景1.2 DUIX数字人项目的开源意义1.3 DUIX数字人技术的独特价值1.4 本文目的与结构 2. DUIX数字人概述2.1 定义与核心概念2.2 硅基智能与DUIX的关系2.3 技术架构2.4 开源优势2.5 应用场景2.6 安全与合规性 3. DUIX数字人技术特点3.1 开源性与社区支持3.2 跨平台兼容性3.3 低算力要求与广泛适用性3.4 高帧率与流畅体验3.5 真人级的交互质量3.6 网络依赖性小3.7 可定制性与灵活性3.8 实时渲染能力3.9 安全性与合规性 4.效果展示5.部署运行5.1 安卓 SDK 集成教程5.2 iOS SDK 集成教程 9. 结语 1. 引言 1.1 数字人技术的发展背景 数字人技术，作为人工智能领域的一个重要分支，近年来得到了迅猛发展。随着计算能力的提升、算法的优化以及大数据的积累，虚拟数字人不仅在外观上越来越接近真人，而且在交互能力上也日益智能化。数字人技术在客服、教育、娱乐等多个领域展现出广泛的应用前景。
1.2 DUIX数字人项目的开源意义 在这样的技术浪潮中，开源项目扮演着至关重要的角色。开源不仅促进了技术的快速迭代和创新，还降低了技术应用的门槛，使得更多的开发者和企业能够参与到数字人技术的开发和应用中来。DUIX数字人项目的开源，正是这一趋势的体现，它为数字人技术的发展注入了新的活力。
1.3 DUIX数字人技术的独特价值 DUIX数字人项目以其开源的特性，为开发者提供了一个自由度高、可定制性强的平台。开发者可以基于DUIX进行二次开发，创造出符合特定需求的数字人应用。同时，DUIX数字人的跨平台特性，使其能够轻松部署在多种设备上，为用户提供更加丰富和便捷的交互体验。
1.4 本文目的与结构 本文旨在深入探讨DUIX数字人技术的各项特点和应用，为对数字人技术感兴趣的开发者和企业提供一份详尽的技术指南。接下来的章节将详细介绍DUIX数字人的技术特点、SDK功能、交互平台能力，并通过实践案例展示DUIX数字人的应用场景和开发指南。最后，我们将对DUIX数字人技术的未来发展进行展望，并提供相关的参考文献和资源链接。
2. DUIX数字人概述 2.1 定义与核心概念 DUIX数字人，全称为"Dialogue User Interface System"，是一个由硅基智能开发的数字人智能交互平台。它基于先进的人工智能技术，通过集成语音识别（ASR）、语音合成（TTS）、大模型、知识库等能力，实现了数字人的高度拟人化和实时交互。
2.2 硅基智能与DUIX的关系 硅基智能作为DUIX数字人项目的发起者和维护者，致力于推动数字人技术的创新和应用。通过开源DUIX项目，硅基智能不仅展示了其在人工智能领域的技术实力，也为全球开发者提供了一个共同参与和贡献的平台。
2.3 技术架构 DUIX数字人的技术架构包括以下几个关键部分：
云服务SDK：支持2D仿真数字人的实时驱动渲染，通过RTC协议推送视频流服务。本地版SDK：允许数字人在本地硬件设备上渲染，实现实时驱动。交互能力：集成了语音交互技术，包括语音识别和语音合成，以及与大模型和知识库的交互。 2.4 开源优势 DUIX数字人项目的开源特性带来了多方面的优势：
透明性：所有源代码对公众开放，用户和开发者可以查看、学习和修改代码。协作性：全球开发者可以共同参与项目的开发和维护，形成强大的社区支持。创新性：开源促进了技术的快速迭代，开发者可以基于现有代码进行创新和优化。 2.5 应用场景 DUIX数字人可广泛应用于以下场景：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/764cca1e28d088cfa12873eb603ff415/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3dd1e04dab0954519765ea32b6695e4/" rel="bookmark">
			华为手机改变休眠时间 不让手机动不动黑屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在手机中找到设置 并打开
在里面找到显示与亮度 并点开
找到并点击休眠操作项
然后就会弹出 多久进入休眠 可以调久一点
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5d9ca3c897dab84cbd1bb13fdf82df1/" rel="bookmark">
			Flink 从入门到放弃
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 写在前面 程序员闯荡江湖的一生都在与数据打交道，初入江湖时基于 MySQL 的 CRUD，渐入佳境后利用 Redis 实现查询加速及分布式控制，本质上都是数据处理；无论主动/被动，都在利用数据来达成业务/技术目的。自然而然的，数据处理成为了计算机科学的重要研究方向。
我们也充分享受了这门学科发展带来的红利，或许你很难想象，在20世纪50年代之前，人们保存与检索数据的方式还是纸质文档 + 字典目录的人工排列；而现今我们能够依据对性能、事务支持、扩展性、一致性、成本等不同层面的需求，在不同数据库间自由选型。
而在此基础之上，人们又对数据处理能力提出了更高的要求，例如：PB级海量数据、秒级响应速度、Exactly-Once 语义、失败容忍、动态扩缩容等等，此时传统数据库便显得有些捉襟见肘。数据库毕竟更专注于提供存储服务而非计算服务，并且受制于不同的底层实现，其所能提供的计算规模、灵活程度、性能表现等也各不相同（例如 RDBMS 的表关联、事务支持就是 KV 型数据库所无法提供的，KV 型数据库的高性能又是 RDBMS 无法企及的；不同索引数据结构的差异，导致对于点查、范围查支持程度的不同）。当然，目前也存在 OceanBase、Hologres 这类原生高性能实时数据仓库，不在本篇的讨论范围内。
因此，存储介质无关的大数据计算引擎应运而生，提供大量通用的函数算子、支持超大型数据计算规模、分布式调度能力、高性能底层计算处理引擎、高可用中间状态存储等等等等一系列牛逼的能力，能满足一切你想要的。
本文便以大数据实时计算领域的事实标准——Flink为例，带你走进计算引擎的世界。
1 初入江湖：初识 Flink 未见其人先闻其声，来看看对于 Flink 相对官方的介绍：
Apache Flink 是一个用于流处理和批处理的开源分布式数据处理框架，它提供了高吞吐量、低延迟的数据处理能力，可以处理大规模数据并具有容错性。Flink 最初是由德国柏林工业大学的研究人员开发的，现在是 Apache 软件基金会的顶级项目之一。
从这段介绍中可以提取出几个关键词：
Apache（牛逼）流（Streaming）处理/批（Batch）处理分布式高吞吐/低延迟/大规模数据集/容错性···
1.1 Streaming/Batch 什么是流处理/批处理？全程叫：流数据处理/批数据处理，大数据计算引擎的两大核心分支。
「批」并不难理解，一批人、一批货、一批任务（你还认识「批」这个字不？），常见的用于描述数量的抽象单位，一切既定规模的实体都可以描述为「一批」。因此，批数据处理就是对于大小已知数据集的处理。
再说「流」，人流量、车流量、金额流水，都是在描述无边界、数量未知、源源不断的数据流动趋势。因此，流数据处理是对于实时生成、无边界数据集的处理。
简单来说，流是源源不断流动着数据的管道，批是既定规模的数据集。
那「流」与「批」两个概念是否相悖呢？
为流加上“近1小时”、“近3天”的限定词，流有了边界、有了确定的范围，流就成了批；将批无限缩小，将每批数据的取值界限设定为1ms，批的实时性又无限接近于流。显然两者并不相悖，只是出发的视角不同，批可以是有边界的流、流也可以由无数个微型的批构成（Spark 便以此理念实现了流计算）。
这时有同学就说了：“这不小流吗？这我熟啊，我每天都 List.stream().map().collect()。”
在了解流的概念后，显然能够知晓这并不是真正意义上的流，只是套用了流式计算的理念——流计算提供了大量函数算子（如 map/filter/flatMap/sum），融合了函数式编程风格，风格类似对管道中元素分步处理。但必须要分清，这并不是真正的流、也不是真正的流计算，因为数据集是既定规模的、有边界的！一定要对流建立正确的认知！
再说回 Flink，其设计理念就是进行流数据处理，流又有着天然实时性和规模未知的特性，所以 Flink 被称为「大数据实时计算引擎」。现今 Flink 也支持了批计算，因为如上文所言“批就是有边界的流”，做一些简单的转换便可以实现批计算语义，因此 Flink 实际上是「流批一体计算引擎」。
1.2 分布式 分布式这个命题过于大，这里仅介绍分布式在 Flink 中的体现。实际这部分也是 Flink 运行时架构的核心内容，这里仅作枚举和简述，后续会进行详细介绍。
Flink 通常以分布式集群的形式运行，提到分布式集群就绕不开高并发/高可用/动态扩展等基本特性，Flink 也提供了这样的基础能力，内置 ZooKeeper 进行分布式环境协调及高可用保障。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5d9ca3c897dab84cbd1bb13fdf82df1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c838fed12a7e158516e95d9e5910bb57/" rel="bookmark">
			C#面：举列 a=10,b=15，在不用第三方变量的前提下，把a,b的值互换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要在不使用第三方变量的前提下交换a和b的值，可以使用异或运算。异或运算的特性是，对于两个相同的数进行异或运算，结果为0；对于任意数与0进行异或运算，结果为该数本身。因此，可以通过多次异或运算来实现变量的值互换。
以下是实现代码：
int a = 10; int b = 15; a = a ^ b; b = a ^ b; a = a ^ b; Console.WriteLine("a = " + a); // 输出：a = 15 Console.WriteLine("b = " + b); // 输出：b = 10 需要注意的是，这种方法只适用于整数类型的变量。对于其他类型的变量，可能需要使用其他的方法来实现值的互换。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e753e31b16add9fb9007a968d9446c08/" rel="bookmark">
			深入解析链表：解锁数据结构核心奥秘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 链表的定义 链表是一种线性数据结构，由一系列节点组成。每个节点包含两个部分：
数据域（Data）：存储节点的数据。指针域（Pointer）：存储指向下一个节点的地址。 链表的第一个节点称为头节点（Head），最后一个节点的指针域指向空（NULL），表示链表的结束。
二. 链表的结构 1) 单向 / 双向 2) 带头 / 不带头 3) 循环 / 非循环 链表种类丰富多样 重点掌握 单向不带头非循环 链表 可作为其他数据结构的子结构，如 哈希桶、图的邻接表等 笔试常考
三. 实现链表 1) 节点类： 定义链表节点类，每个节点包含数据和指向下一个节点的指针。
public class Node { int data; Node next; public Node(int data) { this.data = data; this.next = null; } } 2) 链表类: 用于实现链表的功能 public class MySingleList { private ListNode head; static class ListNode { int val; ListNode next; ListNode(int val) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e753e31b16add9fb9007a968d9446c08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/583ecd37f41371f8169ea671e9785c2a/" rel="bookmark">
			java八股面试文（带答案，万字总结，精心打磨，建议收藏）堪称2024最强
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多同学会问Java面试八股文有必要背吗？
我的回答是：很有必要。你可以讨厌这种模式，但你一定要去背，因为不背你就进不了大厂。
国内的互联网面试，恐怕是现存的、最接近科举考试的制度。
一、java （1）集合 1.list：LinkedList、ArrayList和Vector LinkedList 接口实现类， 链表， 插入删除， 没有同步， 线程不安全ArrayList 接口实现类， 数组， 随机访问， 没有同步， 线程不安全Vector 接口实现类 数组， 同步， 线程安全 2.set：HashSet和TreeSet HashSet 使用哈希表存储元素，元素可以是null LinkedHashSet 链表维护元素的插入次序TreeSet 底层实现为红黑树，元素排好序，元素不可以是null 3.map：HashMap、TreeMap和HashTable 线程安全 HshaMap线程不安全TreeMap线程不安全HashTable线程安全空值 HashMap一个null key,多个null valueTreeMap不能null key，多个null valueHashTable都不能有null 篇幅限制下面就只能给大家展示小册部分内容了。包括了：Java面试、Spring、JVM、MyBatis、Redis、MySQL、并发编程、微服务、Linux、Springboot、SpringCloud、MQ、Kafka 面试专题
需要全套面试笔记的【点击此处即可】即可免费获取
继承和接口 HashMap继承AbstractMap，实现接口MapTreeMap继承AbstractMap，实现接口NavigableMap(SortMap的一种)HashTable继承Dictionary，实现接口Map顺序 HashMap中key是无序的TreeMap是有序的HashTable是无序的构造函数 HashMap有调优初始容量和负载因子TreeMap没有HashTable有数据结构 HashMap是链表+数组+红黑树TreeMap是红黑树HashTable是链表+数组 4.list、set和map的区别 list：元素按进入先后有序保存，可重复set：不可重复，并做内部排序map:代表具有映射关系的集合，其所有的key是一个Set集合，即key无序且不能重复。 5.HashMap扩容机制 数组的初始容量为16，而容量是以2的次方扩充的，一是为了提高性能使用足够大的数组，二是为了能使用位运算代替取模预算(据说提升了5~8倍)。数组是否需要扩充是通过负载因子判断的，如果当前元素个数为数组容量的0.75时，就会扩充数组。这个0.75就是默认的负载因子，可由构造器传入。我们也可以设置大于1的负载因子，这样数组就不会扩充，牺牲性能，节省内存。为了解决碰撞，数组中的元素是单向链表类型。当链表长度到达一个阈值时（7或8），会将链表转换成红黑树提高性能。而当链表长度缩小到另一个阈值时（6），又会将红黑树转换回单向链表提高性能。对于第三点补充说明，检查链表长度转换成红黑树之前，还会先检测当前数组数组是否到达一个阈值（64），如果没有到达这个容量，会放弃转换，先去扩充数组。所以上面也说了链表长度的阈值是7或8，因为会有一次放弃转换的操作。 6.HashMap中的循环链表是如何产生的（jdk1.7） 由于jdk1.7中采用头插法，在多线程中，存在两个线程同时对链表进行扩容的情况，执行transfer函数（链表数据转移）会导致链表数据倒置，当两个线程同时此操作，就导致链表死循环 7.B树和B+树的区别 B树是二叉排序树进化而来；B+树是分块查找进化而来B+树叶节点包含所有数据，非叶节点仅起到索引作用；B树终端节点及以上都包含数据且不重复（叶节点只是一个概念，并不存在）B+树叶节点包含了全部关键字B+树支持顺序查找和多路查找，B树只支持多路查找 8. HashMap为什么用红黑树而不是AVL树或者B+树 AVL树更加严格平衡，因此可以提供更快的査找效果。因此，对于查找密集型任务使用AVL树没毛病。 但是对于插入密集型任务，红黑树要好一些。B/B+树的节点可以存储多个数据，当数据量不够多时，数据都会”挤在“一个节点中，查询效率会退化为链表。 9.CopyOnWriteArrayList的原理 线程并发访问进行读操作时，没有加锁限制写操作时，先将容器复制一份，再在新的副本上执行写操作，此时写操作是上锁的。结束之后再将原容器的引用指向新容器。注意，在上锁执行写操作的过程中，如果有需要读操作，会作用在原容器上。因此上锁的写操作不会影响到并发访问的读操作。 10.BlockingQueue中有哪些方法 篇幅限制下面就只能给大家展示小册部分内容了。包括了：Java面试、Spring、JVM、MyBatis、Redis、MySQL、并发编程、微服务、Linux、Springboot、SpringCloud、MQ、Kafka 面试专题
需要全套面试笔记的【点击此处即可】即可免费获取
共四组增删API
抛异常：如果操作无法立即执行，则抛一个异常；特定值：如果操作无法立即执行，则返回一个特定的值(一般是 true / false)。阻塞：如果操作无法立即执行，则该方法调用将会发生阻塞，直到能够执行；超时：如果操作无法立即执行，则该方法调用将会发生阻塞，直到能够执行。但等待时间不会超过给定值，并返回一个特定值以告知该操作是否成功(典型的是true / false)。 （2）多线程 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/583ecd37f41371f8169ea671e9785c2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3026229c5dc090684f61f146baa0d07f/" rel="bookmark">
			【postgresql初级使用】数据库安全防护，核心数据是黑客的终极大boss，多层次建立安全体系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库访问安全 ​专栏内容：
postgresql使用入门基础手写数据库toadb并发编程 个人主页：我的主页
管理社区：开源数据库
座右铭：天行健，君子以自强不息；地势坤，君子以厚德载物.
文章目录 数据库访问安全概述 安全体系 网络层 操作系统层 数据库层 存储层 总结 结尾 概述 数据库作维护着系统的全部核心数据，在黑客眼中，它就是终极大boss，需要我们精心呵护。
常常听到撞库，拖库，甚至于删库跑路等事件，我们在部署和维护数据库过程中如何防范这些风险呢？
本文介绍数据库访问安全保护的一些方式，结合postgresql 数据库中有一些安全功能，同时还需要配合操作系统，以及网络部署的一起达到数据库的安全。
安全体系 在postgresql 数据库中提供了一些安全功能，如基于主机的访问HBA，角色与权限，自主访问控制DAC等，这些远远达不到高枕无忧的程度。
对于单个数据库来讲，需要在网络层，操作系统层，数据库层，以及存储层等多个层次进行体系化的安全部署，才能有一个安全的数据库。
数据库的安全，我们从离客户最近的网络，然后到数据库服务器的操作系统，再到数据库服务，然后到数据的存储，这一路径来划分各阶段的安全策略与方法，构建一套安全体系。
网络层，是访问数据的通道；通过配置防火墙策略，限制对数据库服务器的访问；也可以通过代理服务器来进行复杂的过滤；操作系统层，数据库服务所有在操作系统也是多用户的，数据库服务部署采用专用用户，并且配置操作系统级的审计策略；数据库层，最核心的数据库服务层，通过数据库功能进行一些安全控制；如HBA，role, DAC, SSL等等；存储层，对于数据，可以进行各种策略的备份，并且对备份进行安全策略控制； 当然，这一体系只是对于单节点的数据来讲，当然还可以通过主备来对服务进行冗余，达到服务级的安全，这里并没有涉及到。
网络层 一般的大型数据库都通过网络来进行访问，同时一旦经过网络就会经常受到黑客的骚扰，为了限制不安全的网络流量，可以通过以下几种方式。
防火墙 在部署的时候首先会部署访火墙的策略，常用的如iptables，精细化的限制访问的IP范围，以及可以访问的协议。
监听端口与IP 对于postgresql 的服务端口号默认为5432，一般部署时避免使用默认端口。默认端口，如80，8080，22等等，每天都会被黑客不断扫描探测，根据端口号就可以猜测到服务类型。
如果有多个网卡或者网段时，限制数据库监听的网络或者网卡设备。
代理 为了减少数据库服务的管理，可以采用代理服务来处理，客户端请求先由代理服务接收进行精细的过滤，记录，对于通过审查的请求转发到数据库服务。
这样数据库服务可以处在一个相对封闭的网络环境中，只与代理服务进行单一通信，更多网络压力由代理服务进行处理。
操作系统层 数据库部署的机器，一般在安装时都会新建一个操作系统用户，如mysql, oracle，postgresql用户，在此用户下启动数据库服务。
那么在操作系统层面设置安全策略，可以保护数据库服务，以及数据库文件的安全。
操作系统用户与权限 数据库服务所在的操作系统用户，一定是非管理员(administrate/root)权限用户，同时要限制它的登陆，使用强的用户口令并定期更新。
同时平常的客户端使用，使用其它操作用户登陆。
目录与文件的访问权限 数据库的存储在磁盘的目录与文件，设置合适的权限和访问用户，比如Linux下要去掉other的访问权限，不能设置为 777 这种权限，这个在postgresql 中也会进行检查，当启动服务时为root用户时，会报错，当集群目录权限默认为 0600。
操作系统级的审计跟踪 对于像mysql/oracle/postgresql用户的操作，都要进行严格的审计，记录操作，定期检查，当然这些操作可以借助于审计系统软件，进行自动化的运行，可视化展示与自动风险报警。
数据库层 当我们的各种应用连到数据库中时，可以进行select/insert/update/delete操作，也可以进行create/drop/alter，都可以进行这些操作时，就会乱套。
在数据库中有一些精细的控制方法，来划分不同数据库对象的访问权限，来抽象人的管理模式。
基于主机的访问控制 在pg_hba.conf文件可以配置不同的应用访问对应的数据库，甚至访问主机对应的数据库用户，以及不同的用户鉴权方法。
hba配置可以更加精细的化分数据库和用户的功能，与应用系统进行对应。
角色与权限 在postgresql中的数据库对象，它有很多权限可以设置，如创建，删除，数据的查询，数据修改，数据删除，数据插入等。
通过角色role与对角权限进行管理，将相关权限打包为角色，也就是权限的集合，再统一grant给一类用户。
自主访问控制策略 自主访问控制策略DAC，就是通过数据库对角上的权限，与数据库用户所拥有的权限，在用户访问数据对象时进行校验，类型似门禁一样，只有用户拥有访问权限才会执行操作，否则会失败。
权限的管理由超级用户postgres和拥有admin权限的用户进行初始创建，后面可以通过owner进行扩展和传播，当然也可以限制权限的继承传播。
传输层加密 TSL/SSL 在postgresql 中可以配置传输层的通信加密，在服务端和客户端配置 SSL证书，通过TSL来验证服务和加解密通信数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3026229c5dc090684f61f146baa0d07f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36144d4944313b2b3eed1081772ceef9/" rel="bookmark">
			什么是BIOS，如何进入BIOS设置？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是BIOS，如何进入BIOS设置？标题 🖥️ 什么是BIOS，如何进入BIOS设置？——默语的深入解析摘要引言正文内容🧩 什么是BIOS？🔧 如何进入BIOS设置？⚙️ 常见的BIOS设置选项🤔 QA环节📝 表格总结总结未来展望参考资料 博主 默语带您 Go to New World.
✍ 个人主页—— 默语 的博客👦🏻
《java 面试题大全》 《java 专栏》 🍩惟余辈才疏学浅，临摹之作或有不妥之处，还请读者海涵指正。☕🍭
《MYSQL从入门到精通》数据库是开发者必会基础之一~
🪁 吾期望此文有资助于尔，即使粗浅难及深广，亦备添少许微薄之助。苟未尽善尽美，敬请批评指正，以资改进。！💻⌨
🖥️ 什么是BIOS，如何进入BIOS设置？——默语的深入解析 摘要 大家好，我是默语，擅长全栈开发、运维和人工智能技术。在这篇博客中，我将详细介绍什么是BIOS及如何进入BIOS设置。通过这篇文章，希望帮助大家更好地理解和使用BIOS。文章内容包括BIOS的定义、功能、进入BIOS的方法，以及常见BIOS设置。关键词：BIOS设置、进入BIOS、BIOS功能、BIOS教程。
引言 BIOS（Basic Input/Output System）是计算机启动时加载的第一个软件，它负责硬件初始化和系统启动。在这篇文章中，我将深入解析BIOS的工作原理，介绍如何进入BIOS设置界面，并详细说明常见的BIOS设置选项。希望通过这篇文章，能够帮助初学者们更好地掌握计算机基础知识。
正文内容 🧩 什么是BIOS？ BIOS是基本输入输出系统的缩写，它是存储在主板上的一个固件，负责在计算机启动时进行硬件初始化和操作系统的引导。BIOS的主要功能包括：
硬件检测和初始化系统配置和设置引导操作系统 🔧 如何进入BIOS设置？ 进入BIOS设置的方法因计算机品牌和型号不同而有所差异。以下是几种常见的方法：
按键提示法：
开机时按下指定按键：大多数计算机在启动时会显示按键提示，例如“Press F2 to enter BIOS”或“Press DEL to enter Setup”。常见按键：F2、F10、DEL、ESC、F1等。 使用启动菜单：
启动菜单选项：某些计算机提供启动菜单选项，可以通过按下特定按键（如F12）进入启动菜单，然后选择进入BIOS设置。 通过操作系统进入：
Windows 10方法：在Windows 10中，可以通过以下步骤进入BIOS设置： 点击“开始”按钮，选择“设置”。进入“更新和安全”。选择“恢复”，然后点击“立即重启”下的“高级启动”。选择“疑难解答” &gt; “高级选项” &gt; “UEFI固件设置” &gt; “重启”。 ⚙️ 常见的BIOS设置选项 在进入BIOS设置后，可以对以下常见选项进行配置：
引导顺序： 设置计算机启动时的设备优先级，例如选择从硬盘、光驱、USB设备启动。 Boot Sequence: [USB Drive] [CD/DVD Drive] [Hard Disk]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36144d4944313b2b3eed1081772ceef9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/413a58962fe5a42a47f0ea633e7b8418/" rel="bookmark">
			全方位对比PostgreSQL和MySQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
引言
技术架构与设计哲学
起源与发展
数据库引擎
PostgreSQL与MySQL：SQL语法与特性对比概览
PostgreSQL与MySQL高级特性对比：数据类型与事务处理能力
数据类型与功能特性
PostgreSQL与MySQL性能与可扩展性对比
PostgreSQL与MySQL性能与可扩展性深度对比
性能与可扩展性
PostgreSQL与MySQL安全性与合规性对比
PostgreSQL与MySQL应用场景与选择建议指南
选择决策框架：
注意：
引言 简要介绍PostgreSQL与MySQL，强调它们作为开源关系型数据库管理系统的重要性，以及在不同应用场景中的广泛使用。
技术架构与设计哲学 起源与发展 PostgreSQL的根源可以追溯到伯克利的POSTGRES项目，该项目始于1986年，是学术界对数据库管理系统探索的成果。旨在推动数据库技术的边界，强调理论的严谨性和对SQL标准的严格遵循。这种学术背景赋予了PostgreSQL强大的理论基础和对数据一致性的高度关注，使其成为支持复杂查询、事务处理和高级数据类型的理想平台。PostgreSQL的设计哲学重视长期稳定性和可扩展性，鼓励模块化设计和社区驱动的创新，这使得它能够适应不断发展的数据管理和分析需求。
MySQL的诞生则更加侧重于实用性与易用性，于1995年由Michael Widenius和David Axmark创建，初衷是为了满足互联网应用程序的快速开发需求。MySQL的设计哲学围绕着简化数据库管理、提高性能，并提供快速开发的环境。它的出现恰逢互联网泡沫时期，迅速获得了Web开发者的青睐，成为众多网站和应用的首选数据库。MySQL的发展历程中，对性能的追求和易于部署的特性始终是其核心价值。
数据库引擎 MySQL的一个显著特点是支持多种数据库引擎，这一设计为用户提供了灵活性，可以根据具体应用场景选择最合适的存储方式。其中，InnoDB引擎自MySQL 5.5版本起成为默认引擎，支持事务处理、行级锁定和外键约束，非常适合需要高并发和数据一致性的应用场景。相比之下，MyISAM引擎虽然在读取性能上有优势，但不支持事务和行级锁，更多用于只读或读取密集型的场景。此外，MySQL还有Memory、Archive等多种引擎，分别针对内存表、归档存储等特定用途。
PostgreSQL则采取了一种不同的策略，不依赖于多个可插拔的存储引擎，而是采用了一个统一且高度集成的核心引擎。这一设计保证了所有特性的一致性和互操作性，使得PostgreSQL能够无缝支持复杂的查询处理、事务管理以及高级数据类型。统一的存储引擎还简化了维护和调优过程，减少了因切换引擎带来的复杂性。尽管这意味着在某些特定场景下可能不如MySQL那样灵活，但PostgreSQL通过其内部的灵活性和可扩展性来弥补，例如通过分区、索引策略和查询优化来适应不同的性能需求。
PostgreSQL与MySQL：SQL语法与特性对比概览 通过对比分析，展示其在数组类型支持、JSON处理、事务管理、临时表、窗口函数、递归查询、数据类型丰富度、默认值约束以及大小写敏感性等方面的异同。
SQL语法/特性PostgreSQLMySQL描述数组类型支持不直接支持PostgreSQL可以直接定义数组类型字段，存储多值。MySQL则需通过字符串或其他间接方式模拟数组。JSON支持强大较简单PostgreSQL对JSON的支持包括索引、查询优化和函数，而MySQL的基本JSON支持较简单，但新版本已增强。事务处理完全ACID默认自动提交PostgreSQL默认支持完整的ACID事务，适合需要高一致性的场景。MySQL默认为每条语句自动提交，但可配置事务处理。临时表会话/全局范围仅会话范围PostgreSQL支持会话级和全局临时表，MySQL只支持会话级临时表。窗口函数支持较晚版本开始支持PostgreSQL较早支持窗口函数，MySQL在较新版本中也开始全面支持。CTE (公用表表达式)支持支持两者都支持CTE，但某些高级用法或性能可能有所不同。递归查询支持8.0版本后支持PostgreSQL早期支持递归查询，MySQL从8.0版本开始支持。数据类型更丰富（如ARRAY, HSTORE, GIS类型）基础类型较全面PostgreSQL支持更多特殊数据类型，MySQL也有丰富的基础数据类型，但不如PostgreSQL多样。默认值约束支持任意表达式限制较多PostgreSQL的默认值可以是任意表达式，MySQL的默认值较为受限，通常是常量。案例敏感可配置默认不区分大小写PostgreSQL可以配置数据库或列的大小写敏感性，MySQL默认不区分大小写（除非使用binary collation）。 注：随着时间的推移，该两个系统都在不断更新和发展，特定功能的支持程度和表现可能会有所变化。在选择数据库时，最好参考最新的官方文档或发行说明来获取最准确的信息。
PostgreSQL与MySQL高级特性对比：数据类型与事务处理能力 特性/数据库PostgreSQLMySQL高级数据类型支持数组、JSONB、hstore等，适用于复杂数据结构存储与查询。支持JSON（较新版本增强），但原生不支持数组、hstore等类型，需通过字符串等间接方式处理。窗口函数早期即支持窗口函数，适用于分组、排名、滑动平均等多种复杂数据分析场景。新版本开始支持窗口函数，功能逐渐完善，但在成熟度和社区资源方面可能稍逊。事务隔离级别支持READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ、SERIALIZABLE，完全遵循SQL标准。同样支持上述四种隔离级别，但默认为REPEATABLE READ，且通过不同的存储引擎（如InnoDB）实现。MVCC实现强大的MVCC机制，为每一行记录维护多个版本，无锁读取提高并发性能，适用于高并发场景。InnoDB存储引擎采用MVCC，通过Undo Logs维护事务视图，同样优化了读写并发，但在锁定策略和性能调优上有其特点。锁机制支持行级锁与多版本并发控制相结合，减少锁争用，提高并发效率。InnoDB支持行级锁，MyISAM等存储引擎使用表锁，行级锁提高了并发处理能力，但锁策略和事务设计影响性能。 数据类型与功能特性 高级数据类型: PostgreSQL提供了更丰富的数据类型，如数组、JSONB、hstore等，适合复杂数据处理。窗口函数与分析查询: PostgreSQL早期就支持窗口函数，适合复杂数据分析；MySQL在较新版本中也增加了这一功能。事务处理与并发控制: 比较两者的事务隔离级别、MVCC实现（Multi-Version Concurrency Control）及锁机制的差异。 PostgreSQL与MySQL性能与可扩展性对比 特性/数据库PostgreSQLMySQL基准测试与工作负载- 在复杂查询、联接操作上表现出色，得益于丰富的索引类型和优化器。&lt;br&gt;- 对于写密集型和混合型工作负载有较好平衡。 - 在读取密集型场景下，尤其是简单的SELECT查询，性能优越。
- InnoDB引擎优化了读取速度和并发处理。
扩展性策略 - 支持分区表，优化大数据表的查询性能。
- 并行查询功能提升处理大量数据的能力。
- 连接池管理提高并发处理能力。- 通过第三方工具（如PgPool-II, Patroni）实现高可用和扩展。
- 数据分片（Sharding）是常见水平扩展手段，适用于大规模数据分布存储。
- 通过Replication（主从复制）、Group Replication实现数据冗余和读写分离，增强扩展性和可用性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/413a58962fe5a42a47f0ea633e7b8418/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/213/">«</a>
	<span class="pagination__item pagination__item--current">214/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/215/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>