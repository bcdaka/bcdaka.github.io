<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6223b49bfedc437d5dae64fba85fc6ba/" rel="bookmark">
			vue3自定义全局less scss函数混入mixins混合样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		export default defineConfig({ plugins: [vue()], resolve: { alias: { '@': fileURLToPath(new URL('./src', import.meta.url)) } }, server: { host: '0.0.0.0', port: 80, open: true }, css: { preprocessorOptions: { scss: { additionalData: `@import './src/global.scss';` // `@mixin cover(){background: blue;}` } } } }) 如下为官网
$injectedColor是一个scss样式变量
https://cn.vitejs.dev/config/shared-options.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94004af0071b7964fbe2a9176b6fd297/" rel="bookmark">
			【QT】Qt 窗口 (QMainWindow)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt 窗口 一、菜单栏1. 创建菜单栏并添加菜单2. 创建菜单项3. 综合示例 二、工具栏1. 创建工具栏2. 设置停靠位置3. 设置浮动属性4. 综合示例 三、状态栏1. 状态栏的创建2. 在状态栏中显示实时消息3. 在状态栏中显示永久消息 四、浮动窗口1. 浮动窗口的创建2. 设置停靠的位置 五、对话框1. 对话框介绍2. 对话框分类3. Qt 内置对话框 Qt 窗口是通过 QMainWindow类 来实现的。
QMainWindow 是一个为用户提供主窗口程序的类，继承自 QWidget 类，并且提供了一个预定义的布局。QMainWindow 包含一个菜单栏（menu bar）、多个工具栏(tool bars)、多个浮动窗口（铆接部件）(dock widgets)、⼀个状态栏(status bar) 和⼀个 中心部件(central widget)，它是许多应用程序的基础，如文本编辑器，图片编辑器等。如下图为 QMainwindow 中 各组件所处的位置：
一、菜单栏 Qt 中的菜单栏是通过 QMenuBar 这个类来实现的。⼀个主窗口最多只有⼀个菜单栏。位于主窗口顶部、主窗⼝标题栏下面。
菜单栏中包含菜单. 菜单中包含菜单项.
1. 创建菜单栏并添加菜单 菜单栏的创建可以借助于 QMainWindow类 提供的 menuBar() 函数来实现。创建菜单，并通过 QMenu 提供的 addMenu() 函数 来添加菜单。
MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow) { ui-&gt;setupUi(this); // 创建菜单栏 // QMenuBar* menubar = menuBar(); QMenuBar* menubar = new QMenuBar(this); this-&gt;setMenuBar(menubar); // 添加菜单 QMenu* menu1 = new QMenu("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94004af0071b7964fbe2a9176b6fd297/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a99a4dce59434ff17f4eafc0b2c970a1/" rel="bookmark">
			【Elasticsearch】Elasticsearch的分片和副本机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 📑前言一、分片（Shard）1.1 分片的定义1.2 分片的重要性1.3 分片的类型1.4 分片的分配 二、副本（Replica）2.1 副本的定义2.2 副本的重要性2.3 副本的分配 三、分片和副本的机制3.1 分片的创建和分配3.2 数据写入过程3.3 数据读取过程 四、分片和副本的配置4.1 配置分片数量4.2 配置副本数量4.3 分片和副本的最佳实践 五、分片和副本的故障恢复5.1 主分片故障恢复5.2 副本分片故障恢复5.3 故障恢复的配置 六、分片和副本的监控6.1 监控分片状态6.2 监控集群健康状态6.3 监控指标 七、小结 📑前言 Elasticsearch是一种分布式搜索和分析引擎，它具有高扩展性和高可用性。为了实现这些特性，Elasticsearch引入了分片（Shard）和副本（Replica）的概念。本文将详细介绍Elasticsearch中的分片和副本机制，帮助读者理解它们的重要性及其实现方法。
一、分片（Shard） 1.1 分片的定义 分片是Elasticsearch中存储数据的基本单位。一个索引可以由多个分片组成，每个分片都是一个独立的Lucene索引。通过分片，Elasticsearch可以将数据分布到多个节点上，从而实现数据的分布式存储和并行处理。
1.2 分片的重要性 分片机制使Elasticsearch具有以下优势：
水平扩展：通过增加分片数量，可以水平扩展索引的存储容量和处理能力。并行处理：分片可以分布在不同的节点上，允许多个节点并行处理查询和索引请求，提高系统的性能和吞吐量。数据分布：分片机制使数据可以分布在集群的多个节点上，减少单点故障的风险，提高数据的可用性和可靠性。 1.3 分片的类型 Elasticsearch中的分片分为两种类型：
主分片（Primary Shard）：主分片是原始的数据分片，所有的写操作（如索引和删除）都首先作用于主分片。副本分片（Replica Shard）：副本分片是主分片的复制品，用于提高数据的可用性和查询性能。副本分片接收来自主分片的数据更新，并在主分片不可用时提供冗余。 1.4 分片的分配 Elasticsearch在创建索引时，用户可以指定索引的分片数量。默认情况下，一个索引包含5个主分片。分片的数量一旦设置，主分片的数量是无法更改的（除非重新创建索引）。然而，副本分片的数量可以在索引创建后动态调整。
二、副本（Replica） 2.1 副本的定义 副本是主分片的完整复制品，它用于提高系统的容错能力和查询性能。每个主分片可以有多个副本分片，这些副本分片分布在集群的不同节点上。
2.2 副本的重要性 副本机制带来了以下好处：
高可用性：副本分片提供了数据冗余，当主分片所在节点出现故障时，副本分片可以提升为主分片，保证数据的可用性。负载均衡：副本分片可以分担查询负载，减少主分片的压力，提高系统的查询性能和响应速度。数据恢复：当节点发生故障时，副本分片可以用于快速恢复数据，减少系统的停机时间。 2.3 副本的分配 副本分片的数量可以在索引创建时指定，默认情况下，每个主分片有一个副本分片。与主分片不同，副本分片的数量可以在索引创建后动态调整。Elasticsearch会自动管理分片和副本的分配，确保它们分布在集群的不同节点上，以最大限度地提高系统的容错能力和性能。
三、分片和副本的机制 3.1 分片的创建和分配 当创建一个新索引时，Elasticsearch会根据用户指定的分片数量创建主分片，并将这些分片分配到集群中的不同节点上。分片的分配过程如下：
分片创建：Elasticsearch根据索引的分片设置，创建指定数量的主分片。分片分配：Elasticsearch将主分片分配到集群中的不同节点上，确保分片均匀分布。副本创建：Elasticsearch根据索引的副本设置，为每个主分片创建副本分片。副本分配：Elasticsearch将副本分片分配到与主分片不同的节点上，确保数据冗余。 3.2 数据写入过程 在Elasticsearch中，数据的写入过程包括以下步骤：
写请求发送到主分片：所有的写操作（如索引和删除）首先发送到主分片。主分片处理写请求：主分片处理写请求，将数据写入到分片中。写请求同步到副本分片：主分片将写操作同步到所有的副本分片，确保数据的一致性。写操作完成：当所有副本分片确认写操作后，Elasticsearch返回写操作的结果。 3.3 数据读取过程 在Elasticsearch中，数据的读取过程包括以下步骤：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a99a4dce59434ff17f4eafc0b2c970a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c260a59c2fc8c5cd1ac6d1aa1a0d09e6/" rel="bookmark">
			探索前沿科技：从迁移学习看人工智能的无限可能性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从迁移学习看人工智能的无限可能性 1 引言1.1 什么是迁移学习1.1.1 迁移学习的定义1.1.2 迁移学习的起源和背景 1.2 迁移学习的重要性1.2.1 解决小数据集问题1.2.2 提高模型训练效率1.2.3 应用于不同领域的广泛性 1.3 迁移学习的前景 2 迁移学习的基本概念2.1 源域和目标域2.1.1 定义与区别2.1.2 示例说明 2.2 特征迁移与参数迁移2.2.1 特征迁移的概念与应用2.2.2 参数迁移的概念与应用 2.3 迁移学习的类型2.3.1 有监督迁移学习2.3.2 无监督迁移学习2.3.3 半监督迁移学习2.3.4 强化迁移学习 3. 迁移学习的常见方法3.1 微调预训练模型预训练模型的选择微调的过程与技巧 3.2 特征提取使用预训练模型提取特征如何结合新模型进行训练 3.3 多任务学习多任务学习的概念如何在迁移学习中应用多任务学习 3.4 对抗训练对抗训练的基本原理在迁移学习中的应用 4. 迁移学习的应用案例4.1 计算机视觉4.2 自然语言处理4.3 医疗健康4.4 自动驾驶 5. 迁移学习的挑战与未来发展5.1 迁移学习的挑战5.2 迁移学习的发展方向 1 引言 1.1 什么是迁移学习 1.1.1 迁移学习的定义 迁移学习（Transfer Learning）是一种机器学习方法，旨在利用已训练好的模型或知识来解决新的但相关的问题。传统的机器学习和深度学习方法通常依赖于大量标注数据和长时间的训练过程，而迁移学习通过将已有模型在相关任务中的知识迁移到新任务中，可以在较少数据和较少计算资源的情况下实现高效的模型训练。
简单来说，迁移学习可以分为两种主要方式：特征迁移（Feature Transfer）和参数迁移（Parameter Transfer）。特征迁移通过提取已训练模型的特征用于新任务，而参数迁移则直接微调预训练模型的参数以适应新任务。
1.1.2 迁移学习的起源和背景 迁移学习的概念源自人类学习的启发。在人类认知过程中，我们常常会将已有的知识和经验应用于新的领域。例如，一个已经学会骑自行车的人，在学习骑摩托车时会相对容易，因为两者的平衡和控制技巧有相似之处。同样地，迁移学习在人工智能领域也试图利用这一特性。
早期的迁移学习研究可以追溯到1990年代，但真正的发展和广泛应用是在深度学习兴起之后。随着计算能力的提升和大规模数据集的出现，深度神经网络在图像、语音和自然语言处理等领域表现出色。然而，训练这些深度模型通常需要大量的标注数据和计算资源，这在实际应用中往往是不可行的。迁移学习通过利用预训练模型，大大减少了训练所需的数据量和计算时间，从而成为解决这些问题的重要手段。
1.2 迁移学习的重要性 1.2.1 解决小数据集问题 在很多实际应用中，获取大规模标注数据集既昂贵又耗时。例如，在医疗领域，收集和标注医学影像数据需要专业人员的参与，而在自动驾驶领域，标注大量驾驶场景数据也是一项巨大的工程。迁移学习通过利用在大数据集上预训练的模型，可以在小数据集上实现较好的性能，显著降低了数据需求。
1.2.2 提高模型训练效率 传统的深度学习模型训练通常需要大量的计算资源和长时间的训练过程。而迁移学习可以通过微调预训练模型的方式，快速适应新的任务。这不仅缩短了训练时间，还降低了对高性能计算资源的需求。在实际应用中，这意味着更快的模型部署和更新，从而能够更及时地响应业务需求和变化。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c260a59c2fc8c5cd1ac6d1aa1a0d09e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c9eff51eab58ef3ad9af14987e85a08/" rel="bookmark">
			Java中的23种设计模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 设计模式单例模式饿汉式线程不安全的懒汉式线程安全的懒汉式双重校验锁静态内部类式枚举式单例与序列化 工厂模式简单工厂模式工厂方法模式抽象工厂模式 原型模式浅克隆深克隆总结 建造者模式适配器模式对象适配器类适配器总结 桥接模式组合模式装饰模式外观模式享元模式代理模式静态代理JDK动态代理Cglib动态代理总结 职责链模式命令模式解释器模式迭代器模式中介者模式备忘录模式观察者模式状态模式策略模式模板方法模式访问者模式 设计模式 设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、高内聚低耦合。虽然GoF设计模式只有23个，但是它们各具特色，每个模式都为某一个可重复的设计问题提供了一套解决方案。根据它们的用途，设计模式可分为创建型，结构型和行为型三种，其中创建型模式主要用于描述如何创建对象，结构型模式主要用于描述如何实现类或对象的组合，行为型模式主要用于描述类或对象怎样交互以及怎样分配职责。在GoF23种设计模式中包含5种创建型设计模式、7种结构型设计模式和11种行为型设计模式。此外，根据某个模式主要是用于处理类之间的关系还是对象之间的关系，设计模式还可以分为类模式和对象模式。
设计模式练习网站: https://java-design-patterns.com/patterns
设计模式类型设计模式名称介绍学习难度使用频率创建型模式(6种)单例模式保证一个类仅有一个对象，并提供一个访问它的全局访问点。★☆☆☆☆★★★★☆简单工厂模式定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。★★☆☆☆★★★★★工厂方法模式定义一个用于创建对象的接口，让子类决定将哪一个类实例化。★★☆☆☆★★★★★抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。★★★★☆★★★★★原型模式使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。★★★☆☆★★★☆☆建造者模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。★★★★☆★★☆☆☆结构型模式(7种)适配器模式将一个类的接口转换成客户希望的另一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。★★☆☆☆★★★★☆桥接模式将抽象部分与它的实现部分分离，使他们都可以独立地变化。★★★☆☆★★★☆☆组合模式组合多个对象形成树形结构以表示具有“整体—部分”关系的层次结构。组合模式对单个对象和组合对象的使用具有一致性。★★★☆☆★★★★☆装饰模式动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。★★★☆☆★★★☆☆外观模式为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。★☆☆☆☆★★★★★享元模式运用共享技术有效地支持大量细粒度的对象。★★★★☆★☆☆☆☆代理模式为其他对象提供一个代理以控制对这个对象的访问。★★★☆☆★★★★☆行为模式(11种)职责链模式为解除请求的发送者和接收者之间的耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它。★★★☆☆★★☆☆☆命令模式将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可取消的操作。★★★☆☆★★★★☆解释器模式定义一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。★★★★★★☆☆☆☆迭代器模式提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。★★★☆☆★★★★★中介者模式用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。★★★☆☆★★☆☆☆备忘录模式在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保持该状态，这样以后就可以将该对象恢复到保存的状态。★★☆☆☆★★☆☆☆观察者模式定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。★★★☆☆★★★★★状态模式允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。★★★☆☆★★★☆☆策略模式定义一系列的算法，把它们一个个封装起来，并且使他们可相互替换。本模式使得算法的变化可以独立于使用它的客户。★☆☆☆☆★★★★☆模板方法模式定义一个操作中的算法的骨架，而将一些步骤延迟到子类。★★☆☆☆★★★☆☆访问者模式表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素类别的前提下定义作用于这些元素的新操作。★★★★☆★☆☆☆☆ 单例模式 确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。单例模式设计就是采用一定的方法保证在整个程序中，对某个类只能存在一个对象的实例，并且该类只提供一个取得其对象实例的方法。
单例模式作用：
在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如网站首页页面缓存）；避免对资源的多重占用（比如写文件操作）； 单例模式主要应用在需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多、重量级对象，但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象(比如数据源、session 工厂等)。单例模式在Java中有6种实现。
名称优点缺点饿汉式线程安全，写法简单不懒加载，可能造成浪费懒汉式(线程不安全)懒加载线程不安全懒汉式(线程安全)线程安全，懒加载效率很低，反序列化破坏单例双重校验锁线程安全，懒加载反序列化破坏单例静态内部类式线程安全，懒加载反序列化破坏单例枚举式防止反射攻击，反序列化创建对象，写法简单不能传参，不能继承其他类 饿汉式 class Singleton { private Singleton() {} private static final Singleton instance = new Singleton(); public static Singleton getInstance() { return instance; } } 这种写法比较简单，就是在类加载的时候就完成实例化。避免了线程同步问题。但是在类装载的时候就完成实例化，没有达到懒加载的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。
线程不安全的懒汉式 class Singleton { private Singleton() { } private static Singleton instance; public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 起到了懒加载的效果，但是只能在单线程下使用。如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例，所以在多线程环境下不可使用这种方式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c9eff51eab58ef3ad9af14987e85a08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf144197e35f2921a915ba4df66eeef3/" rel="bookmark">
			智能化革新：智能AI如何助力生产力发展的未来与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎬 鸽芷咕：个人主页 🔥 个人专栏: 《C++干货基地》《粉丝福利》 ⛺️生活的理想，就是为了理想的生活! 前言 在当今这个科技飞速发展的时代，人工智能（AI）已经成为了推动生产力发展的重要力量。AI技术的应用范围广泛，涵盖了各个行业和领域，为人们的工作和生活带来了前所未有的便利。本文将探讨AI工具的现状、生成式AI和AIGC的区别，以及AI对开发者的影响，并介绍一个实际的代码实战案例，以展示AI如何助力生产力发展。
文章目录 前言一、AI工具现状1.1 萝卜快跑无人驾驶汽车1.2 人工智能对话助手1.3 AI辅助快速编写代码1.4 AI绘画的应用二、生成式AI和AIGC的区别2.1AIGC到底是个啥？2.2 AI和AIGC的区别是什么？2.3 AIGC技术的应用领域AI绘画广告营销 三、AI对开发者的影响3.1 提高开发效率自动代码生成代码审查与错误修正 3.2 改变开发模式和流程迭代开发与测试持续集成与部署 四、代码实战案例：智能推荐系统总结 一、AI工具现状 1.1 萝卜快跑无人驾驶汽车 萝卜快跑无人驾驶汽车是AI技术在交通领域的典型应用。通过AI算法，无人驾驶汽车能够实现路线规划、避障、自动驾驶等功能。尽管AI技术在无人驾驶汽车领域取得了显著成果，但这并不意味着AI会完全取代开发者。相反，AI工具的出现使得开发者能够更专注于创新和设计，提高开发效率。
1.2 人工智能对话助手 人工智能对话助手如ChatMindAi等，可以帮助开发者进行代码咨询、解决问题和提供技术支持。这些助手可以提高开发者的生产力，但同样不会取代他们的角色。
1.3 AI辅助快速编写代码 AI工具如CodeChatMindAi等可以辅助开发者快速编写代码，提高开发效率。这些工具的出现使得开发者能够更好地利用时间，专注于更有价值的工作。
1.4 AI绘画的应用 AI绘画工具如DeepArt等可以将普通图片转换为艺术风格的画作。尽管这在某种程度上体现了AI的创造力，但在软件开发领域，AI更多地是作为辅助工具存在。
二、生成式AI和AIGC的区别 生成式AI指的是能够生成新内容的AI，如音乐、文本、图像等。而AIGC（AI-Generated Content）特指利用AI技术生成文字、图片、音频、视频等内容的过程。在软件开发领域，AIGC更侧重于代码生成、自动化测试等任务。
2.1AIGC到底是个啥？ 说来说去，到底什么是AIGC呢？AIGC是人工智能生成内容的缩写，是一种基于生成对抗网络（GAN）、大型预训练模型等人工智能技术的方法，通过对已有数据进行学习和模式识别，以适当的泛化能力生成相关内容的技术，AIGC的应用领域有很多例如，AIGC可以用于自动生成新闻、文章、音乐、图像等。
2.2 AI和AIGC的区别是什么？ AIGC和AI的区别，人工智能生成内容（AIGC）和GPT都是人工智能（AI）的重要应用，但两者间存在着一些关键的区别。AIGC是一个广义的概念，涵盖了由AI创造的所有内容类型，包括文本、图像、音频和视频。AIGC的创建方式多种多样，取决于所使用的AI技术，例如深度学习、自然语言处理（NLP）或生成对抗网络（GANs）。
2.3 AIGC技术的应用领域 AI绘画 利用AIGC技术，现在市面上已经出现了很多AI辅助完成绘画或替代传统手绘的绘画方式。其核心方法是通过训练好的神经网络对图像进行处理，从而实现快速、高效的绘画过程。与传统绘画方式相比，AI绘画具有自动化、智能化、高效化等优势，大大缩短了绘画的时间，同时提高了绘画的精度和真实感。
AI绘画的实现方式主要分为两类：基于GAN（生成式对抗网络）的方法和基于CNN（卷积神经网络）的方法。基于GAN的方法是指通过训练好的生成模型和判别模型相互对抗，从而生成具有真实感的图像。这种方法可以实现从抽象的线条到具体的色彩、纹理的逐步生成，模拟出人类绘画的思考和构图过程。基于CNN的方法则相对较为简单，直接利用卷积神经网络进行图像风格转换、色彩还原等处理，从而得到优美的绘画作品。
广告营销 广告营销是AIGC技术的另一个重要应用领域。利用AIGC技术可以快速生成广告文案、视频、图片等内容，帮助企业提高广告投放效率和转化率。例如，谷歌的广告平台AdWords就采用了AIGC技术来生成广告文案。同时新闻媒体也是AIGC技术的主要应用领域之一。利用AIGC技术可以快速生成新闻稿件、摘要、标题等内容，大大提高了新闻媒体的效率和准确性。例如，美国《华尔街日报》就使用AIGC技术来生成新闻稿件，每天可以生成数百篇文章。
三、AI对开发者的影响 3.1 提高开发效率 人工智能能通过机器学习算法自动化处理编程任务，例如代码生成、调试和测试等。这种智能自动化不仅缩短了软件开发周期，还提升了代码的质量。特别是在代码审查过程中，AI系统能够识别出代码中的潜在错误和缺陷，甚至提供修复建议，这对于保证软件质量至关重要。
自动代码生成 AI可以通过深度学习模型学习大量的代码库，理解编程语言的语法和用户需求，从而自动生成代码片段或完整程序。这一点对于提升开发速度和减少人力资源的投入具有重大意义。
代码审查与错误修正 AI技术可以在代码提交过程中自动进行审查，识别出潜在的逻辑错误和性能问题。同时，通过历史错误数据的学习，AI还能预测未来可能出现的错误并提前修正，大大提高了软件的稳定性和安全性。
3.2 改变开发模式和流程 AI引入软件开发，使得开发流程更加智能化和自动化。开发者可以利用AI工具和框架来简化设计、编码、测试等环节，实现快速迭代和持续集成。
迭代开发与测试 利用AI的快速迭代能力，软件开发从传统的瀑布模式转变为敏捷开发。AI技术能够在每一个开发阶段提供即时反馈，帮助开发团队快速调整方向和策略，实现产品持续改进。
持续集成与部署 AI可以实现代码的自动构建、测试和部署，构成完整的持续集成和持续部署（CI/CD）流程。这种智能化流程大大降低了人为错误的可能性，提高了软件交付的速度和质量。
四、代码实战案例：智能推荐系统 以下是一个基于Python的智能推荐系统实战案例，展示了AI如何助力生产力发展。
# 导入相关库 import numpy as np import pandas as pd from sklearn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf144197e35f2921a915ba4df66eeef3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6de0c371320f6c2a4b6a3f674659bc72/" rel="bookmark">
			【基础算法总结】哈希表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈希表 1.哈希表简介2.两数之和3.面试题 01.02. 判定是否互为字符重排4.存在重复元素5.存在重复元素 II6.字母异位词分组 点赞👍👍收藏🌟🌟关注💖💖
你的支持是对我最大的鼓励，我们一起努力吧!😃😃
1.哈希表简介 哈希表是什么?
存储数据的容器
有啥用？
“快速” 查找某个元素。 时间复杂度O(1)
什么时候用哈希表？
频繁的查找某一个数的时候。
频繁查找某一个数的时候，我们还要想到一个二分查找也可以快速查找某一个元素，但是二分因为有些局限，具有二段性才可以用二分，它也比较快，时间复杂度O(logn)。而且能用二分我们尽量用二分，因为哈希表虽然非常快，但是它空间复杂度是O(n)。
怎么用哈希表？
容器（哈希表）用数组模拟简易哈希表 什么时候会想到用数组模拟简易哈希表，比如说:
关注字符串中的 “字符” 其中key就是index，value就是nums[index]，字符的ascll值当作index，nums[index]就是我们需要的值。非常快。
2. 数据范围很小的时候
int 1~10^7， 最好不要有负数， - 10^3 ~ 10^3
2.两数之和 题目链接：1. 两数之和
题目分析：
有且仅有一组答案，可以按任意顺序返回。数组中同一个元素在答案里不能重复出现。比如示例2 不能选两个3。
算法原理：
解法一：暴力求解
两层for循环把所有情况都找到，挑选符合条件的。
以前我们是固定一个数，然后往后找。
但是我们还有一种暴力方法，固定一个数，往前找
先固定其中一个数依次与该数之前的数相加
同样也能把所有情况都找完，并且少了判断边界情况。
解法二：利用哈希表做优化
我们先看为什么暴力枚举过程这么慢。慢就慢在当固定一个数的时候，比如说11，我们想在它的前面找到一个 target - nums[i] 的数 如 9 - 11 = - 2，我们暴力策略就是从11之前依次遍历找这个-2。那此时我如果当固定一个数的时候就把它之前的是插入到hash表中，然后在hash表中就可以用O(1)的时间复杂度来找这个-2。之前暴力解法O(N^2)，利用哈希表做优化之后时间复杂度降到O(N)。不过我们空间复杂度是O(N)的。
具体如何操作可以和刚才的固定一个数往前找完美结合起来。当固定一个数的时候，就去hash表中找 target - nums[i] 的数在不在hash表。有就找到了返回对应两个数的下标即可，所有hash&lt;nums[i] , i&gt; 前面存值后面存对应的下标。如果没找到就把这个数加入到hash表中。
接下来扩展一下，为什么之前固定数，往后走不太好用呢？
首先要将所有的数，先加入到hash表中，然后才能固定一个数，在去hash找 target - nums[i] 的数在不在hash表。注意我们这道题有个求于数组中同一个数不能出现两次，如果target = 6，但是数组中有一个3， 你固定3然后在去hash表中找，找到的还是这个3，这是不对的。因为必须要加个if判断一下，当两个数相等时是不对的。而固定一个数往前找，是不会出现这种情况的。我们是先去找，。没找到在把这个数加入到hash表中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6de0c371320f6c2a4b6a3f674659bc72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc3f30462c54a19b844a53bcf0f24fb1/" rel="bookmark">
			Oracle GoldenGate日常运维过程中常见的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景： 在工作，有用到oracle数据库，并且采用了RAC集群模式，但是存在两个oracle数据库之间需要同步指定表的数据，这里就使用到了goldengate，简称是ogg。
1、OGG简介 GoldenGate是一家创建于1995年的美国公司，开发总部设在旧金山，在北美，欧洲和亚洲（包括新加坡、印度、澳大利亚）设有支持中心。
GoldenGate公司专注于数据同步领域，是实现数据同步技术的领导者。至2007年，在全球35个国家售出超过2000个许可证，客户分布在政府、银行、电信、证券、传媒、医疗等行业，大部分客户为全球500强企业，如中国海关总署、中国国家体育总局体彩管理中心、中国电子口岸、海南移动、美国银行、VISA、瑞银集团、澳大利亚海关、新加坡港务局等。 GoldenGate是许多一流的数据库厂商如Oracle、Sybase、Microsoft、MySQL、Teradata等公司的认证合作伙伴，并且和著名的公司如HP、IBM、Sun等厂商建立了战略合作伙伴关系。
2009年被甲骨文Oracle公司收购。
2、GoldenGate 工作原理： OGG提供了一个单一的平台，这个平台可以为任何企业环境实现秒一级的灾难备份。OGG是一种基于于日志的结构化数据复制方式，它通过解析源数据库在线日志或归档日志获得数据的增删改变化，再将这些变化应用到目标数据库，实现源数据库与目标数据库同步、双活。
机制原理图：
二、常见问题： 问题一：停止了ogg后，完成数据迁移后，启动ogg时报错 问题描述： 报错内容：
Wildcard MAP resolved (entry CAM*DBO.*): MAP "CAM*DBO"."PSNSDATALOG", TARGET CAM*DBO."PSNSDATALOG"; Using following columns in default map by name: IDATALOGID, SFILENAME, TSDOWNLOADED, ICOUNT Using the following key columns for target table CAM*DBO.PSNSDATALOG: IDATALOGID. 2019-03-30 12:32:18 WARNING OGG-00869 OCI Error ORA-00001: unique constraint (CAM*DBO.PSNSDATALOG_ID) violated (status = 1). INSERT /*+ RESTRICT_ALL_REF_CONS */ INTO "CAM*DBO"."PSNSDATALOG " ("IDATALOGID","SFILENAME","TSDOWNLOADED","ICOUNT") VALUES (:a0,:a1,:a2,:a3).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc3f30462c54a19b844a53bcf0f24fb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/feb86f643e294be5d6d8705b2cefba40/" rel="bookmark">
			【设计模式之美】【建造型】建造者模式：处理复杂成员变量以及它们之间的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一. 使用场景二. 具体实现三. 小结1. 结合场景使用2. 与工厂模式的区别 建造者模式本身不难，重点是掌握好它的适用场景。
一. 使用场景 如果一个类中有很多属性，为了避免构造函数的参数列表过长，影响代码的可读性和易用性，我们可以通过构造函数配合 set() 方法来解决。
但是，如果存在下面情况中的任意一种，我们就要考虑使用建造者模式了。
如果创建对象时必填的属性有很多，那构造函数就会出现参数列表很长的问题。此时我们也无法通过set方法设置必填属性，因为没有设置的必填属性无法判断。如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合 set() 方法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值，此时我们就不能在类中暴露 set() 方法。 接下来看建造者模式是如何解决这些问题的。
二. 具体实现 对于校验与属性之间存在关系：
我们可以把校验逻辑放置到 Builder 类中，先创建建造者，并且通过 set() 方法设置建造者的变量值，然后在使用 build() 方法真正创建对象之前，做集中的校验，校验通过之后才会创建对象。
对于不可变对象：
把类的构造函数改为 private，这样就只能通过建造者来创建对象。另外不提供提供任何 set() 方法，这样创建出来的对象就是不可变对象了。
具体的代码如下所示：
public class ResourcePoolConfig { private String name; private int maxTotal; private int maxIdle; private int minIdle; private ResourcePoolConfig(Builder builder) { this.name = builder.name; this.maxTotal = builder.maxTotal; this.maxIdle = builder.maxIdle; this.minIdle = builder.minIdle; } //.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/feb86f643e294be5d6d8705b2cefba40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ac5e6087c30ededef765db2e4d7d66a/" rel="bookmark">
			大数据hive表和iceberg表格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iceberg: https://iceberg.apache.org/
iceberg表，是一种面向大型分析数据集的开放表格式，旨在提供可扩展、高效、安全的数据存储和查询解决方案。它支持多种存储后端上的数据操作，并提供 ACID 事务、多版本控制和模式演化等特性，使数据管理和查询更加灵活便捷。Iceberg 可以屏蔽底层数据存储格式上的差异，向上提供统一的操作 API，使得不同的引擎可以通过其提供的 API 接入。
表格式（Table Format）可以理解为元数据以及数据文件的一种组织方式，处于计算框架（Flink，Spark…）之下，数据文件(orc, parquet)之上。这一点与Hive有点类似，hive也是基于HDFS存储、MR/SPARK计算引擎，将数据组织成一种表格式，提供Hive Sql对数据进行处理。如果我们的文件格式选择的是parquet,那么文件是以“.parquet”结尾，例如：
00000-0-root_20211212192602_8036d31b-9598-4e30-8e67-ce6c39f034da-job_1639237002345_0025-00001.parquet 就是一个数据文件。
Iceberg 设计为以快照（Snapshot）的形式来管理表的各个历史版本数据。每个快照中会列出表在某个时刻的所有数据文件列表。Data 文件存储在不同的 Manifest 文件中，Manifest 文件存储在一个 Manifest List 文件中，Manifest 文件可以在不同的 Manifest List 文件间共享，一个 Manifest List 文件代表一个快照。
 Manifest list 文件是元数据文件，其中存储的是 Manifest 文件的列表，每个 Manifest 文件占据一行。
 Manifest 文件是元数据文件，其中列出了组成某个快照的数据文件列表。每行都是每个数据文件的详细描述，包括数据文件的状态、文件路径、分区信息、列级别的统计信息（例如每列的最大最小值、空值数等）、文件的大小以及文件中数据的行数等信息。
 Data 文件是 Iceberg 表真实存储数据的文件，一般是在表的数据存储目录的 data 目录下。
Apache Iceberg表的特点主要包括：
开放的数据湖表格式：Iceberg是一种开放的数据湖表格式，可以在HDFS或对象存储上构建数据湖存储服务，与多种计算引擎如Spark、Flink、Hive和Presto等兼容 。
1.核心能力：Iceberg设计初衷是解决Hive数仓上云的问题，提供基于HDFS或对象存储的轻量级数据湖存储服务，支持ACID语义、行级数据变更、历史版本回溯、高效数据过滤、Schema变更、分区布局变更以及隐式分区 。
2.文件级别的元数据管理：Iceberg通过快照进行多版本控制，每个快照对应一组清单，清单再对应具体数据文件 。
3.数据文件不可变性：Iceberg数据文件一旦创建就不能被修改，而是通过追加新数据文件来增加新数据 。
4.表快照：Iceberg表快照是表在特定时间点的版本，每次修改都会生成新的快照，帮助实现版本控制和数据管理 。
5.清单列表：清单列表是数据文件的元数据信息列表，对数据查询、管理和优化等操作至关重要 。
6.Catalog管理：Catalog是管理表和数据的入口，负责存储表的元数据信息，并允许通过编程方式或CLI进行操作 。
7.ACID和MVCC：Iceberg提供了ACID语义和多版本并发控制，确保数据的一致性和可靠性 。
8.Schema和Partition Evolution：Iceberg支持灵活的表schema变更和分区方式变更，允许对表进行增加列、删除列、更新列等操作 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ac5e6087c30ededef765db2e4d7d66a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d5615b592780e0289a729c689585600/" rel="bookmark">
			深入理解淘客返利系统中的异步消息处理与队列技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深入理解淘客返利系统中的异步消息处理与队列技术
大家好，我是微赚淘客系统3.0的小编，是个冬天不穿秋裤，天冷也要风度的程序猿！
在现代的淘客返利系统中，高并发和复杂的业务需求要求我们采用异步消息处理和队列技术来提高系统的性能和可伸缩性。本文将深入探讨在淘客返利系统中如何利用异步消息处理和队列技术来优化系统架构和业务流程。
消息队列的选择与配置 步骤一：选择合适的消息队列系统 在Java语言中，我们通常选择使用Apache Kafka作为消息队列系统，以下是一个简单的配置示例：
package cn.juwatech.rebate.config; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.kafka.core.DefaultKafkaProducerFactory; import org.springframework.kafka.core.KafkaTemplate; import org.springframework.kafka.core.ProducerFactory; import org.springframework.kafka.support.serializer.StringSerializer; import java.util.HashMap; import java.util.Map; @Configuration public class KafkaConfig { @Value("${kafka.bootstrap.servers}") private String bootstrapServers; @Bean public ProducerFactory&lt;String, String&gt; producerFactory() { Map&lt;String, Object&gt; configProps = new HashMap&lt;&gt;(); configProps.put(org.apache.kafka.clients.producer.ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers); configProps.put(org.apache.kafka.clients.producer.ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class); configProps.put(org.apache.kafka.clients.producer.ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class); return new DefaultKafkaProducerFactory&lt;&gt;(configProps); } @Bean public KafkaTemplate&lt;String, String&gt; kafkaTemplate() { return new KafkaTemplate&lt;&gt;(producerFactory()); } } 步骤二：消息生产者的实现 在淘客返利系统中，我们可能需要将关键业务事件发布到消息队列，例如订单创建事件：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d5615b592780e0289a729c689585600/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd8c353573b4e16a88ec54dd91b83433/" rel="bookmark">
			用于可穿戴传感器的人类活动识别、健康监测和行为建模的大型语言模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇论文题为《用于可穿戴传感器的人类活动识别、健康监测和行为建模的大型语言模型：早期趋势、数据集和挑战的综述》，由埃米利奥·费拉拉（Emilio Ferrara）撰写。论文主要内容如下：
摘要 可穿戴技术的普及使得传感器数据的大量生成成为可能，为健康监测、活动识别和个性化医疗的进步提供了重要机会。然而，这些数据的复杂性和规模也带来了建模和分析的巨大挑战，从时间序列建模到深度学习技术，各种方法相继应用。最新的前沿是采用大型语言模型（LLMs），如GPT-4和Llama，用于通过可穿戴传感器数据分析、建模、理解和生成人类行为。这篇综述探讨了将LLMs应用于基于传感器的人类活动识别和行为建模的当前趋势和挑战。
引言 可穿戴传感器的快速发展带来了大量数据，使我们能够前所未有地监测和理解人类行为和健康。尽管可穿戴传感器数据的规模和复杂性增加了数据建模和分析的难度，LLMs如GPT-4和Llama展示了在数据分析中的强大能力，为从可穿戴传感器数据中提取有意义的见解提供了新的可能性。
可穿戴传感器数据 可穿戴传感器种类繁多，主要包括：
生理传感器：监测心率、血压等生命体征。运动传感器：加速度计、陀螺仪等，用于追踪运动和定位。环境传感器：监测温度、湿度等环境条件。生化传感器：测量葡萄糖等生化指标。多传感器系统：集成多种传感器，提供全面的监测能力。 这些传感器产生的高维、连续时间序列数据需要专门的预处理和分析技术。以下是表1中提到的参考文献详细信息：
可穿戴传感器类型 传感器类型描述参考文献生理传感器监测生命体征和其他生理参数。例子包括心率监测仪、心电图（ECG）、血压监测仪和脉搏血氧仪。[34]运动传感器包括加速度计、陀螺仪和磁力计，用于追踪运动和定位。应用于活动识别和体育科学中至关重要。[24]环境传感器检测环境条件，如温度、湿度和光线。通常集成到可穿戴设备中，以提供上下文感知服务。[9]生化传感器测量生化标志物，如葡萄糖水平、乳酸和电解质。在医学诊断和持续健康监测中非常有价值。[11]多传感器系统将多种传感器类型集成到一个设备中，以提供全面的监测能力。例子包括智能手表和健身追踪器。[17] 数据类型 数据类型描述参考文献时间序列数据大多数可穿戴传感器会产生连续的时间序列数据，捕捉随时间变化的动态。这类数据需要专门的预处理、分割和特征提取技术来进行有效分析。[18]多模态数据可穿戴设备通常通过结合不同类型传感器的输入来生成多模态数据。例如，一块智能手表可能同时收集运动和生理数据。整合和同步这些数据流是准确分析的关键任务。[17]高维数据可穿戴传感器生成的原始数据可能是高维的，特别是在使用多个传感器时。降维技术，如主成分分析（PCA）和特征选择方法，被用来管理这种复杂性。[29]噪声和不完整数据可穿戴传感器由于传感器故障、用户移动和环境干扰等各种因素，容易产生噪声和不完整的数据。有效的数据清理和插补方法对于保持数据质量至关重要。[1] 大型语言模型（LLMs） LLMs如GPT-4和Llama在自然语言处理领域取得了巨大成功，现已开始应用于可穿戴传感器数据分析。它们能够处理多模态数据，包括文本、音频和传感器信号，提供更全面的数据理解。
现状和挑战 LLMs在处理复杂查询和生成有见地的响应方面表现出色，使其成为需要高水平推理和上下文理解任务的理想工具。然而，挑战依然存在，包括数据质量、计算需求、可解释性和隐私问题。未来的研究方向应包括改进预处理技术、开发更高效和可扩展的模型以及加强跨学科合作。
总结 综述提供了可穿戴传感器数据与LLMs交叉领域的全面概览，探讨了当前的状态和未来前景。通过案例研究和成功应用，强调了LLMs在增强可穿戴传感器数据分析和解释方面的潜力。
方法与贡献 现有方法综述：分析了传统机器学习和深度学习在可穿戴传感器数据分析中的应用及其局限性。LLMs的应用前景：讨论了LLMs在处理和分析多模态数据方面的优势，尤其是其在处理复杂、异构数据方面的能力。挑战与建议：提出了数据质量、计算要求、模型可解释性和隐私保护等方面的挑战，并提供了相应的建议和未来研究方向。 结论 LLMs为可穿戴传感器数据分析提供了新的机遇，通过改进数据预处理技术、开发更高效的模型、加强跨学科合作，可以进一步提升其应用效果。
这篇论文通过全面综述当前的研究进展，提出了未来研究的潜在方向，强调了LLMs在可穿戴传感器数据分析中的重要性和潜力。
传感器数据集参考文献： [9] Zachary Englhardt, Chengqian Ma, Margaret E Morris, Chun-Cheng Chang, Xuhai “Orson” Xu, Lianhui Qin, Daniel McDuff, Xin Liu, Shwetak Patel, and Vikram Iyer. 2024. From Classification to Clinical Insights: Towards Analyzing and Reasoning About Mobile and Behavioral Health Data With Large Language Models.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd8c353573b4e16a88ec54dd91b83433/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff271fa19f3e53301c973a7e55d23650/" rel="bookmark">
			尚硅谷大数据技术-数据湖Hudi视频教程-笔记03【Hudi集成Spark】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大数据新风口：Hudi数据湖（尚硅谷&amp;Apache Hudi联合出品）
B站直达：https://www.bilibili.com/video/BV1ue4y1i7na 尚硅谷数据湖Hudi视频教程百度网盘：https://pan.baidu.com/s/1NkPku5Pp-l0gfgoo63hR-Q?pwd=yyds阿里云盘：https://www.aliyundrive.com/s/uMCmjb8nGaC（教程配套资料请从百度网盘下载） 尚硅谷大数据技术-数据湖Hudi视频教程-笔记01【Hudi概述、Hudi编译安装】
尚硅谷大数据技术-数据湖Hudi视频教程-笔记02【Hudi核心概念（基本概念、数据写、数据读）】
尚硅谷大数据技术-数据湖Hudi视频教程-笔记03【Hudi集成Spark】
尚硅谷大数据技术-数据湖Hudi视频教程-笔记04【Hudi集成Flink】
尚硅谷大数据技术-数据湖Hudi视频教程-笔记05【Hudi集成Hive】
目录
第4章 集成 Spark
026
027
028
029
030
031
第4章 集成 Spark 026 第4章 集成 Spark
4.1 环境准备
4.1.1 安装Spark
4.1.2 启动Hadoop（略）
4.2 spark-shell 方式
4.2.1 启动 spark-shell
1）启动命令
[atguigu@node001 ~]$ spark-shell \ &gt; --conf 'spark.serializer=org.apache.spark.serializer.KryoSerializer' \ &gt; --conf 'spark.sql.catalog.spark_catalog=org.apache.spark.sql.hudi.catalog.HoodieCatalog' \ &gt; --conf 'spark.sql.extensions=org.apache.spark.sql.hudi.HoodieSparkSessionExtension' Setting default log level to "WARN". To adjust logging level use sc.setLogLevel(newLevel). For SparkR, use setLogLevel(newLevel).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff271fa19f3e53301c973a7e55d23650/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d8fe5c9dba083a57772062fa3c51f0d/" rel="bookmark">
			AI 教母对话 ChatGPT 之母：大模型具备说服、影响人类甚至控制整个社会的危险能力...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者 | 王启隆
出品 | AI 科技大本营（ID：rgznai100）
沉寂了两周的 OpenAI，在这周终于有了动静。
首先是 7 月 7 日，OpenAI 的首席执行官（CEO）Sam Altman 在《时代》杂志上官宣了自己将成立一家新公司：Thrive AI Health。这是家医疗保健公司，如果一言以蔽之，便是 AI 驱动医疗。
相对应的是，OpenAI 官方随后在 7 月 10 日发布了 12 天以来的第一则推特，官宣了与洛斯阿拉莫斯国家实验室的合作，研究 AI 用于生物科学。
这几天，彭博社又爆料了 OpenAI 的最新动向：他们在 7 月 9 日公司内部的全体会议上与员工分享了一套全新的分类系统，给人工智能划分了五个等级，乍一看就像自动驾驶的等级一样。
让我们先回忆一下自动驾驶的分级：L0（应急辅助）、L1（部分驾驶辅助）、L2（组合驾驶辅助）、L3（有条件自动驾驶）、L4（高度自动驾驶）、L5（完全自动驾驶）。事实上，在 2023 年 11 月发表的一篇论文中，来自 Google DeepMind 的数位研究者就提出过一套包含五个递进级别的 AI 框架，其中包含了“专家”和“超人”等不同的阶段，和自动驾驶分级比较类似。
而在 OpenAI 的分级中，他们目前认为自身正处于第一级“聊天机器人”，但正接近第二级“推理者”水平。这一级别的 AI 系统具备类似拥有博士学位教育但未配备任何工具的人类，能执行基础的问题解决任务。据悉，OpenAI 的管理层在会议中还向员工们展示了涉及 GPT-4 AI 模型的一个研究项目，他们认为这个项目展现了 AI 新的技能，其推理能力已经接近人类水平。
按照 OpenAI 设定的等级划分，通往 AGI 的第三级将被称为“智能体”（Agent），指的是那些能在用户授权下花费数日时间自主执行任务的 AI 系统。第四级是具备创新能力的 AI。而最顶级的，则被称为“组织者”，能代替公司老板。
最后，还是 7 月 9 日这个时间点，约翰霍普金斯大学和 Vox Media 发起了为期一年的合作首场活动，他们这次重点关注人工智能，召集了技术、科学和公共政策的高风险交叉领域工作的最聪明的人才进行讨论。其中有一场对话，汇聚了三位科技界的“女强人”：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d8fe5c9dba083a57772062fa3c51f0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8b2aed4d7ddcd8163988a9dcdcc6367/" rel="bookmark">
			LLM（大语言模型）解码时是怎么生成文本的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Part1配置及参数 transformers==4.28.1
源码地址：transformers/configuration_utils.py at v4.28.1 · huggingface/transformers (github.com)
文档地址：Generation (huggingface.co)
对于生成任务而言：text-decoder, text-to-text, speech-to-text, and vision-to-text models，有以下几种生成的方法：
greedy decoding by calling [~generation.GenerationMixin.greedy_search] if num_beams=1 and do_sample=False
contrastive search by calling [~generation.GenerationMixin.contrastive_search] if penalty_alpha&gt;0. and top_k&gt;1
multinomial sampling by calling [~generation.GenerationMixin.sample] if num_beams=1 and do_sample=True
beam-search decoding by calling [~generation.GenerationMixin.beam_search] if num_beams&gt;1 and do_sample=False
beam-search multinomial sampling by calling [~generation.GenerationMixin.beam_sample] if num_beams&gt;1 and do_sample=True
diverse beam-search decoding by calling [~generation.GenerationMixin.group_beam_search], if num_beams&gt;1 and num_beam_groups&gt;1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8b2aed4d7ddcd8163988a9dcdcc6367/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74f49a5a1cec2d76d853d9f9d8ef5a75/" rel="bookmark">
			JAVA下载EXCEL模板文件设置下拉框以及级联下拉框（easyExcel）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述 当有需求下载EXCEL模板文件时，一些列的数据是想让用户选择而不是输入，此时就需要实现下拉框，当下拉框逐渐多起来之后，有层级关系的时候就涉及到了级联下拉框。
导入导出基于easyExcel实现的，学习跳转--关于Easyexcel | Easy Excel 官网
二、代码实现 （一）、相关依赖 &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.3.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;3.0.5&lt;/version&gt; &lt;/dependency&gt; （二）、代码实现 import cn.hutool.core.date.DateUtil; import cn.hutool.core.io.FileUtil; import lombok.extern.slf4j.Slf4j; import org.apache.poi.ss.usermodel.*; import org.apache.poi.ss.util.CellRangeAddressList; import org.apache.poi.xssf.usermodel.*; import javax.servlet.http.HttpServletResponse; import java.io.ByteArrayOutputStream; import java.io.File; import java.io.FileOutputStream; import java.io.OutputStream; import java.util.*; @Slf4j public class CascadeSelectTool { private final XSSFWorkbook workbook; private XSSFSheet mainSheet; /** * 数据 */ private Map&lt;String, List&lt;String&gt;&gt; areaList = new LinkedHashMap&lt;&gt;(); /** * 隐藏页名称 */ private String hiddenSheetName = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74f49a5a1cec2d76d853d9f9d8ef5a75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36930cbb50b759ba5b3ea1a6c38fcf84/" rel="bookmark">
			文心一言《使用手册》，文心一言怎么用？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、认识文心一言 （一）什么是文心一言 文心一言是百度研发的 人工智能大语言模型产品，能够通过上一句话，预测生成下一段话。 任何人都可以通过输入【指令】和文心一言进行对话互动、提出问题或要求，让文心一言高效地帮助人们获取信息、知识和灵感。
*指令（prompt）其实就是文字，它可以是你向文心一言提的问题（如： 帮我解释一下什么是芯片 ），可以是你希望文心一言帮你完成的任务（如： 帮我写一首诗/画一幅画* ）
（二）文心一言的基础能力 文心一言由文心大模型驱动，具备理解、生成、逻辑、记忆四大基础能力。当前文心大模型已升级至4.0Turbo版本，能够帮助你轻松搞定各类复杂任务。
理解能力： 听得懂潜台词、复杂句式、专业术语，今天，人类说的每一句话，它大概率都能听懂！
生成能力： 快速生成文本、代码、图片、图表、视频，今天，人类目光所致的所有内容，它几乎都能生成！
逻辑能力： 复杂的逻辑难题、困难的数学计算、重要的职业/生活决策统统能帮你解决，情商智商双商在线！
记忆能力： 不仅有高性能，更有好记性。N轮对话过后，你话里的重点，它总会记得，帮你步步精进，解决复杂任务！
（三）文心一言的应用场景 文心一言是你工作、学习、生活中省时提效的好帮手；是你闲暇时刻娱乐打趣的好伙伴；也是你需要倾诉陪伴时的好朋友。在你人生旅途经历的每个阶段、面对的各种场景中，文心一言7*24小时在线，伴你左右。
二、3分钟学会写文心一言指令 一条指令的背后也许是工作中被省掉的N个小时；是学习中多学到的N条知识；是生活中解答的N条疑问；无聊郁闷时的N份正能量。如果你仍苦于不知如何跟AI交互，不妨直接看看这里，三分钟带你快速上手文心一言指令，帮你在不同应用场景找到属于你的宝藏指令！
（一）三分钟快速掌握文心一言基础指令技巧 1.1 指令（Prompt）基本格式： 参考信息：包含文心一言完成任务时需要知道的必要背景和材料，如：报告、知识、数据库、对话上下文等
动作：需要文心一言帮你解决的事情，如：撰写、生成、总结、回答等
目标：需要文心一言生成的目标内容，如：答案、方案、文本、图片、视频、图表等
要求：需要文心一言遵循的任务细节要求，如：按XX格式输出、按XX语言风格撰写等
1.2 指令词构造示例 一条优秀的指令词应清晰明确且具有针对性，能够准确引导模型理解并回应你的问题。下面，让我们看一下什么是不好的指令词，什么是优秀的指令词：
1.2.1 什么是不好的指令词 写一首山和树林的诗。下面的题帮我讲一下。撰写一篇有关大语言模型可信性的论文。 1.2.2 什么是好的指令词 请以唐代诗人的身份，在面对黄山云海时，根据已有唐诗数据，撰写一篇作者借由眼前景观感叹人生不得志的七言绝句，并严格满足七言绝句的格律要求。 请以高中数学老师的身份，在高中课堂上，根据《高中数学必修一》内容，逐步解答学生关于集合的数学问题，并给出解题步骤及相关知识点。 请根据已发表的关于大语言模型可信性的相关文献，撰写一篇系统梳理大语言模型可行性相关研究现状以及未来挑战的综述论文，并且严格遵循《计算机学报》投稿格式。 恭喜你，已经学会了一条优质指令词的基本构造形式。光说不练假把式！接下来我们将使用真实的实践案例，带你一同挖掘文心一言更多的宝藏能力。
（二）文心一言入门指令应用实例 了解文心一言的入门指令（Prompt）方法论之后，本篇章将从职场提效、学习成长、生活助手、情感陪伴、休闲娱乐五个方面，围绕具体的使用人群和真实的使用场景展现对应的方法论。
1.1 巧用文心一言，提效工作职场 职场人的一天难免身陷灵感荒漠，为一条创意想破脑袋；亦或是，面对重复却耗时的任务，被冗长的材料消磨了自己的热情。快来运用刚才学到的指令公式，让灵感涌现，跟重复、机械、低效Say No！
无论你是程序员、设计师、教师、影视编导，还是需要兼具创意和执行力的广告人、自媒体、作家、写手，你都可以让文心一言成为你的专属打工人。
如果你是一个每天都需要打造爆款的广告人、自媒体、主播
灵感匮乏、创意枯竭怎么办？莫慌！文心一言能够为你快速脑暴想点子，也能为你一步到位直接生成创意文字/图片/视频。
以创作陈年老酒这款商品的广告文案为例，10s内一行短句轻松让你灵感爆发，超额达成工作任务！
你可以在文心一言对话框输入：
请参考其他知名白酒品牌文案，为'陈年老酒'这款产品创作十个吸睛的广告文案。
不止于文案，借助文心一言强大的逻辑能力和生成能力，一个简单的创意可以瞬间转化为一则完整的视频脚本，让你的创作能力倍增！
你可以在文心一言对话框输入：
请参照主流短视频平台的观众喜好，为一名美食探店博主，制作一个打卡评测刘记肥肠火锅店的视频脚本，要求标明对应镜号。
如果你是一位每天都要写一沓文书、材料、方案、总结的职场“苦命人”
我一定要向你推荐文心一言！你只需要输出关键信息点，文心一言可以帮你把内容进行扩写和分段，保证有逻辑、有条理、有文化、有品质，堪称材料写作界的一把好手！
以写一封在大会上的公开表扬稿为例，你只需要告诉文心一言被表扬者的几大优点，然后要求文心一言进行扩写，且需要表达流畅、书面、有条理、有逻辑即可！文心一言就可以帮你私人订制一篇独一无二又具有文化内涵的表扬稿，一起来看看！
你可以在文心一言对话框输入：
我要写一段在公司大会上对同事言宝的表扬稿，表扬的几个点如下：【1、言宝在对数据KPI压力很大的情况下，为了保证品牌形象符合公司发展预期，一直坚持做对企业有意义的决策；2、言宝非常注重用户的感受，哪怕用户在非工作时间，甚至在夜间找到言宝，他也会第一时间安抚用户、尽力解决用户问题；3、言宝热心有爱，边界感弱，主动帮助新同学和对工作上手困难的同学解决问题】，帮我把这段内容扩展的更有逻辑，要求表达流畅、书面、适当引经据典。
当然，除去发言稿，文心一言也具备拯救你的报告的能力，让我们一起带入场景感受：
假设你好不容易完成了一天的文案任务，临下班10分钟猛然发现待办事项中还躺着一条写报告的事项，上千字的报告光是找资料就让你犯了难。
你可以在文心一言对话框输入：
作为一名咨询分析师，写一份结构清晰且有数据依据的餐饮行业发展分析报告。
如果你是经常需要处理大量数据的“公式代码小白”
想用Excel函数公式处理数据，却觉得公式繁多记不住、操作复杂不会用、数据量大难处理。莫慌！文心一言用10秒帮你轻松扫除障碍！你只需要输入想实现的数据效果，文心一言可以帮你制作表格、编写公式、构建代码，确保高效、简单、易懂！ 设想这样一个场景：你手头有一堆零散的数据，需要逐个复制粘贴到Excel表格中，是不是觉得非常繁琐？文心一言可以化身数据小能手，直接帮你数据变表格。如果还想添加新列并进行计算，只需向文心一言提供计算公式，便可迅速生成所需表格。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36930cbb50b759ba5b3ea1a6c38fcf84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8da87a1aecf506f0c8b3fed9f5c4d0e/" rel="bookmark">
			【初阶数据结构】理解堆的特性与应用：深入探索完全二叉树的独特魅力
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初阶数据结构相关知识点可以通过点击以下链接进行学习一起加油！时间与空间复杂度的深度剖析深入解析顺序表:探索底层逻辑深入解析单链表:探索底层逻辑深入解析带头双向循环链表:探索底层逻辑深入解析栈:探索底层逻辑深入解析队列:探索底层逻辑深入解析循环队列:探索底层逻辑树与二叉树：从零开始的奇幻之旅 本篇将介绍堆的相关操作与应用，在堆应用方面包括堆排序和Tok问题的解法措施，分析向上向下调整算法对堆进行的调整，利用父子节点之间的规律，帮助我们更好地学习完全二叉树的独特魅力和掌握特殊的完全二叉树堆相关接口的实现
🌈个人主页：是店小二呀
🌈C语言笔记专栏：C语言笔记
🌈C++笔记专栏： C++笔记
🌈初阶数据结构笔记专栏： 初阶数据结构笔记
🌈喜欢的诗句:无人扶我青云志 我自踏雪至山巅
文章目录 一、二叉树的顺序结构二、堆的概念及结构三、堆的实现3.1 堆向下调整算法3.2 向上调整算法3.3 处理完全二叉树不是堆情况3.4 堆的插入3.5 堆的删除3.5.1 挪移数据覆盖删除3.5.2 首尾交换再删除 四、堆的应用4.1 堆排序4.1.1 如果升序建小堆4.1.2 向上或向下调整建堆4.1.3向下向上调整建堆时间复杂度 4.2 TOP-K问题 一、二叉树的顺序结构 普通的二叉树是不适合用数组来存储的，因为可能会存在大量的空间浪费。而完全二叉树更适合使用顺序结构存储。现实中我们通常把堆(一种二叉树)使用顺序结构的数组来存储，需要注意的是这里的堆和操作系统虚拟进程地址空间中的堆是两回事，一个是数据结构，一个是操作系统中管理内存的一块区域分段
二、堆的概念及结构 如果有一个关键码的集合K ={k0，k1，k2，…，kn-1}，把它的所有元素按照完全二叉树的顺序存储方式存储在一个一维数组中，并满足:Ki &lt;= K2*i+1且 Ki &lt;= K2*i+2 (Ki &gt;= K2*i+1且 Ki &gt;= K2*i+2) i =0, 1, 2…则称为小堆(或大堆)。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆
堆分为大堆和小堆
小堆要求:任意一个父亲结点&lt;=孩子结点
大堆要求:任意一个父亲结点&gt;=孩子结点
堆的性质：
大堆中某个节点的值总是不大于其父节点的值小堆中某个节点的值总是不小于其父节点的值堆总是一棵完全二叉树 三、堆的实现 堆分为大堆或小堆，无论是向上或向下调整算法，会根据大小堆的需求去修改部分的代码，其实就是修改大于小于号的问题。以下代码部分是根据建小堆来走，如果需要建大堆可以修改直接的大于小于号。
堆总是一颗完全二叉树，对于搭建完全二叉树的结构，一般采用数组作为存储结构，而完全二叉树作为逻辑结构。
父子节点间下标规律关系
leftchild = parent * 2 + 1;
rightchild = paretn * 2 +2;
parent = (child - 1) / 2;(不区分左右孩子)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8da87a1aecf506f0c8b3fed9f5c4d0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79323dd2c7a74f3d39f0a7defa60a284/" rel="bookmark">
			论文翻译：Explainability for Large Language Models: A Survey
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://arxiv.org/pdf/2309.01029
目录 可解释性在大型语言模型中：一项调查摘要1 引言2 LLMs的训练范式2.1 传统微调范式2.2 提示范式 3 传统微调范式的解释3.1 局部解释3.1.1 基于特征归因的解释3.1.2 基于注意力的解释3.1.3 基于示例的解释 3.2 全局解释3.2.1 基于探针的解释3.2.2 神经元激活解释3.2.3 基于概念的解释3.2.4 机制性可解释性 3.3 利用解释3.3.1 调试模型3.3.2 改进模型 4 解释提示范式4.1 基础模型解释4.1.1 解释上下文学习4.1.2 解释CoT提示4.1.3 表示工程 4.2 助手模型解释4.2.1 解释微调的作用4.2.2 解释幻觉 4.3 利用解释4.3.1 改进LLMs4.3.2 下游应用 5 解释评估5.1 传统微调范式的解释评估5.2 提示范式中的解释评估 6 研究挑战6.1 缺乏真值解释6.2 新兴能力的来源6.3 两种范式的比较6.4 LLMs的捷径学习6.5 注意力冗余6.6 从快照可解释性转向时间分析6.7 安全和伦理 7 结论 可解释性在大型语言模型中：一项调查 摘要 大型语言模型（LLMs）在自然语言处理方面展示了令人印象深刻的能力。然而，它们的内部机制仍然不清晰，这种缺乏透明度为下游应用带来了不必要的风险。因此，理解和解释这些模型对于阐明它们的行为、限制和社会影响至关重要。在本文中，我们介绍了一种可解释性技术的分类，并为解释基于Transformer的语言模型提供了一个结构化的概述。我们根据LLMs的训练范式对技术进行分类：传统的基于微调的范式和基于提示的范式。对于每种范式，我们总结了生成单个预测的局部解释和整体模型知识全局解释的目标和主要方法。我们还讨论了评估生成解释的指标，并讨论了如何利用解释来调试模型和提高性能。最后，我们检查了在LLMs时代与常规深度学习模型相比，解释技术的关键挑战和新兴机遇。
1 引言 大型语言模型（LLMs），如BERT（Devlin等人，2019a）、GPT-3（Brown等人，2020）、GPT4（OpenAI，2023b）、LLaMA-2（Touvron等人，2023b）和Claude（AnthropicAI，2023），在广泛的自然语言处理（NLP）任务中展示了令人印象深刻的性能。像微软、谷歌和百度等主要技术公司已在他们的商业产品和服务中部署了LLMs以增强功能。例如，微软利用GPT-3.5来提高新必应的搜索相关性排名（Mehdi，2023）。由于LLMs是众所周知的复杂“黑箱”系统，它们的内部工作机制是不透明的，而且高复杂性使得模型解释变得非常具有挑战性。这种模型透明度的缺乏有时会导致有害内容的生成或幻觉（Weidinger等人，2021）。因此，开发可解释性以揭示这些强大模型的工作原理至关重要。
可解释性指的是以人类可理解的术语解释或展示模型行为的能力（Doshi-Velez和Kim，2017；Du等人，2019a）。提高LLMs的可解释性至关重要，原因有两个。首先，对于普通用户来说，可解释性通过以易于理解的方式阐明模型预测背后的推理机制，建立适当的信任，而无需技术专长。这样，最终用户能够理解LLMs的能力、限制和潜在缺陷。其次，对于研究人员和开发人员来说，解释模型行为提供了洞察力，以识别无意的偏见、风险和性能改进的领域。换句话说，可解释性作为一种调试工具，可以快速推进模型在下游任务上的性能（Strobelt等人，2018；Bastings等人，2022；Yuksekgonul等人，2023）。它有助于跟踪模型能力随时间的变化，比较不同模型，并为现实世界部署开发可靠、道德和安全的模型。
与传统的深度学习模型相比，LLMs在参数和训练数据的规模上引入了复杂的挑战和激动人心的机遇，用于可解释性研究。首先，随着模型变得更大，由于内部复杂性的增加和训练数据的庞大，理解和解释它们的决策过程变得更加困难。这种复杂性还要求大量的计算资源来生成解释。一方面，传统的实用特征归因技术，如基于梯度的方法（Sundararajan等人，2017）和SHAP值（Lundberg和Lee，2017a），可能需要大量的计算能力来解释具有数十亿参数的LLMs。这使得这些解释技术对于最终用户可以利用的实际应用来说不太实用。另一方面，这种增加的复杂性使得深入分析变得具有挑战性，阻碍了模型的调试和诊断。此外，理解LLMs在上下文学习（Li等人，2023b）和思维链提示（Wu等人，2023a）方面的独特能力，以及幻觉现象，对于解释和改进模型是不可或缺的。其次，这种规模也促进了可解释性技术的创新，并提供了对模型行为更丰富的见解。例如，LLMs可以为其自身的决策过程提供思维链解释。此外，最近的研究发现LLMs可以作为工具，为其他机器学习模型所做的预测提供事后解释（Kroeger等人，2023）。为了更好地理解和增强LLMs，必须回顾现有的可解释性技术，并发展对潜在未来方向的理解。在本文中，我们提供了一种全面的方法概述，用于解释基于Transformer的语言模型。在第2节中，我们介绍了应用LLMs的两个主要范式：1）传统的下游微调范式和2）提示范式。基于这种分类，我们在第3节中回顾了微调LLMs的可解释性方法，在第4节中回顾了提示LLMs的可解释性方法。在第5节中，我们讨论了可解释性方法的评估。最后，在第6节中，我们进一步讨论了与传统深度学习模型相比，解释LLMs的研究挑战，并提供了潜在未来研究方向的见解。本文旨在全面组织对解释复杂语言模型的最新研究进展。
Feature Attribution Explanation - 特征归因解释Attention-based Explanation - 基于注意力的解释Local Explanation - 局部解释Example-based Explanation - 基于示例的解释Natural Language Explanation - 自然语言解释Probing-based Explanation - 基于探针的解释Traditional Fine-tuning - 传统微调 Neuron Activation Explanation - 神经元激活解释 Global Explanation - 全局解释Paradigm (Sec.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79323dd2c7a74f3d39f0a7defa60a284/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86ff74b1c7c87dcd29efd385c998dc9b/" rel="bookmark">
			你也想做一个Elemen-ui吧！！！——Blueの前端路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
diglog组件
准备工作：
在diglog.vue中模仿element-ui搭建diglog框架
该组件需要完成的任务：
title
diglog.vue代码：
App.vue代码：
效果：
自定义dialog的宽度和距离顶部的
App.vue代码：
diglog代码：
效果：
自定义body内容
diglog.vue代码：
App.vue代码：
效果： 自定义footer内容
diglog.vue代码：
App.vue
效果： dialog的显示与隐藏
.sync
定义与原理
使用场景
使用方法
注意事项
实操
第一步：
第二步：
第三步：
效果
结语
前言 🎈🎈🎈Hello，Hello。这里是Blue，本篇文章我们将在前一篇文章http://t.csdnimg.cn/6atDj的基础上，继续封装组件。该组件为经常用的diglog，让我们来尝试去封装一下吧。希望各位在学习途中可以对组件有更多的理解。🎈🎈🎈
视频推荐：http://【VUE进阶-从0到1搭建UI组件库（1-3）】https://www.bilibili.com/video/BV1nJ411V75n?p=13&amp;vd_source=bb412cc25ca27e171f8e17085daad038 diglog组件 准备工作： 第一步：
我们先创建一个diglog.vue组件，再在App.vue中进行对diglog的使用 第二步：在main.js中去将diglog.vue组件声明为全局
import Diglog from './components/diglog.vue' Vue.component(Diglog.name, Diglog) 在diglog.vue中模仿element-ui搭建diglog框架 &lt;template&gt; &lt;div class="one-dialog_wrapper"&gt; &lt;div class="one-dialog"&gt; &lt;div class="one-dialog_header"&gt; &lt;span class="one-dialog_title"&gt;提示&lt;/span&gt; &lt;button class="one-dialog_headerbtn"&gt; &lt;i class="one-icon-close"&gt;&lt;/i&gt; &lt;/button&gt; &lt;/div&gt; &lt;div class="one-dialog_body"&gt; &lt;span&gt;这是一段信息&lt;/span&gt; &lt;/div&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86ff74b1c7c87dcd29efd385c998dc9b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/153/">«</a>
	<span class="pagination__item pagination__item--current">154/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/155/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>