<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d61e3e5d2c083d590ccd5edc6a759611/" rel="bookmark">
			谷粒商城实战笔记-126-全文检索-ElasticSearch-整合-测试保存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一，谷粒商城实战笔记-126-全文检索-ElasticSearch-整合-测试保存1，在Elasticsearch的配置类中增加通用设置2，索引数据3，验证 一，谷粒商城实战笔记-126-全文检索-ElasticSearch-整合-测试保存 1，在Elasticsearch的配置类中增加通用设置 public static final RequestOptions COMMON_OPTIONS; static { RequestOptions.Builder builder = RequestOptions.DEFAULT.toBuilder(); // builder.addHeader("Authorization", "Bearer " + TOKEN); // builder.setHttpAsyncResponseConsumerFactory( // new HttpAsyncResponseConsumerFactory // .HeapBufferedResponseConsumerFactory(30 * 1024 * 1024 * 1024)); COMMON_OPTIONS = builder.build(); } 这段代码的主要作用是：
配置客户端请求时携带的认证信息（如认证令牌）。定义了客户端处理大文件响应的方式，通过设置一个较大的缓冲区大小。 这些配置选项将在后续使用Elasticsearch客户端执行请求时被应用，比如在后面代码片段中 restHighLevelClient.index(request, COMMON_OPTIONS)，其中 COMMON_OPTIONS 被用作请求选项传递给客户端。这样，每次发送请求时都会自动包含这些设置，无需每次都手动配置。
2，索引数据 @Test public void indexData() throws IOException { IndexRequest request = new IndexRequest("users"); request.id("1"); //数据的id User user = new User(); user.setName("zhangsan"); user.setAge(18); user.setGender("男"); String jsonString = JSON.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d61e3e5d2c083d590ccd5edc6a759611/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e97599bb447bcd32edb26dae2bc1c8f/" rel="bookmark">
			（五）activiti-modeler 编辑器初步优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最终效果： 1..首先去掉顶部的logo，没什么用，还占用空间。 修改modeler.html文件，添加样式：
&lt;style type="text/css"&gt; #main-header{ display: none; } #main{ padding: 0px; } &lt;/style&gt; 2.左边组件选择区域太宽了，一般用不到那么宽。 修改editor-app/editor.html文件。添加样式：
同样的，下面改为 col-lg-10 总共加起来12格。
3.中间下方的属性编辑面板希望放到右侧去。 4.右侧属性编辑将一行2个改为一行1个。 html, body{ margin: 0px; padding: 0px; } #main-header{ display: none; } #main{ margin: 0px; padding: 0px; } .selected-item-section clearfix{ float: left; width: 100%; } .selected-item-section .property-row{ float: none; width: 100%; display: flex; height: 29px; } .selected-item-section .selected-item-body{ width: 100%; height: 100%; } .selected-item-body &gt; div { overflow: auto; margin: 0px; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e97599bb447bcd32edb26dae2bc1c8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/978d33b9588977ee795b02f63ee61c06/" rel="bookmark">
			手机在网状态接口如何对接？（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是手机在网状态？ 传入手机号码，查询该手机号的在网状态，返回内容有正常使用、停机、在网但不可用、不在网（销号/未启用/异常）、预销户等多种状态。
二、手机在网状态使用场景？ 1.用户验证与联系：
（1）电商平台在用户注册或修改重要信息时，可以通过手机在网状态接口验证用户手机号码的有效性。如果手机处于无法连接网络或不在网状态，可能提示用户检查手机状态或更换联系方式，以确保能够及时与用户取得联系，如发送订单确认信息、物流配送通知等。
（2）对于一些高价值商品的销售，电商平台可以在发货前再次确认用户手机在网状态，以确保用户能够及时接收快递配送的相关通知，避免因联系不上用户导致的配送延误或商品丢失等问
2.物流配送优化：
（1）物流企业在配送过程中，可以根据收件人的手机在网状态来优化配送时间和方式。如果收件人手机长时间处于离线状态，物流配送人员可以选择在其手机重新上线后再进行联系配送，或者尝试通过其他备用联系方式（如果有的话）通知收件人。例如，对于一些生鲜食品的配送，确保能够及时联系到收件人尤为重要，通过关注手机在网状态可以提高配送的成功率和客户满意度。
（2）在物流跟踪系统中，结合手机在网状态可以提供更精准的服务。比如，当物流状态更新为“即将派送”时，如果系统检测到收件人手机在网，物流企业可以通过短信或应用推送的方式提醒收件人做好收货准备，提高配送效率。
三、如何调用手机在网状态接口？ 下面我们以快证API为例，通过Java调用该接口，以下为示例代码：
public static void main(String[] args) { String host = "https://kzmstatev1.market.alicloudapi.com"; String path = "/api-mall/api/mobile_status/check"; String method = "POST"; String appcode = "你自己的AppCode"; Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;(); //最后在header中的格式(中间是英文空格)为Authorization:APPCODE 83359fd73fe94948385f570e3c139105 headers.put("Authorization", "APPCODE " + appcode); //根据API的要求，定义相对应的Content-Type headers.put("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8"); Map&lt;String, String&gt; querys = new HashMap&lt;String, String&gt;(); Map&lt;String, String&gt; bodys = new HashMap&lt;String, String&gt;(); bodys.put("mobile", "mobile"); try { /** * 重要提示如下: * HttpUtils请从 * https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/978d33b9588977ee795b02f63ee61c06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63f7a9ce33e742873aceb45e86cf9c33/" rel="bookmark">
			了解Java中的反射，带你如何使用反射
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		反射的定义 反射（Reflection）是Java的一种强大机制，它允许程序在运行时动态地查询和操作类的属性和方法。通过反射，Java程序可以获取类的信息，比如类的名称、方法、字段，以及可以动态地创建对象、调用方法和改变字段的值。
反射的主要用途包括：
动态加载类：在运行时加载类，而不需要在编译时确定。查看类的结构：获取类的方法、字段、构造函数等信息，便于开发和调试。实现通用代码：通过反射可以编写更为通用的代码，例如框架和库可以利用反射来实现插件或扩展机制。访问和修改属性：可以在不知道对象具体类型的情况下，访问和修改其属性。 反射的实现一般通过Java的 java.lang.reflect 包进行，常用的类包括 Class、Method、Field 和 Constructor 等。使用反射需要注意性能开销和安全问题，因此在使用时要权衡其必要性。
反射的用途 反射在Java中的用途非常广泛，以下是一些主要的用途：
动态类加载：
可以在运行时加载和实例化类，而不需要在编译时确定类的确切类型。这对于插件架构和动态模块加载非常有用。 获取类的信息：
通过反射，可以获取类的名称、父类、接口、构造函数、方法和字段等信息，这对于调试和开发工具的实现非常重要。 动态方法调用：
可以在运行时调用对象的方法，而不需要在编译时知道方法名。这使得可以实现更加灵活的代码，比如根据用户输入或配置文件调用不同的方法。 访问和修改属性：
可以访问和修改对象的私有字段，例如进行测试时需要操作私有属性的情况。 实现通用库和框架：
许多Java框架（如Spring、Hibernate）使用反射来实现依赖注入、AOP（面向切面编程）、ORM（对象关系映射）等功能，使得框架能够对用户的应用程序进行灵活处理。 对象序列化与反序列化：
反射可以用于将对象转换为字节流或从字节流恢复对象，常用于对象的持久化和网络传输。 单元测试和Mock对象：
在单元测试中，可以使用反射来创建Mock对象，或访问被测试对象的私有方法和属性，进行更全面的测试。 反射提供了灵活性和可扩展性，但使用时也要注意其性能开销和对程序安全性的影响。
反射相关的类 在Java中，反射相关的类主要集中在 java.lang.reflect 包中，以下是一些常用的反射相关类：
Class：
代表一个类或接口的对象。可以用它来获取类的信息，包括类的名称、父类、实现的接口、字段、方法和构造方法等。 Method：
表示类中的某个方法。可以通过 Method 类调用该方法，获取方法的参数类型、返回值类型等信息。 Field：
表示类中的某个字段（属性）。可以用它来获取字段的类型、访问修饰符，并可以通过反射访问或修改字段的值。 Constructor：
表示类的构造函数。可以通过 Constructor 类创建新的对象实例，并获取构造函数的参数类型、修饰符等信息。 Array：
提供了对数组的静态方法，可以动态地创建和访问数组。 AccessibleObject：
是 Field、Method 和 Constructor 的父类，包含了一个用于设置访问权限的方法 setAccessible(boolean flag)，可以通过它来访问私有成员。 InvocationTargetException：
当通过反射调用方法时，如果被调用的方法抛出异常，将会封装在这个异常中。 这些类提供了强大的能力，使得开发者能够在运行时动态地操作类和对象，从而实现灵活和可扩展的代码设计。在使用反射时，需要注意性能开销和安全性问题。
反射的一些相关类的方法 1. Class 类的方法 getName()：返回类的完全限定名（包括包名）。getSuperclass()：返回此 Class 对象所表示的类的父类的 Class 对象。getInterfaces()：返回一个 Class 对象数组，表示所实现的接口。getDeclaredMethods()：返回一个 Method 对象数组，表示此类声明的所有方法（包括私有方法）。getDeclaredFields()：返回一个 Field 对象数组，表示此类声明的所有字段（包括私有字段）。getDeclaredConstructors()：返回一个 Constructor 对象数组，表示此类声明的所有构造函数。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63f7a9ce33e742873aceb45e86cf9c33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e67eaf7c42896596da3cf14899c1e8f/" rel="bookmark">
			LeetCode面试150——134加油站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目难度：中等
默认优化目标：最小化平均时间复杂度。
Python默认为Python3。
目录
1 题目描述
2 题目解析
3 算法原理及代码实现
3.1 贪心算法
参考文献
1 题目描述 在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。
你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。
给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。
示例 1:
输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2] 输出: 3 解释: 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。 因此，3 可为起始索引。 示例 2:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e67eaf7c42896596da3cf14899c1e8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b328a36209a65e1d386a0f0eb5b72a9/" rel="bookmark">
			【数据结构】排序算法（冒泡排序、插入排序、希尔排序、选择排序、堆排序、计数排序）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生命不可能有两次，但许多人连一次也不善于度过。💓💓💓 目录
✨说在前面
🍋知识点一：排序的概念和应用
• 🌰1.排序及其概念
• 🌰2.排序的应用
• 🌰3.常见的排序算法
🍋知识点二：常见排序算法的实现
• 🌰1.冒泡排序
• 🌰2.直接插入排序
• 🌰3.希尔排序
• 🌰4.选择排序
• 🌰5.堆排序
• 🌰6.计数排序
• ✨SumUp结语
✨说在前面 亲爱的读者们大家好！💖💖💖，我们又见面了，在之前的阶段我们已经将几种常见数据结构都学习完了，接下来这几章我们学习数据结构的应用——排序算法。排序算法有很多种，我接下来将会一一带着大家了解和学习。
今天我们将要学习的排序有——冒泡排序、插入排序、希尔排序、选择排序、堆排序和计数排序。排序算法是数据结构中非常重要的一块内容，我们今天就揭开排序算法神秘的面纱，详细剖析和体会排序算法独特的魅力吧~
博主主页传送门：愿天垂怜的博客
🍋知识点一：排序的概念和应用 • 🌰1.排序及其概念 排序：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。
稳定性：假定再待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即再原序列中，存r[i] = r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍然在r[j]之前，则称这种排序是稳定的；否则称为不稳定的。
内部排序：数据元素全部放在内存中的排序。
外部排序：数据元素太多不能同时放在内存中，根据排序的要求不断地在内外存之间移动数据的排序。
• 🌰2.排序的应用 排序在生活中无处不在。我们再逛淘宝、京东的时候，挑选喜欢的商品，希望它的性价比能够高，常常会将该类商品按照价格、销量、评论等方式进行排列，挑选最好的那一个；这里就用到了排序。
大家在高中毕业后查找心仪的院校，也会观察院校在排名中的位次，这个排名也是按照一定方式进行的排列。 所以说，生活中处处有排序，处处都用到排序。 • 🌰3.常见的排序算法 我们常见的排序算法有以下几种：
🍋知识点二：常见排序算法的实现 • 🌰1.冒泡排序 冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历数列的工作是重复进行的，直到没有再需要交换的元素，这意味着数列已经排序完成。这个算法的名字由来是因为越小（或越大）的元素会经由交换慢慢“浮”到数列的顶端。
冒泡排序的基本思路：
1.比较相邻的元素：如果第一个比第二个大（升序排序中），就交换它们两个；
2.对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数；
3.针对所有的元素重复以上的步骤，除了最后一个；
4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
代码如下：
void BubbleSort(int* arr, int length) { assert(arr); for (int j = 0; j &lt; length; j++) { int flag = 1; for (int i = 0; i &lt; length - j; i++) { //前一个比后一个大就交换 if (arr[i] &gt; arr[i + 1]) { int temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; flag = 1; } } //如果没有交换过，flag=0，说明已经全部排好，不用再循环 if(flag == 0) { break; } } } 时间复杂度分析：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b328a36209a65e1d386a0f0eb5b72a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42c47e91487afcc3f081e56bc6d973b3/" rel="bookmark">
			小巧免费的笔记本电池检测工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BatteryInfoView是一款免费的笔记本电池检测软件，适用于笔记本电脑和上网本。该软件能够提供电池的详细信息，包括电池名称、制造商名称、序列号、制造日期、电源状态（充电/放电）、当前电池容量、完全充电容量、设计容量、充电放电比率以及电池温度等。
用户可以通过BatteryInfoView全面了解自己笔记本电池的状态，例如电池的健康度、损耗度等信息，这些数据对于电池管理和维护非常有帮助。此外，该软件还提供了一个日志窗口，可以记录电池状态，并且可以选择每30秒或任何其他时间间隔更新记录。
BatteryInfoView不仅显示电池的基本信息，还可以通过实时预览功能，在更换电池之前在Windows中预览电池的状态，从而避免因更换错误的电池而造成的损失。另外，该软件支持汉化版本，方便中文用户使用。
BatteryInfoView是一款简单实用的工具，可以帮助用户更好地管理和维护他们的笔记本电池，延长电池的使用寿命。
★★★★★笔记本电池检测工具：https://pan.quark.cn/s/e9e138f8f520
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfa70e420b12c4bc5e850f203d8e9bb0/" rel="bookmark">
			什么是云原生？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前言 停下手头的工作，让你的同事定义“云原生”一词。你很可能会得到几个不同的答案。
1.1 让我们从一个简单的定义开始： 云原生架构和技术是一种设计、构建和操作在云中构建并充分利用云计算模型的工作负载的方法。
1.2 云原生计算基金会给出了官方定义： 云原生技术使组织能够在现代动态环境（例如公共云、私有云和混合云）中构建和运行可扩展的应用程序。容器、服务网格、微服务、不可变基础设施和声明性
API 就是这种方法的典型代表。
这些技术可实现松散耦合的系统，使其具有弹性、可管理性和可观察性。结合强大的自动化功能，工程师能够以最少的辛劳频繁且可预测地进行高影响的更改。
云原生关乎速度和敏捷性。业务系统正在从支持业务能力发展成为加速业务速度和增长的战略转型武器。将新想法立即推向市场势在必行。
与此同时，业务系统也变得越来越复杂，用户的要求也越来越高。他们期望快速响应、创新功能和零停机时间。性能问题、重复错误和无法快速行动已不再可接受。您的用户将访问您的竞争对手。云原生系统旨在适应快速变化、大规模和弹性。
以下是一些已实施云原生技术的公司。想想他们所实现的速度、敏捷性和可扩展性。
公司经验Netflix有600个服务投入生产。每天部署100次。优步有 1,000 项服务投入生产。每周部署数千次。微信有3,000个作品服务投入生产。每天部署1,000次。 如您所见，Netflix、Uber 和微信都公开了由许多独立服务组成的云原生系统。这种架构风格使他们能够快速响应市场状况。它们可以即时更新实时复杂应用程序的小部分，而无需完全重新部署。它们可以根据需要单独扩展服务。
2. 云原生的支柱 云原生的速度和敏捷性源自多种因素。最重要的是云基础设施。但还有更多：图 1-3 所示的其他五个基础支柱也为云原生系统提供了基石。
图 1-3 . 云原生基础支柱
让我们花点时间来更好地理解每个支柱的意义。
2.1 云端（The cloud） 云原生系统充分利用云服务模型。
**这些系统专为在动态的虚拟化云环境中蓬勃发展而设计，广泛使用平台即服务 (PaaS)计算基础架构和托管服务。**它们将底层基础架构视为一次性用品- 只需几分钟即可配置，并可根据需要通过自动化调整大小、扩展或销毁。
考虑一下我们对待宠物和商品的方式之间的区别。在传统的数据中心，服务器被视为宠物：一台物理机器，被赋予一个有意义的名字，并受到照顾。您可以通过向同一台机器添加更多资源（扩展）来扩展。如果服务器生病了，您可以照顾它恢复健康。如果服务器不可用，每个人都会注意到。
商品服务模型有所不同。您将每个实例配置为虚拟机或容器。它们是相同的，并分配有系统标识符，例如 Service-01、Service-02 等。您可以通过创建更多实例（横向扩展）进行扩展。当实例不可用时，没有人会注意到。
商品模型包含不可变的基础设施。服务器无需维修或修改。如果一台服务器发生故障或需要更新，则会将其销毁并配置新的服务器 - 所有这些都通过自动化完成。
云原生系统采用商品服务模式。无论基础设施规模如何扩大或缩小，它们都能持续运行，与运行在哪台机器上无关。
Azure 云平台通过自动扩展、自我修复和监控功能支持这种高度弹性的基础设施。
2.2 现代设计（Modern design） 构建基于云的应用程序的一种广泛接受的方法是十二要素应用程序。它描述了开发人员遵循的一组原则和实践，以构建针对现代云环境优化的应用程序。特别关注跨环境的可移植性和声明性自动化。
虽然适用于任何基于 Web 的应用程序，但许多从业者认为十二要素是构建云原生应用的坚实基础。基于这些原则构建的系统可以快速部署和扩展，并添加功能以快速响应市场变化。
下表重点介绍了十二因素方法：
事件解释1 - 代码库每个微服务都有一个单独的代码库，存储在其自己的存储库中。通过版本控制进行跟踪，可以部署到多个环境（QA、Staging、Production）。2 - 依赖项每个微服务隔离并节省自己的依赖项，从而接受变化而不影响整个系统。3 - 配置配置信息从微服务中移出，并通过代码外部的配置管理工具进行外部化。只要应用了正确的配置，相同的配置就可以跨环境传播。4 – 支持服务辅助资源（数据存储、存储、消息代理）应通过可接收的URL公开。这样可以将资源与应用程序分离，可以相互分离。5 - 构建、发布、运行第二个发布都必须严格区分构建、发布和运行阶段。每个阶段都应标记唯一的ID并支持回滚功能。现代CI/CD系统有助于实现这一原则。6 - 流程每个微服务都应该在自己的进程中执行，与其他正在运行的服务隔离。将所需的外部状态化到全局存储或数据存储等支持服务。7 - 端口绑定每个微服务都应该是独立的，其接口和功能应该在自己的端口上公开。这样做可以与其他微服务隔离。8 - 並發需要增加容量时，跨相同进程（副本）水平扩展多个服务，而不是在功能最强大的机器上扩展单个大型实例。开发应用程序同时进行，从而在云环境中扩展。9 - 可处置性服务实例应该是瞬时的。支持快速启动以增加可扩展性的机会，并支持正常关闭以使系统处于正确的状态。Docker 容器以及编排器本身就满足了这个要求。10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfa70e420b12c4bc5e850f203d8e9bb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54d043c14c6547160eb246c881b9f91a/" rel="bookmark">
			《C/C&#43;&#43;实战进阶》介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🚀 前言 本文是《C/C++实战进阶》专栏的说明贴（点击链接，跳转到专栏主页，欢迎订阅，持续更新…）。
专栏介绍：以多年的开发实战为基础，总结并讲解一些的C/C++基础与项目实战进阶内容，以图文并茂的方式对相关知识点进行详细地展开与阐述！专栏涉及了C/C++领域多个方面的内容，包括C++基础及编程要点（模版泛型编程、STL容器及算法函数的使用等）、C++11及以上新特性（不仅看开源代码会用到，日常编码中也会用到部分新特性，面试时也会涉及到）、常用C++开源库的介绍与使用、代码分享（调用系统API、使用开源库）、常用编程技术（动态库、多线程、多进程、数据库及网络编程等）、软件UI编程（Win32/duilib/QT/MFC）、C++软件调试技术（排查软件异常的手段与方法、分析C++软件异常的基础知识、常用软件分析工具使用、实战问题分析案例等）、设计模式、网络基础知识与网络问题分析进阶内容等。
本专栏的内容都是建立在项目实践的基础上，很有实战参考价值！在这里，你将学到大量通过实践总结出来的C++相关知识与技能！
专栏适用人群：适合基础进阶和想做技术提升的C++开发人员！
本专栏是接下来要重点打造的技术专栏，目前专栏文章已经更新到300多篇，还在持续的更新中，欢迎订阅！
专栏文章还在持续更新 ing… 如果文章有用，可以点赞、收藏、关注，也可以订阅专栏！
🔰 专栏内容 本专栏主要包含以下多个方面的内容：（本专栏涵盖了多方面的内容，订阅本专栏，你将获取如下这些全面的内容！本专栏融合了本人多个专栏的内容，订阅了本专栏，相当于订阅了多个专栏！）
📢 1、C++ 专栏开篇就系统地介绍了C/C++的学习路线，并给出了学习C/C++经典书籍推荐！本部分结合项目实践和经验，讲解一些日常工作中常用的C++要点知识（比如常用关键字、预编译指令、编程技巧等）以及一些需要重点关注的内容。比如会讲到模板函数与模板类等泛型编程、日常编码中常用的STL标准模板库的内容（比如如何使用STL算法函数提高STL容器列表的遍历效率、使用STL容器时哪些场景下容易产生异常）、C语言SEH结构化异常中的异常捕获__try…__except、C++中的异常捕获try…catch等。
📢 2、C++11及以上新特性 C++11是C++发展史上一次里程碑的更新，引入了大量的新特性（引入一些新的关键字、左值右值、左值引用、右值引用、移动语义、完美转发、匿名函数、智能指针、并发编程等），极大地扩展了C++的应用范围和表达能力，开启了现代C++时代。此后，C++标准化组织又陆续推出了C++14、C++17和C++20新特性，这些新特性相对C++11要少很多，都是在C++11基础上的锦上添花。
我们需要重点掌握C++11的新特性。很多C++开源代码积极拥抱C++11及以上的新特性，比如大型开源库WebRTC，大量地使用了C++11及以上的新特性。所以，我们在阅读开源代码时要熟悉C++11等新特性，在日常项目开发过程中也会或多或少地使用C++11新特性。此外，通过近几年的观察，C++11新特性已成为很多公司面试时必问的内容。所以学习C++11新特性很有必要，不仅学习阅读开源代码时会用到，日常工作中也会或多或少地用到，而且面试时也会涉及到。
C++新特性，使得C++变得更灵活更高效，但也使得C++变得更加臃肿，更加难以驾驭！
强烈推荐大家去看看Google的C++代码风格指南（Google C++ Style Guide），其中讲到了大量的C++老特性与新特性。有国内程序员翻译而来的中文版本，可以去https://github.com/zh-google-styleguide/zh-google-styleguide下载中文版本pdf文档（不仅仅有C++风格指南，还有Objective-C、Shell、JavaScript、Python、TypeScript这些语言的风格指南）。也可以去网址https://google.github.io/styleguide查看原汁原味的英文版本（英文原版还有更多语言的风格指南）。
本指南的目的是通过详细阐述 C++ 注意事项来驾驭其复杂性。这些规则在保证代码易于管理的同时，也能高效使用 C++ 的语言特性（讲到了大量的C++新特性）。
本指南不仅仅是编码规范，它列出了你要怎么做, 还告诉你为什么要这么做，哪些情况下可以不这么做，以及如何权衡其利弊。
📢 3、C++开源库介绍与使用 会介绍一些常用的开源库，介绍如何去使用常用的开源库（比如如何去调用接口、使用开源库的要点及注意点、使用开源库的问题排查与经验总结）、如何去编译一些开源库、如何使用开源库去搭建一些简单可用的应用系统，并给出项目中使用的部分实例。常见的开源库有sqlite、libcurl、libwebsockets、libevent、boost、jsoncpp/rapidjson、rabbitmq、mqtt、zookeeper、opencv、ffmpeg、sdl、gstreamer、live555、nginx、reactos等。
学习开源库的代码，可以了解开源库内部的业务逻辑，也可以学习开源库的编程思想，后面在使用开源库时会更加得心应手。
📢 4、常用代码分享 会分享一些日常工作中常用功能的实现代码，代码经过项目验证，可以直接拿去使用。比如如何调用系统API去实现一些功能、如何使用libcurl、zlib、zip.cpp/unzip.cpp、libqr、md5、libpng、sqlite、cef、tinyxml、jsoncpp/rapidjson等开源库去实现若干功能。
📢 5、编程技能 会讲到一些常用的编程技能，比如动态库编程、多线程编程（多线程通信与多线程同步）、多进程编程、数据库编程（连接数据库以及SQL语句的编写及SQL语句查询效率优化）、线程间通信及进程间通信、socket网络编程（包含TCP/IP协议栈相关内容）等。会介绍一些开发实践中的要点与编程细节，以及相关问题的排查案例。
📢 6、C++软件调试技术 考察一个开发人员的水平，一方面要看其软件开发与设计能力，另一方面要看其软件调试能力。所以，软件调试能力很重要。
大部分C++开发人员在软件调试这一块都比较欠缺，分析和排查软件异常问题的手段和方法比较单一，处理问题的效率不高，有时甚至会影响到项目推进的进度。
为了解决广大开发人员普遍缺乏调试能力的痛点问题，我们会介绍很多软件调试方面的内容：
1）系统地介绍引发C++软件异常的常见原因以及排查C++软件异常的常用方法。
2）详细介绍常用IDE的调试方式以及使用IDE开发调试的常用经验和技巧。
3）讲解排查C++软件异常所需要掌握的基础汇编知识。了解汇编，可以从汇编的角度去理解很多高级语言无法理解的代码执行细节（比如多线程代码的执行细节），还可以查看汇编上下文去辅助分析和排查软件异常问题。
4）介绍一些常用的分析软件内存问题的专用内存分析工具，比如Windbg、Valgrind和AddressSanitizer等。
5）介绍一些分析软件异常问题所需要掌握的基础知识，比如程序的内存分区、函数调用的栈分布、栈回溯原理、虚函数调用的汇编代码实现、函数调用约定等。
6）系统地介绍日常工作中一些常用的软件分析工具SPY++、Dependency Walker、Process Explorer、Process Hacker、Process Monitor、API Monitor、Windbg、IDA、Clumsy等，并给出使用这些工具分析问题的项目问题分析实例。
7）介绍与分析软件异常息息相关的pdb文件（pdb文件的时间戳和名称、如何加载pdb文件、哪些工具需要使用到pdb文件）、dump文件（如何生成dump文件、生成dump文件的方式有哪些、如何使用Windbg分析dump文件等）。
8）给出多个项目中遇到的软件异常分析实例（比如程序启动失败或启动报错、各类软件崩溃实例），详细讲解了整个问题排查的过程，有很强的实战参考价值。同时也方便大家跟着案例进行学习和实操。后续新的问题排查案例，也会更新到本专栏中！
关于C++软件调试与异常排查更详细的内容，可以去查看我的精品技术专栏：（目前专栏订阅量已达500多个，专栏质量很高，有很强的实战参考价值，广受好评！）
C++软件调试与异常排查从入门到精通系列文章汇总
https://blog.csdn.net/chenlycly/article/details/125529931
📢 7、软件UI编程 所谓软件UI编程，就是使用UI界面库进行客户端软件界面的开发，一方面会涉及到产品的业务，另一方面会涉及到UI界面编程，其中UI界面编程占了较大的比重。本专栏也会讲到常用的UI界面库MFC、开源duilib库、跨平台QT库相关的内容，主要是使用这些UI库的要点及问题排查经验总结。
📢 8、设计模式 设计模式在日常工作中也会时常用到，比如常见的单例模式、简单工厂模式、观察者模式（订阅）、状态模式（状态机）、适配器模式等。在面试时也会问到设计模式相关的问题，比如使用过哪些设计模式、说说某个设计模式的设计思想以及可以解决什么样的问题。一般不要求掌握所有的设计模式，知道并使用过若干个设计模式即可，需要了解更多时再去学习也可以的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54d043c14c6547160eb246c881b9f91a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4570e43cb419df88929db6ed41d6abe2/" rel="bookmark">
			WebRTC简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WebRTC简介
WebRTC（Web Real-Time Communication）是一项开源的实时通信技术，它允许网页浏览器进行实时语音、视频和数据共享通信，而无需安装额外的插件或应用程序。WebRTC的出现极大地简化了实时通信的开发和部署过程，使得实时音视频通信变得更加普及和便捷。以下是对WebRTC的详细介绍。
一、WebRTC的起源与发展 WebRTC最初由一家名为Global IP Solutions（简称GIPS）的瑞典公司开发。Google在2011年收购了GIPS，并将其技术开源，随后与IETF（Internet Engineering Task Force）和W3C（World Wide Web Consortium）等标准组织合作，推动WebRTC技术的标准化进程。目前，WebRTC已经成为实时通信领域的重要标准之一，得到了广泛的支持和应用。
二、WebRTC的核心技术 WebRTC技术的核心在于其能够直接在浏览器之间建立点对点（Peer-to-Peer，简称P2P）的连接，实现音视频流和其他数据的实时传输。这一过程中，WebRTC主要依赖于以下几个关键技术：
媒体捕获：WebRTC使用Web APIs（如getUserMedia和getDisplayMedia）从本地设备（如摄像头和麦克风）捕获音频和视频流。这些API允许网页应用直接访问用户的音视频设备，而无需通过额外的插件或应用程序。
媒体传输：捕获到的音视频数据需要经过编解码器处理，转换成适合网络传输的格式。WebRTC支持多种编解码器，如Opus（音频）、VP8/VP9（视频）等。同时，WebRTC使用RTP（Real-Time Transport Protocol）和UDP（User Datagram Protocol）等协议来传输音视频媒体流。
网络连接：WebRTC使用ICE（Interactive Connectivity Establishment）协议来建立对等连接。ICE协议能够处理NAT（网络地址转换）和防火墙等问题，确保音视频数据能够在复杂的网络环境中顺利传输。ICE结合了STUN（Session Traversal Utilities for NAT）和TURN（Traversal Using Relays around NAT）服务器来辅助建立连接。
信令传输：虽然WebRTC连接是P2P的，但在建立连接之前需要交换一些信令信息（如IP地址、端口号等）。这些信令信息通常通过一个独立的信令服务器进行交换。信令服务器可以使用WebSocket、Socket.IO等技术来实现。
PeerConnection：WebRTC的核心是PeerConnection API，它允许浏览器之间建立点对点连接，直接传输音频、视频和数据。PeerConnection API提供了丰富的接口和功能，使得开发者能够轻松地实现实时通信应用。
三、WebRTC的应用场景 WebRTC的能力使其适用于各种实时通信场景，包括但不限于以下几个方面：
视频会议：WebRTC可以用于构建多方视频会议系统。用户只需通过浏览器即可参与会议，无需安装额外的软件或插件。这使得视频会议变得更加便捷和普及。
实时音视频通话：WebRTC支持浏览器之间的点对点音视频通话。无论是Web电话还是视频聊天应用，都可以利用WebRTC技术来实现实时通信。
数据共享：WebRTC不仅可以传输音视频流，还可以传输任意类型的数据。这使得WebRTC非常适合用于实时共享文件、屏幕或其他类型的数据。
直播和流媒体：WebRTC可以用于构建实时直播和流媒体服务。用户可以通过浏览器观看实时的音视频内容，无需依赖专业的流媒体服务器或播放器。
远程协作：WebRTC在远程协作领域也有广泛的应用。例如，远程团队会议、远程教育和远程医疗等场景都可以利用WebRTC技术来实现实时通信和协作。
四、WebRTC的优势 无需插件或应用程序：WebRTC直接在浏览器中运行，无需安装额外的插件或应用程序。这使得用户可以更加便捷地参与实时通信。
低延迟和高效率：由于WebRTC采用了P2P连接技术，音视频数据可以直接在浏览器之间传输，减少了服务器的负担和传输延迟。同时，WebRTC支持多种编解码器和传输协议，可以根据网络状况自动调整传输参数，确保音视频通信的流畅性和高效性。
跨平台支持：WebRTC支持多种浏览器和操作系统平台，包括Chrome、Firefox、Safari等主流浏览器以及Windows、macOS、Linux等操作系统。这使得WebRTC应用具有广泛的兼容性和可移植性。
易于开发和部署：WebRTC提供了丰富的API和工具集，使得开发者可以轻松地实现实时通信应用。同时，WebRTC的开源特性也使得其技术文档和社区支持非常丰富和活跃。
五、WebRTC在5G和物联网中的应用 5G与WebRTC的结合：
5G网络的低延迟、高带宽特性为WebRTC带来了前所未有的机遇。在5G环境下，WebRTC可以更加稳定地实现高清甚至超高清的音视频通信，同时支持更多的并发用户和更复杂的实时互动场景。例如，在远程医疗领域，医生可以通过5G+WebRTC技术实现超高清视频会诊，实时传输患者的影像资料，提高诊断的准确性和效率。
物联网与WebRTC的融合：
物联网（IoT）的快速发展使得越来越多的设备能够接入互联网，并实现相互之间的通信。WebRTC技术为物联网设备之间的实时音视频通信提供了可能。通过将WebRTC集成到物联网设备中，可以实现设备之间的远程监控、故障诊断、远程控制等功能。例如，在智能家居领域，用户可以通过手机浏览器与家中的智能摄像头建立WebRTC连接，实时查看家中的情况，甚至与家中的智能机器人进行音视频交互。
六、WebRTC的安全性与隐私保护 尽管WebRTC带来了诸多便利，但其安全性和隐私保护问题也不容忽视。由于WebRTC通信是直接在浏览器之间进行的，因此面临着诸如中间人攻击、数据泄露等安全风险。为了保障WebRTC通信的安全性，开发者需要采取一系列措施来加强安全防护：
使用HTTPS：确保WebRTC应用的信令传输通过HTTPS协议进行，以防止信令信息在传输过程中被截获或篡改。
数据加密：对音视频数据进行加密传输，确保数据在传输过程中的机密性和完整性。WebRTC支持DTLS（Datagram Transport Layer Security）协议来加密RTP/UDP传输的数据。
身份验证：在建立WebRTC连接之前，对通信双方进行身份验证，确保只有合法的用户才能参与通信。
访问控制：对WebRTC设备的访问进行严格控制，防止未经授权的访问和操作。
隐私政策：制定并遵守严格的隐私政策，明确告知用户其个人信息的收集、使用和保护方式，尊重用户的隐私权利。
七、WebRTC的开源社区与生态系统 WebRTC的开源特性吸引了众多开发者和企业的关注与参与。目前，WebRTC的开源社区非常活跃，不断有新的技术和解决方案被提出和实现。同时，WebRTC的生态系统也日益完善，包括浏览器厂商、云服务提供商、硬件制造商等各方都在积极推动WebRTC的发展和应用。
八、结论 WebRTC作为一项开源的实时通信技术，凭借其无需插件、低延迟、高效率等优势，在视频会议、实时音视频通话、数据共享、直播流媒体等多个领域得到了广泛应用。随着5G、物联网等新兴技术的快速发展，WebRTC的应用前景将更加广阔。然而，在享受WebRTC带来的便利的同时，我们也需要关注其安全性和隐私保护问题，确保通信过程的安全可靠。未来，随着技术的不断进步和生态系统的日益完善，WebRTC将成为实时通信领域的重要力量，为更多创新应用提供强大的支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/476d6c3f2090578979b71af8b00fc939/" rel="bookmark">
			【人工智能】NLP入门指南：自然语言处理基础全解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、NLPNLP（自然语言处理）NLU（自然语言理解）NLG（自然语言生成） 二、分词1.什么是分词2.常见的分词工具3.jieba分词 三、词向量1.什么是词向量2.文本张量表示方法3.常见的词向量模型3.1 ont-hot 编码3.2 Word2Vec3.3 Embedding 四、TensorFlow Playground 前言 在数字化时代，自然语言处理（NLP）已成为人机交互的桥梁。本文将引导读者从基础到应用，全面了解NLP技术。首先，我们将探索NLP的两大支柱：自然语言理解（NLU）和自然语言生成（NLG），理解它们如何分别让机器理解与生成人类语言。接着，文章将深入中文文本的分词技术，特别是jieba分词的使用。进一步，我们将学习文本的数值表示方法，包括one-hot编码、Word2Vec和Embedding模型，这些技术赋予机器学习模型处理语言的能力。最后，通过TensorFlow Playground，我们将直观体验神经网络在NLP中的应用。
一、NLP NLP（自然语言处理） NLP（Natural Language Processing） 是自然语言处理的缩写，是人工智能和语言学领域的交叉学科，旨在让计算机能够理解和处理人类语言。NLP 的目标包括让计算机能够读取、解析、理解和生成人类语言文本，从而进行各种与语言相关的任务，如文本分类、情感分析、机器翻译、问答系统、聊天机器人等。
NLP 的研究内容主要以下几个方面：
词法分析：包括分词、词性标注、命名实体识别等。句法分析：分析句子结构，如短语划分、依存关系分析等。语义分析：理解句子或文本的含义，包括词义消歧、语义角色标注等。信息抽取：从文本中提取结构化信息，如关系抽取、事件抽取等。文本生成：根据特定要求生成自然语言文本，如文本摘要、文本续写等。文本分类：将文本划分为预定义的类别，如情感分析、主题分类等。机器翻译：将一种语言的文本转换为另一种语言的文本。问答系统：根据用户提出的问题，从文本或知识库中检索答案。 为了实现这些任务，NLP 研究者通常会使用各种算法和模型，如基于规则的方法、基于统计的方法、基于深度学习的方法等。近年来，随着深度学习技术的快速发展，基于神经网络的 NLP 模型，如循环神经网络（RNN）、长短期记忆网络（LSTM）、Transformer 等，在 NLP 任务中取得了显著的性能提升。
自然语言处理（NLP Natural Language Processing） 是一种专业分析人类语言的人工智能。就是在机器语⾔和⼈类语言之间沟通的桥梁，以实现人机交流的目的。
2个核心任务： 自然语言理解 NLU （Natural Language Understanding）自然语言生成 - NLG （Natural Language Generation） NLU（自然语言理解） 自然语言理解（Natural Language Understanding, NLU） 旨在使计算机能够理解和处理人类语言。它通过人工智能技术，从语音或文本输入中获取信息，并对其进行解析以提取有意义的内容。
通俗来说，NLU就是机器需要理解人的意思。举个栗子🌰，试着理解下面两句话（再试试看从机器的角度理解呢）：
冬天到了，衣服能穿多少穿多少夏天到了，衣服能穿多少穿多少 应用场景：
NLU广泛应用于语音识别、情感分析和垃圾邮件过滤等领域。例如，在智能助手中，NLU负责识别用户的查询意图和相关实体，以便做出准确的回应。
典型应用：
机器翻译（有道、百度翻译等）机器客服（各种app里面的机器客户）智能音箱（小爱音箱、天猫精灵等）
技术手段：
NLU的技术手段包括分词、词性标注、句法分析和语义角色标注等。这些技术帮助计算机从自然语言中提取有用的信息，并将其转化为可操作的数据。
NLG（自然语言生成） 自然语言生成（Natural Language Generation, NLG） 是将结构化数据转换为人类可以理解的自然语言的过程。NLG系统分析数据集，创建有意义的叙述，从而生成自然语言输出。
应用场景：
NLG的应用范围包括聊天机器人、语音助手和自动内容生成等。例如，企业可以利用NLG来创建自动报告，或者在客户服务中生成响应用户问题的文本。
典型应用：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/476d6c3f2090578979b71af8b00fc939/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31ec717b08361b0efbbfae04220767b3/" rel="bookmark">
			【Java EE】进程和线程的区别和联系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进程和线程的区别与联系 在现代计算机科学中，理解进程和线程的概念对于高效编程和系统设计至关重要。进程和线程都是操作系统并发执行的基本单元，但它们在资源管理、执行环境、通信方式等方面存在显著区别和联系。
进程和线程的区别 1. 基本概念 进程（Process）：是操作系统中独立运行的程序的实例。每个进程都有自己的地址空间、内存、文件描述符等资源。线程（Thread）：是进程内的一个执行单元，它共享进程的资源（如内存、文件描述符等）。 2. 资源分配 进程 是资源分配的基本单位，操作系统为每个进程分配独立的地址空间。线程 是CPU调度的基本单位，线程共享进程的地址空间和资源。 3. 通信方式 进程 之间通信需要使用进程间通信（IPC）机制，如管道、消息队列、共享内存等。线程 之间可以直接通过共享的内存空间进行通信，效率较高，但需要注意同步和互斥问题。 4. 开销 进程 的创建和销毁开销较大，因为需要分配和回收独立的资源。线程 的创建和销毁开销较小，因为线程共享进程的资源。 5. 独立性 进程 是相互独立的，一个进程的崩溃不会影响其他进程。线程 是相互依赖的，一个线程的崩溃可能导致整个进程的崩溃。 进程和线程的联系 1. 包含关系 一个进程可以包含多个线程，线程是进程的一部分。
2. 共享资源 线程共享进程的资源，如内存、文件描述符等。
3. 并发执行 进程和线程都可以并发执行，从而提高程序的运行效率和响应速度。
Java代码示例 以下是Java中创建和使用进程与线程的简单示例：
使用进程（ProcessBuilder） 在Java中，通常通过ProcessBuilder类来创建和管理进程。以下示例展示了如何启动一个新的进程来执行系统命令。
import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class ProcessExample { public static void main(String[] args) { ProcessBuilder processBuilder = new ProcessBuilder(); // 执行系统命令 "ping -c 3 google.com" (适用于Unix系统，Windows使用 "ping -n 3 google.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31ec717b08361b0efbbfae04220767b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ba8a46a5df72ef9681a6c89d19eec16/" rel="bookmark">
			详解C/C&#43;&#43;输入输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 C/C++输入输出很多，在不同的情况会用不同的输入输出，有的题目在输入时可能换一种输入输出就能不会TLE，有的输入可能要循环输入，但是可以换一种输入直接就能把所有数据输入进去。C/C++有哪些常用的输入输出，在什么时候用它们，这篇博客我会一一详解。
输入 一、cin cin是C++的输入，是C++里面最常用的一种输入。既可以输入数字，也可以输入字符、字符串。注意，cin输入字符串时，当遇到空格、回车、Tab都会结束。当需要输入空格时，那要用什么，后面会讲解。当输入空格字符时，cin不会把空格读入进去。
#include&lt;iostream&gt; #include&lt;cstring&gt; using namespace std; int n; string s; char a,b,c; int main(){ cin&gt;&gt;n; cin&gt;&gt;s; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; cout&lt;&lt;"数字为："&lt;&lt;n&lt;&lt;endl; cout&lt;&lt;"字符串为"&lt;&lt;s&lt;&lt;endl; cout&lt;&lt;"字符为"&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;" "&lt;&lt;c&lt;&lt;endl; return 0; } 二、scanf 用于从标准输入读取格式化的输入，例如整数、浮点数、字符串等,sacnf是C语言的输入，但是广泛应用于C++程序里面，这是因为C语言的scanf比C++的cin快3~4倍，这是因为scanf是用指针操作的，没有类型的安全机制，比如char类型scanf可以用%f输入，而不会报错，但是运行时会出现异常。cin是自动判断你的变量类型，比如char类型，他会用默认的char方法（%c）取数据。这就会影响的效率。
scanf遇到空格、Tab、回车都会结束输入。
当我们看别人程序时前面会出现一行代码，可以用这两行代码实现scanf与cin同步，时间几乎是一样的。
ios::sync_with_stdio(false); cin.tie(0); scanf在输入时，就比较个体化了，不同的类型都有不同的输入表示。
#include&lt;iostream&gt; #include&lt;cstring&gt; using namespace std; int n1; float n2; double n3; char ch[100],a,b; int main(){ scanf("%3d%f%lf",&amp;n1,&amp;n2,&amp;n3);//%3d接受三位数字 scanf("%s",ch);//不接受空格、Tab、回车 scanf("%c%c",&amp;a,&amp;b); printf("数字为：%d %.3f %.2f\n",n1,n2,n3);//%f自动转成%lf printf("字符数组为：%s\n",ch);//ch.c_str() printf("字符为：%c %c\n",a,b);//%c可以吃空格 return 0; } 注：在C语言中，scanf函数可以用于字符数组，但是在C++中，scanf函数不能直接用于string类。因为string是C++中的一个类，而scanf函数是C语言的函数，并不支持C++的类类型。
三、gets gets() 函数的功能是从输入缓冲区中读取一行字符串存储到字符指针变量 str 所指向的内存空间。可以接受空格、Tab，但是不接受回车。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ba8a46a5df72ef9681a6c89d19eec16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1195cb629ca9cd5f1125641c3a2545f9/" rel="bookmark">
			Python酷库之旅-第三方库Pandas(064)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、用法精讲
251、pandas.Series.tz_localize方法
251-1、语法
251-2、参数
251-3、功能
251-4、返回值
251-5、说明
251-6、用法
251-6-1、数据准备
251-6-2、代码示例
251-6-3、结果输出
252、pandas.Series.at_time方法
252-1、语法
252-2、参数
252-3、功能
252-4、返回值
252-5、说明
252-6、用法
252-6-1、数据准备
252-6-2、代码示例
252-6-3、结果输出
253、pandas.Series.between_time方法
253-1、语法
253-2、参数
253-3、功能
253-4、返回值
253-5、说明
253-6、用法
253-6-1、数据准备
253-6-2、代码示例
253-6-3、结果输出
254、pandas.Series.str方法
254-1、语法
254-2、参数
254-3、功能
254-3-1、转换大小写
254-3-2、字符串匹配和搜索
254-3-3、字符串替换和去除
254-3-4、字符串分割和连接
254-3-5、提取和访问子串
254-3-6、格式化和填充
254-3-7、长度和计数
254-4、返回值
254-5、说明
254-6、用法
254-6-1、数据准备
254-6-2、代码示例
254-6-3、结果输出
255、pandas.Series.cat方法
255-1、语法
255-2、参数
255-3、功能
255-4、返回值
255-5、说明
255-6、用法
255-6-1、数据准备
255-6-2、代码示例
255-6-3、结果输出
二、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、博客个人主页
一、用法精讲 251、pandas.Series.tz_localize方法 251-1、语法 # 251、pandas.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1195cb629ca9cd5f1125641c3a2545f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5db881b2220e5a0eda92163b01bcc46b/" rel="bookmark">
			Flink-StarRocks详解:第五部分查询数据湖(第55天)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 4.查询数据湖
4.1 Catalog
4.1.1 概述
4.1.1.1 基本概念
4.1.1.2 Catalog
4.1.1.3 访问Catalog
4.1.2 Default catalog
4.1.3 External Catalog
4.2 文件外部表
4.2.1 使用限制
4.2.2 开源版本语法
4.2.3 阿里云版本
5. 查询及优化
文章目录 系列文章目录前言4.查询数据湖4.1 Catalog4.1.1 概述4.1.1.1 基本概念4.1.1.2 Catalog4.1.1.3 访问Catalog 4.1.2 Default catalog4.1.3 External Catalog 4.2 文件外部表4.2.1 使用限制4.2.2 开源版本语法4.2.3 阿里云版本 5. 查询及优化 前言 本文为Flink-StarRocks详解后续章节：主要详解StarRocks查询数据湖
由于篇幅过长，后续接着下面进行详解：
数仓场景：即席查询大案例
4.查询数据湖 4.1 Catalog 4.1.1 概述 StarRocks 自 2.3 版本起支持 Catalog（数据目录）功能，实现在一套系统内同时维护内、外部数据，方便轻松访问并查询存储在各类外部源的数据。
4.1.1.1 基本概念 内部数据：指保存在 StarRocks 中的数据。
外部数据：指保存在外部数据源（如 Apache Hive™、Apache Iceberg、Apache Hudi、Delta Lake、JDBC）中的数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5db881b2220e5a0eda92163b01bcc46b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef3a273098eebe477859004edad9c401/" rel="bookmark">
			如何利用 ChatGPT 提高工作效率？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容创作与总结： 写作辅助：可以帮助撰写文章、报告、邮件等各种文本，如为招商银行写宣传文案、写论文、写故事等。学习材料生成：能够生成学习材料，如摘要、抽认卡和测验，帮助学生复习和学习课程。评估和考核测验的生成：可以评估小测验等考试的结果，帮助教师评估学生的理解度。课程材料生成：能够生成完整的课程材料，如教学大纲、课程计划和阅读材料。内容翻译：可以将教育内容从一种语言翻译成另一种语言，使学生更容易理解和获取信息。文案写作：可以帮助营销团队快速写出电子邮件、博客文章、社媒推文等，速度比以前快数倍。智能客服： 自动应答：利用自然语言处理技术实现自动应答，主要解决一些重复性的服务性请求，能有效响应客户要求，提高交互效率与任务成功率。客户需求分析：通过理解客户的意图并为客户提供反馈服务，帮助企业发现客户需求。金融咨询：在金融领域，利用其大模型能够大幅提升语义搜索能力，面对复杂多变的投资理财咨询，能够准确地找到满足用户需求的咨询结果。编程开发： 代码编写：初学者和兼职程序员可以使用ChatGPT更高效地编写中等质量的代码，将旧代码从旧语言转换成新语言会变得更容易。智能助手：一些工具可以让公司用现有代码和优秀用例训练算法，打造出智能助手之类的工具来协调所有存储库的代码及指导新员工等。医疗辅助： 导诊问诊：在医疗领域，完全可以替代专业人员为患者提供导诊、问诊和服药建议等。智能自诊：可以模拟临床医生问诊思维，与患者进行自然语言交互，进一步采集患者病情信息，结合医学知识图谱和机器学习模型，智能评估患者可能的患病情况。智能问药：根据患者提供的生理信息、病情，智能推荐药品。用药管家：辅助医疗机构为患者提供完善的个性化用药指导及用药服务，减轻药事工作压力，提升患者用药依从性。其他方面： 信息检索：可以回答各种问题，快速提供相关信息，如查询北京的美食、手机5G流量套餐等。解决问题的帮助：可以帮助学生解决问题，提供分步指示、策略建议和提示。职业指导：可以通过提供潜在职业信息、工作要求等帮助学生进行职业规划。时间管理协助：可以帮助学生进行时间管理，提供提示和策略，以提高其时间管理能力。家庭作业协助：可以通过提供解释、例子和额外资源帮助学生完成作业。 在提高企业运营效率方面有多种应用案例，以下是一些具体实例：
Waymark &amp; OpenAI：Waymark是一个视频广告制作平台，通过集成OpenAI的GPT-3技术，使用微调的GPT-3模型来创建视频脚本，极大提高了视频创作的效率和个性化程度，减少了客户编辑脚本的时间，使得企业能够更快速高效地推销、销售和支持更多的本地广告商 。
BukiHQ Medi &amp; fireflies.ai：BukiHQ Medi是一家公共关系咨询公司，利用fireflies.ai的AI笔记记录器有效解决了公关会议记录问题，减少了手动记笔记的时间浪费，提高了会议效率 。
Sabine &amp; Synthesia：博西家电集团使用Synthesia软件开发虚拟辅导员进行员工培训，通过生成式AI视频制作平台，提高了培训效率，节省了视频制作成本，并且提高了电子学习的参与度 。
Achievers &amp; Forethought：Achievers是一个员工语音识别解决方案平台，引入Forethought的AI生成平台，实现客户支持工单的自动化分类和解决，提高了首次联系解决率和客户支持团队的效率 。
RealDefense &amp; Observe.AI：RealDefense使用Observe.AI的智能劳动力平台，通过AI指导提高了销售业绩，实现了销售配额的完成率提高到103%，并建立了强大的反馈循环 。
MHI &amp; Lumen5：三菱重工（MHI）利用Lumen5的生成式AI视频平台，快速制作视频内容，提高了内容营销的效率和效果，增加了网站流量和社交媒体的粉丝互动 。 一家世界500强软件公司的客服研究：斯坦福大学和麻省理工大学的研究表明，生成式AI能显著提高客服人员的工作效率，平均提升14%，特别是新员工的效率提升了35% 。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52b3ce45a9da8a81e5690667eef060a0/" rel="bookmark">
			计算机网络总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.TCP/IP 网络分层模型 第一层叫“链接层”（link layer），负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次上，使用 MAC 地址来标记网络上的设备。第二层叫“网际层”（internet layer），IP 协议就处在网际层。用 IP 地址取代 MAC 地址，把许多局域网、广域网连接成一个虚拟的巨大网络，如果要在这个网络里找设备则要把 IP 地址“翻译”成 MAC 地址。第三层叫“传输层”（transport layer），负责在 IP 地址标记的两点之间“可靠”地传输数据，是 TCP 协议和 UDP 协议 这两个传输层协议工作的层次。 特性\传输层协议
TCP
UDP
是否是有状态的协议？
是
不是
是否需要事先建立连接
需要
不需要
数据的形式
连续的字节流，有先后顺序
分散的数据包，顺序发乱序收
第四层叫“应用层”（application layer），负责面向具体的应用传输数据，应用层有面向具体应用的各种协议，HTTP 协议就在这一层，还有一些例如 FTP 协议、SSH 协议 等等。 2.OSI 网络分层模型 第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等；第二层：数据链路层，它基本相当于 TCP/IP 的链接层，负责在底层网络上发送原始数据包，工作在物理层之上，使用MAC地址标记网络中的设备；第三层：网络层，相当于 TCP/IP 里的网际层，用IP地址取代MAC地址，将许多局域网、广域网连接成一张虚拟的巨大网络；第四层：传输层，相当于 TCP/IP 里的传输层，负责在IP地址标记的两点之间可靠的传输数据；第五层：会话层，维护网络中的连接状态，即保持会话和同步；第六层：表示层，把数据转换为合适、可理解的语法和语义；第七层：应用层，面向具体的应用传输数据。 3.OSI 网络分层模型 到 TCP/IP网络分层模型 的映射关系 第一层：物理层，TCP/IP 里无对应；第二层：数据链路层，对应 TCP/IP 的链接层；第三层：网络层，对应 TCP/IP 的网际层；第四层：传输层，对应 TCP/IP 的传输层；第五、六、七层：统一对应到 TCP/IP 的应用层。 “四层”和“七层”到底是什么？“五层”“六层”哪去了？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52b3ce45a9da8a81e5690667eef060a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30aeca9481be25710b8adcab3c7e20ba/" rel="bookmark">
			深入理解小程序的渲染机制与性能优化策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、小程序的渲染机制 小程序的渲染机制主要由两部分组成：渲染层和逻辑层。渲染层负责页面的渲染，逻辑层负责处理业务逻辑和数据处理。两者通过一个安全的、高效的通信机制进行数据传输和事件通知。
渲染层：在渲染层，WXML 模板会被解析并生成对应的节点树，节点树中的节点会与其对应的 WXML 节点保持同步。WXML 模板和 WXSS 样式会一起被用于生成最终的页面。 &lt;!-- WXML 示例 --&gt; &lt;view class="container"&gt; &lt;text class="title"&gt;{{title}}&lt;/text&gt; &lt;view wx:for="{{list}}" wx:for-item="item"&gt; &lt;text&gt;{{item.name}}&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; 逻辑层：在逻辑层，我们编写的 JavaScript 代码会被执行，生成页面的初始数据，处理用户的交互行为等。 // JavaScript 示例 Page({ data: { title: "示例标题", list: [ { name: "项目1" }, { name: "项目2" }, { name: "项目3" }, ], }, }); 这两个层次的代码是分开运行在不同的线程中，通过系统进行数据的传输和事件的通知。
二、性能优化策略 2.1 数据绑定 在小程序中，我们通常会使用数据绑定来更新视图。数据绑定的性能主要取决于两个因素：绑定的数据量和绑定的复杂性。为了提高性能，我们应尽量减少绑定的数据量，避免复杂的绑定表达式。
&lt;!-- 不推荐：使用复杂的绑定表达式 --&gt; &lt;text&gt;{{title.toUpperCase() + ' - ' + subTitle}}&lt;/text&gt; &lt;!-- 推荐：简化绑定表达式 --&gt; &lt;text&gt;{{formattedTitle}}&lt;/text&gt; // JavaScript 示例 Page({ data: { title: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30aeca9481be25710b8adcab3c7e20ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7cc69ba635f7211430f0a7d7e8e160e/" rel="bookmark">
			数据结构之《二叉树》(中)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数据结构之《二叉树》(上)中学习了树的相关概念，还了解的树中的二叉树的顺序结构和链式结构，在本篇中我们将重点学习二叉树中的堆的相关概念与性质，同时试着实现堆中的相关方法，一起加油吧！
1.实现顺序结构二叉树 在实现顺序结构的二叉树中通常把堆使用顺序结构的数组来存储，因此我们先要了解堆的概念与结构
1.1 堆的概念与结构 如果有一个关键码的集合 K = {k0 , k1 , k2 , ...，kn−1 } ，把它的所有元素按完全二叉树的顺序存储方式式存储，在⼀个⼀维数组中，并满足： Ki &lt;= K2∗i+1 （ Ki &gt;= K2∗i+1 且 Ki &lt;= K2∗i+2 ），i = 0、1、2... ，则称为小堆(或大堆)。将根结点最大的堆叫做最大堆或大根堆，根结点最小的堆叫做最小堆或小根堆。
以上的堆的概念简单来说就是堆是完全二叉树，在大堆中根结点为最大的元素，在此之后的每个孩子结点都要小于或者等于它的父结点；在小堆中根结点为最小的元素，在此之后的每个孩子结点都要大于或者等于的父结点
因此通过堆的概念的了解需要知道堆有以下的性质：
• 堆中某个结点的值总是不大于或不小于其父结点的值
• 堆总是一棵完全二叉树
例如以下图示就是大堆，并且将其结点的数据存储到数组当中
以下图示就是小堆，并且将其结点的数据存储到数组当中
1.2二叉树的性质 在了解的堆的相关概念和结构后，之后我们要来实现堆，因此在此之前还要再了解二叉树的相关性质
💡 二叉树性质
• 对于具有 n 个结点的完全二叉树，如果按照从上至下从左至右的数组顺序对所有结点从0 开始编号，则对于序号为 i 的结点有：
1. 若 i&gt;0 ，i 位置结点的双亲序号： ； i=0 ， i 为根结点编号，无双亲结点
2. 若 2i+1&lt;n ，左孩⼦序号： ， 2i+1&gt;=n 否则无左孩子
3. 若 2i+2&lt;n ，右孩⼦序号： ， 2i+2&gt;=n 否则无右孩子
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7cc69ba635f7211430f0a7d7e8e160e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29893dfa05ee52f57ff9fe80cfd5e76f/" rel="bookmark">
			Java 并发编程：Java 中的乐观锁与 CAS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是栗筝i，这篇文章是我的 “栗筝i 的 Java 技术栈” 专栏的第 025 篇文章，在 “栗筝i 的 Java 技术栈” 这个专栏中我会持续为大家更新 Java 技术相关全套技术栈内容。专栏的主要目标是已经有一定 Java 开发经验，并希望进一步完善自己对整个 Java 技术体系来充实自己的技术栈的同学。与此同时，本专栏的所有文章，也都会准备充足的代码示例和完善的知识点梳理，因此也十分适合零基础的小白和要准备工作面试的同学学习。当然，我也会在必要的时候进行相关技术深度的技术解读，相信即使是拥有多年 Java 开发经验的从业者和大佬们也会有所收获并找到乐趣。
–
在现代软件开发中，并发编程已成为必不可少的技术。随着多核处理器的普及，如何高效地管理多线程环境下的资源竞争，成为开发者需要面对的重要课题。传统的锁机制（如synchronized关键字和Lock接口）虽然能够解决并发问题，但也带来了性能瓶颈和死锁风险。
为了克服这些缺点，乐观锁和 CAS（Compare And Swap，比较并交换）作为一种无锁并发解决方案应运而生。乐观锁的核心思想是“假设并发冲突很少发生”，因此在进行操作时不立即加锁，而是通过检测冲突来确保数据的一致性。CAS 操作基于 CPU 的原子指令，能够在不使用锁的情况下实现变量的安全更新，从而提高系统的并发性能。
在本文中，我们将深入探讨 Java 并发编程中的乐观锁与 CAS。通过分析AtomicInteger的源码，我们将揭示CAS 操作的工作原理，并探讨其在多线程环境中的实际应用。此外，我们还将介绍 ABA 问题及其解决方案，以及 CAS 自旋操作中的一些优化策略。
文章目录 1、悲观锁与乐观锁1.1、乐观锁1.2、悲观锁 2、CAS 比较并交换2.1、CAS 介绍2.2、CAS 的基本原理2.3、CAS 在 Java 中的应用2.4、CAS 的 ABA 问题2.5、CAS 的自旋问题3、对 Java 中 CAS 的实现解读1、AtomicInteger 对 CAS 的实现2、Unsafe 类简介 1、悲观锁与乐观锁 悲观锁与乐观锁并不是特指某个锁（Java 中没有哪个 Lock 实现类就叫 PessimisticLock 或 OptimisticLock），而是在并发情况下的两种不同策略。
悲观锁与乐观锁是锁的一种宏观分类方式，代表了在并发情况下的两种不同策略。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29893dfa05ee52f57ff9fe80cfd5e76f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/83/">«</a>
	<span class="pagination__item pagination__item--current">84/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/85/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>