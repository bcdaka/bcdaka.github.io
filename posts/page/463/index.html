<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bad56c71e1b1f214e8306c8b6710fe0/" rel="bookmark">
			使用 Vite 和 Bun 构建前端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虽然 Vite 目前可以与 Bun 配合使用，但它尚未进行大量优化，也未调整以使用 Bun 的打包器、模块解析器或转译器。
Vite 可以与 Bun 完美兼容。从 Vite 的模板开始使用吧。
bun create vite my-app ✔ Select a framework: › React ✔ Select a variant: › TypeScript + SWC Scaffolding project in /path/to/my-app... 然后进入项目目录并安装依赖项。
cd my-app bun install 使用 bunx 命令行界面启动Vite CLI开发服务器。
--bun 标志告诉 Bun 使用 bun 而不是 node 来运行 Vite 的CLI；
bunx --bun vite 为了简化这个命令，请将 package.json 文件中的 "dev" 脚本更新为以下内容。
"scripts": { "dev": "vite", "dev": "bunx --bun vite"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bad56c71e1b1f214e8306c8b6710fe0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34537b5e9ea0533bc35e823785692b2f/" rel="bookmark">
			sql2012安装教程详细
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL Server 2012 下载和安装详细教程
1、软件下载
2、软件安装
3、软件验证
1、软件下载
（1）官网地址
https://www.microsoft.com/zh-cn/sql-server/sql-server-downloads
可以自行去下载
（2）网盘地址
链接：百度网盘 请输入提取码
提取码：tqoq
2、软件安装
##（1）双击SETUP应用程序，开始安装SQLServer2012
选择安装-第一个全新sql server安装
##（2）安装成功以后点击确定
##（3）选择第一个如下图所示
##（4）点击下一步(出错也点击)，然后安装程序支持规则
##（5）设置角色，选择设置角色第一个
##（6）功能选择，建议全选：由于SQL占用空间较大，本机修改了功能目录存储位置；
##（7）安装规则
##（8）默认实例，可以更改文件夹位置
##（9）磁盘要求
##（10）服务器设置，直接下一步
##（11）数据库引擎配置
1）混合模式
2）设置密码，可以自定义，当然越简单越好，这里设置123456
3）添加当前用户
4）如下图所致
##（12）Analysis Services配置，选择“添加当前用户”
点击下一步,
##（13）Reporting Services配置，默认不用改
##（14）分布式重播控制器，点击“添加当前用户”
##（15）控制器名称，自定义填写,然后下一步
##（16）错误报告,点击下一步
##（17）安装配置规则,点击下一步
##（18）开始安装
##（19）安装进度
##（20）安装完成，点击关闭
3、软件验证
打开软件，选择2中登录方式都可以，一种sql验证使用用户名为软件默认用户名sa
密码123456登录
也可以选择windows登录验证登录。
如果服务器名称为空，查找windows设置中关于找到设备名称名称复制填入即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e132555f01a8600489d36ba0894ddcba/" rel="bookmark">
			C&#43;&#43;利用开散列哈希表封装unordered_set,unordered_map
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++利用开散列哈希表封装unordered_set,unordered_map 一.前言1.开散列的哈希表完整代码 二.模板参数1.HashNode的改造2.封装unordered_set和unordered_map的第一步1.unordered_set2.unordered_map 3.HashTable 三.string的哈希函数的模板特化四.迭代器类1.operator++运算符重载1.动图演示+分析2.需要哈希表的地址,怎么办?1.解决双向依赖问题2.解决私有成员问题 2.const迭代器的问题3.迭代器类的定义4.迭代器类的完善1.解引用和== !=1.解引用2.== != 2.operator++3.迭代器类的完整代码 五.哈希表的修改1.begin和end2.insert3.find4.哈希表的完整代码 六.unordered_set的完整代码七.unordered_map的完整代码八.test.cpp 一.前言 1.之前我们已经实现了开散列的哈希表,今天我们来用它封装unordered_set,unordered_map
2.本文的封装比利用红黑树封装set和map更加复杂
建议大家先去看我的红黑树封装set和map再来看本文
因为有很多地方跟红黑树封装set和map时是同样的思路和方法,所以本文不会太去赘述一遍
1.开散列的哈希表完整代码 namespace hash_bucket { //HashFunc&lt;int&gt; template&lt;class K&gt; //整型的哈希函数 struct HashFunc { size_t operator()(const K&amp; key) { return (size_t)key; } }; //HashFunc&lt;string&gt; //string的哈希函数 template&lt;&gt; struct HashFunc&lt;string&gt; { size_t operator()(const string&amp; key) { // BKDR size_t hash = 0; for (auto e : key) { hash *= 131; hash += e; } return hash; } }; template&lt;class K, class V&gt; struct HashNode { HashNode* _next; pair&lt;K, V&gt; _kv; HashNode(const pair&lt;K, V&gt;&amp; kv) :_kv(kv) , _next(nullptr) {} }; template&lt;class K, class V, class Hash = HashFunc&lt;K&gt;&gt; class HashTable { typedef HashNode&lt;K, V&gt; Node; public: HashTable() { _tables.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e132555f01a8600489d36ba0894ddcba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9766b3ed6269adcacd00bde6675ea6ac/" rel="bookmark">
			详解main函数参数argc、argv及如何传参
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、main()函数参数
2、main函数如何传参
2.1 环境准备
2.2 通过 Powershell 窗口传参
2.3 通过vs界面传参
3、int main() 和 int main(int argc, char *argv[]) 特点
1、main()函数参数 在C语言中，main函数可以带参数。main函数的原型通常为以下两种形式之一：
1、int main(void) 2、int main(int argc, char *argv[]) 在我们实际写代码时，大都是使用第一种方式，不给main函数传递参数，即 int main()。而实际上main函数也可以接收参数，并有其固定的格式，即第二种形式。
可以发现main函数接收两个参数，分别是 argc 和 argv[]：
argc 表示命令行参数的个数（argument count），包括程序本身。即 argc 的值至少为 1。argv[] 是一个指向字符串数组的指针，其中每个元素是一个指向传递给程序的参数的指针（argument vector），这些字符串是命令行参数。 到这里先知道 main 函数参数的形式即可，它第一个参数为 int 类型的变量，第二个参数是一个char* 类型的指针数组，关于char* argv[ ] 和 （char*）argv[] 的区别在下面文章中有详细讲解。
深入理解c指针（六）-CSDN博客
2、main函数如何传参 2.1 环境准备 为了能详细讲解，从vs新建项目开始。
上述是一个简单的测试代码，在传参后用来打印参数的个数、程序名称、命令行参数。 ps：若不了解指针相关知识请看本人C语言专栏内容，有对指针的详细讲解。 在 Visual Studio 中，Debug 模式和 Release 模式是两种常用的配置选项，它们在编译和运行项目时有一些重要的区别：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9766b3ed6269adcacd00bde6675ea6ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1bfa2f0ad306044e74870ea3f10b022/" rel="bookmark">
			Mac电脑安装nvm(node包版本管理工具)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：通过Homebrew安装（推荐） 1. 安装 Homebrew： 如果您还没有安装Homebrew，首先需要安装它。打开终端（Terminal.app）并运行以下命令：（官网地址：https://brew.sh/zh-cn/） 1.官网提供的链接（没有vpn的话执行不成功） /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)" 2.国内下载地址 /bin/zsh -c "$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)" 按照步骤安装完成就可以了
2. 使用Homebrew安装 NVM： 安装完 Homebrew 后，接着使用以下命令来安装 NVM： 打开终端zsh，执行：
brew install nvm 执行完成就代表nvm已经安装了，但是还需要配置环境变量
3. 配置环境变量： Homebrew 在安装 NVM 时通常会自动处理环境变量的设置，但为了确保 NVM 可以在新的 shell 会话中正常使用，您可能需要手动添加 NVM 的初始化脚本到您的 shell 配置文件中。对于大多数现代 Mac 系统使用的 zsh，编辑或创建 ~/.zshrc 文件。
配置 NVM 的环境变量通常涉及以下步骤： 先使用Homebrew检查nvm的安装位置： brew list nvm 我这里显示
ys@bogon ~ % brew list nvm /opt/homebrew/Cellar/nvm/0.39.7/etc/bash_completion.d/nvm /opt/homebrew/Cellar/nvm/0.39.7/libexec/ (2 files) /opt/homebrew/Cellar/nvm/0.39.7/nvm-exec /opt/homebrew/Cellar/nvm/0.39.7/nvm.sh 打开或创建 shell 配置文件： 对于 macOS Mojave 及以后版本（使用 zsh 作为默认 shell）的用户，您需要编辑或创建 ~/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1bfa2f0ad306044e74870ea3f10b022/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e707ce2c8f1afa22fc05a649c440faf7/" rel="bookmark">
			谈谈我对 AIGC 趋势下软件工程重塑的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：陈鑫
今天给大家带来的话题是 AIGC 趋势下的软件工程重塑。今天这个话题主要分为以下四大部分。
第一部分是 AI 是否已经成为软件研发的必选项；第二部分是 AI 对于软件研发的挑战及智能化机会，第三部分是企业落地软件研发智能化的策略和路径，第四部分是我们现有的可采纳的、可落地的工具，在这一部分我也会重点介绍通义灵码整体的产品能力和概况。
AI 已经成为软件研发的必选项 这张图是麦肯锡最近发布的一个研究报告，大家可以看到他把软件工程列在了整张表格的右上角，也就是影响最大、影响速度最快的一部分。他为什么会有这样的观点？这是因为在大模型时代，我们发现大模型在代码生成和整体的逻辑推理方面是特别擅长的，所以涌现出了类似 Github Copilot 这种非常有代表性的智能编码工具，可以瞬间提升大量企业开发工程师的研发效率，而且 Copilot 是至今为止在世界范围内商业化最成功的大模型的领域之一。
这位美国的 KOL，他也有同样的观点。他认为在大模型时代，可能有大量的技能会被替代，我们 10% 的技能会被 1000 倍的提升，这个跟我们的观点是相似的，尤其是在大模型时代，大模型可以大量地替代开发者的日常事务性工作，这部分的占比很可能超过70%，让开发者得以聚焦于剩下 30% 的业务和技术的创新。
这张图给大家展示的是前一段时间 JetBrains 的一个调研报告，他们在 26500 名工程师之间做调研，想看一下今天有多少开发者已经开始熟练地使用生成式 AI 工具，这份调研也出乎很多人的意料，调研显示，现在 84% 的开发者已经在或多或少地使用生成式人工智能工具了。
其中有哪些场景是开发者最耗时，也是最想提效的场景？
他们在这里也做了一个调研，就如左图所示，首先是编码场景，然后是理解代码，接着是互联网搜索，也就是查询各种各样的研发问题，以及进行调试、编码注释、写测试、代码评审等等一系列的工作。
这张图大家可以看到，有哪些场景是 AI 助手辅助频率最高的？
有以下几个：第一个是使用自然语言去询问软件开发的一些问题，包括生成代码、生成代码注释、解释代码、生成测试等等。其实大家可以发现这一个调研的结果跟上一个其实是非常吻合的。也就是说在我们最高频的场景下，AIGC 其实能起到非常关键的作用。 这也是为什么代码智能生成工具已经逐步成为了每个企业必须采用的一项产品的原因。
这张图也是微软针对 Github Copilot 用户发放的一份调研问卷，了解他们使用类似 AIGC 的代码助手对整个的研发效率或者说研发体感有多少提升，可以看到有很多指标都是 80% 以上的，或者接近 80%。其实我们也针对通义灵码的使用者发放过类似的调研问卷。有超过 80% 的用户都感觉到使用工具以后生产力有了大幅的提升， 跟这个调研报告也非常吻合。
根据前面的调研报告和后面相关的调研数据，大家可以看到，在世界的开发者范围内，AI 已经成为了开发者的必选项，我们软件研发的未来一定是 AI 驱动的场景。
软件研发挑战及智能化的机会 在 2023 年 6 月，我们组织过一次大规模的专家研讨会，在这个研讨会上大家都在讨论智能化未来对软件研发或者软件工程领域的深刻影响。在这个会上，我们有位专家提出了一个观点，他认为软件工程是人类历史上第一次大规模的集体智力的协作活动，它本身是有本质的复杂性在的。例如《人月神话》的作者所讲的，他认为软件本质的复杂性是现在软件系统中无法规避的内在特性，比如复杂度、一致性、可变性和不可见性。
在过去的若干年，为什么软件效能或者说研发效率提升非常困难，就是因为这些维度没有得到非常好的解决。今天在大模型时代，通过 AI 逐步地去替代人类的事务性工作后，它可以起到非常大的改进作用。我们总结下来有以下四大方面。
第一，是对个体效率的提升。 例如我们可以采纳类似 AI 的智能代码助手，它可以大幅的代替研发人员的重复性工作、简单性工作。我们认为它是一种 Copilot 的模式，辅助各个角色去提升自己的工作效率。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e707ce2c8f1afa22fc05a649c440faf7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec7ab1547527789d6499d9820af23e0b/" rel="bookmark">
			Git——IDEA中的使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Git1、IDEA中配置Git2、将本地项目推送到远程仓库2.1、创建项目远程仓库2.2、初始化本地仓库2.3、连接远程仓库2.4、提交到本地仓库2.5、推送到远程仓库 3、克隆远程仓库到本地4、基本操作4.1、代码提交到暂存区4.2、暂存区代码提交到本地库4.3、推送到远程仓库4.4、撤销本地提交4.5、撤销远程推送1、方式一 Revert2、方式二 Reset 4.6、更新代码4.7、暂存修改 5、分支操作5.1、选择分支5.2、新建分支5.3、比较分支5.4、合并分支5.5、删除分支 6、解决代码冲突7、常用快捷键 Git 1、IDEA中配置Git 选择File→Settings打开设置窗口，找到Version Control下的Git选项,然后配置Git路径。如果Git安装在默认路径下，IDEA可以自动找到。选择路径后点击右侧Test，出现版本号提示即可【由于IDEA版本问题，提示的方式可能不一致】。
2、将本地项目推送到远程仓库 2.1、创建项目远程仓库 这个使用GitHub位例，创建仓库spring_boot_test。如下图所示：
2.2、初始化本地仓库 创建完远程仓库之后，还要通过 IDEA 开发工具来初始化一个本地仓库，相比于 Git Bash 这样的命令行来说，IDEA 非常方便可以进行可视化的 Git 管理。
如下图所示，在工具栏中的 VCS，鼠标光标移动到 Import Version Control -&gt; Create Git Repository，点击 Create Git Repository。
点击 Create Git Repository 之后，弹出一个小窗口，选择要初始化的本地项目。这里就以打开的项目 spring_boot_test 为例，对 spring_boot_test 进行 Git 本地初始化。
2.3、连接远程仓库 初始化本地仓库，并且创建完远程仓库项目之后，下一步就需要将本地和远程进行对接交互了。那么在交互之前，肯定是要进行建立连接的，就像打电话之前先呼号建立通话连接一样，之后再进行信息交换。
工具栏 VCS -&gt; Git -&gt; Remotes，点击 Remotes 添加远程仓库连接信息。
添加 Remote，输入 Name 和 URL，这里的 Name 如果没有特殊设置就是按照默认的 origin 来，也是 IDEA 自动补全的，建议在创建远程项目的时候不要轻易修改，这里的 URL 就是在远程项目信息中可以看到，我就不放出来了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec7ab1547527789d6499d9820af23e0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e25187ec19de3cd83dbd7c481df1055/" rel="bookmark">
			从初学者到专家：Java的Lambda表达式完整指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.Lambda的概念 概念：Lambda表达式是Java 8引入的一项重要功能，它允许我们以更简洁和灵活的方式编写代码。可以把Lambda表达式看作是一种更方便的匿名函数，可以像数据一样传递和使用。
使用Lambda表达式可以让我们写出更短、更易读的代码。它可以替代传统的匿名类，使代码更加简洁。Lambda表达式还支持函数式编程，这意味着我们可以将函数作为参数传递给其他方法，使得代码更加灵活和可扩展。
1.1 Lambda表达式的语法 基本语法: (parameters) -&gt; expression 或 (parameters) -&gt;{ statements; } Lambda表达式由三部分组成： paramaters：类似方法中的形参列表，这里的参数是函数式接口里的参数。这里的参数类型可以明确的声明也可不声明而由JVM隐含的推断。另外当只有一个推断类型时可以省略掉圆括号。 -&gt;：可理解为“被用于”的意思 方法体：可以是表达式也可以代码块，是函数式接口里方法的实现。代码块可返回一个值或者什么都不反回，这里的代码块块等同于方法的方法体。如果是表达式，也可以返回一个值或者什么都不反回。 根据上面的语法，理解下面的代码：
对于只有单个表达式的Lambda表达式： import java.util.Arrays; import java.util.List; public class LambdaExample { public static void main(String[] args) { List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); // Lambda表达式作为参数传递给forEach方法 numbers.forEach(number -&gt; System.out.print(number+" ")); } } 运行截图如下：
这个示例首先创建了一个整数列表 numbers。然后，通过调用 forEach 方法并传递一个 Lambda 表达式作为参数，对列表中的每个元素执行操作。
2.对于包含多个语句的Lambda表达式：
import java.util.Arrays; import java.util.List; public class LambdaExample { public static void main(String[] args) { List&lt;Integer&gt; numbers = Arrays.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e25187ec19de3cd83dbd7c481df1055/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c25ff58cea0ebe41e00a8c726a6e4191/" rel="bookmark">
			算法详解——图的深度优先遍历和广度优先遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、图结构二、深度优先遍历2.1 图的遍历2.2 深度优先遍历过程2.3 深度优先遍历核心思想2.4 深度优先遍历实现 三、广度优先遍历3.1 广度优先遍历过程3.2 广度优先遍历核心思想3.3 广度优先遍历实现 参考文献 一、图结构 图结构指的是如下图所示的由节点和边组成的数据。
二、深度优先遍历 2.1 图的遍历 图的遍历任务指的是从图中某个节点开始，遍历得到图中所有节点的过程。
2.2 深度优先遍历过程 假设我们从1号节点开始进行深度优先遍历。遍历的步骤如下：首先，我们选择1号顶点作为起始点。从1号顶点开始，我们尝试沿着边访问尚未到达过的顶点。我们发现2号顶点是未到达过的，所以我们移动到2号顶点。现在，以2号顶点为起点，我们继续尝试访问其他未到达过的顶点。这样，我们又到达了4号顶点。接着，以4号顶点为起点，我们尝试访问其他未到达过的顶点。然而，此时我们无法再通过4号顶点的边访问其他未到达过的顶点，所以我们需要回到2号顶点。回到2号顶点后，我们发现沿着2号顶点的边也无法再访问其他未到达过的顶点。因此，我们需要继续回到1号顶点。现在，我们继续检查1号顶点的边，看看是否还有其他未到达过的顶点。这时我们到达了3号顶点，然后以3号顶点为起点继续访问其他未到达过的顶点，最后到达了5号顶点。此时，所有顶点都已经被访问过，遍历结束。遍历的顺序如下图所示：
2.3 深度优先遍历核心思想 深度优先遍历的核心思想在于：首先选择一个未被访问过的顶点作为起始点，然后沿着当前顶点的边前进到未被访问过的顶点。当当前顶点没有未访问过的邻居顶点时，则回溯到上一个顶点，继续试探访问其他顶点，直到所有的顶点都被访问过为止。显然，深度优先遍历是沿着图的某一条分支遍历直到末端，然后回溯，再沿着另一条分支进行同样的遍历，直到所有的顶点都被访问过为止。
2.4 深度优先遍历实现 如何将这一过程用代码实现呢？在讨论代码实现之前，我们需要先解决如何存储一个图的问题。最常用的方法是使用一个二维数组 e e e 来表示，具体如下所示：
上图中的二维数组中，第 i i i行第 j j j列表示从顶点 i i i到顶点 j j j是否存在一条边。其中， 1 1 1表示存在边， ∞ ∞ ∞表示不存在边。我们将自己到自己的路径（即 i i i等于 j j j）设为 0 0 0。这种图的存储方式被称为邻接矩阵存储法。
注意观察的同学会发现，这个二维数组沿主对角线对称。这是因为上述图是无向图。无向图指的是图的边没有方向性，例如边1-5表示，1号顶点可以到达5号顶点，同时5号顶点也可以到达1号顶点。
接下来，我们将解决如何使用深度优先搜索来实现图的遍历。
// C 代码 #include &lt;stdio.h&gt; int book[101], sum, n, e[101][101]; void dfs(int cur) // cur 是当前所在的顶点编号 { int i; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c25ff58cea0ebe41e00a8c726a6e4191/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87300dc55e66f48267acd2d2a8eee9af/" rel="bookmark">
			蓝桥杯练习题总结（二）dfs题、飞机降落、全球变暖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、飞机降落
二、全球变暖
初始化和输入
确定岛屿
DFS搜索判断岛屿是否会被淹没
计算被淹没的岛屿数量
三、军训排队 一、飞机降落 问题描述：
N架飞机准备降落到某个只有一条跑道的机场。其中第 i 架飞机在 时刻到达机场上空，到达时它的剩余油料还可以继续盘旋 个单位时间，即它最早可以于 1, 时刻开始降落，最晚可以于时刻开始降落。降落过程需要个单位时间。
输入格式：
输入包含多组数据。
第一行包含一个整数N，代表测试数据的组数。
对于每组数据：
第一行包含一个整数T，代表测试数据的组数。
对于每组数据，第一行包含一个整数 N。
接下来的N行，每行包含三个整数。
输出格式：
对于每组数据，输出YES或者NO，代表是否可以全部安全降落。
输入样例：
2 3 0 100 10 10 10 10 0 2 20 3 0 10 20 10 10 20 20 10 20 输出样例：
YES NO 思路：
首先读取飞机的数量N，然后读取每架飞机的到达时间t、盘旋时间d和降落时间l。使用深度优先搜索（DFS）尝试所有可能的降落顺序。DFS的过程中，我们需要一个bool数组来记录每架飞机的降落状态（例如，是否已经降落）。 bool st[N];// 判断当前飞机是否已经降落 循环遍历如果当前尝试的飞机不能在剩余油料允许的时间内降落，或者尝试完所有飞机后没有找到合法的降落顺序，则回溯到上一个状态，尝试另一种降落顺序。对于每一架尝试降落的飞机，检查它是否能够在剩余油料允许的时间内开始降落，即降落的开始时间应该在到达时间加盘旋时间的范围内（ 上一次降落时间 + ）。 if (p[i].t + p[i].d &lt; time) // 如果当前时间超过了飞机的最晚降落时间 { //回溯，回溯到DFS之前的状态。 st[i] = false; return false; } int t = max(time, p[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87300dc55e66f48267acd2d2a8eee9af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d02df67497ed135b3394f0aecaec6e4/" rel="bookmark">
			ubuntu20.04 安装 Qt 后无法启动，出现报错：Could not load the Qt platform plugin “xcb” even though it was found！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、Qt在Ubuntu上的安装
1.下载Qt在线安装程序
2.Qt在线安装
二、Qt creator无法显示问题解决
1.问题所在
2.问题解决
总结
前言 本篇博文是记录了作者在ubuntu20.04版本中安装Qt时遇到的问题以及解决方案。其中包括了Qt在ubuntu系统中的安装以及解决安装后无法启动Qt以及出现报错(qt.qpa.plugin: Could not load the Qt platform plugin "xcb" even though it was found.) 的问题。
一、Qt在Ubuntu上的安装 安装教程是参考这位博主的博文：Linux 系统 (Ubuntu)下安装 Qt 环境
1.下载Qt在线安装程序 (1) 在线安装程序可以在Qt官网的开源下载页面，但是会出现很长时间加载不出来下载页面，因此可以选择去国内的Qt镜像站去下载：Qt在线下载程序镜像站
这里选择的是 4.5 / qt-unified-linux-x64-4.5.2-online.run
(2) 找到下载的文件路径(/home/xxy/Downloads/qt-unified-linux-x64-4.5.2-online.run)(默认下载路径)，并在终端打开，执行以下两个命令(由于考虑到下载速度的原因，第二个命令指定了国内的镜像源)
1 chmod +x qt-unified-linux-x64-4.5.2-online.run 2 ./qt-unified-linux-x64-4.5.2-online.run --mirror http://mirrors.ustc.edu.cn/qtproject 2.Qt在线安装 (1) 命令执行完之后就会打开qt安装程序（此处需要注意的是要提前注册一个Qt的账号）
(2) 此处两个都选上
(3) 勾选 Disable sending pseudonymous usage statistics in Qt Creator
(4) 勾选默认值 Custom installation
(5) 勾选需要下载的组件(关键步骤)，这里我选择的是Qt 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d02df67497ed135b3394f0aecaec6e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f536f2325e32611bd33a540b9f907995/" rel="bookmark">
			9个免费的AI辅助编程工具，智能自动编写和生成代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		9个免费的AI编程工具，智能自动编写和生成代码 | AI工具集
在AIGC技术和工具井喷爆发的时代，对高效智能编程工具的需求和关注也达到前所未有的高度。本篇文章将介绍9款免费好用的AI编程助手工具，无论你是经验丰富的开发人员或刚开始踏上编程旅途，这些AI代码软件都可以帮助你提高项目开发中的生产力、创造力和准确性，快速高效地进行编程开发。
GitHub Copilot 通义灵码 CodeWhisperer CodeGeeX Cody CodeFuse Codeium CodiumAl AskCodi GitHub Copilot 这里试用阿里的通义灵码-个人免费版本：
通义灵码
通义灵码是阿里巴巴团队推出的一款基于通义大模型的智能编程辅助工具，提供行级/函数级实时续写、自然语言生成代码、单元测试生成、代码注释生成、代码解释、研发智能问答、异常报错排查等能力，并针对阿里云 SDK/API的使用场景调优，为开发者带来高效、流畅的编码体验。
支持的编程语言
通义灵码支持 Java、Python、Go、C/C++、JavaScript、TypeScript、PHP、Ruby、Rust、Scala 等主流编程语言。
兼容的编辑器和IDE
通义灵码兼容 Visual Studio Code、JetBrains IDEs 等主流编辑器和 IDE.
譬 产品价格
通义灵码目前是完全免费的，用户只需前往IDE下载对应的插件即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30785d778a9b08ec58d555c326fb2adc/" rel="bookmark">
			mysql迁移达梦数据库 Java踩坑合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		达梦数据库踩坑合集
文章目录 安装达梦设置大小写不敏感Spring boot引入达梦驱动（两种方式）将jar包打入本地maven仓库使用国内maven仓库（阿里云镜像） 达梦驱动yml配置springboot + mybatis-plus整合达梦,如何避免指定数据库名，设置指定库的指定数据库错误信息解决方案 达梦 + mybatis timestamp、datetime 和 MySQL中的datetime数据类型的映射问题背景解决方案 达梦TEXT数据类型在Java中不能映射为String类型错误信息解决方案 达梦数据库将TEXT类型的字段更改为VARCHAR失败错误信息解决方案 达梦数据库查询数据 No serializer found for class dm.jdbc.a.a.a and no properties discovered to create BeanSerializer错误原因解决方式 Error flushing statements. Cause: dm.jdbc.driver.DMException: 当前连接为只读状态参考博客 安装达梦设置大小写不敏感 达梦的大小写敏感设置，只能在安装的时候设置好，安装完成之后不可更改。我是用的是docker安装。在环境变量里设置"-e CASE_SENSITIVE=0",命令如下：
docker run -tid -p 5236:5236 --restart=always --name dm8 --privileged=true -e PAGE_SIZE=16 -e LD_LIBRARY_PATH=/opt/dmdbms/bin -e INSTANCE_NAME=dm8 -e CASE_SENSITIVE=0 -v /dm8_docker/data:/opt/dmdbms/data dm8_single:dm8_20230808_rev197096_x86_rh6_64 如果已经安装了，并且是大小写敏感的。需要将容器停止，然后删除容器，并将挂载目录（这里是 /dm8_docker/data）下的文件一起删掉。再重新执行以上命令。
# 进入容器: docker exec -it 7ccc57b47de3 /bin/bash # 进入数据库: /opt/dmdbms/bin/disql # 输入超级管理员账号和密码 # 达梦默认的账号密码是: # username：SYSDBA # password: SYSDBA001 附上官网截图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30785d778a9b08ec58d555c326fb2adc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90553b7c54bfae5f899825edc93ec3b8/" rel="bookmark">
			【最新|送API Key】零基础调用Anthropic Claude 3 API接口（Python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024 年 Anthropic 发布了 Claude3，据官方测试比 GPT-4 更好，一夜之间爆火，引得不少开发者体验，本文参考Claude 3官方API，梳理了从零开始调用ClaudeAPI的操作方法。
Claude 是Anthropic 的LLM 应用程序（类似于 ChatGPT）。该库允许使用 API（免费）并在Python 项目中与之交互。
一、必要条件 你需要有Claude 的API Key你需要有访问Claude 的网络条件 本文的 API Key 已做删减处理，无法直接调用，会在文末附上完整的API Key，更多 Claude API Key，可访问链接获取
二、操作步骤 1. 安装Anthropic 库 此处以Pycharm为例，点击命令行，输入 pip install anthropic
如安装不畅，可考虑使用其他 pip 镜像。
2. 运行 Hello Word 安装完成后，即可初体验 Claude 3模型，请输入以下代码：
import anthropic client = anthropic.Anthropic( # defaults to os.environ.get("ANTHROPIC_API_KEY") api_key="sk-ant-api03-mrmRzF-1x397AtlRNiur-PEQ7TlpAf3HxY4YQXeyvfB1p642QIAiMYN4Qwv98mKPCJOhA-ZvoYKgAA", ) message = client.messages.create( model="claude-3-opus-20240229", max_tokens=1024, messages=[ {"role": "user", "content": "Hello, Claude"} ] ) print(message.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90553b7c54bfae5f899825edc93ec3b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1df1b0cade6529a354f50c4759f513f9/" rel="bookmark">
			关于Android Studio连接mysql数据库的过程和注册功能的实现（数据的插入）以及mysql环境变量的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装mysql数据库，安装的教程哔站有很多，版本尽量用mysql5.7的版本，用mysql8.0的版本与android studio进行连接的话可能会出现问题。 2.安装完成之后，给本机配置环境变量，步骤：如下图示 （1）通过搜索打开环境变量。
（2）.点击环境变量。
（3）.找到系统变量点击新建。
(4).点击新建之后输入如下内容，切记变量值是你的mysql安装路径。
(5).找到path路径点击进入。
(6).新建一个关于mysql的环境变量,配置完后全部确定。
(7).进行验证mysql数据库是否安装成功。按住电脑win+R输入cmd命令进入终端
输入 mysql -uroot -p 命令，然后需要让你输入你在安装mysql是设置的密码，点击回车，
如果显示如下图这样，说明数据库安装完成，配置成功。
3.下载JDBC驱动包在mysql官网下载进行，版本同样不要太高，用5.14版本的jdbc驱动可以满足mysql5.7的版本。下载完城之后解压，找到如下图文件并进行复制。 4.将复制的文件粘贴到android studio中的libs夹文件中，点击粘贴好的文件右击显示第二张图的样子，再点击Add as Library...等待加载完成之后，出现第三张图则表示你导入成功。 5.在android studio项目里创建一个JDBCUtil类，UserDaol类，MainActivity类以及布局文件activity_main.xml。（注意：数据库连接好之后需要创建一个新的用户并且授予所有权，同时还要新建一个数据库dictionary以及在此数据库下新建一个用户表user才可以使用以下代码，否则可能会出现问题。） JDBCUtil类：
( private static final String URL = "jdbc:mysql://XXX.XXX.XXX.XXX:3306/dictionary?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false";)
此语句中的XXX.XXX.XXX.XXX代表电脑本机的ip地址，3306为端口号（一般都是这个），dictionary为mysql数据库库里面新建的一个名叫dictionary的数据库。
（private static final String USER = "XXX";）此语句中的XXX代表使用数据库的用户名。
（private static final String PWD = "XXXX";）此语句中的XXXX代表用户连接数据库的密码。
import android.util.Log; import java.sql.Connection; import java.sql.DriverManager; public class JDBCUtil { private static final String CLS = "com.mysql.jdbc.Driver"; private static final String URL = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1df1b0cade6529a354f50c4759f513f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70ee6a800c45a050687b68fa53bb48ff/" rel="bookmark">
			【深度学习】最强算法之：深度神经网络（DNN）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度神经网络 1、引言2、深度神经网络2.1 定义2.2 原理2.3 实现方式2.4 算法公式2.4.1 前向传播公式2.4.2 反向传播公式 2.5 代码示例 3、总结 1、引言 小屌丝：鱼哥，我遇到难题了
小鱼：然后呢
小屌丝：你帮我看看呗？
小鱼：怎么看？
小屌丝：… 用眼睛看。
小鱼：这… 那咱就看看
小屌丝：… 你这是看啥，没让你看视力表
小鱼：我得先看看视力表， 以便我好选择用什么工具帮你看这个难题
小屌丝：我… 你随意
小鱼：你可不能干了， 不然，待会泡完澡谁结账啊。
小屌丝： 我…你…
小鱼：好了，我知道什么难题了，这就开整。
小屌丝：牛啊，牛啊，牛
小鱼：大河弯弯向东流，还是这么牛。
2、深度神经网络 2.1 定义 深度神经网络（DNN）是一种由多个神经元层组成的人工神经网络模型。与传统的浅层神经网络相比，DNN具有更多的隐藏层，从而能够处理更复杂和抽象的特征。DNN通过学习输入数据的表示，逐层提取特征，最终实现对数据的分类、回归等任务。 2.2 原理 DNN的核心原理在于通过多层神经元进行特征学习和抽象表示。
- 在DNN中，每个神经元都接收前一层所有神经元的输出，根据权重和激活函数对输入进行计算，并将结果传递给下一层神经元。
- 通过堆叠多个这样的层，DNN能够逐步提取输入数据中的高层次特征，从而实现对复杂数据的高效学习和处理。
DNN的训练过程通常使用反向传播算法。
在训练过程中，DNN根据输入数据和期望输出之间的误差来调整网络参数，以使误差最小化。通过不断地优化网络参数，DNN能够逐渐提高模型的性能和泛化能力。 2.3 实现方式 DNN的实现方式主要依赖于深度学习框架，如TensorFlow、PyTorch等。这些框架提供了丰富的神经网络层和操作，使得构建和训练DNN变得相对简单。
在实现DNN时，
首先需要定义网络结构，包括输入层、隐藏层和输出层的神经元数量以及激活函数等。其次，使用框架提供的API构建网络模型，并初始化网络参数。然后，准备训练数据集，并将数据输入到网络中进行训练。 在训练过程中，通过反向传播算法更新网络参数，直至模型收敛。
2.4 算法公式 DNN的算法公式主要包括前向传播和反向传播两部分。
前向传播公式反向传播公式 2.4.1 前向传播公式 前向传播公式：
输入层到隐藏层的传播： ( z ( l ) = W ( l ) a ( l − 1 ) + b ( l ) ) (z^{(l)} = W^{(l)}a^{(l-1)} + b^{(l)}) (z(l)=W(l)a(l−1)+b(l))隐藏层到输出层的传播： ( a ( l ) = σ ( z ( l ) ) ) (a^{(l)} = \sigma(z^{(l)})) (a(l)=σ(z(l))) 其中， ( l ) (l) (l) 表示层数， ( W ( l ) ) (W^{(l)}) (W(l)) 和 ( b ( l ) ) (b^{(l)}) (b(l)) 分别表示第 ( l ) (l) (l) 层的权重和偏置， ( σ ) (\sigma) (σ) 表示激活函数， ( a ( l − 1 ) ) (a^{(l-1)}) (a(l−1)) 表示前一层的输出， ( z ( l ) ) (z^{(l)}) (z(l)) 表示当前层的线性输出， ( a ( l ) ) (a^{(l)}) (a(l)) 表示当前层的激活输出。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70ee6a800c45a050687b68fa53bb48ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2de750f99b54f5bda055248f24c5c9b/" rel="bookmark">
			【机器学习】决策树（理论）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		决策树（理论） 目录 一、何为决策树1、决策树的组成2、决策树的构建 二、熵1、熵的作用2、熵的定义3、熵的计算4、条件熵的引入5、条件熵的计算 三、划分选择1、信息增益（ ID3 算法选用的评估标准）2、信息增益率（ C4.5 算法选用的评估标准）3、基尼系数（ CART 算法选用的评估标准）4、基尼增益5、基尼增益率 四、决策树中的连续值处理五、决策树中的预剪枝处理（正则化）1、限制决策树的深度2、限制决策树中叶子结点的个数3、限制决策树中叶子结点包含的样本个数4、限制决策树的最低信息增益 六、决策树中的后剪枝处理七、实战部分 一、何为决策树 决策树（Decision Tree）是一种分类和回归方法，是基于各种情况发生的所需条件构成决策树，以实现期望最大化的一种图解法。由于这种决策分支画成图形很像一棵树的枝干，故称决策树。它的运行机制非常通俗易懂，因此被誉为机器学习中，最“友好”的算法。下面通过一个简单的例子来阐述它的执行流程。假设根据大量数据（含 3 个指标：天气、温度、风速）构建了一棵“可预测学校会不会举办运动会”的决策树（如下图所示）。
接下来，当我们拿到某个数据时，就能做出对应预测。
在对任意数据进行预测时，都需要从决策树的根结点开始，一步步走到叶子结点（执行决策的过程）。如，对下表中的第一条数据（ [ 阴天，寒冷，强 ] ）：首先从根结点出发，判断 “天气” 取值，而该数据的 “天气” 属性取值为 “阴天”，从决策树可知，此时可直接输出决策结果为 “举行”。这时，无论其他属性取值为什么，都不需要再执行任何决策（类似于 “短路” 现象）。
1、决策树的组成 决策树由结点和有向边组成。结点有两种类型：内部结点（圆）和叶结点（矩形）。其中，内部结点表示一个特征（属性）；叶结点表示一个类别。而有向边则对应其所属内部结点的可选项（属性的取值范围）。
在用决策树进行分类时，首先从根结点出发，对实例在该结点的对应属性进行测试，接着会根据测试结果，将实例分配到其子结点；然后，在子结点继续执行这一流程，如此递归地对实例进行测试并分配，直至到达叶结点；最终，该实例将被分类到叶结点所指示的结果中。
在决策树中，若把每个内部结点视为一个条件，每对结点之间的有向边视为一个选项，则从根结点到叶结点的每一条路径都可以看做是一个规则，而叶结点则对应着在指定规则下的结论。这样的规则具有互斥性和完备性，从根结点到叶结点的每一条路径代表了一类实例，并且这个实例只能在这条路径上。从这个角度来看，决策树相当于是一个 if-then 的规则集合，因此它具
有非常好的可解释性（白盒模型），这也是为什么说它是机器学习算法中最“友好”的一个原因。
2、决策树的构建 前面介绍了决策树的相关概念，接下来讨论如何构建一棵决策树。
决策树的本质是从训练集中归纳出一套分类规则，使其尽量符合以下要求：
具有较好的泛化能力；在 1 的基础上尽量不出现过拟合现象。 注意到一件事：当目标数据的特征较多时，构建的具有不同规则的决策树也相当庞大（成长复杂度为 𝑂(𝑛!) ）。如当仅考虑 5 个特征时，就能构建出 5×4×3×2×1=120 种。在这么多树中，选择哪一棵才能达到最好的分类效果呢？实际上，这个问题的本质是：应该将样本数据的特征按照怎样的顺序添加到一颗决策树的各级结点中？这便是构建决策树所需要关注的问题核心。
如，在前面的例子中，为什么要先对“天气”进行划分，然后再是“温度”和“风速”呢（下图1）？可不可以先对“风速”进行划分，然后再是“温度”和“天气”呢（下图2）？
一种很直观的思路是：如果按照某个特征对数据进行划分时，它能最大程度地将原本混乱的结果尽可能划分为几个有序的大类，则就应该先以这个特征为决策树中的根结点。接着，不断重复这一过程，直到整棵决策树被构建完成为止。
基于此，引入信息论中的“熵”。
二、熵 1、熵的作用 熵（Entropy)是表示随机变量不确定性的度量。说简单点就是物体内部的混乱程度。比如下边的两幅图中，从 图1 到 图2 表示了熵增的过程。对于决策树的某个结点而言，它在对样本数据进行分类后，我们当然希望分类后的结果能使得整个样本集在各自的类别中尽可能有序，即希望某个特征在被用于分类后，能最大程度地降低样本数据的熵。
现在假设有这样一个待分类数据（如下图所示），若分类器 1 选择特征 𝑥1、分类器 2 选择特征 𝑥2 分别为根构建了一棵决策树，其效果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2de750f99b54f5bda055248f24c5c9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1583b6853374580d9fee85b609133a7/" rel="bookmark">
			Python 常用内置函数详解（二）：print()函数----打印输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、功能二、语法和示例2.1 语法详解2.2 示例2.2.1 输出字符串2.2.2 输出数值2.2.3 输出变量2.2.4 输出彩色文字或背景2.2.5 输出内容到文件2.2.6 特殊文字、符号、标志输出2.2.7 将多次输出内容到一行2.2.8 进制输出2.2.9 动态刷新控制台输出 一、功能 print() 函数是 Python 编程最常见的函数，常用于输出程序结果，默认输出到屏幕，也可以输出到指定文件中。
二、语法和示例 2.1 语法详解 语法格式：
print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False) 参数说明：
value：表示要输出的值，可以是数字、字符串、各种类型的变量等。…：值列表，表示可以一次性打印多个值，输出多个值时，需要使用 "," (英文半角的逗号) 分隔，打印出来各个值之间默认用空格隔开。sep：表示打印值时，各个值之间的间隔符，默认值是一个空格，可以设置为其他的分隔符。end：表示打印完最后一个值需要添加的字符串，用来设定输出语句以什么结尾，默认是换行符 "\n"，即打印完会跳到新行，可以换成其他字符串，如 end='\t' 或 end='' 等，以实现不换行输出。sep 和 end 的参数必须是字符串，或者为 None，为 None 时意味着使用其默认值。file：表示输出的目标对象，可以是文件也可以是数据流，默认是 sys.stdout。可以设置 file=文件储存对象，把内容存到该文件中。flush：表示是否立刻将输出语句输出到目标对象，flush 值为 False 或者 True，默认 flush=False 表示输出值会保存在缓存中。当 flush=True 时，输出值强制写入文件。sep、end、file、flush 都必须以命名参数方式传参，否则会被当作需要输出的对象。如果 print() 函数不传递任何参数，将会输出 end 参数的默认值，即打印一个空行。 2.2 示例 2.2.1 输出字符串 字符串可以直接输出，也可以和数字、运算符等组成表达式进行输出。示例代码如下：
print() # 输出一个空行 print('') # 输出一个空行 print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1583b6853374580d9fee85b609133a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3b185337d5350104c26f3dbe83fe19a/" rel="bookmark">
			【机器学习】一文搞懂算法模型之：LSTM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法模型之LSTM 1、引言2、LSTM2.1 定义2.2 原理2.3 算法公式2.4 基本流程2.5 代码示例 3、总结 1、引言 小屌丝：鱼哥， 你说什么是LSTM
小鱼：LSTM… LSTM …
小屌丝：鱼哥， LSTM是啥？
小鱼：LSTM是… 不好意思说啊
小屌丝：这,有啥不好意思说的？
小鱼：你自己用输入法敲一下不就知道了。
小屌丝：…
小鱼：是啥啊， 让我看看？
小鱼：咋了，还不让我看，一定是…
小屌丝： 乱了乱了， 不是这样的。
小鱼：你看着你屏幕敲出的，还不承认
小屌丝：… 乱了乱了， 我说的LSTM算法模型，
小鱼：… 哦，这个啊，你都知道是算法模型，还问我啥？
小屌丝：这不是触碰到我的知识盲区了嘛，所以特来请教。
小鱼： 最后两个字是重点，待会可以考试哦
小屌丝：给我讲的明明白白的，我就告诉你刚刚输入法输出的是啥。
小鱼：嘿嘿~~
2、LSTM 2.1 定义 长短期记忆网络（Long Short-Term Memory，简称LSTM）是一种特殊的循环神经网络（RNN），旨在解决传统RNN在处理长序列时出现的梯度消失和爆炸问题。
LSTM通过引入门控机制，有效地捕获序列中的长期依赖关系，因此在自然语言处理、语音识别、时间序列预测等领域有着广泛的应用。
2.2 原理 LSTM的核心思想是通过三个门（输入门、遗忘门和输出门）来控制信息的流动。这些门通过sigmoid函数将输入映射到0到1之间的值，从而决定信息的保留或丢弃。
输入门：决定当前时刻的输入和上一时刻的隐状态中有哪些信息需要保留下来。遗忘门：决定上一时刻的细胞状态中哪些信息需要被遗忘。输出门：基于当前的细胞状态来决定输出什么值。 LSTM的单元内部还包括一个细胞状态（cell state），用于保存长期记忆。通过这三个门和细胞状态的共同作用，LSTM能够在处理长序列时保持稳定的性能。
2.3 算法公式 LSTM的算法公式如下：
遗忘门： ( f t = σ ( W f ⋅ [ h t − 1 , x t ] + b f ) ) (f_t = \sigma(W_f \cdot [h_{t-1}, x_t] + b_f)) (ft​=σ(Wf​⋅[ht−1​,xt​]+bf​))输入门： ( i t = σ ( W i ⋅ [ h t − 1 , x t ] + b i ) ) (i_t = \sigma(W_i \cdot [h_{t-1}, x_t] + b_i)) (it​=σ(Wi​⋅[ht−1​,xt​]+bi​))细胞状态更新： ( C ~ t = tanh ⁡ ( W C ⋅ [ h t − 1 , x t ] + b C ) ) (\tilde{C}t = \tanh(W_C \cdot [h{t-1}, x_t] + b_C)) (C~t=tanh(WC​⋅[ht−1,xt​]+bC​))细胞状态： ( C t = f t ∗ C t − 1 + i t ∗ C ~ t ) (C_t = f_t * C_{t-1} + i_t * \tilde{C}_t) (Ct​=ft​∗Ct−1​+it​∗C~t​)输出门： ( o t = σ ( W o ⋅ [ h t − 1 , x t ] + b o ) ) (o_t = \sigma(W_o \cdot [h_{t-1}, x_t] + b_o)) (ot​=σ(Wo​⋅[ht−1​,xt​]+bo​))隐状态： ( h t = o t ∗ tanh ⁡ ( C t ) ) (h_t = o_t * \tanh(C_t)) (ht​=ot​∗tanh(Ct​)) 其中，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3b185337d5350104c26f3dbe83fe19a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48486dd5b83e57588df486df8725d8f7/" rel="bookmark">
			人工智能搜索引擎 Perplexity AI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Perplexity AI是一款革命性的人工智能搜索引擎，结合传统搜索索引与大型语言模型，提供了不一样的搜索体验，免费可不注册即可使用，已是日常必备常用工具，推荐你尝试。
官方网址：https://www.perplexity.ai
快速使用 打开官网，人机交互验证后，便可使用，小白都会 perplexity 菜单栏 搜索区 语言切换 举个栗子：写一段 100字的 perplexity 简介，要求有趣味且吸引人使用
可以看出，是利用大模型写出的结果，有点啰嗦，重新提问：提炼到50字，看到此介绍有欲望点击，这次给出了提炼结果，并且还附带了 Sources 来源。
perplexity 如果你认为不是你想要的结果，还可以继续提供反馈，优化结果。这里已经接近我想要的结果，不再演示，此外又尝试搜索了技术相关问题，Sources 直接引用了官网文档来源，个人感觉相当不错，值得尝试使用。
Perplexity 的特点：
能够通过与用户对话来理解用户的需求，避免提供无关信息。 提供答案的同时，还会总结最佳的发现，避免用户阅读大量文本。 关注公众号 本文由 mdnice 多平台发布
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/462/">«</a>
	<span class="pagination__item pagination__item--current">463/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/464/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>