<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c4b20e7a10d65cc80bf1ffe59974083/" rel="bookmark">
			【Python】—— 文本分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌟欢迎来到 我的博客 —— 探索技术的无限可能！
🌟博客的简介（文章目录）
文本分析 相关知识1. 文本数据处理2. 文本可视化3. Python编程4. 词频统计5. 人名提取6. 自然段划分7. 人物出现频率分布分析8. 词云生成 实验内容数据下载地址1.对纯英文小说进行分析。2.对中文小说进行分析。 问题与解决附录1.对纯英文小说进行分析。2.对中文小说进行分析。 相关知识 当涉及到文本数据处理和可视化的任务时，我们可以通过了解下面的知识和使用Python的一些主要库和工具来完成这些任务。
1. 文本数据处理 包括读取文本文件、对文本进行分词、去除停用词等基本文本处理步骤。
读取文本文件：在Python中，我们使用open函数打开文件，指定文件名、打开模式（这里是’r’表示读取）、以及字符编码（通常是’utf-8’）。 with open('filename.txt', 'r', encoding='utf-8') as file: text_data = file.read() 分词和去除停用词：使用Natural Language Toolkit（NLTK）库进行分词和去除停用词。分词是将文本拆分成单词的过程，而停用词是指那些在文本中频繁出现但没有实际含义的词汇，可以通过NLTK提供的停用词列表进行去除。 from nltk.corpus import stopwords from nltk.tokenize import word_tokenize stop_words = set(stopwords.words('english')) words = word_tokenize(text_data) filtered_words = [word.lower() for word in words if word.isalpha() and word.lower() not in stop_words] 2. 文本可视化 通过词云制作实现文本数据的可视化呈现。
使用wordcloud生成词云图：WordCloud是一个用于生成词云图的库，它根据文本中单词的频率生成具有可视化效果的图形。在示例代码中，我们通过WordCloud生成词云图，并使用matplotlib展示。 from wordcloud import WordCloud import matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c4b20e7a10d65cc80bf1ffe59974083/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/508278c78ff50e3df62c6e485bc85433/" rel="bookmark">
			开源模型应用落地-CodeQwen模型小试-SQL专家测试（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 代码专家模型是基于人工智能的先进技术，它能够自动分析和理解大量的代码库，并从中学习常见的编码模式和最佳实践。这种模型可以提供准确而高效的代码建议，帮助开发人员在编写代码时避免常见的错误和陷阱。
通过学习代码专家模型，开发人员可以获得高效、准确和个性化的代码支持。这不仅可以提高工作效率，还可以在不同的技术环境中简化软件开发工作流程。代码专家模型的引入将为开发人员带来更多的机会去关注创造性的编程任务，从而推动软件开发的创新和进步。
开源模型应用落地-CodeQwen模型小试-小试牛刀（一）
二、术语 2.1.CodeQwen1.5 基于 Qwen 语言模型初始化，拥有 7B 参数的模型，其拥有 GQA 架构，经过了 ~3T tokens 代码相关的数据进行预训练，共计支持 92 种编程语言、且最长支持 64K 的上下文输入。效果方面，CodeQwen1.5 展现出了非凡的代码生成、长序列建模、代码修改、SQL 能力等,该模型可以大大提高开发人员的工作效率，并在不同的技术环境中简化软件开发工作流程。
CodeQwen 是基础的 Coder
代码生成是大语言模型的关键能力之一，期待模型将自然语言指令转换为具有精确的、可执行的代码。仅拥有 70 亿参数的 CodeQwen1.5 在基础代码生成能力上已经超过了更尺寸的模型，进一步缩小了开源 CodeLLM 和 GPT-4 之间编码能力的差距。
CodeQwen 是长序列 Coder
长序列能力对于代码模型来说至关重要，是理解仓库级别代码、成为 Code Agent 的核心能力。而当前的代码模型对于长度的支持仍然非常有限，阻碍了其实际应用的潜力。CodeQwen1.5 希望进一步推进开源代码模型在长序列建模上的进展，我们收集并构造了仓库级别的长序列代码数据进行预训练，通过精细的数据配比和组织方式，使其最终可以最长支持 64K 的输入长度。
CodeQwen 是优秀的代码修改者
一个好的代码助手不仅可以根据指令生成代码，还能够针对已有代码或者新的需求进行修改或错误修复。
CodeQwen 是出色的 SQL 专家
CodeQwen1.5 可以作为一个智能的 SQL 专家，弥合了非编程专业人士与高效数据交互之间的差距。它通过自然语言使无编程专业知识的用户能够查询数据库，从而缓解了与SQL相关的陡峭学习曲线。
2.2.CodeQwen1.5-7B-Chat CodeQwen1.5 is the Code-Specific version of Qwen1.5. It is a transformer-based decoder-only language model pretrained on a large amount of data of codes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/508278c78ff50e3df62c6e485bc85433/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34f8a3619f510f8c01af8086eec7469a/" rel="bookmark">
			手把手教你从0到1搭建一个AI Agent(智能体)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LLM为什么需要agent化 虽然大语言模型的能力很强大，但是Llm仅限于用于训练的知识，这些知识很快会过时，所以llm有以下缺点
幻觉结果并不总是真实的对时事的了解有限或一无所知难以应对复杂推理和计算 例如：买高铁票
(虽然LLM完全理解了买票的行为，但是它本身并不知道“我”所处的城市，列车的时刻表，价格等等信息）
而基于大模型的Agent (LLM based Agent) 可以利用外部工具来克服以上缺点。
ReAct Agent ReAct Agent 论文
LLM Agent 的升级之路： Standard IO(直接回答) -&gt; COT(chain-of-thought)(思维链) -&gt; Action-Only (Function calling) -&gt; Reason + Action
ReAct = Reasoning(推理) + Action(行动)
ReAct Agent 的组成部分 （通过LangChain实现） Models：LLMPrompts：对Agent的指令、约束Memory : 记录Action执行状态 &amp; 缓存已知信息Indexes : 用于结构化文档，以便和模型交互Chains ：Langchain的核心（链）Agent ReAct Agent 的prompt 模板 from langchain_core.prompts import PromptTemplate template = '''Answer the following questions as best you can. You have access to the following tools: {tools} Use the following format: Question: the input question you must answer Thought: you should always think about what to do Action: the action to take, should be one of [{tool_names}] Action Input: the input to the action Observation: the result of the action .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34f8a3619f510f8c01af8086eec7469a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f18e389c987550933094e6392674e38/" rel="bookmark">
			搭建自己的AI智能QQ机器人，可实现单聊或者群聊，新手可看，手把手保姆级教学，可实现机器人托管自己的QQ，机器人可以定时发送消息，个性化定制机器人的类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、搭建自己的QQ服务器 GitHub上开源的项目go-cqhttp可以帮助快速搭建，并且操作十分简单 1. go-cqhttp官网：go-cqhttp 帮助中心 官网界面如下图 2. 下载自己机器适配的版本 如果你是Windows，推荐使用下面的两个文件，Linux也没事，文档中写的很清楚
3. 必要操作和配置文件 下载好之后是下面的三个文件：
双击go-cqhttp.exe，会出现控制台和三个弹窗，弹窗全部点击确定，控制台会自动关闭，这时会发现文件夹里多了一个文件go-cqhttp.bat，如下图所示，双击打开它
在出现的控制台上选择0，并将控制台关闭，接下来就是配置文件
返回文件夹，会发现多出一个文件：config.yml 如下图所示，使用记事本编辑它
文本内容如下图所示，uin是QQ号，password为QQ密码， 因为现在的QQ都有登陆保护或者验证，本次使用的是扫码登录，将uin和password全部置为空，多出的空格不必删除，删除就会报错
再将倒数几行的 地址 和 密钥 前面的 # 删掉，这一步不可以省略
保存文件之后，双击打开go-cqhttp.bat，此时会在文件夹内生成几个登录文件并尝试打开摄像头进行QQ的登录扫描，如果打开摄像头时报错协议不支持或者版本过低，则用记事本打开device.json并将其内容"protocol":6改为"protocol":2
到此，必要的操作和配置文件已经整理好，双击go-cqhttp.bat就可以登录我们自己的QQ了
如果自己弄不明白或者环境配置不上以及任何问题，欢迎和我私聊，如果希望快一点也可加我的微信：BeWhite_Studio
二、使用python语言进行消息的接收和发送 1. 接收QQ消息 将以下代码命名为：receive.py
# 接收QQ端消息 import socket import json ListenSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) ListenSocket.bind(('127.0.0.1', 5701)) ListenSocket.listen(100) HttpResponseHeader = '''HTTP/1.1 200 OK\r\n Content-Type: text/html\r\n\r\n ''' def request_to_json(msg): for i in range(len(msg)): if msg[i] == "{" and msg[-1] == "\n": return json.loads(msg[i:]) return None # 需要循环执行，返回值为json格式 def rev_msg(): # json or None Client, Address = ListenSocket.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f18e389c987550933094e6392674e38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ede653d5f48a8b62637726e5653c6e2f/" rel="bookmark">
			Java导入导出csv格式文件完整版详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先介绍下什么是csv文件？ CSV（Comma-Separated Values，逗号分隔的值）是一种简单、实用的文件格式，用于存储和表示包括文本、数值等各种类型的数据。CSV 文件通常以 .csv 作为文件扩展名。这种文件格式的一个显著特点是：文件内的数据以逗号 , 分隔，呈现一个表格形式。CSV 文件已广泛应用于存储、传输和编辑数据。
2.csv文件结构是什么？ CSV 文件的结构相对简单，通常由以下组成：
每行表示一条记录：CSV 文件中的每一行代表一条记录，相当于数据库中的一行数据。逗号分隔：每行数据中，使用逗号 , 进行数据分隔，代表不同的数据。引号包围：当数据单元格中的内容含有逗号时，为避免混淆，需要引号 (单引号 ' 或双引号 "）将这个数据包围起来，防止误认为是两个不同数据。 例如：
姓名,年龄,性别 张三,25,男 李四,28,男 王五,22,女 上面的例子中，CSV 文件包含三列（姓名、年龄和性别），每行都由逗号 , 分隔的三个数据项组成。
3.csv文件在导入和导出过程中需要注意什么呢？ 在导出csv文件时，通常都是通过文件流的格式进行导出。所以我们一定要注意文件逗号的处理以及换行。话不多说，上代码。
4.csv文件的导出工具类 package org.springjmis.SupSim.utils; import cn.hutool.json.JSON; import com.alibaba.nacos.common.utils.CollectionUtils; import org.springjmis.core.tool.utils.ObjectUtil; import springfox.documentation.spring.web.json.Json; import javax.servlet.http.HttpServletResponse; import java.io.*; import java.net.URLEncoder; import java.text.SimpleDateFormat; import java.util.Date; import java.util.List; import java.util.Map; public class CsvExportUtil { /** * CSV文件列分隔符 */ private static final String CSV_COLUMN_SEPARATOR = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ede653d5f48a8b62637726e5653c6e2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94eb115bc56f1a99e4bae5386242f545/" rel="bookmark">
			【Flutter】App内购支付集成 Google和Apple支付和服务器验证全流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flutter支付集成 前言： 以谷歌内购为例，我们需要做的总共为三步
需要在谷歌市场配置商品，设置测试渠道，配置开发者账号，设置对应权限。配置完商品之后，如何在 Flutter 中获取到商品，购买指定商品，消耗商品等。购买成功之后，如何到服务器校验是否支付成功，后台服务器如何配置通行权限，谷歌市场与谷歌云的关联以及相关校验。 购买交易的生命周期
下面是一次性购买或订阅的典型购买流程：
向用户展示他们可以购买什么。启动购买流程，以便用户接受购买交易。在您的服务器上验证购买交易。向用户提供内容。确认内容已传送给用户。对于消耗型商品，用户要先消耗掉已购商品，才能再次购买。 订阅会自动续订，直到被取消。订阅可处于下面这几种状态：
有效：用户信誉良好，可享用订阅内容。已取消：用户已取消订阅，但在到期前仍可享用订阅内容。处于宽限期：用户遇到了付款问题，但仍可享用订阅内容，同时 Google 会重新尝试通过相应的付款方式扣款。暂时保留：用户遇到了付款问题，不能再享用订阅内容，同时 Google 会重新尝试通过相应的付款方式扣款。已暂停：用户暂停了其订阅，在恢复之前不能享用订阅内容。已到期：用户已取消且不能再享用订阅内容。用户在订阅到期时会被视为流失。 支付流程示意图
一 、google开发者平台配置 首先进入谷歌开发者平台
https://developers.google.com/?hl=zh-cn
进入开发者平台之后，点击google play，创建我们的APP
点击登录管理中心
创建完我们的APP之后，就可以开始配置支付的功能。需要注意的是，在进行谷歌支付测试的时候，需要先提交一个封闭测试版本及以上等级（例如公开版本）的包，然后才可以去创建应用内支付的商品，等这个包提交审核通过之后才可以开始进行谷歌支付的测试。
1.1、创建定价模板 在设置页面
找到付款概况之后，如果没有付款账号，我们填写一些信息，姓名，邮箱，账号，等等信息，创建完成之后我们就可以设置定价的模板。
如果能创建模板说明你付款账号没问题，定价模板是非必须的，可有可无，但是定义了模板之后会更加方便，到时候创建商品可以直接关联模板，账号下的每一个子应用的内购商品都能关联对应的模板，有一个统一的定价。
如何创建定价模板如下：
我们创建模板之后，就可以定义模板的价格与标题，选择的金额会有对应的汇率转换，比如我创建的新加坡币，如果用港元支付的话，会根据汇率转换为对应的港元支付。
创建完成之后，我们就能看到对应的定价模板如下图所示：
1.2、上架封闭测试App 点击创建轨道
点击创建新的发布版本
签名选择Google管理签名，然后上传aab格式的release版本的包，aab版本的包在这里生成
点开Build，选择Generate Signed Bundle/APK
然后选择app bundle
然后一路next，最后选择release版本，然后finish
然后在输出控制台的build选项卡，即可找到刚刚打出来的aab包
然后上传就可以了。
1.3、创建应用内购商品 此时就可以配置应用内商品了，点击这里进行添加配置：
添加完成后记得激活，不然即使审核通过之后测试的时候也获取不到该商品
点击这里激活商品
这个时候商品的配置就完成了。
接下来添加测试账户，进入封闭测试页面，切换到【测试用户选项卡】，然后创建测试群组，在群组里添加测试人员账户即可
当你的APP审核通过之后，这个页面下方的测试人员参与方式便会生效，如下所示：
就可以将这些链接发给测试人员，让他们去安装进行测试购买。
最后修改一下测试政策状态
选中测试群组，然后将政策状态改为LICENSED
OK，配置完成
二 、Apple开发者平台添加内购商品 首先使用苹果开发者账户登录苹果开发者平台
https://developer.apple.com/account
点击【App】
添加新的苹果内购商品
添加的时候页面的指引很清晰，就不赘述了，苹果添加内购商品比较简单，加完就可以了。
然后去创建沙盒账户用来做苹果支付测试，回到首页，点击【用户和访问】
点击沙盒，然后添加一个苹果测试账户，这个账户可以是个假的邮箱，不需要是正式的Apple id,比如你可以设置为8888888@qq.com类似之类的账户
添加完点击创建即可
OK，配置完成
三、flutter 代码集成 使用到的官方推出的应用内购插件：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94eb115bc56f1a99e4bae5386242f545/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd4a0512e08d56b731e4e5330fddccc9/" rel="bookmark">
			SpringBoot项目中读取resource目录下的文件（六种方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、先获取绝对路径再读取文件(jar包里会获取不到)方法一：类加载器的getResource().getPath()获取目录路径方法二：类加载器的getResource().getPath()获取文件路径 二、直接获取文件流（jar包可用）方法三：ClassLoader对象的getResourceAsStream()方法四：Class对象的getResourceAsStream() 三、使用封装好的类（jar包可用）方法五：Spring提供的ClassPathResource方法六：Hutool提供的ResourceUtil 四、测试jar包中是否可用的代码 一、先获取绝对路径再读取文件(jar包里会获取不到) 方法一：类加载器的getResource().getPath()获取目录路径 /** * 方法一：使用类加载器的getResource().getPath()获取全路径再拼接文件名，最后根据文件路径获取文件流 * 备注：jar包不可用，因为jar包中没有一个实际的路径存放文件 * * @param fileName * @return * @throws FileNotFoundException */ public BufferedReader function1(String fileName) throws FileNotFoundException { // /Users/zunf/code/read-resource/target/classes/ String path = this.getClass().getClassLoader().getResource("").getPath(); // /Users/zunf/code/read-resource/target/classes/测试.txt String filePath = path + fileName; return new BufferedReader(new FileReader(filePath)); } 方法二：类加载器的getResource().getPath()获取文件路径 /** * 方法二：使用类加载器的getResource().getPath()，传参直接获取文件路径，再根据文件路径获取文件流 * 备注：jar包不可用，因为jar包中没有一个实际的路径存放文件 * * @param fileName * @return * @throws IOException */ public BufferedReader function2(String fileName) throws IOException { // /Users/zunf/code/read-resource/target/classes/%e6%b5%8b%e8%af%95.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd4a0512e08d56b731e4e5330fddccc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8a6d8c40a4e6e58a73474e302fa3771/" rel="bookmark">
			Android Studio多次安装后无法打开的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在安装Android Studio后，很多开发者可能会遇到这样一个问题：尽管安装过程看似顺利，但尝试打开Android Studio时，却没有任何反应。这种情况可能会令人感到困扰，但请不要担心，这里有一些可能的解决步骤。
ps:本人就是第一次全部非常正确顺利的安装后，然后能正常使用，but不小心点到了更新就打不开啦，又全部删除重新下载也打不开了。下载安装后在finish按钮点击后却没有任何反应，软件也打不开。。
就按其他博主的安装Android Studio的教程安装或者课本视频上安装到最后一步finish时点击后却没有任何反应，软件不会出现打开界面
卸载后全部删除、（下面是删除的每一个步骤）
记得删除这两个文件：
以及App Data（如果没有看到AppData文件可能是电脑隐藏了点击查看全部就可以找到了）
Local和Roaming下
删除Android、Android open Source Project文件夹，最重要的是Google文件下的内容全部删除：
尝试了很多博主的方法但是对我好像没用，也看了bz的视频没找到合适的视频就也没用。
然后我就尝试下载不同版本的AS重新安装，然后我就发现了我不能安装比我一开始安装版本高的软件，安装原来版本的软件也不行，只能安装比以前版本低的AS软件才能打开。
下面是我找到比较好下载的安装网站，也是比较全Android studio版本的网页：
AndroidDevTools - Android开发工具 Android SDK下载 Android Studio下载 Gradle下载 SDK Tools下载再重新进行正确的安装步骤就可以了，这次点击finish就会有反应啦，然后就软件导入gradle是非常的慢记得耐心等待就可以了哦。
如果还有遇到其他问题记得私信评论哦。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be129279700f3a9858ee48eb7c28ce79/" rel="bookmark">
			蛇鹭优化算法(SBOA)-2024年4月SCI新算法-公式原理详解与性能测评 Matlab代码免费获取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声明：文章是从本人公众号中复制而来，因此，想最新最快了解各类智能优化算法及其改进的朋友，可关注我的公众号：强盛机器学习，不定期会有很多免费代码分享~ 目录
原理简介
一、初始化阶段
二、蛇鹭的捕猎策略(探索阶段)
(1)寻找猎物
(2)消耗猎物
(3)攻击猎物
三、蛇鹭的逃生策略(开发阶段)
算法流程图和伪代码
性能测评
参考文献
完整代码
蛇鹭优化算法(Secretary Bird Optimization Algorithm, SBOA)是一种新型的元启发式算法（智能优化算法），灵感来源于模拟蛇鹭的生存能力来解决现实世界的优化问题。这位作者的论文足足写了一百多页，令人震惊，不知道大家为何都越来越卷~SBOA使用CEC-2017和CEC-2022基准套件与15种高级算法进行了比较，并利用其解决了12个约束工程设计问题和无人机三维路径规划。该成果由Youfa Fu等人于2024年4月发表在SCI人工智能二区顶刊《Artificial Intelligence Review》上！
由于发表时间较短，谷歌学术上还没人引用！你先用，你就是创新！
原理简介 灵感：秘书鸟（学名：蛇鹭）是一种引人注目的非洲猛禽，以其独特的外表和独特的行为而闻名。它广泛分布在非洲撒哈拉沙漠以南的草原、稀树草原和开阔的河流地区。秘书鸟通常栖息在热带开阔的草原、树木稀疏的稀树草原和长着高草的开阔地区，它们也可以在半沙漠地区或有开阔空地的树木繁茂的地区找到。秘书鸟的羽毛特点是背部和翅膀上的羽毛呈灰褐色，胸部为纯白色，腹部为深黑色。
秘书鸟的智慧体现在它躲避捕食者的策略上，它包括两种不同的方法。第一种策略涉及到鸟类在发现附近有威胁时伪装自己的能力。如果适合伪装成周围的环境，秘书鸟会融入它的环境，以逃避潜在的威胁。当鸟意识到周围环境不利于伪装时，第二种策略就开始发挥作用了。在这种情况下，它会选择飞行或快速行走作为一种迅速逃离捕食者的手段。秘书鸟行为与秘书鸟优化算法(SBOA)的对应关系如下图所示。在这种情况下，秘书鸟的预备狩猎行为对应于秘书鸟优化算法(SBOA)的初始化阶段。秘书鸟的狩猎过程的后续阶段与SBOA的三个探索阶段相一致。秘书鸟逃避捕食者的两种策略分别对应于SBOA开发阶段的两种策略C1和c2。
一、初始化阶段 蛇鹭优化算法(SBOA)方法属于基于种群的元启发式方法，其中每只秘书鸟都被认为是算法种群中的一个成员。每个秘书鸟在搜索空间中的位置决定了决策变量的值。因此，在初始实现sba时，采用式(1)对秘书鸟在搜索空间中的位置进行随机初始化。
二、蛇鹭的捕猎策略(探索阶段) 秘书鸟以蛇为食时的捕猎行为通常分为三个阶段:寻找猎物、消耗猎物和攻击猎物。秘书鸟的狩猎行为如下图所示。
根据秘书鸟捕食阶段的生物学统计和每个阶段的持续时间，我们将整个捕食过程分为三个相等的时间间隔，分别为t&lt;1/3T、1/3T&lt;t&lt;2/3T和2/3T&lt;t&lt;T，分别对应秘书鸟捕食的三个阶段:寻找猎物、消耗猎物和攻击猎物。
(1)寻找猎物 秘书鸟的捕猎过程通常是从寻找潜在的猎物开始的，尤其是蛇。秘书鸟拥有令人难以置信的敏锐视力，使它们能够迅速发现隐藏在大草原高草中的蛇。它们用长腿慢慢地扫地，同时注意周围的环境，寻找蛇的迹象。它们的长腿和长脖子使它们能够保持相对安全的距离，以避免蛇的攻击。这种情况出现在优化的初始迭代中，此时探索至关重要。因此，这一阶段采用差分进化策略。差分进化利用个体之间的差异来产生新的解决方案，增强了算法的多样性和全局搜索能力。通过引入微分变异操作，多样性可以帮助避免陷入局部最优状态。个体可以探索解空间的不同区域，从而增加找到全局最优解的机会。
在寻找猎物阶段更新秘书鸟的位置可以使用公式(4)(5)​进行建模：
式中，t表示当前迭代次数，T表示最大迭代次数，Xnew,P1 i表示第i只秘书鸟在第一阶段的新状态，xrandom_1和xrandom_2是第一阶段迭代的随机候选解。R1表示区间[0,1]中随机生成的维数为1 × Dim的数组，其中Dim为解空间的维数。xnew P1 i,j表示其第j维的值，Fnew P1 i表示其目标函数的适应度值。
(2)消耗猎物 在秘书鸟发现一条蛇后，它采用了一种独特的狩猎方法。不像其他猛禽会立刻扑进去战斗，秘书鸟用它敏捷的步法和在蛇周围的机动。秘书长站在原地，从高处观察蛇的一举一动。它利用对蛇的动作的敏锐判断，逐渐盘旋、跳跃、挑衅蛇，从而消耗对手的耐力。在这个阶段，使用“xbest”(历史最佳位置)和布朗运动的概念。通过使用“xbest”，个体可以对他们之前找到的最佳位置执行局部搜索，从而更好地探索周围的解决方案空间。此外，这种方法不仅可以帮助个体避免过早收敛到局部最优，而且可以加速算法收敛到解空间中的最佳位置。这是因为个体可以根据全局信息和自己的历史最佳位置进行搜索，从而增加了找到全局最优的机会。布朗运动随机性的引入使个体能够更有效地探索解空间，并提供避免陷入局部最优的机会，从而在解决复杂问题时获得更好的结果。
因此，秘书鸟在捕食阶段的位置更新可以用公式(7)(8)进行建模：
其中，randn(1, Dim)表示从标准正态分布(平均值为0，标准差为1)中随机生成的维数为1 × Dim的数组，xbest表示当前最优值。
(3)攻击猎物 当蛇筋疲力尽时，秘书鸟察觉到了合适的时机，迅速采取行动，利用其强大的腿部肌肉发动攻击。这一阶段通常涉及秘书鸟的踢腿技术，它迅速抬起腿，用锋利的爪子准确地踢蛇，通常瞄准蛇的头部。这些踢腿的目的是迅速使蛇失去能力或杀死蛇，从而避免被咬伤。锋利的爪子攻击蛇的要害，导致它的死亡。有时，当蛇太大而不能立即被杀死时，秘书鸟可能会把蛇带到天空中并释放它，使它坠落在坚硬的地面上，并结束它的生命。在随机搜索过程中，引入Levy飞行策略，增强了优化器的全局搜索能力，降低了SBOA陷入局部解的风险，提高了算法的收敛精度。利维飞行是一种随机的运动模式，其特点是短而连续的步骤和偶尔的长跳跃在短时间内。模拟秘书鸟的飞行能力，增强其对搜索空间的探索能力。大步长有助于算法探索搜索空间的全局范围，使个体更快地接近最佳位置，而小步长有助于提高优化精度。为了使SBOA更具活力，在优化过程中，为了更好地平衡探索与开发、避免过早收敛、加速收敛和提高算法性能，我们引入了一个非线性扰动因子，表示为(1−t) (2 × t)。
因此，更新秘书鸟在攻击猎物阶段的位置可以使用公式(9)(10)进行建模：
三、蛇鹭的逃生策略(开发阶段) 秘书鸟的天敌是大型食肉动物，如鹰、鹰、狐狸和豺狼，它们可能会攻击秘书鸟或偷走秘书鸟的食物。当遇到这些威胁时，秘书鸟通常采用各种逃避策略来保护自己或它们的食物。
这些策略大致可以分为两大类。第一种策略是逃跑或快速奔跑。秘书鸟以其异常长的腿而闻名，这使它们能够以惊人的速度奔跑。它们一天可以走20到30公里的距离，因此被称为“行军鹰”。第二种策略是伪装。秘书鸟可能会利用环境中的颜色或结构融入其中，使捕食者更难发现它们。
在第一种策略中，当秘书鸟探测到捕食者的附近时，它们首先寻找合适的伪装环境。如果附近没有合适和安全的伪装环境，它们会选择飞行或快速奔跑逃跑。在这种情况下，我们引入一个动态扰动因子，记为(1−t/T)^2。这种动态扰动因素有助于算法在探索(寻找新的解决方案)和开发(使用已知的解决方案)之间取得平衡。通过调整这些因素，可以在不同阶段提高勘探水平或加强开采。综上所述，秘书鸟采用的两种逃避策略可以用公式(14)(15)进行建模​：
其中，r=0.5, R2表示从正态分布中随机生成维度为(1 × Dim)的数组，xrandom表示当前迭代的随机候选解，K表示整数1或2的随机选择，可由公式(16)计算：
这里，rand(1,1)表示在(0,1)之间随机生成一个随机数。
算法流程图和伪代码 为了使大家更好地理解，这边给出算法流程图和伪代码，非常清晰！
如果实在看不懂，不用担心，可以看下代码，再结合上文公式理解就一目了然了！
性能测评 原文作者在CEC-2017和CEC-2022基准测试函数中将SBOA与15种高级算法进行了比较，所有测试结果一致证明了SBOA在解决方案质量、收敛速度和稳定性方面的卓越性能。最后，利用SBOA解决了12个约束工程设计问题，并对无人机进行了三维路径规划。
这边为了方便大家对比与理解，采用23个标准测试函数，即CEC2005，并与性能优越的麻雀搜索算法SSA进行对比！这边展示其中5个测试函数的图，其余十几个测试函数大家可以自行切换尝试！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be129279700f3a9858ee48eb7c28ce79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83db9df156c27d1cc3626065eae4be7b/" rel="bookmark">
			Linux下Redis下载及安装教程(实测有效)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、配置gcc 由于Redis是基于c语言编写的需要安装依赖,需要安装gcc，在Linux系统里需要存在C语言的编译环境，一般的Linux系统安装的时候会自动安装，由于我是最小安装模式，所以我需要自己再另外安装一下。
判断系统是否安装gcc，输入命令gcc --version,如果显示未找到命令，则需要安装。
未安装的话输入命令安装 yum install gcc
安装完成后再次输入 gcc --version进行验证 二、下载Redis 1.安装前需要先准备redis安装包，这里示范所选择安装的redis版本为6.2.11 Redis官网链接
redis-6.2.11直接下载地址
2.下载后通过xftp传输到Linux上 新建一个redis的文件夹，我放在usr/local/redis/下
mkdir /usr/local/redis/ 通过xftp传输到Linux上
三、在Linux上安装Redis 1.解压redis安装包 解压redis安装包
tar -zxvf redis-6.2.11.tar.gz 2.查看目录结构 3.make编译 到redis文件夹下输入命令 make
注意：如果执行make命令这里报错: cc not found (cc未找到命令),原因就是因为Linux上缺少gcc,执行命令进行安装即可:
yum install gcc 等待一会即可编译完成。
4.安装redis 执行下面命令安装redis,并指定安装目录
make install PREFIX=/usr/local/redis/redis-6.2.11 安装成功
四、配置redis服务 1.启动redis服务 进入刚刚make install 的redis安装目录,并执行下面命令启动redis服务
./bin/redis-server redis.conf 2.修改redis配置文件
注意:以上面这种启动方法启动redis不能退出控制台,如果退出,那么redis服务也会停止。 如果想要让redis以后台的方式运行，需要修改redis中的配置文件：redis.conf
将该配置文件中的daemonize no改为yes即可。
vim redis.conf 修改完配置文件后,重新启动一下redis服务
./bin/redis-server redis.conf 这个时候就不会一直处在运行界面上，而是后台运行了。
注意:如果需要在其他主机连接redis，利用使用桌面软件连接redis时,记得要修改redis.conf配置文件,要注释掉 ,即配置了允许所有主机连接。
找到bind 127.0.0.1将这一行注掉，新加一行bind 0.0.0.0，为了能够远程连接redis。
修改完后记得重启redis服务使配置文件生效。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83db9df156c27d1cc3626065eae4be7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dc17b00f8a16948f5f8c7fe511fa9cf/" rel="bookmark">
			当AI遇见现实：数智化时代的人类社会新图景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、数智化时代的机遇二、数智化时代的挑战三、如何适应数智化时代《图解数据智能》内容简介作者简介精彩书评目录精彩书摘强化学习什么是强化学习强化学习与监督学习的区别强化学习与无监督学习的区别 前言/序言 随着科技的日新月异，我们步入了一个前所未有的数智化时代。互联网、大数据、人工智能等新一代信息技术的迅猛发展，不仅极大地推动了社会的进步，也正在深刻地改变着我们的生活、工作和思考方式。在这个时代，机遇与挑战并存，我们需要保持敏锐的洞察力和适应力，以更好地把握未来。
一、数智化时代的机遇 在数智化时代，数据成为新的石油，驱动着经济的增长和社会的进步。通过收集、分析和利用数据，我们能够洞察市场趋势、优化决策过程、提升服务效率。同时，云计算、物联网、人工智能等技术的广泛应用，为我们提供了强大的计算能力和智能支持，推动了各行各业的数字化转型和创新发展。
在数字经济领域，新的商业模式和业态不断涌现，电子商务、在线教育、远程医疗等新兴产业蓬勃发展，为人们提供了更加便捷、高效的服务体验。在数字社会领域，社交媒体、网络社区等平台成为人们获取信息、交流思想的重要渠道，推动了社会文化的多样性和包容性。在数字生活和数字治理领域，智能家居、智慧城市等应用的普及，提高了人们的生活质量和城市的治理效率。
二、数智化时代的挑战 然而，数智化时代也带来了诸多挑战。首先，技术的快速迭代和更新让我们应接不暇，需要不断学习和适应新的知识和技能。其次，数字鸿沟的问题日益凸显，不仅存在于代际和城乡之间，更广泛地存在于主动的概念创造者与被动的概念接受者之间。此外，随着数据的不断积累和应用，数据安全和隐私保护问题也日益突出。
同时，数智化时代的变革也对我们的思维方式和工作方式提出了新的挑战。我们需要更加开放、包容和创新的思维方式，以应对不断变化的市场需求和技术趋势。同时，我们也需要更加灵活、高效和协作的工作方式，以适应数字化、智能化和远程化的工作模式。
三、如何适应数智化时代 面对数智化时代的机遇和挑战，我们需要采取积极的措施来适应这个新世界。首先，我们需要加强学习和培训，不断提升自己的数字化素养和智能化能力。通过参加课程、阅读书籍、参与实践等方式，了解最新的科技动态和市场趋势，掌握必要的技术知识和应用技能。
其次，我们需要保持开放的心态和创新的思维，敢于尝试新事物、新方式和新模式。通过关注行业动态、参与创新实践、与同行交流等方式，不断拓展自己的视野和思维，寻找新的发展机遇和增长点。
最后，我们需要加强合作与交流，共同推动数智化时代的发展和进步。通过加强企业间、行业间、国际间的合作与交流，共同推动技术创新、产业升级和社会发展。同时，我们也需要加强与社会各界的沟通与合作，共同推动数字化、智能化和远程化等技术在社会各个领域的广泛应用和普及。
《图解数据智能》 获取方式：https://item.jd.com/13368169.html
内容简介 一个万物互联的数字化世界正在悄然形成，不知不觉中，我们已经进入到了一个前所未有的数字化与智能化时代。
数智化时代对人类社会的改变是颠覆性的。半导体芯片技术的突飞猛进，使得万物皆可“数”；宽带泛在网络的普及应用，使得万物皆可“连”；云计算（算力）与人工智能（算法）的并行发展，使得万事皆可“算”。数据已成为新的生产要素，算法和算力已成为新的生产动力，机器智能将成为新的生产工具，数字经济、数字社会、数字生活和数字治理都将成为智能革命广阔的主战场。我们该如何认识并适应这个时刻变化中的世界？
《图解数据智能》是一本为数字资源的对接方、分配方以及广大的入门学习者提供相关数据智能概念的科普读物。书中各个概念之间相对独立，读者可以将其作为一本检索用的工具书籍，也可以根据自己的兴趣灵活查阅相关篇章。
无论你是数智化领域的专业从业人员，还是刚刚毕业想要进入该领域的技术小白，抑或是正面临着数字化转型的政府或企业人员，或者是千千万万个生活在这个数智化社会中的普通人，都可以阅读此书，你将从酣畅淋漓的技术释疑和轻松有趣的漫画解读中，找到自己的答案。
作者简介 张燕玲，四川大学文学硕士，零点有数营销总监，历任研究总监，具有10余年数据研究工作经验，两次荣获中国市场研究行业专业论文“宝洁奖”一等奖，发表文章数百篇。在推动数据智能和算法产业应用的科普传播方面具有丰富经验。
许正军，博士，高级通信工程师，零点有数技术副总裁。从事信息通信技术、互联网、工业互联网、“互联网+政务服务”和数据智能行业应用开发20余年，在各类学术刊物上发表过40多篇论文。在数字政府、数字社会和数字经济建设领域具有丰富的理论与实践经验。
张军，中国人民大学经济学硕士，零点有数董事、首席执行官，兼任中国信息协会市场研究业分会（CMRA）副会长、欧洲民意与市场研究协会（ESOMAR）中国代表、全球移动通信系统协会(GSMA)评委等职，多年来致力于公共管理和商业服务领域的数据挖掘与咨询服务。
精彩书评 本书整合贯通“数据”“算力”“算法”“技术”和“应用”等基本原理和关键技术，对“数据智能”系列相关通识性内涵及外延进行了故事化和漫画式的逻辑性科普。一册在手，必有所获。
——杜平 国家信息中心原常务副主任和党委书记、现粤港澳大湾区大数据研究院理事会理事长
数智时代、万物互联。能否掌握这轮数智化变革的核心技术是国家立于强国之林的关键。本书语言深入浅出，辅之漫画便于理解，是一本适合全民科普的佳作。
——宋海涛 上海人工智能研究院总经理、执行院长
本书从数据、算力、算法入手，生动形象地介绍了新一代信息技术和数字化转型的知识，是一本难得的科普佳作，有助于我们更好地认识和适应当今数字化世界。
——刘迎风 上海市大数据中心副主任
本书将“数据”到“智能”的原理及各类关键技术概念进行了浅显易懂的解读，是一本难得的用心之作，值得推荐阅读
——彭拯 湘潭大学数学与计算科学学院教授 博士生导师
该书系统性地将“数据智能”的原理、所涉及的技术概念进行了讲解，全书通俗易懂，是数据智能领域非常好的科普著作，值得阅读。
——杨俊锋，南京大学数学系教授、博士生导师、2020年国家优秀青年基金获得者
本书系统性地从“数据”到“智能”所涉及的大量相关概念进行了图文并茂的讲解，是数据智能方面非常好的科普著作，值得阅读。
————卢勇 上海数据交易所副总经理
本书以技术概念为支撑，以数字化转型为主线，聚集人工智能三要素，深入浅出地将“数据智能”进行了全面的图解，是一本难得的科普作品。
——海涛 中国银联原云闪付部副总经理
“数据智能”是人类探索未知事物的一种重要形态，刻画了从“数据”到“信息”到“洞察”再到“智能”的全过程。本书从“算量”“算力”“算法”的综合视角切入，推进全社会“数字化转型”，以生动形象的表述带领读者打开了一窥“数据智能”的大门。
——王彦博 华夏银行金融科技公司（龙盈智达）首席数据科学家、公司副总裁级
目录 第1章　算量　/001 本章导读　/001 大数据　/004 结构化数据　/014 非结构化数据　/021 特征工程　/026 多源数据　/034 网络爬虫　/038 行为数据　/042 元数据　/048 数据仓库　/054 集群系统　/059 分布式系统　/063 中台　/068 数据加密　/076 第2章　算法　/085 本章导读　/085 人工智能　/089 算法　/096 模糊计算　/103 机器学习　/108 监督学习　/111 无监督学习　/116 强化学习　/121 人工神经网络　/127 深度学习　/134 集成学习算法　/139 图像识别　/148 人脸识别　/155 计算机视觉　/158 无人驾驶　/163 开源算法平台　/168 算法偏见　/173 算法责任　/179 第3章　算力　/184 本章导读　/184 算力　/186 DPU　/192 AI 芯片　/204 云、云计算、云存储　/213 公有云、私有云、混合云　/223 边缘计算　/231 第4章　新一代信息技术　/237 本章导读　/237 新一代信息技术　/239 数字新基建　/244 5G　/252 物联网　/260 消费互联网　/268 产业互联网　/273 工业互联网　/278 IPv6　/284 集成电路　/290 芯片　/296 传感器　/301 人机交互　/308 下一代操作系统　/311 智联网　/317 AR/VR　/323 数字孪生　/328 第5章　数字化转型　/334 本章导读　/334 网络强国　/335 数字中国　/340 智慧城市　/346 城市大脑　/351 数字底座　/358 数字化转型　/362 数智化　/366 数字政府　/374 数字经济　/382 数字化治理　/387 数字民生　/391 城市生命体征　/395 智能制造　/400 商业智能　/405 数字货币　/410 精彩书摘 强化学习 【导读】强化学习、监督学习和半监督学习属于机器学习的三个大类。强化学习（Reinforcement Learning）又被称为再励学习、评价学习或增强学习，是除了监督学习和无监督学习之外的第三种机器学习方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7dc17b00f8a16948f5f8c7fe511fa9cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b45acd5e6db2f789a18ba0d7ec30691/" rel="bookmark">
			纯净化安装EasyConnect：macOS Sonoma使用docker安装EasyConnect---docker-easyconnect
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		macOS Sonoma使用docker安装EasyConnect 硬软件配置以及安装背景硬软件配置安装背景 需要准备的工具使用方法：具体操作1.安装docker-easyconnect1.1纯命令行版 EasyConnect（amd64 架构）1.2图形界面版 EasyConnect（x86、amd64、arm64、mips64el 架构） 2.登录vpn1.使用web登录2.使用VNC Viewer登录3.使用命令行进行登录 代理1.使用Proxy SwitchyOmega进行代理2.使用clash进行代理 总结 硬软件配置以及安装背景 硬软件配置 MacBook Pro（2.4 GHz 八核Intel Core i9）macOS Sonoma 14.4 (23E214)EasyConnect_7_6_7_4 安装背景 在公司内网访问过程中，需使用VPN。但在下载并尝试使用EasyConnect时，发现应用打开后无反应。即便通过网页登录，应用也会不断重启，严重影响了电脑的正常使用。考虑到EasyConnect的口碑及可能存在的安全风险，我决定采用一种更安全的方式——使用docker来部署EasyConnect。在网上找到一个使用docker部署EasyConnect的方案，尽管在搭建过程中遇到了不少问题，但最终还是成功解决了。以下是我的经验分享，希望对遇到类似问题的朋友有所帮助。
需要准备的工具 Docker：开源的容器引擎，对于开发者来说相当熟悉。可以从其官网下载。docker-easyconnect：让深信服的 VPN 软件 EasyConnect 或 aTrust 运行在 docker
中，提供 socks5 和 http代理服务和网关供宿主机连接使用。软件使用可以项目地址找到。VNC Viewer：远程桌面控制软件。当登录VPN需要图形验证码或手机验证码时，此软件尤为有用，可在下载地址获取软件。如果只需密码就可以登录，请忽略本软件。Clash：代理客户端，我使用的是clash-verge-rev（v1.5.8），可从下载地址获取。Proxy SwitchyOmega：Chrome代理插件，如果只浏览器访问特定代理地址时，推荐使用此插件，操作更为简便。 使用方法： 首先，安装Docker，然后下载并运行docker-easyconnect的镜像。运行成功后，将提供socks5和http代理服务及网关，供宿主机连接使用。接着，通过代理插件或Clash代理，即可实现访问内网地址。
具体操作 1.安装docker-easyconnect 1.1纯命令行版 EasyConnect（amd64 架构） 注意，纯命令行版本仅支持以下登录方式：用户名+密码、硬件特征码。
安装Docker并运行；在终端输入： docker run --rm --device /dev/net/tun --cap-add NET_ADMIN -ti -p 127.0.0.1:1080:1080 -p 127.0.0.1:8888:8888 -e EC_VER=7.6.3 -e CLI_OPTS="-d vpnaddress -u username -p password"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b45acd5e6db2f789a18ba0d7ec30691/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/839489efbd822230315277f00e1191a2/" rel="bookmark">
			C#WinForm连接sql server数据库进行增删改查详细步骤（包会）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 需要下载的软件vs2022社区版，sql server
1.1 vs2022社区版 下载完成后点击新建项目，创建windows窗体应用，如图：
1.2 在创建好的窗体应用中创建一个button控件和一个datagrewview控件，如图所示：
2 下载sql server数据库，创建自己的账户和密码，进行登录 如下图所示：
2.1 创建20240401数据库 在其中创建学生信息表 如下图所示：
3 在vs中点击工具，连接到数据库，输入自己的服务器名字和数据库的账户，密码进行连接 如下图所示：
3.1 双击button控件 编写代码 如下所示 注意：代码中的ip 数据库名称，表名称要更换为自己的名称
using System.Data;
using System.Data.SqlClient;
using System.Windows.Forms;
namespace _2024042501
{
public partial class Form1 : Form
{
public Form1()
{
InitializeComponent();
}
private void button1_Click(object sender, EventArgs e)
{
//连接
string conStr = "server=DESKTOP-N0NGI; user id = xx; password = 123456; database = 数据库";
SqlConnection con = new SqlConnection(conStr);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/839489efbd822230315277f00e1191a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/960e7468d9d39f8ee9db6e9ae05b4a50/" rel="bookmark">
			【WebGIS实例】（14）MapboxGL 加载地形高程数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 官网示例：Add 3D terrain to a map | Mapbox GL JS | Mapbox
大佬博客：Mapbox GL基础（七）：地形数据的处理与加载 (jl1mall.com)
加载Mapbox地形数据 map.once('style.load', () =&gt; { map.addSource('mapbox-dem', { type: 'raster-dem', url: 'mapbox://mapbox.mapbox-terrain-dem-v1', tileSize: 512, maxzoom: 14 }) map.setFog({}) // 可选：添加大气层(雾气)效果 map.setTerrain({ source: 'mapbox-dem', exaggeration: 1.5 }) }) 加载 tif 格式高程影像 数据名称：Rectangle_#5_高程_右3_Level_16.tif
使用工具：GitHub - FreeGIS/dem2terrain: 根据dem数据生成地形切片的工具
NodeJS 版本：v16.20.2
dem2terrain 这个库的教程写得非常详细了，把项目拷下来按着教程配置一遍就行了。下面是我遇到的问题的记录：
NodeJS 版本问题：实测16.20.2是可行的Windows11 c++编译环境问题：
报错：npm ERR! gyp ERR! stack Error: Could not find any Visual Studio installation to use
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/960e7468d9d39f8ee9db6e9ae05b4a50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d172264b37d95c866bc05864fdd69867/" rel="bookmark">
			flutter开发实战-webview_flutter 4.x版本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		flutter开发实战-webview_flutter 4.x版本使用
在之前使用的webview_flutter版本是3.x的，升级到4.x后，使用方式有所变化。
一、webview_flutter 在工程的pubspec.yaml中引入插件
webview_flutter: ^4.4.2 二、使用webview_flutter 在4.x版本中，我们使用WebViewController来监听加载的状态
代码如下
controller ..setJavaScriptMode(JavaScriptMode.unrestricted) ..setBackgroundColor(const Color(0x00000000)) ..setNavigationDelegate( NavigationDelegate( onProgress: (int progress) { debugPrint('WebView is loading (progress : $progress%)'); }, onPageStarted: (String url) { debugPrint('Page started loading: $url'); }, onPageFinished: (String url) { debugPrint('Page finished loading: $url'); }, onWebResourceError: (WebResourceError error) { debugPrint(''' Page resource error: code: ${error.errorCode} description: ${error.description} errorType: ${error.errorType} isForMainFrame: ${error.isForMainFrame} '''); }, onNavigationRequest: (NavigationRequest request) { if (request.url.startsWith('https://') || request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d172264b37d95c866bc05864fdd69867/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/530dcfea7a7bc868d54be0323de4c1c4/" rel="bookmark">
			数据结构(C):玩转链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
🍺0.前言
1.链表的概念
2.链表的分类 2.1带头不带头
2.2单向和双向
2.3循环和不循环
2.4主要使用的链表 3.链表的实现 3.1申请一个链表
3.2头插和尾插
3.2.1函数的形参问题
3.2.2二级指针问题解决
3.3头删和尾删
3.4打印链表
3.5查找
3.5销毁链表
3.6某个位置插入和删除 3.6.1前插
3.6.1后插
3.6.3前删
3.6.4后删
4.结束语
🍺0.前言 言C之言，聊C之识，以C会友，共向远方。各位博友的各位你们好啊，这里是持续分享数据结构知识的小赵同学，今天要分享的数据结构知识是链表，在这一章，小赵将会向大家展开聊聊链表。✊
1.链表的概念 概念：链表是一种 物理存储结构上非连续 、非顺序的存储结构，数据元素的 逻辑顺序 是通过链表中的 指针链接次序 实现的 。 当然了光靠这个字面上的的理解就想理解链表我感觉还是蛮难的，所以呢，小赵在这里为大家找了一幅图片，方便大家理解 有人说这不是一个火车吗？怎么会和链表扯上关系，但实际上链表和火车是极其相似的，我在这里为大家画了个链表的图。
链表的结构就是一环接着一环的，哪这每一个环是什么呢？其实就是我们的结构体了。我们将结构体的指针放在前一个结构体的里面，来实现彼此之间的互通，从而形成一个链表。
2.链表的分类 可能看到这个标题有人会疑惑为什么链表还有分类呢？不就是一根链子吗？实际上则不然，相比较我们前面所说的火车，链表的可能性更多，它可以没有火车头，它可以彼此之间相互拉着，你拉着我，我拉着你，它们可以从头到尾，也可以围成一个圈，成一个环。
那么究竟到底有哪几种呢？小赵按照三个特征为他们划分，同时它们可以自由组合。
2.1带头不带头 带头和不带头长啥样呢就是下面这个样子
那带头和不带头有啥区别呢？其区别其实和火车很像，我们知道火车头往往是不载客的，而其实我们的这个头也是不载数据的，当然最主要的区别还是在我们后面使用的方便度上。
2.2单向和双向 其实我觉得单向和双向的例子还蛮好理解的，就像我们谈恋爱一样，你单喜欢她，她不喜欢你，就叫单向。互相喜欢就是双向。 2.3循环和不循环 循环和不循环其实也相对比较好理解一点，在这里就不多说了。
这三个特征各位可以随意组合都能构成链表，同时各位用这三个基本特征去判断链表，也能让各位准确地判断出这是什么链表。
2.4主要使用的链表 虽然链表的种类如此之多之杂，但实际上我们正常使用的链表只有下面两个。
说白了，就是一个是白手起家，一个是啥都有的大土豪。白手起家的可能在我们的刷题中是很常见的，因为毕竟是白手起家，难度可能会更大一些。而什么都有这个各位后面会知道真的很爽，但题大多数题目是不会给你这么爽的。所以今天我们聊链表的时候会用我们的穷小子，来做，这样以后做大土豪也更容易一些。
3.链表的实现 那么链表该如何实现呢？跟上面的顺序表一样，我们也是从链表的功能增删查改来玩。
当然开始之前我们肯定是要先定义一个节点：
typedef int SLTDateType; typedef struct SListNode { SLTDateType data; struct SListNode* next; }SListNode; 3.1申请一个链表 这里我们换一种和之前的顺序表不一样的方式，我们直接用指针去玩，因为链表里面的指针非常多，我们可以直接申请一个指针的链表。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/530dcfea7a7bc868d54be0323de4c1c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/478d5cbae2500116d20e6de4567d6eb4/" rel="bookmark">
			Python中怎么安装pandas库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 使用命令行（Windows、Linux或Mac）使用国内镜像源 使用Anaconda（推荐用于数据分析和科学计算）在IDE中安装（如PyCharm）验证安装 要在Python中安装pandas库，您可以使用pip（Python的包管理器）来执行。以下是安装pandas的几种方法： 使用命令行（Windows、Linux或Mac） 打开命令行界面（在Windows上可能是CMD或PowerShell，在Linux或Mac上可能是Terminal），然后输入以下命令：
pip install pandas 或者，如果您使用的是Python 3，并且pip没有指向Python 3的版本，您可能需要使用：
pip3 install pandas 或者，在某些系统上，您可能需要使用python -m pip来确保使用正确的Python版本：
python -m pip install pandas 或者
python3 -m pip install pandas 使用国内镜像源 由于默认的pip下载源在国内访问时下载速度过慢，所以可以使用国内镜像源来加速下载。
常用的国内镜像源有：Python的国内安装源（也称为镜像源）
如何修改默认的下载源，可以参考：学习Python怎么修改默认的pip下载源
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple/ pandas 这将会从清华大学的TUNA镜像源中安装指定的pandas。
使用Anaconda（推荐用于数据分析和科学计算） 如果您已经安装了Anaconda，那么可以使用conda命令来安装pandas：
conda install pandas conda通常与Anaconda一起安装，用于管理Python环境和包，特别适用于数据分析和科学计算。
在IDE中安装（如PyCharm） 如果您使用的是像PyCharm这样的集成开发环境（IDE），那么通常可以在IDE的设置或首选项中直接搜索和安装pandas。在PyCharm中，您可以转到File &gt; Settings &gt; Project: [Your Project Name] &gt; Python Interpreter，然后点击右下角的+按钮来搜索和安装pandas。
验证安装 安装完成后，您可以在Python解释器或脚本中尝试导入pandas来验证是否成功安装：
import pandas as pd print(pd.__version__) 如果成功导入并且打印出版本号，那么说明pandas已经成功安装。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/109588d6952bb4b9620553e3607d5e8c/" rel="bookmark">
			2024年再见，Java 8！Java 17 终于免费了，史上最快的 JDK。。(1)，跟谁学java技术面试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kafka实战笔记 关于这份笔记，为了不影响大家的阅读体验，我只能在文章中展示部分的章节内容和核心截图
Kafka入门为什么选择KafkaKarka的安装、管理和配置 Kafka的集群第一个Kafka程序 afka的生产者
Kafka的消费者深入理解Kafka可靠的数据传递 Spring和Kalka的整合Sprinboot和Kafka的整合Kafka实战之削峰填谷数据管道和流式处理(了解即可) Kafka实战之削峰填谷 本文已被CODING开源项目：【一线大厂Java面试题解析+核心总结学习笔记+最新讲解视频+实战项目源码】收录
需要这份系统化的资料的朋友，可以点击这里获取
稳定的机器，没有任何其他计算要求的进程在运行。
配置 Intel® Xeon® Silver 4116 @ 2.1 GHz (12 cores total / 24 threads) ,128 GiB RAM ,RHEL 8 x86_64
2、JDKs（用于编译和运行） JDK 11 openjdk 11.0.12 2021-07-20
OpenJDK Runtime Environment Temurin-11.0.12+7 (build 11.0.12+7)
OpenJDK 64-Bit Server VM Temurin-11.0.12+7 (build 11.0.12+7, mixed mode)
JDK 16 openjdk 16.0.2 2021-07-20
OpenJDK Runtime Environment (build 16.0.2+7-67)
OpenJDK 64-Bit Server VM (build 16.0.2+7-67, mixed mode, sharing)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/109588d6952bb4b9620553e3607d5e8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23078971ac03ec46b8f460f74c99c8d4/" rel="bookmark">
			【数据结构】带你轻松掌握算法的复杂度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引入： 哈喽大家好，我是野生的编程萌新，首先感谢大家的观看。数据结构的学习者大多有这样的想法：数据结构很重要，一定要学好，但数据结构比较抽象，有些算法理解起来很困难，学的很累。我想让大家知道的是：数据结构非常有趣，很多算法是智慧的结晶，我希望大家在学习数据结构的过程是一种愉悦的心情感受。因此我开创了《数据结构》专栏，在这里我将把数据结构内容以有趣易懂的方式展现给大家。
1.算法 什么是算法呢？算法是描述解决问题的方法。 算法一词最早出现在波斯数学家阿勒•花刺子密在公元825年（相当于我们的唐朝时代）所写的《印度数字算术》。如今普遍认可的算法的定义是：算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。算法是数据结构的基础，用于操作和组织数据的各种方法和技巧。算法可以描述为一串指令，用于在有限时间内执行给定任务。在数据结构中，算法用于操作和处理不同类型的数据，例如数组、链表、树等。算法的设计和实现是数据结构的关键组成部分，可以通过选择合适的算法来提高代码的效率和性能。
2.算法的特性 算法具有五个基本特性：输入、输出、有穷性、确定性和可执行性。
2.1输入和输出 输入输出特性比较容易理解，输入是指算法的初始数据，输出是指算法运行结束后的结果。算法的输入和输出是比较重要的两个特性，算法的输入可以是各种不同类型的数据，例如数字、字符、布尔值、数组、链表等等。输入的特性决定了算法对数据的处理方式。有些算法只接受特定类型的输入，而有些算法可以处理多种不同类型的输入。算法的输出也可以是各种不同类型的数据，取决于算法的具体目标。输出可以是单个值，也可以是一组值，甚至是一个数据结构。输出的特性通常与输入和算法的目标密切相关。
2.2有穷性 有穷性：指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。现实中经常会写出死循环的代码，这就是不满足有穷性。当然啦，在这里的有穷的概念并不是纯数学意义的，而是在实际应用中合理的、可以接受的“边界”。算法的有穷性是算法设计时必须考虑的重要因素之一。如果一个算法没有有穷性，即无法在有限的时间内停止执行，那么它就无法被应用于实际问题中。你说你写一个算法，计算机需要计算几十年，它也一定会结束，他就在数学的意义上是有穷了，那这样算法的意义也就不大了。
2.3确定性 确定性：算法的每一步骤都具有确定的意义，不会出现其他意义。算法在一定条件下，只有一条执行路径，相同的输入只能有唯一的输出结果。算法的每个步骤被精确定义而无歧义。在确定性算法中，每一步操作都是事先确定好的，不受随机因素的影响。这意味着，无论何时何地运行该算法，只要输入相同，输出结果也将是相同的。确定性算法的执行结果可以通过数学推导和逻辑推理来验证和预测，这使得算法的可靠性和正确性能得到保证。
2.4可行性 可行性：算法的每一步必须是可行的，也就是说，每一步都能够通过执行有限次数结束。可行性意味着算法可以转换为程序上机运行，并得到正确的结果。一个可行的算法应该具有较低的时间和空间复杂度，同时能够正确处理各种输入情况，并具备良好的可扩展性。
3.算法的效率 如何衡量一个算法的好坏呢？就比如计算斐波那契数列的代码：
long long Fib(int n) { if(n&lt;=2) return 1; return Fib(n-1)+Fib(n-2); } 斐波那契数列的递归实现方式非常简洁，但简洁一定好吗？那该如何衡量其好与坏呢？我们设计算法肯定是为了提高效率，这里的效率大都指算法在解决问题时所需的时间和空间资源的消耗。算法在编写成可执行程序后，运行时需要耗费时间资源和空间(内存)资源 。因此衡量一个算法的好坏，一般是从时间和空间两个维度来衡量的，即时间复杂度和空间复杂度。时间复杂度主要衡量一个算法的运行快慢，而空间复杂度主要衡量一个算法运行所需要的额外空间。在计算机发展的早期，计算机的存储容量很小。所以对空间复杂度很是在乎。但是经过计算机行业的迅速发展，计算机的存储容量已经达到了很高的程度。所以我们如今已经不需要再特别关注一个算法的空间复杂度。
我们在刷题时也常会看到时间复杂度和空间复杂度的限制，那么什么是时间复杂度和空间复杂度呢？
4.时间复杂度 4.1算法时间复杂度的定义 在计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。一个算法执行所耗费的时间，从理论上说，是不能算出来的，只有你把你的程序放在机器上跑起来，才能知道。但是我们需要每个算法都上机测试吗？是可以都上机测试，但是这很麻烦，所以才有了时间复杂度这个分析方式。一个算法所花费的时间与其中语句的执行次数成正比例，算法中的基本操作的执行次数，为算法的时间复杂度。即：找到某条基本语句与问题规模N之间的数学表达式，就是算出了该算法的时间复杂度。请计算一下下面代码中的++count运行了多少次：
void Func(int n) { int count=0; for(int i=0;i&lt;n;i++) { for(int j=0;i&lt;n;j++) { ++count; } } for(int k=0;k&lt;2*n;k++) { ++count; } int a=10; while(a--) { ++count; } } 函数Func的执行次数和传入的参数n形成一个函数关系：
实际中我们计算时间复杂度时，我们其实并不一定要计算精确的执行次数，而只需要大概执行次数，那么这里我们使用大O的渐进表示法。
4.2大O渐进表示法 大O符号是用于描述函数渐进行为的数学符号。推导大O阶的方法：
用常数1取代运行时间中所有加法常数。在修改后的运行次数函数中，只保留最高阶项。如果最高阶项存在且系数不是1，则去除与这个阶项相乘的系数，得到的结果就是大O阶。 上面的代码使用了大O的渐进表示法后，函数Func的时间复杂度为O（）。通过上面我们会发现大O的渐进表示法去掉了那些对结果影响不大的项，简洁明了的表示出了执行次数。另外有些算法的时间复杂度存在最好、平均和最坏情况：
最好情况：任意输入规模的最小运行次数平均情况：任意输入规模的期望运行次数最坏情况：任意输入规模的最大运行次数 在实际中一般情况关注的是算法的最坏运行情况，所以我们在一个数组中搜索一个数据时的时间复杂度为O(n)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23078971ac03ec46b8f460f74c99c8d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/311cf9672b6fd8288da81a7be27cb89d/" rel="bookmark">
			Springai入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述 1.1发展历史 1.2大模型 大模型，是指具有大规模参数和复杂计算结构的机器学习模型。这些模型通常由深度神经网络构建而成，拥有数十亿甚至数千亿个参数。其设计目的在于提高模型的表达能力和预测性能，以应对更加复杂的任务和数据；
大模型，简单来说，就是一个特别聪明、特别能干的“大脑”，这个“大脑”由很多个小小的“神经元”组成，每个“神经元”都能处理一部分信息，当这些“神经元”一起工作时，大模型就能理解并回答各种问题，或者完成各种复杂的任务。就像你有一个超级聪明的助手，它能帮你写邮件、写PPT、回答你的各种问题等等，它就像是一个上知天文，下知地理，无所不知的人；
1.3Spring AI Spring AI提供的API支持跨人工智能提供商的 聊天，文本到图像，和嵌入模型等，同时支持同步和流API选项；
1、Chat Models 聊天模型：
2、Text-to-image Models 文本到图像模型：
OpenAI with DALL-EStabilityAI 3、Transcription (audio to text) Models 转录（音频到文本）模型
OpenAI 4、Embedding Models 嵌入模型
5、Vector Store API提供了跨不同提供商的可移植性，其特点是提供了一种新颖的类似SQL的元数据过滤API，以保持可移植性；
6、用于AI模型和矢量存储的Spring Boot自动配置和启动器；（xxxx-spring-ai-starter）
7、函数调用
8、用于数据工程的ETL框架
9、广泛的参考文档、示例应用程序和研讨会/课程材料；
未来的版本将在此基础上提供对其他人工智能模型的访问，例如，谷歌刚刚发布的Gemini多模式模态，一个评估人工智能应用程序有效性的框架，更方便的API，以及帮助解决“查询/汇总我的文档”用例的功能。有关即将发布的版本的详细信息，请查看GitHub；
二、Spring AI聊天 2.1方式一String 1、建项目：创建一个Spring Boot项目；
2、加依赖：加入spring-ai-openai-spring-boot-starter依赖；
&lt;dependency&gt; &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt; &lt;artifactId&gt;spring-ai-openai-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; 3、配文件
spring: ai: openai: api-key: sk-3sfER03LDLG3SDFsdlwe283JSdw023lkrmrHDND32fmREKFD （换成你的api-key） base-url: https://api.openai.com 4.编写代码
@RestController public class ChatController { /** * spring-ai 自动装配的，可以直接注入使用 */ @Resource private OpenAiChatClient openAiChatClient; /** * 调用OpenAI的接口 * * @param msg 我们提的问题 * @return */ @RequestMapping(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/311cf9672b6fd8288da81a7be27cb89d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/378/">«</a>
	<span class="pagination__item pagination__item--current">379/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/380/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>