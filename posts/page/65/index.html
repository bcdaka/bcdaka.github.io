<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b640553f9f4e49e774af4b7921ac8909/" rel="bookmark">
			LangChain 推出 LangGraph Studio：首款用于可视化、交互和调试复杂代理应用的代理 IDE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嘿，听说了吗？Langchain最近发布了一项重大更新，他们推出了官方Agent IDE，并且免费开放了LangGraph平台。这对于AI开发者来说是个好消息，意味着我们现在有了更强大的工具来构建智能应用。
今天，我们就来分享由LangChain-ai推出的首个专为智能体开发设计的集成开发环境（IDE），它让智能体开发变得更加简单。这款工具的名字是：LangGraph Studio。
一、Langchain Agent IDE：开启AI开发新篇章
1.1 什么是Langchain Agent IDE？
Langchain Agent IDE是一款专为AI开发者设计的集成开发环境（IDE），它提供了全面的功能集合，能够简化AI代理（Agent）的开发过程。无论是初学者还是经验丰富的开发者，都能通过Agent IDE快速上手，构建出具有强大功能的智能应用。
1.2 关键特性概览
一站式开发体验：Agent IDE集成了代码编辑器、调试器、版本控制等多种工具，使得开发者可以在一个环境中完成所有开发工作。智能辅助编写：借助强大的语言模型，Agent IDE能够提供智能提示和代码补全，帮助开发者更快地编写高质量代码。多语言支持：支持Python、JavaScript等多种编程语言，满足不同开发者的偏好。调试与测试：内置调试工具，支持实时调试和单元测试，确保代码质量。 二、LangGraph Studio：构建智能应用的图形化平台
2.1 什么是LangGraph？
LangGraph Studio是Langchain推出的一款全新的图形化平台，它允许开发者通过拖拽的方式构建复杂的逻辑流，从而实现智能应用的快速搭建。无论是在自然语言处理（NLP）、机器学习（ML）还是其他AI领域，LangGraph都能极大地提高开发效率。
2.2 关键特性概览
1.可视化编辑器
LangGraph Studio 的核心特性之一就是其强大的可视化编辑器。开发者可以通过简单的拖拽操作来构建复杂的代理逻辑流，无需编写一行代码。这种直观的方式极大地降低了入门门槛，同时也让经验丰富的开发者能够更快地实现创意。
节点与连线：通过预定义的节点类型（如条件判断、函数调用等），开发者可以轻松地创建复杂的逻辑流图，直观展示数据流动路径。
自定义节点：支持创建自定义节点，以便封装特定功能或服务，提高代码复用率。
布局优化：内置布局算法，自动优化节点布局，保持逻辑清晰。
2. 实时交互式调试
传统的代理应用程序调试往往依赖于日志输出和模拟环境。而 LangGraph Studio 则引入了一种全新的调试方法 —— 实时交互式调试。用户可以在运行时直接与代理应用程序交互，观察其行为并对特定条件下的响应进行测试。这种即时反馈机制大大缩短了调试周期，提高了工作效率。
模拟数据注入：可以向代理应用程序注入模拟数据，以测试各种边界条件和异常情况。状态跟踪：实时显示代理应用程序的状态变化，帮助开发者理解程序内部的工作原理。多场景测试：支持创建多个测试场景，便于对比不同条件下的行为差异。 3. 强大的调试工具
除了交互式调试外，LangGraph Studio 还配备了一系列强大的调试工具，包括但不限于设置断点、单步执行、查看变量状态等。这些工具使得开发者能够在出现问题时迅速定位并解决问题。
断点调试：支持在任何节点设置断点，暂停执行并检查当前状态。条件断点：允许根据特定条件触发断点，减少无效等待时间。表达式监控：可以监视任意表达式的值，帮助识别逻辑错误。 4. 高度可定制性
为了满足不同应用场景的需求，LangGraph Studio 提供了高度可定制的功能。无论是调整代理的行为逻辑还是集成外部服务，开发者都可以轻松完成。此外，该平台还支持插件扩展，进一步增强了其灵活性。
插件市场：内置插件市场，可以安装和管理第三方插件，丰富功能集。API支持：提供了丰富的 API，方便开发者集成外部服务或创建自定义插件。社区支持：活跃的社区支持，开发者可以交流心得、获取帮助或贡献自己的插件。 5. 无缝云部署
开发完成后，LangGraph Studio 允许用户将代理应用程序直接部署到 LangGraph Cloud 上，简化了从开发到生产的过程。这意味着开发者无需担心后端架构或服务器配置等问题，可以专注于核心业务逻辑的实现。
一键部署：支持一键式部署至云端，无需额外配置。自动扩展：根据负载自动扩展资源，保证应用性能。监控与日志：提供详细的运行监控和日志记录，便于运维管理。 三、Langchain Agent IDE + LangGraph：强强联合，共创未来
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b640553f9f4e49e774af4b7921ac8909/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10b93af35c94444f83108425251a46b4/" rel="bookmark">
			大数据-73 Kafka 高级特性 稳定性-事务 相关配置 事务操作Java 幂等性 仅一次发送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点一下关注吧！！！非常感谢！！持续更新！！！ 目前已经更新到了： Hadoop（已更完）HDFS（已更完）MapReduce（已更完）Hive（已更完）Flume（已更完）Sqoop（已更完）Zookeeper（已更完）HBase（已更完）Redis （已更完）Kafka（正在更新… 章节内容 上节我们完成了如下内容：
Kafka 事务配置Kafka 事务语义消息定义事务概览事务组事务协调器等等 事务相关配置 BrokerConfigs transactional.id.timeout.ms：在ms中，事务协调器在生产者TranscationalId提前过期之前等待的最长时间，并且没有从该生产者TransactionalId接收到任何任务状态更新，默认是604800000（7天），这允许每周一次的生产者作业维护它们的ID。max.transaction.timeout.ms：事务允许的最大超时，如果客户端请求的事务时间超过此时间，broker将在InitPidRequest中返回InvalidTransactionTimeout错误，这可以防止客户端超时过大，从而导致用户无法从事务中包含的主题读取内容
默认值为900000（15分钟），这是消息事务需要发送的事件的保守上限transaction.state.log.replication.factor：事务状态topic的副本数量，默认值3transaction.state.log.num.partitions：事务状态主题的分区数，默认值50transaction.state.log.min.isr：事务状态主题每个分区ISR的最小数量 默认是2transaction.state.log.segement.bytes：事务状态主题的Segment大小，默认104857600字节 ProducerConfigs enbale.idempotence：开启幂等transaction.timeout.ms：事务超时时间，事务协调器在主动中止正在进行的事务之前等待生产者更新事务状态的最长时间，这个配置值将于InitPidRequest一起发送到事务协调器，如果该值大于max.transaction.timeout，在Broker中设置ms时，请求将失败，并出现InvalidTransactionTimeout错误。默认是60000，这使得交易不会阻塞下游消费超过一分钟，这在实时应用程序中通常是允许的。transactional.id：用于事务性交付的TransactionalId，这支持跨多个生产者会话的可靠性语义，因为它允许客户端确保使用相同Transaction的事务在启动任何新事务之前已经完成。如果没有提供TransactionalId，则生产者仅限于幂等交付。 ConsumerConfigs isolation.level：read_uncommitted以偏移顺序使用已提交和未提交的消息。read_commmitted仅以偏移量顺序使用非事务性消息或已提交事务性消息，为了维护偏移排序，这个设置意味着我们必须在使用者中缓冲消息，直到看到给定事务中的所有消息。 幂等性 基本流程 Kafka在引入幂等性之前，Producer向Broker发送消息，然后Broker将消息追加到消息流中后给Producer返回ACK信号值，实现流程如下：
生产中，会出现各种不确定的因素，比如在Producer在发送给Broker的时候出现网络异常。比如以下这种异常情况的出现：
上图这种情况，当Producer第一次发送消息给Broker时，Broker消息（x2,y2）追加到消息中，但是在返回ACK信号给Producer时失败了（比如网络异常）。此时，Producer端触发重试机制，将消息（x2，y2）重新发送给Broker，Broker接收到消息后，再次将该消息追加到消息流中，然后成功返回ACK信号给Producer。这样下来，消息流中就被重复追加两条相同的（x2,y2）的消息。
幂等性 保证咋消息重发的时候，消费者不会重复处理，即使在消费者收到重复消息的时候，重复处理，也要保证最终结果的一致性。
所谓幂等性，数学概念就是：f(f(x)) = f(x)，f函数表示对消费的处理
比如，银行转账，如果失败，需要重试。不管重试多少次，都要保证结果一定一致的。
幂等性实现 添加唯一Id，类似于数据库的主键，用于标记一个消息：
Kafka为了实现幂等性，它在底层设计架构中引入了Producer和SequenceNumber
ProducerID：在每个新的Producer初始化时，会被分配一个唯一的ProducerID，这个ProducerID对客户端的使用者是不可见的。SequenceNumber：对于每个ProducerID，Producer发送数据的每个Topic和Partition都对应一个0开始单调递增的SequenceNumber值。 同样的，这是一种理想状态下的发送流程。实际情况下，会有很多不确定的因素，比如Broker在发送ACK信号给Producer时出现了网络异常，导致发送失败。异常情况如下图所示：
当Producer发送消息（x2,y2）给Broker时，Broker接收到消息并将其追加到消息流中。此时，Broker返回ACK信号给Producer时，发生异常导致Producer接收ACK信号失败。对于Producer来说，会触发重试机制，将消息（x2,y2）再次发送，但是，由于引入幂等性，在每条消息中附带了PID（ProducerID）和SequenceNumber。相同的PID和SequenceNumber发送给Broker，而之前Broker缓存之前发送过的相同的消息，那么在消息流中的消息就只有一条(x2，y2)，不会出现重复发送的情况。
// 实例化⼀个Producer对象 Producer&lt;String, String&gt; producer = new KafkaProducer&lt;&gt;(props); 在 org.apache.kafka.clients.producer.iinternals.Sender 类中，在run()中有一个maybeWaitForPid()方法，用来生成一个ProducerID，实现代码如下：
private void maybeWaitForPid() { if (transactionState == null) { return; } while (!transactionState.hasPid()) { try { Node node = awaitLeastLoadedNodeReady(requestTimeout); if (node != null) { ClientResponse response = sendAndAwaitInitPidRequest(node); if (response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10b93af35c94444f83108425251a46b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2764b2ed534c0960615f93897e4c6ecf/" rel="bookmark">
			Elastic 8.15：更好的语义搜索、新的 OTel 分布、SIEM 数据导入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：来自 Elastic Brian Bergholm
今天，我们很高兴地宣布 Elastic 8.15 正式发布。
有什么新功能？ 8.15 版本包含大量新功能，包括更多工具来优化相关性、增强模型的灵活性和改进向量搜索，以及在 AI 驱动的安全分析方面的进步，使得自定义 SIEM 数据的采集在几分钟内就能完成。继将 Elastic Common Schema (ECS) 和 Universal Profiling 捐赠给 OpenTelemetry (OTel) 项目后，8.15 还包括通过 OTel 收集器分发迁移到 OTel 优先数据架构的下一个重要里程碑。各解决方案的其他亮点包括以下内容。
Elastic Search 可帮助开发人员在业界使用最广泛的向量数据库上实现 AI 搜索应用，并提供开箱即用的语义搜索和生成 AI 功能。
了解如何通过语义文本和重新排名（reranking）轻松将语义搜索融入你的搜索体验、学习排名（Learning tp Rank）和查询规则（query rules）的正式发布 (GA)、Elasticsearch inference API 的技术预览（适用于其他第三方提供商，包括 Google AI/Vertex AI、Mistral 和 Amazon Bedrock）等，请参阅 Elastic Search 亮点博客或 8.15 发行说明。 Elastic Observability 将指标、日志和跟踪转换为可操作的 IT 洞察，以统一整个数字生态系统的可观察性。
请参阅 Elastic Distribution for OpenTelemetry Collector 的技术预览、原生 OTLP 分析支持、Elastic AI Assistant 增强功能的正式发布（例如带有 Gemini 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2764b2ed534c0960615f93897e4c6ecf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31d05887b33d4aa67110b60b4e5c4f90/" rel="bookmark">
			云计算的三大服务模式：IaaS、PaaS、SaaS的深入解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数字化转型的浪潮中，云计算以其独特的灵活性、可扩展性和成本效益，正逐渐成为企业IT架构的核心。云计算提供了三种主要的服务模式，分别是基础设施即服务（IaaS）、平台即服务（PaaS）和软件即服务（SaaS）。每种模式都有其独特的价值和应用场景，为企业提供了从底层硬件资源到上层应用程序的全面解决方案，极大地促进了业务创新和效率提升。 1. 基础设施即服务（IaaS） 基础设施即服务（Infrastructure as a Service, IaaS）是云计算服务的基础层，它提供了计算、存储、网络和安全等基础IT资源的虚拟化服务。通过IaaS，用户可以按需访问和使用这些资源，无需购买和维护昂贵的硬件设备。这种模式的灵活性和可扩展性使得企业能够快速响应业务需求的变化，实现资源的动态调整，同时显著降低IT成本。
核心特点：
按需付费：用户只需为实际使用的资源付费，无需为未使用的资源支付成本。快速部署与扩展：IaaS平台支持快速部署和扩展资源，企业可以迅速响应业务高峰期或低谷期的需求变化。高可用性和灾备能力：云服务提供商通常提供多地域、多可用区的部署选项，确保数据和应用的高可用性，同时提供灾备和恢复服务。 应用场景：
弹性计算：如云服务器、容器服务，满足不同业务场景下的计算需求。存储和备份：提供云硬盘、对象存储等服务，支持海量数据存储和高效备份。网络服务：包括虚拟私有云（VPC）、负载均衡、内容分发网络（CDN）等，实现网络资源的灵活配置和管理。安全服务：提供防火墙、入侵检测和防御系统（IDS/IPS）、数据加密等服务，保障云上资源的安全。 2. 平台即服务（PaaS） 平台即服务（Platform as a Service, PaaS）在IaaS的基础上进一步封装，为开发者提供了一个完整的应用开发和部署环境，包括操作系统、数据库、中间件、开发工具等。PaaS使得开发者可以专注于应用程序的开发和创新，而无需关心底层基础设施的管理和维护，从而极大地提高了开发效率和降低了运维成本。
核心特点：
开发工具和框架：提供集成的开发环境（IDE）、版本控制、代码管理等工具，支持多种开发语言和框架。自动化部署和运维：支持自动化构建、测试、部署和监控，实现持续集成和持续部署（CI/CD）。多租户架构：通过资源隔离和共享，PaaS可以为多个用户提供高效、安全的服务。 应用场景：
应用程序开发与测试：为开发者提供全面的开发工具和测试环境，加速应用程序的开发周期。数据库和中间件服务：提供数据库即服务（DBaaS）、消息队列、缓存服务等，简化应用架构和提高性能。移动和Web应用程序：提供针对移动和Web应用的优化服务，包括API管理、数据同步、推送通知等。 3. 软件即服务（SaaS） 软件即服务（Software as a Service, SaaS）是云计算服务的最高层，它通过互联网提供软件应用程序的使用，用户无需安装和维护软件，只需通过网络访问即可使用。SaaS模式下的软件通常具有多租户架构，能够为大量用户提供服务，同时保持较低的运营成本和较高的可用性。
核心特点：
按需使用：用户可以根据实际需求使用软件服务，无需预先购买软件许可证。自动升级和维护：云服务提供商负责软件的升级、补丁和维护，确保用户始终使用最新的软件版本。多租户架构：通过资源共享和隔离，SaaS可以为多个用户提供高效、安全的服务。 应用场景：
办公和协作工具：如在线文档编辑、邮件服务、日历和会议工具，支持远程工作和团队协作。客户关系管理（CRM）和企业资源规划（ERP）：提供在线的CRM和ERP解决方案，帮助企业管理和优化销售、营销和业务流程。数据分析和业务智能：SaaS提供商可以提供大数据分析和业务智能工具，帮助企业从海量数据中挖掘价值，支持决策制定。 结语 IaaS、PaaS和SaaS作为云计算的三大服务模式，各自满足了企业不同层次的业务需求，从基础设施资源的灵活使用到应用程序的高效开发，再到最终用户的便捷服务，构成了云计算生态系统的完整服务链。通过灵活地选择和组合这些服务，企业能够构建高效、灵活和成本效益高的IT基础设施，加速数字化转型的步伐，实现业务的持续创新和增长。在云计算的推动下，企业不仅能够提升业务效率，还能快速响应市场变化，抓住新的业务机会，为未来的发展奠定坚实的基础。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a47289f774a2d03dd61f50c9715eb84/" rel="bookmark">
			GPT-5：未来已来，你准备好了吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GPT-5：未来已来，你准备好了吗？
在人工智能的浩瀚星空中，自然语言处理（NLP）技术如同璀璨星辰，不断引领着技术革新的浪潮。而在这股浪潮中，OpenAI的GPT（Generative Pre-trained Transformer）系列模型无疑是最为耀眼的明星之一。随着GPT-3的横空出世，其强大的文本生成能力和广泛的应用前景震撼了整个科技界。如今，当我们的目光聚焦于即将到来的GPT-5时，不禁要问：未来已来，我们真的准备好了吗？
一、GPT系列的前世今生 GPT-1：初探生成式预训练 GPT-1是GPT系列的开山之作，于2018年由OpenAI推出。它采用了Transformer架构中的解码器部分，通过大规模无监督语料库的预训练，学会了丰富的语言知识和上下文理解能力。GPT-1的出现，标志着生成式预训练语言模型（Generative Pre-trained Language Model）时代的开启，为后续的模型发展奠定了坚实基础。
GPT-2：规模与能力的飞跃 GPT-2在GPT-1的基础上进行了显著扩展，不仅增大了模型规模，还改进了训练策略，使得其生成文本的质量和多样性有了质的飞跃。GPT-2的出现，让人们对生成式语言模型的能力有了全新的认识，同时也引发了关于模型安全、伦理和社会影响的广泛讨论。
GPT-3：颠覆性的存在 如果说GPT-1和GPT-2是探索与尝试，那么GPT-3无疑是颠覆性的存在。GPT-3拥有惊人的1750亿参数，是迄今为止最大的语言模型之一。其强大的文本生成能力、零样本学习和少样本学习能力，让GPT-3能够在各种NLP任务中展现出卓越的性能，从文本创作到知识问答，从代码编写到聊天对话，几乎无所不能。GPT-3的出现，不仅推动了NLP技术的快速发展，也激发了人们对未来AI应用的无限遐想。
二、GPT-5：未来的展望与挑战 规模与能力的极限探索 随着计算能力和数据资源的不断提升，GPT-5在模型规模上无疑将再次实现飞跃。更大的模型意味着更强的表达能力和更丰富的知识库，这将使GPT-5在文本生成、知识推理、情感分析等方面的能力得到进一步提升。然而，模型规模的扩大也带来了诸多挑战，如训练成本高昂、能耗巨大、计算资源稀缺等。如何在保证模型性能的同时，降低训练成本和环境影响，是GPT-5需要面对的重要问题。
技术创新的持续推动 GPT-5不仅在规模上会有所突破，更可能在技术创新上带来新的飞跃。例如，通过引入更先进的算法和架构，如注意力机制的改进、多模态融合、知识图谱的整合等，进一步提升模型的智能化水平和泛化能力。此外，GPT-5还可能在可解释性、鲁棒性、隐私保护等方面取得重要进展，以更好地满足实际应用的需求和法规要求。
应用场景的广泛拓展 随着GPT-5能力的不断提升，其应用场景也将得到广泛拓展。在教育领域，GPT-5可以为学生提供个性化的学习资源和辅导服务；在医疗领域，它可以帮助医生进行病例分析、药物推荐等工作；在金融领域，GPT-5可以辅助进行风险评估、投资策略制定等决策支持。此外，GPT-5还可能在创意产业、法律服务、科研支持等多个领域发挥重要作用，推动各行各业的智能化转型。
伦理与社会的深刻影响 GPT-5的出现，无疑将对伦理、法律、社会等方面产生深远影响。一方面，GPT-5的强大能力将为社会带来巨大便利和价值；另一方面，其潜在的滥用风险也不容忽视。例如，恶意用户可能利用GPT-5生成虚假信息、进行网络诈骗等行为；同时，GPT-5的广泛应用也可能加剧就业市场的竞争和不平等问题。因此，在推动GPT-5发展的同时，我们也需要加强监管和引导，确保其健康、可持续地发展。
三、我们准备好了吗？ 面对即将到来的GPT-5，我们是否已经做好了充分的准备？这不仅是一个技术问题，更是一个涉及伦理、法律、社会等多个层面的复杂问题。
技术层面 从技术层面来看，我们需要不断提升计算能力和数据存储能力，以支持GPT-5等大规模模型的训练和推理。同时，我们还需要加强算法和架构的创新研究，以应对模型规模扩大带来的挑战。此外，我们还需要加强模型的可解释性、鲁棒性和隐私保护等方面的研究，以确保模型的可靠性和安全性。
伦理与法律层面 在伦理与法律层面，我们需要加强对GPT-5等AI技术的监管和引导。一方面，我们需要制定和完善相关法律法规和政策标准，明确AI技术的使用范围和限制条件；另一方面，我们还需要加强伦理教育和宣传引导工作，提高公众对AI技术的认识和理解水平。同时，我们还需要建立健全AI技术的评估机制和问责机制，以确保其健康、可持续地发展。
社会层面 在社会层面，GPT-5的到来将深刻影响我们的工作、学习和生活方式，要求我们做出相应的调整和准备。
教育与培训 随着GPT-5等AI技术的普及，许多传统行业和职业将面临转型或消失的风险。这意味着我们需要不断更新自己的知识和技能，以适应新的就业市场需求。教育系统需要更加灵活地调整课程设置和教学内容，注重培养学生的创新思维、批判性思维和解决问题的能力，而非仅仅传授书本知识。同时，职业培训将成为更加重要的领域，帮助人们快速掌握新技能，适应职场变化。
就业市场 GPT-5的广泛应用将可能引发就业市场的结构性变革。一方面，它可能会取代一些低技能、重复性高的工作岗位，导致部分人群失业；另一方面，它也将创造新的就业机会，特别是在AI技术、数据分析、创意设计等领域。因此，我们需要关注就业市场的动态变化，及时调整自己的职业规划和发展方向。政府和企业也需要采取措施，为受影响的劳动者提供转岗培训和再就业支持。
社会结构与人际关系 GPT-5等AI技术的发展还可能对社会结构和人际关系产生影响。随着智能机器人和虚拟助手的普及，人们与机器的交流将越来越多，而与人的面对面交流可能会减少。这可能导致社交技能的退化和社会关系的疏离。因此，我们需要重视社交技能的培养和人际交往的重要性，保持与他人的良好沟通和互动。
文化与价值观 GPT-5等AI技术的发展还将对文化和价值观产生深远影响。随着信息传播的速度和广度的增加，不同文化之间的交流和融合将更加频繁。这有助于促进文化的多样性和包容性，但也可能引发文化冲突和价值观的碰撞。因此，我们需要加强文化教育和价值观引导工作，培养人们的文化自觉和文化自信，尊重不同文化的差异和多样性。
结论 GPT-5作为未来AI技术的代表之一，其出现将带来一系列深刻的变化和挑战。我们需要从技术、伦理、法律和社会等多个层面做好准备，以应对这些变化和挑战。同时，我们也需要保持开放的心态和积极的态度，充分利用GPT-5等AI技术带来的机遇和优势，推动社会的进步和发展。未来已来，让我们携手共进，迎接更加美好的明天。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad0a3c0447b0531e57584f9255b0671e/" rel="bookmark">
			Flink-DataWorks第四部分：数据同步（第60天）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 2.4.2 DataStudio侧实时同步
2.4.3 数据集成侧同步任务
文章目录 系列文章目录前言2.4.2 DataStudio侧实时同步2.4.3 数据集成侧同步任务 前言 本文主要详解了DataWorks的数据同步，为第四部分：
由于篇幅过长，分章节进行发布。
后续：
 数据开发
2.4.2 DataStudio侧实时同步 DataWorks为用户提供的实时数据同步功能，方便用户使用单表或整库同步方式，将源端数据库中部分或全部表的数据变化实时同步至目标数据库中，实现目标库实时保持和源库的数据对应。
使用限制：
 实时同步不支持在数据开发界面运行任务，用户需要保存、提交实时同步节点后，在生产环境运维中心运行该节点。
 实时同步仅支持运行在独享数据集成资源组上。
 实时同步任务不支持同步视图。
 目前支持的同步方式有：
步骤一：创建实时同步节点
（1）创建实时同步节点
可以通过以下两种方式创建实时同步节点。
 方式一：展开业务流程，右键单击数据集成 &gt; 新建节点 &gt; 实时同步。
 方式二：双击业务流程名称，将数据集成目录下的实时同步节点直接拖拽至右侧业务流程编辑面板。
（2）在新建节点对话框中，配置各项参数
同步方式设置为数据库变更数据同步到MaxCompute
路径设置为业务流程/test/数据集成
名称设置为stream_data_integration
步骤二：配置实时同步任务
（1）设置同步来源和规则
设置类型为MySQL,数据源设置为rdsmysql
选择同步的源表，这里勾选student_list表，然后添加到右侧
设置表（库名映射规则）：设置表(表(库)名映射规则支持正则表达式转换，比如需要将名称为 “table_01”，“table_02”，“table_03” 同步到一张叫 “my_table” 的表，可以配置正则表名转换规则：源：table.* &gt; 目标 my_table)名映射规则
因为这里是单表采集，所以无需设置
点击下一步
（2）设置目标表
目标MaxCompute数据源设置为odps_first
写入模式为实时直接写增量表
时间自动分区设置：分区表
点击编辑，修改分区间隔为天
刷新源表和MaxCompute表映射
然后点击下一步
（3）因为是新表，所以需要自动建表，点击开始建表
（4）设置表粒度同步规则
点击配置DML，可以设置插入、更新、删除的策略，是选择还是正常处理
一般选择正常处理即可，点击下一步
（5）DDL消息处理规则
对于关系型数据的实时同步，其原始实时信息会包含DDL操作，此处可以设置针对于这些DDL消息同步到目标表时的操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad0a3c0447b0531e57584f9255b0671e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0769407782573016902bf4aa5a820cf/" rel="bookmark">
			【Web开发手礼】探索Web开发的秘密（十八）-Vue2（4）部门管理页面、路由、打包部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要介绍了部门管理页面、路由、打包部署！！！
文章目录
前言
部门管理页面
Vue路由
打包部署
打包
部署
总结
前言 主要介绍了部门管理页面、路由、打包部署！！！
部门管理页面 &lt;template&gt; &lt;div&gt; &lt;el-container style="height: 700px; border: 1px solid #eee"&gt; &lt;el-header style="font-size: 40px; background-color: rgb(238, 241, 246)"&gt;tlias：智能辅助学习系统&lt;/el-header&gt; &lt;el-container&gt; &lt;el-aside width="200px"&gt; &lt;el-menu :default-openeds="['1', '3']"&gt; &lt;el-submenu index="1"&gt; &lt;template slot="title"&gt;&lt;i class="el-icon-message"&gt;&lt;/i&gt;系统信息管理&lt;/template&gt; &lt;el-menu-item index="1-1"&gt; &lt;router-link to="/dept"&gt;部门管理&lt;/router-link&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index="1-2"&gt; &lt;router-link to="/emp"&gt;员工管理&lt;/router-link&gt; &lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt; &lt;/el-aside&gt; &lt;el-main&gt; &lt;el-table :data="tableData" style="width: 100%"&gt; &lt;el-table-column prop="name" label="名称" width="180"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="updatetime" label="最后操作时间" width="210"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="operate" label="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0769407782573016902bf4aa5a820cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18f2f5f8eb053e9387612006d043b100/" rel="bookmark">
			C 循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C 循环 在C编程语言中，循环是一种控制结构，它允许我们重复执行一段代码多次。这是编程中非常基础且强大的功能，广泛应用于各种算法和数据处理的场景中。本文将详细介绍C语言中的循环概念，包括不同类型的循环语句及其使用方法。
1. while 循环 while 循环是C语言中最基本的循环类型。它重复执行一个目标语句，直到给定的条件为假。其基本语法如下：
while (condition) { // 代码块 } 在这里，condition 是一个表达式，它会在每次循环开始前被评估。如果表达式为真（非零），则执行循环体内的代码。一旦表达式为假（零），循环结束。
示例 #include &lt;stdio.h&gt; int main() { int i = 0; while (i &lt; 5) { printf("%d\n", i); i++; } return 0; } 在这个例子中，循环会一直执行，直到 i 的值达到5。
2. do-while 循环 do-while 循环与 while 循环类似，但有一点关键的区别：do-while 循环至少会执行一次循环体，然后再检查条件。其语法如下：
do { // 代码块 } while (condition); 示例 #include &lt;stdio.h&gt; int main() { int i = 0; do { printf("%d\n", i); i++; } while (i &lt; 5); return 0; } 在这个例子中，即使 i 的初始值不满足条件，循环体也会被执行一次。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18f2f5f8eb053e9387612006d043b100/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58a78756456ef60cf25d752059a50b56/" rel="bookmark">
			如何在 VPS 上安装 Express（Node.js 框架）并设置 Socket.io
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站。
本文将学到什么 如何使用 Node Version Manager（NVM）安装 NodeJS 0.10.16如何安装 NodeJS 的 Express web 应用程序框架如何设置一个简单的 Express 项目如何在 Express 中设置 socket.io实时向客户端发送简单消息如何使用客户端 JavaScript 监听消息 步骤 1：设置 NodeJS 注意：如果您已经知道已安装了 NodeJS v0.10.16，则可以跳过此步骤
Node Version Manager（NVM）是一个帮助在 Linux 机器上安装各种 NodeJS 版本的工具。为了使用 NVM，请确保已安装 git 和 curl。
使用 SSH 连接到您的 VPS（droplet）。
如果您尚未安装这些软件，请使用系统的软件包管理器进行安装。例如，在 Ubuntu 或 Debian 上，您可以运行：
``` sudo apt-get install curl git ``` 现在，您需要运行 NVM 安装脚本：
curl https://raw.github.com/creationix/nvm/master/install.sh | sh 重要：您现在必须注销并使用 SSH 重新连接到您的服务器。
通过在终端中输入 nvm 来测试 nvm 命令是否有效。如果没有收到 command not found 错误，则已正确设置了 NVM。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58a78756456ef60cf25d752059a50b56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/496a4c2fe26c172e254851c4024ddf1c/" rel="bookmark">
			[Qt][信号与槽][下]详细讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.自定义信号和槽1.基本语法2.带参数的信号和槽 2.信号与槽的连接方式0.信号和槽存在的意义？1.一对一2.一对多3.多对一 3.信号和槽的其他说明1.信号与槽的断开2.使用Lambda表达式定义槽函数3.信号与槽的优缺点 1.自定义信号和槽 1.基本语法 在Qt中，允许⾃定义信号的发送⽅以及接收⽅，即可以⾃定义信号函数和槽函数⾃定义信号函数书写规范 ⾃定义信号函数必须写到"signals"下返回值为void，只需要声明，不需要实现可以有参数，可以发⽣重载 ⾃定义槽函数书写规范 早期的Qt版本要求槽函数必须写到"public slots"下现在⾼级版本的Qt允许写到类的 “public” 作⽤域中或者全局下返回值为void，需要声明，也需要实现可以有参数，可以发⽣重载 发送自定义信号： 使⽤"emit"关键字发送信号，"emit"是⼀个空的宏"emit"其实是可选的，没有什么含义，只是为了提醒开发⼈员 即：即使不写emit，信号也能发出去但是建议实际开发中，加上emit，代码可读性高 举例：emit MySignal(); 2.带参数的信号和槽 Qt的信号和槽也⽀持带有参数，同时也可以⽀持重载要求：信号函数的参数列表要和对应连接的槽函数列表一致 此时信号触发，调⽤槽函数的时候，信号函数中的实参就能够被传递到槽函数的形参当中通过这样的机制，就可以让信号给槽传递数据了 实际上，参数列表一致主要是要求类型一致，个数如果不一样也可以 但是要求信号的参数的个数必须要比槽的参数的个数多 个数不一致，槽函数会按照参数顺序，拿到信号的前N个参数确保参数的每个参数都是有值的 为什么允许信号的参数比槽的参数多呢？ 一个槽函数，可能会绑定多个信号 如果严格要求参数一致，就意味着信号绑定到槽的要求变高了 这样的规则下，允许信号和槽之间的绑定更灵活了 2.信号与槽的连接方式 0.信号和槽存在的意义？ Qt信号槽connect这个机制，设想很美好 解耦合：把触发用户操作的空间和处理对应用户的操作逻辑解耦合"多对多"效果 &lt;– 一个信号，可以connect到多个槽函数上一个槽函数，也可以被多个信号connect Qt引入信号槽最本质的初心：让信号和槽之间按照"多对多"的方式进行关联 实际上，很多时候，“多对多”这件事，其实是个"伪需求"，实际开发很少会用到 1.一对一 一个信号连接一个槽
一个信号连接另一个信号
2.一对多 一个信号连接多个槽
3.多对一 多个信号连接一个槽函数
3.信号和槽的其他说明 1.信号与槽的断开 使用disconnect()即可断开连接，用法和connect()基本一致说明： 大部分情况下，把信号和槽连上之后，就不必关了主动断开往往是为了把信号重新绑定到另一个槽函数上 2.使用Lambda表达式定义槽函数 早期版本的Qt，若要使⽤Lambda表达式，要在".pro"⽂件中添加： CONFIG += C++11Qt5以上的版本⽆需⼿动添加，在新建项⽬时会⾃动添加示例：正常使用connect(btn, &amp;QPushButton::clicked, this, [=](){ this-&gt;close(); }); 特别示例：当"connect()"第三个参数为"this"时，第四个参数使⽤Lambda表达式时，可以省略掉第三个参数的thisconnect(btn, &amp;QPushButton::clicked, [=](){ this-&gt;close(); }); 3.信号与槽的优缺点 优点：松散耦合 Qt的信号槽机制保证了信号与槽函数的调⽤ 信号发送者不需要知道发出的信号被哪个对象的槽函数接收槽函数也不需要知道哪些信号关联了⾃⼰， ⽀持信号槽机制的类或者⽗类必须继承于QObject类 缺点：效率较低 与回调函数相⽐，信号和槽稍微慢⼀些，因为它们提供了更⾼的灵活性，尽管在实际应⽤程序中差别不⼤通过信号调⽤的槽函数⽐直接调⽤的速度慢约10倍，这是定位信号的接收对象所需的开销 遍历所有关联编组/解组传递的参数多线程时，信号可能需要排队 这种调⽤速度对性能要求不是⾮常⾼的场景是可以忽略的，是可以满⾜绝⼤部分场景⼀个客⼾端程序中，最慢的环节往往是"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/496a4c2fe26c172e254851c4024ddf1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ddf2962ef9574add3479ff9373b1e3f/" rel="bookmark">
			【Android Studio】Webview 内核升级得三种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Android Studio】Webview 内核升级得三种方法 前言X5 腾讯组件crosswalk开源项目webview升级加载的内核（完美解决）总结 前言 在APP 中进行网页加载，一般采用原生自带的Webview 组件，但在需要加载高版本网页的时候，有时候会遇到加载失败的情况，究其原因主要是内核版本太低，导致加载失败。该组件使用的内核在Android 4.4 （API 19）前 ，主要用得是webkit 的内核；Android 4.4后，直接使用的是Chrome内核。目前Chrome内核已经到了120+，时常会遇到问题，谷歌浏览器可以正常加载网页，但内嵌网页加载就是不行。因此，基于这种情况，考虑进行Webview 组件内核的升级。
可用于检测内核版本的网址： https://liulanmi.com/labs/core.html
关于内核升级，目前主要有3种方法 ：
用 X5 腾讯组件，替换Webview 加载网页用intel 的crosswalk开源项目在Webview 基础上升级加载的内核 X5 腾讯组件 它跟webview 很像，在进行布局构建时，组件选择 com.tencent.smtt.sdk.WebView ，然后其余方法基本使用跟webview 一样。在腾讯TBS开发指引 里面有很清楚的介绍，而且还可以下载最新的SDK。
&lt;com.tencent.smtt.sdk.WebView android:id="@+id/web" android:layout_width="match_parent" android:layout_height="match_parent" android:fitsSystemWindows="true" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt; 但是运行后会发现，依旧无法加载网页，虽然导入了 SDK 库，但无法进行内核下载，故无法使用。直接访问说明中的内核下载连接，不能访问。在网上找了一圈，是由于X5内核开始收费了，所以该方法无法解决问题。
crosswalk开源项目 用这个方案，一开头就碰到问题，crosswalk的官方网站不能进了，那么库也就不能下，刚好碰到Intel 服务器崩了，我都怀疑是不是因为这个原因。后来到是在CSDN上下载了 支持ARM 和X86 的 crosswalk-23.53.589.4.aar ，但导入后，运行是正常了，但显示内核版本更低了，离要求的远远达不到。后来查看了原因，原来是这个项目早就停了…
&lt;org.xwalk.core.XWalkView android:layout_width="match_parent" android:layout_height="match_parent" android:id="@+id/web"/&gt; 而且这边发现原生的都比它高，当然也有可能跟加载的crosswalk-23.53.589.4.aar版本低有关系吧，由于无法进官网，导致这个也无法确定原因。
webview升级加载的内核（完美解决） 这个只能说真得是强得离谱，直接用外部下载的内核去进行webview 替换，然后每次初始化内核时，进行加载。而且可以选择arm 或者x86 ，内核版本目前都是120+的，很舒服。webview 使用还是跟之前的一模一样，只是加了内核升级这一过程。
&lt;WebView android:id="@+id/webview" android:layout_width="match_parent" android:layout_height="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ddf2962ef9574add3479ff9373b1e3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53b8cef0313c8ac5f4583756d9c7f073/" rel="bookmark">
			【大模型从入门到精通13】openAI API 构建和评估大型语言模型（LLM）应用1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 构建和评估大型语言模型（LLM）应用开发性能评估指标从开发到部署高风险应用LLM应用开发的最佳实践和建议从小处着手快速迭代自动化测试根据应用需求定制评估考虑伦理影响 构建和评估大型语言模型（LLM）应用 开发和部署大型语言模型（LLM）应用对研究人员和开发者来说带来了独特的挑战和机遇。随着这些应用变得越来越复杂和具有影响力，准确评估其输出的重要性不容忽视。本章深入探讨了评估LLM输出的关键方面，重点关注于开发性能评估指标、从开发到部署的转变，以及高风险应用所需的特殊考虑。
评估LLM应用的输出对于了解它们的有效性并确保达到预定目标至关重要。这一评估过程涉及定性和定量评估相结合的设计，旨在衡量应用在各个维度上的表现。
开发性能评估指标 开发稳健的性能评估指标是评价过程的基础。这些指标为评估LLM应用如何达成其目标提供了定量依据。平均准确率，例如，提供了一个简单的方法来衡量应用产生正确输出的能力。然而，根据应用的目标，开发者可能需要运用一系列的指标，包括精确度、召回率、F1分数和用户满意度评分等。
这些指标服务于多个目的：它们不仅促进了对应用效果的初步评估，还指导了持续的开发工作。通过识别应用表现不佳的领域，开发者可以针对性地改进特定方面。此外，性能指标使利益相关者能够就应用的部署及其潜在的应用领域做出明智的决策。
从开发到部署 从开发到部署的过程是迭代性的，需要持续精炼LLM应用。最初，开发者可能会使用相对简单的提示集和有限的开发集来原型化应用。这一初期阶段着重于建立一个功能性的基线并识别明显的不足之处。
随着开发的进展，系统的复杂度增加。开发者扩展提示范围，纳入更大和更多样化的开发集，并引入更复杂的评估指标。这一迭代过程旨在在开发努力和应用性能之间达到最优平衡。重要的是要认识到，并非每个应用都需要达到完美才能有用或有效。在很多情况下，只要应用高效地满足其核心目标，即使存在一些局限性也能提供显著的价值。
高风险应用 当LLM应用被部署在高风险场景中——比如医疗保健、法律咨询或财务规划——准确可靠的输出的重要性显著提高。在这种背景下，错误输出的后果可能是严重的，因此严格的评估不仅是有益的，而且是必不可少的。
对于高风险应用，评估过程必须特别彻底。开发者应该将评估扩展到标准开发集之外，包括随机抽样的验证集，必要时还包括专用的保留测试集。这种方法有助于确保模型的表现不仅平均较高，而且在广泛的情境中也是一致和可靠的。
此外，开发者必须考虑在敏感情境中部署LLM应用的伦理影响。这包括确保应用不会传播偏见或不准确信息，从而导致伤害。严格的测试，包括偏差检测和缓解策略，对于准备这些应用负责任地部署至关重要。
总之，评估LLM应用是一个多方面的过程，需要仔细考虑性能指标、迭代开发，以及对高风险应用给予特别关注。通过遵守严格的评估标准，开发者可以增强其LLM应用的可靠性、实用性和伦理完整性，确保它们对其所部署的领域做出积极贡献。
LLM应用开发的最佳实践和建议 当开发和部署大型语言模型（LLM）应用时，采用一套最佳实践和建议可以显著提升最终产品的质量、可靠性和伦理标准。下面，我们探讨开发者在整个LLM应用生命周期中应考虑的关键策略，从最初的开发到最后的部署。
从小处着手 采用模块化方法：开始时，专注于一组有限的例子或场景，这些例子或场景是应用功能的核心。这使您能够建立起坚实的基础，并在一个受控的环境中理解模型的能力和局限性。逐步扩展：随着从初始测试中获得见解，逐渐引入更多的复杂性和多样性到您的测试集中。这种机会主义的扩展让您能够根据模型的表现和您应用的独特要求定制开发过程。 快速迭代 利用LLM的灵活性：利用LLM快速迭代周期的优势，快速完善提示，调整参数，并尝试不同的方法。这种快速迭代过程对于发现最佳配置和改善模型响应至关重要。拥抱实验心态：鼓励团队内的实验文化。频繁的迭代和愿意尝试新策略可以带来创新的解决方案和显著提升应用性能。 自动化测试 开发自动化工具：实施脚本或函数，旨在自动评估模型输出与预期结果之间的匹配程度。自动化不仅简化了测试过程，还帮助更精准地识别差异和错误。集成持续测试：将自动化测试整合到您的开发管道中作为一个持续的过程。这样可以确保每次更改或更新都立即得到评估，维持一个持续反馈循环以促进不断改进。 根据应用需求定制评估 定制评估指标：选择的评估指标应该直接反映应用的目标和潜在错误的影响。这意味着选择能够准确衡量对应用成功最关键方面表现的指标。调整评估严谨性：评估过程的深度和严谨性应与应用的潜在影响和错误的严重性成比例。高风险应用需要更为严格的测试和验证协议以确保可靠性和安全性。 考虑伦理影响 进行全面的偏见和公平性分析：对于那些决策具有重大后果的应用，进行深入的偏见测试至关重要，并确保有措施到位以减轻发现的问题。这涉及到定量评估和定性评估，以理解模型输出的更广泛影响。进行伦理审查：实施一个伦理审查流程，考虑您的应用的社会、文化和个体影响。这一审查应涉及多元化的观点和专业知识，以全面评估应用的伦理维度。 遵循这些最佳实践和建议，开发者可以创建不仅表现有效的LLM应用，而且还符合伦理标准和社会期望。这些策略强调了一种深思熟虑的、迭代的开发方式的重要性，以及对公平性、可靠性和负责任创新的承诺。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c584176c6199001ad43b9a3334b92854/" rel="bookmark">
			【Day04】0基础微信小程序入门-学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 基础加强学习目标自定义组件1. 创建与引用2. 样式3. 数据、方法和属性4. 数据监听器5. 纯数据字段6. 组件生命周期6.1 created6.2 attached（使用最多）6.3 detached6.4 定义生命周期函数 7. 组件所在页面的生命周期7.1 定义使用7.2 生成随机的`RGB`颜色值 8. 插槽8.1 单个插槽8.2 多个插槽 9. 父子通信9.1 属性绑定9.2 事件绑定9.3 获取组件实例 10. behaviors 代码共享10.1 创建behavior10.2 导入并使用behavior10.3 behavior可用节点10.4 同名字段处理（了解） 小结 基础加强 学习目标 能够知道如何自定义小程序组件能够知道小程序组件中 behaviors 的作用能够知道如何安装和配置 vant-weapp 组件库能够知道如何使用 MobX 实现全局数据共享能够知道如何对小程序的 API进行 Promise 化 自定义组件 1. 创建与引用 创建组件：
创建components -&gt; test文件夹test文件夹中新建Component输入名称后回车，自动生成4个文件，后缀.js .json .wxml .wxss 为保证目录结构清晰，建议把不同的组件，存放到单独目录中。
引用组件：
全局引用：每个小程序页面中都可以使用。
//app.json "usingComponents": { "my-test":'/components/test/test' } 局部引用：组件只能在被引用的页面内使用。比如在home页面使用test组件
//home.json "usingComponents": { "my-test":'./components/test/test' } &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c584176c6199001ad43b9a3334b92854/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/743e0557089f6c33a31da4495379d246/" rel="bookmark">
			【最新】推荐7款智能AI写作论文生成网站工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当前的AI技术浪潮中，智能AI写作工具已经成为了学术研究和论文撰写的重要助手。本文将推荐7款高效且功能全面的智能AI写作论文生成网站工具，并重点介绍其中备受好评的千笔-AIPassPaPer。
1. 千笔-AIPassPaPer 千笔-AIPassPaPer是一款集多种功能于一体的智能AI写作助手，能够显著提升写作效率和创造力。它不仅具备智能选题、文献推荐、实时语法检查和论文润色等功能，还拥有强大的技术实力和良好的用户评价。
传送门：https://www.aipaperpass.com?pic=lLGw
亲身体验后，可以感受到这个工具操作简单，输出质量优异，极大提升了完成优秀学术论文的便捷性。此外，该平台利用先进的AI技术，通过用户输入的研究需求快速生成高质量的原创论文。
2. 笔灵智能工具 笔灵智能工具是一个多功能的AI服务网站，提供包括写作、绘画、对话等多种功能，适用于更多的人和场景使用。在写作功能方面，它提供了100+类型的写作模型，帮助用户完成工作总结、工作计划等各类文档的撰写。这款工具特别适合需要多方面支持的用户，能够满足不同场景下的写作需求。
3. ChatGPT 作为聊天机器人的始祖，ChatGPT不仅可以辅助学术论文的生成，还能提供创意和灵感。尽管生成的文本可能存在不准确或不完整的情况，但经过人工审核和编辑后，可以达到较高的可信度和准确性。此外，ChatGPT还可以基于已有的公文样本和需求自动生成合适的模板和草稿，为写作者提供参考和起草的起点。
4. QuillBot QuillBot是一款以先进释义和总结功能著称的工具，专为提高学生的写作和研究技能而设计。其AI功能包括重写句子和段落，同时保留原始含义，非常适合需要进行文献综述和内容总结的用户。这款工具能够帮助学生快速理解和整理大量文献资料，提高写作效率。
5. XPaper AI XPaper AI平台允许用户轻松使用AI论文生成器，快速生成高质量的论文内容。不仅如此，XPaper AI还提供详细的写作指导和结构建议，助力用户完成一份完整的学术论文。这种全方位的支持使得XPaper AI成为许多学术研究人员的首选工具。
6. AIPaperPass AIPaperPass是另一个值得推荐的AI写作工具，它能够根据题目检索全网文献生成相关专业大纲，并自动填充完整万字论文，最后搜索生成真实参考文献。这种一体化的服务大大减少了用户在文献查找和论文撰写上的时间和精力。
7. 写作助手（Writesonic） Writesonic是一款基于GPT-3技术的AI写作助手，能够帮助用户快速生成各种类型的文本内容。它特别适合需要大量创作灵感和创意输出的用户，能够迅速生成符合要求的内容并进行初步修改。
总结 以上七款智能AI写作论文生成网站工具各有特色，能够满足不同用户的需求。其中，千笔-AIPassPaPer凭借其全面的功能和高效的输出质量，成为了备受推荐的首选工具。无论是学术研究还是日常写作，这些工具都能大大提高工作效率和创作质量。希望本文的推荐能对您的写作之旅有所帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a338e06da9993772b5939069c40069a9/" rel="bookmark">
			vue.config.js 配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue.config.js 文件是 Vue CLI 项目中的全局配置文件，它允许你以 JavaScript 的形式来配置构建选项，而不是通过命令行参数或者 .vue-clirc 的 JSON 格式。
官方文档: https://cli.vuejs.org/zh/config/#全局-cli-配置
基础配置 publicPath
设置构建好的文件被部署后的公共路径。 module.exports = { publicPath: process.env.NODE_ENV === 'production' ? '/my-app/' : '/', }; outputDir
构建输出的目录，默认是 dist。 module.exports = { outputDir: 'dist', }; assetsDir
用于放置生成的静态资源 (js、css、img、fonts) 的；（项目打包之后，静态资源会放在这个文件夹下）。 module.exports = { assetsDir: "static", }; indexPath
指定生成的 index.html 的输出路径 (相对于 outputDir)。也可以是一个绝对路径。默认 'index.html' module.exports = { indexPath: "index.html", }; productionSourceMap
如果你不需要生产环境的 source map，可以将其设置为 false 以加速生产环境构建。 module.exports = { productionSourceMap: false, }; filenameHashing
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a338e06da9993772b5939069c40069a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4bc7188f7d066f350e1d01a252b9bb3/" rel="bookmark">
			vue.config.js 配置configureWebpack 和 chainWebpack 以及一些常用配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		configureWebpack 介绍 configureWebpack 允许你在 Vue CLI 项目中直接修改 Webpack 的配置。它可以通过一个对象或一个函数来实现。如果你使用的是一个函数，那么它会接收默认的 Webpack 配置作为参数，并且你应该返回一个修改过的配置对象。
用法 configureWebpack 可以是一个对象或一个函数：
作为对象： 如果 configureWebpack 是一个对象，那么这个对象将会通过 webpack-merge 合并到最终的 Webpack 配置中。这种方式适合简单的配置修改。 作为函数： 如果 configureWebpack 是一个函数，那么它会接收默认的 Webpack 配置作为参数。函数可以修改配置并不返回任何东西，也可以返回一个被克隆或修改过的配置版本。这种方式适合更复杂的配置修改，特别是当你需要基于环境变量或其他条件动态修改配置时。 常见配置示例 添加别名
const path = require("path"); module.exports = { configureWebpack: { resolve: { alias: { '@': path.resolve(__dirname, './src') } } } }; 修改输出文件名
module.exports = { configureWebpack: { output: { filename: '[name].[contenthash].js', chunkFilename: '[name].[contenthash].chunk.js' } } }; 添加 Webpack 插件
module.exports = { configureWebpack: (config) =&gt; { config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4bc7188f7d066f350e1d01a252b9bb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/849aa268a5bc8426f1442bda64429ac2/" rel="bookmark">
			【C&#43;&#43;进阶学习】第十二弹——C&#43;&#43; 异常处理：深入解析与实践应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
在C++编程语言中，异常处理是一种重要的机制，它允许程序员在运行时捕获和处理错误或异常情况。本文将详细介绍C++异常处理的相关知识点，包括异常的定义、抛出与捕获、异常处理的原则、以及在实际编程中的应用。
目录
1. 异常处理的基本概念
1.1 异常的定义
1.2 异常的抛出
1.3 异常的捕获
2. 异常的使用
2.1 异常抛出和匹配的原则
2.2 在函数调用链中异常栈的展开匹配原则
3. 异常的重新抛出
4. 异常安全
5. 异常规格
6. C++异常处理的实践应用
6.1 文件操作异常
6.2 数学运算异常
7. 总结
1. 异常处理的基本概念 在C++中，异常处理是一种机制，用于处理运行时发生的错误或异常情况。异常可以是程序执行过程中遇到的任何问题，如除以零、文件读写错误、资源未正确释放等。
1.1 异常的定义 在C++中，异常是一个对象，通常由std::exception或其派生类创建。异常对象包含了错误信息和状态，程序员可以使用这些信息来诊断和处理错误。
1.2 异常的抛出 异常的抛出使用throw关键字。程序员在代码中使用throw语句来抛出异常，这可以是显式抛出一个异常对象，也可以是抛出一个特定类型的异常（如std::runtime_error）。
throw std::runtime_error("发生了一个错误"); 1.3 异常的捕获 异常的捕获使用try...catch块。try块包含可能抛出异常的代码，而catch块用于捕获并处理这些异常。
try { // 可能抛出异常的代码 } catch (const std::exception&amp; e) { // 处理异常 std::cerr &lt;&lt; "捕获到异常: " &lt;&lt; e.what() &lt;&lt; std::endl; } 一个try后面可以跟着多个catch，因为一段代码可能出现多种异常
try { // 保护的标识代码 }catch( ExceptionName e1 ) { // catch 块 }catch( ExceptionName e2 ) { // catch 块 }catch( ExceptionName eN ) { // catch 块 } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/849aa268a5bc8426f1442bda64429ac2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e6d2927619dbd003b2a49669b831f4c/" rel="bookmark">
			[python]如何正确的安装pytorch?(详细)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、我们为什么需要安装pytorch? pytorch作为目前最主流的开源机器学习库之一，凭借庞大的社区支持和易于开发的特性，收获了一大波开发者与项目分支。像我们熟知的“GLM”，“YOLO”,"GPT-Sovits"，“Stable Diffusion”......这些开源项目中都有pytorch的身影。不管是现在的大语言模型或者是一些专用模型都已经离不开pytorch。所以，我们现在就来学习如何安装这个强大的机器学习库吧！
二、检查自己的环境 下面讲的可能需要你具有一定的计算机硬件知识，你需要通过观察自己硬件环境来决定安装哪种版本的pytorch。在下面我会讲几种情况，大家根据自己的情况来判断自己应该在下一步如何操作。
1.拥有NVIDIA的GPU（俗称N卡） 当然这样的情况是比较好的，因为你大概率能使用你的GPU来运行pytorch。当然也不是绝对的，有的较早期的显卡也不支持CUDA。CUDA是NVIDIA的GPU独有的，拥有CUDA pytorch就能把计算任务分给GPU，从而加速深度学习和模型训练。
2.拥有AMD的GPU(俗称A卡) 这种情况也就相对复杂了，因为没有CUDA所以很有可能你无法安装pytorch的GPU版本。退而求其次你只能选择CPU版本。当然这也不是绝对的，在AMD的较新系列显卡中，我们可以使用AMD的ROCM技术来模拟CUDA，从而也能实现对深度学习的加速，而且pytorch有具有一个专门的ROCM版本。当然，我这里硬件不允许所以不演示这种方案了。大家可以自行在网络上进行搜索。之前也提到了，这种方案只支持比较新的AMD的GPU如果你的GPU是6000系以下的基本都没有适配，只能考虑安装CPU版本的。
3.只拥有CPU 如果你是自己组建的多核计算服务器，或者是硬件实在不允许，那你就只能考虑pytorch的CPU版本。这个版本的pytorch只能进行最基本的深度学习，没有加速功能，这也就意味着运行模型的速度会慢许多。甚至在一些场景中只能进行推理不能进行训练。但是这也是安装最简单，并且最容易适配的方案。
通过检查自己的环境相信你已经知道了自己适合哪个版本的pytorch了，下面就让我们根据自己的环境来安装pytorch吧。
三、安装pytorch 我们在这里主要讲NVIDIA的和CPU的安装方案，AMD显卡的方案因为我的硬件限制所以没办法进行演示。下面我们分情况讨论，请大家自己前往对应的情况进行操作。
1.拥有NVIDIA的GPU 如果你有NVIDIA的GPU那么大概率可以使用这个GPU进行加速，之前我们也提到了。我们使用N卡进行加速使用的是它的CUDA，所以我们要做的第一件事当然就是安装CUDA的驱动。
虽然我们直接安装pytorch也能调用显卡进行加速，但是始终不是处于一个非常完美的状态，所以，也是为了让pytorch充分调用我们的硬件资源，我们还是先安装CUDA的驱动。不同型号的显卡它们对应的CUDA驱动也不同，我们首先就需要去查看自己的显卡所对应的CUDA版本是多少。我们这里使用“CMD”命令行进行查看。使用“WIN+R”输入CMD回车。打开如下窗口：
我的窗口我自己改了一下背景，你自己的应该就是黑的，不过不影响，都是一样的，只要确定自己打开的是“CMD命令行”就行，可以观察窗口的左上角来看自己启动的是哪一种命令行。
我们在“CMD命令行”中输入“nvidia-smi.exe”
回车以后应该就能出现下图的输出了。如果你没有得到像下图一样的输出。或者被提示命令找不到那你就要考虑一下显卡驱动是否被正常安装或者重新审查自己的硬件环境了。这一步的输出是下一步的前提，所以，使用N卡的小伙伴一定要过了这一步。
得到这些输出以后，我们可以看到打印出了许多东西。大致就有我们显卡的型号，驱动的版本和CUDA的版本。下面我们着重来看CUDA版本。
如上图，被我框出的地方可以看出这里就是我们CUDA的版本信息了。当然，这里只是我们CUDA能支持到的最新版本，我们实际安装的时候，不一定要安装这个最新版，CUDA是向下兼容的。也就是说，我这里看到的是12.3版本，其实我也可以安装11.7,10.5这些版本。我们这里只是安装CUDA的驱动。pytorch中的CUDA版本对于这个是向下兼容的。举个例子，假如你安装了12.3的CUDA驱动，那么你安装的pytorch对应到的CUDA版本可以是12.3以下的。
好了我们现在已经确定了自己的CUDA能支持到什么版本。我们可以直接去NVIDIA的官网下载对应的CUDA驱动了。官网地址：CUDA Toolkit Archive | NVIDIA Developer
进到官网以后我们可以看到如下界面：
这里有非常多的CUDA驱动版本，我们要找到我们需要的版本，刚才通过查看，我能安装的CUDA最新的驱动为12.3，所以我们这里用12.3作为演示，大家可以根据自己的CUDA版本进行选择。
当我们选择好想要的CUDA驱动以后就可以直接点击CUDA的版本号进入下载界面。
下载界面如图所示，第一步要我们选择系统，我这里是windows，所以选择第二个。选择以后它就会弹出下一个选项。
第二个选项是系统架构，只有一个选项所以我们点击这个选项。
第三个是系统的版本，我这里是windows11,所以这里我选择的11，大家根据自己的情况进行选择。
第四个选择是问是要本地安装还是网络安装，我们这里推荐使用本地安装。网络安装可能会因为网络不稳定而中断。
我们可以点击下面的下载按钮进行下载。
点击了下载以后浏览器过一会儿应该就能弹出下载了。
我们把这个安装包下载到一个我们能找到的地方。
我们这里点击这个exe文件进行安装。
双击以后，弹出一个路径选项，这是一个临时解压路径，所以就算在C盘也没关系。它后面会自己删除。
直接点击OK以后就会进入一个解压阶段。
解压结束以后，就弹出如下检测兼容性的界面。
如果这里兼容性检查不通过就要考虑是不是下载的CUDA驱动版本大于显卡支持CUDA的最大版本。
这里的协议我们选择“同意并继续”。
这里我们选择自定义并且点击“下一步”。
来到这个选择界面，这里我们只勾选“CUDA”即可。
如果你的电脑中没有安装“Visual Studio”，那就点击CUDA旁边的加号把“Visual Studio Integration”的勾去掉。
这里也选择好以后我们继续点击“下一步”。
这里我们选择安装的位置，大家选择安装在非C盘的路径即可。我们继续点击下一步。
随后就开始安装了，我们等待安装完成。
这里它已经提醒我们安装完成了。
我们可以简单的来验证一下我们的安装。
我们打开“cmd命令”窗口，输入“nvcc -V”后回车，效果如下图：
这里输出了我们的CUDA版本信息说明我们的CUDA驱动已经安装成功了。如果你输入“nvcc -V”以后出现nvcc fatal : No input files specified; use option --help for more information，很有可能是你的V没有大写引起的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e6d2927619dbd003b2a49669b831f4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7b460e2b879acdb545149fe70e85ed6/" rel="bookmark">
			VScode的环境编译器选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按快捷键 Ctrl + Shift + P
选择即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2fa66df51357387a7b5f64891d0a4ee/" rel="bookmark">
			queue的模拟实现【C&#43;&#43;】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 全部的实现代码放在了文章末尾什么是适配器模式？准备工作包含头文件定义命名空间类的成员变量 默认成员函数emptysizefrontbackpushpop全部代码 全部的实现代码放在了文章末尾 queue的模拟实现和stack一样，采用了C++适配器模式
queue的适配器一般是deque，也可以是list
因为queue是有特殊限制的线性表【只能在队头删除，队尾插入】，所以只要是线性结构并且可以高效的实现头插和尾删的线性表，就都可以作为queue的适配器
什么是适配器模式？ 适配器模式是一种设计模式，它允许将不兼容接口的类一起工作。
适配器模式通常用于以下情况：
希望使用一个类，但其接口与其他代码不兼容。希望创建一个可重用的类，它能够将接口转换为其他接口。希望使用第三方库或遗留代码，但其接口与其他代码不兼容。 适配器模式通常包括以下三个主要部分：
目标接口（Target）：这是期望使用的接口，客户端代码只能与目标接口交互。源接口（Adaptee）：这是需要适配的类，其接口与目标接口不兼容。适配器（Adapter）：这是一个类，它实现了目标接口，并将调用转换为对源接口的调用。适配器将源接口的调用转换为目标接口的调用，使得客户端代码可以与目标接口交互。 可以类比我们生活中的家庭电源接口和笔记本电脑充电口与电源适配器，它们之间也是一种适配器关系
笔记本电脑充电口是上面提到的目标接口
家庭电源接口是上面提到的源接口
电源适配器是上面提到的适配器
笔记本电脑的充电口是不能和家庭电源接口直接连接进行充电的，因为笔记本电脑用的是直流电，而家庭电源输出的是交流电，所以要把交流电转换为直流电才能给笔记本电脑供电，而电源适配器就能做到这一点
对应了上面提到的适配器模式解决的问题：
可以将不兼容接口的类一起工作
准备工作 创建两个文件，一个头文件myqueue.hpp，一个源文件test.cpp
【因为模板的声明和定义不能分处于不同的文件中，所以把成员函数的声明和定义放在了同一个文件myqueue.hpp中】
myqueue.hpp：存放包含的头文件，命名空间的定义，成员函数和命名空间中的函数的定义
test.cpp：存放main函数，以及测试代码
包含头文件 iostream：用于输入输出
list：提供list类型的适配对象
deque: 提供deque类型的适配对象
定义命名空间 在文件myqueue.hpp中定义上一个命名空间myqueue
把queue类和它的成员函数放进命名空间封装起来，防止与包含的头文件中的函数/变量重名的冲突问题
类的成员变量 只有一个，是适配器对象，默认con是deque类型
默认成员函数 和stack类的模拟实现的时候一样
queue的四大默认成员函数：构造函数，拷贝构造函数，析构函数，赋值运算符重载，都不需要手动写，使用编译器提供的默认的即可
因为编译器给的默认的这四大成员函数，都有一个特性：
如果类的成员变量是其他类实例化的对象，调用本类的四大默认成员函数的时候，对其他类实例化的对象进行操作时就可以自动调用那个类自己的四大默认成员函数
empty 因为把queue的数据都存储在了适配器对象里面 所以判断适配器对象是否为空即可 加const是为了让const修饰的对象也能调用 bool empty()const { return _obj.empty(); } size 因为把queue的数据都存储在了适配器对象里面 所以适配器对象的size，就是queue的size 加const是为了让const修饰的对象也能调用 size_t size()const { return _obj.size(); } front 因为把queue的数据都存储在了适配器对象里面 所以适配器对象中的第一个数据，就是队头的数据 T&amp; front() { return _obj.front(); } const修饰的对象只能调用const修饰的成员函数 const T&amp; front()const { return _obj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2fa66df51357387a7b5f64891d0a4ee/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/64/">«</a>
	<span class="pagination__item pagination__item--current">65/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/66/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>