<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbff8511ec0b7927981184064db6af70/" rel="bookmark">
			使用 Android Studio 通过 MySQL 数据库实现登录、注册和注销
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言
在 Android 应用程序中实现用户认证至关重要，因为它可以保护用户数据并提供个性化的体验。本文将指导你如何使用 Android Studio 通过 MySQL 数据库实现登录、注册和注销功能。
先决条件
安装 Android Studio具有 MySQL 数据库的服务器了解 Java 和 XML 步骤 1：数据库连接
按下 Win+R 打开“运行”对话框。输入 mysql -h localhost -u root -p，然后按 Enter。系统会提示你输入密码。输入你设置的 MySQL root 用户密码。登录成功后，输入以下命令更新用户权限： USE mysql; UPDATE user SET host = '%' WHERE user = 'root'; FLUSH PRIVILEGES; 步骤 2：创建数据库和表及Android Studio 配置
在 Navicat 中创建数据库和表（如果没有连接）
步骤 1：连接到 MySQL 数据库服务器
打开 Navicat。单击“连接”菜单，然后选择“MySQL”。在“连接”对话框中，输入以下信息： 连接名： 输入一个连接名称，以便以后轻松识别此连接。主机： 输入 MySQL 数据库服务器的地址或主机名。端口： 输入 MySQL 数据库服务器的端口号（通常为 3306）。用户名： 输入具有创建数据库和表权限的 MySQL 用户名。密码： 输入 MySQL 用户的密码。 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbff8511ec0b7927981184064db6af70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81d3353b046e221c7f6016c6dab4155b/" rel="bookmark">
			一文带你搞懂AI前沿技术AIGC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人工智能（AI）领域的发展日新月异，而AIGC（Adversarial Instance Generation and Correction）作为其中的一项前沿技术备受关注。本文将带你深入探索AIGC，解析其背后的原理、应用场景以及未来发展趋势。
什么是AIGC？ AIGC，即对抗性实例生成与校正，是一种用于机器学习和人工智能领域的技术。它旨在通过生成对抗性实例来测试和改进机器学习模型的鲁棒性和安全性。
AIGC的原理与深度解析 AIGC技术的核心原理基于对抗性机器学习（Adversarial Machine Learning），它主要包括以下两个关键步骤：
1. 对抗性实例生成 在对抗性实例生成阶段，AIGC通过对原始数据进行微小的修改或扰动，生成能够欺骗模型的对抗性实例。这些微小的变化可能不会对人类观察者产生明显影响，但却足以让模型产生错误的预测结果。这种生成对抗性实例的过程需要深入的数学基础和对模型内部机制的理解。
2. 校正与修正 生成对抗性实例之后，接下来的关键步骤是通过这些实例来训练和测试模型，并检测模型的弱点并进行修正。这一过程包括重新训练模型、调整模型参数或结构，以提高模型的鲁棒性和安全性。在这个过程中，需要充分考虑模型的性能和安全性之间的平衡，以及对抗性实例的生成与模型校正之间的相互影响。
AIGC的应用场景 AIGC技术具有广泛的应用场景，包括但不限于以下几个方面：
安全性增强：在网络安全领域，AIGC可用于检测和防御对抗性攻击，提高系统的安全性和抵抗力。模型鲁棒性提升：在机器学习和深度学习领域，AIGC可用于改进模型的鲁棒性，使其在面对未知的数据时表现更加稳健。数据增强：在数据预处理和增强方面，AIGC可用于生成更多样化和更具挑战性的训练数据，从而提高模型的泛化能力和性能。 AIGC的未来发展趋势 随着对抗性机器学习和人工智能领域的不断发展，AIGC技术也将不断演进和完善。未来，我们可以期待以下几个方面的发展趋势：
算法优化：研究者将继续改进和优化AIGC算法，以提高对抗性实例的生成效率和模型的校正能力。应用拓展：AIGC技术将被应用于更多的领域和场景，以解决实际问题和挑战。安全性加固：随着对抗性攻击的不断演变，AIGC技术也将不断加强系统的安全性和抵抗力，以应对日益复杂的安全威胁。 通过本文的深度解析，相信读者对AIGC这一前沿技术有了更加全面和深入的了解。AIGC的发展将为AI技术的进步和应用带来新的可能性，我们期待看到它在未来的发展中发挥着越来越重要的作用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15e4e8df1bc99abef84c0ab463baaad2/" rel="bookmark">
			使用Amazon SageMaker构建高质量AI作画模型Stable Diffusion_sagemaker ai绘图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前人工智能模型可以分为两大类别，包括判别模型 (Discriminative Model) 与生成模型 (Generative Model)。判别模型根据一组输入数据，例如文本、X 射线图像或者游戏画面，经过一系列计算得到相应目标输出结果，例如单词翻译结果、X 光图像的诊断结果或游戏中下一时刻要执行的动作。判别模型可能是我们最熟悉的一类 AI 模型，其目的是在一组输入变量和目标输出之间创建映射。
而生成模型，并不会不会对输入变量计算分数或标签，而是通过学习输入和输出之间的关系生成新的数据样本，这类模型可以接受与实际值无关的向量(甚至是随机向量)，生成复杂输出，例如文本、音乐或图像。人工智能生成( Artificial Intelligence Generated Content, AIGC) 内容泛指指利用机器学习和自然语言处理技术，让计算机生成人类可理解的文本、音频、图像等内容，主要由深度学习算法和神经网络构成，可以通过学习大量的数据来模拟人类的思维和创造力，从而产生高质量的内容。下图是使用 stable diffusion 模型生成的图像，可以看出生成的图像不仅具有很高的质量，同时能够很好的契合给定的输入描述。
AIGC 通过机器学习方法从原始数据中学习数据特征，进而生成全新的、原创的数据，这些数据与训练数据保持相似，而非简单复制原始数据。AIGC 已经取得了重大进展，并在各个领域得到广泛应用：
内容创作：可以辅助创作者完成图画、文章、小说、音乐等内容的创作设计：可以帮助设计师进行平面设计、UI 设计等游戏：可以生成游戏中的角色、道具等元素视频制作：可以生成特效、动画等内容智能客服：可以生成自然语言对话，实现智能客服等应用 AIGC 可以视为未来的战略技术，其将极大加速人工智能生成数据的速度，正在深刻改变人类社会，推动人类创作活动，包括写作、绘画、编程等，甚至也将推动科学研究，例如生成科学假设和科学现象等。AIGC 是一个快速发展的领域，将为各个行业带来革命性的变化。未来，通过学术界和工业界持续探索新的算法和技术，将进一步提高生成内容的质量和多样性。
总的来说，判别模型关注的是输入和输出之间的关系，直接预测输出结果，而生成模型则关注数据的分布，通过学习数据的统计特征来生成新的样本数据。判别模型推动了人工智能前数十年的发展，而生成模型将成为人工智能未来十年的重点发展方向。
2.2 Stable Diffusion 介绍 最近 AI 作画取得如此巨大进展的原因很大程度上可以归功于开源模型 Stable Diffusion，Stable diffusion 是一个基于潜在扩散模型 (Latent Diffusion Models, LDM) 的文图生成 (text-to-image) 模型，经过训练可以逐步对随机高斯噪声进行去噪以获得感兴趣的数据样本，该模型使用来自 LAION-5B 数据库 (LAION-5B 是目前最大、可自由访问的多模态数据集)子集的 512x512 图像进行训练，使用这个模型，可以生成包括人脸在内的任何图像。在使用 Stable Diffusion 生成高质量图像之前，我们首先介绍该模型的原理与架构，Stable Diffusion 模型架构如下图所示：
Diffusion model 相比生成对抗网络 (Generative Adversarial Network, GAN) 具有更好的图片生成效果，但由于该模型是一种自回归模型，需要反复迭代计算，因此训练和推理代价都很高，主要原因是它们在像素空间中运行，特别是在生成高分辨率图像时，需要消耗大量内存。Latent diffusion 通过在较低维度的潜空间上应用扩散过程而不是使用实际的像素空间来减少内存和计算成本，所以 Stable Diffusion 引入了 Latent diffusion 的方式来解决计算代价昂贵的问题，能够极大地减少计算复杂度，同时可以生成质量较高的图像，Latent Diffusion 的主要包括以下三个组成部分：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15e4e8df1bc99abef84c0ab463baaad2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c795726e118e10d01e74a8d108fc23f1/" rel="bookmark">
			AI大模型探索之路-训练篇5：大语言模型预训练数据准备-词元化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录🚩 AI大模型探索之路-训练篇1：大语言模型微调基础认知
AI大模型探索之路-训练篇2：大语言模型预训练基础认知
AI大模型探索之路-训练篇3：大语言模型全景解读
AI大模型探索之路-训练篇4：大语言模型训练数据集概览
文章目录 系列文章目录🚩前言一、概述二、分词的粒度三、分词器的类型四、BPE/BBPE分词五、WordPiece分词六、Unigram 分词七、分词器的选择八、各大模型的分词效果九、SentencePiece分词器使用 前言 在自然语言处理领域，大语言模型预训练数据准备是一个重要的环节。其中，词元化（Tokenization）作为预训练前期的关键步骤，旨在将原始文本分割成模型可识别和建模的词元序列，为大语言模型提供输入数据。本文将对词元化技术进行详细介绍，包括分词的粒度、分词器的类型以及各大模型的分词效果等内容。
一、概述 分词（词元化）：词元化（Tokenization）是数据预处理中的一个关键步骤，旨在将原始文本分割成模型可识别和建模的词元序列，作为大语言模型的输入数据；形成一个词汇表。
传统自然语言处理研究（如基于条件随机场的序列标注）主要使用基于词汇的分词方法，这种方法更符合人类的语言认知。然而，基于词汇的分词在某些语言（如中文分词）中可能对于相同的输入产生不同的分词结果，导致生成包含海量低频词的庞大词表，还可能存在未登录词（Out-of-vocabulary, OOV）等问题。因此，一些语言模型开始采用字符作为最小单位来分词。其中子词分词器（Subword Tokenizer）被广泛应用于基于 Transformer 的语言模型中，包括 BPE 分词、WordPiece 分词和 Unigram 分词三种常见方法。
二、分词的粒度 从分词的粒度区分，主要包括3种类型，Word 、Subword、Char
1）Word分词粒度以完整的单词为单位进行分词，能够很好地保留每个词的语义，适合上下文理解和语义分析。然而，它面临着长尾效应和稀有词问题，可能导致词汇表庞大并且出现OOV（Out-of-Vocabulary）问题。
OOV是“Out-Of-Vocabulary”的缩写，直译为“词汇表外的”，在自然语言处理中，表示的是那些在词汇表中没有的单词
2）Char分词粒度则是将文本拆分为字符级别，这样可以解决OOV问题，因为可以处理任何字符，但缺点是可能缺乏明确的语义信息，并且由于粒度过细，会增加后续处理的计算成本和时间。
3）Subword分词粒度介于Word和Char之间，旨在克服两者的缺点，同时保留语义信息并减少OOV问题的发生。Subword分词方法如BPE（Byte Pair Encoding）或WordPiece通过统计学方法切分单词为更小的有意义的单元，这使得它们在处理生僻词和缩写时更为有效。（目前使用比较广泛）
三、分词器的类型 针对Subword常用的分词器有3种：BPE 分词、WordPiece 分词和 Unigram 分词。
SentencePiece 是一个开源的分词器工具；是由谷歌开发的，旨在提供一种高效的方式来对文本进行分词，尤其适用于处理变长和不规则的文本数据。它通过训练特定领域的模型来代替预训练模型中的词表，从而更有效地处理词汇。常用的BPE、WordPiece、 Unigram分词器都支持。
四、BPE/BBPE分词 1）BPE：从字符级别开始，逐步合并最频繁连续出现的字符或字符组合，形成新的词汇单元。
2）BBPE：字节级别的 BPE（Byte-level BPE, B-BPE）是 BPE 算法的一种拓展。它将字节视为合并操作的基本符号，从而可以实现更细粒度的分割，且解决了未登录词问题。采用这种词元化方法的代表性语言模型包括 GPT-2 、BART 和 LLaMA 。
3）对于英文、拉美体系的语言来说使用BPE分词足以在可接受的词表大小下解决OOV的问题，但面对中文、日文等语言时，其稀有的字符可能会不必要的占用词汇表（词汇表要么巨大要么会OOV），因此考虑使用字节级别byte-level解决不同语言进行分词时OOV的问题。具体的，BBPE将一段文本的UTF-8编码(UTF-8保证任何语言都可以通用)中的一个字节256位不同的编码作为词表的初始化基础Subword。
例如，GPT-2 的词表大小为 50,257 ，包括 256 个字节的基本词元、一个特殊的文末词元以及通过 50,000 次合并学习到的词元。(相当于既有了BPE特性，又兼容了中文）
BBPE的优点：不会出现 OOV 的情况。不管是怎样的汉字，只要可以用字节表示，就都会存在于初始词表中。
BBPE的缺点：一个汉字由3个字节组成，一个汉字就会被切成多个token，但实际上这多个token没必要进行训练。
BPE词表构建整体流程如下：
五、WordPiece分词 1）WordPiece 分词和 BPE 分词的想法非常相似，都是通过迭代合并连续的词元，但是合并的选择标准略有不同WordPiece 分词算法并不选择最频繁的词对，而是使用下面的公式为每个词对计算分数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c795726e118e10d01e74a8d108fc23f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55f01bbade0ff45f3cc13b8547eef117/" rel="bookmark">
			用自然语言来编程GitHub Copilot；提高代码质量开源工具GPTLint；LLMs开源医学Meditron
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨ 1: GitHub Copilot Workspace 以Copilot 为中心的创新开发者环境，让开发者能用自然语言从构思到编码再到软件开发。
GitHub Copilot Workspace是一个以Copilot为中心的开发者环境，旨在使用自然语言从构思、编码到软件开发的全过程中提供帮助。它标志着开发环境的一次重大变革，通过不同的Copilot-powered代理从开始到结束提供支持，同时让开发者完全控制整个过程。
GitHub Copilot Workspace是为了降低软件开发的门槛，加速从想法到实现的过程，特别适合那些希望提升生产力、优化团队协作和利用AI技术来简化开发工作的专业和业余开发者。
地址：https://github.blog/2024-04-29-github-copilot-workspace/
✨ 2: 神秘的gpt2-chatbot 神秘的gpt2-chatbot 表现和GPT4不分上下
一个名为"gpt2-chatbot"的神秘大模型在AI社区引起了轰动，其性能被认为超越了GPT-4，引发了广泛的讨论和猜测。
有人认为"gpt2-chatbot"可能是GPT-4.5、GPT-5或者是一个真正的GPT-2模型，其输出质量和表现引发了对其真实身份的猜测和讨论。
地址：https://chat.lmsys.org/
✨ 3: GPTLint 基于大型语言模型的提高代码质量工具
GPTLint是一款基于大型语言模型（LLMs）的代码质量工具，其设计初衷是为了在代码库中强制执行更高层次的最佳实践，超越了传统的静态分析工具如eslint所能达到的水平。
GPTLint能够识别和推荐改善代码质量的做法，这些是基于抽象语法树（AST）的方法无法实现的。
GPTLint是为那些追求代码质量，特别是在执行高层次最佳实践方面不惜一切代价的开发者和团队设计的。无论是想超越传统静态分析工具的限制，还是希望在项目中引入更先进的代码审查机制，GPTLint提供了一种新颖的解决方案。
地址：https://github.com/gptlint/gptlint
✨ 4: Meditron 基于大型语言模型（LLMs）的开源医学套件
Meditron是一个基于大型语言模型（LLMs）的开源医学套件，主要包括Meditron-7B和Meditron-70B两个模型。这些模型是通过在丰富的医学领域语料上持续进行预训练，从Llama-2模型调整而来的，涵盖了精选的PubMed论文摘要、国际认可的医学指南新数据集，以及广泛的通用领域语料。
Meditron特别适用于多种医学推理任务，并且经过相关数据的微调后，其表现超越了Llama-2-70B、GPT-3.5和Flan-PaLM等先前的模型。
模型地址：https://huggingface.co/epfl-llm
Meditron提供了一个强大的工具集，旨在通过高质量的医学大语言模型支持医疗保健行业的各项需求。然而，考虑到其对安全性和适用性的限制，应谨慎使用，并在具体投入使用前进行充分测试。
地址：https://github.com/epfLLM/meditron
✨ 5: Chinese-LLaMA-Alpaca-3 一代开源大模型Llama-3开发的项目，专注于中文语言处理
该项目提供了两个核心模型：中文Llama-3基座模型和中文Llama-3-Instruct指令精调大模型。这些模型利用大规模中文数据进行增量预训练，并利用精选指令数据进行精调，以进一步提升中文语义理解和指令执行能力。
Chinese-LLaMA-Alpaca-3项目为中文自然语言处理领域的研究者和开发者提供了一个高质量的资源，可以用于教育、研究以及商业探索。无论是深入研究大模型的内部机制，还是开发实用的应用程序，该项目都提供了强有力的支持。
地址：https://github.com/ymcui/Chinese-LLaMA-Alpaca-3
更多AI工具，参考国内AiBard123，Github-AiBard123
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f22d7d3f47e3adc8c116ab6d770fc464/" rel="bookmark">
			Android14 普通应用registerReceiver注册广播报错One of RECEIVER_EXPORTED or RECEIVER_NOT_EXPORTED should be
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android14 普通应用registerReceiver注册广播报错One of RECEIVER_EXPORTED or RECEIVER_NOT_EXPORTED should be specified … 文章目录 Android14 普通应用registerReceiver注册广播报错One of RECEIVER_EXPORTED or RECEIVER_NOT_EXPORTED should be specified ...一、前言二、Google 对Android14 广播说明三、Android14 注册广播报错解决和分析1、报错示例和解决方法2、报错分析 四、其他1、Android14 registerReceiver注册广播报错总结2、Android13 开始AndroidManifest.xml里面的四大组件都是要定义exported属性的，否则会编译报错3、Context.RECEIVER_EXPORTED 和Context.RECEIVER_NOT_EXPORTED作用?4、ActivityManagerService.java 的源码 寄语：明天五一，劳动节快乐。 一、前言 Android14 普通应用注册广播registerReceiver会报错，提示需要添加一个参数RECEIVER_EXPORTED 或者 RECEIVER_NOT_EXPORTED；系统framework或者系统应用是不会报这个错误的！
这个问题比较好解决，加一个参数就行，但是网上目前没有人对这个问题今天深入分析。
本文对registerReceiver报错进行分析，具体到哪个类哪行代码报错，
分析了解后对于系统其他相关报错能有个认识，或者有分析思路。
RECEIVER_EXPORTED 表示外部应用范围，RECEIVER_NOT_EXPORTED 表示非外部应用范围，是否有作用？
二、Google 对Android14 广播说明 说明图片所示：
对于Android14 主要说明内容：
For apps targeting Build.VERSION_CODES.UPSIDE_DOWN_CAKE, either RECEIVER_EXPORTED or RECEIVER_NOT_EXPORTED must be specified if the receiver is not being registered for system broadcasts or a SecurityException will be thrown.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f22d7d3f47e3adc8c116ab6d770fc464/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1b8bcb250341da4d8e6f7c3880e2043/" rel="bookmark">
			生成式人工智能（AIGC）教学解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 近年来，伴随计算能力跃升和数据量指数级增长，以多模态巨型模型为典型代表的生成式AI技术，在全球范围内引起了广泛关注与热烈追捧。在教育、医疗、法律等众多专业领域，生成式人工智能技术的影响力日益凸显，尤其在教育领域，它不仅是提升教学工具智能化的推手，更是教育理念深层变革的催化剂。因此，唯众顺势发布《生成式人工智能教学解决方案》，通过本方案的实施，我们期望能够充分发挥生成式人工智能技术的潜力，为教育教学提供有力支撑，促进生成式人工智能与教育的深度融合，推动教学质量的全面提升。
二、方案背景与目标 近年来，以ChatGPT为代表的生成式人工智能技术的出现，更是为教育行业带来了前所未有的机遇与挑战。ChatGPT作为一种现象级应用，以其强大的内容生成能力和广泛的应用场景，迅速赢得了全球范围内的广泛关注。教育工作者们也开始深入思考：如何科学合理地利用生成式人工智能技术，为教育教学注入新的活力？它将对传统课堂教学模式产生怎样的冲击和变革？
《中国教育现代化2035》及教育部等相关部门发布的政策文件明确指出，要大力推进基于人工智能技术的智能助教、智能学伴等教学应用的发展，以提升教学质量和效率。党的二十大报告更是强调了“推进教育数字化”的战略方向，为生成式人工智能在教育领域的应用提供了有力的政策支持和指导。
生成式人工智能教学解决方案则通过生成式AI技术，如机器学习、自然语言处理、计算机视觉等，构建一个动态生成学习内容的智能教学平台。通过人机互动的对话进程，教师和学生能够共同创造出丰富多样的学习资源，包括文本、图片、音频、视频等，以重塑课程资源与教学结构。
三、方案概述 《生成式人工智能教学解决方案》通过强大的内容生成能力，为个性化教学注入新活力，从而有效提升教学质量，并培养学生的未来关键能力。本方案的核心在于，通过引入先进的生成式人工智能技术，如基于transformer架构的模型以及OpenAI的ChatGPT和GPT-4等预训练语言模型，实现师生间的高效互动和多模态内容生成。教师将能够利用这些智能工具作为教学助手，构建个性化的智能教育服务体系，以满足学生多样化的学习需求。
为了有效实施这一解决方案，我们提出了“教师行动指南”。首先，教师需要熟悉并掌握生成式人工智能大模型的使用；其次，教师应采用“3+N”模式，即熟练掌握基础工具的同时，根据教学需求选择其他合适的生成式人工智能产品。更为重要的是，教师需要提升与生成式人工智能互动的提示语设计能力，以引导学生进行深度学习，激发其批判性思维。此外，教师的智能教学领导力也是实现这一解决方案的关键。这包括持续学习新技术、洞察教学变革趋势、解决课堂问题、人机协作与提示语运用、伦理指导与学生管理，以及激发批判性与创新思维等能力。这些能力的提升，将确保生成式人工智能在教学中的合理、有效、合规应用，同时促进学生的全面发展。
我们的生成式人工智能教学解决方案将引领教学内容与方法的深刻变革。教学内容将更加注重能力培养，特别是批判性思维、创新思维和独立思考能力等关键素养。教学方法将围绕生成式探究学习和生成式作业展开，强化师生与人工智能的互动对话，鼓励深度学习、因材施教与个性化教学。
四、解决方案规划 4.1 总体规划
生成式人工智能教学解决方案旨在构建一个以智能科技为支撑的教育生态系统，该系统围绕“智慧联动、内容融合、组织优化”的核心理念，深度融合生成式AI技术，如基于Transformer架构的模型、OpenAI的ChatGPT和GPT-4等预训练语言模型，驱动教学内容、方法和评价体系的全面革新。
4.2 培养目标
在人工智能时代，生成式人工智能教学解决方案聚焦于构建一个智慧联动、内容融合与组织优化的教育生态，让每一位教师都能成为“新质生产力”，让每一位学生都能享受到定制化的学习体验。具体而言，旨在通过生成式AI技术，实现"师-机-生"的智能协同，促进教学主体间的智慧联动，不仅提升教师对职业教育知识体系的创新整合能力，而且增强学生在个性化学习路径上的自主探索与实践技能。此外，教学组织和运行机制将通过平台化与简易化的策略优化，利用先进的AI模型和算法，如RNNs、LSTMs和GPT系列，搭建灵活、高效的教学平台，打破传统教育的空间和时间限制，推动教学管理的智能化和教学评价的即时性。在这样的生态系统中，生成式人工智能作为强大的辅助工具，不仅提供定制化的学习资源和即时反馈，还通过智能问答和智慧辅导功能，帮助学生在技能训练中实现精准纠偏和深度学习，从而提升教育的针对性和个性化水平。
4.3 课程建设
生成式人工智能教学解决方案通过智能生成内容、个性化学习路径、即时反馈和资源优化分配，不仅提高了教学效率和质量，还推动了教育向更加个性化、智能化的方向迈进。
生成式AI通过与教师和学生互动，动态生成个性化的学习内容，涵盖文本、图像、音频、视频等多种形式，重塑了课程设计与教学互动的模式。在该方案中，生成式AI技术不仅在备课阶段辅助教师准备和优化教学材料，还能在课堂教学中实时响应学生需求，动态调整教学节奏与内容，实现按需学习资源的即时生成，极大增强了课堂的互动性和灵活性。
教学资源的生成不再局限于预设的材料，而是根据课堂进展和学生反馈，由AI智能分析后动态产出，这种“边教边创”的模式让教育内容更具时效性和针对性。例如，教师可以利用AI在课堂上即时生成与当前学习主题相关的实例文本、图表或视频，帮助学生深入理解知识点。同时，AI技术能够分析学生的学习行为和成效，为教师提供即时的反馈报告，帮助教师精准识别学生的学习难点和兴趣点，及时调整教学策略，真正实现以学生为中心的个性化教学。
对于学生，生成式AI技术通过智能辅导系统，根据每位学生的学习进度和理解程度，提供个性化的学习路径和即时帮助。学生在遇到难题时，能够随时获得AI的指导和解答，无论是文本解析还是编程问题，AI都能提供精准的反馈，促进自主学习和问题解决能力的提升。此外，AI的自动批改作业功能，减轻了教师负担，使教师有更多时间专注于学生个体发展和情感交流，而学生则能更快获得反馈，及时调整学习方法。
该方案还通过生成式AI技术优化在线学习体验，智能推荐系统根据学生的学习偏好和能力匹配最适合的学习资源，确保学习内容既符合学生兴趣又能有效提升学习效果。同时，AI对学习状态的持续监测，帮助老师更好地理解学生的学习状态，适时调整教学计划，促进学生全面能力的发展。
4.4 教学内容
教学内容方面，方案追求通用知识与专业技能的并重，利用生成式AI技术将教学资源多样化、个性化，它不仅增强了教学的灵活性和效率，也促进了学习体验的个性化和深度，同时为构建更加高效、包容和创新的教育生态系统提供了强大动力。
在教师端，生成式AI是备课的强大助手，能够智能生成富含创意的教学内容，如深度解析文学作品、定制化数学练习题，甚至协助创作多元艺术作品，极大丰富了课堂素材。同时，它能够模拟真实教学情境，帮助教师模拟多种教学互动，提升新手教师对教学场景的适应能力。学情分析方面，AI能够快速汇总并分析学生数据，自动生成图表直观展现学习情况，为教师提供精准的学情反馈，促进教学策略的优化。
针对学生，生成式AI是个性化的学习伙伴，根据学生的学习特点和需求，定制个性化学习路径，提供即时解答与互动式学习引导，如采用苏格拉底式的提问激发学生深度思考。在编程等实操性学习中，AI能准确指出代码错误，引导学生修正，增强其逻辑思维和问题解决能力。通过持续的个性化交互和资源推荐，不仅提升学生的学习兴趣，也促进了其综合素养的提升。
4.5 教学实践探索
生成式人工智能教学解决方案在教育领域的实践探索，正逐步展现出其独特的价值和潜力。通过深度整合进教学过程，该方案不仅优化了教学资源的生成与分发，还促进了学习方式的创新和教学模式的转型。首先，生成式AI技术如ChatGPT等，通过模拟真实教学互动，为教师提供智能化辅助工具，例如自动生成高质量的教学案例、课件和个性化习题集，以及协助进行智能备课和学情分析，帮助教师高效掌握学生学习状况，优化教学设计。同时，它还能扮演虚拟助教角色，与学生进行模拟对话，促进自主学习和深度理解，尤其是在语言学习、文学分析、编程教学等领域的应用，极大丰富了教学互动的维度。
其次，针对学生个体差异，生成式人工智能依据学生的学习进度、兴趣和能力，定制生成专属的学习路径和资源。通过智能推荐系统，提供个性化的学习材料，如定制化阅读材料、个性化问题解答、以及适应性练习题等，确保每个学生都能在最适合自己的节奏和难度下学习，有效提升学习效率和成果。利用生成式AI的多模态内容生成能力，将抽象概念具象化，如将复杂的数学公式转化为动态图像，或通过生成特定情境的视频、音频材料，增强学生的学习兴趣和理解深度。此外，通过“苏格拉底式”对话模拟，激发学生的批判性思维和问题解决能力，使学习过程更加互动和沉浸，培养学生的创新意识和高阶思维。
还有，生成式人工智能技术能自动批改作业，提供即时反馈，减轻教师负担，同时通过分析学生作业和测试数据，生成个性化的学习报告，帮助学生识别学习盲点，教师也能据此调整教学策略，实现精准教学。另外，借助生成式AI的跨领域生成能力，促进学科间知识的交叉融合，如结合艺术与科技，利用AI生成艺术作品，或在编程课程中融入AI辅助设计，使学生在实践中学习跨学科知识，增强综合应用能力。
五、方案亮点 方案以其易用性、内容多样性、高效互动性及对教学创新的促进作用，为教育领域带来了革命性的提升。首先，它提供了亲民化的学习界面，极大地降低了学习门槛，学生无需掌握复杂的软件操作技巧，便能以自然的方式与计算机进行深度交互，获取近乎标准答案的解答或解释。其次，该方案中生成式人工智能的角色多样性为教学提供了丰富的可能性，它可以充当翻译员，支持多语种交流，打破语言障碍；也可以作为写作助理，辅助学生完成从演讲稿到编程等不同类型的文本创作；更可以作为生活助手，解答学生关于心理咨询、健康顾问等方面的疑问，实现全方位的学习支持。此外，方案在知识整合和提炼方面的优势尤为明显，通过对大量训练数据的学习，能够迅速理解并总结出知识的模式和规律，为学生提供高效、精准的学习资源；它还能根据学生的学习进度和反馈，动态调整教学内容和难度，实现个性化的学习体验。最后，方案中的生成式人工智能虽然无法完全替代师生之间的面对面交流，但却可以作为重要的教学辅助工具，增强课堂互动、提升教学效果。
六、总结 生成式人工智能教学解决方案在教育领域展现出变革性的影响，它不仅重塑了传统教学模式，还极大地丰富了学习体验，为师生共创智能教育新篇章提供了强有力的支持。该方案凭借生成式AI技术的强大多模态内容生成能力，实现了教学资源的动态定制与即时互动，促进了个性化学习路径的构建，为每位学生提供了量身定制的知识探索之旅。教师借助智能助手的力量，能够高效准备课程、优化教学策略，并通过精准学情分析，实施以学生为中心的个性化教学。学生则在AI的个性化辅导下，获得即时反馈，有效提升自我学习与解决问题的能力。此外，方案还促进了教学内容的深度与广度拓展，通过模拟真实情境的互动对话、多维度的学习资源生成，以及跨学科知识的融合，激发了学生的批判性思维和创新潜能。总之，生成式人工智能教学解决方案通过其易用性、内容多样性、高效互动性，以及对教学创新的深度促进，为教育现代化铺就了一条充满活力的道路，为学生的全面发展和终身学习奠定了坚实基础，同时也为教师角色的转型与教育生态的优化开辟了广阔前景。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee37c08b5f662af7b7dfe78cd9515d13/" rel="bookmark">
			Windows系统 ElasticSearch，Kibana安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、ElasticSearch介绍
二、ElasticSearch安装
三、Elasticsearch 配置
1、编码格式设置
2、启动Elasticsearch
四、Kibana安装
五、Kibana配置
1、配置文件修改
2、启动Kinbana
结语
一、ElasticSearch介绍
Elasticsearch 是一个开源的分布式搜索和分析引擎，它基于 Apache Lucene 搜索引擎库。Elasticsearch 可以用于全文搜索、结构化搜索、分析以及实时数据聚合等功能。它被广泛应用于各种场景，包括企业搜索、日志分析、安全信息与事件管理（SIEM）、商业分析等。
国内现在有大量的公司都在使用 Elasticsearch，包括携程、滴滴、今日头条、饿了么、360安全、小米、vivo等诸多知名公司。
Elasticsearch 具有以下主要特点：
分布式：Elasticsearch 能够在多台服务器之间自动分布数据，并提供高可用性和横向扩展性。
实时性：Elasticsearch 可以快速存储、搜索和分析海量数据，并且支持实时查询和更新。
多样化的数据类型支持：Elasticsearch 支持各种数据类型，包括文本、数值、日期、地理位置等，让用户能够更灵活地进行搜索和聚合。
RESTful API：Elasticsearch 提供了基于 RESTful 风格的 API，使得用户能够使用各种编程语言和工具与其进行交互。
插件生态系统：Elasticsearch 生态系统非常丰富，拥有众多插件和工具，扩展了其功能，满足了不同用户群体的需求。
总的来说，Elasticsearch 是一个功能强大、易于使用的搜索和分析引擎，适用于各种规模和类型的应用场景。如果您需要更详细的介绍或有其他问题，请随时告诉我！我会尽力为您提供帮助。
二、ElasticSearch安装 下载地址：下载 Elastic 产品 | Elastic
进入官网后我们找到对应的下载按钮点进去之后选择对应的操作系统以及我们要安装的版本点击下载就好了。
土豆这里下载的是最新版的。下早好了之后就是下面这样的一个zip压缩包
安装的时候将这个压缩包放在我们要安装的目录下解压即可，解压之后就是这样子：
理论上来说，到这个地方之后我们的Elasticsearch就安装好了。但是还是需要测试滴，请跟我一起搞起来。
三、Elasticsearch 配置 1、编码格式设置 安装好之后我们先到config目录下找到jvm.options这个文件，打开之后在文件最后一行添加如下配置：
-Dfile.encoding=GBK 添加这个配置主要是为了保证我们启动Elasticsearch的时候控制台不会有乱码出现，完成之后我们开始启动Elasticsearch。
2、启动Elasticsearch 到Elasticsearch的安装目录下找到bin文件夹，在文件夹中找到elasticsearch.bat
小伙伴可以选择双击打开，也可以选择在当前目录下使用cmd命令行的方式打开，这一步根据自己喜好就好，土豆这里使用的是命令行的方式打开的，像这样输入elasticsearch回车就行：
因为Elasticsearch的默认端口是9200，所以在启动完成之后去浏览器输入localhost:9200测试下当前服务是否启动成功了。
但是有点尴尬哈，土豆这里在浏览器中输入一直在转圈，没有别的反应，所以我上网查了查之后发现并不是我的服务启动失败，而是没有设置密码。
有些人，没有设置密码，页面会显示输入账号密码的窗口，但也有人像我一样，什么都没有，但是别急。待我慢慢操作一番。
我们到安装目录下的config目录下找到elasticsearch.yml：
进入到yml文件中之后往下滑，我们找到下图的配置文件：
将 xpack.security.enabled 的值修改成 false 然后保存配置文件之后重启服务，重启完毕后再去浏览器去访问localhost:9200。
然后你会发现：浏览器中出现了一个json串，像这样：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee37c08b5f662af7b7dfe78cd9515d13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f407e4a6b4b3dc4c0474ece40bca785/" rel="bookmark">
			【前端系列】20种 Button 样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前端开发中，按钮（Button）是网页交互中常见的元素之一，其样式的设计直接影响着用户体验和界面美观度。本文将介绍20种不同的 Button 样式，旨在帮助前端开发者丰富按钮设计思路，提高用户界面的吸引力和可用性。
1. 默认样式 .button { background-color: #007bff; color: #fff; border: 1px solid #007bff; } 2. 扁平样式 .button { background-color: transparent; color: #007bff; border: none; } 3. 圆角样式
.button { border-radius: 5px; } 4. 阴影样式 .button { box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); } 5. 渐变样式 .button { background: linear-gradient(to right, #ff4e50, #f9d423); color: #fff; } 6. 边框样式 .button { border: 1px solid #007bff; background-color: transparent; color: #007bff; } 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f407e4a6b4b3dc4c0474ece40bca785/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c7df4bfa3b3e2934518b06af7c6f80f/" rel="bookmark">
			深入Rust标准库：必备的Rust语言高级指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💂 个人网站:【 摸鱼游戏】【神级代码资源网站】【工具大全】🤟 一站式轻松构建小程序、Web网站、移动应用：👉注册地址🤟 基于Web端打造的：👉轻量化工具创作平台💅 想寻找共同学习交流，摸鱼划水的小伙伴，请点击【全栈技术交流群】 Rust语言的兴起和流行，部分归功于其出色的安全性和性能特性，但其强大的标准库也是不可或缺的一部分。Rust标准库提供了丰富的数据结构、工具和功能，使得开发者能够高效地构建各种类型的应用程序。本文将深入探讨Rust标准库的各个方面，介绍其常用模块、重要数据结构以及一些高级功能，帮助读者更好地理解和应用Rust语言。
1. Rust标准库概述 Rust标准库是Rust语言的核心组成部分，提供了丰富的功能和工具，包括数据结构、文件操作、多线程支持、网络编程等。它由多个模块组成，每个模块都提供了特定领域的功能。一些常用的模块包括：
std::collections：提供了各种常用的集合类型，如Vec、HashMap、HashSet等，用于存储和管理数据。std::fs：用于文件和目录的操作，包括文件的读写、目录的遍历和文件属性的获取等。std::thread：提供了多线程编程的支持，包括线程的创建、同步和通信等功能。std::net：用于网络编程的支持，包括TCP和UDP协议的socket编程、地址解析等功能。 除了上述模块外，标准库还包括了其他许多模块，涵盖了各个方面的功能，为开发者提供了丰富的选择。
2. 标准库中的常用数据结构 Rust标准库提供了许多常用的数据结构，这些数据结构在实际开发中经常被使用。以下是一些常见的数据结构及其用法：
2.1 Vec Vec是Rust中最常用的动态数组类型，用于存储同一类型的元素。它支持动态增加和删除元素，并提供了索引访问和迭代功能。
let mut vec = Vec::new(); vec.push(1); vec.push(2); vec.push(3); for i in &amp;vec { println!("{}", i); } 2.2 HashMap HashMap是Rust中的哈希表类型，用于存储键值对。它提供了高效的查找和插入操作，并支持根据键值进行遍历。
use std::collections::HashMap; let mut map = HashMap::new(); map.insert("key1", "value1"); map.insert("key2", "value2"); map.insert("key3", "value3"); if let Some(value) = map.get("key1") { println!("Value for key1: {}", value); } for (key, value) in &amp;map { println!("{}: {}"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c7df4bfa3b3e2934518b06af7c6f80f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31f18156014493ba21730853fba60bdf/" rel="bookmark">
			vue 前端读取Excel文件并解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端读取Excel文件并解析 前端如何解释Excel呢 平时项目中对于Excel的导入解析是很常见的功能，一般都是放在后端执行；但是也有特殊的情况，偶尔也有要求说前端执行解析，判空，校验等，最后组装成后端接口想要的数据结构。
前端如何解释Excel呢 因为我使用插件执行的 you know
安装插件 npm install xlsx@0.14.1 // 0.14.1 是我使用的版本 还有个nanoid npm i nanoid 此处我没有使用安装的这个 而是使用 自定的代码如下：
// index.js const createId = () =&gt; { return ( Number(Math.random().toString().substr(2, 7) + Date.now()).toString(36) + Date.now() ) } export { createId as default, createId } 安装已经完成了 当然 依然 you know import XLSX from 'xlsx' import nanoid from 'xxxx/xxx/index' 报一丝 差点忘记了 template &lt;el-upload class="upload" action="" :auto-upload="false" :show-file-list="false" :multiple="false" :on-change="(file, fileList) =&gt; importTemp(file, fileList)"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31f18156014493ba21730853fba60bdf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4f93dfccaaa89767ad8475a6f070117/" rel="bookmark">
			IIS上部署Asp.net core Webapi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、IIS的安装二、asp.net core webapi发布1.我的系统整体结构如下图所示2. 系统发布3.安装asp.net core 运行时。4.IIS部署5.swagger配置 前言 本篇文章将为您详细介绍IIS上部署asp.net core webapi的详细过程
一、IIS的安装 本人电脑的操作系统是win10。
首先打开控制面板，如下图所示：
然后点击【程序】
然后点击【启动或关闭windows功能】
弹出的windows功能对话框如下图所示
注意，要把带有IIS的及其子项都要打钩，这一点一定要记住！！！，如下图所示。
完成以上步骤后，IIS便安装好了。点击左下角【开始】按钮，输入iis,便可以看到如下所示的结果。
点击上图红框，弹出如下对话框。
二、asp.net core webapi发布 1.我的系统整体结构如下图所示 简要介绍一下，我的这个项目是带有前端页面的，我把前端页面放到了wwwroot文件夹里，Common文件夹是一些通用方法，Controllers文件夹是控制器，Models文件夹里放的是实体类。
2. 系统发布 右键单击项目，点击【发布按钮】，如下图所示。
【连接】处，发布方法选择文件系统，【目标位置】选择一个文件夹，建议不要放在C盘。如下图所示，这是我自己选择的一个路径。
【设置】处，配置选择Release，目标框架选择net5.0,因为我的是.net 5.0,部署模式选择框架依赖，目标运行时一定要根据自己的电脑环境来选择，我的电脑是64位操作系统，因此此处选择win-64，它最开始默认的是可移植，我没有改，导致后续部署一直没有成功！
点击下面的保存按钮，然后点击发布按钮，如下图所示。
最后提示发布成功即可。如下图所示。
3.安装asp.net core 运行时。 由于我使用的是.net5.0，因此就需要安装.net5.0对应的运行时。
下载地址： .net5.0运行时
点击标红框的Bundle,下载的安装包如下所示。
点击安装即可。
4.IIS部署 打开IIS，界面如下所示。
右键点击网站按钮，点击【添加网站】，如下图所示。
在弹出的对话框中，网站名称你自己定，比如我写的是CoreWebApi,物理路径选择上面系统发布那一节中目标位置那个文件夹，这里我也截了图了。端口号可以自由设定，但是不能超过某一个值，具体是多少我忘了，你可以设定个四位数的端口号，应该没问题，我设置的是8089，然后点击最下面的【确定】按钮即可。
这是我发布的-CoreWebApi，如下图所示。
但是这里还没完，点击应用程序池，然后点击对应CoreWebApi,在弹出的编辑应用程序池对话框中，按照截图所示进行设置。
点击确定按钮。
5.swagger配置 进入launchSettings.json,进行如下配置
最主要的是把"launchUrl": “swagger”,注释掉，至于applicationUrl对应的那个端口号，随便配置，反正我没用上。
在Startup.cs类里，找到Configure方法，按照我的截图进行修改即可。
保存工程。然后你得再重新发布一下，就按照上面系统发布那一节讲的那样重新发布一下就行了。
进行到这里，你在IIS里右键CoreWebApi,点击管理网站，然后点击浏览，如下图所示。
不出意外的话，你应该看到这样的画面。
不要着急，你这样操作：右键点击CoreWebApi，点击浏览，如下图所示。
在弹出的文件夹中找到web.config,用记事本或Nodepad++打开，找到红框里的内容。
把InProcess改成OutofProcess,然后保存这个文档，这时，重新右键CoreWebApi,点击管理网站，然后点击浏览，你就应该能看到如下画面了。
这样这个API就发布好了。
大家后续有什么问题可以在下面留言。感谢大家学习浏览！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3d6fc6f2742d165545952ea2b7e9e23/" rel="bookmark">
			Android使用adb命令查看串口数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有些串口设备 如电子天平，需要采集重量数据到Android设备上面。这个时候可能会选用RS232转USB的数据线连接到设备上。
那么，如何测试数据是否接收到呢？
可以使用串口调试工具，本文介绍 使用adb的方式去测试
首先用adb进入设备，执行 adb shell
然后执行"ls -l /dev/tty"命令查看有那些设备。如下图所示：
第一个图是没有插上usb的情况
第二个图是插上USB的情况, 我们看到多了一个 /dev/ttyUSB1 的文件，如果没有，说明串口没有识别成功
这个 ttyUSB1 不是固定的，重新插拔一下usb线，可能变成 ttyUSB2或其他的，根据情况处理。
然后，我们可以执行如下命令，监听窜口的十六进制数据。注意， ttyUSB1 要替换成实际的值。
cat /dev/ttyUSB1 |busybox hexdump -C 如果接收到数据，会显示出来，说明串口传输数据成功了。如下图所示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdb607e18ca32f081321f7a4003e812b/" rel="bookmark">
			【GitHub】github学生认证，在vscode中使用copilot的教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		github学生认证并使用copilot教程 写在最前面一.注册github账号1.1、注册1.2、完善你的profile 二、Github 学生认证注意事项：不完善的说明 三、Copilot四、在 Visual Studio Code 中安装 GitHub Copilot 扩展4.1 安装 Copilot 插件4.2 配置 Copilot 插件（新安装）4.3 换 Copilot 插件账号 🌈你好呀！我是 是Yu欸 🌌 2024每日百字篆刻时光，感谢你的陪伴与支持 ~ 🚀 欢迎一起踏上探险之旅，挖掘无限可能，共同成长！ 写在最前面 去年，我被安利后开始使用 GitHub Copilot，这是由 OpenAI 开发的一款革命性的代码自动补全工具。GitHub Copilot 不仅仅是一个简单的代码助手；它基于强大的 GPT-3 模型，能够理解编程语言的复杂性和上下文，从而提供高质量的代码补全建议。
Copilot 的设计目标是提高程序员的编码效率和准确性，使用 Copilot 极其方便。
它通过分析程序员输入的代码和上下文，智能地生成符合逻辑和语法的代码片段。程序员在编码时只需输入关键字或简短的代码提示，Copilot 就能迅速提供一系列合适的代码片段供选择。此外，它支持广泛的编程语言和开发框架，包括但不限于 Python、JavaScript、Java、C++ 和 React。这意味着无论你在使用哪种技术栈，Copilot 都能提供相应的支持。更为重要的是，Copilot 不仅提供代码补全，还能根据用户的编码习惯和历史输入智能地调整其建议，使得这些建议更加个性化和精准。此外，它还能帮助程序员更深入地理解代码的结构和语法，提供有关新编程语言和框架的学习支持。 通过 Copilot，程序员能够快速掌握新技术，有效提升其开发能力和工作效率。
参考：https://blog.csdn.net/cbetula/article/details/130276152
一.注册github账号 1.1、注册 用如QQ邮箱的第三方邮箱注册github
再添加.edu结尾的教育邮箱（Email settings (github.com)）
用以.edu结尾的教育邮箱注册github
1.2、完善你的profile 点击你的头像，有一个“Your profile”进入即可
在左侧填写相应的数据
以下格式填写profile
Name: 中文名（English Name）
如 小张三（Xiao Zhangsan) Bio: (学校名)SchoolName/major in +你的专业(用英文)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdb607e18ca32f081321f7a4003e812b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/670e181a891477873333b3539e866687/" rel="bookmark">
			【Java】全网最详细的logback日志配置说明（用于生产环境日志存储）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 我们搭建项目中一般都需要对日志进行管理，一般有log4j和logback两个日志框架，而logback性能较好，是我们的首选，本编整理了详细的logback日志配置，包括日志压缩存储，按天存储，按照日志大小切割日志文件等等置，大家可以直接复制并根据自己的项目情况配置相关参数用于生产环境，具体如下：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!--logback有5种级别，分别是TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR，定义于ch.qos.logback.classic.Level类中。--&gt; &lt;!--scan : 当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true--&gt; &lt;!--scanPeriod : 设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。--&gt; &lt;!--debug : 当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。--&gt; &lt;configuration scan="true" scanPeriod="60 seconds" debug="false"&gt; &lt;!--设置存储路径变量--&gt; &lt;property name="LOG_HOME" value="./logs"/&gt; &lt;!--项目名称--&gt; &lt;property name="APP_NAME" value="technology-learning"/&gt; &lt;!--日志级别,此处配置级别会被配置文件中覆盖，如果配置文件不配置默认走此处级别--&gt; &lt;property name="log.level" value="info"/&gt; &lt;!-- 日志最大的历史（单位：天 ）不配置视为永久保存--&gt; &lt;property name="log.maxHistory" value="2"/&gt; &lt;!--日志切割最大大小--&gt; &lt;property name="log.maxSize" value="100MB" /&gt; &lt;!--格式化输出--&gt; &lt;property name="log.pattern" value="%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n"/&gt; &lt;!--控制台输出appender--&gt; &lt;appender name="console" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!--设置输出格式--&gt; &lt;encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder"&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/670e181a891477873333b3539e866687/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdff5b01372d2223a9706808381a193e/" rel="bookmark">
			(Microsoft SQL Server，错误: 233)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误信息: A connection was successfully established with the server, but then an error occurred during the pre-login handshake. (provider: Shared Memory Provider, error: 0 - 管道的另一端上无任何进程。) (Microsoft SQL Server，错误: 233)
原因： 找到日志文件，我的目录是：
C:\Program Files\Microsoft SQL Server\MSSQL16.MSSQLSERVER\MSSQL\Log
点开错误日志：
发现报错信息
原来是我开启了服务器连接强制加密。
解决办法： 打开
1、Sql Server Configuration Manager找到MSSLSERVER的协议
2、点击属性-取消强制加密
问题解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bfe02f48be10ac1829f23a78476549e/" rel="bookmark">
			Android（Java）项目支持Kotlin语言开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android（Java）项目通过相关Kotlin设置后，允许同时使用Java语言和Kotlin语言进行开发代码的。
示例环境： Android Studio Giraffe | 2022.3.1 Patch 3
Java 8
Kotlin 1.9.20
设置Kotlin选项： 第一步：在项目根目录下build.gradle配置，增加对Kotlin 1.9.20版本的支持：id ‘org.jetbrains.kotlin.android’ version “1.9.20” apply false ，示例代码：
plugins { id 'com.android.application' version '8.1.3' apply false id 'org.jetbrains.kotlin.android' version "1.9.20" apply false //支持Kotlin } 示例截图：
第二步： app目录下build.gradle配置，增加对Kotlin 1.9.20版本的支持
1）在plugins{} 中添加：id ‘org.jetbrains.kotlin.android’ ，示例代码：
plugins { id 'com.android.application' id 'org.jetbrains.kotlin.android' } 2）在android{}中添加kotlinOptions选项，示例代码：
kotlinOptions { jvmTarget = "1.8" } 3）在dependencies{}中添加kotlin，示例代码：
//Android（Java）项目支持Kotlin语言 implementation "org.jetbrains.kotlin:kotlin-stdlib:1.9.20" // 支持 Java 8 implementation "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bfe02f48be10ac1829f23a78476549e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4acd909f9967be437c70e78778268d4/" rel="bookmark">
			伪分布HBase的安装与部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.实训目标 （1）熟悉掌握使用在Linux下安装伪分布式HBase。
（2）熟悉掌握使用在HBase伪分布式下使用自带Zookeeper。
2.实训环境 环境
版本
说明
Windows 10系统
64位
操作电脑配置
VMware
15
用于搭建所需虚拟机Linux系统
Linux系统
CentOS 7
已配置完成，并命名为hadoop能正常使用
伪分布式Hadoop
3.1.4
用于HBase伪分布式的配置
软件
版本
说明
HBase
2.5.6
最新稳定版本
3.实训说明 通过本小节学习，可知HBase内置也有Zookeeper，但为了对HBase的HMaster节点的高可用管理，更好的使用HBase，配置分布式HBase时使用的是外部Zookeeper集群。但如果只是简单的测试，并不需要存储海量数据，使用分布式HBase集群，会造成资源浪费，因此，可以选择使用伪分布式的HBase和HBase内置的Zookeeper以节约资源。请基于HBase 2.5.6版本实现伪分布式的HBase集群搭建。
4.实训步骤 4.1上传HBase安装包并解压 利用FinalShell软件将HBase安装包hbase-2.5.6-bin.tar.gz上传至虚拟机hadoop的/opt目录下。
使用“tar”命令将HBase解压至/usr/local目录下，具体实现如以下代码所示：
tar -zxvf /opt/hbase-2.5.6-bin.tar.gz -C /usr/local/ 4.2修改配置文件并设置环境变量 HBase伪分布式安装，需要修改的配置文件有hbase-env.sh、hbase-site.xml、regionservers和/etc/profile。
通过“cd /usr/local/hbase-2.5.6/conf”命令进入HBase的conf目录下。
（1）配置HBase的环境变量
执行“vi /etc/profile”命令，对profile文件修改，添加HBase环境变量，内容如代码4-1所示。
代码4-1 修改profile
#HBASE_HOME export HBASE_HOME=/usr/local/hbase-2.5.6 export PATH=$PATH:$HBASE_HOME/bin 切换到命令模式，输入命令“：wq”保存退出。执行命令“source /etc/profile”进行刷新。
（2）修改配置文件hbase-env.sh
执行“vi hbase-env.sh”命令,修改配置文件hbase-env.sh，添加内容如代码4-2所示。切换到命令模式，输入命令“：wq”保存退出。
其中HBASE_CLASSPATH设置为Hadoop配置文件的目录，JAVA_HOME设置为JDK的路径，HBASE_MANAGES_ZK设置为ture，使用HBase自带的Zookeeper。
代码4-2 修改hbase-env.sh
export HBASE_CLASSPATH=/usr/local/hadoop-3.1.4/etc/hadoop export JAVA_HOME=/usr/local/jdk1.8.0_161 export HBASE_MANAGES_ZK=true （3）修改配置文件hbase-site.xml
执行“vi hbase-site.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4acd909f9967be437c70e78778268d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd5015dcbf1a4a1866cb5d3a121dd8ae/" rel="bookmark">
			Vue3，使用monaco-editor实现sql对比编辑器，自定义高亮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：上篇文章讲了monaco-editor的基本使用，这篇文章讲解如何实现monaco-editor的对比效果。 一：安装monaco-editor npm install monaco-editor 二：使用 import * as monaco from "monaco-editor"; import editorWorker from "monaco-editor/esm/vs/editor/editor.worker?worker"; 三：封装基本组件 注意：原本monaco-editor的效果是左编辑器为原始sql，右编辑器为新sql。我这的需求是让左编辑器为可编辑，即左编辑器为新sql。因此我开启了左边的可编辑配置，且将右编辑器设置为只读。（需要根据需求自己更改配置以及传入的值）
&lt;template&gt; &lt;div class="codemirror"&gt; &lt;div id="monacoEditorDiff" ref="editorDiffRef" class="monaco-editor"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup&gt; import * as monaco from "monaco-editor"; import editorWorker from "monaco-editor/esm/vs/editor/editor.worker?worker"; // 定义从父组件接收的属性 const props = defineProps({ options: { type: Object, default: () =&gt; ({ theme: "dark", }), }, oldValue: { type: String, }, newValue: { type: String, }, }); const emits = defineEmits(["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd5015dcbf1a4a1866cb5d3a121dd8ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c49d24c1f23df26e31215f79856f93c4/" rel="bookmark">
			有关后端返回文件流或base64文件，前端如何实现图片展示和下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		后端返回的文件流，前端怎么把图片显示出来 1.多年前端开发经验的我目前用的最多的是：直接将请求地址写在src里面，如：
&lt;img src="/file/preview/picture.png" alt="图片"&gt;
2.由于后台加上鉴权后，需要每个接口在header里面加上token,上面的做法就行不通了，需要发送请求获得文件流
const file_data = res.data // 后端返回的文件流 const blob = new Blob([file_data]) const url = window.URL.createObjectURL(blob) // image中src的链接 3.后台返回base64文件
srcurl= 'data:application/octet-stream;base64,' + res js下载后端返回的文件 1.后端返回文件流形式，前端下载
// res 为后端返回的响应对象 const file_data = res.data // 后端返回的文件流 const blob = new Blob([file_data]) const url = window.URL.createObjectURL(blob) // 创建下载的链接 const file_name = decodeURI(res.headers['content-disposition'].replace('attachment;filename=', '')) // 需要后端暴露请求头'Content-Disposition' console.log(file_name) // 从请求头获取文件名 const downloadElement = document.createElement('a') downloadElement.style.display = 'none' downloadElement.href = url downloadElement.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c49d24c1f23df26e31215f79856f93c4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/388/">«</a>
	<span class="pagination__item pagination__item--current">389/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/390/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>