<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed071cf2dcbc0fe60f394e1e5e6a59fc/" rel="bookmark">
			MongoDB如何安装并配置公网地址实现Navicat远程连接本地数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. 安装Docker2. 使用Docker拉取MongoDB镜像3. 创建并启动MongoDB容器4. 本地连接测试5. 公网远程访问本地MongoDB容器5.1 内网穿透工具安装5.2 创建远程连接公网地址5.3 使用固定TCP地址远程访问 前言 本文主要介绍如何在Linux Ubuntu系统快速部署MongoDB，并结合cpolar内网穿透工具实现公网远程访问本地数据库。
MongoDB服务端可以运行在Linux、Windows、MacOS平台，可以存储比较复杂的数据类型，支持的查询语言非常强大，几乎可以实现类似关系数据库单表查询的绝大部分功能，还可以对数据建立索引。
直接实用包管理器安装MongoDB比较复杂，使用Docker安装部署MongoDB则相对简单快速，下面就和大家分享一下具体操作流程。
1. 安装Docker 本教程操作环境为Linux Ubuntu系统，在开始之前，我们需要先安装Docker。
在终端中执行下方命令：
添加Docker源
# Add Docker's official GPG key: sudo apt-get update sudo apt-get install ca-certificates curl gnupg sudo install -m 0755 -d /etc/apt/keyrings curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg sudo chmod a+r /etc/apt/keyrings/docker.gpg # Add the repository to Apt sources: echo \ "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \ $(.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed071cf2dcbc0fe60f394e1e5e6a59fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5922a8f957f9c82334168c1166926ac6/" rel="bookmark">
			Java项目：基于SSM框架实现的德云社票务管理系统【ssm&#43;B/S架构&#43;源码&#43;数据库&#43;开题报告&#43;毕业论文】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、项目简介 本项目是一套基于SSM框架实现的德云社票务管理系统
包含：项目源码、数据库脚本等，该项目附带全部源码可作为毕设使用。
项目都经过严格调试，eclipse或者idea 确保可以运行！
该系统功能完善、界面美观、操作简单、功能齐全、管理便捷，具有很高的实际应用价值
二、技术实现 jdk版本：1.8 及以上
ide工具：IDEA或者eclipse
数据库: mysql5.7
后端：spring+springmvc+mybatis+maven+mysql
前端：VUE
三、系统功能 系统用户包括有管理员、会员
前台主要功能如下：
用户登录
用户注册
票务信息
常见问题
公告信息
点我收藏
立即预订
发表评论
视频播放
确认下单
支付
退款
个人中心
我的订单
我的收藏
我的地址等
后台主要功能如下：
用户登录
首页
个人中心
修改密码
个人信息
会员管理
票务信息管理
常见问题管理
管理员管理
系统管理
订单管理
公告信息
问题反馈等功能
四、页面 五、文档 六、数据库 七、源码地址 https://download.csdn.net/download/weixin_43860634/89519382
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b4f640ad3413846e98bbaaabd3d461a/" rel="bookmark">
			Python酷库之旅-第三方库Pandas(006)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、用法精讲
10、pandas.DataFrame.to_excel函数
10-1、语法
10-2、参数
10-3、功能
10-4、返回值
10-5、说明
10-6、用法
10-6-1、数据准备
10-6-2、代码示例
10-6-3、结果输出
11、pandas.ExcelFile类
11-1、语法
11-2、参数
11-3、功能
11-4、返回值
11-5、说明
11-5-1、文件访问
11-5-2、工作表操作
11-5-3、高级操作
11-6、用法
11-6-1、数据准备
11-6-2、代码示例
11-6-3、结果输出 12、pandas.ExcelFile.parse函数
12-1、语法
12-2、参数
12-3、功能
12-4、返回值
12-4-1、单个工作表
12-4-2、多个工作表
12-4-3、所有工作表
12-5、说明
12-6、用法
12-6-1、数据准备
12-6-2、代码示例
12-6-3、结果输出 二、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、博客个人主页
一、用法精讲 10、pandas.DataFrame.to_excel函数 10-1、语法 # 10、pandas.DataFrame.to_excel函数 DataFrame.to_excel(excel_writer, *, sheet_name='Sheet1', na_rep='', float_format=None, columns=None, header=True, index=True, index_label=None, startrow=0, startcol=0, engine=None, merge_cells=True, inf_rep='inf', freeze_panes=None, storage_options=None, engine_kwargs=None) Write object to an Excel sheet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b4f640ad3413846e98bbaaabd3d461a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0939dce887f1a066ca8a513152a43c08/" rel="bookmark">
			玩转云服务：Oracle Cloud甲骨文永久免费云服务器注册及配置指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇，带大家分享了：如何薅一台腾讯云服务器。
不过，只有一个月免费额度，到期后需要付费使用。
相对而言，海外云厂商更加慷慨一些，比如微软Azure、甲骨文、亚马逊AWS等。
甲骨文2019年9月就推出了永久免费服务，“永久免费”的噱头一经打出，立即引来了不少流量。不过随着国内薅羊毛大军的进驻，注册账号的门槛越来越高。
这两天猴哥又走了一遍注册流程，成功跑通，亲测有效，趁热乎赶紧分享给大家~
本次分享，手把手带领大家在甲骨文云上，跑通账号注册流程，申请一台虚拟机实例，完成服务器配置，希望能够帮助大家成功白嫖甲骨文的永久免费云服务。
1. 真假‘永久免费’ 所谓的永久免费，其实是有很多限制的，而且你不一定能抢得到哦。
且看官方是这样描述的：
Oracle 云免费套餐只需注册 Oracle 云帐户即可获取，不仅包含丰富的 Always Free 云服务，还提供 300 美元的免费试用储值，让您可以在 30 天内免费使用所有适用的 Oracle 云基础设施服务。其中，Always Free 云服务无时长限制，免费试用仅 300 美元免费储值用尽或 30 天到期（以先到者为准）前有效。
虚拟机资源方面，单个账号可以拥有：
2 个基于 AMD 的虚拟机，每个虚拟机配备 1/8 OCPU 和 1 GB 内存基于 Arm 的 Ampere A1 内核和 24 GB 内存，可作为 1 个虚拟机或最多 4 个虚拟机使用，每月有 3000 个 OCPU 小时和 18000 GB 小时。（每个月 24*30 = 720 小时，意味着你的 4C24G 的 ARM 服务器可以全天候免费在线） 存储方面，有 200G 的免费块存储，不得不说甲骨文还是蛮慷慨的~
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0939dce887f1a066ca8a513152a43c08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/000a958cf72dea259cb32948c3bf1e2b/" rel="bookmark">
			Python酷库之旅-第三方库Pandas(005)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、用法精讲
7、pandas.read_clipboard函数
7-1、语法
7-2、参数
7-3、功能
7-4、返回值
7-5、说明
7-6、用法
7-6-1、代码示例
7-6-2、结果输出
8、pandas.DataFrame.to_clipboard函数
8-1、语法
8-2、参数
8-3、功能
8-4、返回值
8-5、说明
8-6、用法
8-6-1、代码示例
8-6-2、结果输出 9、pandas.read_excel函数
9-1、语法
9-2、参数
9-3、功能
9-4、返回值
9-5、说明
9-6、用法
9-6-1、数据准备
9-6-2、代码示例
9-6-3、结果输出
二、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、博客个人主页
一、用法精讲 7、pandas.read_clipboard函数 7-1、语法 # 7、pandas.read_clipboard函数 pandas.read_clipboard(sep='\\s+', dtype_backend=_NoDefault.no_default, **kwargs) Read text from clipboard and pass to read_csv(). Parses clipboard contents similar to how CSV files are parsed using read_csv(). Parameters: sepstr, default ‘\s+’ A string or regex delimiter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/000a958cf72dea259cb32948c3bf1e2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaf1dc3f30471218eaa7b67ed2697f20/" rel="bookmark">
			【前端从入门到精通：第二课：HTML头部标签常用标签】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		走进HTML世界 HTML简介 可参考百度百科
学习变成到底难不难？ A. 1 * 5 = ?
B. 111 * 555 = ?
A 到 B的过程， 差距就在于动手，不动手你就学不会。
如何创建HTML文件 ​鼠标右键-&gt;新建文本文件-&gt;更改后缀名.html
创建文件所需要注意事项
可以以中文命名，但是不允许使用中文（我）。不允许使用特殊字符。HTML文件名推荐使用小写。如果是多个单词创建的文件名，推荐使用驼峰命名法，每个单词首字母大写
HelloWorld创建完HTML文件后依然是文本文件格式，那么需要将系统中隐藏已知文件类型扩展名勾选掉。 HTML标签相关 HTML标签
标签是HTML的最基本的单位，也是最重要的组成部分，通常用两个角括号括起来得：“&lt;”
和 “&gt;”。
标签有两种形式：
成对标签(双标签)
&lt;p&gt;内容&lt;/p&gt; 不成对标签(单标签)
&lt;hr /&gt; HTML标签的大小写问题
标签是大小写无关的，与表示意思一样。
注意：HTML标签推荐使用小写
HTML标签属性
HTML属性一般都出现在HTML标签中，是HTML标签的一部分。
标签可以有属性，包含了额外的信息，属性的值一定要在双引号中。而且标签还可以存在多个属性。
一般属性由属性名和属性值成对出现：
语法：
&lt;标签名 属性名1=“属性值” 属性名2=“属性值”&gt;&lt;/标签名&gt;
HTML颜色值的设置
浏览器都支持颜色名称集合，颜色值是一个关键字或者是一个RGB格式的数字，在网页中都用的很多。使用英文单词作为颜色值： red 红色 | green 绿色 | blue 蓝色 | pink 粉色 | purple
紫色等。 六位的十六进制颜色值： #ff0000 简写：#f00前两位表示红色，中间两位表示绿色，最后两位表示蓝色。 HTML注释
注释的内容不会被浏览器解释出来
注释的好处：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eaf1dc3f30471218eaa7b67ed2697f20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e63b79a0ce430f91e812c2707241c7a/" rel="bookmark">
			Java 面向对象编程（OOP）的四大特征
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 面向对象编程（OOP）的四大特征 1、抽象2、继承3、 封装4、多态性 💖The Begin💖点点关注，收藏不迷路💖 在Java编程中，面向对象编程（OOP）是一个核心概念。OOP的四大基本特征分别是：抽象、继承、封装和多态。本文将详细介绍这四个特征。
1、抽象 抽象是指将一类对象的共同特征总结出来构造类的过程。抽象包括数据抽象和行为抽象两方面。它只关注对象有哪些属性和行为，并不关注这些行为的具体实现细节。
示例：
abstract class Animal { String name; abstract void makeSound(); } 在这个例子中，Animal类是一个抽象类，它定义了一个抽象方法 makeSound()，但并没有给出具体实现。
2、继承 继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类），得到继承信息的类被称为子类（派生类）。通过继承，子类可以重用父类的代码，同时也可以增加新的属性和方法。
示例：
class Dog extends Animal { void makeSound() { System.out.println("Bark"); } } 在这个例子中，Dog类继承自 Animal 类，并且实现了 makeSound() 方法。
3、 封装 封装是指将数据和操作数据的方法绑定在一起，对数据的访问只能通过已定义的接口。通过封装，可以隐藏对象的内部实现细节，只向外界提供必要的接口。
示例：
class Person { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } } 在这个例子中，Person类的 name 属性是私有的，只能通过 getName() 和 setName() 方法进行访问。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e63b79a0ce430f91e812c2707241c7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29ab6c6607f891c7ffc35e17c8d98a2c/" rel="bookmark">
			14-31 剑和诗人5 - 使用 AirLLM 和分层推理在单个 4GB GPU 上运行 LLama 3 70B
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用分层推理实现大模型语言(LLM) 大型语言模型 (LLM) 领域最近取得了显著进展，LLaMa 3 70B 等模型突破了之前认为可能实现的极限。然而，这些模型的庞大规模给其部署和实际使用带来了巨大挑战，尤其是在资源受限的设备上，例如内存有限的 GPU。
LLM 占用大量内存的主要原因是其复杂的架构，由多个相互堆叠的层组成。传统的模型部署方法需要将整个模型加载到内存中，对于超出可用内存容量的模型来说，这很快就会变得不可行。这一限制阻碍了最先进的 LLM 的广泛采用，将其使用限制在专门的硬件设置或基于云的环境中。
在这篇博文中，我将探讨一种革命性的技术，即分层推理，该技术可以在一台普通的 4GB GPU 上执行 LLaMa 3 70B 模型。通过利用这种方法，我们可以有效地规避传统上困扰大型语言模型部署的内存限制，为它们更广泛的可访问性和实际应用铺平道路。
分而治之的方法：分层推理 分层推理的核心是一种“分而治之”策略，将单片模型分解为更小、更易于管理的组件。这种技术不是一次性将整个模型加载到内存中，而是在适当的情况下仅将必要的层加载到 GPU 内存中。在执行特定层的计算后，该层占用的内存会立即释放，以便加载和处理下一层。
这种方法有效地将内存占用量减少到仅一个转换器层的大小，对于 LLaMa 3 70B 模型来说，大约为 1.6GB — 只是模型整体大小的一小部分。通过精心安排这种逐层执行，我们可以充分利用模型的全部功能，同时遵守即使是中等 GPU 配置的内存限制。
分层推理技术特别适合 LLM，因为它们具有固有结构。这些模型由一系列转换器层组成，每个转换器层负责以特定方式处理和细化输入数据。通过解耦这些层的执行，我们可以有效地将计算负载分配到多个迭代中，从而最大限度地减少总体内存需求。
使用 AirLLM 实现分层推理 虽然分层推理的概念很简单，但其实际实施却可能很复杂且容易出错。幸运的是，AirLLM 库通过提供强大且用户友好的框架来简化此过程，以便使用分层推理执行大型语言模型。
AirLLM 是一个开源 Python 库，专门用于在资源受限的硬件（例如内存容量有限的 GPU）上部署 LLM。它抽象了分层推理的复杂细节，使开发人员能够专注于核心应用程序，而不必担心内存管理和层执行的低级复杂性。
airllm 的主要优势之一是它与 PyTorch 和 TensorFlow 等流行的深度学习框架无缝集成。这种集成使开发人员能够利用他们现有的知识和代码库，最大限度地缩短学习曲线并顺利过渡到分层推理的世界。
以下是 AirLLM 如何使用分层推理在 4GB GPU 上执行 LLaMa 3 70B 模型的高级概述：
模型加载：第一步是将 LLaMa 3 70B 模型检查点加载到内存中。airllm 为此提供了一个方便的 API，处理必要的预处理和数据格式化步骤。层提取：加载模型后，airllm 会从模型架构中提取各个变压器层。此过程涉及分析模型的结构并识别层之间的边界。内存管理：在执行每一层之前，airllm 都会确保 GPU 上有足够的内存。如有必要，它会通过卸载先前处理的层来释放内存，为即将到来的层腾出空间。层执行：分配必要的内存后，airllm 在 GPU 上执行当前层的计算。此过程包括将输入数据输入到层的操作中并捕获结果输出。输出传播：执行完一层后，airllm 将输出传播到序列中的下一层。此步骤可能涉及对数据进行额外的预处理或重塑，以确保与后续层的输入要求兼容。迭代和优化：对模型中的每一层重复步骤 3 到 5，有效地以分层方式执行整个模型。airllm 采用各种优化技术，例如缓存和并行化，以最大限度地提高效率并最大限度地降低计算开销。最终输出：完成所有层的执行后，airllm 会合并最终输出，并以适合下游应用程序或进一步处理的格式呈现。 通过利用 AirLLM，开发人员可以充分利用 LLaMa 3 70B 等大型语言模型的潜力，而不受硬件资源的限制。该库的抽象和优化功能简化了分层推理的过程，从而实现了无缝且高效的部署体验。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29ab6c6607f891c7ffc35e17c8d98a2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a7b97555bfd3d94750494a22ecbacf0/" rel="bookmark">
			Mojolicious测试驱动开发：单元与集成测试的艺术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标题：Mojolicious测试驱动开发：单元与集成测试的艺术 Mojolicious是一个现代化的Perl Web开发框架，它不仅提供了强大的Web应用开发能力，还内置了丰富的测试工具来支持单元测试和集成测试。本文将深入探讨如何在Mojolicious中进行单元测试和集成测试，确保代码的健壯性和可靠性。
1. 测试的重要性 在软件开发中，测试是保证代码质量的关键步骤。单元测试关注单个组件的行为，而集成测试则关注多个组件的协同工作。
2. Mojolicious测试环境搭建 Mojolicious提供了一个简单的测试环境搭建方法，使用Mojo::HelloWorld创建一个示例应用。
mojo generate app MyTestApp 3. 单元测试基础 单元测试通常针对模型、视图、控制器等独立组件进行。Mojolicious使用Test::More和Test::Mojo进行测试。
use Test::More; use Test::Mojo; my $t = Test::Mojo-&gt;new('MyTestApp'); # 测试一个简单的路由 $t-&gt;get_ok('/')-&gt;status_is(200)-&gt;content_like(qr/Welcome to MyTestApp/); 4. 测试控制器 控制器测试是单元测试的一部分，确保控制器逻辑按预期工作。
$t-&gt;get_ok('/example')-&gt;status_is(200); 5. 测试模板渲染 确保模板渲染正确是Web应用测试的重要部分。
$t-&gt;get_ok('/template')-&gt;status_is(200)-&gt;element_exists('h1'); 6. 测试表单提交 测试表单提交确保数据能够正确提交到服务器。
$t-&gt;post_ok('/form' =&gt; form =&gt; {name =&gt; 'Test User'}) -&gt;status_is(302); # 检查重定向状态码 7. 集成测试基础 集成测试关注组件间的交互，通常涉及多个控制器和模型。
$t-&gt;get_ok('/start')-&gt;status_is(200); $t-&gt;post_ok('/process' =&gt; form =&gt; {...}) -&gt;status_is(200); 8. 使用数据库进行测试 当应用使用数据库时，测试可能需要模拟数据库操作。
use Test::Database; database(MyTestApp-&gt;new-&gt;db-&gt;connect_info); $t-&gt;get_ok('/db_test')-&gt;status_is(200); 9. 测试异步操作 Mojolicious支持异步操作，测试这些操作需要特殊的处理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a7b97555bfd3d94750494a22ecbacf0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d8c89ca382ba9bb702e49355b8cfff5/" rel="bookmark">
			240705_昇思学习打卡-Day17-基于 MindSpore 实现 BERT 对话情绪识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		240705_昇思学习打卡-Day17-基于 MindSpore 实现 BERT对话情绪识别 近期确实太忙，此处仅作简单记录：
模型简介 BERT全称是来自变换器的双向编码器表征量（Bidirectional Encoder Representations from Transformers），它是Google于2018年末开发并发布的一种新型语言模型。与BERT模型相似的预训练语言模型例如问答、命名实体识别、自然语言推理、文本分类等在许多自然语言处理任务中发挥着重要作用。模型是基于Transformer中的Encoder并加上双向的结构，因此一定要熟练掌握Transformer的Encoder的结构。
关于Transformer的Encoder的结构在这篇中有提及，可以去参考看看240701_昇思学习打卡-Day13-Vision Transformer图像分类-CSDN博客
BERT模型的主要创新点都在pre-train方法上，即用了Masked Language Model和Next Sentence Prediction两种方法分别捕捉词语和句子级别的representation。
在用Masked Language Model方法训练BERT的时候，随机把语料库中15%的单词做Mask操作。对于这15%的单词做Mask操作分为三种情况：80%的单词直接用[Mask]替换、10%的单词直接替换成另一个新的单词、10%的单词保持不变。
因为涉及到Question Answering (QA) 和 Natural Language Inference (NLI)之类的任务，增加了Next Sentence Prediction预训练任务，目的是让模型理解两个句子之间的联系。与Masked Language Model任务相比，Next Sentence Prediction更简单些，训练的输入是句子A和B，B有一半的几率是A的下一句，输入这两个句子，BERT模型预测B是不是A的下一句。
BERT预训练之后，会保存它的Embedding table和12层Transformer权重（BERT-BASE）或24层Transformer权重（BERT-LARGE）。使用预训练好的BERT模型可以对下游任务进行Fine-tuning，比如：文本分类、相似度判断、阅读理解等。
对话情绪识别（Emotion Detection，简称EmoTect），专注于识别智能对话场景中用户的情绪，针对智能对话场景中的用户文本，自动判断该文本的情绪类别并给出相应的置信度，情绪类型分为积极、消极、中性。 对话情绪识别适用于聊天、客服等多个场景，能够帮助企业更好地把握对话质量、改善产品的用户交互体验，也能分析客服服务质量、降低人工质检成本。
下面以一个文本情感分类任务为例子来说明BERT模型的整个应用过程。
我们假设已经装好了MindSpore环境
# 该案例在 mindnlp 0.3.1 版本完成适配，如果发现案例跑不通，可以指定mindnlp版本，执行`!pip install mindnlp==0.3.1` !pip install mindnlp import os import mindspore from mindspore.dataset import text, GeneratorDataset, transforms from mindspore import nn, context from mindnlp._legacy.engine import Trainer, Evaluator from mindnlp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d8c89ca382ba9bb702e49355b8cfff5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab0fb76b23a2c31e77c188195ad37dc7/" rel="bookmark">
			【C/排序算法】：归并排序和计数排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 归并排序2. 计数排序 1. 归并排序 归并排序是一种效率仅次于快速排序的排序算法。它有非递归和递归两种实现方式(本文只讲述递归实现，非递归实现以后有专门的文章)。
其实，归并排序也叫外排序。它不仅可以对内存中的数据进行排序，还能对文件里的数据排序。
比如：假设有10G的数据放在硬盘的文件中，要排序，如何排呢？
我们知道，内存里的空间远远没有10G，假设有1G内存可用。首先我们可以把10G的文件切分成10个1G的文件，再依次读文件，每次把1G的数据读入内存的数组中，接着利用快排对其进行排序，再把排好序的那1G的数据写到硬盘的一个文件，再继续读下一个1G的数据……当10个文件里的数据都分别有序时，再利用归并排序进行两两归并，最终使10G的数据有序。
1.算法思想：
归并排序采用分治法。首先假设一组数据的左半区间有序，右半区间有序，将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。
若将两个有序表合并成一个有序表，称为二路归并。
所谓 归并，就是将两组有序的数据合成为一组有序的数据。 例如有如下两个有序数组，将两个有序数组归并为一个有序数组，这就是一次归并操作。
2.归并操作的工作原理如下：
第一步：申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列。
第二步：设定两个指针，最初位置分别为两个已经排序序列的起始位置。
第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置。
重复步骤3直到某一指针超出序列尾，将另一序列剩下的所有元素直接复制到合并序列尾。
归并排序类似于二叉树的后序遍历，即先将左右的区间都排为有序后，然后才开始进行归并操作，因为归并必须要满足两个数组是有序的。
例如有如下数组。需要先将该数组每次都分割为两个区间，直到最后每个区间都只有一个值，此时比较两个值大小，然后将该两个值归并到一个数组中，此时就得到一个有两个元素的有序数组，然后再与另一个有两个元素的有序数组进行归并，然后就得到了一个有四个元素的有序数组，然后再与另一个有四个元素的有序数组进行归并，就得到了一个有八个元素的有序数组。就这样依次递归归并，直到最后目标数组为有序数组。
3.归并排序的代码实现如下：
//把数组分成区间 void _MergrSort(int* arr,int left,int right,int* tmp) { //当区间内只有一个元素时，认为有序，递归结束，开始归并 if (left == right) return ; //右移1位右除以2的效果，用来把数组分成两个区间 int mid = (left + right) &gt;&gt; 1; //假设[left mid] [mid+1 right]有序，就可以归并 _MergrSort(arr, left, mid, tmp); _MergrSort(arr, mid + 1, right, tmp); //每次归并的过程 int begin1 = left; int end1 = mid; int begin2 = mid + 1; int end2 = right; //注意：这里的index不要给0，因为在递归过程中left不一定等于0 int index = left; //有一个区间结束就停止 while (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) { if (arr[begin1] &lt;= arr[begin2]) { tmp[index++] = arr[begin1++]; } else { tmp[index++] = arr[begin2++]; } } //当其中有一个区间结束时，另一个有序区间的数据直接拷贝进临时数组里 while (begin1 &lt;= end1) { tmp[index++] = arr[begin1++]; } while (begin2 &lt;= end2) { tmp[index++] = arr[begin2++]; } //最后把临时数组里面的数据拷贝回原数组 //注意：这里拷贝时有可能是局部区间拷贝，要加 begin memcpy(arr+begin, tmp+begin, sizeof(int) * (end -begin +1)); //也可以这样写 //for(int i = left; i &lt;= right; i++) //	arr[i] = tmp[i]; } void MergrSort(int* arr, int sz) { //创建临时数组存放数据 int* tmp = (int*)malloc(sizeof(int) * sz); if (tmp == NULL) { perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab0fb76b23a2c31e77c188195ad37dc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e760d2b48d560f7a55c3c25712221014/" rel="bookmark">
			Linux 端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是虚拟端口 计算机程序之间的通讯，通过IP只能锁定计算机，但是无法锁定具体的程序。通过端口可以锁定计算机上具体的程序，确保程序之间进行沟通。
IP地址相当于小区地址，在小区内可以有许多用户（程序），而门牌号（端口）就是各个住户（程序）的联系地址。
如图，若计算机A和计算机B要通讯，通过IP地址即可。
计算机A上的程序和计算机B上的程序要通讯，就要通过端口
端口分类 工人端口：1-1023，通常用于一些系统内置或知名程序的预留使用，如SSH服务的22端口，HTTPS服务的443端口，非特殊需要，不要占用这个范围的端口。
注册端口：1024-49151，通常可以随意使用，用于松散的绑定一些程序\服务。
动态端口：49152-65535，通常不会固定绑定程序，而是当程序对外进行网络链接时，用于临时使用。
Linux 查看端口的使用情况 nmap 命令 作用：查看端口占用情况
语法：nmap 被查看的IP地址
可以看到，本机（127.0.0.1）上有3个端口现在被程序占用了。
netstat命令 作用：查看指定端口占用情况
语法：netstat -anp | grep 端口号
上图为 111 端口的占用情况。
也可以通过该命令来判断某个端口是否空闲，如下图。
上图说明系统中肯定没有12345这个进程，且12345这个端口没人使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7366b25693b5d1ff23e9dc2a34a7aeb/" rel="bookmark">
			Java实习手册（小白也看得懂）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		秃狼说 距离俺发布的学习路线已经六个月了，那我给小伙伴的学习周期是四五个月左右，我相信大多的小伙伴已经学习的差不多了。正好赶上暑期实习的阶段，在暑期找到实习就成为暑期的头等大事。
实习经验在校招的起到决定性的作用，所以我们需要认真准备。
技术栈准备（不断的复习，永远有你不会的八股文） 技术栈无需学的很透彻。这个时候呢，更考验的是你对基础知识的理解。也就是我们常说的复习好八股文。一个合格的开发实习生，不是一味的背诵八股文。而是与八股文融为一体，通俗易懂的讲就是理解性的背诵。
对于java实习生，八股文主要的侧重点需要放在 java基础，mysql, redis，rabbitMq，ssm，微服务，juc。
java基础：关键字的理解，jdk特性，包装类，集合（HashMap，ArrayList，LinkedList）。
mysql：存储引擎的理解，索引的理解，sql的简单调优，事务基础（并发事务问题）及隔离级别的理解。
redis：数据类型的应用。缓存三大问题。
ssm：bean的生命周期，ioc， aop,，动态代理流程，循环依赖问题，mybatis的执行流程，springboot自动装配原理。
rabbitMq：消息堆积解决方案，延迟队列实现方案。
微服务：微服务五大组件，接口幂等性解决方案。
juc：线程池七大参数，线程池类型，AQS，CAS，锁升级原理。
简历准备（简历控制在两页，一页太少了，三页太多了） 1.调选模板（简约优先）
2.简历排版
个人基本信息教育经历。（如果是专升本的同学，直接学25届，不需要写时间，其他学历就按正常的形式写）技术栈。项目经验：一个微服务，一个单体项目。在校荣誉。 3.描述项目经验的格式上。（图片这种情况就是需要删除无用的亮点）
项目描述。技术选型。主要举出五个项目亮点，在亮点的描述上 使用...技术-&gt;解决...业务问题-&gt;在性能上优化了...。 在秃狼看来，没有最优的简历，简历本来就是一步一步的优化出来的，我不认为某某人修改的简历最好，或许你修改的简历就比我好呢。只要一份简历它能帮你约到面试，那它就是一份好的简历。
投简历 就秃狼的个人经验来看，我们投简历的主要战场就是Boss直聘，智联（回复率低）。
我们就以boss直聘为例
1.关闭自动打招呼。
2.设置常用语，便于后续海投。（自我介绍：哪一届，什么专业，项目经验，技术栈等等）
3.设置在线简历（这个非常重要，hr第一眼就是看这个简历）
4.上传附件简历。
5.开始海投。（找到对应的城市，一天投100家）
hr的上班时间早上8~9点中午 14~15点，所以我们应该在这个时间段投递我们的简历，保证我们的消息在hr信息列表的最高点。
我们在找到合适的岗位后，点击沟通，发送我们设置的自我介绍常用语。
此时会有两种情况：送达，已读。
已读：此时hr看到你的消息了，等待其要我们的简历，如果没有要的话，直接投下一家。
送达：此时hr并没有看到你的简历，所以我们需要重新讲我们的消息重置信息列表的最高点。
如果是早上发的消息，那么我们可以在中午的时候再发送一条问候语。
重置到最高点。
6.海投分析：在简历没有问题的情况下，如果是普通本科的同学，沟通50家平均一场面试。如果超出这比率的话，说明简历需要再进行修改。
面试流程 自信，自信，自信。重要的事情说三遍。不紧张是不可能的，我们要保证的是能和面试官正常的沟通，并且呢，我们需要注意敬语。
1.自我介绍。（要较短且有信息量）
我叫xxx，目前是xxxx学校的大三在读生，有xxxx经历，目前的技术栈包括xxxxxx....。
我们不喜欢使用过多的敬语：很高兴贵公司给予面试机会这种话，我们是来面技术的，不是来搞人情世故的。
2.面试官提问：主要就是八股文+项目。（如果项目没有亮点的话，基本上全是八股文）
3.访问：实习主要做的项目是什么，工作时间，我的技术方面有啥欠缺的。
面经总结 如果是线下面试的话，最好做录音，通过录音做好总结，为下次面试做好准备。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46335c6b056d02613b615deb1a6f82a6/" rel="bookmark">
			Django学习第五天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		启动项目命令
python manage.py runserver 图像验证码生成随机字母或者数字
import random from PIL import Image, ImageDraw, ImageFont, ImageFilter def check_code(width=120, height=40, char_length=5, font_file='ZixunHappyBold.ttf', font_size=28): code = [] img = Image.new(mode='RGB', size=(width, height), color=(255, 255, 255)) draw = ImageDraw.Draw(img, mode='RGB') def rndChar(): """ 生成随机字母 :return: """ return chr(random.randint(65, 90)) # 生成随机数字 # return str(random.randint(0, 9)) def rndColor(): """ 生成随机颜色 :return: """ return (random.randint(0, 255), random.randint(10, 255), random.randint(64, 255)) # 写文字 font = ImageFont.truetype(font_file, font_size) for i in range(char_length): char = rndChar() code.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46335c6b056d02613b615deb1a6f82a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85366e7b198bd664d072c3bd8a30a1b2/" rel="bookmark">
			《C语言》认识数据类型和理解变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌹个人主页🌹：喜欢草莓熊的bear
🌹专栏🌹：C语言基础
目录
前言
一、数据类型的介绍
1.1 字符型
1.2 整形
1.3 浮点型
1.4 布尔类型
1.5 各种数据类型的长度
1.5.1 sizeof操作符
1.5.2 数据类型长度
1.5.3 sizeof中表达式不计算
1.6 signed和unsigned 1.7 数据类型的取值范围
二、变量
2.1变量的创建
2.2变量的分类
三、算术操作符
3.1“/” 整除、
3.2“%” 取余
四、赋值操作符
6.1连续赋值
6.2符合赋值
五、单目操作符
5.1 ++ 和 --
5.1.1 前置++
5.1.2 后置++
5.2 + 和 -
总结
前言 大家好哦，bear又给大家跟新内容了。本节内容主要包含介绍各种数据类型、变量、各种操作符。大家跟上bear的脚步秩序前进冲鸭！
一、数据类型的介绍 C语⾔提供了丰富的 数据类型 来描述⽣活中的各种数据。 使⽤ 整型类型 来描述整数，使⽤ 字符类型 来描述字符，使⽤ 浮点型类型 来描述⼩数。 所谓“ 类型 ”，就是相似的数据所拥有的共同特征，编译器只有知道了数据的类型，才知道怎么操作 数据。 下⾯盘点⼀下C语⾔提供的各种数据类型，本章节主要探讨内置数据类型。 1.1 字符型 用来储存数据的一种类型，分为有符号和无符号。char 默认是有符号的！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85366e7b198bd664d072c3bd8a30a1b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e228a52ca239bfcee3cd7dc59db258eb/" rel="bookmark">
			【Spring Boot】统一异常处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 统一异常处理一. 概念二. 全局异常处理三. 处理特定异常 统一异常处理 一. 概念 其实统一异常是运用了AOP（对某一类事情的集中处理）的思维，简单概括就是在我们进行前后端数据交互的时候，抛出的任何的异常都能够自动捕获然后抛出，不用程序员在敲代码时格外关注try catch语句。
其实统一异常处理非常简单，在实现时要加入类注解@ControllerAdvice(这是一个表示控制通知的注解，在接下来的统一异常处理也要运用到)，并且有一点与统一数据返回不同的是,统一异常处理需要加上类注解@ResponseBody来确认返回的数据类型,然后在类中要进行捕获异常的方法上加上注解@ExceptionHandle即可。
二. 全局异常处理 处理全局异常代码如下:
import com.example.demo.model.Result; import org.springframework.web.bind.annotation.ControllerAdvice; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.ResponseBody; @ControllerAdvice @ResponseBody public class ErrorAdvice { /** * 全局异常处理 */ @ExceptionHandler public Object handler(Exception e) { return Result.fail(e.getMessage()); } } 这样程序抛出异常的时候，就会被该异常处理方法所捕获，并且返回统一异常处理的结果（JSON格式）！
三. 处理特定异常 处理特定异常代码如下:
import com.example.demo.model.Result; import org.springframework.web.bind.annotation.ControllerAdvice; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.ResponseBody; @ResponseBody @ControllerAdvice public class ErrorAdvice { @ExceptionHandler public Object handler(Exception e) { return Result.fail(e.getMessage()); } @ExceptionHandler public Object handler(NullPointerException e) { return Result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e228a52ca239bfcee3cd7dc59db258eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dac1ae02b127a0d279bb9ca8642010e6/" rel="bookmark">
			【Spring Boot】统一数据返回
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 统一数据返回一. 概念二.实现统一数据返回2.1 重写responseAdvice方法2.2 重写beforeBodyWriter方法 三. 特殊类型-String的处理四. 全部代码 统一数据返回 一. 概念 其实统一数据返回是运用了AOP（对某一类事情的集中处理）的思维，简单概括就是在我们进行前后端数据交互的时候，能够让后端的数据进行统一的打包封装，返回给前端，便于前后端的数据处理。
二.实现统一数据返回 其实统一数据返回非常简单，在实现时要加入类注解@ControllerAdvice(这是一个表示控制通知的注解，在接下来的统一异常处理也要运用到)，在添加类注解后还要在实现ResponseBodyAdvice接口，然后重写接口的responseAdvice接口和beforeBodyWriter方法即可实现。
添加类注解@ControllerAdvice，实现接口ResponseBodyAdvice重写responseAdvice方法重写beforeBodyWriter方法特殊数据类型特殊处理（String） 2.1 重写responseAdvice方法 responseAdvice方法如下：
@Override public boolean supports(MethodParameter returnType, Class converterType) { return true; } 可以看到，重写该方法主要返回的是Boolean数据类型，返回false表示不执行统一返回，返回true表示对于所有的数据类型都进行数据统一返回。
supports方法:判断是否要执行beforeBodyWrite方法.true为执行,false不执行.通过该方法可以
选择哪些类或哪些方法的response要进行处理,其他的不进行处理
2.2 重写beforeBodyWriter方法 beforeBodyWriter方法如下：
beforeBodyWrite方法:对response方法进行具体操作处理
其中的参数body最为重要，如果想要对统一后的数据进行格式的转换，直接转换body的格式就行，因为这里的body代指了所有的数据格式。
三. 特殊类型-String的处理 在经过多次不同的数据类型测试后发现，其它类型就可以顺利返回，而String类型却返回不正确。
对于String的数据类型如果想要返回，我们要先引入ObjectMapper，通过调用ObjeceMapper的writeValueAsString()方法来把body的数据格式给转换成Json格式，然后再次进行统一返回即可。
进行数据转换的代码如下：
private static ObjectMapper mapper = new ObjectMapper(); @Override public Object beforeBodyWrite(Object body, MethodParameter returnType,MediaType selectedContentType, Class selectedConverterType, ServerHttpRequestrequest, ServerHttpResponse response) { //如果返回结果为String类型, 使⽤SpringBoot内置提供的Jackson来实现信息的序列化 if (body instanceof String){ return mapper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dac1ae02b127a0d279bb9ca8642010e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bfb9c62fc6168b34d52f8d1dbea9430/" rel="bookmark">
			【AI 大模型】提示工程 ④ ( 自然语言处理 NLG | 自然语言理解 NLU | 自然语言生成 NLG | 使用 提示词 &#43; 大模型 实现 NLU | 使用 提示词 &#43; 大模型 实现 NLG )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、自然语言处理 NLP二、自然语言理解 NLU三、自然语言生成 NLG四、使用 提示词 + 大模型 实现 NLU五、使用 提示词 + 大模型 实现 NLG 一、自然语言处理 NLP 自然语言处理 ( NLP , Natural Language Processing ) , 指的是 " 人工智能 “ " 理解 " 和 ” 生成 " 人类语言的能力 , 包括
识别文本中的意图提取信息回答问题进行推理情感分析语言翻译 等多种任务 , 是一门 交叉学科 , 融合了 语言学、计算机科学、数学 等 多个学科领域 , 使用了如下技术 :
机器学习算法 , 如 : 分类、聚类、序列标注 ;深度学习模型 , 如 : 循环神经网络、Transformer 模型 ;统计模型 ; 自然语言处理 ( NLP , Natural Language Processing ) 主要包含
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bfb9c62fc6168b34d52f8d1dbea9430/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e639908c772e815f6d123c87bdf3c00e/" rel="bookmark">
			【雷丰阳-谷粒商城 】【分布式高级篇-微服务架构篇】【20】认证服务04—SSO单点登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		持续学习&amp;持续更新中…
守破离
【雷丰阳-谷粒商城 】【分布式高级篇-微服务架构篇】【20】认证服务04—SSO单点登录 xxl-sso多系统-单点登录单点登录流程原理图单点登录流程简单实现参考 xxl-sso https://gitee.com/xuxueli0323/xxl-sso
xxl-sso是开源的一个单点登录框架
一个分布式单点登录框架。只需要登录一次就可以访问所有相互信任的应用系统。 拥有"轻量级、分布式、跨域、Cookie+Token均支持、Web+APP均支持"等特性；。现已开放源代码，开箱即用。
C:\Windows\System32\drivers\etc\hosts（模仿三个域名）
#模拟单点登录 127.0.0.1 xxlssoserver.com 127.0.0.1 client1.com 127.0.0.1 client2.com 打包之前修改这三个的配置文件：
举例：修改客户端：
修改完成打包命令：（打包所有）
启动服务器
启动两个客户端：
自己测试：
C:\Users\lenovo\Desktop\xxl-sso\xxl-sso-server\target&gt;java -jar xxl-sso-server-1.1.1-SNAPSHOT.jar C:\Users\lenovo\Desktop\xxl-sso\xxl-sso-samples\xxl-sso-web-sample-springboot\target&gt;java -jar xxl-sso-web-sample-springboot-1.1.1-SNAPSHOT.jar --server.port=13000 C:\Users\lenovo\Desktop\xxl-sso\xxl-sso-samples\xxl-sso-web-sample-springboot\target&gt;java -jar xxl-sso-web-sample-springboot-1.1.1-SNAPSHOT.jar --server.port=12000 http://xxlssoserver.com:8080/xxl-sso-server/login
http://client1.com:12000/xxl-sso-web-sample-springboot/
http://client2.com:13000/xxl-sso-web-sample-springboot/
上面这三个地址，无论访问哪个都要求登录，并且一处登录，处处可用
多系统-单点登录 Single Sign On 一处登陆、处处可用（运行）
单点登录流程原理图 单点登录流程简单实现 认证服务：ssoserver.com:8080
@Controller public class LoginController { @Autowired StringRedisTemplate redisTemplate; /** * TODO 开放接口给其他系统，让它们用来查询 token 对应的用户信息，判断该用户是否登录过，实现单点登录 */ @ResponseBody @GetMapping("/userInfo") public String userInfo(@RequestParam("token") String token){ String s = redisTemplate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e639908c772e815f6d123c87bdf3c00e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2346caf8ed33d49527ce3a7e3e346a7/" rel="bookmark">
			零门槛用AI大模型，AI全能工具箱302.AI让人工智能AIGC变得简单易用！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在当今这个信息爆炸的时代，人工智能（AI）已经不再是遥不可及的高科技，而是逐渐融入我们的日常生活，成为我们解决问题的得力助手。提到AI，几乎每个人都能说上几句， 然而，对于许多人来说，AI的使用似乎仍然存在一定的门槛。
我和大家也一样，苦于找不到好用免费的AI工具而发愁，今天我就把自己的经历分享给大家，希望能有所帮助。
全能工具箱 学术论文搜索，一键搞定 在日常的研究和科研中，看论文几乎是每天都需要做的事情，而寻找一篇高质量的论文往往如同海底捞针。作为一名专注于人工智能领域的研究生，我最近就遇到了这样的困境。研究生导师给我布置了总结姿态技术的任务，但面对网上海量而杂乱的信息，我感到无从下手，无法找到自己真正需要的论文。
找论文的过程真的很花时间，在说完自己的困境后，同实验室的师兄向我推荐了302.AI平台的AI学术论文搜索工具，可以帮助我很好的寻找论文和辅助阅读，节省不必要的时间浪费。
抱着试一试的心态，会后我就立马使用了起来，让我最惊喜的是这个工具真的十分方便和全面！
点击我们要使用的工具，会出现这样的创建界面，需要我们选择自己需要的模型，可以说是非常人性化，自己根据需要选择想用的模型就可以：
令我十分惊讶的是，它竟然搜出了上万条的论文结果，所有论文应有尽有，并且我们可以根据提交日期和相关性进行排序，找到我们需要的匹配度最高的论文或者最新的论文。
可以在搜索列表中，直接打开想看的论文提供全文总结、全文翻译和AI解答功能！，大大提高我们的科研效率！
并且与其他的翻译软件不同，这款工具翻译出来的中文文章格式非常工整，并且文字异常清晰，真的有点震惊到我了，用过的翻译软件进行翻译时总会出现乱码和排版混乱的问题，而它工整的像是本来的文章就是中文一样！图片公式丝毫没有受到影响，强烈推荐每一位科研er。
应用机器人 聪明的聊天AI大模型 在聊天界面点击 【应用商店】，可快捷地选择不同的机器人。比如我这次就选择了BOOKS机器人，因为喜欢阅读，希望AI能为我推荐一下书，节省我的时间，顺便看一看AI BOOKS到底多厉害！
非常聪明的推荐了一本书，并列出详细信息和推荐这本书的理由，真的太方便了。
经过上面的实践，我对AI有了新的认识，原来AI与我们之间真的零距离。
零门槛，共享AI红利 官方网站：https://302.ai/
网站介绍：https://help.302.ai/ 特别福利，不容错过 现在，只要填写问卷即可获得1ptc的使用额度，要知道在低频使用情况下，1ptc（等效1美金，7人民币）可以使用GPT3.5约3个月时间，GPT4.0可以使用约2周时间，GPT4.0联网版可使用约1周时间，相比20美金的月费，性价比非常高，白嫖党赢麻了。
用了为了回馈给广大粉丝群体的支持，大家可以通过下面我分享链接免费进行试用（额度5ptc/天）亲身体验AI的无限可能：
AI体验链接： 分享码: 6876
每个人都可以无门槛的使用AI大模型！
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/189/">«</a>
	<span class="pagination__item pagination__item--current">190/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/191/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>