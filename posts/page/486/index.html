<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7e4843b75ad078cff297dbdf6a1fb83/" rel="bookmark">
			java stream 流遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题一： Exception in thread "main" java.lang.NullPointerException: element cannot be mapped to a null key
原因：当使用stream流进行分组，分组的 key 为 null 则报上述错误 @Data class Studet{ private int id; private String name; public Studet() { } public Studet(int id) { this.id = id; } } Map&lt;Integer, List&lt;Studet&gt;&gt; studentMap = Lists.newArrayList(new Studet(), new Studet(1), new Studet(2)) .stream().collect(Collectors.groupingBy(Studet::getId)); 问题二：Exception in thread "main" java.lang.IllegalStateException: Duplicate key 2
原因:当使用stream流转map时，当前集合中作为key的属性相同时则报上述错误。
@Data class Studet{ private int id; private String name; public Studet() { } public Studet(int id) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7e4843b75ad078cff297dbdf6a1fb83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/247ff30b616cab72339bd7a2e38bebdc/" rel="bookmark">
			Java中四种常用的数组复制的方法copyOf(),arraycop()，clone（）和copyOfRange()的使用与区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		所谓复制数组，是指将一个数组中的元素在另一个数组中进行复制。本文主要介绍关于 Java 里面的数组复制（拷贝）的几种方式和用法。
在 Java 中实现数组复制分别有以下 4 种方法：
1.Arrays 类的 copyOf() 方法
2.Arrays 类的 copyOfRange() 方法
3.System 类的 arraycopy() 方法
4.Object 类的 clone() 方法
下面来详细介绍这 4 种方法的使用。
使用 copyOf() 方法和 copyOfRange() 方法
Arrays 类的 copyOf() 方法与 copyOfRange() 方法都可实现对数组的复制。copyOf() 方法是复制数组至指定长度的（新）数组，copyOfRange() 方法则将指定数组的指定长度复制到一个新数组中。
1. 使用 copyOf() 方法对数组进行复制
Arrays 类的 copyOf() 方法的语法格式如下：
Arrays.copyOf(dataType[] srcArray,int length); 其中，srcArray 表示要进行复制的数组，length 表示复制后的新数组的长度。
使用这种方法复制数组时，默认从原数组的第一个元素（索引值为 0）开始复制，目标数组的长度将为 length。如果 length 大于 srcArray.length，则目标数组中采用默认值填充；如果 length 小于 srcArray.length，则复制到第 length 个元素（索引值为 length-1）即止。
注意：目标数组如果已经存在，将会被重构。
例1：
假设有一个数组中保存了 5 个成绩，现在需要在一个新数组中保存这 5 个成绩，同时留 3 个空余的元素供后期开发使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/247ff30b616cab72339bd7a2e38bebdc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfe28bee7ae3758b8d505167d3511f38/" rel="bookmark">
			This Python interpreter is in a conda environment, but the environment hasnot been activated.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 查看python版本时出现“This Python interpreter is in a conda environment, but the environment has not been activated. Libraries may fail to load. To activate this environment”的问题
原因 CMD 警告:“Python 解释器在 conda 环境中，但该环境尚未激活"。出现这个警告因为我们安装的是anaconda中带的python版本，python处于conda环境中，使用python需要激活。
解决办法 1、确认anaconda的环境：win+R+cmd打开命令控制窗口
2、查看当前环境名，运行：
在显示的环境中， * 前是环境的名字，* 后是环境的路径。比如这里是：
环境名：base 环境的路径：C:\ProgramData\Anaconda3
复制base后面的位置信息。
3、conda activate + base后面的路径，进行激活：
4、检验，激活成功：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc80c2acc9d4b4f82f82ad9ed357873a/" rel="bookmark">
			AIGC:语音克隆模型Bert-VITS2-2.3部署与实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 VITS2模型 1.1 摘要 单阶段文本到语音模型最近被积极研究，其结果优于两阶段管道系统。以往的单阶段模型虽然取得了较大的进展，但在间歇性非自然性、计算效率、对音素转换依赖性强等方面仍有改进的空间。本文提出VITS2，一种单阶段的文本到语音模型，通过改进之前工作的几个方面，有效地合成了更自然的语音。本文提出了改进的结构和训练机制，所提出的方法在提高多说话人模型中语音特征的自然度、相似性以及训练和推理效率方面是有效的。证明了所提出方法可以显著减少以前工作中对音素转换的强依赖，允许完全端到端单阶段方法。
论文地址：https://arxiv.org/pdf/2307.16430.pdf
演示地址：https://vits-2.github.io/demo/
VITS1讲解详见：https://mp.csdn.net/mp_blog/creation/editor/130904876
1.2 介绍 最近，基于深度神经网络的文本到语音的发展取得了重大进展。基于深度神经网络的文本到语音转换是一种从输入文本生成相应原始波形的方法；它有几个有趣的特性，通常使文本到语音任务具有挑战性。通过对特征的快速回顾，可以发现文本到语音任务涉及到将不连续的文本特征转换为连续的波形。输入和输出具有数百倍的时间步长差异，它们之间的对齐必须非常精确才能合成高质量的语音音频。此外，输入文本中不存在的韵律和说话人特征需要自然地表达，文本输入可以有多种说话方式，这是一个一对多的问题。合成高质量语音具有挑战性的另一个因素是，人们在听音频时专注于单个组件；因此，即使构成整个音频的数十万个信号中只有一小部分是非自然的，人类也可以很容易地感知它们。效率是导致任务困难的另一个因素。合成的音频具有很高的时间分辨率，通常每秒包含超过20,000个数据，需要高效的采样方法。
由于文本到语音的任务特点，解决方案也可以是复杂的。之前的工作通过将从输入文本生成波形的过程分为两个级联阶段来解决这些问题。一种流行的方法涉及从第一阶段的输入文本中生成中间语音表示，如梅尔语谱图或语言特征，然后以第二阶段的这些中间表示为条件生成原始波形。两级管道系统具有简化每个模型和便于训练的优点；然而，它们也有以下限制。
错误从第一阶段传播到第二阶段。它不是利用模型内部学习到的表示，而是通过人类定义的特征(如梅尔语谱图或语言特征)进行中介。生成中间特征所需的计算量。最近，为了解决这些限制，直接从输入文本中生成波形的单阶段模型已被积极研究。单阶段模型不仅优于两阶段管道系统，而且显示了生成与人类几乎不可区分的高质量语音的能力。 虽然之前的工作使用单阶段方法取得了巨大的成功，但模型vits存在以下问题：间歇性不自然、时长预测器效率低、输入格式复杂以缓解对齐和时长建模的局限性(使用空白标记)、多说话人模型中说话人相似性不足、训练速度慢以及对音素转换的依赖性强。本文提供了解决这些问题的方法。本文提出一种通过对抗性学习训练的随机时长预测器，利用transformer块和说话人条件文本编码器改进的归一化流，以更好地对多个说话人特征进行建模。实验结果表明，所提出的方法提高了质量和效率。此外，通过使用规范化文本作为模型输入的实验表明，该方法减少了对音素转换的依赖。因此，该方法更接近于完全的端到端单阶段方法。
1.3 模型 在本节中，我们描述了四个小节的改进：时长预测（duration prediction）、具有归一化流的增广变分自编码器（augmented variational autoencoder with normalizing flows）、对齐搜索（alignment search）和以说话人为条件的文本编码器（and speaker-conditioned text encoder）。本文提出一种使用对抗性学习来训练时长预测器的方法，以在训练和合成方面都具有较高的效率来合成自然语音。该模型本质上是使用上一项工作[4,17]中提出的单调对齐搜索(MAS)来学习对齐，并进一步建议进行修改以提高质量。提出了一种通过将transformer块引入到规范化流程中来提高自然性的方法，能在转换分布时捕获长期依赖。此外，本文还改进了多说话人模型中的说话人条件，以提高说话人相似度。
1.3.1 基于时间步进条件判别的随机时长预测器 之前的工作表明，基于流的随机时长预测器比确定性方法更有效地提高了合成语音的自然度。结果很好;然而，基于流的方法需要相对更多的计算和一些复杂的技术。本文提出一种具有对抗性学习的随机时长预测器，以合成更自然的语音，在训练和合成方面的效率都比之前的工作更高。建议的持续时间预测器和鉴别器的概述如图1a所示。我们应用对抗性学习来训练时间预测器，使用与生成器相同的输入条件判别器来适当区分预测的时间。我们使用文本的隐藏表示htext和高斯噪声zd作为生成器G的输入；使用MAS获得的对数尺度的htext和持续时间(以d表示)或从持续时间预测器(以dˆ表示)中预测的htext和持续时间(以d表示)作为鉴别器d的输入。一般生成对抗网络的鉴别器被输入固定长度的输入，而预测每个输入token的持续时间，并且输入序列的长度随每个训练实例而变化。为正确区分可变长度的输入，本文提出一种时间逐步判别器，可区分所有token的每个预测持续时间。我们使用两种类型的损失;对抗学习的最小二乘损失函数和均方误差损失函数：
提出的时长预测器和训练机制允许在较短的步骤中学习时长，并且时长预测器被单独训练作为最后的训练步骤，从而减少了训练的整体计算时间。
1.3.2 带高斯噪声的单调对齐搜索 在之前的工作之后，我们将MAS引入到我们的模型中来学习对齐。该算法产生了在所有可能的单调对齐中具有最高概率的文本和音频之间的对齐，并训练模型以最大化其概率。该方法是有效的;然而，在搜索和优化特定的对齐之后，搜索其他更合适的对齐会受到限制。为了缓解这个问题，我们在计算的概率中添加了一个小的高斯噪声。这为模型提供了额外的机会来搜索其他对齐。我们只在训练开始时添加这种噪声，因为MAS使模型能够快速学习对齐。参考之前的工作[4]，该工作详细描述了算法，正向操作中所有可能位置的Q值都计算出最大对数似然。我们在操作中计算的Q值上添加了小的高斯噪声。
其中i和j分别表示输入序列和后验序列上的特定位置，z表示来自标准化流的转换潜变量。是从标准正态分布中采样的噪声、P的标准差和从0.01开始并每步递减2×10^−6的噪声尺度的乘积。
1.3.3 使用Transformer块的归一化流 之前的工作展示了用归一化流增强的变分自编码器合成高质量语音音频的能力。归一化流包含卷积块，卷积块是捕获相邻数据模式的有效结构，使模型能够合成高质量的语音。在转换分布时，捕捉长期依赖关系的能力至关重要，因为语音的每个部分都与不相邻的其他部分相关。虽然卷积块可以有效捕获相邻模式，但由于其感受野的限制，在捕获长期依赖关系方面存在不足。因此，我们在归一化流中添加了一个带有残差连接的小transformer块，以捕获长期依赖关系，如图1b所示。图2显示了实际的注意力得分图和卷积块的感受野。可以确定，transformer块在变换分布时在不同位置收集信息，这是感受野不可能做到的。
1.3.4 说话人条件文本编码器 由于多说话人模型是根据说话人条件用单一模型合成多种特征的语音，表达每个说话人的个人语音特征是一个重要的质量因素，也是自然度的一个重要因素。已有工作表明，单阶段模型可以高质量地对多个说话人进行建模。考虑到说话人的特定发音和语调等特征会显著影响每个说话人的语音特征的表达，但输入文本中不包含这些特征，设计了一个以说话人信息为条件的文本编码器，通过在编码输入文本的同时学习这些特征来更好地模仿每个说话人的各种语音特征。我们将说话人向量设置在文本编码器的第三个transformer块上，如图1c所示。
1.4 实验 我们在两个不同的数据集上进行了实验。使用LJ语音数据集[20]验证自然度的提升，使用VCTK数据集[21]验证模型是否能更好地再现说话人特征。LJ语音数据集由单个说话者的13100个短音频片段组成，总长度约为24小时。音频格式是16位PCM，采样率为22.05 kHz，我们使用它没有任何操作。我们将数据集随机分为训练集(12,500个样本)、验证集(100个样本)和测试集(500个样本)。
VCTK数据集由109个具有不同口音的英语母语者发出的约44,000个短音频片段组成。音频剪辑的总长度约为44小时。音频格式为16位PCM，采样率为44.1 kHz。我们将采样率降低到22.05 kHz。我们将数据集随机分为训练集(43,470个样本)、验证集(100个样本)和测试集(500个样本)。采用80波段mel尺度谱图计算重建损失。与之前的工作[17]相比，我们使用相同的语谱图作为后验编码器的输入。快速傅里叶变换、窗口和跳数分别设置为1024、1024和256。
我们使用音素序列和规范化文本作为模型的输入进行了实验。我们使用开源软件[22]将文本序列转换为国际音标序列，并将该序列输入文本编码器。与之前的工作[17]相比，我们没有使用空白标记。对于规范化文本的实验，我们使用开源软件[23]用简单的规则规范化输入文本，并将其提供给文本编码器。
使用AdamW[24]优化器训练网络，β1 = 0.8， β2 = 0.99，权重衰减λ = 0.01。学习率衰减在每轮中以0.9991/8因子进行调度，初始学习率为2 × 10^−4。我们每一步为网络提供256个训练实例。继之前的工作[17]之后，应用带窗口的生成器训练。我们在四个NVIDIA V100 gpu上使用混合精度训练。生成波形的网络和持续时间预测器分别训练了800k和30k步。
1.5 结果 1.5.1 自然度评估 为了验证所提模型能够合成自然语音，进行了众包平均意见得分(MOS)测试。在听了从测试集中随机选择的音频样本后，打分者对他们的自然程度进行了从1到5的5分评分。考虑到之前的工作[17]已经显示出与人工记录相似的质量，我们还进行了比较平均意见分数(CMOS)测试，该测试适合通过直接比较来评估高质量样本。评价者在听了从测试集中随机选择的音频样本后，对他们相对偏好的自然程度进行了评分，总分为7分，从3到3分不等评价者被允许对每个音频样本进行一次评估。对所有音频样本进行归一化处理，以避免幅度差异对得分的影响。我们使用官方实现和之前工作[17]的预训练权重作为比较模型。评价结果见表1和表2a。该方法与已有工作[17]的MOS值差为0.09,CMOS值和置信区间分别为0.201和±0.105。实验结果表明，该方法显著提高了合成语音的质量。此外，我们使用[18]方法对CMOS进行了评估，该方法在不同的结构和训练机制下表现出良好的性能。为了评估，我们使用官方实现和预训练权重生成样本。实验结果的CMOS和置信区间分别为0.176和±0.125，表明该方法明显优于传统方法。
1.5.2 消融研究 为验证所提方法的有效性，进行了消融研究。为验证对抗学习训练的随机时间预测器的有效性，将其替换为具有相同结构的确定性时间预测器，并使用L2损失进行训练。确定性时间预测器的训练步骤与之前的工作[17]相同。为验证对齐搜索中使用的噪声调度的有效性，对模型进行无噪声训练。为了验证模型的有效性，在归一化流程中没有transformer模块的情况下对模型进行训练。评价结果如表1所示。确定性持续时间预测器、无噪声的对准搜索和无变压器块的归一化流的消融研究的MOS差值分别为0.14、0.15和0.06。由于不使用空白标记和线性语谱图，计算效率将得到提高，删除一些所提出的方法与之前的工作[17]相比，性能较低。实验结果表明，所提方法在提高图像质量方面是有效的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc80c2acc9d4b4f82f82ad9ed357873a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e99b5e000c79bbed1a1b4756fdb2e353/" rel="bookmark">
			Uniapp 和Vue3 小程序 获取页面dom 方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在写公司的小程序项目 技术框架 主要是Uniapp 和 Vue3
恰好有个需求是要 获取小程序页面dom 结构 用常见的vue3获取dom 结构不起效
记录一下
先给出正确答案
&lt;template&gt; &lt;view&gt; &lt;view&gt; &lt;view&gt;Html&lt;/view&gt; &lt;view id="target"&gt;Css&lt;/view&gt; &lt;view&gt;Javascrip&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script setup&gt; import { getCurrentInstance } from 'vue'; const instance = getCurrentInstance(); const query = uni.createSelectorQuery().in(instance); query.select('#target').boundingClientRect(data =&gt; { if (data) { console.log("获取到布局信息", data); // 这里返回的data就是我们需要的dom结构 } }).exec(); &lt;/script&gt; 同时记录下错误答案
const query = uni.createSelectorQuery().in(this); query.select('#target').boundingClientRect(data =&gt; { console.log(data) }).exec(); 缺少 getCurrentInstance 导入 会报错 vendor.js? [sm]:2306 TypeError: Cannot read property ‘route’ of undefined
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e99b5e000c79bbed1a1b4756fdb2e353/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ee87b99cf9a390160039e8c28d94b11/" rel="bookmark">
			好书推荐丨细说PyTorch深度学习：理论、算法、模型与编程实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 写在前面深度学习推荐图书内容简介作者简介 推荐理由粉丝福利写在最后 写在前面 本期博主给大家推荐一本深度学习的全新正版书籍，感兴趣的小伙伴快来看看吧~
深度学习 深度学习是机器学习的一个分支，它模仿人脑神经网络的工作原理进行复杂的数据处理和模式识别。在计算机科学中，深度学习通过构建多层非线性模型，对输入数据逐层进行特征提取与转换，从而达到对数据的高层抽象理解。
深度学习的核心在于“深度”二字，即其神经网络结构通常包含多个隐藏层。每一层的神经元通过对前一层输出的加权求和并经过激活函数处理后，生成更高级别的特征表示，直至输出层生成最终结果。这种分层的学习过程使得模型能够自动从原始数据中提取关键特征，无需人为设计复杂的特征工程。
深度学习已经在图像识别、语音识别、自然语言处理、推荐系统等领域取得了显著成果，如AlphaGo、自动驾驶技术等前沿应用就是深度学习技术的典型代表。同时，随着计算能力的提升以及大数据的发展，深度学习正不断拓宽其应用边界，持续推动人工智能领域的发展。
推荐图书 《细说PyTorch深度学习：理论、算法、模型与编程实现》
京东直达：https://item.jd.com/13789305.html
内容简介 《细说PyTorch深度学习：理论、算法、模型与编程实现》由业界专家编撰，采用理论描述加代码实践的思路，详细介绍PyTorch的理论知识及其在深度学习中的应用。全书分为两篇，共16章。第一篇为基础知识，主要介绍PyTorch的基本知识、构建开发环境、卷积网络、经典网络、模型保存和调用、网络可视化、数据加载和预处理、数据增强等内容；第二篇为高级应用，主要介绍数据分类、迁移学习、人脸检测和识别、生成对抗网络、目标检测、ViT等内容。该书内容涵盖PyTorch从入门到深度学习的各个方面，是一本基础应用与案例实操相结合的参考书。
《细说PyTorch深度学习：理论、算法、模型与编程实现》理论兼备实例，深入浅出，适合PyTorch初学者使用，也可以作为理工科高等院校本科生、研究生的教学用书，还可作为相关科研工程技术人员的参考书。
作者简介 凌峰，毕业于中国科学院大学，博士，从事机器学习、人工智能、图像处理和计算视觉的研究 与开发工作多年，发表多篇论文，拥有丰富的机器学习算法实现经验。
丁麒文，研究生毕业，主要从事图像处理、机器学习、人工智能和机器视觉领域的研究工作， 熟练运用基于Pytorch、TensorFlow等深度学习框架实现相关图像处理算法，并发表了多篇论文 。
推荐理由 《细说PyTorch深度学习：理论、算法、模型与编程实现》是一本专为深度学习爱好者和从业者精心编写的实用指南。
理论与实践相结合：该书不仅深入浅出地介绍了深度学习的基础理论知识，包括神经网络的原理、优化方法、正则化技术等核心内容，同时结合了实际案例，将这些理论知识融入到具体应用中，确保读者能够从底层理解到上层应用全面掌握。
PyTorch实战详解：书中以目前业界广泛应用且深受开发者喜爱的深度学习框架PyTorch为核心，详细阐述了如何使用PyTorch构建、训练和调试各种深度学习模型。作者通过丰富的代码实例，帮助读者快速掌握PyTorch进行深度学习开发的技能。
广泛覆盖深度学习领域：本书涵盖多种深度学习模型，如卷积神经网络（CNN）、循环神经网络（RNN）、长短时记忆网络（LSTM）、变分自编码器（VAE）以及生成对抗网络（GAN）等，并对每种模型的应用场景和实现细节进行了详尽解析。
适合不同层次读者：无论是初涉深度学习领域的入门者，还是希望进一步提升实战能力的专业人士，都可以从中受益。对于新手来说，它可以作为一本引导入门并迅速提升技术水平的教材；对于有经验的开发者，它则提供了一套系统性梳理和进阶学习的资源。
紧跟前沿动态：鉴于深度学习领域日新月异的发展，《细说PyTorch深度学习：理论、算法、模型与编程实现》在介绍基础的同时，也关注并涵盖了部分最新研究进展和技术动态，有助于读者保持对领域发展的敏锐洞察力。
综上所述，《细说PyTorch深度学习：理论、算法、模型与编程实现》是一本集学术严谨性和实践指导性于一体的高质量图书，无论是用于个人学习成长，还是作为教学参考资料，都是深度学习爱好者的不二之选。
粉丝福利 现在点赞收藏评论“人生苦短，我爱深度学习”评论区将随机抽取至多3名小伙伴免费赠书1本截止日期：2024年3月10日 写在最后 我是一只有趣的兔子，感谢你的支持！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e3a2d2a726a73a2ad69127803f2a2eb/" rel="bookmark">
			stable diffusion采样详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		采样：模型会在Latent Space中生成一个完全随机的图像，然后噪声预测器会从图像中减去预测的噪声。随着这个步骤的不断重复，最终得到一个清晰的图像。
Stable Diffusion在每个步骤中都会生成一张新的采样后的图像，整个去噪的过程，即为采样，使用的采样手段，即为采样器或称为采样方法
逆向采样过程：
在生成阶段，目标是从纯噪声状态开始，通过一系列步骤反向模拟扩散过程以去除噪声并生成清晰图像。这就是采样的核心环节。为了实现这一点，模型需要解一个与扩散过程相反的微分方程或随机过程，以便逐次减少噪声并重构出接近原始数据的概率分布中的样本。
为什么要求解微分方程？（微分方程在这里起着描述数据退化和复原过程的作用。对于Stable Diffusion模型，特别是基于常微分方程(ODE)或随机微分方程(SDE)的变种，模型需要能够预测在任意噪声水平下如何“去噪”给定的输入图像。通过求解这些微分方程，模型能够在每一步预测最优的更新量，从而使得当前的中间态更接近于真实数据而不是噪声。这种迭代去噪的方式允许模型控制生成过程，并最终得到高质量的输出图像。）
举个栗子，最简单的Euler采样
import numpy as np # 定义目标函数（假设我们有一个线性ODE dy/dt = f(t, y)） def f(t, y): # 这里以dy/dt = -y + x + 1为例 # 实际应用中请替换为你的函数f x = t * 2 # 假设x与t有关的一个示例项 return -y + x + 1 def euler(f, t0, y0, h, N): """ Euler方法实现 参数： f : 目标函数 t0 : 初始时间 y0 : 初始状态 h : 时间步长 N : 总步数 返回： t_list : 时间点列表 y_list : 对应时间点的状态列表 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e3a2d2a726a73a2ad69127803f2a2eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1350f93860acec31c70613d43778982d/" rel="bookmark">
			纯前端实现导出pdf文件（服务端不参与）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大致查阅了现阶段使用较多的几种方案,，大概有以下几种方式：
一、原生window.print()方法导出pdf
二、jspdf
三、jspdf + html2canvas
四、pdfmake
方案优点缺点window.print()1、兼容性最好
2、可以将任意内容导出成 pdf 文档, 甚至是非改页面上的内容1、调用方法时部分条件下导出pdf需要用户手动选择
jspdf 1. 调用方法创建 pdf 文件,对于简单的内容可直接使用，
2. 也可以将 dom 节点转换为 pdf
3、生成内容为文本可复制
1、对中文不友好，会有乱码，需要引入字体库解决乱码问题
2、本分dom内容转pdf效果较差, 丢失大量样式设置
3、如果想要导出的pdf文件中包含图片，视觉效果略微模糊
4、pdf分页不好处理
jspdf + html2canvas
1、在jspdf上将生成效果不佳的部分可以转成图片，适用于对样式有要求的场景
2、将乱码部分转为了图片，解决了中文乱码问题
3、没有预览点击即可保存 1、如果内容包含echart图表或者其它图表，该内容需要转图片
2、生成的pdf实际为图片，不支持复制
3、不同浏览器生成可能会有略微差异（页面周边留白部分差异）
4、由于整体效果为图片，导致pdf文件较大（两页2.5MB左右）
5、pdf分页不好处理
pdfmake1、分页好处理1、js对象定义文档内容，对数据结构有固定要求
2、图表依旧需要转图片 以上方式可有利弊，使用还需根据需求及pdf文件的复杂程度去综合考虑
方案一：原生window.print()
推荐两篇博主的文章即可了解到该方法的具体使用
1、聊一聊浏览器打印 - window.print
2、前端实现网页打印详解
个人测试效果如下
因为是后台管理系统，导出不想包含左侧菜单栏和顶部区域，所以只对company-detail类名div中的内容进行导出，做了一个临时导出按钮
假设该页面为想要导出的页面
点击打印如下
注：由于测试，代码中并没有去做样式处理，可以看到效果还不错，加上样式基本可以还原原来的页面，如果是项目需求更多的是文本，表格信息想导出，同时又能接受需要用户手动选择导出为pdf时，这个方案总体最好
方案二：jspdf
sPDF： 用于在浏览器中生成PDF文件。你可以在Vue项目中使用它，通过引入jsPDF库并编写相应的代码来生成PDF。
npm install jspdf import jsPDF from 'jspdf'; // 创建一个PDF实例 const pdf = new jsPDF(); // 添加内容 pdf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1350f93860acec31c70613d43778982d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/106407a334939a63524a53b33a7d95b0/" rel="bookmark">
			AI从截图直接生成代码、前端程序员的福音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介
项目可以将任何屏幕截图或设计转换为干净的代码（支持大多数框架）。来自领先公司的开发人员和设计师使用的排名第一的工具。完全开源，在 GitHub 上拥有超过 35,000 颗星。非常受欢迎。 各位小伙伴们感觉有帮助的，可以收藏一下，方便下次找到项目！
项目地址：https://screenshottocode.com/
这个简单的应用程序将屏幕截图转换为代码（HTML/Tailwind CSS、React、Bootstrap 或 Vue）。它使用 GPT-4 Vision 生成代码，并使用 DALL-E 3 生成外观相似的图像。您现在还可以输入 URL 来克隆实时网站！
项目实践
开始使用
带上您自己的 OpenAI 密钥 -您的密钥必须有权访问 GPT-4 Vision
本地
该应用程序有一个 React/Vite 前端和一个 FastAPI 后端。您将需要一个能够访问 GPT-4 Vision API 的 OpenAI API 密钥。运行后端（我使用 Poetry 进行包管理 -pip install poetry如果你没有它）：cd backendecho "OPENAI_API_KEY=sk-your-key" &gt; .envpoetry installpoetry shellpoetry run uvicorn main:app --reload --port 7001
运行前端：
cd frontendyarnyarn dev
打开http://localhost:5173以使用该应用程序。如果您希望在不同端口上运行后端，请更新 VITE_WS_BACKEND_URLfrontend/.env.local出于调试目的，如果您不想浪费 GPT4-Vision 积分，您可以在模拟模式下运行后端（该模式会传输预先录制的响应）：MOCK=true poetry run uvicorn main:app --reload --port 7001
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/106407a334939a63524a53b33a7d95b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fcd43aeb5a34d0f180ba68cffdc80f7/" rel="bookmark">
			Jenkins 任意文件读取(CVE-2024-23897)&#43;后台用户密码提取哈希破解&#43;反弹Shell 一条龙
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 本文将深入研究一项涉及Jenkins的安全漏洞（CVE-2024–23897），将在实验室中介绍这些概念，这些技能对于渗透测试期间有效管理输出至关重要，而在本次漏洞利用中，更显得尤为关键。
本文还涉及Jenkins凭证管理，针对Jenkins部署，指导参与者如何查找存储的用户和密码信息。更加刺激的是，我们将引导参与者使用Hashcat破解这些凭据，进一步揭露其中的安全挑战。
实验的一大亮点是反向Shell测试，要求学员使用Jenkins内置的Groovy脚本控制台建立反向Shell。通过一个非常典型的试错过程，参与者将亲身体验实现远程命令执行的刺激和挑战。
最后，我们将探讨权限升级，一旦shell访问得到保护，参与者将识别并利用设置了SUID位的二进制文件进行权限升级。
二、 Jenkins (CVE-2024–23897) 靶机主题 此次靶场攻击主题内容：
了解 CI / CD：参与者将从基础知识开始，了解 Jenkins 是什么及其通过持续集成/持续部署 (CI/CD)（Security+
认证的基本概念）实现软件开发自动化方面的作用。 文件描述符：实验室介绍了文件描述符，重点关注 STDOUT 和
STDERR，教参与者如何操作这些流。这些知识对于有效管理渗透测试期间的输出至关重要。输出抑制和重定向：以文件描述符为基础，参与者将练习根据所涉及的文件描述符抑制和重定向输出，这是任何有抱负的渗透测试人员工具包中的一项重要技能。Jenkins 凭证：该活动针对 Jenkins 部署，指导参与者如何查找存储的用户和密码信息。 使用 Hashcat
破解密码：参与者提取凭据并使用 Hashcat 破解它们。反向Shell测试：本实验的一大亮点，本部分要求学员使用Jenkins内置的Groovy脚本控制台建立反向Shell，通过一个非常典型的试错过程来实现远程命令执行。权限升级：一旦 shell 访问得到保护，参与者将识别并利用设置了 SUID 位的二进制文件来进行权限升级，了解 SUID
位的重要性及其在类 Unix 操作系统中的作用。 三、靶机配置 下载靶机：
https://drive.google.com/file/d/1YD7fyJIjPCV3FtUfnK7UbxlMnUdrvA6X/view
下载后给靶机生成一个MAC地址：
00:50:56:3D:BD:9B 配置之后开机，你是没有密码进行登陆的所以这个不理它
我们给靶机生成过了MAC，这个需要进行定义MAC，必须也要在一个局域网里！要不然找不到
sudo arp-scan --localnet | grep 00:50:56 ┌──(kali㉿kali)-[~] └─$ nmap -Pn -sC -sV 192.168.207.132 Starting Nmap 7.94 ( https://nmap.org ) at 2024-03-04 11:15 CST Nmap scan report for 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fcd43aeb5a34d0f180ba68cffdc80f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2947e493c6afe7bfda6976f5bd32736b/" rel="bookmark">
			小程序Taro框架 自定义底部Tabbar，处理自定义Tab栏切换卡顿、闪烁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最终效果 最近在用Taro框架开发一个小程序，有一个自定义底部Tabbar的需求，最终效果如下
起步 这页是我第一次接触自定义小程序底部Tabbar，所有第一选择必然是相看官方文档：微信小程序自定义 Tabbar | Taro 文档 （如果第一次做，请一定要仔细看这个文档）
按照文档正常配置app.config.js app.config.js
export default { tabBar: { custom: true, color: '#000000', selectedColor: '#000000', backgroundColor: '#000000', list: [ { pagePath: 'page/home/index', text: '组件', }, { pagePath: 'page/cart/index', text: '接口', }, ], }, } 配置tab页面usingComponents page/home/index.config.js
export default { navigationBarTitleText: '教材', usingComponents: {}, } page/cart/index.config.js
export default { navigationBarTitleText: '购物车', usingComponents: {}, } 开发 custom-tab-bar 设置 custom-tab-bar 组件 "component": true Demo
import { Component, useState } from 'react'; import { CoverImage, CoverView } from '@tarojs/components' import clx from 'classnames' import Taro from '@tarojs/taro'; import { View } from '@tarojs/components'; import ic_book from '@/static/images/ic_book@2x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2947e493c6afe7bfda6976f5bd32736b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce9c54356f3b3336c518fd7d8f6a6f5d/" rel="bookmark">
			【数据库】关系模式规范化（设计范式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 关系规范化第一范式 1NF第二范式 2NF函数依赖完全函数依赖传递依赖 第三范式 3NFBC范式 BCFN第四范式 4NF第五范式 5NF 关系规范化 关系数据库中的关系满足一定要求的，满足不同程度要求的为不同的范式。满足最低要求的叫第一范式，简称1NF；在第一范式的基础上满足进一步要求的称为第二范式，简称2NF，其余范式以此类推。
首先要明白”范式（NF）”是什么意思。按照教材中的定义，范式是“符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度”。
数据库范式也分为1NF，2NF，3NF，BCNF，4NF，5NF。
一般在我们设计关系型数据库的时候，最多考虑到BCNF就够。符合高一级范式的设计，必定符合低一级范式，例如符合2NF的关系模式，必定符合1NF。
关系模式”和“关系”的区别，类似于面向对象程序设计中”类“与”对象“的区别。”关系“是”关系模式“的一个实例，你可以把”关系”理解为一张带数据的表，而“关系模式”是这张数据表的表结构。
第一范式 1NF 定义： 属于第一范式关系的所有属性都不可再分，即数据项不可分。
理解： 第一范式强调数据表的原子性，是其他范式的基础。如下图所示数据库就不符合第一范式：
实际上，1NF是所有关系型数据库的最基本要求，你在关系型数据库管理系统（RDBMS），例如SQL Server，Oracle，MySQL中创建数据表的时候，如果数据表的设计不符合这个最基本的要求，那么操作一定是不能成功的。也就是说，只要在RDBMS中已经存在的数据表，一定是符合1NF的。如果我们要在RDBMS中表现表中的数据，就得设计为下表的形式：
但日常生活中仅用第一范式来规范表格是远远不够的，依然会存在数据冗余过大、删除异常、插入异常、修改异常的问题，此时就需要引入规范化概念，将其转化为更标准化的表格，减少数据依赖。
规范化：
每一名学生的学号、姓名、系名、系主任这些数据重复多次。每个系与对应的系主任的数据也重复多次——数据冗余过大
假如学校新建了一个系，但是暂时还没有招收任何学生（比如3月份就新建了，但要等到8月份才招生），那么是无法将系名与系主任的数据单独地添加到数据表中去的 （注１）——插入异常
注１：根据三种关系完整性约束中实体完整性的要求，关系中的码（注２）所包含的任意一个属性都不能为空，所有属性的组合也不能重复。为了满足此要求，图中的表，只能将学号与课名的组合作为码，否则就无法唯一地区分每一条记录。
注２：码：关系中的某个属性或者某几个属性的组合，用于区分每个元组（可以把“元组”理解为一张表中的每条记录，也就是每一行）。
假如将某个系中所有学生相关的记录都删除，那么所有系与系主任的数据也就随之消失了（一个系所有学生都没有了，并不表示这个系就没有了）。——删除异常
假如李小明转系到法律系，那么为了保证数据库中数据的一致性，需要修改三条记录中系与系主任的数据。——修改异常。
正因为仅符合1NF的数据库设计存在着这样那样的问题，我们需要提高设计标准，去掉导致上述四种问题的因素，使其符合更高一级的范式（2NF），这就是所谓的“规范化”。
规范化： 一个低一级的关系模式通过模式分解可以转化为若干个高一级范式的关系模式的集合，这个过程叫做规范化。
第二范式 2NF 定义： 若某关系R属于第一范式，且每一个非主属性完全函数依赖于任何一个候选码，则关系R属于第二范式。
此处我们需要理解非主属性、候选码和完全函数依赖的概念。
候选码：
若关系中的某一属性组的值能唯一地标识一个元组，而其子集不能，则称该属性组为候选码。若一个关系中有多个候选码，则选定其中一个为主码。
以下所有内容中，主码或候选码都简称为码。
例如下图所示的学生表中，学号和姓名都可以唯一标识一个元组，故该表的候选码为学号和姓名，主码我们可以随便选定其中一个，则选学号为主码。
学号姓名年龄性别101刘晨19女102王琪21男103张宇20男104李琛19女105欧阳慧20女 主属性：
所有候选码的属性称为主属性。不包含在任何候选码中的属性称为非主属性或非码属性。
在上面的学生表中，学号和姓名就是该关系的主属性，年龄和性别就是非主属性。
函数依赖 设R(U)是属性集U上的关系模式，X、Y是U的子集。若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则称Y函数依赖于X或X函数确定Y。
完全函数依赖 设R(U)是属性集U上的关系模式，X、Y是U的子集。如果Y函数依赖于X，且对于X的任何一个真子集X’，都有Y不函数依赖于X’，则称Y对X完全函数依赖。记作：如果Y函数依赖于X，但Y不完全函数依赖于X，则称Y对X部分函数依赖。
传递依赖 理解： 第二范式是指每个表必须有一个（有且仅有一个）数据项作为关键字或主键（primary key），其他数据项与关键字或者主键一一对应，即其他数据项完全依赖于关键字或主键。由此可知单主属性的关系均属于第二范式。
判断一个关系是否属于第二范式： 找出数据表中的所有码；找出所有主属性和非主属性；判断所有的非主属性对码的部分函数依赖。 图表示了表中所有的函数依赖关系：
码只有一个，就是**（学号、课名）。
主属性有两个：学号 与 课名
非主属性有四个：姓名、系名、系主任、分数
对于（学号，课名） → 姓名**，有 学号 → 姓名，存在非主属性 姓名 对码**（学号，课名）的部分函数依赖。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce9c54356f3b3336c518fd7d8f6a6f5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2b7dff893003a1e26998e96dcab6f2b/" rel="bookmark">
			python萌新爬虫学习笔记【建议收藏】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 发现宝藏前言1. 如何何请求解析url2. 如何获取标签里面的文本3. 如何解析JSON格式4. 如何添加常用的header5. 如何合并两个div6. 如何删除html dom的部分结构7. 如何一次性获取所有div标签里的文本8. python爬虫如何改变响应文本字符集编码9. 如何进行字符集转码10. response.text 和 respone.content的区别11. 如何发送post请求访问页面12. 如何获取 url 中的参数13. 如何下载图片 总结 发现宝藏 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。【宝藏入口】。
前言 为了巩固所学的知识，作者尝试着开始发布一些学习笔记类的博客，方便日后回顾。当然，如果能帮到一些萌新进行新技术的学习那也是极好的。作者菜菜一枚，文章中如果有记录错误，欢迎读者朋友们批评指正。
（博客的参考源码可以在我主页的资源里找到，如果在学习的过程中有什么疑问欢迎大家在评论区向我提出）
1. 如何何请求解析url 要解析 Python 中 Request 返回的 HTML DOM，你可以使用解析库，如 BeautifulSoup 或 lxml，来处理 HTML 文档。下面是使用 Beautiful Soup 和 lxml 的示例代码：首先，确保你已经安装了所需的库。对于 Beautiful Soup，你可以使用 pip install beautifulsoup4 进行安装。对于 lxml，你可以使用 pip install lxml 进行安装。使用 Beautiful Soup 库： BeautifulSoup 是一个 Python 库，用于网络爬虫目的。它提供了一种方便和高效的方式来从 HTML 和 XML 文档中提取数据。使用 BeautifulSoup，你可以解析和遍历 HTML 结构，搜索特定元素，并从网页中提取相关数据。 该库支持不同的解析器，如内置的 Python 解析器、lxml 和 html5lib，允许你根据特定需求选择最适合的解析器。BeautifulSoup 的优势在于它能够处理格式混乱或损坏的 HTML 代码，使其成为处理复杂情况下的网络爬虫任务的强大工具。 import requests from bs4 import BeautifulSoup # 发送请求获取 HTML response = requests.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2b7dff893003a1e26998e96dcab6f2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7402f04f722e89aaeaa2eaa6964be2a/" rel="bookmark">
			【cmake】pkg_check_modules 使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pkg_check_modules 主要通过 .pc 文件引入整个库，该命令会解析指定的 .pc 文件，并将所需的编译和链接信息提取到 CMake 变量中，以便后续使用。
目录
1、pkg_check_modules 的检索目录
2、pkg_check_modules 语法格式
3、应用：pkg_check_modules 引入 libavfilter.pc 3.1 使用 IMPORTED_TARGETS
3.2 不使用 IMPORTED_TARGETS
1、pkg_check_modules 的检索目录 一般情况下，pkg_check_modules 会在默认路径（标准路径）下寻找对应的 pc 文件，如 /usr/lib/pkgconfig、/usr/local/lib/pkgconfig，如果 .pc 文件位于非标准位置，可以通过设置 PKG_CONFIG_PATH环境变量来告诉 pkg-config 查找 .pc 文件的路径。
# ffmpeg 的pc文件位置：${PROJECT_SOURCE_DIR}/3rdparty/ffmpeg/lib/pkgconfig # 系统环境变量：PKG_CONFIG_PATH # 格式： set(ENV{PKG_CONFIG_PATH} "$ENV{PKG_CONFIG_PATH}:&lt;pc文件位置&gt;") set(ENV{PKG_CONFIG_PATH} "$ENV{PKG_CONFIG_PATH}:${PROJECT_SOURCE_DIR}/3rdparty/ffmpeg/lib/pkgconfig") 2、pkg_check_modules 语法格式 pkg_check_modules使用方法和 find_package 类似，基本语法如下:
pkg_check_modules(&lt;PREFIX&gt; REQUIRED|QUIET|OPTIONAL [IMPORTED_TARGETS] &lt;modules&gt;...) ① &lt;PREFIX&gt;
相当于为后续要引入的库起一个别名，这个别名会被用于多个地方，最典型的就是Cmake变量，头文件路径会被保存到 XXX_INCLUDE_DIRS，库文件路径会被保存到 XXX_LIB，而这里的 &lt;PREFIX&gt; 则用于替换变量中的 XXX
② REQUIRED | QUIT | OPTIONAL
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7402f04f722e89aaeaa2eaa6964be2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4facacc629301192692fdcf8f9a2e434/" rel="bookmark">
			IDEA切换JDK版本超详细步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 😀 IDEA切换JDK版本详细教程，全网步骤最详细，实测可用。
文章目录 第一步、选择SDKs切换SDK版本：第二步、选择Modules切换Sources和Dependencies版本：第三步、选择Project切换SDK和Language Level版本：第四步、在Settings中切换Java Compiler版本：总结：4大检查点 第一步、选择SDKs切换SDK版本： 依次点击File——&gt;Project Structure——&gt;SDKs，如果没有相应版本点③添加，有相应版本直接点④选择即可，如这里选择SDK17：
第二步、选择Modules切换Sources和Dependencies版本： 接着上一步，还是在Project Structure中，选中Moudles，点②选择模块或者项目后点击Sources选择与第一步SDK对应的版本17：
接着点击Dependencies选择与第一步SDK对应的版本17：
第三步、选择Project切换SDK和Language Level版本： 依次选择SDK和Language Level切换版本，选择与第一步SDK对应的版本17，最后记得点Apply和OK来保存设置。
第四步、在Settings中切换Java Compiler版本： 依次点击File——&gt;Settings——&gt;Build, Execution, Deployment——&gt;Compiler——&gt;Java Compiler，点击③和④选择与第一步SDK对应的版本17，最后记得点Apply和OK来保存设置：
总结：4大检查点 ①File——&gt;Project Structure——&gt;Project；②File——&gt;Project Structure——&gt;Modules；③File——&gt;Project Structure——&gt;SDKs；④File——&gt;Settings——&gt;Build, Execution, Deployment——&gt;Compiler——&gt;Java Compiler 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cb9942030ded135b472241c1c1eb82d/" rel="bookmark">
			JDK收费的各个版本（记录一下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JDK收费的各个版本（记录一下）
Java收费的安装包使用的时候要闭坑
从2019年1月份开始，Oracle JDK 开始对 Java SE 8 之后的版本开始进行商用收费，确切的说是 8u201/202 之后的版本。如果你用 Java 开发的功能如果是用作商业用途的，如果还不想花钱购买的话，能免费使用的最新版本是 8u201/202。当然如果是个人客户端或者个人开发者可以免费试用 Oracle JDK 所有的版本。
Java11 的性能提升
仅通过切换到 Java 11 就有 16％ 的改进，这种改进可能是因为 Java 10 中引入了 JEP 307: Parallel Full GC for G1。
具体如下：
JDK8 之前版本，仍然免费。
JDK8 免费版本到 8u202，从 8u211版本开始收费。
JDK9、JDK10，全版本免费。
JDK11，免费版本到 11.0.2，从 11.0.3 版本开始商用收费。
JDK12、JDK13、JDK14、JDK15、JDK16，全版本商用收费。
JDK17、JDK18、JDK19、JDK20，全版本(二进制版本)免费。
也就是说
一、免费版本
Java的免费版本包括以下几个版本：
4(1.4)
5(1.5)
6
7
8(update 211以前)
9
10
17
这些版本都可以供用户自由下载和使用，无需支付任何费用。用户不仅可以使用Java的基本功能，还可以无限制地发布和分发自己的应用程序。
二、付费版本
Java的付费版本包括以下几个版本：
8(update 211以后)
11～16
这些版本的许可证价格根据不同的用途和规模而有所不同。对于绝大多数个人开发者和小型企业来说，采用免费版本已经足够，没有必要购买付费版本，除非用户需要使用高级功能、服务或支持。
对比免费版本和收费版本，较高级别的版本包含更多的功能和技术支持服务。付费版本为用户提供了更高的技术支持，并且用户可以从新版本的升级中受益。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cb9942030ded135b472241c1c1eb82d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ade6b1dd1ed8d9aa906db74ef49d792/" rel="bookmark">
			WebLogic：管理控制台中常用超时配置项的分析与说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、超时参数 WebLogic作为服务器端，其控制台中部分常用的与超时相关配置项如下：
1、登录超时
MBean属性：ServerMBean.LoginTimeoutMillis
控制台中的位置：【环境】-&gt;【服务器】-&gt;【&lt;应用服务器名&gt;】-&gt;【配置】-&gt;【优化】
2、空闲连接超时
MBean属性：ServerMBean.IdleConncetionTimeout
控制台中的位置：【环境】-&gt;【服务器】-&gt;【&lt;应用服务器名&gt;】-&gt;【协议】-&gt;【一般信息】
3、完整消息超时
MBean属性：ServerMBean.CompleteMessageTimeout
控制台中的位置：【环境】-&gt;【服务器】-&gt;【&lt;应用服务器名&gt;】-&gt;【协议】-&gt;【一般信息】
4、连接保活超时
MBean属性：WebServerMBean.KeepAliveSecs
控制台中的位置：【环境】-&gt;【服务器】-&gt;【&lt;应用服务器名&gt;】-&gt;【协议】-&gt;【HTTP】
5、POST报文处理超时
MBean属性：WebServerMBean.PostTimeoutSecs
控制台中的位置：【环境】-&gt;【服务器】-&gt;【&lt;应用服务器名&gt;】-&gt;【协议】-&gt;【HTTP】
下面将以WebLogic12.2.1.4.0为例，逐一分析这些配置项是什么意思，以及如何使用。
1、登录超时 官方解释：
The login timeout for this server's default regular (non-SSL) listen port. This is the maximum amount of time allowed for a new connection to establish.
A value of 0 indicates there is no maximum.
MBean Attribute:
ServerMBean.LoginTimeoutMillis Minimum value: 0 Maximum value: 100000 Secure value: 5000
https://docs.oracle.com/en/middleware/fusion-middleware/weblogic-server/12.2.1.4/wlach/pagehelp/Corecoreserverserverconfigtuningtitle.html#attributes
代码分析：
1）com.oracle.weblogic.server.channels.jar
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ade6b1dd1ed8d9aa906db74ef49d792/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7813c994ca0463c00e02794b37598089/" rel="bookmark">
			2024年MySQL 下载、安装及启动停止教程（非常详细），涉及命令行net start mysql80提示发生系统错误5的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装包下载 官方网址： https://www.mysql.com/ MySQL 官方提供了两种不同的版本： 1.社区版本（ MySQL Community Server ） ：免费， 但MySQL 不提供任何技术支持 2.商业版本（ MySQL Enterprise Edition） ：收费，可以使用 30 天，提供技术支持 选择DOWNLOADS向下滑动页面，可找到图2所示内容，可选择商业版本或社区版本进行下载
选择自己电脑系统对应的链接，我选择的是Windows系统
进入下载界面会有两个下载选项，第一个是通过联网在线安装，会在线下载安装包，第二个是离线安装，下载到本地后进行安装，这里我选择的是第二个下载
接下来是是否选择注册账户，选择“No thanks，just start my download.”就能直接进行下载
二、进行安装 双击安装包即可进入安装准备页面
等待一会就会出现这个页面
然后就会进入安装界面，选择默认的开发者模式
点击Execute检查所安装的环境是否正确
检查完毕后，选择同意，进行安装
然后安装结束后，刚刚的页面就会被自动打勾，选择Next继续
接下来同样，Execute进行安装
安装结束，Next继续
Next
进入配置界面，端口号是3306，不需要进行什么改动，继续Next
依旧选择默认选项，Next
进入账户及角色的设置页面，设置好密码并重复一遍，密码简单会被提示weak，但不用在意
然后设置MYSQL的在系统中的名称，采用默认即可，继续Next
授权服务器文件权限，也就是选择是否希望MYSQL更新位于下面显示路径中的文件和文件夹的权限，来保护服务器的数据目录
然后选择Execute
Finish
Next
至此，安装完毕，点击Finish
三、如何启动和停止 方法1 win+R，在Windows命令行中输入services.msc进入Windows系统
然后找到m开头的，可以看到MySQL是启动的状态，因为MySQL是默认开机自启的，右键点击可选择启动或停止 方法2 win+R，在Windows命令行中输入cmd，然后输入net stop mysql80停止，输入net start mysql80启动，不区分大小写，但我的会报错
找到一个解决方法，说这里可能是因为我当时安装在C盘的原因，但我做完没用，大家可以试试，MySQL启动服务时发生系统错误 5，拒绝访问且管理员权限无效、net start mysql 服务名无效解决方法_启动mysql发生系统错误 5。 拒绝访问。-CSDN博客需要进方法一中的这个界面，找到MySQL，单击右键，属性
点击登录，把此账户选项改为本地系统账户
第二个解决方法是找到cmd，在下图所示路径中cmd如何默认以管理身份运行_执行 cmd 默认管理员运行-CSDN博客
然后右键-发送到-桌面快捷方式，再从桌面上右键-属性-快捷方式-高级
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7813c994ca0463c00e02794b37598089/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/996c22a0c1b191f946ebd3d671243cea/" rel="bookmark">
			数据结构和算法——图书馆管理系统（含代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、项目介绍................................ 二、设计方案及规划.................... 三、设计内容及步骤.................... 一、项目介绍 1.课程项目需求分析描述
1.结合c语言中的相关知识，进行项目课程的设计编译运行。充分调用c语言中，数值、循环、函数、结构体等知识点。
2．代码编译运行正常，符合 项目要求，系统相关功能可以正常运行。
3．充分学习和巩固c语言对课程设计的运用。
4．对于图书管理系统，能够区分出用户与管理员。分别具有的各项功能。图书的新增、修改和删除功能，查看图书的借阅排名和图书的借阅和归还。
5.对于书籍增加评论，提高用户的使用体验。
2.课程设计目的
1.充分调动和巩固已学的c语言知识。
2.更好的，更加灵活的对于数据结构与算法的运用。
3.增加对于项目的设立和完善，最后取得成功的经验。
4.提高发现问题，寻找解决方案的综合能力。
3.课程设计要求
1．项目逻辑思维清晰，页面菜单整洁。
2．代码编译运行正常。
3．代码结构严谨，分工明确。
4．图书管理系统功能项目完善。
4.课程设计意义
让学生能够更好的学习和运用数据结构与算法的知识。加以巩固相关知识，更好的完成好项目。提高学生面对困难，寻找解决方案的能力。发挥承上启下的作用，巩固好已学知识，为以后的课程学习打好基础。提高学生对于系统化使用知识的调用，在完成项目中增加经验，提高编译能力。
二、设计方案及规划 （一）、设计方案
顺应时代的发展潮流，计算机科学的迅猛发展，科技的进步，相关行业越来越在使用电子化发展了。面对图书馆登记借阅和图书信息保存，这些工作需要纸质保存，更新效率不高，对于读者和图书管理员都比较繁琐。
因此决定，使用c语言来设计图书管理系统，更好服务于读者和管理员的工作。结合C语言知识点：变量、数组、结构体、结构体数组、循环、条件判断等，
（二）、设计规划
第一天:
画出相应的流程图,并且完成管理员使图书信息增加,并使图书编号,名称,价格等各种信息的显示功能.
第二天:
完成管理员可以使图书信息的修改,删除,功能.
第三天:
完成用户可以使用,图书单条评论功能,并显示评论,修改单条评论功能.
第四天:
使用户可以多条评论,并且实现可以修改各条评论的功能,并且显示图书的评论数及评论,管理员可以删除评论功能.
第五天:
增加用户的借阅功能,归还功能,并且使图书状态可以随用户借阅和归还而发生改变.
第六天:
增加可以使用图书名称查找功能,调试代码,使之实现以上的各种功能,制作ppt
第七天:
完善代码,进行答辩.
三、设计内容及步骤 设计内容：
设计管理员和用户页面设计管理员的功能设计用户的功能目的：使用c语言对于图书实现智能化，实现管理员的增加、删除和修改等功能，并设计出用户的借阅、归还等功能。提高工作效率，减轻负担。
（包括目的说明和安装配置过程示意图）
安装开发工具dev C++:
1.访问Dev-C++官网. 2.运行安装程序. 3.选择偏好的语言. 4.接受许可协议. 5.选择目标文件夹. 6.选择要安装的组件. 7.创建快捷方式. 8.检查选项并开始安装. 9.等待安装完成. 10.点击完成,退出设置向导. 代码如下 #include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#define MAX_BOOK 1000
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/996c22a0c1b191f946ebd3d671243cea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a014a24e24e2792bd3ae5d7243547aa9/" rel="bookmark">
			python生成可视化操作界面,python怎么做可视化界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，本文将围绕python做出的炫酷的可视化展开说明，python可视化界面编程工具是一个很多人都想弄明白的事情，想搞清楚python如何生成可视化界面需要先了解以下几个事情。
Source code download: 本文相关源码
大家好，小编来为大家解答以下问题，python gui可视化操作界面制作，python做出的炫酷的可视化，现在让我们一起来看看吧！
目录
前言
一.环境配置
插件：
1.python
2.Chinese
3.Open In Default Browser
安装python数据可视化的库 pyecharts库
二.制作可视化大屏
从网站中找示例图
1、小编自己做过的各省份车辆销售数量图
2、数据对比类型
3、渐变圆柱
4、饼图
制作大屏
1、制作一个大屏
2、运行下面的代码后会在ipynb所在的目录下生成一个HTML文件，会将示例图汇总到HTML中，在html中调整各个图形的位置和大小
3、最后通过一下代码来调整显示示例图在大屏中的位置
总结
前言 本文章是用网站的示例图用python汇总后用html在网页中实现数据可视化，最后达到数据大屏的效果
一.环境配置 小编用的软件：Visual Studio Code 插件： 1.python 这个插件是Visual Studio代码扩展，丰富地支持Python语言（适用于该语言的所有受支持版本：&gt;=3.7），包括IntelliSense（Pylance）、linting、调试、代码导航、代码格式化、重构、变量资源管理器、测试资源管理器等功能！ 2.Chinese 这个插件是将Visual Studio Code页面中文化的插件，对一些英语不太好的程序员是比较友好的
3.Open In Default Browser 这个插件我是方便使用一些html的文件时可以在Visual Studio Code中直接跳转到网页中所用的，如：
安装python数据可视化的库 pyecharts库 打开anaconda prompt
安装pip install pyecharts==1.9 -i Simple Index
查看是否成功 pip show pyecharts
所用到的环境就安装好啦！接下来就可以用python制作可视化大屏啦
二.制作可视化大屏 从网站中找示例图 1.我们可以从下面的网站中任意找3-6个可视化示例图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a014a24e24e2792bd3ae5d7243547aa9/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/485/">«</a>
	<span class="pagination__item pagination__item--current">486/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/487/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>