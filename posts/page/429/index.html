<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23eff7adacd50213707a3a1cfd5f7d64/" rel="bookmark">
			vue混入（mixins）的使用方法和注意点，2024年最新前端优秀实践指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue中的解释是这样的，如果觉得语言枯燥的可以自行跳过嘿~
混入 (mixins)： 是一种分发 Vue 组件中可复用功能的非常灵活的方式。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项。
怎么用？
举个栗子：
定义一个混入对象
把混入对象混入到当前的组件中
用法似不似相当简单呀
mixins的特点
1 方法和参数在各组件中不共享
混合对象中的参数num
组件1中的参数num进行+1的操作
组件2中的参数num未进行操作
看两组件中分别输出的num值
大家可以看到，我在组件1里改变了num里面的值，组件2中的num值还是混入对象里的初始值
自我介绍一下，小编13年上海交大毕业，曾经在小公司待过，也去过华为、OPPO等大厂，18年进入阿里一直到现在。
深知大多数前端工程师，想要提升技能，往往是自己摸索成长或者是报班学习，但对于培训机构动则几千的学费，着实压力不小。自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《2024年Web前端开发全套学习资料》，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友，同时减轻大家的负担。
既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，基本涵盖了95%以上前端开发知识点，真正体系化！
由于文件比较大，这里只是将部分目录大纲截图出来，每个节点里面都包含大厂面经、学习笔记、源码讲义、实战项目、讲解视频，并且后续会持续更新
如果你觉得这些内容对你有帮助，可以添加V获取：vip1024c （备注前端）
ES6
列举常用的ES6特性：
箭头函数需要注意哪些地方？
let、const、var
拓展：var方式定义的变量有什么样的bug？
Set数据结构
拓展：数组去重的方法
箭头函数this的指向。
手写ES6 class继承。
微信小程序
简单描述一下微信小程序的相关文件类型?
你是怎么封装微信小程序的数据请求？
有哪些参数传值的方法？
你使用过哪些方法，来提高微信小程序的应用速度？
小程序和原生App哪个好？
简述微信小程序原理？
分析微信小程序的优劣势
怎么解决小程序的异步请求问题？
其他知识点面试
webpack的原理
webpack的loader和plugin的区别？
怎么使用webpack对项目进行优化?
防抖、节流
浏览器的缓存机制
描述一下二叉树, 并说明二叉树的几种遍历方式?
项目类问题
笔试编程题：
最后 技术栈比较搭，基本用过的东西都是一模一样的。快手终面喜欢问智力题，校招也是终面问智力题，大家要准备一下一些经典智力题。如果排列组合、概率论这些基础忘了，建议回去补一下。
一个人可以走的很快，但一群人才能走的更远。不论你是正从事IT行业的老鸟或是对IT行业感兴趣的新人，都欢迎扫码加入我们的的圈子（技术交流、学习资源、职场吐槽、大厂内推、面试辅导），让我们一起学习成长！
下一些经典智力题。如果排列组合、概率论这些基础忘了，建议回去补一下。
一个人可以走的很快，但一群人才能走的更远。不论你是正从事IT行业的老鸟或是对IT行业感兴趣的新人，都欢迎扫码加入我们的的圈子（技术交流、学习资源、职场吐槽、大厂内推、面试辅导），让我们一起学习成长！
[外链图片转存中…(img-vYW6yE03-1712778623776)]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df26a9e272a53952a6c9d65624dedaa6/" rel="bookmark">
			2024最新AI系统【SparkAI】，ChatGPT商业运营版系统源码/ai问答/ai绘画/GPTs，SunoAI音乐生成大模型/带分销AIGC搭建部署教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、文章前言 SparkAi创作系统是基于ChatGPT进行开发的ai智能问答系统和Midjourney-AI绘画系统，支持OpenAI-GPT全模型+国内AI全模型。本期针对源码系统整体测试下来非常完美，那么如何搭建部署AI创作ChatGPT？小编这里写一个详细图文教程吧。已支持GPTs、GPT语音对话、GPT-4模型、DALL-E3文生图、图片对话能力上传图片，GPT4-All联网搜索模型、文档分析、Midjourney绘画动态全功能、AI换脸、垫图混图、插件功能、支持最近火爆的Suno-v3-AI音乐生成大模型。
《SparkAI系统介绍文档 - 渐进式AIGC系统》:
SparkAI系统介绍文档 - 渐进式AIGC系统
1.1 系统架构技术栈 前端： Vite + vue3 + ts + NaiveUI + Tailwindcss
管理端：Vite4 + Vue3 + Element-Plus
服务端（后端）：Nodejs + NestJs
数据支持： Mysql5.7(+) + Redis
运行环境：Linux、Windows、MacOs（推荐使用Linux）
数据存储：本地存储 | 阿里云oss | 腾讯云cos | chevereto图床
1.2 特色功能 ①语音对话功能 支持电脑PC浏览器和手机端使用，具有”人的语气“
​
②GPTs ​
③GPT4-All联网搜索模型 ​
④文档分析 ​
⑤Suno-v3-AI音乐生成 ​
⑥Midjourney局部编辑重绘 ​
⑦说图解文 ​
1.3 程序核心功能 已支持 OpenAI GPT全模型 + 国内AI全模型 + 绘画系统 +GPTs+ MJ局部编辑重绘功能+语音对话功能 + 文档分析功能 + Midjourney绘画动态全功能+插件功能！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df26a9e272a53952a6c9d65624dedaa6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6364d39032ca7de8d9d4e1443543ed84/" rel="bookmark">
			【负载均衡 SLB介绍及其算法详解】(1)，2024年最新已成功拿下字节、腾讯、脉脉offer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		缺点
【5】加权最小连接数（Weighted Least Connections）
工作原理
示例
优点
缺点
【6】IP哈希（IP Hash）
工作原理
示例
优点
缺点
【7】公平队列调度（Fair Queueing）
工作原理
示例
优点
缺点
五、会话保持（Session Persistence）
会话保持策略
六、健康检查（Health Check）
类型
常用场景
七、水平扩展（Horizontal Scaling）
优势
挑战
使用场景
结语
原创文章，版权所有，侵权必究。
All rights reserved; those responsible for unauthorized reproduction will be prosecuted。
一、负载均衡 SLB 定义 负载均衡 SLB（Server Load Balancing）是指通过使用专门的设备或软件，将网络流量平均地分发到多个服务器上，确保每个服务器都能够有效地处理请求。这种平衡负载的方法可以提高系统的整体性能，防止某一台服务器过载，并提高服务的可用性和稳定性。
二、负载均衡SLB的作用 负载均衡（SLB）在IT领域的作用是优化网络和系统性能，提高服务的可用性和稳定性。其核心目标是将工作负载均匀地分布到多个服务器上，以防止某一台服务器过载，从而确保整个系统能够更高效地处理请求。以下是负载均衡的主要作用：
性能优化： 负载均衡通过将流量分发到多个服务器上，有效地提高了系统的整体性能。每台服务器都只需处理部分请求，因此可以更有效地利用资源，降低每台服务器的负载，减少响应时间，提高用户体验。
可用性提高： 负载均衡器定期检查服务器的健康状态，如果某台服务器发生故障或不可用，负载均衡器可以自动将流量转移到其他正常运行的服务器上。这种自动故障转移提高了整个系统的可用性，确保服务在部分服务器故障的情况下仍然可用。
容错性增强：负载均衡器可以配置多个服务器来处理相同的请求，从而提高容错性。如果一个服务器发生故障，负载均衡器可以将流量转移到其他服务器，确保服务的连续性。
水平扩展： 负载均衡器支持系统的水平扩展，即通过添加更多的服务器来增加系统的容量和性能，而无需修改应用程序代码。这使得系统更容易适应不断增长的用户和流量。
资源利用均衡： 负载均衡器通过动态分配请求，确保每台服务器都得到合理的负载。这样可以最大程度地利用系统资源，防止某一台服务器过度负载，提高整个系统的效率。
会话管理： 一些应用程序需要保持用户的会话状态，确保用户的所有请求都被发送到同一台服务器。负载均衡器可以支持会话保持，确保用户在整个会话期间都与同一台服务器进行通信。
灵活性和可扩展性： 负载均衡器提供了灵活的配置选项，可以根据需要进行调整。它使系统更具可扩展性，可以适应不同规模和需求的应用程序。
总体而言，负载均衡在现代网络和应用程序架构中是不可或缺的组成部分，通过优化资源利用、提高可用性和容错性，为用户提供更好的服务体验。
三、负载均衡器（Load Balancer） 负载均衡器（Load Balancer）是一种网络设备、服务或软件应用程序，其主要功能是在多个服务器之间分配工作负载，确保每台服务器都能够有效地处理请求。深入了解负载均衡器涉及到其工作原理、主要功能和一些关键概念。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6364d39032ca7de8d9d4e1443543ed84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/334ff706c9187302e40d522e2ccf945e/" rel="bookmark">
			层层剥开Android14升级后异常弹框的神秘面纱_此应用与最新版 android 不兼容。请检查是否有更新,或与应用开发者联系。(1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接下来，我们对这两个异常弹框依次来分析。
问题分析和解决方案 由于两个异常弹框都是由系统主动弹出的，应用层面没有办法去干扰此流程。因此，要想分析这两个问题，我们只能通过系统源码找到弹框提示文字，进而找到对应的代码查看逻辑，分析源码进而找到解决方案。
问题一 通过搜索关键字 此应用与最新版 Android 不兼容。请检查是否有更新，或与应用开发者联系。,我们能够搜索到在Framework层的字符串资源文件中name为 deprecated_abi_message对应的字符串就是我们搜索的关键字。
接下来我们通过namedeprecated_abi_message继续搜索，可以找到该字符串在系统中只在一个地方使用了，以下是它使用的代码：
class DeprecatedAbiDialog extends AppWarnings.BaseDialog {
//省略无关代码…
final CharSequence message = context.getString(R.string.deprecated_abi_message);
final AlertDialog.Builder builder = new AlertDialog.Builder(context)
.setPositiveButton(R.string.ok, (dialog, which) -&gt;
manager.setPackageFlag(
mPackageName, AppWarnings.FLAG_HIDE_DEPRECATED_ABI, true))
.setMessage(message)
.setTitle(label);
//省略无关代码…
}
很清楚的可以看到这个字符串被使用创建成了一个AppWarnings.BaseDialog类型的弹框。离目标代码很近了，我们继续顺着源码找到DeprecatedAbiDialog类在哪里被调用以及它被调用的逻辑是什么。
通过搜索我们可以找到以下调用：
最终我们可以看到弹框的调用逻辑如下：
public void showDeprecatedAbiDialogIfNeeded(ActivityRecord r) {
//省略无关代码…
if (is64BitDevice &amp;&amp; appContainsOnly32bitLibraries) {
mUiHandler.showDeprecatedAbiDialog®;
}
}
自此我们终于找到了问题1异常弹框的触发逻辑。如果设备为64位指令集并且当前应用仅仅包含32位指令集的包，那么就会弹出问题1的异常弹框。
问题一解决方案 通过对问题1的分析，我们知道如果碰到该提示。我们的问题解决方案是 在项目的build.gradel文件的ndk部分添加arm64-v8a的指令集
问题二 自我介绍一下，小编13年上海交大毕业，曾经在小公司待过，也去过华为、OPPO等大厂，18年进入阿里一直到现在。
深知大多数HarmonyOS鸿蒙开发工程师，想要提升技能，往往是自己摸索成长或者是报班学习，但对于培训机构动则几千的学费，着实压力不小。自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《2024年HarmonyOS鸿蒙开发全套学习资料》，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友，同时减轻大家的负担。
既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，基本涵盖了95%以上HarmonyOS鸿蒙开发知识点，真正体系化！
由于文件比较大，这里只是将部分目录大纲截图出来，每个节点里面都包含大厂面经、学习笔记、源码讲义、实战项目、讲解视频，并且会持续更新
如果你觉得这些内容对你有帮助，可以添加VX：vip204888 （备注鸿蒙获取）
一个人可以走的很快，但一群人才能走的更远。不论你是正从事IT行业的老鸟或是对IT行业感兴趣的新人，都欢迎扫码加入我们的的圈子（技术交流、学习资源、职场吐槽、大厂内推、面试辅导），让我们一起学习成长！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/334ff706c9187302e40d522e2ccf945e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9441884f3473b61706971c42ead1bd4a/" rel="bookmark">
			深入了解数据结构第四弹——排序（1）——插入排序和希尔排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
从本篇开始，我们就开始进入排序的学习，在结束完二叉树的学习之后，相信我们对数据在内存中的存储结构有了新的认识，今天开始，我们将进入排序的学习，今天来学习第一篇——插入排序
目录
什么是插入排序？
一、直接插入排序
1、直接插入排序的实现
2、直接插入排序的时间复杂度
二、希尔排序
1、希尔排序的实现
2、希尔排序的时间复杂度
三、直接插入排序和希尔排序时间复杂度的比较
四、总结
首先，我们先来了解一下几种排序算法都有什么，方便我们后期学习，今天，我们先来讲解插入排序
什么是插入排序？ 插入排序其实挺有意思，这种排序方法在我们生活中也挺常见，例如，当我们在打扑克的时候，当我们再次摸牌时，我们会将新牌按照大小顺序插入到旧牌中
插入排序实际上就是将一个数字按照大小顺序插入到已知的序列中去
一、直接插入排序 1、直接插入排序的实现 插入排序是从后往前比较的，例如
当我们对这样一个数组进行插入排序时，我们先将1放进去，然后再放进去2与1比较，再放进去4与前面的1和2比较，以此类推，每放进去一个数字与前面数字比较，所以插入排序的过程是需要遍历数组的，我们首先可以给一个end变量标记现在排好序的数组的末端位置，再给出一个tmp变量来表示要排序的数字
插入排序的代码如下：（降序）
void InsertSort(int* a, int n) { for (int i = 1; i &lt; n; i++) { int end = i - 1; int tmp=a[i]; while (end&gt;=0) { if (tmp &gt; a[end]) { a[end + 1] = a[end]; end--; } else { break; } } a[end + 1] = tmp; } } 通过这段代码我们就可以看出插入排序的规则：当插入数据大于end位置的数据时，让end位置的数据向后移动一位，同时让end位置存放新插入的数据；当插入数据小于end位置数据时，那就直接让插入数据存放在end加1的位置就行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9441884f3473b61706971c42ead1bd4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd08baf469d0a30847e49c3fa2ecef5e/" rel="bookmark">
			docker报错：Docker Desktop - WSL distro terminated abruptly
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我遇到了这个问题，原因是我的C盘空间不足，我想将docker安装到D盘，然后按照网上的方法，卸载了docker，然后以管理员方式打开cmd，为docker安装目录创建目录连接`mklink /j “C:\Program Files\Docker” “D:\Program Files\Docker”`，然后重装docker，然后就老是报错，就报上面的错误，也参考了很多搜索到的方法，但并没有解决办法，后来...
我使用命令行的方式安装了docker，这样的好处是安装时的报错会在控制台中出现，当我安装时，我发现了报错，大概是网络的原因，但docker的安装界面却显示的是安装成功，这很明显不正确，于是，我再次卸载，并打开了vpn，然后再进行安装，这次成功了。
相关命令 # 为docker默认的存储镜像创建软连接 mklink /j "C:\Users\13923\AppData\Local\Docker" "D:\Program Data\Docker" # 为docker的安装目录创建软连接 mklink /j "C:\Program Files\Docker" "D:\Program Files\Docker" # 用 cmd 的方式安装docker start /w "" "Docker_Desktop_Installer.exe" install --installation-dir=D:\Program Files\Docker 总结 这个问题的出现，还可能是网络的原因造成的安装失败，解决了网络，问题也就解决了
参考 # Docker Desktop+WSL2并安装到D盘_docker安装到d盘-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b276b77a0a2470c15b754b275d3c8244/" rel="bookmark">
			【刷题】备战蓝桥杯 — dfs 算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		送给大家一句话：
风度真美！
即使流泪，也要鼓掌，
即使失望，也要满怀希望。
——刘宝增
dfs 算法 1 前言2 洛谷 P1030 [NOIP2001 普及组] 求先序排列题目描述算法思路 3 洛谷 P1294 高手去散步题目描述算法思路 4 蓝桥真题 十三届省赛 飞机降落题目描述算法思路 5 总结Thanks♪(･ω･)ﾉ谢谢阅读！！！下一篇文章见！！！ 1 前言 在蓝桥杯的比赛中，深度优先搜索（DFS，Depth-First Search）算法是一种常用的搜索算法，它通过尽可能深地搜索树的分支，来寻找解决方案。由于其简单和易于实现的特性，DFS成为解决问题的强大工具，尤其是在数据规模较小的情况下。数据在100以内一般使用dfs
运行原理： DFS算法的核心思想是从一个起点开始，沿着树的边走到尽可能深的分支上，然后回溯到之前的分叉点，寻找未探索的分支。这个过程重复进行，直到找到解决方案或探索完所有可能的路径。DFS通常使用递归实现，这使得代码简洁易读。它利用栈（递归调用栈）来记录访问路径，从而实现回溯功能。基本蓝桥杯dfs算法题型可以使用以下模版：
#include &lt;bits/stdc++.h&gt; //视情况而定 #define int long long #define endl '\n' #define N 1001 using namespace std; //往往需要一个哈希表来辅助判断 int vis[N] = {0}; void dfs() { //退出条件很重要！！！ if() return ; for() { //跟新结果 //继续深入 dfs(); //回溯 } } signed main() { //加快读写速度 也可以直接使用C语言标准输入输出函数 ios::sync_with_stdio(0); cin.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b276b77a0a2470c15b754b275d3c8244/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aacfd2a7be7212de32f4ac37f2a51f45/" rel="bookmark">
			实习记录小程序|基于SSM的实习记录小程序设计与实现(源码&#43;数据库&#43;文档)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		知识管理
目录
基于SSM的习记录小程序设计与实现
一、前言
二、系统设计
三、系统功能设计 1、小程序端：
2、后台
四、数据库设计
五、核心代码 六、论文参考
七、最新计算机毕设选题推荐
八、源码获取：
博主介绍：✌️大厂码农|毕设布道师，阿里云开发社区乘风者计划专家博主，CSDN平台Java领域优质创作者，专注于大学生项目实战开发、讲解和毕业答疑辅导。✌️
主要项目：小程序、SpringBoot、SSM、Vue、Html、Jsp、Nodejs等设计与开发。
🍅文末获取源码联系🍅
基于SSM的习记录小程序设计与实现 一、前言 对实习记录进行需求分析，得出实习记录主要功能。接着对实习记录进行总体设计和详细设计。总体设计主要包括小程序功能设计、小程序总体结构设计、小程序数据结构设计和小程序安全设计等；详细设计主要包括实习记录数据库访问的实现，主要功能模块的具体实现，模块实现关键代码等。最后对实习记录进行了功能测试，并对测试结果进行了分析总结，得出实习记录存在的不足及需要改进的地方，为以后的实习记录维护提供了方便，同时也为今后开发类似实习记录提供了借鉴和帮助。
实习记录开发使系统能够更加方便快捷，同时也促使实习记录变的更加系统化、有序化。系统界面较友好，易于操作。
关键词：实习记录；java语言 Mysql 数据库 SSM框架 二、系统设计 系统功能结构如图
三、系统功能设计 1、小程序端： 学生登录，在学生登录页面填写账号、密码进行登录如图5-1所示。
图5-1学生登录界面图
学生登录到实习记录可以查看首页、实习公告、我的等内容，如图5-2所示。
图5-2首页功能界面图
实习公告，在实习公告页面可以填写公告标题、发布时间、发布人、封面等信息进行提交，如图5-3所示。
图5-3实习公告界面图
在实习信息页面可以填写学号、学生姓名、专业、班级、手机号、教师工号、教师姓名、单位名称、单位地址、联系电话、岗位、指导人、实习时间等信息，并可根据需要进行提交，如图5-4所示。
图5-4实习信息界面图
在学生打卡页面可以填写学号、学生姓名、教师工号、教师姓名、打卡时间、打卡图片 、备注等信息，并可根据需要对学生打卡进行提交，如图5-5所示。
图5-5学生打卡界面图
在实习日记页面可以填写日记编号、添加时间、学号、学生姓名、日记标题、今日体会、今日收获等信息，并可根据需要对实习日记进行提交，如图5-6所示。
图5-6实习日记界面图
教师功能模块：
教师登录，在教师登录页面填写账号、密码进行登录如图5-7所示。
图5-7教师登录界面图
教师登录到实习记录可以查看首页、实习公告、我的等内容，如图5-8所示。
图5-8首页功能界面图
实习信息，在实习信息页面可以填写学号、学生姓名、专业、班级、手机号、教师工号、教师姓名、单位名称、单位地址、联系电话、岗位、指导人、实习时间、审核回复等信息进行审核，如图5-9所示。
图5-9实习信息界面图
在打卡记录页面可以填写打卡编号、时间、教师工号、教师姓名、打卡人数、未打卡人数、备注等信息，并可根据需要对打卡记录进行提交，如图5-11所示。
图5-11打卡记录界面图
2、后台 管理员通过填写用户名、密码、角色进行登录如图5-12所示。
图5.12管理员登录界面图
学生管理，通过填写学号、密码、学生姓名、性别、学院、专业、班级、手机号、照片、教师工号、教师姓名等信息进行详情、修改操作，如图5-13所示。
图5.13学生管理界面图
教师管理，通过填写教师工号、密码、教师姓名、性别、照片、职称、联系电话、教师邮箱等信息进行详情、修改、删除操作，如图5-14所示。
图5-14教师管理界面图
实习公告管理，通过填写公告标题、发布时间、发布人、封面等信息进行详情、修改、删除操作，如图5-15所示。
图5-15实习公告管理如图所示。
学院信息管理，通过填写学院等信息进行详情、修改、删除操作，如图5-16所示。
图5-16学院信息管理如图所示。
实习信息管理，通过填写学号、学生姓名、专业、班级、手机号、教师工号、教师姓名、单位名称、单位地址、联系电话、岗位、指导人、实习时间、审核回复、审核状态等信息进行详情、修改、删除操作，如图5-17所示。
图5-17实习信息管理如图所示。
学生打卡管理，通过填写学号、学生姓名、教师工号、教师姓名、打卡时间、打卡图片 、备注等信息进行详情、修改、删除操作，如图5-18所示。
图5-18学生打卡管理如图所示。
打卡记录管理，通过填写打卡编号、时间、教师工号、教师姓名、打卡人数、未打卡人数、备注等信息进行详情、修改、删除操作，如图5-19所示。
图5-19打卡记录管理如图所示。
四、数据库设计 (1) 学生打卡实体属性图如下所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aacfd2a7be7212de32f4ac37f2a51f45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07cc5eebb92e000e9b49405f7eab359e/" rel="bookmark">
			数据库讲解---(数据查询)【MySQL版本】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录​​​​​​​
零.前言
一.单表查询
1.1SELECT语句
1.2例子说明
1.3SELECT使用
1.3.1在学生表中找出所有学生的籍贯
1.3.2查询学生表中的所有信息
1.3.3给列定义别名返回
1.4WHERE的使用
1.4.1查询所有不及格课程的学生的学号、课程号及成绩
1.4.2在学生表中找出信电学院2000年后出生的学生的记录
1.4.3查询出生年份在“1996-1998”年出生的学生的姓名、性别、学院、出生年份
1.4.4查询信电学院、理学院、计算机学院的学生的学号、姓名、学院
1.4.4查询学院不是“信电学院”的学生的学号、姓名、学院
1.5字符匹配(模糊匹配)
1.5.1查询所有姓王的学生的姓名、学号、性别
1.5.2查询名字中，第二个字为“小”字的学生的姓名和学号
1.5.3查找课程名是“DB_Design”课程的课程号、课程性质
1.5.4空值
1.6GROUP BY
1.6.1查询学号在091501~091506至少选修了三门课程的学生的学号和选修课程的课程数
1.7集函数
1.7.1查询学生总人数
1.7.2查询计算机学院学生的平均年龄
1.7.3查询学习180101号课程的学生的最高分数
1.8对查询结果排序
1.8.1查询选修了180102号课程的学生的学号和成绩，查询结果按照成绩从高到低排序
1.8.2查询全体学生情况，查询结果按所在学院的名称升序排列，对同一学院中的学生按年龄降序排列
二.多表查询(连接查询)
2.1等值与非等值连接查询
2.1.1查询每个学生及其选修课程的情况
2.1.2使用自然连接“学生”表和“学习”表
2.2自身连接查询
2.2.1求每一门课程的间接选修课(先修课的先修课)
2.3外连接查询
2.3.2查询所有学生的姓名以及他们选修课程的课程号和成绩
2.3.3查询所有的课程信息及选修该课程的学生的学号及成绩
2.4复合条件连接查询
2.4.1查询选修180101号课程且成绩在90分以上的学生学号，姓名及成绩
2.5多表连接
2.6集合运算连接查询
2.6.1查询选修了180101号或180102号课程或二者都选修了的学生学号、课程号和成绩
三.嵌套查询
3.1简介
3.1.1查询选修了180101号课程的学生姓名
3.2带有ANY或ALL谓词的子查询
3.2.1查询其它学院中比计算机学院某个学生年龄小的学生名单
3.3带有EXISTS谓词的子查询
3.3.1查询选修了180102号课程的学生学号和姓名
3.3.2查询没有选修180102号课程的学生学号和姓名
四.除法运算的实现（困难）
4.1查询至少选修了091501号课程选修的全部课程的学生学号
4.1.1第一步：明确两个集合
4.1.2第二步：表示A包含B
4.1.3第三步：筛选出结果集合
零.前言 数据库讲解（MySQL版）（超详细）【第一章】-CSDN博客
数据库-ER图教程_e-r图数据库-CSDN博客
数据库讲解（MySQL版）（超详细）【第二章】【上】-CSDN博客
​​​​​​​​​​​​​​数据库讲解---(SQL语句--表的使用)【MySQL版本】-CSDN博客
一.单表查询 1.1SELECT语句 SELECT语句用于查询数据库中数据：
语法：
SELECT [ALL | DISTINCT] &lt;属性列表&gt; FROM &lt;表1或视图1&gt;,&lt;表2或视图2&gt;,&lt;表3或视图3&gt;,.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07cc5eebb92e000e9b49405f7eab359e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/257cbc06c630e4922859ad31e14ad06c/" rel="bookmark">
			基于Hadoop和Hive的聊天数据（FineBI）可视化分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 准备工作
2. 新建数据库连接
3. 在Hive数据库中创建存放数据的表
4. ETL数据清洗
5. 指标
​6. 进入Fine BI数据中心
参考内容https://www.bilibili.com/read/cv15490959/
数据文件、jar包、插件
https://pan.baidu.com/s/1Mpquo0EgkyZtLHrCPIK2Qg?pwd=7w0k
1. 准备工作 在FineBI6.0\webapps\webroot\WEB-INF\lib下放置jar包
启动FineBI服务器
安装hive隔离插件
选择该文件
重启服务器
2. 新建数据库连接 在虚拟机后台启动metastore和hiveserver2服务（在hive目录下）
进入beeline客户端
--hive2://后可以是主机名-- !connect jdbc:hive2://192.168.224.112:10000 回车然后输入用户名，我的是root，再回车
密码根据自己的填（我没有），回车
如果不成功，就先配置虚拟机中/hadoop父文件夹/hadoop/etc/hadoop/core-site.xml文件
和/hive父文件夹/hive/conf/hive-site.xml文件
然后重启sh，后台挂起metastore，hiveserver2，启动beeline。
在Fine BI上新建hive数据库连接
数据库名称为自己在hive中创建的数据库，主机为虚拟机IP，端口10000，用户名root
3. 在Hive数据库中创建存放数据的表 创建dgy_30w表（myhive为我自己的数据库），操作在hive和beeline中都可以
create table myhive.dgy_30w ( msg_time string comment "消息发送时间", sender_name string comment "发送人昵称", sender_account string comment "发送人账号", sender_sex string comment "发送人性别", sender_ip string comment "发送人ip地址", sender_os string comment "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/257cbc06c630e4922859ad31e14ad06c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2512d0bcf699958ac1f891d433a4bc4/" rel="bookmark">
			讯飞星火等10个生成式AI平台对比分析 附网址 全部免费 [ 讯飞星火、智谱清言、天工 AI、Kimi AI、通义千问、文心一言、腾讯混元、豆包 AI、海螺 AI、360智脑 ]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
人工智能技术概览
AI平台优劣势对比
讯飞星火​
智谱清言​
天工AI​
Kimi AI​
通义千问​
文心一言​
腾讯混元​
豆包AI​
海螺AI​
360智脑​
部分AI生成的图片
模型测评评分
综合评分（人类裁判）
通用语言能力榜单（人类裁判）
通用语言能力榜单（大模型裁判）
专业学科能力榜单（正确率）
安全与责任榜单（人类裁判）
整体评价
人工智能技术共同优势
人工智能技术共同局限性
总结
人工智能技术概览 随着人工智能技术的迅猛发展，AI语言模型在自然语言处理领域扮演着越来越重要的角色。本文将对讯飞星火、智谱清言、天工 AI、Kimi AI、通义千问、文心一言、腾讯混元、豆包 AI、海螺 AI和360智脑这十款AI语言模型进行详细对比，探讨它们各自的优势和局限性。
序号名称跳转链接（PC）1讯飞星火讯飞星火认知大模型-AI大语言模型-星火大模型-科大讯飞 (xfyun.cn)2智谱清言智谱清言 (chatglm.cn)3天工天工 — 双千亿级大语言模型 (tiangong.cn)4KimiKimi.ai - 帮你看更大的世界 (moonshot.cn)5通义千问通义千问 (aliyun.com)6文心一言文心一言 (baidu.com)7腾讯混元腾讯混元助手 (tencent.com)8豆包豆包 - 抖音旗下 AI 智能助手 (doubao.com)9海螺海螺 AI - 有问题，找海螺 AI (hailuoai.com)10360智脑360智脑 - 体验平台 AI平台优劣势对比 注：优劣势对比排名不分先后。
讯飞星火 优势：
精准的语音识别技术： 讯飞星火通过先进的算法和大量的数据训练，实现了对用户语音指令的高准确度识别，无论是在嘈杂环境还是在不同口音、语速下，都能保持稳定的识别效果，为用户提供流畅的语音交互体验。广泛的语料库资源： 拥有庞大的语料库，覆盖了多种语言和方言，使得讯飞星火在理解和分析用户语言时更为准确和全面，能够应对各种复杂的语言场景。多语种识别与翻译： 支持多种语言的识别和翻译，不仅包括主流的英语、法语等，还包括一些小众语言，极大地方便了用户在不同语言环境下的沟通和交流。多种API接口： 提供了丰富的API接口，使得开发者可以轻松地将讯飞星火集成到自己的应用中，快速开发出具有智能语音交互功能的产品。 局限性：
专业术语理解局限： 尽管讯飞星火在语义理解方面表现出色，但在处理特定领域的专业术语时，可能因为缺乏足够的行业数据支持，导致理解不够深入和准确。语音合成效果一般： 与其他一些人工智能语言模型相比，讯飞星火在语音合成方面的效果可能稍显不足，对于一些对语音质量有较高要求的用户来说，可能无法完全满足其需求。 智谱清言 优势：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2512d0bcf699958ac1f891d433a4bc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a57b19868321818245d80739d76de21/" rel="bookmark">
			SpringBoot中定时任务踩坑，@Scheduled重复执行问题排查（看完直接破防）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 今天再开发业务需求的过程中，需要用到定时任务，原本定的是每10分钟推送一次，可是当每次十分钟到的时候，定时任务就会推送多条！但是非常奇怪的是，本地调试的时候不会有问题，只有当你部署到到服务器上的时候才会暴露这个问题！！！！
如图：
这些消息都是一次性推送出来的，本来他们应该只有一条被推送出来的，可是现在他们却全都出来了，难道真是“一家人就要整整齐齐”吗？
解决思路 这种本地无法重现的问题解决起来最恼火了，于是乎我去网上寻找答案，看看有没有人遇到类似的情况！
其中两篇是这么说的:
文章连接：生产问题：@Scheduled Spring定时任务每次执行两次原因分析以及解决方案
文章连接：spring定时任务执行两次的原因与解决方法
他们的大概的意思就是因为他的配置到导致他的配置类被重复加载了两次，进而导致定时任务重复执行多次！
于是我就类比了一下，看到在我的项目中，确实使用了@EnableScheduling两次
第一次：
第二次：
于是我赶紧把启动类上的@EnableScheduling注解去掉，并祈祷能有用！
结果如我所料，果然没什么用！
于是我继续搜索，看到这样一篇文章：
当我看到这句话的时候，我甚至以为我已经接近真理了！
springboot关于定时任务执行多次的问题
但是当我看到他写的这些太乱了，而且一个简答的定时任务，被他搞得这么复杂，我果断放弃了。
头痛砍头？？？？ 我于是乎又接着找，我发现了这样一篇文章，特别逆天！！！
Springboot 使用 @Scheduled 定时任务生产环境执行两次
好家伙，你这好比你去医院看病，你和医生说：”医生我头痛，我该怎么办？“，医生说：”没事的哈，一会去把把头砍了，砍了就不痛了哈！“
接近真理 时间在一分一秒的过去，我却毫无紧张，甚至已经开始汗流浃背了，从未感到如此巨大之强度，于是乎我便去到了stackoverflow上搜索一下看看！
哎！你说好巧不巧，还真就让我找到问题了！
看到这样一条问题：
这不就是我遇到的问题吗？
他是这么说的：
I have a service which has to run a job to get and refresh it's data from another service. The job has to be run on startup and every couple of hours/days. I was looking into the behavior of the scheduled job and it seems to be called two times consecutively according to the logs (see below).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a57b19868321818245d80739d76de21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63a1a1095a7c6e925bafc4a7cd6d6209/" rel="bookmark">
			JS中的JSON（秒懂如何操作JSON）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、JSON介绍
1.概念
2.主要特点
3.优点
4.使用JSON的原因
使用 XML
使用 JSON
二、JSON语法
三、JSON使用
1.JSON的序列化
2.解析（parse) JSON
3.序列化（Stringify）JSON
四、JSON实例
1.用户信息
2.本地存储
五、JSON应用场景
六、总结
一、JSON介绍 1.概念 JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，它基于JavaScript的语法子集，但是独立于编程语言。JSON格式可以用来在网络中传输数据，也可以存储数据。JSON采用键值对的方式表示数据，其中键是字符串，值可以是字符串、数字、布尔值、数组、对象或者null。
2.主要特点 简洁性（Simplicity）：JSON的语法简洁清晰，易于阅读和编写。它由简单的键值对、数组和值组成，比起XML等其他数据格式更为简洁。
可读性（Readability）：JSON数据易于理解和解释，它使用了人们熟悉的键值对的形式，而且可以通过缩进来表示数据的层级结构，提高了可读性。
跨语言兼容性（Language Independence）：JSON是一种独立于编程语言的数据格式，可以被几乎所有编程语言支持。因此，无论是哪种编程语言，都可以轻松地解析和生成JSON格式的数据。
数据结构（Data Structure）：JSON支持复杂的数据结构，包括对象和数组的嵌套，可以表示各种形式的数据。这种灵活性使得JSON在应用程序之间传输复杂数据时非常有用。
可扩展性（Extensibility）：JSON格式是可扩展的，可以根据需要定义新的数据类型或数据结构。虽然JSON本身提供了基本的数据类型，但是它可以通过约定来支持更复杂的数据模型。
网络友好（Network Friendly）：JSON数据通常比XML等其他数据格式更小，因此在网络传输时占用的带宽更少，速度更快，对于移动设备或者网络带宽有限的环境尤其适用。
3.优点 简洁易读：JSON使用简单的文本格式表示数据，易于阅读和编写。跨平台兼容：JSON是一种通用的数据格式，可以在不同编程语言和平台之间进行数据交换。易于解析和生成：JSON数据可以轻松地被解析和生成，几乎所有编程语言都有相关的解析器和生成器。支持复杂数据结构：JSON支持嵌套的对象和数组，可以表示复杂的数据结构。 4.使用JSON的原因 对于 AJAX 应用程序来说，JSON 比 XML 更快更易使用：
使用 XML 读取 XML 文档使用 XML DOM 来循环遍历文档读取值并存储在变量中 使用 JSON 读取 JSON 字符串用 eval() 处理 JSON 字符串 二、JSON语法 JSON（JavaScript Object Notation）的语法相对简单，主要由以下几个部分组成：
对象（Object）：对象是一组无序的键值对（key-value pairs），用花括号 {} 包裹起来。每个键值对之间用逗号 , 分隔。键和值之间使用冒号 : 分隔。键必须是字符串，而值可以是字符串、数字、布尔值、数组、对象或者null。示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63a1a1095a7c6e925bafc4a7cd6d6209/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0a7d9907837f353b0528a7814ffa774/" rel="bookmark">
			【错误记录】adb 调试 android 设备报错 ( adb server version (32) doesn‘t match this client (41)； killing... )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、错误记录二、问题分析三、解决方案 手机上的 adb server 是新的 , 电脑上的 adb client 很长时间没有更新 , 进入 SDK Manager 中更新 Android SDK Platform-Tools 工具版本即可 ;
一、错误记录 使用 adb 命令 , 查看 设备 , 报如下错误 ;
C:\Users\octop&gt;adb devices adb server version (32) doesn't match this client (41); killing... could not read ok from ADB Server * failed to start daemon adb.exe: failed to check server version: cannot connect to daemon 进入 Android Studio 时 , 也报该错误 :
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0a7d9907837f353b0528a7814ffa774/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8420e568e581f41ff0822708aad1b01f/" rel="bookmark">
			在Linux中安装Android Studio（ubuntu22.04）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Linux中安装Android Studio 准备工作 系统：ubuntu 22.04
位数：64bit
安装要求：
安装流程 1.下载安装包
打开Android Studio官网
把Android Studio的安装包下载下来
2.安装
为了防止丢失，把解压好的文件夹移到 /usr/local 下，可以手动剪切也可以执行下面指令
sudo mv android-studio /usr/local 接下来定位到bin文件中，运行
cd /usr/local/android-studio/bin ./studio.sh 注意这边最后关闭代理，否则无法进行下一步
下面的两个条款都同意一下
等待安装完成即可
3. 注意事项
1.如果使用64位的ubuntu系统，需要用下面的指令安装一些32位的库
sudo apt-get install libc6:i386 libncurses5:i386 libstdc++6:i386 lib32z1 libbz2-1.0:i386 如果系统不是unbuntu，而是64位的Fedora，命令为：
sudo yum install zlib.i686 ncurses-libs.i686 bzip2-libs.i686 每次打开Android studio 执行下面指令： ./usr/local/android-studio/bin/studio.sh 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce83ac38448b5a5d4394473fc9ceb2bf/" rel="bookmark">
			OpenCV与AI深度学习｜16个含源码和数据集的计算机视觉实战项目(建议收藏！)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文来源公众号“OpenCV与AI深度学习”，仅用于学术分享，侵权删，干货满满。
原文链接：分享｜16个含源码和数据集的计算机视觉实战项目
本文将分享16个含源码和数据集的计算机视觉实战项目。具体包括：
1. 人数统计工具
2. 颜色检测
3. 视频中的对象跟踪
4. 行人检测
5. 手势识别
6. 人类情感识别
7. 车道线检测
8. 名片扫描仪
9. 车牌识别
10. 手写数字识别
11.鸢尾花分类
12. 家庭照片人脸检测
13. 乐高积木查找器
14. 个人防护装备检测
15. 口罩检测
16. 交通灯检测
1. 人数统计工具
构建人数统计解决方案既可以是一个有趣的项目，又可以真正找到现实世界的应用程序。
要检测和计算图像中存在的人数，您需要相关的训练数据集和数据训练平台。您可以使用 OpenCV 等免费工具来标记数据，或使用 V7 等自动注释工具来更快地完成此项目。
自 COVID-19 爆发以来，人数统计解决方案越来越受欢迎，有助于执行社交距离规则并提高安全性。
下面是一个推荐的数据集和代码，可以帮助您入门：
https://github.com/gjy3035/PCC-Net 2. 颜色检测
接下来是一个简单的颜色检测器，可用于各种视觉任务。
从检测颜色到构建绿屏应用程序（用自定义视频或背景替换绿色背景）到简单的照片编辑软件，构建颜色识别器是计算机视觉入门的一个很棒的项目。
以下是您可能想要在项目中使用的一些有趣的数据集和代码：
https://github.com/mpatacchiola/deepgaze 3. 视频中的对象跟踪
对象跟踪是根据先前的信息估计场景中存在的目标对象的状态。
您可以使用涉及一个对象（例如汽车）或多个对象（例如行人、动物等）的视频来构建简单的对象跟踪模型。
本质上，该模型将执行两项任务 - 预测对象的下一个状态并根据对象的真实状况纠正该状态。对象跟踪模型在交通控制和人机交互中得到应用。
以下是您可能会对此计算机视觉任务感兴趣的一些视频数据集和代码：
https://github.com/JunweiLiang/Object_Detection_Tracking 4. 行人检测
构建对象检测模型来检测行人是最简单、最快完成的计算机视觉项目之一。
您所需要的只是高质量图像的相关数据集和用于训练和测试模型的数据训练平台。您可以使用免费的图像注释工具之一。
行人探测器通常用于汽车行业的交通安全以及人机交互和智能视频系统。
考虑这些数据集和代码来开始：
https://github.com/kuanhungchen/awesome-tiny-object-detection 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce83ac38448b5a5d4394473fc9ceb2bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0134e6df2e8f0f80d4ebaead07ccb224/" rel="bookmark">
			【数据交换格式】网络socket编程温度采集智能存储与上报项目技术------JSON、TLV
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者简介： 一个平凡而乐于分享的小比特，中南民族大学通信工程专业研究生在读，研究方向无线联邦学习
擅长领域：驱动开发，嵌入式软件开发，BSP开发
作者主页：一个平凡而乐于分享的小比特的个人主页
文章收录专栏：网络socket编程之温度采集智能存储与上报项目，本专栏为网络socket编程之温度采集智能存储与上报项目技术简介，实现流程分析
项目源码：https://gitee.com/TJF865975/project1_ds18b20，README部分包含项目功能及实现，欢迎大家Watch、Star、Fork。
欢迎大家点赞 👍 收藏 ⭐ 加关注哦！💖💖
1.JSON格式 1.1 JSON格式简介 JSON是一种独立于语言和平台、轻量级的数据交换格式，全称JavaScript对象表示法（JavaScript Object Notation）。起初来源于JavaScript这门语言，后来随着使用的广泛，几乎每门开发语言都有处理JSON的API。
优点：易于人的阅读和编写，易于程序解析与生产。比XML更小、更快、更易解析。
JSON样例：首先一个花括号{}，整个代表一个对象，同时里面是一种Key-Value的存储形式，以逗号进行分割。
{ "name": "林黛玉", "sex": "女", "parents": [ { "father": "林如海", "mother": "贾敏" } ], "husband": null, "unmarried": true, "friends": [ { "sex": "男", "name": "贾宝玉" }, { "sex": "女", "name": "史湘云" }, { "sex": "女", "name": "贾探春" } ] } 1.2 JSON数据类型 数据结构：对象（Object）、数组（Array）。
基本类型：string（在双引号中），number（整点或浮点型），Boolean(true，false)，null。
1.2.1 对象Object 形式： {key:value, key:value…}
key：string类型；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0134e6df2e8f0f80d4ebaead07ccb224/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3198520fd54672287b0a235072421eb6/" rel="bookmark">
			NL2SQL基础系列(1)：业界顶尖排行榜、权威测评数据集及LLM大模型（Spider vs BIRD）全面对比优劣分析[Text2SQL、Text2DSL]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NL2SQL基础系列(1)：业界顶尖排行榜、权威测评数据集及LLM大模型（Spider vs BIRD）全面对比优劣分析[Text2SQL、Text2DSL] Text-to-SQL（或者Text2SQL），顾名思义就是把文本转化为SQL语言，更学术一点的定义是：把数据库领域下的自然语言（Natural Language，NL）问题，转化为在关系型数据库中可以执行的结构化询语言（Structured Query Language，SQL），因此Text-to-SQL也可以被简写为NL2SQL。
输入：自然语言问题，比如“查询表t_user的相关信息，结果按id降序排序，只保留前10个数据”输出：SQL，比如“SELECT * FROM t_user ORDER BY id DESC LIMIT 10” 使用 NL2SQL 的技术方案，用户与数据库之间的距离可以进一步缩短，用户可以更自由地查询更多信息、表达自己更丰富的查询意图，还可以减轻目前技术方案的繁琐，解放开发人员。
1.NL2SQL情况 1.1 NL2SQL的发展历史 NL2SQL的历史要追溯到1973年，Woods等人开发了一个名为LUNAR的系统，主要用来回答从月球带回来的岩石相关的问题。1978年，Hendrix设计了一个名叫LIFER/LADDER的接口，可以通过自然语言查询数据库。但是上面提到的系统都是针对特定数据库开发的，而且只支持单表操作。2008年，Siasar等人基于句法和语义知识的基本概念提出了专家系统，并提出一个能够从多个结果中选择一个合适查询语句的算法。2010年，Rao等人提出了一个包含简单和隐式查询的系统。2013年，Chaudhari使用原型技术实现了一个能够处理简单查询和聚合函数的系统。虽然这些系统能够生成不同的查询语句，但依然无法支持多表关联的问题。2014年，Ghosh等人基于Chaudhari的研究成果，在其基础上又开发了一个自动查询生成器，它采用语音或自然语言文本作为输入，支持简单的嵌套查询和聚合操作，同时系统还能够处理那些明确指出的属性。同年，Reinaldha和Widagdo使用了不同的方法来研究用户不同形式的输入，他们采用语义规则来找出问题中出现的词与数据库中的属性之间的关系。2015年，Palakurthi等人提供了与属性类型和分类特征相关的信息，描述了不同属性出现在句子中的处理方式也是不一样的。2016年，Ghosal等人提出了一个系统，能够很好地处理多表简单查询，不过系统使用的数据字典有限。同年，Kaur and J, Jan 强化了系统的简单查询和连接操作，但不支持聚合函数、GROUPBY和HAVING等高级子句。Singh and Solanki也提出了一种将自然语言转为sql查询的算法。他们使用动词表、名词表和规则将属性和表映射到句子中的单词，系统还灵巧地处理了文本的模糊输入。2017年，Google开发了Analyza系统，一个以自然语言为人机交互的接口的系统，支持用户用自然语言做数据探索与数据分析。该系统已在Google两个产品中投入使用，一是Online Sheet产品的QA问答模块，二是提供了一个库存和收入数据数据库的一个访问入口。同年，Sukthankar, Nandan等人开发了nQuery系统，一个自然语言到SQL的查询生成器，支持聚合函数，以及where子句中的多个条件、高级子句（如order by、group by和having）操作。2018年，Utama, Prasetya等人开发了DBPal工具，一个面向数据库的端到端的自然语言接口。DBPal主要有两大特性，一是采用深度模型将自然语言语句转为SQL，二是在用户不知道数据库模式和查询特性的情况下，支持短语提问，同时支持用户查询扩展提示，有助于提高查询效果。
1.2 NL2SQL 业内情况 1.2.1 测评指标 Text-to-SQL任务的评价方法主要包含两种：精确匹配率（Exact Match, Accqm）、执行正确率（Execution Accuracy, Accex）
Execution Accuracy (EX) [paper]
定义：计算SQL执行结果正确的数量在数据集中的比例，结果存在高估的可能。 Exact Match (EM) [paper]
定义：计算模型生成的SQL和标注SQL的匹配程度，结果存在低估的可能。 精确匹配率指,预测得到的SQL语句与标准SQL语句精确匹配成功的问题占比。为了处理由成分顺序带来的匹配错误，当前精确匹配评估将预测的SQL语句和标准SQL语句按着SQL关键词分成多个子句，每个子句中的成分表示为集合，当两个子句对应的集合相同则两个子句相同，当两个SQL所有子句相同则两个SQL精确匹配成功；
执行正确指，执行预测的SQL语句，数据库返回正确答案的问题占比。
1.2.2 业界排行榜 1.3 相关论文综述 (2023-International Conference on Very Large Data Bases, VLDB, CCF-A）A survey on deep learning approaches for text-to-SQL [paper](2022-IEEE Transactions on Knowledge and Data Engineering, TKDE, CCF-A) A Survey on Text-to-SQL Parsing: Concepts, Methods, and Future Directions [paper](2022-International Conference on Computational Linguistics, COLOING, CCF-B) Recent Advances in Text-to-SQL: A Survey of What We Have and What We Expect [paper](2022-arXiv)Deep Learning Driven Natural Languages Text to SQL Query Conversion: A Survey [paper] 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3198520fd54672287b0a235072421eb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1492dd86a8ab9d76aae7059ad92de07a/" rel="bookmark">
			关于几款AI人工智能驱动的代码生成插件，强烈推荐：通义灵码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先说结论：强烈推荐通义灵码、强烈推荐通义灵码、强烈推荐通义灵码，下面所有评测只是针对Java的情况！
1、GitHub Copilot
GitHub Copilot是由GitHub开发的AI辅助编程工具，它使用的是OpenAI Codex技术，这是一个由OpenAI创建的通用预训练语言模型。GitHub Copilot可以根据代码和注释的上下文提供个性化的代码建议。基于chatGPT，很智能；
2、Codeium
是一个免费的人工智能驱动的代码生成工具，可以平替Copilot，智能程度很好，并且免费；
3、CodeWhisperer
是亚马逊开发的，也是一个免费的人工智能驱动的代码生成工具，可以平替Copilot，智能程度很好，并且免费；
4、CodeGeeX
是清华大学知识工程实验室研发的一款基于大模型的全能的智能编程助手，一个具有 130 亿参数的多编程语言代码生成预训练模型，由清华大学知识工程实验室团队开发，采用华为 MindSpore 框架实现，在鹏城实验室“鹏城云脑 II”中的 192 个节点（共 1536 个国产昇腾 910 AI 处理器）上训练，使用 20 多种语言的语料库上预训练得到。可以平替Copilot，智能程序很好，并且免费；
5、通义灵码
通义灵码是一款基于阿里云通义代码大模型打造的智能编码助手，可以平替Copilot，智能程序很好，并且免费；
6、Baidu Comate
基于文心大模型，结合百度积累多年的编程现场大数据和外部优秀开源数据，为你生成更符合实际研发场景的优质代码（这一个是网友推荐让我去测试一下，具体测试总结写在最后）；
六个插件主要区别如下：
1、以上六个都需要注册才能用，智能程度最高的是Copilot，但是需要收费；
2、Copilot收费，后面五个全部是免费，其中Comate有免费版和收费版；
3、前三个是国外的，后面三个是国产的；
大体总结：
我是这样想的，首先能用Copilot当然好，但是它收费，其实想想，项目主要代码还是得自己写，工具只是帮程序员提高效率，只要说工具够用就行，不用太去追求极致，因为用了AI写，其实有时还不能完全放心，需要自己去选择一下修改一下，再就是国外的有的需要挂梯子注册，很烦人，而国产的支持中文会更体贴生成代码网速也会更快，所以我倾向于使用国产的，也当是支持国产AI，我都试过，智能程度完全够用，不过体验下来，CodeGeeX在很多时候，它生成的代码是不会自动给你加右大括号的，然后Comate的智能程度不太够，相比之下我感觉通义灵码用起来更舒服更智能。
下面具体说说我用几个国产代码生成AI（CodeGeeX、通灵义码、Comate）后的感受：
在说使用感受之前，先说一下我个人的一个定位：像软件工程这种大的项目，完全靠AI生成下来，不是说它不可能，绝对可能，并且已经实现，但是现阶段完全由AI给生成的代码，改都不改直接拿来用，我真的不敢，设计模块、架构、优化等等这些，还是需要程序员的介入，所以我认为AI现阶段是拿来提升效率的，并不是来代替程序员的，就好比我是一个设计师，我必须要去自己亲自刷墙吗？刷墙这种具体活现在就可以交给AI了，我只要做好设计，对于程序员某一个功能模块我组织好，然后具体算法交给AI，让它给我生成几套方案出来，然后我再在这个基础上去改一下，AI的出现是逼着程序员不能只光会写代码，还要懂业务，怎么说了，就是你不能把自己只定位为一个coding者，懂代码只是基础，还需要懂业务懂产品懂策划，未来在AI的加持下人人都可以做程序员，所以要把自己晋升为一个设计者一个创造者，在这种定位下，也就是说我的观点是现阶段AI的目标不是来代替程序员，程序员是利用AI提升效率，帮助人类完成一些枯燥重复的工作，从而让人解放出来去做创造性的工作，那么很多主要任务还是需要程序员的介入，那么在选插件的时候，只要是智能程度够用就行，不需要去追求完美，你要记住，不是程序员自己不会，而是程序员把枯燥重复的事交给AI了，我打个比方，天天写排序算法，累不累，又不是什么创新，像这种傻活就交给AI，直接让它给出多套排序算法，你选一个就好，在这种定位下，选择工具时不要太追求完美，智能程度够用就行，能提升效率就行，并不一定非要选择智能程度极致的Copilot，免费的不香吗？我也不想挂梯子，国内的应该网速也快一些，加上现在来说我感觉这国产的AI代码生成智能程度也够用，所以在经过比较之后我最后选择了通义灵码。
使用CodeGeeX后感受：跟下面差不多，但是有一个问题，我感觉它没有通义灵码智能，就是它生成完算法后，它不会智能给你加上右大括号，这搞的人有点毛，需要自己加 }，整体来说我感觉通义灵码更智能。
使用通灵义码后的感受：写了注释后（注释写的越有层次感，生成精度越高，有可能的话在写完需求之后，把特殊变量也自己起好名字并且写进注释里），然后它会一步一步去生成，其实算法在写的时候，中间有可能会出现多种不同分支的写法，通义灵码很智能，在写的过程中，如果我突然改变思路也就是改变分支，然后通义灵码它下一步给的生成提示马上转变成我现在的新思路，也就是说，在你写一个具体需求的过程中，不管是你自己起的头，还是利用通义灵码生成的代码起的头，在这个实现中途中间，你随时可以主动改变算法分支，改变具体实现方法，通义灵码会随时根据你现在具体的代码位置马上转换成你现在的新思路，我真的感觉已经很牛逼了，所以我强烈推荐：通义灵码。我是这样想的，像通义灵码和CodeGeeX这种国产的AI，如果它能赶上Copilot的智能程度，我觉得就算是适当收一点费用，我也能接受。再就是还有一点，听说通义那套大模型它里面主要以生成代码为主，所以通义灵码在代码生成这块做的更智能，重要的事说三遍：强烈推荐通义灵码、强烈推荐通义灵码、强烈推荐通义灵码！
使用Comate后的感受：网友强烈推荐让我试试百度的comate，说实话，我对百度的人工智能还是充满信心的，只是我信息获取渠道有限，所以并没有像上面那些插件一样，第一时间就去测试了，然后对于百度的comate的测试感觉如下：有三点小问题，1、我写了一段注释，分两个地方，第一个地方是主类之外然后让其在main方法中给我生成一个逻辑大体流程，生成的代码没有达到预期，第二个地方是main方法下面的方法区，可以良好的达到预期，并且变量边界比通灵义码更准确，拿选择排序算法来说，Comate在这个算法中的外层循环使用的边界是arr.length-2，这个边界就选的很完美，通义灵码在这个算法中的外层循环使用的边界是arr.length-1而不是arr.length-2，实际上用arr.length-1最后算法也能得到正确结果逻辑上也是正确的，因为当内层循环起步时就是j=i+1这时由于超过了数组的最后一个于是根本不会执行内层循环，只是说感觉有那么一点算法的不完美，如果用arr.length-2时根本就不用再去走内层循环的条件了，从算法上来说没有任何多余的东西会显的更完美，总体来说在这两个地方的根据注释生成代码测试中通义灵码都能达到良好的预期，但是Comate在第一个地方生成的代码就不太宁人满意；2、在我的长时间各种把玩之后，插件主界面不显示了，出bug了；3、生成代码之后无法选择新算法（这里具体指的是不能切换新算法，例如在通义灵码里你可以通过快捷键alt+p去切换新算法，也就是在它有可能的情况下强制要求它去切换一个新算法新逻辑），总体来说Comate还行，算是够用吧，但是整体上没有通义灵码优秀。
写在最后：通义灵码和Baidu Comate都非常不错，不过如果非要在两者之间做个选择，那么我还是推荐你使用通义灵码，因为在整体表现上通义灵码更佳，那个CodeGeeX就不要考虑了，因为如果代码层次一多，它不加右}，让你自己去手动添加，相信我，你会疯掉的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a48b31e98b8ed86ee5f86dd4a26ac712/" rel="bookmark">
			【Stable Diffusion】Roop换脸插件，全网最简单傻瓜式安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天也是应粉丝的要求，出一篇关于roop插件安装的教程。之前已经写过两篇关于roop插件的使用文章，它确实是目前最方便快捷的一款换脸插件了。
无需Lora，一键换脸插件Roop（点击下方图片跳转）
多人物脸部替换，一键换脸插件Roop（2）（点击下方图片跳转） 但是呢，很多朋友还没有用上这款插件，在安装的这一步就倒下了。因为这里面会涉及到一些环境安装和代码运行的一些操作，还需要魔法下载一些文件，有的朋友遇到版本不兼容的问题还会出错等等，属实让人头疼。
今天我既然写了全网最简单这个标题，那就必然是全程无脑安装，但凡你动了一点脑子，就算我输了。
下面我们正式开始。
第一步：
确保你的整合包版本是最新的秋叶整合包，下载包我已经更新到了云盘里，文末扫码就可下载。
在插件包里面下载这个文件。
第二步：
将sd-webui-roop文件夹拖放到“……\sd-webui-aki-v4.2\extensions”目录下。
第三步：
解压这个python压缩包。
替换掉根目录下的这个文件。（删掉原来的，换这个）
第四步：
将inswapper_128.onnx 文件移动到“sd-webui-aki-v4\models\roop ”目录下（没有该目录创建一下）
第五步：
将.ifnude和.insightface目录移动到C:\Users\你的用户名目录下
我的用户名是stream，你的应该是别的名字。
第六步：
启动webui，它会同步内部组件，可能需要5-30分钟，耐心等一下。（不是启动不了，是一定要等待）
当加载完成后就会在浏览器打开，可以在图生图、文生图中下面列表标签看到 roop V0.0.2 。
好了，这就是roop插件的安装方法了，够无脑了吧，复制粘贴就完事了。如果你还没有成功，那……
就是在下输了！
以上，想要安装包的话，文末扫码即可获取。
-END-
写在最后 AIGC技术的未来发展前景广阔，随着人工智能技术的不断发展，AIGC技术也将不断提高。未来，AIGC技术将在游戏和计算领域得到更广泛的应用，使游戏和计算系统具有更高效、更智能、更灵活的特性。同时，AIGC技术也将与人工智能技术紧密结合，在更多的领域得到广泛应用，对程序员来说影响至关重要。未来，AIGC技术将继续得到提高，同时也将与人工智能技术紧密结合，在更多的领域得到广泛应用。
感兴趣的小伙伴，赠送全套AIGC学习资料和安装工具，包含AI绘画、AI人工智能等前沿科技教程，模型插件，具体看下方。
一、AIGC所有方向的学习路线
AIGC所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照下面的知识点去找对应的学习资源，保证自己学得较为全面。
二、AIGC必备工具
工具都帮大家整理好了，安装就可直接上手！
三、最新AIGC学习笔记
当我学到一定基础，有自己的理解能力的时候，会去阅读一些前辈整理的书籍或者手写的笔记资料，这些笔记详细记载了他们对一些技术点的理解，这些理解是比较独到，可以学到不一样的思路。
四、AIGC视频教程合集
观看全面零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
五、实战案例
纸上得来终觉浅，要学会跟着视频一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
若有侵权，请联系删除 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/428/">«</a>
	<span class="pagination__item pagination__item--current">429/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/430/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>