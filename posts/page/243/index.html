<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a754d27dbe414cf255a5d0ab0e82caa0/" rel="bookmark">
			vue3&#43;ts 使用vue3-ace-editor实现Json编辑器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、效果图
输入代码，点击格式化就出现以上效果，再点击压缩，是以下效果
2、安装
npm i vue3-ace-editor 3、使用
新建aceConfig.js文件
// ace配置，使用动态加载来避免第一次加载开销 import ace from 'ace-builds' // 导入不同的主题模块，并设置对应 URL import themeGithubUrl from 'ace-builds/src-noconflict/theme-github?url' ace.config.setModuleUrl('ace/theme/github', themeGithubUrl) import themeChromeUrl from 'ace-builds/src-noconflict/theme-chrome?url' ace.config.setModuleUrl('ace/theme/chrome', themeChromeUrl) import themeMonokaiUrl from 'ace-builds/src-noconflict/theme-monokai?url' ace.config.setModuleUrl('ace/theme/monokai', themeMonokaiUrl) // 导入不同语言的语法模式模块，并设置对应 URL (所有支持的主题和模式：node_modules/ace-builds/src-noconflict) import modeJsonUrl from 'ace-builds/src-noconflict/mode-json?url' ace.config.setModuleUrl('ace/mode/json', modeJsonUrl) import modeJavascriptUrl from 'ace-builds/src-noconflict/mode-javascript?url' ace.config.setModuleUrl('ace/mode/javascript', modeJavascriptUrl) import modeHtmlUrl from 'ace-builds/src-noconflict/mode-html?url' ace.config.setModuleUrl('ace/mode/html', modeHtmlUrl) import modePythonUrl from 'ace-builds/src-noconflict/mode-python?url' ace.config.setModuleUrl('ace/mode/yaml', modePythonUrl) // 用于完成语法检查、代码提示、自动补全等代码编辑功能，必须注册模块 ace/mode/lang _ worker，并设置选项 useWorker: true import workerBaseUrl from 'ace-builds/src-noconflict/worker-base?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a754d27dbe414cf255a5d0ab0e82caa0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23c5f3f12c9fcdcc2bd19e3ce4dfcd09/" rel="bookmark">
			线性代数|机器学习-P16矩阵A的导数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 概述2. 求 d A − 1 ( t ) d t \frac{\mathrm{d}A^{-1}(t)}{\mathrm{d}t} dtdA−1(t)​3. 求 d λ ( t ) d t \frac{\mathrm{d}\lambda(t)}{\mathrm{d}t} dtdλ(t)​3.1 A 和 A T A^T AT有相同的特征值3.2 特征向量单位化3.3 求 λ ( t ) \lambda(t) λ(t) 4. 交替特征值4.1 证明4.2 迭代交替特征值应用 1. 概述 这节课的主题是定义矩阵A是关于时间t的 A ( t ) A(t) A(t),在已知 d A ( t ) d t \frac{\mathrm{d}A(t)}{\mathrm{d}t} dtdA(t)​的情况下，求解 d A − 1 ( t ) d t , d λ ( t ) d t , d σ ( t ) d t \frac{\mathrm{d}A^{-1}(t)}{\mathrm{d}t},\frac{\mathrm{d}\lambda(t)}{\mathrm{d}t},\frac{\mathrm{d}\sigma(t)}{\mathrm{d}t} dtdA−1(t)​,dtdλ(t)​,dtdσ(t)​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23c5f3f12c9fcdcc2bd19e3ce4dfcd09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61e629462b62004d1769b353c166acd7/" rel="bookmark">
			.NET 一些常用的类型转换扩展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#region 转换为string
/// &lt;summary&gt;
/// 将object转换为string，若转换失败，则返回""。不抛出异常。 /// &lt;/summary&gt;
/// &lt;param name="obj"&gt;&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public static string ParseToString(this object obj)
{
return Convert.ToString(obj) ?? string.Empty;
}
#endregion
#region 转换为long
/// &lt;summary&gt;
/// 将object转换为long，若转换失败，则返回0。不抛出异常。 /// &lt;/summary&gt;
/// &lt;param name="obj"&gt;&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public static long ParseToLong(this object obj)
{
if (obj == null)
{
return 0;
}
else
{
bool boolean = long.TryParse(obj.ToString() ?? string.Empty, out long result);
return result;
}
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61e629462b62004d1769b353c166acd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f27a180e04023464952ee1b7728c917a/" rel="bookmark">
			计算机必背单词——算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这些都是我认为程序员需要掌握的单词，就算有些英文你不熟悉，但是对应的中文至少了解什么意思。
看完这个系列，希望你第一能认识更多单词，第二是拓宽自己的知识面，哪个概念不懂就自己去主动了解。
在计算机科学中，算法是解决问题和执行任务的明确指令序列。以下是一些算法相关的单词、词组、短语以及历史上一些著名的算法：
排序算法 (Sorting Algorithms):
Bubble Sort: 冒泡排序
Selection Sort: 选择排序
Insertion Sort: 插入排序
Merge Sort: 归并排序
Quick Sort: 快速排序
Heap Sort: 堆排序
Shell Sort: 希尔排序
Radix Sort: 基数排序
Counting Sort: 计数排序
Bucket Sort: 桶排序
搜索算法 (Search Algorithms):
Linear Search: 线性搜索
Binary Search: 二分搜索
Depth-First Search (DFS): 深度优先搜索
Breadth-First Search (BFS): 广度优先搜索
Uniform Cost Search: 均匀成本搜索
A* Search Algorithm: A*搜索算法
Greedy Best-First Search: 贪心最佳优先搜索
图算法 (Graph Algorithms):
Dijkstra's Algorithm: 迪杰斯特拉算法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f27a180e04023464952ee1b7728c917a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/996c10897f0b6287e0b5208a635d10bc/" rel="bookmark">
			Node.js车牌识别、文档识别、OCR API-自动化录入信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么人工智能如此受关注？因为人工智能技术在图片处理以及在感知与认知等领域的不断突破，带来更高的效率。没错，智能机器人、人工智能技术衍生的产品已经开始替代人的工作。文字录入工作较为显著，OCR技术成为手动录入的杀手锏，图片识别、扫描识别多样化的解决方案层出不穷。
文字录入不限于文档录入，像我们身份证、护照、银行卡、名片、发票上的信息，均可利用翔云OCR API来协助录入。在许多行业，如金融、保险、公安、银行、电信等，均需要采集用户身份证信息。智能身份证识别OCR，则能快速自动识别身份证上所有信息。翔云身份证识别API识别率高，识别速度快。可应用于移动投保、移动展业、移动查勘、移动警务、实名认证、直销银行等应用场景。
翔云银行卡识别API：支持普通版、竖版银行卡和异形卡，识别精准度高。适用于金融远程身份证认证、电商支付绑卡、车险手机投保、直销银行、APP实名认证等应用领域。从而实现用户信息的自动识别和录入，提升用户体验。
以翔云车牌识别接口Node.js开发语言为例：
var request = require('request'); var options = { 'method': 'POST', 'url': 'https://netocr.com/api/recogliu.do', 'headers': { }, formData: { 'img': '/9j', 'key': 'M***********g', 'secret': '3***********6', 'typeId': '19', 'format': 'json' } }; request(options, function (error, response) { if (error) throw new Error(error); console.log(response.body); }); 车牌识别在很大程度上，推动了智能交通的发展。翔云车牌识别API以其卓越的表现、高识别率获得了业界的认可。在智慧停车、汽车交易平台、汽车后市场、二手车交易、移动警务、汽车维修服务等应用场景中，提供了完美的车牌识别功能，并获得一致好评。
毋庸置疑，数字化技术高速的发展，正在逐步改变多种工作、生活方式。其中，工作的拆解将给许多职业带来颠覆性的冲击。可反观之，智能化和自动化也同时带来大量的机遇。翔云认为，我们应该探索如何能更有效地利用人工智能技术来解决、探索更多具有挑战性的问题。
车牌识别在很大程度上，推动了智能交通的发展。翔云车牌识别API以其卓越的表现、高识别率获得了业界的认可。在智慧停车、汽车交易平台、汽车后市场、二手车交易、移动警务、汽车维修服务等应用场景中，提供了完美的车牌识别功能，并获得一致好评。
毋庸置疑，数字化技术高速的发展，正在逐步改变多种工作、生活方式。其中，工作的拆解将给许多职业带来颠覆性的冲击。可反观之，智能化和自动化也同时带来大量的机遇。翔云认为，我们应该探索如何能更有效地利用人工智能技术来解决、探索更多具有挑战性的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f43984115d763580e65891c95b2c9e6c/" rel="bookmark">
			Elasticsearch中的Term_Filter过滤器技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、引言二、Term Filter的工作原理与内部机制三、Term Filter的多样化使用场景3.1 精确匹配3.2 过滤分类与标签3.3 数据范围筛选3.4 复杂查询的构建 四、Term Filter的最佳实践与应用建议4.1 避免使用分析器4.2 优化索引映射4.3 充分利用缓存4.4 持续监控性能 五、结语 在Elasticsearch中，查询和过滤是搜索操作的两个核心组成部分。查询用于返回匹配的文档，而过滤器则主要用于减少搜索结果的数量，同时不计算任何相关性得分。在处理大型数据集时，过滤器的性能显得尤为关键。本文将深入探讨Elasticsearch中的Term Filter过滤器技术，从它的工作原理、使用场景到最佳实践，带您全面了解这一重要工具。
一、引言 Term Filter是Elasticsearch中一个简单且高效的工具，它用于过滤出包含特定术语的文档。与全文本查询不同，Term Filter在内部利用倒排索引进行快速查找，由于不计算得分，它在处理大型数据集时展现出卓越的性能。这一特性使得Term Filter成为搜索应用中的关键组件，特别是在需要精确匹配和快速过滤的场景下。
二、Term Filter的工作原理与内部机制 Term Filter的工作原理主要基于Elasticsearch的倒排索引机制。倒排索引是一种特殊的数据结构，旨在快速定位包含特定术语的文档。在Elasticsearch中，每个字段都关联一个倒排索引，记录了该字段中所有唯一的术语及这些术语在哪些文档中出现。
当执行Term Filter查询时，Elasticsearch会在相应的倒排索引中迅速查找指定的术语。一旦找到匹配的术语，系统就会将包含该术语的所有文档作为查询结果返回。值得强调的是，由于Term Filter不进行相关性得分的计算，它只关注文档是否包含特定的术语，而忽略术语在文档中的出现频率、位置等细节。
此外，Term Filter的内部机制也值得探讨。在查询过程中，Elasticsearch会优化查询路径，尽可能减少不必要的磁盘I/O操作和CPU计算。这种优化确保了Term Filter在处理大量数据时的高效性。
三、Term Filter的多样化使用场景 3.1 精确匹配 在需要精确匹配特定术语的场景中，Term Filter发挥着关键作用。例如，在电商平台上，用户可能希望查找包含特定品牌或型号的产品。通过使用Term Filter，系统可以迅速定位并返回符合用户需求的产品，排除了其他不相关因素的干扰。
3.2 过滤分类与标签 在内容丰富的应用中，文档通常被归类到不同的分类或标签下。Term Filter使得根据这些分类或标签过滤文档变得轻而易举。以新闻应用为例，用户可能只对特定类别的新闻感兴趣，如“政治”或“体育”。通过应用Term Filter，系统能够精准地为用户呈现他们关心的新闻内容。
3.3 数据范围筛选 尽管Term Filter主要用于匹配单个术语，但它也可以与范围查询结合使用，从而筛选出落在特定范围内的文档。例如，在电商平台上，用户可能希望查找价格在某个区间内的商品。通过结合Term Filter和Range Query，系统能够高效地满足用户的这一需求。
3.4 复杂查询的构建 Term Filter的灵活性还体现在它可以与其他类型的过滤器结合使用，以构建更为复杂的查询。例如，通过Bool Filter，多个Term Filter可以被组合在一起，形成一个包含逻辑“与”、“或”或“非”条件的复合查询。这种组合查询在处理复杂搜索需求时具有极高的实用价值。
四、Term Filter的最佳实践与应用建议 4.1 避免使用分析器 在使用Term Filter时，务必确保不对查询术语使用分析器。分析器会对术语进行分词、标准化等操作，这可能导致查询失败或返回不准确的结果。为了获得最佳效果，建议将术语存储在“keyword”类型的字段中，并直接对这些字段进行查询。
4.2 优化索引映射 为了提高Term Filter的性能，对Elasticsearch的索引映射进行优化至关重要。这包括选择合适的字段类型、设置恰当的索引选项以及利用字段级安全性来限制对特定字段的访问。这些优化措施能够显著提升Term Filter的查询效率。
4.3 充分利用缓存 Elasticsearch具有自动缓存查询结果的功能，从而加速后续的相同或相似查询。为了最大化这一优势，建议在相同的会话中重复使用相同的查询条件，以便从缓存中获取结果。此外，通过合理配置Elasticsearch的缓存设置，可以进一步提高缓存命中率，从而提升整体性能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f43984115d763580e65891c95b2c9e6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8293cca2c66ac44d6439a2e3232f8fea/" rel="bookmark">
			MySQL表的增删改查初阶(下篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇会加入个人的所谓鱼式疯言
❤️❤️❤️鱼式疯言:❤️❤️❤️此疯言非彼疯言
而是理解过并总结出来通俗易懂的大白话,
小编会尽可能的在每个概念后插入鱼式疯言,帮助大家理解的.
🤭🤭🤭可能说的不是那么严谨.但小编初心是能让更多人能接受我们这个概念 ！！！
前言 在上一篇文章中，我们主要学习了认识 CRUD 的概念，以及如何在表中 新增数据 ，然后对表中已有的数据进行一系列的 指定列查询 ， 表达式查询，别名查询 ，去重查询 。
小伙伴们可以慢慢回忆下哦，而在本篇文章中，重点将围绕着对指定的 表 中已有的数据进行 查询 ，修改 ， 删除 的。
目录 排序查询
条件查询
修改数据
删除数据
一. 排序查询 1. SQL语句 &lt;1&gt;. 降序排序 select 指定列名 from 表名 order by 列名 desc ; &lt;2&gt;. 升序排序 select 指定列名 from 表名 order by [asc] 字段名; 2. 语句分析 对于 排序查询的标识关键字 就是后面 order by desc / asc 当我们需要指定一个表中的数据,按照某个字段的 大小顺序 进行 排序 时,需要升序就用 order by 字段名 asc 或者 order by 字段名 即可, 而降序就需要 order by 字段名 desc .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8293cca2c66ac44d6439a2e3232f8fea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b60dad8cd0a3d3b2c40e5399f7f48e4a/" rel="bookmark">
			java excel读写工具栏EasyExcel集成与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EasyExcel 是一个基于 Java 的简单、快速、内存开销小的读写 Excel 工具，非常适合处理大量数据的场景。
下面是如何在项目中集成 EasyExcel 并使用它来读写 Excel 文件的基本步骤：
1. 添加依赖 首先，在 Maven 项目的 pom.xml 文件中添加 EasyExcel 的依赖：
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;3.0.5&lt;/version&gt; &lt;!-- 请根据最新版本调整 --&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2. 创建数据模型类 EasyExcel 需要一个 Java Bean 来映射 Excel 表格中的每一行数据。
例如，创建一个 User 类：
public class User { private String name; private String email; private Integer age; // Getter 和 Setter 方法 } 3. 写入 Excel 创建一个工具类 ExcelUtil，用于操作 Excel 文件的读写：
import com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b60dad8cd0a3d3b2c40e5399f7f48e4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c74256c222cc7a4f7d4a37b471e20613/" rel="bookmark">
			【码银送书第二十一期】《大数据智能风控：模型、平台与业务实践》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人行印发的《金融科技（FinTech）发展规划（2022一2025年）》明确指出金融科技成为防范化解金融风险的利器，运用大数据、人工智能等技术建立金融风控模型，有效甄别高风险交易，智能感知异常交易，实现风险早识别、早预警、早处置，提升金融风险技防能力，金融科技在风险控制上已经成为重要基石。
作为经营风险的金融机构，风险管理已成商业银行的核心竞争力，其能否适应数字化转型趋势，将决定银行数字化转型的成败，所以商业银行更应高度关注大数据智能风控体系的建设，充分发挥数据和技术等生产要素价值，全面推进数字化风控体系建设，以高质量风控助力高质量发展，这样才能保证数字银行模式下经营和发展成果的真正落地及实现。
金融科技的发展加速推动银行业进入风控3.0时代。商业银行充分借助先进信息技术，建立基于人工智能和数据挖掘的风险管理模型，推动智能风控体系的构建。这种智能风控体系让金融科技、风险管理和业务经营有效地融合在一起，并在实践中不断完善和优化，实现全程智能风险管控，在风险可控的基础上，全力推动业务发展，为银行高质量发展提供更为强劲的动能。
原文链接（经机械工业出版社授权转载）：大数据智能风控内核
01 什么是大数据智能风控 商业银行作为金融中介机构，经营的本质是对风险的运营和管理。金融科技的高速发展和国家政策的扶持，驱动商业银行向数字化、信息化、智能化的更高阶段发展。在此背景下，商业银行更应抓住数字化转型机遇，建立覆盖风险识别、计量、分析、处置全流程的智能风控体系，全面提升银行风险防控能力。
传统的风控体系中定性风险管理占主体，以主观规则及客户评级为主，存在数据获取维度窄、定量分析能力偏弱、难以精确化用户特征等缺点。在数字化转型的背景下，传统的风险管控模式在风险管控时效性、模型有效性、监控范围等多个方面的短板日益凸显。
大数据智能风控利用不断完善的机器学习、自然语言处理、知识图谱等技术，结合持续提升的算法、数据、硬件处理能力，为解决风险领域的痛点问题提供了很好的契机。大数据智能风控利用多维数据，填补传统风控模式的缺口，从更全面的角度进行客户画像和风险评估，对客户的特征和行为进行全景分析展现，深入地理解、认识、分析和判断客户。
构建量化的、合理的、科学的风险评估模型和风控系统，建立覆盖全流程、全业务、全客户的风险管控措施，实现对反欺诈、授信、贷中监测和贷后管理的全方位一体化的智能防护体系，为各个渠道高风险交易提供实时的预警支持，将事后风险防控更好地推送到事前事中风险防控。
大数据智能风控利用数据、变量、模型、系统提高风险防控能力，已成为商业银行塑造互联网金融时代核心竞争力的重要举措。 02 数据：大数据智能风控的基石 大数据智能风控背后的力量就是大数据的技术和风险分析能力，对风控所提供数据的广度、深度、鲜活度都有较高的要求。然而数据虽然重要，但并不是所有的数据都有价值，只有经过治理、整合后的高质量数据才是大数据智能风控的基石。
大部分商业银行因为各种历史原因，导致数据不全、质量不高、应用不足等一系列问题持续存在，从而使风险数据利用效率不高，对风控决策支持造成制约。因此，建立完善的数据治理体系、数据标准和数据整合是风控平台建设的关键，如同城市建设修建下水道，数据治理是一项长期的、需要非常细致的脏活累活。因此需高度重视数据规范化管理，不仅要有采集海量数据的能力，更要有提炼整合各上下游系统数据统一存储能力，实现业务数据向数据资产的转化。
传统银行的数据使用常常局限在某个系统的业务流程中，却忽视与其他业务系统的关联数据，缺乏对大数据的深度理解。
相比之下，大数据智能风控能够存储海量数据并连通全域数据，建立统一规范的数据标准和质量体系，建设提纯加工后的标准数据资产体系，以满足银行对不同业务的数据需求。在对数据规范化处理后，大数据智能风控对数据进行资产化、服务化，提供数据服务，为业务赋能。
特别是对风险策略规则进行变量准备，创建用户画像体系、关系图谱，在线分析信贷业务跨系统数据查询能力，并为多部门任务协作等任务奠定数据基础，提供强大的分析工具和智能的数据可视化系统，为商业银行信贷各业务和各类分析提供支持和帮助。如见图1所示。
（图1 大数据智能风控的数据支持和服务）
03 特征变量：大数据智能风控的上限 风控领域常说的，“特征变量决定了模型的上限，而大数据智能风控只是逼近这个上限”。强大的特征工程能够显著提升风控的有效性，帮助风控更精准地识别欺诈行为、信用违约等风险事件。
风控特征变量体系的核心在于强化金融机构对风险的即时识别与高效应对能力，这一过程深入结合了多元化数据来源，通过精密的批流数据抽取机制、综合聚合技术以及深度衍生数据加工流程，构建出一个标准化、高度可拓展的特征变量统一平台。
该平台不仅确保了从原始数据摄取到特征生成、再到模型训练及最终决策实施的全链路畅通无阻，而且显著加快了风险事件的响应速率，同时提升了决策的精确性与灵敏度。如图2所示。
（图2 特征变量在智能风控中的定位）
在实时风控技术系架构中，特征变量计算包括了批计算、流计算及图计算。以流计算能力为例，相关技术栈提供了底层面向实时特征计算的能力，主要用于数据ETL、宽表加工、窗口计算等场景，通过预计算、状态聚合计算等能力实现原始特征变量、标准特征变量、衍生特征变量的加工，为决策模型提供特征支持。
模型引擎主要负责存储和管理经训练的各类模型，如信用评分模型、欺诈检测模型、流失预警模型等。决策引擎集中管理规则集、决策树、决策矩阵、评分卡等策略模型，规则集调用特征变量服务及模型引擎的模型服务参与决策流的逻辑运算。
特征变量引擎基于异构数据源，进行数据抽取、加工计算、标准化管理维护，实现风控人员自助查询，更加便捷、规范地进行业务取数和数据分析。具体见图3所述。
（图3 特征变量输出示意图）
04 模型：大数据智能风控的关键 风控的本质在于精准辨识、评估、监控各类潜在风险并采取有效应对措施，这要求我们具备高度敏感的风险雷达，及时发现任何可能撼动资金安全的隐患。大数据驱动的智能风控体系构建于一套精密的风险模型架构之上，该架构通过对数据的深度剖析实现风险的量化评估，揭示风险的本质及潜在影响。简言之，风控模型是将庞杂数据经由数学逻辑转化成未来趋势预测的桥梁，其中心逻辑围绕用户还款行为预测展开，实质上是对用户按时还款可能性的二元判断。
评分卡模型在此基础上更进一步，通过精密计算每位用户的个人信息，输出一个代表还款概率的数值。这一数值直接映射用户的信用等级——概率愈高，信用评分愈佳，意味着用户按时还款的可能性大增；反之，则预示着较高的违约风险及更低的信用评分。模型的核心价值，在于为策略规划提供科学依据，助力决策者精准施策。
实践操作中，智能风控模型深入挖掘用户数据，为每位用户绘制风险肖像，通过风险评分划分出如A、B、C、D等多个风险层级。根据不同层级特征，采取差异化策略：A级用户，凭借优良的信用背景，可享受更高信贷额度与优惠利率，成为我们服务的优先对象；相反，D级用户面临更为严格的条件，包括限制信贷额度与提高利率，以平衡风险敞口。
通过整合先进的模型体系至自动化信贷审批流程，借助大数据的广泛性、多元性和即时性优势，我们运用逻辑回归、支持向量机、自适应增强学习、决策树等多种算法（参见图4），全方位覆盖风险监测。
这些模型不仅融入设备指纹识别、复杂关系网络分析、图像与语音智能识别等前沿技术，还广泛应用于个人信贷的多样场景，深化信息挖掘与分析，形成闭环管理机制：从防御、识别、追踪、分析，到持续优化与实战反馈，确保信贷流程的每一步都配备风控的“智慧盔甲”，有效抵御欺诈行为，提前预警风险。
（图4 风控模型算法支持）
05 平台：大数据智能风控的支撑 风控模型怎么建，除了取决于模型团队对业务的理解、变量的挖掘、模型的开发，更重要的是风控平台的支撑。
风控平台作为风控平台的技术载体，是商业银行数字化转型的关键。传统建模工具通常缺乏对机器学习算法的直接支持，并且需要大量的人工编码。
这对于大部分银行建模人员来说，使用门槛比较高，导致以往商业银行使用传统建模工具建模时常常面临效率较低、模型迭代周期较长、操作烦琐、模型部署的位置不灵活等痛点，严重影响了模型效力的发挥。
大数据智能风控对平台的建设方向是基于灵活工作流引擎和决策规则引擎的信贷审批系统，可以将模型快速、灵活部署到运行环境，以便银行建模人员实现智能风控模型的便捷开发，智能风控系统架构可以支撑风控模型及时迭代优化，快速部署运行，保证模型的时效性，快速适应客群风险特征的变化，发挥智能风控的作用。具体如图5所示。
（图5 风控平台功能架构图）
06 大数据智能风控的内核 大数据智能风控如同一枚先进的火箭，驱使商业银行在风险管理领域实现腾跃。其中，风控数据如同燃料舱，为整个体系注入基础能量，覆盖广泛信息以供深入挖掘。
风控变量则好比引擎的火箭中枢，将海量数据转化为具体的风险评估指标，引导决策方向。风控模型作为火箭头，运用先进算法处理变量，精准预测风险，驱动高效决策制定。
而风控系统则是综合的火箭助推器，整合数据处理、模型应用及策略执行，确保贷前、贷中、贷后及反欺诈等各环节协调运作，形成从数据到决策的闭环管理。如图6所示。
（图6 大数据智能风控内核展示 ）
在大数据智能风控的框架下，数据扮演着基石角色，其质量和多样性直接关乎分析变量的有效性，而变量则构成了模型精准度的基石，界定着风险管理效能的理论边界。
模型作为这一系统的心脏，驱动着商业银行在复杂多变的风险环境中实现精准识别、精密评估与动态监控，进而采取针对性的防范策略。与此同时，高效稳定的平台架构是实施这一切的载体，确保风控策略与模型能够迅速响应市场变化，灵活适应客户群体风险特征的演化，维持智能风控机制的灵敏度与实用性。
四位一体——数据、变量、模型、平台，共同织就了大数据智能风控的内在核心，为信贷业务的全周期管理，即从贷前审查的严谨性、贷中监控的即时性、贷后管理的有效性，到反欺诈机制的前瞻性，提供了全方位、深层次的保障。
这一综合体系不仅是风险控制的坚固防线，也是信贷业务健康发展的助推器，确保在风险可控的前提下，促进金融资源的合理配置与服务效率的持续提升。如图7所示。
（图7：风控内核-四位一体）
07 《大数据智能风控：模型、平台与业务实践》 这是一本深入讲解智能风控理论体系和风控全生命周期业务实践的著作。作者基于在银行业10余年的风控经验，首先详细讲解了“大数据、模型、风控平台”三位一体的智能风控体系，能为风控实践提供扎实的理论指导；然后围绕风控的全生命周期，从贷前评估、贷中监控、贷后管理以及智能反欺诈、智能催收等角度全面讲解了智能风控的业务实践，深刻揭示了智能风控体系的精髓。
第1~2章全面而深入地探讨了智能风控的背景知识：首先对基础信贷业务进行了细致解析，读者可以从中了解其运作方式和重要性；然后，梳理了智能风控是如何随着技术的进步和市场的需求逐渐成熟和完善的。
第3~5章围绕“数据、模型、风控平台”三位一体的智能风控理论体系展开：首先介绍了内部数据、外部数据、个人征信数据在智能风控中的应用，以及智能数据体系的构建；然后深入探讨了智能风控模型的算法、评价指标、开发流程；最后讲解了风控平台的理论框架、设计原则、架构设计、建设流程以及决策引擎的建设。
第6~8章围绕风控的全生命周期探讨了风控策略在实际业务中的应用，包括贷前评估、贷中监控、贷后管理，以及智能反欺诈和智能催收体系的建设和业务实践，能帮助读者将理论知识转化为实际操作能力，更好地应对现实业务中的挑战。
第9章对智能风控的未来发展进行了展望，不仅为读者揭示了未来的机遇，也提供了对于如何应对未来挑战的思考。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c74256c222cc7a4f7d4a37b471e20613/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/845ddf334903deca958e07b4d52066f7/" rel="bookmark">
			springboot项目东方通TongWeb改造适配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboot项目东方通TongWeb改造适配 一、背景 在全球化背景下，为确保国家安全、推动产业升级、满足市场需求和技术进步，国产化成为国家发展战略的重要组成部分，旨在打造一个更加安全、自主、可控的信息技术生态环境。本文章的背景就是客户企业响应国产化政策，要求系统能够适配东方通，在东方通TongWeb上部署运行。
二、改造项目介绍 本文章改造适配的项目是使用的前后端分离的框架，只记录后端springboot项目的改造适配的过程。改造的项目使用的springboot是2.4.3版本。项目在生产环境都是打包成jar包，用jar包部署运行。
三、适配东方通 本文章记录的适配方式有两种，一种是嵌入式适配，在pom.xml中直接配置依赖，嵌入内置TongWeb容器，替代Tomcat，适配完成后打包成可执行 jar 包，按照原来的jar包方式部署运行。另外一种是打包成可执行 war 包，使用TongWeb进行安装部署。
本次项目适配版本：
tongweb嵌入式版本是TongWeb7.0.E.6_P8。
TongWeb企业版的版本是TongWeb7.0.4.9_M3。
1.嵌入式适配 根据东方通官方文档介绍，TongWeb 嵌入式版 Web 容器需要结合 Spring Boot 框架应用，TongWeb 应用服务器运行所需的 jar 资源包，可以根据不同的场景进行引入分别支持以下四种方式引入容器依赖 jar 资源包。
• 方式一：pom.xml中直接配置依赖
• 方式二：嵌入可执行 jar 包
• 方式三：嵌入可执行 war 包
• 方式四：作为外部 jar 包
本次采用的适配方式是方式一，在pom.xml中直接配置依赖。
1.1 pom.xml中直接配置依赖 在springboot项目的pom.xml中配置tongweb-spring-boot-starter依赖，同时排除掉springboot自带的 tomcat 的依赖。（在前面改造项目介绍时提到了springboot的版本，是因为这种方式不同的springboot版本引入相关依赖的版本不同）
&lt;!-- 排除springboot自带的tomcat依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- 添加tongweb-spring-boot-starter依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.tongweb.springboot&lt;/groupId&gt; &lt;artifactId&gt;tongweb-spring-boot-starter-2.x&lt;/artifactId&gt; &lt;version&gt;7.0.E.6_P8&lt;/version&gt; &lt;/dependency&gt; 如果在pom.xml中单独引入了tomcat相关的依赖，也需要去掉。比如下图的就是本次项目中的tomcat相关依赖，全部注释掉了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/845ddf334903deca958e07b4d52066f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e811ba00ccb2994cff255ec5d501fb53/" rel="bookmark">
			go 通过hash，查币安链交易代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个简单的示例代码，用于通过哈希值查询币安链交易：
package main
import (
"encoding/json"
"fmt"
"io/ioutil"
"net/http"
)
func queryBinanceTransactionByHash(hash string) {
url := "https://api.binance.com/api/v3/tx/" + hash
resp, err := http.Get(url)
if err!= nil {
fmt.Println("Error fetching transaction:", err)
return
}
defer resp.Body.Close()
body, err := ioutil.ReadAll(resp.Body)
if err!= nil {
fmt.Println("Error reading response:", err)
return
}
var transaction map[string]interface{}
json.Unmarshal(body, &amp;transaction)
fmt.Println(transaction)
}
func main() {
hash := "your_hash_value"
queryBinanceTransactionByHash(hash)
}
请将 your_hash_value 替换为你要查询的实际哈希值。
这只是一个基本的示例，实际的查询可能需要根据币安链的具体要求和 API 进行进一步的调整和优化。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4b6bcf860369135344295598d75f056/" rel="bookmark">
			关于html内嵌vuejs使用iframe无法加载vue实例解决方案，使用bootstrap再iframe
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述：html内嵌vuejs，manage页面也采用vue进行iframe跳转，这个时候无法加载vue实例。具体原因不明，解决方案如下：bootstrap做管理页面，再通过iframe加载html内嵌vue的页面
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Management Dashboard with Bootstrap&lt;/title&gt; &lt;!-- Bootstrap CSS --&gt; &lt;link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"&gt; &lt;style&gt; /* Custom styles for main content */ #main-content { padding: 20px; overflow: hidden; /* Hide scrollbar */ position: relative; /* Required for absolute positioning inside */ } /* Style for iframe */ #main-iframe { width: 100%; height: 100%; border: none; position: absolute; top: 0; left: 0; right: 0; bottom: 0; overflow-y: auto; /* Enable scrolling */ padding-right: 17px; /* Compensate for scrollbar width */ box-sizing: content-box; /* Adjust content box for padding-right */ } /* Custom styles for sidebar */ #sidebar { background-color: #343a40; /* Dark background color */ color: #f8f9fa; /* Light text color */ height: 100vh; /* Full height */ position: sticky; top: 0; overflow-y: auto; /* Enable scrolling */ padding-top: 20px; /* Padding at the top */ } /* Sidebar title */ #sidebar .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4b6bcf860369135344295598d75f056/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/666774a7d621569e33d536245d343c65/" rel="bookmark">
			openEuler搭建hadoop Standalone 模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Standalone 升级软件安装常用软件关闭防火墙修改主机名和IP地址修改hosts配置文件下载jdk和hadoop并配置环境变量配置ssh免密钥登录修改配置文件初始化集群windows修改hosts文件测试 1、升级软件 yum -y update 2、安装常用软件 yum -y install gcc gcc-c++ autoconf automake cmake make \ zlib zlib-devel openssl openssl-devel pcre-devel \ rsync openssh-server vim man zip unzip net-tools tcpdump lrzsz tar wget 3、关闭防火墙 sed -i 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/selinux/config setenforce 0 systemctl stop firewalld systemctl disable firewalld 4、修改主机名和IP地址 hostnamectl set-hostname hadoop vim /etc/sysconfig/network-scripts/ifcfg-ens32 参考如下：
TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=none DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=eui64 NAME=ens32 UUID=55e7ac28-39d7-4f24-b6bf-0f9fb40b7595 DEVICE=ens32 ONBOOT=yes IPADDR=192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/666774a7d621569e33d536245d343c65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bd088433e083682e49ec067f3721893/" rel="bookmark">
			计算机必背单词——数据结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这些都是我认为程序员需要掌握的单词，就算有些英文你不熟悉，但是对应的中文至少了解什么意思。
看完这个系列，希望你第一能认识更多单词，第二是拓宽自己的知识面，哪个概念不懂就自己去主动了解。
数据结构是计算机科学的基础，用于有效地存储和管理数据。以下是一些更详细的数据结构相关的单词、词组或短语：
基本数据结构:
Primitive Data Types: 原始数据类型
Integer: 整数
Float: 浮点数
Char: 字符
String: 字符串
Boolean: 布尔值
线性数据结构:
Dynamic Array: 动态数组
Singly Linked List: 单向链表
Doubly Linked List: 双向链表
Circular Linked List: 循环链表
Stack (LIFO): 栈（后进先出）
Queue (FIFO): 队列（先进先出）
Priority Queue: 优先队列
树形数据结构:
Binary Search Tree (BST): 二叉搜索树
Balanced Tree: 平衡树
AVL Tree: AVL树
Red-Black Tree: 红黑树
Segment Tree: 线段树
Fenwick Tree / Binary Indexed Tree (BIT): 树状数组
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bd088433e083682e49ec067f3721893/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61634b67f1d31d3953d2ab647fb4be28/" rel="bookmark">
			Java中的Socket编程详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中的Socket编程详解
大家好，我是免费搭建查券返利机器人省钱赚佣金就用微赚淘客系统3.0的小编，也是冬天不穿秋裤，天冷也要风度的程序猿！
Socket编程是网络编程的重要组成部分，用于实现计算机之间的通信。Java提供了强大的Socket编程API，方便开发者创建网络应用。本文将详细介绍Java中的Socket编程，包括基本概念、客户端和服务器端的实现，以及一些常见的应用场景和优化技巧。
什么是Socket Socket是一种通信机制，允许不同主机之间通过网络进行数据交换。Socket编程主要涉及两个端点：客户端和服务器端。客户端发起连接请求，服务器端监听并响应请求，实现数据的双向传输。
Java中的Socket类 Java的java.net包提供了Socket编程的相关类，主要包括以下几个：
Socket：表示客户端的Socket。ServerSocket：表示服务器端的Socket，监听客户端连接请求。InetAddress：表示互联网地址，可以通过主机名或IP地址创建。 实现客户端和服务器端 1. 创建服务器端 服务器端需要创建一个ServerSocket实例，指定监听的端口号，然后调用accept方法等待客户端连接。一旦连接建立，可以通过Socket对象进行数据传输。
示例：
import java.io.*; import java.net.*; public class Server { public static void main(String[] args) { int port = 8080; // 服务器端口 try (ServerSocket serverSocket = new ServerSocket(port)) { System.out.println("服务器启动，等待客户端连接..."); while (true) { try (Socket socket = serverSocket.accept()) { System.out.println("客户端连接成功！"); BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream())); PrintWriter out = new PrintWriter(socket.getOutputStream(), true); String message; while ((message = in.readLine()) !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61634b67f1d31d3953d2ab647fb4be28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80404e17d64d2d07e1fef8e1fd2021aa/" rel="bookmark">
			Ollama深度探索：AI大模型本地部署的全面教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 引言一、Ollama概述1、定义与定位2、核心功能3、技术优势4、应用场景 二、安装与配置1、系统要求2、安装方法3、配置指南4、启动Ollama服务 四、快速开始1、启动Ollama2、部署运行模型3、REEST API 五、自定义模型1、定制化的必要性2、使用Modelfile定制模型3、参数调整4、训练和微调模型 六、高级功能1、多模态模型支持2、REST API的高级用法3、编程语言库 结语 引言 我们正处在人工智能技术飞速发展的时代，其中大型语言模型（LLMs）已成为技术革新的前沿话题。这些模型以其强大的语言理解和生成能力，正在改变我们与机器交互的方式，并在自然语言处理（NLP）、内容创作、代码生成等多个领域展现出巨大的潜力。
本地化AI的新篇章
Ollama作为一个创新的工具，它的核心使命是简化大型语言模型在本地环境中的运行和管理。这不仅为开发者提供了一个强大的平台来部署和定制AI模型，而且也使得终端用户能够更加私密和安全地与这些智能系统进行交互。
隐私与便捷性的平衡
随着对数据隐私和安全性的日益关注，Ollama提供了一种解决方案，允许用户在不依赖外部服务器或云服务的情况下，直接在本地机器上运行复杂的AI模型。这种离线使用方式对于那些对隐私敏感或网络连接不稳定的用户来说尤其有价值。
面向未来的技术
Ollama不仅仅是一个技术工具，它代表了一种面向未来的思维方式。通过提供易于使用的接口和丰富的模型库，Ollama正在推动AI技术的民主化，让更多人能够访问和利用这些先进的模型，以解决实际问题并创造新的可能性。
一、Ollama概述 1、定义与定位 Ollama是一个专为本地环境设计的轻量级、可扩展的框架，用于构建和运行大型语言模型（LLMs）。它不仅仅是一个简单的运行时环境，而是一个完整的生态系统，提供了从模型创建、运行到管理的全套解决方案。Ollama的出现，标志着在本地机器上部署和操作复杂AI模型的新纪元。
2、核心功能 Ollama的核心功能包括但不限于以下几点：
模型运行：支持多种大型语言模型的本地运行，无需依赖远程服务器。模型管理：提供模型的下载、更新、删除等管理功能。自定义模型：允许用户通过Modelfile自定义模型参数和行为。API支持：提供REST API和编程语言库（如Python和JavaScript），方便集成到各种应用中。多模态能力：支持图像等多模态数据的处理和分析。安全性：注重数据的加密和安全传输，保护用户隐私。 3、技术优势 Ollama的技术优势在于其对本地化部署的重视，以及对开发者友好的接口设计：
本地化部署：降低了对网络的依赖，提高了数据处理的隐私性。易用性：简化了模型部署流程，使得即使是初学者也能快速上手。灵活性：通过Modelfile和API，提供了高度的定制性和集成性。社区支持：拥有活跃的社区和丰富的文档，便于用户学习和交流。 4、应用场景 Ollama的应用场景广泛，包括但不限于：
自然语言处理：文本生成、翻译、摘要等。代码生成与辅助：自动生成代码、代码补全等。教育与研究：作为教学工具，帮助学生理解AI模型的工作原理。企业解决方案：定制化模型以满足特定业务需求。 二、安装与配置 1、系统要求 在开始安装Ollama之前，确保您的系统满足以下基本要求：
操作系统：macOS、Windows 10及以上版本、Linux（包括但不限于Ubuntu、Fedora）内存：至少4GB RAM，推荐8GB或以上，具体取决于所运行模型的大小硬盘空间：至少100GB的空闲空间，用于安装Ollama及其模型库 2、安装方法 Ollama支持多种安装方式，包括通过包管理器、Docker或从源代码编译。
通过包管理器安装
对于macOS用户，可以使用Homebrew进行安装：brew install ollama 对于Linux用户，可以使用包管理器如apt（Ubuntu）或dnf（Fedora）：curl -fsSL https://ollama.com/install.sh | sh 或者sudo apt install ollama # Ubuntu sudo dnf install ollama # Fedora Docker安装
Ollama提供了官方的Docker镜像，可以通过Docker Hub获取并运行：docker pull ollama/ollama docker run -p 11434:11434 ollama/ollama 从源代码编译
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80404e17d64d2d07e1fef8e1fd2021aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67af44360e3820178c0bda71b51bdd9e/" rel="bookmark">
			景联文科技构建高质量多轮对话数据库，赋能AI交互新飞跃
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近年来，大语言模型的发展极大推动了自然语言处理领域的进步，大语言模型正引领智能对话领域进入一个全新时代，不仅提升了对话体验的自然度和效率，也为探索更加人性化、智能化的交互方式开辟了道路。
景联文科技作为大语言模型数据服务商，提供海量优质大语言模型数据集，致力于为不同训练阶段的算法精准匹配高质量数据资源。
结合用户需求场景，构建高质量多轮对话数据库，累计2万人共创5000多万轮高质量对话数据库，并对数据库进行了规则制定、数据制造指导、排查、筛重、复核等加工环节，由专人对所有的语料进行模拟编撰，每一个环节都有专人审核，形成一个完整的质量保证体系。
产品数量
文本多轮对话1500万
中英文剧本（电影、电视剧、剧本杀）6万
平行语料：英译其他47语种，1.1亿对；中译其他50语种，2.1亿对；英中950万对。
内容领域分布
对轮对话数据库覆盖多行业，包含电信行业、电商行业、教育行业、金融行业、心理咨询、医疗行业、法律援助、剧情类对话、谜语/脑筋急转弯等。
数据样例
所有数据均提供word、txt、json 格式，均经过严格流程把关，数据准确率99%，重复率低于1%。
景联文科技具备强大的技术实力和丰富的经验，完善的基础设施和专业的技术团队，为对话数据集创作者们提供稳定、高效的在线创作平台。
在技术方面，我们提供丰富的创作工具和提示词库，满足不同领域创作者的需求，让每个人都能发挥自己的创意。
在服务方面，我们提供全面的数据分析和反馈机制，帮助创作者们更好地了解创作过程和成果，不断优化和提升创作质量。
同时，拥有自己的“敏感词数据库”，可以有效避免出现敏感词而造成不必要的法律纠纷。
获取样例请登录景联文科技官网咨询客服。https://www.jinglianwen.com/ai/
或直接发送需求至邮箱：lx@jinglianwen.com
景联文科技｜数据采集｜数据标注｜多轮对话数据库
助力人工智能技术，赋能传统产业智能化转型升级
文章图文著作权归景联文科技所有，商业转载请联系景联文科技获得授权，非商业转载请注明出处。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b9a0ecb0f78188551ea0c8c45945acb/" rel="bookmark">
			【netty】三万字详解！JAVA高性能通信框架，关于netty，看这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.概述
2.hello world
3.EventLoop
4.channel
4.1.同步
4.2.异步
4.3.调试
4.4.关闭
4.5.为什么要用异步
5.future
6.promise
7.pipeline
8.byteBuf
8.1.创建
8.2.内存模式和池化
8.2.1.内存模式
8.2.2.池化
8.3.组成
8.4.操作
8.4.1.读写
8.4.2.释放
8.5.零拷贝
8.5.1.slice
8.5.2.composite
8.6.工具类
9.双向通信
10.粘包半包
10.1.问题成因
10.2.解决办法
10.2.1.短连接
10.2.2.解码器
1.概述
2.定长解码器
3.行解码器
4.固定帧长的解码器
11.协议解析
11.1.Redis
11.2.Http
12.协议设计
12.1.概述
12.2.编码
1.概述 netty，说人话就是封装NIO做出来的一个JAVA高性能通信框架。在JAVA领域，有高性能网络通信需求的时候，绝大多数都会选择netty作为通信框架。
关于JAVA的通信，我猜想可能博主的另外两篇关于BIO和NIO的文章作为本文的导读会不错：
详解TCP-CSDN博客
详解JAVA Socket-CSDN博客
JAVA BIO_java的bio有哪些-CSDN博客
全网最清晰JAVA NIO，看一遍就会-CSDN博客
netty底层就是封装的NIO。如果自己使用NIO的话至少会有以下的不便：
需要自己构建协议。
需要自己解决TCP传输问题，如粘包、半包。
API过于底层，不便于使用。
netty其实就是封装了一下NIO，使得NIO更便于使用。
2.hello world 依赖：
&lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;4.1.39.Final&lt;/version&gt; &lt;/dependency&gt; 服务器：
import io.netty.bootstrap.ServerBootstrap; import io.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b9a0ecb0f78188551ea0c8c45945acb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d330935938a1b3b4e3008ff4f1faa08/" rel="bookmark">
			【C&#43;&#43;】哈希的概念及STL中有关哈希容器的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、unordered系列关联式容器1.1 标准库中的unordered_set1.1.1 unordered_set的介绍1.1.2 unordered_set的常用接口说明1.1.2.1 unordered_set对象的常见构造1.1.2.1.1 [无参构造函数](https://legacy.cplusplus.com/reference/unordered_map/unordered_map/)1.1.2.1.2 [有参构造函数（使用迭代器进行初始化构造）](https://legacy.cplusplus.com/reference/unordered_map/unordered_map/)1.1.2.1.3 [拷贝构造函数](https://legacy.cplusplus.com/reference/unordered_map/unordered_map/) 1.1.2.2 unordered_set iterator 的使用1.1.2.2.1 [begin()函数](https://legacy.cplusplus.com/reference/unordered_set/unordered_set/begin/)1.1.2.2.2 [end()函数](https://legacy.cplusplus.com/reference/unordered_set/unordered_set/end/) 1.1.2.3 unordered_set 对象的容量操作1.1.2.3.1 [size()函数](https://legacy.cplusplus.com/reference/unordered_set/unordered_set/size/)1.1.2.3.2 [empty()函数](https://legacy.cplusplus.com/reference/unordered_set/unordered_set/empty/) 1.1.2.4 unordered_set 对象的增删查改及访问1.1.2.4.1 [insert()函数](https://legacy.cplusplus.com/reference/unordered_set/unordered_set/insert/)1.1.2.4.2 [erase()函数](https://legacy.cplusplus.com/reference/unordered_set/unordered_set/erase/)1.1.2.4.3 [swap()函数](https://legacy.cplusplus.com/reference/unordered_set/unordered_set/swap/)1.1.2.4.4 [clear()函数](https://legacy.cplusplus.com/reference/unordered_set/unordered_set/clear/)1.1.2.4.5 [find()函数](https://legacy.cplusplus.com/reference/unordered_set/unordered_set/find/)1.1.2.4.6 [count()函数](https://legacy.cplusplus.com/reference/unordered_set/unordered_set/count/) 1.1.2.5 unordered_set的桶操作1.1.2.5.1 [bucket_count()函数](https://legacy.cplusplus.com/reference/unordered_set/unordered_set/bucket_count/)1.1.2.5.2 [bucket_size()函数](https://legacy.cplusplus.com/reference/unordered_set/unordered_set/bucket_size/)1.1.2.5.3 [bucket()函数](https://legacy.cplusplus.com/reference/unordered_set/unordered_set/bucket/) 1.2 标准库中的unordered_map1.2.1 unordered_map的介绍1.2.2 unordered_map的常用接口说明1.2.2.1 unordered_map对象的常见构造1.2.2.1.1 [无参构造函数](https://legacy.cplusplus.com/reference/unordered_map/unordered_map/unordered_map/)1.2.2.1.2 [有参构造函数（使用迭代器进行初始化构造）](https://legacy.cplusplus.com/reference/unordered_map/unordered_map/unordered_map/)1.2.2.1.3 [拷贝构造函数](https://legacy.cplusplus.com/reference/unordered_map/unordered_map/unordered_map/) 1.2.2.2 unordered_map iterator 的使用1.1.2.2.1 [begin()函数](https://legacy.cplusplus.com/reference/unordered_map/unordered_map/begin/)1.2.2.2.2 [end()函数](https://legacy.cplusplus.com/reference/unordered_map/unordered_map/end/) 1.2.2.3 unordered_set 对象的容量操作1.2.2.3.1 [size()函数](https://legacy.cplusplus.com/reference/unordered_map/unordered_map/size/)1.2.2.3.2 [empty()函数](https://legacy.cplusplus.com/reference/unordered_map/unordered_map/empty/) 1.2.2.4 unordered_map对象的增删查改及访问1.2.2.4.1 [insert()函数](https://legacy.cplusplus.com/reference/unordered_map/unordered_map/insert/)1.2.2.4.2 [operator[]](https://legacy.cplusplus.com/reference/unordered_map/unordered_map/operator%5B%5D/)1.2.2.4.3 [erase()函数](https://legacy.cplusplus.com/reference/unordered_map/unordered_map/erase/)1.2.2.4.4 [swap()函数](https://legacy.cplusplus.com/reference/unordered_map/unordered_map/swap/)1.2.2.4.5 [clear()函数](https://legacy.cplusplus.com/reference/unordered_map/unordered_map/clear/)1.2.2.4.6 [find()函数](https://legacy.cplusplus.com/reference/unordered_map/unordered_map/find/)1.2.2.4.7 [count()函数](https://legacy.cplusplus.com/reference/unordered_map/unordered_map/count/) 1.2.2.5 unordered_map的桶操作1.2.2.5.1 [bucket_count()函数](https://legacy.cplusplus.com/reference/unordered_map/unordered_map/bucket_count/)1.2.2.5.2 [bucket_size()函数](https://legacy.cplusplus.com/reference/unordered_map/unordered_map/bucket_size/)1.2.2.5.3 [bucket()函数](https://legacy.cplusplus.com/reference/unordered_map/unordered_map/bucket/) 二、底层结构2.1 哈希概念2.2 哈希冲突2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d330935938a1b3b4e3008ff4f1faa08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bcb2cc8950a2244719c252f84b58b51/" rel="bookmark">
			Java中的设计模式：实战案例分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中的设计模式：实战案例分享
大家好，我是免费搭建查券返利机器人省钱赚佣金就用微赚淘客系统3.0的小编，也是冬天不穿秋裤，天冷也要风度的程序猿！
设计模式是软件开发中的宝贵工具，它们为常见的问题提供了经过验证的解决方案，帮助开发者编写出可维护、可扩展的代码。在Java编程中，设计模式更是发挥了重要作用。本文将分享几种常见的Java设计模式，并通过实战案例来展示它们的实际应用。
一、单例模式（Singleton Pattern） 1. 模式简介 单例模式确保一个类只有一个实例，并提供一个全局访问点。它常用于需要全局唯一实例的场景，如配置管理、日志记录等。
2. 实战案例 假设我们需要设计一个日志记录器，确保整个系统中只有一个日志记录器实例。
public class Logger { private static Logger instance; private Logger() { // 私有构造函数 } public static Logger getInstance() { if (instance == null) { synchronized (Logger.class) { if (instance == null) { instance = new Logger(); } } } return instance; } public void log(String message) { System.out.println(message); } } public class Main { public static void main(String[] args) { Logger logger = Logger.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bcb2cc8950a2244719c252f84b58b51/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/242/">«</a>
	<span class="pagination__item pagination__item--current">243/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/244/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>