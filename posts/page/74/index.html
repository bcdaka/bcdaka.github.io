<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/089eab8d7370c5296cbea5e77edbcf40/" rel="bookmark">
			如何在生成式AI里使用 Ray Data 进行大规模 RAG 应用的 Embedding Inference
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		检索增强生成 (RAG) 是企业级生成式 AI（GenAI）应用的热门案例之一。多数 RAG 教程演示了如何利用 OpenAI API 结合 Embedding 模型和大语言模型（LLM）来进行推理（Inference）。然而，在开发过程中，如果能使用开源工具，就可以免去访问自己数据的费用，同时也能加快迭代。
在 Embedding 步骤（即将数据转换为向量的过程）中，使用 Ray Data 取得的性能提升尤为显著。相比于使用 Pandas，采用 Ray Data 等工具对批量推理请求进行汇总处理可以显著节省资源和处理时间。例如，在一台配备 16GB RAM 的 Mac M2 笔记本电脑上，仅使用四个 worker node，Ray Data 的处理速度就比 Pandas 快了 60 倍！本文将详细介绍使用 Milvus + Ray Data 进行 Embedding inference 的性能。
我们的开源 RAG 技术栈包括：
BGM-M3 Embedding 模型：该模型能一次性生成三种类型的向量，包括稀疏向量、稠密向量和多向量。
Ray Data：高效的分布式 Embedding inference 推理工具。
AWS S3：用于临时存储推理结果。
Milvus 或 Zilliz Cloud：用作向量数据库。
示例数据来源：Kaggle 的 IMDB 海报数据集。
开源 RAG 技术栈 BGM-M3 Embedding 模型 BGM-M3 Embedding 模型是一种强大的多功能 Embedding 工具，其特点在于能够处理多语言（Multi-Linguality）、多功能（Multi-Functionality）和多粒度（Multi-Granularity）的数据，因此得名“M3”。该模型支持超过 100 种语言，并能计算三种常见的 Embedding 类型：稀疏向量、稠密向量和多向量。它还可以处理各种长度的文本——从短句到长文档，最多可支持 8192 个 token。更多详情，请参考论文或通过 HugginFace 网站了解此模型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/089eab8d7370c5296cbea5e77edbcf40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e488ab10ba1907ec7e823e165c560c21/" rel="bookmark">
			国产版Sora复现——智谱AI开源CogVideoX-2b 本地部署复现实践教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、CogVideoX简介二、CogVideoX部署实践流程2.1、创建丹摩实例2.2、配置环境和依赖2.3、上传模型与配置文件2.4、开始运行 最后 一、CogVideoX简介 智谱AI在8月6日宣布了一个令人兴奋的消息：他们将开源视频生成模型CogVideoX。目前，其提示词上限为 226 个 token，视频长度为 6 秒，帧率为 8 帧 / 秒，视频分辨率为 720*480，而这仅仅是初代，性能更强参数量更大的模型正在路上。先看两个效果（均为个人本次实践复现得出）：
CogVideoX生成视频1
CogVideo生成视频2
首先简单介绍下原理，CogVideoX的核心在于它的3D变分自编码器，这项技术能够将视频数据压缩至原来的2%，极大地降低了模型处理视频时所需的计算资源，还巧妙地保持了视频帧与帧之间的连贯性，有效避免了视频生成过程中可能出现的闪烁问题。
为了进一步提升内容的连贯性，CogVideoX采用了3D旋转位置编码（3D RoPE）技术，使得模型在处理视频时能够更好地捕捉时间维度上的帧间关系，建立起视频中的长期依赖关系，从而生成更加流畅和连贯的视频序列。
在可控性方面，智谱AI研发了一款端到端的视频理解模型，这个模型能够为视频数据生成精确且与内容紧密相关的描述。这一创新极大地增强了CogVideoX对文本的理解和对用户指令的遵循能力，确保了生成的视频不仅与用户的输入高度相关，而且能够处理超长且复杂的文本提示。
代码仓库：https://github.com/THUDM/CogVideo模型下载：https://huggingface.co/THUDM/CogVideoX-2b技术报告：https://github.com/THUDM/CogVideo/blob/main/resources/CogVideoX.pdf丹摩智算平台：https://damodel.com/register?source=1D5686A0 本篇博客将详细介绍，使用丹摩服务器部署和初步使用CogVideoX的实践流程。
二、CogVideoX部署实践流程 2.1、创建丹摩实例 首先进入控制台，选择GPU云实例，点击创建实例：
由于CogVideoX在FP-16 精度下的推理至少需 18GB 显存，微调则需要 40GB 显存，我们这里可以选择L40S显卡（推荐）或者4090显卡，硬盘可以选择默认的100GB系统盘和50GB数据盘，镜像选择PyTorch2.3.0、Ubuntu-22.04，CUDA12.1镜像，创建并绑定密钥对，最后启动。
2.2、配置环境和依赖 进入JupyterLab后，打开终端，首先输入git clone https://github.com/THUDM/CogVideo.git，拉取CogVideo代码的仓库，如遇到github连接超时，可以使用本地下载压缩包然后上传到服务器解压，拉取成功后会显示CogVideo-main的文件夹如下：
其次，cd进入CogVideo-main文件夹，输入pip install -r requirements.txt安装对应依赖:
其中第一个依赖需要从GitHub仓库中安装特定版本的diffusers包，在安装中可能会出现Running command git clone --filter=blob:non过久：
这种情况可以选择使用本地下载diffusers-0.30.0.dev0-py3-none-any.whl文件（夸克网盘链接：https://pan.quark.cn/s/67d4bf445556）
再使用pip install diffusers-0.30.0.dev0-py3-none-any.whl安装对应版本的diffusers
然后再删除requirements.txt文件中的git+https://github.com/huggingface/diffusers.git@878f609aa5ce4a78fea0f048726889debde1d7e8#egg=diffusers那一行
最后，继续使用pip安装剩下的依赖：
以上依赖安装好后，可以在终端输入python，然后输入以下代码进行测试：
import torch from diffusers import CogVideoXPipeline from diffusers.utils import export_to_video 显示如下状态，没有报错就说明依赖安装成功！
2.3、上传模型与配置文件 除了配置代码文件和项目依赖，还需要上传CogVideoX模型文件和对应的配置文件。打开huggingface，进入https://huggingface.co/THUDM/CogVideoX-2b/tree/main仓库，找到Files and versions目录，将其中的所有模型和配置文件全部下载到本地。
一共大概9GB+大小的文件，下载完成后的目录如下：
然后点击丹摩控制台-文件存储-上传文件，将刚刚下载好的整个CogVideo文件夹上传，上传好后的文件存在实例的/root/shared-storage目录。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e488ab10ba1907ec7e823e165c560c21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fa027e1542f9a04e0f85f5bc257f293/" rel="bookmark">
			程序编译及链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你好！感谢支持孔乙己的新作，本文就程序的编译及链接与大家分析我的思路。
希望能大佬们多多纠正及支持！！！
个人主页：爱摸鱼的孔乙己-CSDN博客 ​ ​
1.翻译译环境与运行环境 当我们进行程序设计时，使用编译器、开发工具编写代码（.c文件），则需要在翻译环境，通过编译将文件中源代码转换为可执行的机器指令（二进制指令），作用于运行环境实际执行代码。
1.1.翻译环境 顾名思义，翻译环境是由编译和链接两大过程组成的，编译又可拆分为：预处理（有些书籍或许称之为预编译）、编译、汇编三个过程。 在一个包含多个.C文件的项目中，多个.C文件单独进行编译并生成对应的目标文件（Windows环境下的目标文件后缀是.obj，Linux环境下后缀是.o） 多个目标文件和链接库一起经过链接器处理生成最终的可执行程序（链接库是指运行时库支持程序运行的基本函数集合或者第三方库）
接下来，我们观察一下编译器的进程：
首先，编译过程始于源文件，通常是以.c或.cpp结尾的代码文件。接下来，这些源文件经过预处理，生成一个中间文件（通常是.i文件），在这个阶段，预处理会处理宏定义和文件包含等指令。随后，预处理后的文件被编译，生成汇编语言文件（通常是 .s 文件）。在这个过程中，编译器将源代码转换为更接近机器语言的形式。接下来是链接阶段，编译器将生成的汇编文件与标准库（如 libc.a）进行链接。链接器在这一阶段负责将所有目标文件和库文件合并，最终生成可执行文件。最后，经过链接器处理后，输出的可执行文件便是用户可以运行的最终结果。
1.2.预处理（预编译） 在预处理阶段，源文件和头文件会被处理为.i 为后缀的文件。在预处理阶段主要是处理源文件中#开始的预编译指令，处理规则如下：
• 将所有的 #define 删除，并展开所有的宏定义。 • 处理所有的条件编译指令，如： #if、#ifdef、#elif、#else、#endif 。 • 处理#include 预编译指令，将包含的头⽂件的内容插⼊到该预编译指令的位置。 这个过程是递归进⾏的，也就是说被包含的头⽂件也可能包含其他⽂件。 • 删除所有的注释 • 添加⾏号和⽂件名标识，⽅便后续编译器⽣成调试信息等。 • 或保留所有的#pragma的编译器指令，编译器后续会使⽤。 1.3.编译 编译过程就是将预处理的文件进行一系列操作：词法分析、语法分析、语义分析及优化，并生成相应的汇编代码文件。
1.3.1.词法分析 将源代码程序输入扫描器，进行简单的词法分析，把代码中字符分割成一系列的记号（关键字、标识符、字面符与特殊符号） 记号 类型array标识符【左方括号index 标识符
】右方括号=赋值（左圆括号index标识符+加号4数字）右圆括号*乘号（左圆括号2数字+加号6数字）右圆括号 1.3.2.语法分析 接下来语法分析器，将对扫描产⽣的记号进⾏语法分析，从⽽产⽣语法树。这些语法树是以表达式为节点的树。 1.3.3.语义分析 由语义分析器来完成语义分析，即对表达式的语法层⾯分析。编译器所能做的分析是语义的静态分析。静态语义分析通常包括声明和类型的匹配，类型的转换等。这个阶段会报告错误的语法信息。 1.4.链接 链接作为一个复杂的过程，链接时需要把一堆文件链接在一起方可生成可执行程序。链接的过程主要包括：地址和空间分配，符号决议和重定位这些步骤；链接解决的是一个项目中多文件、多模块之间互相调用的问题。
1.5.运行环境 程序必须载入内存中，在有操作系统的环境中：一般这个由操作系统完成。在独立的环境中，程序的载入必须由手工安排，也可能是通过可执行代码置入只读内存来完成；程序的执行便开始，紧接着，调用main函数，开始执行程序代码，这个时候程序将使用一个运行时堆栈（stack），存储函数的局部变量和返回地址。程序同时也可以使用静态（static）内存，存储于静态内存中的变量在程序的整个执行过程一直保留他们的值，终止程序。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbdb2a1c7383e412ebd6c54914580983/" rel="bookmark">
			Crowd-SAM：SAM作为拥挤场景中目标检测的智能标注器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 目标检测是一项重要任务，广泛应用于各种场景。通常，它需要大量的标签进行训练，这相当耗时，尤其是在拥挤的场景中。最近，Segment Anything Model（SAM）作为一种强大的零样本分割器应运而生，为实例分割提供了一种新颖的方法。然而，在处理拥挤场景中经常出现遮挡的物体时，SAM及其变体的准确性和效率往往受到损害。在本文中，我们提出了Crowd-SAM，一个基于SAM的框架，旨在以少量可学习参数和最少标记图像为代价，增强SAM在拥挤场景中的性能。我们引入了一个高效的提示采样器（EPS）和一个部分-整体区分网络（PWD-Net），有助于掩码选择，并提高了拥挤场景中的准确性。尽管其设计简单，但Crowd-SAM在包括CrowdHuman和CityPersons在内的多个基准测试中，与最先进的完全监督目标检测方法不相上下。我们的代码可在https://github.com/FelixCaae/CrowdSAM上获得。
关键词：拥挤场景中的检测 ⋅ \cdot ⋅ 少样本学习 ⋅ \cdot ⋅ Segment Anything Model
1、引言 在自动驾驶和视频监控等领域中，拥挤场景下的目标检测是一项基础任务。主要焦点在于识别和定位行人和车辆等密集分布的常见目标，其中遮挡现象带来了重大挑战。近年来，包括两阶段方法[45,60]和基于查询的方法[8,22,62]在内，已经取得了巨大进展。然而，这些方法主要遵循监督学习的方式，并需要大量带标签的训练样本，这带来了相当高的标注成本，每个目标大约需要42.4秒[38]。拥挤场景的密度和复杂性进一步加剧了标注负担。
收集目标标注的高成本促使人们探索替代方案，如小样本学习[34,39,44]、弱监督学习[41,53]、半监督学习[29,30,42,49]和无监督学习[1,6,21,26,48]。其中表现最好的是半监督目标检测（SSOD），它利用带标签和未带标签的数据进行训练，并在常见的基准测试（如PASCAL VOC[15]和COCO[24]）上取得了巨大成功。不幸的是，SSOD引入了额外的复杂性，如复杂的增强技术和在线伪标签。
近年来，基于提示的分割模型因其灵活性和可扩展性而越来越受到关注。特别是，Segment Anything Model（SAM）[20]展现了其高效且准确地预测由提示指定的区域掩码的高能力，这些提示可以是点、框、掩码或文本描述等多种形式。认识到其非凡的潜力，研究人员已付出诸多努力将其应用于各种视觉任务，如医学图像识别[31]、遥感分析[4, 12]、工业缺陷检测[52]等。
尽管在SAM之后取得了巨大进展[18,46,54]，但将SAM应用于拥挤场景中的目标检测却鲜有研究。在本文中，我们基于两个动机研究了SAM在这种情况下的潜力。首先，SAM在一个非常大的数据集SA-1B上进行了预训练，该数据集包含了大多数常见目标，因此合理利用这些知识来促进大规模数据的标注和训练一个全新的检测器是合理的。其次，SAM在处理由聚集在一起的目标组成的复杂场景时，展现出了强大的分割能力，这对于从头开始训练的目标检测器来说是非常困难的。
为此，我们提出了Crowd-SAM，一种由SAM驱动的智能标注器，用于拥挤场景中的目标检测。如图1所示，我们引入了一种基于DINOv2的自促进方法，以减轻人工提示的成本。我们的方法采用配备了高效提示采样器（EPS）的密集网格，以适中的成本覆盖尽可能多的目标。为了在遮挡场景中精确区分多个输出中的掩码，我们设计了一个掩码选择模块，称为部分-整体判别网络（PWD-Net），该网络学习在交并比（IoU）分数中区分质量最高的输出。凭借其轻量级模型设计和快速训练计划，它在包括CrowdHuman[37]和CityPersons[58]在内的公共基准测试中表现出色。
我们的贡献可以概括如下：
我们提出了Crowd-SAM，一种自提示分割方法，用于标注包含聚集目标的图像，仅需少量示例即可产生准确结果。
我们为Crowd-SAM设计了两个新颖组件，即EPS和PWD-Net，它们有效地释放了SAM在拥挤场景中的能力。
我们在两个基准测试上进行了全面的实验，以证明Crowd-SAM的有效性和可推广性。
2、相关工作 目标检测。通用目标检测旨在识别和定位目标，主要分为两类：即一阶段检测器和二阶段检测器。一阶段检测器利用图像特征预测边界框和类别分数[23, 27, 35]，而二阶段检测器则首先生成区域候选框，然后对其进行分类和细化[9, 10, 36]。最近，端到端目标检测器如DETR[2, 55, 63]通过在训练阶段采用一对一匹配来替代手工设计的模块（如非极大值抑制NMS），在多个领域展现出巨大潜力。
然而，将这些检测器直接应用于行人检测往往会导致性能下降，因为行人通常处于拥挤且遮挡的环境中。早期工作[32]提出将额外特征集成到行人检测器中，以探索低级视觉线索，而后续方法[5, 56]则尝试利用头部区域进行更好的表示学习。在[56]中，一个锚点与目标整体和头部部分相关联，通过联合训练实现更鲁棒的检测器。AdaptiveNMS[25]通过预测行人密度来调整NMS阈值。其他方法则侧重于损失函数的设计以改进训练过程。例如，RepLoss[45]鼓励对同一目标的预测一致性，同时排斥来自不同目标的预测。最近，Zheng等人[62]通过建模查询之间的关系，改进了基于DETR的检测器在拥挤场景中的表现，并取得了显著成效。尽管这些工作已将拥挤场景中的目标检测推向了新的阶段，但它们都依赖于大量标记样本进行训练，这非常耗时费力。这一局限性促使我们借助SAM开发标签高效的检测器和自动标注工具。
小样本目标检测（Few-Shot Object Detection，FSOD）。该任务旨在在有限的训练样本下检测新类别的目标。FSOD方法大致可分为基于元学习的方法[16,51]和基于微调的方法[34,39,44]。Meta-RCNN[51]通过孪生网络并行处理查询图像和支持图像。将查询图像中的感兴趣区域（Region of Interest，RoI）特征与类别原型融合，以有效迁移从支持集中学习的知识。TFA[44]提出了一种简单的两阶段微调方法，仅微调网络的最后几层。FSCE[39]在微调阶段引入了监督对比损失，以缓解分类错误问题。De-FRCN[34]停止来自区域候选网络（Region Proposal Network，RPN）的梯度，并缩放来自R-CNN[36]的梯度，随后使用原型校准块来优化分类得分。
分割万物模型（Segment Anything Models，SAM）。SAM[20]是一个用于分割任务的视觉基础模型，采用半监督学习范式在SA-1B数据集上进行训练。由于其接触到了庞大的训练样本库，SAM成为了一个高度通用的类别无关模型，能够有效处理世界上各种各样的对象。尽管SAM在解决分割任务时表现出色，但仍存在领域迁移、效率低下、类别无关设计等问题。HQ-SAM[18]通过学习一个轻量级适配器来提高其分割质量。Fast-SAM[50]和Mobile-SAM[54]则通过知识蒸馏来加快SAM的推理速度。RSprompt[4]通过生成适当的提示，使SAM能够为遥感图像生成语义上不同的分割结果。Med-SA[47]提出了一种空间深度转置方法，使2DSAM能够适应3D医学图像，并设计了一个超提示适配器以实现基于提示的条件适应。不幸的是，这些方法需要大量的标记数据才能进行有效适应，这使得它们在标注成本高昂的拥挤场景中不切实际。与它们不同，Per-SAM[57]和Matcher[28]通过提取无需训练的相似性先验，教会SAM仅通过一个或少数几个实例来识别特定对象。SAPNet[46]为实例分割构建了一个弱监督流程。尽管这些方法降低了数据要求，但它们仍然无法满足拥挤场景（如行人检测，尤其是存在遮挡的情况）的需求。
3、方法 3.1、预备知识 SAM[20]是一个强大且有前景的分割模型，由三个主要组件组成：（a）一个负责特征提取的图像编码器；（b）一个设计用于编码用户提供的几何提示的提示编码器；以及（c）一个轻量级的掩码解码器，该解码器根据给定的提示预测掩码。利用广泛的训练数据，SAM在各种基准测试中展示了令人印象深刻的零样本分割性能。特别是，SAM使用点和框作为提示来指定感兴趣的区域。
DINO[3]代表了一类以自监督方式学习的Vision Transformer（ViT）[7]，专为通用应用而设计。在训练过程中，DINO采用了一种类似于BYOL[11]的自蒸馏策略，促进了鲁棒表示的学习。DINOv2[33]通过集成多个额外的预训练任务来加强DINO的基础，提高了其可扩展性和稳定性，特别是对于大型模型（如具有10亿参数的ViT-H）。得益于其增强功能，DINOv2在语义分割任务中表现出了强大的表示能力。
3.2、问题定义与总体框架 问题定义。如图1所示，我们的目标是在标记数据很少的情况下，检测拥挤场景中的对象（如行人）。我们将此问题表述为一类小样本检测任务。常见的小样本流程是将数据分为基础集和新集。不同的是，我们直接使用目标类的数据进行模型训练，因为基础模型已经在大规模数据上进行了训练。特别是，我们采用分割掩码作为中间结果，这些结果可以很容易地转换为边界框。在训练和评估过程中，仅提供边界框标注。
对SAM自动生成器的初步研究。提示数量会影响SAM的性能，我们针对拥挤场景分析了这一问题。在此情况下，我们使用SAM的自动生成器在CrowdHuman[37]上进行了几项初步研究，该自动生成器利用网格点搜索每个区域。表1传达了三个关键观察结果：（1）拥挤场景需要密集的网格；（2）点提示和类别无关提示的分布模糊性导致了许多假正例（FPs）；（3）当网格尺寸较大时，解码时间是一个不可忽视的负担。因此，密集的提示和假正例的去除是在设计用于拥挤场景中检测/分割任务的基于SAM的方法时的关键方面。
总体框架。受上述研究的启发，我们为SAM[20]配备了几个适当的组件，以实现一个准确且高效的标注框架，如图2所示。为了准确定位成簇的对象，我们采用基础模型DINOv2[33]来预测语义热图，这是一项可以通过简单的二分类器完成的任务。为了区分输出掩码（由正确掩码、背景和部分级掩码的混合组成），我们设计了部分-整体区分网络（PWD-Net），该网络将SAM学习到的标记和DINOv2的语义丰富标记作为输入，以重新评估所有输出。最后，为了处理密集网格使用带来的冗余问题，我们提出了一种高效的提示采样器（EPS），以适中的成本解码掩码。
我们将在以下部分介绍我们方法的详细情况。
3.3、特定类别的提示生成 在拥挤场景中为每个对象（如行人）生成一个独特的点提示实际上是一个非平凡的问题。因此，我们退后一步，研究如何使用与单个对象相关联的多个提示来检测对象，并应用适当的后处理技术来去除重复项。为此，我们采用了一种基于热图的提示生成流程，该流程首先对区域进行分类，然后从正区域生成提示。
对于输入图像 I ∈ R H × W × 3 I \in \mathbb{R}^{H \times W \times 3} I∈RH×W×3，我们首先使用预训练的图像编码器 E D E_{D} ED​ 来提取富含语义的特征。为了更好地将这些预训练特征转移到对象分割任务中，我们在最终输出层之后添加一个多层感知机（MLP）块，从而获得适应后的特征 F D I N O ∈ R H s × W s × C F_{D I N O} \in \mathbb{R}^{\frac{H}{s} \times \frac{W}{s} \times C} FDINO​∈RsH​×sW​×C，其中 s s s 是DINOv2[33]的块大小， C C C 是输出通道数。然后，我们使用一个分割头 H e a d C L S Head_{C L S} HeadCLS​ 对 F D I N O F_{D I N O} FDINO​ 进行逐像素分类，生成一个热图 H ^ ∈ [ 0 , 1 ] H s × W s \hat{\mathbb{H}} \in[0,1]^{\frac{H}{s} \times \frac{W}{s}} H^∈[0,1]sH​×sW​，该热图指示了对象的位置，即 H ^ = Head ⁡ C L S ( F D I N O ) \hat{\mathbb{H}}=\operatorname{Head}_{C L S}\left(F_{D I N O}\right) H^=HeadCLS​(FDINO​)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbdb2a1c7383e412ebd6c54914580983/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbcfb5342fe8617327fbd1614544ee2c/" rel="bookmark">
			在没有硬盘的情况下进行电脑数据迁移
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电脑数据迁移方式 在更换电脑的时候需要进行文件的传输，但是没有硬盘可以选择使用网线直连或者无线文件共享。 通用配置 1.将旧电脑的文件夹或者磁盘设置文件共享
找到指定的文件夹右键属=》属性，点击共享=》点击高级共享
选择共享文件夹以及修改共享用户以及权限
2.更改网络共享中心适配器
3.启动Windows功能 SMB1.0/CIFS
找到控制面板=》程序=》启用或关闭Windows功能
网线直连文件共享 用网线连接两台电脑，然后修改新旧电脑的ip
修改旧电脑，将ip改为192.168.0.2，子网掩码255.255.255.0，网关192.168.0.1
找到控制面板=》网络和 Internet =》网络和共享中心 修改新电脑，将ip改为192.168.0.3，子网掩码255.255.255.0，网关192.168.0.1
步骤同上，只是ip不同最后
在新电脑 Win+r 输入cmd，弹出命令框ping旧电脑的ip是否连通
通过win+r 输入“\旧电脑ip”
弹出共享的文件夹就可以传输啦
无线文件共享 通过无线传输则需要再同一个局域网下，执行网线直连的最后一步即可，
在新电脑 Win+r 输入cmd，弹出命令框ping旧电脑的ip是否连通
通过win+r 输入“\旧电脑ip”
弹出共享的文件夹就可以传输啦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/252bc4d510474fa18efbf40ec1aeb335/" rel="bookmark">
			【sdk】- 对接阿里云抠图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文档地址：https://help.aliyun.com/zh/viapi/use-cases/general-image-segmentation?spm=a2c4g.11186623.0.0.3814173cenldIs
java对接阿里云的通用分割，将代码原封不动复制进来，执行结果失败，咨询阿里云的人员之后，由于jar包冲突导致，需要引入一些特定的包版本来实现
pom引用 &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;imageseg20191230&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;tea-openapi&lt;/artifactId&gt; &lt;version&gt;0.3.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;tea-console&lt;/artifactId&gt; &lt;version&gt;0.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;tea-util&lt;/artifactId&gt; &lt;version&gt;0.2.22&lt;/version&gt; &lt;/dependency&gt; &lt;!--在我的服务中必须手动再次引人，不然报错--&gt; &lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;/dependency&gt; 代码 只需要改pom，对于获取环境变量中的ak信息，完全没必要。
public class AliyunApiService { public static com.aliyun.imageseg20191230.Client createClient(String accessKeyId, String accessKeySecret) throws Exception { /* 初始化配置对象com.aliyun.teaopenapi.models.Config Config对象存放 AccessKeyId、AccessKeySecret、endpoint等配置 */ com.aliyun.teaopenapi.models.Config config = new com.aliyun.teaopenapi.models.Config() .setAccessKeyId(accessKeyId) .setAccessKeySecret(accessKeySecret); // 访问的域名 config.endpoint = "imageseg.cn-shanghai.aliyuncs.com"; return new com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/252bc4d510474fa18efbf40ec1aeb335/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c77211aefa27a53035425790f190c7a8/" rel="bookmark">
			深入解析数据仓库ADS层-从理论到实践的全面指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在大数据时代,数据仓库已经成为企业进行数据分析和决策的核心系统。而在数据仓库的分层架构中,ADS(Application Data Store)层作为最上层的数据应用层,直接面向业务应用和分析需求,其重要性不言而喻。然而,很多数据从业者对ADS层的理解还停留在表面,不清楚如何构建高效的ADS层来支撑复杂的业务场景。
本文将带您深入剖析ADS层的本质,全面介绍ADS层的设计原则、实现方法和最佳实践,帮助您构建一个真正能够驱动业务价值的数据应用层。
目录 什么是ADS层?为什么它如此重要?ADS层的设计原则1. 业务导向2. 性能优先3. 口径一致4. 可扩展性5. 安全可控 ADS层的实现方法1. 确定数据集市2. 设计星型模型3. 实现预计算4. 优化查询性能5. 实现数据安全6. 提供数据字典 ADS层的最佳实践1. 增量更新机制2. 版本控制3. 监控和告警4. 文档和元数据管理5. 性能调优6. 数据生命周期管理7. 持续优化和迭代 ADS层的未来展望结语 什么是ADS层?为什么它如此重要? ADS层全称Application Data Store,即应用数据存储层,是数据仓库分层架构中最接近应用的一层。它直接面向业务应用、报表系统、数据产品等,提供结构化的主题数据集市(Data Mart)。
与其他数据仓库层级相比,ADS层具有以下特点:
面向应用:数据模型和粒度完全匹配具体应用需求高度汇总:通常是多维度的汇总数据,而非原子级数据查询性能优:采用星型模型等OLAP友好的模式设计变更频繁:随业务需求变化而不断调整数据量适中:通过汇总降低了数据量级 ADS层的重要性主要体现在:
屏蔽底层复杂性,为应用提供简单视图提升查询性能,支持交互式分析确保数据口径一致性,避免"数出多门"灵活应对多变的业务需求支撑数据产品开发,释放数据价值 可以说,ADS层的设计好坏直接决定了整个数据仓库能否真正发挥作用、为业务赋能。那么,如何构建一个优秀的ADS层呢?让我们一步步深入探讨。
ADS层的设计原则 要构建一个优秀的ADS层,我们需要遵循以下关键设计原则:
1. 业务导向 ADS层的首要原则是业务导向。每个数据集市都应该对应明确的业务主题,如销售分析、用户画像、供应链优化等。在设计时,我们需要深入理解业务需求,包括:
关键业务问题是什么?需要哪些维度进行分析?关注哪些指标?数据的时效性要求如何?查询模式是怎样的? 只有充分理解业务需求,才能设计出真正有价值的ADS模型。
2. 性能优先 ADS层直接面向应用查询,性能至关重要。我们需要从多个角度保证查询性能:
模型设计:采用星型模型等OLAP友好的模式预计算:提前计算常用的聚合指标分区:根据查询模式合理设置分区策略物化视图:为高频查询路径创建物化视图索引优化:根据查询特征创建合适的索引 3. 口径一致 ADS层是确保全公司数据口径一致性的最后一道防线。我们需要:
统一维度定义:如时间维度的粒度、客户分类的标准等统一指标口径:如GMV、DAU等关键指标的计算规则提供数据字典:详细解释每个字段的含义和计算逻辑 4. 可扩展性 业务需求是不断变化的,ADS层的设计必须具备良好的可扩展性:
使用通用的维度和事实表设计,便于横向扩展预留冗余字段,为未来可能的需求变更做准备采用模块化的设计,便于垂直扩展新的数据集市 5. 安全可控 作为直接面向应用的数据层,ADS层的安全至关重要:
实现细粒度的访问控制,确保数据只对有权限的用户可见对敏感信息进行脱敏处理实现完整的操作审计,记录所有数据访问行为 ADS层的实现方法 理解了设计原则,接下来让我们看看如何具体实现ADS层。
1. 确定数据集市 首先需要根据业务需求,确定需要构建哪些数据集市。常见的数据集市包括:
销售分析集市用户画像集市商品分析集市营销效果分析集市供应链优化集市财务分析集市 每个数据集市都应该对应一个明确的业务主题和应用场景。
2. 设计星型模型 对于每个数据集市,我们通常采用星型模型进行设计。以销售分析集市为例:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c77211aefa27a53035425790f190c7a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e35e833e76d9850bf4064f726bfd5a1/" rel="bookmark">
			【爬虫实战】利用代理爬取电商数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言工具介绍实战获取网站数据编写代码数据展示 推荐总结 前言 当今电商平台正经历着快速的转型与升级。随着技术的进步和用户需求的多样化，电商不仅从简单的在线购物演变为综合性的购物生态系统，还融合了人工智能、大数据和云计算等先进技术。平台通过精准的用户数据分析，提供个性化的购物体验，优化了商品推荐和服务，显著提升了用户满意度和忠诚度。
在这一过程中，爬虫技术扮演了至关重要的角色。通过自动化的数据抓取，爬虫可以高效地收集竞争对手的产品信息、价格变动和市场趋势，为商家提供宝贵的市场洞察。它不仅帮助商家进行实时的价格调整和库存优化，还支持更精确的市场分析和风险预警，使电商平台在竞争激烈的环境中保持领先地位。
工具介绍 工欲善其事必先利其器。今天给大家推荐的是Proxy302，它是一个专业的全球代理IP采购平台，提供按需付费的充值方式、最全面的代理类型以及简洁高效的用户界面。我们来展开描述下他的特色。
按需付费，无月付套餐：无需套餐捆绑购买，按需付费，充值即可使用所有类型的代理IP，无阶梯式定价。最全面代理类型：Proxy302提供市面上最全面的代理类型，满足各种业务需求。 全球240＋国家和地区，6500万个住宅IP可供选择。 Proxy302支持HTTP、SOCKS5网络协议的代理。 Proxy302支持动态、静态代理，代理类型分为【动态按流量扣费】、【动态按IP扣费】、【静态按流量扣费】、【静态按IP扣费】，静态代理还分为住宅IP、数据中心IP。 简洁易用：用户界面简洁而不简单，易用且高效。提供浏览器扩展插件，实现一键设置代理，省去复杂配置步骤。 福利：点击右上角的调查问卷即可马上获取$1测试额度。
实战获取网站数据 这次我们要抓取的是某个知名的购书网站，内容包括：标题、链接、价格和图片链接。为了避免被检测为爬虫，我们首先需要获取登录用户的cookie。登录后，按下F12键，进入“网络”选项，选择任意一个流量记录，在请求头中找到cookie并复制下来。
然后，我们需要分析一下搜索框搜索“华为手机”之后的请求路径。可以从下图中看到，我们点击搜索之后，请求URL为https://search.dangdang.com/?key=%BB%AA%CE%AA%CA%D6%BB%FA&amp;act=input&amp;page_index=1，其中key为“华为手机”的转码，act为动作，page_index代表当前页是第一页。
接着我们需要确认商品元素在页面中的结构。可以观察到，所有商品都位于一个&lt;ul&gt;标签中，每个商品对应一个&lt;li&gt;标签，并且都有相应的class标记。
具体来说，标题位于&lt;p&gt;标签的title属性中，链接在&lt;a&gt;标签的href属性里，图片链接位于下层的&lt;img&gt;标签中，价格则位于另一个&lt;p&gt;标签中。接下来，我们将使用XPath来定位这些标签。
首先我们打开【帮助中心】
点击【快速入门】下的【查看更多】按钮
我们可以看到【非海外环境如何使用代理？】的标题，通过该内容我们了解到有4种实现海外环境的方式。此处阿Q选择使用VPN的方式进行，简单有效。
选择【静态IP】下的【按IP扣费】选项，选择【购买天数】和【国家】之后点击【生成】按钮即可获取到静态住宅IP。
出现下图即表示获取静态IP成功。
编写代码 拿到静态ip之后我们需要定义 get_html_str 函数，来向电商网站发送搜索请求：先定义请求头，模拟浏览器访问，其中包含了一些cookie信息。然后配置我们的代理信息，包含我们拿到的静态代理IP。最后发送HTTP请求到指定的URL，并返回网页源码。
# 发送请求，获取网页源码 def get_html_str(url): # 请求头模拟浏览器（注意这里一定添加自己已经登录的cookie才可以） headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36', 'cookie': '' } # 添加代理IP，此处是我们刚拿到的静态代理ip proxies = ""; # proxies = {} # 添加请求头和代理IP发送请求 response = requests.get(url, headers=headers, proxies=proxies) # 获取网页源码 html_str = response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e35e833e76d9850bf4064f726bfd5a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f2a38942a64659d0b79fe1dbbc1d100/" rel="bookmark">
			c＋＋STL中list介绍，模拟实现和list与vector对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言 ：
1. list的介绍及使用
1.1list的介绍·
1.2 list的使用 1.2.1 list的构造
1.2.2 list iterator的使用 1.2.3 list capacity
1.2.4 list element access
1.2.5 list modiﬁers 1.2.6 list的迭代器失效 2. list的模拟实现 3. list与vector的对比 前言 ： 我们在前几期已经详细介绍了STL中string，vector容器的使用及模拟实现，不难发现，string和vector的结构很相似，他们在物理上都是连续的结构，想访问下一个位置的数据，只需要让相应容器的迭代器自增就可以实现，而我们今天要介绍的list，则无法用这种方法访问下一个位置数据，这也是我们在这一期需要解决的问题。
1. list的介绍及使用 1.1list的介绍· 1. list是可以在常数范围内在任意位置进行插入和删除的序列式容器，并且该容器可以前后双向迭代。
2. list的底层是双向链表结构，双向链表中每个元素存储在互不相关的独立节点中，在节点中通过指针指向其前一个元素和后一个元素。
3. list与forward_list非常相似：最主要的不同在于forward_list是单链表，只能朝前迭代，已让其更简单高效。
4. 与其他的序列式容器相比(array，vector，deque)，list通常在任意位置进行插入、移除元素的行效率更好。
5. 与其他序列式容器相比，list和forward_list最大的缺陷是不支持任意位置的随机访问，比如：要访问list的第6个元素，必须从已知的位置(比如头部或者尾部)迭代到该位置，在这段位置上迭代需要线性的时间开销；list还需要一些额外的空间，以保存每个节点的相关联信息(对于存储类型较小元素的大list来说这可能是一个重要的因素）
list的结构就是我们在数据结构篇学过的双向带头循环链表，以这种结构实现的链表，使用起来比一般的链表更加方便，我们只要得到哨兵位就可以轻松得到链表的其他结点，看上去复杂但是实现起来确实最简单的链表。
1.2 list的使用 与vector一样，list中的接口比较多，此处类似，只需要掌握如何正确的使用，然后再去深入研究背后的原理，已达到可扩展的能力。以下为list中一些常见的重要接口。
1.2.1 list的构造 1.2.2 list iterator的使用 此处，大家可暂时将迭代器理解成一个指针，该指针指向list中的某个节点。
注意事项：
1. begin与end为正向迭代器，对迭代器执行++操作，迭代器向后移动
2. rbegin(end)与rend(begin)为反向迭代器，对迭代器执行++操作，迭代器向前移动 1.2.3 list capacity 1.2.4 list element access 1.2.5 list modiﬁers 以上就是list中核心的日常使用得比较多的接口，当然，list还有许多接口，在需要使用的时候我们可以通过查看文档来学习各个接口的使用方法，这也是作为程序员的基本的能力之一。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f2a38942a64659d0b79fe1dbbc1d100/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7027ee1adc8b4959db3c2e875c9af3b/" rel="bookmark">
			过拟合与欠拟合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，什么是过拟合和欠拟合 打个比方，一个小学生学习数学，刚开始可能什么也不会，慢慢开始学。对于学习较慢的同学，练习题都还没学懂就考试了，结果当然没考好。对于学习能力非常强的同学，才刚开始，所有的题都做会了，之后没事干，天天重复看以前做过的题，最后导致看到原题不用算就能背出答案，由于天天看原来的题，导致思维固化，原题稍微一改就想不出解决方法了。
上面这个例子就深度阐述了过拟合和欠拟合的关系，即
欠拟合：该学的没学会，要做的没做对。(训练集和测试集表现都不好)
过拟合：学的太猛，思维固化，只会做过的。（训练集表现很好，测试集表现不好）
两者的共同点是： 要做的做不对，即在测试集上表现不佳(如果表现好就不是问题了，就变成方法了)
二，过拟合出现的原因以及解决方法 1. 训练时间太久 -&gt; 减少训练时间
2. 数据质量很差。
一个是数据噪声大，一个有错误数据，一个是数据类型单一。 需要进行数据清洗或增加数据。
可能会过度捕捉数据的细节，导致过拟合。
3. 模型太大太复杂。
比如用GPT-3.5来学习论语，那就太小题大作了。数据集的大小应该与模型的大小相匹配。
方法：
4. Dropout。
随机丢弃一些参数不用去训练，这可以理解成一种特殊的集成学习，即每批数据都对应不同的一组参数，这组参数可以认为是一个子网络，每批数据都有一个子网络来进行学习，这样可以让不同的神经元不是很依赖其他的神经元，能够去学到更加鲁棒的特征表示。
5. 集成学习方法bagging。
通过用多个模型去学习数据，从而学习到不同方面的特征，来提高泛化能力，减小方差，降低过拟合的风险。
6. 交叉验证，如K折交叉验证。
通过循环学习，能够防止对特定的数据集过度拟合。
三，欠拟合出现的原因及解决方法 1. 训练时间太短 -&gt; 加长训练时间
2. 模型太简单学不会 -&gt; 模型变大，变深
3. 数据质量。
数据噪声过多，有错误。
可能会因噪声多无法捕捉数据的潜在特征，包括被噪声覆盖的特征。
4. 集成学习方法boosting。
通过顺序学习，能够尽可能的降低偏差，从而降低欠拟合的风险。
四，误差的推导，方差，偏差 其中消去的交叉项, 交叉项三项之间认为是独立的，那么E[XY] = E[X]E[Y], 其中
可得到最后三个交叉项消除
参考链接
欠拟合的原因以及解决办法（深度学习）_欠拟合的原因及解决办法-CSDN博客
dwnlpinterview/BasicAlgorithm/过拟合和欠拟合.md at main · hrwleo/dwnlpinterview (github.com)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23546629ddafcd64268bce58579634c1/" rel="bookmark">
			人工智能深度学习系列—深入解析：均方误差损失（MSE Loss）在深度学习中的应用与实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人工智能深度学习系列—深度解析：交叉熵损失（Cross-Entropy Loss）在分类问题中的应用
人工智能深度学习系列—深入解析：均方误差损失（MSE Loss）在深度学习中的应用与实践
人工智能深度学习系列—深入探索KL散度：度量概率分布差异的关键工具
人工智能深度学习系列—探索余弦相似度损失：深度学习中的相似性度量神器
人工智能深度学习系列—深度学习中的边界框回归新贵：GHM（Generalized Histogram Loss）全解析
人工智能深度学习系列—深度学习损失函数中的Focal Loss解析
人工智能深度学习系列—Wasserstein Loss：度量概率分布差异的新视角
人工智能深度学习系列—GANs的对抗博弈：深入解析Adversarial Loss
人工智能深度学习系列—探索Jaccard相似度损失：图像分割领域的新利器
人工智能深度学习系列—深入探索IoU Loss及其变种：目标检测与分割的精度优化利器
人工智能深度学习系列—深度学习中的相似性追求：Triplet Loss 全解析
文章目录 1. 背景介绍2. Loss计算公式3. 使用场景使用场景扩展 4. 代码样例5. 总结 1. 背景介绍 在深度学习的世界里，损失函数犹如一把尺子，衡量着模型预测与实际结果之间的差距。均方误差损失（Mean Squared Error Loss，简称MSE Loss）作为回归问题中的常见损失函数，以其简单直观的特点，广泛应用于各种预测任务。本文将带您深入了解MSE Loss的背景、计算方法、使用场景以及如何在实际代码中应用它。
在机器学习中，损失函数是衡量模型性能的关键指标，它反映了模型预测值与真实值之间的差异。对于回归问题，我们的目标是最小化预测值与实际值之间的误差，而MSE Loss正是为此设计的。它通过计算预测值与真实值差的平方的平均值，为我们提供了一个量化误差的方法。
2. Loss计算公式 MSE Loss的计算公式如下：
MSE Loss = 1 n ∑ i = 1 n ( y i − y ^ i ) 2 \text{MSE Loss} = \frac{1}{n} \sum_{i=1}^{n}(y_i - \hat{y}_i)^2 MSE Loss=n1​∑i=1n​(yi​−y^​i​)2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23546629ddafcd64268bce58579634c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76d607e22194183a99f08235cca38d34/" rel="bookmark">
			C＋＋入门基础（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		6. 引用（引用就是取别名） 6.1 引用的概念和定义 引用不是新定义一个变量，而是给已存在变量取了⼀个别名，编译器不会为引用变量开辟内存空间，它和它引用的变量共用同一块内存空间。比如：水浒传中李逵，宋江叫"铁牛"，江湖上人称"黑旋风"；林冲，外号豹子头；
类型&amp; 引用别名 = 引用对象;
C++中为了避免引入太多的运算符，会复用C语言的⼀些符号，比如前面的&lt;&lt; 和 &gt;&gt;，这里引用也和取地址使用了同⼀个符号&amp;，大家注意使用方法角度区分就可以。
int a = 0;
// 引⽤：b和c是a的别名 int&amp; b = a;
int&amp; c = a;
// 也可以给别名b取别名，d相当于还是a的别名 int&amp; d = b;
这串代码在底层的角度是这样的 对指针变量取别名：
int* p1 = &amp;a; int*&amp; p2 = p1;
指针变量的使用： typedef struct ListNode
{
int val;
struct ListNode* next;
}LTNode, *PNode;
int main()
{
PNode plist = NULL;
ListPushBack(plist, 1);
return 0;
}
这里的*PNode是指把typedef struct ListNode* 定义为PNode。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76d607e22194183a99f08235cca38d34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c6149f59e0cc84d17bd2a087b069181/" rel="bookmark">
			探索智谱AI的视频生成神器：CogVideoX完全指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 在当今数字化和内容创作高度发达的时代，视频已经成为信息传播和营销的重要工具。然而，对于许多缺乏视频制作经验或资源的个人和企业而言，如何快速、高效地创建吸引人的视频仍然是一个挑战。智谱AI推出的CogVideoX，作为一款先进的视频生成大模型，为用户提供了一种全新的视频创作体验。本文将全面探讨CogVideoX的技术原理、操作方法及如何利用其生成专业级别的视频内容。
概述 CogVideoX是智谱AI开发的视频生成大模型，通过深度学习和计算机视觉技术，能够将简短的文本描述或静态图片转化为高质量、具有视觉吸引力的动态视频。用户只需输入描述或图片，即可快速生成符合预期的视频内容，无需复杂的视频制作技能和工具。
技术细节 CogVideoX利用先进的深度学习和计算机视觉技术，能够理解和转换文本描述为视觉内容。关键技术包括语义理解、图像生成和视频编码等，确保生成的视频具有高质量和视觉吸引力。
语义理解：CogVideoX通过深度学习模型准确理解输入的文本描述，包括主体描述、动作、场景等信息，以实现精准的视觉内容生成。
图像生成：在视频生成过程中，CogVideoX首先生成逼真的静态图像，然后通过动态变化和连贯性处理，将这些图像转换为高质量的视频内容。
视频编码：生成的图像序列经过先进的视频编码技术处理，以确保在各种设备和平台上的流畅播放和高清显示。
视觉效果增强：通过控制镜头语言、景别角度和光影效果等因素，CogVideoX能够为视频增添艺术感和情感表达，提升观看体验和影响力。
模型训练和优化：智谱AI团队持续优化CogVideoX模型，以提升其学习能力、处理速度和生成效果，以满足不同用户的个性化和专业化需求。
这些技术细节共同作用，使得CogVideoX成为视频生成领域的领先工具，支持用户高效、专业的视频内容创作和生成。
实现步骤 1. 创建视频生成任务 为了开始使用CogVideoX生成视频，您需要通过API创建一个视频生成任务。以下是创建任务的代码示例和步骤说明：
代码示例：
from zhipuai import ZhipuAI # 初始化智谱AI客户端 client = ZhipuAI(api_key="YOUR_API_KEY") # 替换为您的API Key # 创建视频生成任务 def create_video_task(prompt, image_url=None): try: response = client.videos.generations( model="cogvideox", prompt=prompt, image_url=image_url ) return response except Exception as e: print(f"Error creating video task: {str(e)}") # 示例提示词和图片URL prompt = "比得兔开小汽车，游走在马路上，脸上的表情充满开心喜悦。" image_url = "https://example.com/path/to/image.jpg" # 替换为您的图片URL，可选 # 调用创建视频生成任务函数 task_response = create_video_task(prompt, image_url) # 输出任务响应 print(task_response) 步骤说明：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c6149f59e0cc84d17bd2a087b069181/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cba762a16ac09a1f4b7024f3205a474/" rel="bookmark">
			重生之我 学习【数据结构之顺序表（SeqList）】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		⭐⭐⭐
新老博友们，感谢各位的阅读观看
期末考试&amp;假期调整暂时的停更了两个多月
没有写博客为大家分享优质内容
还容各位博友多多的理解
美丽的八月重生之我归来
继续为大家分享内容
你我共同加油
一起努力
⭐⭐⭐
数据结构将以顺序表、链表、栈区、队列、二叉树、常见排序算法为主要内容展开学习
这里的数据结构是C语言实现的
道阻且长，行则将至
🌹博主：宝哈 CSDN主页🌹
期待与你的交流学习
说在前面的话 数据结构是计算机存储、组织数据的方式，指的是相互之间存在的一种或多种特定关系的数据元素集合。数据本就是杂乱无章的，当我们对数据进行管理，形成一定的结构体系，数据才能有序存放便于我们存储和使用。数据结构将着力提升大家的算法能力，前期的C语言只是简单的为大家罗列了一些简答的知识点，现在我们将打开代码学习的魔幻大门，或许到这里我们才算得上代码学习刚入门。
前面我们已经学习了语言的基本内容:数组、指针、结构体、动态内存管等内容，这些都为今天我们学习数据结构做了铺垫，开启代码学习的新篇章——数据结构 ，在日常生活中我们要处理大量的数据，数据的统一管理，便于我们对数据增删查改，一些数据的内容过于庞大，高效便捷的管理需要我们对这些数据进行处理，那么如何处理好这些数据，就是我们接下来要学习的内容。
线性表 先来介绍线性表：
线性表在实际应用中非常广泛，比如数组、栈、队列等都可以看作是线性表的不同形式或在不同操作限制下的特殊结构，理解和掌握线性表对于深入学习数据结构至关重要。
物理结构：数据在内存中存储的一种形式
逻辑结构：人为想想出的一种数据结构形式，如线性关系、
线性表在逻辑结构上一定是线性的，在物理结构上不一定是线性的
今天介绍的顺序表是线性表的一种
顺序表（Sequence List）分类 顺序表：是⽤⼀段 物理地址连续的存储单元依次存储数据元素的线性结构，⼀般情况下采⽤数组 存储。 顺序表的底层逻辑是数组，在数组的基础上增加了增删查改的功能完成对数组的封装。
可以这样理解顺序表： 顺序表=数组+增加数据+删除数据+修改数据+查找数据
前期学习的数组，我们知道数组可分为静态数组和动态数组，静态的数组的大小往往限制我们都数据进行一系列的操作，动态数组更受大家的青睐。
/*静态数组*/ int shuzu[10]={ } /*动态数组 动态数组内存开辟*/ int* shuzu /*确定好大小后再去申请*/ 顺序表中对数组进行封装会使用结构体进行
静态顺序表 顺序表的空间已经确定，空间少了不够用空间多了浪费空间。
当空间过小会造成数据的丢失，空间远大于目前需求量需要资金的支持较大。
/*静态顺序表的定义*/ struct Seqlist { int arr[100]; //定长数组（在预估范围内操作） int size; //当前有效数据的个数 }; //静态顺序表 typedef int SLDataType //替换第四行的int #define N 10 typedef struct SeqList { SLDataType a[N]; //int被代替后 便于替换 int size; }SL; 动态顺序表 解决了静态数据表的痛点
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cba762a16ac09a1f4b7024f3205a474/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/104b1a38593a12ce863d8b056561dd4d/" rel="bookmark">
			【用Java学习数据结构系列】初识泛型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看到这句话的时候证明：此刻你我都在努力
加油陌生人
br /&gt;个人主页：Gu Gu Study
专栏：用Java学习数据结构系列
喜欢的一句话： 常常会回顾努力的自己，所以要为自己的努力留下足迹
喜欢的话可以点个赞谢谢了。
作者：小闭
前言 好久没有更新文章了，大概断更了20天，想着今天就写一下文章吧！最近也是又温习了一下数据结构，其实之前我写过关于数据结构的一个专栏那个专栏是写了顺序表，链表，栈和队列，但是那时是用C语言实现的，虽然数据结构不局限于语言，但是总归在语言的使用上有所不同，毕竟面向不同，一个是面向过程的C语言，一个是面向对象的Java。所以这次我打算起一个数据结构的Java专栏，当然由于之前已经写过有些地方会写得简洁一点，模糊的话大家可以去看一下前面得文章哦。今天是关于泛型的哦！只是简单的认识一下基础，为了更好的理解后面Java使用数据结构的代码。
认识包装类 Java中，包装类（Wrapper Classes）是用来包装原始数据类型的类。Java是一种面向对象的语言，所有的对象都是类的实例，包括基本数据类型。但是基本数据类型并不是对象，它们是Java语言的一部分，而不是Java类。为了将基本数据类型当作对象来处理，Java提供了对应的包装类。
以下是Java中的基本数据类型及其对应的包装类：
boolean - Booleanbyte - Byteshort - Shortint - Integerlong - Longfloat - Floadouble - Doublechar - Characte 很容易看出来除了int和char的包装类有些特殊其它基本数据的包装类就是大写其第一个字幕。
包装类的主要作用包括：
自动装箱和拆箱：Java 5 引入了自动装箱（Autoboxing）和拆箱（Unboxing）的概念，允许自动将基本数据类型转换为对应的包装类对象，反之亦然。使用对象的方法：包装类提供了一些有用的方法，比如toString()、equals()、hashCode()等，这些在基本数据类型中是不可用的。集合框架：Java的集合框架只能存储对象，不能直接存储基本数据类型。通过包装类，可以将基本数据类型作为对象存储在集合中。方法参数：在定义方法时，如果需要一个可变参数，可以使用包装类，因为基本数据类型是不可变的。 在数据结构中我们主要运用第三点集合框架，集合框架，后面的文章会给大家讲到。
自动装箱和拆箱的使用 以下就是自动装箱和拆箱的使用方法：
如果将num1和num2打印出来，都是一样的值----5。
public class Test { public static void main(String[] args) { Integer num1 = 5; // 自动装箱 int num2 = num1; // 自动拆箱 System.out.println(num1); System.out.println(num2); } } 包装类还提供了一些静态方法，比如Integer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/104b1a38593a12ce863d8b056561dd4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d587f796da79751585b80885f5da4e03/" rel="bookmark">
			【用Java学习数据结构系列】探索Java集合框架的无尽秘密pro
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看到这句话的时候证明：此刻你我都在努力
加油陌生人
个人主页：Gu Gu Study
专栏：用Java学习数据结构系列
喜欢的一句话： 常常会回顾努力的自己，所以要为自己的努力留下足迹
喜欢的话可以点个赞谢谢了。
作者：小闭
前言 与C语言学习数据结构不同，Java在数据结构的学习和使用上我们必须要了解一下Java的集合框架。
Java中的顺序表，链表，栈，队列，二叉树等，Java都是已经写好的了，其中队列是一个接口。
那么既然Java已经实现了这些数据结构，那么我们只需要认识和会使用这些接口和类就好，那么想认识这些数据结构之前，我们必须要先了解一下Java的集合框架。
什么是集合框架 集合框架是用于表示和操作集合的统一体系结构。所有集合框架都包含以下内容：
接口： 这些是表示集合的抽象数据类型。接口允许独立于其表示的细节来操作集合。在面向对象的语言中，接口通常形成一个层次结构。
实现： 这些是集合接口的具体实现。从本质上讲，它们是可重用的数据结构。
算法： 这些是对实现集合接口的对象执行有用计算（如搜索和排序）的方法。这些算法被称为多态算法：也就是说，相同的方法可以用于适当集合接口的许多不同实现。从本质上讲，算法是可重用的功能。
每个接口都要要实现的方法，当然上图中显示的都是集合框架中的接口。可能有人会问没见到要学习的顺序表和链表之类的东西啊。往下看：
ArrayList（顺序表）
LinkedList（链表）
Vector
Stack（栈）
CopyOnWriteArrayList
这五个类都是实现了这个框架中的List接口。也就是说List中的方法在这些个类中都会是实现。
其中
Java 集合框架的优点 Java 集合框架具有以下优点：
减少编程工作量： 通过提供有用的数据结构和算法，集合框架使您可以专注于程序的重要部分，而不是专注于使其运行所需的低级"管道"。通过促进不相关的
API 之间的互操作性，爪哇岛
集合框架使您无需编写适配器对象或转换代码来连接 API。
提高程序速度和质量： 此集合框架提供了有用数据结构和算法的高性能、高质量实现。每个接口的各种实现都是可以互换的，因此可以通过切换集合实现来轻松调整程序。因为您摆脱了编写自己的数据结构的苦差事，所以您将有更多时间投入到提高程序的质量和性能上。
允许在不相关的 API 之间实现互操作性： 集合接口是 API
来回传递集合的白话。如果我的网络管理 API
提供了节点名称的集合，并且您的 GUI
工具包需要列标题的集合，那么我们的 API
将无缝互操作，即使它们是独立编写的。
减少学习和使用新 API 的工作量： 许多 API
自然而然地在输入上获取集合，并将它们作为输出提供。过去，每个这样的
API 都有一个小的子 API，专门用于操作其集合。这些临时集合子 API
之间几乎没有一致性，因此您必须从头开始学习每个子
API，并且在使用它们时很容易出错。随着标准集合接口的出现，问题消失了。
减少设计新 API
的工作量： 这是前一个优势的另一面。设计人员和实现者不必在每次创建依赖于集合的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d587f796da79751585b80885f5da4e03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca870a930da2404dc61b621c53eb30b9/" rel="bookmark">
			类和对象（下）C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.初始化列表 1.为什么有初始化列表，它的作用？
-&gt;初始化列表，是构造函数初始化的另一种形式。
-&gt;在语法上面理解，初始化列表可以认定为是每个成员变量定义初始化的地方.
-&gt;引用成员变量，const成员变量，没有默认构造的类类型变量，他们三者必须要在自身定义时初始化。所以要将他们放在初始化列表的位置进行初始化，否则会编译报错。
2.使用形式
-&gt;以冒号作为开始标志，每个初始化以逗号作为分隔符号，每个“成员”变量后有个括号，用来放初始值或表达式。
3.C++11支持成员变量声明的位置给缺省值，主要是用于，该成员变量没有在初始化列表初始化使用的。
4.尽量使用初始化列表，因为尽管你不走初始化列表，也会走初始化列表。因为假设该成员在声明时给了缺省值，那么初始化列表会调用他的缺省值进行初始化，如果没有给缺省值，对于类置类型的成员是否初始化取决于编译器，而自定义类型，会去调用它的默认构造，如果没有相应的默认构造，又没有初始化列表。就会编译报错。
5.初始化列表的顺序，其实是按照成员变量声明的顺序来进行的。跟成员变量在初始列表出现的先后顺序无关。
例如以下例子：
2.类型转换 1.C++支持内置类型隐式类型转换为类类型对象，需要有相关类型作为构造函数的参数。
2.构造函数前面加explicit就不再支持隐式类型转换。
3.static成员 1.static修饰的成员变量，称为静态成员变量。！！！静态成员变量一定要在类外面进行初始化。
2.类静态成员变量属于所有的类对象，不属于某个具体的对象，不存在对象中，存在静态区。
3..类静态成员也是类的成员，受类域限制，也受访问限定符的限制（public protected，private）
4.static修饰成员函数，成为静态成员函数，静态成员函数没有this指针。
5.静态成员函数可以访问静态成员，不能访问非静态的，因为没有this指针。
6.非静态的成员函数可以任意的访问静态成员函数和静态成员。
7.突破类域可以访问静态成员 ，可以通过类名::静态成员或对象.静态成员来访问静态成员和静态成员函数
8.静态成员不能在声明时给缺省值，因为缺省值是给构造函数初始化列表使用的，而静态成员不属于某一对象，所以不走初始化列表，所以也就不能给缺省值。
例题：
设已经有A,B,C,D 4个类的定义，程序中A,B,C,D构造函数调⽤顺序为？（） 设已经有A,B,C,D 4个类的定义，程序中A,B,C,D析构函数调⽤顺序为？（） 答案选择：E，B
4.友元 5.内部类 1.什么是内部类？
-&gt;一个类的定义是在另一个类的内部，！！！内部类是一个独立的类，与定义在全局的相比，他只受到类域和访问限定符的限制，所以外部类定义的对象不包括内部类。
2.内部类默认是外部类的友元类。
3.内部类本质也是⼀种封装，当A类跟B类紧密关联，A类实现出来主要就是给B类使⽤，那么可以考虑把A类设计为B的内部类，如果放到private/protected位置，那么A类就是B类的专属内部类，其 他地⽅都⽤不了。 6.匿名对象 1.用类型定义出来的是对象叫做匿名对象，而类型名+对象名定义出来的是有名对象。
2.匿名对象的生命周期只在当前那一行，一般临时定义一个对象当前用一下就可以定义临时对象。
7.对象拷贝时的编译器优化 1.现代编译器会为了尽可能提⾼程序的效率，在不影响正确性的情况下会尽可能减少⼀些传参和传参过程中可以省略的拷⻉。 2.如何优化C++标准并没有严格规定，各个编译器会根据情况⾃⾏处理。当前主流的相对新⼀点的编译器对于连续⼀个表达式步骤中的连续拷⻉会进⾏合并优化，有些更新更"激进"的编译还会进⾏跨⾏跨表达式的合并优化。
今日份鸡汤：“如果没有天赋，那就一直重复！”
今天的学习就到此结束啦！谢谢大家支持！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d1eb3e71a8ed19f40400dbf0db730ac/" rel="bookmark">
			c语言11天笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数的概述
函数：实现一定功能的，独立的代码模块。我们的函数一定是先定义，后使用。
使用函数的优势：
1. 我们可以通过函数提供功能给别人使用。当然我们也可以使用别人提供的函数，减少代码量。
2. 借助函数可以减少重复性的代码。
3. 实现结构化（模块化）
程序设计思想: 结构化程序设计思想：将大型的任务功能划分为相互独立的小型的任务模块来设计。
函数是C语言程序的基本组成单元：
C语言程序是由一个（必然是main函数）或多个函数组成。
函数的分类
从函数实现的角度：
库函数：C语言标准库实现并提供使用的函数，比如常见的有printf()，scanf()
用户自定义函数：需要程序员自行实现，开发中大部分都是这样的函数
从函数形式的角度：
无参函数：函数调用时，无需传参，可配可不配返回值。
有参函数：函数调用时，需要参数传递数据，经常需要配套返回值使用。
相关概念
主调函数：主动去调用其他函数的函数。
被调函数：被调用的函数
很多时候，一个函数既可以是主调函数，也可以是被调函数。这种情况一般出自自定义函 数。
函数的定义
语法
函数首部：
返回类型：函数返回值的类型
函数名：函数的名称，遵循标识符命名（使用英文字母、数字、_、$，不能以数字开头，建议小写 +下划线命名法）
形参列表：用于接收主调函数传递的数据，如果有多个用" , "分隔，且每一个形参都需要指定类 型。
面试题：
注意：
函数类型标识符变量类型说明符相同，它表示返回的函数值的类型。
在C语言中还可以定义无类型（即void类型）的函数，这种函数不返回函数值，只是完成某种功 能。
如果省略函数的类型标识符，则默认为是int型。
函数中返回语句的形式为 return(表达式)；或 return 表达式；其作用是将表达式的值作为函数值返 回给调用函数。其中表达式的类型应与函数类型一致。
如果"形参表列"中有多个形式参数，则它们之间要用" , "分隔。
如果形参表中有多个形参，即使它们的类型是相同的，在形参表中也只能逐个进行说明。 fun1(in t a,int b){}
一个完整C程序中的所有函数可以放在一个文件中，也可以放在 多个文件中。
案例
案例1：
案例2：
形参和实参
概念
形参（形式参数）：
函数定义时指定的参数，形参是用来接收数据的，函数定义时，系统不会为形参申请内存，只有当函 数调用时，系统才会为形参申请内存，用于存储实际参数，并且当函数返回，系统会自动回收为形参 申请的内存资源。(本质上所有函数都有return，只不过当我们的函数返回类型是void的时候，return 关键字被省略了)
实参（实际参数）：
函数调用时主调函数传递的数据参数（常量、变量、表达式..，只要有确定的值），实参是传递的 数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d1eb3e71a8ed19f40400dbf0db730ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a79695c0ee5830156ced38f0b98ac0b4/" rel="bookmark">
			Unity入门1——基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VIew工具 选中View工具后，按住鼠标左键，即可实现拖拽
按住Alt+鼠标右键，移动鼠标即可实现缩放（或使用鼠标滚轮）
Move工具 选中移动工具，即可对界面中的物品进行移动。快捷键W
快速定位物体 在层级管理器中选中物体
光标移动到场景上方，同时按住F键 rotate和scale工具 旋转和缩放
构建发布 选择Publish-&gt;WebGL-&gt;Get started
选择Build and Publish
Switch to WebGL
选择一个文件夹存放构建的项目
构建完毕后选择发布
（需要科学上网）
发布后在弹出的页面上传压缩后的build文件夹，点击保存，即可游玩
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3dcd4b5003dd0c52fe7e7c03f722ac3/" rel="bookmark">
			白骑士的PyCharm教学实战项目篇 4.2 数据分析与可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列目录 上一篇：白骑士的PyCharm教学实战项目篇 4.1 Web应用开发
数据分析和可视化是现代数据科学和工程中的重要环节。借助PyCharm的强大功能，数据分析与可视化的开发工作变得更加高效和便捷。本文将详细介绍如何在PyCharm中进行数据分析工具的集成与使用，以及如何进行数据可视化和报告生成。
数据分析工具集成与使用 PyCharm为数据科学和数据分析提供了全面的支持。通过集成常用的数据分析工具和库，开发者可以在PyCharm中高效地进行数据处理和分析。
安装和配置数据分析工具 创建项目并配置虚拟环境 打开PyCharm，选择 “File” -&gt; “New Project”，创建一个新的Python项目。在创建项目时，选择使用虚拟环境，以便隔离项目依赖。 安装常用的数据分析库 在PyCharm的终端或通过 “File” -&gt; “Settings” -&gt; “Project: &lt;project_name&gt;” -&gt; “Python Interpreter” 添加所需的库。常用的数据分析库包括NumPy、Pandas、SciPy等。安装库的命令如下： pip install numpy pandas scipy 数据分析流程 导入数据 使用Pandas库导入数据，支持多种数据格式，如CSV、Excel、SQL等。例如，从CSV文件导入数据： import pandas as pd data = pd.read_csv('data.csv') 数据清洗与预处理 对导入的数据进行清洗和预处理，包括处理缺失值、重复数据、数据转换等。例如，删除缺失值： data.dropna(inplace=True) 数据分析与统计
使用NumPy和Pandas进行数据分析和统计计算。例如，计算数据的描述统计信息： stats = data.describe() print(stats) 数据可视化与报告生成 数据可视化是数据分析的重要环节，能够帮助我们直观地理解数据和发现数据中的模式和趋势。PyCharm支持多种数据可视化工具和库，如Matplotlib、Seaborn、Plotly等。
安装和配置可视化工具 安装常用的数据可视化库： 在PyCharm的终端或通过“File” -&gt; “Settings” -&gt; “Project: &lt;project_name&gt;” -&gt; “Python Interpreter”添加所需的库。常用的数据可视化库包括Matplotlib、Seaborn、Plotly等。安装库的命令如下： pip install matplotlib seaborn plotly 数据可视化流程 导入可视化库 在Python脚本中导入所需的可视化库。例如： import matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3dcd4b5003dd0c52fe7e7c03f722ac3/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/73/">«</a>
	<span class="pagination__item pagination__item--current">74/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/75/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>