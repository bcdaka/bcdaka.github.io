<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/394510ba1f0c605c0274f367c1754149/" rel="bookmark">
			springboot集成starrocks、以及采用flink实现mysql与starrocks亚秒级同步_spring&#43;starrocks(1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sb.append("'").append(devMc.getMcSta()).append("',"); sb.append("'").append(devMc.getMcEnd()).append("',"); sb.append(devMc.getAudtCid()).append(","); sb.append(devMc.getAudtTagChk()).append(","); sb.append(devMc.getAudtTagOk()).append(","); sb.append("'").append(devMc.getAudtDtm()).append("',"); sb.append(devMc.getAudtUid()).append(","); sb.append("'").append(devMc.getAudtMan()).append("',"); sb.append("'").append(devMc.getAudtInf()).append("',"); sb.append(devMc.getSubmit()).append(","); sb.append(devMc.getVersion()).append(","); sb.append(devMc.getCId()).append(","); sb.append(devMc.getToUpd()); sb.append(")"); if (count == 5000) { sb.append(";"); StringBuilder insert = new StringBuilder(NAME); insert.append(sb.toString()); mapper.insertBatch(insert.toString()); count = 0; sb.setLength(0); } else { sb.append(","); } } if (sb.length() &gt; 0) { StringBuilder insert = new StringBuilder(NAME); insert.append(sb.toString().substring(0, sb.length()-1)); insert.append(";"); mapper.insertBatch(insert.toString()); count = 0; sb.setLength(0); } } @Test public void test2() { DevMc devMc = devMcService.getById(1558); System.err.println("查询完毕"); DynamicDataSourceContextHolder.push("slave"); // 手动切换 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/394510ba1f0c605c0274f367c1754149/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3018496d047507aecc182d2e65b069a8/" rel="bookmark">
			word文档显示异常，mac安装word字体：仿宋gb2312、方正小标宋简体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为mac没有仿宋gb2312字体，windows上word里显示的仿宋gb2312字体与排版，在mac上显示为黑体、排版也错乱了，得不到想要打印格式。
需要安装仿宋gb2312字体（同理 方正小标宋简体）
下载：仿宋GB2312.zip，或者在这下载仿宋GB2312，方正小标宋简体
解压后双击安装得到：仿宋GB2312.ttf
放入word：
拷贝仿宋GB2312.ttf；
打开访达——应用程序——找到word，右键“显示包内容”——Contents——Resources——DFonts；
粘贴仿宋GB2312.ttf到DFonts 文件夹内。
重启word或mac
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bbe7250a690579b61c652e88b22fa66/" rel="bookmark">
			【数据结构与算法】：10道链表经典OJ
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 移除链表元素2. 反转链表2.1反转指针法2.2 头插法 3. 合并两个有序链表4. 分隔链表5. 环形链表6. 链表的中间节点7. 链表中倒数第K个节点8. 相交链表9. 环形链表的约瑟夫问题10. 链表的回文结构 1. 移除链表元素 思路1：遍历原链表，将 val 所在的节点释放掉。(太麻烦)
思路2：创建新链表，再遍历原链表，找到不为 val 的节点尾插到新链表。
思路1代码实现如下：
注意：
1.当链表为空时，直接返回NULL即可。
2.当尾插上最后一个有效节点时，此时它的 next 可能还与最后一个节点相链接，一定要断开！
typedef struct ListNode ListNode; struct ListNode* removeElements(struct ListNode* head, int val) { if (head == NULL) return NULL; //创建一个新链表 ListNode* newHead, * newTail; newHead = newTail = NULL; ListNode* pcur = head; //遍历原链表，找不为val的节点尾插 while (pcur) { ListNode* next = pcur-&gt;next; if (pcur-&gt;val !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bbe7250a690579b61c652e88b22fa66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f5c1605cc1de0a49b49c2d659e82954/" rel="bookmark">
			c语言-＞贪吃蛇实战技巧结合EasyX简单实现页面管理（简单实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：大家好，我是橘橙黄又青，一个想要与大家共同进步的男人😉😉
🍎个人主页：再无B～U～G-CSDN博客
1. 游戏背景 贪吃蛇是久负盛名的游戏，它也和俄罗斯⽅块，扫雷等游戏位列经典游戏的⾏列。 在编程语⾔的教学中，我们以贪吃蛇为例，从设计到代码实现来提升学⽣的编程能⼒和逻辑能⼒。 2. 游戏效果演⽰ 屏幕录制
3. 课程⽬标 使⽤C语⾔在Windows环境的控制台中模拟实现经典⼩游戏贪吃蛇 实现基本的功能： • 贪吃蛇地图绘制 • 蛇吃⻝物的功能 （上、下、左、右⽅向键控制蛇的动作） • 蛇撞墙死亡 • 蛇撞⾃⾝死亡 • 计算得分 • 蛇⾝加速、减速 • 暂停游戏 4. 课程定位 • 提⾼⼩⽐特对编程的兴趣 • 对C语⾔语法做⼀个基本的巩固。 • 对游戏开发有兴趣的同学做⼀个启发。 • 项⽬适合：C语⾔学完的同学，有⼀定的代码能⼒，初步接触数据结构中的链表。 5. 技术要点 C语⾔函数、枚举、结构体、动态 内存管理、预处理指令、链表、Win32 API等。 整体的框架： 课前准备：
调好项目适应本地化
了解EasyX的坐标体系
6. 控制台程序 6.1 控制台程序 设置如下：
6.1 相关函数的使用 地区设置为"C"时，库函数按正常⽅式执⾏，⼩数点是⼀个点。 当程序运⾏起来后想改变地区，就只能显⽰调⽤setlocale函数。⽤" "作为第2个参数，调⽤setlocale 函数就可以切换到本地模式，这种模式下程序会适应本地环境。⽐如：切换到我们的本地模式后就⽀持宽字符（汉字）的输出等 &lt;locale.h&gt;本地化
全部来自于EasyX简单图形库
6.2pause 6.3 outtextxy 两个一个输出字符，一个输出字符串
案例：
6.4cleardevice 6.5图片设置 相关用法：
6.6rectangle 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f5c1605cc1de0a49b49c2d659e82954/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9964bab08234ae827fe4bec43f51002e/" rel="bookmark">
			【JAVASE】带你了解String类的常用方法和常见操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：大家好，我是橘橙黄又青，一个想要与大家共同进步的男人😉😉 🍎个人主页： 再无B～U～G-CSDN博客 目标： 1. 认识 String 类 2. 了解 String 类的基本用法 3. 熟练掌握 String 类的常见操作 4. 认识字符串常量池 5. 认识 StringBuffer 和 StringBuilder 1. 🍎String类的重要性 在 C 语言中已经涉及到字符串了，但是在 C 语言中要表示字符串只能使用字符数组或者字符指针，可以使用标准库提供的字符串系列函数完成大部分操作，但是这种将数据和操作数据方法分离开的方式不符合面相对象的思想，而字符串应用又非常广泛，因此Java语言专门提供了 String 类。 在开发和校招笔试中，字符串也是常客，比如 ：
字符串转整形数字 字符串相加 而且在面试中也频繁被问到，比如： String 、 StringBuff 和 StringBulider 之间的区别等。 2. 🍎常用方法 2.1 🍎字符串构造 常用的三种：
其他方法需要用到时，大家参考Java在线文档：String官方文档 【 注意 】 1. String 是引用类型，内部并不存储字符串本身 ，在 String 类的实现源码中， String 类实例变量如下： 案例： public static void main(String[] args) { // s1和s2引用的是不同对象 s1和s3引用的是同一对象 String s1 = new String("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9964bab08234ae827fe4bec43f51002e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df21cebfecc47755286bb79da9d0fc15/" rel="bookmark">
			一篇文章搞懂数据仓库：数据治理（目的、方法、流程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是数据治理
2、数据治理的目的
3、数据治理的方法
4、数据质量8个衡量标准
5、数据治理流程
1、什么是数据治理
数据治理（Data Governance）是组织中涉及数据使用的一整套管理行为。由企业数据治理部门发起并推行，关于如何制定和实施针对整个企业内部数据的商业应用和技术管理的一系列政策和流程。
数据的质量直接影响着数据的价值，并且直接影响着数据分析的结果以及我们以此做出的决策的质量。我们常说，用数据说话，用数据支撑决策管理，但低质量的数据、甚至存在错误的数据，必然会"说假话"！！！ 数据治理即提高数据的质量，发挥数据资产价值。
2、数据治理的目的
降低风险
建立数据使用内部规则
实施合规要求
改善内部和外部沟通
增加数据价值
方便数据管理
降低成本
通过风险管理和优化来帮助确保公司的持续生存
3、数据治理的方法
从技术实施角度看，数据治理包含**“理”“采”“存”“管”“用”**这五个步骤，即业务和数据资源梳理、数据采集清洗、数据库设计和存储、数据管理、数据使用。
数据资源梳理：数据治理的第一个步骤是从业务的视角厘清组织的数据资源环境和数据资源清单，包含组织机构、业务事项、信息系统，以及以数据库、网页、文件和 API 接口形式存在的数据项资源，本步骤的输出物为分门别类的数据资源清单。
数据采集清洗：通过可视化的 ETL 工具（例如阿里的 DataX，Pentaho Data Integration）将数据从来源端经过抽取 (extract)、转换 (transform)、加载 (load) 至目的端的过程，目的是将散落和零乱的数据集中存储起来。
基础库主题库建设：一般情况下，可以将数据分为基础数据、业务主题数据和分析数据。基础数据一般指的是核心实体数据，或称主数据，例如智慧城市中的人口、法人、地理信息、信用、电子证照等数据。主题数据一般指的是某个业务主题数据，例如市场监督管理局的食品监管、质量监督检查、企业综合监管等数据。而分析数据指的是基于业务主题数据综合分析而得的分析结果数据，例如市场监督管理局的企业综合评价、产业区域分布、高危企业分布等。那么基础库和主题库的建设就是在对业务理解的基础上，基于易存储、易管理、易使用的原则抽像数据存储结构，说白了，就是基于一定的原则设计数据库表结构，然后再根据数据资源清单设计数据采集清洗流程，将整洁干净的数据存储到数据库或数据仓库中。
元数据管理：元数据管理是对基础库和主题库中的数据项属性的管理，同时，将数据项的业务含义与数据项进行了关联，便于业务人员也能够理解数据库中的数据字段含义，并且，元数据是后面提到的自动化数据共享、数据交换和商业智能（BI）的基础。需要注意的是，元数据管理一般是对基础库和主题库中（即核心数据资产）的数据项属性的管理，而数据资源清单是对各类数据来源的数据项的管理。
血缘追踪：数据被业务场景使用时，发现数据错误，数据治理团队需要快速定位数据来源，修复数据错误。那么数据治理团队需要知道业务团队的数据来自于哪个核心库，核心库的数据又来自于哪个数据源头。我们的实践是在元数据和数据资源清单之间建立关联关系，且业务团队使用的数据项由元数据组合配置而来，这样，就建立了数据使用场景与数据源头之间的血缘关系。 数据资源目录：数据资源目录一般应用于数据共享的场景，例如政府部门之间的数据共享，数据资源目录是基于业务场景和行业规范而创建，同时依托于元数据和基础库主题而实现自动化的数据申请和使用。
质量管理：数据价值的成功发掘必须依托于高质量的数据，唯有准确、完整、一致的数据才有使用价值。因此，需要从多维度来分析数据的质量，例如：偏移量、非空检查、值域检查、规范性检查、重复性检查、关联关系检查、离群值检查、波动检查等等。需要注意的是，优秀的数据质量模型的设计必须依赖于对业务的深刻理解，在技术上也推荐使用大数据相关技术来保障检测性能和降低对业务系统的性能影响，例如 Hadoop，MapReduce，HBase 等。
商业智能（BI）：数据治理的目的是使用，对于一个大型的数据仓库来说，数据使用的场景和需求是多变的，那么可以使用 BI 类的产品快速获取需要的数据，并分析形成报表，比较知名的产品有 Microsoft Power BI，QlikView，Tableau，帆软等。
数据共享交换：数据共享包括组织内部和组织之间的数据共享，共享方式也分为库表、文件和 API 接口三种共享方式，库表共享比较直接粗暴，文件共享方式通过 ETL 工具做一个反向的数据交换也就可以实现。我们比较推荐的是 API 接口共享方式，在这种方式下，能够让中心数据仓库保留数据所有权，把数据使用权通过 API 接口的形式进行了转移。API 接口共享可以使用 API 网关实现，常见的功能是自动化的接口生成、申请审核、限流、限并发、多用户隔离、调用统计、调用审计、黑白名单、调用监控、质量监控等等。
4、数据质量8个衡量标准
数据的准确性 数据采集值或者观测值和真实值之间的接近程度，也叫做误差值，误差越大，准确度越低。
数据的精确性 指对同一对象的观测数据在重复测量时所得到不同数据间的接近程度。
自我介绍一下，小编13年上海交大毕业，曾经在小公司待过，也去过华为、OPPO等大厂，18年进入阿里一直到现在。
深知大多数Python工程师，想要提升技能，往往是自己摸索成长或者是报班学习，但对于培训机构动则几千的学费，着实压力不小。自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《2024年Python开发全套学习资料》，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友，同时减轻大家的负担。
既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，基本涵盖了95%以上前端开发知识点，真正体系化！
由于文件比较大，这里只是将部分目录大纲截图出来，每个节点里面都包含大厂面经、学习笔记、源码讲义、实战项目、讲解视频，并且后续会持续更新
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df21cebfecc47755286bb79da9d0fc15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c24571dfdc25dec7beab7c1f21c345e1/" rel="bookmark">
			一篇文章搞懂数据仓库：三种事实表（设计原则，设计方法、对比）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事实表作为数据仓库维度建模的核心，紧紧围绕着业务过程来设 计，通过获取描述业务过程的度量来表达业务过程，包含了引用的维度 和与业务过程有关的度量。
1、三种事实表概述
=============
事实表有三种类型 : 事务事实表、周期快照事实表和累积快照事实表。
1.1 事务事实表 也称原子事实表，描述业务过程，跟踪控件或时间上某点的度量事件，保存的是最原子的数据；
个人理解：类似于mysql binlog日志，每一次相关的 change 都记录下来，生成一行新的数据
1.2 周期快照事实表 以一个周期为时间间隔，来记录事实，一般周期可以是每天、每周、每月、每年等；
个人理解：只看某个业务过程，比如订单收货，数据按订单收货时间来切分，周期可以为每天、每月等。
1.3 累积快照事实 用来描述过程开始和结束之间的关键步骤事件，覆盖过程的整个生命周期，通常具有多个日期字段来记录关键时间点；当过程随着生命周期不断变化时，记录也会随着过程的变化而被修改；
个人理解：要看整个生命周期的多个业务过程，比如：创建订单 → 买家付款 → 卖家发货 → 买家确认收货。粒度是一个订单一行数据，创建订单时间，付款时间，发货时间，收货时间，分别作为一个字段，便于计算不同业务过程的时间间隔。
2、三种事实表对比
=========
事务事实表 周期快照事实表 累积快照事实表 时期/时间 离散事务时间点 以有规律的、可预测的 用于时间跨度不确定的不断变化的工作流 日期维度 事务日期 快照日期 相关业务过程涉及的多个日期 粒度每行代表实体的一个事务 每行代表某时间周期的一个实体 每行代表一个实体的生命周期 事实 事务事实累积事实相关业务过程事实和时间间隔事实 事实表加载 插入 插入 插入与更新 事实表更新 不更新 不更新 业务过程变更时更新 3、事实表设计 8 大原则
=============
原则 1：尽可能包含所有与业务过程相关的事实
分析哪些事实与业务过程相关，是设计过程中非常重要的关注点；
在事实表中，尽量包含所有与业务过程相关的事实，即使存在冗余，由于事实通常是数字型，存储开销不会太大；
原则 2：只选择与业务过程相关的事实
如，订单的下单这个业务过程，事实表中不应该存在支付金额这个表示支付业务过程的事实；
原则 3：分解不可加性事实为可加的组件
如，订单的优惠率，应分解为订单原价金额与订单优惠金额两个事实存储在事实表中；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c24571dfdc25dec7beab7c1f21c345e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be54b146b460356450922943134f25cc/" rel="bookmark">
			Kafka 实战 - SpringBoot 中使用@KafkaListener详解与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Spring Boot项目中使用@KafkaListener注解，可以方便地监听和处理从Kafka主题中流入的消息。以下是一个详细的实战指南：
引入依赖 首先，确保在Spring Boot项目中引入了Spring Kafka的相关依赖。在pom.xml中添加以下内容：
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt; &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt; &lt;!-- 替换为你使用的Spring Kafka版本 --&gt; &lt;version&gt;2.8.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 如果需要自动配置Kafka工厂bean，可以添加以下依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt; &lt;artifactId&gt;spring-kafka-test&lt;/artifactId&gt; &lt;!-- 同上，确保版本一致 --&gt; &lt;version&gt;2.8.0&lt;/version&gt; &lt;!-- 测试环境中才需要这个依赖 --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 配置Kafka连接 在application.yml或application.properties中配置Kafka连接信息：
spring: kafka: bootstrap-servers: localhost:9092 # Kafka集群地址 consumer: group-id: my-consumer-group # 消费者组ID auto-offset-reset: earliest # 默认偏移量位置（earliest/latest） enable-auto-commit: false # 是否自动提交offset，一般建议关闭以便手动控制 key-deserializer: org.apache.kafka.common.serialization.StringDeserializer # 键序列化器 value-deserializer: org.apache.kafka.common.serialization.StringDeserializer # 值序列化器 创建消费者类 创建一个Java类，使用@KafkaListener注解标注监听方法，该方法将在监听到相应主题的消息时被调用。
import org.springframework.kafka.annotation.KafkaListener; import org.springframework.stereotype.Component; @Component public class MyKafkaConsumer { @KafkaListener(topics = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be54b146b460356450922943134f25cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a1d36d4e5119f5f5f98065d08931b8e/" rel="bookmark">
			Android模拟蓝牙蓝牙键盘——适配Android和Windows
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学校寒假有个程序设计比赛，我也一直想要去写一个安卓模拟的蓝牙键盘，这样无论到哪里，比如班班通和没有键盘的电脑设备，有手机就可以操作它，也比USB方便一些。忙活了一个寒假，也走了不少歪路，终于整成了，下面分享一些经验。
（学校的软件设计比赛已经交了终稿了，我的仓库开源在Gitee和GitHub，求求star：
Gitee：https://gitee.com/FengyunTHU/keyboard
GitHub：https://github.com/FengyunTHU/keyboardOFbluetooth）
自己在写代码的过程中也参考了很多CSDN博客，列举如下：
蓝牙HID——将android设备变成蓝牙键盘（BluetoothHidDevice）
仅通过蓝牙HID将安卓手机模拟成鼠标和键盘
使用旧手检做成蓝牙键盘
CSDN上大佬真的很多！
代码思路 ①第一步是蓝牙HID的初始化 在安卓API28后开放了BluetoothHidDevice类，主要就是用它来完成。首先是注册HID服务：
mBtAdapter.getProfileProxy(context, new BluetoothProfile.ServiceListener() { @Override public void onServiceConnected(int profile, BluetoothProfile proxy) { Log.d(TAG, "onServiceConnected: " + profile); Toast.makeText(context, "Okk_connected_service", Toast.LENGTH_SHORT).show(); if (profile == BluetoothProfile.HID_DEVICE) { Log.d(TAG, "Proxy received but it isn't hid_OUT"); if (!(proxy instanceof BluetoothHidDevice)) { Log.e(TAG, "Proxy received but it isn't hid"); return; } Log.d(TAG,"Connecting HID…"); mHidDevice = (BluetoothHidDevice) proxy; Log.d(TAG, "proxyOK"); BluetoothHidDeviceAppSdpSettings Sdpsettings = new BluetoothHidDeviceAppSdpSettings( HidConfig.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a1d36d4e5119f5f5f98065d08931b8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90865ce691ac62add18caf9b4b58c6de/" rel="bookmark">
			【BlueDroid】蓝牙音乐协议分析之A2DP和AVRCP连接流程（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 精讲蓝牙协议栈（Bluetooth Stack）：SPP/A2DP/AVRCP/HFP/PBAP/IAP2/HID/MAP/OPP/PAN/GATTC/GATTS/HOGP等协议理论
2. 欢迎大家关注和订阅，【蓝牙协议栈】和【Android Bluetooth Stack】专栏会持续更新中.....敬请期待！
1. 协议架构 上面描述的就是整体的协议架构，我们针对蓝牙音乐的协议架构分析，其中涉及到了几个协议：
其中针对业务层的逻辑，涉及到了A2DP和AVRCP协议；
1.1 AVRCP介绍 AVRCP全称：Audio/Video Remote Control Profile，即音频/视频远程控制配置文件。
AVRCP设计用于提供控制TV，Hi-Fi设备等的标准接口，此配置文件用于许可单个远程控制设备（或其他设备）控制所有用于可以接入的A/V设备。AVRCP定义了如何控制流媒体的特征。包括暂停、停止、启动重放、音量控制及其他类型的远程控制操作（其实和DLNA的指令控制类似）；
AVRCP是一种在蓝牙协议栈A2DP/AVRCP上实现的控制技术；
1.2 A2DP介绍 A2DP全称：Advenced Audio Distribution Profile，即蓝牙音频传输模型协定；
A2DP规定了使用蓝牙异步传输信道方式，传输高质量音乐文件数据的协议堆栈软件和使用方法，基于该协议就能通过以蓝牙方式传输高品质的音乐。例如使用蓝牙耳机或蓝牙音响设备来收听音乐了；
针对上述的相关的协议，其实和蓝牙命令请求和响应有密切的关联；
2. Command &amp; Event 2.1 Command 我们整理一下蓝牙音乐过程中涉及到的常见的一些Command；
ProtocolJNICommandDescA2dpSinkBluetoothA2dpSinkServiceJniclassInitNative初始化A2dpSink NativeA2dpSinkBluetoothA2dpSinkServiceJniconnectA2dpNative用于连接A2dpSdpBluetoothSdpJnisdpCreateOppOpsRecordNative创建服务记录列表SdpBluetoothSdpJnisdpSearchNative搜索服务AvrcpBluetoothAvrcpControllerJnigetPlayerListNative获取播放列表AvrcpBluetoothAvrcpControllerJnisendPassThroughCommandNative68：播放 70：暂停 75：下一首 76：上一首 2.2 Event Event代表的就是上层业务层向下发送指令到底层返回的callback响应；
ProtocolJNIEventDescA2dpSinkBluetoothA2dpSinkServiceJnibta2dp_connection_state_callback响应A2dp服务连接SdpBluetoothSdpJnisdp_search_callback响应sdp服务搜索结果A2dpSinkBluetoothA2dpSinkServiceJnibta2dp_audio_config_callbackA2dp audio配置变化回调AvrcpBluetoothAvrcpControllerJnibtavrcp_connection_state_callbackAvrcp服务连接状态回调AvrcpBluetoothAvrcpControllerJnibtavrcp_get_rcfeatures_callbackAvrcpBluetoothAvrcpControllerJnibtavrcp_play_status_changed_callback当前播放状态变化信息回调AvrcpBluetoothAvrcpControllerJnibtavrcp_track_changed_callbackTrackInfo信息变化回调AvrcpBluetoothAvrcpControllerJnibtavrcp_set_addressed_player_callback设置address地址信息结果回调AvrcpBluetoothAvrcpControllerJnibtavrcp_uids_changed_callbackuid变化回调AvrcpBluetoothAvrcpControllerJnibtavrcp_get_folder_items_callback获取文件夹目录信息回调AvrcpBluetoothAvrcpControllerJnibtavrcp_playerapplicationsetting_callback播放器设置结果回调AvrcpBluetoothAvrcpControllerJnibtavrcp_playerapplicationsetting_changed_callback更换播放器结果回调AvrcpBluetoothAvrcpControllerJnibtavrcp_available_player_changed_callback播放可行性变化回调AvrcpBluetoothAvrcpControllerJnibtavrcp_addressed_player_update_callbackaddress信息变化回调AvrcpBluetoothAvrcpControllerJnibtavrcp_play_position_changed_callback播放进度条信息回调AvrcpBluetoothAvrcpControllerJnibtavrcp_passthrough_response_callback指令响应结果回调A2dpSinkBluetoothA2dpSinkServiceJnibta2dp_audio_state_callbackA2dp audio状态变化结果回调 3. 协议分析 我们按照蓝牙音乐的播放流程逐一分析涉及到的协议；
3.1 A2dpSink 连接 这个过程中涉及到的Command和Event为：
Command
connectA2dpNative Event
bta2dp_connection_state_callbackbta2dp_audio_config_callback 3.1 connectA2dpNative 3.1.1 Operation 01-01 00:07:30.619 1713 2134 I BluetoothA2dpSinkServiceJni: connectA2dpNative: sBluetoothA2dpInterface: 0x77307fd3e8 01-01 00:07:30.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90865ce691ac62add18caf9b4b58c6de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f88afa182577c4872b6ea26653411194/" rel="bookmark">
			python 爬取携程全国旅游景点信息-2024.4.13
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 概述 携程网是中国领先的在线旅行服务公司，提供酒店预订、机票预订、旅游度假、商旅管理等服务。携程网上有大量的旅游景点和酒店信息，这些信息对于旅行者和旅游业者都有很大的价值。通过爬虫技术，我们可以从携程网上获取这些信息，并进行数据清洗、数据分析、数据可视化等操作，从而得到有用的洞察和建议。
2. 安装requests 库 在开始之前，请确保你已经安装了以下 Python 库：
requests：用于发送 HTTP 请求并获取网页内容。
你可以使用 pip 来安装这些库：
pip install requests 3. 爬取携程旅游网站数据 首先，我们需要确定要爬取的页面。 假设我们想要获取携程旅游网站上某个目的地的旅游信息。如下例如北京。
当前接口 链接 和 post 参数 url = 'https://m.ctrip.com/restapi/soa2/18109/json/getAttractionList?_fxpcqlniredt=09031015313388236487&amp;x-traceID=09031015313388236487-1712974794650-8267936' data = {"index":1,"count":10,"sortType":1,"isShowAggregation":true,"districtId":1,"scene":"DISTRICT","pageId":"214062","traceId":"14f9745c-92ad-f5c5-07bb-171293c80647","extension":[{"name":"osVersion","value":"10"},{"name":"deviceType","value":"windows"}],"filter":{"filterItems":[]},"crnVersion":"2020-09-01 22:00:45","isInitialState":true,"head":{"cid":"09031015313388236487","ctok":"","cver":"1.0","lang":"01","sid":"8888","syscode":"09","auth":"","xsid":"","extension":[]}} 4. 开始正式代码 headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36 Edg/123.0.0.0', 'Cookie': 你的cookies } html = requests.post(url, headers=headers, json=data).json() attractionList = html['attractionList'] for attraction in attractionList: data = attraction['card'] commentCount = data['commentCount'] commentScore = data['commentScore'] coordinate = [data['coordinate']['latitude'], data['coordinate']['longitude']] coverImageUrl = data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f88afa182577c4872b6ea26653411194/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad336d0468ab49c2b2deb28687e54c8a/" rel="bookmark">
			计算机视觉——Mask R-CNN实例分割原理与算法应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 Mask R-CNN 扩展了 Faster R-CNN，为同时进行物体检测和高质量分割提供了框架。它易于训练，运行速度快，适用于其他任务，在 COCO 套件的不同赛道上都取得了优异成绩，即使没有额外的特征，也比其他模型更胜一筹。作为一种简单有效的方法，它为未来的研究奠定了基础。
导言 如上所述，Mask R-CNN 是一种有效而灵活的框架，可同时进行物体检测和高质量分割。它在现有的 Faster R-CNN 基础上增加了一个掩膜预测分支，一个名为 RoIAlign 的新层提供了精确定位。 Mask R-CNN 运行简单、快速，在 COCO 分割任务中表现优于传统模型、在物体检测方面也表现出色。它既灵活又准确，是未来研究和扩展复杂任务的理想框架。
相关研究 基于区域的 CNN（R-CNN）方法，如 Faster R-CNN，已在物体检测中发展出灵活而强大的性能。在实例分割方面，传统方法面临耗时长、准确率低的挑战，而最新的 Mask R-CNN 可同时预测分割和类别标签，以简单灵活的方法实现高性能结果。在分割优先级策略方面，与其他方法不同的是，它采用了实例优先策略，这也是未来有望发展的方向。
屏蔽 R-CNN 掩码 R-CNN 为快速 R-CNN 增加了一个对象掩码输出分支，它可以同时预测对象掩码以及每个候选对象的类别标签和边界框偏移。这种概念简单的方法主要有助于提取详细的空间布局，如像素之间的对齐，而这正是传统方法所缺乏的。
更快的 R-CNN 快速 R-CNN 包括两个阶段。在第一阶段，区域命题网络（RPN）为候选对象提出边界框；在第二阶段，快速 R-CNN 从这些边界框中提取特征，并执行分类和边界框回归。共享特征用于加快推理速度。
掩码 R-CNN 掩码 R-CNN 采用与 Faster R-CNN 相同的初始阶段（RPN），第二阶段为每个 RoI 生成二进制掩码以及类别和箱偏移预测。与普通系统不同的是，类别预测和掩码生成是分开的，因此在训练过程中生成每个类别的掩码时不会发生冲突。这确保了出色的实例分割。
面具表达 遮罩表示物体的空间排列。与普通的 fc 图层不同，遮罩通过卷积保持像素之间的对应关系，自然地捕捉空间结构。与传统方法相比，它的参数更少，精度更高。为了支持这种像素到像素的行为，作者引入了 RoIAlign 层，以实现更准确、参数更少的遮罩预测。
对齐 RoIPool 在提取每个 RoI 的小特征图时通常会使用量化技术。然而，这种量化会影响每个像素的掩码预测。提议的 RoIAlign 图层避免了量化，并使用双线性插值来计算精确的特征值，从而可以进行精细的掩码预测 RoIAlign 比 RoIPool 有了显著的改进。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad336d0468ab49c2b2deb28687e54c8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a669d59eadcdc4d6a71315f102af0923/" rel="bookmark">
			[Win11·Copilot] Win11 系统更新重启后任务栏 Copilot 图标突然消失 | 解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言Copilot介绍产生异常的原因解决方案总结 前言 在 Windows 11 的最新系统更新之后，一些用户报告了任务栏中 Copilot 图标消失的问题。这篇技术博文将为您提供详细的解决方案，帮助您恢复 Copilot 图标，并确保您能够继续享受 Copilot 带来的便利。
Copilot介绍 Copilot 是一个集成在 Windows 11 中的人工智能助手，旨在通过语音或文本输入提供信息检索、内容创作、语言翻译等多种服务。它是微软推出的一项创新技术，致力于提高用户的生产效率和创造力。
以下是 Copilot 的一些主要功能：
信息检索：Copilot 可以帮助用户查找信息，回答问题，提供天气预报、新闻摘要、体育赛事结果等。
内容创作：Copilot 能够创作诗歌、故事、代码、文章、歌曲等创意内容。
语言翻译：Copilot 能够理解和交流多种语言，帮助用户进行语言翻译。
学习辅导：Copilot 可以帮助学生学习，提供数学解题、历史知识、科学原理等方面的解释。
日常任务：Copilot 可以协助用户管理日程、设置提醒、发送邮件等。
技术支持：Copilot 可以提供一些基本的技术支持，如解决计算机问题、软件使用指导等。
Copilot 的目标是通过人工智能技术，提供有用、积极、礼貌、同情、有趣和引人入胜的交流体验。请注意，Copilot 的知识和信息更新到 2021 年为止，因此在某些情况下可能需要通过预定义的内部工具来获取最新信息。Copilot 遵循严格的安全指南，不会提供可能造成身体、情感或财务伤害的信息或内容。
可通过以下方式访问并使用 Copilot：
Windows 11任务栏：如果您安装了 Windows 11 版本的 H2 Insider Preview 版本，Copilot 图标会出现在任务栏中，取代了原来的 Cortana。您可以通过任务栏直接访问 Copilot。
网页端：在网页端通过 copilot.microsoft.com 或 bing.com 访问 Copilot。在这里，可以使用自然语言询问几乎任何主题的问题，AI 将能够提供全面的答案。
Edge浏览器：在 Microsoft Edge 浏览器中也可以访问 Copilot。Edge 上的 Copilot 提供撰写和见解等功能，可以帮助你在创建内容等方面激发创造力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a669d59eadcdc4d6a71315f102af0923/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8058f69289bd0b5f592aefcc05329c6/" rel="bookmark">
			【Android广播机制】之静态注册与动态注册全网详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		😄作者简介： 小曾同学.com,一个致力于测试开发的博主⛽️，主要职责：测试开发、CI/CD
如果文章知识点有错误的地方，还请大家指正，让我们一起学习，一起进步。
😊 座右铭：不想当开发的测试，不是一个好测试✌️。
如果感觉博主的文章还不错的话，还请点赞、收藏哦！👍
Hello小伙伴们，今天给大家分享Android的四大组件之广播机制。
在本文你将收获以下知识：
文章目录 一、前言二、广播的概念三、广播的分类3.1 标准广播（Normal broadcasts）3.2 有序广播 （ordered broadcasts） 四、广播注册方式五、案例5.1 静态注册广播5.2 动态注册广播 一、前言 在日常生活中我们经常会听到各式各样的广播消息，比如“铃铃铃，考试结束，考生停止作答”、村里的广播通知等，那么在Android中广播是怎样的呢，我们今天就来探索下。
广播是Android系统四大组件之一，Android应用与Android系统和其他Android应用之间可以相互收发广播消息，比如我们经常遇到的插拔USB数据线、网络变化监听、电量变化监控等。不仅可以接收系统广播，也可以接收自定义广播。
二、广播的概念 在Android中广播分为广播发送者和广播接收者。而BroadcastReceiver指的是广播接收者，所以我们用以下四点来概括什么是广播：
广播是Android四大组件之一，全称为 BroadcastReceiver 。广播分为发送方和接收方，就算没有接收方，发送方也会发送数据（这是设计使然）广播可以实现跨多个页面的数据通信广播可以实现跨进程间的数据通信。 三、广播的分类 在Android中广播主要分为两种类型：
3.1 标准广播（Normal broadcasts） 是一种完全异步执行的广播，在广播发出之后，所有的广播接收器几乎都会在同一时刻接收到这条广播消息，因此他们之间没有任何先后顺序可言。例如系统广播。
那么随之而来的特点是：
广播的发送者不会知道有哪些接收者接收到了广播消息，也无法影响接收者的执行顺序。接收者无法中断或取消广播的传递。广播的发送和接收是完全异步的，发送者和接收者之间没有直接的交互。 Android内置了很多系统级别的广播，我们可以在应用程序中通过监听这些广播来得到各种系统的状态信息。常见的系统广播：
3.2 有序广播 （ordered broadcasts） 是一种同步执行的广播，在广播发出之后，同一时刻只会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递。所有此时的广播接收器是有先后顺序的，优先级高的广播接收器就可以先收到广播消息，并且前面的广播接收器还可以截断正在传递的广播，这样后面的广播接收器就无法收到广播消息了。
特点：
有序广播允许接收者按照优先级顺序处理广播消息。接收者可以通过设置优先级来控制自己在广播链中的执行顺序。每个接收者可以中断广播的传递，以防止其他接收者继续接收广播消息。有序广播的发送者可以获取接收者处理广播的结果，因为每个接收者可以返回一个结果代码。 有序广播适用的情况
需要按照特定的顺序处理广播消息，确保接收者按照预期的顺序执行。需要控制广播的传递，允许接收者中断广播的传递。需要接收者之间进行通信和协作，通过设置结果代码来返回结果给广播发送者。 四、广播注册方式 广播接收器想要接收到消息，必须要进行注册，Android提供了两种注册方式。
静态注册：在AndroidManifest.xml中注册动态注册：在代码中注册，调用registerReceiver()注册广播。需要注意的是动态注册的接收器一定要取消注册。在onDestroy()方法中调用unregisterReceiver()方法来取消注册。 五、案例 5.1 静态注册广播 1.第一步：创建广播接收器 MyReceiver，继承 BroadcastReceiver 类，并实现 onReceiver()方法，需要注意的是：不要在onReceive()方法中添加过多的逻辑操作或耗时的操作。因为在广播接收器中不允许开启线程，当onReceive()方法运行较长时间而没结束时，程序会报错。因此广播接收器一般用来打开其他组件，比如创建一条状态栏通知或启动一个服务。
public class MyReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { Toast.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8058f69289bd0b5f592aefcc05329c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3c30d3c9c2b9273ef13a563ebd7fdcb/" rel="bookmark">
			DES加密解密算法（简单、易懂、超级详细）_des算法，2024年最新作为字节跳动面试官
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//负数就是中文字符 if (b &lt; 0) { b = -b; flag = 1; } //英文字符转换成ASCII的倒序，所以后面需要进行逆序 while (k &lt; 8) //这里的8表示char是1个字节=8bit { if (b) //这里将ASCII里的字符转换为二进制 { result += ((b % 2) + '0'); // 其中这里+'0',表示将数字转换为字符 b /= 2; } else result += '0'; k++; } //汉字字符处理 if (flag)//判断是否为汉字 { for (i = 0; i &lt; result.length(); i++) //此时因为是负数，源码、反码、补码不相等，需要置换 { if (result[i] == '0') result[i] = '1'; // 反码：最高最不变，其它的0-&gt;1,,1-&gt;0 else result[i] = '0'; } for (i = 0; result[i] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3c30d3c9c2b9273ef13a563ebd7fdcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33a797fa80726ffc8a07f8a81194c8b8/" rel="bookmark">
			【限时免费】华为OD机试2023C卷最全分类题解【Python/Java/C&#43;&#43;三大主流语言】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有华为OD考试扣扣交流群可加：948025485
可上全网独家的 欧弟OJ系统 练习华子OD、大厂真题
绿色聊天软件戳 od1336了解系统算法课程
华为OD机试，2023C卷最强题解（不断更新）
最清晰的题解+注释，最全面的分类总结。
华为OD第三方公司以及HR对接注意事项
华为OD机试知识点1周速成版——如果考试时间只有1周，不妨看看这篇
华为OD笔试2023C卷命题规律解读
Py/Java/C++三种语言ACM模式输入输出总结【大厂笔试/OD机考】
文章目录 栈常规栈单调栈 队列（题目极少，几乎不考）哈希哈希集合哈希表 前缀和双指针同向双指针相向双指针 贪心常规贪心题目结合双指针区间类贪心结合优先队列（堆） 滑动窗口固定滑窗不定滑窗 二分查找动态规划序列dp路径问题打家劫舍问题LIS问题LCS问题 状态dp背包dp博弈问题 树DFS/BFS通用搜索层数相关：仅用BFS拓扑排序：仅用BFS启发式搜索：仅用BFS 回溯模拟排序字符串基础数组基础数学系统设计 位运算（题目极少，几乎不考）链表（题目极少，几乎不考）并查集（题目极少，几乎不考）最小生成树（题目极少且难，几乎不考）华为OD算法/大厂面试高频题算法练习冲刺训练 栈 常规栈 【栈】2023C-密码输入检测【栈】2023C-火星文计算2 单调栈 【单调栈】2023C-找朋友【单调栈】2023C-找最小数【单调栈】2023C-回转寿司 队列（题目极少，几乎不考） 【队列】2023C-篮球游戏 哈希 哈希集合 【哈希集合】2023C-英文输入法【哈希集合】2023C-最大N个数与最小N个数的和 哈希表 【哈希表】2023C-跳房子I【哈希表】2023C-掌握单词个数【哈希表】2023C-石头剪刀布游戏【哈希表】2023C-密码解密 前缀和 双指针 同向双指针 【双指针】2023C-跳房子II 相向双指针 贪心 常规贪心题目 【贪心】2023C-停车找车位【贪心】2023C-找座位【贪心】2023C-求字符串中所有整数的最小和【贪心】2023C-环中最长子串【贪心】2023C-分割均衡字符串【贪心】2023C-分配土地最大面积【贪心】2023C-虚拟游戏理财【贪心】2023C-小朋友来自多少小区【贪心】2023C-伐木工【贪心】2023C-变换最小字符串【贪心/脑筋急转弯】2023C-运输时间 结合双指针 【贪心】2023C-有效子字符串【贪心】2023C-最多可以派出多少支团队 区间类贪心 【贪心】2023C-会议室占用时间【贪心】2023C-堆内存申请 结合优先队列（堆） 【贪心】2023C-在规定时间内获得的最大报酬【贪心】2023C-贪心歌手 滑动窗口 固定滑窗 不定滑窗 【不定滑窗】2023C-求满足条件的最长子串的长度【不定滑窗】2023C-字符串摘要【不定滑窗】2023C-最长的指定瑕疵度的元音子串【不定滑窗】2023C-最大可购买的宝石数量【不定滑窗】2023C-最小矩阵宽度 二分查找 【二分查找】2023C-小明找位置【二分查找】2023C-机器人搬砖【二分查找】2023C-孙悟空吃蟠桃【二分查找】2023C-部门人力分配 动态规划 序列dp 【DP】2023C-分班 路径问题 【DP】2023C-园区参观路径【DP】2023C-两个字符串间的最短路径 打家劫舍问题 LIS问题 LCS问题 状态dp 【DP】2023C-分月饼 背包dp 【DP】2023C-通过软盘拷贝文件 博弈问题 【DP】2023C-抢7游戏 树 【DFS】2023C-计算三叉搜索树的高度【DFS】2023C-悄悄话花费的时间【DFS/BFS】2023C-二叉树的广度优先遍历 DFS/BFS 通用 【DFS/BFS】2023C-地图寻宝【DFS/BFS】2023C-精准核酸检测【DFS/BFS】2023C-图像物体的边界【DFS/BFS】2023C-可以组成网络的服务器【DFS/BFS】2023C-寻找最富裕的小家庭【DFS/BFS】2023C-聚餐地点 搜索层数相关：仅用BFS 【BFS】2023C-周末爬山【BFS】2023C-跳马问题【BFS】2023C-亲子游戏 拓扑排序：仅用BFS 【BFS】2023C-启动多任务排序【BFS】2023C-查找一个有向网络的头节点和尾节点 启发式搜索：仅用BFS 【BFS】2023C-寻找最优的路测线路 回溯 【回溯】2023C-考古学家【回溯】2023C-找到它【回溯】2023C-最长连续手牌【回溯】2023C-表演赛游戏分组【回溯】2023C-田忌赛马【回溯】2023C-加密算法【回溯】2023C-字符串拼接 模拟 排序 【排序】2023C-身高提供排序【排序】2023C-身高排序【排序】2023C-开源项目热榜【排序】2023C-最低位排序【排序】2023C-机场航班调度程序【排序】2023C-数组去重和排序【排序】2023C-智能成绩表 字符串基础 【模拟】2023C-字符串分割（二）【模拟】2023C-API 集群负载统计 数组基础 【模拟】2023B-GPU调度【模拟】2023C-回收银饰【模拟】2023C-小明能到达的最大坐标值【模拟】2023C-比赛的冠亚季军【模拟】2023C-螺旋矩阵【模拟】2023C-灰度图恢复 数学 【模拟】2023C-货车司机【模拟】2023C-整数分解【模拟】2023C-结队编程【模拟】2023C-素数之积【模拟】2023C-来自异国的客人【模拟】2023C-解密犯罪时间【模拟】2023C-多段线数据压缩 系统设计 【系统设计】2023C-文件缓存系统 位运算（题目极少，几乎不考） 链表（题目极少，几乎不考） 并查集（题目极少，几乎不考） 最小生成树（题目极少且难，几乎不考） 【最小生成树】2023C-5G 网络建设 华为OD算法/大厂面试高频题算法练习冲刺训练 华为OD算法/大厂面试高频题算法冲刺训练目前开始常态化报名！目前已服务100+同学成功上岸！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33a797fa80726ffc8a07f8a81194c8b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5c6be556f59e43d184c1a7c570023a3/" rel="bookmark">
			Python虚拟环境（Python venv）的创建、激活、退出及删除_python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以为每个项目创建不同的虚拟环境，并测试它们在不同Python版本下的运行情况，以确保项目兼容性。
2.如何创建Python虚拟环境（venv） 2.1通过Python内置venv创建 Python 3.4+ 可以使用内置到Python中的 venv库 创建和管理虚拟环境。
1）首先打开命令行终端（cmd.exe），以便在终端中执行创建虚拟环境的命令；
2）使用命令创建一个名为"my_venv"的虚拟环境 。
python -m venv C:\python_venv\my_venv 2.2通过virtualenv库创建 除了使用Python内置的venv库外，还有其他方式可以创建Python虚拟环境，其中最常用的是使用第三方工具virtualenv，它是一个灵活的工具，允许在各种操作系统和Python版本中创建虚拟环境，并与不同项目一起使用。它还支持多个Python版本，并提供更多的配置选项，以满足特定项目的需求。
1）安装virtualenv,使用pip命令安装
pip install virtualenv 2）创建虚拟环境，在终端中，导航到你想要创建虚拟环境的目录，并运行以下命令来创建虚拟环境：
virtualenv my_venv 2.3创建的虚拟环境一般目录如下： . ├── Include ├── Lib │ └── site-packages ├── pyvenv.cfg └── Scripts ├── activate ├── activate.bat ├── Activate.ps1 ├── deactivate.bat ├── pip3.23.exe ├── pip3.exe ├── pip.exe ├── python.exe └── pythonw.exe 3.Python虚拟环境的激活 当Python虚拟环境激活以后，就可以在虚拟环境中使用pip来安装第三方依赖项、运行Python程序等工作。
my_venv\Scripts\activate 4.Python虚拟环境的退出 当你完成工作时，可以通过运行以下命令来退出虚拟环境
deactivate 5.Python虚拟环境的删除 1）在删除虚拟环境之前，请确保你已退出并停用了虚拟环境。
自我介绍一下，小编13年上海交大毕业，曾经在小公司待过，也去过华为、OPPO等大厂，18年进入阿里一直到现在。
深知大多数Python工程师，想要提升技能，往往是自己摸索成长或者是报班学习，但对于培训机构动则几千的学费，着实压力不小。自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《2024年Python开发全套学习资料》，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友，同时减轻大家的负担。
既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，基本涵盖了95%以上前端开发知识点，真正体系化！
由于文件比较大，这里只是将部分目录大纲截图出来，每个节点里面都包含大厂面经、学习笔记、源码讲义、实战项目、讲解视频，并且后续会持续更新
如果你觉得这些内容对你有帮助，可以扫码获取！！！（备注Python）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5c6be556f59e43d184c1a7c570023a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9aa64212f01d38433c9051242e7d525/" rel="bookmark">
			RabbitMQ系列（18）--RabbitMQ基于插件实现延迟队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前往RabbitMQ官网下载往RabbitMQ添加延迟消息的插件
RabbitMQ官网下载插件的网址：https://www.rabbitmq.com/community-plugins.html
2、下载rabbitmq_delayer_message_exchange插件（注：RabbitMQ是什么版本的，下载的插件就得是什么版本的，得对应上，以下截图为官方文档的对插件版本的要求说明） 3、把这个插件传输到服务器上
4、根据官网的指示把插件放到RabbitMQ指定的文件夹下
RabbitMQ官网指示安装插件步骤的网址：https://www.rabbitmq.com/installing-plugins.html
我这里安装RabbitMQ的系统是CentOS，所以放在/usr/lib/rabbitmq/lib/rabbitmq_server-3.10.0/plugins这个目录下
5、拷贝插件到指定的目录下
例：
cp rabbitmq_delayed_message_exchange-3.10.0.ez /usr/lib/rabbitmq/lib/rabbitmq_server-3.10.0/plugins/ 效果图：
6、安装延迟队列插件
输入以下命令安装延迟队列插件
rabbitmq-plugins enable rabbitmq_delayed_message_exchange 效果图：
7、重启RabbitMQ
输入以下命令重启RabbitMQ
systemctl restart rabbitmq-server.service 效果图：
8、查看插件是否安装成功
进入RabbitMQ的管理页面，进入Exchange的管理页面，新增Exchange，在Type里面可以看到x-delayed-message的选项，证明延迟队列插件安装成功
9、基于插件实现延迟队列的原理示意图
原先我们没下插件之前实现延迟队列是基于图下这种方式实现的
但我们下载插件后就能通过交换机延迟消息的方式来实现消息的延迟了（由步骤8可见，我们验证插件是否安装成功是从Exchange进去的，而不是从Queues进去的）
10、基于插件延迟队列的代码实现
(1)在config包里新建一个名为DelayedQueueConfig的类用于编写配置队列延迟的代码
代码如下：
package com.ken.springbootrqbbitmq.config; import org.springframework.amqp.core.*; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import java.util.HashMap; import java.util.Map; @Configuration public class DelayedQueueConfig { //队列 public static final String DELAYED_QUEUE_NAME = "delayed_queue"; //交换机 public static final String DELAYED_EXCHANGE_NAME = "DELAYED_EXCHANGE"; //交换机 public static final String DELAYED_ROUTING_KEY = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9aa64212f01d38433c9051242e7d525/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e20919dced52c237741d7c60c3845beb/" rel="bookmark">
			Qt_30道常见面试题及答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 简述 Qt 是什么？ 答：Qt 是一个跨平台的应用程序开发框架，它提供了一系列的工具和库，用于开发图形用户界面（GUI）应用程序。
2. Qt 有哪些主要模块？ 答：Qt 的主要模块包括 Qt Core、Qt Gui、Qt Widgets、QtMultimedia、Qt Network 等。
3. 如何在 Qt 中创建一个窗口？ 答：可以使用 Qt Widgets 模块中的 QMainWindow 或 QDialog 类来创建一个窗口。
4. 在 Qt 中如何添加控件？ 答：可以使用设计师工具（如 Qt Creator）通过拖拽的方式添加控件，也可以通过代码创建控件并设置其属性。
5. 简述信号和槽的概念以及它们的作用。 答：信号和槽是 Qt 中的一种通信机制。信号用于触发某个事件，而槽用于响应信号。通过连接信号和槽，可以实现对象之间的通信。
6. 如何在 Qt 中实现自定义信号和槽？ 答：可以在类中使用signals 关键字声明自定义信号，使用 slots 关键字声明自定义槽，并使用 connect 函数将信号和槽进行连接。
7. Qt 中的布局管理器有哪些？ 答：常见的布局管理器包括 QVBoxLayout（垂直布局）、QHBoxLayout（水平布局）、QGridLayout（网格布局）等。
8. 如何在 Qt 中使用布局管理器？ 答：将控件添加到布局管理器中，并设置布局管理器的属性来管理控件的位置和大小。
9. 在 Qt 中如何实现动态布局？ 答：可以使用 QLayout 的 addWidget 方法动态添加或移除控件，或者使用 QSplitter 等控件来实现动态分割布局。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e20919dced52c237741d7c60c3845beb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c093a155b9ba0c317ecb549f152d620/" rel="bookmark">
			【行业洞察】AIGC证书到底有用吗？费用、认证流程全解析！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【行业洞察】AIGC证书到底有用吗？费用、认证流程全解析！ 在这个以数据和技术为驱动的时代，人工智能(AI)技术正迅速改变我们的工作和生活方式。AIGC（Artificial Intelligence and Generative Content）证书作为一个新兴的专业资格认证，它的出现并非偶然，而是市场需求和技术发展的必然产物。但在投入时间和资金之前，我们必须问自己：AIGC证书真的有用吗？让我们一起探索这一问题，分析其认证费用和认证流程，并揭示持有此证书的深远意义。
证书报名徽：nbaigc（请记住：人工智能时代，一起做一个NB的Aigc） 一、AIGC证书的战略重要性 在AI领域，创新是常态，更新是必须。AIGC证书培训的核心是最新的AI技术和生成内容的应用，这使得持证者在职业竞争中脱颖而出。在技术迭代如此迅速的行业里，持续更新自己的知识库和技能，不仅是个人职业发展的需要，也是企业竞争力的体现。因此，AIGC证书不仅是一张纸，更是一个行业认可的标志，它证明了持有者在人工智能最前沿领域的专业能力和实践经验。
二、AIGC认证费用的合理性 投资自我总是值得的，尤其是在教育和专业发展方面。AIGC认证的费用结构通常包括培训费、材料费和考试费。虽然这样的投入不菲，但与其带来的职业优势和潜在收益相比，这是一笔相当合理的投资。我们必须从长远的角度来看待这笔费用：它不仅提升了你的专业技能，更增加了你在AI领域的市场价值。
三、AIGC认证流程的详细解析 AIGC认证流程设计严谨，确保每一位参与者都能得到系统的训练和评估。从初步的在线学习到实际的项目操作，再到最终的认证考试，每一步都旨在验证和强化学习者的能力。这个过程不仅提供了必要的技术知识，更重要的是培养了解决实际问题的能力。
四、AIGC证书的职业益处 持有AIGC证书的专业人士，在求职市场上具有不可忽视的优势。他们通过认证的背景表明了对专业的热情和对未来技术的适应能力，这使得他们成为各大企业争抢的对象。无论是在职场上求新求变，还是在学术界深造，AIGC证书都是一把打开新世界大门的钥匙。
五、未来展望与号召 当我们站在技术革新的门槛上，AIGC证书提供了跨越门槛的桥梁。这不仅是对个人能力的认证，更是对未来机遇的把握。在这个知识更新换代极快的时代，我们不能停滞不前，应该积极拥抱新技术，通过获取如AIGC这样的认证，不断提升自己的竞争力。
现在是时候行动了！投资自己，获取AIGC证书，为自己在人工智能领域的职业生涯加速——不仅为了今天，更为了未来。让我们一起在AI的浪潮中乘风破浪，拥抱那些无限的可能！
结语 AIGC证书是您在人工智能领域中跨越新高度的翅膀。它的费用是必要的投资，认证流程是提升能力的阶梯，而它的潜在价值是开启未来职业成功之门的钥匙。不要犹豫，为自己的未来投资，拥抱变革，成就非凡。证书报名徽：nbaigc（请记住：人工智能时代，一起做一个NB的Aigc）
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/422/">«</a>
	<span class="pagination__item pagination__item--current">423/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/424/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>