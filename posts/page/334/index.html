<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31430ae0321e5208a88f49c10fe91f79/" rel="bookmark">
			[JAVASE] String类 StringBuffer类 StringBuilder类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.String类
1.1 String字符串不可变的原因
1.2 字符串中的比较方法 1.2.1 equals
1.2.2 compareTo 与 compareToIgnoreCase
1.3 字符串中的查找方法
1.3.1 charAt 1.3.2 indexOf 与 lastIndexOf
1.4 字符串中的转换方法
1.4.1 valueOf
1.4.2 toUpperCase 与 toLowerCase
1.5 字符串的格式化 1.6 字符串的替换 1.6.1 replace
1.6.2 replaceFirst 与 replaceALL 1.7 字符串的分割
1.8 字符串的截取 1.9 字符串的清除
1.10 小总结 (重要)
二. StringBuffer类
2.1 StringBuffer类的说明 2.2 字符串的插入
2.2.1 insert
2.2.2 append
2.3 字符串的删除 2.4 StringBuffer类型 ==&gt; String类型
2.5 小总结 三.StringBuilder类
3.1 StringBuilder类的说明 3.2 StringBuilder类中的常用方法 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31430ae0321e5208a88f49c10fe91f79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac56f3d5613938a9a0f55a538c88a88b/" rel="bookmark">
			04-Shell 编程之正则表达式与文本处理器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于一般计算机用户来说，由于使用到正则表达式的机会不多，所以无法体会正则表达 式的魅力，而对于系统管理员来说，正则表达式则是必备技能之一。 正则表达式对于系统管理员来说是非常重要的，系统运行过程中会产生大量的信息，这 些信息有些是非常重要的，有些则仅是告知的信息。身为系统管理员如果直接看这么多的信 息数据，无法快速定位到重要的信息，如“用户账号登录失败”“服务启动失败”等信息。这时 可以通过正则表达式快速提取“有问题”的信息。如此一来，可以将运维工作变得更加简单、 方便
引言 在Shell编程中，正则表达式（Regular Expression，简称RE）和文本处理器是两项非常重要的工具。它们允许我们高效地处理和分析文本数据。本文档将基于您提供的材料文本，对Shell编程中的正则表达式和文本处理器grep进行详细的解析。
一、正则表达式概述 正则表达式是一种强大的文本处理工具，它使用特定的模式来描述字符序列的规则。通过定义这些规则，我们可以在文本中快速定位、查找、替换或删除符合特定模式的字符串。
在Shell编程中，正则表达式主要用于文本搜索和替换操作。常用的文本处理器如grep、sed、awk等都支持正则表达式。
二、grep命令详解 grep是一个强大的文本搜索工具，它使用正则表达式来搜索文本，并把匹配的行打印出来。以下是grep命令的一些常用选项和参数：
-a：不要忽略二进制数据。-A&lt;显示列数&gt;：除了显示符合范本样式的那一行之外，并显示该行之后的内容。-b：在显示符合范本样式的那一行之外，并显示该行之前的内容。-c：计算符合范本样式的行数。-C&lt;显示列数&gt;：除了显示符合范本样式的那一行之外，并显示该行之前后的内容。-d&lt;进行动作&gt;：当指定要查找的是目录而非文件时，必须使用这项参数。-e&lt;范本样式&gt;：指定字符串作为查找文件内容的范本样式。-E：将范本样式为延伸的普通表示法来使用，即支持扩展正则表达式。-f&lt;范本文件&gt;：指定范本文件，其内容有一个或多个范本样式。-F：将范本样式视为固定字符串的列表。-G：将范本样式视为普通的表示法来使用（默认）。-h：在显示符合范本样式的那一行之前，不标示该行所属的文件名称。-H：在显示符合范本样式的那一行之前，标示该行所属的文件名称（默认）。-i：忽略字符大小写的差别。-l：列出文件内容符合指定的范本样式的文件名称。-L：列出文件内容不符合指定的范本样式的文件名称。-n：在显示符合范本样式的那一行之前，标示出该行的编号。-q：不显示任何信息，但可以通过返回值判断查找是否成功。-R/-r：递归地在目录及其子目录中搜索。-s：不显示错误信息。-v：反转查找，即显示不包含指定模式的行。-w：只显示全字符合的列。-x：只显示全列符合的列。-o：只输出文件中匹配到的部分。 三、示例操作 假设的文件内容 (example.txt):
复制代码
apple123 banana orange456 123grape watermelon789 woody100 xyzwoooood Hello World 解析任务：
查找包含数字的行。查找以wo开头的单词。查找不包含字母o的行。 解析结果：
1. 查找包含数字的行：
我们可以使用正则表达式中的[0-9]来匹配任意数字。因为grep默认就是查找包含指定模式的行，所以不需要额外的参数。
bash复制代码
grep '[0-9]' example.txt 输出结果：
复制代码
apple123 orange456 123grape watermelon789 woody100 xyzwoooood 这些行都包含了至少一个数字。
2. 查找以wo开头的单词：
这里我们可以使用正则表达式的单词边界符\b来确保匹配的是整个单词的开始，而不是单词中的部分子串。
bash复制代码
grep -w '\bwo' example.txt 但注意，上述命令实际上不会返回任何结果，因为文件中没有以wo开头的完整单词（如woody虽然包含wo但不是以它开头）。但如果我们有一个单词wood，它就会被匹配。
如果我们只是想找到包含wo的行（不考虑是否是单词的开始），我们可以简单地使用：
bash复制代码
grep 'wo' example.txt 输出结果：
复制代码
orange456 woody100 xyzwoooood 3. 查找不包含字母o的行：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac56f3d5613938a9a0f55a538c88a88b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4586d577f9a8e40d424a4cb5a343ddb8/" rel="bookmark">
			Kotlin 接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 定义抽象属性抽象方法默认方法使用伴生对象实现接口实例化接口 定义 我们日常生活中接触的接口常见的有 Type-C 接口、USB 接口。我们可以看到，带上了接口，可以用于与特定的设备连接，实现充电、存储等功能。
我们使用interface定义一个接口，其写法与定义类相似：
interface USB 我们可以给它取个名字，因为该名字是所有USB共有的，我们可以放到伴生对象中（因为后面有一些小动作，还是把伴生对象先删掉）：
interface USB { companion object { const val NAME = "USB" } } Note：接口没有构造函数，你不能为一个接口声明构造。
抽象属性 我们知道，USB 接口是存在版本的，我们可以给USB定义一个version。如果你对version赋值，IDEA 提示Property initializers are not allowed in interfaces（interface中属性初始化是不被允许的），因为此时的version是抽象属性。
如果在属性或方法定义前加上关键字abstract，可以将其声明为抽象属性或方法。此时属性不能被赋值，而方法不能拥有方法体。抽象会在实现类（继承自该接口的类）中被实现（override），类似下方提到的默认方法。
interface USB { // 此处 abstract 可以省略 val version: String } Note：接口中不允许初始化属性，但是可以使用get函数（Getter），此时该属性不是abstract抽象属性，是open的（可被实现类override重写）：
interface USB { // open 可省略 open val version: String get() = "3.0" } 抽象方法 使用 USB 接口的工具有很多的用途，我们并不知道它具体用来干什么，此时，我们可以给USB定义一个实现某种功能（如充电、存储）的抽象函数。定义抽象方法时不需要写方法体（也就是不需要说明它要拿来干什么）。方法体会在实现类中写出。
interface USB { val version: String // 此处 abstract 被省略 fun work() } 默认方法 接口中可以写一些具有方法体的方法，其默认带有open修饰符（可以被实现类更改方法体）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4586d577f9a8e40d424a4cb5a343ddb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82829bf81c648a3ad5555b0ed74ea16d/" rel="bookmark">
			LAMP集群分布式安全方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验目的 LAMP（Linux + Apache + MySQL + PHP）是一种常见的Web应用程序堆栈，而LAMP集群是将多个服务器组合在一起以提供高可用性和可扩展性的解决方案。LAMP集群式安全方案的实验目的可以有以下几个方面：
1. 评估集群环境下的数据安全性：通过配置和测试LAMP集群中的数据库服务器、Web服务器和应用服务器之间的安全连接，以确保数据传输的机密性和完整性。
2. 检测和防止网络攻击：在LAMP集群中，网络攻击的风险可能会增加。实验目的可以包括测试和评估集群中的防火墙、入侵检测系统和其他安全措施的有效性，以确保网络不受恶意攻击的影响。
3. 确保应用程序的安全性：在LAMP集群中，应用程序层面的安全漏洞可能会导致敏感数据泄露或未经授权的访问。实验可以包括对应用程序进行渗透测试、代码审查和安全配置评估，以发现和修复潜在的漏洞。
4. 测试高可用性和灾备性：LAMP集群的一个主要目标是提供高可用性和灾备性，即在服务器故障或其他不可预见情况下保持应用程序的连续性。实验可以模拟故障情景，测试集群中的故障转移和自动恢复机制的可靠性和效率。
总之，LAMP集群式安全方案的实验目的是评估和增强LAMP集群的安全性、可靠性和鲁棒性，以应对潜在的安全威胁和故障情况。
实验内容 （一）前期准备
1.安装Centos7
2.配置好ip：10.0.0.8
3.配置好镜像源
4.修改端口为10022
[root@localhost~]# vim /etc/ssh/sshd_config
//编辑/etc/ssh/sshd_config，找到port，去掉“#”，将22改成1002
[root@localhost ~]# systemctl restart sshd //重启sshd服务
[root@localhost ~]# netstat -tunlp | grep sshd
5.克隆三个虚拟机，分别将IP修改为10.0.0.8（Text服务器），10.0.0.9（Web服务器），10.0.0.10（Database服务器）。
（二）Web服务器
1.关闭防火墙和SE Linux
①临时关闭:输入命令setenforce 0,重启系统后还会开启
②永久关闭:输入命令vi /etc/selinux/config，将SELINUX=enforcing改为ELINUX=disabled
远程连接，将默认端口22改为10022安装Apache ①安装Apache：yum -y install httpd
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a31d2b9c34f0fe5cf1979f4a8cb1811/" rel="bookmark">
			4.nginx反向代理、负载均衡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nginx反向代理、负载均衡 一、反向代理1、语法2、注意事项3、后端服务器记录客户端真实IP3.1 在nginx反向代理时添加x-real-ip字段3.2 后端httpd修改combined日志格式3.3 后端是nginx的情况 二、负载均衡 upstream模块1、负载均衡作用2、调度算法3、配置应用 一、反向代理 隐藏后端服务器地址信息 1、语法 location uri { proxy_pass 后端服务器地址; } 需求: 将/mp3的访问请求转交到后端的/music地址
location /mp3 { proxy_pass http://192.168.140.11/music; } 需求: 将/download请求转交到后端的/xz地址
location /download { proxy_pass http://192.168.140.11/xz; } 2、注意事项 反向代理时，nginx会将location中的uri地址自动拼接后端服务器地址 location /first { proxy_pass http://192.168.140.11/; } location中要涉及到正则匹配，后端服务器不支持写具体的uri地址 location ~ /test { proxy_pass http://192.168.140.11; } 3、后端服务器记录客户端真实IP 3.1 在nginx反向代理时添加x-real-ip字段 location /mp3 { proxy_pass http://192.168.140.11/music; proxy_set_header X-REAL-IP $remote_addr; } 3.2 后端httpd修改combined日志格式 [root@ca ~]# grep "LogFormat" /etc/httpd/conf/httpd.conf LogFormat "%{X-REAL-IP}i %l %u %t \"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a31d2b9c34f0fe5cf1979f4a8cb1811/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e0b738c500fbddb1d4eddadb38863a9/" rel="bookmark">
			著名开源软件Greenplum突然关闭GitHub源码，数据仓库选型带来新变数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天一早看见新闻，著名的开源数据仓库Greenplum不能访问了，非常吃惊，因为小编昨天晚上还可以从github下载编译Greenplum7.1的源码。早上登录到Greenplum的github主页，已经是"人去楼空"的404了。
目前Greenplum官网和Twitter没有发布任何消息，也不清楚是什么原因关闭了源码。如果永久闭源，必然将影响到Greenplum的持续业务发展，目前数据仓库领域的竞争非常激烈。
Greenplum是基于PostgreSQL开发的MPP数据仓库，在业界有非常高的流行度，Greenplum当前最新版本是7.1，有许多公司使用，在全球数据库排行榜DB-Engines当前排名第48位。
但是公司一直颠沛流离，从2005年创建，2010年被EMC收购（估值3亿美金），2012年纳入到Pivotal Software品牌，2015年对外开源，2020年Pivotal被VMWare收购，2023年VMWare又被博通收购。
Greenplum在中国有非常大影响力，但是商业发展缓慢，前几年很多核心骨干都出来创业了，包括偶数科技（OushuDB）、酷克数据（HashData）四维纵横（YMatrix）、拓数派（PieCloudDB）等。
另外国内还有很多著名的开源数据仓库选择，如Doris、StarRocks、ClickHouse等等。
参考：
https://en.wikipedia.org/wiki/Greenplum
https://github.com/greenplum-db
https://db-engines.com/en/ranking
原文转自公众号（云数据库技术）：著名开源软件Greenplum突然关闭GitHub源码，数据仓库选型带来新变数著名开源数据仓库Greenplum突然关闭github源码。https://mp.weixin.qq.com/s/YI3IqUZK91hmrpS7xzTHVA
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/375a4faaf2a44177e64df920c06f2850/" rel="bookmark">
			Turbo 游戏引擎将在 Eclipse 的支持下快速发展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们很高兴地宣布，Turbo 将在 Eclipse 上推出。在链上构建游戏的开发者，现可以访问一个易于使用、低代码的 2D 游戏引擎，使任何人都能构建和部署游戏。
这次合作伙伴关系是 Eclipse 游戏生态系统中的一个重要里程碑，并支持我们建立一个活跃的游戏开发者社区的愿景，以推出 Eclipse 原生游戏，这些游戏将独特地受益于我们的高性能执行环境。
“Eclipse 的高吞吐量低延迟性能的技术方案，正在成为 Web3 游戏未来的基础。我们对与 Turbo 的合作感到兴奋，我们将共同对下一代游戏开发者和玩家进行赋能。” Turbo 联合创始人 Julian Moncada 表示。
什么是 Turbo？
Turbo 是新一代 2D 游戏引擎，旨在提升游戏开发速度。其目标是让任何人能够在 24 小时内创建各种类型的游戏，并且可以在不同平台或设备上运行。该引擎采用 WebAssembly + WebGPU 技术，因此具备跨平台特性，甚至可以无需图形用户界面的情况下运行（即无界面模式）。此外，在对代码、着色器或精灵进行修改时，游戏会自动重新加载，使得开发者能够实时更改代码和内容。Turbo 还内置了简化游戏开发所需的 API 接口。
在 Eclipse 上启动 Turbo
通过在 Eclipse 上启动 Turbo，开发者可以开发利用 Eclipse 的高性能和低区块时间的链上游戏。在Eclipse上，使用 Turbo 构建的游戏可以在不到一秒钟的时间内完成状态转换，这得益于 Eclipse 400 毫秒的区块时间，且链上交易将从 Eclipse 的独立费用市场和并行执行中受益，这意味着不管网络上其他任何热点状态如何，游戏状态转换和游戏内交易都将以低费用发生。
招募游戏开发者（包括初次游戏开发者！）
有了 Turbo，创建游戏就像是在 Turbo 文档中引用几行代码并更改某些变量那样简单。如果你有一个简单的 2D 游戏想法，你可以使用 Turbo 构建一个链上游戏（如果你有这样的想法，你就能构建它）。如果这对你来说仍然太复杂，Turbo 创建了一个AI助手，Turbo Game Developer GPT，作为你游戏创建的起点。如果有一个你一直想要创建的游戏，无论是围绕你最喜欢的 meme 币、你最喜欢的加密角色，还是一个 NFT 收藏品，Turbo 都使你能够轻松创建这款游戏。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/375a4faaf2a44177e64df920c06f2850/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4890b4e2900082b2a62f957daae9bd1/" rel="bookmark">
			【JavaScript】ECMAS6（ES6）新特性概览（二）：解构赋值、扩展与收集、class类全面解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥 个人主页：空白诗 🔥 热门专栏：【JavaScript】 文章目录 🌿 引言五、 Destructuring Assignment - 解构赋值，数据提取的艺术 🎨📌 数组解构📌 对象解构📌 特殊用法与技巧📌 小结 六、 Spread and Rest Operators - 扩展与收集，数组操作新境界 🌀📌 扩展运算符📌 剩余参数📌 高级用法与技巧📌 小结 七、 Class类 - 面向对象编程，正式登场 👑📌 构造函数与实例化📌 方法📌 Getter 和 Setter📌 继承📌 静态方法和属性 总结 🌿 引言 ES6，作为ECMAScript 2015的简称，标志着JavaScript编程语言的一个重要进化节点。它不是渐进的变化，而是一次飞跃式的更新，为开发者带来了一系列强大的新特性与语法糖，极大提升了代码的简洁性、可读性和运行效率。从新的变量声明方式let与const，到优雅的箭头函数、模板字符串，再到让对象操作更为灵活的解构赋值与增强的对象字面量，ES6的每项改进都旨在让JavaScript适应日益复杂的应用场景，同时保持其作为脚本语言的活力与魅力。本文是深入探索这些核心特性的起点，为你铺开一条通向高效、现代JavaScript编程实践的道路。
继上文👉🏻 【JavaScript】ECMAS6（ES6）新特性概览（一）：变量声明let与const、箭头函数、模板字面量全面解析 后，我们将继续深入探讨ECMAS6的其他关键特性，涵盖解构赋值、扩展与收集、面向对象编程的Class体系，进一步加深对现代JavaScript编程的理解与应用能力。
五、 Destructuring Assignment - 解构赋值，数据提取的艺术 🎨 解构赋值作为ES6引入的一项强大特性，彻底革新了数据访问与赋值的方式，使得从数组或对象中提取数据变得既直观又高效。这项技术不仅简化了代码，还大大增强了JavaScript的表达能力。
📌 数组解构 数组解构允许你将数组中的元素直接赋值给不同变量。你可以解构任意长度的数组，甚至忽略某些值或使用默认值。
const [first, , third, fourth = "default"] = [1, 2, 3, 4]; console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4890b4e2900082b2a62f957daae9bd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b72c168b72ab103665b7aad8c8a9ad3d/" rel="bookmark">
			一书读懂Python全栈安全，剑指网络空间安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 通过阅读《Python全栈安全/网络空间安全丛书》，您将能够全面而深入地理解Python全栈安全的广阔领域，从基础概念到高级应用无一遗漏。本书不仅详细解析了Python在网络安全、后端开发、数据分析及自动化等全栈领域的安全实践，还紧密贴合网络空间安全的最新趋势与挑战，确保您能掌握保护网络系统、预防黑客攻击、实施安全策略等关键技能。这不仅是一次知识的旅行，更是为您职业生涯保驾护航，助您剑指网络空间安全领域的巅峰，成为守护数字世界的坚强盾牌。
推荐图书 《Python全栈安全/网络空间安全丛书》([美]丹尼斯·伯恩)【摘要 书评 试读】- 京东图书
编辑推荐 安全是一个全栈性问题，包括用户接口、API、Web服务器、网络基础设施等。通过掌握强大的库、框架以及Python生态系统中的工具，你可自上而下地保护自己的系统。本书列举大量实例，插图清晰，代码丰富，准确地告诉你如何保护基于Python的Web应用程序。
《Python全栈安全》由经验丰富的安全专家Dennis Byrne撰写，讲解保护Python和基于Django的Web应用程序所需的一切，解释安全术语，揭开算法的神秘面纱。
本书开篇清晰讲解加密基础知识，然后循序渐进地讲述如何实施多层防御、安全的用户身份验证、安全的第三方访问，分析如何保护应用程序免受常见黑客攻击。
内容简介 加密、散列和数字签名。创建和安装TLS证书。在Django中实现身份验证、授权、OAuth 2.0和表单验证防范点击劫持、跨站脚本和SQL注入等攻击 作者简介 Dennis Byrne 是23andMe 架构团队的成员，负责保护1000 多万客户的基因数据和隐私。在23andMe 之前，Dennis 是LinkedIn 的软件工程师。Dennis 是一名健美运动员和GUE 洞穴潜水员。他目前住在硅谷，远离阿拉斯加(他在那里长大并求学)。
目录 第Ⅰ部分 密码学基础
第1章 纵深防御 3
1.1 攻击面 4
1.2 什么是纵深防御 6
1.2.1 安全标准 7
1.2.2 最佳实践 8
1.2.3 安全基本原则 9
1.3 工具 11
1.4 小结 15
第2章 散列 17
2.1 什么是散列函数 17
2.2 原型人物 22
2.3 数据完整性 23
2.4 选择加密散列函数 24
2.4.1 哪些散列函数是安全的 24
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b72c168b72ab103665b7aad8c8a9ad3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc601615879831b72881a5a6820cb06f/" rel="bookmark">
			解决jdk版本切换失败的原因 (修改环境变量无效) 解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先先了解一下我们的版本因项目版本需求 我们需要将 jdk17 切换为 jdk1.8但是更改了环境变量后执行 java -version 发现版本还是jdk17
随后我就在网上查了相关的问题解决办法，发现还真有不少这种情况，其问题出现的原因是：
由于C:\Windows\System32 下的java.exe 和javac.exe的优先级比配置文件的优先级高
但是我发现我的C:\Windows\System32下并没有发现这几个文件..
首先大家先看看我们的环境变量 发现了导致jdk无法切换的原因Oracle在使用过JDK后就会将JDK的配置写到配置文件中，
若是Oracle的环境变量配置在JDK的变量前时将会被Oracle的配置信息加载覆盖掉
所以我们的解决办法就是 将Oracle的环境变量放到JDK环境变量之后即可
最后修改为下图所示即可
最终能够成功修改我们的jdk版本
最后能够帮助到各位看官，感到非常荣幸。
如果解决了您困扰已久的问题请各位看官 点个关注点个赞。
支持一下我这个新人博主.
参考网址(更换JDK版本不成功，还是以前的版本（两种分析、解决办法） - 90后程序猿 - 博客园 (cnblogs.com))
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0de2f45c4af8b8154e57b1738d75f505/" rel="bookmark">
			AIGC如何改变人类生活20240529
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AIGC如何改变人类生活 随着人工智能技术的不断发展，人类生活正经历着前所未有的变革。在这个过程中，AIGC（人工智能生成内容）的概念应运而生，它已经在很多领域产生了深远的影响。本文将探讨AIGC如何改变人类生活，以期为读者提供更多关于这一创新技术的启示。
1. AIGC的定义 AIGC，即Artificial Intelligence Generated Content，直译为人工智能生成内容。其内涵是利用人工智能技术，通过对大量数据的学习和训练，生成各种形式的内容。AIGC不仅仅是简单的内容生产工具，它代表了一种全新的创作方式和思维模式。通过对AIGC的深刻理解，我们可以更好地把握其带来的机遇和挑战。这样的系统具有强大的学习能力，可以根据输入的数据和任务需求进行自我调整，为用户提供高度智能化的解决方案。
2. AIGC的技术基础 深度学习：AIGC的核心技术之一是深度学习。通过建立神经网络模型，AI能够从海量数据中学习特定模式和规律，从而生成新的内容。深度学习在图像识别、自然语言处理等领域的突破，为AIGC的实现提供了坚实的技术支持。
自然语言处理（NLP）：NLP是AIGC生成文字内容的重要技术。通过对语料库的大规模训练，AI可以理解和生成自然语言，完成从自动撰写文章到生成对话等多种任务。GPT（Generative Pre-trained Transformer）系列模型就是NLP领域的代表性成果。
生成对抗网络（GANs）：GANs是AIGC生成图像、视频等内容的关键技术。GANs由生成器和判别器组成，通过两者的相互博弈，生成器不断优化，最终能够生成逼真的图像和视频内容。
3. AIGC在生活中的应用场景 AIGC已经在多个领域产生了广泛的影响，以下几个方面可以为读者提供一个直观的了解。
3.1 智能家居 在智能家居领域，AIGC可以实现家居设备的智能化和互联。通过学习用户的生活习惯和偏好，AIGC可以帮助用户实现对家居设备的智能控制，如调节室内温度、调整灯光亮度等。此外，AIGC还可以根据用户需求提供更多个性化的服务，如智能推荐音乐、电影等。
案例：小米公司凭借其领先的AIGC技术，为用户打造了全方位的智能家居体验。通过小米AI音箱，用户可以用语音指令控制家中的灯光、电器等设备，实现智能家居的互联互通。小米的智能家居系统还能学习用户的生活习惯，为用户提供更加个性化的家居服务。
3.2 医疗健康 在医疗健康领域，AIGC可以对大量病例进行分析，辅助医生进行诊断。通过学习大量的医学知识和病例数据，AIGC可以为医生提供更精确的诊断建议，提高医疗质量。此外，AIGC还可以帮助用户管理健康，通过分析用户的生活习惯和健康状况，为用户提供个性化的健康建议。
案例：在医疗健康领域，阿里健康利用AIGC技术，推出了多款智能医疗产品。其中，阿里健康的“医鹿”APP通过大数据分析，能够为用户提供个性化的健康管理和疾病预防建议。同时，该系统还能辅助医生进行更准确的诊断，提高医疗服务的质量和效率。IBM的Watson for Oncology使用AI技术分析海量医学文献和病例数据，辅助肿瘤科医生制定治疗方案。据统计，Watson在癌症诊断和治疗建议方面的准确率高达90%以上，为许多患者提供了宝贵的第二意见。
3.3 教育培训 在教育培训领域，AIGC可以为教育者提供更多智能化的教学工具，如智能课程设计、个性化学习路径推荐等。同时，AIGC可以通过分析学生的学习数据，为教育者提供更有针对性的指导建议。在培训领域，AIGC可以为用户提供个性化的学习资源，帮助用户提高学习效率。
案例：在教育培训领域，腾讯课堂利用AIGC技术，为学习者提供了个性化的在线学习体验。通过分析学习者的学习数据和进度，腾讯课堂能够智能推荐适合的学习资源和课程，帮助学习者更高效地掌握知识。同时，该系统还为教师提供了丰富的教学工具和数据分析功能，提升了教学效果。Khan Academy使用AI技术为学生提供个性化的学习体验。AI系统会根据学生的学习进度和表现推荐适合的练习题和视频教程，帮助学生在合适的难度级别上进行学习，从而提高学习效果。
3.4 产业制造 在产业制造领域，AIGC可以实现生产线的智能化和自动化。通过对大量生产数据的分析，AIGC可以为企业提供更高效的生产方案，提高生产效率。此外，AIGC还可以在设备维护方面发挥作用，通过对设备数据的分析，预测设备故障，降低企业运营成本。
案例：西门子（Siemens）利用AIGC技术优化了其制造流程。通过分析生产数据，西门子的AI系统可以预测设备何时需要维护，从而减少故障停机时间，提高生产效率。据报道，西门子的智能工厂项目帮助其生产效率提升了15%。
4. AIGC对人类生活的影响 AIGC正在深刻地改变着人类生活的各个方面，其影响可以从以下几个方面进行总结。
4.1 提高生活品质 AIGC的应用可以帮助人们实现生活中的智能化和个性化，提高人们的生活品质。例如，智能家居可以为用户提供更加舒适的居住环境，智能医疗可以为患者提供更加精确的诊断和治疗方案，智能教育可以为学生提供更加个性化的学习资源，助力人们在各个领域实现更高的生活品质。
4.2 提高工作效率 AIGC在很多行业中的应用，可以极大地提高工作效率，降低人力成本。在制造业中，AIGC可以实现生产线的自动化，为企业节省大量的人力资源；在医疗领域，AIGC可以帮助医生更快地进行诊断，提高床位利用率；在教育领域，AIGC可以为教育者提供智能化的教学工具，降低教育成本。通过提高工作效率，AIGC可以为人类创造更多的财富和发展机会。
4.3 改变人际交往方式 AIGC技术的发展，也在改变人类的沟通方式。随着智能语音助手的普及，人们可以更方便地与设备进行交互；而在社交媒体上，AIGC可以帮助用户更高效地筛选信息，提高人际交往的质量。此外，AIGC还可以为人们提供智能翻译服务，有望打破语言障碍，促进全球范围内的交流与合作。
案例：Google翻译的AI技术可以实时翻译超过100种语言，帮助不同语言背景的人们轻松沟通，为全球商务和旅行提供了极大的便利。
4.4 引发伦理与道德讨论 AIGC技术的广泛应用，也引发了关于伦理和道德的讨论。例如，当AIGC被应用于医疗诊断时，谁应该对诊断结果负责？在教育领域，AIGC是否会导致教师失业？这些问题需要人类在技术发展的过程中进行深入的思考和探讨，以确保AIGC的发展真正造福于人类。
5. 结论 总之，AIGC正在深刻地改变着人类的生活方式。从智能家居、医疗健康、教育培训到产业制造，AIGC在各个领域的应用都为人们带来了前所未有的便捷和高效。然而，在享受AIGC带来的便利的同时，我们也应该关注其带来的伦理与道德问题，确保技术的发展真正造福于人类。在未来，AIGC有望继续引领人类生活的变革，为人类创造更美好的未来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b6f3e06477fb2d058623cd5fb9e7870/" rel="bookmark">
			EureKa是什么?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Eureka 是一个源于 Netflix 公司的开源项目，主要用于实现服务注册和服务发现的功能。它是构建分布式系统中的微服务架构的一个关键组件。下面是对 Eureka 的解释：
基本概念 Eureka 是基于 REST 的服务，主要用于管理微服务架构中的服务实例的注册与发现。它提供了服务注册中心，让各个微服务可以在其中注册自己的信息（比如 IP 地址、端口号、健康状况等），并能够发现其他已注册的服务实例。
核心组件 Eureka Server：作为服务注册中心，负责接收来自各个微服务实例的注册信息，并提供一个可供查询服务实例的接口。Eureka Server 通过复制多个实例来实现高可用性。
Eureka Client：集成在每个微服务应用中，用于向 Eureka Server 注册自身服务实例信息以及从 Eureka Server 获取其他服务实例的信息，从而实现服务间的调用。
关键特性 服务注册：微服务启动时，Eureka Client 会将服务实例的元数据（如主机名、IP地址、端口、健康检查URL等）注册到 Eureka Server。
服务发现：客户端可以通过 Eureka Server 获取到注册的服务实例列表，实现服务间的动态路由与负载均衡。
心跳机制：Eureka Client 定期向 Eureka Server 发送心跳（默认每30秒），以维持服务实例的活性状态。如果心跳超时未更新，Eureka Server 会将该服务实例标记为不可用。
自我保护模式：当网络分区故障发生或者大量服务实例同时下线导致 Eureka Server 收不到心跳时，它会自动进入自我保护模式，停止从注册表中移除因心跳失败而看似不健康的实例，以避免因网络瞬时故障造成服务雪崩。
客户端缓存：Eureka Client 会缓存从 Eureka Server 获取到的服务实例信息，即使与 Eureka Server 的连接中断，也能根据缓存继续进行服务调用，提高了系统的容错性。
高可用部署：生产环境中，通常会部署多个 Eureka Server 实例并形成集群，以确保服务注册中心的高可用性。
使用场景 Eureka 主要适用于微服务架构中，特别是当系统由众多独立服务构成，且这些服务需要动态发现和调用对方时。它被广泛应用于构建高可用、可伸缩的云端应用和服务平台。
集成与配置 Eureka 被 Spring Cloud 框架集成，开发者可以通过简单的注解（如 @EnableEurekaServer 和 @EnableEurekaClient）在 Spring Boot 应用中启用 Eureka Server 或 Client，简化了配置和部署过程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b6f3e06477fb2d058623cd5fb9e7870/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/102d69e4e29716b123665428263f38e9/" rel="bookmark">
			C&#43;&#43;第二十一弹---vector深度剖析及模拟实现(上)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨个人主页： 熬夜学编程的小林
💗系列专栏： 【C语言详解】 【数据结构详解】【C++详解】
目录
1、基本结构
2、默认成员函数
2.1、构造函数
2.2、析构函数 2.3、拷贝构造函数 2.3、赋值操作符重载
3、数据访问
4、迭代器获取
总结
1、基本结构 首先定义一个vector模版类，其中三个成员变量均为迭代器，且此处vector的迭代器是一个原生指针，我们这里为其定义别名iterator。
namespace lin { template&lt;class T&gt;//此处为类模板，实现不同数据类型的存储 class vector { public: //vector迭代器为原生指针 typedef T* iterator;//定义指针类型的别名iterator typedef const T* const_iterator; //...函数接口的实现 private: iterator _start;// 指向容器的开始 iterator _finish;// 指向容器中最后一个有效数据的下一个位置 iterator _endofstorage; // 指向存储容量的结尾 }; } 私有成员变量：
_start: 这是一个指针，指向容器的第一个元素。
_finish: 这个指针指向容器中最后一个有效数据的下一个位置。
_endofstorage: 这个指针指向分配给vector的内存块的末尾。这不是最后一个有效元素的位置，而是整个内存块的结束位置，在这之后可能会有额外的未初始化空间，预留以实现当vector增长时无需重新分配整个数组。
2、默认成员函数 2.1、构造函数 vector()
默认构造的函数功能是构造一个没有元素的空容器。
默认构造函数实现有两种方式，第一种是直接通过初始化列表直接初始值，第二种是通过成员变量的缺省值。
1.初始化列表
//将成员变量都初始化为空 vector() : _start(nullptr) , _finish(nullptr) , _endofstorage(nullptr) {} 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/102d69e4e29716b123665428263f38e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3d7e030ca5fc3e69c407d24d38eb2c1/" rel="bookmark">
			LLVM技术在GaussDB等数据库中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
LLVM和数据库
LLVM适用场景
LLVM对所有类型的SQL都会有收益吗？
LLVM在OLTP中就一定没有收益吗？
GaussDB中的LLVM
1. LLVM在华为应用于数据库的时间线
2. GaussDB LLVM实现简析
3. GaussDB LLVM支持加速的场景
支持LLVM的表达式：
支持LLVM的算子：
4. GaussDB LLVM使用建议
GUC参数：
5. GaussDB LLVM性能表现
PostgreSQL中的LLVM
1. LLVM在PostgreSQL应用的时间线
2. PostgreSQL LLVM实现简析
3. PostgreSQL LLVM支持加速的场景
总结
万物互联的态势下，数据量的激增使得“如何提升数据处理性能”成为各家数据库共同面临的挑战。作为编译优化技术的代表，基于LLVM的CodeGen技术，能为每个查询生成定制的机器码替代原本的通用函数，减少实际查询时冗余的条件逻辑判断、虚函数调用并提高数据局域性，从而达到提升查询整体性能的目的，成为数据库性能优化的一项重要技术。
LLVM能在分析类场景中给用户带来较大的收益，也能在特定的交易性场景中给用户带来一定的收益。接下来详细解读一下LLVM技术在GaussDB等数据库中的应用吧。
LLVM和数据库 LLVM（Low Level Virtual Machine）是一款流行的开源编译器框架，是CodeGen（生成源代码的工具）技术的事实标准，被广泛运用于数据库（如KES, AnalyticDB, GaussDB）、大数据（如Spark）、AI平台（如tensorflow）等领域，用于提升数据处理的性能。
在没有引入LLVM这类CodeGen技术之前，数据库会使用通用的处理逻辑来处理数据。但通用逻辑“笨重”（递归、封装、类型判断转换）的代码实现方式，存在虚函数开销、缓存使用率低下、对指令集不敏感等性能短板。
引入LLVM之后，可以为具体的查询生成定制化的机器码，并尽可能地将数据存储在CPU的寄存器中进一步加快计算的速度：
LLVM天然支持JIT，该技术可以解决条件逻辑冗余的问题；
减少大量的虚函数调用；
将数据尽可能地从内存加载到Cache上；
LLVM做了很多自动矢量化的工作；
比如，下图左侧是通用代码，右侧是CodeGen之后的代码。CodeGen根据实际情况消除了不必要的循环和判断。
图1 通用性处理逻辑和LLVM代码示意
另外，LLVM技术可以有不同的实现粒度。比如：可使用LLVM加速表达式计算，或再进一步，将多个算子融合编译成定制的机器码，或将自定义函数、存储过程等编译成定制的机器码。
图2 LLVM的实现粒度
数据库在执行引擎中，运用LLVM技术提升SQL的执行速度。如下图所示：
图3 LLVM技术运用于执行引擎
LLVM适用场景 LLVM对所有类型的SQL都会有收益吗？ 答案是否定的。
因为执行实时编译本身需要耗费一定的时间（简单表达式能做到毫秒级，复杂情况在百毫秒级），对于查询本身耗时较少的场景，加入LLVM反而会导致性能劣化。
因此，目前LLVM在OLAP/HTAP分析型业务场景中收益较大，有着广泛应用，而在OLTP交易型业务场景中，则相对没有那么广泛。
LLVM在OLTP中就一定没有收益吗？ 答案同样是否定的。
找对场景，一样有收益。比如根据ISPRAS 2017年发表的实验结果（jit-compiling sql queries in postgresql using llvm）可知：pgbench测试下，OLTP场景中简单的查询加上JIT（Just-in-time及时编译，LLVM天然支持）扩展没有带来性能的提升，甚至将TPS（事务数/秒）从21.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3d7e030ca5fc3e69c407d24d38eb2c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cd3b2cee87fcf8f34235469b27ed558/" rel="bookmark">
			Midjourney保姆级教程(五)：Midjourney图生图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Midjourney生成图片的方式除了使用文字描述生成图片外，还有“图生图”的方式，可以让生成的图片更接近参考的图片。
今天我们来聊聊“图生图”的方式。
一、模仿获取propmt 很多时候，我们不知道画什么内容的图片，大家可以关注内容分享平台（公众号、知乎、小红书、B站）等等，看看别人画的什么图片，搜集一些图片和描述词，模仿画出类似的图片。
核心方法：多找别人的图片，模仿作图
Midjourney V5版本出来后，提供了一个“/describe”指令，可以实现根据用户上传的图片，生成4条有关的propmt。
输入 /describe 指令后，需要上传一个图片。
将图片拖到虚线框，或点击“上传图标”上传一个图片。
发送指令后，生成 4 条 prompt
在MJbot回答的最下方有对应Propmt的“1”、“2”、“3”、“4”，点击选中一个，即可发送propmt给AI。
二、纯垫图 1、/blend指令融合 使用“/blend”命令来融合多张图片，也就是纯垫图。
这个指令默认是2张图模式，最多可支持5张图片。
可以直接将图片拖到框中，也可以点击框中的“上传图标”选择文件上传。
融合的原理：mj随机抓取每张图片的部分特点来融合生成图片。
一般不建议多个图片融合，mj不知道融图的方向，融合效果比较差。
这里演示下2张图片融合的效果，注意这里2张图片的位置互换不影响效果。
效果图：
2、/imagine指令（纯图片模式） 优先推荐这个方式，基于参考的图片，再加上风格图片或强化图来明确想要的风格。
（1）上传两张图片给mj
点击输入框左边的“+”，点击上传文件。
1张原图
1张风格图片
如果有需要强化的图片内容，比如保持西装效果，可以再加一张强化图。
（2）复制图片链接
点击MJ bot回复生成的图片，点开“浏览器打开”，复制两个图片的链接，粘贴到“/imagine”的对话框内。
（3）最后直接回车发送，等待生成图片
3、/imagine指令（图片 + 文字模式） 优先推荐这个方式，基于多张图片，再加上文字来明确想要的风格。
（1）上传一张或多张原图
（2）复制图片链接，空格，写入关键词。
商务女生，职业西装，打领带，彩色背景，干净清爽，迪士尼风格，卡通3d，可爱,潮流，C4D, 非常细腻的质感，--ar 3:4
business girl, professional suit, tie, colorful background, clean and fresh, Disney style, cartoon 3d, cute, trendy, C4D, very fine texture --ar 3:4
以上，就是图生图的知识，操作步骤已经详细介绍了，大家可以愉快的耍起来了。
但由于AIGC刚刚爆火，网上相关内容的文章博客五花八门、良莠不齐。要么杂乱、零散、碎片化，看着看着就衔接不上了，要么内容质量太浅，学不到干货。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cd3b2cee87fcf8f34235469b27ed558/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd5e4f9d5e4fd8fd1d09f99c58c7581c/" rel="bookmark">
			探索Django 5: 从零开始，打造你的第一个Web应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天我们将一起探索 Django 5，一个备受开发者喜爱的 Python Web 框架。我们会了解 Django 5 的简介，新特性，如何安装 Django，以及用 Django 编写一个简单的 “Hello, World” 网站。最后，我会推荐一本与 Django 5 相关的书籍，希望能够帮助你更深入地学习这个强大的框架
文章目录 Django 5 简介Django 5 新特性安装 Django用 Django 编写 Hello, World推荐书籍：Django 5 Web 应用开发实战内容简介获取方式 Django 5 简介 Django 是一个开放源代码的 Web 应用程序框架，由 Python 写成。它遵循 MVT（Model-View-Template）的设计模式，旨在帮助开发者高效地构建复杂且功能丰富的 Web 应用程序。随着每个版本的升级，Django 不断演变，提供更多功能和改进，让开发变得更加便捷。
Django 5 新特性 Django 5 带来了许多令人振奋的新特性，包括但不限于：
Asynchronous Views: 引入异步视图，允许处理高并发请求更有效率。Enhanced Admin Interface: 管理界面得到优化，提供更好的用户体验和功能。Improved Security: 加强了安全性，包括对跨站脚本攻击（XSS）等的防范。Performance Improvements: 性能得到进一步提升，使得网站响应更为迅速。 安装 Django 要开始使用 Django 5，首先需要安装它。可以使用 pip（Python 包管理器）来安装 Django：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd5e4f9d5e4fd8fd1d09f99c58c7581c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8742687503aef50b8d9ab7c2da7f082b/" rel="bookmark">
			C语言/数据结构——每日一题（设计循环队列）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.前言
二.正文
1.1题目描述
1.2题目分析
（1）定义栈的结构
（2）创建我们的队列
（3）判断队列是否为空
（4）判断队列是否数据已满
（5）队列数据的插入
（6） 队列数据的删除
（7） 取出队头的数据
（8）取出队尾的数据
（9）销毁我们创建的对列
1.3代码实现
三.结言
一.前言 上一次我们分享了关于队列的基本实现——https://blog.csdn.net/yiqingaa/article/details/139033067?spm=1001.2014.3001.5502
现在我们将使用队列知识来解决问题——设计循环队列：https://leetcode.cn/problems/design-circular-queue/submissions/533299335
二.正文 1.1题目描述 ​
1.2题目分析 ​
本题给了我们七个操作需求，需要我们将这些函数功能实现出来。
对于这道题，假如我们是使用数组来实现队列，在这里我们可以事先模拟走一下：
​
那么我们如何解决这个问题呢。在这里我们我们可以通过多创建一个空间的方式解决这个问题。
​
（1）定义栈的结构 typedef struct { int* a;//a是int*类型的数组 int k;//k代表了我们的数组长度 int head;//head会指向我们的头元素（head在这里不是指针，可以当成另类的下标） int tail;//tail在我们数据的后一个位置（tail在这里不是指针，可以当成另类的下标） } MyCircularQueue; 假如k是4，数组有1，2，3，4这些数据。那么就有：
​
（2）创建我们的队列 MyCircularQueue* myCircularQueueCreate(int k) { MyCircularQueue* obj=(MyCircularQueue*)malloc(sizeof(MyCircularQueue)); obj-&gt;a=(int*)malloc(sizeof(int)*(k+1)); if(obj-&gt;a==NULL) { perror("malloc fail!"); } obj-&gt;k=k; obj-&gt;head=obj-&gt;tail=0; return obj; } 我们首先为我们的队列结构体申请了sizeof(MyCircularQueue)字节大小的空间。
然后又为了我们数组申请了sizeof(int)*(k+1)字节大小的空间。
用我们的结构体成员k接受形参k的值。
并让head，tail都初始化为0。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8742687503aef50b8d9ab7c2da7f082b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37abe98c7f89a9a47211dc677763c40c/" rel="bookmark">
			【设计模式】JAVA Design Patterns——Dependency Injection（依赖注入模式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔍目的 依赖注入是一种软件设计模式，其中一个或多个依赖项（或服务）被注入或通过引用传递到一个依赖对象（或客户端）中，并成为客户端状态的一部分。该模式将客户的依赖关系的创建与其自身的行为分开，这使程序设计可以松散耦合，并遵循控制反转和单一职责原则。
🔍解释 真实世界例子 老巫师喜欢不时地装满烟斗抽烟。 但是，他不想只依赖一个烟草品牌，而是希望能够互换使用它们
通俗描述 依赖注入将客户端依赖的创建与其自身行为分开。
维基百科 在软件工程中，依赖注入是一种对象接收其依赖的其他对象的技术。 这些其他对象称为依赖项。
程序示例 创建烟草接口和具体品牌的类：
public abstract class Tobacco { private static final Logger LOGGER = LoggerFactory.getLogger(Tobacco.class); public void smoke(Wizard wizard) { LOGGER.info("{} smoking {}", wizard.getClass().getSimpleName(), this.getClass().getSimpleName()); } } public class SecondBreakfastTobacco extends Tobacco { } public class RivendellTobacco extends Tobacco { } public class OldTobyTobacco extends Tobacco { } 创建老巫师的类
public interface Wizard { void smoke(); } public class AdvancedWizard implements Wizard { private final Tobacco tobacco; public AdvancedWizard(Tobacco tobacco) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37abe98c7f89a9a47211dc677763c40c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dd9cf780e000c9f5cc3500863c140c5/" rel="bookmark">
			深度解读ChatGPT：揭开人工智能聊天机器人的神秘面纱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：未来已来，AI聊天机器人ChatGPT火爆出圈 近来，一个名叫ChatGPT的人工智能（AI）聊天机器人突然爆火出圈，引起了全球的广泛关注和热议。它可以写代码、写诗歌、写论文，甚至能通过专业资格考试。ChatGPT的强大功能令人惊叹，也引发了人们对AI技术发展的无限遐想。
那么，ChatGPT究竟是什么？它的背后蕴含着怎样的技术原理？它将如何改变我们的生活？本文将带您深入浅出地了解ChatGPT的基本原理，揭开这款AI聊天机器人的神秘面纱。
第一章：ChatGPT的前世今生——从GPT到GPT-3.5 ChatGPT是OpenAI公司开发的一款AI聊天机器人，其名称中的"GPT"代表"Generative Pre-trained Transformer"，是一种强大的语言模型。GPT模型的进化历程可以追溯到以下几个关键节点：
GPT-1: 2018年，OpenAI发布了第一个GPT模型，它可以在大规模文本数据上进行预训练，并生成连贯的文本。GPT-2: 2019年，GPT-2问世，其生成的文本质量有了显著提升，甚至可以生成以假乱真的新闻报道，引发了人们对AI技术滥用的担忧。GPT-3: 2020年，GPT-3横空出世，其参数量达到了惊人的1750亿，使其在文本生成、翻译、问答等任务上表现出了更强大的能力。GPT-3.5: 2022年，OpenAI在GPT-3的基础上进行了优化和改进，推出了GPT-3.5，也就是我们现在所熟知的ChatGPT背后的核心模型。 第二章：ChatGPT的核心——Transformer架构 ChatGPT之所以如此强大，得益于其背后的核心技术——Transformer架构。Transformer是一种神经网络架构，于2017年由Google的研究人员提出，最初用于机器翻译任务。但由于其卓越的性能，Transformer很快被广泛应用于自然语言处理的各个领域。
Transformer架构的核心是自注意力机制（self-attention）。自注意力机制允许模型在处理文本时，对不同位置的词语赋予不同的权重，从而捕捉词语之间的关系。例如，在句子"我喜欢吃苹果"中，"我"和"喜欢"之间的关系比"我"和"苹果"之间的关系更密切，自注意力机制可以很好地捕捉到这种关系。
除了自注意力机制，Transformer还采用了编码器-解码器结构。编码器负责将输入的文本转换为隐藏表示，解码器则根据隐藏表示生成输出文本。这种结构使得Transformer在处理长文本时具有更高的效率。
第三章：ChatGPT的训练——从预训练到微调 ChatGPT的训练过程可以分为两个阶段：预训练和微调。
预训练： 在预训练阶段，ChatGPT被"喂"以海量的文本数据，学习语言的语法、语义和知识。这个阶段的目标是让ChatGPT掌握语言的一般规律。微调： 在微调阶段，ChatGPT会接受特定任务的训练，例如对话生成、文本摘要、机器翻译等。这个阶段的目标是让ChatGPT在特定任务上表现出色。 在微调阶段，OpenAI采用了人类反馈强化学习（RLHF）技术。RLHF让ChatGPT与人类进行交互，从人类的反馈中学习如何生成更符合人类期望的回答。这种技术使得ChatGPT能够更好地理解人类的意图，生成更自然、更流畅的对话。
第四章：ChatGPT的应用——无所不能的AI助手 ChatGPT的强大功能使其在各个领域都具有广泛的应用前景：
聊天机器人： ChatGPT可以生成流畅、自然的对话，为用户提供信息、娱乐、情感支持等服务。文本生成： ChatGPT可以生成各种类型的文本，包括文章、诗歌、代码、电子邮件等。机器翻译： ChatGPT可以实现高质量的机器翻译，打破语言障碍。问答系统： ChatGPT可以回答用户提出的各种问题，帮助用户获取信息。…… 随着ChatGPT技术的不断发展，我们可以预见，它将在更多领域发挥重要作用，成为我们生活中不可或缺的AI助手。
第五章：ChatGPT的未来——机遇与挑战并存 ChatGPT的问世，为我们描绘了AI技术的美好前景。然而，机遇与挑战并存，ChatGPT的发展也面临着一些问题：
模型偏见： ChatGPT的训练数据可能存在偏见，导致其生成的文本也带有偏见。安全风险： ChatGPT可能被滥用于生成虚假信息、垃圾邮件等。伦理问题： ChatGPT的应用可能涉及到隐私、就业等伦理问题。 为了解决这些问题，OpenAI采取了一系列措施，包括改进训练数据、引入安全机制、加强与研究社区的合作等。我们相信，随着技术的进步和社会共识的形成，ChatGPT将在造福人类的同时，最大限度地降低风险。
结语：ChatGPT，开启AI新篇章 ChatGPT的出现，标志着AI技术发展进入了一个新的篇章。它让我们看到了AI在自然语言处理领域的巨大潜力，也让我们对AI的未来充满了期待。我们有理由相信，ChatGPT将不断进化，为我们带来更多惊喜。让我们共同见证ChatGPT创造的奇迹，共同迎接AI时代的到来！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bba9d2861adacde8d39977695cf624af/" rel="bookmark">
			网上书城|基于SprinBoot&#43;vue的网上书城管理系统(源码&#43;数据库&#43;文档)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上书城管理系统
目录
基于SprinBoot+vue的网上书城管理系统
一、前言
二、系统设计
三、系统功能设计 1系统功能模块
2管理员功能模块
3用户后台功能模块
四、数据库设计
五、核心代码 六、论文参考
七、最新计算机毕设选题推荐
八、源码获取：
博主介绍：✌️大厂码农|毕设布道师，阿里云开发社区乘风者计划专家博主，CSDN平台Java领域优质创作者，专注于大学生项目实战开发、讲解和毕业答疑辅导。✌️
主要项目：小程序、SpringBoot、SSM、Vue、Html、Jsp、Nodejs等设计与开发。
🍅文末获取源码联系🍅
基于SprinBoot+vue的网上书城管理系统 一、前言 网上书城管理系统具有网上书城信息管理功能的选择。网上书城管理系统采用java技术，基于springboot框架，mysql数据库进行开发，实现了首页、个人中心、用户管理、图书类型管理、图书分类管理、图书信息管理、我的收藏管理、系统管理、订单管理等内容进行管理，本系统具有良好的兼容性和适应性，为用户提供更多的网上书城信息，也提供了良好的平台，从而提高系统的核心竞争力。
本文首先介绍了设计的背景与研究目的，其次介绍系统相关技术，重点叙述了系统功能分析以及详细设计，最后总结了系统的开发心得。
关键词：java技术；网上书城管理系统；mysql
二、系统设计 系统确定了各项需求，完成了系统的分析和数据库的设计，它就可以根据网站的特点决定网站的发展模式，才能实现代码。通过对网站的分析，这个网站是属于一个小项目，所完成的功能相对简单，就是对数据的基本操作。从而决定采用B/S开发模式。该模型的基本过程是：当用户访问网站的浏览器，或从用户向服务器发送请求时，通过接收请求，然后调用数据访问逻辑运算如比，将结果返回给将结果返回到用户通过浏览器。
三、系统功能设计 1系统功能模块 网上书城管理系统，在系统首页可以查看首页、图书信息、公告资讯、个人中心、后台管理、购物车等内容进行详细操作，如图5-1所示。
图5-1系统首页界面图
用户注册，在用户注册页面通过填写用户名、密码、姓名、邮箱、手机等信息完成用户注册，如图5-2所示。
图5-2用户注册界面图
2管理员功能模块 管理员登录系统，管理员通过输入用户名、密码，选择角色并点击登录进行系统登录操作，如图5-6所示。
图5-6管理员登录界面图
3用户后台功能模块 用户登录进入系统后台，可以对首页、个人中心、我的收藏管理、订单管理等功能进行相应操作，如图5-14所示。
图5-14用户后台功能界面图
四、数据库设计 用户注册实体图如图4-1所示：
图4-1用户注册实体图
数据库表的设计，如下表：
表4-1：配置文件
字段名称
类型
长度
字段说明
主键
默认值
id
bigint
主键
主键
name
varchar
100
配置参数名称
value
varchar
100
配置参数值
五、核心代码 package com.service.impl; import com.utils.StringUtil; import com.service.DictionaryService; import com.utils.ClazzDiff; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bba9d2861adacde8d39977695cf624af/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/333/">«</a>
	<span class="pagination__item pagination__item--current">334/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/335/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>