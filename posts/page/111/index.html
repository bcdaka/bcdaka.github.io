<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b95fabea99fa6556e079ae5169f86465/" rel="bookmark">
			将YOLOv8模型从PyTorch的.pt格式转换为TensorRT的.engine格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TensorRT是由NVIDIA开发的一款高级软件开发套件(SDK)，专为高速深度学习推理而设计。它非常适合目标检测等实时应用。该工具包可针对NVIDIA GPU优化深度学习模型，从而实现更快、更高效的运行。TensorRT模型经过TensorRT优化，包括层融合(layer fusion)、精度校准(precision calibration)(INT8和FP16)、动态张量内存管理和内核自动调整(kernel auto-tuning)等技术。将深度学习模型转换为TensorRT格式可充分发挥NVIDIA GPU的潜力。
TensorRT可兼容各种模型格式，包括TensorFlow、PyTorch和ONNX。
TensorRT模型的主要特点：
(1).Precision Calibration：TensorRT支持精度校准，允许根据特定的精度要求对模型进行微调(fine-tuned)。这包括对INT8和FP16等精度较低的格式的支持，这可以在保持可接受的精度水平的同时进一步提高推理速度。
(2).Layer Fusion：TensorRT优化过程包括层融合，即将神经网络的多个层组合成一个操作。这通过最小化内存访问和计算来减少计算开销并提高推理速度。
(3).Dynamic Tensor Memory Management：TensorRT可有效管理推理过程中的张量内存使用情况，从而减少内存开销并优化内存分配。这可提高GPU内存利用率。
(4).Automatic Kernel Tuning：TensorRT采用自动内核调整，为模型的每一层选择最优化的GPU内核。这种自适应方法可确保模型充分利用GPU的计算能力。
TensorRT中的部署选项：
(1).Deploying within TensorFlow：此方法将TensorRT集成到TensorFlow中，使优化的模型可以在TensorFlow环境中运行。对于混合了受支持层和不受支持的层(a mix of supported and unsupported layers)的模型，此方法非常有用，因为TF-TRT可以高效处理这些层。
(2).Standalone TensorRT Runtime API：提供精细控制，非常适合性能关键型应用程序。它更复杂，但允许自定义实现不受支持的运算符。
(3).NVIDIA Triton Inference Server：支持各种框架模型的选项。它特别适合云端或边缘端推理(cloud or edge inference)，提供并发模型(concurrent model)执行和模型分析等功能。
训练生成TensorRT支持的.engine格式模型：
训练代码如下所示：
import argparse import colorama from ultralytics import YOLO import torch def parse_args(): parser = argparse.ArgumentParser(description="YOLOv8 train") parser.add_argument("--yaml", required=True, type=str, help="yaml file") parser.add_argument("--epochs", required=True, type=int, help="number of training"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b95fabea99fa6556e079ae5169f86465/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a47b1f09f7f1f1d91d67c77aa0e7d37a/" rel="bookmark">
			uni-app全局文件与常用API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 rpx响应式单位@import导入css样式及scss变量用法与static目录import导入css样式uni.scss变量用法 pages.json页面路由globalStyle的属性pages设置页面路径及窗口表现tabBar设置底部菜单选项及iconfont图标 vite.config中安装插件unplugin-auto-import自动导入vue和uniappuni-api交互反馈uni.showToastuni.hideToastuni.showLoadinguni.showModaluni.showActionSheet 动态设置页面导航栏样式uni.setNavigationBarTitleuni.setNavigationBarColoruni.showNavigationBarLoadinguni.hideHomeButton 动态设置TabBar样式uni.setTabBarItemuni.setTabBarStyleuni.hideTabBaruni.showTabBaruni.setTabBarBadgeuni.removeTabBarBadgeuni.showTabBarRedDotuni.hideTabBarRedDot 下拉刷新 onPullDownRefreshuni.startPullDownRefresh(OBJECT)uni.stopPullDownRefresh() 页面和路由uni.navigateTo(OBJECT)uni.reLaunch(OBJECT)uni.navigateBack(OBJECT) StorageSync数据缓存APIuni.setStorageuni.setStorageSync(KEY,DATA)uni.getStorageuni.getStorageSync(KEY)uni.getStorageInfouni.getStorageInfoSync()uni.removeStorage(OBJECT)uni.removeStorageSync(KEY)uni.clearStorage()uni.clearStorageSync() 网络uni.request发起网路请求3种回调结果调用uni.request参数datamethod有效值headertimeout rpx响应式单位 rpx 即响应式 px，一种根据屏幕宽度自适应的动态单位。以 750 宽的屏幕为基准，750rpx 恰好为屏幕宽度。也就是说，在拿到设计稿后，要把稿件宽度等比缩放为750，再测量各区域的大小。在MasterGo，即时设计中都有相应的功能。
@import导入css样式及scss变量用法与static目录 import导入css样式 之前都是在页面中定义CSS，现在再介绍两种写入css样式的方法。
一种是在主组件app.vue中定义页面的公共css，这样定义可以作用于整个程序，但它的权重是最低的。
还有一种方法是，把这些css都放到一个公共的目录common中去：
先创建common目录：选中项目-新建-目录
新建好后，可以在里面创建.css文件，就可以在里面设置CSS样式了，最后，去app.vue的style中导入这个css样式，代码如下：
&lt;style lang="scss"&gt; @import "@/common/css/style.css"; &lt;/style&gt; 效果跟在公共css中写入是一样的，这种写法使整个程序更有条理些。
uni.scss变量用法 在项目根目录中有个uni.scss文件
打开后，里面有很多内置的样式变量，可以直接拿来用的，现在拿个文字颜色过来试试，注意只需要取"$“至”:" 前的内容即可
放到Style中，就可以正常使用了：
&lt;style lang="scss" scoped&gt; .layout{ font-size: 70rpx; color: $uni-color-primary; } &lt;/style&gt; 我们也可以在uni.scss中自己自定义样式的，模仿它的格式，比如像这样，记住要以$符号开头：
$custom-color-1:blue; $custom-color-2:yellow; 这里要注意的是，uni.scss是预编译的，在我们自定义后，需要重启一下，才可以使用自定义的样式。
可以给自定义的样式单独创建一个scss文件，然后再去在uni.scss中引入：
@import"@/common/scss/self.scss" ; pages.json页面路由 globalStyle的属性 pages.json 文件用来对 uni-app 进行全局配置，决定页面文件的路径、窗口样式、原生的导航栏、底部的原生tabbar 等。打开pages.json，这是globalStyle区域的代码，在其中也是可以配置单个页面的，单个页面的权重是大于globalStyle，下面是备注过的代码：
{ "pages": [ { "path": "pages/index/index", "style": { "navigationBarTitleText": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a47b1f09f7f1f1d91d67c77aa0e7d37a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2683d76dd43c0c62401bd45852fc0c52/" rel="bookmark">
			探索算法系列 - 双指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
移动零（原题链接）
复写零（原题链接）
快乐数（原题链接）
盛最多水的容器（原题链接）
有效三角形的个数（原题链接）
查找总价格为目标值的两个商品（原题链接）
三数之和（原题链接）
四数之和（原题链接）
移动零（原题链接） 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
请注意 ，必须在不复制数组的情况下原地对数组进行操作。
解题思路
定义两个指针 cur 和 dest。cur 用于遍历整个数组。dest 指向下一个非零元素应该放置的位置。初始化 dest 为 -1，这是因为我们需要在第一次找到非零元素时将其值赋给 dest 并且增加 dest 的值。 步骤说明
初始化：
cur 从0开始。dest 从-1开始（表示还没有遇到非零元素）。 遍历数组：
使用循环遍历整个数组 nums。对于数组中的每一个元素 nums[cur]，检查它是否是非零元素。 如果 nums[cur] 不为0，则执行以下操作： 将 dest 加1。交换 nums[dest] 和 nums[cur] 的值。 结束条件：
当 cur 遍历完整个数组后，循环结束。 结果：
所有的非零元素都已经被移动到了数组的前半部分，并保持了原有的顺序。所有的0元素都被移动到了数组的后半部分。 具体代码
class Solution { public: void moveZeroes(vector&lt;int&gt;&amp; nums) { for (int cur = 0, dest = -1; cur &lt; nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2683d76dd43c0c62401bd45852fc0c52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99a34ff605a89f955b1f349e525ec427/" rel="bookmark">
			Linux中的三类读写函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件IO和标准IO的区别 遵循标准： 文件IO遵循POSIX标准，主要在类UNIX环境下使用。标准IO遵循ANSI标准，具有更好的可移植性，可以在不同的操作系统上重新编译后运行。可移植性： 文件IO的可移植性相对较差，因为它与系统底层紧密相关。标准IO的可移植性较好，因为它是C语言标准库的一部分，可以在不同的操作系统上移植使用。操作方式： 文件IO通过系统调用来直接读写文件，每次操作都会触发系统调用。标准IO在内部实现了缓冲机制，通过文件流指针来操作文件，减少了系统调用的次数，提高了性能。缓冲机制： 文件IO通常不带缓冲，每次读写操作都会直接与系统底层交互。标准IO带缓冲，先将数据写入缓冲区，再选择合适时机将缓冲区中的数据写入文件或从文件中读取数据到缓冲区。访问的文件类型： 文件IO可以访问不同类型的文件，包括普通文件、设备文件、管道文件和套接字文件等。标准IO主要用于访问普通文件，虽然也可以重定向到其他类型的设备，但其本质还是通过文件流指针来操作文件。使用的接口： 文件IO使用如open、read、write、close等系统调用接口。标准IO使用如fopen、fread、fwrite、fclose等C标准库函数接口。 Linux标准文件描述符
我们使用printf和write都可以输出正常的字符串
当我们给程序加上一条死循环的程序，就会发现用printf()不能继续执行，而用write可以继续执行。
这个原因就是因为缓存问题，见下文
缓存的概念
1.我们的程序中的缓存，就是你想从内核读写的缓存（数组）----用户空间的缓存
2.每打开一个文件，内核在内核空间中也会开辟一块缓存，这个叫内核空间的缓存
文件IO中的写即是将用户空间中的缓存写到内核空间的缓存中。
文件IO中的读即是将内核空间的缓存写到用户空间中的缓存中。
3.标准IO的库函数中也有一个缓存，这个缓存称为----库缓存
C库缓存的特点：
1.遇到\n 时，会将库缓存的内容写到内核缓存中，即调用了系统调用函数。
2.库缓存写满时，会调用系统调用函数，将库缓存内容写到内核缓存中。当写满时，即1024字节
关于上面的问题，使用write函数就是文件IO，它可以直接将用户空间（我们给文件的数据）写道内存空间中，当我们使用C库printf时，他不会直接调用而是等待写满才会系统调用函数将库缓存写道内核缓存中，为了使能够输出我们给文件的数据（hello world），我们可以在输入后面加一个\n使其成功打印（还是和正常输出略有不同）
三类读写缓存 fputs函数 属于C语言标准库函数，用于将一个字符串写入到指的头文件中，写入成功后光标会移到写入的最后一个字符
函数原型
int fputs(const char *str, FILE *stream);
str：指向要写入文件的字符串的指针。stream：指向FILE对象的指针，该FILE对象标识了要写入数据的文件流。 fputs函数将str指向的字符串写入到stream指定的文件流中，但不包括空字符（'\0'）。如果写入成功，fputs返回一个非负整数；如果发生错误，则返回EOF。
fgets函数 用于从指定的文件流中读取一行，使用 fgets 可以很方便地从文件或者标准输入（如键盘）读取字符串，直到遇到换行符或文件结束符，或者达到指定的字符数。
函数原型：
char *fgets(char *str, int n, FILE *stream);
str：指向一个字符数组的指针，用来存储读取到的字符串。n：指定最多读取的字符数，包括最后的空字符（\0），因此实际上最多能读取 n-1 个字符。stream：指定从哪个文件流中读取数据。 返回值
成功时，返回 str。失败或到达文件末尾时，返回 NULL。 注意文件的权限，应该是w+，可读可写！！！！
fflush函数 用于刷新缓冲区，
fflush函数用于将给定的输出流或更新流stream的缓冲区中的数据强制写入到对应的文件或设备中。如果stream指向的是一个输出流或者是一个最近一次操作不是输入的更新流，则fflush会将缓冲区中未写入的数据写入到流指向的文件或设备中。如果stream是空指针（NULL），则fflush会对所有打开的文件流执行刷新操作。 函数原型
int fflush(FILE *stream);
返回值：
成功时，fflush返回0。如果发生错误，则返回EOF，并且设置相应的错误标识符。 第一种：刷新标准输出缓冲区
fflush(stdout)确保printf函数输出的内容立即被写入到标准输出设备（通常是屏幕）上。
第二种：刷新文件流缓冲区
在这个例子中，fflush(file)确保通过fprintf函数写入到file指向的文件中的数据被立即写入到磁盘上。注意，虽然在这个例子中fflush的调用是可选的（因为关闭文件时会自动刷新缓冲区）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99a34ff605a89f955b1f349e525ec427/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9b7c30cde1bed26697ff83e6305dbf9/" rel="bookmark">
			前后端分离的开发模式&#43;YAPI接口文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博客主页：音符犹如代码系列专栏：JavaWeb关注博主，后期持续更新系列文章如果有错误感谢请大家批评指出，及时修改感谢大家点赞👍收藏⭐评论✍ 早期的开发模式：前后端混合开发 在这种模式下开发下，开发的工作人员在开发一个项目的时候他既要使用前端的技术栈来开发前端的功能也需要使用Java技术栈来编写后端的功能实现还要来操作数据库。如此页面的生成和数据的处理在同一个代码文件中完成。
其特点包括：
代码混乱：前端与后端的业务逻辑代码混杂在一起，导致代码可读性和可维护性较差。
开发效率低：前后端开发人员需要紧密协作，在同一个代码库中工作，容易产生冲突和协调问题，影响开发效率。
技术栈受限：由于前后端混合，可能会受到所选后端技术的限制，无法灵活选择最适合前端的技术和框架。
部署复杂：整个应用作为一个整体进行部署，增加了部署的复杂性和风险。
难以扩展：当业务增长需要对前后端进行分别扩展和优化时，由于代码的紧密耦合，会变得非常困难。
当前最主流的开发模式：前后端分离
前端主要负责：
用户界面的设计和开发，使用 HTML、CSS 和现代的前端框架（如 Vue、React、Angular 等）构建美观、交互性强的页面。处理用户的交互操作，通过 JavaScript 实现各种动态效果和逻辑。向后端发送请求获取数据，并将获取的数据进行展示和处理。 后端主要负责：
提供数据接口，接收前端的请求，进行数据处理和业务逻辑的实现。与数据库进行交互，存储和获取数据。保障系统的安全性、稳定性和性能优化。 给大家画一个图方便大家更好的了解前后端混合的开发模式
给大家推荐一个接口的平台：YAPI 官方地址：YApi Pro-高效、易用、功能强大的可视化接口管理平台
YAPI 是一个可本地部署的、可视化的、用于管理接口文档和进行接口测试的开源平台。
它具有以下主要特点和功能：
接口文档管理：支持详细地记录接口的请求方法、URL、参数、请求头、响应示例等信息，方便开发人员查看和理解接口的规范。
团队协作：允许多个团队成员共同编辑和维护接口文档，方便团队内的沟通和协作。
接口测试：可以直接在平台上对接口进行测试，输入请求参数后发送请求，并查看响应结果，便于快速验证接口的功能。
数据 Mock：能够模拟接口的返回数据，方便前端在后端接口未完成时进行开发和调试。
权限管理：可以为不同的用户设置不同的权限，保障接口文档和数据的安全性。
自动化：支持与一些持续集成和部署工具集成，实现接口文档的自动化更新。
使用 YAPI 可以提高开发团队的协作效率，保证接口的质量，减少因为接口不一致而导致的开发问题。
如何使用YAPI： 添加项目添加分类添加接口 在这里添加接口写入接口的名称和接口路径
我们在这个导入json中写入json格式的数据，写好后打开Moc地址
但是这里的数据是混乱的所以我们需要在高级的Moc地址中添加期望，在这里更换我们准确的数据值
添加期望后我们的数据值就是对的了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1e447cbcb23bd60277f5e0a13d9d8d8/" rel="bookmark">
			Apache ShardingSphere Proxy5.5.0实现MySQL分库分表与读写分离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前提准备 1.1 主机IP:192.168.186.77 version: '3.8' services: mysql-master: image: mysql:latest container_name: mysql-master environment: MYSQL_ROOT_PASSWORD: 123456 MYSQL_USER: master MYSQL_PASSWORD: 123456 MYSQL_DATABASE: db1 ports: - "3306:3306" volumes: - mysql-master-data:/var/lib/mysql command: --server-id=1 --log-bin=mysql-bin --binlog-format=ROW cap_add: - SYS_NICE security_opt: - seccomp:unconfined mysql-slave: image: mysql:latest container_name: mysql-slave environment: MYSQL_ROOT_PASSWORD: 123456 MYSQL_USER: slave MYSQL_PASSWORD: 123456 MYSQL_DATABASE: db1 ports: - "3307:3306" volumes: - mysql-slave-data:/var/lib/mysql command: --server-id=2 --log-bin=mysql-bin --binlog-format=ROW --relay-log=relay-bin --relay-log-index=relay-bin.index depends_on: - mysql-master cap_add: - SYS_NICE security_opt: - seccomp:unconfined volumes: mysql-master-data: mysql-slave-data: 注：3306端口扮演master数据库角色，3307端口扮演salve数据库角色。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1e447cbcb23bd60277f5e0a13d9d8d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06914f5e60fd5c0bec12c5bcd3b4fa65/" rel="bookmark">
			[240725] X-CMD 发布 v0.4.2：引入 hua 模块，在终端中阅读古文诗词 | MySQL 发布 9.0 | Docker 引擎爆出 AuthZ 插件绕过漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 X-CMD 发布 v0..4.2✨ hua✨ elv MySQL 发布 9.0一、mysql 9.0.0 的新特性二、MySQL 9.0 中已弃用/删除的功能三、其他更新 Docker 引擎爆出 AuthZ 插件绕过漏洞（CVE-2024-41110） X-CMD 发布 v0…4.2 ✨ hua 新增
中国古诗文阅读模块 hua, 可以使用 x hua 快速查阅唐诗、宋词、楚辞等文章。 ✨ elv 更新
x elv --setup 新增了 all、mod、rc 子命令，可以选择不同程度地将 x-cmd 注入 elvish 环境，实现自由灵活的配置。 升级指南：
# 可以直接用安装脚本 eval "$(curl https://get.x-cmd.com)" ​ # 已安装 x-cmd 的用户则可通过 upgrade 指令触发更新 x upgrade 感谢你对 x-cmd 的支持！ 😊
MySQL 发布 9.0 Oracle 在 7 月初推出了 MySQL 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06914f5e60fd5c0bec12c5bcd3b4fa65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/085d4646492ef9cf241bdc68e29fbb1b/" rel="bookmark">
			Excel基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、移动输入：
enter 下移
shift+enter 上移
tab 右移
shift+tab 左移
（也可以按键盘的上下左右键）
2、行高列宽调整：
鼠标放在标题栏序号的间隙，变成黑色的左右箭头时，
长按鼠标左键可拖动，双击则是自动调整
3、文字居中：
先选中文字，shift连选，ctrl加选，
开始-&gt;对齐方式-&gt;合并后居中，或者选择图标居中
4、快速填充：
填充序号：向下拖动单元格右下角+号，最后选择填充序列
公式填充：先填写一个单元格，然后双击单元格右下角+号
5、计算
公式计算：
点击单元格，上方的公式编辑栏中输入“=D4*E4”（示例），回车即可。（一定要加=号）
求和计算：
点击答案单元格，选择求和，确认求和区域正确后，按回车即可。
6、货币、分数、时间等格式：
选中单元格，开始-&gt;数字格式
7、表格打印：
ctrl+P
开始-&gt;字体-&gt;边框图标，可以添加表格线
esc退出画笔、橡皮擦功能
8、插入行或列：
标题行选中一行或一列，右键选择插入。fn+f4重复操作
或者直接选中多行或多列，再右键插入。
9、快速选择：
ctrl+上下左右，可以快速选中四个角
ctrl+shift+上下左右，可以全选内容区域
点击左上角的三角形，选中所有
10、移动内容：
剪切移动：箭头变成移动光标后，直接拖动
复制移动：长按ctrl并拖动
剪切移动并插入其他行或列中：长按shift并拖动
11、删除重复项：
选中区域，数据-&gt;删除重复值
12、表格转置：
复制表格，开始-&gt;选择性粘贴-&gt;转置粘贴
13、表格对角线：
开始-&gt;字体-&gt;边框图标-&gt;绘制边框，画笔沿对角线画一下，最后再次点击边框图标退出即可。
或者鼠标右键，选择设置单元格格式-&gt;边框-&gt;对角线，最后确认即可。
14、换行输入：
alt+shift
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12011f1a91df021184ac017699d78995/" rel="bookmark">
			【AIGC】Llama-3 官方技术报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Llama-3 技术报告（中文翻译） 欢迎关注【youcans的AGI学习笔记】原创作品
0. 简介 现代人工智能（AI）系统的核心驱动力来自于基础模型。
本文介绍了一组新的基础模型，称为 Llama 3。它是一个语言模型系列，原生支持多语言性、编码、推理和工具使用。
其中，我们所构建的最大模型是一个密集型的Transformer架构，拥有4050亿个参数，能够处理高达12k tokens的上下文窗口。
本文提供了对Llama 3的广泛实证评估。我们发现，在众多任务中，Llama 3的表现质量与诸如GPT-4这样的领军语言模型相当。我们公开发布了 Llama 3，包括405B 参数语言模型的预训练和后训练版本，以及用于输入和输出安全的 Llama Guard 3 模型。
本文还介绍了我们通过组合方法将图像、视频和语音功能集成到 Llama 3 中的实验结果。我们观察到这种方法在图像、视频和语音识别任务上的表现与最先进的方法不相上下。由于模型仍在开发中，因此尚未广泛发布。
Llama3 简介：
模型：llama 3.1 模型系列：405B（含量化版）、70B、8B， 128k的上下文工具：开源配套的Agent系统网站：https://llama.meta.com/日期: July 23,2024 Llama3的卓越表现源于三大核心要素：
高质量数据：15T tokens的高质量多语言数据。规模性：8B、70B、405B的模型矩阵，通过大模型提升小模型的质量，实现同类最佳效果。简洁性：选择Transformer架构而非MoE架构，采用相对简单的后训练程序，如SFT、RS和DPO，而非复杂的强化学习算法。
报告还分享了Llama3在多模态集成方面的初步实验，展现了其在图像、视频和语音处理方面的潜力。 Llama3的开发历程：预训练与后训练
预训练：在15.6万亿token上预训练了4050亿参数的模型，上下文窗口为8K token。随后进行继续预训练，将上下文窗口扩展至128K token。后训练：通过多轮人类反馈与模型对齐，每轮包括监督式微调（SFT）和直接偏好优化（DPO）。后训练阶段还整合了工具使用等新能力，并在编码和推理等领域取得显著进展。 Llama3的多模态能力：图像、视频和语音的融合
为了赋予Llama3多模态能力，Meta采用了组合方法，引入了图像、视频和语音编码器。具体过程包括：
多模态编码器预训练：分别对图像和语音编码器进行训练，学习视觉和语音信号的表示。视觉适配器训练：将图像编码器融入预训练的语言模型，实现图像表示与语言表示的对齐。在此基础上，训练视频适配器，实现跨帧信息聚合。语音适配器训练：将语音编码器整合到模型中，实现高质量的语音理解。 Llama3 技术报告目录
引言：Llama3成功的三大要素、开发历程、多模态能力概述预训练
预训练数据：数据来源、清洗、去重、过滤等
模型架构：Transformer架构选择、参数设置等
规模定律实验：模型规模对性能的影响
基础设施、扩展和效率：训练硬件、并行策略、优化技巧等
训练方法：初始预训练、长上下文预训练、退火等后期训练
建模：SFT、RM、DPO等技术
后期训练数据：清洗、修剪等
Chat能力：代码、多语言、数学和推理、长文本、工具调用能力，以及如何减少幻觉等效果评估
Base模型：benchmark指标、鲁棒性、对抗性和污染分析
Chat模型：通用知识和指令遵循benchmark指标、人类考试GRE/LSAT/SAT/AP/GMAT等、单项技能测试
人类评估：在几乎所有能力上，Llama 3 405B和GPT-4的胜利率在误差范围内
安全性评估：安全评估基准、预训练和微调效果等推理
流水线并行：推理加速技术
FP8量化：模型量化技术视觉实验
数据：图像和视频数据处理
模型架构：图像编码器、图像适配器、视频适配器语音实验
数据：语音数据处理
模型架构：语音编码器、语音适配器相关工作结论贡献者和致谢 1. 引言 基础模型是语言、视觉、语音或其他模式的通用模型，旨在支持各种人工智能任务。它们构成了许多现代人工智能系统的基础。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12011f1a91df021184ac017699d78995/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc9fbbcabc626bd6d13e005ec5b599dc/" rel="bookmark">
			【数据结构】建堆算法复杂度分析及TOP-K问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【数据结构】建堆算法复杂度分析及TOP-K问题 🔥个人主页：大白的编程日记
🔥专栏：数据结构
文章目录 【数据结构】建堆算法复杂度分析及TOP-K问题前言一.复杂度分析1.1向下建堆复杂度1.2向上建堆复杂度1.3堆排序复杂度 二.TOP-K问题2.1思路分析2.2代码实现 后言 前言 哈喽，各位小伙伴大家好！上期我们讲了堆排序和建堆算法。今天我们就来分析一下他们的时间复杂度。话不多说,咱们进入正题。向大厂冲锋!
一.复杂度分析 我们都知道堆是一个完全二叉树。那他的高度h和节点数量N有什么关系呢？
那我们再来对比一下满二叉树和完全二叉树的高度h.
我们用大O渐进表示法看的话他们两个的高度h都可以认为是logN的量级
所以我们的堆的上下调整可以认为是logN，也就是高度次。
因为堆是完全二叉树，而满二叉树也是完全二叉树，所以为了方便证明
我们使用满二叉树来证明(时间复杂度本来看的就是近似值，多几个结点不影响最终结果)：
1.1向下建堆复杂度 我们先分别算出第一层到h-1层的节点个数和该层节点的调整次数
然后再推出总的调整次数。
推导
1.2向上建堆复杂度 我们先分别算出第2层到h层的节点个数和该层节点的调整次数
然后再推出总的调整次数。
推导
所以向下建堆的时间复杂度是O(N),向上建堆的复杂度是O(N*logN).
所以以后我们都尽量使用向下调整建堆。因为他的效率更高。
1.3堆排序复杂度 现在我们来看一下我们堆排序的时间复杂度是多少呢？
推导
堆排序的复杂度是O(N*logN). 二.TOP-K问题 2.1思路分析 我们的堆除了可以用来排序还可以用来解决经典的TOP-K问题。
TOP-K问题：即求数据结合中前K个最大的元素或者最小的元素，一般情况下数据量都比较大。
比如：专业前10名、世界500强、富豪榜、游戏中前100的活跃玩家等。
方法一
我们很容易想到直接排序然后取出前K个即可。
但是这个方法有个致命缺陷。
如果数据量非常大，排序就不太可取了(可能数据都不能一下子全部加载到内存中)。
我们发现这个方法在数据量太大的时候并不适用。
那有什么其他好的方法吗？方法二
最佳的方式就是用堆来解决，基本思路如下：
1 .用数据集合中前K个元素来建堆
前k个最大的元素，则建K个数的小堆
前k个最小的元素，则建K个数的大堆
2 . 用剩余的N-K个元素依次与堆顶元素来比较，
如果比堆顶元素还要大或小(小堆大 大堆小)则替换堆顶元素，然后向下调整重新建堆。 将剩余N-K个元素依次与堆顶元素比完之后，堆中剩余的K个元素就是所求的前K个最小或者最大的元素。
为什么呢？
证明
我们通过N-K次比较就可以筛选出N-K个不满足最大前K个数的数
剩下在堆的数就是最大的前K个。疑问
我们用反证法可以得知这种情况不存在。
2.2代码实现 生成数据函数
我们先用srand生成不同的种子防止生成的随机数是伪随机数。
然后fopen打开文件。循环生成随机数然后写入文件即可。最后关闭文件。 void CreatData() { int n = 100000;//生成10万个数据 srand(time(0));//生成不同的种子 FILE* pf = fopen("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc9fbbcabc626bd6d13e005ec5b599dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e278f11a71f7152a572a5c0125de26d/" rel="bookmark">
			C语言：字符串函数、内存函数剖析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字符串函数、内存函数剖析 一、字符串函数（一）求字符串长度1、strlen（1）库函数实现（2）自定义实现 （二）长度不受限制的字符串函数1、strcpy（1）库函数实现（2）自定义实现 2、strcat（1）库函数实现（2）自定义实现 3、strcmp（1）库函数实现（2）自定义实现 （三）长度受限制的字符串函数介绍1、strncpy2、strncat3、strncmp （四）字符串查找1、strstr2、strtok （五）错误信息报告1、strerror2、prerror 二、内存操作函数（一）内存拷贝1、memcpy(1)库函数实现(2)自定义实现 2、memmove（1）库函数实现（2）自定义实现 （二）内存比较1、memcmp （三）内存设置1、memset（1）库函数实现 三、结束语 一、字符串函数 （一）求字符串长度 1、strlen （1）库函数实现 strlen用来计算字符串的长度,遇到’\0’读取结束，这里‘\0’不算作长度。
size_t strlen ( const char * str ); （2）自定义实现 自定义实现我们采取三种方式
//计数器实现 size_t my_strlen1(const char* str) { assert(str); int i = 0, count = 0; while (str[i]) { count += 1; i += 1; } return count; } //指针的实现 size_t my_strlen2(const char* str) { assert(str); const char* p = str; while (*p !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e278f11a71f7152a572a5c0125de26d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3147f59b2836c5690b0498e5214cd9d4/" rel="bookmark">
			IEEE-Trans系列：TIV“倒下”，这本1区Top势头正猛，CCF-B类，国人友好，年发文1500！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本周投稿推荐 SCI&amp;EI
• 1区计算机类，3.5-4.0（1个月录用）
• CCF推荐，1区-Top（3天初审）
EI
• 各领域沾边均可（2天录用）
知网（CNKI）、谷歌学术
• 7天录用-检索（百发百中，包检索）
SSCI
• 1区，2.0-3.0（1个月录用）
工程技术类 2024年7月23日，著名顶级期刊IEEE Transactions on Intelligent Vehicles（IEEE TIV）被On Hold的消息在全网闹得沸沸扬扬，今天小编推荐一本同样是IEEE-Trans系列的中科院1区顶级期刊，CCF-B类，含金量持续上升，众多作者推荐，下面不妨跟随小编一起看看它的表现！
1、期刊简介
出版社
IEEE
影响因子
7.5-8.0
期刊分区
JCR1区，中科院1区-Top
检索数据库
SCIE&amp;EI
数据库收录
年份
2000年
预警记录
无
自引率
13.90%
年发文量
近三年平均发文1437篇
国人占比
52.762%
• 征稿领域：有关运输系统领域的智能技术研究，包括理论方法、传感、通信、建模和仿真、数据安全、控制和监测、安全评估、基础设施建设等
• PS：期刊入选中国计算机学会CCF-B类推荐
2、影响因子
最新影响因子为7.5-8.0，影响因子一路攀升，期刊实力强劲
3、期刊分区
• 最新JCR分区为Q1，SCIE检索；
• 中科院大类分区：工程技术1区
• 中科院小类分区：工程：土木1区；工程：电子与电气2区；运输科技2区
• 是Top期刊
• 无中科院预警记录
4、自引率
最新自引率为13.90%，整体走势持续下降，中间略有起伏，总体看得出期刊对自身质量把控的重视，目前处于安全阈值内
5、年发文量
近三年发文量上升，年平均发文1437篇，对稿件的录用率有提高
6、国人占比
国人占比排名第一达到52.762%，发文审稿对国人友好
·END·
作为知名的IEEE出版社旗下Top期刊，其含金量不言而喻，为进一步扩大影响力，该刊的年发文量上涨，平均审稿周期3个月较为快速，相关领域作者评职首选，推荐！
更多好刊选刊资讯，关注公众号【Unionpub学术】不迷路~
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3147f59b2836c5690b0498e5214cd9d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3400890504e03df61a2a56c9efe7b2e5/" rel="bookmark">
			【C&#43;&#43;练级之路】【Lv.17】【STL】set类和map类的模拟实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快乐的流畅：个人主页 个人专栏：《C游记》《数据结构世界》《进击的C++》 远方有一堆篝火，在为久候之人燃烧！ 文章目录 引言一、红黑树（改造版）1.1 结点1.2 迭代器1.2.1 operator++1.2.2 operator- - 1.3 本体1.3.1 成员变量1.3.2 begin和end1.3.3 Find1.3.4 Insert 二、set2.1 成员变量与仿函数2.2 begin和end2.3 find2.4 insert 三、map3.1 成员变量与仿函数3.2 begin和end3.3 find3.4 insert3.5 operator[ ] 引言 STL库中的set类和map类，其底层原理都是通过红黑树来实现的。尽管set和map可以各自实现一棵红黑树，但是为了提高代码的复用率，STL库中将红黑树进行了一定的改造，实现以相同的底层实现不同的容器。
一、红黑树（改造版） 1.1 结点 enum Color { RED, BLACK }; template&lt;class T&gt; struct RBTreeNode { RBTreeNode&lt;T&gt;* _left; RBTreeNode&lt;T&gt;* _right; RBTreeNode&lt;T&gt;* _parent; T _data; Color _col; RBTreeNode(const T&amp; data) : _left(nullptr) , _right(nullptr) , _parent(nullptr) , _data(data) , _col(RED) {} }; 细节：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3400890504e03df61a2a56c9efe7b2e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78da129953aed4b4c16407e0f9902ec5/" rel="bookmark">
			OpenSSL学习笔记及在项目中的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenSSL官方命令手册：OpenSSL commands - OpenSSL Documentation
参考教程：
操作：OpenSSL的基本使用教程(一）_openssl.exe使用教程-CSDN博客
操作：Linux和Shell回炉复习系列文章总目录 - 骏马金龙 - 博客园 (cnblogs.com)
网站应用：最新OpenSSL简明教程_openssl使用教程-CSDN博客
概念 公钥和私钥 公钥：可以公开分享，用于加密数据或验证数字签名。私钥：必须保密，用于解密数据或创建数字签名。关系：公钥和私钥是成对出现的，使用公钥加密的数据只能由对应的私钥解密，反之亦然。 一个完整的RSA私钥包含了以下几个关键参数：
模数（Modulus，N）公钥指数（Public Exponent，e）私钥指数（Private Exponent，d）素数p（Prime 1，p）素数q（Prime 2，q）指数dp（Exponent 1，dp）指数dq（Exponent 2，dq）系数（Coefficient，qinv） 数字签名 数字签名使用私钥创建，确保数据的完整性和来源的真实性。验证签名使用公钥，可以确认数据是否被篡改，并且确认数据确实来自特定的私钥持有者。 数字证书 数字证书由受信任的证书颁发机构（CA）签发，包含公钥及其所有者的身份信息。证书用于验证公钥的真实性，确保其属于声明中的持有者。 对称加密和非对称加密 对称加密：使用相同的密钥进行加密和解密，例如 AES、DES。非对称加密：使用一对公钥和私钥进行加密和解密，例如 RSA。对称加密速度快，适合大数据量；非对称加密安全性高，适合小数据量。 证书链 证书链由一系列证书组成，确保最终用户证书的可信性。包括根证书（CA）、中间证书和最终用户证书。验证证书链时，必须从根证书到最终用户证书逐级验证。 常见文件后缀 .key：通常用于表示私钥或公钥文件。这个后缀比较通用，可以表示任何类型的加密密钥。 private.key（私钥），public.key（公钥）。
.pub:通常用于表示公钥文件。这个后缀明确指示文件包含公钥。id_rsa.pub（RSA 公钥），id_ecdsa.pub（ECDSA 公钥）。
.pri：通常用于表示私钥文件。虽然不是标准后缀，但一些系统或工具可能使用这个后缀来标识私钥文件。 private.pri。
.pem： PEM（Privacy Enhanced Mail）格式文件的标准后缀，通常用于存储证书、私钥、公钥和证书链。文件内容通常以 Base64 编码并用 “-----BEGIN CERTIFICATE-----” 等标头和尾标记。cert.pem（证书），private.pem（私钥），public.pem（公钥）。
.crt：通常用于表示 X.509 证书文件。这个后缀通常用于证书文件，格式可以是 PEM 或 DER。server.crt（服务器证书），ca.crt（CA 证书）。
.csr：用于表示证书签名请求（Certificate Signing Request）文件。CSR 文件包含申请证书时的必要信息。request.csr。
.der：DER（Distinguished Encoding Rules）格式文件的标准后缀，通常用于存储二进制编码的证书或密钥。不同于 PEM 格式，DER 文件是二进制格式，没有 Base64 编码。cert.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78da129953aed4b4c16407e0f9902ec5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd1ac996c6a7d4256047c806acbc9c93/" rel="bookmark">
			土耳其云手机提升TikTok电商效率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数字化飞速发展的今天，TikTok不仅是一个社交平台，更是一个巨大的电商市场。随着TikTok电商功能在全球范围内的扩展，土耳其的商家和内容创作者正面临着前所未有的机遇。本文将详细介绍土耳其云手机怎样帮助商家抓住机遇，实现业务增长。
土耳其云手机的独特优势
土耳其云手机是一种基于云端的虚拟设备，用户无需实际拥有物理手机即可在云端操作多个虚拟手机。通过这一技术，用户可以随时随地、在任何设备上轻松管理他们的业务，这为TikTok电商平台的应用提供了无限可能。
如何利用土耳其云手机提升TikTok电商效率？
多账户高效管理：在TikTok电商运营中，商家通常需要管理多个账户。土耳其云手机使用户能够在一个平台上无缝切换和操作多个账户，简化了复杂的管理流程，大幅提高了运营效率。
即时市场反馈：通过云手机的数据收集功能，商家可以实时监控TikTok上的市场动态，分析用户互动数据，迅速调整营销策略。无论是推出新产品还是进行促销活动，都能做到快速响应，确保始终处于市场前沿。
批量内容发布：在TikTok上，频繁发布高质量内容是吸引用户的关键。利用土耳其云手机，商家可以轻松实现批量上传视频和图片，保证内容发布的连续性和高效性，从而提高品牌曝光率。
本地网络和IP：土耳其云手机提供当地的网络和纯净IP，让用户即使身处国外也能轻松连接和登录土耳其TikTok。这种本地化的网络服务，不仅帮助商家实现精准引流，还能有效防止因IP不同导致的限流和封号问题。
增强数据安全：土耳其云手机采用先进的加密技术，确保用户数据和商业信息的安全。这不仅保护了商家的商业机密，也增强了消费者的信任，为长期的客户关系打下坚实基础。
土耳其云手机不仅是一项技术创新，更是推动商业发展的强大工具，利用土耳其云手机提升其业务竞争力，实现更大的商业成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c595456d88d875185b075d732e863218/" rel="bookmark">
			pytorch前馈神经网络--手写数字识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 具体内容就是：
输入一个图像，经过神经网络后，识别为一个数字。从而实现图像的分类。
资源：
https://download.csdn.net/download/fengzhongye51460/89578965
思路： 确定输入的图像：会单通道灰度的28*28的图像，
把图像平铺后，输送到784个神经元的输入层
输入层输送到隐藏层，提取特征
隐藏层输送到输出层，显示概率
初始化模型 import torch # Import PyTorch from torch import nn # Import the neural network module from PyTorch # Define the neural network class, inheriting from nn.Module class Network(nn.Module): def __init__(self): super().__init__() # Call the initializer of the parent class nn.Module self.layer1 = nn.Linear(784, 256) # Define the first linear layer (input size 784, output size 256) self.layer2 = nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c595456d88d875185b075d732e863218/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34a05ba5fca4d8672b0b095f73e414ec/" rel="bookmark">
			力扣69题 x的平方根 二分查找法（简单易懂）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		力扣69题 x的平方根 二分查找法（简单易懂） 文章目录 力扣69题 x的平方根 二分查找法（简单易懂）题目描述思路代码总结 题目描述 给你一个非负整数 x ，计算并返回 x 的 算术平方根 。
由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。
注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。
示例 1：
输入：x = 4
输出：2
示例 2：
输入：x = 8
输出：2
解释：8 的算术平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。
思路 可以用二分查找的方法 0-3进行if判断
用二分找到midmid小于x 但（mid+1）（mid+1）大于x的值
然后缩小区间
下面是代码
代码 class Solution { public int mySqrt(int x) { if (x == 0) return 0; if (x &lt;= 3) return 1; int left = 1, right = x / 2; while (left &lt;= right) { int mid = left + (right - left) / 2; // 直接定位 if (mid &lt;= x / mid &amp;&amp; (mid + 1) &gt; x / (mid + 1)) { return mid; } else if (mid &gt; x / mid) { right = mid - 1; } else { left = mid + 1; } } // 不会走到这里的 return 0; } } 总结 一种人一种写法 建议大家用自己的二分做来题 不要一味去模仿他人的二分 加油！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/461b18e2928e3c689add6167fe853673/" rel="bookmark">
			VSCode 命令行使用 git commit 无法输入中文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 问题描述 在使用 VSCode 的集成终端（Terminal）进行 git commit -m 'feat：xxx' 操作时，发现 xxx 的位置只能编写英文，无法输入中文或者输入中文后出现问题。
这通常与终端编码设置、VSCode 的配置或者操作系统设置有关。
2. 解决方案 1. 检查并设置终端编码 确保我们的终端支持 UTF-8 编码，因为 UTF-8 支持包括中文在内的多种语言。
1. 对于 Windows 用户，如果使用的是命令提示符（CMD），可能需要切换到 PowerShell 或 Windows Terminal（推荐），因为它们默认支持 UTF-8 编码。
2. 对于 macOS 和 Linex 用户，大多数现代 macOS 和 Linux 终端默认支持 UTF-8，因此通常不需要额外设置。如果使用的是 VSCode 的内置终端，确保它配置为使用 UTF-8 编码。
2. 检查 VSCode 设置 1. 打开 VSCode 的设置（Ctrl + ，或Cmd + ，）
2. 搜索 terminal.integrated.encoding 并确保它被设置为 " utf-8 "。
3. 检查 git 配置 git config --global i18n.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/461b18e2928e3c689add6167fe853673/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2c447903524b22f14d4e44a86b2e0a6/" rel="bookmark">
			leetcode日记（51）不同路径Ⅱ
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		和上一道题（无障碍物的最短路径）很像，但事实上比上一题多了优化方法
根据上一题改的代码如下，添加了对障碍物的判定，如果有障碍物则将数组值设为0。
class Solution { public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) { int m=obstacleGrid.size(); int n=obstacleGrid[0].size(); int a[m][n]; for(int i=0;i&lt;m;i++) for(int j=0;j&lt;n;j++) a[i][j]=0; for(int i=0;i&lt;n&amp;&amp;obstacleGrid[0][i]==0;i++) a[0][i]=1; for(int i=0;i&lt;m&amp;&amp;obstacleGrid[i][0]==0;i++) a[i][0]=1; for(int i=1;i&lt;m;i++){ for(int j=1;j&lt;n;j++){ if(obstacleGrid[i][j]==0) a[i][j]=a[i-1][j]+a[i][j-1]; } } return a[m-1][n-1]; } }; 然后看了答案，答案说可以使用滚动数组优化，就又去搜了一下滚动数组的使用方法。
参考了一下63. 不同路径 II(C++)---动态规划解题(并进行滚动数组思想优化)，琢磨了一下代码，原理是将上面的二维数组优化成了一维，记录开始位置到达每一行末尾的路径数。如有障碍物则直接将数目设为0，然后继续遍历这一行；没有障碍物就将数目设为上一行路径数加上这一行路径数。
需要注意的是遍历方向，按照上面这种思路需要先遍历列再遍历行，如果先遍历行，如果上一行末尾有障碍物那么下一行就通过不了。
class Solution { public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) { int m=obstacleGrid.size(); int n=obstacleGrid[0].size(); vector&lt;int&gt; a(m); a[0]=!obstacleGrid[0][0]; for(int j=0;j&lt;n;j++){ for(int i=0;i&lt;m;i++){ if(obstacleGrid[i][j]) a[i]=0; else if(i&gt;0&amp;&amp;!obstacleGrid[i-1][j]) a[i]+=a[i-1]; cout&lt;&lt;i&lt;&lt;" "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2c447903524b22f14d4e44a86b2e0a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3154c29c6aa6af0f3b8cd526bd894396/" rel="bookmark">
			uniapp集成安卓原生录屏插件以及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 我们知道UniApp的出现简化了开发者的工作流程，并减少了代码的重复编写。开发者可以使用一套代码编译到iOS、Android、以及各种小程序的应用，节省了人力和时间成本，但是涉及到与系统交互的时候，比如录屏、录音、录像、文件操作等就需要借助原生插件来完成。
这样的话当需要做一个APP的时候我们可以用uniapp来开发，一套代码同时适配ios和安卓，然后遇到部分uniapp不好实现的功能时可用ios和安卓原生工程分别写一个原生插件集成到uniapp项目完成完整的功能。
下面我们就以安卓录屏插件为例来讲解如何集成到项目
集成插件的两种方式 （1）云端插件集成 Dcloud提供了DCloud 插件市场，上面有各种类型的插件，我们可以到这个市场去搜索我们需要的插件，然后集成到项目，集成方法比较简单，选择好插件后可以导入示例项目，演示功能，符合项目需求就可以点击购买for云打包，按照步骤集成到项目。具体使用方法、插件所需权限等插件页面都会有完整的介绍，这里推荐一个比较好用的安卓录屏插件，支持应用外录屏，经过多方测试，功能比较稳定需要的小伙伴可以直接去Dcloud市场查看集成安卓(android)原生录屏插件（支持应用外录屏） - DCloud 插件市场
（2）本地插件集成 如果我们手里有写好的插件，那就不用到插件市场，可以直接把插件以一定的规则导入项目。首先我们通过原生工程AndroidStudio（安卓）或者xcode（ios）完成插件的开发，具体的插件开发流程可以查看uniapp的开发文档简介 | uni小程序SDK，这里不做讲解，本文主要介绍怎么在开发好了插件的基础上集成到uniapp项目以及使用
（1）开发好录屏插件后在androidStudio工程中倒出插件（插件以.aar后缀结尾）
（2）回到uniapp项目中新建名为nativeplugins的文件夹，把json文件以及插件按照如图所示的目录结构存放，这样就集成好了插件，json文件是插件配置文件，配置了插件名称、id以及版本等
（3）回到manifest.json中选择APP原生插件配置选项，选择本地插件，选择了之后需要重新制作自定义基座插件才能生效
（4）走完上面的步骤后就完成了插件的集成，接下来就可以使用插件功能了
const screenModule = uni.requireNativePlugin('cfy-screen') 上面代码是用uniapp提供的方法通过插件ID引入插件对象，然后用插件对象就可以调用插件的方法完成相关的功能。如下
在csdn资源中，本人上传了集成有安卓录屏插件的uniapp示例项目，可以提供大家下载学习使用https://download.csdn.net/download/j15087159186/89578916
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/110/">«</a>
	<span class="pagination__item pagination__item--current">111/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/112/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>