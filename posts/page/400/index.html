<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea65c3f21283932cc51e8f3251491a79/" rel="bookmark">
			Python如何安装本地的.whl文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Python中，.whl文件（也被称为wheel文件）是一种二进制包格式，它允许用户在没有源代码的情况下安装Python库。这对于那些没有编译环境或者希望快速安装的用户来说非常有用。在本文中，我们将探讨如何在本地安装.whl文件。
一、下载.whl文件
首先，你需要从可信的来源下载.whl文件。这可以是Python官方网站的Files部分，也可以是像PyPI这样的第三方库托管平台。确保你下载的是与你的Python版本和操作系统兼容的文件。
二、安装pip
如果你还没有安装pip，你需要先安装它。pip是Python的包管理器，用于安装和管理Python库。你可以通过Python的官方网站下载get-pip.py脚本并按照说明进行安装。
三、使用pip安装.whl文件
一旦你有了.whl文件和pip，你就可以使用以下命令来安装它：
pip install /path/to/your/package.whl 在上面的命令中，你需要将/path/to/your/package.whl替换为你的.whl文件的实际路径。例如，如果你的.whl文件位于你的用户目录下的Downloads文件夹中，并且文件名是example-package-1.0.0-py3-none-any.whl，那么你应该运行以下命令：
pip install ~/Downloads/example-package-1.0.0-py3-none-any.whl 四、验证安装
安装完成后，你可以通过Python的交互式解释器来验证库是否已成功安装。打开终端，输入python或python3（取决于你的Python环境配置）来启动Python解释器，然后尝试导入你刚刚安装的库：
import example_package 如果没有出现错误，那么说明库已经成功安装并且可以正常使用了。
五、注意事项
确保你的pip版本是最新的，以便支持最新的wheel格式和功能。你可以使用pip install --upgrade pip命令来更新pip。如果你在安装过程中遇到权限问题，可以尝试在命令前添加sudo（在Linux或macOS上）或使用虚拟环境来避免权限问题。如果你正在使用的是虚拟环境，确保你已经激活了相应的虚拟环境，然后再运行安装命令。 通过以上步骤，你应该能够成功地在本地安装.whl文件并在Python中使用它。无论是为了快速部署项目还是为了避免编译源代码的麻烦，.whl文件都是一个非常实用的工具。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/178515a73f4af684a4bc40d4011eac38/" rel="bookmark">
			全球AI大模型盘点（全网首发）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、全球大模型 1、ChatGPT ChatGPT 是人工智能公司 OpenAI 基于 GPT-3.5 研发的大规模对话式语言模型，目前处于测试阶段，拥有 OpenAI 账户即可免费使用。 ChatGPT 采用对话格式，目前已经做到流利回答问题、纠正自己的错误、挑战用户提出的不正确的前提并拒绝不正当的要求，且支持中文。2023/03/15 凌晨，openAI 发布了多模态预训练大模型 GPT-4，并且同步升级了 ChatGPT，允许 ChatGPT Plus 的订阅者获得 GPT-4 的访问权限。
2、Claude
Claude是由Anthropic开发的一个大型语言模型，它在多个任务上展示了超越ChatGPT-4的能力，特别是在理解深层次语言模式和复杂推理方面。
3、Gemini Gemini是由Google Research团队开发的一个大型语言模型，它在自然语言理解和生成方面具有强大的能力，通常用于研究和实验性项目。
4、Mistral Mistral是一个专注于生成式任务的AI模型，它通过学习大量数据来模拟和预测内容，常用于文本生成和图像生成等任务。
5、Llama (Hugging Face Space) Llama是Hugging Face公司推出的一个模型，它在自然语言处理任务中表现出色，如文本分类、问答和文本生成，适用于多种应用场景。
6、Grok xAI Grok xAI是由Grok公司开发的一个AI模型，它在特定领域如金融和医疗中展现出深度学习和模式识别的能力，用于解决复杂的行业问题。
二、国内大模型 星火大模型
科大讯飞推出的AI大语言模型，提供多样化的智能服务，如绘画创作、编程辅助、PPT大纲生成等。
智谱清言
智谱AI开发的千亿参数对话模型，支持多轮对话和内容创作，具备信息归纳总结能力。
豆包
提供AI搜索、PDF问答和图像生成等功能的智能平台，旨在帮助用户获取信息和创作内容。
Kimi
Moonshot AI开发的智能助手，支持超长文本输入，适用于处理长文本的复杂任务。
Coze
提供个性化推荐、财经信息查询、绘图助手等多种AI智能体，通过智能对话提供服务。
万知
一站式AI工作平台，支持文档解析、PPT创作、长文速读等功能，助力阅读、创作和分享。
百川
百川智能推出的超千亿参数大模型，支持中英双语，具备搜索增强技术，适用于多种文档和网址输入。
文心一言
百度推出的AI服务，利用大模型技术提供自然语言处理能力，支持多种智能应用场景。
通义千问
阿里云提供的AI服务，基于大模型技术，提供智能问答和语言理解服务。
混元
腾讯推出的混元助手小程序，提供便捷的AI服务，优化移动用户体验。
商量
一个AI对话平台，提供智能对话服务，帮助用户解决问题和获取信息。
跃问
新兴的AI聊天服务，允许用户进行智能对话，获取所需信息和支持。
Dify
提供AI驱动的服务，旨在通过智能技术改善用户工作效率和生活质量。
万知
另一入口指向万知平台，提供全面的AI服务，包括但不限于数据分析、文档阅读和内容创作。
三、AI视频 Morph Studio
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/178515a73f4af684a4bc40d4011eac38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ede8c18fef61011e39f7226d67f63bf/" rel="bookmark">
			【ML】朴素贝叶斯分类器及Python手写实现（详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、两个学派
1.1 频率学派：
1.2 贝叶斯学派
二、朴素贝叶斯
2.1 简介
2.2 相关公式
2.2.1 贝叶斯公式
2.2.2 朴素贝叶斯公式
三、案例分析（西瓜集）
四、Python实现NB代码解读
4.1 西瓜集手写代码
4.2 鸢尾花手写代码
4.3 鸢尾花第三方库
五、Python实现NB代码汇总
5.1 不使用sklearn中方法
5.1.1 数据集：西瓜集3.0（来自西瓜书《机器学习 周志华》84页）
5.1.2 数据集：鸢尾花iris（来自sklearn提供的数据集）
5.2 使用sklearn中的方法
5.2.1 数据集：鸢尾花iris（来自sklearn提供的数据集）
【写在前面】
本篇文章介绍了朴素贝叶斯分类器（Naive Bayes，NB）的工作原理以及使用Python实现NB，这里介绍了3种代码：使用西瓜集3.0手写NB、使用鸢尾花数据集手写NB、使用鸢尾花数据集使用机器学习第三方库实现NB。如有错误欢迎指正。
一、两个学派 概率模型的训练过程就是参数估计过程。对于参数估计，统计学界的两个学派（频率学派、贝叶斯学派）提供了不同的解决方案。
1.1 频率学派： 核心思想：认为参数真值是固定的、未知的一个常数，而观察到的数据是随机的。其着眼点是样本空间。
解决方法：最大似然估计（MLE）。
1.2 贝叶斯学派 核心思想：认为参数真值是未观察到的随机变量，其本身也可有分布，而观察到的数据是固定的。其着眼点是参数空间，重视参数的分布。利用参数的先验信息估计后验概率，即先验概率P(c)+样本信息（条件概率）P(x|c)-&gt;后验概率P(c|x)。
解决方法：最大后验估计（MAP）。
频率学派的观点是对总体分布做适当的假定，结合样本信息对参数进行统计推断，这里涉及总体信息和样本信息；而贝叶斯学派的观点认为除了上述两类信息之外，统计推断还应引入先验信息。
一般来说，先验信息来源于经验和历史资料。频率学派不假设任何的先验信息，不参照过去的经验，只按照当前已有的数据进行概率推断；贝叶斯学派会假设先验信息的存在。
二、朴素贝叶斯 2.1 简介 贝叶斯分类的分类原理就是利用贝叶斯公式根据某特征的先验概率计算出后验概率，然后选择具有最大后验概率的类别作为该特征所属的类别。
朴素贝叶斯之所以称为“朴素”，是因为假设了各个特征之间是相互独立的。
2.2 相关公式 对于待分类样本S：
特征集合X={x1,x2,…,xn}
类标签集合C={c1,c2,…,cm}
表示样本S具有n个特征，可能会有m中不同的分类结果。
2.2.1 贝叶斯公式 其中：
ci：表示一种预测类别结果；
X：表示样本S的一组特征观测数据；
P(ci)：表示ci的先验概率，即在未观察到X之前S属于ci的概率；
P(ci|X)：表示ci的后验概率；即在观察到X后S属于ci的概率；
P(X|ci)/ P(X)：可能性函数，表示调整因子，使预测概率更加接近真实概率；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ede8c18fef61011e39f7226d67f63bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/692b6ea4f3d320e6f78dc6e27d5f10b1/" rel="bookmark">
			Python中实现单例模式的最佳实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python中实现单例模式的最佳实践
在软件开发中，单例模式是一种常见的设计模式，它确保一个类仅有一个实例，并提供一个全局访问点来获取该实例。这种模式在多个场景中都很有用，比如配置管理、日志记录、线程池等。Python作为一种灵活且强大的编程语言，提供了多种实现单例模式的方法。本文将介绍几种在Python中实现单例模式的常用方法，并提供相应的代码示例。
一、使用模块导入实现单例模式
在Python中，模块是天然的单例。当模块被第一次导入时，会创建模块对象，并且在后续导入中，Python会重用该对象。因此，我们可以利用这一特性来实现单例模式。
示例代码：
# singleton.py class Singleton: def operation(self): return "Instance operation" # 创建Singleton类的实例 singleton_instance = Singleton() # 在其他模块中，可以直接导入singleton_instance from singleton import singleton_instance # 使用singleton_instance print(singleton_instance.operation()) 这种方法简单且有效，但缺点是如果我们需要动态地创建单例，或者需要根据不同的参数创建不同的单例实例，那么这种方法就不适用了。
二、使用类装饰器实现单例模式
使用类装饰器是一种更加灵活的方式，它允许我们动态地创建单例，并且可以轻松地应用于任何类。
示例代码：
def singleton(cls): instances = {} def getinstance(): if cls not in instances: instances[cls] = cls() return instances[cls] return getinstance @singleton class MyClass: def __init__(self): pass def operation(self): return "Singleton operation" # 获取单例实例 instance1 = MyClass() instance2 = MyClass() # 验证是否为同一个实例 print(instance1 is instance2) # 输出: True # 使用实例 print(instance1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/692b6ea4f3d320e6f78dc6e27d5f10b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3561d1c2099b056efc63bba6538f24e/" rel="bookmark">
			Python OpenCV图像处理：从基础到高级的全方位指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
第一部分：Python OpenCV图像处理基础
1.1 OpenCV简介
1.2 Python OpenCV安装
1.3 实战案例：图像显示与保存
1.4 注意事项
第二部分：Python OpenCV图像处理高级技巧
2.1 图像变换
2.2 图像增强
2.3 图像复原
第三部分：Python OpenCV图像处理实战项目
3.1 图像滤波
3.2 图像分割
3.3 图像特征提取
第四部分：Python OpenCV图像处理注意事项与优化策略
4.1 图像尺寸与分辨率
4.2 图像文件格式
4.3 内存管理
4.4 性能优化
总结
OpenCV是一个开源的计算机视觉库，广泛应用于图像处理、图像识别、图像合成等领域。本文将从四个部分详细介绍Python OpenCV图像处理的基础知识、常用库、实战案例及注意事项，帮助读者从入门到精通Python OpenCV图像处理。
第一部分：Python OpenCV图像处理基础 1.1 OpenCV简介 OpenCV是一个开源的计算机视觉库，提供了丰富的图像处理算法和功能。它支持多种编程语言，包括Python、C++、C#等。OpenCV的主要功能包括图像处理、图像识别、图像合成等。
OpenCV的核心概念包括图像处理、图像分析、机器学习等。它提供了一系列的图像处理函数，如图像变换、图像增强、图像复原等。此外，OpenCV还支持图像识别和图像合成，可以用于构建复杂的计算机视觉系统。
1.2 Python OpenCV安装 要使用Python OpenCV，首先需要安装OpenCV库。可以使用pip进行安装：
pip install opencv-python 安装完成后，可以通过以下方式导入OpenCV库：
import cv2 1.3 实战案例：图像显示与保存 下面通过一个简单的例子来演示如何使用OpenCV库显示和保存图像。
import cv2 # 打开图像 image = cv2.imread('example.jpg') # 显示图像 cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3561d1c2099b056efc63bba6538f24e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7513c7628aa56f3d6b4226efb3e5ffc5/" rel="bookmark">
			【DB2报错】执行存储过程报 SQLCODE:-420 SQLSTATE:22018,解决方法在这里。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		执行存储过程的时候碰到这个报错： Invalid character found in a character string argument of the function "DECFLOAT"...SQLSTATE:22018 SQLCODE:-420 不要慌！！遇事不决先翻译：
翻译：在函数 "DECFLOAT" 的字符串自变量中找到无效字符。
报错解释 ：
原因分析：
处理方式：
情况一：
情况二：
报错解释 ： SQLCODE:-420 函数 函数名（这里指的是报错信息里的DECFLOAT） 的字符串自变量包含在数字 SQL 常量中无效的字符。 由于使用 CAST 规范并将 函数名 （DECFLOAT）作为目标数据类型，或者将一个自变量隐式强制类型转换为数字数据类型而调用了此函数。 用于 SQL 语句中的函数或数据类型可能是 函数名 （DECFLOAT）的同义词。
SQLSTATE:22018 CAST 规范 或者 CAST 标量函数的字符值无效。
用户响应：更改 SQL 语句，使每个操作数或 VALUES 子句中的每行有完全相同的列数。
原因分析： 根据提示找到问题语句所在地方，是一个IF条件里的语句
/*-------------------------------------- 情况一：字段类型说明 DEPTNO decimal(2,0) --------------------------------------*/ SELECT COUNT(1) FROM EMP WHERE DEPTNO &lt;&gt; '' /*--------------------------------------------- 情况二：字段类型说明 var_col varchar(8) var_col里的枚举值都是数字，也有''（空字符串）的情况 -----------------------------------------------*/ SELECT var_col FROM test_table WHERE var_col &gt; 0 处理方式 情况一： SELECT COUNT(1) FROM EMP WHERE DEPTNO &lt;&gt; ''
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7513c7628aa56f3d6b4226efb3e5ffc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/554ab455185c5d47913685f01065359a/" rel="bookmark">
			分布式hbase：status查看hbase shell时抱错：ERROR: KeeperErrorCode = NoNode for /hbase/master 问题。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hbase的HMaster进程会自动停止 master节点start-hbase.sh启动hbase后，jps命令查看启动进程可以看到HMaster进程，但是总是过十几秒就直接停止了，再输出jps命令无法查看到HMaster进程。hbase shell进入shell界面,输出status命令查看hbase运行状态时抱错：ERROR: KeeperErrorCode = NoNode for /hbase/master 问题。
抱错原因： 1./etc/hosts是否配置节点和IP地址对应。
2.没有关闭主节点和从节点的安全模式。
3.hbase的hbase-site.xml配置文件有误。
解决方法： 1：没有配置节点的IP地址对应就无法获取节点： 先查看cat /etc/hosts各节点配置了
配置命令：vim /etc/hosts
192.168.40.129 master //（自己本机主节点ip 节点名称）
192.168.40.130 salve1 //(自己本机从节点ip 节点名称)
2：没有关闭安全模式，主节点无法获取从节点（需要关闭安全模式）: 查看namenode处于哪个状态 hdfs dfsadmin -sagemode get
两种模式：
safe mode is on (在安全模式)
safe mode is off (退出安全模式）
补充：进入安全模式命令（hadoop启动的时候是在安全模式） hdfs dfsadmin -sagemode enter
离开安全模式 hafs dfsadmin -sagemode leave(无法用这个命令退出，可用下面的强制退出)
强制退出安全模式： hdfs dfsadmin -safemode forceExit
3：hbase的hbase-site.xml的hbase重要的文件，如配置错误将无法启动hbase。配置HBase的数据是否保存在主节点的目录下。 用命令vim打开并编辑hbase-site.xml，命令如下：
root@master:~# vim /usr/local/hbase/conf/hbase-site.xml
修改为如下内容：
&lt;configuration&gt;
&lt;!-- 配置HBase的数据保存在HDFS对应目录下 --&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/554ab455185c5d47913685f01065359a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50536635184398513907e5f07bf821d3/" rel="bookmark">
			Kafka入门使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前言 1.1. 什么是消息队列 消息队列（MQ）是消息传递中间件解决方案的一个组件，旨在支持独立的应用和服务之间的信息交换。 消息队列按发送顺序存储“消息”（由应用所创建、供其他应用使用的数据包），直到使用方应用能够处理它们为止。 这些消息安全地等待接收方应用做好准备，因此，即使网络或接收方应用出现问题，消息队列中的消息也不会丢失。
1.2. 为什么用消息队列 1.2.1. 解耦 生产者（客户端）发送消息到MQ中去，接受者（服务端）处理消息，需要消费的系统直接去MQ取消息进行消费即可而不需要和其他系统有耦合。
例如订单服务在电商订单创建后，发送扣减可用库存消息到MQ，库存系统在接受到消息后处理扣减可用库存。后续如果还需要扩展，通知其他第三方系统，只需要新增一个消费者去接收扣减信息处理即可。
1.2.2. 异步 将用户的请求数据存储到MQ之后就立即返回结果。随后，系统再对消息进行消费。
例如短信验证码业务，登录服务在接受到用户手机号之后，将手机号发送到MQ，短信服务接受消息后进行短信发送。登录服务不需要等待发送验证码完成，即可继续后续处理。
1.2.3. 削峰 先将短时间高并发产生的事务消息存储在MQ中，然后后端服务再慢慢根据自己的能力去消费这些消息。
例如电商大促时，可在订单服务前架设一层订单接收服务，只负责接收订单并将订单信息发送到MQ，订单服务根据自身消费能力来接收订单信息并创建订单。 这样就避免订单服务因过高流量而宕机。
1.3. Kafka Kafka是最初由Linkedin公司开发，是一个分布式、支持分区的（partition）、多副本的（replica），基于zookeeper协调的分布式消息系统，它的最大的特性就是可以实时的处理大量数据以满足各种需求场景：比如基于hadoop的批处理系统、低延迟的实时系统、storm/Spark流式处理引擎，web/nginx日志、访问日志，消息服务等等，用scala语言编写，Linkedin于2010年贡献给了Apache基金会并成为顶级开源项目。
2. 安装 2.1. 官网 Apache Kafka
2.2. docker安装 version: "1" services: kafka: image: 'bitnami/kafka:latest' hostname: kafka ports: - 9092:9092 - 9093:9093 volumes: - 'D:\Docker\Kafka\data:/bitnami/kafka' networks: - kafka_net environment: # KRaft settings - KAFKA_CFG_NODE_ID=0 - KAFKA_CFG_PROCESS_ROLES=controller,broker - KAFKA_CFG_CONTROLLER_QUORUM_VOTERS=0@kafka:9093 # Listeners - KAFKA_CFG_LISTENERS=PLAINTEXT://:9092,CONTROLLER://:9093 - KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://192.168.2.51:9092 - KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP=CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT - KAFKA_CFG_CONTROLLER_LISTENER_NAMES=CONTROLLER - KAFKA_CFG_INTER_BROKER_LISTENER_NAME=PLAINTEXT networks: kafka_net: driver: bridge docker-compose -f .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50536635184398513907e5f07bf821d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9dbe4b8141a209a11215369f2c90da9/" rel="bookmark">
			web大鱼海棠主题网页(6页)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📔1.网页作品简介方面 ：HTML网站模板。主要有：首页 、剧情简介、角色介绍、制作相关、作品评价、交流登录页等总共 6个页面。
📘2.网站文件方面：网站系统文件种类包含：html网页结构文件、css网页样式文件、js网页特效文件、images网页图片文件；
📙网页编辑方面：网页作品代码简单，可使用任意HTML编辑软件（如：Dreamweaver、HBuilder、Vscode 、Sublime 、Webstorm、Text 、Notepad++ 等任意html编辑软件进行运行及修改编辑等操作）。
📒3.网页作品技术：Div+CSS、导航栏效果、表单等等知识点网站布局方面：计划采用目前主流的、能兼容各大主流浏览器
“我想见到天空，想看看那个世界。”——大鱼海棠
首页 、 剧情简介、 角色介绍、 制作相关、 作品评价、 交流登录页 index.html
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;link rel="stylesheet" type="text/css" href="css/css.css" /&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="di"&gt; &lt;div class="dao"&gt; &lt;div class="logo"&gt; &lt;p&gt;大鱼海棠&lt;/p&gt; &lt;/div&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="index.html"&gt;网站首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="juqing.html"&gt;剧情简介&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="jiaose.html"&gt;角色介绍&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="zhizuo.html"&gt;制作相关&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="pingjia.html"&gt;作品评价&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="liuyan.html"&gt;交流登录&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9dbe4b8141a209a11215369f2c90da9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9483592d7ee461a921a0f76ca5586bae/" rel="bookmark">
			【DB2报错】执行存储过程报 SQLCODE:-104 SQLSTATE:42601
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天创建存储过程的时候碰到这个报错： AN unexpected tkoen "END-OF-STATEMENT" was found following "COMMIT",Expected tokens may include:"END IF"..SQLSTATE:42601 SQLCODE:-104 不要慌！！遇事不决先翻译！！！
翻译：在“COMMIT”之后发现了一个异常的tkoen“END-OF-STATEMENT”，异常的tkoen 可能包括：“END IF”.SQL状态：-104 SQL代码：42601
报错解释 ：
原因分析：
处理方式：
情况一、
情况二、
报错解释 ： SQLCODE:-104 错误状态码，在 文本 后面找到异常 标记。预期标记可能包括： 标记列表。
SQLSTATE:42601 错误类代码，含义字符、标记或自居无效或丢失。
用户响应：在指定的标记区域内检查并更正语句。
原因分析： 根据提示找到问题语句所在地方，COMMIT后面也只是一个正常的 IF 判断结束和 存储过程结束而已，并没有什么异常。但是提示还另外补了一句unexpected tkoen "END-OF-STATEMENT" 结束出现了问题。
CREATE OR REPLACE PROCEDURE DROP_VIEW( IN V_NAME VARCHAR(100)) BEGIN DECLARE CNT_V INTEGER; DECLARE DROP_SQL VARCHAR(1000); SET CNT_V= (SELECT COUNT(1) FROM SYSCAT.VIEWS WHERE VIEWSCHEMA = TRIM(CURRENT_SCHEMA) AND VIEWNAME = V_NAME); IF CNT_V &lt;&gt; 0 THEN SET DROP_SQL = 'DROP VIEW ' || V_NAME; COMMIT; END IF; END; 处理方式： 情况一、 按照提示的话我们可以发现问题就出现在存储过程结束的位置，检查结束语句分隔符为“@”；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9483592d7ee461a921a0f76ca5586bae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/595c5adaca72c979c5c6114f9fe3a58c/" rel="bookmark">
			nohup java -jar 启动java项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hi，我是程序员王也，一个资深Java开发工程师，平时十分热衷于技术副业变现和各种搞钱项目的程序员~，如果你也是，可以一起交流交流。
今天我们聊聊linux中运行java jar包的问题~
理解nohup命令 nohup命令的基本概念 nohup是一个常用的Unix命令，用于在忽略挂起信号（SIGHUP）的情况下运行指定的命令或进程。当用户注销或关闭终端时，通常后台运行的进程会收到SIGHUP信号而终止。使用nohup可以避免这种情况，使得进程即使在用户注销后也能继续运行。
nohup的工作原理 nohup通过忽略SIGHUP信号来实现命令的持续运行。当nohup命令被执行时，它会启动一个新的进程，并将该进程的SIGHUP信号屏蔽，这样即使终端关闭，该进程也不会受到影响。
nohup与后台进程的区别 后台进程可以通过在命令后添加&amp;符号来启动，如command &amp;。然而，后台进程在用户注销后通常无法继续运行，因为它们会收到SIGHUP信号。与之相比，nohup启动的进程则不会受到用户注销的影响。
示例：使用nohup启动Java应用 假设我们有一个名为MyApp.jar的Java应用程序，我们希望在后台运行它，即使用户注销或关闭终端，应用也能持续运行。
启动命令 nohup java -jar MyApp.jar &amp; 这个命令做了以下几件事：
nohup：告诉系统忽略挂起信号。java -jar MyApp.jar：实际的Java命令，用于启动JAR文件。&amp;：将命令放入后台执行。 输出重定向 默认情况下，nohup会将输出重定向到名为nohup.out的文件中。如果需要自定义输出文件，可以使用重定向操作符：
nohup java -jar MyApp.jar &gt; output.log 2&gt;&amp;1 &amp; 这里：
&gt;：将标准输出重定向到output.log文件。2&gt;&amp;1：将标准错误也重定向到同一个文件。 查看进程状态 可以使用ps命令查看nohup启动的进程状态：
ps -ef | grep MyApp.jar 停止进程 要停止由nohup启动的进程，可以使用kill命令结合进程ID（PID）：
kill -9 PID 其中，PID是ps命令查询到的进程ID。
案例源码说明 以下是使用nohup启动Java应用的完整示例，包括启动、输出重定向和进程管理：
启动Java应用
nohup java -jar /path/to/MyApp.jar &gt; /path/to/output.log 2&gt;&amp;1 &amp; 查看进程
ps -ef | grep MyApp.jar 停止进程
kill -9 $(pgrep -f MyApp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/595c5adaca72c979c5c6114f9fe3a58c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cf781c59f51e7563d93260e2e5c9ac9/" rel="bookmark">
			Llama改进之——均方根层归一化RMSNorm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 在学习完GPT2之后，从本文开始进入Llama模型系列。
本文介绍Llama模型的改进之RMSNorm(均方根层归一化)。它是由Root Mean Square Layer Normalization论文提出来的，可以参阅其论文笔记1。
LayerNorm 层归一化(LayerNorm)对Transformer等模型来说非常重要，它可以帮助稳定训练并提升模型收敛性。LayerNorm针对一个样本所有特征计算均值和方差，然后使用这些来对样本进行归一化：
μ = 1 H ∑ i = 1 H x i , σ = 1 H ∑ i = 1 H ( x i − μ ) 2 , N ( x ) = x − μ σ , h = g ⊙ N ( x ) + b (1) \mu = \frac{1}{H}\sum_{i=1}^H x_i,\quad \sigma = \sqrt{\frac{1}{H}\sum_{i=1}^H (x_i - \mu)^2}, \quad N(\pmb x) = \frac{\pmb x-\mu}{\sigma},\quad \pmb h = \pmb g \,\odot N(\pmb x) + \pmb b \tag 1 μ=H1​i=1∑H​xi​,σ=H1​i=1∑H​(xi​−μ)2 ​,N(x)=σx−μ​,h=g⊙N(x)+b(1)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cf781c59f51e7563d93260e2e5c9ac9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/589536b849299a8355915e85844bece5/" rel="bookmark">
			Python-Mysql 实现学生信息管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python-Mysql 实现学生信息管理系统
一、前言
二、系统流程图
三、数据库设计图
概念设计：
逻辑结构设计
物理结构设计
四、Nacicat下载与数据库创建
五、Pymysql下载
六、连接数据库（代码）
七、系统功能实现（代码）
八、系统功能实现（部分运行结果）
九、参考网址
一、前言 目的：设计一个学生信息管理系统，可对学生进行添加、删除、修改、查找和报表输出等功能，学生属性有：学号、姓名、性别、所属班级、相片、出生日期和备注等属性。
本文是已经在终端装好数据库，利用Navicat方便查看数据库，因为题目要求里有图片属性，在终端不能查看图片的jpg格式，只能看到二进制文字。另外我建了两个python文件 一个是连接数据库且创建表（先运行） 另一个是系统功能设计（后运行）。
如果不想用navicat，也可以用终端，不过首先要在终端创建要用的数据库。然后在利用文中第六章，创建一个表。然后运行第七章的代码，那么再查看表结构和数据的时候就要在终端运行。相关代码如下：
CREATE DATABASE 数据库; USE 数据库; DESC 表; SELECT *FROM 表; 这个学生管理系统做的很简陋，欢迎大家继续改进。
终端启动方式：
二、系统流程图 三、数据库设计图 概念设计： E-R图
逻辑结构设计 学生信息（学号#，姓名，性别，所属班级，出生日期，备注，图片）
物理结构设计 所属班级，出生日期，备注，图片一开始可以为空，也就是不用输入值
字段名
类型
长度
不是空值
键
学号
int
TRUE
主键
姓名
varchar
50
TRUE
性别
varchar
50
TRUE
所属班级
varchar
50
FALSE
出生日期
date
FALSE
备注
varchar
255
FALSE
图片
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/589536b849299a8355915e85844bece5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0508e1dd79cf90d7ab2d367f1b6dc278/" rel="bookmark">
			Hadoop与hdfs的认知讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.HDFS的简介： HDFS：大规模数据分布式存储核心 HDFS（Hadoop Distributed File System）是Hadoop项目的一个子项目，也是Hadoop的核心组件之一。它是一个分布式文件系统，设计用于存储大型数据，如TB和PB级别的数据。
HDFS的主要特征包括：
文件分块存储：在HDFS中，文件在物理上是分块存储的。块的大小可以通过配置参数（dfs.blocksize）来规定。在Hadoop 2.x版本中，默认块大小是128M，而在老版本中是64M。统一的命名空间和目录树：HDFS文件系统会给客户端提供一个统一的抽象目录树。客户端通过路径来访问文件，形如：hdfs默认文件:https://hadoop.apache.org/docs/r3.3.4/hadoop-project-dist/hadoop-hdfs/hdfs-default.xml元数据管理：目录结构及文件分块信息（元数据）的管理由NameNode节点承担。NameNode是HDFS集群的主节点，负责维护整个HDFS文件系统的目录树，以及每一个路径（文件）所对应的block块信息（block的id，及所在的DataNode等）。 1.1 Hadoop架构 HDFS(Hadoop Distributed FileSystem)，由3个模块组成：分布式存储HDFS，分布式计算MapReduce，资源调度框架Yarn
大量的文件可以分散存储在不同的服务器上面
单个文件比较大，单块磁盘放不下，可以切分成很多小的block块，分散存储在不同的服务器上面，各服务器通过网络连接，造成一个整体。
1.2 定义block HDFS3.x上的文件会按照128M为单位切分成一个个的block，分散存储在集群的不同的数据节点datanode上，需要注意的是，这个操作是HDFS自动完成的。hadoop当中, 文件的 block 块大小默认是 128M（134217728字节）。
假设我们现在要存储一个300M的文件，这个300M就会被切分成这128M,128M,44M三块，这时我们需要知道，就算它的底层逻辑会按照128M进行划分，可是datanode3一个实际占用44M的块也是不会占据128M的空间的。（具体情况具体分析）
#即使是某一块突然宕机也不会影响整体的运行#
二、HDFS的四大组件 HDFS的四个基本组件:HDFS Client、NameNode、DataNode和Secondary NameNode 2.1Client 的介绍 就是客户端。 文件切分。文件上传 HDFS 的时候，Client 将文件切分成 一个一个的Block，然后进行存储 与 NameNode 交互，获取文件的位置信息。 与 DataNode 交互，读取或者写入数据。 Client 提供一些命令来管理 和访问HDFS，比如启动或者关闭HDFS。 2.2 NameNode的介绍 大数据框架都是分布式的，可能每个角色都运行在各个不同的服务器上面，需要进行通信的时候就要需要网络的支持，而在我们客户端需要读一个文件的信息时，必须知道我们这个文件被分成了多少个block，各个block又分别存储在哪个服务器上，这种用于描述文件的信息被称为文件的元数据信息（metaData），而metaData就是存储在NameNode的内存中的 2.3metaData的介绍（记录数据的数据） #Hive元数据存储用Metastore
Hadoop元数据存储用Namenode metaData的大小：文件，block，目录占用大概150byte字节的元数据，所以为什么说HDFS适合存储大文件而不适合存储小文件，可想而知存储一个大文件就只有一份150byte的元数据，存储N多个小文件就会伴随存在N份150Byte字节的元数据文件，这就非常地不划算（可以帮助你去按需购买所需要大小的运存） 2.4Secondary NameNode的介绍 并非 NameNode 的后备，当NameNode 挂掉的时候，它并不能马上替换 NameNode 并提供服务， 辅助 NameNode，分担其工作量， 在紧急情况下，可辅助恢复 NameNode。
实习笔记： 1.访问端口
hdfs访问：2.x 50070 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0508e1dd79cf90d7ab2d367f1b6dc278/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b901666b00b097050f092b8f91e8bfd/" rel="bookmark">
			微信小程序开发 更改AppID(小程序ID)为自己的时,出现:修改项目APPID失败: Error: INVALID LOGIN,access token expired
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最开始是使用的测试账号,游客模式下,调用 wx.operateWXData 是受限的, API 的返回是工具的模拟返回,想继续调用什么时,需使用真实账号。 更改AppID(小程序ID)为自己的时,出现:修改项目APPID失败: Error: INVALID LOGIN,access token expired 想知道我的解决方法可跳过如下
期间尝试了很多:
方法一: 进入目录 /src/manifest.json -- 点击“源码视图” -- 找到微信小程序节点,修改其中的"appid";
因为实在没找到manifest.json文件,换下一个办法
方法二: 在打开项目的页面,右下角的 注销 注销后使用自己的真实AappID登录
但是点不动,以失败告终
...
以下是我的解决方法,不一定适用每个人,希望对你们有所帮助 在小程序管理页面
管理 --&gt; 选中自己需要的那个(我就一个,所以点全选) --&gt; 点击删除 --&gt; 完成 然后重新打开.更改成功, token expired问题解决 以上是我的解决办法,希望对你们有启发!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ae558f166db564cf8335a33ab794300/" rel="bookmark">
			uniapp vue 多端开发 超链接 打开浏览器 打开外部网站 支持小程序、H5、APP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言： 开发项目时发现多端打开网站的方式有点乱，网上的方法基本不全，就写了这个函数供大家使用。
代码： 小程序暂时不支持直接跳转到外部浏览器，需要可以新建页面，把网站在项目页面打开，具体操作请百度😘。
openLink(link){ // #ifdef APP-PLUS plus.runtime.openURL(link); // #endif // #ifdef H5 window.open(link); // #endif // #ifdef MP uni.setClipboardData({ data: link, success: () =&gt; {	uni.showToast({ icon: 'none', title: '链接已复制，请在浏览器打开' });	} }); // #endif }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a24a488287f1e2ed8327d592a33ba1b/" rel="bookmark">
			【AI工具】LM Studio 部署本地llama3以及python调用openai的API与llama3本地服务器进行问答...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 下载LM Studio
https://lmstudio.ai/
2. 安装后打开主界面
3. 下载自己感兴趣的大模型
由于网络原因，通过IDM手动下载后拷贝到相应文件夹下
点击下载后，左下角点击“ 1 downloading”可以查看详情
从详情中提取出模型下载地址然后手动下载，比如“https://huggingface.co/TheBloke/phi-2-GGUF/resolve/main/phi-2.Q4_K_S.gguf”
下载完毕后，将模型拷贝到 模型文件夹所在目录，新建两级目录，参考下图：
以模型下载网址“https://huggingface.co/TheBloke/phi-2-GGUF/resolve/main/phi-2.Q4_K_S.gguf”为例，新建 “TheBloke”文件夹，然后在里面新建 “phi-2-GGUF”文件夹，最后把 模型文件“phi-2.Q4_K_S.gguf”拷贝到 “phi-2-GGUF”文件夹。
之后就可以打开聊天界面，加载模型后聊天了
4. 启动本地服务器
5. 使用 OpenAI 的 Python API 来与一个智能助手进行终端聊天
# 在终端中与智能助手聊天 from openai import OpenAI # 指向本地服务器 client = OpenAI(base_url="http://localhost:1234/v1", api_key="lm-studio") # 初始化历史记录列表，其中包含系统和用户的角色和内容 history = [ {"role": "system", "content": "你是一个聪明的助手。你总是提供合理、准确且有帮助的答案。总是用中文简体回答"}, {"role": "user", "content": "你好，向第一次开启这个程序的人介绍你自己。请简洁明了。请用中文回答"}, ] # 使用while循环不断地接收用户输入并提供回答 while True: # 创建聊天完成请求，指定模型、历史消息和其他参数 completion = client.chat.completions.create( model="zhouzr/Llama3-8B-Chinese-Chat-GGUF", messages=history, temperature=0.7, stream=True, ) # 初始化新消息字典，用于存储助手的回答 new_message = {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a24a488287f1e2ed8327d592a33ba1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd7c8f4aa2dfe66ee8c9847ed2d1b513/" rel="bookmark">
			【大数据实训】基于当当网图书信息的数据分析与可视化(八)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于当当网图书信息的数据分析与可视化 一、实验环境
（1）Linux： Ubuntu 16.04
（2）Python: 3.5
（3）Hadoop：3.1.3（4）Spark: 2.4.0（5）Web框架：flask 1.0.3
（6）可视化工具：Echarts
（7）开发工具：Visual Studio Code
二、小组成员及分工
（1）成员：林海滢，王惠玲，陈嘉怡，郭诗念
（2）分工：xxx负责xxxx部分，xxx负责xxxx部分，xxx负责xxxx部分。
三、数据采集
3.1数据集说明
爬取网站：http://search.dangdang.com/?key=java，是当当网的java图书的信息网站。数据文件：java_books.xlsx。其中包含了1661条与java图书信息有关的数据。
数据格式为：
图 3. 1 采集数据格式
数据中包含的内容如下：
（1）book_name： 图书的标题
（2）introduction：图书的简介
（3）author： 图书的作者
（4）price： 图书的价格（元/本）
（5）press： 图书出版社
（6）comment： 图书的评论
3.2.爬取数据集以及将其保存到本地D盘文件中的流程
（1）选取所需要爬取的页面进行遍历爬取
（2）通过正则表达式抓取所需要的数据
（3）将爬取出的数据转化为dataframe格式并保存为xlsx文件存放在D盘
四、数据清洗与预处理
4.1预处理中提取的数据
图 4.1 数据处理前的数据格式及存在问题的特征列
4.2 清洗预处理后的数据格式
图 4.2 数据处理后的数据格式及特征列
4.3 清洗与预处理的流程
（1）首先检查数据的结构以及是否有数据缺失。
（2）发现book_name特征列的数据格式不对，于是处理转换为了整数类型。
（3）发现price特征列的数据格式不对，于是处理转换为了浮点类型。
（4）内容简介列数据清洗 删除异常值。
（5）保存清洗与预处理后的数据集。
五、spark数据分析
5.1 数据分析目标
（1）图书的售价分布情况（观察图书价格大体集中在哪个分段得出图书价格趋势）
（2）部分图书出版社的出书数量统计
（3）图书的作者出书（观察哪个作者出的书最多）
（4）图书的评论分布情况（观察图书评论大体集中在哪个分段得出图书评论趋势）
（5）图书的部分作者数量统计
（6）分析价格的最大值、最小值、均值、方差和中位数
六、数据可视化
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd7c8f4aa2dfe66ee8c9847ed2d1b513/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/808172c285415cfc07eec015e02edfe5/" rel="bookmark">
			Llama 3 最强开源模型？深入剖析Meta Llama 3技术细节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Meta 最近宣布推出了其最新力作——Meta AI，这是一款先进的人工智能聊天机器人，由公司最新且功能强大的 Llama 3 模型驱动。
自 OpenAI 推出广受欢迎的 ChatGPT 以来，众多顶尖企业纷纷涉足这一领域，竞相推出自己的 AI 聊天机器人。在这场技术竞赛中，Meta 凭借 Llama 3 的强大支持，可能已经打造出了目前市场上功能最为强大的 AI 聊天机器人。
什么是Llama-3？ Llama 模型的首个版本发布于去年 2 月，属于首批对外开放权重的大型语言模型。紧接着，Meta 在 2023 年 7 月推出了该模型的升级版——Llama 2。
Llama 3 不仅是 Meta AI 聊天机器人的动力引擎，还被 Meta 誉为当前最强大的公开可用的大型语言模型 LLM。相较于前身 Llama 2，Llama 3 在性能上实现了显著飞跃。它拥有高达 8 至 700 亿个参数，这一数字在同类模型中独占鳌头。
Llama 3 在减少错误、增强响应多样性以及提升对齐度方面均有突破。
此外，Meta 还精心设计了一套全新的人类评估集，覆盖 12 个实际用例，确保模型在现实世界场景下的表现。这些用例包括但不限于：征求建议、集体讨论、分类、封闭式问答、编程、创意写作、信息抽取、角色扮演、开放式问答、逻辑推理、文本重写以及总结等。
Llama 3 与 Llama 2 对比 Llama 3 在多个关键方面对前代 Llama 2 实现了显著提升，增强了其整体功能和性能：
1. 词汇量的扩大：Llama 3 的词汇量显著增加，从 Llama 2 的 32000 个标记扩展到 128256 个标记。这一扩展不仅提高了文本编码的效率，还显著增强了模型的多语言处理能力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/808172c285415cfc07eec015e02edfe5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a80f820a739e03d4b244c56250f02696/" rel="bookmark">
			python——井字棋游戏——代码（全）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章下面有井字棋全部代码和如何与上一篇登入界面进行连接
1.绘制九宫格窗口 我们先设置两个函数，一个函数里面储存九宫格，另一个函数储存主程序，之后我们调用主程序进行实现。
（1）设置窗口九宫格窗口 代码： import tkinter as tk def main(): root = tk.Tk() root.title("九宫格") root.geometry("500x600") if __name__ == "__main__": main() （2）画九宫格 canvas：可以在窗口中创建各种图形。
create:create 是 tkinter 中 Canvas 组件的方法之一，用于在画布上创建不同类型的图形。通过 create 方法，可以创建并添加各种图形对象到画布上，如矩形、椭圆、文本、线条等。
代码： def draw_grid(canvas): # 画外边框线 canvas.create_line(2, 2, 300, 2, width=2) # 上 canvas.create_line(2, 2, 2, 300, width=2) # 左 canvas.create_line(2, 300, 300, 300, width=2) # 下 canvas.create_line(300, 2, 300, 300, width=2) # 右 # 画横线 canvas.create_line(100, 0, 100, 300) canvas.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a80f820a739e03d4b244c56250f02696/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/399/">«</a>
	<span class="pagination__item pagination__item--current">400/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/401/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>