<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dd86d2ab7035a1c13771dc05bd5e010/" rel="bookmark">
			Spring-容器：IOC-基于XML管理Bean
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、概述1.1、定义1.2、简介1.3、作用1.4依赖注入1.4.1定义1.4.2作用1.4.3实现方式1.5实现 二、基于XML管理Bean（了解）2.1、获取Bean的方式2.2、依赖注入2.2.1、根据setter注入2.2.2、根据构造器注入 2.3、特殊值处理2.3.1、字面量赋值2.3.2、null值2.3.3、xml实体2.3.4、CDATA节 2.4、为对象类型属性赋值2.4.1、引用外部Bean2.4.2、引用内部Bean2.4.3、级联属性赋值 2.5、为数组类型属性赋值2.6、为集合类型属性赋值2.6.1、注入List集合类型属性值2.6.2、注入Map集合类型属性值2.6.3、注入引用集合类型属性值 2.7、引入P命名空间属性值2.8、引入外部属性文件2.9、引入Bean的作用域2.10、Bean的生命周期2.11、引入FactoryBean属性值2.12、引入xml自动装配 一、概述 1.1、定义 ​ IoC (Inversion of Control)，即控制反转，是一种设计模式或者说设计思想，它是面向对象编程中的一种概念，用来描述对象之间的依赖关系，指导我们如何设计出松耦合、更优良的程序。
1.2、简介 ​ Spring 通过 IoC 容器来管理所有 Java 对象的实例化和初始化，控制对象与对象之间的依赖关系。我们将由 IoC 容器管理的 Java 对象称为 Spring Bean，它与使用关键字 new 创建的 Java 对象没有任何区别。
1.3、作用 ​ 在 IoC 模式中，控制权从程序代码中转移到了容器中，即通过容器来管理对象的创建、销毁、依赖注入等操作，而应用程序本身只需要使用这些对象即可。这样，应用程序就不需要自己管理对象之间的依赖关系，而是由容器来管理，从而实现了代码的解耦和更好的可维护性，提高程序扩展力。
说明：
将对象的创建权利交出去，交给第三方容器负责将对象和对象之间关系的维护权交出去，交给第三方容器负责 1.4依赖注入 1.4.1定义 ​ 依赖注入（Dependency Injection，DI）是一种设计模式，其主要思想是在程序运行的过程中，通过外部容器（如Spring容器）动态地将依赖对象注入到程序中，以解耦对象之间的依赖关系，从而提高程序的灵活性、可维护性和可测试性。
1.4.2作用 ​ Spring通过依赖注入的方式来完成Bean管理的。换句话说，依赖注入，依赖注入实现了控制反转的思想。依赖指的是对象和对象之间的关联关系。注入指的是一种数据传递行为，通过注入行为来让对象和对象产生关系。
补充：
Bean管理说的是：Bean对象的创建，以及Bean对象中属性的赋值（或者叫做Bean对象之间关系的维护）。
1.4.3实现方式 第一种：set注入第二种：构造注入 1.5实现 ​ Spring 的框架中，IoC 容器是通过 BeanFactory 和 ApplicationContext 接口实现的。
BeanFactory 接口是 Spring 框架最底层的接口，提供了基本的 IoC 功能；ApplicationContext 接口是 BeanFactory 接口的子接口，提供了更高级的特性和功能，如 AOP、国际化、事件驱动等。其中BeanFactory 接口，最重要的方法是getBean()方法，用于从容器中获取对象。 ApplicationContext的主要实现类:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7dd86d2ab7035a1c13771dc05bd5e010/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/970a9af36158be99bda08811620b83d6/" rel="bookmark">
			数字证书、数字签名及其关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.数字证书与数字签名
1.数字证书是一个经证书授权中心数字签名的包含公开密钥拥有者信息以及公开密钥的文件。简单地说，数字证书是一段包含用户身份信息、用户公钥信息以及份验证机构数字签名的数据。
通俗理解：数字证书相当于【身份证】 —— 确认你是谁，用于确认身份
2.数字证书内容
数字证书由权威的第三方机构（CA，Certificate Authority）签发和管理的电子文档，内含密钥对（公钥和私钥）所有者的识别信息。主要包含：
证书的版本信息；
证书的序列号，每个证书都有一个唯一的证书序列号；
证书所使用的签名算法；
证书的发行机构名称；
证书的有效期；
证书所有人的名称；
证书所有人的密钥对；
证书发行者对证书的签名。
3.数字证书使用流程
证书申请：用户向CA机构提交个人信息和公钥，申请数字证书。
证书签发：CA机构验证用户身份后，将用户的公钥和个人信息绑定在一起，签发数字证书，并附上CA的签名信息。
证书使用：用户在网络通信中使用数字证书进行身份认证和数据加密/解密，接收方则通过验证数字证书来确认发送方的身份和数据的真实性。
4.PKI公钥体系
（1）PKI（Public Key Infrastructure，公钥基础设施）是一种基于公钥密码学的技术框架，用于安全地管理数字证书、公钥和私钥，从而确保通信和数据的机密性、完整性和身份验证。
（2）PKI的核心组件
数字证书颁发机构（CA）：PKI的核心组件，负责验证用户的身份并颁发数字证书。数字证书包含用户的公钥和身份信息，并由CA签名以确保证书的合法性。
注册机构（RA）：CA的合作伙伴，负责验证用户的身份和审核证书请求。RA通常处理与用户的直接接触，将身份验证结果传递给CA。
证书吊销列表（CRL）：由CA维护的列表，包含吊销的数字证书的信息。当用户的数字证书被吊销时，其信息将被添加到CRL中，以通知其他用户不再信任该证书。
数字证书：包含用户的公钥和身份信息，以及CA的数字签名。这些证书用于身份验证、加密和数字签名。
公钥基础设施目录（PKID）：一个全局目录服务，用于存储和分发公钥、证书和CRL，帮助用户查找和获取其他用户的证书。
（3）PKI的工作流程
注册：用户向CA或RA提交数字证书请求，并提供必要的身份信息。
身份验证：CA或RA对用户的身份信息进行验证，以确保其合法性。
证书颁发：如果身份验证成功，CA将为用户生成数字证书，包含用户的公钥和身份信息，并对证书进行数字签名。
证书发布：CA将颁发的数字证书发布到PKID或其他适当的目录服务中，以便其他用户访问。
证书使用：用户使用数字证书进行身份验证、加密通信和数字签名。
证书更新与吊销：数字证书通常具有有限的有效期，用户需要定期更新证书以保持其有效性。如果用户的私钥泄漏或其他原因，用户的数字证书需要吊销，CA将吊销信息发布到CRL中。
二.数字签名
1.数字签名是一种用于保证数字信息完整性、真实性和不可抵赖性的技术。它利用公钥加密技术，通过私钥对信息的摘要进行加密生成签名，接收方则使用公钥进行解密和验证。
数字签名相当于【持身份证进行签名】—— 作用对消息内容进行确认，确认的确是某人自愿签名，或是确实是某人发的消息
2.数字签名的原理
数字签名是基于非对称密钥加密技术与数字摘要技术的应用，是一个包含电子文件信息以及发送者身份，并能够鉴别发送者身份以及发送信息是否被篡改的一段数字串。一段数字签名数字串，包含了电子文件经过Hash编码后产生的数字摘要，即一个Hash函数值以及发送者的公钥和私钥三部分内容。发送方通过私钥加密后发送给接收方，接收方使用公钥解密，通过对比解密后的Hash函数值确定数据电文是否被篡改。
三.数字证书与数字签名关系及应用
1.数字签名和数字证书的关系
相互依赖：
数字签名依赖于数字证书中的公钥来验证签名的真实性。接收方在验证数字签名时，需要使用发送方证书中的公钥进行解密和验证。
同时，数字证书也需要通过数字签名来证明其有效性和可信度。CA在签发证书时，会使用自己的私钥对证书内容进行签名，接收方则使用CA的公钥进行验证。
共同保障信息安全：
数字证书和数字签名共同协作，可以大大提高网络通信的安全性和可靠性。数字证书确保了通信双方的身份真实可靠，而数字签名则确保了数据的完整性、真实性和不可抵赖性。
2.场景示例：用户A向用户B发送一段内容，但不想被窃取或篡改
（1）首先用户A对此内容进行 hash 运算【提取出摘要（hash值，就是一字符串）】，之后对此 hash 值用【自己的私钥】进行加密 —— 形成了数字签名
（2）之后用户A 将【数字签名（加密的内容hash值）】和【内容原文】一起发送给用户 B
（3）用户B通过之前用户A发送过来的证书 —— 获取【用户A的公钥】
此处证书的真伪，通过【公证机构CA】来辨别，每台机器上会【内置CA机构的证书，用来验证用户传来的证书】
此处证书确保了【用户A的公钥正确性，也就是用户A的身份真实性】
（4）用户B通过【证书中的公钥】，解开【数字签名（加密的内容hash值）】，获得【未加密的内容hash值】
（5）用户B通过与用户A相同的 hash 函数对【内容原文】进行hash运算，得到【摘要（hash值，就是一字符串）】，与步骤4中获取的【未加密的内容hash值】进行比较，从而判别内容是否被篡改
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/970a9af36158be99bda08811620b83d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a5380265cb22d914d09b7ba2785d585/" rel="bookmark">
			新增一个数组传递给后端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现的效果：
页面
&lt;div style="margin-bottom: 10px" v-if="totalPrice"&gt; &lt;p style="font-weight: bolder;margin-bottom: 10px"&gt; 支付计划 &lt;el-button type="text" size="small" @click="addPayInfo" icon="el-icon-plus"&gt;添加&lt;/el-button&gt; &lt;/p&gt; &lt;ul v-for="(p,i) of payList" :key="i" class="pay-info"&gt; &lt;li&gt; &lt;span&gt;第{{i+1}}笔支付金额:&lt;/span&gt; &lt;el-input v-model="p.price" @input="handleInput($event,i,'pay');onCalculate(p,i,createParams.commodityList[0].price)" :disabled="!mark &amp;&amp; p.is_amend" style="width: 200px;margin-right: 10px" size="small"&gt;&lt;/el-input&gt; &lt;/li&gt; &lt;li&gt; &lt;el-switch style="display: block" v-model="p.is_pay" :disabled="!mark &amp;&amp; p.is_amend" active-color="#13ce66" inactive-color="#ff4949" active-text="已支付" inactive-text="未支付"&gt; &lt;/el-switch&gt; &lt;/li&gt; &lt;li&gt; &lt;span style="vertical-align: top"&gt;备注：&lt;/span&gt; &lt;el-input type="textarea" v-model="p.desc" :disabled="!mark &amp;&amp; p.is_amend" style="width: 200px;margin-right: 10px" size="small"&gt;&lt;/el-input&gt; &lt;/li&gt; &lt;li&gt; &lt;el-button type="danger" size="mini" @click="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a5380265cb22d914d09b7ba2785d585/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1ca30c2d9d9ca75103684020509c209/" rel="bookmark">
			【2024数模国赛赛题思路公开】国赛C题思路丨附可运行代码丨无偿自提
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024年国赛C题解题思路
C 题 农作物的种植策略
根据乡村的实际情况，充分利用有限的耕地资源，因地制宜，发展有机种植产业，对乡村经济的可持续发展具有重要的现实意义。选择适宜的农作物，优化种植策略，有利于方便田间管理，提高生产效益，减少各种不确定因素可能造成的种植风险。
某乡村地处华北山区，常年温度偏低，大多数耕地每年只能种植一季农作物。该乡村现有露天耕地 1201 亩，分散为 34 个大小不同的地块，包括平旱地、梯田、山坡地和水浇地 4 种类型。平旱地、梯田和山坡地适宜每年种植一季粮食类作物；水浇地适宜每年种植一季水稻或两季蔬菜。该乡村另有16 个普通大棚和4 个智慧大棚，每个大棚耕地面积为0.6 亩。普通大棚适宜每年种植一季蔬菜和一季食用菌，智慧大棚适宜每年种植两季蔬菜。同一地块（含大棚）每季可以合种不同的作物。详见附件1。
根据农作物的生长规律，每种作物在同一地块（含大棚）都不能连续重茬种植，否则会减产；因含有豆类作物根菌的土壤有利于其他作物生长，从 2023 年开始要求每个地块（含大棚）的所有土地三年内至少种植一次豆类作物。同时，种植方案应考虑到方便耕种作业和田间管理，譬如：每种作物每季的种植地不能太分散，每种作物在单个地块（含大棚）种植的面积不宜太小，等等。2023年的农作物种植和相关统计数据见附件 2。
请建立数学模型，研究下列问题：
问题1 假定各种农作物未来的预期销售量、种植成本、亩产量和销售价格相对于 2023 年保持稳定，每季种植的农作物在当季销售。如果某种作物每季的总产量超过相应的预期销售量，超过部分不能正常销售。请针对以下两种情况，分别给出该乡村 2024~2030 年农作物的最优种植方案，将结果分别填入result1_1.xlsx 和result1_2.xlsx 中（模板文件见附件3）。
(1) 超过部分滞销，造成浪费；
(2) 超过部分按2023 年销售价格的50%降价出售。
【题目分析】
任务：在假定农作物的销售量、种植成本、亩产量和销售价格稳定的情况下，为乡村2024-2030年制定最优的种植方案。需要考虑两种情况：
滞销浪费：超出部分无法销售，需合理分配种植面积，避免浪费。降价出售：超出部分按50%的价格出售，这可能影响种植策略，需要平衡不同农作物的收益和种植面积。 【初步思路】
第一问的详细思路与建模过程
问题背景：
我们需要在假定农作物的销售量、种植成本、亩产量和销售价格稳定的情况下，为乡村2024-2030年制定最优种植方案。目标是最大化利润，并要考虑两种情况：
滞销浪费：超过部分无法销售，造成浪费。降价出售：超过部分按原售价的50%处理。 【解题思路】
一、问题转化为数学模型
1. 变量定义
地块变量： 记Ai 表示第 i 个地块的面积（亩），i=1,2,...,n，其中n=34 。每个地块可以种植不同的作物，记 Xu 为第i个地块种植第j种作物的面积（亩），j=1,2,...,m，其中 m 是作物种类。作物产量和价格： 记 Yj为第j种作物的单位面积产量（吨/亩），Pj 为该作物的单位售价（元/吨）。 成本和收益： 记 Cj 为种植第j种作物的单位面积成本（元/亩）。收益为作物销售量与售价的乘积，超出销售量部分按不同情况处理。 作物销售量约束： 设第j种作物的预期销售量为 Sj（吨），当种植量超过此值，需根据不同情况处理。 2. 目标函数
目标是最大化2024-2030年种植方案的总利润。首先，作物的总产量为：
基于此，作物的利润分为两种情况：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1ca30c2d9d9ca75103684020509c209/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4552c236edcea473b4e070dd0e4aad7/" rel="bookmark">
			2024年高教社杯数学建模国赛赛题浅析——助攻快速选题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一图流——一张图读懂国赛
总体概述：
A题偏几何与运动学模型，适合有几何与物理背景的队伍，数据处理复杂性中等。
B题侧重统计和优化，适合有运筹学和经济学背景的队伍，数据处理较为直接但涉及多步骤的决策优化。
C题属于优化类问题，涉及复杂的多变量优化与不确定性分析，数据处理难度大。
D题涉及概率和优化，特别是几何概率模型的推导，理论难度较高。
E题数据量较大，重点在于大规模交通数据的分析与优化，适合擅长交通工程和数据分析的队伍。
难度评估 A:B:C= 1.8:1.3:1 D:E=1.5:1 选题人数 A:B:C= 1:1.5:2.8 D:E=0.5:1.2 A题：“板凳龙”闹元宵 问题背景：这个题目基于“板凳龙”的传统民俗活动，要求模拟和优化舞龙队的行进过程，特别是在盘龙时的路径和速度控制。关键挑战是如何在规定的空间内，通过数学建模准确地描述各个龙节的位置和速度。
关键问题：
1. 建立各个龙节的运动模型，基于螺线方程描述其轨迹。
2. 优化路径，以确保各节之间不会发生碰撞。
3. 模拟调头过程，确保龙头和龙尾的协调动作，并优化调头曲线以减少长度。
4. 控制速度，确保舞龙过程中速度不会超出限制。
建模思路：
使用参数化的螺线方程描述舞龙的行进轨迹。
基于长度、螺距等约束条件，计算每个龙节的实时位置和速度。
通过曲率和速度的优化，保证不发生碰撞且速度平稳。
B题：生产过程中的决策问题 问题背景：该题目涉及企业生产管理，尤其是如何在产品零部件采购和生产的各个环节中做出最佳决策。重点是如何通过检测和拆解策略最小化成本，同时控制产品次品率。
关键问题：
1. 设计合理的抽样检测方案，帮助企业判断零部件的次品率是否超过标称值。
2. 在生产过程中决定是否对零部件和成品进行检测，以及是否拆解不合格品。
3. 综合考虑多个工序和零部件的情况，给出最优生产决策。
建模思路：
利用统计学中的抽样检验理论，设计低成本的抽样方案。
建立一个成本收益模型，综合考虑零件的次品率、检测成本、拆解费用和市场售价。
对于多工序生产，使用动态规划或线性规划等方法，优化整个生产流程的决策。
C题：农作物的种植策略 问题背景：该题目围绕乡村农作物的种植优化，目标是利用有限的耕地资源，在多种农作物之间制定最优的种植策略，从而提高收益并降低风险。
关键问题：
1. 基于农作物的销售量、种植成本和产量，制定最优的种植计划。
2. 在考虑农作物市场波动和气候变化的情况下，优化未来数年的种植策略。
3. 考虑不同农作物之间的互补性和替代性，进一步优化种植策略。
建模思路：
通过线性规划、整数规划等优化模型，确定在不同地块上的农作物种植面积。
将农作物的销售价格、成本和产量的不确定性引入模型，采用蒙特卡罗模拟或随机规划来进行风险分析。
利用协整分析或相关性分析，处理不同农作物之间的相互关系。
D题：反潜航空深弹命中概率问题 问题背景：该题目涉及反潜战术中的深弹投射，重点是通过数学模型来计算深弹命中潜艇的概率。
关键问题：
1. 分析投弹落点、深度引爆设置与命中概率之间的关系，并给出最大化命中概率的投弹方案。
2. 在考虑多重不确定因素的情况下，设计最优的投弹深度和阵列布局，以最大化命中概率。
建模思路：
结合随机变量的分布（如正态分布）来分析潜艇位置的误差。
利用几何概率计算深弹落点与潜艇的关系，推导命中概率的表达式。
在多弹投射时，使用阵列优化算法来设计落点分布，并最大化投弹的整体命中概率。
E题：交通流量管控 问题背景：该题目关注小镇道路上的交通流量优化，特别是在黄金周期间处理旅游车流的问题。核心是通过分析车流数据，优化信号灯配置和停车位管理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4552c236edcea473b4e070dd0e4aad7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b74964ae47f795d03965a18ce3567ae1/" rel="bookmark">
			【2024数学建模国赛赛题解析已出】原创免费分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024数模国赛赛题已正式发布
数模加油站初步分析评估了此次竞赛题目：
A题：偏数学+仿真建模，难度偏难，适合数学专业背景的同学
B题：评价决策类，自由度大，容易水，适合基础不太好的同学
C题：数据优化题，比去年简单，目前看难度最低
D题：几何建模题，偏数学，适合数学相关专业
E题：运筹优化类题目，对优化基础要求较高
整体难度： A＞B≥C
A＞D＞E＞B≥C
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/684307826b26254d8056d5706426778c/" rel="bookmark">
			《JavaEE进阶》----10.＜SpringMVC应用分层：【三层架构】＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇博客我们主要讲解
1.应用的分层：三层架构
2.Spring MVC和三层架构的区别和联系
3.软件设计原则：高内聚低耦合
4.应用分层的好处
5.通过应用分层后的代码示例
一、三层架构简介 阿里开发手册中,关于工程结构部分,定义了常见工程的应用分层结构:
上图的表示层，也叫做表现层。
解释概念 1.表现层（Controller）：展示数据结果和接收用户指令的，是最靠近用户的一层；
2.业务逻辑层（Service）：处理业务逻辑，里面有复杂业务的具体实现。
3.数据层（Mapper/Dao）：存储和管理与应用程序的相关的数据。
二、Spring MVC和三层架构的区别和联系 SpringMVC 三层架构 联系 二者其实是从不同角度对软件工程进行了抽象。 MVC模式强调数据和视图分离,将数据展示和数据处理分开,通过控制器对两者进行组合.
三层架构强调不同维度数据处理的高内聚和低耦合,将交互界面,业务处理和数据库操作的逻辑分开.角度不同也就谈不上互相替代了，在日常的开发中可以经常看到两种共存的情况，比如我们设计模型层的时候往往也会拆分出业务逻辑层（Service层）和数据访问层（Dao层）。 我的理解 区别
MVC架构模式组成：模型（Model）、视图（View）、控制器（Controller）
三层架构将业务应用分为：表现层、业务逻辑层、数据访问层。
Spring MVC：是对MVC思想在Spring框架中的一种实现。
三层架构是对代码处理的不同的逻辑功能的封层。
我觉得他们是两个独立的思想。
MVC是站在前后端共同开发时，对开发的理解。V对应前端，MC对应后端。
而如今我们已经前后端分离进行开发，因此实际上MVC的思想其实是有点过时的。
三层结构就是对我们纯后端代码的分层。
联系
但是他们有共同的目的，就是使我们开发程序更加的清晰有条理。
从概念上讲：二者都是软件工程领域中的架构模式。
并且三层架构中的表现层，对应MVC的视图和控制器，
而MVC中的模型对应三层架构的业务逻辑层，数据层，实体类。
二者的目的是相同的,都是"解耦，分层，代码复用"
三、软件设计原则：高内聚低耦合 高内聚低耦合矛盾吗? 不矛盾
高内聚：指的是一个模块中各个元素之间的联系的紧密程度。
低耦合：指的是各个模块之间的紧密程度。
比如一个企业中，各个部门关联关系要尽可能小，一个部门发生问题，要尽可能降低对其他部门的影响，就是低耦合。
但是部门员工关系要尽量紧密，遇到问题一起解决。这叫高内聚。
比如人体的各个部位中，手、脚、胳膊、腿之间的影响比较小，使得当手受伤，对其他部位影响很小，这就是低耦合。
而人体中，肌肉、骨骼、肌腱等需要相互配合，才能使得人们可以灵活运动。这就需要高内聚，紧密相连。
四、应用分层的好处 1.降低层与层之间的依赖，结构更加的明确，利于各层逻辑的复用。
2.开发人员可以只关注整个结构中的其中某一层，极大的降低了维护成本和维护时间
3.可以很容易的用新的实现来替换原有层次的实现
4.利于标准化。
五、通过应用分层后的代码示例 比如我们写的图书管理系统。如今我们主框架创建三个软件包。
1.Controller 2.Service 3. Mapper 六、SpringMVC大总结 1、十一个注解 对于SpringMVC。实际就学习各种Web开发需要用到的注解
a、@RequestMapping：路由映射
b、@RequestParam：后端参数重命名
c、@RequestBody：接收JSON类型的参数。
d、@PathVariable：接收路径参数
e、@RequestPart：上传文件
f、@ResponseBody：返回数据
g、CookieValue：从Cookie中获取值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/684307826b26254d8056d5706426778c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/097ecc2624488545704adb10c1ecde8f/" rel="bookmark">
			在Go中迅速使用RabbitMQ
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 认识1.1 MQ分类1.2 安装1.3 基本流程 2 [Work模型](https://www.rabbitmq.com/tutorials/tutorial-two-go#preparation)3 交换机3.1 fanout3.2 direct3.3 [topic](https://www.rabbitmq.com/tutorials/tutorial-five-go) 4 Golang创建交换机/队列/Publish/Consume/Bind5 可靠性5.1 生产者可靠性5.2 MQ可靠性5.2.1 Lazy Queue 5.3 消费者可靠性5.4 业务幂等性5.4 Golang实现可靠性1. 确保消息生产者的可靠性2. 确保消息队列的可靠性3. 确保消息消费者的可靠性4. 容错处理 6 延迟消息6.1 死信交换机6.2 延迟消息插件6.2.1 安装6.2.2 使用6.2.3 应用场景 为什么要使用消息队列 1 认识 1.1 MQ分类 有Broker
重Topic —— 在整个broker中，依据topic来进行消息中转。在重topic的MQ中必然需要topic —— kafka轻Topic —— topic只是一种中转模式 —— rabbitMQ 无Broker
1.2 安装 # latest RabbitMQ 3.13 docker run \ -e RABBITMQ_DEFAULT_USER=dusong \ #默认账号和密码均为：guest -e RABBITMQ_DEFAULT_PASS=123123 \ -d \ #detached mode -v mq-plugins:/plugins \ #插件挂载 --rm \ --name rabbitmq \ -p 5672:5672 \ #消息通信端口 -p 15672:15672 \ #管理界面端口 rabbitmq:3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/097ecc2624488545704adb10c1ecde8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61f0371f85ef87f1ae224f7492267ab7/" rel="bookmark">
			La-Z-Boy 标签制作注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在制作标签之前，供应商需要通过EDI向La-Z-Boy发送提前发货通知（ASN）。ASN中的每个明细行将会至少对应一个运输编号（shipment ID），这个信息将会被体现在运输标签上，和标签上的条形码一起，用于La-Z-Boy收货。
供应商必须确保其装箱单以及发票中的信息能够对应上该批次货物的运输标签以及相关运输编号。供应商可以在La-Z-Boy提供的标签文档中，找到La-Z-Boy EDI部门的联系邮箱，IT人员可以通过此邮箱与La-Z-Boy进一步沟通建立ASN连接。
La-Z-Boy Label类型与包装类型的对应关系 本文中托盘指外包装，箱子指内包装，结合客户生产实际可能用到不同的包装材料，不限于托盘、木箱、纸箱等。
LZB支持整托、混托(整箱)、散箱(整箱)三种包装方式，不同包装方式对应不同Label，尺寸均为B-10(4英寸 x 6英寸)。
1.整托（Full Pallet） 整托定义：托盘或集装箱上放置的货物完全由同一种产品组成的包装方式，所有物料对应同一个订单号。每个托盘上只放置一种SKU（库存单位），方便装卸和库存管理。主要用于大批量、单一产品的运输，如批发商、零售商的库存补货。不适合小批量、多品种的订单。
La-Z-Boy要求整托的货物中，每托或者每个集装箱需使用两张相同的Master Shipping Label。
箱子：每个箱子仍需一张Carton Label，用于装有相同产品（部件号）的单个容器，这个标签中将会详细说明箱子内容，标识产品的最小包装容器。
标签粘贴方式
示例：一个滑木箱（Skid）中运输的货物为：一个物料编号，一个采购订单编号。
叉车进入视图（正面）：每个纸箱贴箱贴，滑木箱右上角贴Master Shipping Label。
侧面：和正面相同的Master Shipping Label，贴在滑木箱左上角。
2.混托（Mixed Pallet） 混托定义：混托是指在一个托盘上放置多种不同产品（SKU）的包装方式。 一个托盘上包含多种产品或者多个采购订单组合，通常用于混合多种SKU以满足特定订单需求。灵活性高，能够满足小批量、多品种的订单需求，适合分销中心和零售店铺。常用于多样化订单的配送，有效利用运输空间，减少空托的情况，但装卸速度相对较慢，库存管理复杂，可能增加订单处理时间和成本。
La-Z-Boy要求混托的货物中，每托中每种物料号-订单号对需使用一张Mixed Shipping Label。
同时每个混托上还需要使用两张相同的Mixed Load Shipping Label，用于警示此集装箱为混合装载。
箱子：以上托盘+箱子结构中的每个箱子仍需一张Carton Label。
标签粘贴方式
零件号或者订单编号的组合装运时，需要使用 MIXED LOAD 和Mixed Load Shipping Label。
叉车进入视图（正面）：每个纸箱贴箱贴，滑木箱右上角贴MIXED LOAD Label，MIXED LOAD下方贴一个装有混合主标签（Mixed Master Labels）的透明塑料封套(每一对零件和订单号的组合需要一张标签)
侧面：和正面相同的MIXED LOAD，贴在滑木箱左上角。
3.散箱（Loose Cartons） 散箱定义：散箱是指单个或少量产品直接装箱，而非放置在托盘上的包装方式。产品通常直接放入纸箱或其他包装中，没有使用托盘进行组合。可以按需装箱，适合非常小批量或特殊产品的运输。
每个箱子需要一张Carton Label。同时，对于所有散箱还需一张Master Shipping Label。
La-Z-Boy Label 注意事项 运输编号（shipment ID） 供应商需要创建一个带有条形码的独一无二的运输编号，有两种命名规则。大多数情况下，运输编号是由La-Z-Boy 供应商账号（5位或6位数字）以及按顺序生成的9位数号码。供应商需要控制这个运输编号5年内不可以被重复使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61f0371f85ef87f1ae224f7492267ab7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e760174a5156c3e2b5d73b086925be51/" rel="bookmark">
			计算机毕业设计选题推荐-企业会议室管理系统-Java/Python项目实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨作者主页：IT研究室✨
个人简介：曾从事计算机专业培训教学，擅长Java、Python、微信小程序、Golang、安卓Android等项目实战。接项目定制开发、代码讲解、答辩教学、文档编写、降重等。
☑文末获取源码☑
精彩专栏推荐⬇⬇⬇
Java项目
Python项目
安卓项目
微信小程序项目
文章目录 一、前言二、开发环境三、系统界面展示四、代码参考五、论文参考六、系统视频结语 一、前言 随着企业规模的扩大和日常运营的复杂化，企业内部的会议活动频率显著增加。根据《2022年全球企业会议与活动管理趋势报告》显示，企业每年用于会议和活动的支出增长了10%，且大型企业的年均会议次数已达到200次以上。与此同时，会议室的管理和调度也变得愈发复杂。传统的会议室管理方式通常依赖人工记录和纸质登记，不仅效率低下，而且容易出现预定冲突、设备损坏未及时修复等问题，导致企业的会议活动受到影响。特别是在多部门、多会议室并行使用的情况下，会议室的资源浪费和使用不当现象频发，降低了办公效率和资源利用率。为了解决这些问题，开发一套智能化的企业会议室管理系统，通过信息化手段提高会议室使用效率，优化会议安排，已成为众多企业的迫切需求。此外，会议通知、投票和资料管理等附加功能的集成也能大大提升会议的管理水平和参会人员的体验。
现有的会议室管理方案普遍存在一些问题。首先，会议室的预定和使用信息管理较为混乱，常常依赖人工填写表单或简单的电子邮件申请，这种方式不仅容易产生遗漏和重复预定，还无法做到实时更新。例如，在会议高峰期，多个部门同时申请同一会议室的情况时有发生，管理人员难以及时协调，造成预定冲突。其次，设备报修、会议资料管理等功能分散，员工需要通过不同的系统或手段完成，这增加了操作的复杂性，也不利于集中管理。此外，许多现有系统缺乏灵活的会议通知和投票管理功能，参会人员无法及时获取会议变动信息，会议的参与度和互动性较低。因此，本课题的研究目标是设计并开发一套集会议室预定、设备报修、通知管理、会议投票和资料管理于一体的企业会议室管理系统，提升会议安排的自动化水平，优化资源分配，增强会议的互动性和参与体验。
本课题的研究具有重要的实际意义。首先，通过构建智能化的会议室管理系统，可以显著提高会议室的使用效率，减少因预定冲突和信息不透明导致的资源浪费和工作延误。管理员能够通过系统轻松管理会议室资源、处理预定申请和设备报修，并根据需求合理分配会议资源，提升企业内部的协作效率。其次，系统的会议通知和投票功能能够增强会议的互动性，参会人员可以及时获取会议通知、参与投票决策，从而提高会议的参与感和决策效率。此外，系统还集成了会议资料管理和设备报修等功能，员工可以通过统一平台查看会议资料、提交报修申请，减少了信息分散导致的操作复杂性。最终，该系统将为企业带来全面的会议管理解决方案，不仅提升了资源利用率，还改善了企业内部的沟通和决策效率，有助于企业提高整体运营效能。
在企业会议室管理系统中，管理员的功能模块设计涵盖了会议室资源的全面管理和企业内部会议活动的监督与支持。管理员可以进行员工管理，确保系统内用户信息的完整性和准确性；会议室管理和会议室分类管理，负责新增、删除和编辑会议室信息及其分类；审核会议预定，管理员可以查看并批准或拒绝会议室的使用申请；会议通知管理和会议资料管理功能用于发布和管理会议的相关信息和文件；管理员还可以通过会议投票管理模块组织并监督会议中的投票活动，查看员工的考勤情况并管理通知公告的发布；此外，管理员还能够通过意见收集管理模块获取员工的反馈，并通过设备报修回复功能对报修申请作出处理。员工的功能模块则侧重于会议室的使用和日常操作，包括查看会议室信息、提交会议室预定申请、查看并下载会议资料、参与会议投票活动、查看系统内发布的通知公告、通过系统打卡进行考勤，以及提交设备报修申请，通过这些功能模块实现对会议室资源的高效利用和会议活动的全流程参与。
角色：管理员、员工。
功能：
1）管理员：员工管理、会议室管理、会议室分类管理、审核会议预定、会议通知管理、会议资料管理、会议投票管理、查看员工考勤、通知公告管理、意见收集管理、设备报修回复。
2）员工：查看会议室信息、预定会议室、查看会议资料、会议投票、查看通知公告、考勤打卡、设备报修。
二、开发环境 开发语言：Java/Python数据库：MySQL系统架构：B/S后端：SpringBoot/SSM/Django/Flask前端：Vue 三、系统界面展示 企业会议室管理系统界面展示：
员工-查看会议室信息：
员工-查看会议资料：
员工-会议投票：
员工-查看意见收集：
管理员-首页数据统计：
管理员-首页数据统计：
管理员-会议资料管理：
四、代码参考 项目实战代码参考： @RestController @RequestMapping("/meetingRoom") public class MeetingRoomController { @Autowired private MeetingRoomService meetingRoomService; // 获取所有会议室信息 @GetMapping("/all") public ResponseEntity&lt;List&lt;MeetingRoom&gt;&gt; getAllMeetingRooms() { List&lt;MeetingRoom&gt; meetingRooms = meetingRoomService.list(); return ResponseEntity.ok(meetingRooms); } // 根据分类获取会议室信息 @GetMapping("/category/{categoryId}") public ResponseEntity&lt;List&lt;MeetingRoom&gt;&gt; getMeetingRoomsByCategory(@PathVariable Long categoryId) { QueryWrapper&lt;MeetingRoom&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e760174a5156c3e2b5d73b086925be51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4e877a83d5070634c88da5174796275/" rel="bookmark">
			策略模式实现搜索功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念： 策略模式是一种行为设计模式，用于定义一系列算法，将他们封装起来，并使他们可以互相替换。使用策略模式可以让代码更加灵活，且易于扩展和维护
背景： 假设你有一个功能需要多种不同的算法或行为实现（如不同的排序方式、不同的支付方式、不同的搜索方式等），这些行为是相似的。但是在细节上有所不同。
核心： 将这些可变的行为封装为不同的策略累，并定义一个接口来规范这些策略的实现。这样就可以在运行时动态切换策略，而不需要修改客户端的代码
用途： 1、替换不同的算法：可以根据需要动态的选择不同的算法或实现。比如不同的折扣策略，不同的支付方式
2、简化条件语句：用策略模式可以替换大量的if-else语句
3、提高可扩展性：新增一种行为时，只需要添加一个新的策略类，而不需要修改现有的代码
基本结构： 1、策略接口（Strategy Interface）：定义所有策略类必须实现的方法。
2、具体策略类（Concrete Strategy）：每个类实现具体的算法或行为。
3、上下文类（Context）：持有一个策略对象并调用策略的方法。
示例： 假设你有一个电商平台，根据用户的等级（普通用户、会员、VIP）给予不同的折扣。我们可以使用策略模式来实现不同的折扣逻辑。
1、定义策略接口
// 策略接口，定义计算折扣的方法 public interface IDiscountStrategy { decimal CalculateDiscount(decimal price); } 2、实现具体的策略类
// 普通用户的折扣策略：无折扣 public class NoDiscountStrategy : IDiscountStrategy { public decimal CalculateDiscount(decimal price) { return price; // 无折扣 } } // 会员的折扣策略：10% 折扣 public class MemberDiscountStrategy : IDiscountStrategy { public decimal CalculateDiscount(decimal price) { return price * 0.9m; // 10% 折扣 } } // VIP 的折扣策略：20% 折扣 public class VIPDiscountStrategy : IDiscountStrategy { public decimal CalculateDiscount(decimal price) { return price * 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4e877a83d5070634c88da5174796275/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c2ebc50dcd01d291914d14a394fd5f6/" rel="bookmark">
			JAVA多线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、多线程的状态 线程在一定条件下，状态会发生变化。线程一共有以下几种状态 新建状态（New): 创建一个新的线程对象就绪状态(Runnable): 线程对象创建后，调用该对象的start()方法，改线程就进入到就绪状态。这意味着线程已经准备好执行，等待系统分配处理器资源。运行（Running） ：线程获得了处理器资源，开始执行run()方法中的代码。这是线程处于活动状态的阶段。阻塞（Blocked）：线程在等待某个条件满足时进入阻塞状态。例如，线程可能在等待I/O操作完成或者等待获取锁。死亡状态(Dead)：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。 代码示例1多线程的几种状态 （无阻塞） public class MyThread{ public static void main(String[] args) throws Exception { Thread thread=new Thread(() -&gt; { System.out.println("线程进入可运行状态"); try { Thread.sleep(1000); // 让线程休眠1秒，模拟执行任务 } catch (InterruptedException e) { throw new RuntimeException(e); } }); // 打印线程初始状态 System.out.println("线程初始状态： " + thread.getState()); // 启动线程 thread.start(); // 打印线程可运行状态 System.out.println("线程可运行状态： " + thread.getState()); // 主线程等待子线程执行完毕 thread.join(); // 打印线程终止状态 System.out.println("线程终止状态： " + thread.getState()); } } 代码示例2线程的几种状态（包含阻塞） public class MyThread { private static Lock lock = new ReentrantLock(); private static Condition condition = lock.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c2ebc50dcd01d291914d14a394fd5f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/597eaadd1decef8e2e3c0b565d260e25/" rel="bookmark">
			手撕Python之函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.函数 定义函数的语法
def 函数名 :
代码语句
函数的作用：我们把需要反复执行的程序封装起来，制作成一个可以反复调用的工具，这个工具在编程中就叫函数
对于不同情况我们就调用对应的函数，可以减少代码量
简单函数的创建：
#对于函数，函数内的代码前面要有一个缩进，表示这些代码是属于这个函数的 def test(): print("存款") print("取款") print("查询") print("取卡") #def是函数创建的一个关键词 注意：函数不会主动进行编译的，需要我们手动进行调用的
下面就是如何对函数的调用
我们在使用函数的时候直接就是函数名()
比如说int()要加括号才能执行
#那么我们在创建好函数之后我们怎么进行函数的使用呢？ #注意：函数不会主动进行编译的，需要我们手动进行调用的 #使用函数（调用函数）---函数名() #对于这种调用的方法的话，我们之前的print() 和type() #都是函数，只不过里面的代码我们是不需要写的，之前就写好了的，我们直接调用进行使用就行李科 test() #这里我们成功调用函数 ''' 存款 取款 查询 取卡 ''' 使用函数之后我们的代码量就不会出现冗余的现象了
对于用户登录的题目我们是可以用函数的
注册：
#用户注册---reg def reg(): name=input("请输入注册的用户名：") while True: p1=input("请输入密码：") p2=input("请再次输入密码：") if p1==p2: students.append({'name':name,'password':p1})#p1是字符串我们得进行转换 print("注册成功")#那么我们就不用再输入密码了，我们就退出这个循环就行了 break else: print("两次密码要一致") #直到我们输入正确的密码之后我们就能跳出这个循环了 登录：
#用户登录---log def log(): name=input("请输入用户名：") for i in students: #i存在的是用户的信息字典 if name==i['name']: #对输入的用户名进行判断 for n in range(1,4): #循环3次进行输入密码的操作，如果输入正确直接跳出循环 pwd=input("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/597eaadd1decef8e2e3c0b565d260e25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3837346ab3e6db36f2cc5be36eb4a76f/" rel="bookmark">
			spring boot 项目 跟 JavaScript 简单 websocket 使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 websocket 简绍WebSocket 的优势包括：JavaScript 设置处理事件 Java 服务端设置导jar包创建WebSocket端点@EnableWebSocketregisterWebSocketHandlers 实现WebSocket处理器afterConnectionEstablishedafterConnectionClosedhandleTextMessage 注销WebSocket连接 自己定义一个 固定id 方便使用 websocket 简绍 WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议。WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。
WebSocket 的优势包括： 全双工通信：允许服务器主动向客户端发送信息，同时也能够提供客户端到服务器的低延迟通信。
减少带宽消耗：一旦建立连接之后，通信开销很小，因为不需要HTTP头部。
创建更丰富的交互体验：实时更新数据的能力，使得应用能够更加流畅地响应用户的动作
可以通过 JavaScript 的 WebSocket 对象来创建一个 WebSocket 连接。
var ws = new WebSocket('ws://localhost:8080'); JavaScript 设置 处理事件 WebSocket 对象提供了几个事件处理器来处理连接的状态变化：
open：连接成功建立时触发。
message：接收到消息时触发。
error：发生错误时触发。
close：连接关闭时触发。
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;WebSocket Example&lt;/title&gt; &lt;script&gt; document.addEventListener('DOMContentLoaded', function () { const socket = new WebSocket('ws://localhost:8080/websocket'); socket.onopen = function (event) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3837346ab3e6db36f2cc5be36eb4a76f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7297026b6cb1ab842435a19be6f5046c/" rel="bookmark">
			Java在智能数据挖掘系统的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		智能数据挖掘系统是利用机器学习、统计分析等技术从大量数据中自动或半自动地发现模式和知识的系统。Java作为一种流行的编程语言，因其强大的性能和丰富的生态系统，在智能数据挖掘领域的应用非常广泛。本文将探讨Java在智能数据挖掘系统中的应用，并提供示例代码。
智能数据挖掘系统概述
智能数据挖掘系统通常具备以下功能：
数据预处理：包括数据清洗、归一化、特征选择等。模式识别：识别数据中的模式，如分类、聚类、关联规则挖掘等。预测分析：基于历史数据对未来趋势进行预测。异常检测：识别数据中的异常或离群点。结果解释：提供对挖掘结果的解释和可视化。 Java在智能数据挖掘系统中的应用
丰富的机器学习库：Java有多种机器学习库，如Weka、MOA、Deeplearning4j等，提供数据挖掘所需的算法。大数据处理：Java与Hadoop、Spark等大数据处理框架的结合，可以处理大规模数据集。跨平台性：Java的跨平台特性使得数据挖掘应用可以部署在不同的操作系统上。图形用户界面：Java的Swing、JavaFX等技术可以开发友好的用户界面，提高用户体验。 示例代码
以下是一个简单的Java智能数据挖掘系统的示例代码，使用Weka库进行数据预处理和分类。
数据预处理类（DataPreprocessor.java）
import weka.core.Instances;
import weka.core.converters.ConverterUtils.DataSource;
import weka.filters.Filter;
import weka.filters.unsupervised.attribute.Normalize;
public class DataPreprocessor {
cnshydsy.com/4gh45s/
www.cnshydsy.com/4gh45s/
m.cnshydsy.com/4gh45s/
ntaiqiyi.com/4gh45s/
www.ntaiqiyi.com/4gh45s/
m.ntaiqiyi.com/4gh45s/
aoxiangqp.com/4gh45s/
www.aoxiangqp.com/4gh45s/
m.aoxiangqp.com/4gh45s/
public static Instances loadData(String fileName) throws Exception {
DataSource source = new DataSource(fileName);
Instances data = source.getDataSet();
return data;
}
public static void normalizeData(Instances data) throws Exception {
if (data.classIndex() == -1)
throw new Exception("Data has no class attribute specified.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7297026b6cb1ab842435a19be6f5046c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01f6785d05e82e7527f196c43293fba3/" rel="bookmark">
			【Nginx】反向代理原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、正向代理 说到反向代理，那也不得不提一下正向代理。
什么是正向代理？
正向代理是一种代理模式，它通常位于客户端，允许客户端通过它来发起请求到真正的目标服务器，从而隐藏客户端的身份或改善性能。
举个栗子，企业或学校网络中的代理服务器。
内部网络的用户必须通过这台代理服务器来访问互联网上的资源。
这样做的目的可能是为了实现上网内容过滤、缓存以加速访问和减少带宽消耗，或者是为了达到监控和控制用户上网行为的目的。
用户在浏览器或其他网络应用中配置代理服务器的地址和端口，所有对外的 HTTP 或 HTTPS 请求都会先发送到这个代理服务器，再由代理服务器转发到互联网上的目标服务器。 “梯子”的原理也是正向代理 二、反向代理 什么是反向代理？
反向代理是一种服务器端技术，它拦截来自客户端的请求，并作为客户端的代理向后端服务器发出请求，然后将结果返回给客户端。 举个栗子，使用如 Nginx 或 HAProxy 这样的软件来管理进入网站的流量。
在这种设置下，当用户尝试访问一个网站（比如 www.example.com）时，他们的请求实际上首先到达反向代理服务器。这个代理服务器根据一定的规则决定如何将请求路由到后台的多个实际服务器之一。
这种架构可以帮助负载均衡、提高安全性（因为外部世界只直接与代理服务器交互，而不是直接与后端服务器），并且可以提供 SSL 终止、压缩响应等附加服务。
三、总结 一句话总结，正向代理就是代理客户端，用户可以感受到；反向代理就是代理服务端，用户感受不到。
四、基础配置 使用 Nginx 做反向代理并不复杂，只需要简单的配置即可：
// 定义了一个新的服务器块（server block），用于处理特定域名或 IP 地址的请求 server { // 指定这个服务器块监听标准的 HTTP 端口 80 listen 80; // 指定了这个服务器块负责处理域名为 example.com 的请求 server_name example.com; // 定义了一个位置块（location block），这里设置的是对根路径/的所有请求都将被代理到另一个服务器 location / { // 配置了代理的行为，告诉 Nginx 将所有针对/的请求转发到本地主机的 8000 端口上 // 这里的localhost指的是运行 Nginx 服务器的机器本身 proxy_pass http://localhost:8000; // 设置了代理传递给后端服务器的 Host 头部信息 // 这使得后端服务器知道原始请求的目标主机名 proxy_set_header Host $host; // 设置了 X-Real-IP 头部，让后端服务器知道原始客户端的真实 IP 地址 proxy_set_header X-Real-IP $remote_addr; // 这个指令用于添加或修改 X-Forwarded-For 头部 // 该头部包含了客户端和代理之间的完整 IP 地址列表 // 如果请求经过了多个代理，这些代理会依次追加它们的信息到这个头部字段中 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } } 这段配置的作用是：当有请求到达 example.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01f6785d05e82e7527f196c43293fba3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa46f3e5e4cde1f1b055ee784e4c56dc/" rel="bookmark">
			IntelliJ Idea 常用快捷键列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ctrl+Shift + Enter，语句完成
“！”，否定完成，输入表达式时按 “！”键
Ctrl+E，最近的文件
Ctrl+Shift+E，最近更改的文件
Shift+Click，可以关闭文件
Ctrl+[ OR ]，可以跑到大括号的开头与结尾
Ctrl+F12，可以显示当前文件的结构
Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择
Ctrl+N，可以快速打开类
Ctrl+Shift+N，可以快速打开文件
Alt+Q，可以看到当前方法的声明
Ctrl+P，可以显示参数信息
Ctrl+Shift+Insert，可以选择剪贴板内容并插入
Alt+Insert，可以生成构造器/Getter/Setter等
Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义
Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catch
Ctrl+Enter，导入包，自动修正
Ctrl+Alt+L，格式化代码
Ctrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作
Ctrl+Alt+O，优化导入的类和包
Ctrl+R，替换文本
Ctrl+F，查找文本
Ctrl+Shift+Space，自动补全代码
Ctrl+空格，代码提示（与系统输入法快捷键冲突）
Ctrl+Shift+Alt+N，查找类中的方法或变量
Alt+Shift+C，最近的更改
Alt+Shift+Up/Down，上/下移一行
Shift+F6，重构 – 重命名
Ctrl+X，删除行
Ctrl+D，复制行
Ctrl+/或Ctrl+Shift+/，注释（//或者/**/）
Ctrl+J，自动代码（例如：serr）
Ctrl+Alt+J，用动态模板环绕
Ctrl+H，显示类结构图（类的继承层次）
Ctrl+Q，显示注释文档
Alt+F1，查找代码所在位置
Alt+1，快速打开或隐藏工程面板
Ctrl+Alt+left/right，返回至上次浏览的位置
Alt+left/right，切换代码视图
Alt+Up/Down，在方法间快速移动定位
Ctrl+Shift+Up/Down，向上/下移动语句
F2 或 Shift+F2，高亮错误或警告快速定位
Tab，代码标签输入完成后，按 Tab，生成代码
Ctrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失
Alt+F3，逐个往下查找相同文本，并高亮显示
Ctrl+Up/Down，光标中转到第一行或最后一行下
Ctrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处）
Ctrl+Alt+B，跳转到方法实现处
Ctrl+Shift+Backspace，跳转到上次编辑的地方
Ctrl+O，重写方法
Ctrl+Alt+Space，类名自动完成
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa46f3e5e4cde1f1b055ee784e4c56dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e69e00fc61828b9e08c2285fc5359d5/" rel="bookmark">
			tomcat日志显示中文乱码的方法解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.修改tomcat的logging.properties 把以下都改为GBK: 1catalina.org.apache.juli.FileHandler.level = FINE
1catalina.org.apache.juli.FileHandler.directory = ${catalina.base}/logs
1catalina.org.apache.juli.FileHandler.prefix = catalina.
1catalina.org.apache.juli.FileHandler.encoding = GBK
2localhost.org.apache.juli.FileHandler.level = FINE
2localhost.org.apache.juli.FileHandler.directory = ${catalina.base}/logs
2localhost.org.apache.juli.FileHandler.prefix = localhost.
2localhost.org.apache.juli.FileHandler.encoding = GBK
3manager.org.apache.juli.FileHandler.level = FINE
3manager.org.apache.juli.FileHandler.directory = ${catalina.base}/logs
3manager.org.apache.juli.FileHandler.prefix = manager.
3manager.org.apache.juli.FileHandler.encoding = GBK
4host-manager.org.apache.juli.FileHandler.level = FINE
4host-manager.org.apache.juli.FileHandler.directory = ${catalina.base}/logs
4host-manager.org.apache.juli.FileHandler.prefix = host-manager.
4host-manager.org.apache.juli.FileHandler.encoding = GBK
2.项目启动时候加上： -Dfile.encoding=GBK
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abe56eae73973663a914034e49d2722c/" rel="bookmark">
			Java——IDEA使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、IDEA介绍 IntelliJ IDEA 是 JetBrains 公司开发的一款功能强大的集成开发环境（IDE），主要用于 Java 编程语言，但也支持多种其他语言和框架。由于其强大的功能和灵活性，IntelliJ IDEA 被广泛应用于软件开发领域，并被认为是市场上最优秀的 IDE 之一。
二、IDEA使用 1、汉化 IDEA默认支持的是英语，我们可以下载简体中文插件。首先点击右上角的设置图标，进入如图的设置界面：
然后找到左边栏的 Plugin（插件） 选项，找到中文简体包插件，然后点击 Install 安装选项，然后点击 Restart IDE 按钮，
然后就是重启 IDEA：
然后发现已经被汉化了。
2、设置字体 点击左上角的设置图标，进入设置界面，如下图：
找到编辑器（Editor）选项，找到字体（Font），就可以设置编辑器的字体。如果你要修改菜单和导航栏的字体与字体大小就参照下图的步骤：
3、设置缩进 找到最右下角的这个导航栏，点击这个4个空格这个地方：
然后就出现了以下列表：
然后就选择为 Java 配置缩进，然后可以看到以下界面：
点击使用制表符缩进就是使用制表符，不勾选制表符就是使用空格作为缩进。
可以发现导航栏还有很多选项，可以对更多地方进行更细致的配置，这里就不详细介绍了。
三、IDEA快捷键 1、按键映射 快捷键可以让我们对工具的使用更方便快捷，这里介绍几个IDEA的快捷键，详细更多快捷键可以在设置中的按键映射（英文模式下为 Keymap ）中看到：
我们可以在这里对快捷键进行改动。
在这里可以看到可以映射更多软件的快捷键：
2、简单介绍 1）删除光标所在的行 可以在搜索框中搜索你要修改的快捷键。
我这里的快捷删除整行是自己更改至 Ctrl + D 的。默认是 Ctrl + Y，可能与其他快捷键有冲突。你可以选择自己熟悉的快捷键进行配置。设置完毕后记得点击 OK 按钮以保存。
2）注释一行 行注释默认的是 Ctrl + / 。编辑器一般都使用这个快捷键作为注释行快捷键。第一次注释，第二次取消注释。
3）复制并粘贴一行 复写一行，一般快捷键是 Ctrl + D，这里的作用一般是赋值这一行然后再在这行的下一行粘贴。
4）补全单词 多次使用，就会循环显式要补全的候选词。快捷键默认是 Alt + /。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abe56eae73973663a914034e49d2722c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dba16a8257ebc5bbf28077cf255c3c67/" rel="bookmark">
			力扣172.阶乘后的0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 class Solution { public int trailingZeroes(int n) { int ans = 0; //本质：每5个数有一个5的倍数，每25个数有一个25的倍数…… int num = 5; while(n / num != 0) { ans += n/num; num *= 5; } return ans; } } 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/3/">«</a>
	<span class="pagination__item pagination__item--current">4/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/5/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>