<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d1e37bb57bb356084a5b397f289e61b/" rel="bookmark">
			java调用DLL保姆级教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工作中有部分业务需要调用三方的dll文件，在网上搜集资料后测试调用成功，如下笔记希望能帮到你们！
Java可以使用Java Native Interface （JNI）来调用DLL文件。
1. 定义Native方法：使用Java的关键字“native”定义Java的方法，这个方法将在DLL文件中被实现。
2. 生成Java头文件：使用Java Development Kit中的Javah工具会生成一个C头文件（JavaNativeInterface.h）。
3. 创建一份C源文件，并实现JNI方法：导入生成的JavaNativeInterface.h头文件、实现Java方法中的native方法，并声明一个JNIEXPORT返回类型与Java方法返回类型相同的函数。
4. 将生成的C源文件编译成DLL文件：在Visual Studio中创建一个DLL项目并将源文件添加进来。生成DLL文件。
5. 加载DLL文件并调用方法：在Java中使用System.loadLibrary() API加载DLL文件。然后就可以使用Java的native方法来调用DLL文件中的函数了。
以下是代码示例，要使用此示例，首先需要使用Visual Studio进行两个步骤：
（1）编写DLL项目代码
（2）生成DLL库。
Dll_Test.h：
#ifndef __DLL_TEST_H__ #define __DLL_TEST_H__ #ifdef __cplusplus extern "C" { #endif JNIEXPORT jint JNICALL Java_com_zeroin_myapp_DllTest_nativeAdd (JNIEnv *, jobject, jint, jint); JNIEXPORT jstring JNICALL Java_com_zeroin_myapp_DllTest_nativeHelloWorld (JNIEnv *, jobject); #ifdef __cplusplus } #endif #endif Dll_Test.c：
#include "com_zeroin_myapp_DllTest.h" JNIEXPORT jint JNICALL Java_com_zeroin_myapp_DllTest_nativeAdd(JNIEnv *env, jobject obj, jint a, jint b) { return a + b; } JNIEXPORT jstring JNICALL Java_com_zeroin_myapp_DllTest_nativeHelloWorld(JNIEnv *env, jobject obj) { return (*env)-&gt;NewStringUTF(env, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d1e37bb57bb356084a5b397f289e61b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/803c2438ecba74f460e8941e19644468/" rel="bookmark">
			【ADB】电脑通过ADB向手机传输文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 具体步骤如下：
Step1 下载ADB工具 下载最新版本的 ADB工具
!!! 注意：一定要是最新版本的ADB，否则很可能导致无法识别到手机。
将下载的ADB解压以后的文件如下图所示：
Step2 添加环境变量 将 ADB的路径 D:\platformtools （根据你的情况进行选择）添加到环境变量即可。
Step3 验证是否正确安装 打开 cmd 并输入 adb version 显示如下内容表示正确安装
Step4 手机打开开发者模式 不同手机打开开发者模式的方法不同，请自行搜索
Step5 查看手机是否成功连接 输入 adb devices 将会显示设备列表
Step6 进行文件传输 将指定文件传输到手机的 /sdcard/download 目录下
adb push 文件路径 /sdcard/download 常用指令
指令说明adb help查看帮助信息adb start-server开启adb服务adb kill-server关闭adb服务adb devices查看设备信息 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbe1795811b6cb31357830473da5d18f/" rel="bookmark">
			路径规划最全综述&#43;代码&#43;可视化绘图（Dijkstra算法&#43;A*算法&#43;RRT算法等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		路径规划综述 1. 背景介绍 路径规划是指在给定的环境中找到从起点到终点的最佳路径的过程。它在现实生活中有着广泛的应用，包括无人驾驶、物流配送、机器人导航等领域。随着人工智能和计算机技术的发展，路径规划技术也在不断地得到改进和应用。
路径规划中常见的算法可以分为两类：基于搜索的规划和基于采样的规划。
基于搜索的规划包括 Breadth-First Searching (BFS)、Depth-First Searching (DFS)、Best-First Searching、Dijkstra’s、A*、Bidirectional A*、Anytime Repairing A*、Learning Real-time A* (LRTA*)、Real-time Adaptive A* (RTAA*)、Lifelong Planning A* (LPA*)、Dynamic A* (D*)、D* Lite 和Anytime D* 等算法。这些算法通过搜索图形结构来找到最短或最优的路径，其中 A* 是最为常用和经典的算法之一。
优缺点比较 BFS（Breadth-First Searching）
优点：可找到最短路径；适用于无权图。 缺点：时间复杂度高；空间复杂度高。
DFS（Depth-First Searching）
优点：空间复杂度低。
缺点：可能会陷入死循环；不一定能找到最短路径。
Best-First Searching
优点：速度快；可以处理启发式信息。 缺点：可能会陷入局部最优解。
Dijkstra’s
优点：可以找到最短路径；适用于有权图。 缺点：时间复杂度高；不能处理负权边。
A*
优点：速度快；可以处理启发式信息；可以找到最短路径。 缺点：可能会陷入局部最优解。
Bidirectional A*
优点：速度快；可以找到最短路径。 缺点：需要存储两个搜索树；可能会出现问题，例如搜索空间过大或搜索树生长过慢。
Anytime Repairing A*
优点：可以在任何时候停止搜索并返回最佳路径；可以处理启发式信息。
缺点：可能会陷入局部最优解。
LRTA* (Learning Real-time A*)
优点：可以处理动态环境；可以处理启发式信息。 缺点：需要进行实时计算，可能会导致性能问题。
RTAA* (Real-time Adaptive A*)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbe1795811b6cb31357830473da5d18f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9a56d65863cb3e86e0e1902381890c1/" rel="bookmark">
			公网环境使用navicat图形化工具远程连接本地MariaDB数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 配置MariaDB数据库1.1 安装MariaDB数据库1.2 测试局域网内远程连接 2. 内网穿透2.1 创建隧道映射2.2 测试随机地址公网远程访问3. 配置固定TCP端口地址3.1 保留一个固定的公网TCP端口地址3.2 配置固定公网TCP端口地址3.3 测试固定地址公网远程访问 本篇教程将使用cpolar内网穿透本地MariaDB数据库，并实现在外公网环境下使用navicat图形化工具远程连接本地内网的MariaDB数据库。
1. 配置MariaDB数据库 1.1 安装MariaDB数据库 进入MariaDB数据库官网https://mariadb.com/downloads/community/,然后下载相应的windows版本
下载好后点击安装,出现设置密码界面设置一下密码,mariaBD和mysql使用同样的端口,如本机已经安装mysql,在安装过程中需要更改mariaDB端口,或者卸载mysql
1.2 测试局域网内远程连接 安装成功后使用连接工具测试是否能连接,这里使用navicat进行测试连接
测试局域网内连接成功
2. 内网穿透 本地测试连接没问题后,我们来做内网穿透，将其发布到公网环境下进行远程访问。
因为该数据库目前只能在局域网内被访问，但是我们可以使用cpolar内网穿透工具，将内网的MariaDB数据库映射到公网上，实现远程访问。
2.1 创建隧道映射 cpolar官网：https://www.cpolar.com/
进入cpolar官网下载页面,下载windows安装包到本地然后解压一路默认安装即可
cpolar安装成功后，双击打开cpolar【或者在浏览器上访问本地9200端口 127.0.0.1:9200】，使用cpolar邮箱账号登录 web UI管理界面，如果还没有注册cpolar账号的话，点击免费注册，会跳到cpolar官网注册一个账号就可以了.
登录成功后，点击左侧仪表盘的隧道管理——创建隧道，创建一个tcp协议的隧道指向本地3306端口:
隧道名称：可自定义，注意不要与已有的隧道名称重复协议：tcp本地地址：3306域名类型：免费选择随机域名地区：默认China top即可 点击创建
隧道创建成功后，点击左侧的状态——在线隧道列表，可以看到，刚刚创建的隧道已经有生成了相应的公网地址，将其复制下来
2.2 测试随机地址公网远程访问 打开navicat,输入tcp公网地址:3.tcp.cpolar.top端口号11241,然后点击测试连接,出现连接成功即可
3. 配置固定TCP端口地址 由于以上创建的隧道使用的是随机地址隧道,地址会在24小时内变化,为了使连接更加稳定,我们可以将其配置为固定的tcp连接地址。
需要注意，配置固定TCP端口地址需要将cpolar升级到专业版套餐或以上。
3.1 保留一个固定的公网TCP端口地址 登录到cpolar官网后台，点击左侧的预留，选择保留的TCP地址，我们先来为远程MariaDB保留一个固定端口地址。
地区：选择China VIP描述：即备注，可自定义填写 点击保留
地址保留成功后，系统会生成相应的固定公网地址，将其复制下来，接下来将其配置到隧道中。
3.2 配置固定公网TCP端口地址 在浏览器上访问9200端口，http://127.0.0.1:9200/，登录cpolar web ui管理界面，点击左侧仪表盘的隧道管理——隧道列表，找到mariaDB隧道，点击右侧的编辑
修改隧道信息，将保留成功的固定tcp地址配置到隧道中
端口类型：修改为固定tcp端口预留的tcp地址：填写保留成功的地址 点击更新
隧道更新成功后，点击左侧仪表盘的状态——在线隧道列表，找到需要编辑的隧道，可以看到公网地址已经更新成为了固定tcp地址。
3.3 测试固定地址公网远程访问 测试使用固定TCP端口地址远程mariaDB,我们再次打开navicat,使用固定tcp地址连接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebfa1ec004073e559a63497827f30ec0/" rel="bookmark">
			Java接入微信支付超级详细教程【保姆级】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍了“二维码付款”的代码。其他微信支付方式的代码都在源码中。
一、准备开发所需的账号以及配置信息 首先想要接入微信支付我们需要两个玩意：
一是公众号/小程序/企业微信（开发用的）这个是为了获取 APPID
一是微信支付商户（收钱用的） 获取 api_key mch_id
1、前往：https://mp.weixin.qq.com/ （微信公众平台）注册一个应用，类型只能是：公众号/小程序/企业微信，注册完成需要完成”微信认证“（微信需要收取300元）。
2、前往：https://pay.weixin.qq.com（微信支付商户平台）注册一个商户，支付成功后的钱就会在这个账号里面。
​ 1、APPID：应用id也就是 公众号/小程序的ID
​ 2、Api_key： 对应的APIv2密钥
​ 3、mch_Id：商户ID （收钱的商家ID）对应的是 【微信支付商户号】
4.将申请的下来的APPID绑定到商户号下，添加成功后再次到工作号里面
【广告与服务—&gt;微信支付】这个时候会看到关联申请，同意就可以了。到这一步前置工作就完成了
二、准备环境 项目采用SpringBoot
微信支付有两种版本：V3和V2，本文的接入版本为V2
1、导入jar包
1.1微信支付jar包
&lt;dependency&gt; &lt;groupId&gt;com.github.wxpay&lt;/groupId&gt; &lt;artifactId&gt;wxpay-sdk&lt;/artifactId&gt; &lt;version&gt;0.0.3&lt;/version&gt; &lt;/dependency&gt; 1.2导入hutool工具类jar包
&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.8.12&lt;/version&gt; &lt;/dependency&gt; 2、设置开发参数
如果自己就是商户 那么可以将参数设置到配置文件application.yml中，如果是多商户则建立商户收款配置表 将信息维护到数据库中
在application.yml，设置好开发参数
pay: appid: wx123456789a439 #微信公众号appid api_key: gwxkjvfewvfabvcrxgrawvgs924ceaxj #公众号设置的api密钥 mch_id: 1603596731 #微信商户平台 商户id 本文是多商户
数据库参考
微信支付工具类
package com.manage.common.utils; import javax.net.ssl.HttpsURLConnection; import javax.servlet.http.HttpServletRequest; import java.io.*; import java.net.URL; /** * 微信支付工具类 * */ public class WxChatPayCommonUtil { /** * 发送 http 请求 * @param requestUrl 请求路径 * @param requestMethod 请求方式(GET/POST/PUT/DELETE/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebfa1ec004073e559a63497827f30ec0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46fb41d070f820c4786fdf84ef7fd3b3/" rel="bookmark">
			java取出list中的某几个属性组成一个新的集合的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我用了三种方式,1:forEach循环;2:for循环;3:stream方法
package org.springblade.test; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.stream.Collectors; public class Test { @org.junit.jupiter.api.Test public void aaa() { User user1 = new User("张三", 10, 1); User user2 = new User("李四 ", 11, 1); User user3 = new User("王五", 12, 0); List&lt;User&gt; users = new ArrayList&lt;&gt;(); users.add(user1); users.add(user2); users.add(user3); //我这里都转为了List&lt;Map&lt;String, Object&gt;&gt;数组,也可以转换为一个新的实体类(自行创建) //使用forEach循环转化 List&lt;Map&lt;String, Object&gt;&gt; infosFromForEach = new ArrayList&lt;&gt;(); users.forEach(user -&gt; { Map&lt;String, Object&gt; singleMap = new HashMap&lt;&gt;(); singleMap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46fb41d070f820c4786fdf84ef7fd3b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6ed6ac3ceb43e321a780be4bb710122/" rel="bookmark">
			小程序嵌套H5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在微信小程序中内嵌H5页面是一种常见的需求，因为H5页面具有灵活性和跨平台性，可以弥补小程序原生代码的不足。
微信小程序自带的 web-view 组件相当于 HTML页面中的 iframe ，方便我们在微信小程序中打开一个 H5 页面；从微信小程序基础库1.6.4开始，我们就可以在小程序内放置一个&lt;web-view&gt;组件来链接我们的HTML页面了。
web-view使用前提：业务域名 由于个人类型的小程序暂不支持使用。只有非个人类型小程序可以配置业务域名
1、扫码登录微信公众平台；
2、开发管理 —— 开发设置 —— 业务域名 进行添加、修改；
3、配置完业务域名后，还需要下载校验文件（步骤2中第四张图的红色框部分），并将校验文件放置在域名根目录下（让后端去操作）。这一步相当于是让对方授权你能打开他的网页，比如要在你的小程序中打开百度，就需要百度去把这个校验文件放到他的域名根目录下得到他的授权；
4、设置业务域名时，报检查校验怎见石板，可以参考业务域名设置--校验文件检查失败自查指引 微信开放社区进行自查。
web-view链接打不开问题 打不开某个外部网页链接：
检查是否配置了小程序的业务域名，注意外部网页内再次 iframe 内嵌的其他域名也需要配置
检查是否为 https 协议，不支持http协议，不支持 IP 地址
打不开公众号文章：检查小程序是否已关联该公众号
外部网页链接、公众号文章链接在开发工具、体验版上可以打开，正式版上不行：
检查开发工具上是否开启了 “ 不校验合法域名、web-view业务域名、TLS版本以及HTTPS证书 ” 选项，开发工具上开启这个选项，不用配置业务域名或关联小程序也能打开链接，在开发工具上将该选项关掉，也就打不开了，该选项位置如下图；体验版上能打开是因为打开了 “ 开发调试 ”，关闭开发调试后，同样也是打不开。
web-view的基本使用 官方web-view组件使用：web-view | 微信开放文档
每个页面只能有一个 web-view组件，并且 web-view组件将默认展示在最高层级
index.wxml
&lt;view class="page-body"&gt; &lt;web-view src="{{webUrl}}"&gt;&lt;/web-view&gt; &lt;/view&gt; index.js
data: { webUrl: app.globalData.BASE_URL + "contacts" }, H5页面和小程序跳转及传参 web-view提供的跳转接口 跳转基本流程 在小程序中新建一个web-view组件，指定URL为要嵌入的H5页面的链接。
在H5页面中添加微信小程序JS SDK的引入，在H5页面中可以通过JS SDK调用小程序API。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6ed6ac3ceb43e321a780be4bb710122/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b1f36cff518c9d827b0d65adcbd961e/" rel="bookmark">
			【PostGIS】PostgreSQL15&#43;对应PostGIS安装教程及空间数据可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、PostgreSQL15与对应PostGIS安装 PostgreSQL15安装：下载地址PostGIS安装：下载地址（选择倒数第二个） 1、PostgreSQL安装 下载安装包；开始安装，这里使用默认安装，一直next直到安装完成；在系统环境变量中，添加PG_HOME变量：
在Path中新增：%PG_HOME%\bin\ ；在cmd中使用命令：psql --version 查看是否配置成功；
配置完成后，在cmd中启动postgreSQL服务【重要】：
pg_ctl -D D:\ProgramFile\postgresql\15\data start 其中-D后面的路径是postgresql的安装路径下的data文件夹；
确保服务成功启动后，安装postGIS。 2、PostGIS安装 下载安装包；开始安装，使用默认安装，一直点next即可（安装进行到下面这个页面时，第二个选项可选可不选，功能是创建一个数据库模版）；
安装完成后，打开Navicat，新建一个postgreSQL连接：
连接成功后，可以看到之前安装时选择的模版：
如果安装时没有选择模版，也可以手动在查询语句中添加扩展和空间函数支持： -- Enable PostGIS (as of 3.0 contains just geometry/geography) CREATE EXTENSION postgis; -- enable raster support (for 3+) CREATE EXTENSION postgis_raster; -- Enable Topology CREATE EXTENSION postgis_topology; -- Enable PostGIS Advanced 3D -- and other geoprocessing algorithms -- sfcgal not available with all distributions CREATE EXTENSION postgis_sfcgal; -- fuzzy matching needed for Tiger CREATE EXTENSION fuzzystrmatch; -- rule based standardizer CREATE EXTENSION address_standardizer; -- example rule data set CREATE EXTENSION address_standardizer_data_us; -- Enable US Tiger Geocoder CREATE EXTENSION postgis_tiger_geocoder; 【注意】要使用postGIS扩展必须保证postgreSQL服务启动，即postgreSQL安装中的第六步，添加了postGIS扩展后，就可以开始使用了：常见的空间函数见这篇文章 二、空间数据可视化 如果想可视化postGIS中的数据，可以使用QGIS查看，QGIS下载地址。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b1f36cff518c9d827b0d65adcbd961e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2f433c3aeb45e4823b6a2d7ad740335/" rel="bookmark">
			Stable Diffusion官方模型下载地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.5版本下载 https://huggingface.co/runwayml/stable-diffusion-v1-5/tree/main
模型包：v1-5-pruned.safetensors
2.1版本下载 https://huggingface.co/stabilityai/stable-diffusion-2-1/tree/mainmmd
模型包：v2-1_768-ema-pruned.safetensors
sdxl-1.0版本下载 https://huggingface.co/stabilityai/stable-diffusion-xl-base-1.0/tree/maink
模型包： sd_xl_base_1.0.safetensors
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ab00fe4bc631cd84ac0b2a53d5b9ca7/" rel="bookmark">
			处理解决运行前端脚手架工程报错： ‘vue-cli-service‘ 不是内部或外部命令，也不是可运行的程序 或批处理文件。附带 Linux
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、场景介绍
二、处理方式
1、 如果 package.json 配置没有 vue-cli-server 那么就安装它即可，注意安装完毕需重启编辑器启动项目，避免依赖添加不生效问题
2、如果 package.json 配置有 vue-cli-server 或者安装了还是没好，可以看看 node_modules 工程模块是否存在，如果没有请安装。
3、 如果上面两个条件都存在，却还是不行，那就是网络不稳定导致运行下载时包缺失，可以清掉 node_modules 后再次安装，我有4种方式，可以根据需求来
三，总结：以上任意步骤处理完，都最好重启编辑器后，重新启动项目
一、场景介绍 相信大家开发或者维护中，一定有运行过Vue脚手架工程吧，那么在运行时报错'vue-cli-service' 不是内部或外部命令，这个问题肯定也会经常遇到，我也是在多次运行时遇到过，所以在此分享下我的处理经验。
二、处理方式 遇到该情况的原因有三个，第一个就是要在我们工程的 package.json 配置文件中查看是否有 vue-cli-server，如果没有则需安装，第二个是因为缺少 node_modules 模块，第三就是网络不稳定导致运行下载时包缺失。
1、 如果 package.json 配置没有 vue-cli-server 那么就安装它即可，注意安装完毕需重启编辑器启动项目，避免依赖添加不生效问题 npm i -D @vue/cli-service 2、如果 package.json 配置有 vue-cli-server 或者安装了还是没好，可以看看 node_modules 工程模块是否存在，如果没有请安装。 一般负责前端工程的弟兄在给你项目的时候，会考虑到工程存储较大，为了方便传输会优化删掉 node_modules 模块然后发布到云端，这就像后端传输工程把 target 清掉是一个道理，所以没有的话是需要添加的。
执行命令： npm install 3、 如果上面两个条件都存在，却还是不行，那就是网络不稳定导致运行下载时包缺失，可以清掉 node_modules 后再次安装，我有4种方式，可以根据需求来 （1）在打开cmd进入项目目录执行 rd /s /q node_modules
rd /s /q node_modules （2）PowerShell 或 git bash 进入控制台命令 rm -rf .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ab00fe4bc631cd84ac0b2a53d5b9ca7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c244a412e95bed6c285e94e9d1713fe/" rel="bookmark">
			如何用python新建一个文件,python如何建立新文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章主要介绍了如何通过python新建一个文件中的文件，具有一定借鉴价值，需要的朋友可以参考下。希望大家阅读完这篇文章后大有收获，下面让小编带着大家一起了解一下。
前言： 计算机操作系统是以文件为单位对数据进行管理的。文件是指存储在某种介质上的数据集合用python如何画弧形。文件在存储介质上的位置是由驱动器名称、文件夹以及文件名来定位的。Python具有强大的文件处理功能，如文件的创建、打开、文件内容的写入、读出文件中的内容等等。
1.文件基本操作： 1.1创建文件： 在Python中利用open(file_name,code)方法来创建（打开）文件（如果该文件已存在就直接打开，如果该文件不存在，就创建新文件）。语法格式如下：
open(file_name,code)
参数说明：
name:创建文件的名称；
code：创建文件的模式。
code含义‘w’打开一个文件，只写‘wb’以二进制格式打开一个文件，只写‘w+’打开一个文件，读写‘wb+‘以二进制格式打开一个文件，读写‘r’以只读的方式打开文件。文件指针位于文件开头‘r+’打开一个文件用于读写。文件指针位于文件开头‘rb’以二进制格式打开一个文件进行读写。文件指针位于文件开头，一般用于非文本文件（如，图片）‘a’打开一个文件用于追加。若该文件已存在，则文件指针位于文件末尾，新的内容将被被写入到原有内容之后；若该文件不存在，则创建新文件进行写入。‘ab’以二进制格式打开一个文件，用于追加。若该文件已存在，则文件指针位于文件末尾，新的内容将被被写入到原有内容之后；若该文件不存在，则创建新文件进行写入。‘a+’打开一个文件用于读写.文件指针位于文件末尾‘ab+’以二进制格式打开一个文件用于读写。文件指针位于文件末尾 表1-1 注意：在 Python 中，以普通方式（文本模式）打开或创建文件和以二进制格式打开或创建文件，主要有以下几点不同：
数据的读取与写入方式： 在文本模式下，文件中的内容被视为字符串（在 Python 3 中为 Unicode 字符串），并且会自动处理平台特定的行结束符。在 Windows 上，行结束符为 \r\n，在 Unix/Linux 上为 \n。当你从文件读取或写入文本时，Python 会自动处理这些行结束符。但是，在二进制模式下，数据则被视为原始字节流，不会对行结束符做任何处理。
编码问题： 在文本模式下，可以通过 encoding 参数指定一个字符编码方式，比如 UTF-8，ASCII等。当你从文件读取或写入文本时，Python 会自动根据指定的编码方式对文本进行编码或解码。但是，在二进制模式下，由于数据被视为原始字节流，不涉及任何编码和解码的操作，所以不需要（也不能）指定字符编码方式。
文件类型： 有些文件（比如图片，音频，视频等）是以二进制格式存储的，这些文件必须以二进制模式打开。如果尝试以文本模式打开这些文件，可能会导致数据的损坏。
因此，在处理文件时，应根据文件的类型和需要处理的数据类型选择适当的文件打开模式。如果你需要处理的是文本数据，那么通常应使用文本模式。如果你需要处理的是二进制数据（比如图片或音频文件），或者需要进行低级的文件操作（比如读写固定数量的字节），那么应使用二进制模式。
#举个栗子： import os txt = open("mytext.txt",'w') print("成功创建一个文本文件，文件名为mytext.txt") doc= open("myword.docx","wb+") print("成功创建一个word文件，文件名为myword.docx") 1.2写入文件内容： 文件创建成功后，就利用write（string）可以向文件中写入内容。语法格式如下：
write(string)
参数及注意事项说明：
string:要写入文件中的字符串。但需要注意的是，Python字符串可以是二进制字符串。特别是当，文件以二进制模式创建时，string要利用 encode（）转换为bytes形式，否则会报错
注意事项： write()方法的返回值为写入的字符长度；2.write（）方法不会在字符串的末尾添加换行符；3.在文件关闭或缓冲区刷新前，字符串内容还存储在缓冲区中，在文件中是看不到写入的内容的。利用close（）方法来关闭文件。
#举个栗子 import os import chardet with open("mytxt.txt","wb+") as txt: txt.write("\n写入的信息如下：".encode()) txt.write(("\n文件名："+txt.name).encode()) txt.write(("\n创建的模式："+txt.mode).encode()) txt.write("\n满怀热爱，奔赴星海\n".encode()) print(content) 运行结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c244a412e95bed6c285e94e9d1713fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3a289ae98ec1ee56d30c7b8a8e33d8b/" rel="bookmark">
			Springboot文件下载方式（直接下载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.example.demo.controller; import org.apache.commons.io.FileUtils; import org.apache.http.HttpEntity; import org.apache.http.HttpResponse; import org.apache.http.client.HttpClient; import org.apache.http.client.methods.HttpGet; import org.apache.http.impl.client.HttpClients; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.bind.annotation.RestController; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.*; import java.net.URLDecoder; import java.net.URLEncoder; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; @RequestMapping("/upload3") @RestController public class uploadController { //定义分片有多大 private final static long PER_PAGE=1024l*1024l*50l; //设置分片存储的临时目录 private final static String DOWN_PATH="C:\\Users\\Lenovo\\Desktop\\lianxi"; //下载文件的地址 private final static String url="http://localhost:8080/upload3/downLoad/"; //文件存放的位置 private final static String pathfile=System.getProperty("user.dir")+"\\static\\upload\\"; ExecutorService pool= Executors.newFixedThreadPool(10); //文件大小文件名字 // 探测 获取文件信息 // 多线程分片下载 //最后一个分片下载完 始合并 @RequestMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3a289ae98ec1ee56d30c7b8a8e33d8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e34f5dd8150b9ee6f76dbff510169b27/" rel="bookmark">
			本地搭建【文档助手】大模型版（LangChain&#43;llama&#43;Streamlit）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 本文的文档助手就是：我们上传一个文档，然后在对话框中输入问题，大模型会把问题的答案返回。
安装步骤 先下载代码到本地 LangChain调用llama模型的示例代码：https://github.com/afaqueumer/DocQA（代码不是本人写的，尊重原创）
git clone https://github.com/afaqueumer/DocQA.git 环境安装 双击 setup_env.bat 如果没反应可能是缺少环境，打开控制台手动执行一下，缺python或者pip的自己根据报错下载一下 如果llama-cpp-python安装报错
（1）需要下载Visual Studio
（2）打开Visual Studio，工具，获取工具和功能
（3）等待下载完，重新运行setup_env.bat
如果还有报错【error C2061: 语法错误:】，那么可能是Visual Studio的版本太低了，我一开始用的是2019版本，后来换成了2022
更新为2022之后重复上面操作
下载一个靠谱的模型
https://huggingface.co/TheBloke/Llama-2-7B-GGUF
本文用的是：TheBloke/Llama-2-7B-GGUF中的最精简版
进入DocQA，修改app.py 原始
llm = LlamaCpp(model_path="./models/llama-7b.ggmlv3.q4_0.bin") embeddings = LlamaCppEmbeddings(model_path="models/llama-7b.ggmlv3.q4_0.bin") 这里改成自己下载的模型地址，比如：llama-2-7b.Q2_K.gguf
llm = LlamaCpp(model_path="../llama.cpp/models/7B/llama-2-7b.Q2_K.gguf") embeddings = LlamaCppEmbeddings(model_path="../llama.cpp/models/7B/llama-2-7b.Q2_K.gguf") 运行 双击run_app.bat 测试 准备好一个txt文档
As of October this year, there were nearly 2,500 geographical indication products in China The reporter learned from the State Intellectual Property Office that in recent years, the quantity and quality of China's geographical indication products have risen rapidly.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e34f5dd8150b9ee6f76dbff510169b27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9b14e9c1e55a6e4fcccec75f088c515/" rel="bookmark">
			基于llama-index对embedding模型进行微调
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QA对话目前是大语言模型的一大应用场景，在QA对话中，由于大语言模型信息的滞后性以及不包含业务知识的特点，我们经常需要外挂知识库来协助大模型解决一些问题。在外挂知识库的过程中，embedding模型的召回效果直接影响到大模型的回答效果，因此，在许多场景下，我们都需要微调我们的embedding模型来提高我们的召回效果。下面，我们就基于llama-index对BAAI/bge-base-zh-v1.5模型进行微调，关于该模型的介绍，可以参考https://huggingface.co/BAAI/bge-base-zh-v1.5。
平台介绍 对embedding模型进行微调的过程中需要使用GPU加速训练，由于家境贫寒，我这里就使用了Google colab提供的免费T4GPU进行微调测试。如果大家没办法使用这个，可以使用国内一些公司的GPU云平台，租便宜的GPU就行，微调这个模型所耗费的GPU资源不多。以下所有训练代码皆是在Jupter-notebook上编写并执行的。
依赖安装 安装一些依赖库，有些依赖需要制定版本，否则存在不兼容的问题。
!pip install langchain==0.0.300 llmx==0.0.15a0 openai==0.28.1 llama_index==0.8.23.post1 pypdf sentence-transformers 训练样本准备 我们当前的使用场景是QA问答场景，因此训练数据的格式最好也是问答的格式。我这里由于没有现成的问答样本（人工整理比较耗时），因此我就摘取了《明朝那些事儿》这个小说里面的部分章节，然后让GPT-3.5针对文章内容进行提问，从而形成问答对。代码如下
import json import openai import os from llama_index import SimpleDirectoryReader from llama_index.node_parser import SimpleNodeParser from llama_index.schema import MetadataMode from llama_index import ( VectorStoreIndex, SimpleDirectoryReader, ServiceContext, Response ) def load_corpus(docs, for_training=False, verbose=False): parser = SimpleNodeParser.from_defaults() if for_training: nodes = parser.get_nodes_from_documents(docs[:5], show_progress=verbose) else: nodes = parser.get_nodes_from_documents(docs[6:], show_progress=verbose) if verbose: print(f'Parsed {len(nodes)} nodes') return nodes SEC_FILE = ['embedding_test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9b14e9c1e55a6e4fcccec75f088c515/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/476fbf464637e04d6f7dd9c8ac7a4df8/" rel="bookmark">
			人工智能课程设计毕业设计——基于机器学习的贷款违约预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要
随着人们对于贷款的需求量不断增加以及我国债券市场和信贷市场违约事件频发，商业银行不良资产率与用户个人贷款违约风险成为了政府和银行业关心的核心问题，而对信用贷款违约风险进行有效评估和测度也成为了商业银行提高其经营管理水平的核心要务。
本小组以金融风控中的个人信贷为背景，根据贷款申请人的数据信息预测其是否有违约的可能，我们致力建立多种机器学习模型，基于贷款违约信息的数据，进行模型训练，用来预测贷款人是否存在违约的可能。
本次实验使用了Decision tree、AdaBoost、Bagging、RandomForest、Xgboost、Lightgbm和Catboost 7种机器学习模型，使用五折交叉验证的方法，对贷款违约数据进行训练，使用AUC指标作为评估这7个模型的评估指标，得到效果最好的模型是catboost模型，它最高的AUC为74.88%，并且生成数据可视化分析报告。
关键词：数据分析；数据不平衡；机器学习；交叉验证；集成学习
基于机器学习的贷款违约预测
1. 问题描述 1.1 问题背景 近年来，我国用于买房、购车以及其他消费的贷款规模快速增长，人们对于贷款的需求不断增加，随之而来的，是我国债券市场和信贷市场违约事件频发。商业银行不良资产率与用户个人贷款违约风险成为了政府和银行业关心的核心问题，而对信用贷款违约风险进行有效评估和测度也成为了商业银行提高其经营管理水平的核心要务。
本文通过处理用户贷款数据以及贷款人的各项特征数据，分析各项特征与违约情况之间的相关性，建立个人贷款违约预测模型，帮助银行的业务人员明确客户的更多有意义的指标变量，在应对日益增多的贷款审核业务中对用户贷款风险进行预测，及早发现贷款的潜在损失，减少人工审核成本，提高预测准确率，更好地为用户提供贷款服务与业务。
本项目数据集来源于阿里天池大数据平台，以金融风控中的个人信贷为背景，根据贷款申请人的数据信息预测其是否有违约的可能，建立模型预测是否通过此项贷款。
1.2 所需关键技术 （1）matplotlib数据可视化：Matplotlib是Python中最基本的可视化工具，是一个非常简单而又完善的开源绘图库，能够以跨平台的交互式环境生成图形，用来绘制各种静态，动态，交互式的图表。
（2）seaborn数据可视化：Seaborn是基于matplotlib的图形可视化python包。它提供了一种高度交互式界面，便于用户能够做出各种有吸引力的统计图表。Seaborn是在matplotlib的基础上进行了更高级的API封装，从而使得作图更加容易，可以将Seaborn视为matplotlib的补充。
（3）pandas数据统计分析：pandas是一个以Numpy为基础的强大的分析结构化数据的工具集，为Python数据分析提供了高性能，且易于使用的数据结构。pandas提供了两种数据结构，分别是Series（一维数组结构）与DataFrame（二维数组结构），这两种数据结构极大地增强的了Pandas的数据分析能力。
（4）Scikit-learn机器学习：Scikit-learn是一个基于NumPy,SciPy，Matplotlib的开源机器学习工具包，主要涵盖分类、回归和聚类算法，例如逻辑回归、朴素贝叶斯、随机森林、SVM、k-means等算法，旨在与Python数值科学库NumPy和SciPy联合使用。
（5）PCA数据降维：PCA主成分分析是一种无监督的数据降维方法，将一个高维数据集转换为一个低维数据集。PCA降维的思想旨在减少数据集的维数，同时还保持数据集的对方差贡献最大的特征，最终使数据直观呈现在二维坐标系。
（6）集成学习：集成学习是一种通过构建并结合多个学习器来完成学习任务机器学习方法，主要是将有限的模型相互组合。集成学习就是组合多个弱监督模型以期得到一个更好更全面的强监督模型，集成学习潜在的思想是即便某一个弱分类器得到了错误的预测，其他的弱分类器也可以将错误纠正回来。集成学习主要有Bagging、Boosting以及Stacking。
（7）网格搜索法：网格搜索法是指定参数值的一种穷举搜索方法，通过将估计函数的参数通过交叉验证的方法进行优化来得到最优的学习算法。网格搜索用于选取模型的最优超参数，算法在拟合函数尝试了所有的参数组合后，返回一个合适的分类器，自动调整至最佳参数组合。
2. 数据分析 2.1 数据获取 本文数据下载于阿里天池大数据平台，是Datawhale与天池联合发起金融风控之贷款违约预测挑战赛训练数据集。贷款违约预测数据集中包含了部分匿名特征，该数据来自某信贷平台的贷款记录，总数据量超过120w，包含47列变量信息，其中15列为匿名变量。在本次实验中，从中抽取80万条作为训练集，20万条作为测试集A。
数据集特征概况介绍如表2-1所示：
表2-1 数据集特征概况介绍
特征名称
特征含义
id
为贷款清单分配的唯一信用证标识
loanAmnt
贷款金额
term
贷款期限（year）
interestRate
贷款利率
installment
分期付款金额
grade
贷款等级
subGrade
贷款等级之子级
employmentTitle
就业职称
employmentLength
就业年限（年）
homeOwnership
借款人在登记时提供的房屋所有权状况
annualIncome
年收入
verificationStatus
验证状态
issueDate
贷款发放的月份
purpose
借款人在贷款申请时的贷款用途类别
postCode
借款人在贷款申请中提供的邮政编码的前3位数字
regionCode
地区编码
dti
债务收入比
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/476fbf464637e04d6f7dd9c8ac7a4df8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3a85e71973145980fcb8b566c223187/" rel="bookmark">
			Java Web应用小案例 - 实现用户登录功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、使用纯JSP方式实现用户登录功能（一）项目概述（二）实现步骤1、创建Web项目2、创建登录页面3、创建登录处理页面4、创建登录成功和失败页面（1）登录成功页面（2）登录失败页面 5、编辑项目首页 （三）测试程序，查看效果 二、使用JSP+Servlet方式实现用户登录功能（一）实现思路（二）实现步骤1、创建Web项目2、创建登录页面3、创建登录处理程序4、创建登录成功页面5、创建登录失败页面6、编辑项目首页 （三）测试测试，查看结果 三、JSP+Servlet+DB方式实现用户登录功能（一）实现思路（二）实现步骤1、创建数据库2、创建用户表3、创建Jakarta EE项目4、创建用户实体类5、添加数据库驱动程序6、创建数据库连接管理工具类7、创建用户数据访问类8、测试用户数据访问类9、创建用户服务类10、创建登录处理程序11、创建登录页面12、创建登录成功页面13、创建登录失败页面14、编辑项目首页 （三）运行程序，查看结果 四、课后作业任务1、采用MVC模式实现用户注册功能任务2、在登录成功页面显示用户列表 一、使用纯JSP方式实现用户登录功能 （一）项目概述 今天我们将一起学习如何使用纯JSP方式实现用户登录功能。在这个过程中，我们会通过四个主要步骤来完成这个任务：创建Web项目、创建登录页面、创建登录处理页面以及创建登录成功和失败页面。 （二）实现步骤 1、创建Web项目 创建Jakarta EE项目，要设置项目名称 - LoginDemo01，保存位置 - D:\WebProjects，选择模板 - Web application，设置应用服务器 - Tomcat 10.1.16，语言 - Java，构建系统 - Maven，组 - net.huawei、构件 - LoginDemo01，JDK - 21
单击【Next】按钮，选择版本 - Jakarta EE 10，添加依赖 - Servlet
单击【Create】按钮完成项目的创建
在项目结构窗口里，修改构件名 - 将LoginDemo01:war exploded改成LoginDemo01，与项目名保持一致
要编辑服务器配置，重新部署项目
切换到【Server】选项卡，URL已经自动变成http://localhost:8080/LoginDemo01/
启动服务器，查看效果
单击【Hello Servlet】超链接
本案例不使用Servlet，所以删除HelloServlet
2、创建登录页面 接下来，我们开始创建登录页面。登录页面是用户输入用户名和密码的地方，我们将其命名为login.jsp。在这个页面中，我们使用HTML代码创建一个表单，包含了账号和密码两个输入框，以及登录和重置两个按钮，为了登录页面美观，我们需要一个外部样式表styles.css。
创建login.jsp页面
&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3a85e71973145980fcb8b566c223187/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4c2c9bf878e8e705078a581a6f13b4d/" rel="bookmark">
			程序员的20大RabbitMQ面试问题及答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、什么是 RabbitMQ？为什么使用 RabbitMQ？2、RabbitMQ 有什么优缺点？3.rabbitmq 的使用场景4.RabbitMQ基本概念5.RabbitMQ 中的 broker 是指什么？cluster 又是指什么？6、RabbitMQ 概念里的 channel、exchange 和 queue 是逻辑概念，还是对应着进程实体？分别起什么作用？7 vhost 是什么？起什么作用？8. 消息基于什么传输？9. 消息如何分发？10. 消息怎么路由？11. 什么是元数据？元数据分为哪些类型？包括哪些内容？与 cluster 相关的元数据有哪些？元数据是如何保存的？元数据在 cluster 中是如何分布的？12. 在单node 系统和多 node 构成的 cluster 系统中声明 queue、exchange ，以及进行 binding 会有什么不同？13. 如何确保消息正确地发送至RabbitMQ？14. 如何确保消息接收方消费了消息？15、如何保证 RabbitMQ 不被重复消费？16、如何保证 RabbitMQ 消息的可靠传输？17、如何保证 RabbitMQ 消息的顺序性？18. 死信队列和延迟队列的使用?19. 使用了消息队列会有什么缺点?20. 多个消费者监听一个队列时，消息如何分发? 1、什么是 RabbitMQ？为什么使用 RabbitMQ？ RabbitMQ 是一款开源的，Erlang 编写的，基于 AMQP 协议的，消息中间件；
可以用它来：解耦、异步、削峰。
2、RabbitMQ 有什么优缺点？ 优点：解耦、异步、削峰；
缺点：降低了系统的稳定性：本来系统运行好好的，现在你非要加入个消息队列进去，那消息队列挂了，你的系统不是呵呵了。因此，系统可用性会降低；
增加了系统的复杂性：加入了消息队列，要多考虑很多方面的问题，比如：一致性问题、如何保证消息不被重复消费、如何保证消息可靠性传输等。因此，需要考虑的东西更多，复杂性增大。
3.rabbitmq 的使用场景 （1）服务间异步通信
（2）顺序消费
（3）定时任务
（4）请求削峰
4.RabbitMQ基本概念 Broker： 简单来说就是消息队列服务器实体
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4c2c9bf878e8e705078a581a6f13b4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b359e2fb4992adb770f460720668e1e/" rel="bookmark">
			AI写作指南：如何辨别文章是人工智能还是真人撰写的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着人工智能（AI）发展，写作指令自动化越来越普及。但是，如何辨别一篇文章是人工撰写还是AI生成的呢？以下是几个方法，希望能够帮到您：
1.对比语言风格
在判断一篇文章是否由 AI 生成时，我们可以关注它与已知作者其他作品之间的差异，如词汇选择、句子结构及修辞运用等方面。这些都有助于我们探寻到可能存在的人工智能痕迹。
2.分析逻辑框架
真正的作者在创作过程中常展现出他们个人独特的逻辑思考及表达技巧。通过洞察文章的逻辑结构，审视其中观点、证明与结论间的关联，便能判断该篇作品是否具备优良的人脑思维的协调性了。
3.观察情感表达
情感在文学创作中扮演着重要角色，但人工智能（AI）生成的文本常常欠缺此元素。初步识别AI作品的方法包括关注文章中的情感色彩、描写情感化程度，以及分析作者对主题的看法与情感倾向等元素。
4.检测语法错误
智能写作系统生成的文章，在基本的语法规则上通常会有较好的遵守，不太容易出现常犯的语法错误。我们只需仔细检查文中有无拼写错误、主谓搭配不当或句式杂乱无章等现象，就可判断该文是否出自机器人之手了。
5.细节揭示真相
在评估文章是否为AI生成时，请留意是否有细节描述。具体包括特定场景介绍、人物形象刻画乃至生动有趣的细节描写等元素哦。
6.真实背景调查
若您对一篇文章怀有疑问，可尝试进行作者背景资料检索。搜寻其个人信息、社交平台动态及其他文章，这样就能洞悉作者的写作特点与经历，方便我们推断该文是否为人工智能撰写。
7.客观事实核实
检查文章所述事实的真实性与精确度，我们可以对比已知事实或是查阅可靠来源来判断文章是否出自人工智能之手。
8.人机交互测试
利用人机交互测试，我们能有效地通过与文章作者对话来分析答复问题的方式以及思维过程。这有助于初步鉴别出一篇文章是否完全由人工智能生成。
9.参考他人意见
如您对某篇文章产生质疑，欢迎邀请他人提出意见。共同参考他人的看法以及你个人的考量，想必能更精准地判断它是否由人工智能创作。
10.综合判断
综上所述，我们运用了多种方式进行分析后，再结合自身的敏锐洞察力与丰富经验，我们可以得出较为精确的结论：究竟是AI编写了这篇内容，还是有真实的作者在背后操刀？
随着AI技术的快速进步，如何鉴别文章是否为AI生成已逐渐成为关键课题。本文将介绍四种简易方法，助您轻松评估文章的可信度，从而提升对信息的甄别技巧。让我们携手守护真实信息，共创优质网络环境!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e23975ff94a0bee3eeb105aed5ca829b/" rel="bookmark">
			【Unity编辑器】使用AssetDatabase创建、删、改、加载资源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AssetDatabase是Unity编辑器环境下的一种API，主要用于在代码中对项目中的资源进行管理和操作。注意：AssetDatabase的这些方法只能在Unity编辑器环境下运行，不能在构建后的游戏中使用。在游戏运行时，你需要使用其他资源加载方法，如Resources.Load、AssetBundle加载或者Addressables等。
以下是一些常用的AssetDatabase方法及其使用示例：
创建新资产：
using UnityEngine; using UnityEditor; public class CreateNewAssetExample : Editor { [MenuItem("Assets/Create/New Asset")] static void CreateNewAsset() { // 创建一个新的ScriptableObject类型资产 ScriptableObject newAsset = CreateInstance&lt;ScriptableObject&gt;(); // 设置资产的名称 newAsset.name = "NewAsset"; // 选择保存新资产的路径 string path = "Assets/MyAssets/NewAsset.asset"; // 使用AssetDatabase.CreateAsset方法创建新资产 AssetDatabase.CreateAsset(newAsset, path); // 让Unity刷新资源数据库，使新资产在项目窗口中可见 AssetDatabase.SaveAssets(); AssetDatabase.Refresh(); } } 2.创建新文件夹：
using UnityEngine; using UnityEditor; public class CreateNewFolderExample : Editor { [MenuItem("Assets/Create/New Folder")] static void CreateNewFolder() { // 指定新文件夹的路径 string folderPath = "Assets/MyFolders/NewFolder"; // 使用AssetDatabase.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e23975ff94a0bee3eeb105aed5ca829b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96ffdd9f88a2cf68f45efceac3dff01f/" rel="bookmark">
			语音情感识别基本原理及应用场景-python（课设报告）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 摘要
一 语音情感识别的基本原理
语音信号的特征提取
情感状态的分类和识别
积极情感
消极情感
中性情感
语音情感识别的算法和模型 卷积神经网络（CNN）
长短期记忆网络（LSTM）
决策树（Decision Tree）
支持向量机（SVM）
二 Python语言在语音情感识别中的应用
使用python进行语音信号的处理和分析
Python语音情感识别库的介绍和应用
Python编程实现语音情感识别的基本算法
三 语音情感识别的应用场景
语音助手的情感识别和应用
电话客服的情感识别和应用
一、情感识别应用
二、举例说明
社交媒体的情感识别和应用
一、情感分析
二、情感交流
三、情感推荐
心理健康评测
四 实际测试和示例演示
流程图:
一、数据预处理
1. 读取CASIA情感数据库
2. 提取MFCCs特征
3. 零填充和转换为numpy数组
二、模型构建与训练
1. 构建卷积神经网络模型
2. 模型编译
3. 模型训练
三、结果评估与分析
1. 模型评估
2. 结果可视化
四、结论
五 语音情感识别发展前景
六 总结
一、引言
二、语音情感识别现状
三、语音情感识别前景
四、语音情感识别挑战
五、总结
七 源代码 声明
摘要 语音情感识别是一项研究人类语音中所蕴含情感信息的技术，用于识别和分析说话者语音中的情感状态，包括愉快、悲伤、愤怒、焦虑等。这项技术可以通过分析语音中的声调、语速、语音质量等特征来判断说话者的情感状态，从而帮助人们更好地理解和交流。
语音情感识别的发展情况可以追溯到20世纪80年代，当时研究人员开始尝试使用语音信号处理技术来识别说话者的情感状态。随着人工智能和机器学习技术的不断发展，语音情感识别技术也得到了长足的进步。现在，语音情感识别已经被广泛应用于语音助手、客服机器人、情感分析等领域。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96ffdd9f88a2cf68f45efceac3dff01f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/545/">«</a>
	<span class="pagination__item pagination__item--current">546/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/547/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>