<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91f3e8a1076921ef70cef6b6a536dc87/" rel="bookmark">
			阿里云API安全2.0全新发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里云安全发布API防护产品已将近三年，为客户提供API资产全生命周期监控管理，发现和管理业务中存在的全量API接口资产，并提升API接口在数据流转过程中的安全性，现已全面覆盖OWASP提出的API TOP 10安全风险。
近期，阿里云API安全发布了全新2.0版本，对产品架构进行了全面升级改造，在检测时效性、丰富度、准确率以及使用体验等方面均有大幅提升。
近实时的检测能力提供自动化识别API接口资产、分析API敏感数据、业务用途、服务对象、生命周期状态、流量成分等能力，通过多维度构建API基线画像，可实现API分类分级管理。并支持将相关资产、告警信息推送到日志服务，方便与用户内部运维系统联动集成，提升运维效率；
接口脆弱性发现能力增强当前支持六大类（覆盖接口设计、接口开发规范、权限管理、账号安全、敏感数据保护、访问控制）总共38种接口的风险检测能力，对API常见风险，例如未授权接口敏感数据泄漏、内部应用弱口令等均可实现检测；
强化攻击检测能力支持五大类（覆盖API滥用、基线异常、账号风险、响应异常、敏感数据泄露）总共25种API异常行为检测，例如针对接口数据爬取场景，攻击者可以通过遍历ID值来获取个人敏感信息，造成数据泄漏风险，阿里云API安全可基于已建立的基线，持续监控并及时预警异常行为；
灵活的自定义检测进一步开放了自定义策略能力，支持客户根据各自的业务特性和安全需求自定义接口识别、风险/攻击、敏感数据、生命周期、业务用途等检测策略。例如在自定义攻击检测方面，新版本支持对各请求参数、敏感数据去重统计，可更精确的发现接口滥用如数据遍历、撞库、爆破等攻击行为。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9823adf108e1b5d0b69eef9614ee537c/" rel="bookmark">
			【Spring Boot】Spring原理：Bean的作用域和生命周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Spring原理一. 知识回顾1.1 回顾Spring IOC1.2 回顾Spring DI1.3 回顾如何获取对象 二. Bean的作用域三. Bean的生命周期 Spring原理 一. 知识回顾 在之前IOC/DI的学习中我们也用到了Bean对象，现在先来回顾一下IOC/DI的知识吧！
首先Spring IOC，也叫控制反转，简单来说就是依赖添加5大注解把该对象交给Spring来管理，Spring会把该对象放入IOC容器中，在接下来的调用中直接注入即可，注入也就是Spring DI操作了。
回顾一下，一共有以下五大注解：
1.1 回顾Spring IOC 类注解
@Controller（控制层注解）@Service（逻辑层注解）@Repository（数据层注解）@Component（总注解）@Configuration(插件注解) 然后就是有一点要注意的就是，@Component注解可以说是其他四个注解的父注解，就是其他注解底层都是依赖@Component来实现的，都可以使用@Component注解来代替使用，但是不能代替@Controller,因为别忘了Controller注解还有返回视图的作用，这是@Component注解所不具备的
方法注解
@Bean（方法注解） 该注解用于把方法交给Spring进行管理，但是必须和类注解连用
1.2 回顾Spring DI Spring DI就是把IOC容器里的东西拿出来进行使用，主要是@Autowired注解，主要有三种注入方式
属性注入(就是通过给成员变量进行注入)构造注入(就是通过构造方法注入)Set方法注入 其实在实际运用中,使用属性注入基本上能满足90%的需求了.
Spring DI主要面试考的主要是拥有多个相同对象,注入时该如何保证?
主要提供了以下三大注解
@Primary（默认注入的方法）@Qualifier（加入要注入对象的方法名称）@Resource（要注入对象的名称） @Autowird与@Resource的区别
@Autowired是spring框架提供的注解，⽽@Resource是JDK提供的注解@Autowired默认是按照类型注⼊，⽽@Resource是按照名称注⼊.相⽐于@Autowired来说，@Resource⽀持更多的参数设置，例如name设置，根据名称获取Bean。 1.3 回顾如何获取对象 Spring主要提供了两种方法获取Bean对象：
ApplicationContext（上下文）@Autowired 第二种是注入方式就不一一叙述了，主要是ApplicationContext获取Bean对象，其实就是调用了分类BeanFactory工厂来获取对象。
两者主要有以下两点区别：
继承关系和功能方⾯来说：Spring容器有两个顶级的接口：BeanFactory和
ApplicationContext。其中BeanFactory提供了基础的访问容器的能⼒，⽽
ApplicationContext属于BeanFactory的⼦类，它除了继承了BeanFactory的所有功能之外，
它还拥有独特的特性，还添加了对国际化⽀持、资源访问⽀持、以及事件传播等方⾯的⽀持.
从性能方⾯来说：ApplicationContext是⼀次性加载并初始化所有的Bean对象，也就是饿加载，⽽
BeanFactory是需要那个才去加载那个，也就是懒加载，因此更加轻量.(空间换时间)
好了，回顾完了Spring IOC/DI的知识点了，就该进入正题了。
二. Bean的作用域 Bean的作用域是指Bean在Spring框架中的某种行为模式.
主要有以下6种作用域
singleton：单例作用域prototype：原型作用域（多例作用域）request：请求作用域session：会话作用域Application:全局作用域websocket：HTTPWebSocket作用域 作用域说明singleton每个SpringIoC容器内同名称的bean只有⼀个实例(单例)(默认)prototype每次使用该bean时会创建新的实例(⾮单例)request每个HTTP请求生命周期内,创建新的实例(web环境中)session每个HTTPSession生命周期内,创建新的实例(web环境中)application每个ServletContext生命周期内,创建新的实例(web环境中)websocket每个WebSocket生命周期内,创建新的实例(web环境中) 单例作用域:多次访问,得到的都是同⼀个对象,并且 @Autowired 和 applicationContext.getBean()
也是同⼀个对象.
多例作用域:观察ContextDog,每次获取的对象都不⼀样(注⼊的对象在Spring容器启动时,就已经注⼊了,所以多次请求也不会发生变化)
请求作用域:在⼀次请求中, @Autowired 和 applicationContext.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9823adf108e1b5d0b69eef9614ee537c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/226da7eab950e1fe963f98f7c2389996/" rel="bookmark">
			[安洵杯 2019]crackMe
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大佬wp:
[安洵杯 2019]crackMe - Moominn - 博客园 (cnblogs.com)
首先肯定是运行
(运行这个耗费了我好久,一直说我缺失什么文件,我giao,最后是问学长要的dll文件)
输入类型,然后提醒我hook
没搞懂,先分析吧
F12找到right,reverse--从结果来推
cmp str2= 1UTAOIkpyOSWGv/mOYFY4R!!
上调找到这里
再换表 对base64的表进行了移位处理
这里我也没看懂,看wp才知道,这里是说对不足的补全为!(之前是补全为=)
输入字符两两swap SM4 base64表大小写转换 这是我们逆向推出来的流程
我们现在重新来理一下
首先是base64被换表了----输入字符移动----输入字符swap---SM4加密---base64表大小写转换---base64加密为str2
import base64 ans1='1UTAOIkpyOSWGv/mOYFY4R!!' ans='' for i in range(0,len(ans1),2): ans+=ans1[i+1] ans+=ans1[i]#这里先把最后一步的字符转换给完成了 table='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/' #大小写转换 new_table='' for i in table: tmp=ord(i) if 97 &lt;= tmp &lt;= 122: new_table += chr(tmp - 32) elif 65 &lt;= tmp &lt;= 90: new_table += chr(tmp + 32) else: new_table+=chr(tmp) print(new_table) renew_table='' renew_table=new_table[24:]+new_table[:24] print(renew_table) #得到新表 arr=[] for i in range(len(ans)-2): arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/226da7eab950e1fe963f98f7c2389996/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d09b13e6ba7cb67712e81902eeffe738/" rel="bookmark">
			测试移动电源IC IP5306、IP5407
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍 1、IP5306 IP5306是一款由INJOINIC（英集芯）生产的高集成度的电源管理SOC芯片，广泛应用于移动电源和便携式设备中。以下是该芯片的主要特点和功能：
同步开关充放电：IP5306支持2.4A的同步升压转换和2.1A的同步开关充电，具有高效率，升压效率可达92%，充电效率可达91% 。
内置电源路径管理：支持边充边放功能，允许设备在充电的同时为其他设备供电 。
自适应充电电流调节：能够根据适配器自动调节充电电流，支持4.20V至4.40V的电池 。
LED电量显示：支持1至4颗LED电量显示，方便用户了解电池电量 。
功能丰富：包括按键开机、内置照明灯驱动以及自动检测手机插入和拔出的功能 。
低功耗设计：智能识别负载，自动进入待机模式，待机功耗小于100 µA 。
BOM极简：功率MOS内置，单电感实现充放电，简化了设计并减少了成本 。
多重保护：包括输出过流、过压、短路保护，以及输入过压、过充、过放、过流放电保护和整机过温保护，确保了使用的安全性和可靠性 。
封装类型：IP5306采用ESOP8封装，适合SMT安装，具有较小的占用空间 。
应用领域：主要用于移动电源/充电宝、手机、平板电脑等便携式设备 。
此外，IP5306还支持I2C通信，可以灵活定制需求，具有可定制的I2C接口型号IP5306_I2C 。这些特性使得IP5306成为移动电源和其他便携式设备的理想选择，提供了一种高效、可靠且成本效益高的电源管理解决方案。
2、IP5407 IP5407是一款由INJOINIC（英集芯科技有限公司）生产的多功能电源管理SOC芯片，专为移动电源设计，提供完整的电源解决方案。以下是该芯片的一些主要特性和功能：
同步开关充放电：IP5407具备2.1A/2.4A的同步升压转换能力和2.0A的同步开关充电能力，升压效率可达到93%，充电效率高达91%，并且内置电源路径管理，支持边充边放功能，输出支持线补60mV 。
充电管理：该芯片能够自动调节充电电流，以匹配适配器的输出能力，并支持4.20V和4.35V电池 。
电量显示：IP5407支持4/2/1颗LED电量显示，其中标准型号IP5407支持4颗LED显示，而定制型号IP5407_2D1D支持2颗和1颗LED显示 。
多功能：芯片内置照明灯驱动，能自动检测手机插入和拔出，并集成了手机充电电流智能识别DCP功能，同时支持电池NTC温度保护 。
低功耗设计：IP5407在输出固定常开5V时，待机功耗小于150µA 。
BOM简化：功率MOS内置，通过单电感实现充放电，简化了BOM并减少了成本 。
多重保护：具备输出过流、过压、短路保护，以及输入过压、过充、过放、过流放电保护和整机过温保护，ESD达到4KV，瞬间耐压11V 。
应用领域：IP5407适用于移动电源/充电宝、手机、平板电脑等便携式设备 。
封装类型：IP5407采用ESOP8封装 。
智能识别：集成了手机充电电流智能识别功能，能自动为连接上的手机设备切换D+和D-线路连接，加快手机的充电速度，支持苹果、三星以及BC1.2接口规范的D+，D-切换 。
IP5407的这些特性使其成为移动电源设计的理想选择，提供了一种高效、多功能且成本效益高的解决方案。
二、IP5306测试 1、VOUT输出 接上电池，VOUT电压2.36V，短按一下按键，VOUT电压5.16V，无论是否接负载，VOUT会一直保持输出。接上电池，VOUT电压2.36V，接入VIN充电，VOUT电压5.02V；VIN保持，拔掉电池，VOUT电压5.10V，无论是否接负载，VOUT会一直保持输出。
2、VBAT 接入VIN充电，VBAT电压4.25V。
3、指示灯 接上电池，指示灯灭，短按一下按键，指示灯点亮40s。
三、IP5407测试 1、VOUT输出 接上电池，VOUT电压0V，短按一下按键，VOUT电压5.16V，不接负载，会立即关闭输出。接上电池，VOUT电压0V，接入VIN充电，VOUT电压5.11V；VIN保持，拔掉电池，VOUT电压5.11V，无论是否接负载，VOUT会一直保持输出。
2、VBAT 接入VIN充电，VBAT电压3.15V。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3534ab11422a94278a2e3dde094396ca/" rel="bookmark">
			Clean My Mac X破解版，让您的电脑跟新的一样好用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Clean My Mac X破解版是一款专门为所有的苹果电脑用户而准备的系统优化工具，这款软件可以支持多种不同版本的Mac系统。我们可以通过Clean My Mac X免激活码破解版来将电脑系统里的各种垃圾文件和垃圾程序进行清理，从而确保系统能够快速运行。
Clean My Mac X破解版不仅可以帮助我们的用户清理系统里的垃圾文件和程序，而且这款软件还可以管理系统里的所有的扩展、插件和依赖项。通过Clean My Mac X免激活码破解版，我们也可以监测苹果电脑里所有硬件设备的使用情况。
链接: https://pan.baidu.com/s/1_TFnrIVH1NGsZPsA3lpwAA 提取码: dpjw
CleanMyMac X-安装包：https://souurl.cn/QUYb57
Clean My Mac X破解版软件特色 易于使用：具有简单易用的界面，只需两个步骤即可清理系统中的无用文件。
强大的清理功能：它可以清理系统中的临时文件、缓存、日志文件、无用的二进制文件等，从而释放磁盘空间。
卸载和修复应用程序：可以卸载不需要的应用程序，修复不正常工作的应用程序。
管理扩展和更多：可以帮助用户管理所有的扩展、插件和依赖项，以确保系统的稳定性和性能。
监控Mac健康状况：可以监控Mac的硬盘健康状况、电池健康状况、内存使用情况等，以便用户及时发现并解决问题。
新设计和精美简洁的界面：拥有一个新设计和精美简洁的界面，使用户能够更加方便地使用它来清理、优化和维护Mac。
软件亮点 系统垃圾：清理您的系统来获得最大的性能和释放自由空间。
照片垃圾：移除照片图库中的支持数据，使之变小。
邮件附件：移除邮件下载和附件的本地副本
iTunes 垃圾：清理过时的iOS设备备份，软件更新和其他iTunes支持数据
废纸篓：倾倒Mac上所有废纸篓，包括邮寄和照片图库垃圾。
大型和旧文件：查找和移除大型文件和文件夹。
卸载器；移除整个应用程序，包括其所有关联文件。
维护：运行一组脚本，快速优化系统性能。
隐私：立即移除浏览历史以及在线和离线活动的痕迹。
扩展：移除或禁用Widget，应用程序插件，偏好设置面板，词典，屏幕保护程序和登录项。
碎纸机：迅速擦除任何不需要的文件或文件夹而又不留一丝痕迹。
软件功能 1.CleanMyMac带来的好处
删除应用 完全删除应用程序，不留任何痕迹。
重置应用程序 仅删除服务文件并首次启动任何应用程序。
清理残余文件 删除之前移至“已删除邮件”的应用的剩余部分(已损坏的服务文件)。
删除扩展程序 更改Mac启动项，隐藏或禁用启动代理，安装文件和其他核心扩展。
2.重置Mac应用程序
使用CleanMyMac通过清除其服务文件将应用程序重置为首次启动状态：
只需单击一下即可删除服务文件
释放磁盘空间
3.清理已删除程序的残留文件
将应用程序拖放到废纸篓时，请检查Mac上是否存在保留在磁盘上的先前删除的应用程序的痕迹。
查找并删除所有剩余物，遗骸和破损的服务文件!
4.禁用和卸载Mac系统扩展
预览和操作Mac上安装的用户和核心扩展。您可以轻松切换模式甚至删除
禁用Mac启动项
关闭Mac Launch Agents
删除macOS安装文件
删除浏览器扩展
清理屏幕保护程序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3534ab11422a94278a2e3dde094396ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6152dd3339e74534a5ca9db78a58dc1c/" rel="bookmark">
			linux系统操作/基本命令/vim/权限修改/用户建立
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux的目录结构： 一：在Linux系统中，路径之间的层级关系，使用:/来表示
注意:1、开头的/表示根目录
2、后面的/表示层级关系
二：在windows系统中，路径之间的层级关系，使用:\来表示
注意:1、D:表示D盘
2、\表示层级关系
练习题：请根据语言描述，写出对应的Linux路径
1、在根目录下有一个文件夹test，文件夹内有一个文件hello.txt，请描述文件的路径 /test/hello.txt
2、在根目录下有一个文件itheima.txt，请描述文件的路径。 /itheima.txt
3、在根目录下有一个文件夹itcast，在itcast文件夹内有文件夹itheima，在itheima文件夹内有文件hello.txt，请描述文件的路径 /itcast/itheima/hello.txt
Linux命令入门： 一：ls命令： 1、ls命令的作用是? 在命令行中，以平铺的形式，展示当前工作目录(默认HOME目录)下的内容(文件或文件夹)
2、HOME目录是? 每一个用户在Linux系统的专属目录，默认在:/home/用户名
3、当前工作目录? Linux命令行在执行命令的时候，需要一个工作目录，打开命令行程序(终端)默认设置工作目录在用户的HOME目录
二：ls 命令的-a选项 1、a选项，表示: all的意思，即列出全部文件 (包含隐藏的文件/文件夹)
可以看到，ls-a 对比ls 列出的内容更多了
图中以.开头的，表示是Linux系统的隐藏文件/文件夹 (只要以.开头，就能自动隐藏)只有通过-a选项，才能看到这些隐藏的文件/文件夹 三：ls命令的-l选项 [Linux路径] 1、-l选项，表示:以列表 (竖向排列)的形式展示内容，并展示更多信息
四：ls命令选项的组合使用 语法中的选项是可以组合使用的，比如学习的-a和-l可以组合应用写法:
1、ls -l -a2、ls -la3、ls -al 上述三种写法，都是一样的，表示同时应用-l和-a的功能
五：ls 命令的 -h选项 1、-h 表示以易于阅读的形式，列出文件大小，如K、M、G（文件的单位大小）2、-h选项必须要搭配-l一起使用 小结：
1、ls命令的参数的作用
可以指定要查看的文件夹(目录)的内容，如果不给定参数，就查看当前工作目录的内容
2、ls命令的选项
a选项，可以展示出隐藏的内容
以.开头的文件或文件夹默认被隐藏，需要-a才能显示出来
-l选项，以列表的形式展示内容，并展示更多细节
-h选项，需要和-l选项搭配使用，以更加人性化的方式显示文件的大小单位
3、命令的选项组合使用
命令的选项是可以组合使用的，比如: ls -lah,等同于 ls-a -l-h
linux:常用的命令 1、ls：列出文件list list列出当前路径下的文件与文件夹
ls常用参数：
-l：列出文件的详细信息（竖向排列）-a:all,列出所有文件，包括隐形文件-h：1.列出文件大小，如K、M、G（文件的单位大小） 2.-h选项必须要搭配-l一起使用，如ls -lh
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6152dd3339e74534a5ca9db78a58dc1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/277c03790a1f7e1dc7fe5fb5b6111932/" rel="bookmark">
			前后端通信 —— HTTP/HTTPS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、HTTP/HTTPS 简介
1、HTTP
2、HTTPS
二、HTTP 工作过程
三、HTTP 消息
1、HTTP消息结构
2、HTTP消息示例
四、HTTP 方法（常用）
1、GET
2、POST
3、PUT
4、DELETE
5、GET与POST对比
五、HTTP 状态码（常用）
1、HTTP 状态码是什么
2、常见的HTTP状态码
一、HTTP/HTTPS 简介 1、HTTP HTTP（Hypertext Transfer Protocol），超文本传输协议；
是一种用于在万维网上传输数据的应用层协议；主要用来定义客户端和服务器之间的通信规则，包括请求和响应的格式、方法、状态码等；是一个基于 TCP/IP 通信协议来传递数据（HTML 文件、图片文件、查询结果等）； 2、HTTPS HTTPS（HyperText Transfer Protocol Secure），超文本传输安全协议；
在 HTTP 上加入 SSL/TLS 协议，为数据传输提供了加密和身份验证，是HTTP的安全版本；
二、HTTP 工作过程 1、客户端发起请求
用户通过客户端（如浏览器）输入 URL，客户端向服务器发起一个 HTTP 请求；
2、服务器处理请求
服务器接收到请求后，根据请求的类型（如GET、POST等）和请求的资源，进行相应的处理；
3、服务器返回响应
服务器将处理结果包装成HTTP响应消息，发送回客户端；
4、客户端渲染页面
客户端接收到响应后，根据响应内容（如HTML、图片等）渲染页面，展示给用户；
三、HTTP 消息 HTTP消息是指，在HTTP协议中，客户端与服务端之间进行数据传输的基本单元；
是前后端通信的基础，由一系列的文本行组成，有着固定的结构和格式；遵循HTTP协议的规范，确保数据能够在客户端和服务器之间正确、高效地传输；分为两种类型：请求消息和响应消息； 1、HTTP消息结构 （1）请求消息
（2）响应消息
组成部分说明 起始行
Start Line
请求消息：起始行包括请求方法、请求URI、HTTP版本；响应消息：起始行包括HTTP版本、状态码、状态文本信息； 头部字段
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/277c03790a1f7e1dc7fe5fb5b6111932/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bbec405340d3dca067c73197b5aaef1/" rel="bookmark">
			通过vagrant与VirtualBox 创建虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载vagrant与VirtualBox【windows版本案例】 1.1 vagrant 下载地址 【按需下载】 https://developer.hashicorp.com/vagrant/install?product_intent=vagranthttps://developer.hashicorp.com/vagrant/install?product_intent=vagrant
1.2 VirtualBox 下载地址 【按需下载】 Downloads – Oracle VM VirtualBoxhttps://www.virtualbox.org/wiki/Downloads
2.安装 2.1 windwos 版本为傻瓜式安装 点击软件安装即可 2.2 配置vagrant （1）安装vagrant后 可以通过命令来看是否安装成功，如果显示对应版本代表已经安装成功，如下所示
vagrant version (2) windwos 系统尽量不要在系统盘创建 ，在D盘 创建放置虚拟机目录。因为笔者想创建三台虚拟机，所以创建了三个目录。
（3）进入创建的目录，在此目录下打开终端【按住 “shift+右键” 即可看到在此处打开终端的操作】执行 vagrant init 【option】 会生成一个VagrantFile文件。因为笔者依然用的是centos7的镜像 所以在init 之后指定的是centos。
注意：如果都是通过当前镜像创建虚拟机，不需要每个目录进行 init 操作，只需要把生成的
VagrantFile 文件复制到其他目录即可。
vagrant init centos/7 （4）上述的centos/7 为什么这么配置 是在vagrant的云服务中有相关镜像 可以在第一次创建虚拟机之前 会从vagrant 官网自动下载到本地，再次创建新的虚拟机。下方为下载地址，以及网站截图。可自行查找自己需要的镜像。
Discover Vagrant Boxes - Vagrant Cloudhttps://app.vagrantup.com/boxes/search
(5) 执行 vagrant up 如果没有相关镜像，会先下载镜像，然后自动创建虚拟机，同样也是要和VagrantFile 在同级目录下执行此命令。下图为命令以及安装成功截图。
vagrant up （6）安装成功后，无需在VIrtualBox配置 会自动找到新建虚拟机，会自动显示在VIrtualBox中 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bbec405340d3dca067c73197b5aaef1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d780c6efa9e997d8b1efbe1d1c372e87/" rel="bookmark">
			20240712 每日AI必读资讯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📰人工智能现状报告最新重要发现！！
- 国外软件开发平台 Retool 日前调查约 750 位技术人员发现，AI 的采用率并没有飙升，但工作岗位的替代危机正在上演。
- AI 的采用率真的在飙升吗？真实现状：
（1）产品和工程是主体
（2）使用越多，生产力提升越显著
（3）工作中被允许使用 AI 的情况正在提升，但仍然有近三成在“偷偷”使用
- AI 正在取代工作岗位、ChatBot 进入厌倦期、向量数据库崛起
🔗 AI 正在取代工作岗位、ChatBot 进入厌倦期、向量数据库崛起，人工智能现状报告有这些重要发现！...-CSDN博客
🌐OpenAI将文本转语音 API 添加到了开发者Playground 中
- 只需输入文本消息，即可在六种预设声音中生成音频。
- 会根据文本自动匹配对应语言的语音，不需要选择语言国家。
- 方便开发者轻松构建应用。
🔗在线体验：https://platform.openai.com/playground/tts
🎙️AI对口型项目EchoMimic：音频+角色照片生成生动配嘴型视频 - 通过结合音频和面部标志，EchoMimic 提高了生成动画的稳定性，减少了抖动和失真。
- 使生成的面部动画更加符合自然的面部运动和表情变化。
- EchoMimic 不仅可以单独使用音频或面部标志点，还可以结合两者进行视频生成。
- EchoMimic 支持不同语言的音频输入，并能够根据不同语言的特点生成相应的肖像动画。
🔗演示：https://badtobest.github.io/echomimic.html 🔗 EchoMimic: Lifelike Audio-Driven Portrait Animations
🔗 https://blink.csdn.net/details/1754847 🖼️UltraEdit：更精准理解上下文指令 实现图片局部重绘和整体编辑
- 结合语言与视觉反馈，UltraEdit 打造全新图像处理方式
- 提供自由格式编辑和基于区域的编辑两种模式，满足不同需求
- 在丰富编辑任务和更少偏差方面具有明显优势，为用户提供高质量编辑体验
🔗 https://ultra-editing.github.io/
⌚ 三星推出 Galaxy Ring 智能戒指：可以进行7x24小时全天候健康监测
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d780c6efa9e997d8b1efbe1d1c372e87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/495a05bf226bac1a183281c8c49cf2e2/" rel="bookmark">
			Django ORM中的Q对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Q 对象在 Django ORM 中用于构建复杂的查询条件，特别是当你需要使用逻辑运算符（如 AND、OR、NOT）时。以下是一些使用 Q 对象进行复杂查询的实际例子。
Q对象使用 模型 假设我们有一个包含员工信息的模型 Employee：
from django.db import models class Employee(models.Model): name = models.CharField(max_length=100) age = models.IntegerField() department = models.CharField(max_length=100) salary = models.DecimalField(max_digits=10, decimal_places=2) hire_date = models.DateField() def __str__(self): return self.name 1. 使用 Q 对象进行 OR 查询 获取所有年龄大于30或工资高于50000的员工：
from django.db.models import Q # 获取所有年龄大于30或工资高于50000的员工 employees = Employee.objects.filter(Q(age__gt=30) | Q(salary__gt=50000)) for employee in employees: print(employee.name, employee.age, employee.salary) 2. 使用 Q 对象进行 AND 查询 获取所有年龄大于30且工资高于50000的员工：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/495a05bf226bac1a183281c8c49cf2e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4686eda218c6a18c997b98dcbde0c346/" rel="bookmark">
			Django ORM中的F 对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		F 对象非常强大，可以在查询和更新操作中进行复杂的字段间运算。
假设我们有一个包含商品信息的模型 Product：
from django.db import models class Product(models.Model): name = models.CharField(max_length=100) price = models.DecimalField(max_digits=10, decimal_places=2) discount_price = models.DecimalField(max_digits=10, decimal_places=2) stock = models.IntegerField() def __str__(self): return self.name 1. 比较两个字段的值 获取所有折扣价低于原价的商品：
from django.db.models import F # 获取所有折扣价低于原价的商品 discounted_products = Product.objects.filter(discount_price__lt=F('price')) for product in discounted_products: print(product.name, product.price, product.discount_price) 2. 字段间的算术运算 计算每个商品的折扣金额（原价减去折扣价），并按折扣金额排序：
# 计算每个商品的折扣金额，并按折扣金额排序 products_with_discount = Product.objects.annotate( discount_amount=F('price') - F('discount_price') ).order_by('-discount_amount') for product in products_with_discount: print(product.name, product.price, product.discount_price, product.discount_amount) 3. 使用 F 对象进行更新操作 将所有库存少于10的商品的价格提高10%：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4686eda218c6a18c997b98dcbde0c346/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a900b7e434c87c1101690191c6d82ed/" rel="bookmark">
			从 QWebEnginePage 打印文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QWebEnginePage 是 Qt WebEngine 模块中的一个类，它提供了用于处理网页内容的接口。如果你想要打印 QWebEnginePage 中的内容，你可以使用 QPrinter 和 QPrintDialog 类来实现。
项目配置了 Qt WebEngine 模块，并且在你的.pro文件中包含了相应的配置：
QT += webenginewidgets
实现代码如下，参考
printme « webenginewidgets « examples - qt/qtwebengine.git - Qt WebEngine
main.cpp
#include "printhandler.h" #include &lt;QApplication&gt; #include &lt;QShortcut&gt; #include &lt;QWebEngineView&gt; int main(int argc, char *argv[]) { QCoreApplication::setAttribute(Qt::AA_EnableHighDpiScaling); QApplication app(argc, argv); view.setUrl(QUrl(QStringLiteral("qrc:/index.html"))); view.resize(1024, 750); view.show(); PrintHandler handler; handler.setPage(view.page()); auto printPreviewShortCut = new QShortcut(QKeySequence(Qt::CTRL + Qt::Key_P), &amp;view); auto printShortCut = new QShortcut(QKeySequence(Qt::CTRL + Qt::SHIFT + Qt::Key_P), &amp;view); QObject::connect(printPreviewShortCut, &amp;QShortcut::activated, &amp;handler, &amp;PrintHandler::printPreview); QObject::connect(printShortCut, &amp;QShortcut::activated, &amp;handler, &amp;PrintHandler::print); return app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a900b7e434c87c1101690191c6d82ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e47609587c16f0baab215bdf5cdeb26/" rel="bookmark">
			习惯用Windows的设计师又想有类似Raycast的效率工具，怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你是一名习惯用Windows的设计师，同时又很想要有类似Raycast这种效率提升工具（Raycast是一款只支持在MacOS使用的效率工具，可以极大的提高使用Mac电脑办公人士的工作效率）。那么这次机会来了，你无需被迫换Mac电脑了，用Windows电脑照样可以工作效率翻倍！
最近有一款比较火的效率工具，支持在Windows上和MacOS上使用，同时可以拥有类似Raycast的效率提升效果，而且更符合国人的使用习惯（中文版，有客服答疑解惑，更符合国人的使用场景需求等）。
这款适合国人的效率工具名叫千鹿设计助手，目前这款产品使用前需要有邀请码，大家可以先用这个邀请码 fGa4Rd 大家注册成功之后会自动获得1000积分，这些积分后续在一些AI功能上可以直接使用。
下面我就来为大家介绍一下这款产品的特点以及如何帮助我们提高日常的工作效率。
1、特点
1.1这款产品主打的是插件化的设计理念，想使用哪个功能，就直接安装对应的插件，非常快捷方便，无需一开始装一堆自己不需要的功能模块。不想用具体的某个功能可以删除对应的功能插件。同时各种功能插件还在不断地增加中
1.2支持目前经常需要用到的各种AI功能，比如文生图、AI局部重绘、AI扩图、AI去背景、AI线稿上色、AI智能擦除等等
1.3支持与各种设计软件无缝对接，生成的图或者修改的图可以直接传给对应的设计软件，非常快捷方便
1.4功能可随时调用，不管是用快捷键还是用鼠标悬浮弹出对应的功能菜单，信手拈来，速度极快。
2. 常用的提高工作效率的实用功能
2.1快速搜索查找文件
直接Alt+F调出文件搜索框，输入想搜索的文件，瞬间就能从你的电脑硬盘中查找出所需的文件，比windows自带的搜索功能速度更快更细致，查找文件的最佳功能
2.2 文生图
日常苦于没有设计素材，直接使用文生图试试。输入想要的图片的描述词，或者输入中文点击右上角的翻译，千鹿助手会帮你自动翻译成英文。生成的图可以直接应用到各种设计软件中，非常快捷方便。
2.3 批量转化图片格式
这个是我经常需要用到的功能，直接快捷键调出批量转换格式的窗口，选择所有要转换格式的所有图，然后选择要转换的目标图片格式和目标图片存放的路径，直接点击“处理”按钮，瞬间就能完成图片格式的转换，非常方便快捷。
2.4批量压缩图片
压缩图片是日常最常用的功能，直接快捷键调出压缩图片功能窗口，选择所有需要压缩的图片，选择压缩程度选项，选择保存的路径，点击开始处理按钮就能获得压缩好的图片。
2.5. 批量改尺寸
修改尺寸也是常见的操作之一，直接快捷键调出批量改尺寸的功能窗口，选择所有需要改尺寸的图片，选择尺寸调整的方法（按比例，还是按定宽来改尺寸），点击开始处理按钮就能获得修改好的图片。
2.6 智能擦除
直接使用快捷键调出 智能擦除功能，添加所需擦除的图片
选择完图片之后，框选需要擦除的区域，点击立即擦除按钮，系统就会根据你选的区域进行智能擦除。
以上举例的只是个人日常工作中常用到的一些功能，千鹿设计助手已经能帮自己节省大量的时间。千鹿设计助手还有其他大量提高工作效率的功能模块，比如OCR文字识别、翻译、扩图、无损放大、截图、智能填充、去背景、取色器、高清修复、局部重绘、提示词生成器、线稿上色等等。这些大家可以自己尝试之后，选择自己日常工作中常用的功能来使用，应该能帮大家节省大量的时间。
目前千鹿设计助手使用前需要提交邀请码才能使用，大家可以使用这个邀请码 fGa4Rd
希望大家用千鹿设计助手之后，能节省大量的工作时间。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a95a75744ac5312cad512444c642553/" rel="bookmark">
			Java中的LinkedList（链表）（如果想知道Java中有关LinkedList的知识点，那么只看这一篇就足够了！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：在Java编程语言中，Java集合框架提供了一组丰富的数据结构，以满足各种应用需求。其中，LinkedList作为一种常用的数据结构，具有独特的优势和广泛的应用场景。
✨✨✨这里是秋刀鱼不做梦的BLOG
✨✨✨想要了解更多内容可以访问我的主页秋刀鱼不做梦-CSDN博客
先让我们看一下本文大致的讲解内容：
目录
1.LinkedList的初识
2.LinkedList的创建
3.LinkedList中的常见API
（1）添加元素
（2）删除元素
（3）修改元素
（4）获取元素
4.LinkedList的遍历
（1）使用 for 循环
（2）使用增强型 for 循环
（3）使用 Iterator
（4）使用 ListIterator
（5）直接打印
5.LinkedList与ArrayList的区别
1.LinkedList的初识 在开始学习LinkedList之前，让我们先了解一下什么是LinkedList：
LinkedList（双向链表）是一种基于链表实现的线性数据结构，与ArrayList（顺序表）等基于数组实现的结构不同，它通过节点的引用来管理元素的存储和连接。
其中每个节点包含三个主要部分：数据部分、指向下一个节点的指针（next）和指向前一个节点的指针（prev）。
下图很好的展示了什么是通过节点的引用来管理元素的存储和连接以及双向链表的构成：
—— 通过上边的解释，我相信读者你已经对LinkedList（双向链表）有了自己的初步认知，那么接下来我们从LinkedList在整个集合框架中与其他类与接口的关系来继续介绍LinkedList（双向链表）
LinkedList与其他类与接口的关系：
从上图中我们可以了解到：
1. LinkedList实现了List接口；
2. LinkedList的底层使用了双向链表；
3. LinkedList没有实现RandomAccess接口，因此LinkedList不支持随机访问；
通过上边的简单介绍，相信读者已经大致的了解了Java中的LinkedList，那么接下来让我们开始正式的来学习Java中的LinkedList（双向链表）吧。
2.LinkedList的创建 在Java中创建LinkedList有两种方式：
方法解释LinkedList()无参构造public LinkedList(Collection&lt;? extends E&gt; c)使用其他集合容器中元素构造List （1）让我们使用一个案例来看一下使用空参创建LinkedList的方式：
import java.util.LinkedList; public class LinkedListExample { public static void main(String[] args) { // 创建一个空的LinkedList LinkedList&lt;String&gt; linkedList = new LinkedList&lt;&gt;(); // 添加一些元素到LinkedList中 linkedList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a95a75744ac5312cad512444c642553/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6878566ab64d30350b9634425fd4b3fb/" rel="bookmark">
			【leetcode】滑动窗口专题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.长度最小的子数组2.无重复字符的最长子串3.最大连续1的个数III4.将x减小到0的最小操作数5.水果成篮6.找到字符串中所有字母异位词7.串联所有单词的子串8.最小覆盖子串 1.长度最小的子数组 leetcode 209.长度最小的子数组
看到这个题目，第一眼肯定想到的是暴力枚举，那我们就来枚举以下试试：
很明显，暴力枚举的方式会超时。
那有没有哪里能优化一下，让它不超时呢？我们来分析一下：
在暴力枚举中，我们的 right 每次都会回到left位置的下一个，然后和 left 一起重新枚举。
优化枚举具体步骤如下：
在上面的枚举过程中，我们的蓝色框就像是一个滑动的、大小不固定的窗口，我们称这种方式叫做滑动窗口
对与滑动窗口而言，无非就以下几个步骤：
每个题目窗口的起始、更新结果的位置是不固定的，具体情况具体分析。
按照滑动窗口的方法，我们的代码就不会超时啦。
简单分析以下时间复杂度：从代码看好像是O(n2)，但是由于我们滑动窗口的思想，两个指针是同向遍历，而且不会回退；当right指针结束时，循环结束，所以它的时间复杂度是O(n)。
class Solution { public: int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) { int ret = INT_MAX; int n = nums.size(); int sum = 0; for(int left = 0, right = 0; right &lt; n; right++)//right后移 { //进窗口 sum += nums[right]; //判断窗口 while(sum &gt;= target) { //符合条件，更新结果 ret = min(ret,right - left + 1); sum -= nums[left];//出窗口 left++; } } if(ret == INT_MAX) return 0; else return ret; } }; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6878566ab64d30350b9634425fd4b3fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ccd5667736cc3ee0bb4fb6caa88de06/" rel="bookmark">
			Java Stream API详解：高效处理集合数据的利器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 Java 8引入了许多新特性，其中最为显著的莫过于Lambda表达式和Stream API。Stream API提供了一种高效、简洁的方法来处理集合数据，使代码更加简洁明了，且具有较高的可读性和可维护性。本文将深入探讨Java Stream API的使用，包括基础概念、常用操作、并行处理、实战案例以及最佳实践等内容。
目录 什么是Stream APIStream API的基础操作 创建Stream中间操作终端操作 Stream API的高级操作 排序筛选映射规约收集 并行StreamStream API实战案例 处理集合数据文件操作数据库操作 Stream API的最佳实践常见问题与解决方案总结 什么是Stream API Stream API是Java 8引入的一种用于处理集合数据的抽象，它允许以声明性方式（类似SQL语句）来处理数据。Stream API提供了许多强大的操作，可以用来对集合进行过滤、排序、映射、规约等操作，极大地简化了代码。
特点 声明性编程：使用Stream API可以以声明性的方式编写代码，减少样板代码。链式调用：Stream API的操作可以链式调用，提高代码的可读性。惰性求值：中间操作是惰性求值的，只有在执行终端操作时才会进行计算。并行处理：支持并行处理，可以充分利用多核CPU的优势。 Stream API的基础操作 创建Stream Stream API提供了多种方式来创建Stream，常见的有以下几种：
从集合创建： List&lt;String&gt; list = Arrays.asList("a", "b", "c"); Stream&lt;String&gt; stream = list.stream(); 从数组创建： String[] array = {"a", "b", "c"}; Stream&lt;String&gt; stream = Arrays.stream(array); 使用Stream.of： Stream&lt;String&gt; stream = Stream.of("a", "b", "c"); 使用Stream.generate： Stream&lt;Double&gt; stream = Stream.generate(Math::random).limit(10); 使用Stream.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ccd5667736cc3ee0bb4fb6caa88de06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c5040d3c180f8389790f8c74dffefbe/" rel="bookmark">
			Java---SpringBoot详解二
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		勤奋勤劳铸梦成，
晨曦微露起长征。
汗水浇灌花似锦，
寒窗苦读岁月明。
千锤百炼心如铁，
万里征途志不倾。
持之以恒终有日，
功成名就笑谈中。
目录
一，统一响应结果
二，三层架构
三，分层解耦
四，IOC
五，DI
接上文Java---SpringBoot详解一-CSDN博客
一，统一响应结果 之前我们返回的结果都是各自返回各自的，这样客户端解析的时候就非常麻烦，不便于封装，下面是我们想要的结果：
客户端只需要根据Result这一种格式解析就可以。
下面我们创建一个Result类：
package com.yuanzhen.yzjavatest.bean; public class Result { private Integer code;//1成功，0失败 private String msg;//提示信息 private Object data;//数据date public Result() { } public Result(Integer code, String msg, Object data) { this.code = code; this.msg = msg; this.data = data; } public void setCode(Integer code) { this.code = code; } public void setMsg(String msg) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c5040d3c180f8389790f8c74dffefbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43bd299c8d898a02472a9f5249928311/" rel="bookmark">
			快递查询｜阿里云实现调用API接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整体请求流程
介绍：
本次解析通过阿里云云市场的云服务来实现程序中对快递包裹实时监控，首先需要准备选择一家可以提供快递查询的商品。
https://market.aliyun.com/apimarket/detail/cmapi00065859#sku=yuncode5985900001
步骤1: 选择商品
如图点击免费试用，即可免费申请该接口数据。
步骤2: 调试
输入对应的参数，查看文档后发现支持自动识别快递公司，那么直接输入单号 78792812069699
点击《发起请求》，即可看到响应列表中返回的实时数据，这样就表示整个接口请求完成，下一步就可以把该请求接入到对应程序中。
步骤3: 对接
在《买家控制台》可以查看您账户的appcode，网站还有其他开发语言的案例，可以对应您自身业务进行参考，下面以 python为例调用接口。
import urllib, urllib2, sys import ssl host = 'https://tsexpress.market.alicloudapi.com' path = '/exp/index' method = 'GET' appcode = '你自己的AppCode' querys = 'no=78792812069699&amp;phone=&amp;com=' bodys = {} url = host + path + '?' + querys request = urllib2.Request(url) request.add_header('Authorization', 'APPCODE ' + appcode) ctx = ssl.create_default_context() ctx.check_hostname = False ctx.verify_mode = ssl.CERT_NONE response = urllib2.urlopen(request, context=ctx) content = response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43bd299c8d898a02472a9f5249928311/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fab5995dc2ed8b86da4217a5aeae36ee/" rel="bookmark">
			（三）大模型/人工智能/机器学习/深度学习/NLP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一.模型 模型，简单来说，就是用来表示或解释某个事物、现象或系统的一种工具或框架。它可以是实体的，也可以是虚拟的，目的是为了帮助我们更好地理解和预测所描述的对象。在生活中，模型无处不在，它们以各种形式存在，帮助我们解决各种问题。
大白话：模型就像是一个简化的“影子”或“替身”，它代表了真实世界中的某个东西或过程，但比真实的东西更简单、更容易理解。比如，你想造一个房子，但直接造个真房子太麻烦了，所以你会先造一个小的、简化的房子模型，这样你就可以更容易地看到房子的样子，并计划如何建造它。
例子：
建筑模型：在建筑设计阶段，设计师会制作建筑的微缩模型，以便更好地展示建筑的外观、结构和布局。这个模型就是建筑的“代表”，帮助我们提前预览建筑建成后的样子。经济模型：经济学家会使用数学模型来描述和预测经济现象，如GDP增长、失业率变化等。这些模型通过一系列变量和方程式，将复杂的经济系统简化为可计算的形式，从而帮助政策制定者做出决策。交通流模型：交通工程师会使用交通流模型来模拟道路、高速公路和交通信号灯的运行情况。通过输入不同的道路元素、交通量和车速趋势，模型可以计算出最优化的交通流控制方案，以提高道路通行效率和安全性。 二.大模型 在人工智能（AI）领域，大模型指的是具有庞大参数规模和复杂网络结构的深度学习模型。这些模型通过海量数据的训练，能够学习到丰富的知识和特征，从而在各种任务中表现出色。
特点：
参数量大，通常由数百万到数十亿的参数组成。数据量大，需要海量的数据作为支撑。计算资源需求高，训练和推理过程需要大量的计算资源。应用场景广泛，可以应用于自然语言处理、计算机视觉、语音识别等多个领域。 大白话：大模型就像是超级复杂的“影子”，它比一般的模型要大得多，也复杂得多。在计算机世界里，大模型是由很多很多“小零件”（我们称之为参数）组成的，这些“小零件”一起工作，可以处理非常复杂的任务。就像是一个超级聪明的机器人，它有很多很多的大脑细胞（参数），所以它能做很多聪明的事情，比如听懂你的话、看懂你的照片等。 例子： 智能助手：像谷歌助手、苹果的Siri和亚马逊的Alexa等智能助手，都使用了基于大模型的语音识别技术。它们能够将用户的语音转换成文本，并执行相应的指令或回答用户的问题。图像识别：在医疗领域，大模型可以用于图像识别，帮助医生诊断疾病和辅助手术。通过分析患者的医疗图像，模型可以自动识别出异常区域或病变组织，为医生提供重要的参考信息。个性化推荐：在电商和新闻领域，大模型可以根据用户的历史行为和偏好，推荐相关的商品和文章。这种个性化推荐服务不仅提高了用户体验，还促进了销售和阅读量的增长。 三.人工智能 人工智能（AI）是一门模拟和扩展人类智能的学科。它旨在研究和开发能够模拟、延伸和扩展人的智能的理论、方法、技术及应用系统。AI 的目标是让机器能够胜任一些通常需要人类智能才能完成的复杂工作。
人工智能的实现依赖于多种技术和算法，包括机器学习、深度学习、自然语言处理、计算机视觉等。这些技术让计算机能够从大量数据中学习并提取有用的信息，从而变得更加“聪明”。
总之，人工智能就是让机器具备类似于人类的智能能力，以更加高效、准确地完成各种任务，并为我们的生活带来便利和改变。
大白话：
人工智能（Artificial Intelligence, AI）通俗来说，就是让机器或计算机能够模仿人类的智能行为，完成一些原本需要人类智慧才能完成的任务。这里说的“智能行为”包括但不限于思考、学习、推理、理解、交流、感知、决策等等。
想象一下，你有一个非常聪明的机器人朋友，它不仅能听懂你的话，还能理解你的情绪，甚至能跟你聊天、玩游戏、帮你解决问题。比如，当你问它“今天天气怎么样？”时，它不仅能告诉你温度、湿度等具体信息，还能根据你的行程建议你是否需要带伞或加衣服。这就是人工智能在发挥作用。
例子： 自动驾驶汽车就是人工智能的一个典型应用。汽车通过摄像头、雷达等传感器感知周围环境，并利用算法和模型来做出驾驶决策。这就是人工智能技术在汽车上的应用，使得汽车能够像人一样进行驾驶操作。
四.机器学习 机器学习是让计算机从数据中自动学习和改进的过程。它不需要显式编程来告诉计算机如何完成任务，而是让计算机通过观察和分析数据来自己找出完成任务的方法。
通过给计算机提供大量的历史数据（如用户行为记录、图像、文本等），机器学习算法能够自动地发现数据中的规律和模式，并利用这些规律来预测未来的数据或做出决策。
大白话：机器学习就是让计算机变得更聪明的一种方法。想象一下，你教一个小孩子认识苹果，你会给他看很多苹果的图片，告诉他这是苹果。机器学习就是类似的过程，但对象是计算机。你给计算机看很多数据（比如图片、文字等），并告诉它这些数据的一些特点（比如哪些是苹果），然后计算机就会自己学习，并尝试识别出更多的苹果。这样，计算机就变得越来越聪明了。
例子：当你在音乐App上听歌时，App会根据你的听歌历史和喜好为你推荐新的歌曲。这就是机器学习在发挥作用，通过分析你的听歌行为来预测你可能会喜欢的歌曲。 五.深度学习 深度学习是机器学习的一个子领域，它使用多层神经网络来模拟人脑的学习过程，从而实现对数据的自动特征提取和分类。
深度学习是机器学习的一种更高级的方法。它就像是给计算机装了一个更强大的“大脑”。这个“大脑”有很多层，每一层都能学习到数据的一些特点。就像是你教小孩子认识苹果时，他可能会先看到苹果的颜色，再看到苹果的形状，最后才认出这是苹果。深度学习也是这样的过程，但它能自动地、一层一层地学习到数据的特点，所以它能处理更复杂、更抽象的任务。
特点：
能够处理复杂、非线性的数据，如图像、声音和文本。自动提取数据中的关键特征，减少了对人工特征工程的依赖。在许多任务中表现出色，如图像识别、语音识别和自然语言处理。 大白话：
想象一下，你有一个非常复杂的任务，比如识别照片中的动物种类。这个任务对于人类来说可能相对简单，因为我们已经通过多年的学习和经验，积累了大量的关于动物的知识和特征。但是，对于计算机来说，这个任务就复杂得多了，因为它没有我们那样的直观感受和经验。
深度学习就是计算机用来学习这个任务的一种方法。它就像是一个聪明的孩子，在不断地观察、学习和尝试中，逐渐学会了如何识别照片中的动物。
这个“孩子”有一个非常特别的大脑，我们称之为神经网络。这个神经网络由很多层组成，每一层都负责学习不同的特征。比如，第一层可能学习一些简单的线条和形状，第二层则基于这些线条和形状学习更复杂的图案，第三层再基于这些图案学习更高级别的特征，以此类推。
这个学习过程是自动的，不需要我们人为地去告诉计算机每个特征是什么。相反，计算机通过查看大量的照片，自己发现哪些特征对于识别动物是有用的，并不断地调整和优化这些特征。
随着学习的深入，这个神经网络变得越来越擅长识别动物。当给它一张新的照片时，它能够快速地识别出照片中的动物种类，就像我们人类一样。
这就是深度学习的基本思想：通过构建多层的神经网络，让计算机自动地学习数据的特征和规律，从而完成复杂的任务。深度学习之所以强大，就是因为它能够自动地从数据中提取出有用的信息，而不需要我们人为地进行复杂的特征工程。
例子：手机翻译App中的自动翻译功能就使用了深度学习技术。当你输入一段文字或说出一句话时，App能够迅速将其翻译成另一种语言。这就是深度学习模型通过学习海量的双语对照数据来实现的。
六.NLP（自然语言处理） NLP是自然语言处理的缩写，它是指用计算机对自然语言的形、音、义等信息进行处理的技术。NLP的目标是让计算机能够理解和生成人类语言，从而实现人机之间的有效通信。
大白话：NLP就是让计算机能理解人类说的话和写的字的一种方法。想象一下，你和一个只会说机器语言（比如二进制代码）的机器人聊天，那肯定会很费劲。但如果你有一个懂NLP的机器人，它就能理解你说的话，并给出相应的回答。NLP技术让计算机能够读懂人类的语言，理解其中的意思，甚至还能生成人类的语言来回答我们的问题。
例子：智能语音助手（如Siri、小爱同学）就是NLP的应用之一。当你对语音助手说话时，它能够理解你的语言，并给出相应的回答或执行相应的操作。这就是NLP技术在后台分析你的语音数据，并将其转化为计算机可以理解的指令。
七.关系 人工智能是一个广泛的领域，它包含了机器学习、深度学习、NLP等多个子领域。机器学习是实现人工智能的一种重要手段，它让计算机能够从数据中自动学习和改进。深度学习是机器学习的一个分支，它使用多层神经网络来模拟人脑的学习过程。机器学习关注于让计算机从数据中自动学习和改进，而深度学习则是机器学习的一种特殊形式，它使用多层神经网络来实现学习。NLP是人工智能和机器学习在自然语言处理领域的应用，它专注于让计算机理解和生成人类语言。大模型则是深度学习领域中的一种特殊形式，它拥有海量的参数和复杂的结构，能够处理复杂的任务。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/841e672505e13625232f4a16283bf86d/" rel="bookmark">
			华为认证的证书有哪些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为认证的证书体系丰富多样，涵盖了多个技术领域和不同的认证级别。以下是对华为认证证书的主要分类和特点的归纳：
一、认证等级 技术认证是华为认证体系中的核心部分，主要分为以下三个级别：
HCIA（华为认证初级） 概述：HCIA是华为认证体系中的初级认证，主要面向入门级工程师。通过该认证，个人可以证明自己在华为技术领域具备了基本的知识和技能。方向：HCIA认证证书包括多个方向，如网络、云、人工智能等，满足不同领域的需求。特点：HCIA证书通常要求考生掌握华为相关产品或解决方案的基础知识，能够进行基本的配置和维护。HCIP（华为认证中级） 概述：HCIP是华为认证体系中的中级认证，主要面向高级工程师和技术专家。该认证要求个人在华为技术领域具备更深入的知识和技能。方向：HCIP认证证书同样包括多个方向，如路由交换、安全、云等，以满足不同领域的需求。特点：HCIP证书持有人能够设计和实现中大型企业网络解决方案，具备较高的技术水平和实践经验。HCIE（华为认证专家） 概述：HCIE是华为认证体系中的最高级别认证，主要面向专家级工程师。该认证要求个人在华为技术领域具备全面的知识和实践经验。方向：HCIE认证涵盖了华为技术的各个方面求个人具备高度的专业知识和技能。特点：HCIE证书持有人能够设计和实现大型、复杂的网络解决方案，是业界认可的专家级人才。此外，HCIE认证证书是纸质版套装证书，与其他两个级别的电子版证书有所不同。 二、认证方向
华为认证（Huawei Certification）涵盖了多个技术领域和方向，以满足不同行业和个人在数字化转型过程中的需求。以下是一些主要的华为认证方向：
网络方向： 安全：涵盖网络安全领域的各个方面，如防火墙、入侵检测/防御系统（IDS/IPS）、VPN等，旨在培养专业的网络安全人才。数据通信（路由交换）：涉及更高级的网络技术，如MPLS VPN、SDN（软件定义网络）、网络自动化等，适合需要处理复杂网络场景的专业人员。云与计算方向： 华为云：针对华为云平台的认证，包括云基础设施、云服务、云解决方案等多个方面，帮助个人和企业更好地使用和管理华为云资源。云计算：不仅限于华为云，还包括更广泛的云计算技术，如虚拟化、云存储、云管理、云安全等。大数据：针对大数据处理和分析技术的认证，包括Hadoop、Spark、大数据存储与管理等。存储与备份方向： 存储：专注于数据存储和备份技术的认证，包括SAN、NAS、对象存储、备份与恢复等，帮助企业和个人构建高效、可靠的数据存储解决方案。人工智能与物联网方向： AI：随着人工智能技术的兴起，华为也推出了相关的认证，涵盖机器学习、深度学习、自然语言处理等前沿技术。 综上所述，华为认证证书体系涵盖了多个技术领域和不同的认证级别，旨在满足不同领域和行业的需求，为个人和企业在相关领域的发展提供支持，伙伴们可以根据自身的基础情况、兴趣爱好来选择学习哪个方向。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/166/">«</a>
	<span class="pagination__item pagination__item--current">167/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/168/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>