<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48f989c56a679ec914c91581d5687da9/" rel="bookmark">
			windows环境(非docker)中利用Ollama和open webui部署运行大模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. ollama 下载安装： GitHub - ollama/ollama: Get up and running with Llama 3, Mistral, Gemma, and other large language models.
安装完成后可以在cmd命令提示符窗口中输入ollama -v查看是否安装好。
输入ollama run llama3可以直接下载llama3大模型并运行进行对话，默认是llama3:latest版本，8b的一个版本。该模型只能进行文本对话。
2. open webui下载安装 🚀 Getting Started | Open WebUI
官方文档推荐使用docker安装，这里我使用非docker的方式安装
2.1 安装node.js 下载 | Node.js 中文网 (nodejs.cn)
我直接安装的最新版本20.12.2
2.2 安装npm node.js 20.12.2版本需要npm版本10.5.0，较低版本后续配置open webui时会报错，通常配置过程中报错都是版本依赖问题。
由于本地已经有较低npm版本了，因此这里我就通过命令直接更新到指定版本
npm install npm@10.5.0
2.3 根据官方文档配置环境 先用git将源码拉下来并修改配置文件，配置文件中有ollama server端口地址11434，后续运行的命令 npm i以及pip安装依赖都需要在虚拟环境中运行。pip安装依赖过程可能网速会比较慢。
我本地环境中anaconda3版本不是最新的，也没准备直接更新到最新，因此cmd中直接通过conda命令创建的虚拟环境配置的。
conda create -n ollama python=3.11
conda activate ollama
配置好了启动open webui在虚拟环境中执行start_windows.bat，而不是start.sh，因为这里是windows环境。这里需要注意的是首次运行时会连接官网https://huggingface.co在线安装transformers库，由于国内被墙这里会报错。我这里是通过科学上网的方式下载的，据说有国内源可以下载，这里我就不在介绍了。错误如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48f989c56a679ec914c91581d5687da9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/429d3de7d0a9803cda007b5d8d0470dc/" rel="bookmark">
			【头歌-Python】Python第六章作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1关：列表的属性与方法 a = int(input()) ls = [] for i in range(a): t = input().split(" ") if t[0] == 'insert': ls.insert(int(t[1]), int(t[2])) elif t[0] == 'print': print(ls) elif t[0] == 'remove': ls.remove(int(t[1])) elif t[0] == 'append': ls.append(int(t[1])) elif t[0] == 'sort': ls.sort() elif t[0] == 'pop': ls.pop() elif t[0] == 'reverse': ls.reverse() 第2关：推导式与生成器 ls = ['the lord of the rings', 'anaconda', 'legally blonde', 'gone with the wind'] s = input() if s == '1': print([x ** 3 for x in range(10)]) elif s == '2': print([x ** 3 for x in [0, 2, 4, 6, 8]]) elif s == '3': print([(x, x ** 3) for x in [1, 3, 5, 7, 9]]) elif s == '4': for i in range(4): ls[i] = ls[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/429d3de7d0a9803cda007b5d8d0470dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f8aabcd3f3e0b889fa606fbf17c2f61/" rel="bookmark">
			【独家】万字长文带你梳理Llama开源家族：从Llama-1到Llama-3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Datawhale干货 作者：张帆，陈安东，Datawhale成员
引言 在AI领域，大模型的发展正以前所未有的速度推进技术的边界。
北京时间4月19日凌晨，Meta在官网上官宣了Llama-3，作为继Llama-1、Llama-2和Code-Llama之后的第三代模型，Llama-3在多个基准测试中实现了全面领先，性能优于业界同类最先进的模型。
纵观Llama系列模型，从版本1到3，展示了大规模预训练语言模型的演进及其在实际应用中的显著潜力。这些模型不仅在技术上不断刷新纪录，更在商业和学术界产生了深远的影响。因此，对Llama模型不同版本之间的系统对比，不仅可以揭示技术进步的具体细节，也能帮助我们理解这些高级模型如何解决现实世界的复杂问题。
文本将详细梳理Llama开源家族的演进历程，包括：
Llama进化史（第1节）
模型架构（第2节）
训练数据（第3节）
训练方法（第4节）
效果对比（第5节）
社区生态（第6节）
总结（第7节）
与此同时，我们还设计了一系列全面的开源课程（So-Lrage-Lm），旨在从多个维度深入解析大规模预训练语言模型的内在工作机制和外在应用场景。课程内容覆盖了从模型架构、性能评估，到数据管理和模型优化等关键技术点，以及模型在社会、环境和法律层面的复杂交互。
通过本课程，参与者将学习如何从理论和实践层面评估和优化大模型。我们的课程规划包括了一系列模块化的学习单元，每一单元都针对大模型的一个具体方面，从基础知识到高级应用逐步深入，确保学习者可以在结束课程后，独立进行大模型的设计、评估和应用。此外，课程中的案例研究和实践项目将直接关联到当前最前沿的AI技术和应用，以及这些技术如何在现实世界中找到应用。
点击访问课程地址或者阅读原文即可查看课程内容，欢迎Star~
https://github.com/datawhalechina/so-large-lm
1. Llama进化史 本节将对每个版本的Llama模型进行简要介绍，包括它们发布的时间和主要特点。
1.1 Llama-1 系列 Llama-1 [1]是Meta在2023年2月发布的大语言模型，是当时性能非常出色的开源模型之一，有7B、13B、30B和65B四个参数量版本。Llama-1各个参数量版本都在超过1T token的语料上进行了预训训练，其中，最大的65B参数的模型在2,048张A100 80G GPU上训练了近21天，并在大多数基准测试中超越了具有175B参数的GPT-3。
由于模型开源且性能优异，Llama迅速成为了开源社区中最受欢迎的大模型之一，以Llama为核心的生态圈也由此崛起。我们将在第6节对这一生态进行详细介绍。与此同时，众多研究者将其作为基座模型，进行了继续预训练或者微调，衍生出了众多变体模型（见下图），极大地推动了大模型领域的研究进展。
唯一美中不足的是，因为开源协议问题，Llama-1不可免费商用。
1.2 Llama-2 系列 时隔5个月，Meta在2023年7月发布了免费可商用版本 Llama-2 [2]，有7B、13B、34B和70B四个参数量版本，除了34B模型外，其他均已开源。
相比于Llama-1，Llama-2将预训练的语料扩充到了 2T token，同时将模型的上下文长度从2,048翻倍到了4,096，并引入了分组查询注意力机制（grouped-query attention, GQA）等技术。
有了更强大的基座模型Llama-2，Meta通过进一步的有监督微调（Supervised Fine-Tuning, SFT）、基于人类反馈的强化学习（Reinforcement Learning with Human Feedback, RLHF）等技术对模型进行迭代优化，并发布了面向对话应用的微调系列模型 Llama-2 Chat。
通过“预训练-有监督微调-基于人类反馈的强化学习”这一训练流程，Llama-2 Chat不仅在众多基准测试中取得了更好的模型性能，同时在应用中也更加安全。
随后，得益于Llama-2的优异性能，Meta在2023年8月发布了专注于代码生成的Code-Llama，共有7B、13B、34B和70B四个参数量版本。
1.3 Llama-3 系列
2024年4月，Meta正式发布了开源大模型 Llama 3，包括8B和70B两个参数量版本。除此之外，Meta还透露，400B的Llama-3还在训练中。
相比Llama-2，Llama-3支持8K长文本，并采用了一个编码效率更高的tokenizer，词表大小为128K。在预训练数据方面，Llama-3使用了超过15T token的语料，这比Llama 2的7倍还多。
Llama-3在性能上取得了巨大飞跃，并在相同规模的大模型中取得了最优异的性能。
另外，推理、代码生成和指令跟随等能力得到了极大的改进，使Llama 3更加可控。
2. 模型架构 本节将详细描述Llama的模型架构，包括神经网络的大小、层数、注意力机制等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f8aabcd3f3e0b889fa606fbf17c2f61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a442c072fb67202671488be141957661/" rel="bookmark">
			Android APK反编译就这么简单 详解（附图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android反编译整合工具包（最新） 下载
官方最新版本下载地址：
apktool（google code）
dex2jar（google code）
jd-gui（google code）最新版请见官方
工具介绍：
apktool
作用：资源文件获取，可以提取出图片文件和布局文件进行使用查看
dex2jar
作用：将apk反编译成Java源码（classes.dex转化成jar文件）
jd-gui
作用：查看APK中classes.dex转化成出的jar文件，即源码文件
反编译流程：
一、apk反编译得到程序的源代码、图片、XML配置、语言资源等文件
下载上述工具中的apktool，解压得到3个文件：aapt.exe，apktool.bat，apktool.jar ，将需要反编译的APK文件放到该目录下，
打开命令行界面（运行-CMD） ，定位到apktool文件夹，输入以下命令：apktool.bat d -f test.apk test
**
**
（命令中test.apk指的是要反编译的APK文件全名，test为反编译后资源文件存放的目录名称，即为：apktool.bat d -f [apk文件 ] [输出文件夹]）
说明获取成功，之后发现在文件夹下多了个test文件，点击便可以查看该应用的所有资源文件了。
如果你想将反编译完的文件重新打包成apk，那你可以：输入apktool.bat b test（你编译出来文件夹）便可，效果如下：
之后在之前的test文件下便可以发现多了2个文件夹:
build
dist(里面存放着打包出来的APK文件)
二、Apk反编译得到Java源代码
下载上述工具中的dex2jar和jd-gui ，解压
将要反编译的APK后缀名改为.rar或则 .zip，并解压，得到其中的额classes.dex文件（它就是java文件编译再通过dx工具打包而成的），将获取到的classes.dex放到之前解压出来的工具dex2jar-0.0.9.15 文件夹内，
在命令行下定位到dex2jar.bat所在目录，输入dex2jar.bat classes.dex，效果如下：
在改目录下会生成一个classes_dex2jar.jar的文件，然后打开工具jd-gui文件夹里的jd-gui.exe，之后用该工具打开之前生成的classes_dex2jar.jar文件，便可以看到源码了，效果如下：
被混淆过的效果图（类文件名称以及里面的方法名称都会以a,b,c…之类的样式命名）：
三、 图形化反编译apk（本人未使用过）
上述步骤一、二讲述了命令行反编译apk，现在提供一种图形化反编译工具：Androidfby
首先，下载上述反编译工具包，打开Androidfby目录，双击Android反编译工具.exe，就可以浏览打开要反编译的apk
自我介绍一下，小编13年上海交大毕业，曾经在小公司待过，也去过华为、OPPO等大厂，18年进入阿里一直到现在。
深知大多数初中级Android工程师，想要提升技能，往往是自己摸索成长或者是报班学习，但对于培训机构动则近万的学费，着实压力不小。自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《2024年Android移动开发全套学习资料》，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友，同时减轻大家的负担。
既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，基本涵盖了95%以上Android开发知识点，真正体系化！
由于文件比较大，这里只是将部分目录截图出来，每个节点里面都包含大厂面经、学习笔记、源码讲义、实战项目、讲解视频，并且会持续更新！
如果你觉得这些内容对你有帮助，可以扫码获取！！（备注：Android）
写在最后 在技术领域内，没有任何一门课程可以让你学完后一劳永逸，再好的课程也只能是“师傅领进门，修行靠个人”。“学无止境”这句话，在任何技术领域，都不只是良好的习惯，更是程序员和工程师们不被时代淘汰、获得更好机会和发展的必要前提。
如果你觉得自己学习效率低，缺乏正确的指导，可以一起学习交流！
加入我们吧！群内有许多来自一线的技术大牛，也有在小厂或外包公司奋斗的码农，我们致力打造一个平等，高质量的Android交流圈子，不一定能短期就让每个人的技术突飞猛进，但从长远来说，眼光，格局，长远发展的方向才是最重要的。
35岁中年危机大多是因为被短期的利益牵着走，过早压榨掉了价值，如果能一开始就树立一个正确的长远的职业规划。35岁后的你只会比周围的人更值钱。
《互联网大厂面试真题解析、进阶开发核心学习笔记、全套讲解视频、实战项目源码讲义》点击传送门即可获取！
的。
35岁中年危机大多是因为被短期的利益牵着走，过早压榨掉了价值，如果能一开始就树立一个正确的长远的职业规划。35岁后的你只会比周围的人更值钱。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a442c072fb67202671488be141957661/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6dd25535bb3aa137762ac76c174c922/" rel="bookmark">
			使用 ADB 命令在 Android 设备上进行截屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Android 开发和调试过程中，截取设备屏幕是一项非常有用的功能。ADB（Android Debug Bridge）是一个强大的工具，可以帮助我们与 Android 设备进行通信和调试。本文将介绍如何使用 ADB 命令在 Android 设备上进行截屏。
1. 准备工作 在开始之前，确保你已经完成以下准备工作：
在计算机上安装好 Android SDK，并且配置好了 ADB。连接你的 Android 设备到计算机，并确保 ADB 能够正确识别设备。 2. 使用 ADB 截屏命令 使用 ADB 截屏命令非常简单。下面是一些常用的命令：
方法一：使用 adb shell 命令 打开命令行终端，并执行以下步骤：
输入 adb devices 确保设备已连接。使用以下命令截取屏幕并保存为图片文件： adb shell screencap -p /sdcard/screenshot.png 将截图文件从设备复制到计算机上： adb pull /sdcard/screenshot.png 方法二：使用 adb exec-out 命令 输入 adb devices 确保设备已连接。使用以下命令截取屏幕并保存为图片文件： @echo off for /f %%A in ('powershell -Command "Get-Date -Format yyyy_MMdd_HHmm_ss"') do set "timestamp=%%A" echo Timestamp: %timestamp% adb exec-out screencap -p &gt; %timestamp%.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6dd25535bb3aa137762ac76c174c922/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bef09553f93dce1ffe8af96a49d8a50/" rel="bookmark">
			MySQL面经【索引】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		索引是什么 索引相当于一本书的目录，通过目录可以快速地找到对应的资源。 添加索引是给某一个字段，或者某些字段添加索引。
索引的种类 主键索引（PRIMARY） 数据列不允许重复，不允许为NULL，⼀个表只能有⼀个主键。 唯⼀索引（UNIQUE） 数据列不允许重复，允许为NULL值，⼀个表允许多个列创建唯⼀索引。 可以通过 ALTER TABLE table_name ADD UNIQUE (column);
创建唯⼀索引 可以通过 ALTER TABLE table_name ADD UNIQUE (column1,column2);
普通索引（INDEX） 可以通过 ALTER TABLE table_name ADD INDEX index_name (column); 创建普通索引
可以通过 ALTER TABLE table_name ADD INDEX index_name(column1,column2,column3); 创建组合索引
全⽂索引（FULLTEXT）
可以通过 ALTER TABLE table_name ADD FULLTEXT (column); 创建全⽂索引 索引的特点 索引加快数据库的检索速度索引降低了插⼊、删除、修改等维护任务的速度唯⼀索引可以确保每⼀⾏数据的唯⼀性通过使⽤索引，可以在查询的过程中使⽤优化隐藏器，提⾼系统的性能 索引需要占物理和数据空间 索引并⾮是越多越好，创建索引也需要耗费资源，
⼀是额外占用了数据库的存储空间
⼆是在插⼊和删除时要花费较多的时间维护索引
创建索引的三种方式 创建表时创建索引 在执⾏CREATE TABLE时创建索引
CREATE TABLE user_index2 ( id INT auto_increment PRIMARY KEY, first_name VARCHAR (16), last_name VARCHAR (16), id_card VARCHAR (18), information text, KEY name (first_name, last_name), FULLTEXT KEY (information), UNIQUE KEY (id_card) ); 使⽤ALTER TABLE命令去增加索引 ALTER TABLE table_name ADD INDEX index_name (column_list); ALTER TABLE⽤来创建普通索引、UNIQUE索引或PRIMARY KEY索引。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bef09553f93dce1ffe8af96a49d8a50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1951eed2a1eb21d40f6bb5710bce52fd/" rel="bookmark">
			解决IDEA报 Decompiled.class file, bytecode version 52.0 （Java 8）异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决idea报 Decompiled.class file, bytecode version 52.0 （Java 8）异常 今天在用 idea 写Java作业改.class类中的代码时，发现怎么都修改不了代码，显示该文件只读，报Decompiled.class file, bytecode version 52.0 （Java 8）的错误。如下图：
但其实解决方案特别简单！！我自己都被我自己逗笑了。
只需要检查是不是打开了out文件夹下的文件，而不是src文件夹目录下的文件。out文件夹下是编译过的文件，自然是只读的属性，只需要打开对应正确文件夹下目录的文件，即可正常编译了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0f1a16a482755ba9b10fde1ef1d64f2/" rel="bookmark">
			【AI开发：音频】一、GPT-SoVITS整合工具包的部署问题解决（GPU版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 目前GPT-SoVITS的合成效果比较不错，相比较其他厂商的产品要规整的多。众多厂家中也是国内使用最多的一款了，并且这个整合包里携带了，除背景音、切割、训练、微调、合成、低成本合成等一些列完整的工具，也可以作为API进行使用。
GPT-SoVITS是花儿不哭大佬研发的低成本AI音色克隆软件。
本文中，使用GPT-SoVITS-beta0306fix2说了下在部署过程中出现的问题，很多问题是几乎搜索不到的，在这里我进行了整理，进行逐一解决。
一、下载 语雀官网：GPT-SoVITS指南 · 语雀
项目地址：GitHub - RVC-Boss/GPT-SoVITS: 1 min voice data can also be used to train a good TTS model! (few shot voice cloning)
二、部署准备 我是在Winwods 10 64专业版部署，所以安装了Miniconda。
1.Miniconda安装 参考：【AI开发：环境篇】Anaconda安装和基础命令-CSDN博客
2.创建虚拟环境（python使用3.9） conda create --name win10 python=3.9 3.设定系统环境 参考：【AI开发：环境篇】Anaconda安装和基础命令-CSDN博客
4.关键点torch 重点：Miniconda是从清华源下载来的，默认的下载源也是清华源，但是清华源下载的torch是CPU版的，那么项目运行起来是找不到GPU的，会出现torch.cuda.is_available() 返回False。所以这里我们要用torch官网的源来进行安装。
题外话：torch.cuda.is_available() 返回False，这个问题不光是因为torch是CPU版本，还有可能是CUDA和torch之间的版本不兼容问题。在这里我们不要轻易去重新安装CUDA，更好的办法是控制torch的版本。
此次安装，我使用的CUDA版本是11.2，所以我再torch官网上下载比11.2高切相近的11.8。
torch官网：PyTorch
pip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118 测试下，到这里torch就没问题了！！！
三、GPT-SoVITS部署 1.安装GPT-SoVITS工具包 #一下操作可以在虚拟环境中执行，也可以在系统环境中执行，前面我们做了工作的。 #进入项目目录 cd E:\AI Go\GPT-SoVITS-beta0306fix2 #执行安装 pip install -r requirements.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0f1a16a482755ba9b10fde1ef1d64f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df3d41f327a1e5e7ad996e77a865c103/" rel="bookmark">
			运筹学基础（六）：列生成算法（Column generation）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言从Cutting stock problem说起常规建模Column generation reformulation 列生成法核心思想相关概念Master Problem (MP)Linear Master Problem (LMP)Restricted Linear Master Problem (RLMP)subproblem（核能预警，非常重要） 算法流程图CG求解cutting stock problem适用场景：large linear programming 参考资料 前言 学习列生成之前，有一些前置基础需要理解，不然就没法继续往下学了。所以为了写这篇文章，我提前铺垫了3篇文章帮助自己把基础捡起来！
单纯形法：运筹学基础（一）求解线性规划的单纯形法详解检验数：运筹学基础（四）：单纯形法中检验数（reduced cost）的理解对偶问题：运筹学基础（五）：对偶问题及其性质 今天终于可以进入正题了！
从Cutting stock problem说起 有一堆固定长度的钢管，不同的顾客想要长度不一样的钢管若干，怎么切割钢管能够使得消耗的钢管数最少？
常规建模 【集合】
K K K：未切割的钢管集合； I I I：所需钢管的种类集合； 【参数】
D i D_i Di​：第 i i i种钢管的需求数量； L k L_k Lk​：第 k k k根未切钢管的长度； L i L_i Li​：第 i i i种钢管的长度； 【决策变量】
x k i x_{ki} xki​：第 k k k根钢管切割第 i i i种长度的数量； y k y_k yk​：第 k k k根钢管是否使用； 【数学模型】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df3d41f327a1e5e7ad996e77a865c103/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b02d14c9b1bf85e8fc809211ec190665/" rel="bookmark">
			【Python】自定义修改pip下载模块默认的安装路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为电脑下载了Anaconda提供的默认Python 3.9 以及后期下载的python3.10所以在Pychram进行项目开发时，发现一些库怎么导入都导入不了，手动install也是失败，后期在cmd里面发现python以及pip配置有点儿混乱，导致执行命令时，下载的Lib库都在3.9下，但是Pychram编译环境是在3.10下，所以一直报红
一、对于 Windows 系统： 右键点击“计算机”或“此电脑”，选择“属性”。点击“高级系统设置”。在“系统属性”窗口中选择“环境变量”。在“系统变量”或“用户变量”中找到 Path 变量，选择它，然后点击“编辑”。添加 pip 的路径到列表中，例如：C:\Python310\Scripts\。点击“确定”保存更改。 之后，你可以直接在命令行中使用 pip --version 命令，因为现在系统会知道去哪里找 pip 可执行文件。
需要重新配置python3.10的环境变量，将之前安装Anaconda的python3.9给覆盖掉
配置成功后，发现pip的版本才22.0.4太低了，不足以下载tensorflow相关的库
没配好环境变量前，pip的version是24.0，但是path是python 3.9下的（所以提示pip版本太低，一直没发现猫腻，原来是path对不上）
配置成功后，可以执行 pip install tensorflow
安装成功！！！
二、修改pip文件下载模块的默认存储路径 pip.ini文件位置一般在C盘C:\Users…\AppData\Roaming\pip
方式一、在cmd下执行指令，其中：C:\Users\Cappuccino\AppData\Local\Programs\Python\Python310\Lib\site-packages 为需要安装的pip安装源位置，具体如下所示： pip config set global.target C:\Users\Cappuccino\AppData\Local\Programs\Python\Python310\Lib\site-packages 方式二、直接在pip.ini文件中直接修改，第一行是镜像源，第二行是pip文件修改位置。 [global] index-url = https://mirrors.aliyun.com/pypi/simple/ target = C:\Users\Cappuccino\AppData\Local\Programs\Python\Python310\Lib\site-packages 如果是刚配置的python环境，pip.ini文件是没有的，需要在执行完cmd执行指令之后才会生成，如果没有这个文件也可以手动创建该文件，文件路径：C:\Users…\AppData\Roaming\pip,具体如下图所示：
修改cmd情况下pip指令显示的模块地址与pycharm配置的环境中显示的文件地址： 步骤一：找到site.py文件位置 执行指令：python -m site -help
我的路径是在这块，一般都是在python路径下面，也可以执行指令：where python来查看python路径
步骤二、修改USER_SITE及USER_BASE值 未修改前一般是于python同一目录，因其为python文件，建议路径前面加r以免出现转义字符（r的作用：表示双引号当中为字符串，忽视当中可能出现的转义字符）具体如下所示：
USER_SITE = r"C:\Users\Cappuccino\AppData\Local\Programs\Python\Python310\Lib\site-packages" USER_BASE = r"C:\Users\Cappuccino\AppData\Local\Programs\Python\Python310" 步骤三：验证是否成功，执行指令：python -m site 说明 两个操作修改的作用位置不同，只修改pip.ini文件，在cmd情况下下载的模块包依旧会默认下载到需要的位置，但是如果未配置site.py文件，则pycharm读取的模块地址及cmd指令下如：pip list显示的模块位置默认还是python解析器下的地址，并非一回事。
该操作主要是考虑到自己的代码因为同步git的原因，在公司及自己的电脑上敲代码时为了避免每次都要下载模块包，为了避免麻烦而将模块包连同项目一并上传到git进行了托管，配置pip读取位置可以有效的避免模块读取位置及模块下载位置均可同步到git中。
三、镜像源 解决使用pip安装时报错Could not fetch URL https://pypi.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b02d14c9b1bf85e8fc809211ec190665/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ebec16b60e10175b027feab6dfcf2fe/" rel="bookmark">
			2024最好用的11个AI搜索引擎工具盘点！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0. 未来百科 未来百科，最大的 中文AI 产品导航网站 —— 为发现全球优质 AI 工具而生 。目前已 聚集全球 10000+优质 AI 工具产品 ，旨在帮助用户发现全球最好的 AI 工具，同时为研发 AI 垂直应用的创业公司提供展示窗口，迎接未来的 AI 时代。未来百科，每天带你了解好玩儿的 AI 工具。关注我，探索更多AI工具。
1. 360AI 搜索 访问 360AI 搜索: https://www.huntagi.com/sites/1706642948656.html
360AI 搜索介绍： 360AI 搜索，新一代智能答案引擎，值得信赖的智能搜索伙伴，为复杂搜索提供专业支持，解锁更相关、更全面的答案。AI 对用户提问进行精准语义分析，并通过追问获取更多有价值信息，将问题拆分为多组关键词后再进行搜索引擎检索，深度阅读网页内容，最终呈现逻辑清晰、准确无误的答案。
功能介绍： 提供联网搜索功能，可以获取丰富的信息资源。 支持语义理解和生成，能够回答用户提出的问题并给出详细答案。 具备知识增强大语言模型，可以进行逻辑推理和记忆功能。 新一代答案引擎 - 360AI 搜索 如今的搜索引擎似乎已无法满足我们的需求，我们明确知道自己想寻找什么，但搜索引擎却往往无法理解。 现在，360 集团全新升级的大模型搜索产品"360AI 搜索"应运而生，为最复杂的搜索查询提供更相关、更全面的答案。
2. 秘塔 AI 搜索 访问 秘塔 AI 搜索: https://www.huntagi.com/sites/1708434234533.html
什么是"秘塔 AI 搜索"？ 秘塔 AI 搜索是一款强大的搜索引擎，通过智能算法和机器学习技术，为用户提供高效、准确的搜索结果。不仅可以满足用户对各类信息的需求，还具备学术搜索功能，帮助用户快速找到相关研究论文。
"秘塔 AI 搜索"有哪些功能？ 全网搜索：秘塔 AI 搜索拥有广泛而丰富的网络资源库，能够全面覆盖互联网上的各类信息，并根据用户输入关键词进行精准匹配。 学术搜索：新增了学术搜索功能，在原有基础上增加了专门针对学术领域的数据源和算法模型。无论是科研人员、教育工作者还是学生群体都可以方便地查找到所需研究成果和文献资料。 智能推荐：秘塔 AI 搜索会根据用户历史查询记录和兴趣偏好进行个性化推荐，让每次检索都更加贴合用户需求。 快速响应：采用先进的分布式计算架构和优化算法，在保证查询质量的同时实现毫秒级响应速度。 产品特点： 无广告：秘塔 AI 搜索不会在搜索结果中显示任何广告，保证用户能够直达结果，不受干扰。 直达结果：秘塔 AI 搜索通过智能算法，能够准确理解用户的搜索意图，直接呈现最相关的结果，节省用户的时间。 深入搜索：秘塔 AI 搜索能够深入网页内容，提供更全面的搜索结果，让用户能够获取更多有价值的信息。 准确度高：秘塔 AI 搜索利用深度神经网络等先进技术进行数据处理与分析，从海量信息中筛选出最相关、最权威、最可信赖的结果。 用户友好：界面简洁清晰，操作简单直观。支持多种语言输入及自动纠错功能，提升使用体验。 隐私保护：严格遵守隐私政策，并采取多重安全措施保护用户个人信息安全。 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ebec16b60e10175b027feab6dfcf2fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/873cb87d9bdb4e59cf527c48642e1024/" rel="bookmark">
			JDK 11下载、安装、配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载 到Oracle管网下载JDK 11，下载前需要登录，否则直接点下载会出现502 bad gateway。
下载页面链接
https://www.oracle.com/hk/java/technologies/downloads/#java11-windows
登录
有些人可能没有Oracle账号，注册也比较慢，有需要的，可以在评论区回复，我把我下载的存储到了百度网盘，可以发给大家。
点击下图所示的view accounts登录。
在页面搜索11，找到Jdk 11，windows版本，点击下载
安装 双击下载的exe文件，一直点下一步就行，中间需要自己修改安装路径到自己想要安装的目标文件夹。
配置 基本配置
在环境变量中，需要配置Java Home，Path，CLASSPATH等信息。可以看我参考的博客。
JAVA_HOME：D:\Program Files\Java\jdk-11。
Path：%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;
CLASSPATH： .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;
删除Path变量里面的C盘里面的javapath
根据其他博主介绍，需要删除Path路径下面的javapath，否则会出问题，具体什么问题我不知道，我在配置的时候，直接删除了。
我选的路径是安装在D盘中的，也没有安装在C盘中，不知道这个路径是怎么生成的。
java11目录下没有jre这个路径
其他博主在安装后，也没有这个路径，但是我的配置项里面先保留着，因为有可能后面有些代码要使用jdk 8，要切回jdk8.
classpath相关配置
jdk11安装目录下的lib目录下，比jdk8也少了两个jar包，但是先留着吧，怕后面要切回jdk8.
参考 Win10安装jdk11及环境变量配置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e913ca3dabf776ae6cc2a679f728723f/" rel="bookmark">
			【建议收藏】用AI快速生成一个网页（名侦探柯南~灰原哀主题网页），适合大学生web期末大作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面是提供给AI的提示词和AI给出的代码以及成果展示
1、生成一个网页导航栏，宽度为1300px，高度为60px。导航区域在导航栏最右侧不超出导航栏，高60px，宽度500px，里面是5个导航菜单项横向排列，每个宽度100px，高60px。导航栏的背景颜色为#D7719B，字体大小为24px，链接颜色为白色，鼠标悬停时菜单项背景色变为橙色。
以下是使用 HTML 和 CSS 实现上述要求的导航栏的示例代码：
HTML:
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;link rel="stylesheet" type="text/css" href="styles.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;nav&gt; &lt;div class="nav-bg"&gt; &lt;div class="nav-links"&gt; &lt;a href="#"&gt;菜单 1&lt;/a&gt; &lt;a href="#"&gt;菜单 2&lt;/a&gt; &lt;a href="#"&gt;菜单 3&lt;/a&gt; &lt;a href="#"&gt;菜单 4&lt;/a&gt; &lt;a href="#"&gt;菜单 5&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt; &lt;/body&gt; &lt;/html&gt; CSS (styles.css):
.nav-bg { width: 1300px; height: 60px; background-color: #D7719B; font-size: 24px; } .nav-links { position: absolute; right: 0; top: 0; width: 500px; height: 60px; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e913ca3dabf776ae6cc2a679f728723f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7049be603bedafd3fb76c046faad818/" rel="bookmark">
			【GIS面试】GIS算法介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：后端小肥肠
1. 前言 在地理信息系统（GIS）的领域中，算法扮演着极其重要的角色，它们使得复杂的空间数据分析成为可能。无论是在环境科学、城市规划，还是在灾害管理等众多领域，高效和精确的算法都是必不可少的工具。本文将介绍GIS领域中几个关键算法，这些算法是每一位GIS专业人士在面试中都应该熟悉的知识点。
2. GIS关键算法介绍 2.1. 道格拉斯-普克算法（Douglas–Peucker） 1. 概念原理
道格拉斯-普克算法(Douglas–Peucker algorithm，亦称为拉默-道格拉斯-普克算法、迭代适应点算法、分裂与合并算法)是将曲线近似表示为一系列点，并减少点的数量的一种算法。该算法的原始类型分别由乌尔斯·拉默（Urs Ramer）于 1972年以及大卫·道格拉斯（David Douglas）和托马斯·普克（Thomas Peucker）于 1973年提出，并在之后的数十年中由其他学者予以完善。 算法的基本思路是：对每一条曲线的首末点虚连一条直线,求所有点与直线的距离,并找出最大距离值dmax ,用dmax与限差D相比:若dmax &lt;D，这条曲线上的中间点全部舍去；若dmax ≥D，保留dmax 对应的坐标点，并以该点为界,把曲线分为两部分，对这两部分重复使用该方法。
简单来讲，其实就是一种压缩算法，对线要素进行压缩，是一个重复的以直代曲的过程。 2. 应用场景
此算法极大地减少了需要处理和存储的数据量，特别是在地理信息系统中处理大规模地图数据时。应用包括移动设备的地图优化显示、实时交通管理系统中的路线简化，以及卫星图像的预处理，以提高处理效率和响应速度。
2.2. D8单流向算法 1. 概念原理
ArcGIS 水文分析的两个重要的基础，一是使用 DEM进行分析，二是分析的基础算法为D8单流向算法。 D8算法是假定雨水降落在地形中某一个格子上，该格子的水流将会流向周围8个 格子地形最低的格子中。如果多个像元格子的最大下降方向都相同，则会扩大相邻像元范围，直到找到最陡下降方向为止。
D8 算法又称作单流向算法。其特点就计算速度快，能够很好的反应出地形对地表径流形成的作用。但其弊端也是显而易见。因为水流只流向一个方向，是单线传递，一旦遇到某一洼地的时候，周边的水流都会集中向该洼地流入，导致断流现象,而现实中由于水会向多个方位不定 向的流动，是不会轻易导致断流的。如果要避免这种情况发生，就需要对地形中的洼地进行填平， 确保水流也能从该洼地流出。这就是为什么水文分析工具中出现了一些与水文分析完全没有关系的一个工具–填洼 。 从D8算法可以看出，ArcGIS 的水文分析工具是依赖无凹陷的DEM地形的，所以在分析之前都必须对DEM数据进行检查。【汇】工具和【填洼】工具就是为了分析前查找和填平洼地而生 的，在使用水文分析之前必须要使用这两个工具对DEM进行处理。
单流向算法影响限制了ArcGIS水文分析工具的使用。尤其是地势平坦的地区和人工干预比较多的城市区域，基本上不适用。因为地势平坦导致水流无法沿某一方向流动而形成径流。 另一种情况是事实上的断流形成，如存在地表水流汇流入地下水系的情况。一旦出现流入地下暗河，D8 算法就完全失效。因此，在喀斯特地貌中同样也不适用。 D8算法是完全不考虑降雨的多少、土壤渗透率、植被吸水以及水流挡阻等水文过程，它只是假 定有无限的降雨并最终汇聚水流形成径流，并通过汇流范围来定义最终的河流。因此，它只是一 个径流汇成河流的定性分析（尽管流量计算看起来是有定量因子），并不能通过其流量算法去做水文的预报。
2. 应用场景
该算法被广泛应用于环境科学和水文学中，如在洪水风险映射、流域管理和土地利用规划中。它帮助研究者和决策者预测在极端气候事件下可能出现的水流路径和集水区的变化。
2.3. 迪杰斯特拉算法（Dijkstra） 1. 概念原理
Dijkstra算法基于图论，使用广度优先搜索解决最短路径问题。它逐步扩展前沿，每次从未处理的顶点中选择距离起点最近的顶点，然后更新其相邻顶点的最短路径，这个过程一直进行到目标顶点被标记为已处理或所有顶点都被处理完。
2. 应用场景
这种算法被广泛应用于交通导航系统，如Google Maps和其他GPS导航软件中，提供给用户最短或最快的行驶路线。同时，在网络路由以及城市交通规划中也非常有用，帮助设计更有效的交通网络。
2.4. Floyd-Warshall算法 1.概念原理
Floyd-Warshall算法是一个全局最短路径算法，能够计算图中所有顶点对之间的最短路径。该算法通过逐步引入中介顶点，使用动态规划的方法更新顶点间的最短距离，最终得到一个距离矩阵，表示任意两点间的最短距离。
在计算机科学中，Floyd-Warshall 算法是一种在具有正或负边缘权重（但没有负周期）的加权图中找到最短路径的算法。算法的单个执行将找到所有顶点对之间的最短路径的长度（加权）。 虽然它不返回路径本身的细节，但是可以通过对算法的简单修改来重建路径。该算法的版本也可用于查找关系R的传递闭包，或（与Schulze投票系统相关）在加权图中所有顶点对之间的最宽路径。
2. 应用场景
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7049be603bedafd3fb76c046faad818/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e50308d03fba1c0e53394d81d5787e8/" rel="bookmark">
			C&#43;&#43; stl容器list的底层模拟实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言：
1.创建节点
2.普通迭代器的封装
3.反向迭代器的封装
为什么要对正向迭代器进行封装？
4.const迭代器
5.构造函数
6.拷贝构造
7.赋值重载
8.insert
9.erase
10.析构
11.头插头删，尾插尾删
12.完整代码+简单测试
总结：
前言： 模拟实现list，本篇的重点就是由于list是一个双向循环链表结构，所以我们对迭代器的实现不能是简单的指针的++，--了，因为我们知道，链表的存储不一定是连续的，所以直接++，--是链接不起来节点的，所以我们要对迭代器也就是对节点的指针进行封装。结尾会附上完整的代码。 1.创建节点 template&lt;class T&gt; struct list_node { list_node&lt;T&gt;* _prev; list_node&lt;T&gt;* _next; T _data; list_node(const T&amp; x= T())//这里不给缺省值可能会因为没有默认构造函数而编不过 :_prev(nullptr) ,_next(nullptr) ,_data(x) {} }; 注意给缺省值，这样全缺省就会被当做默认构造了，不会因为没有默认构造而报错。
我们实现的list是带哨兵位的，它同时是迭代器的end（）（因为是双向循环的list）。
2.普通迭代器的封装 template&lt;class T,class Ref,class Ptr&gt; struct _list_iterator { typedef list_node&lt;T&gt; node; typedef _list_iterator&lt;T, Ref, Ptr&gt; self; node* _node;//对迭代器也就是节点的指针进行封装，因为list迭代器是不能直接++的 _list_iterator(node* n) :_node(n) {} Ref operator*()//返回的必须是引用，不然改变不了外面的对象的成员,要支持对自己解引用改变值就要用应用 { return _node-&gt;_data; } Ptr operator-&gt;() { return &amp;(_node-&gt;_data);//返回地址，再解引用直接访问数据 } self&amp; operator++() { _node = _node-&gt;_next; return *this; } self operator++(int) { self tmp(*this);//默认的拷贝构造可以，因为没有深拷贝 _node = _node-&gt;_next; return tmp; } self&amp; operator--() { _node = _node-&gt;_prev; return *this; } self operator--(int) { self tmp(*this); _node = _node-&gt;_prev; return tmp; } bool operator!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e50308d03fba1c0e53394d81d5787e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af10383db9dded70d327d8ffc85c829f/" rel="bookmark">
			使用 Axios 处理 AxiosError 的三种常见方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用 Axios 时处理 AxiosError 有几种常见的方法:
使用 try-catch 语句捕获异常: try { const response = await axios.get('/api/data'); // 处理响应数据 } catch (error) { if (error.response) { // 请求成功但状态码不在 2xx 范围 console.log(error.response.data); console.log(error.response.status); console.log(error.response.headers); } else if (error.request) { // 请求发出但没有收到响应 console.log(error.request); } else { // 在设置请求时发生了错误 console.log('Error', error.message); } } 使用 Axios 实例的 interceptors 拦截器: const instance = axios.create(); instance.interceptors.response.use( (response) =&gt; { // 处理成功响应 return response; }, (error) =&gt; { // 处理错误响应 if (error.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af10383db9dded70d327d8ffc85c829f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f6799b8a3df9a2fa9007f50c79b8db6/" rel="bookmark">
			小程序获取微信头像与昵称
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过 button 组件 open-type 的值设置为 chooseAvatar，当用户选择需要使用的头像之后，可以通过 bindchooseavatar 事件回调获取到头像信息的临时路径。选择使用微信头像或者从相册选择以及拍照返回的都是临时路径（注意临时路径不能作为真正的路径存在数据库用户信息中）
需要将 input 组件 type 的值设置为 nickname，当用户在此input进行输入时，键盘上方会展示微信昵称。
从基础库2.24.4版本起，在onBlur 事件触发时，微信将异步对用户输入的内容进行安全监测，若未通过安全监测，微信将清空用户输入的内容，建议开发者通过 form 中form-type 为submit 的button 组件收集用户输入的内容。
官方文档：头像昵称填写 | 微信开放文档
将onChooseAvatar返回的临时链接通过wx.uploadFile()上传到自己的服务器，这个时候要注意：服务器返回的地址最好定义一个新的字段赋值，我自己尝试的赋给表单接收的变量，这个变量用在页面上，正式版渲染不出来
that.setData({
cover:data.data, // 页面可以渲染出来
'form.cover': data.data, // 页面渲染不出来
}); 小程序发布时如果选择了收集用户隐私，那么小程序后台-&gt;设置-&gt;服务内容声明-&gt;隐私服务协议。 隐私协议里边要提现用于******，收集用户的昵称，头像等
&lt;button open-type="chooseAvatar" bind:chooseavatar="onChooseAvatar"&gt;&lt;/button&gt; onChooseAvatar(e) { const {avatarUrl} = e.detail console.log("avatarUrl", avatarUrl) let that = this that.upload_file('上传文件接口',avatarUrl); }, upload_file: function (url, filePath) { var that = this; wx.uploadFile({ url: url, //后台处理接口 filePath: filePath, name: 'file', header: { 'content-type': 'multipart/form-data', 'Authorization': 'Bearer ' + wx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f6799b8a3df9a2fa9007f50c79b8db6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a68d241f348ec6351d5ac95089004ed/" rel="bookmark">
			最新 CentOS7 上使用 yum 安装 MySQL8 超详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS7 使用 yum 安装 MySQL8 卸载 1、检查本机是否已经安装mysql # rpm -qa | grep mysql
# rpm -qa | grep mariabd
命令举例如下：
[zhang@node4 yum.repos.d]$ rpm -qa | grep mysql mysql-community-libs-compat-8.0.36-1.el7.x86_64 mysql-community-client-plugins-8.0.36-1.el7.x86_64 mysql-community-libs-8.0.36-1.el7.x86_64 mysql-community-server-8.0.36-1.el7.x86_64 mysql-community-client-8.0.36-1.el7.x86_64 mysql-community-common-8.0.36-1.el7.x86_64 mysql80-community-release-el7-8.noarch mysql-community-icu-data-files-8.0.36-1.el7.x86_64 2、如已经安装，卸载已安装的mysql，不检查依赖关系 # rpm -e --nodeps 已经安装程序名称
命令举例：
[zhang@node4 yum.repos.d]$ su root Password: [root@node4 yum.repos.d]# rpm -e --nodeps mysql-community-libs-compat-8.0.36-1.el7.x86_64 [root@node4 yum.repos.d]# rpm -e --nodeps mysql-community-client-plugins-8.0.36-1.el7.x86_64 [root@node4 yum.repos.d]# rpm -e --nodeps mysql-community-libs-8.0.36-1.el7.x86_64 [root@node4 yum.repos.d]# rpm -e --nodeps mysql-community-server-8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a68d241f348ec6351d5ac95089004ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15c8aadceab5b7329eb306277ae2349a/" rel="bookmark">
			毕设：《基于hive的音乐数据分析系统的设计与实现》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 环境启动一、爬取数据1.1、歌单信息1.2、每首歌前20条评论1.3、排行榜 二、搭建环境1.1、搭建JAVA1.2、配置hadoop1.3、配置Hadoop环境：YARN1.4、MYSQL1.5、HIVE(数据仓库)1.6、Sqoop（关系数据库数据迁移） 三、hadoop配置内存四、导入数据到hive五、sqoop导入数据 环境启动 启动hadoop图形化界面
cd /opt/server/hadoop-3.1.0/sbin/ ./start-dfs.sh ./start-yarn.sh # 或者 ./start-all.sh 启动hive
hive 一、爬取数据 1.1、歌单信息 CREATE TABLE playlist ( PlaylistID INT AUTO_INCREMENT PRIMARY KEY, Type VARCHAR(255), Title VARCHAR(255), PlayCount VARCHAR(255), Contributor VARCHAR(255) ); # _*_ coding : utf-8 _*_ # @Time : 2023/11/15 10:26 # @Author : Laptoy # @File : 01_playlist # @Project : finalDesign import requests import time from bs4 import BeautifulSoup import pymysql db_connection = pymysql.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15c8aadceab5b7329eb306277ae2349a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aca3afa7b0dd98406fa02ae634777504/" rel="bookmark">
			MacOS 文件系统种类及介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MacOS 文件系统种类 详细介绍 详细介绍 从图片中我们可以看到一个文件系统选择器的界面，列出了多种不同的文件系统选项。这些文件系统各有其特点和用途，以下是它们之间的主要区别：
APFS：Apple File System，是苹果公司为其设备（如Mac和iOS设备）开发的新型文件系统。它支持快速的数据访问、加密和快照功能，为苹果设备提供了高效、安全的数据存储。
APFS (Encrypted)：这是APFS的加密版本。启用加密后，存储在APFS卷上的所有数据都会被加密，从而保护数据免受未经授权的访问。这对于个人隐私和安全性至关重要的场景来说是非常有用的。
APFS (Case-sensitive)：大小敏感的文件系统意味着它会区分文件名的大小写。例如，“File.txt”和“file.txt”会被视为两个不同的文件。这在某些特定应用场景（如编程和开发）中可能是必要的。
APFS (Case-sensitive, Encrypted)：这是结合了大小敏感和加密功能的APFS版本。它同时提供了数据的大小敏感存储和加密保护。
Mac OS Extended (Journaled)：这是旧版Mac OS X中使用的标准文件系统。它使用了日志技术（journaling），有助于在突然断电或其他意外情况下更快地恢复文件系统的一致性。
Mac OS Extended (Case-sensitive, Journaled)：这是Mac OS Extended的一个变种，支持大小敏感的文件名。
ExFAT：这是一个常用于闪存驱动器（如USB闪存盘）的文件系统，它支持大文件和跨平台兼容性。
MS-DOS (FAT)：这是非常老旧的文件系统，常用于早期的Windows系统和一些闪存驱动器。它不支持大文件或长文件名，且没有加密或高级日志功能。
总的来说，这些文件系统之间的主要区别在于它们对数据的处理方式、是否支持加密、是否区分大小写以及适用的平台和场景。选择哪种文件系统取决于具体的需求，如性能、安全性、兼容性等。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/404/">«</a>
	<span class="pagination__item pagination__item--current">405/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/406/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>