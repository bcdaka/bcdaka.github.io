<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d9fdc5fa7bd7903fd91f6959b7e61f1/" rel="bookmark">
			restful传值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@GetMapping 普通的get请求 后端：
restfule的get请求 通过/asd/123这种方式get请求传入后端
前端
url: '/system/role/deptTree/' + roleId + '/' + tenantId, method: 'get' 后端@PathVariable从path上取对应的值
通过
@GetMapping(value = "/deptTree/{roleId}/{tenantId}") public AjaxResult deptTree(@PathVariable("roleId") Long roleId,@PathVariable("tenantId")Integer tenantId){ } get请求，对象接收，不用@RequestBody
@PostMapping 前端
参数名对应，post请求传数组到后端
this.download('monitor/operlog/export', { ids: this.ids.join(','), tenantId: 123 }, `操作日志信息列表.xlsx`) 后端，参数名对应，直接接收到，不用注解
@PostMapping("/export") public void export(HttpServletResponse response,String ids,Integer tenantId) { @PutMapping 前端
data是form表单数据后端
实例1
前端参数 { "orderId": "123", "addedFees": [{ "feeType": "34", "feeName": "过路费", "feeAmount": "1121" }, { "feeType": "33", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d9fdc5fa7bd7903fd91f6959b7e61f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18caa4112c9c160a9447a58e2a6ae7f3/" rel="bookmark">
			go 中判断slice中是否包含某个字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Go 中判断一个 slice 中是否包含某个字符串，可以通过遍历 slice 来实现。以下是一个简单的示例代码：
package main import ( "fmt" ) func contains(slice []string, item string) bool { // 遍历slice中的每个元素 for _, v := range slice { // 判断元素是否等于目标字符串 if v == item { return true } } return false } func main() { // 示例slice mySlice := []string{"apple", "banana", "cherry"} // 判断"banana"是否在slice中 if contains(mySlice, "banana") { fmt.Println("Found") } else { fmt.Println("Not Found") } // 判断"orange"是否在slice中 if contains(mySlice, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18caa4112c9c160a9447a58e2a6ae7f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6535dd2f430d4d5d2576ab66287d3166/" rel="bookmark">
			IP地址证书申请流程教学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IP地址证书是一种特殊的SSL/TLS证书，它与传统的基于域名的证书有所不同。为了确保网站的安全传输和建立用户的信任，安装SSL证书是必不可少的。那么IP地址申请SSL证书该怎么操作呢，首先可以申请基于IP地址的SSL证书，需要确保IP地址的适用性
下面是具体的申请操作流程：
1.申请入口：登录JoySSL官网，在右上角点击注册，注册账号时会要求填写注册码，填写后可获取渠道低价和一对一技术支持，有需要的可填写“230922”
IP SSL证书-JoySSLhttps://www.joyssl.com/certificate/select/ip_certificate.html?nid=22
2.提供必要信息：根据证书供应商的要求，提供申请SSL证书所需的相关信息，包括组织或个人信息等。
3.完成验证流程：证书供应商将对身份进行验证，以确保所申请域名或IP地址的所有权。
总的来说在申请基于IP地址的SSL证书时，务必确保满足所有条件，并选择一个可靠的证书提供商。同时，要注意证书的有效期，需要及时更新证书以避免过期以维护网站的安全性和可靠性
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/978814d49e07c74eaf14a2aab1acbfac/" rel="bookmark">
			RuoYi-Vue前后端分离版集成Cas单点登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		后端 1.添加CAS依赖 在common模块pom添加spring-security-cas依赖： &lt;!-- spring security cas--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-cas&lt;/artifactId&gt; &lt;/dependency&gt; 2.修改配置文件 在admin模块下的application.yml配置文件中添加： # CAS 相关配置 start # CAS服务器配置 cas: server: host: #CAS服务地址 url: http://host:port/sso #CAS ticket 验证 服务地址 ticket_validator_url: http://host:port/sso #CAS服务登录地址 login_url: ${cas.server.host.url}/login #CAS服务登出地址 logout_url: ${cas.server.host.url}/logout?service=${cas.server.host.url}/login?service=${app.server.host.url} #应用访问地址 app: #项目名称 name: Xxx #是否开启CAS casEnable: true server: host: #项目地址 url: http://host:${server.port} #应用登录地址 login_url: / #应用登出地址 logout_url: /logout #前端回调地址 callback_url: /cas/index #前端登录地址 web_url: http://host:port/xxx_vue # CAS 相关配置 end 3.修改LoginUser.java 由于CAS认证需要authorities属性，此属性不能为空，此处为了方便直接new HashSet(): package com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/978814d49e07c74eaf14a2aab1acbfac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90408fc2d31b256eb8c50eceeab27352/" rel="bookmark">
			灵办AI助手Chrome插件全面评测：PC Web端的智能办公利器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		探索灵办AI助手在Mac OS上的高效表现，支持多款主流浏览器，助你轻松应对办公挑战 文章目录 探索灵办AI助手在Mac OS上的高效表现，支持多款主流浏览器，助你轻松应对办公挑战摘要引言开发环境介绍核心功能评测1. 网页翻译与双语对照 🌍2. AI对话功能 💬3. AI阅读功能 📚4. AI代码助手 💻 用户体验评测1. 安装与设置 🔧2. 操作界面与用户交互 🖱️3. 性能与稳定性 ⚙️ 总结与建议综合评价 🏅优缺点分析 💡优化建议 🛠️适用场景与目标用户 🎯 摘要 灵办AI助手是一款功能强大的办公工具插件，支持Chrome、Edge、360等主流浏览器，并且在Mac OS上表现尤为出色。本文将深入评测其网页翻译、AI对话、AI续写、AI阅读等核心功能，展示其在实际应用中的效果。同时，我们还将提供详细的安装与设置指南，助你轻松上手这款效率神器。如果你迫不及待想要体验，可以通过点击📲 👉链接：https://ilingban.com/browser_extension/?from=mth立即安装。
引言 大家好，我是猫头虎，今天为大家介绍一款能够显著提升工作和学习效率的神器——灵办AI助手。🌟 在信息化办公的时代，各种工具层出不穷，但真正能够满足我们需求的却寥寥无几。本文将深入评测灵办AI助手在Mac OS上Chrome插件版本的实际表现，帮助你判断这款工具是否值得在日常工作中使用。同时，我们也将简要介绍灵办AI助手对其他浏览器的支持，方便你在不同平台间自由切换。
开发环境介绍 本次评测的主要环境是Mac OS，浏览器选择了最新版本的Chrome。灵办AI助手不仅支持Chrome，还能无缝兼容Edge、360、360极速浏览器，用户在Windows和Mac OS系统中都能轻松使用。这次评测将聚焦于Chrome插件版本，通过实际使用探寻其效用。
核心功能评测 1. 网页翻译与双语对照 🌍 跨语言沟通在现代办公中至关重要。灵办AI助手提供的网页翻译功能支持多种语言，翻译速度与准确性俱佳。双语对照功能让你能够轻松对比原文与译文，帮助理解复杂的外文内容。
只需简单的三步操作，即可解决双语翻译问题，如下图所示：
评测结果：翻译准确度高，特别是在专业领域的文章中表现出色。双语对照展示整齐，帮助用户更好地理解复杂内容。
2. AI对话功能 💬 灵办AI助手不仅能回答日常工作中的各类问题，还能够在已有文本的基础上进行智能续写，帮助你完成未完待续的创作任务。无论是续写故事、文章，还是补充技术文档，灵办AI助手都能为你提供高效的帮助，确保内容延续一致。
例如，以下是一个提示词：“在这次项目的关键阶段，团队面临了前所未有的挑战……”。灵办AI助手可以基于此提示词进行续写，提供完整且逻辑连贯的内容扩展。
下图展示了灵办AI助手续写的效果：
评测结果：对话功能响应迅速，回答精准，续写的内容自然且逻辑连贯，能够有效丰富和拓展原有文本，显著提升工作效率。
3. AI阅读功能 📚 面对海量信息，灵办AI助手的AI阅读功能能够帮助你解析复杂文章，并快速提炼出关键要点，极大提高信息处理效率。只需选中网页内容，点击悬浮图标，即可快速生成摘要。
如下图所示：
评测结果：文章解析精准，摘要提取到位，信息整合功能尤为突出，有效帮助用户掌握核心内容。
4. AI代码助手 💻 灵办AI助手不仅在内容创作上表现出色，作为开发者的辅助工具同样强大。通过代码生成和纠错功能，开发者能够更高效地完成任务。我测试了一个生成美颜算法的案例，效果如下图所示：
评测结果：代码生成准确，逻辑性强。纠错功能对多种编程语言支持良好，错误识别准确，显著提升了编程效率。
用户体验评测 1. 安装与设置 🔧 灵办AI助手的安装过程非常简便，无需复杂操作。初次使用时，系统会引导完成必要的配置，帮助用户迅速上手。如果你还没有安装，点击📲 👉链接：https://ilingban.com/browser_extension/?from=mth进入灵办AI助手工具下载页，按照如下步骤完成安装配置即可。
详细安装步骤如下图所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90408fc2d31b256eb8c50eceeab27352/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e39f4dd92aba17e988b6fb2411307ce4/" rel="bookmark">
			【算法/训练】：动态规划（线性DP）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、路径类 1. 字母收集 思路：
1、预处理
对输入的字符矩阵我们按照要求将其转换为数字分数，由于只能往下和往右走，因此走到（i，j）的位置要就是从（i - 1， j）往下走，或者是从(i，j - 1)的位置往右走，由于我们要使得路程遍历积分最多，则应该从积分多的位置过来，
2、状态表示 dp[i][j] 表示：从[0, 0]出发，到底[i, j]位置，一共有多少分
3、状态转移方程
故（i，j）位置的积分应该为dp[ i ][ j ] = max(dp[ i - 1 ][ j ], dp[ i ][ j - 1 ]) + dp[ i ][ j ];
4、初始化
但是上面仅对于（i &gt;= 1 &amp;&amp; j &gt;= 1）成立，对于第一行和第一列我们应该特殊处理，利用前缀和的知识可以求得，走到第一列的第i个位置最多能拿的积分以及走到第一行的第j个位置最多能拿的积分，然后我们就可以按照dp[ i ][ j ] = max(dp[ i - 1 ][ j ], dp[ i ][ j - 1 ]) + dp[ i ][ j ]的方法遍历每个节点即可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e39f4dd92aba17e988b6fb2411307ce4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f1a326fb754e40d53bf4ba190e6f48a/" rel="bookmark">
			《花100块做个摸鱼小网站! 》第二篇—后端应用搭建和完成第一个爬虫
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 大家好呀，我是summo，前面已经教会大家怎么去阿里云买服务器（链接在这，需要自取：https://developer.aliyun.com/huodong/dashiblogger?userCode=mtbtcjr1），以及怎么搭建JDK、Redis、MySQL这些环境或者数据库。从这篇文章开始就进入正式的编码阶段了，我们从后端开始，先把热搜数据获取到，然后再开始前端部分。
本来我想把后端应用搭建和完成第一个爬虫分为两篇文章写的，但是想到墨迹三周还没看到效果，估计有些同学已经等不及了，所以我把这两篇文章合成一篇了，篇幅比较长，感兴趣的同学可以认真看下。因为后端应用初始化的时候涉及很多配置，有很多命名，建议大家写别急着个性化用自己的名字命名应用和配置，可以先用我的命名方式搭建一个出来，先成功再研究个性化，这样成就感很足，学习动力也强。
二、后端应用搭建 这个摸鱼小网站主要使用的SpringBoot框架配合一些中间件实现，开发工具用的是idea社区版，建议不要下载人家的正式版然后破解，一来麻烦的很，二来社区版足够开发使用了，点击这个可以下载idea社区版。
1. maven项目搭建 打开idea后，点击New Project，我们从一个空的maven项目开始，一步步把项目搭建出来。
我们输入name、GroupId、ArtifactId点击确定，如果你是老手可以自己搭建，如果你是新手建议跟我输的一样，因为后面还有很多地方要用的这些名字。
把src目录删掉，我们不需要，只留下pom.xml文件就行了。
接下来我们开始创建子module，创建方式如下图：
以summo-sbmy-start子module为例，输入如下的信息就可以创建一个module出来啦。
按照这个方式创建出如下的module出来。
2. pom.xml配置 这部分我现在不详细说，后面我会单独写一篇文章讲我的依赖和配置。如果刚才你的名字取得跟我一样，直接复制粘贴就完事了，如果名字不一样记得把名字给替换为你的。
（1）summo-sbmy pom.xml内容如下：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.15&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.summo&lt;/groupId&gt; &lt;artifactId&gt;summo-sbmy&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;summo-sbmy-dao&lt;/module&gt; &lt;module&gt;summo-sbmy-service&lt;/module&gt; &lt;module&gt;summo-sbmy-web&lt;/module&gt; &lt;module&gt;summo-sbmy-start&lt;/module&gt; &lt;module&gt;summo-sbmy-job&lt;/module&gt; &lt;module&gt;summo-sbmy-common&lt;/module&gt; &lt;/modules&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- 自依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.summo&lt;/groupId&gt; &lt;artifactId&gt;summo-sbmy-common&lt;/artifactId&gt; &lt;version&gt;${project.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.summo&lt;/groupId&gt; &lt;artifactId&gt;summo-sbmy-service&lt;/artifactId&gt; &lt;version&gt;${project.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f1a326fb754e40d53bf4ba190e6f48a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4707ceb41b7b200b24a32c8517a1786/" rel="bookmark">
			「Mac上的数据库狂欢」：Docker开箱，秒变数据大神！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 篇幅有点长，大家可以打开目录快速跳转到想要的数据库即可！
虽然说用命令行会显得我们更加专业一些，但对于我英语水平不怎么好的人来说，毕竟命令多又长，还不好记。我个人是喜欢复杂问题简单化，踩了很多的坑，摸索着探出一条更适合处于初期或是过渡期的小伙伴，后期咱们可以试着去对付命令行。其实没什么好尴尬的，只要你会用自己喜欢的方式，无论高不高级，你一样优秀！！！只要你的电脑有Docker，就能操作！
本次我们要下载的数据库（准确来说是镜像）有Mysql、SQL server、Postgres sql、Mongo db、Redis、Clickhouse、DM（达梦）、Presto、Mariadb…
后面还会继续推出相应的数据库：oracle、hive…
Docker下载安装 Mac安装官网地址：https://hub.docker.com/
选择你的Mac芯片型号，我这里是M2芯片，选择第二个，英特尔选择第一个。
正在下载中…
桌面右键（双指）推出Docker
安装完毕之后，顶部的菜单栏里会有个小鲸鱼图标：
打开Docker：
后面下载镜像并运行的时候，你们就能更清晰地认识到这些概念了，莫急。
另外在这里，如果科学上网的话，咱们就要配置国内镜像源。安装好 Docker 后，其 registry server 是默认指向 https://hub.docker.com 的。在国内该hub源访问速度异常慢，尤其是大一点的镜像经常出现timeout。我们可以通过切换至国内镜像仓库来解决这一问题。
修改源具体需要添加如下内容：
{ "registry-mirrors": [ "https://registry.docker-cn.com", "https://hub-mirror.c.163.com", "https://mirror.baidubce.com", "https://ccr.ccs.tencentyun.com", "https://docker.mirrors.ustc.edu.cn" ] } 1.Docker中国区官方镜像：https://registry.docker-cn.com
2.网易：http://hub-mirror.c.163.com
3.百度：https://mirror.baidubce.com
4.中国科技大学：https://docker.mirrors.ustc.edu.cn
5.腾讯云：https://ccr.ccs.tencentyun.com
右下角记得Apply&amp;restart!
接下来我们就来依次下载镜像…
在Docker上下载镜像 mysql 打开docker顶部菜单搜索栏里，快捷键Command + K
搜索mysql，在这里我们可以看到很多镜像，我们可以看到下载数和收藏数，有绿色标志的就是官方推出的docker镜像，这里选择第一个
点击pull拉取镜像，这里版本就默认选择最新的了
最核心的一步：设置你的数据库端口号、用户名以及密码。设置完毕后点击Run，这里详细说明一下：
Container name：容器名。注意中间不要有空格，否则会报错Host port：端口号。这里最好换一个自己习惯的端口号，不建议使用官方默认的端口号（避免使用默认端口号可以提高安全性、避免端口冲突以及方便管理和维护）Environment variables：环境变量参数设置。这里按照我提供的参数填入就好，Value就是参数值，按照Variables进行填写，纯靠英语水平。哈哈
环境变量参数：MYSQL_ROOT_PASSWORD 这个时候，容器就会运行，并打印日志，查看有无报错信息。
返回之后可以看到:Status显示Running，CPU的占用率，端口号以及最后一次打开的时间：
检查无误后，就可以打开数据库可视化管理工具（Navicat、DataGrip、Chat2DB等等）进行连接了，一般都会有自带的Download Driver，正常下载驱动，填写好基本信息就可以使用了，这里以Chat2DB进行演示，连接成功！
这里小编强烈推荐这款国产数据库工具：Chat2DB
简介：Chat2DB 是一款AI first的数据管理、开发、分析工具，它的核心是AIGC（Artificial Intelligence Generation Code）能力，它可以将自然语言转换为SQL，也可以将SQL转换为自然语言，也可以自动生成报表，极大的提升人员的效率。通过一个产品可以实现数据管理、数据开发、数据分析的能力，即使不懂SQL的运营业务也可以使用快速查询业务数据、生成报表能力。
官方网址：http://chat2db.ai/zh-CN
github：https://github.com/chat2db/Chat2DB
SQL Server 打开终端，输入以下命令：（客户端没有，离谱） // 下载sqlserver镜像 docker pull mcr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4707ceb41b7b200b24a32c8517a1786/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91cd419ba28d4f43c41a0042552a2bc6/" rel="bookmark">
			成功解决7版本的数据库导入 8版本数据库脚本报错问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我 | 在这里
⭐ 全栈开发攻城狮、全网10W+粉丝、2022博客之星后端领域Top1、专家博主。
🎓擅长 指导毕设 | 论文指导 | 系统开发 | 毕业答辩 | 系统讲解等。已指导60+位同学顺利毕业
✈️个人公众号：热爱技术的小郑。回复 Java全套视频教程 或 前端全套视频教程 即可获取 300G+ 教程资料，以及大量毕设项目源码。
🐬专注干货知识分享、项目实战案例开发分享
🚪 传送门：Github毕设源码仓库
文章目录 前言解决办法注意 前言 在使用可视化操作工具Navicate运行数据库脚本的时候 报的错误：Unknown collation: ‘utf8mb4_0900_ai_ci’
解释：这个错误通常是因为你的 MySQL 数据库版本不支持 utf8mb4_0900_ai_ci 排序规则。在 MySQL 5.7 之前，utf8mb4_0900_ai_ci 排序规则并不存在，因此如果你在更低版本的 MySQL 中尝试使用这个排序规则，就会遇到这个错误。
解决办法 1、升级 MySQL 版本：如果可能，升级你的 MySQL 到 8.0 版本或更高，因为这些版本原生支持 utf8mb4_0900_ai_ci。
2、更改排序规则：如果不能升级 MySQL，考虑将排序规则改为 utf8mb4_general_ci 或 utf8mb4_unicode_ci，它们在较老的 MySQL 版本中被广泛支持。
你可以修改 SQL 脚本，或者在导入数据时进行全局替换。以下是如何进行替换的示例：【建议使用编辑本对脚本进行全局替换，方便快捷】
ALTER TABLE your_table_name CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; 或者在 SQL 文件中，将所有 utf8mb4_0900_ai_ci 替换为 utf8mb4_unicode_ci。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91cd419ba28d4f43c41a0042552a2bc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/926000112aef68722812ddfdf98b3177/" rel="bookmark">
			大数据-78 Kafka 集群模式 集群的应用场景与Kafka集群的搭建 三台云服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点一下关注吧！！！非常感谢！！持续更新！！！ 目前已经更新到了： Hadoop（已更完）HDFS（已更完）MapReduce（已更完）Hive（已更完）Flume（已更完）Sqoop（已更完）Zookeeper（已更完）HBase（已更完）Redis （已更完）Kafka（正在更新…） 章节内容 上节我们完成了如下的内容：
Kafka 延时队列Kafka 重试队列Kafka JavaAPI 实现 重试队列的操作 应用场景 消息传递 Kafka可以很好的替代传统的邮件代理，消息代理的使用有很多种原因（将处理与数据生产者分离，缓冲未处理消息等）。与大多数邮件系统相比，Kafka具有更好的吞吐量，内置的分区，复制和容错功能，这使其成为大规模邮件处理应用程序的理想解决方案。
网站活动路由 Kafka最初的用例是能够将用户活动跟踪管道重建为一组实时的发布-订阅。这意味着将网站活动（页面浏览、搜索、其他操作等）发布到主题中心，每种活动类型只有一个主题。这些可用于一系列的用例的订阅，包括实时处理，实时监控，以及加载到Hadoop或脱机数据仓库系统中以进行脱机处理和报告。
活动跟踪通常量很大，因为每个用户页面视图都会生成许多活动消息。
监控指标 Kafka通常用于操作监控数据，这涉及汇总来自分布式应用程序的统计信息，以生成操作数据的集中。
日志汇总 许多人使用Kafka代替日志聚合解决方案，日志聚合通常从服务器收集物理日志文件，并将它们放在中央位置（也许是文件服务器或HDFS）以进行处理。Kafka提取文件的详细信息，并以日志的形式更清晰的抽象日志或事件数据，这允许较低的延迟的处理，并更容易支持多个数据源和分布式数据消耗。以日志为中心的系统（例如Scribe或Flume）相比，Kafka具有同样出色的性能，由于复制而提供的更强的耐用性保证以及更低的端到端的延迟。
流处理 Kafka的需要用户在由多个阶段组成的处理管道中处理数据，其中原始输入数据从Kafka主题中使用，然后进行汇总，充实或以其他方式转换为新主题，以供进一步使用或后续处理。例如，用于推荐新闻文章的处理管道可能会从RSS提要中检索文章内容，并将其发布到文章主题中。进一步的处理可能会使该内容规范化或重复数据删除，并将清晰后的文章内容发布到新主题中。最后的处理阶段可能会尝试向用户推荐此内容。这样的处理管道基于各个主题创建实时数据流的图形。
从0.10.0.0开始，一个轻量但功能强大的流处理库成为KafkaStreams可以在ApacheKafka中使用来执行上述数据处理。除了KafkaStreams之外，其他开源流处理工具还包括ApacheStorm和Apache Samza。
活动采集 事件源是一种应用程序，其中状态更改以时间顺序记录记录。Kafka对大量存储的日志数据的支持使其成为以这种样式构建的应用程序的绝佳后端。
提交日志 Kafka可以用作分布式系统的一种外部提交日志，该日志有助于在节点之间复制数据，并充当故障节点恢复其数据的重新同步机制。Kafka中的日志压缩功能有助于支持此用法。
集群搭建 集群设计 由于之前我们已经搭建过单机的Kafka，同时我们为了做之前的实验，一共搭建了两台Kafka的小集群（用作Broker宕机之后的分区、副本等内容的测试），这里我们将对一些部分进行简化。
机器详情 目前我们有三台云服务：
h121.wzk.icuh122.wzk.icuh123.wzk.icu 我们已经搭建好了，ZooKeeper的集群，如果你还没有搭建，需要回到之前的章节：ZooKeeper集群搭建。
这里开始，我们直接搭建Kafka的集群环境。
在 h121.wzk.icu 中，我我们已经有了：kafka_2.12-2.7.2 且是配置好的。
我们借助之前Hadoop中编写的Shell工具来完成Kafka文件的分发（你也可以使用别的方法，比如压缩包等等）
rsync-script kafka_2.12-2.7.2/ h121 h122 h123 环境变量 我们在三台节点上，尽量配置好环境变量：
JDKZooKeeperKafka 修改配置 h121 vim /opt/servers/kafka_2.12-2.7.2/config/server.properties 修改如下内容：
# h121是0、h122是1、h123是2 broker.id=0 # 数据的存储目录 log.dirs=/opt/kafka-logs # ZooKeeper 地址 zookeeper.connect=h121.wzk.icu:2181,h122.wzk.icu:2181,h123.wzk.icu:2181 对应的内容截图如下所示：
h122 # h121是0、h122是1、h123是2 broker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/926000112aef68722812ddfdf98b3177/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65daed308a1ebbfcfefbf2bf21aff926/" rel="bookmark">
			Typescript在AI产品中应用越来越广泛
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AI产品中的应用 TypeScript 在 AI 产品中的应用逐渐增多，主要得益于其提供的类型安全、面向对象编程和模块化等特性，这些特性使得开发者能够构建可维护、可扩展和高性能的应用程序。
首先，TypeScript 作为 JavaScript 的超集，通过静态类型检查帮助开发者在编译时发现错误，提高代码的可读性和可维护性。在 AI 领域，这可以显著减少运行时错误，特别是在复杂的算法和数据处理中。
其次，TypeScript 支持面向对象编程，允许开发者构建复杂的系统架构。这对于创建 AI 系统中的模块化组件非常有用，如神经网络、数据处理管道等。
此外，TypeScript 的模块化特性也非常适合 AI 应用的需求。开发者可以将不同的功能模块化为独立的模块，然后通过 TypeScript 的模块系统进行组合，从而提高代码的重用性和可维护性。
在 AI 产品中，TypeScript 可以与多种机器学习库一起使用，例如 TensorFlow.js 和 Brain.js，这些库提供了构建和训练 AI 模型的工具和算法。例如，TensorFlow.js 允许在浏览器或 Node.js 环境中运行机器学习模型，而 Brain.js 提供了构建神经网络的简单接口。
最近，TypeChat 项目由 TypeScript 和 C# 的创造者 Anders Hejlsberg 开发，它使用 TypeScript 来引导 AI 语言模型提供类型安全的结构化响应数据，这显示了 TypeScript 在 AI 领域的新应用。
总的来说，TypeScript 在 AI 产品中的应用前景广阔，它提供的类型系统和现代编程特性，为构建可靠和高效的 AI 应用程序提供了坚实的基础。开发者可以利用 TypeScript 结合各种 AI 框架和库，来解决图像分类、自然语言处理、数据预测等现实世界问题。
前、后端通吃 TypeScript 是一种静态类型的编程语言，它是 JavaScript 的一个超集，这意味着任何有效的 JavaScript 代码也是有效的 TypeScript 代码。TypeScript 提供了类型注解、接口、类、模块和其他特性，这些特性使得它非常适合用于构建大型、可维护的应用程序。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65daed308a1ebbfcfefbf2bf21aff926/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcccf708f357f844f0adcaea8988a2c6/" rel="bookmark">
			【MYSQL】表的设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 数据库约束not null 约束unique （唯一）约束default 默认值约束primary key （主键）约束foreign key （外键）约束check 约束总结 表的设计三大范式第一范式第二范式第三范式 表的关系 数据库约束 是关系型数据库的一个重要功能，主要作用是保证数据的完整性，也可能理解数据的正确性（数据本身是否正确，关联关系是否正确），人工检查数据完整性的工作量非常的大，在数据表中定义一些约束，那么数据库写入数据的时候，数据库会帮我们做校验工作，约束一般是指定在列上的，使用在表的定义时在要约束的列的类型后加上。 not null 约束 表示该列不能存储null值。
如果存入null会报错。
unique （唯一）约束 表示该列中的数据不能重复（null）除外。
插入相同或者已有的值会报错。
default 默认值约束 指定列为空时的默认值。
primary key （主键）约束 相当于是not null 和 unique的结合，
表示该列中的数据既不能重复也不能为空。
如果存入null会报错。插入相同或者已有的值也会报错。
当主键是整型时，我们常常加上auto_increment让主键从当前最大值加1，
但是当插入错误时该值相当于被生成了，下一个从这个开始。
通俗将就是当前主键最大值为7，然后插入时报错了，改回来后插入行主键为9。
一张表中最多只能定义一个主键，定义超了就会报错，
要想多列为主键只能使用复合主键primary key (列名1, 列名2)。
使用复合主键，必须列值都相同才算重复，任一列值都不能为null。
foreign key （外键）约束 保证一个表中的数据匹配另一个表中的值的参照完整性。
就是将另一个表中的值作为该表中该列的范围。
被外键约束的列在约束前先定义，
语法是foreign key (列名) references 外表名(外列名)，
被外键约束的表还存在就不能删除外表。
check 约束 该约束在5.7版本不能使用，导致兼容性不好，所以一般不用。
使用了该约束后该列只能插入被约束的值。
总结 约束类型说明示例not null 约束使用not null指定列不能为空name varchar(20) not null,unique 约束指定列为唯一的、不重复的，null除外name varchar(20) unique,default 默认值约束指定列为空时的默认值age int default 20,primary key 主键约束not null 和 unique 的结合id int primary key,foreign key外键约束关联其他表的主键或唯一键foreign key (字段名) references 主表(列)check约束保证列中的值符合指定的条件check (gender = ‘男’ or gender =‘女’) 表的设计 一般我们编程流程如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcccf708f357f844f0adcaea8988a2c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25dd5e234ec30f0f116756cecf292559/" rel="bookmark">
			【C&#43;&#43;指南】缺省参数（默认参数）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💓 博客主页：倔强的石头的CSDN主页 📝Gitee主页：倔强的石头的gitee主页
⏩ 文章专栏：《C++指南》
期待您的关注
目录
一、引言
二、缺省参数的概念
三、缺省参数的使用
全缺省参数：
半缺省参数：
声明和定义分离：
四、注意事项
一、引言 在C++中，缺省参数是一项非常实用的特性，它允许函数在调用时省略某些参数的值，这些省略的参数将自动采用函数声明中指定的默认值。这一特性不仅提高了代码的灵活性，还使得函数的使用更加简洁明了。本文将深入探讨C++缺省参数的概念、使用方法、注意事项以及最佳实践。
二、缺省参数的概念 缺省参数，顾名思义，即为函数参数提供默认值的机制。在函数声明时，可以为参数指定一个默认值，如果在函数调用时没有提供该参数的值，则自动使用声明时指定的默认值。这一特性特别适用于那些大多数情况下使用相同值，但偶尔需要不同值的参数。缺省参数分为全缺省和半缺省参数：全缺省就是全部形参给缺省值，半缺省就是部分形参给缺省值。 三、缺省参数的使用 C++规定半缺省参数必须从右往左 依次连续缺省，不能间隔跳跃给缺省值带缺省参数的函数调⽤，C++规定必须从左到右依次给实参，不能跳跃给实参函数声明和定义分离时，缺省参数不能在函数声明和定义中同时出现，规定必须函数声明给缺省 值。 简单来说：
函数声明时缺省参数从右往左，函数调用传递实参时从左往右，如果声明和定义分离就只在声明处给缺省值
全缺省参数： #include &lt;iostream&gt; using namespace std; // 全缺省 void Func1(int a = 10, int b = 20, int c = 30) { cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; "c = " &lt;&lt; c &lt;&lt; endl &lt;&lt; endl; } int main() { Func1();//全缺省参数，调用时可以不给实参 Func1(1); Func1(1, 2); Func1(1, 2, 3); return 0; } 半缺省参数： #include &lt;iostream&gt; using namespace std; // 半缺省 void Func2(int a, int b = 10, int c = 20) { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25dd5e234ec30f0f116756cecf292559/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb07de83ee1022bbef02939f888234ef/" rel="bookmark">
			SpringBoot基础(二)：配置文件详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot基础系列文章
SpringBoot基础(一)：快速入门
SpringBoot基础(二)：配置文件详解
目录 一、配置文件分类二、配置文件优先级1、不同版本优先级2、不同位置优先级 三、配置文件格式1、yml和yaml格式1.1、字符串1.2、布尔类型1.3、整数型1.4、浮点型1.5、空（Null）1.6、时间类型1.7、对象(属性和值)、Map(键值对)1.8、数组、list、set1.9、对象数组、对象list、对象set 2、properties格式 四、临时属性设置1、临时属性2、自定义配置文件 五、配置文件数据读取1、读取单一数据2、读取全部数据3、读取对象数据4、配置文件内的数据引用 六、多环境开发1、yml单一文件版2、yml多文件版3、yml独立配置多文件版 一、配置文件分类 SpringBoot提供了3种配置文件的格式
application.properties（传统格式/默认格式） server.port=81 application.yml（主流格式） server: port: 82 application.yaml server: port: 83 yml格式和yaml格式除了文件名后缀不一样，格式完全一样
二、配置文件优先级 1、不同版本优先级 springboot 2.4.0及以后版本：application.yaml ➡️ application.yml ➡️ application.propertiesspringboot 2.4.0以前版本：application.properties ➡️ application.yml ➡️ application.yaml旧版application.properties优先级最高，新版优先级最低不同配置文件中相同配置高优先级覆盖低优先级，不同配置文件中不同配置全部保留 2、不同位置优先级 classpath：application.yml（resources目录）【最低-程序员】classpath：config/application.yml（resources目录下的config目录）【项目经理】file ：application.yml（jar包所在目录）【运维】file ：config/application.yml（jar包所在目录下config目录）【最高-运维经理】 三、配置文件格式 1、yml和yaml格式 大小写敏感使用缩进表示层级关系，只允许使用空格（不允许使用Tab键） 缩进的空格数量不重要，只要相同层级的元素左侧对齐即可属性名与属性值之间使用冒号+空格作为分隔 #号 表示注释可使用-代替驼峰，如Java中的lastName，在yml中lastName或last-name都可正确映射 1.1、字符串 字符串可不用加单引号或双引号单引号不会转义【\n 则为普通字符串显示】双引号会转义【\n会显示为换行符】字符串可以拆成多行，换行符会被转化成一个空格|开头，大文本写在下层，保留文本格式，换行符正确显示 str1: 哈喽 str2: 哈喽 你好 呀 str3: '哈喽 \n 你好' str4: "哈喽 \n 你好" str5: | 哈喽 你好 # 转为json样式如下 {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb07de83ee1022bbef02939f888234ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/252721a8c4f63830a8c61dab589f0999/" rel="bookmark">
			基于ssm&#43;vue&#43;uniapp的网上商城小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发语言：Java框架：ssm+uniappJDK版本：JDK1.8服务器：tomcat7数据库：mysql 5.7（一定要5.7版本）数据库工具：Navicat11开发软件：eclipse/myeclipse/ideaMaven包：Maven3.3.9 系统展示
管理员登录
用户管理
商品信息管理
活动专区管理
新品上架管理
用户评价管理
订单管理
用户首页
商品信息详情
我的界面
用户充值
新增收货地址
购物车
我的订单
我的评价
摘要
网上商城的设计主要是对系统所要实现的功能进行详细考虑，确定所要实现的功能后进行界面的设计，在这中间还要考虑如何可以更好的将功能及页面进行很好的结合，方便用户可以很容易明了的找到自己所需要的信息，还有系统平台后期的可操作性，通过对信息内容的详细了解进行技术的开发。
网上商城平台开发使系统能够更加方便快捷，同时也促使网上商城变的更加系统化、有序化。系统界面较友好，易于操作。具体在系统设计上，微信端使用微信开发者，后台也使用java技术在动态页面上进行了设计，Mysql数据库，是一个非常优秀的网上商城。
研究背景
随着信息时代的快速发展，互联网的优势和普及，人们生活水平的不断提高，工作时间的繁忙，使得网上商城的开发成为必需。网上商城主要是借助计算机，通过对网上商城管理所需的信息管理，增加用户的选择，同时也方便广大用户信息的及时查询、修改以及对网上商城信息的及时了解。网上商城序给用户带来了更多的选择, 该系统通过和数据库软件协作来满足用户的需求。
关键技术
当今流行的“SSM组合框架”是Spring + SpringMVC + MyBatis的缩写，受到很多的追捧，“组合SSM框架”是强强联手、各司其职、协调互补的团队精神。web项目的框架，通常更简单的数据源。Spring属于一个轻量级的反转控制框架(IoC)，但它也是一个面向表面的容器(AOP)。SpringMVC常常用于控制器的分类工作模式，与模型对象分开，程序对象的作用与自动取款机进行处理。这种解耦治疗使整个系统的个性化变得更加容易。MyBatis是一个良好的可持续性框架，支持普通SQL查询，同时允许对存储过程的高级映射进行数据的优化处理。大型Java Web应用程序的由于开发成本太高，开发后难以维护和开发过程中一些难以解决的问题，而采用“SSM组合框架”，它允许建立业务层次结构，并为这个问题提供良好的解决方案。
JS-SDK是对之前的 WeixinJSBrige 的一个包装，以及新能力的释放，并且由对内开放转为了对所有开发者开放，在很短的时间内获得了极大的关注。从数据监控来看，绝大部分在微信内传播的移动网页都使用到了相关的接口。
JS-SDK 解决了移动网页能力不足的问题，通过暴露微信的接口使得 微信小程序 开发者能够拥有更多的能力，然而在更多的能力之外，JS-SDK 的模式并没有解决使用移动网页遇到的体验不良的问题。用户在访问网页的时候，在浏览器开始显示之前都会有一个的白屏过程，在移动端，受限于设备性能和网络速度，白屏会更加明显。我们团队把很多技术精力放置在如何帮助平台上的微信小程序开发者解决这个问题。因此我们设计了一个 JS-SDK 的增强版本，其中有一个重要的功能，称之为“微信 微信小程序 资源离线存储”。
JAVA语言是目前软件市场上应用最广泛的语言开发程序。可以在多种平台上运用的，兼容性比较强，适应市面上大多数操作系统，不会出现乱码的现像，其扩展性和维护性都更好，具有分析问题和解决问题的能力，是面向过程的程序设计方便我们编写的代码更强壮。
Vue是一款流行的开源JavaScript框架，用于构建用户界面和单页面应用程序。Vue的核心库只关注视图层，易于上手并且可以与其他库或现有项目轻松整合。
MYSQL数据库运行速度快，安全性能也很高，而且对使用的平台没有任何的限制，所以被广泛应运到系统的开发中。MySQL是一个开源和多线程的关系管理数据库系统，MySQL是开放源代码的数据库，具有跨平台性。
B/S（浏览器/服务器）结构是目前主流的网络化的结构模式，它能够把系统核心功能集中在服务器上面，可以帮助系统开发人员简化操作，便于维护和使用。
系统分析
对系统的可行性分析以及对所有功能需求进行详细的分析，来查看该系统是否具有开发的可能。
系统设计
功能模块设计和数据库设计这两部分内容都有专门的表格和图片表示。
系统实现
管理员进入到首页界面，通过界面的任务大厅，进入到系统可以进行查看个人中心、用户管理、商品信息管理、商品类型管理、活动专区管理、新品专区管理、新品上架管理、用户评论管理、系统管理、订单管理等功能模块，进行相对应操作。商品管理：通过列表可以获取商品名称、商品类型、规格、图片、价格信息，进行查看详情、修改或删除操作，或在线查看评论操作。订单管理，管理员可以根据自己的需求进行系统所有的订单信息进行在线查看，管理员可以根据条件进行选择未付款订单、已付款订单、未收货订单、已完成订单等进行条件查看相应的订单数据并进行订单处理，通过订单列表进行查看系统已有的订单信息、金额、订单用户、收货地址、订单状态等信息，并且根据订单状态进行订单处理操作，对于订单的状态，可以在线对订单信息进行选择发货等操作。
首页：用户登录到网上商城客可以查看首页、商品信息、活动专区、新品上架、我的等功能模块，进行相对应操作。商品信息详情页面：通过列表可以获取商品名称、图片、商品类型、规格、商品介绍等信息，进行查看信息详情或加入购物车、立即订购操作，并通过输入添加评论进行评论操作。购物车：通过页面可以获取商品名称、价格、图片、数量进行查看总金额进行查看或立即下单操作。我的订单：通过页面可以获取已支付、已发货、已完成、已取消等订单信息，进行查看或取消订单操作。
系统测试
软件系统测试的目的是通过测试找出在程序中的存在的错误信息和阻碍程序正常运转的安全隐患。这同时也是每一个系统软件测试的主要的规定，软件系统的应用过程中，发现一个重要的错误也是极具有很大的影响力的，一个好的测试的方案就为发展程序中存在的重大问题的；同样，一个成功的测试方案也就发现了迄今为止尚未发现的一个重要错误的测试。
软件测试的主要的好处就是为了让软件的运行情况更好，让用户的使用的过程中更加的满意。在软件工程中，软件测试是一个十分重要环节，在交付用户使用最终的软件之前，软件测试就是一个检验的过程，主要针对的是软件的软件设计开发、需求分析、系统编码各阶段结果的一个检验过程。
结论
网上商城的设计，通过互联网来解决实现信息化的网站系统，通过我四年所学的所有专业知识整合一起，进行对网上商城进行开发设计，当然在真正着手来做的时候遇到了很多问题，一个是网站的技术问题，一个是自己之前没有单独开发过程序，动手实践比较少，面对问题的同时，自己的自信心也受到了一些打击，不过我也是快速的调整自己的状态，老师与同学讨论的方法解决了所有的困难。
（可运行源码+sql文件+文档）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/973261b12fd344b4e3e53a9c97d6f048/" rel="bookmark">
			人工智能时代如何重构你的核心竞争力（程序员篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、AI辅助编程对程序员工作的影响二、程序员应重点发展的核心能力三、人机协作模式下的职业发展规划 在人工智能（AI）技术的浪潮下，尤其是AIGC（如ChatGPT、Midjourney、Claude等）大语言模型的崛起，程序员的工作领域正经历着翻天覆地的变化。AI辅助编程工具不仅革新了编码实践，还引发了关于AI是否会取代程序员角色的广泛讨论。然而，更现实的视角是，AI应被视为提升工作效率和创造力的伙伴，而非对手。在此背景下，程序员如何保持并提升自身的核心竞争力，成为了一个值得深入探讨的话题。
一、AI辅助编程对程序员工作的影响 正面效应显著：
效率飞跃：AI工具如自动补全、代码生成和代码审查等，显著减少了程序员在编写和调试代码上的时间。这不仅加快了项目进度，还使得程序员能够专注于更高层次的问题解决和系统优化。创新加速：AI技术为程序员提供了更多的实验机会和灵感来源，促进了创新思维的激发和新技术的探索。 潜在风险不容忽视：
技能退化：过度依赖AI工具可能导致程序员在基础编程技能上的生疏，如算法设计、数据结构理解和手动调试能力等。这些技能是构建复杂系统和解决挑战性问题的基石。
创新惰性：如果程序员习惯于直接采用AI生成的代码或解决方案，可能会减少独立思考和创造性解决问题的机会，从而削弱创新能力。
因此，程序员需要在使用AI工具的同时，保持对基础编程技能的掌握和更新，并主动寻求创新挑战，以维持和提升个人竞争力。
二、程序员应重点发展的核心能力 复杂系统设计能力： 随着业务复杂性的增加，程序员需要具备设计高可用、可扩展和安全的系统架构的能力。这要求深入理解业务需求，结合技术趋势，制定出合理的系统设计方案。
跨学科知识整合能力： AI时代下的项目往往涉及多个学科领域的知识，如机器学习、数据科学、云计算、物联网等。程序员需要不断学习新知识，掌握跨学科整合的能力，以应对多样化的项目需求。
与AI协作的能力： 程序员需要了解AI模型的工作原理和局限性，能够设计适合AI处理的数据和任务，以及优化AI模型的性能。同时，还需要掌握AI伦理和法律知识，确保AI技术的合规应用。
为了培养这些能力，程序员可以采取以下措施：
积极参与实战项目，将理论知识应用于实际场景中；关注行业动态和技术发展趋势，保持对新技术、新工具的敏感度；加强跨学科交流和学习，拓宽视野和知识面；参与开源社区和技术论坛的讨论和交流，与同行分享经验和心得。 三、人机协作模式下的职业发展规划 持续学习： 在AI时代，技术更新速度加快，程序员需要保持持续学习的习惯。通过参加培训课程、阅读专业书籍和文章、参与技术研讨会等方式不断充实自己。
专业方向选择： 根据个人兴趣和市场需求选择适合自己的专业方向进行深入学习。例如可以选择机器学习工程师、大数据分析师、云计算架构师等热门职业方向。
竞争力保持策略： 建立个人品牌：通过分享技术经验、撰写博客和文章、参与开源项目等方式提升个人知名度和影响力。拓展人脉资源：与同行建立联系和交流网络，了解行业动态和就业机会。保持创新思维：不断挑战自我，尝试新技术和新方法的应用，保持对未知领域的探索精神。 人工智能时代为程序员带来了前所未有的机遇和挑战。通过保持对基础编程技能的掌握和更新、培养跨学科知识整合能力和与AI协作的能力、制定科学的职业发展规划和保持持续学习的习惯等措施，程序员可以在AI时代中保持并提升自身的核心竞争力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41e914ca6a3ed4acdab622685fb12a26/" rel="bookmark">
			硬件工程师必须掌握的MOS管详细知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MOS管，全称为金属-氧化物半导体场效应晶体管（Metal-Oxide-Semiconductor Field-Effect Transistor，MOSFET），是一种重要的半导体器件，广泛应用于电子工业中各种电路的开关、放大、调制、数字电路和模拟电路等领域。以下是对MOS管的详细知识介绍：
一、定义与结构
定义：MOS管是一种利用电场效应来控制其电流大小的半导体三端器件。它由金属栅极（G）、氧化物绝缘层（通常为SiO2）和半导体层（D为漏极，S为源极）构成。
结构：MOS管的主要结构包括栅极（G）、漏极（D）和源极（S）。栅极与源极之间通过一层氧化物绝缘层隔离，形成电容效应，从而控制漏极与源极之间的电流。
二、工作原理
电压控制：MOS管是一种电压控制型器件，通过改变栅极与源极之间的电压（VGS）来控制漏极与源极之间的电流（ID）。当VGS大于某一特定值（阈值电压Vth）时，漏极与源极之间形成导电沟道，电流开始流通。
导电沟道：根据导电沟道的不同，MOS管可分为N沟道和P沟道两类。N沟道MOS管在VGS为正时导通，而P沟道MOS管在VGS为负时导通。
三、特性与参数
体积小、功耗低：MOS管具有体积小、重量轻、功耗低等优点，适合用于大规模集成电路中。
高输入阻抗、低噪声：MOS管的输入阻抗高，噪声低，适用于对信号质量要求高的场合。
热稳定性好：MOS管的温度系数小，工作稳定性好，不易受温度影响。
主要参数：包括栅源极最大驱动电压（VGS）、漏源电压（VDS）、漏源导通电阻（RDS(on)）、栅极电荷（Qg）、漏极电流（Id）等。这些参数决定了MOS管的性能和使用条件。
四、分类
按导电沟道分：N沟道MOS管和P沟道MOS管。
按工作类型分：增强型MOS管和耗尽型MOS管。增强型MOS管在VGS为零时沟道不导通，需要一定的VGS才能形成导电沟道；而耗尽型MOS管在VGS为零时沟道已经导通，但随着VGS的变化，沟道宽度会发生变化。
五、应用
数字电路：MOS管可以作为数字电路中的开关元件，用于实现逻辑运算、计数器、存储器等功能。
模拟电路：MOS管可以作为模拟电路中的放大器元件，用于信号放大、滤波、调制等功能。
功率电子：MOS管在功率电子领域也有广泛应用，如直流电源、变换器、逆变器等电路中。
通信电子：MOS管还可以作为射频功率放大器使用于无线通信、雷达、卫星通信等领域。
六、生产工艺
MOS管的生产工艺主要包括基片准备、氧化层形成、金属电极沉积、掺杂、固化和测试等步骤。这些步骤共同确保了MOS管的性能和质量。
综上所述，MOS管是一种具有优异性能和广泛应用前景的半导体器件。随着电子技术的不断发展，MOS管将在更多领域发挥重要作用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/869b0b852ccb93d03d6d20320a5856b4/" rel="bookmark">
			【Linux】编辑器vim入门（概念&#43;模式转换&#43;技巧）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vim编辑器 1.1. 什么是vim?1.2. 下载vim：1.3. 💫配置vim214😸四种常见模式1.2.1正常/普通/命令模式1.2.2插入模式1.2.3 底行模式1.2.3 可视化模式 1.3 模式切换1.4 基础使用1）使用vim打开文件2)编辑输入4）vim编辑器强制退出（不保存） 1.5 小技巧补充1）异常退出解决方案2）退出vim编辑器3）快捷键--命令模式 1.1. 什么是vim? vim是Linux编辑器，功能上和记事本没有区别。
不仅仅可以用来写c语言和c++，其它语言也可以在上面写。
1.2. 下载vim： (1)判断是否已经安装vim
可以先在系统上，输入 vim ，查看是否已经安装了vim.
能进入到一个新页面，就是已经安装了vim。可以直接跳到下一步。进行 vim 的配置。
vim的退出比较特殊，所以进入到新页面之后，先不要随意动键盘。确认是vim打开页面就可以了，然后使用 键盘的左上角的 Esc，然后再 shift + ；，然后输入 q!
vim (2)安装vim
执行指令需要root权限。
要么加上sudo进行提权，要么以root身份执行。
[sudo / root] yum install -y vim 下载好vim后，我们就可以用它来编辑文本了，vim既可以直接编辑现有文本，也可以直接创建一个不存在的文件。
1.3. 💫配置vim 详细已经在这篇文章写到啦，大家可以跳转查看：【Linux】vim编辑器的配置（手动配置 + 自动配置 一键配置 超快速 ）
214😸四种常见模式 1.2.1正常/普通/命令模式 进入vim 的默认模式控制屏幕光标的移动，字符、字或行的删除移动复制某区段及进入Insert mode下或者到 last line mode 1.2.2插入模式 只有在Insert mode下，才可以做文字输入，按**「ESC」键**可回到命令行模式。该模式是我们后面用的最频繁的编辑模式。
1.2.3 底行模式 文件保存或退出，
也可以进行文件替换，找字符串，列出行号等操作。
在命令模式下**，shift+:**即可进入该模式。
1.2.3 可视化模式 可以做一些列选操作（通过方向键选择某些列的内容，可以用来做批量化注释）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/869b0b852ccb93d03d6d20320a5856b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ec2d2064fdd93ae400789205cdb8a8e/" rel="bookmark">
			【算法/学习】：记忆化搜索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨ 落魄谷中寒风吹，春秋蝉鸣少年归 🌏 📃个人主页：island1314
🔥个人专栏：算法学习
⛺️ 欢迎关注：👍点赞 👂🏽留言 😍收藏 💞 💞 💞
​
🚀引言： 基本概念 记忆化搜索（Memoization Search）：是一种通过存储已经遍历过的状态信息，从而避免对同一状态重复遍历的搜索算法。
主要特点和应用场景包括：
避免重复计算： 记忆化搜索算法通过缓存已经计算过的结果，以避免对相同输入进行重复计算。这在递归算法中特别有用，因为递归往往会导致相同的子问题被反复解决。提高效率： 通过保存中间计算结果，记忆化搜索算法能够大幅减少算法的时间复杂度，从指数级别降低到多项式级别。 动态规划： 记忆化搜索在动态规划中经常被使用。动态规划是一种解决优化问题的方法，通常包含递归和子问题重叠的特点。记忆化搜索能够避免重复计算，使得动态规划算法更加高效。
递归算法优化： 记忆化搜索主要用于优化递归算法。在递归调用中，如果存在相同的输入参数，记忆化搜索算法将直接返回已经计算过的结果，而不是重新执行计算。
应用于搜索问题： 记忆化搜索不仅用于动态规划，还可以应用于搜索问题，特别是深度优先搜索中的状态记忆。
经典的例子包括斐波那契数列的递归实现、图的最短路径问题中的递归搜索等。在实现记忆化搜索时，通常需要使用数据结构（如哈希表、数组等）来保存已经计算过的结果。
记忆化搜索和动态规划都是一种用于优化递归算法的技术，它们有很多相似之处，但也存在一些关键的区别
记忆化搜索与递归相同与不同 相同之处：
重叠子问题： 记忆化搜索和动态规划都针对具有重叠子问题性质的问题。这意味着问题可以被划分为许多相似的子问题，这些子问题在解决整体问题时会被多次重复计算。 优化递归： 两者都旨在优化递归算法。递归算法通常会导致相同的子问题被反复解决，而记忆化搜索和动态规划都致力于避免这种重复计算。 缓存中间结果： 记忆化搜索和动态规划都使用某种形式的缓存来存储已经计算过的中间结果，以便在需要时直接返回结果，而不是重新计算。 不同之处：
自顶向下 vs 自底向上： 记忆化搜索是自顶向下的方法，从大问题开始，逐步分解为子问题，并缓存这些子问题的结果。动态规划是自底向上的方法，从最小的子问题开始解决，逐步构建出整个问题的解。递归 vs 迭代： 记忆化搜索通常使用递归实现，通过递归调用来解决问题。动态规划则使用迭代的方式，通过循环来计算并填充表格或数组。状态转移方程 vs 递归调用： 在动态规划中，通常通过状态转移方程来描述问题的子问题之间的关系，从而构建解。而在记忆化搜索中，通常直接使用递归调用来表示问题的分解。使用场景： 记忆化搜索通常更适用于处理问题的子问题规模较小，问题的状态转移方程比较复杂，递推关系不是很明确，问题适合转换为递归形式，并且递归深度不会太深。而动态规划则更适用于处理问题的子问题规模较大的情况，问题的状态转移方程比较简单，递归关系比较明确。问题不太适合转换为递归形式，或者递归深度过大容易导致栈溢出。 总的来说，当递归中出现了大量完全相同的问题时，就会用到记忆化搜索和动态规划去优化递归算法的技术，但它们的实现方式和问题解决的思路有一些不同。在解决问题时，根据具体的情况选择使用记忆化搜索或动态规划能够更好地满足问题的需求。
记忆化搜索的解题步骤 我们在使用记忆化搜索解决问题的时候，其基本步骤如下：
写出问题的动态规划「状态」和「状态转移方程」。
定义一个缓存（数组或哈希表），用于保存子问题的解。
定义一个递归函数，用于解决问题。在递归函数中，首先检查缓存中是否已经存在需要计算的结果，如果存在则直接返回结果，否则进行计算，并将结果存储到缓存中，再返回结果。
在主函数中，调用递归函数并返回结果。
让我们来看一些相关题目，加深对于记忆化搜索的理解吧
1. 斐波那契数 图解：
下面我们写出两种写法
递归写法：
int dfs(int n) { if (n == 0 || n == 1) return n; return dfs(n - 1) + dfs(n - 2); } int fib(int n) { return dfs(n); } 记忆化搜索写法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ec2d2064fdd93ae400789205cdb8a8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bad7ed33c7a084c634bdf533dbcee3c/" rel="bookmark">
			【Java数据结构】---List(LinkedList)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		乐观学习，乐观生活，才能不断前进啊！！！
我的主页：optimistic_chen
我的专栏：c语言 ，Java
欢迎大家访问~
创作不易，大佬们点赞鼓励下吧~
文章目录 前言链表（MySingleList）具体功能代码 LinkedList简介LinkedList的模拟实现LinkedList的使用LinkedList的构造LinkedList的方法LinkedList的遍历 ArrayList和LinkeddList的区别完结 前言 上篇博客详细写了ArrayList的相关问题，包括上图（极其重要），我会在最近几篇博客中都有附上。
ArrayList的优点很明显，底层逻辑是一个数组，它通过下标去访问数据的速度非常快。但是在ArrayList任意位置插入或者删除元素时，就需要将后序元素整体往前或者往后搬移，时间复杂度为O(n)，效率比较低
所以java集合框架中引入了LinkedList类，即链表结构。
链表（MySingleList） 链表，作为线性表的一种，它与顺序表截然相反：链表是一种物理存储结构 上 非连续存储结构， 数据元素的逻辑顺序是通过链表中的引用 链接次序实现的
之前C语言了解过这方面的知识C语言—链表专题，所以我们有一定的基础，我相信链表对于大家一定是熟悉的存在。我们先由易入难，先自己尝试一下单链表（MySingleList）的功能实现，为接下来的 LinkedList(无头双向链表) 打下基础.
接口
public interface IList { public void addFirst(int data); public void addLast(int data); public void addIndex(int index,int data); public boolean contains(int key); public void remove(int key); public void removeAllKey(int key); public int size(); public void clear(); public void display(); } 具体功能代码 头插法
@Override public void addFirst(int data) { ListNode node = new ListNode(data); node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bad7ed33c7a084c634bdf533dbcee3c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/57/">«</a>
	<span class="pagination__item pagination__item--current">58/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/59/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>