<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/476d0f8ad300c4d347b18b0bb7e6b67a/" rel="bookmark">
			hive数据库delete删除部分数据/删除分区内的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hive delete 删除部分数据 一、hive删除数据1.1、删除整个表1.2、删除表中的特定行1.3、删除表中的特定分区1.4、删除分区内的部分数据1.5、清空表中的所有数据 二、扩展2.1、dynamic partition on Crud si not disabled, please set hive.crud.dynamic.partition=true to enable it 在Hive中，删除部分数据是一个常见的操作，特别是当我们需要清除不再需要的数据或者进行数据更新时。Hive提供了多种方式来删除部分数据，本文将介绍其中几种常用的方法。
一、hive删除数据 1.1、删除整个表 最简单的方法是删除整个表，这将删除表中的所有数据。可以使用DROP TABLE语句来完成这个操作。下面是一个示例：
DROP TABLE my_table; 这将删除名为my_table的表。请注意，这将删除表的元数据和数据。
1.2、删除表中的特定行 如果只需要删除表中的部分数据，可以使用DELETE语句。DELETE语句用于删除满足指定条件的行。下面是一个示例：
DELETE FROM my_table WHERE condition; 其中，my_table是要删除数据的表名，condition是一个表达式，用于指定哪些行应该被删除。例如，要删除my_table表中age大于30的所有行，可以使用以下语句：
DELETE FROM my_table WHERE age &gt; 30; 这将删除所有age大于30的行。
1.3、删除表中的特定分区 如果表是分区的，可以使用DELETE语句删除特定的分区。分区是根据表中的某些列进行划分的，因此可以只删除特定的分区而不影响其他分区。下面是一个示例：
DELETE FROM my_table PARTITION (partition_column = partition_value); 或者 alter table my_table drop partition(partition_column = partition_value) 其中，my_table是要删除数据的表名，partition_column是分区列的名称，partition_value是要删除的分区的值。例如，要删除my_table表中date列为’2022-01-01’的分区，可以使用以下语句：
DELETE FROM my_table PARTITION (date = '2022-01-01'); 或者 alter table my_table drop partition(date = '2022-01-01') 这将删除所有date列为’2022-01-01’的分区。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/476d0f8ad300c4d347b18b0bb7e6b67a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa67f977db1eea294a815da9b448af6f/" rel="bookmark">
			扬帆未来，成就架构之路：十本书籍助力你的架构师梦想 | 文末送书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信大家都对未来的职业发展有着憧憬和规划，要做架构师、要做技术总监、要做CTO。对于如何实现自己的职业规划也都信心满满，努力工作、好好学习、不断提升自己。
规划职业发展 当涉及未来职业发展时，我们都怀揣着远大的目标和野心。对许多人而言，成为一名优秀的架构师、技术总监或CTO是一种梦想，更是一个可以实现的现实目标。
为了踏上这个职业征程，我们需要不断奋斗，不断完善自我。这意味着持续投入努力工作、培养专业技能、掌握行业趋势并积极寻求成长机会。通过不断的学习和经验积累，我们才能站在行业前沿，成为解决复杂技术难题的领军人物。这种积极的态度和持续的学习精神是我们实现职业规划的关键。
架构师的多元工作范围 优秀的架构师不仅仅是编写代码，他们工作的范围涵盖广泛。从开发基础框架到设计软件架构，优化系统性能到修复重要Bug，再到做出关键技术决策，这些都是架构师需要涉足的领域。成为优秀的软件架构师需要长期的修炼和建立自己的软件开发技术体系。
相信成为一名优秀的架构师是很多程序员的目标，架构师的工作包罗万象，从开发基础框架到设计软件架构，从优化系统性能到修复重要Bug，从新技术选型到做出关键技术决策，从指导工程师开发到沟通、协调各种内外部关系。想要成为一个优秀的软件架构师，需要经过漫长的修炼，构建起自己的软件开发技术体系。但是一切看似纷繁复杂的技术技巧，均有其核心和基本的原理。
读书充电，迎接挑战 读书充电，温暖你的冬日，本期推荐几本架构师成长和软件架构技术相关的好书，助你度过这个不太景气的寒冬！
投资自己 永远是稳赚不赔的生意
《高并发架构实战：从需求分析到系统设计》 李智慧的这本书为你提供了一站式的高并发架构解决方案，深入解析了架构思维与实践要点。
大厂架构师敲门砖！本书将为你提供一站式的高并发架构解决方案，以及架构师权衡抉择的方法与技巧。本书由知名技术畅销书作者李智慧撰写，从需求分析到详细设计，从八大维度剖析18个精彩案例，让你真正掌握架构思维与实践要点。
《架构师的自我修炼：技术、架构和未来》 由同程旅行首席架构师撰写，本书梳理了架构师在职业进阶道路上必须掌握的各种技术技能。
成为架构师是很多程序员的梦想，如何才能成为架构师呢？成为架构师需要掌握哪些技术能力呢？如何融会贯通所有这些知识，信手拈来运用到自己的架构设计中呢？由同程旅行首席架构师、《架构师的自我修炼：技术、架构和未来》一书作者李智慧为你梳理在职业进阶的道路上必须牢固掌握的各种技术技能，帮助你建立起自己的知识体系。
《中台架构与实现：基于DDD和微服务》 这本书系统讲解了如何基于DDD思想实现中台和微服务协同设计和落地的方法。
这是一部系统讲解如何基于DDD思想实现中台和微服务协同设计和落地的著作。它将DDD、中台和微服务三者结合，给出了一套体系化的基于DDD思想的企业级前、中、后台协同设计方法。本书注重实战，汇聚了大量分布式架构的新设计方法、思想和理念，同时包含大量的案例和代码，是理论与实践相结合的最佳经验分享。交互式的行文风格，文字有活力，内容不刻板，简洁易懂。
《分布式系统架构：架构策略与难题求解》 对于构建现代分布式系统的架构师来说，这本书提供了架构决策的理论指导。
本书为构建微服务和分析整个技术栈中架构决策的细微差别提供了理论指导。在本书中，你将了解构建分布式系统时可以做出的架构决策，并了解每个决策的利弊。对于要构建现代分布式系统的架构师来说，这本书是必读的
《流程自动化实战：系统架构和软件开发视角 》 基于20年实践经验，本书展示了如何应用流程自动化解决微服务和云原生架构的复杂性。
本书基于作者在流程自动化领域20年的实践经验，全面而系统地展示如何应用流程自动化模型、方法和工具来解决微服务和云原生架构的复杂性。书中首先讲述流程自动化如何应用于现代系统架构和软件开发实践；然后研究工具要具备什么样的支持度才能成为每个开发者工具箱的重要组成部分；最后通过示例展示一个轻量且开发者友好的工作流引擎是实现流程自动化的核心组件。适合想要了解流程自动化的软件开发者、软件架构师和系统架构师阅读。
《分布式系统架构与开发：技术原理与面试题解析》 对于构建现代分布式系统的架构师来说，这本书提供了架构决策的理论指导。
分布式技术是互联网应用开发的核心技术体系，包含与微服务架构相关的一系列技术组件。开发人员可能每天都在使用这些技术组件，却很少花心思去系统性地理解其设计思想和实现机制。本书融合了作者对分布式系统构建过程中各项核心技术的深刻理解与实践经验，并对Spring Cloud、Dubbo、MyBatis等主流的分布式开发框架提供了源码级的底层原理剖析。如果读者想要更好地实现日常开发需求、理解框架原理以及应对技术原理类面试，本书都能提供帮助。
《服务端开发：技术、方法与实用解决方案》 全面讲解服务端开发，是作者近10年服务端开发经验的总结与实践智慧结合。
这是一本从开发流程、技术栈、典型问题解决方案和开发规范等维度全面讲解服务端开发的著作。它衍生自作者在蚂蚁内部讲授的高口碑课程，是作者近10年服务端开发经验的总结，同时融合了业界在服务端开发方面的宝贵项目经验和实践智慧。本书理论与实践结合，摆脱编程语言、框架、中间件及传统编程思想的束缚，全景式、体系化地阐述了服务端开发，
《现代C++软件架构：方法与实践》 本书能帮助你把相关知识应用到工作中，设计分布式大规模应用程序。
如果你正在使用现代C++，那么本书将帮助你把相关知识应用到工作中，设计分布式大规模应用程序。本书首先快速介绍架构概念，包括已建立的模式和不断上升的趋势；然后，详细阐释软件架构的概念及相关组件；接着，深入探索应用程序架构中涉及的设计概念和软件开发中涉及的模式，详细介绍构建、打包、集成和部署组件的方法，以及架构的不同质量属性，例如可维护性、可重用性、可测试性、性能、可伸缩性和安全性；最后，概述分布式系统，例如面向服务的架构、微服务和云原生设计，并简单介绍如何在应用程序开发中应用它们。
《软件架构实践（原书第4版）》
这本书能为任何软件架构项目提供专家方法和测试模型的实用指南。
软件架构领域开创性著作 软件架构类图书事实标准。作者对软件架构进行了广泛而全面的概述。可帮助软件架构师实现企业IT体系架构设计。本书涵盖了软件架构整个生命周期的方方面面，是能为任何软件架构项目（无论多么复杂）提供专家方法和测试模型的实用指南。通过这本书，你不仅掌握什么是架构、架构的影响，更是能掌握如何评估架构质量。
《解决方案架构师修炼之道》
最后，再强行植入一本门槛稍低的书，这本书能为任何软件架构项目提供专家方法和测试模型的实用指南：
探讨解决方案架构师所扮演的各种角色，以及他们在企业中所发挥的作用。
从架构师的角度理解大数据处理、机器学习和物联网等高级概念。
发现不同的解决方案架构模式，如事件驱动和微服务模式。
找到让自己跟上技术更新并提高技能的方法。
借助云迁移实现遗留系统的现代化改造。
选择合适的战略以降低成本。
希望以上十本书中，总有一本适合你。不断学习、积累知识，成为一名优秀的架构师！！
文末送书 送书参与方式
图书数量：下方名片内小程序直接抽出 2 名小伙伴 送出本文上述架构师的书籍中任意一本 ！
活动时间：截止到 2023/11/24 21:00:00
🏆抽奖方式：
⭐️⭐️点击下方名片，点击菜单抽奖，即可参与（如下图）⭐️⭐️
🏆会在 CSDN 动态公布中奖名单。
名单公布时间：2023/11/24 21:10:00
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/926314cc20574e9faf301edfd8cdc7f0/" rel="bookmark">
			数据结构-二叉树·堆（顺序结构的实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎉个人名片：
🐼作者简介：一名乐于分享在学习道路上收获的大二在校生
🐻‍❄个人主页🎉：GOTXX
🐼个人WeChat：ILXOXVJE
🐼本文由GOTXX原创，首发CSDN🎉🎉🎉
🕊系列专栏：零基础学习C语言----- 数据结构的学习之路
🐓每日一句：如果没有特别幸运，那就请特别努力！🎉🎉🎉
————————————————
🎉文章简介：
本篇文章对 树的相关概念及结构，二叉树（堆）的概念及结构，二叉树顺序结构及实现的相关知识详细讲解！二叉树链式结构 在下一章讲解！
如果您觉得文章不错，期待你的一键三连哦，你的鼓励是我创作动力的源泉，让我们一起加油，一起奔跑，让我们顶峰相见！！！🎉🎉🎉
目录
一.树的概念及结构
1.1树的概念
相关概念：
1.2树的表示
二.二叉树的概念及结构
2.1二叉树的概念
二叉树：
2.2两个特殊的二叉树
满二叉树：
完全二叉树：
三.二叉树顺序结构及实现
3.1二叉树顺序结构
堆在存储的分类：大根堆，小根堆
3.2二叉树（堆）顺序结构的实现
这里重点分析向上/向下调整的函数
向上调整：
向下调整：
完整代码：Heap.h Heap.c 一.树的概念及结构 1.1树的概念 图一 图二 树是一种非线性的数据结构，它是由k个节点（k&gt;=0）组成的具有层次关系的一个集合，如图一所示，把上图倒过来，如图二所示，看起来像一棵树，所以被叫作树；
类似于树的特点，把最上面的那个结点（A）叫作根结点；
除了根结点，其余的结点又可以分为若干个类似于树的子树，如下图：
所以树是递归定义的；
相关概念： 1.结点的度：及该结点含有子树的个数(有几个孩子)，如上图：1的度为3，2的度为1，4的度为2；
2.叶结点（终端结点）：度为0的结点，如上图的3，5，6，7；
3.分枝结点（非终端结点）：根结点与叶结点以外的结点，如2，4；
4.双亲结点（父结点）：一个结点含有子结点，该结点称为子结点的父结点，如1是2，3，4的父结点，4是6，7的父结点；
5.孩子结点（子结点）：如5是2的子结点，4是1的子结点；
6.兄弟结点：有相同父结点的结点称为兄弟结点，如6，7的父结点都是4，所以6，7是兄弟结点；
7.树的度：一棵树中，最大的结点的度称为树的度，如上面的树的度是3（因为1的度最大，为3）；
8.结点的层次：根为第一层，往下一次类推；
9.树的高度（深度）：如上图，树的高度为3；
10.森林：有许多互不相交的树组成的集合；
11.度为0的结点个数为N0，度为2的节点个数为N2；则有N0=N2+1；
1.2树的表示 最常见的是孩子兄弟表示法
双亲表示法（一般使用结构体数组）：只存储双亲的下标或指针；
例如：
上面这个树用双亲表示法表示：
蓝色：存储的该结点的父结点的下标或指针；
没有父亲就存储-1（-1不是个有效的下标）；
二.二叉树的概念及结构 2.1二叉树的概念 二叉树： 1.不存在度大于2的结点的树；最多两个，可以是1个或则0个；
度为0（空树）；
2.二叉树的子树 有左右子树之分，次序不能颠倒，所以二叉树是有序的；
2.2两个特殊的二叉树 满二叉树： 一个二叉树，如果每一层的结点数都达到最大值，这个数就是满二叉树；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/926314cc20574e9faf301edfd8cdc7f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2da4e624f44772996a40afa9f3f82029/" rel="bookmark">
			扩散模型实战（十）：Stable Diffusion文本条件生成图像大模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推荐阅读列表： 扩散模型实战（一）：基本原理介绍
扩散模型实战（二）：扩散模型的发展
扩散模型实战（三）：扩散模型的应用
扩散模型实战（四）：从零构建扩散模型
扩散模型实战（五）：采样过程
扩散模型实战（六）：Diffusers DDPM初探
扩散模型实战（七）：Diffusers蝴蝶图像生成实战
扩散模型实战（八）：微调扩散模型
扩散模型实战（九）：使用CLIP模型引导和控制扩散模型
在AIGC时代，Stable Diffusion无疑是其中最亮的“仔”，它是一个强大的文本条件隐式扩散模型（text-conditioned latent diffusion model），可以根据文字描述（也称为Prompt）生成精美图片。
一、基本概念 1.1 隐式扩散 对于基于transformer的大模型来说，self-attention的计算复杂度与输入数据是平方关系的，比如一张128X128像素的图片在像素数量上是64X64像素图片的4倍，内存和计算量是16倍。这正是高分辨率图像生成任务存在的普遍现象。
为了解决这个问题，提出了隐式扩散（Latent Diffusion）方法，该方法认为图片通常包含大量冗余信息，首先使用大量图片数据训练一个Variational Auto-Encode（VAE）模型，编码器将图片映射到一个较小的隐式表示，解码器可以将较小的隐式表示映射到原始图片。Stable Diffusion中的VAE接受一张3通道图片作为输入，生成一个4通道的隐式特征，同时每一个空间维度都将减少为原来的八分之一。例如，一张512X512像素的图片可以被压缩到一个4X64X64的隐式表示。
通过在隐式表示（而不是完整图像）上进行扩散，可以使用更少的内存也可以减少UNet层数，从而加速图片生成，极大降低了训练和推理成本。
隐式扩散的结构，如下图所示：
1.2 以文本为生成条件 前面的章节展示了如何将额外信息输入给UNet，以实现对生成图像的控制，这种方法称为条件生成。以文本为条件进行控制图像的生成是在推理阶段，我们可以输入期望图像的文本描述（Prompt），并把纯噪声数据作为起点，然后模型对噪声数据进行“去噪”，从而生成能够匹配文本描述的图像。那么这个过程是如何实现的呢？
我们需要对文本进行编码表示，然后输入给UNet作为生成条件，文本嵌入表示如下图ENCODER_HIDDEN_STATES
Stable Diffusion使用CLIP对文本描述进行编码，首先对输入文本描述进行分词，然后输入给CLIP文本编码器，从而为每个token产生一个768维（Stable Diffusion 1.x版本）或者1024维（Stable Diffusion 2.x版本）向量，为了使输入格式一致，文本描述总是被补全或者截断为77个token。
那么，如何将这些条件信息输入给UNet进行预测呢？答案是使用交叉注意力（cross-attention）机制。UNet网络中的每个空间位置都可以与文本条件中的不同token建立注意力（在稍后的代码中可以看到具体的实现），如下图所示：
1.3 无分类器引导 第2节我们提到可以使用CLIP编码文本描述来控制图像的生成，但是实际使用中，每个生成的图像都是按照文本描述生成的吗？当然不一定，其实是大模型的幻觉问题，原因可能是训练数据中图像与文本描述相关性弱，模型可能学着不过度依赖文本描述，而是从大量图像中学习来生成图像，最终达不到我们的期望，那如何解决呢？
我们可以引入一个小技巧-无分类器引导（Classifier-Free Guidance，CFG）。在训练时，我们时不时把文本条件置空，强制模型去学习如何在无文字信息的情况下对图像“去噪”。在推理阶段，我们分别进行了两个预测：一个有文字条件，另一个则没有文字条件。这样我们就可以利用两者的差异来建立一个最终的预测了，并使最终结果在文本条件预测所指明的方向上依据一个缩放系数（引导尺度）更好的生成文本描述匹配的结果。从下图看到，更大的引导尺度能让生成的图像更接近文本描述。
1.4 其他类型的条件生成模型：Img2Img、Inpainting与Depth2Img模型 其实除了使用文本描述作为条件生成图像，还有其他不同类型的条件可以控制Stable Diffusion生成图像，比如图片到图片、图片的部分掩码（mask）到图片以及深度图到图片，这些模型分别使用图片本身、图片掩码和图片深度信息作为条件来生成最终的图片。
Img2Img是图片到图片的转换，包括多种类型，如风格转换（从照片风格转换为动漫风格）和图片超分辨率（给定一张低分辨率图片作为条件，让模型生成对应的高分辨率图片，类似Stable Diffusion Upscaler）。Inpainting又称图片修复，模型会根据掩码的区域信息和掩码之外的全局结构信息生成连贯的图片。Depth2Img采用图片的深度新作为条件，模型生成与深度图本身相似的具有全局结构的图片，如下图所示：
1.5 使用DreamBooth微调扩散模型 DreamBooth可以微调文本到图像的生成模型，最初是为Google的Imagen Model开发的，很快被应用到Stable Diffusion中。它可以根据用户提供的一个主题3~5张图片，就可以生成与该主题相关的图像，但它对于各种设置比较敏感。
二、环境准备 安装python库
pip install -Uq diffusers ftfy acceleratepip install -Uq git+https://github.com/huggingface/transformers 数据准备
import torchimport requestsfrom PIL import Imagefrom io import BytesIOfrom matplotlib import pyplot as plt　# 这次要探索的管线比较多from diffusers import ( StableDiffusionPipeline, StableDiffusionImg2ImgPipeline, StableDiffusionInpaintPipeline, StableDiffusionDepth2ImgPipeline ) # 因为要用到的展示图片较多，所以我们写了一个旨在下载图片的函数def download_image(url): response = requests.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2da4e624f44772996a40afa9f3f82029/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1fd62bb4c3307d465aaf2f43e078992/" rel="bookmark">
			ElasticStack日志分析平台－ES 集群、Kibana与Kafka
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Elasticsearch 1、介绍： Elasticsearch 是一个开源的分布式搜索和分析引擎，Logstash 和 Beats 收集的数据可以存储在 Elasticsearch 中进行搜索和分析。
Elasticsearch为所有类型的数据提供近乎实时的搜索和分析：一旦数据被索引，它就可以立即被搜索和分析，这种实时性使得用户能够即时获取最新数据的搜索结果和分析信息。
2、概念： ① 文档：文档是 Elasticsearch中所有可搜索数据的最小的数据单元。它是以JSON 格式表示的一条数据记录，每个文档都有一个唯一的ID来标识，文档可以包含各种字段，例如文本、数字、日期、嵌套对象等。
② 文档元数据：文档除了包含实际的数据外，还有一些元数据信息。这些信息包括文档的版本号、索引的时间戳、路由信息等。
③ 索引（Index）：索引是一组具有相似特征的文档的集合，每个索引都有一个唯一的名称，用于标识和检索其中的文档。
二、ES 集群： 1、概念： Elasticsearch（ES）集群是由一个或多个Elasticsearch节点组成的集合。这些节点协同工作，共同承载数据存储、处理和搜索的负载。
(1) Master Node 和 Master-eligible Node: ① Master Node：主节点负责管理整个集群的状态和拓扑结构；
② Master-eligible Node：有资格成为主节点的节点。
ES 集群每个节点启动后，默认就是一个 Master eligible node，Master-eligible node 可以参加选主流程，成为 Master Node ；当第一个节点启动时，它会将自己选举成 Master Node，每个节点上都保存了集群的状态，只有 Master Node 才能修改集群的状态信息。
(2) Date Node 和 Coordinating Node： ① Data Node：数据节点，这些节点负责存储数据分片；
② Coordinating Node：协调节点，负责接收来自客户端的请求，将请求转发到适当的数据节点，并将数据节点的响应整合后返回给客户端。
(3) 主分片与副本分片： 分片（Shards）是将数据水平分割和分布式存储的机制，它允许将大量数据分散到集群中的多个节点上，以提高性能、扩展性和可用性。
① 主分片（Primary Shard）：主分片是索引的原始数据分片，在创建索引时，可以指定主分片的数量，一旦创建后，主分片的数量将保持不变。
② 副本分片（Replica Shard）：副本分片是主分片的复制品，用于提供数据的冗余备份和高可用性。副本分片数量可以随时更改，通过增加或减少副本的数量，可以影响集群服务的可用性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1fd62bb4c3307d465aaf2f43e078992/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cd68789a3010dcd1af019644dd012db/" rel="bookmark">
			Layout工程师们--Allegro X AI实现pcb自动布局布线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cadence 推出 Allegro X AI，旨在加速 PCB 设计流程，可将周转时间缩短 10 倍以上
楷登电子（美国 Cadence 公司，NASDAQ：CDNS）今日宣布推出 Cadence® Allegro® X AI technology，这是 Cadence 新一代系统设计技术，在性能和自动化方面实现了革命性的提升。这款 AI 新产品依托于 Allegro X Design Platform 平台，可显著节省 PCB 设计时间，与手动设计电路板相比，在不牺牲甚至有可能提高质量的前提下，将布局布线（P&amp;R）任务用时从数天缩短至几分钟。
传统上，PCB 设计中的布局布线一直是一个耗时的手动过程，会影响产品上市速度。Allegro X AI 技术利用云端的扩展性来实现物理设计自动化，在提供 PCB 生成式设计的同时，还可确保设计在电气方面准确无误，并可用于制造。这项新技术可自动执行器件摆放、金属镀覆和关键网络布线，并集成了快速信号完整性和电源完整性分析功能。使用生成式 AI 功能，客户可以简化自己的系统设计流程，将 PCB 设计周转时间缩短 10 倍以上。
Allegro X AI 技术具有以下优势：
· 提高生产力：采用可扩展架构，利用云端的计算基础设施，实现自动布局布线，从而大幅缩短设计周转时间。
· 更好的结果质量：利用生成式 AI 自动布局功能，能够在设计的早期阶段进行可行性分析。超越手动方法，探索更多解决方案可能性，进一步优化各类指标，如在缩短线长的同时遵守设计约束条件。
· 高效的设计收敛：Allegro X 平台与系统分析技术紧密集成，使用户可以优化设计的电气性能和热性能。
“Cadence 致力于提供融合人工智能和云技术的系统设计解决方案，确保最快的周转时间，”Cadence 公司研发副总裁 Michael Jackson 说，“新推出的 Allegro X AI 技术巩固了 Cadence 在 PCB 设计方面的技术领先地位，带来了变革性的影响，通过人工智能驱动的自动化、增强的引擎性能，以及与 Cadence 系统设计和分析产品组合的集成，帮助客户提高生产力。”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d03d9044547fed9598132c3932f0427/" rel="bookmark">
			Android Studio - 新版 logcat 过滤使用记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于 as 在每次升级都有很多问题，因此去年升级到 Dolphin 就一直未升级，Dolphin 版本就可以在设置中打开新版的 logcat 过滤功能，觉得不太习惯又关掉了。这次刚好 asfp 的下载重新学习下新版的功能。在此简单记录下。
我们可以在输入框输入 "p" 然后就会有提示 p 开头的过滤名称。旧版的只能在过滤包名的条件下再过滤一个名称，新版的可以自行创建过滤规则。输入包名也会有提示的。
常用的使用方式 1、过滤包名 package:org.sipdroid.sipua 2、过滤字段 message:sipua 3、过滤包名加字段 package:org.sipdroid.sipua message:alarm 4、过滤包名加两个字段 package:org.sipdroid.sipua message:=alarm message:600 解释如下
其他的方式可以按照自己的需要任意添加，下面补充一下各个含义：
tag：与日志条目的 tag 字段匹配。package：与日志记录应用的软件包名称匹配。process：与日志记录应用的进程名称匹配。message：与日志条目的消息部分匹配。level：与指定或更高严重级别的日志匹配，例如 DEBUG。age：如果条目时间戳是最近的，则匹配。值要指定为数字，后跟表示时间单位的字母：s 表示秒，m 表示分钟，h 表示小时，d 表示天。例如，age: 5m 只会过滤过去 5 分钟内记录的消息。 否定和正则表达式 以下字段支持否定和正则表达式匹配：tag、package、message 和 line。
否定的表示方式是在字段名称前面加上 -。例如，-tag:MyTag 匹配 tag 不包含字符串 MyTag 的日志条目。
正则表达式匹配通过在字段名称中附加 ~ 来表示。例如 tag~:My.*Tag。
否定和正则表达式修饰符可以结合使用。例如，-tag~:My.*Tag。
逻辑运算符和圆括号 查询语言支持由 &amp; 和 | 以及圆括号表示的 AND 和 OR 运算符。例如：
(tag:foo | level:ERROR) &amp; package:mine
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d03d9044547fed9598132c3932f0427/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5965fcb691da972cdd8d085c48615efd/" rel="bookmark">
			解决 “Module build failed (from ./node_modules/babel-loader/lib/index.js)“ 错误的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 文章目录 系列文章目录前言一、错误原因：二、解决方法：三、注意事项：总结 前言 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站，这篇文章男女通用，看懂了就去分享给你的码吧。
在前端项目开发中，如果使用了 Babel 来转译 ES6+ 语法，有时会遇到错误信息 “Module build failed (from ./node_modules/babel-loader/lib/index.js)”。这个错误通常发生在使用 Webpack 或其他构建工具时。本文将详细介绍出现这个错误的原因，并提供解决方法，确保正确转译 ES6+ 语法，避免该错误的发生。
一、错误原因： “Module build failed (from ./node_modules/babel-loader/lib/index.js)” 错误通常发生在以下情况：
Babel 配置错误：可能是因为 Babel 配置有误，或者缺少必要的插件或预设。
依赖版本不兼容：Babel 的依赖版本与其他插件或构建工具不兼容，导致转译失败。
缺少必要的依赖：可能缺少了必要的依赖，导致 Babel 无法正常工作。
二、解决方法： 要解决 “Module build failed (from ./node_modules/babel-loader/lib/index.js)” 错误，我们需要采取以下措施：
检查 Babel 配置： 首先要检查项目中的 Babel 配置文件（通常是 .babelrc 或 babel.config.js），确保配置正确并且没有语法错误。
安装依赖： 确保项目中已经安装了必要的 Babel 相关依赖。通常需要安装 @babel/core、@babel/preset-env 等核心插件和预设。
版本兼容性： 确保 Babel 的依赖版本与其他插件或构建工具兼容。可以尝试更新 Babel 相关依赖的版本，或者查看文档了解版本兼容性信息。
清除缓存： 有时缓存可能导致错误，可以尝试清除 Webpack 或其他构建工具的缓存。
查看错误日志： 在错误信息中通常会包含更详细的错误栈信息，可以查看错误日志来了解具体出错的原因。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5965fcb691da972cdd8d085c48615efd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2860e6d6ccd5941697ff2cbfd5d163c/" rel="bookmark">
			MySQL排序规则之utf8mb4_0900_ai_ci
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. utf8mb4_0900_ai_ci是什么？如何理解？ 是什么？ utf8mb4_0900_ai_ci是mysql8.0之后的数据库的一种排序规则（collation）。
如何理解？ utf8mb4，这个名字许多人大概熟悉。如今️✈️♥️emoji表情已经大量使用，但MySQL之前的的字符集(character set)是utf8(更准确的名字是utf8mb3，一个字符最多使用3个字节来存储)，只能存储编码值从0x000到0xFFFF之间的字符。然而，emoji表情字符的码值超过了0xFFFF，按照UTF-8规范，存储时需要用4个字节。正因为如此，MySQL才提供了utf8mb4的字符集。如果把数据库表的字符集设定为utf8mb4，就可以正常存储包含表情字符的文本了。中间的0900，它对应的是Unicode 9.0的规范。要知道，Unicode规范是在不断更新的，每次更新既包括扩充，也包括修正。比如6.0版新加入了222个中日韩统一表义字符(CJK Unified Ideographs)，7.0版加入了俄国货币卢布的符号等等。最后两部分_ai_ci，ai表示accent insensitivity，也就是“不区分音调”，而ci表示case insensitivity，也就是“不区分大小写”。 2. utf8mb4_0900_ai_ci有什么优点，为什么要用它？ utf8mb4_0900_ai_ci是针对Unicode字符集的一种扩展，支持存储和处理更广泛的字符。
使用utf8mb4_0900_ai_ci的一些优点和原因：
支持更多的字符：utf8mb4_0900_ai_ci字符集支持存储和处理包括表情符号、特殊符号和罕见字符在内的更多Unicode字符。相比之前的字符集，它可以更全面地满足多语言和多字符需求。表情符号支持：随着表情符号在现代通信中的广泛使用，使用utf8mb4_0900_ai_ci字符集可以确保数据库能够正确存储和处理这些表情符号。排序规则：utf8mb4_0900_ai_ci排序规则是根据Unicode标准制定的，它提供了更准确和一致的排序方式。这对于需要对文本进行排序和比较的应用程序非常重要，尤其是涉及多语言的场景。兼容性：utf8mb4_0900_ai_ci字符集在MySQL 8.0.0版本引入，是MySQL官方推荐的字符集。使用它可以确保与最新版本的MySQL兼容，并且能够利用MySQL提供的最新功能和改进。 总之，utf8mb4_0900_ai_ci字符集和排序规则提供了更广泛的字符支持和更准确的排序方式，适用于需要处理多语言、表情符号和特殊字符的应用程序。它是与最新版本的MySQL兼容的推荐选择。
3. 如何使用utf8mb4_0900_ai_ci？ 要在MySQL中使用utf8mb4_0900_ai_ci字符集和排序规则，需要进行以下步骤：
创建数据库时指定字符集和排序规则： CREATE DATABASE your_database_name CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci; 这将创建一个名为your_database_name的数据库，并将其字符集设置为utf8mb4，排序规则设置为utf8mb4_0900_ai_ci。
2. 在创建表时指定字符集和排序规则：
CREATE TABLE your_table_name ( column1 datatype CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci, column2 datatype CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci, ... ); 在创建表时，为每个需要存储utf8mb4字符集的列指定字符集和排序规则。将datatype替换为相应的数据类型。
3. 修改现有表的字符集和排序规则：
ALTER TABLE your_table_name CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci; 使用上述语句，将现有表your_table_name的字符集和排序规则修改为utf8mb4和utf8mb4_0900_ai_ci。
请注意，执行上述操作可能会导致数据丢失或格式变化。在进行任何更改之前，请务必备份重要的数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2860e6d6ccd5941697ff2cbfd5d163c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f671e82f0b6d0f13a46d6c769376a95/" rel="bookmark">
			Oracle中的NVL、NVL2、NULLIF、COALESCE函数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NVL、NVL2、NULLIF与COALESCE都是处理当前字段值为空时候的转换函数。接下来我们对这几个函数进行介绍。
NVL函数 基本语法：
NVL（表达式1，表达式2）
含义：
如果表达式1为空值，NVL返回值为表达式2的值，否则返回表达式1的值。
该函数的目的是把一个空值（null）转换成一个实际的值。其表达式的值可以是数字型、字符型和日期型，表达式1和表达式2的数据类型必须为同一个类型。举例如下：
对数字型： NVL（ comm,0);对字符型： NVL( TO_CHAR(comm), ‘No Commission’)对日期型 ：NVL（hiredate,’ 28-MAR-99’) 示例1：
SELECT D.EMPNO,D.COMM, NVL(COMM,200) FROM SCOTT.EMP D; 示例2：
select ename,NVL(TO_char(comm),ename||' is not a salesperson!') AS COMMISSION from emp NVL2函数 基本语法：
NVL2(表达式1，表达式2，表达式3）
含义：
如果表达式1为空，返回值为表达式3的值。如果表达式1不为空，返回值为表达式2的值。
例如 NVL2（comm，sal+comm,sal)
NVL2函数测试comm，如果comm为空，就返回sal 的值。如果 comm 不为空(null),就返回表达式 sal+comm的值。
示例：
SELECT D.EMPNO, COMM, SAL,NVL2(COMM, SAL + COMM, SAL) FROM SCOTT.EMP D; NULLIF函数 基本语法：
NULLIF(表达式1,表达式2)
含义：
如果第一个表达式和第二个表达式的内容相同，那么返回NULL，否则，返回第一个表达式的值。
示例：
SELECT ENAME,NULLIF(LENGTH(ENAME),5) FROM SCOTT.EMP D; COALESCE函数 基本语法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f671e82f0b6d0f13a46d6c769376a95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b732f99992a8a0b6b412b79f3f9ab951/" rel="bookmark">
			postman可以通的请求，前端通不了（前端添加Content-type，后端收不到请求）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接口完成之后，自己使用postman测试了一下，没有问题；
可是在和小组前端调试接口的时候，他却说访问不了；
信息如下：（我自己写的一个打印请求信息的拦截器）
发现报错信息是：
Content type 'application/x-www-form-urlencoded;charset=UTF-8' not supported
也就是说发送过来的内容格式为 “application/x-www-form-urlencoded；charset=UTF-8”，这个内容格式后端不支持；
主要是因为我的后端使用的是@RequestBody注解接收的参数
这个注解需要“application/json”格式的数据；
让后前端就加了一个
headers: {
'Content-Type': 'application/json;charset=UTF-8'
}
可是此时他使用的框架却报错了
Network Error
AxiosError: Network Error
at XMLHttpRequest.handleError (webpack-internal:///.de_modules/axiosb/adapters/xhr.js:160:14)
并且我后端的信息如下：
请求方式为OPTION;(可是他发送的是Post)
我也看不懂
去问了一下chatgpt
也去搜了许多相关的博文，
后面发现将Content-Type设置成application/json会受到同源政策的限制。就会会先发送一个option请求嗅探服务器是否具有应答的能力，然后才会发送真正的请求。
此时关键的就来了，
"Access-Control-Allow-Headers"响应头告诉浏览器服务器允许的额外请求头，以便浏览器可以继续发送实际的跨域请求。
也就是说后端需要设置一个"Access-Control-Allow-Headers"让浏览器发送真实的跨域请求（这里设置了headers的请求）；
代码如下：添加一个拦截器
package com.kzj.common.filter; import javax.servlet.*; import javax.servlet.annotation.WebFilter; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebFilter//需要启动类开启@ServletComponentScan才会生效 public class MyAddCrossOrigin implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletResponse response=(HttpServletResponse)servletResponse; //允许来自任何源的跨域请求 response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b732f99992a8a0b6b412b79f3f9ab951/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bd811c4f6ee3c693cd63b9a89795a31/" rel="bookmark">
			【数据结构】顺序表详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言
一、顺序表是什么
二、顺序表的基本操作
1.初始化
实现思想：
代码如下（示例）：
2.顺序表扩容函数
实现思想：
代码如下（示例）：
3.顺序表头插
实现思想：
代码如下（示例）：
代码实现图（示例）：
4.顺序表尾插
实现思想：
代码如下（示例）：
代码实现图（示例）：
5.顺序表尾删
实现思想：
代码如下（示例）：
代码实现图（示例）：
6.顺序表头删
实现思想：
代码如下（示例）：
代码实现图（示例）：
7.顺序表查找
实现思想：
代码如下（示例）：
代码实现图（示例）：
8.顺序表任意位置插入
实现思想：
代码如下（示例）：
代码实现图（示例）：
9.顺序表任意位置删除
实现思想：
代码如下（示例）：
代码实现图（示例）：
10.销毁顺序表
实现思想：
代码如下（示例）：
11.顺序表打印
实现思想：
代码如下（示例）：
代码实现图（示例）：
12.顺序表修改
实现思想：
代码如下（示例）：
代码实现图（示例）：
总结
前言 本文详细的介绍了数据结构当中的最基础的顺序表，可以让初学者对顺序表进行深刻的的理解
一、顺序表是什么 顺序表是一种线性结构，它的逻辑上相邻的数据在计算机内的存储位置也是相邻的，可以快速定位第几个元素，中间不允许有空，所以插入、删除时需要移动大量元素。顺序表可以分配一段连续的存储空间。顺序表上的基本操作有：初始化、顺序表头插、尾插、头删、尾删、查找、插入、删除、修改、销毁顺序表。
二、顺序表的基本操作 1.初始化 一个程序要进行首先一个功能，首先要保证要进行初始化。对数据的初始化就如同汽车的车架子相同。
实现思想： 主体思想：为程序开辟所需要的内存空间，并对开辟的结构体进行初始化
顺序表的初始化，首先要保证头节点地址不为空，然后使用malloc函数开辟一个固定大小结构体的空间，使结构体的当中的指针至指向该空间，并且判断是否开辟失败，如果失败perror函数返回开辟失败的原因，并将结构体的其他的变量进行初始化
代码如下（示例）： void SLInit(SL* ps) { assert(ps); ps-&gt;a = (SLDataType*)malloc(sizeof(SLDataType)*4); if (ps-&gt;a == NULL) { perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bd811c4f6ee3c693cd63b9a89795a31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c71f93311ad1eec7858bf2a58fe4326/" rel="bookmark">
			spring中，为什么前端明明传了值，后端却接收不到
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题场景问题重现解决方式原因分析原理分析结论扩展 问题场景 在进行前后端的联调时，有时候会出现，前端明明传了值，后端接口却接收不到的情况，这种情况常常让人很苦恼，然后就会去仔细对比前后端的参数单词是不是对应上了，也会去检查是不是前端的请求参数格式有问题，又或者是后端接口接收的参数格式有问题，一通检查对比下来，发现都没问题。那究竟是为什么呢？那就继续往下看吧。
问题重现 控制层代码：
@PostMapping(value = "/test") public void test(@RequestBody UserVO userVO) { System.out.println("用户代码：" + userVO.getUCode()); System.out.println("用户名称：" + userVO.getUName()); } 参数实体类：UserVO
@Data public class UserVO { /** * 用户代码 */ private Long uCode; /** * 用户名称 */ private String uName; } 用postman模拟前端调用：
控制台预期打印结果：
用户代码：12345 用户名称：小明 控制台实际打印结果：
解决方式 在实体类的属性上方加@JsonProperty注解，如下图：
然后测试控制台打印结果：
原因分析 首先我们先把实体类复原，并且加上一个新的属性loginType
@Data public class UserVO { /** * 用户代码 */ private Long uCode; /** * 用户名称 */ private String uName; /** * 登录类型 */ private String loginType; } 眼尖的同学可能会发现了，我新加的属性loginType长得是不是跟原来两个属性uCode和uName不太一样，不一样的点在于uCode和uName都是首字母小写，第二个字母大写的单词，而loginType则不然。但是它们三都符合驼峰命名法的规范，对吧。这时候可以猜测，难道是这个原因导致的？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c71f93311ad1eec7858bf2a58fe4326/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac906ccf6b0d4415fd1886ccd76e44f0/" rel="bookmark">
			uniapp实现将页面转换成pdf（小程序、app、h5）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用html2Canvas和jspdf
安装这两个
npm i jspdf html2canvas uniapp在小程序无法获取dom，app端可在renderjs中获取 dom，小程序需要使用web-view导入一个h5页面，实现转pdf
H5和小程序 &lt;template&gt; &lt;div&gt; &lt;div id="content"&gt; 要转换的内容 &lt;/div&gt; &lt;button type="button" class="btn btn-primary" @click="getPdf()"&gt;导出PDF&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import html2Canvas from 'html2canvas' import { jsPDF } from 'jspdf' let BaseUrl = 'url' //域名 export default{ methods:{ getPdf(){ let that = this var shareContent = document.getElementById('content'); var width = shareContent.offsetWidth / 4; var height = shareContent.offsetHeight / 4; html2Canvas(shareContent , { dpi: 900, scrolly: 0, // width:eleW,//生成后的宽度 // height:eleH,//生成后的高度 scrollx: -10, useCORS: true, //允许canvas画布内可以跨域请求外部链接图片, 允许跨域请求。 // backgroundColor: null //避免图片有白色边框 }).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac906ccf6b0d4415fd1886ccd76e44f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b79b22695b3749c1a9ce415ce0a0adb/" rel="bookmark">
			不用写一行代码！Python最强自动化神器！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Playwright介绍 Playwright是一个由Microsoft开发的开源自动化测试工具，它可以用于测试Web应用程序。Playwright支持多种浏览器，包括Chrome、Firefox和WebKit，同时也支持多种编程语言，如JavaScript、TypeScript、Python和C#。
2、特点、使用场景 Playwright具有以下特点：
支持所有主流浏览器
跨平台：Windows、Linux 和macOS
可用于模拟移动端WEB应用的测试。
支持无头模式（默认）和有头模式
使用场景包括但不限于：
自动化测试：开发人员和测试人员可以使用Playwright来编写自动化测试脚本，验证Web应用程序的功能和性能。
性能测试：Playwright可以模拟多个用户同时访问Web应用程序，帮助测试应用程序在高负载情况下的性能表现。
可访问性测试：Playwright可以模拟用户使用辅助技术（如屏幕阅读器）访问Web应用程序，帮助测试应用程序的可访问性。
网页截图和录制：Playwright可以生成网页截图，也可以录制用户操作过程，帮助开发人员和测试人员分析问题。
总之，Playwright可以用于各种Web应用程序测试场景，帮助团队提高测试效率和测试覆盖率。
3、架构原理 playwright共由三部分组成：
client：在客户端是我们用不同的编程语言编写的代码，如JavaScript，Java，Python，C#等。
server：Playwright的server通过nodejs构建并负责与client 以及不同的 Web 浏览器引擎进行通信。
通信协议：client通过WebSocket 协议与Playwright server 通信；
Playwright使用 Chrome DevTools 协议（CDP）与 Chromium 通信。触发测试后，client端代码将被转换为JSON格式，然后使用websocket协议发送到服务器。palywright通过单个 websocket 协议连接传达所有请求，该连接将保持不变，直到所有测试执行完成。由于命令是在单个连接上发送的，因此测试失败或不稳定的可能性较小，并且命令可以快速执行。这种架构与Selenium相反，Selenium使用HTTP连接协议，并将每个命令（如浏览器打开，单击，关闭浏览器）作为单独的HTTP请求发送。此外，在Selenium中，服务器和客户端之间的连接将在每次请求后终止，并为下一个请求重新建立。这也是Playwright为什么比selenium快的原因！
4、环境安装 Playwright环境部署简单，不像Selenium那样需要下载浏览器对应版本的驱动程序chromedriver，直接安装即可：
# 1、安装 playwright: pip3 install playwright # 2、安装所需的浏览器 chromium,firefox 和 webkit: playwright install # 3、如何只安装特定的浏览器，比如Chrome： playwright install chromium 如果您在使用 pip3 install playwright 安装 Playwright 时遇到下载速度缓慢的问题，可以尝试以下方法来加速下载：
更换 pip 镜像源
可以使用国内的 pip 镜像源来替代默认的源，例如使用阿里云的 pip 镜像源或者清华大学的镜像源等。可以使用以下命令来更换 pip 镜像源：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b79b22695b3749c1a9ce415ce0a0adb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9099643cdb1004e283c08f5856f8879/" rel="bookmark">
			【小黑送书—第六期】＞＞AI时代，程序员如何应对挑战——《AI时代系列书籍》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在AI时代，程序员面临着新的机遇和挑战。为了适应这个快速发展的时代，掌握新技能并采取相应的应对策略是至关重要的。
对于办公人员或程序员来说，利用AI可以提高工作效率。例如，使用AI助手可以帮助自动化日常的重复性工作，如邮件筛选、日程安排等。此外，AI还可以用于数据分析和预测，帮助办公人员更好地做出决策和规划。
今天给大家带来AI时代系列书籍：《AI时代程序员开发之道：ChatGPT让程序员插上翅膀》《AI时代项目经理成长之道：ChatGPT让项目经理插上翅膀》《AI时代产品经理升级之道：ChatGPT让产品经理插上翅膀》《AI时代架构师修炼之道：ChatGPT让架构师插上翅膀》
由北京大学出版社出版，一套专注于帮助程序员在AI时代实现晋级、提高效率的图书。
《AI时代项目经理成长之道：ChatGPT让项目经理插上翅膀》 内容简介： 《AI时代项目经理成长之道：ChatGPT让项目经理插上翅膀》是一本致力于揭示人工智能如何颠覆和重塑项目管理，并以ChatGPT为核心工具推动项目管理创新的实用指南。本书通过13章的系统探讨，带领读者踏上项目管理卓越之路。
第1章“人工智能颠覆与重塑项目管理”，首先揭示了人工智能对项目管理的深刻影响和带来的机遇与挑战，为读者构建了认知框架。第2章至第13章依次介绍了使用ChatGPT编写各种文档、在项目启动中的应用、帮助组建高效团队、辅助项目沟通管理、项目计划与管理、项目成本管理、项目时间管理、项目质量管理、项目风险管理、辅助采购计划与采购流程、辅助项目绩效管理以及进行项目总结等各方面的内容。 本书注重理论与实践的结合，每章都以具体案例、实用技巧和实践为基础，帮助读者深入了解ChatGPT的应用场景，掌握在项目管理中实际运用的方法和策略。在本书中，读者将学习如何利用ChatGPT工具提升项目管理效率、增强团队协作能力、改善沟通效果、精确制订计划、优化成本控制、管理项目进度、确保质量标准、识别和应对风险、优化采购过程、衡量绩效指标以及总结项目经验。
无论您是初入职场的新手项目经理还是经验丰富的专业人士，本书都将成为您的导航，帮助您在人工智能时代展现卓越的项目管理能力。通过本书的指导，您将获得ChatGPT引领下的项目管理创新之道，并在日常工作中取得更加优异的成果
编辑推荐： 1.开发新模式：让项目管理更高效、更快捷、更完美。
2.全流程解析：涵盖ChatGPT的不同应用场景，从编写各种文档，到组建高效团队、辅助项目沟通管理、计划管理、时间管理、质量管理等使用ChatGPT进行程序开发的关键技巧。
3.实战检验：ChatGPT结合多种项目管理工具及案例实操讲解，理解更加透彻。
4.100%提高开发效率：揭秘ChatGPT与项目管理工作高效融合的核心方法论和实践经验。
5.超值资源：免费赠送全书案例源文件、教学视频及配套工具，供读者下载学习。
《AI时代程序员开发之道：ChatGPT让程序员插上翅膀》 内容简介： 本书是一本介绍如何使用ChatGPT的实用手册，它建立了一个新的程序员开发模式。本书从介绍 “ChatGPT第一次接触”开始，深入分析如何使用该工具来提高开发效率和质量。
本书的每一章都涵盖了ChatGPT的不同应用场景，从编写各种文档，到辅助进行需求分析和系统设计，以及数据库设计和开发高质量代码等，均有详尽的讲解。读者将从中了解到，如何利用ChatGPT这一AI工具来辅助程序员更加高效地开发软件。
本书还特别介绍了如何使用ChatGPT辅助进行系统测试以及任务管理，并对源代码底层逻辑进行了深入分析。这个全面的框架将帮助读者在软件开发过程中更好地管理和优化代码。最后，本书以两个实战案例作为结尾：第一个是使用ChatGPT辅助开发PetStore宠物商店项目，第二个是使用ChatGPT辅助开发“我的备忘录”App。这两个实战案例将会帮助读者更好领悟如何将ChatGPT引入具体的软件开发中。
总之，如果您是一位热爱软件开发的程序员，如果您想要拥有新一代智能化的编程方式，这本书将是您必不可少的参考书。
前言/序言： 每一个软件工程师都知道，软件开发是一个漫长而富有挑战性的过程。 需要面对的问题非常复杂，如需求分析、架构设计、代码实现、测试等。 这些任务有时候既烦琐又复杂，对于我们的工作效率和心态来说都是很 大的挑战。 但是，随着科技的发展，人工智能工具正在越来越多地渗透到我们 的生活和工作中。这些工具不但帮助我们节省时间和精力，而且在某些 方面甚至能够替代我们的工作。作为软件工程师，我们是非常幸运的， 因为我们可以利用一种名为ChatGPT的AI工具来加速开发过程。 ChatGPT这个工具“多才多艺”，它可以为我们自动生成流畅的自然 语言，辅助我们在文档编写、需求分析和系统设计等方面更加高效准确 地工作。它甚至可以基于我们的思路自动生成初步的代码框架，这在软 件开发中无疑是一个突破性的进展。当我们意识到使用ChatGPT这种AI 工具会使工作效率大大提高时，感受到的不仅是兴奋，还有愉悦感，因 为它会让我们从烦琐的工作中解脱出来，有更多的时间关注创新和优化 工作的细节。
本书是一本非常有用的指南，它将向我们展示如何利用ChatGPT这 个AI工具，提高工作效率和实现开发目标。在本书的阐述下，我们将学习如何正确地应用这个工具，了解它的系统特点，并通过实战案例来更 加深入地理解如何运用ChatGPT，使我们的开发更加高效。 在软件开发中，我们需要面对无穷无尽的问题和挑战，这也是人类 竞争的本质。作为软件工程师，我们必须始终寻找新的工具和技术，以 更好地处理事情。ChatGPT这个AI工具的出现，不仅是我们的机遇，也 是我们不断前进的动力源泉。越来越多的软件工程师正在掌握这一新技术，在新领域中迎接挑战，并证明我们可以不断地创新和发展。
这本书不仅适合程序员和开发团队，也适合产品经理、项目经理、 技术经理及其他IT行业人员。不论您是什么职位，都可以从本书中获得 很多有价值的知识和工具来提高自己的工作效率。 让我们一起努力，让开发“插上翅膀”，超越自我，不断进步，为科 技进步发挥积极的作用。
本书附赠全书案例源代码及相关教学视频等资源，读者可扫描下方 左侧二维码关注“博雅读书社”微信公众号，输入本书77页的资源下载码， 即可获得本书的下载学习资源。 本书提供答疑服务，可扫描维下方右侧二维码留言“AI程序员”，即 可进入学习交流群。
《AI时代产品经理升级之道：ChatGPT让产品经理插上翅膀》 内容简介： 本书是一本面向产品经理的实用新书，分 12 章系统探讨如何用ChatGPT提升产品管理工作的效率和质量。
第 1 章介绍了人工智能对产品管理的影响；第 2 章介绍用ChatGPT提高文档写作效率；第 3 章介绍用ChatGPT进行竞品和市场分析；第 4 章介绍用ChatGPT优化需求管理；第 5 章介绍用ChatGPT分析产品数据；第 6 章介绍用ChatGPT改进用户体验；第 7 章介绍用ChatGPT设计产品原型；第 8 章介绍用ChatGPT管理产品项目；第 9 章介绍用ChatGPT测试和控制产品质量；第 10 章介绍用ChatGPT发布和运营产品；第 11 章介绍用ChatGPT驱动产品创新；第12 章介绍用ChatGPT维护和支持产品。 通过本书的理论和实践指导，产品经理可以在AI时代，高效利用ChatGPT全流程提升产品管理能力，从而取得
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9099643cdb1004e283c08f5856f8879/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7a2363d77ae363f2a56bb3285359a20/" rel="bookmark">
			使用Java生成图片——功能强大的图形工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言 Java是一种广泛使用的编程语言，它具有强大的功能和卓越的性能，可以用来创建各种类型的应用程序，包括生成图像。在Java中，可以使用Java的内置类库和第三方库来生成图片。下面是一篇关于Java生成图片的介绍文章。
二、具体代码 PrescriptionPictureGenerateUtil.java package com.sinohealth.sdc.ehr.util; import cn.hutool.core.collection.CollectionUtil; import cn.hutool.core.date.DatePattern; import cn.hutool.core.date.DateUtil; import cn.hutool.core.io.FileUtil; import com.google.common.collect.Lists; import com.sinohealth.commons.utils.StringPool; import com.sinohealth.commons.utils.StringUtils; import com.sinohealth.sdc.ehr.dto.PrescriptionInfoDTO; import com.sun.image.codec.jpeg.JPEGCodec; import com.sun.image.codec.jpeg.JPEGEncodeParam; import lombok.Getter; import lombok.Setter; import lombok.extern.slf4j.Slf4j; import org.springframework.core.io.ClassPathResource; import javax.imageio.ImageIO; import java.awt.*; import java.awt.geom.Rectangle2D; import java.awt.image.BufferedImage; import java.io.*; import java.util.List; /** * @Title: PrescriptionPictureGenerateUtil * @Package com.sinohealth.sdc.ehr.util * @Copyright: Copyright (C) SinoHealth Co. Ltd, All Rights Reserved * @Author xiao.xl 2020/9/27 11:53 * @Description: 处方图片生成工具 */ @Slf4j public class PrescriptionPictureGenerateUtil { /** * 签名图片最大宽度 */ private static final int SIGNAL_MAX_WIDTH = 100; /** * 签名图片最大高度 */ private static final int SIGNAL_MAX_HEIGHT = 60; /** * 处方笺图片宽 */ private static final int PIC_WIDTH = 700; /** * 处方笺图片高 */ private static final int PIC_HEIGHT = 1000; /** * 顶部与底部留白 */ private static final int MARGIN_Y = 30; /** * 左右留白 */ private static final int MARGIN_X = 20; /** * 行高 */ private static final int LINE_HEIGHT = 10; /** * 处方笺图片字体 */ private static final String FONT_NAME = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7a2363d77ae363f2a56bb3285359a20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/057589f9412971799a0b968f24c912c9/" rel="bookmark">
			探寻人工智能前沿 迎接AIGC时代——CSIG企业行（附一些好玩的创新点）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上周我有幸参加了由中国图像图形学会和合合信息共同举办的CSIG企业行活动。
这次活动邀请了多位来自图像描述与视觉问答、图文公式识别、自然语言处理、生成式视觉等领域的学者，他们分享了各自的研究成果和经验，并与现场观众进行了深入的交流和探讨。干货多多，感悟多多，在这里分享此次的收获给大家。
一、活动介绍 ✍中国图像图形学学会（China Society of Image and Graphics，CSIG）成立于1990年，是经国家民政部批准成立的国家一级学会，是中国科学技术协会的正式团体会员。它是致力于推进图像图形学领域学科建设、技术研究和学术交流的专业学会。中国图象图形学学会的宗旨是团结广大图象图形科技工作者，积极开展图象图形基础理论和高新技术的研究，促进该学科技术的发展和在国民经济各个领域的推广应用。此次的CSIG企业行-走进合合信息就是学会的重要交流研讨形式之一。
本次活动以“图文智能处理与多场景应用技术展望”为主题，聚集了来自全国知名高校和合合信息技术团队的学者和工程师，一同分享图像文档处理领域的最新研究成果和实践经验。
在当天，来自上海交通大学、厦门大学、复旦大学、中国科学技术大学等知名学府的学者和合合信息技术团队的工程师的分享探讨了图像文档处理中的结构建模、底层视觉技术、跨媒体数据协同应用、生成式人工智能及对话式大型语言模型等多个领域的研究进展和实践成果，下面我选取并总结了会上我最感兴趣，也是当前最热点的几个话题的部分内容，分享给大家：
二、🎉生成式人工智能和元宇宙 2.1、生成式人工智能——未来的战略技术 杨小康教授在现场强调了生成式人工智能的重要性，他指出，生成式人工智能是通过机器学习方法从数据中学习特征，进而生成全新的、原创的数据，预计到2025，生成式人工智能产生的数据将占据人类全部数据的10%。
当生成式数据超过80%的时候，人类是否全面进入元宇宙成为了一个非常值得深思的问题，元宇宙需要生成式人工智能来构建，通过生成式人工智能所生成的数据，元宇宙才能不断地演化和发展。生成式人工智能的发展将推动元宇宙的发展和进化，而元宇宙的不断演化和发展也将进一步促进生成式人工智能技术的创新与进步，两者相互促进、相互依存。这也预示着未来的科技发展将朝着更加智能化、更加普惠化的方向前进。
2.2、生成式世界模型 生成式世界模型是一种基于人工智能的技术，其核心思想是让计算机从输入数据中学习，从而构建出一个全新的、可以被操作的虚拟世界。
生成式世界模型通过学习大量数据中的规律和模式，可以生成全新的、原创的数据，并以此构建出一个与真实世界类似的虚拟世界。这个虚拟世界中的每个元素都是由计算机自主创造的，并且可以被操作、改变、扩展。与传统的计算机模拟不同，生成式世界模型所创造的虚拟世界具有更高的逼真度和互动性，能够提供更加真实的体验。
2.3、生成式虚拟数字人 生成式虚拟数字人是指利用生成式人工智能技术，从真实的人类数据中学习，生成一个虚拟的数字化人类形象，其外貌、言谈举止和行为模式等方面均与真实的人类相似度极高。生成式虚拟数字人的应用领域非常广泛，包括电影、游戏、社交网络、虚拟现实、远程教育、在线客服等诸多领域。
杨教授为我们介绍了许多生成式虚拟数字人的应用。其中包括3D人脸重建、高拟真的表情可驱动数字人技术、语音驱动个性化数字人技术、跨模态驱动等等。
总的来说，生成式虚拟数字人作为生成式人工智能技术的一种应用，将在各个领域发挥越来越重要的作用，未来，随着技术的不断进步和应用场景的不断拓展，生成式虚拟数字人的应用将会更加广泛，也将会呈现出越来越高的技术水平和越来越强的应用能力。
2.4、想法1：生成式人工智能+艺术 这让我联想到目前火热的Midjourney和Dalle等AI作画工具。
绘画艺术是几千年文化的结晶，但是大多数成功的艺术家都有自己独特的绘画风格，利用人工智能研究和模仿这种绘画风格的独特性和绘画技巧，将艺术大师的名画的画风迁移到普通的图片也是一个非常有趣的应用。
利用神经网络进行风格转移，可以实现多种艺术风格的融合。一方面可以实现图像的二次开发，表现出更好的艺术效果。另一方面，可以为设计师提供全新的艺术视角和设计灵感。
目前，基于深度学习的风格迁移主要采用经典的网络结构VGG-Net。
VGG16模型是牛津大学的K.Simonyan和A.Zisserman在论文“Very Deep Convolutional Networks for Large-Scale Image Recognition”中提出的卷积神经网络模型，模型首先输入一个224 x 224像素大小的RGB图像时，经过一系列卷积层，这些卷积层使用非常小的滤波器大小（3x3）以捕捉像素周围的左/右、上/下和中心的特征，在其中一个卷积层配置中，使用1x1的滤波器来进行线性转换，卷积的步幅为1个像素，这样输入图像的填充方式使得在卷积后保留空间分辨率。随后最大池化层用于进一步降低图像的空间维度。
在卷积层和池化层之后，作者还设计了三个全连接层，这些层的结构在所有网络中都相同。前两个全连接层都有4096个节点，第三个全连接层有1000个节点，用于输出1000个类别的概率分布。最后一层是softmax层，用于将全连接层的输出转换为概率值。所有的隐藏层都使用ReLU激活函数，但不包含局部响应归一化（LRN）。
总的来说，VGG16,模型通过用多个 3×3 内核大小的过滤器一个接一个地替换大内核的过滤器（第一和第二卷积层中分别为 11 和 5）来对 AlexNet 进行改进，使得模型具有出色的特征提取能力和较高的精度。
三、✨大型语言模型（类ChatGPT）的关键技术和实现 3.1、ChatGPT的三个关键技术 邱锡鹏教授为我们介绍了目前火热的类ChatGPT的大型语言模型，虽然目前ChatGPT技术细节和模型参数尚未开源，但是它已经展现出惊人的能力，呈现了普适人工智能助手的广阔研究和应用前景。其中，情景学习、思维链和指令学习是其三个最为突出的特点：
情景学习：这是ChatGPT的核心能力之一，它能够从文本中学习出不同上下文之间的关联性，进而在新的情景下产生合理的回复。这种能力不仅需要对语义和逻辑有着深入的理解，还需要对语言的常识和背景知识有所了解。通过对大量数据的训练，ChatGPT能够逐渐提升其情景学习的能力，实现更为自然、准确的对话。
思维链：ChatGPT可以通过建立思维链来理解问题，即将一个问题分解成一系列相关的子问题，并在不同的阶段中进行回答。这种能力使得ChatGPT可以更加深入地理解问题，从而提供更为准确的答案。
指令学习：ChatGPT的另一个重要能力是它可以从指令式的文本中学习出对应的行为，并将其转化为相应的操作。这种能力对于语音助手、机器人等领域具有重要的应用价值。例如，当用户发出“帮我用js代码解决下面这个问题”的指令时，ChatGPT可以理解该指令的含义并将其转化为输出相应的代码，实现与用户的交互。同样，ChatGPT也能够通过大量的数据训练提升其指令学习的能力，进而实现更为准确和智能的指令执行。
3.2、暗知识的理解和应用 ChatGPT只是对话式人工智能领域的一个开始，随着技术的不断发展，人工智能将会更好地理解并应用“暗知识”，即无法直接通过文本获得的知识，比如人类的观察和经验。此外，跨模态学习也是人工智能未来发展的重要方向，通过让机器从多种感知模态（如视觉、听觉、触觉）中进行学习和交互，可以更好地模拟人类的认知过程，实现更加智能化和精准化的应用。
3.3、想法2：任务导向型对话系统+Excel、PPT、PS ChatGPT的下一步发展一方面可能是多模态的运用，另一方面则是任务导向型对话系统。面向任务的对话（TOD）通常被分解为三个子任务:
对话状态跟踪(DST)，用于跟踪用户的信念状态;
对话政策学习(POL)，用于决定采取何种系统行动;
自然语言生成(NLG)，用于生成对话响应
PPTOD模型将不同的对话模块(例如DST、POL和NLG)集成到一个统一的模型中。受上下文内学习概念(Brown et al, 2020)的激励，作者将特定于任务的自然语言指令(称为提示)插入对话上下文作为模型输入来引导模型解决不同的TOD子任务，这种方式上不同子任务的代数是解耦的，使得模型具有更大的灵活性，另外作者还使用T5对由部分注释数据组成的异构对话语料库进行了预训练。
在此基础上，使用任务导向型对话系统操纵Excel、PPT、PS等工具进行任务协作是一个非常值得开发的思路。对于Excel这类数据处理软件，任务导向型对话系统可以通过识别和理解用户输入的数据，自动完成数据处理、图表绘制等操作。对于PPT这类演示软件，任务导向型对话系统可以通过理解用户输入的要求，自动调整PPT页面布局、插入图片、添加动画，使得PPT制作过程变得更加简单和快捷。对于PS这类图像处理软件，任务导向型对话系统可以通过理解用户输入的要求，自动完成图像裁剪、调色、修图等操作，使得图像处理变得更加简单和高效。
四、🎊复杂跨媒体数据协同分析与应用 4.1、视觉--&gt;语言跨媒体分析研究 接下来纪荣嵘教授的主题报告是复杂跨媒体数据协同分析与应用，这也是和文本生成图像的方向息息相关。
视觉-语言跨媒体分析研究是计算机视觉（CV）领域的重要研究方向之一，它将图像和视频中的视觉信息与自然语言中的语义信息相结合，通过计算机算法进行跨媒体的分析和理解。该领域的研究目标是建立视觉与语言之间的联系，实现计算机对图像、视频、语音等多模态数据的深入理解和处理，从而推进人工智能的发展和应用。在视觉-语言跨媒体分析研究中，深度学习技术和生成式模型被广泛应用，例如图文匹配、看图说话、视觉问答、听文作图和指向检测等，为实现智能化应用和人机交互提供了有力支撑。
4.2、语言--&gt;视觉跨媒体分析研究 语言-视觉跨媒体分析研究致力于将自然语言和视觉信息进行融合，实现对多模态数据的分析和理解。例如，通过将图像与相应的文字描述相结合，可以构建图像标注系统，从而提高图像检索的效率。此外，在机器翻译方面，语言--&gt;视觉跨媒体分析研究可以将图像作为上下文信息，辅助翻译系统进行翻译，提高翻译质量。近年来，随着深度学习技术的不断发展，语言--&gt;视觉跨媒体分析研究取得了很大的进展，并在图像检索、机器翻译、视频理解等领域得到了广泛的应用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/057589f9412971799a0b968f24c912c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46119f03272bfb17440fb600e2ed5b47/" rel="bookmark">
			⑧【MySQL】数据库查询：内连接、外连接、自连接、子查询、多表查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人简介：Java领域新星创作者；阿里云技术博主、星级博主、专家博主；正在Java学习的路上摸爬滚打，记录学习的过程~
个人主页：.29.的博客
学习社区：进去逛一逛~
内连接、外连接、自连接、子查询、多表查询 ⑧MySQL数据库查询1. 多表关系2. 多表查询🚀内连接 —— INNER JOIN🚀左外连接 —— LEFT OUTER JOIN🚀右外连接 —— RIGHT OUTER JOIN🚀自连接 —— JOIN🚀联合查询 —— UNION、UNION ALL🚀子查询（嵌套查询） ⑧MySQL数据库查询 1. 多表关系 多表关系：
一对一 ：在任意一方加入外键，关联另一方的主键，并设置外键为唯一（UNIQUE）。一对多（多对一） ：在多的一方建立外键，指向一的一方的主键。多对多 ：建立第三张表作为中间表，中间表至少包含两个外键，分别关联双方主键。 2. 多表查询 多表查询：
在多张表中查询数据。笛卡尔积：两个集合，集合A 与 集合B中元素的所有组合情况，在多表查询时需要使用WHERE关键字或 JOIN ON关键字消除笛卡尔积。 🚀内连接 —— INNER JOIN 连接查询 —— 内连接：
内连接：
①隐式内连接
SELECT 字段列表 FROM 表1,表2 WHERE 连接条件...; ②显示内连接
SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件...; == 内连接查询的是两张表交集的部分 ==
-- 演示： -- 查询员工姓名，以及关联的部门名称（隐式内连接） -- 表：员工表emp、部门表dept SELECT emp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46119f03272bfb17440fb600e2ed5b47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/637a81330795e2dbefb10d8282ac921e/" rel="bookmark">
			浅谈AI人工智能ChatGpt提升竞彩足球分析准确率最高的分析软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着科技的不断进步，人工智能正在扮演着越来越重要的角色。在体育领域，特别是足球竞猜中，AI人工智能ChatGpt正以其卓越的分析能力引起了广泛的关注。作为一款以大数据分析为基础的分析软件，AI人工智能ChatGpt不仅可以提供准确的数据预测，还能帮助用户提高竞彩足球的分析准确率。
AI人工智能ChatGpt：提升竞彩足球分析准确率的最强大脑
传统的足球竞猜往往会受到诸多因素的影响，而AI人工智能ChatGpt则能够通过分析海量的数据，快速准确地预测比赛结果。无论是球队的实力、战术的运用还是球员的状态，ChatGpt都能够凭借其强大的计算能力，对每个因素进行精确的权衡和预测。这使得用户可以更加全面地了解比赛，从而做出更为准确的判断。
AI人工智能ChatGpt的优势之一就是其独特的学习与进化能力。通过不断学习和与用户的交互，ChatGpt能够更好地理解用户的需求，并进行个性化的分析与预测。用户可以通过与ChatGpt的对话，向其提供自己的观点和判断，并得到ChatGpt的及时回应和分析结果。这种交互式的功能不仅提高了用户的参与度，还能够进一步提高准确率。
AI人工智能ChatGpt不仅在分析竞彩足球方面表现优秀，还可应用于其他领域的数据分析。大数据分析已经成为当今社会的一个重要趋势，各个行业都在利用大数据来推动发展。在金融、医疗、市场营销等领域，AI人工智能ChatGpt同样能够发挥出强大的分析能力，为决策提供有力的支持。
总而言之，AI人工智能ChatGpt作为一款以大数据分析为基础的分析软件，通过其强大的脑力和智能化的功能，帮助用户提高竞彩足球的分析准确率。无论是在足球竞猜中还是其他领域的数据分析中，AI人工智能ChatGpt都能够成为您的最强大脑，帮助您做出更为准确的决策。让我们一起迈入人工智能时代，共同享受科技的便利与智慧！
点击查看详细操作教程
操作步骤
1.先登录验证使用权限
2.在数据分析里,复制chatGpt分析模板
3.点击chatGpt分析,粘贴到分析输入框,回车发送复制好的模板
4.等待分析结果
软件截图
案例1、韩K 2023-06-06 15:30 水源FC 1-3 蔚山现代 案例2、何乙 2023-06-07 02:00 阿尔梅城 2-0 埃门 案例就分享到这，凡事没有绝对，如有疑问可联系作者。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/566/">«</a>
	<span class="pagination__item pagination__item--current">567/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/568/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>