<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3eda51d07cc0df9bfb1e9b24dabb3f33/" rel="bookmark">
			Spring AOP（下）原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文我们来学习 Spring AOP 的原理，也就是 Spring 是如何实现 AOP 的。Spring AOP 是基于动态代理来实现 AOP 的；
1. 代理模式 1.1 代理弄模式的定义 代理模式，也叫委托模式。
定义：为其他对象提供一种代理以控制这个对象的访问。它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类间接调用。
某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介作用。
使用代理前：
使用代理后：
就像生活中的例子，生活中的代理类似与艺人经纪人：广告商找艺人拍广告，需要经过经纪人，由经纪人来和艺人沟通。
1.2 代理模式的主要角色： 1、Subject：业务接口类。可以是抽象类或者接口（不一定有）。
2、RealSubject：业务实现类。具体的业务执行，也就是被代理对象。
3、Proxy：代理类。RealSubject的代理。
比如让xox代言：
Subject：小偶像就是提前定义了小偶像要和合作方做的事情，交给经纪人代理处理；
RealSubject：小偶像。
Proxy：经纪人。
UML类图如下：
代理模式可以在不修改被代理对象的基础上，通过扩展代理类，进行一些功能的附加与增强。根据代理的创建时期，代理模式分为静态代理和动态代理。
静态代理：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。
动态代理：在程序运行时，运用反射机制动态创建而成。
2. 静态代理 静态代理：在程序运行前，代理类的 .class文件就已经存在了。（签合约之前，小偶像已经将自己能做到的义务写到了文案里面，就等合约方签字）。
我们通过代码来加深理解。以经纪人为例：
2.1 定义接口 （定义小偶像要接的剧和能参加的活动，也是经纪人需要做的事情）：
public interface Xox { void receiveJuben(); //xox要接受剧本 } 2.2 实现接口 （沈梦瑶要接剧本）： public class ShenMengyao implements Xox{ @Override public void receiveJuben() { System.out.println("我是沈梦瑶，我要接剧本"); } } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3eda51d07cc0df9bfb1e9b24dabb3f33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88f3898fb89b0127f711b574130747ac/" rel="bookmark">
			手撕Python之散列类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.字典 思考：如果有多个数据，例如：“凯子”，“男”，19，如何快速存储这些数据
多数我们是通过列表进行存储的
li=['凯子','男',19]
在定义完这个列表之后我们如何来找到数据'凯子'呢？
我们可以通过索引
print(li[0])
如果将来数据顺序发生改变的话，还能用索引值进行访问吗
答案是不能的
数据顺序发生变化，每个数据的下标也随之变化,如何保证数据顺序变化前后能使用同一种方法查找数据呢？
那么这里就涉及到了字典
字典的定义 定义：{‘键’：'值'，‘键’：'值'}
1.字典的数据，都是以键值对的方式----键和值都要成对出现
2.键值对之间用逗号隔开
字典的定义：
d={'name':'凯子','age':19,'sex':'男'} print(d) #{'name': '凯子', 'age': 19, 'sex': '男'} print(type(d)) #&lt;class 'dict'&gt; 获取字典内值的方式：字典[键]
#上面已经将字典定义好了，但是我们现在怎么进行拿值的操作呢？ #获取值---字典[键]： #序列类型是有顺序的，散列类型是没有顺序的 #字典也是没有顺序的，如果想访问值的话，我们是需要通过键进行获取的 print(d['name']) #凯子 #我们将顺序进行改变的话我们仍然能进行访问 序列类型是有顺序的，散列类型是没有顺序的
字典也是没有顺序的，如果想访问值的话，我们是需要通过键进行获取的
在字典之内不管顺序怎么变我们都能通过键进行访问
字典注意事项 键必须是唯一的
#键必须是唯一的 d={'name': '凯子', 'age': 19, 'sex': '男',"name":"小明"} print(d) #{'name': '小明', 'age': 19, 'sex': '男'} #之前定义的凯子就被这个小明给替换掉了 #如果在字典里面出现重复的键，那么前面的键值对会被后面的键值对给替换掉 ''' 因为我们之前就说明了 在字典中对数值的访问我们只能通过键 那么现在有两个一样的键，那么我们是不知道访问谁的 所以在字典中键必须是唯一的 如果同时出现一样的键，那么前面的键值对会被后面键值对提坏 如果确实要定义两个名字的话，我们可以在name后面加上数字进行区分 ''' 如果在字典里面出现重复的键，那么前面的键值对会被后面的键值对给替换掉
最好的解决方法就是在键后面加上数字进行区分
键值对必须成对出现，不然就会报错
字典中的键，只能是不可以修改的类型（字符串、元组、数字）
所以我们是不能用列表作为键
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88f3898fb89b0127f711b574130747ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbdaf5744ecf1a698fe2e037ab5967fb/" rel="bookmark">
			Git基础教程：掌握版本控制的秘密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈 个人主页：Zfox_
🔥 系列专栏：C++从入门到精通
目录 🚀 什么是Git 🚀 在本系列博客中所实现的目标 一： 🔥 Git 初识 二： 🔥 Git 安装 🍊 Linux-centos🍊 Linux-ubuntu🍊 Windows 三： 🔥 Git 基本操作🍊 创建 Git 本地仓库🍊 配置 Git 四： 🔥 认识⼯作区、暂存区、版本库 五： 🔥 添加⽂件六： 🔥 查看 .git ⽂件 🚀 修改⽂件 七： 🔥 版本回退八： 🔥 撤销修改🍊 情况⼀：对于⼯作区的代码，还没有 add🍊 情况⼆：已经 add ，但没有 commit🍊 情况三：已经 add ，并且也 commit 了 九： 🔥 删除⽂件🚀 共勉 🚀 什么是Git 🥝 Git是目前世界上最先进的分布式版本控制系统。 🚀 在本系列博客中所实现的目标 技术⽬标: 掌握 Git 企业级应⽤，深刻理解Git操作过程与操作原理，理解⼯作区，暂存区，版本库的含义。技术⽬标: 掌握 Git 版本管理，⾃由进⾏版本回退、撤销、修改等Git操作⽅式与背后操作原理 。技术⽬标: 掌握 Git 分⽀管理，从分⽀创建，切换，合并，删除的整个⽣命周期，灵活进⾏各种场景下的分⽀管理，学习常⻅分⽀管理策略。技术⽬标: 掌握 Git 远程仓库与本地仓库，结合版本管理与分⽀管理，做到基于分⽀级的个⼈级开发 。技术⽬标: 理解分布式版本控制系统，学习远程仓库与本地仓库的交互操作，掌握多⼈协作开发模式。协作⽬标：学习企业级常⻅分⽀策略 (master / release / develop / feature / hotfix等)，理解不同公司，不同环境下适合的分⽀模型。结合案例，引⼊⼯程师，测试⼈员，技术经理等⻆⾊，展现项⽬开发过程的全貌，深刻理解开发的整体流程，俯视Git在其中的作⽤。 一： 🔥 Git 初识 💢 提出问题 🥝 不知道你⼯作或学习时，有没有遇到这样的情况：我们在编写各种⽂档时，为了防⽌⽂档丢失，更改失误，失误后能恢复到原来的版本，不得不复制出⼀个副本，⽐如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbdaf5744ecf1a698fe2e037ab5967fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62f328b7d387ad2a7479ea193834a163/" rel="bookmark">
			物联网（IoT）支持的小型水处理厂实时硬件在环（HIL）仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇论文的标题是《Real-Time Hardware-In-The-Loop Simulation of IoT-Enabled Mini Water Treatment Plant》，作者是 Mohamad Taib Miskon 等人，发表在 2024 年 IEEE 自动控制与智能系统国际会议（I2CACIS）上。以下是该论文的主要内容概述：
研究背景：
论文讨论了在马来西亚沙巴州偏远地区，由于地理位置复杂、地形崎岖和交通基础设施不足，传统的供水系统难以覆盖。作为提供清洁水给沙巴州Lok Dangkaan村庄的一部分，本研究开发了一个专门的小型水处理和过滤系统。 硬件在环（HIL）技术：
采用硬件在环（HIL）框架来支持为Lok Dangkaan的小型水处理厂开发电子控制单元（ECU）。HIL技术通过结合实际硬件和系统动态的软件仿真，增强了原型开发过程。 系统设计：
系统由两套设备组成，每套代表目标部署地点的不同水储存罐位置，使用树莓派作为核心嵌入式控制器。采用图形用户界面（GUI）展示当前水位和每个位置泵的激活情况。通过为该地区配置的MQTT协议中继信息。 研究方法：
定义了项目目标，重点是双站点设置：站点1作为收集池塘（罐1），站点2包括过滤系统和储存罐（罐2）。主要目标是建立一个鲁棒的控制器系统，管理两个站点的水过滤系统的所有关键元素，包括泵、指示器、开关、水位传感器、数据记录、远程监控和水使用量调节。 硬件和软件开发：
电子控制单元（ECU）包括控制面板、树莓派、接触器继电器、灯指示器、选择开关和Arduino Nano。HIL部分包括嵌入在Arduino Nano中的水箱填充模型。 GUI开发：
使用开源软件Node-RED开发了GUI，使用SVG图形，每个元素都有其独特的ID。 实验结果：
功能性测试旨在评估系统的操作能力和响应性，包括所有主要功能，从手动控制到界面交互和连接协议。测试结果表明，系统的所有测试项都表现出令人满意的性能，包括手动启动/停止操作、通过GUI的启动/停止操作、GUI的响应性和更新、灯指示器、MQTT连接、低水位指示器和溢流指示器。 结论：
研究工作对于实施定制的HIL仿真，针对偏远地区的小型水过滤系统具有重要意义，这些地区的传统供水服务无法到达。功能性测试证实了HIL设置的输入/输出罐仿真的系统操作有效性，所有测试项都显示出令人满意的性能。论文提出，未来的工作可以集中在提高GUI的响应性，以提供更无缝的用户体验，并探索集成高级诊断功能和机器学习能力，以实现泵操作的预测性维护、预测村庄的水使用情况以增强水管理，并减少中断或短缺的可能性。 致谢：
作者感谢UiTM Terengganu提供测试原型所需的实验室设施，以及马来西亚财政部下属的Unit Pelaksanaan dan Koordinasi Stimulus Ekonomi Antara Agensi Nasional (LAKSANA) 和沙巴州Baitulmal Negeri Sabah (PBNS)在资金计划下对这项工作的支持。 论文详细介绍了一种实时HIL仿真系统，用于物联网（IoT）支持的小型水处理厂，强调了在实际部署前进行预部署验证和可靠性评估的重要性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a498ae1c3daeaebfa63db10f3e27a3e/" rel="bookmark">
			文件包含PHP伪协议利用方法 本地复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境配置 步骤一：更改参数
php.ini ⾥有两个重要的参数 allow_url_fopen 、allow_url_include 步骤二：创建123.php文件输入一句话木马 步骤三：创建1.php less-1 file://协议 123.php?cmd=file://D:\phpstudy_pro\WWW\1.php less-2 php://filter协议 base解码 less-3 php://input协议 123.php?cmd=php://input利用burp抓包 更改传参方式 更改参数进行放包 less-4 data:// 123.php?cmd=data:text/plain,&lt;?php phpinfo();?&gt;
less-5 zip:// 创建2.txt文件进行压缩
123.php?cmd=zip://D:\phpstudy_pro\WWW\2.zip%232.txt
less-6 phar:// 123.php?cmd=phar://D:\phpstudy_pro\WWW\2.zip\2.txt
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/969728255e03e2a292cb659bc2ee2c87/" rel="bookmark">
			npm、yarn、pnpm小节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Npm 嵌套依赖： 老版本npm@3之前由于依赖嵌套下载，所以存在重复下载包导致体积过大以及嵌套路径字符过长的问题，后通过类似yarn扁平化提升依赖，将node_modules所有包放在同一层级解决(对于同一个包的不同版本，只会提升一个版本包（根据package.json中的引入先后位置），其他的仍然在嵌套的node_modules下)，这样又引入了一个问题？ 不同引入先后位置导致扁平化结果的不确定性，所以有了yarn.lock\package.lock来固定依赖版本，但是仍然存在不同版本的包。 Yarn： ● 扁平化处理 - npm@3
幽灵依赖： 很容易出现包管理问题。由于扁平化处理，会将依赖提升到同一级，即子依赖包也会提升到项目的node_modules下，就出现了在项目的package.json没有引入该依赖，但是能在项目中引入该包。比如项目依赖A，而A依赖B，扁平化处理之后A、B都在node_modules下，所以在项目中就能直接使用B，即使没有在package中引入。如果在项目中使用了B，后续又去掉了A就导致无法找到B而报错。 ● 离线缓存
● 并行下载依赖包，比npm快
Pnpm 主要是将所有依赖下载到pnpm-store中心仓库，然后在node_modules下创建一个pnpm的文件夹利用软硬连接来将项目中的依赖连接到中心仓库的依赖包，以此来复用，避免重新下载包，减少了磁盘空间
题外话 npm run xxx 或者 npx xxx其实都是使用node执行的node_modules下.bin文件夹下的可执行文件，手动通过node ./node_modules/.bin/xxx 也可以启动，项目目录中node_modules没有就会去全局的node目录的node_modules下查找，没有则报错command is not found。 【npm run xxx之后发送了什么？】
ps: 常说的npm全局安装依赖和局部安装，如果-g就是全局安装，即安装在node的目录的node_modules下(mac: 默认路径是 /usr/local/lib/node_modules,如果使用nvm来管理则在nvm目录中)，局部安装就是在项目自身的node_modules下安装。
参考资料：
PNPM vs NPM vs YARN
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a15fb967563a5d0578468b97b8a62b3/" rel="bookmark">
			Java 面向对象编程基础详解（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、面向对象编程概述
（一）面向对象编程的特点
（二）Java 中的面向对象编程元素
二、类和对象
（一）类的设计
（二）类的实例化
（三）面向对象完成具体功能的操作三步骤
三、内存解析
（一）对象在内存中的分配
（二）类中对象的内存解析
四、成员变量和局部变量
（一）变量的分类
（二）相同点
（三）不同点
五、方法
（一）使用方法的好处
（二）使用举例
（三）声明举例
（四）方法声明的细节
（五）形参和实参
六、补充知识点和案例
（一）面向对象编程的优势
（二）案例：汽车类的设计
一、面向对象编程概述 面向对象编程（Object-Oriented Programming，OOP）是一种编程范式，与面向过程编程（Procedure-Oriented Programming，POP）相对。Java 是一种完全面向对象的编程语言，其核心是类和对象。
（一）面向对象编程的特点 封装：将数据和操作封装在类中，通过访问修饰符控制对数据的访问。继承：子类继承父类的属性和方法，实现代码复用。多态：同一操作作用于不同的对象可以有不同的表现形式。 （二）Java 中的面向对象编程元素 类及类的成员：属性（成员变量）、方法、构造器、代码块、内部类。关键字：this、super、package、import、static、final、interface 等。 二、类和对象 类是属性和行为的集合，对象是类的实例化。
（一）类的设计 属性：该类事物的状态信息，对应类中的成员变量。行为：该类事物要做的操作，对应类中的成员方法。 （二）类的实例化 格式：类类型 对象名 = new 创建的对象实体。例如：Phone p1 = new Phone();。
（三）面向对象完成具体功能的操作三步骤 创建类，设计类的内部成员（属性和方法）。创建类的对象。通过对象，调用其内部声明的属性和方法，完成相关的功能。 三、内存解析 （一）对象在内存中的分配 涉及到的内存结构有栈、堆和方法区。
栈：存储方法内定义的变量。堆：存储 new 出来的对象实体，包括对象的属性。方法区：存放类的模板。 （二）类中对象的内存解析 创建一个类的对象：只要没有 new 就是没有开创内存空间。创建多个对象：每个对象都在堆中占据独立的空间，拥有自己的属性副本。 四、成员变量和局部变量 （一）变量的分类 按照数据类型：基本数据类型和引用数据类型。按照在类中声明的位置：成员变量（属性）和局部变量（方法内声明的变量）。 （二）相同点 声明的格式相同：数据类型 变量名 = 变量值。变量都有其作用域。变量必须先声明再赋值后使用。 （三）不同点 类中声明的位置不同： 属性：声明在类内，方法外的变量。局部变量：声明在方法、构造器内部的变量。在内存中分配的位置不同： 属性：随着对象的创建，存储在堆中。局部变量：存储在栈空间中。生命周期不同： 属性：随着对象的创建而创建，随着对象的消失而消失。局部变量：随着方法对应的栈帧入栈，局部变量会在栈中分配。随着方法对应的栈帧出栈，局部变量消亡。作用域不同： 属性：在整个类中有效。局部变量：仅仅限于局部变量所在的方法中。是否可以有权限修饰符进行修饰： 属性是可以的，局部变量是不可以的。是否有默认值： 属性都有默认值。局部变量都没有默认初始化值。 五、方法 （一）使用方法的好处 方法是类或对象行为特征的抽象，用来完成某个功能操作。将功能封装为方法的目的是可以实现代码重用，减少代码冗余。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a15fb967563a5d0578468b97b8a62b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1e1d8da1c99c246b187626181c5391a/" rel="bookmark">
			【Hadoop|HDFS篇】HDFS概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. HDFS产出背景及定义 1.1 HDFS产生背景 随着数据量越来越大，在一个操作系统存不下所有的数据，那么就分配到更多的操作系
统管理的磁盘中，但是不方便管理和维护，迫切需要一种系统来管理多台机器上的文件，这
就是分布式文件管理系统。HDFS只是分布式文件管理系统中的一种。
1.2 HDFS 定义 HDFS(Hadoop Distributed File System)，它是一个文件系统，用于存储文件，通过目
录树来定位文件;其次，它是分布式的，由很多服务器联合起来实现其功能，集群中的服务
器有各自的角色。
HDFS 的使用场景:适合一次写入，多次读出的场景。一个文件经过创建、写入和关闭
之后就不需要改变。
2. HDFS的优缺点 2.1 HDFS的优点 高容错性：
数据自动保存多个副本。它可以通过增加副本的形式，提高容错率。某个副本丢失后，它可以自动恢复。 适合处理大数据：
数据规模：能够处理数据规模达到GB，TB，甚至是PB级别的数据。文件规模：能够处理百万规模以上的文件数量，数量相当之大。 可构建在廉价的机器上，通过多副本机制，提高可靠性。
2.2 HDFS的缺点 1) 不适合低延时数据访问，比如毫秒级的存储数据，是做不到的。
2) 无法高效的对大量小文件进行存储。
存储大量小文件的话，它会占用NameNode大量的内存来存储文件目录和块信息。这样是不可取的，因为NameNode的内存总是有限的;小文件存储的寻址时间会超过读取时间，它违反了HDFS的设计目标。 3) 不支持并发写入、文件随机修改。
一个文件只能有一个写，不允许多个线程同时写，仅支持数据append(追加)，不支持文件的随机修改 3. HDFS的组成架构 1）NameNode(nn)：就是master，它是一个主管，管理者。
管理HDFS的名称空间。配置副本策略。管理数据块（Block）的映射信息。处理客户端读写请求。 2）DateNode：就是slave。NameNode下达命令，DateNode执行操作。
存储实际的数据块。执行数据块的读写操作。 3）Client：就是客户端。
文件切分。文件上传HDFS的时候，Client将文件切分成一个一个的Block，然后进行上传。与NameNode交互，获取文件的位置信息。与DataNode交互，读取或写入数据。Client提供一些命令来管理HDFS，比如NameNode的格式化。Client可以通过一些命令来访问HDFS，比如对HDFS的增删改查。 4）Secondary NameNode：并非NameNode热备。当NameNode挂掉的时候，并不能马上替换NameNode并提供服务。
辅助NameNode，分担其工作量，比如定期合并Fsimage和Edits，并推送给NameNode。在紧急情况下，可辅助恢复NameNode。 4. HDFS文件块大小 HDFS中的文件在物理上是分块存储（Block），块的大小可以通过配置参数（dfs blocksize）来规定，默认大小在Hadoop3.x/2.x版本是128M，1.x版本是64M.
为什么块的大小不能设置太大，也不能设置太小。
（1）HDFS的块设置太小，会增加寻址时间，程序一直在找块的开始位置。
（2）如果块设置的太大，从磁盘传输数据的时间会明显大于定位这个块开始位置所需的时间。导致程序在处理这块数据的时候，会非常慢。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d89c1be744e3d7d6b1bdaef32c31a3a/" rel="bookmark">
			python---爬取QQ音乐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如Cookie为非vip，仅能获取非vip歌曲 1.下载包 pip install jsonpath 2.代码 import os import time import requests from jsonpath import jsonpath def search_and_download_qq_music(query_text): headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.0.0 Safari/537.36 Edg/128.0.0.0', 'Cookie': 'you cookie here' } # 请求的链接 # query_text = 'Black Myth wukong' search_url = rf'https://u.y.qq.com/cgi-bin/musicu.fcg?data={{"comm":{{"g_tk":235530277,"uin":"1152921504916411742","format":"json","inCharset":"utf-8","outCharset":"utf-8","notice":0,"platform":"h5","needNewCode":1,"ct":23,"cv":0}},"req_0":{{"method":"DoSearchForQQMusicDesktop","module":"music.search.SearchCgiService","param":{{"remoteplace":"txt.mqq.all","searchid":"64237725668973550","search_type":0,"query":"{query_text}","page_num":1,"num_per_page":20}}}}}}' response = requests.get(search_url) music_list = jsonpath(response.json(), '$..data.body.song.list')[0] # print(f'music_list: {music_list}') if not os.path.exists('Q Music'): os.mkdir('Q Music') for item in music_list: music_mid = jsonpath(item, '$.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d89c1be744e3d7d6b1bdaef32c31a3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86f0846243bd55464f390b7d898261b7/" rel="bookmark">
			从手控到声控，NRK3502离线语音芯片赋能智能风扇解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这个智能家居时代，我们重新定义了“清凉”的含义。九芯作为智能语音识别领域的领航者，推出搭载NRK3502系列芯片的智能风扇解决方案，旨在以离线语音控制技术创新风扇操作体验，让用户享受更加智能、便捷、个性化的凉爽。
九芯NRK3502语音识别芯片是一款适用于智能风扇的蓝牙双模智能语音IoT芯片，具备高性能的32位CPU处理器，内置SRAM和FLASH存储，支持UART、GPIO、SPI、SD卡、I²C、ADC、TouchSensor等外围接口，以及集成NPU和浮点运算单元。‌
这款芯片采用MCU加语音识别专用NPU架构内核，支持50条本地指令离线3-5米远场识别，并兼容RTOS轻量级系统。NRK3502芯片的设计支持简洁友好的客制化工具，可快速部署到不同的终端产品上，为智能风扇提供了高效、便捷的语音控制解决方案。
此外，该芯片还支持蓝牙V5.1+BR+EDR+BLE，具有Class1、2、3发送功率，提供增强型动态范围，支持多种包型和发射功率，确保了智能风扇在连接和通信方面的稳定性和效率‌。
同时，NRK3502系列的语音芯片具有广泛的应用场景，例如：智能家电、智能家居、智能玩具、无线音视频、工业控制、医疗监护等广泛的物联网领域。这些应用场景不仅展现了芯片的多功能性，更预示着其在未来智能生活中的无限潜力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e860cf2cefeba8b6cc4521177fa5f15e/" rel="bookmark">
			rabbitmq高可用集群搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求分析基本情况 在进行RabbitMQ搭建时，我们基于现有的连接数据和业务需求进行了深入分析。目前的统计数据显示，连接数为631，队列数为80418。为了确保业务需求的顺利满足，我们需要在云产品和自建RabbitMQ消息队列服务之间做出选择。
经过比较发现，即使选择腾讯云的最高规格配置，其Queue数也难以满足我们的需求，并且成本相对较高。因此，我们决定搭建自建服务。为此，计划使用三台配置为8核 16GB 100GB 5Mbps / 标准型SA5的服务器节点，构建一个高可靠性集群，以确保系统的稳定性和可靠性。
腾讯云:
节点规格2核4G4核12G8核24G16核32G消息 TPS(生产+消费)600~10002100~35004200~70009000~15000最大queue数量100200300800最大连接数500250040008000费用/月20283537693013434 自建服务:
序号节点1节点2节点3费用/月业务新选型8核 16GB 100GB 5Mbps /标准型SA58核 16GB 100GB 5Mbps /标准型SA58核 16GB 100GB 5Mbps /标准型SA52485.2 需求变动:
前期功能业务体谅小基于目前的现状考虑，并且不影响未来的扩容的情况下的方案节点规格收容 4核8G内150GB硬(50G系统盘+100G数据盘)/标准型SA5,以及搭建实现和优化需求：
1、 集群建设
2、 实现高可用
3、 节点只运行rabbitmq,所以内存阀值调制总在比的70%
rabbimtmq集群搭建 系统均使用CentOS7.9
节点名称节点IPrabbitmq版本docker/compose规格数据盘pos_rabbitmq_1172.17.80.273.8-manageme18.03.1/1.29.24核8G50GB100GBpos_rabbitmq_2172.17.80.323.8-manageme18.03.1/1.29.24核8G50GB100GBpos_rabbitmq_1172.17.80.63.8-manageme18.03.1/1.29.24核8G50GB100GB 腾讯云申请三台实例节点 初始化三台实例主机 hostnamectl set-hostname POS_Rabbitmq_1 bash init.sh init.sh 脚步内容,腾讯云内置了自己的yum源,可以不需要替换
yum clean all &amp;&amp; yum makecache yum install telnet curl wget lrzsz net-tools vim unzip zip htop tree -y echo "=====系统环境初始化脚本=====" echo "1.关闭防火墙与SELinux" systemctl stop firewalld systemctl disable firewalld setenforce 0 sed -i '/SELINUX/{s/enforcing/disabled/}' /etc/selinux/config echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e860cf2cefeba8b6cc4521177fa5f15e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4098edd79ab89776c8b0198a8b6c1954/" rel="bookmark">
			Faiss向量数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Faiss（Facebook AI Similarity Search）向量数据库是由Facebook AI研究院开发的一种高效相似性搜索和聚类的库。Faiss不仅支持在高维空间中进行高效的相似性搜索，还能够在处理大规模数据集时展现出卓越的性能，尤其适用于图像检索、文本搜索、推荐系统和语音处理等多种应用场景。 在推荐系统中，Faiss可以用于快速查找用户可能感兴趣的物品或寻找具有相似兴趣的用户。 在信息检索领域，Faiss可以用于构建文档或图像的相似性搜索引擎。在图像识别领域，Faiss可以用于构建图像特征的索引，实现快速的相似图像搜索和图像聚类。 安装Faiss： 💢cpu版本：
conda install -c pytorch faiss-cpu 💢gpu版本：
conda install -c pytorch faiss-gpu Faiss 处理固定维数 d 的向量集合，通常为几十到几百个。这些集合可以存储在矩阵中。我们假设采用行主存储，即向量编号 i 的第 j 个分量存储在矩阵的第 i 行、第 j 列中。Faiss 仅使用 32 位浮点矩阵。
import numpy as np d = 64 # 设置向量的维度为64 nb = 100000 # 向量数量为100,000 nq = 10000 # 查询向量的数量为10,000 np.random.seed(1234) # make reproducible xb = np.random.random((nb, d)).astype('float32') xb[:, 0] += np.arange(nb) / 1000. xq = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4098edd79ab89776c8b0198a8b6c1954/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0047d9d8655bddf3d1add17133bbc53/" rel="bookmark">
			【Linux】使用Linux实现小程序 - 进度条
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、缓冲区二、回车换行的概念三、进度条的设计3.1 版本1（没有配合场景）3.2 版本2（配合场景）3.3 版本3（美化进度条） 结尾 一、缓冲区 C/C++语言，会针对标准输出，给我们提供默认的缓冲区，这里主要讲输出缓冲区，那么它在哪里呢？
在C语言中，输出缓冲区通常与标准I/O流（如stdout、stderr等）相关联。这些流在C标准库中通过FILE结构体来表示，而FILE结构体内部封装了文件描述符和缓冲区等信息。因此，当使用printf()等函数进行输出时，实际上是将数据写入到了与stdout流相关联的缓冲区中。
那么需要怎么证明呢？
当我们没有使用fflush刷新缓冲区时，printf()函数早已运行了，但是数据却没有立马显示出来，而是暂停了两秒钟才显示出来，因为printf()函数输出的数据在缓冲区中，所以没有立马显示出来，当暂停两秒钟后，程序结束，强制刷新缓冲区，才将缓冲区的内容输出。
那么有人也会问了，当我们使用 printf()函数输出数据时添加\n，也能立马输出数据这是为什么？
因为/n也是一种刷新策略，/n也叫做行刷新。
二、回车换行的概念 在这里向大家提一个问题，大家是否认为回车和换行是一个东西，其实不然，回车和换行是两个不同的概念，回车是将光标移回当前行的第一个位置，换行是将光标的位置移动到下一行，但光标的位置并不会移回行的第一个位置。
在老式键盘中的回车换行也是比较形象的体现了回车和换行的特征。
那么我们在敲代码使用的 /r 和 /n 分别是什么呢？
- /r 是回车，光标仅仅回到当前行的第一个位置。
- /n 是回车换行，光标即移回行的第一个位置，又移动到下一行。
那么下面写一份代码，除/r 和 /n不同外其他部分全部相同，来看看程序的结果分别是什么。
我们通过上面的图片可以看到使用/n时，每一秒钟在下一行输出一个数字
而使用/r时，每一秒钟在当前行输出一个数字，并且覆盖上一个字符，最终被命令行覆盖，但是当循环时强制刷新缓冲区就可以把最后一个数字留下来，通过/r的这个特性，那么我们就可以设计倒计时，进度等。
三、进度条的设计 3.1 版本1（没有配合场景） 进度条效果图
// process.c #include"process.h" const char rotate[]={"|/-\\"}; void process() { char arr[SIZE] = {0}; int rate = 0; int len = strlen(rotate); while(rate &lt;= MAX_RATE) { printf("[%-100s][%3d%%][%c]\r",arr,rate,rotate[rate%len]); usleep(STIME); arr[rate++]=STYLE; } printf("\n"); } //	process.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0047d9d8655bddf3d1add17133bbc53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a86ce0c408bc2420fcfb4a5d42b425d6/" rel="bookmark">
			vscode终端执行npm指令时报错:无法加载文件 D:\nodejs\npm-check.ps1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题
解决 1.输入get-ExecutionPolicy得到Restricted
2. 执行命令Set-ExecutionPolicy -Scope CurrentUser并输入RemoteSigned
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e671a7f1de19617dd4d530b3a1bea31b/" rel="bookmark">
			场外个股期权的风险有哪些方面？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天带你了解场外个股期权的风险有哪些方面？场外个股期权虽然提供了高度的灵活性和定制性，但也伴随着一些风险。
场外个股期权风险 1.对手方信用风险：由于场外交易不通过中央清算机构，因此每个参与方都面临对方可能无法履约的风险。
2.流动性风险：场外个股期权可能不如交易所交易的期权那样流通，这可能导致在需要时难以快速平仓或退出。
3.定价透明度：场外市场的定价可能不如交易所市场透明，这可能导致定价不公或误差。
4.法律和监管风险：场外市场的监管可能不如交易所严格，这可能导致法律和合规风险。
5.市场风险：与所有金融工具一样，市场条件的变化可能导致投资损失。
6.复杂性风险：由于场外个股期权可以高度定制，其复杂性可能导致理解和管理上的困难，增加操作风险。
如何管理场外个股期权风险 风险对冲与套期保值 运用期货、远期、互换等衍生工具，对场外期权的风险敞口进行对冲，降低市场风险。
根据投资组合的风险状况，选择合适的对冲工具和策略，如 Delta 对冲、Gamma 对冲、Vega 对冲等。
风险限额设置 根据自身的风险承受能力和资本实力，设定交易规模、风险敞口、止损限额等指标。
对单个交易对手、单个标的资产、单个行业等设置风险限额，避免过度集中风险。
当交易达到风险限额时，及时停止交易或采取对冲措施，以控制风险的进一步扩大。
以上就是“场外个股期权的风险有哪些方面？”的全部内容，希望本文能给您带来帮助，在未来市场交易中收获满满，财源广进！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a259bdcabc25a460a956a18417205da9/" rel="bookmark">
			Scala与Spark：中英文非扫描版程序设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文还有配套的精品资源，点击获取 简介：Scala结合面向对象和函数式编程，广泛用于大数据和分布式计算，尤其在Spark框架中，因为其高效性能和并行处理能力。提供的资源涵盖了Scala的基础与进阶知识，以及Spark编程的核心概念，如RDD、DataFrame、DataSet和Spark SQL。同时，介绍了Scala的并发模型、Actor模型、Futures和Promises等，并行编程工具。PDF文件包含详细的Scala语法、核心概念，以及在Spark上构建并行应用程序的教程。掌握Scala和Spark将增强处理大数据和并行计算的专业技能。 1. Scala编程语言介绍 Scala是一种多范式的编程语言，旨在以简洁、优雅的方式融合面向对象和函数式编程的概念。自从2003年发布以来，Scala因其在JVM（Java虚拟机）上的强大表现，以及与Java生态系统的无缝集成而受到了广泛关注。Scala的核心设计哲学是表达力和静态类型的安全性，它允许开发者以更少的代码量表达复杂的逻辑。本章将从Scala的基本语法开始，向读者展示如何快速开始使用Scala，并理解其在现代软件开发中的重要性。我们将探讨Scala的一些基础特性，例如类型推断、模式匹配以及集合API，这些都是学习Scala必须掌握的基础知识。 // 示例代码：一个简单的Scala程序 object HelloWorld { def main(args: Array[String]): Unit = { println("Hello, world!") } } 在上述代码中，我们定义了一个 HelloWorld 对象，其中包含了程序的入口点 main 方法。这是每个Scala程序的基本组成部分。接下来，我们将详细探讨Scala的语法和结构，为深入学习Scala编程语言打下坚实的基础。 2. Scala面向对象和函数式特性 2.1 Scala的面向对象特性 2.1.1 类和对象的概念 Scala中的类（Class）是定义对象的蓝图，它定义了对象的状态和行为。Scala中使用关键字 class 来定义一个类。对象（Object）是类的实例，每个对象都有自己的状态，但行为（方法）是一致的。在Scala中，对象也被视为一等公民，可以赋值给变量，作为函数参数或返回值。 一个基本的Scala类定义如下： class Person(val name: String, val age: Int) { def greet(): Unit = { println(s"Hello, my name is $name and I am $age years old.") } } 在这个例子中， Person 类有两个属性： name 和 age 。这些属性由构造器参数定义，并且被标记为 val ，意味着它们是不可变的。 greet 方法是一个类的行为，它打印出一个欢迎信息。 创建一个 Person 类的实例，并调用其方法的示例代码如下： val person = new Person("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a259bdcabc25a460a956a18417205da9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa21773e48d1d4d5700e0700a9b9c25a/" rel="bookmark">
			第六届机器学习、大数据与商务智能国际会议（MLBDBI 2024）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
主办单位
大会简介 会议组委会
征稿主题
参会方式
会议日程
重要信息
大会官网：www.mlbdbi.org
会议时间：2024年11月1-3日
会议地点：中国-杭州
收录检索：EI Compendex，Scopus
主办单位 大会简介 由浙江财经大学信息技术与人工智能学院主办的第六届机器学习、大数据与商务智能国际会议（MLBDBI 2024）将于2024年11月1-3日在中国浙江杭州召开。MLBDBI 2024将围绕“机器学习”、"大数据”、“商务智能”等最新研究领域，为来自国内外高等院校、科学研究所、企事业单位的专家、教授、学者、工程师等提供一个分享专业经验，扩大专业网络，面对面交流新思想以及展示研究成果的国际平台，探讨本领域发展所面临的关键性挑战问题和研究方向，以期推动该领域理论、技术在高校和企业的发展和应用，也为参会者建立业务或研究上的联系以及寻找未来事业上的全球合作伙伴。 会议组委会 大会主席 TPC主席 组织委员会主席 出版主席 宣传主席
征稿主题 机器学习 大数据 商务智能 深入和强化学习
网络的模式识别和分类
用于网络切片优化的机器学习
机器学习5G系统
用于用户行为预测的机器学习
新的创新机器学习方法
优化机器学习方法
机器学习算法的性能分析
机器学习的实验评估
异构网络中的数据挖掘
机器学习多媒体
物联网机器学习
机器学习的安全和保护
分布式和分散式机器学习算法等
大数据分析
数据科学模型和方法
大数据的算法
大数据搜索和信息检索技术
大数据采集，集成，清洁和最佳实践
大数据和深度学习
可扩展的计算模型，理论和算法
用于大数据分析的内存系统和平台
大数据和高性能计算
大数据的网络基础设施
大数据系统的绩效评估报告
大数据系统的资源管理方法
物联网大数据应用
大数据的移动应用
智能城市的大数据应用
大数据系统的可扩展性
大数据隐私和安全等
智能计算方法和应用
进化计算和学习
群体智能与优化
信号处理和模式识别
图像处理与信息安全
虚拟现实与人机交互
商业智能和多媒体技术
医疗保健信息学理论与方法
自然语言处理与计算语言学
机器人智能计算
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa21773e48d1d4d5700e0700a9b9c25a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bedafadf40172ea15a71b9d4fa1c8341/" rel="bookmark">
			AWS EC2安全组配置:轻松开放端口访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在AWS EC2实例上开放特定端口是配置服务器安全性和可访问性的重要步骤。本文中九河云将介绍如何通过AWS控制台配置EC2安全组来实现端口开放。
1. 登录AWS控制台
首先,登录到AWS管理控制台,并导航到EC2服务页面。
2. 找到目标EC2实例
在EC2控制面板中,找到需要开放端口的实例,并记下其安全组ID。
3. 配置安全组
点击左侧导航栏中的"安全组",找到对应实例的安全组。选择该安全组,点击"编辑入站规则"。
4. 添加新规则
在编辑入站规则页面,点击"添加规则"。选择要开放的协议类型(如TCP、UDP等),输入端口号,然后在来源处选择允许访问的IP范围。
5. 保存更改 添加完所需的规则后,点击"保存规则"以应用更改。
6. 验证端口开放
使用telnet或其他网络工具测试端口是否成功开放。
注意事项:
- 只开放必要的端口,遵循最小权限原则
- 定期审核安全组规则,及时关闭不再使用的端口
- 考虑使用更精细的IP限制,而不是对所有IP开放
通过以上步骤,您可以轻松管理EC2实例的端口访问,既保证了服务的可用性。记住,定期检查和更新安全组配置是保持EC2实例安全的关键。
想要了解更多的AWS云领域知识请关注九河云。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af7fa82df60901ac310ff62f076b5eb8/" rel="bookmark">
			工业网关在汽车智能工厂中的应用-天拓四方
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工业网关是工业物联网（IIoT）的关键组成部分，它充当了工业现场设备与云端或企业级系统之间的桥梁。在智能工厂中，工业网关的应用至关重要，它确保了生产线的顺畅运行，并通过数据的透明化，提升了生产效率和安全性。以下是一个具体案例，展示了工业网关在汽车制造企业智能工厂中的深度应用。
案例背景：某汽车制造企业为了提升生产线的自动化水平和响应市场变化的能力，决定采用工业物联网技术对工厂进行智能化改造。改造的核心是部署工业网关，以实现设备数据的透明化和生产过程的优化。
设备集成与数据采集：智能工厂中存在多种设备和系统，如PLC、CNC、机器人、传感器等。工业网关通过支持多种工业协议（如Modbus、Profinet、EtherCAT等）和通信接口（如以太网、串口、无线等），实现了对这些设备的快速集成和数据的高效采集。
协议转换与数据传输：工业网关负责将不同设备的数据转换为统一的通信协议，以便于数据的传输和处理。同时，工业网关还可以根据需要对数据进行压缩和加密，确保数据的安全性和传输效率。
生产监控与数据记录：通过工业网关，工厂的操作人员可以在控制室实时监控生产线的状态，获取设备的运行数据和生产数据。这些数据被记录下来，为后续的分析和优化提供依据。
云集成与远程访问：工业网关可以与企业的云平台或企业资源规划（ERP）系统无缝集成，使得管理层可以远程访问和分析生产数据，做出更加精准的业务决策。这种集成也支持了远程设备维护和软件更新，进一步提升了运营效率。
安全性与可靠性：工业网关通常设计有高级别的安全特性，如数据加密、防火墙、访问控制等，以确保数据的安全传输和系统的稳定运行。在智能工厂中，工业网关的这些特性对于防止网络攻击和保护关键生产数据至关重要。
总结：
工业网关在智能工厂中的应用是多方面的，它确保了生产线的稳定运行和设备的有效管理，通过数据的透明化，为企业带来了显著的生产效率和成本节约。随着工业4.0的持续推进，工业网关将继续在智能制造、远程运维、预测性维护等领域发挥关键作用，成为企业数字化转型的核心推动力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4614333f21e2ee7b00e6a87aa5ff88ad/" rel="bookmark">
			【Java 基础】：三大特征之多态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨ 杏花疏影里，吹笛到天明 🌏 📃个人主页：island1314
🔥个人专栏：java学习
⛺️ 欢迎关注：👍点赞 👂🏽留言 😍收藏 💞 💞 💞
🚀引言 在前两篇博客中，我们已经讲完了面向对象程序三大特性之一的封装、继承，
【Java 基础】类和对象（构造&amp;this&amp;封装&amp;static&amp;代码块）-CSDN博客
【Java 基础】三大特征之继承-CSDN博客
下面让我们来看看多态有哪些内容吧
1. 多态概念 💢💢在Java中，多态是面向对象编程中的一个重要概念，它允许不同类型的对象对同一方法进行不同的实现。具体来说，多态性指的是通过父类的引用变量来引用子类的对象，从而实现对不同对象的统一操作。
多态是方法或对象具有多种形态，是面向对象的第三大特征。多态的前提是两个对象（类）存在继承关系，多态是建立在封装和继承基础之上的。 2. 多态实现条件 在Java中，要实现多态性，就必须满足以下条件：
继承关系
存在继承关系的类之间才能够使用多态性。多态性通常通过一个父类用变量引用子类对象来实现。
方法重写
子类必须重写（Override）父类的方法。通过在子类中重新定义和实现父类的方法，可以根据子类的特点行为改变这个方法的行为，如猫和狗吃东西的独特行为。
父类引用指向子类对象
使用父类的引用变量来引用子类对象。这样可以实现对不同类型的对象的统一操作，而具体调用哪个子类的方法会在运行时多态决定
例如，下面的案例是根据猫和狗吃东西动作的不同，而实现的多态：
class Animal { public void eat() { System.out.println("动物吃东西"); } } class Dog extends Animal { @Override public void eat() { System.out.println("狗吃狗粮"); } } class Cat extends Animal { @Override public void eat() { System.out.println("猫吃猫粮"); } } public class Test { public static void main(String[] args) { Animal animal1 = new Dog(); // 父类引用指向子类对象 Animal animal2 = new Cat(); // 父类引用指向子类对象 animal1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4614333f21e2ee7b00e6a87aa5ff88ad/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/6/">«</a>
	<span class="pagination__item pagination__item--current">7/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/8/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>