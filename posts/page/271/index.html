<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf22d1abdab36c5f48a3c02f6626236b/" rel="bookmark">
			Mac 下载并激活IDEA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.https://3.jetbra.in 打开这个网站,点击第一个网速比较快的连接
2.在新页面顶部有一个蓝色的下载链接文字&lt; jetbra.zip(20220801) &gt;点击下载
3.步骤2打开的页面不要关闭后面还有用
4.在idea官网下载idea对应的版本 https://www.jetbrains.com/idea/download/other.html
我下载的是2024.1.3 -macOS(dmg)
5.下载安装完毕idea之后,找到步骤2下载的文件,找到 scripts文件夹,使用终端打开scripts文件夹(打开终端,cd然后把文件夹拖到终端里),执行" ./install.sh "指令
6.如果终端提示: done. the“kill Dock”command can fix the crash issue.则表示成功
7.在步骤2的页面.有一个 IDEA的大方块,鼠标放上去会变成 copy to clipboard 然后点击就复制了激活码
8.打开idea在Get license from:选项里选择Activation code,把步骤7复制的激活码粘贴上去,点击Activate ,
9.如果显示Subscription is active untill Augusr 1, 2026就表示破解成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4f592d6744ff02d51879b184986109d/" rel="bookmark">
			力扣每日一题 6/13 反悔贪心算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博客主页：誓则盟约系列专栏：IT竞赛 专栏关注博主，后期持续更新系列文章如果有错误感谢请大家批评指出，及时修改感谢大家点赞👍收藏⭐评论✍ 2813.子序列最大优雅度【困难】 题目： 给你一个长度为 n 的二维整数数组 items 和一个整数 k 。
items[i] = [profiti, categoryi]，其中 profiti 和 categoryi 分别表示第 i 个项目的利润和类别。
现定义 items 的 子序列 的 优雅度 可以用 total_profit + distinct_categories2 计算，其中 total_profit 是子序列中所有项目的利润总和，distinct_categories 是所选子序列所含的所有类别中不同类别的数量。
你的任务是从 items 所有长度为 k 的子序列中，找出 最大优雅度 。
用整数形式表示并返回 items 中所有长度恰好为 k 的子序列的最大优雅度。
注意：数组的子序列是经由原数组删除一些元素（可能不删除）而产生的新数组，且删除不改变其余元素相对顺序。
示例 1：
输入：items = [[3,2],[5,1],[10,1]], k = 2 输出：17 解释： 在这个例子中，我们需要选出长度为 2 的子序列。 其中一种方案是 items[0] = [3,2] 和 items[2] = [10,1] 。 子序列的总利润为 3 + 10 = 13 ，子序列包含 2 种不同类别 [2,1] 。 因此，优雅度为 13 + 22 = 17 ，可以证明 17 是可以获得的最大优雅度。 示例 2：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4f592d6744ff02d51879b184986109d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03235c3038fe565bb74947e7e7fcf097/" rel="bookmark">
			【C&#43;&#43;高阶】C&#43;&#43;继承学习手册：全面解析继承的各个方面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📝个人主页🌹：Eternity._
⏩收录专栏⏪：C++ “ 登神长阶 ”
🤡往期回顾🤡：模板进阶
🌹🌹期待您的关注 🌹🌹
继承 📖1. 继承的概念及定义⛰️继承的概念🌄继承定义 📙2. 基类和派生类对象赋值转换📕3. 继承中的作用域🎩成员变量隐藏🎈成员函数隐藏 📚4. 派生类的默认成员函数🧩默认成员函数🧩派生类默认函数特征 📒5. 友元与静态成员变量🍂友元🍁静态成员 📜6. 多继承🌞菱形继承🌙虚拟继承⭐虚拟继承解决数据冗余和二义性的原理 🔥7. 总结 前言： 当我们踏上C++编程的旅程时，继承无疑是一个无法回避且至关重要的概念。作为面向对象编程的三大特性之一，继承不仅让我们能够创建出层次清晰、结构合理的代码，还极大地提高了代码的可重用性和可维护性。在本文中，我们将一起深入探讨C++继承的奥秘，从基础概念到高级应用，逐步揭开它的神秘面纱
C++继承允许我们定义一个基类（或称为父类），并从这个基类中派生出新的类（称为派生类、子类）。派生类会继承基类的成员和成员函数，同时还可以添加自己的成员和成员函数。这种能力使得我们能够构建出复杂的类层次结构，实现代码的模块化和复用
在本文的学习中我们不仅仅要了解继承的基本概念。在实际编程中，我们还需要掌握如何正确使用继承、如何避免常见的继承陷阱、以及如何利用继承来优化我们的代码结构。因此，本文将带领大家从多个角度全面学习C++继承，包括继承的语法规则、访问控制、构造函数与析构函数的调用、多重继承与菱形继承等问题
让我们一起踏上学习C++继承的旅程吧！
📖1. 继承的概念及定义 ⛰️继承的概念 继承(inheritance)机制是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加功能，这样产生新的类，称派生类。继承呈现了面向对象程序设计的层次结构，体现了由简单到复杂的认知过程。以前我们接触的复用都是函数复用，继承是类设计层次的复用
继承代码示例
class A { public: void func() { cout &lt;&lt; "A::func()" &lt;&lt; endl; } protected: int _a = 10; }; // 继承后父类A的成员_a（成员函数+成员变量）都会变成子类的一部分 class B : public A { public: // ...... protected: int _b = 100; }; int main() { A a ; B b; a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03235c3038fe565bb74947e7e7fcf097/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f5448e7f7c570b688a46559ece091ac/" rel="bookmark">
			夏季河湖防溺水新举措：青犀AI视频智能监控系统保障水域安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近日一则新闻引起大众关注，有网友发布视频称，假期在逛西湖时，发现水面上“平躺”漂浮着一名游客在等待救援。在事发3分钟内，沿湖救生员成功将落水游客救到了岸边。
随着夏季的到来，雨水增多，各危险水域水位大幅上升，加上天气炎热，偷偷下湖游泳者屡禁不止，尤其是在水库、深水池塘、湖泊、河流等水域，由于缺乏有效的监管手段，溺水事故时有发生。传统的监控方式往往依赖于人工巡逻，存在监控盲区、反应速度慢等问题，难以满足现代水域安全监管的需求。因此，TSINGSEE青犀AI视频智能监控防溺水方案具有重要的实践意义。
一、方案介绍 TSINGSEE青犀夏季河湖AI视频智能监控防溺水方案，主要采用安防视频监控综合管理平台EasyCVR视频汇聚融合系统，通过接入安装在水域周边的摄像头，实现对水域环境的全天候、无死角监控。同时，利用AI人工智能技术，对视频监控系统采集的图像进行实时分析。通过目标检测、行为识别等技术，自动检测人员闯入危险水域等行为，一旦发现，系统立即触发报警机制，向管理人员发送报警信息，有效预防溺水事故的发生。
二、方案功能点 1、AI算法智能识别，快速响应
依托AI智能分析网关的智能算法，可以对接入的视频流进行实时分析，实时监测是否有人员闯入警戒区、徘徊、摔倒等，并能及时触发告警，自动推送提示消息给管理人员，提醒管理人员及时处理，还可以联动现场语音装置进行播报驱离，有效提升危险水域的管控力度。
区域入侵：自动检测划定区域内是否有人员/车辆进入，检测到该行为将立即触发告警并抓拍，可支持选择人员、电动车、自行车、三轮车、汽车、卡车。越界检测：自动检测人员越过划定警戒线（含方向）的行为，检测到则立即触发告警。区域徘徊：自动检测划定区域内人员及停留时间，超出阈值则判断为徘徊，超出徘徊次数将触发告警。摔倒检测：自动识别人员的摔倒行为，并触发告警。 2、实时监控，管理可视化，无死角覆盖
利用安防视频综合管理系统EasyCVR视频云平台的视频汇聚及管理能力，可将部署在水库、河湖、河湖岸线、深水潭、池塘等危险水域的前端摄像头等设备进行统一集中接入，实现对危险水域的24小时不间断高清视频监控。管理人员可以随时随地查看水域情况，及时发现并处理安全隐患，加强夏季防溺水监管。
视频汇聚EasyCVR安防监控平台特点如下：
视频汇聚管理：智慧安防监控EasyCVR视频管理平台能在复杂的网络环境中，将前端监控设备统一集中接入与汇聚管理；多协议接入：支持国标GB/T28181协议、RTMP、RTSP/Onvif协议、海康Ehome、海康SDK、大华SDK、华为SDK、宇视SDK、乐橙SDK、萤石云SDK、GA/T 1400协议等；24小时监控：支持7*24小时实时高清视频监控，能同时播放多路监控视频流，视频画面1、4、9、16个可选，支持自定义视频轮播；流媒体分发：能对外分发RTMP、RTSP、HTTP-FLV、WebSocket-FLV、HLS、WebRTC、ws-fmp4、http-fmp4等视频流，支持在多终端设备上观看；录像回放与存储：支持视频录像、存储、回放功能，可通过调阅视频录像查看现场事发经过，将视频录像作为追溯责任的证据；GIS地图：可根据设备的地理位置信息，在地图上实现可视化、空间化点位布局展示、调阅视频；系统运维管理：具备权限/用户/角色管理、设备分级分组管理、鉴权管理、服务器集群等管理能力；拓展性：平台提供标准的API接口，方便进行开发和集成。 3、数据存储，录像回放方便有效追溯
视频监控EasyCVR视频管理云平台还具备录像、检索、回放、存储等功能。一旦发生溺水事故，管理人员可以通过查看存储的视频资料，了解事故发生的经过和原因，为后续的救援和处理工作提供重要的线索和依据。同时，这些视频资料也可以作为教育素材，用于向公众普及防溺水知识和提高安全意识。
TSINGSEE青犀夏季河湖AI视频智能监控防溺水方案，利用人工智能技术，对监控画面进行智能分析和识别，及时发现并预警潜在的溺水风险，从而采取相应的防范措施。通过科技手段提升了水域安全监管水平，实现了对水域的实时监控和智能预警。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1334f00e41bb73ea1e4c5e2fce540cca/" rel="bookmark">
			深度学习 - RNN训练过程推演
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 数据准备 字符序列 “hello” 转换为 one-hot 编码表示：
输入: [‘h’, ‘e’, ‘l’, ‘l’]输出: [‘e’, ‘l’, ‘l’, ‘o’] 2. 初始化参数 假设我们使用一个单层的 RNN，隐藏层大小为2。初始参数如下：
W x h = ( 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 ) , W h h = ( 0.1 0.2 0.3 0.4 ) , W h y = ( 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 ) W_{xh} = \begin{pmatrix} 0.1 &amp; 0.2 \\ 0.3 &amp; 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1334f00e41bb73ea1e4c5e2fce540cca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c0b36923c578df445bed8619896ff7c/" rel="bookmark">
			美国科技新闻三则 | 科技股成为美股第二大股息分派行业 &amp; 马斯克高调宣布：560亿美元薪酬方案已获通过 &amp; 争夺AI以太网：英伟达 VS Arista Networks
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		科技股成为美股第二大股息分派行业 长期以来，高息股一直被看作成熟行业（例如金融股、能源股）的标配，但科技股正在改变这个生态。今年以来，Meta、Alphabet、Salesforce都加入了股息分派的大军。
图1，科技股占标普500现金派息总额的14.1%，在所有行业排名第二。尽管科技股的股息率不高，但是金额巨大。
图2，科技股分红，最大的受益者往往是上市公司的创始人。这背后有一个很重要的因素——全球科技公司的掌舵人，相较于15年前，平均年龄已经大幅增长。
马斯克高调宣布：560亿美元薪酬方案已获通过 据马斯克发文，特斯拉股东高票批准其560亿美元薪酬方案，特斯拉总部将迁至德州。
据路透社报道，6月13日，马斯克在社交媒体平台X上表示，特斯拉股东已投票批准其560亿美元的薪酬方案，并计划将公司合法住所迁至德克萨斯州。
尽管主要投资者Glass Lewis和机构股东服务公司（ISS）反对，但投票通过率很高，这标志着马斯克和董事会取得了重大胜利。
该薪酬方案授予马斯克约 3 亿股激励性股票期权，并在 2018 年获得超过 70% 的股东支持通过。
然而，一位特拉华州法官在今年 1 月以披露给投资者信息不足为由撤销了该方案，称董事会“听命于”马斯克。特斯拉董事会随后在提供新披露信息的情况下再次提交了该方案进行投票。
一位知情人士称，主要机构投资者和散户的组合确保了投票结果的“赞成”。
股东还对其他提案进行投票，包括将总部从特拉华州迁至德克萨斯州，以及改选马斯克的弟弟Kimbal Musk和James Murdoch两名董事会成员。
一些投资者认为，对马斯克薪酬的投票是对其领导能力信心的考验。尽管马斯克是特斯拉成功的推动力，但公司最近销售和利润放缓引发了人们对他分散注意力的担忧，尤其是他同时经营六家公司，包括SpaceX和社交媒体巨头X（前推特）。
特斯拉一直在争取支持，特别是散户投资者的支持。这些散户在特斯拉的所有权基础中占比异常高，但通常不参与投票。公司高管在X上发布消息，称马斯克对特斯拉的成功至关重要，并在社交媒体上投放广告。马斯克还承诺让投票的股东参观特斯拉德州工厂。
董事会认为，马斯克实现了市值、营收和盈利能力方面的所有目标，应获得相应报酬。尽管特拉华州法官批评2018年的薪酬计划，但董事会坚持认为该方案是留住马斯克的必要条件。
股东Donald Ball提起诉讼，质疑即将举行的股东投票，称马斯克使用胁迫手段争取批准。
尽管股东们已经批准此方案，但特拉华州法院是否会允许投票生效还不确定。马斯克或需等待数月或数年，才能通过上诉恢复薪酬待遇。
争夺AI以太网：英伟达 VS Arista Networks 花旗指出，尽管英伟达刚刚入局以太网市场，但其与交换机龙头Arista的技术发展接近同步。英伟达1.6T以太网产品预计在2026年初部署，Arista基于博通的1.6T交换机可能会稍早或同时推出。
受益于数据中心建设热潮，以太网在AI组网中加速渗透，英伟达和Arista Networks正全力推动以太网技术发展。
花旗在本周的最新报告中对比了两者的产品路线图，其指出以太网渗透加快给英伟达和“交换机龙头”Arista带来机会，两者在以太网技术方面的发展接近同步，都有望在不久的将来推出高速以太网解决方案。
花旗强调，对于Arista而言，英伟达是一个比预期更强大的以太网竞争对手：
尽管英伟达刚刚进入以太网市场，它正在执行一个雄心勃勃且极快的以太网AI产品部署，并可能与Arista的AI路线图相匹配；
英伟达表示他们预计Spectrum-X平台将在一年内成为数十亿美元产品线，突显了众多客户愿意在以太网领域也采用英伟达的捆绑方法。
花旗报告指出，英伟达和Arista Networks都将在2024年底或2025年初拥有端到端的800G解决方案：
英伟达的Spectrum-X平台是一个集成了软件、以太网交换机、网络接口卡（NICs）和数据处理单元（DPU）的综合解决方案。此前文章指出，Spectrum-X相比传统以太网，能够将生成式AI网络性能提高1.6倍。该平台整合了Nvidia Spectrum X以太网交换机和Nvidia BlueField-3超级网卡，以解决传统以太网在AI应用中的瓶颈。Arista的Etherlink技术是结合了博通的Tomahawk 5叶交换机（目前已有）和计划在2024年晚些时候推出的Jericho 3 Spine产品，并在其上添加软件。 花旗进一步表示，英伟达和Arista在1.6T产品（基于102.4T芯片）的路线图上可能也是一致的，博通下一代以太网芯片Tomahawk 6推出时间将影响英伟达和Arista相关产品的上市时间。
由于Tomahawk 5自2023年3月已经开始大规模生产，预计Tomahawk 6（基于102.4T芯片）将在2025年初或中期开始生产，这一推测基于以太网芯片通常2年的发展路线图。
如果Tomahawk 6的生产时间符合预期，那么基于Tomahawk 6的交换机可能会在2025年末或2026年初量产。这表明与英伟达的1.6T以太网产品（Spectrum-X1600）相比，Arista基于博通的1.6T交换机可能会稍早或同时推出，Nvidia的产品预计在2026年初部署。
此外，从以太网联盟到2040年的技术路线图和速度发展趋势可以看出，以太网最新的400GbE和800GbE标准已经制定，而3.2Tb/s则是未来可能的极限速率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dcc552c02d161252fc494aedadc66aa/" rel="bookmark">
			【开发环境】PX4无人机实物使用视觉或运动捕捉系统进行位置估计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PX4无人机实物使用视觉或运动捕捉系统进行位置估计 PX4中关于外部位置信息的MAVLink话题参考坐标系EKF2调整配置参数调整EKF2_EV_DELAY参数 与ROS共同使用将OptiTrack MoCap系统提供的姿态数据导入ROSMotive MoCap软件的步骤将姿态数据导入ROS重新映射姿态数据 将姿态数据转发到PX4PX4和ROS的参考坐标系 飞行测试 视觉惯性里程计（VIO）和运动捕捉系统（MoCap）允许无人机在全局位置信息不可用或不可靠时导航（例如在室内或在桥下飞行等）。
VIO和MoCap都根据视觉信息确定车辆的位置和姿态，它们之间的主要区别在于坐标系视角：
VIO使用机载传感器从无人机的视角获取姿态数据。
MoCap使用机外摄像机系统来获取3D空间中的无人机姿态数据。
来自VIO和MoCap的姿态数据都可用于更新基于PX4的自动驾驶仪的局部位置估计（相对于局部原点），并且还可选择性地融合到无人机姿态估计中。此外，如果外部姿态系统也提供线速度测量数据，则该数据可以用于改进状态估计（线速度测量数据的融合仅由EKF2算法支持）。
这篇文章介绍了如何配置基于PX4飞控的无人机系统，通过ROS或其他MAVLink系统从MoCap/VIO系统获取数据。主要介绍如何设置像VICON和Optitrack这样的MoCap系统，以及像ROVIO、SVO和PTAM这样的VIO系统。
PX4中关于外部位置信息的MAVLink话题 PX4使用以下MAVLink话题获取外部位置信息，并将其映射到uORB话题。
MAVLink话题名称uORB话题VISION_POSITION_ESTIMATEvehicle_visual_odometryODOMETRY (frame_id = MAV_FRAME_LOCAL_FRD)vehicle_visual_odometryATT_POS_MOCAPvehicle_mocap_odometryODOMETRY (frame_id = MAV_FRAME_MOCAP_NED)vehicle_mocap_odometry EKF2状态估计器只能订阅vehicle_visual_odometry话题获取外部位置信息，因此只能处理前两条话题，如果使用MoCap系统则必须生成这些话题才能够使用EKF2。vehicle_visual_odometry话题是唯一一个可以向PX4发送线速度测量数据的话题。
话题的传输频率应在30Hz和50Hz之间。如果信息速率过低，EKF2将不会熔断外部视觉信息。
PX4当前不支持以下MAVLink视觉话题：GLOBAL_vision_POSITION_ESTIMATE、vision_SPEED_ESTIMATE、VICON_POSTION_ESTIMATE。
参考坐标系 PX4将FRD（X向前、Y向右和Z向下）用于局部机体坐标系以及参考坐标系。
当使用磁力计的航向时，PX4参考系的X轴将与北方对齐，因此它被称为NED（X North，Y East，Z Down）。
PX4估计器的参考帧的航向和外部姿态估计的航向在大多数情况下将不匹配。因此，外部姿态估计的参考帧以不同的方式命名，称为MAV_frame_LOCAL_FRD。
根据参考系的来源，在发送MAVLink Vision/MoCap话题之前，您需要对姿态估计应用自定义变换。这对于更改姿态估计的父帧和子帧的方向是必要的，以使其符合PX4约定。可以根据MAVROS odom插件了解必要的转换。
例如，如果使用Optitrack坐标系，则局部坐标系位于水平面上（x前和z右），而y轴垂直并指向上。一个简单的技巧是交换轴以获得NED坐标系。
如果x_{mav}、y_{mav}和z_{mav}是通过MAVLink作为位置反馈发送的坐标，则我们获得：
x_{mav} = x_{mocap} y_{mav} = z_{mocap} z_{mav} = - y_{mocap} 对于无人机姿态方向的坐标系变换，保持四元数的标量部分w相同，并以相同的方式交换矢量部分x、y和z。你可以在每个系统中应用这个技巧-如果你需要获得NED坐标系，请查看你的MoCap输出并相应地交换轴。
EKF2调整配置参数 必须设置以下参数才能将外部位置信息与EKF2一起使用。
参数名称外部位置估计设置EKF2_AID_MASK根据融合模型需求设置视觉位置融合、视觉速度融合、视觉偏航角融合和外部视觉欧拉角融合。EKF2_HGT_MODE设置为使用视觉作为海拔估计的主要来源。EKF2_EV_DELAY设置为测量的时间戳与实际捕获时间之间的差值。EKF2_EV_POS_X, EKF2_EV_POS_Y, EKF2_EV_POS_Z设置视觉传感器（或MoCap标记）相对于无人机机体坐标系的位置。 调整EKF2_EV_DELAY参数 EKF2_EV_DELAY参数是相对于IMU测量的视觉位置估计器延迟。
或者换句话说，这是视觉系统时间戳和IMU时钟（EKF2的基本时钟）记录的实际捕获时间之间的差异。
从技术上讲，如果MoCap和ROS计算机之间有正确的时间戳（而不仅仅是到达时间）和时间同步（例如NTP），则可以将其设置为0。事实上，这需要一些经验调整，因为整个MoCap到PX4的通信链路中的延迟是需要特殊设置的。使用完全同步的通信链路来设置系统是罕见的！
通过检查IMU速率和EV速率之间的偏移，可以从日志中获得延迟的粗略估计。要启用EV速率的日志记录，请在参数设置中勾选SDLOG_PROFILE参数的第7选项（计算机视觉和禁用）。
可以通过调整参数来进一步降低该值，以找到在动态机动过程中产生最低EKF的值。
与ROS共同使用 ROS不需要用于提供外部姿态信息，但强烈建议使用，因为它已经与VIO和MoCap系统进行了良好的集成。
将OptiTrack MoCap系统提供的姿态数据导入ROS VIO和MoCap系统有不同的获取姿态数据的方式，并且有自己的设置和话题。
下面介绍了OptiTrack MoCap系统的设置。对于其他系统，请参阅供应商设置文档。
OptiTrack官网
以下步骤说明如何将OptiTrack系统的位置估计值输入PX4。假设MoCap系统已校准。
校准过程的教程
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7dcc552c02d161252fc494aedadc66aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4575127a09ab6b805f670be79fe8f516/" rel="bookmark">
			Python基础教程（十六）：正则表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💝💝💝首先，欢迎各位来到我的博客，很高兴能够在这里和您见面！希望您在这里不仅可以有所收获，同时也能感受到一份轻松欢乐的氛围，祝你生活愉快！
💝💝💝如有需要请大家订阅我的专栏【Python系列】哟！我会定期更新相关系列的文章
💝💝💝关注！关注！！请关注！！！请大家关注下博主，您的支持是我不断创作的最大动力！！！
文章目录 引言一、正则表达式基础二、Python `re` 模块常用方法三、经典案例展示案例 1：验证电子邮件地址案例 2：获取电话号码案例 3：替换敏感词 四、进阶用法五、总结 结束语 引言 正则表达式是处理字符串的强大工具，尤其在数据清洗、文本解析和模式匹配等场景中发挥着重要作用。Python 提供了 re 模块来支持正则表达式的使用，本文将带你深入了解 Python 中的正则表达式，从基本语法到高级用法，结合实际案例，让你成为正则表达式的高手。
一、正则表达式基础 正则表达式由普通字符（如字母 a-z）和特殊字符（称为元字符）组成。元字符在正则表达式中具有特殊含义，它们可以表示一个字符集、一个位置等。下面是一些常用的元字符：
.：匹配任意除换行符以外的字符。
*：匹配前面的子表达式零次或多次。
+：匹配前面的子表达式一次或多次。
?：匹配前面的子表达式零次或一次。
^：匹配输入字符串的开始位置。
$：匹配输入字符串的结束位置。
[…]：字符集，匹配方括号中的任意字符。
[^…]：否定字符集，匹配任何不在方括号中的字符。
|：或，匹配 | 左右的表达式任意一个。
(…)：分组，将多个字符当做一个整体进行匹配。
元字符：如 . 匹配任意单个字符，* 表示前面的元素可以出现任意次，包括0次。字符集：[abc] 匹配 ‘a’ 或 ‘b’ 或 ‘c’。位置锚点：^ 匹配行的开始，$ 匹配行的结束。 二、Python re 模块常用方法 re.search(pattern, string)：扫描整个字符串并返回第一个成功的匹配。re.match(pattern, string)：尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功，则返回 None。re.findall(pattern, string)：查找字符串中所有匹配正则表达式的子串，并返回一个列表。re.finditer(pattern, string)：类似于 findall，但返回的是一个迭代器，每次迭代返回一个 Match 对象。re.sub(pattern, repl, string)：将字符串中所有匹配正则表达式的子串替换为指定字符串。 参数说明：
pattern 匹配的正则表达式string 要匹配的字符串。flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：正则表达式修饰符 - 可选标志 三、经典案例展示 案例 1：验证电子邮件地址 import re email_pattern = r"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4575127a09ab6b805f670be79fe8f516/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84ed99ca51d40a505af9f7bd0071f6fa/" rel="bookmark">
			远程连接MySQL数据库（多种方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		远程连接MySQL数据库（多种方法） 1、授权连接到MySql 确保电脑上有mysql服务器，才可以进行如下操作
步骤1：配置服务器 配置MySQL服务器允许远程连接： 1、修改服务器配置文件：
sudo nano /etc/mysql/mysql.conf.d/mysqld.cnf 2、注释或修改 bind-address 行：
# bind-address = 127.0.0.1 bind-address = 0.0.0.0 3、重启 MySQL 服务：
sudo systemctl restart mysql 创建用户授权访问： 1、连接到 MySQL 服务器：
mysql -u root -p 2、创建用户并授予权限：
CREATE USER 'yourusername'@'%' IDENTIFIED BY 'yourpassword'; GRANT ALL PRIVILEGES ON yourdatabase.* TO 'yourusername'@'%' WITH GRANT OPTION; FLUSH PRIVILEGES; -- 创建一个新的 MySQL 用户 CREATE USER 'xiaozhou'@'%' IDENTIFIED BY 'securepassword'; -- 授予新用户对 car_door 数据库的所有权限 GRANT ALL PRIVILEGES ON car_door.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84ed99ca51d40a505af9f7bd0071f6fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c1c7cce09eab81188279907a72e75f6/" rel="bookmark">
			MYSQL、ORACLE、PostgreSQL数据库对象层次及权限管理对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、PostgreSQL二、MySQL三、Oracle 前言 本文为出于自己扩展、比较、图形化的思维路径自行总结归纳，可能有些细节不太准确，欢迎指正。
MySQL、Oracle、PostgreSQL关系型数据库都有管理员用户、用户、权限管理、表函数索引等数据库对象，schema。但在数据库对象隶属层次上有差异和相同的地方。
一、PostgreSQL PostgreSQL的数据库对象及权限管理分层管理。
一个实例下可以有多个数据库，每个数据库下有多个schema，每个schema下有不同的数据库对象，用户A要访问某个数据库的表，需要依次获取对该数据库(可以访问多个数据库)、该schema、该表的权限，才能成功访问。user和schema不是绑定的
默认情况下，在一个数据库内新建一个新用户时会默认创建该用户的同名schema，该用户拥有对同名schema的所有权限，同时，也可以新建其他schema，一个用户可以拥有、访问多个schema。
3.权限管理分为：管理员权限和对象权限
管理员与实例权限：SYSADMIN（系统管理员权限）、MONADMIN（监控管理员权限）、OPRADMIN（运维管理员）、POLADMIN（安全策略管理员权限）、AUDITADMIN（审计管理员权限）、LOGIN、CREATEDB、CREATEROLE、USEFT、CREATEROLE。
对象权限：对database、schema、table、package、等对象insert、select等权限 管理员与实例权限赋权语句 create user XXX SYSADMIN|LOGIN|CREATEDB....(不一一举例,); alter user XXX SYSADMIN|LOGIN|CREATEDB....(不一一举例,); 对象权限(不一一举例)select、update、insert等等权限 grant all privileges on database XXX to user; grant all privileges on schema A to XXX; grant all privileges on table tabname to XXX; 二、MySQL schema和数据库(database)是相同的
也就是说schema名称和数据库实例的名称是相同的，一个数据库只拥有一个schema。权限管理分为：全局权限、数据库权限、对象权限。
三、Oracle Oracle 用户user和schema强绑定
oracle一般（严谨点）一个集群只有一个数据库，一个数据库下可以有多个user(schema),一个用户只能有一个schema权限管理份分为：系统权限和对象权限
系统权限 ：oracle总计有225种系统权限,系统规定使用数据库的权限。对oracle来说，对数据库和对模式的权限属于系统权限。包括dba权限
用户权限：授权给表、视图、序列、同义词的权限 系统权限 GRANT &lt;系统权限名称&gt; TO {PUBLIC | &lt;角色名&gt; | &lt;用户名&gt;[,...N]} [WITH ADMIN OPTION] WITH ADMIN OPTION表示指定用户可以将这些权限授予该其他的用户。 系统权限：（不一一举例） 系统权限包括 数据库维护权限 ALTER DATABASE 修改数据库的结构 ALTER SYSTEM 修改数据库系统的初始化参数 DROP PUBULIC SYNONYM 删除公共同义词 create procedure 在自己的模式中创建存储过程 drop procedure 在自己的模式中删除存储过程 create database link 创建数据库连接权限，通过数据库连接允许用户存取远程的数据库。 drop datebase link 删除数据库的连接 create synonym 创建私有同义词 drop synonym 删除同义词 create sequence 创建开发者所需的序列 create trigger 创建触发器 ———————————————— 对象权限 对象权限的授予 GRANT {&lt;对象权限名&gt; | ALL [PRIVILEGE] [(&lt;&gt;[,.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c1c7cce09eab81188279907a72e75f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47c03457a2db06ad72e19a408d404c4b/" rel="bookmark">
			网络协议五
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、RPC协议 【整体都没仔细研究 无论是什么 RPC，底层都是 Socket 编程
二、结合双十一项目 【没仔细研究 VPC 1. 创建一个 VPC 并指定一个 IP 段 解释：虚拟私有云（VPC）是一个虚拟的网络环境，它与互联网隔离，并允许用户在云上安全地运行虚拟机（VM）和其他云资源。指定一个 IP 段是为了确保所有在这个 VPC 中运行的资源都有唯一的 IP 地址，不会与其他网络冲突。
举例：假设你创建了一个 VPC，并指定了一个 IP 段为10.0.0.0/16。这个 IP 段表示从10.0.0.0到10.0.255.255的所有IP地址，可以用来为你的应用程序和服务分配IP地址。
2. 每个 VPC 被分配一个 VXLAN 的 ID 解释：VXLAN（Virtual Extensible LAN）是一个网络虚拟化技术，用于在大规模数据中心内创建虚拟网络。每个 VPC 被分配一个唯一的 VXLAN ID，以确保不同的 VPC 之间的隔离，即使它们的虚拟机可能在同一台物理机上运行，它们的二层网络也是隔离的。
举例：你的 VPC 被分配了 VXLAN ID 为1001，这确保了你的 VPC 与其他用户的 VPC 是隔离的。
3. 为每个可用区分配一个 Subnet 解释：可用区（Availability Zone, AZ）是云提供商的一个物理隔离区域，用于提高服务的可用性和容灾能力。在你的 VPC 内，可以为每个可用区创建一个子网（Subnet），即在大的 IP 段里划分出两个小的 IP 段。
举例：假设你有两个可用区（AZ1 和 AZ2），你可以在你的 VPC 内创建两个子网：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47c03457a2db06ad72e19a408d404c4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbb222994158530ededafd977f21401a/" rel="bookmark">
			基于图像识别的中医AI舌面诊技术，全面开放API对接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 望面部色泽之所以能够判别疾病，其原理在于面部血脉分布丰富，《灵柩·邪气脏腑病形》曰“十二经脉，三百六十五络，其血气皆上于面而走空窍”；其次，面部皮肤嫩薄，体内气血盛衰变化，最容易通过面部色泽变化显露出来；此外，患者面部多暴露于外，方便医生观察。面部色泽对于疾病的判断也具有重要意义，可以用于判断气血盛衰、识别病邪性质、确定疾病部位、预测疾病转归。
舌诊是通过观察舌质和舌苔的变化，了解机体生理功能和病理情况的侦察方法，在疾病发展的过程中，舌诊的变换往往比较明显，故舌诊在望诊中具有举足轻重的地位。《笔花医镜·望舌色》云：“舌者心之窍，凡病具现于舌，能辨其色，证其自然”。《医生棒喝》记载：“观舌本，可验其阴阳虚实；审苔垢，即知其邪之寒热浅深也。”强调通过全面观察舌质、舌苔，便可推测其发病的性质。由于舌与脏腑、经络、气血津液关系十分密切，其变化与体内的各种变化同步，所以有人把舌象比作反映内脏变化的“镜子”。临床实践证明，凡体质禀赋的强弱，正气的盛衰、病情的深浅、预后的吉凶均能客观地从舌象上反映出来，为医生临床诊断提供重要的依据。
将人工智能应用于传统的舌面望诊任务中，已经成为当下研究的热点。李福凤等将最小偏差法和线性判别式分析相结合，在多个色彩空间中进行实验，找到了面部光泽识别的最佳空间和模型，取得了89%的高准确率；陆萍等利用神经网络分析中医面诊证素辨证，构造了一个高效经济的基于证素辨证的面诊神经网络结构；沈兰荪等利用图像分析技术研究中医舌诊客观化，提出了舌体区域分割、裂纹分析、舌苔和舌质特征分析等一套算法，并通过临床证明了其有效性；唐俊安等利用snake模型分割舌象，在RGB色彩空间中通过对“湿热症”和“湿寒症”两种舌象的检测和对比，证明了提出算法对其症的有效性；郝一鸣等通过分析收集糖尿病患者的13个舌诊参数和糖尿病相关指标GHb，发现舌色的S值与GHb高度相关，可为糖尿病中医证候临床诊断提供客观依据。
基本原理 通过图像全方位识别患者的舌、面等多种症状，为医生提供高可靠的临床诊疗参考意见，加快医生工作效率，协助医生提升诊断的准确性。
舌面诊断系统共包含三个子系统，分别为面象诊断系统、舌象诊断系统和图像预处理系统。·
（1）其中面象诊断系统包含了7个子系统，分别为：眼睑浮肿识别系统、面部光泽识别系统、川字眉识别系统、双眼皮识别系统、脸型识别系统、眉毛浓淡识别系统和唇厚薄识别系统。
（2）舌象诊断识别系统包含5个子系统，分别为：苔色识别系统、苔腻识别系统、舌体胖瘦识别系统、裂纹识别系统和齿痕识别系统。
图-舌面诊断系统架构
首先，通过目标检测算法识别人脸和舌头区域，获得人脸区域和舌头区域的外接矩形框；然后，对获得的人脸区域和舌头区域进行具体部位的提取。系统识别到人脸区域进行特征点回归的操作获得人脸的特征点信息，同时对人脸区域进行实例分割获得眉毛、眼睛、鼻子、嘴唇、皮肤、头发、耳朵、口、脖子等，系统对识别到的舌体区域进行舌体分割，获得没有背景干扰的舌体，提高舌诊的精度，用于后续的舌诊计算机识别；然后，系统根据提取到的实例图片和面部特征点等多种信息对舌面特征进行预测；最后，可视化预测结果。
图-舌面系统处理流程
研究过程中，通过对舌面图像定位，去噪，采用先进深度学习技术实现对患者的舌苔，舌质，面象等多种特征的精准识别，为医生提供可靠的临床诊疗意见，提升诊断的效率和准确性。
图-舌面诊研究过程
核心模块 1、图像质量检测
根据舌面图像的具体情况进行色彩校正，光照还原，模糊检测，高频信息滤波等预处理。图像在拍摄过程中，由于光照、抖动、雾等一系列因素可能使图像质量过差。所以，通过图像预处理模块，减少或者去除这些不利因素对图像质量造成的影响。
基于Laplacian高频信息的模糊图像检测：模糊的图像具有很少的高频信息和大量的低频信息。纹理，材质等属于图像的低频信息，轮廓，边缘等属于图像的高频信息。因此通过评估高频信息能够简单有效地反映图像的模糊程度。Laplacian算子是一种二阶微分算子，常被用于提取图像的高频信息。Laplacian算子做模糊检测的具体流程分三步。首先，彩色图片转换为灰度图像；其次，对灰度图像进行4领域的Laplacian算子滤波，提取高频图像；最后，计算高频图像的标准差σ，当σ小于一定的阈值时，则该图像模糊，否则该图像清晰。
基于导向滤波的图像去噪：去噪算法主要是去除图片中存在的噪声，本系统使用的去噪算法有传统的高斯滤波和导向滤波。导向滤波是一种包边滤波器，能够在去噪的同时保留边缘高频信息，导向滤波的指导图片为待滤波图片的灰度图。该方法能够很好的去除雾天图片的影响。
2、面象特征分析
面象诊断系统包含了7个子系统，分别为：眼睑浮肿识别系统、面部光泽识别系统、川字眉识别系统、双眼皮识别系统、脸型识别系统、眉毛浓淡识别系统和唇厚薄识别系统。
人脸关键点检测是人脸识别和分析领域中的关键一步，它是诸如人脸识别、面部情感分析、三维人脸重建及三维动画等其它人脸相关问题的前提和突破口。系统对识别到的人脸区域进行特征点回归操作获得人脸的特征点信息，同时对人脸区域进行实例分割获得眉、眼、鼻、唇、发、耳、口、颈等。由于人脸图片特征点标注工作需要耗费大量的资源，因此系统采用无监督的面部特征点回归算法，在只有少量标注的情况下，充分考虑未标注图片的信息，提高算法的回归精度和识别准确率。
3、舌象特征分析
舌象诊断识别系统包含5个子系统，分别为：苔色识别系统、苔腻识别系统、舌体胖瘦识别系统、裂纹识别系统和齿痕识别系统。
由R-CNN和Fast RCNN算法发展而来的Faster RCNN算法是目前主流的目标检测算法。Faster RCNN将特征提取，候选区域抽取，特征金字塔网络，目标框回归，分类等整合到一个深度网络中，相比之前的RCNN类网络，很好的平衡了检测精度和检测速度，综合性能提升明显。本项目Faster RCNN的特征抽取层采用了更加轻量级的FBNet网络，检测速度有了更进一步提高。训练数据来源于基层医生采集的真实舌面数据，标注工作由具有中医临床知识的中医师进行标注。当高质量图片输入后，算法会返回图片中所有的舌面坐标信息。
临床应用 传统舌面望诊的难点：传统的中医舌面望诊是通过医生观察患者舌面做出结论，诊断结果往往和医生的临床经验，学习经历、断病时状态等因素有关，具有很强的主观性。同时传统舌面望诊也易受光线，气候，地域等外界因素的干扰。针对这些问题，近年来，随着计算机信息技术图像识别的高速发展，以计算机图像分析技术为主要手段，将中医舌面诊断客观化研究与计算机技术紧密结合，为中医舌面诊断客观化提供了新的方向。
系统可以通过患者的舌、面图片，快速预测中医舌面特征有：眼睑浮肿、面部光泽、川字眉、眼皮层数、脸型、眉毛浓淡、唇厚薄、苔色、苔腻、舌体胖瘦、裂纹和齿痕。帮助医师在门诊过程中提升效率、准确率。
产品示例 只需三步即可生成中医体质报告：用户拍摄自己的舌部、面部照片，上传后系统立刻检测，给出分析报告，检测有效率可以达到90%以上。
图-产品流程
在提供体质报告的同时，还能够根据商家的产品进行个性化定制，支持在用户的体质基础上推荐相应的茶饮产品/保健产品/专科医生等，并关联销售路径。这种对应关系建立在专业的中医理论基础上，通过科学的方法与体质相匹配。
现已全面开放API对接，可以方便快捷的集成在网页、app、小程序等，我们提供专业的医学保障和技术支持，欢迎各位交流讨论学习！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f17fdbf97bf50bb41e867554969d52e9/" rel="bookmark">
			【C&#43;&#43;】STL中stack和queue(适配器版)的模拟实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：在此之前我们讲到了stack和queue还有deque的常见的使用方法，并且也在数据结构的时候用C语言去实现过栈和队列，今天我们将进一步的用C++去模拟实现stack和queue
💖 博主CSDN主页:卫卫卫的个人主页 💞
👉 专栏分类:高质量Ｃ++学习 👈
💯代码仓库:卫卫周大胖的学习日记💫
💪关注博主和博主一起学习!一起努力！
目录标题 什么是适配器Stack的模拟实现Stack的基本结构常见函数的模拟实现入栈 - push(const T&amp; x)出栈- pop()获取栈顶元素 - const T&amp; top()栈中的元素个数 - size_t size()判断栈是否为空 整体代码: Queue的模拟实现Queue的基本结构常见函数的模拟实现入队列- push(const T&amp; x)出队列- pop()获取队头元素- const T&amp; front()获取队尾元素- const T&amp; back()获取队列元素个数 - size_t size()判断队列是否为空 - bool empty() 整体代码 在讲stack和queue的模拟实现之前我们需要提到一个概念:适配器
什么是适配器 适配器是一种设计模式，也是一种编程工具，用于将一个类的接口转换成另一个类的接口。适配器模式允许不兼容的类之间能够协同工作。
在C++中，适配器是指通过改变容器的接口使其适用于不同的需求。适配器可以封装容器，以提供一种更简单、更有限的功能接口，或者可以通过改变容器的工作方式来满足特定的需求。
在STL（标准模板库）中，适配器包括以下几种：
迭代器适配器：用于改变迭代器的行为，如reverse_iterator适配器用于反向遍历一个容器。容器适配器：用于改变容器的接口，如stack适配器用于实现堆栈功能。函数适配器：用于改变函数的行为，如bind适配器用于绑定函数和参数，生成新的函数对象。 适配器模式是一种重要的设计模式，它提供了一种解决兼容性问题的方式，并且可以使代码更加灵活和可复用。在C++中，STL的适配器提供了方便的工具和容器，使开发者能够更好地处理不同的需求和场景。
Stack的模拟实现 Stack的基本结构 这里很多人就会说，我们在C语言实现栈的时候就是像下面这么写的呐，就和实现vector一样的方式去实现stack不就行了嘛？如果是要用这样的方式去实现，那么博主今天就不会提到适配器这个概念了。
代码思路: 既然我们使用适配器来帮助我们来实现stack，那就是说你这个容器适配器的功能要满足我们stack所需要的入栈、出栈、获取栈顶元素、判断是否为空等等。
namespace bit { //这里我们通过模板来灵活的选择底层的容器适配器，只需要适配器满足我们所需要的操作即可 template&lt;class T, class Container = deque&lt;T&gt;&gt;//适配器 class stack { private: Container _con; }; STL中对stack和queue默认选择deque作为其底层容器，主要是因为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f17fdbf97bf50bb41e867554969d52e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c62130df5af2087ccc0dca4c02460806/" rel="bookmark">
			Python酷库之旅-比翼双飞情侣库(04)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、xlrd库的由来
二、xlrd库优缺点
1、优点
1-1、支持多种Excel文件格式
1-2、高效性
1-3、开源性
1-4、简单易用
1-5、良好的兼容性
2、缺点
2-1、对.xlsx格式支持有限
2-2、功能相对单一
2-3、更新和维护频率低
2-4、依赖外部资源
三、xlrd库的版本说明
1、xlrd 1.2.0版本
2、xlrd 2.0.1版本
3、xlrd3(非官方名称)
四、如何学好xlrd库？
1、获取xlrd库的属性和方法
2、获取xlrd库的帮助信息
3、用法精讲
3-10、xlrd.biffh.unpack_unicode函数
3-10-1、语法
3-10-2、参数
3-10-3、功能
3-10-4、返回值
3-10-5、说明
3-10-6、用法
3-11、xlrd.biffh.unpack_unicode_update_pos函数
3-11-1、语法
3-11-2、参数
3-11-3、功能
3-11-4、返回值
3-11-5、说明
3-11-6、用法
3-12、xlrd.biff_count_records函数
3-12-1、语法
3-12-2、参数
3-12-3、功能
3-12-4、返回值
3-12-5、说明
3-12-6、用法
五、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、 博客个人主页
​​​​​​​
在Excel中，通常所说的“情侣键”并非官方术语，而是对某些常用且经常成对出现的快捷键的一种形象化的称呼。其中，最为人熟知和广泛使用的“情侣键”是“Ctrl+C”和“Ctrl+V”。
1、Ctrl+C：这个快捷键的作用是“拷贝”或“复制”。当你在Excel中选中某个单元格、一行、一列或整个工作表的内容后，按下Ctrl+C键，这些内容就会被复制到计算机的剪贴板中，等待下一步的粘贴操作。
2、Ctrl+V：这个快捷键的作用是“粘贴”。在你按下Ctrl+C键将内容复制到剪贴板后，可以通过按下Ctrl+V键将这些内容粘贴到Excel中的另一个位置，这两个操作经常是连续进行的，因此Ctrl+C和Ctrl+V就像一对“情侣”，总是成对出现。
除了这对常见的“情侣键”外，Excel中还有许多其他的快捷键可以帮助用户更高效地完成各种操作。然而，这些快捷键通常并没有像Ctrl+C和Ctrl+V那样形成特定的“情侣”关系。
然而，今天我不再展开介绍“情侣键”，而是要重点推介Python中的“情侣库”，即xlrd和xlwt两个第三方库。
一、xlrd库的由来 xlrd库是一种用于在Python中读取Excel文件的库，它的名称中的"xl"代表Excel，"rd"代表读取，其开发者是John Machin(注：库名字符拆分诠释，只是一种猜测)。
xlrd最初是在2005年开始开发的，是基于Python的开源项目(下载：xlrd库官网下载)。
由于Excel文件在数据处理和分析中的重要性，xlrd库填补了Python在处理Excel文件方面的空白，使得用户可以方便地在Python环境中读取Excel文件的内容，并进行进一步的数据操作和分析。
二、xlrd库优缺点 1、优点 1-1、支持多种Excel文件格式 xlrd库支持多种Excel文件格式，包括`.xls`和`.xlsx`(在旧版本中)，这使得无论数据存储在哪种格式的Excel文件中，用户都可以使用xlrd库来读取。
1-2、高效性 xlrd库使用C语言编写，因此其性能非常高，即使面对非常大的Excel文件，xlrd也可以快速地读取其中的数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c62130df5af2087ccc0dca4c02460806/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3374a20dbaabf85a1ebaf1e91f11e0ce/" rel="bookmark">
			前端怎么预览pdf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景 后台返回了一个在线的pdf地址，需要我这边去做一个pdf的预览（需求1），并且支持配置是否可以下载（需求2），需要在当前页就能预览（需求3）。之前我写过一篇预览pdf的文章，但是当时后台返回的是blob流文件，如果你们的pdf也是以流文件的形式返回的，可以看这篇文章（超链接点进去就行）。
2.简单说下pdf预览的实现方式 a.借助 &lt;embed&gt; / &lt;iframe&gt;标签 这个是真的很简单，我直接贴在下面了，缺点是： 没办法阻止用户打印和下载pdf，所以我pass了这个方案
&lt;embed type="application/pdf" :src="pdfUrl" width="800" height="600" /&gt; &lt;iframe :src="pdfUrl" width="800" height="600" /&gt; 实现效果：
b.使用vue插件vue-pdf来渲染(应该还有一些其他的插件也可以使用，大家自己研究下实现的效果把)
这个方案我已经试了且用到项目上了，但是感觉很丑，跟浏览器打开pdf的效果差别很大，原因是这个插件大概得原理是把pdf转成了图片然后使用canvas来渲染的，然后很多东西都没有，就被我pass了。你可以想象一下你的pdf，然后你截图放进你网页上的感觉，就差不多是这个效果了，图片我忘记保存了，大家脑补一下
我找了个图，这个其实别人还做了一些其他的渲染，比如下面的也是他自己写的。我感觉是没这么好看的，所以就抛弃了这个
c.使用pdf.js预览
我觉得预览pdf这一块还是得用pdf.js，真的很成熟，样式也还是很给力的，然后想要改成什么样就可以改成什么样，因为源码在你手上。
缺点：稍微麻烦点，需要处理跨域的问题（但是如果你的网站、pdf文件所在位置，后台返回的pdf位置都在同一个域名下的话，就不需要处理）。且可能需要知道一点运维的知识，不然很可能你在本地能运行成功，但是到线上可能访问不到
3.使用pdf.js预览pdf a.到官网去下载pdf.js 建议下第二个！！！（别问我为啥，因为我下了第一个来写demo发现有报错，又踩坑了）
b.解压之后直接丢到项目中的public文件夹下面去 c.写一个pdf.vue文件，内容如下（注意我的路径，这个路径跟public的路径是一样的，前面加了一个/，原因如下：当我们使用npm run serve时，我们的本地电脑也会开启一个服务将public项目中的资源开发出来，此时跟服务器是一样的，你去访问：localhost:8080/pdf/web/viewer.html 是可以正常访问通的，这里不理解的话，就依葫芦画瓢吧，没关系的 ）： &lt;template&gt; &lt;iframe :src="'/pdf/web/viewer.html?file='+pdfUrl"&gt;&lt;/iframe&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'Pdf', props: { pdfUrl: { type: String, default: '' } } } &lt;/script&gt; &lt;style scoped&gt; iframe { /* width: 960px; */ width: 1100px; max-width: 100%; height: 800px; margin-left: 50%; transform: translateX(-50%); } &lt;/style&gt; d.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3374a20dbaabf85a1ebaf1e91f11e0ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3caa0f538aa66206b1e34b61c12ac6b4/" rel="bookmark">
			【Docker】Docker 配置镜像加速
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Docker配置镜像加速或配置源加速，主要是为了加快Docker镜像的拉取速度，特别是在网络环境较差或需要频繁拉取镜像的情况下。以下是一个详细的配置步骤。
1. 确定要使用的镜像源 首先，你需要选择一个或多个镜像源。以下是一些常见的Docker镜像源：
中国官方镜像：https://registry.docker-cn.com网易163镜像：http://hub-mirror.c.163.com中科大镜像：https://docker.mirrors.ustc.edu.cn阿里云镜像：https://[xxx].mirror.aliyuncs.com （注意这里的[xxx]是阿里云提供的唯一标识符，需要根据你的阿里云账号来获取）文档： https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors 2. 配置Docker的镜像源 2.1 修改Docker配置文件 Docker的配置文件通常位于/etc/docker/daemon.json。如果该文件不存在，你需要手动创建它。
使用文本编辑器（如vim或nano）打开或创建该文件：
sudo vim /etc/docker/daemon.json 2.2 添加镜像源地址 在打开的文件中，添加或修改"registry-mirrors"配置项，将你要使用的镜像源地址放入列表中。例如：
{ "registry-mirrors": [ "https://registry.docker-cn.com", "http://hub-mirror.c.163.com", "https://docker.mirrors.ustc.edu.cn" // 你可以继续添加其他镜像源地址.... ] } 2.3 保存并退出编辑器 在vim中，你可以按Esc键退出编辑模式，然后输入:wq保存并退出。
2.4 重启Docker服务 为了让配置生效，你需要重启Docker服务。这里提供两种重启方法：
使用systemctl命令： sudo systemctl daemon-reload sudo systemctl restart docker 使用service命令（在某些系统中可能可用）： sudo service docker restart 3. 验证配置是否成功 重启Docker服务后，你可以使用以下命令来验证配置是否成功：
sudo docker info 在输出信息中，你应该能看到"Registry Mirrors"部分，并且列出了你添加的镜像源地址。
注意事项 确保你的Docker版本支持镜像源配置。如果你使用的是阿里云或其他云服务提供商提供的镜像加速器，你可能需要登录到你的云服务控制台来获取唯一的镜像加速器地址。镜像源的配置可能会因为网络环境的变化而需要更新。如果发现镜像拉取速度变慢或无法拉取，可以考虑更换或添加其他镜像源。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0217bdf62cada5c9e46e6f3760e60972/" rel="bookmark">
			Vue 3获取DOM元素的大小以及相对于视口的位置的getBoundingClientRect属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Vue 3中，可以使用ref来获取DOM元素的getBoundingClientRect属性。
如果元素已挂载，我们使用 getBoundingClientRect 方法来获取元素的位置和大小信息。这个方法返回一个对象，其中包含了 left、top、right、bottom 等属性，这些属性表示元素相对于其最近的滚动祖先（通常是视口）的位置。
这里是一个简单的例子：
&lt;template&gt; &lt;div ref="boxRef"&gt;Hello World&lt;/div&gt; &lt;/template&gt; &lt;script setup&gt; import { ref, onMounted } from 'vue'; const boxRef = ref(null); //创建一个响应式引用boxRef，它将指向div元素 //在onMounted钩子中，我们确保当组件挂载后获取这个元素的getBoundingClientRect属性。这个属性包含了元素的大小以及相对于视口的位置。 onMounted(() =&gt; { if (boxRef.value) { const rect = boxRef.value.getBoundingClientRect(); console.log(rect); } }); &lt;/script&gt; 如果你想要监听元素上的右键点击事件，并获取该元素的位置，你可以使用@contextmenu.prevent来监听右键点击事件，并使用getBoundingClientRect方法来获取元素的位置。
这里是如何实现的一个例子：
&lt;template&gt; &lt;div ref="myElement" @contextmenu.prevent="handleRightClick"&gt; 右键点击我 &lt;/div&gt; &lt;/template&gt; &lt;script setup&gt; import { ref } from 'vue'; const myElement = ref(null); function handleRightClick(event) { if (myElement.value) { //获取了元素的位置信息rect，它包含了元素相对于视口的位置和大小。 //使用event.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0217bdf62cada5c9e46e6f3760e60972/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27e0857863133ae84ef6f2ccf7837f6f/" rel="bookmark">
			【MySQL】索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		索引 1.初识索引2.认识磁盘3.MySQL 与磁盘交互基本单位4.建立共识5.索引的理解6.索引操作7.全文索引 点赞👍👍收藏🌟🌟关注💖💖
你的支持是对我最大的鼓励，我们一起努力吧!😃😃
1.初识索引 没有索引，可能会有什么问题？
索引：提高数据库的性能，索引是物美价廉的东西了。不用加内存，不用改程序，不用调sql，只要执行正确的 create index ，查询速度就可能提高成百上千倍。但是天下没有免费的午餐，查询速度的提高是以插入、更新、删除的速度为代价的，这些写操作，增加了大量的IO。所以它的价值，在于提高一个海量数据的检索速度。
所有mysql的CURD操作全部都是在mysql的内存中进行的，mysql在启动的是会预先开辟一大块空间，开辟好空间之后在合适的时候把数据对应CURD操作体现在内存级，然后mysql会定期把数据刷新到磁盘中做持久化。换言之MySQL的服务器，本质是在内存中的，所有的数据库的CURD操作，全部都是在内存中进行的！ 索引也是如此
索引是提高效率的，一般我们知道提高算法效率的因素：1. 组织数据的方式 ，2. 算法本身。索引是更改特定组织数据的方式，把以前数据的组织方式以新的数据结构组织起来。所以索引是内存中一种特定结构组织的一种结构，具体是什么结构后面再说，
常见索引分为：
主键索引(primary key)唯一索引(unique)普通索引(index)全文索引(fulltext)–解决中子文索引问题。 下面见识一下索引
先整一个海量表，在查询的时候，看看没有索引时有什么问题？
--构建一个8000000条记录的数据 --构建的海量表数据需要有差异性，所以使用存储过程来创建， 拷贝下面代码就可以了，暂时不用理解 -- 产生随机字符串 delimiter $$ create function rand_string(n INT) returns varchar(255) begin declare chars_str varchar(100) default 'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ'; declare return_str varchar(255) default ''; declare i int default 0; while i &lt; n do set return_str =concat(return_str,substring(chars_str,floor(1+rand()*52),1)); set i = i + 1; end while; return return_str; end $$ delimiter ; --产生随机数字 delimiter $$ create function rand_num() returns int(5) begin declare i int default 0; set i = floor(10+rand()*500); return i; end $$ delimiter ; --创建存储过程，向雇员表添加海量数据 delimiter $$ create procedure insert_emp(in start int(10),in max_num int(10)) begin declare i int default 0; set autocommit = 0; repeat set i = i + 1; insert into EMP values ((start+i) ,rand_string(6),'SALESMAN',0001,curdate(),2000,400,rand_num()); until i = max_num end repeat; commit; end $$ delimiter ; -- 执行存储过程，添加8000000条记录 call insert_emp(100001, 8000000); 到此，已经创建出了海量数据的表了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27e0857863133ae84ef6f2ccf7837f6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/108d9078e1571fda80b633da2382dc4f/" rel="bookmark">
			【递归、搜索与回溯】综合练习一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		综合练习一 1.找出所有子集的异或总和再求和2.全排列 II3.电话号码的字母组合4.括号生成 点赞👍👍收藏🌟🌟关注💖💖
你的支持是对我最大的鼓励，我们一起努力吧!😃😃
1.找出所有子集的异或总和再求和 题目链接：1863. 找出所有子集的异或总和再求和
题目描述：
先找出所有子集，然后把每个子集异或的和加起来返回去。
算法原理：
这道题和我们上一道思路完全是一模一样，
先画出决策树设计代码
全局变量
递归函数
细节：回溯、剪枝、递归出口 因为我们有上一道题的基础，我们直接就画出决策树
这里我们需要两个全局变量，一个path记录到沿途每个子集的异或，然后sum负责每个字节的异或和加起来。dfs函数，还是需要一个pos记录当前异或的位置，dfs(nums,pos)，回溯利用异或的规则，两个相同的数异或为0。这里也没有剪枝， 递归出口 循环结束就是递归出口。
class Solution { int sum=0; int path=0; public: int subsetXORSum(vector&lt;int&gt;&amp; nums) { dfs(nums,0); return sum; } void dfs(vector&lt;int&gt;&amp; nums,int pos) { sum+=path; for(int i=pos;i&lt;nums.size();++i) { path^=nums[i]; dfs(nums,i+1); path^=nums[i]; // 恢复现场 } } }; 2.全排列 II 题目链接：47. 全排列 II
题目分析：
重复的数全排列后会有重复的结果，这道题就是要求去掉重乎之后的全排列
算法原理：
这道题几乎和全排列1 一模一样，我们就不在细说那些决策树怎么画，代码应该怎么写等等。这里主要就是剪枝的问题。
下面我们边画决策树变分析问题，把全排列所有不重复不漏的情况画出来，越详细越好。 我们只用关心四个位置，每个位置每次从数组中4个数选择一个树放到一个位置上就行了。只用选四次就行了。
第一次可以选第一个1、第二个1、第三个1、2，但是注意这里就存在剪枝的问题了，如果第一个位置还把第二个1和第三个1选上，此时就会存在重复问题！因为后面三个位置是从112中选的。
此时就出现了第一种剪枝情况
同一个节点的所有分支中，相同的元素只能选择一次
然后我们再往下走，第二个位置也可以从数组中4个数字中选任意一个。但是第一个1我们要把它剪掉，因为第一个位置已经把第一个1选过了，只能选一次。此时就有了第二种剪枝情况，这个是和全排列1一模一样的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/108d9078e1571fda80b633da2382dc4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32de81c53fc1077cbb27ac65410244ab/" rel="bookmark">
			【大数据】Spark使用大全:下载安装、RDD操作、JAVA编程、SQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
1.下载安装
2.RDD操作
3.JAVA编程示例
4.Spark SQL
前言 本文是作者大数据系列中的一文，专栏地址：
https://blog.csdn.net/joker_zjn/category_12631789.html?spm=1001.2014.3001.5482
该系列会成体系的聊一聊整个大数据的技术栈，绝对干货，欢迎订阅。
1.下载安装 前置环境：
Hadoop 3.1.3Java JDK 1.8 下载地址：
Downloads | Apache Spark
往下拉找到Spark release archives.
由于前面我们已经搭建好了hadoop环境，所以这里选择with out hadoop的版本。
配置config目录下有一个配置模板spark-env.sh.template:
将这个模板修改或者复制为spark-env.sh然后在里面：
export SPARK_DIST_CLASSPATH=${Hadoop的安装路径/bin classpath}
因为Spark只是个计算引擎，具体要去操作对应的分部署文件系统的，所以将Spark的类路径指向了hadoop。也就是通过这个配置将Spark要操作的数据源设置为了HDFS。
启动：
bin目录下：
./run-exmaple SparkPi
这是一个Spark自带的demo，如果跑起来不报错，说明就没什么问题了。
2.RDD操作 可以用Spark自带的Spark shell来进行RDD操作：
./bin/spark-shell
RDD操作分为两类：
转换，就是只是返回中间数据集的操作。动作，就是有具体单个返回值的操作。 map - 应用于RDD的每个元素，产生一个新的RDD。
val numbersRdd = spark.sparkContext.parallelize(Array(1, 2, 3, 4))
val squaredRdd = numbersRdd.map(x =&gt; x * x) filter - 根据函数条件过滤RDD中的元素。
val evenNumbersRdd = numbersRdd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32de81c53fc1077cbb27ac65410244ab/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/270/">«</a>
	<span class="pagination__item pagination__item--current">271/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/272/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>