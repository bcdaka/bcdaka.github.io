<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0412d21cf98a73f4d8b624cd58a28cdc/" rel="bookmark">
			AI时代架构设计新模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		云原生架构原则 云原生架构本身作为一种架构，也有若干架构原则作为应用架构的核心架构控制面，通过遵从这些架构原则可以让技术主管和架构师在做技术选择时不会出现大的偏差。
服务化原则 当代码规模超出小团队的合作范围时，就有必要进行服务化拆分了，包括拆分为微服务架构、小服务( Mini Service)架构，通过服务化架构把不同生命周期的模块分离出来，分别进行业务迭代，避免迭代频繁模块被慢速模块拖慢，从而加快整体的进度和稳定性。同时服务化架构以面向接口编程，服务内部的功能高度内聚，模块间通过公共功能模块的提取增加软件的复用程度。
分布式环境下的限流降级、熔断隔仓、灰度、反压、零信任安全等，本质上都是基于服务流量（而非网络流量）的控制策略，所以云原生架构强调使用服务化的目的还在于从架构层面抽象化业务模块之间的关系，标准化服务流量的传输，从而帮助业务模块进行基于服务流量的策略控制和治理，不管这些服务是基于什么语言开发的。
弹性原则 大部分系统部署上线需要根据业务量的估算，准备一定规模的机器，从提出采购申请，到供应商洽谈、机器部署上电、软件部署、性能压测，往往需要好几个月甚至一年的周期;而这期间如果业务发生变化了，重新调整也非常困难。弹性则是指系统的部署规模可以随着业务量的变化自动伸缩，无须根据事先的容量规划准备固定的硬件和软件资源。好的弹性能力不仅缩短了从采购到上线的时间，让企业不用操心额外软硬件资源的成本支出（闲置成本），降低了企业的IT成本，更关键的是当业务规模面临海量突发性扩张的时候，不再因为平时软硬件资源储备不足而“说不”，保障了企业收益。
可观测原则 今天大部分企业的软件规模都在不断增长，原来单机可以对应用做完所有调试，但在分布式环境下需要对多个主机上的信息做关联，才可能回答清楚服务为什么宕机、哪些服务违反了其定义的SLO、目前的故障影响哪些用户、最近这次变更对哪些服务指标带来了影响等等，这些都要求系统具备更强的可观测能力。可观测性与监控、业务探活、APM等系统提供的能力不同，前者是在云这样的分布式系统中，主动通过日志、链路跟踪和度量等手段，让一次APP点击背后的多次服务调用的耗时、返回值和参数都清晰可见，甚至可以下钻到每次三方软件调用、SQL请求、节点拓扑、网络响应等，这样的能力可以使运维、开发和业务人员实时掌握软件运行情况，并结合多个维度的数据指标，获得前所未有的关联分析能力，不断对业务健康度和用户体验进行数字化衡量和持续优化。
韧性原则 当业务上线后，最不能接受的就是业务不可用，让用户无法正常使用软件，影响体验和收入。韧性代表了当软件所依赖的软硬件组件出现各种异常时,软件表现出来的抵御能力,这些异常通常包括硬件故障、硬件资源瓶颈(如CPU/网卡带宽耗尽）、业务流量超出软件设计能力、影响机房工作的故障和灾难、软件 bug、黑客攻击等对业务不可用带来致命影响的因素。
韧性从多个维度诠释了软件持续提供业务服务的能力，核心目标是提升软件的MTBF ( Mean TimeBetween Failure，平均无故障时间)。从架构设计上，韧性包括服务异步化能力、重试/限流/降级/熔断Ⅰ反压、主从模式、集群模式、AZ内的高可用、单元化、跨region容灾、异地多活容灾等。
所有过程自动化原则 技术往往是把“双刃剑”，容器、微服务、DevOps、大量第三方组件的使用，在降低分布式复杂性和提升迭代速度的同时，因为整体增大了软件技术栈的复杂度和组件规模，所以不可避免地带来了软件交付的复杂性，如果这里控制不当，应用就无法体会到云原生技术的优势。通过 laC ( lnfrastructure asCode ) . GitOps、OAM (Open Application Model ) . Kubernetes operator和大量自动化交付工具在CIICD流水线中的实践，一方面标准化企业内部的软件交付过程，另一方面在标准化的基础上进行自动化，通过配置数据自描述和面向终态的交付过程，让自动化工具理解交付目标和环境差异，实现整个软件交付和运维的自动化。
零信任原则 零信任安全针对传统边界安全架构思想进行了重新评估和审视，并对安全架构思路给出了新建议。其核心思想是，默认情况下不应该信任网络内部和外部的任何人/设备/系统，需要基于认证和授权重构访问控制的信任基础，诸如IP地址、主机、地理位置、所处网络等均不能作为可信的凭证。零信任对访问控制进行了范式上的颠覆，引导安全体系架构从“网络中心化”走向“身份中心化”，其本质诉求是以身份为中心进行访问控制。
零信任第一个核心问题就是ldentity，赋予不同的Entity 不同的 Identity，解决是谁在什么环境下访问某个具体的资源的问题。在研发、测试和运维微服务场景下，ldentity 及其相关策略不仅是安全的基础,更是众多（资源，服务，环境）隔离机制的基础;在员工访问企业内部应用的场景下，ldentity 及其相关策略提供了灵活的机制来提供随时随地的接入服务。
架构持续演进原则 今天技术和业务的演进速度非常快，很少有一开始就清晰定义了架构并在整个软件生命周期里面都适用，相反往往还需要对架构进行一定范围内的重构，因此云原生架构本身也应该和必须是一个具备持续演进能力的架构，而不是一个封闭式架构。除了增量迭代、目标选取等因素外，还需要考虑组织（例如架构控制委员会）层面的架构治理和风险控制，特别是在业务高速迭代情况下的架构、业务、实现平衡
关系。云原生架构对于新建应用而言的架构控制策略相对容易选择(通常是选择弹性、敏捷、成本的维度)，但对于存量应用向云原生架构迁移，则需要从架构上考虑遗留应用的迁出成本/风险和到云上的迁入成本/风险，以及技术上通过微服务Ⅰ应用网关、应用集成、适配器、服务网格、数据迁移、在线灰度等应用和流量进行细颗粒度控制。
图书推荐 关键点 1.架构设计新模式：让架构设计更高效、更快捷、更完美。
2.全流程解析：涵盖架构设计的不同应用场景，介绍从编写各种文档，到应用图形图表与UML建模、设计模式、数据库设计，再到编写代码、开发软件架构等关键环节。
3.实战检验：ChatGPT结合多种架构设计工具及案例实操讲解，理解更加透彻。
4.100%提高架构设计效率：揭秘ChatGPT与架构设计高效融合的核心方法论和实践经验。
5.超值资源：赠送教学视频及配套工具，供读者下载学习。
内容简介 本书是一本旨在帮助架构师在人工智能时代展翅高飞的实用指南。全书以ChatGPT为核心工具，揭示了人工智能技术对架构师的角色和职责进行颠覆和重塑的关键点。本书通过共计 13 章的系统内容，深入探讨AI技术在架构
设计中的应用，以及AI对传统架构师工作方式的影响。通过学习，读者将了解如何利用ChatGPT这一强大的智能辅助工具，提升架构师的工作效率和创造力。
本书的读者主要是架构师及相关从业人员。无论你是初入职场的新手架构师还是经验丰富的专业人士，本书都将成为你的指南，帮助你在人工智能时代展现卓越的架构设计能力。通过本书的指导，你将学习如何运用ChatGPT等工具和技术，以创新的方式构建高效、可靠、可扩展的软件架构。
同时，本书也适用于对架构设计感兴趣的其他技术类从业人员，如软件工程师、系统分析师、技术顾问等。通过学习本书的内容，你可以深入了解人工智能对架构设计的影响和带来的挑战，拓展自己的技术视野，提升对软件系统整体架构的理解和把握能力。
作者简介 关东升，一个在IT领域摸爬滚打20多年的老程序员、知名培训专家、畅销书作家，精通多种信息技术。曾参与设计和开发北京市公交一卡通系统、国家农产品追溯系统、金融系统微博等移动客户端项目，并在App Store发布多款游戏和应用软件。长期为中国移动、中国联通、中国南方航空、中国工商银行和天津港务局等企事业单位提供培训服务。先后出版了50多部IT图书，广受读者欢迎。
当当网链接
京东的链接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0da3a7b55e8a7e3822bee0a89550c16f/" rel="bookmark">
			【Spring】Spring的循环依赖以及解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 什么是Spring循环依赖？ ​ Spring循环依赖指的是两个或多个Bean之间相互依赖，形成一个环状依赖的情况。通俗的说，就是A依赖B，B依赖C，C依赖A，这样就形成了一个循环依赖的环。
​ Spring循环依赖通常会导致Bean无法正确地被实例化，从而导致应用程序无法正常启动或者出现异常。因此，Spring循环依赖是一种需要尽量避免的情况。
2. 常见形成原因 1. 构造函数循环依赖 ​ 在使用构造函数注入Bean时，如果两个Bean之间相互依赖，就可能会形成构造函数循环依赖，例如：
@Component public class A { private B b; public A(B b) { this.b = b; }} ============== @Component public class B { private A a; public B(A a) { this.a = a; }} 上述代码，A、B的构造函数分别需要创建对方，A依赖B，B依赖A，它们之间形成了一个循环依赖。
当Spring容器启动时，它会尝试先实例化A，但是在实例化A的时候需要先实例化B，而实例化B的时候需要先实例化A，这样就形成了一个循环依赖的死循环，从而导致应用程序无法正常启动。
2. 属性循环依赖 ​ 在使用属性注入Bean时，如果两个Bean之间相互依赖，就可能会形成属性循环依赖。例如：
@Component public class A { @Autowired private B b; } ============= @Component public class B { @Autowired private A a; } 类似的，同样Spring在实例化A时会注入B，而注入B时又需要注入A，形成循环依赖
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0da3a7b55e8a7e3822bee0a89550c16f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9887d116c6aeb797779d52a56b3e748/" rel="bookmark">
			SpringBoot集成Flowable工作流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、了解Flowable1. 什么是Flowable2. Flowable基本流程3. Flowable主要几张表介绍 二、SpringBoot集成Flowable1. 在idea中安装Flowable插件2. SpringBoot集成Flowable3. SpringBoot集成Flowable前端页面 三、创建流程模版(以请假为例) 提示：以下是本篇文章正文内容，下面案例可供参考
一、了解Flowable 1. 什么是Flowable Flowable下载
Flowable源码GitHub下载
Flowable用户使用手册
Flowable是一个使用Java编写的轻量级业务流程引擎。Flowable流程引擎可用于部署BPMN 2.0流程定义（用于定义流程的行业XML标准）， 创建这些流程定义的流程实例，进行查询，访问运行中或历史的流程实例与相关数据，等等。
具体介绍请看Flowable介绍
2. Flowable基本流程 参考知乎Flowable工作流引擎
对于业务建模，我们需要一种通用的语言来描绘，这样在沟通上和实现上会降低难度，就像中文、英文一样，BPMN2.0便是一种国际通用的建模语言，他能让自然人轻松阅读，更能被计算机所解析。
协议中元素的主要分类为，事件-任务-连线-网关
一个流程必须包含一个事件（如：开始事件）和至少一个结束（事件）。其中网关的作用是流程流转逻辑的控制。任务则分很多类型，他们各司其职，所有节点均由连线联系起来。
BPMN2.0协议
不同的图标代表不同的含义
网关
互斥网关（Exclusive Gateway） 又称排他网关，他有且仅有一个有效出口，可以理解为if…else if… else if…else，就和我们平时写代码的一样。
并行网关（Parallel Gateway） 他的所有出口都会被执行，可以理解为开多线程同时执行多个任务。
包容性网关（Inclusive Gateway）
只要满足条件的出口都会执行，可以理解为 if(…) do, if (…) do, if (…)
do，所有的条件判断都是同级别的。
任务
人工任务（User Task）
它是使用得做多的一种任务类型，他自带有一些人工任务的变量，例如签收人（Assignee），签收人就代表该任务交由谁处理，我们也可以通过某个特定或一系列特定的签收人来查找待办任务。利用上面的行为解释便是，当到达User
Task节点的时候，节点设置Assignee变量或等待设置Assignee变量，当任务被完成的时候，我们使用Trigger来要求流程引擎退出该任务，继续流转。
服务任务（Service Task）
该任务会在到达的时候执行一段自动的逻辑并自动流转。从“到达自动执行一段逻辑”这里我们就可以发现，服务任务的想象空间就可以非常大，我们可以执行一段计算，执行发送邮件，执行RPC调用，而使用最广泛的则为HTTP调用，因为HTTP是使用最广泛的协议之一，它可以解决大部分第三方调用问题，在我们的使用中，HTTP服务任务也被我们单独剥离出来作为一个特殊任务节点。
接受任务（Receive Task） 该任务的名字让人费解，但它又是最简单的一种任务，当该任务到达的时候，它不做任何逻辑，而是被动地等待Trigger，它的适用场景往往是一些不明确的阻塞，比如：一个复杂的计算需要等待很多条件，这些条件是需要人为来判断是否可以执行，而不是直接执行，这个时候，工作人员如果判断可以继续了，那么就Trigger一下使其流转。
结构
调用活动（Call Activity）
调用活动可以理解为函数调用，它会引用另外一个流程使之作为子流程运行，调用活动跟函数调用的功能一样，使流程模块化，增加复用的可能性。
3. Flowable主要几张表介绍 Flowable在项目启动的时候会自动创建表，以下是主要几张表介绍
ACT_RU_TASK： 每次启动的流程都会再这张表中,表示代办项, 流程结束会删除该流程数据ACT_RU_EXECUTION： 流程执行过程表, 会存该流程正在执行的过程数据, 流程结束会删除该流程数据ACT_RU_VARIABLE： 流程变量表, 流程中传的参数都会再该表存储, 流程结束会删除该流程数据ACT_HI_PROCINST： 历史运行流程, 当流程处理完了, 在ACT_RU_* 表中就不会有数据, 可以在该表中查询历史ACT_HI_TASKINST： 历史运行的task信息,ACT_RE_PROCDEF： 流程模板记录,同一个key多次发布version_字段会递增ACT_RE_DEPLOYMENT： 部署的流程模板, 可以启动流程使用的 二、SpringBoot集成Flowable 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9887d116c6aeb797779d52a56b3e748/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/057161bc7d15176eb2b6d5d565c15f78/" rel="bookmark">
			基于LLaMA-Factory的微调记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 数据模型准备基于网页的简单微调基于网页的简单评测基于网页的简单聊天基于网页的模型合并微调问题测试与解决问题测试模板修改强化训练持续训练单数据集训练微调总结 LLaMA-Factory是一个非常好用的无代码微调框架，不管是在模型、微调方式还是参数设置上都提供了非常完备的支持，下面是对微调全过程的一个记录。 数据模型准备 微调时一般需要准备三个数据集：一个是自我认知数据集（让大模型知道自己是谁），一个是特定任务数据集（微调时需要完成的目标任务），一个是通用任务数据集（保持大模型的通用能力，防止变傻）。前两个一般要自己定义，最后一个用现成的就行。
自定义数据集可采用alpaca和sharegpt格式，这里采用的是alpaca格式：
[ { "instruction": "用户指令（必填）", "input": "用户输入（选填）", "output": "模型回答（必填）", "system": "系统提示词（选填）", "history": [ ["第一轮指令（选填）", "第一轮回答（选填）"], ["第二轮指令（选填）", "第二轮回答（选填）"] ] } ] 由于不需要考虑多轮对话，所以history可以不要，这里采用了两种数据集的组织方式，一种是只有instruction和output，把问题作为instruction，另外一种是把问题作为input，把回答问题这一要求作为instruction。这两种格式分别记为format2和format3。
在根据若干个不同的专业领域生成完多个自定义的问答json文件之后，分别生成其format2和format3的文件以及test测试文件，根据以下代码计算其sha1值：
import hashlib def calculate_sha1(file_path): sha1 = hashlib.sha1() try: with open(file_path, 'rb') as file: while True: data = file.read(8192) # Read in chunks to handle large files if not data: break sha1.update(data) return sha1.hexdigest() except FileNotFoundError: return "File not found." # 使用示例 file_path = '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/057161bc7d15176eb2b6d5d565c15f78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ef35c8aa53ef073d9a9128cdd1ab9f5/" rel="bookmark">
			Android中 Gradle与 AGP 版本对应关系表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、对照表 Android Gradle Plugin Version版本Gradle Version版本1.0.0 - 1.1.32.2.1 - 2.31.2.0 - 1.3.12.2.1 - 2.91.5.02.2.1 - 2.132.0.0 - 2.1.22.10 - 2.132.1.3 - 2.2.32.14.1+2.3.0+3.3+3.0.0+4.1+3.1.0+4.4+3.2.0 - 3.2.14.6+3.3.0 - 3.3.34.10.1+3.4.0 - 3.4.35.1.1+3.5.0 - 3.5.45.4.1+3.6.0 - 3.6.45.6.4+4.0.0+6.1.1+4.1.0+6.5+4.2.0+6.7.1+7.07.0+7.17.2+7.27.3.3+7.37.4+7.47.5+8.08.0+8.18.0+ 2、AGP版本 AGP版本查看
官网也会弄说明 当前AGP 对应的 Gradle版本的
3、Gradle版本 Gradle版本查看
4、Android配置Gradle和AGP （1）配置 Gradle 版本 目录：项目/gradle/wrapper/gradle-wrapper.properties
gradle-wrapper.properties distributionBase=GRADLE_USER_HOME distributionPath=wrapper/dists zipStoreBase=GRADLE_USER_HOME zipStorePath=wrapper/dists distributionUrl=https\://services.gradle.org/distributions/gradle-6.1.1-all.zip 配置本地 distributionUrl distributionUrl=file:///Users/leon/Library/gradle-6.1.1-all.zip （2）配置 AGP 版本 目录：项目/build.gradle buildscript { repositories { // google() // jcenter() maven { url 'https://maven.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ef35c8aa53ef073d9a9128cdd1ab9f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/449333f729826b2395b3675e83c09ddb/" rel="bookmark">
			超级实用！Android Studio的10大神器插件，让你的开发效率翻倍！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		超级实用！Android Studio的10大神器插件，让你的开发效率翻倍！ Android Studio是一款功能强大的集成开发环境（IDE），专为Android应用程序开发而设计。它提供了丰富的工具和功能，使开发者能够轻松创建高质量的Android应用。除了内置的功能外，Android Studio还支持插件系统，允许开发者根据自己的需求进行定制和扩展。在这篇文章中，我们将介绍Android Studio最受欢迎的10款插件，并详细探讨它们的功能和用途。
1. ADB Idea ADB Idea是一款非常实用的插件，它简化了与Android设备进行调试和交互的过程。该插件集成了Android Debug Bridge（ADB）工具，使开发者能够通过简单的菜单选项执行各种ADB命令。例如，您可以使用ADB Idea安装、卸载、复制文件、查看日志等操作，而无需手动输入命令。此外，该插件还提供了一个方便的ADB Shell窗口，允许直接在Android设备上执行命令。
2. Android Drawable Importer Android Drawable Importer是一款非常实用的插件，旨在帮助开发者快速导入和管理Android应用中的图像资源。它支持多种图像格式，包括PNG、JPEG和SVG，并自动生成适应不同屏幕密度的drawable资源。使用该插件，您可以轻松导入图像文件，并自动为其生成相应的drawable资源，无需手动处理不同分辨率的图片。
3. CodeGlance CodeGlance是一款非常方便的插件，它为Android Studio编辑器添加了一个小的代码缩略图。该缩略图位于编辑器右侧，显示整个代码文件的概览。通过CodeGlance，开发者可以快速浏览代码，并迅速定位到感兴趣的部分。该插件支持多种主题和自定义选项，以满足不同开发者的个性化需求。
4. Android Material Design Icon Generator Android Material Design Icon Generator是一款帮助开发者创建符合Material Design风格的图标资源的插件。Material Design是一种现代化的设计语言，被广泛应用于Android应用的界面设计中。该插件提供了一个简单易用的界面，允许开发者根据自己的需求选择图标尺寸和密度，并自动生成相应的图标资源。使用该插件，开发者可以快速创建符合Material Design规范的图标，提升应用的用户体验。
5. FindBugs-IDEA FindBugs-IDEA是一款帮助开发者检测代码中潜在缺陷和错误的插件。该插件基于FindBugs工具，提供了多种检测规则和建议修复方案。它可以帮助开发者发现常见的代码问题，如空指针引用、资源未关闭等，并在编辑器中进行标记和提示。通过使用FindBugs-IDEA，开发者可以提前捕捉潜在的问题，改善代码质量和可靠性。
6. Android Parcelable code generator Android Parcelable code generator是一款帮助开发者自动生成Parcelable实现代码的插件。Parcelable是一种Android特有的序列化机制，用于在不同组件之间传递对象。手动实现Parcelable接口通常需要编写大量的重复代码，而使用该插件，开发者只需选择要包含在Parcelable类中的字段，然后自动为其生成相应的代码。这极大地简化了Parcelable的实现过程，提高了开发效率。
7. JSON To Dart JSON to Dart是一款帮助开发者在Flutter和Dart项目中快速生成Dart类的插件。在移动应用开发中，从服务器请求数据并将其解析为对象是一个常见的任务。JSON to Dart插件通过分析给定的JSON数据结构，自动生成相应的Dart类和相关的序列化/反序列化代码。它支持嵌套的JSON结构，能够识别内部类，并生成一个单独的Dart文件。使用JSON to Dart，开发者可以节省大量手动编写和维护代码的时间和精力。
8. Android Input Android Input是一款简化在Android设备或模拟器上输入文本的插件。在开发过程中，经常需要测试应用在真实设备上的输入功能，例如表单输入、搜索等。Android Input插件允许开发者通过一个简单的对话框快速输入文本，并将其发送到设备上。插件记住了最后使用的设备，因此您无需每次都选择设备。同时，它还记住了您上次发送的文本，方便再次使用。如果不想发送任何文本，只需按下ESC键即可关闭对话框。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/449333f729826b2395b3675e83c09ddb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/259b476df06abd678866f07fd914dc45/" rel="bookmark">
			RabbitMQ——基于 KeepAlived &#43; HAProxy 搭建 RabbitMQ 高可用负载均衡集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、集群简介 1.1 集 群架构
当单台 RabbitMQ 服务器的处理消息的能力达到瓶颈时，此时可以通过 RabbitMQ 集群来进行扩展，从而达到提升吞吐量的目的。
RabbitMQ 集群是一个或多个节点的逻辑分组，集群中的每个节点都是对等的，每个节点共享所有的用户，虚拟主机，队列，交换器，绑定关系，运行时参数和其他分布式状态等信息。一个高可用，负载均衡的 RabbitMQ 集群架构应类似下图： 这里对上面的集群架构做一下解释说明：
首先，一个基本的 RabbitMQ 集群不是高可用的，虽然集群共享队列，但在默认情况下，消息只会被路由到某一个节点的符合条件的队列上，并不会同步到其他节点的相同队列上。假设消息路由到 node1 的 my-queue 队列上，但是 node1 突然宕机了，那么消息就会丢失，想要解决这个问题，需要开启队列镜像，将集群中的队列彼此之间进行镜像，此时消息就会被拷贝到处于同一个镜像分组中的所有队列上。
其次 ，RabbitMQ 集群本身并没有提供负载均衡的功能，也就是说对于一个三节点的集群，每个节点的负载可能都是不相同的，想要解决这个问题可以通过硬件负载均衡或者软件负载均衡的方式，这里我们选择使用 HAProxy 来进行负载均衡，当然也可以使用其他负载均衡中间件，如 LVS 等。HAProxy 同时支持四层和七层负载均衡，并基于单一进程的事件驱动模型，因此它可以支持非常高的井发连接数。
接着，假设我们只采用一台 HAProxy ，那么它就存在明显的单点故障的问题，所以至少需要两台 HAProxy ，同时这两台 HAProxy 之间需要能够自动进行故障转移，通常的解决方案就是 KeepAlived 。KeepAlived 采用 VRRP (Virtual Router Redundancy Protocol，虚拟路由冗余协议) 来解决单点失效的问题，它通常由一组一备两个节点组成，同一时间内只有主节点会提供对外服务，并同时提供一个虚拟的 IP 地址(Virtual Internet Protocol Address ，简称 VIP) 。 如果主节点故障，那么备份节点会自动接管 VIP 并成为新的主节点 ，直到原有的主节点恢复。
最后，任何想要连接到 RabbitMQ 集群的客户端只需要连接到虚拟 IP，而不必关心集群是何种架构，示例如下：
ConnectionFactory factory = new ConnectionFactory(); // 假设虚拟ip为 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/259b476df06abd678866f07fd914dc45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e037395ddaec01c259911c5666c4e780/" rel="bookmark">
			mongodb数据库集合（表）的创建和数据修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言发现宝藏一、集合的创建二、集合的修改三、数据插入数据库四、清空数据库集合数据 前言 为了巩固所学的知识，作者尝试着开始发布一些学习笔记类的博客，方便日后回顾。当然，如果能帮到一些萌新进行新技术的学习那也是极好的。作者菜菜一枚，文章中如果有记录错误，欢迎读者朋友们批评指正。
（博客的参考源码可以在我主页的资源里找到，如果在学习的过程中有什么疑问欢迎大家在评论区向我提出）
发现宝藏 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。【宝藏入口】。
一、集合的创建 一、版面集合： catalogues 主键id(数据类型为整形） 关键字：keywords（数据类型为字符串） isFuzzy: 0 搜索位置：searchArea（数据类型为字符串） 时间筛选：year（数据类型为时间类） 类型：form（数据类型为字符串） 领域：type（数据类型为字符串） 第几页：page（数据类型为整型） 来源:origin（数据类型为字符串） source: 2 更新时间：updateTime（数据类型为时间类） 二、内容 cards 主键：id (数据类型为整形） 标题：title 来源: origin 原始网页html dom结构：htmlcontent 清洗后的html dom结构：content 第几页：page（数据类型为字符串） 搜索位置：searchArea（数据类型为字符串） 时间筛选：year（数据类型为时间类） 类型：form（数据类型为字符串） 领域：type（数据类型为字符串） 地址：url（数据类型为字符串） 内容图片存储的位置：illustrations（数据类型为数组） 更新时间：updateTime（数据类型为时间类） 为了生成 MongoDB 数据库，你首先需要安装 MongoDB 数据库服务器，并确保你的 Python 环境中安装了 PyMongo，这是 MongoDB 官方提供的 Python 驱动程序。
接下来，你可以按照以下步骤创建一个 Python 脚本来实现数据库的创建和数据插入：
1.安装 MongoDB：在你的机器上安装 MongoDB 数据库服务器。你可以从 MongoDB 官方网站下载安装程序并按照说明进行安装。
’
2.安装 PyMongo：在你的 Python 环境中安装 PyMongo 包。你可以通过 pip 进行安装：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e037395ddaec01c259911c5666c4e780/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb93c9b51f6b35c0f685506fb666636b/" rel="bookmark">
			【学习笔记】树上差分总结(点差分/边差分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.树上差分的基本概念 1.树上差分的定义 树上差分，顾名思义，意思就是在树上做差分。
至于什么是差分呢？如果不会的同学，可以先看看我的这篇博客:一维,二维差分の详解（简单易懂）_一维差分-CSDN博客
2.树上差分能解决的问题 树上差分有什么作用？举个例子，如果题目要求对树上的一段路径进行操作，并询问某个点或某条边被经过的次数，树上差分就可以派上用场了。
类比于差分数组,树上差分利用的思想也是前缀和思想。(在这里应该是子树和思想）
树上差分，就是利用差分的性质，对路径上的重要节点进行修改（而不是暴力全改），作为其差分数组的值，最后在求值时，利用dfs遍历求出差分数组的前缀和得出答案，就可以达到降低复杂度的目的。
树上差分时需要求LCA，不会的同学可以先看看我的这篇博客:详解最近公共祖先(LCA)-CSDN博客
树上差分一般有两种类型的题目，一种是对边进行差分，另一种就是对点进行差分。
下面我将会分别讲解一下这两种问题。
二.点差分 1.思路 直接去dfs暴力加点权的话，肯定会TLE,但是我们现在在讲啥?树上差分啊!
假设需要将两点u,v之间路径上的所有点权增加x,l是lca(u,v),p是l的父亲节点，则差分操作如下：
sum[u] += x; sum[v] += x; sum[l] -= x; sum[p] -= x; 举个栗子(其中假设x=1):
其中s和t就是题目中树上点权需要加1的节点的起始点，绿色的数字代表点权(已经加1了) 则操作后有：
至于为什么要这么操作呢?别急，继续往下看。
做完上述的差分操作后，我们就要统计答案了。
当我们dfs搜索到s，向上回溯。
下面以u表示当前dfs搜索到的节点。
对于每个u统计它的子树大小(要用前缀和的思想记录每个点的点权了)，顺着路径标起来。
(即sum[u] += sum[son])
我们会发现第一次从s回溯到s与t的LCA时候,sum[LCA(s,t)] += sum[son[LCA(s,t)]]
此时sum[LCA(s,t)]=0(-1+1=0)。这时我们不禁会有一个疑问: "不是LCA(s,t)会被经过一次嘛,为什么是0!"
别急,我们继续搜另一边。.
继续：我们搜索到t,向上回溯。
依旧统计每个u的子树大小sum[u]+=sum[son]
再度回到LCA(s,t)，依旧是sum[LCA(s,t)]+=sum[son[LCA(s,t)]]
这个时候 sum[LCA(s,t)]=1 这就达到了我们要的效果 (是不是特别优秀φ(゜▽゜*)♪)
但是我们还要思考一个问题:万一我们再从LCA(s,t)向上回溯的时候使得其父亲节点的子树和为1怎么办?这样我们不就使得其父亲节点被多经过了一次?
其实很简单，我们只需要在前面差分操作时将sum[fa[lca(s,t)]]-=x就行了。
这样就达到了标记我们路径上的点的要求! 是否有一种恍然大悟的感觉呢?
2.例题Max flow 问题 参考代码 #include&lt;bits/stdc++.h&gt; using namespace std; int n,q,mx[300001][41],deep[300001],sum[300001],ans; vector&lt;int&gt; vec[300001]; void dfs(int x,int fa)//lca的初始化 { deep[x] = deep[fa] + 1; mx[x][0] = fa; for(int i = 0;i &lt; vec[x].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb93c9b51f6b35c0f685506fb666636b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f5d884dbb9efa966069bf0971b05549/" rel="bookmark">
			HiveSQL题——collect_set()/collect_list()聚合函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、collect_set() /collect_list()介绍 collect_set()函数与collect_list()函数属于高级聚合函数（行转列），将分组中的某列转换成一个数组返回，常与concat_ws()函数连用实现字段拼接效果。
collect_list：收集并形成list集合，结果不去重
collect_set：收集并形成set集合，结果去重 二、collect_set() /collect_list()有序性 0 问题描述 有一张用户关注表table20，需求：根据用户user_id分组，按照粉丝关注的时间升序排序，输出粉丝id数组和粉丝关注的时间数组，并保障两个数组的数据能一一对应。
1 数据准备 create table if not exists table20 ( user_id int comment '用户id', follow_user_id int comment '粉丝id', update_time string comment '粉丝关注的时间' ) comment '用户关注表'; insert overwrite table table20 values (1, 101,'2021-09-30 10:12:00'), (1, 103,'2021-10-01 11:00:00'), (1, 104,'2021-11-02 10:00:00'), (1, 103,'2021-11-28 10:22:00'), (2, 104,'2021-11-02 10:11:00'), (2, 100,'2021-11-03 10:21:00'), (1, 99,'2021-11-23 12:28:00'); 2 数据分析 方式一： row_number() over(partition by .. order by..) as rn 排序，然后再使用collect_list()/collect_set()进行聚合.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f5d884dbb9efa966069bf0971b05549/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b443d8d8a8290abbcfbfaf00d9a4586b/" rel="bookmark">
			Android 应用添加系统签名权限的几种方式实现介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 应用添加系统签名权限的几种方式实现介绍 文章目录 Android 应用添加系统签名权限的几种方式实现介绍一、前言二、Android 应用添加系统签名权限的几种方式介绍1、在Android Studio添加系统签名文件2、源码编译apk添加系统签名Android.mkAndroid.bp 3、源码编译app代码添加系统签名Android.mkAndroid.bp 三、缺少系统权限报错示例1、设置Settings属性报错2、设置Wifi开关状态失败3、Settings属性设置为啥需要系统权限？4、设置Wifi开关状态为啥失败？ 四、其他1、系统权限介绍（1）普通权限（normal）（2）运行时权限（dangerous）（3）签名权限（signature）（4）特殊权限（privileged） 2、如何查看一个应用的权限情况？3、系统权限级别总结Android中不同应用权限级别从低到高总结场景 4、Android APEX：系统新篇章的应用扁平化技术 一、前言 Android 应用添加系统签名就能获取到系统权限调用一些系统接口，
添加系统签名的方式主要包括：
在Android Studio中配置签名文件生成apk 和 在源码目录编译添加系统签名生成apk。
本文介绍的都是一些基础的签名知识，后续延伸介绍相关权限内容。有兴趣的可以进行了解。
二、Android 应用添加系统签名权限的几种方式介绍 1、在Android Studio添加系统签名文件 源码中生成 jks 签名文件：
https://blog.csdn.net/wenzhi20102321/article/details/134898404
Studio 在对应需要签名的module（默认是app）的build.gradle中添加如下代码：
android { compileSdkVersion 30 buildToolsVersion "30.0.0" compileOptions { sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 } 。。。 //证书信息在这里配置 signingConfigs { main { storeFile file("./platform.jks") //签名文件路径，根目录 storePassword "skg202302" keyAlias "skg" keyPassword "skg202302" } } buildTypes { release { minifyEnabled false signingConfig signingConfigs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b443d8d8a8290abbcfbfaf00d9a4586b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56270ca670e36528d996f387bf095377/" rel="bookmark">
			hive表加字段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.给表添加字段2.为什么使用cascade3.使用场景 1.给表添加字段 alter table database.tablename add columns(字段名 字段类型 comment '字段中文含义') cascade; 2.为什么使用cascade 在Hive中，当你想要修改表结构，例如添加字段时，可能会使用ALTER TABLE语句。在这个过程中，CASCADE关键字的使用具有特定的意义。首先，让我们理解一下基本的ALTER TABLE操作和CASCADE关键字的作用。
ALTER TABLE 基础
在Hive中，ALTER TABLE语句用于修改表的结构，这包括添加字段、重命名字段、更改字段类型等。例如，如果你想要给一个表添加一个新的列，你可能会使用如下的语句：
ALTER TABLE table_name ADD COLUMNS (new_column_name column_type); 这个操作会在表的结构中添加一个新的列，但它不会影响表中已经存在的数据。新添加的列在旧数据中的值将会是NULL。
CASCADE 关键字
CASCADE关键字在Hive的ALTER TABLE操作中用得相对较少，它的主要作用是在修改表结构时级联应用到分区表的所有分区。在大多数情况下，当你对表进行结构更改时，如添加或删除列，这些更改自动应用到所有分区，而无需显式使用CASCADE。
然而，在某些特定的场景下，比如使用复杂的数据类型或者在特定的Hive版本和配置下，CASCADE关键字的使用可能会变得更加重要。其目的是为了确保表结构的更改能够顺利地应用到所有相关的分区，避免因为分区未同步更新而导致的数据不一致或查询错误。
3.使用场景 通常情况下，你不需要在每次使用ALTER TABLE添加字段时都使用CASCADE关键字。但是，在一些特殊情况下，如果你遇到了因为分区未更新导致的问题，或者你的Hive环境有特定的要求，使用CASCADE可能就变得必要了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b434e21944fbeb9a035b17dbca3f9401/" rel="bookmark">
			web 技术栈有哪些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端技术栈： HTML（超文本标记语言）：
用于创建网页结构的标记语言，定义页面的内容和结构。 CSS（层叠样式表）：
用于设计和排版网页的样式表语言，负责页面的外观和样式。 JavaScript：
一种脚本语言，用于在浏览器中实现动态交互和客户端逻辑。常用的前端框架和库如React、Vue、Angular等，可以加速开发。 前端框架和库：
React.js、Vue.js、Angular等，用于简化和加速前端开发，提供组件化、状态管理等功能。 AJAX（异步JavaScript和XML）：
通过在后台与服务器进行异步数据交换，使页面无需重新加载而更新部分内容。 Webpack、Babel等构建工具：
用于打包、编译和转译前端代码，提高开发效率和优化性能。 npm或Yarn：
包管理工具，用于安装、管理和共享前端项目中的依赖。 浏览器开发者工具：
浏览器内置的调试和分析工具，用于检查和优化前端代码。 后端技术栈： 服务器：
例如Node.js、Python（使用Django或Flask框架）、Ruby（使用Ruby on Rails框架）、Java（使用Spring框架）等。 数据库：
常见的数据库包括MySQL、PostgreSQL、MongoDB、Redis等，用于存储和管理应用程序的数据。 后端框架：
Express.js（Node.js的框架）、Django（Python的框架）、Ruby on Rails（Ruby的框架）、Spring Boot（Java的框架）等，用于简化后端开发。 API（应用程序接口）：
用于不同组件之间的通信，RESTful API和GraphQL是常见的实现方式。 Web服务器：
例如Nginx、Apache等，用于处理HTTP请求，负责将请求转发到后端应用程序。 身份验证和授权：
用于保护应用程序的安全，常见的有JWT（JSON Web Tokens）、OAuth等。 容器化和微服务：
Docker等容器技术和微服务架构，用于简化应用程序的部署和维护。 持续集成/持续部署（CI/CD）工具：
例如Jenkins、Travis CI、GitHub Actions等，用于自动化构建、测试和部署过程。 日志记录和监控工具：
如ELK Stack（Elasticsearch、Logstash、Kibana）、Prometheus等，用于监控应用程序的性能和行为。 如何系统学习？ 第一阶段：前端基础 HTML、CSS和JavaScript基础：
学习HTML用于页面结构，CSS用于样式设计，JavaScript用于页面交互。掌握DOM和基本的事件处理。 学习浏览器开发者工具：
熟悉浏览器的开发者工具，用于调试和分析前端代码。 学习响应式设计和移动端开发：
学习如何创建响应式的网页，适应不同设备的屏幕尺寸。了解移动端开发的基础。 学习前端框架：
选择学习一种前端框架，如React、Vue.js、Angular等。理解组件化开发和状态管理。 学习构建工具：
学习使用Webpack、Parcel等构建工具，了解模块化开发、打包、压缩等概念。 第二阶段：后端基础 学习基本的后端语言：
选择一门后端语言，如Node.js（JavaScript）、Python、Ruby、Java等，并了解其基本语法和特性。 学习后端框架：
学习后端框架，例如Express.js（Node.js）、Django（Python）、Ruby on Rails（Ruby）、Spring Boot（Java）等。 学习数据库基础：
学习关系型数据库（如MySQL、PostgreSQL）和非关系型数据库（如MongoDB），了解数据库的基本操作和设计。 第三阶段：全栈开发 学习RESTful API设计：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b434e21944fbeb9a035b17dbca3f9401/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82f895b23ad4050f9aa436b8d385d854/" rel="bookmark">
			JDBC教程：JDBC连接Mysql数据库超详细讲解（从入门到熟练使用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JDBC 1.概念： 【 Java DataBase Connectivity 】，Java数据库连接即 ，JDBC的作用是：用Java语言操作数据库 2.本质： 官方定义的一套操作所有关系型数据库的规则/规范（ 即接口-- API（Application Programming Interface ））
且由关系型数据库厂商自己写JDBC的实现类，实现这套接口（数据库驱动）
真正执行的代码是驱动jar包中的实现类
3.快速入门 步骤 导入驱动jar包
图1--查看MySQL版本 图2---到官网下载对应版本的jar包 https://downloads.mysql.com/archives/c-j/ 是旧版本 页面有所不同
MySQL :: Download Connector/J 附上最新版下载地址
图3---直接下载无需登录注册Oracle官网账号 在src中新建libs包
复制mysql-connector-java-8.0.26.jar 到项目libs目录下
图4.图5.图6--复制jar包并粘贴 右键—&gt;add as library(添加为库)
图7--添加为库 注册驱动
Class.forName("com.mysql.jdbc.Driver"); 注：需要抛出异常（如图）
使用throws Exception代替具体的异常类型（如throws ClassNotFoundException）
获取数据库连接对象 Connection
create database JDBC_study; use JDBC_study; create table account ( id int auto_increment primary key , name varchar(10) null, balance double null ); ​ 图8–提前准备的数据表
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82f895b23ad4050f9aa436b8d385d854/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a48d9f6c8d0cebe846c6d5dc0b5fd4c/" rel="bookmark">
			【hive】- 使用insert into/insert overwrite插入数据到静态分区、动态分区、动静态分区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、hive分区hive分区类型hive分区参数 二、数据插入方式静态分区插入数据动态分区插入数据动静混合分区插入数据 前言 Hive中支持的分区类型有两种，静态分区（static partition）与动态分区（dynamic partition），本文主要讲针对不同分区情况，如何正确地使用insert into/insert overwrite 将数据插入表里对应的分区。
一、hive分区 hive分区类型 静态分区与动态分区的区别：
静态分区字段需要手动指定，通过用户传递来决定；而动态分区字段是根据select出来的具体值进行动态分区。 hive分区参数 hive.exec.dynamic.partition：是否启动动态分区，默认为false。hive.exec.dynamic.partition.mode：打开动态分区后，动态分区的模式为strict和nonstrict。 strict 可设置为静态和半动态，要求至少包含一个静态分区列。nonstrict 可设置为静态、半动态和动态，动态必须设置此参数。 hive.exec.max.dynamic.partitions：允许的最大的动态分区的个数，默认为1000。hive.exec.max.dynamic.partitions.permode：一个mapreduce job所允许的最大的动态分区的个数，默认为100。 二、数据插入方式 建立分区表
create table test_1 (id string, name string, classes string, scores int) partitioned by (city_code string,cur_day string) row format delimited fields terminated by ','; 辅助分区表的测试表
create table test_1_tmp( id string, name string, classes string, scores int, city_code string, cur_day string) row format delimited fields terminated by ','; 静态分区插入数据 insert into，在city_code=‘200’,cur_day='20231111’分区下追加数据。 insert into table test_1 partition(city_code='200',cur_day='20231111') select t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a48d9f6c8d0cebe846c6d5dc0b5fd4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c607de4a233d15919138efc2cc8ecda9/" rel="bookmark">
			详解SkyWalking前端监控的性能指标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SkyWalking 从8.2.0版本开始支持对前端浏览器端的性能进行监控，不仅可以像以前一样监控浏览器发送给后端服务的与请求，还能看到前端的渲染速度、错误日志等信息——这些信息是获取最终用户体验的最有效指标。实现的方式是引入skywalking-client-js库，这是一个 skywalking 官方出品的一个前端埋点上报插件，支持React, Angular, Vue框架。它有如下功能：
提供指标和错误收集到SkyWalking后端。
轻量级的。一个简单的JavaScript库。不需要浏览器插件。
浏览器作为整个分布式跟踪系统的起点。
skywalking-client-js本质 浏览器端的监控其实也是在前端代码里插入一个js的agent，和后台代码的接入一样。Skywalking-client-js 将错误数据跟踪到 OAP 服务器，最终在 UI 端可视化数据。
Browser监控入口 详解Browser-App 监控页面 对于应用程序的错误概述，有几个基本统计信息和错误趋势的指标，包括以下指标。
App Error Count, 应用错误计数，所选时间段内的错误总数。
App JS Error Rate ，应用JS 错误率，选定时间段内出现 JS 错误的 PV 占总 PV 的比例。
All of Apps Error Count, 所有应用错误计数，前 N 个应用错误计数排名。
All of Apps JS Error Rate，所有应用JS错误率，前N个应用JS错误率排名。
Error Count of Versions in the Selected App，所选应用中版本的错误计数，所选应用排名中版本的前 N 个错误计数。
Error Rate of Versions in the Selected App，所选应用中版本的错误率，所选应用中版本排名前 N 名的 JS 错误率。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c607de4a233d15919138efc2cc8ecda9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbf84b33018dd70f559f00bf57db1fa3/" rel="bookmark">
			MATLAB知识点：矩阵的重构和重新排列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​讲解视频：可以在bilibili搜索《MATLAB教程新手入门篇——数学建模清风主讲》。​
MATLAB教程新手入门篇（数学建模清风主讲，适合零基础同学观看）_哔哩哔哩_bilibili
节选自第3章 3.3.5 矩阵的重构和重新排列 这一小节将介绍一些和矩阵的重构或重新排列相关的函数，下表给出了本小节要学的函数的名称和作用：
（1）reshape函数
reshape函数可以改变矩阵的形状，其常用语法为reshape(A, m, n)或者reshape(A,[m,n])，这可以将矩阵A的形状更改为m行n列，前提是转换前后的两个矩阵的元素总数要相同。
例如有一个矩阵A，它原来的形状是2行6列，如果我们需要将其形状变成3行4列，就可以使用命令：reshape(A, 3, 4). 从上面的运行结果可以看出， reshape函数实际上是按矩阵的线性索引来重新组织矩阵元素的。也就是说，它先取矩阵A的第一列，然后是第二列，依此类推，再按新的维度重新组织这些元素。因此，转换后的B矩阵中的元素和A矩阵中的元素是完全相同的，即A(:)和B(:)的结果完全相同。
另外，我们不需要自己来计算转换后的矩阵有多少行或多少列。可以只给出转换后的行数，列数用空向量[ ]代替；或者只给出转换后的列数，行数用空向量[ ]代替。MATLAB会自动帮我们计算转换后的矩阵大小。例如：若A是一个由12个元素组成的矩阵，命令reshape(A,3,[ ])、reshape(A,[ ],4)可以实现和reshape(A,3,4)一样的效果。
如果你给出的转换后的行数和列数的乘积不等于原始矩阵中元素的个数，那么MATLAB就会报错：
（2）sort函数
sort函数是用于对向量或矩阵进行排序的。如果输入的参数是矩阵的话，还可以对矩阵的每一行或每一列分别进行排序。
①对向量排序
我们先来学习sort函数对向量排序，假设v是一个向量，有下面两种基础的用法：
sort(v) 可以将向量v按照从小到大的顺序进行升序排列；
sort(v, 'descend' )可以将向量v按照从大到小的顺序进行降序排列。
注意，上面的用法中，sort函数只有一个返回值，即排序后的向量；事实上，sort函数可以有两个返回值，基本用法为：[sort_v, ind] = sort(v)。这里，sort_v是排序后的向量，ind是排序后的向量（即sort_v）中的每个元素在原向量（即v）中的索引（即下标、位置）。我们来看一个具体的例子：
在上面的例子中，我们让sort函数返回了两个变量；sort_v和ind。它们是两个长度相等的向量，向量的方向和sort函数中输入的v向量的方向一致，都是行向量。向量v中所有元素的最小值为8，而8在v中的索引是4，因此sort_v中第一个元素为8，ind的第一个元素为4； 向量v中第二小的值为10，而10是v中的第1个元素，因此sort_v中第二个元素为10，ind的第二个元素为1；依次类推，可以得到sort_v和ind向量的值。事实上，这里有一个恒等关系成立：v(ind)运行的结果和sort_v的结果完全一样，大家可以自行验证。
下面我们看一个具体的应用场景。假设清风班上有10名同学，序号分别是1号、2号一直到10号。已知这10名同学的成绩构成的向量为：[84 70 61 90 69 78 88 74 92 76]，问：清风班上哪三名同学的分数最高，分数分别是多少?
根据MATLAB返回的结果可以看出：9号、4号和7号这三名同学的分数排名前三，分别是92、90和88分。
上面这个问题比较简单，我们再来提一个问题：我们能不能知道这10名同学在班上的排名？例如：1号同学84分，在班上排名第4；2号同学70分，在班上排名第8；3号同学61分，排名第10；4号同学90分，排名第2；…… ；依此类推，最终我们想要得到的排名为：[4 8 10 2 9 5 3 7 1 6].
大家观察ind的值和我们想得到的排名的值，应该可以发现如下规律：1号同学排名第4，而ind中等于1的元素的索引也为4；2号同学排名第8，而ind中等于2的元素的索引也为8；3号同学排名第10，而ind中等于3的元素的索引也为10；4号同学排名第2，而ind中等于4的元素的索引也为2，依次类推，我们可以根据ind得到想要的排名。
根据上面的分析，我们可以将ind这个向量按照从小到大的顺序排列，排序后的向量是[1,2,3,…,10]，且排序后的向量中的每个元素在向量ind中的索引就是我们要得到的排名!
因此，我们只需要加下面这行代码，new_ind就是我们想要计算的排名：
注意：如果存在同学的成绩相同的情况，那么这个代码就会存在问题，要想解决这个问题可以用到我们本章后面要学的ismember函数，这个问题也将放到本章最后的练习题中。
② 对矩阵排序
上面介绍的是sort函数对向量进行排序的应用，下面我们再来介绍sort函数对矩阵A进行排序的用法：sort(A, dim). dim = 1时，沿着行方向(从上至下)对矩阵的每一列升序排列
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbf84b33018dd70f559f00bf57db1fa3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de36cabf70ec36f4a0aaa6352fdcd422/" rel="bookmark">
			Java中indexOf函数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中indexOf函数详解
大家好，我是免费搭建查券返利机器人赚佣金就用微赚淘客系统3.0的小编，也是冬天不穿秋裤，天冷也要风度的程序猿！今天我们来深入探讨Java中常用的字符串处理函数之一——indexOf函数。
什么是indexOf函数？ indexOf是Java中String类提供的一个用于查找子字符串在原始字符串中首次出现位置的方法。它的使用方式如下：
int indexOf(String str) 其中，str是要查找的子字符串，而函数的返回值是子字符串在原始字符串中的索引位置。如果未找到子字符串，返回值为-1。
indexOf的基本用法 让我们通过一个简单的示例来了解indexOf的基本用法：
public class IndexOfExample { public static void main(String[] args) { String originalString = "Hello, World!"; String searchString = "World"; // 使用indexOf查找子字符串的位置 int index = originalString.indexOf(searchString); // 输出结果 if (index != -1) { System.out.println("子字符串在原始字符串中的位置：" + index); } else { System.out.println("未找到子字符串"); } } } 在上述例子中，我们定义了一个原始字符串originalString，然后使用indexOf方法查找子字符串"World"在原始字符串中的位置。如果找到了，就输出位置；如果未找到，则输出未找到的提示。
indexOf的高级用法 除了基本的用法，indexOf还提供了一些高级的用法，例如：
指定起始位置进行查找： 可以通过在函数中传入起始查找位置的参数，限定查找范围。 int indexOf(String str, int fromIndex) 从后向前查找： 通过lastIndexOf方法，可以从字符串末尾开始向前查找子字符串。 int lastIndexOf(String str) 示例：指定起始位置和从后向前查找 public class AdvancedIndexOfExample { public static void main(String[] args) { String originalString = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de36cabf70ec36f4a0aaa6352fdcd422/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4fccb44ca717467387c566b65bbc9d2/" rel="bookmark">
			强大到离谱！AI视频生成必备的10款工具推荐!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		亲测好用的10款AI工具分享，帮助你轻松解决图片快速生成、短视频制作、文案编辑、图像处理等各种办公难题，大大提高工作效率。
1.AI视频生成——巨日禄 地址：https://aitools.jurilu.com/
推荐理由："巨日禄 "是一款功能强大的文本视频生成器，可以快速将文本内容转换成极具吸引力的视频。操作简单，用户只需输入文字，选择喜欢的样式和模板， “巨日禄”就会自动将文字内容转换成生动的视频演示。不仅如此，“巨日禄”还提供了丰富的素材库，如背景音乐、照片和动画效果等，让您可以轻松定制自己的视频。 2.对话——Auto-GPT Auto-GPT 是 Torantulino 提供的免费开发工具。这款开源的语言处理应用程序使用下一代 GPT-4 语言模型。它拥有更强大的人工智能机制和许多自动化功能。你只需告诉应用程序你需要什么，它就会完成剩下的所有工作。这包括在互联网上搜索答案、引用资料来源，甚至管理系统上的文件。 与 docGPT 或 Merlin - Open AI ChatGPT Powered Assistant 等其他 GPT 应用程序不同，它适用于更广泛的任务。不过，它是为实验而不是商业用途而设计的，这也是其界面具有挑战性的原因。 3.文档总结——ChatDOC 上传 PDF/Word 文档并稍加聊天，即可立即获得文章摘要、要点总结、详细描述、数据分析、内容润色… 您还可以选择表格、文本或有针对性的问题，以获得更准确的答案。ChatDOC 答案可以追溯到文档内容，后续支持图片、扫描件格式和多种格式和多个文档交叉问题。 4.图片处理工具——CleanUp.pictures CleanUp.pictures是一款比较少见的在线图片处理工具，主要功能是快速修复图片中的任何物体或缺陷，例如，你想抚平衬衫上的褶皱，去除照片中的一些缺陷，自拍的照片也可以进行更改 如果不想在照片中出现某个人或物体，可以在产品图片中创建更干净的背景。
CleanUp.pictures 的操作非常简单，只需上传图片并用鼠标光标画出需要处理的区域，它就会自动计算并补充附近的色彩范围，修饰后的照片看起来依然非常自然，用户可以使用不同的画笔来更精确地标记 可调整大小，完成后可显示原始图像与修改后图像的差异。 5.影音比例转换——Videograp Videograph 是一家专注于视听技术的工具，提供视频编码、即时流媒体、分析、API 和 CDN 交换等服务。 在图像处理方面，推出了 AI 技术，经过 AI 处理后，可以自动将横屏人像视频转换为直版视频，尤其是现在大部分用户都集中在移动设备和社交媒体平台上，视频剪切编辑只需几分钟。竖屏的使用有助于提升观看体验，尤其是现在的用户都集中在移动设备和社交媒体平台上。另一方面，转换为竖屏后，可以避免过多黑边填满手机屏幕，压缩影片尺寸。 6.影片转档——HitPaw HitPaw 是一家专注于开发各种实用软件的公司，应用软件如胶片下载、传输、AI 画质修复、去水印、屏幕录制和胶片编辑等软件一应俱全，此前推出的 "胶片、音频、图片 HitPaw 在线一站式在线剪辑工具 "包含一系列在线工具，无需下载，无需安装，快速使用在线工具，解决工作和日常生活中遇到的胶片问题。虽然更容易解决工作和日常生活中遇到的情况，但在线工具的缺点是如果要处理较大的文件，或者只能选择电脑版软件，则不适合使用在线工具。 7.免费模板编辑器——editorAC editorAC 是一款在线免费设计模板工具，之前推荐过 photoAC、illustAC 和免费剪影矢量图 silhouetteAC，editorAC 可以制作商业传单、横幅、菜单、名片、徽标和通讯等。 它根据不同类别内置了大量免费设计模板，也可用于社交网站。此外，还有用于社交网站的横幅、封面设计、缩略图、海报、收据、送货单、信纸、明信片和用于印刷材料的各种卡片，所有这些都可以从网页上访问和编辑。 8.平面素材制作——Crello Crello 是一项可以让用户快速设计出好看照片的工具，通过预先设计好的模板和尺寸，用户可以选择和更改内容，并添加其它照片、视频、文本、背景和对象，制作出专业外观的图形材料 操作过程非常简单，在浏览器中即可完成，无需像使用普通在线工具那样下载或安装其他软件。操作过程与使用普通在线工具一样简单，可在浏览器中完成，无需额外下载或安装任何软件。 9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4fccb44ca717467387c566b65bbc9d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62199ef52d3d247b5f137fca0cb1104c/" rel="bookmark">
			图书|基于Springboot的图书管理系统设计与实现(源码&#43;数据库&#43;文档)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图书管理系统目录
目录
基于Springboot的图书管理系统设计与实现
一、前言
二、系统功能设计
三、系统实现
1、个人中心
2、管理员管理
3、用户管理
4、图书出版社管理
5、公告类型管理
6、所在书架管理
7、图书类型管理
8、论坛管理
9、公告信息管理
10、图书信息管理
11、借阅信息管理
12、轮播图管理
四、数据库设计
1、实体ER图
五、核心代码 六、论文参考
七、最新计算机毕设选题推荐
八、源码获取：
博主介绍：✌️大厂码农|毕设布道师，阿里云开发社区乘风者计划专家博主，CSDN平台Java领域优质创作者，专注于大学生项目实战开发、讲解和毕业答疑辅导。✌️
主要项目：小程序、SpringBoot、SSM、Vue、Html、Jsp、Nodejs等设计与开发。
🍅文末获取源码联系🍅
👉 毕设答疑 👈
基于Springboot的图书管理系统设计与实现 一、前言 传统的图书管理信息管理模式，采用人工登记的方式保存相关数据，这种以人力为主的管理模式已然落后。本人结合使用主流的程序开发技术，设计了一款基于springboot的图书管理系统，可以较大地减少人力、财力的损耗，方便相关人员及时更新和保存信息。
本系统主要使用B/S开发模式，在idea集成开发环境下，采用Java语言编码设计系统功能，MySQL数据库管理相关的系统数据信息，SSM框架设计和开发系统功能架构，最后通过使用Tomcat服务器，在浏览器中发布设计的系统，并且完成系统与数据库的交互工作。本文对系统的需求分析、可行性分析、技术支持、功能设计、数据库设计、功能测试等内容做了较为详细的介绍，并且在本文中也展示了系统主要的功能模块设计界面和操作界面，并对其做出了必要的解释说明，方便用户对系统进行操作和使用，以及后期的相关人员对系统进行更新和维护。通过设计基于springboot的图书管理系统，可以极大地提高图书管理的工作效率，提升用户的使用体验。
关键词：图书管理；Java语言；B/S结构；MySQL数据库
二、系统功能设计 图书管理系统的使用者主要可以被分为管理员角色和用户角色两类。其中，管理员角色主要的功能需求有用户信息管理、图书信息管理、借阅信息管理等模块，用户角色主要的功能需求有系统登录、查询图书信息、查询借阅信息等模块。本系统的总体功能设计如图：
三、系统实现 1、个人中心 通过设计的个人中心管理功能模块，管理用户可以对相关的个人信息进行管理，比如管理用户可以更新个人账号的密码信息，修改个人账号的用户名信息等，修改密码界面设计如图5-1所示，个人信息界面设计如图5-2所示。
图5-1修改密码界面
图5-2个人信息界面
2、管理员管理 通过设计的管理员管理功能模块，管理用户可以对相关的管理员用户信息进行管理，比如管理用户可以查看管理员的用户名，更新管理员密码，删除已经注销的管理员用户信息记录等，管理员管理界面设计如图5-3所示。
图5-3管理员管理界面
3、用户管理 通过设计的用户管理功能模块，管理用户可以对相关的用户信息进行管理，比如管理用户可以查看用户头像信息，更新用户手机号码，删除已经注销的用户信息记录等，用户管理界面设计如图5-4所示。
图5-4用户管理界面
4、图书出版社管理 通过设计的图书出版社管理功能模块，管理用户可以对相关的图书出版社信息进行管理，比如管理用户可以添加新图书出版社信息记录，更新图书出版社名称，删除失效的图书出版社信息记录等，图书出版社管理界面设计如图5-5所示。
图5-5图书出版社管理界面
5、公告类型管理 通过设计的公告类型管理功能模块，管理用户可以对相关的公告类型信息进行管理，比如管理用户可以添加新公告类型信息记录，更新公告类型名称，删除失效的公告类型信息记录等，公告类型管理界面设计如图5-6所示。
图5-6公告类型管理界面
6、所在书架管理 通过设计的所在书架管理功能模块，管理用户可以对相关的所在书架信息进行管理，比如管理用户可以添加新所在书架信息记录，更新所在书架名称，删除失效的所在书架信息记录等，所在书架管理界面设计如图5-7所示。
图5-7所在书架管理界面
7、图书类型管理 通过设计的图书类型管理功能模块，管理用户可以对相关的图书类型信息进行管理，比如管理用户可以添加新图书类型信息记录，更新图书类型名称，删除失效的图书类型信息记录等，图书类型管理界面设计如图5-8所示。
图5-8图书类型管理界面
8、论坛管理 通过设计的论坛管理功能模块，管理用户可以对相关的论坛信息进行管理，比如管理用户可以添加新论坛信息记录，更新发布的帖子内容，删除失效的论坛信息记录等，论坛管理界面设计如图5-9所示。
图5-9论坛管理界面
9、公告信息管理 通过设计的公告信息管理功能模块，管理用户可以对相关的公告信息信息进行管理，比如管理用户可以查看公告时间，删除失效的公告信息记录等，公告信息管理界面设计如图5-10所示。
图5-10公告信息管理界面
10、图书信息管理 通过设计的图书信息管理功能模块，管理用户可以对相关的图书信息信息进行管理，比如管理用户可以查看图书数量，删除失效的图书信息记录等，图书信息管理界面设计如图5-11所示。
图5-11图书信息管理界面
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62199ef52d3d247b5f137fca0cb1104c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/511/">«</a>
	<span class="pagination__item pagination__item--current">512/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/513/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>