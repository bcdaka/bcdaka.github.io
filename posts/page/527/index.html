<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66369188d6d11cf73b17bfe70a1cbf69/" rel="bookmark">
			Android WLAN 直连（对等连接或 P2P）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念 Wi-Fi Direct®支持Wi-Fi设备相互直接连接，并非Android设备独有的，是WIfi联盟提供的一种设备与设备之间直接联网通讯的技术，实现点对点的连接，我们常说的Wifi P2P连接。
最大的特点和优势就是无需接入网络就可连接设备
有了Wi-Fi Direct，手机、摄像头、打印机、个人电脑和游戏设备无需互联网连接，就能够建立自己的Wi-Fi网络。Wi-Fi Direct设备相互连接后，通过设备设置，就可快速简便地传送或显示内容、玩游戏以及分享应用。这些设备可以一对一地连接，或者几个设备形成的一组设备可以同时连接。由于无需接入点或互联网连接，因此设备在哪里，哪里就有Wi-Fi Direct网络。设备之间建立的Wi-Fi Direct连接对包括Miracast®在内的很多应用而言属于底层技术。诸如智能手机、摄像头、打印机、电视机、个人电脑、游戏机等成千上万的设备均已通过认证。
随时随地建立连接
即使附近没有Wi-Fi网络可用，Wi-Fi Direct设备之间也可以随时随地建立连接。Wi-Fi Direct设备向同一区域内的其他设备发送信号，让这些设备知道可以建立连接。用户可以查看可用设备并请求连接，也可以接收另一台设备发出的连接邀请。两个或更多个经过Wi-Fi Direct认证的设备直接连接时，会使用Wi-Fi Protected Setup™形成一个Wi-Fi Direct设备组。
Android设备如何使用WLAN P2P Android API 概览
WifiP2pManager 类提供的方法使您可以在设备上与 WLAN 硬件交互，以执行发现和连接对等设备等操作。可执行的操作如下：
initialize()通过 WLAN 框架注册应用。必须先调用此方法，然后再调用任何其他 WLAN P2P 方法。connect()启动与具有指定配置的设备的对等连接。cancelConnect()取消任何正在进行的对等群组协商。requestConnectInfo()请求设备连接信息。createGroup()以群组所有者的身份，使用当前设备创建对等群组。removeGroup()移除当前对等群组。requestGroupInfo()请求对等群组信息。discoverPeers()启动对等设备发现requestPeers()请求已发现对等设备的当前列表。 WifiP2pManager 方法使您可以在侦听器中进行传递，以便 WLAN P2P 框架可以向您的 Activity 通知通话状态。下表介绍可用的侦听器接口和使用侦听器的相应 WifiP2pManager 方法调用：
侦听器接口相关操作WifiP2pManager.ActionListenerconnect()、cancelConnect()、createGroup()、removeGroup() 和 discoverPeers()WifiP2pManager.ChannelListenerinitialize()WifiP2pManager.ConnectionInfoListenerrequestConnectInfo()WifiP2pManager.GroupInfoListenerrequestGroupInfo()WifiP2pManager.PeerListListenerrequestPeers() WLAN P2P API 定义当发生特定 WLAN P2P 事件时会广播的 Intent，例如发现新的对等设备时，或设备的 WLAN 状态更改时。您可以通过创建处理这些 Intent 的广播接收器，在应用中注册接收这些 Intent：
Intent说明WIFI_P2P_CONNECTION_CHANGED_ACTION当设备的 WLAN 连接状态更改时广播。WIFI_P2P_PEERS_CHANGED_ACTION当您调用 discoverPeers() 时广播。如果您在应用中处理此 Intent，则通常需要调用 requestPeers() 以获取对等设备的更新列表。WIFI_P2P_STATE_CHANGED_ACTION当 WLAN P2P 在设备上启用或停用时广播。WIFI_P2P_THIS_DEVICE_CHANGED_ACTION当设备的详细信息（例如设备名称）更改时广播。 创建 WLAN P2P 应用 创建 WLAN P2P 应用涉及为应用创建并注册广播接收器、发现对等设备，连接到对等设备，以及将数据传输到对等设备。以下部分将介绍如何完成此操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66369188d6d11cf73b17bfe70a1cbf69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e2d2330a6c8040b2c2c7922d4203bfa/" rel="bookmark">
			C语言课设--航班订票系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言课设--航班订票系统 0.文件结构1.代码2.航班信息录入3.查看航班信息4.航班信息查询5.修改航班信息6.删除航班信息7.订票8.查看订单9.修改订单10.退票 大一的C语言课设，极简航班订票系统，希望能够对大家有所帮助 源码 + 文件 ： 航班订票系统.zip 0.文件结构 首先需要在代码文件同级文件夹下创建一个flight文件夹，然后在flight文件夹下创建flight.dat和order.dat文件分别用于保存航班信息和订票信息
文件结构1
文件结构2
1.代码 #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;math.h&gt; #include&lt;stdlib.h&gt; #define SIZE 20 #define NUM 100 typedef struct{ char flightNum[SIZE]; char take_off_Time[SIZE]; char land_Time[SIZE]; char take_off_City[SIZE]; char land_City[SIZE]; float pre_Price; float discount; float now_Price; int tickets; }FLIGHT,*PFLIGHT; typedef struct{ char flightNum[SIZE]; char take_off_Time[SIZE]; char land_Time[SIZE]; char take_off_City[SIZE]; char land_City[SIZE]; float price; }ORDERFLIGHT,*PORDERFLIGHT; typedef struct{ char orderId[SIZE]; char name[SIZE]; char userId[SIZE]; ORDERFLIGHT order; }ORDER,*PORDER; void input_flight(){ FILE* fp; int i=0; int n; FLIGHT f[NUM]; if((fp=fopen("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e2d2330a6c8040b2c2c7922d4203bfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f25713a05e59d0ea2e5e0f41d379c8e/" rel="bookmark">
			C语言之指针详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 指针1.1 简介1.2 什么是指针1.2.1 定义1.2.2 指针表示1.2.3 为什么*p=&amp;a不正确 1.3 使用指针1.3.1 简单使用1.3.2 NULL 指针1.3.3 指针算术运算1.3.3.1 定义1.3.3.2 遍历数组：递增一个指针1.3.3.3 遍历数组：递减一个指针1.3.3.4 指针的比较 1.3.4 指针数组1.3.4.1 简单示例1.3.4.2 字符串指针数组问题 1.3.5 指向数组的指针1.3.6 指向指针的指针 1.4 函数和指针关系1.4.1 传递指针给函数1.4.2 从函数返回指针1.4.3 函数指针1.4.4 回调函数 1 指针 1.1 简介 当初学C语言，指针是最头疼的地方，难以理解，不过时间长了就自然明白了
通过指针，可以简化一些 C 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。
每一个变量都有一个内存位置，每一个内存位置都定义了可使用 &amp; 运算符访问的地址，它表示了在内存中的一个地址。
注意：用register修饰的变量是没法取到地址的，没有内存位置
1.2 什么是指针 1.2.1 定义 指针也就是内存地址，指针变量是用来存放内存地址的变量。就像其他变量或常量一样，必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为： type *var_name;
type 是指针的基类型，它必须是一个有效的 C 数据类型var_name 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。 所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数。
不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。
1.2.2 指针表示 请看下面的实例，它将输出定义的变量地址：
#include &lt;stdio.h&gt; int main () { int var_runoob = 10; int *p; // 定义指针变量 p = &amp;var_runoob; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f25713a05e59d0ea2e5e0f41d379c8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1701030c214782a85e0b0e431df1622/" rel="bookmark">
			6个强大且好看的AI绘画网站，各种美女随便生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、AI绘画 https://www.gaituya.com/aiimg/
一个比较专业的文字生成图片网站，支持输入各种文字生成好看的图片，包括漫画、二次元、3D科幻、风景等类型的图片都能一键生成，并且还支持自定义选择文本匹配度。
生成的方法很简单，打开后输入文字描述，输入的描述语越详细，生成的效果越好，输入的文字最好带有画面内容、风格等关键词，输入完成后选择生成数量，最后点击开始生成，很快就可以在页面看到生成的图片效果。
2、文心一格 https://yige.baidu.com/
一个由百度出品的AI绘画网站，打开页面就可以看到各种已创作完成的AI图片，每个图片素材还提供了详细的文字描述，不知道怎么描述生成的话，还可以直接复制文字内容生成图片。
打开页面点击上方的“AI创作”，下面会进入AI文字描述页面，输入想要生成的文字内容，然后选择生成的图片风格包括二次元、梵高、中国风、怀旧漫画等风格，接着再选择生成数量，最后点击立即生成，很快就可以看到生成的效果图。
3、6pen https://6pen.art/
一个专门用来生成AI艺术图片网站，打开首页可以看到页面设计非常具有艺术效果，生成的图片不仅好看，而且每张都堪称艺术绘画，只需要登录账号就可以进入创作页面，而
支持输入文字以及上传图片生成AI图片，支持生成的风格也超级丰富，包括水墨画、素描、铅笔画、水墨画等都能用它生成，生成后的图片全都是无水印的，可以直接点击下载。
4、Artpai https://artpai.xyz/pc/#/create
一个专门用来生成各种AI图片的网站，打开页面就可以看到文字描述框，你可以输入各种科幻、风景、中国风、动物等描述语，还支持上传底部图片作为参考。
生成的方法也很简单，打开页面输入文字描述语，然后选择生成数量、风格、以及生成的画面比例，支持生成竖版海报、短视频竖版、横版海报等，设置完成后点击开始生成，很快就可以在页面看到生成后的AI效果图。
5、elbo https://art.elbo.ai/
一个国外的AI图片生成网站，登录账号就可以进入制作页面，它可以生成各种国外的二次元人物、3D科幻图片、风景等类型的图片，因为是国外的网站，所以大家在输入描述语最好也是英文，生成后的图片支持免费下载。
资料分享 小编整理了一份AI绘画的入门资料包，包括Stable Diffusion和Midjourney的安装包等等，wx扫描二v码免费领取 【保证100%免费】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab0fe82934d637853931bfc5124902a9/" rel="bookmark">
			java.lang.ClassNotFoundException: org.mybatis.logging.LoggerFactory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在公司整合老项目时，用SpringBoot2在整合mybatis-plus，启动后报错：
Caused by: java.lang.NoClassDefFoundError: org/mybatis/logging/LoggerFactory at com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean.&lt;clinit&gt;(MybatisSqlSessionFactoryBean.java:88) at com.baomidou.mybatisplus.autoconfigure.MybatisPlusAutoConfiguration.sqlSessionFactory(MybatisPlusAutoConfiguration.java:167) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:154) ... 64 common frames omitted Caused by: java.lang.ClassNotFoundException: org.mybatis.logging.LoggerFactory at java.net.URLClassLoader.findClass(URLClassLoader.java:387) at java.lang.ClassLoader.loadClass(ClassLoader.java:418) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:355) at java.lang.ClassLoader.loadClass(ClassLoader.java:351) ... 71 common frames omitted 我的配置是：
&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.3&lt;/version&gt; &lt;/dependency&gt; mybatis-plus 3.2.0以上版本需要用到一个扩展包，但是和springboot整合的starter里面还没有，所以需要单独加上一个扩展包，用同版本的扩展包就行：
&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-extension&lt;/artifactId&gt; &lt;version&gt;3.5.3&lt;/version&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46ab6e0265e9dc02155fd9198c907b6b/" rel="bookmark">
			Python 爬虫：如何用 BeautifulSoup 爬取网页数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在网络时代，数据是最宝贵的资源之一。而爬虫技术就是一种获取数据的重要手段。Python 作为一门高效、易学、易用的编程语言，自然成为了爬虫技术的首选语言之一。而 BeautifulSoup 则是 Python 中最常用的爬虫库之一，它能够帮助我们快速、简单地解析 HTML 和 XML 文档，从而提取出我们需要的数据。
本文将介绍如何使用 BeautifulSoup 爬取网页数据，并提供详细的代码和注释，帮助读者快速上手。
安装 BeautifulSoup 在开始之前，我们需要先安装 BeautifulSoup。可以使用 pip 命令进行安装：
pip install beautifulsoup4 爬取网页数据 在本文中，我们将以爬取豆瓣电影 Top250 为例，介绍如何使用 BeautifulSoup 爬取网页数据。
首先，我们需要导入必要的库：
import requests from bs4 import BeautifulSoup 然后，我们需要获取网页的 HTML 代码。可以使用 requests 库中的 get() 方法来获取网页：
url = 'https://movie.douban.com/top250' response = requests.get(url) html = response.text 接下来，我们需要使用 BeautifulSoup 解析 HTML 代码。可以使用 BeautifulSoup 的构造方法来创建一个 BeautifulSoup 对象：
soup = BeautifulSoup(html, 'html.parser') 这里我们使用了 ‘html.parser’ 作为解析器，也可以使用其他解析器，如 lxml、html5lib 等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46ab6e0265e9dc02155fd9198c907b6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22a015449e855023497a90c5959f5946/" rel="bookmark">
			MySQL java.sql.SQLSyntaxErrorException: You have an error in your SQL syntax 关键字异常处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、异常错误二、原因三、解决方法 一、异常错误 使用mybatis插入数据时出现java.sql.SQLSyntaxErrorException异常
收到错误“由：java.sql.SQLSyntaxErrorException：您的SQL语法有错误;检查与您的MySQL服务器版本相对应的手册，了解在第14行的“”附近使用的正确语法。
Uncaught (in promise) Error: ### Error updating database. Cause: java.sql.SQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'group, device_sort, create_time ) ' at line 4 ### The error may exist in file [D:\Project\zdhzyjy\remote-burning\ruoyi-device\target\classes\mapper\device\DevDeviceMapper.xml] ### The error may involve com.ruoyi.device.mapper.DevDeviceMapper.insertDevDevice-Inline ### The error occurred while setting parameters ### SQL: insert into dev_device ( name, port, group, device_sort, create_time ) values ( ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22a015449e855023497a90c5959f5946/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94b52c302ce43278594107876a951178/" rel="bookmark">
			SQL Server命令大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 数据库管理2. 表操作3. 查询数据4. 连接查询5. 存储过程与函数6. 视图7. 索引8. 其他常用命令9. 用户与权限管理10. 数据备份与恢复11. 系统函数与信息查询12. 其他高级特性13. 分区表14. 高级查询操作15. 复制与同步16. 异步处理与作业调度17. 查询执行计划18. 引用外部数据19. 动态SQL20. 自增序列与标识符21. 数据类型转换22. CASE表达式和IIF函数23. 数据库快照 SQL Server 中包含了大量的命令用于数据库的管理、查询和操作。以下是一些主要命令分类及其简要示例： 1. 数据库管理 创建数据库 CREATE DATABASE MyDatabase; 删除数据库 DROP DATABASE MyDatabase; 选择/切换当前数据库 USE MyDatabase; 2. 表操作 创建表 CREATE TABLE Employees ( EmployeeID int PRIMARY KEY, FirstName nvarchar(50), LastName nvarchar(50), HireDate datetime ); 插入数据 INSERT INTO Employees (EmployeeID, FirstName, LastName, HireDate) VALUES (1, 'John', 'Doe', '2023-01-01'); 更新数据 UPDATE Employees SET FirstName = 'Jane' WHERE EmployeeID = 1; 删除数据 DELETE FROM Employees WHERE EmployeeID = 1; 修改表结构 ALTER TABLE Employees ADD DepartmentID int FOREIGN KEY REFERENCES Departments(DepartmentID); 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94b52c302ce43278594107876a951178/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fe554a8968c1b259470bb3ee4094a1c/" rel="bookmark">
			golang面试题大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		go基础类 1、与其他语言相比，使用 Go 有什么好处？ 与其他作为学术实验开始的语言不同， Go 代码的设计是务实的。每个功能和语法决策都旨在让程序员的生活更轻松。Golang 针对并发进行了优化，并且在规模上运行良好。由于单一的标准代码格式， Golang 通常被认为比其他语言更具可读性。自动垃圾收集明显比 Java 或 Python 更有效，因为它与程序同时执行。 2、 Golang 使用什么数据类型？ Golang 使用以下类型：
MethodBoolStringArraySliceStructPointerFunctionInterfaceMapChannel 3、 Go 程序中的包是什么 包 (pkg) 是 Go 工作区中包含 Go 源文件或其他包的目录。源文件中的每个函数、变量和类型都存储在链接包中。每个 Go 源文件都属于一个包，该包在文件顶部使用以下命令声明：
package &lt;packagename&gt; 您可以使用以下方法导入和导出包以重用导出的函数或类型：
import &lt;packagename&gt; Golang 的标准包是fmt，其中包含格式化和打印功能，如Println().
4、Go支持什么形式的类型转换？将整数转换为浮点数。 Go支持显式类型转换以满足其严格的类型要求。
i := 55 //int j := 67.8 //float64 sum := i + int(j) //j is converted to int 5、什么是 Goroutine？你如何停止它？ 一个 Goroutine 是一个函数或方法执行同时旁边其他任何够程采用了特殊的Goroutine 线程。 Goroutine 线程比标准线程更轻量级，大多数 Golang 程序同时使用数千个 Goroutine。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fe554a8968c1b259470bb3ee4094a1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bf523c42a47c3d27f9fb1377a26ad94/" rel="bookmark">
			记录一次脏数据导致flink任务失败的处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前正常运行的flink任务突然失败，任务是从kafka读取数据，写入到mysql
主要报错有：
java.io.IOException: Failed to deserialize consumer record due to ........ Suppressed: java.lang.RuntimeException: Writing records to JDBC failed. ........ Caused by: java.lang.RuntimeException: Writing records to JDBC failed. ........ Caused by: java.sql.BatchUpdateException: Data truncation: #22007 ........ Caused by: com.mysql.cj.jdbc.exceptions.MysqlDataTruncation: Data truncation: #22007 ........ Caused by: com.mysql.cj.jdbc.exceptions.MysqlDataTruncation: Data truncation: #22007 ........ Caused by: java.io.IOException: Failed to deserialize consumer record ConsumerRecord(topic = xxxxx, partition = 2, leaderEpoch = 5, offset = 189180123, CreateTime = 1705403370519, serialized key size = -1, serialized value size = 554, headers = RecordHeaders(headers = [], isReadOnly = false), key = null, value = [B@15c184d1).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bf523c42a47c3d27f9fb1377a26ad94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2582b144f97724284dbd4918810abd74/" rel="bookmark">
			列族：HBase中列族的概念和用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景介绍 HBase是一个分布式、可扩展、高性能的列式存储系统，基于Google的Bigtable设计。HBase提供了一种高效的数据存储和查询方法，可以处理大量数据并提供快速的读写操作。HBase的核心数据结构是列族(column family)，这一概念在HBase中非常重要，对于HBase的性能和可扩展性都有很大影响。本文将详细介绍HBase中列族的概念和用法，并分析其在HBase中的作用和重要性。
2.核心概念与联系 2.1列族的定义 列族(column family)是HBase中最基本的数据结构，它是一组列(column)的集合。列族中的列具有相同的前缀，列族可以理解为一种逻辑上的分组。列族在HBase中有以下几个重要的特点：
列族是HBase中数据存储的基本单位，一个表可以有多个列族。列族内的列名是有序的，列名的前缀相同，即属于同一个列族。列族在HBase中的存储结构是有序的，同一列族的数据会被存储在同一块磁盘空间上，这有助于提高读写性能。列族在HBase中的存储格式是列式存储，即同一列族中的列可以不同时存在，这有助于节省存储空间。 2.2列族与列的关系 列族和列之间的关系是一种包含关系。列族包含了多个列，列具有唯一的列名和列值。在HBase中，列名是由列族名和具体的列名组成的。例如，如果有一个列族名为“user”，那么在这个列族下可以有多个列名，如“name”、“age”、“gender”等。
2.3列族与行(row)的关系 列族和行之间的关系是一种多对一的关系。一个行可以包含多个列族，而一个列族可以包含多个行。在HBase中，行是数据的唯一标识，每个行都有一个唯一的行键(rowkey)。同一个行可以包含多个列族，而同一个列族可以包含多个行。
3.核心算法原理和具体操作步骤以及数学模型公式详细讲解 3.1列族的存储结构 HBase的列族存储结构如下：
+------------+ | 列族1 | +------------+ | 列1_1 | | 列1_2 | | 列1_3 | +------------+ | 列族2 | +------------+ | 列2_1 | | 列2_2 | | 列2_3 | +------------+ ... 在HBase中，同一列族中的列会被存储在同一块磁盘空间上，这有助于提高读写性能。同时，同一列族中的列可以不同时存在，这有助于节省存储空间。
3.2列族的存储格式 HBase的列族存储格式是列式存储，即同一列族中的列可以不同时存在。这种存储格式有助于节省存储空间，因为不需要为每个列分配空间。在HBase中，列的存储格式如下：
+------------+ | 列族1 | +------------+ | 列1_1 | | 列1_2 | | 列1_3 | +------------+ | 列族2 | +------------+ | 列2_1 | | 列2_2 | | 列2_3 | +------------+ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2582b144f97724284dbd4918810abd74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c02779d9d33bb1388487325487ede853/" rel="bookmark">
			Flink与Kafka集成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景介绍 Flink与Kafka集成是一种常见的大数据处理技术，它可以帮助我们实现实时数据处理和分析。Flink是一个流处理框架，可以处理大量数据并提供实时分析功能。Kafka是一个分布式消息系统，可以用于构建实时数据流管道。在本文中，我们将深入了解Flink与Kafka集成的背景、核心概念、算法原理、代码实例等方面。
1.1 Flink的背景 Flink是一个开源的流处理框架，由Apache软件基金会支持。它可以处理大量数据流，并提供实时分析功能。Flink的核心特点是高性能、低延迟和容错性。它可以处理各种数据源，如Kafka、HDFS、TCP流等。Flink还支持多种数据处理操作，如窗口操作、聚合操作、连接操作等。
1.2 Kafka的背景 Kafka是一个分布式消息系统，由LinkedIn公司开发。它可以用于构建实时数据流管道，并支持高吞吐量和低延迟。Kafka的核心特点是可扩展性、可靠性和高性能。它可以处理大量数据，并支持多种数据格式，如文本、JSON、Avro等。Kafka还支持多种数据处理操作，如分区、重复消费等。
1.3 Flink与Kafka的集成背景 Flink与Kafka集成可以帮助我们实现实时数据处理和分析。在大数据场景中，实时数据处理和分析是非常重要的。例如，在网络日志分析、实时监控、实时推荐等场景中，我们需要实时处理和分析数据。Flink与Kafka集成可以帮助我们实现这些场景下的实时数据处理和分析。
2.核心概念与联系 2.1 Flink的核心概念 Flink的核心概念包括数据流、数据源、数据接收器、数据操作、数据接收器等。
数据流：Flink中的数据流是一种无限序列数据，数据流中的数据元素可以被处理、转换和传输。数据源：Flink中的数据源是数据流的来源，数据源可以是文件、socket流、Kafka等。数据接收器：Flink中的数据接收器是数据流的终点，数据接收器可以是文件、socket流、Kafka等。数据操作：Flink中的数据操作包括转换操作、聚合操作、窗口操作、连接操作等。 2.2 Kafka的核心概念 Kafka的核心概念包括主题、分区、消息、生产者、消费者等。
主题：Kafka中的主题是一种逻辑上的分区组，主题中的数据会被分布到多个分区上。分区：Kafka中的分区是一种物理上的分区，每个分区中存储一部分主题的数据。消息：Kafka中的消息是一种数据单元，消息可以是文本、JSON、Avro等格式。生产者：Kafka中的生产者是数据发送方，生产者可以将数据发送到主题中。消费者：Kafka中的消费者是数据接收方，消费者可以从主题中读取数据。 2.3 Flink与Kafka的集成 Flink与Kafka集成可以帮助我们实现实时数据处理和分析。在Flink与Kafka集成中，Flink作为数据处理框架，可以从Kafka中读取数据，并进行实时处理和分析。同时，Flink还可以将处理结果写回到Kafka中，实现端到端的实时数据处理和分析。
3.核心算法原理和具体操作步骤以及数学模型公式详细讲解 3.1 Flink的核心算法原理 Flink的核心算法原理包括数据流计算、数据分区、数据一致性等。
数据流计算：Flink的数据流计算是基于数据流图(DataFlow Graph)的计算模型，数据流图中的节点表示数据操作，边表示数据流。Flink的数据流计算遵循数据流图的计算模型，实现了数据流的处理、转换和传输。数据分区：Flink的数据分区是一种分布式计算模型，数据分区可以帮助我们实现数据的并行处理和负载均衡。Flink的数据分区遵循分区键(Partition Key)的原则，将数据分布到多个任务上。数据一致性：Flink的数据一致性是一种数据处理模型，可以帮助我们实现数据的一致性和可靠性。Flink的数据一致性遵循事件时间语义(Event Time Semantics)的原则，实现了数据的一致性和可靠性。 3.2 Kafka的核心算法原理 Kafka的核心算法原理包括分区、复制、消费者组等。
分区：Kafka的分区是一种物理上的分区，每个分区中存储一部分主题的数据。Kafka的分区可以帮助我们实现数据的并行处理和负载均衡。复制：Kafka的复制是一种数据一致性模型，可以帮助我们实现数据的可靠性和一致性。Kafka的复制遵循副本集(Replica Set)的原则，将数据复制到多个 broker 上。消费者组：Kafka的消费者组是一种消费模型，可以帮助我们实现数据的分布式消费和负载均衡。Kafka的消费者组遵循分区协ordsinator(Partition Coordinator)的原则，将数据分布到多个消费者上。 3.3 Flink与Kafka的集成算法原理 Flink与Kafka集成的算法原理包括 Flink读取Kafka数据、Flink写入Kafka数据等。
Flink读取Kafka数据：Flink可以通过FlinkKafkaConsumer来读取Kafka数据。FlinkKafkaConsumer会从Kafka中读取数据，并将数据转换为Flink数据流。Flink写入Kafka数据：Flink可以通过FlinkKafkaProducer写入Kafka数据。FlinkKafkaProducer会将Flink数据流转换为Kafka数据，并将数据写入Kafka。 4.具体代码实例和详细解释说明 4.1 Flink读取Kafka数据 ```java import org.apache.flink.streaming.api.datastream.DataStream; import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment; import org.apache.flink.streaming.connectors.kafka.FlinkKafkaConsumer;
public class FlinkKafkaConsumerExample { public static void main(String[] args) throws Exception { // 创建执行环境 StreamExecutionEnvironment env = StreamExecutionEnvironment.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c02779d9d33bb1388487325487ede853/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f535e60513fc379d6270995063020693/" rel="bookmark">
			Kafka中的消息延时队列与死信队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景介绍 Kafka是一个分布式流处理平台，可以用于构建实时数据流管道和流处理应用。它的核心功能包括生产者-消费者模式、分区、副本和分布式集群等。在Kafka中，消息延时队列和死信队列是两个重要的概念，它们有助于处理消息的延迟和失效问题。
消息延时队列是指在Kafka中，消息在队列中的存活时间为一定的延时时间，当延时时间到达后，消息会被自动删除。这种特性可以用于处理短暂的延迟和避免队列中的消息积压。
死信队列是指在Kafka中，消息在队列中的存活时间达到设定的过期时间后，仍然没有被消费，这时候消息会被转移到死信队列中，以便进行后续处理，如通知管理员或者存储到数据库等。这种特性可以用于处理消息失效和消费失败的情况。
在本文中，我们将详细介绍Kafka中的消息延时队列与死信队列的核心概念、算法原理、具体操作步骤以及代码实例。
2.核心概念与联系 2.1消息延时队列 消息延时队列是指在Kafka中，消息在队列中的存活时间为一定的延时时间，当延时时间到达后，消息会被自动删除。这种特性可以用于处理短暂的延迟和避免队列中的消息积压。
消息延时队列的主要应用场景是处理短暂的延迟和避免队列中的消息积压。例如，在实时推送消息的场景中，由于网络延迟或者消费者处理能力不足，可能会导致消息在队列中积压。在这种情况下，可以使用消息延时队列来自动删除过期的消息，以减少队列的积压。
2.2死信队列 死信队列是指在Kafka中，消息在队列中的存活时间达到设定的过期时间后，仍然没有被消费，这时候消息会被转移到死信队列中，以便进行后续处理，如通知管理员或者存储到数据库等。这种特性可以用于处理消息失效和消费失败的情况。
死信队列的主要应用场景是处理消息失效和消费失败。例如，在实时推送消息的场景中，如果消息在设定的时间内没有被消费，可能是由于消费者故障或者网络问题导致的。在这种情况下，可以使用死信队列来将这些失效的消息转移到死信队列中，以便进行后续处理。
2.3联系 消息延时队列和死信队列都是Kafka中用于处理消息的特性。它们的主要区别在于，消息延时队列是根据消息的存活时间来自动删除消息的，而死信队列是根据消息的过期时间和消费情况来将消息转移到死信队列中的。
3.核心算法原理和具体操作步骤以及数学模型公式详细讲解 3.1消息延时队列的算法原理 消息延时队列的算法原理是基于消息的存活时间来自动删除消息的。具体来说，在Kafka中，每个消息都有一个时间戳，这个时间戳表示消息在队列中的存活时间。当消息在队列中的时间超过设定的延时时间后，消息会被自动删除。
数学模型公式：
$$ T{expire} = T{current} + \Delta T $$
其中，$T{expire}$ 表示消息的过期时间，$T{current}$ 表示当前时间，$\Delta T$ 表示延时时间。
具体操作步骤：
在Kafka中创建一个消息队列。为队列设置延时时间。将消息推送到队列中，同时为消息设置时间戳。当消息在队列中的时间超过设定的延时时间后，消息会被自动删除。 3.2死信队列的算法原理 死信队列的算法原理是基于消息的过期时间和消费情况来将消息转移到死信队列中的。具体来说，在Kafka中，每个消息都有一个时间戳，这个时间戳表示消息的过期时间。当消息在设定的时间内没有被消费，可以将这些消息转移到死信队列中。
数学模型公式：
$$ T{expire} = T{current} + \Delta T $$
其中，$T{expire}$ 表示消息的过期时间，$T{current}$ 表示当前时间，$\Delta T$ 表示过期时间。
具体操作步骤：
在Kafka中创建一个消息队列。为队列设置过期时间。将消息推送到队列中，同时为消息设置时间戳。当消息在设定的过期时间内没有被消费时，将消息转移到死信队列中。 4.具体代码实例和详细解释说明 4.1消息延时队列的代码实例 ```python from kafka import KafkaProducer, KafkaConsumer import time
创建生产者 producer = KafkaProducer(bootstrap_servers='localhost:9092')
创建消费者 consumer = KafkaConsumer('delayqueue', bootstrapservers='localhost:9092')
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f535e60513fc379d6270995063020693/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9de22a914c808576de92a23856a6052c/" rel="bookmark">
			【文档数据库】ES和MongoDB的对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.由文档存储牵出的问题
2.什么是MongoDB？
3.ES和MongoDB的对比
1.由文档存储牵出的问题 本文或者说关于mongodb的这个系列文章的源头：
前面我们聊过了分布式链路追踪系统，在基于日志实现的分布式链路追踪的方式seluth+zipkin中为了防止数据丢失，需要将数据持久化。我们给出的是持久化进mysql中的示例。
【JAVA】分布式链路追踪技术概论-CSDN博客
https://bugman.blog.csdn.net/article/details/135258207?spm=1001.2014.3001.5502
后面我们发现存放日志以及需要进行后期统计这个场景来说的话关系型数据库是不合适的，于是引出了用ES系列：
https://bugman.blog.csdn.net/article/details/135342256?spm=1001.2014.3001.5502
https://bugman.blog.csdn.net/article/details/135425284?spm=1001.2014.3001.5502
https://bugman.blog.csdn.net/article/details/135515805?spm=1001.2014.3001.5502
https://bugman.blog.csdn.net/article/details/135581380?spm=1001.2014.3001.5502
聊完ES后，这时候我们难免就避不开mongodb这个热门的文档数据库，什么是MongoDB，MongoDB的核心概念，ES和MongoDB的对比，将会是本文的核心内容。
2.什么是MongoDB？ MongoDB（由“Humongous Database”缩写而来）是一种开源的、面向文档的 NoSQL 数据库系统，自4.0版本开始支持ACID。它在设计上采用了分布式文件存储的思想，适用于大规模数据的存储和处理。
说的直白点，MongoDB在设计的时候就是冲着解决海量文档的存储来的。
mongodb的架构如下：
database（数据库）：数据库是一个仓库，里面可以存放集合。
collection（集合）：类似于数组，可以在集合中存放文档。
document（文档）：mongodb最小的单位，我们存储和操作的内容都是文档。
数据库类比数据库，集合类比表，文档类比一条数据。
数据库和集合都不需要我们手动创建，当我们创建文档时，文档所在的数据库或者集合不存在，会自动创建数据库和集合。
mongodb的数据结构：
MongoDB的数据结构是其用来应对海量文档存储的核心，其是以类JSON的方式来存储数据，也就是BSON。BSON是二进制的，这样做的目的是为了增强存储能力，具体的细节后文说。先来看看JSON和BSON的比较：
假设我们有如下的 JSON 对象，用于描述一个人的基本信息：
这个 JSON 对象包含了一些基本的数据类型，如字符串、数字、布尔值、对象和数组。
{
"name": "John Doe",
"age": 30,
"isStudent": false,
"birthday": "1990-01-01",
"address": {
"street": "123 Main St",
"city": "Anytown"
},
"hobbies": ["reading", "cycling"]
}
现在，我们将同样的数据转换为 BSON 格式。在 BSON 中，我们可以使用一些 JSON 中不存在的数据类型。以下是 BSON 版本的同一数据，包含一些 BSON 特有的字段（请注意，这是概念性的表示，因为 BSON 实际上是二进制格式，无法以纯文本形式直观展示）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9de22a914c808576de92a23856a6052c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcc18385157749828695e5b2de0341d3/" rel="bookmark">
			Python中Matplotlib的plot函数参数详解及代码示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数据可视化中，matplotlib.pyplot模块的plot函数是一个非常重要且常用的工具，用于绘制2D图形。这个函数支持许多参数，控制着绘图的各个方面，从线型到颜色再到标记等，提供了丰富的功能。
1. 基本的 plot 函数用法 回顾一下plot函数的基本用法。在最简单的情况下，它接受两个参数，分别是 x 轴和 y 轴的数据，用于绘制折线图。
import matplotlib.pyplot as plt # 示例数据 x = [1, 2, 3, 4, 5] y = [2, 4, 6, 8, 10] # 使用 plot 函数绘制折线图 plt.plot(x, y) # 显示图形 plt.show() 这段代码创建了一个简单的折线图，其中 x 是横轴数据，y 是纵轴数据。接下来，我们将介绍一些常用的参数，以及它们的作用和用法。
2. plot 函数的常用参数 2.1. 颜色 (color) color参数用于指定线条的颜色。它可以使用颜色名称、十六进制值或RGB元组等形式。
plt.plot(x, y, color='red') # 使用颜色名称 plt.plot(x, y, color='#FF0000') # 使用十六进制值 plt.plot(x, y, color=(1, 0, 0)) # 使用RGB元组 2.2. 线型 (linestyle) linestyle参数用于指定线条的样式，例如实线、虚线、点划线等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcc18385157749828695e5b2de0341d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2580e8705251d9492b8ff3160f8ace1/" rel="bookmark">
			毕业设计- 基于深度学习的小样本时间序列预测算法 - Attention
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
课题背景与意义
课题实现
一、数据集
二、设计思路
三、相关代码示例
最后💯
前言 📅大四是整个大学期间最忙碌的时光,一边要忙着准备考研,考公,考教资或者实习为毕业后面临的就业升学做准备,一边要为毕业设计耗费大量精力。近几年各个学校要求的毕设项目越来越难,有不少课题是研究生级别难度的,对本科同学来说是充满挑战。为帮助大家顺利通过和节省时间与精力投入到更重要的就业和考试中去,学长分享优质的选题经验和毕设项目与技术思路。
🚀对毕设有任何疑问都可以问学长哦!
选题指导:
最新最全计算机专业毕设选题精选推荐汇总
大家好,这里是海浪学长毕设专题,本次分享的课题是
🎯基于深度学习的小样本时间序列预测算法
课题背景与意义 近年来，利用深度学习进行时间序列预测在多个领域取得了广泛成功，但由于数据难以收集，样本不足成为一个挑战。为了解决这个问题，研究者提出了小样本学习(FSL)方法。其中，数据增强是一种常用的方法，通过增加训练数据规模来有效避免过拟合问题。在图像领域，数据增强方法如几何变换、样本合成等已被广泛研究和应用。在回归问题上，添加噪声或进行数据插值等方法也被用于数据增强。综上所述，数据增强是解决时间序列预测中小样本问题的一种有效方法。
课题实现 一、数据集 由于在网络上找不到现有的合适数据集，我决定自己收集数据并创建一个全新的数据集，用于小样本时间序列预测系统的研究。我的数据集包含了各种时间序列场景的观测数据，其中包括多个传感器的测量值和其他相关环境变量。通过现场采集数据，我能够捕捉到真实的时间序列情况和多样的环境条件，这将为我的研究提供更准确、可靠的数据。
二、设计思路 本次设计提出了一种数据增强网络，旨在解决时间序列预测中的小样本问题。该方法结合了注意力机制、时间卷积网络和长短期记忆网络，通过在TimeGAN生成对抗网络中引入Soft-Attention机制来解决动态信息丢失的问题。
该方法的关键点包括：
引入Soft-Attention机制： Soft-Attention机制在TimeGAN中的加入可以有效地解决时间序列数据中的动态信息丢失问题，并提高生成数据的质量。传统的生成对抗网络（GAN）在生成时间序列数据时，往往无法捕捉到序列中的长期依赖关系和动态变化。而Soft-Attention机制可以帮助网络在生成过程中更加关注序列中重要的时间步，从而更好地保留序列的动态信息。
Soft-Attention机制通过引入注意力权重来调整模型对序列中不同时间步的关注程度。在TimeGAN中，Soft-Attention机制可以用于生成器网络，使其能够根据输入的随机向量生成与时间序列数据中动态变化相匹配的序列。通过学习注意力权重，生成器可以更加关注序列中重要的时间步，从而更好地模拟真实数据的动态特征。
时间卷积结构与Self-Attention机制融合： 将时间卷积网络与Self-Attention机制相结合可以提高数据生成效果。时间卷积网络在处理时间序列数据时具有很好的性质，它可以捕捉到数据中的时序特征和局部模式。通过卷积层的滑动窗口操作，时间卷积网络能够提取出不同时间尺度上的特征，从而更好地建模时间序列数据的动态特性。
通过将时间卷积网络和Self-Attention机制相结合，ATCLSTM-TimeGAN能够充分利用它们各自的优势，提高数据生成的效果。时间卷积网络能够处理时序特征和局部模式，而Self-Attention机制能够捕捉长距离依赖关系。这种结合有助于生成更真实、更准确的时间序列数据，增强了模型对数据动态特性的建模能力。
验证生成数据的真实性与有用性： 通过比较不同数据增强方法生成的数据分布差异以及在预测任务上的效果，可以验证生成数据的真实性和对预测任务的有用性。不同的数据增强方法可以通过生成多样化的合成数据，来模拟真实数据的分布特征。
通过对比生成数据与真实数据的分布差异，可以评估生成数据的真实性。如果生成数据能够与真实数据在分布上相似，即生成数据能够覆盖真实数据的多样性和特征，那么可以认为生成数据具有较高的真实性。
此外，还需要验证生成数据在预测任务上的有效性。通过将生成数据与真实数据混合，构建更丰富的训练集，并将其用于预测任务，可以评估生成数据对于提升预测模型性能的贡献。如果生成数据能够有效地提升预测模型的性能，即生成数据在预测任务中具有一定的可用性和有效性，那么可以进一步证明生成数据的有用性。
总的来说，ATCLSTM-TimeGAN是一种结合了注意力机制、时间卷积网络和长短期记忆网络的数据增强方法，旨在解决时间序列预测中的小样本问题。通过在TimeGAN中引入Soft-Attention机制，并融合时间卷积结构和Self-Attention机制，该方法能够生成更真实、有用的时间序列数据，并提高预测任务的效果。
三、相关代码示例 # 合并真实数据和生成数据 X_combined_method1 = np.vstack((X_real, X_gen_method1)) y_combined_method1 = np.concatenate((y_real, y_gen_method1)) X_combined_method2 = np.vstack((X_real, X_gen_method2)) y_combined_method2 = np.concatenate((y_real, y_gen_method2)) # 划分训练集和测试集 X_train_method1, X_test_method1, y_train_method1, y_test_method1 = train_test_split( X_combined_method1, y_combined_method1, test_size=0.2, random_state=42) X_train_method2, X_test_method2, y_train_method2, y_test_method2 = train_test_split( X_combined_method2, y_combined_method2, test_size=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2580e8705251d9492b8ff3160f8ace1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d22217caa6ffde0d598f0b5c51431a9/" rel="bookmark">
			Web 服务器的搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.web的简介
2.搭建web服务器实现访问网站　2.1 环境准备　2.2搭建http服务　2.3搭建https服务
1.web的简介 1.1什么是web
Web（全称为World Wide Web）是一种基于互联网的信息交流和共享方式。它是由许多相互连接的网页组成的系统，这些网页包含了文本、图像、音频、视频和其他形式的多媒体内容。Web 使用一种称为超文本的方式来链接网页，使得用户可以通过点击链接在不同的网页之间导航，并访问到不同的内容。
Web 的核心技术是HTTP（Hypertext Transfer Protocol，超文本传输协议），它定义了在网络上进行文档传输的规则。通过浏览器等客户端软件，用户可以使用HTTP与Web服务器进行通信，请求和接收网页内容，并在自己的设备上进行显示和交互。
1.2什么是http
HTTP（Hypertext Transfer Protocol）是一种在计算机网络上进行数据通信的应用层协议，是Web通信的基础。HTTP协议是为 Web 浏览器和 Web 服务器之间传输数据而特别设计的。HTTP协议通常运行在TCP/IP协议栈之上，在客户端和服务器之间进行数据交换。HTTP协议使用请求（request）和响应（response）的方式进行通信，客户端发送请求，并等待服务端回应。
HTTP协议以设计简单、通用、快速、灵活等特点广泛应用于万维网上，通过浏览器或是其他工具可以方便地访问网站、获取资源、交互数据等。HTTP协议支持多种不同的请求方式，如GET、POST、PUT、DELETE等，也支持多种数据格式的传输，如HTML、XML、JSON等，因此被广泛应用于Web应用程序的开发中。
1.3什么是https
HTTPS（Hypertext Transfer Protocol Secure）是一种加密通信协议，是HTTP协议的安全版本，它提供了对 Web 客户端和服务器之间数据传输过程的加密保护和完整性验证。在HTTPS协议之下，通过 SSL/TLS 协议在传输层对数据进行加密，从而保障客户端和服务器之间的通信安全。
和普通的 HTTP 协议不同，HTTPS 在传输数据时会对数据进行加密，使得数据传输过程中不易被窃取或篡改，能够更好地保障用户的隐私安全。通常，HTTPS 协议在 Web 应用程序中被用于处理用户敏感信息，比如登录密码、银行卡信息、个人信息等。
为了保证网站使用 HTTPS 协议的合法性，Web浏览器会在访问网站时验证网站的安全证书，这个证书包括了网站的身份和公钥。如果验证通过，浏览器会自动将数据通过公钥进行加密，然后再发送给服务器。同时，HTTPS 协议的应用也需要在服务器上安装 SSL/TLS 证书，用于识别服务器身份，并通过 SSL/TLS 协议建立加密的数据传输通道。
2.搭建web服务器实现访问网站 2.1 环境准备 2.1.0 要求介绍
1.基于域名www.openlab.com可以访问网站内容为 welcome to openlab!!!
2.给该公司创建三个网站目录分别显示学生信息，教学资料和缴费网站，基于www.openlab.com/student 网站访问学生信息，www.openlab.com/data网站访问教学资料 www.openlab.com/money网站访问缴费网站。
3.（1）学生信息网站只有song和tian两人可以访问，其他网站所有用户用能访问。
（2）访问缴费网站实现数据加密基于https访问。
2.1.1进行挂载并关闭防火墙和selinux
[root@localhost ~]# mount /dev/sr0 /mnt mount: /mnt: WARNING: source write-protected, mounted read-only.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d22217caa6ffde0d598f0b5c51431a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/319b29360715ef8098ad4a8009ae4916/" rel="bookmark">
			【SpringBoot】Bean 是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		感兴趣的话，可以看我另外一篇关于 Bean 的文章：【Java基础】Spring 中 Bean 的理解与使用
一、Bean 定义 Bean 作为 Spring 框架面试中不可或缺的概念，其本质上是指代任何被 Spring 加载生成出来的对象。（本质上区别于 Java Bean，Java Bean 是对于 Java 类的一种规范定义。）Spring Bean 代表着 Spring 中最小的执行单位，其加载、作用域、生命周期的管理都由 Spring 操作。可见 Spring Bean 在整个 Spring 框架中的重要地位。
二、设计目的 在了解 Spring 是如何管理 Bean 组件之前，咋们有必要了解为什么 Spring 需要设计出来这么一套机制。假设当前咋们是某个大家族里的公子转世，天天过着衣来伸手饭来张口的生活。在你的家里有一位无微不至的大管家，无论你需要什么，只要跟管家说一下，他就能给你找来。
有一天，你突然饿了，于是你对着管家吩咐道：“本少爷想吃帝王蟹。”。管家听到命令后，吭哧吭哧的给你搞来了。至于管家到底是抓来的、还是买来的，作为少爷的你自然是不关注的。
与此相类似的，如果把程序员想象成少爷，那么 SpringBoot 就是我们忠诚的管家先生。当我们需要用容器内的对象时，只需要“告诉” Spring，Spring 就能自动帮我们加载，我们则无需考虑这个 Bean 到底是如何加载的、什么时候回收等细节逻辑。我们只需要使用即可。由此一来，降低了使用门槛，也减少了对于细节的一些管理。
三、名词介绍 定义：Bean 是在 Spring 容器中被实例化、管理和维护的对象。一个 Bean 可以是任何普通的 Java 对象，例如 POJO、Service、Respository、Controller 等等。将一个类声明为 Bean 的方式可以是在类级别上使用 ‘@Component’ 注解或其派生注解（‘@Service’、‘@Repository’、‘@Controller’等），也可以是通过配置文件进行显式的声明。实例化：Spring 容器负责实例化 Bean。当应用程序启动时，Spring 容器会根据配置信息或注解扫描的结果，找到并实例化所有被标记为 Bean 的类，并将它们加入容器中。实例化的过程由 Spring 的 IoC 容器负责。管理：一旦 Bean 被实例化，Spring 容器将负责管理 Bean 的生命周期和依赖关系。它会根据配置文件或注解的信息，自动解决 Bean 之间的依赖关系，确保在需要的时候正确的注入依赖。Spring 容器还会负责销毁不再需要的 Bean。依赖注入：依赖注入是 Spring 框架的一个重要特性，它允许通过自动或显式配置的方式将 Bean 的依赖项注入到其它 Bean 中。依赖注入可以通过构造函数注入、Setter 方法注入或字段注入的方式实现，其中最常见的是使用 ‘@Autowired’注解进行注入。作用域：Spring 框架提供了多种作用域（scope）来管理 Bean 的生命周期。常见的作用域包括单例（Singleton）、原型（Prototype）、会话（Session）、请求（Request）等。默认情况下，Bean 是单例的，即每个容器中只存在一个实例。但可以根据需要配置其它作用域。 @Component // 默认为单例 public class MyBean { // 代码.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/319b29360715ef8098ad4a8009ae4916/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de0e3559791e6082aeb2431438ff0d40/" rel="bookmark">
			AIGC内容分享(五十一)：音韵如诗如斯：AIGC音乐创新工具之Suno
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Suno是谁？
先听为快
如何使用Suno
歌曲的结构及如何使用Metatags
Suno收费吗？
Suno的模型
朋友与对手
结语
AI生成音乐是一种创新的音乐创作方式，通过人工智能技术，使任何人都能够轻松地创作出引人入胜的音乐作品。与传统的音乐创作方式不同，AI生成音乐不要求用户具备专业的音乐知识或乐器技能。
Suno是谁？ Suno是一家人工智能公司，总部位于美国马萨诸塞州的剑桥，团队由音乐家和人工智能专家组成。
Suno创新的音乐平台，为任何对音乐充满热情的人提供了一个制作优秀音乐的机会。
无论是音乐素人还是专业达人，通过Suno，用户可以轻松运用简单的创意和想象力，从零开始创作属于自己的音乐。
与传统音乐创作方式不同，AI生成音乐不需要用户学习复杂的乐理或演奏技能，使创作者能够更专注地表达他们的音乐思想，并将这些思想转化为动听的旋律。
这种创作方式不仅为音乐注入更多个性和多样性，同时为那些渴望追求音乐梦想的人提供了更为便捷和灵活的途径。
Suno让每个怀揣音乐梦想和激情的个体都得以成为自己音乐创作的艺术家，共同融入这场音乐创作的浪漫变革之中。
2023年10月，Suno社区已经创作了100万首歌曲，到2023年11月，生成的歌曲数量已经超过400万首。
先听为快 在探索Suno创作方法之前，让我们先欣赏两首我今早使用Suno创作首发的歌曲。
一首英文民谣歌曲。
一首中文布鲁斯歌曲。
感受如何？
如何使用Suno Suno的使用方式包括两种：一是通过访问app.suno.ai网站，另一是通过Discord。
截至2023年12月，Suno生成音乐作品（1个Chirps）的最大时长为80秒，如果需要延长，每次可以延续60秒。
1. Web访问（app.suno.ai）
首先，打开首页，点击“Create”按钮，即可开始创作。
如果是第一次使用，需要创建一个帐号。你可以选择使用Google、Microsoft或Discord帐号进行登录。
登录完成后，点击“Create”按钮，开始创作。
在“Song Description”中，你可以描述你想要的歌曲的风格和主题。
“Song Description”中描述歌曲的风格主题。
例如，你可以输入：“轻快的流行曲，夏日海滩的感觉。”然后，点击“Create”按钮。
在右侧，你会看到两首新创作完成的歌曲，可以播放一下看看哪个效果更好。
你可以试听它们，感受创作的成果。
使用定制模式
通过使用“Custom Mode”，你可以提供详细信息，包括歌词和音乐风格。
生成的结果还算不错，这就是我们在开头听到的那首英文民谣。
在当前版本下，AI创造的歌曲时长为1分20秒。如果你想要延长歌曲，只需点击歌曲中的三个小圆点，然后选择“Continue From This Clip”。接着，会弹出一个包含“Continue From”的提示信息和按钮，点击即可进行延长。
2. Discord使用方式
这种使用方式和绘图工具Midjourney一样，访问discord上相应的server和频道。
先访问，https://discord.gg/suno-ai，然后选择一个Generate频道，开始创作：
1. 在消息栏中输入 `/chirp`
2. 按下 *Enter`，将会弹出一个窗口
3. 输入你希望采用的音乐风格，然后加入歌词。上面的提示框是自己输入歌词，下面则是直接求助ChatGPT生成歌词。
ChanGPT + Suno，AI工具都变成一条龙服务了。
4. 按下 `Submit`
歌曲的结构及如何使用Metatags 我们先了解一下歌曲歌词的一般结构。
通常，一首歌曲的构成包括：前奏 → 主歌 → 导歌 → 副歌 → 间奏 → 主歌 → 导歌 → 副歌 → 桥段 → 副歌 → 尾奏。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de0e3559791e6082aeb2431438ff0d40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/921fc267034510af52a6e34b5fa11e6e/" rel="bookmark">
			快速上手！LLaMa-Factory最新微调实践，轻松实现专属大模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.为什么要对Yuan2.0做微调？ Yuan2.0（https://huggingface.co/IEITYuan）是浪潮信息发布的新一代基础语言大模型，该模型拥有优异的数学、代码能力。自发布以来，Yuan2.0已经受到了业界广泛的关注。当前Yuan2.0已经开源参数量分别是102B、51B和2B的3个基础模型，以供研发人员做进一步的开发。
LLM（大语言模型）微调方案是解决通用大模型落地私有领域的一大利器。基于开源大模型的微调，不仅可以提升LLM对于指令的遵循能力，也能通过行业知识的引入，来提升LLM在专业领域的知识和能力。当前，学界和业界已经基于LLM开发及实践出了众多的微调方法，如指令微调、基于人类反馈的强化学习（RLHF，Reinforcement Learning from Human Feedback）、直接偏好优化（DPO，Direct Preference Optimization）等。内存和计算资源是制约LLM微调的两大瓶颈，通过使用高效微调（PEFT，Parameter-Efficient Fine-Tuning）方案可以有效缓解上述问题，当前业界已经出现了LoRA和QLoRA等高效微调技术，可以实现在单张GPU上完成千亿参数的微调训练。因此，一个能够实现上述功能的简洁、高效、易用、与时俱进的微调框架是开展LLM微调工作的最佳抓手。
LLaMA-Factory（https://github.com/hiyouga/LLaMA-Factory）是零隙智能（SeamLessAI）开源的低代码大模型训练框架，它集成了业界最广泛使用的微调方法和优化技术，并支持业界众多的开源模型的微调和二次训练，开发者可以使用私域数据、基于有限算力完成领域大模型的定制开发。LLaMA-Factory还为开发者提供了可视化训练、推理平台，一键配置模型训练，实现零代码微调LLM。自2023年5月开源以来，成为社区内最受欢迎的微调框架，github星数已超9K。
目前LLaMA-Factory已完成与Yuan2.0的适配微调，通过使用LLaMA-Factory可以方便快捷的对不同尺寸的Yuan2.0基础模型进行全量微调及高效微调。本文将介绍如何使用alpaca中文数据集、ShareGPT数据集和llama-factory提供的模型认知数据集，对Yuan2.0进行微调，来构建自己的人工智能助手。
2.资源需求评估和环境准备 下面的表格给出了使用llama-factory微调Yuan2.0模型的最低显存需求。大家可以根据手头GPU资源的显存情况来评估使用的模型以及对应的微调算法。比如选择Yuan2.0-2B模型，使用QLoRA微调方法，只需要最小5GB显存，当前业界绝大多数的GPU都可以满足。
表格2‑1：Yuan2.0不同微调策略所需要的最低显存需求评估。
微调方法
Yuan2.0-2B
Yuan2.0-51B
Yuan2.0-102B
全参微调
40GB
1000GB
2000GB
LoRA
7GB
120GB
230GB
QLoRA
5GB
40GB
80GB
Llama-factory的部署可以参考其github上的部署文档，yuan2.0的github上也提供了完整的llama-factory的环境部署流程（https://github.com/IEIT-Yuan/Yuan-2.0/blob/main/docs/Yuan2_llama-factory.md）可供参考。在本文的部署实践中，使用了ngc-torch2308作为基础docker镜像。
3.Yuan2.0 Lora微调Step by step流程 下面以Yuan2.0-2B模型的LoRA微调为例，进行step by step的流程介绍。
Step by Step ，yuan2.0模型微调演示demo
step1：基于torch2308镜像启动容器，可以映射容器内的7860端口到宿主机，以便后期微调及推理测试使用；克隆llama-factory项目，使用pip清华源，按照如下命令安装相关依赖。 cd /workspace/sa/LLM_test/LLaMA-Factory-main vim src/train_web.py #如下文件内容可以修改server_port为自己映射的端口 from llmtuner import create_ui def main(): demo = create_ui() demo.queue() demo.launch(server_name="0.0.0.0",server_port=6666, share=False, inbrowser=True) if __name__ == "__main__": main() #使用如下命令在终端启动web服务，并在浏览器中打开web界面 python src/train_web.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/921fc267034510af52a6e34b5fa11e6e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/526/">«</a>
	<span class="pagination__item pagination__item--current">527/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/528/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>